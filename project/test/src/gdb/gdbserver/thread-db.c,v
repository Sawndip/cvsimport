head	1.47;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.47
	gdb_7_6-2013-04-26-release:1.47
	gdb_7_6-branch:1.47.0.2
	gdb_7_6-2013-03-12-branchpoint:1.47
	gdb_7_5_1-2012-11-29-release:1.43
	gdb_7_5-2012-08-17-release:1.43
	gdb_7_5-branch:1.43.0.2
	gdb_7_5-2012-07-18-branchpoint:1.43
	gdb_7_4_1-2012-04-26-release:1.42.2.1
	gdb_7_4-2012-01-24-release:1.42.2.1
	gdb_7_4-branch:1.42.0.2
	gdb_7_4-2011-12-13-branchpoint:1.42
	gdb_7_3_1-2011-09-04-release:1.39
	gdb_7_3-2011-07-26-release:1.39
	gdb_7_3-branch:1.39.0.2
	gdb_7_3-2011-04-01-branchpoint:1.39
	gdb_7_2-2010-09-02-release:1.36
	gdb_7_2-branch:1.36.0.2
	gdb_7_2-2010-07-07-branchpoint:1.36
	gdb_7_1-2010-03-18-release:1.33
	gdb_7_1-branch:1.33.0.2
	gdb_7_1-2010-02-18-branchpoint:1.33
	gdb_7_0_1-2009-12-22-release:1.23
	gdb_7_0-2009-10-06-release:1.23
	gdb_7_0-branch:1.23.0.4
	gdb_7_0-2009-09-16-branchpoint:1.23
	arc-sim-20090309:1.15
	msnyder-checkpoint-072509-branch:1.23.0.2
	msnyder-checkpoint-072509-branchpoint:1.23
	arc-insight_6_8-branch:1.15.0.14
	arc-insight_6_8-branchpoint:1.15
	insight_6_8-branch:1.15.0.12
	insight_6_8-branchpoint:1.15
	reverse-20081226-branch:1.16.0.2
	reverse-20081226-branchpoint:1.16
	multiprocess-20081120-branch:1.15.0.10
	multiprocess-20081120-branchpoint:1.15
	reverse-20080930-branch:1.15.0.8
	reverse-20080930-branchpoint:1.15
	reverse-20080717-branch:1.15.0.6
	reverse-20080717-branchpoint:1.15
	msnyder-reverse-20080609-branch:1.15.0.4
	msnyder-reverse-20080609-branchpoint:1.15
	drow-reverse-20070409-branch:1.9.0.2
	drow-reverse-20070409-branchpoint:1.9
	gdb_6_8-2008-03-27-release:1.15
	gdb_6_8-branch:1.15.0.2
	gdb_6_8-2008-02-26-branchpoint:1.15
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.2
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.2
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.4.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.4.2.1
	gdb-csl-sourcerygxx-4_1-17:1.4.2.1
	gdb-csl-20060226-branch-local-2:1.4.2.1
	gdb-csl-sourcerygxx-4_1-14:1.4.2.1
	gdb-csl-sourcerygxx-4_1-13:1.4.2.1
	gdb-csl-sourcerygxx-4_1-12:1.4.2.1
	gdb-csl-sourcerygxx-3_4_4-21:1.4.2.1
	gdb_6_5-20060621-release:1.5
	gdb-csl-sourcerygxx-4_1-9:1.4.2.1
	gdb-csl-sourcerygxx-4_1-8:1.4.2.1
	gdb-csl-sourcerygxx-4_1-7:1.4.2.1
	gdb-csl-arm-2006q1-6:1.4.2.1
	gdb-csl-sourcerygxx-4_1-6:1.4.2.1
	gdb-csl-symbian-6_4_50_20060226-10:1.4.2.1
	gdb-csl-symbian-6_4_50_20060226-9:1.4.2.1
	gdb-csl-symbian-6_4_50_20060226-8:1.4.2.1
	gdb-csl-coldfire-4_1-11:1.4.2.1
	gdb-csl-sourcerygxx-3_4_4-19:1.4.2.1
	gdb-csl-coldfire-4_1-10:1.4.2.1
	gdb_6_5-branch:1.5.0.10
	gdb_6_5-2006-05-14-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-5:1.4.2.1
	nickrob-async-20060513-branch:1.5.0.8
	nickrob-async-20060513-branchpoint:1.5
	gdb-csl-sourcerygxx-4_1-4:1.4.2.1
	msnyder-reverse-20060502-branch:1.5.0.6
	msnyder-reverse-20060502-branchpoint:1.5
	gdb-csl-morpho-4_1-4:1.4.2.1
	gdb-csl-sourcerygxx-3_4_4-17:1.4.2.1
	readline_5_1-import-branch:1.5.0.4
	readline_5_1-import-branchpoint:1.5
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.4.2.1
	gdb-csl-symbian-20060226-branch:1.4.2.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.4.2.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.4.2.1
	msnyder-reverse-20060331-branch:1.5.0.2
	msnyder-reverse-20060331-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.4.0.4
	gdb-csl-available-20060303-branchpoint:1.4
	gdb-csl-20060226-branch:1.4.0.2
	gdb-csl-20060226-branchpoint:1.4
	gdb_6_4-20051202-release:1.3
	msnyder-fork-checkpoint-branch:1.3.0.8
	msnyder-fork-checkpoint-branchpoint:1.3
	gdb-csl-gxxpro-6_3-branch:1.3.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.3
	gdb_6_4-branch:1.3.0.4
	gdb_6_4-2005-11-01-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.3.0.2
	gdb-csl-arm-20051020-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.2.0.6
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.2
	gdb-csl-arm-20050325-2005-q1a:1.2
	csl-arm-20050325-branch:1.2.0.4
	csl-arm-20050325-branchpoint:1.2
	gdb-post-i18n-errorwarning-20050211:1.2
	gdb-pre-i18n-errorwarning-20050211:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.2
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.1
	drow_intercu-merge-20040915:1.1
	jimb-gdb_6_2-e500-branch:1.1.0.72
	jimb-gdb_6_2-e500-branchpoint:1.1
	gdb_6_2-20040730-release:1.1
	gdb_6_2-branch:1.1.0.68
	gdb_6_2-2004-07-10-gmt-branchpoint:1.1
	gdb_6_1_1-20040616-release:1.1
	gdb_6_1-2004-04-05-release:1.1
	drow_intercu-merge-20040402:1.1
	drow_intercu-merge-20040327:1.1
	ezannoni_pie-20040323-branch:1.1.0.66
	ezannoni_pie-20040323-branchpoint:1.1
	cagney_tramp-20040321-mergepoint:1.1
	cagney_tramp-20040309-branch:1.1.0.64
	cagney_tramp-20040309-branchpoint:1.1
	gdb_6_1-branch:1.1.0.62
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1
	drow_intercu-20040221-branch:1.1.0.60
	drow_intercu-20040221-branchpoint:1.1
	cagney_bfdfile-20040213-branch:1.1.0.58
	cagney_bfdfile-20040213-branchpoint:1.1
	drow-cplus-merge-20040208:1.1
	carlton_dictionary-20040126-merge:1.1
	cagney_bigcore-20040122-branch:1.1.0.56
	cagney_bigcore-20040122-branchpoint:1.1
	drow-cplus-merge-20040113:1.1
	drow-cplus-merge-20031224:1.1
	drow-cplus-merge-20031220:1.1
	carlton_dictionary-20031215-merge:1.1
	drow-cplus-merge-20031214:1.1
	carlton-dictionary-20031111-merge:1.1
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.1.0.54
	kettenis_sparc-20030918-branchpoint:1.1
	carlton_dictionary-20030917-merge:1.1
	ezannoni_pie-20030916-branchpoint:1.1
	ezannoni_pie-20030916-branch:1.1.0.52
	cagney_x86i386-20030821-branch:1.1.0.50
	cagney_x86i386-20030821-branchpoint:1.1
	carlton_dictionary-20030805-merge:1.1
	carlton_dictionary-20030627-merge:1.1
	gdb_6_0-branch:1.1.0.48
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.46
	jimb-ppc64-linux-20030613-branchpoint:1.1
	cagney_convert-20030606-branch:1.1.0.44
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.42
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.40
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.38
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.36
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.34
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.32
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.30
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.28
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.26
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.24
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.22
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.20
	cagney_offbyone-20030303-branchpoint:1.1
	carlton_dictionary-20030207-merge:1.1
	interps-20030203-mergepoint:1.1
	interps-20030202-branch:1.1.0.18
	interps-20030202-branchpoint:1.1
	cagney-unwind-20030108-branch:1.1.0.16
	cagney-unwind-20030108-branchpoint:1.1
	carlton_dictionary-20021223-merge:1.1
	gdb_5_3-2002-12-12-release:1.1
	carlton_dictionary-20021115-merge:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.14
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-20020927-merge:1.1
	carlton_dictionary-branch:1.1.0.12
	carlton_dictionary-20020920-branchpoint:1.1
	gdb_5_3-branch:1.1.0.10
	gdb_5_3-2002-09-04-branchpoint:1.1
	kseitz_interps-20020829-merge:1.1
	cagney_sysregs-20020825-branch:1.1.0.8
	cagney_sysregs-20020825-branchpoint:1.1
	readline_4_3-import-branch:1.1.0.6
	readline_4_3-import-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.4
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.47
date	2013.02.12.15.03.12;	author palves;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2012.11.09.02.58.50;	author qiyao;	state Exp;
branches;
next	1.44;

1.44
date	2012.08.08.19.48.19;	author devans;	state Exp;
branches;
next	1.43;

1.43
date	2012.01.04.08.17.24;	author brobecke;	state Exp;
branches;
next	1.42;

1.42
date	2011.05.26.15.49.26;	author qiyao;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2011.05.13.22.36.07;	author devans;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.10.16.53.23;	author devans;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.06.00.14.09;	author msnyder;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.01.01.53.43;	author gdbadmin;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.03.18.13.36;	author palves;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.02.00.47.34;	author palves;	state Exp;
branches;
next	1.34;

1.34
date	2010.04.11.16.33.56;	author palves;	state Exp;
branches;
next	1.33;

1.33
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.28.16.09.27;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.21.20.52.53;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2009.12.19.00.29.11;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2009.11.16.18.15.05;	author palves;	state Exp;
branches;
next	1.28;

1.28
date	2009.11.12.15.33.50;	author mkuvyrkov;	state Exp;
branches;
next	1.27;

1.27
date	2009.11.12.00.47.39;	author ppluzhnikov;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.29.17.43.44;	author ppluzhnikov;	state Exp;
branches;
next	1.25;

1.25
date	2009.10.28.17.03.16;	author ppluzhnikov;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.09.00.31.01;	author ppluzhnikov;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.03.20.15.51;	author uweigand;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.01.22.50.24;	author palves;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.01.22.48.05;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.22.23.57.10;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.17.20.25.35;	author palves;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.15.22.07.19;	author devans;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.09.18.52.20;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches
	1.15.10.1;
next	1.14;

1.14
date	2007.12.18.21.58.01;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.23.20.05.03;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.02.15.35.36;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.27.11.52.02;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.28.22.21.23;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.17.16.02.27;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.30.19.05.33;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.15.16.13.29;	author drow;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2005.12.23.18.11.55;	author eliz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.09.17.23.14.37;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.16.17.42.00;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.11.17.32.40;	author drow;	state Exp;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.42.2.1
date	2012.01.06.04.43.40;	author brobecke;	state Exp;
branches;
next	;

1.15.10.1
date	2008.11.25.20.47.19;	author palves;	state Exp;
branches;
next	;

1.5.8.1
date	2006.08.28.07.48.46;	author nickrob;	state Exp;
branches;
next	;

1.4.2.1
date	2006.03.15.19.53.38;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.43.13;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.20.01.36.24;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.47
log
@From: Sanimir Agovic <sanimir.agovic@@intel.com>

null ptr check to prevent gdbserver from crashing

Evaluating a thread local storage variable in a remote scenario crashes
gdbserver if libthread-db could not be loaded.

2013-02-12  Sanimir Agovic  <sanimir.agovic@@intel.com>

gdbserver/
	* thread-db.c (thread_db_get_tls_address):
	NULL pointer check thread_db.

testsuite/
	* gdb.server/no-thread-db.exp: New file.
	* gdb.server/no-thread-db.c: New file.
	* gdb.server/Makefile.in (EXECUTABLES): Add no-thread-db.
@
text
@/* Thread management interface, for the remote server for GDB.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.

   Contributed by MontaVista Software.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"

#include "linux-low.h"

extern int debug_threads;

static int thread_db_use_events;

#include "gdb_proc_service.h"
#include "gdb_thread_db.h"
#include "gdb_vecs.h"

#ifndef USE_LIBTHREAD_DB_DIRECTLY
#include <dlfcn.h>
#endif

#include <stdint.h>
#include <limits.h>
#include <ctype.h>

struct thread_db
{
  /* Structure that identifies the child process for the
     <proc_service.h> interface.  */
  struct ps_prochandle proc_handle;

  /* Connection to the libthread_db library.  */
  td_thragent_t *thread_agent;

  /* If this flag has been set, we've already asked GDB for all
     symbols we might need; assume symbol cache misses are
     failures.  */
  int all_symbols_looked_up;

#ifndef USE_LIBTHREAD_DB_DIRECTLY
  /* Handle of the libthread_db from dlopen.  */
  void *handle;
#endif

  /* Thread creation event breakpoint.  The code at this location in
     the child process will be called by the pthread library whenever
     a new thread is created.  By setting a special breakpoint at this
     location, GDB can detect when a new thread is created.  We obtain
     this location via the td_ta_event_addr call.  Note that if the
     running kernel supports tracing clones, then we don't need to use
     (and in fact don't use) this magic thread event breakpoint to
     learn about threads.  */
  struct breakpoint *td_create_bp;

  /* Addresses of libthread_db functions.  */
  td_err_e (*td_ta_new_p) (struct ps_prochandle * ps, td_thragent_t **ta);
  td_err_e (*td_ta_event_getmsg_p) (const td_thragent_t *ta,
				    td_event_msg_t *msg);
  td_err_e (*td_ta_set_event_p) (const td_thragent_t *ta,
				 td_thr_events_t *event);
  td_err_e (*td_ta_event_addr_p) (const td_thragent_t *ta,
				  td_event_e event, td_notify_t *ptr);
  td_err_e (*td_ta_map_lwp2thr_p) (const td_thragent_t *ta, lwpid_t lwpid,
				   td_thrhandle_t *th);
  td_err_e (*td_thr_get_info_p) (const td_thrhandle_t *th,
				 td_thrinfo_t *infop);
  td_err_e (*td_thr_event_enable_p) (const td_thrhandle_t *th, int event);
  td_err_e (*td_ta_thr_iter_p) (const td_thragent_t *ta,
				td_thr_iter_f *callback, void *cbdata_p,
				td_thr_state_e state, int ti_pri,
				sigset_t *ti_sigmask_p,
				unsigned int ti_user_flags);
  td_err_e (*td_thr_tls_get_addr_p) (const td_thrhandle_t *th,
				     psaddr_t map_address,
				     size_t offset, psaddr_t *address);
  const char ** (*td_symbol_list_p) (void);
};

static char *libthread_db_search_path;

static int find_one_thread (ptid_t);
static int find_new_threads_callback (const td_thrhandle_t *th_p, void *data);

static const char *
thread_db_err_str (td_err_e err)
{
  static char buf[64];

  switch (err)
    {
    case TD_OK:
      return "generic 'call succeeded'";
    case TD_ERR:
      return "generic error";
    case TD_NOTHR:
      return "no thread to satisfy query";
    case TD_NOSV:
      return "no sync handle to satisfy query";
    case TD_NOLWP:
      return "no LWP to satisfy query";
    case TD_BADPH:
      return "invalid process handle";
    case TD_BADTH:
      return "invalid thread handle";
    case TD_BADSH:
      return "invalid synchronization handle";
    case TD_BADTA:
      return "invalid thread agent";
    case TD_BADKEY:
      return "invalid key";
    case TD_NOMSG:
      return "no event message for getmsg";
    case TD_NOFPREGS:
      return "FPU register set not available";
    case TD_NOLIBTHREAD:
      return "application not linked with libthread";
    case TD_NOEVENT:
      return "requested event is not supported";
    case TD_NOCAPAB:
      return "capability not available";
    case TD_DBERR:
      return "debugger service failed";
    case TD_NOAPLIC:
      return "operation not applicable to";
    case TD_NOTSD:
      return "no thread-specific data for this thread";
    case TD_MALLOC:
      return "malloc failed";
    case TD_PARTIALREG:
      return "only part of register set was written/read";
    case TD_NOXREGS:
      return "X register set not available for this thread";
#ifdef HAVE_TD_VERSION
    case TD_VERSION:
      return "version mismatch between libthread_db and libpthread";
#endif
    default:
      xsnprintf (buf, sizeof (buf), "unknown thread_db error '%d'", err);
      return buf;
    }
}

#if 0
static char *
thread_db_state_str (td_thr_state_e state)
{
  static char buf[64];

  switch (state)
    {
    case TD_THR_STOPPED:
      return "stopped by debugger";
    case TD_THR_RUN:
      return "runnable";
    case TD_THR_ACTIVE:
      return "active";
    case TD_THR_ZOMBIE:
      return "zombie";
    case TD_THR_SLEEP:
      return "sleeping";
    case TD_THR_STOPPED_ASLEEP:
      return "stopped by debugger AND blocked";
    default:
      xsnprintf (buf, sizeof (buf), "unknown thread_db state %d", state);
      return buf;
    }
}
#endif

static int
thread_db_create_event (CORE_ADDR where)
{
  td_event_msg_t msg;
  td_err_e err;
  struct lwp_info *lwp;
  struct thread_db *thread_db = current_process ()->private->thread_db;

  if (thread_db->td_ta_event_getmsg_p == NULL)
    fatal ("unexpected thread_db->td_ta_event_getmsg_p == NULL");

  if (debug_threads)
    fprintf (stderr, "Thread creation event.\n");

  /* FIXME: This assumes we don't get another event.
     In the LinuxThreads implementation, this is safe,
     because all events come from the manager thread
     (except for its own creation, of course).  */
  err = thread_db->td_ta_event_getmsg_p (thread_db->thread_agent, &msg);
  if (err != TD_OK)
    fprintf (stderr, "thread getmsg err: %s\n",
	     thread_db_err_str (err));

  /* If we do not know about the main thread yet, this would be a good time to
     find it.  We need to do this to pick up the main thread before any newly
     created threads.  */
  lwp = get_thread_lwp (current_inferior);
  if (lwp->thread_known == 0)
    find_one_thread (lwp->head.id);

  /* msg.event == TD_EVENT_CREATE */

  find_new_threads_callback (msg.th_p, NULL);

  return 0;
}

static int
thread_db_enable_reporting (void)
{
  td_thr_events_t events;
  td_notify_t notify;
  td_err_e err;
  struct thread_db *thread_db = current_process ()->private->thread_db;

  if (thread_db->td_ta_set_event_p == NULL
      || thread_db->td_ta_event_addr_p == NULL
      || thread_db->td_ta_event_getmsg_p == NULL)
    /* This libthread_db is missing required support.  */
    return 0;

  /* Set the process wide mask saying which events we're interested in.  */
  td_event_emptyset (&events);
  td_event_addset (&events, TD_CREATE);

  err = thread_db->td_ta_set_event_p (thread_db->thread_agent, &events);
  if (err != TD_OK)
    {
      warning ("Unable to set global thread event mask: %s",
	       thread_db_err_str (err));
      return 0;
    }

  /* Get address for thread creation breakpoint.  */
  err = thread_db->td_ta_event_addr_p (thread_db->thread_agent, TD_CREATE,
				       &notify);
  if (err != TD_OK)
    {
      warning ("Unable to get location for thread creation breakpoint: %s",
	       thread_db_err_str (err));
      return 0;
    }
  thread_db->td_create_bp
    = set_breakpoint_at ((CORE_ADDR) (unsigned long) notify.u.bptaddr,
			 thread_db_create_event);

  return 1;
}

static int
find_one_thread (ptid_t ptid)
{
  td_thrhandle_t th;
  td_thrinfo_t ti;
  td_err_e err;
  struct thread_info *inferior;
  struct lwp_info *lwp;
  struct thread_db *thread_db = current_process ()->private->thread_db;
  int lwpid = ptid_get_lwp (ptid);

  inferior = (struct thread_info *) find_inferior_id (&all_threads, ptid);
  lwp = get_thread_lwp (inferior);
  if (lwp->thread_known)
    return 1;

  /* Get information about this thread.  */
  err = thread_db->td_ta_map_lwp2thr_p (thread_db->thread_agent, lwpid, &th);
  if (err != TD_OK)
    error ("Cannot get thread handle for LWP %d: %s",
	   lwpid, thread_db_err_str (err));

  err = thread_db->td_thr_get_info_p (&th, &ti);
  if (err != TD_OK)
    error ("Cannot get thread info for LWP %d: %s",
	   lwpid, thread_db_err_str (err));

  if (debug_threads)
    fprintf (stderr, "Found thread %ld (LWP %d)\n",
	     ti.ti_tid, ti.ti_lid);

  if (lwpid != ti.ti_lid)
    {
      warning ("PID mismatch!  Expected %ld, got %ld",
	       (long) lwpid, (long) ti.ti_lid);
      return 0;
    }

  if (thread_db_use_events)
    {
      err = thread_db->td_thr_event_enable_p (&th, 1);
      if (err != TD_OK)
	error ("Cannot enable thread event reporting for %d: %s",
	       ti.ti_lid, thread_db_err_str (err));
    }

  /* If the new thread ID is zero, a final thread ID will be available
     later.  Do not enable thread debugging yet.  */
  if (ti.ti_tid == 0)
    return 0;

  lwp->thread_known = 1;
  lwp->th = th;

  return 1;
}

/* Attach a thread.  Return true on success.  */

static int
attach_thread (const td_thrhandle_t *th_p, td_thrinfo_t *ti_p)
{
  struct lwp_info *lwp;

  if (debug_threads)
    fprintf (stderr, "Attaching to thread %ld (LWP %d)\n",
	     ti_p->ti_tid, ti_p->ti_lid);
  linux_attach_lwp (ti_p->ti_lid);
  lwp = find_lwp_pid (pid_to_ptid (ti_p->ti_lid));
  if (lwp == NULL)
    {
      warning ("Could not attach to thread %ld (LWP %d)\n",
	       ti_p->ti_tid, ti_p->ti_lid);
      return 0;
    }

  lwp->thread_known = 1;
  lwp->th = *th_p;

  if (thread_db_use_events)
    {
      td_err_e err;
      struct thread_db *thread_db = current_process ()->private->thread_db;

      err = thread_db->td_thr_event_enable_p (th_p, 1);
      if (err != TD_OK)
	error ("Cannot enable thread event reporting for %d: %s",
	       ti_p->ti_lid, thread_db_err_str (err));
    }

  return 1;
}

/* Attach thread if we haven't seen it yet.
   Increment *COUNTER if we have attached a new thread.
   Return false on failure.  */

static int
maybe_attach_thread (const td_thrhandle_t *th_p, td_thrinfo_t *ti_p,
		     int *counter)
{
  struct lwp_info *lwp;

  lwp = find_lwp_pid (pid_to_ptid (ti_p->ti_lid));
  if (lwp != NULL)
    return 1;

  if (!attach_thread (th_p, ti_p))
    return 0;

  if (counter != NULL)
    *counter += 1;

  return 1;
}

static int
find_new_threads_callback (const td_thrhandle_t *th_p, void *data)
{
  td_thrinfo_t ti;
  td_err_e err;
  struct thread_db *thread_db = current_process ()->private->thread_db;

  err = thread_db->td_thr_get_info_p (th_p, &ti);
  if (err != TD_OK)
    error ("Cannot get thread info: %s", thread_db_err_str (err));

  /* Check for zombies.  */
  if (ti.ti_state == TD_THR_UNKNOWN || ti.ti_state == TD_THR_ZOMBIE)
    return 0;

  if (!maybe_attach_thread (th_p, &ti, (int *) data))
    {
      /* Terminate iteration early: we might be looking at stale data in
	 the inferior.  The thread_db_find_new_threads will retry.  */
      return 1;
    }

  return 0;
}

static void
thread_db_find_new_threads (void)
{
  td_err_e err;
  ptid_t ptid = current_ptid;
  struct thread_db *thread_db = current_process ()->private->thread_db;
  int loop, iteration;

  /* This function is only called when we first initialize thread_db.
     First locate the initial thread.  If it is not ready for
     debugging yet, then stop.  */
  if (find_one_thread (ptid) == 0)
    return;

  /* Require 4 successive iterations which do not find any new threads.
     The 4 is a heuristic: there is an inherent race here, and I have
     seen that 2 iterations in a row are not always sufficient to
     "capture" all threads.  */
  for (loop = 0, iteration = 0; loop < 4; ++loop, ++iteration)
    {
      int new_thread_count = 0;

      /* Iterate over all user-space threads to discover new threads.  */
      err = thread_db->td_ta_thr_iter_p (thread_db->thread_agent,
					 find_new_threads_callback,
					 &new_thread_count,
					 TD_THR_ANY_STATE,
					 TD_THR_LOWEST_PRIORITY,
					 TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);
      if (debug_threads)
	fprintf (stderr, "Found %d threads in iteration %d.\n",
		 new_thread_count, iteration);

      if (new_thread_count != 0)
	{
	  /* Found new threads.  Restart iteration from beginning.  */
	  loop = -1;
	}
    }
  if (err != TD_OK)
    error ("Cannot find new threads: %s", thread_db_err_str (err));
}

/* Cache all future symbols that thread_db might request.  We can not
   request symbols at arbitrary states in the remote protocol, only
   when the client tells us that new symbols are available.  So when
   we load the thread library, make sure to check the entire list.  */

static void
thread_db_look_up_symbols (void)
{
  struct thread_db *thread_db = current_process ()->private->thread_db;
  const char **sym_list;
  CORE_ADDR unused;

  for (sym_list = thread_db->td_symbol_list_p (); *sym_list; sym_list++)
    look_up_one_symbol (*sym_list, &unused, 1);

  /* We're not interested in any other libraries loaded after this
     point, only in symbols in libpthread.so.  */
  thread_db->all_symbols_looked_up = 1;
}

int
thread_db_look_up_one_symbol (const char *name, CORE_ADDR *addrp)
{
  struct thread_db *thread_db = current_process ()->private->thread_db;
  int may_ask_gdb = !thread_db->all_symbols_looked_up;

  /* If we've passed the call to thread_db_look_up_symbols, then
     anything not in the cache must not exist; we're not interested
     in any libraries loaded after that point, only in symbols in
     libpthread.so.  It might not be an appropriate time to look
     up a symbol, e.g. while we're trying to fetch registers.  */
  return look_up_one_symbol (name, addrp, may_ask_gdb);
}

int
thread_db_get_tls_address (struct thread_info *thread, CORE_ADDR offset,
			   CORE_ADDR load_module, CORE_ADDR *address)
{
  psaddr_t addr;
  td_err_e err;
  struct lwp_info *lwp;
  struct thread_info *saved_inferior;
  struct process_info *proc;
  struct thread_db *thread_db;

  proc = get_thread_process (thread);
  thread_db = proc->private->thread_db;

  /* If the thread layer is not (yet) initialized, fail.  */
  if (thread_db == NULL || !thread_db->all_symbols_looked_up)
    return TD_ERR;

  if (thread_db->td_thr_tls_get_addr_p == NULL)
    return -1;

  lwp = get_thread_lwp (thread);
  if (!lwp->thread_known)
    find_one_thread (lwp->head.id);
  if (!lwp->thread_known)
    return TD_NOTHR;

  saved_inferior = current_inferior;
  current_inferior = thread;
  /* Note the cast through uintptr_t: this interface only works if
     a target address fits in a psaddr_t, which is a host pointer.
     So a 32-bit debugger can not access 64-bit TLS through this.  */
  err = thread_db->td_thr_tls_get_addr_p (&lwp->th,
					  (psaddr_t) (uintptr_t) load_module,
					  offset, &addr);
  current_inferior = saved_inferior;
  if (err == TD_OK)
    {
      *address = (CORE_ADDR) (uintptr_t) addr;
      return 0;
    }
  else
    return err;
}

#ifdef USE_LIBTHREAD_DB_DIRECTLY

static int
thread_db_load_search (void)
{
  td_err_e err;
  struct thread_db *tdb;
  struct process_info *proc = current_process ();

  if (proc->private->thread_db != NULL)
    fatal ("unexpected: proc->private->thread_db != NULL");

  tdb = xcalloc (1, sizeof (*tdb));
  proc->private->thread_db = tdb;

  tdb->td_ta_new_p = &td_ta_new;

  /* Attempt to open a connection to the thread library.  */
  err = tdb->td_ta_new_p (&tdb->proc_handle, &tdb->thread_agent);
  if (err != TD_OK)
    {
      if (debug_threads)
	fprintf (stderr, "td_ta_new(): %s\n", thread_db_err_str (err));
      free (tdb);
      proc->private->thread_db = NULL;
      return 0;
    }

  tdb->td_ta_map_lwp2thr_p = &td_ta_map_lwp2thr;
  tdb->td_thr_get_info_p = &td_thr_get_info;
  tdb->td_ta_thr_iter_p = &td_ta_thr_iter;
  tdb->td_symbol_list_p = &td_symbol_list;

  /* This is required only when thread_db_use_events is on.  */
  tdb->td_thr_event_enable_p = &td_thr_event_enable;

  /* These are not essential.  */
  tdb->td_ta_event_addr_p = &td_ta_event_addr;
  tdb->td_ta_set_event_p = &td_ta_set_event;
  tdb->td_ta_event_getmsg_p = &td_ta_event_getmsg;
  tdb->td_thr_tls_get_addr_p = &td_thr_tls_get_addr;

  return 1;
}

#else

static int
try_thread_db_load_1 (void *handle)
{
  td_err_e err;
  struct thread_db *tdb;
  struct process_info *proc = current_process ();

  if (proc->private->thread_db != NULL)
    fatal ("unexpected: proc->private->thread_db != NULL");

  tdb = xcalloc (1, sizeof (*tdb));
  proc->private->thread_db = tdb;

  tdb->handle = handle;

  /* Initialize pointers to the dynamic library functions we will use.
     Essential functions first.  */

#define CHK(required, a)					\
  do								\
    {								\
      if ((a) == NULL)						\
	{							\
	  if (debug_threads)					\
	    fprintf (stderr, "dlsym: %s\n", dlerror ());	\
	  if (required)						\
	    {							\
	      free (tdb);					\
	      proc->private->thread_db = NULL;			\
	      return 0;						\
	    }							\
	}							\
    }								\
  while (0)

  CHK (1, tdb->td_ta_new_p = dlsym (handle, "td_ta_new"));

  /* Attempt to open a connection to the thread library.  */
  err = tdb->td_ta_new_p (&tdb->proc_handle, &tdb->thread_agent);
  if (err != TD_OK)
    {
      if (debug_threads)
	fprintf (stderr, "td_ta_new(): %s\n", thread_db_err_str (err));
      free (tdb);
      proc->private->thread_db = NULL;
      return 0;
    }

  CHK (1, tdb->td_ta_map_lwp2thr_p = dlsym (handle, "td_ta_map_lwp2thr"));
  CHK (1, tdb->td_thr_get_info_p = dlsym (handle, "td_thr_get_info"));
  CHK (1, tdb->td_ta_thr_iter_p = dlsym (handle, "td_ta_thr_iter"));
  CHK (1, tdb->td_symbol_list_p = dlsym (handle, "td_symbol_list"));

  /* This is required only when thread_db_use_events is on.  */
  CHK (thread_db_use_events,
       tdb->td_thr_event_enable_p = dlsym (handle, "td_thr_event_enable"));

  /* These are not essential.  */
  CHK (0, tdb->td_ta_event_addr_p = dlsym (handle, "td_ta_event_addr"));
  CHK (0, tdb->td_ta_set_event_p = dlsym (handle, "td_ta_set_event"));
  CHK (0, tdb->td_ta_event_getmsg_p = dlsym (handle, "td_ta_event_getmsg"));
  CHK (0, tdb->td_thr_tls_get_addr_p = dlsym (handle, "td_thr_tls_get_addr"));

#undef CHK

  return 1;
}

#ifdef HAVE_DLADDR

/* Lookup a library in which given symbol resides.
   Note: this is looking in the GDBSERVER process, not in the inferior.
   Returns library name, or NULL.  */

static const char *
dladdr_to_soname (const void *addr)
{
  Dl_info info;

  if (dladdr (addr, &info) != 0)
    return info.dli_fname;
  return NULL;
}

#endif

static int
try_thread_db_load (const char *library)
{
  void *handle;

  if (debug_threads)
    fprintf (stderr, "Trying host libthread_db library: %s.\n",
	     library);
  handle = dlopen (library, RTLD_NOW);
  if (handle == NULL)
    {
      if (debug_threads)
	fprintf (stderr, "dlopen failed: %s.\n", dlerror ());
      return 0;
    }

#ifdef HAVE_DLADDR
  if (debug_threads && strchr (library, '/') == NULL)
    {
      void *td_init;

      td_init = dlsym (handle, "td_init");
      if (td_init != NULL)
	{
	  const char *const libpath = dladdr_to_soname (td_init);

	  if (libpath != NULL)
	    fprintf (stderr, "Host %s resolved to: %s.\n",
		     library, libpath);
	}
    }
#endif

  if (try_thread_db_load_1 (handle))
    return 1;

  /* This library "refused" to work on current inferior.  */
  dlclose (handle);
  return 0;
}

/* Handle $sdir in libthread-db-search-path.
   Look for libthread_db in the system dirs, or wherever a plain
   dlopen(file_without_path) will look.
   The result is true for success.  */

static int
try_thread_db_load_from_sdir (void)
{
  return try_thread_db_load (LIBTHREAD_DB_SO);
}

/* Try to load libthread_db from directory DIR of length DIR_LEN.
   The result is true for success.  */

static int
try_thread_db_load_from_dir (const char *dir, size_t dir_len)
{
  char path[PATH_MAX];

  if (dir_len + 1 + strlen (LIBTHREAD_DB_SO) + 1 > sizeof (path))
    {
      char *cp = xmalloc (dir_len + 1);

      memcpy (cp, dir, dir_len);
      cp[dir_len] = '\0';
      warning (_("libthread-db-search-path component too long,"
		 " ignored: %s."), cp);
      free (cp);
      return 0;
    }

  memcpy (path, dir, dir_len);
  path[dir_len] = '/';
  strcpy (path + dir_len + 1, LIBTHREAD_DB_SO);
  return try_thread_db_load (path);
}

/* Search libthread_db_search_path for libthread_db which "agrees"
   to work on current inferior.
   The result is true for success.  */

static int
thread_db_load_search (void)
{
  VEC (char_ptr) *dir_vec;
  char *this_dir;
  int i, rc = 0;

  if (libthread_db_search_path == NULL)
    libthread_db_search_path = xstrdup (LIBTHREAD_DB_SEARCH_PATH);

  dir_vec = dirnames_to_char_ptr_vec (libthread_db_search_path);

  for (i = 0; VEC_iterate (char_ptr, dir_vec, i, this_dir); ++i)
    {
      const int pdir_len = sizeof ("$pdir") - 1;
      size_t this_dir_len;

      this_dir_len = strlen (this_dir);

      if (strncmp (this_dir, "$pdir", pdir_len) == 0
	  && (this_dir[pdir_len] == '\0'
	      || this_dir[pdir_len] == '/'))
	{
	  /* We don't maintain a list of loaded libraries so we don't know
	     where libpthread lives.  We *could* fetch the info, but we don't
	     do that yet.  Ignore it.  */
	}
      else if (strcmp (this_dir, "$sdir") == 0)
	{
	  if (try_thread_db_load_from_sdir ())
	    {
	      rc = 1;
	      break;
	    }
	}
      else
	{
	  if (try_thread_db_load_from_dir (this_dir, this_dir_len))
	    {
	      rc = 1;
	      break;
	    }
	}
    }

  free_char_ptr_vec (dir_vec);
  if (debug_threads)
    fprintf (stderr, "thread_db_load_search returning %d\n", rc);
  return rc;
}

#endif  /* USE_LIBTHREAD_DB_DIRECTLY */

int
thread_db_init (int use_events)
{
  struct process_info *proc = current_process ();

  /* FIXME drow/2004-10-16: This is the "overall process ID", which
     GNU/Linux calls tgid, "thread group ID".  When we support
     attaching to threads, the original thread may not be the correct
     thread.  We would have to get the process ID from /proc for NPTL.
     For LinuxThreads we could do something similar: follow the chain
     of parent processes until we find the highest one we're attached
     to, and use its tgid.

     This isn't the only place in gdbserver that assumes that the first
     process in the list is the thread group leader.  */

  thread_db_use_events = use_events;

  if (thread_db_load_search ())
    {
      if (use_events && thread_db_enable_reporting () == 0)
	{
	  /* Keep trying; maybe event reporting will work later.  */
	  thread_db_mourn (proc);
	  return 0;
	}
      thread_db_find_new_threads ();
      thread_db_look_up_symbols ();
      return 1;
    }

  return 0;
}

static int
any_thread_of (struct inferior_list_entry *entry, void *args)
{
  int *pid_p = args;

  if (ptid_get_pid (entry->id) == *pid_p)
    return 1;

  return 0;
}

static void
switch_to_process (struct process_info *proc)
{
  int pid = pid_of (proc);

  current_inferior =
    (struct thread_info *) find_inferior (&all_threads,
					  any_thread_of, &pid);
}

/* Disconnect from libthread_db and free resources.  */

static void
disable_thread_event_reporting (struct process_info *proc)
{
  struct thread_db *thread_db = proc->private->thread_db;
  if (thread_db)
    {
      td_err_e (*td_ta_clear_event_p) (const td_thragent_t *ta,
				       td_thr_events_t *event);

#ifndef USE_LIBTHREAD_DB_DIRECTLY
      td_ta_clear_event_p = dlsym (thread_db->handle, "td_ta_clear_event");
#else
      td_ta_clear_event_p = &td_ta_clear_event;
#endif

      if (td_ta_clear_event_p != NULL)
	{
	  struct thread_info *saved_inferior = current_inferior;
	  td_thr_events_t events;

	  switch_to_process (proc);

	  /* Set the process wide mask saying we aren't interested
	     in any events anymore.  */
	  td_event_fillset (&events);
	  (*td_ta_clear_event_p) (thread_db->thread_agent, &events);

	  current_inferior = saved_inferior;
	}
    }
}

static void
remove_thread_event_breakpoints (struct process_info *proc)
{
  struct thread_db *thread_db = proc->private->thread_db;

  if (thread_db->td_create_bp != NULL)
    {
      struct thread_info *saved_inferior = current_inferior;

      switch_to_process (proc);

      delete_breakpoint (thread_db->td_create_bp);
      thread_db->td_create_bp = NULL;

      current_inferior = saved_inferior;
    }
}

void
thread_db_detach (struct process_info *proc)
{
  struct thread_db *thread_db = proc->private->thread_db;

  if (thread_db)
    {
      disable_thread_event_reporting (proc);
      remove_thread_event_breakpoints (proc);
    }
}

/* Disconnect from libthread_db and free resources.  */

void
thread_db_mourn (struct process_info *proc)
{
  struct thread_db *thread_db = proc->private->thread_db;
  if (thread_db)
    {
      td_err_e (*td_ta_delete_p) (td_thragent_t *);

#ifndef USE_LIBTHREAD_DB_DIRECTLY
      td_ta_delete_p = dlsym (thread_db->handle, "td_ta_delete");
#else
      td_ta_delete_p = &td_ta_delete;
#endif

      if (td_ta_delete_p != NULL)
	(*td_ta_delete_p) (thread_db->thread_agent);

#ifndef USE_LIBTHREAD_DB_DIRECTLY
      dlclose (thread_db->handle);
#endif  /* USE_LIBTHREAD_DB_DIRECTLY  */

      free (thread_db);
      proc->private->thread_db = NULL;
    }
}

/* Handle "set libthread-db-search-path" monitor command and return 1.
   For any other command, return 0.  */

int
thread_db_handle_monitor_command (char *mon)
{
  const char *cmd = "set libthread-db-search-path";
  size_t cmd_len = strlen (cmd);

  if (strncmp (mon, cmd, cmd_len) == 0
      && (mon[cmd_len] == '\0'
	  || mon[cmd_len] == ' '))
    {
      const char *cp = mon + cmd_len;

      if (libthread_db_search_path != NULL)
	free (libthread_db_search_path);

      /* Skip leading space (if any).  */
      while (isspace (*cp))
	++cp;

      if (*cp == '\0')
	cp = LIBTHREAD_DB_SEARCH_PATH;
      libthread_db_search_path = xstrdup (cp);

      monitor_output ("libthread-db-search-path set to `");
      monitor_output (libthread_db_search_path);
      monitor_output ("'\n");
      return 1;
    }

  /* Tell server.c to perform default processing.  */
  return 0;
}
@


1.46
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d497 1
a497 1
  if (!thread_db->all_symbols_looked_up)
@


1.45
log
@gdb/gdbserver:
2012-11-09  Yao Qi  <yao@@codesourcery.com>

	* spu-low.c (current_ptid): Move it to ..
	* gdbthread.h: ... here.  New.
	* remote-utils.c (read_ptid): Use macro 'current_ptid'.
	* server.c (myresume, process_serial_event): Likewise.
	* thread-db.c (thread_db_find_new_threads): Likewise.
	* tracepoint.c (run_inferior_command): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004-2012 Free Software Foundation, Inc.
@


1.44
log
@	* gdb_string.h: Moved to ...
	* common/gdb_string.h: ... here.
	* common/vec.h: Remove #ifndef GDBSERVER conditional inclusion of
	gdb_string.h and gdb_assert.h.

	gdbserver/
	* configure.ac: Add check for strstr.
	* config.in: Regenerate.
	* configure: Regenerate.

	* linux-thread-db.c: #include "gdb_vecs.h".
	(try_thread_db_load_from_pdir_1): New arg "subdir".  All callers
	updated.
	(try_thread_db_load_from_pdir): New arg "subdir".  All callers updated.
	(thread_db_load_search): Use a vector to iterate over path elements.
	Handle text appearing after "$pdir".

	gdbserver/
	* Makefile.in (SFILES): Add gdb_vecs.c.
	(OBS): Add gdb_vecs.o.
	(gdb_vecs_h, host_defs_h): New variables.
	(thread-db.o): Add $(gdb_vecs_h) dependency.
	(gdb_vecs.o): New rule.
	* thread-db.c: #include "gdb_vecs.h".
	(thread_db_load_search): Use a vector to iterate over path elements.
	Handle text appearing after "$pdir".
@
text
@d409 1
a409 1
  ptid_t ptid = ((struct inferior_list_entry *) current_inferior)->id;
@


1.43
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d31 1
d745 3
a747 2
  const char *search_path;
  int rc = 0;
d752 3
a754 2
  search_path = libthread_db_search_path;
  while (*search_path)
d756 1
a756 2
      const char *end = strchr (search_path, ':');
      const char *this_dir = search_path;
d759 1
a759 10
      if (end)
	{
	  this_dir_len = end - search_path;
	  search_path += this_dir_len + 1;
	}
      else
	{
	  this_dir_len = strlen (this_dir);
	  search_path += this_dir_len;
	}
d761 3
a763 2
      if (this_dir_len == sizeof ("$pdir") - 1
	  && strncmp (this_dir, "$pdir", this_dir_len) == 0)
d769 1
a769 2
      else if (this_dir_len == sizeof ("$sdir") - 1
	       && strncmp (this_dir, "$sdir", this_dir_len) == 0)
d787 1
@


1.42
log
@2011-05-26  Yao Qi  <yao@@codesourcery.com>

	gdb/
	* gdb_thread_db.h: Delete.  Move to ...
	* common/gdb_thread_db.h: ... here.

	gdb/gdbserver/
	* Makefile.in (thread-db.o): Track dependence to
	common/gdb_thread_db.h.
	* thread-db.c: include gdb_thread_db.h from right place.
@
text
@d2 1
a2 2
   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.42.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2004-2012 Free Software Foundation, Inc.
@


1.41
log
@	Support $pdir and $sdir in libthread-db-search-path.
	* NEWS: Mention $sdir,$pdir.
	* gdb_thread_db.h (LIBTHREAD_DB_SEARCH_PATH): Add $sdir:$pdir.
	* linux-thread-db.c (try_thread_db_load_from_pdir): New function.
	(try_thread_db_load_from_sdir): New function.
	(try_thread_db_load_from_dir): New function.
	(thread_db_load_search): Handle $pdir, $sdir.  Remove trying of
	system directories if search of libthread-db-search-path fails,
	that is now done via $sdir.
	(has_libpthread): New function.
	(thread_db_load): Remove search for libthread_db in directory of
	libpthread, that is now done via $pdir.

	gdbserver/
	* thread-db.c (try_thread_db_load_from_sdir): New function.
	(try_thread_db_load_from_dir): New function.
	(thread_db_load_search): Handle $sdir, ignore $pdir.
	Remove trying of system directories if search of
	libthread-db-search-path fails,	that is now done via $sdir.

	doc/
	* gdb.texinfo (Threads): Document $sdir,$pdir.
	(Server): Document $pdir exception.
@
text
@d31 1
a31 1
#include "../gdb_thread_db.h"
@


1.40
log
@	* linux-thread-db.c (set_libthread_db_search_path): New function.
	(_initialize_thread_db): Add setter for libthread-db-search-path.

	gdbserver/
	* thread-db.c (thread_db_handle_monitor_command): Handle elided path.

	doc/
	* gdb.texinfo (Threads): If an empty path is provided for
	libthread-db-search-path it is reset to its default value.
	(Server): Ditto.
@
text
@d701 41
a744 1
  char path[PATH_MAX];
d755 3
d760 2
a761 15
	  size_t len = end - search_path;
	  if (len + 1 + strlen (LIBTHREAD_DB_SO) + 1 > sizeof (path))
	    {
	      char *cp = xmalloc (len + 1);
	      memcpy (cp, search_path, len);
	      cp[len] = '\0';
	      warning ("libthread_db_search_path component too long, "
		       "ignored: %s.", cp);
	      free (cp);
	      search_path += len + 1;
	      continue;
	    }
	  memcpy (path, search_path, len);
	  path[len] = '\0';
	  search_path += len + 1;
d765 3
a767 1
	  size_t len = strlen (search_path);
d769 11
a779 1
	  if (len + 1 + strlen (LIBTHREAD_DB_SO) + 1 > sizeof (path))
d781 1
a781 2
	      warning ("libthread_db_search_path component too long,"
		       " ignored: %s.", search_path);
a783 2
	  memcpy (path, search_path, len + 1);
	  search_path += len;
d785 1
a785 5
      strcat (path, "/");
      strcat (path, LIBTHREAD_DB_SO);
      if (debug_threads)
	fprintf (stderr, "thread_db_load_search trying %s\n", path);
      if (try_thread_db_load (path))
d787 5
a791 2
	  rc = 1;
	  break;
a793 2
  if (rc == 0)
    rc = try_thread_db_load (LIBTHREAD_DB_SO);
@


1.39
log
@2011-01-05  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdbreplay.c: Shorten lines of >= 80 columns.
	* linux-low.c: Ditto.
	* linux-ppc-low.c: Ditto.
	* linux-s390-low.c: Ditto.
	* linux-sparc-low.c: Ditto.
	* linux-x86-low.c: Ditto.
	* linux-xtensa-low.c: Ditto.
	* mem-break.c: Ditto.
	* nto-low.c: Ditto.
	* regcache.h: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* server.h: Ditto.
	* thread-db.c: Ditto.
	* tracepoint.c: Ditto.
	* utils.c: Ditto.
	* win32-low.h: Ditto.
@
text
@d919 6
a924 1
  if (strncmp (mon, "set libthread-db-search-path ", 29) == 0)
d926 1
a926 1
      const char *cp = mon + 29;
d935 2
@


1.38
log
@run copyright.sh for 2011.
@
text
@d431 2
a432 1
					 TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,
@


1.37
log
@use xsnprintf instead of snprintf.

snprintf is not available on LynxOS, so I changed the calls to snprintf
to calls to xsnprintf, which should be strictly equivalent.

gdb/gdbserver/ChangeLog:

        * utils.c (xsnprintf): Make non-static.
        * server.h: Add xsnprintf declaration.
        * linux-low.c, nto-low.c, target.c, thread-db.c, tracepoint.c:
        replace calls to snprintf by calls to xsnprintf throughout.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.36
log
@	gdb/gdbserver/
	* proc-service.c (ps_pglobal_lookup): Use
	thread_db_look_up_one_symbol.
	* remote-utils.c (look_up_one_symbol): Add new `may_ask_gdb'
	parameter.  Use it instead of all_symbols_looked_up.
	* server.h (struct process_info) <all_symbols_looked_up>: Delete
	field.
	(all_symbols_looked_up): Don't declare.
	(look_up_one_symbol): Add new `may_ask_gdb' parameter.
	* thread-db.c (struct thread_db) <all_symbols_looked_up>: New
	field.
	(thread_db_look_up_symbols): Adjust call to look_up_one_symbol.
	Set all_symbols_looked_up here.
	(thread_db_look_up_one_symbol): New.
	(thread_db_get_tls_address): Adjust.
	(thread_db_load_search, try_thread_db_load_1): Always allocate the
	thread_db object on the heap, and tentatively set it in the
	process structure.
	(thread_db_init): Don't set all_symbols_looked_up here.
	* linux-low.h (thread_db_look_up_one_symbol): Declare.
@
text
@d153 1
a153 1
      snprintf (buf, sizeof (buf), "unknown thread_db error '%d'", err);
d179 1
a179 1
      snprintf (buf, sizeof (buf), "unknown thread_db state %d", state);
@


1.35
log
@	* linux-low.c (linux_kill_one_lwp): Assume the lwp is stopped.
	(linux_kill): Stop all lwps here.  Don't delete the main lwp here.
	(linux_detach_one_lwp): Assume the lwp is stopped.
	(any_thread_of): Delete.
	(linux_detach): Stop all lwps here.  Don't blindly delete all
	breakpoints.
	(delete_lwp_callback): New.
	(linux_mourn): Delete all lwps of the process that is gone.
	(linux_wait_1): Don't delete the last lwp of the process here.
	* mem-break.h (mark_breakpoints_out): Declare.
	* mem-break.c (mark_breakpoints_out): New.
	(free_all_breakpoints): Use it.
	* server.c (handle_target_event): If the process is gone, mark
	breakpoints out.
	* thread-db.c (struct thread_db) <create_bp>: New field.
	(thread_db_enable_reporting): Fix prototype.  Store a thread event
	breakpoint reference in the thread_db struct.
	(thread_db_load_search): Clear the thread_db object.
	(try_thread_db_load_1): Ditto.
	(switch_to_process): New.
	(disable_thread_event_reporting): Use it.
	(remove_thread_event_breakpoints): New.
	(thread_db_detach, thread_db_mourn): Use it.
@
text
@d50 5
d460 19
a478 1
    look_up_one_symbol (*sym_list, &unused);
d496 1
a496 1
  if (!proc->all_symbols_looked_up)
d532 1
a532 1
  struct thread_db tdb;
d538 2
a539 1
  memset (&tdb, 0, sizeof (tdb));
d541 1
a541 1
  tdb.td_ta_new_p = &td_ta_new;
d544 1
a544 1
  err = tdb.td_ta_new_p (&tdb.proc_handle, &tdb.thread_agent);
d549 2
d554 4
a557 4
  tdb.td_ta_map_lwp2thr_p = &td_ta_map_lwp2thr;
  tdb.td_thr_get_info_p = &td_thr_get_info;
  tdb.td_ta_thr_iter_p = &td_ta_thr_iter;
  tdb.td_symbol_list_p = &td_symbol_list;
d560 1
a560 1
  tdb.td_thr_event_enable_p = &td_thr_event_enable;
d563 4
a566 7
  tdb.td_ta_event_addr_p = &td_ta_event_addr;
  tdb.td_ta_set_event_p = &td_ta_set_event;
  tdb.td_ta_event_getmsg_p = &td_ta_event_getmsg;
  tdb.td_thr_tls_get_addr_p = &td_thr_tls_get_addr;

  proc->private->thread_db = xmalloc (sizeof (tdb));
  memcpy (proc->private->thread_db, &tdb, sizeof (tdb));
d577 1
a577 1
  struct thread_db tdb;
d583 2
a584 1
  memset (&tdb, 0, sizeof (tdb));
d586 1
a586 1
  tdb.handle = handle;
d599 5
a603 1
	    return 0;						\
d608 1
a608 1
  CHK (1, tdb.td_ta_new_p = dlsym (handle, "td_ta_new"));
d611 1
a611 1
  err = tdb.td_ta_new_p (&tdb.proc_handle, &tdb.thread_agent);
d616 2
d621 4
a624 4
  CHK (1, tdb.td_ta_map_lwp2thr_p = dlsym (handle, "td_ta_map_lwp2thr"));
  CHK (1, tdb.td_thr_get_info_p = dlsym (handle, "td_thr_get_info"));
  CHK (1, tdb.td_ta_thr_iter_p = dlsym (handle, "td_ta_thr_iter"));
  CHK (1, tdb.td_symbol_list_p = dlsym (handle, "td_symbol_list"));
d628 1
a628 1
       tdb.td_thr_event_enable_p = dlsym (handle, "td_thr_event_enable"));
d631 4
a634 4
  CHK (0, tdb.td_ta_event_addr_p = dlsym (handle, "td_ta_event_addr"));
  CHK (0, tdb.td_ta_set_event_p = dlsym (handle, "td_ta_set_event"));
  CHK (0, tdb.td_ta_event_getmsg_p = dlsym (handle, "td_ta_event_getmsg"));
  CHK (0, tdb.td_thr_tls_get_addr_p = dlsym (handle, "td_thr_tls_get_addr"));
a637 3
  proc->private->thread_db = xmalloc (sizeof (tdb));
  memcpy (proc->private->thread_db, &tdb, sizeof (tdb));

a792 1
      proc->all_symbols_looked_up = 1;
@


1.34
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d55 10
d218 1
a218 1
thread_db_enable_reporting ()
d252 3
a254 2
  set_breakpoint_at ((CORE_ADDR) (unsigned long) notify.u.bptaddr,
		     thread_db_create_event);
d515 2
d560 2
d784 10
d813 1
a813 1
	  struct thread_info *saved_inferior;
a814 1
	  int pid;
d816 1
a816 5
	  pid = pid_of (proc);
	  saved_inferior = current_inferior;
	  current_inferior =
	    (struct thread_info *) find_inferior (&all_threads,
						  any_thread_of, &pid);
d828 18
d849 7
a855 1
  disable_thread_event_reporting (proc);
@


1.33
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d746 1
a746 1
	  thread_db_free (proc, 0);
d771 2
a772 2
void
thread_db_free (struct process_info *proc, int detaching)
a776 3
      struct thread_info *saved_inferior;
      int pid;
      td_err_e (*td_ta_delete_p) (td_thragent_t *);
a781 1
      td_ta_delete_p = dlsym (thread_db->handle, "td_ta_delete");
a782 1
      td_ta_delete_p = &td_ta_delete;
d786 1
a786 7
      pid = pid_of (proc);
      saved_inferior = current_inferior;
      current_inferior =
	(struct thread_info *) find_inferior (&all_threads,
					      any_thread_of, &pid);

      if (detaching && td_ta_clear_event_p != NULL)
d788 1
d790 7
d802 2
d805 24
a838 1
      current_inferior = saved_inferior;
@


1.32
log
@	* linux-low.c (linux_remove_process): Remove `detaching'
	parameter.  Don't release/detach from thread_db here.
	(linux_kill): Release/detach from thread_db here, ...
	(linux_detach): ... and here, before actually detaching.
	(linux_wait_1): ... and here, when a process exits.
	* thread-db.c (any_thread_of): New.
	(thread_db_free): Switch the current inferior to a thread of the
	passed in process.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009
@


1.31
log
@	* configure.ac: Check for dladdr.
	* config.in: Regenerate.
	* configure: Regenerate.
	* thread-db.c (dladdr_to_soname): Only define ifdef HAVE_DLADDR.
	(try_thread_db_load): Update.
@
text
@d758 11
d777 2
d791 6
d816 1
@


1.30
log
@	gdb/
	* gdb_proc_service.h (psaddr_t): Fix type.
	* linux-thread-db.c (thread_db_info.td_thr_tls_get_addr_p): Fix
	signature to match glibc.
	(thread_db_get_thread_local_address): Use psaddr_t for type of
	address to match parameter of td_thr_tls_get_addr_p.
	Cast through psaddr_t instead of (void*) to match parameter of
	td_thr_tls_get_addr_p.

	gdbserver/
	* gdb_proc_service.h (psaddr_t): Fix type.
	* thread-db.c (thread_db_info.td_thr_tls_get_addr_p): Fix
	signature to match glibc.
@
text
@d599 2
d615 2
d633 1
d648 1
@


1.29
log
@	* linux-low.c (linux_remove_process): Add `detaching' parameter.
	Pass it to thread_db_free.
	(linux_kill, linux_detach, linux_wait_1): Adjust to pass the
	proper `detaching' argument to linux_remove_process.
	* linux-low.h (thread_db_free): Add `detaching' parameter.
	* thread-db.c (thread_db_init): Pass false as `detaching' argument
	to thread_db_free.
	(thread_db_free): Add `detaching' parameter.  Only
	call td_ta_clear_event if detaching from process.
@
text
@d74 2
a75 2
				     void *map_address,
				     size_t offset, void **address);
@


1.28
log
@	* thread-db.c (thread_db_free): Fix typo.
@
text
@d740 1
a740 1
	  thread_db_free (proc);
d755 1
a755 1
thread_db_free (struct process_info *proc)
a759 1
#ifndef USE_LIBTHREAD_DB_DIRECTLY
d764 1
d766 7
a772 1
      if (td_ta_clear_event_p != NULL)
d776 2
a777 2
	  /* Set the process wide mask saying we aren't interested in any
	     events anymore.  */
a781 1
      td_ta_delete_p = dlsym (thread_db->handle, "td_ta_delete");
d785 1
a786 6
#else
      td_thr_events_t events;

      td_event_fillset (&events);
      td_ta_clear_event (thread_db->thread_agent, &events);
      td_ta_delete (thread_db->thread_agent);
@


1.27
log
@gdb/ChangeLog:

2009-11-11  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/10838
	* linux-thread-db.c (thread_db_info): New member.
	(disable_thread_event_reporting): Call td_ta_clear_event.

gdbserver/ChangeLog:

2009-11-11  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/10838
	* thread-db.c (thread_db_free): Call td_ta_clear_event.
@
text
@d782 1
a782 1
      td_thd_events_t events;
@


1.26
log
@2009-10-29  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* configure.ac: New --with-libthread-db option.
	* thread-db.c: Allow direct dependence on libthread_db.
	(thread_db_free): Adjust.
	* config.in: Regenerate.
	* configure: Likewise.
@
text
@d762 13
d782 4
@


1.25
log
@2009-10-28  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/10757
	* thread-db.c (attach_thread): New function.
	(maybe_attach_thread): Return success/failure.
	(find_new_threads_callback): Adjust.
	(thread_db_find_new_threads): Loop until no new threads.
@
text
@d33 1
d35 2
d50 1
d53 1
d492 45
d715 2
d760 1
d768 4
@


1.24
log
@doc/
2009-10-08  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* gdb.texinfo (Server): Document libthread-db-search-path.

gdbserver/
2009-10-08  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* acinclude.m4: (SRV_CHECK_THREAD_DB, SRV_CHECK_TLS_GET_ADDR): Remove.
	* configure.ac: Adjust.
	* linux-low.h (struct process_info_private): Move members to struct
	thread_db.
	(thread_db_free, thread_db_handle_monitor_command): New prototype.
	* linux-low.c (linux_remove_process): Adjust.
	(linux_wait_for_event_1, linux_look_up_symbols): Likewise.
	* server.c (handle_query): Move code ...
	(handle_monitor_command): ... here. New function.
	* target.h (struct target_ops): New member.
	* thread-db.c (struct thread_db): New.
	(libthread_db_search_path): New variable.
	(thread_db_create_event, thread_db_enable_reporting)
	(find_one_thread, maybe_attach_thread, find_new_threads_callback)
	(thread_db_find_new_threads, (thread_db_get_tls_address): Adjust.
	(try_thread_db_load_1, dladdr_to_soname): New functions.
	(try_thread_db_load, thread_db_load_search): New functions.
	(thread_db_init): Search for libthread_db.
	(thread_db_free): New function.
	(thread_db_handle_monitor_command): Likewise.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d300 4
a303 2
static void
maybe_attach_thread (const td_thrhandle_t *th_p, td_thrinfo_t *ti_p)
a304 1
  td_err_e err;
a306 4
  lwp = find_lwp_pid (pid_to_ptid (ti_p->ti_lid));
  if (lwp != NULL)
    return;

d316 1
a316 1
      return;
d324 1
d326 1
d332 25
d374 6
a379 1
  maybe_attach_thread (th_p, &ti);
d390 1
d398 24
a421 5
  /* Iterate over all user-space threads to discover new threads.  */
  err = thread_db->td_ta_thr_iter_p (thread_db->thread_agent,
				     find_new_threads_callback, NULL,
				     TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,
				     TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);
@


1.23
log
@	* inferiors.c (get_thread_process): Make global.
	* server.h (get_thread_process): Add prototype.
	* thread-db.c (find_one_thread): Use get_thread_process
	instead of current_process.
	(thread_db_get_tls_address): Do not crash if called when
	thread layer is not yet initialized.
@
text
@a29 4
#ifdef HAVE_THREAD_DB_H
#include <thread_db.h>
#endif

d31 1
d33 1
d35 40
d171 4
a174 1
  struct process_info_private *proc = current_process()->private;
d183 1
a183 1
  err = td_ta_event_getmsg (proc->thread_agent, &msg);
a201 11
#if 0
static int
thread_db_death_event (CORE_ADDR where)
{
  if (debug_threads)
    fprintf (stderr, "Thread death event.\n");

  return 0;
}
#endif

d208 7
a214 1
  struct process_info_private *proc = current_process()->private;
d220 1
a220 7
#if 0
  /* This is reported to be broken in glibc 2.1.3.  A different approach
     will be necessary to support that.  */
  td_event_addset (&events, TD_DEATH);
#endif

  err = td_ta_set_event (proc->thread_agent, &events);
d229 2
a230 1
  err = td_ta_event_addr (proc->thread_agent, TD_CREATE, &notify);
a239 16
#if 0
  /* Don't concern ourselves with reported thread deaths, only
     with actual thread deaths (via wait).  */

  /* Get address for thread death breakpoint.  */
  err = td_ta_event_addr (proc->thread_agent, TD_DEATH, &notify);
  if (err != TD_OK)
    {
      warning ("Unable to get location for thread death breakpoint: %s",
	       thread_db_err_str (err));
      return;
    }
  set_breakpoint_at ((CORE_ADDR) (unsigned long) notify.u.bptaddr,
		     thread_db_death_event);
#endif

d251 1
a251 1
  struct process_info_private *proc;
d260 1
a260 2
  proc = get_thread_process (inferior)->private;
  err = td_ta_map_lwp2thr (proc->thread_agent, lwpid, &th);
d265 1
a265 1
  err = td_thr_get_info (&th, &ti);
d283 1
a283 1
      err = td_thr_event_enable (&th, 1);
d327 2
a328 1
      err = td_thr_event_enable (th_p, 1);
d340 1
d342 1
a342 1
  err = td_thr_get_info (th_p, &ti);
d360 1
a360 1
  struct process_info_private *proc = current_process()->private;
d369 4
a372 4
  err = td_ta_thr_iter (proc->thread_agent,
			find_new_threads_callback, NULL,
			TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,
			TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS);
d385 2
a386 1
  const char **sym_list = td_symbol_list ();
d389 1
a389 1
  for (sym_list = td_symbol_list (); *sym_list; sym_list++)
a396 1
#if HAVE_TD_THR_TLS_GET_ADDR
d401 5
d408 1
a408 1
  if (!get_thread_process (thread)->all_symbols_looked_up)
d411 3
d425 3
a427 2
  err = td_thr_tls_get_addr (&lwp->th, (psaddr_t) (uintptr_t) load_module,
			     offset, &addr);
d436 178
a613 3
#else
  return -1;
#endif
a618 1
  int err;
a619 1
  struct process_info_private *priv = proc->private;
d634 1
a634 2
  err = td_ta_new (&priv->proc_handle, &priv->thread_agent);
  switch (err)
a635 7
    case TD_NOLIBTHREAD:
      /* No thread library was detected.  */
      return 0;

    case TD_OK:
      /* The thread library was detected.  */

d637 5
a641 1
	return 0;
d646 18
d665 29
a693 3
    default:
      warning ("error initializing thread_db library: %s",
	       thread_db_err_str (err));
d696 1
@


1.22
log
@2009-04-01  Pedro Alves  <pedro@@codesourcery.com>

	Implement the multiprocess extensions, and add linux multiprocess
	support.

	* server.h (ULONGEST): Declare.
	(struct ptid, ptid_t): New.
	(minus_one_ptid, null_ptid): Declare.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): Declare.
	(struct inferior_list_entry): Change `id' type from unsigned from
	to ptid_t.
	(struct sym_cache, struct breakpoint, struct
	process_info_private): Forward declare.
	(struct process_info): Declare.
	(current_process): Declare.
	(all_processes): Declare.
	(initialize_inferiors): Declare.
	(add_thread): Adjust to use ptid_t.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): Ditto.
	(add_process, remove_process, find_thread_pid): Declare.
	(find_inferior_id): Adjust to use ptid_t.
	(cont_thread, general_thread, step_thread): Change type to ptid_t.
	(multi_process): Declare.
	(push_event): Adjust to use ptid_t.
	(read_ptid, write_ptid): Declare.
	(prepare_resume_reply): Adjust to use ptid_t.
	(clear_symbol_cache): Declare.
	* inferiors.c (all_processes): New.
	(null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): New.
	(add_thread): Change unsigned long to ptid.  Remove gdb_id
	parameter.  Adjust.
	(thread_id_to_gdb_id, thread_to_gdb_id): Change unsigned long to ptid.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Change unsigned long to ptid.
	(gdb_id_to_thread_id, find_inferior_id): Change unsigned long to ptid.
	(loaded_dll, pull_pid_from_list): Adjust.
	(add_process, remove_process, find_process_pid)
	(get_thread_process, current_process, initialize_inferiors): New.
	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_waitstatus) <related_pid>: Ditto.
	(struct target_ops) <kill, detach>: Add `pid' argument.  Change
	return type to int.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <thread_alive>: Change pid's type to ptid_t.
	(struct target_ops) <wait>: Add `ptid' field.  Change return type
	to ptid.
	(kill_inferior, detach_inferior, join_inferior): Add `pid' argument.
	(mywait): Add `ptid' argument.  Change return type to ptid_t.
	(target_pid_to_str): Declare.
	* target.c (set_desired_inferior): Adjust to use ptids.
	(mywait): Add new `ptid' argument.  Adjust.
	(target_pid_to_str): New.
	* mem-break.h (free_all_breakpoints): Declare.
	* mem-break.c (breakpoints): Delelete.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Adjust
	to use per-process breakpoint list.
	(free_all_breakpoints): New.
	* remote-utils.c (struct sym_cache) <name>: Drop `const'.
	(symbol_cache, all_symbols_looked_up): Delete.
	(hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, hex_or_minus_one,
	read_ptid): New.
	(prepare_resume_reply): Change ptid argument's type from unsigned
	long to ptid_t.  Adjust.  Implement W;process and X;process.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust to per-process symbol cache.  *
	* server.c (cont_thread, general_thread, step_thread): Change type
	to ptid_t.
	(attached): Delete.
	(multi_process): New.
	(last_ptid): Change type to ptid_t.
	(struct vstop_notif) <ptid>: Change type to ptid_t.
	(queue_stop_reply, push_event): Change `ptid' argument's type to
	ptid_t.
	(discard_queued_stop_replies): Add `pid' argument.
	(start_inferior): Adjust to use ptids.  Adjust to mywait interface
	changes.  Don't reference the `attached' global.
	(attach_inferior): Adjust to mywait interface changes.
	(handle_query): Adjust to use ptids.  Parse GDB's qSupported
	features.  Handle and report "multiprocess+".  Handle
	"qAttached:PID".
	(handle_v_cont): Adjust to use ptids.  Adjust to mywait interface
	changes.
	(handle_v_kill): New.
	(handle_v_stopped): Adjust to use target_pid_to_str.
	(handle_v_requests): Allow multiple attaches and runs when
	multiprocess extensions are in effect.  Handle "vKill".
	(myresume): Adjust to use ptids.
	(queue_stop_reply_callback): Add `arg' parameter.  Handle it.
	(handle_status): Adjust to discard_queued_stop_replies interface
	change.
	(first_thread_of, kill_inferior_callback)
	(detach_or_kill_inferior_callback, join_inferiors_callback): New.
	(main): Call initialize_inferiors.  Adjust to use ptids, killing
	and detaching from all inferiors.  Handle multiprocess packet
	variants.
	* linux-low.h: Include gdb_proc_service.h.
	(struct process_info_private): New.
	(struct linux_target_ops) <pid_of>: Use ptid_get_pid.
	<lwpid_of>: Use ptid_get_lwp.
	(get_lwp_thread): Adjust.
	(struct lwp_info): Add `dead' member.
	(find_lwp_pid): Declare.
	* linux-low.c (thread_db_active): Delete.
	(new_inferior): Adjust comment.
	(inferior_pid): Delete.
	(linux_add_process): New.
	(handle_extended_wait): Adjust.
	(add_lwp): Change unsigned long to ptid.
	(linux_create_inferior): Add process to processes table.  Adjust
	to use ptids.  Don't set new_inferior here.
	(linux_attach_lwp): Rename to ...
	(linux_attach_lwp_1): ... this.  Add `initial' argument.  Handle
	it.  Adjust to use ptids.
	(linux_attach_lwp): New.
	(linux_attach): Add process to processes table.  Don't set
	new_inferior here.
	(struct counter): New.
	(second_thread_of_pid_p, last_thread_of_process_p): New.
	(linux_kill_one_lwp): Add `args' parameter.  Handle it.  Adjust to
	multiple processes.
	(linux_kill): Add `pid' argument.  Handle it.  Adjust to multiple
	processes.  Remove process from process table.
	(linux_detach_one_lwp): Add `args' parameter.  Handle it.  Adjust
	to multiple processes.
	(any_thread_of): New.
	(linux_detach): Add `pid' argument, and handle it.  Remove process
	from processes table.
	(linux_join): Add `pid' argument.  Handle it.
	(linux_thread_alive): Change unsighed long argument to ptid_t.
	Consider dead lwps as not being alive.
	(status_pending_p): Rename `dummy' argument to `arg'.  Filter out
	threads we're not interested in.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_lwp): Change `pid' argument's type from int to
	ptid_t.  Adjust.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.  Change `pid' argument's type
	from int to ptid_t.  Adjust.
	(linux_wait_for_event): New.
	(linux_wait_1): Add `ptid' argument.  Change return type to
	ptid_t.  Adjust.  Use last_thread_of_process_p.  Remove processes
	that exit from the process table.
	(linux_wait): Add `ptid' argument.  Change return type to ptid_t.
	Adjust.
	(mark_lwp_dead): New.
	(wait_for_sigstop): Adjust to use ptids.  If a process exits while
	stopping all threads, mark its main lwp as dead.
	(linux_set_resume_request, linux_resume_one_thread): Adjust to use
	ptids.
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory): Inline `inferior_pid'.
	(linux_look_up_symbols): Adjust to use per-process
	`thread_db_active'.
	(linux_request_interrupt): Adjust to use ptids.
	(linux_read_auxv): Inline `inferior_pid'.
	(initialize_low): Don't reference thread_db_active.
	* gdb_proc_service.h (struct ps_prochandle) <pid>: Remove.
	* proc-service.c (ps_lgetregs): Use find_lwp_pid.
	(ps_getpid): Return the pid of the current inferior.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(thread_db_create_event, thread_db_enable_reporting): Adjust to
	per-process data.
	(find_one_thread): Change argument type to ptid_t.  Adjust to
	per-process data.
	(maybe_attach_thread): Adjust to per-process data and ptids.
	(thread_db_find_new_threads): Ditto.
	(thread_db_init): Ditto.
	* spu-low.c (spu_create_inferior, spu_attach): Add process to
	processes table.  Adjust to use ptids.
	(spu_kill, spu_detach): Adjust interface.  Remove process from
	processes table.
	(spu_join, spu_thread_alive): Adjust interface.
	(spu_wait): Adjust interface.  Remove process from processes
	table.  Adjust to use ptids.
	* win32-low.c (current_inferior_tid): Delete.
	(current_inferior_ptid): New.
	(debug_event_ptid): New.
	(thread_rec): Take a ptid.  Adjust.
	(child_add_thread): Add `pid' argument.  Adjust to use ptids.
	(child_delete_thread): Ditto.
	(do_initial_child_stuff): Add `attached' argument.  Add process to
	processes table.
	(child_fetch_inferior_registers, child_store_inferior_registers):
	Adjust.
	(win32_create_inferior): Pass 0 to do_initial_child_stuff.
	(win32_attach): Pass 1 to do_initial_child_stuff.
	(win32_kill): Adjust interface.  Remove process from processes
	table.
	(win32_detach): Ditto.
	(win32_join): Adjust interface.
	(win32_thread_alive): Take a ptid.
	(win32_resume): Adjust to use ptids.
	(get_child_debug_event): Ditto.
	(win32_wait): Adjust interface.  Remove exiting process from
	processes table.
@
text
@d236 1
a236 1
  struct process_info_private *proc = current_process()->private;
d245 1
d386 4
@


1.21
log
@	Non-stop mode support.

	* server.h (non_stop): Declare.
	(gdb_client_data, handler_func): Declare.
	(delete_file_handler, add_file_handler, start_event_loop):
	Declare.
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif): Declare.
	* target.h (enum resume_kind): New.
	(struct thread_resume): Replace `step' field by `kind' field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <wait>: Add `options' argument.
	<supports_non_stop, async, start_non_stop>: New fields.
	(target_supports_non_stop, target_async): New.
	(start_non_stop): Declare.
	(mywait): Add `options' argument.
	* target.c (mywait): Add `options' argument.  Print child exit
	notifications here.
	(start_non_stop): New.
	* server.c (non_stop, own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New global.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to use resume_kind.  Adjust to mywait
	interface changes.
	(attach_inferior): In non-stop mode, don't wait for the target
	here.
	(handle_general_set): Handle QNonStop.
	(handle_query): When handling qC, return the current general
	thread, instead of the first thread of the list.
	(handle_query): If the backend supports non-stop mode, include
	QNonStop+ in the qSupported query response.
	(handle_v_cont): Adjust to use resume_kind.  Handle resume_stop
	and non-stop mode.
	(handle_v_attach, handle_v_run): Handle non-stop mode.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for vCont;t.  Handle vStopped.
	(myresume): Adjust to use resume_kind.  Handle non-stop.
	(queue_stop_reply_callback): New.
	(handle_status): Handle non-stop mode.
	(main): Clear non_stop flag on reconnection.  Use the event-loop.
	Refactor serial protocol handling from here ...
	(process_serial_event): ... to this new function.  When GDB
	selects any thread, select one here.  In non-stop mode, wait until
	GDB acks all pending events before exiting.
	(handle_serial_event, handle_target_event): New.
	* remote-utils.c (remote_open): Install remote_desc in the event
	loop.
	(remote_close): Remove remote_desc from the event loop.
	(putpkt_binary): Rename to...
	(putpkt_binary_1): ... this.  Add `is_notic' argument.  Handle it.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(prepare_resume_reply): In non-stop mode, don't change the
	general_thread.
	* event-loop.c: New.
	* Makefile.in (OBJ): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (pid_of): Moved here.
	(lwpid_of): New.
	(get_lwp_thread): Use lwpid_of.
	(struct lwp_info): Delete `lwpid' field.  Add `suspended' field.
	* linux-low.c (pid_of): Delete.
	(inferior_pid): Use lwpid_of.
	(linux_event_pipe): New.
	(target_is_async_p): New.
	(delete_lwp): New.
	(handle_extended_wait): Use lwpid_of.
	(add_lwp): Don't set lwpid field.
	(linux_attach_lwp): Adjust debug output.  Use lwpid_of.
	(linux_kill_one_lwp): If killing a running lwp, stop it first.
	Use lwpid_of.  Adjust to linux_wait_for_event interface changes.
	(linux_detach_one_lwp): If detaching from a running lwp, stop it
	first.  Adjust to linux_wait_for_event interface changes.  Use
	lwpid_of.
	(linux_detach): Don't delete the main lwp here.
	(linux_join): Use my_waitpid.  Avoid signal_pid.  Use lwpid_of.
	(status_pending_p): Don't consider explicitly suspended lwps.
	(linux_wait_for_lwp): Take an integer pid instead of a lwp_info
	pointer.  Add OPTIONS argument.  Change return type to int.  Use
	my_waitpid instead of sleeping.  Handle WNOHANG.  Use lwpid_of.
	(linux_wait_for_event): Take an integer pid instead of a lwp_info
	pointer.  Add status pointer argument.  Return a pid instead of a
	status.  Use lwpid_of.  Adjust to linux_wait_for_lwp interface
	changes.  In non-stop mode, don't switch to a random thread.
	(linux_wait): Rename to...
	(linux_wait_1): ... this.  Add target_options argument, and handle
	it.  Adjust to use resume_kind.  Use lwpid_of.  In non-stop mode,
	don't handle the continue thread.  Handle TARGET_WNOHANG.  Merge
	clean exit and signal exit code.  Don't stop all threads in
	non-stop mode.  In all-stop mode, only stop all threads when
	reporting a stop to GDB.  Handle explicit thread stop requests.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(send_sigstop): Use lwpid_of.
	(wait_for_sigstop): Use lwpid_of.  Adjust to linux_wait_for_event
	interface changes.  In non-stop mode, don't switch to a random
	thread.
	(linux_resume_one_lwp): Use lwpid_of.
	(linux_continue_one_thread, linux_queue_one_thread): Merge into ...
	(linux_resume_one_thread): ... this.  Handle resume_stop.  In
	non-stop mode, don't look for pending flag in all threads.
	(resume_status_pending_p): Don't consider explicitly suspended
	threads.
	(my_waitpid): Reimplement.  Emulate __WALL.
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Use lwpid_of.
	(sigchld_handler, linux_supports_non_stop, linux_async)
	(linux_start_non_stop): New.
	(linux_target_ops): Register linux_supports_non_stop, linux_async
	and linux_start_non_stop.
	(initialize_low): Install SIGCHLD handler.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(thread_db_get_tls_address): Use lwpid_of.
	* win32-low.c (win32_detach): Adjust to use resume_kind.
	(win32_wait): Add `options' argument.
	* spu-low.c (spu_resume): Adjust to use resume_kind.
	(spu_wait): Add `options' argument.
@
text
@d38 1
a38 8
/* Structure that identifies the child process for the
   <proc_service.h> interface.  */
static struct ps_prochandle proc_handle;

/* Connection to the libthread_db library.  */
static td_thragent_t *thread_agent;

static int find_one_thread (int);
d133 1
d142 1
a142 1
  err = td_ta_event_getmsg (thread_agent, &msg);
d152 1
a152 1
    find_one_thread (lwpid_of (lwp));
d178 1
d190 1
a190 1
  err = td_ta_set_event (thread_agent, &events);
d199 1
a199 1
  err = td_ta_event_addr (thread_agent, TD_CREATE, &notify);
d214 1
a214 1
  err = td_ta_event_addr (thread_agent, TD_DEATH, &notify);
d229 1
a229 1
find_one_thread (int lwpid)
d236 2
d239 1
a239 1
  inferior = (struct thread_info *) find_inferior_id (&all_threads, lwpid);
d245 1
a245 1
  err = td_ta_map_lwp2thr (thread_agent, lwpid_of (lwp), &th);
d259 1
a259 1
  if (lwpid_of (lwp) != ti.ti_lid)
d262 1
a262 1
	       (long) lwpid_of (lwp), (long) ti.ti_lid);
a288 1
  struct thread_info *inferior;
d291 2
a292 3
  inferior = (struct thread_info *) find_inferior_id (&all_threads,
						      ti_p->ti_lid);
  if (inferior != NULL)
d299 2
a300 3
  inferior = (struct thread_info *) find_inferior_id (&all_threads,
						      ti_p->ti_lid);
  if (inferior == NULL)
a306 2
  lwp = inferior_target_data (inferior);

d342 2
d348 1
a348 1
  if (find_one_thread (all_threads.head->id) == 0)
d352 2
a353 1
  err = td_ta_thr_iter (thread_agent, find_new_threads_callback, NULL,
d383 1
d387 1
a387 1
    find_one_thread (lwpid_of (lwp));
d391 2
d398 1
d415 2
a427 4
  proc_handle.pid = ((struct inferior_list_entry *)current_inferior)->id;

  /* Allow new symbol lookups.  */
  all_symbols_looked_up = 0;
d431 1
a431 1
  err = td_ta_new (&proc_handle, &thread_agent);
d445 1
a445 1
      all_symbols_looked_up = 1;
@


1.20
log
@	* i387-fp.c, linux-arm-low.c, linux-cris-low.c,
	linux-crisv32-low.c, linux-i386-low.c, linux-low.c,
	linux-mips-low.c, linux-s390-low.c, linux-sparc-low.c,
	linux-x86-64-low.c, linux-xtensa-low.c, proc-service.c,
	regcache.c, remote-utils.c, server.c, spu-low.c, target.h,
	thread-db.c, win32-low.c, xtensa-xtregs.c, gdbreplay.c,
	Makefile.in, configure.ac: Fix whitespace throughout.
	* configure: Regenerate.
@
text
@d158 1
a158 1
    find_one_thread (lwp->lwpid);
d248 1
a248 1
  err = td_ta_map_lwp2thr (thread_agent, lwp->lwpid, &th);
d262 1
a262 1
  if (lwp->lwpid != ti.ti_lid)
d265 1
a265 1
	       (long) lwp->lwpid, (long) ti.ti_lid);
d391 1
a391 1
    find_one_thread (lwp->lwpid);
@


1.19
log
@	Rename "process" to "lwp" throughout.

	* linux-low.c (all_processes): Rename to...
	(all_lwps): ... this.
	(inferior_pid, handle_extended_wait, get_stop_pc): Adjust.
	(add_process): Rename to ...
	(add_lwp): ... this.  Adjust.
	(linux_create_inferior): Adjust.
	(linux_attach_lwp): Adjust.
	(linux_attach): Adjust.
	(linux_kill_one_process): Rename to ...
	(linux_kill_one_lwp): ... this.  Adjust.
	(linux_kill): Adjust.
	(linux_detach_one_process): Rename to ...
	(linux_detach_one_lwp): ... this.  Adjust.
	(linux_detach): Adjust.
	(check_removed_breakpoint): Adjust.
	(status_pending_p): Adjust.
	(linux_wait_for_process): Rename to ...
	(linux_wait_for_lwp): ... this.  Adjust.
	(linux_wait_for_event): Adjust.
	(send_sigstop): Adjust.
	(wait_for_sigstop): Adjust.
	(stop_all_processes): Rename to ...
	(stop_all_lwps): ... this.
	(linux_resume_one_process): Rename to ...
	(linux_resume_one_lwp): ... this.  Adjust.
	(linux_set_resume_request, linux_continue_one_thread)
	(linux_queue_one_thread, resume_status_pending_p)
	(usr_store_inferior_registers, regsets_store_inferior_registers)
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Adjust.
	* linux-low.h (get_process): Rename to ...
	(get_lwp): ... this.  Adjust.
	(get_thread_process): Rename to ...
	(get_thread_lwp): ... this.  Adjust.
	(get_process_thread): Rename to ...
	(get_lwp_thread): ... this.  Adjust.
	(struct process_info): Rename to ...
	(struct lwp_info): ... this.
	(all_processes): Rename to ...
	(all_lwps): ... this.
	* proc-service.c (ps_lgetregs): Adjust.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(maybe_attach_thread, thread_db_get_tls_address): Adjust.
@
text
@d199 1
a199 1
               thread_db_err_str (err));
@


1.18
log
@	* target.h (target_signal_to_string): Make return type const char *.
	(target_signal_to_name): Ditto.
	(target_signal_from_name): Make arg const char *.
	* thread-db.c (thread_db_err_str): Make return type const char *.
	* utils.c (perror_with_name): Make arg const char *.
	* infrun.c (sig_print_info): Update.

	* signals/signals.c (signals): Make array and struct members const.
	(target_signal_to_string): Make return type const char *.
	(target_signal_to_name): Ditto.
	(target_signal_from_name): Make arg const char *.

	* gdbserver/gdbreplay.c (perror_with_name): Make arg const char *.
	* gdbserver/server.h (target_signal_to_name): Make return type
	const char *.
@
text
@d139 1
a139 1
  struct process_info *process;
d156 3
a158 3
  process = get_thread_process (current_inferior);
  if (process->thread_known == 0)
    find_one_thread (process->lwpid);
d240 1
a240 1
  struct process_info *process;
d243 2
a244 2
  process = get_thread_process (inferior);
  if (process->thread_known)
d248 1
a248 1
  err = td_ta_map_lwp2thr (thread_agent, process->lwpid, &th);
d262 1
a262 1
  if (process->lwpid != ti.ti_lid)
d265 1
a265 1
	       (long) process->lwpid, (long) ti.ti_lid);
d282 2
a283 2
  process->thread_known = 1;
  process->th = th;
d293 1
a293 1
  struct process_info *process;
d313 1
a313 1
  process = inferior_target_data (inferior);
d315 2
a316 2
  process->thread_known = 1;
  process->th = *th_p;
d387 1
a387 1
  struct process_info *process;
d389 4
a392 4
  process = get_thread_process (thread);
  if (!process->thread_known)
    find_one_thread (process->lwpid);
  if (!process->thread_known)
d398 1
a398 1
  err = td_thr_tls_get_addr (&process->th, (psaddr_t) (uintptr_t) load_module,
@


1.17
log
@        Updated copyright notices for most files.
@
text
@d48 1
a48 1
static char *
@


1.16
log
@	* linux-low.h (struct process_info): Delete member tid, unused.
	* thread-db.c (find_one_thread): Update.
	(maybe_attach_thread): Update.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008
@


1.15
log
@	Updated copyright notices for most files.
@
text
@a282 1
  process->tid = ti.ti_tid;
a314 1
  process->tid = ti_p->ti_tid;
@


1.15.10.1
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-10-13  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (discard_pending_stop_replies): Initialize prev.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_wait_1): Cancel breakpoint hits in threads
	we're not reporting.
	(cancel_breakpoints_callback): New.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (queue_stop_reply_callback, handle_status): Pass
	TARGET_SIGNAL_TRAP, not TARGET_SIGNAL_0.

	* linux-low.c (ptid_is_pid): Delete.
	(linux_wait_for_event): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_wait): Flush the event pipe before polling for an event.
	(wait_for_sigstop): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_resume_one_lwp): Small cleanup.
	(cancel_breakpoint): New.
	(linux_resume_one_thread): Use it.  Still report SIGTRAPs.
	(regsets_store_inferior_registers): Plug leak.
	(sigchld_handler): Don't use fprintf here.

	* mem-break.c (breakpoint_at): New.
	* inferiors.c (ptid_is_pid): New.
	* mem-break.h (breakpoint_at): Declare.
	* server.c (discard_queued_stop_replies): Add `pid' argument.
	Handle it.
	(send_next_stop_reply): Cleanup.
	(attach_inferior): Don't wait here in non-stop mode.
	(handle_v_attach): Don't queue stop replies here.
	(handle_v_kill): Discard queued stop replies of the inferior we
	just killed.
	(queue_stop_reply_callback): Add `arg' argument.  Handle it.
	(handle_status): Adjust.
	(kill_inferior_callback): Discard queued stop replies of the
	inferior we just killed.
	(detach_or_kill_inferior_callback): Discard queued stop replies of
	the inferior we just killed or detached from.
	(process_serial_event): Cleanup.  Discard queued stop replies of
	the inferior we just detached.  Don't write 0 bytes to the inferior.
	(handle_serial_event): Debug output.
	* server.h (ptid_is_pid): Declare.

	* remote-utils.c (prepare_resume_reply): Avoid reading registers
	and memory from a thread that is gone.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.h (struct sym_cache, struct process_info_private):
	Forward declare.
	(struct process_info): Add symbol_cache, all_symbols_looked_up and
	private fields.
	(current_process): Declare.
	* remote-utils.c (struct sym_cache) <name>: Remove constness.
	(symbol_cache): Delete.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust, to per-process symbol cache.
	* inferiors.c (current_process): New.

	* linux-low.h: Include "gdb_proc_service.h".
	(struct process_info_private): Define.
	* linux-low.c (thread_db_active): Delete.
	(linux_add_process): New.
	(handle_extended_wait, linux_create_inferior, linux_attach): Use
	it.
	(linux_wait_for_event, linux_look_up_symbols): Adjust.
	(initialize_low): Don't clear the global thread_db_active.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(fixup_proc_handle): New.
	(thread_db_err_str, thread_db_enable_reporting): Use it.  Adjust.
	(thread_db_find_new_threads): Look for the current inferior
	thread, not the first thread in the list.  Use fixup_proc_handle.
	Adjust.
	(thread_db_get_tls_address): Use fixup_proc_handle.
	(thread_db_init): Likewise.  Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* mem-break.c (get_breakpoint_list): Add `create' argument.  Only
	create the list if create is set.
	(remove_breakpoint_list): New.
	(set_breakpoint_at, find_breakpoint_at, check_mem_read)
	(check_mem_write, delete_all_breakpoints): Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (gdbserver_usage): Describe --remote-debug option.
	(main): Handle --remote-debug switch.

	2008-09-19  Pedro Alves  <pedro@@codesourcery.com>

	Non-stop mode support.

	* linux-low.c (linux_event_pipe): New int array for pipe.
	(target_is_async_p): New.
	(handle_extended_wait): Use my_waitpid.
	(linux_kill_one_lwp): Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_kill_one_process, linux_kill): Delete.
	(linux_kill_1): Rename back to ...
	(linux_kill) ... this.  Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_detach_one_lwp): Make sure the LWP is stopped.  Adjust to
	new linux_wait_for_event interface.
	(linux_detach_one_process, linux_detach): Delete.
	(linux_detach_1): Rename back to ...
	(linux_detach): This.
	(linux_join): Add PID argument.  Use my_waitpid instead of
	waitpid.
	(status_pending_p): Ignore suspended threads.
	(my_waitpid): Emulate __WALL.
	(linux_wait_for_lwp): Add 'options' argument.  Handle it.  Use
	my_wait.  If requesting an event from a specific process, leave
	events in other processes pending.
	(resume_stopped_lwps): New.
	(linux_wait_for_event): Delete.
	(linux_wait_for_event_1): Rename back to ...
	(linux_wait_for_event): ... this.  Change interface: add wstat and
	options arguments, return -1 on error, 0 otherwise.  Adjust.  In
	all-stop, resume stopped lwps if there was no pending status.
	Don't return immediatelly if a pending status was found ---
	continue handling it instead.  Don't loop, only handle one event.
	(linux_wait): Rename to ...
	(linux_wait_1): ... this.  Add target_options argument.  Handle
	it.  Don't loop --- only handle one event.  Ignore the continue
	thread in non_stop mode.  Adjust to new resume_kind interface.
	Only stop all threads in all-stop mode.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(wait_for_sigstop): Set stopping_threads here.  Use
	linux_wait_for_lwp instead of linux_wait_for_event.  Adjust.
	(stop_all_lwps): Don't set stopping_threads here.
	(resume_ptr): Delete.
	(struct resume_info): New.
	(linux_set_resume_request): Add arg argument.  Adjust to take a
	struct remove_info instead of the global resume_ptr.  Accept
	pid,-1 to apply to all threads.
	(linux_continue_one_thread, linux_queue_one_thread): Merge both
	and create ...
	(linux_resume_one_thread): ... this.  New.  Handle rk_stop.
	(resume_status_pending_p): Assume no resume info to mean do
	nothing.  Ignore suspended LWPs.
	(linux_resume): Add n argument.  Adjust.  In non-stop mode, don't
	look for a pending status over all threads.
	(linux_read_offsets): Minor cleanup.
	(sigchld_handler, linux_async, linux_start_non_stop): New.
	(linux_target_ops): Register linux_async and linux_start_non_stop.
	(initialize_low): Register sigchld_handler as SIGCHLD handler.

	* utils.c (internal_verror, internal_error_file_line): New.

	* Makefile.in (SFILES): Add event-loop.c.
	(OBS): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (struct lwp_info) <suspended>: New flag.

	* thread-db.c (thread_db_create_event): Make sure thread_db reads
	from the current inferior.
	(thread_db_get_tls_address): Comment.

	* server.c (thread_from_wait, old_thread_from_wait, attached):
	Delete.
	(non_stop): New global.
	(own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to new thread_resume interface.  Adjust
	to new mywait interface.
	(attach_inferior): Adjust.
	(handle_general_set): Handle QNonStop.
	(handle_query): Pass 'QNonStop+'.
	(handle_v_cont): Handle vCont;t.  Don't enable/disable async io in
	non-stop mode.  In non-stop return OK, and don't wait for the
	target.
	(handle_v_attach): In non-stop, return OK, and queue events for
	all threads.
	(handle_v_run): In non-stop, set the general thread here.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for 't'.  Handle 'vStopped'.
	(proceed): Add comment.  Adjust.  In non-stop, don't
	enable/disable async io; write 'OK', and don't wait for the
	target.
	(queue_stop_reply_callback, handle_status): New.
	(kill_inferior_callback, detach_or_kill_inferior_callback)
	(join_inferiors_callback): New.
	(main): In --debug mode, also enable remote debug.  Don't pass -1
	to kill_inferior or detach_inferior; instead, iterate over all
	processes killing or detaching them.  Adjust to use the even-loop.
	(process_serial_event): New, factored out of main.  If the
	connection closed, remove all sources from the event loop.
	Iterate over all inferiors joining them.  Use handle_status.
	Don't print inferior exit notices here.  In non-stop, defer
	exiting until GDB read all queued events.
	(handle_serial_event, handle_target_event): New.

	* server.h (FOR_EACH_INFERIOR): New.
	(thread_from_wait, old_thread_from_wait): Remove.
	(non_stop): Declare.
	(gdb_client_data, handler_func): New typedefs.
	(delete_file_handler, add_file_handler, start_event_loop)
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif, internal_error_file_line): Declare.
	(internal_error): Define.

	* target.c (mywait): Add `options' argument.  Print inferior exit
	notices here.
	(start_non_stop): New.

	* event-loop.c: New.

	* remote-utils.c (remote_open): Register remote_desc in the event
	loop, with handle_serial_event as callback.
	(remote_close): Remove remote_desc from the event loop.
	(hex_or_minus_one): New.
	(read_ptid, read_ptid): Use it.
	(putpkt_binary): Rename to ...
	(putpkt_binary_1): ... this.  Add `notif' argument.  Handle
	pushing a remote protocol notification.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(getpkt): Debug output.
	(prepare_resume_reply): Remove dead code.  In non-stop, don't set
	the general thread here.

	* target.h (enum resume_kind): New.
	(struct thread_resume) <leave_stopped, step>: Delete.
	(struct thread_resume) <kind>: New field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <kill, detach>: Adjust comments.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <resume>: Add `n' argument.
	(struct target_ops) <wait>: Add `options' argument.
	(struct target_ops) <async, start_non_stop>: New fields.
	(join_inferior): Add `pid' argument.
	(target_async): New.
	(start_non_stop): Declare.
	(mywait): Add options argument.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (new_inferior): Mention in the comment that all
	inferiors should have the same architecture for now.
	(linux_create_inferior, linux_attach): Only set new_inferior if
	this is the first process.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (ptid_is_pid): Move higher.
	(linux_wait_for_lwp): Remove dead code.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.
	(linux_wait_for_event): New.
	(ptid_same_pid): Delete.
	(linux_set_resume_request): Clearify.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (handle_extended_wait, linux_attach_lwp)
	(linux_attach): Minor cleanups.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_thread_alive): Return false for a listed
	thread known to be dead.
	(linux_wait_for_event): Don't set the dead flag here.
	(wait_for_sigstop): Store ptid before waiting for the event.
	Minor cleanup.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (find_inferior): Allow deleting the current iterated
	inferior.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_pid_to_exec_file): Move higher.
	(linux_enable_event_reporting): Enable PTRACE_O_TRACEEXEC.
	(handle_extended_wait): Handle PTRACE_EVENT_EXEC.

	* remote-utils.c (prepare_resume_reply): Set the general thread to
	the last thread that had an event in TARGET_WAITKIND_FORKED and
	TARGET_WAITKIND_VFORKED.  Handle TARGET_WAITKIND_EXECD.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (handle_query): Pass "QExecFile:PID;" back in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_supports_tracefork_flag): Move higher.
	(linux_enable_event_reporting): New.
	(handle_extended_wait): Change return type to int.  Handle
	PTRACE_EVENT_FORK and PTRACE_EVENT_VFORK.
	(add_lwp): Set waitstatus.kind to TARGET_WAITKIND_IGNORE.
	(linux_attach_lwp): Use linux_enable_event_reporting.
	(linux_wait_for_event): Don't keep waiting if the extended wait
	status should be reported to gdb.
	(linux_wait): Use linux_enable_event_reporting.  If waitstatus
	holds a processed event, return it instead.
	* remote-utils.c (prepare_resume_reply): Handle
	TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	* linux-low.h (struct lwp_info) <waitstatus>: New member.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops) <pid_to_exec_file>: New member.
	* server.c (handle_query): Handle qExecFile.
	* linux-low.c (linux_pid_to_exec_file): New.
	(linux_target_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (is_lwpid): New.
	(linux_kill_one_lwp, linux_kill_1, linux_detach_one_lwp): Adjust.
	(status_pending_p): Check if we're interested in this lwp.
	(linux_wait_for_lwp): Change signature: return an lwp_info*, and
	take a ptid instead of an lwp_info**.
	(linux_wait_for_event): Take a ptid instead of a thread_info
	pointer.  Adjust.
	(wait_for_sigstop): Adjust.  If a whole process died, keep the
	exit status pending.
	(ptid_is_pid, ptid_same_pid): New.
	(linux_set_resume_request): Allow resuming all threads of a process.
	(resume_status_pending_p): Check for dead lwps.

	* linux-low.h (struct lwp_info) <dead>: New field.

	* server.c (start_inferior): Only resume and wait for events from
	the inferior we're creating.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Decouple target code from remote protocol.

	* linux-low.c (linux_wait): Change prototype.  Adjust.
	* server.c (last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.
	(attach_inferior, handle_v_cont, handle_v_attach, handle_v_run)
	(handle_v_kill, handle_v_requests): Remove "status" and "signal"
	parameters.  Adjust.
	(myresume): Rename to ...
	(proceed): ... this.  Remove "statusp" parameter.  Adjust.
	(main): Remove "status" local.  Adjust.
	* target.c (mywait): Change prototype.  Adjust.
	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Change prototype.
	(mywait): Adjust.
	* remote-utils.c: Include "target.h".
	(prepare_resume_reply): Change prototype to take a ptid and a
	target_waitstatus.  Adjust.
	* server.h (prepare_resume_reply): Adjust prototype.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (all_processes): New.
	(add_process): New.

	* linux-low.c (linux_create_inferior): Add process.
	(linux_attach_lwp): Add "initial" parameter, and use it instead of
	relying on having only one thread in the global list.
	(linux_attach): Add process.
	(struct counter): New.
	(check_if_last_thread_of_pid, is_last_thread_of_process): New.
	(linux_kill_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Use
	is_last_thread_of_process.
	(linux_kill): Rename to ...
	(linux_kill_1): ... this.  Kill lwps of the requested only.
	(linux_kill_one_process): New.
	(linux_kill): New.
	(linux_detach_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Remove the lwp from
	both the lwp list and the thread list.
	(any_thread_of, linux_detach_1, linux_detach_one_process): New.
	(linux_detach): Reimplement.
	(linux_wait_for_event): Use is_last_thread_of_process.
	(linux_wait): Likewise.  On process exit, don't clear all inferiors.
	Implement multi-process extensions.

	* mem-break.c (breakpoints): Delete.
	(struct breakpoint_list): New.
	(all_breakpoints): New.
	(get_breakpoint_list): New.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Use it.

	* server.h (struct process_info): New.
	(all_processes): Declare.
	(add_process): Declare.

	* linux-low.h (linux_attach_lwp): Add "initial" parameter.

	* thread-db.c (maybe_attach_thread): Adjust.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c, linux-low.h, proc-service.c, thread-db.c: Rename
	`struct process_info' to `struct lwp_info', and adjust throughout.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Implement remote protocol multi-process extensions.

	* inferiors.c (null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New functions.
	(add_thread): Drop gdb_id argument.  Retype thread_id argument to
	ptid_t.  Adjust.
	(thread_id_to_gdb_id): Adjust.
	(thread_to_gdb_id): Change return type to ptid_t.  Adjust.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Adjust.
	(gdb_id_to_thread_id): Change return type to ptid_t.  Adjust.
	(find_inferior_id): Change id argument type to ptid_t.  Adjust.
	(loaded_dll, add_pid_to_list, pull_pid_from_list): Adjust.
	(initialize_inferiors): New.

	* remote-utils.c (hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, read_ptid): New.
	(prepare_resume_reply): Adjust.

	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait): Change type to ptid_t.
	(multi_process): New.
	(start_inferior): Adjust.
	(handle_query): Adjust.  Report multiprocess extensions support.
	(handle_v_cont): Adjust.
	(handle_v_kill): New.
	(handle_v_requests): Handle vKill.
	(myresume): Adjust.
	(first_thread_of): New.
	(main): Call initialize_inferiors.  If bailing out, kill all
	inferiors.  Handle multi-process detach.  Handle multi-process H
	and T.

	* server.h (ULONGEST): New typedef.
	(struct ptid): New struct.
	(ptid_t): New typedef.
	(minus_one_ptid, null_ptid): New.
	(ptid_t ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New.
	(struct inferior_list_entry) <id>: Change type to ptid_t.
	(add_thread, thread_id_to_gdb_id, thread_to_gdb_id)
	(gdb_id_to_thread_id): Adjust prototypes.
	(find_thread_pid): Declare.
	(find_inferior_id): Adjust prototype.
	(cont_thread, general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Adjust type to ptid_t.
	(multi_process): Declare.
	(read_ptid, write_ptid): Declare.

	* linux-low.c (pid_of): Adjust.
	(lwpid_of): New.
	(inferior_lwpid): New.
	(handle_extended_wait): Adjust.
	(add_process): Change pid argument to a ptid.  Adjust.
	(linux_create_inferior): Adjust.
	(linux_attach_lwp): Adjust.  Clear new_inferior on error.  If
	creating a new inferior, don't rely on inferior_pid, instead use
	the lwpid as pid.
	(linux_attach): Set new_inferior earlier.  Adjust.
	(linux_kill): Change return type to int.  Adjust.
	(linux_detach): Add pid parameter.
	(linux_thread_alive): Change lwpid paremeter type to ptid.
	Adjust.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_process): Adjust.
	(linux_wait_for_process, linux_wait_for_event, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process,
	(linux_resume_one_process, linux_set_resume_request)
	(linux_continue_one_thread, linux_queue_one_thread)
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory, linux_request_interrupt, linux_read_auxv):
	Adjust.

	* linux-low.h (get_process_thread): Adjust.
	(struct process_info) <lwpid>: Remove.
	(find_lwp_pid): Declare.

	* target.c (set_desired_inferior): Adjust.
	(target_pid_to_str): New.

	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_ops) <kill>: Change return type to int, and take an
	int as parameter.
	(struct target_ops) <detach>: Take an int as parameter.
	(struct target_ops) <thread_alive>: Change pid argument type to
	ptid_t.
	(kill_inferior, detach_inferior): Add PID argument.

	* thread-db.c (thread_db_create_event): Adjust.
	(find_one_thread): Change argument to a ptid.  Adjust.
	(maybe_attach_thread, thread_db_get_tls_address, thread_db_init):
	Adjust.

	* proc-service.c (ps_lgetregs): Adjust.
@
text
@d38 3
a40 2
static int find_one_thread (ptid_t);
static int find_new_threads_callback (const td_thrhandle_t *th_p, void *data);
d42 2
a43 5
static void
fixup_proc_handle (void)
{
  ptid_t inferior_ptid;
  struct process_info_private *proc = current_process ()->private;
d45 2
a46 22
  /* FIXME drow/2004-10-16: This is the "overall process ID", which
     GNU/Linux calls tgid, "thread group ID".  When we support
     attaching to threads, the original thread may not be the correct
     thread.  We would have to get the process ID from /proc for NPTL.
     For LinuxThreads we could do something similar: follow the chain
     of parent processes until we find the highest one we're attached
     to, and use its tgid.

     This isn't the only place in gdbserver that assumes that the first
     process in the list is the thread group leader.  */

  /* We're actually passing the current lwp to proc_services.  This is
     because in non-stop mode, the tgid process may be running at this
     point --- linux doesn't allow reading memory through running
     LWPs.  At this point, I'm not sure if it's useful to actually
     have a proc_handle.pid instead of just making proc_services
     return current_inferior->id.pid directly.  */

  inferior_ptid = ((struct inferior_list_entry *)current_inferior)->id;

  proc->proc_handle.pid = ptid_get_lwp (inferior_ptid);
}
d139 1
a139 1
  struct lwp_info *lwp;
a143 2
  fixup_proc_handle ();

d148 1
a148 1
  err = td_ta_event_getmsg (current_process()->private->thread_agent, &msg);
d156 3
a158 3
  lwp = get_thread_lwp (current_inferior);
  if (lwp->thread_known == 0)
    find_one_thread (lwp->head.id);
a183 1
  struct process_info_private *proc = current_process()->private;
d195 1
a195 1
  err = td_ta_set_event (proc->thread_agent, &events);
d204 1
a204 1
  err = td_ta_event_addr (proc->thread_agent, TD_CREATE, &notify);
a210 1

d219 1
a219 1
  err = td_ta_event_addr (proc->thread_agent, TD_DEATH, &notify);
d234 1
a234 1
find_one_thread (ptid_t ptid)
d240 1
a240 2
  struct lwp_info *lwp;
  int lwpid = ptid_get_lwp (ptid);
d242 3
a244 3
  inferior = (struct thread_info *) find_inferior_id (&all_threads, ptid);
  lwp = get_thread_lwp (inferior);
  if (lwp->thread_known)
d248 1
a248 1
  err = td_ta_map_lwp2thr (current_process()->private->thread_agent, lwpid, &th);
d262 1
a262 1
  if (lwpid != ti.ti_lid)
d265 1
a265 1
	       (long) lwpid, (long) ti.ti_lid);
d282 3
a284 3
  lwp->thread_known = 1;
  lwp->tid = ti.ti_tid;
  lwp->th = th;
d293 2
a294 1
  struct lwp_info *lwp;
d296 3
a298 2
  lwp = find_lwp_pid (pid_to_ptid (ti_p->ti_lid));
  if (lwp != NULL)
d304 4
a307 3
  linux_attach_lwp (ti_p->ti_lid, 0);
  lwp = find_lwp_pid (pid_to_ptid (ti_p->ti_lid));
  if (lwp == NULL)
d314 5
a318 3
  lwp->tid = ti_p->ti_tid;
  lwp->thread_known = 1;
  lwp->th = *th_p;
a351 1
  ptid_t ptid = ((struct inferior_list_entry *)current_inferior)->id;
d356 1
a356 3
  /* Is there any harm done in using the current inferior for
     this?  */
  if (find_one_thread (ptid) == 0)
a358 3
  /* Make sure we give thread_db the right lwp to talk to.  */
  fixup_proc_handle ();

d360 1
a360 2
  err = td_ta_thr_iter (current_process()->private->thread_agent,
			find_new_threads_callback, NULL,
d389 1
a389 4
  struct lwp_info *lwp;

  /* Make sure we give thread_db the right lwp to talk to.  */
  fixup_proc_handle ();
d391 4
a394 4
  lwp = get_thread_lwp (thread);
  if (!lwp->thread_known)
    find_one_thread (lwp->head.id);
  if (!lwp->thread_known)
d400 1
a400 1
  err = td_thr_tls_get_addr (&lwp->th, (psaddr_t) (uintptr_t) load_module,
a417 2
  struct process_info *proc = current_process ();
  struct process_info_private *priv = proc->private;
d419 11
a429 1
  fixup_proc_handle ();
d432 1
a432 1
  proc->all_symbols_looked_up = 0;
d436 1
a436 1
  err = td_ta_new (&priv->proc_handle, &priv->thread_agent);
d450 1
a450 1
      proc->all_symbols_looked_up = 1;
@


1.14
log
@	* linux-low.c (linux_wait_for_event): Update messages.  Do not
	reinsert auto-delete breakpoints.
	* mem-break.c (struct breakpoint): Change return type of handler to
	int.
	(set_breakpoint_at): Update handler type.
	(reinsert_breakpoint_handler): Return 1 instead of calling
	delete_breakpoint.
	(reinsert_breakpoint_by_bp): Check for the original breakpoint before
	setting a new one.
	(check_breakpoints): Delete auto-delete breakpoints and return 2.
	* mem-break.h (set_breakpoint_at): Update handler type.
	* thread-db.c (thread_db_create_event, thread_db_create_event): Update.
	* win32-low.c (auto_delete_breakpoint): New.
	(get_child_debug_event): Use it.
@
text
@d2 2
a3 1
   Copyright (C) 2002, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.13
log
@	* inferiors.c (change_inferior_id): Delete.
	(add_pid_to_list, pull_pid_from_list): New.
	* linux-low.c (PTRACE_SETOPTIONS, PTRACE_GETEVENTMSG)
	(PTRACE_O_TRACESYSGOOD, PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK)
	(PTRACE_O_TRACECLONE, PTRACE_O_TRACEEXEC, PTRACE_O_TRACEVFORKDONE)
	(PTRACE_O_TRACEEXIT, PTRACE_EVENT_FORK, PTRACE_EVENT_VFORK)
	(PTRACE_EVENT_CLONE, PTRACE_EVENT_EXEC, PTRACE_EVENT_VFORK_DONE)
	(PTRACE_EVENT_EXIT, __WALL): Provide default definitions.
	(stopped_pids, thread_db_active, must_set_ptrace_flags): New variables.
	(using_threads): Always set to 1.
	(handle_extended_wait): New.
	(add_process): Do not set TID.
	(linux_create_inferior): Set must_set_ptrace_flags.
	(linux_attach_lwp): Remove TID argument.  Do not check using_threads.
	Use PTRACE_SETOPTIONS.  Call new_thread_notify.  Update all callers.
	(linux_thread_alive): Rename TID argument to LWPID.
	(linux_wait_for_process): Handle unknown processes.  Do not use TID.
	(linux_wait_for_event): Do not use TID or check using_threads.  Update
	call to dead_thread_notify.  Call handle_extended_wait.
	(linux_create_inferior): Use PTRACE_SETOPTIONS.
	(send_sigstop): Delete sigstop_sent.
	(wait_for_sigstop): Avoid TID.
	(linux_supports_tracefork_flag, linux_tracefork_child, my_waitpid)
	(linux_test_for_tracefork): New.
	(linux_lookup_signals): Use thread_db_active and
	linux_supports_tracefork_flag.
	(initialize_low): Use thread_db_active and linux_test_for_tracefork.
	* linux-low.h (get_process_thread): Avoid TID.
	(struct process_ifo): Move thread_known and tid to the end.  Remove
	sigstop_sent.
	(linux_attach_lwp, thread_db_init): Update prototypes.
	* server.h (change_inferior_id): Delete prototype.
	(add_pid_to_list, pull_pid_from_list): New prototypes.
	* thread-db.c (thread_db_use_events): New.
	(find_first_thread): Rename to...
	(find_one_thread): ...this.  Update callers and messages.  Do not
	call fatal.  Check thread_db_use_events.  Do not call
	change_inferior_id or new_thread_notify.
	(maybe_attach_thread): Update.  Do not call new_thread_notify.
	(thread_db_init): Set thread_db_use_events.  Check use_events.
	* utils.c (fatal, warning): Correct message prefix.
@
text
@d133 1
a133 1
static void
d162 2
d167 1
a167 1
static void
d172 2
@


1.12
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d27 2
d44 1
a44 1
static int find_first_thread (void);
d157 1
a157 1
    find_first_thread ();
d229 1
a229 1
find_first_thread (void)
d237 1
a237 1
  inferior = (struct thread_info *) all_threads.head;
d242 1
a242 1
  /* Get information about the one thread we know we have.  */
d245 2
a246 1
    error ("Cannot get first thread handle: %s", thread_db_err_str (err));
d250 2
a251 1
    error ("Cannot get first thread info: %s", thread_db_err_str (err));
d254 1
a254 1
    fprintf (stderr, "Found first thread %ld (LWP %d)\n",
d258 5
a262 2
    fatal ("PID mismatch!  Expected %ld, got %ld",
	   (long) process->lwpid, (long) ti.ti_lid);
d264 1
a264 3
  /* If the new thread ID is zero, a final thread ID will be available
     later.  Do not enable thread debugging yet.  */
  if (ti.ti_tid == 0)
a269 1
      return 0;
d272 4
a275 4
  /* Switch to indexing the threads list by TID.  */
  change_inferior_id (&all_threads, ti.ti_tid);

  new_thread_notify (ti.ti_tid);
d277 1
a278 2
  process->lwpid = ti.ti_lid;
  process->thread_known = 1;
a280 5
  err = td_thr_event_enable (&th, 1);
  if (err != TD_OK)
    error ("Cannot enable thread event reporting for %d: %s",
           ti.ti_lid, thread_db_err_str (err));

d292 1
a292 1
						      ti_p->ti_tid);
d299 1
a299 1
  linux_attach_lwp (ti_p->ti_lid, ti_p->ti_tid);
d301 1
a301 1
						      ti_p->ti_tid);
a310 2
  new_thread_notify (ti_p->ti_tid);

a311 2
  process->lwpid = ti_p->ti_lid;

d314 8
a321 4
  err = td_thr_event_enable (th_p, 1);
  if (err != TD_OK)
    error ("Cannot enable thread event reporting for %d: %s",
           ti_p->ti_lid, thread_db_err_str (err));
d351 1
a351 1
  if (find_first_thread () == 0)
d388 1
a388 1
    find_first_thread ();
d410 1
a410 1
thread_db_init ()
d429 2
d441 1
a441 1
      if (thread_db_enable_reporting () == 0)
@


1.11
log
@	* inferiors.c (change_inferior_id): Add comment.
	* linux-low.c (check_removed_breakpoint): Add an early
	prototype.  Improve debug output.
	(linux_attach): Doc update.
	(linux_detach_one_process, linux_detach): Clean up before releasing
	each process.
	(send_sigstop, wait_for_sigstop): Improve comments and debug output.
	* linux-low.h (struct process_info): Doc improvement.
	* mem-break.c (delete_all_breakpoints): New.
	* mem-break.h (delete_all_breakpoints): New prototype.
	* thread-db.c (find_first_thread): New.
	(thread_db_create_event): Call it instead of
	thread_db_find_new_threads.  Clean up unused variables.
	(maybe_attach_thread): Remove first thread handling.
	(thread_db_find_new_threads): Use find_first_thread.
	(thread_db_get_tls_address): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.10
log
@	* linux-thread-db.c (thread_db_attach): Delete.
	(thread_db_detach): Typo fix.  Call target_mourn_inferior
	instead of fixing up proc_handle.
	(have_threads_callback, have_threads): New functions.
	(thread_db_wait): Remove dead proc_handle.pid check.  Only
	translate PTIDs if we have registered threads.  Check for new
	threads if we have none.
	(thread_db_create_inferior, thread_db_post_startup_inferior): Delete.
	(find_new_threads_callback): Only enable event reporting if TID == 0.
	(same_ptid_callback): New.
	(thread_db_get_thread_local_address): Check for new threads.
	(init_thread_db_ops): Don't set to_attach, to_create_inferior,
	or to_post_startup_inferior.

	* thread-db.c (thread_db_find_new_threads): Add prototype.
	(thread_db_create_event): Check for the main thread before adding
	a new thread.
	(maybe_attach_thread): Only enable event reporting if TID == 0.
	(thread_db_get_tls_address): Check for new threads.
@
text
@d44 1
a44 1
static void thread_db_find_new_threads (void);
a137 2
  struct inferior_linux_data *tdata;
  struct thread_info *inferior;
a142 2
  tdata = inferior_target_data (current_inferior);

d155 1
a155 2
  inferior = (struct thread_info *) all_threads.head;
  process = get_thread_process (inferior);
d157 1
a157 1
    thread_db_find_new_threads ();
d228 60
a294 30
  /* If we are attaching to our first thread, things are a little
     different.  */
  if (all_threads.head == all_threads.tail)
    {
      inferior = (struct thread_info *) all_threads.head;
      process = get_thread_process (inferior);

      if (process->thread_known == 0)
	{
	  /* If the new thread ID is zero, a final thread ID will be
	     available later.  Do not enable thread debugging yet.  */
	  if (ti_p->ti_tid == 0)
	    {
	      err = td_thr_event_enable (th_p, 1);
	      if (err != TD_OK)
		error ("Cannot enable thread event reporting for %d: %s",
		       ti_p->ti_lid, thread_db_err_str (err));
	      return;
	    }

	  if (process->lwpid != ti_p->ti_lid)
	    fatal ("PID mismatch!  Expected %ld, got %ld",
		   (long) process->lwpid, (long) ti_p->ti_lid);

	  /* Switch to indexing the threads list by TID.  */
	  change_inferior_id (&all_threads, ti_p->ti_tid);
	  goto found;
	}
    }
  
a314 1
found:
d352 6
d392 1
a392 1
    thread_db_find_new_threads ();
@


1.9
log
@Copyright updates for 2007.
@
text
@d44 1
d139 2
d156 8
d246 1
d249 15
d362 2
@


1.8
log
@gdb/gdbserver/
	* Makefile.in (clean): Remove reg-mips64.c.
	(reg-mips64.c, reg-mips64.o): New rules.
	* configure.srv: Handle mips64.  Include regset support for mips.
	* linux-mips-low.c (union mips_register): New.
	(mips_get_pc, mips_set_pc, mips_reinsert_addr): Use it.
	(mips_breakpoint, mips_breakpoint_at): Use int.
	(mips_collect_register, mips_supply_register)
	(mips_collect_register_32bit, mips_supply_register_32bit)
	(mips_fill_gregset, mips_store_gregset, mips_fill_fpregset)
	(mips_store_fpregset, target_regsets): New.
	* thread-db.c (thread_db_get_tls_address): Use uintptr_t.
gdb/
	* regformats/reg-mips64.dat: New file.
@
text
@d2 1
a2 2
   Copyright (C) 2002, 2004, 2005, 2006
   Free Software Foundation, Inc.
@


1.7
log
@	* acinclude.m4 (SRV_CHECK_TLS_GET_ADDR): New.
	* configure.ac: Use it.  Define HAVE_TD_THR_TLS_GET_ADDR.
	* config.in, configure: Regenerated.
	* inferiors.c (gdb_id_to_thread): New function.
	(gdb_id_to_thread_id): Use it.
	* linux-low.c (linux_target_ops): Use thread_db_get_tls_address.
	* linux-low.h (struct process_info): Add th member.
	(thread_db_get_tls_address): New prototype.
	* remote-utils.c (decode_address): Make non-static.
	* server.c (handle_query): Handle qGetTLSAddr.
	* server.h (gdb_id_to_thread, decode_address): New prototypes.
	* target.h (struct target_ops): Add get_tls_address.
	* thread-db.c (maybe_attach_thread): Save the thread handle.
	(thread_db_get_tls_address): New.
@
text
@d36 2
d338 5
a342 2
  err = td_thr_tls_get_addr (&process->th, (psaddr_t) load_module, offset,
			     &addr);
d345 1
a345 1
      *address = (CORE_ADDR) addr;
@


1.6
log
@	* remote-utils.c (all_symbols_looked_up): New variable.
	(look_up_one_symbol): Check it.
	* server.h (look_up_one_symbol): New declaration.
	* thread-db.c (thread_db_init): Set all_symbols_looked_up.
@
text
@d269 1
d324 27
@


1.5
log
@	* configure.ac: Remove checks for prfpregset_t.
	* gdb_proc_service.h: New file.
	* linux-i386-low.c, linux-x86-64-low.c, thread-db.c: Use the
	new "gdb_proc_service.h".
	* proc-service.c: Likewise.
	(ps_pglobal_lookup, ps_pdread, ps_pdwrite): Use psaddr_t.
	(ps_lgetfpregs, ps_lsetfpregs): Use a void* argument.
	* Makefile.in (gdb_proc_service_h): Updated.
	* configure, config.in: Regenerated.
@
text
@d339 3
d356 1
@


1.5.8.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a338 3
  /* Allow new symbol lookups.  */
  all_symbols_looked_up = 0;

a352 1
      all_symbols_looked_up = 1;
@


1.4
log
@	* linux-arm-low.c:
	* linux-cris-low.c:
	* inferiors.c:
	* i387-fp.h:
	* i387-fp.c:
	* gdbreplay.c:
	* regcache.c:
	* proc-service.c:
	* mem-break.h:
	* mem-break.c:
	* linux-x86-64-low.c:
	* linux-sh-low.c:
	* linux-s390-low.c:
	* linux-ppc64-low.c:
	* linux-ppc-low.c:
	* linux-mips-low.c:
	* linux-m68k-low.c:
	* linux-m32r-low.c:
	* linux-low.h:
	* linux-low.c:
	* linux-ia64-low.c:
	* linux-i386-low.c:
	* linux-crisv32-low.c:
	* thread-db.c:
	* terminal.h:
	* target.h:
	* target.c:
	* server.h:
	* server.c:
	* remote-utils.c:
	* regcache.h:
	* utils.c:
	* Makefile.in:
	* configure.ac:
	* gdbserver.1: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005
d34 1
a34 13
/* Correct for all GNU/Linux targets (for quite some time).  */
#define GDB_GREGSET_T elf_gregset_t
#define GDB_FPREGSET_T elf_fpregset_t

#ifndef HAVE_ELF_FPREGSET_T
/* Make sure we have said types.  Not all platforms bring in <linux/elf.h>
   via <sys/procfs.h>.  */
#ifdef HAVE_LINUX_ELF_H
#include <linux/elf.h>
#endif
#endif

#include "../gdb_proc_service.h"
@


1.4.2.1
log
@Merge ten gdb and gdbserver patches for MIPS/MIPS64 support.
@
text
@d2 1
a2 1
   Copyright (C) 2002, 2004, 2005, 2006
d34 13
a46 1
#include "gdb_proc_service.h"
@


1.3
log
@	* acinclude.m4: Correct quoting.
	* aclocal.m4: Regenerated.

	Suggested by SZOKOVACS Robert <szo@@ies.hu>:
	* thread-db.c (thread_db_err_str): Handle TD_VERSION.
	(thread_db_init): Call thread_db_err_str.
	* configure.ac: Check for TD_VERSION.
	* config.in, configure: Regenerated.
@
text
@d2 1
a2 1
   Copyright 2002, 2004, 2005
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.2
log
@	* linux-i386-low.c (ps_get_thread_area): New.
	* linux-x86-64-low.c (ps_get_thread_area): New.
	* linux-low.c: Include <sys/syscall.h>.
	(linux_kill_one_process): Don't kill the first thread here.
	(linux_kill): Kill the first thread here.
	(kill_lwp): New function.
	(send_sigstop, linux_send_signal): Use it.
	* proc-service.c: Clean up #ifdefs.
	(fpregset_info): Delete.
	(ps_lgetregs): Update and enable implementation.
	(ps_lsetregs, ps_lgetfpregs, ps_lsetfpregs): Remove disabled
	implementations.
	* remote-utils.c (struct sym_cache, symbol_cache): New.
	(input_interrupt): Print a clearer message.
	(async_io_enabled): New variable.
	(enable_async_io, disable_async_io): Use it.  Update comments.
	(look_up_one_symbol): Use the symbol cache.
	* thread-db.c (thread_db_look_up_symbols): New function.
	(thread_db_init): Update comments.  Call thread_db_look_up_symbols.
@
text
@d2 1
a2 1
   Copyright 2002
d106 4
d368 2
a369 1
      warning ("error initializing thread_db library.");
@


1.1
log
@2002-06-11  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbserver/thread-db.c: New file.
	* gdbserver/proc-service.c: New file.
	* gdbserver/acinclude.m4: New file.
	* gdbserver/Makefile.in: Add GDBSERVER_LIBS, gdb_proc_service_h,
	proc-service.o, and thread-db.o.
	(linux-low.o): Add USE_THREAD_DB.
	* gdbserver/acconfig.h: Add HAVE_PRGREGSET_T, HAVE_PRFPREGSET_T,
	HAVE_LWPID_T, HAVE_PSADDR_T, and PRFPREGSET_T_BROKEN.
	* gdbserver/aclocal.m4: Regenerated.
	* gdbserver/config.in: Regenerated.
	* gdbserver/configure: Regenerated.
	* gdbserver/configure.in: Check for proc_service.h, sys/procfs.h,
	thread_db.h, and linux/elf.h headrs.
	Check for lwpid_t, psaddr_t, prgregset_t, prfpregset_t, and
	PRFPREGSET_T_BROKEN.  Introduce srv_thread_depfiles and USE_THREAD_DB.
	Check for -lthread_db and thread support.
	* gdbserver/configure.srv: Enable thread_db support for ARM, i386, MIPS,
	PowerPC, and SuperH.
	* gdbserver/i387-fp.c: Constify arguments.
	* gdbserver/i387-fp.h: Likewise.
	* gdbserver/inferiors.c: (struct thread_info): Renamed from
	`struct inferior_info'.  Remove PID member.  Use generic inferior
	list header.  All uses updated.
	(inferiors, signal_pid): Removed.
	(all_threads): New variable.
	(get_thread): Define.
	(add_inferior_to_list): New function.
	(for_each_inferior): New function.
	(change_inferior_id): New function.
	(add_inferior): Removed.
	(remove_inferior): New function.
	(add_thread): New function.
	(free_one_thread): New function.
	(remove_thread): New function.
	(clear_inferiors): Use for_each_inferior and free_one_thread.
	(find_inferior): New function.
	(find_inferior_id): New function.
	(inferior_target_data): Update argument type.
	(set_inferior_target_data): Likewise.
	(inferior_regcache_data): Likewise.
	(set_inferior_regcache_data): Likewise.
	* gdbserver/linux-low.c (linux_bp_reinsert): Remove.
	(all_processes, stopping_threads, using_thrads)
	(struct pending_signals, debug_threads, pid_of): New.
	(inferior_pid): Replace with macro.
	(struct inferior_linux_data): Remove.
	(get_stop_pc, add_process): New functions.
	(linux_create_inferior): Restore SIGRTMIN+1 before calling exec.
	Use add_process and add_thread.
	(linux_attach_lwp): New function, based on old linux_attach.  Use
	add_process and add_thread.  Set stop_expected for new threads.
	(linux_attach): New function.
	(linux_kill_one_process): New function.
	(linux_kill): Kill all LWPs.
	(linux_thread_alive): Use find_inferior_id.
	(check_removed_breakpoints, status_pending_p): New functions.
	(linux_wait_for_process): Renamed from linux_wait_for_one_inferior.
	Update.  Use WNOHANG.  Wait for cloned processes also.  Update process
	struct for the found process.
	(linux_wait_for_event): New function.
	(linux_wait): Use it.  Support LWPs.
	(send_sigstop, wait_for_sigstop, stop_all_processes)
	(linux_resume_one_process, linux_continue_one_process): New functions.
	(linux_resume): Support LWPs.
	(REGISTER_RAW_SIZE): Remove.
	(fetch_register): Use register_size instead.  Call supply_register.
	(usr_store_inferior_registers): Likewise.  Call collect_register.
	Fix recursive case.
	(regsets_fetch_inferior_registers): Improve error message.
	(regsets_store_inferior_registers): Add debugging.
	(linux_look_up_symbols): Call thread_db_init if USE_THREAD_DB.
	(unstopped_p, linux_signal_pid): New functions.
	(linux_target_ops): Add linux_signal_pid.
	(linux_init_signals): New function.
	(initialize_low): Call it.  Initialize using_threads.
	* gdbserver/regcache.c (inferior_regcache_data): Add valid
	flag.
	(get_regcache): Fetch registers lazily.  Add fetch argument
	and update all callers.
	(regcache_invalidate_one, regcache_invalidate): New
	functions.
	(new_register_cache): Renamed from create_register_cache.
	Return the new regcache.
	(free_register_cache): Change argument to a void *.
	(registers_to_string, registers_from_string): Call get_regcache
	with fetch flag set.
	(register_data): Make static.  Pass fetch flag to get_regcache.
	(supply_register): Call get_regcache with fetch flag clear.
	(collect_register): Call get_regcache with fetch flag set.
	(collect_register_as_string): New function.
	* gdbserver/regcache.h: Update.
	* gdbserver/remote-utils.c (putpkt): Flush after debug output and use
	stderr.
	Handle input interrupts while waiting for an ACK.
	(input_interrupt): Use signal_pid method.
	(getpkt): Flush after debug output and use stderr.
	(outreg): Use collect_register_as_string.
	(new_thread_notify, dead_thread_notify): New functions.
	(prepare_resume_reply): Check using_threads.  Set thread_from_wait
	and general_thread.
	(look_up_one_symbol): Flush after debug output.
	* gdbserver/server.c (step_thread, server_waiting): New variables.
	(start_inferior): Don't use signal_pid.  Update call to mywait.
	(attach_inferior): Update call to mywait.
	(handle_query): Handle qfThreadInfo and qsThreadInfo.
	(main): Don't fetch/store registers explicitly.  Use
	set_desired_inferior.  Support proposed ``Hs'' packet.  Update
	calls to mywait.
	* gdbserver/server.h: Update.
	(struct inferior_list, struct_inferior_list_entry): New.
	* gdbserver/target.c (set_desired_inferior): New.
	(write_inferior_memory): Constify.
	(mywait): New function.
	* gdbserver/target.h: Update.
	(struct target_ops): New signal_pid method.
	(mywait): Removed macro, added prototype.

	* gdbserver/linux-low.h (regset_func): Removed.
	(regset_fill_func, regset_store_func): New.
	(enum regset_type): New.
	(struct regset_info): Add type field.  Use new operation types.
	(struct linux_target_ops): stop_pc renamed to get_pc.
	Add decr_pc_after_break and breakpoint_at.
	(get_process, get_thread_proess, get_process_thread)
	(strut process_info, all_processes, linux_attach_lwp)
	(thread_db_init): New.

	* gdbserver/linux-arm-low.c (arm_get_pc, arm_set_pc,
	arm_breakpoint, arm_breakpoint_len, arm_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-i386-low.c (i386_store_gregset, i386_store_fpregset)
	(i386_store_fpxregset): Constify.
	(target_regsets): Add new kind identifier.
	(i386_get_pc): Renamed from i386_stop_pc.  Simplify.
	(i386_set_pc): Add debugging.
	(i386_breakpoint_at): New function.
	(the_low_target): Add new members.
	* gdbserver/linux-mips-low.c (mips_get_pc, mips_set_pc)
	(mips_breakpoint, mips_breakpoint_len, mips_reinsert_addr)
	(mips_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-ppc-low.c (ppc_get_pc, ppc_set_pc)
	(ppc_breakpoint, ppc_breakpoint_len, ppc_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-sh-low.c (sh_get_pc, sh_set_pc)
	(sh_breakpoint, sh_breakpoint_len, sh_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-x86-64-low.c (target_regsets): Add new kind
	identifier.
@
text
@d315 15
d335 10
d360 1
@


1.1.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.1.2.1
log
@merge from trunk
@
text
@@

