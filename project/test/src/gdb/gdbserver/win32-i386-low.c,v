head	1.27;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.26
	gdb_7_6-2013-04-26-release:1.26
	gdb_7_6-branch:1.26.0.2
	gdb_7_6-2013-03-12-branchpoint:1.26
	gdb_7_5_1-2012-11-29-release:1.25
	gdb_7_5-2012-08-17-release:1.25
	gdb_7_5-branch:1.25.0.2
	gdb_7_5-2012-07-18-branchpoint:1.25
	gdb_7_4_1-2012-04-26-release:1.24.2.1
	gdb_7_4-2012-01-24-release:1.24.2.1
	gdb_7_4-branch:1.24.0.2
	gdb_7_4-2011-12-13-branchpoint:1.24
	gdb_7_3_1-2011-09-04-release:1.22.2.1
	gdb_7_3-2011-07-26-release:1.22.2.1
	gdb_7_3-branch:1.22.0.2
	gdb_7_3-2011-04-01-branchpoint:1.22
	gdb_7_2-2010-09-02-release:1.20
	gdb_7_2-branch:1.20.0.2
	gdb_7_2-2010-07-07-branchpoint:1.20
	gdb_7_1-2010-03-18-release:1.18
	gdb_7_1-branch:1.18.0.2
	gdb_7_1-2010-02-18-branchpoint:1.18
	gdb_7_0_1-2009-12-22-release:1.16
	gdb_7_0-2009-10-06-release:1.16
	gdb_7_0-branch:1.16.0.4
	gdb_7_0-2009-09-16-branchpoint:1.16
	arc-sim-20090309:1.11
	msnyder-checkpoint-072509-branch:1.16.0.2
	msnyder-checkpoint-072509-branchpoint:1.16
	arc-insight_6_8-branch:1.11.0.6
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.4
	insight_6_8-branchpoint:1.11
	reverse-20081226-branch:1.13.0.10
	reverse-20081226-branchpoint:1.13
	multiprocess-20081120-branch:1.13.0.8
	multiprocess-20081120-branchpoint:1.13
	reverse-20080930-branch:1.13.0.6
	reverse-20080930-branchpoint:1.13
	reverse-20080717-branch:1.13.0.4
	reverse-20080717-branchpoint:1.13
	msnyder-reverse-20080609-branch:1.13.0.2
	msnyder-reverse-20080609-branchpoint:1.13
	drow-reverse-20070409-branch:1.8.0.2
	drow-reverse-20070409-branchpoint:1.8
	gdb_6_8-2008-03-27-release:1.11
	gdb_6_8-branch:1.11.0.2
	gdb_6_8-2008-02-26-branchpoint:1.11
	gdb_6_7_1-2007-10-29-release:1.10
	gdb_6_7-2007-10-10-release:1.10
	gdb_6_7-branch:1.10.0.2
	gdb_6_7-2007-09-07-branchpoint:1.10
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.4
	gdb_6_6-2006-11-15-branchpoint:1.1
	nickrob-async-20060513-branch:1.1.0.2
	nickrob-async-20060828-mergepoint:1.1;
locks; strict;
comment	@ * @;


1.27
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2012.01.04.08.17.24;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.07.14.45.09;	author brobecke;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2011.05.31.21.18.56;	author palves;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2010.08.25.14.40.21;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2010.04.20.09.58.42;	author muller;	state Exp;
branches;
next	1.19;

1.19
date	2010.04.20.00.17.05;	author muller;	state Exp;
branches;
next	1.18;

1.18
date	2010.01.20.22.55.38;	author palves;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.04.18.13.28;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.30.16.35.25;	author devans;	state Exp;
branches;
next	1.14;

1.14
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.28.05.54.09;	author uweigand;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.27.03.27.40;	author uweigand;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.10.21.48.56;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2007.03.29.01.06.48;	author palves;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.28.22.00.15;	author palves;	state dead;
branches;
next	1.6;

1.6
date	2007.03.27.22.46.08;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.26.20.10.18;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.25.17.40.10;	author palves;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.03.17.57.16;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.07.23.03.52.15;	author drow;	state Exp;
branches
	1.1.2.1;
next	;

1.24.2.1
date	2012.01.06.04.43.40;	author brobecke;	state Exp;
branches;
next	;

1.22.2.1
date	2011.05.31.21.23.41;	author palves;	state Exp;
branches;
next	;

1.1.2.1
date	2006.08.28.07.48.46;	author nickrob;	state Exp;
branches;
next	;


desc
@@


1.27
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@/* Copyright (C) 2007-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "win32-low.h"
#include "i386-low.h"

#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

#define FCS_REGNUM 27
#define FOP_REGNUM 31

#define FLAG_TRACE_BIT 0x100

#ifdef __x86_64__
/* Defined in auto-generated file reg-amd64.c.  */
void init_registers_amd64 (void);
extern const struct target_desc *tdesc_amd64;
#else
/* Defined in auto-generated file reg-i386.c.  */
void init_registers_i386 (void);
extern const struct target_desc *tdesc_i386;
#endif

static struct i386_debug_reg_state debug_reg_state;

static int debug_registers_changed = 0;
static int debug_registers_used = 0;

/* Update the inferior's debug register REGNUM from STATE.  */

void
i386_dr_low_set_addr (const struct i386_debug_reg_state *state, int regnum)
{
  if (! (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR))
    fatal ("Invalid debug register %d", regnum);

  /* debug_reg_state.dr_mirror is already set.
     Just notify i386_set_thread_context, i386_thread_added
     that the registers need to be updated.  */
  debug_registers_changed = 1;
  debug_registers_used = 1;
}

CORE_ADDR
i386_dr_low_get_addr (int regnum)
{
  gdb_assert (DR_FIRSTADDR <= regnum && regnum <= DR_LASTADDR);

  return debug_reg_state.dr_mirror[regnum];
}

/* Update the inferior's DR7 debug control register from STATE.  */

void
i386_dr_low_set_control (const struct i386_debug_reg_state *state)
{
  /* debug_reg_state.dr_control_mirror is already set.
     Just notify i386_set_thread_context, i386_thread_added
     that the registers need to be updated.  */
  debug_registers_changed = 1;
  debug_registers_used = 1;
}

unsigned
i386_dr_low_get_control (void)
{
  return debug_reg_state.dr_control_mirror;
}

/* Get the value of the DR6 debug status register from the inferior
   and record it in STATE.  */

unsigned
i386_dr_low_get_status (void)
{
  /* We don't need to do anything here, the last call to thread_rec for
     current_event.dwThreadId id has already set it.  */
  return debug_reg_state.dr_status_mirror;
}

/* Watchpoint support.  */

static int
i386_insert_point (char type, CORE_ADDR addr, int len)
{
  switch (type)
    {
    case '2':
    case '3':
    case '4':
      return i386_low_insert_watchpoint (&debug_reg_state,
					 type, addr, len);
    default:
      /* Unsupported.  */
      return 1;
    }
}

static int
i386_remove_point (char type, CORE_ADDR addr, int len)
{
  switch (type)
    {
    case '2':
    case '3':
    case '4':
      return i386_low_remove_watchpoint (&debug_reg_state,
					 type, addr, len);
    default:
      /* Unsupported.  */
      return 1;
    }
}

static int
i386_stopped_by_watchpoint (void)
{
  return i386_low_stopped_by_watchpoint (&debug_reg_state);
}

static CORE_ADDR
i386_stopped_data_address (void)
{
  CORE_ADDR addr;
  if (i386_low_stopped_data_address (&debug_reg_state, &addr))
    return addr;
  return 0;
}

static void
i386_initial_stuff (void)
{
  i386_low_init_dregs (&debug_reg_state);
  debug_registers_changed = 0;
  debug_registers_used = 0;
}

static void
i386_get_thread_context (win32_thread_info *th, DEBUG_EVENT* current_event)
{
  /* Requesting the CONTEXT_EXTENDED_REGISTERS register set fails if
     the system doesn't support extended registers.  */
  static DWORD extended_registers = CONTEXT_EXTENDED_REGISTERS;

 again:
  th->context.ContextFlags = (CONTEXT_FULL
			      | CONTEXT_FLOATING_POINT
			      | CONTEXT_DEBUG_REGISTERS
			      | extended_registers);

  if (!GetThreadContext (th->h, &th->context))
    {
      DWORD e = GetLastError ();

      if (extended_registers && e == ERROR_INVALID_PARAMETER)
	{
	  extended_registers = 0;
	  goto again;
	}

      error ("GetThreadContext failure %ld\n", (long) e);
    }

  debug_registers_changed = 0;

  if (th->tid == current_event->dwThreadId)
    {
      /* Copy dr values from the current thread.  */
      struct i386_debug_reg_state *dr = &debug_reg_state;
      dr->dr_mirror[0] = th->context.Dr0;
      dr->dr_mirror[1] = th->context.Dr1;
      dr->dr_mirror[2] = th->context.Dr2;
      dr->dr_mirror[3] = th->context.Dr3;
      dr->dr_status_mirror = th->context.Dr6;
      dr->dr_control_mirror = th->context.Dr7;
    }
}

static void
i386_set_thread_context (win32_thread_info *th, DEBUG_EVENT* current_event)
{
  if (debug_registers_changed)
    {
      struct i386_debug_reg_state *dr = &debug_reg_state;
      th->context.Dr0 = dr->dr_mirror[0];
      th->context.Dr1 = dr->dr_mirror[1];
      th->context.Dr2 = dr->dr_mirror[2];
      th->context.Dr3 = dr->dr_mirror[3];
      /* th->context.Dr6 = dr->dr_status_mirror;
	 FIXME: should we set dr6 also ?? */
      th->context.Dr7 = dr->dr_control_mirror;
    }

  SetThreadContext (th->h, &th->context);
}

static void
i386_thread_added (win32_thread_info *th)
{
  /* Set the debug registers for the new thread if they are used.  */
  if (debug_registers_used)
    {
      struct i386_debug_reg_state *dr = &debug_reg_state;
      th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
      GetThreadContext (th->h, &th->context);

      th->context.Dr0 = dr->dr_mirror[0];
      th->context.Dr1 = dr->dr_mirror[1];
      th->context.Dr2 = dr->dr_mirror[2];
      th->context.Dr3 = dr->dr_mirror[3];
      /* th->context.Dr6 = dr->dr_status_mirror;
	 FIXME: should we set dr6 also ?? */
      th->context.Dr7 = dr->dr_control_mirror;

      SetThreadContext (th->h, &th->context);
      th->context.ContextFlags = 0;
    }
}

static void
i386_single_step (win32_thread_info *th)
{
  th->context.EFlags |= FLAG_TRACE_BIT;
}

#ifndef __x86_64__

/* An array of offset mappings into a Win32 Context structure.
   This is a one-to-one mapping which is indexed by gdb's register
   numbers.  It retrieves an offset into the context structure where
   the 4 byte register is located.
   An offset value of -1 indicates that Win32 does not provide this
   register in it's CONTEXT structure.  In this case regptr will return
   a pointer into a dummy register.  */
#define context_offset(x) ((int)&(((CONTEXT *)NULL)->x))
static const int mappings[] = {
  context_offset (Eax),
  context_offset (Ecx),
  context_offset (Edx),
  context_offset (Ebx),
  context_offset (Esp),
  context_offset (Ebp),
  context_offset (Esi),
  context_offset (Edi),
  context_offset (Eip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.RegisterArea[0 * 10]),
  context_offset (FloatSave.RegisterArea[1 * 10]),
  context_offset (FloatSave.RegisterArea[2 * 10]),
  context_offset (FloatSave.RegisterArea[3 * 10]),
  context_offset (FloatSave.RegisterArea[4 * 10]),
  context_offset (FloatSave.RegisterArea[5 * 10]),
  context_offset (FloatSave.RegisterArea[6 * 10]),
  context_offset (FloatSave.RegisterArea[7 * 10]),
  context_offset (FloatSave.ControlWord),
  context_offset (FloatSave.StatusWord),
  context_offset (FloatSave.TagWord),
  context_offset (FloatSave.ErrorSelector),
  context_offset (FloatSave.ErrorOffset),
  context_offset (FloatSave.DataSelector),
  context_offset (FloatSave.DataOffset),
  context_offset (FloatSave.ErrorSelector),
  /* XMM0-7 */
  context_offset (ExtendedRegisters[10 * 16]),
  context_offset (ExtendedRegisters[11 * 16]),
  context_offset (ExtendedRegisters[12 * 16]),
  context_offset (ExtendedRegisters[13 * 16]),
  context_offset (ExtendedRegisters[14 * 16]),
  context_offset (ExtendedRegisters[15 * 16]),
  context_offset (ExtendedRegisters[16 * 16]),
  context_offset (ExtendedRegisters[17 * 16]),
  /* MXCSR */
  context_offset (ExtendedRegisters[24])
};
#undef context_offset

#else /* __x86_64__ */

#define context_offset(x) (offsetof (CONTEXT, x))
static const int mappings[] =
{
  context_offset (Rax),
  context_offset (Rbx),
  context_offset (Rcx),
  context_offset (Rdx),
  context_offset (Rsi),
  context_offset (Rdi),
  context_offset (Rbp),
  context_offset (Rsp),
  context_offset (R8),
  context_offset (R9),
  context_offset (R10),
  context_offset (R11),
  context_offset (R12),
  context_offset (R13),
  context_offset (R14),
  context_offset (R15),
  context_offset (Rip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.FloatRegisters[0]),
  context_offset (FloatSave.FloatRegisters[1]),
  context_offset (FloatSave.FloatRegisters[2]),
  context_offset (FloatSave.FloatRegisters[3]),
  context_offset (FloatSave.FloatRegisters[4]),
  context_offset (FloatSave.FloatRegisters[5]),
  context_offset (FloatSave.FloatRegisters[6]),
  context_offset (FloatSave.FloatRegisters[7]),
  context_offset (FloatSave.ControlWord),
  context_offset (FloatSave.StatusWord),
  context_offset (FloatSave.TagWord),
  context_offset (FloatSave.ErrorSelector),
  context_offset (FloatSave.ErrorOffset),
  context_offset (FloatSave.DataSelector),
  context_offset (FloatSave.DataOffset),
  context_offset (FloatSave.ErrorSelector)
  /* XMM0-7 */ ,
  context_offset (Xmm0),
  context_offset (Xmm1),
  context_offset (Xmm2),
  context_offset (Xmm3),
  context_offset (Xmm4),
  context_offset (Xmm5),
  context_offset (Xmm6),
  context_offset (Xmm7),
  context_offset (Xmm8),
  context_offset (Xmm9),
  context_offset (Xmm10),
  context_offset (Xmm11),
  context_offset (Xmm12),
  context_offset (Xmm13),
  context_offset (Xmm14),
  context_offset (Xmm15),
  /* MXCSR */
  context_offset (FloatSave.MxCsr)
};
#undef context_offset

#endif /* __x86_64__ */

/* Fetch register from gdbserver regcache data.  */
static void
i386_fetch_inferior_register (struct regcache *regcache,
			      win32_thread_info *th, int r)
{
  char *context_offset = (char *) &th->context + mappings[r];

  long l;
  if (r == FCS_REGNUM)
    {
      l = *((long *) context_offset) & 0xffff;
      supply_register (regcache, r, (char *) &l);
    }
  else if (r == FOP_REGNUM)
    {
      l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
      supply_register (regcache, r, (char *) &l);
    }
  else
    supply_register (regcache, r, context_offset);
}

/* Store a new register value into the thread context of TH.  */
static void
i386_store_inferior_register (struct regcache *regcache,
			      win32_thread_info *th, int r)
{
  char *context_offset = (char *) &th->context + mappings[r];
  collect_register (regcache, r, context_offset);
}

static const unsigned char i386_win32_breakpoint = 0xcc;
#define i386_win32_breakpoint_len 1

static void
i386_arch_setup (void)
{
#ifdef __x86_64__
  init_registers_amd64 ();
  win32_tdesc = tdesc_amd64;
#else
  init_registers_i386 ();
  win32_tdesc = tdesc_i386;
#endif
}

struct win32_target_ops the_low_target = {
  i386_arch_setup,
  sizeof (mappings) / sizeof (mappings[0]),
  i386_initial_stuff,
  i386_get_thread_context,
  i386_set_thread_context,
  i386_thread_added,
  i386_fetch_inferior_register,
  i386_store_inferior_register,
  i386_single_step,
  &i386_win32_breakpoint,
  i386_win32_breakpoint_len,
  i386_insert_point,
  i386_remove_point,
  i386_stopped_by_watchpoint,
  i386_stopped_data_address
};
@


1.26
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d34 1
d38 1
d404 1
a404 1
init_windows_x86 (void)
d408 1
d411 1
d416 1
a416 1
  init_windows_x86,
@


1.25
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 1
a1 1
/* Copyright (C) 2007-2012 Free Software Foundation, Inc.
@


1.24
log
@[gdbserver] Fix watchpoint support on Windows

Watchpoint support doesn't work anymore when using gdbserver on Windows.
They just never trigger.

The problem comes from the fact that we always set the debug registers
to zero, no matter what.  This in turn comes from the fact that we
use i386_low_insert_watchpoint to compute the DR values:

      return i386_low_insert_watchpoint (&debug_reg_state,
                                         type, addr, len);

This function saves the new values in debug_reg_state.  However,
the values we actually use when setting the DR registers are
taken from two different globals:

        static unsigned dr_status_mirror;
        static unsigned dr_control_mirror;

These are really never actually changed (their value is set from
the DR values read from the inferior, but since we never change
them, in practice, they never change).

The fix is to use the values provided by debug_reg_state, and
to eliminate the two dr_[...] globals.

gdb/gdbserver/ChangeLog:

        * win32-i386-low.c (dr_status_mirror, dr_control_mirror): Delete.
        (i386_dr_low_get_control, i386_dr_low_get_status): Use
        dr_status_mirror and dr_control_mirror from debug_reg_state.
        (i386_dr_low_get_status): Use debug_reg_state.dr_status_mirror
        (i386_initial_stuff): Remove use of deleted globals.
        (i386_get_thread_context, i386_set_thread_context,
        i386_thread_added): Use dr_status_mirror and dr_control_mirror
        from debug_reg_state.
@
text
@d1 1
a1 1
/* Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.24.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 1
a1 1
/* Copyright (C) 2007-2012 Free Software Foundation, Inc.
@


1.23
log
@2011-05-31  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* linux-x86-low.c (i386_dr_low_get_addr): Fix off by one in
	assertion.
	* win32-i386-low.c (i386_dr_low_get_addr): Ditto.

	gdb/testsuite/
	* gdb.arch/i386-dr3-watch.c: New file.
	* gdb.arch/i386-dr3-watch.exp: New file.
@
text
@a39 2
static unsigned dr_status_mirror;
static unsigned dr_control_mirror;
d82 1
a82 1
  return dr_control_mirror;
d93 1
a93 1
  return dr_status_mirror;
a150 2
  dr_status_mirror = 0;
  dr_control_mirror = 0;
d189 2
a190 2
      dr_status_mirror = th->context.Dr6;
      dr_control_mirror = th->context.Dr7;
d204 1
a204 1
      /* th->context.Dr6 = dr_status_mirror;
d206 1
a206 1
      th->context.Dr7 = dr_control_mirror;
d226 1
a226 1
      /* th->context.Dr6 = dr_status_mirror;
d228 1
a228 1
      th->context.Dr7 = dr_control_mirror;
@


1.22
log
@run copyright.sh for 2011.
@
text
@d64 1
a64 1
  gdb_assert (DR_FIRSTADDR <= regnum && regnum < DR_LASTADDR);
@


1.22.2.1
log
@2011-05-31  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* linux-x86-low.c (i386_dr_low_get_addr): Fix off by one in
	assertion.
	* win32-i386-low.c (i386_dr_low_get_addr): Ditto.

	gdb/testsuite/
	* gdb.arch/i386-dr3-watch.c: New file.
	* gdb.arch/i386-dr3-watch.exp: New file.
@
text
@d64 1
a64 1
  gdb_assert (DR_FIRSTADDR <= regnum && regnum <= DR_LASTADDR);
@


1.21
log
@	PR threads/10729

	* linux-x86-low.c (update_debug_registers_callback): New.
	(i386_dr_low_set_addr): Use it.
	(i386_dr_low_get_addr): New.
	(i386_dr_low_set_control): Use update_debug_registers_callback.
	(i386_dr_low_get_control): New.
	(i386_dr_low_get_status): Adjust.
	* linux-low.c (linux_stop_lwp): New.
	* linux-low.h (linux_stop_lwp): Declare.

	* i386-low.c (I386_DR_GET_RW_LEN): Take the dr7 contents as
	argument instead of a i386_debug_reg_state.
	(I386_DR_WATCH_HIT): Take the dr6 contents as argument instead of
	a i386_debug_reg_state.
	(i386_insert_aligned_watchpoint): Adjust.
	(i386_remove_aligned_watchpoint): Adjust.
	(i386_low_stopped_data_address): Read the debug registers from the
	inferior instead of from the mirrors.
	* i386-low.h (struct i386_debug_reg_state): Extend comment.
	(i386_dr_low_get_addr): Declare.
	(i386_dr_low_get_control): Declare.
	(i386_dr_low_get_status): Change prototype.

	* win32-i386-low.c (dr_status_mirror, dr_control_mirror): New globals.
	(i386_dr_low_get_addr): New.
	(i386_dr_low_get_control): New.
	(i386_dr_low_get_status): Adjust prototype.  Return
	dr_status_mirror.
	(i386_initial_stuff): Clear dr_status_mirror and
	dr_control_mirror.
	(i386_get_thread_context): Adjust.
	(i386_set_thread_context): Adjust.
	(i386_thread_added): Adjust.
@
text
@d1 1
a1 1
/* Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.20
log
@	* win32-i386-low.c: Use __x86_64__ macro instead of __x86_64 to
	be consistent with other sources of this directory.
	(init_registers_amd64): Correct name of source file of this function
	in the comment.
@
text
@d40 2
d61 8
d81 6
d90 2
a91 2
void
i386_dr_low_get_status (struct i386_debug_reg_state *state)
d95 1
d153 2
d193 2
a194 2
      dr->dr_status_mirror = th->context.Dr6;
      dr->dr_control_mirror = th->context.Dr7;
d208 1
a208 1
      /* th->context.Dr6 = dr->dr_status_mirror;
d210 1
a210 1
      th->context.Dr7 = dr->dr_control_mirror;
d230 1
a230 1
      /* th->context.Dr6 = dr->dr_status_mirror;
d232 1
a232 1
      th->context.Dr7 = dr->dr_control_mirror;
@


1.19
log
@	* win32-i386-low.c: Add 64-bit support.
	(CONTEXT_EXTENDED_REGISTERS): Set macro to zero if not exisiting.
	(init_registers_amd64): Declare.
	(mappings): Add 64-bit version of array.
	(init_windows_x86): New function.
	(the_low_target): Change init_arch field to init_windows_x86.
@
text
@d31 2
a32 2
#ifdef __x86_64
/* Defined in auto-generated file reg-i386.c.  */
d226 1
a226 1
#ifndef __x86_64
d283 1
a283 1
#else /* __x86_64 */
d350 1
a350 1
#endif /* __x86_64 */
d389 1
a389 1
#ifdef __x86_64
@


1.18
log
@	* regcache.h (struct thread_info): Forward declare.
	(struct regcache): New.
	(new_register_cache): Adjust prototype.
	(get_thread_regcache): Declare.
	(free_register_cache): Adjust prototype.
	(registers_to_string, registers_from_string): Ditto.
	(supply_register, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Ditto.
	* regcache.c (struct inferior_regcache_data): Delete.
	(get_regcache): Rename to ...
	(get_thread_regcache): ... this.  Adjust.  Switch inferior before
	fetching registers.
	(regcache_invalidate_one): Adjust.
	(regcache_invalidate): Fix prototype.
	(new_register_cache): Return the new register cache.
	(free_register_cache): Change prototype.
	(realloc_register_cache): Adjust.
	(registers_to_string): Change prototype to take a regcache.  Adjust.
	(registers_from_string): Ditto.
	(register_data): Ditto.
	(supply_register): Ditto.
	(supply_register_by_name): Ditto.
	(collect_register): Ditto.
	(collect_register_as_string): Ditto.
	(collect_register_by_name): Ditto.
	* server.c (process_serial_event): Adjust.
	* linux-low.h (regset_fill_func, regset_store_func): Change
	prototype.
	(get_pc, set_pc, collect_ptrace_register, supply_ptrace_register):
	Change prototype.
	* linux-low.c (get_stop_pc): Adjust.
	(check_removed_breakpoint): Adjust.
	(linux_wait_for_event): Adjust.
	(linux_resume_one_lwp): Adjust.
	(fetch_register): Add regcache parameter.  Adjust.
	(usr_store_inferior_registers): Ditto.
	(regsets_fetch_inferior_registers): Ditto.
	(regsets_store_inferior_registers): Ditto.
	(linux_fetch_registers, linux_store_registers): Ditto.
	* i387-fp.c (i387_cache_to_fsave): Change prototype to take a
	regcache.  Adjust.
	(i387_fsave_to_cache, i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* i387-fp.h (i387_cache_to_fsave, i387_fsave_to_cache): Change
	prototype to take a regcache.
	(i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* remote-utils.c (convert_ascii_to_int, outreg)
	(prepare_resume_reply): Change prototype to take a regcache.
	Adjust.
	* target.h (struct target_ops) <fetch_registers, store_registers>:
	Change prototype to take a regcache.
	(fetch_inferior_registers, store_inferior_registers): Change
	prototype to take a regcache.  Adjust.
	* proc-service.c (ps_lgetregs): Adjust.
	* linux-x86-low.c (x86_fill_gregset, x86_store_gregset)
	(x86_fill_fpregset, x86_store_fpregset, x86_fill_fpxregset)
	(x86_store_fpxregset, x86_get_pc, x86_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-arm-low.c (arm_fill_gregset, arm_store_gregset)
	(arm_fill_wmmxregset, arm_store_wmmxregset, arm_fill_vfpregset)
	(arm_store_vfpregset, arm_get_pc, arm_set_pc):
	(arm_breakpoint_at): Change prototype to take a regcache.  Adjust.
	* linux-cris-low.c (cris_get_pc, cris_set_pc)
	(cris_cannot_fetch_register):
	(cris_breakpoint_at): Change prototype to take a regcache.
	Adjust.
	* linux-crisv32-low.c (cris_get_pc, cris_set_pc,
	cris_reinsert_addr, cris_write_data_breakpoint): Change prototype
	to take a regcache.  Adjust.
	(cris_breakpoint_at, cris_insert_point, cris_remove_point):
	Adjust.
	* linux-m32r-low.c (m32r_get_pc, m32r_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-m68k-low.c (m68k_fill_gregset, m68k_store_gregset)
	(m68k_fill_fpregset, m68k_store_fpregset, m68k_get_pc,
	(m68k_set_pc): Change prototype to take a regcache.  Adjust.
	* linux-mips-low.c (mips_get_pc):
	(mips_set_pc): Change prototype to take a regcache.  Adjust.
	(mips_reinsert_addr): Adjust.
	(mips_collect_register): Change prototype to take a regcache.
	Adjust.
	(mips_supply_register):
	(mips_collect_register_32bit, mips_supply_register_32bit)
	(mips_fill_gregset, mips_store_gregset, mips_fill_fpregset)
	(mips_store_fpregset): Ditto.
	* linux-ppc-low.c (ppc_supply_ptrace_register, ppc_supply_ptrace_register):
	Ditto.
	(parse_spufs_run): Adjust.
	(ppc_get_pc, ppc_set_pc, ppc_fill_gregset, ppc_fill_vsxregset)
	(ppc_store_vsxregset, ppc_fill_vrregset, ppc_store_vrregset)
	(ppc_fill_evrregset, ppc_store_evrregset): Change prototype to
	take a regcache.  Adjust.
	* linux-s390-low.c (s390_collect_ptrace_register)
	(s390_supply_ptrace_register, s390_fill_gregset, s390_get_pc)
	(s390_set_pc): Change prototype to take a regcache.  Adjust.
	(s390_arch_setup): Adjust.
	* linux-sh-low.c (sh_get_pc, sh_breakpoint_at)
	(sh_fill_gregset): Change prototype to take a regcache.  Adjust.
	* linux-sparc-low.c (sparc_fill_gregset_to_stack)
	(sparc_fill_gregset, sparc_store_gregset_from_stack)
	(sparc_store_gregset, sparc_get_pc): Change prototype to take a
	regcache.  Adjust.
	(sparc_breakpoint_at): Adjust.
	* linux-xtensa-low.c (xtensa_fill_gregset):
	(xtensa_store_gregset):
	(xtensa_fill_xtregset, xtensa_store_xtregset, xtensa_get_pc)
	(xtensa_set_pc): Change prototype to take a regcache.  Adjust.
	* nto-low.c (nto_fetch_registers, nto_store_registers): Change
	prototype to take a regcache.  Adjust.
	* win32-arm-low.c (arm_fetch_inferior_register)
	(arm_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-i386-low.c (i386_fetch_inferior_register)
	(i386_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-low.c (child_fetch_inferior_registers)
	(child_store_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_wait): Adjust.
	(win32_fetch_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_store_inferior_registers): Adjust.
	* win32-low.h (struct win32_target_ops) <fetch_inferior_register,
	store_inferior_register>: Change prototype to take a regcache.
@
text
@d22 4
d31 4
d37 1
d226 2
d283 69
d386 10
d397 1
a397 1
  init_registers_i386,
@


1.17
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d274 2
a275 1
i386_fetch_inferior_register (win32_thread_info *th, int r)
d283 1
a283 1
      supply_register (r, (char *) &l);
d288 1
a288 1
      supply_register (r, (char *) &l);
d291 1
a291 1
    supply_register (r, context_offset);
d296 2
a297 1
i386_store_inferior_register (win32_thread_info *th, int r)
d300 1
a300 1
  collect_register (r, context_offset);
@


1.16
log
@	* win32-i386-low.c (i386_get_thread_context): Handle systems that
	don't support CONTEXT_EXTENDED_REGISTERS.
	(i386_win32_breakpoint, i386_win32_breakpoint_len): New.
	(the_low_target): Install them.
	* win32-low.c (get_child_debug_event): Handle WaitForDebugEvent
	failing with ERROR_PIPE_NOT_CONNECTED.
@
text
@d1 1
a1 1
/* Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.15
log
@	Add h/w watchpoint support to x86-linux, win32-i386.
	* Makefile.in (SFILES): Add i386-low.c
	(i386_low_h): Define.
	(i386-low.o): Add dependencies.
	(linux-x86-low.o): Add i386-low.h dependency.
	(win32-i386-low.o): Ditto.
	* i386-low.c: New file.
	* i386-low.h: New file.
	* configure.srv (i[34567]86-*-cygwin*): Add i386-low.o to srv_tgtobj.
	(i[34567]86-*-linux*, i[34567]86-*-mingw*, x86_64-*-linux*): Ditto.
	* linux-low.c (linux_add_process): Initialize arch_private.
	(linux_remove_process): Free arch_private.
	(add_lwp): Initialize arch_private.
	(delete_lwp): Free arch_private.
	(linux_resume_one_lwp): Call the_low_target.prepare_to_resume if
	provided.
	* linux-low.h (process_info_private): New member arch_private.
	(lwp_info): New member arch_private.
	(linux_target_ops): New members new_process, new_thread,
	prepare_to_resume.
	(ptid_of): New macro.
	* linux-x86-low.c: Include stddef.h, i386-low.h.
	(arch_process_info): New struct.
	(arch_lwp_info): New struct.
	(x86_linux_dr_get, x86_linux_dr_set): New functions.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(x86_insert_point, x86_remove_point): New functions.
	(x86_stopped_by_watchpoint): New function.
	(x86_stopped_data_address): New function.
	(x86_linux_new_process, x86_linux_new_thread): New functions.
	(x86_linux_prepare_to_resume): New function.
	(the_low_target): Add entries for insert_point, remove_point,
	stopped_by_watchpoint, stopped_data_address, new_process, new_thread,
	prepare_to_resume.
	* server.c (debug_hw_points): New global.
	(monitor_show_help): Document set debug-hw-points.
	(handle_query): Process "set debug-hw-points".
	* server.h (debug_hw_points): Declare.
	(paddress): Declare.
	* utils.c (NUMCELLS, CELLSIZE): New macros.
	(get_sell, xsnprintf, paddress): New functions.
	* win32-arm-low.c (the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-i386-low.c: Include i386-low.h.
	(debug_reg_state): Replaces dr.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(i386_insert_point, i386_remove_point): New functions.
	(i386_stopped_by_watchpoint): New function.
	(i386_stopped_data_address): New function.
	(i386_initial_stuff): Update.
	(get_thread_context,set_thread_context,i386_thread_added): Update.
	(the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-low.c (win32_insert_watchpoint): New function.
	(win32_remove_watchpoint): New function.
	(win32_stopped_by_watchpoint): New function.
	(win32_stopped_data_address): New function.
	(win32_target_ops): Add entries for insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address.
	* win32-low.h (win32_target_ops): New members insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
@
text
@d132 9
a140 5
  th->context.ContextFlags = \
    CONTEXT_FULL | \
    CONTEXT_FLOATING_POINT | \
    CONTEXT_EXTENDED_REGISTERS | \
    CONTEXT_DEBUG_REGISTERS;
d142 12
a153 1
  GetThreadContext (th->h, &th->context);
d301 3
d314 2
a315 2
  NULL, /* breakpoint */
  0, /* breakpoint_len */
@


1.14
log
@        Updated copyright notices for most files.
@
text
@d20 1
d30 1
a30 1
static unsigned dr[8];
d35 86
d124 1
a124 1
  memset (&dr, 0, sizeof (dr));
d145 7
a151 6
      dr[0] = th->context.Dr0;
      dr[1] = th->context.Dr1;
      dr[2] = th->context.Dr2;
      dr[3] = th->context.Dr3;
      dr[6] = th->context.Dr6;
      dr[7] = th->context.Dr7;
d160 6
a165 5
      th->context.Dr0 = dr[0];
      th->context.Dr1 = dr[1];
      th->context.Dr2 = dr[2];
      th->context.Dr3 = dr[3];
      /* th->context.Dr6 = dr[6];
d167 1
a167 1
      th->context.Dr7 = dr[7];
d179 1
d183 5
a187 5
      th->context.Dr0 = dr[0];
      th->context.Dr1 = dr[1];
      th->context.Dr2 = dr[2];
      th->context.Dr3 = dr[3];
      /* th->context.Dr6 = dr[6];
d189 1
a189 1
      th->context.Dr7 = dr[7];
d298 4
@


1.13
log
@ChangeLog:

	* features/Makefile (%.dat): Emit xmltarget statement.

	* regformats/regdat.sh: Support xmltarget and xmlarch statments.
	Generate code to set gdbserver_xmltarget in init_registers_${name}.

	* regformats/arm-with-iwmmxt.dat: Regenerate.
	* regformats/mips64-linux.dat: Regenerate.
	* regformats/mips-linux.dat: Regenerate.
	* regformats/rs6000/powerpc-32.dat: Regenerate.
	* regformats/rs6000/powerpc-64.dat: Regenerate.
	* regformats/rs6000/powerpc-e500.dat: Regenerate.

	* regformats/reg-arm.dat: Add xmlarch statement.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-i386-linux.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-spu.dat: Likewise.

gdbserver/ChangeLog:

	* regcache.h (gdbserver_xmltarget): Add extern declaration.
	* server.c (gdbserver_xmltarget): Define.
	(get_features_xml): Use it to replace "target.xml" and arch_string.

	* configure.srv: Remove srv_xmltarget.  Add XML files that were
	mentioned there to srv_xmlfiles instead.  Remove conditional tests
	on gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe; set
	srv_xmlfiles and srv_regobj to include all possible choices.
	* configure.ac (srv_xmltarget): Remove.
	(srv_xmlfiles): Do not add "target.xml".
	(gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe): Remove
	checks for supplementary target information.
	* configure: Regenerate.
	* Makefile.in (XML_TARGET): Remove.
	(target.xml): Remove rule.
	(clean): Do not clean up target.xml.
	(.PRECIOUS): Do not mention target.xml.

	* target.h (struct target_ops): Remove arch_string member.
	* linux-low.c (linux_arch_string): Remove.
	(linux_target_ops): Remove arch_string initializer.
	* linux-low.h (struct linux_target_ops): Remove arch_string member.
	* linux-i386-low.c (the_low_target): Remove arch_string initializer.
	* linux-x86-64-low.c (the_low_target): Remove arch_string initializer.
	* spu-low.c (spu_arch_string): Remove.
	(spu_target_ops): Remove arch_string initializer.
	* win32-low.c (win32_arch_string): Remove.
	(win32_target_ops): Remove arch_string initializer.
	* win32-low.h (struct win32_target_ops): Remove arch_string member.
	* win32-arm-low.c (the_low_target): Remove arch_string initializer.
	* win32-i368-low.c (the_low_target): Remove arch_string initializer.
@
text
@d1 1
a1 1
/* Copyright (C) 2007, 2008 Free Software Foundation, Inc.
@


1.12
log
@gdb/ChangeLog:

	* regformats/regdat.sh: Rename init_registers function in
	generated file to init_registers_${name}.

	* regformats/reg-crisv32.dat: Set "name" to crisv32.
	* regformats/reg-ppc64.dat: Set "name" to ppc64.
	* regformats/reg-s390x.dat: Set "name" to s390x.

gdbserver/ChangeLog:

	* server.h (init_registers): Remove prototype.

	* linux-low.h (struct linux_target_ops): Add arch_setup field.
	* linux-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* linux-arm-low.c (init_registers_arm): Add prototype.
	(init_registers_arm_with_iwmmxt): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-cris-low.c (init_registers_cris): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-crisv32-low.c (init_registers_crisv32): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-i386-low.c (init_registers_i386_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ia64-low.c (init_registers_ia64): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m32r-low.c (init_registers_m32r): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m68k-low.c (init_registers_m68k): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-mips-low.c (init_registers_mips_linux): Add prototype.
	(init_registers_mips64_linux): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc-low.c (init_registers_ppc): Add prototype.
	(init_registers_powerpc_32, init_registers_powerpc_e500): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc64-low.c (init_registers_ppc64): Add prototype.
	(init_registers_powerpc_64): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-s390-low.c (init_registers_s390): Add prototype.
	(init_registers_s390x): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-sh-low.c (init_registers_sh): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-x86-64-low.c (init_registers_x86_64_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-xtensa-low.c (init_registers_xtensa): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* win32-low.h (struct win32_target_ops): Add arch_setup field.
	* win32-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* win32-arm-low.c (init_registers_arm): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* win32-i386-low.c (init_registers_i386): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* spu-low.c (init_registers_spu): Add prototype.
	(initialize_low): Call initialie_registers_spu () instead of
	initialize_registers ().
@
text
@a207 1
  "i386" /* arch_string */
@


1.11
log
@	Updated copyright notices for most files.
@
text
@d26 3
d197 1
@


1.10
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1 1
a1 1
/* Copyright (C) 2007 Free Software Foundation, Inc.
@


1.9
log
@	* win32-low.c (debug_registers_changed,
	debug_registers_used, CONTEXT_EXTENDED_REGISTERS,
	CONTEXT_FLOATING_POINT, CONTEXT_DEBUG_REGISTERS,
	CONTEXT_DEBUGGER, CONTEXT_DEBUGGER_DR): Delete.
	(thread_rec): Get context using the low target.
	(child_add_thread): Call thread_added on the low target,
	which does the same thing.
	(regptr): Delete.
	(do_initial_child_stuff): Remove debug registers references.
	Set context using the low target.  Resume threads after
	setting the contexts.
	(child_continue): Remove dead variable.  Remove debug
	registers references.
	(child_fetch_inferior_registers): Go through the low target.
	(do_child_store_inferior_registers): Remove.
	(child_store_inferior_registers): Go through the low target.
	(win32_resume): Remove debug registers references.
	Set context using the low target.
	(handle_exception): Change return type to void.  Don't record
	context here.  Set status to TARGET_WAITKIND_SPURIOUS on a
	first chance exception.
	(get_child_debug_event): Change return type to void.  Remove
	goto loop.  Always return after waiting for debug event.
	(win32_wait): Convert to switch statement.  Handle spurious
	events.

	* win32-i386-low.c (debug_registers_changed,
	debug_registers_used): New.
	(initial_stuff): Rename to ...
	(i386_initial_stuff): ... this.  Clear debug registers
	state variables.
	(store_debug_registers): Delete.
	(i386_get_thread_context): New.
	(load_debug_registers): Delete.
	(i386_set_thread_context): New.
	(i386_thread_added): New.
	(single_step): Rename to ...
	(i386_single_step): ... this.
	(do_fetch_inferior_registers): Rename to ...
	(i386_fetch_inferior_register): ... this.
	(i386_store_inferior_register): New.
	(the_low_target): Adapt to new interface.

	* win32-arm-low.c (CONTEXT_FLOATING_POINT): Define.
	(arm_get_thread_context): New.
	(arm_set_thread_context): New.
	(regptr): New.
	(do_fetch_inferior_registers): Rename to ...
	(arm_fetch_inferior_register): ... this.
	(arm_store_inferior_register): New.
	(arm_wince_breakpoint): Reimplement as unsigned long.
	(arm_wince_breakpoint_len): Define.
	(the_low_target): Adapt to new interface.

	* win32-low.h (target_ops): Remove regmap, store_debug_registers and
	load_debug_registers.  Add get_thread_context, set_thread_context,
	thread_added and store_inferior_register.  Rename
	fetch_inferior_registers to fetch_inferior_register.
	(regptr): Remove declaration.
@
text
@d7 1
a7 1
   the Free Software Foundation; either version 2 of the License, or
d16 1
a16 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.8
log
@gdb/

	* arm-wince-tdep.c: New.
	* config/arm/wince.mt (DEPRECATED_TM_FILE): Use tm-arm.h.
	(MT_CFLAGS): Delete.
	(TM_CLIBS): Delete.
	(TDEPFILES): Add arm-wince-tdep.o, corelow.o, solib.o,
	solib-legacy.o, solib-svr4.o, and remove wince.o.
	* configure.tgt (arm*-*-mingw32ce*): Add.
	* signals/signals.c [HAVE_SIGNAL_H]: Check.
	(do_target_signal_to_host): Silence 'not used' warning.
	* config/arm/tm-wince.h: Remove.

gdb/gdbserver/

	* gdbserver/configure.ac: Add errno checking.
	(AC_CHECK_HEADERS): Add errno.h, fcntl.h, signal.h,
	sys/file.h and malloc.h.
	(AC_CHECK_DECLS): Add perror.
	(srv_mingwce): Handle.
	* gdbserver/configure.srv (i[34567]86-*-cygwin*): Add
	win32-i386-low.o to srv_tgtobj.
	(i[34567]86-*-mingw*): Likewise.
	(arm*-*-mingw32ce*): Add case.
	* gdbreplay.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_ERRNO_H, HAVE_MALLOC_H]: Check.
	[__MINGW32CE__] (strerror): New function.
	[__MINGW32CE__] (errno): Define to GetLastError.
	[__MINGW32CE__] (COUNTOF): New macro.
	(remote_open): Remove extra close call.
	* mem-break.c (delete_breakpoint_at): New function.
	* mem-break.h (delete_breakpoint_at): Declare.
	* remote-utils.c [HAVE_SYS_FILE_H, HAVE_SIGNAL_H,
	HAVE_FCNTL_H, HAVE_UNISTD_H, HAVE_ERRNO_H]: Check.
	[USE_WIN32API] (read, write): Add char* casts.
	* server.c [HAVE_UNISTD_H, HAVE_SIGNAL_H]: Check.
	* server.h: Include wincecompat.h on Windows CE.
	[HAVE_ERRNO_H]: Check.
	(perror): Declare if not declared.
	* utils.c: Add stdlib.h, errno.h and malloc.h includes.
	(perror_with_name): Remove errno declaration.
	* wincecompat.h: New.
	* wincecompat.c: New.
	* win32-low.h: New.
	* win32-arm-low.c: New.
	* win32-i386-low.c: New.
	(win32-low.c): Include mem-break.h and win32-low.h, and winnt.h.
	(OUTMSG2): Make it safe.
	(_T): New macro.
	(COUNTOF): New macro.
	(NUM_REGS): Get it from the low target.
	(CONTEXT_EXTENDED_REGISTERS, CONTEXT_FLOATING_POINT,
	CONTEXT_DEBUG_REGISTERS): Add fallbacks to 0.
	(thread_rec): Let low target handle debug registers.
	(child_add_thread): Likewise.
	(child_init_thread_list): Likewise.
	(continue_one_thread): Likewise.
	(regptr): New.
	(do_child_fetch_inferior_registers): Move to ...
	* win32-i386-low.c: ... here, and rename to ...
	(do_fetch_inferior_registers): ... this.
	* win32-low.c (child_fetch_inferior_registers):
	Go through the low target.
	(do_child_store_inferior_registers): Use regptr.
	(strwinerror): New function.
	(win32_create_inferior): Handle Windows CE.
	Use strwinerror instead of strerror on Windows error
	codes.  Add program to the error output.
	Don't close the main thread handle on Windows CE.
	(win32_attach): Use coredll.dll on Windows CE.
	(win32_kill): Close current process and current
	thread handles.
	(win32_detach): Use coredll.dll on Windows CE.
	(win32_resume): Let low target handle debug registers, and
	step request.
	(handle_exception): Add/Remove initial breakpoint.  Avoid
	non-existant WSTOPSIG on Windows CE.
	(win32_read_inferior_memory): Cast to remove warning.
	(win32_arch_string): Go through the low target.
	(initialize_low): Call set_breakpoint_data with the low
	target's breakpoint.
	* win32-low.c (dr, FLAG_TRACE_BIT, FCS_REGNUM,
	FOP_REGNUM, mappings): Move to ...
	* win32-i386-low.c: ... here.
	* win32-low.c (win32_thread_info): Move to ...
	* win32-low.h: ... here.
	* Makefile.in (SFILES): Add win32-low.c, win32-i386-low.c,
	win32-arm-low.c and wincecompat.c.
	(all:): Add $EXEEXT.
	(install-only:): Likewise.
	(gdbserver:): Likewise.
	(gdbreplay:): Likewise.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d30 3
d34 1
a34 1
initial_stuff (void)
d37 2
d42 1
a42 1
store_debug_registers (win32_thread_info *th)
d44 20
a63 6
  dr[0] = th->context.Dr0;
  dr[1] = th->context.Dr1;
  dr[2] = th->context.Dr2;
  dr[3] = th->context.Dr3;
  dr[6] = th->context.Dr6;
  dr[7] = th->context.Dr7;
d67 1
a67 1
load_debug_registers (win32_thread_info *th)
d69 12
a80 7
  th->context.Dr0 = dr[0];
  th->context.Dr1 = dr[1];
  th->context.Dr2 = dr[2];
  th->context.Dr3 = dr[3];
  /* th->context.Dr6 = dr[6];
     FIXME: should we set dr6 also ?? */
  th->context.Dr7 = dr[7];
a82 1
/* Fetch register(s) from gdbserver regcache data.  */
d84 1
a84 1
do_fetch_inferior_registers (win32_thread_info *th, int r)
d86 13
a98 1
  char *context_offset = regptr (&th->context, r);
d100 2
a101 5
  long l;
  if (r == FCS_REGNUM)
    {
      l = *((long *) context_offset) & 0xffff;
      supply_register (r, (char *) &l);
a102 7
  else if (r == FOP_REGNUM)
    {
      l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
      supply_register (r, (char *) &l);
    }
  else
    supply_register (r, context_offset);
d106 1
a106 1
single_step (win32_thread_info *th)
d166 29
a195 1
  mappings,
d197 8
a204 6
  initial_stuff,
  store_debug_registers,
  load_debug_registers,
  do_fetch_inferior_registers,
  single_step,
  (const char*)NULL, /* breakpoint */
@


1.7
log
@	* win32-i386-low.c: Rename to ...
	* win32-low.c: ... this.
	* configure.srv: Replace win32-i386-low.o with win32-low.o.
	* Makefile.in: Likewise.
@
text
@d1 1
a1 4
/* Low level interface to Windows debugging, for gdbserver.
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.

   Contributed by Leo Zayas.  Based on "win32-nat.c" from GDB.
d21 1
a21 2
#include "regcache.h"
#include "gdb/signals.h"
d23 2
a24 6
#include <windows.h>
#include <imagehlp.h>
#include <psapi.h>
#include <sys/param.h>
#include <malloc.h>
#include <process.h>
d26 1
a26 5
#ifndef USE_WIN32API
#include <sys/cygwin.h>
#endif

#define LOG 0
a27 19
#define OUTMSG(X) do { printf X; fflush (stdout); } while (0)
#if LOG
#define OUTMSG2(X) do { printf X; fflush (stdout); } while (0)
#else
#define OUTMSG2(X)
#endif

int using_threads = 1;

/* Globals.  */
static HANDLE current_process_handle = NULL;
static DWORD current_process_id = 0;
static enum target_signal last_sig = TARGET_SIGNAL_0;

/* The current debug event from WaitForDebugEvent.  */
static DEBUG_EVENT current_event;

static int debug_registers_changed = 0;
static int debug_registers_used = 0;
d30 2
a31 23
typedef BOOL winapi_DebugActiveProcessStop (DWORD dwProcessId);
typedef BOOL winapi_DebugSetProcessKillOnExit (BOOL KillOnExit);

#define FLAG_TRACE_BIT 0x100
#define CONTEXT_DEBUGGER (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS	\
  | CONTEXT_EXTENDED_REGISTERS

/* Thread information structure used to track extra information about
   each thread.  */
typedef struct thread_info_struct
{
  DWORD tid;
  HANDLE h;
  int suspend_count;
  CONTEXT context;
} thread_info;
static DWORD main_thread_id = 0;

/* Get the thread ID from the current selected inferior (the current
   thread).  */
static DWORD
current_inferior_tid (void)
d33 1
a33 2
  thread_info *th = inferior_target_data (current_inferior);
  return th->tid;
d36 2
a37 42
/* Find a thread record given a thread id.  If GET_CONTEXT is set then
   also retrieve the context for this thread.  */
static thread_info *
thread_rec (DWORD id, int get_context)
{
  struct thread_info *thread;
  thread_info *th;

  thread = (struct thread_info *) find_inferior_id (&all_threads, id);
  if (thread == NULL)
    return NULL;

  th = inferior_target_data (thread);
  if (!th->suspend_count && get_context)
    {
      if (get_context > 0 && id != current_event.dwThreadId)
	th->suspend_count = SuspendThread (th->h) + 1;
      else if (get_context < 0)
	th->suspend_count = -1;

      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;

      GetThreadContext (th->h, &th->context);

      if (id == current_event.dwThreadId)
	{
	  /* Copy dr values from that thread.  */
	  dr[0] = th->context.Dr0;
	  dr[1] = th->context.Dr1;
	  dr[2] = th->context.Dr2;
	  dr[3] = th->context.Dr3;
	  dr[6] = th->context.Dr6;
	  dr[7] = th->context.Dr7;
	}
    }

  return th;
}

/* Add a thread to the thread list.  */
static thread_info *
child_add_thread (DWORD tid, HANDLE h)
d39 6
a44 35
  thread_info *th;

  if ((th = thread_rec (tid, FALSE)))
    return th;

  th = (thread_info *) malloc (sizeof (*th));
  memset (th, 0, sizeof (*th));
  th->tid = tid;
  th->h = h;

  add_thread (tid, th, (unsigned int) tid);
  set_inferior_regcache_data ((struct thread_info *)
			      find_inferior_id (&all_threads, tid),
			      new_register_cache ());

  /* Set the debug registers for the new thread if they are used.  */
  if (debug_registers_used)
    {
      /* Only change the value of the debug registers.  */
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;

      GetThreadContext (th->h, &th->context);

      th->context.Dr0 = dr[0];
      th->context.Dr1 = dr[1];
      th->context.Dr2 = dr[2];
      th->context.Dr3 = dr[3];
      /* th->context.Dr6 = dr[6];
         FIXME: should we set dr6 also ?? */
      th->context.Dr7 = dr[7];
      SetThreadContext (th->h, &th->context);
      th->context.ContextFlags = 0;
    }

  return th;
a46 1
/* Delete a thread from the list of threads.  */
d48 1
a48 1
delete_thread_info (struct inferior_list_entry *thread)
d50 7
a56 5
  thread_info *th = inferior_target_data ((struct thread_info *) thread);

  remove_thread ((struct thread_info *) thread);
  CloseHandle (th->h);
  free (th);
d59 1
a59 1
/* Delete a thread from the list of threads.  */
d61 1
a61 1
child_delete_thread (DWORD id)
d63 1
a63 1
  struct inferior_list_entry *thread;
d65 2
a66 20
  /* If the last thread is exiting, just return.  */
  if (all_threads.head == all_threads.tail)
    return;

  thread = find_inferior_id (&all_threads, id);
  if (thread == NULL)
    return;

  delete_thread_info (thread);
}

/* Transfer memory from/to the debugged process.  */
static int
child_xfer_memory (CORE_ADDR memaddr, char *our, int len,
		   int write, struct target_ops *target)
{
  SIZE_T done;
  long addr = (long) memaddr;

  if (write)
d68 2
a69 3
      WriteProcessMemory (current_process_handle, (LPVOID) addr,
			  (LPCVOID) our, len, &done);
      FlushInstructionCache (current_process_handle, (LPCVOID) addr, len);
d71 1
a71 1
  else
d73 2
a74 2
      ReadProcessMemory (current_process_handle, (LPCVOID) addr, (LPVOID) our,
			 len, &done);
d76 2
a77 1
  return done;
d80 2
a81 2
/* Generally, what has the program done?  */
enum target_waitkind
d83 2
a84 41
  /* The program has exited.  The exit status is in value.integer.  */
  TARGET_WAITKIND_EXITED,

  /* The program has stopped with a signal.  Which signal is in
     value.sig.  */
  TARGET_WAITKIND_STOPPED,

  /* The program is letting us know that it dynamically loaded something
     (e.g. it called load(2) on AIX).  */
  TARGET_WAITKIND_LOADED,

  /* The program has exec'ed a new executable file.  The new file's
     pathname is pointed to by value.execd_pathname.  */

  TARGET_WAITKIND_EXECD,

  /* Nothing happened, but we stopped anyway.  This perhaps should be handled
     within target_wait, but I'm not sure target_wait should be resuming the
     inferior.  */
  TARGET_WAITKIND_SPURIOUS,
};

struct target_waitstatus
{
  enum target_waitkind kind;

  /* Forked child pid, execd pathname, exit status or signal number.  */
  union
  {
    int integer;
    enum target_signal sig;
    int related_pid;
    char *execd_pathname;
    int syscall_id;
  }
  value;
};

#define NUM_REGS 41
#define FCS_REGNUM 27
#define FOP_REGNUM 31
d86 7
a138 1

d141 11
a151 814
/* Clear out any old thread list and reintialize it to a pristine
   state. */
static void
child_init_thread_list (void)
{
  for_each_inferior (&all_threads, delete_thread_info);
}

static void
do_initial_child_stuff (DWORD pid)
{
  int i;

  last_sig = TARGET_SIGNAL_0;

  debug_registers_changed = 0;
  debug_registers_used = 0;
  for (i = 0; i < sizeof (dr) / sizeof (dr[0]); i++)
    dr[i] = 0;
  memset (&current_event, 0, sizeof (current_event));

  child_init_thread_list ();
}

/* Resume all artificially suspended threads if we are continuing
   execution.  */
static int
continue_one_thread (struct inferior_list_entry *this_thread, void *id_ptr)
{
  struct thread_info *thread = (struct thread_info *) this_thread;
  int thread_id = * (int *) id_ptr;
  thread_info *th = inferior_target_data (thread);
  int i;

  if ((thread_id == -1 || thread_id == th->tid)
      && th->suspend_count)
    {
      for (i = 0; i < th->suspend_count; i++)
	(void) ResumeThread (th->h);
      th->suspend_count = 0;
      if (debug_registers_changed)
	{
	  /* Only change the value of the debug registers.  */
	  th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
	  th->context.Dr0 = dr[0];
	  th->context.Dr1 = dr[1];
	  th->context.Dr2 = dr[2];
	  th->context.Dr3 = dr[3];
	  /* th->context.Dr6 = dr[6];
	     FIXME: should we set dr6 also ?? */
	  th->context.Dr7 = dr[7];
	  SetThreadContext (th->h, &th->context);
	  th->context.ContextFlags = 0;
	}
    }

  return 0;
}

static BOOL
child_continue (DWORD continue_status, int thread_id)
{
  BOOL res;

  res = ContinueDebugEvent (current_event.dwProcessId,
			    current_event.dwThreadId, continue_status);
  continue_status = 0;
  if (res)
    find_inferior (&all_threads, continue_one_thread, &thread_id);

  debug_registers_changed = 0;
  return res;
}

/* Fetch register(s) from gdbserver regcache data.  */
static void
do_child_fetch_inferior_registers (thread_info *th, int r)
{
  char *context_offset = ((char *) &th->context) + mappings[r];
  long l;
  if (r == FCS_REGNUM)
    {
      l = *((long *) context_offset) & 0xffff;
      supply_register (r, (char *) &l);
    }
  else if (r == FOP_REGNUM)
    {
      l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
      supply_register (r, (char *) &l);
    }
  else
    supply_register (r, context_offset);
}

/* Fetch register(s) from the current thread context.  */
static void
child_fetch_inferior_registers (int r)
{
  int regno;
  thread_info *th = thread_rec (current_inferior_tid (), TRUE);
  if (r == -1 || r == 0 || r > NUM_REGS)
    child_fetch_inferior_registers (NUM_REGS);
  else
    for (regno = 0; regno < r; regno++)
      do_child_fetch_inferior_registers (th, regno);
}

/* Get register from gdbserver regcache data.  */
static void
do_child_store_inferior_registers (thread_info *th, int r)
{
  collect_register (r, ((char *) &th->context) + mappings[r]);
}

/* Store a new register value into the current thread context.  We don't
   change the program's context until later, when we resume it.  */
static void
child_store_inferior_registers (int r)
{
  int regno;
  thread_info *th = thread_rec (current_inferior_tid (), TRUE);
  if (r == -1 || r == 0 || r > NUM_REGS)
    child_store_inferior_registers (NUM_REGS);
  else
    for (regno = 0; regno < r; regno++)
      do_child_store_inferior_registers (th, regno);
}

/* Start a new process.
   PROGRAM is a path to the program to execute.
   ARGS is a standard NULL-terminated array of arguments,
   to be passed to the inferior as ``argv''.
   Returns the new PID on success, -1 on failure.  Registers the new
   process with the process list.  */
static int
win32_create_inferior (char *program, char **program_args)
{
#ifndef USE_WIN32API
  char real_path[MAXPATHLEN];
  char *orig_path, *new_path, *path_ptr;
#endif
  char *winenv = NULL;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
  BOOL ret;
  DWORD flags;
  char *args;
  int argslen;
  int argc;

  if (!program)
    error ("No executable specified, specify executable to debug.\n");

  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);

  flags = DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS;

#ifndef USE_WIN32API
  orig_path = NULL;
  path_ptr = getenv ("PATH");
  if (path_ptr)
    {
      orig_path = alloca (strlen (path_ptr) + 1);
      new_path = alloca (cygwin_posix_to_win32_path_list_buf_size (path_ptr));
      strcpy (orig_path, path_ptr);
      cygwin_posix_to_win32_path_list (path_ptr, new_path);
      setenv ("PATH", new_path, 1);
    }
  cygwin_conv_to_win32_path (program, real_path);
  program = real_path;
#endif

  argslen = strlen (program) + 1;
  for (argc = 1; program_args[argc]; argc++)
    argslen += strlen (program_args[argc]) + 1;
  args = alloca (argslen);
  strcpy (args, program);
  for (argc = 1; program_args[argc]; argc++)
    {
      /* FIXME: Can we do better about quoting?  How does Cygwin
         handle this?  */
      strcat (args, " ");
      strcat (args, program_args[argc]);
    }
  OUTMSG2 (("Command line is %s\n", args));

  flags |= CREATE_NEW_PROCESS_GROUP;

  ret = CreateProcess (0, args,	/* command line */
		       NULL,	/* Security */
		       NULL,	/* thread */
		       TRUE,	/* inherit handles */
		       flags,	/* start flags */
		       winenv, NULL,	/* current directory */
		       &si, &pi);

#ifndef USE_WIN32API
  if (orig_path)
    setenv ("PATH", orig_path, 1);
#endif

  if (!ret)
    {
      error ("Error creating process %s, (error %d): %s\n", args,
	     (int) GetLastError (), strerror (GetLastError ()));
    }
  else
    {
      OUTMSG2 (("Process created: %s\n", (char *) args));
    }

  CloseHandle (pi.hThread);

  current_process_handle = pi.hProcess;
  current_process_id = pi.dwProcessId;

  do_initial_child_stuff (current_process_id);

  return current_process_id;
}

/* Attach to a running process.
   PID is the process ID to attach to, specified by the user
   or a higher layer.  */
static int
win32_attach (unsigned long pid)
{
  int res = 0;
  HMODULE kernel32 = LoadLibrary ("KERNEL32.DLL");
  winapi_DebugActiveProcessStop *DebugActiveProcessStop = NULL;
  winapi_DebugSetProcessKillOnExit *DebugSetProcessKillOnExit = NULL;

  DebugActiveProcessStop =
    (winapi_DebugActiveProcessStop *) GetProcAddress (kernel32,
						      "DebugActiveProcessStop");
  DebugSetProcessKillOnExit =
    (winapi_DebugSetProcessKillOnExit *) GetProcAddress (kernel32,
							 "DebugSetProcessKillOnExit");

  res = DebugActiveProcess (pid) ? 1 : 0;

  if (!res)
    error ("Attach to process failed.");

  if (DebugSetProcessKillOnExit != NULL)
    DebugSetProcessKillOnExit (FALSE);

  current_process_id = pid;
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE, pid);

  if (current_process_handle == NULL)
    {
      res = 0;
      if (DebugActiveProcessStop != NULL)
	DebugActiveProcessStop (current_process_id);
    }

  if (res)
    do_initial_child_stuff (pid);

  FreeLibrary (kernel32);

  return res;
}

/* Handle OUTPUT_DEBUG_STRING_EVENT from child process.  */
static void
handle_output_debug_string (struct target_waitstatus *ourstatus)
{
#define READ_BUFFER_LEN 1024
  CORE_ADDR addr;
  char s[READ_BUFFER_LEN + 1] = { 0 };
  DWORD nbytes = current_event.u.DebugString.nDebugStringLength;

  if (nbytes == 0)
    return;

  if (nbytes > READ_BUFFER_LEN)
    nbytes = READ_BUFFER_LEN;

  addr = (CORE_ADDR) (size_t) current_event.u.DebugString.lpDebugStringData;

  if (current_event.u.DebugString.fUnicode)
    {
      /* The event tells us how many bytes, not chars, even
         in Unicode.  */
      WCHAR buffer[(READ_BUFFER_LEN + 1) / sizeof (WCHAR)] = { 0 };
      if (read_inferior_memory (addr, (unsigned char *) buffer, nbytes) != 0)
	return;
      wcstombs (s, buffer, (nbytes + 1) / sizeof (WCHAR));
    }
  else
    {
      if (read_inferior_memory (addr, (unsigned char *) s, nbytes) != 0)
	return;
    }

  if (strncmp (s, "cYg", 3) != 0)
    monitor_output (s);
#undef READ_BUFFER_LEN
}

/* Kill all inferiors.  */
static void
win32_kill (void)
{
  if (current_process_handle == NULL)
    return;

  TerminateProcess (current_process_handle, 0);
  for (;;)
    {
      if (!child_continue (DBG_CONTINUE, -1))
	break;
      if (!WaitForDebugEvent (&current_event, INFINITE))
	break;
      if (current_event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
	break;
      else if (current_event.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
	{
  	  struct target_waitstatus our_status = { 0 };
	  handle_output_debug_string (&our_status);
  	}
    }
}

/* Detach from all inferiors.  */
static void
win32_detach (void)
{
  HMODULE kernel32 = LoadLibrary ("KERNEL32.DLL");
  winapi_DebugActiveProcessStop *DebugActiveProcessStop = NULL;
  winapi_DebugSetProcessKillOnExit *DebugSetProcessKillOnExit = NULL;

  DebugActiveProcessStop =
    (winapi_DebugActiveProcessStop *) GetProcAddress (kernel32,
						      "DebugActiveProcessStop");
  DebugSetProcessKillOnExit =
    (winapi_DebugSetProcessKillOnExit *) GetProcAddress (kernel32,
							 "DebugSetProcessKillOnExit");

  if (DebugSetProcessKillOnExit != NULL)
    DebugSetProcessKillOnExit (FALSE);

  if (DebugActiveProcessStop != NULL)
    DebugActiveProcessStop (current_process_id);
  else
    win32_kill ();

  FreeLibrary (kernel32);
}

/* Return 1 iff the thread with thread ID TID is alive.  */
static int
win32_thread_alive (unsigned long tid)
{
  int res;

  /* Our thread list is reliable; don't bother to poll target
     threads.  */
  if (find_inferior_id (&all_threads, tid) != NULL)
    res = 1;
  else
    res = 0;
  return res;
}

/* Resume the inferior process.  RESUME_INFO describes how we want
   to resume.  */
static void
win32_resume (struct thread_resume *resume_info)
{
  DWORD tid;
  enum target_signal sig;
  int step;
  thread_info *th;
  DWORD continue_status = DBG_CONTINUE;

  /* This handles the very limited set of resume packets that GDB can
     currently produce.  */

  if (resume_info[0].thread == -1)
    tid = -1;
  else if (resume_info[1].thread == -1 && !resume_info[1].leave_stopped)
    tid = -1;
  else
    /* Yes, we're ignoring resume_info[0].thread.  It'd be tricky to make
       the Windows resume code do the right thing for thread switching.  */
    tid = current_event.dwThreadId;

  if (resume_info[0].thread != -1)
    {
      sig = resume_info[0].sig;
      step = resume_info[0].step;
    }
  else
    {
      sig = 0;
      step = 0;
    }

  if (sig != TARGET_SIGNAL_0)
    {
      if (current_event.dwDebugEventCode != EXCEPTION_DEBUG_EVENT)
	{
	  OUTMSG (("Cannot continue with signal %d here.\n", sig));
	}
      else if (sig == last_sig)
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
      else
	OUTMSG (("Can only continue with recieved signal %d.\n", last_sig));
    }

  last_sig = TARGET_SIGNAL_0;

  /* Get context for the currently selected thread.  */
  th = thread_rec (current_event.dwThreadId, FALSE);
  if (th)
    {
      if (th->context.ContextFlags)
	{
	  if (debug_registers_changed)
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	         FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }

	  /* Move register values from the inferior into the thread
	     context structure.  */
	  regcache_invalidate ();

	  if (step)
	    th->context.EFlags |= FLAG_TRACE_BIT;

	  SetThreadContext (th->h, &th->context);
	  th->context.ContextFlags = 0;
	}
    }

  /* Allow continuing with the same signal that interrupted us.
     Otherwise complain.  */

  child_continue (continue_status, tid);
}

static int
handle_exception (struct target_waitstatus *ourstatus)
{
  thread_info *th;
  DWORD code = current_event.u.Exception.ExceptionRecord.ExceptionCode;

  ourstatus->kind = TARGET_WAITKIND_STOPPED;

  /* Record the context of the current thread.  */
  th = thread_rec (current_event.dwThreadId, -1);

  switch (code)
    {
    case EXCEPTION_ACCESS_VIOLATION:
      OUTMSG2 (("EXCEPTION_ACCESS_VIOLATION"));
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case STATUS_STACK_OVERFLOW:
      OUTMSG2 (("STATUS_STACK_OVERFLOW"));
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
      break;
    case STATUS_FLOAT_DENORMAL_OPERAND:
      OUTMSG2 (("STATUS_FLOAT_DENORMAL_OPERAND"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
      OUTMSG2 (("EXCEPTION_ARRAY_BOUNDS_EXCEEDED"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      OUTMSG2 (("STATUS_FLOAT_INEXACT_RESULT"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      OUTMSG2 (("STATUS_FLOAT_INVALID_OPERATION"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_OVERFLOW:
      OUTMSG2 (("STATUS_FLOAT_OVERFLOW"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_STACK_CHECK:
      OUTMSG2 (("STATUS_FLOAT_STACK_CHECK"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_UNDERFLOW:
      OUTMSG2 (("STATUS_FLOAT_UNDERFLOW"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      OUTMSG2 (("STATUS_FLOAT_DIVIDE_BY_ZERO"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      OUTMSG2 (("STATUS_INTEGER_DIVIDE_BY_ZERO"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_OVERFLOW:
      OUTMSG2 (("STATUS_INTEGER_OVERFLOW"));
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
      break;
    case EXCEPTION_BREAKPOINT:
      OUTMSG2 (("EXCEPTION_BREAKPOINT"));
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case DBG_CONTROL_C:
      OUTMSG2 (("DBG_CONTROL_C"));
      ourstatus->value.sig = TARGET_SIGNAL_INT;
      break;
    case DBG_CONTROL_BREAK:
      OUTMSG2 (("DBG_CONTROL_BREAK"));
      ourstatus->value.sig = TARGET_SIGNAL_INT;
      break;
    case EXCEPTION_SINGLE_STEP:
      OUTMSG2 (("EXCEPTION_SINGLE_STEP"));
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
      break;
    case EXCEPTION_ILLEGAL_INSTRUCTION:
      OUTMSG2 (("EXCEPTION_ILLEGAL_INSTRUCTION"));
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
      break;
    case EXCEPTION_PRIV_INSTRUCTION:
      OUTMSG2 (("EXCEPTION_PRIV_INSTRUCTION"));
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
      break;
    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
      OUTMSG2 (("EXCEPTION_NONCONTINUABLE_EXCEPTION"));
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
      break;
    default:
      if (current_event.u.Exception.dwFirstChance)
	return 0;
      OUTMSG2 (("gdbserver: unknown target exception 0x%08lx at 0x%08lx",
		current_event.u.Exception.ExceptionRecord.ExceptionCode,
		(DWORD) current_event.u.Exception.ExceptionRecord.
		ExceptionAddress));
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
      break;
    }
  OUTMSG2 (("\n"));
  last_sig = ourstatus->value.sig;
  return 1;
}

/* Get the next event from the child.  Return 1 if the event requires
   handling.  */
static int
get_child_debug_event (struct target_waitstatus *ourstatus)
{
  BOOL debug_event;
  DWORD continue_status, event_code;
  thread_info *th = NULL;
  static thread_info dummy_thread_info;
  int retval = 0;

in:

  last_sig = TARGET_SIGNAL_0;
  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;

  if (!(debug_event = WaitForDebugEvent (&current_event, 1000)))
    goto out;

  current_inferior =
    (struct thread_info *) find_inferior_id (&all_threads,
					     current_event.dwThreadId);

  continue_status = DBG_CONTINUE;
  event_code = current_event.dwDebugEventCode;

  switch (event_code)
    {
    case CREATE_THREAD_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event CREATE_THREAD_DEBUG_EVENT "
		"for pid=%d tid=%x)\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));

      /* Record the existence of this thread.  */
      th = child_add_thread (current_event.dwThreadId,
			     current_event.u.CreateThread.hThread);

      retval = current_event.dwThreadId;
      break;

    case EXIT_THREAD_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event EXIT_THREAD_DEBUG_EVENT "
		"for pid=%d tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      child_delete_thread (current_event.dwThreadId);
      th = &dummy_thread_info;
      break;

    case CREATE_PROCESS_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event CREATE_PROCESS_DEBUG_EVENT "
		"for pid=%d tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      CloseHandle (current_event.u.CreateProcessInfo.hFile);

      current_process_handle = current_event.u.CreateProcessInfo.hProcess;
      main_thread_id = current_event.dwThreadId;

      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname = "Main executable";

      /* Add the main thread.  */
      th =
	child_add_thread (main_thread_id,
			  current_event.u.CreateProcessInfo.hThread);

      retval = ourstatus->value.related_pid = current_event.dwThreadId;
      break;

    case EXIT_PROCESS_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event EXIT_PROCESS_DEBUG_EVENT "
		"for pid=%d tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
      CloseHandle (current_process_handle);
      current_process_handle = NULL;
      retval = main_thread_id;
      break;

    case LOAD_DLL_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event LOAD_DLL_DEBUG_EVENT "
		"for pid=%d tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      CloseHandle (current_event.u.LoadDll.hFile);

      ourstatus->kind = TARGET_WAITKIND_LOADED;
      ourstatus->value.integer = 0;
      retval = main_thread_id;
      break;

    case UNLOAD_DLL_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event UNLOAD_DLL_DEBUG_EVENT "
		"for pid=%d tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      break;

    case EXCEPTION_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event EXCEPTION_DEBUG_EVENT "
		"for pid=%d tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      retval = handle_exception (ourstatus);
      break;

    case OUTPUT_DEBUG_STRING_EVENT:
      /* A message from the kernel (or Cygwin).  */
      OUTMSG2 (("gdbserver: kernel event OUTPUT_DEBUG_STRING_EVENT "
		"for pid=%d tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      handle_output_debug_string (ourstatus);
      break;

    default:
      OUTMSG2 (("gdbserver: kernel event unknown "
		"for pid=%d tid=%x code=%ld\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId,
		current_event.dwDebugEventCode));
      break;
    }

  current_inferior =
    (struct thread_info *) find_inferior_id (&all_threads,
					     current_event.dwThreadId);

  if (!retval || (event_code != EXCEPTION_DEBUG_EVENT && event_code != EXIT_PROCESS_DEBUG_EVENT))
    {
      child_continue (continue_status, -1);
      goto in;
    }

  if (th == NULL)
    thread_rec (current_event.dwThreadId, TRUE);

out:
  return retval;
}

/* Wait for the inferior process to change state.
   STATUS will be filled in with a response code to send to GDB.
   Returns the signal which caused the process to stop. */
static unsigned char
win32_wait (char *status)
{
  struct target_waitstatus our_status;

  *status = 'T';

  while (1)
    {
      get_child_debug_event (&our_status);

      if (our_status.kind == TARGET_WAITKIND_EXITED)
	{
	  OUTMSG2 (("Child exited with retcode = %x\n",
		    our_status.value.integer));

	  *status = 'W';

	  child_fetch_inferior_registers (-1);

	  return our_status.value.integer;
	}
      else if (our_status.kind == TARGET_WAITKIND_STOPPED)
	{
	  OUTMSG2 (("Child Stopped with signal = %x \n",
		    WSTOPSIG (our_status.value.sig)));

	  *status = 'T';

	  child_fetch_inferior_registers (-1);

	  return our_status.value.sig;
	}
      else
	OUTMSG (("Ignoring unknown internal event, %d\n", our_status.kind));

      {
	struct thread_resume resume;
	resume.thread = -1;
	resume.step = 0;
	resume.sig = 0;
	resume.leave_stopped = 0;
	win32_resume (&resume);
      }
    }
}

/* Fetch registers from the inferior process.
   If REGNO is -1, fetch all registers; otherwise, fetch at least REGNO.  */
static void
win32_fetch_inferior_registers (int regno)
{
  child_fetch_inferior_registers (regno);
}

/* Store registers to the inferior process.
   If REGNO is -1, store all registers; otherwise, store at least REGNO.  */
static void
win32_store_inferior_registers (int regno)
{
  child_store_inferior_registers (regno);
}

/* Read memory from the inferior process.  This should generally be
   called through read_inferior_memory, which handles breakpoint shadowing.
   Read LEN bytes at MEMADDR into a buffer at MYADDR.  */
static int
win32_read_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  return child_xfer_memory (memaddr, myaddr, len, 0, 0) != len;
}

/* Write memory to the inferior process.  This should generally be
   called through write_inferior_memory, which handles breakpoint shadowing.
   Write LEN bytes from the buffer at MYADDR to MEMADDR.
   Returns 0 on success and errno on failure.  */
static int
win32_write_inferior_memory (CORE_ADDR memaddr, const unsigned char *myaddr,
			     int len)
{
  return child_xfer_memory (memaddr, (char *) myaddr, len, 1, 0) != len;
}

static const char *
win32_arch_string (void)
{
  return "i386";
}

static struct target_ops win32_target_ops = {
  win32_create_inferior,
  win32_attach,
  win32_kill,
  win32_detach,
  win32_thread_alive,
  win32_resume,
  win32_wait,
  win32_fetch_inferior_registers,
  win32_store_inferior_registers,
  win32_read_inferior_memory,
  win32_write_inferior_memory,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  win32_arch_string
a152 9

/* Initialize the Win32 backend.  */
void
initialize_low (void)
{
  set_target_ops (&win32_target_ops);

  init_registers ();
}
@


1.6
log
@	* remote-utils.c (monitor_output): Constify msg parameter.
	* server.h (monitor_output): Likewise.
	* win32-i386-low.c (handle_output_debug_string): New.
	(win32_kill): Handle OUTPUT_DEBUG_STRING_EVENT events using
	handle_output_debug_string.
	(get_child_debug_event): Likewise.
@
text
@@


1.5
log
@	* gdb.texinfo (Monitor commands for gdbserver): New subsection.

	* remote-utils.c (monitor_output): New function.
	* server.c (debug_threads): Define here.
	(monitor_show_help): New function.
	(handle_query): Handle qRcmd.
	(main): Do not handle 'd' packet.
	* server.h (debug_threads, remote_debug, monitor_output): Declare.
	* linux-low.c, spu-low.c, win32-i386-low.c: Remove definitions
	of debug_threads.

	* gdb.server/server-mon.exp: New test.
@
text
@d579 37
d632 5
d984 1
@


1.4
log
@	* server.c (get_features_xml): Check if target implemented
	arch_string.
	* win32-i386-low.c (win32_arch_string): New.
	(win32_target_ops): Add win32_arch_string as arch_string member.
@
text
@a46 1
int debug_threads;
@


1.3
log
@Copyright updates for 2007.
@
text
@d1057 6
d1075 10
a1084 2
  0,
  0
@


1.2
log
@	* linux-low.c (linux_kill): Handle being called with no threads.
	* win32-i386-low.c (win32_kill): Likewise.
	(get_child_debug_event): Clear current_process_handle.
@
text
@d2 1
a2 2
   Copyright (C) 2006
   Free Software Foundation, Inc.
@


1.1
log
@gdb/
	* configure.tgt: Build gdbserver for Cygwin and mingw32.
gdb/gdbserver/
	* configure.ac: Check for more headers which are missing on
	Windows.  Automatically supply -lwsock32 and USE_WIN32API.
	* configure.srv: Add Cygwin and mingw32.
	* remote-utils.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_open): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(remote_close, putpkt_binary, input_interrupt, block_async_io)
	(unblock_async_io, enable_async_io, disable_async_io)
	(readchar, getpkt): Update for Winsock support.
	(prepare_resume_reply): Expect a protocol signal number.
	* server.c: Disable <sys/wait.h> on mingw32.
	(start_inferior): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(attach_inferior): Likewise.  Use protocol signal
	numbers.
	(main): Skip 'D' packet on mingw32.  Use protocol signal numbers
	and names.
	* win32-i386-low.c: New file.
	* Makefile.in (XM_CLIBS): Set.
	(gdbserver, gdbreplay): Use $(INTERNAL_CFLAGS).
	(win32-i386-low.o): New dependency rule.
	* linux-low.c (linux_wait): Use target signal numbers.
	* target.h (struct target_ops): Doc fix.
	* server.h (target_signal_to_name): New prototype.
	* gdbreplay.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_close, remote_open): Adjust for Winsock support.
	* configure, config.in: Regenerated.
@
text
@d585 3
d907 1
@


1.1.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@@

