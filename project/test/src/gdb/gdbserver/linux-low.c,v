head	1.248;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.233.2.2
	gdb_7_6-2013-04-26-release:1.233.2.1
	gdb_7_6-branch:1.233.0.2
	gdb_7_6-2013-03-12-branchpoint:1.233
	gdb_7_5_1-2012-11-29-release:1.226
	gdb_7_5-2012-08-17-release:1.226
	gdb_7_5-branch:1.226.0.2
	gdb_7_5-2012-07-18-branchpoint:1.226
	gdb_7_4_1-2012-04-26-release:1.183.2.1
	gdb_7_4-2012-01-24-release:1.183.2.1
	gdb_7_4-branch:1.183.0.2
	gdb_7_4-2011-12-13-branchpoint:1.183
	gdb_7_3_1-2011-09-04-release:1.170
	gdb_7_3-2011-07-26-release:1.170
	gdb_7_3-branch:1.170.0.2
	gdb_7_3-2011-04-01-branchpoint:1.170
	gdb_7_2-2010-09-02-release:1.151.2.1
	gdb_7_2-branch:1.151.0.2
	gdb_7_2-2010-07-07-branchpoint:1.151
	gdb_7_1-2010-03-18-release:1.129.2.1
	gdb_7_1-branch:1.129.0.2
	gdb_7_1-2010-02-18-branchpoint:1.129
	gdb_7_0_1-2009-12-22-release:1.112
	gdb_7_0-2009-10-06-release:1.112
	gdb_7_0-branch:1.112.0.2
	gdb_7_0-2009-09-16-branchpoint:1.112
	arc-sim-20090309:1.72
	msnyder-checkpoint-072509-branch:1.109.0.2
	msnyder-checkpoint-072509-branchpoint:1.109
	arc-insight_6_8-branch:1.72.0.6
	arc-insight_6_8-branchpoint:1.72
	insight_6_8-branch:1.72.0.4
	insight_6_8-branchpoint:1.72
	reverse-20081226-branch:1.85.0.2
	reverse-20081226-branchpoint:1.85
	multiprocess-20081120-branch:1.81.0.2
	multiprocess-20081120-branchpoint:1.81
	reverse-20080930-branch:1.80.0.2
	reverse-20080930-branchpoint:1.80
	reverse-20080717-branch:1.78.0.2
	reverse-20080717-branchpoint:1.78
	msnyder-reverse-20080609-branch:1.77.0.2
	msnyder-reverse-20080609-branchpoint:1.77
	drow-reverse-20070409-branch:1.54.0.2
	drow-reverse-20070409-branchpoint:1.54
	gdb_6_8-2008-03-27-release:1.72
	gdb_6_8-branch:1.72.0.2
	gdb_6_8-2008-02-26-branchpoint:1.72
	gdb_6_7_1-2007-10-29-release:1.61
	gdb_6_7-2007-10-10-release:1.61
	gdb_6_7-branch:1.61.0.2
	gdb_6_7-2007-09-07-branchpoint:1.61
	insight_6_6-20070208-release:1.47
	gdb_6_6-2006-12-18-release:1.47
	gdb_6_6-branch:1.47.0.2
	gdb_6_6-2006-11-15-branchpoint:1.47
	insight_6_5-20061003-release:1.44
	gdb-csl-symbian-6_4_50_20060226-12:1.43.2.2.2.3
	gdb-csl-sourcerygxx-3_4_4-25:1.41
	nickrob-async-20060828-mergepoint:1.45
	gdb-csl-symbian-6_4_50_20060226-11:1.43.2.2.2.3
	gdb-csl-sourcerygxx-4_1-17:1.43.2.2
	gdb-csl-20060226-branch-local-2:1.43.2.2
	gdb-csl-sourcerygxx-4_1-14:1.43.2.2
	gdb-csl-sourcerygxx-4_1-13:1.43.2.2
	gdb-csl-sourcerygxx-4_1-12:1.43.2.2
	gdb-csl-sourcerygxx-3_4_4-21:1.43.2.2
	gdb_6_5-20060621-release:1.44
	gdb-csl-sourcerygxx-4_1-9:1.43.2.2
	gdb-csl-sourcerygxx-4_1-8:1.43.2.2
	gdb-csl-sourcerygxx-4_1-7:1.43.2.2
	gdb-csl-arm-2006q1-6:1.43.2.2
	gdb-csl-sourcerygxx-4_1-6:1.43.2.2
	gdb-csl-symbian-6_4_50_20060226-10:1.43.2.2.2.3
	gdb-csl-symbian-6_4_50_20060226-9:1.43.2.2.2.3
	gdb-csl-symbian-6_4_50_20060226-8:1.43.2.2.2.3
	gdb-csl-coldfire-4_1-11:1.43.2.2
	gdb-csl-sourcerygxx-3_4_4-19:1.43.2.2
	gdb-csl-coldfire-4_1-10:1.43.2.2
	gdb_6_5-branch:1.44.0.4
	gdb_6_5-2006-05-14-branchpoint:1.44
	gdb-csl-sourcerygxx-4_1-5:1.43.2.2
	nickrob-async-20060513-branch:1.44.0.2
	nickrob-async-20060513-branchpoint:1.44
	gdb-csl-sourcerygxx-4_1-4:1.43.2.2
	msnyder-reverse-20060502-branch:1.43.0.10
	msnyder-reverse-20060502-branchpoint:1.43
	gdb-csl-morpho-4_1-4:1.43.2.2
	gdb-csl-sourcerygxx-3_4_4-17:1.43.2.2
	readline_5_1-import-branch:1.43.0.8
	readline_5_1-import-branchpoint:1.43
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.43.2.2
	gdb-csl-symbian-20060226-branch:1.43.2.2.0.2
	gdb-csl-symbian-20060226-branchpoint:1.43.2.2
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.43.2.2
	msnyder-reverse-20060331-branch:1.43.0.6
	msnyder-reverse-20060331-branchpoint:1.43
	gdb-csl-available-20060303-branch:1.43.0.4
	gdb-csl-available-20060303-branchpoint:1.43
	gdb-csl-20060226-branch:1.43.0.2
	gdb-csl-20060226-branchpoint:1.43
	gdb_6_4-20051202-release:1.41
	msnyder-fork-checkpoint-branch:1.41.0.8
	msnyder-fork-checkpoint-branchpoint:1.41
	gdb-csl-gxxpro-6_3-branch:1.41.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.41
	gdb_6_4-branch:1.41.0.4
	gdb_6_4-2005-11-01-branchpoint:1.41
	gdb-csl-arm-20051020-branch:1.41.0.2
	gdb-csl-arm-20051020-branchpoint:1.41
	msnyder-tracepoint-checkpoint-branch:1.36.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.36
	gdb-csl-arm-20050325-2005-q1b:1.34.2.1
	gdb-csl-arm-20050325-2005-q1a:1.34.2.1
	csl-arm-20050325-branch:1.34.0.2
	csl-arm-20050325-branchpoint:1.34
	gdb-post-i18n-errorwarning-20050211:1.33
	gdb-pre-i18n-errorwarning-20050211:1.33
	gdb_6_3-20041109-release:1.33
	gdb_6_3-branch:1.33.0.2
	gdb_6_3-20041019-branchpoint:1.33
	drow_intercu-merge-20040921:1.32
	drow_intercu-merge-20040915:1.32
	jimb-gdb_6_2-e500-branch:1.32.0.8
	jimb-gdb_6_2-e500-branchpoint:1.32
	gdb_6_2-20040730-release:1.32
	gdb_6_2-branch:1.32.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.32
	gdb_6_1_1-20040616-release:1.29.2.3
	gdb_6_1-2004-04-05-release:1.29.2.3
	drow_intercu-merge-20040402:1.32
	drow_intercu-merge-20040327:1.32
	ezannoni_pie-20040323-branch:1.32.0.2
	ezannoni_pie-20040323-branchpoint:1.32
	cagney_tramp-20040321-mergepoint:1.31
	cagney_tramp-20040309-branch:1.30.0.2
	cagney_tramp-20040309-branchpoint:1.30
	gdb_6_1-branch:1.29.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.29
	drow_intercu-20040221-branch:1.27.0.4
	drow_intercu-20040221-branchpoint:1.27
	cagney_bfdfile-20040213-branch:1.27.0.2
	cagney_bfdfile-20040213-branchpoint:1.27
	drow-cplus-merge-20040208:1.27
	carlton_dictionary-20040126-merge:1.26
	cagney_bigcore-20040122-branch:1.26.0.2
	cagney_bigcore-20040122-branchpoint:1.26
	drow-cplus-merge-20040113:1.26
	drow-cplus-merge-20031224:1.26
	drow-cplus-merge-20031220:1.26
	carlton_dictionary-20031215-merge:1.26
	drow-cplus-merge-20031214:1.26
	carlton-dictionary-20031111-merge:1.26
	gdb_6_0-2003-10-04-release:1.24.2.1
	kettenis_sparc-20030918-branch:1.25.0.6
	kettenis_sparc-20030918-branchpoint:1.25
	carlton_dictionary-20030917-merge:1.25
	ezannoni_pie-20030916-branchpoint:1.25
	ezannoni_pie-20030916-branch:1.25.0.4
	cagney_x86i386-20030821-branch:1.25.0.2
	cagney_x86i386-20030821-branchpoint:1.25
	carlton_dictionary-20030805-merge:1.25
	carlton_dictionary-20030627-merge:1.24
	gdb_6_0-branch:1.24.0.2
	gdb_6_0-2003-06-23-branchpoint:1.24
	jimb-ppc64-linux-20030613-branch:1.23.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.23
	cagney_convert-20030606-branch:1.23.0.2
	cagney_convert-20030606-branchpoint:1.23
	cagney_writestrings-20030508-branch:1.21.0.16
	cagney_writestrings-20030508-branchpoint:1.21
	jimb-ppc64-linux-20030528-branch:1.21.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.21
	carlton_dictionary-20030523-merge:1.21
	cagney_fileio-20030521-branch:1.21.0.12
	cagney_fileio-20030521-branchpoint:1.21
	kettenis_i386newframe-20030517-mergepoint:1.21
	jimb-ppc64-linux-20030509-branch:1.21.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.21
	kettenis_i386newframe-20030504-mergepoint:1.21
	carlton_dictionary-20030430-merge:1.21
	kettenis_i386newframe-20030419-branch:1.21.0.8
	kettenis_i386newframe-20030419-branchpoint:1.21
	carlton_dictionary-20030416-merge:1.21
	cagney_frameaddr-20030409-mergepoint:1.21
	kettenis_i386newframe-20030406-branch:1.21.0.6
	kettenis_i386newframe-20030406-branchpoint:1.21
	cagney_frameaddr-20030403-branchpoint:1.21
	cagney_frameaddr-20030403-branch:1.21.0.4
	cagney_framebase-20030330-mergepoint:1.21
	cagney_framebase-20030326-branch:1.21.0.2
	cagney_framebase-20030326-branchpoint:1.21
	cagney_lazyid-20030317-branch:1.20.0.12
	cagney_lazyid-20030317-branchpoint:1.20
	kettenis-i386newframe-20030316-mergepoint:1.20
	offbyone-20030313-branch:1.20.0.10
	offbyone-20030313-branchpoint:1.20
	kettenis-i386newframe-20030308-branch:1.20.0.8
	kettenis-i386newframe-20030308-branchpoint:1.20
	carlton_dictionary-20030305-merge:1.20
	cagney_offbyone-20030303-branch:1.20.0.6
	cagney_offbyone-20030303-branchpoint:1.20
	carlton_dictionary-20030207-merge:1.20
	interps-20030203-mergepoint:1.20
	interps-20030202-branch:1.20.0.4
	interps-20030202-branchpoint:1.20
	cagney-unwind-20030108-branch:1.20.0.2
	cagney-unwind-20030108-branchpoint:1.20
	carlton_dictionary-20021223-merge:1.20
	gdb_5_3-2002-12-12-release:1.19.2.1
	carlton_dictionary-20021115-merge:1.19
	kseitz_interps-20021105-merge:1.19
	kseitz_interps-20021103-merge:1.19
	drow-cplus-merge-20021020:1.19
	drow-cplus-merge-20021025:1.19
	carlton_dictionary-20021025-merge:1.19
	carlton_dictionary-20021011-merge:1.19
	drow-cplus-branch:1.19.0.6
	drow-cplus-branchpoint:1.19
	kseitz_interps-20020930-merge:1.19
	carlton_dictionary-20020927-merge:1.19
	carlton_dictionary-branch:1.19.0.4
	carlton_dictionary-20020920-branchpoint:1.19
	gdb_5_3-branch:1.19.0.2
	gdb_5_3-2002-09-04-branchpoint:1.19
	kseitz_interps-20020829-merge:1.19
	cagney_sysregs-20020825-branch:1.18.0.4
	cagney_sysregs-20020825-branchpoint:1.18
	readline_4_3-import-branch:1.18.0.2
	readline_4_3-import-branchpoint:1.18
	gdb_5_2_1-2002-07-23-release:1.9.2.1
	kseitz_interps-20020528-branch:1.16.0.6
	kseitz_interps-20020528-branchpoint:1.16
	cagney_regbuf-20020515-branch:1.16.0.4
	cagney_regbuf-20020515-branchpoint:1.16
	jimb-macro-020506-branch:1.16.0.2
	jimb-macro-020506-branchpoint:1.16
	gdb_5_2-2002-04-29-release:1.9.2.1
	gdb_5_2-branch:1.9.0.2
	gdb_5_2-2002-03-03-branchpoint:1.9;
locks; strict;
comment	@ * @;


1.248
date	2013.09.05.20.45.39;	author palves;	state Exp;
branches;
next	1.247;

1.247
date	2013.09.05.20.40.33;	author palves;	state Exp;
branches;
next	1.246;

1.246
date	2013.08.28.17.40.58;	author jkratoch;	state Exp;
branches;
next	1.245;

1.245
date	2013.08.22.23.46.29;	author luisgpm;	state Exp;
branches;
next	1.244;

1.244
date	2013.08.14.02.22.19;	author luisgpm;	state Exp;
branches;
next	1.243;

1.243
date	2013.07.01.11.28.30;	author palves;	state Exp;
branches;
next	1.242;

1.242
date	2013.06.11.18.05.57;	author palves;	state Exp;
branches;
next	1.241;

1.241
date	2013.06.11.17.26.25;	author palves;	state Exp;
branches;
next	1.240;

1.240
date	2013.06.09.17.08.47;	author jkratoch;	state Exp;
branches;
next	1.239;

1.239
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.238;

1.238
date	2013.06.04.12.59.21;	author gary;	state Exp;
branches;
next	1.237;

1.237
date	2013.05.23.17.17.50;	author palves;	state Exp;
branches;
next	1.236;

1.236
date	2013.05.16.10.31.49;	author luisgpm;	state Exp;
branches;
next	1.235;

1.235
date	2013.03.22.14.52.26;	author palves;	state Exp;
branches;
next	1.234;

1.234
date	2013.03.13.18.37.54;	author brobecke;	state Exp;
branches;
next	1.233;

1.233
date	2013.03.11.08.35.11;	author mmetzger;	state Exp;
branches
	1.233.2.1;
next	1.232;

1.232
date	2013.03.07.09.47.57;	author palves;	state Exp;
branches;
next	1.231;

1.231
date	2013.02.04.17.47.00;	author mshawcroft;	state Exp;
branches;
next	1.230;

1.230
date	2013.01.16.14.46.17;	author qiyao;	state Exp;
branches;
next	1.229;

1.229
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.228;

1.228
date	2012.11.26.13.30.07;	author qiyao;	state Exp;
branches;
next	1.227;

1.227
date	2012.11.15.16.12.19;	author muller;	state Exp;
branches;
next	1.226;

1.226
date	2012.07.07.12.13.57;	author jkratoch;	state Exp;
branches;
next	1.225;

1.225
date	2012.07.02.15.29.38;	author shebs;	state Exp;
branches;
next	1.224;

1.224
date	2012.06.12.14.02.15;	author qiyao;	state Exp;
branches;
next	1.223;

1.223
date	2012.06.11.07.24.15;	author qiyao;	state Exp;
branches;
next	1.222;

1.222
date	2012.05.30.19.51.38;	author bauermann;	state Exp;
branches;
next	1.221;

1.221
date	2012.05.28.20.37.29;	author jkratoch;	state Exp;
branches;
next	1.220;

1.220
date	2012.05.24.16.51.37;	author palves;	state Exp;
branches;
next	1.219;

1.219
date	2012.05.24.16.39.13;	author palves;	state Exp;
branches;
next	1.218;

1.218
date	2012.05.22.23.17.51;	author macro;	state Exp;
branches;
next	1.217;

1.217
date	2012.05.22.13.50.50;	author mgretton;	state Exp;
branches;
next	1.216;

1.216
date	2012.05.21.23.50.25;	author macro;	state Exp;
branches;
next	1.215;

1.215
date	2012.05.11.13.34.34;	author palves;	state Exp;
branches;
next	1.214;

1.214
date	2012.04.24.15.03.43;	author bauermann;	state Exp;
branches;
next	1.213;

1.213
date	2012.04.12.15.35.32;	author hjl;	state Exp;
branches;
next	1.212;

1.212
date	2012.04.10.22.33.13;	author macro;	state Exp;
branches;
next	1.211;

1.211
date	2012.03.30.20.23.16;	author bauermann;	state Exp;
branches;
next	1.210;

1.210
date	2012.03.29.21.27.28;	author palves;	state Exp;
branches;
next	1.209;

1.209
date	2012.03.28.18.30.01;	author palves;	state Exp;
branches;
next	1.208;

1.208
date	2012.03.26.12.39.19;	author palves;	state Exp;
branches;
next	1.207;

1.207
date	2012.03.23.20.27.08;	author palves;	state Exp;
branches;
next	1.206;

1.206
date	2012.03.23.20.26.14;	author palves;	state Exp;
branches;
next	1.205;

1.205
date	2012.03.21.13.43.55;	author tschwinge;	state Exp;
branches;
next	1.204;

1.204
date	2012.03.13.15.02.23;	author jkratoch;	state Exp;
branches;
next	1.203;

1.203
date	2012.03.13.15.00.37;	author jkratoch;	state Exp;
branches;
next	1.202;

1.202
date	2012.03.07.19.25.39;	author palves;	state Exp;
branches;
next	1.201;

1.201
date	2012.03.05.17.09.37;	author jkratoch;	state Exp;
branches;
next	1.200;

1.200
date	2012.03.03.04.34.51;	author qiyao;	state Exp;
branches;
next	1.199;

1.199
date	2012.03.03.03.32.45;	author qiyao;	state Exp;
branches;
next	1.198;

1.198
date	2012.03.02.16.23.42;	author palves;	state Exp;
branches;
next	1.197;

1.197
date	2012.03.01.22.19.47;	author macro;	state Exp;
branches;
next	1.196;

1.196
date	2012.02.29.13.59.39;	author qiyao;	state Exp;
branches;
next	1.195;

1.195
date	2012.02.27.16.22.16;	author palves;	state Exp;
branches;
next	1.194;

1.194
date	2012.02.27.16.19.19;	author palves;	state Exp;
branches;
next	1.193;

1.193
date	2012.02.24.15.15.56;	author luisgpm;	state Exp;
branches;
next	1.192;

1.192
date	2012.02.02.18.06.40;	author palves;	state Exp;
branches;
next	1.191;

1.191
date	2012.01.27.19.23.43;	author palves;	state Exp;
branches;
next	1.190;

1.190
date	2012.01.25.18.25.13;	author jkratoch;	state Exp;
branches;
next	1.189;

1.189
date	2012.01.20.20.02.25;	author jkratoch;	state Exp;
branches;
next	1.188;

1.188
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.187;

1.187
date	2011.12.18.20.55.08;	author jkratoch;	state Exp;
branches;
next	1.186;

1.186
date	2011.12.18.15.49.04;	author teawater;	state Exp;
branches;
next	1.185;

1.185
date	2011.12.16.19.06.37;	author devans;	state Exp;
branches;
next	1.184;

1.184
date	2011.12.14.17.33.24;	author palves;	state Exp;
branches;
next	1.183;

1.183
date	2011.12.08.10.28.58;	author jkratoch;	state Exp;
branches
	1.183.2.1;
next	1.182;

1.182
date	2011.12.06.23.09.08;	author macro;	state Exp;
branches;
next	1.181;

1.181
date	2011.12.06.23.00.15;	author macro;	state Exp;
branches;
next	1.180;

1.180
date	2011.12.02.22.26.52;	author jkratoch;	state Exp;
branches;
next	1.179;

1.179
date	2011.11.14.20.07.24;	author shebs;	state Exp;
branches;
next	1.178;

1.178
date	2011.10.07.12.06.48;	author uweigand;	state Exp;
branches;
next	1.177;

1.177
date	2011.09.30.00.01.59;	author vapier;	state Exp;
branches;
next	1.176;

1.176
date	2011.08.24.12.17.39;	author luisgpm;	state Exp;
branches;
next	1.175;

1.175
date	2011.08.14.15.25.45;	author qiyao;	state Exp;
branches;
next	1.174;

1.174
date	2011.08.14.13.03.13;	author qiyao;	state Exp;
branches;
next	1.173;

1.173
date	2011.07.21.23.46.12;	author kcy;	state Exp;
branches;
next	1.172;

1.172
date	2011.05.04.20.20.12;	author devans;	state Exp;
branches;
next	1.171;

1.171
date	2011.04.26.15.36.04;	author qiyao;	state Exp;
branches;
next	1.170;

1.170
date	2011.02.27.21.41.26;	author msnyder;	state Exp;
branches;
next	1.169;

1.169
date	2011.02.27.21.20.06;	author msnyder;	state Exp;
branches;
next	1.168;

1.168
date	2011.01.06.00.14.09;	author msnyder;	state Exp;
branches;
next	1.167;

1.167
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.166;

1.166
date	2010.12.29.16.15.42;	author vapier;	state Exp;
branches;
next	1.165;

1.165
date	2010.11.16.03.27.05;	author vapier;	state Exp;
branches;
next	1.164;

1.164
date	2010.09.06.15.15.50;	author qiyao;	state Exp;
branches;
next	1.163;

1.163
date	2010.09.06.15.10.15;	author qiyao;	state Exp;
branches;
next	1.162;

1.162
date	2010.09.01.01.53.43;	author gdbadmin;	state Exp;
branches;
next	1.161;

1.161
date	2010.08.28.14.51.29;	author palves;	state Exp;
branches;
next	1.160;

1.160
date	2010.08.28.14.03.27;	author palves;	state Exp;
branches;
next	1.159;

1.159
date	2010.08.27.00.16.48;	author palves;	state Exp;
branches;
next	1.158;

1.158
date	2010.08.26.23.17.22;	author palves;	state Exp;
branches;
next	1.157;

1.157
date	2010.08.26.16.24.41;	author palves;	state Exp;
branches;
next	1.156;

1.156
date	2010.08.25.16.49.04;	author palves;	state Exp;
branches;
next	1.155;

1.155
date	2010.08.25.16.27.05;	author palves;	state Exp;
branches;
next	1.154;

1.154
date	2010.08.25.14.40.21;	author palves;	state Exp;
branches;
next	1.153;

1.153
date	2010.08.11.15.53.04;	author tschwinge;	state Exp;
branches;
next	1.152;

1.152
date	2010.08.09.14.59.23;	author palves;	state Exp;
branches;
next	1.151;

1.151
date	2010.06.14.22.16.09;	author palves;	state Exp;
branches
	1.151.2.1;
next	1.150;

1.150
date	2010.06.01.13.20.52;	author palves;	state Exp;
branches;
next	1.149;

1.149
date	2010.05.28.18.23.15;	author jkratoch;	state Exp;
branches;
next	1.148;

1.148
date	2010.05.03.04.02.20;	author palves;	state Exp;
branches;
next	1.147;

1.147
date	2010.05.03.03.04.30;	author palves;	state Exp;
branches;
next	1.146;

1.146
date	2010.05.02.00.47.34;	author palves;	state Exp;
branches;
next	1.145;

1.145
date	2010.05.01.15.46.26;	author palves;	state Exp;
branches;
next	1.144;

1.144
date	2010.04.30.21.36.45;	author palves;	state Exp;
branches;
next	1.143;

1.143
date	2010.04.16.07.49.36;	author muller;	state Exp;
branches;
next	1.142;

1.142
date	2010.04.12.17.39.42;	author palves;	state Exp;
branches;
next	1.141;

1.141
date	2010.04.11.16.33.55;	author palves;	state Exp;
branches;
next	1.140;

1.140
date	2010.04.09.03.40.00;	author palves;	state Exp;
branches;
next	1.139;

1.139
date	2010.04.07.18.49.46;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2010.04.03.23.14.18;	author palves;	state Exp;
branches;
next	1.137;

1.137
date	2010.04.01.15.31.26;	author palves;	state Exp;
branches;
next	1.136;

1.136
date	2010.04.01.14.25.34;	author palves;	state Exp;
branches;
next	1.135;

1.135
date	2010.03.24.21.12.45;	author palves;	state Exp;
branches;
next	1.134;

1.134
date	2010.03.24.00.05.03;	author palves;	state Exp;
branches;
next	1.133;

1.133
date	2010.03.15.00.31.16;	author palves;	state Exp;
branches;
next	1.132;

1.132
date	2010.03.14.19.34.47;	author palves;	state Exp;
branches;
next	1.131;

1.131
date	2010.03.14.18.46.40;	author palves;	state Exp;
branches;
next	1.130;

1.130
date	2010.03.06.00.11.42;	author palves;	state Exp;
branches;
next	1.129;

1.129
date	2010.02.13.01.13.54;	author devans;	state Exp;
branches
	1.129.2.1;
next	1.128;

1.128
date	2010.02.01.20.19.05;	author jkratoch;	state Exp;
branches;
next	1.127;

1.127
date	2010.01.29.15.40.22;	author drow;	state Exp;
branches;
next	1.126;

1.126
date	2010.01.21.18.35.42;	author devans;	state Exp;
branches;
next	1.125;

1.125
date	2010.01.20.22.55.38;	author palves;	state Exp;
branches;
next	1.124;

1.124
date	2010.01.20.18.29.39;	author devans;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.20.18.22.48;	author devans;	state Exp;
branches;
next	1.122;

1.122
date	2010.01.12.21.40.24;	author vprus;	state Exp;
branches;
next	1.121;

1.121
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.120;

1.120
date	2009.12.28.19.45.56;	author devans;	state Exp;
branches;
next	1.119;

1.119
date	2009.12.28.16.09.27;	author palves;	state Exp;
branches;
next	1.118;

1.118
date	2009.12.21.21.23.43;	author devans;	state Exp;
branches;
next	1.117;

1.117
date	2009.12.21.17.54.03;	author devans;	state Exp;
branches;
next	1.116;

1.116
date	2009.12.19.01.16.23;	author devans;	state Exp;
branches;
next	1.115;

1.115
date	2009.12.16.21.23.34;	author devans;	state Exp;
branches;
next	1.114;

1.114
date	2009.11.16.18.15.05;	author palves;	state Exp;
branches;
next	1.113;

1.113
date	2009.10.09.00.31.01;	author ppluzhnikov;	state Exp;
branches;
next	1.112;

1.112
date	2009.07.31.15.25.22;	author uweigand;	state Exp;
branches;
next	1.111;

1.111
date	2009.07.28.18.26.50;	author drow;	state Exp;
branches;
next	1.110;

1.110
date	2009.07.28.17.44.29;	author drow;	state Exp;
branches;
next	1.109;

1.109
date	2009.06.30.16.35.25;	author devans;	state Exp;
branches;
next	1.108;

1.108
date	2009.06.25.22.13.53;	author palves;	state Exp;
branches;
next	1.107;

1.107
date	2009.06.22.19.33.41;	author aristovski;	state Exp;
branches;
next	1.106;

1.106
date	2009.06.19.13.35.35;	author palves;	state Exp;
branches;
next	1.105;

1.105
date	2009.05.24.17.44.19;	author devans;	state Exp;
branches;
next	1.104;

1.104
date	2009.05.24.17.37.34;	author devans;	state Exp;
branches;
next	1.103;

1.103
date	2009.05.24.01.09.22;	author devans;	state Exp;
branches;
next	1.102;

1.102
date	2009.05.13.17.17.22;	author devans;	state Exp;
branches;
next	1.101;

1.101
date	2009.05.12.22.25.00;	author devans;	state Exp;
branches;
next	1.100;

1.100
date	2009.05.07.23.29.25;	author devans;	state Exp;
branches;
next	1.99;

1.99
date	2009.05.06.17.32.59;	author palves;	state Exp;
branches;
next	1.98;

1.98
date	2009.04.30.18.35.55;	author devans;	state Exp;
branches;
next	1.97;

1.97
date	2009.04.03.11.40.02;	author palves;	state Exp;
branches;
next	1.96;

1.96
date	2009.04.01.22.50.24;	author palves;	state Exp;
branches;
next	1.95;

1.95
date	2009.04.01.22.48.05;	author palves;	state Exp;
branches;
next	1.94;

1.94
date	2009.04.01.22.31.45;	author palves;	state Exp;
branches;
next	1.93;

1.93
date	2009.04.01.22.29.33;	author palves;	state Exp;
branches;
next	1.92;

1.92
date	2009.04.01.22.25.44;	author palves;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.22.23.57.10;	author palves;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.17.20.25.35;	author palves;	state Exp;
branches;
next	1.89;

1.89
date	2009.02.06.22.59.01;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.06.00.20.44;	author devans;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.05.23.11.48;	author devans;	state Exp;
branches;
next	1.86;

1.86
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.85;

1.85
date	2008.12.14.20.51.04;	author devans;	state Exp;
branches;
next	1.84;

1.84
date	2008.12.12.23.14.28;	author devans;	state Exp;
branches;
next	1.83;

1.83
date	2008.12.12.23.13.20;	author devans;	state Exp;
branches;
next	1.82;

1.82
date	2008.12.02.07.57.37;	author vprus;	state Exp;
branches;
next	1.81;

1.81
date	2008.11.14.22.06.41;	author drow;	state Exp;
branches
	1.81.2.1;
next	1.80;

1.80
date	2008.08.05.22.13.23;	author uweigand;	state Exp;
branches;
next	1.79;

1.79
date	2008.07.28.18.28.56;	author devans;	state Exp;
branches;
next	1.78;

1.78
date	2008.07.12.22.22.42;	author uweigand;	state Exp;
branches;
next	1.77;

1.77
date	2008.04.17.21.21.38;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2008.02.28.05.54.09;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2008.02.27.03.33.07;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2008.02.27.03.31.05;	author uweigand;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.27.03.27.40;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.01.00.08.25;	author palves;	state Exp;
branches;
next	1.71;

1.71
date	2008.01.30.00.51.50;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2007.12.21.16.04.27;	author schwab;	state Exp;
branches;
next	1.68;

1.68
date	2007.12.18.21.58.01;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2007.12.07.01.41.29;	author drow;	state Exp;
branches;
next	1.66;

1.66
date	2007.11.05.19.22.08;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2007.11.01.19.19.39;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2007.10.24.13.27.01;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2007.10.23.20.05.03;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2007.09.19.14.41.50;	author drow;	state Exp;
branches;
next	1.61;

1.61
date	2007.09.04.21.30.23;	author drow;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2007.07.02.15.35.36;	author drow;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.20.18.54.21;	author drow;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.13.21.03.38;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.10.21.33.31;	author palves;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.10.21.05.15;	author palves;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.27.18.32.01;	author drow;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.26.20.10.18;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.25.17.59.43;	author palves;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.09.22.55.10;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.03.17.57.16;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2006.11.16.15.08.25;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.17.16.02.27;	author drow;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.28.22.46.29;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2006.07.23.03.52.15;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.09.15.21.19;	author nathan;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2006.02.15.14.36.32;	author drow;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2005.12.23.18.11.55;	author eliz;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.13.15.21.02;	author drow;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2005.07.13.15.02.49;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.13.14.48.58;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.17.04.01.05;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2005.06.13.01.59.22;	author drow;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.16.10.24.37;	author uweigand;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.12.12.14.23;	author orjanf;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.03.16.56.53;	author drow;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2004.10.16.17.42.00;	author drow;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.23.21.14.24;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.12.20.51.50;	author drow;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.05.03.43.19;	author drow;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2004.02.29.16.47.15;	author drow;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2004.02.25.20.41.29;	author roland;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.31.22.19.31;	author drow;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2003.10.13.16.17.21;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.29.04.01.39;	author drow;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	2003.06.17.20.28.14;	author drow;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2003.06.05.14.26.58;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.29.22.56.50;	author jimb;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.26.16.36.41;	author drow;	state Exp;
branches
	1.21.14.1;
next	1.20;

1.20
date	2002.11.18.00.37.50;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.29.18.50.24;	author drow;	state Exp;
branches
	1.19.2.1
	1.19.4.1
	1.19.6.1;
next	1.18;

1.18
date	2002.07.18.15.18.02;	author mludvig;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.11.17.32.39;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.24.15.33.54;	author mludvig;	state Exp;
branches
	1.16.4.1
	1.16.6.1;
next	1.15;

1.15
date	2002.04.20.17.04.09;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.11.20.30.06;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.09.23.52.05;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.09.22.44.43;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.09.21.16.16;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.04.16.28.35;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.27.07.07.39;	author drow;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2002.02.20.22.58.57;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.14.06.21.22;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.05.22.14.09;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.05.22.01.49;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2002.02.05.19.09.34;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.05.19.06.26;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.05.18.49.55;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.05.18.44.18;	author drow;	state Exp;
branches;
next	;

1.233.2.1
date	2013.03.13.18.54.49;	author brobecke;	state Exp;
branches;
next	1.233.2.2;

1.233.2.2
date	2013.08.29.14.24.15;	author jkratoch;	state Exp;
branches;
next	;

1.183.2.1
date	2012.01.06.04.43.37;	author brobecke;	state Exp;
branches;
next	;

1.151.2.1
date	2010.08.11.15.58.49;	author tschwinge;	state Exp;
branches;
next	;

1.129.2.1
date	2010.03.06.00.12.57;	author palves;	state Exp;
branches;
next	;

1.81.2.1
date	2008.11.25.20.47.19;	author palves;	state Exp;
branches;
next	;

1.44.2.1
date	2006.08.28.07.48.46;	author nickrob;	state Exp;
branches;
next	;

1.43.2.1
date	2006.03.31.15.35.33;	author nathan;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2006.03.31.15.39.10;	author nathan;	state Exp;
branches
	1.43.2.2.2.1;
next	;

1.43.2.2.2.1
date	2006.04.12.14.48.23;	author drow;	state Exp;
branches;
next	1.43.2.2.2.2;

1.43.2.2.2.2
date	2006.04.12.14.52.05;	author drow;	state Exp;
branches;
next	1.43.2.2.2.3;

1.43.2.2.2.3
date	2006.04.12.18.11.42;	author drow;	state Exp;
branches;
next	;

1.41.2.1
date	2005.10.20.03.36.28;	author pbrook;	state Exp;
branches;
next	;

1.34.2.1
date	2005.03.29.02.52.06;	author pbrook;	state Exp;
branches;
next	;

1.30.2.1
date	2004.03.21.23.57.41;	author cagney;	state Exp;
branches;
next	;

1.29.2.1
date	2004.03.05.03.44.51;	author drow;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2004.03.12.20.53.24;	author drow;	state Exp;
branches;
next	1.29.2.3;

1.29.2.3
date	2004.03.23.21.16.21;	author drow;	state Exp;
branches;
next	;

1.27.4.1
date	2004.03.27.17.38.01;	author drow;	state Exp;
branches;
next	;

1.25.4.1
date	2004.03.23.20.28.36;	author ezannoni;	state Exp;
branches;
next	;

1.24.2.1
date	2003.06.29.04.03.04;	author drow;	state Exp;
branches;
next	;

1.21.14.1
date	2003.05.29.06.20.49;	author jimb;	state Exp;
branches;
next	1.21.14.2;

1.21.14.2
date	2003.05.29.19.01.10;	author jimb;	state Exp;
branches;
next	1.21.14.3;

1.21.14.3
date	2003.05.29.19.05.50;	author jimb;	state Exp;
branches;
next	;

1.19.2.1
date	2002.11.18.00.40.01;	author drow;	state Exp;
branches;
next	;

1.19.4.1
date	2002.12.23.19.39.08;	author carlton;	state Exp;
branches;
next	1.19.4.2;

1.19.4.2
date	2003.04.16.19.57.01;	author carlton;	state Exp;
branches;
next	1.19.4.3;

1.19.4.3
date	2003.06.27.21.50.18;	author carlton;	state Exp;
branches;
next	1.19.4.4;

1.19.4.4
date	2003.08.05.17.13.21;	author carlton;	state Exp;
branches;
next	1.19.4.5;

1.19.4.5
date	2003.11.11.23.51.09;	author carlton;	state Exp;
branches;
next	;

1.19.6.1
date	2003.12.14.20.27.44;	author drow;	state Exp;
branches;
next	1.19.6.2;

1.19.6.2
date	2004.02.09.19.43.54;	author drow;	state Exp;
branches;
next	;

1.16.4.1
date	2002.06.15.16.43.13;	author cagney;	state Exp;
branches;
next	;

1.16.6.1
date	2002.06.20.01.36.12;	author kseitz;	state Exp;
branches;
next	1.16.6.2;

1.16.6.2
date	2002.07.22.21.47.10;	author kseitz;	state Exp;
branches;
next	1.16.6.3;

1.16.6.3
date	2002.08.30.22.52.50;	author kseitz;	state Exp;
branches;
next	;

1.9.2.1
date	2002.03.07.20.56.18;	author drow;	state Exp;
branches;
next	;


desc
@@


1.248
log
@[gdbserver] Split a new hostio.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* server.h (handle_vFile, hostio_last_error_from_errno): Move
	to ...
	* hostio.h: ... this new file.
	* hostio.c, server.c, linux-low.c, nto-low.c, spu-low,
	win32-low.c: Include hostio.h.
@
text
@/* Low level interface to ptrace, for the remote server for GDB.
   Copyright (C) 1995-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "linux-low.h"
#include "linux-osdata.h"
#include "agent.h"

#include "nat/linux-nat.h"
#include "nat/linux-waitpid.h"
#include "gdb_wait.h"
#include <stdio.h>
#include <sys/ptrace.h>
#include "linux-ptrace.h"
#include "linux-procfs.h"
#include <signal.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/syscall.h>
#include <sched.h>
#include <ctype.h>
#include <pwd.h>
#include <sys/types.h>
#include <dirent.h>
#include "gdb_stat.h"
#include <sys/vfs.h>
#include <sys/uio.h>
#include "filestuff.h"
#include "tracepoint.h"
#include "hostio.h"
#ifndef ELFMAG0
/* Don't include <linux/elf.h> here.  If it got included by gdb_proc_service.h
   then ELFMAG0 will have been defined.  If it didn't get included by
   gdb_proc_service.h then including it will likely introduce a duplicate
   definition of elf_fpregset_t.  */
#include <elf.h>
#endif

#ifndef SPUFS_MAGIC
#define SPUFS_MAGIC 0x23c9b64e
#endif

#ifdef HAVE_PERSONALITY
# include <sys/personality.h>
# if !HAVE_DECL_ADDR_NO_RANDOMIZE
#  define ADDR_NO_RANDOMIZE 0x0040000
# endif
#endif

#ifndef O_LARGEFILE
#define O_LARGEFILE 0
#endif

#ifndef W_STOPCODE
#define W_STOPCODE(sig) ((sig) << 8 | 0x7f)
#endif

/* This is the kernel's hard limit.  Not to be confused with
   SIGRTMIN.  */
#ifndef __SIGRTMIN
#define __SIGRTMIN 32
#endif

/* Some targets did not define these ptrace constants from the start,
   so gdbserver defines them locally here.  In the future, these may
   be removed after they are added to asm/ptrace.h.  */
#if !(defined(PT_TEXT_ADDR) \
      || defined(PT_DATA_ADDR) \
      || defined(PT_TEXT_END_ADDR))
#if defined(__mcoldfire__)
/* These are still undefined in 3.10 kernels.  */
#define PT_TEXT_ADDR 49*4
#define PT_DATA_ADDR 50*4
#define PT_TEXT_END_ADDR  51*4
/* BFIN already defines these since at least 2.6.32 kernels.  */
#elif defined(BFIN)
#define PT_TEXT_ADDR 220
#define PT_TEXT_END_ADDR 224
#define PT_DATA_ADDR 228
/* These are still undefined in 3.10 kernels.  */
#elif defined(__TMS320C6X__)
#define PT_TEXT_ADDR     (0x10000*4)
#define PT_DATA_ADDR     (0x10004*4)
#define PT_TEXT_END_ADDR (0x10008*4)
#endif
#endif

#ifdef HAVE_LINUX_BTRACE
# include "linux-btrace.h"
#endif

#ifndef HAVE_ELF32_AUXV_T
/* Copied from glibc's elf.h.  */
typedef struct
{
  uint32_t a_type;		/* Entry type */
  union
    {
      uint32_t a_val;		/* Integer value */
      /* We use to have pointer elements added here.  We cannot do that,
	 though, since it does not work when using 32-bit definitions
	 on 64-bit platforms and vice versa.  */
    } a_un;
} Elf32_auxv_t;
#endif

#ifndef HAVE_ELF64_AUXV_T
/* Copied from glibc's elf.h.  */
typedef struct
{
  uint64_t a_type;		/* Entry type */
  union
    {
      uint64_t a_val;		/* Integer value */
      /* We use to have pointer elements added here.  We cannot do that,
	 though, since it does not work when using 32-bit definitions
	 on 64-bit platforms and vice versa.  */
    } a_un;
} Elf64_auxv_t;
#endif

/* ``all_threads'' is keyed by the LWP ID, which we use as the GDB protocol
   representation of the thread ID.

   ``all_lwps'' is keyed by the process ID - which on Linux is (presently)
   the same as the LWP ID.

   ``all_processes'' is keyed by the "overall process ID", which
   GNU/Linux calls tgid, "thread group ID".  */

struct inferior_list all_lwps;

/* A list of all unknown processes which receive stop signals.  Some
   other process will presumably claim each of these as forked
   children momentarily.  */

struct simple_pid_list
{
  /* The process ID.  */
  int pid;

  /* The status as reported by waitpid.  */
  int status;

  /* Next in chain.  */
  struct simple_pid_list *next;
};
struct simple_pid_list *stopped_pids;

/* Trivial list manipulation functions to keep track of a list of new
   stopped processes.  */

static void
add_to_pid_list (struct simple_pid_list **listp, int pid, int status)
{
  struct simple_pid_list *new_pid = xmalloc (sizeof (struct simple_pid_list));

  new_pid->pid = pid;
  new_pid->status = status;
  new_pid->next = *listp;
  *listp = new_pid;
}

static int
pull_pid_from_list (struct simple_pid_list **listp, int pid, int *statusp)
{
  struct simple_pid_list **p;

  for (p = listp; *p != NULL; p = &(*p)->next)
    if ((*p)->pid == pid)
      {
	struct simple_pid_list *next = (*p)->next;

	*statusp = (*p)->status;
	xfree (*p);
	*p = next;
	return 1;
      }
  return 0;
}

enum stopping_threads_kind
  {
    /* Not stopping threads presently.  */
    NOT_STOPPING_THREADS,

    /* Stopping threads.  */
    STOPPING_THREADS,

    /* Stopping and suspending threads.  */
    STOPPING_AND_SUSPENDING_THREADS
  };

/* This is set while stop_all_lwps is in effect.  */
enum stopping_threads_kind stopping_threads = NOT_STOPPING_THREADS;

/* FIXME make into a target method?  */
int using_threads = 1;

/* True if we're presently stabilizing threads (moving them out of
   jump pads).  */
static int stabilizing_threads;

static void linux_resume_one_lwp (struct lwp_info *lwp,
				  int step, int signal, siginfo_t *info);
static void linux_resume (struct thread_resume *resume_info, size_t n);
static void stop_all_lwps (int suspend, struct lwp_info *except);
static void unstop_all_lwps (int unsuspend, struct lwp_info *except);
static int linux_wait_for_event (ptid_t ptid, int *wstat, int options);
static void *add_lwp (ptid_t ptid);
static int linux_stopped_by_watchpoint (void);
static void mark_lwp_dead (struct lwp_info *lwp, int wstat);
static void proceed_all_lwps (void);
static int finish_step_over (struct lwp_info *lwp);
static CORE_ADDR get_stop_pc (struct lwp_info *lwp);
static int kill_lwp (unsigned long lwpid, int signo);

/* True if the low target can hardware single-step.  Such targets
   don't need a BREAKPOINT_REINSERT_ADDR callback.  */

static int
can_hardware_single_step (void)
{
  return (the_low_target.breakpoint_reinsert_addr == NULL);
}

/* True if the low target supports memory breakpoints.  If so, we'll
   have a GET_PC implementation.  */

static int
supports_breakpoints (void)
{
  return (the_low_target.get_pc != NULL);
}

/* Returns true if this target can support fast tracepoints.  This
   does not mean that the in-process agent has been loaded in the
   inferior.  */

static int
supports_fast_tracepoints (void)
{
  return the_low_target.install_fast_tracepoint_jump_pad != NULL;
}

/* True if LWP is stopped in its stepping range.  */

static int
lwp_in_step_range (struct lwp_info *lwp)
{
  CORE_ADDR pc = lwp->stop_pc;

  return (pc >= lwp->step_range_start && pc < lwp->step_range_end);
}

struct pending_signals
{
  int signal;
  siginfo_t info;
  struct pending_signals *prev;
};

/* The read/write ends of the pipe registered as waitable file in the
   event loop.  */
static int linux_event_pipe[2] = { -1, -1 };

/* True if we're currently in async mode.  */
#define target_is_async_p() (linux_event_pipe[0] != -1)

static void send_sigstop (struct lwp_info *lwp);
static void wait_for_sigstop (struct inferior_list_entry *entry);

/* Return non-zero if HEADER is a 64-bit ELF file.  */

static int
elf_64_header_p (const Elf64_Ehdr *header, unsigned int *machine)
{
  if (header->e_ident[EI_MAG0] == ELFMAG0
      && header->e_ident[EI_MAG1] == ELFMAG1
      && header->e_ident[EI_MAG2] == ELFMAG2
      && header->e_ident[EI_MAG3] == ELFMAG3)
    {
      *machine = header->e_machine;
      return header->e_ident[EI_CLASS] == ELFCLASS64;

    }
  *machine = EM_NONE;
  return -1;
}

/* Return non-zero if FILE is a 64-bit ELF file,
   zero if the file is not a 64-bit ELF file,
   and -1 if the file is not accessible or doesn't exist.  */

static int
elf_64_file_p (const char *file, unsigned int *machine)
{
  Elf64_Ehdr header;
  int fd;

  fd = open (file, O_RDONLY);
  if (fd < 0)
    return -1;

  if (read (fd, &header, sizeof (header)) != sizeof (header))
    {
      close (fd);
      return 0;
    }
  close (fd);

  return elf_64_header_p (&header, machine);
}

/* Accepts an integer PID; Returns true if the executable PID is
   running is a 64-bit ELF file..  */

int
linux_pid_exe_is_elf_64_file (int pid, unsigned int *machine)
{
  char file[PATH_MAX];

  sprintf (file, "/proc/%d/exe", pid);
  return elf_64_file_p (file, machine);
}

static void
delete_lwp (struct lwp_info *lwp)
{
  remove_thread (get_lwp_thread (lwp));
  remove_inferior (&all_lwps, &lwp->head);
  free (lwp->arch_private);
  free (lwp);
}

/* Add a process to the common process list, and set its private
   data.  */

static struct process_info *
linux_add_process (int pid, int attached)
{
  struct process_info *proc;

  proc = add_process (pid, attached);
  proc->private = xcalloc (1, sizeof (*proc->private));

  /* Set the arch when the first LWP stops.  */
  proc->private->new_inferior = 1;

  if (the_low_target.new_process != NULL)
    proc->private->arch_private = the_low_target.new_process ();

  return proc;
}

/* Handle a GNU/Linux extended wait response.  If we see a clone
   event, we need to add the new LWP to our list (and not report the
   trap to higher layers).  */

static void
handle_extended_wait (struct lwp_info *event_child, int wstat)
{
  int event = wstat >> 16;
  struct lwp_info *new_lwp;

  if (event == PTRACE_EVENT_CLONE)
    {
      ptid_t ptid;
      unsigned long new_pid;
      int ret, status;

      ptrace (PTRACE_GETEVENTMSG, lwpid_of (event_child), (PTRACE_TYPE_ARG3) 0,
	      &new_pid);

      /* If we haven't already seen the new PID stop, wait for it now.  */
      if (!pull_pid_from_list (&stopped_pids, new_pid, &status))
	{
	  /* The new child has a pending SIGSTOP.  We can't affect it until it
	     hits the SIGSTOP, but we're already attached.  */

	  ret = my_waitpid (new_pid, &status, __WALL);

	  if (ret == -1)
	    perror_with_name ("waiting for new child");
	  else if (ret != new_pid)
	    warning ("wait returned unexpected PID %d", ret);
	  else if (!WIFSTOPPED (status))
	    warning ("wait returned unexpected status 0x%x", status);
	}

      ptid = ptid_build (pid_of (event_child), new_pid, 0);
      new_lwp = (struct lwp_info *) add_lwp (ptid);
      add_thread (ptid, new_lwp);

      /* Either we're going to immediately resume the new thread
	 or leave it stopped.  linux_resume_one_lwp is a nop if it
	 thinks the thread is currently running, so set this first
	 before calling linux_resume_one_lwp.  */
      new_lwp->stopped = 1;

     /* If we're suspending all threads, leave this one suspended
	too.  */
      if (stopping_threads == STOPPING_AND_SUSPENDING_THREADS)
	new_lwp->suspended = 1;

      /* Normally we will get the pending SIGSTOP.  But in some cases
	 we might get another signal delivered to the group first.
	 If we do get another signal, be sure not to lose it.  */
      if (WSTOPSIG (status) == SIGSTOP)
	{
	  if (stopping_threads != NOT_STOPPING_THREADS)
	    new_lwp->stop_pc = get_stop_pc (new_lwp);
	  else
	    linux_resume_one_lwp (new_lwp, 0, 0, NULL);
	}
      else
	{
	  new_lwp->stop_expected = 1;

	  if (stopping_threads != NOT_STOPPING_THREADS)
	    {
	      new_lwp->stop_pc = get_stop_pc (new_lwp);
	      new_lwp->status_pending_p = 1;
	      new_lwp->status_pending = status;
	    }
	  else
	    /* Pass the signal on.  This is what GDB does - except
	       shouldn't we really report it instead?  */
	    linux_resume_one_lwp (new_lwp, 0, WSTOPSIG (status), NULL);
	}

      /* Always resume the current thread.  If we are stopping
	 threads, it will have a pending SIGSTOP; we may as well
	 collect it now.  */
      linux_resume_one_lwp (event_child, event_child->stepping, 0, NULL);
    }
}

/* Return the PC as read from the regcache of LWP, without any
   adjustment.  */

static CORE_ADDR
get_pc (struct lwp_info *lwp)
{
  struct thread_info *saved_inferior;
  struct regcache *regcache;
  CORE_ADDR pc;

  if (the_low_target.get_pc == NULL)
    return 0;

  saved_inferior = current_inferior;
  current_inferior = get_lwp_thread (lwp);

  regcache = get_thread_regcache (current_inferior, 1);
  pc = (*the_low_target.get_pc) (regcache);

  if (debug_threads)
    fprintf (stderr, "pc is 0x%lx\n", (long) pc);

  current_inferior = saved_inferior;
  return pc;
}

/* This function should only be called if LWP got a SIGTRAP.
   The SIGTRAP could mean several things.

   On i386, where decr_pc_after_break is non-zero:
   If we were single-stepping this process using PTRACE_SINGLESTEP,
   we will get only the one SIGTRAP (even if the instruction we
   stepped over was a breakpoint).  The value of $eip will be the
   next instruction.
   If we continue the process using PTRACE_CONT, we will get a
   SIGTRAP when we hit a breakpoint.  The value of $eip will be
   the instruction after the breakpoint (i.e. needs to be
   decremented).  If we report the SIGTRAP to GDB, we must also
   report the undecremented PC.  If we cancel the SIGTRAP, we
   must resume at the decremented PC.

   (Presumably, not yet tested) On a non-decr_pc_after_break machine
   with hardware or kernel single-step:
   If we single-step over a breakpoint instruction, our PC will
   point at the following instruction.  If we continue and hit a
   breakpoint instruction, our PC will point at the breakpoint
   instruction.  */

static CORE_ADDR
get_stop_pc (struct lwp_info *lwp)
{
  CORE_ADDR stop_pc;

  if (the_low_target.get_pc == NULL)
    return 0;

  stop_pc = get_pc (lwp);

  if (WSTOPSIG (lwp->last_status) == SIGTRAP
      && !lwp->stepping
      && !lwp->stopped_by_watchpoint
      && lwp->last_status >> 16 == 0)
    stop_pc -= the_low_target.decr_pc_after_break;

  if (debug_threads)
    fprintf (stderr, "stop pc is 0x%lx\n", (long) stop_pc);

  return stop_pc;
}

static void *
add_lwp (ptid_t ptid)
{
  struct lwp_info *lwp;

  lwp = (struct lwp_info *) xmalloc (sizeof (*lwp));
  memset (lwp, 0, sizeof (*lwp));

  lwp->head.id = ptid;

  if (the_low_target.new_thread != NULL)
    lwp->arch_private = the_low_target.new_thread ();

  add_inferior_to_list (&all_lwps, &lwp->head);

  return lwp;
}

/* Start an inferior process and returns its pid.
   ALLARGS is a vector of program-name and args. */

static int
linux_create_inferior (char *program, char **allargs)
{
#ifdef HAVE_PERSONALITY
  int personality_orig = 0, personality_set = 0;
#endif
  struct lwp_info *new_lwp;
  int pid;
  ptid_t ptid;

#ifdef HAVE_PERSONALITY
  if (disable_randomization)
    {
      errno = 0;
      personality_orig = personality (0xffffffff);
      if (errno == 0 && !(personality_orig & ADDR_NO_RANDOMIZE))
	{
	  personality_set = 1;
	  personality (personality_orig | ADDR_NO_RANDOMIZE);
	}
      if (errno != 0 || (personality_set
			 && !(personality (0xffffffff) & ADDR_NO_RANDOMIZE)))
	warning ("Error disabling address space randomization: %s",
		 strerror (errno));
    }
#endif

#if defined(__UCLIBC__) && defined(HAS_NOMMU)
  pid = vfork ();
#else
  pid = fork ();
#endif
  if (pid < 0)
    perror_with_name ("fork");

  if (pid == 0)
    {
      close_most_fds ();
      ptrace (PTRACE_TRACEME, 0, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0);

#ifndef __ANDROID__ /* Bionic doesn't use SIGRTMIN the way glibc does.  */
      signal (__SIGRTMIN + 1, SIG_DFL);
#endif

      setpgid (0, 0);

      /* If gdbserver is connected to gdb via stdio, redirect the inferior's
	 stdout to stderr so that inferior i/o doesn't corrupt the connection.
	 Also, redirect stdin to /dev/null.  */
      if (remote_connection_is_stdio ())
	{
	  close (0);
	  open ("/dev/null", O_RDONLY);
	  dup2 (2, 1);
	  if (write (2, "stdin/stdout redirected\n",
		     sizeof ("stdin/stdout redirected\n") - 1) < 0)
	    {
	      /* Errors ignored.  */;
	    }
	}

      execv (program, allargs);
      if (errno == ENOENT)
	execvp (program, allargs);

      fprintf (stderr, "Cannot exec %s: %s.\n", program,
	       strerror (errno));
      fflush (stderr);
      _exit (0177);
    }

#ifdef HAVE_PERSONALITY
  if (personality_set)
    {
      errno = 0;
      personality (personality_orig);
      if (errno != 0)
	warning ("Error restoring address space randomization: %s",
		 strerror (errno));
    }
#endif

  linux_add_process (pid, 0);

  ptid = ptid_build (pid, pid, 0);
  new_lwp = add_lwp (ptid);
  add_thread (ptid, new_lwp);
  new_lwp->must_set_ptrace_flags = 1;

  return pid;
}

/* Attach to an inferior process.  */

static void
linux_attach_lwp_1 (unsigned long lwpid, int initial)
{
  ptid_t ptid;
  struct lwp_info *new_lwp;

  if (ptrace (PTRACE_ATTACH, lwpid, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0)
      != 0)
    {
      struct buffer buffer;

      if (!initial)
	{
	  /* If we fail to attach to an LWP, just warn.  */
	  fprintf (stderr, "Cannot attach to lwp %ld: %s (%d)\n", lwpid,
		   strerror (errno), errno);
	  fflush (stderr);
	  return;
	}

      /* If we fail to attach to a process, report an error.  */
      buffer_init (&buffer);
      linux_ptrace_attach_warnings (lwpid, &buffer);
      buffer_grow_str0 (&buffer, "");
      error ("%sCannot attach to lwp %ld: %s (%d)", buffer_finish (&buffer),
	     lwpid, strerror (errno), errno);
    }

  if (initial)
    /* If lwp is the tgid, we handle adding existing threads later.
       Otherwise we just add lwp without bothering about any other
       threads.  */
    ptid = ptid_build (lwpid, lwpid, 0);
  else
    {
      /* Note that extracting the pid from the current inferior is
	 safe, since we're always called in the context of the same
	 process as this new thread.  */
      int pid = pid_of (get_thread_lwp (current_inferior));
      ptid = ptid_build (pid, lwpid, 0);
    }

  new_lwp = (struct lwp_info *) add_lwp (ptid);
  add_thread (ptid, new_lwp);

  /* We need to wait for SIGSTOP before being able to make the next
     ptrace call on this LWP.  */
  new_lwp->must_set_ptrace_flags = 1;

  if (linux_proc_pid_is_stopped (lwpid))
    {
      if (debug_threads)
	fprintf (stderr,
		 "Attached to a stopped process\n");

      /* The process is definitely stopped.  It is in a job control
	 stop, unless the kernel predates the TASK_STOPPED /
	 TASK_TRACED distinction, in which case it might be in a
	 ptrace stop.  Make sure it is in a ptrace stop; from there we
	 can kill it, signal it, et cetera.

	 First make sure there is a pending SIGSTOP.  Since we are
	 already attached, the process can not transition from stopped
	 to running without a PTRACE_CONT; so we know this signal will
	 go into the queue.  The SIGSTOP generated by PTRACE_ATTACH is
	 probably already in the queue (unless this kernel is old
	 enough to use TASK_STOPPED for ptrace stops); but since
	 SIGSTOP is not an RT signal, it can only be queued once.  */
      kill_lwp (lwpid, SIGSTOP);

      /* Finally, resume the stopped process.  This will deliver the
	 SIGSTOP (or a higher priority signal, just like normal
	 PTRACE_ATTACH), which we'll catch later on.  */
      ptrace (PTRACE_CONT, lwpid, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0);
    }

  /* The next time we wait for this LWP we'll see a SIGSTOP as PTRACE_ATTACH
     brings it to a halt.

     There are several cases to consider here:

     1) gdbserver has already attached to the process and is being notified
	of a new thread that is being created.
	In this case we should ignore that SIGSTOP and resume the
	process.  This is handled below by setting stop_expected = 1,
	and the fact that add_thread sets last_resume_kind ==
	resume_continue.

     2) This is the first thread (the process thread), and we're attaching
	to it via attach_inferior.
	In this case we want the process thread to stop.
	This is handled by having linux_attach set last_resume_kind ==
	resume_stop after we return.

	If the pid we are attaching to is also the tgid, we attach to and
	stop all the existing threads.  Otherwise, we attach to pid and
	ignore any other threads in the same group as this pid.

     3) GDB is connecting to gdbserver and is requesting an enumeration of all
	existing threads.
	In this case we want the thread to stop.
	FIXME: This case is currently not properly handled.
	We should wait for the SIGSTOP but don't.  Things work apparently
	because enough time passes between when we ptrace (ATTACH) and when
	gdb makes the next ptrace call on the thread.

     On the other hand, if we are currently trying to stop all threads, we
     should treat the new thread as if we had sent it a SIGSTOP.  This works
     because we are guaranteed that the add_lwp call above added us to the
     end of the list, and so the new thread has not yet reached
     wait_for_sigstop (but will).  */
  new_lwp->stop_expected = 1;
}

void
linux_attach_lwp (unsigned long lwpid)
{
  linux_attach_lwp_1 (lwpid, 0);
}

/* Attach to PID.  If PID is the tgid, attach to it and all
   of its threads.  */

static int
linux_attach (unsigned long pid)
{
  /* Attach to PID.  We will check for other threads
     soon.  */
  linux_attach_lwp_1 (pid, 1);
  linux_add_process (pid, 1);

  if (!non_stop)
    {
      struct thread_info *thread;

     /* Don't ignore the initial SIGSTOP if we just attached to this
	process.  It will be collected by wait shortly.  */
      thread = find_thread_ptid (ptid_build (pid, pid, 0));
      thread->last_resume_kind = resume_stop;
    }

  if (linux_proc_get_tgid (pid) == pid)
    {
      DIR *dir;
      char pathname[128];

      sprintf (pathname, "/proc/%ld/task", pid);

      dir = opendir (pathname);

      if (!dir)
	{
	  fprintf (stderr, "Could not open /proc/%ld/task.\n", pid);
	  fflush (stderr);
	}
      else
	{
	  /* At this point we attached to the tgid.  Scan the task for
	     existing threads.  */
	  unsigned long lwp;
	  int new_threads_found;
	  int iterations = 0;
	  struct dirent *dp;

	  while (iterations < 2)
	    {
	      new_threads_found = 0;
	      /* Add all the other threads.  While we go through the
		 threads, new threads may be spawned.  Cycle through
		 the list of threads until we have done two iterations without
		 finding new threads.  */
	      while ((dp = readdir (dir)) != NULL)
		{
		  /* Fetch one lwp.  */
		  lwp = strtoul (dp->d_name, NULL, 10);

		  /* Is this a new thread?  */
		  if (lwp
		      && find_thread_ptid (ptid_build (pid, lwp, 0)) == NULL)
		    {
		      linux_attach_lwp_1 (lwp, 0);
		      new_threads_found++;

		      if (debug_threads)
			fprintf (stderr, "\
Found and attached to new lwp %ld\n", lwp);
		    }
		}

	      if (!new_threads_found)
		iterations++;
	      else
		iterations = 0;

	      rewinddir (dir);
	    }
	  closedir (dir);
	}
    }

  return 0;
}

struct counter
{
  int pid;
  int count;
};

static int
second_thread_of_pid_p (struct inferior_list_entry *entry, void *args)
{
  struct counter *counter = args;

  if (ptid_get_pid (entry->id) == counter->pid)
    {
      if (++counter->count > 1)
	return 1;
    }

  return 0;
}

static int
last_thread_of_process_p (struct thread_info *thread)
{
  ptid_t ptid = ((struct inferior_list_entry *)thread)->id;
  int pid = ptid_get_pid (ptid);
  struct counter counter = { pid , 0 };

  return (find_inferior (&all_threads,
			 second_thread_of_pid_p, &counter) == NULL);
}

/* Kill LWP.  */

static void
linux_kill_one_lwp (struct lwp_info *lwp)
{
  int pid = lwpid_of (lwp);

  /* PTRACE_KILL is unreliable.  After stepping into a signal handler,
     there is no signal context, and ptrace(PTRACE_KILL) (or
     ptrace(PTRACE_CONT, SIGKILL), pretty much the same) acts like
     ptrace(CONT, pid, 0,0) and just resumes the tracee.  A better
     alternative is to kill with SIGKILL.  We only need one SIGKILL
     per process, not one for each thread.  But since we still support
     linuxthreads, and we also support debugging programs using raw
     clone without CLONE_THREAD, we send one for each thread.  For
     years, we used PTRACE_KILL only, so we're being a bit paranoid
     about some old kernels where PTRACE_KILL might work better
     (dubious if there are any such, but that's why it's paranoia), so
     we try SIGKILL first, PTRACE_KILL second, and so we're fine
     everywhere.  */

  errno = 0;
  kill (pid, SIGKILL);
  if (debug_threads)
    fprintf (stderr,
	     "LKL:  kill (SIGKILL) %s, 0, 0 (%s)\n",
	     target_pid_to_str (ptid_of (lwp)),
	     errno ? strerror (errno) : "OK");

  errno = 0;
  ptrace (PTRACE_KILL, pid, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0);
  if (debug_threads)
    fprintf (stderr,
	     "LKL:  PTRACE_KILL %s, 0, 0 (%s)\n",
	     target_pid_to_str (ptid_of (lwp)),
	     errno ? strerror (errno) : "OK");
}

/* Callback for `find_inferior'.  Kills an lwp of a given process,
   except the leader.  */

static int
kill_one_lwp_callback (struct inferior_list_entry *entry, void *args)
{
  struct thread_info *thread = (struct thread_info *) entry;
  struct lwp_info *lwp = get_thread_lwp (thread);
  int wstat;
  int pid = * (int *) args;

  if (ptid_get_pid (entry->id) != pid)
    return 0;

  /* We avoid killing the first thread here, because of a Linux kernel (at
     least 2.6.0-test7 through 2.6.8-rc4) bug; if we kill the parent before
     the children get a chance to be reaped, it will remain a zombie
     forever.  */

  if (lwpid_of (lwp) == pid)
    {
      if (debug_threads)
	fprintf (stderr, "lkop: is last of process %s\n",
		 target_pid_to_str (entry->id));
      return 0;
    }

  do
    {
      linux_kill_one_lwp (lwp);

      /* Make sure it died.  The loop is most likely unnecessary.  */
      pid = linux_wait_for_event (lwp->head.id, &wstat, __WALL);
    } while (pid > 0 && WIFSTOPPED (wstat));

  return 0;
}

static int
linux_kill (int pid)
{
  struct process_info *process;
  struct lwp_info *lwp;
  int wstat;
  int lwpid;

  process = find_process_pid (pid);
  if (process == NULL)
    return -1;

  /* If we're killing a running inferior, make sure it is stopped
     first, as PTRACE_KILL will not work otherwise.  */
  stop_all_lwps (0, NULL);

  find_inferior (&all_threads, kill_one_lwp_callback , &pid);

  /* See the comment in linux_kill_one_lwp.  We did not kill the first
     thread in the list, so do so now.  */
  lwp = find_lwp_pid (pid_to_ptid (pid));

  if (lwp == NULL)
    {
      if (debug_threads)
	fprintf (stderr, "lk_1: cannot find lwp %ld, for pid: %d\n",
		 lwpid_of (lwp), pid);
    }
  else
    {
      if (debug_threads)
	fprintf (stderr, "lk_1: killing lwp %ld, for pid: %d\n",
		 lwpid_of (lwp), pid);

      do
	{
	  linux_kill_one_lwp (lwp);

	  /* Make sure it died.  The loop is most likely unnecessary.  */
	  lwpid = linux_wait_for_event (lwp->head.id, &wstat, __WALL);
	} while (lwpid > 0 && WIFSTOPPED (wstat));
    }

  the_target->mourn (process);

  /* Since we presently can only stop all lwps of all processes, we
     need to unstop lwps of other processes.  */
  unstop_all_lwps (0, NULL);
  return 0;
}

/* Get pending signal of THREAD, for detaching purposes.  This is the
   signal the thread last stopped for, which we need to deliver to the
   thread when detaching, otherwise, it'd be suppressed/lost.  */

static int
get_detach_signal (struct thread_info *thread)
{
  enum gdb_signal signo = GDB_SIGNAL_0;
  int status;
  struct lwp_info *lp = get_thread_lwp (thread);

  if (lp->status_pending_p)
    status = lp->status_pending;
  else
    {
      /* If the thread had been suspended by gdbserver, and it stopped
	 cleanly, then it'll have stopped with SIGSTOP.  But we don't
	 want to deliver that SIGSTOP.  */
      if (thread->last_status.kind != TARGET_WAITKIND_STOPPED
	  || thread->last_status.value.sig == GDB_SIGNAL_0)
	return 0;

      /* Otherwise, we may need to deliver the signal we
	 intercepted.  */
      status = lp->last_status;
    }

  if (!WIFSTOPPED (status))
    {
      if (debug_threads)
	fprintf (stderr,
		 "GPS: lwp %s hasn't stopped: no pending signal\n",
		 target_pid_to_str (ptid_of (lp)));
      return 0;
    }

  /* Extended wait statuses aren't real SIGTRAPs.  */
  if (WSTOPSIG (status) == SIGTRAP && status >> 16 != 0)
    {
      if (debug_threads)
	fprintf (stderr,
		 "GPS: lwp %s had stopped with extended "
		 "status: no pending signal\n",
		 target_pid_to_str (ptid_of (lp)));
      return 0;
    }

  signo = gdb_signal_from_host (WSTOPSIG (status));

  if (program_signals_p && !program_signals[signo])
    {
      if (debug_threads)
	fprintf (stderr,
		 "GPS: lwp %s had signal %s, but it is in nopass state\n",
		 target_pid_to_str (ptid_of (lp)),
		 gdb_signal_to_string (signo));
      return 0;
    }
  else if (!program_signals_p
	   /* If we have no way to know which signals GDB does not
	      want to have passed to the program, assume
	      SIGTRAP/SIGINT, which is GDB's default.  */
	   && (signo == GDB_SIGNAL_TRAP || signo == GDB_SIGNAL_INT))
    {
      if (debug_threads)
	fprintf (stderr,
		 "GPS: lwp %s had signal %s, "
		 "but we don't know if we should pass it.  Default to not.\n",
		 target_pid_to_str (ptid_of (lp)),
		 gdb_signal_to_string (signo));
      return 0;
    }
  else
    {
      if (debug_threads)
	fprintf (stderr,
		 "GPS: lwp %s has pending signal %s: delivering it.\n",
		 target_pid_to_str (ptid_of (lp)),
		 gdb_signal_to_string (signo));

      return WSTOPSIG (status);
    }
}

static int
linux_detach_one_lwp (struct inferior_list_entry *entry, void *args)
{
  struct thread_info *thread = (struct thread_info *) entry;
  struct lwp_info *lwp = get_thread_lwp (thread);
  int pid = * (int *) args;
  int sig;

  if (ptid_get_pid (entry->id) != pid)
    return 0;

  /* If there is a pending SIGSTOP, get rid of it.  */
  if (lwp->stop_expected)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Sending SIGCONT to %s\n",
		 target_pid_to_str (ptid_of (lwp)));

      kill_lwp (lwpid_of (lwp), SIGCONT);
      lwp->stop_expected = 0;
    }

  /* Flush any pending changes to the process's registers.  */
  regcache_invalidate_thread (get_lwp_thread (lwp));

  /* Pass on any pending signal for this thread.  */
  sig = get_detach_signal (thread);

  /* Finally, let it resume.  */
  if (the_low_target.prepare_to_resume != NULL)
    the_low_target.prepare_to_resume (lwp);
  if (ptrace (PTRACE_DETACH, lwpid_of (lwp), (PTRACE_TYPE_ARG3) 0,
	      (PTRACE_TYPE_ARG4) (long) sig) < 0)
    error (_("Can't detach %s: %s"),
	   target_pid_to_str (ptid_of (lwp)),
	   strerror (errno));

  delete_lwp (lwp);
  return 0;
}

static int
linux_detach (int pid)
{
  struct process_info *process;

  process = find_process_pid (pid);
  if (process == NULL)
    return -1;

  /* Stop all threads before detaching.  First, ptrace requires that
     the thread is stopped to sucessfully detach.  Second, thread_db
     may need to uninstall thread event breakpoints from memory, which
     only works with a stopped process anyway.  */
  stop_all_lwps (0, NULL);

#ifdef USE_THREAD_DB
  thread_db_detach (process);
#endif

  /* Stabilize threads (move out of jump pads).  */
  stabilize_threads ();

  find_inferior (&all_threads, linux_detach_one_lwp, &pid);

  the_target->mourn (process);

  /* Since we presently can only stop all lwps of all processes, we
     need to unstop lwps of other processes.  */
  unstop_all_lwps (0, NULL);
  return 0;
}

/* Remove all LWPs that belong to process PROC from the lwp list.  */

static int
delete_lwp_callback (struct inferior_list_entry *entry, void *proc)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct process_info *process = proc;

  if (pid_of (lwp) == pid_of (process))
    delete_lwp (lwp);

  return 0;
}

static void
linux_mourn (struct process_info *process)
{
  struct process_info_private *priv;

#ifdef USE_THREAD_DB
  thread_db_mourn (process);
#endif

  find_inferior (&all_lwps, delete_lwp_callback, process);

  /* Freeing all private data.  */
  priv = process->private;
  free (priv->arch_private);
  free (priv);
  process->private = NULL;

  remove_process (process);
}

static void
linux_join (int pid)
{
  int status, ret;

  do {
    ret = my_waitpid (pid, &status, 0);
    if (WIFEXITED (status) || WIFSIGNALED (status))
      break;
  } while (ret != -1 || errno != ECHILD);
}

/* Return nonzero if the given thread is still alive.  */
static int
linux_thread_alive (ptid_t ptid)
{
  struct lwp_info *lwp = find_lwp_pid (ptid);

  /* We assume we always know if a thread exits.  If a whole process
     exited but we still haven't been able to report it to GDB, we'll
     hold on to the last lwp of the dead process.  */
  if (lwp != NULL)
    return !lwp->dead;
  else
    return 0;
}

/* Return 1 if this lwp has an interesting status pending.  */
static int
status_pending_p_callback (struct inferior_list_entry *entry, void *arg)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  ptid_t ptid = * (ptid_t *) arg;
  struct thread_info *thread;

  /* Check if we're only interested in events from a specific process
     or its lwps.  */
  if (!ptid_equal (minus_one_ptid, ptid)
      && ptid_get_pid (ptid) != ptid_get_pid (lwp->head.id))
    return 0;

  thread = get_lwp_thread (lwp);

  /* If we got a `vCont;t', but we haven't reported a stop yet, do
     report any status pending the LWP may have.  */
  if (thread->last_resume_kind == resume_stop
      && thread->last_status.kind != TARGET_WAITKIND_IGNORE)
    return 0;

  return lwp->status_pending_p;
}

static int
same_lwp (struct inferior_list_entry *entry, void *data)
{
  ptid_t ptid = *(ptid_t *) data;
  int lwp;

  if (ptid_get_lwp (ptid) != 0)
    lwp = ptid_get_lwp (ptid);
  else
    lwp = ptid_get_pid (ptid);

  if (ptid_get_lwp (entry->id) == lwp)
    return 1;

  return 0;
}

struct lwp_info *
find_lwp_pid (ptid_t ptid)
{
  return (struct lwp_info*) find_inferior (&all_lwps, same_lwp, &ptid);
}

static struct lwp_info *
linux_wait_for_lwp (ptid_t ptid, int *wstatp, int options)
{
  int ret;
  int to_wait_for = -1;
  struct lwp_info *child = NULL;

  if (debug_threads)
    fprintf (stderr, "linux_wait_for_lwp: %s\n", target_pid_to_str (ptid));

  if (ptid_equal (ptid, minus_one_ptid))
    to_wait_for = -1;			/* any child */
  else
    to_wait_for = ptid_get_lwp (ptid);	/* this lwp only */

  options |= __WALL;

retry:

  ret = my_waitpid (to_wait_for, wstatp, options);
  if (ret == 0 || (ret == -1 && errno == ECHILD && (options & WNOHANG)))
    return NULL;
  else if (ret == -1)
    perror_with_name ("waitpid");

  if (debug_threads
      && (!WIFSTOPPED (*wstatp)
	  || (WSTOPSIG (*wstatp) != 32
	      && WSTOPSIG (*wstatp) != 33)))
    fprintf (stderr, "Got an event from %d (%x)\n", ret, *wstatp);

  child = find_lwp_pid (pid_to_ptid (ret));

  /* If we didn't find a process, one of two things presumably happened:
     - A process we started and then detached from has exited.  Ignore it.
     - A process we are controlling has forked and the new child's stop
     was reported to us by the kernel.  Save its PID.  */
  if (child == NULL && WIFSTOPPED (*wstatp))
    {
      add_to_pid_list (&stopped_pids, ret, *wstatp);
      goto retry;
    }
  else if (child == NULL)
    goto retry;

  child->stopped = 1;

  child->last_status = *wstatp;

  if (WIFSTOPPED (*wstatp))
    {
      struct process_info *proc;

      /* Architecture-specific setup after inferior is running.  This
	 needs to happen after we have attached to the inferior and it
	 is stopped for the first time, but before we access any
	 inferior registers.  */
      proc = find_process_pid (pid_of (child));
      if (proc->private->new_inferior)
	{
	  struct thread_info *saved_inferior;

	  saved_inferior = current_inferior;
	  current_inferior = get_lwp_thread (child);

	  the_low_target.arch_setup ();

	  current_inferior = saved_inferior;

	  proc->private->new_inferior = 0;
	}
    }

  /* Fetch the possibly triggered data watchpoint info and store it in
     CHILD.

     On some archs, like x86, that use debug registers to set
     watchpoints, it's possible that the way to know which watched
     address trapped, is to check the register that is used to select
     which address to watch.  Problem is, between setting the
     watchpoint and reading back which data address trapped, the user
     may change the set of watchpoints, and, as a consequence, GDB
     changes the debug registers in the inferior.  To avoid reading
     back a stale stopped-data-address when that happens, we cache in
     LP the fact that a watchpoint trapped, and the corresponding data
     address, as soon as we see CHILD stop with a SIGTRAP.  If GDB
     changes the debug registers meanwhile, we have the cached data we
     can rely on.  */

  if (WIFSTOPPED (*wstatp) && WSTOPSIG (*wstatp) == SIGTRAP)
    {
      if (the_low_target.stopped_by_watchpoint == NULL)
	{
	  child->stopped_by_watchpoint = 0;
	}
      else
	{
	  struct thread_info *saved_inferior;

	  saved_inferior = current_inferior;
	  current_inferior = get_lwp_thread (child);

	  child->stopped_by_watchpoint
	    = the_low_target.stopped_by_watchpoint ();

	  if (child->stopped_by_watchpoint)
	    {
	      if (the_low_target.stopped_data_address != NULL)
		child->stopped_data_address
		  = the_low_target.stopped_data_address ();
	      else
		child->stopped_data_address = 0;
	    }

	  current_inferior = saved_inferior;
	}
    }

  /* Store the STOP_PC, with adjustment applied.  This depends on the
     architecture being defined already (so that CHILD has a valid
     regcache), and on LAST_STATUS being set (to check for SIGTRAP or
     not).  */
  if (WIFSTOPPED (*wstatp))
    child->stop_pc = get_stop_pc (child);

  if (debug_threads
      && WIFSTOPPED (*wstatp)
      && the_low_target.get_pc != NULL)
    {
      struct thread_info *saved_inferior = current_inferior;
      struct regcache *regcache;
      CORE_ADDR pc;

      current_inferior = get_lwp_thread (child);
      regcache = get_thread_regcache (current_inferior, 1);
      pc = (*the_low_target.get_pc) (regcache);
      fprintf (stderr, "linux_wait_for_lwp: pc is 0x%lx\n", (long) pc);
      current_inferior = saved_inferior;
    }

  return child;
}

/* This function should only be called if the LWP got a SIGTRAP.

   Handle any tracepoint steps or hits.  Return true if a tracepoint
   event was handled, 0 otherwise.  */

static int
handle_tracepoints (struct lwp_info *lwp)
{
  struct thread_info *tinfo = get_lwp_thread (lwp);
  int tpoint_related_event = 0;

  /* If this tracepoint hit causes a tracing stop, we'll immediately
     uninsert tracepoints.  To do this, we temporarily pause all
     threads, unpatch away, and then unpause threads.  We need to make
     sure the unpausing doesn't resume LWP too.  */
  lwp->suspended++;

  /* And we need to be sure that any all-threads-stopping doesn't try
     to move threads out of the jump pads, as it could deadlock the
     inferior (LWP could be in the jump pad, maybe even holding the
     lock.)  */

  /* Do any necessary step collect actions.  */
  tpoint_related_event |= tracepoint_finished_step (tinfo, lwp->stop_pc);

  tpoint_related_event |= handle_tracepoint_bkpts (tinfo, lwp->stop_pc);

  /* See if we just hit a tracepoint and do its main collect
     actions.  */
  tpoint_related_event |= tracepoint_was_hit (tinfo, lwp->stop_pc);

  lwp->suspended--;

  gdb_assert (lwp->suspended == 0);
  gdb_assert (!stabilizing_threads || lwp->collecting_fast_tracepoint);

  if (tpoint_related_event)
    {
      if (debug_threads)
	fprintf (stderr, "got a tracepoint event\n");
      return 1;
    }

  return 0;
}

/* Convenience wrapper.  Returns true if LWP is presently collecting a
   fast tracepoint.  */

static int
linux_fast_tracepoint_collecting (struct lwp_info *lwp,
				  struct fast_tpoint_collect_status *status)
{
  CORE_ADDR thread_area;

  if (the_low_target.get_thread_area == NULL)
    return 0;

  /* Get the thread area address.  This is used to recognize which
     thread is which when tracing with the in-process agent library.
     We don't read anything from the address, and treat it as opaque;
     it's the address itself that we assume is unique per-thread.  */
  if ((*the_low_target.get_thread_area) (lwpid_of (lwp), &thread_area) == -1)
    return 0;

  return fast_tracepoint_collecting (thread_area, lwp->stop_pc, status);
}

/* The reason we resume in the caller, is because we want to be able
   to pass lwp->status_pending as WSTAT, and we need to clear
   status_pending_p before resuming, otherwise, linux_resume_one_lwp
   refuses to resume.  */

static int
maybe_move_out_of_jump_pad (struct lwp_info *lwp, int *wstat)
{
  struct thread_info *saved_inferior;

  saved_inferior = current_inferior;
  current_inferior = get_lwp_thread (lwp);

  if ((wstat == NULL
       || (WIFSTOPPED (*wstat) && WSTOPSIG (*wstat) != SIGTRAP))
      && supports_fast_tracepoints ()
      && agent_loaded_p ())
    {
      struct fast_tpoint_collect_status status;
      int r;

      if (debug_threads)
	fprintf (stderr, "\
Checking whether LWP %ld needs to move out of the jump pad.\n",
		 lwpid_of (lwp));

      r = linux_fast_tracepoint_collecting (lwp, &status);

      if (wstat == NULL
	  || (WSTOPSIG (*wstat) != SIGILL
	      && WSTOPSIG (*wstat) != SIGFPE
	      && WSTOPSIG (*wstat) != SIGSEGV
	      && WSTOPSIG (*wstat) != SIGBUS))
	{
	  lwp->collecting_fast_tracepoint = r;

	  if (r != 0)
	    {
	      if (r == 1 && lwp->exit_jump_pad_bkpt == NULL)
		{
		  /* Haven't executed the original instruction yet.
		     Set breakpoint there, and wait till it's hit,
		     then single-step until exiting the jump pad.  */
		  lwp->exit_jump_pad_bkpt
		    = set_breakpoint_at (status.adjusted_insn_addr, NULL);
		}

	      if (debug_threads)
		fprintf (stderr, "\
Checking whether LWP %ld needs to move out of the jump pad...it does\n",
		 lwpid_of (lwp));
	      current_inferior = saved_inferior;

	      return 1;
	    }
	}
      else
	{
	  /* If we get a synchronous signal while collecting, *and*
	     while executing the (relocated) original instruction,
	     reset the PC to point at the tpoint address, before
	     reporting to GDB.  Otherwise, it's an IPA lib bug: just
	     report the signal to GDB, and pray for the best.  */

	  lwp->collecting_fast_tracepoint = 0;

	  if (r != 0
	      && (status.adjusted_insn_addr <= lwp->stop_pc
		  && lwp->stop_pc < status.adjusted_insn_addr_end))
	    {
	      siginfo_t info;
	      struct regcache *regcache;

	      /* The si_addr on a few signals references the address
		 of the faulting instruction.  Adjust that as
		 well.  */
	      if ((WSTOPSIG (*wstat) == SIGILL
		   || WSTOPSIG (*wstat) == SIGFPE
		   || WSTOPSIG (*wstat) == SIGBUS
		   || WSTOPSIG (*wstat) == SIGSEGV)
		  && ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp),
			     (PTRACE_TYPE_ARG3) 0, &info) == 0
		  /* Final check just to make sure we don't clobber
		     the siginfo of non-kernel-sent signals.  */
		  && (uintptr_t) info.si_addr == lwp->stop_pc)
		{
		  info.si_addr = (void *) (uintptr_t) status.tpoint_addr;
		  ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp),
			  (PTRACE_TYPE_ARG3) 0, &info);
		}

	      regcache = get_thread_regcache (get_lwp_thread (lwp), 1);
	      (*the_low_target.set_pc) (regcache, status.tpoint_addr);
	      lwp->stop_pc = status.tpoint_addr;

	      /* Cancel any fast tracepoint lock this thread was
		 holding.  */
	      force_unlock_trace_buffer ();
	    }

	  if (lwp->exit_jump_pad_bkpt != NULL)
	    {
	      if (debug_threads)
		fprintf (stderr,
			 "Cancelling fast exit-jump-pad: removing bkpt. "
			 "stopping all threads momentarily.\n");

	      stop_all_lwps (1, lwp);
	      cancel_breakpoints ();

	      delete_breakpoint (lwp->exit_jump_pad_bkpt);
	      lwp->exit_jump_pad_bkpt = NULL;

	      unstop_all_lwps (1, lwp);

	      gdb_assert (lwp->suspended >= 0);
	    }
	}
    }

  if (debug_threads)
    fprintf (stderr, "\
Checking whether LWP %ld needs to move out of the jump pad...no\n",
	     lwpid_of (lwp));

  current_inferior = saved_inferior;
  return 0;
}

/* Enqueue one signal in the "signals to report later when out of the
   jump pad" list.  */

static void
enqueue_one_deferred_signal (struct lwp_info *lwp, int *wstat)
{
  struct pending_signals *p_sig;

  if (debug_threads)
    fprintf (stderr, "\
Deferring signal %d for LWP %ld.\n", WSTOPSIG (*wstat), lwpid_of (lwp));

  if (debug_threads)
    {
      struct pending_signals *sig;

      for (sig = lwp->pending_signals_to_report;
	   sig != NULL;
	   sig = sig->prev)
	fprintf (stderr,
		 "   Already queued %d\n",
		 sig->signal);

      fprintf (stderr, "   (no more currently queued signals)\n");
    }

  /* Don't enqueue non-RT signals if they are already in the deferred
     queue.  (SIGSTOP being the easiest signal to see ending up here
     twice)  */
  if (WSTOPSIG (*wstat) < __SIGRTMIN)
    {
      struct pending_signals *sig;

      for (sig = lwp->pending_signals_to_report;
	   sig != NULL;
	   sig = sig->prev)
	{
	  if (sig->signal == WSTOPSIG (*wstat))
	    {
	      if (debug_threads)
		fprintf (stderr,
			 "Not requeuing already queued non-RT signal %d"
			 " for LWP %ld\n",
			 sig->signal,
			 lwpid_of (lwp));
	      return;
	    }
	}
    }

  p_sig = xmalloc (sizeof (*p_sig));
  p_sig->prev = lwp->pending_signals_to_report;
  p_sig->signal = WSTOPSIG (*wstat);
  memset (&p_sig->info, 0, sizeof (siginfo_t));
  ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp), (PTRACE_TYPE_ARG3) 0,
	  &p_sig->info);

  lwp->pending_signals_to_report = p_sig;
}

/* Dequeue one signal from the "signals to report later when out of
   the jump pad" list.  */

static int
dequeue_one_deferred_signal (struct lwp_info *lwp, int *wstat)
{
  if (lwp->pending_signals_to_report != NULL)
    {
      struct pending_signals **p_sig;

      p_sig = &lwp->pending_signals_to_report;
      while ((*p_sig)->prev != NULL)
	p_sig = &(*p_sig)->prev;

      *wstat = W_STOPCODE ((*p_sig)->signal);
      if ((*p_sig)->info.si_signo != 0)
	ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp), (PTRACE_TYPE_ARG3) 0,
		&(*p_sig)->info);
      free (*p_sig);
      *p_sig = NULL;

      if (debug_threads)
	fprintf (stderr, "Reporting deferred signal %d for LWP %ld.\n",
		 WSTOPSIG (*wstat), lwpid_of (lwp));

      if (debug_threads)
	{
	  struct pending_signals *sig;

	  for (sig = lwp->pending_signals_to_report;
	       sig != NULL;
	       sig = sig->prev)
	    fprintf (stderr,
		     "   Still queued %d\n",
		     sig->signal);

	  fprintf (stderr, "   (no more queued signals)\n");
	}

      return 1;
    }

  return 0;
}

/* Arrange for a breakpoint to be hit again later.  We don't keep the
   SIGTRAP status and don't forward the SIGTRAP signal to the LWP.  We
   will handle the current event, eventually we will resume this LWP,
   and this breakpoint will trap again.  */

static int
cancel_breakpoint (struct lwp_info *lwp)
{
  struct thread_info *saved_inferior;

  /* There's nothing to do if we don't support breakpoints.  */
  if (!supports_breakpoints ())
    return 0;

  /* breakpoint_at reads from current inferior.  */
  saved_inferior = current_inferior;
  current_inferior = get_lwp_thread (lwp);

  if ((*the_low_target.breakpoint_at) (lwp->stop_pc))
    {
      if (debug_threads)
	fprintf (stderr,
		 "CB: Push back breakpoint for %s\n",
		 target_pid_to_str (ptid_of (lwp)));

      /* Back up the PC if necessary.  */
      if (the_low_target.decr_pc_after_break)
	{
	  struct regcache *regcache
	    = get_thread_regcache (current_inferior, 1);
	  (*the_low_target.set_pc) (regcache, lwp->stop_pc);
	}

      current_inferior = saved_inferior;
      return 1;
    }
  else
    {
      if (debug_threads)
	fprintf (stderr,
		 "CB: No breakpoint found at %s for [%s]\n",
		 paddress (lwp->stop_pc),
		 target_pid_to_str (ptid_of (lwp)));
    }

  current_inferior = saved_inferior;
  return 0;
}

/* When the event-loop is doing a step-over, this points at the thread
   being stepped.  */
ptid_t step_over_bkpt;

/* Wait for an event from child PID.  If PID is -1, wait for any
   child.  Store the stop status through the status pointer WSTAT.
   OPTIONS is passed to the waitpid call.  Return 0 if no child stop
   event was found and OPTIONS contains WNOHANG.  Return the PID of
   the stopped child otherwise.  */

static int
linux_wait_for_event (ptid_t ptid, int *wstat, int options)
{
  struct lwp_info *event_child, *requested_child;
  ptid_t wait_ptid;

  event_child = NULL;
  requested_child = NULL;

  /* Check for a lwp with a pending status.  */

  if (ptid_equal (ptid, minus_one_ptid) || ptid_is_pid (ptid))
    {
      event_child = (struct lwp_info *)
	find_inferior (&all_lwps, status_pending_p_callback, &ptid);
      if (debug_threads && event_child)
	fprintf (stderr, "Got a pending child %ld\n", lwpid_of (event_child));
    }
  else
    {
      requested_child = find_lwp_pid (ptid);

      if (stopping_threads == NOT_STOPPING_THREADS
	  && requested_child->status_pending_p
	  && requested_child->collecting_fast_tracepoint)
	{
	  enqueue_one_deferred_signal (requested_child,
				       &requested_child->status_pending);
	  requested_child->status_pending_p = 0;
	  requested_child->status_pending = 0;
	  linux_resume_one_lwp (requested_child, 0, 0, NULL);
	}

      if (requested_child->suspended
	  && requested_child->status_pending_p)
	fatal ("requesting an event out of a suspended child?");

      if (requested_child->status_pending_p)
	event_child = requested_child;
    }

  if (event_child != NULL)
    {
      if (debug_threads)
	fprintf (stderr, "Got an event from pending child %ld (%04x)\n",
		 lwpid_of (event_child), event_child->status_pending);
      *wstat = event_child->status_pending;
      event_child->status_pending_p = 0;
      event_child->status_pending = 0;
      current_inferior = get_lwp_thread (event_child);
      return lwpid_of (event_child);
    }

  if (ptid_is_pid (ptid))
    {
      /* A request to wait for a specific tgid.  This is not possible
	 with waitpid, so instead, we wait for any child, and leave
	 children we're not interested in right now with a pending
	 status to report later.  */
      wait_ptid = minus_one_ptid;
    }
  else
    wait_ptid = ptid;

  /* We only enter this loop if no process has a pending wait status.  Thus
     any action taken in response to a wait status inside this loop is
     responding as soon as we detect the status, not after any pending
     events.  */
  while (1)
    {
      event_child = linux_wait_for_lwp (wait_ptid, wstat, options);

      if ((options & WNOHANG) && event_child == NULL)
	{
	  if (debug_threads)
	    fprintf (stderr, "WNOHANG set, no event found\n");
	  return 0;
	}

      if (event_child == NULL)
	error ("event from unknown child");

      if (ptid_is_pid (ptid)
	  && ptid_get_pid (ptid) != ptid_get_pid (ptid_of (event_child)))
	{
	  if (! WIFSTOPPED (*wstat))
	    mark_lwp_dead (event_child, *wstat);
	  else
	    {
	      event_child->status_pending_p = 1;
	      event_child->status_pending = *wstat;
	    }
	  continue;
	}

      current_inferior = get_lwp_thread (event_child);

      /* Check for thread exit.  */
      if (! WIFSTOPPED (*wstat))
	{
	  if (debug_threads)
	    fprintf (stderr, "LWP %ld exiting\n", lwpid_of (event_child));

	  /* If the last thread is exiting, just return.  */
	  if (last_thread_of_process_p (current_inferior))
	    {
	      if (debug_threads)
		fprintf (stderr, "LWP %ld is last lwp of process\n",
			 lwpid_of (event_child));
	      return lwpid_of (event_child);
	    }

	  if (!non_stop)
	    {
	      current_inferior = (struct thread_info *) all_threads.head;
	      if (debug_threads)
		fprintf (stderr, "Current inferior is now %ld\n",
			 lwpid_of (get_thread_lwp (current_inferior)));
	    }
	  else
	    {
	      current_inferior = NULL;
	      if (debug_threads)
		fprintf (stderr, "Current inferior is now <NULL>\n");
	    }

	  /* If we were waiting for this particular child to do something...
	     well, it did something.  */
	  if (requested_child != NULL)
	    {
	      int lwpid = lwpid_of (event_child);

	      /* Cancel the step-over operation --- the thread that
		 started it is gone.  */
	      if (finish_step_over (event_child))
		unstop_all_lwps (1, event_child);
	      delete_lwp (event_child);
	      return lwpid;
	    }

	  delete_lwp (event_child);

	  /* Wait for a more interesting event.  */
	  continue;
	}

      if (event_child->must_set_ptrace_flags)
	{
	  linux_enable_event_reporting (lwpid_of (event_child));
	  event_child->must_set_ptrace_flags = 0;
	}

      if (WIFSTOPPED (*wstat) && WSTOPSIG (*wstat) == SIGTRAP
	  && *wstat >> 16 != 0)
	{
	  handle_extended_wait (event_child, *wstat);
	  continue;
	}

      if (WIFSTOPPED (*wstat)
	  && WSTOPSIG (*wstat) == SIGSTOP
	  && event_child->stop_expected)
	{
	  int should_stop;

	  if (debug_threads)
	    fprintf (stderr, "Expected stop.\n");
	  event_child->stop_expected = 0;

	  should_stop = (current_inferior->last_resume_kind == resume_stop
			 || stopping_threads != NOT_STOPPING_THREADS);

	  if (!should_stop)
	    {
	      linux_resume_one_lwp (event_child,
				    event_child->stepping, 0, NULL);
	      continue;
	    }
	}

      return lwpid_of (event_child);
    }

  /* NOTREACHED */
  return 0;
}

/* Count the LWP's that have had events.  */

static int
count_events_callback (struct inferior_list_entry *entry, void *data)
{
  struct lwp_info *lp = (struct lwp_info *) entry;
  struct thread_info *thread = get_lwp_thread (lp);
  int *count = data;

  gdb_assert (count != NULL);

  /* Count only resumed LWPs that have a SIGTRAP event pending that
     should be reported to GDB.  */
  if (thread->last_status.kind == TARGET_WAITKIND_IGNORE
      && thread->last_resume_kind != resume_stop
      && lp->status_pending_p
      && WIFSTOPPED (lp->status_pending)
      && WSTOPSIG (lp->status_pending) == SIGTRAP
      && !breakpoint_inserted_here (lp->stop_pc))
    (*count)++;

  return 0;
}

/* Select the LWP (if any) that is currently being single-stepped.  */

static int
select_singlestep_lwp_callback (struct inferior_list_entry *entry, void *data)
{
  struct lwp_info *lp = (struct lwp_info *) entry;
  struct thread_info *thread = get_lwp_thread (lp);

  if (thread->last_status.kind == TARGET_WAITKIND_IGNORE
      && thread->last_resume_kind == resume_step
      && lp->status_pending_p)
    return 1;
  else
    return 0;
}

/* Select the Nth LWP that has had a SIGTRAP event that should be
   reported to GDB.  */

static int
select_event_lwp_callback (struct inferior_list_entry *entry, void *data)
{
  struct lwp_info *lp = (struct lwp_info *) entry;
  struct thread_info *thread = get_lwp_thread (lp);
  int *selector = data;

  gdb_assert (selector != NULL);

  /* Select only resumed LWPs that have a SIGTRAP event pending. */
  if (thread->last_resume_kind != resume_stop
      && thread->last_status.kind == TARGET_WAITKIND_IGNORE
      && lp->status_pending_p
      && WIFSTOPPED (lp->status_pending)
      && WSTOPSIG (lp->status_pending) == SIGTRAP
      && !breakpoint_inserted_here (lp->stop_pc))
    if ((*selector)-- == 0)
      return 1;

  return 0;
}

static int
cancel_breakpoints_callback (struct inferior_list_entry *entry, void *data)
{
  struct lwp_info *lp = (struct lwp_info *) entry;
  struct thread_info *thread = get_lwp_thread (lp);
  struct lwp_info *event_lp = data;

  /* Leave the LWP that has been elected to receive a SIGTRAP alone.  */
  if (lp == event_lp)
    return 0;

  /* If a LWP other than the LWP that we're reporting an event for has
     hit a GDB breakpoint (as opposed to some random trap signal),
     then just arrange for it to hit it again later.  We don't keep
     the SIGTRAP status and don't forward the SIGTRAP signal to the
     LWP.  We will handle the current event, eventually we will resume
     all LWPs, and this one will get its breakpoint trap again.

     If we do not do this, then we run the risk that the user will
     delete or disable the breakpoint, but the LWP will have already
     tripped on it.  */

  if (thread->last_resume_kind != resume_stop
      && thread->last_status.kind == TARGET_WAITKIND_IGNORE
      && lp->status_pending_p
      && WIFSTOPPED (lp->status_pending)
      && WSTOPSIG (lp->status_pending) == SIGTRAP
      && !lp->stepping
      && !lp->stopped_by_watchpoint
      && cancel_breakpoint (lp))
    /* Throw away the SIGTRAP.  */
    lp->status_pending_p = 0;

  return 0;
}

static void
linux_cancel_breakpoints (void)
{
  find_inferior (&all_lwps, cancel_breakpoints_callback, NULL);
}

/* Select one LWP out of those that have events pending.  */

static void
select_event_lwp (struct lwp_info **orig_lp)
{
  int num_events = 0;
  int random_selector;
  struct lwp_info *event_lp;

  /* Give preference to any LWP that is being single-stepped.  */
  event_lp
    = (struct lwp_info *) find_inferior (&all_lwps,
					 select_singlestep_lwp_callback, NULL);
  if (event_lp != NULL)
    {
      if (debug_threads)
	fprintf (stderr,
		 "SEL: Select single-step %s\n",
		 target_pid_to_str (ptid_of (event_lp)));
    }
  else
    {
      /* No single-stepping LWP.  Select one at random, out of those
         which have had SIGTRAP events.  */

      /* First see how many SIGTRAP events we have.  */
      find_inferior (&all_lwps, count_events_callback, &num_events);

      /* Now randomly pick a LWP out of those that have had a SIGTRAP.  */
      random_selector = (int)
	((num_events * (double) rand ()) / (RAND_MAX + 1.0));

      if (debug_threads && num_events > 1)
	fprintf (stderr,
		 "SEL: Found %d SIGTRAP events, selecting #%d\n",
		 num_events, random_selector);

      event_lp = (struct lwp_info *) find_inferior (&all_lwps,
						    select_event_lwp_callback,
						    &random_selector);
    }

  if (event_lp != NULL)
    {
      /* Switch the event LWP.  */
      *orig_lp = event_lp;
    }
}

/* Decrement the suspend count of an LWP.  */

static int
unsuspend_one_lwp (struct inferior_list_entry *entry, void *except)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;

  /* Ignore EXCEPT.  */
  if (lwp == except)
    return 0;

  lwp->suspended--;

  gdb_assert (lwp->suspended >= 0);
  return 0;
}

/* Decrement the suspend count of all LWPs, except EXCEPT, if non
   NULL.  */

static void
unsuspend_all_lwps (struct lwp_info *except)
{
  find_inferior (&all_lwps, unsuspend_one_lwp, except);
}

static void move_out_of_jump_pad_callback (struct inferior_list_entry *entry);
static int stuck_in_jump_pad_callback (struct inferior_list_entry *entry,
				       void *data);
static int lwp_running (struct inferior_list_entry *entry, void *data);
static ptid_t linux_wait_1 (ptid_t ptid,
			    struct target_waitstatus *ourstatus,
			    int target_options);

/* Stabilize threads (move out of jump pads).

   If a thread is midway collecting a fast tracepoint, we need to
   finish the collection and move it out of the jump pad before
   reporting the signal.

   This avoids recursion while collecting (when a signal arrives
   midway, and the signal handler itself collects), which would trash
   the trace buffer.  In case the user set a breakpoint in a signal
   handler, this avoids the backtrace showing the jump pad, etc..
   Most importantly, there are certain things we can't do safely if
   threads are stopped in a jump pad (or in its callee's).  For
   example:

     - starting a new trace run.  A thread still collecting the
   previous run, could trash the trace buffer when resumed.  The trace
   buffer control structures would have been reset but the thread had
   no way to tell.  The thread could even midway memcpy'ing to the
   buffer, which would mean that when resumed, it would clobber the
   trace buffer that had been set for a new run.

     - we can't rewrite/reuse the jump pads for new tracepoints
   safely.  Say you do tstart while a thread is stopped midway while
   collecting.  When the thread is later resumed, it finishes the
   collection, and returns to the jump pad, to execute the original
   instruction that was under the tracepoint jump at the time the
   older run had been started.  If the jump pad had been rewritten
   since for something else in the new run, the thread would now
   execute the wrong / random instructions.  */

static void
linux_stabilize_threads (void)
{
  struct thread_info *save_inferior;
  struct lwp_info *lwp_stuck;

  lwp_stuck
    = (struct lwp_info *) find_inferior (&all_lwps,
					 stuck_in_jump_pad_callback, NULL);
  if (lwp_stuck != NULL)
    {
      if (debug_threads)
	fprintf (stderr, "can't stabilize, LWP %ld is stuck in jump pad\n",
		 lwpid_of (lwp_stuck));
      return;
    }

  save_inferior = current_inferior;

  stabilizing_threads = 1;

  /* Kick 'em all.  */
  for_each_inferior (&all_lwps, move_out_of_jump_pad_callback);

  /* Loop until all are stopped out of the jump pads.  */
  while (find_inferior (&all_lwps, lwp_running, NULL) != NULL)
    {
      struct target_waitstatus ourstatus;
      struct lwp_info *lwp;
      int wstat;

      /* Note that we go through the full wait even loop.  While
	 moving threads out of jump pad, we need to be able to step
	 over internal breakpoints and such.  */
      linux_wait_1 (minus_one_ptid, &ourstatus, 0);

      if (ourstatus.kind == TARGET_WAITKIND_STOPPED)
	{
	  lwp = get_thread_lwp (current_inferior);

	  /* Lock it.  */
	  lwp->suspended++;

	  if (ourstatus.value.sig != GDB_SIGNAL_0
	      || current_inferior->last_resume_kind == resume_stop)
	    {
	      wstat = W_STOPCODE (gdb_signal_to_host (ourstatus.value.sig));
	      enqueue_one_deferred_signal (lwp, &wstat);
	    }
	}
    }

  find_inferior (&all_lwps, unsuspend_one_lwp, NULL);

  stabilizing_threads = 0;

  current_inferior = save_inferior;

  if (debug_threads)
    {
      lwp_stuck
	= (struct lwp_info *) find_inferior (&all_lwps,
					 stuck_in_jump_pad_callback, NULL);
      if (lwp_stuck != NULL)
	fprintf (stderr, "couldn't stabilize, LWP %ld got stuck in jump pad\n",
		 lwpid_of (lwp_stuck));
    }
}

/* Wait for process, returns status.  */

static ptid_t
linux_wait_1 (ptid_t ptid,
	      struct target_waitstatus *ourstatus, int target_options)
{
  int w;
  struct lwp_info *event_child;
  int options;
  int pid;
  int step_over_finished;
  int bp_explains_trap;
  int maybe_internal_trap;
  int report_to_gdb;
  int trace_event;
  int in_step_range;

  /* Translate generic target options into linux options.  */
  options = __WALL;
  if (target_options & TARGET_WNOHANG)
    options |= WNOHANG;

retry:
  bp_explains_trap = 0;
  trace_event = 0;
  in_step_range = 0;
  ourstatus->kind = TARGET_WAITKIND_IGNORE;

  /* If we were only supposed to resume one thread, only wait for
     that thread - if it's still alive.  If it died, however - which
     can happen if we're coming from the thread death case below -
     then we need to make sure we restart the other threads.  We could
     pick a thread at random or restart all; restarting all is less
     arbitrary.  */
  if (!non_stop
      && !ptid_equal (cont_thread, null_ptid)
      && !ptid_equal (cont_thread, minus_one_ptid))
    {
      struct thread_info *thread;

      thread = (struct thread_info *) find_inferior_id (&all_threads,
							cont_thread);

      /* No stepping, no signal - unless one is pending already, of course.  */
      if (thread == NULL)
	{
	  struct thread_resume resume_info;
	  resume_info.thread = minus_one_ptid;
	  resume_info.kind = resume_continue;
	  resume_info.sig = 0;
	  linux_resume (&resume_info, 1);
	}
      else
	ptid = cont_thread;
    }

  if (ptid_equal (step_over_bkpt, null_ptid))
    pid = linux_wait_for_event (ptid, &w, options);
  else
    {
      if (debug_threads)
	fprintf (stderr, "step_over_bkpt set [%s], doing a blocking wait\n",
		 target_pid_to_str (step_over_bkpt));
      pid = linux_wait_for_event (step_over_bkpt, &w, options & ~WNOHANG);
    }

  if (pid == 0) /* only if TARGET_WNOHANG */
    return null_ptid;

  event_child = get_thread_lwp (current_inferior);

  /* If we are waiting for a particular child, and it exited,
     linux_wait_for_event will return its exit status.  Similarly if
     the last child exited.  If this is not the last child, however,
     do not report it as exited until there is a 'thread exited' response
     available in the remote protocol.  Instead, just wait for another event.
     This should be safe, because if the thread crashed we will already
     have reported the termination signal to GDB; that should stop any
     in-progress stepping operations, etc.

     Report the exit status of the last thread to exit.  This matches
     LinuxThreads' behavior.  */

  if (last_thread_of_process_p (current_inferior))
    {
      if (WIFEXITED (w) || WIFSIGNALED (w))
	{
	  if (WIFEXITED (w))
	    {
	      ourstatus->kind = TARGET_WAITKIND_EXITED;
	      ourstatus->value.integer = WEXITSTATUS (w);

	      if (debug_threads)
		fprintf (stderr,
			 "\nChild exited with retcode = %x \n",
			 WEXITSTATUS (w));
	    }
	  else
	    {
	      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	      ourstatus->value.sig = gdb_signal_from_host (WTERMSIG (w));

	      if (debug_threads)
		fprintf (stderr,
			 "\nChild terminated with signal = %x \n",
			 WTERMSIG (w));

	    }

	  return ptid_of (event_child);
	}
    }
  else
    {
      if (!WIFSTOPPED (w))
	goto retry;
    }

  /* If this event was not handled before, and is not a SIGTRAP, we
     report it.  SIGILL and SIGSEGV are also treated as traps in case
     a breakpoint is inserted at the current PC.  If this target does
     not support internal breakpoints at all, we also report the
     SIGTRAP without further processing; it's of no concern to us.  */
  maybe_internal_trap
    = (supports_breakpoints ()
       && (WSTOPSIG (w) == SIGTRAP
	   || ((WSTOPSIG (w) == SIGILL
		|| WSTOPSIG (w) == SIGSEGV)
	       && (*the_low_target.breakpoint_at) (event_child->stop_pc))));

  if (maybe_internal_trap)
    {
      /* Handle anything that requires bookkeeping before deciding to
	 report the event or continue waiting.  */

      /* First check if we can explain the SIGTRAP with an internal
	 breakpoint, or if we should possibly report the event to GDB.
	 Do this before anything that may remove or insert a
	 breakpoint.  */
      bp_explains_trap = breakpoint_inserted_here (event_child->stop_pc);

      /* We have a SIGTRAP, possibly a step-over dance has just
	 finished.  If so, tweak the state machine accordingly,
	 reinsert breakpoints and delete any reinsert (software
	 single-step) breakpoints.  */
      step_over_finished = finish_step_over (event_child);

      /* Now invoke the callbacks of any internal breakpoints there.  */
      check_breakpoints (event_child->stop_pc);

      /* Handle tracepoint data collecting.  This may overflow the
	 trace buffer, and cause a tracing stop, removing
	 breakpoints.  */
      trace_event = handle_tracepoints (event_child);

      if (bp_explains_trap)
	{
	  /* If we stepped or ran into an internal breakpoint, we've
	     already handled it.  So next time we resume (from this
	     PC), we should step over it.  */
	  if (debug_threads)
	    fprintf (stderr, "Hit a gdbserver breakpoint.\n");

	  if (breakpoint_here (event_child->stop_pc))
	    event_child->need_step_over = 1;
	}
    }
  else
    {
      /* We have some other signal, possibly a step-over dance was in
	 progress, and it should be cancelled too.  */
      step_over_finished = finish_step_over (event_child);
    }

  /* We have all the data we need.  Either report the event to GDB, or
     resume threads and keep waiting for more.  */

  /* If we're collecting a fast tracepoint, finish the collection and
     move out of the jump pad before delivering a signal.  See
     linux_stabilize_threads.  */

  if (WIFSTOPPED (w)
      && WSTOPSIG (w) != SIGTRAP
      && supports_fast_tracepoints ()
      && agent_loaded_p ())
    {
      if (debug_threads)
	fprintf (stderr,
		 "Got signal %d for LWP %ld.  Check if we need "
		 "to defer or adjust it.\n",
		 WSTOPSIG (w), lwpid_of (event_child));

      /* Allow debugging the jump pad itself.  */
      if (current_inferior->last_resume_kind != resume_step
	  && maybe_move_out_of_jump_pad (event_child, &w))
	{
	  enqueue_one_deferred_signal (event_child, &w);

	  if (debug_threads)
	    fprintf (stderr,
		     "Signal %d for LWP %ld deferred (in jump pad)\n",
		     WSTOPSIG (w), lwpid_of (event_child));

	  linux_resume_one_lwp (event_child, 0, 0, NULL);
	  goto retry;
	}
    }

  if (event_child->collecting_fast_tracepoint)
    {
      if (debug_threads)
	fprintf (stderr, "\
LWP %ld was trying to move out of the jump pad (%d).  \
Check if we're already there.\n",
		 lwpid_of (event_child),
		 event_child->collecting_fast_tracepoint);

      trace_event = 1;

      event_child->collecting_fast_tracepoint
	= linux_fast_tracepoint_collecting (event_child, NULL);

      if (event_child->collecting_fast_tracepoint != 1)
	{
	  /* No longer need this breakpoint.  */
	  if (event_child->exit_jump_pad_bkpt != NULL)
	    {
	      if (debug_threads)
		fprintf (stderr,
			 "No longer need exit-jump-pad bkpt; removing it."
			 "stopping all threads momentarily.\n");

	      /* Other running threads could hit this breakpoint.
		 We don't handle moribund locations like GDB does,
		 instead we always pause all threads when removing
		 breakpoints, so that any step-over or
		 decr_pc_after_break adjustment is always taken
		 care of while the breakpoint is still
		 inserted.  */
	      stop_all_lwps (1, event_child);
	      cancel_breakpoints ();

	      delete_breakpoint (event_child->exit_jump_pad_bkpt);
	      event_child->exit_jump_pad_bkpt = NULL;

	      unstop_all_lwps (1, event_child);

	      gdb_assert (event_child->suspended >= 0);
	    }
	}

      if (event_child->collecting_fast_tracepoint == 0)
	{
	  if (debug_threads)
	    fprintf (stderr,
		     "fast tracepoint finished "
		     "collecting successfully.\n");

	  /* We may have a deferred signal to report.  */
	  if (dequeue_one_deferred_signal (event_child, &w))
	    {
	      if (debug_threads)
		fprintf (stderr, "dequeued one signal.\n");
	    }
	  else
	    {
	      if (debug_threads)
		fprintf (stderr, "no deferred signals.\n");

	      if (stabilizing_threads)
		{
		  ourstatus->kind = TARGET_WAITKIND_STOPPED;
		  ourstatus->value.sig = GDB_SIGNAL_0;
		  return ptid_of (event_child);
		}
	    }
	}
    }

  /* Check whether GDB would be interested in this event.  */

  /* If GDB is not interested in this signal, don't stop other
     threads, and don't report it to GDB.  Just resume the inferior
     right away.  We do this for threading-related signals as well as
     any that GDB specifically requested we ignore.  But never ignore
     SIGSTOP if we sent it ourselves, and do not ignore signals when
     stepping - they may require special handling to skip the signal
     handler.  */
  /* FIXME drow/2002-06-09: Get signal numbers from the inferior's
     thread library?  */
  if (WIFSTOPPED (w)
      && current_inferior->last_resume_kind != resume_step
      && (
#if defined (USE_THREAD_DB) && !defined (__ANDROID__)
	  (current_process ()->private->thread_db != NULL
	   && (WSTOPSIG (w) == __SIGRTMIN
	       || WSTOPSIG (w) == __SIGRTMIN + 1))
	  ||
#endif
	  (pass_signals[gdb_signal_from_host (WSTOPSIG (w))]
	   && !(WSTOPSIG (w) == SIGSTOP
		&& current_inferior->last_resume_kind == resume_stop))))
    {
      siginfo_t info, *info_p;

      if (debug_threads)
	fprintf (stderr, "Ignored signal %d for LWP %ld.\n",
		 WSTOPSIG (w), lwpid_of (event_child));

      if (ptrace (PTRACE_GETSIGINFO, lwpid_of (event_child),
		  (PTRACE_TYPE_ARG3) 0, &info) == 0)
	info_p = &info;
      else
	info_p = NULL;
      linux_resume_one_lwp (event_child, event_child->stepping,
			    WSTOPSIG (w), info_p);
      goto retry;
    }

  /* Note that all addresses are always "out of the step range" when
     there's no range to begin with.  */
  in_step_range = lwp_in_step_range (event_child);

  /* If GDB wanted this thread to single step, and the thread is out
     of the step range, we always want to report the SIGTRAP, and let
     GDB handle it.  Watchpoints should always be reported.  So should
     signals we can't explain.  A SIGTRAP we can't explain could be a
     GDB breakpoint --- we may or not support Z0 breakpoints.  If we
     do, we're be able to handle GDB breakpoints on top of internal
     breakpoints, by handling the internal breakpoint and still
     reporting the event to GDB.  If we don't, we're out of luck, GDB
     won't see the breakpoint hit.  */
  report_to_gdb = (!maybe_internal_trap
		   || (current_inferior->last_resume_kind == resume_step
		       && !in_step_range)
		   || event_child->stopped_by_watchpoint
		   || (!step_over_finished && !in_step_range
		       && !bp_explains_trap && !trace_event)
		   || (gdb_breakpoint_here (event_child->stop_pc)
		       && gdb_condition_true_at_breakpoint (event_child->stop_pc)
		       && gdb_no_commands_at_breakpoint (event_child->stop_pc)));

  run_breakpoint_commands (event_child->stop_pc);

  /* We found no reason GDB would want us to stop.  We either hit one
     of our own breakpoints, or finished an internal step GDB
     shouldn't know about.  */
  if (!report_to_gdb)
    {
      if (debug_threads)
	{
	  if (bp_explains_trap)
	    fprintf (stderr, "Hit a gdbserver breakpoint.\n");
	  if (step_over_finished)
	    fprintf (stderr, "Step-over finished.\n");
	  if (trace_event)
	    fprintf (stderr, "Tracepoint event.\n");
	  if (lwp_in_step_range (event_child))
	    fprintf (stderr, "Range stepping pc 0x%s [0x%s, 0x%s).\n",
		     paddress (event_child->stop_pc),
		     paddress (event_child->step_range_start),
		     paddress (event_child->step_range_end));
	}

      /* We're not reporting this breakpoint to GDB, so apply the
	 decr_pc_after_break adjustment to the inferior's regcache
	 ourselves.  */

      if (the_low_target.set_pc != NULL)
	{
	  struct regcache *regcache
	    = get_thread_regcache (get_lwp_thread (event_child), 1);
	  (*the_low_target.set_pc) (regcache, event_child->stop_pc);
	}

      /* We may have finished stepping over a breakpoint.  If so,
	 we've stopped and suspended all LWPs momentarily except the
	 stepping one.  This is where we resume them all again.  We're
	 going to keep waiting, so use proceed, which handles stepping
	 over the next breakpoint.  */
      if (debug_threads)
	fprintf (stderr, "proceeding all threads.\n");

      if (step_over_finished)
	unsuspend_all_lwps (event_child);

      proceed_all_lwps ();
      goto retry;
    }

  if (debug_threads)
    {
      if (current_inferior->last_resume_kind == resume_step)
	{
	  if (event_child->step_range_start == event_child->step_range_end)
	    fprintf (stderr, "GDB wanted to single-step, reporting event.\n");
	  else if (!lwp_in_step_range (event_child))
	    fprintf (stderr, "Out of step range, reporting event.\n");
	}
      if (event_child->stopped_by_watchpoint)
	fprintf (stderr, "Stopped by watchpoint.\n");
      if (gdb_breakpoint_here (event_child->stop_pc))
	fprintf (stderr, "Stopped by GDB breakpoint.\n");
      if (debug_threads)
	fprintf (stderr, "Hit a non-gdbserver trap event.\n");
    }

  /* Alright, we're going to report a stop.  */

  if (!non_stop && !stabilizing_threads)
    {
      /* In all-stop, stop all threads.  */
      stop_all_lwps (0, NULL);

      /* If we're not waiting for a specific LWP, choose an event LWP
	 from among those that have had events.  Giving equal priority
	 to all LWPs that have had events helps prevent
	 starvation.  */
      if (ptid_equal (ptid, minus_one_ptid))
	{
	  event_child->status_pending_p = 1;
	  event_child->status_pending = w;

	  select_event_lwp (&event_child);

	  event_child->status_pending_p = 0;
	  w = event_child->status_pending;
	}

      /* Now that we've selected our final event LWP, cancel any
	 breakpoints in other LWPs that have hit a GDB breakpoint.
	 See the comment in cancel_breakpoints_callback to find out
	 why.  */
      find_inferior (&all_lwps, cancel_breakpoints_callback, event_child);

      /* If we were going a step-over, all other threads but the stepping one
	 had been paused in start_step_over, with their suspend counts
	 incremented.  We don't want to do a full unstop/unpause, because we're
	 in all-stop mode (so we want threads stopped), but we still need to
	 unsuspend the other threads, to decrement their `suspended' count
	 back.  */
      if (step_over_finished)
	unsuspend_all_lwps (event_child);

      /* Stabilize threads (move out of jump pads).  */
      stabilize_threads ();
    }
  else
    {
      /* If we just finished a step-over, then all threads had been
	 momentarily paused.  In all-stop, that's fine, we want
	 threads stopped by now anyway.  In non-stop, we need to
	 re-resume threads that GDB wanted to be running.  */
      if (step_over_finished)
	unstop_all_lwps (1, event_child);
    }

  ourstatus->kind = TARGET_WAITKIND_STOPPED;

  if (current_inferior->last_resume_kind == resume_stop
      && WSTOPSIG (w) == SIGSTOP)
    {
      /* A thread that has been requested to stop by GDB with vCont;t,
	 and it stopped cleanly, so report as SIG0.  The use of
	 SIGSTOP is an implementation detail.  */
      ourstatus->value.sig = GDB_SIGNAL_0;
    }
  else if (current_inferior->last_resume_kind == resume_stop
	   && WSTOPSIG (w) != SIGSTOP)
    {
      /* A thread that has been requested to stop by GDB with vCont;t,
	 but, it stopped for other reasons.  */
      ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (w));
    }
  else
    {
      ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (w));
    }

  gdb_assert (ptid_equal (step_over_bkpt, null_ptid));

  if (debug_threads)
    fprintf (stderr, "linux_wait ret = %s, %d, %d\n",
	     target_pid_to_str (ptid_of (event_child)),
	     ourstatus->kind,
	     ourstatus->value.sig);

  return ptid_of (event_child);
}

/* Get rid of any pending event in the pipe.  */
static void
async_file_flush (void)
{
  int ret;
  char buf;

  do
    ret = read (linux_event_pipe[0], &buf, 1);
  while (ret >= 0 || (ret == -1 && errno == EINTR));
}

/* Put something in the pipe, so the event loop wakes up.  */
static void
async_file_mark (void)
{
  int ret;

  async_file_flush ();

  do
    ret = write (linux_event_pipe[1], "+", 1);
  while (ret == 0 || (ret == -1 && errno == EINTR));

  /* Ignore EAGAIN.  If the pipe is full, the event loop will already
     be awakened anyway.  */
}

static ptid_t
linux_wait (ptid_t ptid,
	    struct target_waitstatus *ourstatus, int target_options)
{
  ptid_t event_ptid;

  if (debug_threads)
    fprintf (stderr, "linux_wait: [%s]\n", target_pid_to_str (ptid));

  /* Flush the async file first.  */
  if (target_is_async_p ())
    async_file_flush ();

  event_ptid = linux_wait_1 (ptid, ourstatus, target_options);

  /* If at least one stop was reported, there may be more.  A single
     SIGCHLD can signal more than one child stop.  */
  if (target_is_async_p ()
      && (target_options & TARGET_WNOHANG) != 0
      && !ptid_equal (event_ptid, null_ptid))
    async_file_mark ();

  return event_ptid;
}

/* Send a signal to an LWP.  */

static int
kill_lwp (unsigned long lwpid, int signo)
{
  /* Use tkill, if possible, in case we are using nptl threads.  If tkill
     fails, then we are not using nptl threads and we should be using kill.  */

#ifdef __NR_tkill
  {
    static int tkill_failed;

    if (!tkill_failed)
      {
	int ret;

	errno = 0;
	ret = syscall (__NR_tkill, lwpid, signo);
	if (errno != ENOSYS)
	  return ret;
	tkill_failed = 1;
      }
  }
#endif

  return kill (lwpid, signo);
}

void
linux_stop_lwp (struct lwp_info *lwp)
{
  send_sigstop (lwp);
}

static void
send_sigstop (struct lwp_info *lwp)
{
  int pid;

  pid = lwpid_of (lwp);

  /* If we already have a pending stop signal for this process, don't
     send another.  */
  if (lwp->stop_expected)
    {
      if (debug_threads)
	fprintf (stderr, "Have pending sigstop for lwp %d\n", pid);

      return;
    }

  if (debug_threads)
    fprintf (stderr, "Sending sigstop to lwp %d\n", pid);

  lwp->stop_expected = 1;
  kill_lwp (pid, SIGSTOP);
}

static int
send_sigstop_callback (struct inferior_list_entry *entry, void *except)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;

  /* Ignore EXCEPT.  */
  if (lwp == except)
    return 0;

  if (lwp->stopped)
    return 0;

  send_sigstop (lwp);
  return 0;
}

/* Increment the suspend count of an LWP, and stop it, if not stopped
   yet.  */
static int
suspend_and_send_sigstop_callback (struct inferior_list_entry *entry,
				   void *except)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;

  /* Ignore EXCEPT.  */
  if (lwp == except)
    return 0;

  lwp->suspended++;

  return send_sigstop_callback (entry, except);
}

static void
mark_lwp_dead (struct lwp_info *lwp, int wstat)
{
  /* It's dead, really.  */
  lwp->dead = 1;

  /* Store the exit status for later.  */
  lwp->status_pending_p = 1;
  lwp->status_pending = wstat;

  /* Prevent trying to stop it.  */
  lwp->stopped = 1;

  /* No further stops are expected from a dead lwp.  */
  lwp->stop_expected = 0;
}

static void
wait_for_sigstop (struct inferior_list_entry *entry)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *saved_inferior;
  int wstat;
  ptid_t saved_tid;
  ptid_t ptid;
  int pid;

  if (lwp->stopped)
    {
      if (debug_threads)
	fprintf (stderr, "wait_for_sigstop: LWP %ld already stopped\n",
		 lwpid_of (lwp));
      return;
    }

  saved_inferior = current_inferior;
  if (saved_inferior != NULL)
    saved_tid = ((struct inferior_list_entry *) saved_inferior)->id;
  else
    saved_tid = null_ptid; /* avoid bogus unused warning */

  ptid = lwp->head.id;

  if (debug_threads)
    fprintf (stderr, "wait_for_sigstop: pulling one event\n");

  pid = linux_wait_for_event (ptid, &wstat, __WALL);

  /* If we stopped with a non-SIGSTOP signal, save it for later
     and record the pending SIGSTOP.  If the process exited, just
     return.  */
  if (WIFSTOPPED (wstat))
    {
      if (debug_threads)
	fprintf (stderr, "LWP %ld stopped with signal %d\n",
		 lwpid_of (lwp), WSTOPSIG (wstat));

      if (WSTOPSIG (wstat) != SIGSTOP)
	{
	  if (debug_threads)
	    fprintf (stderr, "LWP %ld stopped with non-sigstop status %06x\n",
		     lwpid_of (lwp), wstat);

	  lwp->status_pending_p = 1;
	  lwp->status_pending = wstat;
	}
    }
  else
    {
      if (debug_threads)
	fprintf (stderr, "Process %d exited while stopping LWPs\n", pid);

      lwp = find_lwp_pid (pid_to_ptid (pid));
      if (lwp)
	{
	  /* Leave this status pending for the next time we're able to
	     report it.  In the mean time, we'll report this lwp as
	     dead to GDB, so GDB doesn't try to read registers and
	     memory from it.  This can only happen if this was the
	     last thread of the process; otherwise, PID is removed
	     from the thread tables before linux_wait_for_event
	     returns.  */
	  mark_lwp_dead (lwp, wstat);
	}
    }

  if (saved_inferior == NULL || linux_thread_alive (saved_tid))
    current_inferior = saved_inferior;
  else
    {
      if (debug_threads)
	fprintf (stderr, "Previously current thread died.\n");

      if (non_stop)
	{
	  /* We can't change the current inferior behind GDB's back,
	     otherwise, a subsequent command may apply to the wrong
	     process.  */
	  current_inferior = NULL;
	}
      else
	{
	  /* Set a valid thread as current.  */
	  set_desired_inferior (0);
	}
    }
}

/* Returns true if LWP ENTRY is stopped in a jump pad, and we can't
   move it out, because we need to report the stop event to GDB.  For
   example, if the user puts a breakpoint in the jump pad, it's
   because she wants to debug it.  */

static int
stuck_in_jump_pad_callback (struct inferior_list_entry *entry, void *data)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *thread = get_lwp_thread (lwp);

  gdb_assert (lwp->suspended == 0);
  gdb_assert (lwp->stopped);

  /* Allow debugging the jump pad, gdb_collect, etc..  */
  return (supports_fast_tracepoints ()
	  && agent_loaded_p ()
	  && (gdb_breakpoint_here (lwp->stop_pc)
	      || lwp->stopped_by_watchpoint
	      || thread->last_resume_kind == resume_step)
	  && linux_fast_tracepoint_collecting (lwp, NULL));
}

static void
move_out_of_jump_pad_callback (struct inferior_list_entry *entry)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *thread = get_lwp_thread (lwp);
  int *wstat;

  gdb_assert (lwp->suspended == 0);
  gdb_assert (lwp->stopped);

  wstat = lwp->status_pending_p ? &lwp->status_pending : NULL;

  /* Allow debugging the jump pad, gdb_collect, etc.  */
  if (!gdb_breakpoint_here (lwp->stop_pc)
      && !lwp->stopped_by_watchpoint
      && thread->last_resume_kind != resume_step
      && maybe_move_out_of_jump_pad (lwp, wstat))
    {
      if (debug_threads)
	fprintf (stderr,
		 "LWP %ld needs stabilizing (in jump pad)\n",
		 lwpid_of (lwp));

      if (wstat)
	{
	  lwp->status_pending_p = 0;
	  enqueue_one_deferred_signal (lwp, wstat);

	  if (debug_threads)
	    fprintf (stderr,
		     "Signal %d for LWP %ld deferred "
		     "(in jump pad)\n",
		     WSTOPSIG (*wstat), lwpid_of (lwp));
	}

      linux_resume_one_lwp (lwp, 0, 0, NULL);
    }
  else
    lwp->suspended++;
}

static int
lwp_running (struct inferior_list_entry *entry, void *data)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;

  if (lwp->dead)
    return 0;
  if (lwp->stopped)
    return 0;
  return 1;
}

/* Stop all lwps that aren't stopped yet, except EXCEPT, if not NULL.
   If SUSPEND, then also increase the suspend count of every LWP,
   except EXCEPT.  */

static void
stop_all_lwps (int suspend, struct lwp_info *except)
{
  /* Should not be called recursively.  */
  gdb_assert (stopping_threads == NOT_STOPPING_THREADS);

  stopping_threads = (suspend
		      ? STOPPING_AND_SUSPENDING_THREADS
		      : STOPPING_THREADS);

  if (suspend)
    find_inferior (&all_lwps, suspend_and_send_sigstop_callback, except);
  else
    find_inferior (&all_lwps, send_sigstop_callback, except);
  for_each_inferior (&all_lwps, wait_for_sigstop);
  stopping_threads = NOT_STOPPING_THREADS;
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

static void
linux_resume_one_lwp (struct lwp_info *lwp,
		      int step, int signal, siginfo_t *info)
{
  struct thread_info *saved_inferior;
  int fast_tp_collecting;

  if (lwp->stopped == 0)
    return;

  fast_tp_collecting = lwp->collecting_fast_tracepoint;

  gdb_assert (!stabilizing_threads || fast_tp_collecting);

  /* Cancel actions that rely on GDB not changing the PC (e.g., the
     user used the "jump" command, or "set $pc = foo").  */
  if (lwp->stop_pc != get_pc (lwp))
    {
      /* Collecting 'while-stepping' actions doesn't make sense
	 anymore.  */
      release_while_stepping_state_list (get_lwp_thread (lwp));
    }

  /* If we have pending signals or status, and a new signal, enqueue the
     signal.  Also enqueue the signal if we are waiting to reinsert a
     breakpoint; it will be picked up again below.  */
  if (signal != 0
      && (lwp->status_pending_p
	  || lwp->pending_signals != NULL
	  || lwp->bp_reinsert != 0
	  || fast_tp_collecting))
    {
      struct pending_signals *p_sig;
      p_sig = xmalloc (sizeof (*p_sig));
      p_sig->prev = lwp->pending_signals;
      p_sig->signal = signal;
      if (info == NULL)
	memset (&p_sig->info, 0, sizeof (siginfo_t));
      else
	memcpy (&p_sig->info, info, sizeof (siginfo_t));
      lwp->pending_signals = p_sig;
    }

  if (lwp->status_pending_p)
    {
      if (debug_threads)
	fprintf (stderr, "Not resuming lwp %ld (%s, signal %d, stop %s);"
		 " has pending status\n",
		 lwpid_of (lwp), step ? "step" : "continue", signal,
		 lwp->stop_expected ? "expected" : "not expected");
      return;
    }

  saved_inferior = current_inferior;
  current_inferior = get_lwp_thread (lwp);

  if (debug_threads)
    fprintf (stderr, "Resuming lwp %ld (%s, signal %d, stop %s)\n",
	     lwpid_of (lwp), step ? "step" : "continue", signal,
	     lwp->stop_expected ? "expected" : "not expected");

  /* This bit needs some thinking about.  If we get a signal that
     we must report while a single-step reinsert is still pending,
     we often end up resuming the thread.  It might be better to
     (ew) allow a stack of pending events; then we could be sure that
     the reinsert happened right away and not lose any signals.

     Making this stack would also shrink the window in which breakpoints are
     uninserted (see comment in linux_wait_for_lwp) but not enough for
     complete correctness, so it won't solve that problem.  It may be
     worthwhile just to solve this one, however.  */
  if (lwp->bp_reinsert != 0)
    {
      if (debug_threads)
	fprintf (stderr, "  pending reinsert at 0x%s\n",
		 paddress (lwp->bp_reinsert));

      if (can_hardware_single_step ())
	{
	  if (fast_tp_collecting == 0)
	    {
	      if (step == 0)
		fprintf (stderr, "BAD - reinserting but not stepping.\n");
	      if (lwp->suspended)
		fprintf (stderr, "BAD - reinserting and suspended(%d).\n",
			 lwp->suspended);
	    }

	  step = 1;
	}

      /* Postpone any pending signal.  It was enqueued above.  */
      signal = 0;
    }

  if (fast_tp_collecting == 1)
    {
      if (debug_threads)
	fprintf (stderr, "\
lwp %ld wants to get out of fast tracepoint jump pad (exit-jump-pad-bkpt)\n",
		 lwpid_of (lwp));

      /* Postpone any pending signal.  It was enqueued above.  */
      signal = 0;
    }
  else if (fast_tp_collecting == 2)
    {
      if (debug_threads)
	fprintf (stderr, "\
lwp %ld wants to get out of fast tracepoint jump pad single-stepping\n",
		 lwpid_of (lwp));

      if (can_hardware_single_step ())
	step = 1;
      else
	fatal ("moving out of jump pad single-stepping"
	       " not implemented on this target");

      /* Postpone any pending signal.  It was enqueued above.  */
      signal = 0;
    }

  /* If we have while-stepping actions in this thread set it stepping.
     If we have a signal to deliver, it may or may not be set to
     SIG_IGN, we don't know.  Assume so, and allow collecting
     while-stepping into a signal handler.  A possible smart thing to
     do would be to set an internal breakpoint at the signal return
     address, continue, and carry on catching this while-stepping
     action only when that breakpoint is hit.  A future
     enhancement.  */
  if (get_lwp_thread (lwp)->while_stepping != NULL
      && can_hardware_single_step ())
    {
      if (debug_threads)
	fprintf (stderr,
		 "lwp %ld has a while-stepping action -> forcing step.\n",
		 lwpid_of (lwp));
      step = 1;
    }

  if (debug_threads && the_low_target.get_pc != NULL)
    {
      struct regcache *regcache = get_thread_regcache (current_inferior, 1);
      CORE_ADDR pc = (*the_low_target.get_pc) (regcache);
      fprintf (stderr, "  resuming from pc 0x%lx\n", (long) pc);
    }

  /* If we have pending signals, consume one unless we are trying to
     reinsert a breakpoint or we're trying to finish a fast tracepoint
     collect.  */
  if (lwp->pending_signals != NULL
      && lwp->bp_reinsert == 0
      && fast_tp_collecting == 0)
    {
      struct pending_signals **p_sig;

      p_sig = &lwp->pending_signals;
      while ((*p_sig)->prev != NULL)
	p_sig = &(*p_sig)->prev;

      signal = (*p_sig)->signal;
      if ((*p_sig)->info.si_signo != 0)
	ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp), (PTRACE_TYPE_ARG3) 0,
		&(*p_sig)->info);

      free (*p_sig);
      *p_sig = NULL;
    }

  if (the_low_target.prepare_to_resume != NULL)
    the_low_target.prepare_to_resume (lwp);

  regcache_invalidate_thread (get_lwp_thread (lwp));
  errno = 0;
  lwp->stopped = 0;
  lwp->stopped_by_watchpoint = 0;
  lwp->stepping = step;
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, lwpid_of (lwp),
	  (PTRACE_TYPE_ARG3) 0,
	  /* Coerce to a uintptr_t first to avoid potential gcc warning
	     of coercing an 8 byte integer to a 4 byte pointer.  */
	  (PTRACE_TYPE_ARG4) (uintptr_t) signal);

  current_inferior = saved_inferior;
  if (errno)
    {
      /* ESRCH from ptrace either means that the thread was already
	 running (an error) or that it is gone (a race condition).  If
	 it's gone, we will get a notification the next time we wait,
	 so we can ignore the error.  We could differentiate these
	 two, but it's tricky without waiting; the thread still exists
	 as a zombie, so sending it signal 0 would succeed.  So just
	 ignore ESRCH.  */
      if (errno == ESRCH)
	return;

      perror_with_name ("ptrace");
    }
}

struct thread_resume_array
{
  struct thread_resume *resume;
  size_t n;
};

/* This function is called once per thread.  We look up the thread
   in RESUME_PTR, and mark the thread with a pointer to the appropriate
   resume request.

   This algorithm is O(threads * resume elements), but resume elements
   is small (and will remain small at least until GDB supports thread
   suspension).  */
static int
linux_set_resume_request (struct inferior_list_entry *entry, void *arg)
{
  struct lwp_info *lwp;
  struct thread_info *thread;
  int ndx;
  struct thread_resume_array *r;

  thread = (struct thread_info *) entry;
  lwp = get_thread_lwp (thread);
  r = arg;

  for (ndx = 0; ndx < r->n; ndx++)
    {
      ptid_t ptid = r->resume[ndx].thread;
      if (ptid_equal (ptid, minus_one_ptid)
	  || ptid_equal (ptid, entry->id)
	  /* Handle both 'pPID' and 'pPID.-1' as meaning 'all threads
	     of PID'.  */
	  || (ptid_get_pid (ptid) == pid_of (lwp)
	      && (ptid_is_pid (ptid)
		  || ptid_get_lwp (ptid) == -1)))
	{
	  if (r->resume[ndx].kind == resume_stop
	      && thread->last_resume_kind == resume_stop)
	    {
	      if (debug_threads)
		fprintf (stderr, "already %s LWP %ld at GDB's request\n",
			 thread->last_status.kind == TARGET_WAITKIND_STOPPED
			 ? "stopped"
			 : "stopping",
			 lwpid_of (lwp));

	      continue;
	    }

	  lwp->resume = &r->resume[ndx];
	  thread->last_resume_kind = lwp->resume->kind;

	  lwp->step_range_start = lwp->resume->step_range_start;
	  lwp->step_range_end = lwp->resume->step_range_end;

	  /* If we had a deferred signal to report, dequeue one now.
	     This can happen if LWP gets more than one signal while
	     trying to get out of a jump pad.  */
	  if (lwp->stopped
	      && !lwp->status_pending_p
	      && dequeue_one_deferred_signal (lwp, &lwp->status_pending))
	    {
	      lwp->status_pending_p = 1;

	      if (debug_threads)
		fprintf (stderr,
			 "Dequeueing deferred signal %d for LWP %ld, "
			 "leaving status pending.\n",
			 WSTOPSIG (lwp->status_pending), lwpid_of (lwp));
	    }

	  return 0;
	}
    }

  /* No resume action for this thread.  */
  lwp->resume = NULL;

  return 0;
}


/* Set *FLAG_P if this lwp has an interesting status pending.  */
static int
resume_status_pending_p (struct inferior_list_entry *entry, void *flag_p)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;

  /* LWPs which will not be resumed are not interesting, because
     we might not wait for them next time through linux_wait.  */
  if (lwp->resume == NULL)
    return 0;

  if (lwp->status_pending_p)
    * (int *) flag_p = 1;

  return 0;
}

/* Return 1 if this lwp that GDB wants running is stopped at an
   internal breakpoint that we need to step over.  It assumes that any
   required STOP_PC adjustment has already been propagated to the
   inferior's regcache.  */

static int
need_step_over_p (struct inferior_list_entry *entry, void *dummy)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *thread;
  struct thread_info *saved_inferior;
  CORE_ADDR pc;

  /* LWPs which will not be resumed are not interesting, because we
     might not wait for them next time through linux_wait.  */

  if (!lwp->stopped)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Need step over [LWP %ld]? Ignoring, not stopped\n",
		 lwpid_of (lwp));
      return 0;
    }

  thread = get_lwp_thread (lwp);

  if (thread->last_resume_kind == resume_stop)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Need step over [LWP %ld]? Ignoring, should remain stopped\n",
		 lwpid_of (lwp));
      return 0;
    }

  gdb_assert (lwp->suspended >= 0);

  if (lwp->suspended)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Need step over [LWP %ld]? Ignoring, suspended\n",
		 lwpid_of (lwp));
      return 0;
    }

  if (!lwp->need_step_over)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Need step over [LWP %ld]? No\n", lwpid_of (lwp));
    }

  if (lwp->status_pending_p)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Need step over [LWP %ld]? Ignoring, has pending status.\n",
		 lwpid_of (lwp));
      return 0;
    }

  /* Note: PC, not STOP_PC.  Either GDB has adjusted the PC already,
     or we have.  */
  pc = get_pc (lwp);

  /* If the PC has changed since we stopped, then don't do anything,
     and let the breakpoint/tracepoint be hit.  This happens if, for
     instance, GDB handled the decr_pc_after_break subtraction itself,
     GDB is OOL stepping this thread, or the user has issued a "jump"
     command, or poked thread's registers herself.  */
  if (pc != lwp->stop_pc)
    {
      if (debug_threads)
	fprintf (stderr,
		 "Need step over [LWP %ld]? Cancelling, PC was changed.  "
		 "Old stop_pc was 0x%s, PC is now 0x%s\n",
		 lwpid_of (lwp), paddress (lwp->stop_pc), paddress (pc));

      lwp->need_step_over = 0;
      return 0;
    }

  saved_inferior = current_inferior;
  current_inferior = thread;

  /* We can only step over breakpoints we know about.  */
  if (breakpoint_here (pc) || fast_tracepoint_jump_here (pc))
    {
      /* Don't step over a breakpoint that GDB expects to hit
	 though.  If the condition is being evaluated on the target's side
	 and it evaluate to false, step over this breakpoint as well.  */
      if (gdb_breakpoint_here (pc)
	  && gdb_condition_true_at_breakpoint (pc)
	  && gdb_no_commands_at_breakpoint (pc))
	{
	  if (debug_threads)
	    fprintf (stderr,
		     "Need step over [LWP %ld]? yes, but found"
		     " GDB breakpoint at 0x%s; skipping step over\n",
		     lwpid_of (lwp), paddress (pc));

	  current_inferior = saved_inferior;
	  return 0;
	}
      else
	{
	  if (debug_threads)
	    fprintf (stderr,
		     "Need step over [LWP %ld]? yes, "
		     "found breakpoint at 0x%s\n",
		     lwpid_of (lwp), paddress (pc));

	  /* We've found an lwp that needs stepping over --- return 1 so
	     that find_inferior stops looking.  */
	  current_inferior = saved_inferior;

	  /* If the step over is cancelled, this is set again.  */
	  lwp->need_step_over = 0;
	  return 1;
	}
    }

  current_inferior = saved_inferior;

  if (debug_threads)
    fprintf (stderr,
	     "Need step over [LWP %ld]? No, no breakpoint found at 0x%s\n",
	     lwpid_of (lwp), paddress (pc));

  return 0;
}

/* Start a step-over operation on LWP.  When LWP stopped at a
   breakpoint, to make progress, we need to remove the breakpoint out
   of the way.  If we let other threads run while we do that, they may
   pass by the breakpoint location and miss hitting it.  To avoid
   that, a step-over momentarily stops all threads while LWP is
   single-stepped while the breakpoint is temporarily uninserted from
   the inferior.  When the single-step finishes, we reinsert the
   breakpoint, and let all threads that are supposed to be running,
   run again.

   On targets that don't support hardware single-step, we don't
   currently support full software single-stepping.  Instead, we only
   support stepping over the thread event breakpoint, by asking the
   low target where to place a reinsert breakpoint.  Since this
   routine assumes the breakpoint being stepped over is a thread event
   breakpoint, it usually assumes the return address of the current
   function is a good enough place to set the reinsert breakpoint.  */

static int
start_step_over (struct lwp_info *lwp)
{
  struct thread_info *saved_inferior;
  CORE_ADDR pc;
  int step;

  if (debug_threads)
    fprintf (stderr,
	     "Starting step-over on LWP %ld.  Stopping all threads\n",
	     lwpid_of (lwp));

  stop_all_lwps (1, lwp);
  gdb_assert (lwp->suspended == 0);

  if (debug_threads)
    fprintf (stderr, "Done stopping all threads for step-over.\n");

  /* Note, we should always reach here with an already adjusted PC,
     either by GDB (if we're resuming due to GDB's request), or by our
     caller, if we just finished handling an internal breakpoint GDB
     shouldn't care about.  */
  pc = get_pc (lwp);

  saved_inferior = current_inferior;
  current_inferior = get_lwp_thread (lwp);

  lwp->bp_reinsert = pc;
  uninsert_breakpoints_at (pc);
  uninsert_fast_tracepoint_jumps_at (pc);

  if (can_hardware_single_step ())
    {
      step = 1;
    }
  else
    {
      CORE_ADDR raddr = (*the_low_target.breakpoint_reinsert_addr) ();
      set_reinsert_breakpoint (raddr);
      step = 0;
    }

  current_inferior = saved_inferior;

  linux_resume_one_lwp (lwp, step, 0, NULL);

  /* Require next event from this LWP.  */
  step_over_bkpt = lwp->head.id;
  return 1;
}

/* Finish a step-over.  Reinsert the breakpoint we had uninserted in
   start_step_over, if still there, and delete any reinsert
   breakpoints we've set, on non hardware single-step targets.  */

static int
finish_step_over (struct lwp_info *lwp)
{
  if (lwp->bp_reinsert != 0)
    {
      if (debug_threads)
	fprintf (stderr, "Finished step over.\n");

      /* Reinsert any breakpoint at LWP->BP_REINSERT.  Note that there
	 may be no breakpoint to reinsert there by now.  */
      reinsert_breakpoints_at (lwp->bp_reinsert);
      reinsert_fast_tracepoint_jumps_at (lwp->bp_reinsert);

      lwp->bp_reinsert = 0;

      /* Delete any software-single-step reinsert breakpoints.  No
	 longer needed.  We don't have to worry about other threads
	 hitting this trap, and later not being able to explain it,
	 because we were stepping over a breakpoint, and we hold all
	 threads but LWP stopped while doing that.  */
      if (!can_hardware_single_step ())
	delete_reinsert_breakpoints ();

      step_over_bkpt = null_ptid;
      return 1;
    }
  else
    return 0;
}

/* This function is called once per thread.  We check the thread's resume
   request, which will tell us whether to resume, step, or leave the thread
   stopped; and what signal, if any, it should be sent.

   For threads which we aren't explicitly told otherwise, we preserve
   the stepping flag; this is used for stepping over gdbserver-placed
   breakpoints.

   If pending_flags was set in any thread, we queue any needed
   signals, since we won't actually resume.  We already have a pending
   event to report, so we don't need to preserve any step requests;
   they should be re-issued if necessary.  */

static int
linux_resume_one_thread (struct inferior_list_entry *entry, void *arg)
{
  struct lwp_info *lwp;
  struct thread_info *thread;
  int step;
  int leave_all_stopped = * (int *) arg;
  int leave_pending;

  thread = (struct thread_info *) entry;
  lwp = get_thread_lwp (thread);

  if (lwp->resume == NULL)
    return 0;

  if (lwp->resume->kind == resume_stop)
    {
      if (debug_threads)
	fprintf (stderr, "resume_stop request for LWP %ld\n", lwpid_of (lwp));

      if (!lwp->stopped)
	{
	  if (debug_threads)
	    fprintf (stderr, "stopping LWP %ld\n", lwpid_of (lwp));

	  /* Stop the thread, and wait for the event asynchronously,
	     through the event loop.  */
	  send_sigstop (lwp);
	}
      else
	{
	  if (debug_threads)
	    fprintf (stderr, "already stopped LWP %ld\n",
		     lwpid_of (lwp));

	  /* The LWP may have been stopped in an internal event that
	     was not meant to be notified back to GDB (e.g., gdbserver
	     breakpoint), so we should be reporting a stop event in
	     this case too.  */

	  /* If the thread already has a pending SIGSTOP, this is a
	     no-op.  Otherwise, something later will presumably resume
	     the thread and this will cause it to cancel any pending
	     operation, due to last_resume_kind == resume_stop.  If
	     the thread already has a pending status to report, we
	     will still report it the next time we wait - see
	     status_pending_p_callback.  */

	  /* If we already have a pending signal to report, then
	     there's no need to queue a SIGSTOP, as this means we're
	     midway through moving the LWP out of the jumppad, and we
	     will report the pending signal as soon as that is
	     finished.  */
	  if (lwp->pending_signals_to_report == NULL)
	    send_sigstop (lwp);
	}

      /* For stop requests, we're done.  */
      lwp->resume = NULL;
      thread->last_status.kind = TARGET_WAITKIND_IGNORE;
      return 0;
    }

  /* If this thread which is about to be resumed has a pending status,
     then don't resume any threads - we can just report the pending
     status.  Make sure to queue any signals that would otherwise be
     sent.  In all-stop mode, we do this decision based on if *any*
     thread has a pending status.  If there's a thread that needs the
     step-over-breakpoint dance, then don't resume any other thread
     but that particular one.  */
  leave_pending = (lwp->status_pending_p || leave_all_stopped);

  if (!leave_pending)
    {
      if (debug_threads)
	fprintf (stderr, "resuming LWP %ld\n", lwpid_of (lwp));

      step = (lwp->resume->kind == resume_step);
      linux_resume_one_lwp (lwp, step, lwp->resume->sig, NULL);
    }
  else
    {
      if (debug_threads)
	fprintf (stderr, "leaving LWP %ld stopped\n", lwpid_of (lwp));

      /* If we have a new signal, enqueue the signal.  */
      if (lwp->resume->sig != 0)
	{
	  struct pending_signals *p_sig;
	  p_sig = xmalloc (sizeof (*p_sig));
	  p_sig->prev = lwp->pending_signals;
	  p_sig->signal = lwp->resume->sig;
	  memset (&p_sig->info, 0, sizeof (siginfo_t));

	  /* If this is the same signal we were previously stopped by,
	     make sure to queue its siginfo.  We can ignore the return
	     value of ptrace; if it fails, we'll skip
	     PTRACE_SETSIGINFO.  */
	  if (WIFSTOPPED (lwp->last_status)
	      && WSTOPSIG (lwp->last_status) == lwp->resume->sig)
	    ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp), (PTRACE_TYPE_ARG3) 0,
		    &p_sig->info);

	  lwp->pending_signals = p_sig;
	}
    }

  thread->last_status.kind = TARGET_WAITKIND_IGNORE;
  lwp->resume = NULL;
  return 0;
}

static void
linux_resume (struct thread_resume *resume_info, size_t n)
{
  struct thread_resume_array array = { resume_info, n };
  struct lwp_info *need_step_over = NULL;
  int any_pending;
  int leave_all_stopped;

  find_inferior (&all_threads, linux_set_resume_request, &array);

  /* If there is a thread which would otherwise be resumed, which has
     a pending status, then don't resume any threads - we can just
     report the pending status.  Make sure to queue any signals that
     would otherwise be sent.  In non-stop mode, we'll apply this
     logic to each thread individually.  We consume all pending events
     before considering to start a step-over (in all-stop).  */
  any_pending = 0;
  if (!non_stop)
    find_inferior (&all_lwps, resume_status_pending_p, &any_pending);

  /* If there is a thread which would otherwise be resumed, which is
     stopped at a breakpoint that needs stepping over, then don't
     resume any threads - have it step over the breakpoint with all
     other threads stopped, then resume all threads again.  Make sure
     to queue any signals that would otherwise be delivered or
     queued.  */
  if (!any_pending && supports_breakpoints ())
    need_step_over
      = (struct lwp_info *) find_inferior (&all_lwps,
					   need_step_over_p, NULL);

  leave_all_stopped = (need_step_over != NULL || any_pending);

  if (debug_threads)
    {
      if (need_step_over != NULL)
	fprintf (stderr, "Not resuming all, need step over\n");
      else if (any_pending)
	fprintf (stderr,
		 "Not resuming, all-stop and found "
		 "an LWP with pending status\n");
      else
	fprintf (stderr, "Resuming, no pending status or step over needed\n");
    }

  /* Even if we're leaving threads stopped, queue all signals we'd
     otherwise deliver.  */
  find_inferior (&all_threads, linux_resume_one_thread, &leave_all_stopped);

  if (need_step_over)
    start_step_over (need_step_over);
}

/* This function is called once per thread.  We check the thread's
   last resume request, which will tell us whether to resume, step, or
   leave the thread stopped.  Any signal the client requested to be
   delivered has already been enqueued at this point.

   If any thread that GDB wants running is stopped at an internal
   breakpoint that needs stepping over, we start a step-over operation
   on that particular thread, and leave all others stopped.  */

static int
proceed_one_lwp (struct inferior_list_entry *entry, void *except)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *thread;
  int step;

  if (lwp == except)
    return 0;

  if (debug_threads)
    fprintf (stderr,
	     "proceed_one_lwp: lwp %ld\n", lwpid_of (lwp));

  if (!lwp->stopped)
    {
      if (debug_threads)
	fprintf (stderr, "   LWP %ld already running\n", lwpid_of (lwp));
      return 0;
    }

  thread = get_lwp_thread (lwp);

  if (thread->last_resume_kind == resume_stop
      && thread->last_status.kind != TARGET_WAITKIND_IGNORE)
    {
      if (debug_threads)
	fprintf (stderr, "   client wants LWP to remain %ld stopped\n",
		 lwpid_of (lwp));
      return 0;
    }

  if (lwp->status_pending_p)
    {
      if (debug_threads)
	fprintf (stderr, "   LWP %ld has pending status, leaving stopped\n",
		 lwpid_of (lwp));
      return 0;
    }

  gdb_assert (lwp->suspended >= 0);

  if (lwp->suspended)
    {
      if (debug_threads)
	fprintf (stderr, "   LWP %ld is suspended\n", lwpid_of (lwp));
      return 0;
    }

  if (thread->last_resume_kind == resume_stop
      && lwp->pending_signals_to_report == NULL
      && lwp->collecting_fast_tracepoint == 0)
    {
      /* We haven't reported this LWP as stopped yet (otherwise, the
	 last_status.kind check above would catch it, and we wouldn't
	 reach here.  This LWP may have been momentarily paused by a
	 stop_all_lwps call while handling for example, another LWP's
	 step-over.  In that case, the pending expected SIGSTOP signal
	 that was queued at vCont;t handling time will have already
	 been consumed by wait_for_sigstop, and so we need to requeue
	 another one here.  Note that if the LWP already has a SIGSTOP
	 pending, this is a no-op.  */

      if (debug_threads)
	fprintf (stderr,
		 "Client wants LWP %ld to stop. "
		 "Making sure it has a SIGSTOP pending\n",
		 lwpid_of (lwp));

      send_sigstop (lwp);
    }

  step = thread->last_resume_kind == resume_step;
  linux_resume_one_lwp (lwp, step, 0, NULL);
  return 0;
}

static int
unsuspend_and_proceed_one_lwp (struct inferior_list_entry *entry, void *except)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;

  if (lwp == except)
    return 0;

  lwp->suspended--;
  gdb_assert (lwp->suspended >= 0);

  return proceed_one_lwp (entry, except);
}

/* When we finish a step-over, set threads running again.  If there's
   another thread that may need a step-over, now's the time to start
   it.  Eventually, we'll move all threads past their breakpoints.  */

static void
proceed_all_lwps (void)
{
  struct lwp_info *need_step_over;

  /* If there is a thread which would otherwise be resumed, which is
     stopped at a breakpoint that needs stepping over, then don't
     resume any threads - have it step over the breakpoint with all
     other threads stopped, then resume all threads again.  */

  if (supports_breakpoints ())
    {
      need_step_over
	= (struct lwp_info *) find_inferior (&all_lwps,
					     need_step_over_p, NULL);

      if (need_step_over != NULL)
	{
	  if (debug_threads)
	    fprintf (stderr, "proceed_all_lwps: found "
		     "thread %ld needing a step-over\n",
		     lwpid_of (need_step_over));

	  start_step_over (need_step_over);
	  return;
	}
    }

  if (debug_threads)
    fprintf (stderr, "Proceeding, no step-over needed\n");

  find_inferior (&all_lwps, proceed_one_lwp, NULL);
}

/* Stopped LWPs that the client wanted to be running, that don't have
   pending statuses, are set to run again, except for EXCEPT, if not
   NULL.  This undoes a stop_all_lwps call.  */

static void
unstop_all_lwps (int unsuspend, struct lwp_info *except)
{
  if (debug_threads)
    {
      if (except)
	fprintf (stderr,
		 "unstopping all lwps, except=(LWP %ld)\n", lwpid_of (except));
      else
	fprintf (stderr,
		 "unstopping all lwps\n");
    }

  if (unsuspend)
    find_inferior (&all_lwps, unsuspend_and_proceed_one_lwp, except);
  else
    find_inferior (&all_lwps, proceed_one_lwp, except);
}


#ifdef HAVE_LINUX_REGSETS

#define use_linux_regsets 1

/* Returns true if REGSET has been disabled.  */

static int
regset_disabled (struct regsets_info *info, struct regset_info *regset)
{
  return (info->disabled_regsets != NULL
	  && info->disabled_regsets[regset - info->regsets]);
}

/* Disable REGSET.  */

static void
disable_regset (struct regsets_info *info, struct regset_info *regset)
{
  int dr_offset;

  dr_offset = regset - info->regsets;
  if (info->disabled_regsets == NULL)
    info->disabled_regsets = xcalloc (1, info->num_regsets);
  info->disabled_regsets[dr_offset] = 1;
}

static int
regsets_fetch_inferior_registers (struct regsets_info *regsets_info,
				  struct regcache *regcache)
{
  struct regset_info *regset;
  int saw_general_regs = 0;
  int pid;
  struct iovec iov;

  regset = regsets_info->regsets;

  pid = lwpid_of (get_thread_lwp (current_inferior));
  while (regset->size >= 0)
    {
      void *buf, *data;
      int nt_type, res;

      if (regset->size == 0 || regset_disabled (regsets_info, regset))
	{
	  regset ++;
	  continue;
	}

      buf = xmalloc (regset->size);

      nt_type = regset->nt_type;
      if (nt_type)
	{
	  iov.iov_base = buf;
	  iov.iov_len = regset->size;
	  data = (void *) &iov;
	}
      else
	data = buf;

#ifndef __sparc__
      res = ptrace (regset->get_request, pid,
		    (PTRACE_TYPE_ARG3) (long) nt_type, data);
#else
      res = ptrace (regset->get_request, pid, data, nt_type);
#endif
      if (res < 0)
	{
	  if (errno == EIO)
	    {
	      /* If we get EIO on a regset, do not try it again for
		 this process mode.  */
	      disable_regset (regsets_info, regset);
	      free (buf);
	      continue;
	    }
	  else
	    {
	      char s[256];
	      sprintf (s, "ptrace(regsets_fetch_inferior_registers) PID=%d",
		       pid);
	      perror (s);
	    }
	}
      else if (regset->type == GENERAL_REGS)
	saw_general_regs = 1;
      regset->store_function (regcache, buf);
      regset ++;
      free (buf);
    }
  if (saw_general_regs)
    return 0;
  else
    return 1;
}

static int
regsets_store_inferior_registers (struct regsets_info *regsets_info,
				  struct regcache *regcache)
{
  struct regset_info *regset;
  int saw_general_regs = 0;
  int pid;
  struct iovec iov;

  regset = regsets_info->regsets;

  pid = lwpid_of (get_thread_lwp (current_inferior));
  while (regset->size >= 0)
    {
      void *buf, *data;
      int nt_type, res;

      if (regset->size == 0 || regset_disabled (regsets_info, regset))
	{
	  regset ++;
	  continue;
	}

      buf = xmalloc (regset->size);

      /* First fill the buffer with the current register set contents,
	 in case there are any items in the kernel's regset that are
	 not in gdbserver's regcache.  */

      nt_type = regset->nt_type;
      if (nt_type)
	{
	  iov.iov_base = buf;
	  iov.iov_len = regset->size;
	  data = (void *) &iov;
	}
      else
	data = buf;

#ifndef __sparc__
      res = ptrace (regset->get_request, pid,
		    (PTRACE_TYPE_ARG3) (long) nt_type, data);
#else
      res = ptrace (regset->get_request, pid, data, nt_type);
#endif

      if (res == 0)
	{
	  /* Then overlay our cached registers on that.  */
	  regset->fill_function (regcache, buf);

	  /* Only now do we write the register set.  */
#ifndef __sparc__
	  res = ptrace (regset->set_request, pid,
			(PTRACE_TYPE_ARG3) (long) nt_type, data);
#else
	  res = ptrace (regset->set_request, pid, data, nt_type);
#endif
	}

      if (res < 0)
	{
	  if (errno == EIO)
	    {
	      /* If we get EIO on a regset, do not try it again for
		 this process mode.  */
	      disable_regset (regsets_info, regset);
	      free (buf);
	      continue;
	    }
	  else if (errno == ESRCH)
	    {
	      /* At this point, ESRCH should mean the process is
		 already gone, in which case we simply ignore attempts
		 to change its registers.  See also the related
		 comment in linux_resume_one_lwp.  */
	      free (buf);
	      return 0;
	    }
	  else
	    {
	      perror ("Warning: ptrace(regsets_store_inferior_registers)");
	    }
	}
      else if (regset->type == GENERAL_REGS)
	saw_general_regs = 1;
      regset ++;
      free (buf);
    }
  if (saw_general_regs)
    return 0;
  else
    return 1;
}

#else /* !HAVE_LINUX_REGSETS */

#define use_linux_regsets 0
#define regsets_fetch_inferior_registers(regsets_info, regcache) 1
#define regsets_store_inferior_registers(regsets_info, regcache) 1

#endif

/* Return 1 if register REGNO is supported by one of the regset ptrace
   calls or 0 if it has to be transferred individually.  */

static int
linux_register_in_regsets (const struct regs_info *regs_info, int regno)
{
  unsigned char mask = 1 << (regno % 8);
  size_t index = regno / 8;

  return (use_linux_regsets
	  && (regs_info->regset_bitmap == NULL
	      || (regs_info->regset_bitmap[index] & mask) != 0));
}

#ifdef HAVE_LINUX_USRREGS

int
register_addr (const struct usrregs_info *usrregs, int regnum)
{
  int addr;

  if (regnum < 0 || regnum >= usrregs->num_regs)
    error ("Invalid register number %d.", regnum);

  addr = usrregs->regmap[regnum];

  return addr;
}

/* Fetch one register.  */
static void
fetch_register (const struct usrregs_info *usrregs,
		struct regcache *regcache, int regno)
{
  CORE_ADDR regaddr;
  int i, size;
  char *buf;
  int pid;

  if (regno >= usrregs->num_regs)
    return;
  if ((*the_low_target.cannot_fetch_register) (regno))
    return;

  regaddr = register_addr (usrregs, regno);
  if (regaddr == -1)
    return;

  size = ((register_size (regcache->tdesc, regno)
	   + sizeof (PTRACE_XFER_TYPE) - 1)
	  & -sizeof (PTRACE_XFER_TYPE));
  buf = alloca (size);

  pid = lwpid_of (get_thread_lwp (current_inferior));
  for (i = 0; i < size; i += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      *(PTRACE_XFER_TYPE *) (buf + i) =
	ptrace (PTRACE_PEEKUSER, pid,
		/* Coerce to a uintptr_t first to avoid potential gcc warning
		   of coercing an 8 byte integer to a 4 byte pointer.  */
		(PTRACE_TYPE_ARG3) (uintptr_t) regaddr, (PTRACE_TYPE_ARG4) 0);
      regaddr += sizeof (PTRACE_XFER_TYPE);
      if (errno != 0)
	error ("reading register %d: %s", regno, strerror (errno));
    }

  if (the_low_target.supply_ptrace_register)
    the_low_target.supply_ptrace_register (regcache, regno, buf);
  else
    supply_register (regcache, regno, buf);
}

/* Store one register.  */
static void
store_register (const struct usrregs_info *usrregs,
		struct regcache *regcache, int regno)
{
  CORE_ADDR regaddr;
  int i, size;
  char *buf;
  int pid;

  if (regno >= usrregs->num_regs)
    return;
  if ((*the_low_target.cannot_store_register) (regno))
    return;

  regaddr = register_addr (usrregs, regno);
  if (regaddr == -1)
    return;

  size = ((register_size (regcache->tdesc, regno)
	   + sizeof (PTRACE_XFER_TYPE) - 1)
	  & -sizeof (PTRACE_XFER_TYPE));
  buf = alloca (size);
  memset (buf, 0, size);

  if (the_low_target.collect_ptrace_register)
    the_low_target.collect_ptrace_register (regcache, regno, buf);
  else
    collect_register (regcache, regno, buf);

  pid = lwpid_of (get_thread_lwp (current_inferior));
  for (i = 0; i < size; i += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      ptrace (PTRACE_POKEUSER, pid,
	    /* Coerce to a uintptr_t first to avoid potential gcc warning
	       about coercing an 8 byte integer to a 4 byte pointer.  */
	      (PTRACE_TYPE_ARG3) (uintptr_t) regaddr,
	      (PTRACE_TYPE_ARG4) *(PTRACE_XFER_TYPE *) (buf + i));
      if (errno != 0)
	{
	  /* At this point, ESRCH should mean the process is
	     already gone, in which case we simply ignore attempts
	     to change its registers.  See also the related
	     comment in linux_resume_one_lwp.  */
	  if (errno == ESRCH)
	    return;

	  if ((*the_low_target.cannot_store_register) (regno) == 0)
	    error ("writing register %d: %s", regno, strerror (errno));
	}
      regaddr += sizeof (PTRACE_XFER_TYPE);
    }
}

/* Fetch all registers, or just one, from the child process.
   If REGNO is -1, do this for all registers, skipping any that are
   assumed to have been retrieved by regsets_fetch_inferior_registers,
   unless ALL is non-zero.
   Otherwise, REGNO specifies which register (so we can save time).  */
static void
usr_fetch_inferior_registers (const struct regs_info *regs_info,
			      struct regcache *regcache, int regno, int all)
{
  struct usrregs_info *usr = regs_info->usrregs;

  if (regno == -1)
    {
      for (regno = 0; regno < usr->num_regs; regno++)
	if (all || !linux_register_in_regsets (regs_info, regno))
	  fetch_register (usr, regcache, regno);
    }
  else
    fetch_register (usr, regcache, regno);
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers, skipping any that are
   assumed to have been saved by regsets_store_inferior_registers,
   unless ALL is non-zero.
   Otherwise, REGNO specifies which register (so we can save time).  */
static void
usr_store_inferior_registers (const struct regs_info *regs_info,
			      struct regcache *regcache, int regno, int all)
{
  struct usrregs_info *usr = regs_info->usrregs;

  if (regno == -1)
    {
      for (regno = 0; regno < usr->num_regs; regno++)
	if (all || !linux_register_in_regsets (regs_info, regno))
	  store_register (usr, regcache, regno);
    }
  else
    store_register (usr, regcache, regno);
}

#else /* !HAVE_LINUX_USRREGS */

#define usr_fetch_inferior_registers(regs_info, regcache, regno, all) do {} while (0)
#define usr_store_inferior_registers(regs_info, regcache, regno, all) do {} while (0)

#endif


void
linux_fetch_registers (struct regcache *regcache, int regno)
{
  int use_regsets;
  int all = 0;
  const struct regs_info *regs_info = (*the_low_target.regs_info) ();

  if (regno == -1)
    {
      if (the_low_target.fetch_register != NULL
	  && regs_info->usrregs != NULL)
	for (regno = 0; regno < regs_info->usrregs->num_regs; regno++)
	  (*the_low_target.fetch_register) (regcache, regno);

      all = regsets_fetch_inferior_registers (regs_info->regsets_info, regcache);
      if (regs_info->usrregs != NULL)
	usr_fetch_inferior_registers (regs_info, regcache, -1, all);
    }
  else
    {
      if (the_low_target.fetch_register != NULL
	  && (*the_low_target.fetch_register) (regcache, regno))
	return;

      use_regsets = linux_register_in_regsets (regs_info, regno);
      if (use_regsets)
	all = regsets_fetch_inferior_registers (regs_info->regsets_info,
						regcache);
      if ((!use_regsets || all) && regs_info->usrregs != NULL)
	usr_fetch_inferior_registers (regs_info, regcache, regno, 1);
    }
}

void
linux_store_registers (struct regcache *regcache, int regno)
{
  int use_regsets;
  int all = 0;
  const struct regs_info *regs_info = (*the_low_target.regs_info) ();

  if (regno == -1)
    {
      all = regsets_store_inferior_registers (regs_info->regsets_info,
					      regcache);
      if (regs_info->usrregs != NULL)
	usr_store_inferior_registers (regs_info, regcache, regno, all);
    }
  else
    {
      use_regsets = linux_register_in_regsets (regs_info, regno);
      if (use_regsets)
	all = regsets_store_inferior_registers (regs_info->regsets_info,
						regcache);
      if ((!use_regsets || all) && regs_info->usrregs != NULL)
	usr_store_inferior_registers (regs_info, regcache, regno, 1);
    }
}


/* Copy LEN bytes from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.  */

static int
linux_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int pid = lwpid_of (get_thread_lwp (current_inferior));
  register PTRACE_XFER_TYPE *buffer;
  register CORE_ADDR addr;
  register int count;
  char filename[64];
  register int i;
  int ret;
  int fd;

  /* Try using /proc.  Don't bother for one word.  */
  if (len >= 3 * sizeof (long))
    {
      int bytes;

      /* We could keep this file open and cache it - possibly one per
	 thread.  That requires some juggling, but is even faster.  */
      sprintf (filename, "/proc/%d/mem", pid);
      fd = open (filename, O_RDONLY | O_LARGEFILE);
      if (fd == -1)
	goto no_proc;

      /* If pread64 is available, use it.  It's faster if the kernel
	 supports it (only one syscall), and it's 64-bit safe even on
	 32-bit platforms (for instance, SPARC debugging a SPARC64
	 application).  */
#ifdef HAVE_PREAD64
      bytes = pread64 (fd, myaddr, len, memaddr);
#else
      bytes = -1;
      if (lseek (fd, memaddr, SEEK_SET) != -1)
	bytes = read (fd, myaddr, len);
#endif

      close (fd);
      if (bytes == len)
	return 0;

      /* Some data was read, we'll try to get the rest with ptrace.  */
      if (bytes > 0)
	{
	  memaddr += bytes;
	  myaddr += bytes;
	  len -= bytes;
	}
    }

 no_proc:
  /* Round starting address down to longword boundary.  */
  addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  count = ((((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
	   / sizeof (PTRACE_XFER_TYPE));
  /* Allocate buffer of that many longwords.  */
  buffer = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));

  /* Read all the longwords */
  errno = 0;
  for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
    {
      /* Coerce the 3rd arg to a uintptr_t first to avoid potential gcc warning
	 about coercing an 8 byte integer to a 4 byte pointer.  */
      buffer[i] = ptrace (PTRACE_PEEKTEXT, pid,
			  (PTRACE_TYPE_ARG3) (uintptr_t) addr,
			  (PTRACE_TYPE_ARG4) 0);
      if (errno)
	break;
    }
  ret = errno;

  /* Copy appropriate bytes out of the buffer.  */
  if (i > 0)
    {
      i *= sizeof (PTRACE_XFER_TYPE);
      i -= memaddr & (sizeof (PTRACE_XFER_TYPE) - 1);
      memcpy (myaddr,
	      (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	      i < len ? i : len);
    }

  return ret;
}

/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's
   memory at MEMADDR.  On failure (cannot write to the inferior)
   returns the value of errno.  Always succeeds if LEN is zero.  */

static int
linux_write_memory (CORE_ADDR memaddr, const unsigned char *myaddr, int len)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
    / sizeof (PTRACE_XFER_TYPE);

  /* Allocate buffer of that many longwords.  */
  register PTRACE_XFER_TYPE *buffer = (PTRACE_XFER_TYPE *)
    alloca (count * sizeof (PTRACE_XFER_TYPE));

  int pid = lwpid_of (get_thread_lwp (current_inferior));

  if (len == 0)
    {
      /* Zero length write always succeeds.  */
      return 0;
    }

  if (debug_threads)
    {
      /* Dump up to four bytes.  */
      unsigned int val = * (unsigned int *) myaddr;
      if (len == 1)
	val = val & 0xff;
      else if (len == 2)
	val = val & 0xffff;
      else if (len == 3)
	val = val & 0xffffff;
      fprintf (stderr, "Writing %0*x to 0x%08lx\n", 2 * ((len < 4) ? len : 4),
	       val, (long)memaddr);
    }

  /* Fill start and end extra bytes of buffer with existing memory data.  */

  errno = 0;
  /* Coerce the 3rd arg to a uintptr_t first to avoid potential gcc warning
     about coercing an 8 byte integer to a 4 byte pointer.  */
  buffer[0] = ptrace (PTRACE_PEEKTEXT, pid,
		      (PTRACE_TYPE_ARG3) (uintptr_t) addr,
		      (PTRACE_TYPE_ARG4) 0);
  if (errno)
    return errno;

  if (count > 1)
    {
      errno = 0;
      buffer[count - 1]
	= ptrace (PTRACE_PEEKTEXT, pid,
		  /* Coerce to a uintptr_t first to avoid potential gcc warning
		     about coercing an 8 byte integer to a 4 byte pointer.  */
		  (PTRACE_TYPE_ARG3) (uintptr_t) (addr + (count - 1)
						  * sizeof (PTRACE_XFER_TYPE)),
		  (PTRACE_TYPE_ARG4) 0);
      if (errno)
	return errno;
    }

  /* Copy data to be written over corresponding part of buffer.  */

  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	  myaddr, len);

  /* Write the entire buffer.  */

  for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      ptrace (PTRACE_POKETEXT, pid,
	      /* Coerce to a uintptr_t first to avoid potential gcc warning
		 about coercing an 8 byte integer to a 4 byte pointer.  */
	      (PTRACE_TYPE_ARG3) (uintptr_t) addr,
	      (PTRACE_TYPE_ARG4) buffer[i]);
      if (errno)
	return errno;
    }

  return 0;
}

static void
linux_look_up_symbols (void)
{
#ifdef USE_THREAD_DB
  struct process_info *proc = current_process ();

  if (proc->private->thread_db != NULL)
    return;

  /* If the kernel supports tracing clones, then we don't need to
     use the magic thread event breakpoint to learn about
     threads.  */
  thread_db_init (!linux_supports_traceclone ());
#endif
}

static void
linux_request_interrupt (void)
{
  extern unsigned long signal_pid;

  if (!ptid_equal (cont_thread, null_ptid)
      && !ptid_equal (cont_thread, minus_one_ptid))
    {
      struct lwp_info *lwp;
      int lwpid;

      lwp = get_thread_lwp (current_inferior);
      lwpid = lwpid_of (lwp);
      kill_lwp (lwpid, SIGINT);
    }
  else
    kill_lwp (signal_pid, SIGINT);
}

/* Copy LEN bytes from inferior's auxiliary vector starting at OFFSET
   to debugger memory starting at MYADDR.  */

static int
linux_read_auxv (CORE_ADDR offset, unsigned char *myaddr, unsigned int len)
{
  char filename[PATH_MAX];
  int fd, n;
  int pid = lwpid_of (get_thread_lwp (current_inferior));

  xsnprintf (filename, sizeof filename, "/proc/%d/auxv", pid);

  fd = open (filename, O_RDONLY);
  if (fd < 0)
    return -1;

  if (offset != (CORE_ADDR) 0
      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)
    n = -1;
  else
    n = read (fd, myaddr, len);

  close (fd);

  return n;
}

/* These breakpoint and watchpoint related wrapper functions simply
   pass on the function call if the target has registered a
   corresponding function.  */

static int
linux_insert_point (char type, CORE_ADDR addr, int len)
{
  if (the_low_target.insert_point != NULL)
    return the_low_target.insert_point (type, addr, len);
  else
    /* Unsupported (see target.h).  */
    return 1;
}

static int
linux_remove_point (char type, CORE_ADDR addr, int len)
{
  if (the_low_target.remove_point != NULL)
    return the_low_target.remove_point (type, addr, len);
  else
    /* Unsupported (see target.h).  */
    return 1;
}

static int
linux_stopped_by_watchpoint (void)
{
  struct lwp_info *lwp = get_thread_lwp (current_inferior);

  return lwp->stopped_by_watchpoint;
}

static CORE_ADDR
linux_stopped_data_address (void)
{
  struct lwp_info *lwp = get_thread_lwp (current_inferior);

  return lwp->stopped_data_address;
}

#if defined(__UCLIBC__) && defined(HAS_NOMMU)	      \
    && defined(PT_TEXT_ADDR) && defined(PT_DATA_ADDR) \
    && defined(PT_TEXT_END_ADDR)

/* This is only used for targets that define PT_TEXT_ADDR,
   PT_DATA_ADDR and PT_TEXT_END_ADDR.  If those are not defined, supposedly
   the target has different ways of acquiring this information, like
   loadmaps.  */

/* Under uClinux, programs are loaded at non-zero offsets, which we need
   to tell gdb about.  */

static int
linux_read_offsets (CORE_ADDR *text_p, CORE_ADDR *data_p)
{
  unsigned long text, text_end, data;
  int pid = lwpid_of (get_thread_lwp (current_inferior));

  errno = 0;

  text = ptrace (PTRACE_PEEKUSER, pid, (PTRACE_TYPE_ARG3) PT_TEXT_ADDR,
		 (PTRACE_TYPE_ARG4) 0);
  text_end = ptrace (PTRACE_PEEKUSER, pid, (PTRACE_TYPE_ARG3) PT_TEXT_END_ADDR,
		     (PTRACE_TYPE_ARG4) 0);
  data = ptrace (PTRACE_PEEKUSER, pid, (PTRACE_TYPE_ARG3) PT_DATA_ADDR,
		 (PTRACE_TYPE_ARG4) 0);

  if (errno == 0)
    {
      /* Both text and data offsets produced at compile-time (and so
	 used by gdb) are relative to the beginning of the program,
	 with the data segment immediately following the text segment.
	 However, the actual runtime layout in memory may put the data
	 somewhere else, so when we send gdb a data base-address, we
	 use the real data base address and subtract the compile-time
	 data base-address from it (which is just the length of the
	 text segment).  BSS immediately follows data in both
	 cases.  */
      *text_p = text;
      *data_p = data - (text_end - text);

      return 1;
    }
 return 0;
}
#endif

static int
linux_qxfer_osdata (const char *annex,
		    unsigned char *readbuf, unsigned const char *writebuf,
		    CORE_ADDR offset, int len)
{
  return linux_common_xfer_osdata (annex, readbuf, offset, len);
}

/* Convert a native/host siginfo object, into/from the siginfo in the
   layout of the inferiors' architecture.  */

static void
siginfo_fixup (siginfo_t *siginfo, void *inf_siginfo, int direction)
{
  int done = 0;

  if (the_low_target.siginfo_fixup != NULL)
    done = the_low_target.siginfo_fixup (siginfo, inf_siginfo, direction);

  /* If there was no callback, or the callback didn't do anything,
     then just do a straight memcpy.  */
  if (!done)
    {
      if (direction == 1)
	memcpy (siginfo, inf_siginfo, sizeof (siginfo_t));
      else
	memcpy (inf_siginfo, siginfo, sizeof (siginfo_t));
    }
}

static int
linux_xfer_siginfo (const char *annex, unsigned char *readbuf,
		    unsigned const char *writebuf, CORE_ADDR offset, int len)
{
  int pid;
  siginfo_t siginfo;
  char inf_siginfo[sizeof (siginfo_t)];

  if (current_inferior == NULL)
    return -1;

  pid = lwpid_of (get_thread_lwp (current_inferior));

  if (debug_threads)
    fprintf (stderr, "%s siginfo for lwp %d.\n",
	     readbuf != NULL ? "Reading" : "Writing",
	     pid);

  if (offset >= sizeof (siginfo))
    return -1;

  if (ptrace (PTRACE_GETSIGINFO, pid, (PTRACE_TYPE_ARG3) 0, &siginfo) != 0)
    return -1;

  /* When GDBSERVER is built as a 64-bit application, ptrace writes into
     SIGINFO an object with 64-bit layout.  Since debugging a 32-bit
     inferior with a 64-bit GDBSERVER should look the same as debugging it
     with a 32-bit GDBSERVER, we need to convert it.  */
  siginfo_fixup (&siginfo, inf_siginfo, 0);

  if (offset + len > sizeof (siginfo))
    len = sizeof (siginfo) - offset;

  if (readbuf != NULL)
    memcpy (readbuf, inf_siginfo + offset, len);
  else
    {
      memcpy (inf_siginfo + offset, writebuf, len);

      /* Convert back to ptrace layout before flushing it out.  */
      siginfo_fixup (&siginfo, inf_siginfo, 1);

      if (ptrace (PTRACE_SETSIGINFO, pid, (PTRACE_TYPE_ARG3) 0, &siginfo) != 0)
	return -1;
    }

  return len;
}

/* SIGCHLD handler that serves two purposes: In non-stop/async mode,
   so we notice when children change state; as the handler for the
   sigsuspend in my_waitpid.  */

static void
sigchld_handler (int signo)
{
  int old_errno = errno;

  if (debug_threads)
    {
      do
	{
	  /* fprintf is not async-signal-safe, so call write
	     directly.  */
	  if (write (2, "sigchld_handler\n",
		     sizeof ("sigchld_handler\n") - 1) < 0)
	    break; /* just ignore */
	} while (0);
    }

  if (target_is_async_p ())
    async_file_mark (); /* trigger a linux_wait */

  errno = old_errno;
}

static int
linux_supports_non_stop (void)
{
  return 1;
}

static int
linux_async (int enable)
{
  int previous = (linux_event_pipe[0] != -1);

  if (debug_threads)
    fprintf (stderr, "linux_async (%d), previous=%d\n",
	     enable, previous);

  if (previous != enable)
    {
      sigset_t mask;
      sigemptyset (&mask);
      sigaddset (&mask, SIGCHLD);

      sigprocmask (SIG_BLOCK, &mask, NULL);

      if (enable)
	{
	  if (pipe (linux_event_pipe) == -1)
	    fatal ("creating event pipe failed.");

	  fcntl (linux_event_pipe[0], F_SETFL, O_NONBLOCK);
	  fcntl (linux_event_pipe[1], F_SETFL, O_NONBLOCK);

	  /* Register the event loop handler.  */
	  add_file_handler (linux_event_pipe[0],
			    handle_target_event, NULL);

	  /* Always trigger a linux_wait.  */
	  async_file_mark ();
	}
      else
	{
	  delete_file_handler (linux_event_pipe[0]);

	  close (linux_event_pipe[0]);
	  close (linux_event_pipe[1]);
	  linux_event_pipe[0] = -1;
	  linux_event_pipe[1] = -1;
	}

      sigprocmask (SIG_UNBLOCK, &mask, NULL);
    }

  return previous;
}

static int
linux_start_non_stop (int nonstop)
{
  /* Register or unregister from event-loop accordingly.  */
  linux_async (nonstop);
  return 0;
}

static int
linux_supports_multi_process (void)
{
  return 1;
}

static int
linux_supports_disable_randomization (void)
{
#ifdef HAVE_PERSONALITY
  return 1;
#else
  return 0;
#endif
}

static int
linux_supports_agent (void)
{
  return 1;
}

static int
linux_supports_range_stepping (void)
{
  if (*the_low_target.supports_range_stepping == NULL)
    return 0;

  return (*the_low_target.supports_range_stepping) ();
}

/* Enumerate spufs IDs for process PID.  */
static int
spu_enumerate_spu_ids (long pid, unsigned char *buf, CORE_ADDR offset, int len)
{
  int pos = 0;
  int written = 0;
  char path[128];
  DIR *dir;
  struct dirent *entry;

  sprintf (path, "/proc/%ld/fd", pid);
  dir = opendir (path);
  if (!dir)
    return -1;

  rewinddir (dir);
  while ((entry = readdir (dir)) != NULL)
    {
      struct stat st;
      struct statfs stfs;
      int fd;

      fd = atoi (entry->d_name);
      if (!fd)
        continue;

      sprintf (path, "/proc/%ld/fd/%d", pid, fd);
      if (stat (path, &st) != 0)
        continue;
      if (!S_ISDIR (st.st_mode))
        continue;

      if (statfs (path, &stfs) != 0)
        continue;
      if (stfs.f_type != SPUFS_MAGIC)
        continue;

      if (pos >= offset && pos + 4 <= offset + len)
        {
          *(unsigned int *)(buf + pos - offset) = fd;
          written += 4;
        }
      pos += 4;
    }

  closedir (dir);
  return written;
}

/* Implements the to_xfer_partial interface for the TARGET_OBJECT_SPU
   object type, using the /proc file system.  */
static int
linux_qxfer_spu (const char *annex, unsigned char *readbuf,
		 unsigned const char *writebuf,
		 CORE_ADDR offset, int len)
{
  long pid = lwpid_of (get_thread_lwp (current_inferior));
  char buf[128];
  int fd = 0;
  int ret = 0;

  if (!writebuf && !readbuf)
    return -1;

  if (!*annex)
    {
      if (!readbuf)
	return -1;
      else
	return spu_enumerate_spu_ids (pid, readbuf, offset, len);
    }

  sprintf (buf, "/proc/%ld/fd/%s", pid, annex);
  fd = open (buf, writebuf? O_WRONLY : O_RDONLY);
  if (fd <= 0)
    return -1;

  if (offset != 0
      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)
    {
      close (fd);
      return 0;
    }

  if (writebuf)
    ret = write (fd, writebuf, (size_t) len);
  else
    ret = read (fd, readbuf, (size_t) len);

  close (fd);
  return ret;
}

#if defined PT_GETDSBT || defined PTRACE_GETFDPIC
struct target_loadseg
{
  /* Core address to which the segment is mapped.  */
  Elf32_Addr addr;
  /* VMA recorded in the program header.  */
  Elf32_Addr p_vaddr;
  /* Size of this segment in memory.  */
  Elf32_Word p_memsz;
};

# if defined PT_GETDSBT
struct target_loadmap
{
  /* Protocol version number, must be zero.  */
  Elf32_Word version;
  /* Pointer to the DSBT table, its size, and the DSBT index.  */
  unsigned *dsbt_table;
  unsigned dsbt_size, dsbt_index;
  /* Number of segments in this map.  */
  Elf32_Word nsegs;
  /* The actual memory map.  */
  struct target_loadseg segs[/*nsegs*/];
};
#  define LINUX_LOADMAP		PT_GETDSBT
#  define LINUX_LOADMAP_EXEC	PTRACE_GETDSBT_EXEC
#  define LINUX_LOADMAP_INTERP	PTRACE_GETDSBT_INTERP
# else
struct target_loadmap
{
  /* Protocol version number, must be zero.  */
  Elf32_Half version;
  /* Number of segments in this map.  */
  Elf32_Half nsegs;
  /* The actual memory map.  */
  struct target_loadseg segs[/*nsegs*/];
};
#  define LINUX_LOADMAP		PTRACE_GETFDPIC
#  define LINUX_LOADMAP_EXEC	PTRACE_GETFDPIC_EXEC
#  define LINUX_LOADMAP_INTERP	PTRACE_GETFDPIC_INTERP
# endif

static int
linux_read_loadmap (const char *annex, CORE_ADDR offset,
		    unsigned char *myaddr, unsigned int len)
{
  int pid = lwpid_of (get_thread_lwp (current_inferior));
  int addr = -1;
  struct target_loadmap *data = NULL;
  unsigned int actual_length, copy_length;

  if (strcmp (annex, "exec") == 0)
    addr = (int) LINUX_LOADMAP_EXEC;
  else if (strcmp (annex, "interp") == 0)
    addr = (int) LINUX_LOADMAP_INTERP;
  else
    return -1;

  if (ptrace (LINUX_LOADMAP, pid, addr, &data) != 0)
    return -1;

  if (data == NULL)
    return -1;

  actual_length = sizeof (struct target_loadmap)
    + sizeof (struct target_loadseg) * data->nsegs;

  if (offset < 0 || offset > actual_length)
    return -1;

  copy_length = actual_length - offset < len ? actual_length - offset : len;
  memcpy (myaddr, (char *) data + offset, copy_length);
  return copy_length;
}
#else
# define linux_read_loadmap NULL
#endif /* defined PT_GETDSBT || defined PTRACE_GETFDPIC */

static void
linux_process_qsupported (const char *query)
{
  if (the_low_target.process_qsupported != NULL)
    the_low_target.process_qsupported (query);
}

static int
linux_supports_tracepoints (void)
{
  if (*the_low_target.supports_tracepoints == NULL)
    return 0;

  return (*the_low_target.supports_tracepoints) ();
}

static CORE_ADDR
linux_read_pc (struct regcache *regcache)
{
  if (the_low_target.get_pc == NULL)
    return 0;

  return (*the_low_target.get_pc) (regcache);
}

static void
linux_write_pc (struct regcache *regcache, CORE_ADDR pc)
{
  gdb_assert (the_low_target.set_pc != NULL);

  (*the_low_target.set_pc) (regcache, pc);
}

static int
linux_thread_stopped (struct thread_info *thread)
{
  return get_thread_lwp (thread)->stopped;
}

/* This exposes stop-all-threads functionality to other modules.  */

static void
linux_pause_all (int freeze)
{
  stop_all_lwps (freeze, NULL);
}

/* This exposes unstop-all-threads functionality to other gdbserver
   modules.  */

static void
linux_unpause_all (int unfreeze)
{
  unstop_all_lwps (unfreeze, NULL);
}

static int
linux_prepare_to_access_memory (void)
{
  /* Neither ptrace nor /proc/PID/mem allow accessing memory through a
     running LWP.  */
  if (non_stop)
    linux_pause_all (1);
  return 0;
}

static void
linux_done_accessing_memory (void)
{
  /* Neither ptrace nor /proc/PID/mem allow accessing memory through a
     running LWP.  */
  if (non_stop)
    linux_unpause_all (1);
}

static int
linux_install_fast_tracepoint_jump_pad (CORE_ADDR tpoint, CORE_ADDR tpaddr,
					CORE_ADDR collector,
					CORE_ADDR lockaddr,
					ULONGEST orig_size,
					CORE_ADDR *jump_entry,
					CORE_ADDR *trampoline,
					ULONGEST *trampoline_size,
					unsigned char *jjump_pad_insn,
					ULONGEST *jjump_pad_insn_size,
					CORE_ADDR *adjusted_insn_addr,
					CORE_ADDR *adjusted_insn_addr_end,
					char *err)
{
  return (*the_low_target.install_fast_tracepoint_jump_pad)
    (tpoint, tpaddr, collector, lockaddr, orig_size,
     jump_entry, trampoline, trampoline_size,
     jjump_pad_insn, jjump_pad_insn_size,
     adjusted_insn_addr, adjusted_insn_addr_end,
     err);
}

static struct emit_ops *
linux_emit_ops (void)
{
  if (the_low_target.emit_ops != NULL)
    return (*the_low_target.emit_ops) ();
  else
    return NULL;
}

static int
linux_get_min_fast_tracepoint_insn_len (void)
{
  return (*the_low_target.get_min_fast_tracepoint_insn_len) ();
}

/* Extract &phdr and num_phdr in the inferior.  Return 0 on success.  */

static int
get_phdr_phnum_from_proc_auxv (const int pid, const int is_elf64,
			       CORE_ADDR *phdr_memaddr, int *num_phdr)
{
  char filename[PATH_MAX];
  int fd;
  const int auxv_size = is_elf64
    ? sizeof (Elf64_auxv_t) : sizeof (Elf32_auxv_t);
  char buf[sizeof (Elf64_auxv_t)];  /* The larger of the two.  */

  xsnprintf (filename, sizeof filename, "/proc/%d/auxv", pid);

  fd = open (filename, O_RDONLY);
  if (fd < 0)
    return 1;

  *phdr_memaddr = 0;
  *num_phdr = 0;
  while (read (fd, buf, auxv_size) == auxv_size
	 && (*phdr_memaddr == 0 || *num_phdr == 0))
    {
      if (is_elf64)
	{
	  Elf64_auxv_t *const aux = (Elf64_auxv_t *) buf;

	  switch (aux->a_type)
	    {
	    case AT_PHDR:
	      *phdr_memaddr = aux->a_un.a_val;
	      break;
	    case AT_PHNUM:
	      *num_phdr = aux->a_un.a_val;
	      break;
	    }
	}
      else
	{
	  Elf32_auxv_t *const aux = (Elf32_auxv_t *) buf;

	  switch (aux->a_type)
	    {
	    case AT_PHDR:
	      *phdr_memaddr = aux->a_un.a_val;
	      break;
	    case AT_PHNUM:
	      *num_phdr = aux->a_un.a_val;
	      break;
	    }
	}
    }

  close (fd);

  if (*phdr_memaddr == 0 || *num_phdr == 0)
    {
      warning ("Unexpected missing AT_PHDR and/or AT_PHNUM: "
	       "phdr_memaddr = %ld, phdr_num = %d",
	       (long) *phdr_memaddr, *num_phdr);
      return 2;
    }

  return 0;
}

/* Return &_DYNAMIC (via PT_DYNAMIC) in the inferior, or 0 if not present.  */

static CORE_ADDR
get_dynamic (const int pid, const int is_elf64)
{
  CORE_ADDR phdr_memaddr, relocation;
  int num_phdr, i;
  unsigned char *phdr_buf;
  const int phdr_size = is_elf64 ? sizeof (Elf64_Phdr) : sizeof (Elf32_Phdr);

  if (get_phdr_phnum_from_proc_auxv (pid, is_elf64, &phdr_memaddr, &num_phdr))
    return 0;

  gdb_assert (num_phdr < 100);  /* Basic sanity check.  */
  phdr_buf = alloca (num_phdr * phdr_size);

  if (linux_read_memory (phdr_memaddr, phdr_buf, num_phdr * phdr_size))
    return 0;

  /* Compute relocation: it is expected to be 0 for "regular" executables,
     non-zero for PIE ones.  */
  relocation = -1;
  for (i = 0; relocation == -1 && i < num_phdr; i++)
    if (is_elf64)
      {
	Elf64_Phdr *const p = (Elf64_Phdr *) (phdr_buf + i * phdr_size);

	if (p->p_type == PT_PHDR)
	  relocation = phdr_memaddr - p->p_vaddr;
      }
    else
      {
	Elf32_Phdr *const p = (Elf32_Phdr *) (phdr_buf + i * phdr_size);

	if (p->p_type == PT_PHDR)
	  relocation = phdr_memaddr - p->p_vaddr;
      }

  if (relocation == -1)
    {
      /* PT_PHDR is optional, but necessary for PIE in general.  Fortunately
	 any real world executables, including PIE executables, have always
	 PT_PHDR present.  PT_PHDR is not present in some shared libraries or
	 in fpc (Free Pascal 2.4) binaries but neither of those have a need for
	 or present DT_DEBUG anyway (fpc binaries are statically linked).

	 Therefore if there exists DT_DEBUG there is always also PT_PHDR.

	 GDB could find RELOCATION also from AT_ENTRY - e_entry.  */

      return 0;
    }

  for (i = 0; i < num_phdr; i++)
    {
      if (is_elf64)
	{
	  Elf64_Phdr *const p = (Elf64_Phdr *) (phdr_buf + i * phdr_size);

	  if (p->p_type == PT_DYNAMIC)
	    return p->p_vaddr + relocation;
	}
      else
	{
	  Elf32_Phdr *const p = (Elf32_Phdr *) (phdr_buf + i * phdr_size);

	  if (p->p_type == PT_DYNAMIC)
	    return p->p_vaddr + relocation;
	}
    }

  return 0;
}

/* Return &_r_debug in the inferior, or -1 if not present.  Return value
   can be 0 if the inferior does not yet have the library list initialized.
   We look for DT_MIPS_RLD_MAP first.  MIPS executables use this instead of
   DT_DEBUG, although they sometimes contain an unused DT_DEBUG entry too.  */

static CORE_ADDR
get_r_debug (const int pid, const int is_elf64)
{
  CORE_ADDR dynamic_memaddr;
  const int dyn_size = is_elf64 ? sizeof (Elf64_Dyn) : sizeof (Elf32_Dyn);
  unsigned char buf[sizeof (Elf64_Dyn)];  /* The larger of the two.  */
  CORE_ADDR map = -1;

  dynamic_memaddr = get_dynamic (pid, is_elf64);
  if (dynamic_memaddr == 0)
    return map;

  while (linux_read_memory (dynamic_memaddr, buf, dyn_size) == 0)
    {
      if (is_elf64)
	{
	  Elf64_Dyn *const dyn = (Elf64_Dyn *) buf;
#ifdef DT_MIPS_RLD_MAP
	  union
	    {
	      Elf64_Xword map;
	      unsigned char buf[sizeof (Elf64_Xword)];
	    }
	  rld_map;

	  if (dyn->d_tag == DT_MIPS_RLD_MAP)
	    {
	      if (linux_read_memory (dyn->d_un.d_val,
				     rld_map.buf, sizeof (rld_map.buf)) == 0)
		return rld_map.map;
	      else
		break;
	    }
#endif	/* DT_MIPS_RLD_MAP */

	  if (dyn->d_tag == DT_DEBUG && map == -1)
	    map = dyn->d_un.d_val;

	  if (dyn->d_tag == DT_NULL)
	    break;
	}
      else
	{
	  Elf32_Dyn *const dyn = (Elf32_Dyn *) buf;
#ifdef DT_MIPS_RLD_MAP
	  union
	    {
	      Elf32_Word map;
	      unsigned char buf[sizeof (Elf32_Word)];
	    }
	  rld_map;

	  if (dyn->d_tag == DT_MIPS_RLD_MAP)
	    {
	      if (linux_read_memory (dyn->d_un.d_val,
				     rld_map.buf, sizeof (rld_map.buf)) == 0)
		return rld_map.map;
	      else
		break;
	    }
#endif	/* DT_MIPS_RLD_MAP */

	  if (dyn->d_tag == DT_DEBUG && map == -1)
	    map = dyn->d_un.d_val;

	  if (dyn->d_tag == DT_NULL)
	    break;
	}

      dynamic_memaddr += dyn_size;
    }

  return map;
}

/* Read one pointer from MEMADDR in the inferior.  */

static int
read_one_ptr (CORE_ADDR memaddr, CORE_ADDR *ptr, int ptr_size)
{
  int ret;

  /* Go through a union so this works on either big or little endian
     hosts, when the inferior's pointer size is smaller than the size
     of CORE_ADDR.  It is assumed the inferior's endianness is the
     same of the superior's.  */
  union
  {
    CORE_ADDR core_addr;
    unsigned int ui;
    unsigned char uc;
  } addr;

  ret = linux_read_memory (memaddr, &addr.uc, ptr_size);
  if (ret == 0)
    {
      if (ptr_size == sizeof (CORE_ADDR))
	*ptr = addr.core_addr;
      else if (ptr_size == sizeof (unsigned int))
	*ptr = addr.ui;
      else
	gdb_assert_not_reached ("unhandled pointer size");
    }
  return ret;
}

struct link_map_offsets
  {
    /* Offset and size of r_debug.r_version.  */
    int r_version_offset;

    /* Offset and size of r_debug.r_map.  */
    int r_map_offset;

    /* Offset to l_addr field in struct link_map.  */
    int l_addr_offset;

    /* Offset to l_name field in struct link_map.  */
    int l_name_offset;

    /* Offset to l_ld field in struct link_map.  */
    int l_ld_offset;

    /* Offset to l_next field in struct link_map.  */
    int l_next_offset;

    /* Offset to l_prev field in struct link_map.  */
    int l_prev_offset;
  };

/* Construct qXfer:libraries-svr4:read reply.  */

static int
linux_qxfer_libraries_svr4 (const char *annex, unsigned char *readbuf,
			    unsigned const char *writebuf,
			    CORE_ADDR offset, int len)
{
  char *document;
  unsigned document_len;
  struct process_info_private *const priv = current_process ()->private;
  char filename[PATH_MAX];
  int pid, is_elf64;

  static const struct link_map_offsets lmo_32bit_offsets =
    {
      0,     /* r_version offset. */
      4,     /* r_debug.r_map offset.  */
      0,     /* l_addr offset in link_map.  */
      4,     /* l_name offset in link_map.  */
      8,     /* l_ld offset in link_map.  */
      12,    /* l_next offset in link_map.  */
      16     /* l_prev offset in link_map.  */
    };

  static const struct link_map_offsets lmo_64bit_offsets =
    {
      0,     /* r_version offset. */
      8,     /* r_debug.r_map offset.  */
      0,     /* l_addr offset in link_map.  */
      8,     /* l_name offset in link_map.  */
      16,    /* l_ld offset in link_map.  */
      24,    /* l_next offset in link_map.  */
      32     /* l_prev offset in link_map.  */
    };
  const struct link_map_offsets *lmo;
  unsigned int machine;
  int ptr_size;
  CORE_ADDR lm_addr = 0, lm_prev = 0;
  int allocated = 1024;
  char *p;
  CORE_ADDR l_name, l_addr, l_ld, l_next, l_prev;
  int header_done = 0;

  if (writebuf != NULL)
    return -2;
  if (readbuf == NULL)
    return -1;

  pid = lwpid_of (get_thread_lwp (current_inferior));
  xsnprintf (filename, sizeof filename, "/proc/%d/exe", pid);
  is_elf64 = elf_64_file_p (filename, &machine);
  lmo = is_elf64 ? &lmo_64bit_offsets : &lmo_32bit_offsets;
  ptr_size = is_elf64 ? 8 : 4;

  while (annex[0] != '\0')
    {
      const char *sep;
      CORE_ADDR *addrp;
      int len;

      sep = strchr (annex, '=');
      if (sep == NULL)
	break;

      len = sep - annex;
      if (len == 5 && strncmp (annex, "start", 5) == 0)
	addrp = &lm_addr;
      else if (len == 4 && strncmp (annex, "prev", 4) == 0)
	addrp = &lm_prev;
      else
	{
	  annex = strchr (sep, ';');
	  if (annex == NULL)
	    break;
	  annex++;
	  continue;
	}

      annex = decode_address_to_semicolon (addrp, sep + 1);
    }

  if (lm_addr == 0)
    {
      int r_version = 0;

      if (priv->r_debug == 0)
	priv->r_debug = get_r_debug (pid, is_elf64);

      /* We failed to find DT_DEBUG.  Such situation will not change
	 for this inferior - do not retry it.  Report it to GDB as
	 E01, see for the reasons at the GDB solib-svr4.c side.  */
      if (priv->r_debug == (CORE_ADDR) -1)
	return -1;

      if (priv->r_debug != 0)
	{
	  if (linux_read_memory (priv->r_debug + lmo->r_version_offset,
				 (unsigned char *) &r_version,
				 sizeof (r_version)) != 0
	      || r_version != 1)
	    {
	      warning ("unexpected r_debug version %d", r_version);
	    }
	  else if (read_one_ptr (priv->r_debug + lmo->r_map_offset,
				 &lm_addr, ptr_size) != 0)
	    {
	      warning ("unable to read r_map from 0x%lx",
		       (long) priv->r_debug + lmo->r_map_offset);
	    }
	}
    }

  document = xmalloc (allocated);
  strcpy (document, "<library-list-svr4 version=\"1.0\"");
  p = document + strlen (document);

  while (lm_addr
	 && read_one_ptr (lm_addr + lmo->l_name_offset,
			  &l_name, ptr_size) == 0
	 && read_one_ptr (lm_addr + lmo->l_addr_offset,
			  &l_addr, ptr_size) == 0
	 && read_one_ptr (lm_addr + lmo->l_ld_offset,
			  &l_ld, ptr_size) == 0
	 && read_one_ptr (lm_addr + lmo->l_prev_offset,
			  &l_prev, ptr_size) == 0
	 && read_one_ptr (lm_addr + lmo->l_next_offset,
			  &l_next, ptr_size) == 0)
    {
      unsigned char libname[PATH_MAX];

      if (lm_prev != l_prev)
	{
	  warning ("Corrupted shared library list: 0x%lx != 0x%lx",
		   (long) lm_prev, (long) l_prev);
	  break;
	}

      /* Ignore the first entry even if it has valid name as the first entry
	 corresponds to the main executable.  The first entry should not be
	 skipped if the dynamic loader was loaded late by a static executable
	 (see solib-svr4.c parameter ignore_first).  But in such case the main
	 executable does not have PT_DYNAMIC present and this function already
	 exited above due to failed get_r_debug.  */
      if (lm_prev == 0)
	{
	  sprintf (p, " main-lm=\"0x%lx\"", (unsigned long) lm_addr);
	  p = p + strlen (p);
	}
      else
	{
	  /* Not checking for error because reading may stop before
	     we've got PATH_MAX worth of characters.  */
	  libname[0] = '\0';
	  linux_read_memory (l_name, libname, sizeof (libname) - 1);
	  libname[sizeof (libname) - 1] = '\0';
	  if (libname[0] != '\0')
	    {
	      /* 6x the size for xml_escape_text below.  */
	      size_t len = 6 * strlen ((char *) libname);
	      char *name;

	      if (!header_done)
		{
		  /* Terminate `<library-list-svr4'.  */
		  *p++ = '>';
		  header_done = 1;
		}

	      while (allocated < p - document + len + 200)
		{
		  /* Expand to guarantee sufficient storage.  */
		  uintptr_t document_len = p - document;

		  document = xrealloc (document, 2 * allocated);
		  allocated *= 2;
		  p = document + document_len;
		}

	      name = xml_escape_text ((char *) libname);
	      p += sprintf (p, "<library name=\"%s\" lm=\"0x%lx\" "
			    "l_addr=\"0x%lx\" l_ld=\"0x%lx\"/>",
			    name, (unsigned long) lm_addr,
			    (unsigned long) l_addr, (unsigned long) l_ld);
	      free (name);
	    }
	}

      lm_prev = lm_addr;
      lm_addr = l_next;
    }

  if (!header_done)
    {
      /* Empty list; terminate `<library-list-svr4'.  */
      strcpy (p, "/>");
    }
  else
    strcpy (p, "</library-list-svr4>");

  document_len = strlen (document);
  if (offset < document_len)
    document_len -= offset;
  else
    document_len = 0;
  if (len > document_len)
    len = document_len;

  memcpy (readbuf, document + offset, len);
  xfree (document);

  return len;
}

#ifdef HAVE_LINUX_BTRACE

/* Enable branch tracing.  */

static struct btrace_target_info *
linux_low_enable_btrace (ptid_t ptid)
{
  struct btrace_target_info *tinfo;

  tinfo = linux_enable_btrace (ptid);

  if (tinfo != NULL)
    {
      struct thread_info *thread = find_thread_ptid (ptid);
      struct regcache *regcache = get_thread_regcache (thread, 0);

      tinfo->ptr_bits = register_size (regcache->tdesc, 0) * 8;
    }

  return tinfo;
}

/* Read branch trace data as btrace xml document.  */

static void
linux_low_read_btrace (struct btrace_target_info *tinfo, struct buffer *buffer,
		       int type)
{
  VEC (btrace_block_s) *btrace;
  struct btrace_block *block;
  int i;

  btrace = linux_read_btrace (tinfo, type);

  buffer_grow_str (buffer, "<!DOCTYPE btrace SYSTEM \"btrace.dtd\">\n");
  buffer_grow_str (buffer, "<btrace version=\"1.0\">\n");

  for (i = 0; VEC_iterate (btrace_block_s, btrace, i, block); i++)
    buffer_xml_printf (buffer, "<block begin=\"0x%s\" end=\"0x%s\"/>\n",
		       paddress (block->begin), paddress (block->end));

  buffer_grow_str (buffer, "</btrace>\n");

  VEC_free (btrace_block_s, btrace);
}
#endif /* HAVE_LINUX_BTRACE */

static struct target_ops linux_target_ops = {
  linux_create_inferior,
  linux_attach,
  linux_kill,
  linux_detach,
  linux_mourn,
  linux_join,
  linux_thread_alive,
  linux_resume,
  linux_wait,
  linux_fetch_registers,
  linux_store_registers,
  linux_prepare_to_access_memory,
  linux_done_accessing_memory,
  linux_read_memory,
  linux_write_memory,
  linux_look_up_symbols,
  linux_request_interrupt,
  linux_read_auxv,
  linux_insert_point,
  linux_remove_point,
  linux_stopped_by_watchpoint,
  linux_stopped_data_address,
#if defined(__UCLIBC__) && defined(HAS_NOMMU)	      \
    && defined(PT_TEXT_ADDR) && defined(PT_DATA_ADDR) \
    && defined(PT_TEXT_END_ADDR)
  linux_read_offsets,
#else
  NULL,
#endif
#ifdef USE_THREAD_DB
  thread_db_get_tls_address,
#else
  NULL,
#endif
  linux_qxfer_spu,
  hostio_last_error_from_errno,
  linux_qxfer_osdata,
  linux_xfer_siginfo,
  linux_supports_non_stop,
  linux_async,
  linux_start_non_stop,
  linux_supports_multi_process,
#ifdef USE_THREAD_DB
  thread_db_handle_monitor_command,
#else
  NULL,
#endif
  linux_common_core_of_thread,
  linux_read_loadmap,
  linux_process_qsupported,
  linux_supports_tracepoints,
  linux_read_pc,
  linux_write_pc,
  linux_thread_stopped,
  NULL,
  linux_pause_all,
  linux_unpause_all,
  linux_cancel_breakpoints,
  linux_stabilize_threads,
  linux_install_fast_tracepoint_jump_pad,
  linux_emit_ops,
  linux_supports_disable_randomization,
  linux_get_min_fast_tracepoint_insn_len,
  linux_qxfer_libraries_svr4,
  linux_supports_agent,
#ifdef HAVE_LINUX_BTRACE
  linux_supports_btrace,
  linux_low_enable_btrace,
  linux_disable_btrace,
  linux_low_read_btrace,
#else
  NULL,
  NULL,
  NULL,
  NULL,
#endif
  linux_supports_range_stepping,
};

static void
linux_init_signals ()
{
  /* FIXME drow/2002-06-09: As above, we should check with LinuxThreads
     to find what the cancel signal actually is.  */
#ifndef __ANDROID__ /* Bionic doesn't use SIGRTMIN the way glibc does.  */
  signal (__SIGRTMIN+1, SIG_IGN);
#endif
}

#ifdef HAVE_LINUX_REGSETS
void
initialize_regsets_info (struct regsets_info *info)
{
  for (info->num_regsets = 0;
       info->regsets[info->num_regsets].size >= 0;
       info->num_regsets++)
    ;
}
#endif

void
initialize_low (void)
{
  struct sigaction sigchld_action;
  memset (&sigchld_action, 0, sizeof (sigchld_action));
  set_target_ops (&linux_target_ops);
  set_breakpoint_data (the_low_target.breakpoint,
		       the_low_target.breakpoint_len);
  linux_init_signals ();
  linux_ptrace_init_warnings ();

  sigchld_action.sa_handler = sigchld_handler;
  sigemptyset (&sigchld_action.sa_mask);
  sigchld_action.sa_flags = SA_RESTART;
  sigaction (SIGCHLD, &sigchld_action, NULL);

  initialize_low_arch ();
}
@


1.247
log
@[gdbserver] Split a new tracepoint.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* ax.c, linux-low.c, linux-x86-low.c, server.c: Include
	tracepoint.h.
	* server.h (IPA_BUFSIZ, initialize_tracepoint, tracing)
	(disconnected_tracing, tracepoint_look_up_symbols, stop_tracing
	(handle_tracepoint_general_set, handle_tracepoint_query)
	(tracepoint_finished_step, tracepoint_was_hit)
	(release_while_stepping_state_list, current_traceframe)
	(in_readonly_region, traceframe_read_mem)
	(fetch_traceframe_registers, traceframe_read_sdata)
	(traceframe_read_info, struct fast_tpoint_collect_status)
	(fast_tracepoint_collecting, force_unlock_trace_buffer)
	(handle_tracepoit_bkpts, initialize_low_tracepoint)
	(supply_fast_tracepoint_registers)
	(supply_static_tracepoint_registers, set_trampoline_buffer_space)
	(ipa_tdesc, claim_trampoline_space)
	(have_fast_tracepoint_trampoline_buffer, gdb_agent_about_to_close)
	(agent_mem_read, agent_get_trace_state_variable_value)
	(agent_set_trace_state_variable_value, agent_tsv_read)
	(agent_mem_read_string, get_raw_reg_func_addr)
	(get_get_tsv_func_addr, get_set_tsv_func_addr): Move to ...
	* tracepoint.h: ... this new file.
@
text
@d49 1
@


1.246
log
@PR server/15604

gdb/gdbserver/
2013-08-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c: Include filestuff.h.
	(linux_create_inferior) <pid == 0>: Call close_most_fds.
	* lynx-low.c: Include filestuff.h.
	(lynx_create_inferior) <pid == 0>: Call close_most_fds.
	* server.c: Include filestuff.h.
	(main): Call notice_open_fds.
	* spu-low.c: Include filestuff.h.
	(spu_create_inferior) <pid == 0>: Call close_most_fds.
@
text
@d48 1
@


1.245
log
@	Unify ptrace options discovery code and make both GDB and
	gdbserver use it.

	gdb/
	* Makefile.in (HFILES_NO_SRCDIR): Add nat/linux-nat.h and
	nat/linux-waitpid.h.
	(linux-waitpid.o): New object file rule.
	* common/linux-ptrace.c: Include nat/linux-waitpid.h.
	(current_ptrace_options): Moved from linux-nat.c.
	(linux_ptrace_test_ret_to_nx): Use type casts for ptrace
	parameters.
	(linux_fork_to_function): New function.
	(linux_grandchild_function): Likewise.
	(linux_child_function): Likewise.
	(linux_check_ptrace_features): New function, heavily
	based on linux-nat.c:linux_test_for_tracefork.
	(linux_enable_event_reporting): New function.
	(ptrace_supports_feature): Likewise.
	(linux_supports_tracefork): Likewise.
	(linux_supports_traceclone): Likewise.
	(linux_supports_tracevforkdone): Likewise.
	(linux_supports_tracesysgood): Likewise.
	* common/linux-ptrace.h (HAS_NOMMU): Moved from
	gdbserver/linux-low.c.
	(linux_enable_event_reporting): New declaration.
	(linux_supports_tracefork): Likewise.
	(linux_supports_traceclone): Likewise.
	(linux_supports_tracevforkdone): Likewise.
	(linux_supports_tracesysgood): Likewise.
	* config.in (PTRACE_TYPE_ARG4): Regenerate.
	* config/aarch64/linux.mh (NATDEPFILES): Add linux-waitpid.o.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Likewise.
	* config/arm/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise..
	* config/powerpc/linux.mh (NATDEPFILES): Likewise..
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/spu-linux.mh (NATDEPFILES): Likewise.
	* config/sparc/linux.mh (NATDEPFILES): Likewise.
	* config/sparc/linux64.mh (NATDEPFILES): Likewise.
	* config/tilegx/linux.mh (NATDEPFILES): Likewise.
	* config/xtensa/linux.mh (NATDEPFILES): Likewise.
	* configure.ac (AC_CACHE_CHECK): Add void * to the list of
	ptrace's 4th argument's types.
	Check the type of PTRACE_TYPE_ARG4.
	* configure: Regenerate.
	* linux-nat.c: Include nat/linux-nat.h and nat/linux-waitpid.h.
	(SYSCALL_SIGTRAP): Moved to nat/linux-nat.h.
	(linux_supports_tracefork_flag): Remove.
	(linux_supports_tracesysgood_flag): Likewise.
	(linux_supports_tracevforkdone_flag): Likewise.
	(current_ptrace_options): Moved to
	common/linux-ptrace.c.
	(linux_tracefork_child): Remove.
	(my_waitpid): Remove.
	(linux_test_for_tracefork): Renamed to
	linux_check_ptrace_features and moved to common/linux-ptrace.c.
	(linux_test_for_tracesysgood): Remove.
	(linux_supports_tracesysgood): Remove.
	(linux_supports_tracefork): Remove.
	(linux_supports_tracevforkdone): Remove.
	(linux_enable_tracesysgood): Remove.
	(linux_enable_event_reporting): Remove.
	(linux_init_ptrace): New function.
	(linux_child_post_attach): Call linux_init_ptrace.
	(linux_child_post_startup_inferior): Call linux_init_ptrace.
	(linux_child_follow_fork): Call linux_supports_tracefork
	and linux_supports_tracevforkdone.
	(linux_child_insert_fork_catchpoint): Call
	linux_supports_tracefork.
	(linux_child_insert_vfork_catchpoint): Likewise.
	(linux_child_set_syscall_catchpoint): Call
	linux_supports_tracesysgood.
	(lin_lwp_attach_lwp): Call linux_supports_tracefork.
	* nat/linux-nat.h: New file.
	* nat/linux-waitpid.c: New file.
	* nat/linux-waitpid.h: New file.

	gdb/gdbserver/
	* Makefile.in: Explain why ../target and ../nat are not
	listed as include file search paths.
	(linux-waitpid.o): New object file rule.
	* configure.srv (srv_native_linux_obj): New variable.
	Replace all occurrences of linux native object files with
	$srv_native_linux_obj.
	* linux-low.c: Include nat/linux-nat.h and nat/linux-waitpid.h.
	(HAS_NOMMU): Move defining logic to common/linux-ptrace.c.
	(linux_enable_event_reporting): Remove declaration.
	(my_waitpid): Moved to common/linux-waitpid.c.
	(linux_wait_for_event): Pass ptid when calling
	linux_enable_event_reporting.
	(linux_supports_tracefork_flag): Remove.
	(linux_enable_event_reporting): Likewise.
	(linux_tracefork_grandchild): Remove.
	(STACK_SIZE): Moved to common/linux-ptrace.c.
	(linux_tracefork_child): Remove.
	(linux_test_for_tracefork): Remove.
	(linux_look_up_symbols): Call linux_supports_traceclone.
	(initialize_low): Remove call to linux_test_for_tracefork.
	* linux-low.h (PTRACE_TYPE_ARG3): Move to
	common/linux-ptrace.h.
	(PTRACE_TYPE_ARG4): Likewise.
	Include linux-ptrace.h.
@
text
@d47 1
d584 1
@


1.244
log
@	* linux-arm-low.c: Rename all occurrences of PTRACE_ARG3_TYPE
	to PTRACE_TYPE_ARG3.
	* linux-low.c: Rename all occurrences of PTRACE_ARG3_TYPE
	to PTRACE_TYPE_ARG3 and PTRACE_ARG4_TYPE to
	PTRACE_TYPE_ARG4.
	* linux-low.h (PTRACE_ARG3_TYPE): Rename to PTRACE_TYPE_ARG3.
	(PTRACE_ARG4_TYPE): Rename to PTRACE_TYPE_ARG4.
@
text
@d24 2
a79 8
#ifdef __UCLIBC__
#if !(defined(__UCLIBC_HAS_MMU__) || defined(__ARCH_HAS_MMU__))
/* PTRACE_TEXT_ADDR and friends.  */
#include <asm/ptrace.h>
#define HAS_NOMMU
#endif
#endif

a232 1
static void linux_enable_event_reporting (int pid);
a371 75
/* Wrapper function for waitpid which handles EINTR, and emulates
   __WALL for systems where that is not available.  */

static int
my_waitpid (int pid, int *status, int flags)
{
  int ret, out_errno;

  if (debug_threads)
    fprintf (stderr, "my_waitpid (%d, 0x%x)\n", pid, flags);

  if (flags & __WALL)
    {
      sigset_t block_mask, org_mask, wake_mask;
      int wnohang;

      wnohang = (flags & WNOHANG) != 0;
      flags &= ~(__WALL | __WCLONE);
      flags |= WNOHANG;

      /* Block all signals while here.  This avoids knowing about
	 LinuxThread's signals.  */
      sigfillset (&block_mask);
      sigprocmask (SIG_BLOCK, &block_mask, &org_mask);

      /* ... except during the sigsuspend below.  */
      sigemptyset (&wake_mask);

      while (1)
	{
	  /* Since all signals are blocked, there's no need to check
	     for EINTR here.  */
	  ret = waitpid (pid, status, flags);
	  out_errno = errno;

	  if (ret == -1 && out_errno != ECHILD)
	    break;
	  else if (ret > 0)
	    break;

	  if (flags & __WCLONE)
	    {
	      /* We've tried both flavors now.  If WNOHANG is set,
		 there's nothing else to do, just bail out.  */
	      if (wnohang)
		break;

	      if (debug_threads)
		fprintf (stderr, "blocking\n");

	      /* Block waiting for signals.  */
	      sigsuspend (&wake_mask);
	    }

	  flags ^= __WCLONE;
	}

      sigprocmask (SIG_SETMASK, &org_mask, NULL);
    }
  else
    {
      do
	ret = waitpid (pid, status, flags);
      while (ret == -1 && errno == EINTR);
      out_errno = errno;
    }

  if (debug_threads)
    fprintf (stderr, "my_waitpid (%d, 0x%x): status(%x), %d\n",
	     pid, flags, status ? *status : -1, ret);

  errno = out_errno;
  return ret;
}

a4579 162
/* Non-zero if the kernel supports PTRACE_O_TRACEFORK.  */
static int linux_supports_tracefork_flag;

static void
linux_enable_event_reporting (int pid)
{
  if (!linux_supports_tracefork_flag)
    return;

  ptrace (PTRACE_SETOPTIONS, pid, (PTRACE_TYPE_ARG3) 0,
	  (PTRACE_TYPE_ARG4) PTRACE_O_TRACECLONE);
}

/* Helper functions for linux_test_for_tracefork, called via clone ().  */

static int
linux_tracefork_grandchild (void *arg)
{
  _exit (0);
}

#define STACK_SIZE 4096

static int
linux_tracefork_child (void *arg)
{
  ptrace (PTRACE_TRACEME, 0, (PTRACE_TYPE_ARG3) 0, (PTRACE_TYPE_ARG4) 0);
  kill (getpid (), SIGSTOP);

#if !(defined(__UCLIBC__) && defined(HAS_NOMMU))

  if (fork () == 0)
    linux_tracefork_grandchild (NULL);

#else /* defined(__UCLIBC__) && defined(HAS_NOMMU) */

#ifdef __ia64__
  __clone2 (linux_tracefork_grandchild, arg, STACK_SIZE,
	    CLONE_VM | SIGCHLD, NULL);
#else
  clone (linux_tracefork_grandchild, (char *) arg + STACK_SIZE,
	 CLONE_VM | SIGCHLD, NULL);
#endif

#endif /* defined(__UCLIBC__) && defined(HAS_NOMMU) */

  _exit (0);
}

/* Determine if PTRACE_O_TRACEFORK can be used to follow fork events.  Make
   sure that we can enable the option, and that it had the desired
   effect.  */

static void
linux_test_for_tracefork (void)
{
  int child_pid, ret, status;
  long second_pid;
#if defined(__UCLIBC__) && defined(HAS_NOMMU)
  char *stack = xmalloc (STACK_SIZE * 4);
#endif /* defined(__UCLIBC__) && defined(HAS_NOMMU) */

  linux_supports_tracefork_flag = 0;

#if !(defined(__UCLIBC__) && defined(HAS_NOMMU))

  child_pid = fork ();
  if (child_pid == 0)
    linux_tracefork_child (NULL);

#else /* defined(__UCLIBC__) && defined(HAS_NOMMU) */

  /* Use CLONE_VM instead of fork, to support uClinux (no MMU).  */
#ifdef __ia64__
  child_pid = __clone2 (linux_tracefork_child, stack, STACK_SIZE,
			CLONE_VM | SIGCHLD, stack + STACK_SIZE * 2);
#else /* !__ia64__ */
  child_pid = clone (linux_tracefork_child, stack + STACK_SIZE,
		     CLONE_VM | SIGCHLD, stack + STACK_SIZE * 2);
#endif /* !__ia64__ */

#endif /* defined(__UCLIBC__) && defined(HAS_NOMMU) */

  if (child_pid == -1)
    perror_with_name ("clone");

  ret = my_waitpid (child_pid, &status, 0);
  if (ret == -1)
    perror_with_name ("waitpid");
  else if (ret != child_pid)
    error ("linux_test_for_tracefork: waitpid: unexpected result %d.", ret);
  if (! WIFSTOPPED (status))
    error ("linux_test_for_tracefork: waitpid: unexpected status %d.", status);

  ret = ptrace (PTRACE_SETOPTIONS, child_pid, (PTRACE_TYPE_ARG3) 0,
		(PTRACE_TYPE_ARG4) PTRACE_O_TRACEFORK);
  if (ret != 0)
    {
      ret = ptrace (PTRACE_KILL, child_pid, (PTRACE_TYPE_ARG3) 0,
		    (PTRACE_TYPE_ARG4) 0);
      if (ret != 0)
	{
	  warning ("linux_test_for_tracefork: failed to kill child");
	  return;
	}

      ret = my_waitpid (child_pid, &status, 0);
      if (ret != child_pid)
	warning ("linux_test_for_tracefork: failed to wait for killed child");
      else if (!WIFSIGNALED (status))
	warning ("linux_test_for_tracefork: unexpected wait status 0x%x from "
		 "killed child", status);

      return;
    }

  ret = ptrace (PTRACE_CONT, child_pid, (PTRACE_TYPE_ARG3) 0,
		(PTRACE_TYPE_ARG4) 0);
  if (ret != 0)
    warning ("linux_test_for_tracefork: failed to resume child");

  ret = my_waitpid (child_pid, &status, 0);

  if (ret == child_pid && WIFSTOPPED (status)
      && status >> 16 == PTRACE_EVENT_FORK)
    {
      second_pid = 0;
      ret = ptrace (PTRACE_GETEVENTMSG, child_pid, (PTRACE_TYPE_ARG3) 0,
		    &second_pid);
      if (ret == 0 && second_pid != 0)
	{
	  int second_status;

	  linux_supports_tracefork_flag = 1;
	  my_waitpid (second_pid, &second_status, 0);
	  ret = ptrace (PTRACE_KILL, second_pid, (PTRACE_TYPE_ARG3) 0,
			(PTRACE_TYPE_ARG4) 0);
	  if (ret != 0)
	    warning ("linux_test_for_tracefork: failed to kill second child");
	  my_waitpid (second_pid, &status, 0);
	}
    }
  else
    warning ("linux_test_for_tracefork: unexpected result from waitpid "
	     "(%d, status 0x%x)", ret, status);

  do
    {
      ret = ptrace (PTRACE_KILL, child_pid, (PTRACE_TYPE_ARG3) 0,
		    (PTRACE_TYPE_ARG4) 0);
      if (ret != 0)
	warning ("linux_test_for_tracefork: failed to kill child");
      my_waitpid (child_pid, &status, 0);
    }
  while (WIFSTOPPED (status));

#if defined(__UCLIBC__) && defined(HAS_NOMMU)
  free (stack);
#endif /* defined(__UCLIBC__) && defined(HAS_NOMMU) */
}


d4589 4
a4592 4
  /* If the kernel supports tracing forks then it also supports tracing
     clones, and then we don't need to use the magic thread event breakpoint
     to learn about threads.  */
  thread_db_init (!linux_supports_tracefork_flag);
a5855 1
  linux_test_for_tracefork ();
@


1.243
log
@Normalize on PATH_MAX instead of MAXPATHLEN throughout.

With the pathmax gnulib module in place, we can use PATH_MAX
consistently throughout, instead of the current mixbag of PATH_MAX and
MAXPATHLEN uses.  It's no longer necessary to include sys/param.h
(supposedly, I can't check all ports touched here) for MAXPATHLEN.

Don't remove sys/param.h from GDB's configure.ac, as later tests in
the file use HAVE_SYS_PARAM_H checks.

Tested on x86_64 Fedora 17.

Also cross-built for --host=i686-w64-mingw32, and --host=i586-pc-msdosdjgpp.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Include "pathmax.h".
	* utils.c: Don't include sys/param.h.
	(gdb_realpath): Remove code that checks for MAXPATHLEN.
	* solib-ia64-hpux.c (ia64_hpux_handle_load_event): Use PATH_MAX
	instead of MAXPATHLEN.
	* solib-sunos.c: Don't include sys/param.h.
	* xcoffread.c: Don't include sys/param.h.
	* bsd-kvm.c: Don't include sys/param.h.
	* darwin-nat.c: Don't include sys/param.h.
	(darwin_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* darwin-nat-info.c: Don't include sys/param.h.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* i386obsd-nat.c: Don't include sys/param.h.
	* inf-child.c: Don't include sys/param.h.
	(inf_child_fileio_readlink): Use PATH_MAX instead of MAXPATHLEN.
	* linux-fork.c: Don't include sys/param.h.
	(fork_save_infrun_state): Use PATH_MAX instead of MAXPATHLEN.
	* linux-nat.c: Don't include sys/param.h.
	(linux_child_pid_to_exec_file, linux_proc_pending_signals)
	(linux_proc_pending_signals): Use PATH_MAX instead of MAXPATHLEN.
	* m68klinux-nat.c: Don't include sys/param.h.
	* nbsd-nat.c: Don't include sys/param.h.
	(nbsd_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* ppc-linux-nat.c: Don't include sys/param.h.
	* rs6000-nat.c: Don't include sys/param.h.
	* spu-linux-nat.c. Don't include sys/param.h.
	* windows-nat.c: Don't include sys/param.h.
	* xtensa-linux-nat.c: Don't include sys/param.h.
	* config/i386/nm-fbsd.h: Don't include sys/param.h.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* server.h: Include "pathmax.h".
	* linux-low.c: Don't include sys/param.h.
	(linux_pid_exe_is_elf_64_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* win32-low.c: Don't include sys/param.h.
	(win32_create_inferior): Use PATH_MAX instead of MAXPATHLEN.
@
text
@d470 1
a470 1
      ptrace (PTRACE_GETEVENTMSG, lwpid_of (event_child), (PTRACE_ARG3_TYPE) 0,
d665 1
a665 1
      ptrace (PTRACE_TRACEME, 0, (PTRACE_ARG3_TYPE) 0, (PTRACE_ARG4_TYPE) 0);
d727 1
a727 1
  if (ptrace (PTRACE_ATTACH, lwpid, (PTRACE_ARG3_TYPE) 0, (PTRACE_ARG4_TYPE) 0)
d794 1
a794 1
      ptrace (PTRACE_CONT, lwpid, (PTRACE_ARG3_TYPE) 0, (PTRACE_ARG4_TYPE) 0);
d985 1
a985 1
  ptrace (PTRACE_KILL, pid, (PTRACE_ARG3_TYPE) 0, (PTRACE_ARG4_TYPE) 0);
d1198 2
a1199 2
  if (ptrace (PTRACE_DETACH, lwpid_of (lwp), (PTRACE_ARG3_TYPE) 0,
	      (PTRACE_ARG4_TYPE) (long) sig) < 0)
d1641 1
a1641 1
			     (PTRACE_ARG3_TYPE) 0, &info) == 0
d1648 1
a1648 1
			  (PTRACE_ARG3_TYPE) 0, &info);
d1743 1
a1743 1
  ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp), (PTRACE_ARG3_TYPE) 0,
d1765 1
a1765 1
	ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp), (PTRACE_ARG3_TYPE) 0,
d2639 1
a2639 1
		  (PTRACE_ARG3_TYPE) 0, &info) == 0)
d3335 1
a3335 1
	ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp), (PTRACE_ARG3_TYPE) 0,
d3351 1
a3351 1
	  (PTRACE_ARG3_TYPE) 0,
d3354 1
a3354 1
	  (PTRACE_ARG4_TYPE) (uintptr_t) signal);
d3822 1
a3822 1
	    ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp), (PTRACE_ARG3_TYPE) 0,
d4112 1
a4112 1
		    (PTRACE_ARG3_TYPE) (long) nt_type, data);
d4187 1
a4187 1
		    (PTRACE_ARG3_TYPE) (long) nt_type, data);
d4200 1
a4200 1
			(PTRACE_ARG3_TYPE) (long) nt_type, data);
d4310 1
a4310 1
		(PTRACE_ARG3_TYPE) (uintptr_t) regaddr, (PTRACE_ARG4_TYPE) 0);
d4359 2
a4360 2
	      (PTRACE_ARG3_TYPE) (uintptr_t) regaddr,
	      (PTRACE_ARG4_TYPE) *(PTRACE_XFER_TYPE *) (buf + i));
d4554 2
a4555 2
			  (PTRACE_ARG3_TYPE) (uintptr_t) addr,
			  (PTRACE_ARG4_TYPE) 0);
d4621 2
a4622 2
		      (PTRACE_ARG3_TYPE) (uintptr_t) addr,
		      (PTRACE_ARG4_TYPE) 0);
d4633 1
a4633 1
		  (PTRACE_ARG3_TYPE) (uintptr_t) (addr + (count - 1)
d4635 1
a4635 1
		  (PTRACE_ARG4_TYPE) 0);
d4653 2
a4654 2
	      (PTRACE_ARG3_TYPE) (uintptr_t) addr,
	      (PTRACE_ARG4_TYPE) buffer[i]);
d4671 2
a4672 2
  ptrace (PTRACE_SETOPTIONS, pid, (PTRACE_ARG3_TYPE) 0,
	  (PTRACE_ARG4_TYPE) PTRACE_O_TRACECLONE);
d4688 1
a4688 1
  ptrace (PTRACE_TRACEME, 0, (PTRACE_ARG3_TYPE) 0, (PTRACE_ARG4_TYPE) 0);
d4756 2
a4757 2
  ret = ptrace (PTRACE_SETOPTIONS, child_pid, (PTRACE_ARG3_TYPE) 0,
		(PTRACE_ARG4_TYPE) PTRACE_O_TRACEFORK);
d4760 2
a4761 2
      ret = ptrace (PTRACE_KILL, child_pid, (PTRACE_ARG3_TYPE) 0,
		    (PTRACE_ARG4_TYPE) 0);
d4778 2
a4779 2
  ret = ptrace (PTRACE_CONT, child_pid, (PTRACE_ARG3_TYPE) 0,
		(PTRACE_ARG4_TYPE) 0);
d4789 1
a4789 1
      ret = ptrace (PTRACE_GETEVENTMSG, child_pid, (PTRACE_ARG3_TYPE) 0,
d4797 2
a4798 2
	  ret = ptrace (PTRACE_KILL, second_pid, (PTRACE_ARG3_TYPE) 0,
			(PTRACE_ARG4_TYPE) 0);
d4810 2
a4811 2
      ret = ptrace (PTRACE_KILL, child_pid, (PTRACE_ARG3_TYPE) 0,
		    (PTRACE_ARG4_TYPE) 0);
d4946 6
a4951 6
  text = ptrace (PTRACE_PEEKUSER, pid, (PTRACE_ARG3_TYPE) PT_TEXT_ADDR,
		 (PTRACE_ARG4_TYPE) 0);
  text_end = ptrace (PTRACE_PEEKUSER, pid, (PTRACE_ARG3_TYPE) PT_TEXT_END_ADDR,
		     (PTRACE_ARG4_TYPE) 0);
  data = ptrace (PTRACE_PEEKUSER, pid, (PTRACE_ARG3_TYPE) PT_DATA_ADDR,
		 (PTRACE_ARG4_TYPE) 0);
d5024 1
a5024 1
  if (ptrace (PTRACE_GETSIGINFO, pid, (PTRACE_ARG3_TYPE) 0, &siginfo) != 0)
d5045 1
a5045 1
      if (ptrace (PTRACE_SETSIGINFO, pid, (PTRACE_ARG3_TYPE) 0, &siginfo) != 0)
@


1.242
log
@Lazily allocate 'struct regsets_info'::disabled_regsets.

There's no need for every arch to pre-allocate disabled_regsets.
Chances are the array won't be used.

(I have a hunch that with some more work we could dispense with
initialize_regsets_info.)

Tested on x86_64 Fedora 17 w/ -lmcheck.

gdb/gdbserver/
2013-06-11  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (regset_disabled, disable_regset): New functions.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): Use them.
	(initialize_regsets_info); Don't allocate the disabled_regsets
	array here.
	* linux-low.h (struct regsets_info) <disabled_regsets>: Extend
	comment.
@
text
@a25 1
#include <sys/param.h>
d344 1
a344 1
  char file[MAXPATHLEN];
@


1.241
log
@Fix regression from multi-arch patch.

This fixes the regression reported at
<http://sourceware.org/ml/gdb-patches/2013-06/msg00185.html>.

GDBserver was reaching:

static int
regsets_fetch_inferior_registers (struct regsets_info *regsets_info,
				  struct regcache *regcache)
{
  struct regset_info *regset;
  int saw_general_regs = 0;
  int pid;
  struct iovec iov;

  regset = regsets_info->regsets;

  pid = lwpid_of (get_thread_lwp (current_inferior));
  while (regset->size >= 0)
    {
      void *buf, *data;
      int nt_type, res;

      if (regset->size == 0
	  || regsets_info->disabled_regsets[regset - regsets_info->regsets])
	{
>>>>>>>	  regset ++;      <<<<<<<  HERE
	  continue;
	}

Because info->disabled_regsets[] was not being initialized, and that
causes all sorts of wrong.

gdb/gdbserver/
2013-06-11  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (initialize_regsets_info): Use xcalloc instead of
	xmalloc.
@
text
@d4054 22
d4093 1
a4093 2
      if (regset->size == 0
	  || regsets_info->disabled_regsets[regset - regsets_info->regsets])
a4120 2
	      int dr_offset;

d4123 1
a4123 2
	      dr_offset = regset - regsets_info->regsets;
	      regsets_info->disabled_regsets[dr_offset] = 1;
d4164 1
a4164 2
      if (regset->size == 0
	  || regsets_info->disabled_regsets[regset - regsets_info->regsets])
a4210 2
	      int dr_offset;

d4213 1
a4213 2
	      dr_offset = regset - regsets_info->regsets;
	      regsets_info->disabled_regsets[dr_offset] = 1;
a6088 1
  info->disabled_regsets = xcalloc (1, info->num_regsets);
@


1.240
log
@gdb/gdbserver/
	Fix compatibility with Android Bionic.
	* linux-low.c (linux_qxfer_libraries_svr4): Ignore first entry even if
	it is not empty.
@
text
@d6075 1
a6075 1
  info->disabled_regsets = xmalloc (info->num_regsets);
@


1.239
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@d5854 7
a5860 6
      /* Not checking for error because reading may stop before
	 we've got PATH_MAX worth of characters.  */
      libname[0] = '\0';
      linux_read_memory (l_name, libname, sizeof (libname) - 1);
      libname[sizeof (libname) - 1] = '\0';
      if (libname[0] != '\0')
d5862 11
a5872 12
	  /* 6x the size for xml_escape_text below.  */
	  size_t len = 6 * strlen ((char *) libname);
	  char *name;

	  if (!header_done)
	    {
	      /* Terminate `<library-list-svr4'.  */
	      *p++ = '>';
	      header_done = 1;
	    }

	  while (allocated < p - document + len + 200)
d5874 27
a5900 6
	      /* Expand to guarantee sufficient storage.  */
	      uintptr_t document_len = p - document;

	      document = xrealloc (document, 2 * allocated);
	      allocated *= 2;
	      p = document + document_len;
a5901 12

	  name = xml_escape_text ((char *) libname);
	  p += sprintf (p, "<library name=\"%s\" lm=\"0x%lx\" "
			"l_addr=\"0x%lx\" l_ld=\"0x%lx\"/>",
			name, (unsigned long) lm_addr,
			(unsigned long) l_addr, (unsigned long) l_ld);
	  free (name);
	}
      else if (lm_prev == 0)
	{
	  sprintf (p, " main-lm=\"0x%lx\"", (unsigned long) lm_addr);
	  p = p + strlen (p);
@


1.238
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* server.c (handle_query): Add "augmented-libraries-svr4-read+"
	to qSupported response when appropriate.
	(handle_qxfer_libraries_svr4): Allow qXfer:libraries-svr4:read
	with nonzero-length annex.
	* linux-low.c (linux_qxfer_libraries_svr4): Parse and handle
	arguments supplied in annex.
@
text
@a226 9
/* This flag is true iff we've just created or attached to our first
   inferior but it has not stopped yet.  As soon as it does, we need
   to call the low target's arch_setup callback.  Doing this only on
   the first inferior avoids reinializing the architecture on every
   inferior, and avoids messing with the register caches of the
   already running inferiors.  NOTE: this assumes all inferiors under
   control of gdbserver have the same architecture.  */
static int new_inferior;

a286 5
#ifdef HAVE_LINUX_REGSETS
static char *disabled_regsets;
static int num_regsets;
#endif

a367 4
  /* Is this the first process?  If so, then set the arch.  */
  if (all_processes.head == NULL)
    new_inferior = 1;

d371 3
d1191 1
a1191 2
  regcache_invalidate_one ((struct inferior_list_entry *)
			   get_lwp_thread (lwp));
d1399 1
a1399 5
  /* Architecture-specific setup after inferior is running.
     This needs to happen after we have attached to the inferior
     and it is stopped for the first time, but before we access
     any inferior registers.  */
  if (new_inferior)
d1401 20
a1420 5
      the_low_target.arch_setup ();
#ifdef HAVE_LINUX_REGSETS
      memset (disabled_regsets, 0, num_regsets);
#endif
      new_inferior = 0;
d3346 1
a3346 2
  regcache_invalidate_one ((struct inferior_list_entry *)
			   get_lwp_thread (lwp));
d4055 2
a4056 1
regsets_fetch_inferior_registers (struct regcache *regcache)
d4063 1
a4063 1
  regset = target_regsets;
d4071 2
a4072 1
      if (regset->size == 0 || disabled_regsets[regset - target_regsets])
d4100 2
d4103 3
a4105 2
		 this process.  */
	      disabled_regsets[regset - target_regsets] = 1;
d4130 2
a4131 1
regsets_store_inferior_registers (struct regcache *regcache)
d4138 1
a4138 1
  regset = target_regsets;
d4146 2
a4147 1
      if (regset->size == 0 || disabled_regsets[regset - target_regsets])
d4194 2
d4197 3
a4199 2
		 this process.  */
	      disabled_regsets[regset - target_regsets] = 1;
d4231 2
a4232 2
#define regsets_fetch_inferior_registers(regcache) 1
#define regsets_store_inferior_registers(regcache) 1
d4240 1
a4240 1
linux_register_in_regsets (int regno)
d4246 2
a4247 2
	  && (the_low_target.regset_bitmap == NULL
	      || (the_low_target.regset_bitmap[index] & mask) != 0));
d4253 1
a4253 1
register_addr (int regnum)
d4257 1
a4257 1
  if (regnum < 0 || regnum >= the_low_target.num_regs)
d4260 1
a4260 1
  addr = the_low_target.regmap[regnum];
d4267 2
a4268 1
fetch_register (struct regcache *regcache, int regno)
d4275 1
a4275 1
  if (regno >= the_low_target.num_regs)
d4280 1
a4280 1
  regaddr = register_addr (regno);
d4284 2
a4285 1
  size = ((register_size (regno) + sizeof (PTRACE_XFER_TYPE) - 1)
d4311 2
a4312 1
store_register (struct regcache *regcache, int regno)
d4319 1
a4319 1
  if (regno >= the_low_target.num_regs)
d4324 1
a4324 1
  regaddr = register_addr (regno);
d4328 2
a4329 1
  size = ((register_size (regno) + sizeof (PTRACE_XFER_TYPE) - 1)
d4370 2
a4371 1
usr_fetch_inferior_registers (struct regcache *regcache, int regno, int all)
d4373 2
d4377 3
a4379 3
      for (regno = 0; regno < the_low_target.num_regs; regno++)
	if (all || !linux_register_in_regsets (regno))
	  fetch_register (regcache, regno);
d4382 1
a4382 1
    fetch_register (regcache, regno);
d4391 2
a4392 1
usr_store_inferior_registers (struct regcache *regcache, int regno, int all)
d4394 2
d4398 3
a4400 3
      for (regno = 0; regno < the_low_target.num_regs; regno++)
	if (all || !linux_register_in_regsets (regno))
	  store_register (regcache, regno);
d4403 1
a4403 1
    store_register (regcache, regno);
d4408 2
a4409 2
#define usr_fetch_inferior_registers(regcache, regno, all) do {} while (0)
#define usr_store_inferior_registers(regcache, regno, all) do {} while (0)
d4419 1
d4423 3
a4425 2
      if (the_low_target.fetch_register != NULL)
	for (regno = 0; regno < the_low_target.num_regs; regno++)
d4428 3
a4430 2
      all = regsets_fetch_inferior_registers (regcache);
      usr_fetch_inferior_registers (regcache, -1, all);
d4438 1
a4438 1
      use_regsets = linux_register_in_regsets (regno);
d4440 4
a4443 3
	all = regsets_fetch_inferior_registers (regcache);
      if (!use_regsets || all)
	usr_fetch_inferior_registers (regcache, regno, 1);
d4452 1
d4456 4
a4459 2
      all = regsets_store_inferior_registers (regcache);
      usr_store_inferior_registers (regcache, regno, all);
d4463 1
a4463 1
      use_regsets = linux_register_in_regsets (regno);
d4465 4
a4468 3
	all = regsets_store_inferior_registers (regcache);
      if (!use_regsets || all)
	usr_store_inferior_registers (regcache, regno, 1);
d5931 1
d5933 6
a5938 1
    tinfo->ptr_bits = register_size (0) * 8;
d6058 12
a6080 5
#ifdef HAVE_LINUX_REGSETS
  for (num_regsets = 0; target_regsets[num_regsets].size >= 0; num_regsets++)
    ;
  disabled_regsets = xmalloc (num_regsets);
#endif
d6086 2
@


1.237
log
@range stepping: gdbserver (x86 GNU/Linux)

This patch adds support for range stepping to GDBserver, teaching it
about vCont;r.

It'd be easy to enable this for all hardware single-step targets
without needing the linux_target_ops hook, however, at least PPC needs
special care, due to the fact that PPC atomic sequences can't be
hardware single-stepped through, a thing which GDBserver doesn't know
about.  So this leaves the support limited to x86/x86_64.

gdb/
2013-05-23  Pedro Alves  <palves@@redhat.com>

	* NEWS: Mention GDBserver range stepping support.

gdb/gdbserver/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* linux-low.c (lwp_in_step_range): New function.
	(linux_wait_1): If the thread was range stepping and stopped
	outside the stepping range, report the stop to GDB.  Otherwise,
	continue stepping.  Add range stepping debug output.
	(linux_set_resume_request): Copy the step range from the resume
	request to the lwp.
	(linux_supports_range_stepping): New.
	(linux_target_ops) <supports_range_stepping>: Set to
	linux_supports_range_stepping.
	* linux-low.h (struct linux_target_ops)
	<supports_range_stepping>: New field.
	(struct lwp_info) <step_range_start, step_range_end>: New fields.
	* linux-x86-low.c (x86_supports_range_stepping): New.
	(the_low_target) <supports_range_stepping>: Set to
	x86_supports_range_stepping.
	* server.c (handle_v_cont): Handle 'r' action.
	(handle_v_requests): Append ";r" if the target supports range
	stepping.
	* target.h (struct thread_resume) <step_range_start,
	step_range_end>: New fields.
	(struct target_ops) <supports_range_stepping>:
	New field.
	(target_supports_range_stepping): New macro.
@
text
@d5731 6
d5747 1
d5749 23
a5771 2
  if (priv->r_debug == 0)
    priv->r_debug = get_r_debug (pid, is_elf64);
d5773 2
a5774 5
  /* We failed to find DT_DEBUG.  Such situation will not change for this
     inferior - do not retry it.  Report it to GDB as E01, see for the reasons
     at the GDB solib-svr4.c side.  */
  if (priv->r_debug == (CORE_ADDR) -1)
    return -1;
d5776 1
a5776 1
  if (priv->r_debug == 0)
d5778 27
a5804 1
      document = xstrdup ("<library-list-svr4 version=\"1.0\"/>\n");
d5806 16
a5821 1
  else
d5823 1
a5823 19
      int allocated = 1024;
      char *p;
      const int ptr_size = is_elf64 ? 8 : 4;
      CORE_ADDR lm_addr, lm_prev, l_name, l_addr, l_ld, l_next, l_prev;
      int r_version, header_done = 0;

      document = xmalloc (allocated);
      strcpy (document, "<library-list-svr4 version=\"1.0\"");
      p = document + strlen (document);

      r_version = 0;
      if (linux_read_memory (priv->r_debug + lmo->r_version_offset,
			     (unsigned char *) &r_version,
			     sizeof (r_version)) != 0
	  || r_version != 1)
	{
	  warning ("unexpected r_debug version %d", r_version);
	  goto done;
	}
d5825 1
a5825 2
      if (read_one_ptr (priv->r_debug + lmo->r_map_offset,
			&lm_addr, ptr_size) != 0)
d5827 3
a5829 3
	  warning ("unable to read r_map from 0x%lx",
		   (long) priv->r_debug + lmo->r_map_offset);
	  goto done;
d5832 6
a5837 11
      lm_prev = 0;
      while (read_one_ptr (lm_addr + lmo->l_name_offset,
			   &l_name, ptr_size) == 0
	     && read_one_ptr (lm_addr + lmo->l_addr_offset,
			      &l_addr, ptr_size) == 0
	     && read_one_ptr (lm_addr + lmo->l_ld_offset,
			      &l_ld, ptr_size) == 0
	     && read_one_ptr (lm_addr + lmo->l_prev_offset,
			      &l_prev, ptr_size) == 0
	     && read_one_ptr (lm_addr + lmo->l_next_offset,
			      &l_next, ptr_size) == 0)
d5839 3
a5841 1
	  unsigned char libname[PATH_MAX];
d5843 1
a5843 1
	  if (lm_prev != l_prev)
d5845 3
a5847 3
	      warning ("Corrupted shared library list: 0x%lx != 0x%lx",
		       (long) lm_prev, (long) l_prev);
	      break;
d5850 1
a5850 6
	  /* Not checking for error because reading may stop before
	     we've got PATH_MAX worth of characters.  */
	  libname[0] = '\0';
	  linux_read_memory (l_name, libname, sizeof (libname) - 1);
	  libname[sizeof (libname) - 1] = '\0';
	  if (libname[0] != '\0')
d5852 6
a5857 32
	      /* 6x the size for xml_escape_text below.  */
	      size_t len = 6 * strlen ((char *) libname);
	      char *name;

	      if (!header_done)
		{
		  /* Terminate `<library-list-svr4'.  */
		  *p++ = '>';
		  header_done = 1;
		}

	      while (allocated < p - document + len + 200)
		{
		  /* Expand to guarantee sufficient storage.  */
		  uintptr_t document_len = p - document;

		  document = xrealloc (document, 2 * allocated);
		  allocated *= 2;
		  p = document + document_len;
		}

	      name = xml_escape_text ((char *) libname);
	      p += sprintf (p, "<library name=\"%s\" lm=\"0x%lx\" "
			       "l_addr=\"0x%lx\" l_ld=\"0x%lx\"/>",
			    name, (unsigned long) lm_addr,
			    (unsigned long) l_addr, (unsigned long) l_ld);
	      free (name);
	    }
	  else if (lm_prev == 0)
	    {
	      sprintf (p, " main-lm=\"0x%lx\"", (unsigned long) lm_addr);
	      p = p + strlen (p);
d5860 6
a5865 5
	  if (l_next == 0)
	    break;

	  lm_prev = lm_addr;
	  lm_addr = l_next;
d5867 1
a5867 2
    done:
      if (!header_done)
d5869 2
a5870 2
	  /* Empty list; terminate `<library-list-svr4'.  */
	  strcpy (p, "/>");
d5872 9
a5880 2
      else
	strcpy (p, "</library-list-svr4>");
d5882 2
@


1.236
log
@	* linux-low.c: Move definition checks upwards for PT_TEXT_ADDR,
	PT_DATA_ADDR and PT_TEXT_END_ADDR.  Update comments.
	(linux_read_offsets): Remove PT_TEXT_ADDR, PT_DATA_ADDR and
	PT_TEXT_END_ADDR guards.  Update comments.
	(linux_target_op) <read_offsets>: Conditionally define to
	linux_read_offsets if the target is UCLIBC and if it defines
	PT_TEXT_ADDR, PT_DATA_ADDR and PT_TEXT_END_ADDR.
@
text
@d279 10
d2350 1
d2360 1
d2654 13
a2666 8
  /* If GDB wanted this thread to single step, we always want to
     report the SIGTRAP, and let GDB handle it.  Watchpoints should
     always be reported.  So should signals we can't explain.  A
     SIGTRAP we can't explain could be a GDB breakpoint --- we may or
     not support Z0 breakpoints.  If we do, we're be able to handle
     GDB breakpoints on top of internal breakpoints, by handling the
     internal breakpoint and still reporting the event to GDB.  If we
     don't, we're out of luck, GDB won't see the breakpoint hit.  */
d2668 2
a2669 1
		   || current_inferior->last_resume_kind == resume_step
d2671 1
a2671 1
		   || (!step_over_finished
d2692 5
d2728 6
a2733 1
	fprintf (stderr, "GDB wanted to single-step, reporting event.\n");
d3432 3
d5128 9
d5995 1
@


1.235
log
@Linux: No need to set ptrace event options in fork/clone children.

Oleg Nesterov told me that the Linux kernel copies the parent's ptrace
options to fork/clone children, so there's no need for GDB to do that
manually.

I was actually a bit surprised, since I thought the ptracer had to
always set the ptrace options itself, and GDB is indeed calling
PTRACE_SETOPTIONS for each new fork child, if it'll stay attached.

Looking at the history of that code, I found that is was actually I
who added that set-ptrace-options-in-children bit, back in
http://sourceware.org/ml/gdb-patches/2009-05/msg00656.html.  But,
honestly, I don't recall why I needed that.  I think I may have just
blindly believed it was necessary.

I then looked back at the history of all the PTRACE_SETOPTIONS code we
have, and found that gdb never did copy the ptrace options before my
patch.  But, when gdbserver learnt to use PTRACE_EVENT_CLONE, at
http://sourceware.org/ml/gdb-patches/2007-10/msg00547.html, it was
made to do 'ptrace (PTRACE_SETOPTIONS, new_pid, 0,
PTRACE_O_TRACECLONE)' for all new clones.  Hmmm.  But, GDB itself
never did that, so it can't really ever have been necessary, I
believe, otherwise GDB should have been doing it too.

(GDBserver doesn't support following forks, and so naturally doesn't
do any PTRACE_SETOPTIONS on fork children.)

So this patch removes the -I believe- unnecessary ptrace syscalls.

Tested on x86_64 Fedora 17, native/gdbserver, and on x86_64 RHEL5
native/gdbserver (Linux 2.6.18, I think a ptrace-on-utrace kernel).
No regressions.

gdb/
2013-03-22  Pedro Alves  <palves@@redhat.com>

	* linux-nat.c (linux_child_follow_fork): Don't call
	linux_enable_event_reporting.
	(linux_handle_extended_wait): Don't call
	linux_enable_event_reporting.

gdb/gdbserver/
2013-03-22  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (handle_extended_wait): Don't call
	linux_enable_event_reporting.
@
text
@d87 24
d4860 8
a4867 19
#if defined(__UCLIBC__) && defined(HAS_NOMMU)
#if ! (defined(PT_TEXT_ADDR) \
       || defined(PT_DATA_ADDR) \
       || defined(PT_TEXT_END_ADDR))
#if defined(__mcoldfire__)
/* These should really be defined in the kernel's ptrace.h header.  */
#define PT_TEXT_ADDR 49*4
#define PT_DATA_ADDR 50*4
#define PT_TEXT_END_ADDR  51*4
#elif defined(BFIN)
#define PT_TEXT_ADDR 220
#define PT_TEXT_END_ADDR 224
#define PT_DATA_ADDR 228
#elif defined(__TMS320C6X__)
#define PT_TEXT_ADDR     (0x10000*4)
#define PT_DATA_ADDR     (0x10004*4)
#define PT_TEXT_END_ADDR (0x10008*4)
#endif
#endif
a4874 1
#if defined(PT_TEXT_ADDR) && defined(PT_DATA_ADDR) && defined(PT_TEXT_END_ADDR)
a4902 1
#endif
d5901 3
a5903 1
#if defined(__UCLIBC__) && defined(HAS_NOMMU)
@


1.234
log
@Extraneous NULL in linux_target_ops when HAVE_LINUX_BTRACE not defined

This fixes the followin error when HAVE_LINUX_BTRACE is not defined:

    linux-low.c:5943: error: excess elements in struct initializer
    linux-low.c:5943: error: (near initialization for 'linux_target_ops')

gdb/gdbserver/ChangeLog:

        * linux-low.c (linux_target_ops) [!HAVE_LINUX_BTRACE]:
        Remove extraneous NULL element.
@
text
@a470 2
      linux_enable_event_reporting (new_pid);

@


1.233
log
@Add the gdb remote target operations for branch tracing.
We define the following packets:

  Qbtrace:bts         enable branch tracing for the current thread
                      returns "OK" or "Enn"

  Qbtrace:off         disable branch tracing for the current thread
                      returns "OK" or "Enn"

  qXfer:btrace:read   read the full branch trace data for the current thread

gdb/
	* target.h (enum target_object): Add TARGET_OBJECT_BTRACE.
	* remote.c: Include btrace.h.
	(struct btrace_target_info): New struct.
	(remote_supports_btrace): New function.
	(send_Qbtrace): New function.
	(remote_enable_btrace): New function.
	(remote_disable_btrace): New function.
	(remote_teardown_btrace): New function.
	(remote_read_btrace): New function.
	(init_remote_ops): Add btrace ops.
	(enum <unnamed>): Add btrace packets.
	(struct protocol_feature remote_protocol_features[]): Add btrace packets.
	(_initialize_remote): Add packet configuration for branch tracing.

gdbserver/
	* target.h (struct target_ops): Add btrace ops.
	(target_supports_btrace): New macro.
	(target_enable_btrace): New macro.
	(target_disable_btrace): New macro.
	(target_read_btrace): New macro.
	* gdbthread.h (struct thread_info): Add btrace field.
	* server.c: Include btrace-common.h.
	(handle_btrace_general_set): New function.
	(handle_btrace_enable): New function.
	(handle_btrace_disable): New function.
	(handle_general_set): Call handle_btrace_general_set.
	(handle_qxfer_btrace): New function.
	(struct qxfer qxfer_packets[]): Add btrace entry.
	* inferiors.c (remove_thread): Disable btrace.
	* linux-low: Include linux-btrace.h.
	(linux_low_enable_btrace): New function.
	(linux_low_read_btrace): New function.
	(linux_target_ops): Add btrace ops.
	* configure.srv (i[34567]86-*-linux*): Add linux-btrace.o.
	Add srv_linux_btrace=yes.
	(x86_64-*-linux*): Add linux-btrace.o.
	Add srv_linux_btrace=yes.
	* configure.ac: Define HAVE_LINUX_BTRACE.
	* config.in: Regenerated.
	* configure: Regenerated.
@
text
@a5942 1
  NULL,
@


1.233.2.1
log
@Extraneous NULL in linux_target_ops when HAVE_LINUX_BTRACE not defined

This fixes the followin error when HAVE_LINUX_BTRACE is not defined:

    linux-low.c:5943: error: excess elements in struct initializer
    linux-low.c:5943: error: (near initialization for 'linux_target_ops')

gdb/gdbserver/ChangeLog:

        * linux-low.c (linux_target_ops) [!HAVE_LINUX_BTRACE]:
        Remove extraneous NULL element.
@
text
@d5943 1
@


1.233.2.2
log
@PR server/15604

gdb/gdbserver/
2013-08-29  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c
	(linux_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	(lynx_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	* remote-utils.c (remote_desc, listen_desc): Remove static qualifier.
	* server.h (remote_desc, listen_desc): New declaration.
	* spu-low.c
	(spu_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
@
text
@a670 6
      else
	{
	  close (listen_desc);
	  if (gdb_connected ())
	    close (remote_desc);
	}
@


1.232
log
@PR gdb/15236: gdbserver write to linux memory with zero length corrupts stack

PROBLEM:

The function linux_write_memory () in linux-low.c allocates a buffer
on the stack to hold a copy of the data to be written.

  register PTRACE_XFER_TYPE *buffer = (PTRACE_XFER_TYPE *)
    alloca (count * sizeof (PTRACE_XFER_TYPE));

"count" is the number of bytes to be written, rounded up to the
nearest multiple of sizeof (PTRACE_XFER_TYPE) and allowing for not
being an aligned address. The function later uses

  buffer[0] = ptrace (PTRACE_PEEKTEXT, pid,
                      (PTRACE_ARG3_TYPE) (uintptr_t) addr, 0);

The problem is that this function can be called to write zero bytes on
an aligned address, for example when receiving an X packet of length 0
(used to test if 8-bit write is supported). Under these circumstances,
count can be zero.

Since in this case, buffer[0] may never have been allocated, the stack
is corrupted and gdbserver may crash.

SOLUTION:

Writing zero bytes should always succeed. The patch below returns
successfully early if the length is zero, so avoiding the stack
corruption.

Verified on the ARC GDB 7.5.1 port.

2013-03-07  Jeremy Bennett  <jeremy.bennett@@embecosm.com>

	PR server/15236

	* linux-low.c (linux_write_memory): Return early success if LEN is
	zero.
@
text
@d87 4
d5828 41
d5933 12
@


1.231
log
@Ensure ptrace() calls cast arguments 3 and 4 appropriately.

        * linux-low.c (handle_extended_wait, linux_create_inferior)
        (linux_attach_lwp_1, linux_kill_one_lwp, linux_attach_one_lwp)
        (dequeue_one_deferred_signal, linux_resume_one_thread)
        (fetch_register, linux_write_memory, linux_enable_event_reporting)
        (linux_tracefork_grandchild, linux_test_for_tracefork)
        (linux_read_offsets, linux_xfer_siginfo, linux_xfer_siginfo ): Add
        PTRACE_ARG3_TYPE and PTRACE_ARG4_TYPE cast to ptrace arguments
        where the argument is 0.
@
text
@d4484 1
a4484 1
   returns the value of errno.  */
d4503 6
@


1.230
log
@gdb/gdbserver/
	* linux-low.c (linux_resume_one_lwp): Don't check
	'lwp->bp_reinsert != 0'.
@
text
@d448 2
a449 1
      ptrace (PTRACE_GETEVENTMSG, lwpid_of (event_child), 0, &new_pid);
d645 1
a645 1
      ptrace (PTRACE_TRACEME, 0, 0, 0);
d707 2
a708 1
  if (ptrace (PTRACE_ATTACH, lwpid, 0, 0) != 0)
d774 1
a774 1
      ptrace (PTRACE_CONT, lwpid, 0, 0);
d965 1
a965 1
  ptrace (PTRACE_KILL, pid, 0, 0);
d1179 1
a1179 1
  if (ptrace (PTRACE_DETACH, lwpid_of (lwp), 0,
d1610 2
a1611 1
		  && ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp), 0, &info) == 0
d1617 2
a1618 1
		  ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp), 0, &info);
d1713 2
a1714 1
  ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp), 0, &p_sig->info);
d1735 2
a1736 1
	ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp), 0, &(*p_sig)->info);
d2606 2
a2607 1
      if (ptrace (PTRACE_GETSIGINFO, lwpid_of (event_child), 0, &info) == 0)
d3287 2
a3288 1
	ptrace (PTRACE_SETSIGINFO, lwpid_of (lwp), 0, &(*p_sig)->info);
d3303 2
a3304 1
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, lwpid_of (lwp), 0,
d3772 2
a3773 1
	    ptrace (PTRACE_GETSIGINFO, lwpid_of (lwp), 0, &p_sig->info);
d4234 1
a4234 1
		(PTRACE_ARG3_TYPE) (uintptr_t) regaddr, 0);
d4462 2
a4463 1
			  (PTRACE_ARG3_TYPE) (uintptr_t) addr, 0);
d4523 2
a4524 1
		      (PTRACE_ARG3_TYPE) (uintptr_t) addr, 0);
d4537 1
a4537 1
		  0);
d4573 2
a4574 1
  ptrace (PTRACE_SETOPTIONS, pid, 0, (PTRACE_ARG4_TYPE) PTRACE_O_TRACECLONE);
d4590 1
a4590 1
  ptrace (PTRACE_TRACEME, 0, 0, 0);
d4658 1
a4658 1
  ret = ptrace (PTRACE_SETOPTIONS, child_pid, 0,
d4662 2
a4663 1
      ret = ptrace (PTRACE_KILL, child_pid, 0, 0);
d4680 2
a4681 1
  ret = ptrace (PTRACE_CONT, child_pid, 0, 0);
d4691 2
a4692 1
      ret = ptrace (PTRACE_GETEVENTMSG, child_pid, 0, &second_pid);
d4699 2
a4700 1
	  ret = ptrace (PTRACE_KILL, second_pid, 0, 0);
d4712 2
a4713 1
      ret = ptrace (PTRACE_KILL, child_pid, 0, 0);
d4860 6
a4865 3
  text = ptrace (PTRACE_PEEKUSER, pid, (long)PT_TEXT_ADDR, 0);
  text_end = ptrace (PTRACE_PEEKUSER, pid, (long)PT_TEXT_END_ADDR, 0);
  data = ptrace (PTRACE_PEEKUSER, pid, (long)PT_DATA_ADDR, 0);
d4939 1
a4939 1
  if (ptrace (PTRACE_GETSIGINFO, pid, 0, &siginfo) != 0)
d4960 1
a4960 1
      if (ptrace (PTRACE_SETSIGINFO, pid, 0, &siginfo) != 0)
@


1.229
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d3195 1
a3195 1
      if (lwp->bp_reinsert != 0 && can_hardware_single_step ())
@


1.228
log
@gdb/gdbserver/
2012-11-26  Yao Qi  <yao@@codesourcery.com>

	* configure.ac (build_warnings): Append '-Wempty-body'.
	* configure: Regenerated.
	* linux-low.c (linux_create_inferior): Use braces for empty 'if'
	body.
@
text
@d2 1
a2 1
   Copyright (C) 1995-1996, 1998-2012 Free Software Foundation, Inc.
@


1.227
log
@2012-11-15  Pierre Muller  <muller@@sourceware.org>

	ARI fixes: move gdb_wait and gdb_stat headers to common subdirectory.
	* gdb_stat.h: Delete. Moved to common directory.
	* common/gdb_stat.h: New file.
	* gdb_wait.h: Delete. Moved to common directory.
	* common/gdb_wait.h: New file.
	* Makefile.in (H_FILES_NO_SRC): Adapt to new header
	location.
	* contrib/ari/gdb_ari.sh (wait.h rule): Adapt to new gdb_wait.h
	location.
	(stat.h rule): Adapt to new gdb_stat.h location.
	* common/linux-osdata.c: Include "gdb_stat.h" header instead of
	<sys/stat.h> header.
	* common/linux-ptrace.c: Include "gdb_wait.h" header instead of
	<sys/wait.h> header.


gdbserver ChangeLog entry:

2012-11-15  Pierre Muller  <muller@@sourceware.org>

	* configure.ac (AC_CHECK_HEADERS): Add wait.h header.
	* config.in: Regenerate.
	* configure: Regenerate.
	* linux-low.c: Use "gdb_stat.h" header instead of <sys/stat.h> header.
	Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* lynx-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* remote-utils.c: Use "gdb_stat.h" header instead of <sys/stat.h>
	header.
	* server.c: Remove HAVE_WAIT_H conditional.  Use "gdb_wait.h" header
	instead of <sys/wait.h> header.
	* spu-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
@
text
@d662 3
a664 1
	    /* Errors ignored.  */;
@


1.226
log
@gdb/
	* common/linux-ptrace.c: Include gdb_assert.h.
	<__i386__> (linux_ptrace_test_ret_to_nx_instr): New declaration.
	<__i386__>: Include sys/reg.h, sys/mman.h, signal.h, sys/wait.h and
	stdint.h.
	(linux_ptrace_test_ret_to_nx, linux_ptrace_init_warnings): New
	functions.
	* common/linux-ptrace.h (linux_ptrace_init_warnings): New declarations.
	* linux-nat.c (linux_child_post_attach)
	(linux_child_post_startup_inferior): Call linux_ptrace_init_warnings.

gdb/gdbserver/
	* gdbserver/linux-low.c (initialize_low): Call
	linux_ptrace_init_warnings.
@
text
@d24 1
a24 1
#include <sys/wait.h>
d43 1
a43 1
#include <sys/stat.h>
@


1.225
log
@	Add target-side support for dynamic printf.
	* NEWS: Mention the additional style.
	* breakpoint.h (struct bp_target_info): New fields tcommands, persist.
	(struct bp_location): New field cmd_bytecode.
	* breakpoint.c: Include format.h.
	(disconnected_dprintf): New global.
	(parse_cmd_to_aexpr): New function.
	(build_target_command_list): New function.
	(insert_bp_location): Call it.
	(remove_breakpoints_pid): Skip dprintf breakpoints.
	(print_one_breakpoint_location): Ditto.
	(dprintf_style_agent): New global.
	(dprintf_style_enums): Add dprintf_style_agent.
	(update_dprintf_command_list): Add agent case.
	(agent_printf_command): New function.
	(_initialize_breakpoint): Add new commands.
	* common/ax.def (printf): New bytecode.
	* ax.h (ax_string): Declare.
	* ax-gdb.h (gen_printf): Declare.
	* ax-gdb.c: Include cli-utils.h, format.h.
	(gen_printf): New function.
	(maint_agent_print_command): New function.
	(_initialize_ax_gdb): Add maint agent-printf command.
	* ax-general.c (ax_string): New function.
	(ax_print): Add printf disassembly.
	* Makefile.in (SFILES): Add format.c
	(COMMON_OBS): Add format.o.
	* common/format.h: New file.
	* common/format.c: New file.
	* printcmd.c: Include format.h.
	(ui_printf): Call parse_format_string.
	* remote.c (remote_state): New field breakpoint_commands.
	(PACKET_BreakpointCommands): New enum.
	(remote_breakpoint_commands_feature): New function.
	(remote_protocol_features): Add new BreakpointCommands entry.
	(remote_can_run_breakpoint_commands): New function.
	(remote_add_target_side_commands): New function.
	(remote_insert_breakpoint): Call it.
	(remote_insert_hw_breakpoint): Ditto.
	(_initialize_remote): Add new packet configuration for
	target-side breakpoint commands.
	* target.h (struct target_ops): New field
	to_can_run_breakpoint_commands.
	(target_can_run_breakpoint_commands): New macro.
	* target.c (update_current_target): Handle
	to_can_run_breakpoint_commands.

	[gdbserver]
	* Makefile.in (WARN_CFLAGS_NO_FORMAT): Define.
	(ax.o): Add it to build rule.
	(ax-ipa.o): Ditto.
	(OBS): Add format.o.
	(IPA_OBS): Add format.o.
	* server.c (handle_query): Claim support for breakpoint commands.
	(process_point_options): Add command case.
	(process_serial_event): Leave running if there are printfs in
	effect.
	* mem-break.h (any_persistent_commands): Declare.
	(add_breakpoint_commands): Declare.
	(gdb_no_commands_at_breakpoint): Declare.
	(run_breakpoint_commands): Declare.
	* mem-break.c (struct point_command_list): New struct.
	(struct breakpoint): New field command_list.
	(any_persistent_commands): New function.
	(add_commands_to_breakpoint): New function.
	(add_breakpoint_commands): New function.
	(gdb_no_commands_at_breakpoint): New function.
	(run_breakpoint_commands): New function.
	* linux-low.c (linux_wait_1): Test for and run breakpoint commands
	locally.
	* ax.c: Include format.h.
	(ax_printf): New function.
	(gdb_eval_agent_expr): Add printf opcode.

	[doc]
	* gdb.texinfo (Dynamic Printf): Mention agent style and
	disconnected dprintf.
	(Maintenance Commands): Describe maint agent-printf.
	(General Query Packets): Mention BreakpointCommands feature.
	(Packets): Document commands extension to Z0 packet.
	* agentexpr.texi (Bytecode Descriptions): Document printf
	bytecode.

	[testsuite]
	* gdb.base/dprintf.exp: Add agent style tests.
@
text
@d5881 1
@


1.224
log
@gdb/gdbserver:
        * linux-low.c (linux_set_resume_request): Simplify predicate.  Add
        comment.
        * server.c (handle_v_cont): Extend comment.
@
text
@d2621 4
a2624 1
		   && gdb_condition_true_at_breakpoint (event_child->stop_pc)));
d3505 2
a3506 1
	  && gdb_condition_true_at_breakpoint (pc))
@


1.223
log
@gdb/gdbserver:

	* linux-low.c (linux_attach): Add 'static'.
@
text
@d3342 5
a3346 4
	  || (ptid_is_pid (ptid)
	      && (ptid_get_pid (ptid) == pid_of (lwp)))
	  || (ptid_get_lwp (ptid) == -1
	      && (ptid_get_pid (ptid) == pid_of (lwp))))
@


1.222
log
@	* linux-low.c (get_r_debug): Disable code using DT_MIPS_RLD_MAP
	if the platform doesn't know about it.
@
text
@d820 1
a820 1
int
@


1.221
log
@gdb/
	* solib-svr4.c (svr4_current_sos): New comment on
	svr4_current_sos_via_xfer_libraries fall back.

gdb/gdbserver/
	* linux-low.c (linux_qxfer_libraries_svr4): Return -1 if R_DEBUG is -1.

gdb/testsuite/
	* gdb.server/solib-list-lib.c: New file.
	* gdb.server/solib-list-main.c: New file.
	* gdb.server/solib-list.exp: New file.
@
text
@d5495 1
d5511 1
d5522 1
d5538 1
@


1.220
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d5654 7
a5660 1
  if (priv->r_debug == (CORE_ADDR) -1 || priv->r_debug == 0)
@


1.219
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d1065 1
a1065 1
  enum gdb_signal signo = TARGET_SIGNAL_0;
d1077 1
a1077 1
	  || thread->last_status.value.sig == TARGET_SIGNAL_0)
d1120 1
a1120 1
	   && (signo == TARGET_SIGNAL_TRAP || signo == TARGET_SIGNAL_INT))
d2265 1
a2265 1
	  if (ourstatus.value.sig != TARGET_SIGNAL_0
d2561 1
a2561 1
		  ourstatus->value.sig = TARGET_SIGNAL_0;
d2734 1
a2734 1
      ourstatus->value.sig = TARGET_SIGNAL_0;
@


1.218
log
@	* linux-low.c (linux_store_registers): Avoid the copying sequence
	when no data has been retrieved by ptrace.
@
text
@d1065 1
a1065 1
  enum target_signal signo = TARGET_SIGNAL_0;
d1105 1
a1105 1
  signo = target_signal_from_host (WSTOPSIG (status));
d1113 1
a1113 1
		 target_signal_to_string (signo));
d1127 1
a1127 1
		 target_signal_to_string (signo));
d1136 1
a1136 1
		 target_signal_to_string (signo));
d2268 1
a2268 1
	      wstat = W_STOPCODE (target_signal_to_host (ourstatus.value.sig));
d2389 1
a2389 1
	      ourstatus->value.sig = target_signal_from_host (WTERMSIG (w));
d2588 1
a2588 1
	  (pass_signals[target_signal_from_host (WSTOPSIG (w))]
d2741 1
a2741 1
      ourstatus->value.sig = target_signal_from_host (WSTOPSIG (w));
d2745 1
a2745 1
      ourstatus->value.sig = target_signal_from_host (WSTOPSIG (w));
@


1.217
log
@2012-05-22  Will Deacon  <will.deacon@@arm.com>

	* linux-low (__UCLIBC__ && !(__UCLIBC_HAS_MMU__ || __ARCH_HAS_MMU__)):
	Include asm/ptrace.h.
	(PT_TEXT_ADDR, PT_DATA_ADDR, PT_TEXT_END_ADDR): Define only if not
	already defined.
@
text
@d4452 8
a4459 5
  i *= sizeof (PTRACE_XFER_TYPE);
  i -= memaddr & (sizeof (PTRACE_XFER_TYPE) - 1);
  memcpy (myaddr,
	  (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	  i < len ? i : len);
@


1.216
log
@	* linux-low.c (linux_store_registers): Don't re-retrieve data
	with ptrace that has already been obtained from /proc.  Always
	copy any data retrieved with ptrace to the buffer supplied.
@
text
@d81 2
d4801 3
d4818 1
@


1.215
log
@2012-05-11  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* linux-low.c (enum stopping_threads_kind): New.
	(stopping_threads): Change type to `enum stopping_threads_kind'.
	(handle_extended_wait): If stopping and suspending threads, leave
	the new_lwp suspended too.
	(linux_wait_for_event): Adjust.
	(stop_all_lwps): Set `stopping_threads' to
	STOPPING_AND_SUSPENDING_THREADS or STOPPING_THREADS depending on
	whether we're suspending threads or just stopping them.  Assert no
	recursion happens.
@
text
@d4381 5
d4387 1
a4387 9
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
      / sizeof (PTRACE_XFER_TYPE);
  /* Allocate buffer of that many longwords.  */
  register PTRACE_XFER_TYPE *buffer
    = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
a4388 2
  char filename[64];
  int pid = lwpid_of (get_thread_lwp (current_inferior));
d4393 2
d4407 1
a4407 1
      if (pread64 (fd, myaddr, len, memaddr) != len)
d4409 3
a4411 1
      if (lseek (fd, memaddr, SEEK_SET) == -1 || read (fd, myaddr, len) != len)
d4413 7
d4421 3
a4423 2
	  close (fd);
	  goto no_proc;
a4424 3

      close (fd);
      return 0;
d4428 8
d4437 1
a4439 1
      errno = 0;
d4445 1
a4445 1
	return errno;
d4447 1
d4450 2
d4454 1
a4454 1
	  len);
d4456 1
a4456 1
  return 0;
@


1.214
log
@	* linux-low.h (PTRACE_ARG3_TYPE): Move macro from linux-low.c.
	(PTRACE_ARG4_TYPE): Likewise.
	(PTRACE_XFER_TYPE): Likewise.
	* linux-arm-low.c (arm_prepare_to_resume): Cast third argument of
	ptrace to PTRACE_ARG3_TYPE.
	* linux-low.c (PTRACE_ARG3_TYPE): Move macro to linux-low.h.
	(PTRACE_ARG4_TYPE): Likewise.
	(PTRACE_XFER_TYPE): Likewise.
	(linux_detach_one_lwp): Cast fourth argument of
	ptrace to long then PTRACE_ARG4_TYPE.
	(regsets_fetch_inferior_registers): Cast third argument of
	ptrace to long then PTRACE_ARG3_TYPE.
	(regsets_store_inferior_registers): Likewise.
@
text
@d175 14
a188 2
/* FIXME this is a bit of a hack, and could be removed.  */
int stopping_threads;
d476 5
d486 1
a486 1
	  if (stopping_threads)
d495 1
a495 1
	  if (stopping_threads)
d1835 1
a1835 1
      if (!stopping_threads
d1983 1
a1983 1
			 || stopping_threads);
d3092 6
a3097 1
  stopping_threads = 1;
d3104 1
a3104 1
  stopping_threads = 0;
@


1.213
log
@Check if GDBserver is compatible with process

	PR gdb/13969
	* linux-low.c (linux_pid_exe_is_elf_64_file): Also return the
	e_machine field.
	(linux_qxfer_libraries_svr4): Update call to elf_64_file_p.
	* linux-low.h (linux_pid_exe_is_elf_64_file): Updated.
	* linux-x86-low.c (x86_arch_setup): Check if GDBserver is
	compatible with process.
@
text
@a243 4
#define PTRACE_ARG3_TYPE void *
#define PTRACE_ARG4_TYPE void *
#define PTRACE_XFER_TYPE long

d1156 2
a1157 1
  if (ptrace (PTRACE_DETACH, lwpid_of (lwp), 0, sig) < 0)
d3997 2
a3998 1
      res = ptrace (regset->get_request, pid, nt_type, data);
d4071 2
a4072 1
      res = ptrace (regset->get_request, pid, nt_type, data);
d4084 2
a4085 1
	  res = ptrace (regset->set_request, pid, nt_type, data);
@


1.212
log
@	* linux-low.c (get_r_debug): Handle DT_MIPS_RLD_MAP.
@
text
@d266 1
a266 1
elf_64_header_p (const Elf64_Ehdr *header)
d268 11
a278 5
  return (header->e_ident[EI_MAG0] == ELFMAG0
          && header->e_ident[EI_MAG1] == ELFMAG1
          && header->e_ident[EI_MAG2] == ELFMAG2
          && header->e_ident[EI_MAG3] == ELFMAG3
          && header->e_ident[EI_CLASS] == ELFCLASS64);
d286 1
a286 1
elf_64_file_p (const char *file)
d302 1
a302 1
  return elf_64_header_p (&header);
d309 1
a309 1
linux_pid_exe_is_elf_64_file (int pid)
d314 1
a314 1
  return elf_64_file_p (file);
d5593 1
d5602 1
a5602 1
  is_elf64 = elf_64_file_p (filename);
@


1.211
log
@	* configure.ac: Check whether Elf32_auxv_t and Elf64_auxv_t
	are available.
	* linux-low.c [HAVE_ELF32_AUXV_T] (Elf32_auxv_t): Add typedef.
	[HAVE_ELF64_AUXV_T] (Elf64_auxv_t): Likewise.
	* config.in: Regenerate.
	* configure: Likewise.
@
text
@d5422 3
a5424 1
   can be 0 if the inferior does not yet have the library list initialized.  */
d5432 1
d5436 1
a5436 1
    return (CORE_ADDR) -1;
d5443 15
d5459 2
a5460 2
	  if (dyn->d_tag == DT_DEBUG)
	    return dyn->d_un.d_val;
d5468 15
d5484 2
a5485 2
	  if (dyn->d_tag == DT_DEBUG)
	    return dyn->d_un.d_val;
d5494 1
a5494 1
  return (CORE_ADDR) -1;
@


1.210
log
@2012-03-29  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (regsets_store_inferior_registers) [__sparc__]:
	Correct ptrace arguments.
@
text
@d85 30
@


1.209
log
@2012-03-28  Pedro Alves  <palves@@redhat.com>

	* linux-ia64-low.c (ia64_regmap): Map IA64_EC_REGNUM to PT_AR_EC.
	(IA64_GR0_REGNUM, IA64_FR0_REGNUM)
	(IA64_FR1_REGNUM): New defines.
	(ia64_fetch_register): New.
	(the_low_target): Install it.
	* linux-low.h (struct linux_target_ops) <fetch_register>: New
	field.
	* linux-low.c (linux_fetch_registers): Try the
	the_low_target.fetch_register hook first.

	* linux-arm-low.c (the_low_target): Adjust.
	* linux-bfin-low.c (the_low_target): Adjust.
	* linux-cris-low.c (the_low_target): Adjust.
	* linux-crisv32-low.c (the_low_target): Adjust.
	* linux-m32r-low.c (the_low_target): Adjust.
	* linux-m68k-low.c (the_low_target): Adjust.
	* linux-mips-low.c (the_low_target): Adjust.
	* linux-ppc-low.c (the_low_target): Adjust.
	* linux-s390-low.c (the_low_target): Adjust.
	* linux-sh-low.c (the_low_target): Adjust.
	* linux-sparc-low.c (the_low_target): Adjust.
	* linux-tic6x-low.c (the_low_target): Adjust.
	* linux-x86-low.c (the_low_target): Adjust.
	* linux-xtensa-low.c (the_low_target): Adjust.
@
text
@d4039 1
a4039 1
      res = ptrace (regset->get_request, pid, &iov, data);
@


1.208
log
@2012-03-26  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (linux_qxfer_libraries_svr4): Fix pasto in comment.
@
text
@d4274 4
d4279 1
a4279 1
      usr_fetch_inferior_registers (regcache, regno, all);
d4283 4
@


1.207
log
@2012-03-23  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (linux_qxfer_libraries_svr4): Terminate the
	"library-list-svr4" element's start tag when the the DSO list is
	empty.
@
text
@d5481 1
a5481 1
/* Construct qXfer:libraries:read reply.  */
@


1.206
log
@2012-03-23  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (read_one_ptr): Read the inferior's pointer through
	a variable whose type size is the same as the inferior's pointer
	size.
@
text
@d5633 7
a5639 1
      strcpy (p, "</library-list-svr4>");
@


1.205
log
@struct siginfo vs. siginfo_t

gdb/
	* amd64-linux-nat.c (amd64_linux_siginfo_fixup): Use siginfo_t instead
	of struct siginfo.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Likewise.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	* linux-nat.c (linux_nat_siginfo_fixup, siginfo_fixup)
	(linux_xfer_siginfo, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-nat.h (struct lwp_info, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Likewise.
	* procfs.c (gdb_siginfo_t): Likewise.

gdbserver/
	* linux-arm-low.c (arm_stopped_by_watchpoint): Use siginfo_t instead of
	struct siginfo.
	* linux-low.c (siginfo_fixup, linux_xfer_siginfo): Likewise.
	* linux-x86-low.c (x86_siginfo_fixup): Likewise.
	* linux-low.h: Include <signal.h>.
	(struct siginfo): Remove forward declaration.
	(struct linux_target_ops) <siginfo_fixup>: Use siginfo_t instead of
	struct siginfo.
@
text
@d5431 24
a5454 2
  *ptr = 0;
  return linux_read_memory (memaddr, (unsigned char *) ptr, ptr_size);
@


1.204
log
@gdb/
	* common/linux-procfs.c (linux_proc_get_int): New, from
	linux_proc_get_tgid, change its LWPID type to pid_t, add parameter
	field.
	(linux_proc_get_tgid): Only call linux_proc_get_int.
	(linux_proc_get_tracerpid): New.
	(linux_proc_pid_has_state): New, from linux_proc_pid_is_zombie.
	(linux_proc_pid_is_stopped, linux_proc_pid_is_zombie): Only call
	linux_proc_pid_has_state.
	* common/linux-procfs.h (linux_proc_get_tracerpid): New declaration.
	* common/linux-ptrace.c: Include linux-procfs.h and buffer.h.
	(linux_ptrace_attach_warnings): New.
	* common/linux-ptrace.h (struct buffer, linux_ptrace_attach_warnings):
	New declaration.
	* linux-nat.c: Include exceptions.h, linux-ptrace.h and buffer.h.
	(linux_nat_attach): New variables ex, buffer, message and message_s.
	Wrap to_attach by TRY_CATCH and call linux_ptrace_attach_warnings.

gdb/gdbserver/
	* linux-low.c (linux_attach_lwp_1): New variable buffer.  Call
	linux_ptrace_attach_warnings.

gdb/testsuite/
	* gdb.base/attach-twice.c: New files.
	* gdb.base/attach-twice.exp: New files.
@
text
@d4782 1
a4782 1
siginfo_fixup (struct siginfo *siginfo, void *inf_siginfo, int direction)
d4794 1
a4794 1
	memcpy (siginfo, inf_siginfo, sizeof (struct siginfo));
d4796 1
a4796 1
	memcpy (inf_siginfo, siginfo, sizeof (struct siginfo));
d4805 2
a4806 2
  struct siginfo siginfo;
  char inf_siginfo[sizeof (struct siginfo)];
@


1.203
log
@gdb/
	* Makefile.in (linux-ptrace.o): New.
	* common/linux-procfs.c (linux_proc_pid_is_zombie): New,
	from linux-nat.c.
	* common/linux-procfs.h (linux_proc_pid_is_zombie): New declaration.
	* common/linux-ptrace.c: New file.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-ptrace.o.
	* config/arm/linux.mh: Likewise.
	* config/i386/linux.mh: Likewise.
	* config/i386/linux64.mh: Likewise.
	* config/ia64/linux.mh: Likewise.
	* config/m32r/linux.mh: Likewise.
	* config/m68k/linux.mh: Likewise.
	* config/mips/linux.mh: Likewise.
	* config/pa/linux.mh: Likewise.
	* config/powerpc/linux.mh: Likewise.
	* config/powerpc/ppc64-linux.mh: Likewise.
	* config/powerpc/spu-linux.mh: Likewise.
	* config/s390/s390.mh: Likewise.
	* config/sparc/linux.mh: Likewise.
	* config/sparc/linux64.mh: Likewise.
	* config/xtensa/linux.mh: Likewise.
	* linux-nat.c (linux_lwp_is_zombie): Remove, move it to
	common/linux-procfs.c.
	(wait_lwp): Rename linux_lwp_is_zombie to linux_proc_pid_is_zombie.

gdb/gdbserver/
	* Makefile.in (linux-ptrace.o): New.
	* configure.srv (arm*-*-linux*, bfin-*-*linux*, crisv32-*-linux*)
	(cris-*-linux*, i[34567]86-*-linux*, ia64-*-linux*, m32r*-*-linux*)
	(m68*-*-linux*, m68*-*-uclinux*, mips*-*-linux*, powerpc*-*-linux*)
	(s390*-*-linux*, sh*-*-linux*, sparc*-*-linux*, tic6x-*-uclinux)
	(x86_64-*-linux*, xtensa*-*-linux*): Add linux-ptrace.o to SRV_TGTOBJ
	of these targets.
	* linux-low.c (linux_attach_lwp_1): Remove redundent else clause.
@
text
@d655 2
d667 5
a671 2
      error ("Cannot attach to lwp %ld: %s (%d)\n", lwpid,
	     strerror (errno), errno);
@


1.202
log
@2012-03-07  Pedro Alves  <palves@@redhat.com>

	gdb/doc/
	* gdb.texinfo (General Query Packets): Document new
	QProgramSignals packet.
	* gdb.texinfo (Remote configuration): Mention
	"program-signals-packet".

	gdb/gdbserver/
	* linux-low.c (get_detach_signal): New.
	(linux_detach_one_lwp): Get rid of a pending SIGSTOP with SIGCONT.
	Pass on pending signals to PTRACE_DETACH.  Check the result of the
	ptrace call.
	* server.c (program_signals, program_signals_p): New.
	(handle_general_set): Handle QProgramSignals.
	* server.h (program_signals, program_signals_p): Declare.

	gdb/
	* NEWS: Mention QProgramSignals.
	* inferior.h (update_signals_program_target): Declare.
	* infrun.c: (update_signals_program_target): New.
	(handle_command): Update the target of the new program signals
	array changes.
	* remote.c (PACKET_QProgramSignals): New enum.
	(last_program_signals_packet): New global.
	(remote_program_signals): New.
	(remote_start_remote): Update the target with the program signals
	list.
	(remote_protocol_features): Add entry for QPassSignals.
	(remote_open_1): Free anc clear last_program_signals_packet.
	(init_remote_ops): Install remote_program_signals.
	* target.c (update_current_target): Adjust.
	(target_program_signals): New.
	* target.h (struct target_ops) <to_program_signals>: New field.
	(target_program_signals): Declare.
@
text
@d663 4
a666 4
      else
	/* If we fail to attach to a process, report an error.  */
	error ("Cannot attach to lwp %ld: %s (%d)\n", lwpid,
	       strerror (errno), errno);
@


1.201
log
@gdb/gdbserver/
	* linux-low.c (get_dynamic): Don't warn when PT_PHDR isn't found.
	New comment why.
@
text
@d1002 84
d1092 1
d1097 1
a1097 3
  /* If this process is stopped but is expecting a SIGSTOP, then make
     sure we take care of that now.  This isn't absolutely guaranteed
     to collect the SIGSTOP, but is fairly likely to.  */
d1100 6
a1105 2
      int wstat;
      /* Clear stop_expected, so that the SIGSTOP will be reported.  */
a1106 2
      linux_resume_one_lwp (lwp, 0, 0, NULL);
      linux_wait_for_event (lwp->head.id, &wstat, __WALL);
d1113 3
d1119 4
a1122 1
  ptrace (PTRACE_DETACH, lwpid_of (lwp), 0, 0);
@


1.200
log
@gdb:
        * common/agent.c (agent_loaded_p): New.
        (agent_look_up_symbols): New global.
        * common/agent.h: Declare agent_loaded_p.

gdb/gdbserver:

        * Makefile.in (linux-low.o): Keep dependence on agent.h.
        (linux-x86-low.o): Likewise.
        * server.h: Remove in_process_agent_loaded.
        * tracepoint.c (in_process_agent_loaded): Removed.  Moved it
        common/agent.c.
        Update callers.
@
text
@d5253 10
a5262 1
      warning ("Unexpected missing PT_PHDR");
@


1.199
log
@gdb:
	* target.h (struct target_ops) <to_use_agent>: New field.
	(struct target_ops) <to_can_use_agent>: New field.
	(target_use_agent, target_can_use_agent): New macro.
	* target.c (update_current_target): Update.
	* remote.c: New enum `PACKET_QAgent'.
	(remote_protocol_features): Add a new element.
	(remote_use_agent, remote_can_use_agent): New.
	(init_remote_ops): Initialize field `can_use_agent' with
	remote_can_use_agent.  Intiailize field `use_agent' with
	remote_use_agent.
	* common/agent.c (use_agent): New global.
	* common/agent.h: Declare it.
	* tracepoint.c (info_static_tracepoint_markers_command): Add
	comment.
	* Makefile.in (SFILES): Add common/agent.c and agent.c.
	(COMMON_OBS): Add common/agent.o and agent.o
	(common-agent.o): New rule.
	* agent.c: New.

gdb/doc:
	* gdb.texinfo (In-Process Agent): New node.
	Document new commands.
	(General Query Packets): Add packet `QAgent'.

gdb/gdbserver:
	* linux-low.c (linux_supports_agent): New.
	(linux_target_ops): Initialize field `supports_agent' with
	linux_supports_agent.
	* target.h (struct target_ops) <supports_agent>: New.
	(target_supports_agent): New macro.
	* server.c (handle_general_set): Handle packet 'QAgent'.
	(handle_query): Send `QAgent+'.
	* Makefile.in (server.o): Depends on agent.h.
@
text
@d22 1
d1394 1
a1394 1
      && in_process_agent_loaded ())
d2325 1
a2325 1
      && in_process_agent_loaded ())
d2879 1
a2879 1
	  && in_process_agent_loaded ()
@


1.198
log
@2012-03-02  Pedro Alves  <palves@@redhat.com>

	* inferiors.c (add_pid_to_list, pull_pid_from_list): Delete.
	* linux-low.c (struct simple_pid_list): New.
	(stopped_pids): New a struct simple_pid_list pointer.
	(add_to_pid_list, pull_pid_from_list): New.
	(handle_extended_wait): Don't assume the first signal new children
	report is SIGSTOP.  Adjust call to pull_pid_from_list.
	(linux_wait_for_lwp): Adjust.
@
text
@d4857 6
d5585 1
@


1.197
log
@	gdb/
	* features/mips-dsp.xml: New file.
	* features/mips64-dsp.xml: New file.
	* features/mips-dsp-linux.xml: New file.
	* features/mips64-dsp-linux.xml: New file.
	* features/Makefile (WHICH): Add mips-dsp-linux and
	mips64-dsp-linux.
	(mips-dsp-expedite, mips64-dsp-expedite): New variables.
	* features/mips-dsp-linux.c: New file.
	* features/mips64-dsp-linux.c: New file.
	* regformats/mips-dsp-linux.dat: New file.
	* regformats/mips64-dsp-linux.dat: New file.
	* mips-linux-nat.c (mips_linux_register_addr): Handle DSP
	registers.
	(mips64_linux_register_addr): Likewise.
	(mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Update call to
	mips64_linux_regsets_fetch_registers.
	(mips64_linux_store_registers): Update call to
	mips64_linux_regsets_store_registers.
	(mips_linux_read_description): Probe for DSP registers.
	(_initialize_mips_linux_nat): Call initialize_tdesc_mips_dsp_linux
	and initialize_tdesc_mips64_dsp_linux.
	* mips-linux-tdep.c (supply_gregset, mips64_supply_gregset):
	Remove padding of no longer used embedded register slots.
	* mips-linux-tdep.h (DSP_BASE, DSP_CONTROL): New macros.
	(MIPS_RESTART_REGNUM): Redefine enum value.
	* mips-tdep.c (mips_generic_reg_names): Remove trailing null
	strings.
	(mips_tx39_reg_names): Likewise.
	(mips_linux_reg_names): New array of register names for Linux
	targets.
	(mips_register_name): Check for a null pointer in
	mips_processor_reg_names and return an empty string.
	(mips_register_type): Exclude embedded registers for the IRIX
	and Linux ABIs.
	(mips_pseudo_register_type): Likewise.  Use dynamic numbers to
	refer to FP registers, LO, HI, BadVAddr, Cause and PC.  Handle
	DSP registers.
	(mips_stab_reg_to_regnum): Handle DSP accumulators.
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	(mips_gdbarch_init): Likewise.  Initialize internal register
	indices for the Linux ABI.  Use dynamic numbers to refer to
	registers, as applicable, while parsing the target description.
	* mips-tdep.h (struct mips_regnum): Add dspacc/dspctl offsets.

	gdb/doc/
	* gdb.texinfo (MIPS Features): Add org.gnu.gdb.mips.dsp.

	gdb/gdbserver/
	* linux-low.h (linux_target_ops): Add regset_bitmap member.
	* linux-low.c (use_linux_regsets): New macro.
	[!HAVE_LINUX_REGSETS] (regsets_fetch_inferior_registers): Likewise.
	[!HAVE_LINUX_REGSETS] (regsets_store_inferior_registers): Likewise.
	(linux_register_in_regsets): New function.
	(usr_fetch_inferior_registers): Skip registers covered by
	regsets.
	(usr_store_inferior_registers): Likewise.
	(usr_fetch_inferior_registers): New macro.
	(usr_store_inferior_registers): Likewise.
	(linux_fetch_registers): Handle mixed regset/non-regset targets.
	(linux_store_registers): Likewise.
	* linux-mips-low.c (init_registers_mips_dsp_linux): New
	prototype.
	(init_registers_mips64_dsp_linux): Likewise.
	(init_registers_mips_linux): New macro.
	(init_registers_mips_dsp_linux): Likewise.
	(mips_dsp_num_regs): Likewise.
	(DSP_BASE, DSP_CONTROL): New fallback macros.
	(mips_base_regs): New macro.
	(mips_regmap): Use it.  Fix the size.
	(mips_dsp_regmap): New variable.
	(mips_dsp_regset_bitmap): Likewise.
	(mips_arch_setup): New function.
	(mips_cannot_fetch_register): Use the_low_target.regmap rather
	than mips_regmap.
	(mips_cannot_store_register): Likewise.
	(the_low_target): Update .arch_setup, .num_regs and .regmap
	initializers.  Add .regset_bitmap initializer.
	* linux-arm-low.c (the_low_target): Add .regset_bitmap
	initializer.
	* linux-bfin-low.c (the_low_target): Likewise.
	* linux-cris-low.c (the_low_target): Likewise.
	* linux-crisv32-low.c (the_low_target): Likewise.
	* linux-ia64-low.c (the_low_target): Likewise.
	* linux-m32r-low.c (the_low_target): Likewise.
	* linux-m68k-low.c (the_low_target): Likewise.
	* linux-ppc-low.c (the_low_target): Likewise.
	* linux-s390-low.c (the_low_target): Likewise.
	* linux-sh-low.c (the_low_target): Likewise.
	* linux-sparc-low.c (the_low_target): Likewise.
	* linux-tic6x-low.c (the_low_target): Likewise.
	* linux-x86-low.c (the_low_target): Likewise.
	* linux-xtensa-low.c (the_low_target): Likewise.
	* configure.srv <mips*-*-linux*>: Add mips-dsp-linux.o and
	mips64-dsp-linux.o to srv_regobj.  Add mips-dsp-linux.xml,
	mips64-dsp-linux.xml, mips-dsp.xml and mips64-dsp.xml to
	srv_xmlfiles.
	* Makefile.in (mips-dsp-linux.o, mips-dsp-linux.c): New targets.
	(mips64-dsp-linux.o, mips64-dsp-linux.c): Likewise.

	gdb/testsuite/
	* gdb.xml/tdesc-regs.exp: Add "mips-dsp.xml" to the list of MIPS
	core registers.
@
text
@d95 3
a97 3
/* A list of all unknown processes which receive stop signals.  Some other
   process will presumably claim each of these as forked children
   momentarily.  */
d99 44
a142 1
struct inferior_list stopped_pids;
d399 1
a399 1
      int ret, status = W_STOPCODE (SIGSTOP);
d404 1
a404 1
      if (! pull_pid_from_list (&stopped_pids, new_pid))
d1216 1
a1216 1
      add_pid_to_list (&stopped_pids, ret);
@


1.196
log
@gdb/gdbserver:

2012-02-29  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* linux-low.c (linux_wait_1): Call unsuspend_all_lwps when
	`step_over_finished' is true.

gdb/testsuite:

2012-02-29  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.trace/trace-mt.c: New
	* gdb.trace/trace-mt.exp: New.
@
text
@a3783 1
#ifdef HAVE_LINUX_USRREGS
d3785 1
a3785 21
int
register_addr (int regnum)
{
  int addr;

  if (regnum < 0 || regnum >= the_low_target.num_regs)
    error ("Invalid register number %d.", regnum);

  addr = the_low_target.regmap[regnum];

  return addr;
}

/* Fetch one register.  */
static void
fetch_register (struct regcache *regcache, int regno)
{
  CORE_ADDR regaddr;
  int i, size;
  char *buf;
  int pid;
d3787 1
a3787 114
  if (regno >= the_low_target.num_regs)
    return;
  if ((*the_low_target.cannot_fetch_register) (regno))
    return;

  regaddr = register_addr (regno);
  if (regaddr == -1)
    return;

  size = ((register_size (regno) + sizeof (PTRACE_XFER_TYPE) - 1)
	  & -sizeof (PTRACE_XFER_TYPE));
  buf = alloca (size);

  pid = lwpid_of (get_thread_lwp (current_inferior));
  for (i = 0; i < size; i += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      *(PTRACE_XFER_TYPE *) (buf + i) =
	ptrace (PTRACE_PEEKUSER, pid,
		/* Coerce to a uintptr_t first to avoid potential gcc warning
		   of coercing an 8 byte integer to a 4 byte pointer.  */
		(PTRACE_ARG3_TYPE) (uintptr_t) regaddr, 0);
      regaddr += sizeof (PTRACE_XFER_TYPE);
      if (errno != 0)
	error ("reading register %d: %s", regno, strerror (errno));
    }

  if (the_low_target.supply_ptrace_register)
    the_low_target.supply_ptrace_register (regcache, regno, buf);
  else
    supply_register (regcache, regno, buf);
}

/* Store one register.  */
static void
store_register (struct regcache *regcache, int regno)
{
  CORE_ADDR regaddr;
  int i, size;
  char *buf;
  int pid;

  if (regno >= the_low_target.num_regs)
    return;
  if ((*the_low_target.cannot_store_register) (regno))
    return;

  regaddr = register_addr (regno);
  if (regaddr == -1)
    return;

  size = ((register_size (regno) + sizeof (PTRACE_XFER_TYPE) - 1)
	  & -sizeof (PTRACE_XFER_TYPE));
  buf = alloca (size);
  memset (buf, 0, size);

  if (the_low_target.collect_ptrace_register)
    the_low_target.collect_ptrace_register (regcache, regno, buf);
  else
    collect_register (regcache, regno, buf);

  pid = lwpid_of (get_thread_lwp (current_inferior));
  for (i = 0; i < size; i += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      ptrace (PTRACE_POKEUSER, pid,
	    /* Coerce to a uintptr_t first to avoid potential gcc warning
	       about coercing an 8 byte integer to a 4 byte pointer.  */
	      (PTRACE_ARG3_TYPE) (uintptr_t) regaddr,
	      (PTRACE_ARG4_TYPE) *(PTRACE_XFER_TYPE *) (buf + i));
      if (errno != 0)
	{
	  /* At this point, ESRCH should mean the process is
	     already gone, in which case we simply ignore attempts
	     to change its registers.  See also the related
	     comment in linux_resume_one_lwp.  */
	  if (errno == ESRCH)
	    return;

	  if ((*the_low_target.cannot_store_register) (regno) == 0)
	    error ("writing register %d: %s", regno, strerror (errno));
	}
      regaddr += sizeof (PTRACE_XFER_TYPE);
    }
}

/* Fetch all registers, or just one, from the child process.  */
static void
usr_fetch_inferior_registers (struct regcache *regcache, int regno)
{
  if (regno == -1)
    for (regno = 0; regno < the_low_target.num_regs; regno++)
      fetch_register (regcache, regno);
  else
    fetch_register (regcache, regno);
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */
static void
usr_store_inferior_registers (struct regcache *regcache, int regno)
{
  if (regno == -1)
    for (regno = 0; regno < the_low_target.num_regs; regno++)
      store_register (regcache, regno);
  else
    store_register (regcache, regno);
}
#endif /* HAVE_LINUX_USRREGS */



#ifdef HAVE_LINUX_REGSETS
a3947 1
  return 0;
d3950 174
a4123 1
#endif /* HAVE_LINUX_REGSETS */
d4129 16
a4144 7
#ifdef HAVE_LINUX_REGSETS
  if (regsets_fetch_inferior_registers (regcache) == 0)
    return;
#endif
#ifdef HAVE_LINUX_USRREGS
  usr_fetch_inferior_registers (regcache, regno);
#endif
d4150 16
a4165 7
#ifdef HAVE_LINUX_REGSETS
  if (regsets_store_inferior_registers (regcache) == 0)
    return;
#endif
#ifdef HAVE_LINUX_USRREGS
  usr_store_inferior_registers (regcache, regno);
#endif
@


1.195
log
@2012-02-27  Pedro Alves  <palves@@redhat.com>

	gdb/gdbserver/
	* linux-low.c (pid_is_stopped): Delete, moved to common/.
	(linux_attach_lwp_1): Adjust to use linux_proc_pid_is_stopped.

	gdb/
	* linux-nat.c (pid_is_stopped): Delete, moved to common/.
	(linux_nat_post_attach_wait): Adjust to use
	linux_proc_pid_is_stopped.

	* common/linux-procfs.h (linux_proc_pid_is_stopped): Declare.
	* common/linux-procfs.c (linux_proc_pid_is_stopped): New function,
	based on pid_is_stopped from both linux-nat.c and
	gdbserver/linux-low.c, and renamed.
@
text
@d2512 9
@


1.194
log
@2012-02-27  Pedro Alves  <palves@@redhat.com>

	PR server/9684
	* linux-low.c (pid_is_stopped): New.
	(linux_attach_lwp_1): Handle attaching to 'T (stopped)' processes.
@
text
@a600 31
/* Detect `T (stopped)' in `/proc/PID/status'.
   Other states including `T (tracing stop)' are reported as false.  */

static int
pid_is_stopped (pid_t pid)
{
  FILE *status_file;
  char buf[100];
  int retval = 0;

  snprintf (buf, sizeof (buf), "/proc/%d/status", (int) pid);
  status_file = fopen (buf, "r");
  if (status_file != NULL)
    {
      int have_state = 0;

      while (fgets (buf, sizeof (buf), status_file))
	{
	  if (strncmp (buf, "State:", 6) == 0)
	    {
	      have_state = 1;
	      break;
	    }
	}
      if (have_state && strstr (buf, "T (stopped)") != NULL)
	retval = 1;
      fclose (status_file);
    }
  return retval;
}

d646 1
a646 1
  if (pid_is_stopped (lwpid))
@


1.193
log
@2012-02-24  Luis Machado  <lgustavo@@codesourcery>

	* server.c (handle_query): Advertise support for target-side
	breakpoint condition evaluation.
	(process_point_options): New function.
	(process_serial_event): When inserting a breakpoint, check for
	a target-side condition that should be evaluated.

	* mem-break.c: Include regcache.h and ax.h.
	(point_cond_list_t): New data structure.
	(breakpoint) <cond_list>: New field.
	(find_gdb_breakpoint_at): Make non-static.
	(delete_gdb_breakpoint_at): Clear any target-side
	conditions.
	(clear_gdb_breakpoint_conditions): New function.
	(add_condition_to_breakpoint): Likewise.
	(add_breakpoint_condition): Likewise.
	(gdb_condition_true_at_breakpoint): Likewise.
	(gdb_breakpoint_here): Return result directly instead
	of going through a local variable.

	* mem-break.h (find_gdb_breakpoint_at): New prototype.
	(clear_gdb_breakpoint_conditions): Likewise.
	(add_breakpoint_condition): Likewise.
	(gdb_condition_true_at_breakpoint): Likewise.

	* linux-low.c (linux_wait_1): Evaluate target-side breakpoint condition.
	(need_step_over_p): Take target-side breakpoint condition into
	consideration.
@
text
@d601 31
d677 27
@


1.192
log
@2012-02-02  Pedro Alves  <palves@@redhat.com>

	Try SIGKILL first, then PTRACE_KILL.
	* linux-low.c (linux_kill_one_lwp): New.
	(linux_kill_one_lwp): Rename to ...
	(kill_one_lwp_callback): ... this.  Use the new
	linux_kill_one_lwp.
@
text
@d2401 2
a2402 1
		   || gdb_breakpoint_here (event_child->stop_pc));
d3265 4
a3268 2
	 though.  */
      if (gdb_breakpoint_here (pc))
@


1.191
log
@2012-01-27  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (linux_child_pid_to_exec_file): Delete.
	(elf_64_file_p): Make static.
	(linux_pid_exe_is_elf_64_file): New.
	* linux-low.h (linux_child_pid_to_exec_file, elf_64_file_p):
	Delete declarations.
	(linux_pid_exe_is_elf_64_file): Declare.
	* linux-x86-low.c (x86_arch_setup): Use
	linux_pid_exe_is_elf_64_file.
@
text
@d804 40
a843 1
/* Kill the inferior lwp.  */
d846 1
a846 1
linux_kill_one_lwp (struct inferior_list_entry *entry, void *args)
d871 1
a871 1
      ptrace (PTRACE_KILL, lwpid_of (lwp), 0, 0);
d896 1
a896 1
  find_inferior (&all_threads, linux_kill_one_lwp, &pid);
d916 1
a916 1
	  ptrace (PTRACE_KILL, lwpid_of (lwp), 0, 0);
@


1.190
log
@gdb/gdbserver/
	* linux-low.c (linux_wait_for_event_1): Rename to ...
	(linux_wait_for_event): ... here and merge it with former
	linux_wait_for_event - new variable wait_ptid, use it.
	(linux_wait_for_event): Remove - merge it to linux_wait_for_event_1.
@
text
@a188 26
/* Accepts an integer PID; Returns a string representing a file that
   can be opened to get info for the child process.
   Space for the result is malloc'd, caller must free.  */

char *
linux_child_pid_to_exec_file (int pid)
{
  char *name1, *name2;

  name1 = xmalloc (MAXPATHLEN);
  name2 = xmalloc (MAXPATHLEN);
  memset (name2, 0, MAXPATHLEN);

  sprintf (name1, "/proc/%d/exe", pid);
  if (readlink (name1, name2, MAXPATHLEN) > 0)
    {
      free (name1);
      return name2;
    }
  else
    {
      free (name2);
      return name1;
    }
}

d205 1
a205 1
int
d225 12
@


1.189
log
@gdb/gdbserver/
	Code cleanup.
	* linux-low.c (linux_wait_for_event_1): Use ptid_is_pid.
@
text
@d1572 1
a1572 1
linux_wait_for_event_1 (ptid_t ptid, int *wstat, int options)
d1575 1
d1624 11
d1641 1
a1641 1
      event_child = linux_wait_for_lwp (ptid, wstat, options);
d1653 13
a1757 42
static int
linux_wait_for_event (ptid_t ptid, int *wstat, int options)
{
  ptid_t wait_ptid;

  if (ptid_is_pid (ptid))
    {
      /* A request to wait for a specific tgid.  This is not possible
	 with waitpid, so instead, we wait for any child, and leave
	 children we're not interested in right now with a pending
	 status to report later.  */
      wait_ptid = minus_one_ptid;
    }
  else
    wait_ptid = ptid;

  while (1)
    {
      int event_pid;

      event_pid = linux_wait_for_event_1 (wait_ptid, wstat, options);

      if (event_pid > 0
	  && ptid_is_pid (ptid) && ptid_get_pid (ptid) != event_pid)
	{
	  struct lwp_info *event_child
	    = find_lwp_pid (pid_to_ptid (event_pid));

	  if (! WIFSTOPPED (*wstat))
	    mark_lwp_dead (event_child, *wstat);
	  else
	    {
	      event_child->status_pending_p = 1;
	      event_child->status_pending = *wstat;
	    }
	}
      else
	return event_pid;
    }
}


@


1.188
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1581 1
a1581 2
  if (ptid_equal (ptid, minus_one_ptid)
      || ptid_equal (pid_to_ptid (ptid_get_pid (ptid)), ptid))
@


1.187
log
@gdb/gdbserver/
	* linux-low.c (linux_create_inferior): Put empty if clause for write.

	Revert:
	2011-12-18  Hui Zhu  <teawater@@gmail.com>
	* linux-low.c (linux_create_inferior): Save return value to ret.
@
text
@d2 1
a2 2
   Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.186
log
@2011-12-18  Hui Zhu  <teawater@@gmail.com>

	* linux-low.c (linux_create_inferior): Save return value to ret.
@
text
@a576 1
	  int ret;
d580 3
a582 2
	  ret = write (2, "stdin/stdout redirected\n",
		       sizeof ("stdin/stdout redirected\n") - 1);
@


1.185
log
@	* NEWS: Add entry for stdio gdbserver.

	gdbserver/
	* linux-low.c (linux_create_inferior): If stdio connection,
	redirect stdin from /dev/null, stdout to stderr.
	* remote-utils.c (remote_is_stdio): New static global.
	(remote_connection_is_stdio): New function.
	(remote_prepare): Handle stdio connection.
	(remote_open): Ditto.
	(remote_close): Don't close stdin for stdio connections.
	(read_prim,write_prim): New functions.  Replace all calls to
	read/write to these.
	* server.c (main): Watch for "-" argument.  Move call to
	remote_prepare before start_inferior.
	* server.h (STDIO_CONNECTION_NAME): New macro.
	(remote_connection_is_stdio): Declare.

	doc/
	* gdb.texinfo (Server): Document -/stdio argument to gdbserver.

	testsuite/
	* lib/gdbserver-support.exp (gdb_target_cmd): Recognize stdio
	gdbserver output.
	(gdbserver_default_get_remote_address): New function.
	(gdbserver_start): Call gdb,get_remote_address to compute argument
	to "target remote" command.
@
text
@d577 1
d581 2
a582 2
	  write (2, "stdin/stdout redirected\n",
		 sizeof ("stdin/stdout redirected\n") - 1);
@


1.184
log
@2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_detach_one_lwp): Call
	the_low_target.prepare_to_resume before detaching.
@
text
@d572 12
@


1.183
log
@gdb/gdbserver/
	* linux-low.c (linux_kill): Skip PTRACE_KILL if LWP does not exist.
	Print new debug message for such case.
@
text
@d921 2
@


1.183.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 1995-1996, 1998-2012 Free Software Foundation, Inc.
@


1.182
log
@	* linux-low.c (fetch_register, store_register): Make code
	consistent, fix formatting.
@
text
@d865 11
a875 3
  if (debug_threads)
    fprintf (stderr, "lk_1: killing lwp %ld, for pid: %d\n",
	     lwpid_of (lwp), pid);
d877 3
a879 3
  do
    {
      ptrace (PTRACE_KILL, lwpid_of (lwp), 0, 0);
d881 4
a884 3
      /* Make sure it died.  The loop is most likely unnecessary.  */
      lwpid = linux_wait_for_event (lwp->head.id, &wstat, __WALL);
    } while (lwpid > 0 && WIFSTOPPED (wstat));
@


1.181
log
@	* linux-low.c (usr_store_inferior_registers): Factor out code
	to handle individual registers into...
	(store_register): ... this new function.
@
text
@a3747 1
  pid = lwpid_of (get_thread_lwp (current_inferior));
d3749 1
a3749 1
	  & - sizeof (PTRACE_XFER_TYPE));
d3751 2
d3783 1
a3783 2

  if ((*the_low_target.cannot_store_register) (regno) == 1)
d3789 3
a3791 3
  errno = 0;
  size = (register_size (regno) + sizeof (PTRACE_XFER_TYPE) - 1)
	 & - sizeof (PTRACE_XFER_TYPE);
@


1.180
log
@gdb/
	* Makefile.in (XMLFILES): Add library-list-svr4.dtd.
	* features/library-list-svr4.dtd: New file.
	* remote.c (PACKET_qXfer_libraries_svr4): New.
	(remote_protocol_features): new entry for PACKET_qXfer_libraries_svr4.
	(remote_xfer_partial): Handle TARGET_OBJECT_LIBRARIES_SVR4.
	* solib-svr4.c (struct svr4_library_list): New.
	[HAVE_LIBEXPAT]: Include xml-support.h.
	[HAVE_LIBEXPAT] (svr4_library_list_start_library)
	[HAVE_LIBEXPAT] (svr4_library_list_start_list, svr4_library_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_children)
	[HAVE_LIBEXPAT] (svr4_library_list_attributes)
	[HAVE_LIBEXPAT] (svr4_library_list_elements, svr4_parse_libraries)
	[HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries)
	[!HAVE_LIBEXPAT] (svr4_current_sos_via_xfer_libraries): New.
	(svr4_read_so_list): Extend the corruption message by addresses.
	(svr4_current_sos): New variable library_list, call
	svr4_current_sos_via_xfer_libraries.
	* target.h (enum target_object): New TARGET_OBJECT_LIBRARIES_SVR4.

gdb/gdbserver/
	* linux-low.c (get_phdr_phnum_from_proc_auxv, get_dynamic, get_r_debug)
	(read_one_ptr, struct link_map_offsets, linux_qxfer_libraries_svr4):
	New.
	(struct linux_target_ops): Install linux_qxfer_libraries_svr4.
	* linux-low.h (struct process_info_private): New member r_debug.
	* server.c (handle_qxfer_libraries): Call
	the_target->qxfer_libraries_svr4.
	(handle_qxfer_libraries_svr4): New function.
	(qxfer_packets): New entry "libraries-svr4".
	(handle_query): Check QXFER_LIBRARIES_SVR4 and report libraries-svr4.
	* target.h (struct target_ops): New member qxfer_libraries_svr4.
	* remote.c (remote_xfer_partial): Call add_packet_config_cmd for
	PACKET_qXfer_libraries_svr4.

gdb/doc/
	* gdb.texinfo (Requirements, Remote Protocol): Reference also `Library
	List Format for SVR4 Targets'.
	(General Query Packets): New item qXfer:libraries-svr4:read.
	(Library List Format for SVR4 Targets): New node.

gdb/testsuite/
	* gdb.base/solib-corrupted.exp: Suppress test on is_remote target.
	(corrupted list): Adjust the expectation.
@
text
@d3771 54
d3842 3
a3844 51
  CORE_ADDR regaddr;
  int i, size;
  char *buf;
  int pid;

  if (regno >= 0)
    {
      if (regno >= the_low_target.num_regs)
	return;

      if ((*the_low_target.cannot_store_register) (regno) == 1)
	return;

      regaddr = register_addr (regno);
      if (regaddr == -1)
	return;
      errno = 0;
      size = (register_size (regno) + sizeof (PTRACE_XFER_TYPE) - 1)
	     & - sizeof (PTRACE_XFER_TYPE);
      buf = alloca (size);
      memset (buf, 0, size);

      if (the_low_target.collect_ptrace_register)
	the_low_target.collect_ptrace_register (regcache, regno, buf);
      else
	collect_register (regcache, regno, buf);

      pid = lwpid_of (get_thread_lwp (current_inferior));
      for (i = 0; i < size; i += sizeof (PTRACE_XFER_TYPE))
	{
	  errno = 0;
	  ptrace (PTRACE_POKEUSER, pid,
		/* Coerce to a uintptr_t first to avoid potential gcc warning
		   about coercing an 8 byte integer to a 4 byte pointer.  */
		  (PTRACE_ARG3_TYPE) (uintptr_t) regaddr,
		  (PTRACE_ARG4_TYPE) *(PTRACE_XFER_TYPE *) (buf + i));
	  if (errno != 0)
	    {
	      /* At this point, ESRCH should mean the process is
		 already gone, in which case we simply ignore attempts
		 to change its registers.  See also the related
		 comment in linux_resume_one_lwp.  */
	      if (errno == ESRCH)
		return;

	      if ((*the_low_target.cannot_store_register) (regno) == 0)
		error ("writing register %d: %s", regno, strerror (errno));
	    }
	  regaddr += sizeof (PTRACE_XFER_TYPE);
	}
    }
d3846 1
a3846 2
    for (regno = 0; regno < the_low_target.num_regs; regno++)
      usr_store_inferior_registers (regcache, regno);
@


1.179
log
@2011-11-14  Stan Shebs  <stan@@codesourcery.com>
	    Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* NEWS: Document shorter fast tracepoints and qTMinFTPILen packet.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): Query target for
	the minimum instruction size for fast tracepoints.
	* target.h (struct target_ops): Add new method
	to_get_min_fast_tracepoint_insn_len.
	(target_get_min_fast_tracepoint_insn_len): New.
	* target.c (update_current_target): Set up new target operation.
	* remote.c (remote_write_bytes_aux): Fix typo.
	(remote_get_min_fast_tracepoint_insn_len): New.
	(init_remote_ops): Initialize new field.

	* gdb.texinfo (Create and Delete Tracepoints): Describe what is
	needed to get shorter fast tracepoints.
	(Tracepoint Packets): Document new qTMinFTPILen packet.

	* linux-x86-low.c (small_jump_insn): New.
	(i386_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message, build a trampoline and issue a small
	jump instruction to it.
	(x86_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message.
	(x86_get_min_fast_tracepoint_insn_len): New.
	(the_low_target): Add call to x86_get_min_fast_tracepoint_insn_len.
	* linux-low.h (struct linux_target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new operation.
	* linux-low.c (linux_install_fast_tracepoint_jump_pad): Add
	arguments.
	(linux_get_min_fast_tracepoint_insn_len): New function.
	(linux_target_op): Add new operation.
	* tracepoint.c (gdb_trampoline_buffer): New IPA variable.
	(gdb_trampoline_buffer_end): Ditto.
	(gdb_trampoline_buffer_error): Ditto.
	(struct ipa_sym_addresses): Add fields for new IPA variables.
	(symbol_list): Add entries for new IPA variables.
	(struct tracepoint): Add fields to hold the address range of the
	trampoline used by the tracepoint.
	(trampoline_buffer_head): New static variable.
	(trampoline_buffer_tail): Ditto.
	(claim_trampoline_space): New function.
	(have_fast_tracepoint_trampoline_buffer): New function.
	(clone_fast_tracepoint): Fill in trampoline fields of tracepoint
	structure.
	(install_fast_tracepoint): Ditto, also add error buffer argument.
	(cmd_qtminftpilen): New function.
	(handle_tracepoint_query): Add response to qTMinFTPILen packet.
	(fast_tracepoint_from_trampoline_address): New function.
	(fast_tracepoint_collecting): Handle trampoline as part of jump
	pad space.
	(set_trampoline_buffer_space): New function.
	(initialize_tracepoint): Initialize new IPA variables.
	* target.h (struct target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new
	get_min_fast_tracepoint_insn_len operation.
	(target_get_min_fast_tracepoint_insn_len): New.
	(install_fast_tracepoint_jump_pad): Add arguments.
	* server.h (IPA_BUFSIZ): Define.
	* linux-i386-ipa.c: Include extra header files.
	(initialize_fast_tracepoint_trampoline_buffer): New function.
	(initialize_low_tracepoint): Call it.
	* server.h (set_trampoline_buffer_space): Declare.
	(claim_trampoline_space): Ditto.
	(have_fast_tracepoint_trampoline_buffer): Ditto.

	* gdb.trace/ftrace.c: New.
	* gdb.trace/ftrace.exp: New.
@
text
@d4967 376
d5405 1
@


1.178
log
@	* inferior.h (disable_randomization): Declare.
	* infrun.c (disable_randomization): New global variable.
	(show_disable_randomization): New function.
	(set_disable_randomization): Likewise.
	(_initialize_infrun): Install set/show disable-randomization
	commands.
	* linux-nat.c (disable_randomization): Remove.
	(show_disable_randomization): Likewise.
	(set_disable_randomization): Likewise.
	(_initialize_linux_nat): No longer install set/show
	disable-randomization commands here.
	(linux_nat_supports_disable_randomization): New function.
	(linux_nat_add_target): Install it.
	* remote.c (PACKET_QDisableRandomization): New enum value.
	(remote_protocol_packets): Support QDisableRandomization.
	(_initialize_remote): Likewise.
	(remote_supports_disable_randomization): New function.
	(init_remote_ops): Install it.
	(extended_remote_supports_disable_randomization): New function.
	(init_extended_remote_ops): Install it.
	(extended_remote_disable_randomization): New function.
	(extended_remote_create_inferior_1): Call it.
	* target.h (struct target_ops): Add to_supports_disable_randomization.
	(target_supports_disable_randomization): Add prototype.
	* target.c (target_supports_disable_randomization): New function.
	(find_default_supports_disable_randomization): Likewise.
	(init_dummy_target): Install it.

doc/
	* gdb.texinfo (Starting your Program): "set disable-randomization"
	is no longer Linux-specific.
	(Remote Configuration): Document "set remote
	disable-randomization-packet".
	(General Query Packets): Document "QDisableRandomization" packet
	and add it to "qSupported" list.

gdbserver/
	* configure.ac: Check support for personality routine.
	* configure: Regenerate.
	* config.in: Likewise.
	* linux-low.c: Include <sys/personality.h>.
	Define ADDR_NO_RANDOMIZE if necessary.
	(linux_create_inferior): Disable address space randomization when
	forking inferior, if requested.
	(linux_supports_disable_randomization): New function.
	(linux_target_ops): Install it.
	* server.h (disable_randomization): Declare.
	* server.c (disable_randomization): New global variable.
	(handle_general_set): Handle QDisableRandomization.
	(handle_query): Likewise for qSupported.
	(main): Support --disable-randomization and --no-disable-randomization
	command line arguments.
	* target.h (struct target_ops): Add supports_disable_randomization.
	(target_supports_disable_randomization): New macro.
@
text
@d4936 2
d4941 2
a4942 1
					CORE_ADDR *adjusted_insn_addr_end)
d4946 4
a4949 2
     jump_entry, jjump_pad_insn, jjump_pad_insn_size,
     adjusted_insn_addr, adjusted_insn_addr_end);
d4961 6
d5028 1
@


1.177
log
@gdbserver: add support for FDPIC loadmaps

The DSBT support is very close to the FDPIC code, so extend the existing
loadmap support to work with FDPIC loadmaps too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d58 7
d530 3
d537 17
d582 11
d4674 9
d5015 2
a5016 1
  linux_emit_ops
@


1.176
log
@Stop threads when attaching to a PID that is the tgid.
@
text
@d4730 1
a4730 1
#if defined PT_GETDSBT
d4741 1
d4754 17
a4770 1
#endif
a4771 1
#if defined PT_GETDSBT
d4782 1
a4782 1
    addr= (int) PTRACE_GETDSBT_EXEC;
d4784 1
a4784 1
    addr = (int) PTRACE_GETDSBT_INTERP;
d4788 1
a4788 1
  if (ptrace (PT_GETDSBT, pid, addr, &data) != 0)
d4804 3
a4806 1
#endif /* defined PT_GETDSBT */
a4955 1
#if defined PT_GETDSBT
a4956 3
#else
  NULL,
#endif
@


1.175
log
@gdb/gdbserver/

	* Makefile.in (clean): Remove tic6x-*.c files.
	(linux-tic6x-low.o, tic6x-c62x-linux.o, tic6x-c64x-linux.o): New rules.
	(tic6x-c64xp-linux.o, tic6x-c62x-linux.c, tic6x-c64x-linux.c): Likewise.
	(tic6x-c64xp-linux.c): Likewise.
	* configure.srv: Add support for tic6x-*-uclinux.
	* linux-tic6x-low.c: New.
	* linux-low.c (PT_TEXT_ADDR, PT_DATA_ADDR, PT_TEXT_END_ADDR): Define.
@
text
@d29 1
d590 3
a592 1
    /* NOTE/FIXME: This lwp might have not been the tgid.  */
d627 4
a630 2
	??? If the process already has several threads we leave the other
	threads running.
d654 3
d660 2
d675 59
@


1.174
log
@        gdb/
        * remote.c (PACKET_qXfer_fdpic): New enum value.
        (remote_protocol_features): Add qXfer:fdpic:read packet.
        (remote_xfer_partial): Support TARGET_OBJECT_FDPIC.
        (_initialize_remote): Add set/show remote read-fdpic-loadmap command.
        * target.h (enum target_object): Add TARGET_OBJECT_FDPIC.

        gdb/gdbserver:
        * target.h (struct target_ops): Add read_loadmap.
        * linux-low.c (struct target_loadseg): New type.
        (struct target_loadmap): New type.
        (linux_read_loadmap): New function.
        (linux_target_ops): Add linux_read_loadmap.
        * server.c (handle_query): Support qXfer:fdpic:read packet.
	* win32-low.c (win32_target_ops): Initialize field `read_loadmap' to NULL.

        gdb/doc/
        * gdb.texinfo : Document qXfer:fdpic:read packet.
@
text
@d4350 4
@


1.173
log
@2011-07-22  Kwok Cheung Yeung  <kcy@@codesourcery.com>

gdb/
	* defs.h: Add guard against inclusion in gdbserver.
	(struct ptid, ptid_t): Move to common/ptid.h.
	(xfree, xzalloc, xasprintf, xvasprintf, xstrprintf, xstrvprintf,
	xsnprintf, internal_error): Move to common/common-utils.h.
	(nomem): Delete.
	* gdb_assert.h: Move into common/ sub-directory.
	* gdb_locale.h: Ditto.
	* gdb_dirent.h: Ditto.
	* inferior.h (minus_one_ptid, null_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid):
	Move into common/ptid.h.
	* xml-support.c (xml_escape_text): Move into common/xml-utils.c.
	(gdb_xml_create_parser_and_cleanup_1, xml_fetch_context_from_file):
	Change nomem to malloc_failure.
	* xml-support.h (xml_escape_text): Move into common/xml-utils.h.
	* utils.c (nomem): Rename to malloc_failure.
	(xmalloc, xzalloc, xrealloc, xcalloc, xfree, xstrprintf, xasprintf,
	xvasprintf, xstrvprintf, xsnprintf): Move to common/common-utils.c.
	(gdb_buildargv): Change nomem to malloc_failure.
	* infrun.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal,
	ptid_is_pid): Move into common/ptid.c.
	(initialize_infrun): Delete initialization of null_ptid and
	minus_one_ptid.
	* linux-nat.c (linux_nat_xfer_osdata): Defer to
	linux_common_xfer_osdata.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/ptid.c and common/buffer.c.
	(HFILES_NO_SRCDIR): Add common/common-utils.h, common/xml-utils.h,
	common/ptid.h, common/buffer.h and common/linux-osdata.h.
	(COMMON_OBS): Add xml-utils.o, common-utils.o, buffer.o and ptid.o.
	(common-utils.o, xml-utils.o, ptid.o, buffer.o, linux-osdata.o): New
	rules.
	* common/gdb_assert.h: New.
	* common/gdb_dirent.h: New.
	* common/gdb_locale.h: New.
	* common/buffer.c: New.
	* common/buffer.h: New.
	* common/ptid.c: New.
	* common/ptid.h: New.
	* common/xml-utils.c: New.
	* common/xml-utils.h: New.
	* common/common-utils.c: New.
	* common/common-utils.h: New.
	* common/linux-osdata.c: New.
	* common/linux-osdata.h: New.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Add linux-osdata.o.
	* config/arm/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux.mh (NATDEPFILES): Ditto.
	* config/i386/linux64.mh (NATDEPFILES): Ditto.
	* config/ia64/linux.mh (NATDEPFILES): Ditto.
	* config/m32r/linux.mh (NATDEPFILES): Ditto.
	* config/m68k/linux.mh (NATDEPFILES): Ditto.
	* config/mips/linux.mh (NATDEPFILES): Ditto.
	* config/pa/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/linux.mh (NATDEPFILES): Ditto.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Ditto.
	* config/s390/s390.mh (NATDEPFILES): Ditto.
	* config/sparc/linux.mh (NATDEPFILES): Ditto.
	* config/sparc/linux64.mh (NATDEPFILES): Ditto.
	* config/xtensa/linux.mh (NATDEPFILES): Ditto.

gdbserver/
	* linux-low.c (compare_ints, unique, list_threads, show_process,
	linux_core_of_thread): Delete.
	(linux_target_ops): Change linux_core_of_thread to
	linux_common_core_of_thread.
	(linux_qxfer_osdata): Defer to linux_common_xfer_osdata.
	* utils.c (malloc_failure): Change type of argument.
	(xmalloc, xrealloc, xcalloc, xsnprintf): Delete.
	* Makefile.in (SFILES): Add common/common-utils.c, common/xml-utils.c,
	common/linux-osdata.c, common/ptid.c and common/buffer.c.
	(OBS): Add xml-utils.o, common-utils.o, ptid.o and buffer.o.
	(IPA_OBJS): Add common-utils-ipa.o.
	(ptid_h, linux_osdata_h): New macros.
	(server_h): Add common/common-utils.h, common/xml-utils.h,
	common/buffer.h, common/gdb_assert.h, common/gdb_locale.h and
	common/ptid.h.
	(common-utils-ipa.o, common-utils.o, xml-utils.o, linux-osdata.o,
	ptid.o, buffer.o): New rules.
	(linux-low.o): Add common/linux-osdata.h as a dependency.
	* configure.srv (srv_tgtobj): Add linux-osdata.o to Linux targets.
	* configure.ac: Add AC_HEADER_DIRENT check.
	* config.in: Regenerate.
	* configure: Regenerate.
	* remote-utils.c (xml_escape_text): Delete.
	(buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf): Move to common/buffer.c.
	* server.c (main): Remove call to initialize_inferiors.
	* server.h (struct ptid, ptid_t, minus_one_ptid, null_ptid,
	ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp, ptid_get_tid,
	ptid_equal, ptid_is_pid, initialize_inferiors, xml_escape_text,
	internal_error, gdb_assert, gdb_assert_fail): Delete.
	(struct buffer, buffer_grow, buffer_free, buffer_init, buffer_finish,
	buffer_xml_printf, buffer_grow_str, buffer_grow_str0): Move to
	common/buffer.h.
	* inferiors.c (null_ptid, minus_one_ptid, ptid_build, pid_to_ptid,
	ptid_get_pid, ptid_get_lwp, ptid_get_tid, ptid_equal, ptid_is_pid,
	initialize_inferiors): Delete.
@
text
@d4657 60
d4865 5
@


1.172
log
@	* linux-low.c (linux_join): Skip process lookup.
	* spu-low.c (spu_join): Ditto.
	* server.c (join_inferiors_callback): Delete.
	(process_serial_event): For 'D' packet (detach) call join_inferior
	directly.
@
text
@d22 1
a121 1
static int linux_core_of_thread (ptid_t ptid);
a4389 170
compare_ints (const void *xa, const void *xb)
{
  int a = *(const int *)xa;
  int b = *(const int *)xb;

  return a - b;
}

static int *
unique (int *b, int *e)
{
  int *d = b;
  while (++b != e)
    if (*d != *b)
      *++d = *b;
  return ++d;
}

/* Given PID, iterates over all threads in that process.

   Information about each thread, in a format suitable for qXfer:osdata:thread
   is printed to BUFFER, if it's not NULL.  BUFFER is assumed to be already
   initialized, and the caller is responsible for finishing and appending '\0'
   to it.

   The list of cores that threads are running on is assigned to *CORES, if it
   is not NULL.  If no cores are found, *CORES will be set to NULL.  Caller
   should free *CORES.  */

static void
list_threads (int pid, struct buffer *buffer, char **cores)
{
  int count = 0;
  int allocated = 10;
  int *core_numbers = xmalloc (sizeof (int) * allocated);
  char pathname[128];
  DIR *dir;
  struct dirent *dp;
  struct stat statbuf;

  sprintf (pathname, "/proc/%d/task", pid);
  if (stat (pathname, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))
    {
      dir = opendir (pathname);
      if (!dir)
	{
	  free (core_numbers);
	  return;
	}

      while ((dp = readdir (dir)) != NULL)
	{
	  unsigned long lwp = strtoul (dp->d_name, NULL, 10);

	  if (lwp != 0)
	    {
	      unsigned core = linux_core_of_thread (ptid_build (pid, lwp, 0));

	      if (core != -1)
		{
		  char s[sizeof ("4294967295")];
		  sprintf (s, "%u", core);

		  if (count == allocated)
		    {
		      allocated *= 2;
		      core_numbers = realloc (core_numbers,
					      sizeof (int) * allocated);
		    }
		  core_numbers[count++] = core;
		  if (buffer)
		    buffer_xml_printf (buffer,
				       "<item>"
				       "<column name=\"pid\">%d</column>"
				       "<column name=\"tid\">%s</column>"
				       "<column name=\"core\">%s</column>"
				       "</item>", pid, dp->d_name, s);
		}
	      else
		{
		  if (buffer)
		    buffer_xml_printf (buffer,
				       "<item>"
				       "<column name=\"pid\">%d</column>"
				       "<column name=\"tid\">%s</column>"
				       "</item>", pid, dp->d_name);
		}
	    }
	}
      closedir (dir);
    }

  if (cores)
    {
      *cores = NULL;
      if (count > 0)
	{
	  struct buffer buffer2;
	  int *b;
	  int *e;
	  qsort (core_numbers, count, sizeof (int), compare_ints);

	  /* Remove duplicates. */
	  b = core_numbers;
	  e = unique (b, core_numbers + count);

	  buffer_init (&buffer2);

	  for (b = core_numbers; b != e; ++b)
	    {
	      char number[sizeof ("4294967295")];
	      sprintf (number, "%u", *b);
	      buffer_xml_printf (&buffer2, "%s%s",
				 (b == core_numbers) ? "" : ",", number);
	    }
	  buffer_grow_str0 (&buffer2, "");

	  *cores = buffer_finish (&buffer2);
	}
    }
  free (core_numbers);
}

static void
show_process (int pid, const char *username, struct buffer *buffer)
{
  char pathname[128];
  FILE *f;
  char cmd[MAXPATHLEN + 1];

  sprintf (pathname, "/proc/%d/cmdline", pid);

  if ((f = fopen (pathname, "r")) != NULL)
    {
      size_t len = fread (cmd, 1, sizeof (cmd) - 1, f);
      if (len > 0)
	{
	  char *cores = 0;
	  int i;
	  for (i = 0; i < len; i++)
	    if (cmd[i] == '\0')
	      cmd[i] = ' ';
	  cmd[len] = '\0';

	  buffer_xml_printf (buffer,
			     "<item>"
			     "<column name=\"pid\">%d</column>"
			     "<column name=\"user\">%s</column>"
			     "<column name=\"command\">%s</column>",
			     pid,
			     username,
			     cmd);

	  /* This only collects core numbers, and does not print threads.  */
	  list_threads (pid, NULL, &cores);

	  if (cores)
	    {
	      buffer_xml_printf (buffer,
				 "<column name=\"cores\">%s</column>", cores);
	      free (cores);
	    }

	  buffer_xml_printf (buffer, "</item>");
	}
      fclose (f);
    }
}

static int
d4394 1
a4394 84
  /* We make the process list snapshot when the object starts to be
     read.  */
  static const char *buf;
  static long len_avail = -1;
  static struct buffer buffer;
  int processes = 0;
  int threads = 0;

  DIR *dirp;

  if (strcmp (annex, "processes") == 0)
    processes = 1;
  else if (strcmp (annex, "threads") == 0)
    threads = 1;
  else
    return 0;

  if (!readbuf || writebuf)
    return 0;

  if (offset == 0)
    {
      if (len_avail != -1 && len_avail != 0)
       buffer_free (&buffer);
      len_avail = 0;
      buf = NULL;
      buffer_init (&buffer);
      if (processes)
	buffer_grow_str (&buffer, "<osdata type=\"processes\">");
      else if (threads)
	buffer_grow_str (&buffer, "<osdata type=\"threads\">");

      dirp = opendir ("/proc");
      if (dirp)
       {
	 struct dirent *dp;
	 while ((dp = readdir (dirp)) != NULL)
	   {
	     struct stat statbuf;
	     char procentry[sizeof ("/proc/4294967295")];

	     if (!isdigit (dp->d_name[0])
		 || strlen (dp->d_name) > sizeof ("4294967295") - 1)
	       continue;

	     sprintf (procentry, "/proc/%s", dp->d_name);
	     if (stat (procentry, &statbuf) == 0
		 && S_ISDIR (statbuf.st_mode))
	       {
		 int pid = (int) strtoul (dp->d_name, NULL, 10);

		 if (processes)
		   {
		     struct passwd *entry = getpwuid (statbuf.st_uid);
		     show_process (pid, entry ? entry->pw_name : "?", &buffer);
		   }
		 else if (threads)
		   {
		     list_threads (pid, &buffer, NULL);
		   }
	       }
	   }

	 closedir (dirp);
       }
      buffer_grow_str0 (&buffer, "</osdata>\n");
      buf = buffer_finish (&buffer);
      len_avail = strlen (buf);
    }

  if (offset >= len_avail)
    {
      /* Done.  Get rid of the data.  */
      buffer_free (&buffer);
      buf = NULL;
      len_avail = 0;
      return 0;
    }

  if (len > len_avail - offset)
    len = len_avail - offset;
  memcpy (readbuf, buf + offset, len);

  return len;
a4656 57
static int
linux_core_of_thread (ptid_t ptid)
{
  char filename[sizeof ("/proc//task//stat")
		 + 2 * 20 /* decimal digits for 2 numbers, max 2^64 bit each */
		 + 1];
  FILE *f;
  char *content = NULL;
  char *p;
  char *ts = 0;
  int content_read = 0;
  int i;
  int core;

  sprintf (filename, "/proc/%d/task/%ld/stat",
	   ptid_get_pid (ptid), ptid_get_lwp (ptid));
  f = fopen (filename, "r");
  if (!f)
    return -1;

  for (;;)
    {
      int n;
      content = realloc (content, content_read + 1024);
      n = fread (content + content_read, 1, 1024, f);
      content_read += n;
      if (n < 1024)
	{
	  content[content_read] = '\0';
	  break;
	}
    }

  p = strchr (content, '(');

  /* Skip ")".  */
  if (p != NULL)
    p = strchr (p, ')');
  if (p != NULL)
    p++;

  /* If the first field after program name has index 0, then core number is
     the field with index 36.  There's no constant for that anywhere.  */
  if (p != NULL)
    p = strtok_r (p, " ", &ts);
  for (i = 0; p != NULL && i != 36; ++i)
    p = strtok_r (NULL, " ", &ts);

  if (p == NULL || sscanf (p, "%d", &core) == 0)
    core = -1;

  free (content);
  fclose (f);

  return core;
}

d4804 1
a4804 1
  linux_core_of_thread,
@


1.171
log
@gdb/

        * linux-nat.c: Move common macros to ...
        Include linux-ptrace.h.
        * common/linux-ptrace.h: ... here.  New.

gdb/gdbserver/

        * linux-low.c: Move common macros to linux-ptrace.h.
        Include linux-ptrace.h.
	* Makefile.in (linux_ptrace_h): New.
	(linux-low.o): Depends on linux-ptrace.h.
@
text
@a880 5
  struct process_info *process;

  process = find_process_pid (pid);
  if (process == NULL)
    return;
@


1.170
log
@2011-02-26  Michael Snyder  <msnyder@@vmware.com>

	* linux-low.c (list_threads): Call closedir for dirent.
@
text
@d27 1
a55 5
#ifndef PTRACE_GETSIGINFO
# define PTRACE_GETSIGINFO 0x4202
# define PTRACE_SETSIGINFO 0x4203
#endif

a59 33
/* If the system headers did not provide the constants, hard-code the normal
   values.  */
#ifndef PTRACE_EVENT_FORK

#define PTRACE_SETOPTIONS	0x4200
#define PTRACE_GETEVENTMSG	0x4201

/* options set using PTRACE_SETOPTIONS */
#define PTRACE_O_TRACESYSGOOD	0x00000001
#define PTRACE_O_TRACEFORK	0x00000002
#define PTRACE_O_TRACEVFORK	0x00000004
#define PTRACE_O_TRACECLONE	0x00000008
#define PTRACE_O_TRACEEXEC	0x00000010
#define PTRACE_O_TRACEVFORKDONE	0x00000020
#define PTRACE_O_TRACEEXIT	0x00000040

/* Wait extended result codes for the above trace options.  */
#define PTRACE_EVENT_FORK	1
#define PTRACE_EVENT_VFORK	2
#define PTRACE_EVENT_CLONE	3
#define PTRACE_EVENT_EXEC	4
#define PTRACE_EVENT_VFORK_DONE	5
#define PTRACE_EVENT_EXIT	6

#endif /* PTRACE_EVENT_FORK */

/* We can't always assume that this flag is available, but all systems
   with the ptrace event handlers also have __WALL, so it's safe to use
   in some contexts.  */
#ifndef __WALL
#define __WALL          0x40000000 /* Wait for any child.  */
#endif

@


1.169
log
@2011-02-26  Michael Snyder  <msnyder@@vmware.com>

	* linux-low.c (linux_xfer_siginfo): Fix fencepost error.
@
text
@d4521 1
@


1.168
log
@2011-01-05  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdbreplay.c: Shorten lines of >= 80 columns.
	* linux-low.c: Ditto.
	* linux-ppc-low.c: Ditto.
	* linux-s390-low.c: Ditto.
	* linux-sparc-low.c: Ditto.
	* linux-x86-low.c: Ditto.
	* linux-xtensa-low.c: Ditto.
	* mem-break.c: Ditto.
	* nto-low.c: Ditto.
	* regcache.h: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* server.h: Ditto.
	* thread-db.c: Ditto.
	* tracepoint.c: Ditto.
	* utils.c: Ditto.
	* win32-low.h: Ditto.
@
text
@d4731 1
a4731 1
  if (offset > sizeof (siginfo))
@


1.167
log
@run copyright.sh for 2011.
@
text
@d1671 2
a1672 1
	  struct lwp_info *event_child = find_lwp_pid (pid_to_ptid (event_pid));
d2068 3
a2070 1
		fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
d2078 3
a2080 1
		fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
d2304 2
a2305 1
		   || (!step_over_finished && !bp_explains_trap && !trace_event)
d3185 2
a3186 1
		     "Need step over [LWP %ld]? yes, found breakpoint at 0x%s\n",
d4055 3
a4057 1
  = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1) / sizeof (PTRACE_XFER_TYPE);
d4059 3
a4061 1
  register PTRACE_XFER_TYPE *buffer = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d4104 2
a4105 1
  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)), myaddr, len);
@


1.166
log
@gdbserver: bfin: new port

Signed-off-by: Jie Zhang <jie.zhang@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.165
log
@gdbserver: fix warning in nommu clone

Building gdbserver for nommu targets atm fails with:
	linux-low.c: In function 'linux_tracefork_child':
	linux-low.c:4151: error: pointer of type 'void *' used in arithmetic

So cast the void* to a char*.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d4376 4
@


1.164
log
@2010-09-06  Yao Qi  <yao@@codesourcery.com>

	* linux-low.c (linux_kill): Remove unused variable.
	(linux_stabilize_threads): Likewise.
	* server.c (start_inferior): Likewise.
	(queue_stop_reply_callback): Likewise.
	* tracepoint.c (do_action_at_tracepoint): Likewise.
@
text
@d4151 1
a4151 1
  clone (linux_tracefork_grandchild, arg + STACK_SIZE,
@


1.163
log
@2010-09-06  Yao Qi  <yao@@codesourcery.com>

	* linux-low.c (maybe_move_out_of_jump_pad): Restore current_inferior
	on return.
@
text
@a777 1
  struct thread_info *thread;
a793 1
  thread = get_lwp_thread (lwp);
a1935 1
      ptid_t ptid;
d1941 1
a1941 1
      ptid = linux_wait_1 (minus_one_ptid, &ourstatus, 0);
@


1.162
log
@use xsnprintf instead of snprintf.

snprintf is not available on LynxOS, so I changed the calls to snprintf
to calls to xsnprintf, which should be strictly equivalent.

gdb/gdbserver/ChangeLog:

        * utils.c (xsnprintf): Make non-static.
        * server.h: Add xsnprintf declaration.
        * linux-low.c, nto-low.c, target.c, thread-db.c, tracepoint.c:
        replace calls to snprintf by calls to xsnprintf throughout.
@
text
@d1247 1
d1318 2
@


1.161
log
@	* linux-low.c (__SIGRTMIN): Define if not already defined.
	(linux_create_inferior): Check for __ANDROID__ rather than
	__SIGRTMIN.
	(enqueue_one_deferred_signal): Don't requeue non-RT signals that
	are already deferred.
	(linux_wait_1): Check for __ANDROID__ rather than __SIGRTMIN.
	(linux_resume_one_thread): Don't queue a SIGSTOP if the lwp is
	stopped and already has a pending signal to report.
	(proceed_one_lwp): : Don't queue a SIGSTOP if the lwp already has
	a pending signal to report or is moving out of a jump pad.
	(linux_init_signals): Check for __ANDROID__ rather than
	__SIGRTMIN.
@
text
@d4313 1
a4313 1
  snprintf (filename, sizeof filename, "/proc/%d/auxv", pid);
@


1.160
log
@	* linux-low.c (linux_stabilize_threads): Wrap debug output in a
	debug_threads check.  Avoid a linear search when not doing debug
	output.
@
text
@d101 6
d575 1
a575 1
#ifdef __SIGRTMIN /* Bionic doesn't use SIGRTMIN the way glibc does.  */
d1346 24
d2263 1
a2263 1
#if defined (USE_THREAD_DB) && defined (__SIGRTMIN)
d3365 8
a3372 1
	  send_sigstop (lwp);
d3540 3
a3542 1
  if (thread->last_resume_kind == resume_stop)
d5159 1
a5159 1
#ifdef __SIGRTMIN /* Bionic doesn't use SIGRTMIN the way glibc does.  */
@


1.159
log
@	* linux-low.c (linux_unprepare_to_access_memory): Rename to ...
	(linux_done_accessing_memory): ... this.
	(linux_target_ops): Adjust.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Adjust.
	* nto-low.c (nto_target_ops): Adjust comment.
	* server.c (gdb_read_memory, gdb_write_memory): Adjust.
	* spu-low.c (spu_target_ops): Adjust comment.
	* target.h (target_ops): Rename unprepare_to_access_memory field
	to done_accessing_memory.
	(unprepare_to_access_memory): Rename to ...
	(done_accessing_memory): ... this.
@
text
@d1887 3
a1889 2
      fprintf (stderr, "can't stabilize, LWP %ld is stuck in jump pad\n",
	       lwpid_of (lwp_stuck));
d1935 4
a1938 2
  lwp_stuck
    = (struct lwp_info *) find_inferior (&all_lwps,
d1940 1
a1940 3
  if (lwp_stuck != NULL)
    {
      if (debug_threads)
@


1.158
log
@	* linux-low.c (linux_prepare_to_access_memory): New.
	(linux_unprepare_to_access_memory): New.
	(linux_target_ops): Install them.
	* server.c (read_memory): Rename to ...
	(gdb_read_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(write_memory): Rename to ...
	(gdb_write_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(handle_search_memory_1): Adjust.
	(process_serial_event): Adjust.
	* target.h (struct target_ops): New fields
	prepare_to_access_memory and unprepare_to_access_memory.
	(prepare_to_access_memory, unprepare_to_access_memory): New.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Use
	prepare_to_access_memory/prepare_to_access_memory.
	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_target_ops): Adjust.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d5019 1
a5019 1
linux_unprepare_to_access_memory (void)
d5066 1
a5066 1
  linux_unprepare_to_access_memory,
@


1.157
log
@	* gdbreplay.c (remote_error): New.
	(gdbchar): New.
	(expect): Use gdbchar.  Check for error reading from GDB.
	Clarify sync error output.
	(play): Check for errors writing to GDB.
	* linux-low.c (sigchld_handler): Really ignore `write' errors.
	* remote-utils.c (getpkt): Check for errors writing to the remote
	descriptor.
@
text
@d5009 19
d5065 2
@


1.156
log
@	* linux-low.c (linux_wait_1): Move non-debugging code out of
	`debug_threads' control.
@
text
@d4716 10
a4725 2
    /* fprintf is not async-signal-safe, so call write directly.  */
    write (2, "sigchld_handler\n", sizeof ("sigchld_handler\n") - 1);
@


1.155
log
@	* linux-low.c (linux_wait_1): Don't set last_status here.
	* server.c (push_event, queue_stop_reply_callback): Assert we're
	not pushing a TARGET_WAITKIND_IGNORE event.
	(start_inferior, start_inferior, attach_inferior, handle_v_cont)
	(myresume, handle_target_event): Set the thread's last_resume_kind
	and last_status from the target returned status.
@
text
@d2203 1
a2203 1
	  else if (debug_threads)
d2205 2
a2206 1
	      fprintf (stderr, "no deferred signals.\n");
@


1.154
log
@	PR threads/10729

	* linux-x86-low.c (update_debug_registers_callback): New.
	(i386_dr_low_set_addr): Use it.
	(i386_dr_low_get_addr): New.
	(i386_dr_low_set_control): Use update_debug_registers_callback.
	(i386_dr_low_get_control): New.
	(i386_dr_low_get_status): Adjust.
	* linux-low.c (linux_stop_lwp): New.
	* linux-low.h (linux_stop_lwp): Declare.

	* i386-low.c (I386_DR_GET_RW_LEN): Take the dr7 contents as
	argument instead of a i386_debug_reg_state.
	(I386_DR_WATCH_HIT): Take the dr6 contents as argument instead of
	a i386_debug_reg_state.
	(i386_insert_aligned_watchpoint): Adjust.
	(i386_remove_aligned_watchpoint): Adjust.
	(i386_low_stopped_data_address): Read the debug registers from the
	inferior instead of from the mirrors.
	* i386-low.h (struct i386_debug_reg_state): Extend comment.
	(i386_dr_low_get_addr): Declare.
	(i386_dr_low_get_control): Declare.
	(i386_dr_low_get_status): Change prototype.

	* win32-i386-low.c (dr_status_mirror, dr_control_mirror): New globals.
	(i386_dr_low_get_addr): New.
	(i386_dr_low_get_control): New.
	(i386_dr_low_get_status): Adjust prototype.  Return
	dr_status_mirror.
	(i386_initial_stuff): Clear dr_status_mirror and
	dr_control_mirror.
	(i386_get_thread_context): Adjust.
	(i386_set_thread_context): Adjust.
	(i386_thread_added): Adjust.
@
text
@a2393 3
  if (!stabilizing_threads)
    current_inferior->last_status = *ourstatus;

@


1.153
log
@2010-08-11  Thomas Schwinge  <thomas@@codesourcery.com>

	* linux-low.c (linux_wait_1): Correctly return the ptid of the child
	after its termination.
@
text
@d2481 6
@


1.152
log
@	* linux-low.c (gdb_wants_lwp_stopped): Delete.
	(gdb_wants_all_stopped): Delete.
	(linux_wait_1): Don't call them.
	* server.c (handle_v_cont): Tag all threads as want-stopped.
	(gdb_wants_thread_stopped): Fix comments.  Tag the thread that
	stopped as "client-wants-stopped".
@
text
@d2048 1
a2048 1
	  return pid_to_ptid (pid);
@


1.151
log
@gdb/
2010-06-14  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention GDBserver's JIT compilation of tracepoint
	bytecode.

gdb/gdbserver/
2010-06-14  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	Bytecode compiler.

	* linux-x86-low.c: Include limits.h.
	(add_insns): New.
	(always_true): New.
	(EMIT_ASM): New.
	(EMIT_ASM32): New.
	(amd64_emit_prologue, amd64_emit_epilogue, amd64_emit_add)
	(amd64_emit_sub, amd64_emit_mul, amd64_emit_lsh)
	(amd64_emit_rsh_signed, amd64_emit_rsh_unsigned, amd64_emit_ext,
	(amd64_emit_log_not, amd64_emit_bit_and, amd64_emit_bit_or)
	(amd64_emit_bit_xor, amd64_emit_bit_not, amd64_emit_equal,
	(amd64_emit_less_signed, amd64_emit_less_unsigned, amd64_emit_ref,
	(amd64_emit_if_goto, amd64_emit_goto, amd64_write_goto_address)
	(amd64_emit_const, amd64_emit_call, amd64_emit_reg)
	(amd64_emit_pop, amd64_emit_stack_flush, amd64_emit_zero_ext)
	(amd64_emit_swap, amd64_emit_stack_adjust, amd64_emit_int_call_1)
	(amd64_emit_void_call_2): New.
	(amd64_emit_ops): New.
	(i386_emit_prologue, i386_emit_epilogue, i386_emit_add)
	(i386_emit_sub,i386_emit_mul, i386_emit_lsh, i386_emit_rsh_signed)
	(i386_emit_rsh_unsigned, i386_emit_ext, i386_emit_log_not)
	(i386_emit_bit_and, i386_emit_bit_or, i386_emit_bit_xor)
	(i386_emit_bit_not, i386_emit_equal, i386_emit_less_signed)
	(i386_emit_less_unsigned, i386_emit_ref, i386_emit_if_goto)
	(i386_emit_goto, i386_write_goto_address, i386_emit_const)
	(i386_emit_call, i386_emit_reg, i386_emit_pop)
	(i386_emit_stack_flush, i386_emit_zero_ext, i386_emit_swap)
	(i386_emit_stack_adjust, i386_emit_int_call_1)
	(i386_emit_void_call_2): New.
	(i386_emit_ops): New.
	(x86_emit_ops): New.
	(the_low_target): Install x86_emit_ops.
	* server.h (struct emit_ops): New.
	(get_raw_reg_func_addr): Declare.
	(current_insn_ptr, emit_error): Declare.
	* tracepoint.c (get_raw_reg, get_trace_state_variable_value)
	(set_trace_state_variable_value): New defines.
	(struct ipa_sym_addresses): New fields addr_get_raw_reg,
	addr_get_trace_state_variable_value and
	addr_set_trace_state_variable_value.
	(symbol_list): New fields for get_raw_reg,
	get_trace_state_variable_value and set_trace_state_variable_value.
	(condfn): New typedef.
	(struct tracepoint): New field `compiled_cond'.
	(do_action_at_tracepoint): Clear compiled_cond.
	(get_trace_state_variable_value, set_trace_state_variable_value):
	Export in the IPA.
	(condition_true_at_tracepoint): If there's a compiled condition,
	run that.
	(current_insn_ptr, emit_error): New globals.
	(struct bytecode_address): New.
	(get_raw_reg_func_addr): New.
	(emit_prologue, emit_epilogue, emit_add, emit_sub, emit_mul)
	(emit_lsh, emit_rsh_signed, emit_rsh_unsigned, emit_ext)
	(emit_log_not, emit_bit_and, emit_bit_or, emit_bit_xor)
	(emit_bit_not, emit_equal, emit_less_signed, emit_less_unsigned)
	(emit_ref, emit_if_goto, emit_goto, write_goto_address, emit_const)
	(emit_reg, emit_pop, emit_stack_flush, emit_zero_ext, emit_swap)
	(emit_stack_adjust, emit_int_call_1, emit_void_call_2): New.
	(compile_tracepoint_condition, compile_bytecodes): New.
	* target.h (emit_ops): Forward declare.
	(struct target_ops): New field emit_ops.
	(target_emit_ops): New.
	* linux-amd64-ipa.c (gdb_agent_get_raw_reg): New.
	* linux-i386-ipa.c (gdb_agent_get_raw_reg): New.
	* linux-low.c (linux_emit_ops): New.
	(linux_target_ops): Install it.
	* linux-low.h (struct linux_target_ops): New field emit_ops.
@
text
@a1811 18
/* Set this inferior LWP's state as "want-stopped".  We won't resume
   this LWP until the client gives us another action for it.  */

static void
gdb_wants_lwp_stopped (struct inferior_list_entry *entry)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *thread = get_lwp_thread (lwp);

  /* Most threads are stopped implicitly (all-stop); tag that with
     signal 0.  The thread being explicitly reported stopped to the
     client, gets it's status fixed up afterwards.  */
  thread->last_status.kind = TARGET_WAITKIND_STOPPED;
  thread->last_status.value.sig = TARGET_SIGNAL_0;

  thread->last_resume_kind = resume_stop;
}

a1837 8
/* Set all LWP's states as "want-stopped".  */

static void
gdb_wants_all_stopped (void)
{
  for_each_inferior (&all_lwps, gdb_wants_lwp_stopped);
}

a2365 2
  /* Do this before the gdb_wants_all_stopped calls below, since they
     always set last_resume_kind to resume_stop.  */
a2387 17
  if (stabilizing_threads)
    return ptid_of (event_child);

  if (!non_stop)
    {
      /* From GDB's perspective, all-stop mode always stops all
	 threads implicitly.  Tag all threads as "want-stopped".  */
      gdb_wants_all_stopped ();
    }
  else
    {
      /* We're reporting this LWP as stopped.  Update it's
      	 "want-stopped" state to what the client wants, until it gets
      	 a new resume action.  */
      gdb_wants_lwp_stopped (&event_child->head);
    }

d2394 2
a2395 1
  current_inferior->last_status = *ourstatus;
@


1.151.2.1
log
@2010-08-11  Thomas Schwinge  <thomas@@codesourcery.com>

	* linux-low.c (linux_wait_1): Correctly return the ptid of the child
	after its termination.
@
text
@d2074 1
a2074 1
	  return ptid_of (event_child);
@


1.150
log
@gdb/gdbserver/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>
	    Stan Shebs  <stan@@codesourcery.com>

	* Makefile.in (IPA_DEPFILES, extra_libraries): New.
	(all): Depend on $(extra_libraries).
	(install-only): Install the IPA.
	(IPA_OBJS, IPA_LIB): New.
	(clean): Remove the IPA lib.
	(IPAGENT_CFLAGS): New.
	(tracepoint-ipa.o, utils-ipa.o, remote-utils-ipa.o)
	(regcache-ipa.o, i386-linux-ipa.o, linux-i386-ipa.o)
	(linux-amd64-ipa.o, amd64-linux-ipa.o): New rules.
	* linux-amd64-ipa.c, linux-i386-ipa.c: New files.
	* configure.ac: Check for atomic builtins support in the compiler.
	(IPA_DEPFILES, extra_libraries): Define.
	* configure.srv (ipa_obj): Add description.
	(ipa_i386_linux_regobj, ipa_amd64_linux_regobj): Define.
	(i[34567]86-*-linux*): Set ipa_obj.
	(x86_64-*-linux*): Set ipa_obj.
	* linux-low.c (stabilizing_threads): New.
	(supports_fast_tracepoints): New.
	(linux_detach): Stabilize threads before detaching.
	(handle_tracepoints): Handle internal tracing breakpoints.  Assert
	the lwp is either not stabilizing, or is moving out of a jump pad.
	(linux_fast_tracepoint_collecting): New.
	(maybe_move_out_of_jump_pad): New.
	(enqueue_one_deferred_signal): New.
	(dequeue_one_deferred_signal): New.
	(linux_wait_for_event_1): If moving out of a jump pad, defer
	pending signals to later.
	(linux_stabilize_threads): New.
	(linux_wait_1): Check if threads need moving out of jump pads, and
	do it if so.
	(stuck_in_jump_pad_callback): New.
	(move_out_of_jump_pad_callback): New.
	(lwp_running): New.
	(linux_resume_one_lwp): Handle moving out of jump pads.
	(linux_set_resume_request): Dequeue deferred signals.
	(need_step_over_p): Also step over fast tracepoint jumps.
	(start_step_over): Also uninsert fast tracepoint jumps.
	(finish_step_over): Also reinsert fast tracepoint jumps.
	(linux_install_fast_tracepoint_jump): New.
	(linux_target_ops): Install linux_stabilize_threads and
	linux_install_fast_tracepoint_jump_pad.
	* linux-low.h (linux_target_ops) <get_thread_area,
	install_fast_tracepoint_jump_pad>: New fields.
	(struct lwp_info) <collecting_fast_tracepoint,
	pending_signals_to_report, exit_jump_pad_bkpt>: New fields.
	(linux_get_thread_area): Declare.
	* linux-x86-low.c (jump_insn): New.
	(x86_get_thread_area): New.
	(append_insns): New.
	(push_opcode): New.
	(amd64_install_fast_tracepoint_jump_pad): New.
	(i386_install_fast_tracepoint_jump_pad): New.
	(x86_install_fast_tracepoint_jump_pad): New.
	(the_low_target): Install x86_get_thread_area and
	x86_install_fast_tracepoint_jump_pad.
	* mem-break.c (set_raw_breakpoint_at): Use read_inferior_memory.
	(struct fast_tracepoint_jump): New.
	(fast_tracepoint_jump_insn): New.
	(fast_tracepoint_jump_shadow): New.
	(find_fast_tracepoint_jump_at): New.
	(fast_tracepoint_jump_here): New.
	(delete_fast_tracepoint_jump): New.
	(set_fast_tracepoint_jump): New.
	(uninsert_fast_tracepoint_jumps_at): New.
	(reinsert_fast_tracepoint_jumps_at): New.
	(set_breakpoint_at): Use write_inferior_memory.
	(uninsert_raw_breakpoint): Use write_inferior_memory.
	(check_mem_read): Mask out fast tracepoint jumps.
	(check_mem_write): Mask out fast tracepoint jumps.
	* mem-break.h (struct fast_tracepoint_jump): Forward declare.
	(set_fast_tracepoint_jump): Declare.
	(delete_fast_tracepoint_jump)
	(fast_tracepoint_jump_here, uninsert_fast_tracepoint_jumps_at)
	(reinsert_fast_tracepoint_jumps_at): Declare.
	* regcache.c: Don't compile many functions when building the
	in-process agent library.
	(init_register_cache) [IN_PROCESS_AGENT]: Don't allow allocating
	the register buffer in the heap.
	(free_register_cache): If the register buffer isn't owned by the
	regcache, don't free it.
	(set_register_cache) [IN_PROCESS_AGENT]: Don't re-alocate
	pre-existing register caches.
	* remote-utils.c (convert_int_to_ascii): Constify `from' parameter
	type.
	(convert_ascii_to_int): : Constify `from' parameter type.
	(decode_M_packet, decode_X_packet): Replace the `to' parameter by
	a `to_p' pointer to pointer parameter.  If TO_P is NULL, malloc
	the needed buffer in-place.
	(relocate_instruction): New.
	* server.c (handle_query) <qSymbols>: If the target supports
	tracepoints, give it a chance of looking up symbols.  Report
	support for fast tracepoints.
	(handle_status): Stabilize threads.
	(process_serial_event): Adjust.
	* server.h (struct fast_tracepoint_jump): Forward declare.
	(struct process_info) <fast_tracepoint_jumps>: New field.
	(convert_ascii_to_int, convert_int_to_ascii): Adjust.
	(decode_X_packet, decode_M_packet): Adjust.
	(relocate_instruction): Declare.
	(in_process_agent_loaded): Declare.
	(tracepoint_look_up_symbols): Declare.
	(struct fast_tpoint_collect_status): Declare.
	(fast_tracepoint_collecting): Declare.
	(force_unlock_trace_buffer): Declare.
	(handle_tracepoint_bkpts): Declare.
	(initialize_low_tracepoint)
	(supply_fast_tracepoint_registers) [IN_PROCESS_AGENT]: Declare.
	* target.h (struct target_ops) <stabilize_threads,
	install_fast_tracepoint_jump_pad>: New fields.
	(stabilize_threads, install_fast_tracepoint_jump_pad): New.
	* tracepoint.c [HAVE_MALLOC_H]: Include malloc.h.
	[HAVE_STDINT_H]: Include stdint.h.
	(trace_debug_1): Rename to ...
	(trace_vdebug): ... this.
	(trace_debug): Rename to ...
	(trace_debug_1): ... this.  Add `level' parameter.
	(trace_debug): New.
	(ATTR_USED, ATTR_NOINLINE): New.
	(IP_AGENT_EXPORT): New.
	(gdb_tp_heap_buffer, gdb_jump_pad_buffer, gdb_jump_pad_buffer_end)
	(collecting, gdb_collect, stop_tracing, flush_trace_buffer)
	(about_to_request_buffer_space, trace_buffer_is_full)
	(stopping_tracepoint, expr_eval_result, error_tracepoint)
	(tracepoints, tracing, trace_buffer_ctrl, trace_buffer_ctrl_curr)
	(trace_buffer_lo, trace_buffer_hi, traceframe_read_count)
	(traceframe_write_count, traceframes_created)
	(trace_state_variables)
	New renaming defines.
	(struct ipa_sym_addresses): New.
	(STRINGIZE_1, STRINGIZE, IPA_SYM): New.
	(symbol_list): New.
	(ipa_sym_addrs): New.
	(all_tracepoint_symbols_looked_up): New.
	(in_process_agent_loaded): New.
	(write_e_ipa_not_loaded): New.
	(maybe_write_ipa_not_loaded): New.
	(tracepoint_look_up_symbols): New.
	(debug_threads) [IN_PROCESS_AGENT]: New.
	(read_inferior_memory) [IN_PROCESS_AGENT]: New.
	(UNKNOWN_SIDE_EFFECTS): New.
	(stop_tracing): New.
	(flush_trace_buffer): New.
	(stop_tracing_bkpt): New.
	(flush_trace_buffer_bkpt): New.
	(read_inferior_integer): New.
	(read_inferior_uinteger): New.
	(read_inferior_data_pointer): New.
	(write_inferior_data_pointer): New.
	(write_inferior_integer): New.
	(write_inferior_uinteger): New.
	(struct collect_static_trace_data_action): Delete.
	(enum tracepoint_type): New.
	(struct tracepoint) <type>: New field `type'.
	<actions_str, step_actions, step_actions_str>: Only include in GDBserver.
	<orig_size, obj_addr_on_target, adjusted_insn_addr>
	<adjusted_insn_addr_end, jump_pad, jump_pad_end>: New fields.
	(tracepoints): Use IP_AGENT_EXPORT.
	(last_tracepoint): Don't include in the IPA.
	(stopping_tracepoint): Use IP_AGENT_EXPORT.
	(trace_buffer_is_full): Use IP_AGENT_EXPORT.
	(alloced_trace_state_variables): New.
	(trace_state_variables): Use IP_AGENT_EXPORT.
	(traceframe_t): Delete unused variable.
	(circular_trace_buffer): Don't include in the IPA.
	(trace_buffer_start): Delete.
	(struct trace_buffer_control): New.
	(trace_buffer_free): Delete.
	(struct ipa_trace_buffer_control): New.
	(GDBSERVER_FLUSH_COUNT_MASK, GDBSERVER_FLUSH_COUNT_MASK_PREV)
	(GDBSERVER_FLUSH_COUNT_MASK_CURR, GDBSERVER_UPDATED_FLUSH_COUNT_BIT):
	New.
	(trace_buffer_ctrl): New.
	(TRACE_BUFFER_CTRL_CURR): New.
	(trace_buffer_start, trace_buffer_free, trace_buffer_end_free):
	Reimplement as macros.
	(trace_buffer_wrap): Delete.
	(traceframe_write_count, traceframe_read_count)
	(traceframes_created, tracing): Use IP_AGENT_EXPORT.
	(struct tracepoint_hit_ctx) <type>: New field.
	(struct fast_tracepoint_ctx): New.
	(memory_barrier): New.
	(cmpxchg): New.
	(record_tracepoint_error): Update atomically in the IPA.
	(clear_inferior_trace_buffer): New.
	(about_to_request_buffer_space): New.
	(trace_buffer_alloc): Handle GDBserver and inferior simulatenous
	updating the same buffer.
	(add_tracepoint): Default the tracepoint's type to trap
	tracepoint, and orig_size to -1.
	(get_trace_state_variable) [IN_PROCESS_AGENT]: Handle allocated
	internal variables.
	(create_trace_state_variable): New parameter `gdb'.  Handle it.
	(clear_installed_tracepoints): Clear fast tracepoint jumps.
	(cmd_qtdp): Handle fast tracepoints.
	(cmd_qtdv): Adjust.
	(max_jump_pad_size): New.
	(gdb_jump_pad_head): New.
	(get_jump_space_head): New.
	(claim_jump_space): New.
	(sort_tracepoints): New.
	(MAX_JUMP_SIZE): New.
	(cmd_qtstart): Handle fast tracepoints.  Sync tracepoints with the
	IPA.
	(stop_tracing) [IN_PROCESS_AGENT]: Don't include the tdisconnected
	support.  Upload fast traceframes, and delete internal IPA
	breakpoints.
	(stop_tracing_handler): New.
	(flush_trace_buffer_handler): New.
	(cmd_qtstop): Upload fast tracepoints.
	(response_tracepoint): Handle fast tracepoints.
	(tracepoint_finished_step): Upload fast traceframes.  Set the
	tracepoint hit context's tracepoint type.
	(handle_tracepoint_bkpts): New.
	(tracepoint_was_hit): Set the tracepoint hit context's tracepoint
	type.  Add comment about fast tracepoints.
	(collect_data_at_tracepoint) [IN_PROCESS_AGENT]: Don't access the
	non-existing action_str field.
	(get_context_regcache): Handle fast tracepoints.
	(do_action_at_tracepoint) [!IN_PROCESS_AGENT]: Don't write the PC
	to the regcache.
	(fast_tracepoint_from_jump_pad_address): New.
	(fast_tracepoint_from_ipa_tpoint_address): New.
	(collecting_t): New.
	(force_unlock_trace_buffer): New.
	(fast_tracepoint_collecting): New.
	(collecting): New.
	(gdb_collect): New.
	(write_inferior_data_ptr): New.
	(target_tp_heap): New.
	(target_malloc): New.
	(download_agent_expr): New.
	(UALIGN): New.
	(download_tracepoints): New.
	(download_trace_state_variables): New.
	(upload_fast_traceframes): New.
	(IPA_FIRST_TRACEFRAME): New.
	(IPA_NEXT_TRACEFRAME_1): New.
	(IPA_NEXT_TRACEFRAME): New.
	[IN_PROCESS_AGENT]: Include sys/mman.h and fcntl.h.
	[IN_PROCESS_AGENT] (gdb_tp_heap_buffer, gdb_jump_pad_buffer)
	(gdb_jump_pad_buffer_end): New.
	[IN_PROCESS_AGENT] (initialize_tracepoint_ftlib): New.
	(initialize_tracepoint): Adjust.
	[IN_PROCESS_AGENT]: Allocate the IPA heap, and jump pad scratch
	buffer.  Initialize the low module.
	* utils.c (PREFIX, TOOLNAME): New.
	(malloc_failure): Use PREFIX.
	(error): In the IPA, an error causes an exit.
	(fatal, warning): Use PREFIX.
	(internal_error): Use TOOLNAME.
	(NUMCELLS): Increase to 10.
	* configure, config.in: Regenerate.

gdb/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention gdbserver fast tracepoints support.

gdb/doc/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Set Tracepoints): Mention tracepoints support in
	gdbserver, and add cross reference.
	(Tracepoints support in gdbserver): New subsection.
@
text
@d5057 9
d5121 2
a5122 1
  linux_install_fast_tracepoint_jump_pad
@


1.149
log
@gdb/
	* linux-nat.c (linux_nat_core_of_thread_1): Fix crash on invalid
	CONTENT.

gdb/gdbserver/
	* linux-low.c (linux_core_of_thread): Fix crash on invalid CONTENT.
	New comment.
@
text
@d130 4
d177 10
d863 3
d1147 2
d1156 1
d1168 225
d1474 15
d1864 107
d1993 2
d2137 44
d2182 59
a2240 1
      trace_event = 0;
d2351 1
a2351 1
  if (!non_stop)
d2376 3
d2416 3
d2690 76
d2792 1
d2797 4
d2814 4
a2817 2
      && (lwp->status_pending_p || lwp->pending_signals != NULL
	  || lwp->bp_reinsert != 0))
d2866 8
a2873 5
	  if (step == 0)
	    fprintf (stderr, "BAD - reinserting but not stepping.\n");
	  if (lwp->suspended)
	    fprintf (stderr, "BAD - reinserting and suspended(%d).\n",
		     lwp->suspended);
d2882 27
d2934 6
a2939 3
  /* If we have pending signals, consume one unless we are trying to reinsert
     a breakpoint.  */
  if (lwp->pending_signals != NULL && lwp->bp_reinsert == 0)
d3036 17
d3169 1
a3169 1
  if (breakpoint_here (pc))
d3258 1
d3295 1
d5040 17
d5110 3
a5112 1
  linux_cancel_breakpoints
@


1.148
log
@	* linux-low.c (linux_kill, linux_detach): Adjust.
	(status_pending_p_callback): Remove redundant statement.  Check
	for !TARGET_WAITIKIND_IGNORE, instead of
	TARGET_WAITKIND_STOPPED.
	(handle_tracepoints): Make sure LWP is locked.  Adjust.
	(linux_wait_for_event_1): Adjust.
	(linux_cancel_breakpoints): New.
	(unsuspend_one_lwp): New.
	(unsuspend_all_lwps): New.
	(linux_wait_1): If finishing a step-over, unsuspend all lwps.
	(send_sigstop_callback): Change return type to int, add new
	`except' parameter and handle it.
	(suspend_and_send_sigstop_callback): New.
	(stop_all_lwps): Add new `suspend' and `expect' parameters, and
	pass them down.  If SUSPEND, also increment the lwp's suspend
	count.
	(linux_resume_one_lwp): Add notice about resuming a suspended LWP.
	(need_step_over_p): Don't consider suspended LWPs.
	(start_step_over): Adjust.
	(proceed_one_lwp): Change return type to int, add new `except'
	parameter and handle it.
	(unsuspend_and_proceed_one_lwp): New.
	(proceed_all_lwps): Use find_inferior instead of
	for_each_inferior.
	(unstop_all_lwps): Add `unsuspend' parameter.  If UNSUSPEND, them
	also decrement the suspend count of LWPs.  Pass `except' down,
	instead of hacking its suspend count.
	(linux_pause_all): Add `freeze' parameter.  Adjust.
	(linux_unpause_all): New.
	(linux_target_ops): Install linux_unpause_all.
	* server.c (handle_status): Adjust.
	* target.h (struct target_ops): New fields `unpause_all' and
	`cancel_breakpoints'.  Add new parameter to `pause_all'.
	(pause_all): Add new `freeze' parameter.
	(unpause_all): New.
	(cancel_breakpoints): New.
	* tracepoint.c (clear_installed_tracepoints): Pause threads, and
	cancel breakpoints.
	(cmd_qtstart): Pause threads.
	(stop_tracing): Pause threads, and cancel breakpoints.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@a4348 1
  p = strchr (p, ')') + 2; /* skip ")" and a whitespace. */
d4350 11
a4360 2
  p = strtok_r (p, " ", &ts);
  for (i = 0; i != 36; ++i)
d4363 1
a4363 1
  if (sscanf (p, "%d", &core) == 0)
@


1.147
log
@	* linux-low.c (linux_wait_for_event_1): Move passing the signal to
	the inferior right away from here...
	(linux_wait_1): ... to here, and adjust to check the thread's
	last_resume_kind instead of the lwp's step or stop_expected flags.
@
text
@d142 2
a143 1
static void stop_all_lwps (void);
a149 1
static void unstop_all_lwps (struct lwp_info *except);
d768 1
a768 1
  stop_all_lwps ();
d793 1
a793 1
  unstop_all_lwps (NULL);
d843 1
a843 1
  stop_all_lwps ();
d855 1
a855 1
  unstop_all_lwps (NULL);
d931 1
a931 1
  struct thread_info *thread = get_lwp_thread (lwp);
d944 1
a944 1
      && thread->last_status.kind == TARGET_WAITKIND_STOPPED)
d1116 6
d1134 4
d1303 1
a1303 1
		unstop_all_lwps (event_child);
d1497 6
d1570 26
d1851 5
a1855 4
      /* We've finished stepping over a breakpoint.  We've stopped all
	 LWPs momentarily except the stepping one.  This is where we
	 resume them all again.  We're going to keep waiting, so use
	 proceed, which handles stepping over the next breakpoint.  */
d1858 4
d1883 1
a1883 1
      stop_all_lwps ();
d1913 1
a1913 1
	unstop_all_lwps (event_child);
d1962 2
a1963 1
  get_lwp_thread (event_child)->last_status = *ourstatus;
d2072 2
a2073 2
static void
send_sigstop_callback (struct inferior_list_entry *entry)
d2077 4
d2082 1
a2082 1
    return;
d2085 18
d2213 4
d2218 1
a2218 1
stop_all_lwps (void)
d2221 5
a2225 1
  for_each_inferior (&all_lwps, send_sigstop_callback);
d2308 3
d2507 11
d2631 2
a2632 1
  stop_all_lwps ();
d2881 2
a2882 2
static void
proceed_one_lwp (struct inferior_list_entry *entry)
d2884 1
a2884 1
  struct lwp_info *lwp;
d2888 2
a2889 1
  lwp = (struct lwp_info *) entry;
d2899 1
a2899 1
      return;
d2910 1
a2910 1
      return;
d2918 1
a2918 1
      return;
d2921 2
d2927 1
a2927 1
      return;
d2953 15
d3005 1
a3005 1
  for_each_inferior (&all_lwps, proceed_one_lwp);
d3013 1
a3013 1
unstop_all_lwps (struct lwp_info *except)
d3025 4
a3028 8
  /* Make sure proceed_one_lwp doesn't try to resume this thread.  */
  if (except != NULL)
    ++except->suspended;

  for_each_inferior (&all_lwps, proceed_one_lwp);

  if (except != NULL)
    --except->suspended;
d4406 1
a4406 1
linux_pause_all (void)
d4408 10
a4417 1
  stop_all_lwps ();
d4470 1
d4472 2
a4473 1
  NULL,	      /* get_tib_address (Windows OS specific).  */
@


1.146
log
@	* linux-low.c (linux_kill_one_lwp): Assume the lwp is stopped.
	(linux_kill): Stop all lwps here.  Don't delete the main lwp here.
	(linux_detach_one_lwp): Assume the lwp is stopped.
	(any_thread_of): Delete.
	(linux_detach): Stop all lwps here.  Don't blindly delete all
	breakpoints.
	(delete_lwp_callback): New.
	(linux_mourn): Delete all lwps of the process that is gone.
	(linux_wait_1): Don't delete the last lwp of the process here.
	* mem-break.h (mark_breakpoints_out): Declare.
	* mem-break.c (mark_breakpoints_out): New.
	(free_all_breakpoints): Use it.
	* server.c (handle_target_event): If the process is gone, mark
	breakpoints out.
	* thread-db.c (struct thread_db) <create_bp>: New field.
	(thread_db_enable_reporting): Fix prototype.  Store a thread event
	breakpoint reference in the thread_db struct.
	(thread_db_load_search): Clear the thread_db object.
	(try_thread_db_load_1): Ditto.
	(switch_to_process): New.
	(disable_thread_event_reporting): Use it.
	(remove_thread_event_breakpoints): New.
	(thread_db_detach, thread_db_mourn): Use it.
@
text
@a1316 37
      /* If GDB is not interested in this signal, don't stop other
	 threads, and don't report it to GDB.  Just resume the
	 inferior right away.  We do this for threading-related
	 signals as well as any that GDB specifically requested we
	 ignore.  But never ignore SIGSTOP if we sent it ourselves,
	 and do not ignore signals when stepping - they may require
	 special handling to skip the signal handler.  */
      /* FIXME drow/2002-06-09: Get signal numbers from the inferior's
	 thread library?  */
      if (WIFSTOPPED (*wstat)
	  && !event_child->stepping
	  && (
#if defined (USE_THREAD_DB) && defined (__SIGRTMIN)
	      (current_process ()->private->thread_db != NULL
	       && (WSTOPSIG (*wstat) == __SIGRTMIN
		   || WSTOPSIG (*wstat) == __SIGRTMIN + 1))
	      ||
#endif
	      (pass_signals[target_signal_from_host (WSTOPSIG (*wstat))]
	       && !(WSTOPSIG (*wstat) == SIGSTOP
		    && event_child->stop_expected))))
	{
	  siginfo_t info, *info_p;

	  if (debug_threads)
	    fprintf (stderr, "Ignored signal %d for LWP %ld.\n",
		     WSTOPSIG (*wstat), lwpid_of (event_child));

	  if (ptrace (PTRACE_GETSIGINFO, lwpid_of (event_child), 0, &info) == 0)
	    info_p = &info;
	  else
	    info_p = NULL;
	  linux_resume_one_lwp (event_child, event_child->stepping,
				WSTOPSIG (*wstat), info_p);
	  continue;
	}

d1730 38
a1767 2
  /* We have all the data we need.  Either report the event to GDB, or
     resume threads and keep waiting for more.  */
d1769 8
a1776 9
  /* Check If GDB would be interested in this event.  If GDB wanted
     this thread to single step, we always want to report the SIGTRAP,
     and let GDB handle it.  Watchpoints should always be reported.
     So should signals we can't explain.  A SIGTRAP we can't explain
     could be a GDB breakpoint --- we may or not support Z0
     breakpoints.  If we do, we're be able to handle GDB breakpoints
     on top of internal breakpoints, by handling the internal
     breakpoint and still reporting the event to GDB.  If we don't,
     we're out of luck, GDB won't see the breakpoint hit.  */
@


1.145
log
@	* linux-low.c (linux_enable_event_reporting): New.
	(linux_wait_for_event_1, handle_extended_wait): Use it.
@
text
@a741 5
  /* If we're killing a running inferior, make sure it is stopped
     first, as PTRACE_KILL will not work otherwise.  */
  if (!lwp->stopped)
    send_sigstop (lwp);

d766 4
a780 5
  /* If we're killing a running inferior, make sure it is stopped
     first, as PTRACE_KILL will not work otherwise.  */
  if (!lwp->stopped)
    send_sigstop (lwp);

d789 1
a789 1
  delete_lwp (lwp);
d791 3
a793 1
  the_target->mourn (process);
a806 22
  /* If we're detaching from a running inferior, make sure it is
     stopped first, as PTRACE_DETACH will not work otherwise.  */
  if (!lwp->stopped)
    {
      int lwpid = lwpid_of (lwp);

      stopping_threads = 1;
      send_sigstop (lwp);

      /* If this detects a new thread through a clone event, the new
	 thread is appended to the end of the lwp list, so we'll
	 eventually detach from it.  */
      wait_for_sigstop (&lwp->head);
      stopping_threads = 0;

      /* If LWP exits while we're trying to stop it, there's nothing
	 left to do.  */
      lwp = find_lwp_pid (pid_to_ptid (lwpid));
      if (lwp == NULL)
	return 0;
    }

d815 1
a815 2
      if (lwp->stopped)
	linux_resume_one_lwp (lwp, 0, 0, NULL);
a830 11
any_thread_of (struct inferior_list_entry *entry, void *args)
{
  int *pid_p = args;

  if (ptid_get_pid (entry->id) == *pid_p)
    return 1;

  return 0;
}

static int
d839 6
a848 4
  current_inferior =
    (struct thread_info *) find_inferior (&all_threads, any_thread_of, &pid);

  delete_all_breakpoints ();
d852 18
d882 2
a1681 4
	  delete_lwp (event_child);

	  current_inferior = NULL;

@


1.144
log
@	* linux-low.c (linux_kill_one_lwp, linux_kill)
	(linux_detach_one_lwp): Adjust to send_sigstop interface change.
	(send_sigstop): Take an lwp_info as parameter instead.  Queue a
	SIGSTOP even if the LWP is stopped.
	(send_sigstop_callback): New.
	(stop_all_lwps): Use send_sigstop_callback instead.
	(linux_resume_one_thread): Adjust.
	(proceed_one_lwp): Still proceed an LWP that the client has
	requested to stop, if we haven't reported it as stopped yet.  Make
	sure that LWPs the client want stopped, have a pending SIGSTOP.
@
text
@d153 1
d400 1
a400 1
      ptrace (PTRACE_SETOPTIONS, new_pid, 0, (PTRACE_ARG4_TYPE) PTRACE_O_TRACECLONE);
d1322 1
a1322 2
	  ptrace (PTRACE_SETOPTIONS, lwpid_of (event_child),
		  0, (PTRACE_ARG4_TYPE) PTRACE_O_TRACECLONE);
d3418 9
@


1.143
log
@
	Support for Windows OS Thread Information Block.
	* NEWS: Document new feature.
	* remote.c (PACKET_qGetTIBAddr): New enum element.
	(remote_get_tib_address): New function.
	(init_remote_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_remote): Add add_packet_config_cmd
	for PACKET_qGetTIBAddr.
	* target.c (update_current_target): Set default value for
	new to_get_tib_address field.
	* target.h (target_ops): New field to_get_tib_address.
	(target_get_tib_address): New macro.
	* windows-nat.c (thread_info): Add thread_local_base field.
	(windows_add_thread): Add tlb argument of type 'void *'.
	(fake_create_process): Adapt windows_add_thread call.
	(get_windows_debug_event): Idem.
	(windows_get_tib_address): New function.
	(init_windows_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_windows_nat): Replace info_w32_cmdlist
	initialization by a call to init_w32_command_list.
	(info_w32_command, info_w32_cmdlist): Removed from here...
	to windows-tdep.c file.
	* windows-tdep.h (info_w32_cmdlist): Declare.
	(init_w32_command_list): New external function
	declaration.
	* windows-tdep.c: Add several headers.
	(info_w32_cmdlist): to here, made global.
	(thread_information_32): New struct.
	(thread_information_64): New struct.
	(TIB_NAME): New char array.
	(MAX_TIB32, MAX_TIB64, FULL_TIB_SIZE): New constants.
	(maint_display_all_tib): New static variable.
	(windows_get_tlb_type): New function.
	(tlb_value_read, tlb_value_write): New functions.
	(tlb_value_funcs): New static struct.
	(tlb_make_value): New function.
	(display_one_tib): New function.
	(display_tib): New function.
	(show_maint_show_all_tib):New function.
	(info_w32_command): Moved from windows-nat.c.
	(init_w32_command_list): New function.
	(_initialize_windows_tdep): New function.
	New "maint set/show show-all-tib" command
	New "$_tlb" internal variable.

gdbserver/ChangeLog entry:

	* server.c (handle_query): Handle 'qGetTIBAddr' query.
	* target.h (target_ops): New get_tib_address field.
	* win32-low.h (win32_thread_info): Add thread_local_base field.
	* win32-low.c (child_add_thread): Add tlb argument.
	Set thread_local_base field to TLB.
	(get_child_debug_event): Adapt to child_add_thread change.
	(win32_get_tib_address): New function.
	(win32_target_ops): Set get_tib_address field to
	win32_get_tib_address.
	* linux-low.c (linux_target_ops): Set get_tib_address field to NULL.

doc/ChangeLog entry:

	gdb.texinfo ($_tlb): Document new automatic convinience variable.
	(info w32 thread-information-block): Document new command.
	(qGetTIBAddress): Document new gdbserver query.
	(maint set/show show-all-tib): Document new command.
@
text
@d195 1
a195 1
static void send_sigstop (struct inferior_list_entry *entry);
d744 1
a744 1
    send_sigstop (&lwp->head);
d784 1
a784 1
    send_sigstop (&lwp->head);
d817 1
a817 1
      send_sigstop (&lwp->head);
d2023 1
a2023 1
send_sigstop (struct inferior_list_entry *entry)
a2024 1
  struct lwp_info *lwp = (struct lwp_info *) entry;
a2026 3
  if (lwp->stopped)
    return;

d2047 11
d2169 1
a2169 1
  for_each_inferior (&all_lwps, send_sigstop);
d2671 1
a2671 1
	  send_sigstop (&lwp->head);
d2691 1
a2691 1
	  send_sigstop (&lwp->head);
d2832 2
a2833 1
  if (thread->last_resume_kind == resume_stop)
d2836 2
a2837 1
	fprintf (stderr, "   client wants LWP %ld stopped\n", lwpid_of (lwp));
d2856 21
@


1.142
log
@	gdb/gdbserver/
	* linux-low.c (linux_mourn): Also remove the process.
	* server.c (handle_target_event): Don't remove the process here.
	* nto-low.c (nto_mourn): New.
	(nto_target_ops): Install it.
	* spu-low.c (spu_mourn): New.
	(spu_target_ops): Install it.
	* win32-low.c (win32_mourn): New.
	(win32_target_ops): Install it.
@
text
@d4337 2
a4338 1
  linux_pause_all
@


1.141
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d904 2
@


1.140
log
@	gdb/gdbserver/
	* server.h (LONGEST): New.
	(struct thread_info) <while_stepping>: New field.
	(unpack_varlen_hex, xrealloc, pulongest, plongest, phex_nz):
	Declare.
	(initialize_tracepoint, handle_tracepoint_general_set)
	(handle_tracepoint_query, tracepoint_finished_step)
	(tracepoint_was_hit, release_while_stepping_state_list):
	(current_traceframe): Declare.
	* server.c (handle_general_set): Handle tracepoint packets.
	(read_memory): New.
	(write_memory): New.
	(handle_search_memory_1): Use read_memory.
	(handle_query): Report support for conditional tracepoints, trace
	state variables, and tracepoint sources.  Handle tracepoint
	queries.
	(main): Initialize the tracepoints module.
	(process_serial_event): Handle traceframe reads/writes.

	* linux-low.c (handle_tracepoints): New.
	(linux_wait_1): Call it.
	(linux_resume_one_lwp): Handle while-stepping.
	(linux_supports_tracepoints, linux_read_pc, linux_write_pc): New.
	(linux_target_ops): Install them.
	* linux-low.h (struct linux_target_ops) <supports_tracepoints>:
	New field.
	* linux-x86-low.c (x86_supports_tracepoints): New.
	(the_low_target). Install it.

	* mem-break.h (delete_breakpoint): Declare.
	* mem-break.c (delete_breakpoint): Make external.

	* target.h (struct target_ops): Add `supports_tracepoints',
	`read_pc', and `write_pc' fields.
	(target_supports_tracepoints): Define.
	* utils.c (xrealloc, decimal2str, pulongest, plongest, thirty_two)
	(phex_nz): New.

	* regcache.h (struct regcache) <registers_owned>: New field.
	(init_register_cache, regcache_cpy): Declare.
	(regcache_read_pc, regcache_write_pc): Declare.
	(register_cache_size): Declare.
	(supply_regblock): Declare.
	* regcache.c (init_register_cache): New.
	(new_register_cache): Use it.
	(regcache_cpy): New.
	(register_cache_size): New.
	(supply_regblock): New.
	(regcache_read_pc, regcache_write_pc): New.

	* tracepoint.c: New.

	* Makefile.in (OBS): Add tracepoint.o.
	(tracepoint.o): New rule.

	gdb/
	* regformats/regdat.sh: Include server.h.  Don't include
	regcache.h.
@
text
@a289 13
/* Remove a process from the common process list,
   also freeing all private data.  */

static void
linux_remove_process (struct process_info *process)
{
  struct process_info_private *priv = process->private;

  free (priv->arch_private);
  free (priv);
  remove_process (process);
}

a523 2
  lwp->last_resume_kind = resume_continue;

d632 1
a632 1
	and the fact that add_lwp sets last_resume_kind ==
a667 2
  struct lwp_info *lwp;

a668 1

d673 6
a678 5
      /* Don't ignore the initial SIGSTOP if we just attached to this
	 process.  It will be collected by wait shortly.  */
      lwp = (struct lwp_info *) find_inferior_id (&all_lwps,
						  ptid_build (pid, pid, 0));
      lwp->last_resume_kind = resume_stop;
a793 3
#ifdef USE_THREAD_DB
  thread_db_free (process, 0);
#endif
d795 2
a796 1
  linux_remove_process (process);
d877 1
a877 1
  thread_db_free (process, 1);
d885 2
a886 1
  linux_remove_process (process);
d891 16
d956 1
a956 1
  if (lwp->last_resume_kind == resume_stop
d1378 1
a1378 1
	  should_stop = (event_child->last_resume_kind == resume_stop
d1443 1
d1450 2
a1451 2
  if (get_lwp_thread (lp)->last_status.kind == TARGET_WAITKIND_IGNORE
      && lp->last_resume_kind != resume_stop
d1467 1
d1469 2
a1470 2
  if (get_lwp_thread (lp)->last_status.kind == TARGET_WAITKIND_IGNORE
      && lp->last_resume_kind == resume_step
d1484 1
d1490 2
a1491 2
  if (lp->last_resume_kind != resume_stop
      && get_lwp_thread (lp)->last_status.kind == TARGET_WAITKIND_IGNORE
d1506 1
d1524 2
a1525 2
  if (lp->last_resume_kind != resume_stop
      && get_lwp_thread (lp)->last_status.kind == TARGET_WAITKIND_IGNORE
d1602 1
a1602 1
  lwp->last_resume_kind = resume_stop;
a1695 6
	  int pid = pid_of (event_child);
	  struct process_info *process = find_process_pid (pid);

#ifdef USE_THREAD_DB
	  thread_db_free (process, 0);
#endif
a1696 1
	  linux_remove_process (process);
d1798 1
a1798 1
		   || event_child->last_resume_kind == resume_step
d1841 1
a1841 1
      if (event_child->last_resume_kind == resume_step)
d1893 2
a1894 1
  if (event_child->last_resume_kind == resume_stop && WSTOPSIG (w) == SIGSTOP)
d1901 2
a1902 1
  else if (event_child->last_resume_kind == resume_stop && WSTOPSIG (w) != SIGSTOP)
d2361 1
a2361 1
	      && lwp->last_resume_kind == resume_stop)
d2374 1
a2374 1
	  lwp->last_resume_kind = lwp->resume->kind;
d2412 1
d2428 3
a2430 1
  if (lwp->last_resume_kind == resume_stop)
d2477 1
a2477 1
  current_inferior = get_lwp_thread (lwp);
d2805 1
d2821 3
a2823 1
  if (lwp->last_resume_kind == resume_stop)
d2845 1
a2845 1
  step = lwp->last_resume_kind == resume_step;
d4038 4
d4271 14
d4290 1
d4333 3
a4335 1
  linux_write_pc
@


1.139
log
@Add x86 AVX support to gdbserver.

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Updated.
	(i386-avx.o): New.
	(i386-avx.c): Likewise.
	(i386-avx-linux.o): Likewise.
	(i386-avx-linux.c): Likewise.
	(amd64-avx.o): Likewise.
	(amd64-avx.c): Likewise.
	(amd64-avx-linux.o): Likewise.
	(amd64-avx-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): Add i386-avx.o.
	(srv_i386_linux_regobj): Add i386-avx-linux.o.
	(srv_amd64_regobj): Add amd64-avx.o.
	(srv_amd64_linux_regobj): Add amd64-avx-linux.o.
	(srv_i386_32bit_xmlfiles): Add i386/32bit-avx.xml.
	(srv_i386_64bit_xmlfiles): Add i386/64bit-avx.xml.
	(srv_i386_xmlfiles): Add i386/i386-avx.xml.
	(srv_amd64_xmlfiles): Add i386/amd64-avx.xml.
	(srv_i386_linux_xmlfiles): Add i386/i386-avx-linux.xml.
	(srv_amd64_linux_xmlfiles): Add i386/amd64-avx-linux.xml.

	* i387-fp.c: Include "i386-xstate.h".
	(i387_xsave): New.
	(i387_cache_to_xsave): Likewise.
	(i387_xsave_to_cache): Likewise.
	(x86_xcr0): Likewise.

	* i387-fp.h (i387_cache_to_xsave): Likewise.
	(i387_xsave_to_cache): Likewise.
	(x86_xcr0): Likewise.

	* linux-arm-low.c (target_regsets): Initialize nt_type to 0.
	* linux-crisv32-low.c (target_regsets): Likewise.
	* linux-m68k-low.c (target_regsets): Likewise.
	* linux-mips-low.c (target_regsets): Likewise.
	* linux-ppc-low.c (target_regsets): Likewise.
	* linux-s390-low.c (target_regsets): Likewise.
	* linux-sh-low.c (target_regsets): Likewise.
	* linux-sparc-low.c (target_regsets): Likewise.
	* linux-xtensa-low.c (target_regsets): Likewise.

	* linux-low.c: Include <sys/uio.h>.
	(regsets_fetch_inferior_registers): Support nt_type.
	(regsets_store_inferior_registers): Likewise.
	(linux_process_qsupported): New.
	(linux_target_ops): Add linux_process_qsupported.

	* linux-low.h (regset_info): Add nt_type.
	(linux_target_ops): Add process_qsupported.

	* linux-x86-low.c: Include "i386-xstate.h", "elf/common.h"
	and <sys/uio.h>.
	(init_registers_i386_avx_linux): New.
	(init_registers_amd64_avx_linux): Likewise.
	(xmltarget_i386_linux_no_xml): Likewise.
	(xmltarget_amd64_linux_no_xml): Likewise.
	(PTRACE_GETREGSET): Likewise.
	(PTRACE_SETREGSET): Likewise.
	(x86_fill_xstateregset): Likewise.
	(x86_store_xstateregset): Likewise.
	(use_xml): Likewise.
	(x86_linux_update_xmltarget): Likewise.
	(x86_linux_process_qsupported): Likewise.
	(target_regsets): Add NT_X86_XSTATE entry and Initialize nt_type.
	(x86_arch_setup): Don't call init_registers_amd64_linux nor
	init_registers_i386_linux here.  Call
	x86_linux_update_xmltarget.
	(the_low_target): Add x86_linux_process_qsupported.

	* server.c (handle_query): Call target_process_qsupported.

	* target.h (target_ops): Add process_qsupported.
	(target_process_qsupported): New.
@
text
@d1120 33
d1625 1
d1764 5
d1786 2
d1805 1
a1805 1
		   || (!step_over_finished && !bp_explains_trap)
d1819 2
d2181 9
d2254 18
d4238 26
d4308 4
a4311 1
  linux_process_qsupported
@


1.138
log
@	* inferiors.c (add_thread): Set last_status kind to
	TARGET_WAITKIND_IGNORE.
	* linux-low.c (cancel_breakpoint): Remove unnecessary regcache
	fetch.  Use ptid_of.  Avoid unnecessary get_lwp_thread calls.
	(linux_wait_1): Move `thread' local definition to block that uses
	it.  Don't NULL initialize `event_child'.
	(linux_resume_one_thread): Avoid unnecessary get_lwp_thread calls.
	Alway set the thread's last_status to TARGET_WAITKIND_IGNORE.
	* linux-x86-low.c (x86_breakpoint_at): Read raw memory.
@
text
@d42 1
d2981 1
d2988 2
a2989 2
      void *buf;
      int res;
d2998 11
d3010 1
a3010 1
      res = ptrace (regset->get_request, pid, 0, buf);
d3012 1
a3012 1
      res = ptrace (regset->get_request, pid, buf, 0);
d3050 1
d3057 2
a3058 2
      void *buf;
      int res;
d3071 11
d3083 1
a3083 1
      res = ptrace (regset->get_request, pid, 0, buf);
d3085 1
a3085 1
      res = ptrace (regset->get_request, pid, buf, 0);
d3095 1
a3095 1
	  res = ptrace (regset->set_request, pid, 0, buf);
d3097 1
a3097 1
	  res = ptrace (regset->set_request, pid, buf, 0);
d4161 7
d4211 2
a4212 1
  linux_core_of_thread
@


1.137
log
@	* linux-low.c (get_stop_pc): Don't adjust the PC if stopped with
	an extended waitstatus, or by a watchpoint.
	(cancel_breakpoints_callback): Don't cancel a breakpoint if the
	thread was stepping or has been stopped by a watchpoint.
@
text
@a1127 1
  struct regcache *regcache;
a1132 2
  regcache = get_thread_regcache (get_lwp_thread (lwp), 1);

d1142 1
a1142 1
		 target_pid_to_str (lwp->head.id));
d1148 1
a1148 1
	    = get_thread_regcache (get_lwp_thread (lwp), 1);
d1161 1
a1161 1
		 target_pid_to_str (lwp->head.id));
d1584 1
a1584 2
  struct thread_info *thread = NULL;
  struct lwp_info *event_child = NULL;
d1610 2
d2616 1
a2616 1
      get_lwp_thread (lwp)->last_status.kind = TARGET_WAITKIND_IGNORE;
a2635 1
      get_lwp_thread (lwp)->last_status.kind = TARGET_WAITKIND_IGNORE;
d2663 1
@


1.136
log
@	* linux-low.c (linux_wait_1): Avoid setting need_step_over is
	there's a GDB breakpoint at stop_pc.  Always report a trap to GDB
	if we could tell there's a GDB breakpoint at stop_pc.
	(need_step_over_p): Don't do a step over if we find a GDB
	breakpoint at the resume PC.

	* mem-break.c (struct raw_breakpoint): New.
	(enum bkpt_type): New type `gdb_breakpoint'.
	(struct breakpoint): Delete the `PC', `old_data' and `inserted'
	fields.  New field `raw'.
	(find_raw_breakpoint_at): New.
	(set_raw_breakpoint_at): Handle refcounting.  Create a raw
	breakpoint instead.
	(set_breakpoint_at): Adjust.
	(delete_raw_breakpoint): New.
	(release_breakpoint): New.
	(delete_breakpoint): Rename to...
	(delete_breakpoint_1): ... this.  Add proc parameter.  Use
	release_breakpoint.  Return ENOENT.
	(delete_breakpoint): Reimplement.
	(find_breakpoint_at): Delete.
	(find_gdb_breakpoint_at): New.
	(delete_breakpoint_at): Delete.
	(set_gdb_breakpoint_at): New.
	(delete_gdb_breakpoint_at): New.
	(gdb_breakpoint_here): New.
	(set_reinsert_breakpoint): Use release_breakpoint.
	(uninsert_breakpoint): Rename to ...
	(uninsert_raw_breakpoint): ... this.
	(uninsert_breakpoints_at): Adjust to handle raw breakpoints.
	(reinsert_raw_breakpoint): Change parameter type to
	raw_breakpoint.
	(reinsert_breakpoints_at): Adjust to handle raw breakpoints
	instead.
	(check_breakpoints): Adjust.  Use release_breakpoint.
	(breakpoint_here): Rewrite using find_raw_breakpoint_at.
	(breakpoint_inserted_here): Ditto.
	(check_mem_read): Adjust to iterate over raw breakpoints instead.
	Don't trust the breakpoint's shadow if it is not inserted.
	(check_mem_write): Adjust to iterate over raw breakpoints instead.
	(delete_all_breakpoints): Adjust.
	(free_all_breakpoints): Mark all breakpoints as uninserted, and
	use delete_breakpoint_1.

	* mem-break.h (breakpoints_supported): Delete declaration.
	(set_gdb_breakpoint_at): Declare.
	(gdb_breakpoint_here): Declare.
	(delete_breakpoint_at): Delete.
	(delete_gdb_breakpoint_at): Declare.

	* server.h (struct raw_breakpoint): Forward declare.
	(struct process_info): New field `raw_breakpoints'.

	* linux-x86-low.c (x86_insert_point, x86_remote_point): Handle Z0
	breakpoints.
@
text
@d514 4
a517 1
  if (WSTOPSIG (lwp->last_status) == SIGTRAP && !lwp->stepping)
a1133 9
  if (lwp->stepping)
    {
      if (debug_threads)
	fprintf (stderr,
		 "CB: [%s] is stepping\n",
		 target_pid_to_str (lwp->head.id));
      return 0;
    }

d1496 2
@


1.135
log
@	* linux-low.c (status_pending_p_callback): Fix comment.
	(linux_wait_for_event_1): Move most of the internal breakpoint
	handling from here...
	(linux_wait_1): ... to here.
	(count_events_callback): New.
	(select_singlestep_lwp_callback): New.
	(select_event_lwp_callback): New.
	(cancel_breakpoints_callback): New.
	(select_event_lwp): New.
	(linux_wait_1): Simplify internal breakpoint handling.  Give equal
	priority to all LWPs that have had events that should be reported
	to the client.  Cancel breakpoints when about to reporting the
	event to the client, not while stopping lwps.  No longer cancel
	finished single-steps here.
	(cancel_finished_single_step): Delete.
	(cancel_finished_single_steps): Delete.
@
text
@d1743 2
a1744 1
	  event_child->need_step_over = 1;
d1759 7
a1765 1
     and let GDB handle it.  */
d1769 2
a1770 1
		   || (!step_over_finished && !bp_explains_trap));
d1812 2
d2414 1
a2414 1
  /* We only step over our breakpoints.  */
d2417 9
a2425 4
      if (debug_threads)
	fprintf (stderr,
		 "Need step over [LWP %ld]? yes, found breakpoint at 0x%s\n",
		 lwpid_of (lwp), paddress (pc));
d2427 18
a2444 7
      /* We've found an lwp that needs stepping over --- return 1 so
	 that find_inferior stops looking.  */
      current_inferior = saved_inferior;

      /* If the step over is cancelled, this is set again.  */
      lwp->need_step_over = 0;
      return 1;
@


1.134
log
@	Teach linux gdbserver to step-over-breakpoints.

	* linux-low.c (can_hardware_single_step): New.
	(supports_breakpoints): New.
	(handle_extended_wait): If stopping threads, read the stop pc of
	the new cloned LWP.
	(get_pc): New.
	(get_stop_pc): Add `lwp' parameter.  Handle it.  Bail out if the
	low target doesn't support retrieving the PC.
	(add_lwp): Set last_resume_kind to resume_continue.
	(linux_attach_lwp_1): Adjust comments.  Always set stop_expected.
	(linux_attach): Don't clear stop_expected.  Set the lwp's
	last_resume_kind to resume_stop.
	(linux_detach_one_lwp): Don't check for removed breakpoints.
	(check_removed_breakpoint): Delete.
	(status_pending_p): Rename to ...
	(status_pending_p_callback): ... this.  Don't check for removed
	breakpoints.  Don't consider threads that are stopped from GDB's
	perspective.
	(linux_wait_for_lwp): Always read the stop_pc here.
	(cancel_breakpoint): New.
	(step_over_bkpt): New global.
	(linux_wait_for_event_1): Implement stepping over breakpoints.
	(gdb_wants_lwp_stopped): New.
	(gdb_wants_all_stopped): New.
	(linux_wait_1): Tag threads as gdb-wants-stopped.  Cancel finished
	single-step traps here.  Store the thread's last reported target
	wait status.
	(send_sigstop): Don't clear stop_expected.  Always set it,
	instead.
	(mark_lwp_dead): Remove reference to pending_is_breakpoint.
	(cancel_finished_single_step): New.
	(cancel_finished_single_steps): New.
	(wait_for_sigstop): Don't cancel finished single-step traps here.
	(linux_resume_one_lwp): Don't check for removed breakpoints.
	Don't set `step' on non-hardware step archs.
	(linux_set_resume_request): Ignore resume_stop requests if already
	stopping or stopped.  Set the lwp's last_resume_kind.
	(resume_status_pending_p): Don't check for removed breakpoints.
	(need_step_over_p): New.
	(start_step_over): New.
	(finish_step_over): New.
	(linux_resume_one_thread): Always queue a sigstop for resume_stop
	requests.  Clear the thread's last reported target waitstatus.
	Don't use the `suspended' flag.  Don't consider pending breakpoints.
	(linux_resume): Start a step-over if necessary.
	(proceed_one_lwp): New.
	(proceed_all_lwps): New.
	(unstop_all_lwps): New.
	* linux-low.h (struct lwp_info): Rewrite comment for the
	`suspended' flag.  Add the `stop_pc' field.  Delete the
	`pending_stop_pc' field.  Tweak the `stepping' flag's comment.
	Add `'last_resume_kind' and `need_step_over' fields.
	* inferiors.c (struct thread_info): Delete, moved elsewhere.
	* mem-break.c (struct breakpoint): Delete `reinserting' flag.
	Delete `breakpoint_to_reinsert' field.  New flag `inserted'.
	(set_raw_breakpoint_at): New.
	(set_breakpoint_at): Rewrite to use it.
	(reinsert_breakpoint_handler): Delete.
	(set_reinsert_breakpoint): New.
	(reinsert_breakpoint_by_bp): Delete.
	(delete_reinsert_breakpoints): New.
	(uninsert_breakpoint): Rewrite.
	(uninsert_breakpoints_at): New.
	(reinsert_breakpoint): Rewrite.
	(reinsert_breakpoints_at): New.
	(check_breakpoints): Rewrite.
	(breakpoint_here): New.
	(breakpoint_inserted_here): New.
	(check_mem_read): Adjust.
	* mem-break.h (breakpoints_supported, breakpoint_here)
	(breakpoint_inserted_here, set_reinsert_breakpoint): Declare.
	(reinsert_breakpoint_by_bp): Delete declaration.
	(delete_reinsert_breakpoints): Declare.
	(reinsert_breakpoint): Delete declaration.
	(reinsert_breakpoints_at): Declare.
	(uninsert_breakpoint): Delete declaration.
	(uninsert_breakpoints_at): Declare.
	(check_breakpoints): Adjust prototype.
	* server.h: Adjust include order.
	(struct thread_info): Declare here.  Add a `last_status' field.
@
text
@a148 1
static void cancel_finished_single_steps (struct lwp_info *except);
d936 1
a936 2
/* Return 1 if this lwp has an interesting status pending.  This
   function may silently resume an inferior lwp.  */
a1189 1
  CORE_ADDR stop_pc;
a1191 1
 again:
d1231 1
a1231 14
      int step_over_finished = 0;
      int bp_explains_trap = 0;
      int cancel_sigtrap;

      if (ptid_equal (step_over_bkpt, null_ptid))
	event_child = linux_wait_for_lwp (ptid, wstat, options);
      else
	{
	  if (debug_threads)
	    fprintf (stderr, "step_over_bkpt set [%s], doing a blocking wait\n",
		     target_pid_to_str (step_over_bkpt));
	  event_child = linux_wait_for_lwp (step_over_bkpt,
					    wstat, options & ~WNOHANG);
	}
a1365 212
      cancel_sigtrap = (stopping_threads
			|| event_child->last_resume_kind == resume_stop);

      /* Do not allow nested internal breakpoint handling, or leave
	 the unadjusted PCs visible to GDB.  Simply cancel the
	 breakpoint now, and eventually when the thread is resumed, it
	 will trap again, if the breakpoint is still there by
	 then.  */
      if (WIFSTOPPED (*wstat)
	  && WSTOPSIG (*wstat) == SIGTRAP
	  && cancel_sigtrap)
	{
	  if (debug_threads)
	    fprintf (stderr, "Got a nested SIGTRAP while stopping threads\n");

	  if (cancel_breakpoint (event_child))
	    {
	      if (debug_threads)
		fprintf (stderr, " bkpt canceled\n");

	      /* We don't resume immediately to collect the SIGSTOP,
		 due to other reasons we may care for this SIGTRAP
		 below.  Care must be taken to not process anything
		 breakpoint related though from this point on.  */
	    }
	}

      /* If this event was not handled above, and is not a SIGTRAP, we
	 report it.  SIGILL and SIGSEGV are also treated as traps in
	 case a breakpoint is inserted at the current PC.  If this
	 target does not support breakpoints, we also report the
	 SIGTRAP without further processing; it's of no concern to
	 us.  */
      if (!WIFSTOPPED (*wstat)
	  || !supports_breakpoints ()
	  || (WSTOPSIG (*wstat) != SIGTRAP
	      && WSTOPSIG (*wstat) != SIGILL
	      && WSTOPSIG (*wstat) != SIGSEGV)
	  /* Only handle SIGILL or SIGSEGV if we've hit a recognized
	     breakpoint.  */
	  || (WSTOPSIG (*wstat) != SIGTRAP
	      && !(*the_low_target.breakpoint_at) (event_child->stop_pc)))
	{
	  if (debug_threads && WIFSTOPPED (*wstat))
	    fprintf (stderr, "Reporting signal %d for LWP %ld.\n",
		     WSTOPSIG (*wstat), lwpid_of (event_child));

	  /* If we were stepping over a breakpoint, this signal
	     arriving means we didn't manage to move past the
	     breakpoint location.  Cancel the operation for now --- it
	     will be handled again on the next resume, if required
	     (the breakpoint may be removed meanwhile, for
	     example).  */
	  if (finish_step_over (event_child))
	    {
	      event_child->need_step_over = 1;
	      unstop_all_lwps (event_child);
	    }
	  return lwpid_of (event_child);
	}

      stop_pc = event_child->stop_pc;

      /* Handle anything that requires bookkeeping before deciding to
	 report the event or continue waiting.  */

      /* First check if we can explain the SIGTRAP with an internal
	 breakpoint, or if we should possibly report the event to GDB.
	 Do this before anything that may remove or insert a
	 breakpoint.  */
      bp_explains_trap = breakpoint_inserted_here (stop_pc);

      /* We have a SIGTRAP, possibly a step-over dance has just
	 finished.  If so, tweak the state machine accordingly,
	 reinsert breakpoints and delete any reinsert (software
	 single-step) breakpoints.  */
      step_over_finished = finish_step_over (event_child);

      /* Now invoke the callbacks of any breakpoints there.  */
      if (!cancel_sigtrap)
	check_breakpoints (stop_pc);

      /* If we're stopping threads, resume once more to collect the
	 SIGSTOP, and do nothing else.  Note that we don't set
	 need_step_over.  If this predicate matches, then we've
	 cancelled the SIGTRAP before reaching here, and we do want
	 any breakpoint at STOP_PC to be re-hit on resume.  */
      if (stopping_threads
	  || event_child->last_resume_kind == resume_stop)
	{
	  gdb_assert (cancel_sigtrap);

	  if (step_over_finished)
	    unstop_all_lwps (event_child);

	  if (debug_threads)
	    {
	      if (event_child->last_resume_kind == resume_stop)
		fprintf (stderr, "Bailing out; GDB wanted the LWP to stop.\n");
	      else if (stopping_threads)
		fprintf (stderr, "Bailing out; stopping threads.\n");

	      if (bp_explains_trap)
		fprintf (stderr, "   Hit a breakpoint.\n");
	      if (step_over_finished)
		fprintf (stderr, "   Step-over finished.\n");
	      if (event_child->stopped_by_watchpoint)
		fprintf (stderr, "   Stopped by watchpoint.\n");
	    }

	  /* Leave these pending.  */
	  if (event_child->stopped_by_watchpoint)
	    return lwpid_of (event_child);

	  /* Otherwise, there may or not be a pending SIGSTOP.  If
	     there isn't one, queue one up.  In any case, go back to
	     the event loop to collect it.  Don't return yet, as we
	     don't want this SIGTRAP to be left pending.  Note that
	     since we cancelled the breakpoint above, the PC is
	     already adjusted, and hence get_stop_pc returns the
	     correct PC when we collect the SIGSTOP.  */

	  if (!event_child->stop_expected)
	    {
	      event_child->stop_expected = 1;
	      kill_lwp (lwpid_of (event_child), SIGSTOP);
	    }

	  /* Clear the single-stepping flag and SIGTRAP as we resume.  */
	  linux_resume_one_lwp (event_child, 0, 0, NULL);
	  continue;
	}

      /* We have all the data we need.  Either report the event to
	 GDB, or resume threads and keep waiting for more.  */

      /* Check If GDB would be interested in this event.  If GDB
	 wanted this thread to single step, we always want to report
	 the SIGTRAP, and let GDB handle it.  */
      if ((event_child->last_resume_kind == resume_step)
	  || event_child->stopped_by_watchpoint)
	{
	  if (step_over_finished)
	    unstop_all_lwps (event_child);

	  if (debug_threads)
	    {
	      if (event_child->last_resume_kind == resume_step)
		fprintf (stderr, "GDB wanted to single-step, reporting event.\n");
	      if (event_child->stopped_by_watchpoint)
		fprintf (stderr, "Stopped by watchpoint.\n");
	    }
	}
      /* We found no reason GDB would want us to stop.  We either hit
	 one of our own breakpoints, or finished an internal step GDB
	 shouldn't know about.  */
      else if (step_over_finished || bp_explains_trap)
	{
	  if (debug_threads)
	    {
	      if (bp_explains_trap)
		fprintf (stderr, "Hit a gdbserver breakpoint.\n");
	      if (step_over_finished)
		fprintf (stderr, "Step-over finished.\n");
	    }

	  /* If we stepped or ran into an internal breakpoint, we've
	     already handled it.  So next time we resume (from this
	     PC), we should step over it.  */
	  if (breakpoint_here (stop_pc))
	    event_child->need_step_over = 1;

	  /* We're not reporting this breakpoint to GDB, so apply the
	     decr_pc_after_break adjustment to the inferior's regcache
	     ourselves.  */

	  if (the_low_target.set_pc != NULL)
	    {
	      struct regcache *regcache
		= get_thread_regcache (get_lwp_thread (event_child), 1);
	      (*the_low_target.set_pc) (regcache, stop_pc);
	    }

	  /* We've finished stepping over a breakpoint.  We've stopped
	     all LWPs momentarily except the stepping one.  This is
	     where we resume them all again.  We're going to keep
	     waiting, so use proceed, which handles stepping over the
	     next breakpoint.  */
	  if (debug_threads)
	    fprintf (stderr, "proceeding all threads.\n");
	  proceed_all_lwps ();

	  /* If we stopped threads momentarily, we may have threads
	     with pending statuses now (except when we're going to
	     force the next event out of a specific LWP, in which case
	     don't want to handle the pending events of other LWPs
	     yet.  */
	  if (ptid_equal (step_over_bkpt, null_ptid))
	    goto again;
	  else
	    continue;
	}
      else
	{
	  /* GDB breakpoint or program trap, perhaps.  */
	  if (step_over_finished)
	    unstop_all_lwps (event_child);
	}

      if (debug_threads)
	fprintf (stderr, "Hit a non-gdbserver trap event.\n");

d1413 145
d1592 1
a1592 1
  struct lwp_info *lwp = NULL;
d1595 4
d1634 10
a1643 1
  pid = linux_wait_for_event (ptid, &w, options);
d1647 1
a1647 1
  lwp = get_thread_lwp (current_inferior);
d1665 1
a1665 1
	  int pid = pid_of (lwp);
d1671 1
a1671 1
	  delete_lwp (lwp);
d1703 143
d1850 1
a1850 1
  if (lwp->last_resume_kind == resume_stop && WSTOPSIG (w) == SIGSTOP)
d1857 1
a1857 1
  else if (lwp->last_resume_kind == resume_stop && WSTOPSIG (w) != SIGSTOP)
a1871 11
      /* In all-stop, stop all threads, we're about to report an event
	 to GDB.  */
      stop_all_lwps ();

      /* Do not leave a pending single-step finish to be reported to
	 the client.  The client will give us a new action for this
	 thread, possibly a continue request --- otherwise, the client
	 would consider this pending SIGTRAP reported later a spurious
	 signal.  */
      cancel_finished_single_steps (lwp);

d1881 1
a1881 1
      gdb_wants_lwp_stopped (&lwp->head);
d1886 1
a1886 1
	     target_pid_to_str (lwp->head.id),
d1890 2
a1891 2
  get_lwp_thread (lwp)->last_status = *ourstatus;
  return lwp->head.id;
a2019 39
static int
cancel_finished_single_step (struct inferior_list_entry *entry, void *except)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *saved_inferior;

  if (lwp == except)
    return 0;

  saved_inferior = current_inferior;
  current_inferior = get_lwp_thread (lwp);

  /* Do not leave a pending single-step finish to be reported to the
     client.  The client will give us a new action for this thread,
     possibly a continue request --- otherwise, the client would
     consider this pending SIGTRAP reported later a spurious
     signal.  */
  if (lwp->status_pending_p
      && WSTOPSIG (lwp->status_pending) == SIGTRAP
      && lwp->stepping
      && !lwp->stopped_by_watchpoint)
    {
      if (debug_threads)
	fprintf (stderr, "  single-step SIGTRAP cancelled\n");

      lwp->status_pending_p = 0;
      lwp->status_pending = 0;
    }

  current_inferior = saved_inferior;
  return 0;
}

static void
cancel_finished_single_steps (struct lwp_info *except)
{
  find_inferior (&all_lwps, cancel_finished_single_step, except);
}

@


1.133
log
@	* linux-low.c (fetch_register): Avoid passing a non string literal
	format to `error'.
	(usr_store_inferior_registers): Ditto.
@
text
@a142 1
static int check_removed_breakpoint (struct lwp_info *event_child);
d147 24
d429 3
a431 1
	  if (! stopping_threads)
d437 1
d440 1
d457 27
a483 1
/* This function should only be called if the process got a SIGTRAP.
d506 1
a506 1
get_stop_pc (void)
d508 4
a511 2
  struct regcache *regcache = get_thread_regcache (current_inferior, 1);
  CORE_ADDR stop_pc = (*the_low_target.get_pc) (regcache);
d513 3
a515 2
  if (! get_thread_lwp (current_inferior)->stepping
      && WSTOPSIG (get_thread_lwp (current_inferior)->last_status) == SIGTRAP)
d534 2
d642 4
a645 2
	In this case we should ignore that SIGSTOP and resume the process.
	This is handled below by setting stop_expected = 1.
d650 2
a651 2
	This is handled by having linux_attach clear stop_expected after
	we return.
d668 1
a668 2
  if (! stopping_threads)
    new_lwp->stop_expected = 1;
d692 1
a692 1
      lwp->stop_expected = 0;
a847 4
  /* Make sure the process isn't stopped at a breakpoint that's
     no longer there.  */
  check_removed_breakpoint (lwp);

a936 67
/* Return nonzero if this process stopped at a breakpoint which
   no longer appears to be inserted.  Also adjust the PC
   appropriately to resume where the breakpoint used to be.  */
static int
check_removed_breakpoint (struct lwp_info *event_child)
{
  CORE_ADDR stop_pc;
  struct thread_info *saved_inferior;
  struct regcache *regcache;

  if (event_child->pending_is_breakpoint == 0)
    return 0;

  if (debug_threads)
    fprintf (stderr, "Checking for breakpoint in lwp %ld.\n",
	     lwpid_of (event_child));

  saved_inferior = current_inferior;
  current_inferior = get_lwp_thread (event_child);
  regcache = get_thread_regcache (current_inferior, 1);
  stop_pc = get_stop_pc ();

  /* If the PC has changed since we stopped, then we shouldn't do
     anything.  This happens if, for instance, GDB handled the
     decr_pc_after_break subtraction itself.  */
  if (stop_pc != event_child->pending_stop_pc)
    {
      if (debug_threads)
	fprintf (stderr, "Ignoring, PC was changed.  Old PC was 0x%08llx\n",
		 event_child->pending_stop_pc);

      event_child->pending_is_breakpoint = 0;
      current_inferior = saved_inferior;
      return 0;
    }

  /* If the breakpoint is still there, we will report hitting it.  */
  if ((*the_low_target.breakpoint_at) (stop_pc))
    {
      if (debug_threads)
	fprintf (stderr, "Ignoring, breakpoint is still present.\n");
      current_inferior = saved_inferior;
      return 0;
    }

  if (debug_threads)
    fprintf (stderr, "Removed breakpoint.\n");

  /* For decr_pc_after_break targets, here is where we perform the
     decrement.  We go immediately from this function to resuming,
     and can not safely call get_stop_pc () again.  */
  if (the_low_target.set_pc != NULL)
    {
      if (debug_threads)
	fprintf (stderr, "Set pc to 0x%lx\n", (long) stop_pc);
      (*the_low_target.set_pc) (regcache, stop_pc);
    }

  /* We consumed the pending SIGTRAP.  */
  event_child->pending_is_breakpoint = 0;
  event_child->status_pending_p = 0;
  event_child->status_pending = 0;

  current_inferior = saved_inferior;
  return 1;
}

d940 1
a940 1
status_pending_p (struct inferior_list_entry *entry, void *arg)
d944 1
d952 7
a958 12
  if (lwp->status_pending_p && !lwp->suspended)
    if (check_removed_breakpoint (lwp))
      {
	/* This thread was stopped at a breakpoint, and the breakpoint
	   is now gone.  We were told to continue (or step...) all threads,
	   so GDB isn't trying to single-step past this breakpoint.
	   So instead of reporting the old SIGTRAP, pretend we got to
	   the breakpoint just after it was removed instead of just
	   before; resume the process.  */
	linux_resume_one_lwp (lwp, 0, 0, NULL);
	return 0;
      }
d960 1
a960 1
  return (lwp->status_pending_p && !lwp->suspended);
a1031 1
  child->pending_is_breakpoint = 0;
d1093 7
d1108 1
a1108 2
      current_inferior = (struct thread_info *)
	find_inferior_id (&all_threads, child->head.id);
d1118 65
d1193 5
a1197 3
  struct lwp_info *event_child = NULL;
  int bp_status;
  struct lwp_info *requested_child = NULL;
a1199 3
  /* It is possible that the user changed the pending task's registers since
     it stopped.  We correctly handle the change of PC if we hit a breakpoint
     (in check_removed_breakpoint); signals should be reported anyway.  */
d1205 1
a1205 1
	find_inferior (&all_lwps, status_pending_p, &ptid);
d1212 2
a1213 2
      if (requested_child->status_pending_p
	  && !check_removed_breakpoint (requested_child))
d1235 14
a1248 1
      event_child = linux_wait_for_lwp (ptid, wstat, options);
d1251 5
a1255 1
	return 0;
a1276 2
	  delete_lwp (event_child);

d1294 12
a1305 1
	    return lwpid_of (event_child);
a1317 11
      if (WIFSTOPPED (*wstat)
	  && WSTOPSIG (*wstat) == SIGSTOP
	  && event_child->stop_expected)
	{
	  if (debug_threads)
	    fprintf (stderr, "Expected stop.\n");
	  event_child->stop_expected = 0;
	  linux_resume_one_lwp (event_child, event_child->stepping, 0, NULL);
	  continue;
	}

d1344 2
a1345 1
	       && (WSTOPSIG (*wstat) != SIGSTOP || !stopping_threads))))
d1357 1
a1357 2
	  linux_resume_one_lwp (event_child,
				event_child->stepping,
d1362 20
a1381 12
      /* If this event was not handled above, and is not a SIGTRAP,
	 report it.  SIGILL and SIGSEGV are also treated as traps in case
	 a breakpoint is inserted at the current PC.  */
      if (!WIFSTOPPED (*wstat)
	  || (WSTOPSIG (*wstat) != SIGTRAP && WSTOPSIG (*wstat) != SIGILL
	      && WSTOPSIG (*wstat) != SIGSEGV))
	return lwpid_of (event_child);

      /* If this target does not support breakpoints, we simply report the
	 signal; it's of no concern to us.  */
      if (the_low_target.get_pc == NULL)
	return lwpid_of (event_child);
d1383 2
a1384 1
      stop_pc = get_stop_pc ();
d1386 8
a1393 12
      /* Only handle SIGILL or SIGSEGV if we've hit a recognized
	 breakpoint.  */
      if (WSTOPSIG (*wstat) != SIGTRAP
	  && (event_child->stepping
	      || ! (*the_low_target.breakpoint_at) (stop_pc)))
	return lwpid_of (event_child);

      /* bp_reinsert will only be set if we were single-stepping.
	 Notice that we will resume the process after hitting
	 a gdbserver breakpoint; single-stepping to/over one
	 is not supported (yet).  */
      if (event_child->bp_reinsert != 0)
d1396 13
a1408 3
	    fprintf (stderr, "Reinserted breakpoint.\n");
	  reinsert_breakpoint (event_child->bp_reinsert);
	  event_child->bp_reinsert = 0;
d1410 32
a1441 3
	  /* Clear the single-stepping flag and SIGTRAP as we resume.  */
	  linux_resume_one_lwp (event_child, 0, 0, NULL);
	  continue;
d1444 4
a1447 1
      bp_status = check_breakpoints (stop_pc);
d1449 23
a1471 1
      if (bp_status != 0)
d1473 5
d1479 13
a1491 1
	    fprintf (stderr, "Hit a gdbserver breakpoint.\n");
d1493 3
a1495 20
	  /* We hit one of our own breakpoints.  We mark it as a pending
	     breakpoint, so that check_removed_breakpoint () will do the PC
	     adjustment for us at the appropriate time.  */
	  event_child->pending_is_breakpoint = 1;
	  event_child->pending_stop_pc = stop_pc;

	  /* We may need to put the breakpoint back.  We continue in the event
	     loop instead of simply replacing the breakpoint right away,
	     in order to not lose signals sent to the thread that hit the
	     breakpoint.  Unfortunately this increases the window where another
	     thread could sneak past the removed breakpoint.  For the current
	     use of server-side breakpoints (thread creation) this is
	     acceptable; but it needs to be considered before this breakpoint
	     mechanism can be used in more general ways.  For some breakpoints
	     it may be necessary to stop all other threads, but that should
	     be avoided where possible.

	     If breakpoint_reinsert_addr is NULL, that means that we can
	     use PTRACE_SINGLESTEP on this platform.  Uninsert the breakpoint,
	     mark it for reinsertion, and single-step.
d1497 7
a1503 3
	     Otherwise, call the target function to figure out where we need
	     our temporary breakpoint, create it, and continue executing this
	     process.  */
d1505 1
a1505 14
	  /* NOTE: we're lifting breakpoints in non-stop mode.  This
	     is currently only used for thread event breakpoints, so
	     it isn't that bad as long as we have PTRACE_EVENT_CLONE
	     events.  */
	  if (bp_status == 2)
	    /* No need to reinsert.  */
	    linux_resume_one_lwp (event_child, 0, 0, NULL);
	  else if (the_low_target.breakpoint_reinsert_addr == NULL)
	    {
	      event_child->bp_reinsert = stop_pc;
	      uninsert_breakpoint (stop_pc);
	      linux_resume_one_lwp (event_child, 1, 0, NULL);
	    }
	  else
d1507 2
a1508 3
	      reinsert_breakpoint_by_bp
		(stop_pc, (*the_low_target.breakpoint_reinsert_addr) ());
	      linux_resume_one_lwp (event_child, 0, 0, NULL);
d1511 2
d1516 58
a1573 2
      if (debug_threads)
	fprintf (stderr, "Hit a non-gdbserver breakpoint.\n");
d1575 11
a1585 16
      /* If we were single-stepping, we definitely want to report the
	 SIGTRAP.  Although the single-step operation has completed,
	 do not clear clear the stepping flag yet; we need to check it
	 in wait_for_sigstop.  */
      if (event_child->stepping)
	return lwpid_of (event_child);

      /* A SIGTRAP that we can't explain.  It may have been a breakpoint.
	 Check if it is a breakpoint, and if so mark the process information
	 accordingly.  This will handle both the necessary fiddling with the
	 PC on decr_pc_after_break targets and suppressing extra threads
	 hitting a breakpoint if two hit it at once and then GDB removes it
	 after the first is reported.  Arguably it would be better to report
	 multiple threads hitting breakpoints simultaneously, but the current
	 remote protocol does not allow this.  */
      if ((*the_low_target.breakpoint_at) (stop_pc))
d1587 3
a1589 2
	  event_child->pending_is_breakpoint = 1;
	  event_child->pending_stop_pc = stop_pc;
d1592 3
d1642 26
a1773 5
  /* In all-stop, stop all threads.  Be careful to only do this if
     we're about to report an event to GDB.  */
  if (!non_stop)
    stop_all_lwps ();

d1776 3
a1778 1
  if (lwp->suspended && WSTOPSIG (w) == SIGSTOP)
d1785 1
a1785 1
  else if (lwp->suspended && WSTOPSIG (w) != SIGSTOP)
d1788 1
a1788 3
	 but, it stopped for other reasons.  Set stop_expected so the
	 pending SIGSTOP is ignored and the LWP is resumed.  */
      lwp->stop_expected = 1;
d1796 27
d1829 1
a1931 4
      /* We clear the stop_expected flag so that wait_for_sigstop
	 will receive the SIGSTOP event (instead of silently resuming and
	 waiting again).  It'll be reset below.  */
      lwp->stop_expected = 0;
d1938 1
a1951 4
  /* So that check_removed_breakpoint doesn't try to figure out if
     this is stopped at a breakpoint.  */
  lwp->pending_is_breakpoint = 0;

d1959 39
d2006 1
d2009 6
a2014 1
    return;
d2024 4
a2027 1
  linux_wait_for_event (ptid, &wstat, __WALL);
d2032 1
a2032 2
  if (WIFSTOPPED (wstat)
      && WSTOPSIG (wstat) != SIGSTOP)
d2035 2
a2036 2
	fprintf (stderr, "LWP %ld stopped with non-sigstop status %06x\n",
		 lwpid_of (lwp), wstat);
d2038 1
a2038 8
      /* Do not leave a pending single-step finish to be reported to
	 the client.  The client will give us a new action for this
	 thread, possibly a continue request --- otherwise, the client
	 would consider this pending SIGTRAP reported later a spurious
	 signal.  */
      if (WSTOPSIG (wstat) == SIGTRAP
	  && lwp->stepping
	  && !lwp->stopped_by_watchpoint)
d2041 3
a2043 4
	    fprintf (stderr, "  single-step SIGTRAP ignored\n");
	}
      else
	{
a2046 1
      lwp->stop_expected = 1;
d2048 1
a2048 1
  else if (!WIFSTOPPED (wstat))
d2051 1
a2051 2
	fprintf (stderr, "Process %ld exited while stopping LWPs\n",
		 lwpid_of (lwp));
d2053 12
a2064 5
      /* Leave this status pending for the next time we're able to
	 report it.  In the mean time, we'll report this lwp as dead
	 to GDB, so GDB doesn't try to read registers and memory from
	 it.  */
      mark_lwp_dead (lwp, wstat);
d2129 9
a2137 2
  if (lwp->status_pending_p && !check_removed_breakpoint (lwp))
    return;
d2160 10
a2169 4
	fprintf (stderr, "  pending reinsert at %08lx", (long)lwp->bp_reinsert);
      if (step == 0)
	fprintf (stderr, "BAD - reinserting but not stepping.\n");
      step = 1;
a2174 2
  check_removed_breakpoint (lwp);

d2266 13
d2280 1
a2302 8
  /* If this thread has a removed breakpoint, we won't have any
     events to report later, so check now.  check_removed_breakpoint
     may clear status_pending_p.  We avoid calling check_removed_breakpoint
     for any thread that we are not otherwise going to resume - this
     lets us preserve stopped status when two threads hit a breakpoint.
     GDB removes the breakpoint to single-step a particular thread
     past it, then re-inserts it and resumes all threads.  We want
     to report the second thread without resuming it in the interim.  */
d2304 44
a2347 1
    check_removed_breakpoint (lwp);
d2350 55
a2404 1
    * (int *) flag_p = 1;
d2409 100
d2528 2
a2529 1
  int pending_flag = * (int *) arg;
d2540 1
a2540 1
	fprintf (stderr, "suspending LWP %ld\n", lwpid_of (lwp));
d2545 1
a2545 1
	    fprintf (stderr, "running -> suspending LWP %ld\n", lwpid_of (lwp));
d2547 2
a2548 1
	  lwp->suspended = 1;
d2554 2
a2555 8
	    {
	      if (lwp->suspended)
		fprintf (stderr, "already stopped/suspended LWP %ld\n",
			 lwpid_of (lwp));
	      else
		fprintf (stderr, "already stopped/not suspended LWP %ld\n",
			 lwpid_of (lwp));
	    }
d2557 13
a2569 7
	  /* Make sure we leave the LWP suspended, so we don't try to
	     resume it without GDB telling us to.  FIXME: The LWP may
	     have been stopped in an internal event that was not meant
	     to be notified back to GDB (e.g., gdbserver breakpoint),
	     so we should be reporting a stop event in that case
	     too.  */
	  lwp->suspended = 1;
d2574 1
a2576 2
  else
    lwp->suspended = 0;
d2582 4
a2585 3
     thread has a pending status.  */
  if (non_stop)
    resume_status_pending_p (&lwp->head, &pending_flag);
d2587 1
a2587 1
  if (!pending_flag)
d2592 1
a2592 7
      if (ptid_equal (lwp->resume->thread, minus_one_ptid)
	  && lwp->stepping
	  && lwp->pending_is_breakpoint)
	step = 1;
      else
	step = (lwp->resume->kind == resume_step);

d2594 1
a2628 1
  int pending_flag;
d2630 3
d2636 7
a2642 6
  /* If there is a thread which would otherwise be resumed, which
     has a pending status, then don't resume any threads - we can just
     report the pending status.  Make sure to queue any signals
     that would otherwise be sent.  In non-stop mode, we'll apply this
     logic to each thread individually.  */
  pending_flag = 0;
d2644 120
a2763 1
    find_inferior (&all_lwps, resume_status_pending_p, &pending_flag);
d2766 13
d2780 3
a2782 2
      if (pending_flag)
	fprintf (stderr, "Not resuming, pending status\n");
d2784 2
a2785 1
	fprintf (stderr, "Resuming, no pending status\n");
d2788 8
a2795 1
  find_inferior (&all_threads, linux_resume_one_thread, &pending_flag);
@


1.132
log
@	* linux-low.c (linux_write_memory): Bail out early if peeking
	memory failed.
@
text
@d2220 1
a2220 9
	{
	  /* Warning, not error, in case we are attached; sometimes the
	     kernel doesn't let us at the registers.  */
	  char *err = strerror (errno);
	  char *msg = alloca (strlen (err) + 128);
	  sprintf (msg, "reading register %d: %s", regno, err);
	  error (msg);
	  goto error_exit;
	}
a2226 2

error_exit:;
d2292 1
a2292 8
		{
		  char *err = strerror (errno);
		  char *msg = alloca (strlen (err) + 128);
		  sprintf (msg, "writing register %d: %s",
			   regno, err);
		  error (msg);
		  return;
		}
@


1.131
log
@	* linux-low.h (struct lwp_info): New fields
	`stopped_by_watchpoint' and `stopped_data_address'.
	* linux-low.c (linux_wait_for_lwp): Check for watchpoint triggers
	here, and cache them in the lwp object.
	(wait_for_sigstop): Check stopped_by_watchpoint lwp field
	directly.
	(linux_resume_one_lwp): Clear the lwp's stopped_by_watchpoint
	field.
	(linux_stopped_by_watchpoint): Rewrite.
	(linux_stopped_data_address): Rewrite.
@
text
@d2559 2
a2560 3
/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.
   On failure (cannot write the inferior)
d2592 1
d2597 2
d2602 1
d2610 2
d2614 1
a2614 1
  /* Copy data to be written over corresponding part of buffer */
@


1.130
log
@2010-03-06  Simo Melenius  <simo.melenius@@iki.fi>

	* linux-low.c (linux_wait_for_lwp): Fetch the regcache after
	switching the current inferior, not before.
@
text
@d1065 45
d1772 1
a1772 1
	  && !linux_stopped_by_watchpoint ())
d1926 1
d2866 3
a2868 4
  if (the_low_target.stopped_by_watchpoint != NULL)
    return the_low_target.stopped_by_watchpoint ();
  else
    return 0;
d2874 3
a2876 4
  if (the_low_target.stopped_data_address != NULL)
    return the_low_target.stopped_data_address ();
  else
    return 0;
@


1.129
log
@	* linux-low.c (linux_supports_tracefork_flag): Document.
	(linux_look_up_symbols): Add comment.
@
text
@d1070 1
a1070 1
      struct regcache *regcache = get_thread_regcache (current_inferior, 1);
d1075 1
@


1.129.2.1
log
@2010-03-06  Simo Melenius  <simo.melenius@@iki.fi>

	* linux-low.c (linux_wait_for_lwp): Fetch the regcache after
	switching the current inferior, not before.
@
text
@d1070 1
a1070 1
      struct regcache *regcache;
a1074 1
      regcache = get_thread_regcache (current_inferior, 1);
@


1.128
log
@gdb/
	PR libc/11214:
	* linux-low.c (linux_tracefork_child) [!(__UCLIBC__ && HAS_NOMMU)]: New.
	(linux_test_for_tracefork): Move `stack' into [__UCLIBC__ && HAS_NOMMU].
	(linux_test_for_tracefork) [!(__UCLIBC__ && HAS_NOMMU)]: New.

gdb/testsuite/
	PR libc/11214:
	* gdb.threads/current-lwp-dead.c: Include features.h.
	(HAS_NOMMU): New.
	(fn, main): Move CLONE_VM into [__UCLIBC__ && HAS_NOMMU].
@
text
@d2583 1
d2739 3
@


1.127
log
@	* infrun.c (prepare_to_proceed): Handle other signals which might
	match a breakpoint.
	(handle_inferior_event): Move the check for unusual breakpoint
	signals earlier.

	gdbserver/
	* linux-low.c (get_stop_pc): Check for SIGTRAP.
	(linux_wait_for_event_1): Handle SIGILL and SIGSEGV as possible
	breakpoints.
@
text
@d2600 8
d2615 3
d2630 1
d2632 1
d2636 8
d2648 1
a2648 1
#else
d2651 4
a2654 1
#endif
d2723 1
d2725 1
@


1.126
log
@	* linux-low.c (PTRACE_ARG3_TYPE): Change from long to void*.
	(PTRACE_ARG4_TYPE): New macro.
	(handle_extended_wait): Cast ptrace arg4 to PTRACE_ARG4_TYPE.
	(linux_wait_for_event_1, linux_resume_one_lwp): Ditto.
	(fetch_register): Cast to uintptr_t before casting to PTRACE_ARG3_TYPE.
	(usr_store_inferior_registers): Ditto.
	(linux_read_memory, linux_write_memory): Ditto.
	(linux_test_for_tracefork): Ditto.
@
text
@d458 2
a459 1
  if (! get_thread_lwp (current_inferior)->stepping)
d1248 6
a1253 3
      /* If this event was not handled above, and is not a SIGTRAP, report
	 it.  */
      if (!WIFSTOPPED (*wstat) || WSTOPSIG (*wstat) != SIGTRAP)
d1257 1
a1257 1
	 SIGTRAP; it's of no concern to us.  */
d1263 7
@


1.125
log
@	* regcache.h (struct thread_info): Forward declare.
	(struct regcache): New.
	(new_register_cache): Adjust prototype.
	(get_thread_regcache): Declare.
	(free_register_cache): Adjust prototype.
	(registers_to_string, registers_from_string): Ditto.
	(supply_register, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Ditto.
	* regcache.c (struct inferior_regcache_data): Delete.
	(get_regcache): Rename to ...
	(get_thread_regcache): ... this.  Adjust.  Switch inferior before
	fetching registers.
	(regcache_invalidate_one): Adjust.
	(regcache_invalidate): Fix prototype.
	(new_register_cache): Return the new register cache.
	(free_register_cache): Change prototype.
	(realloc_register_cache): Adjust.
	(registers_to_string): Change prototype to take a regcache.  Adjust.
	(registers_from_string): Ditto.
	(register_data): Ditto.
	(supply_register): Ditto.
	(supply_register_by_name): Ditto.
	(collect_register): Ditto.
	(collect_register_as_string): Ditto.
	(collect_register_by_name): Ditto.
	* server.c (process_serial_event): Adjust.
	* linux-low.h (regset_fill_func, regset_store_func): Change
	prototype.
	(get_pc, set_pc, collect_ptrace_register, supply_ptrace_register):
	Change prototype.
	* linux-low.c (get_stop_pc): Adjust.
	(check_removed_breakpoint): Adjust.
	(linux_wait_for_event): Adjust.
	(linux_resume_one_lwp): Adjust.
	(fetch_register): Add regcache parameter.  Adjust.
	(usr_store_inferior_registers): Ditto.
	(regsets_fetch_inferior_registers): Ditto.
	(regsets_store_inferior_registers): Ditto.
	(linux_fetch_registers, linux_store_registers): Ditto.
	* i387-fp.c (i387_cache_to_fsave): Change prototype to take a
	regcache.  Adjust.
	(i387_fsave_to_cache, i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* i387-fp.h (i387_cache_to_fsave, i387_fsave_to_cache): Change
	prototype to take a regcache.
	(i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* remote-utils.c (convert_ascii_to_int, outreg)
	(prepare_resume_reply): Change prototype to take a regcache.
	Adjust.
	* target.h (struct target_ops) <fetch_registers, store_registers>:
	Change prototype to take a regcache.
	(fetch_inferior_registers, store_inferior_registers): Change
	prototype to take a regcache.  Adjust.
	* proc-service.c (ps_lgetregs): Adjust.
	* linux-x86-low.c (x86_fill_gregset, x86_store_gregset)
	(x86_fill_fpregset, x86_store_fpregset, x86_fill_fpxregset)
	(x86_store_fpxregset, x86_get_pc, x86_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-arm-low.c (arm_fill_gregset, arm_store_gregset)
	(arm_fill_wmmxregset, arm_store_wmmxregset, arm_fill_vfpregset)
	(arm_store_vfpregset, arm_get_pc, arm_set_pc):
	(arm_breakpoint_at): Change prototype to take a regcache.  Adjust.
	* linux-cris-low.c (cris_get_pc, cris_set_pc)
	(cris_cannot_fetch_register):
	(cris_breakpoint_at): Change prototype to take a regcache.
	Adjust.
	* linux-crisv32-low.c (cris_get_pc, cris_set_pc,
	cris_reinsert_addr, cris_write_data_breakpoint): Change prototype
	to take a regcache.  Adjust.
	(cris_breakpoint_at, cris_insert_point, cris_remove_point):
	Adjust.
	* linux-m32r-low.c (m32r_get_pc, m32r_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-m68k-low.c (m68k_fill_gregset, m68k_store_gregset)
	(m68k_fill_fpregset, m68k_store_fpregset, m68k_get_pc,
	(m68k_set_pc): Change prototype to take a regcache.  Adjust.
	* linux-mips-low.c (mips_get_pc):
	(mips_set_pc): Change prototype to take a regcache.  Adjust.
	(mips_reinsert_addr): Adjust.
	(mips_collect_register): Change prototype to take a regcache.
	Adjust.
	(mips_supply_register):
	(mips_collect_register_32bit, mips_supply_register_32bit)
	(mips_fill_gregset, mips_store_gregset, mips_fill_fpregset)
	(mips_store_fpregset): Ditto.
	* linux-ppc-low.c (ppc_supply_ptrace_register, ppc_supply_ptrace_register):
	Ditto.
	(parse_spufs_run): Adjust.
	(ppc_get_pc, ppc_set_pc, ppc_fill_gregset, ppc_fill_vsxregset)
	(ppc_store_vsxregset, ppc_fill_vrregset, ppc_store_vrregset)
	(ppc_fill_evrregset, ppc_store_evrregset): Change prototype to
	take a regcache.  Adjust.
	* linux-s390-low.c (s390_collect_ptrace_register)
	(s390_supply_ptrace_register, s390_fill_gregset, s390_get_pc)
	(s390_set_pc): Change prototype to take a regcache.  Adjust.
	(s390_arch_setup): Adjust.
	* linux-sh-low.c (sh_get_pc, sh_breakpoint_at)
	(sh_fill_gregset): Change prototype to take a regcache.  Adjust.
	* linux-sparc-low.c (sparc_fill_gregset_to_stack)
	(sparc_fill_gregset, sparc_store_gregset_from_stack)
	(sparc_store_gregset, sparc_get_pc): Change prototype to take a
	regcache.  Adjust.
	(sparc_breakpoint_at): Adjust.
	* linux-xtensa-low.c (xtensa_fill_gregset):
	(xtensa_store_gregset):
	(xtensa_fill_xtregset, xtensa_store_xtregset, xtensa_get_pc)
	(xtensa_set_pc): Change prototype to take a regcache.  Adjust.
	* nto-low.c (nto_fetch_registers, nto_store_registers): Change
	prototype to take a regcache.  Adjust.
	* win32-arm-low.c (arm_fetch_inferior_register)
	(arm_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-i386-low.c (i386_fetch_inferior_register)
	(i386_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-low.c (child_fetch_inferior_registers)
	(child_store_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_wait): Adjust.
	(win32_fetch_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_store_inferior_registers): Adjust.
	* win32-low.h (struct win32_target_ops) <fetch_inferior_register,
	store_inferior_register>: Change prototype to take a regcache.
@
text
@d156 2
a157 1
#define PTRACE_ARG3_TYPE long
d389 1
a389 1
      ptrace (PTRACE_SETOPTIONS, new_pid, 0, PTRACE_O_TRACECLONE);
d1188 1
a1188 1
		  0, PTRACE_O_TRACECLONE);
d1870 4
a1873 1
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, lwpid_of (lwp), 0, signal);
d2156 4
a2159 1
	ptrace (PTRACE_PEEKUSER, pid, (PTRACE_ARG3_TYPE) regaddr, 0);
d2229 5
a2233 2
	  ptrace (PTRACE_POKEUSER, pid, (PTRACE_ARG3_TYPE) regaddr,
		  *(PTRACE_XFER_TYPE *) (buf + i));
d2485 4
a2488 1
      buffer[i] = ptrace (PTRACE_PEEKTEXT, pid, (PTRACE_ARG3_TYPE) addr, 0);
d2535 4
a2538 1
  buffer[0] = ptrace (PTRACE_PEEKTEXT, pid, (PTRACE_ARG3_TYPE) addr, 0);
d2544 4
a2547 2
		  (PTRACE_ARG3_TYPE) (addr + (count - 1)
				      * sizeof (PTRACE_XFER_TYPE)),
d2560 5
a2564 1
      ptrace (PTRACE_POKETEXT, pid, (PTRACE_ARG3_TYPE) addr, buffer[i]);
d2631 2
a2632 1
  ret = ptrace (PTRACE_SETOPTIONS, child_pid, 0, PTRACE_O_TRACEFORK);
@


1.124
log
@* linux-low.c (W_STOPCODE): Provide definition if missing.
@
text
@d454 2
a455 1
  CORE_ADDR stop_pc = (*the_low_target.get_pc) ();
d888 1
d899 1
a899 1

d935 1
a935 1
      (*the_low_target.set_pc) (stop_pc);
d1068 1
d1073 1
a1073 1
      pc = (*the_low_target.get_pc) ();
d1838 2
a1839 1
      CORE_ADDR pc = (*the_low_target.get_pc) ();
d2128 1
a2128 1
fetch_register (int regno)
d2167 1
a2167 1
    the_low_target.supply_ptrace_register (regno, buf);
d2169 1
a2169 1
    supply_register (regno, buf);
d2176 1
a2176 1
usr_fetch_inferior_registers (int regno)
d2180 1
a2180 1
      fetch_register (regno);
d2182 1
a2182 1
    fetch_register (regno);
d2189 1
a2189 1
usr_store_inferior_registers (int regno)
d2214 1
a2214 1
	the_low_target.collect_ptrace_register (regno, buf);
d2216 1
a2216 1
	collect_register (regno, buf);
d2248 1
a2248 1
      usr_store_inferior_registers (regno);
d2257 1
a2257 1
regsets_fetch_inferior_registers ()
d2303 1
a2303 1
      regset->store_function (buf);
d2314 1
a2314 1
regsets_store_inferior_registers ()
d2348 1
a2348 1
	  regset->fill_function (buf);
d2398 1
a2398 1
linux_fetch_registers (int regno)
d2401 1
a2401 1
  if (regsets_fetch_inferior_registers () == 0)
d2405 1
a2405 1
  usr_fetch_inferior_registers (regno);
d2410 1
a2410 1
linux_store_registers (int regno)
d2413 1
a2413 1
  if (regsets_store_inferior_registers () == 0)
d2417 1
a2417 1
  usr_store_inferior_registers (regno);
@


1.123
log
@	* linux-low.c (linux_create_inferior): Wrap use of __SIGRTMIN in
	#ifdef.
	(linux_wait_for_event1, linux_init_signals): Ditto.
@
text
@d96 4
@


1.122
log
@	Implement core awareness.

	* bcache.c (compare_ints): Remove
	(print_percentage): Use compare_positive_ints.
	* defs.h (compare_positive_ints): Declare.
	* linux-nat.h (struct lin_lwp): New field core.
	(linux_nat_core_of_thread_1): Declare.
	* linux-nat.c (add_lwp): Init the 'core' field.
	(linux_nat_wait_1): Record the core.
	(linux_nat_core_of_thread_1, linux_nat_core_of_thread): New.
	(linux_nat_add_target): Register the above.
	* linux-thread-db.c (update_thread_core): New.
	(thread_db_find_new_threads): Update core information for
	every thread.
	* remote.c (struct private_thread_info): New.
	(free_private_thread_info, demand_private_info): New.
	(PACKET_qXfer_threads, use_osdata_threads): New.
	(struct thread_item, threads_parsing_context
	(start_thread, end_thread, thread_attributes)
	(thread_children, threads_children, threads_elements): New.
	(remote_threads_info): Try qXfer:threads before anything
	else.
	(remote_protocol_packets): Register qXfer:threads.
	(remote_open_1): Init use_osdata_threads.
	(struct stop_reply): New field 'core'.
	(remote_parse_stop_reply): Parse core number.
	(process_stop_reply): Record core number.
	(remote_xfer_partial): Handle qXfer:threads.
	(remote_core_of_thread): New.
	(init_remote_ops): Register remote_core_of_thread.
	(_initialize_remote): Register qXfer:read.
	* target.c (target_core_of_thread): New
	* target.h (enum target_object): New value TARGET_OBJECT_THREADS.
	(struct target_ops): New field to_core_of_threads.
	(target_core_of_thread): Declare.
	* gdbthread.h (struct thread_info): New field private_dtor.
	* thread.c (print_thread_info): Report the core.
	* ui-out.c (MAX_UI_OUT_LEVELS): Increase.
	* utils.c (compare_positive_ints): New.
	* features/threads.dtd: New.
	* mi/mi-interp.c (mi_on_normal_stop): Report the core.
	* mi/mi-main.c (struct collect_cores_data, collect_cores)
	(do_nothing, free_vector_of_osdata_items)
	(splay_tree_int_comparator, free_splay_tree): New.
	(print_one_inferior_data): Implemented printing of selected
	inferiors.  Collect and print cores.
	(output_cores): New.
	(mi_cmd_list_thread_groups): Support --recurse.  Permit specifying
	thread groups together with --available.
@
text
@d501 1
d503 1
d1214 1
a1214 1
#ifdef USE_THREAD_DB
d3415 1
d3417 1
@


1.121
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d143 1
d2806 169
d2984 2
d2989 5
a2993 1
  if (strcmp (annex, "processes") != 0)
d3006 4
a3009 1
      buffer_grow_str (&buffer, "<osdata type=\"processes\">");
d3028 1
a3028 4
		 char pathname[128];
		 FILE *f;
		 char cmd[MAXPATHLEN + 1];
		 struct passwd *entry;
d3030 6
a3035 4
		 sprintf (pathname, "/proc/%s/cmdline", dp->d_name);
		 entry = getpwuid (statbuf.st_uid);

		 if ((f = fopen (pathname, "r")) != NULL)
d3037 1
a3037 21
		     size_t len = fread (cmd, 1, sizeof (cmd) - 1, f);
		     if (len > 0)
		       {
			 int i;
			 for (i = 0; i < len; i++)
			   if (cmd[i] == '\0')
			     cmd[i] = ' ';
			 cmd[len] = '\0';

			 buffer_xml_printf (
			   &buffer,
			   "<item>"
			   "<column name=\"pid\">%s</column>"
			   "<column name=\"user\">%s</column>"
			   "<column name=\"command\">%s</column>"
			   "</item>",
			   dp->d_name,
			   entry ? entry->pw_name : "?",
			   cmd);
		       }
		     fclose (f);
d3313 49
d3401 1
a3401 1
  thread_db_handle_monitor_command
d3403 1
a3403 1
  NULL
d3405 1
@


1.120
log
@	* linux-low.c: Delete inclusion of ansidecl.h, elf/common.h,
	elf/external.h.  Include <elf.h> instead but only if necessary.
@
text
@d3 1
a3 1
   2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.119
log
@	* linux-low.c (linux_remove_process): Remove `detaching'
	parameter.  Don't release/detach from thread_db here.
	(linux_kill): Release/detach from thread_db here, ...
	(linux_detach): ... and here, before actually detaching.
	(linux_wait_1): ... and here, when a process exits.
	* thread-db.c (any_thread_of): New.
	(thread_db_free): Switch the current inferior to a thread of the
	passed in process.
@
text
@a21 3
#include "ansidecl.h" /* For ATTRIBUTE_PACKED, must be bug in external.h.  */
#include "elf/common.h"
#include "elf/external.h"
d42 7
d198 1
a198 1
elf_64_header_p (const Elf64_External_Ehdr *header)
d214 1
a214 1
  Elf64_External_Ehdr header;
@


1.118
log
@	gdb/
	* linux-nat.c (kill_lwp): Minor cleanup, move definition of
	tkill_failed into ifdef HAVE_TKILL_SYSCALL.  Move setting of errno
	there too.  Delete unnecessary resetting of errno after syscall.
	Minor comment changes to match gdbserver/linux-low.c:kill_lwp.

	gdbserver/
	* linux-low.c (kill_lwp): Use __NR_tkill instead of SYS_tkill.
	Move definition of tkill_failed to ifdef __NR_tkill to avoid gcc
	warning ifndef __NR_tkill.  Move setting of errno there too.
	Delete unnecessary resetting of errno after syscall.
	Minor comment changes to match gdb/linux-nat.c:kill_lwp.
@
text
@d261 1
a261 1
linux_remove_process (struct process_info *process, int detaching)
a264 4
#ifdef USE_THREAD_DB
  thread_db_free (process, detaching);
#endif

d735 3
d739 1
a739 1
  linux_remove_process (process, 0);
d823 4
d832 1
a832 1
  linux_remove_process (process, 1);
d1457 3
d1461 1
a1461 1
	  linux_remove_process (process, 0);
@


1.117
log
@	* linux-low.c (my_waitpid): Delete unnecessary prototype.
@
text
@d1575 1
a1575 2
/* Send a signal to an LWP.  For LinuxThreads, kill is enough; however, if
   thread groups are in use, we need to use tkill.  */
d1580 2
a1581 1
  static int tkill_failed;
d1583 15
a1597 11
  errno = 0;

#ifdef SYS_tkill
  if (!tkill_failed)
    {
      int ret = syscall (SYS_tkill, lwpid, signo);
      if (errno != ENOSYS)
	return ret;
      errno = 0;
      tkill_failed = 1;
    }
@


1.116
log
@	* linux-low.c (my_waitpid): Move definition away from being in
	between linux_tracefork_child/linux_test_for_tracefork.
@
text
@a136 1
static int my_waitpid (int pid, int *status, int flags);
@


1.115
log
@	* linux-low.c (linux_read_memory): Fix argument to read.
@
text
@d275 75
a2552 75
/* Wrapper function for waitpid which handles EINTR, and emulates
   __WALL for systems where that is not available.  */

static int
my_waitpid (int pid, int *status, int flags)
{
  int ret, out_errno;

  if (debug_threads)
    fprintf (stderr, "my_waitpid (%d, 0x%x)\n", pid, flags);

  if (flags & __WALL)
    {
      sigset_t block_mask, org_mask, wake_mask;
      int wnohang;

      wnohang = (flags & WNOHANG) != 0;
      flags &= ~(__WALL | __WCLONE);
      flags |= WNOHANG;

      /* Block all signals while here.  This avoids knowing about
	 LinuxThread's signals.  */
      sigfillset (&block_mask);
      sigprocmask (SIG_BLOCK, &block_mask, &org_mask);

      /* ... except during the sigsuspend below.  */
      sigemptyset (&wake_mask);

      while (1)
	{
	  /* Since all signals are blocked, there's no need to check
	     for EINTR here.  */
	  ret = waitpid (pid, status, flags);
	  out_errno = errno;

	  if (ret == -1 && out_errno != ECHILD)
	    break;
	  else if (ret > 0)
	    break;

	  if (flags & __WCLONE)
	    {
	      /* We've tried both flavors now.  If WNOHANG is set,
		 there's nothing else to do, just bail out.  */
	      if (wnohang)
		break;

	      if (debug_threads)
		fprintf (stderr, "blocking\n");

	      /* Block waiting for signals.  */
	      sigsuspend (&wake_mask);
	    }

	  flags ^= __WCLONE;
	}

      sigprocmask (SIG_SETMASK, &org_mask, NULL);
    }
  else
    {
      do
	ret = waitpid (pid, status, flags);
      while (ret == -1 && errno == EINTR);
      out_errno = errno;
    }

  if (debug_threads)
    fprintf (stderr, "my_waitpid (%d, 0x%x): status(%x), %d\n",
	     pid, flags, status ? *status : -1, ret);

  errno = out_errno;
  return ret;
}

@


1.114
log
@	* linux-low.c (linux_remove_process): Add `detaching' parameter.
	Pass it to thread_db_free.
	(linux_kill, linux_detach, linux_wait_1): Adjust to pass the
	proper `detaching' argument to linux_remove_process.
	* linux-low.h (thread_db_free): Add `detaching' parameter.
	* thread-db.c (thread_db_init): Pass false as `detaching' argument
	to thread_db_free.
	(thread_db_free): Add `detaching' parameter.  Only
	call td_ta_clear_event if detaching from process.
@
text
@d2360 1
a2360 1
      if (lseek (fd, memaddr, SEEK_SET) == -1 || read (fd, memaddr, len) != len)
@


1.113
log
@doc/
2009-10-08  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* gdb.texinfo (Server): Document libthread-db-search-path.

gdbserver/
2009-10-08  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* acinclude.m4: (SRV_CHECK_THREAD_DB, SRV_CHECK_TLS_GET_ADDR): Remove.
	* configure.ac: Adjust.
	* linux-low.h (struct process_info_private): Move members to struct
	thread_db.
	(thread_db_free, thread_db_handle_monitor_command): New prototype.
	* linux-low.c (linux_remove_process): Adjust.
	(linux_wait_for_event_1, linux_look_up_symbols): Likewise.
	* server.c (handle_query): Move code ...
	(handle_monitor_command): ... here. New function.
	* target.h (struct target_ops): New member.
	* thread-db.c (struct thread_db): New.
	(libthread_db_search_path): New variable.
	(thread_db_create_event, thread_db_enable_reporting)
	(find_one_thread, maybe_attach_thread, find_new_threads_callback)
	(thread_db_find_new_threads, (thread_db_get_tls_address): Adjust.
	(try_thread_db_load_1, dladdr_to_soname): New functions.
	(try_thread_db_load, thread_db_load_search): New functions.
	(thread_db_init): Search for libthread_db.
	(thread_db_free): New function.
	(thread_db_handle_monitor_command): Likewise.
	* config.in: Regenerate.
	* configure: Regenerate.
@
text
@d262 1
a262 1
linux_remove_process (struct process_info *process)
d267 1
a267 1
  thread_db_free (process);
d666 1
a666 1
  linux_remove_process (process);
d755 1
a755 1
  linux_remove_process (process);
d1381 1
a1381 1
	  linux_remove_process (process);
@


1.112
log
@ChangeLog:

	* linux-nat.c: Include <sys/vfs.h>.
	(SPUFS_MAGIC): Define.
	(spu_enumerate_spu_ids): New function.
	(linux_proc_xfer_spu): New function.
	(linux_xfer_partial): Handle TARGET_OBJECT_SPU.

	(iterate_over_spus): New function.
	(struct linux_spu_corefile_data): New data type.
	(linux_spu_corefile_callback): New function.
	(linux_spu_make_corefile_notes): New function.
	(linux_nat_make_corefile_notes): Call it.

	* corelow.c (struct spuid_list): New data type.
	(add_to_spuid_list): New function.
	(core_xfer_partial): Handle TARGET_OBJECT_SPU.

gdbserver/ChangeLog:

	* linux-low.c: Include <sys/stat.h> and <sys/vfs.h>.
	(SPUFS_MAGIC): Define.
	(spu_enumerate_spu_ids): New function.
	(linux_qxfer_spu): New function.
	(linux_target_ops): Install linux_qxfer_spu.
@
text
@d264 8
a271 2
  free (process->private->arch_private);
  free (process->private);
d1131 1
a1131 1
	      (current_process ()->private->thread_db_active
d2651 1
a2651 1
  if (proc->private->thread_db_active)
d2654 1
a2654 2
  proc->private->thread_db_active
    = thread_db_init (!linux_supports_tracefork_flag);
d3179 6
a3184 1
  linux_supports_multi_process
@


1.111
log
@	* NEWS: Mention ARM VFP support.
	* target-descriptions.c (tdesc_register_type): Make public.
	(tdesc_unnumbered_register): New function.
	(tdesc_register_reggroup_p): Allow missing
	pseudo_register_reggroup_p.
	* target-descriptions.h (tdesc_register_type): Declare.
	(tdesc_unnumbered_register): Declare.
	* arm-tdep.c (arm_neon_quad_read, arm_neon_quad_write): New functions.
	(arm_push_dummy_call): Use arm_neon_quad_write.
	(arm_neon_double_type, arm_neon_quad_type): New functions.
	(arm_register_type): Handle VFP and NEON registers.  Override the
	types of double-precision registers for NEON.  Disable FPA registers
	if they are not present.
	(arm_dwarf_reg_to_regnum): Add current VFP and NEON register numbers.
	(arm_return_value): Use arm_neon_quad_write and arm_neon_quad_read.
	(arm_register_name): Handle VFP single and NEON quad registers.
	(arm_pseudo_read, arm_pseudo_write): New functions.
	(arm_gdbarch_init): Check for VFP and NEON in the target description.
	Assign numbers to double-precision registers.  Register VFP and NEON
	pseudo registers.  Remove a shadowed "i" variable.
	* arm-tdep.h (enum gdb_regnum): Add ARM_D0_REGNUM and
	ARM_D31_REGNUM.
	(struct gdbarch_tdep): Add have_neon_pseudos, have_neon,
	have_vfp_registers, have_vfp_pseudos, neon_double_type,
	and neon_quad_type.

	* features/Makefile: Make expedite settings only architecture
	specific.
	(WHICH): Add new ARM descriptions.
	* features/arm-with-neon.xml, features/arm-with-vfpv2.c,
	features/arm-with-vfpv3.c, features/arm-vfpv2.xml,
	features/arm-vfpv3.xml, features/arm-with-vfpv2.xml,
	features/arm-with-vfpv3.xml, features/arm-with-neon.c: New files.
	* regformats/arm-with-neon.dat, regformats/arm-with-vfpv2.dat,
	regformats/arm-with-vfpv3.dat: Generate.

	doc/
	* gdb.texinfo (ARM Features): Document org.gnu.gdb.arm.vfp and
	org.gnu.gdb.arm.neon.

	gdbserver/
	* linux-low.c (linux_write_memory): Update debugging output.
	* Makefile.in (clean): Add new descriptions.
	(arm-with-vfpv2.o, arm-with-vfpv2.c, arm-with-vfpv3.o)
	(arm-with-vfpv3.c, arm-with-neon.o, arm-with-neon.c): New rules.
	* configure.srv: Add new files for arm*-*-linux*.
	* linux-arm-low.c: Add new declarations.
	(PTRACE_GETVFPREGS, PTRACE_SETVFPREGS): Define if undefined.
	(arm_hwcap, HWCAP_VFP, HWCAP_IWMMXT, HWCAP_NEON, HWCAP_VFPv3)
	(HWCAP_VFPv3D16): New.
	(arm_fill_wmmxregset, arm_store_wmmxregset): Check HWCAP_IWMMXT
	instead of __IWMMXT__.
	(arm_fill_vfpregset, arm_store_vfpregset, arm_get_hwcap)
	(arm_arch_setup): New.
	(target_regsets): Remove #ifdef.  Add VFP regset.
	(the_low_target): Use arm_arch_setup.

	testsuite/
	* gdb.base/float.exp: Handle VFP registers.
@
text
@d43 6
d3043 94
d3167 1
a3167 1
  NULL,
@


1.110
log
@	* linux-low.c (linux_kill_one_lwp): Adjust kernel workaround to skip
	the main thread again.
@
text
@d2397 10
a2406 1
      fprintf (stderr, "Writing %02x to %08lx\n", (unsigned)myaddr[0], (long)memaddr);
@


1.109
log
@	Add h/w watchpoint support to x86-linux, win32-i386.
	* Makefile.in (SFILES): Add i386-low.c
	(i386_low_h): Define.
	(i386-low.o): Add dependencies.
	(linux-x86-low.o): Add i386-low.h dependency.
	(win32-i386-low.o): Ditto.
	* i386-low.c: New file.
	* i386-low.h: New file.
	* configure.srv (i[34567]86-*-cygwin*): Add i386-low.o to srv_tgtobj.
	(i[34567]86-*-linux*, i[34567]86-*-mingw*, x86_64-*-linux*): Ditto.
	* linux-low.c (linux_add_process): Initialize arch_private.
	(linux_remove_process): Free arch_private.
	(add_lwp): Initialize arch_private.
	(delete_lwp): Free arch_private.
	(linux_resume_one_lwp): Call the_low_target.prepare_to_resume if
	provided.
	* linux-low.h (process_info_private): New member arch_private.
	(lwp_info): New member arch_private.
	(linux_target_ops): New members new_process, new_thread,
	prepare_to_resume.
	(ptid_of): New macro.
	* linux-x86-low.c: Include stddef.h, i386-low.h.
	(arch_process_info): New struct.
	(arch_lwp_info): New struct.
	(x86_linux_dr_get, x86_linux_dr_set): New functions.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(x86_insert_point, x86_remove_point): New functions.
	(x86_stopped_by_watchpoint): New function.
	(x86_stopped_data_address): New function.
	(x86_linux_new_process, x86_linux_new_thread): New functions.
	(x86_linux_prepare_to_resume): New function.
	(the_low_target): Add entries for insert_point, remove_point,
	stopped_by_watchpoint, stopped_data_address, new_process, new_thread,
	prepare_to_resume.
	* server.c (debug_hw_points): New global.
	(monitor_show_help): Document set debug-hw-points.
	(handle_query): Process "set debug-hw-points".
	* server.h (debug_hw_points): Declare.
	(paddress): Declare.
	* utils.c (NUMCELLS, CELLSIZE): New macros.
	(get_sell, xsnprintf, paddress): New functions.
	* win32-arm-low.c (the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-i386-low.c: Include i386-low.h.
	(debug_reg_state): Replaces dr.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(i386_insert_point, i386_remove_point): New functions.
	(i386_stopped_by_watchpoint): New function.
	(i386_stopped_data_address): New function.
	(i386_initial_stuff): Update.
	(get_thread_context,set_thread_context,i386_thread_added): Update.
	(the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-low.c (win32_insert_watchpoint): New function.
	(win32_remove_watchpoint): New function.
	(win32_stopped_by_watchpoint): New function.
	(win32_stopped_data_address): New function.
	(win32_target_ops): Add entries for insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address.
	* win32-low.h (win32_target_ops): New members insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
@
text
@d592 1
a592 1
  if (last_thread_of_process_p (thread))
@


1.108
log
@	* server.c (process_serial_event): Re-return unsupported, not
	error, if the type isn't recognized.  Re-allow supporting only
	insert or remove packets.  Also call require_running for
	breakpoints.  Add missing break statement to default case.  Tidy.
	* target.h (struct target_ops): Rename insert_watchpoint to
	insert_point, and remove_watchpoint to remove_point.

	* linux-low.h (struct linux_target_ops): Likewise.
	* linux-low.c (linux_insert_watchpoint): Rename to ...
	(linux_insert_point): ... this.  Adjust.
	(linux_remove_watchpoint): Rename to ...
	(linux_remove_point): ... this.  Adjust.
	(linux_target_ops): Adjust.
	* linux-crisv32-low.c (cris_insert_watchpoint): Rename to ...
	(cris_insert_point): ... this.
	(cris_remove_watchpoint): Rename to ...
	(cris_remove_point): ... this.
	(the_low_target): Adjust.
@
text
@d227 1
d246 3
d258 1
d384 3
a476 1

d1750 3
@


1.107
log
@	* linux-low.c (usr_fetch_inferior_registers): Remove check for regno 0.
	* proc-service.c (ps_lgetregs): Pass -1 to fetch all registers.
	* regcache.c (get_regcache): Likewise.
	* spu-low.c (spu_fetch_registers): Remove 0 to -1 conversion.
	* win32-low.c (child_fetch_inferior_registers): Remove check for
	regno 0.
@
text
@d2674 3
a2676 2
/* These watchpoint related wrapper functions simply pass on the function call
   if the target has registered a corresponding function.  */
d2679 1
a2679 1
linux_insert_watchpoint (char type, CORE_ADDR addr, int len)
d2681 2
a2682 2
  if (the_low_target.insert_watchpoint != NULL)
    return the_low_target.insert_watchpoint (type, addr, len);
d2689 1
a2689 1
linux_remove_watchpoint (char type, CORE_ADDR addr, int len)
d2691 2
a2692 2
  if (the_low_target.remove_watchpoint != NULL)
    return the_low_target.remove_watchpoint (type, addr, len);
d3034 2
a3035 2
  linux_insert_watchpoint,
  linux_remove_watchpoint,
@


1.106
log
@2009-06-19  Aleksandar Ristovski  <aristovski@@qnx.com>
	    Pedro Alves <pedro@@codesourcery.com>

	* target.h (struct target_ops) <supports_multi_process>: New
	callback.
	(target_supports_multi_process): New.
	* server.c (handle_query): Even if GDB reports support, only
	enable multi-process if the target also supports it.  Report
	multi-process support only if the target backend supports it.
	* linux-low.c (linux_supports_multi_process): New function.
	(linux_target_ops): Install it as target_supports_multi_process
	callback.
@
text
@d2057 1
a2057 1
  if (regno == -1 || regno == 0)
@


1.105
log
@	* linux-low.c (handle_extended_wait): Use linux_resume_one_lwp
	to resume the newly created thread, don't call ptrace (PTRACE_CONT)
	directly.
@
text
@d3011 6
d3054 1
@


1.104
log
@	* linux-low.c (get_stop_pc): Print pc if debug_threads.
	(check_removed_breakpoint, linux_wait_for_lwp): Ditto.
	(linux_resume_one_lwp): Ditto.
@
text
@d298 6
d309 2
a310 4
	  if (stopping_threads)
	    new_lwp->stopped = 1;
	  else
	    ptrace (PTRACE_CONT, new_pid, 0, 0);
a316 1
	      new_lwp->stopped = 1;
d323 1
a323 1
	    ptrace (PTRACE_CONT, new_pid, 0, WSTOPSIG (status));
@


1.103
log
@	* linux-low.c (linux_resume_one_lwp): Change type of first arg
	from struct inferior_list_entry * to struct lwp_info *.
	All callers updated.
@
text
@d357 7
a363 4
  if (get_thread_lwp (current_inferior)->stepping)
    return stop_pc;
  else
    return stop_pc - the_low_target.decr_pc_after_break;
d820 5
a824 1
    (*the_low_target.set_pc) (stop_pc);
d952 2
a953 1
      && WIFSTOPPED (*wstatp))
d956 2
d960 2
a961 3
      /* For testing only; i386_stop_pc prints out a diagnostic.  */
      if (the_low_target.get_pc != NULL)
	get_stop_pc ();
d1718 2
a1719 2
      fprintf (stderr, "  ");
      (*the_low_target.get_pc) ();
@


1.102
log
@(linux_test_for_tracefork): Back out turd from previous check-in.
@
text
@d124 1
a124 1
static void linux_resume_one_lwp (struct inferior_list_entry *entry,
d326 1
a326 2
      linux_resume_one_lwp (&event_child->head,
			    event_child->stepping, 0, NULL);
d690 1
a690 1
	linux_resume_one_lwp (&lwp->head, 0, 0, NULL);
d851 1
a851 1
	linux_resume_one_lwp (&lwp->head, 0, 0, NULL);
d1076 1
a1076 2
	  linux_resume_one_lwp (&event_child->head,
				event_child->stepping, 0, NULL);
d1118 1
a1118 1
	  linux_resume_one_lwp (&event_child->head,
d1148 1
a1148 1
	  linux_resume_one_lwp (&event_child->head, 0, 0, NULL);
d1190 1
a1190 1
	    linux_resume_one_lwp (&event_child->head, 0, 0, NULL);
d1195 1
a1195 1
	      linux_resume_one_lwp (&event_child->head, 1, 0, NULL);
d1201 1
a1201 1
	      linux_resume_one_lwp (&event_child->head, 0, 0, NULL);
d1646 1
a1646 1
linux_resume_one_lwp (struct inferior_list_entry *entry,
a1648 1
  struct lwp_info *lwp = (struct lwp_info *) entry;
d1918 1
a1918 1
      linux_resume_one_lwp (&lwp->head, step, lwp->resume->sig, NULL);
@


1.101
log
@	Biarch support for i386/amd64 gdbserver.
	* Makefile.in (SFILES): Remove linux-i386-low.c, linux-x86-64-low.c.
	Add linux-x86-low.c.
	(linux-i386-low.o, linux-x86-64-low.o): Delete.
	(linux-x86-low.o): Add.
	* linux-x86-64-low.c: Delete.
	* linux-i386-low.c: Delete.
	* linux-x86-low.c: New file.
	* configure.srv (i?86-linux srv_tgtobj): Replace linux-i386-low.o with
	linux-x86-low.o.
	(x86_64-linux srv_tgtobj): Replace linux-x86-64-low.o with
	linux-x86-low.o.
	(x86_64-linux srv_regobj): Add reg-i386-linux.o.
	* linux-low.c: Include ansidecl.h, elf/common.h, elf/external.h.
	(linux_child_pid_to_exec_file): New function.
	(elf_64_header_p, elf_64_file_p): New functions.
	(siginfo_fixup): New function.
	(linux_xfer_siginfo): New local inf_siginfo.  Call siginfo_fixup to
	give target a chance to convert layout.
	* linux-low.h (linux_target_ops): New member siginfo_fixup.
	(linux_child_pid_to_exec_file, elf_64_file_p): Declare.
@
text
@a2525 2
  return;

@


1.100
log
@	* linux-low.c (regsets_fetch_inferior_registers): Fix memory leak.
	(regsets_store_inferior_registers): Ditto.
@
text
@d22 3
d160 62
d2526 2
d2856 22
d2882 1
d2884 1
a2884 1
  long pid = -1;
d2892 1
a2892 1
    fprintf (stderr, "%s siginfo for lwp %ld.\n",
d2902 6
d2912 1
a2912 1
    memcpy (readbuf, (char *) &siginfo + offset, len);
d2915 5
a2919 1
      memcpy ((char *) &siginfo + offset, writebuf, len);
@


1.99
log
@	PR server/10048

	* linux-low.c (must_set_ptrace_flags): Delete.
	(linux_create_inferior): Set `lwp->must_set_ptrace_flags' instead
	of the global.
	(linux_attach_lwp_1): Don't set PTRACE_SETOPTIONS here.  Set
	`lwp->must_set_ptrace_flags' instead.
	(linux_wait_for_event_1): If ptrace options here.
	(linux_wait_1): ... not here.
@
text
@d2095 1
d2110 1
d2170 1
d2179 1
@


1.98
log
@	* inferiors.c (remove_process): Fix memory leak, free process.
	* linux-low.c (linux_remove_process): New function.
	(linux_kill): Call it instead of remove_process.
	(linux_detach, linux_wait_1): Ditto.
@
text
@a111 2
static int must_set_ptrace_flags;

d320 1
a320 1
  void *new_lwp;
d355 1
a355 1
  must_set_ptrace_flags = 1;
a383 4
  /* FIXME: This intermittently fails.
     We need to wait for SIGSTOP first.  */
  ptrace (PTRACE_SETOPTIONS, lwpid, 0, PTRACE_O_TRACECLONE);

d399 5
d998 7
a1266 5
  if (must_set_ptrace_flags)
    {
      ptrace (PTRACE_SETOPTIONS, lwpid_of (lwp), 0, PTRACE_O_TRACECLONE);
      must_set_ptrace_flags = 0;
    }
@


1.97
log
@	* linux-low.c (usr_store_inferior_registers): Declare local `pid'
	variable.
@
text
@d185 10
d578 1
a578 1
  remove_process (process);
d667 1
a667 1
  remove_process (process);
d1286 1
a1286 1
	  remove_process (process);
@


1.96
log
@2009-04-01  Pedro Alves  <pedro@@codesourcery.com>

	Implement the multiprocess extensions, and add linux multiprocess
	support.

	* server.h (ULONGEST): Declare.
	(struct ptid, ptid_t): New.
	(minus_one_ptid, null_ptid): Declare.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): Declare.
	(struct inferior_list_entry): Change `id' type from unsigned from
	to ptid_t.
	(struct sym_cache, struct breakpoint, struct
	process_info_private): Forward declare.
	(struct process_info): Declare.
	(current_process): Declare.
	(all_processes): Declare.
	(initialize_inferiors): Declare.
	(add_thread): Adjust to use ptid_t.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): Ditto.
	(add_process, remove_process, find_thread_pid): Declare.
	(find_inferior_id): Adjust to use ptid_t.
	(cont_thread, general_thread, step_thread): Change type to ptid_t.
	(multi_process): Declare.
	(push_event): Adjust to use ptid_t.
	(read_ptid, write_ptid): Declare.
	(prepare_resume_reply): Adjust to use ptid_t.
	(clear_symbol_cache): Declare.
	* inferiors.c (all_processes): New.
	(null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): New.
	(add_thread): Change unsigned long to ptid.  Remove gdb_id
	parameter.  Adjust.
	(thread_id_to_gdb_id, thread_to_gdb_id): Change unsigned long to ptid.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Change unsigned long to ptid.
	(gdb_id_to_thread_id, find_inferior_id): Change unsigned long to ptid.
	(loaded_dll, pull_pid_from_list): Adjust.
	(add_process, remove_process, find_process_pid)
	(get_thread_process, current_process, initialize_inferiors): New.
	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_waitstatus) <related_pid>: Ditto.
	(struct target_ops) <kill, detach>: Add `pid' argument.  Change
	return type to int.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <thread_alive>: Change pid's type to ptid_t.
	(struct target_ops) <wait>: Add `ptid' field.  Change return type
	to ptid.
	(kill_inferior, detach_inferior, join_inferior): Add `pid' argument.
	(mywait): Add `ptid' argument.  Change return type to ptid_t.
	(target_pid_to_str): Declare.
	* target.c (set_desired_inferior): Adjust to use ptids.
	(mywait): Add new `ptid' argument.  Adjust.
	(target_pid_to_str): New.
	* mem-break.h (free_all_breakpoints): Declare.
	* mem-break.c (breakpoints): Delelete.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Adjust
	to use per-process breakpoint list.
	(free_all_breakpoints): New.
	* remote-utils.c (struct sym_cache) <name>: Drop `const'.
	(symbol_cache, all_symbols_looked_up): Delete.
	(hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, hex_or_minus_one,
	read_ptid): New.
	(prepare_resume_reply): Change ptid argument's type from unsigned
	long to ptid_t.  Adjust.  Implement W;process and X;process.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust to per-process symbol cache.  *
	* server.c (cont_thread, general_thread, step_thread): Change type
	to ptid_t.
	(attached): Delete.
	(multi_process): New.
	(last_ptid): Change type to ptid_t.
	(struct vstop_notif) <ptid>: Change type to ptid_t.
	(queue_stop_reply, push_event): Change `ptid' argument's type to
	ptid_t.
	(discard_queued_stop_replies): Add `pid' argument.
	(start_inferior): Adjust to use ptids.  Adjust to mywait interface
	changes.  Don't reference the `attached' global.
	(attach_inferior): Adjust to mywait interface changes.
	(handle_query): Adjust to use ptids.  Parse GDB's qSupported
	features.  Handle and report "multiprocess+".  Handle
	"qAttached:PID".
	(handle_v_cont): Adjust to use ptids.  Adjust to mywait interface
	changes.
	(handle_v_kill): New.
	(handle_v_stopped): Adjust to use target_pid_to_str.
	(handle_v_requests): Allow multiple attaches and runs when
	multiprocess extensions are in effect.  Handle "vKill".
	(myresume): Adjust to use ptids.
	(queue_stop_reply_callback): Add `arg' parameter.  Handle it.
	(handle_status): Adjust to discard_queued_stop_replies interface
	change.
	(first_thread_of, kill_inferior_callback)
	(detach_or_kill_inferior_callback, join_inferiors_callback): New.
	(main): Call initialize_inferiors.  Adjust to use ptids, killing
	and detaching from all inferiors.  Handle multiprocess packet
	variants.
	* linux-low.h: Include gdb_proc_service.h.
	(struct process_info_private): New.
	(struct linux_target_ops) <pid_of>: Use ptid_get_pid.
	<lwpid_of>: Use ptid_get_lwp.
	(get_lwp_thread): Adjust.
	(struct lwp_info): Add `dead' member.
	(find_lwp_pid): Declare.
	* linux-low.c (thread_db_active): Delete.
	(new_inferior): Adjust comment.
	(inferior_pid): Delete.
	(linux_add_process): New.
	(handle_extended_wait): Adjust.
	(add_lwp): Change unsigned long to ptid.
	(linux_create_inferior): Add process to processes table.  Adjust
	to use ptids.  Don't set new_inferior here.
	(linux_attach_lwp): Rename to ...
	(linux_attach_lwp_1): ... this.  Add `initial' argument.  Handle
	it.  Adjust to use ptids.
	(linux_attach_lwp): New.
	(linux_attach): Add process to processes table.  Don't set
	new_inferior here.
	(struct counter): New.
	(second_thread_of_pid_p, last_thread_of_process_p): New.
	(linux_kill_one_lwp): Add `args' parameter.  Handle it.  Adjust to
	multiple processes.
	(linux_kill): Add `pid' argument.  Handle it.  Adjust to multiple
	processes.  Remove process from process table.
	(linux_detach_one_lwp): Add `args' parameter.  Handle it.  Adjust
	to multiple processes.
	(any_thread_of): New.
	(linux_detach): Add `pid' argument, and handle it.  Remove process
	from processes table.
	(linux_join): Add `pid' argument.  Handle it.
	(linux_thread_alive): Change unsighed long argument to ptid_t.
	Consider dead lwps as not being alive.
	(status_pending_p): Rename `dummy' argument to `arg'.  Filter out
	threads we're not interested in.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_lwp): Change `pid' argument's type from int to
	ptid_t.  Adjust.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.  Change `pid' argument's type
	from int to ptid_t.  Adjust.
	(linux_wait_for_event): New.
	(linux_wait_1): Add `ptid' argument.  Change return type to
	ptid_t.  Adjust.  Use last_thread_of_process_p.  Remove processes
	that exit from the process table.
	(linux_wait): Add `ptid' argument.  Change return type to ptid_t.
	Adjust.
	(mark_lwp_dead): New.
	(wait_for_sigstop): Adjust to use ptids.  If a process exits while
	stopping all threads, mark its main lwp as dead.
	(linux_set_resume_request, linux_resume_one_thread): Adjust to use
	ptids.
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory): Inline `inferior_pid'.
	(linux_look_up_symbols): Adjust to use per-process
	`thread_db_active'.
	(linux_request_interrupt): Adjust to use ptids.
	(linux_read_auxv): Inline `inferior_pid'.
	(initialize_low): Don't reference thread_db_active.
	* gdb_proc_service.h (struct ps_prochandle) <pid>: Remove.
	* proc-service.c (ps_lgetregs): Use find_lwp_pid.
	(ps_getpid): Return the pid of the current inferior.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(thread_db_create_event, thread_db_enable_reporting): Adjust to
	per-process data.
	(find_one_thread): Change argument type to ptid_t.  Adjust to
	per-process data.
	(maybe_attach_thread): Adjust to per-process data and ptids.
	(thread_db_find_new_threads): Ditto.
	(thread_db_init): Ditto.
	* spu-low.c (spu_create_inferior, spu_attach): Add process to
	processes table.  Adjust to use ptids.
	(spu_kill, spu_detach): Adjust interface.  Remove process from
	processes table.
	(spu_join, spu_thread_alive): Adjust interface.
	(spu_wait): Adjust interface.  Remove process from processes
	table.  Adjust to use ptids.
	* win32-low.c (current_inferior_tid): Delete.
	(current_inferior_ptid): New.
	(debug_event_ptid): New.
	(thread_rec): Take a ptid.  Adjust.
	(child_add_thread): Add `pid' argument.  Adjust to use ptids.
	(child_delete_thread): Ditto.
	(do_initial_child_stuff): Add `attached' argument.  Add process to
	processes table.
	(child_fetch_inferior_registers, child_store_inferior_registers):
	Adjust.
	(win32_create_inferior): Pass 0 to do_initial_child_stuff.
	(win32_attach): Pass 1 to do_initial_child_stuff.
	(win32_kill): Adjust interface.  Remove process from processes
	table.
	(win32_detach): Ditto.
	(win32_join): Adjust interface.
	(win32_thread_alive): Take a ptid.
	(win32_resume): Adjust to use ptids.
	(get_child_debug_event): Ditto.
	(win32_wait): Adjust interface.  Remove exiting process from
	processes table.
@
text
@d1988 1
@


1.95
log
@	Non-stop mode support.

	* server.h (non_stop): Declare.
	(gdb_client_data, handler_func): Declare.
	(delete_file_handler, add_file_handler, start_event_loop):
	Declare.
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif): Declare.
	* target.h (enum resume_kind): New.
	(struct thread_resume): Replace `step' field by `kind' field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <wait>: Add `options' argument.
	<supports_non_stop, async, start_non_stop>: New fields.
	(target_supports_non_stop, target_async): New.
	(start_non_stop): Declare.
	(mywait): Add `options' argument.
	* target.c (mywait): Add `options' argument.  Print child exit
	notifications here.
	(start_non_stop): New.
	* server.c (non_stop, own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New global.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to use resume_kind.  Adjust to mywait
	interface changes.
	(attach_inferior): In non-stop mode, don't wait for the target
	here.
	(handle_general_set): Handle QNonStop.
	(handle_query): When handling qC, return the current general
	thread, instead of the first thread of the list.
	(handle_query): If the backend supports non-stop mode, include
	QNonStop+ in the qSupported query response.
	(handle_v_cont): Adjust to use resume_kind.  Handle resume_stop
	and non-stop mode.
	(handle_v_attach, handle_v_run): Handle non-stop mode.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for vCont;t.  Handle vStopped.
	(myresume): Adjust to use resume_kind.  Handle non-stop.
	(queue_stop_reply_callback): New.
	(handle_status): Handle non-stop mode.
	(main): Clear non_stop flag on reconnection.  Use the event-loop.
	Refactor serial protocol handling from here ...
	(process_serial_event): ... to this new function.  When GDB
	selects any thread, select one here.  In non-stop mode, wait until
	GDB acks all pending events before exiting.
	(handle_serial_event, handle_target_event): New.
	* remote-utils.c (remote_open): Install remote_desc in the event
	loop.
	(remote_close): Remove remote_desc from the event loop.
	(putpkt_binary): Rename to...
	(putpkt_binary_1): ... this.  Add `is_notic' argument.  Handle it.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(prepare_resume_reply): In non-stop mode, don't change the
	general_thread.
	* event-loop.c: New.
	* Makefile.in (OBJ): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (pid_of): Moved here.
	(lwpid_of): New.
	(get_lwp_thread): Use lwpid_of.
	(struct lwp_info): Delete `lwpid' field.  Add `suspended' field.
	* linux-low.c (pid_of): Delete.
	(inferior_pid): Use lwpid_of.
	(linux_event_pipe): New.
	(target_is_async_p): New.
	(delete_lwp): New.
	(handle_extended_wait): Use lwpid_of.
	(add_lwp): Don't set lwpid field.
	(linux_attach_lwp): Adjust debug output.  Use lwpid_of.
	(linux_kill_one_lwp): If killing a running lwp, stop it first.
	Use lwpid_of.  Adjust to linux_wait_for_event interface changes.
	(linux_detach_one_lwp): If detaching from a running lwp, stop it
	first.  Adjust to linux_wait_for_event interface changes.  Use
	lwpid_of.
	(linux_detach): Don't delete the main lwp here.
	(linux_join): Use my_waitpid.  Avoid signal_pid.  Use lwpid_of.
	(status_pending_p): Don't consider explicitly suspended lwps.
	(linux_wait_for_lwp): Take an integer pid instead of a lwp_info
	pointer.  Add OPTIONS argument.  Change return type to int.  Use
	my_waitpid instead of sleeping.  Handle WNOHANG.  Use lwpid_of.
	(linux_wait_for_event): Take an integer pid instead of a lwp_info
	pointer.  Add status pointer argument.  Return a pid instead of a
	status.  Use lwpid_of.  Adjust to linux_wait_for_lwp interface
	changes.  In non-stop mode, don't switch to a random thread.
	(linux_wait): Rename to...
	(linux_wait_1): ... this.  Add target_options argument, and handle
	it.  Adjust to use resume_kind.  Use lwpid_of.  In non-stop mode,
	don't handle the continue thread.  Handle TARGET_WNOHANG.  Merge
	clean exit and signal exit code.  Don't stop all threads in
	non-stop mode.  In all-stop mode, only stop all threads when
	reporting a stop to GDB.  Handle explicit thread stop requests.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(send_sigstop): Use lwpid_of.
	(wait_for_sigstop): Use lwpid_of.  Adjust to linux_wait_for_event
	interface changes.  In non-stop mode, don't switch to a random
	thread.
	(linux_resume_one_lwp): Use lwpid_of.
	(linux_continue_one_thread, linux_queue_one_thread): Merge into ...
	(linux_resume_one_thread): ... this.  Handle resume_stop.  In
	non-stop mode, don't look for pending flag in all threads.
	(resume_status_pending_p): Don't consider explicitly suspended
	threads.
	(my_waitpid): Reimplement.  Emulate __WALL.
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Use lwpid_of.
	(sigchld_handler, linux_supports_non_stop, linux_async)
	(linux_start_non_stop): New.
	(linux_target_ops): Register linux_supports_non_stop, linux_async
	and linux_start_non_stop.
	(initialize_low): Install SIGCHLD handler.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(thread_db_get_tls_address): Use lwpid_of.
	* win32-low.c (win32_detach): Adjust to use resume_kind.
	(win32_wait): Add `options' argument.
	* spu-low.c (spu_resume): Adjust to use resume_kind.
	(spu_wait): Add `options' argument.
@
text
@d93 4
a96 1
   the same as the LWP ID.  */
a110 1
static int thread_db_active;
d114 7
a120 3
/* This flag is true iff we've just created or attached to a new inferior
   but it has not stopped yet.  As soon as it does, we need to call the
   low target's arch_setup callback.  */
d127 1
a127 1
static int linux_wait_for_event (int pid, int *wstat, int options);
d129 1
a129 1
static void *add_lwp (unsigned long pid);
d132 1
a148 3
/* FIXME: Delete eventually.  */
#define inferior_pid (lwpid_of (get_thread_lwp (current_inferior)))

d167 18
d197 1
d221 3
a223 3
      new_lwp = (struct lwp_info *) add_lwp (new_pid);
      add_thread (new_pid, new_lwp, new_pid);
      new_thread_notify (thread_id_to_gdb_id (lwpid_of (new_lwp)));
d292 1
a292 1
add_lwp (unsigned long pid)
d299 1
a299 1
  lwp->head.id = pid;
d314 1
d342 5
a346 2
  new_lwp = add_lwp (pid);
  add_thread (pid, new_lwp, pid);
a347 1
  new_inferior = 1;
d354 2
a355 2
void
linux_attach_lwp (unsigned long pid)
d357 1
d360 1
a360 1
  if (ptrace (PTRACE_ATTACH, pid, 0, 0) != 0)
d362 1
a362 1
      if (all_threads.head != NULL)
d365 1
a365 1
	  fprintf (stderr, "Cannot attach to lwp %ld: %s (%d)\n", pid,
d372 1
a372 1
	error ("Cannot attach to lwp %ld: %s (%d)\n", pid,
d378 13
a390 1
  ptrace (PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACECLONE);
d392 2
a393 3
  new_lwp = (struct lwp_info *) add_lwp (pid);
  add_thread (pid, new_lwp, pid);
  new_thread_notify (thread_id_to_gdb_id (lwpid_of (new_lwp)));
d430 6
d441 3
a443 1
  linux_attach_lwp (pid);
d449 2
a450 1
      lwp = (struct lwp_info *) find_inferior_id (&all_lwps, pid);
d454 19
a472 1
  new_inferior = 1;
d477 6
a482 1
/* Kill the inferior process.  Make us have no inferior.  */
d484 8
a491 2
static void
linux_kill_one_lwp (struct inferior_list_entry *entry)
a494 1
  int pid;
d496 4
d505 8
a512 2
  if (entry == all_threads.head)
    return;
d524 1
a524 1
      pid = linux_wait_for_event (lwpid_of (lwp), &wstat, __WALL);
d526 2
d530 2
a531 2
static void
linux_kill (void)
d533 1
a533 1
  struct thread_info *thread = (struct thread_info *) all_threads.head;
d535 1
d537 1
a537 1
  int pid;
d539 3
a541 2
  if (thread == NULL)
    return;
d543 1
a543 1
  for_each_inferior (&all_threads, linux_kill_one_lwp);
d547 2
a548 1
  lwp = get_thread_lwp (thread);
d551 2
a552 1
    fprintf (stderr, "lk_1: killing lwp %ld\n", lwpid_of (lwp));
d564 2
a565 2
      pid = linux_wait_for_event (lwpid_of (lwp), &wstat, __WALL);
    } while (pid > 0 && WIFSTOPPED (wstat));
d568 2
a569 1
  clear_inferiors ();
d572 2
a573 2
static void
linux_detach_one_lwp (struct inferior_list_entry *entry)
d577 4
d586 1
a586 1
      int pid = lwpid_of (lwp);
d599 1
a599 1
      lwp = (struct lwp_info *) find_inferior_id (&all_lwps, pid);
d601 1
a601 1
	return;
d618 1
a618 1
      linux_wait_for_event (lwpid_of (lwp), &wstat, __WALL);
d629 1
d633 1
a633 1
linux_detach (void)
d635 20
d656 2
a657 2
  for_each_inferior (&all_threads, linux_detach_one_lwp);
  clear_inferiors ();
d662 1
a662 1
linux_join (void)
d665 1
a665 2
  struct thread_info *thread;
  struct lwp_info *lwp;
d667 3
a669 2
  thread = (struct thread_info *) all_threads.head;
  lwp = get_thread_lwp (thread);
d672 1
a672 1
    ret = my_waitpid (lwpid_of (lwp), &status, 0);
d680 1
a680 1
linux_thread_alive (unsigned long lwpid)
d682 7
a688 2
  if (find_inferior_id (&all_threads, lwpid) != NULL)
    return 1;
d758 1
a758 1
status_pending_p (struct inferior_list_entry *entry, void *dummy)
d761 7
d785 23
d809 1
a809 1
linux_wait_for_lwp (int pid, int *wstatp, int options)
d812 1
a812 1
  int to_wait_for = pid;
d816 6
a821 1
    fprintf (stderr, "linux_wait_for_lwp: %d\n", pid);
d839 1
a839 1
  child = (struct lwp_info *) find_inferior_id (&all_lwps, ret);
d876 1
a876 1
	find_inferior_id (&all_threads, lwpid_of (child));
d893 1
a893 1
linux_wait_for_event (int pid, int *wstat, int options)
d900 1
a900 1
  /* Check for a process with a pending status.  */
d905 2
a906 1
  if (pid == -1)
d909 1
a909 1
	find_inferior (&all_lwps, status_pending_p, NULL);
d915 1
a915 2
      requested_child = (struct lwp_info *)
	find_inferior_id (&all_lwps, pid);
d939 1
a939 1
      event_child = linux_wait_for_lwp (pid, wstat, options);
a951 1
	  int lwpid = lwpid_of (event_child);
d953 1
a953 1
	    fprintf (stderr, "LWP %d exiting\n", lwpid);
d956 1
a956 1
	  if (all_threads.head == all_threads.tail)
d959 2
a960 1
		fprintf (stderr, "LWP %d is last lwp of process\n", lwpid);
a963 1
	  dead_thread_notify (thread_id_to_gdb_id (lwpid_of (event_child)));
d983 1
a983 1
	    return lwpid;
d1021 1
a1021 1
	      (thread_db_active
d1159 40
d1201 3
a1203 2
static unsigned long
linux_wait_1 (struct target_waitstatus *ourstatus, int target_options)
a1208 1
  int wait_pid = -1;
d1225 3
a1227 1
  if (!non_stop && cont_thread != 0 && cont_thread != -1)
d1236 1
a1236 1
	  resume_info.thread = -1;
d1242 1
a1242 1
	wait_pid = cont_thread;
d1245 1
a1245 1
  pid = linux_wait_for_event (wait_pid, &w, options);
d1247 1
a1247 1
    return pid;
d1268 1
a1268 1
  if (all_threads.head == all_threads.tail)
d1272 2
a1273 3
	  int pid;

	  pid = pid_of (lwp);
d1276 1
a1276 1
	  clear_inferiors ();
d1298 1
a1298 1
	  return pid;
d1335 2
a1336 2
    fprintf (stderr, "linux_wait ret = %ld, %d, %d\n",
	     lwpid_of (lwp),
d1340 1
a1340 1
  return lwpid_of (lwp);
d1371 3
a1373 2
static unsigned long
linux_wait (struct target_waitstatus *ourstatus, int target_options)
d1375 1
a1375 1
  unsigned long event_ptid;
d1378 1
a1378 1
    fprintf (stderr, "linux_wait\n");
d1384 1
a1384 1
  event_ptid = linux_wait_1 (ourstatus, target_options);
d1390 1
a1390 1
      && event_ptid != 0)
d1452 21
d1478 2
a1479 2
  unsigned long saved_tid;
  unsigned long ptid;
d1488 1
a1488 1
    saved_tid = 0; /* avoid bogus unused warning */
d1490 1
a1490 1
  ptid = lwpid_of (lwp);
d1523 12
d1708 13
a1720 5
    if (r->resume[ndx].thread == -1 || r->resume[ndx].thread == entry->id)
      {
	lwp->resume = &r->resume[ndx];
	return 0;
      }
d1792 1
a1792 1
	    fprintf (stderr, "running -> suspending %ld\n", lwpid_of (lwp));
d1838 1
a1838 1
      if (lwp->resume->thread == -1
d1927 1
d1937 2
d1946 1
a1946 1
	ptrace (PTRACE_PEEKUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, 0);
d2011 1
d2015 1
a2015 1
	  ptrace (PTRACE_POKEUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
d2054 1
d2058 1
d2072 1
a2072 1
      res = ptrace (regset->get_request, inferior_pid, 0, buf);
d2074 1
a2074 1
      res = ptrace (regset->get_request, inferior_pid, buf, 0);
d2088 2
a2089 2
	      sprintf (s, "ptrace(regsets_fetch_inferior_registers) PID=%ld",
		       inferior_pid);
d2109 1
d2113 1
d2131 1
a2131 1
      res = ptrace (regset->get_request, inferior_pid, 0, buf);
d2133 1
a2133 1
      res = ptrace (regset->get_request, inferior_pid, buf, 0);
d2143 1
a2143 1
	  res = ptrace (regset->set_request, inferior_pid, 0, buf);
d2145 1
a2145 1
	  res = ptrace (regset->set_request, inferior_pid, buf, 0);
d2229 1
d2236 1
a2236 1
      sprintf (filename, "/proc/%ld/mem", inferior_pid);
d2264 1
a2264 2
      buffer[i] = ptrace (PTRACE_PEEKTEXT, inferior_pid,
			  (PTRACE_ARG3_TYPE) addr, 0);
d2293 1
d2302 1
a2302 2
  buffer[0] = ptrace (PTRACE_PEEKTEXT, inferior_pid,
		      (PTRACE_ARG3_TYPE) addr, 0);
d2307 1
a2307 1
	= ptrace (PTRACE_PEEKTEXT, inferior_pid,
d2322 1
a2322 1
      ptrace (PTRACE_POKETEXT, inferior_pid, (PTRACE_ARG3_TYPE) addr, buffer[i]);
d2528 3
a2530 1
  if (thread_db_active)
d2533 2
a2534 1
  thread_db_active = thread_db_init (!linux_supports_tracefork_flag);
d2543 2
a2544 1
  if (cont_thread != 0 && cont_thread != -1)
d2565 1
d2567 1
a2567 1
  snprintf (filename, sizeof filename, "/proc/%ld/auxv", inferior_pid);
a2939 1
  thread_db_active = 0;
@


1.94
log
@	Decouple target code from remote protocol.

	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Return an unsigned long.  Take a
	target_waitstatus pointer instead of a char pointer.
	(mywait): Likewise.
	* target.c (mywait): Change prototype to return an unsigned long.
	Take a target_waitstatus pointer instead of a char pointer.  Adjust.
	* server.h (thread_from_wait, old_thread_from_wait): Delete
	declarations.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.
	* server.c (thread_from_wait, old_thread_from_wait): Delete.
	(last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.  Return a
	pid instead of a signal.
	(attach_inferior): Remove "status" and "signal" parameters.
	Adjust.
	(handle_query): For qGetTLSAddr, parse the thread id with strtol,
	not as an address.
	(handle_v_cont, handle_v_attach, handle_v_run, handle_v_kill)
	(handle_v_requests, myresume): Remove "status" and "signal"
	parameters.  Adjust.
	(handle_status): New.
	(main): Delete local `status'.  Adjust.
	* remote-utils.c: Include target.h.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.  Adjust.

	* linux-low.c (linux_wait): Adjust to new target_ops->wait
	interface.
	* spu-low.c (spu_wait): Adjust.
	* win32-low.c (enum target_waitkind, struct target_waitstatus):
	Delete.
	(win32_wait): Adjust.
@
text
@d121 1
a121 1
static int linux_wait_for_event (struct thread_info *child);
d142 9
a150 1
#define pid_of(proc) ((proc)->head.id)
d152 14
a165 2
/* FIXME: Delete eventually.  */
#define inferior_pid (pid_of (get_thread_lwp (current_inferior)))
d178 1
a178 1
      ptrace (PTRACE_GETEVENTMSG, inferior_pid, 0, &new_pid);
d200 1
a200 1
      new_thread_notify (thread_id_to_gdb_id (new_lwp->lwpid));
a276 1
  lwp->lwpid = pid;
d345 1
a345 1
	error ("Cannot attach to process %ld: %s (%d)\n", pid,
d355 1
a355 1
  new_thread_notify (thread_id_to_gdb_id (new_lwp->lwpid));
d399 7
a405 4
  /* Don't ignore the initial SIGSTOP if we just attached to this process.
     It will be collected by wait shortly.  */
  lwp = (struct lwp_info *) find_inferior_id (&all_lwps, pid);
  lwp->stop_expected = 0;
d419 1
d429 5
d436 1
a436 1
      ptrace (PTRACE_KILL, pid_of (lwp), 0, 0);
d439 2
a440 2
      wstat = linux_wait_for_event (thread);
    } while (WIFSTOPPED (wstat));
d449 1
d459 9
d470 1
a470 1
      ptrace (PTRACE_KILL, pid_of (lwp), 0, 0);
d473 2
a474 2
      wstat = linux_wait_for_event (thread);
    } while (WIFSTOPPED (wstat));
d476 1
a477 2
  free (all_lwps.head);
  all_lwps.head = all_lwps.tail = NULL;
d486 22
d517 1
d522 1
a522 1
      linux_wait_for_event (thread);
d530 3
a532 1
  ptrace (PTRACE_DETACH, pid_of (lwp), 0, 0);
a540 2
  free (all_lwps.head);
  all_lwps.head = all_lwps.tail = NULL;
a546 1
  extern unsigned long signal_pid;
d548 5
d555 1
a555 1
    ret = waitpid (signal_pid, &status, 0);
d585 1
a585 1
	     event_child->lwpid);
d640 1
a640 1
  if (lwp->status_pending_p)
d653 1
a653 1
  return lwp->status_pending_p;
d656 2
a657 2
static void
linux_wait_for_lwp (struct lwp_info **childp, int *wstatp)
d660 5
a664 1
  int to_wait_for = -1;
d666 1
a666 2
  if (*childp != NULL)
    to_wait_for = (*childp)->lwpid;
a668 3
  while (1)
    {
      ret = waitpid (to_wait_for, wstatp, WNOHANG);
d670 5
a674 20
      if (ret == -1)
	{
	  if (errno != ECHILD)
	    perror_with_name ("waitpid");
	}
      else if (ret > 0)
	break;

      ret = waitpid (to_wait_for, wstatp, WNOHANG | __WCLONE);

      if (ret == -1)
	{
	  if (errno != ECHILD)
	    perror_with_name ("waitpid (WCLONE)");
	}
      else if (ret > 0)
	break;

      usleep (1000);
    }
d682 1
a682 2
  if (to_wait_for == -1)
    *childp = (struct lwp_info *) find_inferior_id (&all_lwps, ret);
d688 1
a688 1
  if (*childp == NULL && WIFSTOPPED (*wstatp))
d693 1
a693 1
  else if (*childp == NULL)
d696 2
a697 2
  (*childp)->stopped = 1;
  (*childp)->pending_is_breakpoint = 0;
d699 1
a699 1
  (*childp)->last_status = *wstatp;
d719 1
a719 1
	find_inferior_id (&all_threads, (*childp)->lwpid);
d725 2
d729 6
d736 1
a736 1
linux_wait_for_event (struct thread_info *child)
d739 1
a739 2
  struct lwp_info *event_child;
  int wstat;
d741 1
d747 2
a748 1
  if (child == NULL)
d753 1
a753 1
	fprintf (stderr, "Got a pending child %ld\n", event_child->lwpid);
d757 5
a761 4
      event_child = get_thread_lwp (child);
      if (event_child->status_pending_p
	  && check_removed_breakpoint (event_child))
	event_child = NULL;
d766 8
a773 11
      if (event_child->status_pending_p)
	{
	  if (debug_threads)
	    fprintf (stderr, "Got an event from pending child %ld (%04x)\n",
		     event_child->lwpid, event_child->status_pending);
	  wstat = event_child->status_pending;
	  event_child->status_pending_p = 0;
	  event_child->status_pending = 0;
	  current_inferior = get_lwp_thread (event_child);
	  return wstat;
	}
d782 1
a782 4
      if (child == NULL)
	event_child = NULL;
      else
	event_child = get_thread_lwp (child);
d784 2
a785 1
      linux_wait_for_lwp (&event_child, &wstat);
d790 1
a790 2
      current_inferior = (struct thread_info *)
	find_inferior_id (&all_threads, event_child->lwpid);
d793 1
a793 1
      if (! WIFSTOPPED (wstat))
d795 1
d797 1
a797 1
	    fprintf (stderr, "LWP %ld exiting\n", event_child->head.id);
d801 5
a805 1
	    return wstat;
d807 2
a808 1
	  dead_thread_notify (thread_id_to_gdb_id (event_child->lwpid));
d810 13
a822 4
	  remove_inferior (&all_lwps, &event_child->head);
	  free (event_child);
	  remove_thread (current_inferior);
	  current_inferior = (struct thread_info *) all_threads.head;
d826 2
a827 2
	  if (child != NULL)
	    return wstat;
d833 2
a834 2
      if (WIFSTOPPED (wstat)
	  && WSTOPSIG (wstat) == SIGSTOP
d845 2
a846 2
      if (WIFSTOPPED (wstat) && WSTOPSIG (wstat) == SIGTRAP
	  && wstat >> 16 != 0)
d848 1
a848 1
	  handle_extended_wait (event_child, wstat);
d861 1
a861 1
      if (WIFSTOPPED (wstat)
d865 3
a867 2
	      (thread_db_active && (WSTOPSIG (wstat) == __SIGRTMIN
				    || WSTOPSIG (wstat) == __SIGRTMIN + 1))
d870 2
a871 2
	      (pass_signals[target_signal_from_host (WSTOPSIG (wstat))]
	       && (WSTOPSIG (wstat) != SIGSTOP || !stopping_threads))))
d877 1
a877 1
		     WSTOPSIG (wstat), event_child->head.id);
d879 1
a879 1
	  if (ptrace (PTRACE_GETSIGINFO, event_child->lwpid, 0, &info) == 0)
d885 1
a885 1
				WSTOPSIG (wstat), info_p);
d891 2
a892 2
      if (!WIFSTOPPED (wstat) || WSTOPSIG (wstat) != SIGTRAP)
	return wstat;
d897 1
a897 1
	return wstat;
d948 5
d980 1
a980 1
	return wstat;
d996 1
a996 1
      return wstat;
d1006 1
a1006 1
linux_wait (struct target_waitstatus *ourstatus)
d1009 10
a1018 2
  struct thread_info *child = NULL;
  struct lwp_info *lwp;
d1021 2
d1029 1
a1029 1
  if (cont_thread != 0 && cont_thread != -1)
d1031 2
a1032 2
      child = (struct thread_info *) find_inferior_id (&all_threads,
						       cont_thread);
d1035 1
a1035 1
      if (child == NULL)
d1039 2
a1040 1
	  resume_info.step = resume_info.sig = 0;
d1043 2
d1047 5
a1051 2
  w = linux_wait_for_event (child);
  stop_all_lwps ();
d1055 1
a1055 1
      ptrace (PTRACE_SETOPTIONS, inferior_pid, 0, PTRACE_O_TRACECLONE);
a1057 3

  lwp = get_thread_lwp (current_inferior);

d1072 1
a1072 2
      int pid = pid_of (lwp);
      if (WIFEXITED (w))
d1074 3
a1076 3
	  if (debug_threads)
	    fprintf (stderr, "\nChild exited with retcode = %x \n",
		     WEXITSTATUS (w));
d1078 1
a1078 2
	  ourstatus->kind = TARGET_WAITKIND_EXITED;
	  ourstatus->value.integer = WEXITSTATUS (w);
a1079 2
	  free (all_lwps.head);
	  all_lwps.head = all_lwps.tail = NULL;
d1081 17
a1097 7
	  return pid;
	}
      else if (!WIFSTOPPED (w))
	{
	  if (debug_threads)
	    fprintf (stderr, "\nChild terminated with signal = %x \n",
		     WTERMSIG (w));
d1099 1
a1099 5
	  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	  ourstatus->value.sig = target_signal_from_host (WTERMSIG (w));
	  clear_inferiors ();
	  free (all_lwps.head);
	  all_lwps.head = all_lwps.tail = NULL;
d1110 5
a1115 1
  ourstatus->value.sig = target_signal_from_host (WSTOPSIG (w));
d1117 79
a1195 1
  return lwp->lwpid;
d1226 1
d1231 2
d1238 1
a1238 2
	fprintf (stderr, "Have pending sigstop for lwp %ld\n",
		 lwp->lwpid);
d1248 1
a1248 1
    fprintf (stderr, "Sending sigstop to lwp %ld\n", lwp->head.id);
d1250 1
a1250 1
  kill_lwp (lwp->head.id, SIGSTOP);
d1257 1
a1257 1
  struct thread_info *saved_inferior, *thread;
d1260 1
d1266 8
a1273 4
  saved_tid = ((struct inferior_list_entry *) saved_inferior)->id;
  thread = (struct thread_info *) find_inferior_id (&all_threads,
						    lwp->lwpid);
  wstat = linux_wait_for_event (thread);
d1283 1
a1283 1
		 lwp->lwpid, wstat);
d1305 1
a1305 1
  if (linux_thread_alive (saved_tid))
d1312 12
a1323 2
      /* Set a valid thread as current.  */
      set_desired_inferior (0);
d1376 1
a1376 1
	     inferior_pid, step ? "step" : "continue", signal,
d1421 1
a1421 1
	ptrace (PTRACE_SETSIGINFO, lwp->lwpid, 0, &(*p_sig)->info);
d1432 1
a1432 1
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, lwp->lwpid, 0, signal);
a1488 5
/* This function is called once per thread.  We check the thread's resume
   request, which will tell us whether to resume, step, or leave the thread
   stopped; and what signal, if any, it should be sent.  For threads which
   we aren't explicitly told otherwise, we preserve the stepping flag; this
   is used for stepping over gdbserver-placed breakpoints.  */
d1490 3
a1492 2
static void
linux_continue_one_thread (struct inferior_list_entry *entry)
d1494 1
a1494 6
  struct lwp_info *lwp;
  struct thread_info *thread;
  int step;

  thread = (struct thread_info *) entry;
  lwp = get_thread_lwp (thread);
d1496 2
d1499 1
a1499 1
    return;
d1501 10
a1510 6
  if (lwp->resume->thread == -1
      && lwp->stepping
      && lwp->pending_is_breakpoint)
    step = 1;
  else
    step = lwp->resume->step;
d1512 2
a1513 1
  linux_resume_one_lwp (&lwp->head, step, lwp->resume->sig, NULL);
d1515 1
a1515 1
  lwp->resume = NULL;
d1520 5
a1524 4
   stopped; and what signal, if any, it should be sent.  We queue any needed
   signals, since we won't actually resume.  We already have a pending event
   to report, so we don't need to preserve any step requests; they should
   be re-issued if necessary.  */
d1526 7
a1532 2
static void
linux_queue_one_thread (struct inferior_list_entry *entry)
d1536 2
d1543 1
a1543 1
    return;
d1545 1
a1545 2
  /* If we have a new signal, enqueue the signal.  */
  if (lwp->resume->sig != 0)
d1547 22
a1568 5
      struct pending_signals *p_sig;
      p_sig = xmalloc (sizeof (*p_sig));
      p_sig->prev = lwp->pending_signals;
      p_sig->signal = lwp->resume->sig;
      memset (&p_sig->info, 0, sizeof (siginfo_t));
d1570 8
a1577 7
      /* If this is the same signal we were previously stopped by,
	 make sure to queue its siginfo.  We can ignore the return
	 value of ptrace; if it fails, we'll skip
	 PTRACE_SETSIGINFO.  */
      if (WIFSTOPPED (lwp->last_status)
	  && WSTOPSIG (lwp->last_status) == lwp->resume->sig)
	ptrace (PTRACE_GETSIGINFO, lwp->lwpid, 0, &p_sig->info);
d1579 3
a1581 1
      lwp->pending_signals = p_sig;
d1583 2
d1586 12
a1597 2
  lwp->resume = NULL;
}
d1599 6
a1604 5
/* Set DUMMY if this process has an interesting status pending.  */
static int
resume_status_pending_p (struct inferior_list_entry *entry, void *flag_p)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
d1606 6
a1611 4
  /* Processes which will not be resumed are not interesting, because
     we might not wait for them next time through linux_wait.  */
  if (lwp->resume == NULL)
    return 0;
d1613 16
a1628 10
  /* If this thread has a removed breakpoint, we won't have any
     events to report later, so check now.  check_removed_breakpoint
     may clear status_pending_p.  We avoid calling check_removed_breakpoint
     for any thread that we are not otherwise going to resume - this
     lets us preserve stopped status when two threads hit a breakpoint.
     GDB removes the breakpoint to single-step a particular thread
     past it, then re-inserts it and resumes all threads.  We want
     to report the second thread without resuming it in the interim.  */
  if (lwp->status_pending_p)
    check_removed_breakpoint (lwp);
d1630 3
a1632 2
  if (lwp->status_pending_p)
    * (int *) flag_p = 1;
d1634 1
d1649 2
a1650 1
     that would otherwise be sent.  */
d1652 2
a1653 1
  find_inferior (&all_lwps, resume_status_pending_p, &pending_flag);
d1663 1
a1663 4
  if (pending_flag)
    for_each_inferior (&all_threads, linux_queue_one_thread);
  else
    for_each_inferior (&all_threads, linux_continue_one_thread);
d2110 2
a2111 1
/* Wrapper function for waitpid which handles EINTR.  */
d2116 54
a2169 2
  int ret;
  do
d2171 4
a2174 1
      ret = waitpid (pid, status, flags);
a2175 1
  while (ret == -1 && errno == EINTR);
d2177 5
d2296 1
d2299 2
a2300 1
      kill_lwp (lwp->lwpid, SIGINT);
d2389 1
a2389 1
  int pid = get_thread_lwp (current_inferior)->head.id;
d2531 1
a2531 1
  pid = pid_of (get_thread_lwp (current_inferior));
d2559 77
d2670 3
d2686 2
d2699 5
@


1.93
log
@	* target.h (struct thread_resume): Delete leave_stopped member.
	(struct target_ops): Add a `n' argument to the `resume' callback.
	* server.c (start_inferior): Adjust.
	(handle_v_cont, myresume): Adjust.
	* linux-low.c (check_removed_breakpoint): Adjust to resume
	interface change, and to removed leave_stopped field.
	(resume_ptr): Delete.
	(struct thread_resume_array): New.
	(linux_set_resume_request): Add new `arg' parameter.  Adjust to
	resume interface change.
	(linux_continue_one_thread, linux_queue_one_thread)
	(resume_status_pending_p): Check if the resume field is NULL
	instead of checking the leave_stopped member.
	(linux_resume): Adjust to the target resume interface change.
	* spu-low.c (spu_resume): Adjust to the target resume interface
	change.
	* win32-low.c (win32_detach, win32_resume): Ditto.
@
text
@d932 2
a933 2
static unsigned char
linux_wait (char *status)
d937 1
d970 2
d986 1
d989 6
a994 3
	  fprintf (stderr, "\nChild exited with retcode = %x \n",
		   WEXITSTATUS (w));
	  *status = 'W';
d998 2
a999 1
	  return WEXITSTATUS (w);
d1003 6
a1008 3
	  fprintf (stderr, "\nChild terminated with signal = %x \n",
		   WTERMSIG (w));
	  *status = 'X';
d1012 2
a1013 1
	  return target_signal_from_host (WTERMSIG (w));
d1022 4
a1025 2
  *status = 'T';
  return target_signal_from_host (WSTOPSIG (w));
@


1.92
log
@gdb/gdbserver/

	* linux-low.c (linux_wait_for_event): Don't clear the `stepping'
	flag.
	(wait_for_sigstop): Don't leave a finished single-step SIGTRAP
	pending.
	(linux_continue_one_thread): Only preserve the stepping flag if
	there's a pending breakpoint.

gdb/testsuite/

	* gdb.threads/pending-step.c, gdb.threads/pending-step.exp: New.
@
text
@d119 1
a119 1
static void linux_resume (struct thread_resume *resume_info);
d955 2
a956 2
	  resume_info.step = resume_info.sig = resume_info.leave_stopped = 0;
	  linux_resume (&resume_info);
d1250 5
a1254 1
static struct thread_resume *resume_ptr;
d1263 2
a1264 2
static void
linux_set_resume_request (struct inferior_list_entry *entry)
d1269 1
d1273 1
d1275 9
a1283 3
  ndx = 0;
  while (resume_ptr[ndx].thread != -1 && resume_ptr[ndx].thread != entry->id)
    ndx++;
d1285 1
a1285 1
  lwp->resume = &resume_ptr[ndx];
d1304 1
a1304 1
  if (lwp->resume->leave_stopped)
d1335 1
a1335 1
  if (lwp->resume->leave_stopped)
d1369 1
a1369 1
  if (lwp->resume->leave_stopped)
d1390 1
a1390 1
linux_resume (struct thread_resume *resume_info)
d1393 1
d1395 1
a1395 4
  /* Yes, the use of a global here is rather ugly.  */
  resume_ptr = resume_info;

  for_each_inferior (&all_threads, linux_set_resume_request);
@


1.91
log
@	* i387-fp.c, linux-arm-low.c, linux-cris-low.c,
	linux-crisv32-low.c, linux-i386-low.c, linux-low.c,
	linux-mips-low.c, linux-s390-low.c, linux-sparc-low.c,
	linux-x86-64-low.c, linux-xtensa-low.c, proc-service.c,
	regcache.c, remote-utils.c, server.c, spu-low.c, target.h,
	thread-db.c, win32-low.c, xtensa-xtregs.c, gdbreplay.c,
	Makefile.in, configure.ac: Fix whitespace throughout.
	* configure: Regenerate.
@
text
@d125 1
d903 3
a905 8
	 SIGTRAP.  The single-step operation has completed, so also
	 clear the stepping flag; in general this does not matter,
	 because the SIGTRAP will be reported to the client, which
	 will give us a new action for this thread, but clear it for
	 consistency anyway.  It's safe to clear the stepping flag
	 because the only consumer of get_stop_pc () after this point
	 is check_removed_breakpoint, and pending_is_breakpoint is not
	 set.  It might be wiser to use a step_completed flag instead.  */
d907 1
a907 4
	{
	  event_child->stepping = 0;
	  return wstat;
	}
d1093 18
a1110 2
      lwp->status_pending_p = 1;
      lwp->status_pending = wstat;
d1295 4
a1298 2
  if (lwp->resume->thread == -1)
    step = lwp->stepping || lwp->resume->step;
@


1.90
log
@	Rename "process" to "lwp" throughout.

	* linux-low.c (all_processes): Rename to...
	(all_lwps): ... this.
	(inferior_pid, handle_extended_wait, get_stop_pc): Adjust.
	(add_process): Rename to ...
	(add_lwp): ... this.  Adjust.
	(linux_create_inferior): Adjust.
	(linux_attach_lwp): Adjust.
	(linux_attach): Adjust.
	(linux_kill_one_process): Rename to ...
	(linux_kill_one_lwp): ... this.  Adjust.
	(linux_kill): Adjust.
	(linux_detach_one_process): Rename to ...
	(linux_detach_one_lwp): ... this.  Adjust.
	(linux_detach): Adjust.
	(check_removed_breakpoint): Adjust.
	(status_pending_p): Adjust.
	(linux_wait_for_process): Rename to ...
	(linux_wait_for_lwp): ... this.  Adjust.
	(linux_wait_for_event): Adjust.
	(send_sigstop): Adjust.
	(wait_for_sigstop): Adjust.
	(stop_all_processes): Rename to ...
	(stop_all_lwps): ... this.
	(linux_resume_one_process): Rename to ...
	(linux_resume_one_lwp): ... this.  Adjust.
	(linux_set_resume_request, linux_continue_one_thread)
	(linux_queue_one_thread, resume_status_pending_p)
	(usr_store_inferior_registers, regsets_store_inferior_registers)
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Adjust.
	* linux-low.h (get_process): Rename to ...
	(get_lwp): ... this.  Adjust.
	(get_thread_process): Rename to ...
	(get_thread_lwp): ... this.  Adjust.
	(get_process_thread): Rename to ...
	(get_lwp_thread): ... this.  Adjust.
	(struct process_info): Rename to ...
	(struct lwp_info): ... this.
	(all_processes): Rename to ...
	(all_lwps): ... this.
	* proc-service.c (ps_lgetregs): Adjust.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(maybe_attach_thread, thread_db_get_tls_address): Adjust.
@
text
@d343 3
a345 3
        of a new thread that is being created.
        In this case we should ignore that SIGSTOP and resume the process.
        This is handled below by setting stop_expected = 1.
d348 6
a353 6
        to it via attach_inferior.
        In this case we want the process thread to stop.
        This is handled by having linux_attach clear stop_expected after
        we return.
        ??? If the process already has several threads we leave the other
        threads running.
d356 6
a361 6
        existing threads.
        In this case we want the thread to stop.
        FIXME: This case is currently not properly handled.
        We should wait for the SIGSTOP but don't.  Things work apparently
        because enough time passes between when we ptrace (ATTACH) and when
        gdb makes the next ptrace call on the thread.
d903 1
a903 1
         clear the stepping flag; in general this does not matter,
d907 1
a907 1
         because the only consumer of get_stop_pc () after this point
d992 2
a993 1
	  fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
d1002 2
a1003 1
	  fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
d1036 1
a1036 1
        return ret;
d1165 2
a1166 2
    fprintf (stderr, "Resuming lwp %ld (%s, signal %d, stop %s)\n", inferior_pid,
	     step ? "step" : "continue", signal,
d1428 2
a1429 2
  size = (register_size (regno) + sizeof (PTRACE_XFER_TYPE) - 1)
         & - sizeof (PTRACE_XFER_TYPE);
d1507 4
a1510 3
	      /* At this point, ESRCH should mean the process is already gone, 
		 in which case we simply ignore attempts to change its registers.
		 See also the related comment in linux_resume_one_lwp.  */
d1627 1
a1627 1
          res = ptrace (regset->set_request, inferior_pid, 0, buf);
d1629 1
a1629 1
          res = ptrace (regset->set_request, inferior_pid, buf, 0);
d1644 4
a1647 3
	      /* At this point, ESRCH should mean the process is already gone, 
		 in which case we simply ignore attempts to change its registers.
		 See also the related comment in linux_resume_one_lwp.  */
d1747 2
a1748 1
      buffer[i] = ptrace (PTRACE_PEEKTEXT, inferior_pid, (PTRACE_ARG3_TYPE) addr, 0);
d1754 3
a1756 1
  memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)), len);
d2069 8
a2076 8
         used by gdb) are relative to the beginning of the program,
         with the data segment immediately following the text segment.
         However, the actual runtime layout in memory may put the data
         somewhere else, so when we send gdb a data base-address, we
         use the real data base address and subtract the compile-time
         data base-address from it (which is just the length of the
         text segment).  BSS immediately follows data in both
         cases.  */
d2079 1
a2079 1
      
d2089 2
a2090 2
                   unsigned char *readbuf, unsigned const char *writebuf,
                   CORE_ADDR offset, int len)
d2118 32
a2149 32
         struct dirent *dp;
         while ((dp = readdir (dirp)) != NULL)
           {
             struct stat statbuf;
             char procentry[sizeof ("/proc/4294967295")];

             if (!isdigit (dp->d_name[0])
                 || strlen (dp->d_name) > sizeof ("4294967295") - 1)
               continue;

             sprintf (procentry, "/proc/%s", dp->d_name);
             if (stat (procentry, &statbuf) == 0
                 && S_ISDIR (statbuf.st_mode))
               {
                 char pathname[128];
                 FILE *f;
                 char cmd[MAXPATHLEN + 1];
                 struct passwd *entry;

                 sprintf (pathname, "/proc/%s/cmdline", dp->d_name);
                 entry = getpwuid (statbuf.st_uid);

                 if ((f = fopen (pathname, "r")) != NULL)
                   {
                     size_t len = fread (cmd, 1, sizeof (cmd) - 1, f);
                     if (len > 0)
                       {
                         int i;
                         for (i = 0; i < len; i++)
                           if (cmd[i] == '\0')
                             cmd[i] = ' ';
                         cmd[len] = '\0';
d2151 1
a2151 1
                         buffer_xml_printf (
d2161 5
a2165 5
                       }
                     fclose (f);
                   }
               }
           }
d2167 1
a2167 1
         closedir (dirp);
@


1.89
log
@2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/
	* target.h (enum target_object): Add new TARGET_OBJECT_SIGNAL_INFO.
	* infrun.c (siginfo_value_read, siginfo_value_write): New.
	(siginfo_value_funcs): New.
	(siginfo_make_value): New.
	(_initialize_infrun): Create the $_siginfo convenience variable.
	* gdbtypes.h (append_composite_type_field_aligned): Declare.
	* gdbtypes.c (append_composite_type_field): Rename to...
	(append_composite_type_field_aligned): ... this.  Add ALIGNMENT
	argument.  Handle it.
	(append_composite_type_field): Rewrite on top of
	append_composite_type_field_aligned.
	* value.h (internalvar_make_value): New typedef.
	(struct internalvar) <make_value>: New field.
	(create_internalvar_type_lazy): Declare.
	* value.c (create_internalvar): Clear make_value.
	(create_internalvar_type_lazy): New.
	(value_of_internalvar): If make_value is set use it.
	(preserve_values): Skip internal variables that don't have a
	value.
	* gdbarch.sh (get_siginfo_type): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.h, linux-tdep.c: New.
	* amd64-linux-tdep.c: Include "linux-tdep.h".
	(amd64_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* i386-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.
	* arm-linux-tdep.c: Include "linux-tdep.h".
	(i386_linux_init_abi): Register linux_get_siginfo_type and
	linux_get_siginfo_mapper.

	* linux-nat.c (linux_xfer_siginfo): New.
	(linux_nat_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	* remote.c (PACKET_qXfer_siginfo_read)
	(PACKET_qXfer_siginfo_write): New.
	(feature remote_protocol_features): Add "qXfer:siginfo:read" and
	"qXfer:siginfo:write" features.
	(remote_xfer_partial): Handle TARGET_OBJECT_SIGNAL_INFO.
	(_initialize_remote): Add "set/show remote read-siginfo-object"
	and "set/show remote write-siginfo-object" commands.

	* Makefile.in (ALL_TARGET_OBS): Add linux-tdep.o.
	(HFILES_NO_SRCDIR): Add linux-tdep.h.
	(ALLDEPFILES): Add linux-tdep.c.

	* configure.tgt (arm*-*-linux* | arm*-*-uclinux*)
	(i[34567]86-*-linux*, x86_64-*-linux*): Add linux-tdep.o to
	gdb_target_obs.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* server.c (handle_query): Report qXfer:siginfo:read and
	qXfer:siginfo:write as supported and handle them.
	* target.h (struct target_ops) <qxfer_siginfo>: New field.
	* linux-low.c (linux_xfer_siginfo): New.
	(linux_target_ops): Set it.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Signals): Document $_siginfo.
	(Convenience Variables): Mention $_siginfo.
	(Remote Configuration): Document qXfer:siginfo:read,
	qXfer:siginfo:write packets, and the read-siginfo-object,
	write-siginfo-object commands.

2009-02-06  Pedro Alves  <pedro@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/siginfo-obj.c, gdb.base/siginfo-obj.exp: New.
@
text
@d92 1
a92 1
   ``all_processes'' is keyed by the process ID - which on Linux is (presently)
d95 1
a95 1
struct inferior_list all_processes;
d117 2
a118 2
static void linux_resume_one_process (struct inferior_list_entry *entry,
				      int step, int signal, siginfo_t *info);
d120 1
a120 1
static void stop_all_processes (void);
d122 2
a123 2
static int check_removed_breakpoint (struct process_info *event_child);
static void *add_process (unsigned long pid);
d144 1
a144 1
#define inferior_pid (pid_of (get_thread_process (current_inferior)))
d147 1
a147 1
handle_extended_wait (struct process_info *event_child, int wstat)
d150 1
a150 1
  struct process_info *new_process;
d177 3
a179 3
      new_process = (struct process_info *) add_process (new_pid);
      add_thread (new_pid, new_process, new_pid);
      new_thread_notify (thread_id_to_gdb_id (new_process->lwpid));
d187 1
a187 1
	    new_process->stopped = 1;
d193 1
a193 1
	  new_process->stop_expected = 1;
d196 3
a198 3
	      new_process->stopped = 1;
	      new_process->status_pending_p = 1;
	      new_process->status_pending = status;
d209 2
a210 2
      linux_resume_one_process (&event_child->head,
				event_child->stepping, 0, NULL);
d241 1
a241 1
  if (get_thread_process (current_inferior)->stepping)
d248 1
a248 1
add_process (unsigned long pid)
d250 1
a250 1
  struct process_info *process;
d252 2
a253 2
  process = (struct process_info *) xmalloc (sizeof (*process));
  memset (process, 0, sizeof (*process));
d255 2
a256 2
  process->head.id = pid;
  process->lwpid = pid;
d258 1
a258 1
  add_inferior_to_list (&all_processes, &process->head);
d260 1
a260 1
  return process;
d269 1
a269 1
  void *new_process;
d298 2
a299 2
  new_process = add_process (pid);
  add_thread (pid, new_process, pid);
d311 1
a311 1
  struct process_info *new_process;
d318 1
a318 1
	  fprintf (stderr, "Cannot attach to process %ld: %s (%d)\n", pid,
d333 3
a335 3
  new_process = (struct process_info *) add_process (pid);
  add_thread (pid, new_process, pid);
  new_thread_notify (thread_id_to_gdb_id (new_process->lwpid));
d365 1
a365 1
     because we are guaranteed that the add_process call above added us to the
d369 1
a369 1
    new_process->stop_expected = 1;
d375 1
a375 1
  struct process_info *process;
d381 2
a382 2
  process = (struct process_info *) find_inferior_id (&all_processes, pid);
  process->stop_expected = 0;
d392 1
a392 1
linux_kill_one_process (struct inferior_list_entry *entry)
d395 1
a395 1
  struct process_info *process = get_thread_process (thread);
d407 1
a407 1
      ptrace (PTRACE_KILL, pid_of (process), 0, 0);
d418 1
a418 1
  struct process_info *process;
d424 1
a424 1
  for_each_inferior (&all_threads, linux_kill_one_process);
d426 1
a426 1
  /* See the comment in linux_kill_one_process.  We did not kill the first
d428 1
a428 1
  process = get_thread_process (thread);
d431 1
a431 1
      ptrace (PTRACE_KILL, pid_of (process), 0, 0);
d438 2
a439 2
  free (all_processes.head);
  all_processes.head = all_processes.tail = NULL;
d443 1
a443 1
linux_detach_one_process (struct inferior_list_entry *entry)
d446 1
a446 1
  struct process_info *process = get_thread_process (thread);
d450 1
a450 1
  check_removed_breakpoint (process);
d455 1
a455 1
  if (process->stop_expected)
d458 3
a460 3
      process->stop_expected = 0;
      if (process->stopped)
	linux_resume_one_process (&process->head, 0, 0, NULL);
d466 1
a466 1
			   get_process_thread (process));
d469 1
a469 1
  ptrace (PTRACE_DETACH, pid_of (process), 0, 0);
d476 1
a476 1
  for_each_inferior (&all_threads, linux_detach_one_process);
d478 2
a479 2
  free (all_processes.head);
  all_processes.head = all_processes.tail = NULL;
d510 1
a510 1
check_removed_breakpoint (struct process_info *event_child)
d519 1
a519 1
    fprintf (stderr, "Checking for breakpoint in process %ld.\n",
d523 1
a523 1
  current_inferior = get_process_thread (event_child);
d568 2
a569 2
/* Return 1 if this process has an interesting status pending.  This function
   may silently resume an inferior process.  */
d573 1
a573 1
  struct process_info *process = (struct process_info *) entry;
d575 2
a576 2
  if (process->status_pending_p)
    if (check_removed_breakpoint (process))
d584 1
a584 1
	linux_resume_one_process (&process->head, 0, 0, NULL);
d588 1
a588 1
  return process->status_pending_p;
d592 1
a592 1
linux_wait_for_process (struct process_info **childp, int *wstatp)
d633 1
a633 1
    *childp = (struct process_info *) find_inferior_id (&all_processes, ret);
d682 1
a682 1
  struct process_info *event_child;
d692 2
a693 2
      event_child = (struct process_info *)
	find_inferior (&all_processes, status_pending_p, NULL);
d699 1
a699 1
      event_child = get_thread_process (child);
d715 1
a715 1
	  current_inferior = get_process_thread (event_child);
d729 1
a729 1
	event_child = get_thread_process (child);
d731 1
a731 1
      linux_wait_for_process (&event_child, &wstat);
d751 1
a751 1
	  remove_inferior (&all_processes, &event_child->head);
d772 2
a773 2
	  linux_resume_one_process (&event_child->head,
				    event_child->stepping, 0, NULL);
d814 3
a816 3
	  linux_resume_one_process (&event_child->head,
				    event_child->stepping,
				    WSTOPSIG (wstat), info_p);
d844 1
a844 1
	  linux_resume_one_process (&event_child->head, 0, 0, NULL);
d881 1
a881 1
	    linux_resume_one_process (&event_child->head, 0, 0, NULL);
d886 1
a886 1
	      linux_resume_one_process (&event_child->head, 1, 0, NULL);
d892 1
a892 1
	      linux_resume_one_process (&event_child->head, 0, 0, NULL);
d968 1
a968 1
  stop_all_processes ();
d995 2
a996 2
	  free (all_processes.head);
	  all_processes.head = all_processes.tail = NULL;
d1004 2
a1005 2
	  free (all_processes.head);
	  all_processes.head = all_processes.tail = NULL;
d1046 1
a1046 1
  struct process_info *process = (struct process_info *) entry;
d1048 1
a1048 1
  if (process->stopped)
d1053 1
a1053 1
  if (process->stop_expected)
d1056 2
a1057 2
	fprintf (stderr, "Have pending sigstop for process %ld\n",
		 process->lwpid);
d1062 1
a1062 1
      process->stop_expected = 0;
d1067 1
a1067 1
    fprintf (stderr, "Sending sigstop to process %ld\n", process->head.id);
d1069 1
a1069 1
  kill_lwp (process->head.id, SIGSTOP);
d1075 1
a1075 1
  struct process_info *process = (struct process_info *) entry;
d1080 1
a1080 1
  if (process->stopped)
d1086 1
a1086 1
						    process->lwpid);
d1097 4
a1100 4
		 process->lwpid, wstat);
      process->status_pending_p = 1;
      process->status_pending = wstat;
      process->stop_expected = 1;
d1116 1
a1116 1
stop_all_processes (void)
d1119 2
a1120 2
  for_each_inferior (&all_processes, send_sigstop);
  for_each_inferior (&all_processes, wait_for_sigstop);
d1129 2
a1130 2
linux_resume_one_process (struct inferior_list_entry *entry,
			  int step, int signal, siginfo_t *info)
d1132 1
a1132 1
  struct process_info *process = (struct process_info *) entry;
d1135 1
a1135 1
  if (process->stopped == 0)
d1142 2
a1143 2
      && (process->status_pending_p || process->pending_signals != NULL
	  || process->bp_reinsert != 0))
d1147 1
a1147 1
      p_sig->prev = process->pending_signals;
d1153 1
a1153 1
      process->pending_signals = p_sig;
d1156 1
a1156 1
  if (process->status_pending_p && !check_removed_breakpoint (process))
d1160 1
a1160 1
  current_inferior = get_process_thread (process);
d1163 1
a1163 1
    fprintf (stderr, "Resuming process %ld (%s, signal %d, stop %s)\n", inferior_pid,
d1165 1
a1165 1
	     process->stop_expected ? "expected" : "not expected");
d1174 1
a1174 1
     uninserted (see comment in linux_wait_for_process) but not enough for
d1177 1
a1177 1
  if (process->bp_reinsert != 0)
d1180 1
a1180 1
	fprintf (stderr, "  pending reinsert at %08lx", (long)process->bp_reinsert);
d1189 1
a1189 1
  check_removed_breakpoint (process);
d1199 1
a1199 1
  if (process->pending_signals != NULL && process->bp_reinsert == 0)
d1203 1
a1203 1
      p_sig = &process->pending_signals;
d1209 1
a1209 1
	ptrace (PTRACE_SETSIGINFO, process->lwpid, 0, &(*p_sig)->info);
d1216 1
a1216 1
			   get_process_thread (process));
d1218 3
a1220 3
  process->stopped = 0;
  process->stepping = step;
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, process->lwpid, 0, signal);
d1251 1
a1251 1
  struct process_info *process;
d1256 1
a1256 1
  process = get_thread_process (thread);
d1262 1
a1262 1
  process->resume = &resume_ptr[ndx];
d1274 1
a1274 1
  struct process_info *process;
d1279 1
a1279 1
  process = get_thread_process (thread);
d1281 1
a1281 1
  if (process->resume->leave_stopped)
d1284 2
a1285 2
  if (process->resume->thread == -1)
    step = process->stepping || process->resume->step;
d1287 1
a1287 1
    step = process->resume->step;
d1289 1
a1289 1
  linux_resume_one_process (&process->head, step, process->resume->sig, NULL);
d1291 1
a1291 1
  process->resume = NULL;
d1304 1
a1304 1
  struct process_info *process;
d1308 1
a1308 1
  process = get_thread_process (thread);
d1310 1
a1310 1
  if (process->resume->leave_stopped)
d1314 1
a1314 1
  if (process->resume->sig != 0)
d1318 2
a1319 2
      p_sig->prev = process->pending_signals;
      p_sig->signal = process->resume->sig;
d1326 3
a1328 3
      if (WIFSTOPPED (process->last_status)
	  && WSTOPSIG (process->last_status) == process->resume->sig)
	ptrace (PTRACE_GETSIGINFO, process->lwpid, 0, &p_sig->info);
d1330 1
a1330 1
      process->pending_signals = p_sig;
d1333 1
a1333 1
  process->resume = NULL;
d1340 1
a1340 1
  struct process_info *process = (struct process_info *) entry;
d1344 1
a1344 1
  if (process->resume->leave_stopped)
d1355 2
a1356 2
  if (process->status_pending_p)
    check_removed_breakpoint (process);
d1358 1
a1358 1
  if (process->status_pending_p)
d1379 1
a1379 1
  find_inferior (&all_processes, resume_status_pending_p, &pending_flag);
d1507 1
a1507 1
		 See also the related comment in linux_resume_one_process.  */
d1643 1
a1643 1
		 See also the related comment in linux_resume_one_process.  */
d1959 1
a1959 1
      struct process_info *process;
d1961 2
a1962 2
      process = get_thread_process (current_inferior);
      kill_lwp (process->lwpid, SIGINT);
d2051 1
a2051 1
  int pid = get_thread_process (current_inferior)->head.id;
d2193 1
a2193 1
  pid = pid_of (get_thread_process (current_inferior));
@


1.88
log
@* ChangeLog: Fix date of last entry.
* linux-low.c (handle_extended_wait): Improve comment.
@
text
@d2183 38
d2254 1
@


1.87
log
@	* linux-low.c (linux_attach_lwp): Add some comments/fixmes.
@
text
@d183 1
a183 1
         If we do, be sure not to lose it.  */
@


1.86
log
@        Updated copyright notices for most files.
@
text
@d329 2
d338 24
a361 3
     brings it to a halt.  We should ignore that SIGSTOP and resume the process
     (unless this is the first process, in which case the flag will be cleared
     in linux_attach).
d365 3
a367 3
     because we are guaranteed that add_process added us to the end of the
     list, and so the new thread has not yet reached wait_for_sigstop (but
     will).  */
@


1.85
log
@	* utils.c (xmalloc,xcalloc,xstrdup): New fns.
	* server.h (ATTR_MALLOC): New macro.
	(xmalloc,xcalloc,xstrdup): Declare.
	* hostio.c: Replace malloc,calloc,strdup with xmalloc,xcalloc,xstrdup.
	* inferiors.c: Ditto.
	* linux-low.c: Ditto.
	* mem-break.c: Ditto.
	* regcache.c: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* target.c: Ditto.
	* win32-low.c: Ditto.
@
text
@d3 1
a3 1
   2006, 2007, 2008 Free Software Foundation, Inc.
@


1.84
log
@	* linux-low.c (linux_wait_for_process): Don't clobber current_inferior
	in debugging printf.
@
text
@d252 1
a252 1
  process = (struct process_info *) malloc (sizeof (*process));
d1123 1
a1123 1
      p_sig = malloc (sizeof (*p_sig));
d1294 1
a1294 1
      p_sig = malloc (sizeof (*p_sig));
d1530 1
a1530 1
      buf = malloc (regset->size);
d1583 1
a1583 1
      buf = malloc (regset->size);
d1835 1
a1835 1
  char *stack = malloc (STACK_SIZE * 4);
d2215 1
a2215 1
  disabled_regsets = malloc (num_regsets);
@


1.83
log
@	* linux-low.c (handle_extended_wait): Simplify, use my_waitpid.
@
text
@d645 1
d651 1
@


1.82
log
@	Implement -list-thread-groups --available

        * Makefile.in (XMLFILES): Add osdata.dtd.
        (SFILES): Add osdata.c.
        (COMMON_OBS): Add osdata.o.
        * linux-nat.c: Include pwd.h, sys/types.h, gdb_dirent.h and xml-support.h.
        (linux_nat_xfer_osdata): New function.
        (linux_xfer_partial): Handle TARGET_OBJECT_OSDATA.
        * osdata.c: New file.
        * osdata.h: New file.
        * remote.c (PACKET_qXfer_osdata): New packet enum.
        (remote_protocol_features): Add "qXfer:osdata:read".
        (remote_read_qxfer): Handle TARGET_OBJECT_OSDATA.
        (extended_remote_can_run): New.
        (init_extended_remote_ops): Set to_can_run to
        extended_remote_can_run.
        (_initialize_remote): Add packet config command for
        "qXfer:osdata:read".
        * xml-support.c (obstack_xml_printf): New function.
        * xml-support.h (obstack_xml_printf): Declare.
        * target.c (target_get_osdata): New function.
        * target.h (enum target_object): Add TARGET_OBJECT_OSDATA.
        (target_os_data): Declare.
        * features/osdata.dtd: New file.
        * mi/mi-main.c (mi_list_thread_groups): Handle the --available
        option.
@
text
@d124 1
d165 1
a165 3
	  do {
	    ret = waitpid (new_pid, &status, __WALL);
	  } while (ret == -1 && errno == EINTR);
@


1.81
log
@2008-11-14  Daniel Gutson  <dgutson@@codesourcery.com>

	* configure.tgt (sparc64-*-linux*): Added gdbserver support.
	* regformats/reg-sparc64.dat: New file.

gdbserver/
2008-11-14  Daniel Gutson  <dgutson@@codesourcery.com>

	* Makefile.in (SFILES, clean): Added sparc64 files.
	(reg-sparc64.o, reg-sparc64.c): New.
	* configure.srv (sparc*-*-linux*): New configuration.
	* linux-low.c (regsets_fetch_inferior_registers): Swap ptrace
	syscall arguments for SPARC.
	(regsets_store_inferior_registers): Likewise.
	* linux-sparc-low.c: New file.
@
text
@d36 4
d2056 103
d2191 1
@


1.81.2.1
log
@2008-11-25  Pedro Alves  <pedro@@codesourcery.com>

	2008-10-13  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (discard_pending_stop_replies): Initialize prev.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_wait_1): Cancel breakpoint hits in threads
	we're not reporting.
	(cancel_breakpoints_callback): New.

	2008-10-12  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (queue_stop_reply_callback, handle_status): Pass
	TARGET_SIGNAL_TRAP, not TARGET_SIGNAL_0.

	* linux-low.c (ptid_is_pid): Delete.
	(linux_wait_for_event): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_wait): Flush the event pipe before polling for an event.
	(wait_for_sigstop): In non-stop, don't set the current
	inferior arbitrarily.
	(linux_resume_one_lwp): Small cleanup.
	(cancel_breakpoint): New.
	(linux_resume_one_thread): Use it.  Still report SIGTRAPs.
	(regsets_store_inferior_registers): Plug leak.
	(sigchld_handler): Don't use fprintf here.

	* mem-break.c (breakpoint_at): New.
	* inferiors.c (ptid_is_pid): New.
	* mem-break.h (breakpoint_at): Declare.
	* server.c (discard_queued_stop_replies): Add `pid' argument.
	Handle it.
	(send_next_stop_reply): Cleanup.
	(attach_inferior): Don't wait here in non-stop mode.
	(handle_v_attach): Don't queue stop replies here.
	(handle_v_kill): Discard queued stop replies of the inferior we
	just killed.
	(queue_stop_reply_callback): Add `arg' argument.  Handle it.
	(handle_status): Adjust.
	(kill_inferior_callback): Discard queued stop replies of the
	inferior we just killed.
	(detach_or_kill_inferior_callback): Discard queued stop replies of
	the inferior we just killed or detached from.
	(process_serial_event): Cleanup.  Discard queued stop replies of
	the inferior we just detached.  Don't write 0 bytes to the inferior.
	(handle_serial_event): Debug output.
	* server.h (ptid_is_pid): Declare.

	* remote-utils.c (prepare_resume_reply): Avoid reading registers
	and memory from a thread that is gone.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.h (struct sym_cache, struct process_info_private):
	Forward declare.
	(struct process_info): Add symbol_cache, all_symbols_looked_up and
	private fields.
	(current_process): Declare.
	* remote-utils.c (struct sym_cache) <name>: Remove constness.
	(symbol_cache): Delete.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust, to per-process symbol cache.
	* inferiors.c (current_process): New.

	* linux-low.h: Include "gdb_proc_service.h".
	(struct process_info_private): Define.
	* linux-low.c (thread_db_active): Delete.
	(linux_add_process): New.
	(handle_extended_wait, linux_create_inferior, linux_attach): Use
	it.
	(linux_wait_for_event, linux_look_up_symbols): Adjust.
	(initialize_low): Don't clear the global thread_db_active.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(fixup_proc_handle): New.
	(thread_db_err_str, thread_db_enable_reporting): Use it.  Adjust.
	(thread_db_find_new_threads): Look for the current inferior
	thread, not the first thread in the list.  Use fixup_proc_handle.
	Adjust.
	(thread_db_get_tls_address): Use fixup_proc_handle.
	(thread_db_init): Likewise.  Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* mem-break.c (get_breakpoint_list): Add `create' argument.  Only
	create the list if create is set.
	(remove_breakpoint_list): New.
	(set_breakpoint_at, find_breakpoint_at, check_mem_read)
	(check_mem_write, delete_all_breakpoints): Adjust.

	2008-09-26  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (gdbserver_usage): Describe --remote-debug option.
	(main): Handle --remote-debug switch.

	2008-09-19  Pedro Alves  <pedro@@codesourcery.com>

	Non-stop mode support.

	* linux-low.c (linux_event_pipe): New int array for pipe.
	(target_is_async_p): New.
	(handle_extended_wait): Use my_waitpid.
	(linux_kill_one_lwp): Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_kill_one_process, linux_kill): Delete.
	(linux_kill_1): Rename back to ...
	(linux_kill) ... this.  Stop the LWP if it is not stopped already.
	Use my_waitpid, not linux_wait_for_event.  Remove the lwp and the
	corresponding thread from the lists.
	(linux_detach_one_lwp): Make sure the LWP is stopped.  Adjust to
	new linux_wait_for_event interface.
	(linux_detach_one_process, linux_detach): Delete.
	(linux_detach_1): Rename back to ...
	(linux_detach): This.
	(linux_join): Add PID argument.  Use my_waitpid instead of
	waitpid.
	(status_pending_p): Ignore suspended threads.
	(my_waitpid): Emulate __WALL.
	(linux_wait_for_lwp): Add 'options' argument.  Handle it.  Use
	my_wait.  If requesting an event from a specific process, leave
	events in other processes pending.
	(resume_stopped_lwps): New.
	(linux_wait_for_event): Delete.
	(linux_wait_for_event_1): Rename back to ...
	(linux_wait_for_event): ... this.  Change interface: add wstat and
	options arguments, return -1 on error, 0 otherwise.  Adjust.  In
	all-stop, resume stopped lwps if there was no pending status.
	Don't return immediatelly if a pending status was found ---
	continue handling it instead.  Don't loop, only handle one event.
	(linux_wait): Rename to ...
	(linux_wait_1): ... this.  Add target_options argument.  Handle
	it.  Don't loop --- only handle one event.  Ignore the continue
	thread in non_stop mode.  Adjust to new resume_kind interface.
	Only stop all threads in all-stop mode.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(wait_for_sigstop): Set stopping_threads here.  Use
	linux_wait_for_lwp instead of linux_wait_for_event.  Adjust.
	(stop_all_lwps): Don't set stopping_threads here.
	(resume_ptr): Delete.
	(struct resume_info): New.
	(linux_set_resume_request): Add arg argument.  Adjust to take a
	struct remove_info instead of the global resume_ptr.  Accept
	pid,-1 to apply to all threads.
	(linux_continue_one_thread, linux_queue_one_thread): Merge both
	and create ...
	(linux_resume_one_thread): ... this.  New.  Handle rk_stop.
	(resume_status_pending_p): Assume no resume info to mean do
	nothing.  Ignore suspended LWPs.
	(linux_resume): Add n argument.  Adjust.  In non-stop mode, don't
	look for a pending status over all threads.
	(linux_read_offsets): Minor cleanup.
	(sigchld_handler, linux_async, linux_start_non_stop): New.
	(linux_target_ops): Register linux_async and linux_start_non_stop.
	(initialize_low): Register sigchld_handler as SIGCHLD handler.

	* utils.c (internal_verror, internal_error_file_line): New.

	* Makefile.in (SFILES): Add event-loop.c.
	(OBS): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (struct lwp_info) <suspended>: New flag.

	* thread-db.c (thread_db_create_event): Make sure thread_db reads
	from the current inferior.
	(thread_db_get_tls_address): Comment.

	* server.c (thread_from_wait, old_thread_from_wait, attached):
	Delete.
	(non_stop): New global.
	(own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to new thread_resume interface.  Adjust
	to new mywait interface.
	(attach_inferior): Adjust.
	(handle_general_set): Handle QNonStop.
	(handle_query): Pass 'QNonStop+'.
	(handle_v_cont): Handle vCont;t.  Don't enable/disable async io in
	non-stop mode.  In non-stop return OK, and don't wait for the
	target.
	(handle_v_attach): In non-stop, return OK, and queue events for
	all threads.
	(handle_v_run): In non-stop, set the general thread here.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for 't'.  Handle 'vStopped'.
	(proceed): Add comment.  Adjust.  In non-stop, don't
	enable/disable async io; write 'OK', and don't wait for the
	target.
	(queue_stop_reply_callback, handle_status): New.
	(kill_inferior_callback, detach_or_kill_inferior_callback)
	(join_inferiors_callback): New.
	(main): In --debug mode, also enable remote debug.  Don't pass -1
	to kill_inferior or detach_inferior; instead, iterate over all
	processes killing or detaching them.  Adjust to use the even-loop.
	(process_serial_event): New, factored out of main.  If the
	connection closed, remove all sources from the event loop.
	Iterate over all inferiors joining them.  Use handle_status.
	Don't print inferior exit notices here.  In non-stop, defer
	exiting until GDB read all queued events.
	(handle_serial_event, handle_target_event): New.

	* server.h (FOR_EACH_INFERIOR): New.
	(thread_from_wait, old_thread_from_wait): Remove.
	(non_stop): Declare.
	(gdb_client_data, handler_func): New typedefs.
	(delete_file_handler, add_file_handler, start_event_loop)
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif, internal_error_file_line): Declare.
	(internal_error): Define.

	* target.c (mywait): Add `options' argument.  Print inferior exit
	notices here.
	(start_non_stop): New.

	* event-loop.c: New.

	* remote-utils.c (remote_open): Register remote_desc in the event
	loop, with handle_serial_event as callback.
	(remote_close): Remove remote_desc from the event loop.
	(hex_or_minus_one): New.
	(read_ptid, read_ptid): Use it.
	(putpkt_binary): Rename to ...
	(putpkt_binary_1): ... this.  Add `notif' argument.  Handle
	pushing a remote protocol notification.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(getpkt): Debug output.
	(prepare_resume_reply): Remove dead code.  In non-stop, don't set
	the general thread here.

	* target.h (enum resume_kind): New.
	(struct thread_resume) <leave_stopped, step>: Delete.
	(struct thread_resume) <kind>: New field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <kill, detach>: Adjust comments.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <resume>: Add `n' argument.
	(struct target_ops) <wait>: Add `options' argument.
	(struct target_ops) <async, start_non_stop>: New fields.
	(join_inferior): Add `pid' argument.
	(target_async): New.
	(start_non_stop): Declare.
	(mywait): Add options argument.

	2008-09-15  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (new_inferior): Mention in the comment that all
	inferiors should have the same architecture for now.
	(linux_create_inferior, linux_attach): Only set new_inferior if
	this is the first process.

	2008-08-29  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (ptid_is_pid): Move higher.
	(linux_wait_for_lwp): Remove dead code.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.
	(linux_wait_for_event): New.
	(ptid_same_pid): Delete.
	(linux_set_resume_request): Clearify.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (handle_extended_wait, linux_attach_lwp)
	(linux_attach): Minor cleanups.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_thread_alive): Return false for a listed
	thread known to be dead.
	(linux_wait_for_event): Don't set the dead flag here.
	(wait_for_sigstop): Store ptid before waiting for the event.
	Minor cleanup.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (find_inferior): Allow deleting the current iterated
	inferior.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_pid_to_exec_file): Move higher.
	(linux_enable_event_reporting): Enable PTRACE_O_TRACEEXEC.
	(handle_extended_wait): Handle PTRACE_EVENT_EXEC.

	* remote-utils.c (prepare_resume_reply): Set the general thread to
	the last thread that had an event in TARGET_WAITKIND_FORKED and
	TARGET_WAITKIND_VFORKED.  Handle TARGET_WAITKIND_EXECD.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* server.c (handle_query): Pass "QExecFile:PID;" back in the reply.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (linux_supports_tracefork_flag): Move higher.
	(linux_enable_event_reporting): New.
	(handle_extended_wait): Change return type to int.  Handle
	PTRACE_EVENT_FORK and PTRACE_EVENT_VFORK.
	(add_lwp): Set waitstatus.kind to TARGET_WAITKIND_IGNORE.
	(linux_attach_lwp): Use linux_enable_event_reporting.
	(linux_wait_for_event): Don't keep waiting if the extended wait
	status should be reported to gdb.
	(linux_wait): Use linux_enable_event_reporting.  If waitstatus
	holds a processed event, return it instead.
	* remote-utils.c (prepare_resume_reply): Handle
	TARGET_WAITKIND_FORKED and TARGET_WAITKIND_VFORKED.
	* linux-low.h (struct lwp_info) <waitstatus>: New member.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* target.h (struct target_ops) <pid_to_exec_file>: New member.
	* server.c (handle_query): Handle qExecFile.
	* linux-low.c (linux_pid_to_exec_file): New.
	(linux_target_ops): Register it.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c (is_lwpid): New.
	(linux_kill_one_lwp, linux_kill_1, linux_detach_one_lwp): Adjust.
	(status_pending_p): Check if we're interested in this lwp.
	(linux_wait_for_lwp): Change signature: return an lwp_info*, and
	take a ptid instead of an lwp_info**.
	(linux_wait_for_event): Take a ptid instead of a thread_info
	pointer.  Adjust.
	(wait_for_sigstop): Adjust.  If a whole process died, keep the
	exit status pending.
	(ptid_is_pid, ptid_same_pid): New.
	(linux_set_resume_request): Allow resuming all threads of a process.
	(resume_status_pending_p): Check for dead lwps.

	* linux-low.h (struct lwp_info) <dead>: New field.

	* server.c (start_inferior): Only resume and wait for events from
	the inferior we're creating.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Decouple target code from remote protocol.

	* linux-low.c (linux_wait): Change prototype.  Adjust.
	* server.c (last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.
	(attach_inferior, handle_v_cont, handle_v_attach, handle_v_run)
	(handle_v_kill, handle_v_requests): Remove "status" and "signal"
	parameters.  Adjust.
	(myresume): Rename to ...
	(proceed): ... this.  Remove "statusp" parameter.  Adjust.
	(main): Remove "status" local.  Adjust.
	* target.c (mywait): Change prototype.  Adjust.
	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Change prototype.
	(mywait): Adjust.
	* remote-utils.c: Include "target.h".
	(prepare_resume_reply): Change prototype to take a ptid and a
	target_waitstatus.  Adjust.
	* server.h (prepare_resume_reply): Adjust prototype.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* inferiors.c (all_processes): New.
	(add_process): New.

	* linux-low.c (linux_create_inferior): Add process.
	(linux_attach_lwp): Add "initial" parameter, and use it instead of
	relying on having only one thread in the global list.
	(linux_attach): Add process.
	(struct counter): New.
	(check_if_last_thread_of_pid, is_last_thread_of_process): New.
	(linux_kill_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Use
	is_last_thread_of_process.
	(linux_kill): Rename to ...
	(linux_kill_1): ... this.  Kill lwps of the requested only.
	(linux_kill_one_process): New.
	(linux_kill): New.
	(linux_detach_one_lwp): Add ARGS parameter.  Change return type to
	int.  Check if we're interested in this lwp.  Remove the lwp from
	both the lwp list and the thread list.
	(any_thread_of, linux_detach_1, linux_detach_one_process): New.
	(linux_detach): Reimplement.
	(linux_wait_for_event): Use is_last_thread_of_process.
	(linux_wait): Likewise.  On process exit, don't clear all inferiors.
	Implement multi-process extensions.

	* mem-break.c (breakpoints): Delete.
	(struct breakpoint_list): New.
	(all_breakpoints): New.
	(get_breakpoint_list): New.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Use it.

	* server.h (struct process_info): New.
	(all_processes): Declare.
	(add_process): Declare.

	* linux-low.h (linux_attach_lwp): Add "initial" parameter.

	* thread-db.c (maybe_attach_thread): Adjust.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	* linux-low.c, linux-low.h, proc-service.c, thread-db.c: Rename
	`struct process_info' to `struct lwp_info', and adjust throughout.

	2008-08-28  Pedro Alves  <pedro@@codesourcery.com>

	Implement remote protocol multi-process extensions.

	* inferiors.c (null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New functions.
	(add_thread): Drop gdb_id argument.  Retype thread_id argument to
	ptid_t.  Adjust.
	(thread_id_to_gdb_id): Adjust.
	(thread_to_gdb_id): Change return type to ptid_t.  Adjust.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Adjust.
	(gdb_id_to_thread_id): Change return type to ptid_t.  Adjust.
	(find_inferior_id): Change id argument type to ptid_t.  Adjust.
	(loaded_dll, add_pid_to_list, pull_pid_from_list): Adjust.
	(initialize_inferiors): New.

	* remote-utils.c (hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, read_ptid): New.
	(prepare_resume_reply): Adjust.

	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait): Change type to ptid_t.
	(multi_process): New.
	(start_inferior): Adjust.
	(handle_query): Adjust.  Report multiprocess extensions support.
	(handle_v_cont): Adjust.
	(handle_v_kill): New.
	(handle_v_requests): Handle vKill.
	(myresume): Adjust.
	(first_thread_of): New.
	(main): Call initialize_inferiors.  If bailing out, kill all
	inferiors.  Handle multi-process detach.  Handle multi-process H
	and T.

	* server.h (ULONGEST): New typedef.
	(struct ptid): New struct.
	(ptid_t): New typedef.
	(minus_one_ptid, null_ptid): New.
	(ptid_t ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal): New.
	(struct inferior_list_entry) <id>: Change type to ptid_t.
	(add_thread, thread_id_to_gdb_id, thread_to_gdb_id)
	(gdb_id_to_thread_id): Adjust prototypes.
	(find_thread_pid): Declare.
	(find_inferior_id): Adjust prototype.
	(cont_thread, general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Adjust type to ptid_t.
	(multi_process): Declare.
	(read_ptid, write_ptid): Declare.

	* linux-low.c (pid_of): Adjust.
	(lwpid_of): New.
	(inferior_lwpid): New.
	(handle_extended_wait): Adjust.
	(add_process): Change pid argument to a ptid.  Adjust.
	(linux_create_inferior): Adjust.
	(linux_attach_lwp): Adjust.  Clear new_inferior on error.  If
	creating a new inferior, don't rely on inferior_pid, instead use
	the lwpid as pid.
	(linux_attach): Set new_inferior earlier.  Adjust.
	(linux_kill): Change return type to int.  Adjust.
	(linux_detach): Add pid parameter.
	(linux_thread_alive): Change lwpid paremeter type to ptid.
	Adjust.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_process): Adjust.
	(linux_wait_for_process, linux_wait_for_event, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process,
	(linux_resume_one_process, linux_set_resume_request)
	(linux_continue_one_thread, linux_queue_one_thread)
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory, linux_request_interrupt, linux_read_auxv):
	Adjust.

	* linux-low.h (get_process_thread): Adjust.
	(struct process_info) <lwpid>: Remove.
	(find_lwp_pid): Declare.

	* target.c (set_desired_inferior): Adjust.
	(target_pid_to_str): New.

	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_ops) <kill>: Change return type to int, and take an
	int as parameter.
	(struct target_ops) <detach>: Take an int as parameter.
	(struct target_ops) <thread_alive>: Change pid argument type to
	ptid_t.
	(kill_inferior, detach_inferior): Add PID argument.

	* thread-db.c (thread_db_create_event): Adjust.
	(find_one_thread): Change argument to a ptid.  Adjust.
	(maybe_attach_thread, thread_db_get_tls_address, thread_db_init):
	Adjust.

	* proc-service.c (ps_lgetregs): Adjust.
@
text
@d85 2
a86 2
/* ``all_processes'' is keyed by the "overall process ID", which
   GNU/Linux calls tgid, "thread group ID".
d88 2
a89 2
   ``all_threads'' is keyed by the LWP ID, which we use as the GDB
   protocol representation of the thread ID.
d91 1
a91 2
   ``all_lwps'' is keyed by the LWP ID - on Linux the LWP IDs are
   global (presently).  */
d93 2
a94 4
struct inferior_list all_lwps;

/* A list of all unknown lwps which receive stop signals.  Some other
   lwp will presumably claim each of these as forked children
d104 1
d108 3
a110 7
/* This flag is true iff we've just created or attached to our first
   inferior but it has not stopped yet.  As soon as it does, we need
   to call the low target's arch_setup callback.  Doing this only on
   the first inferior avoids reinializing the architecture on every
   inferior, and avoids messing with the register caches of the
   already running inferiors.  NOTE: this assumes all inferiors under
   control of gdbserver have the same architecture.  */
d113 7
a119 7
static void linux_resume_one_lwp (struct inferior_list_entry *entry,
				  int step, int signal, siginfo_t *info);
static void linux_resume (struct thread_resume *resume_info, size_t n);
static void stop_all_lwps (void);
static int linux_wait_for_event (ptid_t ptid, int *wstat, int options);
static int check_removed_breakpoint (struct lwp_info *event_child);
static void *add_lwp (ptid_t ptid);
d136 1
a136 4
#define pid_of(proc) ptid_get_pid ((proc)->head.id)
#define lwpid_of(proc) ptid_get_lwp ((proc)->head.id)

#define is_lwpid(ptid) (ptid_get_lwp (ptid) != 0)
d139 1
a139 71
#define inferior_pid (pid_of (get_thread_lwp (current_inferior)))
#define inferior_lwpid (lwpid_of (get_thread_lwp (current_inferior)))

/* The read/write ends of the pipe registered as waitable file in the
   event loop.  */
static int linux_event_pipe[2] = { -1, -1 };

/* True if we're currently in async mode.  */
#define target_is_async_p() (linux_event_pipe[0] != -1)

static int my_waitpid (int pid, int *status, int flags);
static void send_sigstop (struct inferior_list_entry *entry);
static void wait_for_sigstop (struct inferior_list_entry *entry);
static int cancel_breakpoints_callback (struct inferior_list_entry *entry,
					void *data);

/* Add a process to the common process list, and set its private
   data.  */

static struct process_info *
linux_add_process (int pid, int attached)
{
  struct process_info *proc;

  proc = add_process (pid, attached);
  proc->private = calloc (1, sizeof (*proc->private));

  return proc;
}

/* Read the tgid of an lwp from `/proc/PID/status'.  */

static int
tgid_of_pid (int pid)
{
  FILE *status_file;
  char buf[100];
  int tgid = 0;

  snprintf (buf, sizeof (buf), "/proc/%d/status", pid);
  status_file = fopen (buf, "r");
  if (status_file != NULL)
    {
      while (fgets (buf, sizeof (buf), status_file))
	{
	  if (strncmp (buf, "Tgid:", 5) == 0)
	    {
	      tgid = strtol (buf + 5, NULL, 0);
	      break;
	    }
	}
      fclose (status_file);
    }

  return tgid;
}

static char *
linux_pid_to_exec_file (int pid)
{
  static char path[MAXPATHLEN];
  char procexe[MAXPATHLEN];

  sprintf (procexe, "/proc/%d/exe", pid);
  if (readlink (procexe, path, MAXPATHLEN) > 0)
    return path;
  else
    return NULL;
}

static int linux_supports_tracefork_flag;
d142 1
a142 25
linux_enable_event_reporting (int pid)
{
  int options;

  options = PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK
    | PTRACE_O_TRACEEXEC | PTRACE_O_TRACECLONE;

#if 0
  /* TODO: We need to model this in the remote protocol.  */
  if (linux_supports_tracevforkdone (pid))
    options |= PTRACE_O_TRACEVFORKDONE;
#endif

  /* Do not enable PTRACE_O_TRACEEXIT until GDB is more prepared to support
     read-only process state.  */
  ptrace (PTRACE_SETOPTIONS, pid, 0, options);
}

/* Handle a GNU/Linux extended wait response.  If we see a clone
   event, we need to add the new LWP to our list (and not report the
   trap to higher layers).  This function returns non-zero if the
   event should be ignored and we should wait again.  */

static int
handle_extended_wait (struct lwp_info *event_child, int wstat)
d145 1
a145 2
  struct lwp_info *new_lwp;
  struct target_waitstatus *ourstatus = &event_child->waitstatus;
d147 1
a147 3
  if (event == PTRACE_EVENT_FORK
      || event == PTRACE_EVENT_VFORK
      || event == PTRACE_EVENT_CLONE)
a148 1
      ptid_t ptid;
d152 1
a152 1
      ptrace (PTRACE_GETEVENTMSG, lwpid_of (event_child), 0, &new_pid);
d160 3
a162 1
	  ret = my_waitpid (new_pid, &status, __WALL);
d172 1
a172 3
      ourstatus->value.related_pid = ptid_build (new_pid, new_pid, 0);

      linux_enable_event_reporting (new_pid);
d174 8
a181 2
      if (event == PTRACE_EVENT_FORK
	  || event == PTRACE_EVENT_VFORK)
d183 2
a184 4
	  int is_fork = (event == PTRACE_EVENT_FORK);

	  if (is_fork)
	    ourstatus->kind = TARGET_WAITKIND_FORKED;
d186 1
a186 20
	    ourstatus->kind = TARGET_WAITKIND_VFORKED;

	  if (debug_threads)
	    {
	      if (is_fork)
		fprintf (stderr, "PTRACE_EVENT_FORK pid=(%ld), newpid=(%ld)",
			 lwpid_of (event_child), new_pid);
	      else
		fprintf (stderr, "PTRACE_EVENT_VFORK pid=(%ld), newpid=(%ld)",
			 lwpid_of (event_child), new_pid);
	    }

	  linux_add_process (new_pid, 1);
	  ptid = ptid_build (new_pid, new_pid, 0);
	  new_lwp = (struct lwp_info *) add_lwp (ptid);
	  new_lwp->stopped = 1;
	  add_thread (ptid, new_lwp);

	  event_child->stopped = 1;
	  return 0;
d190 2
a191 11
	  ptid = ptid_build (pid_of (event_child), new_pid, 0);
	  new_lwp = (struct lwp_info *) add_lwp (ptid);
	  add_thread (ptid, new_lwp);
#if 0
	  new_thread_notify (thread_id_to_gdb_id (new_lwp->lwpid));
#endif

	  /* Normally we will get the pending SIGSTOP.  But in some
	     cases we might get another signal delivered to the group
	     first.  If we do, be sure not to lose it.  */
	  if (WSTOPSIG (status) == SIGSTOP)
d193 3
a195 4
	      if (stopping_threads)
		new_lwp->stopped = 1;
	      else
		ptrace (PTRACE_CONT, new_pid, 0, 0);
d198 4
a201 13
	    {
	      new_lwp->stop_expected = 1;
	      if (stopping_threads)
		{
		  new_lwp->stopped = 1;
		  new_lwp->status_pending_p = 1;
		  new_lwp->status_pending = status;
		}
	      else
		/* Pass the signal on.  This is what GDB does - except
		   shouldn't we really report it instead?  */
		ptrace (PTRACE_CONT, new_pid, 0, WSTOPSIG (status));
	    }
d203 4
a206 4
	  /* Always resume the current thread.  If we are stopping
	     threads, it will have a pending SIGSTOP; we may as well
	     collect it now.  */
	  linux_resume_one_lwp (&event_child->head,
a207 11
	  return 1;
	}
    }
  else if (event == PTRACE_EVENT_EXEC)
    {
      fprintf (stderr, "got PTRACE_EVENT_EXEC\n");

      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname
	= strdup (linux_pid_to_exec_file (lwpid_of (event_child)));
      return 0;
a208 2

  error ("unknown ptrace event %d", event);
d211 1
a211 1
/* This function should only be called if the lwp got a SIGTRAP.
d215 1
a215 1
   If we were single-stepping this lwp using PTRACE_SINGLESTEP,
d219 1
a219 1
   If we continue the lwp using PTRACE_CONT, we will get a
d238 1
a238 1
  if (get_thread_lwp (current_inferior)->stepping)
d245 1
a245 1
add_lwp (ptid_t ptid)
d247 1
a247 4
  struct lwp_info *lwp;

  lwp = (struct lwp_info *) malloc (sizeof (*lwp));
  memset (lwp, 0, sizeof (*lwp));
d249 2
a250 1
  lwp->head.id = ptid;
d252 2
a253 1
  lwp->waitstatus.kind = TARGET_WAITKIND_IGNORE;
d255 1
a255 1
  add_inferior_to_list (&all_lwps, &lwp->head);
d257 1
a257 1
  return lwp;
d266 1
a266 1
  void *new_lwp;
a267 1
  ptid_t ptid;
d295 2
a296 9
  /* If this the first process?  If so, then set the arch.  */
  if (all_processes.head == NULL)
    new_inferior = 1;

  linux_add_process (pid, 0);

  ptid = ptid_build (pid, pid, 0);
  new_lwp = add_lwp (ptid);
  add_thread (ptid, new_lwp);
d298 1
d306 1
a306 1
linux_attach_lwp (unsigned long pid, int initial)
d308 1
a308 2
  ptid_t ptid;
  struct lwp_info *new_lwp;
d312 1
a312 1
      if (!initial)
d315 1
a315 1
	  fprintf (stderr, "Cannot attach to lwp %ld: %s (%d)\n", pid,
d321 3
a323 7
	{
	  new_inferior = 0;

	  /* If we fail to attach to a process, report an error.  */
	  error ("Cannot attach to lwp %ld: %s (%d)\n", pid,
		 strerror (errno), errno);
	}
d326 1
a326 1
  linux_enable_event_reporting (pid);
d328 3
a330 12
  if (initial)
    /* NOTE/FIXME: This lwp might have not been the tgid.  */
    ptid = ptid_build (pid, pid, 0);
  else
    ptid = ptid_build (inferior_pid, pid, 0);

  new_lwp = (struct lwp_info *) add_lwp (ptid);
  add_thread (ptid, new_lwp);

#if 0
  new_thread_notify (thread_id_to_gdb_id (new_lwp->lwpid));
#endif
d333 1
a333 1
     brings it to a halt.  We should ignore that SIGSTOP and resume the lwp
d339 1
a339 1
     because we are guaranteed that add_lwp added us to the end of the
d343 1
a343 1
    new_lwp->stop_expected = 1;
d349 1
a349 7
  struct lwp_info *lwp;
  int tgid = tgid_of_pid (pid);

  /* Maybe we could be smarter about this.  */
  if (tgid != 0 && tgid != pid)
    warning ("%s is a cloned process",
	     target_pid_to_str (pid_to_ptid (pid)));
d351 1
a351 7
  linux_attach_lwp (pid, 1);

  /* If this the first process?  If so, then set the arch.  */
  if (all_processes.head == NULL)
    new_inferior = 1;

  linux_add_process (pid, 1);
d355 2
a356 6
  lwp = (struct lwp_info *) find_inferior_id (&all_lwps,
					      ptid_build (pid, pid, 0));
  lwp->stop_expected = 0;

  return 0;
}
d358 1
a358 19
struct counter
{
  int pid;
  int count;
};

static int
check_if_last_thread_of_pid (struct inferior_list_entry *entry, void *args)
{
  struct counter *counter = args;

  if (ptid_get_pid (entry->id) == counter->pid)
    {
      counter->count++;

      if (counter->count > 1)
	/* OK, we know it's not the last, we can stop counting.  */
	return 1;
    }
d363 1
a363 6
static int
is_last_thread_of_process (struct thread_info *thread)
{
  ptid_t ptid = ((struct inferior_list_entry *)thread)->id;
  int pid = ptid_get_pid (ptid);
  struct counter counter = { pid , 0 };
d365 2
a366 8
  return (find_inferior (&all_threads,
			 check_if_last_thread_of_pid, &counter) == NULL);
}

/* Kill the inferior lwp.  */

static int
linux_kill_one_lwp (struct inferior_list_entry *entry, void *args)
d369 1
a369 1
  struct lwp_info *lwp = get_thread_lwp (thread);
a370 4
  int pid = * (int *) args;

  if (ptid_get_pid (entry->id) != pid)
    return 0;
d376 2
a377 13

  if (pid_of (lwp) == lwpid_of (lwp))
    {
      if (debug_threads)
	fprintf (stderr, "lkop: is last of process %s\n",
		 target_pid_to_str (entry->id));
      return 0;
    }

  /* If we're killing a running inferior, make sure it is stopped
     first, as PTRACE_KILL will not work otherwise.  */
  if (!lwp->stopped)
    send_sigstop (&lwp->head);
d381 1
a381 1
      ptrace (PTRACE_KILL, lwpid_of (lwp), 0, 0);
d384 2
a385 7
      pid = my_waitpid (lwpid_of (lwp), &wstat, __WALL);
    } while (pid == lwpid_of (lwp));

  remove_inferior (&all_lwps, &lwp->head);
  remove_thread (thread);

  return 0;
d388 2
a389 2
static int
linux_kill (int pid)
d391 1
a392 2
  struct lwp_info *lwp;
  struct thread_info *thread;
a393 1
  int lwpid;
d395 2
a396 2
  process =
    (struct process_info *) find_inferior_id (&all_processes, pid_to_ptid (pid));
d398 1
a398 4
  if (process == NULL)
    return -1;

  find_inferior (&all_threads, linux_kill_one_lwp, &pid);
d400 1
a400 1
  /* See the comment in linux_kill_one_lwp.  We did not kill the first
d402 1
a402 12
  lwp = find_lwp_pid (pid_to_ptid (pid));
  thread = get_lwp_thread (lwp);

  if (debug_threads)
    fprintf (stderr, "lk_1: killing lwp %s, for pid: %d\n",
	     target_pid_to_str (lwp->head.id), pid);

  /* If we're killing a running inferior, make sure it is stopped
     first, as PTRACE_KILL will not work otherwise.  */
  if (!lwp->stopped)
    send_sigstop (&lwp->head);

d405 1
a405 1
      ptrace (PTRACE_KILL, lwpid_of (lwp), 0, 0);
d408 2
a409 2
      lwpid = my_waitpid (lwpid_of (lwp), &wstat, __WALL);
    } while (lwpid == lwpid_of (lwp));
d411 3
a413 5
  remove_inferior (&all_lwps, &lwp->head);
  remove_thread (thread);
  remove_inferior (&all_processes, &process->head);

  return 0;
d416 2
a417 2
static int
linux_detach_one_lwp (struct inferior_list_entry *entry, void *args)
d420 1
a420 13
  struct lwp_info *lp = get_thread_lwp (thread);
  int pid = * (int *) args;

  if (ptid_get_pid (entry->id) != pid)
    return 0;

  /* If we're detaching from a running inferior, make sure it is
     stopped first, as PTRACE_DETACH will not work otherwise.  */
  if (!lp->stopped)
    {
      send_sigstop (&lp->head);
      wait_for_sigstop (&lp->head);
    }
d422 1
a422 1
  /* Make sure the LWP isn't stopped at a breakpoint that's
d424 1
a424 1
  check_removed_breakpoint (lp);
d426 1
a426 1
  /* If this lwp is stopped but is expecting a SIGSTOP, then make
d429 1
a429 1
  if (lp->stop_expected)
a430 1
      int wstat;
d432 4
a435 4
      lp->stop_expected = 0;
      if (lp->stopped)
	linux_resume_one_lwp (&lp->head, 0, 0, NULL);
      linux_wait_for_event (lp->head.id, &wstat, __WALL);
d438 1
a438 1
  /* Flush any pending changes to the lwp's registers.  */
d440 1
a440 1
			   get_lwp_thread (lp));
d443 1
a443 7
  ptrace (PTRACE_DETACH, lwpid_of (lp), 0, 0);

  /* Get rid of it.  */
  remove_inferior (&all_lwps, &lp->head);
  remove_thread (thread);

  return 0;
d447 1
a447 1
any_thread_of (struct inferior_list_entry *entry, void *args)
a448 23
  int *pid_p = args;

  if (ptid_get_pid (entry->id) == *pid_p)
    return 1;

  return 0;
}

static int
linux_detach (int pid)
{
  struct process_info *process;

  process =
    (struct process_info *) find_inferior_id (&all_processes,
					      pid_to_ptid (pid));

  if (process == NULL)
    return -1;

  current_inferior =
    (struct thread_info *) find_inferior (&all_threads, any_thread_of, &pid);

d450 4
a453 3
  find_inferior (&all_threads, linux_detach_one_lwp, &pid);

  remove_inferior (&all_processes, &process->head);
d458 1
a458 1
linux_join (int pid)
d460 1
a462 12
  struct process_info *process;
  process = (struct process_info *) find_inferior_id (&all_processes,
						      pid_to_ptid (pid));

  if (!process)
    return; /* weird */

  /* If we are attached, then we can exit.  Otherwise, we need to hang
     around doing nothing, until the child is gone.  */
  if (process->attached)
    return;

d464 1
a464 1
    ret = my_waitpid (pid, &status, 0);
d472 1
a472 1
linux_thread_alive (ptid_t ptid)
d474 2
a475 7
  struct lwp_info *lwp = find_lwp_pid (ptid);

  /* We assume we always know if a thread exits.  If a whole process
     exited but we still haven't been able to report it to GDB, we'll
     hold on to the last lwp of the dead process.  */
  if (lwp != NULL)
    return !lwp->dead;
d480 1
a480 1
/* Return nonzero if this lwp stopped at a breakpoint which
d484 1
a484 1
check_removed_breakpoint (struct lwp_info *event_child)
d493 2
a494 2
    fprintf (stderr, "Checking for breakpoint in lwp %ld.\n",
	     lwpid_of (event_child));
d497 1
a497 1
  current_inferior = get_lwp_thread (event_child);
d542 2
a543 2
/* Return 1 if this lwp has an interesting status pending.  This function
   may silently resume an inferior lwp.  */
d545 1
a545 1
status_pending_p (struct inferior_list_entry *entry, void *arg)
d547 1
a547 2
  struct lwp_info *lwp = (struct lwp_info *) entry;
  ptid_t ptid = * (ptid_t *) arg;
d549 2
a550 8
  /* Check if we're only interested in events from a specific process
     or its lwps.  */
  if (!ptid_equal (minus_one_ptid, ptid)
      && ptid_get_pid (ptid) != ptid_get_pid (lwp->head.id))
    return 0;

  if (lwp->status_pending_p && !lwp->suspended)
    if (check_removed_breakpoint (lwp))
d557 2
a558 2
	   before; resume the lwp.  */
	linux_resume_one_lwp (&lwp->head, 0, 0, NULL);
d562 1
a562 1
  return (lwp->status_pending_p && !lwp->suspended);
d565 2
a566 2
static int
same_lwp (struct inferior_list_entry *entry, void *data)
d568 2
a569 2
  ptid_t ptid = *(ptid_t *) data;
  int lwp;
d571 2
a572 4
  if (ptid_get_lwp (ptid) != 0)
    lwp = ptid_get_lwp (ptid);
  else
    lwp = ptid_get_pid (ptid);
d574 2
a575 24
  if (ptid_get_lwp (entry->id) == lwp)
    return 1;

  return 0;
}

struct lwp_info *
find_lwp_pid (ptid_t ptid)
{
  return (struct lwp_info*) find_inferior (&all_lwps, same_lwp, &ptid);
}

/* Wrapper function for waitpid which handles EINTR, and emulates
   __WALL for systems where that is not available.  */

static int
my_waitpid (int pid, int *status, int flags)
{
  int ret, out_errno;

  if (debug_threads)
    fprintf (stderr, "my_waitpid (%d, 0x%x)\n", pid, flags);

  if (flags & __WALL)
d577 1
a577 3
      sigset_t mask;
      sigset_t org_mask;
      sigset_t suspend_mask;
d579 7
a585 10
      int org_flags = flags;
      int wnohang = (flags & WNOHANG) != 0;
      flags &= ~__WALL;
      flags |= WNOHANG;
      flags &= ~__WCLONE;

      sigemptyset (&mask);
      sigaddset (&mask, SIGCHLD);

      sigprocmask (SIG_BLOCK, &mask, &org_mask);
d587 1
a587 2
      /* Any signal unblocks the sigsuspend below.  */
      sigemptyset (&suspend_mask);
d589 1
a589 1
      while (1)
d591 2
a592 41
	  do
	    {
	      errno = 0;
	      ret = waitpid (pid, status, flags);
	    }
	  while (ret == -1 && errno == EINTR);
	  out_errno = errno;

	  if (ret == -1)
	    {
	      if (out_errno != ECHILD)
		break;

	      /* We know there's no child of this flavour, recurse
		 with the right type.  */
	      org_flags &= ~__WALL;
	      org_flags |= (flags & __WCLONE) ? 0 : __WCLONE;
	      ret = my_waitpid (pid, status, org_flags);
	      out_errno = errno;
	      break;
	    }
	  else if (ret > 0)
	    break;

	  if (flags & __WCLONE)
	    {
	      if (wnohang)
		break;
	      else
		{
		  if (debug_threads)
		    fprintf (stderr, "blocking\n");

		  /* Block waiting for any signal.  Ideally, we'd wait for
		     SIGCHLD and LinuxThreads' signals, but this avoids
		     knowing which signals those are.  */
		  sigsuspend (&suspend_mask);
		}
	    }

	  flags ^= __WCLONE;
d594 2
d597 1
a597 1
      sigprocmask (SIG_SETMASK, &org_mask, NULL);
a598 45
  else
    {
      do
	ret = waitpid (pid, status, flags);
      while (ret == -1 && errno == EINTR);
      out_errno = errno;
    }

  if (debug_threads)
    fprintf (stderr, "my_waitpid (%d, 0x%x): status(%x), %d\n",
	     pid, flags, status ? *status : -1, ret);

  errno = out_errno;
  return ret;
}

static struct lwp_info *
linux_wait_for_lwp (ptid_t ptid, int *wstatp, int options)
{
  int ret;
  int to_wait_for = -1;
  struct lwp_info *child = NULL;

  if (debug_threads)
    fprintf (stderr, "linux_wait_for_lwp: %s\n", target_pid_to_str (ptid));

  if (ptid_equal (ptid, minus_one_ptid))
    to_wait_for = -1;			/* any child */
  else if (is_lwpid (ptid))
    to_wait_for = ptid_get_lwp (ptid);	/* this lwp only */
  else
    to_wait_for = -1;			/* a specific tgid, but this
					   is not possible.  We wait
					   for everything, and cache
					   what we don't need now.  */

  options |= __WALL;

retry:

  ret = my_waitpid (to_wait_for, wstatp, options);
  if (ret == 0 || (ret == -1 && errno == ECHILD && (options & WNOHANG)))
    return NULL;
  else if (ret == -1)
    perror_with_name ("waitpid");
d606 2
a607 1
  child = find_lwp_pid (pid_to_ptid (ret));
d609 3
a611 3
  /* If we didn't find a lwp, one of two things presumably happened:
     - A lwp we started and then detached from has exited.  Ignore it.
     - A lwp we are controlling has forked and the new child's stop
d613 1
a613 1
  if (child == NULL && WIFSTOPPED (*wstatp))
a615 8
      if (options & WNOHANG)
	return NULL;
      goto retry;
    }
  else if (child == NULL)
    {
      if (options & WNOHANG)
	return NULL;
d618 2
d621 2
a622 2
  child->stopped = 1;
  child->pending_is_breakpoint = 0;
d624 1
a624 1
  child->last_status = *wstatp;
d643 1
a643 1
	find_inferior_id (&all_threads, child->head.id);
a647 38

  if (ptid_is_pid (ptid))
    {
      if (pid_of (child) != ptid_get_pid (ptid))
	{
	  if (debug_threads)
	    fprintf (stderr, "LWP %ld got an event %06x, leaving pending.\n",
		     lwpid_of (child), *wstatp);
	  child->status_pending_p = 1;
	  child->status_pending = *wstatp;
	  if ((options & WNOHANG) == 0)
	    goto retry;

	  child = NULL;
	}
    }

  return child;
}

static int
resume_stopped_lwps (struct inferior_list_entry *entry, void *arg)
{
  ptid_t ptid = * (ptid_t *) arg;
  struct lwp_info *lwp = (struct lwp_info *) entry;

  if ((ptid_equal (ptid, minus_one_ptid)
       || (ptid_is_pid (ptid)
	   && ptid_get_pid (ptid) == pid_of (lwp)))
      && lwp->stopped
      && !lwp->suspended)
    {
      if (debug_threads)
	fprintf (stderr, "resuming stopped LWP %ld\n", lwpid_of (lwp));
      linux_resume_one_lwp (&lwp->head, 0, 0, NULL);
    }

  return 0;
a649 1

d651 1
a651 1
linux_wait_for_event (ptid_t ptid, int *wstat, int options)
d654 2
a655 1
  struct lwp_info *event_child = NULL;
a656 1
  struct lwp_info *requested_child = NULL;
d658 1
a658 1
  /* Check for a lwp with a pending status.  */
d662 1
a662 3

  if (ptid_equal (ptid, minus_one_ptid)
      || ptid_equal (pid_to_ptid (ptid_get_pid (ptid)), ptid))
d664 2
a665 2
      event_child = (struct lwp_info *)
	find_inferior (&all_lwps, status_pending_p, &ptid);
d667 1
a667 17
	fprintf (stderr, "Got a pending child %ld\n", lwpid_of (event_child));

      /* If we just handled a pending status, and the event was not
	 interesting to report to GDB, we will reach here again.  This
	 time, we may find that there are no more interesting pending
	 statuses to handle, but, the previous iteration left all
	 threads stopped.  Resume them now.

	 Don't do this in non-stop mode, as that would resume threads
	 silently behind GDB's back --- e.g., just after starting a
	 new inferior, we could get here due to a spurious
	 target_wait(..., TARGET_WNOHANG) call.  In that case, we
	 don't want to resume all stopped threads.  In all-stop, there
	 should be no wnohang calls, so we always want to resume
	 threads.  */
      if (!non_stop && !event_child)
	find_inferior (&all_lwps, resume_stopped_lwps, &ptid);
d671 4
a674 4
      requested_child = find_lwp_pid (ptid);
      if (requested_child->status_pending_p
	  && !check_removed_breakpoint (requested_child))
	event_child = requested_child;
d679 11
a689 6
      if (debug_threads)
	fprintf (stderr, "Got an event from pending child %ld (%04x)\n",
		 ptid_get_lwp (event_child->head.id), event_child->status_pending);
      *wstat = event_child->status_pending;
      event_child->status_pending_p = 0;
      event_child->status_pending = 0;
d692 10
a701 4
  /* If no lwp of interested had a pending wait status, wait for
     one.  */
  if (!event_child)
    event_child = linux_wait_for_lwp (ptid, wstat, options);
d703 1
a703 3
    {
      if ((options & WNOHANG) && event_child == NULL)
	return -1;
d708 2
a709 1
      current_inferior = get_lwp_thread (event_child);
d712 1
a712 1
      if (! WIFSTOPPED (*wstat))
d715 1
a715 2
	    fprintf (stderr, "LWP %ld exiting\n",
		     ptid_get_lwp (event_child->head.id));
d718 3
a720 8
	  if (is_last_thread_of_process (current_inferior))
	    {
	      if (debug_threads)
		fprintf (stderr, "LWP %ld is last lwp of process\n",
			 ptid_get_lwp (event_child->head.id));
	      return 0;
	    }
#if 0
a721 1
#endif
d723 1
a723 1
	  remove_inferior (&all_lwps, &event_child->head);
d726 1
a726 14

	  if (!non_stop)
	    {
	      current_inferior = (struct thread_info *) all_threads.head;
	      if (debug_threads)
		fprintf (stderr, "Current inferior is now %ld\n",
			 lwpid_of (get_thread_lwp (current_inferior)));
	    }
	  else
	    {
	      current_inferior = NULL;
	      if (debug_threads)
		fprintf (stderr, "Current inferior is now <NULL>\n");
	    }
d730 2
a731 2
	  if (requested_child != NULL)
	    return 0;
d734 1
a734 1
	  return -1;
d737 2
a738 2
      if (WIFSTOPPED (*wstat)
	  && WSTOPSIG (*wstat) == SIGSTOP
d744 3
a746 3
	  linux_resume_one_lwp (&event_child->head,
				event_child->stepping, 0, NULL);
	  return -1;
d749 2
a750 2
      if (WIFSTOPPED (*wstat) && WSTOPSIG (*wstat) == SIGTRAP
	  && *wstat >> 16 != 0)
d752 2
a753 2
	  if (handle_extended_wait (event_child, *wstat))
	    return -1;
d765 1
a765 1
      if (WIFSTOPPED (*wstat)
d769 2
a770 3
	      (current_process ()->private->thread_db_active
	       && (WSTOPSIG (*wstat) == __SIGRTMIN
		   || WSTOPSIG (*wstat) == __SIGRTMIN + 1))
d773 2
a774 2
	      (pass_signals[target_signal_from_host (WSTOPSIG (*wstat))]
	       && (WSTOPSIG (*wstat) != SIGSTOP || !stopping_threads))))
d780 1
a780 1
		     WSTOPSIG (*wstat), ptid_get_lwp (event_child->head.id));
d782 1
a782 1
	  if (ptrace (PTRACE_GETSIGINFO, ptid_get_lwp (event_child->head.id), 0, &info) == 0)
d786 4
a789 5

	  linux_resume_one_lwp (&event_child->head,
				event_child->stepping,
				WSTOPSIG (*wstat), info_p);
	  return -1;
d794 2
a795 2
      if (!WIFSTOPPED (*wstat) || WSTOPSIG (*wstat) != SIGTRAP)
	return 0;
d800 1
a800 1
	return 0;
d805 1
a805 1
	 Notice that we will resume the lwp after hitting
d816 2
a817 2
	  linux_resume_one_lwp (&event_child->head, 0, 0, NULL);
	  return -1;
d850 1
a850 6
	     lwp.  */

	  /* NOTE: we're lifting breakpoints in non-stop mode.  This
	     is currently only used for thread event breakpoints, so
	     it isn't that bad as long as we have PTRACE_EVENT_CLONE
	     events.  */
d853 1
a853 1
	    linux_resume_one_lwp (&event_child->head, 0, 0, NULL);
d858 1
a858 1
	      linux_resume_one_lwp (&event_child->head, 1, 0, NULL);
d864 1
a864 1
	      linux_resume_one_lwp (&event_child->head, 0, 0, NULL);
d867 1
a867 1
	  return -1;
d885 1
a885 1
	  return 0;
d889 1
a889 1
	 Check if it is a breakpoint, and if so mark the lwp information
d902 1
a902 1
      return 0;
d911 2
a912 157
static ptid_t
linux_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus, int target_options)
{
  int w;
  struct thread_info *thread = NULL;
  struct lwp_info *lwp = NULL;
  int options;

  /* Translate generic target options into linux options.  */
  options = __WALL;
  if (target_options & TARGET_WNOHANG)
    options |= WNOHANG;

  ourstatus->kind = TARGET_WAITKIND_IGNORE;

  /* If we were only supposed to resume one thread, only wait for
     that thread - if it's still alive.  If it died, however - which
     can happen if we're coming from the thread death case below -
     then we need to make sure we restart the other threads.  We could
     pick a thread at random or restart all; restarting all is less
     arbitrary.  */
  /* TODO: Check if the incoming PTID is requesting an event for an
     lwp of another process?  */
  /* Don't do this in non-stop.  */
  if (!non_stop
      && !ptid_equal (cont_thread, null_ptid)
      && !ptid_equal (cont_thread, minus_one_ptid))
    {
      thread = (struct thread_info *) find_inferior_id (&all_threads,
							cont_thread);

      /* No stepping, no signal - unless one is pending already, of course.  */
      if (thread == NULL)
	{
	  struct thread_resume resume_info;
	  resume_info.thread = minus_one_ptid;
	  resume_info.kind = rk_continue;
	  resume_info.sig = 0;
	  linux_resume (&resume_info, 1);
	}
      else
	ptid = cont_thread;
    }

  if (linux_wait_for_event (ptid, &w, options) != 0)
    return minus_one_ptid;

  if (!non_stop)
    stop_all_lwps ();

  if (must_set_ptrace_flags)
    {
      linux_enable_event_reporting (inferior_lwpid);
      must_set_ptrace_flags = 0;
    }

  /* If we are waiting for a particular child, and it exited,
     linux_wait_for_event will return its exit status.  Similarly if
     the last child exited.  If this is not the last child, however,
     do not report it as exited until there is a 'thread exited' response
     available in the remote protocol.  Instead, just wait for another event.
     This should be safe, because if the thread crashed we will already
     have reported the termination signal to GDB; that should stop any
     in-progress stepping operations, etc.

     Report the exit status of the last thread to exit.  This matches
     LinuxThreads' behavior.  */

  lwp = get_thread_lwp (current_inferior);

  /* Now that we've selected our final event LWP, cancel any
     breakpoints in other LWPs that have hit a GDB breakpoint.  See
     the comment in cancel_breakpoints_callback to find out why.  */
  if (!non_stop)
    find_inferior (&all_lwps, cancel_breakpoints_callback, lwp);

  if (is_last_thread_of_process (current_inferior))
    {
      if (WIFEXITED (w) || WIFSIGNALED (w))
	{
	  struct process_info *process;
	  int pid;

	  pid = pid_of (lwp);

	  process = (struct process_info *)
	    find_inferior_id (&all_processes, pid_to_ptid (pid));

	  remove_inferior (&all_lwps, &lwp->head);
	  remove_thread (current_inferior);
	  remove_inferior (&all_processes, &process->head);

	  current_inferior = NULL;

	  if (WIFEXITED (w))
	    {
	      ourstatus->kind = TARGET_WAITKIND_EXITED;
	      ourstatus->value.integer = WEXITSTATUS (w);

	      if (debug_threads)
		fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));

	      return pid_to_ptid (pid);
	    }
	  else
	    {
	      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
	      ourstatus->value.sig = target_signal_from_host (WTERMSIG (w));

	      if (debug_threads)
		fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));

	      return pid_to_ptid (pid);
	    }
	}
    }
  else
    {
      if (!WIFSTOPPED (w))
	return lwp->head.id;
    }

  if (lwp->waitstatus.kind != TARGET_WAITKIND_IGNORE)
    {
      *ourstatus = lwp->waitstatus;
      lwp->waitstatus.kind = TARGET_WAITKIND_IGNORE;
    }
  else
    {
      ourstatus->kind = TARGET_WAITKIND_STOPPED;
      ourstatus->value.sig = target_signal_from_host (WSTOPSIG (w));
    }

  if (debug_threads)
    fprintf (stderr, "linux_wait ret = %s, %d, %d\n",
	     target_pid_to_str (lwp->head.id),
	     ourstatus->kind,
	     ourstatus->value.sig);

  return lwp->head.id;
}

/* Get rid of any pending event in the pipe.  */
static void
async_file_flush (void)
{
  int ret;
  char buf;

  do
    ret = read (linux_event_pipe[0], &buf, 1);
  while (ret == 0 || (ret == -1 && errno == EINTR));
}

/* Put something in the pipe, so the event loop wakes up.  */
static void
async_file_mark (void)
d914 14
a927 1
  int ret;
d929 9
a937 1
  async_file_flush ();
d939 2
a940 4
  do
    ret = write (linux_event_pipe[1], "+", 1);
  while (ret == 0 || (ret == -1 && errno == EINTR));
}
d942 5
a946 5
/* */
static ptid_t
linux_wait (ptid_t ptid, struct target_waitstatus *ourstatus, int target_options)
{
  ptid_t event_ptid;
d948 8
a955 2
  if (debug_threads)
    fprintf (stderr, "linux_wait: [%s]\n", target_pid_to_str (ptid));
d957 2
a958 5
  /* Flush the async file first.  We can't do it below, because that
     would be racy.  A SIGCHLD may arrive any time after we get out of
     my_waitpid, which marks the async file.  */
  if (target_is_async_p ())
    async_file_flush ();
d960 1
a960 1
  do
d962 20
a981 8
      event_ptid = linux_wait_1 (ptid, ourstatus, target_options);
    } while ((target_options & TARGET_WNOHANG) == 0
	     && ourstatus->kind == TARGET_WAITKIND_IGNORE);

  /* If we requested any event, and something came out, assume there
     may be more.  If we requested a specific lwp or process, also
     assume there may be more.  */
  if (target_is_async_p ())
d983 2
a984 3
      if (!ptid_equal (ptid, minus_one_ptid)
	  || ourstatus->kind != TARGET_WAITKIND_IGNORE)
	async_file_mark ();
d987 2
a988 1
  return event_ptid;
d1018 1
a1018 2
  int lwpid;
  struct lwp_info *lwp;
d1020 1
a1020 3
  lwp = (struct lwp_info *) entry;

  if (lwp->stopped)
d1023 1
a1023 3
  lwpid = lwpid_of (lwp);

  /* If we already have a pending stop signal for this lwp, don't
d1025 1
a1025 1
  if (lwp->stop_expected)
d1028 2
a1029 2
	fprintf (stderr, "Have pending sigstop for lwp %d\n",
		 lwpid);
d1034 1
a1034 1
      lwp->stop_expected = 0;
d1039 1
a1039 1
    fprintf (stderr, "Sending sigstop to lwp %d\n", lwpid);
d1041 1
a1041 1
  kill_lwp (lwpid, SIGSTOP);
d1047 2
a1048 2
  struct lwp_info *lwp = (struct lwp_info *) entry;
  struct thread_info *saved_inferior;
d1050 1
a1050 2
  ptid_t saved_tid;
  ptid_t ptid;
d1052 1
a1052 1
  if (lwp->stopped)
d1057 3
a1059 6

  ptid = lwp->head.id;

  stopping_threads = 1;
  linux_wait_for_lwp (ptid, &wstat, __WALL);
  stopping_threads = 0;
d1062 1
a1062 1
     and record the pending SIGSTOP.  If the lwp exited, just
d1069 4
a1072 4
		 lwpid_of (lwp), wstat);
      lwp->status_pending_p = 1;
      lwp->status_pending = wstat;
      lwp->stop_expected = 1;
a1073 5
  else if (!WIFSTOPPED (wstat))
    {
      if (debug_threads)
	fprintf (stderr, "Process %ld exited while stopping LWPs\n",
		 ptid_get_lwp (lwp->head.id));
d1075 1
a1075 17
      /* Leave this status pending for the next time we're able to
	 report it.  In the mean time, we'll report this lwp as
	 dead to GDB, so GDB doesn't try to read registers and
	 memory from it.  */
      lwp->dead = 1;
      lwp->status_pending_p = 1;
      lwp->status_pending = wstat;
      lwp->stopped = 1; /* prevent trying to stop it again.  */
      lwp->stop_expected = 0; /* No stop is expected, the lwp is
				 dead.  */
    }

  if (non_stop)
    /* We can't change the current inferior behind GDB's back,
       otherwise, a subsequent command may apply to the wrong process.
       Actually, we have to take care of this in all-stop +
       multi-process too.  FIXME.  */
d1079 2
a1080 6
      if (linux_thread_alive (saved_tid))
	current_inferior = saved_inferior;
      else
	{
	  if (debug_threads)
	    fprintf (stderr, "Previously current thread died.\n");
d1082 2
a1083 3
	  /* Set a valid thread as current.  */
	  set_desired_inferior (0);
	}
d1088 1
a1088 1
stop_all_lwps (void)
d1090 4
a1093 2
  for_each_inferior (&all_lwps, send_sigstop);
  for_each_inferior (&all_lwps, wait_for_sigstop);
d1096 1
a1096 1
/* Resume execution of the inferior lwp.
d1101 2
a1102 2
linux_resume_one_lwp (struct inferior_list_entry *entry,
		      int step, int signal, siginfo_t *info)
d1104 1
a1104 1
  struct lwp_info *lwp = (struct lwp_info *) entry;
d1107 1
a1107 1
  if (lwp->stopped == 0)
d1114 2
a1115 2
      && (lwp->status_pending_p || lwp->pending_signals != NULL
	  || lwp->bp_reinsert != 0))
d1119 1
a1119 1
      p_sig->prev = lwp->pending_signals;
d1125 1
a1125 1
      lwp->pending_signals = p_sig;
d1128 1
a1128 1
  if (lwp->status_pending_p && !check_removed_breakpoint (lwp))
d1132 1
a1132 1
  current_inferior = get_lwp_thread (lwp);
d1135 1
a1135 1
    fprintf (stderr, "Resuming lwp %ld (%s, signal %d, stop %s)\n", inferior_lwpid,
d1137 1
a1137 1
	     lwp->stop_expected ? "expected" : "not expected");
d1146 1
a1146 1
     uninserted (see comment in linux_wait_for_lwp) but not enough for
d1149 1
a1149 1
  if (lwp->bp_reinsert != 0)
d1152 1
a1152 1
	fprintf (stderr, "  pending reinsert at %08lx", (long)lwp->bp_reinsert);
d1161 1
a1161 1
  check_removed_breakpoint (lwp);
d1171 1
a1171 1
  if (lwp->pending_signals != NULL && lwp->bp_reinsert == 0)
d1175 1
a1175 1
      p_sig = &lwp->pending_signals;
d1181 1
a1181 1
	ptrace (PTRACE_SETSIGINFO, ptid_get_lwp (lwp->head.id), 0, &(*p_sig)->info);
d1188 1
a1188 1
			   get_lwp_thread (lwp));
d1190 3
a1192 3
  lwp->stopped = 0;
  lwp->stepping = step;
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, lwpid_of (lwp), 0, signal);
d1211 1
a1211 5
struct resume_info
{
  struct thread_resume *request;
  size_t n;
};
d1213 2
a1214 2
/* This function is called once per thread.  We look up the thread in
   RESUME_INFO, and mark the thread with a pointer to the appropriate
d1220 2
a1221 2
static int
linux_set_resume_request (struct inferior_list_entry *entry, void *arg)
d1223 1
a1223 1
  struct lwp_info *lwp;
a1225 1
  struct resume_info *resume_info;
d1228 1
a1228 17
  lwp = get_thread_lwp (thread);
  resume_info = arg;

  for (ndx = 0; ndx < resume_info->n; ndx++)
    {
      ptid_t ptid = resume_info->request[ndx].thread;
      if (ptid_equal (ptid, minus_one_ptid)
	  || ptid_equal (ptid, entry->id)
	  || (ptid_is_pid (ptid)
	      && (ptid_get_pid (ptid) == pid_of (lwp)))
	  || (ptid_get_lwp (ptid) == -1
	      && (ptid_get_pid (ptid) == pid_of (lwp))))
	{
	  lwp->resume = &resume_info->request[ndx];
	  return 0;
	}
    }
d1230 3
a1232 2
  /* Don't touch.  */
  lwp->resume = NULL;
d1234 1
a1234 1
  return 0;
d1237 5
a1241 5
/* Set *FLAG_P if this lwp has an interesting status pending.  */
static int
resume_status_pending_p (struct inferior_list_entry *entry, void *flag_p)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
d1243 2
a1244 38
  /* LWPs which will not be resumed are not interesting, because
     we might not wait for them next time through linux_wait.  */
  if (lwp->resume == NULL)
    return 0;

  if (lwp->dead)
    {
      /* If this thread is known to be dead, then the whole process it
	 belonged to has exited.  Report it.  */

      /* TODO: See if the dead flag is really needed, or the
	 pending_status is enough.  */
      if (!lwp->status_pending_p)
	warning ("dead thread without a pending status?");

      * (int *) flag_p = 1;
      return 0;
    }

  /* If this thread has a removed breakpoint, we won't have any
     events to report later, so check now.  check_removed_breakpoint
     may clear status_pending_p.  We avoid calling check_removed_breakpoint
     for any thread that we are not otherwise going to resume - this
     lets us preserve stopped status when two threads hit a breakpoint.
     GDB removes the breakpoint to single-step a particular thread
     past it, then re-inserts it and resumes all threads.  We want
     to report the second thread without resuming it in the interim.  */
  if (lwp->status_pending_p && !lwp->suspended)
    check_removed_breakpoint (lwp);

  if (lwp->status_pending_p)
    * (int *) flag_p = 1;

  return 0;
}

static int
cancel_breakpoint (struct lwp_info *lwp)
d1246 3
a1248 21
  /* Arrange for a breakpoint to be hit again later.  We don't keep
     the SIGTRAP status and don't forward the SIGTRAP signal to the
     thread.  Eventually we will resume this thread, and this
     breakpoint will trap again.

     If we do not do this, then we run the risk that the user will
     delete or disable the breakpoint, but the thread will have
     already tripped on it.  */

  if (lwp->stopped
      && !lwp->dead
      && !lwp->stepping
      && ((lwp->status_pending_p
	   && WIFSTOPPED (lwp->status_pending)
	   && WSTOPSIG (lwp->status_pending) == SIGTRAP)
	  || (!lwp->status_pending_p
	      && WIFSTOPPED (lwp->last_status)
	      && WSTOPSIG (lwp->last_status) == SIGTRAP)))
    {
      CORE_ADDR stop_pc;
      struct thread_info *saved_inferior;
d1250 2
a1251 2
      /* If there's a breakpoint here, adjust the PC, so the
	 breakpoint is hit again when the thread is resumed.  */
d1253 2
a1254 3
      if (debug_threads)
	fprintf (stderr, "Checking for breakpoint in lwp %ld.\n",
		 lwpid_of (lwp));
d1256 4
a1259 46
      saved_inferior = current_inferior;
      current_inferior = get_lwp_thread (lwp);

      stop_pc = (*the_low_target.get_pc) ();
      stop_pc -= the_low_target.decr_pc_after_break;

      /* If there's a breakpoint there, back off the PC.  */
      if (breakpoint_at (stop_pc)
	  || (*the_low_target.breakpoint_at) (stop_pc))
	{
	  if (the_low_target.set_pc != NULL)
	    {
	      if (debug_threads)
		fprintf (stderr, "CB: breakpoint present, backing off PC.\n");
	      (*the_low_target.set_pc) (stop_pc);
	    }
	  else
	    {
	      if (debug_threads)
		fprintf (stderr, "CB: breakpoint present ignoring SIGTRAP.\n");
	    }

	  lwp->pending_is_breakpoint = 0;
	  lwp->status_pending_p = 0;
	  lwp->status_pending = 0;
	  lwp->last_status = W_STOPCODE (0);

	  current_inferior = saved_inferior;
	  return 1;
	}

      current_inferior = saved_inferior;
    }

  return 0;
}

static int
cancel_breakpoints_callback (struct inferior_list_entry *entry, void *data)
{
  struct lwp_info *lp = (struct lwp_info *) entry;
  struct lwp_info *event_lp = data;

  /* Leave the LWP that has been elected to receive a SIGTRAP alone.  */
  if (lp == event_lp)
    return 0;
d1261 1
a1261 10
  /* If a LWP other than the LWP that we're reporting an event for has
     hit a GDB breakpoint (as opposed to some random trap signal),
     then just arrange for it to hit it again later.  We don't keep
     the SIGTRAP status and don't forward the SIGTRAP signal to the
     LWP.  We will handle the current event, eventually we will resume
     all LWPs, and this one will get its breakpoint trap again.

     If we do not do this, then we run the risk that the user will
     delete or disable the breakpoint, but the LWP will have already
     tripped on it.  */
d1263 1
a1263 2
  cancel_breakpoint (lp);
  return 0;
d1268 4
a1271 1
   stopped; and what signal, if any, it should be sent.
d1273 2
a1274 11
   For threads which we aren't explicitly told otherwise, we preserve
   the stepping flag; this is used for stepping over gdbserver-placed
   breakpoints.

   If pending_flags was set in any thread, we queue any needed
   signals, since we won't actually resume.  We already have a pending
   event to report, so we don't need to preserve any step requests;
   they should be re-issued if necessary.  */

static int
linux_resume_one_thread (struct inferior_list_entry *entry, void *arg)
d1276 1
a1276 1
  struct lwp_info *lwp;
a1277 2
  int step;
  int pending_flag = * (int *) arg;
d1280 1
a1280 1
  lwp = get_thread_lwp (thread);
d1282 2
a1283 2
  if (lwp->resume == NULL)
    return 0;
d1285 2
a1286 1
  if (lwp->resume->kind == rk_stop)
d1288 5
a1292 34
      if (debug_threads)
	fprintf (stderr, "suspending thread %s\n",
		 target_pid_to_str (entry->id));

      /* Do this before waiting for sigstop, as the thread may
	 die.  */
      /* TODO: how do we report that happening to GDB?  GDB and the
	 user can get very confused if a thread exits without GDB
	 being aware of it.  E.g, user tries to interrupts thread, but
	 GDB doesn't reply back, The simplest seem to be to implement
	 a thread exit stop reply.  Note that returning a generic
	 error is not an option if we're handling a vCont.  The reply
	 has already been sent at this point, and, the same vCont can
	 hold multiple resumptions -- to which would the error
	 apply?  */
      lwp->resume = NULL;

      /* To simplify things, we're waiting for the lwp to stop here,
	 and pushing the stop reply to gdbserver's common code.  An
	 alternative, would be to defer to linux_wait to do the wait,
	 and notice that an lwp with the "suspended" flag but
	 "!stopped", should leave any status pending, and report a
	 sig0 stop status.  */

      /* Do we have to distinguish internal stops from external stops,
	 due to the support for gdbserver breakpoints?  If so, then
	 thread_info needs to gain a "running" property.  */
      if (!lwp->stopped)
	{
	  ptid_t ptid = entry->id;

	  if (debug_threads)
	    fprintf (stderr, "running -> suspending %s\n",
		     target_pid_to_str (entry->id));
d1294 7
a1300 62
	  lwp->suspended = 1;
	  send_sigstop (&lwp->head);
	  wait_for_sigstop (&lwp->head);
	  if (!lwp->dead)
	    {
	      struct target_waitstatus status;
	      status.kind = TARGET_WAITKIND_STOPPED;

	      /* Cancel internal breakpoints, otherwise, the user will
		 see a possibly invalid PC on decr_pc_after_break
		 archs, because GDB can't tell there's a breakpoint
		 there.  As long as we do it, might as well cancel GDB
		 breakpoints too, although GDB will also adjust the PC
		 if we don't in that case.  */

	      /* Cancel breakpoints, but leave out finished steps and
		 watchpoint hits.  */
	      if (cancel_breakpoint (lwp))
		/* The LWP hit a breakpoint while we tried to stop it,
		   and we backed off the PC.  Report a SIG0.  */
		status.value.sig = 0;
	      else if (lwp->stopped
		       && lwp->stepping
		       && ((!lwp->status_pending_p
			    && WIFSTOPPED (lwp->last_status)
			    && WSTOPSIG (lwp->last_status) == SIGTRAP)
			   || (lwp->status_pending_p
			       && WIFSTOPPED (lwp->status_pending)
			       && WSTOPSIG (lwp->status_pending) == SIGTRAP)))
		{
		  /* The LWP finished a hardware single-step; report
		     the SIGTRAP to GDB.  */
		  lwp->pending_is_breakpoint = 0;
		  lwp->status_pending_p = 0;
		  lwp->status_pending = 0;
		  lwp->last_status = W_STOPCODE (SIGTRAP);
		  /* Report the finished single-step.  When using
		     displaced stepping, GDB needs this to be able to
		     fixup the PC.  */
		  status.value.sig = TARGET_SIGNAL_TRAP;
		}
	      else
		/* Leave other signals pending.  */
		status.value.sig = 0;

	      /* Pass the stop reply back to GDB.  */
	      push_event (ptid, &status);
	    }
	  else
	    ;
	}
      else
	{
	  if (debug_threads)
	    {
	      if (lwp->suspended)
		fprintf (stderr, "already stopped/suspended %s\n",
			 target_pid_to_str (entry->id));
	      else
		fprintf (stderr, "already stopped/not suspended %s\n",
			 target_pid_to_str (entry->id));
	    }
d1302 1
a1302 9
	  /* Make sure we leave the LWP suspended, so we don't try to
	     resume it without GDB telling us to.  FIXME: The LWP may
	     have been stopped in an internal event that was not meant
	     to be notified back to GDB (e.g., gdbserver breakpoint),
	     so we should be reporting a stop event in that case
	     too.  */
	  lwp->suspended = 1;
	}
      return 0;
a1303 2
  else
    lwp->suspended = 0;
d1305 2
a1306 7
  /* If this thread which is about to be resumed has a pending status,
     then don't resume any threads - we can just report the pending
     status.  Make sure to queue any signals that would otherwise be
     sent.  In all-stop mode, we do this decision based on if *any*
     thread has a pending status.  */
  if (non_stop)
    resume_status_pending_p (&lwp->head, &pending_flag);
d1308 5
a1312 5
  if (!pending_flag)
    {
      if (debug_threads)
	fprintf (stderr, "resuming thread %s\n",
		 target_pid_to_str (entry->id));
d1314 4
a1317 4
      if (ptid_equal (lwp->resume->thread, minus_one_ptid))
	step = lwp->stepping || (lwp->resume->kind == rk_step);
      else
	step = (lwp->resume->kind == rk_step);
d1319 10
a1328 7
      linux_resume_one_lwp (&lwp->head, step, lwp->resume->sig, NULL);
    }
  else
    {
      if (debug_threads)
	fprintf (stderr, "leaving thread %s stopped\n",
		 target_pid_to_str (entry->id));
d1330 2
a1331 16
      /* If we have a new signal, enqueue the signal.  */
      if (lwp->resume->sig != 0)
	{
	  struct pending_signals *p_sig;
	  p_sig = malloc (sizeof (*p_sig));
	  p_sig->prev = lwp->pending_signals;
	  p_sig->signal = lwp->resume->sig;
	  memset (&p_sig->info, 0, sizeof (siginfo_t));

	  /* If this is the same signal we were previously stopped by,
	     make sure to queue its siginfo.  We can ignore the return
	     value of ptrace; if it fails, we'll skip
	     PTRACE_SETSIGINFO.  */
	  if (WIFSTOPPED (lwp->last_status)
	      && WSTOPSIG (lwp->last_status) == lwp->resume->sig)
	    ptrace (PTRACE_GETSIGINFO, ptid_get_lwp (lwp->head.id), 0, &p_sig->info);
a1332 5
	  lwp->pending_signals = p_sig;
	}
    }

  lwp->resume = NULL;
d1337 1
a1337 1
linux_resume (struct thread_resume *resume_info, size_t n)
a1339 1
  struct resume_info info = { resume_info, n };
d1341 2
a1342 13
  if (debug_threads)
    {
      int idx;
      fprintf (stderr, "linux_resume\n");
      for (idx = 0; idx < n; idx++)
	{
	  fprintf (stderr, " thread(%s), kind(%d), sig(%d)\n",
		   target_pid_to_str (resume_info[idx].thread),
		   resume_info[idx].kind,
		   resume_info[idx].sig);
	  idx++;
	}
    }
d1344 1
a1344 1
  find_inferior (&all_threads, linux_set_resume_request, &info);
a1349 3
  /* This is only used in all-stop mode however.  In non-stop mode,
     decide to leave pending based on the thread we're resuming itself
     having a pending status already or not.  */
d1351 1
a1351 2
  if (!non_stop)
    find_inferior (&all_lwps, resume_status_pending_p, &pending_flag);
d1361 4
a1364 1
  find_inferior (&all_threads, linux_resume_one_thread, &pending_flag);
d1405 1
a1405 1
	ptrace (PTRACE_PEEKUSER, inferior_lwpid, (PTRACE_ARG3_TYPE) regaddr, 0);
d1427 1
a1427 1
/* Fetch all registers, or just one, from the child lwp.  */
d1473 1
a1473 1
	  ptrace (PTRACE_POKEUSER, inferior_lwpid, (PTRACE_ARG3_TYPE) regaddr,
d1477 1
a1477 1
	      /* At this point, ESRCH should mean the lwp is already gone,
d1479 1
a1479 1
		 See also the related comment in linux_resume_one_lwp.  */
d1526 5
a1530 1
      res = ptrace (regset->get_request, inferior_lwpid, 0, buf);
d1536 1
a1536 1
		 this lwp.  */
d1544 1
a1544 1
		       inferior_lwpid);
d1583 5
a1587 1
      res = ptrace (regset->get_request, inferior_lwpid, 0, buf);
d1595 5
a1599 1
	  res = ptrace (regset->set_request, inferior_lwpid, 0, buf);
d1607 1
a1607 1
		 this lwp.  */
d1613 1
a1613 1
	      /* At this point, ESRCH should mean the lwp is already gone,
d1615 1
a1615 2
		 See also the related comment in linux_resume_one_lwp.  */
	      free (buf);
d1687 1
a1687 1
      sprintf (filename, "/proc/%ld/mem", inferior_lwpid);
d1715 1
a1715 1
      buffer[i] = ptrace (PTRACE_PEEKTEXT, inferior_lwpid, (PTRACE_ARG3_TYPE) addr, 0);
d1750 1
a1750 1
  buffer[0] = ptrace (PTRACE_PEEKTEXT, inferior_lwpid,
d1756 1
a1756 1
	= ptrace (PTRACE_PEEKTEXT, inferior_lwpid,
d1771 1
a1771 1
      ptrace (PTRACE_POKETEXT, inferior_lwpid, (PTRACE_ARG3_TYPE) addr, buffer[i]);
d1779 2
d1806 15
d1917 1
a1917 5
  /* It would probably be cleaner now to move this whole function to
     thread-db.c.  */

  struct process_info *proc = current_process ();
  if (proc->private->thread_db_active)
d1920 1
a1920 2
  proc->private->thread_db_active
    = thread_db_init (!linux_supports_tracefork_flag);
d1929 1
a1929 2
  if (!ptid_equal (cont_thread, null_ptid)
      && !ptid_equal (cont_thread, minus_one_ptid))
d1931 1
a1931 2
      struct lwp_info *lwp;
      int lwpid;
d1933 2
a1934 3
      lwp = get_thread_lwp (current_inferior);
      lwpid = ptid_get_lwp (lwp->head.id);
      kill_lwp (lwpid, SIGINT);
d1949 1
a1949 1
  snprintf (filename, sizeof filename, "/proc/%ld/auxv", inferior_lwpid);
a2014 6
#if defined(__arm__)
#ifndef PTRACE_GETPROCMAP
#define PTRACE_GETPROCMAP 27
#endif
#endif

d2023 1
a2023 1
  int pid = pid_of (get_thread_lwp (current_inferior));
a2047 12
#if defined(PTRACE_GETPROCMAP)
  unsigned long data[6];
  int pid = pid_of (get_thread_lwp (current_inferior));

  if (ptrace (PTRACE_GETPROCMAP, pid, NULL, data) == 0)
    {
      /* GETPROCMAP returns text_start, text_end, data_start.  See above.  */
      *text_p = data[0];
      *data_p = data[2] - (data[1] - data[0]);
      return 1;
    }
#endif
a2051 73
/* SIGCHLD handler that serves two purposes: In non-stop/async mode,
   so we notice when any child changes state; as the handler for the
   sigsuspend in my_waitpid.  */

static void
sigchld_handler (int signo)
{
  int old_errno = errno;

  if (debug_threads)
    /* fprintf is not an async-signal-safe function, so call write
       directly.  */
    write (2, "sigchld_handler\n",
	   strlen ("sigchld_handler\n"));

  if (target_is_async_p ())
    async_file_mark (); /* trigger a linux_wait */

  errno = old_errno;
}

static int
linux_async (int enable)
{
  int previous = (linux_event_pipe[0] != -1);

  if (previous != enable)
    {
      sigset_t mask;
      sigemptyset (&mask);
      sigaddset (&mask, SIGCHLD);

      sigprocmask (SIG_BLOCK, &mask, NULL);

      if (enable)
	{
	  if (pipe (linux_event_pipe) == -1)
	    internal_error ("creating event pipe failed.");

	  fcntl (linux_event_pipe[0], F_SETFL, O_NONBLOCK);
	  fcntl (linux_event_pipe[1], F_SETFL, O_NONBLOCK);

	  /* Register the event loop handler.  */
	  add_file_handler (linux_event_pipe[0],
			    handle_target_event, NULL);

	  /* Always trigger a linux_wait.  */
	  async_file_mark ();
	}
      else
	{
	  delete_file_handler (linux_event_pipe[0]);

	  close (linux_event_pipe[0]);
	  close (linux_event_pipe[1]);
	  linux_event_pipe[0] = -1;
	  linux_event_pipe[1] = -1;
	}

      sigprocmask (SIG_UNBLOCK, &mask, NULL);
    }

  return previous;
}

static int
linux_start_non_stop (int nonstop)
{
  /* Register or unregister from event-loop accordingly.  */
  linux_async (nonstop);
  return 0;
}

a2083 3
  linux_pid_to_exec_file,
  linux_async,
  linux_start_non_stop,
d2097 1
a2097 2
  struct sigaction sigchld_action;

a2107 5

  sigchld_action.sa_handler = sigchld_handler;
  sigemptyset (&sigchld_action.sa_mask);
  sigchld_action.sa_flags = SA_RESTART;
  sigaction (SIGCHLD, &sigchld_action, NULL);
@


1.80
log
@	* linux-low.c (linux_resume_one_process): Ignore ESRCH.
	(usr_store_inferior_registers): Likewise.
	(regsets_store_inferior_registers): Likewise.
@
text
@d1526 1
d1528 3
d1583 1
d1585 3
d1595 5
a1599 1
	  res = ptrace (regset->set_request, inferior_pid, 0, buf);
@


1.79
log
@	* linux-low.c (sys/dir.h, sys/user.h): Remove includes.
	(linux_write_memory): Remove declaration of errno.
@
text
@d1196 13
a1208 1
    perror_with_name ("ptrace");
d1477 6
d1599 7
@


1.78
log
@	* linux-low.c (handle_extended_wait): Do not use "status"
	variable uninitialized.
@
text
@a25 1
#include <sys/dir.h>
a26 1
#include <sys/user.h>
a1704 1
  extern int errno;
@


1.77
log
@2008-04-17  Daniel Jacobowitz  <dan@@codesourcery.com>

	* linux-low.c (disabled_regsets, num_regsets): New.
	(use_regsets_p): Delete.
	(linux_wait_for_process): Clear disabled_regsets.
	(regsets_fetch_inferior_registers): Check and set it.
	(regsets_store_inferior_registers): Likewise.
	(linux_fetch_registers, linux_store_registers): Do not use
	use_regsets_p.
	(initialize_low): Allocate disabled_regsets.
@
text
@d152 1
a152 1
      int ret, status;
@


1.76
log
@ChangeLog:

	* features/Makefile (%.dat): Emit xmltarget statement.

	* regformats/regdat.sh: Support xmltarget and xmlarch statments.
	Generate code to set gdbserver_xmltarget in init_registers_${name}.

	* regformats/arm-with-iwmmxt.dat: Regenerate.
	* regformats/mips64-linux.dat: Regenerate.
	* regformats/mips-linux.dat: Regenerate.
	* regformats/rs6000/powerpc-32.dat: Regenerate.
	* regformats/rs6000/powerpc-64.dat: Regenerate.
	* regformats/rs6000/powerpc-e500.dat: Regenerate.

	* regformats/reg-arm.dat: Add xmlarch statement.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-i386-linux.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-spu.dat: Likewise.

gdbserver/ChangeLog:

	* regcache.h (gdbserver_xmltarget): Add extern declaration.
	* server.c (gdbserver_xmltarget): Define.
	(get_features_xml): Use it to replace "target.xml" and arch_string.

	* configure.srv: Remove srv_xmltarget.  Add XML files that were
	mentioned there to srv_xmlfiles instead.  Remove conditional tests
	on gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe; set
	srv_xmlfiles and srv_regobj to include all possible choices.
	* configure.ac (srv_xmltarget): Remove.
	(srv_xmlfiles): Do not add "target.xml".
	(gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe): Remove
	checks for supplementary target information.
	* configure: Regenerate.
	* Makefile.in (XML_TARGET): Remove.
	(target.xml): Remove rule.
	(clean): Do not clean up target.xml.
	(.PRECIOUS): Do not mention target.xml.

	* target.h (struct target_ops): Remove arch_string member.
	* linux-low.c (linux_arch_string): Remove.
	(linux_target_ops): Remove arch_string initializer.
	* linux-low.h (struct linux_target_ops): Remove arch_string member.
	* linux-i386-low.c (the_low_target): Remove arch_string initializer.
	* linux-x86-64-low.c (the_low_target): Remove arch_string initializer.
	* spu-low.c (spu_arch_string): Remove.
	(spu_target_ops): Remove arch_string initializer.
	* win32-low.c (win32_arch_string): Remove.
	(win32_target_ops): Remove arch_string initializer.
	* win32-low.h (struct win32_target_ops): Remove arch_string member.
	* win32-arm-low.c (the_low_target): Remove arch_string initializer.
	* win32-i368-low.c (the_low_target): Remove arch_string initializer.
@
text
@d134 2
a135 1
static int use_regsets_p = 1;
d635 3
d1503 1
a1503 1
      if (regset->size == 0)
d1515 4
a1518 12
	      /* If we get EIO on the first regset, do not try regsets again.
		 If we get EIO on a later regset, disable that regset.  */
	      if (regset == target_regsets)
		{
		  use_regsets_p = 0;
		  return -1;
		}
	      else
		{
		  regset->size = 0;
		  continue;
		}
d1552 1
a1552 1
      if (regset->size == 0)
d1578 4
a1581 12
	      /* If we get EIO on the first regset, do not try regsets again.
		 If we get EIO on a later regset, disable that regset.  */
	      if (regset == target_regsets)
		{
		  use_regsets_p = 0;
		  return -1;
		}
	      else
		{
		  regset->size = 0;
		  continue;
		}
d1607 2
a1608 5
  if (use_regsets_p)
    {
      if (regsets_fetch_inferior_registers () == 0)
	return;
    }
d1619 2
a1620 5
  if (use_regsets_p)
    {
      if (regsets_store_inferior_registers () == 0)
	return;
    }
d2069 5
@


1.75
log
@	* linux-low.h (struct linux_target_ops): Replace left_pad_xfer field
	by collect_ptrace_register and supply_ptrace_register hooks.
	* linux-low.c (fetch_register): Use supply_ptrace_register callback
	instead of checking for the_low_target.left_pad_xfer.
	(usr_store_inferior_registers): Use collect_ptrace_register callback
	instead of checking for the_low_target.left_pad_xfer.

	* linux-s390-low.c (s390_collect_ptrace_register): New function.
	(s390_supply_ptrace_register): Likewise.
	(s390_fill_gregset): Call s390_collect_ptrace_register.
	(the_low_target): Update.

	* linux-ppc64-low.c (ppc_collect_ptrace_register): New function.
	(ppc_supply_ptrace_register): Likewise.
	(the_low_target): Update.

	* linux-i386-low.c (the_low_target): Update.
	* linux-x86-64-low.c (the_low_target): Update.
@
text
@a2035 6
static const char *
linux_arch_string (void)
{
  return the_low_target.arch_string;
}

a2065 1
  linux_arch_string,
@


1.74
log
@	* configure.srv [s390x-*-linux*]: Set srv_regobj to include both
	reg-s390.o and reg-s390x.o.

	* linux-low.c (new_inferior): New global variable.
	(linux_create_inferior, linux_attach): Set it.
	(linux_wait_for_process): Call the_low_target.arch_setup after the
	target has stopped for the first time.
	(initialize_low): Do not call the_low_target.arch_setup.

	* linux-s390-low.c (s390_get_pc): Support bi-arch operation.
	(s390_set_pc): Likewise.
	(s390_arch_setup): New function.
	(the_low_target): Use s390_arch_setup as arch_setup routine.

	* regcache.c (realloc_register_cache): New function.
	(set_register_cache): Call it for each existing regcache.
@
text
@d1404 3
a1406 4
  if (the_low_target.left_pad_xfer
      && register_size (regno) < sizeof (PTRACE_XFER_TYPE))
    supply_register (regno, (buf + sizeof (PTRACE_XFER_TYPE)
			     - register_size (regno)));
d1450 3
a1452 4
      if (the_low_target.left_pad_xfer
	  && register_size (regno) < sizeof (PTRACE_XFER_TYPE))
	collect_register (regno, (buf + sizeof (PTRACE_XFER_TYPE)
				  - register_size (regno)));
d1455 1
@


1.73
log
@gdb/ChangeLog:

	* regformats/regdat.sh: Rename init_registers function in
	generated file to init_registers_${name}.

	* regformats/reg-crisv32.dat: Set "name" to crisv32.
	* regformats/reg-ppc64.dat: Set "name" to ppc64.
	* regformats/reg-s390x.dat: Set "name" to s390x.

gdbserver/ChangeLog:

	* server.h (init_registers): Remove prototype.

	* linux-low.h (struct linux_target_ops): Add arch_setup field.
	* linux-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* linux-arm-low.c (init_registers_arm): Add prototype.
	(init_registers_arm_with_iwmmxt): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-cris-low.c (init_registers_cris): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-crisv32-low.c (init_registers_crisv32): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-i386-low.c (init_registers_i386_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ia64-low.c (init_registers_ia64): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m32r-low.c (init_registers_m32r): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m68k-low.c (init_registers_m68k): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-mips-low.c (init_registers_mips_linux): Add prototype.
	(init_registers_mips64_linux): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc-low.c (init_registers_ppc): Add prototype.
	(init_registers_powerpc_32, init_registers_powerpc_e500): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc64-low.c (init_registers_ppc64): Add prototype.
	(init_registers_powerpc_64): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-s390-low.c (init_registers_s390): Add prototype.
	(init_registers_s390x): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-sh-low.c (init_registers_sh): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-x86-64-low.c (init_registers_x86_64_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-xtensa-low.c (init_registers_xtensa): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* win32-low.h (struct win32_target_ops): Add arch_setup field.
	* win32-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* win32-arm-low.c (init_registers_arm): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* win32-i386-low.c (init_registers_i386): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* spu-low.c (init_registers_spu): Add prototype.
	(initialize_low): Call initialie_registers_spu () instead of
	initialize_registers ().
@
text
@d110 5
d299 1
d359 2
d627 10
a2092 1
  the_low_target.arch_setup ();
@


1.72
log
@	* hostio.c: Don't include errno.h.
	(errno_to_fileio_errno): Move to hostio-errno.
	* hostio.c: (hostio_error): Remove the error parameter.  Defer the
	error number outputting to the target->hostio_last_error callback.
	(hostio_packet_error): Use FILEIO_EINVAL directly.
	(handle_open, handle_pread, hostio_error, handle_unlink): Update
	calls to hostio_error.
	* hostio-errno.c: New.
	* server.h (hostio_last_error_from_errno): Declare.
	* target.h (target_ops): Add hostio_last_error member.
	* linux-low.c (linux_target_op): Register hostio_last_error_from_errno
	as hostio_last_error handler.
	* spu-low.c (spu_target_ops): Likewise.
	* win32-low.c [_WIN32_WCE] (win32_error_to_fileio_error)
	(wince_hostio_last_error): New functions.
	(win32_target_ops) [_WIN32_WCE]: Register wince_hostio_last_error
	as hostio_last_error handler.
	(win32_target_ops) [!_WIN32_WCE]: Register
	hostio_last_error_from_errno as hostio_last_error handler.
	* Makefile.in (SFILES): Add hostio.c and hostio-errno.c.
	(hostio-errno.o): New rule.
	* configure.ac (GDBSERVER_DEPFILES): Add $srv_hostio_err_objs.
	* configure.srv (srv_hostio_err_objs): New variable.  Default to
	hostio-errno.o.
	(arm*-*-mingw32ce*): Set srv_hostio_err_objs to "".
	* configure: Regenerate.
@
text
@d2075 1
a2075 1
  init_registers ();
@


1.71
log
@	* linux-low.c (linux_attach_lwp): Do not _exit after errors.
	(linux_kill, linux_detach): Clean up the process list.
	* remote-utils.c (remote_open): Improve port number parsing.
	(putpkt_binary, input_interrupt): Only send interrupts if the target
	is running.
	* server.c (extended_protocol): Make static.
	(attached): Define earlier.
	(exit_requested, response_needed, program_argv): New variables.
	(target_running): New.
	(start_inferior): Clear attached here.
	(attach_inferior): Set attached here.
	(require_running): Define.
	(handle_query): Use require_running and target_running.  Implement
	"monitor exit".
	(handle_v_attach, handle_v_run): New.
	(handle_v_requests): Use require_running.  Handle vAttach and vRun.
	(gdbserver_usage): Update.
	(main): Redo argument parsing.  Handle --debug and --multi.  Handle
	--attach along with other options or after the port.  Save
	program_argv.  Support no initial program.  Resynchronize
	communication with GDB after an error.  Handle "monitor exit".
	Use require_running and target_running.  Always allow the extended
	protocol.  Do not error out for Hc0 or Hc-1.  Do not automatically
	restart in extended mode.
	* README: Refer to the GDB manual.  Update --attach usage.

	* remote.c (struct remote_state): Add cached_wait_status.
	(remote_exec_file): New variable.
	(PACKET_vAttach, PACKET_vRun): New constants.
	(extended_remote_restart): Do not query for status.
	(struct start_remote_args): New.
	(remote_start_remote): Take it as a second argument.  Check
	whether the target is running.  Issue an error for non-running
	non-extended targets.  Cache the wait status.  Set inferior_ptid
	here.
	(remote_open_1): Prompt to disconnect non-running targets.  Make
	sure the target is marked running.  Do not set inferior_ptid here.
	Update call to remote_start_remote.  Do not call remote_check_symbols
	if the target is not running.
	(remote_detach_1): Rename from remote_detach.  Take an EXTENDED
	argument.  Handle a non-running target.
	(remote_detach): Use it.
	(extended_remote_detach): New.
	(remote_disconnect): Fix typo.  Use remoute_mourn_1.
	(extended_remote_attach_1, extended_remote_attach)
	(extended_async_remote_attach): New.
	(remote_vcont_resume): Remove unused variable.
	(remote_wait, remote_async_wait): Use any cached wait status.
	(putpkt_binary, getpkt): Clear any cached wait status.
	(extended_remoute_mourn_1): New.
	(extended_remote_mourn): Use it.
	(extended_async_remote_mourn, extended_remote_run): New.
	(extended_remote_create_inferior_1): New.
	(extended_remote_create_inferior): Use it.
	(extended_remote_async_create_inferior): Likewise.
	(remote_xfer_partial): Skip for non-executing targets.
	(init_extended_remote_ops): Set to_detach and to_attach.
	(init_extended_async_remote_ops): Likewise.  Use
	extended_async_remote_mourn.
	(_initialize_remote): Register vAttach, vRun, and
	set remote exec-file.
	* NEWS: Mention vAttach, vRun, and gdbserver extended-remote support.

	* gdb.server/ext-attach.c, gdb.server/ext-attach.exp,
	gdb.server/ext-run.exp: New files.
	* lib/gdbserver-support.exp (gdbserver_download): New.
	(gdbserver_start): New.  Update gdbserver expected
	output.
	(gdbserver_spawn): Use them.
	(gdbserver_start_extended): New.

	* gdb.texinfo (Using the `gdbserver' Program): Add security
	warning.  Rearrange into subsections and subsubsections.  Document
	--multi and --debug.  Correct --with-sysroot typo.  Update --attach
	usage.  Make load reference clearer.  Document monitor exit.
	(Remote Configuration): Document set remote exec-file, attach-packet,
	and run-packet.
	(Packets): Document vAttach and vRun.
@
text
@d2056 2
@


1.70
log
@	Updated copyright notices for most files.
@
text
@d307 11
a317 1
      fprintf (stderr, "Cannot attach to process %ld: %s (%d)\n", pid,
a318 6
      fflush (stderr);

      /* If we fail to attach to an LWP, just return.  */
      if (all_threads.head == NULL)
	_exit (0177);
      return;
d403 4
d445 2
@


1.69
log
@	* linux-low.c (STACK_SIZE): Define.
	(linux_tracefork_child): Use it.  Use __clone2 on ia64.
	(linux_test_for_tracefork): Likewise.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
@


1.68
log
@	* linux-low.c (linux_wait_for_event): Update messages.  Do not
	reinsert auto-delete breakpoints.
	* mem-break.c (struct breakpoint): Change return type of handler to
	int.
	(set_breakpoint_at): Update handler type.
	(reinsert_breakpoint_handler): Return 1 instead of calling
	delete_breakpoint.
	(reinsert_breakpoint_by_bp): Check for the original breakpoint before
	setting a new one.
	(check_breakpoints): Delete auto-delete breakpoints and return 2.
	* mem-break.h (set_breakpoint_at): Update handler type.
	* thread-db.c (thread_db_create_event, thread_db_create_event): Update.
	* win32-low.c (auto_delete_breakpoint): New.
	(get_child_debug_event): Use it.
@
text
@d1746 2
d1753 7
a1759 1
  clone (linux_tracefork_grandchild, arg, CLONE_VM | SIGCHLD, NULL);
d1787 1
a1787 1
  char *stack = malloc (8192);
d1792 7
a1798 2
  child_pid = clone (linux_tracefork_child, stack + 2048,
		     CLONE_VM | SIGCHLD, stack + 6144);
@


1.67
log
@	* linux-low.c (linux_wait, linux_resume): Do not handle async I/O.
	* remote-utils.c (remote_open): Do not call disable_async_io.
	(block_async_io): Delete.
	(unblock_async_io): Make static.
	(initialize_async_io): New.
	* server.c (handle_v_cont): Handle async I/O here.
	(myresume): Likewise.  Move other common resume tasks here...
	(main): ... from here.  Call initialize_async_io.  Disable async
	I/O before the main loop.
	* server.h (initialize_async_io): Declare.
	(block_async_io, unblock_async_io): Delete prototypes.
	* spu-low.c (spu_resume, spu_wait): Do not handle async I/O here.
@
text
@d626 1
d790 1
a790 2
      if (debug_threads)
	fprintf (stderr, "Hit a (non-reinsert) breakpoint.\n");
d792 1
a792 1
      if (check_breakpoints (stop_pc) != 0)
d794 3
d803 1
a803 1
	  /* Now we need to put the breakpoint back.  We continue in the event
d821 4
a824 1
	  if (the_low_target.breakpoint_reinsert_addr == NULL)
d840 3
@


1.66
log
@	* linux-low.c: Include <sched.h>.
@
text
@a899 2
  enable_async_io ();
  unblock_async_io ();
a901 1
  disable_async_io ();
d1313 1
a1313 5
    {
      block_async_io ();
      enable_async_io ();
      for_each_inferior (&all_threads, linux_continue_one_thread);
    }
@


1.65
log
@	* linux-low.c (linux_tracefork_grandchild): New.
	(linux_tracefork_child): Use clone.
	(linux_test_for_tracefork): Use clone; allocate and free a stack.
@
text
@d37 1
@


1.64
log
@	* linux-low.c (handle_extended_wait): Handle unexpected signals.
@
text
@d1735 1
a1735 1
/* A helper function for linux_test_for_tracefork, called after fork ().  */
d1737 8
a1744 2
static void
linux_tracefork_child (void)
d1748 1
a1748 1
  fork ();
d1776 1
d1780 3
a1782 1
  child_pid = fork ();
d1784 1
a1784 4
    perror_with_name ("fork");

  if (child_pid == 0)
    linux_tracefork_child ();
d1849 2
@


1.63
log
@	* inferiors.c (change_inferior_id): Delete.
	(add_pid_to_list, pull_pid_from_list): New.
	* linux-low.c (PTRACE_SETOPTIONS, PTRACE_GETEVENTMSG)
	(PTRACE_O_TRACESYSGOOD, PTRACE_O_TRACEFORK, PTRACE_O_TRACEVFORK)
	(PTRACE_O_TRACECLONE, PTRACE_O_TRACEEXEC, PTRACE_O_TRACEVFORKDONE)
	(PTRACE_O_TRACEEXIT, PTRACE_EVENT_FORK, PTRACE_EVENT_VFORK)
	(PTRACE_EVENT_CLONE, PTRACE_EVENT_EXEC, PTRACE_EVENT_VFORK_DONE)
	(PTRACE_EVENT_EXIT, __WALL): Provide default definitions.
	(stopped_pids, thread_db_active, must_set_ptrace_flags): New variables.
	(using_threads): Always set to 1.
	(handle_extended_wait): New.
	(add_process): Do not set TID.
	(linux_create_inferior): Set must_set_ptrace_flags.
	(linux_attach_lwp): Remove TID argument.  Do not check using_threads.
	Use PTRACE_SETOPTIONS.  Call new_thread_notify.  Update all callers.
	(linux_thread_alive): Rename TID argument to LWPID.
	(linux_wait_for_process): Handle unknown processes.  Do not use TID.
	(linux_wait_for_event): Do not use TID or check using_threads.  Update
	call to dead_thread_notify.  Call handle_extended_wait.
	(linux_create_inferior): Use PTRACE_SETOPTIONS.
	(send_sigstop): Delete sigstop_sent.
	(wait_for_sigstop): Avoid TID.
	(linux_supports_tracefork_flag, linux_tracefork_child, my_waitpid)
	(linux_test_for_tracefork): New.
	(linux_lookup_signals): Use thread_db_active and
	linux_supports_tracefork_flag.
	(initialize_low): Use thread_db_active and linux_test_for_tracefork.
	* linux-low.h (get_process_thread): Avoid TID.
	(struct process_ifo): Move thread_known and tid to the end.  Remove
	sigstop_sent.
	(linux_attach_lwp, thread_db_init): Update prototypes.
	* server.h (change_inferior_id): Delete prototype.
	(add_pid_to_list, pull_pid_from_list): New prototypes.
	* thread-db.c (thread_db_use_events): New.
	(find_first_thread): Rename to...
	(find_one_thread): ...this.  Update callers and messages.  Do not
	call fatal.  Check thread_db_use_events.  Do not call
	change_inferior_id or new_thread_notify.
	(maybe_attach_thread): Update.  Do not call new_thread_notify.
	(thread_db_init): Set thread_db_use_events.  Check use_events.
	* utils.c (fatal, warning): Correct message prefix.
@
text
@d163 1
a163 1
	  else if (!WIFSTOPPED (status) || WSTOPSIG (status) != SIGSTOP)
d173 10
a182 2
      if (stopping_threads)
	new_process->stopped = 1;
d184 13
a196 1
	ptrace (PTRACE_CONT, new_pid, 0, 0);
@


1.62
log
@	* linux-low.c (O_LARGEFILE): Define.
	(linux_read_memory): Use /proc/PID/mem.
	* configure.ac: Use AC_GNU_SOURCE.  Check for pread64.
	* configure, config.in: Regenerated.
@
text
@d47 33
d86 2
a87 3
/* ``all_threads'' is keyed by the LWP ID - it should be the thread ID instead,
   however.  This requires changing the ID in place when we go from !using_threads
   to using_threads, immediately.
d94 6
d104 4
a107 1
int using_threads;
d115 1
d136 50
a227 3

  /* Default to tid == lwpid == pid.  */
  process->tid = pid;
d272 1
d280 1
a280 1
linux_attach_lwp (unsigned long pid, unsigned long tid)
d291 1
a291 1
      if (!using_threads)
d296 2
d299 2
a300 1
  add_thread (tid, new_process, pid);
d321 1
a321 1
  linux_attach_lwp (pid, pid);
d434 1
a434 1
linux_thread_alive (unsigned long tid)
d436 1
a436 1
  if (find_inferior_id (&all_threads, tid) != NULL)
d536 1
d571 12
d592 1
a592 1
	find_inferior_id (&all_threads, (*childp)->tid);
d657 1
a657 1
	find_inferior_id (&all_threads, event_child->tid);
d660 1
a660 1
      if (using_threads && ! WIFSTOPPED (wstat))
d663 1
a663 2
	    fprintf (stderr, "Thread %ld (LWP %ld) exiting\n",
		     event_child->tid, event_child->head.id);
d669 1
a669 1
	  dead_thread_notify (event_child->tid);
d685 1
a685 2
      if (using_threads
	  && WIFSTOPPED (wstat)
d697 7
d715 8
a722 5
	  && ((using_threads && (WSTOPSIG (wstat) == __SIGRTMIN
				 || WSTOPSIG (wstat) == __SIGRTMIN + 1))
	      || (pass_signals[target_signal_from_host (WSTOPSIG (wstat))]
		  && (WSTOPSIG (wstat) != SIGSTOP
		      || !event_child->sigstop_sent))))
d727 2
a728 3
	    fprintf (stderr, "Ignored signal %d for %ld (LWP %ld).\n",
		     WSTOPSIG (wstat), event_child->tid,
		     event_child->head.id);
d885 6
a984 1
  process->sigstop_sent = 1;
d1001 1
a1001 1
						    process->tid);
d1011 2
a1012 3
	fprintf (stderr, "Process %ld (thread %ld) "
		 "stopped with non-sigstop status %06x\n",
		 process->lwpid, process->tid, wstat);
d1713 113
d1830 1
a1830 1
  if (using_threads)
d1833 1
a1833 1
  using_threads = thread_db_init ();
d2015 1
a2015 1
  using_threads = 0;
d2021 1
@


1.61
log
@	* linux-low.c (linux_wait_for_event): Do not pass signals while
	single-stepping.
@
text
@d43 4
d1495 30
d1526 1
@


1.60
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d592 4
a595 3
	 signals as well as any that GDB specifically requested
	 we ignore.  But never ignore SIGSTOP if we sent it
	 ourselves.  */
d599 1
@


1.59
log
@	* inferiors.c (change_inferior_id): Add comment.
	* linux-low.c (check_removed_breakpoint): Add an early
	prototype.  Improve debug output.
	(linux_attach): Doc update.
	(linux_detach_one_process, linux_detach): Clean up before releasing
	each process.
	(send_sigstop, wait_for_sigstop): Improve comments and debug output.
	* linux-low.h (struct process_info): Doc improvement.
	* mem-break.c (delete_all_breakpoints): New.
	* mem-break.h (delete_all_breakpoints): New prototype.
	* thread-db.c (find_first_thread): New.
	(thread_db_create_event): Call it instead of
	thread_db_find_new_threads.  Clean up unused variables.
	(maybe_attach_thread): Remove first thread handling.
	(thread_db_find_new_threads): Use find_first_thread.
	(thread_db_get_tls_address): Likewise.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.58
log
@	* linux-low.c (linux_create_inferior): Try execv before execvp.
	* spu-low.c (spu_create_inferior): Likewise.
@
text
@d71 1
d228 2
a229 1
  /* Don't ignore the initial SIGSTOP if we just attached to this process.  */
d291 21
d318 1
d320 1
d360 2
a361 1
    fprintf (stderr, "Checking for breakpoint.\n");
d374 2
a375 1
	fprintf (stderr, "Ignoring, PC was changed.\n");
d847 7
d889 3
a891 1
	fprintf (stderr, "Stopped with non-sigstop signal\n");
@


1.57
log
@2007-06-13  Mike Frysinger  <vapier@@gentoo.org>

	* linux-low.c (linux_create_inferior): Change execv to execvp.
	* spu-low.c (spu_create_inferior): Likewies.
@
text
@d168 3
a170 1
      execvp (program, allargs);
@


1.56
log
@	* linux-low.c (linux_detach): Change return type to int.  Return 0.
	* spu-low.c (spu_detach): Likewise.
@
text
@d168 1
a168 1
      execv (program, allargs);
@


1.55
log
@	* target.h (target_ops): Change return type of detach to int.
	Add join.
	(join_inferior): New.
	* server.c (main): Don't skip detach support on mingw32.
	If the inferior doesn't support detaching return error.
	Call join_inferior instead of using waitpid.
	* linux-low.c (linux_join): New.
	(linux_target_op): Add linux_join.
	* spu-low.c (spu_join): New.
	(spu_target_ops): Add spu_join.
	* win32-low.c (win32_detach): Adapt to new interface.
	Reopen current_process_handle before detaching.  Issue a child
	resume before detaching.
	(win32_join): New.
	(win32_target_op): Add win32_join.
@
text
@d290 1
a290 1
static void
d294 1
@


1.54
log
@2007-03-27  Jon Ringle  <jon@@ringle.org>

	* linux-low.c: Check __ARCH_HAS_MMU__ also.
@
text
@d296 13
d1672 1
@


1.53
log
@	* gdb.texinfo (Monitor commands for gdbserver): New subsection.

	* remote-utils.c (monitor_output): New function.
	* server.c (debug_threads): Define here.
	(monitor_show_help): New function.
	(handle_query): Handle qRcmd.
	(main): Do not handle 'd' packet.
	* server.h (debug_threads, remote_debug, monitor_output): Declare.
	* linux-low.c, spu-low.c, win32-i386-low.c: Remove definitions
	of debug_threads.

	* gdb.server/server-mon.exp: New test.
@
text
@d45 6
d152 1
a152 1
#if defined(__UCLIBC__) && !defined(__UCLIBC_HAS_MMU__)
d1603 1
a1603 1
#if defined(__UCLIBC__) && !defined(__UCLIBC_HAS_MMU__)
d1673 1
a1673 1
#if defined(__UCLIBC__) && !defined(__UCLIBC_HAS_MMU__)
@


1.52
log
@	* target.h (target_ops): Rename send_signal to request_interrupt,
	and remove enum target_signal parameter.
	* linux-low.c (linux_request_interrupt): Rename from
	linux_send_signal, and always send SIGINT.
	* spu-low.c (spu_request_interrupt): Rename from spu_send_signal,
	and always send SIGINT.
	* remote-utils.c (putpkt_binary): Call request_interrupt, instead
	of send_signal.
	(input_interrupt): Likewise.
@
text
@a79 2
int debug_threads = 0;

@


1.51
log
@XML feature description support.

	* NEWS: Mention target descriptions, "set tdesc filename",
	"unset tdesc filename", "show tdesc filename", and
	qXfer:features:read.
	* arch-utils.c (choose_architecture_for_target): New function.
	(gdbarch_info_fill): Call it.
	* target-descriptions.c (struct property): Make members non-const.
	(struct target_desc): Add arch member.
	(target_description_filename): New variable.
	(target_find_description): Try via XML first.
	(tdesc_architecture): New.
	(free_target_description, make_cleanup_free_target_description): New.
	(set_tdesc_property): Call xstrdup.
	(set_tdesc_architecture, tdesc_set_cmdlist, tdesc_show_cmdlist)
	(tdesc_unset_cmdlist, unset_tdesc_cmd, unset_tdesc_filename_cmd)
	(set_tdesc_cmd, show_tdesc_cmd, set_tdesc_filename_cmd)
	(show_tdesc_filename_cmd, _initialize_target_descriptions): New.
	* target-descriptions.h (tdesc_architecture)
	(make_cleanup_free_target_description, set_tdesc_architecture): New
	prototypes.
	* Makefile.in (SFILES): Add xml-tdesc.c.
	(COMMON_OBS): Add xml-tdesc.o.
	(target-descriptions.o): Update.
	(xml-tdesc.o): New rule.
	* xml-tdesc.c, xml-tdesc.h: New files.
	* remote.c (PACKET_qXfer_features): New enum.
	(remote_protocol_features): Add qXfer:features:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_FEATURES.
	(_initialize_remote): Register qXfer:features:read.
	* target.h (enum target_object): Add TARGET_OBJECT_AVAILABLE_FEATURES.
	* features/gdb-target.dtd: New file.

	* linux-i386-low.c (the_low_target): Set arch_string.
	* linux-x86-64-low.c (the_low_target): Likewise.
	* linux-low.c (linux_arch_string): New.
	(linux_target_ops): Add it.
	* linux-low.h (struct linux_target_ops): Add arch_string.
	* server.c (write_qxfer_response): Use const void * for DATA.
	(get_features_xml): New.
	(handle_query): Handle qXfer:features:read.  Report it for qSupported.
	* target.h (struct target_ops): Add arch_string method.

	* gdb.texinfo (Target Descriptions): New section.
	(General Query Packets): Add QPassSignals anchor.  Mention
	qXfer:features:read under qSupported.  Expand mentions of
	qXfer:memory-map:read and QPassSignals.  Document
	qXfer:features:read.
@
text
@d1517 1
a1517 1
linux_send_signal (int signum)
d1526 1
a1526 1
      kill_lwp (process->lwpid, signum);
d1529 1
a1529 1
    kill_lwp (signal_pid, signum);
d1663 1
a1663 1
  linux_send_signal,
@


1.50
log
@Copyright updates for 2007.
@
text
@d1644 6
d1679 1
@


1.49
log
@	* linux-low.c (linux_kill): Handle being called with no threads.
	* win32-i386-low.c (win32_kill): Likewise.
	(get_child_debug_event): Clear current_process_handle.
@
text
@d3 1
a3 2
   2006
   Free Software Foundation, Inc.
@


1.48
log
@gdb/
	* remote.c (PACKET_QPassSignals): New.
	(last_pass_packet, remote_pass_signals): New.
	(remote_protocol_features): Add QPassSignals.
	(remote_query_supported): Correct an infinite loop.
	(remote_open_1): Reset last_pass_packet.
	(remote_resume): Call remote_pass_signals.
	(_initialize_remote): Register "set remote pass-signals".
gdb/doc/
	* gdb.texinfo (Remote configuration): Mention
	"pass-signals-packet".
	(General Query Packets): Document QPassSignals.  Fix
	a typo.
gdb/gdbserver/
	* linux-low.c (linux_wait_for_event): Reformat.  Use the
	pass_signals array.
	* remote-utils.c (decode_address_to_semicolon): New.
	* server.c (pass_signals, handle_general_set): New.
	(handle_query): Mention QPassSignals for qSupported.
	(main): Call handle_general_set.
	* server.h (pass_signals, decode_address_to_semicolon): New.
@
text
@d258 1
a258 1
  struct process_info *process = get_thread_process (thread);
d261 3
d268 1
@


1.47
log
@	* acinclude.m4 (SRV_CHECK_TLS_GET_ADDR): New.
	* configure.ac: Use it.  Define HAVE_TD_THR_TLS_GET_ADDR.
	* config.in, configure: Regenerated.
	* inferiors.c (gdb_id_to_thread): New function.
	(gdb_id_to_thread_id): Use it.
	* linux-low.c (linux_target_ops): Use thread_db_get_tls_address.
	* linux-low.h (struct process_info): Add th member.
	(thread_db_get_tls_address): New prototype.
	* remote-utils.c (decode_address): Make non-static.
	* server.c (handle_query): Handle qGetTLSAddr.
	* server.h (gdb_id_to_thread, decode_address): New prototypes.
	* target.h (struct target_ops): Add get_tls_address.
	* thread-db.c (maybe_attach_thread): Save the thread handle.
	(thread_db_get_tls_address): New.
@
text
@d501 2
a502 1
      if (using_threads)
d504 19
a522 22
	  /* Check for thread exit.  */
	  if (! WIFSTOPPED (wstat))
	    {
	      if (debug_threads)
		fprintf (stderr, "Thread %ld (LWP %ld) exiting\n",
			 event_child->tid, event_child->head.id);

	      /* If the last thread is exiting, just return.  */
	      if (all_threads.head == all_threads.tail)
		return wstat;

	      dead_thread_notify (event_child->tid);

	      remove_inferior (&all_processes, &event_child->head);
	      free (event_child);
	      remove_thread (current_inferior);
	      current_inferior = (struct thread_info *) all_threads.head;

	      /* If we were waiting for this particular child to do something...
		 well, it did something.  */
	      if (child != NULL)
		return wstat;
d524 3
a526 3
	      /* Wait for a more interesting event.  */
	      continue;
	    }
d528 12
a539 11
	  if (WIFSTOPPED (wstat)
	      && WSTOPSIG (wstat) == SIGSTOP
	      && event_child->stop_expected)
	    {
	      if (debug_threads)
		fprintf (stderr, "Expected stop.\n");
	      event_child->stop_expected = 0;
	      linux_resume_one_process (&event_child->head,
					event_child->stepping, 0, NULL);
	      continue;
	    }
d541 16
a556 7
	  /* FIXME drow/2002-06-09: Get signal numbers from the inferior's
	     thread library?  */
	  if (WIFSTOPPED (wstat)
	      && (WSTOPSIG (wstat) == __SIGRTMIN
		  || WSTOPSIG (wstat) == __SIGRTMIN + 1))
	    {
	      siginfo_t info, *info_p;
d558 4
a561 4
	      if (debug_threads)
		fprintf (stderr, "Ignored signal %d for %ld (LWP %ld).\n",
			 WSTOPSIG (wstat), event_child->tid,
			 event_child->head.id);
d563 8
a570 9
	      if (ptrace (PTRACE_GETSIGINFO, event_child->lwpid, 0, &info) == 0)
		info_p = &info;
	      else
		info_p = NULL;
	      linux_resume_one_process (&event_child->head,
					event_child->stepping,
					WSTOPSIG (wstat), info_p);
	      continue;
	    }
@


1.46
log
@	* linux-low.c (PTRACE_GETSIGINFO, PTRACE_SETSIGINFO): Define.
	(linux_resume_one_process): Take a siginfo_t *.  Update all
	callers.  Queue it if necessary.  Use PTRACE_SETSIGINFO.
	(struct pending_signals): Add a siginfo_t.
	(linux_wait_for_process): Always set last_status.
	(linux_wait_for_event): Use PTRACE_GETSIGINFO.
	(linux_queue_one_thread): Use PTRACE_GETSIGINFO.
	* linux-low.h (struct process_info): Add last_status.
@
text
@d1655 7
@


1.45
log
@gdb/
	* configure.tgt: Build gdbserver for Cygwin and mingw32.
gdb/gdbserver/
	* configure.ac: Check for more headers which are missing on
	Windows.  Automatically supply -lwsock32 and USE_WIN32API.
	* configure.srv: Add Cygwin and mingw32.
	* remote-utils.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_open): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(remote_close, putpkt_binary, input_interrupt, block_async_io)
	(unblock_async_io, enable_async_io, disable_async_io)
	(readchar, getpkt): Update for Winsock support.
	(prepare_resume_reply): Expect a protocol signal number.
	* server.c: Disable <sys/wait.h> on mingw32.
	(start_inferior): Adjust for mingw32 support.  Flush
	standard error after writing to it.
	(attach_inferior): Likewise.  Use protocol signal
	numbers.
	(main): Skip 'D' packet on mingw32.  Use protocol signal numbers
	and names.
	* win32-i386-low.c: New file.
	* Makefile.in (XM_CLIBS): Set.
	(gdbserver, gdbreplay): Use $(INTERNAL_CFLAGS).
	(win32-i386-low.o): New dependency rule.
	* linux-low.c (linux_wait): Use target signal numbers.
	* target.h (struct target_ops): Doc fix.
	* server.h (target_signal_to_name): New prototype.
	* gdbreplay.c: Don't include headers unconditionally which
	are missing on mingw32.  Include <winsock.h> for mingw32.
	(remote_close, remote_open): Adjust for Winsock support.
	* configure, config.in: Regenerated.
@
text
@d41 5
d62 1
a62 1
				      int step, int signal);
d70 1
d375 1
a375 1
	linux_resume_one_process (&process->head, 0, 0);
d428 2
d538 1
a538 1
					event_child->stepping, 0);
d548 2
d554 5
d561 1
a561 1
					WSTOPSIG (wstat));
d590 1
a590 1
	  linux_resume_one_process (&event_child->head, 0, 0);
d627 1
a627 1
	      linux_resume_one_process (&event_child->head, 1, 0);
d633 1
a633 1
	      linux_resume_one_process (&event_child->head, 0, 0);
d858 1
a858 1
			  int step, int signal)
d877 4
d936 3
d1005 1
a1005 1
  linux_resume_one_process (&process->head, step, process->resume->sig);
d1036 10
@


1.44
log
@	* configure.srv (m68k*-*-uclinux*): New target.
	* linux-low.c (linux_create_inferior): Use vfork on mmuless systems.
	(linux_resume_one_process): Remove extraneous cast.
	(linux_read_offsets): New.
	(linux_target_op): Add linux_read_offsets on mmuless systems.
	* server.c (handle_query): Add qOffsets logic.
	* target.h (struct target_ops): Add read_offsets.
@
text
@d717 1
a717 1
	  return ((unsigned char) WEXITSTATUS (w));
d726 1
a726 1
	  return ((unsigned char) WTERMSIG (w));
d736 1
a736 1
  return ((unsigned char) WSTOPSIG (w));
@


1.44.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d717 1
a717 1
	  return WEXITSTATUS (w);
d726 1
a726 1
	  return target_signal_from_host (WTERMSIG (w));
d736 1
a736 1
  return target_signal_from_host (WSTOPSIG (w));
@


1.43
log
@	* linux-low.c (regsets_store_inferior_registers): Read the regset
	from the target before filling it.
@
text
@d143 3
d147 1
d903 1
a903 1
      (long) (*the_low_target.get_pc) ();
d1557 45
d1621 3
@


1.43.2.1
log
@	* gdb/gdbserver/Makefile.in (reg-cf.o, reg-cf.c): New targets.
	* gdb/gdbserver/configure.srv (m68k*-*-uclinux*): New target.
	* gdb/gdbserver/linux-low.c (linux_create_inferior): Use vfork on
	mmuless systems.
	(linux_resume_one_process): Remove extraneous cast.
	(linux_read_offsets): New.
	(linux_target_op): Add linux_read_offsets on mmuless systems.
	* gdb/gdbserver/server.c (handle_query): Add qOffsets logic.
	* gdb/gdbserver/target.h (struct target_ops): Add read_offsets.
@
text
@a142 3
#if defined(__UCLIBC__) && !defined(__UCLIBC_HAS_MMU__)
  pid = vfork ();
#else
a143 1
#endif
d899 1
a899 1
      (*the_low_target.get_pc) ();
a1552 47
#if defined(__UCLIBC__) && !defined(__UCLIBC_HAS_MMU__)
#if defined(__mcoldfire__)
/* These should really be defined in the kernel's ptrace.h header.  */
#define PT_TEXT_ADDR 49*4
#define PT_DATA_ADDR 50*4
#define PT_TEXT_END_ADDR  51*4
#endif

/* Under uClinux, programs are loaded at non-zero offsets, which we need
   to tell gdb about.  */

static int
linux_read_offsets (CORE_ADDR *text_p, CORE_ADDR *data_p)
{
#if defined(PT_TEXT_ADDR) && defined(PT_DATA_ADDR) && defined(PT_TEXT_END_ADDR)
  unsigned long text, text_end, data;
  int pid = get_thread_process (current_inferior)->head.id;

  errno = 0;

  text = ptrace (PTRACE_PEEKUSER, pid, (long)PT_TEXT_ADDR, 0);
  text_end = ptrace (PTRACE_PEEKUSER, pid, (long)PT_TEXT_END_ADDR, 0);
  data = ptrace (PTRACE_PEEKUSER, pid, (long)PT_DATA_ADDR, 0);

  if (errno == 0)
    {
      /* Both text and data offsets produced at compile-time (and so
         used by gdb) are relative to the beginning of the program,
         with the data segment immediately following the text segment.
         However, the actual runtime layout in memory may put the data
         somewhere else, so when we send gdb a data base-address, we
         use the real data base address and subtract the compile-time
         data base-address from it (which is just the length of the
         text segment).  BSS immediately follows data in both
         cases.  */
      printf ("%lx, %lx, %lx\n", text, text_end, data);
      
      *text_p = text;
      *data_p = data - (text_end - text);
      
      return 1;
    }
#endif
 return 0;
}
#endif

a1571 3
#if defined(__UCLIBC__) && !defined(__UCLIBC_HAS_MMU__)
  linux_read_offsets,
#endif
@


1.43.2.2
log
@	* gdb/gdbserver/linux-low.c (linux_read_offsets): Remove debugging
	printf.
@
text
@d1592 2
@


1.43.2.2.2.1
log
@Actually include patch, not just changelog.
@
text
@a265 4

  clear_inferiors ();
  free (all_processes.head);
  all_processes.head = all_processes.tail = NULL;
@


1.43.2.2.2.2
log
@No, really, check in the RIGHT patch!
[Revert half of changes from previous commit.]
@
text
@d266 4
@


1.43.2.2.2.3
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a265 4

  clear_inferiors ();
  free (all_processes.head);
  all_processes.head = all_processes.tail = NULL;
a280 4

  clear_inferiors ();
  free (all_processes.head);
  all_processes.head = all_processes.tail = NULL;
a418 10
  /* If we see an event for a process we don't know about, one of two things
     could be happening: it could be a new thread, e.g. via CLONE_PTRACE,
     or it could be a detached process exiting.  We do not yet support
     CLONE_PTRACE, so we should disregard extraneous events.  */
  if (*childp == NULL)
    {
      linux_wait_for_process (childp, wstatp);
      return;
    }

@


1.42
log
@	* linux-arm-low.c:
	* linux-cris-low.c:
	* inferiors.c:
	* i387-fp.h:
	* i387-fp.c:
	* gdbreplay.c:
	* regcache.c:
	* proc-service.c:
	* mem-break.h:
	* mem-break.c:
	* linux-x86-64-low.c:
	* linux-sh-low.c:
	* linux-s390-low.c:
	* linux-ppc64-low.c:
	* linux-ppc-low.c:
	* linux-mips-low.c:
	* linux-m68k-low.c:
	* linux-m32r-low.c:
	* linux-low.h:
	* linux-low.c:
	* linux-ia64-low.c:
	* linux-i386-low.c:
	* linux-crisv32-low.c:
	* thread-db.c:
	* terminal.h:
	* target.h:
	* target.c:
	* server.h:
	* server.c:
	* remote-utils.c:
	* regcache.h:
	* utils.c:
	* Makefile.in:
	* configure.ac:
	* gdbserver.1: Add (C) after Copyright.  Update the FSF
	address.
@
text
@d2 2
a3 1
   Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d1290 15
a1304 2
      regset->fill_function (buf);
      res = ptrace (regset->set_request, inferior_pid, 0, buf);
@


1.41
log
@	* configure.ac: Define HAVE_LINUX_REGSETS even if PTRACE_GETREGS
	is not available.  Define HAVE_PTRACE_GETREGS if it is.
	* config.in, configure: Regenerated.
	* configure.srv: Set srv_linux_regsets for PowerPC and PowerPC64.
	* linux-i386-low.c, linux-m68k-low.c: Update to use
	HAVE_PTRACE_GETREGS.
	* linux-low.c (regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): Only return 0 if we processed
	GENERAL_REGS.
	* linux-ppc-low.c (ppc_fill_gregset, target_regsets): New.
	* linux-ppc64-low.c (ppc_fill_gregset, target_regsets): New.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.41.2.1
log
@2005-03-30  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in (arm-linux-nat.o): Update dependencies.
	* gdb/arm-linux-nat.c: Include "gdb_assert.h".
	(PTRACE_GETWMMXREGS, PTRACE_SETWMMXREGS): Define.
	(arm_linux_has_wmmx_registers): New flag.
	(GET_THREAD_ID): Remove stray punctuation.
	(IWMMXT_REGS_SIZE): Define.
	(fetch_wmmx_regs, store_wmmx_regs): New functions.
	(fetch_inferior_registers, store_inferior_registers): Call them.
	(arm_linux_available_registers): New function.
	* gdb/inftarg.c (child_xfer_partial): Handle
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/config/arm/nm-linux.h (arm_linux_available_registers): Add
	prototype.
	(NATIVE_XFER_AVAILABLE_REGISTERS): Define.

	* gdb/gdbserver/linux-arm-low.c (arm_fill_wmmxregset)
	(arm_store_wmmxregset): Remove stray text.
	(arm_available_registers): Remove debugging output.  Use hex.
	* gdb/gdbserver/regcache.c (num_registers): Make global.
	* gdb/gdbserver/server.c (handle_p_packet, handle_P_packet): Check
	the value of regnum.

2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@d71 1
a71 1
int use_regsets_p = 1;
a1357 9
static char *
linux_available_registers (void)
{
  if (the_low_target.available_registers == NULL)
    return NULL;
  else
    return (*the_low_target.available_registers) ();
}

a1557 1
  linux_available_registers,
@


1.40
log
@	* inferiors.c (struct thread_info): Add gdb_id.
	(add_thread): Add gdb_id argument.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): New.
	* linux-low.c (linux_create_inferior, linux_attach_lwp): Update
	calls to add_thread.
	* remote-utils.c (prepare_resume_reply: Use thread_to_gdb_id.
	* server.c (handle_query): Use thread_to_gdb_id.
	(handle_v_cont, main): Use gdb_id_to_thread_id.
	* server.h (add_thread): Update prototype.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): New
	prototypes.
@
text
@d1216 1
d1258 2
d1263 4
a1266 1
  return 0;
d1273 1
d1313 2
d1318 4
@


1.39
log
@	* linux-low.c (fetch_register, usr_store_inferior_registers): Handle
	left-padded registers.
	* linux-low.h (struct linux_target_ops): Add left_pad_xfer.
	* linux-ppc64-low.c (the_low_target): Set left_pad_xfer.
@
text
@d163 1
a163 1
  add_thread (pid, new_process);
d188 1
a188 1
  add_thread (tid, new_process);
@


1.38
log
@	* linux-low.c (linux_wait, linux_send_signal): Don't test
	an unsigned long variable for > 0 if it could be MAX_ULONG.
	* server.c (myresume): Likewise.
	* target.c (set_desired_inferior): Likewise.
@
text
@d1129 6
a1134 1
  supply_register (regno, buf);
d1176 6
a1181 1
      collect_register (regno, buf);
@


1.37
log
@	* acconfig.h: Remove.
	* configure.ac: Add a test for socklen_t.  Use three-argument
	AC_DEFINE throughout.
	* config.in: Regenerated using autoheader 2.59.
	* configure: Regenerated.

	* gdbreplay.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	* remote-utils.c (socklen_t): Provide a default.
	(remote_open): Use socklen_t.
	(convert_int_to_ascii, convert_ascii_to_int, decode_M_packet): Use
	unsigned char.

	* i387-fp.c (struct i387_fsave, struct i387_fxsave): Use unsigned
	char for buffers.
	* linux-low.c (linux_read_memory, linux_write_memory)
	(linux_read_auxv): Likewise.
	* mem-break.c (breakpoint_data, set_breakpoint_data, check_mem_read)
	(check_mem_write): Likewise.
	* mem-break.h (set_breakpoint_data, check_mem_read, check_mem_write):
	Likewise.
	* regcache.c (struct inferior_rgcache_data, registers_to_string)
	(registers_from_string, register_data): Likewise.
	* server.c (handle_query, main): Likewise.
	* server.h (convert_ascii_to_int, convert_int_to_ascii)
	(decode_M_packet): Likewise.
	* target.c (read_inferior_memory, write_inferior_memory): Likewise.
	* target.h (struct target_ops): Update read_memory, write_memory,
	and read_auxv.
	(read_inferior_memory, write_inferior_memory): Update.
	* linux-low.h (struct linux_target_ops): Change type of breakpoint
	to unsigned char *.
	* linux-arm-low.c, linux-cris-low.c, linux-crisv32-low.c,
	linux-i386-low.c, linux-m32r-low.c, linux-m68k-low.c,
	linux-mips-low.c, linux-ppc-low.c, linux-ppc64-low.c,
	linux-s390-low.c, linux-sh-low.c: Update for changes in
	read_inferior_memory and the_low_target->breakpoint.
@
text
@d670 1
a670 1
  if (cont_thread > 0)
d1438 1
a1438 1
  if (cont_thread > 0)
@


1.36
log
@	* linux-low.c (fetch_register): Ensure buffer size is a multiple
	of sizeof (PTRACE_XFER_TYPE).
	(usr_store_inferior_registers): Likewise.  Zero out excess bytes.
@
text
@d1340 1
a1340 1
linux_read_memory (CORE_ADDR memaddr, char *myaddr, int len)
d1374 1
a1374 1
linux_write_memory (CORE_ADDR memaddr, const char *myaddr, int len)
d1453 1
a1453 1
linux_read_auxv (CORE_ADDR offset, char *myaddr, unsigned int len)
@


1.35
log
@2005-05-12  Orjan Friberg  <orjanf@@axis.com>

	* target.h (struct target_ops): Add insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address function
	pointers for hardware watchpoint support.
	* linux-low.h (struct linux_target_ops): Ditto.
	* linux-low.c (linux_insert_watchpoint, linux_remove_watchpoint)
	(linux_stopped_by_watchpoint, linux_stopped_data_address): New.  Add
	to linux_target_ops.
	* remote-utils.c (prepare_resume_reply): Add watchpoint information to
	reply packet.
	* server.c (main): Recognize 'Z' and 'z' packets.
@
text
@d1098 1
a1098 1
  register int i;
d1109 4
a1112 2
  buf = alloca (register_size (regno));
  for (i = 0; i < register_size (regno); i += sizeof (PTRACE_XFER_TYPE))
d1152 1
a1152 1
  int i;
d1167 4
a1170 1
      buf = alloca (register_size (regno));
d1172 1
a1172 1
      for (i = 0; i < register_size (regno); i += sizeof (PTRACE_XFER_TYPE))
@


1.34
log
@	* inferiors.c (change_inferior_id, add_thread, find_inferior_id):
	Take unsigned long arguments for PIDs.
	* linux-low.c (add_process, linux_attach_lwp, linux_attach)
	(linux_thread_alive, linux_wait_for_event, kill_lwp, send_sigstop)
	(wait_for_sigstop, linux_resume_one_process)
	(regsets_fetch_inferior_registers, linux_send_signal)
	(linux_read_auxv): Likewise.  Update the types of variables holding
	PIDs.  Update format string specifiers.
	* linux-low.h (struct process_info, linux_attach_lwp): Likewise.
	* remote-utils.c (prepare_resume_reply): Likewise.
	* server.c (cont_thread, general_thread, step_thread)
	(thread_from_wait, old_thread_from_wait, signal_pid): Change type to
	unsigned long.
	(handle_query): Update format specifiers.
	(handle_v_cont, main): Use strtoul for thread IDs.
	* server.h (struct inferior_list_entry): Use unsigned long for ID.
	(add_thread, find_inferior_id, change_inferior_id, cont_thread)
	(general_thread, step_thread, thread_from_wait)
	(old_thread_from_wait): Update.
	* target.h (struct thread_resume): Use unsigned long for THREAD.
	(struct target_ops): Use unsigned long for arguments to attach and
	thread_alive.
@
text
@d1470 41
a1510 1

d1526 4
@


1.34.2.1
log
@2005-03-28  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/Makefile.in: arm-tdep.o depends on $(observer_h).
	* gdb/arm-linux-nat.c (fetch_fpregister, fetch_fpregs,
	store_fpregister, store_fpregs): Rename...
	(fetch_fpa_register, fetch_fpa_regs, store_fpa_register,
	store_fpa_regs): ... to this.
	* gdb/arm-linux-tdep.c (arm_linux_init_abi): Provide ABI specific
	overrides.
	* gdb/arm-tdep.c: Include opserver.h.
	(struct gdbarch_tdep_info): Add.
	(arm_push_dummy_call): Handle doubleword alignment.
	(arm_register_type): Handle iWMMXt and VFP regs.
	(arm_register_byte): Ditto.
	(arm_pseudo_register_read): New function.
	(arm_pseudo_register_write): New function.
	(arm_dwarf_reg_to_regnum): New function.
	(arm_register_sim_regno): Handle iWMMXT regs.
	(arm_register_remote_regno): New function.
	(arm_extract_return_value): Use new macro names.
	(arm_register_name): Handle iWMMXt and VFP registers.
	(arm_sim_available_registers): New function.
	(arm_update_architecture): New function.
	(arm_gdbarch_init): Handle optional register sets.  Register new
	hooks.  Fix misleading error message.
	(_initialize_arm_tdep): Call observer_attach_inferior_created.
	* gdb/arm-tdep.h (ARM_NUM_FP_ARG_REGS, ARM_LAST_FP_ARG_REGNUM,
	FP_REGISTER_SIZE, NUM_FREGS): Rename ...
	(ARM_NUM_FPA_ARG_REGS, ARM_LAST_FPA_ARG_REGNUM, FPA_REGISTER_SIZE,
	NUM_FPA_REGS): ... to this.
	(NUM_IWMMXT_COP0REGS, NUM_IWMMXT_COP1REGS, NUM_IWMMXT_REGS,
	IWMMXT_COP0_REGSIZE, IWMMXT_COP1_REGSIZE, NUM_VFP_XREGS,
	VFP_XREG_SIZE, NUM_VFP_SREGS, VFP_SREG_SIZE, NUM_VFP_PSEUDOS): Define.
	(struct gdbarch_tdep): Add target_has_iwmmxt_regs,
	target_has_vfp_regs, first_iwmmxt_regnum, target_iwmmxt_regnum,
	first_vfp_regnum, first_vfp_pseudo and target_vfp_regnum.
	* gdb/gdbarch.c (struct gdbarch): Add remote_num_g_packet_regs,
	sim_available_registers and register_remote_regno.
	(startup_gdbarch, verify_gdbarch): Ditto.
	(gdbarch_dump): Dump new fields.
	(gdbarch_remote_num_g_packet_regs_p, gdbarch_remote_num_g_packet_regs,
	set_gdbarch_remote_num_g_packet_regs,
	gdbarch_sim_available_registers_p, gdbarch_sim_available_registers,
	set_gdbarch_sim_available_registers, gdbarch_register_remote_regno_p,
	gdbarch_register_remote_regno, set_gdbarch_register_remote_regno):
	New functions.
	* gdb/gdbarch.h: Add prototypes.
	* gdb/gdbarch.sh: Add new fields.
	(deprecated_current_gdbarch_select_hack): Call flush_cached_frames.
	* gdb/remote-sim.h (gdbsim_create_inferior): Call
	observer_notify_inferior_created.
	(gdbsim_xfer_partial): New function.
	(init_gdbsim_ops): Use it.
	* gdb/remote.c (struct remote_state): Add num_g_regs.
	(init_remote_state): Only consider hard regs.  Allow target to provide
	register mapping.
	(packet_reg_from_regnum): Don't check pseudo regs.
	(packet_reg_from_pnum): Ditto.
	(remote_protocol_qPart_availableRegisters): Add.
	(set_remote_protocol_qPart_availableRegisters_packet_cmd,
	show_remote_protocol_qPart_availableRegisters_packet_cmd): New
	functions.
	(fetch_register_using_p, store_register_using_P): Handle arbitrary
	register mappings.
	(fetch_registers_using_g): New function.
	(remote_fetch_registers): Use it.
	(store_registers_using_G): New function.
	(remote_store_registers): Use it.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_REGISTERS.
	(show_remote_cmd): Display availableRegisters.
	(_initialize_remote): Register qPart_availableRegisters.
	* gdb/target.h (enum target_object): Add
	TARGET_OBJECT_AVAILABLE_REGISTERS.
	* gdb/gdbserver/configure.srv (arm*-*-linux*): set
	srv_linux_regsets=yes.
	* gdb/gdbserver/linux-arm-low.c (PTRACE_GETWMMXREGS,
	PTRACE_SETWMMXREGS): Define.
	(arm_fill_gregset, arm_store_gregset, arm_fill_wmmxregset,
	arm_store_wmmxregset, arm_available_registers): New functions.
	(target_regsets): Add.
	(the_low_target): Use arm_available_registers.
	* gdb/gdbserver/linux-low.c (linux_available_registers): New function.
	(linux_target_op): Use it.
	* gdb/gdbserver/linux-low.h (gdbserver/linux-low.h): Add
	available_registers.
	(use_regsets_p): Declare.
	* gdb/gdbserver/regcache.c (g_register_bytes): Add.
	(regcache_invalidate, registers_to_string, registers_from_string):
	Use it.
	(set_register_cache): Set g_register_bytes.
	(supply_register_as_string): New function.
	* gdb/gdbserver/regcache.h (supply_register_as_string): Add prototype.
	* gdb/gdbserver/server.c (handle_query): Handle
	qPart:availableRegisters.
	(handle_p_packet, handle_P_packet): New functions.
	(main): Handle 'p' and 'P' packets.
	* gdb/gdbserver/target.h (struct target_ops): Add available_registers.
	* gdb/regformats/reg-arm.dat: Add last_g_reg and iWMMXT regs.
	* gdb/regformats/regdat.sh: Handle last_g_reg.
	* gdb/regformats/regdef.h (set_register_cache): Update prototype.
@
text
@d71 1
a71 1
int use_regsets_p = 1;
a1469 9
static char *
linux_available_registers (void)
{
  if (the_low_target.available_registers == NULL)
    return NULL;
  else
    return (*the_low_target.available_registers) ();
}

a1485 1
  linux_available_registers,
@


1.33
log
@	* linux-i386-low.c (ps_get_thread_area): New.
	* linux-x86-64-low.c (ps_get_thread_area): New.
	* linux-low.c: Include <sys/syscall.h>.
	(linux_kill_one_process): Don't kill the first thread here.
	(linux_kill): Kill the first thread here.
	(kill_lwp): New function.
	(send_sigstop, linux_send_signal): Use it.
	* proc-service.c: Clean up #ifdefs.
	(fpregset_info): Delete.
	(ps_lgetregs): Update and enable implementation.
	(ps_lsetregs, ps_lgetfpregs, ps_lsetfpregs): Remove disabled
	implementations.
	* remote-utils.c (struct sym_cache, symbol_cache): New.
	(input_interrupt): Print a clearer message.
	(async_io_enabled): New variable.
	(enable_async_io, disable_async_io): Use it.  Update comments.
	(look_up_one_symbol): Use the symbol cache.
	* thread-db.c (thread_db_look_up_symbols): New function.
	(thread_db_init): Update comments.  Call thread_db_look_up_symbols.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d115 1
a115 1
add_process (int pid)
d171 1
a171 1
linux_attach_lwp (int pid, int tid)
d177 1
a177 1
      fprintf (stderr, "Cannot attach to process %d: %s (%d)\n", pid,
d205 1
a205 1
linux_attach (int pid)
d280 1
a280 1
linux_thread_alive (int tid)
d444 1
a444 1
	fprintf (stderr, "Got a pending child %d\n", event_child->lwpid);
d459 1
a459 1
	    fprintf (stderr, "Got an event from pending child %d (%04x)\n",
d494 1
a494 1
		fprintf (stderr, "Thread %d (LWP %d) exiting\n",
d536 1
a536 1
		fprintf (stderr, "Ignored signal %d for %d (LWP %d).\n",
d738 1
a738 1
kill_lwp (int lwpid, int signo)
d775 1
a775 1
    fprintf (stderr, "Sending sigstop to process %d\n", process->head.id);
d786 2
a787 1
  int wstat, saved_tid;
d867 1
a867 1
    fprintf (stderr, "Resuming process %d (%s, signal %d, stop %s)\n", inferior_pid,
d1237 1
a1237 1
	      sprintf (s, "ptrace(regsets_fetch_inferior_registers) PID=%d",
d1431 1
a1431 1
  extern int signal_pid;
d1453 1
a1453 1
  snprintf (filename, sizeof filename, "/proc/%d/auxv", inferior_pid);
@


1.32
log
@	* linux-low.c (linux_wait): Clear all_processes list also.
@
text
@d38 1
d227 7
d246 4
d251 10
d734 24
d777 1
a777 1
  kill (process->head.id, SIGSTOP);
d1437 1
a1437 1
      kill (process->lwpid, signum);
d1440 1
a1440 1
    kill (signal_pid, signum);
@


1.31
log
@	* linux-low.c: Include <errno.h>.  Remove extern declaration of
	errno.
@
text
@d688 2
d695 1
d697 2
a698 1
	  *status = 'X';
@


1.30
log
@	* linux-low.c (linux_read_memory): Change return type to
	int.  Check for and return error from ptrace().
	* target.c (read_inferior_memory): Change return type to int.  Pass
	back return status from the_target->read_memory().
	* target.h (struct target_ops): Adapt *read_memory() prototype.
	Update comment.
	(read_inferior_memory): Adapt prototype.
	* server.c (main): Return an error packet if
	read_inferior_memory() returns an error.
@
text
@d37 1
a71 2

extern int errno;
@


1.30.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@a36 1
#include <errno.h>
d71 2
@


1.29
log
@	* linux-low.c (linux_wait): Unblock async I/O.
	(linux_resume): Block and enable async I/O.
	* remote-utils.c (block_async_io, unblock_async_io): New functions.
	* server.h (block_async_io, unblock_async_io): Add prototypes.
@
text
@d1284 1
a1284 1
static void
d1301 1
d1303 2
d1309 2
@


1.29.2.1
log
@	* linux-low.c (linux_read_memory): Change return type to
	int.  Check for and return error from ptrace().
	* target.c (read_inferior_memory): Change return type to int.  Pass
	back return status from the_target->read_memory().
	* target.h (struct target_ops): Adapt *read_memory() prototype.
	Update comment.
	(read_inferior_memory): Adapt prototype.
	* server.c (main): Return an error packet if
	read_inferior_memory() returns an error.
@
text
@d1284 1
a1284 1
static int
a1300 1
      errno = 0;
a1301 2
      if (errno)
	return errno;
a1305 2

  return 0;
@


1.29.2.2
log
@	* linux-low.c: Include <errno.h>.  Remove extern declaration of
	errno.
@
text
@a36 1
#include <errno.h>
d71 2
@


1.29.2.3
log
@	* linux-low.c (linux_wait): Clear all_processes list also.
@
text
@a687 2
	  free (all_processes.head);
	  all_processes.head = all_processes.tail = NULL;
d693 1
a694 3
	  clear_inferiors ();
	  free (all_processes.head);
	  all_processes.head = all_processes.tail = NULL;
@


1.28
log
@2004-02-25  Roland McGrath  <roland@@redhat.com>

	* target.h (struct target_ops): New member `read_auxv'.
	* server.c (handle_query): Handle qPart:auxv:read: query using that.
	* linux-low.c (linux_read_auxv): New function.
	(linux_target_ops): Initialize `read_auxv' member to that.
@
text
@d665 1
d1021 5
a1025 1
    for_each_inferior (&all_threads, linux_continue_one_thread);
@


1.27
log
@	* linux-low.c: Update copyright year.
	(check_removed_breakpoint): Clear pending_is_breakpoint.
	(linux_set_resume_request, linux_queue_one_thread)
	(resume_status_pending_p): New functions.
	(linux_continue_one_thread): Use process->resume.
	(linux_resume): Only resume threads if there are no pending events.
	* linux-low.h (struct process_info): Add resume request
	pointer.
@
text
@d600 1
a600 1
         clear the stepping flag; in general this does not matter, 
d844 1
a844 1
  if (debug_threads && the_low_target.get_pc != NULL) 
d1286 2
a1287 2
  register int count 
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1) 
d1290 1
a1290 1
  register PTRACE_XFER_TYPE *buffer 
d1384 26
d1425 1
@


1.27.4.1
log
@Merge mainline to intercu branch.
@
text
@a36 1
#include <errno.h>
d72 2
d600 1
a600 1
         clear the stepping flag; in general this does not matter,
a664 1
  unblock_async_io ();
a687 2
	  free (all_processes.head);
	  all_processes.head = all_processes.tail = NULL;
d693 1
a694 3
	  clear_inferiors ();
	  free (all_processes.head);
	  all_processes.head = all_processes.tail = NULL;
d844 1
a844 1
  if (debug_threads && the_low_target.get_pc != NULL)
d1020 1
a1020 5
    {
      block_async_io ();
      enable_async_io ();
      for_each_inferior (&all_threads, linux_continue_one_thread);
    }
d1279 1
a1279 1
static int
d1286 2
a1287 2
  register int count
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
d1290 1
a1290 1
  register PTRACE_XFER_TYPE *buffer
a1295 1
      errno = 0;
a1296 2
      if (errno)
	return errno;
a1300 2

  return 0;
a1383 26
/* Copy LEN bytes from inferior's auxiliary vector starting at OFFSET
   to debugger memory starting at MYADDR.  */

static int
linux_read_auxv (CORE_ADDR offset, char *myaddr, unsigned int len)
{
  char filename[PATH_MAX];
  int fd, n;

  snprintf (filename, sizeof filename, "/proc/%d/auxv", inferior_pid);

  fd = open (filename, O_RDONLY);
  if (fd < 0)
    return -1;

  if (offset != (CORE_ADDR) 0
      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)
    n = -1;
  else
    n = read (fd, myaddr, len);

  close (fd);

  return n;
}

a1398 1
  linux_read_auxv,
@


1.26
log
@	* linux-low.c (linux_resume): Take a struct thread_resume *
	argument.
	(linux_wait): Update call.
	(resume_ptr): New static variable.
	(linux_continue_one_thread): Renamed from
	linux_continue_one_process.  Use resume_ptr.
	(linux_resume): Use linux_continue_one_thread.
	* server.c (handle_v_cont, handle_v_requests): New functions.
	(myresume): New function.
	(main): Handle 'v' case.
	* target.h (struct thread_resume): New type.
	(struct target_ops): Change argument of "resume" to struct
	thread_resume *.
	(myresume): Delete macro.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002
d319 1
d880 6
a885 6
   in RESUME_PTR, which will tell us whether to resume, step, or leave
   the thread stopped; and what signal, if any, it should be sent.
   For threads which we aren't explicitly told otherwise, we preserve
   the stepping flag; this is used for stepping over gdbserver-placed
   breakpoints.  If the thread has a status pending, it may not actually
   be resumed.  */
d887 1
a887 1
linux_continue_one_thread (struct inferior_list_entry *entry)
d891 1
a891 1
  int ndx, step;
d900 20
a919 1
  if (resume_ptr[ndx].leave_stopped)
d922 2
a923 2
  if (resume_ptr[ndx].thread == -1)
    step = process->stepping || resume_ptr[ndx].step;
d925 3
a927 1
    step = resume_ptr[ndx].step;
d929 61
a989 1
  linux_resume_one_process (&process->head, step, resume_ptr[ndx].sig);
d995 1
a995 2
  /* Yes, this is quadratic.  If it ever becomes a problem then it's
     fairly easy to fix.  Yes, the use of a global here is rather ugly.  */
d997 1
d999 22
a1020 1
  for_each_inferior (&all_threads, linux_continue_one_thread);
@


1.25
log
@	* configure.in: Check whether we need to prototype strerror.
	* server.h: Optionally prototype strerror.
	* gdbreplay.c (perror_with_name): Use strerror.
	* linux-low.c (linux_attach_lwp): Use strerror.
	* utils.c (perror_with_name): Use strerror.
	* config.in, configure: Regenerated.
@
text
@d55 1
a55 1
static void linux_resume (int step, int signal);
d655 6
a660 1
	linux_resume (0, 0);
d876 9
a884 5
/* This function is called once per process other than the first
   one.  The first process we are told the signal to continue
   with, and whether to step or continue; for all others, any
   existing signals will be marked in status_pending_p to be
   reported momentarily, and we preserve the stepping flag.  */
d886 1
a886 1
linux_continue_one_process (struct inferior_list_entry *entry)
d889 17
d907 1
a907 2
  process = (struct process_info *) entry;
  linux_resume_one_process (entry, process->stepping, 0);
d911 1
a911 1
linux_resume (int step, int signal)
d913 2
a914 7
  struct process_info *process;

  process = get_thread_process (current_inferior);

  /* If the current process has a status pending, this signal will
     be enqueued and sent later.  */
  linux_resume_one_process (&process->head, step, signal);
d916 2
a917 2
  if (cont_thread == 0 || cont_thread == -1)
    for_each_inferior (&all_processes, linux_continue_one_process);
@


1.25.4.1
log
@merge mainline chenges into branch
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a36 1
#include <errno.h>
d55 1
a55 1
static void linux_resume (struct thread_resume *resume_info);
d72 2
a318 1
  event_child->pending_is_breakpoint = 0;
d599 1
a599 1
         clear the stepping flag; in general this does not matter,
d655 1
a655 6
	{
	  struct thread_resume resume_info;
	  resume_info.thread = -1;
	  resume_info.step = resume_info.sig = resume_info.leave_stopped = 0;
	  linux_resume (&resume_info);
	}
a658 1
  unblock_async_io ();
d838 1
a838 1
  if (debug_threads && the_low_target.get_pc != NULL)
d871 5
a875 9
static struct thread_resume *resume_ptr;

/* This function is called once per thread.  We look up the thread
   in RESUME_PTR, and mark the thread with a pointer to the appropriate
   resume request.

   This algorithm is O(threads * resume elements), but resume elements
   is small (and will remain small at least until GDB supports thread
   suspension).  */
d877 1
a877 1
linux_set_resume_request (struct inferior_list_entry *entry)
a879 5
  struct thread_info *thread;
  int ndx;

  thread = (struct thread_info *) entry;
  process = get_thread_process (thread);
d881 2
a882 5
  ndx = 0;
  while (resume_ptr[ndx].thread != -1 && resume_ptr[ndx].thread != entry->id)
    ndx++;

  process->resume = &resume_ptr[ndx];
a884 6
/* This function is called once per thread.  We check the thread's resume
   request, which will tell us whether to resume, step, or leave the thread
   stopped; and what signal, if any, it should be sent.  For threads which
   we aren't explicitly told otherwise, we preserve the stepping flag; this
   is used for stepping over gdbserver-placed breakpoints.  */

d886 1
a886 1
linux_continue_one_thread (struct inferior_list_entry *entry)
a888 8
  struct thread_info *thread;
  int step;

  thread = (struct thread_info *) entry;
  process = get_thread_process (thread);

  if (process->resume->leave_stopped)
    return;
d890 1
a890 4
  if (process->resume->thread == -1)
    step = process->stepping || process->resume->step;
  else
    step = process->resume->step;
d892 3
a894 1
  linux_resume_one_process (&process->head, step, process->resume->sig);
d896 2
a897 96
  process->resume = NULL;
}

/* This function is called once per thread.  We check the thread's resume
   request, which will tell us whether to resume, step, or leave the thread
   stopped; and what signal, if any, it should be sent.  We queue any needed
   signals, since we won't actually resume.  We already have a pending event
   to report, so we don't need to preserve any step requests; they should
   be re-issued if necessary.  */

static void
linux_queue_one_thread (struct inferior_list_entry *entry)
{
  struct process_info *process;
  struct thread_info *thread;

  thread = (struct thread_info *) entry;
  process = get_thread_process (thread);

  if (process->resume->leave_stopped)
    return;

  /* If we have a new signal, enqueue the signal.  */
  if (process->resume->sig != 0)
    {
      struct pending_signals *p_sig;
      p_sig = malloc (sizeof (*p_sig));
      p_sig->prev = process->pending_signals;
      p_sig->signal = process->resume->sig;
      process->pending_signals = p_sig;
    }

  process->resume = NULL;
}

/* Set DUMMY if this process has an interesting status pending.  */
static int
resume_status_pending_p (struct inferior_list_entry *entry, void *flag_p)
{
  struct process_info *process = (struct process_info *) entry;

  /* Processes which will not be resumed are not interesting, because
     we might not wait for them next time through linux_wait.  */
  if (process->resume->leave_stopped)
    return 0;

  /* If this thread has a removed breakpoint, we won't have any
     events to report later, so check now.  check_removed_breakpoint
     may clear status_pending_p.  We avoid calling check_removed_breakpoint
     for any thread that we are not otherwise going to resume - this
     lets us preserve stopped status when two threads hit a breakpoint.
     GDB removes the breakpoint to single-step a particular thread
     past it, then re-inserts it and resumes all threads.  We want
     to report the second thread without resuming it in the interim.  */
  if (process->status_pending_p)
    check_removed_breakpoint (process);

  if (process->status_pending_p)
    * (int *) flag_p = 1;

  return 0;
}

static void
linux_resume (struct thread_resume *resume_info)
{
  int pending_flag;

  /* Yes, the use of a global here is rather ugly.  */
  resume_ptr = resume_info;

  for_each_inferior (&all_threads, linux_set_resume_request);

  /* If there is a thread which would otherwise be resumed, which
     has a pending status, then don't resume any threads - we can just
     report the pending status.  Make sure to queue any signals
     that would otherwise be sent.  */
  pending_flag = 0;
  find_inferior (&all_processes, resume_status_pending_p, &pending_flag);

  if (debug_threads)
    {
      if (pending_flag)
	fprintf (stderr, "Not resuming, pending status\n");
      else
	fprintf (stderr, "Resuming, no pending status\n");
    }

  if (pending_flag)
    for_each_inferior (&all_threads, linux_queue_one_thread);
  else
    {
      block_async_io ();
      enable_async_io ();
      for_each_inferior (&all_threads, linux_continue_one_thread);
    }
d1156 1
a1156 1
static int
d1163 2
a1164 2
  register int count
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
d1167 1
a1167 1
  register PTRACE_XFER_TYPE *buffer
a1172 1
      errno = 0;
a1173 2
      if (errno)
	return errno;
a1177 2

  return 0;
a1260 26
/* Copy LEN bytes from inferior's auxiliary vector starting at OFFSET
   to debugger memory starting at MYADDR.  */

static int
linux_read_auxv (CORE_ADDR offset, char *myaddr, unsigned int len)
{
  char filename[PATH_MAX];
  int fd, n;

  snprintf (filename, sizeof filename, "/proc/%d/auxv", inferior_pid);

  fd = open (filename, O_RDONLY);
  if (fd < 0)
    return -1;

  if (offset != (CORE_ADDR) 0
      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)
    n = -1;
  else
    n = read (fd, myaddr, len);

  close (fd);

  return n;
}

a1275 1
  linux_read_auxv,
@


1.24
log
@gdb/
        * NEWS: Mention gdbserver detach change and "disconnect" command.
        * infcmd.c (disconnect_command): New function.
        (_initialize_infcmd): Add ``disconnect'' command.
        * remote.c (remote_async_detach): Delete.
        (remote_detach): Merge remote_async_detach.
        (remote_disconnect): New.
        (init_remote_ops): Set to_disconnect.
        (init_remote_cisco_ops): Likewise.
        (init_remote_async_ops): Likewise.  Use remote_detach.
        * target.c (cleanup_target): Default to_disconnect.
        (update_current_target): Inherit to_disconnect.
        (target_disconnect, debug_to_disconnect): New functions.
        (setup_target_debug): Set to_disconnect.
        * target.h (struct target_ops): Add to_disconnect.
        (target_disconnect): Add prototype.
gdbserver/
	* linux-low.c: Move comment to linux_thread_alive where it belonged.
	(linux_detach_one_process, linux_detach): New functions.
	(linux_target_ops): Add linux_detach.
	* server.c (main): Handle 'D' packet.
	* target.h (struct target_ops): Add "detach" member.
	(detach_inferior): Define.
mi/
        * mi-cmds.c (mi_cmds): Add "-target-disconnect".
@
text
@d178 1
a178 2
	       errno < sys_nerr ? sys_errlist[errno] : "unknown error",
	       errno);
@


1.24.2.1
log
@	* configure.in: Check whether we need to prototype strerror.
	* server.h: Optionally prototype strerror.
	* gdbreplay.c (perror_with_name): Use strerror.
	* linux-low.c (linux_attach_lwp): Use strerror.
	* utils.c (perror_with_name): Use strerror.
	* config.in, configure: Regenerated.
@
text
@d178 2
a179 1
	       strerror (errno), errno);
@


1.23
log
@	* linux-low.c (linux_wait_for_event): Correct comment typos.
	(linux_resume_one_process): Call check_removed_breakpoint.
	(linux_send_signal): New function.
	(linux_target_ops): Add linux_send_signal.
	* remote-utils.c (putpkt, input_interrupt): Use send_signal instead
	of kill.
	* target.h (struct target_ops): Add send_signal.
@
text
@a236 1
/* Return nonzero if the given thread is still alive.  */
d243 16
d1267 1
@


1.22
log
@* linux-low.c (usr_store_inferior_registers): Transfer buf in
PTRACE_XFER_TYPE-sized chunks, not int-sized chunks.  Otherwise,
if 'int' is smaller than PTRACE_XFER_TYPE, you end up throwing
away part of the register's value.
@
text
@d402 1
a402 1
     (in check_removed_breakpoints); signals should be reported anyway.  */
d544 1
a544 1
	     breakpoint, so that check_removed_breakpoints () will do the PC
d590 1
a590 1
	 is check_removed_breakpoints, and pending_is_breakpoint is not
d789 1
a789 1
  if (process->status_pending_p)
d1231 16
d1260 1
@


1.21
log
@	* linux-low.c (linux_create_inferior): Use __SIGRTMIN.
	(linux_wait_for_event, linux_init_signals): Likewise.
@
text
@d979 1
a979 1
		  *(int *) (buf + i));
d992 1
a992 1
	  regaddr += sizeof (int);
@


1.21.14.1
log
@* linux-low.c (usr_store_inferior_registers): Transfer buf in
PTRACE_XFER_TYPE-sized chunks, not int-sized chunks.  Otherwise,
if 'int' is smaller than PTRACE_XFER_TYPE, you end up throwing
away part of the register's value.
@
text
@d979 1
a979 1
		  *(PTRACE_XFER_TYPE *) (buf + i));
@


1.21.14.2
log
@Revert patch for revision.
@
text
@d979 1
a979 1
		  *(int *) (buf + i));
@


1.21.14.3
log
@* linux-low.c (usr_store_inferior_registers): Transfer buf in
PTRACE_XFER_TYPE-sized chunks, not int-sized chunks.  Otherwise,
if 'int' is smaller than PTRACE_XFER_TYPE, you end up throwing
away part of the register's value.
@
text
@d979 1
a979 1
		  *(PTRACE_XFER_TYPE *) (buf + i));
d992 1
a992 1
	  regaddr += sizeof (PTRACE_XFER_TYPE);
@


1.20
log
@	* linux-arm-low.c (arm_num_regs): Increase.
	(arm_regmap): Include status register.

	* linux-low.c (register_addr): Remove incorrect -1 check.
@
text
@d150 1
a150 1
      signal (SIGRTMIN + 1, SIG_DFL);
d496 2
a497 2
	      && (WSTOPSIG (wstat) == SIGRTMIN
		  || WSTOPSIG (wstat) == SIGRTMIN + 1))
d1251 1
a1251 1
  signal (SIGRTMIN+1, SIG_IGN);
@


1.19
log
@        * linux-low.c (linux_create_inferior): Call setpgid.  Return
        the new PID.
        (unstopped_p, linux_signal_pid): Remove.
        (linux_target_ops): Remove linux_signal_pid.
        * remote-utils.c (putpkt, input_interrupt): Use signal_pid
        global instead of target method.
        * target.h (struct target_ops): Remove signal_pid.  Update comment
        for create_inferior.
        * server.c (signal_pid): New variable.
        (create_inferior): Set signal_pid.  Block SIGTTOU and SIGTTIN in
        gdbserver.  Set the child to be the foreground process group.
        (attach_inferior): Set signal_pid.
@
text
@a896 2
  if (addr == -1)
    addr = 0;
@


1.19.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d55 1
a55 1
static void linux_resume (struct thread_resume *resume_info);
d150 1
a150 1
      signal (__SIGRTMIN + 1, SIG_DFL);
d178 2
a179 1
	       strerror (errno), errno);
d237 1
a243 16
static void
linux_detach_one_process (struct inferior_list_entry *entry)
{
  struct thread_info *thread = (struct thread_info *) entry;
  struct process_info *process = get_thread_process (thread);

  ptrace (PTRACE_DETACH, pid_of (process), 0, 0);
}

static void
linux_detach (void)
{
  for_each_inferior (&all_threads, linux_detach_one_process);
}

/* Return nonzero if the given thread is still alive.  */
d402 1
a402 1
     (in check_removed_breakpoint); signals should be reported anyway.  */
d496 2
a497 2
	      && (WSTOPSIG (wstat) == __SIGRTMIN
		  || WSTOPSIG (wstat) == __SIGRTMIN + 1))
d544 1
a544 1
	     breakpoint, so that check_removed_breakpoint () will do the PC
d590 1
a590 1
	 is check_removed_breakpoint, and pending_is_breakpoint is not
d641 1
a641 6
	{
	  struct thread_resume resume_info;
	  resume_info.thread = -1;
	  resume_info.step = resume_info.sig = resume_info.leave_stopped = 0;
	  linux_resume (&resume_info);
	}
d789 1
a789 1
  if (process->status_pending_p && !check_removed_breakpoint (process))
d857 5
a861 9
static struct thread_resume *resume_ptr;

/* This function is called once per thread.  We look up the thread
   in RESUME_PTR, which will tell us whether to resume, step, or leave
   the thread stopped; and what signal, if any, it should be sent.
   For threads which we aren't explicitly told otherwise, we preserve
   the stepping flag; this is used for stepping over gdbserver-placed
   breakpoints.  If the thread has a status pending, it may not actually
   be resumed.  */
d863 1
a863 1
linux_continue_one_thread (struct inferior_list_entry *entry)
a865 5
  struct thread_info *thread;
  int ndx, step;

  thread = (struct thread_info *) entry;
  process = get_thread_process (thread);
d867 2
a868 13
  ndx = 0;
  while (resume_ptr[ndx].thread != -1 && resume_ptr[ndx].thread != entry->id)
    ndx++;

  if (resume_ptr[ndx].leave_stopped)
    return;

  if (resume_ptr[ndx].thread == -1)
    step = process->stepping || resume_ptr[ndx].step;
  else
    step = resume_ptr[ndx].step;

  linux_resume_one_process (&process->head, step, resume_ptr[ndx].sig);
d872 1
a872 1
linux_resume (struct thread_resume *resume_info)
d874 3
a876 2
  /* Yes, this is quadratic.  If it ever becomes a problem then it's
     fairly easy to fix.  Yes, the use of a global here is rather ugly.  */
d878 6
a883 2
  resume_ptr = resume_info;
  for_each_inferior (&all_threads, linux_continue_one_thread);
d897 2
d981 1
a981 1
		  *(PTRACE_XFER_TYPE *) (buf + i));
d994 1
a994 1
	  regaddr += sizeof (PTRACE_XFER_TYPE);
a1232 16
static void
linux_send_signal (int signum)
{
  extern int signal_pid;

  if (cont_thread > 0)
    {
      struct process_info *process;

      process = get_thread_process (current_inferior);
      kill (process->lwpid, signum);
    }
  else
    kill (signal_pid, signum);
}

a1237 1
  linux_detach,
a1245 1
  linux_send_signal,
d1253 1
a1253 1
  signal (__SIGRTMIN+1, SIG_IGN);
@


1.19.6.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a318 1
  event_child->pending_is_breakpoint = 0;
d879 6
a884 6
   in RESUME_PTR, and mark the thread with a pointer to the appropriate
   resume request.

   This algorithm is O(threads * resume elements), but resume elements
   is small (and will remain small at least until GDB supports thread
   suspension).  */
d886 1
a886 1
linux_set_resume_request (struct inferior_list_entry *entry)
d890 1
a890 1
  int ndx;
d899 1
a899 20
  process->resume = &resume_ptr[ndx];
}

/* This function is called once per thread.  We check the thread's resume
   request, which will tell us whether to resume, step, or leave the thread
   stopped; and what signal, if any, it should be sent.  For threads which
   we aren't explicitly told otherwise, we preserve the stepping flag; this
   is used for stepping over gdbserver-placed breakpoints.  */

static void
linux_continue_one_thread (struct inferior_list_entry *entry)
{
  struct process_info *process;
  struct thread_info *thread;
  int step;

  thread = (struct thread_info *) entry;
  process = get_thread_process (thread);

  if (process->resume->leave_stopped)
d902 2
a903 2
  if (process->resume->thread == -1)
    step = process->stepping || process->resume->step;
d905 1
a905 3
    step = process->resume->step;

  linux_resume_one_process (&process->head, step, process->resume->sig);
d907 1
a907 61
  process->resume = NULL;
}

/* This function is called once per thread.  We check the thread's resume
   request, which will tell us whether to resume, step, or leave the thread
   stopped; and what signal, if any, it should be sent.  We queue any needed
   signals, since we won't actually resume.  We already have a pending event
   to report, so we don't need to preserve any step requests; they should
   be re-issued if necessary.  */

static void
linux_queue_one_thread (struct inferior_list_entry *entry)
{
  struct process_info *process;
  struct thread_info *thread;

  thread = (struct thread_info *) entry;
  process = get_thread_process (thread);

  if (process->resume->leave_stopped)
    return;

  /* If we have a new signal, enqueue the signal.  */
  if (process->resume->sig != 0)
    {
      struct pending_signals *p_sig;
      p_sig = malloc (sizeof (*p_sig));
      p_sig->prev = process->pending_signals;
      p_sig->signal = process->resume->sig;
      process->pending_signals = p_sig;
    }

  process->resume = NULL;
}

/* Set DUMMY if this process has an interesting status pending.  */
static int
resume_status_pending_p (struct inferior_list_entry *entry, void *flag_p)
{
  struct process_info *process = (struct process_info *) entry;

  /* Processes which will not be resumed are not interesting, because
     we might not wait for them next time through linux_wait.  */
  if (process->resume->leave_stopped)
    return 0;

  /* If this thread has a removed breakpoint, we won't have any
     events to report later, so check now.  check_removed_breakpoint
     may clear status_pending_p.  We avoid calling check_removed_breakpoint
     for any thread that we are not otherwise going to resume - this
     lets us preserve stopped status when two threads hit a breakpoint.
     GDB removes the breakpoint to single-step a particular thread
     past it, then re-inserts it and resumes all threads.  We want
     to report the second thread without resuming it in the interim.  */
  if (process->status_pending_p)
    check_removed_breakpoint (process);

  if (process->status_pending_p)
    * (int *) flag_p = 1;

  return 0;
d913 2
a914 1
  int pending_flag;
a915 1
  /* Yes, the use of a global here is rather ugly.  */
d917 1
a917 22

  for_each_inferior (&all_threads, linux_set_resume_request);

  /* If there is a thread which would otherwise be resumed, which
     has a pending status, then don't resume any threads - we can just
     report the pending status.  Make sure to queue any signals
     that would otherwise be sent.  */
  pending_flag = 0;
  find_inferior (&all_processes, resume_status_pending_p, &pending_flag);

  if (debug_threads)
    {
      if (pending_flag)
	fprintf (stderr, "Not resuming, pending status\n");
      else
	fprintf (stderr, "Resuming, no pending status\n");
    }

  if (pending_flag)
    for_each_inferior (&all_threads, linux_queue_one_thread);
  else
    for_each_inferior (&all_threads, linux_continue_one_thread);
@


1.19.4.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d897 2
@


1.19.4.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d150 1
a150 1
      signal (__SIGRTMIN + 1, SIG_DFL);
d496 2
a497 2
	      && (WSTOPSIG (wstat) == __SIGRTMIN
		  || WSTOPSIG (wstat) == __SIGRTMIN + 1))
d1251 1
a1251 1
  signal (__SIGRTMIN+1, SIG_IGN);
@


1.19.4.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d237 1
a243 16
static void
linux_detach_one_process (struct inferior_list_entry *entry)
{
  struct thread_info *thread = (struct thread_info *) entry;
  struct process_info *process = get_thread_process (thread);

  ptrace (PTRACE_DETACH, pid_of (process), 0, 0);
}

static void
linux_detach (void)
{
  for_each_inferior (&all_threads, linux_detach_one_process);
}

/* Return nonzero if the given thread is still alive.  */
d402 1
a402 1
     (in check_removed_breakpoint); signals should be reported anyway.  */
d544 1
a544 1
	     breakpoint, so that check_removed_breakpoint () will do the PC
d590 1
a590 1
	 is check_removed_breakpoint, and pending_is_breakpoint is not
d789 1
a789 1
  if (process->status_pending_p && !check_removed_breakpoint (process))
d979 1
a979 1
		  *(PTRACE_XFER_TYPE *) (buf + i));
d992 1
a992 1
	  regaddr += sizeof (PTRACE_XFER_TYPE);
a1230 16
static void
linux_send_signal (int signum)
{
  extern int signal_pid;

  if (cont_thread > 0)
    {
      struct process_info *process;

      process = get_thread_process (current_inferior);
      kill (process->lwpid, signum);
    }
  else
    kill (signal_pid, signum);
}

a1235 1
  linux_detach,
a1243 1
  linux_send_signal,
@


1.19.4.4
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d178 2
a179 1
	       strerror (errno), errno);
@


1.19.4.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d55 1
a55 1
static void linux_resume (struct thread_resume *resume_info);
d655 1
a655 6
	{
	  struct thread_resume resume_info;
	  resume_info.thread = -1;
	  resume_info.step = resume_info.sig = resume_info.leave_stopped = 0;
	  linux_resume (&resume_info);
	}
d871 5
a875 9
static struct thread_resume *resume_ptr;

/* This function is called once per thread.  We look up the thread
   in RESUME_PTR, which will tell us whether to resume, step, or leave
   the thread stopped; and what signal, if any, it should be sent.
   For threads which we aren't explicitly told otherwise, we preserve
   the stepping flag; this is used for stepping over gdbserver-placed
   breakpoints.  If the thread has a status pending, it may not actually
   be resumed.  */
d877 1
a877 1
linux_continue_one_thread (struct inferior_list_entry *entry)
a879 17
  struct thread_info *thread;
  int ndx, step;

  thread = (struct thread_info *) entry;
  process = get_thread_process (thread);

  ndx = 0;
  while (resume_ptr[ndx].thread != -1 && resume_ptr[ndx].thread != entry->id)
    ndx++;

  if (resume_ptr[ndx].leave_stopped)
    return;

  if (resume_ptr[ndx].thread == -1)
    step = process->stepping || resume_ptr[ndx].step;
  else
    step = resume_ptr[ndx].step;
d881 2
a882 1
  linux_resume_one_process (&process->head, step, resume_ptr[ndx].sig);
d886 1
a886 1
linux_resume (struct thread_resume *resume_info)
d888 7
a894 2
  /* Yes, this is quadratic.  If it ever becomes a problem then it's
     fairly easy to fix.  Yes, the use of a global here is rather ugly.  */
d896 2
a897 2
  resume_ptr = resume_info;
  for_each_inferior (&all_threads, linux_continue_one_thread);
@


1.19.2.1
log
@	* linux-arm-low.c (arm_num_regs): Increase.
	(arm_regmap): Include status register.

	* linux-low.c (register_addr): Remove incorrect -1 check.
@
text
@d897 2
@


1.18
log
@2002-07-18  Michal Ludvig  <mludvig@@suse.cz>

	* linux-low.c (regsets_store_inferior_registers): Add free()
	at the end of a loop to prevent memory leak.
	* linux-x86-64-low.c (x86_64_regmap): Add CS, SS registers.
	(X86_64_NUM_GREGS): Count it from the size of x86_64_regmap.
@
text
@d152 2
d165 1
a165 1
  return 0;
a1232 28
/* Return 1 if this process is not stopped.  */
static int
unstopped_p (struct inferior_list_entry *entry, void *dummy)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->stopped)
    return 0;

  return 1;
}

static int
linux_signal_pid ()
{
  struct inferior_list_entry *process;

  process = find_inferior (&all_processes, unstopped_p, NULL);

  if (process == NULL)
    {
      warning ("no unstopped process");
      return inferior_pid;
    }

  return pid_of ((struct process_info *) process);
}

a1245 1
  linux_signal_pid,
@


1.17
log
@2002-06-11  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbserver/thread-db.c: New file.
	* gdbserver/proc-service.c: New file.
	* gdbserver/acinclude.m4: New file.
	* gdbserver/Makefile.in: Add GDBSERVER_LIBS, gdb_proc_service_h,
	proc-service.o, and thread-db.o.
	(linux-low.o): Add USE_THREAD_DB.
	* gdbserver/acconfig.h: Add HAVE_PRGREGSET_T, HAVE_PRFPREGSET_T,
	HAVE_LWPID_T, HAVE_PSADDR_T, and PRFPREGSET_T_BROKEN.
	* gdbserver/aclocal.m4: Regenerated.
	* gdbserver/config.in: Regenerated.
	* gdbserver/configure: Regenerated.
	* gdbserver/configure.in: Check for proc_service.h, sys/procfs.h,
	thread_db.h, and linux/elf.h headrs.
	Check for lwpid_t, psaddr_t, prgregset_t, prfpregset_t, and
	PRFPREGSET_T_BROKEN.  Introduce srv_thread_depfiles and USE_THREAD_DB.
	Check for -lthread_db and thread support.
	* gdbserver/configure.srv: Enable thread_db support for ARM, i386, MIPS,
	PowerPC, and SuperH.
	* gdbserver/i387-fp.c: Constify arguments.
	* gdbserver/i387-fp.h: Likewise.
	* gdbserver/inferiors.c: (struct thread_info): Renamed from
	`struct inferior_info'.  Remove PID member.  Use generic inferior
	list header.  All uses updated.
	(inferiors, signal_pid): Removed.
	(all_threads): New variable.
	(get_thread): Define.
	(add_inferior_to_list): New function.
	(for_each_inferior): New function.
	(change_inferior_id): New function.
	(add_inferior): Removed.
	(remove_inferior): New function.
	(add_thread): New function.
	(free_one_thread): New function.
	(remove_thread): New function.
	(clear_inferiors): Use for_each_inferior and free_one_thread.
	(find_inferior): New function.
	(find_inferior_id): New function.
	(inferior_target_data): Update argument type.
	(set_inferior_target_data): Likewise.
	(inferior_regcache_data): Likewise.
	(set_inferior_regcache_data): Likewise.
	* gdbserver/linux-low.c (linux_bp_reinsert): Remove.
	(all_processes, stopping_threads, using_thrads)
	(struct pending_signals, debug_threads, pid_of): New.
	(inferior_pid): Replace with macro.
	(struct inferior_linux_data): Remove.
	(get_stop_pc, add_process): New functions.
	(linux_create_inferior): Restore SIGRTMIN+1 before calling exec.
	Use add_process and add_thread.
	(linux_attach_lwp): New function, based on old linux_attach.  Use
	add_process and add_thread.  Set stop_expected for new threads.
	(linux_attach): New function.
	(linux_kill_one_process): New function.
	(linux_kill): Kill all LWPs.
	(linux_thread_alive): Use find_inferior_id.
	(check_removed_breakpoints, status_pending_p): New functions.
	(linux_wait_for_process): Renamed from linux_wait_for_one_inferior.
	Update.  Use WNOHANG.  Wait for cloned processes also.  Update process
	struct for the found process.
	(linux_wait_for_event): New function.
	(linux_wait): Use it.  Support LWPs.
	(send_sigstop, wait_for_sigstop, stop_all_processes)
	(linux_resume_one_process, linux_continue_one_process): New functions.
	(linux_resume): Support LWPs.
	(REGISTER_RAW_SIZE): Remove.
	(fetch_register): Use register_size instead.  Call supply_register.
	(usr_store_inferior_registers): Likewise.  Call collect_register.
	Fix recursive case.
	(regsets_fetch_inferior_registers): Improve error message.
	(regsets_store_inferior_registers): Add debugging.
	(linux_look_up_symbols): Call thread_db_init if USE_THREAD_DB.
	(unstopped_p, linux_signal_pid): New functions.
	(linux_target_ops): Add linux_signal_pid.
	(linux_init_signals): New function.
	(initialize_low): Call it.  Initialize using_threads.
	* gdbserver/regcache.c (inferior_regcache_data): Add valid
	flag.
	(get_regcache): Fetch registers lazily.  Add fetch argument
	and update all callers.
	(regcache_invalidate_one, regcache_invalidate): New
	functions.
	(new_register_cache): Renamed from create_register_cache.
	Return the new regcache.
	(free_register_cache): Change argument to a void *.
	(registers_to_string, registers_from_string): Call get_regcache
	with fetch flag set.
	(register_data): Make static.  Pass fetch flag to get_regcache.
	(supply_register): Call get_regcache with fetch flag clear.
	(collect_register): Call get_regcache with fetch flag set.
	(collect_register_as_string): New function.
	* gdbserver/regcache.h: Update.
	* gdbserver/remote-utils.c (putpkt): Flush after debug output and use
	stderr.
	Handle input interrupts while waiting for an ACK.
	(input_interrupt): Use signal_pid method.
	(getpkt): Flush after debug output and use stderr.
	(outreg): Use collect_register_as_string.
	(new_thread_notify, dead_thread_notify): New functions.
	(prepare_resume_reply): Check using_threads.  Set thread_from_wait
	and general_thread.
	(look_up_one_symbol): Flush after debug output.
	* gdbserver/server.c (step_thread, server_waiting): New variables.
	(start_inferior): Don't use signal_pid.  Update call to mywait.
	(attach_inferior): Update call to mywait.
	(handle_query): Handle qfThreadInfo and qsThreadInfo.
	(main): Don't fetch/store registers explicitly.  Use
	set_desired_inferior.  Support proposed ``Hs'' packet.  Update
	calls to mywait.
	* gdbserver/server.h: Update.
	(struct inferior_list, struct_inferior_list_entry): New.
	* gdbserver/target.c (set_desired_inferior): New.
	(write_inferior_memory): Constify.
	(mywait): New function.
	* gdbserver/target.h: Update.
	(struct target_ops): New signal_pid method.
	(mywait): Removed macro, added prototype.

	* gdbserver/linux-low.h (regset_func): Removed.
	(regset_fill_func, regset_store_func): New.
	(enum regset_type): New.
	(struct regset_info): Add type field.  Use new operation types.
	(struct linux_target_ops): stop_pc renamed to get_pc.
	Add decr_pc_after_break and breakpoint_at.
	(get_process, get_thread_proess, get_process_thread)
	(strut process_info, all_processes, linux_attach_lwp)
	(thread_db_init): New.

	* gdbserver/linux-arm-low.c (arm_get_pc, arm_set_pc,
	arm_breakpoint, arm_breakpoint_len, arm_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-i386-low.c (i386_store_gregset, i386_store_fpregset)
	(i386_store_fpxregset): Constify.
	(target_regsets): Add new kind identifier.
	(i386_get_pc): Renamed from i386_stop_pc.  Simplify.
	(i386_set_pc): Add debugging.
	(i386_breakpoint_at): New function.
	(the_low_target): Add new members.
	* gdbserver/linux-mips-low.c (mips_get_pc, mips_set_pc)
	(mips_breakpoint, mips_breakpoint_len, mips_reinsert_addr)
	(mips_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-ppc-low.c (ppc_get_pc, ppc_set_pc)
	(ppc_breakpoint, ppc_breakpoint_len, ppc_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-sh-low.c (sh_get_pc, sh_set_pc)
	(sh_breakpoint, sh_breakpoint_len, sh_breakpoint_at): New.
	(the_low_target): Add new members.
	* gdbserver/linux-x86-64-low.c (target_regsets): Add new kind
	identifier.
@
text
@d1100 1
@


1.16
log
@2002-04-24  Michal Ludvig  <mludvig@@suse.cz>

	* gdbserver/linux-low.c (regsets_fetch_inferior_registers),
	(regsets_store_inferior_registers): Removed cast to int from
	ptrace() calls.
	* gdbserver/regcache.h: Added declaration of struct inferior_info.
@
text
@d38 3
a40 1
static CORE_ADDR linux_bp_reinsert;
d42 13
d56 8
d74 3
a76 1
static int inferior_pid;
d78 38
a115 1
struct inferior_linux_data
d117 15
a131 2
  int pid;
};
d139 1
a139 1
  struct inferior_linux_data *tdata;
d150 2
d160 2
a161 4
  add_inferior (pid);
  tdata = (struct inferior_linux_data *) malloc (sizeof (*tdata));
  tdata->pid = pid;
  set_inferior_target_data (current_inferior, tdata);
a162 2
  /* FIXME remove */
  inferior_pid = pid;
d168 2
a169 2
static int
linux_attach (int pid)
d171 1
a171 1
  struct inferior_linux_data *tdata;
d179 5
a183 1
      _exit (0177);
d186 28
a213 4
  add_inferior (pid);
  tdata = (struct inferior_linux_data *) malloc (sizeof (*tdata));
  tdata->pid = pid;
  set_inferior_target_data (current_inferior, tdata);
d220 17
d239 10
a248 5
  if (inferior_pid == 0)
    return;
  ptrace (PTRACE_KILL, inferior_pid, 0, 0);
  wait (0);
  clear_inferiors ();
d251 3
a253 1
/* Return nonzero if the given thread is still alive.  */
d255 1
a255 1
linux_thread_alive (int pid)
d257 50
d310 2
d313 22
a334 1
linux_wait_for_one_inferior (struct inferior_info *child)
d336 5
a340 2
  struct inferior_linux_data *child_data = inferior_target_data (child);
  int pid, wstat;
d344 9
a352 1
      pid = waitpid (child_data->pid, &wstat, 0);
d354 1
a354 2
      if (pid != child_data->pid)
	perror_with_name ("wait");
d356 1
a356 4
      /* If this target supports breakpoints, see if we hit one.  */
      if (the_low_target.stop_pc != NULL
	  && WIFSTOPPED (wstat)
	  && WSTOPSIG (wstat) == SIGTRAP)
d358 14
a371 1
	  CORE_ADDR stop_pc;
d373 81
a453 1
	  if (linux_bp_reinsert != 0)
d455 21
a475 3
	      reinsert_breakpoint (linux_bp_reinsert);
	      linux_bp_reinsert = 0;
	      linux_resume (0, 0);
d479 11
a489 2
	  fetch_inferior_registers (0);
	  stop_pc = (*the_low_target.stop_pc) ();
d491 5
a495 1
	  if (check_breakpoints (stop_pc) != 0)
d497 10
a506 2
	      if (the_low_target.set_pc != NULL)
		(*the_low_target.set_pc) (stop_pc);
d508 30
a537 12
	      if (the_low_target.breakpoint_reinsert_addr == NULL)
		{
		  linux_bp_reinsert = stop_pc;
		  uninsert_breakpoint (stop_pc);
		  linux_resume (1, 0);
		}
	      else
		{
		  reinsert_breakpoint_by_bp
		    (stop_pc, (*the_low_target.breakpoint_reinsert_addr) ());
		  linux_resume (0, 0);
		}
d539 37
a575 1
	      continue;
d577 31
d612 1
d617 1
a617 1
/* Wait for process, returns status */
d623 18
d643 2
a644 1
  w = linux_wait_for_one_inferior (current_inferior);
d647 13
a659 1
  if (WIFEXITED (w))
d661 14
a674 4
      fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
      *status = 'W';
      clear_inferiors ();
      return ((unsigned char) WEXITSTATUS (w));
d676 1
a676 1
  else if (!WIFSTOPPED (w))
d678 2
a679 4
      fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
      clear_inferiors ();
      *status = 'X';
      return ((unsigned char) WTERMSIG (w));
a681 2
  fetch_inferior_registers (0);

d686 73
d764 2
a765 1
linux_resume (int step, int signal)
d767 78
d846 5
a850 1
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, inferior_pid, 1, signal);
d855 28
a885 2
#define REGISTER_RAW_SIZE(regno) register_size((regno))

d907 1
d917 2
a918 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d921 1
a921 1
      *(PTRACE_XFER_TYPE *) (register_data (regno) + i) =
d935 2
d959 1
d973 3
a975 1
      for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d979 1
a979 1
		  *(int *) (register_data (regno) + i));
d997 1
a997 1
      store_inferior_registers (regno);
d1006 1
a1006 1
regsets_fetch_inferior_registers (void)
d1044 4
a1047 1
	      perror ("Warning: ptrace(regsets_fetch_inferior_registers)");
d1057 1
a1057 1
regsets_store_inferior_registers (void)
d1183 5
d1222 34
a1255 1
  /* Don't need to look up any symbols yet.  */
d1271 1
d1274 8
d1285 1
d1290 1
@


1.16.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d38 1
a38 3
/* ``all_threads'' is keyed by the LWP ID - it should be the thread ID instead,
   however.  This requires changing the ID in place when we go from !using_threads
   to using_threads, immediately.
a39 13
   ``all_processes'' is keyed by the process ID - which on Linux is (presently)
   the same as the LWP ID.  */

struct inferior_list all_processes;

/* FIXME this is a bit of a hack, and could be removed.  */
int stopping_threads;

/* FIXME make into a target method?  */
int using_threads;

static void linux_resume_one_process (struct inferior_list_entry *entry,
				      int step, int signal);
a40 8
static void stop_all_processes (void);
static int linux_wait_for_event (struct thread_info *child);

struct pending_signals
{
  int signal;
  struct pending_signals *prev;
};
d51 1
a51 3
int debug_threads = 0;

#define pid_of(proc) ((proc)->head.id)
d53 1
a53 27
/* FIXME: Delete eventually.  */
#define inferior_pid (pid_of (get_thread_process (current_inferior)))

/* This function should only be called if the process got a SIGTRAP.
   The SIGTRAP could mean several things.

   On i386, where decr_pc_after_break is non-zero:
   If we were single-stepping this process using PTRACE_SINGLESTEP,
   we will get only the one SIGTRAP (even if the instruction we
   stepped over was a breakpoint).  The value of $eip will be the
   next instruction.
   If we continue the process using PTRACE_CONT, we will get a
   SIGTRAP when we hit a breakpoint.  The value of $eip will be
   the instruction after the breakpoint (i.e. needs to be
   decremented).  If we report the SIGTRAP to GDB, we must also
   report the undecremented PC.  If we cancel the SIGTRAP, we
   must resume at the decremented PC.

   (Presumably, not yet tested) On a non-decr_pc_after_break machine
   with hardware or kernel single-step:
   If we single-step over a breakpoint instruction, our PC will
   point at the following instruction.  If we continue and hit a
   breakpoint instruction, our PC will point at the breakpoint
   instruction.  */

static CORE_ADDR
get_stop_pc (void)
d55 2
a56 26
  CORE_ADDR stop_pc = (*the_low_target.get_pc) ();

  if (get_thread_process (current_inferior)->stepping)
    return stop_pc;
  else
    return stop_pc - the_low_target.decr_pc_after_break;
}

static void *
add_process (int pid)
{
  struct process_info *process;

  process = (struct process_info *) malloc (sizeof (*process));
  memset (process, 0, sizeof (*process));

  process->head.id = pid;

  /* Default to tid == lwpid == pid.  */
  process->tid = pid;
  process->lwpid = pid;

  add_inferior_to_list (&all_processes, &process->head);

  return process;
}
d64 1
a64 1
  void *new_process;
a74 2
      signal (SIGRTMIN + 1, SIG_DFL);

d83 4
a86 2
  new_process = add_process (pid);
  add_thread (pid, new_process);
d88 2
d95 2
a96 2
void
linux_attach_lwp (int pid, int tid)
d98 1
a98 1
  struct process_info *new_process;
d106 1
a106 5

      /* If we fail to attach to an LWP, just return.  */
      if (!using_threads)
	_exit (0177);
      return;
d109 4
a112 28
  new_process = (struct process_info *) add_process (pid);
  add_thread (tid, new_process);

  /* The next time we wait for this LWP we'll see a SIGSTOP as PTRACE_ATTACH
     brings it to a halt.  We should ignore that SIGSTOP and resume the process
     (unless this is the first process, in which case the flag will be cleared
     in linux_attach).

     On the other hand, if we are currently trying to stop all threads, we
     should treat the new thread as if we had sent it a SIGSTOP.  This works
     because we are guaranteed that add_process added us to the end of the
     list, and so the new thread has not yet reached wait_for_sigstop (but
     will).  */
  if (! stopping_threads)
    new_process->stop_expected = 1;
}

int
linux_attach (int pid)
{
  struct process_info *process;

  linux_attach_lwp (pid, pid);

  /* Don't ignore the initial SIGSTOP if we just attached to this process.  */
  process = (struct process_info *) find_inferior_id (&all_processes, pid);
  process->stop_expected = 0;

d119 1
a119 1
linux_kill_one_process (struct inferior_list_entry *entry)
d121 5
a125 11
  struct thread_info *thread = (struct thread_info *) entry;
  struct process_info *process = get_thread_process (thread);
  int wstat;

  do
    {
      ptrace (PTRACE_KILL, pid_of (process), 0, 0);

      /* Make sure it died.  The loop is most likely unnecessary.  */
      wstat = linux_wait_for_event (thread);
    } while (WIFSTOPPED (wstat));
a128 18
static void
linux_kill (void)
{
  for_each_inferior (&all_threads, linux_kill_one_process);
}

static int
linux_thread_alive (int tid)
{
  if (find_inferior_id (&all_threads, tid) != NULL)
    return 1;
  else
    return 0;
}

/* Return nonzero if this process stopped at a breakpoint which
   no longer appears to be inserted.  Also adjust the PC
   appropriately to resume where the breakpoint used to be.  */
d130 1
a130 1
check_removed_breakpoint (struct process_info *event_child)
a131 50
  CORE_ADDR stop_pc;
  struct thread_info *saved_inferior;

  if (event_child->pending_is_breakpoint == 0)
    return 0;

  if (debug_threads)
    fprintf (stderr, "Checking for breakpoint.\n");

  saved_inferior = current_inferior;
  current_inferior = get_process_thread (event_child);

  stop_pc = get_stop_pc ();

  /* If the PC has changed since we stopped, then we shouldn't do
     anything.  This happens if, for instance, GDB handled the
     decr_pc_after_break subtraction itself.  */
  if (stop_pc != event_child->pending_stop_pc)
    {
      if (debug_threads)
	fprintf (stderr, "Ignoring, PC was changed.\n");

      event_child->pending_is_breakpoint = 0;
      current_inferior = saved_inferior;
      return 0;
    }

  /* If the breakpoint is still there, we will report hitting it.  */
  if ((*the_low_target.breakpoint_at) (stop_pc))
    {
      if (debug_threads)
	fprintf (stderr, "Ignoring, breakpoint is still present.\n");
      current_inferior = saved_inferior;
      return 0;
    }

  if (debug_threads)
    fprintf (stderr, "Removed breakpoint.\n");

  /* For decr_pc_after_break targets, here is where we perform the
     decrement.  We go immediately from this function to resuming,
     and can not safely call get_stop_pc () again.  */
  if (the_low_target.set_pc != NULL)
    (*the_low_target.set_pc) (stop_pc);

  /* We consumed the pending SIGTRAP.  */
  event_child->status_pending_p = 0;
  event_child->status_pending = 0;

  current_inferior = saved_inferior;
a134 2
/* Return 1 if this process has an interesting status pending.  This function
   may silently resume an inferior process.  */
d136 1
a136 22
status_pending_p (struct inferior_list_entry *entry, void *dummy)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->status_pending_p)
    if (check_removed_breakpoint (process))
      {
	/* This thread was stopped at a breakpoint, and the breakpoint
	   is now gone.  We were told to continue (or step...) all threads,
	   so GDB isn't trying to single-step past this breakpoint.
	   So instead of reporting the old SIGTRAP, pretend we got to
	   the breakpoint just after it was removed instead of just
	   before; resume the process.  */
	linux_resume_one_process (&process->head, 0, 0);
	return 0;
      }

  return process->status_pending_p;
}

static void
linux_wait_for_process (struct process_info **childp, int *wstatp)
d138 2
a139 5
  int ret;
  int to_wait_for = -1;

  if (*childp != NULL)
    to_wait_for = (*childp)->lwpid;
d143 1
a143 9
      ret = waitpid (to_wait_for, wstatp, WNOHANG);

      if (ret == -1)
	{
	  if (errno != ECHILD)
	    perror_with_name ("waitpid");
	}
      else if (ret > 0)
	break;
d145 2
a146 1
      ret = waitpid (to_wait_for, wstatp, WNOHANG | __WCLONE);
d148 4
a151 1
      if (ret == -1)
d153 1
a153 14
	  if (errno != ECHILD)
	    perror_with_name ("waitpid (WCLONE)");
	}
      else if (ret > 0)
	break;

      usleep (1000);
    }

  if (debug_threads
      && (!WIFSTOPPED (*wstatp)
	  || (WSTOPSIG (*wstatp) != 32
	      && WSTOPSIG (*wstatp) != 33)))
    fprintf (stderr, "Got an event from %d (%x)\n", ret, *wstatp);
d155 1
a155 81
  if (to_wait_for == -1)
    *childp = (struct process_info *) find_inferior_id (&all_processes, ret);

  (*childp)->stopped = 1;
  (*childp)->pending_is_breakpoint = 0;

  if (debug_threads
      && WIFSTOPPED (*wstatp))
    {
      current_inferior = (struct thread_info *)
	find_inferior_id (&all_threads, (*childp)->tid);
      /* For testing only; i386_stop_pc prints out a diagnostic.  */
      if (the_low_target.get_pc != NULL)
	get_stop_pc ();
    }
}

static int
linux_wait_for_event (struct thread_info *child)
{
  CORE_ADDR stop_pc;
  struct process_info *event_child;
  int wstat;

  /* Check for a process with a pending status.  */
  /* It is possible that the user changed the pending task's registers since
     it stopped.  We correctly handle the change of PC if we hit a breakpoint
     (in check_removed_breakpoints); signals should be reported anyway.  */
  if (child == NULL)
    {
      event_child = (struct process_info *)
	find_inferior (&all_processes, status_pending_p, NULL);
      if (debug_threads && event_child)
	fprintf (stderr, "Got a pending child %d\n", event_child->lwpid);
    }
  else
    {
      event_child = get_thread_process (child);
      if (event_child->status_pending_p
	  && check_removed_breakpoint (event_child))
	event_child = NULL;
    }

  if (event_child != NULL)
    {
      if (event_child->status_pending_p)
	{
	  if (debug_threads)
	    fprintf (stderr, "Got an event from pending child %d (%04x)\n",
		     event_child->lwpid, event_child->status_pending);
	  wstat = event_child->status_pending;
	  event_child->status_pending_p = 0;
	  event_child->status_pending = 0;
	  current_inferior = get_process_thread (event_child);
	  return wstat;
	}
    }

  /* We only enter this loop if no process has a pending wait status.  Thus
     any action taken in response to a wait status inside this loop is
     responding as soon as we detect the status, not after any pending
     events.  */
  while (1)
    {
      if (child == NULL)
	event_child = NULL;
      else
	event_child = get_thread_process (child);

      linux_wait_for_process (&event_child, &wstat);

      if (event_child == NULL)
	error ("event from unknown child");

      current_inferior = (struct thread_info *)
	find_inferior_id (&all_threads, event_child->tid);

      if (using_threads)
	{
	  /* Check for thread exit.  */
	  if (! WIFSTOPPED (wstat))
d157 3
a159 21
	      if (debug_threads)
		fprintf (stderr, "Thread %d (LWP %d) exiting\n",
			 event_child->tid, event_child->head.id);

	      /* If the last thread is exiting, just return.  */
	      if (all_threads.head == all_threads.tail)
		return wstat;

	      dead_thread_notify (event_child->tid);

	      remove_inferior (&all_processes, &event_child->head);
	      free (event_child);
	      remove_thread (current_inferior);
	      current_inferior = (struct thread_info *) all_threads.head;

	      /* If we were waiting for this particular child to do something...
		 well, it did something.  */
	      if (child != NULL)
		return wstat;

	      /* Wait for a more interesting event.  */
d163 2
a164 11
	  if (WIFSTOPPED (wstat)
	      && WSTOPSIG (wstat) == SIGSTOP
	      && event_child->stop_expected)
	    {
	      if (debug_threads)
		fprintf (stderr, "Expected stop.\n");
	      event_child->stop_expected = 0;
	      linux_resume_one_process (&event_child->head,
					event_child->stepping, 0);
	      continue;
	    }
d166 1
a166 5
	  /* FIXME drow/2002-06-09: Get signal numbers from the inferior's
	     thread library?  */
	  if (WIFSTOPPED (wstat)
	      && (WSTOPSIG (wstat) == SIGRTMIN
		  || WSTOPSIG (wstat) == SIGRTMIN + 1))
d168 2
a169 10
	      if (debug_threads)
		fprintf (stderr, "Ignored signal %d for %d (LWP %d).\n",
			 WSTOPSIG (wstat), event_child->tid,
			 event_child->head.id);
	      linux_resume_one_process (&event_child->head,
					event_child->stepping,
					WSTOPSIG (wstat));
	      continue;
	    }
	}
d171 12
a182 22
      /* If this event was not handled above, and is not a SIGTRAP, report
	 it.  */
      if (!WIFSTOPPED (wstat) || WSTOPSIG (wstat) != SIGTRAP)
	return wstat;

      /* If this target does not support breakpoints, we simply report the
	 SIGTRAP; it's of no concern to us.  */
      if (the_low_target.get_pc == NULL)
	return wstat;

      stop_pc = get_stop_pc ();

      /* bp_reinsert will only be set if we were single-stepping.
	 Notice that we will resume the process after hitting
	 a gdbserver breakpoint; single-stepping to/over one
	 is not supported (yet).  */
      if (event_child->bp_reinsert != 0)
	{
	  if (debug_threads)
	    fprintf (stderr, "Reinserted breakpoint.\n");
	  reinsert_breakpoint (event_child->bp_reinsert);
	  event_child->bp_reinsert = 0;
d184 1
a184 45
	  /* Clear the single-stepping flag and SIGTRAP as we resume.  */
	  linux_resume_one_process (&event_child->head, 0, 0);
	  continue;
	}

      if (debug_threads)
	fprintf (stderr, "Hit a (non-reinsert) breakpoint.\n");

      if (check_breakpoints (stop_pc) != 0)
	{
	  /* We hit one of our own breakpoints.  We mark it as a pending
	     breakpoint, so that check_removed_breakpoints () will do the PC
	     adjustment for us at the appropriate time.  */
	  event_child->pending_is_breakpoint = 1;
	  event_child->pending_stop_pc = stop_pc;

	  /* Now we need to put the breakpoint back.  We continue in the event
	     loop instead of simply replacing the breakpoint right away,
	     in order to not lose signals sent to the thread that hit the
	     breakpoint.  Unfortunately this increases the window where another
	     thread could sneak past the removed breakpoint.  For the current
	     use of server-side breakpoints (thread creation) this is
	     acceptable; but it needs to be considered before this breakpoint
	     mechanism can be used in more general ways.  For some breakpoints
	     it may be necessary to stop all other threads, but that should
	     be avoided where possible.

	     If breakpoint_reinsert_addr is NULL, that means that we can
	     use PTRACE_SINGLESTEP on this platform.  Uninsert the breakpoint,
	     mark it for reinsertion, and single-step.

	     Otherwise, call the target function to figure out where we need
	     our temporary breakpoint, create it, and continue executing this
	     process.  */
	  if (the_low_target.breakpoint_reinsert_addr == NULL)
	    {
	      event_child->bp_reinsert = stop_pc;
	      uninsert_breakpoint (stop_pc);
	      linux_resume_one_process (&event_child->head, 1, 0);
	    }
	  else
	    {
	      reinsert_breakpoint_by_bp
		(stop_pc, (*the_low_target.breakpoint_reinsert_addr) ());
	      linux_resume_one_process (&event_child->head, 0, 0);
a185 31

	  continue;
	}

      /* If we were single-stepping, we definitely want to report the
	 SIGTRAP.  The single-step operation has completed, so also
         clear the stepping flag; in general this does not matter, 
	 because the SIGTRAP will be reported to the client, which
	 will give us a new action for this thread, but clear it for
	 consistency anyway.  It's safe to clear the stepping flag
         because the only consumer of get_stop_pc () after this point
	 is check_removed_breakpoints, and pending_is_breakpoint is not
	 set.  It might be wiser to use a step_completed flag instead.  */
      if (event_child->stepping)
	{
	  event_child->stepping = 0;
	  return wstat;
	}

      /* A SIGTRAP that we can't explain.  It may have been a breakpoint.
	 Check if it is a breakpoint, and if so mark the process information
	 accordingly.  This will handle both the necessary fiddling with the
	 PC on decr_pc_after_break targets and suppressing extra threads
	 hitting a breakpoint if two hit it at once and then GDB removes it
	 after the first is reported.  Arguably it would be better to report
	 multiple threads hitting breakpoints simultaneously, but the current
	 remote protocol does not allow this.  */
      if ((*the_low_target.breakpoint_at) (stop_pc))
	{
	  event_child->pending_is_breakpoint = 1;
	  event_child->pending_stop_pc = stop_pc;
a189 1

d194 1
a194 1
/* Wait for process, returns status.  */
a199 18
  struct thread_info *child = NULL;

retry:
  /* If we were only supposed to resume one thread, only wait for
     that thread - if it's still alive.  If it died, however - which
     can happen if we're coming from the thread death case below -
     then we need to make sure we restart the other threads.  We could
     pick a thread at random or restart all; restarting all is less
     arbitrary.  */
  if (cont_thread > 0)
    {
      child = (struct thread_info *) find_inferior_id (&all_threads,
						       cont_thread);

      /* No stepping, no signal - unless one is pending already, of course.  */
      if (child == NULL)
	linux_resume (0, 0);
    }
d202 1
a202 2
  w = linux_wait_for_event (child);
  stop_all_processes ();
d205 1
a205 13
  /* If we are waiting for a particular child, and it exited,
     linux_wait_for_event will return its exit status.  Similarly if
     the last child exited.  If this is not the last child, however,
     do not report it as exited until there is a 'thread exited' response
     available in the remote protocol.  Instead, just wait for another event.
     This should be safe, because if the thread crashed we will already
     have reported the termination signal to GDB; that should stop any
     in-progress stepping operations, etc.

     Report the exit status of the last thread to exit.  This matches
     LinuxThreads' behavior.  */

  if (all_threads.head == all_threads.tail)
d207 4
a210 14
      if (WIFEXITED (w))
	{
	  fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
	  *status = 'W';
	  clear_inferiors ();
	  return ((unsigned char) WEXITSTATUS (w));
	}
      else if (!WIFSTOPPED (w))
	{
	  fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
	  clear_inferiors ();
	  *status = 'X';
	  return ((unsigned char) WTERMSIG (w));
	}
d212 1
a212 1
  else
d214 4
a217 2
      if (!WIFSTOPPED (w))
	goto retry;
d220 2
a225 73
static void
send_sigstop (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->stopped)
    return;

  /* If we already have a pending stop signal for this process, don't
     send another.  */
  if (process->stop_expected)
    {
      process->stop_expected = 0;
      return;
    }

  if (debug_threads)
    fprintf (stderr, "Sending sigstop to process %d\n", process->head.id);

  kill (process->head.id, SIGSTOP);
  process->sigstop_sent = 1;
}

static void
wait_for_sigstop (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;
  struct thread_info *saved_inferior, *thread;
  int wstat, saved_tid;

  if (process->stopped)
    return;

  saved_inferior = current_inferior;
  saved_tid = ((struct inferior_list_entry *) saved_inferior)->id;
  thread = (struct thread_info *) find_inferior_id (&all_threads,
						    process->tid);
  wstat = linux_wait_for_event (thread);

  /* If we stopped with a non-SIGSTOP signal, save it for later
     and record the pending SIGSTOP.  If the process exited, just
     return.  */
  if (WIFSTOPPED (wstat)
      && WSTOPSIG (wstat) != SIGSTOP)
    {
      if (debug_threads)
	fprintf (stderr, "Stopped with non-sigstop signal\n");
      process->status_pending_p = 1;
      process->status_pending = wstat;
      process->stop_expected = 1;
    }

  if (linux_thread_alive (saved_tid))
    current_inferior = saved_inferior;
  else
    {
      if (debug_threads)
	fprintf (stderr, "Previously current thread died.\n");

      /* Set a valid thread as current.  */
      set_desired_inferior (0);
    }
}

static void
stop_all_processes (void)
{
  stopping_threads = 1;
  for_each_inferior (&all_processes, send_sigstop);
  for_each_inferior (&all_processes, wait_for_sigstop);
  stopping_threads = 0;
}

d231 1
a231 2
linux_resume_one_process (struct inferior_list_entry *entry,
			  int step, int signal)
a232 78
  struct process_info *process = (struct process_info *) entry;
  struct thread_info *saved_inferior;

  if (process->stopped == 0)
    return;

  /* If we have pending signals or status, and a new signal, enqueue the
     signal.  Also enqueue the signal if we are waiting to reinsert a
     breakpoint; it will be picked up again below.  */
  if (signal != 0
      && (process->status_pending_p || process->pending_signals != NULL
	  || process->bp_reinsert != 0))
    {
      struct pending_signals *p_sig;
      p_sig = malloc (sizeof (*p_sig));
      p_sig->prev = process->pending_signals;
      p_sig->signal = signal;
      process->pending_signals = p_sig;
    }

  if (process->status_pending_p)
    return;

  saved_inferior = current_inferior;
  current_inferior = get_process_thread (process);

  if (debug_threads)
    fprintf (stderr, "Resuming process %d (%s, signal %d, stop %s)\n", inferior_pid,
	     step ? "step" : "continue", signal,
	     process->stop_expected ? "expected" : "not expected");

  /* This bit needs some thinking about.  If we get a signal that
     we must report while a single-step reinsert is still pending,
     we often end up resuming the thread.  It might be better to
     (ew) allow a stack of pending events; then we could be sure that
     the reinsert happened right away and not lose any signals.

     Making this stack would also shrink the window in which breakpoints are
     uninserted (see comment in linux_wait_for_process) but not enough for
     complete correctness, so it won't solve that problem.  It may be
     worthwhile just to solve this one, however.  */
  if (process->bp_reinsert != 0)
    {
      if (debug_threads)
	fprintf (stderr, "  pending reinsert at %08lx", (long)process->bp_reinsert);
      if (step == 0)
	fprintf (stderr, "BAD - reinserting but not stepping.\n");
      step = 1;

      /* Postpone any pending signal.  It was enqueued above.  */
      signal = 0;
    }

  check_removed_breakpoint (process);

  if (debug_threads && the_low_target.get_pc != NULL) 
    {
      fprintf (stderr, "  ");
      (long) (*the_low_target.get_pc) ();
    }

  /* If we have pending signals, consume one unless we are trying to reinsert
     a breakpoint.  */
  if (process->pending_signals != NULL && process->bp_reinsert == 0)
    {
      struct pending_signals **p_sig;

      p_sig = &process->pending_signals;
      while ((*p_sig)->prev != NULL)
	p_sig = &(*p_sig)->prev;

      signal = (*p_sig)->signal;
      free (*p_sig);
      *p_sig = NULL;
    }

  regcache_invalidate_one ((struct inferior_list_entry *)
			   get_process_thread (process));
d234 1
a234 5
  process->stopped = 0;
  process->stepping = step;
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, process->lwpid, 0, signal);

  current_inferior = saved_inferior;
a238 9
/* This function is called once per process other than the first
   one.  The first process we are told the signal to continue
   with, and whether to step or continue; for all others, any
   existing signals will be marked in status_pending_p to be
   reported momentarily, and we preserve the stepping flag.  */
static void
linux_continue_one_process (struct inferior_list_entry *entry)
{
  struct process_info *process;
d240 1
a240 14
  process = (struct process_info *) entry;
  linux_resume_one_process (entry, process->stepping, 0);
}

static void
linux_resume (int step, int signal)
{
  struct process_info *process;

  process = get_thread_process (current_inferior);

  /* If the current process has a status pending, this signal will
     be enqueued and sent later.  */
  linux_resume_one_process (&process->head, step, signal);
d242 1
a242 5
  if (cont_thread == 0 || cont_thread == -1)
    for_each_inferior (&all_processes, linux_continue_one_process);
}

#ifdef HAVE_LINUX_USRREGS
a264 1
  char *buf;
d274 1
a274 2
  buf = alloca (register_size (regno));
  for (i = 0; i < register_size (regno); i += sizeof (PTRACE_XFER_TYPE))
d277 1
a277 1
      *(PTRACE_XFER_TYPE *) (buf + i) =
a290 2
  supply_register (regno, buf);

a312 1
  char *buf;
d326 1
a326 3
      buf = alloca (register_size (regno));
      collect_register (regno, buf);
      for (i = 0; i < register_size (regno); i += sizeof (PTRACE_XFER_TYPE))
d330 1
a330 1
		  *(int *) (buf + i));
d348 1
a348 1
      usr_store_inferior_registers (regno);
d357 1
a357 1
regsets_fetch_inferior_registers ()
d395 1
a395 4
	      char s[256];
	      sprintf (s, "ptrace(regsets_fetch_inferior_registers) PID=%d",
		       inferior_pid);
	      perror (s);
d405 1
a405 1
regsets_store_inferior_registers ()
a530 5
  if (debug_threads)
    {
      fprintf (stderr, "Writing %02x to %08lx\n", (unsigned)myaddr[0], (long)memaddr);
    }

d565 1
a565 34
#ifdef USE_THREAD_DB
  if (using_threads)
    return;

  using_threads = thread_db_init ();
#endif
}

/* Return 1 if this process is not stopped.  */
static int
unstopped_p (struct inferior_list_entry *entry, void *dummy)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->stopped)
    return 0;

  return 1;
}

static int
linux_signal_pid ()
{
  struct inferior_list_entry *process;

  process = find_inferior (&all_processes, unstopped_p, NULL);

  if (process == NULL)
    {
      warning ("no unstopped process");
      return inferior_pid;
    }

  return pid_of ((struct process_info *) process);
a580 1
  linux_signal_pid,
a582 8
static void
linux_init_signals ()
{
  /* FIXME drow/2002-06-09: As above, we should check with LinuxThreads
     to find what the cancel signal actually is.  */
  signal (SIGRTMIN+1, SIG_IGN);
}

a585 1
  using_threads = 0;
a589 1
  linux_init_signals ();
@


1.16.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a1099 1
      free (buf);
@


1.16.6.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a151 2
      setpgid (0, 0);

d163 1
a163 1
  return pid;
d1231 28
d1272 1
@


1.16.4.1
log
@merge from trunk
@
text
@d38 1
a38 3
/* ``all_threads'' is keyed by the LWP ID - it should be the thread ID instead,
   however.  This requires changing the ID in place when we go from !using_threads
   to using_threads, immediately.
a39 13
   ``all_processes'' is keyed by the process ID - which on Linux is (presently)
   the same as the LWP ID.  */

struct inferior_list all_processes;

/* FIXME this is a bit of a hack, and could be removed.  */
int stopping_threads;

/* FIXME make into a target method?  */
int using_threads;

static void linux_resume_one_process (struct inferior_list_entry *entry,
				      int step, int signal);
a40 8
static void stop_all_processes (void);
static int linux_wait_for_event (struct thread_info *child);

struct pending_signals
{
  int signal;
  struct pending_signals *prev;
};
d51 1
a51 3
int debug_threads = 0;

#define pid_of(proc) ((proc)->head.id)
d53 1
a53 27
/* FIXME: Delete eventually.  */
#define inferior_pid (pid_of (get_thread_process (current_inferior)))

/* This function should only be called if the process got a SIGTRAP.
   The SIGTRAP could mean several things.

   On i386, where decr_pc_after_break is non-zero:
   If we were single-stepping this process using PTRACE_SINGLESTEP,
   we will get only the one SIGTRAP (even if the instruction we
   stepped over was a breakpoint).  The value of $eip will be the
   next instruction.
   If we continue the process using PTRACE_CONT, we will get a
   SIGTRAP when we hit a breakpoint.  The value of $eip will be
   the instruction after the breakpoint (i.e. needs to be
   decremented).  If we report the SIGTRAP to GDB, we must also
   report the undecremented PC.  If we cancel the SIGTRAP, we
   must resume at the decremented PC.

   (Presumably, not yet tested) On a non-decr_pc_after_break machine
   with hardware or kernel single-step:
   If we single-step over a breakpoint instruction, our PC will
   point at the following instruction.  If we continue and hit a
   breakpoint instruction, our PC will point at the breakpoint
   instruction.  */

static CORE_ADDR
get_stop_pc (void)
d55 2
a56 26
  CORE_ADDR stop_pc = (*the_low_target.get_pc) ();

  if (get_thread_process (current_inferior)->stepping)
    return stop_pc;
  else
    return stop_pc - the_low_target.decr_pc_after_break;
}

static void *
add_process (int pid)
{
  struct process_info *process;

  process = (struct process_info *) malloc (sizeof (*process));
  memset (process, 0, sizeof (*process));

  process->head.id = pid;

  /* Default to tid == lwpid == pid.  */
  process->tid = pid;
  process->lwpid = pid;

  add_inferior_to_list (&all_processes, &process->head);

  return process;
}
d64 1
a64 1
  void *new_process;
a74 2
      signal (SIGRTMIN + 1, SIG_DFL);

d83 4
a86 2
  new_process = add_process (pid);
  add_thread (pid, new_process);
d88 2
d95 2
a96 2
void
linux_attach_lwp (int pid, int tid)
d98 1
a98 1
  struct process_info *new_process;
d106 1
a106 5

      /* If we fail to attach to an LWP, just return.  */
      if (!using_threads)
	_exit (0177);
      return;
d109 4
a112 28
  new_process = (struct process_info *) add_process (pid);
  add_thread (tid, new_process);

  /* The next time we wait for this LWP we'll see a SIGSTOP as PTRACE_ATTACH
     brings it to a halt.  We should ignore that SIGSTOP and resume the process
     (unless this is the first process, in which case the flag will be cleared
     in linux_attach).

     On the other hand, if we are currently trying to stop all threads, we
     should treat the new thread as if we had sent it a SIGSTOP.  This works
     because we are guaranteed that add_process added us to the end of the
     list, and so the new thread has not yet reached wait_for_sigstop (but
     will).  */
  if (! stopping_threads)
    new_process->stop_expected = 1;
}

int
linux_attach (int pid)
{
  struct process_info *process;

  linux_attach_lwp (pid, pid);

  /* Don't ignore the initial SIGSTOP if we just attached to this process.  */
  process = (struct process_info *) find_inferior_id (&all_processes, pid);
  process->stop_expected = 0;

d119 1
a119 1
linux_kill_one_process (struct inferior_list_entry *entry)
d121 5
a125 11
  struct thread_info *thread = (struct thread_info *) entry;
  struct process_info *process = get_thread_process (thread);
  int wstat;

  do
    {
      ptrace (PTRACE_KILL, pid_of (process), 0, 0);

      /* Make sure it died.  The loop is most likely unnecessary.  */
      wstat = linux_wait_for_event (thread);
    } while (WIFSTOPPED (wstat));
a128 18
static void
linux_kill (void)
{
  for_each_inferior (&all_threads, linux_kill_one_process);
}

static int
linux_thread_alive (int tid)
{
  if (find_inferior_id (&all_threads, tid) != NULL)
    return 1;
  else
    return 0;
}

/* Return nonzero if this process stopped at a breakpoint which
   no longer appears to be inserted.  Also adjust the PC
   appropriately to resume where the breakpoint used to be.  */
d130 1
a130 1
check_removed_breakpoint (struct process_info *event_child)
a131 50
  CORE_ADDR stop_pc;
  struct thread_info *saved_inferior;

  if (event_child->pending_is_breakpoint == 0)
    return 0;

  if (debug_threads)
    fprintf (stderr, "Checking for breakpoint.\n");

  saved_inferior = current_inferior;
  current_inferior = get_process_thread (event_child);

  stop_pc = get_stop_pc ();

  /* If the PC has changed since we stopped, then we shouldn't do
     anything.  This happens if, for instance, GDB handled the
     decr_pc_after_break subtraction itself.  */
  if (stop_pc != event_child->pending_stop_pc)
    {
      if (debug_threads)
	fprintf (stderr, "Ignoring, PC was changed.\n");

      event_child->pending_is_breakpoint = 0;
      current_inferior = saved_inferior;
      return 0;
    }

  /* If the breakpoint is still there, we will report hitting it.  */
  if ((*the_low_target.breakpoint_at) (stop_pc))
    {
      if (debug_threads)
	fprintf (stderr, "Ignoring, breakpoint is still present.\n");
      current_inferior = saved_inferior;
      return 0;
    }

  if (debug_threads)
    fprintf (stderr, "Removed breakpoint.\n");

  /* For decr_pc_after_break targets, here is where we perform the
     decrement.  We go immediately from this function to resuming,
     and can not safely call get_stop_pc () again.  */
  if (the_low_target.set_pc != NULL)
    (*the_low_target.set_pc) (stop_pc);

  /* We consumed the pending SIGTRAP.  */
  event_child->status_pending_p = 0;
  event_child->status_pending = 0;

  current_inferior = saved_inferior;
a134 2
/* Return 1 if this process has an interesting status pending.  This function
   may silently resume an inferior process.  */
d136 1
a136 22
status_pending_p (struct inferior_list_entry *entry, void *dummy)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->status_pending_p)
    if (check_removed_breakpoint (process))
      {
	/* This thread was stopped at a breakpoint, and the breakpoint
	   is now gone.  We were told to continue (or step...) all threads,
	   so GDB isn't trying to single-step past this breakpoint.
	   So instead of reporting the old SIGTRAP, pretend we got to
	   the breakpoint just after it was removed instead of just
	   before; resume the process.  */
	linux_resume_one_process (&process->head, 0, 0);
	return 0;
      }

  return process->status_pending_p;
}

static void
linux_wait_for_process (struct process_info **childp, int *wstatp)
d138 2
a139 5
  int ret;
  int to_wait_for = -1;

  if (*childp != NULL)
    to_wait_for = (*childp)->lwpid;
d143 1
a143 9
      ret = waitpid (to_wait_for, wstatp, WNOHANG);

      if (ret == -1)
	{
	  if (errno != ECHILD)
	    perror_with_name ("waitpid");
	}
      else if (ret > 0)
	break;
d145 2
a146 1
      ret = waitpid (to_wait_for, wstatp, WNOHANG | __WCLONE);
d148 4
a151 1
      if (ret == -1)
d153 1
a153 14
	  if (errno != ECHILD)
	    perror_with_name ("waitpid (WCLONE)");
	}
      else if (ret > 0)
	break;

      usleep (1000);
    }

  if (debug_threads
      && (!WIFSTOPPED (*wstatp)
	  || (WSTOPSIG (*wstatp) != 32
	      && WSTOPSIG (*wstatp) != 33)))
    fprintf (stderr, "Got an event from %d (%x)\n", ret, *wstatp);
d155 1
a155 81
  if (to_wait_for == -1)
    *childp = (struct process_info *) find_inferior_id (&all_processes, ret);

  (*childp)->stopped = 1;
  (*childp)->pending_is_breakpoint = 0;

  if (debug_threads
      && WIFSTOPPED (*wstatp))
    {
      current_inferior = (struct thread_info *)
	find_inferior_id (&all_threads, (*childp)->tid);
      /* For testing only; i386_stop_pc prints out a diagnostic.  */
      if (the_low_target.get_pc != NULL)
	get_stop_pc ();
    }
}

static int
linux_wait_for_event (struct thread_info *child)
{
  CORE_ADDR stop_pc;
  struct process_info *event_child;
  int wstat;

  /* Check for a process with a pending status.  */
  /* It is possible that the user changed the pending task's registers since
     it stopped.  We correctly handle the change of PC if we hit a breakpoint
     (in check_removed_breakpoints); signals should be reported anyway.  */
  if (child == NULL)
    {
      event_child = (struct process_info *)
	find_inferior (&all_processes, status_pending_p, NULL);
      if (debug_threads && event_child)
	fprintf (stderr, "Got a pending child %d\n", event_child->lwpid);
    }
  else
    {
      event_child = get_thread_process (child);
      if (event_child->status_pending_p
	  && check_removed_breakpoint (event_child))
	event_child = NULL;
    }

  if (event_child != NULL)
    {
      if (event_child->status_pending_p)
	{
	  if (debug_threads)
	    fprintf (stderr, "Got an event from pending child %d (%04x)\n",
		     event_child->lwpid, event_child->status_pending);
	  wstat = event_child->status_pending;
	  event_child->status_pending_p = 0;
	  event_child->status_pending = 0;
	  current_inferior = get_process_thread (event_child);
	  return wstat;
	}
    }

  /* We only enter this loop if no process has a pending wait status.  Thus
     any action taken in response to a wait status inside this loop is
     responding as soon as we detect the status, not after any pending
     events.  */
  while (1)
    {
      if (child == NULL)
	event_child = NULL;
      else
	event_child = get_thread_process (child);

      linux_wait_for_process (&event_child, &wstat);

      if (event_child == NULL)
	error ("event from unknown child");

      current_inferior = (struct thread_info *)
	find_inferior_id (&all_threads, event_child->tid);

      if (using_threads)
	{
	  /* Check for thread exit.  */
	  if (! WIFSTOPPED (wstat))
d157 3
a159 21
	      if (debug_threads)
		fprintf (stderr, "Thread %d (LWP %d) exiting\n",
			 event_child->tid, event_child->head.id);

	      /* If the last thread is exiting, just return.  */
	      if (all_threads.head == all_threads.tail)
		return wstat;

	      dead_thread_notify (event_child->tid);

	      remove_inferior (&all_processes, &event_child->head);
	      free (event_child);
	      remove_thread (current_inferior);
	      current_inferior = (struct thread_info *) all_threads.head;

	      /* If we were waiting for this particular child to do something...
		 well, it did something.  */
	      if (child != NULL)
		return wstat;

	      /* Wait for a more interesting event.  */
d163 2
a164 11
	  if (WIFSTOPPED (wstat)
	      && WSTOPSIG (wstat) == SIGSTOP
	      && event_child->stop_expected)
	    {
	      if (debug_threads)
		fprintf (stderr, "Expected stop.\n");
	      event_child->stop_expected = 0;
	      linux_resume_one_process (&event_child->head,
					event_child->stepping, 0);
	      continue;
	    }
d166 1
a166 5
	  /* FIXME drow/2002-06-09: Get signal numbers from the inferior's
	     thread library?  */
	  if (WIFSTOPPED (wstat)
	      && (WSTOPSIG (wstat) == SIGRTMIN
		  || WSTOPSIG (wstat) == SIGRTMIN + 1))
d168 2
a169 10
	      if (debug_threads)
		fprintf (stderr, "Ignored signal %d for %d (LWP %d).\n",
			 WSTOPSIG (wstat), event_child->tid,
			 event_child->head.id);
	      linux_resume_one_process (&event_child->head,
					event_child->stepping,
					WSTOPSIG (wstat));
	      continue;
	    }
	}
d171 12
a182 22
      /* If this event was not handled above, and is not a SIGTRAP, report
	 it.  */
      if (!WIFSTOPPED (wstat) || WSTOPSIG (wstat) != SIGTRAP)
	return wstat;

      /* If this target does not support breakpoints, we simply report the
	 SIGTRAP; it's of no concern to us.  */
      if (the_low_target.get_pc == NULL)
	return wstat;

      stop_pc = get_stop_pc ();

      /* bp_reinsert will only be set if we were single-stepping.
	 Notice that we will resume the process after hitting
	 a gdbserver breakpoint; single-stepping to/over one
	 is not supported (yet).  */
      if (event_child->bp_reinsert != 0)
	{
	  if (debug_threads)
	    fprintf (stderr, "Reinserted breakpoint.\n");
	  reinsert_breakpoint (event_child->bp_reinsert);
	  event_child->bp_reinsert = 0;
d184 1
a184 45
	  /* Clear the single-stepping flag and SIGTRAP as we resume.  */
	  linux_resume_one_process (&event_child->head, 0, 0);
	  continue;
	}

      if (debug_threads)
	fprintf (stderr, "Hit a (non-reinsert) breakpoint.\n");

      if (check_breakpoints (stop_pc) != 0)
	{
	  /* We hit one of our own breakpoints.  We mark it as a pending
	     breakpoint, so that check_removed_breakpoints () will do the PC
	     adjustment for us at the appropriate time.  */
	  event_child->pending_is_breakpoint = 1;
	  event_child->pending_stop_pc = stop_pc;

	  /* Now we need to put the breakpoint back.  We continue in the event
	     loop instead of simply replacing the breakpoint right away,
	     in order to not lose signals sent to the thread that hit the
	     breakpoint.  Unfortunately this increases the window where another
	     thread could sneak past the removed breakpoint.  For the current
	     use of server-side breakpoints (thread creation) this is
	     acceptable; but it needs to be considered before this breakpoint
	     mechanism can be used in more general ways.  For some breakpoints
	     it may be necessary to stop all other threads, but that should
	     be avoided where possible.

	     If breakpoint_reinsert_addr is NULL, that means that we can
	     use PTRACE_SINGLESTEP on this platform.  Uninsert the breakpoint,
	     mark it for reinsertion, and single-step.

	     Otherwise, call the target function to figure out where we need
	     our temporary breakpoint, create it, and continue executing this
	     process.  */
	  if (the_low_target.breakpoint_reinsert_addr == NULL)
	    {
	      event_child->bp_reinsert = stop_pc;
	      uninsert_breakpoint (stop_pc);
	      linux_resume_one_process (&event_child->head, 1, 0);
	    }
	  else
	    {
	      reinsert_breakpoint_by_bp
		(stop_pc, (*the_low_target.breakpoint_reinsert_addr) ());
	      linux_resume_one_process (&event_child->head, 0, 0);
a185 31

	  continue;
	}

      /* If we were single-stepping, we definitely want to report the
	 SIGTRAP.  The single-step operation has completed, so also
         clear the stepping flag; in general this does not matter, 
	 because the SIGTRAP will be reported to the client, which
	 will give us a new action for this thread, but clear it for
	 consistency anyway.  It's safe to clear the stepping flag
         because the only consumer of get_stop_pc () after this point
	 is check_removed_breakpoints, and pending_is_breakpoint is not
	 set.  It might be wiser to use a step_completed flag instead.  */
      if (event_child->stepping)
	{
	  event_child->stepping = 0;
	  return wstat;
	}

      /* A SIGTRAP that we can't explain.  It may have been a breakpoint.
	 Check if it is a breakpoint, and if so mark the process information
	 accordingly.  This will handle both the necessary fiddling with the
	 PC on decr_pc_after_break targets and suppressing extra threads
	 hitting a breakpoint if two hit it at once and then GDB removes it
	 after the first is reported.  Arguably it would be better to report
	 multiple threads hitting breakpoints simultaneously, but the current
	 remote protocol does not allow this.  */
      if ((*the_low_target.breakpoint_at) (stop_pc))
	{
	  event_child->pending_is_breakpoint = 1;
	  event_child->pending_stop_pc = stop_pc;
a189 1

d194 1
a194 1
/* Wait for process, returns status.  */
a199 18
  struct thread_info *child = NULL;

retry:
  /* If we were only supposed to resume one thread, only wait for
     that thread - if it's still alive.  If it died, however - which
     can happen if we're coming from the thread death case below -
     then we need to make sure we restart the other threads.  We could
     pick a thread at random or restart all; restarting all is less
     arbitrary.  */
  if (cont_thread > 0)
    {
      child = (struct thread_info *) find_inferior_id (&all_threads,
						       cont_thread);

      /* No stepping, no signal - unless one is pending already, of course.  */
      if (child == NULL)
	linux_resume (0, 0);
    }
d202 1
a202 2
  w = linux_wait_for_event (child);
  stop_all_processes ();
d205 1
a205 13
  /* If we are waiting for a particular child, and it exited,
     linux_wait_for_event will return its exit status.  Similarly if
     the last child exited.  If this is not the last child, however,
     do not report it as exited until there is a 'thread exited' response
     available in the remote protocol.  Instead, just wait for another event.
     This should be safe, because if the thread crashed we will already
     have reported the termination signal to GDB; that should stop any
     in-progress stepping operations, etc.

     Report the exit status of the last thread to exit.  This matches
     LinuxThreads' behavior.  */

  if (all_threads.head == all_threads.tail)
d207 4
a210 14
      if (WIFEXITED (w))
	{
	  fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
	  *status = 'W';
	  clear_inferiors ();
	  return ((unsigned char) WEXITSTATUS (w));
	}
      else if (!WIFSTOPPED (w))
	{
	  fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
	  clear_inferiors ();
	  *status = 'X';
	  return ((unsigned char) WTERMSIG (w));
	}
d212 1
a212 1
  else
d214 4
a217 2
      if (!WIFSTOPPED (w))
	goto retry;
d220 2
a225 73
static void
send_sigstop (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->stopped)
    return;

  /* If we already have a pending stop signal for this process, don't
     send another.  */
  if (process->stop_expected)
    {
      process->stop_expected = 0;
      return;
    }

  if (debug_threads)
    fprintf (stderr, "Sending sigstop to process %d\n", process->head.id);

  kill (process->head.id, SIGSTOP);
  process->sigstop_sent = 1;
}

static void
wait_for_sigstop (struct inferior_list_entry *entry)
{
  struct process_info *process = (struct process_info *) entry;
  struct thread_info *saved_inferior, *thread;
  int wstat, saved_tid;

  if (process->stopped)
    return;

  saved_inferior = current_inferior;
  saved_tid = ((struct inferior_list_entry *) saved_inferior)->id;
  thread = (struct thread_info *) find_inferior_id (&all_threads,
						    process->tid);
  wstat = linux_wait_for_event (thread);

  /* If we stopped with a non-SIGSTOP signal, save it for later
     and record the pending SIGSTOP.  If the process exited, just
     return.  */
  if (WIFSTOPPED (wstat)
      && WSTOPSIG (wstat) != SIGSTOP)
    {
      if (debug_threads)
	fprintf (stderr, "Stopped with non-sigstop signal\n");
      process->status_pending_p = 1;
      process->status_pending = wstat;
      process->stop_expected = 1;
    }

  if (linux_thread_alive (saved_tid))
    current_inferior = saved_inferior;
  else
    {
      if (debug_threads)
	fprintf (stderr, "Previously current thread died.\n");

      /* Set a valid thread as current.  */
      set_desired_inferior (0);
    }
}

static void
stop_all_processes (void)
{
  stopping_threads = 1;
  for_each_inferior (&all_processes, send_sigstop);
  for_each_inferior (&all_processes, wait_for_sigstop);
  stopping_threads = 0;
}

d231 1
a231 2
linux_resume_one_process (struct inferior_list_entry *entry,
			  int step, int signal)
a232 78
  struct process_info *process = (struct process_info *) entry;
  struct thread_info *saved_inferior;

  if (process->stopped == 0)
    return;

  /* If we have pending signals or status, and a new signal, enqueue the
     signal.  Also enqueue the signal if we are waiting to reinsert a
     breakpoint; it will be picked up again below.  */
  if (signal != 0
      && (process->status_pending_p || process->pending_signals != NULL
	  || process->bp_reinsert != 0))
    {
      struct pending_signals *p_sig;
      p_sig = malloc (sizeof (*p_sig));
      p_sig->prev = process->pending_signals;
      p_sig->signal = signal;
      process->pending_signals = p_sig;
    }

  if (process->status_pending_p)
    return;

  saved_inferior = current_inferior;
  current_inferior = get_process_thread (process);

  if (debug_threads)
    fprintf (stderr, "Resuming process %d (%s, signal %d, stop %s)\n", inferior_pid,
	     step ? "step" : "continue", signal,
	     process->stop_expected ? "expected" : "not expected");

  /* This bit needs some thinking about.  If we get a signal that
     we must report while a single-step reinsert is still pending,
     we often end up resuming the thread.  It might be better to
     (ew) allow a stack of pending events; then we could be sure that
     the reinsert happened right away and not lose any signals.

     Making this stack would also shrink the window in which breakpoints are
     uninserted (see comment in linux_wait_for_process) but not enough for
     complete correctness, so it won't solve that problem.  It may be
     worthwhile just to solve this one, however.  */
  if (process->bp_reinsert != 0)
    {
      if (debug_threads)
	fprintf (stderr, "  pending reinsert at %08lx", (long)process->bp_reinsert);
      if (step == 0)
	fprintf (stderr, "BAD - reinserting but not stepping.\n");
      step = 1;

      /* Postpone any pending signal.  It was enqueued above.  */
      signal = 0;
    }

  check_removed_breakpoint (process);

  if (debug_threads && the_low_target.get_pc != NULL) 
    {
      fprintf (stderr, "  ");
      (long) (*the_low_target.get_pc) ();
    }

  /* If we have pending signals, consume one unless we are trying to reinsert
     a breakpoint.  */
  if (process->pending_signals != NULL && process->bp_reinsert == 0)
    {
      struct pending_signals **p_sig;

      p_sig = &process->pending_signals;
      while ((*p_sig)->prev != NULL)
	p_sig = &(*p_sig)->prev;

      signal = (*p_sig)->signal;
      free (*p_sig);
      *p_sig = NULL;
    }

  regcache_invalidate_one ((struct inferior_list_entry *)
			   get_process_thread (process));
d234 1
a234 5
  process->stopped = 0;
  process->stepping = step;
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, process->lwpid, 0, signal);

  current_inferior = saved_inferior;
a238 9
/* This function is called once per process other than the first
   one.  The first process we are told the signal to continue
   with, and whether to step or continue; for all others, any
   existing signals will be marked in status_pending_p to be
   reported momentarily, and we preserve the stepping flag.  */
static void
linux_continue_one_process (struct inferior_list_entry *entry)
{
  struct process_info *process;
d240 1
a240 14
  process = (struct process_info *) entry;
  linux_resume_one_process (entry, process->stepping, 0);
}

static void
linux_resume (int step, int signal)
{
  struct process_info *process;

  process = get_thread_process (current_inferior);

  /* If the current process has a status pending, this signal will
     be enqueued and sent later.  */
  linux_resume_one_process (&process->head, step, signal);
d242 1
a242 5
  if (cont_thread == 0 || cont_thread == -1)
    for_each_inferior (&all_processes, linux_continue_one_process);
}

#ifdef HAVE_LINUX_USRREGS
a264 1
  char *buf;
d274 1
a274 2
  buf = alloca (register_size (regno));
  for (i = 0; i < register_size (regno); i += sizeof (PTRACE_XFER_TYPE))
d277 1
a277 1
      *(PTRACE_XFER_TYPE *) (buf + i) =
a290 2
  supply_register (regno, buf);

a312 1
  char *buf;
d326 1
a326 3
      buf = alloca (register_size (regno));
      collect_register (regno, buf);
      for (i = 0; i < register_size (regno); i += sizeof (PTRACE_XFER_TYPE))
d330 1
a330 1
		  *(int *) (buf + i));
d348 1
a348 1
      usr_store_inferior_registers (regno);
d357 1
a357 1
regsets_fetch_inferior_registers ()
d395 1
a395 4
	      char s[256];
	      sprintf (s, "ptrace(regsets_fetch_inferior_registers) PID=%d",
		       inferior_pid);
	      perror (s);
d405 1
a405 1
regsets_store_inferior_registers ()
a530 5
  if (debug_threads)
    {
      fprintf (stderr, "Writing %02x to %08lx\n", (unsigned)myaddr[0], (long)memaddr);
    }

d565 1
a565 34
#ifdef USE_THREAD_DB
  if (using_threads)
    return;

  using_threads = thread_db_init ();
#endif
}

/* Return 1 if this process is not stopped.  */
static int
unstopped_p (struct inferior_list_entry *entry, void *dummy)
{
  struct process_info *process = (struct process_info *) entry;

  if (process->stopped)
    return 0;

  return 1;
}

static int
linux_signal_pid ()
{
  struct inferior_list_entry *process;

  process = find_inferior (&all_processes, unstopped_p, NULL);

  if (process == NULL)
    {
      warning ("no unstopped process");
      return inferior_pid;
    }

  return pid_of ((struct process_info *) process);
a580 1
  linux_signal_pid,
a582 8
static void
linux_init_signals ()
{
  /* FIXME drow/2002-06-09: As above, we should check with LinuxThreads
     to find what the cancel signal actually is.  */
  signal (SIGRTMIN+1, SIG_IGN);
}

a585 1
  using_threads = 0;
a589 1
  linux_init_signals ();
@


1.15
log
@2002-04-20  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/mem-break.c: New file.
        * gdbserver/mem-break.h: New file.
        * gdbserver/Makefile.in: Add mem-break.o rule; update server.h
        dependencies.
        * gdbserver/inferiors.c (struct inferior_info): Add target_data
        member.
        (clear_inferiors): Free target_data member if set.
        (inferior_target_data, set_inferior_target_data): New functions.
        * gdbserver/linux-i386-low.c (i386_breakpoint, i386_breakpoint_len)
        (i386_stop_pc, i386_set_pc): New.  Add to the_low_target.
        * gdbserver/linux-low.c (linux_bp_reinsert): New variable.
        (struct inferior_linux_data): New.
        (linux_create_inferior): Use set_inferior_target_data.
        (linux_attach): Likewise.  Call add_inferior.
        (linux_wait_for_one_inferior): New function.
        (linux_wait): Call it.
        (linux_write_memory): Add const.
        (initialize_low): Call set_breakpoint_data.
        * gdbserver/linux-low.h (struct linux_target_ops): Add breakpoint
        handling members.
        * gdbserver/server.c (attach_inferior): Remove extra add_inferior
        call.
        * gdbserver/server.h: Include mem-break.h.  Update inferior.c
        prototypes.
        * gdbserver/target.c (read_inferior_memory)
        (write_inferior_memory): New functions.
        * gdbserver/target.h (read_inferior_memory)
        (write_inferior_memory): Change macros to prototypes.
        (struct target_ops): Update comments.  Add const to write_memory
        definition.
@
text
@d375 1
a375 1
      res = ptrace (regset->get_request, inferior_pid, 0, (int) buf);
d424 1
a424 1
      res = ptrace (regset->set_request, inferior_pid, 0, (int) buf);
@


1.14
log
@2002-04-11  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c (usr_store_inferior_registers): Support
        registers which are allowed to fail to store.
        * gdbserver/linux-low.h (linux_target_ops): Likewise.
        * gdbserver/linux-ppc-low.c (ppc_regmap): Support FPSCR.
        (ppc_cannot_store_register): FPSCR may not be storable.
        * regformats/reg-ppc.dat: Support FPSCR.
@
text
@d38 4
d53 5
d64 1
d84 4
d98 2
d109 4
d135 59
a198 1
  int pid;
d202 1
a202 1
  pid = waitpid (inferior_pid, &w, 0);
a203 2
  if (pid != inferior_pid)
    perror_with_name ("wait");
d519 1
a519 1
linux_write_memory (CORE_ADDR memaddr, char *myaddr, int len)
d587 2
@


1.13
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * linux-low.c (linux_look_up_symbols): New hook.
        (linux_target_ops): Add linux_look_up_symbols.
        * remote-utils.c (decode_address): New function.
        (look_up_one_symbol): New function.
        * server.c (handle_query): Call target look_up_symbols hook.
        * server.h (look_up_one_symbol): Add prototype.
        * target.h (struct target_ops): Add look_up_symbols hook.
@
text
@d243 1
a243 1
      if ((*the_low_target.cannot_store_register) (regno))
d257 9
a265 8
	      /* Warning, not error, in case we are attached; sometimes the
		 kernel doesn't let us at the registers.  */
	      char *err = strerror (errno);
	      char *msg = alloca (strlen (err) + 128);
	      sprintf (msg, "writing register %d: %s",
		       regno, err);
	      error (msg);
	      return;
@


1.12
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

	* linux-low.h: Remove obsolete prototypes.
	(struct linux_target_ops): New.
	(extern the_low_target): New.
	* linux-low.c (num_regs, regmap): Remove declarations.
	(register_addr): Use the_low_target explicitly.
	(fetch_register): Likewise.
	(usr_fetch_inferior_registers): Likewise.
	(usr_store_inferior_registers): Likewise.
	* linux-arm-low.c (num_regs): Remove.
	(arm_num_regs): Define.
	(arm_regmap): Renamed from regmap, made static.
	(arm_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(arm_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-i386-low.c (num_regs): Remove.
	(i386_num_regs): Define.
	(i386_regmap): Renamed from regmap, made static.
	(i386_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(i386_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-ia64-low.c (num_regs): Remove.
	(ia64_num_regs): Define.
	(ia64_regmap): Renamed from regmap, made static.
	(ia64_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(ia64_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-m68k-low.c (num_regs): Remove.
	(m68k_num_regs): Define.
	(m68k_regmap): Renamed from regmap, made static.
	(m68k_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(m68k_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-mips-low.c (num_regs): Remove.
	(mips_num_regs): Define.
	(mips_regmap): Renamed from regmap, made static.
	(mips_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(mips_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-ppc-low.c (num_regs): Remove.
	(ppc_num_regs): Define.
	(ppc_regmap): Renamed from regmap, made static.
	(ppc_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(ppc_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-s390-low.c (num_regs): Remove.
	(s390_num_regs): Define.
	(s390_regmap): Renamed from regmap, made static.
	(s390_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(s390_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-sh-low.c (num_regs): Remove.
	(sh_num_regs): Define.
	(sh_regmap): Renamed from regmap, made static.
	(sh_cannot_fetch_register): Renamed from cannot_fetch_register,
	made static.
	(sh_cannot_store_register): Renamed from cannot_store_register,
	made static.
	(the_low_target): New.
	* linux-x86-64-low.c (x86_64_regmap): Renamed from regmap.
	(the_low_target): New.
@
text
@d484 7
d503 1
@


1.11
log
@2002-04-09  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/inferiors.c: New file.
        * gdbserver/target.c: New file.
        * gdbserver/target.h: New file.
        * gdbserver/Makefile.in:  Add target.o and inferiors.o.  Update
        dependencies.
        * gdbserver/linux-low.c (inferior_pid): New static variable,
        moved from server.c.
        (linux_create_inferior): Renamed from create_inferior.
        Call add_inferior.  Return 0 on success instead of a PID.
        (linux_attach): Renamed from myattach.
        (linux_kill): Renamed from kill_inferior.  Call clear_inferiors ().
        (linux_thread_alive): Renamed from mythread_alive.
        (linux_wait): Renamed from mywait.  Call clear_inferiors () if the
        child dies.
        (linux_resume): Renamed from myresume.  Add missing ``return 0''.
        (regsets_store_inferior_registers): Correct error message.
        Add missing ``return 0''.
        (linux_fetch_registers): Renamed from fetch_inferior_registers.
        (linux_store_registers): Renamed from store_inferior_registers.
        (linux_read_memory): Renamed from read_inferior_memory.
        (linux_write_memory): Renamed from write_inferior_memory.
        (linux_target_ops): New structure.
        (initialize_low): Call set_target_ops ().
        * gdbserver/remote-utils.c (unhexify): New function.
        (hexify): New function.
        (input_interrupt): Send signals to ``signal_pid''.
        * gdbserver/server.c (inferior_pid): Remove.
        (start_inferior): Update create_inferior call.
        (attach_inferior): Call add_inferior.
        (handle_query): New function.
        (main): Call handle_query for `q' packets.
        * gdbserver/server.h: Include "target.h".  Remove obsolete prototypes.
        Add prototypes for "inferiors.c", "target.c", hexify, and unhexify.
@
text
@a46 5
#ifdef HAVE_LINUX_USRREGS
extern int num_regs;
extern int regmap[];
#endif

d173 1
a173 1
  if (regnum < 0 || regnum >= num_regs)
d176 1
a176 1
  addr = regmap[regnum];
d190 1
a190 1
  if (regno >= num_regs)
d192 1
a192 1
  if (cannot_fetch_register (regno))
d223 1
a223 1
    for (regno = 0; regno < num_regs; regno++)
d240 1
a240 1
      if (regno >= num_regs)
d243 1
a243 1
      if (cannot_store_register (regno))
d270 1
a270 1
    for (regno = 0; regno < num_regs; regno++)
@


1.10
log
@2002-03-04  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c (PTRACE_XFER_TYPE): Change to long.
        (num_regs, regmap): Move inside HAVE_LINUX_USRREGS.
        (register_addr, REGISTER_RAW_SIZE): Likewise.
        (usr_store_inferior_registers): Use PTRACE_XFER_TYPE.
        * gdbserver/linux-x86-64-low.c: Remove extra #endif.
@
text
@d52 2
d57 2
a58 2
int
create_inferior (char *program, char **allargs)
d78 4
a81 1
  return pid;
d86 2
a87 2
int
myattach (int pid)
d103 2
a104 2
void
kill_inferior (void)
d110 1
d114 2
a115 2
int
mythread_alive (int pid)
d122 2
a123 2
unsigned char
mywait (char *status)
d138 1
d144 1
d159 2
a160 2
void
myresume (int step, int signal)
d329 1
d372 1
a372 1
	      perror ("Warning: ptrace(regsets_fetch_inferior_registers)");
d377 1
d384 1
a384 1
fetch_inferior_registers (int regno)
d399 1
a399 1
store_inferior_registers (int regno)
d417 2
a418 2
void
read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
d446 2
a447 2
int
write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
d490 13
d506 1
@


1.9
log
@2002-02-27  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/acconfig.h: New file.
        * gdbserver/i387-fp.c: New file.
        * gdbserver/i387-fp.h: New file.
        * gdbserver/linux-x86-64.c: New file.
        * regformats/reg-x86-64.dat: New file.
        * configure.tgt: Add x86_64-*-linux* gdbserver support.
        & gdbserver/configure.srv: Add x86_64-*-linux* and regset support.
        * gdbserver/configure.in: Add support for regsets.
        * gdbserver/config.in: Regenerate.
        * gdbserver/configure: Regenerate.
        * gdbserver/Makefile.in: Likewise.  Add $(linux_low_h).
        * gdbserver/linux-low.h: New file.
        * gdbserver/linux-low.c: Include "linux-low.h".  Add support
        for regsets.
        * gdbserver/linux-arm-low.c: Include "linux-low.h".
        * gdbserver/linux-ia64-low.c: Include "linux-low.h".
        * gdbserver/linux-m68k-low.c: Include "linux-low.h".
        * gdbserver/linux-mips-low.c: Include "linux-low.h".
        * gdbserver/linux-ppc-low.c: Include "linux-low.h".
        * gdbserver/linux-sh-low.c: Include "linux-low.h".
        * gdbserver/linux-i386-low.c: Include "linux-low.h".  Include
        "i387-fp.h".  Add PTRACE_GETREGS and friends.
        * gdbserver/regcache.c (supply_register): New function.
        (supply_register_by_name): New function.
        (collect_register): New function.
        (collect_register_by_name): New function.
@
text
@d39 1
a39 1
#define PTRACE_XFER_TYPE int
d46 2
d50 1
d160 3
a179 4


#ifdef HAVE_LINUX_USRREGS

d247 1
a247 1
      for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
@


1.9.2.1
log
@2002-03-07  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c (PTRACE_XFER_TYPE): Change to long.
        (num_regs, regmap): Move inside HAVE_LINUX_USRREGS.
        (register_addr, REGISTER_RAW_SIZE): Likewise.
        (usr_store_inferior_registers): Use PTRACE_XFER_TYPE.
        * gdbserver/linux-x86-64-low.c: Remove extra #endif.
@
text
@d39 1
a39 1
#define PTRACE_XFER_TYPE long
a45 2

#ifdef HAVE_LINUX_USRREGS
a47 1
#endif
a156 3

#ifdef HAVE_LINUX_USRREGS

d174 4
d245 1
a245 1
      for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
@


1.8
log
@2002-02-20  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c (mywait): Change argument to waitpid
        to be an integer instead of a `union wait'.
@
text
@d23 2
a25 1

d41 4
d174 4
a178 1

d214 2
a215 3

void
fetch_inferior_registers (int regno)
d227 2
a228 3

void
store_inferior_registers (int regno)
d268 133
@


1.7
log
@2002-02-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/Makefile.in: Add regformats directory to INCLUDE_CFLAGS,
        and remove unused $(INCLUDE_DIR).
        Add regcache.c to OBS.
        Add generated register protocol files to clean target.
        Update dependencies for new objects, obsolete old target code.

        * gdbserver/linux-low.c: Remove all platform-specific code to
        new files.  Remove various dead code.  Update to use regcache
        functionality.
        * gdbserver/remote-utils.c (fromhex): Add return statement
        to quiet warning.
        (putpkt): Dynamically allocate buf2 because PBUFSIZ is no longer
        constant.
        (input_interrupt): Add integer parameter to match prototype
        of a signal handler.
        (outreg): Use register_data ().
        (prepare_resume_reply): Use gdbserver_expedite_regs.
        * gdbserver/server.c (main): Dynamically allocate own_buf because
        PBUFSIZ is no longer constant.  Use registers_to_string () and
        registers_from_string ().
        * gdbserver/server.h: No longer include "defs.h".  Add prototypes
        for error (), fatal (), and warning ().  Update definition of
        PBUFSIZ to use regcache functionality.  Add include guard.
        * gdbserver/utils.c (fatal): Add missing ``const''.
        (warning): New function.

        * regformats/regdat.sh: Include "regcache.h" in generated files.
        Provide init_registers () function.
        * regformats/regdef.h: Add prototype for set_register_cache ().
        Add include guard.

        * gdbserver/linux-arm-low.c: New file.
        * gdbserver/linux-i386-low.c: New file.
        * gdbserver/linux-ia64-low.c: New file.
        * gdbserver/linux-m68k-low.c: New file.
        * gdbserver/linux-mips-low.c: New file.
        * gdbserver/linux-ppc-low.c: New file.
        * gdbserver/linux-sh-low.c: New file.

        * gdbserver/regcache.c: New file.
        * gdbserver/regcache.h: New file.

        * gdbserver/low-linux.c: Removed obsolete file.
@
text
@d112 1
a112 1
  union wait w;
d115 1
a115 1
  pid = waitpid (inferior_pid, (int *)&w, 0);
@


1.6
log
@2002-02-05  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c (mywait): Cast second argument of waitpid
        to (int *).
@
text
@d34 2
a35 9

/***************Begin MY defs*********************/
static char my_registers[REGISTER_BYTES];
char *registers = my_registers;
/***************End MY defs*********************/

#ifdef HAVE_SYS_REG_H
#include <sys/reg.h>
#endif
d41 2
a42 2

static void initialize_arch (void);
d152 1
a152 377

#if !defined (offsetof)
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

/* U_REGS_OFFSET is the offset of the registers within the u area.  */
#if !defined (U_REGS_OFFSET)
#define U_REGS_OFFSET \
  ptrace (PT_READ_U, inferior_pid, \
          (PTRACE_ARG3_TYPE) (offsetof (struct user, u_ar0)), 0) \
    - KERNEL_U_ADDR
#endif

#ifdef I386_GNULINUX_TARGET
/* This module only supports access to the general purpose registers.
   Adjust the relevant constants accordingly.

   FIXME: kettenis/2001-03-28: We should really use PTRACE_GETREGS to
   get at the registers.  Better yet, we should try to share code with
   i386-linux-nat.c.  */
#undef NUM_FREGS
#define NUM_FREGS 0
#undef NUM_REGS
#define NUM_REGS NUM_GREGS

/* This stuff comes from i386-tdep.c.  */

/* i386_register_byte[i] is the offset into the register file of the
   start of register number i.  We initialize this from
   i386_register_raw_size.  */
int i386_register_byte[MAX_NUM_REGS];

/* i386_register_raw_size[i] is the number of bytes of storage in
   GDB's register array occupied by register i.  */
int i386_register_raw_size[MAX_NUM_REGS] = {
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
  10, 10, 10, 10,
  10, 10, 10, 10,
   4,  4,  4,  4,
   4,  4,  4,  4,
  16, 16, 16, 16,
  16, 16, 16, 16,
   4
};

static void
initialize_arch (void)
{
  /* Initialize the table saying where each register starts in the
     register file.  */
  {
    int i, offset;

    offset = 0;
    for (i = 0; i < MAX_NUM_REGS; i++)
      {
	i386_register_byte[i] = offset;
	offset += i386_register_raw_size[i];
      }
  }
}

/* This stuff comes from i386-linux-nat.c.  */

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */
static int regmap[] = 
{
  EAX, ECX, EDX, EBX,
  UESP, EBP, ESI, EDI,
  EIP, EFL, CS, SS,
  DS, ES, FS, GS
};

/* Return the address of register REGNUM.  BLOCKEND is the value of
   u.u_ar0, which should point to the registers.  */

CORE_ADDR
register_u_addr (CORE_ADDR blockend, int regnum)
{
  return (blockend + 4 * regmap[regnum]);
}
#elif defined(TARGET_M68K)
static void
initialize_arch (void)
{
  return;
}

/* This table must line up with REGISTER_NAMES in tm-m68k.h */
static int regmap[] =
{
#ifdef PT_D0
  PT_D0, PT_D1, PT_D2, PT_D3, PT_D4, PT_D5, PT_D6, PT_D7,
  PT_A0, PT_A1, PT_A2, PT_A3, PT_A4, PT_A5, PT_A6, PT_USP,
  PT_SR, PT_PC,
#else
  14, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15,
  17, 18,
#endif
#ifdef PT_FP0
  PT_FP0, PT_FP1, PT_FP2, PT_FP3, PT_FP4, PT_FP5, PT_FP6, PT_FP7,
  PT_FPCR, PT_FPSR, PT_FPIAR
#else
  21, 24, 27, 30, 33, 36, 39, 42, 45, 46, 47
#endif
};

/* BLOCKEND is the value of u.u_ar0, and points to the place where GS
   is stored.  */

int
m68k_linux_register_u_addr (int blockend, int regnum)
{
  return (blockend + 4 * regmap[regnum]);
}
#elif defined(IA64_GNULINUX_TARGET)
#undef NUM_FREGS
#define NUM_FREGS 0

#include <asm/ptrace_offsets.h>

static int u_offsets[] =
  {
    /* general registers */
    -1,		/* gr0 not available; i.e, it's always zero */
    PT_R1,
    PT_R2,
    PT_R3,
    PT_R4,
    PT_R5,
    PT_R6,
    PT_R7,
    PT_R8,
    PT_R9,
    PT_R10,
    PT_R11,
    PT_R12,
    PT_R13,
    PT_R14,
    PT_R15,
    PT_R16,
    PT_R17,
    PT_R18,
    PT_R19,
    PT_R20,
    PT_R21,
    PT_R22,
    PT_R23,
    PT_R24,
    PT_R25,
    PT_R26,
    PT_R27,
    PT_R28,
    PT_R29,
    PT_R30,
    PT_R31,
    /* gr32 through gr127 not directly available via the ptrace interface */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    /* Floating point registers */
    -1, -1,	/* f0 and f1 not available (f0 is +0.0 and f1 is +1.0) */
    PT_F2,
    PT_F3,
    PT_F4,
    PT_F5,
    PT_F6,
    PT_F7,
    PT_F8,
    PT_F9,
    PT_F10,
    PT_F11,
    PT_F12,
    PT_F13,
    PT_F14,
    PT_F15,
    PT_F16,
    PT_F17,
    PT_F18,
    PT_F19,
    PT_F20,
    PT_F21,
    PT_F22,
    PT_F23,
    PT_F24,
    PT_F25,
    PT_F26,
    PT_F27,
    PT_F28,
    PT_F29,
    PT_F30,
    PT_F31,
    PT_F32,
    PT_F33,
    PT_F34,
    PT_F35,
    PT_F36,
    PT_F37,
    PT_F38,
    PT_F39,
    PT_F40,
    PT_F41,
    PT_F42,
    PT_F43,
    PT_F44,
    PT_F45,
    PT_F46,
    PT_F47,
    PT_F48,
    PT_F49,
    PT_F50,
    PT_F51,
    PT_F52,
    PT_F53,
    PT_F54,
    PT_F55,
    PT_F56,
    PT_F57,
    PT_F58,
    PT_F59,
    PT_F60,
    PT_F61,
    PT_F62,
    PT_F63,
    PT_F64,
    PT_F65,
    PT_F66,
    PT_F67,
    PT_F68,
    PT_F69,
    PT_F70,
    PT_F71,
    PT_F72,
    PT_F73,
    PT_F74,
    PT_F75,
    PT_F76,
    PT_F77,
    PT_F78,
    PT_F79,
    PT_F80,
    PT_F81,
    PT_F82,
    PT_F83,
    PT_F84,
    PT_F85,
    PT_F86,
    PT_F87,
    PT_F88,
    PT_F89,
    PT_F90,
    PT_F91,
    PT_F92,
    PT_F93,
    PT_F94,
    PT_F95,
    PT_F96,
    PT_F97,
    PT_F98,
    PT_F99,
    PT_F100,
    PT_F101,
    PT_F102,
    PT_F103,
    PT_F104,
    PT_F105,
    PT_F106,
    PT_F107,
    PT_F108,
    PT_F109,
    PT_F110,
    PT_F111,
    PT_F112,
    PT_F113,
    PT_F114,
    PT_F115,
    PT_F116,
    PT_F117,
    PT_F118,
    PT_F119,
    PT_F120,
    PT_F121,
    PT_F122,
    PT_F123,
    PT_F124,
    PT_F125,
    PT_F126,
    PT_F127,
    /* predicate registers - we don't fetch these individually */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* branch registers */
    PT_B0,
    PT_B1,
    PT_B2,
    PT_B3,
    PT_B4,
    PT_B5,
    PT_B6,
    PT_B7,
    /* virtual frame pointer and virtual return address pointer */
    -1, -1,
    /* other registers */
    PT_PR,
    PT_CR_IIP,	/* ip */
    PT_CR_IPSR, /* psr */
    PT_CFM,	/* cfm */
    /* kernel registers not visible via ptrace interface (?) */
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* hole */
    -1, -1, -1, -1, -1, -1, -1, -1,
    PT_AR_RSC,
    PT_AR_BSP,
    PT_AR_BSPSTORE,
    PT_AR_RNAT,
    -1,
    -1,		/* Not available: FCR, IA32 floating control register */
    -1, -1,
    -1,		/* Not available: EFLAG */
    -1,		/* Not available: CSD */
    -1,		/* Not available: SSD */
    -1,		/* Not available: CFLG */
    -1,		/* Not available: FSR */
    -1,		/* Not available: FIR */
    -1,		/* Not available: FDR */
    -1,
    PT_AR_CCV,
    -1, -1, -1,
    PT_AR_UNAT,
    -1, -1, -1,
    PT_AR_FPSR,
    -1, -1, -1,
    -1,		/* Not available: ITC */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1,
    PT_AR_PFS,
    PT_AR_LC,
    -1,		/* Not available: EC, the Epilog Count register */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1,
    /* nat bits - not fetched directly; instead we obtain these bits from
       either rnat or unat or from memory. */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
  };
d155 1
a155 1
ia64_register_u_addr (int blockend, int regnum)
d159 1
a159 1
  if (regnum < 0 || regnum >= NUM_REGS)
d162 1
a162 1
  addr = u_offsets[regnum];
a168 33
static void
initialize_arch (void)
{
  return;
}

#elif defined(ARM_GNULINUX_TARGET)
int arm_register_u_addr(blockend, regnum)
     int blockend;
     int regnum;
{
  return blockend + REGISTER_BYTE(regnum);  
}

static void
initialize_arch ()
{
}
#endif

CORE_ADDR
register_addr (int regno, CORE_ADDR blockend)
{
  CORE_ADDR addr;

  if (regno < 0 || regno >= NUM_REGS)
    error ("Invalid register number %d.", regno);

  REGISTER_U_ADDR (addr, blockend, regno);

  return addr;
}

d177 4
a180 2
  /* Offset of registers within the u area.  */
  unsigned int offset;
d182 3
a184 3
  offset = U_REGS_OFFSET;

  regaddr = register_addr (regno, offset);
d188 1
a188 1
      *(PTRACE_XFER_TYPE *) &registers[REGISTER_BYTE (regno) + i] =
d211 1
a211 1
    for (regno = 0; regno < NUM_REGS - NUM_FREGS; regno++)
a225 1
  unsigned int offset = U_REGS_OFFSET;
d229 8
a236 2
#if 0
      if (CANNOT_STORE_REGISTER (regno))
a237 2
#endif
      regaddr = register_addr (regno, offset);
d239 1
a239 2
#if 0
      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)
d241 3
a243 3
	  scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
	  ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		  scratch, 0);
d246 8
a253 4
	      /* Error, even if attached.  Failing to write these two
	         registers is pretty serious.  */
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
d255 1
a256 20
      else
#endif
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
	  {
	    errno = 0;
	    ptrace (PTRACE_POKEUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		    *(int *) &registers[REGISTER_BYTE (regno) + i]);
	    if (errno != 0)
	      {
		/* Warning, not error, in case we are attached; sometimes the
		   kernel doesn't let us at the registers.  */
		char *err = strerror (errno);
		char *msg = alloca (strlen (err) + 128);
		sprintf (msg, "writing register %d: %s",
			 regno, err);
		error (msg);
		return;
	      }
	    regaddr += sizeof (int);
	  }
d259 1
a259 1
    for (regno = 0; regno < NUM_REGS - NUM_FREGS; regno++)
a262 6
/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
   in the NEW_SUN_PTRACE case.
   It ought to be straightforward.  But it appears that writing did
   not write the data that I specified.  I cannot understand where
   it got the data that it actually did write.  */

d342 1
a342 1
  initialize_arch ();
@


1.5
log
@2002-02-05  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c (kill_inferior): Remove commented out
        code.
@
text
@d122 1
a122 1
  pid = waitpid (inferior_pid, &w, 0);
@


1.4
log
@2002-02-05  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c: Remove unused include files.
@
text
@a103 1
/*************inferior_died ();****VK**************/
@


1.3
log
@2002-02-05  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c: Define PTRACE_ARG3_TYPE.
        (read_inferior_memory): Use it.
        (write_inferior_memory): Likewise.
@
text
@a23 2
#include "frame.h"
#include "inferior.h"
@


1.2
log
@2002-02-05  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c (create_inferior): Call strerror instead of
        grubbing through sys_errlist.
@
text
@d46 1
a46 2
/* Default the type of the ptrace transfer to int.  */
#ifndef PTRACE_XFER_TYPE
a47 1
#endif
d719 1
a719 1
      buffer[i] = ptrace (PTRACE_PEEKTEXT, inferior_pid, addr, 0);
d746 2
a747 1
  buffer[0] = ptrace (PTRACE_PEEKTEXT, inferior_pid, addr, 0);
d753 3
a755 1
		  addr + (count - 1) * sizeof (PTRACE_XFER_TYPE), 0);
d767 1
a767 1
      ptrace (PTRACE_POKETEXT, inferior_pid, addr, buffer[i]);
@


1.1
log
@2002-02-05  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/linux-low.c: New file, copied exactly from low-linux.c.
@
text
@d35 1
d74 1
a74 1
	       errno < sys_nerr ? sys_errlist[errno] : "unknown error");
@

