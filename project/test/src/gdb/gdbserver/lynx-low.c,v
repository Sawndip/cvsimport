head	1.23;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.18.2.1
	gdb_7_6-2013-04-26-release:1.18
	gdb_7_6-branch:1.18.0.2
	gdb_7_6-2013-03-12-branchpoint:1.18
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.2
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.4.4.1
	gdb_7_4-2012-01-24-release:1.4.4.1
	gdb_7_4-branch:1.4.0.4
	gdb_7_4-2011-12-13-branchpoint:1.4
	gdb_7_3_1-2011-09-04-release:1.4
	gdb_7_3-2011-07-26-release:1.4
	gdb_7_3-branch:1.4.0.2
	gdb_7_3-2011-04-01-branchpoint:1.4;
locks; strict;
comment	@ * @;


1.23
date	2013.10.01.10.56.51;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2013.08.28.17.40.58;	author jkratoch;	state Exp;
branches;
next	1.21;

1.21
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2013.05.17.06.53.53;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.17.06.47.44;	author brobecke;	state Exp;
branches;
next	1.18;

1.18
date	2013.01.07.11.43.42;	author brobecke;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2013.01.07.11.43.16;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2013.01.07.11.39.00;	author brobecke;	state Exp;
branches;
next	1.15;

1.15
date	2013.01.07.11.38.35;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.12.17.11.17.12;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.12.17.11.13.52;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2012.12.17.11.03.00;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2012.12.17.11.02.47;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2012.12.17.10.51.29;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.15.16.12.19;	author muller;	state Exp;
branches;
next	1.7;

1.7
date	2012.05.24.16.51.37;	author palves;	state Exp;
branches;
next	1.6;

1.6
date	2012.05.24.16.39.13;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2010.09.13.19.10.30;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2010.09.13.19.10.19;	author brobecke;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.01.18.57.12;	author brobecke;	state Exp;
branches;
next	;

1.18.2.1
date	2013.08.29.14.24.15;	author jkratoch;	state Exp;
branches;
next	;

1.4.4.1
date	2012.01.06.04.43.37;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.23
log
@[gdbserver/LynxOS]: Incomplete thread list after --attach

The current implementation is forgetting to populate the thread list
when attaching to the process. This results in an incomplete list of
threads when debugging a threaded program.

Unfortunately, as the added comments hints, there appears to be
no way of getting the list of threads via ptrace, other than by
spawning the "ps" command, and parsing its output. Not great,
but it appears to be the best we can do.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_add_threads_after_attach): New function.
        (lynx_attach): Remove call to add_thread.  Add call to
        lynx_add_threads_after_attach instead.
@
text
@/* Copyright (C) 2009-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "target.h"
#include "lynx-low.h"

#include <limits.h>
#include <sys/ptrace.h>
#include <sys/piddef.h> /* Provides PIDGET, TIDGET, BUILDPID, etc.  */
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include "gdb_wait.h"
#include <signal.h>
#include "filestuff.h"

int using_threads = 1;

const struct target_desc *lynx_tdesc;

/* Per-process private data.  */

struct process_info_private
{
  /* The PTID obtained from the last wait performed on this process.
     Initialized to null_ptid until the first wait is performed.  */
  ptid_t last_wait_event_ptid;
};

/* Print a debug trace on standard output if debug_threads is set.  */

static void
lynx_debug (char *string, ...)
{
  va_list args;

  if (!debug_threads)
    return;

  va_start (args, string);
  fprintf (stderr, "DEBUG(lynx): ");
  vfprintf (stderr, string, args);
  fprintf (stderr, "\n");
  va_end (args);
}

/* Build a ptid_t given a PID and a LynxOS TID.  */

static ptid_t
lynx_ptid_build (int pid, long tid)
{
  /* brobecker/2010-06-21: It looks like the LWP field in ptids
     should be distinct for each thread (see write_ptid where it
     writes the thread ID from the LWP).  So instead of storing
     the LynxOS tid in the tid field of the ptid, we store it in
     the lwp field.  */
  return ptid_build (pid, tid, 0);
}

/* Return the process ID of the given PTID.

   This function has little reason to exist, it's just a wrapper around
   ptid_get_pid.  But since we have a getter function for the lynxos
   ptid, it feels cleaner to have a getter for the pid as well.  */

static int
lynx_ptid_get_pid (ptid_t ptid)
{
  return ptid_get_pid (ptid);
}

/* Return the LynxOS tid of the given PTID.  */

static long
lynx_ptid_get_tid (ptid_t ptid)
{
  /* See lynx_ptid_build: The LynxOS tid is stored inside the lwp field
     of the ptid.  */
  return ptid_get_lwp (ptid);
}

/* For a given PTID, return the associated PID as known by the LynxOS
   ptrace layer.  */

static int
lynx_ptrace_pid_from_ptid (ptid_t ptid)
{
  return BUILDPID (lynx_ptid_get_pid (ptid), lynx_ptid_get_tid (ptid));
}

/* Return a string image of the ptrace REQUEST number.  */

static char *
ptrace_request_to_str (int request)
{
#define CASE(X) case X: return #X
  switch (request)
    {
      CASE(PTRACE_TRACEME);
      CASE(PTRACE_PEEKTEXT);
      CASE(PTRACE_PEEKDATA);
      CASE(PTRACE_PEEKUSER);
      CASE(PTRACE_POKETEXT);
      CASE(PTRACE_POKEDATA);
      CASE(PTRACE_POKEUSER);
      CASE(PTRACE_CONT);
      CASE(PTRACE_KILL);
      CASE(PTRACE_SINGLESTEP);
      CASE(PTRACE_ATTACH);
      CASE(PTRACE_DETACH);
      CASE(PTRACE_GETREGS);
      CASE(PTRACE_SETREGS);
      CASE(PTRACE_GETFPREGS);
      CASE(PTRACE_SETFPREGS);
      CASE(PTRACE_READDATA);
      CASE(PTRACE_WRITEDATA);
      CASE(PTRACE_READTEXT);
      CASE(PTRACE_WRITETEXT);
      CASE(PTRACE_GETFPAREGS);
      CASE(PTRACE_SETFPAREGS);
      CASE(PTRACE_GETWINDOW);
      CASE(PTRACE_SETWINDOW);
      CASE(PTRACE_SYSCALL);
      CASE(PTRACE_DUMPCORE);
      CASE(PTRACE_SETWRBKPT);
      CASE(PTRACE_SETACBKPT);
      CASE(PTRACE_CLRBKPT);
      CASE(PTRACE_GET_UCODE);
#ifdef PT_READ_GPR
      CASE(PT_READ_GPR);
#endif
#ifdef PT_WRITE_GPR
      CASE(PT_WRITE_GPR);
#endif
#ifdef PT_READ_FPR
      CASE(PT_READ_FPR);
#endif
#ifdef PT_WRITE_FPR
      CASE(PT_WRITE_FPR);
#endif
#ifdef PT_READ_VPR
      CASE(PT_READ_VPR);
#endif
#ifdef PT_WRITE_VPR
      CASE(PT_WRITE_VPR);
#endif
#ifdef PTRACE_PEEKUSP
      CASE(PTRACE_PEEKUSP);
#endif
#ifdef PTRACE_POKEUSP
      CASE(PTRACE_POKEUSP);
#endif
      CASE(PTRACE_PEEKTHREAD);
      CASE(PTRACE_THREADUSER);
      CASE(PTRACE_FPREAD);
      CASE(PTRACE_FPWRITE);
      CASE(PTRACE_SETSIG);
      CASE(PTRACE_CONT_ONE);
      CASE(PTRACE_KILL_ONE);
      CASE(PTRACE_SINGLESTEP_ONE);
      CASE(PTRACE_GETLOADINFO);
      CASE(PTRACE_GETTRACESIG);
#ifdef PTRACE_GETTHREADLIST
      CASE(PTRACE_GETTHREADLIST);
#endif
    }
#undef CASE

  return "<unknown-request>";
}

/* A wrapper around ptrace that allows us to print debug traces of
   ptrace calls if debug traces are activated.  */

static int
lynx_ptrace (int request, ptid_t ptid, int addr, int data, int addr2)
{
  int result;
  const int pid = lynx_ptrace_pid_from_ptid (ptid);
  int saved_errno;

  if (debug_threads)
    fprintf (stderr, "PTRACE (%s, pid=%d(pid=%d, tid=%d), addr=0x%x, "
             "data=0x%x, addr2=0x%x)",
             ptrace_request_to_str (request), pid, PIDGET (pid), TIDGET (pid),
             addr, data, addr2);
  result = ptrace (request, pid, addr, data, addr2);
  saved_errno = errno;
  if (debug_threads)
    fprintf (stderr, " -> %d (=0x%x)\n", result, result);

  errno = saved_errno;
  return result;
}

/* Call add_process with the given parameters, and initializes
   the process' private data.  */

static struct process_info *
lynx_add_process (int pid, int attached)
{
  struct process_info *proc;

  proc = add_process (pid, attached);
  proc->tdesc = lynx_tdesc;
  proc->private = xcalloc (1, sizeof (*proc->private));
  proc->private->last_wait_event_ptid = null_ptid;

  return proc;
}

/* Implement the create_inferior method of the target_ops vector.  */

static int
lynx_create_inferior (char *program, char **allargs)
{
  int pid;

  lynx_debug ("lynx_create_inferior ()");

  pid = fork ();
  if (pid < 0)
    perror_with_name ("fork");

  if (pid == 0)
    {
      int pgrp;

      close_most_fds ();

      /* Switch child to its own process group so that signals won't
         directly affect gdbserver. */
      pgrp = getpid();
      setpgid (0, pgrp);
      ioctl (0, TIOCSPGRP, &pgrp);
      lynx_ptrace (PTRACE_TRACEME, null_ptid, 0, 0, 0);
      execv (program, allargs);
      fprintf (stderr, "Cannot exec %s: %s.\n", program, strerror (errno));
      fflush (stderr);
      _exit (0177);
    }

  lynx_add_process (pid, 0);
  /* Do not add the process thread just yet, as we do not know its tid.
     We will add it later, during the wait for the STOP event corresponding
     to the lynx_ptrace (PTRACE_TRACEME) call above.  */
  return pid;
}

/* Assuming we've just attached to a running inferior whose pid is PID,
   add all threads running in that process.  */

static void
lynx_add_threads_after_attach (int pid)
{
  /* Ugh!  There appears to be no way to get the list of threads
     in the program we just attached to.  So get the list by calling
     the "ps" command.  This is only needed now, as we will then
     keep the thread list up to date thanks to thread creation and
     exit notifications.  */
  FILE *f;
  char buf[256];
  int thread_pid, thread_tid;

  f = popen ("ps atx", "r");
  if (f == NULL)
    perror_with_name ("Cannot get thread list");

  while (fgets (buf, sizeof (buf), f) != NULL)
    if ((sscanf (buf, "%d %d", &thread_pid, &thread_tid) == 2
	 && thread_pid == pid))
    {
      ptid_t thread_ptid = lynx_ptid_build (pid, thread_tid);

      if (!find_thread_ptid (thread_ptid))
	{
	  lynx_debug ("New thread: (pid = %d, tid = %d)",
		      pid, thread_tid);
	  add_thread (thread_ptid, NULL);
	}
    }

  pclose (f);
}

/* Implement the attach target_ops method.  */

static int
lynx_attach (unsigned long pid)
{
  ptid_t ptid = lynx_ptid_build (pid, 0);

  if (lynx_ptrace (PTRACE_ATTACH, ptid, 0, 0, 0) != 0)
    error ("Cannot attach to process %lu: %s (%d)\n", pid,
	   strerror (errno), errno);

  lynx_add_process (pid, 1);
  lynx_add_threads_after_attach (pid);

  return 0;
}

/* Implement the resume target_ops method.  */

static void
lynx_resume (struct thread_resume *resume_info, size_t n)
{
  /* FIXME: Assume for now that n == 1.  */
  ptid_t ptid = resume_info[0].thread;
  const int request = (resume_info[0].kind == resume_step
                       ? PTRACE_SINGLESTEP : PTRACE_CONT);
  const int signal = resume_info[0].sig;

  /* If given a minus_one_ptid, then try using the current_process'
     private->last_wait_event_ptid.  On most LynxOS versions,
     using any of the process' thread works well enough, but
     LynxOS 178 is a little more sensitive, and triggers some
     unexpected signals (Eg SIG61) when we resume the inferior
     using a different thread.  */
  if (ptid_equal (ptid, minus_one_ptid))
    ptid = current_process()->private->last_wait_event_ptid;

  /* The ptid might still be minus_one_ptid; this can happen between
     the moment we create the inferior or attach to a process, and
     the moment we resume its execution for the first time.  It is
     fine to use the current_inferior's ptid in those cases.  */
  if (ptid_equal (ptid, minus_one_ptid))
    ptid = thread_to_gdb_id (current_inferior);

  regcache_invalidate ();

  errno = 0;
  lynx_ptrace (request, ptid, 1, signal, 0);
  if (errno)
    perror_with_name ("ptrace");
}

/* Resume the execution of the given PTID.  */

static void
lynx_continue (ptid_t ptid)
{
  struct thread_resume resume_info;

  resume_info.thread = ptid;
  resume_info.kind = resume_continue;
  resume_info.sig = 0;

  lynx_resume (&resume_info, 1);
}

/* A wrapper around waitpid that handles the various idiosyncrasies
   of LynxOS' waitpid.  */

static int
lynx_waitpid (int pid, int *stat_loc)
{
  int ret = 0;

  while (1)
    {
      ret = waitpid (pid, stat_loc, WNOHANG);
      if (ret < 0)
        {
	  /* An ECHILD error is not indicative of a real problem.
	     It happens for instance while waiting for the inferior
	     to stop after attaching to it.  */
	  if (errno != ECHILD)
	    perror_with_name ("waitpid (WNOHANG)");
	}
      if (ret > 0)
        break;
      /* No event with WNOHANG.  See if there is one with WUNTRACED.  */
      ret = waitpid (pid, stat_loc, WNOHANG | WUNTRACED);
      if (ret < 0)
        {
	  /* An ECHILD error is not indicative of a real problem.
	     It happens for instance while waiting for the inferior
	     to stop after attaching to it.  */
	  if (errno != ECHILD)
	    perror_with_name ("waitpid (WNOHANG|WUNTRACED)");
	}
      if (ret > 0)
        break;
      usleep (1000);
    }
  return ret;
}

/* Implement the wait target_ops method.  */

static ptid_t
lynx_wait_1 (ptid_t ptid, struct target_waitstatus *status, int options)
{
  int pid;
  int ret;
  int wstat;
  ptid_t new_ptid;

  if (ptid_equal (ptid, minus_one_ptid))
    pid = lynx_ptid_get_pid (thread_to_gdb_id (current_inferior));
  else
    pid = BUILDPID (lynx_ptid_get_pid (ptid), lynx_ptid_get_tid (ptid));

retry:

  ret = lynx_waitpid (pid, &wstat);
  new_ptid = lynx_ptid_build (ret, ((union wait *) &wstat)->w_tid);
  find_process_pid (ret)->private->last_wait_event_ptid = new_ptid;

  /* If this is a new thread, then add it now.  The reason why we do
     this here instead of when handling new-thread events is because
     we need to add the thread associated to the "main" thread - even
     for non-threaded applications where the new-thread events are not
     generated.  */
  if (!find_thread_ptid (new_ptid))
    {
      lynx_debug ("New thread: (pid = %d, tid = %d)",
		  lynx_ptid_get_pid (new_ptid), lynx_ptid_get_tid (new_ptid));
      add_thread (new_ptid, NULL);
    }

  if (WIFSTOPPED (wstat))
    {
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.integer = gdb_signal_from_host (WSTOPSIG (wstat));
      lynx_debug ("process stopped with signal: %d",
                  status->value.integer);
    }
  else if (WIFEXITED (wstat))
    {
      status->kind = TARGET_WAITKIND_EXITED;
      status->value.integer = WEXITSTATUS (wstat);
      lynx_debug ("process exited with code: %d", status->value.integer);
    }
  else if (WIFSIGNALED (wstat))
    {
      status->kind = TARGET_WAITKIND_SIGNALLED;
      status->value.integer = gdb_signal_from_host (WTERMSIG (wstat));
      lynx_debug ("process terminated with code: %d",
                  status->value.integer);
    }
  else
    {
      /* Not sure what happened if we get here, or whether we can
	 in fact get here.  But if we do, handle the event the best
	 we can.  */
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.integer = gdb_signal_from_host (0);
      lynx_debug ("unknown event ????");
    }

  /* SIGTRAP events are generated for situations other than single-step/
     breakpoint events (Eg. new-thread events).  Handle those other types
     of events, and resume the execution if necessary.  */
  if (status->kind == TARGET_WAITKIND_STOPPED
      && status->value.integer == GDB_SIGNAL_TRAP)
    {
      const int realsig = lynx_ptrace (PTRACE_GETTRACESIG, new_ptid, 0, 0, 0);

      lynx_debug ("(realsig = %d)", realsig);
      switch (realsig)
	{
	  case SIGNEWTHREAD:
	    /* We just added the new thread above.  No need to do anything
	       further.  Just resume the execution again.  */
	    lynx_continue (new_ptid);
	    goto retry;

	  case SIGTHREADEXIT:
	    remove_thread (find_thread_ptid (new_ptid));
	    lynx_continue (new_ptid);
	    goto retry;
	}
    }

  return new_ptid;
}

/* A wrapper around lynx_wait_1 that also prints debug traces when
   such debug traces have been activated.  */

static ptid_t
lynx_wait (ptid_t ptid, struct target_waitstatus *status, int options)
{
  ptid_t new_ptid;

  lynx_debug ("lynx_wait (pid = %d, tid = %ld)",
              lynx_ptid_get_pid (ptid), lynx_ptid_get_tid (ptid));
  new_ptid = lynx_wait_1 (ptid, status, options);
  lynx_debug ("          -> (pid=%d, tid=%ld, status->kind = %d)",
	      lynx_ptid_get_pid (new_ptid), lynx_ptid_get_tid (new_ptid),
	      status->kind);
  return new_ptid;
}

/* Implement the kill target_ops method.  */

static int
lynx_kill (int pid)
{
  ptid_t ptid = lynx_ptid_build (pid, 0);
  struct target_waitstatus status;
  struct process_info *process;

  process = find_process_pid (pid);
  if (process == NULL)
    return -1;

  lynx_ptrace (PTRACE_KILL, ptid, 0, 0, 0);
  lynx_wait (ptid, &status, 0);
  the_target->mourn (process);
  return 0;
}

/* Implement the detach target_ops method.  */

static int
lynx_detach (int pid)
{
  ptid_t ptid = lynx_ptid_build (pid, 0);
  struct process_info *process;

  process = find_process_pid (pid);
  if (process == NULL)
    return -1;

  lynx_ptrace (PTRACE_DETACH, ptid, 0, 0, 0);
  the_target->mourn (process);
  return 0;
}

/* Implement the mourn target_ops method.  */

static void
lynx_mourn (struct process_info *proc)
{
  /* Free our private data.  */
  free (proc->private);
  proc->private = NULL;

  clear_inferiors ();
}

/* Implement the join target_ops method.  */

static void
lynx_join (int pid)
{
  /* The PTRACE_DETACH is sufficient to detach from the process.
     So no need to do anything extra.  */
}

/* Implement the thread_alive target_ops method.  */

static int
lynx_thread_alive (ptid_t ptid)
{
  /* The list of threads is updated at the end of each wait, so it
     should be up to date.  No need to re-fetch it.  */
  return (find_thread_ptid (ptid) != NULL);
}

/* Implement the fetch_registers target_ops method.  */

static void
lynx_fetch_registers (struct regcache *regcache, int regno)
{
  struct lynx_regset_info *regset = lynx_target_regsets;
  ptid_t inferior_ptid = thread_to_gdb_id (current_inferior);

  lynx_debug ("lynx_fetch_registers (regno = %d)", regno);

  while (regset->size >= 0)
    {
      char *buf;
      int res;

      buf = xmalloc (regset->size);
      res = lynx_ptrace (regset->get_request, inferior_ptid, (int) buf, 0, 0);
      if (res < 0)
        perror ("ptrace");
      regset->store_function (regcache, buf);
      free (buf);
      regset++;
    }
}

/* Implement the store_registers target_ops method.  */

static void
lynx_store_registers (struct regcache *regcache, int regno)
{
  struct lynx_regset_info *regset = lynx_target_regsets;
  ptid_t inferior_ptid = thread_to_gdb_id (current_inferior);

  lynx_debug ("lynx_store_registers (regno = %d)", regno);

  while (regset->size >= 0)
    {
      char *buf;
      int res;

      buf = xmalloc (regset->size);
      res = lynx_ptrace (regset->get_request, inferior_ptid, (int) buf, 0, 0);
      if (res == 0)
        {
	  /* Then overlay our cached registers on that.  */
	  regset->fill_function (regcache, buf);
	  /* Only now do we write the register set.  */
	  res = lynx_ptrace (regset->set_request, inferior_ptid, (int) buf,
			     0, 0);
        }
      if (res < 0)
        perror ("ptrace");
      free (buf);
      regset++;
    }
}

/* Implement the read_memory target_ops method.  */

static int
lynx_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  /* On LynxOS, memory reads needs to be performed in chunks the size
     of int types, and they should also be aligned accordingly.  */
  int buf;
  const int xfer_size = sizeof (buf);
  CORE_ADDR addr = memaddr & -(CORE_ADDR) xfer_size;
  ptid_t inferior_ptid = thread_to_gdb_id (current_inferior);

  while (addr < memaddr + len)
    {
      int skip = 0;
      int truncate = 0;

      errno = 0;
      if (addr < memaddr)
        skip = memaddr - addr;
      if (addr + xfer_size > memaddr + len)
        truncate = addr + xfer_size - memaddr - len;
      buf = lynx_ptrace (PTRACE_PEEKTEXT, inferior_ptid, addr, 0, 0);
      if (errno)
        return errno;
      memcpy (myaddr + (addr - memaddr) + skip, (gdb_byte *) &buf + skip,
              xfer_size - skip - truncate);
      addr += xfer_size;
    }

  return 0;
}

/* Implement the write_memory target_ops method.  */

static int
lynx_write_memory (CORE_ADDR memaddr, const unsigned char *myaddr, int len)
{
  /* On LynxOS, memory writes needs to be performed in chunks the size
     of int types, and they should also be aligned accordingly.  */
  int buf;
  const int xfer_size = sizeof (buf);
  CORE_ADDR addr = memaddr & -(CORE_ADDR) xfer_size;
  ptid_t inferior_ptid = thread_to_gdb_id (current_inferior);

  while (addr < memaddr + len)
    {
      int skip = 0;
      int truncate = 0;

      if (addr < memaddr)
        skip = memaddr - addr;
      if (addr + xfer_size > memaddr + len)
        truncate = addr + xfer_size - memaddr - len;
      if (skip > 0 || truncate > 0)
        /* We need to read the memory at this address in order to preserve
           the data that we are not overwriting.  */
        lynx_read_memory (addr, (unsigned char *) &buf, xfer_size);
        if (errno)
          return errno;
      memcpy ((gdb_byte *) &buf + skip, myaddr + (addr - memaddr) + skip,
              xfer_size - skip - truncate);
      errno = 0;
      lynx_ptrace (PTRACE_POKETEXT, inferior_ptid, addr, buf, 0);
      if (errno)
        return errno;
      addr += xfer_size;
    }

  return 0;
}

/* Implement the kill_request target_ops method.  */

static void
lynx_request_interrupt (void)
{
  ptid_t inferior_ptid = thread_to_gdb_id (current_inferior);

  kill (lynx_ptid_get_pid (inferior_ptid), SIGINT);
}

/* The LynxOS target_ops vector.  */

static struct target_ops lynx_target_ops = {
  lynx_create_inferior,
  lynx_attach,
  lynx_kill,
  lynx_detach,
  lynx_mourn,
  lynx_join,
  lynx_thread_alive,
  lynx_resume,
  lynx_wait,
  lynx_fetch_registers,
  lynx_store_registers,
  NULL,  /* prepare_to_access_memory */
  NULL,  /* done_accessing_memory */
  lynx_read_memory,
  lynx_write_memory,
  NULL,  /* look_up_symbols */
  lynx_request_interrupt,
  NULL,  /* read_auxv */
  NULL,  /* insert_point */
  NULL,  /* remove_point */
  NULL,  /* stopped_by_watchpoint */
  NULL,  /* stopped_data_address */
  NULL,  /* read_offsets */
  NULL,  /* get_tls_address */
  NULL,  /* qxfer_spu */
  NULL,  /* hostio_last_error */
  NULL,  /* qxfer_osdata */
  NULL,  /* qxfer_siginfo */
  NULL,  /* supports_non_stop */
  NULL,  /* async */
  NULL,  /* start_non_stop */
  NULL,  /* supports_multi_process */
  NULL,  /* handle_monitor_command */
};

void
initialize_low (void)
{
  set_target_ops (&lynx_target_ops);
  the_low_target.arch_setup ();
}

@


1.22
log
@PR server/15604

gdb/gdbserver/
2013-08-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c: Include filestuff.h.
	(linux_create_inferior) <pid == 0>: Call close_most_fds.
	* lynx-low.c: Include filestuff.h.
	(lynx_create_inferior) <pid == 0>: Call close_most_fds.
	* server.c: Include filestuff.h.
	(main): Call notice_open_fds.
	* spu-low.c: Include filestuff.h.
	(spu_create_inferior) <pid == 0>: Call close_most_fds.
@
text
@d265 36
d313 1
a313 1
  add_thread (ptid, NULL);
@


1.21
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@d30 1
d244 2
@


1.20
log
@[gdbserver/lynx178]: Fix null_ptid -vs- minus_one_ptid confusion in comment

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_resume): Fix null_ptid/minus_one_ptid
        confusion in comment.
@
text
@d33 2
d219 1
@


1.19
log
@gdbserver/lynx178: spurious SIG61 signal when resuming inferior.

On ppc-lynx178, resuming the execution of a program after hitting
a breakpoint sometimes triggers a spurious SIG61 event:

    (gdb) cont
    Continuing.

    Program received signal SIG61, Real-time event 61.
    [Switching to Thread 39]
    0x10002324 in a_test.task1 (<_task>=0x3ffff774) at a_test.adb:30
    30          select  -- Task 1

From this point on, continuing again lets the signal kill the program.
Using "signal 0" or configuring GDB to discard the signal does not
help either, as the program immediately reports the same signal again.

What happens is the following:

  - GDB sends a single-step order to gdbserver: $vCont;s:31
    This tells GDBserver to do a step using thread 0x31=49.
    GDBserver does the step, and thread 49 receives the SIGTRAP
    indicating that the step has finished.

  - GDB then sends a "continue", but this time does not specify
    which thread to continue: $vCont;c
    GDBserver uses an arbitrary thread's ptid to resume the program's
    execution (the current_inferior's ptid was chosen for that).
    See lynx-low.c:lynx_resume:

        if (ptid_equal (ptid, minus_one_ptid))
          ptid = thread_to_gdb_id (current_inferior);

So far on all LynxOS platforms, this has been good enough. But
not so on LynxOS 178. If the ptid used to resume the execution
is not the same as the thread that did the step, we get the weird
signal.

This patch fixes the problem by saving the ptid of the thread
that last caused an event, received during a call to waitpid.
The ptid is saved in per-process private data.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (struct process_info_private): New type.
        (lynx_add_process): New function.
        (lynx_create_inferior, lynx_attach): Replace calls to
        add_process by calls to lynx_add_process.
        (lynx_resume): If PTID is null, then try using
        current_process()->private->last_wait_event_ptid.
        Add comments.
        (lynx_clear_inferiors): Delete.  The contents of that function
        has been inlined in lynx_mourn;
        (lynx_wait_1): Save the ptid in the process's private data.
        (lynx_mourn): Free the process' private data.  Replace call
        to lynx_clear_inferiors by call to clear_inferiors.
@
text
@d287 1
a287 1
  /* If given a null_ptid, then try using the current_process'
d296 4
a299 4
  /* The ptid might still be NULL; this can happen between the moment
     we create the inferior or attach to a process, and the moment
     we resume its execution for the first time.  It is fine to
     use the current_inferior's ptid in those cases.  */
@


1.18
log
@Simplifly ptrace_request_to_str's implementation...

... following Pedro's advice of using a temporary macro.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (ptrace_request_to_str): Define a temporary
        macro and use it to simplify this function's implementation.
@
text
@d33 9
d208 15
d252 1
a252 1
  add_process (pid, 0);
d270 1
a270 1
  add_process (pid, 1);
d287 13
a324 10
/* Remove all inferiors and associated threads.  */

static void
lynx_clear_inferiors (void)
{
  /* We do not use private data, so nothing much to do except calling
     clear_inferiors.  */
  clear_inferiors ();
}

d382 1
d511 5
a515 1
  lynx_clear_inferiors ();
@


1.18.2.1
log
@PR server/15604

gdb/gdbserver/
2013-08-29  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c
	(linux_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	(lynx_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	* remote-utils.c (remote_desc, listen_desc): Remove static qualifier.
	* server.h (remote_desc, listen_desc): New declaration.
	* spu-low.c
	(spu_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
@
text
@a220 6
      if (!remote_connection_is_stdio ())
	{
	  close (listen_desc);
	  if (gdb_connected ())
	    close (remote_desc);
	}
@


1.17
log
@Add ptrace error handling in lynx_resume

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_resume): Call perror_with_name if lynx_ptrace
        sets errno.
@
text
@d99 1
d102 30
a131 90
      case PTRACE_TRACEME:
        return "PTRACE_TRACEME";
        break;
      case PTRACE_PEEKTEXT:
        return "PTRACE_PEEKTEXT";
        break;
      case PTRACE_PEEKDATA:
        return "PTRACE_PEEKDATA";
        break;
      case PTRACE_PEEKUSER:
        return "PTRACE_PEEKUSER";
        break;
      case PTRACE_POKETEXT:
        return "PTRACE_POKETEXT";
        break;
      case PTRACE_POKEDATA:
        return "PTRACE_POKEDATA";
        break;
      case PTRACE_POKEUSER:
        return "PTRACE_POKEUSER";
        break;
      case PTRACE_CONT:
        return "PTRACE_CONT";
        break;
      case PTRACE_KILL:
        return "PTRACE_KILL";
        break;
      case PTRACE_SINGLESTEP:
        return "PTRACE_SINGLESTEP";
        break;
      case PTRACE_ATTACH:
        return "PTRACE_ATTACH";
        break;
      case PTRACE_DETACH:
        return "PTRACE_DETACH";
        break;
      case PTRACE_GETREGS:
        return "PTRACE_GETREGS";
        break;
      case PTRACE_SETREGS:
        return "PTRACE_SETREGS";
        break;
      case PTRACE_GETFPREGS:
        return "PTRACE_GETFPREGS";
        break;
      case PTRACE_SETFPREGS:
        return "PTRACE_SETFPREGS";
        break;
      case PTRACE_READDATA:
        return "PTRACE_READDATA";
        break;
      case PTRACE_WRITEDATA:
        return "PTRACE_WRITEDATA";
        break;
      case PTRACE_READTEXT:
        return "PTRACE_READTEXT";
        break;
      case PTRACE_WRITETEXT:
        return "PTRACE_WRITETEXT";
        break;
      case PTRACE_GETFPAREGS:
        return "PTRACE_GETFPAREGS";
        break;
      case PTRACE_SETFPAREGS:
        return "PTRACE_SETFPAREGS";
        break;
      case PTRACE_GETWINDOW:
        return "PTRACE_GETWINDOW";
        break;
      case PTRACE_SETWINDOW:
        return "PTRACE_SETWINDOW";
        break;
      case PTRACE_SYSCALL:
        return "PTRACE_SYSCALL";
        break;
      case PTRACE_DUMPCORE:
        return "PTRACE_DUMPCORE";
        break;
      case PTRACE_SETWRBKPT:
        return "PTRACE_SETWRBKPT";
        break;
      case PTRACE_SETACBKPT:
        return "PTRACE_SETACBKPT";
        break;
      case PTRACE_CLRBKPT:
        return "PTRACE_CLRBKPT";
        break;
      case PTRACE_GET_UCODE:
        return "PTRACE_GET_UCODE";
        break;
d133 1
a133 3
      case PT_READ_GPR:
        return "PT_READ_GPR";
        break;
d136 1
a136 3
      case PT_WRITE_GPR:
        return "PT_WRITE_GPR";
        break;
d139 1
a139 3
      case PT_READ_FPR:
        return "PT_READ_FPR";
        break;
d142 1
a142 3
      case PT_WRITE_FPR:
        return "PT_WRITE_FPR";
        break;
d145 1
a145 3
      case PT_READ_VPR:
        return "PT_READ_VPR";
        break;
d148 1
a148 3
      case PT_WRITE_VPR:
        return "PT_WRITE_VPR";
        break;
d151 1
a151 3
      case PTRACE_PEEKUSP:
        return "PTRACE_PEEKUSP";
        break;
d154 1
a154 3
      case PTRACE_POKEUSP:
        return "PTRACE_POKEUSP";
        break;
d156 10
a165 30
      case PTRACE_PEEKTHREAD:
        return "PTRACE_PEEKTHREAD";
        break;
      case PTRACE_THREADUSER:
        return "PTRACE_THREADUSER";
        break;
      case PTRACE_FPREAD:
        return "PTRACE_FPREAD";
        break;
      case PTRACE_FPWRITE:
        return "PTRACE_FPWRITE";
        break;
      case PTRACE_SETSIG:
        return "PTRACE_SETSIG";
        break;
      case PTRACE_CONT_ONE:
        return "PTRACE_CONT_ONE";
        break;
      case PTRACE_KILL_ONE:
        return "PTRACE_KILL_ONE";
        break;
      case PTRACE_SINGLESTEP_ONE:
        return "PTRACE_SINGLESTEP_ONE";
        break;
      case PTRACE_GETLOADINFO:
        return "PTRACE_GETLOADINFO";
        break;
      case PTRACE_GETTRACESIG:
	return "PTRACE_GETTRACESIG";
	break;
d167 1
a167 3
      case PTRACE_GETTHREADLIST:
        return "PTRACE_GETTHREADLIST";
        break;
d170 2
@


1.16
log
@LynxOS: Resume the same thread when receiving a thread create/exit event.

Before this patch, the ptid passed to lynx_resume was completely
ignored, and we used the current_inferior. This resulted in trying
to resume the inferior execution using the wrong ptid after having
received a thread create/exit event, because the inferior_ptid
was still set to the ptid prior to receiving the signal.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_resume): Use the resume_info parameter
        to determine the ptid for the lynx_ptrace call, unless
        it is equal to minus_one_ptid, in which case we use the
        ptid of the current_inferior.
        (lynx_wait_1): After having received a thread create/exit
        event, resume the inferior's execution using the signaling
        thread's ptid, rather than the old ptid.
@
text
@d362 2
d365 2
@


1.15
log
@Delete unused variable in lynx_resume

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_resume): Delete variable ret.
@
text
@a351 1
  ptid_t inferior_ptid = thread_to_gdb_id (current_inferior);
d353 1
d358 3
d362 1
a362 1
  lynx_ptrace (request, inferior_ptid, 1, signal, 0);
d503 1
a503 1
	    lynx_continue (ptid);
d508 1
a508 1
	    lynx_continue (ptid);
@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a356 1
  int ret;
d359 1
a359 1
  ret = lynx_ptrace (request, inferior_ptid, 1, signal, 0);
@


1.13
log
@lynx-low: Add debug trace when new thread is discovered.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_wait_1): Add debug trace before adding
        new thread.
@
text
@d1 1
a1 1
/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.12
log
@Add PTRACE_GETTRACESIG handling in ptrace_request_to_str

We use this ptrace request when handling SIGTRAP signals,
and without this change, the debug trances show:

    PTRACE (<unknown-request>, ...

This patch fixes this.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (ptrace_request_to_str): Add handling for
        PTRACE_GETTRACESIG.
@
text
@d451 5
a455 1
    add_thread (new_ptid, NULL);
@


1.11
log
@Delete unused variable in lynx_attach.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_attach): Delete variable new_process.
@
text
@d258 3
@


1.10
log
@remove unused variable in lynx_create_inferior.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (lynx_create_inferior): Delete variable new_process.
@
text
@a331 1
  struct process_info *new_process;
d338 1
a338 1
  new_process = add_process (pid, 1);
@


1.9
log
@lynx-low.c: PTRACE_GETTHREADLIST may not be defined.

LynxOS 178 does not define this macro.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (ptrace_request_to_str): Do not handle
        PTRACE_GETTHREADLIST if this macro does not exist.
@
text
@a295 1
  struct process_info *new_process;
d320 1
a320 1
  new_process = add_process (pid, 0);
@


1.8
log
@2012-11-15  Pierre Muller  <muller@@sourceware.org>

	ARI fixes: move gdb_wait and gdb_stat headers to common subdirectory.
	* gdb_stat.h: Delete. Moved to common directory.
	* common/gdb_stat.h: New file.
	* gdb_wait.h: Delete. Moved to common directory.
	* common/gdb_wait.h: New file.
	* Makefile.in (H_FILES_NO_SRC): Adapt to new header
	location.
	* contrib/ari/gdb_ari.sh (wait.h rule): Adapt to new gdb_wait.h
	location.
	(stat.h rule): Adapt to new gdb_stat.h location.
	* common/linux-osdata.c: Include "gdb_stat.h" header instead of
	<sys/stat.h> header.
	* common/linux-ptrace.c: Include "gdb_wait.h" header instead of
	<sys/wait.h> header.


gdbserver ChangeLog entry:

2012-11-15  Pierre Muller  <muller@@sourceware.org>

	* configure.ac (AC_CHECK_HEADERS): Add wait.h header.
	* config.in: Regenerate.
	* configure: Regenerate.
	* linux-low.c: Use "gdb_stat.h" header instead of <sys/stat.h> header.
	Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* lynx-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* remote-utils.c: Use "gdb_stat.h" header instead of <sys/stat.h>
	header.
	* server.c: Remove HAVE_WAIT_H conditional.  Use "gdb_wait.h" header
	instead of <sys/wait.h> header.
	* spu-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
@
text
@d258 1
d262 1
@


1.7
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d28 1
a28 1
#include <sys/wait.h>
@


1.6
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d484 1
a484 1
      && status->value.integer == TARGET_SIGNAL_TRAP)
@


1.5
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d453 1
a453 1
      status->value.integer = target_signal_from_host (WSTOPSIG (wstat));
d466 1
a466 1
      status->value.integer = target_signal_from_host (WTERMSIG (wstat));
d476 1
a476 1
      status->value.integer = target_signal_from_host (0);
@


1.4
log
@run copyright.sh for 2011.
@
text
@d1 1
a1 1
/* Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.4.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1 1
a1 1
/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.3
log
@[LynxOS] Remove handling of PTRACE_* values removed in Lynx5.

Some of the PTRACE_ macros/values were removed in LynxOS 5.x.
Since we have not use them so far, the chances that we will use them
one day are very small.  So I decided to delete them.

gdb/gdbserver/ChangeLog:

        * lynx-low.c (ptrace_request_to_str): Remove handling for
        request values that have been removed in LynxOS 5.x.
@
text
@d1 1
a1 1
/* Copyright (C) 2009, 2010 Free Software Foundation, Inc.
@


1.2
log
@[LynxOS] Include sys/ptrace.h instead of ptrace.h.

This is one of the changes needed in order to build gdbserver on
LynxOS 5.x.

Really interesting: On LynxOS 4.x, there is a #warning when sys/ptrace.h
is used (explaining that ptrace.h will be used instead), whereas this
file was removed from LynxOS 5.x. The contents of sys/ptrace.h on 4.x
(or at least the meat of it):

    #if defined(__GNUC__) || defined(__GNUG__)
    #if !defined(__NO_INCLUDE_WARN__)
    #warning Using <ptrace.h> instead of <sys/ptrace.h>
    #endif /* defined(__NO_INCLUDE_WARN__) */
    #endif /* defined(__GNUC__) || defined(__GNUG__) */

    #include <ptrace.h>

The fix I went for, for now, is to just include <sys/ptrace.h>
unconditionally.  I could have done some configury, but we already
have to build with -D__NO_INCLUDE_WARN__ to avoid the warnings
anyway, and that's unvoidable, due to system includes themselves
including the "wrong" header file.

Since <sys/ptrace.h> seems to be the choice that was made for LynxOS,
and since it works to include it on LynxOS 4.x, I think that's the simplest
solution.

gdb/gdbserver/ChangeLog:

        * lynx-low.c, lynx-ppc-low.c: Include <sys/ptrace.h> instead of
        <ptrace.h>
@
text
@a210 10
#ifdef PTRACE_GETVECREGS
      case PTRACE_GETVECREGS:
        return "PTRACE_GETVECREGS";
        break;
#endif
#ifdef PTRACE_SETVECREGS
      case PTRACE_SETVECREGS:
        return "PTRACE_SETVECREGS";
        break;
#endif
a260 30
      case PTRACE_POSTSYSCALL:
        return "PTRACE_POSTSYSCALL";
        break;
      case PTRACE_USE_SIGEXECED:
        return "PTRACE_USE_SIGEXECED";
        break;
      case PTRACE_GETTRACESIG:
        return "PTRACE_GETTRACESIG";
        break;
      case PTRACE_GETCWD:
        return "PTRACE_GETCWD";
        break;
      case PTRACE_TRAPFORK:
        return "PTRACE_TRAPFORK";
        break;
      case PTRACE_GETCHILDPID:
        return "PTRACE_GETCHILDPID";
        break;
      case PTRACE_SYSCALL_ONE:
        return "PTRACE_SYSCALL_ONE";
        break;
      case PTRACE_SIGMASK:
        return "PTRACE_SIGMASK";
        break;
      case PTRACE_GETIWD:
        return "PTRACE_GETIWD";
        break;
      case PTRACE_GETEXECFILE:
        return "PTRACE_GETEXECFILE";
        break;
@


1.1
log
@gdbserver support for powerpc-lynxos (4.x)

This patch adds support for powerpc-lynxos.

gdbserver/ChangeLog:

        * gdbserver/lynx-low.c, gdbserver/lynx-low.h,
        gdbserver/lynx-ppc-low.c: New files.
        * Makefile.in (lynx_low_h): New variable.
        (lynx-low.o, lynx-ppc-low.o): New rules.
        * configure.ac: On LynxOS, link with -lnetinet.
        * configure.srv: Add handling of powerpc-*-lynxos* targets.
        * configure: regenerate.
@
text
@d23 1
a23 1
#include <ptrace.h>
@

