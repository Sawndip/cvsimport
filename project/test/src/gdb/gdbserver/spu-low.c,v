head	1.45;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.42.2.1
	gdb_7_6-2013-04-26-release:1.42
	gdb_7_6-branch:1.42.0.2
	gdb_7_6-2013-03-12-branchpoint:1.42
	gdb_7_5_1-2012-11-29-release:1.39
	gdb_7_5-2012-08-17-release:1.39
	gdb_7_5-branch:1.39.0.2
	gdb_7_5-2012-07-18-branchpoint:1.39
	gdb_7_4_1-2012-04-26-release:1.35.2.1
	gdb_7_4-2012-01-24-release:1.35.2.1
	gdb_7_4-branch:1.35.0.2
	gdb_7_4-2011-12-13-branchpoint:1.35
	gdb_7_3_1-2011-09-04-release:1.34
	gdb_7_3-2011-07-26-release:1.34
	gdb_7_3-branch:1.34.0.2
	gdb_7_3-2011-04-01-branchpoint:1.34
	gdb_7_2-2010-09-02-release:1.31
	gdb_7_2-branch:1.31.0.2
	gdb_7_2-2010-07-07-branchpoint:1.31
	gdb_7_1-2010-03-18-release:1.28
	gdb_7_1-branch:1.28.0.2
	gdb_7_1-2010-02-18-branchpoint:1.28
	gdb_7_0_1-2009-12-22-release:1.25.4.1
	gdb_7_0-2009-10-06-release:1.25.4.1
	gdb_7_0-branch:1.25.0.4
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.15
	msnyder-checkpoint-072509-branch:1.25.0.2
	msnyder-checkpoint-072509-branchpoint:1.25
	arc-insight_6_8-branch:1.15.0.6
	arc-insight_6_8-branchpoint:1.15
	insight_6_8-branch:1.15.0.4
	insight_6_8-branchpoint:1.15
	reverse-20081226-branch:1.17.0.10
	reverse-20081226-branchpoint:1.17
	multiprocess-20081120-branch:1.17.0.8
	multiprocess-20081120-branchpoint:1.17
	reverse-20080930-branch:1.17.0.6
	reverse-20080930-branchpoint:1.17
	reverse-20080717-branch:1.17.0.4
	reverse-20080717-branchpoint:1.17
	msnyder-reverse-20080609-branch:1.17.0.2
	msnyder-reverse-20080609-branchpoint:1.17
	drow-reverse-20070409-branch:1.5.0.2
	drow-reverse-20070409-branchpoint:1.5
	gdb_6_8-2008-03-27-release:1.15
	gdb_6_8-branch:1.15.0.2
	gdb_6_8-2008-02-26-branchpoint:1.15
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	gdb_6_7-branch:1.12.0.2
	gdb_6_7-2007-09-07-branchpoint:1.12
	insight_6_6-20070208-release:1.1.2.1
	gdb_6_6-2006-12-18-release:1.1.2.1
	gdb_6_6-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.45
date	2013.09.05.20.45.39;	author palves;	state Exp;
branches;
next	1.44;

1.44
date	2013.08.28.17.40.58;	author jkratoch;	state Exp;
branches;
next	1.43;

1.43
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2012.11.15.16.12.19;	author muller;	state Exp;
branches;
next	1.40;

1.40
date	2012.11.09.02.58.50;	author qiyao;	state Exp;
branches;
next	1.39;

1.39
date	2012.05.24.16.51.37;	author palves;	state Exp;
branches;
next	1.38;

1.38
date	2012.05.24.16.39.13;	author palves;	state Exp;
branches;
next	1.37;

1.37
date	2012.04.05.11.20.50;	author palves;	state Exp;
branches;
next	1.36;

1.36
date	2012.01.04.08.17.24;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.04.20.20.12;	author devans;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.27.00.16.48;	author palves;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.26.23.17.22;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2010.06.19.17.36.50;	author uweigand;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.12.17.39.42;	author palves;	state Exp;
branches;
next	1.29;

1.29
date	2010.04.11.16.33.56;	author palves;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.21.14.11.21;	author palves;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.27.20.45.20;	author uweigand;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.22.19.33.41;	author aristovski;	state Exp;
branches
	1.25.4.1;
next	1.24;

1.24
date	2009.04.03.14.38.39;	author uweigand;	state Exp;
branches;
next	1.23;

1.23
date	2009.04.01.22.50.24;	author palves;	state Exp;
branches;
next	1.22;

1.22
date	2009.04.01.22.48.05;	author palves;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.01.22.31.45;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.01.22.29.33;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.22.23.57.10;	author palves;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.28.05.54.09;	author uweigand;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.27.03.27.40;	author uweigand;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.01.00.08.25;	author palves;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.07.01.41.29;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.20.18.54.21;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.13.21.03.38;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.12.14.38.32;	author uweigand;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.12.14.31.26;	author uweigand;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.10.21.33.31;	author palves;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.10.21.05.15;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.26.20.10.18;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.25.17.59.43;	author palves;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.22.17.41.37;	author uweigand;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.17.59.08;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.22.17.34.15;	author uweigand;	state Exp;
branches
	1.1.2.1;
next	;

1.42.2.1
date	2013.08.29.14.24.16;	author jkratoch;	state Exp;
branches;
next	;

1.35.2.1
date	2012.01.06.04.43.40;	author brobecke;	state Exp;
branches;
next	;

1.25.4.1
date	2009.09.29.00.39.01;	author uweigand;	state Exp;
branches;
next	;

1.1.2.1
date	2006.11.24.20.11.07;	author uweigand;	state Exp;
branches;
next	;


desc
@@


1.45
log
@[gdbserver] Split a new hostio.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* server.h (handle_vFile, hostio_last_error_from_errno): Move
	to ...
	* hostio.h: ... this new file.
	* hostio.c, server.c, linux-low.c, nto-low.c, spu-low,
	win32-low.c: Include hostio.h.
@
text
@/* Low level interface to SPUs, for the remote server for GDB.
   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   Contributed by Ulrich Weigand <uweigand@@de.ibm.com>.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"

#include "gdb_wait.h"
#include <stdio.h>
#include <sys/ptrace.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/syscall.h>
#include "filestuff.h"
#include "hostio.h"

/* Some older glibc versions do not define this.  */
#ifndef __WNOTHREAD
#define __WNOTHREAD     0x20000000      /* Don't wait on children of other
					   threads in this group */
#endif

#define PTRACE_TYPE_RET long
#define PTRACE_TYPE_ARG3 long

/* Number of registers.  */
#define SPU_NUM_REGS         130
#define SPU_NUM_CORE_REGS    128

/* Special registers.  */
#define SPU_ID_REGNUM        128
#define SPU_PC_REGNUM        129

/* PPU side system calls.  */
#define INSTR_SC	0x44000002
#define NR_spu_run	0x0116

/* These are used in remote-utils.c.  */
int using_threads = 0;

/* Defined in auto-generated file reg-spu.c.  */
void init_registers_spu (void);
extern const struct target_desc *tdesc_spu;

/* Fetch PPU register REGNO.  */
static CORE_ADDR
fetch_ppc_register (int regno)
{
  PTRACE_TYPE_RET res;

  int tid = ptid_get_lwp (current_ptid);

#ifndef __powerpc64__
  /* If running as a 32-bit process on a 64-bit system, we attempt
     to get the full 64-bit register content of the target process.
     If the PPC special ptrace call fails, we're on a 32-bit system;
     just fall through to the regular ptrace call in that case.  */
  {
    char buf[8];

    errno = 0;
    ptrace (PPC_PTRACE_PEEKUSR_3264, tid,
	    (PTRACE_TYPE_ARG3) (regno * 8), buf);
    if (errno == 0)
      ptrace (PPC_PTRACE_PEEKUSR_3264, tid,
	      (PTRACE_TYPE_ARG3) (regno * 8 + 4), buf + 4);
    if (errno == 0)
      return (CORE_ADDR) *(unsigned long long *)buf;
  }
#endif

  errno = 0;
  res = ptrace (PT_READ_U, tid,
		(PTRACE_TYPE_ARG3) (regno * sizeof (PTRACE_TYPE_RET)), 0);
  if (errno != 0)
    {
      char mess[128];
      sprintf (mess, "reading PPC register #%d", regno);
      perror_with_name (mess);
    }

  return (CORE_ADDR) (unsigned long) res;
}

/* Fetch WORD from PPU memory at (aligned) MEMADDR in thread TID.  */
static int
fetch_ppc_memory_1 (int tid, CORE_ADDR memaddr, PTRACE_TYPE_RET *word)
{
  errno = 0;

#ifndef __powerpc64__
  if (memaddr >> 32)
    {
      unsigned long long addr_8 = (unsigned long long) memaddr;
      ptrace (PPC_PTRACE_PEEKTEXT_3264, tid, (PTRACE_TYPE_ARG3) &addr_8, word);
    }
  else
#endif
    *word = ptrace (PT_READ_I, tid, (PTRACE_TYPE_ARG3) (size_t) memaddr, 0);

  return errno;
}

/* Store WORD into PPU memory at (aligned) MEMADDR in thread TID.  */
static int
store_ppc_memory_1 (int tid, CORE_ADDR memaddr, PTRACE_TYPE_RET word)
{
  errno = 0;

#ifndef __powerpc64__
  if (memaddr >> 32)
    {
      unsigned long long addr_8 = (unsigned long long) memaddr;
      ptrace (PPC_PTRACE_POKEDATA_3264, tid, (PTRACE_TYPE_ARG3) &addr_8, word);
    }
  else
#endif
    ptrace (PT_WRITE_D, tid, (PTRACE_TYPE_ARG3) (size_t) memaddr, word);

  return errno;
}

/* Fetch LEN bytes of PPU memory at MEMADDR to MYADDR.  */
static int
fetch_ppc_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int i, ret;

  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_TYPE_RET);
  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)
	       / sizeof (PTRACE_TYPE_RET));
  PTRACE_TYPE_RET *buffer;

  int tid = ptid_get_lwp (current_ptid);

  buffer = (PTRACE_TYPE_RET *) alloca (count * sizeof (PTRACE_TYPE_RET));
  for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))
    if ((ret = fetch_ppc_memory_1 (tid, addr, &buffer[i])) != 0)
      return ret;

  memcpy (myaddr,
	  (char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),
	  len);

  return 0;
}

/* Store LEN bytes from MYADDR to PPU memory at MEMADDR.  */
static int
store_ppc_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  int i, ret;

  CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_TYPE_RET);
  int count = ((((memaddr + len) - addr) + sizeof (PTRACE_TYPE_RET) - 1)
	       / sizeof (PTRACE_TYPE_RET));
  PTRACE_TYPE_RET *buffer;

  int tid = ptid_get_lwp (current_ptid);

  buffer = (PTRACE_TYPE_RET *) alloca (count * sizeof (PTRACE_TYPE_RET));

  if (addr != memaddr || len < (int) sizeof (PTRACE_TYPE_RET))
    if ((ret = fetch_ppc_memory_1 (tid, addr, &buffer[0])) != 0)
      return ret;

  if (count > 1)
    if ((ret = fetch_ppc_memory_1 (tid, addr + (count - 1)
					       * sizeof (PTRACE_TYPE_RET),
				   &buffer[count - 1])) != 0)
      return ret;

  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_TYPE_RET) - 1)),
	  myaddr, len);

  for (i = 0; i < count; i++, addr += sizeof (PTRACE_TYPE_RET))
    if ((ret = store_ppc_memory_1 (tid, addr, buffer[i])) != 0)
      return ret;

  return 0;
}


/* If the PPU thread is currently stopped on a spu_run system call,
   return to FD and ADDR the file handle and NPC parameter address
   used with the system call.  Return non-zero if successful.  */
static int
parse_spufs_run (int *fd, CORE_ADDR *addr)
{
  unsigned int insn;
  CORE_ADDR pc = fetch_ppc_register (32);  /* nip */

  /* Fetch instruction preceding current NIP.  */
  if (fetch_ppc_memory (pc-4, (char *) &insn, 4) != 0)
    return 0;
  /* It should be a "sc" instruction.  */
  if (insn != INSTR_SC)
    return 0;
  /* System call number should be NR_spu_run.  */
  if (fetch_ppc_register (0) != NR_spu_run)
    return 0;

  /* Register 3 contains fd, register 4 the NPC param pointer.  */
  *fd = fetch_ppc_register (34);  /* orig_gpr3 */
  *addr = fetch_ppc_register (4);
  return 1;
}


/* Copy LEN bytes at OFFSET in spufs file ANNEX into/from READBUF or WRITEBUF,
   using the /proc file system.  */
static int
spu_proc_xfer_spu (const char *annex, unsigned char *readbuf,
		   const unsigned char *writebuf,
		   CORE_ADDR offset, int len)
{
  char buf[128];
  int fd = 0;
  int ret = -1;

  if (!annex)
    return 0;

  sprintf (buf, "/proc/%ld/fd/%s", ptid_get_lwp (current_ptid), annex);
  fd = open (buf, writebuf? O_WRONLY : O_RDONLY);
  if (fd <= 0)
    return -1;

  if (offset != 0
      && lseek (fd, (off_t) offset, SEEK_SET) != (off_t) offset)
    {
      close (fd);
      return 0;
    }

  if (writebuf)
    ret = write (fd, writebuf, (size_t) len);
  else if (readbuf)
    ret = read (fd, readbuf, (size_t) len);

  close (fd);
  return ret;
}


/* Start an inferior process and returns its pid.
   ALLARGS is a vector of program-name and args. */
static int
spu_create_inferior (char *program, char **allargs)
{
  int pid;
  ptid_t ptid;
  struct process_info *proc;

  pid = fork ();
  if (pid < 0)
    perror_with_name ("fork");

  if (pid == 0)
    {
      close_most_fds ();
      ptrace (PTRACE_TRACEME, 0, 0, 0);

      setpgid (0, 0);

      execv (program, allargs);
      if (errno == ENOENT)
	execvp (program, allargs);

      fprintf (stderr, "Cannot exec %s: %s.\n", program,
	       strerror (errno));
      fflush (stderr);
      _exit (0177);
    }

  proc = add_process (pid, 0);
  proc->tdesc = tdesc_spu;

  ptid = ptid_build (pid, pid, 0);
  add_thread (ptid, NULL);
  return pid;
}

/* Attach to an inferior process.  */
int
spu_attach (unsigned long  pid)
{
  ptid_t ptid;
  struct process_info *proc;

  if (ptrace (PTRACE_ATTACH, pid, 0, 0) != 0)
    {
      fprintf (stderr, "Cannot attach to process %ld: %s (%d)\n", pid,
	       strerror (errno), errno);
      fflush (stderr);
      _exit (0177);
    }

  proc = add_process (pid, 1);
  proc->tdesc = tdesc_spu;
  ptid = ptid_build (pid, pid, 0);
  add_thread (ptid, NULL);
  return 0;
}

/* Kill the inferior process.  */
static int
spu_kill (int pid)
{
  int status, ret;
  struct process_info *process = find_process_pid (pid);
  if (process == NULL)
    return -1;

  ptrace (PTRACE_KILL, pid, 0, 0);

  do {
    ret = waitpid (pid, &status, 0);
    if (WIFEXITED (status) || WIFSIGNALED (status))
      break;
  } while (ret != -1 || errno != ECHILD);

  clear_inferiors ();
  remove_process (process);
  return 0;
}

/* Detach from inferior process.  */
static int
spu_detach (int pid)
{
  struct process_info *process = find_process_pid (pid);
  if (process == NULL)
    return -1;

  ptrace (PTRACE_DETACH, pid, 0, 0);

  clear_inferiors ();
  remove_process (process);
  return 0;
}

static void
spu_mourn (struct process_info *process)
{
  remove_process (process);
}

static void
spu_join (int pid)
{
  int status, ret;

  do {
    ret = waitpid (pid, &status, 0);
    if (WIFEXITED (status) || WIFSIGNALED (status))
      break;
  } while (ret != -1 || errno != ECHILD);
}

/* Return nonzero if the given thread is still alive.  */
static int
spu_thread_alive (ptid_t ptid)
{
  return ptid_equal (ptid, current_ptid);
}

/* Resume process.  */
static void
spu_resume (struct thread_resume *resume_info, size_t n)
{
  size_t i;

  for (i = 0; i < n; i++)
    if (ptid_equal (resume_info[i].thread, minus_one_ptid)
	|| ptid_equal (resume_info[i].thread, current_ptid))
      break;

  if (i == n)
    return;

  /* We don't support hardware single-stepping right now, assume
     GDB knows to use software single-stepping.  */
  if (resume_info[i].kind == resume_step)
    fprintf (stderr, "Hardware single-step not supported.\n");

  regcache_invalidate ();

  errno = 0;
  ptrace (PTRACE_CONT, ptid_get_lwp (current_ptid), 0, resume_info[i].sig);
  if (errno)
    perror_with_name ("ptrace");
}

/* Wait for process, returns status.  */
static ptid_t
spu_wait (ptid_t ptid, struct target_waitstatus *ourstatus, int options)
{
  int pid = ptid_get_pid (ptid);
  int w;
  int ret;

  while (1)
    {
      ret = waitpid (pid, &w, WNOHANG | __WALL | __WNOTHREAD);

      if (ret == -1)
	{
	  if (errno != ECHILD)
	    perror_with_name ("waitpid");
	}
      else if (ret > 0)
	break;

      usleep (1000);
    }

  /* On the first wait, continue running the inferior until we are
     blocked inside an spu_run system call.  */
  if (!server_waiting)
    {
      int fd;
      CORE_ADDR addr;

      while (!parse_spufs_run (&fd, &addr))
	{
	  ptrace (PT_SYSCALL, pid, (PTRACE_TYPE_ARG3) 0, 0);
	  waitpid (pid, NULL, __WALL | __WNOTHREAD);
	}
    }

  if (WIFEXITED (w))
    {
      fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
      ourstatus->kind =  TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = WEXITSTATUS (w);
      clear_inferiors ();
      return pid_to_ptid (ret);
    }
  else if (!WIFSTOPPED (w))
    {
      fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;
      ourstatus->value.sig = gdb_signal_from_host (WTERMSIG (w));
      clear_inferiors ();
      return pid_to_ptid (ret);
    }

  /* After attach, we may have received a SIGSTOP.  Do not return this
     as signal to GDB, or else it will try to continue with SIGSTOP ...  */
  if (!server_waiting)
    {
      ourstatus->kind = TARGET_WAITKIND_STOPPED;
      ourstatus->value.sig = GDB_SIGNAL_0;
      return ptid_build (ret, ret, 0);
    }

  ourstatus->kind = TARGET_WAITKIND_STOPPED;
  ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (w));
  return ptid_build (ret, ret, 0);
}

/* Fetch inferior registers.  */
static void
spu_fetch_registers (struct regcache *regcache, int regno)
{
  int fd;
  CORE_ADDR addr;

  /* We must be stopped on a spu_run system call.  */
  if (!parse_spufs_run (&fd, &addr))
    return;

  /* The ID register holds the spufs file handle.  */
  if (regno == -1 || regno == SPU_ID_REGNUM)
    supply_register (regcache, SPU_ID_REGNUM, (char *)&fd);

  /* The NPC register is found at ADDR.  */
  if (regno == -1 || regno == SPU_PC_REGNUM)
    {
      char buf[4];
      if (fetch_ppc_memory (addr, buf, 4) == 0)
	supply_register (regcache, SPU_PC_REGNUM, buf);
    }

  /* The GPRs are found in the "regs" spufs file.  */
  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_CORE_REGS))
    {
      unsigned char buf[16*SPU_NUM_CORE_REGS];
      char annex[32];
      int i;

      sprintf (annex, "%d/regs", fd);
      if (spu_proc_xfer_spu (annex, buf, NULL, 0, sizeof buf) == sizeof buf)
	for (i = 0; i < SPU_NUM_CORE_REGS; i++)
	  supply_register (regcache, i, buf + i*16);
    }
}

/* Store inferior registers.  */
static void
spu_store_registers (struct regcache *regcache, int regno)
{
  int fd;
  CORE_ADDR addr;

  /* ??? Some callers use 0 to mean all registers.  */
  if (regno == 0)
    regno = -1;

  /* We must be stopped on a spu_run system call.  */
  if (!parse_spufs_run (&fd, &addr))
    return;

  /* The NPC register is found at ADDR.  */
  if (regno == -1 || regno == SPU_PC_REGNUM)
    {
      char buf[4];
      collect_register (regcache, SPU_PC_REGNUM, buf);
      store_ppc_memory (addr, buf, 4);
    }

  /* The GPRs are found in the "regs" spufs file.  */
  if (regno == -1 || (regno >= 0 && regno < SPU_NUM_CORE_REGS))
    {
      unsigned char buf[16*SPU_NUM_CORE_REGS];
      char annex[32];
      int i;

      for (i = 0; i < SPU_NUM_CORE_REGS; i++)
	collect_register (regcache, i, buf + i*16);

      sprintf (annex, "%d/regs", fd);
      spu_proc_xfer_spu (annex, NULL, buf, 0, sizeof buf);
    }
}

/* Copy LEN bytes from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.  */
static int
spu_read_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  int fd, ret;
  CORE_ADDR addr;
  char annex[32], lslr_annex[32], buf[32];
  CORE_ADDR lslr;

  /* We must be stopped on a spu_run system call.  */
  if (!parse_spufs_run (&fd, &addr))
    return 0;

  /* Use the "mem" spufs file to access SPU local store.  */
  sprintf (annex, "%d/mem", fd);
  ret = spu_proc_xfer_spu (annex, myaddr, NULL, memaddr, len);
  if (ret > 0)
    return ret == len ? 0 : EIO;

  /* SPU local store access wraps the address around at the
     local store limit.  We emulate this here.  To avoid needing
     an extra access to retrieve the LSLR, we only do that after
     trying the original address first, and getting end-of-file.  */
  sprintf (lslr_annex, "%d/lslr", fd);
  memset (buf, 0, sizeof buf);
  if (spu_proc_xfer_spu (lslr_annex, (unsigned char *)buf, NULL,
			 0, sizeof buf) <= 0)
    return ret;

  lslr = strtoul (buf, NULL, 16);
  ret = spu_proc_xfer_spu (annex, myaddr, NULL, memaddr & lslr, len);

  return ret == len ? 0 : EIO;
}

/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.
   On failure (cannot write the inferior)
   returns the value of errno.  */
static int
spu_write_memory (CORE_ADDR memaddr, const unsigned char *myaddr, int len)
{
  int fd, ret;
  CORE_ADDR addr;
  char annex[32], lslr_annex[32], buf[32];
  CORE_ADDR lslr;

  /* We must be stopped on a spu_run system call.  */
  if (!parse_spufs_run (&fd, &addr))
    return 0;

  /* Use the "mem" spufs file to access SPU local store.  */
  sprintf (annex, "%d/mem", fd);
  ret = spu_proc_xfer_spu (annex, NULL, myaddr, memaddr, len);
  if (ret > 0)
    return ret == len ? 0 : EIO;

  /* SPU local store access wraps the address around at the
     local store limit.  We emulate this here.  To avoid needing
     an extra access to retrieve the LSLR, we only do that after
     trying the original address first, and getting end-of-file.  */
  sprintf (lslr_annex, "%d/lslr", fd);
  memset (buf, 0, sizeof buf);
  if (spu_proc_xfer_spu (lslr_annex, (unsigned char *)buf, NULL,
			 0, sizeof buf) <= 0)
    return ret;

  lslr = strtoul (buf, NULL, 16);
  ret = spu_proc_xfer_spu (annex, NULL, myaddr, memaddr & lslr, len);

  return ret == len ? 0 : EIO;
}

/* Look up special symbols -- unneded here.  */
static void
spu_look_up_symbols (void)
{
}

/* Send signal to inferior.  */
static void
spu_request_interrupt (void)
{
  syscall (SYS_tkill, ptid_get_lwp (current_ptid), SIGINT);
}

static struct target_ops spu_target_ops = {
  spu_create_inferior,
  spu_attach,
  spu_kill,
  spu_detach,
  spu_mourn,
  spu_join,
  spu_thread_alive,
  spu_resume,
  spu_wait,
  spu_fetch_registers,
  spu_store_registers,
  NULL, /* prepare_to_access_memory */
  NULL, /* done_accessing_memory */
  spu_read_memory,
  spu_write_memory,
  spu_look_up_symbols,
  spu_request_interrupt,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  spu_proc_xfer_spu,
  hostio_last_error_from_errno,
};

void
initialize_low (void)
{
  static const unsigned char breakpoint[] = { 0x00, 0x00, 0x3f, 0xff };

  set_target_ops (&spu_target_ops);
  set_breakpoint_data (breakpoint, sizeof breakpoint);
  init_registers_spu ();
}
@


1.44
log
@PR server/15604

gdb/gdbserver/
2013-08-28  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c: Include filestuff.h.
	(linux_create_inferior) <pid == 0>: Call close_most_fds.
	* lynx-low.c: Include filestuff.h.
	(lynx_create_inferior) <pid == 0>: Call close_most_fds.
	* server.c: Include filestuff.h.
	(main): Call notice_open_fds.
	* spu-low.c: Include filestuff.h.
	(spu_create_inferior) <pid == 0>: Call close_most_fds.
@
text
@d33 1
@


1.43
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@d32 1
d278 1
@


1.42
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d59 1
a59 1

d269 1
d291 2
a292 1
  add_process (pid, 0);
d304 1
d314 2
a315 1
  add_process (pid, 1);
@


1.42.2.1
log
@PR server/15604

gdb/gdbserver/
2013-08-29  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR server/15604
	* linux-low.c
	(linux_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	(lynx_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
	* remote-utils.c (remote_desc, listen_desc): Remove static qualifier.
	* server.h (remote_desc, listen_desc): New declaration.
	* spu-low.c
	(spu_create_inferior) <pid == 0 && !remote_connection_is_stdio ()>:
	Close LISTEN_DESC and optionally REMOTE_DESC.
@
text
@a275 6
      if (!remote_connection_is_stdio ())
	{
	  close (listen_desc);
	  if (gdb_connected ())
	    close (remote_desc);
	}
@


1.41
log
@2012-11-15  Pierre Muller  <muller@@sourceware.org>

	ARI fixes: move gdb_wait and gdb_stat headers to common subdirectory.
	* gdb_stat.h: Delete. Moved to common directory.
	* common/gdb_stat.h: New file.
	* gdb_wait.h: Delete. Moved to common directory.
	* common/gdb_wait.h: New file.
	* Makefile.in (H_FILES_NO_SRC): Adapt to new header
	location.
	* contrib/ari/gdb_ari.sh (wait.h rule): Adapt to new gdb_wait.h
	location.
	(stat.h rule): Adapt to new gdb_stat.h location.
	* common/linux-osdata.c: Include "gdb_stat.h" header instead of
	<sys/stat.h> header.
	* common/linux-ptrace.c: Include "gdb_wait.h" header instead of
	<sys/wait.h> header.


gdbserver ChangeLog entry:

2012-11-15  Pierre Muller  <muller@@sourceware.org>

	* configure.ac (AC_CHECK_HEADERS): Add wait.h header.
	* config.in: Regenerate.
	* configure: Regenerate.
	* linux-low.c: Use "gdb_stat.h" header instead of <sys/stat.h> header.
	Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* lynx-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
	* remote-utils.c: Use "gdb_stat.h" header instead of <sys/stat.h>
	header.
	* server.c: Remove HAVE_WAIT_H conditional.  Use "gdb_wait.h" header
	instead of <sys/wait.h> header.
	* spu-low.c: Use "gdb_wait.h" header instead of <sys/wait.h> header.
@
text
@d2 1
a2 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.40
log
@gdb/gdbserver:
2012-11-09  Yao Qi  <yao@@codesourcery.com>

	* spu-low.c (current_ptid): Move it to ..
	* gdbthread.h: ... here.  New.
	* remote-utils.c (read_ptid): Use macro 'current_ptid'.
	* server.c (myresume, process_serial_event): Likewise.
	* thread-db.c (thread_db_find_new_threads): Likewise.
	* tracepoint.c (run_inferior_command): Likewise.
@
text
@d23 1
a23 1
#include <sys/wait.h>
@


1.39
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@a53 3
/* Get current thread ID (Linux task ID).  */
#define current_ptid ((struct inferior_list_entry *)current_inferior)->id

@


1.38
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d468 1
a468 1
      ourstatus->value.sig = TARGET_SIGNAL_0;
@


1.37
log
@2012-04-05  Pedro Alves  <palves@@redhat.com>

	-Werror=strict-aliasing

	* spu-low.c (parse_spufs_run): Avoid dereferencing type-punned
	pointer.
@
text
@d458 1
a458 1
      ourstatus->value.sig = target_signal_from_host (WTERMSIG (w));
d473 1
a473 1
  ourstatus->value.sig = target_signal_from_host (WSTOPSIG (w));
@


1.36
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d209 1
a209 1
  char buf[4];
d213 1
a213 1
  if (fetch_ppc_memory (pc-4, buf, 4) != 0)
d216 1
a216 1
  if (*(unsigned int *)buf != INSTR_SC)
@


1.35
log
@	* linux-low.c (linux_join): Skip process lookup.
	* spu-low.c (spu_join): Ditto.
	* server.c (join_inferiors_callback): Delete.
	(process_serial_event): For 'D' packet (detach) call join_inferior
	directly.
@
text
@d2 1
a2 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.35.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.34
log
@run copyright.sh for 2011.
@
text
@a367 5
  struct process_info *process;

  process = find_process_pid (pid);
  if (process == NULL)
    return;
@


1.33
log
@	* linux-low.c (linux_unprepare_to_access_memory): Rename to ...
	(linux_done_accessing_memory): ... this.
	(linux_target_ops): Adjust.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Adjust.
	* nto-low.c (nto_target_ops): Adjust comment.
	* server.c (gdb_read_memory, gdb_write_memory): Adjust.
	* spu-low.c (spu_target_ops): Adjust comment.
	* target.h (target_ops): Rename unprepare_to_access_memory field
	to done_accessing_memory.
	(unprepare_to_access_memory): Rename to ...
	(done_accessing_memory): ... this.
@
text
@d2 2
a3 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.32
log
@	* linux-low.c (linux_prepare_to_access_memory): New.
	(linux_unprepare_to_access_memory): New.
	(linux_target_ops): Install them.
	* server.c (read_memory): Rename to ...
	(gdb_read_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(write_memory): Rename to ...
	(gdb_write_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(handle_search_memory_1): Adjust.
	(process_serial_event): Adjust.
	* target.h (struct target_ops): New fields
	prepare_to_access_memory and unprepare_to_access_memory.
	(prepare_to_access_memory, unprepare_to_access_memory): New.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Use
	prepare_to_access_memory/prepare_to_access_memory.
	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_target_ops): Adjust.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d657 1
a657 1
  NULL, /* unprepare_to_access_memory */
@


1.31
log
@ChangeLog:

	* spu-multiarch.c (spu_xfer_partial): Wrap around local store
	limit on local store memory accesses.
	* spu-linux-nat.c (spu_xfer_partial): Likewise.
	* spu-tdep.c (spu_lslr): Remove.
	(spu_pointer_to_address): Do not truncate addresses.
	(spu_integer_to_address): Likewise.
	(spu_overlay_new_objfile): Use SPU_OVERLAY_LMA.
	* spu-tdep.h: Add comments.
	(SPUADDR_SPU): Respect SPU_OVERLAY_LMA bit.
	(SPU_OVERLAY_LMA): Define.

gdbserver/ChangeLog:

	* spu-low.c (spu_read_memory): Wrap around local store limit.
	(spu_write_memory): Likewise.

testsuite/ChangeLog:

	* gdb.arch/spu-ls.exp: New file.
	* gdb.arch/spu-ls.c: Likewise.
@
text
@d656 2
@


1.30
log
@	gdb/gdbserver/
	* linux-low.c (linux_mourn): Also remove the process.
	* server.c (handle_target_event): Don't remove the process here.
	* nto-low.c (nto_mourn): New.
	(nto_target_ops): Install it.
	* spu-low.c (spu_mourn): New.
	(spu_target_ops): Install it.
	* win32-low.c (win32_mourn): New.
	(win32_target_ops): Install it.
@
text
@d564 2
a565 1
  char annex[32];
d574 16
d602 2
a603 1
  char annex[32];
d612 16
@


1.29
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d358 6
d615 1
a615 1
  NULL, /* mourn */
@


1.28
log
@	* spu-low.c (spu_fetch_registers, spu_store_registers): Change
	  prototype to take a regcache.  Adjust.
@
text
@a450 1
      remove_process (find_process_pid (ret));
a458 1
      remove_process (find_process_pid (ret));
d609 1
@


1.27
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d480 1
a480 1
spu_fetch_registers (int regno)
d491 1
a491 1
    supply_register (SPU_ID_REGNUM, (char *)&fd);
d498 1
a498 1
	supply_register (SPU_PC_REGNUM, buf);
d511 1
a511 1
	  supply_register (i, buf + i*16);
d517 1
a517 1
spu_store_registers (int regno)
d534 1
a534 1
      collect_register (SPU_PC_REGNUM, buf);
d546 1
a546 1
	collect_register (i, buf + i*16);
@


1.26
log
@	* spu-low.c (spu_kill): Wait for inferior to terminate.
	Call clear_inferiors.
	(spu_detach): Call clear_inferiors.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.25
log
@	* linux-low.c (usr_fetch_inferior_registers): Remove check for regno 0.
	* proc-service.c (ps_lgetregs): Pass -1 to fetch all registers.
	* regcache.c (get_regcache): Likewise.
	* spu-low.c (spu_fetch_registers): Remove 0 to -1 conversion.
	* win32-low.c (child_fetch_inferior_registers): Remove check for
	regno 0.
@
text
@d324 1
d330 8
d351 2
@


1.25.4.1
log
@	* spu-low.c (spu_kill): Wait for inferior to terminate.
	Call clear_inferiors.
	(spu_detach): Call clear_inferiors.
@
text
@a323 1
  int status, ret;
a328 8

  do {
    ret = waitpid (pid, &status, 0);
    if (WIFEXITED (status) || WIFSIGNALED (status))
      break;
  } while (ret != -1 || errno != ECHILD);

  clear_inferiors ();
a341 2

  clear_inferiors ();
@


1.24
log
@	* remote-utils.c (prepare_resume_reply): Null-terminate packet.
	* spu-low.c (current_tid): Rename to ...
	(current_ptid): ... this.
	(fetch_ppc_register, fetch_ppc_memory, store_ppc_memory,
	spu_proc_xfer_spu, spu_resume, spu_request_interrupt): Use
	ptid_get_lwp (current_ptid) instead of current_tid.
	(spu_kill, spu_detach, spu_join, spu_wait): Use pid argument
	instead of current_tid.  Use find_process_pid to verify pid
	argument is valid.  Pass proper argument to remove_process.
	(spu_thread_alive): Compare current_ptid instead of current_tid.
	(spu_resume): Likewise.
@
text
@a473 4
  /* ??? Some callers use 0 to mean all registers.  */
  if (regno == 0)
    regno = -1;

@


1.23
log
@2009-04-01  Pedro Alves  <pedro@@codesourcery.com>

	Implement the multiprocess extensions, and add linux multiprocess
	support.

	* server.h (ULONGEST): Declare.
	(struct ptid, ptid_t): New.
	(minus_one_ptid, null_ptid): Declare.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): Declare.
	(struct inferior_list_entry): Change `id' type from unsigned from
	to ptid_t.
	(struct sym_cache, struct breakpoint, struct
	process_info_private): Forward declare.
	(struct process_info): Declare.
	(current_process): Declare.
	(all_processes): Declare.
	(initialize_inferiors): Declare.
	(add_thread): Adjust to use ptid_t.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): Ditto.
	(add_process, remove_process, find_thread_pid): Declare.
	(find_inferior_id): Adjust to use ptid_t.
	(cont_thread, general_thread, step_thread): Change type to ptid_t.
	(multi_process): Declare.
	(push_event): Adjust to use ptid_t.
	(read_ptid, write_ptid): Declare.
	(prepare_resume_reply): Adjust to use ptid_t.
	(clear_symbol_cache): Declare.
	* inferiors.c (all_processes): New.
	(null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): New.
	(add_thread): Change unsigned long to ptid.  Remove gdb_id
	parameter.  Adjust.
	(thread_id_to_gdb_id, thread_to_gdb_id): Change unsigned long to ptid.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Change unsigned long to ptid.
	(gdb_id_to_thread_id, find_inferior_id): Change unsigned long to ptid.
	(loaded_dll, pull_pid_from_list): Adjust.
	(add_process, remove_process, find_process_pid)
	(get_thread_process, current_process, initialize_inferiors): New.
	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_waitstatus) <related_pid>: Ditto.
	(struct target_ops) <kill, detach>: Add `pid' argument.  Change
	return type to int.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <thread_alive>: Change pid's type to ptid_t.
	(struct target_ops) <wait>: Add `ptid' field.  Change return type
	to ptid.
	(kill_inferior, detach_inferior, join_inferior): Add `pid' argument.
	(mywait): Add `ptid' argument.  Change return type to ptid_t.
	(target_pid_to_str): Declare.
	* target.c (set_desired_inferior): Adjust to use ptids.
	(mywait): Add new `ptid' argument.  Adjust.
	(target_pid_to_str): New.
	* mem-break.h (free_all_breakpoints): Declare.
	* mem-break.c (breakpoints): Delelete.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Adjust
	to use per-process breakpoint list.
	(free_all_breakpoints): New.
	* remote-utils.c (struct sym_cache) <name>: Drop `const'.
	(symbol_cache, all_symbols_looked_up): Delete.
	(hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, hex_or_minus_one,
	read_ptid): New.
	(prepare_resume_reply): Change ptid argument's type from unsigned
	long to ptid_t.  Adjust.  Implement W;process and X;process.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust to per-process symbol cache.  *
	* server.c (cont_thread, general_thread, step_thread): Change type
	to ptid_t.
	(attached): Delete.
	(multi_process): New.
	(last_ptid): Change type to ptid_t.
	(struct vstop_notif) <ptid>: Change type to ptid_t.
	(queue_stop_reply, push_event): Change `ptid' argument's type to
	ptid_t.
	(discard_queued_stop_replies): Add `pid' argument.
	(start_inferior): Adjust to use ptids.  Adjust to mywait interface
	changes.  Don't reference the `attached' global.
	(attach_inferior): Adjust to mywait interface changes.
	(handle_query): Adjust to use ptids.  Parse GDB's qSupported
	features.  Handle and report "multiprocess+".  Handle
	"qAttached:PID".
	(handle_v_cont): Adjust to use ptids.  Adjust to mywait interface
	changes.
	(handle_v_kill): New.
	(handle_v_stopped): Adjust to use target_pid_to_str.
	(handle_v_requests): Allow multiple attaches and runs when
	multiprocess extensions are in effect.  Handle "vKill".
	(myresume): Adjust to use ptids.
	(queue_stop_reply_callback): Add `arg' parameter.  Handle it.
	(handle_status): Adjust to discard_queued_stop_replies interface
	change.
	(first_thread_of, kill_inferior_callback)
	(detach_or_kill_inferior_callback, join_inferiors_callback): New.
	(main): Call initialize_inferiors.  Adjust to use ptids, killing
	and detaching from all inferiors.  Handle multiprocess packet
	variants.
	* linux-low.h: Include gdb_proc_service.h.
	(struct process_info_private): New.
	(struct linux_target_ops) <pid_of>: Use ptid_get_pid.
	<lwpid_of>: Use ptid_get_lwp.
	(get_lwp_thread): Adjust.
	(struct lwp_info): Add `dead' member.
	(find_lwp_pid): Declare.
	* linux-low.c (thread_db_active): Delete.
	(new_inferior): Adjust comment.
	(inferior_pid): Delete.
	(linux_add_process): New.
	(handle_extended_wait): Adjust.
	(add_lwp): Change unsigned long to ptid.
	(linux_create_inferior): Add process to processes table.  Adjust
	to use ptids.  Don't set new_inferior here.
	(linux_attach_lwp): Rename to ...
	(linux_attach_lwp_1): ... this.  Add `initial' argument.  Handle
	it.  Adjust to use ptids.
	(linux_attach_lwp): New.
	(linux_attach): Add process to processes table.  Don't set
	new_inferior here.
	(struct counter): New.
	(second_thread_of_pid_p, last_thread_of_process_p): New.
	(linux_kill_one_lwp): Add `args' parameter.  Handle it.  Adjust to
	multiple processes.
	(linux_kill): Add `pid' argument.  Handle it.  Adjust to multiple
	processes.  Remove process from process table.
	(linux_detach_one_lwp): Add `args' parameter.  Handle it.  Adjust
	to multiple processes.
	(any_thread_of): New.
	(linux_detach): Add `pid' argument, and handle it.  Remove process
	from processes table.
	(linux_join): Add `pid' argument.  Handle it.
	(linux_thread_alive): Change unsighed long argument to ptid_t.
	Consider dead lwps as not being alive.
	(status_pending_p): Rename `dummy' argument to `arg'.  Filter out
	threads we're not interested in.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_lwp): Change `pid' argument's type from int to
	ptid_t.  Adjust.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.  Change `pid' argument's type
	from int to ptid_t.  Adjust.
	(linux_wait_for_event): New.
	(linux_wait_1): Add `ptid' argument.  Change return type to
	ptid_t.  Adjust.  Use last_thread_of_process_p.  Remove processes
	that exit from the process table.
	(linux_wait): Add `ptid' argument.  Change return type to ptid_t.
	Adjust.
	(mark_lwp_dead): New.
	(wait_for_sigstop): Adjust to use ptids.  If a process exits while
	stopping all threads, mark its main lwp as dead.
	(linux_set_resume_request, linux_resume_one_thread): Adjust to use
	ptids.
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory): Inline `inferior_pid'.
	(linux_look_up_symbols): Adjust to use per-process
	`thread_db_active'.
	(linux_request_interrupt): Adjust to use ptids.
	(linux_read_auxv): Inline `inferior_pid'.
	(initialize_low): Don't reference thread_db_active.
	* gdb_proc_service.h (struct ps_prochandle) <pid>: Remove.
	* proc-service.c (ps_lgetregs): Use find_lwp_pid.
	(ps_getpid): Return the pid of the current inferior.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(thread_db_create_event, thread_db_enable_reporting): Adjust to
	per-process data.
	(find_one_thread): Change argument type to ptid_t.  Adjust to
	per-process data.
	(maybe_attach_thread): Adjust to per-process data and ptids.
	(thread_db_find_new_threads): Ditto.
	(thread_db_init): Ditto.
	* spu-low.c (spu_create_inferior, spu_attach): Add process to
	processes table.  Adjust to use ptids.
	(spu_kill, spu_detach): Adjust interface.  Remove process from
	processes table.
	(spu_join, spu_thread_alive): Adjust interface.
	(spu_wait): Adjust interface.  Remove process from processes
	table.  Adjust to use ptids.
	* win32-low.c (current_inferior_tid): Delete.
	(current_inferior_ptid): New.
	(debug_event_ptid): New.
	(thread_rec): Take a ptid.  Adjust.
	(child_add_thread): Add `pid' argument.  Adjust to use ptids.
	(child_delete_thread): Ditto.
	(do_initial_child_stuff): Add `attached' argument.  Add process to
	processes table.
	(child_fetch_inferior_registers, child_store_inferior_registers):
	Adjust.
	(win32_create_inferior): Pass 0 to do_initial_child_stuff.
	(win32_attach): Pass 1 to do_initial_child_stuff.
	(win32_kill): Adjust interface.  Remove process from processes
	table.
	(win32_detach): Ditto.
	(win32_join): Adjust interface.
	(win32_thread_alive): Take a ptid.
	(win32_resume): Adjust to use ptids.
	(get_child_debug_event): Ditto.
	(win32_wait): Adjust interface.  Remove exiting process from
	processes table.
@
text
@d55 1
a55 1
#define current_tid ((struct inferior_list_entry *)current_inferior)->id
d70 1
a70 1
  int tid = current_tid;
d153 1
a153 1
  int tid = current_tid;
d178 1
a178 1
  int tid = current_tid;
d243 1
a243 1
  sprintf (buf, "/proc/%ld/fd/%s", current_tid, annex);
d322 1
a322 1
spu_kill (int)
d324 6
a329 2
  ptrace (PTRACE_KILL, current_tid, 0, 0);
  remove_process (pid);
d337 6
a342 2
  ptrace (PTRACE_DETACH, current_tid, 0, 0);
  remove_process (pid);
d350 5
d357 1
a357 1
    ret = waitpid (current_tid, &status, 0);
d367 1
a367 1
  return ptid_get_lwp (ptid) == current_tid;
d378 1
a378 1
	|| ptid_get_lwp (resume_info[i].thread) == current_tid)
d392 1
a392 1
  ptrace (PTRACE_CONT, current_tid, 0, resume_info[i].sig);
d401 1
a401 1
  int tid = current_tid;
d407 1
a407 1
      ret = waitpid (tid, &w, WNOHANG | __WALL | __WNOTHREAD);
d429 2
a430 2
	  ptrace (PT_SYSCALL, tid, (PTRACE_TYPE_ARG3) 0, 0);
	  waitpid (tid, NULL, __WALL | __WNOTHREAD);
a433 2
  ret = current_tid;

d440 1
a440 1
      remove_process (ret);
d449 1
a449 1
      remove_process (ret);
d596 1
a596 1
  syscall (SYS_tkill, current_tid, SIGINT);
@


1.22
log
@	Non-stop mode support.

	* server.h (non_stop): Declare.
	(gdb_client_data, handler_func): Declare.
	(delete_file_handler, add_file_handler, start_event_loop):
	Declare.
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif): Declare.
	* target.h (enum resume_kind): New.
	(struct thread_resume): Replace `step' field by `kind' field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <wait>: Add `options' argument.
	<supports_non_stop, async, start_non_stop>: New fields.
	(target_supports_non_stop, target_async): New.
	(start_non_stop): Declare.
	(mywait): Add `options' argument.
	* target.c (mywait): Add `options' argument.  Print child exit
	notifications here.
	(start_non_stop): New.
	* server.c (non_stop, own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New global.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to use resume_kind.  Adjust to mywait
	interface changes.
	(attach_inferior): In non-stop mode, don't wait for the target
	here.
	(handle_general_set): Handle QNonStop.
	(handle_query): When handling qC, return the current general
	thread, instead of the first thread of the list.
	(handle_query): If the backend supports non-stop mode, include
	QNonStop+ in the qSupported query response.
	(handle_v_cont): Adjust to use resume_kind.  Handle resume_stop
	and non-stop mode.
	(handle_v_attach, handle_v_run): Handle non-stop mode.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for vCont;t.  Handle vStopped.
	(myresume): Adjust to use resume_kind.  Handle non-stop.
	(queue_stop_reply_callback): New.
	(handle_status): Handle non-stop mode.
	(main): Clear non_stop flag on reconnection.  Use the event-loop.
	Refactor serial protocol handling from here ...
	(process_serial_event): ... to this new function.  When GDB
	selects any thread, select one here.  In non-stop mode, wait until
	GDB acks all pending events before exiting.
	(handle_serial_event, handle_target_event): New.
	* remote-utils.c (remote_open): Install remote_desc in the event
	loop.
	(remote_close): Remove remote_desc from the event loop.
	(putpkt_binary): Rename to...
	(putpkt_binary_1): ... this.  Add `is_notic' argument.  Handle it.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(prepare_resume_reply): In non-stop mode, don't change the
	general_thread.
	* event-loop.c: New.
	* Makefile.in (OBJ): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (pid_of): Moved here.
	(lwpid_of): New.
	(get_lwp_thread): Use lwpid_of.
	(struct lwp_info): Delete `lwpid' field.  Add `suspended' field.
	* linux-low.c (pid_of): Delete.
	(inferior_pid): Use lwpid_of.
	(linux_event_pipe): New.
	(target_is_async_p): New.
	(delete_lwp): New.
	(handle_extended_wait): Use lwpid_of.
	(add_lwp): Don't set lwpid field.
	(linux_attach_lwp): Adjust debug output.  Use lwpid_of.
	(linux_kill_one_lwp): If killing a running lwp, stop it first.
	Use lwpid_of.  Adjust to linux_wait_for_event interface changes.
	(linux_detach_one_lwp): If detaching from a running lwp, stop it
	first.  Adjust to linux_wait_for_event interface changes.  Use
	lwpid_of.
	(linux_detach): Don't delete the main lwp here.
	(linux_join): Use my_waitpid.  Avoid signal_pid.  Use lwpid_of.
	(status_pending_p): Don't consider explicitly suspended lwps.
	(linux_wait_for_lwp): Take an integer pid instead of a lwp_info
	pointer.  Add OPTIONS argument.  Change return type to int.  Use
	my_waitpid instead of sleeping.  Handle WNOHANG.  Use lwpid_of.
	(linux_wait_for_event): Take an integer pid instead of a lwp_info
	pointer.  Add status pointer argument.  Return a pid instead of a
	status.  Use lwpid_of.  Adjust to linux_wait_for_lwp interface
	changes.  In non-stop mode, don't switch to a random thread.
	(linux_wait): Rename to...
	(linux_wait_1): ... this.  Add target_options argument, and handle
	it.  Adjust to use resume_kind.  Use lwpid_of.  In non-stop mode,
	don't handle the continue thread.  Handle TARGET_WNOHANG.  Merge
	clean exit and signal exit code.  Don't stop all threads in
	non-stop mode.  In all-stop mode, only stop all threads when
	reporting a stop to GDB.  Handle explicit thread stop requests.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(send_sigstop): Use lwpid_of.
	(wait_for_sigstop): Use lwpid_of.  Adjust to linux_wait_for_event
	interface changes.  In non-stop mode, don't switch to a random
	thread.
	(linux_resume_one_lwp): Use lwpid_of.
	(linux_continue_one_thread, linux_queue_one_thread): Merge into ...
	(linux_resume_one_thread): ... this.  Handle resume_stop.  In
	non-stop mode, don't look for pending flag in all threads.
	(resume_status_pending_p): Don't consider explicitly suspended
	threads.
	(my_waitpid): Reimplement.  Emulate __WALL.
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Use lwpid_of.
	(sigchld_handler, linux_supports_non_stop, linux_async)
	(linux_start_non_stop): New.
	(linux_target_ops): Register linux_supports_non_stop, linux_async
	and linux_start_non_stop.
	(initialize_low): Install SIGCHLD handler.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(thread_db_get_tls_address): Use lwpid_of.
	* win32-low.c (win32_detach): Adjust to use resume_kind.
	(win32_wait): Add `options' argument.
	* spu-low.c (spu_resume): Adjust to use resume_kind.
	(spu_wait): Add `options' argument.
@
text
@d271 1
d293 4
a296 1
  add_thread (pid, NULL, pid);
d304 2
d314 3
a316 1
  add_thread (pid, NULL, pid);
d321 2
a322 2
static void
spu_kill (void)
d325 2
d331 1
a331 1
spu_detach (void)
d334 1
d339 1
a339 1
spu_join (void)
d352 1
a352 1
spu_thread_alive (unsigned long tid)
d354 1
a354 1
  return tid == current_tid;
d364 2
a365 2
    if (resume_info[i].thread == -1
	|| resume_info[i].thread == current_tid)
d385 2
a386 2
static unsigned long
spu_wait (struct target_waitstatus *ourstatus, int options)
d429 2
a430 1
      return ret;
d438 2
a439 1
      return ret;
d448 1
a448 1
      return ret;
d453 1
a453 1
  return ret;
@


1.21
log
@	Decouple target code from remote protocol.

	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Return an unsigned long.  Take a
	target_waitstatus pointer instead of a char pointer.
	(mywait): Likewise.
	* target.c (mywait): Change prototype to return an unsigned long.
	Take a target_waitstatus pointer instead of a char pointer.  Adjust.
	* server.h (thread_from_wait, old_thread_from_wait): Delete
	declarations.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.
	* server.c (thread_from_wait, old_thread_from_wait): Delete.
	(last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.  Return a
	pid instead of a signal.
	(attach_inferior): Remove "status" and "signal" parameters.
	Adjust.
	(handle_query): For qGetTLSAddr, parse the thread id with strtol,
	not as an address.
	(handle_v_cont, handle_v_attach, handle_v_run, handle_v_kill)
	(handle_v_requests, myresume): Remove "status" and "signal"
	parameters.  Adjust.
	(handle_status): New.
	(main): Delete local `status'.  Adjust.
	* remote-utils.c: Include target.h.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.  Adjust.

	* linux-low.c (linux_wait): Adjust to new target_ops->wait
	interface.
	* spu-low.c (spu_wait): Adjust.
	* win32-low.c (enum target_waitkind, struct target_waitstatus):
	Delete.
	(win32_wait): Adjust.
@
text
@d362 1
a362 1
  if (resume_info[i].step)
d375 1
a375 1
spu_wait (struct target_waitstatus *ourstatus)
@


1.20
log
@	* target.h (struct thread_resume): Delete leave_stopped member.
	(struct target_ops): Add a `n' argument to the `resume' callback.
	* server.c (start_inferior): Adjust.
	(handle_v_cont, myresume): Adjust.
	* linux-low.c (check_removed_breakpoint): Adjust to resume
	interface change, and to removed leave_stopped field.
	(resume_ptr): Delete.
	(struct thread_resume_array): New.
	(linux_set_resume_request): Add new `arg' parameter.  Adjust to
	resume interface change.
	(linux_continue_one_thread, linux_queue_one_thread)
	(resume_status_pending_p): Check if the resume field is NULL
	instead of checking the leave_stopped member.
	(linux_resume): Adjust to the target resume interface change.
	* spu-low.c (spu_resume): Adjust to the target resume interface
	change.
	* win32-low.c (win32_detach, win32_resume): Ditto.
@
text
@d374 2
a375 2
static unsigned char
spu_wait (char *status)
d410 2
d415 2
a416 1
      *status = 'W';
d418 1
a418 1
      return ((unsigned char) WEXITSTATUS (w));
d423 2
a424 1
      *status = 'X';
d426 1
a426 1
      return ((unsigned char) WTERMSIG (w));
d433 3
a435 2
      *status = 'T';
      return 0;
d438 3
a440 2
  *status = 'T';
  return ((unsigned char) WSTOPSIG (w));
@


1.19
log
@	* i387-fp.c, linux-arm-low.c, linux-cris-low.c,
	linux-crisv32-low.c, linux-i386-low.c, linux-low.c,
	linux-mips-low.c, linux-s390-low.c, linux-sparc-low.c,
	linux-x86-64-low.c, linux-xtensa-low.c, proc-service.c,
	regcache.c, remote-utils.c, server.c, spu-low.c, target.h,
	thread-db.c, win32-low.c, xtensa-xtregs.c, gdbreplay.c,
	Makefile.in, configure.ac: Fix whitespace throughout.
	* configure: Regenerate.
@
text
@d348 1
a348 1
spu_resume (struct thread_resume *resume_info)
d350 1
a350 3
  while (resume_info->thread != -1
	 && resume_info->thread != current_tid)
    resume_info++;
d352 6
a357 1
  if (resume_info->leave_stopped)
d362 1
a362 1
  if (resume_info->step)
d368 1
a368 1
  ptrace (PTRACE_CONT, current_tid, 0, resume_info->sig);
@


1.18
log
@        Updated copyright notices for most files.
@
text
@d36 1
a36 1
				           threads in this group */
d93 1
a93 1
	 	(PTRACE_TYPE_ARG3) (regno * sizeof (PTRACE_TYPE_RET)), 0);
d193 1
a193 1
          myaddr, len);
d206 1
a206 1
static int 
@


1.17
log
@ChangeLog:

	* features/Makefile (%.dat): Emit xmltarget statement.

	* regformats/regdat.sh: Support xmltarget and xmlarch statments.
	Generate code to set gdbserver_xmltarget in init_registers_${name}.

	* regformats/arm-with-iwmmxt.dat: Regenerate.
	* regformats/mips64-linux.dat: Regenerate.
	* regformats/mips-linux.dat: Regenerate.
	* regformats/rs6000/powerpc-32.dat: Regenerate.
	* regformats/rs6000/powerpc-64.dat: Regenerate.
	* regformats/rs6000/powerpc-e500.dat: Regenerate.

	* regformats/reg-arm.dat: Add xmlarch statement.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-i386-linux.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-spu.dat: Likewise.

gdbserver/ChangeLog:

	* regcache.h (gdbserver_xmltarget): Add extern declaration.
	* server.c (gdbserver_xmltarget): Define.
	(get_features_xml): Use it to replace "target.xml" and arch_string.

	* configure.srv: Remove srv_xmltarget.  Add XML files that were
	mentioned there to srv_xmlfiles instead.  Remove conditional tests
	on gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe; set
	srv_xmlfiles and srv_regobj to include all possible choices.
	* configure.ac (srv_xmltarget): Remove.
	(srv_xmlfiles): Do not add "target.xml".
	(gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe): Remove
	checks for supplementary target information.
	* configure: Regenerate.
	* Makefile.in (XML_TARGET): Remove.
	(target.xml): Remove rule.
	(clean): Do not clean up target.xml.
	(.PRECIOUS): Do not mention target.xml.

	* target.h (struct target_ops): Remove arch_string member.
	* linux-low.c (linux_arch_string): Remove.
	(linux_target_ops): Remove arch_string initializer.
	* linux-low.h (struct linux_target_ops): Remove arch_string member.
	* linux-i386-low.c (the_low_target): Remove arch_string initializer.
	* linux-x86-64-low.c (the_low_target): Remove arch_string initializer.
	* spu-low.c (spu_arch_string): Remove.
	(spu_target_ops): Remove arch_string initializer.
	* win32-low.c (win32_arch_string): Remove.
	(win32_target_ops): Remove arch_string initializer.
	* win32-low.h (struct win32_target_ops): Remove arch_string member.
	* win32-arm-low.c (the_low_target): Remove arch_string initializer.
	* win32-i368-low.c (the_low_target): Remove arch_string initializer.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.16
log
@gdb/ChangeLog:

	* regformats/regdat.sh: Rename init_registers function in
	generated file to init_registers_${name}.

	* regformats/reg-crisv32.dat: Set "name" to crisv32.
	* regformats/reg-ppc64.dat: Set "name" to ppc64.
	* regformats/reg-s390x.dat: Set "name" to s390x.

gdbserver/ChangeLog:

	* server.h (init_registers): Remove prototype.

	* linux-low.h (struct linux_target_ops): Add arch_setup field.
	* linux-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* linux-arm-low.c (init_registers_arm): Add prototype.
	(init_registers_arm_with_iwmmxt): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-cris-low.c (init_registers_cris): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-crisv32-low.c (init_registers_crisv32): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-i386-low.c (init_registers_i386_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ia64-low.c (init_registers_ia64): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m32r-low.c (init_registers_m32r): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m68k-low.c (init_registers_m68k): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-mips-low.c (init_registers_mips_linux): Add prototype.
	(init_registers_mips64_linux): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc-low.c (init_registers_ppc): Add prototype.
	(init_registers_powerpc_32, init_registers_powerpc_e500): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc64-low.c (init_registers_ppc64): Add prototype.
	(init_registers_powerpc_64): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-s390-low.c (init_registers_s390): Add prototype.
	(init_registers_s390x): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-sh-low.c (init_registers_sh): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-x86-64-low.c (init_registers_x86_64_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-xtensa-low.c (init_registers_xtensa): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* win32-low.h (struct win32_target_ops): Add arch_setup field.
	* win32-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* win32-arm-low.c (init_registers_arm): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* win32-i386-low.c (init_registers_i386): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* spu-low.c (init_registers_spu): Add prototype.
	(initialize_low): Call initialie_registers_spu () instead of
	initialize_registers ().
@
text
@a565 6
static const char *
spu_arch_string (void)
{
  return "spu";
}

a587 1
  spu_arch_string,
@


1.15
log
@	* hostio.c: Don't include errno.h.
	(errno_to_fileio_errno): Move to hostio-errno.
	* hostio.c: (hostio_error): Remove the error parameter.  Defer the
	error number outputting to the target->hostio_last_error callback.
	(hostio_packet_error): Use FILEIO_EINVAL directly.
	(handle_open, handle_pread, hostio_error, handle_unlink): Update
	calls to hostio_error.
	* hostio-errno.c: New.
	* server.h (hostio_last_error_from_errno): Declare.
	* target.h (target_ops): Add hostio_last_error member.
	* linux-low.c (linux_target_op): Register hostio_last_error_from_errno
	as hostio_last_error handler.
	* spu-low.c (spu_target_ops): Likewise.
	* win32-low.c [_WIN32_WCE] (win32_error_to_fileio_error)
	(wince_hostio_last_error): New functions.
	(win32_target_ops) [_WIN32_WCE]: Register wince_hostio_last_error
	as hostio_last_error handler.
	(win32_target_ops) [!_WIN32_WCE]: Register
	hostio_last_error_from_errno as hostio_last_error handler.
	* Makefile.in (SFILES): Add hostio.c and hostio-errno.c.
	(hostio-errno.o): New rule.
	* configure.ac (GDBSERVER_DEPFILES): Add $srv_hostio_err_objs.
	* configure.srv (srv_hostio_err_objs): New variable.  Default to
	hostio-errno.o.
	(arm*-*-mingw32ce*): Set srv_hostio_err_objs to "".
	* configure: Regenerate.
@
text
@d60 3
d606 1
a606 1
  init_registers ();
@


1.14
log
@	Updated copyright notices for most files.
@
text
@d593 1
@


1.13
log
@	* linux-low.c (linux_wait, linux_resume): Do not handle async I/O.
	* remote-utils.c (remote_open): Do not call disable_async_io.
	(block_async_io): Delete.
	(unblock_async_io): Make static.
	(initialize_async_io): New.
	* server.c (handle_v_cont): Handle async I/O here.
	(myresume): Likewise.  Move other common resume tasks here...
	(main): ... from here.  Call initialize_async_io.  Disable async
	I/O before the main loop.
	* server.h (initialize_async_io): Declare.
	(block_async_io, unblock_async_io): Delete prototypes.
	* spu-low.c (spu_resume, spu_wait): Do not handle async I/O here.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.12
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a350 3
  block_async_io ();
  enable_async_io ();

a374 3
  enable_async_io ();
  unblock_async_io ();

a403 2
  disable_async_io ();

@


1.11
log
@	* linux-low.c (linux_create_inferior): Try execv before execvp.
	* spu-low.c (spu_create_inferior): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.10
log
@2007-06-13  Mike Frysinger  <vapier@@gentoo.org>

	* linux-low.c (linux_create_inferior): Change execv to execvp.
	* spu-low.c (spu_create_inferior): Likewies.
@
text
@d281 3
a283 1
      execvp (program, allargs);
@


1.9
log
@ChangeLog:

	* remote.c (remote_write_qxfer): New function.
	(remote_xfer_partial): Add handling for TARGET_OBJECT_SPU.
	(remote_read_qxfer): Do not cache empty objects.
	(_initialize_remote): Add PACKET_qXfer_spu_read and
	PACKET_qXfer_spu_write.

doc/ChangeLog:

	* gdb.texinfo (General Query Packets): Document qXfer:spu:read
	and qXfer:spu:write packets and mention them under qSupported.

gdbserver/ChangeLog:

	* remote-utils.c (decode_xfer_write): New function.
	* server.h (decode_xfer_write): Add prototype.
	* server.c (handle_query): Add PACKET_LEN argument.  Support
	qXfer:spu:read and qXfer:spu:write packets.
	(main): Pass packet_len to handle_query.
	* spu-low.c (spu_target_ops): Add spu_proc_xfer_spu.
	* target.h (target_ops): Add qxfer_spu.
@
text
@d281 1
a281 1
      execv (program, allargs);
@


1.8
log
@ChangeLog:

	* spu-linux-nat.c (spu_proc_xfer_spu): Do not return failure when
	accessing non-seekable spufs files.

gdbserver/ChangeLog:

	* spu-low.c (spu_proc_xfer_spu): Do not return failure when
	accessing non-seekable spufs files.
@
text
@a576 1

d600 1
@


1.7
log
@	* linux-low.c (linux_detach): Change return type to int.  Return 0.
	* spu-low.c (spu_detach): Likewise.
@
text
@d251 1
a251 1
      return -1;
@


1.6
log
@	* target.h (target_ops): Change return type of detach to int.
	Add join.
	(join_inferior): New.
	* server.c (main): Don't skip detach support on mingw32.
	If the inferior doesn't support detaching return error.
	Call join_inferior instead of using waitpid.
	* linux-low.c (linux_join): New.
	(linux_target_op): Add linux_join.
	* spu-low.c (spu_join): New.
	(spu_target_ops): Add spu_join.
	* win32-low.c (win32_detach): Adapt to new interface.
	Reopen current_process_handle before detaching.  Issue a child
	resume before detaching.
	(win32_join): New.
	(win32_target_op): Add win32_join.
@
text
@d317 1
a317 1
static void
d321 1
@


1.5
log
@	* gdb.texinfo (Monitor commands for gdbserver): New subsection.

	* remote-utils.c (monitor_output): New function.
	* server.c (debug_threads): Define here.
	(monitor_show_help): New function.
	(handle_query): Handle qRcmd.
	(main): Do not handle 'd' packet.
	* server.h (debug_threads, remote_debug, monitor_output): Declare.
	* linux-low.c, spu-low.c, win32-i386-low.c: Remove definitions
	of debug_threads.

	* gdb.server/server-mon.exp: New test.
@
text
@d323 12
d582 1
@


1.4
log
@	* target.h (target_ops): Rename send_signal to request_interrupt,
	and remove enum target_signal parameter.
	* linux-low.c (linux_request_interrupt): Rename from
	linux_send_signal, and always send SIGINT.
	* spu-low.c (spu_request_interrupt): Rename from spu_send_signal,
	and always send SIGINT.
	* remote-utils.c (putpkt_binary): Call request_interrupt, instead
	of send_signal.
	(input_interrupt): Likewise.
@
text
@a60 1
int debug_threads = 0;
@


1.3
log
@        * spu-low.c (spu_arch_string): New.
        (spu_target_ops): Add spu_arch_string.
@
text
@d554 1
a554 1
spu_send_signal (int signo)
d556 1
a556 1
  syscall (SYS_tkill, current_tid, signo);
d579 1
a579 1
  spu_send_signal,
@


1.2
log
@Copyright updates for 2007.
@
text
@d559 6
d581 7
@


1.1
log
@ChangeLog:

	* configure.tgt: Enable gdbserver for SPU target.
	* configure.ac: Build gdbserver when gdb_native is yes.
	* configure: Regenerate.
	* regformats/reg-spu.dat: New file.

gdbserver/ChangeLog:

	* configure.srv: Add target "spu*-*-*".
	* Makefile.in (clean): Remove reg-spu.c.
	(reg-spu.c, reg-spu.o, spu-low.o): Add dependencies.
	* spu-low.c: New file.
@
text
@d2 1
a2 1
   Copyright (C) 2006 Free Software Foundation, Inc.
@


1.1.2.1
log
@ChangeLog:

	* configure.tgt: Enable gdbserver for SPU target.
	* configure.ac: Build gdbserver when gdb_native is yes.
	* configure: Regenerate.
	* regformats/reg-spu.dat: New file.

gdbserver/ChangeLog:

	* configure.srv: Add target "spu*-*-*".
	* Makefile.in (clean): Remove reg-spu.c.
	(reg-spu.c, reg-spu.o, spu-low.o): Add dependencies.
	* spu-low.c: New file.
@
text
@@

