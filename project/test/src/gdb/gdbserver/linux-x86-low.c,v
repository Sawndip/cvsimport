head	1.51;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.44.2.1
	gdb_7_6-2013-04-26-release:1.44
	gdb_7_6-branch:1.44.0.2
	gdb_7_6-2013-03-12-branchpoint:1.44
	gdb_7_5_1-2012-11-29-release:1.42
	gdb_7_5-2012-08-17-release:1.42
	gdb_7_5-branch:1.42.0.2
	gdb_7_5-2012-07-18-branchpoint:1.42
	gdb_7_4_1-2012-04-26-release:1.31.2.1
	gdb_7_4-2012-01-24-release:1.31.2.1
	gdb_7_4-branch:1.31.0.2
	gdb_7_4-2011-12-13-branchpoint:1.31
	gdb_7_3_1-2011-09-04-release:1.26.2.1
	gdb_7_3-2011-07-26-release:1.26.2.1
	gdb_7_3-branch:1.26.0.2
	gdb_7_3-2011-04-01-branchpoint:1.26
	gdb_7_2-2010-09-02-release:1.20
	gdb_7_2-branch:1.20.0.2
	gdb_7_2-2010-07-07-branchpoint:1.20
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.2
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.3
	gdb_7_0-2009-10-06-release:1.3
	gdb_7_0-branch:1.3.0.4
	gdb_7_0-2009-09-16-branchpoint:1.3
	msnyder-checkpoint-072509-branch:1.3.0.2
	msnyder-checkpoint-072509-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.51
date	2013.09.05.20.40.58;	author palves;	state Exp;
branches;
next	1.50;

1.50
date	2013.09.05.20.40.33;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2013.06.12.16.05.39;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2013.06.11.13.32.52;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.31.19.14.33;	author devans;	state Exp;
branches;
next	1.45;

1.45
date	2013.05.23.17.17.50;	author palves;	state Exp;
branches;
next	1.44;

1.44
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2012.07.19.18.27.17;	author eager;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.13.14.39.41;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2012.04.12.21.06.12;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2012.04.12.15.35.32;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2012.03.28.18.30.01;	author palves;	state Exp;
branches;
next	1.38;

1.38
date	2012.03.21.13.43.55;	author tschwinge;	state Exp;
branches;
next	1.37;

1.37
date	2012.03.09.03.47.15;	author qiyao;	state Exp;
branches;
next	1.36;

1.36
date	2012.03.03.04.34.52;	author qiyao;	state Exp;
branches;
next	1.35;

1.35
date	2012.03.01.22.19.47;	author macro;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.27.19.23.43;	author palves;	state Exp;
branches;
next	1.33;

1.33
date	2012.01.04.08.17.23;	author brobecke;	state Exp;
branches;
next	1.32;

1.32
date	2011.12.13.16.11.26;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2011.11.14.20.07.24;	author shebs;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2011.09.15.22.54.12;	author shebs;	state Exp;
branches;
next	1.29;

1.29
date	2011.09.08.22.38.29;	author shebs;	state Exp;
branches;
next	1.28;

1.28
date	2011.05.31.21.18.56;	author palves;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.27.18.37.40;	author froydnj;	state Exp;
branches;
next	1.26;

1.26
date	2011.01.06.00.14.09;	author msnyder;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.24.13.41.43;	author palves;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.27.00.16.48;	author palves;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.26.23.17.22;	author palves;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.25.14.40.21;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2010.06.20.22.23.36;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2010.06.15.10.44.48;	author palves;	state Exp;
branches;
next	1.18;

1.18
date	2010.06.14.22.16.09;	author palves;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.01.13.20.52;	author palves;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.17.14.12.31;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.12.13.25.51;	author palves;	state Exp;
branches;
next	1.14;

1.14
date	2010.04.12.13.18.13;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2010.04.09.03.40.00;	author palves;	state Exp;
branches;
next	1.12;

1.12
date	2010.04.08.22.32.38;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.07.18.49.46;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.03.23.14.18;	author palves;	state Exp;
branches;
next	1.9;

1.9
date	2010.04.01.14.25.34;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2010.03.23.18.00.57;	author palves;	state Exp;
branches;
next	1.7;

1.7
date	2010.03.01.15.33.30;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2010.01.20.22.55.38;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.4;

1.4
date	2009.12.22.00.18.13;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.30.16.35.25;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.13.19.11.04;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.12.22.25.00;	author devans;	state Exp;
branches;
next	;

1.44.2.1
date	2013.06.05.21.15.41;	author devans;	state Exp;
branches;
next	;

1.31.2.1
date	2012.01.06.04.43.37;	author brobecke;	state Exp;
branches;
next	;

1.26.2.1
date	2011.05.31.21.23.41;	author palves;	state Exp;
branches;
next	;


desc
@@


1.51
log
@[gdbserver] Move bytecode compilation bits from server.h to ax.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* server.h (struct emit_ops, current_insn_ptr, emit_error):
	Move ...
        * ax.h: ... here.
@
text
@/* GNU/Linux/x86-64 specific low level interface, for the remote server
   for GDB.
   Copyright (C) 2002-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include <stddef.h>
#include <signal.h>
#include <limits.h>
#include <inttypes.h>
#include "server.h"
#include "linux-low.h"
#include "i387-fp.h"
#include "i386-low.h"
#include "i386-xstate.h"
#include "elf/common.h"

#include "gdb_proc_service.h"
#include "agent.h"
#include "tdesc.h"
#include "tracepoint.h"
#include "ax.h"

#ifdef __x86_64__
/* Defined in auto-generated file amd64-linux.c.  */
void init_registers_amd64_linux (void);
extern const struct target_desc *tdesc_amd64_linux;

/* Defined in auto-generated file amd64-avx-linux.c.  */
void init_registers_amd64_avx_linux (void);
extern const struct target_desc *tdesc_amd64_avx_linux;

/* Defined in auto-generated file x32-linux.c.  */
void init_registers_x32_linux (void);
extern const struct target_desc *tdesc_x32_linux;

/* Defined in auto-generated file x32-avx-linux.c.  */
void init_registers_x32_avx_linux (void);
extern const struct target_desc *tdesc_x32_avx_linux;
#endif

/* Defined in auto-generated file i386-linux.c.  */
void init_registers_i386_linux (void);
extern const struct target_desc *tdesc_i386_linux;

/* Defined in auto-generated file i386-mmx-linux.c.  */
void init_registers_i386_mmx_linux (void);
extern const struct target_desc *tdesc_i386_mmx_linux;

/* Defined in auto-generated file i386-avx-linux.c.  */
void init_registers_i386_avx_linux (void);
extern const struct target_desc *tdesc_i386_avx_linux;

#ifdef __x86_64__
static struct target_desc *tdesc_amd64_linux_no_xml;
#endif
static struct target_desc *tdesc_i386_linux_no_xml;


static unsigned char jump_insn[] = { 0xe9, 0, 0, 0, 0 };
static unsigned char small_jump_insn[] = { 0x66, 0xe9, 0, 0 };

/* Backward compatibility for gdb without XML support.  */

static const char *xmltarget_i386_linux_no_xml = "@@<target>\
<architecture>i386</architecture>\
<osabi>GNU/Linux</osabi>\
</target>";

#ifdef __x86_64__
static const char *xmltarget_amd64_linux_no_xml = "@@<target>\
<architecture>i386:x86-64</architecture>\
<osabi>GNU/Linux</osabi>\
</target>";
#endif

#include <sys/reg.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>
#include <sys/uio.h>

#ifndef PTRACE_GETREGSET
#define PTRACE_GETREGSET	0x4204
#endif

#ifndef PTRACE_SETREGSET
#define PTRACE_SETREGSET	0x4205
#endif


#ifndef PTRACE_GET_THREAD_AREA
#define PTRACE_GET_THREAD_AREA 25
#endif

/* This definition comes from prctl.h, but some kernels may not have it.  */
#ifndef PTRACE_ARCH_PRCTL
#define PTRACE_ARCH_PRCTL      30
#endif

/* The following definitions come from prctl.h, but may be absent
   for certain configurations.  */
#ifndef ARCH_GET_FS
#define ARCH_SET_GS 0x1001
#define ARCH_SET_FS 0x1002
#define ARCH_GET_FS 0x1003
#define ARCH_GET_GS 0x1004
#endif

/* Per-process arch-specific data we want to keep.  */

struct arch_process_info
{
  struct i386_debug_reg_state debug_reg_state;
};

/* Per-thread arch-specific data we want to keep.  */

struct arch_lwp_info
{
  /* Non-zero if our copy differs from what's recorded in the thread.  */
  int debug_registers_changed;
};

#ifdef __x86_64__

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.
   Note that the transfer layout uses 64-bit regs.  */
static /*const*/ int i386_regmap[] = 
{
  RAX * 8, RCX * 8, RDX * 8, RBX * 8,
  RSP * 8, RBP * 8, RSI * 8, RDI * 8,
  RIP * 8, EFLAGS * 8, CS * 8, SS * 8,
  DS * 8, ES * 8, FS * 8, GS * 8
};

#define I386_NUM_REGS (sizeof (i386_regmap) / sizeof (i386_regmap[0]))

/* So code below doesn't have to care, i386 or amd64.  */
#define ORIG_EAX ORIG_RAX

static const int x86_64_regmap[] =
{
  RAX * 8, RBX * 8, RCX * 8, RDX * 8,
  RSI * 8, RDI * 8, RBP * 8, RSP * 8,
  R8 * 8, R9 * 8, R10 * 8, R11 * 8,
  R12 * 8, R13 * 8, R14 * 8, R15 * 8,
  RIP * 8, EFLAGS * 8, CS * 8, SS * 8,
  DS * 8, ES * 8, FS * 8, GS * 8,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1,
  ORIG_RAX * 8
};

#define X86_64_NUM_REGS (sizeof (x86_64_regmap) / sizeof (x86_64_regmap[0]))

#else /* ! __x86_64__ */

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */
static /*const*/ int i386_regmap[] = 
{
  EAX * 4, ECX * 4, EDX * 4, EBX * 4,
  UESP * 4, EBP * 4, ESI * 4, EDI * 4,
  EIP * 4, EFL * 4, CS * 4, SS * 4,
  DS * 4, ES * 4, FS * 4, GS * 4
};

#define I386_NUM_REGS (sizeof (i386_regmap) / sizeof (i386_regmap[0]))

#endif

#ifdef __x86_64__

/* Returns true if the current inferior belongs to a x86-64 process,
   per the tdesc.  */

static int
is_64bit_tdesc (void)
{
  struct regcache *regcache = get_thread_regcache (current_inferior, 0);

  return register_size (regcache->tdesc, 0) == 8;
}

#endif


/* Called by libthread_db.  */

ps_err_e
ps_get_thread_area (const struct ps_prochandle *ph,
		    lwpid_t lwpid, int idx, void **base)
{
#ifdef __x86_64__
  int use_64bit = is_64bit_tdesc ();

  if (use_64bit)
    {
      switch (idx)
	{
	case FS:
	  if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_FS) == 0)
	    return PS_OK;
	  break;
	case GS:
	  if (ptrace (PTRACE_ARCH_PRCTL, lwpid, base, ARCH_GET_GS) == 0)
	    return PS_OK;
	  break;
	default:
	  return PS_BADADDR;
	}
      return PS_ERR;
    }
#endif

  {
    unsigned int desc[4];

    if (ptrace (PTRACE_GET_THREAD_AREA, lwpid,
		(void *) (intptr_t) idx, (unsigned long) &desc) < 0)
      return PS_ERR;

    /* Ensure we properly extend the value to 64-bits for x86_64.  */
    *base = (void *) (uintptr_t) desc[1];
    return PS_OK;
  }
}

/* Get the thread area address.  This is used to recognize which
   thread is which when tracing with the in-process agent library.  We
   don't read anything from the address, and treat it as opaque; it's
   the address itself that we assume is unique per-thread.  */

static int
x86_get_thread_area (int lwpid, CORE_ADDR *addr)
{
#ifdef __x86_64__
  int use_64bit = is_64bit_tdesc ();

  if (use_64bit)
    {
      void *base;
      if (ptrace (PTRACE_ARCH_PRCTL, lwpid, &base, ARCH_GET_FS) == 0)
	{
	  *addr = (CORE_ADDR) (uintptr_t) base;
	  return 0;
	}

      return -1;
    }
#endif

  {
    struct lwp_info *lwp = find_lwp_pid (pid_to_ptid (lwpid));
    struct regcache *regcache = get_thread_regcache (get_lwp_thread (lwp), 1);
    unsigned int desc[4];
    ULONGEST gs = 0;
    const int reg_thread_area = 3; /* bits to scale down register value.  */
    int idx;

    collect_register_by_name (regcache, "gs", &gs);

    idx = gs >> reg_thread_area;

    if (ptrace (PTRACE_GET_THREAD_AREA,
		lwpid_of (lwp),
		(void *) (long) idx, (unsigned long) &desc) < 0)
      return -1;

    *addr = desc[1];
    return 0;
  }
}



static int
x86_cannot_store_register (int regno)
{
#ifdef __x86_64__
  if (is_64bit_tdesc ())
    return 0;
#endif

  return regno >= I386_NUM_REGS;
}

static int
x86_cannot_fetch_register (int regno)
{
#ifdef __x86_64__
  if (is_64bit_tdesc ())
    return 0;
#endif

  return regno >= I386_NUM_REGS;
}

static void
x86_fill_gregset (struct regcache *regcache, void *buf)
{
  int i;

#ifdef __x86_64__
  if (register_size (regcache->tdesc, 0) == 8)
    {
      for (i = 0; i < X86_64_NUM_REGS; i++)
	if (x86_64_regmap[i] != -1)
	  collect_register (regcache, i, ((char *) buf) + x86_64_regmap[i]);
      return;
    }
#endif

  for (i = 0; i < I386_NUM_REGS; i++)
    collect_register (regcache, i, ((char *) buf) + i386_regmap[i]);

  collect_register_by_name (regcache, "orig_eax",
			    ((char *) buf) + ORIG_EAX * 4);
}

static void
x86_store_gregset (struct regcache *regcache, const void *buf)
{
  int i;

#ifdef __x86_64__
  if (register_size (regcache->tdesc, 0) == 8)
    {
      for (i = 0; i < X86_64_NUM_REGS; i++)
	if (x86_64_regmap[i] != -1)
	  supply_register (regcache, i, ((char *) buf) + x86_64_regmap[i]);
      return;
    }
#endif

  for (i = 0; i < I386_NUM_REGS; i++)
    supply_register (regcache, i, ((char *) buf) + i386_regmap[i]);

  supply_register_by_name (regcache, "orig_eax",
			   ((char *) buf) + ORIG_EAX * 4);
}

static void
x86_fill_fpregset (struct regcache *regcache, void *buf)
{
#ifdef __x86_64__
  i387_cache_to_fxsave (regcache, buf);
#else
  i387_cache_to_fsave (regcache, buf);
#endif
}

static void
x86_store_fpregset (struct regcache *regcache, const void *buf)
{
#ifdef __x86_64__
  i387_fxsave_to_cache (regcache, buf);
#else
  i387_fsave_to_cache (regcache, buf);
#endif
}

#ifndef __x86_64__

static void
x86_fill_fpxregset (struct regcache *regcache, void *buf)
{
  i387_cache_to_fxsave (regcache, buf);
}

static void
x86_store_fpxregset (struct regcache *regcache, const void *buf)
{
  i387_fxsave_to_cache (regcache, buf);
}

#endif

static void
x86_fill_xstateregset (struct regcache *regcache, void *buf)
{
  i387_cache_to_xsave (regcache, buf);
}

static void
x86_store_xstateregset (struct regcache *regcache, const void *buf)
{
  i387_xsave_to_cache (regcache, buf);
}

/* ??? The non-biarch i386 case stores all the i387 regs twice.
   Once in i387_.*fsave.* and once in i387_.*fxsave.*.
   This is, presumably, to handle the case where PTRACE_[GS]ETFPXREGS
   doesn't work.  IWBN to avoid the duplication in the case where it
   does work.  Maybe the arch_setup routine could check whether it works
   and update the supported regsets accordingly.  */

static struct regset_info x86_regsets[] =
{
#ifdef HAVE_PTRACE_GETREGS
  { PTRACE_GETREGS, PTRACE_SETREGS, 0, sizeof (elf_gregset_t),
    GENERAL_REGS,
    x86_fill_gregset, x86_store_gregset },
  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_X86_XSTATE, 0,
    EXTENDED_REGS, x86_fill_xstateregset, x86_store_xstateregset },
# ifndef __x86_64__
#  ifdef HAVE_PTRACE_GETFPXREGS
  { PTRACE_GETFPXREGS, PTRACE_SETFPXREGS, 0, sizeof (elf_fpxregset_t),
    EXTENDED_REGS,
    x86_fill_fpxregset, x86_store_fpxregset },
#  endif
# endif
  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, 0, sizeof (elf_fpregset_t),
    FP_REGS,
    x86_fill_fpregset, x86_store_fpregset },
#endif /* HAVE_PTRACE_GETREGS */
  { 0, 0, 0, -1, -1, NULL, NULL }
};

static CORE_ADDR
x86_get_pc (struct regcache *regcache)
{
  int use_64bit = register_size (regcache->tdesc, 0) == 8;

  if (use_64bit)
    {
      unsigned long pc;
      collect_register_by_name (regcache, "rip", &pc);
      return (CORE_ADDR) pc;
    }
  else
    {
      unsigned int pc;
      collect_register_by_name (regcache, "eip", &pc);
      return (CORE_ADDR) pc;
    }
}

static void
x86_set_pc (struct regcache *regcache, CORE_ADDR pc)
{
  int use_64bit = register_size (regcache->tdesc, 0) == 8;

  if (use_64bit)
    {
      unsigned long newpc = pc;
      supply_register_by_name (regcache, "rip", &newpc);
    }
  else
    {
      unsigned int newpc = pc;
      supply_register_by_name (regcache, "eip", &newpc);
    }
}

static const unsigned char x86_breakpoint[] = { 0xCC };
#define x86_breakpoint_len 1

static int
x86_breakpoint_at (CORE_ADDR pc)
{
  unsigned char c;

  (*the_target->read_memory) (pc, &c, 1);
  if (c == 0xCC)
    return 1;

  return 0;
}

/* Support for debug registers.  */

static unsigned long
x86_linux_dr_get (ptid_t ptid, int regnum)
{
  int tid;
  unsigned long value;

  tid = ptid_get_lwp (ptid);

  errno = 0;
  value = ptrace (PTRACE_PEEKUSER, tid,
		  offsetof (struct user, u_debugreg[regnum]), 0);
  if (errno != 0)
    error ("Couldn't read debug register");

  return value;
}

static void
x86_linux_dr_set (ptid_t ptid, int regnum, unsigned long value)
{
  int tid;

  tid = ptid_get_lwp (ptid);

  errno = 0;
  ptrace (PTRACE_POKEUSER, tid,
	  offsetof (struct user, u_debugreg[regnum]), value);
  if (errno != 0)
    error ("Couldn't write debug register");
}

static int
update_debug_registers_callback (struct inferior_list_entry *entry,
				 void *pid_p)
{
  struct lwp_info *lwp = (struct lwp_info *) entry;
  int pid = *(int *) pid_p;

  /* Only update the threads of this process.  */
  if (pid_of (lwp) == pid)
    {
      /* The actual update is done later just before resuming the lwp,
	 we just mark that the registers need updating.  */
      lwp->arch_private->debug_registers_changed = 1;

      /* If the lwp isn't stopped, force it to momentarily pause, so
	 we can update its debug registers.  */
      if (!lwp->stopped)
	linux_stop_lwp (lwp);
    }

  return 0;
}

/* Update the inferior's debug register REGNUM from STATE.  */

void
i386_dr_low_set_addr (const struct i386_debug_reg_state *state, int regnum)
{
  /* Only update the threads of this process.  */
  int pid = pid_of (get_thread_lwp (current_inferior));

  if (! (regnum >= 0 && regnum <= DR_LASTADDR - DR_FIRSTADDR))
    fatal ("Invalid debug register %d", regnum);

  find_inferior (&all_lwps, update_debug_registers_callback, &pid);
}

/* Return the inferior's debug register REGNUM.  */

CORE_ADDR
i386_dr_low_get_addr (int regnum)
{
  struct lwp_info *lwp = get_thread_lwp (current_inferior);
  ptid_t ptid = ptid_of (lwp);

  /* DR6 and DR7 are retrieved with some other way.  */
  gdb_assert (DR_FIRSTADDR <= regnum && regnum <= DR_LASTADDR);

  return x86_linux_dr_get (ptid, regnum);
}

/* Update the inferior's DR7 debug control register from STATE.  */

void
i386_dr_low_set_control (const struct i386_debug_reg_state *state)
{
  /* Only update the threads of this process.  */
  int pid = pid_of (get_thread_lwp (current_inferior));

  find_inferior (&all_lwps, update_debug_registers_callback, &pid);
}

/* Return the inferior's DR7 debug control register.  */

unsigned
i386_dr_low_get_control (void)
{
  struct lwp_info *lwp = get_thread_lwp (current_inferior);
  ptid_t ptid = ptid_of (lwp);

  return x86_linux_dr_get (ptid, DR_CONTROL);
}

/* Get the value of the DR6 debug status register from the inferior
   and record it in STATE.  */

unsigned
i386_dr_low_get_status (void)
{
  struct lwp_info *lwp = get_thread_lwp (current_inferior);
  ptid_t ptid = ptid_of (lwp);

  return x86_linux_dr_get (ptid, DR_STATUS);
}

/* Breakpoint/Watchpoint support.  */

static int
x86_insert_point (char type, CORE_ADDR addr, int len)
{
  struct process_info *proc = current_process ();
  switch (type)
    {
    case '0': /* software-breakpoint */
      {
	int ret;

	ret = prepare_to_access_memory ();
	if (ret)
	  return -1;
	ret = set_gdb_breakpoint_at (addr);
	done_accessing_memory ();
	return ret;
      }
    case '1': /* hardware-breakpoint */
    case '2': /* write watchpoint */
    case '3': /* read watchpoint */
    case '4': /* access watchpoint */
      return i386_low_insert_watchpoint (&proc->private->arch_private->debug_reg_state,
					 type, addr, len);

    default:
      /* Unsupported.  */
      return 1;
    }
}

static int
x86_remove_point (char type, CORE_ADDR addr, int len)
{
  struct process_info *proc = current_process ();
  switch (type)
    {
    case '0': /* software-breakpoint */
      {
	int ret;

	ret = prepare_to_access_memory ();
	if (ret)
	  return -1;
	ret = delete_gdb_breakpoint_at (addr);
	done_accessing_memory ();
	return ret;
      }
    case '1': /* hardware-breakpoint */
    case '2': /* write watchpoint */
    case '3': /* read watchpoint */
    case '4': /* access watchpoint */
      return i386_low_remove_watchpoint (&proc->private->arch_private->debug_reg_state,
					 type, addr, len);
    default:
      /* Unsupported.  */
      return 1;
    }
}

static int
x86_stopped_by_watchpoint (void)
{
  struct process_info *proc = current_process ();
  return i386_low_stopped_by_watchpoint (&proc->private->arch_private->debug_reg_state);
}

static CORE_ADDR
x86_stopped_data_address (void)
{
  struct process_info *proc = current_process ();
  CORE_ADDR addr;
  if (i386_low_stopped_data_address (&proc->private->arch_private->debug_reg_state,
				     &addr))
    return addr;
  return 0;
}

/* Called when a new process is created.  */

static struct arch_process_info *
x86_linux_new_process (void)
{
  struct arch_process_info *info = xcalloc (1, sizeof (*info));

  i386_low_init_dregs (&info->debug_reg_state);

  return info;
}

/* Called when a new thread is detected.  */

static struct arch_lwp_info *
x86_linux_new_thread (void)
{
  struct arch_lwp_info *info = xcalloc (1, sizeof (*info));

  info->debug_registers_changed = 1;

  return info;
}

/* Called when resuming a thread.
   If the debug regs have changed, update the thread's copies.  */

static void
x86_linux_prepare_to_resume (struct lwp_info *lwp)
{
  ptid_t ptid = ptid_of (lwp);
  int clear_status = 0;

  if (lwp->arch_private->debug_registers_changed)
    {
      int i;
      int pid = ptid_get_pid (ptid);
      struct process_info *proc = find_process_pid (pid);
      struct i386_debug_reg_state *state
	= &proc->private->arch_private->debug_reg_state;

      for (i = DR_FIRSTADDR; i <= DR_LASTADDR; i++)
	if (state->dr_ref_count[i] > 0)
	  {
	    x86_linux_dr_set (ptid, i, state->dr_mirror[i]);

	    /* If we're setting a watchpoint, any change the inferior
	       had done itself to the debug registers needs to be
	       discarded, otherwise, i386_low_stopped_data_address can
	       get confused.  */
	    clear_status = 1;
	  }

      x86_linux_dr_set (ptid, DR_CONTROL, state->dr_control_mirror);

      lwp->arch_private->debug_registers_changed = 0;
    }

  if (clear_status || lwp->stopped_by_watchpoint)
    x86_linux_dr_set (ptid, DR_STATUS, 0);
}

/* When GDBSERVER is built as a 64-bit application on linux, the
   PTRACE_GETSIGINFO data is always presented in 64-bit layout.  Since
   debugging a 32-bit inferior with a 64-bit GDBSERVER should look the same
   as debugging it with a 32-bit GDBSERVER, we do the 32-bit <-> 64-bit
   conversion in-place ourselves.  */

/* These types below (compat_*) define a siginfo type that is layout
   compatible with the siginfo type exported by the 32-bit userspace
   support.  */

#ifdef __x86_64__

typedef int compat_int_t;
typedef unsigned int compat_uptr_t;

typedef int compat_time_t;
typedef int compat_timer_t;
typedef int compat_clock_t;

struct compat_timeval
{
  compat_time_t tv_sec;
  int tv_usec;
};

typedef union compat_sigval
{
  compat_int_t sival_int;
  compat_uptr_t sival_ptr;
} compat_sigval_t;

typedef struct compat_siginfo
{
  int si_signo;
  int si_errno;
  int si_code;

  union
  {
    int _pad[((128 / sizeof (int)) - 3)];

    /* kill() */
    struct
    {
      unsigned int _pid;
      unsigned int _uid;
    } _kill;

    /* POSIX.1b timers */
    struct
    {
      compat_timer_t _tid;
      int _overrun;
      compat_sigval_t _sigval;
    } _timer;

    /* POSIX.1b signals */
    struct
    {
      unsigned int _pid;
      unsigned int _uid;
      compat_sigval_t _sigval;
    } _rt;

    /* SIGCHLD */
    struct
    {
      unsigned int _pid;
      unsigned int _uid;
      int _status;
      compat_clock_t _utime;
      compat_clock_t _stime;
    } _sigchld;

    /* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
    struct
    {
      unsigned int _addr;
    } _sigfault;

    /* SIGPOLL */
    struct
    {
      int _band;
      int _fd;
    } _sigpoll;
  } _sifields;
} compat_siginfo_t;

/* For x32, clock_t in _sigchld is 64bit aligned at 4 bytes.  */
typedef long __attribute__ ((__aligned__ (4))) compat_x32_clock_t;

typedef struct compat_x32_siginfo
{
  int si_signo;
  int si_errno;
  int si_code;

  union
  {
    int _pad[((128 / sizeof (int)) - 3)];

    /* kill() */
    struct
    {
      unsigned int _pid;
      unsigned int _uid;
    } _kill;

    /* POSIX.1b timers */
    struct
    {
      compat_timer_t _tid;
      int _overrun;
      compat_sigval_t _sigval;
    } _timer;

    /* POSIX.1b signals */
    struct
    {
      unsigned int _pid;
      unsigned int _uid;
      compat_sigval_t _sigval;
    } _rt;

    /* SIGCHLD */
    struct
    {
      unsigned int _pid;
      unsigned int _uid;
      int _status;
      compat_x32_clock_t _utime;
      compat_x32_clock_t _stime;
    } _sigchld;

    /* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
    struct
    {
      unsigned int _addr;
    } _sigfault;

    /* SIGPOLL */
    struct
    {
      int _band;
      int _fd;
    } _sigpoll;
  } _sifields;
} compat_x32_siginfo_t __attribute__ ((__aligned__ (8)));

#define cpt_si_pid _sifields._kill._pid
#define cpt_si_uid _sifields._kill._uid
#define cpt_si_timerid _sifields._timer._tid
#define cpt_si_overrun _sifields._timer._overrun
#define cpt_si_status _sifields._sigchld._status
#define cpt_si_utime _sifields._sigchld._utime
#define cpt_si_stime _sifields._sigchld._stime
#define cpt_si_ptr _sifields._rt._sigval.sival_ptr
#define cpt_si_addr _sifields._sigfault._addr
#define cpt_si_band _sifields._sigpoll._band
#define cpt_si_fd _sifields._sigpoll._fd

/* glibc at least up to 2.3.2 doesn't have si_timerid, si_overrun.
   In their place is si_timer1,si_timer2.  */
#ifndef si_timerid
#define si_timerid si_timer1
#endif
#ifndef si_overrun
#define si_overrun si_timer2
#endif

static void
compat_siginfo_from_siginfo (compat_siginfo_t *to, siginfo_t *from)
{
  memset (to, 0, sizeof (*to));

  to->si_signo = from->si_signo;
  to->si_errno = from->si_errno;
  to->si_code = from->si_code;

  if (to->si_code == SI_TIMER)
    {
      to->cpt_si_timerid = from->si_timerid;
      to->cpt_si_overrun = from->si_overrun;
      to->cpt_si_ptr = (intptr_t) from->si_ptr;
    }
  else if (to->si_code == SI_USER)
    {
      to->cpt_si_pid = from->si_pid;
      to->cpt_si_uid = from->si_uid;
    }
  else if (to->si_code < 0)
    {
      to->cpt_si_pid = from->si_pid;
      to->cpt_si_uid = from->si_uid;
      to->cpt_si_ptr = (intptr_t) from->si_ptr;
    }
  else
    {
      switch (to->si_signo)
	{
	case SIGCHLD:
	  to->cpt_si_pid = from->si_pid;
	  to->cpt_si_uid = from->si_uid;
	  to->cpt_si_status = from->si_status;
	  to->cpt_si_utime = from->si_utime;
	  to->cpt_si_stime = from->si_stime;
	  break;
	case SIGILL:
	case SIGFPE:
	case SIGSEGV:
	case SIGBUS:
	  to->cpt_si_addr = (intptr_t) from->si_addr;
	  break;
	case SIGPOLL:
	  to->cpt_si_band = from->si_band;
	  to->cpt_si_fd = from->si_fd;
	  break;
	default:
	  to->cpt_si_pid = from->si_pid;
	  to->cpt_si_uid = from->si_uid;
	  to->cpt_si_ptr = (intptr_t) from->si_ptr;
	  break;
	}
    }
}

static void
siginfo_from_compat_siginfo (siginfo_t *to, compat_siginfo_t *from)
{
  memset (to, 0, sizeof (*to));

  to->si_signo = from->si_signo;
  to->si_errno = from->si_errno;
  to->si_code = from->si_code;

  if (to->si_code == SI_TIMER)
    {
      to->si_timerid = from->cpt_si_timerid;
      to->si_overrun = from->cpt_si_overrun;
      to->si_ptr = (void *) (intptr_t) from->cpt_si_ptr;
    }
  else if (to->si_code == SI_USER)
    {
      to->si_pid = from->cpt_si_pid;
      to->si_uid = from->cpt_si_uid;
    }
  else if (to->si_code < 0)
    {
      to->si_pid = from->cpt_si_pid;
      to->si_uid = from->cpt_si_uid;
      to->si_ptr = (void *) (intptr_t) from->cpt_si_ptr;
    }
  else
    {
      switch (to->si_signo)
	{
	case SIGCHLD:
	  to->si_pid = from->cpt_si_pid;
	  to->si_uid = from->cpt_si_uid;
	  to->si_status = from->cpt_si_status;
	  to->si_utime = from->cpt_si_utime;
	  to->si_stime = from->cpt_si_stime;
	  break;
	case SIGILL:
	case SIGFPE:
	case SIGSEGV:
	case SIGBUS:
	  to->si_addr = (void *) (intptr_t) from->cpt_si_addr;
	  break;
	case SIGPOLL:
	  to->si_band = from->cpt_si_band;
	  to->si_fd = from->cpt_si_fd;
	  break;
	default:
	  to->si_pid = from->cpt_si_pid;
	  to->si_uid = from->cpt_si_uid;
	  to->si_ptr = (void* ) (intptr_t) from->cpt_si_ptr;
	  break;
	}
    }
}

static void
compat_x32_siginfo_from_siginfo (compat_x32_siginfo_t *to,
				 siginfo_t *from)
{
  memset (to, 0, sizeof (*to));

  to->si_signo = from->si_signo;
  to->si_errno = from->si_errno;
  to->si_code = from->si_code;

  if (to->si_code == SI_TIMER)
    {
      to->cpt_si_timerid = from->si_timerid;
      to->cpt_si_overrun = from->si_overrun;
      to->cpt_si_ptr = (intptr_t) from->si_ptr;
    }
  else if (to->si_code == SI_USER)
    {
      to->cpt_si_pid = from->si_pid;
      to->cpt_si_uid = from->si_uid;
    }
  else if (to->si_code < 0)
    {
      to->cpt_si_pid = from->si_pid;
      to->cpt_si_uid = from->si_uid;
      to->cpt_si_ptr = (intptr_t) from->si_ptr;
    }
  else
    {
      switch (to->si_signo)
	{
	case SIGCHLD:
	  to->cpt_si_pid = from->si_pid;
	  to->cpt_si_uid = from->si_uid;
	  to->cpt_si_status = from->si_status;
	  to->cpt_si_utime = from->si_utime;
	  to->cpt_si_stime = from->si_stime;
	  break;
	case SIGILL:
	case SIGFPE:
	case SIGSEGV:
	case SIGBUS:
	  to->cpt_si_addr = (intptr_t) from->si_addr;
	  break;
	case SIGPOLL:
	  to->cpt_si_band = from->si_band;
	  to->cpt_si_fd = from->si_fd;
	  break;
	default:
	  to->cpt_si_pid = from->si_pid;
	  to->cpt_si_uid = from->si_uid;
	  to->cpt_si_ptr = (intptr_t) from->si_ptr;
	  break;
	}
    }
}

static void
siginfo_from_compat_x32_siginfo (siginfo_t *to,
				 compat_x32_siginfo_t *from)
{
  memset (to, 0, sizeof (*to));

  to->si_signo = from->si_signo;
  to->si_errno = from->si_errno;
  to->si_code = from->si_code;

  if (to->si_code == SI_TIMER)
    {
      to->si_timerid = from->cpt_si_timerid;
      to->si_overrun = from->cpt_si_overrun;
      to->si_ptr = (void *) (intptr_t) from->cpt_si_ptr;
    }
  else if (to->si_code == SI_USER)
    {
      to->si_pid = from->cpt_si_pid;
      to->si_uid = from->cpt_si_uid;
    }
  else if (to->si_code < 0)
    {
      to->si_pid = from->cpt_si_pid;
      to->si_uid = from->cpt_si_uid;
      to->si_ptr = (void *) (intptr_t) from->cpt_si_ptr;
    }
  else
    {
      switch (to->si_signo)
	{
	case SIGCHLD:
	  to->si_pid = from->cpt_si_pid;
	  to->si_uid = from->cpt_si_uid;
	  to->si_status = from->cpt_si_status;
	  to->si_utime = from->cpt_si_utime;
	  to->si_stime = from->cpt_si_stime;
	  break;
	case SIGILL:
	case SIGFPE:
	case SIGSEGV:
	case SIGBUS:
	  to->si_addr = (void *) (intptr_t) from->cpt_si_addr;
	  break;
	case SIGPOLL:
	  to->si_band = from->cpt_si_band;
	  to->si_fd = from->cpt_si_fd;
	  break;
	default:
	  to->si_pid = from->cpt_si_pid;
	  to->si_uid = from->cpt_si_uid;
	  to->si_ptr = (void* ) (intptr_t) from->cpt_si_ptr;
	  break;
	}
    }
}

#endif /* __x86_64__ */

/* Convert a native/host siginfo object, into/from the siginfo in the
   layout of the inferiors' architecture.  Returns true if any
   conversion was done; false otherwise.  If DIRECTION is 1, then copy
   from INF to NATIVE.  If DIRECTION is 0, copy from NATIVE to
   INF.  */

static int
x86_siginfo_fixup (siginfo_t *native, void *inf, int direction)
{
#ifdef __x86_64__
  unsigned int machine;
  int tid = lwpid_of (get_thread_lwp (current_inferior));
  int is_elf64 = linux_pid_exe_is_elf_64_file (tid, &machine);

  /* Is the inferior 32-bit?  If so, then fixup the siginfo object.  */
  if (!is_64bit_tdesc ())
    {
      if (sizeof (siginfo_t) != sizeof (compat_siginfo_t))
	fatal ("unexpected difference in siginfo");

      if (direction == 0)
	compat_siginfo_from_siginfo ((struct compat_siginfo *) inf, native);
      else
	siginfo_from_compat_siginfo (native, (struct compat_siginfo *) inf);

      return 1;
    }
  /* No fixup for native x32 GDB.  */
  else if (!is_elf64 && sizeof (void *) == 8)
    {
      if (sizeof (siginfo_t) != sizeof (compat_x32_siginfo_t))
	fatal ("unexpected difference in siginfo");

      if (direction == 0)
	compat_x32_siginfo_from_siginfo ((struct compat_x32_siginfo *) inf,
					 native);
      else
	siginfo_from_compat_x32_siginfo (native,
					 (struct compat_x32_siginfo *) inf);

      return 1;
    }
#endif

  return 0;
}

static int use_xml;

/* Format of XSAVE extended state is:
	struct
	{
	  fxsave_bytes[0..463]
	  sw_usable_bytes[464..511]
	  xstate_hdr_bytes[512..575]
	  avx_bytes[576..831]
	  future_state etc
	};

  Same memory layout will be used for the coredump NT_X86_XSTATE
  representing the XSAVE extended state registers.

  The first 8 bytes of the sw_usable_bytes[464..467] is the OS enabled
  extended state mask, which is the same as the extended control register
  0 (the XFEATURE_ENABLED_MASK register), XCR0.  We can use this mask
  together with the mask saved in the xstate_hdr_bytes to determine what
  states the processor/OS supports and what state, used or initialized,
  the process/thread is in.  */
#define I386_LINUX_XSAVE_XCR0_OFFSET 464

/* Does the current host support the GETFPXREGS request?  The header
   file may or may not define it, and even if it is defined, the
   kernel will return EIO if it's running on a pre-SSE processor.  */
int have_ptrace_getfpxregs =
#ifdef HAVE_PTRACE_GETFPXREGS
  -1
#else
  0
#endif
;

/* Does the current host support PTRACE_GETREGSET?  */
static int have_ptrace_getregset = -1;

/* Get Linux/x86 target description from running target.  */

static const struct target_desc *
x86_linux_read_description (void)
{
  unsigned int machine;
  int is_elf64;
  int avx;
  int tid;
  static uint64_t xcr0;
  struct regset_info *regset;

  tid = lwpid_of (get_thread_lwp (current_inferior));

  is_elf64 = linux_pid_exe_is_elf_64_file (tid, &machine);

  if (sizeof (void *) == 4)
    {
      if (is_elf64 > 0)
       error (_("Can't debug 64-bit process with 32-bit GDBserver"));
#ifndef __x86_64__
      else if (machine == EM_X86_64)
       error (_("Can't debug x86-64 process with 32-bit GDBserver"));
#endif
    }

#if !defined __x86_64__ && defined HAVE_PTRACE_GETFPXREGS
  if (machine == EM_386 && have_ptrace_getfpxregs == -1)
    {
      elf_fpxregset_t fpxregs;

      if (ptrace (PTRACE_GETFPXREGS, tid, 0, (long) &fpxregs) < 0)
	{
	  have_ptrace_getfpxregs = 0;
	  have_ptrace_getregset = 0;
	  return tdesc_i386_mmx_linux;
	}
      else
	have_ptrace_getfpxregs = 1;
    }
#endif

  if (!use_xml)
    {
      x86_xcr0 = I386_XSTATE_SSE_MASK;

      /* Don't use XML.  */
#ifdef __x86_64__
      if (machine == EM_X86_64)
	return tdesc_amd64_linux_no_xml;
      else
#endif
	return tdesc_i386_linux_no_xml;
    }

  if (have_ptrace_getregset == -1)
    {
      uint64_t xstateregs[(I386_XSTATE_SSE_SIZE / sizeof (uint64_t))];
      struct iovec iov;

      iov.iov_base = xstateregs;
      iov.iov_len = sizeof (xstateregs);

      /* Check if PTRACE_GETREGSET works.  */
      if (ptrace (PTRACE_GETREGSET, tid,
		  (unsigned int) NT_X86_XSTATE, (long) &iov) < 0)
	have_ptrace_getregset = 0;
      else
	{
	  have_ptrace_getregset = 1;

	  /* Get XCR0 from XSAVE extended state.  */
	  xcr0 = xstateregs[(I386_LINUX_XSAVE_XCR0_OFFSET
			     / sizeof (uint64_t))];

	  /* Use PTRACE_GETREGSET if it is available.  */
	  for (regset = x86_regsets;
	       regset->fill_function != NULL; regset++)
	    if (regset->get_request == PTRACE_GETREGSET)
	      regset->size = I386_XSTATE_SIZE (xcr0);
	    else if (regset->type != GENERAL_REGS)
	      regset->size = 0;
	}
    }

  /* Check the native XCR0 only if PTRACE_GETREGSET is available.  */
  avx = (have_ptrace_getregset
	 && (xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK);

  /* AVX is the highest feature we support.  */
  if (avx)
    x86_xcr0 = xcr0;

  if (machine == EM_X86_64)
    {
#ifdef __x86_64__
      if (avx)
	{
	  if (!is_elf64)
	    return tdesc_x32_avx_linux;
	  else
	    return tdesc_amd64_avx_linux;
	}
      else
	{
	  if (!is_elf64)
	    return tdesc_x32_linux;
	  else
	    return tdesc_amd64_linux;
	}
#endif
    }
  else
    {
      if (avx)
	return tdesc_i386_avx_linux;
      else
	return tdesc_i386_linux;
    }

  gdb_assert_not_reached ("failed to return tdesc");
}

/* Callback for find_inferior.  Stops iteration when a thread with a
   given PID is found.  */

static int
same_process_callback (struct inferior_list_entry *entry, void *data)
{
  int pid = *(int *) data;

  return (ptid_get_pid (entry->id) == pid);
}

/* Callback for for_each_inferior.  Calls the arch_setup routine for
   each process.  */

static void
x86_arch_setup_process_callback (struct inferior_list_entry *entry)
{
  int pid = ptid_get_pid (entry->id);

  /* Look up any thread of this processes.  */
  current_inferior
    = (struct thread_info *) find_inferior (&all_threads,
					    same_process_callback, &pid);

  the_low_target.arch_setup ();
}

/* Update all the target description of all processes; a new GDB
   connected, and it may or not support xml target descriptions.  */

static void
x86_linux_update_xmltarget (void)
{
  struct thread_info *save_inferior = current_inferior;

  /* Before changing the register cache's internal layout, flush the
     contents of the current valid caches back to the threads, and
     release the current regcache objects.  */
  regcache_release ();

  for_each_inferior (&all_processes, x86_arch_setup_process_callback);

  current_inferior = save_inferior;
}

/* Process qSupported query, "xmlRegisters=".  Update the buffer size for
   PTRACE_GETREGSET.  */

static void
x86_linux_process_qsupported (const char *query)
{
  /* Return if gdb doesn't support XML.  If gdb sends "xmlRegisters="
     with "i386" in qSupported query, it supports x86 XML target
     descriptions.  */
  use_xml = 0;
  if (query != NULL && strncmp (query, "xmlRegisters=", 13) == 0)
    {
      char *copy = xstrdup (query + 13);
      char *p;

      for (p = strtok (copy, ","); p != NULL; p = strtok (NULL, ","))
	{
	  if (strcmp (p, "i386") == 0)
	    {
	      use_xml = 1;
	      break;
	    }
	} 

      free (copy);
    }

  x86_linux_update_xmltarget ();
}

/* Common for x86/x86-64.  */

static struct regsets_info x86_regsets_info =
  {
    x86_regsets, /* regsets */
    0, /* num_regsets */
    NULL, /* disabled_regsets */
  };

#ifdef __x86_64__
static struct regs_info amd64_linux_regs_info =
  {
    NULL, /* regset_bitmap */
    NULL, /* usrregs_info */
    &x86_regsets_info
  };
#endif
static struct usrregs_info i386_linux_usrregs_info =
  {
    I386_NUM_REGS,
    i386_regmap,
  };

static struct regs_info i386_linux_regs_info =
  {
    NULL, /* regset_bitmap */
    &i386_linux_usrregs_info,
    &x86_regsets_info
  };

const struct regs_info *
x86_linux_regs_info (void)
{
#ifdef __x86_64__
  if (is_64bit_tdesc ())
    return &amd64_linux_regs_info;
  else
#endif
    return &i386_linux_regs_info;
}

/* Initialize the target description for the architecture of the
   inferior.  */

static void
x86_arch_setup (void)
{
  current_process ()->tdesc = x86_linux_read_description ();
}

static int
x86_supports_tracepoints (void)
{
  return 1;
}

static void
append_insns (CORE_ADDR *to, size_t len, const unsigned char *buf)
{
  write_inferior_memory (*to, buf, len);
  *to += len;
}

static int
push_opcode (unsigned char *buf, char *op)
{
  unsigned char *buf_org = buf;

  while (1)
    {
      char *endptr;
      unsigned long ul = strtoul (op, &endptr, 16);

      if (endptr == op)
	break;

      *buf++ = ul;
      op = endptr;
    }

  return buf - buf_org;
}

#ifdef __x86_64__

/* Build a jump pad that saves registers and calls a collection
   function.  Writes a jump instruction to the jump pad to
   JJUMPAD_INSN.  The caller is responsible to write it in at the
   tracepoint address.  */

static int
amd64_install_fast_tracepoint_jump_pad (CORE_ADDR tpoint, CORE_ADDR tpaddr,
					CORE_ADDR collector,
					CORE_ADDR lockaddr,
					ULONGEST orig_size,
					CORE_ADDR *jump_entry,
					CORE_ADDR *trampoline,
					ULONGEST *trampoline_size,
					unsigned char *jjump_pad_insn,
					ULONGEST *jjump_pad_insn_size,
					CORE_ADDR *adjusted_insn_addr,
					CORE_ADDR *adjusted_insn_addr_end,
					char *err)
{
  unsigned char buf[40];
  int i, offset;
  int64_t loffset;

  CORE_ADDR buildaddr = *jump_entry;

  /* Build the jump pad.  */

  /* First, do tracepoint data collection.  Save registers.  */
  i = 0;
  /* Need to ensure stack pointer saved first.  */
  buf[i++] = 0x54; /* push %rsp */
  buf[i++] = 0x55; /* push %rbp */
  buf[i++] = 0x57; /* push %rdi */
  buf[i++] = 0x56; /* push %rsi */
  buf[i++] = 0x52; /* push %rdx */
  buf[i++] = 0x51; /* push %rcx */
  buf[i++] = 0x53; /* push %rbx */
  buf[i++] = 0x50; /* push %rax */
  buf[i++] = 0x41; buf[i++] = 0x57; /* push %r15 */
  buf[i++] = 0x41; buf[i++] = 0x56; /* push %r14 */
  buf[i++] = 0x41; buf[i++] = 0x55; /* push %r13 */
  buf[i++] = 0x41; buf[i++] = 0x54; /* push %r12 */
  buf[i++] = 0x41; buf[i++] = 0x53; /* push %r11 */
  buf[i++] = 0x41; buf[i++] = 0x52; /* push %r10 */
  buf[i++] = 0x41; buf[i++] = 0x51; /* push %r9 */
  buf[i++] = 0x41; buf[i++] = 0x50; /* push %r8 */
  buf[i++] = 0x9c; /* pushfq */
  buf[i++] = 0x48; /* movl <addr>,%rdi */
  buf[i++] = 0xbf;
  *((unsigned long *)(buf + i)) = (unsigned long) tpaddr;
  i += sizeof (unsigned long);
  buf[i++] = 0x57; /* push %rdi */
  append_insns (&buildaddr, i, buf);

  /* Stack space for the collecting_t object.  */
  i = 0;
  i += push_opcode (&buf[i], "48 83 ec 18");	/* sub $0x18,%rsp */
  i += push_opcode (&buf[i], "48 b8");          /* mov <tpoint>,%rax */
  memcpy (buf + i, &tpoint, 8);
  i += 8;
  i += push_opcode (&buf[i], "48 89 04 24");    /* mov %rax,(%rsp) */
  i += push_opcode (&buf[i],
		    "64 48 8b 04 25 00 00 00 00"); /* mov %fs:0x0,%rax */
  i += push_opcode (&buf[i], "48 89 44 24 08"); /* mov %rax,0x8(%rsp) */
  append_insns (&buildaddr, i, buf);

  /* spin-lock.  */
  i = 0;
  i += push_opcode (&buf[i], "48 be");		/* movl <lockaddr>,%rsi */
  memcpy (&buf[i], (void *) &lockaddr, 8);
  i += 8;
  i += push_opcode (&buf[i], "48 89 e1");       /* mov %rsp,%rcx */
  i += push_opcode (&buf[i], "31 c0");		/* xor %eax,%eax */
  i += push_opcode (&buf[i], "f0 48 0f b1 0e"); /* lock cmpxchg %rcx,(%rsi) */
  i += push_opcode (&buf[i], "48 85 c0");	/* test %rax,%rax */
  i += push_opcode (&buf[i], "75 f4");		/* jne <again> */
  append_insns (&buildaddr, i, buf);

  /* Set up the gdb_collect call.  */
  /* At this point, (stack pointer + 0x18) is the base of our saved
     register block.  */

  i = 0;
  i += push_opcode (&buf[i], "48 89 e6");	/* mov %rsp,%rsi */
  i += push_opcode (&buf[i], "48 83 c6 18");	/* add $0x18,%rsi */

  /* tpoint address may be 64-bit wide.  */
  i += push_opcode (&buf[i], "48 bf");		/* movl <addr>,%rdi */
  memcpy (buf + i, &tpoint, 8);
  i += 8;
  append_insns (&buildaddr, i, buf);

  /* The collector function being in the shared library, may be
     >31-bits away off the jump pad.  */
  i = 0;
  i += push_opcode (&buf[i], "48 b8");          /* mov $collector,%rax */
  memcpy (buf + i, &collector, 8);
  i += 8;
  i += push_opcode (&buf[i], "ff d0");          /* callq *%rax */
  append_insns (&buildaddr, i, buf);

  /* Clear the spin-lock.  */
  i = 0;
  i += push_opcode (&buf[i], "31 c0");		/* xor %eax,%eax */
  i += push_opcode (&buf[i], "48 a3");		/* mov %rax, lockaddr */
  memcpy (buf + i, &lockaddr, 8);
  i += 8;
  append_insns (&buildaddr, i, buf);

  /* Remove stack that had been used for the collect_t object.  */
  i = 0;
  i += push_opcode (&buf[i], "48 83 c4 18");	/* add $0x18,%rsp */
  append_insns (&buildaddr, i, buf);

  /* Restore register state.  */
  i = 0;
  buf[i++] = 0x48; /* add $0x8,%rsp */
  buf[i++] = 0x83;
  buf[i++] = 0xc4;
  buf[i++] = 0x08;
  buf[i++] = 0x9d; /* popfq */
  buf[i++] = 0x41; buf[i++] = 0x58; /* pop %r8 */
  buf[i++] = 0x41; buf[i++] = 0x59; /* pop %r9 */
  buf[i++] = 0x41; buf[i++] = 0x5a; /* pop %r10 */
  buf[i++] = 0x41; buf[i++] = 0x5b; /* pop %r11 */
  buf[i++] = 0x41; buf[i++] = 0x5c; /* pop %r12 */
  buf[i++] = 0x41; buf[i++] = 0x5d; /* pop %r13 */
  buf[i++] = 0x41; buf[i++] = 0x5e; /* pop %r14 */
  buf[i++] = 0x41; buf[i++] = 0x5f; /* pop %r15 */
  buf[i++] = 0x58; /* pop %rax */
  buf[i++] = 0x5b; /* pop %rbx */
  buf[i++] = 0x59; /* pop %rcx */
  buf[i++] = 0x5a; /* pop %rdx */
  buf[i++] = 0x5e; /* pop %rsi */
  buf[i++] = 0x5f; /* pop %rdi */
  buf[i++] = 0x5d; /* pop %rbp */
  buf[i++] = 0x5c; /* pop %rsp */
  append_insns (&buildaddr, i, buf);

  /* Now, adjust the original instruction to execute in the jump
     pad.  */
  *adjusted_insn_addr = buildaddr;
  relocate_instruction (&buildaddr, tpaddr);
  *adjusted_insn_addr_end = buildaddr;

  /* Finally, write a jump back to the program.  */

  loffset = (tpaddr + orig_size) - (buildaddr + sizeof (jump_insn));
  if (loffset > INT_MAX || loffset < INT_MIN)
    {
      sprintf (err,
	       "E.Jump back from jump pad too far from tracepoint "
	       "(offset 0x%" PRIx64 " > int32).", loffset);
      return 1;
    }

  offset = (int) loffset;
  memcpy (buf, jump_insn, sizeof (jump_insn));
  memcpy (buf + 1, &offset, 4);
  append_insns (&buildaddr, sizeof (jump_insn), buf);

  /* The jump pad is now built.  Wire in a jump to our jump pad.  This
     is always done last (by our caller actually), so that we can
     install fast tracepoints with threads running.  This relies on
     the agent's atomic write support.  */
  loffset = *jump_entry - (tpaddr + sizeof (jump_insn));
  if (loffset > INT_MAX || loffset < INT_MIN)
    {
      sprintf (err,
	       "E.Jump pad too far from tracepoint "
	       "(offset 0x%" PRIx64 " > int32).", loffset);
      return 1;
    }

  offset = (int) loffset;

  memcpy (buf, jump_insn, sizeof (jump_insn));
  memcpy (buf + 1, &offset, 4);
  memcpy (jjump_pad_insn, buf, sizeof (jump_insn));
  *jjump_pad_insn_size = sizeof (jump_insn);

  /* Return the end address of our pad.  */
  *jump_entry = buildaddr;

  return 0;
}

#endif /* __x86_64__ */

/* Build a jump pad that saves registers and calls a collection
   function.  Writes a jump instruction to the jump pad to
   JJUMPAD_INSN.  The caller is responsible to write it in at the
   tracepoint address.  */

static int
i386_install_fast_tracepoint_jump_pad (CORE_ADDR tpoint, CORE_ADDR tpaddr,
				       CORE_ADDR collector,
				       CORE_ADDR lockaddr,
				       ULONGEST orig_size,
				       CORE_ADDR *jump_entry,
				       CORE_ADDR *trampoline,
				       ULONGEST *trampoline_size,
				       unsigned char *jjump_pad_insn,
				       ULONGEST *jjump_pad_insn_size,
				       CORE_ADDR *adjusted_insn_addr,
				       CORE_ADDR *adjusted_insn_addr_end,
				       char *err)
{
  unsigned char buf[0x100];
  int i, offset;
  CORE_ADDR buildaddr = *jump_entry;

  /* Build the jump pad.  */

  /* First, do tracepoint data collection.  Save registers.  */
  i = 0;
  buf[i++] = 0x60; /* pushad */
  buf[i++] = 0x68; /* push tpaddr aka $pc */
  *((int *)(buf + i)) = (int) tpaddr;
  i += 4;
  buf[i++] = 0x9c; /* pushf */
  buf[i++] = 0x1e; /* push %ds */
  buf[i++] = 0x06; /* push %es */
  buf[i++] = 0x0f; /* push %fs */
  buf[i++] = 0xa0;
  buf[i++] = 0x0f; /* push %gs */
  buf[i++] = 0xa8;
  buf[i++] = 0x16; /* push %ss */
  buf[i++] = 0x0e; /* push %cs */
  append_insns (&buildaddr, i, buf);

  /* Stack space for the collecting_t object.  */
  i = 0;
  i += push_opcode (&buf[i], "83 ec 08");	/* sub    $0x8,%esp */

  /* Build the object.  */
  i += push_opcode (&buf[i], "b8");		/* mov    <tpoint>,%eax */
  memcpy (buf + i, &tpoint, 4);
  i += 4;
  i += push_opcode (&buf[i], "89 04 24");	   /* mov %eax,(%esp) */

  i += push_opcode (&buf[i], "65 a1 00 00 00 00"); /* mov %gs:0x0,%eax */
  i += push_opcode (&buf[i], "89 44 24 04");	   /* mov %eax,0x4(%esp) */
  append_insns (&buildaddr, i, buf);

  /* spin-lock.  Note this is using cmpxchg, which leaves i386 behind.
     If we cared for it, this could be using xchg alternatively.  */

  i = 0;
  i += push_opcode (&buf[i], "31 c0");		/* xor %eax,%eax */
  i += push_opcode (&buf[i], "f0 0f b1 25");    /* lock cmpxchg
						   %esp,<lockaddr> */
  memcpy (&buf[i], (void *) &lockaddr, 4);
  i += 4;
  i += push_opcode (&buf[i], "85 c0");		/* test %eax,%eax */
  i += push_opcode (&buf[i], "75 f2");		/* jne <again> */
  append_insns (&buildaddr, i, buf);


  /* Set up arguments to the gdb_collect call.  */
  i = 0;
  i += push_opcode (&buf[i], "89 e0");		/* mov %esp,%eax */
  i += push_opcode (&buf[i], "83 c0 08");	/* add $0x08,%eax */
  i += push_opcode (&buf[i], "89 44 24 fc");	/* mov %eax,-0x4(%esp) */
  append_insns (&buildaddr, i, buf);

  i = 0;
  i += push_opcode (&buf[i], "83 ec 08");	/* sub $0x8,%esp */
  append_insns (&buildaddr, i, buf);

  i = 0;
  i += push_opcode (&buf[i], "c7 04 24");       /* movl <addr>,(%esp) */
  memcpy (&buf[i], (void *) &tpoint, 4);
  i += 4;
  append_insns (&buildaddr, i, buf);

  buf[0] = 0xe8; /* call <reladdr> */
  offset = collector - (buildaddr + sizeof (jump_insn));
  memcpy (buf + 1, &offset, 4);
  append_insns (&buildaddr, 5, buf);
  /* Clean up after the call.  */
  buf[0] = 0x83; /* add $0x8,%esp */
  buf[1] = 0xc4;
  buf[2] = 0x08;
  append_insns (&buildaddr, 3, buf);


  /* Clear the spin-lock.  This would need the LOCK prefix on older
     broken archs.  */
  i = 0;
  i += push_opcode (&buf[i], "31 c0");		/* xor %eax,%eax */
  i += push_opcode (&buf[i], "a3");		/* mov %eax, lockaddr */
  memcpy (buf + i, &lockaddr, 4);
  i += 4;
  append_insns (&buildaddr, i, buf);


  /* Remove stack that had been used for the collect_t object.  */
  i = 0;
  i += push_opcode (&buf[i], "83 c4 08");	/* add $0x08,%esp */
  append_insns (&buildaddr, i, buf);

  i = 0;
  buf[i++] = 0x83; /* add $0x4,%esp (no pop of %cs, assume unchanged) */
  buf[i++] = 0xc4;
  buf[i++] = 0x04;
  buf[i++] = 0x17; /* pop %ss */
  buf[i++] = 0x0f; /* pop %gs */
  buf[i++] = 0xa9;
  buf[i++] = 0x0f; /* pop %fs */
  buf[i++] = 0xa1;
  buf[i++] = 0x07; /* pop %es */
  buf[i++] = 0x1f; /* pop %ds */
  buf[i++] = 0x9d; /* popf */
  buf[i++] = 0x83; /* add $0x4,%esp (pop of tpaddr aka $pc) */
  buf[i++] = 0xc4;
  buf[i++] = 0x04;
  buf[i++] = 0x61; /* popad */
  append_insns (&buildaddr, i, buf);

  /* Now, adjust the original instruction to execute in the jump
     pad.  */
  *adjusted_insn_addr = buildaddr;
  relocate_instruction (&buildaddr, tpaddr);
  *adjusted_insn_addr_end = buildaddr;

  /* Write the jump back to the program.  */
  offset = (tpaddr + orig_size) - (buildaddr + sizeof (jump_insn));
  memcpy (buf, jump_insn, sizeof (jump_insn));
  memcpy (buf + 1, &offset, 4);
  append_insns (&buildaddr, sizeof (jump_insn), buf);

  /* The jump pad is now built.  Wire in a jump to our jump pad.  This
     is always done last (by our caller actually), so that we can
     install fast tracepoints with threads running.  This relies on
     the agent's atomic write support.  */
  if (orig_size == 4)
    {
      /* Create a trampoline.  */
      *trampoline_size = sizeof (jump_insn);
      if (!claim_trampoline_space (*trampoline_size, trampoline))
	{
	  /* No trampoline space available.  */
	  strcpy (err,
		  "E.Cannot allocate trampoline space needed for fast "
		  "tracepoints on 4-byte instructions.");
	  return 1;
	}

      offset = *jump_entry - (*trampoline + sizeof (jump_insn));
      memcpy (buf, jump_insn, sizeof (jump_insn));
      memcpy (buf + 1, &offset, 4);
      write_inferior_memory (*trampoline, buf, sizeof (jump_insn));

      /* Use a 16-bit relative jump instruction to jump to the trampoline.  */
      offset = (*trampoline - (tpaddr + sizeof (small_jump_insn))) & 0xffff;
      memcpy (buf, small_jump_insn, sizeof (small_jump_insn));
      memcpy (buf + 2, &offset, 2);
      memcpy (jjump_pad_insn, buf, sizeof (small_jump_insn));
      *jjump_pad_insn_size = sizeof (small_jump_insn);
    }
  else
    {
      /* Else use a 32-bit relative jump instruction.  */
      offset = *jump_entry - (tpaddr + sizeof (jump_insn));
      memcpy (buf, jump_insn, sizeof (jump_insn));
      memcpy (buf + 1, &offset, 4);
      memcpy (jjump_pad_insn, buf, sizeof (jump_insn));
      *jjump_pad_insn_size = sizeof (jump_insn);
    }

  /* Return the end address of our pad.  */
  *jump_entry = buildaddr;

  return 0;
}

static int
x86_install_fast_tracepoint_jump_pad (CORE_ADDR tpoint, CORE_ADDR tpaddr,
				      CORE_ADDR collector,
				      CORE_ADDR lockaddr,
				      ULONGEST orig_size,
				      CORE_ADDR *jump_entry,
				      CORE_ADDR *trampoline,
				      ULONGEST *trampoline_size,
				      unsigned char *jjump_pad_insn,
				      ULONGEST *jjump_pad_insn_size,
				      CORE_ADDR *adjusted_insn_addr,
				      CORE_ADDR *adjusted_insn_addr_end,
				      char *err)
{
#ifdef __x86_64__
  if (is_64bit_tdesc ())
    return amd64_install_fast_tracepoint_jump_pad (tpoint, tpaddr,
						   collector, lockaddr,
						   orig_size, jump_entry,
						   trampoline, trampoline_size,
						   jjump_pad_insn,
						   jjump_pad_insn_size,
						   adjusted_insn_addr,
						   adjusted_insn_addr_end,
						   err);
#endif

  return i386_install_fast_tracepoint_jump_pad (tpoint, tpaddr,
						collector, lockaddr,
						orig_size, jump_entry,
						trampoline, trampoline_size,
						jjump_pad_insn,
						jjump_pad_insn_size,
						adjusted_insn_addr,
						adjusted_insn_addr_end,
						err);
}

/* Return the minimum instruction length for fast tracepoints on x86/x86-64
   architectures.  */

static int
x86_get_min_fast_tracepoint_insn_len (void)
{
  static int warned_about_fast_tracepoints = 0;

#ifdef __x86_64__
  /*  On x86-64, 5-byte jump instructions with a 4-byte offset are always
      used for fast tracepoints.  */
  if (is_64bit_tdesc ())
    return 5;
#endif

  if (agent_loaded_p ())
    {
      char errbuf[IPA_BUFSIZ];

      errbuf[0] = '\0';

      /* On x86, if trampolines are available, then 4-byte jump instructions
	 with a 2-byte offset may be used, otherwise 5-byte jump instructions
	 with a 4-byte offset are used instead.  */
      if (have_fast_tracepoint_trampoline_buffer (errbuf))
	return 4;
      else
	{
	  /* GDB has no channel to explain to user why a shorter fast
	     tracepoint is not possible, but at least make GDBserver
	     mention that something has gone awry.  */
	  if (!warned_about_fast_tracepoints)
	    {
	      warning ("4-byte fast tracepoints not available; %s\n", errbuf);
	      warned_about_fast_tracepoints = 1;
	    }
	  return 5;
	}
    }
  else
    {
      /* Indicate that the minimum length is currently unknown since the IPA
	 has not loaded yet.  */
      return 0;
    }
}

static void
add_insns (unsigned char *start, int len)
{
  CORE_ADDR buildaddr = current_insn_ptr;

  if (debug_threads)
    fprintf (stderr, "Adding %d bytes of insn at %s\n",
	     len, paddress (buildaddr));

  append_insns (&buildaddr, len, start);
  current_insn_ptr = buildaddr;
}

/* Our general strategy for emitting code is to avoid specifying raw
   bytes whenever possible, and instead copy a block of inline asm
   that is embedded in the function.  This is a little messy, because
   we need to keep the compiler from discarding what looks like dead
   code, plus suppress various warnings.  */

#define EMIT_ASM(NAME, INSNS)						\
  do									\
    {									\
      extern unsigned char start_ ## NAME, end_ ## NAME;		\
      add_insns (&start_ ## NAME, &end_ ## NAME - &start_ ## NAME);	\
      __asm__ ("jmp end_" #NAME "\n"					\
	       "\t" "start_" #NAME ":"					\
	       "\t" INSNS "\n"						\
	       "\t" "end_" #NAME ":");					\
    } while (0)

#ifdef __x86_64__

#define EMIT_ASM32(NAME,INSNS)						\
  do									\
    {									\
      extern unsigned char start_ ## NAME, end_ ## NAME;		\
      add_insns (&start_ ## NAME, &end_ ## NAME - &start_ ## NAME);	\
      __asm__ (".code32\n"						\
	       "\t" "jmp end_" #NAME "\n"				\
	       "\t" "start_" #NAME ":\n"				\
	       "\t" INSNS "\n"						\
	       "\t" "end_" #NAME ":\n"					\
	       ".code64\n");						\
    } while (0)

#else

#define EMIT_ASM32(NAME,INSNS) EMIT_ASM(NAME,INSNS)

#endif

#ifdef __x86_64__

static void
amd64_emit_prologue (void)
{
  EMIT_ASM (amd64_prologue,
	    "pushq %rbp\n\t"
	    "movq %rsp,%rbp\n\t"
	    "sub $0x20,%rsp\n\t"
	    "movq %rdi,-8(%rbp)\n\t"
	    "movq %rsi,-16(%rbp)");
}


static void
amd64_emit_epilogue (void)
{
  EMIT_ASM (amd64_epilogue,
	    "movq -16(%rbp),%rdi\n\t"
	    "movq %rax,(%rdi)\n\t"
	    "xor %rax,%rax\n\t"
	    "leave\n\t"
	    "ret");
}

static void
amd64_emit_add (void)
{
  EMIT_ASM (amd64_add,
	    "add (%rsp),%rax\n\t"
	    "lea 0x8(%rsp),%rsp");
}

static void
amd64_emit_sub (void)
{
  EMIT_ASM (amd64_sub,
	    "sub %rax,(%rsp)\n\t"
	    "pop %rax");
}

static void
amd64_emit_mul (void)
{
  emit_error = 1;
}

static void
amd64_emit_lsh (void)
{
  emit_error = 1;
}

static void
amd64_emit_rsh_signed (void)
{
  emit_error = 1;
}

static void
amd64_emit_rsh_unsigned (void)
{
  emit_error = 1;
}

static void
amd64_emit_ext (int arg)
{
  switch (arg)
    {
    case 8:
      EMIT_ASM (amd64_ext_8,
		"cbtw\n\t"
		"cwtl\n\t"
		"cltq");
      break;
    case 16:
      EMIT_ASM (amd64_ext_16,
		"cwtl\n\t"
		"cltq");
      break;
    case 32:
      EMIT_ASM (amd64_ext_32,
		"cltq");
      break;
    default:
      emit_error = 1;
    }
}

static void
amd64_emit_log_not (void)
{
  EMIT_ASM (amd64_log_not,
	    "test %rax,%rax\n\t"
	    "sete %cl\n\t"
	    "movzbq %cl,%rax");
}

static void
amd64_emit_bit_and (void)
{
  EMIT_ASM (amd64_and,
	    "and (%rsp),%rax\n\t"
	    "lea 0x8(%rsp),%rsp");
}

static void
amd64_emit_bit_or (void)
{
  EMIT_ASM (amd64_or,
	    "or (%rsp),%rax\n\t"
	    "lea 0x8(%rsp),%rsp");
}

static void
amd64_emit_bit_xor (void)
{
  EMIT_ASM (amd64_xor,
	    "xor (%rsp),%rax\n\t"
	    "lea 0x8(%rsp),%rsp");
}

static void
amd64_emit_bit_not (void)
{
  EMIT_ASM (amd64_bit_not,
	    "xorq $0xffffffffffffffff,%rax");
}

static void
amd64_emit_equal (void)
{
  EMIT_ASM (amd64_equal,
	    "cmp %rax,(%rsp)\n\t"
	    "je .Lamd64_equal_true\n\t"
	    "xor %rax,%rax\n\t"
	    "jmp .Lamd64_equal_end\n\t"
	    ".Lamd64_equal_true:\n\t"
	    "mov $0x1,%rax\n\t"
	    ".Lamd64_equal_end:\n\t"
	    "lea 0x8(%rsp),%rsp");
}

static void
amd64_emit_less_signed (void)
{
  EMIT_ASM (amd64_less_signed,
	    "cmp %rax,(%rsp)\n\t"
	    "jl .Lamd64_less_signed_true\n\t"
	    "xor %rax,%rax\n\t"
	    "jmp .Lamd64_less_signed_end\n\t"
	    ".Lamd64_less_signed_true:\n\t"
	    "mov $1,%rax\n\t"
	    ".Lamd64_less_signed_end:\n\t"
	    "lea 0x8(%rsp),%rsp");
}

static void
amd64_emit_less_unsigned (void)
{
  EMIT_ASM (amd64_less_unsigned,
	    "cmp %rax,(%rsp)\n\t"
	    "jb .Lamd64_less_unsigned_true\n\t"
	    "xor %rax,%rax\n\t"
	    "jmp .Lamd64_less_unsigned_end\n\t"
	    ".Lamd64_less_unsigned_true:\n\t"
	    "mov $1,%rax\n\t"
	    ".Lamd64_less_unsigned_end:\n\t"
	    "lea 0x8(%rsp),%rsp");
}

static void
amd64_emit_ref (int size)
{
  switch (size)
    {
    case 1:
      EMIT_ASM (amd64_ref1,
		"movb (%rax),%al");
      break;
    case 2:
      EMIT_ASM (amd64_ref2,
		"movw (%rax),%ax");
      break;
    case 4:
      EMIT_ASM (amd64_ref4,
		"movl (%rax),%eax");
      break;
    case 8:
      EMIT_ASM (amd64_ref8,
		"movq (%rax),%rax");
      break;
    }
}

static void
amd64_emit_if_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_if_goto,
	    "mov %rax,%rcx\n\t"
	    "pop %rax\n\t"
	    "cmp $0,%rcx\n\t"
	    ".byte 0x0f, 0x85, 0x0, 0x0, 0x0, 0x0");
  if (offset_p)
    *offset_p = 10;
  if (size_p)
    *size_p = 4;
}

static void
amd64_emit_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_goto,
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0");
  if (offset_p)
    *offset_p = 1;
  if (size_p)
    *size_p = 4;
}

static void
amd64_write_goto_address (CORE_ADDR from, CORE_ADDR to, int size)
{
  int diff = (to - (from + size));
  unsigned char buf[sizeof (int)];

  if (size != 4)
    {
      emit_error = 1;
      return;
    }

  memcpy (buf, &diff, sizeof (int));
  write_inferior_memory (from, buf, sizeof (int));
}

static void
amd64_emit_const (LONGEST num)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr = current_insn_ptr;

  i = 0;
  buf[i++] = 0x48;  buf[i++] = 0xb8; /* mov $<n>,%rax */
  memcpy (&buf[i], &num, sizeof (num));
  i += 8;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
}

static void
amd64_emit_call (CORE_ADDR fn)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr;
  LONGEST offset64;

  /* The destination function being in the shared library, may be
     >31-bits away off the compiled code pad.  */

  buildaddr = current_insn_ptr;

  offset64 = fn - (buildaddr + 1 /* call op */ + 4 /* 32-bit offset */);

  i = 0;

  if (offset64 > INT_MAX || offset64 < INT_MIN)
    {
      /* Offset is too large for a call.  Use callq, but that requires
	 a register, so avoid it if possible.  Use r10, since it is
	 call-clobbered, we don't have to push/pop it.  */
      buf[i++] = 0x48; /* mov $fn,%r10 */
      buf[i++] = 0xba;
      memcpy (buf + i, &fn, 8);
      i += 8;
      buf[i++] = 0xff; /* callq *%r10 */
      buf[i++] = 0xd2;
    }
  else
    {
      int offset32 = offset64; /* we know we can't overflow here.  */
      memcpy (buf + i, &offset32, 4);
      i += 4;
    }

  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
}

static void
amd64_emit_reg (int reg)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr;

  /* Assume raw_regs is still in %rdi.  */
  buildaddr = current_insn_ptr;
  i = 0;
  buf[i++] = 0xbe; /* mov $<n>,%esi */
  memcpy (&buf[i], &reg, sizeof (reg));
  i += 4;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
  amd64_emit_call (get_raw_reg_func_addr ());
}

static void
amd64_emit_pop (void)
{
  EMIT_ASM (amd64_pop,
	    "pop %rax");
}

static void
amd64_emit_stack_flush (void)
{
  EMIT_ASM (amd64_stack_flush,
	    "push %rax");
}

static void
amd64_emit_zero_ext (int arg)
{
  switch (arg)
    {
    case 8:
      EMIT_ASM (amd64_zero_ext_8,
		"and $0xff,%rax");
      break;
    case 16:
      EMIT_ASM (amd64_zero_ext_16,
		"and $0xffff,%rax");
      break;
    case 32:
      EMIT_ASM (amd64_zero_ext_32,
		"mov $0xffffffff,%rcx\n\t"
		"and %rcx,%rax");
      break;
    default:
      emit_error = 1;
    }
}

static void
amd64_emit_swap (void)
{
  EMIT_ASM (amd64_swap,
	    "mov %rax,%rcx\n\t"
	    "pop %rax\n\t"
	    "push %rcx");
}

static void
amd64_emit_stack_adjust (int n)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr = current_insn_ptr;

  i = 0;
  buf[i++] = 0x48; /* lea $<n>(%rsp),%rsp */
  buf[i++] = 0x8d;
  buf[i++] = 0x64;
  buf[i++] = 0x24;
  /* This only handles adjustments up to 16, but we don't expect any more.  */
  buf[i++] = n * 8;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
}

/* FN's prototype is `LONGEST(*fn)(int)'.  */

static void
amd64_emit_int_call_1 (CORE_ADDR fn, int arg1)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr;

  buildaddr = current_insn_ptr;
  i = 0;
  buf[i++] = 0xbf; /* movl $<n>,%edi */
  memcpy (&buf[i], &arg1, sizeof (arg1));
  i += 4;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
  amd64_emit_call (fn);
}

/* FN's prototype is `void(*fn)(int,LONGEST)'.  */

static void
amd64_emit_void_call_2 (CORE_ADDR fn, int arg1)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr;

  buildaddr = current_insn_ptr;
  i = 0;
  buf[i++] = 0xbf; /* movl $<n>,%edi */
  memcpy (&buf[i], &arg1, sizeof (arg1));
  i += 4;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
  EMIT_ASM (amd64_void_call_2_a,
	    /* Save away a copy of the stack top.  */
	    "push %rax\n\t"
	    /* Also pass top as the second argument.  */
	    "mov %rax,%rsi");
  amd64_emit_call (fn);
  EMIT_ASM (amd64_void_call_2_b,
	    /* Restore the stack top, %rax may have been trashed.  */
	    "pop %rax");
}

void
amd64_emit_eq_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_eq,
	    "cmp %rax,(%rsp)\n\t"
	    "jne .Lamd64_eq_fallthru\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax\n\t"
	    /* jmp, but don't trust the assembler to choose the right jump */
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	    ".Lamd64_eq_fallthru:\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax");

  if (offset_p)
    *offset_p = 13;
  if (size_p)
    *size_p = 4;
}

void
amd64_emit_ne_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_ne,
	    "cmp %rax,(%rsp)\n\t"
	    "je .Lamd64_ne_fallthru\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax\n\t"
	    /* jmp, but don't trust the assembler to choose the right jump */
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	    ".Lamd64_ne_fallthru:\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax");

  if (offset_p)
    *offset_p = 13;
  if (size_p)
    *size_p = 4;
}

void
amd64_emit_lt_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_lt,
	    "cmp %rax,(%rsp)\n\t"
	    "jnl .Lamd64_lt_fallthru\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax\n\t"
	    /* jmp, but don't trust the assembler to choose the right jump */
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	    ".Lamd64_lt_fallthru:\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax");

  if (offset_p)
    *offset_p = 13;
  if (size_p)
    *size_p = 4;
}

void
amd64_emit_le_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_le,
	    "cmp %rax,(%rsp)\n\t"
	    "jnle .Lamd64_le_fallthru\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax\n\t"
	    /* jmp, but don't trust the assembler to choose the right jump */
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	    ".Lamd64_le_fallthru:\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax");

  if (offset_p)
    *offset_p = 13;
  if (size_p)
    *size_p = 4;
}

void
amd64_emit_gt_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_gt,
	    "cmp %rax,(%rsp)\n\t"
	    "jng .Lamd64_gt_fallthru\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax\n\t"
	    /* jmp, but don't trust the assembler to choose the right jump */
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	    ".Lamd64_gt_fallthru:\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax");

  if (offset_p)
    *offset_p = 13;
  if (size_p)
    *size_p = 4;
}

void
amd64_emit_ge_goto (int *offset_p, int *size_p)
{
  EMIT_ASM (amd64_ge,
	    "cmp %rax,(%rsp)\n\t"
	    "jnge .Lamd64_ge_fallthru\n\t"
	    ".Lamd64_ge_jump:\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax\n\t"
	    /* jmp, but don't trust the assembler to choose the right jump */
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	    ".Lamd64_ge_fallthru:\n\t"
	    "lea 0x8(%rsp),%rsp\n\t"
	    "pop %rax");

  if (offset_p)
    *offset_p = 13;
  if (size_p)
    *size_p = 4;
}

struct emit_ops amd64_emit_ops =
  {
    amd64_emit_prologue,
    amd64_emit_epilogue,
    amd64_emit_add,
    amd64_emit_sub,
    amd64_emit_mul,
    amd64_emit_lsh,
    amd64_emit_rsh_signed,
    amd64_emit_rsh_unsigned,
    amd64_emit_ext,
    amd64_emit_log_not,
    amd64_emit_bit_and,
    amd64_emit_bit_or,
    amd64_emit_bit_xor,
    amd64_emit_bit_not,
    amd64_emit_equal,
    amd64_emit_less_signed,
    amd64_emit_less_unsigned,
    amd64_emit_ref,
    amd64_emit_if_goto,
    amd64_emit_goto,
    amd64_write_goto_address,
    amd64_emit_const,
    amd64_emit_call,
    amd64_emit_reg,
    amd64_emit_pop,
    amd64_emit_stack_flush,
    amd64_emit_zero_ext,
    amd64_emit_swap,
    amd64_emit_stack_adjust,
    amd64_emit_int_call_1,
    amd64_emit_void_call_2,
    amd64_emit_eq_goto,
    amd64_emit_ne_goto,
    amd64_emit_lt_goto,
    amd64_emit_le_goto,
    amd64_emit_gt_goto,
    amd64_emit_ge_goto
  };

#endif /* __x86_64__ */

static void
i386_emit_prologue (void)
{
  EMIT_ASM32 (i386_prologue,
	    "push %ebp\n\t"
	    "mov %esp,%ebp\n\t"
	    "push %ebx");
  /* At this point, the raw regs base address is at 8(%ebp), and the
     value pointer is at 12(%ebp).  */
}

static void
i386_emit_epilogue (void)
{
  EMIT_ASM32 (i386_epilogue,
	    "mov 12(%ebp),%ecx\n\t"
	    "mov %eax,(%ecx)\n\t"
	    "mov %ebx,0x4(%ecx)\n\t"
	    "xor %eax,%eax\n\t"
	    "pop %ebx\n\t"
	    "pop %ebp\n\t"
	    "ret");
}

static void
i386_emit_add (void)
{
  EMIT_ASM32 (i386_add,
	    "add (%esp),%eax\n\t"
	    "adc 0x4(%esp),%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_sub (void)
{
  EMIT_ASM32 (i386_sub,
	    "subl %eax,(%esp)\n\t"
	    "sbbl %ebx,4(%esp)\n\t"
	    "pop %eax\n\t"
	    "pop %ebx\n\t");
}

static void
i386_emit_mul (void)
{
  emit_error = 1;
}

static void
i386_emit_lsh (void)
{
  emit_error = 1;
}

static void
i386_emit_rsh_signed (void)
{
  emit_error = 1;
}

static void
i386_emit_rsh_unsigned (void)
{
  emit_error = 1;
}

static void
i386_emit_ext (int arg)
{
  switch (arg)
    {
    case 8:
      EMIT_ASM32 (i386_ext_8,
		"cbtw\n\t"
		"cwtl\n\t"
		"movl %eax,%ebx\n\t"
		"sarl $31,%ebx");
      break;
    case 16:
      EMIT_ASM32 (i386_ext_16,
		"cwtl\n\t"
		"movl %eax,%ebx\n\t"
		"sarl $31,%ebx");
      break;
    case 32:
      EMIT_ASM32 (i386_ext_32,
		"movl %eax,%ebx\n\t"
		"sarl $31,%ebx");
      break;
    default:
      emit_error = 1;
    }
}

static void
i386_emit_log_not (void)
{
  EMIT_ASM32 (i386_log_not,
	    "or %ebx,%eax\n\t"
	    "test %eax,%eax\n\t"
	    "sete %cl\n\t"
	    "xor %ebx,%ebx\n\t"
	    "movzbl %cl,%eax");
}

static void
i386_emit_bit_and (void)
{
  EMIT_ASM32 (i386_and,
	    "and (%esp),%eax\n\t"
	    "and 0x4(%esp),%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_bit_or (void)
{
  EMIT_ASM32 (i386_or,
	    "or (%esp),%eax\n\t"
	    "or 0x4(%esp),%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_bit_xor (void)
{
  EMIT_ASM32 (i386_xor,
	    "xor (%esp),%eax\n\t"
	    "xor 0x4(%esp),%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_bit_not (void)
{
  EMIT_ASM32 (i386_bit_not,
	    "xor $0xffffffff,%eax\n\t"
	    "xor $0xffffffff,%ebx\n\t");
}

static void
i386_emit_equal (void)
{
  EMIT_ASM32 (i386_equal,
	    "cmpl %ebx,4(%esp)\n\t"
	    "jne .Li386_equal_false\n\t"
	    "cmpl %eax,(%esp)\n\t"
	    "je .Li386_equal_true\n\t"
	    ".Li386_equal_false:\n\t"
	    "xor %eax,%eax\n\t"
	    "jmp .Li386_equal_end\n\t"
	    ".Li386_equal_true:\n\t"
	    "mov $1,%eax\n\t"
	    ".Li386_equal_end:\n\t"
	    "xor %ebx,%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_less_signed (void)
{
  EMIT_ASM32 (i386_less_signed,
	    "cmpl %ebx,4(%esp)\n\t"
	    "jl .Li386_less_signed_true\n\t"
	    "jne .Li386_less_signed_false\n\t"
	    "cmpl %eax,(%esp)\n\t"
	    "jl .Li386_less_signed_true\n\t"
	    ".Li386_less_signed_false:\n\t"
	    "xor %eax,%eax\n\t"
	    "jmp .Li386_less_signed_end\n\t"
	    ".Li386_less_signed_true:\n\t"
	    "mov $1,%eax\n\t"
	    ".Li386_less_signed_end:\n\t"
	    "xor %ebx,%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_less_unsigned (void)
{
  EMIT_ASM32 (i386_less_unsigned,
	    "cmpl %ebx,4(%esp)\n\t"
	    "jb .Li386_less_unsigned_true\n\t"
	    "jne .Li386_less_unsigned_false\n\t"
	    "cmpl %eax,(%esp)\n\t"
	    "jb .Li386_less_unsigned_true\n\t"
	    ".Li386_less_unsigned_false:\n\t"
	    "xor %eax,%eax\n\t"
	    "jmp .Li386_less_unsigned_end\n\t"
	    ".Li386_less_unsigned_true:\n\t"
	    "mov $1,%eax\n\t"
	    ".Li386_less_unsigned_end:\n\t"
	    "xor %ebx,%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_ref (int size)
{
  switch (size)
    {
    case 1:
      EMIT_ASM32 (i386_ref1,
		"movb (%eax),%al");
      break;
    case 2:
      EMIT_ASM32 (i386_ref2,
		"movw (%eax),%ax");
      break;
    case 4:
      EMIT_ASM32 (i386_ref4,
		"movl (%eax),%eax");
      break;
    case 8:
      EMIT_ASM32 (i386_ref8,
		"movl 4(%eax),%ebx\n\t"
		"movl (%eax),%eax");
      break;
    }
}

static void
i386_emit_if_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (i386_if_goto,
	    "mov %eax,%ecx\n\t"
	    "or %ebx,%ecx\n\t"
	    "pop %eax\n\t"
	    "pop %ebx\n\t"
	    "cmpl $0,%ecx\n\t"
	    /* Don't trust the assembler to choose the right jump */
	    ".byte 0x0f, 0x85, 0x0, 0x0, 0x0, 0x0");

  if (offset_p)
    *offset_p = 11; /* be sure that this matches the sequence above */
  if (size_p)
    *size_p = 4;
}

static void
i386_emit_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (i386_goto,
	    /* Don't trust the assembler to choose the right jump */
	    ".byte 0xe9, 0x0, 0x0, 0x0, 0x0");
  if (offset_p)
    *offset_p = 1;
  if (size_p)
    *size_p = 4;
}

static void
i386_write_goto_address (CORE_ADDR from, CORE_ADDR to, int size)
{
  int diff = (to - (from + size));
  unsigned char buf[sizeof (int)];

  /* We're only doing 4-byte sizes at the moment.  */
  if (size != 4)
    {
      emit_error = 1;
      return;
    }

  memcpy (buf, &diff, sizeof (int));
  write_inferior_memory (from, buf, sizeof (int));
}

static void
i386_emit_const (LONGEST num)
{
  unsigned char buf[16];
  int i, hi, lo;
  CORE_ADDR buildaddr = current_insn_ptr;

  i = 0;
  buf[i++] = 0xb8; /* mov $<n>,%eax */
  lo = num & 0xffffffff;
  memcpy (&buf[i], &lo, sizeof (lo));
  i += 4;
  hi = ((num >> 32) & 0xffffffff);
  if (hi)
    {
      buf[i++] = 0xbb; /* mov $<n>,%ebx */
      memcpy (&buf[i], &hi, sizeof (hi));
      i += 4;
    }
  else
    {
      buf[i++] = 0x31; buf[i++] = 0xdb; /* xor %ebx,%ebx */
    }
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
}

static void
i386_emit_call (CORE_ADDR fn)
{
  unsigned char buf[16];
  int i, offset;
  CORE_ADDR buildaddr;

  buildaddr = current_insn_ptr;
  i = 0;
  buf[i++] = 0xe8; /* call <reladdr> */
  offset = ((int) fn) - (buildaddr + 5);
  memcpy (buf + 1, &offset, 4);
  append_insns (&buildaddr, 5, buf);
  current_insn_ptr = buildaddr;
}

static void
i386_emit_reg (int reg)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr;

  EMIT_ASM32 (i386_reg_a,
	    "sub $0x8,%esp");
  buildaddr = current_insn_ptr;
  i = 0;
  buf[i++] = 0xb8; /* mov $<n>,%eax */
  memcpy (&buf[i], &reg, sizeof (reg));
  i += 4;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
  EMIT_ASM32 (i386_reg_b,
	    "mov %eax,4(%esp)\n\t"
	    "mov 8(%ebp),%eax\n\t"
	    "mov %eax,(%esp)");
  i386_emit_call (get_raw_reg_func_addr ());
  EMIT_ASM32 (i386_reg_c,
	    "xor %ebx,%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

static void
i386_emit_pop (void)
{
  EMIT_ASM32 (i386_pop,
	    "pop %eax\n\t"
	    "pop %ebx");
}

static void
i386_emit_stack_flush (void)
{
  EMIT_ASM32 (i386_stack_flush,
	    "push %ebx\n\t"
	    "push %eax");
}

static void
i386_emit_zero_ext (int arg)
{
  switch (arg)
    {
    case 8:
      EMIT_ASM32 (i386_zero_ext_8,
		"and $0xff,%eax\n\t"
		"xor %ebx,%ebx");
      break;
    case 16:
      EMIT_ASM32 (i386_zero_ext_16,
		"and $0xffff,%eax\n\t"
		"xor %ebx,%ebx");
      break;
    case 32:
      EMIT_ASM32 (i386_zero_ext_32,
		"xor %ebx,%ebx");
      break;
    default:
      emit_error = 1;
    }
}

static void
i386_emit_swap (void)
{
  EMIT_ASM32 (i386_swap,
	    "mov %eax,%ecx\n\t"
	    "mov %ebx,%edx\n\t"
	    "pop %eax\n\t"
	    "pop %ebx\n\t"
	    "push %edx\n\t"
	    "push %ecx");
}

static void
i386_emit_stack_adjust (int n)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr = current_insn_ptr;

  i = 0;
  buf[i++] = 0x8d; /* lea $<n>(%esp),%esp */
  buf[i++] = 0x64;
  buf[i++] = 0x24;
  buf[i++] = n * 8;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
}

/* FN's prototype is `LONGEST(*fn)(int)'.  */

static void
i386_emit_int_call_1 (CORE_ADDR fn, int arg1)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr;

  EMIT_ASM32 (i386_int_call_1_a,
	    /* Reserve a bit of stack space.  */
	    "sub $0x8,%esp");
  /* Put the one argument on the stack.  */
  buildaddr = current_insn_ptr;
  i = 0;
  buf[i++] = 0xc7;  /* movl $<arg1>,(%esp) */
  buf[i++] = 0x04;
  buf[i++] = 0x24;
  memcpy (&buf[i], &arg1, sizeof (arg1));
  i += 4;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
  i386_emit_call (fn);
  EMIT_ASM32 (i386_int_call_1_c,
	    "mov %edx,%ebx\n\t"
	    "lea 0x8(%esp),%esp");
}

/* FN's prototype is `void(*fn)(int,LONGEST)'.  */

static void
i386_emit_void_call_2 (CORE_ADDR fn, int arg1)
{
  unsigned char buf[16];
  int i;
  CORE_ADDR buildaddr;

  EMIT_ASM32 (i386_void_call_2_a,
	    /* Preserve %eax only; we don't have to worry about %ebx.  */
	    "push %eax\n\t"
	    /* Reserve a bit of stack space for arguments.  */
	    "sub $0x10,%esp\n\t"
	    /* Copy "top" to the second argument position.  (Note that
	       we can't assume function won't scribble on its
	       arguments, so don't try to restore from this.)  */
	    "mov %eax,4(%esp)\n\t"
	    "mov %ebx,8(%esp)");
  /* Put the first argument on the stack.  */
  buildaddr = current_insn_ptr;
  i = 0;
  buf[i++] = 0xc7;  /* movl $<arg1>,(%esp) */
  buf[i++] = 0x04;
  buf[i++] = 0x24;
  memcpy (&buf[i], &arg1, sizeof (arg1));
  i += 4;
  append_insns (&buildaddr, i, buf);
  current_insn_ptr = buildaddr;
  i386_emit_call (fn);
  EMIT_ASM32 (i386_void_call_2_b,
	    "lea 0x10(%esp),%esp\n\t"
	    /* Restore original stack top.  */
	    "pop %eax");
}


void
i386_emit_eq_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (eq,
	      /* Check low half first, more likely to be decider  */
	      "cmpl %eax,(%esp)\n\t"
	      "jne .Leq_fallthru\n\t"
	      "cmpl %ebx,4(%esp)\n\t"
	      "jne .Leq_fallthru\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx\n\t"
	      /* jmp, but don't trust the assembler to choose the right jump */
	      ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	      ".Leq_fallthru:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx");

  if (offset_p)
    *offset_p = 18;
  if (size_p)
    *size_p = 4;
}

void
i386_emit_ne_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (ne,
	      /* Check low half first, more likely to be decider  */
	      "cmpl %eax,(%esp)\n\t"
	      "jne .Lne_jump\n\t"
	      "cmpl %ebx,4(%esp)\n\t"
	      "je .Lne_fallthru\n\t"
	      ".Lne_jump:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx\n\t"
	      /* jmp, but don't trust the assembler to choose the right jump */
	      ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	      ".Lne_fallthru:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx");

  if (offset_p)
    *offset_p = 18;
  if (size_p)
    *size_p = 4;
}

void
i386_emit_lt_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (lt,
	      "cmpl %ebx,4(%esp)\n\t"
	      "jl .Llt_jump\n\t"
	      "jne .Llt_fallthru\n\t"
	      "cmpl %eax,(%esp)\n\t"
	      "jnl .Llt_fallthru\n\t"
	      ".Llt_jump:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx\n\t"
	      /* jmp, but don't trust the assembler to choose the right jump */
	      ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	      ".Llt_fallthru:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx");

  if (offset_p)
    *offset_p = 20;
  if (size_p)
    *size_p = 4;
}

void
i386_emit_le_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (le,
	      "cmpl %ebx,4(%esp)\n\t"
	      "jle .Lle_jump\n\t"
	      "jne .Lle_fallthru\n\t"
	      "cmpl %eax,(%esp)\n\t"
	      "jnle .Lle_fallthru\n\t"
	      ".Lle_jump:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx\n\t"
	      /* jmp, but don't trust the assembler to choose the right jump */
	      ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	      ".Lle_fallthru:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx");

  if (offset_p)
    *offset_p = 20;
  if (size_p)
    *size_p = 4;
}

void
i386_emit_gt_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (gt,
	      "cmpl %ebx,4(%esp)\n\t"
	      "jg .Lgt_jump\n\t"
	      "jne .Lgt_fallthru\n\t"
	      "cmpl %eax,(%esp)\n\t"
	      "jng .Lgt_fallthru\n\t"
	      ".Lgt_jump:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx\n\t"
	      /* jmp, but don't trust the assembler to choose the right jump */
	      ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	      ".Lgt_fallthru:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx");

  if (offset_p)
    *offset_p = 20;
  if (size_p)
    *size_p = 4;
}

void
i386_emit_ge_goto (int *offset_p, int *size_p)
{
  EMIT_ASM32 (ge,
	      "cmpl %ebx,4(%esp)\n\t"
	      "jge .Lge_jump\n\t"
	      "jne .Lge_fallthru\n\t"
	      "cmpl %eax,(%esp)\n\t"
	      "jnge .Lge_fallthru\n\t"
	      ".Lge_jump:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx\n\t"
	      /* jmp, but don't trust the assembler to choose the right jump */
	      ".byte 0xe9, 0x0, 0x0, 0x0, 0x0\n\t"
	      ".Lge_fallthru:\n\t"
	      "lea 0x8(%esp),%esp\n\t"
	      "pop %eax\n\t"
	      "pop %ebx");

  if (offset_p)
    *offset_p = 20;
  if (size_p)
    *size_p = 4;
}

struct emit_ops i386_emit_ops =
  {
    i386_emit_prologue,
    i386_emit_epilogue,
    i386_emit_add,
    i386_emit_sub,
    i386_emit_mul,
    i386_emit_lsh,
    i386_emit_rsh_signed,
    i386_emit_rsh_unsigned,
    i386_emit_ext,
    i386_emit_log_not,
    i386_emit_bit_and,
    i386_emit_bit_or,
    i386_emit_bit_xor,
    i386_emit_bit_not,
    i386_emit_equal,
    i386_emit_less_signed,
    i386_emit_less_unsigned,
    i386_emit_ref,
    i386_emit_if_goto,
    i386_emit_goto,
    i386_write_goto_address,
    i386_emit_const,
    i386_emit_call,
    i386_emit_reg,
    i386_emit_pop,
    i386_emit_stack_flush,
    i386_emit_zero_ext,
    i386_emit_swap,
    i386_emit_stack_adjust,
    i386_emit_int_call_1,
    i386_emit_void_call_2,
    i386_emit_eq_goto,
    i386_emit_ne_goto,
    i386_emit_lt_goto,
    i386_emit_le_goto,
    i386_emit_gt_goto,
    i386_emit_ge_goto
  };


static struct emit_ops *
x86_emit_ops (void)
{
#ifdef __x86_64__
  if (is_64bit_tdesc ())
    return &amd64_emit_ops;
  else
#endif
    return &i386_emit_ops;
}

static int
x86_supports_range_stepping (void)
{
  return 1;
}

/* This is initialized assuming an amd64 target.
   x86_arch_setup will correct it for i386 or amd64 targets.  */

struct linux_target_ops the_low_target =
{
  x86_arch_setup,
  x86_linux_regs_info,
  x86_cannot_fetch_register,
  x86_cannot_store_register,
  NULL, /* fetch_register */
  x86_get_pc,
  x86_set_pc,
  x86_breakpoint,
  x86_breakpoint_len,
  NULL,
  1,
  x86_breakpoint_at,
  x86_insert_point,
  x86_remove_point,
  x86_stopped_by_watchpoint,
  x86_stopped_data_address,
  /* collect_ptrace_register/supply_ptrace_register are not needed in the
     native i386 case (no registers smaller than an xfer unit), and are not
     used in the biarch case (HAVE_LINUX_USRREGS is not defined).  */
  NULL,
  NULL,
  /* need to fix up i386 siginfo if host is amd64 */
  x86_siginfo_fixup,
  x86_linux_new_process,
  x86_linux_new_thread,
  x86_linux_prepare_to_resume,
  x86_linux_process_qsupported,
  x86_supports_tracepoints,
  x86_get_thread_area,
  x86_install_fast_tracepoint_jump_pad,
  x86_emit_ops,
  x86_get_min_fast_tracepoint_insn_len,
  x86_supports_range_stepping,
};

void
initialize_low_arch (void)
{
  /* Initialize the Linux target descriptions.  */
#ifdef __x86_64__
  init_registers_amd64_linux ();
  init_registers_amd64_avx_linux ();
  init_registers_x32_linux ();
  init_registers_x32_avx_linux ();

  tdesc_amd64_linux_no_xml = xmalloc (sizeof (struct target_desc));
  copy_target_description (tdesc_amd64_linux_no_xml, tdesc_amd64_linux);
  tdesc_amd64_linux_no_xml->xmltarget = xmltarget_amd64_linux_no_xml;
#endif
  init_registers_i386_linux ();
  init_registers_i386_mmx_linux ();
  init_registers_i386_avx_linux ();

  tdesc_i386_linux_no_xml = xmalloc (sizeof (struct target_desc));
  copy_target_description (tdesc_i386_linux_no_xml, tdesc_i386_linux);
  tdesc_i386_linux_no_xml->xmltarget = xmltarget_i386_linux_no_xml;

  initialize_regsets_info (&x86_regsets_info);
}
@


1.50
log
@[gdbserver] Split a new tracepoint.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* ax.c, linux-low.c, linux-x86-low.c, server.c: Include
	tracepoint.h.
	* server.h (IPA_BUFSIZ, initialize_tracepoint, tracing)
	(disconnected_tracing, tracepoint_look_up_symbols, stop_tracing
	(handle_tracepoint_general_set, handle_tracepoint_query)
	(tracepoint_finished_step, tracepoint_was_hit)
	(release_while_stepping_state_list, current_traceframe)
	(in_readonly_region, traceframe_read_mem)
	(fetch_traceframe_registers, traceframe_read_sdata)
	(traceframe_read_info, struct fast_tpoint_collect_status)
	(fast_tracepoint_collecting, force_unlock_trace_buffer)
	(handle_tracepoit_bkpts, initialize_low_tracepoint)
	(supply_fast_tracepoint_registers)
	(supply_static_tracepoint_registers, set_trampoline_buffer_space)
	(ipa_tdesc, claim_trampoline_space)
	(have_fast_tracepoint_trampoline_buffer, gdb_agent_about_to_close)
	(agent_mem_read, agent_get_trace_state_variable_value)
	(agent_set_trace_state_variable_value, agent_tsv_read)
	(agent_mem_read_string, get_raw_reg_func_addr)
	(get_get_tsv_func_addr, get_set_tsv_func_addr): Move to ...
	* tracepoint.h: ... this new file.
@
text
@d35 1
@


1.49
log
@[GDBserver] Fix gdb.threads/siginfo-threads.exp, gdb.base/siginfo-obj.exp regressions.

This fixes the regressions reported at
<http://sourceware.org/ml/gdb-patches/2013-06/msg00280.html>:

 $ runtest-gdbserver gdb.base/siginfo-obj.exp gdb.base/siginfo-thread.exp gdb.threads/siginfo-threads.exp
 Running ./gdb.base/siginfo-thread.exp ...
 FAIL: gdb.base/siginfo-thread.exp: p ssi_addr
 Running ./gdb.threads/siginfo-threads.exp ...
 FAIL: gdb.threads/siginfo-threads.exp: signal 0 si_pid
 FAIL: gdb.threads/siginfo-threads.exp: signal 1 si_pid
 FAIL: gdb.threads/siginfo-threads.exp: signal 2 si_pid
 FAIL: gdb.threads/siginfo-threads.exp: signal 3 si_pid
 Running ./gdb.base/siginfo-obj.exp ...
 FAIL: gdb.base/siginfo-obj.exp: p ssi_addr
 FAIL: gdb.base/siginfo-obj.exp: p ssi_addr

The multi-arch patch made GDBserver do the the wrong siginfo layout
conversion, because most uses of `linux_is_elf64' were removed, and it
ended up never set.  A global really is the wrong thing to use as
elf64-ness is a per-process property; `linux_is_elf64' was just
accidentally left behind.

Tested on x86_64 Fedora 17.

gdb/gdbserver/
2013-06-12  Pedro Alves  <palves@@redhat.com>

	* linux-x86-low.c (linux_is_elf64): Delete global.
	(x86_siginfo_fixup): Replace reference to `linux_is_elf64' global
	with local linux_pid_exe_is_elf_64_file use.
@
text
@d34 1
@


1.48
log
@[GDBserver] Initialize the x32 avx target description.

All target descriptions must be initialized at startup, but this one was forgotten.

gdb/gdbserver/
2013-06-11  Pedro Alves  <palves@@redhat.com>

	* linux-x86-low.c (initialize_low_arch): Call
	init_registers_x32_avx_linux.
@
text
@a1140 2
/* Is this process 64-bit?  */
static int linux_is_elf64;
d1153 4
d1171 1
a1171 1
  else if (!linux_is_elf64 && sizeof (void *) == 8)
@


1.47
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@d3338 1
@


1.46
log
@	* linux-x86-low.c (ps_get_thread_area): Properly extend address to
	64 bits in 64-cross-32 environment.
@
text
@d33 1
d35 1
a35 2
/* Defined in auto-generated file i386-linux.c.  */
void init_registers_i386_linux (void);
d38 2
a39 2
/* Defined in auto-generated file i386-avx-linux.c.  */
void init_registers_i386_avx_linux (void);
d42 2
a43 2
/* Defined in auto-generated file i386-mmx-linux.c.  */
void init_registers_i386_mmx_linux (void);
d46 2
d50 20
d185 16
d209 1
a209 1
  int use_64bit = register_size (0) == 8;
d252 1
a252 1
  int use_64bit = register_size (0) == 8;
d292 1
a292 1
i386_cannot_store_register (int regno)
d294 5
d303 1
a303 1
i386_cannot_fetch_register (int regno)
d305 5
d319 1
a319 1
  if (register_size (0) == 8)
d341 1
a341 1
  if (register_size (0) == 8)
d410 1
a410 3
   and update target_regsets accordingly, maybe by moving target_regsets
   to linux_target_ops and set the right one there, rather than having to
   modify the target_regsets global.  */
d412 1
a412 1
struct regset_info target_regsets[] =
d437 1
a437 1
  int use_64bit = register_size (0) == 8;
d456 1
a456 1
  int use_64bit = register_size (0) == 8;
d1156 1
a1156 1
  if (register_size (0) == 4)
d1190 34
a1223 1
/* Update gdbserver_xmltarget.  */
d1225 4
a1228 2
static void
x86_linux_update_xmltarget (void)
d1230 5
a1234 1
  int pid;
d1236 6
a1241 23
  static unsigned long long xcr0;
  static int have_ptrace_getregset = -1;
#if !defined(__x86_64__) && defined(HAVE_PTRACE_GETFPXREGS)
  static int have_ptrace_getfpxregs = -1;
#endif

  if (!current_inferior)
    return;

  /* Before changing the register cache internal layout or the target
     regsets, flush the contents of the current valid caches back to
     the threads.  */
  regcache_invalidate ();

  pid = pid_of (get_thread_lwp (current_inferior));
#ifdef __x86_64__
  if (num_xmm_registers == 8)
    init_registers_i386_linux ();
  else if (linux_is_elf64)
    init_registers_amd64_linux ();
  else
    init_registers_x32_linux ();
#else
d1243 7
a1249 4
# ifdef HAVE_PTRACE_GETFPXREGS
      if (have_ptrace_getfpxregs == -1)
	{
	  elf_fpxregset_t fpxregs;
d1251 4
a1254 4
	  if (ptrace (PTRACE_GETFPXREGS, pid, 0, (int) &fpxregs) < 0)
	    {
	      have_ptrace_getfpxregs = 0;
	      x86_xcr0 = I386_XSTATE_X87_MASK;
d1256 1
a1256 14
	      /* Disable PTRACE_GETFPXREGS.  */
	      for (regset = target_regsets;
		   regset->fill_function != NULL; regset++)
		if (regset->get_request == PTRACE_GETFPXREGS)
		  {
		    regset->size = 0;
		    break;
		  }
	    }
	  else
	    have_ptrace_getfpxregs = 1;
	}

      if (!have_ptrace_getfpxregs)
d1258 3
a1260 2
	  init_registers_i386_mmx_linux ();
	  return;
d1262 2
a1263 2
# endif
      init_registers_i386_linux ();
d1269 2
d1273 2
a1274 2
      if (num_xmm_registers == 8)
	gdbserver_xmltarget = xmltarget_i386_linux_no_xml;
a1275 3
	gdbserver_xmltarget = xmltarget_amd64_linux_no_xml;
#else
      gdbserver_xmltarget = xmltarget_i386_linux_no_xml;
d1277 1
a1277 4

      x86_xcr0 = I386_XSTATE_SSE_MASK;

      return;
a1279 1
  /* Check if XSAVE extended state is supported.  */
d1282 1
a1282 1
      unsigned long long xstateregs[I386_XSTATE_SSE_SIZE / sizeof (long long)];
d1289 4
a1292 2
      if (ptrace (PTRACE_GETREGSET, pid, (unsigned int) NT_X86_XSTATE,
		  &iov) < 0)
d1294 13
a1306 2
	  have_ptrace_getregset = 0;
	  return;
d1308 1
a1308 2
      else
	have_ptrace_getregset = 1;
d1310 7
a1316 11
      /* Get XCR0 from XSAVE extended state at byte 464.  */
      xcr0 = xstateregs[464 / sizeof (long long)];

      /* Use PTRACE_GETREGSET if it is available.  */
      for (regset = target_regsets;
	   regset->fill_function != NULL; regset++)
	if (regset->get_request == PTRACE_GETREGSET)
	  regset->size = I386_XSTATE_SIZE (xcr0);
	else if (regset->type != GENERAL_REGS)
	  regset->size = 0;
    }
d1318 1
a1318 1
  if (have_ptrace_getregset)
d1320 9
a1328 2
      /* AVX is the highest feature we support.  */
      if ((xcr0 & I386_XSTATE_AVX_MASK) == I386_XSTATE_AVX_MASK)
d1330 2
a1331 8
	  x86_xcr0 = xcr0;

#ifdef __x86_64__
	  /* I386 has 8 xmm regs.  */
	  if (num_xmm_registers == 8)
	    init_registers_i386_avx_linux ();
	  else if (linux_is_elf64)
	    init_registers_amd64_avx_linux ();
d1333 2
a1334 3
	    init_registers_x32_avx_linux ();
#else
	  init_registers_i386_avx_linux ();
a1335 1
	}
d1337 54
d1423 1
a1423 1
/* Initialize gdbserver for the architecture of the inferior.  */
d1425 6
a1430 6
static void
x86_arch_setup (void)
{
  int pid = pid_of (get_thread_lwp (current_inferior));
  unsigned int machine;
  int is_elf64 = linux_pid_exe_is_elf_64_file (pid, &machine);
d1432 7
a1438 7
  if (sizeof (void *) == 4)
    {
      if (is_elf64 > 0)
	error (_("Can't debug 64-bit process with 32-bit GDBserver"));
#ifndef __x86_64__
      else if (machine == EM_X86_64)
	error (_("Can't debug x86-64 process with 32-bit GDBserver"));
d1440 12
a1451 1
    }
d1453 3
d1457 3
a1459 23
  if (is_elf64 < 0)
    {
      /* This can only happen if /proc/<pid>/exe is unreadable,
	 but "that can't happen" if we've gotten this far.
	 Fall through and assume this is a 32-bit program.  */
    }
  else if (machine == EM_X86_64)
    {
      /* Amd64 doesn't have HAVE_LINUX_USRREGS.  */
      the_low_target.num_regs = -1;
      the_low_target.regmap = NULL;
      the_low_target.cannot_fetch_register = NULL;
      the_low_target.cannot_store_register = NULL;

      /* Amd64 has 16 xmm regs.  */
      num_xmm_registers = 16;

      linux_is_elf64 = is_elf64;
      x86_linux_update_xmltarget ();
      return;
    }

  linux_is_elf64 = 0;
d1461 2
d1464 2
a1465 1
  /* Ok we have a 32-bit inferior.  */
d1467 4
a1470 9
  the_low_target.num_regs = I386_NUM_REGS;
  the_low_target.regmap = i386_regmap;
  the_low_target.cannot_fetch_register = i386_cannot_fetch_register;
  the_low_target.cannot_store_register = i386_cannot_store_register;

  /* I386 has 8 xmm regs.  */
  num_xmm_registers = 8;

  x86_linux_update_xmltarget ();
d1900 1
a1900 1
  if (register_size (0) == 8)
d1934 1
a1934 1
  if (register_size (0) == 8)
d3277 1
a3277 3
  int use_64bit = register_size (0) == 8;

  if (use_64bit)
d3296 3
a3298 5
  -1,
  NULL,
  NULL,
  NULL,
  NULL,
d3329 24
@


1.45
log
@range stepping: gdbserver (x86 GNU/Linux)

This patch adds support for range stepping to GDBserver, teaching it
about vCont;r.

It'd be easy to enable this for all hardware single-step targets
without needing the linux_target_ops hook, however, at least PPC needs
special care, due to the fact that PPC atomic sequences can't be
hardware single-stepped through, a thing which GDBserver doesn't know
about.  So this leaves the support limited to x86/x86_64.

gdb/
2013-05-23  Pedro Alves  <palves@@redhat.com>

	* NEWS: Mention GDBserver range stepping support.

gdb/gdbserver/
2013-05-23  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	* linux-low.c (lwp_in_step_range): New function.
	(linux_wait_1): If the thread was range stepping and stopped
	outside the stepping range, report the stop to GDB.  Otherwise,
	continue stepping.  Add range stepping debug output.
	(linux_set_resume_request): Copy the step range from the resume
	request to the lwp.
	(linux_supports_range_stepping): New.
	(linux_target_ops) <supports_range_stepping>: Set to
	linux_supports_range_stepping.
	* linux-low.h (struct linux_target_ops)
	<supports_range_stepping>: New field.
	(struct lwp_info) <step_range_start, step_range_end>: New fields.
	* linux-x86-low.c (x86_supports_range_stepping): New.
	(the_low_target) <supports_range_stepping>: Set to
	x86_supports_range_stepping.
	* server.c (handle_v_cont): Handle 'r' action.
	(handle_v_requests): Append ";r" if the target supports range
	stepping.
	* target.h (struct thread_resume) <step_range_start,
	step_range_end>: New fields.
	(struct target_ops) <supports_range_stepping>:
	New field.
	(target_supports_range_stepping): New macro.
@
text
@d199 2
a200 1
    *(int *)base = desc[1];
@


1.44
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d3178 6
d3223 1
@


1.44.2.1
log
@	* linux-x86-low.c (ps_get_thread_area): Properly extend address to
	64 bits in 64-cross-32 environment.
@
text
@d199 1
a199 2
    /* Ensure we properly extend the value to 64-bits for x86_64.  */
    *base = (void *) (uintptr_t) desc[1];
@


1.43
log
@2012-07-19  Michael Eager  <eager@@eagercon.com>

	* i386-low.c (Z_packet_to_hw_type): Add Z_PACKET_HW_BP, translate
	to hw_execute.
	* linux-x86-low.c (x86_insert_point, x86_remove_point):
	Call i386_low_insert_watchpoint, i386_low_remove_watchpoint to add/del
	hardware breakpoint.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2004-2012 Free Software Foundation, Inc.
@


1.42
log
@Enable x32 support in gdbserver

	* Makefile.in (clean): Also remove x32.c x32-linux.c
	x32-avx.c x32-avx-linux.c.
	(x32.o): New target.
	(x32.c): Likewise.
	(x32-linux.o): Likewise.
	(x32-linux.c): Likewise.
	(x32-avx.o): Likewise.
	(x32-avx.c): Likewise.
	(x32-avx-linux.o): Likewise.
	(x32-avx-linux.c): Likewise.

	* configure.srv (srv_amd64_regobj): Add x32.o x32-avx.o.
	(srv_amd64_linux_regobj): Add x32-linux.o x32-avx-linux.o.
	(srv_i386_64bit_xmlfiles): Add i386/x32-core.xml.
	(srv_amd64_xmlfiles): Add i386/x32.xml i386/x32-avx.xml.
	(srv_amd64_linux_xmlfiles): Add i386/x32-linux.xml
	i386/x32-avx-linux.xml.

	* linux-x86-low.c (init_registers_x32_linux): New prototype.
	(init_registers_x32_avx_linux): Likwise.
	(x86_linux_update_xmltarget): Call init_registers_x32_linux
	or init_registers_x32_avx_linux if linux_is_elf64 is false.
@
text
@d564 1
a564 1
    case '0':
d575 4
a578 3
    case '2':
    case '3':
    case '4':
d581 1
d594 1
a594 1
    case '0':
d605 4
a608 3
    case '2':
    case '3':
    case '4':
@


1.41
log
@Convert siginfo for x32 in gdbserver

	* linux-x86-low.c (compat_x32_clock_t): New.
	(compat_x32_siginfo_t): Likewise.
	(compat_x32_siginfo_from_siginfo): Likewise.
	(siginfo_from_compat_x32_siginfo): Likewise.
	(linux_is_elf64): Likewise.
	(x86_siginfo_fixup): Call compat_x32_siginfo_from_siginfo
	and siginfo_from_compat_x32_siginfo for x32.
	(x86_arch_setup): Set linux_is_elf64.
@
text
@d44 4
d1165 2
d1168 1
a1168 1
    init_registers_amd64_linux ();
d1263 2
d1266 1
a1266 1
	    init_registers_amd64_avx_linux ();
@


1.40
log
@Check if GDBserver is compatible with process

	PR gdb/13969
	* linux-low.c (linux_pid_exe_is_elf_64_file): Also return the
	e_machine field.
	(linux_qxfer_libraries_svr4): Update call to elf_64_file_p.
	* linux-low.h (linux_pid_exe_is_elf_64_file): Updated.
	* linux-x86-low.c (x86_arch_setup): Check if GDBserver is
	compatible with process.
@
text
@d779 61
d973 116
d1114 15
d1333 1
d1337 2
@


1.39
log
@2012-03-28  Pedro Alves  <palves@@redhat.com>

	* linux-ia64-low.c (ia64_regmap): Map IA64_EC_REGNUM to PT_AR_EC.
	(IA64_GR0_REGNUM, IA64_FR0_REGNUM)
	(IA64_FR1_REGNUM): New defines.
	(ia64_fetch_register): New.
	(the_low_target): Install it.
	* linux-low.h (struct linux_target_ops) <fetch_register>: New
	field.
	* linux-low.c (linux_fetch_registers): Try the
	the_low_target.fetch_register hook first.

	* linux-arm-low.c (the_low_target): Adjust.
	* linux-bfin-low.c (the_low_target): Adjust.
	* linux-cris-low.c (the_low_target): Adjust.
	* linux-crisv32-low.c (the_low_target): Adjust.
	* linux-m32r-low.c (the_low_target): Adjust.
	* linux-m68k-low.c (the_low_target): Adjust.
	* linux-mips-low.c (the_low_target): Adjust.
	* linux-ppc-low.c (the_low_target): Adjust.
	* linux-s390-low.c (the_low_target): Adjust.
	* linux-sh-low.c (the_low_target): Adjust.
	* linux-sparc-low.c (the_low_target): Adjust.
	* linux-tic6x-low.c (the_low_target): Adjust.
	* linux-x86-low.c (the_low_target): Adjust.
	* linux-xtensa-low.c (the_low_target): Adjust.
@
text
@a1108 1
#ifdef __x86_64__
d1110 12
a1121 1
  int use_64bit = linux_pid_exe_is_elf_64_file (pid);
d1123 2
a1124 1
  if (use_64bit < 0)
d1130 1
a1130 1
  else if (use_64bit)
@


1.38
log
@struct siginfo vs. siginfo_t

gdb/
	* amd64-linux-nat.c (amd64_linux_siginfo_fixup): Use siginfo_t instead
	of struct siginfo.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Likewise.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	* linux-nat.c (linux_nat_siginfo_fixup, siginfo_fixup)
	(linux_xfer_siginfo, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-nat.h (struct lwp_info, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Likewise.
	* procfs.c (gdb_siginfo_t): Likewise.

gdbserver/
	* linux-arm-low.c (arm_stopped_by_watchpoint): Use siginfo_t instead of
	struct siginfo.
	* linux-low.c (siginfo_fixup, linux_xfer_siginfo): Likewise.
	* linux-x86-low.c (x86_siginfo_fixup): Likewise.
	* linux-low.h: Include <signal.h>.
	(struct siginfo): Remove forward declaration.
	(struct linux_target_ops) <siginfo_fixup>: Use siginfo_t instead of
	struct siginfo.
@
text
@d2972 1
@


1.37
log
@2012-03-08  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	Fix PR server/13392.
	* linux-x86-low.c (amd64_install_fast_tracepoint_jump_pad): Check
	offset of JMP insn.
	* tracepoint.c (remove_tracepoint): New.
	(cmd_qtdp): Call remove_tracepoint when failed to install.

2012-03-08  Yao Qi  <yao@@codesourcery.com>
	    Pedro Alves  <palves@@redhat.com>

	Fix PR server/13392.
	* gdb.trace/change-loc.exp (tracepoint_change_loc_1): Remove kfail.
	(tracepoint_change_loc_2): Remove kfail.  Return if failed to
	download tracepoints.
	* gdb.trace/pending.exp (pending_tracepoint_works): Likewise.
	(pending_tracepoint_resolved_during_trace): Likewise.
	(pending_tracepoint_installed_during_trace): Likewise.
	(pending_tracepoint_with_action_resolved): Likewise.
@
text
@d921 1
a921 1
x86_siginfo_fixup (struct siginfo *native, void *inf, int direction)
d927 1
a927 1
      if (sizeof (struct siginfo) != sizeof (compat_siginfo_t))
@


1.36
log
@gdb:
        * common/agent.c (agent_loaded_p): New.
        (agent_look_up_symbols): New global.
        * common/agent.h: Declare agent_loaded_p.

gdb/gdbserver:

        * Makefile.in (linux-low.o): Keep dependence on agent.h.
        (linux-x86-low.o): Likewise.
        * server.h: Remove in_process_agent_loaded.
        * tracepoint.c (in_process_agent_loaded): Removed.  Moved it
        common/agent.c.
        Update callers.
@
text
@d23 1
d1204 2
d1329 11
a1339 1
  offset = (tpaddr + orig_size) - (buildaddr + sizeof (jump_insn));
d1348 11
a1358 1
  offset = *jump_entry - (tpaddr + sizeof (jump_insn));
@


1.35
log
@	gdb/
	* features/mips-dsp.xml: New file.
	* features/mips64-dsp.xml: New file.
	* features/mips-dsp-linux.xml: New file.
	* features/mips64-dsp-linux.xml: New file.
	* features/Makefile (WHICH): Add mips-dsp-linux and
	mips64-dsp-linux.
	(mips-dsp-expedite, mips64-dsp-expedite): New variables.
	* features/mips-dsp-linux.c: New file.
	* features/mips64-dsp-linux.c: New file.
	* regformats/mips-dsp-linux.dat: New file.
	* regformats/mips64-dsp-linux.dat: New file.
	* mips-linux-nat.c (mips_linux_register_addr): Handle DSP
	registers.
	(mips64_linux_register_addr): Likewise.
	(mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Update call to
	mips64_linux_regsets_fetch_registers.
	(mips64_linux_store_registers): Update call to
	mips64_linux_regsets_store_registers.
	(mips_linux_read_description): Probe for DSP registers.
	(_initialize_mips_linux_nat): Call initialize_tdesc_mips_dsp_linux
	and initialize_tdesc_mips64_dsp_linux.
	* mips-linux-tdep.c (supply_gregset, mips64_supply_gregset):
	Remove padding of no longer used embedded register slots.
	* mips-linux-tdep.h (DSP_BASE, DSP_CONTROL): New macros.
	(MIPS_RESTART_REGNUM): Redefine enum value.
	* mips-tdep.c (mips_generic_reg_names): Remove trailing null
	strings.
	(mips_tx39_reg_names): Likewise.
	(mips_linux_reg_names): New array of register names for Linux
	targets.
	(mips_register_name): Check for a null pointer in
	mips_processor_reg_names and return an empty string.
	(mips_register_type): Exclude embedded registers for the IRIX
	and Linux ABIs.
	(mips_pseudo_register_type): Likewise.  Use dynamic numbers to
	refer to FP registers, LO, HI, BadVAddr, Cause and PC.  Handle
	DSP registers.
	(mips_stab_reg_to_regnum): Handle DSP accumulators.
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	(mips_gdbarch_init): Likewise.  Initialize internal register
	indices for the Linux ABI.  Use dynamic numbers to refer to
	registers, as applicable, while parsing the target description.
	* mips-tdep.h (struct mips_regnum): Add dspacc/dspctl offsets.

	gdb/doc/
	* gdb.texinfo (MIPS Features): Add org.gnu.gdb.mips.dsp.

	gdb/gdbserver/
	* linux-low.h (linux_target_ops): Add regset_bitmap member.
	* linux-low.c (use_linux_regsets): New macro.
	[!HAVE_LINUX_REGSETS] (regsets_fetch_inferior_registers): Likewise.
	[!HAVE_LINUX_REGSETS] (regsets_store_inferior_registers): Likewise.
	(linux_register_in_regsets): New function.
	(usr_fetch_inferior_registers): Skip registers covered by
	regsets.
	(usr_store_inferior_registers): Likewise.
	(usr_fetch_inferior_registers): New macro.
	(usr_store_inferior_registers): Likewise.
	(linux_fetch_registers): Handle mixed regset/non-regset targets.
	(linux_store_registers): Likewise.
	* linux-mips-low.c (init_registers_mips_dsp_linux): New
	prototype.
	(init_registers_mips64_dsp_linux): Likewise.
	(init_registers_mips_linux): New macro.
	(init_registers_mips_dsp_linux): Likewise.
	(mips_dsp_num_regs): Likewise.
	(DSP_BASE, DSP_CONTROL): New fallback macros.
	(mips_base_regs): New macro.
	(mips_regmap): Use it.  Fix the size.
	(mips_dsp_regmap): New variable.
	(mips_dsp_regset_bitmap): Likewise.
	(mips_arch_setup): New function.
	(mips_cannot_fetch_register): Use the_low_target.regmap rather
	than mips_regmap.
	(mips_cannot_store_register): Likewise.
	(the_low_target): Update .arch_setup, .num_regs and .regmap
	initializers.  Add .regset_bitmap initializer.
	* linux-arm-low.c (the_low_target): Add .regset_bitmap
	initializer.
	* linux-bfin-low.c (the_low_target): Likewise.
	* linux-cris-low.c (the_low_target): Likewise.
	* linux-crisv32-low.c (the_low_target): Likewise.
	* linux-ia64-low.c (the_low_target): Likewise.
	* linux-m32r-low.c (the_low_target): Likewise.
	* linux-m68k-low.c (the_low_target): Likewise.
	* linux-ppc-low.c (the_low_target): Likewise.
	* linux-s390-low.c (the_low_target): Likewise.
	* linux-sh-low.c (the_low_target): Likewise.
	* linux-sparc-low.c (the_low_target): Likewise.
	* linux-tic6x-low.c (the_low_target): Likewise.
	* linux-x86-low.c (the_low_target): Likewise.
	* linux-xtensa-low.c (the_low_target): Likewise.
	* configure.srv <mips*-*-linux*>: Add mips-dsp-linux.o and
	mips64-dsp-linux.o to srv_regobj.  Add mips-dsp-linux.xml,
	mips64-dsp-linux.xml, mips-dsp.xml and mips64-dsp.xml to
	srv_xmlfiles.
	* Makefile.in (mips-dsp-linux.o, mips-dsp-linux.c): New targets.
	(mips64-dsp-linux.o, mips64-dsp-linux.c): Likewise.

	gdb/testsuite/
	* gdb.xml/tdesc-regs.exp: Add "mips-dsp.xml" to the list of MIPS
	core registers.
@
text
@d31 1
d1590 1
a1590 1
  if (in_process_agent_loaded ())
@


1.34
log
@2012-01-27  Pedro Alves  <palves@@redhat.com>

	* linux-low.c (linux_child_pid_to_exec_file): Delete.
	(elf_64_file_p): Make static.
	(linux_pid_exe_is_elf_64_file): New.
	* linux-low.h (linux_child_pid_to_exec_file, elf_64_file_p):
	Delete declarations.
	(linux_pid_exe_is_elf_64_file): Declare.
	* linux-x86-low.c (x86_arch_setup): Use
	linux_pid_exe_is_elf_64_file.
@
text
@d2947 1
@


1.33
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1109 1
a1109 4
  char *file = linux_child_pid_to_exec_file (pid);
  int use_64bit = elf_64_file_p (file);

  free (file);
@


1.32
log
@2011-12-13  Pedro Alves  <pedro@@codesourcery.com>

	PR remote/13492

	* i386-low.c (i386_low_stopped_data_address): Avoid fetching
	DR_CONTROL unless necessary.  Extend comments.
	* linux-x86-low.c (x86_linux_prepare_to_resume): Don't write to
	DR0-3 if not used.  If any watchpoint was set, clear DR_STATUS.
@
text
@d3 1
a3 2
   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.31
log
@2011-11-14  Stan Shebs  <stan@@codesourcery.com>
	    Kwok Cheung Yeung  <kcy@@codesourcery.com>

	* NEWS: Document shorter fast tracepoints and qTMinFTPILen packet.
	* i386-tdep.c (i386_fast_tracepoint_valid_at): Query target for
	the minimum instruction size for fast tracepoints.
	* target.h (struct target_ops): Add new method
	to_get_min_fast_tracepoint_insn_len.
	(target_get_min_fast_tracepoint_insn_len): New.
	* target.c (update_current_target): Set up new target operation.
	* remote.c (remote_write_bytes_aux): Fix typo.
	(remote_get_min_fast_tracepoint_insn_len): New.
	(init_remote_ops): Initialize new field.

	* gdb.texinfo (Create and Delete Tracepoints): Describe what is
	needed to get shorter fast tracepoints.
	(Tracepoint Packets): Document new qTMinFTPILen packet.

	* linux-x86-low.c (small_jump_insn): New.
	(i386_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message, build a trampoline and issue a small
	jump instruction to it.
	(x86_install_fast_tracepoint_jump_pad): Add arguments for
	trampoline and error message.
	(x86_get_min_fast_tracepoint_insn_len): New.
	(the_low_target): Add call to x86_get_min_fast_tracepoint_insn_len.
	* linux-low.h (struct linux_target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new operation.
	* linux-low.c (linux_install_fast_tracepoint_jump_pad): Add
	arguments.
	(linux_get_min_fast_tracepoint_insn_len): New function.
	(linux_target_op): Add new operation.
	* tracepoint.c (gdb_trampoline_buffer): New IPA variable.
	(gdb_trampoline_buffer_end): Ditto.
	(gdb_trampoline_buffer_error): Ditto.
	(struct ipa_sym_addresses): Add fields for new IPA variables.
	(symbol_list): Add entries for new IPA variables.
	(struct tracepoint): Add fields to hold the address range of the
	trampoline used by the tracepoint.
	(trampoline_buffer_head): New static variable.
	(trampoline_buffer_tail): Ditto.
	(claim_trampoline_space): New function.
	(have_fast_tracepoint_trampoline_buffer): New function.
	(clone_fast_tracepoint): Fill in trampoline fields of tracepoint
	structure.
	(install_fast_tracepoint): Ditto, also add error buffer argument.
	(cmd_qtminftpilen): New function.
	(handle_tracepoint_query): Add response to qTMinFTPILen packet.
	(fast_tracepoint_from_trampoline_address): New function.
	(fast_tracepoint_collecting): Handle trampoline as part of jump
	pad space.
	(set_trampoline_buffer_space): New function.
	(initialize_tracepoint): Initialize new IPA variables.
	* target.h (struct target_ops): Add arguments to
	install_fast_tracepoint_jump_pad operation, add new
	get_min_fast_tracepoint_insn_len operation.
	(target_get_min_fast_tracepoint_insn_len): New.
	(install_fast_tracepoint_jump_pad): Add arguments.
	* server.h (IPA_BUFSIZ): Define.
	* linux-i386-ipa.c: Include extra header files.
	(initialize_fast_tracepoint_trampoline_buffer): New function.
	(initialize_low_tracepoint): Call it.
	* server.h (set_trampoline_buffer_space): Declare.
	(claim_trampoline_space): Ditto.
	(have_fast_tracepoint_trampoline_buffer): Ditto.

	* gdb.trace/ftrace.c: New.
	* gdb.trace/ftrace.exp: New.
@
text
@d658 1
d669 10
a678 1
	x86_linux_dr_set (ptid, i, state->dr_mirror[i]);
d685 1
a685 1
  if (lwp->stopped_by_watchpoint)
@


1.31.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2002, 2004-2012 Free Software Foundation, Inc.
@


1.30
log
@	* server.h (struct emit_ops): Add compare-goto fields.
	* tracepoint.c (gdb_agent_op_sizes): New table.
	(emit_eq_goto): New function.
	(emit_ne_goto): New function.
	(emit_lt_goto): New function.
	(emit_le_goto): New function.
	(emit_gt_goto): New function.
	(emit_ge_goto): New function.
	(is_goto_target): New function.
	(compile_bytecodes): Recognize special cases of compare-goto
	combinations and call specialized emitters for them.
	* linux-x86-low.c (amd64_emit_eq_goto): New function.
	(amd64_emit_ne_goto): New function.
	(amd64_emit_lt_goto): New function.
	(amd64_emit_le_goto): New function.
	(amd64_emit_gt_goto): New function.
	(amd64_emit_ge_goto): New function.
	(amd64_emit_ops): Add the new functions.
	(i386_emit_eq_goto): New function.
	(i386_emit_ne_goto): New function.
	(i386_emit_lt_goto): New function.
	(i386_emit_le_goto): New function.
	(i386_emit_gt_goto): New function.
	(i386_emit_ge_goto): New function.
	(i386_emit_ops): Add the new functions.
@
text
@d45 1
d1186 2
d1191 2
a1192 1
					CORE_ADDR *adjusted_insn_addr_end)
d1353 2
d1358 2
a1359 1
				       CORE_ADDR *adjusted_insn_addr_end)
d1465 1
a1465 1
  buf[i++] = 0x1f; /* pop %de */
d1489 34
a1522 5
  offset = *jump_entry - (tpaddr + sizeof (jump_insn));
  memcpy (buf, jump_insn, sizeof (jump_insn));
  memcpy (buf + 1, &offset, 4);
  memcpy (jjump_pad_insn, buf, sizeof (jump_insn));
  *jjump_pad_insn_size = sizeof (jump_insn);
d1536 2
d1541 2
a1542 1
				      CORE_ADDR *adjusted_insn_addr_end)
d1549 1
d1553 2
a1554 1
						   adjusted_insn_addr_end);
d1560 1
d1564 49
a1612 1
						adjusted_insn_addr_end);
d2966 2
a2967 1
  x86_emit_ops
@


1.29
log
@	* linux-x86-low.c (i386_emit_prologue): Save %ebx.
	(i386_emit_epilogue): Restore %ebx.
@
text
@d1996 121
d2149 7
a2155 1
    amd64_emit_void_call_2
d2630 156
d2818 7
a2824 1
    i386_emit_void_call_2
@


1.28
log
@2011-05-31  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* linux-x86-low.c (i386_dr_low_get_addr): Fix off by one in
	assertion.
	* win32-i386-low.c (i386_dr_low_get_addr): Ditto.

	gdb/testsuite/
	* gdb.arch/i386-dr3-watch.c: New file.
	* gdb.arch/i386-dr3-watch.exp: New file.
@
text
@d2038 2
a2039 1
	    "mov %esp,%ebp");
d2052 1
@


1.27
log
@fix strict-aliasing warnings
	* linux-x86-low.c (amd64_emit_const): Call memcpy instead of
	casting pointers.
	(amd64_emit_reg, amd64_emit_int_call_1, amd64_emit_void_call_2):
	(i386_emit_const, i386_emit_reg, i386_emit_int_call_1):
	(i386_emit_void_call_2): Likewise.
@
text
@d511 1
a511 1
  gdb_assert (DR_FIRSTADDR <= regnum && regnum < DR_LASTADDR);
@


1.26
log
@2011-01-05  Michael Snyder  <msnyder@@msnyder-server.eng.vmware.com>

	* gdbreplay.c: Shorten lines of >= 80 columns.
	* linux-low.c: Ditto.
	* linux-ppc-low.c: Ditto.
	* linux-s390-low.c: Ditto.
	* linux-sparc-low.c: Ditto.
	* linux-x86-low.c: Ditto.
	* linux-xtensa-low.c: Ditto.
	* mem-break.c: Ditto.
	* nto-low.c: Ditto.
	* regcache.h: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* server.h: Ditto.
	* thread-db.c: Ditto.
	* tracepoint.c: Ditto.
	* utils.c: Ditto.
	* win32-low.h: Ditto.
@
text
@d1822 1
a1822 1
  *((LONGEST *) (&buf[i])) = num;
d1879 1
a1879 1
  *((int *) (&buf[i])) = reg;
d1962 1
a1962 1
  *((int *) (&buf[i])) = arg1;
d1981 1
a1981 1
  *((int *) (&buf[i])) = arg1;
d2304 1
a2304 1
  int i, hi;
d2309 2
a2310 1
  *((int *) (&buf[i])) = (num & 0xffffffff);
d2316 1
a2316 1
      *((int *) (&buf[i])) = hi;
d2355 1
a2355 1
  *((int *) (&buf[i])) = reg;
d2455 1
a2455 1
  *((int *) (&buf[i])) = arg1;
d2490 1
a2490 1
  *((int *) (&buf[i])) = arg1;
@


1.26.2.1
log
@2011-05-31  Pedro Alves  <pedro@@codesourcery.com>

	gdb/gdbserver/
	* linux-x86-low.c (i386_dr_low_get_addr): Fix off by one in
	assertion.
	* win32-i386-low.c (i386_dr_low_get_addr): Ditto.

	gdb/testsuite/
	* gdb.arch/i386-dr3-watch.c: New file.
	* gdb.arch/i386-dr3-watch.exp: New file.
@
text
@d511 1
a511 1
  gdb_assert (DR_FIRSTADDR <= regnum && regnum <= DR_LASTADDR);
@


1.25
log
@run copyright.sh for 2011.
@
text
@d235 2
a236 1
		lwpid_of (lwp), (void *) (long) idx, (unsigned long) &desc) < 0)
d663 2
a664 1
      struct i386_debug_reg_state *state = &proc->private->arch_private->debug_reg_state;
d1549 1
a1549 1
      __asm__ ("jmp end_" #NAME "\n"				\
@


1.24
log
@	gdb/
	* amd64-linux-nat.c (compat_siginfo_from_siginfo)
	(siginfo_from_compat_siginfo): Also copy si_pid and si_uid when
	si_code is < 0.  Check for si_code == SI_TIMER before checking for
	si_code < 0.

	gdb/gdbserver/
	* linux-x86-low.c (compat_siginfo_from_siginfo)
	(siginfo_from_compat_siginfo): Also copy si_pid and si_uid when
	si_code is < 0.  Check for si_code == SI_TIMER before checking for
	si_code < 0.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.23
log
@	* linux-low.c (linux_unprepare_to_access_memory): Rename to ...
	(linux_done_accessing_memory): ... this.
	(linux_target_ops): Adjust.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Adjust.
	* nto-low.c (nto_target_ops): Adjust comment.
	* server.c (gdb_read_memory, gdb_write_memory): Adjust.
	* spu-low.c (spu_target_ops): Adjust comment.
	* target.h (target_ops): Rename unprepare_to_access_memory field
	to done_accessing_memory.
	(unprepare_to_access_memory): Rename to ...
	(done_accessing_memory): ... this.
@
text
@d795 1
a795 1
  if (to->si_code < 0)
d797 2
d806 1
a806 1
  else if (to->si_code == SI_TIMER)
d808 2
a809 2
      to->cpt_si_timerid = from->si_timerid;
      to->cpt_si_overrun = from->si_overrun;
d851 1
a851 1
  if (to->si_code < 0)
d853 2
d862 1
a862 1
  else if (to->si_code == SI_TIMER)
d864 2
a865 2
      to->si_timerid = from->cpt_si_timerid;
      to->si_overrun = from->cpt_si_overrun;
@


1.22
log
@	* linux-low.c (linux_prepare_to_access_memory): New.
	(linux_unprepare_to_access_memory): New.
	(linux_target_ops): Install them.
	* server.c (read_memory): Rename to ...
	(gdb_read_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(write_memory): Rename to ...
	(gdb_write_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(handle_search_memory_1): Adjust.
	(process_serial_event): Adjust.
	* target.h (struct target_ops): New fields
	prepare_to_access_memory and unprepare_to_access_memory.
	(prepare_to_access_memory, unprepare_to_access_memory): New.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Use
	prepare_to_access_memory/prepare_to_access_memory.
	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_target_ops): Adjust.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d565 1
a565 1
	unprepare_to_access_memory ();
d593 1
a593 1
	unprepare_to_access_memory ();
@


1.21
log
@	PR threads/10729

	* linux-x86-low.c (update_debug_registers_callback): New.
	(i386_dr_low_set_addr): Use it.
	(i386_dr_low_get_addr): New.
	(i386_dr_low_set_control): Use update_debug_registers_callback.
	(i386_dr_low_get_control): New.
	(i386_dr_low_get_status): Adjust.
	* linux-low.c (linux_stop_lwp): New.
	* linux-low.h (linux_stop_lwp): Declare.

	* i386-low.c (I386_DR_GET_RW_LEN): Take the dr7 contents as
	argument instead of a i386_debug_reg_state.
	(I386_DR_WATCH_HIT): Take the dr6 contents as argument instead of
	a i386_debug_reg_state.
	(i386_insert_aligned_watchpoint): Adjust.
	(i386_remove_aligned_watchpoint): Adjust.
	(i386_low_stopped_data_address): Read the debug registers from the
	inferior instead of from the mirrors.
	* i386-low.h (struct i386_debug_reg_state): Extend comment.
	(i386_dr_low_get_addr): Declare.
	(i386_dr_low_get_control): Declare.
	(i386_dr_low_get_status): Change prototype.

	* win32-i386-low.c (dr_status_mirror, dr_control_mirror): New globals.
	(i386_dr_low_get_addr): New.
	(i386_dr_low_get_control): New.
	(i386_dr_low_get_status): Adjust prototype.  Return
	dr_status_mirror.
	(i386_initial_stuff): Clear dr_status_mirror and
	dr_control_mirror.
	(i386_get_thread_context): Adjust.
	(i386_set_thread_context): Adjust.
	(i386_thread_added): Adjust.
@
text
@d549 1
a549 1
/* Watchpoint support.  */
d558 10
a567 1
      return set_gdb_breakpoint_at (addr);
d586 10
a595 1
      return delete_gdb_breakpoint_at (addr);
@


1.20
log
@2010-06-20  Ian Lance Taylor  <iant@@google.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* linux-x86-low.c (always_true): Delete.
	(EMIT_ASM, EMIT_ASM32): Use an uncondition asm jmp instead of
	trying to fool the compiler with always_true.
@
text
@d464 23
d492 1
a492 3
  struct inferior_list_entry *lp;
  CORE_ADDR addr;
  /* Only need to update the threads of this process.  */
d498 2
a499 1
  addr = state->dr_mirror[regnum];
d501 10
a510 3
  for (lp = all_lwps.head; lp; lp = lp->next)
    {
      struct lwp_info *lwp = (struct lwp_info *) lp;
d512 1
a512 5
      /* The actual update is done later, we just mark that the register
	 needs updating.  */
      if (pid_of (lwp) == pid)
	lwp->arch_private->debug_registers_changed = 1;
    }
d520 1
a520 2
  struct inferior_list_entry *lp;
  /* Only need to update the threads of this process.  */
d523 10
a532 3
  for (lp = all_lwps.head; lp; lp = lp->next)
    {
      struct lwp_info *lwp = (struct lwp_info *) lp;
d534 1
a534 5
      /* The actual update is done later, we just mark that the register
	 needs updating.  */
      if (pid_of (lwp) == pid)
	lwp->arch_private->debug_registers_changed = 1;
    }
d540 2
a541 2
void
i386_dr_low_get_status (struct i386_debug_reg_state *state)
d546 1
a546 1
  state->dr_status_mirror = x86_linux_dr_get (ptid, DR_STATUS);
@


1.19
log
@	* linux-x86-low.c (amd64_emit_const, amd64_emit_void_call_2)
	(i386_emit_const, i386_emit_void_call_2): Replace int64_t uses with
	LONGEST uses.
	* server.h (struct emit_ops): Replace int64_t uses with LONGEST
	uses.
	* tracepoint.c (emit_const, emit_void_call_2): Replace int64_t
	uses with LONGEST uses.
@
text
@a1486 8
/* A function used to trick optimizers.  */

int
always_true (void)
{
  return 1;
}

d1493 10
a1502 9
#define EMIT_ASM(NAME,INSNS)						\
  { extern unsigned char start_ ## NAME, end_ ## NAME;			\
    add_insns (&start_ ## NAME, &end_ ## NAME - &start_ ## NAME);	\
    if (always_true ())						\
      goto skipover ## NAME;						\
    __asm__ ("start_" #NAME ":\n\t" INSNS "\n\tend_" #NAME ":\n\t");	\
    skipover ## NAME:							\
    ; }

d1507 11
a1517 8
  { extern unsigned char start_ ## NAME, end_ ## NAME;			\
    add_insns (&start_ ## NAME, &end_ ## NAME - &start_ ## NAME);	\
    if (always_true ())						\
      goto skipover ## NAME;						\
    __asm__ (".code32\n\tstart_" #NAME ":\n\t" INSNS "\n\tend_" #NAME ":\n" \
	     "\t.code64\n\t");						\
    skipover ## NAME:							\
    ; }
@


1.18
log
@gdb/
2010-06-14  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention GDBserver's JIT compilation of tracepoint
	bytecode.

gdb/gdbserver/
2010-06-14  Stan Shebs  <stan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	Bytecode compiler.

	* linux-x86-low.c: Include limits.h.
	(add_insns): New.
	(always_true): New.
	(EMIT_ASM): New.
	(EMIT_ASM32): New.
	(amd64_emit_prologue, amd64_emit_epilogue, amd64_emit_add)
	(amd64_emit_sub, amd64_emit_mul, amd64_emit_lsh)
	(amd64_emit_rsh_signed, amd64_emit_rsh_unsigned, amd64_emit_ext,
	(amd64_emit_log_not, amd64_emit_bit_and, amd64_emit_bit_or)
	(amd64_emit_bit_xor, amd64_emit_bit_not, amd64_emit_equal,
	(amd64_emit_less_signed, amd64_emit_less_unsigned, amd64_emit_ref,
	(amd64_emit_if_goto, amd64_emit_goto, amd64_write_goto_address)
	(amd64_emit_const, amd64_emit_call, amd64_emit_reg)
	(amd64_emit_pop, amd64_emit_stack_flush, amd64_emit_zero_ext)
	(amd64_emit_swap, amd64_emit_stack_adjust, amd64_emit_int_call_1)
	(amd64_emit_void_call_2): New.
	(amd64_emit_ops): New.
	(i386_emit_prologue, i386_emit_epilogue, i386_emit_add)
	(i386_emit_sub,i386_emit_mul, i386_emit_lsh, i386_emit_rsh_signed)
	(i386_emit_rsh_unsigned, i386_emit_ext, i386_emit_log_not)
	(i386_emit_bit_and, i386_emit_bit_or, i386_emit_bit_xor)
	(i386_emit_bit_not, i386_emit_equal, i386_emit_less_signed)
	(i386_emit_less_unsigned, i386_emit_ref, i386_emit_if_goto)
	(i386_emit_goto, i386_write_goto_address, i386_emit_const)
	(i386_emit_call, i386_emit_reg, i386_emit_pop)
	(i386_emit_stack_flush, i386_emit_zero_ext, i386_emit_swap)
	(i386_emit_stack_adjust, i386_emit_int_call_1)
	(i386_emit_void_call_2): New.
	(i386_emit_ops): New.
	(x86_emit_ops): New.
	(the_low_target): Install x86_emit_ops.
	* server.h (struct emit_ops): New.
	(get_raw_reg_func_addr): Declare.
	(current_insn_ptr, emit_error): Declare.
	* tracepoint.c (get_raw_reg, get_trace_state_variable_value)
	(set_trace_state_variable_value): New defines.
	(struct ipa_sym_addresses): New fields addr_get_raw_reg,
	addr_get_trace_state_variable_value and
	addr_set_trace_state_variable_value.
	(symbol_list): New fields for get_raw_reg,
	get_trace_state_variable_value and set_trace_state_variable_value.
	(condfn): New typedef.
	(struct tracepoint): New field `compiled_cond'.
	(do_action_at_tracepoint): Clear compiled_cond.
	(get_trace_state_variable_value, set_trace_state_variable_value):
	Export in the IPA.
	(condition_true_at_tracepoint): If there's a compiled condition,
	run that.
	(current_insn_ptr, emit_error): New globals.
	(struct bytecode_address): New.
	(get_raw_reg_func_addr): New.
	(emit_prologue, emit_epilogue, emit_add, emit_sub, emit_mul)
	(emit_lsh, emit_rsh_signed, emit_rsh_unsigned, emit_ext)
	(emit_log_not, emit_bit_and, emit_bit_or, emit_bit_xor)
	(emit_bit_not, emit_equal, emit_less_signed, emit_less_unsigned)
	(emit_ref, emit_if_goto, emit_goto, write_goto_address, emit_const)
	(emit_reg, emit_pop, emit_stack_flush, emit_zero_ext, emit_swap)
	(emit_stack_adjust, emit_int_call_1, emit_void_call_2): New.
	(compile_tracepoint_condition, compile_bytecodes): New.
	* target.h (emit_ops): Forward declare.
	(struct target_ops): New field emit_ops.
	(target_emit_ops): New.
	* linux-amd64-ipa.c (gdb_agent_get_raw_reg): New.
	* linux-i386-ipa.c (gdb_agent_get_raw_reg): New.
	* linux-low.c (linux_emit_ops): New.
	(linux_target_ops): Install it.
	* linux-low.h (struct linux_target_ops): New field emit_ops.
@
text
@d1767 1
a1767 1
amd64_emit_const (int64_t num)
d1775 1
a1775 1
  *((int64_t *) (&buf[i])) = num;
d1787 1
a1787 1
  int64_t offset64;
d1922 1
a1922 1
/* FN's prototype is `void(*fn)(int,int64_t)'.  */
d2254 1
a2254 1
i386_emit_const (int64_t num)
d2417 1
a2417 1
/* FN's prototype is `void(*fn)(int,int64_t)'.  */
@


1.17
log
@gdb/gdbserver/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>
	    Stan Shebs  <stan@@codesourcery.com>

	* Makefile.in (IPA_DEPFILES, extra_libraries): New.
	(all): Depend on $(extra_libraries).
	(install-only): Install the IPA.
	(IPA_OBJS, IPA_LIB): New.
	(clean): Remove the IPA lib.
	(IPAGENT_CFLAGS): New.
	(tracepoint-ipa.o, utils-ipa.o, remote-utils-ipa.o)
	(regcache-ipa.o, i386-linux-ipa.o, linux-i386-ipa.o)
	(linux-amd64-ipa.o, amd64-linux-ipa.o): New rules.
	* linux-amd64-ipa.c, linux-i386-ipa.c: New files.
	* configure.ac: Check for atomic builtins support in the compiler.
	(IPA_DEPFILES, extra_libraries): Define.
	* configure.srv (ipa_obj): Add description.
	(ipa_i386_linux_regobj, ipa_amd64_linux_regobj): Define.
	(i[34567]86-*-linux*): Set ipa_obj.
	(x86_64-*-linux*): Set ipa_obj.
	* linux-low.c (stabilizing_threads): New.
	(supports_fast_tracepoints): New.
	(linux_detach): Stabilize threads before detaching.
	(handle_tracepoints): Handle internal tracing breakpoints.  Assert
	the lwp is either not stabilizing, or is moving out of a jump pad.
	(linux_fast_tracepoint_collecting): New.
	(maybe_move_out_of_jump_pad): New.
	(enqueue_one_deferred_signal): New.
	(dequeue_one_deferred_signal): New.
	(linux_wait_for_event_1): If moving out of a jump pad, defer
	pending signals to later.
	(linux_stabilize_threads): New.
	(linux_wait_1): Check if threads need moving out of jump pads, and
	do it if so.
	(stuck_in_jump_pad_callback): New.
	(move_out_of_jump_pad_callback): New.
	(lwp_running): New.
	(linux_resume_one_lwp): Handle moving out of jump pads.
	(linux_set_resume_request): Dequeue deferred signals.
	(need_step_over_p): Also step over fast tracepoint jumps.
	(start_step_over): Also uninsert fast tracepoint jumps.
	(finish_step_over): Also reinsert fast tracepoint jumps.
	(linux_install_fast_tracepoint_jump): New.
	(linux_target_ops): Install linux_stabilize_threads and
	linux_install_fast_tracepoint_jump_pad.
	* linux-low.h (linux_target_ops) <get_thread_area,
	install_fast_tracepoint_jump_pad>: New fields.
	(struct lwp_info) <collecting_fast_tracepoint,
	pending_signals_to_report, exit_jump_pad_bkpt>: New fields.
	(linux_get_thread_area): Declare.
	* linux-x86-low.c (jump_insn): New.
	(x86_get_thread_area): New.
	(append_insns): New.
	(push_opcode): New.
	(amd64_install_fast_tracepoint_jump_pad): New.
	(i386_install_fast_tracepoint_jump_pad): New.
	(x86_install_fast_tracepoint_jump_pad): New.
	(the_low_target): Install x86_get_thread_area and
	x86_install_fast_tracepoint_jump_pad.
	* mem-break.c (set_raw_breakpoint_at): Use read_inferior_memory.
	(struct fast_tracepoint_jump): New.
	(fast_tracepoint_jump_insn): New.
	(fast_tracepoint_jump_shadow): New.
	(find_fast_tracepoint_jump_at): New.
	(fast_tracepoint_jump_here): New.
	(delete_fast_tracepoint_jump): New.
	(set_fast_tracepoint_jump): New.
	(uninsert_fast_tracepoint_jumps_at): New.
	(reinsert_fast_tracepoint_jumps_at): New.
	(set_breakpoint_at): Use write_inferior_memory.
	(uninsert_raw_breakpoint): Use write_inferior_memory.
	(check_mem_read): Mask out fast tracepoint jumps.
	(check_mem_write): Mask out fast tracepoint jumps.
	* mem-break.h (struct fast_tracepoint_jump): Forward declare.
	(set_fast_tracepoint_jump): Declare.
	(delete_fast_tracepoint_jump)
	(fast_tracepoint_jump_here, uninsert_fast_tracepoint_jumps_at)
	(reinsert_fast_tracepoint_jumps_at): Declare.
	* regcache.c: Don't compile many functions when building the
	in-process agent library.
	(init_register_cache) [IN_PROCESS_AGENT]: Don't allow allocating
	the register buffer in the heap.
	(free_register_cache): If the register buffer isn't owned by the
	regcache, don't free it.
	(set_register_cache) [IN_PROCESS_AGENT]: Don't re-alocate
	pre-existing register caches.
	* remote-utils.c (convert_int_to_ascii): Constify `from' parameter
	type.
	(convert_ascii_to_int): : Constify `from' parameter type.
	(decode_M_packet, decode_X_packet): Replace the `to' parameter by
	a `to_p' pointer to pointer parameter.  If TO_P is NULL, malloc
	the needed buffer in-place.
	(relocate_instruction): New.
	* server.c (handle_query) <qSymbols>: If the target supports
	tracepoints, give it a chance of looking up symbols.  Report
	support for fast tracepoints.
	(handle_status): Stabilize threads.
	(process_serial_event): Adjust.
	* server.h (struct fast_tracepoint_jump): Forward declare.
	(struct process_info) <fast_tracepoint_jumps>: New field.
	(convert_ascii_to_int, convert_int_to_ascii): Adjust.
	(decode_X_packet, decode_M_packet): Adjust.
	(relocate_instruction): Declare.
	(in_process_agent_loaded): Declare.
	(tracepoint_look_up_symbols): Declare.
	(struct fast_tpoint_collect_status): Declare.
	(fast_tracepoint_collecting): Declare.
	(force_unlock_trace_buffer): Declare.
	(handle_tracepoint_bkpts): Declare.
	(initialize_low_tracepoint)
	(supply_fast_tracepoint_registers) [IN_PROCESS_AGENT]: Declare.
	* target.h (struct target_ops) <stabilize_threads,
	install_fast_tracepoint_jump_pad>: New fields.
	(stabilize_threads, install_fast_tracepoint_jump_pad): New.
	* tracepoint.c [HAVE_MALLOC_H]: Include malloc.h.
	[HAVE_STDINT_H]: Include stdint.h.
	(trace_debug_1): Rename to ...
	(trace_vdebug): ... this.
	(trace_debug): Rename to ...
	(trace_debug_1): ... this.  Add `level' parameter.
	(trace_debug): New.
	(ATTR_USED, ATTR_NOINLINE): New.
	(IP_AGENT_EXPORT): New.
	(gdb_tp_heap_buffer, gdb_jump_pad_buffer, gdb_jump_pad_buffer_end)
	(collecting, gdb_collect, stop_tracing, flush_trace_buffer)
	(about_to_request_buffer_space, trace_buffer_is_full)
	(stopping_tracepoint, expr_eval_result, error_tracepoint)
	(tracepoints, tracing, trace_buffer_ctrl, trace_buffer_ctrl_curr)
	(trace_buffer_lo, trace_buffer_hi, traceframe_read_count)
	(traceframe_write_count, traceframes_created)
	(trace_state_variables)
	New renaming defines.
	(struct ipa_sym_addresses): New.
	(STRINGIZE_1, STRINGIZE, IPA_SYM): New.
	(symbol_list): New.
	(ipa_sym_addrs): New.
	(all_tracepoint_symbols_looked_up): New.
	(in_process_agent_loaded): New.
	(write_e_ipa_not_loaded): New.
	(maybe_write_ipa_not_loaded): New.
	(tracepoint_look_up_symbols): New.
	(debug_threads) [IN_PROCESS_AGENT]: New.
	(read_inferior_memory) [IN_PROCESS_AGENT]: New.
	(UNKNOWN_SIDE_EFFECTS): New.
	(stop_tracing): New.
	(flush_trace_buffer): New.
	(stop_tracing_bkpt): New.
	(flush_trace_buffer_bkpt): New.
	(read_inferior_integer): New.
	(read_inferior_uinteger): New.
	(read_inferior_data_pointer): New.
	(write_inferior_data_pointer): New.
	(write_inferior_integer): New.
	(write_inferior_uinteger): New.
	(struct collect_static_trace_data_action): Delete.
	(enum tracepoint_type): New.
	(struct tracepoint) <type>: New field `type'.
	<actions_str, step_actions, step_actions_str>: Only include in GDBserver.
	<orig_size, obj_addr_on_target, adjusted_insn_addr>
	<adjusted_insn_addr_end, jump_pad, jump_pad_end>: New fields.
	(tracepoints): Use IP_AGENT_EXPORT.
	(last_tracepoint): Don't include in the IPA.
	(stopping_tracepoint): Use IP_AGENT_EXPORT.
	(trace_buffer_is_full): Use IP_AGENT_EXPORT.
	(alloced_trace_state_variables): New.
	(trace_state_variables): Use IP_AGENT_EXPORT.
	(traceframe_t): Delete unused variable.
	(circular_trace_buffer): Don't include in the IPA.
	(trace_buffer_start): Delete.
	(struct trace_buffer_control): New.
	(trace_buffer_free): Delete.
	(struct ipa_trace_buffer_control): New.
	(GDBSERVER_FLUSH_COUNT_MASK, GDBSERVER_FLUSH_COUNT_MASK_PREV)
	(GDBSERVER_FLUSH_COUNT_MASK_CURR, GDBSERVER_UPDATED_FLUSH_COUNT_BIT):
	New.
	(trace_buffer_ctrl): New.
	(TRACE_BUFFER_CTRL_CURR): New.
	(trace_buffer_start, trace_buffer_free, trace_buffer_end_free):
	Reimplement as macros.
	(trace_buffer_wrap): Delete.
	(traceframe_write_count, traceframe_read_count)
	(traceframes_created, tracing): Use IP_AGENT_EXPORT.
	(struct tracepoint_hit_ctx) <type>: New field.
	(struct fast_tracepoint_ctx): New.
	(memory_barrier): New.
	(cmpxchg): New.
	(record_tracepoint_error): Update atomically in the IPA.
	(clear_inferior_trace_buffer): New.
	(about_to_request_buffer_space): New.
	(trace_buffer_alloc): Handle GDBserver and inferior simulatenous
	updating the same buffer.
	(add_tracepoint): Default the tracepoint's type to trap
	tracepoint, and orig_size to -1.
	(get_trace_state_variable) [IN_PROCESS_AGENT]: Handle allocated
	internal variables.
	(create_trace_state_variable): New parameter `gdb'.  Handle it.
	(clear_installed_tracepoints): Clear fast tracepoint jumps.
	(cmd_qtdp): Handle fast tracepoints.
	(cmd_qtdv): Adjust.
	(max_jump_pad_size): New.
	(gdb_jump_pad_head): New.
	(get_jump_space_head): New.
	(claim_jump_space): New.
	(sort_tracepoints): New.
	(MAX_JUMP_SIZE): New.
	(cmd_qtstart): Handle fast tracepoints.  Sync tracepoints with the
	IPA.
	(stop_tracing) [IN_PROCESS_AGENT]: Don't include the tdisconnected
	support.  Upload fast traceframes, and delete internal IPA
	breakpoints.
	(stop_tracing_handler): New.
	(flush_trace_buffer_handler): New.
	(cmd_qtstop): Upload fast tracepoints.
	(response_tracepoint): Handle fast tracepoints.
	(tracepoint_finished_step): Upload fast traceframes.  Set the
	tracepoint hit context's tracepoint type.
	(handle_tracepoint_bkpts): New.
	(tracepoint_was_hit): Set the tracepoint hit context's tracepoint
	type.  Add comment about fast tracepoints.
	(collect_data_at_tracepoint) [IN_PROCESS_AGENT]: Don't access the
	non-existing action_str field.
	(get_context_regcache): Handle fast tracepoints.
	(do_action_at_tracepoint) [!IN_PROCESS_AGENT]: Don't write the PC
	to the regcache.
	(fast_tracepoint_from_jump_pad_address): New.
	(fast_tracepoint_from_ipa_tpoint_address): New.
	(collecting_t): New.
	(force_unlock_trace_buffer): New.
	(fast_tracepoint_collecting): New.
	(collecting): New.
	(gdb_collect): New.
	(write_inferior_data_ptr): New.
	(target_tp_heap): New.
	(target_malloc): New.
	(download_agent_expr): New.
	(UALIGN): New.
	(download_tracepoints): New.
	(download_trace_state_variables): New.
	(upload_fast_traceframes): New.
	(IPA_FIRST_TRACEFRAME): New.
	(IPA_NEXT_TRACEFRAME_1): New.
	(IPA_NEXT_TRACEFRAME): New.
	[IN_PROCESS_AGENT]: Include sys/mman.h and fcntl.h.
	[IN_PROCESS_AGENT] (gdb_tp_heap_buffer, gdb_jump_pad_buffer)
	(gdb_jump_pad_buffer_end): New.
	[IN_PROCESS_AGENT] (initialize_tracepoint_ftlib): New.
	(initialize_tracepoint): Adjust.
	[IN_PROCESS_AGENT]: Allocate the IPA heap, and jump pad scratch
	buffer.  Initialize the low module.
	* utils.c (PREFIX, TOOLNAME): New.
	(malloc_failure): Use PREFIX.
	(error): In the IPA, an error causes an exit.
	(fatal, warning): Use PREFIX.
	(internal_error): Use TOOLNAME.
	(NUMCELLS): Increase to 10.
	* configure, config.in: Regenerate.

gdb/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* NEWS: Mention gdbserver fast tracepoints support.

gdb/doc/
2010-06-01  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Set Tracepoints): Mention tracepoints support in
	gdbserver, and add cross reference.
	(Tracepoints support in gdbserver): New subsection.
@
text
@d23 1
d1474 1028
d2536 2
a2537 1
  x86_install_fast_tracepoint_jump_pad
@


1.16
log
@Define xmltarget_amd64_linux_no_xml only for amd64.

2010-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* linux-x86-low.c (xmltarget_amd64_linux_no_xml): Define only
	if __x86_64__ is defined.
@
text
@d43 2
d196 47
d1093 380
d1505 3
a1507 1
  x86_supports_tracepoints
@


1.15
log
@	* regcache.c (set_register_cache): Invalidate regcaches before
	changing the register cache layout.
	(regcache_invalidate_one): Allow a NULL regcache.
	* linux-x86-low.c (x86_linux_update_xmltarget): Invalidate
	regcaches before changing the register cache layout or the target
	regsets.
@
text
@d49 2
d55 1
@


1.14
log
@Avoid unused variable warning on Linux/x86-64.

2010-04-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* linux-x86-low.c (x86_linux_update_xmltarget): Avoid unused
	variable warning on Linux/x86-64.
@
text
@d844 5
@


1.13
log
@	gdb/gdbserver/
	* server.h (LONGEST): New.
	(struct thread_info) <while_stepping>: New field.
	(unpack_varlen_hex, xrealloc, pulongest, plongest, phex_nz):
	Declare.
	(initialize_tracepoint, handle_tracepoint_general_set)
	(handle_tracepoint_query, tracepoint_finished_step)
	(tracepoint_was_hit, release_while_stepping_state_list):
	(current_traceframe): Declare.
	* server.c (handle_general_set): Handle tracepoint packets.
	(read_memory): New.
	(write_memory): New.
	(handle_search_memory_1): Use read_memory.
	(handle_query): Report support for conditional tracepoints, trace
	state variables, and tracepoint sources.  Handle tracepoint
	queries.
	(main): Initialize the tracepoints module.
	(process_serial_event): Handle traceframe reads/writes.

	* linux-low.c (handle_tracepoints): New.
	(linux_wait_1): Call it.
	(linux_resume_one_lwp): Handle while-stepping.
	(linux_supports_tracepoints, linux_read_pc, linux_write_pc): New.
	(linux_target_ops): Install them.
	* linux-low.h (struct linux_target_ops) <supports_tracepoints>:
	New field.
	* linux-x86-low.c (x86_supports_tracepoints): New.
	(the_low_target). Install it.

	* mem-break.h (delete_breakpoint): Declare.
	* mem-break.c (delete_breakpoint): Make external.

	* target.h (struct target_ops): Add `supports_tracepoints',
	`read_pc', and `write_pc' fields.
	(target_supports_tracepoints): Define.
	* utils.c (xrealloc, decimal2str, pulongest, plongest, thirty_two)
	(phex_nz): New.

	* regcache.h (struct regcache) <registers_owned>: New field.
	(init_register_cache, regcache_cpy): Declare.
	(regcache_read_pc, regcache_write_pc): Declare.
	(register_cache_size): Declare.
	(supply_regblock): Declare.
	* regcache.c (init_register_cache): New.
	(new_register_cache): Use it.
	(regcache_cpy): New.
	(register_cache_size): New.
	(supply_regblock): New.
	(regcache_read_pc, regcache_write_pc): New.

	* tracepoint.c: New.

	* Makefile.in (OBS): Add tracepoint.o.
	(tracepoint.o): New rule.

	gdb/
	* regformats/regdat.sh: Include server.h.  Don't include
	regcache.h.
@
text
@d837 1
a837 1
#ifdef HAVE_PTRACE_GETFPXREGS
@


1.12
log
@Support i386 without SSE.

gdb/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-linux-nat.c (have_ptrace_getfpxregs): Initialize to -1
	if HAVE_PTRACE_GETFPXREGS is defined.
	(i386_linux_read_description): Set have_ptrace_getfpxregs and
	have_ptrace_getregset to 0 if ptrace PTRACE_GETFPXREGS failed.

	* i386-linux-tdep.c: Include "features/i386/i386-mmx-linux.c"
	(i386_linux_core_read_description): Return tdesc_i386_mmx_linux
	if .reg-xfp section doesn't exist.
	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_mmx_linux.

	* i386-linux-tdep.h (tdesc_i386_mmx_linux): New.

	* i386-tdep.c: Include "features/i386/i386-mmx.c".
	(i386_go32_init_abi): Set tdesc to tdesc_i386_mmx.
	(i386_validate_tdesc_p): Make org.gnu.gdb.i386.sse optional.  Set
	xcr0 to I386_XSTATE_X87_MASK if SSE isn't available.
	(i386_gdbarch_init): Update comments.
	(_initialize_i386_tdep): Call initialize_tdesc_i386_mmx.

	* common/i386-xstate.h (I386_XSTATE_X87_MASK): New.

	* config/djgpp/fnchange.lst: Add i386 MMX XML files.

	* features/Makefile (i386/i386-mmx-expedite): New.
	(i386/i386-mmx-linux-expedite): Likewise.
	($(outdir)/i386/i386-mmx.dat): Likewise.
	($(outdir)/i386/i386-mmx-linux.dat): Likewise.

	* features/i386/i386-mmx-linux.c: New.
	* features/i386/i386-mmx-linux.xml: Likewise.
	* features/i386/i386-mmx.c: Likewise.
	* features/i386/i386-mmx.xml: Likewise.
	* regformats/i386/i386-mmx-linux.dat: Likewise.
	* regformats/i386/i386-mmx.dat: Likewise.

	* features/Makefile (WHICH): Add i386/i386-mmx and
	i386/i386-mmx-linux.

gdb/doc/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.texinfo (i386 Features): Make org.gnu.gdb.i386.avx
	optional.  Make org.gnu.gdb.i386.avx requires
	org.gnu.gdb.i386.avx.

gdb/gdbserver/

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Also remove i386-mmx.c i386-mmx-linux.c.
	(i386-mmx.o): New.
	(i386-mmx.c): Likewise.
	(i386-mmx-linux.o): Likewise.
	(i386-mmx-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): Add i386-mmx.o.
	(srv_i386_linux_regobj): Add i386-mmx-linux.o.
	(srv_i386_xmlfiles): Add i386/i386-mmx.xml.
	(srv_i386_linux_xmlfiles): Add i386/i386-mmx-linux.xml.

	* linux-x86-low.c (init_registers_i386_mmx_linux): New.
	(x86_linux_update_xmltarget): Call init_registers_i386_mmx_linux
	and return if ptrace PTRACE_GETFPXREGS failed in 32bit.
@
text
@d1030 6
d1067 2
a1068 1
  x86_linux_process_qsupported 
@


1.11
log
@Add x86 AVX support to gdbserver.

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Updated.
	(i386-avx.o): New.
	(i386-avx.c): Likewise.
	(i386-avx-linux.o): Likewise.
	(i386-avx-linux.c): Likewise.
	(amd64-avx.o): Likewise.
	(amd64-avx.c): Likewise.
	(amd64-avx-linux.o): Likewise.
	(amd64-avx-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): Add i386-avx.o.
	(srv_i386_linux_regobj): Add i386-avx-linux.o.
	(srv_amd64_regobj): Add amd64-avx.o.
	(srv_amd64_linux_regobj): Add amd64-avx-linux.o.
	(srv_i386_32bit_xmlfiles): Add i386/32bit-avx.xml.
	(srv_i386_64bit_xmlfiles): Add i386/64bit-avx.xml.
	(srv_i386_xmlfiles): Add i386/i386-avx.xml.
	(srv_amd64_xmlfiles): Add i386/amd64-avx.xml.
	(srv_i386_linux_xmlfiles): Add i386/i386-avx-linux.xml.
	(srv_amd64_linux_xmlfiles): Add i386/amd64-avx-linux.xml.

	* i387-fp.c: Include "i386-xstate.h".
	(i387_xsave): New.
	(i387_cache_to_xsave): Likewise.
	(i387_xsave_to_cache): Likewise.
	(x86_xcr0): Likewise.

	* i387-fp.h (i387_cache_to_xsave): Likewise.
	(i387_xsave_to_cache): Likewise.
	(x86_xcr0): Likewise.

	* linux-arm-low.c (target_regsets): Initialize nt_type to 0.
	* linux-crisv32-low.c (target_regsets): Likewise.
	* linux-m68k-low.c (target_regsets): Likewise.
	* linux-mips-low.c (target_regsets): Likewise.
	* linux-ppc-low.c (target_regsets): Likewise.
	* linux-s390-low.c (target_regsets): Likewise.
	* linux-sh-low.c (target_regsets): Likewise.
	* linux-sparc-low.c (target_regsets): Likewise.
	* linux-xtensa-low.c (target_regsets): Likewise.

	* linux-low.c: Include <sys/uio.h>.
	(regsets_fetch_inferior_registers): Support nt_type.
	(regsets_store_inferior_registers): Likewise.
	(linux_process_qsupported): New.
	(linux_target_ops): Add linux_process_qsupported.

	* linux-low.h (regset_info): Add nt_type.
	(linux_target_ops): Add process_qsupported.

	* linux-x86-low.c: Include "i386-xstate.h", "elf/common.h"
	and <sys/uio.h>.
	(init_registers_i386_avx_linux): New.
	(init_registers_amd64_avx_linux): Likewise.
	(xmltarget_i386_linux_no_xml): Likewise.
	(xmltarget_amd64_linux_no_xml): Likewise.
	(PTRACE_GETREGSET): Likewise.
	(PTRACE_SETREGSET): Likewise.
	(x86_fill_xstateregset): Likewise.
	(x86_store_xstateregset): Likewise.
	(use_xml): Likewise.
	(x86_linux_update_xmltarget): Likewise.
	(x86_linux_process_qsupported): Likewise.
	(target_regsets): Add NT_X86_XSTATE entry and Initialize nt_type.
	(x86_arch_setup): Don't call init_registers_amd64_linux nor
	init_registers_i386_linux here.  Call
	x86_linux_update_xmltarget.
	(the_low_target): Add x86_linux_process_qsupported.

	* server.c (handle_query): Call target_process_qsupported.

	* target.h (target_ops): Add process_qsupported.
	(target_process_qsupported): New.
@
text
@d40 2
d833 2
d837 3
d844 1
d851 32
a882 1
  init_registers_i386_linux ();
a904 1
      int pid = pid_of (get_thread_lwp (current_inferior));
a906 1
      struct regset_info *regset;
@


1.10
log
@	* inferiors.c (add_thread): Set last_status kind to
	TARGET_WAITKIND_IGNORE.
	* linux-low.c (cancel_breakpoint): Remove unnecessary regcache
	fetch.  Use ptid_of.  Avoid unnecessary get_lwp_thread calls.
	(linux_wait_1): Move `thread' local definition to block that uses
	it.  Don't NULL initialize `event_child'.
	(linux_resume_one_thread): Avoid unnecessary get_lwp_thread calls.
	Alway set the thread's last_status to TARGET_WAITKIND_IGNORE.
	* linux-x86-low.c (x86_breakpoint_at): Read raw memory.
@
text
@d27 2
d36 15
d55 10
d282 12
d306 1
a306 1
  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof (elf_gregset_t),
d309 2
d313 1
a313 1
  { PTRACE_GETFPXREGS, PTRACE_SETFPXREGS, sizeof (elf_fpxregset_t),
d318 1
a318 1
  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof (elf_fpregset_t),
d322 1
a322 1
  { 0, 0, -1, -1, NULL, NULL }
d824 122
a965 2
      init_registers_amd64_linux ();

d975 1
a981 2
  init_registers_i386_linux ();

d989 2
d1023 2
a1024 1
  x86_linux_prepare_to_resume
@


1.9
log
@	* linux-low.c (linux_wait_1): Avoid setting need_step_over is
	there's a GDB breakpoint at stop_pc.  Always report a trap to GDB
	if we could tell there's a GDB breakpoint at stop_pc.
	(need_step_over_p): Don't do a step over if we find a GDB
	breakpoint at the resume PC.

	* mem-break.c (struct raw_breakpoint): New.
	(enum bkpt_type): New type `gdb_breakpoint'.
	(struct breakpoint): Delete the `PC', `old_data' and `inserted'
	fields.  New field `raw'.
	(find_raw_breakpoint_at): New.
	(set_raw_breakpoint_at): Handle refcounting.  Create a raw
	breakpoint instead.
	(set_breakpoint_at): Adjust.
	(delete_raw_breakpoint): New.
	(release_breakpoint): New.
	(delete_breakpoint): Rename to...
	(delete_breakpoint_1): ... this.  Add proc parameter.  Use
	release_breakpoint.  Return ENOENT.
	(delete_breakpoint): Reimplement.
	(find_breakpoint_at): Delete.
	(find_gdb_breakpoint_at): New.
	(delete_breakpoint_at): Delete.
	(set_gdb_breakpoint_at): New.
	(delete_gdb_breakpoint_at): New.
	(gdb_breakpoint_here): New.
	(set_reinsert_breakpoint): Use release_breakpoint.
	(uninsert_breakpoint): Rename to ...
	(uninsert_raw_breakpoint): ... this.
	(uninsert_breakpoints_at): Adjust to handle raw breakpoints.
	(reinsert_raw_breakpoint): Change parameter type to
	raw_breakpoint.
	(reinsert_breakpoints_at): Adjust to handle raw breakpoints
	instead.
	(check_breakpoints): Adjust.  Use release_breakpoint.
	(breakpoint_here): Rewrite using find_raw_breakpoint_at.
	(breakpoint_inserted_here): Ditto.
	(check_mem_read): Adjust to iterate over raw breakpoints instead.
	Don't trust the breakpoint's shadow if it is not inserted.
	(check_mem_write): Adjust to iterate over raw breakpoints instead.
	(delete_all_breakpoints): Adjust.
	(free_all_breakpoints): Mark all breakpoints as uninserted, and
	use delete_breakpoint_1.

	* mem-break.h (breakpoints_supported): Delete declaration.
	(set_gdb_breakpoint_at): Declare.
	(gdb_breakpoint_here): Declare.
	(delete_breakpoint_at): Delete.
	(delete_gdb_breakpoint_at): Declare.

	* server.h (struct raw_breakpoint): Forward declare.
	(struct process_info): New field `raw_breakpoints'.

	* linux-x86-low.c (x86_insert_point, x86_remote_point): Handle Z0
	breakpoints.
@
text
@d328 1
a328 1
  read_inferior_memory (pc, &c, 1);
@


1.8
log
@	* linux-x86-low.c (x86_linux_prepare_to_resume): Clear DR6 if the
	lwp had been stopped by a watchpoint.
@
text
@d434 2
d453 2
@


1.7
log
@Enable XML target descriptions for x86.

gdb/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* amd64-linux-nat.c (AMD64_LINUX_USER64_CS): New.
	(amd64_linux_read_description): Likewise.
	(_initialize_amd64_linux_nat): Set to_read_description to
	amd64_linux_read_description.

	* amd64-linux-tdep.c: Include "features/i386/amd64-linux.c".
	(amd64_linux_register_name): Removed.
	(amd64_linux_register_type): Likewise.
	(amd64_linux_core_read_description): New.
	(amd64_linux_init_abi): Set target description to
	tdesc_amd64_linux if needed.  Support orig_rax in target
	description.  Don't call set_gdbarch_register_name nor
	set_gdbarch_register_type.  Call
	set_gdbarch_core_read_description.
	(_initialize_amd64_linux_tdep): Call
	initialize_tdesc_amd64_linux.

	* amd64-linux-tdep.h (tdesc_amd64_linux): New.

	* amd64-tdep.c:  Include "features/i386/amd64.c".
	(amd64_register_names): Removed.
	(amd64_register_name): Likewise.
	(amd64_register_type): Likewise.
	(amd64_init_abi):  Set num_core_regs and register_names.  Set
	target description to tdesc_amd64 if needed.  Don't call
	set_gdbarch_register_name nor set_gdbarch_register_type.
	(_initialize_amd64_tdep): New.

	* i386-linux-nat.c (i386_linux_read_description): New.
	(_initialize_i386_linux_nat): Set to_read_description to
	i386_linux_read_description.

	* i386-linux-tdep.c: Include "features/i386/i386-linux.c".
	(i386_linux_register_name): Removed.
	(i386_linux_core_read_description): New.
	(i386_linux_read_description): Likewise.
	(i386_linux_init_abi): Don't call set_gdbarch_register_name.
	Set target description to tdesc_i386_linux if needed.  Support
	orig_eax.  Set register_reggroup_p.  Call
	set_gdbarch_core_read_description.
	(_initialize_i386_linux_tdep): Call initialize_tdesc_i386_linux.

	* i386-linux-tdep.h (tdesc_i386_linux): New.

	* i386-nto-tdep.c (i386nto_regset_id): Replace I386_NUM_FREGS
	with I387_NUM_REGS.

	* i386-tdep.c: Include "features/i386/i386.c".
	(i386_register_names): Make it const.
	(i386_mmx_names): Likewise.
	(i386_num_register_names): Removed.
	(i386_register_name): Likewise.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_type): Likewise.
	(i387_ext_type): Call tdesc_find_type instead of arch_float_type.
	(i386_pseudo_register_name): New.
	(i386_pseudo_register_type): Likewise.
	(i386_mmx_type): Make it static.
	(i386_gdbarch_init): Check arch.  Replace I386_NUM_FREGS with
	I387_NUM_REGS.  Set num_core_regs and register_names.  Don't
	call set_gdbarch_register_name nor set_gdbarch_register_type.
	Set register_reggroup_p.  Set target description to tdesc_i386
	if needed.  Call set_tdesc_pseudo_register_type,
	set_tdesc_pseudo_register_name and tdesc_use_registers.
	(_initialize_i386_tdep): Call initialize_tdesc_i386.
	initialize_tdesc_x86_64.

	* i386-tdep.h (gdbarch_tdep): Remove i386_eflags_type,
	i386_mxcsr_type and i386_sse_type.  Add num_core_regs,
	register_names, tdesc and register_reggroup_p.
	(I386_NUM_FREGS): Removed.
	(i386_eflags_type): Likewise.
	(i386_mxcsr_type): Likewise.
	(i386_mmx_type): Likewise.
	(i386_sse_type): Likewise.
	(i386_register_name): Likewise.
	(i386_regnum): Add I386_MXCSR_REGNUM.
	(I386_SSE_NUM_REGS): Defined with I386_MXCSR_REGNUM.

	* i387-tdep.h (I387_NUM_REGS): New.

	* regformats/i386/i386-linux.dat: Generated.
	* regformats/i386/i386.dat: Likewise.
	* regformats/i386/amd64-linux.dat: Likewise.
	* regformats/i386/amd64.dat: Likewise.

	* regformats/reg-i386-linux.dat: Removed.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-x86-64.dat: Likewise.

gdb/gdbserver/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.in (clean): Replace reg-i386.c, reg-x86-64.c,
	reg-i386-linux.c and reg-x86-64-linux.c with i386.c, amd64.c,
	i386-linux.c and amd64-linux.c.
	(reg-i386.o): Removed.
	(reg-i386.c): Likewise.
	(reg-i386-linux.o): Likewise.
	(reg-i386-linux.c): Likewise.
	(reg-x86-64.o): Likewise.
	(reg-x86-64.c): Likewise.
	(reg-x86-64-linux.o): Likewise.
	(reg-x86-64-linux.c): Likewise.
	(i386.o): New.
	(i386.c): Likewise.
	(i386-linux.o): Likewise.
	(i386-linux.c): Likewise.
	(amd64.o): Likewise.
	(amd64.c): Likewise.
	(amd64-linux.o): Likewise.
	(amd64-linux.c): Likewise.

	* configure.srv (srv_i386_regobj): New.
	(srv_i386_linux_regobj): Likewise.
	(srv_amd64_regobj): Likewise.
	(srv_amd64_linux_regobj): Likewise.
	(srv_i386_32bit_xmlfiles): Likewise.
	(srv_i386_64bit_xmlfiles): Likewise.
	(srv_i386_xmlfiles): Likewise.
	(srv_amd64_xmlfiles): Likewise.
	(srv_i386_linux_xmlfiles): Likewise.
	(srv_amd64_linux_xmlfiles): Likewise.
	(i[34567]86-*-cygwin*): Set srv_regobj to $srv_i386_regobj.  Set
	srv_xmlfiles to $srv_i386_xmlfiles.
	(i[34567]86-*-mingw32ce*): Likewise.
	(i[34567]86-*-mingw*): Likewise.
	(i[34567]86-*-nto*): Likewise.
	(i[34567]86-*-linux*): Set srv_regobj to $srv_i386_linux_regobj
	and $srv_amd64_linux_regobj.  Set srv_xmlfiles to
	$srv_i386_linux_xmlfiles and $srv_amd64_linux_xmlfiles.
	(x86_64-*-linux*): Likewise.

	* linux-x86-low.c (init_registers_x86_64_linux): Removed.
	(init_registers_amd64_linux): New.
	(x86_arch_setup): Replace init_registers_x86_64_linux with
	init_registers_amd64_linux.

gdb/testsuite/

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gdb.xml/tdesc-regs.exp (architecture): New.  Set it for x86.
	(load_description): Set architecture if defined.
@
text
@d510 2
a514 1
      ptid_t ptid = ptid_of (lwp);
d526 3
@


1.6
log
@	* regcache.h (struct thread_info): Forward declare.
	(struct regcache): New.
	(new_register_cache): Adjust prototype.
	(get_thread_regcache): Declare.
	(free_register_cache): Adjust prototype.
	(registers_to_string, registers_from_string): Ditto.
	(supply_register, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Ditto.
	* regcache.c (struct inferior_regcache_data): Delete.
	(get_regcache): Rename to ...
	(get_thread_regcache): ... this.  Adjust.  Switch inferior before
	fetching registers.
	(regcache_invalidate_one): Adjust.
	(regcache_invalidate): Fix prototype.
	(new_register_cache): Return the new register cache.
	(free_register_cache): Change prototype.
	(realloc_register_cache): Adjust.
	(registers_to_string): Change prototype to take a regcache.  Adjust.
	(registers_from_string): Ditto.
	(register_data): Ditto.
	(supply_register): Ditto.
	(supply_register_by_name): Ditto.
	(collect_register): Ditto.
	(collect_register_as_string): Ditto.
	(collect_register_by_name): Ditto.
	* server.c (process_serial_event): Adjust.
	* linux-low.h (regset_fill_func, regset_store_func): Change
	prototype.
	(get_pc, set_pc, collect_ptrace_register, supply_ptrace_register):
	Change prototype.
	* linux-low.c (get_stop_pc): Adjust.
	(check_removed_breakpoint): Adjust.
	(linux_wait_for_event): Adjust.
	(linux_resume_one_lwp): Adjust.
	(fetch_register): Add regcache parameter.  Adjust.
	(usr_store_inferior_registers): Ditto.
	(regsets_fetch_inferior_registers): Ditto.
	(regsets_store_inferior_registers): Ditto.
	(linux_fetch_registers, linux_store_registers): Ditto.
	* i387-fp.c (i387_cache_to_fsave): Change prototype to take a
	regcache.  Adjust.
	(i387_fsave_to_cache, i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* i387-fp.h (i387_cache_to_fsave, i387_fsave_to_cache): Change
	prototype to take a regcache.
	(i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* remote-utils.c (convert_ascii_to_int, outreg)
	(prepare_resume_reply): Change prototype to take a regcache.
	Adjust.
	* target.h (struct target_ops) <fetch_registers, store_registers>:
	Change prototype to take a regcache.
	(fetch_inferior_registers, store_inferior_registers): Change
	prototype to take a regcache.  Adjust.
	* proc-service.c (ps_lgetregs): Adjust.
	* linux-x86-low.c (x86_fill_gregset, x86_store_gregset)
	(x86_fill_fpregset, x86_store_fpregset, x86_fill_fpxregset)
	(x86_store_fpxregset, x86_get_pc, x86_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-arm-low.c (arm_fill_gregset, arm_store_gregset)
	(arm_fill_wmmxregset, arm_store_wmmxregset, arm_fill_vfpregset)
	(arm_store_vfpregset, arm_get_pc, arm_set_pc):
	(arm_breakpoint_at): Change prototype to take a regcache.  Adjust.
	* linux-cris-low.c (cris_get_pc, cris_set_pc)
	(cris_cannot_fetch_register):
	(cris_breakpoint_at): Change prototype to take a regcache.
	Adjust.
	* linux-crisv32-low.c (cris_get_pc, cris_set_pc,
	cris_reinsert_addr, cris_write_data_breakpoint): Change prototype
	to take a regcache.  Adjust.
	(cris_breakpoint_at, cris_insert_point, cris_remove_point):
	Adjust.
	* linux-m32r-low.c (m32r_get_pc, m32r_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-m68k-low.c (m68k_fill_gregset, m68k_store_gregset)
	(m68k_fill_fpregset, m68k_store_fpregset, m68k_get_pc,
	(m68k_set_pc): Change prototype to take a regcache.  Adjust.
	* linux-mips-low.c (mips_get_pc):
	(mips_set_pc): Change prototype to take a regcache.  Adjust.
	(mips_reinsert_addr): Adjust.
	(mips_collect_register): Change prototype to take a regcache.
	Adjust.
	(mips_supply_register):
	(mips_collect_register_32bit, mips_supply_register_32bit)
	(mips_fill_gregset, mips_store_gregset, mips_fill_fpregset)
	(mips_store_fpregset): Ditto.
	* linux-ppc-low.c (ppc_supply_ptrace_register, ppc_supply_ptrace_register):
	Ditto.
	(parse_spufs_run): Adjust.
	(ppc_get_pc, ppc_set_pc, ppc_fill_gregset, ppc_fill_vsxregset)
	(ppc_store_vsxregset, ppc_fill_vrregset, ppc_store_vrregset)
	(ppc_fill_evrregset, ppc_store_evrregset): Change prototype to
	take a regcache.  Adjust.
	* linux-s390-low.c (s390_collect_ptrace_register)
	(s390_supply_ptrace_register, s390_fill_gregset, s390_get_pc)
	(s390_set_pc): Change prototype to take a regcache.  Adjust.
	(s390_arch_setup): Adjust.
	* linux-sh-low.c (sh_get_pc, sh_breakpoint_at)
	(sh_fill_gregset): Change prototype to take a regcache.  Adjust.
	* linux-sparc-low.c (sparc_fill_gregset_to_stack)
	(sparc_fill_gregset, sparc_store_gregset_from_stack)
	(sparc_store_gregset, sparc_get_pc): Change prototype to take a
	regcache.  Adjust.
	(sparc_breakpoint_at): Adjust.
	* linux-xtensa-low.c (xtensa_fill_gregset):
	(xtensa_store_gregset):
	(xtensa_fill_xtregset, xtensa_store_xtregset, xtensa_get_pc)
	(xtensa_set_pc): Change prototype to take a regcache.  Adjust.
	* nto-low.c (nto_fetch_registers, nto_store_registers): Change
	prototype to take a regcache.  Adjust.
	* win32-arm-low.c (arm_fetch_inferior_register)
	(arm_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-i386-low.c (i386_fetch_inferior_register)
	(i386_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-low.c (child_fetch_inferior_registers)
	(child_store_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_wait): Adjust.
	(win32_fetch_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_store_inferior_registers): Adjust.
	* win32-low.h (struct win32_target_ops) <fetch_inferior_register,
	store_inferior_register>: Change prototype to take a regcache.
@
text
@d30 1
a30 1
/* Defined in auto-generated file reg-i386-linux.c.  */
d32 2
a33 2
/* Defined in auto-generated file reg-x86-64-linux.c.  */
void init_registers_x86_64_linux (void);
d795 1
a795 1
      init_registers_x86_64_linux ();
@


1.5
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d176 1
a176 1
x86_fill_gregset (void *buf)
d185 1
a185 1
	  collect_register (i, ((char *) buf) + x86_64_regmap[i]);
d191 1
a191 1
    collect_register (i, ((char *) buf) + i386_regmap[i]);
d193 2
a194 1
  collect_register_by_name ("orig_eax", ((char *) buf) + ORIG_EAX * 4);
d198 1
a198 1
x86_store_gregset (const void *buf)
d207 1
a207 1
	  supply_register (i, ((char *) buf) + x86_64_regmap[i]);
d213 1
a213 1
    supply_register (i, ((char *) buf) + i386_regmap[i]);
d215 2
a216 1
  supply_register_by_name ("orig_eax", ((char *) buf) + ORIG_EAX * 4);
d220 1
a220 1
x86_fill_fpregset (void *buf)
d223 1
a223 1
  i387_cache_to_fxsave (buf);
d225 1
a225 1
  i387_cache_to_fsave (buf);
d230 1
a230 1
x86_store_fpregset (const void *buf)
d233 1
a233 1
  i387_fxsave_to_cache (buf);
d235 1
a235 1
  i387_fsave_to_cache (buf);
d242 1
a242 1
x86_fill_fpxregset (void *buf)
d244 1
a244 1
  i387_cache_to_fxsave (buf);
d248 1
a248 1
x86_store_fpxregset (const void *buf)
d250 1
a250 1
  i387_fxsave_to_cache (buf);
d285 1
a285 1
x86_get_pc (void)
d292 1
a292 1
      collect_register_by_name ("rip", &pc);
d298 1
a298 1
      collect_register_by_name ("eip", &pc);
d304 1
a304 1
x86_set_pc (CORE_ADDR pc)
d311 1
a311 1
      supply_register_by_name ("rip", &newpc);
d316 1
a316 1
      supply_register_by_name ("eip", &newpc);
@


1.4
log
@	* linux-x86-low.c: Delete outdated comment about Elf32_Phdr.
@
text
@d3 1
a3 1
   Copyright (C) 2002, 2004, 2005, 2006, 2007, 2008, 2009
@


1.3
log
@	Add h/w watchpoint support to x86-linux, win32-i386.
	* Makefile.in (SFILES): Add i386-low.c
	(i386_low_h): Define.
	(i386-low.o): Add dependencies.
	(linux-x86-low.o): Add i386-low.h dependency.
	(win32-i386-low.o): Ditto.
	* i386-low.c: New file.
	* i386-low.h: New file.
	* configure.srv (i[34567]86-*-cygwin*): Add i386-low.o to srv_tgtobj.
	(i[34567]86-*-linux*, i[34567]86-*-mingw*, x86_64-*-linux*): Ditto.
	* linux-low.c (linux_add_process): Initialize arch_private.
	(linux_remove_process): Free arch_private.
	(add_lwp): Initialize arch_private.
	(delete_lwp): Free arch_private.
	(linux_resume_one_lwp): Call the_low_target.prepare_to_resume if
	provided.
	* linux-low.h (process_info_private): New member arch_private.
	(lwp_info): New member arch_private.
	(linux_target_ops): New members new_process, new_thread,
	prepare_to_resume.
	(ptid_of): New macro.
	* linux-x86-low.c: Include stddef.h, i386-low.h.
	(arch_process_info): New struct.
	(arch_lwp_info): New struct.
	(x86_linux_dr_get, x86_linux_dr_set): New functions.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(x86_insert_point, x86_remove_point): New functions.
	(x86_stopped_by_watchpoint): New function.
	(x86_stopped_data_address): New function.
	(x86_linux_new_process, x86_linux_new_thread): New functions.
	(x86_linux_prepare_to_resume): New function.
	(the_low_target): Add entries for insert_point, remove_point,
	stopped_by_watchpoint, stopped_data_address, new_process, new_thread,
	prepare_to_resume.
	* server.c (debug_hw_points): New global.
	(monitor_show_help): Document set debug-hw-points.
	(handle_query): Process "set debug-hw-points".
	* server.h (debug_hw_points): Declare.
	(paddress): Declare.
	* utils.c (NUMCELLS, CELLSIZE): New macros.
	(get_sell, xsnprintf, paddress): New functions.
	* win32-arm-low.c (the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-i386-low.c: Include i386-low.h.
	(debug_reg_state): Replaces dr.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(i386_insert_point, i386_remove_point): New functions.
	(i386_stopped_by_watchpoint): New function.
	(i386_stopped_data_address): New function.
	(i386_initial_stuff): Update.
	(get_thread_context,set_thread_context,i386_thread_added): Update.
	(the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-low.c (win32_insert_watchpoint): New function.
	(win32_remove_watchpoint): New function.
	(win32_stopped_by_watchpoint): New function.
	(win32_stopped_data_address): New function.
	(win32_target_ops): Add entries for insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address.
	* win32-low.h (win32_target_ops): New members insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
@
text
@a29 4
/* NOTE: gdb_proc_service.h may include linux/elf.h.
   We need Elf32_Phdr.  If we don't get linux/elf.h we could include
   elf.h like linux-ppc-low.c does.  */

@


1.2
log
@	* linux-x86-low.c: Don't include assert.h.
	(x86_siginfo_fixup): Use fatal, not assert.
	(x86_arch_setup): Fix comment.
@
text
@d21 1
d26 1
d61 15
d337 192
d842 4
a845 4
  NULL,
  NULL,
  NULL,
  NULL,
d853 3
@


1.1
log
@	Biarch support for i386/amd64 gdbserver.
	* Makefile.in (SFILES): Remove linux-i386-low.c, linux-x86-64-low.c.
	Add linux-x86-low.c.
	(linux-i386-low.o, linux-x86-64-low.o): Delete.
	(linux-x86-low.o): Add.
	* linux-x86-64-low.c: Delete.
	* linux-i386-low.c: Delete.
	* linux-x86-low.c: New file.
	* configure.srv (i?86-linux srv_tgtobj): Replace linux-i386-low.o with
	linux-x86-low.o.
	(x86_64-linux srv_tgtobj): Replace linux-x86-64-low.o with
	linux-x86-low.o.
	(x86_64-linux srv_regobj): Add reg-i386-linux.o.
	* linux-low.c: Include ansidecl.h, elf/common.h, elf/external.h.
	(linux_child_pid_to_exec_file): New function.
	(elf_64_header_p, elf_64_file_p): New functions.
	(siginfo_fixup): New function.
	(linux_xfer_siginfo): New local inf_siginfo.  Call siginfo_fixup to
	give target a chance to convert layout.
	* linux-low.h (linux_target_ops): New member siginfo_fixup.
	(linux_child_pid_to_exec_file, elf_64_file_p): Declare.
@
text
@a20 1
#include <assert.h>
d553 2
a554 1
      assert (sizeof (struct siginfo) == sizeof (compat_siginfo_t));
d568 1
a568 1
/* Return non-zero if the target is 64-bit.  */
@

