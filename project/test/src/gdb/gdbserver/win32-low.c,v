head	1.69;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.63
	gdb_7_6-2013-04-26-release:1.63
	gdb_7_6-branch:1.63.0.2
	gdb_7_6-2013-03-12-branchpoint:1.63
	gdb_7_5_1-2012-11-29-release:1.61
	gdb_7_5-2012-08-17-release:1.61
	gdb_7_5-branch:1.61.0.2
	gdb_7_5-2012-07-18-branchpoint:1.61
	gdb_7_4_1-2012-04-26-release:1.57.2.1
	gdb_7_4-2012-01-24-release:1.57.2.1
	gdb_7_4-branch:1.57.0.2
	gdb_7_4-2011-12-13-branchpoint:1.57
	gdb_7_3_1-2011-09-04-release:1.52
	gdb_7_3-2011-07-26-release:1.52
	gdb_7_3-branch:1.52.0.2
	gdb_7_3-2011-04-01-branchpoint:1.52
	gdb_7_2-2010-09-02-release:1.48
	gdb_7_2-branch:1.48.0.2
	gdb_7_2-2010-07-07-branchpoint:1.48
	gdb_7_1-2010-03-18-release:1.43
	gdb_7_1-branch:1.43.0.2
	gdb_7_1-2010-02-18-branchpoint:1.43
	gdb_7_0_1-2009-12-22-release:1.38
	gdb_7_0-2009-10-06-release:1.38
	gdb_7_0-branch:1.38.0.4
	gdb_7_0-2009-09-16-branchpoint:1.38
	arc-sim-20090309:1.25
	msnyder-checkpoint-072509-branch:1.38.0.2
	msnyder-checkpoint-072509-branchpoint:1.38
	arc-insight_6_8-branch:1.25.0.6
	arc-insight_6_8-branchpoint:1.25
	insight_6_8-branch:1.25.0.4
	insight_6_8-branchpoint:1.25
	reverse-20081226-branch:1.28.0.2
	reverse-20081226-branchpoint:1.28
	multiprocess-20081120-branch:1.27.0.8
	multiprocess-20081120-branchpoint:1.27
	reverse-20080930-branch:1.27.0.6
	reverse-20080930-branchpoint:1.27
	reverse-20080717-branch:1.27.0.4
	reverse-20080717-branchpoint:1.27
	msnyder-reverse-20080609-branch:1.27.0.2
	msnyder-reverse-20080609-branchpoint:1.27
	drow-reverse-20070409-branch:1.3.0.2
	drow-reverse-20070409-branchpoint:1.3
	gdb_6_8-2008-03-27-release:1.25
	gdb_6_8-branch:1.25.0.2
	gdb_6_8-2008-02-26-branchpoint:1.25
	gdb_6_7_1-2007-10-29-release:1.15
	gdb_6_7-2007-10-10-release:1.15
	gdb_6_7-branch:1.15.0.2
	gdb_6_7-2007-09-07-branchpoint:1.15;
locks; strict;
comment	@ * @;


1.69
date	2013.09.05.20.45.39;	author palves;	state Exp;
branches;
next	1.68;

1.68
date	2013.09.05.20.41.55;	author palves;	state Exp;
branches;
next	1.67;

1.67
date	2013.09.02.14.32.19;	author muller;	state Exp;
branches;
next	1.66;

1.66
date	2013.07.02.11.59.24;	author mgherzan;	state Exp;
branches;
next	1.65;

1.65
date	2013.07.01.11.28.30;	author palves;	state Exp;
branches;
next	1.64;

1.64
date	2013.06.07.10.46.59;	author palves;	state Exp;
branches;
next	1.63;

1.63
date	2013.02.28.09.09.02;	author corinna;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.01.06.33.00;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2012.05.24.16.51.37;	author palves;	state Exp;
branches;
next	1.60;

1.60
date	2012.05.24.16.39.13;	author palves;	state Exp;
branches;
next	1.59;

1.59
date	2012.04.29.06.28.30;	author qiyao;	state Exp;
branches;
next	1.58;

1.58
date	2012.01.04.08.17.24;	author brobecke;	state Exp;
branches;
next	1.57;

1.57
date	2011.08.14.16.06.59;	author qiyao;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2011.08.14.13.03.13;	author qiyao;	state Exp;
branches;
next	1.55;

1.55
date	2011.08.05.14.21.07;	author eliz;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.19.18.04.09;	author tromey;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.07.23.59.59;	author muller;	state Exp;
branches;
next	1.52;

1.52
date	2011.01.01.15.33.24;	author brobecke;	state Exp;
branches;
next	1.51;

1.51
date	2010.09.01.17.29.32;	author gdbadmin;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.27.00.16.48;	author palves;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.26.23.17.22;	author palves;	state Exp;
branches;
next	1.48;

1.48
date	2010.05.03.04.02.20;	author palves;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.20.00.07.44;	author muller;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.16.07.49.37;	author muller;	state Exp;
branches;
next	1.45;

1.45
date	2010.04.12.17.39.42;	author palves;	state Exp;
branches;
next	1.44;

1.44
date	2010.04.11.16.33.56;	author palves;	state Exp;
branches;
next	1.43;

1.43
date	2010.01.20.22.55.38;	author palves;	state Exp;
branches;
next	1.42;

1.42
date	2010.01.01.07.31.49;	author brobecke;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.26.22.18.40;	author palves;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.26.22.16.29;	author palves;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.26.22.14.39;	author palves;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.04.18.13.28;	author palves;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.30.16.35.25;	author devans;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.22.19.33.41;	author aristovski;	state Exp;
branches;
next	1.35;

1.35
date	2009.04.01.22.50.24;	author palves;	state Exp;
branches;
next	1.34;

1.34
date	2009.04.01.22.48.05;	author palves;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.01.22.31.45;	author palves;	state Exp;
branches;
next	1.32;

1.32
date	2009.04.01.22.29.33;	author palves;	state Exp;
branches;
next	1.31;

1.31
date	2009.03.22.23.57.10;	author palves;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.14.13.42.27;	author palves;	state Exp;
branches;
next	1.29;

1.29
date	2009.01.03.05.57.57;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.14.20.51.04;	author devans;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.28.05.54.09;	author uweigand;	state Exp;
branches;
next	1.26;

1.26
date	2008.02.27.03.27.40;	author uweigand;	state Exp;
branches;
next	1.25;

1.25
date	2008.02.14.22.41.39;	author palves;	state Exp;
branches;
next	1.24;

1.24
date	2008.02.01.00.08.25;	author palves;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.01.22.53.14;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.18.21.58.01;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2007.12.03.01.42.06;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2007.12.03.01.30.59;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.03.01.27.19;	author palves;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.03.01.18.49;	author palves;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.03.01.10.30;	author palves;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.02.23.40.17;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.03.22.17.27;	author palves;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.03.22.04.02;	author palves;	state Exp;
branches;
next	1.13;

1.13
date	2007.08.23.18.08.48;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.31.13.58.19;	author palves;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.17.12.51.41;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.08.19.37.46;	author palves;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.10.22.04.50;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.10.21.48.56;	author palves;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.10.21.05.15;	author palves;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.10.20.48.41;	author palves;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.10.20.39.18;	author palves;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.10.20.25.01;	author palves;	state Exp;
branches;
next	1.3;

1.3
date	2007.03.30.20.28.24;	author palves;	state Exp;
branches;
next	1.2;

1.2
date	2007.03.28.22.12.31;	author palves;	state Exp;
branches;
next	1.1;

1.1
date	2007.03.28.22.00.15;	author palves;	state Exp;
branches;
next	;

1.57.2.1
date	2012.01.06.04.43.40;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.69
log
@[gdbserver] Split a new hostio.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* server.h (handle_vFile, hostio_last_error_from_errno): Move
	to ...
	* hostio.h: ... this new file.
	* hostio.c, server.c, linux-low.c, nto-low.c, spu-low,
	win32-low.c: Include hostio.h.
@
text
@/* Low level interface to Windows debugging, for gdbserver.
   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   Contributed by Leo Zayas.  Based on "win32-nat.c" from GDB.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "server.h"
#include "regcache.h"
#include "gdb/signals.h"
#include "gdb/fileio.h"
#include "mem-break.h"
#include "win32-low.h"
#include "gdbthread.h"
#include "dll.h"
#include "hostio.h"

#include <stdint.h>
#include <windows.h>
#include <winnt.h>
#include <imagehlp.h>
#include <tlhelp32.h>
#include <psapi.h>
#include <process.h>

#ifndef USE_WIN32API
#include <sys/cygwin.h>
#endif

#define OUTMSG(X) do { printf X; fflush (stderr); } while (0)

#define OUTMSG2(X) \
  do						\
    {						\
      if (debug_threads)			\
	{					\
	  printf X;				\
	  fflush (stderr);			\
	}					\
    } while (0)

#ifndef _T
#define _T(x) TEXT (x)
#endif

#ifndef COUNTOF
#define COUNTOF(STR) (sizeof (STR) / sizeof ((STR)[0]))
#endif

#ifdef _WIN32_WCE
# define GETPROCADDRESS(DLL, PROC) \
  ((winapi_ ## PROC) GetProcAddress (DLL, TEXT (#PROC)))
#else
# define GETPROCADDRESS(DLL, PROC) \
  ((winapi_ ## PROC) GetProcAddress (DLL, #PROC))
#endif

int using_threads = 1;

/* Globals.  */
static int attaching = 0;
static HANDLE current_process_handle = NULL;
static DWORD current_process_id = 0;
static DWORD main_thread_id = 0;
static enum gdb_signal last_sig = GDB_SIGNAL_0;

/* The current debug event from WaitForDebugEvent.  */
static DEBUG_EVENT current_event;

/* Non zero if an interrupt request is to be satisfied by suspending
   all threads.  */
static int soft_interrupt_requested = 0;

/* Non zero if the inferior is stopped in a simulated breakpoint done
   by suspending all the threads.  */
static int faked_breakpoint = 0;

const struct target_desc *win32_tdesc;

#define NUM_REGS (the_low_target.num_regs)

typedef BOOL (WINAPI *winapi_DebugActiveProcessStop) (DWORD dwProcessId);
typedef BOOL (WINAPI *winapi_DebugSetProcessKillOnExit) (BOOL KillOnExit);
typedef BOOL (WINAPI *winapi_DebugBreakProcess) (HANDLE);
typedef BOOL (WINAPI *winapi_GenerateConsoleCtrlEvent) (DWORD, DWORD);

static void win32_resume (struct thread_resume *resume_info, size_t n);

/* Get the thread ID from the current selected inferior (the current
   thread).  */
static ptid_t
current_inferior_ptid (void)
{
  return ((struct inferior_list_entry*) current_inferior)->id;
}

/* The current debug event from WaitForDebugEvent.  */
static ptid_t
debug_event_ptid (DEBUG_EVENT *event)
{
  return ptid_build (event->dwProcessId, event->dwThreadId, 0);
}

/* Get the thread context of the thread associated with TH.  */

static void
win32_get_thread_context (win32_thread_info *th)
{
  memset (&th->context, 0, sizeof (CONTEXT));
  (*the_low_target.get_thread_context) (th, &current_event);
#ifdef _WIN32_WCE
  memcpy (&th->base_context, &th->context, sizeof (CONTEXT));
#endif
}

/* Set the thread context of the thread associated with TH.  */

static void
win32_set_thread_context (win32_thread_info *th)
{
#ifdef _WIN32_WCE
  /* Calling SuspendThread on a thread that is running kernel code
     will report that the suspending was successful, but in fact, that
     will often not be true.  In those cases, the context returned by
     GetThreadContext will not be correct by the time the thread
     stops, hence we can't set that context back into the thread when
     resuming - it will most likelly crash the inferior.
     Unfortunately, there is no way to know when the thread will
     really stop.  To work around it, we'll only write the context
     back to the thread when either the user or GDB explicitly change
     it between stopping and resuming.  */
  if (memcmp (&th->context, &th->base_context, sizeof (CONTEXT)) != 0)
#endif
    (*the_low_target.set_thread_context) (th, &current_event);
}

/* Find a thread record given a thread id.  If GET_CONTEXT is set then
   also retrieve the context for this thread.  */
static win32_thread_info *
thread_rec (ptid_t ptid, int get_context)
{
  struct thread_info *thread;
  win32_thread_info *th;

  thread = (struct thread_info *) find_inferior_id (&all_threads, ptid);
  if (thread == NULL)
    return NULL;

  th = inferior_target_data (thread);
  if (get_context && th->context.ContextFlags == 0)
    {
      if (!th->suspended)
	{
	  if (SuspendThread (th->h) == (DWORD) -1)
	    {
	      DWORD err = GetLastError ();
	      OUTMSG (("warning: SuspendThread failed in thread_rec, "
		       "(error %d): %s\n", (int) err, strwinerror (err)));
	    }
	  else
	    th->suspended = 1;
	}

      win32_get_thread_context (th);
    }

  return th;
}

/* Add a thread to the thread list.  */
static win32_thread_info *
child_add_thread (DWORD pid, DWORD tid, HANDLE h, void *tlb)
{
  win32_thread_info *th;
  ptid_t ptid = ptid_build (pid, tid, 0);

  if ((th = thread_rec (ptid, FALSE)))
    return th;

  th = xcalloc (1, sizeof (*th));
  th->tid = tid;
  th->h = h;
  th->thread_local_base = (CORE_ADDR) (uintptr_t) tlb;

  add_thread (ptid, th);

  if (the_low_target.thread_added != NULL)
    (*the_low_target.thread_added) (th);

  return th;
}

/* Delete a thread from the list of threads.  */
static void
delete_thread_info (struct inferior_list_entry *thread)
{
  win32_thread_info *th = inferior_target_data ((struct thread_info *) thread);

  remove_thread ((struct thread_info *) thread);
  CloseHandle (th->h);
  free (th);
}

/* Delete a thread from the list of threads.  */
static void
child_delete_thread (DWORD pid, DWORD tid)
{
  struct inferior_list_entry *thread;
  ptid_t ptid;

  /* If the last thread is exiting, just return.  */
  if (all_threads.head == all_threads.tail)
    return;

  ptid = ptid_build (pid, tid, 0);
  thread = find_inferior_id (&all_threads, ptid);
  if (thread == NULL)
    return;

  delete_thread_info (thread);
}

/* These watchpoint related wrapper functions simply pass on the function call
   if the low target has registered a corresponding function.  */

static int
win32_insert_point (char type, CORE_ADDR addr, int len)
{
  if (the_low_target.insert_point != NULL)
    return the_low_target.insert_point (type, addr, len);
  else
    /* Unsupported (see target.h).  */
    return 1;
}

static int
win32_remove_point (char type, CORE_ADDR addr, int len)
{
  if (the_low_target.remove_point != NULL)
    return the_low_target.remove_point (type, addr, len);
  else
    /* Unsupported (see target.h).  */
    return 1;
}

static int
win32_stopped_by_watchpoint (void)
{
  if (the_low_target.stopped_by_watchpoint != NULL)
    return the_low_target.stopped_by_watchpoint ();
  else
    return 0;
}

static CORE_ADDR
win32_stopped_data_address (void)
{
  if (the_low_target.stopped_data_address != NULL)
    return the_low_target.stopped_data_address ();
  else
    return 0;
}


/* Transfer memory from/to the debugged process.  */
static int
child_xfer_memory (CORE_ADDR memaddr, char *our, int len,
		   int write, struct target_ops *target)
{
  BOOL success;
  SIZE_T done = 0;
  DWORD lasterror = 0;
  uintptr_t addr = (uintptr_t) memaddr;

  if (write)
    {
      success = WriteProcessMemory (current_process_handle, (LPVOID) addr,
				    (LPCVOID) our, len, &done);
      if (!success)
	lasterror = GetLastError ();
      FlushInstructionCache (current_process_handle, (LPCVOID) addr, len);
    }
  else
    {
      success = ReadProcessMemory (current_process_handle, (LPCVOID) addr,
				   (LPVOID) our, len, &done);
      if (!success)
	lasterror = GetLastError ();
    }
  if (!success && lasterror == ERROR_PARTIAL_COPY && done > 0)
    return done;
  else
    return success ? done : -1;
}

/* Clear out any old thread list and reinitialize it to a pristine
   state. */
static void
child_init_thread_list (void)
{
  for_each_inferior (&all_threads, delete_thread_info);
}

static void
do_initial_child_stuff (HANDLE proch, DWORD pid, int attached)
{
  struct process_info *proc;

  last_sig = GDB_SIGNAL_0;

  current_process_handle = proch;
  current_process_id = pid;
  main_thread_id = 0;

  soft_interrupt_requested = 0;
  faked_breakpoint = 0;

  memset (&current_event, 0, sizeof (current_event));

  proc = add_process (pid, attached);
  proc->tdesc = win32_tdesc;
  child_init_thread_list ();

  if (the_low_target.initial_stuff != NULL)
    (*the_low_target.initial_stuff) ();
}

/* Resume all artificially suspended threads if we are continuing
   execution.  */
static int
continue_one_thread (struct inferior_list_entry *this_thread, void *id_ptr)
{
  struct thread_info *thread = (struct thread_info *) this_thread;
  int thread_id = * (int *) id_ptr;
  win32_thread_info *th = inferior_target_data (thread);

  if ((thread_id == -1 || thread_id == th->tid)
      && th->suspended)
    {
      if (th->context.ContextFlags)
	{
	  win32_set_thread_context (th);
	  th->context.ContextFlags = 0;
	}

      if (ResumeThread (th->h) == (DWORD) -1)
	{
	  DWORD err = GetLastError ();
	  OUTMSG (("warning: ResumeThread failed in continue_one_thread, "
		   "(error %d): %s\n", (int) err, strwinerror (err)));
	}
      th->suspended = 0;
    }

  return 0;
}

static BOOL
child_continue (DWORD continue_status, int thread_id)
{
  /* The inferior will only continue after the ContinueDebugEvent
     call.  */
  find_inferior (&all_threads, continue_one_thread, &thread_id);
  faked_breakpoint = 0;

  if (!ContinueDebugEvent (current_event.dwProcessId,
			   current_event.dwThreadId,
			   continue_status))
    return FALSE;

  return TRUE;
}

/* Fetch register(s) from the current thread context.  */
static void
child_fetch_inferior_registers (struct regcache *regcache, int r)
{
  int regno;
  win32_thread_info *th = thread_rec (current_inferior_ptid (), TRUE);
  if (r == -1 || r > NUM_REGS)
    child_fetch_inferior_registers (regcache, NUM_REGS);
  else
    for (regno = 0; regno < r; regno++)
      (*the_low_target.fetch_inferior_register) (regcache, th, regno);
}

/* Store a new register value into the current thread context.  We don't
   change the program's context until later, when we resume it.  */
static void
child_store_inferior_registers (struct regcache *regcache, int r)
{
  int regno;
  win32_thread_info *th = thread_rec (current_inferior_ptid (), TRUE);
  if (r == -1 || r == 0 || r > NUM_REGS)
    child_store_inferior_registers (regcache, NUM_REGS);
  else
    for (regno = 0; regno < r; regno++)
      (*the_low_target.store_inferior_register) (regcache, th, regno);
}

/* Map the Windows error number in ERROR to a locale-dependent error
   message string and return a pointer to it.  Typically, the values
   for ERROR come from GetLastError.

   The string pointed to shall not be modified by the application,
   but may be overwritten by a subsequent call to strwinerror

   The strwinerror function does not change the current setting
   of GetLastError.  */

char *
strwinerror (DWORD error)
{
  static char buf[1024];
  TCHAR *msgbuf;
  DWORD lasterr = GetLastError ();
  DWORD chars = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM
			       | FORMAT_MESSAGE_ALLOCATE_BUFFER,
			       NULL,
			       error,
			       0, /* Default language */
			       (LPVOID)&msgbuf,
			       0,
			       NULL);
  if (chars != 0)
    {
      /* If there is an \r\n appended, zap it.  */
      if (chars >= 2
	  && msgbuf[chars - 2] == '\r'
	  && msgbuf[chars - 1] == '\n')
	{
	  chars -= 2;
	  msgbuf[chars] = 0;
	}

      if (chars > ((COUNTOF (buf)) - 1))
	{
	  chars = COUNTOF (buf) - 1;
	  msgbuf [chars] = 0;
	}

#ifdef UNICODE
      wcstombs (buf, msgbuf, chars + 1);
#else
      strncpy (buf, msgbuf, chars + 1);
#endif
      LocalFree (msgbuf);
    }
  else
    sprintf (buf, "unknown win32 error (%u)", (unsigned) error);

  SetLastError (lasterr);
  return buf;
}

static BOOL
create_process (const char *program, char *args,
		DWORD flags, PROCESS_INFORMATION *pi)
{
  BOOL ret;

#ifdef _WIN32_WCE
  wchar_t *p, *wprogram, *wargs;
  size_t argslen;

  wprogram = alloca ((strlen (program) + 1) * sizeof (wchar_t));
  mbstowcs (wprogram, program, strlen (program) + 1);

  for (p = wprogram; *p; ++p)
    if (L'/' == *p)
      *p = L'\\';

  argslen = strlen (args);
  wargs = alloca ((argslen + 1) * sizeof (wchar_t));
  mbstowcs (wargs, args, argslen + 1);

  ret = CreateProcessW (wprogram, /* image name */
			wargs,    /* command line */
			NULL,     /* security, not supported */
			NULL,     /* thread, not supported */
			FALSE,    /* inherit handles, not supported */
			flags,    /* start flags */
			NULL,     /* environment, not supported */
			NULL,     /* current directory, not supported */
			NULL,     /* start info, not supported */
			pi);      /* proc info */
#else
  STARTUPINFOA si = { sizeof (STARTUPINFOA) };

  ret = CreateProcessA (program,  /* image name */
			args,     /* command line */
			NULL,     /* security */
			NULL,     /* thread */
			TRUE,     /* inherit handles */
			flags,    /* start flags */
			NULL,     /* environment */
			NULL,     /* current directory */
			&si,      /* start info */
			pi);      /* proc info */
#endif

  return ret;
}

/* Start a new process.
   PROGRAM is a path to the program to execute.
   ARGS is a standard NULL-terminated array of arguments,
   to be passed to the inferior as ``argv''.
   Returns the new PID on success, -1 on failure.  Registers the new
   process with the process list.  */
static int
win32_create_inferior (char *program, char **program_args)
{
#ifndef USE_WIN32API
  char real_path[PATH_MAX];
  char *orig_path, *new_path, *path_ptr;
#endif
  BOOL ret;
  DWORD flags;
  char *args;
  int argslen;
  int argc;
  PROCESS_INFORMATION pi;
  DWORD err;

  /* win32_wait needs to know we're not attaching.  */
  attaching = 0;

  if (!program)
    error ("No executable specified, specify executable to debug.\n");

  flags = DEBUG_PROCESS | DEBUG_ONLY_THIS_PROCESS;

#ifndef USE_WIN32API
  orig_path = NULL;
  path_ptr = getenv ("PATH");
  if (path_ptr)
    {
      int size = cygwin_conv_path_list (CCP_POSIX_TO_WIN_A, path_ptr, NULL, 0);
      orig_path = alloca (strlen (path_ptr) + 1);
      new_path = alloca (size);
      strcpy (orig_path, path_ptr);
      cygwin_conv_path_list (CCP_POSIX_TO_WIN_A, path_ptr, new_path, size);
      setenv ("PATH", new_path, 1);
     }
  cygwin_conv_path (CCP_POSIX_TO_WIN_A, program, real_path, PATH_MAX);
  program = real_path;
#endif

  argslen = 1;
  for (argc = 1; program_args[argc]; argc++)
    argslen += strlen (program_args[argc]) + 1;
  args = alloca (argslen);
  args[0] = '\0';
  for (argc = 1; program_args[argc]; argc++)
    {
      /* FIXME: Can we do better about quoting?  How does Cygwin
	 handle this?  */
      strcat (args, " ");
      strcat (args, program_args[argc]);
    }
  OUTMSG2 (("Command line is \"%s\"\n", args));

#ifdef CREATE_NEW_PROCESS_GROUP
  flags |= CREATE_NEW_PROCESS_GROUP;
#endif

  ret = create_process (program, args, flags, &pi);
  err = GetLastError ();
  if (!ret && err == ERROR_FILE_NOT_FOUND)
    {
      char *exename = alloca (strlen (program) + 5);
      strcat (strcpy (exename, program), ".exe");
      ret = create_process (exename, args, flags, &pi);
      err = GetLastError ();
    }

#ifndef USE_WIN32API
  if (orig_path)
    setenv ("PATH", orig_path, 1);
#endif

  if (!ret)
    {
      error ("Error creating process \"%s%s\", (error %d): %s\n",
	     program, args, (int) err, strwinerror (err));
    }
  else
    {
      OUTMSG2 (("Process created: %s\n", (char *) args));
    }

#ifndef _WIN32_WCE
  /* On Windows CE this handle can't be closed.  The OS reuses
     it in the debug events, while the 9x/NT versions of Windows
     probably use a DuplicateHandle'd one.  */
  CloseHandle (pi.hThread);
#endif

  do_initial_child_stuff (pi.hProcess, pi.dwProcessId, 0);

  return current_process_id;
}

/* Attach to a running process.
   PID is the process ID to attach to, specified by the user
   or a higher layer.  */
static int
win32_attach (unsigned long pid)
{
  HANDLE h;
  winapi_DebugSetProcessKillOnExit DebugSetProcessKillOnExit = NULL;
  DWORD err;
#ifdef _WIN32_WCE
  HMODULE dll = GetModuleHandle (_T("COREDLL.DLL"));
#else
  HMODULE dll = GetModuleHandle (_T("KERNEL32.DLL"));
#endif
  DebugSetProcessKillOnExit = GETPROCADDRESS (dll, DebugSetProcessKillOnExit);

  h = OpenProcess (PROCESS_ALL_ACCESS, FALSE, pid);
  if (h != NULL)
    {
      if (DebugActiveProcess (pid))
	{
	  if (DebugSetProcessKillOnExit != NULL)
	    DebugSetProcessKillOnExit (FALSE);

	  /* win32_wait needs to know we're attaching.  */
	  attaching = 1;
	  do_initial_child_stuff (h, pid, 1);
	  return 0;
	}

      CloseHandle (h);
    }

  err = GetLastError ();
  error ("Attach to process failed (error %d): %s\n",
	 (int) err, strwinerror (err));
}

/* Handle OUTPUT_DEBUG_STRING_EVENT from child process.  */
static void
handle_output_debug_string (struct target_waitstatus *ourstatus)
{
#define READ_BUFFER_LEN 1024
  CORE_ADDR addr;
  char s[READ_BUFFER_LEN + 1] = { 0 };
  DWORD nbytes = current_event.u.DebugString.nDebugStringLength;

  if (nbytes == 0)
    return;

  if (nbytes > READ_BUFFER_LEN)
    nbytes = READ_BUFFER_LEN;

  addr = (CORE_ADDR) (size_t) current_event.u.DebugString.lpDebugStringData;

  if (current_event.u.DebugString.fUnicode)
    {
      /* The event tells us how many bytes, not chars, even
	 in Unicode.  */
      WCHAR buffer[(READ_BUFFER_LEN + 1) / sizeof (WCHAR)] = { 0 };
      if (read_inferior_memory (addr, (unsigned char *) buffer, nbytes) != 0)
	return;
      wcstombs (s, buffer, (nbytes + 1) / sizeof (WCHAR));
    }
  else
    {
      if (read_inferior_memory (addr, (unsigned char *) s, nbytes) != 0)
	return;
    }

  if (strncmp (s, "cYg", 3) != 0)
    {
      if (!server_waiting)
	{
	  OUTMSG2(("%s", s));
	  return;
	}

      monitor_output (s);
    }
#undef READ_BUFFER_LEN
}

static void
win32_clear_inferiors (void)
{
  if (current_process_handle != NULL)
    CloseHandle (current_process_handle);

  for_each_inferior (&all_threads, delete_thread_info);
  clear_inferiors ();
}

/* Kill all inferiors.  */
static int
win32_kill (int pid)
{
  struct process_info *process;

  if (current_process_handle == NULL)
    return -1;

  TerminateProcess (current_process_handle, 0);
  for (;;)
    {
      if (!child_continue (DBG_CONTINUE, -1))
	break;
      if (!WaitForDebugEvent (&current_event, INFINITE))
	break;
      if (current_event.dwDebugEventCode == EXIT_PROCESS_DEBUG_EVENT)
	break;
      else if (current_event.dwDebugEventCode == OUTPUT_DEBUG_STRING_EVENT)
	{
	  struct target_waitstatus our_status = { 0 };
	  handle_output_debug_string (&our_status);
	}
    }

  win32_clear_inferiors ();

  process = find_process_pid (pid);
  remove_process (process);
  return 0;
}

/* Detach from inferior PID.  */
static int
win32_detach (int pid)
{
  struct process_info *process;
  winapi_DebugActiveProcessStop DebugActiveProcessStop = NULL;
  winapi_DebugSetProcessKillOnExit DebugSetProcessKillOnExit = NULL;
#ifdef _WIN32_WCE
  HMODULE dll = GetModuleHandle (_T("COREDLL.DLL"));
#else
  HMODULE dll = GetModuleHandle (_T("KERNEL32.DLL"));
#endif
  DebugActiveProcessStop = GETPROCADDRESS (dll, DebugActiveProcessStop);
  DebugSetProcessKillOnExit = GETPROCADDRESS (dll, DebugSetProcessKillOnExit);

  if (DebugSetProcessKillOnExit == NULL
      || DebugActiveProcessStop == NULL)
    return -1;

  {
    struct thread_resume resume;
    resume.thread = minus_one_ptid;
    resume.kind = resume_continue;
    resume.sig = 0;
    win32_resume (&resume, 1);
  }

  if (!DebugActiveProcessStop (current_process_id))
    return -1;

  DebugSetProcessKillOnExit (FALSE);
  process = find_process_pid (pid);
  remove_process (process);

  win32_clear_inferiors ();
  return 0;
}

static void
win32_mourn (struct process_info *process)
{
  remove_process (process);
}

/* Wait for inferiors to end.  */
static void
win32_join (int pid)
{
  HANDLE h = OpenProcess (PROCESS_ALL_ACCESS, FALSE, pid);
  if (h != NULL)
    {
      WaitForSingleObject (h, INFINITE);
      CloseHandle (h);
    }
}

/* Return 1 iff the thread with thread ID TID is alive.  */
static int
win32_thread_alive (ptid_t ptid)
{
  int res;

  /* Our thread list is reliable; don't bother to poll target
     threads.  */
  if (find_inferior_id (&all_threads, ptid) != NULL)
    res = 1;
  else
    res = 0;
  return res;
}

/* Resume the inferior process.  RESUME_INFO describes how we want
   to resume.  */
static void
win32_resume (struct thread_resume *resume_info, size_t n)
{
  DWORD tid;
  enum gdb_signal sig;
  int step;
  win32_thread_info *th;
  DWORD continue_status = DBG_CONTINUE;
  ptid_t ptid;

  /* This handles the very limited set of resume packets that GDB can
     currently produce.  */

  if (n == 1 && ptid_equal (resume_info[0].thread, minus_one_ptid))
    tid = -1;
  else if (n > 1)
    tid = -1;
  else
    /* Yes, we're ignoring resume_info[0].thread.  It'd be tricky to make
       the Windows resume code do the right thing for thread switching.  */
    tid = current_event.dwThreadId;

  if (!ptid_equal (resume_info[0].thread, minus_one_ptid))
    {
      sig = resume_info[0].sig;
      step = resume_info[0].kind == resume_step;
    }
  else
    {
      sig = 0;
      step = 0;
    }

  if (sig != GDB_SIGNAL_0)
    {
      if (current_event.dwDebugEventCode != EXCEPTION_DEBUG_EVENT)
	{
	  OUTMSG (("Cannot continue with signal %d here.\n", sig));
	}
      else if (sig == last_sig)
	continue_status = DBG_EXCEPTION_NOT_HANDLED;
      else
	OUTMSG (("Can only continue with recieved signal %d.\n", last_sig));
    }

  last_sig = GDB_SIGNAL_0;

  /* Get context for the currently selected thread.  */
  ptid = debug_event_ptid (&current_event);
  th = thread_rec (ptid, FALSE);
  if (th)
    {
      if (th->context.ContextFlags)
	{
	  /* Move register values from the inferior into the thread
	     context structure.  */
	  regcache_invalidate ();

	  if (step)
	    {
	      if (the_low_target.single_step != NULL)
		(*the_low_target.single_step) (th);
	      else
		error ("Single stepping is not supported "
		       "in this configuration.\n");
	    }

	  win32_set_thread_context (th);
	  th->context.ContextFlags = 0;
	}
    }

  /* Allow continuing with the same signal that interrupted us.
     Otherwise complain.  */

  child_continue (continue_status, tid);
}

static void
win32_add_one_solib (const char *name, CORE_ADDR load_addr)
{
  char buf[MAX_PATH + 1];
  char buf2[MAX_PATH + 1];

#ifdef _WIN32_WCE
  WIN32_FIND_DATA w32_fd;
  WCHAR wname[MAX_PATH + 1];
  mbstowcs (wname, name, MAX_PATH);
  HANDLE h = FindFirstFile (wname, &w32_fd);
#else
  WIN32_FIND_DATAA w32_fd;
  HANDLE h = FindFirstFileA (name, &w32_fd);
#endif

  if (h == INVALID_HANDLE_VALUE)
    strcpy (buf, name);
  else
    {
      FindClose (h);
      strcpy (buf, name);
#ifndef _WIN32_WCE
      {
	char cwd[MAX_PATH + 1];
	char *p;
	if (GetCurrentDirectoryA (MAX_PATH + 1, cwd))
	  {
	    p = strrchr (buf, '\\');
	    if (p)
	      p[1] = '\0';
	    SetCurrentDirectoryA (buf);
	    GetFullPathNameA (w32_fd.cFileName, MAX_PATH, buf, &p);
	    SetCurrentDirectoryA (cwd);
	  }
      }
#endif
    }

#ifndef _WIN32_WCE
  if (strcasecmp (buf, "ntdll.dll") == 0)
    {
      GetSystemDirectoryA (buf, sizeof (buf));
      strcat (buf, "\\ntdll.dll");
    }
#endif

#ifdef __CYGWIN__
  cygwin_conv_path (CCP_WIN_A_TO_POSIX, buf, buf2, sizeof (buf2));
#else
  strcpy (buf2, buf);
#endif

  loaded_dll (buf2, load_addr);
}

static char *
get_image_name (HANDLE h, void *address, int unicode)
{
  static char buf[(2 * MAX_PATH) + 1];
  DWORD size = unicode ? sizeof (WCHAR) : sizeof (char);
  char *address_ptr;
  int len = 0;
  char b[2];
  SIZE_T done;

  /* Attempt to read the name of the dll that was detected.
     This is documented to work only when actively debugging
     a program.  It will not work for attached processes. */
  if (address == NULL)
    return NULL;

#ifdef _WIN32_WCE
  /* Windows CE reports the address of the image name,
     instead of an address of a pointer into the image name.  */
  address_ptr = address;
#else
  /* See if we could read the address of a string, and that the
     address isn't null. */
  if (!ReadProcessMemory (h, address,  &address_ptr,
			  sizeof (address_ptr), &done)
      || done != sizeof (address_ptr)
      || !address_ptr)
    return NULL;
#endif

  /* Find the length of the string */
  while (ReadProcessMemory (h, address_ptr + len++ * size, &b, size, &done)
	 && (b[0] != 0 || b[size - 1] != 0) && done == size)
    continue;

  if (!unicode)
    ReadProcessMemory (h, address_ptr, buf, len, &done);
  else
    {
      WCHAR *unicode_address = (WCHAR *) alloca (len * sizeof (WCHAR));
      ReadProcessMemory (h, address_ptr, unicode_address, len * sizeof (WCHAR),
			 &done);

      WideCharToMultiByte (CP_ACP, 0, unicode_address, len, buf, len, 0, 0);
    }

  return buf;
}

typedef BOOL (WINAPI *winapi_EnumProcessModules) (HANDLE, HMODULE *,
						  DWORD, LPDWORD);
typedef BOOL (WINAPI *winapi_GetModuleInformation) (HANDLE, HMODULE,
						    LPMODULEINFO, DWORD);
typedef DWORD (WINAPI *winapi_GetModuleFileNameExA) (HANDLE, HMODULE,
						     LPSTR, DWORD);

static winapi_EnumProcessModules win32_EnumProcessModules;
static winapi_GetModuleInformation win32_GetModuleInformation;
static winapi_GetModuleFileNameExA win32_GetModuleFileNameExA;

static BOOL
load_psapi (void)
{
  static int psapi_loaded = 0;
  static HMODULE dll = NULL;

  if (!psapi_loaded)
    {
      psapi_loaded = 1;
      dll = LoadLibrary (TEXT("psapi.dll"));
      if (!dll)
	return FALSE;
      win32_EnumProcessModules =
	      GETPROCADDRESS (dll, EnumProcessModules);
      win32_GetModuleInformation =
	      GETPROCADDRESS (dll, GetModuleInformation);
      win32_GetModuleFileNameExA =
	      GETPROCADDRESS (dll, GetModuleFileNameExA);
    }

  return (win32_EnumProcessModules != NULL
	  && win32_GetModuleInformation != NULL
	  && win32_GetModuleFileNameExA != NULL);
}

static int
psapi_get_dll_name (LPVOID BaseAddress, char *dll_name_ret)
{
  DWORD len;
  MODULEINFO mi;
  size_t i;
  HMODULE dh_buf[1];
  HMODULE *DllHandle = dh_buf;
  DWORD cbNeeded;
  BOOL ok;

  if (!load_psapi ())
    goto failed;

  cbNeeded = 0;
  ok = (*win32_EnumProcessModules) (current_process_handle,
				    DllHandle,
				    sizeof (HMODULE),
				    &cbNeeded);

  if (!ok || !cbNeeded)
    goto failed;

  DllHandle = (HMODULE *) alloca (cbNeeded);
  if (!DllHandle)
    goto failed;

  ok = (*win32_EnumProcessModules) (current_process_handle,
				    DllHandle,
				    cbNeeded,
				    &cbNeeded);
  if (!ok)
    goto failed;

  for (i = 0; i < ((size_t) cbNeeded / sizeof (HMODULE)); i++)
    {
      if (!(*win32_GetModuleInformation) (current_process_handle,
					  DllHandle[i],
					  &mi,
					  sizeof (mi)))
	{
	  DWORD err = GetLastError ();
	  error ("Can't get module info: (error %d): %s\n",
		 (int) err, strwinerror (err));
	}

      if (mi.lpBaseOfDll == BaseAddress)
	{
	  len = (*win32_GetModuleFileNameExA) (current_process_handle,
					       DllHandle[i],
					       dll_name_ret,
					       MAX_PATH);
	  if (len == 0)
	    {
	      DWORD err = GetLastError ();
	      error ("Error getting dll name: (error %d): %s\n",
		     (int) err, strwinerror (err));
	    }
	  return 1;
	}
    }

failed:
  dll_name_ret[0] = '\0';
  return 0;
}

typedef HANDLE (WINAPI *winapi_CreateToolhelp32Snapshot) (DWORD, DWORD);
typedef BOOL (WINAPI *winapi_Module32First) (HANDLE, LPMODULEENTRY32);
typedef BOOL (WINAPI *winapi_Module32Next) (HANDLE, LPMODULEENTRY32);

static winapi_CreateToolhelp32Snapshot win32_CreateToolhelp32Snapshot;
static winapi_Module32First win32_Module32First;
static winapi_Module32Next win32_Module32Next;
#ifdef _WIN32_WCE
typedef BOOL (WINAPI *winapi_CloseToolhelp32Snapshot) (HANDLE);
static winapi_CloseToolhelp32Snapshot win32_CloseToolhelp32Snapshot;
#endif

static BOOL
load_toolhelp (void)
{
  static int toolhelp_loaded = 0;
  static HMODULE dll = NULL;

  if (!toolhelp_loaded)
    {
      toolhelp_loaded = 1;
#ifndef _WIN32_WCE
      dll = GetModuleHandle (_T("KERNEL32.DLL"));
#else
      dll = LoadLibrary (L"TOOLHELP.DLL");
#endif
      if (!dll)
	return FALSE;

      win32_CreateToolhelp32Snapshot =
	GETPROCADDRESS (dll, CreateToolhelp32Snapshot);
      win32_Module32First = GETPROCADDRESS (dll, Module32First);
      win32_Module32Next = GETPROCADDRESS (dll, Module32Next);
#ifdef _WIN32_WCE
      win32_CloseToolhelp32Snapshot =
	GETPROCADDRESS (dll, CloseToolhelp32Snapshot);
#endif
    }

  return (win32_CreateToolhelp32Snapshot != NULL
	  && win32_Module32First != NULL
	  && win32_Module32Next != NULL
#ifdef _WIN32_WCE
	  && win32_CloseToolhelp32Snapshot != NULL
#endif
	  );
}

static int
toolhelp_get_dll_name (LPVOID BaseAddress, char *dll_name_ret)
{
  HANDLE snapshot_module;
  MODULEENTRY32 modEntry = { sizeof (MODULEENTRY32) };
  int found = 0;

  if (!load_toolhelp ())
    return 0;

  snapshot_module = win32_CreateToolhelp32Snapshot (TH32CS_SNAPMODULE,
						    current_event.dwProcessId);
  if (snapshot_module == INVALID_HANDLE_VALUE)
    return 0;

  /* Ignore the first module, which is the exe.  */
  if (win32_Module32First (snapshot_module, &modEntry))
    while (win32_Module32Next (snapshot_module, &modEntry))
      if (modEntry.modBaseAddr == BaseAddress)
	{
#ifdef UNICODE
	  wcstombs (dll_name_ret, modEntry.szExePath, MAX_PATH + 1);
#else
	  strcpy (dll_name_ret, modEntry.szExePath);
#endif
	  found = 1;
	  break;
	}

#ifdef _WIN32_WCE
  win32_CloseToolhelp32Snapshot (snapshot_module);
#else
  CloseHandle (snapshot_module);
#endif
  return found;
}

static void
handle_load_dll (void)
{
  LOAD_DLL_DEBUG_INFO *event = &current_event.u.LoadDll;
  char dll_buf[MAX_PATH + 1];
  char *dll_name = NULL;
  CORE_ADDR load_addr;

  dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';

  /* Windows does not report the image name of the dlls in the debug
     event on attaches.  We resort to iterating over the list of
     loaded dlls looking for a match by image base.  */
  if (!psapi_get_dll_name (event->lpBaseOfDll, dll_buf))
    {
      if (!server_waiting)
	/* On some versions of Windows and Windows CE, we can't create
	   toolhelp snapshots while the inferior is stopped in a
	   LOAD_DLL_DEBUG_EVENT due to a dll load, but we can while
	   Windows is reporting the already loaded dlls.  */
	toolhelp_get_dll_name (event->lpBaseOfDll, dll_buf);
    }

  dll_name = dll_buf;

  if (*dll_name == '\0')
    dll_name = get_image_name (current_process_handle,
			       event->lpImageName, event->fUnicode);
  if (!dll_name)
    return;

  /* The symbols in a dll are offset by 0x1000, which is the
     offset from 0 of the first byte in an image - because
     of the file header and the section alignment. */

  load_addr = (CORE_ADDR) (uintptr_t) event->lpBaseOfDll + 0x1000;
  win32_add_one_solib (dll_name, load_addr);
}

static void
handle_unload_dll (void)
{
  CORE_ADDR load_addr =
	  (CORE_ADDR) (uintptr_t) current_event.u.UnloadDll.lpBaseOfDll;
  load_addr += 0x1000;
  unloaded_dll (NULL, load_addr);
}

static void
handle_exception (struct target_waitstatus *ourstatus)
{
  DWORD code = current_event.u.Exception.ExceptionRecord.ExceptionCode;

  ourstatus->kind = TARGET_WAITKIND_STOPPED;

  switch (code)
    {
    case EXCEPTION_ACCESS_VIOLATION:
      OUTMSG2 (("EXCEPTION_ACCESS_VIOLATION"));
      ourstatus->value.sig = GDB_SIGNAL_SEGV;
      break;
    case STATUS_STACK_OVERFLOW:
      OUTMSG2 (("STATUS_STACK_OVERFLOW"));
      ourstatus->value.sig = GDB_SIGNAL_SEGV;
      break;
    case STATUS_FLOAT_DENORMAL_OPERAND:
      OUTMSG2 (("STATUS_FLOAT_DENORMAL_OPERAND"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
      OUTMSG2 (("EXCEPTION_ARRAY_BOUNDS_EXCEEDED"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INEXACT_RESULT:
      OUTMSG2 (("STATUS_FLOAT_INEXACT_RESULT"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_INVALID_OPERATION:
      OUTMSG2 (("STATUS_FLOAT_INVALID_OPERATION"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_OVERFLOW:
      OUTMSG2 (("STATUS_FLOAT_OVERFLOW"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_STACK_CHECK:
      OUTMSG2 (("STATUS_FLOAT_STACK_CHECK"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_UNDERFLOW:
      OUTMSG2 (("STATUS_FLOAT_UNDERFLOW"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_FLOAT_DIVIDE_BY_ZERO:
      OUTMSG2 (("STATUS_FLOAT_DIVIDE_BY_ZERO"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_DIVIDE_BY_ZERO:
      OUTMSG2 (("STATUS_INTEGER_DIVIDE_BY_ZERO"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case STATUS_INTEGER_OVERFLOW:
      OUTMSG2 (("STATUS_INTEGER_OVERFLOW"));
      ourstatus->value.sig = GDB_SIGNAL_FPE;
      break;
    case EXCEPTION_BREAKPOINT:
      OUTMSG2 (("EXCEPTION_BREAKPOINT"));
      ourstatus->value.sig = GDB_SIGNAL_TRAP;
#ifdef _WIN32_WCE
      /* Remove the initial breakpoint.  */
      check_breakpoints ((CORE_ADDR) (long) current_event
			 .u.Exception.ExceptionRecord.ExceptionAddress);
#endif
      break;
    case DBG_CONTROL_C:
      OUTMSG2 (("DBG_CONTROL_C"));
      ourstatus->value.sig = GDB_SIGNAL_INT;
      break;
    case DBG_CONTROL_BREAK:
      OUTMSG2 (("DBG_CONTROL_BREAK"));
      ourstatus->value.sig = GDB_SIGNAL_INT;
      break;
    case EXCEPTION_SINGLE_STEP:
      OUTMSG2 (("EXCEPTION_SINGLE_STEP"));
      ourstatus->value.sig = GDB_SIGNAL_TRAP;
      break;
    case EXCEPTION_ILLEGAL_INSTRUCTION:
      OUTMSG2 (("EXCEPTION_ILLEGAL_INSTRUCTION"));
      ourstatus->value.sig = GDB_SIGNAL_ILL;
      break;
    case EXCEPTION_PRIV_INSTRUCTION:
      OUTMSG2 (("EXCEPTION_PRIV_INSTRUCTION"));
      ourstatus->value.sig = GDB_SIGNAL_ILL;
      break;
    case EXCEPTION_NONCONTINUABLE_EXCEPTION:
      OUTMSG2 (("EXCEPTION_NONCONTINUABLE_EXCEPTION"));
      ourstatus->value.sig = GDB_SIGNAL_ILL;
      break;
    default:
      if (current_event.u.Exception.dwFirstChance)
	{
	  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;
	  return;
	}
      OUTMSG2 (("gdbserver: unknown target exception 0x%08x at 0x%s",
	    (unsigned) current_event.u.Exception.ExceptionRecord.ExceptionCode,
	    phex_nz ((uintptr_t) current_event.u.Exception.ExceptionRecord.
	    ExceptionAddress, sizeof (uintptr_t))));
      ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;
      break;
    }
  OUTMSG2 (("\n"));
  last_sig = ourstatus->value.sig;
}


static void
suspend_one_thread (struct inferior_list_entry *entry)
{
  struct thread_info *thread = (struct thread_info *) entry;
  win32_thread_info *th = inferior_target_data (thread);

  if (!th->suspended)
    {
      if (SuspendThread (th->h) == (DWORD) -1)
	{
	  DWORD err = GetLastError ();
	  OUTMSG (("warning: SuspendThread failed in suspend_one_thread, "
		   "(error %d): %s\n", (int) err, strwinerror (err)));
	}
      else
	th->suspended = 1;
    }
}

static void
fake_breakpoint_event (void)
{
  OUTMSG2(("fake_breakpoint_event\n"));

  faked_breakpoint = 1;

  memset (&current_event, 0, sizeof (current_event));
  current_event.dwThreadId = main_thread_id;
  current_event.dwDebugEventCode = EXCEPTION_DEBUG_EVENT;
  current_event.u.Exception.ExceptionRecord.ExceptionCode
    = EXCEPTION_BREAKPOINT;

  for_each_inferior (&all_threads, suspend_one_thread);
}

#ifdef _WIN32_WCE
static int
auto_delete_breakpoint (CORE_ADDR stop_pc)
{
  return 1;
}
#endif

/* Get the next event from the child.  */

static int
get_child_debug_event (struct target_waitstatus *ourstatus)
{
  ptid_t ptid;

  last_sig = GDB_SIGNAL_0;
  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;

  /* Check if GDB sent us an interrupt request.  */
  check_remote_input_interrupt_request ();

  if (soft_interrupt_requested)
    {
      soft_interrupt_requested = 0;
      fake_breakpoint_event ();
      goto gotevent;
    }

#ifndef _WIN32_WCE
  attaching = 0;
#else
  if (attaching)
    {
      /* WinCE doesn't set an initial breakpoint automatically.  To
	 stop the inferior, we flush all currently pending debug
	 events -- the thread list and the dll list are always
	 reported immediatelly without delay, then, we suspend all
	 threads and pretend we saw a trap at the current PC of the
	 main thread.

	 Contrary to desktop Windows, Windows CE *does* report the dll
	 names on LOAD_DLL_DEBUG_EVENTs resulting from a
	 DebugActiveProcess call.  This limits the way we can detect
	 if all the dlls have already been reported.  If we get a real
	 debug event before leaving attaching, the worst that will
	 happen is the user will see a spurious breakpoint.  */

      current_event.dwDebugEventCode = 0;
      if (!WaitForDebugEvent (&current_event, 0))
	{
	  OUTMSG2(("no attach events left\n"));
	  fake_breakpoint_event ();
	  attaching = 0;
	}
      else
	OUTMSG2(("got attach event\n"));
    }
  else
#endif
    {
      /* Keep the wait time low enough for confortable remote
	 interruption, but high enough so gdbserver doesn't become a
	 bottleneck.  */
      if (!WaitForDebugEvent (&current_event, 250))
        {
	  DWORD e  = GetLastError();

	  if (e == ERROR_PIPE_NOT_CONNECTED)
	    {
	      /* This will happen if the loader fails to succesfully
		 load the application, e.g., if the main executable
		 tries to pull in a non-existing export from a
		 DLL.  */
	      ourstatus->kind = TARGET_WAITKIND_EXITED;
	      ourstatus->value.integer = 1;
	      return 1;
	    }

	  return 0;
        }
    }

 gotevent:

  switch (current_event.dwDebugEventCode)
    {
    case CREATE_THREAD_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event CREATE_THREAD_DEBUG_EVENT "
		"for pid=%u tid=%x)\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));

      /* Record the existence of this thread.  */
      child_add_thread (current_event.dwProcessId,
			current_event.dwThreadId,
			current_event.u.CreateThread.hThread,
			current_event.u.CreateThread.lpThreadLocalBase);
      break;

    case EXIT_THREAD_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event EXIT_THREAD_DEBUG_EVENT "
		"for pid=%u tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      child_delete_thread (current_event.dwProcessId,
			   current_event.dwThreadId);

      current_inferior = (struct thread_info *) all_threads.head;
      return 1;

    case CREATE_PROCESS_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event CREATE_PROCESS_DEBUG_EVENT "
		"for pid=%u tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      CloseHandle (current_event.u.CreateProcessInfo.hFile);

      current_process_handle = current_event.u.CreateProcessInfo.hProcess;
      main_thread_id = current_event.dwThreadId;

      ourstatus->kind = TARGET_WAITKIND_EXECD;
      ourstatus->value.execd_pathname = "Main executable";

      /* Add the main thread.  */
      child_add_thread (current_event.dwProcessId,
			main_thread_id,
			current_event.u.CreateProcessInfo.hThread,
			current_event.u.CreateProcessInfo.lpThreadLocalBase);

      ourstatus->value.related_pid = debug_event_ptid (&current_event);
#ifdef _WIN32_WCE
      if (!attaching)
	{
	  /* Windows CE doesn't set the initial breakpoint
	     automatically like the desktop versions of Windows do.
	     We add it explicitly here.	 It will be removed as soon as
	     it is hit.	 */
	  set_breakpoint_at ((CORE_ADDR) (long) current_event.u
			     .CreateProcessInfo.lpStartAddress,
			     auto_delete_breakpoint);
	}
#endif
      break;

    case EXIT_PROCESS_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event EXIT_PROCESS_DEBUG_EVENT "
		"for pid=%u tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      ourstatus->kind = TARGET_WAITKIND_EXITED;
      ourstatus->value.integer = current_event.u.ExitProcess.dwExitCode;
      child_continue (DBG_CONTINUE, -1);
      CloseHandle (current_process_handle);
      current_process_handle = NULL;
      break;

    case LOAD_DLL_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event LOAD_DLL_DEBUG_EVENT "
		"for pid=%u tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      CloseHandle (current_event.u.LoadDll.hFile);
      handle_load_dll ();

      ourstatus->kind = TARGET_WAITKIND_LOADED;
      ourstatus->value.sig = GDB_SIGNAL_TRAP;
      break;

    case UNLOAD_DLL_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event UNLOAD_DLL_DEBUG_EVENT "
		"for pid=%u tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      handle_unload_dll ();
      ourstatus->kind = TARGET_WAITKIND_LOADED;
      ourstatus->value.sig = GDB_SIGNAL_TRAP;
      break;

    case EXCEPTION_DEBUG_EVENT:
      OUTMSG2 (("gdbserver: kernel event EXCEPTION_DEBUG_EVENT "
		"for pid=%u tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      handle_exception (ourstatus);
      break;

    case OUTPUT_DEBUG_STRING_EVENT:
      /* A message from the kernel (or Cygwin).  */
      OUTMSG2 (("gdbserver: kernel event OUTPUT_DEBUG_STRING_EVENT "
		"for pid=%u tid=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId));
      handle_output_debug_string (ourstatus);
      break;

    default:
      OUTMSG2 (("gdbserver: kernel event unknown "
		"for pid=%u tid=%x code=%x\n",
		(unsigned) current_event.dwProcessId,
		(unsigned) current_event.dwThreadId,
		(unsigned) current_event.dwDebugEventCode));
      break;
    }

  ptid = debug_event_ptid (&current_event);
  current_inferior =
    (struct thread_info *) find_inferior_id (&all_threads, ptid);
  return 1;
}

/* Wait for the inferior process to change state.
   STATUS will be filled in with a response code to send to GDB.
   Returns the signal which caused the process to stop. */
static ptid_t
win32_wait (ptid_t ptid, struct target_waitstatus *ourstatus, int options)
{
  struct regcache *regcache;

  while (1)
    {
      if (!get_child_debug_event (ourstatus))
	continue;

      switch (ourstatus->kind)
	{
	case TARGET_WAITKIND_EXITED:
	  OUTMSG2 (("Child exited with retcode = %x\n",
		    ourstatus->value.integer));
	  win32_clear_inferiors ();
	  return pid_to_ptid (current_event.dwProcessId);
	case TARGET_WAITKIND_STOPPED:
	case TARGET_WAITKIND_LOADED:
	  OUTMSG2 (("Child Stopped with signal = %d \n",
		    ourstatus->value.sig));

	  regcache = get_thread_regcache (current_inferior, 1);
	  child_fetch_inferior_registers (regcache, -1);

	  if (ourstatus->kind == TARGET_WAITKIND_LOADED
	      && !server_waiting)
	    {
	      /* When gdb connects, we want to be stopped at the
		 initial breakpoint, not in some dll load event.  */
	      child_continue (DBG_CONTINUE, -1);
	      break;
	    }

	  /* We don't expose _LOADED events to gdbserver core.  See
	     the `dlls_changed' global.  */
	  if (ourstatus->kind == TARGET_WAITKIND_LOADED)
	    ourstatus->kind = TARGET_WAITKIND_STOPPED;

	  return debug_event_ptid (&current_event);
	default:
	  OUTMSG (("Ignoring unknown internal event, %d\n", ourstatus->kind));
	  /* fall-through */
	case TARGET_WAITKIND_SPURIOUS:
	case TARGET_WAITKIND_EXECD:
	  /* do nothing, just continue */
	  child_continue (DBG_CONTINUE, -1);
	  break;
	}
    }
}

/* Fetch registers from the inferior process.
   If REGNO is -1, fetch all registers; otherwise, fetch at least REGNO.  */
static void
win32_fetch_inferior_registers (struct regcache *regcache, int regno)
{
  child_fetch_inferior_registers (regcache, regno);
}

/* Store registers to the inferior process.
   If REGNO is -1, store all registers; otherwise, store at least REGNO.  */
static void
win32_store_inferior_registers (struct regcache *regcache, int regno)
{
  child_store_inferior_registers (regcache, regno);
}

/* Read memory from the inferior process.  This should generally be
   called through read_inferior_memory, which handles breakpoint shadowing.
   Read LEN bytes at MEMADDR into a buffer at MYADDR.  */
static int
win32_read_inferior_memory (CORE_ADDR memaddr, unsigned char *myaddr, int len)
{
  return child_xfer_memory (memaddr, (char *) myaddr, len, 0, 0) != len;
}

/* Write memory to the inferior process.  This should generally be
   called through write_inferior_memory, which handles breakpoint shadowing.
   Write LEN bytes from the buffer at MYADDR to MEMADDR.
   Returns 0 on success and errno on failure.  */
static int
win32_write_inferior_memory (CORE_ADDR memaddr, const unsigned char *myaddr,
			     int len)
{
  return child_xfer_memory (memaddr, (char *) myaddr, len, 1, 0) != len;
}

/* Send an interrupt request to the inferior process. */
static void
win32_request_interrupt (void)
{
  winapi_DebugBreakProcess DebugBreakProcess;
  winapi_GenerateConsoleCtrlEvent GenerateConsoleCtrlEvent;

#ifdef _WIN32_WCE
  HMODULE dll = GetModuleHandle (_T("COREDLL.DLL"));
#else
  HMODULE dll = GetModuleHandle (_T("KERNEL32.DLL"));
#endif

  GenerateConsoleCtrlEvent = GETPROCADDRESS (dll, GenerateConsoleCtrlEvent);

  if (GenerateConsoleCtrlEvent != NULL
      && GenerateConsoleCtrlEvent (CTRL_BREAK_EVENT, current_process_id))
    return;

  /* GenerateConsoleCtrlEvent can fail if process id being debugged is
     not a process group id.
     Fallback to XP/Vista 'DebugBreakProcess', which generates a
     breakpoint exception in the interior process.  */

  DebugBreakProcess = GETPROCADDRESS (dll, DebugBreakProcess);

  if (DebugBreakProcess != NULL
      && DebugBreakProcess (current_process_handle))
    return;

  /* Last resort, suspend all threads manually.  */
  soft_interrupt_requested = 1;
}

#ifdef _WIN32_WCE
int
win32_error_to_fileio_error (DWORD err)
{
  switch (err)
    {
    case ERROR_BAD_PATHNAME:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_INVALID_NAME:
    case ERROR_PATH_NOT_FOUND:
      return FILEIO_ENOENT;
    case ERROR_CRC:
    case ERROR_IO_DEVICE:
    case ERROR_OPEN_FAILED:
      return FILEIO_EIO;
    case ERROR_INVALID_HANDLE:
      return FILEIO_EBADF;
    case ERROR_ACCESS_DENIED:
    case ERROR_SHARING_VIOLATION:
      return FILEIO_EACCES;
    case ERROR_NOACCESS:
      return FILEIO_EFAULT;
    case ERROR_BUSY:
      return FILEIO_EBUSY;
    case ERROR_ALREADY_EXISTS:
    case ERROR_FILE_EXISTS:
      return FILEIO_EEXIST;
    case ERROR_BAD_DEVICE:
      return FILEIO_ENODEV;
    case ERROR_DIRECTORY:
      return FILEIO_ENOTDIR;
    case ERROR_FILENAME_EXCED_RANGE:
    case ERROR_INVALID_DATA:
    case ERROR_INVALID_PARAMETER:
    case ERROR_NEGATIVE_SEEK:
      return FILEIO_EINVAL;
    case ERROR_TOO_MANY_OPEN_FILES:
      return FILEIO_EMFILE;
    case ERROR_HANDLE_DISK_FULL:
    case ERROR_DISK_FULL:
      return FILEIO_ENOSPC;
    case ERROR_WRITE_PROTECT:
      return FILEIO_EROFS;
    case ERROR_NOT_SUPPORTED:
      return FILEIO_ENOSYS;
    }

  return FILEIO_EUNKNOWN;
}

static void
wince_hostio_last_error (char *buf)
{
  DWORD winerr = GetLastError ();
  int fileio_err = win32_error_to_fileio_error (winerr);
  sprintf (buf, "F-1,%x", fileio_err);
}
#endif

/* Write Windows OS Thread Information Block address.  */

static int
win32_get_tib_address (ptid_t ptid, CORE_ADDR *addr)
{
  win32_thread_info *th;
  th = thread_rec (ptid, 0);
  if (th == NULL)
    return 0;
  if (addr != NULL)
    *addr = th->thread_local_base;
  return 1;
}

static struct target_ops win32_target_ops = {
  win32_create_inferior,
  win32_attach,
  win32_kill,
  win32_detach,
  win32_mourn,
  win32_join,
  win32_thread_alive,
  win32_resume,
  win32_wait,
  win32_fetch_inferior_registers,
  win32_store_inferior_registers,
  NULL, /* prepare_to_access_memory */
  NULL, /* done_accessing_memory */
  win32_read_inferior_memory,
  win32_write_inferior_memory,
  NULL, /* lookup_symbols */
  win32_request_interrupt,
  NULL, /* read_auxv */
  win32_insert_point,
  win32_remove_point,
  win32_stopped_by_watchpoint,
  win32_stopped_data_address,
  NULL, /* read_offsets */
  NULL, /* get_tls_address */
  NULL, /* qxfer_spu */
#ifdef _WIN32_WCE
  wince_hostio_last_error,
#else
  hostio_last_error_from_errno,
#endif
  NULL, /* qxfer_osdata */
  NULL, /* qxfer_siginfo */
  NULL, /* supports_non_stop */
  NULL, /* async */
  NULL, /* start_non_stop */
  NULL, /* supports_multi_process */
  NULL, /* handle_monitor_command */
  NULL, /* core_of_thread */
  NULL, /* read_loadmap */
  NULL, /* process_qsupported */
  NULL, /* supports_tracepoints */
  NULL, /* read_pc */
  NULL, /* write_pc */
  NULL, /* thread_stopped */
  win32_get_tib_address
};

/* Initialize the Win32 backend.  */
void
initialize_low (void)
{
  set_target_ops (&win32_target_ops);
  if (the_low_target.breakpoint != NULL)
    set_breakpoint_data (the_low_target.breakpoint,
			 the_low_target.breakpoint_len);
  the_low_target.arch_setup ();
}
@


1.68
log
@[gdbserver] Split a new dll.h file out of server.h.

gdb/gdbserver/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* dll.c, inferiors.c, remote-utils.c, server.c: Include "dll.h".
	* server.h (struct dll_info, all_dlls, dlls_changed, clear_dlls)
	(loaded_dll, unloaded_dll): Move to ...
	* dll.h: ... this new file.
	* inferiors.c, remote-utils.c, win32-low.c: Include "dll.h".
@
text
@d29 1
@


1.67
log
@	* win32-low.c (child_xfer_memory): Check if ReadProcessMemory
	or WriteProcessMemory complete successfully and handle
	ERROR_PARTIAL_COPY error.
@
text
@d28 1
@


1.66
log
@gdbserver, win32: fix some function typedefs

2013-05-25  Mircea Gherzan  <mircea.gherzan@@intel.com>

gdbserver/
	* win32-low.c (winapi_DebugActiveProcessStop): Move the WINAPI
	attribute inside the parentheses.
	(winapi_DebugSetProcessKillOnExit): Ditto.
	(winapi_DebugBreakProcess): Ditto.
	(winapi_GenerateConsoleCtrlEvent): Ditto.

Change-Id: I3aab72f2a1725a46b9da0e41a4ba08d7886284b9
Signed-off-by: Mircea Gherzan <mircea.gherzan@@intel.com>
@
text
@d281 3
a283 1
  SIZE_T done;
d288 4
a291 2
      WriteProcessMemory (current_process_handle, (LPVOID) addr,
			  (LPCVOID) our, len, &done);
d296 4
a299 2
      ReadProcessMemory (current_process_handle, (LPCVOID) addr, (LPVOID) our,
			 len, &done);
d301 4
a304 1
  return done;
@


1.65
log
@Normalize on PATH_MAX instead of MAXPATHLEN throughout.

With the pathmax gnulib module in place, we can use PATH_MAX
consistently throughout, instead of the current mixbag of PATH_MAX and
MAXPATHLEN uses.  It's no longer necessary to include sys/param.h
(supposedly, I can't check all ports touched here) for MAXPATHLEN.

Don't remove sys/param.h from GDB's configure.ac, as later tests in
the file use HAVE_SYS_PARAM_H checks.

Tested on x86_64 Fedora 17.

Also cross-built for --host=i686-w64-mingw32, and --host=i586-pc-msdosdjgpp.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Include "pathmax.h".
	* utils.c: Don't include sys/param.h.
	(gdb_realpath): Remove code that checks for MAXPATHLEN.
	* solib-ia64-hpux.c (ia64_hpux_handle_load_event): Use PATH_MAX
	instead of MAXPATHLEN.
	* solib-sunos.c: Don't include sys/param.h.
	* xcoffread.c: Don't include sys/param.h.
	* bsd-kvm.c: Don't include sys/param.h.
	* darwin-nat.c: Don't include sys/param.h.
	(darwin_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* darwin-nat-info.c: Don't include sys/param.h.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* i386obsd-nat.c: Don't include sys/param.h.
	* inf-child.c: Don't include sys/param.h.
	(inf_child_fileio_readlink): Use PATH_MAX instead of MAXPATHLEN.
	* linux-fork.c: Don't include sys/param.h.
	(fork_save_infrun_state): Use PATH_MAX instead of MAXPATHLEN.
	* linux-nat.c: Don't include sys/param.h.
	(linux_child_pid_to_exec_file, linux_proc_pending_signals)
	(linux_proc_pending_signals): Use PATH_MAX instead of MAXPATHLEN.
	* m68klinux-nat.c: Don't include sys/param.h.
	* nbsd-nat.c: Don't include sys/param.h.
	(nbsd_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* ppc-linux-nat.c: Don't include sys/param.h.
	* rs6000-nat.c: Don't include sys/param.h.
	* spu-linux-nat.c. Don't include sys/param.h.
	* windows-nat.c: Don't include sys/param.h.
	* xtensa-linux-nat.c: Don't include sys/param.h.
	* config/i386/nm-fbsd.h: Don't include sys/param.h.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* server.h: Include "pathmax.h".
	* linux-low.c: Don't include sys/param.h.
	(linux_pid_exe_is_elf_64_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* win32-low.c: Don't include sys/param.h.
	(win32_create_inferior): Use PATH_MAX instead of MAXPATHLEN.
@
text
@d93 4
a96 4
typedef BOOL WINAPI (*winapi_DebugActiveProcessStop) (DWORD dwProcessId);
typedef BOOL WINAPI (*winapi_DebugSetProcessKillOnExit) (BOOL KillOnExit);
typedef BOOL WINAPI (*winapi_DebugBreakProcess) (HANDLE);
typedef BOOL WINAPI (*winapi_GenerateConsoleCtrlEvent) (DWORD, DWORD);
@


1.64
log
@[GDBserver] Multi-process + multi-arch

This patch makes GDBserver support multi-process + biarch.

Currently, if you're debugging more than one process at once with a
single gdbserver (in extended-remote mode), then all processes must
have the same architecture (e.g., 64-bit vs 32-bit).  Otherwise, you
see this:

Added inferior 2
[Switching to inferior 2 [<null>] (<noexec>)]
Reading symbols from /home/pedro/gdb/tests/main32...done.
Temporary breakpoint 2 at 0x4004cf: main. (2 locations)
Starting program: /home/pedro/gdb/tests/main32
warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64
warning: Architecture rejected target-supplied description
Remote 'g' packet reply is too long: 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090cfffff0000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000b042f7460000000000020000230000002b0000002b0000002b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007f03000000000000ffff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000801f00003b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
... etc, etc ...

Even though the process was running a 32-bit program, GDBserver sent
back to GDB a register set in 64-bit layout.

A patch (http://sourceware.org/ml/gdb-patches/2012-11/msg00228.html) a
while ago made GDB track a target_gdbarch per inferior, and as
consequence, fetch a target description per-inferior.  This patch is
the GDBserver counterpart, that makes GDBserver keep track of each
process'es XML target description and register layout.  So in the
example above, GDBserver will send the correct register set in 32-bit
layout to GDB.

A new "struct target_desc" object (tdesc for short) is added, that
holds the target description and register layout information about
each process.  Each `struct process_info' holds a pointer to a target
description.  The regcache also gains a pointer to a target
description, mainly for convenience, and parallel with GDB (and
possible future support for programs that flip processor modes).

The low target's arch_setup routines are responsible for setting the
process'es correct tdesc.  This isn't that much different to how
things were done before, except that instead of detecting the inferior
process'es architecture and calling the corresponding
init_registers_FOO routine, which would change the regcache layout
globals and recreate the threads' regcaches, the regcache.c globals
are gone, and the init_registers_$BAR routines now each initialize a
separate global struct target_desc object (one for each arch variant
GDBserver supports), and so all the init_registers_$BAR routines that
are built into GDBserver are called early at GDBserver startup time
(similarly to how GDB handles its built-in target descriptions), and
then the arch_setup routine is responsible for making
process_info->tdesc point to one of these target description globals.
The regcache module is all parameterized to get the regcache's layout
from the tdesc object instead of the old register_bytes, etc. globals.

The threads' regcaches are now created lazily.  The old scheme where
we created each of them when we added a new thread doesn't work
anymore, because we add the main thread/lwp before we see it stop for
the first time, and it is only when we see the thread stop for the
first time that we have a chance of determining the inferior's
architecture (through the_low_target.arch_setup).  Therefore when we
add the main thread we don't know which architecture/tdesc its
regcache should have.

This patch makes the gdb.multi/multi-arch.exp test now pass against
(extended-remote) GDBserver.  It currently fails, without this patch.

The IPA also uses the regcache, so it gains a new global struct
target_desc pointer, which points at the description of the process it
is loaded in.

Re. the linux-low.c & friends changes.  Since the register map
etc. may differ between processes (64-bit vs 32-bit) etc., the
linux_target_ops num_regs, regmap and regset_bitmap data fields are no
longer sufficient.  A new method is added in their place that returns
a pointer to a new struct that includes all info linux-low.c needs to
access registers of the current inferior.

The patch/discussion that originally introduced
linux-low.c:disabled_regsets mentions that the disabled_regsets set
may be different per mode (in a biarch setup), and indeed that is
cleared whenever we start a new (first) inferior, so that global is
moved as well behind the new `struct regs_info'.

On the x86 side:

I simply replaced the i387-fp.c:num_xmm_registers global with a check
for 64-bit or 32-bit process, which is equivalent to how the global
was set.  This avoided coming up with some more general mechanism that
would work for all targets that use this module (GNU/Linux, Windows,
etc.).

Tested:

  GNU/Linux IA64
  GNU/Linux MIPS64
  GNU/Linux PowerPC (Fedora 16)
  GNU/Linux s390x (Fedora 16)
  GNU/Linux sparc64 (Debian)
  GNU/Linux x86_64, -m64 and -m32 (Fedora 17)

Cross built, and smoke tested:

  i686-w64-mingw32, under Wine.
  GNU/Linux TI C6x, by Yao Qi.

Cross built but otherwise not tested:

  aarch64-linux-gnu
  arm-linux-gnu
  m68k-linux
  nios2-linux-gnu
  sh-linux-gnu
  spu
  tilegx-unknown-linux-gnu

Completely untested:

  GNU/Linux Blackfin
  GNU/Linux CRIS
  GNU/Linux CRISv32
  GNU/Linux TI Xtensa
  GNU/Linux M32R
  LynxOS
  QNX NTO

gdb/gdbserver/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* Makefile.in (OBS): Add tdesc.o.
	(IPA_OBJS): Add tdesc-ipa.o.
	(tdesc-ipa.o): New rule.
	* ax.c (gdb_eval_agent_expr): Adjust register_size call to new
	interface.
	* linux-low.c (new_inferior): Delete.
	(disabled_regsets, num_regsets): Delete.
	(linux_add_process): Adjust to set the new per-process
	new_inferior flag.
	(linux_detach_one_lwp): Adjust to call regcache_invalidate_thread.
	(linux_wait_for_lwp): Adjust.  Only call arch_setup if the event
	was a stop.  When calling arch_setup, switch the current inferior
	to the thread that got an event.
	(linux_resume_one_lwp): Adjust to call regcache_invalidate_thread.
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers): New regsets_info parameter.
	Adjust to use it.
	(linux_register_in_regsets): New regs_info parameter.  Adjust to
	use it.
	(register_addr, fetch_register, store_register): New usrregs_info
	parameter.  Adjust to use it.
	(usr_fetch_inferior_registers, usr_store_inferior_registers): New
	parameter regs_info.  Adjust to use it.
	(linux_fetch_registers): Get the current inferior's regs_info, and
	adjust to use it.
	(linux_store_registers): Ditto.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): New.
	(initialize_low): Don't initialize the target_regsets here.  Call
	initialize_low_arch.
	* linux-low.h (target_regsets): Delete declaration.
	(struct regsets_info): New.
	(struct usrregs_info): New.
	(struct regs_info): New.
	(struct process_info_private) <new_inferior>: New field.
	(struct linux_target_ops): Delete the num_regs, regmap, and
	regset_bitmap fields.  New field regs_info.
	[HAVE_LINUX_REGSETS] (initialize_regsets_info): Declare.
	* i387-fp.c (num_xmm_registers): Delete.
	(i387_cache_to_fsave, i387_fsave_to_cache): Adjust find_regno
	calls to new interface.
	(i387_cache_to_fxsave, i387_cache_to_xsave, i387_fxsave_to_cache)
	(i387_xsave_to_cache): Adjust find_regno calls to new interface.
	Infer the number of xmm registers from the regcache's target
	description.
	* i387-fp.h (num_xmm_registers): Delete.
	* inferiors.c (add_thread): Don't install the thread's regcache
	here.
	* proc-service.c (gregset_info): Fetch the current inferior's
	regs_info.  Adjust to use it.
	* regcache.c: Include tdesc.h.
	(register_bytes, reg_defs, num_registers)
	(gdbserver_expedite_regs): Delete.
	(get_thread_regcache): If the thread doesn't have a regcache yet,
	create one, instead of aborting gdbserver.
	(regcache_invalidate_one): Rename to ...
	(regcache_invalidate_thread): ... this.
	(regcache_invalidate_one): New.
	(regcache_invalidate): Only invalidate registers of the current
	process.
	(init_register_cache): Add target_desc parameter, and use it.
	(new_register_cache): Ditto.  Assert the target description has a
	non zero registers_size.
	(regcache_cpy): Add assertions.  Adjust.
	(realloc_register_cache, set_register_cache): Delete.
	(registers_to_string, registers_from_string): Adjust.
	(find_register_by_name, find_regno, find_register_by_number)
	(register_cache_size): Add target_desc parameter, and use it.
	(free_register_cache_thread, free_register_cache_thread_one)
	(regcache_release, register_cache_size): New.
	(register_size): Add target_desc parameter, and use it.
	(register_data, supply_register, supply_register_zeroed)
	(supply_regblock, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Adjust.
	* regcache.h (struct target_desc): Forward declare.
	(struct regcache) <tdesc>: New field.
	(init_register_cache, new_register_cache): Add target_desc
	parameter.
	(regcache_invalidate_thread): Declare.
	(regcache_invalidate_one): Delete declaration.
	(regcache_release): Declare.
	(find_register_by_number, register_cache_size, register_size)
	(find_regno): Add target_desc parameter.
	(gdbserver_expedite_regs, gdbserver_xmltarget): Delete
	declarations.
	* remote-utils.c: Include tdesc.h.
	(outreg, prepare_resume_reply): Adjust.
	* server.c: Include tdesc.h.
	(gdbserver_xmltarget): Delete declaration.
	(get_features_xml, process_serial_event): Adjust.
	* server.h [IN_PROCESS_AGENT] (struct target_desc): Forward
	declare.
	(struct process_info) <tdesc>: New field.
	(ipa_tdesc): Declare.
	* tdesc.c: New file.
	* tdesc.h: New file.
	* tracepoint.c: Include tdesc.h.
	[IN_PROCESS_AGENT] (ipa_tdesc): Define.
	(get_context_regcache): Adjust to pass ipa_tdesc down.
	(do_action_at_tracepoint): Adjust to get the register cache size
	from the context regcache's description.
	(traceframe_walk_blocks): Adjust to get the register cache size
	from the current trace frame's description.
	(traceframe_get_pc): Adjust to get current trace frame's
	description and pass it down.
	(gdb_collect): Adjust to get the register cache size from the
	IPA's description.
	* linux-amd64-ipa.c (tdesc_amd64_linux): Declare.
	(gdbserver_xmltarget): Delete.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-i386-ipa.c (tdesc_i386_linux): Declare.
	(initialize_low_tracepoint): Set the ipa's target description.
	* linux-x86-low.c: Include tdesc.h.
	[__x86_64__] (is_64bit_tdesc): New.
	(ps_get_thread_area, x86_get_thread_area): Use it.
	(i386_cannot_store_register): Rename to ...
	(x86_cannot_store_register): ... this.  Use is_64bit_tdesc.
	(i386_cannot_fetch_register): Rename to ...
	(x86_cannot_fetch_register): ... this.  Use is_64bit_tdesc.
	(x86_fill_gregset, x86_store_gregset): Adjust register_size calls
	to new interface.
	(target_regsets): Rename to ...
	(x86_regsets): ... this.
	(x86_get_pc, x86_set_pc): Adjust register_size calls to new
	interface.
	(x86_siginfo_fixup): Use is_64bit_tdesc.
	[__x86_64__] (tdesc_amd64_linux, tdesc_amd64_avx_linux)
	(tdesc_x32_avx_linux, tdesc_x32_linux)
	(tdesc_i386_linux, tdesc_i386_mmx_linux, tdesc_i386_avx_linux):
	Declare.
	(x86_linux_update_xmltarget): Delete.
	(I386_LINUX_XSAVE_XCR0_OFFSET): Define.
	(have_ptrace_getfpxregs, have_ptrace_getregset): New.
	(AMD64_LINUX_USER64_CS): New.
	(x86_linux_read_description): New, based on
	x86_linux_update_xmltarget.
	(same_process_callback): New.
	(x86_arch_setup_process_callback): New.
	(x86_linux_update_xmltarget): New.
	(x86_regsets_info): New.
	(amd64_linux_regs_info): New.
	(i386_linux_usrregs_info): New.
	(i386_linux_regs_info): New.
	(x86_linux_regs_info): New.
	(x86_arch_setup): Reimplement.
	(x86_install_fast_tracepoint_jump_pad): Use is_64bit_tdesc.
	(x86_emit_ops): Ditto.
	(the_low_target): Adjust.  Install x86_linux_regs_info,
	x86_cannot_fetch_register, and x86_cannot_store_register.
	(initialize_low_arch): New.
	* linux-ia64-low.c (tdesc_ia64): Declare.
	(ia64_fetch_register): Adjust.
	(ia64_usrregs_info, regs_info): New globals.
	(ia64_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sparc-low.c (tdesc_sparc64): Declare.
	(sparc_fill_gregset_to_stack, sparc_store_gregset_from_stack):
	Adjust.
	(sparc_arch_setup): New function.
	(sparc_regsets_info, sparc_usrregs_info, regs_info): New globals.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-ppc-low.c (tdesc_powerpc_32l, tdesc_powerpc_altivec32l)
	(tdesc_powerpc_cell32l, tdesc_powerpc_vsx32l)
	(tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l)
	(tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_e500l)
	(tdesc_powerpc_64l, tdesc_powerpc_altivec64l)
	(tdesc_powerpc_cell64l, tdesc_powerpc_vsx64l)
	(tdesc_powerpc_isa205_64l, tdesc_powerpc_isa205_altivec64l)
	(tdesc_powerpc_isa205_vsx64l): Declare.
	(ppc_cannot_store_register, ppc_collect_ptrace_register)
	(ppc_supply_ptrace_register, parse_spufs_run, ppc_get_pc)
	(ppc_set_pc, ppc_get_hwcap): Adjust.
	(ppc_usrregs_info): Forward declare.
	(!__powerpc64__) ppc_regmap_adjusted: New global.
	(ppc_arch_setup): Adjust to the current process'es target
	description.
	(ppc_fill_vsxregset, ppc_store_vsxregset, ppc_fill_vrregset)
	(ppc_store_vrregset, ppc_fill_evrregset, ppc_store_evrregse)
	(ppc_store_evrregset): Adjust.
	(target_regsets): Rename to ...
	(ppc_regsets): ... this, and make static.
	(ppc_usrregs_info, ppc_regsets_info, regs_info): New globals.
	(ppc_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-s390-low.c (tdesc_s390_linux32, tdesc_s390_linux32v1)
	(tdesc_s390_linux32v2, tdesc_s390_linux64, tdesc_s390_linux64v1)
	(tdesc_s390_linux64v2, tdesc_s390x_linux64, tdesc_s390x_linux64v1)
	(tdesc_s390x_linux64v2): Declare.
	(s390_collect_ptrace_register, s390_supply_ptrace_register)
	(s390_fill_gregset, s390_store_last_break): Adjust.
	(target_regsets): Rename to ...
	(s390_regsets): ... this, and make static.
	(s390_get_pc, s390_set_pc): Adjust.
	(s390_get_hwcap): New target_desc parameter, and use it.
	[__s390x__] (have_hwcap_s390_high_gprs): New global.
	(s390_arch_setup): Adjust to set the current process'es target
	description.  Don't adjust the regmap.
	(s390_usrregs_info, s390_regsets_info, regs_info): New globals.
	[__s390x__] (s390_usrregs_info_3264, s390_regsets_info_3264)
	(regs_info_3264): New globals.
	(s390_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-mips-low.c (tdesc_mips_linux, tdesc_mips_dsp_linux)
	(tdesc_mips64_linux, tdesc_mips64_dsp_linux): Declare.
	[__mips64] (init_registers_mips_linux)
	(init_registers_mips_dsp_linux): Delete defines.
	[__mips64] (tdesc_mips_linux, tdesc_mips_dsp_linux): New defines.
	(have_dsp): New global.
	(mips_read_description): New, based on mips_arch_setup.
	(mips_arch_setup): Reimplement.
	(get_usrregs_info): New function.
	(mips_cannot_fetch_register, mips_cannot_store_register)
	(mips_get_pc, mips_set_pc, mips_fill_gregset, mips_store_gregset)
	(mips_fill_fpregset, mips_store_fpregset): Adjust.
	(target_regsets): Rename to ...
	(mips_regsets): ... this, and make static.
	(mips_regsets_info, mips_dsp_usrregs_info, mips_usrregs_info)
	(dsp_regs_info, regs_info): New globals.
	(mips_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-arm-low.c (tdesc_arm, tdesc_arm_with_iwmmxt)
	(tdesc_arm_with_vfpv2, tdesc_arm_with_vfpv3, tdesc_arm_with_neon):
	Declare.
	(arm_fill_vfpregset, arm_store_vfpregset): Adjust.
	(arm_read_description): New, with bits factored from
	arm_arch_setup.
	(arm_arch_setup): Reimplement.
	(target_regsets): Rename to ...
	(arm_regsets): ... this, and make static.
	(arm_regsets_info, arm_usrregs_info, regs_info): New globals.
	(arm_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m68k-low.c (tdesc_m68k): Declare.
	(target_regsets): Rename to ...
	(m68k_regsets): ... this, and make static.
	(m68k_regsets_info, m68k_usrregs_info, regs_info): New globals.
	(m68k_regs_info): New function.
	(m68k_arch_setup): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-sh-low.c (tdesc_sharch): Declare.
	(target_regsets): Rename to ...
	(sh_regsets): ... this, and make static.
	(sh_regsets_info, sh_usrregs_info, regs_info): New globals.
	(sh_regs_info, sh_arch_setup): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-bfin-low.c (tdesc_bfin): Declare.
	(bfin_arch_setup): New function.
	(bfin_usrregs_info, regs_info): New globals.
	(bfin_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_cris): Declare.
	(cris_arch_setup): New function.
	(cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-cris-low.c (tdesc_crisv32): Declare.
	(cris_arch_setup): New function.
	(cris_regsets_info, cris_usrregs_info, regs_info): New globals.
	(cris_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-m32r-low.c (tdesc_m32r): Declare.
	(m32r_arch_setup): New function.
	(m32r_usrregs_info, regs_info): New globals.
	(m32r_regs_info): Adjust.
	(initialize_low_arch): New function.
	* linux-tic6x-low.c (tdesc_tic6x_c64xp_linux)
	(tdesc_tic6x_c64x_linux, tdesc_tic6x_c62x_linux): Declare.
	(tic6x_usrregs_info): Forward declare.
	(tic6x_read_description): New function, based on ...
	(tic6x_arch_setup): ... this.  Reimplement.
	(target_regsets): Rename to ...
	(tic6x_regsets): ... this, and make static.
	(tic6x_regsets_info, tic6x_usrregs_info, regs_info): New globals.
	(tic6x_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-xtensa-low.c (tdesc_xtensa): Declare.
	(xtensa_fill_gregset, xtensa_store_gregset): Adjust.
	(target_regsets): Rename to ...
	(xtensa_regsets): ... this, and make static.
	(xtensa_regsets_info, xtensa_usrregs_info, regs_info): New
	globals.
	(xtensa_arch_setup, xtensa_regs_info): New functions.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* linux-nios2-low.c (tdesc_nios2_linux): Declare.
	(nios2_arch_setup): Set the current process'es tdesc.
	(target_regsets): Rename to ...
	(nios2_regsets): ... this.
	(nios2_regsets_info, nios2_usrregs_info, regs_info): New globals.
	(nios2_regs_info): New function.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
        * linux-aarch64-low.c (tdesc_aarch64): Declare.
        (aarch64_arch_setup): Set the current process'es tdesc.
        (target_regsets): Rename to ...
        (aarch64_regsets): ... this.
        (aarch64_regsets_info, aarch64_usrregs_info, regs_info): New globals.
        (aarch64_regs_info): New function.
        (the_low_target): Adjust.
        (initialize_low_arch): New function.
	* linux-tile-low.c (tdesc_tilegx, tdesc_tilegx32): Declare
	globals.
	(target_regsets): Rename to ...
	(tile_regsets): ... this.
	(tile_regsets_info, tile_usrregs_info, regs_info): New globals.
	(tile_regs_info): New function.
	(tile_arch_setup): Set the current process'es tdesc.
	(the_low_target): Adjust.
	(initialize_low_arch): New function.
	* spu-low.c (tdesc_spu): Declare.
	(spu_create_inferior, spu_attach): Set the new process'es tdesc.
	* win32-arm-low.c (tdesc_arm): Declare.
	(arm_arch_setup): New function.
	(the_low_target): Install arm_arch_setup instead of
	init_registers_arm.
	* win32-i386-low.c (tdesc_i386, tdesc_amd64): Declare.
	(init_windows_x86): Rename to ...
	(i386_arch_setup): ... this.  Set `win32_tdesc'.
	(the_low_target): Adjust.
	* win32-low.c (win32_tdesc): New global.
	(child_add_thread): Don't create the thread cache here.
	(do_initial_child_stuff): Set the new process'es tdesc.
	* win32-low.h (struct target_desc): Forward declare.
	(win32_tdesc): Declare.
	* lynx-i386-low.c (tdesc_i386): Declare global.
	(lynx_i386_arch_setup): Set `lynx_tdesc'.
	* lynx-low.c (lynx_tdesc): New global.
	(lynx_add_process): Set the new process'es tdesc.
	* lynx-low.h (struct target_desc): Forward declare.
	(lynx_tdesc): Declare global.
	* lynx-ppc-low.c (tdesc_powerpc_32): Declare global.
	(lynx_ppc_arch_setup): Set `lynx_tdesc'.
	* nto-low.c (nto_tdesc): New global.
	(do_attach): Set the new process'es tdesc.
	* nto-low.h (struct target_desc): Forward declare.
	(nto_tdesc): Declare.
	* nto-x86-low.c (tdesc_i386): Declare.
	(nto_x86_arch_setup): Set `nto_tdesc'.

gdb/
2013-06-07  Pedro Alves  <palves@@redhat.com>

	* regformats/regdat.sh: Output #include tdesc.h.  Make globals
	static.  Output a global target description pointer.
	(init_registers_${name}): Adjust to initialize a
	target description structure.
@
text
@a34 1
#include <sys/param.h>
d517 1
a517 1
  char real_path[MAXPATHLEN];
d548 1
a548 2
  cygwin_conv_path (CCP_POSIX_TO_WIN_A, program, real_path,
		    MAXPATHLEN);
@


1.63
log
@	* win32-low.c: Throughout, fix format strings and casts of
	printf-like functions to avoid type related warnings on all
	platforms.
	(get_child_debug_event): Print dwDebugEventCode as hex since
	that's how it's usually documented.
@
text
@d90 2
a197 3
  set_inferior_regcache_data ((struct thread_info *)
			      find_inferior_id (&all_threads, ptid),
			      new_register_cache ());
d310 2
d323 2
a324 1
  add_process (pid, attached);
@


1.62
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d451 1
a451 1
    sprintf (buf, "unknown win32 error (%ld)", error);
d1320 4
a1323 4
      OUTMSG2 (("gdbserver: unknown target exception 0x%08lx at 0x%s",
		current_event.u.Exception.ExceptionRecord.ExceptionCode,
		phex_nz ((uintptr_t) current_event.u.Exception.ExceptionRecord.
		ExceptionAddress, sizeof (uintptr_t))));
d1455 1
a1455 1
		"for pid=%d tid=%x)\n",
d1468 1
a1468 1
		"for pid=%d tid=%x\n",
d1479 1
a1479 1
		"for pid=%d tid=%x\n",
d1513 1
a1513 1
		"for pid=%d tid=%x\n",
d1525 1
a1525 1
		"for pid=%d tid=%x\n",
d1537 1
a1537 1
		"for pid=%d tid=%x\n",
d1547 1
a1547 1
		"for pid=%d tid=%x\n",
d1556 1
a1556 1
		"for pid=%d tid=%x\n",
d1564 1
a1564 1
		"for pid=%d tid=%x code=%ld\n",
d1567 1
a1567 1
		current_event.dwDebugEventCode));
@


1.61
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d2 1
a2 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.60
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d77 1
a77 1
static enum gdb_signal last_sig = TARGET_SIGNAL_0;
d311 1
a311 1
  last_sig = TARGET_SIGNAL_0;
d838 1
a838 1
  if (sig != TARGET_SIGNAL_0)
d850 1
a850 1
  last_sig = TARGET_SIGNAL_0;
d1235 1
a1235 1
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
d1239 1
a1239 1
      ourstatus->value.sig = TARGET_SIGNAL_SEGV;
d1243 1
a1243 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1247 1
a1247 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1251 1
a1251 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1255 1
a1255 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1259 1
a1259 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1263 1
a1263 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1267 1
a1267 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1271 1
a1271 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1275 1
a1275 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1279 1
a1279 1
      ourstatus->value.sig = TARGET_SIGNAL_FPE;
d1283 1
a1283 1
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
d1292 1
a1292 1
      ourstatus->value.sig = TARGET_SIGNAL_INT;
d1296 1
a1296 1
      ourstatus->value.sig = TARGET_SIGNAL_INT;
d1300 1
a1300 1
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
d1304 1
a1304 1
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
d1308 1
a1308 1
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
d1312 1
a1312 1
      ourstatus->value.sig = TARGET_SIGNAL_ILL;
d1324 1
a1324 1
      ourstatus->value.sig = TARGET_SIGNAL_UNKNOWN;
d1382 1
a1382 1
  last_sig = TARGET_SIGNAL_0;
d1532 1
a1532 1
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
d1542 1
a1542 1
      ourstatus->value.sig = TARGET_SIGNAL_TRAP;
@


1.59
log
@gdb/gdbserver:

	* server.h: Move some code to ...
	* gdbthread.h: ... here.  New.
	* Makefile.in (inferiors.o, regcache.o): Depends on gdbthread.h
	(remote-utils.o, server.o, target.o tracepoint.o): Likewise.
	(nto-low.o, win32-low.o): Likewise.
	* inferiors.c, linux-low.h, nto-low.c: Include gdbthread.h.
	* regcache.c, remote-utils.c, server.c: Likewise.
	* target.c, tracepoint.c, win32-low.c: Likewise.
@
text
@d77 1
a77 1
static enum target_signal last_sig = TARGET_SIGNAL_0;
d809 1
a809 1
  enum target_signal sig;
@


1.58
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d27 1
@


1.57
log
@gdb/gdbserver/

	* target.h (struct target_ops): Fix indent.
	* win32-low.c (win32_target_ops): Fix comment.
@
text
@d2 1
a2 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.57.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.56
log
@        gdb/
        * remote.c (PACKET_qXfer_fdpic): New enum value.
        (remote_protocol_features): Add qXfer:fdpic:read packet.
        (remote_xfer_partial): Support TARGET_OBJECT_FDPIC.
        (_initialize_remote): Add set/show remote read-fdpic-loadmap command.
        * target.h (enum target_object): Add TARGET_OBJECT_FDPIC.

        gdb/gdbserver:
        * target.h (struct target_ops): Add read_loadmap.
        * linux-low.c (struct target_loadseg): New type.
        (struct target_loadmap): New type.
        (linux_read_loadmap): New function.
        (linux_target_ops): Add linux_read_loadmap.
        * server.c (handle_query): Support qXfer:fdpic:read packet.
	* win32-low.c (win32_target_ops): Initialize field `read_loadmap' to NULL.

        gdb/doc/
        * gdb.texinfo : Document qXfer:fdpic:read packet.
@
text
@d1814 1
a1814 1
  NULL, /* read_fdpic_loadmap */
@


1.55
log
@
 win32-low.c: Include <stdint.h>.
@
text
@d1814 1
@


1.54
log
@gdb
	* windows-tdep.c (windows_xfer_shared_library):
	* windows-nat.c (get_module_name, windows_make_so):
	* v850-tdep.c (v850_handle_pushm):
	* utils.c (null_cleanup, gdb_realpath):
	* ui-out.c (get_next_header):
	* tracepoint.c (clear_traceframe_info):
	* symtab.c (lookup_symtab):
	* serial.h (struct serial_ops):
	* mipsread.c (read_alphacoff_dynamic_symtab):
	* infcmd.c (print_return_value):
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address):
	* f-exp.y (parse_number):
	* exceptions.c (catch_exceptions):
	* dummy-frame.c (dummy_frame_this_id):
	* defs.h (struct cleanup):
	* breakpoint.c (disable_breakpoints_in_unloaded_shlib):
	* arm-tdep.c (arm_push_dummy_call):
	* amd64-tdep.h (amd64_collect_xsave):
	* amd64-tdep.c (amd64_collect_xsave):
	* alpha-tdep.c (alpha_heuristic_frame_unwind_cache):
	* README (typing): Remove duplicate words.
	* cli/cli-decode.c (lookup_cmd_composition): Add comma.
	* infrun.c (siginfo_value_read): Fix typo.
	* solib-frv.c (frv_fdpic_find_global_pointer): Likewise.
	* top.c (source_line_number): Add comma.
gdb/doc
	* gdbint.texinfo (Register Information Functions): Remove
	duplicate "the".
	* gdb.texinfo (Emacs): Remove duplicate "to".
	(GDB/MI Variable Objects): Remove duplicate "the".
	(General Query Packets): Likewise.
gdb/testsuite
	* gdb.mi/mi-nsmoribund.exp:
	* gdb.hp/gdb.objdbg/objdbg01.exp:
	* gdb.base/structs.exp (test_struct_returns):
	* gdb.base/call-sc.exp (test_scalar_returns):
	* gdb.base/bigcore.exp: Remove duplicate words.
gdb/gdbserver
	* win32-low.c (handle_load_dll): Remove duplicate "the".
@
text
@d29 1
@


1.53
log
@	Remove support for old Cygwin 1.5 versions.
	* win32-low.c (win32_create_inferior): Use new cygwin_path_list
	function to avoid warning.
	(win32_add_one_solib): Use cygwin_conv_path function to avoid
	warning.
@
text
@d1207 1
a1207 1
     the offset from 0 of the first byte in an image - because
@


1.52
log
@run copyright.sh for 2011.
@
text
@d539 1
d541 1
a541 1
      new_path = alloca (cygwin_posix_to_win32_path_list_buf_size (path_ptr));
d543 1
a543 1
      cygwin_posix_to_win32_path_list (path_ptr, new_path);
d545 3
a547 2
    }
  cygwin_conv_to_win32_path (program, real_path);
d930 1
a930 1
  cygwin_conv_to_posix_path (buf, buf2);
@


1.51
log
@[gdbserver] Move malloc.h include to server.h.

This patch moves all includes of malloc.h, which were introduced
purely to get access to alloca's declaration, to server.h, next
to the include of alloca.h.

There is one exception: gdbreplay.c, which does not include server.h.
In this case, the include of alloca.h was simply moved up a bit, next
to the include of malloc.h.

gdb/gdbserver/ChangeLog:

        * gdbreplay.c: Move include of alloca.h up, next to include of
        malloc.h.
        * server.h: Add include of malloc.h.
        * mem-break.c: Remove include of malloc.h.
        * server.c, tracepoint.c, utils.c, win32-low.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.50
log
@	* linux-low.c (linux_unprepare_to_access_memory): Rename to ...
	(linux_done_accessing_memory): ... this.
	(linux_target_ops): Adjust.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Adjust.
	* nto-low.c (nto_target_ops): Adjust comment.
	* server.c (gdb_read_memory, gdb_write_memory): Adjust.
	* spu-low.c (spu_target_ops): Adjust comment.
	* target.h (target_ops): Rename unprepare_to_access_memory field
	to done_accessing_memory.
	(unprepare_to_access_memory): Rename to ...
	(done_accessing_memory): ... this.
@
text
@a33 1
#include <malloc.h>
@


1.49
log
@	* linux-low.c (linux_prepare_to_access_memory): New.
	(linux_unprepare_to_access_memory): New.
	(linux_target_ops): Install them.
	* server.c (read_memory): Rename to ...
	(gdb_read_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(write_memory): Rename to ...
	(gdb_write_memory): ... this.  Use
	prepare_to_access_memory/prepare_to_access_memory.
	(handle_search_memory_1): Adjust.
	(process_serial_event): Adjust.
	* target.h (struct target_ops): New fields
	prepare_to_access_memory and unprepare_to_access_memory.
	(prepare_to_access_memory, unprepare_to_access_memory): New.
	* linux-x86-low.c (x86_insert_point, x86_remove_point): Use
	prepare_to_access_memory/prepare_to_access_memory.
	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_target_ops): Adjust.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d1785 1
a1785 1
  NULL, /* unprepare_to_access_memory */
@


1.48
log
@	* linux-low.c (linux_kill, linux_detach): Adjust.
	(status_pending_p_callback): Remove redundant statement.  Check
	for !TARGET_WAITIKIND_IGNORE, instead of
	TARGET_WAITKIND_STOPPED.
	(handle_tracepoints): Make sure LWP is locked.  Adjust.
	(linux_wait_for_event_1): Adjust.
	(linux_cancel_breakpoints): New.
	(unsuspend_one_lwp): New.
	(unsuspend_all_lwps): New.
	(linux_wait_1): If finishing a step-over, unsuspend all lwps.
	(send_sigstop_callback): Change return type to int, add new
	`except' parameter and handle it.
	(suspend_and_send_sigstop_callback): New.
	(stop_all_lwps): Add new `suspend' and `expect' parameters, and
	pass them down.  If SUSPEND, also increment the lwp's suspend
	count.
	(linux_resume_one_lwp): Add notice about resuming a suspended LWP.
	(need_step_over_p): Don't consider suspended LWPs.
	(start_step_over): Adjust.
	(proceed_one_lwp): Change return type to int, add new `except'
	parameter and handle it.
	(unsuspend_and_proceed_one_lwp): New.
	(proceed_all_lwps): Use find_inferior instead of
	for_each_inferior.
	(unstop_all_lwps): Add `unsuspend' parameter.  If UNSUSPEND, them
	also decrement the suspend count of LWPs.  Pass `except' down,
	instead of hacking its suspend count.
	(linux_pause_all): Add `freeze' parameter.  Adjust.
	(linux_unpause_all): New.
	(linux_target_ops): Install linux_unpause_all.
	* server.c (handle_status): Adjust.
	* target.h (struct target_ops): New fields `unpause_all' and
	`cancel_breakpoints'.  Add new parameter to `pause_all'.
	(pause_all): Add new `freeze' parameter.
	(unpause_all): New.
	(cancel_breakpoints): New.
	* tracepoint.c (clear_installed_tracepoints): Pause threads, and
	cancel breakpoints.
	(cmd_qtstart): Pause threads.
	(stop_tracing): Pause threads, and cancel breakpoints.
	* win32-low.c (win32_target_ops): Adjust.
@
text
@d1784 2
@


1.47
log
@	* win32-low.c: Adapt to support also 64-bit architecture.
	(child_xfer_memory): Use uintptr_t type for local variable `addr'.
	(get_image_name): Use SIZE_T type for local variable `done'.
	(psapi_get_dll_name): Use LPVOID type for parameter `BaseAddress'.
	(toolhelp_get_dll_name): Idem.
	(handle_load_dll): Use CORE_ADDR type for local variable `load_addr'.
	Use uintptr_t typecast to avoid warning.
	(handle_unload_dll): Use uintptr_t typecast to avoid warning.
	(handle_exception): Use phex_nz to avoid warning.
	(win32_wait): Remove unused local variable `process'.
@
text
@d1814 1
a1814 2
  NULL, /* pause_all */
  win32_get_tib_address,
@


1.46
log
@
	Support for Windows OS Thread Information Block.
	* NEWS: Document new feature.
	* remote.c (PACKET_qGetTIBAddr): New enum element.
	(remote_get_tib_address): New function.
	(init_remote_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_remote): Add add_packet_config_cmd
	for PACKET_qGetTIBAddr.
	* target.c (update_current_target): Set default value for
	new to_get_tib_address field.
	* target.h (target_ops): New field to_get_tib_address.
	(target_get_tib_address): New macro.
	* windows-nat.c (thread_info): Add thread_local_base field.
	(windows_add_thread): Add tlb argument of type 'void *'.
	(fake_create_process): Adapt windows_add_thread call.
	(get_windows_debug_event): Idem.
	(windows_get_tib_address): New function.
	(init_windows_ops): Set to_get_tib_address field
	to remote_get_tib_address.
	(_initialize_windows_nat): Replace info_w32_cmdlist
	initialization by a call to init_w32_command_list.
	(info_w32_command, info_w32_cmdlist): Removed from here...
	to windows-tdep.c file.
	* windows-tdep.h (info_w32_cmdlist): Declare.
	(init_w32_command_list): New external function
	declaration.
	* windows-tdep.c: Add several headers.
	(info_w32_cmdlist): to here, made global.
	(thread_information_32): New struct.
	(thread_information_64): New struct.
	(TIB_NAME): New char array.
	(MAX_TIB32, MAX_TIB64, FULL_TIB_SIZE): New constants.
	(maint_display_all_tib): New static variable.
	(windows_get_tlb_type): New function.
	(tlb_value_read, tlb_value_write): New functions.
	(tlb_value_funcs): New static struct.
	(tlb_make_value): New function.
	(display_one_tib): New function.
	(display_tib): New function.
	(show_maint_show_all_tib):New function.
	(info_w32_command): Moved from windows-nat.c.
	(init_w32_command_list): New function.
	(_initialize_windows_tdep): New function.
	New "maint set/show show-all-tib" command
	New "$_tlb" internal variable.

gdbserver/ChangeLog entry:

	* server.c (handle_query): Handle 'qGetTIBAddr' query.
	* target.h (target_ops): New get_tib_address field.
	* win32-low.h (win32_thread_info): Add thread_local_base field.
	* win32-low.c (child_add_thread): Add tlb argument.
	Set thread_local_base field to TLB.
	(get_child_debug_event): Adapt to child_add_thread change.
	(win32_get_tib_address): New function.
	(win32_target_ops): Set get_tib_address field to
	win32_get_tib_address.
	* linux-low.c (linux_target_ops): Set get_tib_address field to NULL.

doc/ChangeLog entry:

	gdb.texinfo ($_tlb): Document new automatic convinience variable.
	(info w32 thread-information-block): Document new command.
	(qGetTIBAddress): Document new gdbserver query.
	(maint set/show show-all-tib): Document new command.
@
text
@d283 1
a283 1
  long addr = (long) memaddr;
d944 1
a944 1
  DWORD done;
d1022 1
a1022 1
psapi_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
d1067 1
a1067 1
      if ((DWORD) (mi.lpBaseOfDll) == BaseAddress)
d1137 1
a1137 1
toolhelp_get_dll_name (DWORD BaseAddress, char *dll_name_ret)
d1154 1
a1154 1
      if ((DWORD) modEntry.modBaseAddr == BaseAddress)
d1179 1
a1179 1
  DWORD load_addr;
d1186 1
a1186 1
  if (!psapi_get_dll_name ((DWORD) event->lpBaseOfDll, dll_buf))
d1193 1
a1193 1
	toolhelp_get_dll_name ((DWORD) event->lpBaseOfDll, dll_buf);
d1208 1
a1208 1
  load_addr = (DWORD) event->lpBaseOfDll + 0x1000;
d1216 1
a1216 1
	  (CORE_ADDR) (DWORD) current_event.u.UnloadDll.lpBaseOfDll;
d1317 1
a1317 1
      OUTMSG2 (("gdbserver: unknown target exception 0x%08lx at 0x%08lx",
d1319 2
a1320 2
		(DWORD) current_event.u.Exception.ExceptionRecord.
		ExceptionAddress));
a1579 1
  struct process_info *process;
@


1.45
log
@	gdb/gdbserver/
	* linux-low.c (linux_mourn): Also remove the process.
	* server.c (handle_target_event): Don't remove the process here.
	* nto-low.c (nto_mourn): New.
	(nto_target_ops): Install it.
	* spu-low.c (spu_mourn): New.
	(spu_target_ops): Install it.
	* win32-low.c (win32_mourn): New.
	(win32_target_ops): Install it.
@
text
@d181 1
a181 1
child_add_thread (DWORD pid, DWORD tid, HANDLE h)
d192 1
d1459 2
a1460 1
			current_event.u.CreateThread.hThread);
d1490 2
a1491 1
			current_event.u.CreateProcessInfo.hThread);
d1759 14
d1787 1
a1787 1
  NULL,
d1789 1
a1789 1
  NULL,
d1794 3
a1796 3
  NULL,
  NULL,
  NULL,
d1802 15
@


1.44
log
@	GDBserver disconnected tracing support.

	* linux-low.c (linux_remove_process): Delete.
	(add_lwp): Don't set last_resume_kind here.
	(linux_kill): Use `mourn'.
	(linux_detach): Use `thread_db_detach', and `mourn'.
	(linux_mourn): New.
	(linux_attach_lwp_1): Adjust comment.
	(linux_attach): last_resume_kind moved the thread_info; adjust.
	(status_pending_p_callback): Adjust.
	(linux_wait_for_event_1): Adjust.
	(count_events_callback, select_singlestep_lwp_callback)
	(select_event_lwp_callback, cancel_breakpoints_callback)
	(db_wants_lwp_stopped, linux_wait_1, need_step_over_p)
	(proceed_one_lwp): Adjust.
	(linux_async): Add debug output.
	(linux_thread_stopped): New.
	(linux_pause_all): New.
	(linux_target_ops): Install linux_mourn, linux_thread_stopped and
	linux_pause_all.
	* linux-low.h (struct lwp_info): Delete last_resume_kind field.
	(thread_db_free): Delete declaration.
	(thread_db_detach, thread_db_mourn): Declare.
	* thread-db.c (thread_db_init): Use thread_db_mourn.
	(thread_db_free): Delete, split in two.
	(disable_thread_event_reporting): New.
	(thread_db_detach): New.
	(thread_db_mourn): New.

	* server.h (struct thread_info) <last_resume_kind>: New field.
	<attached>: Add comment.
	<gdb_detached>: New field.
	(handler_func): Change return type to int.
	(handle_serial_event, handle_target_event): Ditto.
	(gdb_connected): Declare.
	(tracing): Delete.
	(disconnected_tracing): Declare.
	(stop_tracing): Declare.

	* server.c (handle_query) <qSupported>: Report support for
	disconnected tracing.
	(queue_stop_reply_callback): Account for running threads.
	(gdb_wants_thread_stopped): New.
	(gdb_wants_all_threads_stopped): New.
	(gdb_reattached_process): New.
	(handle_status): Clear the `gdb_detached' flag of all processes.
	In all-stop, stop all threads.
	(main): Be sure to leave tfind mode.  Handle disconnected tracing.
	(process_serial_event): If the remote connection breaks, or if an
	exit was forced with "monitor exit", force an event loop exit.
	Handle disconnected tracing on detach.
	(handle_serial_event): Adjust.
	(handle_target_event): If GDB isn't connected, forward events back
	to the inferior, unless the last process exited, in which case,
	exit gdbserver.  Adjust interface.

	* remote-utils.c (remote_open): Don't block in accept.  Instead
	register an event loop source on the listen socket file
	descriptor.  Refactor bits into ...
	(listen_desc): ... this new global.
	(gdb_connected): ... this new function.
	(enable_async_notification): ... this new function.
	(handle_accept_event): ... this new function.
	(remote_close): Clear remote_desc.

	* inferiors.c (add_thread): Set the new thread's last_resume_kind.

	* target.h (struct target_ops) <mourn, thread_stopped, pause_all>:
	New fields.
	(mourn_inferior): Define.
	(target_process_qsupported): Avoid the dangling else problem.
	(thread_stopped): Define.
	(pause_all): Define.
	(target_waitstatus_to_string): Declare.
	* target.c (target_waitstatus_to_string): New.

	* tracepoint.c (tracing): Make extern.
	(disconnected_tracing): New.
	(stop_tracing): Make extern.  Handle tracing stops due to GDB
	disconnecting.
	(cmd_qtdisconnected): New.
	(cmd_qtstatus): Report disconnected tracing status in trace reply.
	(handle_tracepoint_general_set): Handle QTDisconnected.

	* event-loop.c (event_handler_func): Change return type to int.
	(process_event): Bail out if the event handler wants the event
	loop to stop.
	(handle_file_event): Ditto.
	(start_event_loop): Bail out if the event handler wants the event
	loop to stop.

	* nto-low.c (nto_target_ops): Adjust.
	* spu-low.c (spu_wait): Don't remove the process here.
	(spu_target_ops): Adjust.
	* win32-low.c (win32_wait): Don't remove the process here.
	(win32_target_ops): Adjust.
@
text
@d766 6
d1761 1
a1761 1
  NULL,
@


1.43
log
@	* regcache.h (struct thread_info): Forward declare.
	(struct regcache): New.
	(new_register_cache): Adjust prototype.
	(get_thread_regcache): Declare.
	(free_register_cache): Adjust prototype.
	(registers_to_string, registers_from_string): Ditto.
	(supply_register, supply_register_by_name, collect_register)
	(collect_register_as_string, collect_register_by_name): Ditto.
	* regcache.c (struct inferior_regcache_data): Delete.
	(get_regcache): Rename to ...
	(get_thread_regcache): ... this.  Adjust.  Switch inferior before
	fetching registers.
	(regcache_invalidate_one): Adjust.
	(regcache_invalidate): Fix prototype.
	(new_register_cache): Return the new register cache.
	(free_register_cache): Change prototype.
	(realloc_register_cache): Adjust.
	(registers_to_string): Change prototype to take a regcache.  Adjust.
	(registers_from_string): Ditto.
	(register_data): Ditto.
	(supply_register): Ditto.
	(supply_register_by_name): Ditto.
	(collect_register): Ditto.
	(collect_register_as_string): Ditto.
	(collect_register_by_name): Ditto.
	* server.c (process_serial_event): Adjust.
	* linux-low.h (regset_fill_func, regset_store_func): Change
	prototype.
	(get_pc, set_pc, collect_ptrace_register, supply_ptrace_register):
	Change prototype.
	* linux-low.c (get_stop_pc): Adjust.
	(check_removed_breakpoint): Adjust.
	(linux_wait_for_event): Adjust.
	(linux_resume_one_lwp): Adjust.
	(fetch_register): Add regcache parameter.  Adjust.
	(usr_store_inferior_registers): Ditto.
	(regsets_fetch_inferior_registers): Ditto.
	(regsets_store_inferior_registers): Ditto.
	(linux_fetch_registers, linux_store_registers): Ditto.
	* i387-fp.c (i387_cache_to_fsave): Change prototype to take a
	regcache.  Adjust.
	(i387_fsave_to_cache, i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* i387-fp.h (i387_cache_to_fsave, i387_fsave_to_cache): Change
	prototype to take a regcache.
	(i387_cache_to_fxsave, i387_fxsave_to_cache): Ditto.
	* remote-utils.c (convert_ascii_to_int, outreg)
	(prepare_resume_reply): Change prototype to take a regcache.
	Adjust.
	* target.h (struct target_ops) <fetch_registers, store_registers>:
	Change prototype to take a regcache.
	(fetch_inferior_registers, store_inferior_registers): Change
	prototype to take a regcache.  Adjust.
	* proc-service.c (ps_lgetregs): Adjust.
	* linux-x86-low.c (x86_fill_gregset, x86_store_gregset)
	(x86_fill_fpregset, x86_store_fpregset, x86_fill_fpxregset)
	(x86_store_fpxregset, x86_get_pc, x86_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-arm-low.c (arm_fill_gregset, arm_store_gregset)
	(arm_fill_wmmxregset, arm_store_wmmxregset, arm_fill_vfpregset)
	(arm_store_vfpregset, arm_get_pc, arm_set_pc):
	(arm_breakpoint_at): Change prototype to take a regcache.  Adjust.
	* linux-cris-low.c (cris_get_pc, cris_set_pc)
	(cris_cannot_fetch_register):
	(cris_breakpoint_at): Change prototype to take a regcache.
	Adjust.
	* linux-crisv32-low.c (cris_get_pc, cris_set_pc,
	cris_reinsert_addr, cris_write_data_breakpoint): Change prototype
	to take a regcache.  Adjust.
	(cris_breakpoint_at, cris_insert_point, cris_remove_point):
	Adjust.
	* linux-m32r-low.c (m32r_get_pc, m32r_set_pc): Change prototype to
	take a regcache.  Adjust.
	* linux-m68k-low.c (m68k_fill_gregset, m68k_store_gregset)
	(m68k_fill_fpregset, m68k_store_fpregset, m68k_get_pc,
	(m68k_set_pc): Change prototype to take a regcache.  Adjust.
	* linux-mips-low.c (mips_get_pc):
	(mips_set_pc): Change prototype to take a regcache.  Adjust.
	(mips_reinsert_addr): Adjust.
	(mips_collect_register): Change prototype to take a regcache.
	Adjust.
	(mips_supply_register):
	(mips_collect_register_32bit, mips_supply_register_32bit)
	(mips_fill_gregset, mips_store_gregset, mips_fill_fpregset)
	(mips_store_fpregset): Ditto.
	* linux-ppc-low.c (ppc_supply_ptrace_register, ppc_supply_ptrace_register):
	Ditto.
	(parse_spufs_run): Adjust.
	(ppc_get_pc, ppc_set_pc, ppc_fill_gregset, ppc_fill_vsxregset)
	(ppc_store_vsxregset, ppc_fill_vrregset, ppc_store_vrregset)
	(ppc_fill_evrregset, ppc_store_evrregset): Change prototype to
	take a regcache.  Adjust.
	* linux-s390-low.c (s390_collect_ptrace_register)
	(s390_supply_ptrace_register, s390_fill_gregset, s390_get_pc)
	(s390_set_pc): Change prototype to take a regcache.  Adjust.
	(s390_arch_setup): Adjust.
	* linux-sh-low.c (sh_get_pc, sh_breakpoint_at)
	(sh_fill_gregset): Change prototype to take a regcache.  Adjust.
	* linux-sparc-low.c (sparc_fill_gregset_to_stack)
	(sparc_fill_gregset, sparc_store_gregset_from_stack)
	(sparc_store_gregset, sparc_get_pc): Change prototype to take a
	regcache.  Adjust.
	(sparc_breakpoint_at): Adjust.
	* linux-xtensa-low.c (xtensa_fill_gregset):
	(xtensa_store_gregset):
	(xtensa_fill_xtregset, xtensa_store_xtregset, xtensa_get_pc)
	(xtensa_set_pc): Change prototype to take a regcache.  Adjust.
	* nto-low.c (nto_fetch_registers, nto_store_registers): Change
	prototype to take a regcache.  Adjust.
	* win32-arm-low.c (arm_fetch_inferior_register)
	(arm_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-i386-low.c (i386_fetch_inferior_register)
	(i386_store_inferior_register): Change prototype to take a
	regcache.  Adjust.
	* win32-low.c (child_fetch_inferior_registers)
	(child_store_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_wait): Adjust.
	(win32_fetch_inferior_registers): Change prototype to take a
	regcache.  Adjust.
	(win32_store_inferior_registers): Adjust.
	* win32-low.h (struct win32_target_ops) <fetch_inferior_register,
	store_inferior_register>: Change prototype to take a regcache.
@
text
@a1583 3

	  process = find_process_pid (current_process_id);
	  remove_process (process);
d1755 1
@


1.42
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d375 1
a375 1
child_fetch_inferior_registers (int r)
d380 1
a380 1
    child_fetch_inferior_registers (NUM_REGS);
d383 1
a383 1
      (*the_low_target.fetch_inferior_register) (th, regno);
d389 1
a389 1
child_store_inferior_registers (int r)
d394 1
a394 1
    child_store_inferior_registers (NUM_REGS);
d397 1
a397 1
      (*the_low_target.store_inferior_register) (th, regno);
d1572 1
d1594 2
a1595 1
	  child_fetch_inferior_registers (-1);
d1627 1
a1627 1
win32_fetch_inferior_registers (int regno)
d1629 1
a1629 1
  child_fetch_inferior_registers (regno);
d1635 1
a1635 1
win32_store_inferior_registers (int regno)
d1637 1
a1637 1
  child_store_inferior_registers (regno);
@


1.41
log
@	* win32-low.c (get_child_debug_event): On EXIT_THREAD_DEBUG_EVENT
	events, don't leave current_inferior pointing at null.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.40
log
@	* win32-low.c (LOG): Delete.
	(OUTMSG): Output to stderr.
	(OUTMSG2): Conditionalize on `debug_threads' variable, instead of
	on compile time LOG macro.
	(win32_wait): Fix debug output.
@
text
@a1440 4
  ptid = debug_event_ptid (&current_event);
  current_inferior =
    (struct thread_info *) find_inferior_id (&all_threads, ptid);

d1462 3
a1464 1
      break;
d1559 1
@


1.39
log
@	* win32-low.c (win32_add_one_solib): If the dll name is
	"ntdll.dll", prepend the system directory to the dll path.
@
text
@d41 1
a41 1
#define LOG 0
d43 9
a51 6
#define OUTMSG(X) do { printf X; fflush (stdout); } while (0)
#if LOG
#define OUTMSG2(X) do { printf X; fflush (stdout); } while (0)
#else
#define OUTMSG2(X) do ; while (0)
#endif
d1592 1
a1592 1
		    our_status.value.sig));
@


1.38
log
@	* win32-i386-low.c (i386_get_thread_context): Handle systems that
	don't support CONTEXT_EXTENDED_REGISTERS.
	(i386_win32_breakpoint, i386_win32_breakpoint_len): New.
	(the_low_target): Install them.
	* win32-low.c (get_child_debug_event): Handle WaitForDebugEvent
	failing with ERROR_PIPE_NOT_CONNECTED.
@
text
@d909 8
@


1.37
log
@	Add h/w watchpoint support to x86-linux, win32-i386.
	* Makefile.in (SFILES): Add i386-low.c
	(i386_low_h): Define.
	(i386-low.o): Add dependencies.
	(linux-x86-low.o): Add i386-low.h dependency.
	(win32-i386-low.o): Ditto.
	* i386-low.c: New file.
	* i386-low.h: New file.
	* configure.srv (i[34567]86-*-cygwin*): Add i386-low.o to srv_tgtobj.
	(i[34567]86-*-linux*, i[34567]86-*-mingw*, x86_64-*-linux*): Ditto.
	* linux-low.c (linux_add_process): Initialize arch_private.
	(linux_remove_process): Free arch_private.
	(add_lwp): Initialize arch_private.
	(delete_lwp): Free arch_private.
	(linux_resume_one_lwp): Call the_low_target.prepare_to_resume if
	provided.
	* linux-low.h (process_info_private): New member arch_private.
	(lwp_info): New member arch_private.
	(linux_target_ops): New members new_process, new_thread,
	prepare_to_resume.
	(ptid_of): New macro.
	* linux-x86-low.c: Include stddef.h, i386-low.h.
	(arch_process_info): New struct.
	(arch_lwp_info): New struct.
	(x86_linux_dr_get, x86_linux_dr_set): New functions.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(x86_insert_point, x86_remove_point): New functions.
	(x86_stopped_by_watchpoint): New function.
	(x86_stopped_data_address): New function.
	(x86_linux_new_process, x86_linux_new_thread): New functions.
	(x86_linux_prepare_to_resume): New function.
	(the_low_target): Add entries for insert_point, remove_point,
	stopped_by_watchpoint, stopped_data_address, new_process, new_thread,
	prepare_to_resume.
	* server.c (debug_hw_points): New global.
	(monitor_show_help): Document set debug-hw-points.
	(handle_query): Process "set debug-hw-points".
	* server.h (debug_hw_points): Declare.
	(paddress): Declare.
	* utils.c (NUMCELLS, CELLSIZE): New macros.
	(get_sell, xsnprintf, paddress): New functions.
	* win32-arm-low.c (the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-i386-low.c: Include i386-low.h.
	(debug_reg_state): Replaces dr.
	(i386_dr_low_set_addr, i386_dr_low_set_control): New functions.
	(i386_dr_low_get_status): New function.
	(i386_insert_point, i386_remove_point): New functions.
	(i386_stopped_by_watchpoint): New function.
	(i386_stopped_data_address): New function.
	(i386_initial_stuff): Update.
	(get_thread_context,set_thread_context,i386_thread_added): Update.
	(the_low_target): Add entries for insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
	* win32-low.c (win32_insert_watchpoint): New function.
	(win32_remove_watchpoint): New function.
	(win32_stopped_by_watchpoint): New function.
	(win32_stopped_data_address): New function.
	(win32_target_ops): Add entries for insert_watchpoint,
	remove_watchpoint, stopped_by_watchpoint, stopped_data_address.
	* win32-low.h (win32_target_ops): New members insert_point,
	remove_point, stopped_by_watchpoint, stopped_data_address.
@
text
@d1410 16
a1425 1
	return 0;
@


1.36
log
@	* linux-low.c (usr_fetch_inferior_registers): Remove check for regno 0.
	* proc-service.c (ps_lgetregs): Pass -1 to fetch all registers.
	* regcache.c (get_regcache): Likewise.
	* spu-low.c (spu_fetch_registers): Remove 0 to -1 conversion.
	* win32-low.c (child_fetch_inferior_registers): Remove check for
	regno 0.
@
text
@d231 42
d1742 4
a1745 4
  NULL,
  NULL,
  NULL,
  NULL,
@


1.35
log
@2009-04-01  Pedro Alves  <pedro@@codesourcery.com>

	Implement the multiprocess extensions, and add linux multiprocess
	support.

	* server.h (ULONGEST): Declare.
	(struct ptid, ptid_t): New.
	(minus_one_ptid, null_ptid): Declare.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): Declare.
	(struct inferior_list_entry): Change `id' type from unsigned from
	to ptid_t.
	(struct sym_cache, struct breakpoint, struct
	process_info_private): Forward declare.
	(struct process_info): Declare.
	(current_process): Declare.
	(all_processes): Declare.
	(initialize_inferiors): Declare.
	(add_thread): Adjust to use ptid_t.
	(thread_id_to_gdb_id, thread_to_gdb_id, gdb_id_to_thread_id): Ditto.
	(add_process, remove_process, find_thread_pid): Declare.
	(find_inferior_id): Adjust to use ptid_t.
	(cont_thread, general_thread, step_thread): Change type to ptid_t.
	(multi_process): Declare.
	(push_event): Adjust to use ptid_t.
	(read_ptid, write_ptid): Declare.
	(prepare_resume_reply): Adjust to use ptid_t.
	(clear_symbol_cache): Declare.
	* inferiors.c (all_processes): New.
	(null_ptid, minus_one_ptid): New.
	(ptid_build, pid_to_ptid, ptid_get_pid, ptid_get_lwp)
	(ptid_get_tid, ptid_equal, ptid_is_pid): New.
	(add_thread): Change unsigned long to ptid.  Remove gdb_id
	parameter.  Adjust.
	(thread_id_to_gdb_id, thread_to_gdb_id): Change unsigned long to ptid.
	(gdb_id_to_thread): Rename to ...
	(find_thread_pid): ... this.  Change unsigned long to ptid.
	(gdb_id_to_thread_id, find_inferior_id): Change unsigned long to ptid.
	(loaded_dll, pull_pid_from_list): Adjust.
	(add_process, remove_process, find_process_pid)
	(get_thread_process, current_process, initialize_inferiors): New.
	* target.h (struct thread_resume) <thread>: Change type to ptid_t.
	(struct target_waitstatus) <related_pid>: Ditto.
	(struct target_ops) <kill, detach>: Add `pid' argument.  Change
	return type to int.
	(struct target_ops) <join>: Add `pid' argument.
	(struct target_ops) <thread_alive>: Change pid's type to ptid_t.
	(struct target_ops) <wait>: Add `ptid' field.  Change return type
	to ptid.
	(kill_inferior, detach_inferior, join_inferior): Add `pid' argument.
	(mywait): Add `ptid' argument.  Change return type to ptid_t.
	(target_pid_to_str): Declare.
	* target.c (set_desired_inferior): Adjust to use ptids.
	(mywait): Add new `ptid' argument.  Adjust.
	(target_pid_to_str): New.
	* mem-break.h (free_all_breakpoints): Declare.
	* mem-break.c (breakpoints): Delelete.
	(set_breakpoint_at, delete_breakpoint, find_breakpoint_at)
	(check_mem_read, check_mem_write, delete_all_breakpoints): Adjust
	to use per-process breakpoint list.
	(free_all_breakpoints): New.
	* remote-utils.c (struct sym_cache) <name>: Drop `const'.
	(symbol_cache, all_symbols_looked_up): Delete.
	(hexchars): New.
	(ishex, unpack_varlen_hex, write_ptid, hex_or_minus_one,
	read_ptid): New.
	(prepare_resume_reply): Change ptid argument's type from unsigned
	long to ptid_t.  Adjust.  Implement W;process and X;process.
	(free_sym_cache, clear_symbol_cache): New.
	(look_up_one_symbol): Adjust to per-process symbol cache.  *
	* server.c (cont_thread, general_thread, step_thread): Change type
	to ptid_t.
	(attached): Delete.
	(multi_process): New.
	(last_ptid): Change type to ptid_t.
	(struct vstop_notif) <ptid>: Change type to ptid_t.
	(queue_stop_reply, push_event): Change `ptid' argument's type to
	ptid_t.
	(discard_queued_stop_replies): Add `pid' argument.
	(start_inferior): Adjust to use ptids.  Adjust to mywait interface
	changes.  Don't reference the `attached' global.
	(attach_inferior): Adjust to mywait interface changes.
	(handle_query): Adjust to use ptids.  Parse GDB's qSupported
	features.  Handle and report "multiprocess+".  Handle
	"qAttached:PID".
	(handle_v_cont): Adjust to use ptids.  Adjust to mywait interface
	changes.
	(handle_v_kill): New.
	(handle_v_stopped): Adjust to use target_pid_to_str.
	(handle_v_requests): Allow multiple attaches and runs when
	multiprocess extensions are in effect.  Handle "vKill".
	(myresume): Adjust to use ptids.
	(queue_stop_reply_callback): Add `arg' parameter.  Handle it.
	(handle_status): Adjust to discard_queued_stop_replies interface
	change.
	(first_thread_of, kill_inferior_callback)
	(detach_or_kill_inferior_callback, join_inferiors_callback): New.
	(main): Call initialize_inferiors.  Adjust to use ptids, killing
	and detaching from all inferiors.  Handle multiprocess packet
	variants.
	* linux-low.h: Include gdb_proc_service.h.
	(struct process_info_private): New.
	(struct linux_target_ops) <pid_of>: Use ptid_get_pid.
	<lwpid_of>: Use ptid_get_lwp.
	(get_lwp_thread): Adjust.
	(struct lwp_info): Add `dead' member.
	(find_lwp_pid): Declare.
	* linux-low.c (thread_db_active): Delete.
	(new_inferior): Adjust comment.
	(inferior_pid): Delete.
	(linux_add_process): New.
	(handle_extended_wait): Adjust.
	(add_lwp): Change unsigned long to ptid.
	(linux_create_inferior): Add process to processes table.  Adjust
	to use ptids.  Don't set new_inferior here.
	(linux_attach_lwp): Rename to ...
	(linux_attach_lwp_1): ... this.  Add `initial' argument.  Handle
	it.  Adjust to use ptids.
	(linux_attach_lwp): New.
	(linux_attach): Add process to processes table.  Don't set
	new_inferior here.
	(struct counter): New.
	(second_thread_of_pid_p, last_thread_of_process_p): New.
	(linux_kill_one_lwp): Add `args' parameter.  Handle it.  Adjust to
	multiple processes.
	(linux_kill): Add `pid' argument.  Handle it.  Adjust to multiple
	processes.  Remove process from process table.
	(linux_detach_one_lwp): Add `args' parameter.  Handle it.  Adjust
	to multiple processes.
	(any_thread_of): New.
	(linux_detach): Add `pid' argument, and handle it.  Remove process
	from processes table.
	(linux_join): Add `pid' argument.  Handle it.
	(linux_thread_alive): Change unsighed long argument to ptid_t.
	Consider dead lwps as not being alive.
	(status_pending_p): Rename `dummy' argument to `arg'.  Filter out
	threads we're not interested in.
	(same_lwp, find_lwp_pid): New.
	(linux_wait_for_lwp): Change `pid' argument's type from int to
	ptid_t.  Adjust.
	(linux_wait_for_event): Rename to ...
	(linux_wait_for_event_1): ... this.  Change `pid' argument's type
	from int to ptid_t.  Adjust.
	(linux_wait_for_event): New.
	(linux_wait_1): Add `ptid' argument.  Change return type to
	ptid_t.  Adjust.  Use last_thread_of_process_p.  Remove processes
	that exit from the process table.
	(linux_wait): Add `ptid' argument.  Change return type to ptid_t.
	Adjust.
	(mark_lwp_dead): New.
	(wait_for_sigstop): Adjust to use ptids.  If a process exits while
	stopping all threads, mark its main lwp as dead.
	(linux_set_resume_request, linux_resume_one_thread): Adjust to use
	ptids.
	(fetch_register, usr_store_inferior_registers)
	(regsets_fetch_inferior_registers)
	(regsets_store_inferior_registers, linux_read_memory)
	(linux_write_memory): Inline `inferior_pid'.
	(linux_look_up_symbols): Adjust to use per-process
	`thread_db_active'.
	(linux_request_interrupt): Adjust to use ptids.
	(linux_read_auxv): Inline `inferior_pid'.
	(initialize_low): Don't reference thread_db_active.
	* gdb_proc_service.h (struct ps_prochandle) <pid>: Remove.
	* proc-service.c (ps_lgetregs): Use find_lwp_pid.
	(ps_getpid): Return the pid of the current inferior.
	* thread-db.c (proc_handle, thread_agent): Delete.
	(thread_db_create_event, thread_db_enable_reporting): Adjust to
	per-process data.
	(find_one_thread): Change argument type to ptid_t.  Adjust to
	per-process data.
	(maybe_attach_thread): Adjust to per-process data and ptids.
	(thread_db_find_new_threads): Ditto.
	(thread_db_init): Ditto.
	* spu-low.c (spu_create_inferior, spu_attach): Add process to
	processes table.  Adjust to use ptids.
	(spu_kill, spu_detach): Adjust interface.  Remove process from
	processes table.
	(spu_join, spu_thread_alive): Adjust interface.
	(spu_wait): Adjust interface.  Remove process from processes
	table.  Adjust to use ptids.
	* win32-low.c (current_inferior_tid): Delete.
	(current_inferior_ptid): New.
	(debug_event_ptid): New.
	(thread_rec): Take a ptid.  Adjust.
	(child_add_thread): Add `pid' argument.  Adjust to use ptids.
	(child_delete_thread): Ditto.
	(do_initial_child_stuff): Add `attached' argument.  Add process to
	processes table.
	(child_fetch_inferior_registers, child_store_inferior_registers):
	Adjust.
	(win32_create_inferior): Pass 0 to do_initial_child_stuff.
	(win32_attach): Pass 1 to do_initial_child_stuff.
	(win32_kill): Adjust interface.  Remove process from processes
	table.
	(win32_detach): Ditto.
	(win32_join): Adjust interface.
	(win32_thread_alive): Take a ptid.
	(win32_resume): Adjust to use ptids.
	(get_child_debug_event): Ditto.
	(win32_wait): Adjust interface.  Remove exiting process from
	processes table.
@
text
@d334 1
a334 1
  if (r == -1 || r == 0 || r > NUM_REGS)
@


1.34
log
@	Non-stop mode support.

	* server.h (non_stop): Declare.
	(gdb_client_data, handler_func): Declare.
	(delete_file_handler, add_file_handler, start_event_loop):
	Declare.
	(handle_serial_event, handle_target_event, push_event)
	(putpkt_notif): Declare.
	* target.h (enum resume_kind): New.
	(struct thread_resume): Replace `step' field by `kind' field.
	(TARGET_WNOHANG): Define.
	(struct target_ops) <wait>: Add `options' argument.
	<supports_non_stop, async, start_non_stop>: New fields.
	(target_supports_non_stop, target_async): New.
	(start_non_stop): Declare.
	(mywait): Add `options' argument.
	* target.c (mywait): Add `options' argument.  Print child exit
	notifications here.
	(start_non_stop): New.
	* server.c (non_stop, own_buf, mem_buf): New globals.
	(struct vstop_notif): New.
	(notif_queue): New global.
	(queue_stop_reply, push_event, discard_queued_stop_replies)
	(send_next_stop_reply): New.
	(start_inferior): Adjust to use resume_kind.  Adjust to mywait
	interface changes.
	(attach_inferior): In non-stop mode, don't wait for the target
	here.
	(handle_general_set): Handle QNonStop.
	(handle_query): When handling qC, return the current general
	thread, instead of the first thread of the list.
	(handle_query): If the backend supports non-stop mode, include
	QNonStop+ in the qSupported query response.
	(handle_v_cont): Adjust to use resume_kind.  Handle resume_stop
	and non-stop mode.
	(handle_v_attach, handle_v_run): Handle non-stop mode.
	(handle_v_stopped): New.
	(handle_v_requests): Report support for vCont;t.  Handle vStopped.
	(myresume): Adjust to use resume_kind.  Handle non-stop.
	(queue_stop_reply_callback): New.
	(handle_status): Handle non-stop mode.
	(main): Clear non_stop flag on reconnection.  Use the event-loop.
	Refactor serial protocol handling from here ...
	(process_serial_event): ... to this new function.  When GDB
	selects any thread, select one here.  In non-stop mode, wait until
	GDB acks all pending events before exiting.
	(handle_serial_event, handle_target_event): New.
	* remote-utils.c (remote_open): Install remote_desc in the event
	loop.
	(remote_close): Remove remote_desc from the event loop.
	(putpkt_binary): Rename to...
	(putpkt_binary_1): ... this.  Add `is_notic' argument.  Handle it.
	(putpkt_binary): New as wrapper around putpkt_binary_1.
	(putpkt_notif): New.
	(prepare_resume_reply): In non-stop mode, don't change the
	general_thread.
	* event-loop.c: New.
	* Makefile.in (OBJ): Add event-loop.o.
	(event-loop.o): New rule.

	* linux-low.h (pid_of): Moved here.
	(lwpid_of): New.
	(get_lwp_thread): Use lwpid_of.
	(struct lwp_info): Delete `lwpid' field.  Add `suspended' field.
	* linux-low.c (pid_of): Delete.
	(inferior_pid): Use lwpid_of.
	(linux_event_pipe): New.
	(target_is_async_p): New.
	(delete_lwp): New.
	(handle_extended_wait): Use lwpid_of.
	(add_lwp): Don't set lwpid field.
	(linux_attach_lwp): Adjust debug output.  Use lwpid_of.
	(linux_kill_one_lwp): If killing a running lwp, stop it first.
	Use lwpid_of.  Adjust to linux_wait_for_event interface changes.
	(linux_detach_one_lwp): If detaching from a running lwp, stop it
	first.  Adjust to linux_wait_for_event interface changes.  Use
	lwpid_of.
	(linux_detach): Don't delete the main lwp here.
	(linux_join): Use my_waitpid.  Avoid signal_pid.  Use lwpid_of.
	(status_pending_p): Don't consider explicitly suspended lwps.
	(linux_wait_for_lwp): Take an integer pid instead of a lwp_info
	pointer.  Add OPTIONS argument.  Change return type to int.  Use
	my_waitpid instead of sleeping.  Handle WNOHANG.  Use lwpid_of.
	(linux_wait_for_event): Take an integer pid instead of a lwp_info
	pointer.  Add status pointer argument.  Return a pid instead of a
	status.  Use lwpid_of.  Adjust to linux_wait_for_lwp interface
	changes.  In non-stop mode, don't switch to a random thread.
	(linux_wait): Rename to...
	(linux_wait_1): ... this.  Add target_options argument, and handle
	it.  Adjust to use resume_kind.  Use lwpid_of.  In non-stop mode,
	don't handle the continue thread.  Handle TARGET_WNOHANG.  Merge
	clean exit and signal exit code.  Don't stop all threads in
	non-stop mode.  In all-stop mode, only stop all threads when
	reporting a stop to GDB.  Handle explicit thread stop requests.
	(async_file_flush, async_file_mark): New.
	(linux_wait): New.
	(send_sigstop): Use lwpid_of.
	(wait_for_sigstop): Use lwpid_of.  Adjust to linux_wait_for_event
	interface changes.  In non-stop mode, don't switch to a random
	thread.
	(linux_resume_one_lwp): Use lwpid_of.
	(linux_continue_one_thread, linux_queue_one_thread): Merge into ...
	(linux_resume_one_thread): ... this.  Handle resume_stop.  In
	non-stop mode, don't look for pending flag in all threads.
	(resume_status_pending_p): Don't consider explicitly suspended
	threads.
	(my_waitpid): Reimplement.  Emulate __WALL.
	(linux_request_interrupt, linux_read_offsets, linux_xfer_siginfo):
	Use lwpid_of.
	(sigchld_handler, linux_supports_non_stop, linux_async)
	(linux_start_non_stop): New.
	(linux_target_ops): Register linux_supports_non_stop, linux_async
	and linux_start_non_stop.
	(initialize_low): Install SIGCHLD handler.
	* thread-db.c (thread_db_create_event, find_one_thread)
	(thread_db_get_tls_address): Use lwpid_of.
	* win32-low.c (win32_detach): Adjust to use resume_kind.
	(win32_wait): Add `options' argument.
	* spu-low.c (spu_resume): Adjust to use resume_kind.
	(spu_wait): Add `options' argument.
@
text
@d97 2
a98 2
static DWORD
current_inferior_tid (void)
d100 8
a107 2
  win32_thread_info *th = inferior_target_data (current_inferior);
  return th->tid;
d146 1
a146 1
thread_rec (DWORD id, int get_context)
d151 1
a151 1
  thread = (struct thread_info *) find_inferior_id (&all_threads, id);
d178 1
a178 1
child_add_thread (DWORD tid, HANDLE h)
d181 1
d183 1
a183 1
  if ((th = thread_rec (tid, FALSE)))
d190 1
a190 1
  add_thread (tid, th, (unsigned int) tid);
d192 1
a192 1
			      find_inferior_id (&all_threads, tid),
d214 1
a214 1
child_delete_thread (DWORD id)
d217 1
d223 2
a224 1
  thread = find_inferior_id (&all_threads, id);
d262 1
a262 1
do_initial_child_stuff (HANDLE proch, DWORD pid)
d275 1
d333 1
a333 1
  win32_thread_info *th = thread_rec (current_inferior_tid (), TRUE);
d347 1
a347 1
  win32_thread_info *th = thread_rec (current_inferior_tid (), TRUE);
d553 1
a553 1
  do_initial_child_stuff (pi.hProcess, pi.dwProcessId);
d584 1
a584 1
	  do_initial_child_stuff (h, pid);
d652 2
a653 2
static void
win32_kill (void)
d655 2
d658 1
a658 1
    return;
d677 4
d683 1
a683 1
/* Detach from all inferiors.  */
d685 1
a685 1
win32_detach (void)
d687 1
d704 1
a704 1
    resume.thread = -1;
d714 2
d723 1
a723 1
win32_join (void)
d725 1
a725 3
  extern unsigned long signal_pid;

  HANDLE h = OpenProcess (PROCESS_ALL_ACCESS, FALSE, signal_pid);
d735 1
a735 1
win32_thread_alive (unsigned long tid)
d741 1
a741 1
  if (find_inferior_id (&all_threads, tid) != NULL)
d758 1
d763 1
a763 1
  if (n == 1 && resume_info[0].thread == -1)
d772 1
a772 1
  if (resume_info[0].thread != -1)
d798 2
a799 1
  th = thread_rec (current_event.dwThreadId, FALSE);
d1317 2
d1373 1
d1375 1
a1375 2
    (struct thread_info *) find_inferior_id (&all_threads,
					     current_event.dwThreadId);
d1386 3
a1388 2
      child_add_thread (current_event.dwThreadId,
			     current_event.u.CreateThread.hThread);
d1396 2
a1397 1
      child_delete_thread (current_event.dwThreadId);
d1414 2
a1415 1
      child_add_thread (main_thread_id,
d1418 1
a1418 1
      ourstatus->value.related_pid = current_event.dwThreadId;
d1494 1
a1494 2
    (struct thread_info *) find_inferior_id (&all_threads,
					     current_event.dwThreadId);
d1501 2
a1502 2
static unsigned long
win32_wait (struct target_waitstatus *ourstatus, int options)
d1504 2
d1517 2
d1520 1
a1520 1
	  return current_event.dwProcessId;
d1542 1
a1542 1
	  return current_event.dwThreadId;
@


1.33
log
@	Decouple target code from remote protocol.

	* target.h (enum target_waitkind): New.
	(struct target_waitstatus): New.
	(struct target_ops) <wait>: Return an unsigned long.  Take a
	target_waitstatus pointer instead of a char pointer.
	(mywait): Likewise.
	* target.c (mywait): Change prototype to return an unsigned long.
	Take a target_waitstatus pointer instead of a char pointer.  Adjust.
	* server.h (thread_from_wait, old_thread_from_wait): Delete
	declarations.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.
	* server.c (thread_from_wait, old_thread_from_wait): Delete.
	(last_status, last_ptid): New.
	(start_inferior): Remove "statusptr" argument.  Adjust.  Return a
	pid instead of a signal.
	(attach_inferior): Remove "status" and "signal" parameters.
	Adjust.
	(handle_query): For qGetTLSAddr, parse the thread id with strtol,
	not as an address.
	(handle_v_cont, handle_v_attach, handle_v_run, handle_v_kill)
	(handle_v_requests, myresume): Remove "status" and "signal"
	parameters.  Adjust.
	(handle_status): New.
	(main): Delete local `status'.  Adjust.
	* remote-utils.c: Include target.h.
	(prepare_resume_reply): Change prototype to take a
	target_waitstatus.  Adjust.

	* linux-low.c (linux_wait): Adjust to new target_ops->wait
	interface.
	* spu-low.c (spu_wait): Adjust.
	* win32-low.c (enum target_waitkind, struct target_waitstatus):
	Delete.
	(win32_wait): Adjust.
@
text
@d688 1
a688 1
    resume.step = 0;
d757 1
a757 1
      step = resume_info[0].step;
d1479 1
a1479 1
win32_wait (struct target_waitstatus *ourstatus)
@


1.32
log
@	* target.h (struct thread_resume): Delete leave_stopped member.
	(struct target_ops): Add a `n' argument to the `resume' callback.
	* server.c (start_inferior): Adjust.
	(handle_v_cont, myresume): Adjust.
	* linux-low.c (check_removed_breakpoint): Adjust to resume
	interface change, and to removed leave_stopped field.
	(resume_ptr): Delete.
	(struct thread_resume_array): New.
	(linux_set_resume_request): Add new `arg' parameter.  Adjust to
	resume interface change.
	(linux_continue_one_thread, linux_queue_one_thread)
	(resume_status_pending_p): Check if the resume field is NULL
	instead of checking the leave_stopped member.
	(linux_resume): Adjust to the target resume interface change.
	* spu-low.c (spu_resume): Adjust to the target resume interface
	change.
	* win32-low.c (win32_detach, win32_resume): Ditto.
@
text
@a243 39
/* Generally, what has the program done?  */
enum target_waitkind
{
  /* The program has exited.  The exit status is in value.integer.  */
  TARGET_WAITKIND_EXITED,

  /* The program has stopped with a signal.  Which signal is in
     value.sig.  */
  TARGET_WAITKIND_STOPPED,

  /* The program is letting us know that it dynamically loaded
     or unloaded something.  */
  TARGET_WAITKIND_LOADED,

  /* The program has exec'ed a new executable file.  The new file's
     pathname is pointed to by value.execd_pathname.  */
  TARGET_WAITKIND_EXECD,

  /* Nothing interesting happened, but we stopped anyway.  We take the
     chance to check if GDB requested an interrupt.  */
  TARGET_WAITKIND_SPURIOUS,
};

struct target_waitstatus
{
  enum target_waitkind kind;

  /* Forked child pid, execd pathname, exit status or signal number.  */
  union
  {
    int integer;
    enum target_signal sig;
    int related_pid;
    char *execd_pathname;
    int syscall_id;
  }
  value;
};

d1478 2
a1479 2
static unsigned char
win32_wait (char *status)
a1480 4
  struct target_waitstatus our_status;

  *status = 'T';

d1483 1
a1483 1
      if (!get_child_debug_event (&our_status))
d1486 1
a1486 1
      switch (our_status.kind)
d1490 1
a1490 1
		    our_status.value.integer));
a1491 1
	  *status = 'W';
d1493 1
a1493 1
	  return our_status.value.integer;
a1498 2
	  *status = 'T';

d1501 1
a1501 1
	  if (our_status.kind == TARGET_WAITKIND_LOADED
d1510 6
a1515 1
	  return our_status.value.sig;
d1517 1
a1517 1
	  OUTMSG (("Ignoring unknown internal event, %d\n", our_status.kind));
@


1.31
log
@	* i387-fp.c, linux-arm-low.c, linux-cris-low.c,
	linux-crisv32-low.c, linux-i386-low.c, linux-low.c,
	linux-mips-low.c, linux-s390-low.c, linux-sparc-low.c,
	linux-x86-64-low.c, linux-xtensa-low.c, proc-service.c,
	regcache.c, remote-utils.c, server.c, spu-low.c, target.h,
	thread-db.c, win32-low.c, xtensa-xtregs.c, gdbreplay.c,
	Makefile.in, configure.ac: Fix whitespace throughout.
	* configure: Regenerate.
@
text
@d93 1
a93 1
static void win32_resume (struct thread_resume *resume_info);
d729 1
a729 2
    resume.leave_stopped = 0;
    win32_resume (&resume);
d773 1
a773 1
win32_resume (struct thread_resume *resume_info)
d784 1
a784 1
  if (resume_info[0].thread == -1)
d786 1
a786 1
  else if (resume_info[1].thread == -1 && !resume_info[1].leave_stopped)
@


1.30
log
@	* win32-low.c (get_child_debug_event): Issue a final DBG_CONTINUE
	when handling a EXIT_PROCESS_DEBUG_EVENT.
@
text
@d461 9
a469 9
                        wargs,    /* command line */
                        NULL,     /* security, not supported */
                        NULL,     /* thread, not supported */
                        FALSE,    /* inherit handles, not supported */
                        flags,    /* start flags */
                        NULL,     /* environment, not supported */
                        NULL,     /* current directory, not supported */
                        NULL,     /* start info, not supported */
                        pi);      /* proc info */
d540 1
a540 1
         handle this?  */
d612 1
a612 1
 	  attaching = 1;
d645 1
a645 1
         in Unicode.  */
d698 1
a698 1
  	  struct target_waitstatus our_status = { 0 };
d700 1
a700 1
  	}
d1245 1
a1245 1
                         .u.Exception.ExceptionRecord.ExceptionAddress);
d1357 12
a1368 12
 	 stop the inferior, we flush all currently pending debug
 	 events -- the thread list and the dll list are always
 	 reported immediatelly without delay, then, we suspend all
 	 threads and pretend we saw a trap at the current PC of the
 	 main thread.

 	 Contrary to desktop Windows, Windows CE *does* report the dll
 	 names on LOAD_DLL_DEBUG_EVENTs resulting from a
 	 DebugActiveProcess call.  This limits the way we can detect
 	 if all the dlls have already been reported.  If we get a real
 	 debug event before leaving attaching, the worst that will
 	 happen is the user will see a spurious breakpoint.  */
d1372 5
a1376 5
 	{
 	  OUTMSG2(("no attach events left\n"));
 	  fake_breakpoint_event ();
 	  attaching = 0;
 	}
d1378 1
a1378 1
 	OUTMSG2(("got attach event\n"));
d1384 2
a1385 2
 	 interruption, but high enough so gdbserver doesn't become a
 	 bottleneck.  */
d1387 1
a1387 1
 	return 0;
d1540 1
a1540 1
 	case TARGET_WAITKIND_LOADED:
d1558 1
a1558 1
 	default:
d1560 3
a1562 3
 	  /* fall-through */
 	case TARGET_WAITKIND_SPURIOUS:
 	case TARGET_WAITKIND_EXECD:
@


1.29
log
@        Updated copyright notices for most files.
@
text
@d1456 1
@


1.28
log
@	* utils.c (xmalloc,xcalloc,xstrdup): New fns.
	* server.h (ATTR_MALLOC): New macro.
	(xmalloc,xcalloc,xstrdup): Declare.
	* hostio.c: Replace malloc,calloc,strdup with xmalloc,xcalloc,xstrdup.
	* inferiors.c: Ditto.
	* linux-low.c: Ditto.
	* mem-break.c: Ditto.
	* regcache.c: Ditto.
	* remote-utils.c: Ditto.
	* server.c: Ditto.
	* target.c: Ditto.
	* win32-low.c: Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.27
log
@ChangeLog:

	* features/Makefile (%.dat): Emit xmltarget statement.

	* regformats/regdat.sh: Support xmltarget and xmlarch statments.
	Generate code to set gdbserver_xmltarget in init_registers_${name}.

	* regformats/arm-with-iwmmxt.dat: Regenerate.
	* regformats/mips64-linux.dat: Regenerate.
	* regformats/mips-linux.dat: Regenerate.
	* regformats/rs6000/powerpc-32.dat: Regenerate.
	* regformats/rs6000/powerpc-64.dat: Regenerate.
	* regformats/rs6000/powerpc-e500.dat: Regenerate.

	* regformats/reg-arm.dat: Add xmlarch statement.
	* regformats/reg-i386.dat: Likewise.
	* regformats/reg-i386-linux.dat: Likewise.
	* regformats/reg-x86-64-linux.dat: Likewise.
	* regformats/reg-spu.dat: Likewise.

gdbserver/ChangeLog:

	* regcache.h (gdbserver_xmltarget): Add extern declaration.
	* server.c (gdbserver_xmltarget): Define.
	(get_features_xml): Use it to replace "target.xml" and arch_string.

	* configure.srv: Remove srv_xmltarget.  Add XML files that were
	mentioned there to srv_xmlfiles instead.  Remove conditional tests
	on gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe; set
	srv_xmlfiles and srv_regobj to include all possible choices.
	* configure.ac (srv_xmltarget): Remove.
	(srv_xmlfiles): Do not add "target.xml".
	(gdb_cv_arm_iwmmxt, gdb_cv_ppc_altivec, gdb_cv_ppc_spe): Remove
	checks for supplementary target information.
	* configure: Regenerate.
	* Makefile.in (XML_TARGET): Remove.
	(target.xml): Remove rule.
	(clean): Do not clean up target.xml.
	(.PRECIOUS): Do not mention target.xml.

	* target.h (struct target_ops): Remove arch_string member.
	* linux-low.c (linux_arch_string): Remove.
	(linux_target_ops): Remove arch_string initializer.
	* linux-low.h (struct linux_target_ops): Remove arch_string member.
	* linux-i386-low.c (the_low_target): Remove arch_string initializer.
	* linux-x86-64-low.c (the_low_target): Remove arch_string initializer.
	* spu-low.c (spu_arch_string): Remove.
	(spu_target_ops): Remove arch_string initializer.
	* win32-low.c (win32_arch_string): Remove.
	(win32_target_ops): Remove arch_string initializer.
	* win32-low.h (struct win32_target_ops): Remove arch_string member.
	* win32-arm-low.c (the_low_target): Remove arch_string initializer.
	* win32-i368-low.c (the_low_target): Remove arch_string initializer.
@
text
@d179 1
a179 1
  th = calloc (1, sizeof (*th));
@


1.26
log
@gdb/ChangeLog:

	* regformats/regdat.sh: Rename init_registers function in
	generated file to init_registers_${name}.

	* regformats/reg-crisv32.dat: Set "name" to crisv32.
	* regformats/reg-ppc64.dat: Set "name" to ppc64.
	* regformats/reg-s390x.dat: Set "name" to s390x.

gdbserver/ChangeLog:

	* server.h (init_registers): Remove prototype.

	* linux-low.h (struct linux_target_ops): Add arch_setup field.
	* linux-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* linux-arm-low.c (init_registers_arm): Add prototype.
	(init_registers_arm_with_iwmmxt): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-cris-low.c (init_registers_cris): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-crisv32-low.c (init_registers_crisv32): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-i386-low.c (init_registers_i386_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ia64-low.c (init_registers_ia64): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m32r-low.c (init_registers_m32r): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-m68k-low.c (init_registers_m68k): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-mips-low.c (init_registers_mips_linux): Add prototype.
	(init_registers_mips64_linux): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc-low.c (init_registers_ppc): Add prototype.
	(init_registers_powerpc_32, init_registers_powerpc_e500): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-ppc64-low.c (init_registers_ppc64): Add prototype.
	(init_registers_powerpc_64): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-s390-low.c (init_registers_s390): Add prototype.
	(init_registers_s390x): Likewise.
	(the_low_target): Add initializer for arch_setup field.
	* linux-sh-low.c (init_registers_sh): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-x86-64-low.c (init_registers_x86_64_linux): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* linux-xtensa-low.c (init_registers_xtensa): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* win32-low.h (struct win32_target_ops): Add arch_setup field.
	* win32-low.c (initialize_low): Call the_low_target.arch_setup ()
	instead of init_registers ().
	* win32-arm-low.c (init_registers_arm): Add prototype.
	(the_low_target): Add initializer for arch_setup field.
	* win32-i386-low.c (init_registers_i386): Add prototype.
	(the_low_target): Add initializer for arch_setup field.

	* spu-low.c (init_registers_spu): Add prototype.
	(initialize_low): Call initialie_registers_spu () instead of
	initialize_registers ().
@
text
@a1638 6
static const char *
win32_arch_string (void)
{
  return the_low_target.arch_string;
}

a1719 1
  win32_arch_string,
@


1.25
log
@	* win32-low.c (do_initial_child_stuff): Add process handle
	parameter.  Set current_process_handle and current_process_id from the
	parameters. Clear globals.
	(win32_create_inferior): Don't set current_process_handle and
	current_process_id here.  Instead pass them on the call to
	do_initial_child_stuff.
	(win32_attach): Likewise.
	(win32_clear_inferiors): New.
	(win32_kill): Don't close the current process handle or the
	current thread handle here.  Instead call win32_clear_inferiors.
	(win32_detach): Don't open a new handle to the process.  Call
	win32_clear_inferiors.
	(win32_join): Don't rely on current_process_handle; open a new
	handle using the process id.
	(win32_wait): Call win32_clear_inferiors when the inferior process
	has exited.
@
text
@d1743 1
a1743 1
  init_registers ();
@


1.24
log
@	* hostio.c: Don't include errno.h.
	(errno_to_fileio_errno): Move to hostio-errno.
	* hostio.c: (hostio_error): Remove the error parameter.  Defer the
	error number outputting to the target->hostio_last_error callback.
	(hostio_packet_error): Use FILEIO_EINVAL directly.
	(handle_open, handle_pread, hostio_error, handle_unlink): Update
	calls to hostio_error.
	* hostio-errno.c: New.
	* server.h (hostio_last_error_from_errno): Declare.
	* target.h (target_ops): Add hostio_last_error member.
	* linux-low.c (linux_target_op): Register hostio_last_error_from_errno
	as hostio_last_error handler.
	* spu-low.c (spu_target_ops): Likewise.
	* win32-low.c [_WIN32_WCE] (win32_error_to_fileio_error)
	(wince_hostio_last_error): New functions.
	(win32_target_ops) [_WIN32_WCE]: Register wince_hostio_last_error
	as hostio_last_error handler.
	(win32_target_ops) [!_WIN32_WCE]: Register
	hostio_last_error_from_errno as hostio_last_error handler.
	* Makefile.in (SFILES): Add hostio.c and hostio-errno.c.
	(hostio-errno.o): New rule.
	* configure.ac (GDBSERVER_DEPFILES): Add $srv_hostio_err_objs.
	* configure.srv (srv_hostio_err_objs): New variable.  Default to
	hostio-errno.o.
	(arm*-*-mingw32ce*): Set srv_hostio_err_objs to "".
	* configure: Regenerate.
@
text
@d72 1
a92 2
static DWORD main_thread_id = 0;

d292 1
a292 1
do_initial_child_stuff (DWORD pid)
d296 7
d582 1
a582 4
  current_process_handle = pi.hProcess;
  current_process_id = pi.dwProcessId;

  do_initial_child_stuff (current_process_id);
d613 1
a613 3
	  current_process_handle = h;
	  current_process_id = pid;
	  do_initial_child_stuff (pid);
d670 10
a683 2
  win32_thread_info *current_thread;

d703 1
a703 8
  CloseHandle (current_process_handle);

  current_thread = inferior_target_data (current_inferior);
  if (current_thread && current_thread->h)
    {
      /* This may fail in an attached process, so don't check.  */
      (void) CloseHandle (current_thread->h);
    }
a709 2
  HANDLE h;

a723 10
  /* We need a new handle, since DebugActiveProcessStop
     closes all the ones that came through the events.  */
  if ((h = OpenProcess (PROCESS_ALL_ACCESS,
			FALSE,
			current_process_id)) == NULL)
    {
      /* The process died.  */
      return -1;
    }

d734 2
a735 4
    {
      CloseHandle (h);
      return -1;
    }
d738 1
a738 1
  current_process_handle = h;
d746 1
a746 3
  if (current_process_id == 0
      || current_process_handle == NULL)
    return;
d748 6
a753 5
  WaitForSingleObject (current_process_handle, INFINITE);
  CloseHandle (current_process_handle);

  current_process_handle = NULL;
  current_process_id = 0;
d1536 1
@


1.23
log
@	Updated copyright notices for most files.
@
text
@d24 1
d1657 59
d1738 7
a1744 1
  win32_arch_string
@


1.22
log
@	* linux-low.c (linux_wait_for_event): Update messages.  Do not
	reinsert auto-delete breakpoints.
	* mem-break.c (struct breakpoint): Change return type of handler to
	int.
	(set_breakpoint_at): Update handler type.
	(reinsert_breakpoint_handler): Return 1 instead of calling
	delete_breakpoint.
	(reinsert_breakpoint_by_bp): Check for the original breakpoint before
	setting a new one.
	(check_breakpoints): Delete auto-delete breakpoints and return 2.
	* mem-break.h (set_breakpoint_at): Update handler type.
	* thread-db.c (thread_db_create_event, thread_db_create_event): Update.
	* win32-low.c (auto_delete_breakpoint): New.
	(get_child_debug_event): Use it.
@
text
@d2 1
a2 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.21
log
@	* win32-low.c (attaching): New global.
	(win32_create_inferior): Clear the `attaching' global.
	(win32_attach): Set the `attaching' global.
	(get_child_debug_event) [_WIN32_WCE]: Stop the inferior when
	attaching.  Only set a breakpoint at the entry point if not
	attaching.
@
text
@d1337 8
d1456 1
a1456 1
			     delete_breakpoint_at);
@


1.20
log
@	* win32-low.c (win32_attach): Call OpenProcess before
	DebugActiveProcess, not after.  Add last error output to error
	call.
@
text
@d68 1
d502 3
d607 2
d1355 38
a1392 5
  /* Keep the wait time low enough for confortable remote
     interruption, but high enough so gdbserver doesn't become a
     bottleneck.  */
  if (!WaitForDebugEvent (&current_event, 250))
    return 0;
d1440 10
a1449 6
      /* Windows CE doesn't set the initial breakpoint automatically
	 like the desktop versions of Windows do.  We add it explicitly
	 here.  It will be removed as soon as it is hit.  */
      set_breakpoint_at ((CORE_ADDR) (long) current_event.u
			 .CreateProcessInfo.lpStartAddress,
			 delete_breakpoint_at);
@


1.19
log
@	* win32-low.c (win32_get_thread_context)
	(win32_set_thread_context): New functions.
	(thread_rec): Use win32_get_thread_context.
	(continue_one_thread, win32_resume): Use win32_set_thread_context.
	* win32-low.h (win32_thread_info) [_WIN32_WCE]: Add `base_context'
	field.
@
text
@d585 1
a585 1
  winapi_DebugActiveProcessStop DebugActiveProcessStop = NULL;
d587 1
a592 1
  DebugActiveProcessStop = GETPROCADDRESS (dll, DebugActiveProcessStop);
d595 2
a596 1
  if (DebugActiveProcess (pid))
d598 4
a601 2
      if (DebugSetProcessKillOnExit != NULL)
 	DebugSetProcessKillOnExit (FALSE);
d603 5
a607 1
      current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE, pid);
d609 1
a609 8
      if (current_process_handle != NULL)
 	{
 	  current_process_id = pid;
 	  do_initial_child_stuff (pid);
 	  return 0;
 	}
      if (DebugActiveProcessStop != NULL)
	DebugActiveProcessStop (current_process_id);
d612 3
a614 1
  error ("Attach to process failed.");
@


1.18
log
@	* win32-low.c (soft_interrupt_requested, faked_breakpoint): New
	global variables.
	(child_add_thread): Minor cleanup.
	(child_continue): Resume artificially suspended threads before
	calling ContinueDebugEvent.
	(suspend_one_thread): New.
	(fake_breakpoint_event): New.
	(get_child_debug_event): Change return type to int.  Check here if
	gdb sent an interrupt request.  If a soft interrupt was requested,
	fake a breakpoint event.  Return 0 if there is no event to handle,
	and 1 otherwise.
	(win32_wait): Don't check here if gdb sent an interrupt request.
	Ensure there is a valid event to handle.
	(win32_request_interrupt): Add soft interruption method as last
	resort.
@
text
@d103 33
d163 1
a163 1
      (*the_low_target.get_thread_context) (th, &current_event);
d317 1
a317 1
	  (*the_low_target.set_thread_context) (th, &current_event);
d842 1
a842 1
	  (*the_low_target.set_thread_context) (th, &current_event);
@


1.17
log
@	* win32-low.h (win32_thread_info): Add descriptions to the
	structure members.  Replace `suspend_count' counter by a
	`suspended' flag.
	* win32-low.c (thread_rec): Update condition of when to get the
	context from the inferior.  Rely on ContextFlags being set if it
	has already been retrieved.  Only suspend the inferior thread if
	we haven't already.  Warn if that fails.
	(continue_one_thread): s/suspend_count/suspended/.  Only call
	ResumeThread once.  Warn if that fails.
@
text
@d75 8
d145 1
a145 2
  th = (win32_thread_info *) malloc (sizeof (*th));
  memset (th, 0, sizeof (*th));
d303 9
a311 6
  BOOL res;

  res = ContinueDebugEvent (current_event.dwProcessId,
			    current_event.dwThreadId, continue_status);
  if (res)
    find_inferior (&all_threads, continue_one_thread, &thread_id);
d313 1
a313 1
  return res;
d1260 36
d1297 2
a1298 1
static void
a1300 2
  BOOL debug_event;

d1304 17
a1320 4
  /* Keep the wait time low enough for confortable remote interruption,
     but high enough so gdbserver doesn't become a bottleneck.  */
  if (!(debug_event = WaitForDebugEvent (&current_event, 250)))
    return;
d1437 1
d1452 2
a1453 4
      /* Check if GDB sent us an interrupt request.  */
      check_remote_input_interrupt_request ();

      get_child_debug_event (&our_status);
d1560 2
a1561 1
  OUTMSG (("Could not interrupt process.\n"));
@


1.16
log
@	* win32-low.c (win32_wait): Don't read from the inferior when it
	has already exited.
@
text
@d108 1
a108 1
  if (!th->suspend_count && get_context)
d110 11
a120 2
      if (id != current_event.dwThreadId)
	th->suspend_count = SuspendThread (th->h) + 1;
a270 1
  int i;
d273 1
a273 1
      && th->suspend_count)
d281 7
a287 3
      for (i = 0; i < th->suspend_count; i++)
	(void) ResumeThread (th->h);
      th->suspend_count = 0;
@


1.15
log
@	* win32-low.c (create_process): New.
	(win32_create_inferior): Use create_process instead of
	CreateProcess.  If create_process failed retry appending an ".exe"
	suffix.  Store the GetLastError result immediatelly after
	create_process calls and use it on the call to error.
@
text
@a1392 3

	  child_fetch_inferior_registers (-1);

@


1.14
log
@	* win32-low.c (handle_load_dll): Don't use toolhelp when waiting.
@
text
@d376 49
d444 1
a444 6
#ifndef __MINGW32CE__
  STARTUPINFOA si = { sizeof (STARTUPINFOA) };
  char *winenv = NULL;
#else
  wchar_t *wargs, *wprogram;
#endif
d484 9
a492 28
#ifdef __MINGW32CE__
  to_back_slashes (program);
  wargs = alloca (argslen * sizeof (wchar_t));
  mbstowcs (wargs, args, argslen);
  wprogram = alloca ((strlen (program) + 1) * sizeof (wchar_t));
  mbstowcs (wprogram, program, strlen (program) + 1);
  ret = CreateProcessW (wprogram, /* image name */
                        wargs,    /* command line */
                        NULL,     /* security, not supported */
                        NULL,     /* thread, not supported */
                        FALSE,    /* inherit handles, not supported */
                        flags,    /* start flags */
                        NULL,     /* environment, not supported */
                        NULL,     /* current directory, not supported */
                        NULL,     /* start info, not supported */
                        &pi);     /* proc info */
#else
  ret = CreateProcessA (program,  /* image name */
			args,     /* command line */
			NULL,     /* security */
			NULL,     /* thread */
			TRUE,     /* inherit handles */
			flags,    /* start flags */
			winenv,   /* environment */
			NULL,     /* current directory */
			&si,      /* start info */
			&pi);     /* proc info */
#endif
a500 1
      DWORD err = GetLastError ();
@


1.13
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1069 12
a1080 3
  if (!psapi_get_dll_name ((DWORD) (event->lpBaseOfDll), dll_buf)
      && !toolhelp_get_dll_name ((DWORD) (event->lpBaseOfDll), dll_buf))
    dll_buf[0] = dll_buf[sizeof (dll_buf) - 1] = '\0';
@


1.12
log
@	* win32-low.c (winapi_CloseToolhelp32Snapshot) [_WIN32_WCE]: New
	typedef.
	(win32_CloseToolhelp32Snapshot) [_WIN32_WCE]: New global var.
	(load_toolhelp) [_WIN32_WCE]: Load TOOLHELP.DLL.  Get
	CloseToolhelp32Snapshot.
	(toolhelp_get_dll_name) [_WIN32_WCE]: Close the snapshot with
	CloseToolhelp32Snapshot.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.11
log
@2007-07-17  Pedro Alves  <pedro_alves@@portugalmail.pt>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/i386/cygwin.mt (TDEPFILES): Add solib-target.o.
	* coff-pe-read.c (read_pe_exported_syms): Delete verbose
	printf.
	* NEWS: Mention gdbserver DLL support.

	* gdb.base/unload.c (dlopen, dlsym, dlclose, dlerror): Define
	for __WIN32__.
	(SHLIB_NAME): Delete definition.  Always pass dlerror to fprintf.
	* gdb.base/unload.exp: Use shared library test routines.

	* inferiors.c (all_dlls, dlls_changed, get_dll): New.
	(add_thread): Minor cleanups.
	(clear_inferiors): Move lower in the file.  Clear the DLL
	list.
	(free_one_dll, match_dll, loaded_dll, unloaded_dll, clear_list): New.
	* remote-utils.c (prepare_resume_reply): Check dlls_changed.
	(xml_escape_text): New.
	* server.c (handle_query): Handle qXfer:libraries:read.  Report it
	for qSupported.
	(handle_v_cont): Report errors.
	(gdbserver_version): Update.
	(main): Correct size of own_buf.  Do not report initial DLL events.
	* server.h (struct dll_info, all_dlls, dlls_changed, loaded_dll)
	(unloaded_dll, xml_escape_text): New.
	* win32-low.c (enum target_waitkind): Update comments.
	(win32_add_one_solib, get_image_name, winapi_EnumProcessModules)
	(winapi_GetModuleInformation, winapi_GetModuleFileNameExA)
	(win32_EnumProcessModules, win32_GetModuleInformation)
	(win32_GetModuleFileNameExA, load_psapi, psapi_get_dll_name)
	(winapi_CreateToolhelp32Snapshot, winapi_Module32First)
	(winapi_Module32Next, win32_CreateToolhelp32Snapshot)
	(win32_Module32First, win32_Module32Next, load_toolhelp)
	(toolhelp_get_dll_name, handle_load_dll, handle_unload_dll): New.
	(get_child_debug_event): Handle DLL events.
	(win32_wait): Likewise.
@
text
@d983 4
d1000 1
a1000 1
      dll = GetModuleHandle (_T("COREDLL.DLL"));
d1009 4
d1017 5
a1021 1
	  && win32_Module32Next != NULL);
d1029 1
d1040 4
a1043 6
  if (!win32_Module32First (snapshot_module, &modEntry))
    goto failed;

  while (win32_Module32Next (snapshot_module, &modEntry))
    if ((DWORD) modEntry.modBaseAddr == BaseAddress)
      {
d1045 1
a1045 1
	wcstombs (dll_name_ret, modEntry.szExePath, MAX_PATH + 1);
d1047 1
a1047 1
	strcpy (dll_name_ret, modEntry.szExePath);
d1049 3
a1051 3
	CloseHandle (snapshot_module);
	return 1;
      }
d1053 3
a1055 1
failed:
d1057 2
a1058 1
  return 0;
@


1.10
log
@	* win32-low.c (handle_output_debug_string): Ignore event if not
	waiting.
@
text
@d32 1
d206 2
a207 2
  /* The program is letting us know that it dynamically loaded something
     (e.g. it called load(2) on AIX).  */
d777 310
d1277 1
d1280 1
a1280 1
      ourstatus->value.integer = 0;
d1288 3
d1353 1
d1361 9
a1374 1
 	case TARGET_WAITKIND_LOADED:
@


1.9
log
@	* server.h (check_remote_input_interrupt_request): New function.
	* remote_utils.c (INVALID_DESCRIPTOR): New define.
	(remote_desc): Initialize with INVALID_DESCRIPTOR.
	(input_interrupt): Expose on USE_WIN32API too.  Fix whitespace.
	(check_remote_input_interrupt_request): New function.
	* server.h (check_remote_input_interrupt_request): Declare.

	* win32-low.(winapi_DebugBreakProcess,
	winapi_GenerateConsoleCtrlEvent): New typedefs.
	(get_child_debug_event): Lower Win32 debug event polling from 1 sec
	to 250 ms.
	(win32_wait): Check for remote interrupt request
	with check_remote_input_interrupt_request.
	(win32_request_interrupt): New function.
	(win32_target_op): Set request_interrupt to win32_request_interrupt.
@
text
@d570 9
a578 1
    monitor_output (s);
@


1.8
log
@	* win32-low.c (debug_registers_changed,
	debug_registers_used, CONTEXT_EXTENDED_REGISTERS,
	CONTEXT_FLOATING_POINT, CONTEXT_DEBUG_REGISTERS,
	CONTEXT_DEBUGGER, CONTEXT_DEBUGGER_DR): Delete.
	(thread_rec): Get context using the low target.
	(child_add_thread): Call thread_added on the low target,
	which does the same thing.
	(regptr): Delete.
	(do_initial_child_stuff): Remove debug registers references.
	Set context using the low target.  Resume threads after
	setting the contexts.
	(child_continue): Remove dead variable.  Remove debug
	registers references.
	(child_fetch_inferior_registers): Go through the low target.
	(do_child_store_inferior_registers): Remove.
	(child_store_inferior_registers): Go through the low target.
	(win32_resume): Remove debug registers references.
	Set context using the low target.
	(handle_exception): Change return type to void.  Don't record
	context here.  Set status to TARGET_WAITKIND_SPURIOUS on a
	first chance exception.
	(get_child_debug_event): Change return type to void.  Remove
	goto loop.  Always return after waiting for debug event.
	(win32_wait): Convert to switch statement.  Handle spurious
	events.

	* win32-i386-low.c (debug_registers_changed,
	debug_registers_used): New.
	(initial_stuff): Rename to ...
	(i386_initial_stuff): ... this.  Clear debug registers
	state variables.
	(store_debug_registers): Delete.
	(i386_get_thread_context): New.
	(load_debug_registers): Delete.
	(i386_set_thread_context): New.
	(i386_thread_added): New.
	(single_step): Rename to ...
	(i386_single_step): ... this.
	(do_fetch_inferior_registers): Rename to ...
	(i386_fetch_inferior_register): ... this.
	(i386_store_inferior_register): New.
	(the_low_target): Adapt to new interface.

	* win32-arm-low.c (CONTEXT_FLOATING_POINT): Define.
	(arm_get_thread_context): New.
	(arm_set_thread_context): New.
	(regptr): New.
	(do_fetch_inferior_registers): Rename to ...
	(arm_fetch_inferior_register): ... this.
	(arm_store_inferior_register): New.
	(arm_wince_breakpoint): Reimplement as unsigned long.
	(arm_wince_breakpoint_len): Define.
	(the_low_target): Adapt to new interface.

	* win32-low.h (target_ops): Remove regmap, store_debug_registers and
	load_debug_registers.  Add get_thread_context, set_thread_context,
	thread_added and store_inferior_register.  Rename
	fetch_inferior_registers to fetch_inferior_register.
	(regptr): Remove declaration.
@
text
@d80 2
d213 2
a214 3
  /* Nothing happened, but we stopped anyway.  This perhaps should be handled
     within target_wait, but I'm not sure target_wait should be resuming the
     inferior.  */
d883 3
a885 1
  if (!(debug_event = WaitForDebugEvent (&current_event, 1000)))
d1013 3
d1087 33
d1140 1
a1140 1
  NULL,
@


1.7
log
@	* target.h (target_ops): Change return type of detach to int.
	Add join.
	(join_inferior): New.
	* server.c (main): Don't skip detach support on mingw32.
	If the inferior doesn't support detaching return error.
	Call join_inferior instead of using waitpid.
	* linux-low.c (linux_join): New.
	(linux_target_op): Add linux_join.
	* spu-low.c (spu_join): New.
	(spu_target_ops): Add spu_join.
	* win32-low.c (win32_detach): Adapt to new interface.
	Reopen current_process_handle before detaching.  Issue a child
	resume before detaching.
	(win32_join): New.
	(win32_target_op): Add win32_join.
@
text
@a75 3
static int debug_registers_changed = 0;
static int debug_registers_used = 0;

d81 1
a81 7
#ifndef CONTEXT_EXTENDED_REGISTERS
#define CONTEXT_EXTENDED_REGISTERS 0
#endif

#ifndef CONTEXT_FLOATING_POINT
#define CONTEXT_FLOATING_POINT 0
#endif
d83 1
a83 9
#ifndef CONTEXT_DEBUG_REGISTERS
#define CONTEXT_DEBUG_REGISTERS 0
#endif

#define CONTEXT_DEBUGGER (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
#define CONTEXT_DEBUGGER_DR CONTEXT_DEBUGGER | CONTEXT_DEBUG_REGISTERS	\
  | CONTEXT_EXTENDED_REGISTERS

static DWORD main_thread_id = 0;
d109 1
a109 1
      if (get_context > 0 && id != current_event.dwThreadId)
a110 2
      else if (get_context < 0)
	th->suspend_count = -1;
d112 1
a112 10
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;

      GetThreadContext (th->h, &th->context);

      if (id == current_event.dwThreadId)
	{
	  /* Copy dr values from that thread.  */
	  if (the_low_target.store_debug_registers != NULL)
	    (*the_low_target.store_debug_registers) (th);
	}
d137 2
a138 14
  /* Set the debug registers for the new thread if they are used.  */
  if (debug_registers_used
      && the_low_target.load_debug_registers != NULL)
    {
      /* Only change the value of the debug registers.  */
      th->context.ContextFlags = CONTEXT_DEBUGGER_DR;

      GetThreadContext (th->h, &th->context);

      (*the_low_target.load_debug_registers) (th);

      SetThreadContext (th->h, &th->context);
      th->context.ContextFlags = 0;
    }
a208 1

a232 19
/* Return a pointer into a CONTEXT field indexed by gdb register number.
   Return a pointer to an dummy register holding zero if there is no
   corresponding CONTEXT field for the given register number.  */
char *
regptr (CONTEXT* c, int r)
{
  if (the_low_target.regmap[r] < 0)
  {
    static ULONG zero;
    /* Always force value to zero, in case the user tried to write
       to this register before.  */
    zero = 0;
    return (char *) &zero;
  }
  else
    return (char *) c + the_low_target.regmap[r];
}


a245 3
  debug_registers_changed = 0;
  debug_registers_used = 0;

d267 6
a275 11
      if (debug_registers_changed)
	{
	  /* Only change the value of the debug registers.  */
	  th->context.ContextFlags = CONTEXT_DEBUG_REGISTERS;

	  if (the_low_target.load_debug_registers != NULL)
	    the_low_target.load_debug_registers (th);

	  SetThreadContext (th->h, &th->context);
	  th->context.ContextFlags = 0;
	}
a287 1
  continue_status = 0;
a290 1
  debug_registers_changed = 0;
d304 1
a304 8
      (*the_low_target.fetch_inferior_registers) (th, regno);
}

/* Get register from gdbserver regcache data.  */
static void
do_child_store_inferior_registers (win32_thread_info *th, int r)
{
  collect_register (r, regptr (&th->context, r));
d318 1
a318 1
      do_child_store_inferior_registers (th, regno);
a741 4
	  if (debug_registers_changed)
	    if (the_low_target.load_debug_registers != NULL)
	      (*the_low_target.load_debug_registers) (th);

d754 2
a755 1
	  SetThreadContext (th->h, &th->context);
d766 1
a766 1
static int
a768 1
  win32_thread_info *th;
a772 3
  /* Record the context of the current thread.  */
  th = thread_rec (current_event.dwThreadId, -1);

d858 4
a861 1
	return 0;
a870 1
  return 1;
d873 2
a874 3
/* Get the next event from the child.  Return 1 if the event requires
   handling.  */
static int
a877 6
  DWORD continue_status, event_code;
  win32_thread_info *th = NULL;
  static win32_thread_info dummy_thread_info;
  int retval = 0;

in:
d883 1
a883 1
    goto out;
d889 1
a889 4
  continue_status = DBG_CONTINUE;
  event_code = current_event.dwDebugEventCode;

  switch (event_code)
d898 1
a898 1
      th = child_add_thread (current_event.dwThreadId,
a899 2

      retval = current_event.dwThreadId;
a907 1
      th = &dummy_thread_info;
d924 2
a925 3
      th =
	child_add_thread (main_thread_id,
			  current_event.u.CreateProcessInfo.hThread);
d927 1
a927 1
      retval = ourstatus->value.related_pid = current_event.dwThreadId;
a946 1
      retval = main_thread_id;
a957 1
      retval = main_thread_id;
d972 1
a972 1
      retval = handle_exception (ourstatus);
a995 12

  if (!retval || (event_code != EXCEPTION_DEBUG_EVENT && event_code != EXIT_PROCESS_DEBUG_EVENT))
    {
      child_continue (continue_status, -1);
      goto in;
    }

  if (th == NULL)
    thread_rec (current_event.dwThreadId, TRUE);

out:
  return retval;
d1012 1
a1012 1
      if (our_status.kind == TARGET_WAITKIND_EXITED)
d1014 1
d1023 1
a1023 3
	}
      else if (our_status.kind == TARGET_WAITKIND_STOPPED)
	{
d1032 9
a1041 11
      else
	OUTMSG (("Ignoring unknown internal event, %d\n", our_status.kind));

      {
	struct thread_resume resume;
	resume.thread = -1;
	resume.step = 0;
	resume.sig = 0;
	resume.leave_stopped = 0;
	win32_resume (&resume);
      }
@


1.6
log
@	* win32-low.c (win32-attach): Fix return value.
	* target.h (target_ops): Describe ATTACH return values.
@
text
@d686 1
a686 1
static void
d689 2
d701 41
a741 2
  if (DebugSetProcessKillOnExit != NULL)
    DebugSetProcessKillOnExit (FALSE);
d743 5
a747 4
  if (DebugActiveProcessStop != NULL)
    DebugActiveProcessStop (current_process_id);
  else
    win32_kill ();
d1205 1
@


1.5
log
@	* win32-low.c (GETPROCADDRESS): Define.
	(winapi_DebugActiveProcessStop): Add WINAPI.  typedef as pointer.
	(winapi_DebugSetProcessKillOnExit): Likewise.
	(win32_create_inferior): Force usage of ansi CreateProcessA.
	(win32_attach): Use GETPROCADDRESS.
	(win32_detach): Likewise.
@
text
@a582 1
  int res = 0;
d593 4
a596 7
  res = DebugActiveProcess (pid) ? 1 : 0;

  if (!res)
    error ("Attach to process failed.");

  if (DebugSetProcessKillOnExit != NULL)
    DebugSetProcessKillOnExit (FALSE);
d598 1
a598 2
  current_process_id = pid;
  current_process_handle = OpenProcess (PROCESS_ALL_ACCESS, FALSE, pid);
d600 6
a605 3
  if (current_process_handle == NULL)
    {
      res = 0;
d610 1
a610 4
  if (res)
    do_initial_child_stuff (pid);

  return res;
@


1.4
log
@	* win32-low.c (win32_wait): Don't use WSTOPSIG.
@
text
@d58 8
d81 2
a82 2
typedef BOOL winapi_DebugActiveProcessStop (DWORD dwProcessId);
typedef BOOL winapi_DebugSetProcessKillOnExit (BOOL KillOnExit);
d473 1
a473 1
  STARTUPINFO si = { sizeof (STARTUPINFO) };
d534 10
a543 10
  ret = CreateProcess (program, /* image name */
		       args,	/* command line */
		       NULL,	/* security */
		       NULL,	/* thread */
		       TRUE,	/* inherit handles */
		       flags,	/* start flags */
		       winenv,  /* environment */
		       NULL,	/* current directory */
		       &si,     /* start info */
		       &pi);    /* proc info */
d584 2
a585 3
  winapi_DebugActiveProcessStop *DebugActiveProcessStop = NULL;

  winapi_DebugSetProcessKillOnExit *DebugSetProcessKillOnExit = NULL;
d591 2
a592 4
  DebugActiveProcessStop = (winapi_DebugActiveProcessStop *)
    GetProcAddress (dll, _T("DebugActiveProcessStop"));
  DebugSetProcessKillOnExit = (winapi_DebugSetProcessKillOnExit *)
    GetProcAddress (dll, _T("DebugSetProcessKillOnExit"));
d694 2
a695 2
  winapi_DebugActiveProcessStop *DebugActiveProcessStop = NULL;
  winapi_DebugSetProcessKillOnExit *DebugSetProcessKillOnExit = NULL;
d701 2
a702 4
  DebugActiveProcessStop = (winapi_DebugActiveProcessStop *)
    GetProcAddress (dll, _T("DebugActiveProcessStop"));
  DebugSetProcessKillOnExit = (winapi_DebugSetProcessKillOnExit *)
    GetProcAddress (dll, _T("DebugSetProcessKillOnExit"));
@


1.3
log
@	* win32-low.c: Commit leftover changes from 2007-03-29.
@
text
@d1095 1
a1095 5
#ifndef __MINGW32CE__
	  OUTMSG2 (("Child Stopped with signal = %x \n",
		    WSTOPSIG (our_status.value.sig)));
#else
	  OUTMSG2 (("Child Stopped with signal = %x \n",
a1096 1
#endif
@


1.2
log
@	* win32-low.c: Rename typedef thread_info to
	win32_thread_info throughout.
@
text
@d26 2
d30 1
d47 9
a55 1
#define OUTMSG2(X)
d70 2
a71 1
static unsigned dr[8];
d76 12
a87 1
#define FLAG_TRACE_BIT 0x100
a91 9
/* Thread information structure used to track extra information about
   each thread.  */
typedef struct win32_thread_info
{
  DWORD tid;
  HANDLE h;
  int suspend_count;
  CONTEXT context;
} win32_thread_info;
d130 2
a131 6
	  dr[0] = th->context.Dr0;
	  dr[1] = th->context.Dr1;
	  dr[2] = th->context.Dr2;
	  dr[3] = th->context.Dr3;
	  dr[6] = th->context.Dr6;
	  dr[7] = th->context.Dr7;
d158 2
a159 1
  if (debug_registers_used)
d166 2
a167 7
      th->context.Dr0 = dr[0];
      th->context.Dr1 = dr[1];
      th->context.Dr2 = dr[2];
      th->context.Dr3 = dr[3];
      /* th->context.Dr6 = dr[6];
         FIXME: should we set dr6 also ?? */
      th->context.Dr7 = dr[7];
d266 17
a282 50
#define NUM_REGS 41
#define FCS_REGNUM 27
#define FOP_REGNUM 31

#define context_offset(x) ((int)&(((CONTEXT *)NULL)->x))
static const int mappings[] = {
  context_offset (Eax),
  context_offset (Ecx),
  context_offset (Edx),
  context_offset (Ebx),
  context_offset (Esp),
  context_offset (Ebp),
  context_offset (Esi),
  context_offset (Edi),
  context_offset (Eip),
  context_offset (EFlags),
  context_offset (SegCs),
  context_offset (SegSs),
  context_offset (SegDs),
  context_offset (SegEs),
  context_offset (SegFs),
  context_offset (SegGs),
  context_offset (FloatSave.RegisterArea[0 * 10]),
  context_offset (FloatSave.RegisterArea[1 * 10]),
  context_offset (FloatSave.RegisterArea[2 * 10]),
  context_offset (FloatSave.RegisterArea[3 * 10]),
  context_offset (FloatSave.RegisterArea[4 * 10]),
  context_offset (FloatSave.RegisterArea[5 * 10]),
  context_offset (FloatSave.RegisterArea[6 * 10]),
  context_offset (FloatSave.RegisterArea[7 * 10]),
  context_offset (FloatSave.ControlWord),
  context_offset (FloatSave.StatusWord),
  context_offset (FloatSave.TagWord),
  context_offset (FloatSave.ErrorSelector),
  context_offset (FloatSave.ErrorOffset),
  context_offset (FloatSave.DataSelector),
  context_offset (FloatSave.DataOffset),
  context_offset (FloatSave.ErrorSelector),
  /* XMM0-7 */
  context_offset (ExtendedRegisters[10 * 16]),
  context_offset (ExtendedRegisters[11 * 16]),
  context_offset (ExtendedRegisters[12 * 16]),
  context_offset (ExtendedRegisters[13 * 16]),
  context_offset (ExtendedRegisters[14 * 16]),
  context_offset (ExtendedRegisters[15 * 16]),
  context_offset (ExtendedRegisters[16 * 16]),
  context_offset (ExtendedRegisters[17 * 16]),
  /* MXCSR */
  context_offset (ExtendedRegisters[24])
};
a283 1
#undef context_offset
d285 1
a285 1
/* Clear out any old thread list and reintialize it to a pristine
a295 2
  int i;

d300 1
a300 2
  for (i = 0; i < sizeof (dr) / sizeof (dr[0]); i++)
    dr[i] = 0;
d304 3
d329 4
a332 7
	  th->context.Dr0 = dr[0];
	  th->context.Dr1 = dr[1];
	  th->context.Dr2 = dr[2];
	  th->context.Dr3 = dr[3];
	  /* th->context.Dr6 = dr[6];
	     FIXME: should we set dr6 also ?? */
	  th->context.Dr7 = dr[7];
a355 20
/* Fetch register(s) from gdbserver regcache data.  */
static void
do_child_fetch_inferior_registers (win32_thread_info *th, int r)
{
  char *context_offset = ((char *) &th->context) + mappings[r];
  long l;
  if (r == FCS_REGNUM)
    {
      l = *((long *) context_offset) & 0xffff;
      supply_register (r, (char *) &l);
    }
  else if (r == FOP_REGNUM)
    {
      l = (*((long *) context_offset) >> 16) & ((1 << 11) - 1);
      supply_register (r, (char *) &l);
    }
  else
    supply_register (r, context_offset);
}

d366 1
a366 1
      do_child_fetch_inferior_registers (th, regno);
d373 1
a373 1
  collect_register (r, ((char *) &th->context) + mappings[r]);
d390 55
a457 3
  char *winenv = NULL;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;
d463 7
a473 3
  memset (&si, 0, sizeof (si));
  si.cb = sizeof (si);

d491 1
a491 1
  argslen = strlen (program) + 1;
d495 1
a495 1
  strcpy (args, program);
d503 1
a503 1
  OUTMSG2 (("Command line is %s\n", args));
d505 1
d507 1
d509 20
a528 2
  ret = CreateProcess (0, args,	/* command line */
		       NULL,	/* Security */
d532 5
a536 2
		       winenv, NULL,	/* current directory */
		       &si, &pi);
d545 3
a547 2
      error ("Error creating process %s, (error %d): %s\n", args,
	     (int) GetLastError (), strerror (GetLastError ()));
d554 4
d559 1
a575 1
  HMODULE kernel32 = LoadLibrary ("KERNEL32.DLL");
d577 1
d579 9
a587 7

  DebugActiveProcessStop =
    (winapi_DebugActiveProcessStop *) GetProcAddress (kernel32,
						      "DebugActiveProcessStop");
  DebugSetProcessKillOnExit =
    (winapi_DebugSetProcessKillOnExit *) GetProcAddress (kernel32,
							 "DebugSetProcessKillOnExit");
a609 2
  FreeLibrary (kernel32);

d654 2
d674 9
a688 1
  HMODULE kernel32 = LoadLibrary ("KERNEL32.DLL");
d691 9
a699 7

  DebugActiveProcessStop =
    (winapi_DebugActiveProcessStop *) GetProcAddress (kernel32,
						      "DebugActiveProcessStop");
  DebugSetProcessKillOnExit =
    (winapi_DebugSetProcessKillOnExit *) GetProcAddress (kernel32,
							 "DebugSetProcessKillOnExit");
a707 2

  FreeLibrary (kernel32);
d780 2
a781 9
	    {
	      th->context.Dr0 = dr[0];
	      th->context.Dr1 = dr[1];
	      th->context.Dr2 = dr[2];
	      th->context.Dr3 = dr[3];
	      /* th->context.Dr6 = dr[6];
	         FIXME: should we set dr6 also ?? */
	      th->context.Dr7 = dr[7];
	    }
d788 7
a794 2
	    th->context.EFlags |= FLAG_TRACE_BIT;

d870 5
d984 8
d1095 1
d1098 4
d1145 1
a1145 1
  return child_xfer_memory (memaddr, myaddr, len, 0, 0) != len;
d1162 1
a1162 1
  return "i386";
d1194 3
a1196 1

@


1.1
log
@	* win32-i386-low.c: Rename to ...
	* win32-low.c: ... this.
	* configure.srv: Replace win32-i386-low.o with win32-low.o.
	* Makefile.in: Likewise.
@
text
@d71 1
a71 1
typedef struct thread_info_struct
d77 1
a77 1
} thread_info;
d85 1
a85 1
  thread_info *th = inferior_target_data (current_inferior);
d91 1
a91 1
static thread_info *
d95 1
a95 1
  thread_info *th;
d129 1
a129 1
static thread_info *
d132 1
a132 1
  thread_info *th;
d137 1
a137 1
  th = (thread_info *) malloc (sizeof (*th));
d173 1
a173 1
  thread_info *th = inferior_target_data ((struct thread_info *) thread);
d344 1
a344 1
  thread_info *th = inferior_target_data (thread);
d389 1
a389 1
do_child_fetch_inferior_registers (thread_info *th, int r)
d412 1
a412 1
  thread_info *th = thread_rec (current_inferior_tid (), TRUE);
d422 1
a422 1
do_child_store_inferior_registers (thread_info *th, int r)
d433 1
a433 1
  thread_info *th = thread_rec (current_inferior_tid (), TRUE);
d689 1
a689 1
  thread_info *th;
d767 1
a767 1
  thread_info *th;
d875 2
a876 2
  thread_info *th = NULL;
  static thread_info dummy_thread_info;
@

