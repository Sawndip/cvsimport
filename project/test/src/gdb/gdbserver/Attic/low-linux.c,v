head	1.15;
access;
symbols
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.12
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.4
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.2
	gdb_5_1-2001-07-29-branchpoint:1.11
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.9
	insight-precleanup-2001-01-01:1.5
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.2.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb-post-params-removal-2000-06-04:1.2
	gdb-pre-params-removal-2000-06-04:1.2
	gdb-post-params-removal-2000-05-28:1.2
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.4
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2002.02.14.06.21.22;	author drow;	state dead;
branches;
next	1.14;

1.14
date	2002.01.17.21.13.49;	author drow;	state Exp;
branches;
next	1.13;

1.13
date	2002.01.17.20.46.16;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.05.15.11.48;	author kwalker;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.26.02.23.58;	author drow;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.07.11.17.33.24;	author jtc;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.28.09.15.22;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.13.23.31.14;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.06.08.21.44;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.23.19.45.12;	author jtc;	state Exp;
branches;
next	1.5;

1.5
date	2000.12.08.19.46.07;	author jtc;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.13.03.17.11;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.21.05.23.05;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.17.46;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.02.04.44.24;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.11.09.01.23.13;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.11.17.02.30.36;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.08.02.50.48;	author jsm;	state Exp;
branches;
next	;

1.11.4.1
date	2001.09.27.00.13.30;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.15
log
@2002-02-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/Makefile.in: Add regformats directory to INCLUDE_CFLAGS,
        and remove unused $(INCLUDE_DIR).
        Add regcache.c to OBS.
        Add generated register protocol files to clean target.
        Update dependencies for new objects, obsolete old target code.

        * gdbserver/linux-low.c: Remove all platform-specific code to
        new files.  Remove various dead code.  Update to use regcache
        functionality.
        * gdbserver/remote-utils.c (fromhex): Add return statement
        to quiet warning.
        (putpkt): Dynamically allocate buf2 because PBUFSIZ is no longer
        constant.
        (input_interrupt): Add integer parameter to match prototype
        of a signal handler.
        (outreg): Use register_data ().
        (prepare_resume_reply): Use gdbserver_expedite_regs.
        * gdbserver/server.c (main): Dynamically allocate own_buf because
        PBUFSIZ is no longer constant.  Use registers_to_string () and
        registers_from_string ().
        * gdbserver/server.h: No longer include "defs.h".  Add prototypes
        for error (), fatal (), and warning ().  Update definition of
        PBUFSIZ to use regcache functionality.  Add include guard.
        * gdbserver/utils.c (fatal): Add missing ``const''.
        (warning): New function.

        * regformats/regdat.sh: Include "regcache.h" in generated files.
        Provide init_registers () function.
        * regformats/regdef.h: Add prototype for set_register_cache ().
        Add include guard.

        * gdbserver/linux-arm-low.c: New file.
        * gdbserver/linux-i386-low.c: New file.
        * gdbserver/linux-ia64-low.c: New file.
        * gdbserver/linux-m68k-low.c: New file.
        * gdbserver/linux-mips-low.c: New file.
        * gdbserver/linux-ppc-low.c: New file.
        * gdbserver/linux-sh-low.c: New file.

        * gdbserver/regcache.c: New file.
        * gdbserver/regcache.h: New file.

        * gdbserver/low-linux.c: Removed obsolete file.
@
text
@/* Low level interface to ptrace, for the remote server for GDB.
   Copyright 1995, 1996, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "server.h"
#include <sys/wait.h>
#include "frame.h"
#include "inferior.h"

#include <stdio.h>
#include <sys/param.h>
#include <sys/dir.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <fcntl.h>

/***************Begin MY defs*********************/
static char my_registers[REGISTER_BYTES];
char *registers = my_registers;
/***************End MY defs*********************/

#ifdef HAVE_SYS_REG_H
#include <sys/reg.h>
#endif

/* Default the type of the ptrace transfer to int.  */
#ifndef PTRACE_XFER_TYPE
#define PTRACE_XFER_TYPE int
#endif

extern int errno;

static void initialize_arch (void);

/* Start an inferior process and returns its pid.
   ALLARGS is a vector of program-name and args. */

int
create_inferior (char *program, char **allargs)
{
  int pid;

  pid = fork ();
  if (pid < 0)
    perror_with_name ("fork");

  if (pid == 0)
    {
      ptrace (PTRACE_TRACEME, 0, 0, 0);

      execv (program, allargs);

      fprintf (stderr, "Cannot exec %s: %s.\n", program,
	       errno < sys_nerr ? sys_errlist[errno] : "unknown error");
      fflush (stderr);
      _exit (0177);
    }

  return pid;
}

/* Attach to an inferior process.  */

int
myattach (int pid)
{
  if (ptrace (PTRACE_ATTACH, pid, 0, 0) != 0)
    {
      fprintf (stderr, "Cannot attach to process %d: %s (%d)\n", pid,
	       errno < sys_nerr ? sys_errlist[errno] : "unknown error",
	       errno);
      fflush (stderr);
      _exit (0177);
    }

  return 0;
}

/* Kill the inferior process.  Make us have no inferior.  */

void
kill_inferior (void)
{
  if (inferior_pid == 0)
    return;
  ptrace (PTRACE_KILL, inferior_pid, 0, 0);
  wait (0);
/*************inferior_died ();****VK**************/
}

/* Return nonzero if the given thread is still alive.  */
int
mythread_alive (int pid)
{
  return 1;
}

/* Wait for process, returns status */

unsigned char
mywait (char *status)
{
  int pid;
  union wait w;

  enable_async_io ();
  pid = waitpid (inferior_pid, &w, 0);
  disable_async_io ();
  if (pid != inferior_pid)
    perror_with_name ("wait");

  if (WIFEXITED (w))
    {
      fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
      *status = 'W';
      return ((unsigned char) WEXITSTATUS (w));
    }
  else if (!WIFSTOPPED (w))
    {
      fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
      *status = 'X';
      return ((unsigned char) WTERMSIG (w));
    }

  fetch_inferior_registers (0);

  *status = 'T';
  return ((unsigned char) WSTOPSIG (w));
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
myresume (int step, int signal)
{
  errno = 0;
  ptrace (step ? PTRACE_SINGLESTEP : PTRACE_CONT, inferior_pid, 1, signal);
  if (errno)
    perror_with_name ("ptrace");
}


#if !defined (offsetof)
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

/* U_REGS_OFFSET is the offset of the registers within the u area.  */
#if !defined (U_REGS_OFFSET)
#define U_REGS_OFFSET \
  ptrace (PT_READ_U, inferior_pid, \
          (PTRACE_ARG3_TYPE) (offsetof (struct user, u_ar0)), 0) \
    - KERNEL_U_ADDR
#endif

#ifdef I386_GNULINUX_TARGET
/* This module only supports access to the general purpose registers.
   Adjust the relevant constants accordingly.

   FIXME: kettenis/2001-03-28: We should really use PTRACE_GETREGS to
   get at the registers.  Better yet, we should try to share code with
   i386-linux-nat.c.  */
#undef NUM_FREGS
#define NUM_FREGS 0
#undef NUM_REGS
#define NUM_REGS NUM_GREGS

/* This stuff comes from i386-tdep.c.  */

/* i386_register_byte[i] is the offset into the register file of the
   start of register number i.  We initialize this from
   i386_register_raw_size.  */
int i386_register_byte[MAX_NUM_REGS];

/* i386_register_raw_size[i] is the number of bytes of storage in
   GDB's register array occupied by register i.  */
int i386_register_raw_size[MAX_NUM_REGS] = {
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
  10, 10, 10, 10,
  10, 10, 10, 10,
   4,  4,  4,  4,
   4,  4,  4,  4,
  16, 16, 16, 16,
  16, 16, 16, 16,
   4
};

static void
initialize_arch (void)
{
  /* Initialize the table saying where each register starts in the
     register file.  */
  {
    int i, offset;

    offset = 0;
    for (i = 0; i < MAX_NUM_REGS; i++)
      {
	i386_register_byte[i] = offset;
	offset += i386_register_raw_size[i];
      }
  }
}

/* This stuff comes from i386-linux-nat.c.  */

/* Mapping between the general-purpose registers in `struct user'
   format and GDB's register array layout.  */
static int regmap[] = 
{
  EAX, ECX, EDX, EBX,
  UESP, EBP, ESI, EDI,
  EIP, EFL, CS, SS,
  DS, ES, FS, GS
};

/* Return the address of register REGNUM.  BLOCKEND is the value of
   u.u_ar0, which should point to the registers.  */

CORE_ADDR
register_u_addr (CORE_ADDR blockend, int regnum)
{
  return (blockend + 4 * regmap[regnum]);
}
#elif defined(TARGET_M68K)
static void
initialize_arch (void)
{
  return;
}

/* This table must line up with REGISTER_NAMES in tm-m68k.h */
static int regmap[] =
{
#ifdef PT_D0
  PT_D0, PT_D1, PT_D2, PT_D3, PT_D4, PT_D5, PT_D6, PT_D7,
  PT_A0, PT_A1, PT_A2, PT_A3, PT_A4, PT_A5, PT_A6, PT_USP,
  PT_SR, PT_PC,
#else
  14, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 15,
  17, 18,
#endif
#ifdef PT_FP0
  PT_FP0, PT_FP1, PT_FP2, PT_FP3, PT_FP4, PT_FP5, PT_FP6, PT_FP7,
  PT_FPCR, PT_FPSR, PT_FPIAR
#else
  21, 24, 27, 30, 33, 36, 39, 42, 45, 46, 47
#endif
};

/* BLOCKEND is the value of u.u_ar0, and points to the place where GS
   is stored.  */

int
m68k_linux_register_u_addr (int blockend, int regnum)
{
  return (blockend + 4 * regmap[regnum]);
}
#elif defined(IA64_GNULINUX_TARGET)
#undef NUM_FREGS
#define NUM_FREGS 0

#include <asm/ptrace_offsets.h>

static int u_offsets[] =
  {
    /* general registers */
    -1,		/* gr0 not available; i.e, it's always zero */
    PT_R1,
    PT_R2,
    PT_R3,
    PT_R4,
    PT_R5,
    PT_R6,
    PT_R7,
    PT_R8,
    PT_R9,
    PT_R10,
    PT_R11,
    PT_R12,
    PT_R13,
    PT_R14,
    PT_R15,
    PT_R16,
    PT_R17,
    PT_R18,
    PT_R19,
    PT_R20,
    PT_R21,
    PT_R22,
    PT_R23,
    PT_R24,
    PT_R25,
    PT_R26,
    PT_R27,
    PT_R28,
    PT_R29,
    PT_R30,
    PT_R31,
    /* gr32 through gr127 not directly available via the ptrace interface */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    /* Floating point registers */
    -1, -1,	/* f0 and f1 not available (f0 is +0.0 and f1 is +1.0) */
    PT_F2,
    PT_F3,
    PT_F4,
    PT_F5,
    PT_F6,
    PT_F7,
    PT_F8,
    PT_F9,
    PT_F10,
    PT_F11,
    PT_F12,
    PT_F13,
    PT_F14,
    PT_F15,
    PT_F16,
    PT_F17,
    PT_F18,
    PT_F19,
    PT_F20,
    PT_F21,
    PT_F22,
    PT_F23,
    PT_F24,
    PT_F25,
    PT_F26,
    PT_F27,
    PT_F28,
    PT_F29,
    PT_F30,
    PT_F31,
    PT_F32,
    PT_F33,
    PT_F34,
    PT_F35,
    PT_F36,
    PT_F37,
    PT_F38,
    PT_F39,
    PT_F40,
    PT_F41,
    PT_F42,
    PT_F43,
    PT_F44,
    PT_F45,
    PT_F46,
    PT_F47,
    PT_F48,
    PT_F49,
    PT_F50,
    PT_F51,
    PT_F52,
    PT_F53,
    PT_F54,
    PT_F55,
    PT_F56,
    PT_F57,
    PT_F58,
    PT_F59,
    PT_F60,
    PT_F61,
    PT_F62,
    PT_F63,
    PT_F64,
    PT_F65,
    PT_F66,
    PT_F67,
    PT_F68,
    PT_F69,
    PT_F70,
    PT_F71,
    PT_F72,
    PT_F73,
    PT_F74,
    PT_F75,
    PT_F76,
    PT_F77,
    PT_F78,
    PT_F79,
    PT_F80,
    PT_F81,
    PT_F82,
    PT_F83,
    PT_F84,
    PT_F85,
    PT_F86,
    PT_F87,
    PT_F88,
    PT_F89,
    PT_F90,
    PT_F91,
    PT_F92,
    PT_F93,
    PT_F94,
    PT_F95,
    PT_F96,
    PT_F97,
    PT_F98,
    PT_F99,
    PT_F100,
    PT_F101,
    PT_F102,
    PT_F103,
    PT_F104,
    PT_F105,
    PT_F106,
    PT_F107,
    PT_F108,
    PT_F109,
    PT_F110,
    PT_F111,
    PT_F112,
    PT_F113,
    PT_F114,
    PT_F115,
    PT_F116,
    PT_F117,
    PT_F118,
    PT_F119,
    PT_F120,
    PT_F121,
    PT_F122,
    PT_F123,
    PT_F124,
    PT_F125,
    PT_F126,
    PT_F127,
    /* predicate registers - we don't fetch these individually */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* branch registers */
    PT_B0,
    PT_B1,
    PT_B2,
    PT_B3,
    PT_B4,
    PT_B5,
    PT_B6,
    PT_B7,
    /* virtual frame pointer and virtual return address pointer */
    -1, -1,
    /* other registers */
    PT_PR,
    PT_CR_IIP,	/* ip */
    PT_CR_IPSR, /* psr */
    PT_CFM,	/* cfm */
    /* kernel registers not visible via ptrace interface (?) */
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* hole */
    -1, -1, -1, -1, -1, -1, -1, -1,
    PT_AR_RSC,
    PT_AR_BSP,
    PT_AR_BSPSTORE,
    PT_AR_RNAT,
    -1,
    -1,		/* Not available: FCR, IA32 floating control register */
    -1, -1,
    -1,		/* Not available: EFLAG */
    -1,		/* Not available: CSD */
    -1,		/* Not available: SSD */
    -1,		/* Not available: CFLG */
    -1,		/* Not available: FSR */
    -1,		/* Not available: FIR */
    -1,		/* Not available: FDR */
    -1,
    PT_AR_CCV,
    -1, -1, -1,
    PT_AR_UNAT,
    -1, -1, -1,
    PT_AR_FPSR,
    -1, -1, -1,
    -1,		/* Not available: ITC */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1,
    PT_AR_PFS,
    PT_AR_LC,
    -1,		/* Not available: EC, the Epilog Count register */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1,
    /* nat bits - not fetched directly; instead we obtain these bits from
       either rnat or unat or from memory. */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
  };

int
ia64_register_u_addr (int blockend, int regnum)
{
  int addr;

  if (regnum < 0 || regnum >= NUM_REGS)
    error ("Invalid register number %d.", regnum);

  addr = u_offsets[regnum];
  if (addr == -1)
    addr = 0;

  return addr;
}

static void
initialize_arch (void)
{
  return;
}

#elif defined(ARM_GNULINUX_TARGET)
int arm_register_u_addr(blockend, regnum)
     int blockend;
     int regnum;
{
  return blockend + REGISTER_BYTE(regnum);  
}

static void
initialize_arch ()
{
}
#endif

CORE_ADDR
register_addr (int regno, CORE_ADDR blockend)
{
  CORE_ADDR addr;

  if (regno < 0 || regno >= NUM_REGS)
    error ("Invalid register number %d.", regno);

  REGISTER_U_ADDR (addr, blockend, regno);

  return addr;
}

/* Fetch one register.  */

static void
fetch_register (int regno)
{
  CORE_ADDR regaddr;
  register int i;

  /* Offset of registers within the u area.  */
  unsigned int offset;

  offset = U_REGS_OFFSET;

  regaddr = register_addr (regno, offset);
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      *(PTRACE_XFER_TYPE *) &registers[REGISTER_BYTE (regno) + i] =
	ptrace (PTRACE_PEEKUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, 0);
      regaddr += sizeof (PTRACE_XFER_TYPE);
      if (errno != 0)
	{
	  /* Warning, not error, in case we are attached; sometimes the
	     kernel doesn't let us at the registers.  */
	  char *err = strerror (errno);
	  char *msg = alloca (strlen (err) + 128);
	  sprintf (msg, "reading register %d: %s", regno, err);
	  error (msg);
	  goto error_exit;
	}
    }
error_exit:;
}

/* Fetch all registers, or just one, from the child process.  */

void
fetch_inferior_registers (int regno)
{
  if (regno == -1 || regno == 0)
    for (regno = 0; regno < NUM_REGS - NUM_FREGS; regno++)
      fetch_register (regno);
  else
    fetch_register (regno);
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int regno)
{
  CORE_ADDR regaddr;
  int i;
  unsigned int offset = U_REGS_OFFSET;

  if (regno >= 0)
    {
#if 0
      if (CANNOT_STORE_REGISTER (regno))
	return;
#endif
      regaddr = register_addr (regno, offset);
      errno = 0;
#if 0
      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)
	{
	  scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
	  ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		  scratch, 0);
	  if (errno != 0)
	    {
	      /* Error, even if attached.  Failing to write these two
	         registers is pretty serious.  */
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
      else
#endif
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
	  {
	    errno = 0;
	    ptrace (PTRACE_POKEUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		    *(int *) &registers[REGISTER_BYTE (regno) + i]);
	    if (errno != 0)
	      {
		/* Warning, not error, in case we are attached; sometimes the
		   kernel doesn't let us at the registers.  */
		char *err = strerror (errno);
		char *msg = alloca (strlen (err) + 128);
		sprintf (msg, "writing register %d: %s",
			 regno, err);
		error (msg);
		return;
	      }
	    regaddr += sizeof (int);
	  }
    }
  else
    for (regno = 0; regno < NUM_REGS - NUM_FREGS; regno++)
      store_inferior_registers (regno);
}

/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
   in the NEW_SUN_PTRACE case.
   It ought to be straightforward.  But it appears that writing did
   not write the data that I specified.  I cannot understand where
   it got the data that it actually did write.  */

/* Copy LEN bytes from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.  */

void
read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  register int count 
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1) 
      / sizeof (PTRACE_XFER_TYPE);
  /* Allocate buffer of that many longwords.  */
  register PTRACE_XFER_TYPE *buffer 
    = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));

  /* Read all the longwords */
  for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
    {
      buffer[i] = ptrace (PTRACE_PEEKTEXT, inferior_pid, addr, 0);
    }

  /* Copy appropriate bytes out of the buffer.  */
  memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)), len);
}

/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.
   On failure (cannot write the inferior)
   returns the value of errno.  */

int
write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
  = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1) / sizeof (PTRACE_XFER_TYPE);
  /* Allocate buffer of that many longwords.  */
  register PTRACE_XFER_TYPE *buffer = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
  extern int errno;

  /* Fill start and end extra bytes of buffer with existing memory data.  */

  buffer[0] = ptrace (PTRACE_PEEKTEXT, inferior_pid, addr, 0);

  if (count > 1)
    {
      buffer[count - 1]
	= ptrace (PTRACE_PEEKTEXT, inferior_pid,
		  addr + (count - 1) * sizeof (PTRACE_XFER_TYPE), 0);
    }

  /* Copy data to be written over corresponding part of buffer */

  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)), myaddr, len);

  /* Write the entire buffer.  */

  for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
    {
      errno = 0;
      ptrace (PTRACE_POKETEXT, inferior_pid, addr, buffer[i]);
      if (errno)
	return errno;
    }

  return 0;
}

void
initialize_low (void)
{
  initialize_arch ();
}
@


1.14
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/low-hppabsd.c, gdbserver/low-lynx.c,
        gdbserver/low-nbsd.c, gdbserver/low-sim.c,
        gdbserver/low-sparc.c, gdbserver/low-sun3.c,
        gdbserver/low-linux.c, gdbserver/server.c: Correct copyright notices.
@
text
@@


1.13
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * low-hppabsd.c (myattach): New function, returning -1.
        * low-lynx.c (myattach): Likewise.
        * low-nbsd.c (myattach): Likewise.
        * low-sim.c (myattach): Likewise.
        * low-sparc.c (myattach): Likewise.
        * low-sun3.c (myattach): Likewise.

        * low-linux.c (myattach): New function.

        * server.c (attach_inferior): New function.
        (main): Handle "--attach".
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1998, 1999, 2000, 2001
@


1.12
log
@* gdbserver/low-linux.c (arm_register_u_addr): added.
(initialize_arch): added for ARM target.
* config/arm/nm-linux.h (U_REGS_OFFSET) defined.
(REGISTER_U_ADDR) defined.
* config/arm/tm-linux.h (ARM_GNULINUX_TARGET) defined.
@
text
@d81 17
@


1.11
log
@        * infptrace.c (child_xfer_memory): Add cast to CORE_ADDR.
        * infttrace.c (child_xfer_memory): Likewise.
        * symm-nat.c (child_xfer_memory): Likewise.
        * gdbserver/low-hppabsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-linux.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-lynx.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-nbsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sparc.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sun3.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
@
text
@d544 13
@


1.11.4.1
log
@http://www10.software.ibm.com/developerworks/opensource/linux390/exp_src.html
Patch:    gdb-5.1pre-050901-s390.tar.gz (09/11/2001)
MD5: 886251f3719a754dd65a69df462ceac1
@
text
@a51 1
#ifndef S390_GNULINUX_TARGET
d53 1
a53 1
#endif
d116 1
a116 2
      fprintf (stderr, "\nChild exited with retcode = %x \n",
	       WEXITSTATUS (w));
d122 1
a122 2
      fprintf (stderr, "\nChild terminated with signal = %x \n",
	       WTERMSIG (w));
d181 4
a184 4
  4, 4, 4, 4,
  4, 4, 4, 4,
  4, 4, 4, 4,
  4, 4, 4, 4,
d187 2
a188 2
  4, 4, 4, 4,
  4, 4, 4, 4,
d191 1
a191 1
  4
d215 2
a216 1
static int regmap[] = {
d239 2
a240 1
static int regmap[] = {
d271 252
a522 251
static int u_offsets[] = {
  /* general registers */
  -1,				/* gr0 not available; i.e, it's always zero */
  PT_R1,
  PT_R2,
  PT_R3,
  PT_R4,
  PT_R5,
  PT_R6,
  PT_R7,
  PT_R8,
  PT_R9,
  PT_R10,
  PT_R11,
  PT_R12,
  PT_R13,
  PT_R14,
  PT_R15,
  PT_R16,
  PT_R17,
  PT_R18,
  PT_R19,
  PT_R20,
  PT_R21,
  PT_R22,
  PT_R23,
  PT_R24,
  PT_R25,
  PT_R26,
  PT_R27,
  PT_R28,
  PT_R29,
  PT_R30,
  PT_R31,
  /* gr32 through gr127 not directly available via the ptrace interface */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  /* Floating point registers */
  -1, -1,			/* f0 and f1 not available (f0 is +0.0 and f1 is +1.0) */
  PT_F2,
  PT_F3,
  PT_F4,
  PT_F5,
  PT_F6,
  PT_F7,
  PT_F8,
  PT_F9,
  PT_F10,
  PT_F11,
  PT_F12,
  PT_F13,
  PT_F14,
  PT_F15,
  PT_F16,
  PT_F17,
  PT_F18,
  PT_F19,
  PT_F20,
  PT_F21,
  PT_F22,
  PT_F23,
  PT_F24,
  PT_F25,
  PT_F26,
  PT_F27,
  PT_F28,
  PT_F29,
  PT_F30,
  PT_F31,
  PT_F32,
  PT_F33,
  PT_F34,
  PT_F35,
  PT_F36,
  PT_F37,
  PT_F38,
  PT_F39,
  PT_F40,
  PT_F41,
  PT_F42,
  PT_F43,
  PT_F44,
  PT_F45,
  PT_F46,
  PT_F47,
  PT_F48,
  PT_F49,
  PT_F50,
  PT_F51,
  PT_F52,
  PT_F53,
  PT_F54,
  PT_F55,
  PT_F56,
  PT_F57,
  PT_F58,
  PT_F59,
  PT_F60,
  PT_F61,
  PT_F62,
  PT_F63,
  PT_F64,
  PT_F65,
  PT_F66,
  PT_F67,
  PT_F68,
  PT_F69,
  PT_F70,
  PT_F71,
  PT_F72,
  PT_F73,
  PT_F74,
  PT_F75,
  PT_F76,
  PT_F77,
  PT_F78,
  PT_F79,
  PT_F80,
  PT_F81,
  PT_F82,
  PT_F83,
  PT_F84,
  PT_F85,
  PT_F86,
  PT_F87,
  PT_F88,
  PT_F89,
  PT_F90,
  PT_F91,
  PT_F92,
  PT_F93,
  PT_F94,
  PT_F95,
  PT_F96,
  PT_F97,
  PT_F98,
  PT_F99,
  PT_F100,
  PT_F101,
  PT_F102,
  PT_F103,
  PT_F104,
  PT_F105,
  PT_F106,
  PT_F107,
  PT_F108,
  PT_F109,
  PT_F110,
  PT_F111,
  PT_F112,
  PT_F113,
  PT_F114,
  PT_F115,
  PT_F116,
  PT_F117,
  PT_F118,
  PT_F119,
  PT_F120,
  PT_F121,
  PT_F122,
  PT_F123,
  PT_F124,
  PT_F125,
  PT_F126,
  PT_F127,
  /* predicate registers - we don't fetch these individually */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* branch registers */
  PT_B0,
  PT_B1,
  PT_B2,
  PT_B3,
  PT_B4,
  PT_B5,
  PT_B6,
  PT_B7,
  /* virtual frame pointer and virtual return address pointer */
  -1, -1,
  /* other registers */
  PT_PR,
  PT_CR_IIP,			/* ip */
  PT_CR_IPSR,			/* psr */
  PT_CFM,			/* cfm */
  /* kernel registers not visible via ptrace interface (?) */
  -1, -1, -1, -1, -1, -1, -1, -1,
  /* hole */
  -1, -1, -1, -1, -1, -1, -1, -1,
  PT_AR_RSC,
  PT_AR_BSP,
  PT_AR_BSPSTORE,
  PT_AR_RNAT,
  -1,
  -1,				/* Not available: FCR, IA32 floating control register */
  -1, -1,
  -1,				/* Not available: EFLAG */
  -1,				/* Not available: CSD */
  -1,				/* Not available: SSD */
  -1,				/* Not available: CFLG */
  -1,				/* Not available: FSR */
  -1,				/* Not available: FIR */
  -1,				/* Not available: FDR */
  -1,
  PT_AR_CCV,
  -1, -1, -1,
  PT_AR_UNAT,
  -1, -1, -1,
  PT_AR_FPSR,
  -1, -1, -1,
  -1,				/* Not available: ITC */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1,
  PT_AR_PFS,
  PT_AR_LC,
  -1,				/* Not available: EC, the Epilog Count register */
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1,
  /* nat bits - not fetched directly; instead we obtain these bits from
     either rnat or unat or from memory. */
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1,
};
d572 2
a573 5
#ifdef  S390_GNULINUX_TARGET	/* intel has CANNOT_FETCH_REGISTER defined but not linked */
  if (CANNOT_FETCH_REGISTER (regno))
    memset (&registers[REGISTER_BYTE (regno)], 0, REGISTER_RAW_SIZE (regno));
  else
#endif
d575 5
a579 3
      regaddr = register_addr (regno, offset);
      for (i = 0; i < REGISTER_RAW_SIZE (regno);
	   i += sizeof (PTRACE_XFER_TYPE))
d581 7
a587 15
	  errno = 0;
	  *(PTRACE_XFER_TYPE *) & registers[REGISTER_BYTE (regno) + i] =
	    ptrace (PTRACE_PEEKUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		    0);
	  regaddr += sizeof (PTRACE_XFER_TYPE);
	  if (errno != 0)
	    {
	      /* Warning, not error, in case we are attached; sometimes the
	         kernel doesn't let us at the registers.  */
	      char *err = strerror (errno);
	      char *msg = alloca (strlen (err) + 128);
	      sprintf (msg, "reading register %d: %s", regno, err);
	      error (msg);
	      goto error_exit;
	    }
d599 1
a599 5
    for (regno = 0; regno < NUM_REGS
#ifndef S390_GNULINUX_TARGET
	 - NUM_FREGS
#endif
	 ; regno++)
d618 1
a618 1
#ifdef  S390_GNULINUX_TARGET	/* intel has CANNOT_STORE_REGISTER defined but not implemented */
d640 1
a640 2
	for (i = 0; i < REGISTER_RAW_SIZE (regno);
	     i += sizeof (PTRACE_XFER_TYPE))
d644 1
a644 2
		    *(PTRACE_XFER_TYPE *) & registers[REGISTER_BYTE (regno) +
						      i]);
d651 2
a652 1
		sprintf (msg, "writing register %d: %s", regno, err);
d660 1
a660 5
    for (regno = 0; regno < NUM_REGS
#ifndef S390_GNULINUX_TARGET
	 - NUM_FREGS
#endif
	 ; regno++)
d680 3
a682 3
  register int count
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
    / sizeof (PTRACE_XFER_TYPE);
d684 1
a684 1
  register PTRACE_XFER_TYPE *buffer
d694 1
a694 2
  memcpy (myaddr,
	  (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)), len);
d710 1
a710 3
    =
    (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) -
     1) / sizeof (PTRACE_XFER_TYPE);
d712 1
a712 2
  register PTRACE_XFER_TYPE *buffer =
    (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d728 1
a728 2
  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
	  myaddr, len);
a745 1
#ifndef S390_GNULINUX_TARGET
a746 1
#endif
@


1.10
log
@* gdbserver/remote-utils.c (remote_open): Set gdbserver as "owner"
of SIGIO.
(input_interrupt): Don't block on read, in case we got redundant
SIGIO.  Don't gripe about redundant SIGIO.
* gdbserver/low-hppabsd.c (mywait): Use waitpid().  Enable SIGIO
handler while waiting.
* gdbserver/low-linux.c (mywait): Likewise.
* gdbserver/low-nbsd.c (mywait): Likewise.
* gdbserver/low-sparc.c (mywait): Likewise.
@
text
@d678 1
a678 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
d707 1
a707 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
@


1.9
log
@* gdbserver/low-linux.c [I386_GNULINUX_TARGET]: Cleanup code and
make it work again.
(NUM_FREGS): Redefine to 0.
(NUM_REGS): Redefine as NUM_GREGS.
(i386_register_byte, i386_register_raw_size): Update from
i386-tdep.c.  Add comment about their origin.
(regmap, register_u_addr): Take these from i386-linux-nat.c.
(i386_register_u_addr): Removed.
@
text
@d108 3
a110 1
  pid = wait (&w);
@


1.8
log
@Eliminate ARCH_NUM_REGS.
@
text
@d158 20
a177 2
/* i386_register_raw_size[i] is the number of bytes of storage in the
   actual machine representation for register i.  */
a191 2
int i386_register_byte[MAX_NUM_REGS];

d209 5
a213 3
/* this table must line up with REGISTER_NAMES in tm-i386v.h */
/* symbols like 'EAX' come from <sys/reg.h> */
static int regmap[] =
d218 1
a218 1
  DS, ES, FS, GS,
d221 5
a225 2
int
i386_register_u_addr (int blockend, int regnum)
d227 1
a227 17
#if 0
  /* this will be needed if fp registers are reinstated */
  /* for now, you can look at them with 'info float'
   * sys5 wont let you change them with ptrace anyway
   */
  if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM)
    {
      int ubase, fpstate;
      struct user u;
      ubase = blockend + 4 * (SS + 1) - KSTKSZ;
      fpstate = ubase + ((char *) &u.u_fpstate - (char *) &u);
      return (fpstate + 0x1c + 10 * (regnum - FP0_REGNUM));
    }
  else
#endif
    return (blockend + 4 * regmap[regnum]);

@


1.7
log
@Update/correct copyright notices.
@
text
@d544 1
a544 1
  if (regno < 0 || regno >= ARCH_NUM_REGS)
@


1.6
log
@* config/m32r/m32r.mt (GDBSERVER_LIBS): Added ../../intl/libintl.a.
* config/mips/vr5000.mt (GDBSERVER_LIBS): Likewise.
* config/tic80/tic80.mt (GDBSERVER_LIBS): Likewise.
* gdbserver/low-sim.c (#include "defs.h"): Removed.
(mygeneric_load): Rename from generic_load.

* gdbserver/low-hppabsd.c (#include "server.h"): Added.
(#include "defs.h"): Removed.
(inferior_pid, perror_with_name): Remove declarations.
* gdbserver/low-linux.c: Likewise.
* gdbserver/low-nbsd.c: Likewise.
* gdbserver/low-sparc.c: Likewise.
* gdbserver/low-sun3.c: Likewise.

* i386-stub.c: Re-indent.
* m68k-stub.c: Re-indent.
@
text
@d2 2
a3 1
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
@


1.5
log
@* gdbserver/low-hppabsd.c (buf2, environ, quit, quit_flag):
Removed unused variables and declarations.
* gdbserver/low-linux.c (buf2, environ, query, quit, quit_flag):
Likewise.
* gdbserver/low-nbsd.c (buf2, environ, quit, quit_flag):
Likewise.
* gdbserver/low-sparc.c (buf2, environ, query, quit, quit_flag):
Likewise.
* gdbserver/low-sun.c (buf2, environ, query, quit, quit_flag):
Likewise.

* gdbserver/low-hppabsd.c, gdbserver/low-linux.c,
gdbserver/low-nbsd.c, gdbserver/low-sparc.c, gdbserver/low-sun3.c
(create_inferior): Update comment.

* gdbserver/low-nbsd.c (initialize_arch, fetch_inferior_registers,
store_inferior_registers): Provide implementations for the m68k
and ns32k.
* config/m68k/nbsd.mt (GDBSERVER_DEPFILES): Add low-nbsd.o
* config/ns32k/nbsd.mt (GDBSERVER_DEPFILES): Likewise.
* configure.tgt (m68*-*-netbsd*, ns32k-*-netbsd*): Add gdbserver
to configdirs.
-------------------------------------------------------------------
@
text
@d21 1
a21 1
#include "defs.h"
a49 2
extern int inferior_pid;
void perror_with_name ();
@


1.4
log
@Protoization.
@
text
@a35 1
int quit_flag = 0;
a37 6

/* Index within `registers' of the first byte of the space for
   register N.  */


char buf2[MAX_REGISTER_RAW_SIZE];
a48 1
extern char **environ;
d51 1
a51 2
void quit (), perror_with_name ();
int query ();
d56 1
a56 2
   ALLARGS is a vector of program-name and args.
   ENV is the environment vector to pass.  */
@


1.3
log
@Use PT_CFM in place of PT_CR_IFS.
@
text
@d69 1
a69 3
create_inferior (program, allargs)
     char *program;
     char **allargs;
d95 1
a95 1
kill_inferior ()
d106 1
a106 2
mythread_alive (pid)
     int pid;
d114 1
a114 2
mywait (status)
     char *status;
d147 1
a147 3
myresume (step, signal)
     int step;
     int signal;
d188 1
a188 1
initialize_arch ()
d215 1
a215 3
i386_register_u_addr (blockend, regnum)
     int blockend;
     int regnum;
d237 1
a237 1
initialize_arch ()
d265 1
a265 3
m68k_linux_register_u_addr (blockend, regnum)
     int blockend;
     int regnum;
d544 1
a544 1
initialize_arch ()
d551 1
a551 3
register_addr (regno, blockend)
     int regno;
     CORE_ADDR blockend;
d566 1
a566 2
fetch_register (regno)
     int regno;
d600 1
a600 2
fetch_inferior_registers (regno)
     int regno;
d614 1
a614 2
store_inferior_registers (regno)
     int regno;
d678 1
a678 4
read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d707 1
a707 4
write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d748 1
a748 1
initialize_low ()
@


1.2
log
@IA-64 changes.
@
text
@d479 1
a479 1
    PT_CR_IFS,	/* cfm */
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d29 1
a32 3
#if 0
#include <sgtty.h>
#endif
d37 2
a38 1
char registers[REGISTER_BYTES];
d47 3
a49 1
#include <sys/ptrace.h>
d51 3
a53 2
#if __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1)
#include <sys/reg.h>
d62 2
d103 1
a103 1
  /*************inferior_died ();****VK**************/
d174 36
a209 1
#ifndef TARGET_M68K
d212 1
a212 1
static int regmap[] = 
d230 1
a230 1
  if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM) 
d235 1
a235 1
      fpstate = ubase + ((char *)&u.u_fpstate - (char *)&u);
d237 1
a237 1
    } 
d241 1
a241 1
  
d243 7
a249 1
#else /* TARGET_M68K */
d251 1
a251 1
static int regmap[] = 
d277 280
a556 1
    return (blockend + 4 * regmap[regnum]);
d581 1
a581 1
  register unsigned int regaddr;
d590 1
a590 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
d593 3
a595 3
      *(int *) &registers[ regno * 4 + i] = ptrace (PTRACE_PEEKUSR, inferior_pid,
				 (PTRACE_ARG3_TYPE) regaddr, 0);
      regaddr += sizeof (int);
d607 1
a607 1
 error_exit:;
d617 1
a617 1
    for (regno = 0; regno < NUM_REGS-NUM_FREGS; regno++)
d631 2
a632 2
  register unsigned int regaddr;
  register int i;
d645 6
a650 6
        {
          scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
          ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
                  scratch, 0);
          if (errno != 0)
            {
d652 5
a656 5
		 registers is pretty serious.  */
              sprintf (buf, "writing register number %d", regno);
              perror_with_name (buf);
            }
        }
d659 1
a659 1
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof(int))
d662 1
a662 1
	    ptrace (PTRACE_POKEUSR, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
d675 1
a675 1
	    regaddr += sizeof(int);
d679 1
a679 1
    for (regno = 0; regno < NUM_REGS-NUM_FREGS; regno++)
d700 1
a700 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
d702 3
a704 2
  register int count
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
d706 2
a707 1
  register int *buffer = (int *) alloca (count * sizeof (int));
d710 1
a710 1
  for (i = 0; i < count; i++, addr += sizeof (int))
d716 1
a716 1
  memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (int) - 1)), len);
d732 1
a732 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
d735 1
a735 1
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
d737 1
a737 1
  register int *buffer = (int *) alloca (count * sizeof (int));
d748 1
a748 1
		  addr + (count - 1) * sizeof (int), 0);
d753 1
a753 1
  memcpy ((char *) buffer + (memaddr & (sizeof (int) - 1)), myaddr, len);
d757 1
a757 1
  for (i = 0; i < count; i++, addr += sizeof (int))
d769 1
a769 7
initialize ()
{
  inferior_pid = 0;
}

int
have_inferior_p ()
d771 1
a771 1
  return inferior_pid != 0;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d98 1
a98 1
/*************inferior_died ();****VK**************/
d172 1
a172 1
static int regmap[] =
d190 1
a190 1
  if (regnum >= FP0_REGNUM && regnum <= FP7_REGNUM)
d195 1
a195 1
      fpstate = ubase + ((char *) &u.u_fpstate - (char *) &u);
d197 1
a197 1
    }
d201 1
a201 1

d205 1
a205 1
static int regmap[] =
d231 1
a231 1
  return (blockend + 4 * regmap[regnum]);
d268 2
a269 2
      *(int *) &registers[regno * 4 + i] = ptrace (PTRACE_PEEKUSR, inferior_pid,
					     (PTRACE_ARG3_TYPE) regaddr, 0);
d282 1
a282 1
error_exit:;
d292 1
a292 1
    for (regno = 0; regno < NUM_REGS - NUM_FREGS; regno++)
d320 6
a325 6
	{
	  scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
	  ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		  scratch, 0);
	  if (errno != 0)
	    {
d327 5
a331 5
	         registers is pretty serious.  */
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
d334 1
a334 1
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
d350 1
a350 1
	    regaddr += sizeof (int);
d354 1
a354 1
    for (regno = 0; regno < NUM_REGS - NUM_FREGS; regno++)
@


1.1.1.3
log
@import gdb-1999-11-01 snapshot
@
text
@a28 1
#include <sys/ptrace.h>
d32 3
d39 1
a39 2
static char my_registers[REGISTER_BYTES];
char *registers = my_registers;
d48 3
a50 1
#ifdef HAVE_SYS_REG_H
a53 5
/* Default the type of the ptrace transfer to int.  */
#ifndef PTRACE_XFER_TYPE
#define PTRACE_XFER_TYPE int
#endif

d170 1
a170 36
#ifdef I386_GNULINUX_TARGET
/* i386_register_raw_size[i] is the number of bytes of storage in the
   actual machine representation for register i.  */
int i386_register_raw_size[MAX_NUM_REGS] = {
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
   4,  4,  4,  4,
  10, 10, 10, 10,
  10, 10, 10, 10,
   4,  4,  4,  4,
   4,  4,  4,  4,
  16, 16, 16, 16,
  16, 16, 16, 16,
   4
};

int i386_register_byte[MAX_NUM_REGS];

static void
initialize_arch()
{
  /* Initialize the table saying where each register starts in the
     register file.  */
  {
    int i, offset;

    offset = 0;
    for (i = 0; i < MAX_NUM_REGS; i++)
      {
	i386_register_byte[i] = offset;
	offset += i386_register_raw_size[i];
      }
  }
}

d204 1
a204 7
#elif defined(TARGET_M68K)
static void
initialize_arch()
{
  return;
}

a233 250
/* start-sanitize-ia64 */
#elif defined(IA64_GNULINUX_TARGET)
#undef NUM_FREGS
#define NUM_FREGS 0

#include <asm/ptrace_offsets.h>

static int u_offsets[] =
  {
    /* general registers */
    -1,		/* gr0 not available; i.e, it's always zero */
    PT_R1,
    PT_R2,
    PT_R3,
    PT_R4,
    PT_R5,
    PT_R6,
    PT_R7,
    PT_R8,
    PT_R9,
    PT_R10,
    PT_R11,
    PT_R12,
    PT_R13,
    PT_R14,
    PT_R15,
    PT_R16,
    PT_R17,
    PT_R18,
    PT_R19,
    PT_R20,
    PT_R21,
    PT_R22,
    PT_R23,
    PT_R24,
    PT_R25,
    PT_R26,
    PT_R27,
    PT_R28,
    PT_R29,
    PT_R30,
    PT_R31,
    /* gr32 through gr127 not directly available via the ptrace interface */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    /* Floating point registers */
    -1, -1,	/* f0 and f1 not available (f0 is +0.0 and f1 is +1.0) */
    PT_F2,
    PT_F3,
    PT_F4,
    PT_F5,
    PT_F6,
    PT_F7,
    PT_F8,
    PT_F9,
    PT_F10,
    PT_F11,
    PT_F12,
    PT_F13,
    PT_F14,
    PT_F15,
    PT_F16,
    PT_F17,
    PT_F18,
    PT_F19,
    PT_F20,
    PT_F21,
    PT_F22,
    PT_F23,
    PT_F24,
    PT_F25,
    PT_F26,
    PT_F27,
    PT_F28,
    PT_F29,
    PT_F30,
    PT_F31,
    PT_F32,
    PT_F33,
    PT_F34,
    PT_F35,
    PT_F36,
    PT_F37,
    PT_F38,
    PT_F39,
    PT_F40,
    PT_F41,
    PT_F42,
    PT_F43,
    PT_F44,
    PT_F45,
    PT_F46,
    PT_F47,
    PT_F48,
    PT_F49,
    PT_F50,
    PT_F51,
    PT_F52,
    PT_F53,
    PT_F54,
    PT_F55,
    PT_F56,
    PT_F57,
    PT_F58,
    PT_F59,
    PT_F60,
    PT_F61,
    PT_F62,
    PT_F63,
    PT_F64,
    PT_F65,
    PT_F66,
    PT_F67,
    PT_F68,
    PT_F69,
    PT_F70,
    PT_F71,
    PT_F72,
    PT_F73,
    PT_F74,
    PT_F75,
    PT_F76,
    PT_F77,
    PT_F78,
    PT_F79,
    PT_F80,
    PT_F81,
    PT_F82,
    PT_F83,
    PT_F84,
    PT_F85,
    PT_F86,
    PT_F87,
    PT_F88,
    PT_F89,
    PT_F90,
    PT_F91,
    PT_F92,
    PT_F93,
    PT_F94,
    PT_F95,
    PT_F96,
    PT_F97,
    PT_F98,
    PT_F99,
    PT_F100,
    PT_F101,
    PT_F102,
    PT_F103,
    PT_F104,
    PT_F105,
    PT_F106,
    PT_F107,
    PT_F108,
    PT_F109,
    PT_F110,
    PT_F111,
    PT_F112,
    PT_F113,
    PT_F114,
    PT_F115,
    PT_F116,
    PT_F117,
    PT_F118,
    PT_F119,
    PT_F120,
    PT_F121,
    PT_F122,
    PT_F123,
    PT_F124,
    PT_F125,
    PT_F126,
    PT_F127,
    /* branch registers */
    PT_B0,
    PT_B1,
    PT_B2,
    PT_B3,
    PT_B4,
    PT_B5,
    PT_B6,
    PT_B7,
    /* other registers */
    PT_PR,
    PT_CR_IIP,
    PT_CR_IPSR,
    /* kernel registers not visible via ptrace interface (?) */
    -1, -1, -1, -1, -1, -1, -1, -1,
    /* hole */
    -1, -1, -1, -1, -1, -1, -1, -1,
    PT_AR_RSC,
    PT_AR_BSP,
    PT_AR_BSPSTORE,
    PT_AR_RNAT,
    -1,
    -1,		/* Not available: FCR, IA32 floating control register */
    -1, -1,
    -1,		/* Not available: EFLAG */
    -1,		/* Not available: CSD */
    -1,		/* Not available: SSD */
    -1,		/* Not available: CFLG */
    -1,		/* Not available: FSR */
    -1,		/* Not available: FIR */
    -1,		/* Not available: FDR */
    -1,
    PT_AR_CCV,
    -1, -1, -1,
    PT_AR_UNAT,
    -1, -1, -1,
    PT_AR_FPSR,
    -1, -1, -1,
    -1,		/* Not available: ITC */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1,
    PT_AR_PFS,
    PT_AR_LC,
    -1,		/* Not available: EC, the Epilog Count register */
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
    -1,
  };

int
ia64_register_u_addr (int blockend, int regnum)
{
  int addr;

  if (regnum < 0 || regnum >= NUM_REGS)
    error ("Invalid register number %d.", regnum);

  addr = u_offsets[regnum];
  if (addr == -1)
    addr = 0;

  return addr;
}

initialize_arch()
{
  return;
}
/* end-sanitize-ia64 */
d257 1
a257 1
  CORE_ADDR regaddr;
d266 1
a266 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d269 3
a271 3
      *(PTRACE_XFER_TYPE *) &registers[REGISTER_BYTE (regno) + i] =
	ptrace (PTRACE_PEEKUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr, 0);
      regaddr += sizeof (PTRACE_XFER_TYPE);
d307 2
a308 2
  CORE_ADDR regaddr;
  int i;
d338 1
a338 1
	    ptrace (PTRACE_POKEUSER, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
d376 1
a376 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
d378 2
a379 3
  register int count 
    = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1) 
      / sizeof (PTRACE_XFER_TYPE);
d381 1
a381 2
  register PTRACE_XFER_TYPE *buffer 
    = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d384 1
a384 1
  for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
d390 1
a390 1
  memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)), len);
d406 1
a406 1
  register CORE_ADDR addr = memaddr & -sizeof (PTRACE_XFER_TYPE);
d409 1
a409 1
  = (((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1) / sizeof (PTRACE_XFER_TYPE);
d411 1
a411 1
  register PTRACE_XFER_TYPE *buffer = (PTRACE_XFER_TYPE *) alloca (count * sizeof (PTRACE_XFER_TYPE));
d422 1
a422 1
		  addr + (count - 1) * sizeof (PTRACE_XFER_TYPE), 0);
d427 1
a427 1
  memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)), myaddr, len);
d431 1
a431 1
  for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
a445 1
  initialize_arch();
@


1.1.1.4
log
@import gdb-1999-11-08 snapshot
@
text
@d495 1
a495 1
    PT_CR_IFS,	/* was PT_AR_PFS, but it seemed bogus */
@


1.1.1.5
log
@import gdb-1999-11-16 snapshot
@
text
@a453 9
    /* predicate registers - we don't fetch these individually */
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
    -1, -1, -1, -1, -1, -1, -1, -1,
a462 2
    /* virtual frame pointer and virtual return address pointer */
    -1, -1,
d738 1
a738 1
initialize_low ()
d740 1
d742 6
@


1.1.1.6
log
@import gdb-1999-12-07 snapshot
@
text
@d277 261
@


