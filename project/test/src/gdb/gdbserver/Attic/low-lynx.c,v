head	1.7;
access;
symbols
	jimb-ppc64-linux-20030613-branch:1.6.0.50
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.48
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.46
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.44
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.42
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.40
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.38
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.36
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.34
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.32
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.30
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.28
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.26
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.24
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030203-mergepoint:1.6
	interps-20030202-branch:1.6.0.22
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.20
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.6
	kseitz_interps-20021105-merge:1.6
	kseitz_interps-20021103-merge:1.6
	drow-cplus-merge-20021020:1.6
	drow-cplus-merge-20021025:1.6
	carlton_dictionary-20021025-merge:1.6
	carlton_dictionary-20021011-merge:1.6
	drow-cplus-branch:1.6.0.18
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.16
	carlton_dictionary-20020920-branchpoint:1.6
	gdb_5_3-branch:1.6.0.14
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.12
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.10
	readline_4_3-import-branchpoint:1.6
	gdb_5_2_1-2002-07-23-release:1.6
	kseitz_interps-20020528-branch:1.6.0.8
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.6
	cagney_regbuf-20020515-branchpoint:1.6
	jimb-macro-020506-branch:1.6.0.4
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	dberlin-typesystem-branch:1.3.0.2
	dberlin-typesystem-branchpoint:1.3
	gdb-post-ptid_t-2001-05-03:1.3
	gdb-pre-ptid_t-2001-05-03:1.3
	insight-precleanup-2001-01-01:1.2
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2003.06.20.14.08.16;	author drow;	state dead;
branches;
next	1.6;

1.6
date	2002.01.17.21.13.49;	author drow;	state Exp;
branches
	1.6.16.1
	1.6.18.1;
next	1.5;

1.5
date	2002.01.17.20.46.16;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2001.07.26.02.23.58;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.06.08.21.44;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.17.47;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.02.04.44.24;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.11.17.02.30.36;	author jsm;	state Exp;
branches;
next	;

1.6.16.1
date	2003.06.27.21.50.18;	author carlton;	state dead;
branches;
next	;

1.6.18.1
date	2003.12.14.20.27.44;	author drow;	state dead;
branches;
next	;


desc
@@


1.7
log
@	* Makefile.in (SFILES): Update.
	* low-hppabsd.c, low-lynx.c, low-nbsd.c, low-sim.c, low-sparc.c,
	low-sun3.c: Remove files.
@
text
@/* Low level interface to ptrace, for the remote server for GDB.
   Copyright 1986, 1987, 1993, 1994, 1995, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "server.h"
#include "frame.h"
#include "inferior.h"

#include <stdio.h>
#include <sys/param.h>
#include <sys/dir.h>
#define LYNXOS
#include <sys/mem.h>
#include <sys/signal.h>
#include <sys/file.h>
#include <sys/kernel.h>
#ifndef __LYNXOS
#define __LYNXOS
#endif
#include <sys/itimer.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/proc.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sgtty.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/fpp.h>

static char my_registers[REGISTER_BYTES];
char *registers = my_registers;

#include <sys/ptrace.h>

/* Start an inferior process and returns its pid.
   ALLARGS is a vector of program-name and args. */

int
create_inferior (char *program, char **allargs)
{
  int pid;

  pid = fork ();
  if (pid < 0)
    perror_with_name ("fork");

  if (pid == 0)
    {
      int pgrp;

      /* Switch child to it's own process group so that signals won't
         directly affect gdbserver. */

      pgrp = getpid ();
      setpgrp (0, pgrp);
      ioctl (0, TIOCSPGRP, &pgrp);

      ptrace (PTRACE_TRACEME, 0, (PTRACE_ARG3_TYPE) 0, 0);

      execv (program, allargs);

      fprintf (stderr, "GDBserver (process %d):  Cannot exec %s: %s.\n",
	       getpid (), program,
	       errno < sys_nerr ? sys_errlist[errno] : "unknown error");
      fflush (stderr);
      _exit (0177);
    }

  return pid;
}

/* Attaching is not supported.  */
int
myattach (int pid)
{
  return -1;
}

/* Kill the inferior process.  Make us have no inferior.  */

void
kill_inferior (void)
{
  if (inferior_pid == 0)
    return;
  ptrace (PTRACE_KILL, inferior_pid, 0, 0);
  wait (0);

  inferior_pid = 0;
}

/* Return nonzero if the given thread is still alive.  */
int
mythread_alive (int pid)
{
  /* Arggh.  Apparently pthread_kill only works for threads within
     the process that calls pthread_kill.

     We want to avoid the lynx signal extensions as they simply don't
     map well to the generic gdb interface we want to keep.

     All we want to do is determine if a particular thread is alive;
     it appears as if we can just make a harmless thread specific
     ptrace call to do that.  */
  return (ptrace (PTRACE_THREADUSER,
		  BUILDPID (PIDGET (inferior_pid), pid), 0, 0) != -1);
}

/* Wait for process, returns status */

unsigned char
mywait (char *status)
{
  int pid;
  union wait w;

  while (1)
    {
      enable_async_io ();

      pid = wait (&w);

      disable_async_io ();

      if (pid != PIDGET (inferior_pid))
	perror_with_name ("wait");

      thread_from_wait = w.w_tid;
      inferior_pid = BUILDPID (inferior_pid, w.w_tid);

      if (WIFSTOPPED (w)
	  && WSTOPSIG (w) == SIGTRAP)
	{
	  int realsig;

	  realsig = ptrace (PTRACE_GETTRACESIG, inferior_pid,
			    (PTRACE_ARG3_TYPE) 0, 0);

	  if (realsig == SIGNEWTHREAD)
	    {
	      /* It's a new thread notification.  Nothing to do here since
	         the machine independent code in wait_for_inferior will
	         add the thread to the thread list and restart the thread
	         when pid != inferior_pid and pid is not in the thread list.
	         We don't even want to muck with realsig -- the code in
	         wait_for_inferior expects SIGTRAP.  */
	      ;
	    }
	}
      break;
    }

  if (WIFEXITED (w))
    {
      *status = 'W';
      return ((unsigned char) WEXITSTATUS (w));
    }
  else if (!WIFSTOPPED (w))
    {
      *status = 'X';
      return ((unsigned char) WTERMSIG (w));
    }

  fetch_inferior_registers (0);

  *status = 'T';
  return ((unsigned char) WSTOPSIG (w));
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
myresume (int step, int signal)
{
  errno = 0;
  ptrace (step ? PTRACE_SINGLESTEP_ONE : PTRACE_CONT,
	  BUILDPID (inferior_pid, cont_thread == -1 ? 0 : cont_thread),
	  1, signal);
  if (errno)
    perror_with_name ("ptrace");
}

#undef offsetof
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)

/* Mapping between GDB register #s and offsets into econtext.  Must be
   consistent with REGISTER_NAMES macro in various tmXXX.h files. */

#define X(ENTRY)(offsetof(struct econtext, ENTRY))

#ifdef I386
/* Mappings from tm-i386v.h */

static int regmap[] =
{
  X (eax),
  X (ecx),
  X (edx),
  X (ebx),
  X (esp),			/* sp */
  X (ebp),			/* fp */
  X (esi),
  X (edi),
  X (eip),			/* pc */
  X (flags),			/* ps */
  X (cs),
  X (ss),
  X (ds),
  X (es),
  X (ecode),			/* Lynx doesn't give us either fs or gs, so */
  X (fault),			/* we just substitute these two in the hopes
				   that they are useful. */
};
#endif

#ifdef M68K
/* Mappings from tm-m68k.h */

static int regmap[] =
{
  X (regs[0]),			/* d0 */
  X (regs[1]),			/* d1 */
  X (regs[2]),			/* d2 */
  X (regs[3]),			/* d3 */
  X (regs[4]),			/* d4 */
  X (regs[5]),			/* d5 */
  X (regs[6]),			/* d6 */
  X (regs[7]),			/* d7 */
  X (regs[8]),			/* a0 */
  X (regs[9]),			/* a1 */
  X (regs[10]),			/* a2 */
  X (regs[11]),			/* a3 */
  X (regs[12]),			/* a4 */
  X (regs[13]),			/* a5 */
  X (regs[14]),			/* fp */
  0,				/* sp */
  X (status),			/* ps */
  X (pc),

  X (fregs[0 * 3]),		/* fp0 */
  X (fregs[1 * 3]),		/* fp1 */
  X (fregs[2 * 3]),		/* fp2 */
  X (fregs[3 * 3]),		/* fp3 */
  X (fregs[4 * 3]),		/* fp4 */
  X (fregs[5 * 3]),		/* fp5 */
  X (fregs[6 * 3]),		/* fp6 */
  X (fregs[7 * 3]),		/* fp7 */

  X (fcregs[0]),		/* fpcontrol */
  X (fcregs[1]),		/* fpstatus */
  X (fcregs[2]),		/* fpiaddr */
  X (ssw),			/* fpcode */
  X (fault),			/* fpflags */
};
#endif

#ifdef SPARC
/* Mappings from tm-sparc.h */

#define FX(ENTRY)(offsetof(struct fcontext, ENTRY))

static int regmap[] =
{
  -1,				/* g0 */
  X (g1),
  X (g2),
  X (g3),
  X (g4),
  -1,				/* g5->g7 aren't saved by Lynx */
  -1,
  -1,

  X (o[0]),
  X (o[1]),
  X (o[2]),
  X (o[3]),
  X (o[4]),
  X (o[5]),
  X (o[6]),			/* sp */
  X (o[7]),			/* ra */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* l0 -> l7 */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* i0 -> i7 */

  FX (f.fregs[0]),		/* f0 */
  FX (f.fregs[1]),
  FX (f.fregs[2]),
  FX (f.fregs[3]),
  FX (f.fregs[4]),
  FX (f.fregs[5]),
  FX (f.fregs[6]),
  FX (f.fregs[7]),
  FX (f.fregs[8]),
  FX (f.fregs[9]),
  FX (f.fregs[10]),
  FX (f.fregs[11]),
  FX (f.fregs[12]),
  FX (f.fregs[13]),
  FX (f.fregs[14]),
  FX (f.fregs[15]),
  FX (f.fregs[16]),
  FX (f.fregs[17]),
  FX (f.fregs[18]),
  FX (f.fregs[19]),
  FX (f.fregs[20]),
  FX (f.fregs[21]),
  FX (f.fregs[22]),
  FX (f.fregs[23]),
  FX (f.fregs[24]),
  FX (f.fregs[25]),
  FX (f.fregs[26]),
  FX (f.fregs[27]),
  FX (f.fregs[28]),
  FX (f.fregs[29]),
  FX (f.fregs[30]),
  FX (f.fregs[31]),

  X (y),
  X (psr),
  X (wim),
  X (tbr),
  X (pc),
  X (npc),
  FX (fsr),			/* fpsr */
  -1,				/* cpsr */
};
#endif

#ifdef SPARC

/* This routine handles some oddball cases for Sparc registers and LynxOS.
   In partucular, it causes refs to G0, g5->7, and all fp regs to return zero.
   It also handles knows where to find the I & L regs on the stack.  */

void
fetch_inferior_registers (int regno)
{
#if 0
  int whatregs = 0;

#define WHATREGS_FLOAT 1
#define WHATREGS_GEN 2
#define WHATREGS_STACK 4

  if (regno == -1)
    whatregs = WHATREGS_FLOAT | WHATREGS_GEN | WHATREGS_STACK;
  else if (regno >= L0_REGNUM && regno <= I7_REGNUM)
    whatregs = WHATREGS_STACK;
  else if (regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
    whatregs = WHATREGS_FLOAT;
  else
    whatregs = WHATREGS_GEN;

  if (whatregs & WHATREGS_GEN)
    {
      struct econtext ec;	/* general regs */
      char buf[MAX_REGISTER_RAW_SIZE];
      int retval;
      int i;

      errno = 0;
      retval = ptrace (PTRACE_GETREGS,
		       BUILDPID (inferior_pid, general_thread),
		       (PTRACE_ARG3_TYPE) & ec,
		       0);
      if (errno)
	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");

      memset (buf, 0, REGISTER_RAW_SIZE (G0_REGNUM));
      supply_register (G0_REGNUM, buf);
      supply_register (TBR_REGNUM, (char *) &ec.tbr);

      memcpy (&registers[REGISTER_BYTE (G1_REGNUM)], &ec.g1,
	      4 * REGISTER_RAW_SIZE (G1_REGNUM));
      for (i = G1_REGNUM; i <= G1_REGNUM + 3; i++)
	register_valid[i] = 1;

      supply_register (PS_REGNUM, (char *) &ec.psr);
      supply_register (Y_REGNUM, (char *) &ec.y);
      supply_register (PC_REGNUM, (char *) &ec.pc);
      supply_register (NPC_REGNUM, (char *) &ec.npc);
      supply_register (WIM_REGNUM, (char *) &ec.wim);

      memcpy (&registers[REGISTER_BYTE (O0_REGNUM)], ec.o,
	      8 * REGISTER_RAW_SIZE (O0_REGNUM));
      for (i = O0_REGNUM; i <= O0_REGNUM + 7; i++)
	register_valid[i] = 1;
    }

  if (whatregs & WHATREGS_STACK)
    {
      CORE_ADDR sp;
      int i;

      sp = read_register (SP_REGNUM);

      target_xfer_memory (sp + FRAME_SAVED_I0,
			  &registers[REGISTER_BYTE (I0_REGNUM)],
			  8 * REGISTER_RAW_SIZE (I0_REGNUM), 0);
      for (i = I0_REGNUM; i <= I7_REGNUM; i++)
	register_valid[i] = 1;

      target_xfer_memory (sp + FRAME_SAVED_L0,
			  &registers[REGISTER_BYTE (L0_REGNUM)],
			  8 * REGISTER_RAW_SIZE (L0_REGNUM), 0);
      for (i = L0_REGNUM; i <= L0_REGNUM + 7; i++)
	register_valid[i] = 1;
    }

  if (whatregs & WHATREGS_FLOAT)
    {
      struct fcontext fc;	/* fp regs */
      int retval;
      int i;

      errno = 0;
      retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & fc,
		       0);
      if (errno)
	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");

      memcpy (&registers[REGISTER_BYTE (FP0_REGNUM)], fc.f.fregs,
	      32 * REGISTER_RAW_SIZE (FP0_REGNUM));
      for (i = FP0_REGNUM; i <= FP0_REGNUM + 31; i++)
	register_valid[i] = 1;

      supply_register (FPS_REGNUM, (char *) &fc.fsr);
    }
#endif
}

/* This routine handles storing of the I & L regs for the Sparc.  The trick
   here is that they actually live on the stack.  The really tricky part is
   that when changing the stack pointer, the I & L regs must be written to
   where the new SP points, otherwise the regs will be incorrect when the
   process is started up again.   We assume that the I & L regs are valid at
   this point.  */

void
store_inferior_registers (int regno)
{
#if 0
  int whatregs = 0;

  if (regno == -1)
    whatregs = WHATREGS_FLOAT | WHATREGS_GEN | WHATREGS_STACK;
  else if (regno >= L0_REGNUM && regno <= I7_REGNUM)
    whatregs = WHATREGS_STACK;
  else if (regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
    whatregs = WHATREGS_FLOAT;
  else if (regno == SP_REGNUM)
    whatregs = WHATREGS_STACK | WHATREGS_GEN;
  else
    whatregs = WHATREGS_GEN;

  if (whatregs & WHATREGS_GEN)
    {
      struct econtext ec;	/* general regs */
      int retval;

      ec.tbr = read_register (TBR_REGNUM);
      memcpy (&ec.g1, &registers[REGISTER_BYTE (G1_REGNUM)],
	      4 * REGISTER_RAW_SIZE (G1_REGNUM));

      ec.psr = read_register (PS_REGNUM);
      ec.y = read_register (Y_REGNUM);
      ec.pc = read_register (PC_REGNUM);
      ec.npc = read_register (NPC_REGNUM);
      ec.wim = read_register (WIM_REGNUM);

      memcpy (ec.o, &registers[REGISTER_BYTE (O0_REGNUM)],
	      8 * REGISTER_RAW_SIZE (O0_REGNUM));

      errno = 0;
      retval = ptrace (PTRACE_SETREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & ec,
		       0);
      if (errno)
	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");
    }

  if (whatregs & WHATREGS_STACK)
    {
      int regoffset;
      CORE_ADDR sp;

      sp = read_register (SP_REGNUM);

      if (regno == -1 || regno == SP_REGNUM)
	{
	  if (!register_valid[L0_REGNUM + 5])
	    abort ();
	  target_xfer_memory (sp + FRAME_SAVED_I0,
			      &registers[REGISTER_BYTE (I0_REGNUM)],
			      8 * REGISTER_RAW_SIZE (I0_REGNUM), 1);

	  target_xfer_memory (sp + FRAME_SAVED_L0,
			      &registers[REGISTER_BYTE (L0_REGNUM)],
			      8 * REGISTER_RAW_SIZE (L0_REGNUM), 1);
	}
      else if (regno >= L0_REGNUM && regno <= I7_REGNUM)
	{
	  if (!register_valid[regno])
	    abort ();
	  if (regno >= L0_REGNUM && regno <= L0_REGNUM + 7)
	    regoffset = REGISTER_BYTE (regno) - REGISTER_BYTE (L0_REGNUM)
	      + FRAME_SAVED_L0;
	  else
	    regoffset = REGISTER_BYTE (regno) - REGISTER_BYTE (I0_REGNUM)
	      + FRAME_SAVED_I0;
	  target_xfer_memory (sp + regoffset, &registers[REGISTER_BYTE (regno)],
			      REGISTER_RAW_SIZE (regno), 1);
	}
    }

  if (whatregs & WHATREGS_FLOAT)
    {
      struct fcontext fc;	/* fp regs */
      int retval;

/* We read fcontext first so that we can get good values for fq_t... */
      errno = 0;
      retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & fc,
		       0);
      if (errno)
	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");

      memcpy (fc.f.fregs, &registers[REGISTER_BYTE (FP0_REGNUM)],
	      32 * REGISTER_RAW_SIZE (FP0_REGNUM));

      fc.fsr = read_register (FPS_REGNUM);

      errno = 0;
      retval = ptrace (PTRACE_SETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & fc,
		       0);
      if (errno)
	perror_with_name ("Sparc fetch_inferior_registers(ptrace)");
    }
#endif
}
#endif /* SPARC */

#ifndef SPARC

/* Return the offset relative to the start of the per-thread data to the
   saved context block.  */

static unsigned long
lynx_registers_addr (void)
{
  CORE_ADDR stblock;
  int ecpoff = offsetof (st_t, ecp);
  CORE_ADDR ecp;

  errno = 0;
  stblock = (CORE_ADDR) ptrace (PTRACE_THREADUSER, BUILDPID (inferior_pid, general_thread),
				(PTRACE_ARG3_TYPE) 0, 0);
  if (errno)
    perror_with_name ("PTRACE_THREADUSER");

  ecp = (CORE_ADDR) ptrace (PTRACE_PEEKTHREAD, BUILDPID (inferior_pid, general_thread),
			    (PTRACE_ARG3_TYPE) ecpoff, 0);
  if (errno)
    perror_with_name ("lynx_registers_addr(PTRACE_PEEKTHREAD)");

  return ecp - stblock;
}

/* Fetch one or more registers from the inferior.  REGNO == -1 to get
   them all.  We actually fetch more than requested, when convenient,
   marking them as valid so we won't fetch them again.  */

void
fetch_inferior_registers (int ignored)
{
  int regno;
  unsigned long reg;
  unsigned long ecp;

  ecp = lynx_registers_addr ();

  for (regno = 0; regno < NUM_REGS; regno++)
    {
      int ptrace_fun = PTRACE_PEEKTHREAD;

#ifdef PTRACE_PEEKUSP
      ptrace_fun = regno == SP_REGNUM ? PTRACE_PEEKUSP : PTRACE_PEEKTHREAD;
#endif

      errno = 0;
      reg = ptrace (ptrace_fun, BUILDPID (inferior_pid, general_thread),
		    (PTRACE_ARG3_TYPE) (ecp + regmap[regno]), 0);
      if (errno)
	perror_with_name ("fetch_inferior_registers(PTRACE_PEEKTHREAD)");

      *(unsigned long *) &registers[REGISTER_BYTE (regno)] = reg;
    }
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int ignored)
{
  int regno;
  unsigned long reg;
  unsigned long ecp;

  ecp = lynx_registers_addr ();

  for (regno = 0; regno < NUM_REGS; regno++)
    {
      int ptrace_fun = PTRACE_POKEUSER;

#ifdef PTRACE_POKEUSP
      ptrace_fun = regno == SP_REGNUM ? PTRACE_POKEUSP : PTRACE_POKEUSER;
#endif

      reg = *(unsigned long *) &registers[REGISTER_BYTE (regno)];

      errno = 0;
      ptrace (ptrace_fun, BUILDPID (inferior_pid, general_thread),
	      (PTRACE_ARG3_TYPE) (ecp + regmap[regno]), reg);
      if (errno)
	perror_with_name ("PTRACE_POKEUSER");
    }
}

#endif /* ! SPARC */

/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
   in the NEW_SUN_PTRACE case.
   It ought to be straightforward.  But it appears that writing did
   not write the data that I specified.  I cannot understand where
   it got the data that it actually did write.  */

/* Copy LEN bytes from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.  */

void
read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (int);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
  /* Allocate buffer of that many longwords.  */
  register int *buffer = (int *) alloca (count * sizeof (int));

  /* Read all the longwords */
  for (i = 0; i < count; i++, addr += sizeof (int))
    {
      buffer[i] = ptrace (PTRACE_PEEKTEXT, BUILDPID (inferior_pid, general_thread), addr, 0);
    }

  /* Copy appropriate bytes out of the buffer.  */
  memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (int) - 1)), len);
}

/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.
   On failure (cannot write the inferior)
   returns the value of errno.  */

int
write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (int);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
  /* Allocate buffer of that many longwords.  */
  register int *buffer = (int *) alloca (count * sizeof (int));
  extern int errno;

  /* Fill start and end extra bytes of buffer with existing memory data.  */

  buffer[0] = ptrace (PTRACE_PEEKTEXT, BUILDPID (inferior_pid, general_thread), addr, 0);

  if (count > 1)
    {
      buffer[count - 1]
	= ptrace (PTRACE_PEEKTEXT, BUILDPID (inferior_pid, general_thread),
		  addr + (count - 1) * sizeof (int), 0);
    }

  /* Copy data to be written over corresponding part of buffer */

  memcpy ((char *) buffer + (memaddr & (sizeof (int) - 1)), myaddr, len);

  /* Write the entire buffer.  */

  for (i = 0; i < count; i++, addr += sizeof (int))
    {
      while (1)
	{
	  errno = 0;
	  ptrace (PTRACE_POKETEXT, BUILDPID (inferior_pid, general_thread), addr, buffer[i]);
	  if (errno)
	    {
	      fprintf (stderr, "\
ptrace (PTRACE_POKETEXT): errno=%d, pid=0x%x, addr=0x%x, buffer[i] = 0x%x\n",
		       errno, BUILDPID (inferior_pid, general_thread),
		       addr, buffer[i]);
	      fprintf (stderr, "Sleeping for 1 second\n");
	      sleep (1);
	    }
	  else
	    break;
	}
    }

  return 0;
}

void
initialize_low (void)
{
}
@


1.6
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/low-hppabsd.c, gdbserver/low-lynx.c,
        gdbserver/low-nbsd.c, gdbserver/low-sim.c,
        gdbserver/low-sparc.c, gdbserver/low-sun3.c,
        gdbserver/low-linux.c, gdbserver/server.c: Correct copyright notices.
@
text
@@


1.6.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.6.16.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.5
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * low-hppabsd.c (myattach): New function, returning -1.
        * low-lynx.c (myattach): Likewise.
        * low-nbsd.c (myattach): Likewise.
        * low-sim.c (myattach): Likewise.
        * low-sparc.c (myattach): Likewise.
        * low-sun3.c (myattach): Likewise.

        * low-linux.c (myattach): New function.

        * server.c (attach_inferior): New function.
        (main): Handle "--attach".
@
text
@d2 1
a2 1
   Copyright 1986, 1987, 1993, 1994, 1995, 1999, 2000
@


1.4
log
@        * infptrace.c (child_xfer_memory): Add cast to CORE_ADDR.
        * infttrace.c (child_xfer_memory): Likewise.
        * symm-nat.c (child_xfer_memory): Likewise.
        * gdbserver/low-hppabsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-linux.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-lynx.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-nbsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sparc.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sun3.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
@
text
@d90 7
@


1.3
log
@Update/correct copyright notices.
@
text
@d660 1
a660 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
d687 1
a687 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
@


1.2
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright (C) 1986, 1987, 1993 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d47 2
a48 1
char registers[REGISTER_BYTES];
d56 1
a56 3
create_inferior (program, allargs)
     char *program;
     char **allargs;
d69 1
a69 1
	 directly affect gdbserver. */
d71 2
a72 2
      pgrp = getpid();
      setpgrp(0, pgrp);
d75 1
a75 1
      ptrace (PTRACE_TRACEME, 0, (PTRACE_ARG3_TYPE)0, 0);
d80 1
a80 1
	       getpid(), program,
d92 1
a92 1
kill_inferior ()
d104 1
a104 2
mythread_alive (pid)
     int pid;
d122 1
a122 2
mywait (status)
     char *status;
d129 1
a129 1
      enable_async_io();
d133 1
a133 1
      disable_async_io();
d135 1
a135 1
      if (pid != PIDGET(inferior_pid))
d141 2
a142 2
      if (WIFSTOPPED(w)
	  && WSTOPSIG(w) == SIGTRAP)
d147 1
a147 1
			    (PTRACE_ARG3_TYPE)0, 0);
d152 5
a156 5
		 the machine independent code in wait_for_inferior will
		 add the thread to the thread list and restart the thread
		 when pid != inferior_pid and pid is not in the thread list.
		 We don't even want to muck with realsig -- the code in
		 wait_for_inferior expects SIGTRAP.  */
d185 1
a185 3
myresume (step, signal)
     int step;
     int signal;
d208 16
a223 16
  X(eax),
  X(ecx),
  X(edx),
  X(ebx),
  X(esp),			/* sp */
  X(ebp),			/* fp */
  X(esi),
  X(edi),
  X(eip),			/* pc */
  X(flags),			/* ps */
  X(cs),
  X(ss),
  X(ds),
  X(es),
  X(ecode),			/* Lynx doesn't give us either fs or gs, so */
  X(fault),			/* we just substitute these two in the hopes
d233 15
a247 15
  X(regs[0]),			/* d0 */
  X(regs[1]),			/* d1 */
  X(regs[2]),			/* d2 */
  X(regs[3]),			/* d3 */
  X(regs[4]),			/* d4 */
  X(regs[5]),			/* d5 */
  X(regs[6]),			/* d6 */
  X(regs[7]),			/* d7 */
  X(regs[8]),			/* a0 */
  X(regs[9]),			/* a1 */
  X(regs[10]),			/* a2 */
  X(regs[11]),			/* a3 */
  X(regs[12]),			/* a4 */
  X(regs[13]),			/* a5 */
  X(regs[14]),			/* fp */
d249 2
a250 2
  X(status),			/* ps */
  X(pc),
d252 14
a265 14
  X(fregs[0*3]),		/* fp0 */
  X(fregs[1*3]),		/* fp1 */
  X(fregs[2*3]),		/* fp2 */
  X(fregs[3*3]),		/* fp3 */
  X(fregs[4*3]),		/* fp4 */
  X(fregs[5*3]),		/* fp5 */
  X(fregs[6*3]),		/* fp6 */
  X(fregs[7*3]),		/* fp7 */

  X(fcregs[0]),			/* fpcontrol */
  X(fcregs[1]),			/* fpstatus */
  X(fcregs[2]),			/* fpiaddr */
  X(ssw),			/* fpcode */
  X(fault),			/* fpflags */
d277 4
a280 4
  X(g1),
  X(g2),
  X(g3),
  X(g4),
d285 53
a337 53
  X(o[0]),
  X(o[1]),
  X(o[2]),
  X(o[3]),
  X(o[4]),
  X(o[5]),
  X(o[6]),			/* sp */
  X(o[7]),			/* ra */

  -1,-1,-1,-1,-1,-1,-1,-1,	/* l0 -> l7 */

  -1,-1,-1,-1,-1,-1,-1,-1,	/* i0 -> i7 */

  FX(f.fregs[0]),		/* f0 */
  FX(f.fregs[1]),
  FX(f.fregs[2]),
  FX(f.fregs[3]),
  FX(f.fregs[4]),
  FX(f.fregs[5]),
  FX(f.fregs[6]),
  FX(f.fregs[7]),
  FX(f.fregs[8]),
  FX(f.fregs[9]),
  FX(f.fregs[10]),
  FX(f.fregs[11]),
  FX(f.fregs[12]),
  FX(f.fregs[13]),
  FX(f.fregs[14]),
  FX(f.fregs[15]),
  FX(f.fregs[16]),
  FX(f.fregs[17]),
  FX(f.fregs[18]),
  FX(f.fregs[19]),
  FX(f.fregs[20]),
  FX(f.fregs[21]),
  FX(f.fregs[22]),
  FX(f.fregs[23]),
  FX(f.fregs[24]),
  FX(f.fregs[25]),
  FX(f.fregs[26]),
  FX(f.fregs[27]),
  FX(f.fregs[28]),
  FX(f.fregs[29]),
  FX(f.fregs[30]),
  FX(f.fregs[31]),

  X(y),
  X(psr),
  X(wim),
  X(tbr),
  X(pc),
  X(npc),
  FX(fsr),			/* fpsr */
d349 1
a349 2
fetch_inferior_registers (regno)
     int regno;
d369 1
a369 1
      struct econtext ec;		/* general regs */
d377 1
a377 1
		       (PTRACE_ARG3_TYPE) &ec,
d381 1
a381 1
  
d384 1
a384 1
      supply_register (TBR_REGNUM, (char *)&ec.tbr);
d391 5
a395 5
      supply_register (PS_REGNUM, (char *)&ec.psr);
      supply_register (Y_REGNUM, (char *)&ec.y);
      supply_register (PC_REGNUM, (char *)&ec.pc);
      supply_register (NPC_REGNUM, (char *)&ec.npc);
      supply_register (WIM_REGNUM, (char *)&ec.wim);
d411 1
a411 1
			  &registers[REGISTER_BYTE(I0_REGNUM)],
d417 1
a417 1
			  &registers[REGISTER_BYTE(L0_REGNUM)],
d425 1
a425 1
      struct fcontext fc;		/* fp regs */
d430 1
a430 1
      retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) &fc,
d434 1
a434 1
  
d440 1
a440 1
      supply_register (FPS_REGNUM, (char *)&fc.fsr);
d453 1
a453 2
store_inferior_registers (regno)
     int regno;
d471 1
a471 1
      struct econtext ec;		/* general regs */
d488 1
a488 1
      retval = ptrace (PTRACE_SETREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) &ec,
d503 2
a504 2
	  if (!register_valid[L0_REGNUM+5])
	    abort();
d516 1
a516 1
	    abort();
d530 1
a530 1
      struct fcontext fc;		/* fp regs */
d535 1
a535 1
      retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) &fc,
d539 1
a539 1
  
d546 1
a546 1
      retval = ptrace (PTRACE_SETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) &fc,
d550 1
a550 1
      }
d561 1
a561 1
lynx_registers_addr()
d564 1
a564 1
  int ecpoff = offsetof(st_t, ecp);
d569 1
a569 1
				(PTRACE_ARG3_TYPE)0, 0);
d574 1
a574 1
			    (PTRACE_ARG3_TYPE)ecpoff, 0);
d586 1
a586 2
fetch_inferior_registers (ignored)
     int ignored;
d592 1
a592 1
  ecp = lynx_registers_addr();
d607 2
a608 2
  
      *(unsigned long *)&registers[REGISTER_BYTE (regno)] = reg;
d617 1
a617 2
store_inferior_registers (ignored)
     int ignored;
d623 1
a623 1
  ecp = lynx_registers_addr();
d633 1
a633 1
      reg = *(unsigned long *)&registers[REGISTER_BYTE (regno)];
d655 1
a655 4
read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d682 1
a682 4
write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d719 1
a719 1
	      fprintf(stderr, "\
d721 4
a724 4
		      errno, BUILDPID (inferior_pid, general_thread),
		      addr, buffer[i]);
	      fprintf(stderr, "Sleeping for 1 second\n");
	      sleep(1);
d732 5
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d69 1
a69 1
         directly affect gdbserver. */
d71 2
a72 2
      pgrp = getpid ();
      setpgrp (0, pgrp);
d75 1
a75 1
      ptrace (PTRACE_TRACEME, 0, (PTRACE_ARG3_TYPE) 0, 0);
d80 1
a80 1
	       getpid (), program,
d131 1
a131 1
      enable_async_io ();
d135 1
a135 1
      disable_async_io ();
d137 1
a137 1
      if (pid != PIDGET (inferior_pid))
d143 2
a144 2
      if (WIFSTOPPED (w)
	  && WSTOPSIG (w) == SIGTRAP)
d149 1
a149 1
			    (PTRACE_ARG3_TYPE) 0, 0);
d154 5
a158 5
	         the machine independent code in wait_for_inferior will
	         add the thread to the thread list and restart the thread
	         when pid != inferior_pid and pid is not in the thread list.
	         We don't even want to muck with realsig -- the code in
	         wait_for_inferior expects SIGTRAP.  */
d212 16
a227 16
  X (eax),
  X (ecx),
  X (edx),
  X (ebx),
  X (esp),			/* sp */
  X (ebp),			/* fp */
  X (esi),
  X (edi),
  X (eip),			/* pc */
  X (flags),			/* ps */
  X (cs),
  X (ss),
  X (ds),
  X (es),
  X (ecode),			/* Lynx doesn't give us either fs or gs, so */
  X (fault),			/* we just substitute these two in the hopes
d237 15
a251 15
  X (regs[0]),			/* d0 */
  X (regs[1]),			/* d1 */
  X (regs[2]),			/* d2 */
  X (regs[3]),			/* d3 */
  X (regs[4]),			/* d4 */
  X (regs[5]),			/* d5 */
  X (regs[6]),			/* d6 */
  X (regs[7]),			/* d7 */
  X (regs[8]),			/* a0 */
  X (regs[9]),			/* a1 */
  X (regs[10]),			/* a2 */
  X (regs[11]),			/* a3 */
  X (regs[12]),			/* a4 */
  X (regs[13]),			/* a5 */
  X (regs[14]),			/* fp */
d253 2
a254 2
  X (status),			/* ps */
  X (pc),
d256 14
a269 14
  X (fregs[0 * 3]),		/* fp0 */
  X (fregs[1 * 3]),		/* fp1 */
  X (fregs[2 * 3]),		/* fp2 */
  X (fregs[3 * 3]),		/* fp3 */
  X (fregs[4 * 3]),		/* fp4 */
  X (fregs[5 * 3]),		/* fp5 */
  X (fregs[6 * 3]),		/* fp6 */
  X (fregs[7 * 3]),		/* fp7 */

  X (fcregs[0]),		/* fpcontrol */
  X (fcregs[1]),		/* fpstatus */
  X (fcregs[2]),		/* fpiaddr */
  X (ssw),			/* fpcode */
  X (fault),			/* fpflags */
d281 4
a284 4
  X (g1),
  X (g2),
  X (g3),
  X (g4),
d289 53
a341 53
  X (o[0]),
  X (o[1]),
  X (o[2]),
  X (o[3]),
  X (o[4]),
  X (o[5]),
  X (o[6]),			/* sp */
  X (o[7]),			/* ra */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* l0 -> l7 */

  -1, -1, -1, -1, -1, -1, -1, -1,	/* i0 -> i7 */

  FX (f.fregs[0]),		/* f0 */
  FX (f.fregs[1]),
  FX (f.fregs[2]),
  FX (f.fregs[3]),
  FX (f.fregs[4]),
  FX (f.fregs[5]),
  FX (f.fregs[6]),
  FX (f.fregs[7]),
  FX (f.fregs[8]),
  FX (f.fregs[9]),
  FX (f.fregs[10]),
  FX (f.fregs[11]),
  FX (f.fregs[12]),
  FX (f.fregs[13]),
  FX (f.fregs[14]),
  FX (f.fregs[15]),
  FX (f.fregs[16]),
  FX (f.fregs[17]),
  FX (f.fregs[18]),
  FX (f.fregs[19]),
  FX (f.fregs[20]),
  FX (f.fregs[21]),
  FX (f.fregs[22]),
  FX (f.fregs[23]),
  FX (f.fregs[24]),
  FX (f.fregs[25]),
  FX (f.fregs[26]),
  FX (f.fregs[27]),
  FX (f.fregs[28]),
  FX (f.fregs[29]),
  FX (f.fregs[30]),
  FX (f.fregs[31]),

  X (y),
  X (psr),
  X (wim),
  X (tbr),
  X (pc),
  X (npc),
  FX (fsr),			/* fpsr */
d374 1
a374 1
      struct econtext ec;	/* general regs */
d382 1
a382 1
		       (PTRACE_ARG3_TYPE) & ec,
d386 1
a386 1

d389 1
a389 1
      supply_register (TBR_REGNUM, (char *) &ec.tbr);
d396 5
a400 5
      supply_register (PS_REGNUM, (char *) &ec.psr);
      supply_register (Y_REGNUM, (char *) &ec.y);
      supply_register (PC_REGNUM, (char *) &ec.pc);
      supply_register (NPC_REGNUM, (char *) &ec.npc);
      supply_register (WIM_REGNUM, (char *) &ec.wim);
d416 1
a416 1
			  &registers[REGISTER_BYTE (I0_REGNUM)],
d422 1
a422 1
			  &registers[REGISTER_BYTE (L0_REGNUM)],
d430 1
a430 1
      struct fcontext fc;	/* fp regs */
d435 1
a435 1
      retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & fc,
d439 1
a439 1

d445 1
a445 1
      supply_register (FPS_REGNUM, (char *) &fc.fsr);
d477 1
a477 1
      struct econtext ec;	/* general regs */
d494 1
a494 1
      retval = ptrace (PTRACE_SETREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & ec,
d509 2
a510 2
	  if (!register_valid[L0_REGNUM + 5])
	    abort ();
d522 1
a522 1
	    abort ();
d536 1
a536 1
      struct fcontext fc;	/* fp regs */
d541 1
a541 1
      retval = ptrace (PTRACE_GETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & fc,
d545 1
a545 1

d552 1
a552 1
      retval = ptrace (PTRACE_SETFPREGS, BUILDPID (inferior_pid, general_thread), (PTRACE_ARG3_TYPE) & fc,
d556 1
a556 1
    }
d567 1
a567 1
lynx_registers_addr ()
d570 1
a570 1
  int ecpoff = offsetof (st_t, ecp);
d575 1
a575 1
				(PTRACE_ARG3_TYPE) 0, 0);
d580 1
a580 1
			    (PTRACE_ARG3_TYPE) ecpoff, 0);
d599 1
a599 1
  ecp = lynx_registers_addr ();
d614 2
a615 2

      *(unsigned long *) &registers[REGISTER_BYTE (regno)] = reg;
d631 1
a631 1
  ecp = lynx_registers_addr ();
d641 1
a641 1
      reg = *(unsigned long *) &registers[REGISTER_BYTE (regno)];
d733 1
a733 1
	      fprintf (stderr, "\
d735 4
a738 4
		       errno, BUILDPID (inferior_pid, general_thread),
		       addr, buffer[i]);
	      fprintf (stderr, "Sleeping for 1 second\n");
	      sleep (1);
@


1.1.1.3
log
@import gdb-1999-11-01 snapshot
@
text
@d47 1
a47 2
static char my_registers[REGISTER_BYTES];
char *registers = my_registers;
@


1.1.1.4
log
@import gdb-1999-11-16 snapshot
@
text
@a748 5

void
initialize_low ()
{
}
@


