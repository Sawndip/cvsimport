head	1.12;
access;
symbols
	jimb-ppc64-linux-20030613-branch:1.11.0.50
	jimb-ppc64-linux-20030613-branchpoint:1.11
	cagney_convert-20030606-branch:1.11.0.48
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.46
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.44
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.42
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.40
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.38
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.36
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.34
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.32
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.30
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.28
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.26
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.24
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030203-mergepoint:1.11
	interps-20030202-branch:1.11.0.22
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.20
	cagney-unwind-20030108-branchpoint:1.11
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.11
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.18
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.16
	carlton_dictionary-20020920-branchpoint:1.11
	gdb_5_3-branch:1.11.0.14
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.12
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.10
	readline_4_3-import-branchpoint:1.11
	gdb_5_2_1-2002-07-23-release:1.11
	kseitz_interps-20020528-branch:1.11.0.8
	kseitz_interps-20020528-branchpoint:1.11
	cagney_regbuf-20020515-branch:1.11.0.6
	cagney_regbuf-20020515-branchpoint:1.11
	jimb-macro-020506-branch:1.11.0.4
	jimb-macro-020506-branchpoint:1.11
	gdb_5_2-2002-04-29-release:1.11
	gdb_5_2-branch:1.11.0.2
	gdb_5_2-2002-03-03-branchpoint:1.11
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.4
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.2
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.7.0.2
	dberlin-typesystem-branchpoint:1.7
	gdb-post-ptid_t-2001-05-03:1.7
	gdb-pre-ptid_t-2001-05-03:1.7
	insight-precleanup-2001-01-01:1.3
	gdb-post-protoization-2000-07-29:1.2
	gdb-pre-protoization-2000-07-29:1.1.1.4
	gdb-premipsmulti-2000-06-06-branch:1.1.1.4.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.4
	gdb-post-params-removal-2000-06-04:1.1.1.4
	gdb-pre-params-removal-2000-06-04:1.1.1.4
	gdb-post-params-removal-2000-05-28:1.1.1.4
	gdb-pre-params-removal-2000-05-28:1.1.1.4
	gdb_5_0-2000-05-19-release:1.1.1.4
	gdb_4_18_2-2000-05-18-release:1.1.1.4
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.4
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.4
	gdb_5_0-2000-04-10-branch:1.1.1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.4
	repo-unification-2000-02-06:1.1.1.4
	insight-2000-02-04:1.1.1.4
	gdb-2000-02-04:1.1.1.4
	gdb-2000-02-02:1.1.1.4
	gdb-2000-02-01:1.1.1.4
	gdb-2000-01-31:1.1.1.4
	gdb-2000-01-26:1.1.1.4
	gdb-2000-01-24:1.1.1.4
	gdb-2000-01-17:1.1.1.4
	gdb-2000-01-10:1.1.1.4
	gdb-2000-01-05:1.1.1.4
	gdb-1999-12-21:1.1.1.4
	gdb-1999-12-13:1.1.1.4
	gdb-1999-12-07:1.1.1.4
	gdb-1999-12-06:1.1.1.4
	gdb-1999-11-16:1.1.1.4
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.2
	gdb-1999-10-18:1.1.1.2
	gdb-1999-10-11:1.1.1.2
	gdb-1999-10-04:1.1.1.2
	gdb-1999-09-28:1.1.1.2
	gdb-1999-09-21:1.1.1.2
	gdb-1999-09-13:1.1.1.2
	gdb-1999-09-08:1.1.1.2
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.12
date	2003.06.20.14.08.16;	author drow;	state dead;
branches;
next	1.11;

1.11
date	2002.01.17.21.13.49;	author drow;	state Exp;
branches
	1.11.16.1
	1.11.18.1;
next	1.10;

1.10
date	2002.01.17.20.46.16;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.26.02.23.57;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.11.17.33.24;	author jtc;	state Exp;
branches;
next	1.7;

1.7
date	2001.04.06.22.25.09;	author jtc;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.23.31.14;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.06.08.21.44;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.23.19.45.12;	author jtc;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.08.19.46.07;	author jtc;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.30.01.48.28;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.34.26;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.17.44;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.11.02.04.44.24;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.11.17.02.30.36;	author jsm;	state Exp;
branches;
next	;

1.11.16.1
date	2003.06.27.21.50.18;	author carlton;	state dead;
branches;
next	;

1.11.18.1
date	2003.12.14.20.27.44;	author drow;	state dead;
branches;
next	;


desc
@@


1.12
log
@	* Makefile.in (SFILES): Update.
	* low-hppabsd.c, low-lynx.c, low-nbsd.c, low-sim.c, low-sparc.c,
	low-sun3.c: Remove files.
@
text
@/* Low level interface to ptrace, for the remote server for GDB.
   Copyright 1995, 1996, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include "server.h"
#include <sys/wait.h>
#include "frame.h"
#include "inferior.h"

#include <stdio.h>
#include <sys/param.h>
#include <sys/dir.h>
#include <sys/user.h>
#include <signal.h>
#include <sys/ioctl.h>
#include <sgtty.h>
#include <fcntl.h>

/***************Begin MY defs*********************/
static char my_registers[REGISTER_BYTES];
char *registers = my_registers;
/***************End MY defs*********************/

#include <sys/ptrace.h>
#include <machine/reg.h>

extern int errno;

/* Start an inferior process and returns its pid.
   ALLARGS is a vector of program-name and args. */

int
create_inferior (char *program, char **allargs)
{
  int pid;

  pid = fork ();
  if (pid < 0)
    perror_with_name ("fork");

  if (pid == 0)
    {
      ptrace (PT_TRACE_ME, 0, 0, 0, 0);

      execv (program, allargs);

      fprintf (stderr, "Cannot exec %s: %s.\n", program,
	       errno < sys_nerr ? sys_errlist[errno] : "unknown error");
      fflush (stderr);
      _exit (0177);
    }

  return pid;
}

/* Kill the inferior process.  Make us have no inferior.  */

void
kill_inferior (void)
{
  if (inferior_pid == 0)
    return;
  ptrace (8, inferior_pid, 0, 0, 0);
  wait (0);
/*************inferior_died ();****VK**************/
}

/* Attaching is not supported.  */
int
myattach (int pid)
{
  return -1;
}

/* Return nonzero if the given thread is still alive.  */
int
mythread_alive (int pid)
{
  return 1;
}

/* Wait for process, returns status */

unsigned char
mywait (char *status)
{
  int pid;
  union wait w;

  enable_async_io ();
  pid = waitpid (inferior_pid, &w, 0);
  disable_async_io ();
  if (pid != inferior_pid)
    perror_with_name ("wait");

  if (WIFEXITED (w))
    {
      fprintf (stderr, "\nChild exited with retcode = %x \n", WEXITSTATUS (w));
      *status = 'W';
      return ((unsigned char) WEXITSTATUS (w));
    }
  else if (!WIFSTOPPED (w))
    {
      fprintf (stderr, "\nChild terminated with signal = %x \n", WTERMSIG (w));
      *status = 'X';
      return ((unsigned char) WTERMSIG (w));
    }

  fetch_inferior_registers (0);

  *status = 'T';
  return ((unsigned char) WSTOPSIG (w));
}

/* Resume execution of the inferior process.
   If STEP is nonzero, single-step it.
   If SIGNAL is nonzero, give it that signal.  */

void
myresume (int step, int signal)
{
  errno = 0;
  ptrace (step ? PT_STEP : PT_CONTINUE, inferior_pid, 1, signal, 0);
  if (errno)
    perror_with_name ("ptrace");
}


#if !defined (offsetof)
#define offsetof(TYPE, MEMBER) ((unsigned long) &((TYPE *)0)->MEMBER)
#endif

/* U_REGS_OFFSET is the offset of the registers within the u area.  */
#if !defined (U_REGS_OFFSET)
#define U_REGS_OFFSET \
  ptrace (PT_READ_U, inferior_pid, \
          (PTRACE_ARG3_TYPE) (offsetof (struct user, u_ar0)), 0) \
    - KERNEL_U_ADDR
#endif

CORE_ADDR
register_addr (int regno, CORE_ADDR blockend)
{
  CORE_ADDR addr;

  if (regno < 0 || regno >= NUM_REGS)
    error ("Invalid register number %d.", regno);

  REGISTER_U_ADDR (addr, blockend, regno);

  return addr;
}

/* Fetch one register.  */

static void
fetch_register (int regno)
{
  register unsigned int regaddr;
  char buf[MAX_REGISTER_RAW_SIZE];
  register int i;

  /* Offset of registers within the u area.  */
  unsigned int offset;

  offset = U_REGS_OFFSET;

  regaddr = register_addr (regno, offset);
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
    {
      errno = 0;
      *(int *) &registers[regno * 4 + i] = ptrace (PT_RUREGS, inferior_pid,
					  (PTRACE_ARG3_TYPE) regaddr, 0, 0);
      regaddr += sizeof (int);
      if (errno != 0)
	{
	  /* Warning, not error, in case we are attached; sometimes the
	     kernel doesn't let us at the registers.  */
	  char *err = strerror (errno);
	  char *msg = alloca (strlen (err) + 128);
	  sprintf (msg, "reading register %d: %s", regno, err);
	  error (msg);
	  goto error_exit;
	}
    }
error_exit:;
}

/* Fetch all registers, or just one, from the child process.  */

void
fetch_inferior_registers (int regno)
{
  if (regno == -1 || regno == 0)
    for (regno = 0; regno < NUM_REGS; regno++)
      fetch_register (regno);
  else
    fetch_register (regno);
}

/* Store our register values back into the inferior.
   If REGNO is -1, do this for all registers.
   Otherwise, REGNO specifies which register (so we can save time).  */

void
store_inferior_registers (int regno)
{
  register unsigned int regaddr;
  char buf[80];
  extern char registers[];
  register int i;
  unsigned int offset = U_REGS_OFFSET;
  int scratch;

  if (regno >= 0)
    {
      if (CANNOT_STORE_REGISTER (regno))
	return;
      regaddr = register_addr (regno, offset);
      errno = 0;
      if (regno == PCOQ_HEAD_REGNUM || regno == PCOQ_TAIL_REGNUM)
	{
	  scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
	  ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		  scratch, 0);
	  if (errno != 0)
	    {
	      /* Error, even if attached.  Failing to write these two
	         registers is pretty serious.  */
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
      else
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
	  {
	    errno = 0;
	    ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		    *(int *) &registers[REGISTER_BYTE (regno) + i], 0);
	    if (errno != 0)
	      {
		/* Warning, not error, in case we are attached; sometimes the
		   kernel doesn't let us at the registers.  */
		char *err = strerror (errno);
		char *msg = alloca (strlen (err) + 128);
		sprintf (msg, "writing register %d: %s",
			 regno, err);
		error (msg);
		return;
	      }
	    regaddr += sizeof (int);
	  }
    }
  else
    for (regno = 0; regno < NUM_REGS; regno++)
      store_inferior_registers (regno);
}

/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory
   in the NEW_SUN_PTRACE case.
   It ought to be straightforward.  But it appears that writing did
   not write the data that I specified.  I cannot understand where
   it got the data that it actually did write.  */

/* Copy LEN bytes from inferior's memory starting at MEMADDR
   to debugger memory starting at MYADDR.  */

void
read_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (int);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
  /* Allocate buffer of that many longwords.  */
  register int *buffer = (int *) alloca (count * sizeof (int));

  /* Read all the longwords */
  for (i = 0; i < count; i++, addr += sizeof (int))
    {
      buffer[i] = ptrace (1, inferior_pid, addr, 0, 0);
    }

  /* Copy appropriate bytes out of the buffer.  */
  memcpy (myaddr, (char *) buffer + (memaddr & (sizeof (int) - 1)), len);
}

/* Copy LEN bytes of data from debugger memory at MYADDR
   to inferior's memory at MEMADDR.
   On failure (cannot write the inferior)
   returns the value of errno.  */

int
write_inferior_memory (CORE_ADDR memaddr, char *myaddr, int len)
{
  register int i;
  /* Round starting address down to longword boundary.  */
  register CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (int);
  /* Round ending address up; get number of longwords that makes.  */
  register int count
  = (((memaddr + len) - addr) + sizeof (int) - 1) / sizeof (int);
  /* Allocate buffer of that many longwords.  */
  register int *buffer = (int *) alloca (count * sizeof (int));
  extern int errno;

  /* Fill start and end extra bytes of buffer with existing memory data.  */

  buffer[0] = ptrace (1, inferior_pid, addr, 0, 0);

  if (count > 1)
    {
      buffer[count - 1]
	= ptrace (1, inferior_pid,
		  addr + (count - 1) * sizeof (int), 0, 0);
    }

  /* Copy data to be written over corresponding part of buffer */

  memcpy ((char *) buffer + (memaddr & (sizeof (int) - 1)), myaddr, len);

  /* Write the entire buffer.  */

  for (i = 0; i < count; i++, addr += sizeof (int))
    {
      errno = 0;
      ptrace (4, inferior_pid, addr, buffer[i], 0);
      if (errno)
	return errno;
    }

  return 0;
}

void
initialize_low (void)
{
}
@


1.11
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbserver/low-hppabsd.c, gdbserver/low-lynx.c,
        gdbserver/low-nbsd.c, gdbserver/low-sim.c,
        gdbserver/low-sparc.c, gdbserver/low-sun3.c,
        gdbserver/low-linux.c, gdbserver/server.c: Correct copyright notices.
@
text
@@


1.11.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.11.16.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@@


1.10
log
@2002-01-17  Daniel Jacobowitz  <drow@@mvista.com>

        * low-hppabsd.c (myattach): New function, returning -1.
        * low-lynx.c (myattach): Likewise.
        * low-nbsd.c (myattach): Likewise.
        * low-sim.c (myattach): Likewise.
        * low-sparc.c (myattach): Likewise.
        * low-sun3.c (myattach): Likewise.

        * low-linux.c (myattach): New function.

        * server.c (attach_inferior): New function.
        (main): Handle "--attach".
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.9
log
@        * infptrace.c (child_xfer_memory): Add cast to CORE_ADDR.
        * infttrace.c (child_xfer_memory): Likewise.
        * symm-nat.c (child_xfer_memory): Likewise.
        * gdbserver/low-hppabsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-linux.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-lynx.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-nbsd.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sparc.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
        * gdbserver/low-sun3.c (read_inferior_memory): Likewise.
        (write_inferior_memory): Likewise.
@
text
@d84 7
@


1.8
log
@* gdbserver/remote-utils.c (remote_open): Set gdbserver as "owner"
of SIGIO.
(input_interrupt): Don't block on read, in case we got redundant
SIGIO.  Don't gripe about redundant SIGIO.
* gdbserver/low-hppabsd.c (mywait): Use waitpid().  Enable SIGIO
handler while waiting.
* gdbserver/low-linux.c (mywait): Likewise.
* gdbserver/low-nbsd.c (mywait): Likewise.
* gdbserver/low-sparc.c (mywait): Likewise.
@
text
@d282 1
a282 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
d309 1
a309 1
  register CORE_ADDR addr = memaddr & -sizeof (int);
@


1.7
log
@* gdbserver/low-hppabsd.c (read_inferior_memory): Add explicit
  void return value;
* gdbserver/low-nbsd.c: Likewise.
* gdbserver/low-sparc.c: Likewise.
* gdbserver/low-sun3.c: Likewise.
---------------------------------------------------------------------
@
text
@d99 3
a101 1
  pid = wait (&w);
@


1.6
log
@Eliminate ARCH_NUM_REGS.
@
text
@d275 1
@


1.5
log
@Update/correct copyright notices.
@
text
@d153 1
a153 1
  if (regno < 0 || regno >= ARCH_NUM_REGS)
@


1.4
log
@* config/m32r/m32r.mt (GDBSERVER_LIBS): Added ../../intl/libintl.a.
* config/mips/vr5000.mt (GDBSERVER_LIBS): Likewise.
* config/tic80/tic80.mt (GDBSERVER_LIBS): Likewise.
* gdbserver/low-sim.c (#include "defs.h"): Removed.
(mygeneric_load): Rename from generic_load.

* gdbserver/low-hppabsd.c (#include "server.h"): Added.
(#include "defs.h"): Removed.
(inferior_pid, perror_with_name): Remove declarations.
* gdbserver/low-linux.c: Likewise.
* gdbserver/low-nbsd.c: Likewise.
* gdbserver/low-sparc.c: Likewise.
* gdbserver/low-sun3.c: Likewise.

* i386-stub.c: Re-indent.
* m68k-stub.c: Re-indent.
@
text
@d2 1
a2 1
   Copyright (C) 1995 Free Software Foundation, Inc.
@


1.3
log
@* gdbserver/low-hppabsd.c (buf2, environ, quit, quit_flag):
Removed unused variables and declarations.
* gdbserver/low-linux.c (buf2, environ, query, quit, quit_flag):
Likewise.
* gdbserver/low-nbsd.c (buf2, environ, quit, quit_flag):
Likewise.
* gdbserver/low-sparc.c (buf2, environ, query, quit, quit_flag):
Likewise.
* gdbserver/low-sun.c (buf2, environ, query, quit, quit_flag):
Likewise.

* gdbserver/low-hppabsd.c, gdbserver/low-linux.c,
gdbserver/low-nbsd.c, gdbserver/low-sparc.c, gdbserver/low-sun3.c
(create_inferior): Update comment.

* gdbserver/low-nbsd.c (initialize_arch, fetch_inferior_registers,
store_inferior_registers): Provide implementations for the m68k
and ns32k.
* config/m68k/nbsd.mt (GDBSERVER_DEPFILES): Add low-nbsd.o
* config/ns32k/nbsd.mt (GDBSERVER_DEPFILES): Likewise.
* configure.tgt (m68*-*-netbsd*, ns32k-*-netbsd*): Add gdbserver
to configdirs.
-------------------------------------------------------------------
@
text
@d21 1
a21 1
#include "defs.h"
a43 2
extern int inferior_pid;
void perror_with_name ();
@


1.2
log
@Protoization.
@
text
@a35 1
int quit_flag = 0;
a37 6

/* Index within `registers' of the first byte of the space for
   register N.  */


char buf2[MAX_REGISTER_RAW_SIZE];
a42 1
extern char **environ;
d45 1
a45 2
void quit (), perror_with_name ();
int query ();
d48 1
a48 2
   ALLARGS is a vector of program-name and args.
   ENV is the environment vector to pass.  */
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 2
a38 1
char registers[REGISTER_BYTES];
d61 1
a61 3
create_inferior (program, allargs)
     char *program;
     char **allargs;
d87 1
a87 1
kill_inferior ()
d93 1
a93 1
  /*************inferior_died ();****VK**************/
d98 1
a98 2
mythread_alive (pid)
     int pid;
d106 1
a106 2
mywait (status)
     char *status;
d139 1
a139 3
myresume (step, signal)
     int step;
     int signal;
d161 1
a161 3
register_addr (regno, blockend)
     int regno;
     CORE_ADDR blockend;
d176 1
a176 2
fetch_register (regno)
     int regno;
d191 2
a192 2
      *(int *) &registers[ regno * 4 + i] = ptrace (PT_RUREGS, inferior_pid,
				 (PTRACE_ARG3_TYPE) regaddr, 0, 0);
d205 1
a205 1
 error_exit:;
d211 1
a211 2
fetch_inferior_registers (regno)
     int regno;
d225 1
a225 2
store_inferior_registers (regno)
     int regno;
d241 6
a246 6
        {
          scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
          ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
                  scratch, 0);
          if (errno != 0)
            {
d248 5
a252 5
		 registers is pretty serious.  */
              sprintf (buf, "writing register number %d", regno);
              perror_with_name (buf);
            }
        }
d254 1
a254 1
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof(int))
d270 1
a270 1
	    regaddr += sizeof(int);
d287 1
a287 4
read_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d314 1
a314 4
write_inferior_memory (memaddr, myaddr, len)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
d355 1
a355 7
initialize ()
{
  inferior_pid = 0;
}

int
have_inferior_p ()
a356 1
  return inferior_pid != 0;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d93 1
a93 1
/*************inferior_died ();****VK**************/
d198 2
a199 2
      *(int *) &registers[regno * 4 + i] = ptrace (PT_RUREGS, inferior_pid,
					  (PTRACE_ARG3_TYPE) regaddr, 0, 0);
d212 1
a212 1
error_exit:;
d250 6
a255 6
	{
	  scratch = *(int *) &registers[REGISTER_BYTE (regno)] | 0x3;
	  ptrace (PT_WUREGS, inferior_pid, (PTRACE_ARG3_TYPE) regaddr,
		  scratch, 0);
	  if (errno != 0)
	    {
d257 5
a261 5
	         registers is pretty serious.  */
	      sprintf (buf, "writing register number %d", regno);
	      perror_with_name (buf);
	    }
	}
d263 1
a263 1
	for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (int))
d279 1
a279 1
	    regaddr += sizeof (int);
@


1.1.1.3
log
@import gdb-1999-11-01 snapshot
@
text
@d37 1
a37 2
static char my_registers[REGISTER_BYTES];
char *registers = my_registers;
@


1.1.1.4
log
@import gdb-1999-11-16 snapshot
@
text
@d372 1
a372 1
initialize_low ()
d374 7
@


