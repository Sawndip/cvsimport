head	1.34;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.34
	gdb_7_6-2013-04-26-release:1.34
	gdb_7_6-branch:1.34.0.2
	gdb_7_6-2013-03-12-branchpoint:1.34
	gdb_7_5_1-2012-11-29-release:1.32.2.1
	gdb_7_5-2012-08-17-release:1.32.2.1
	gdb_7_5-branch:1.32.0.2
	gdb_7_5-2012-07-18-branchpoint:1.32
	gdb_7_4_1-2012-04-26-release:1.31.4.1
	gdb_7_4-2012-01-24-release:1.31.4.1
	gdb_7_4-branch:1.31.0.4
	gdb_7_4-2011-12-13-branchpoint:1.31
	gdb_7_3_1-2011-09-04-release:1.31
	gdb_7_3-2011-07-26-release:1.31
	gdb_7_3-branch:1.31.0.2
	gdb_7_3-2011-04-01-branchpoint:1.31
	gdb_7_2-2010-09-02-release:1.25
	gdb_7_2-branch:1.25.0.4
	gdb_7_2-2010-07-07-branchpoint:1.25
	gdb_7_1-2010-03-18-release:1.25
	gdb_7_1-branch:1.25.0.2
	gdb_7_1-2010-02-18-branchpoint:1.25
	gdb_7_0_1-2009-12-22-release:1.24
	gdb_7_0-2009-10-06-release:1.24
	gdb_7_0-branch:1.24.0.4
	gdb_7_0-2009-09-16-branchpoint:1.24
	arc-sim-20090309:1.19
	msnyder-checkpoint-072509-branch:1.24.0.2
	msnyder-checkpoint-072509-branchpoint:1.24
	arc-insight_6_8-branch:1.19.0.6
	arc-insight_6_8-branchpoint:1.19
	insight_6_8-branch:1.19.0.4
	insight_6_8-branchpoint:1.19
	reverse-20081226-branch:1.22.0.10
	reverse-20081226-branchpoint:1.22
	multiprocess-20081120-branch:1.22.0.8
	multiprocess-20081120-branchpoint:1.22
	reverse-20080930-branch:1.22.0.6
	reverse-20080930-branchpoint:1.22
	reverse-20080717-branch:1.22.0.4
	reverse-20080717-branchpoint:1.22
	msnyder-reverse-20080609-branch:1.22.0.2
	msnyder-reverse-20080609-branchpoint:1.22
	drow-reverse-20070409-branch:1.16.0.2
	drow-reverse-20070409-branchpoint:1.16
	gdb_6_8-2008-03-27-release:1.19
	gdb_6_8-branch:1.19.0.2
	gdb_6_8-2008-02-26-branchpoint:1.19
	gdb_6_7_1-2007-10-29-release:1.18
	gdb_6_7-2007-10-10-release:1.18
	gdb_6_7-branch:1.18.0.2
	gdb_6_7-2007-09-07-branchpoint:1.18
	insight_6_6-20070208-release:1.15
	gdb_6_6-2006-12-18-release:1.15
	gdb_6_6-branch:1.15.0.2
	gdb_6_6-2006-11-15-branchpoint:1.15
	insight_6_5-20061003-release:1.14
	gdb-csl-symbian-6_4_50_20060226-12:1.14
	gdb-csl-sourcerygxx-3_4_4-25:1.13
	nickrob-async-20060828-mergepoint:1.15
	gdb-csl-symbian-6_4_50_20060226-11:1.14
	gdb-csl-sourcerygxx-4_1-17:1.14
	gdb-csl-20060226-branch-local-2:1.14
	gdb-csl-sourcerygxx-4_1-14:1.14
	gdb-csl-sourcerygxx-4_1-13:1.14
	gdb-csl-sourcerygxx-4_1-12:1.14
	gdb-csl-sourcerygxx-3_4_4-21:1.14
	gdb_6_5-20060621-release:1.14
	gdb-csl-sourcerygxx-4_1-9:1.14
	gdb-csl-sourcerygxx-4_1-8:1.14
	gdb-csl-sourcerygxx-4_1-7:1.14
	gdb-csl-arm-2006q1-6:1.14
	gdb-csl-sourcerygxx-4_1-6:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.14
	gdb-csl-symbian-6_4_50_20060226-9:1.14
	gdb-csl-symbian-6_4_50_20060226-8:1.14
	gdb-csl-coldfire-4_1-11:1.14
	gdb-csl-sourcerygxx-3_4_4-19:1.14
	gdb-csl-coldfire-4_1-10:1.14
	gdb_6_5-branch:1.14.0.16
	gdb_6_5-2006-05-14-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-5:1.14
	nickrob-async-20060513-branch:1.14.0.14
	nickrob-async-20060513-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-4:1.14
	msnyder-reverse-20060502-branch:1.14.0.12
	msnyder-reverse-20060502-branchpoint:1.14
	gdb-csl-morpho-4_1-4:1.14
	gdb-csl-sourcerygxx-3_4_4-17:1.14
	readline_5_1-import-branch:1.14.0.10
	readline_5_1-import-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.14
	gdb-csl-symbian-20060226-branch:1.14.0.8
	gdb-csl-symbian-20060226-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.14
	msnyder-reverse-20060331-branch:1.14.0.6
	msnyder-reverse-20060331-branchpoint:1.14
	gdb-csl-available-20060303-branch:1.14.0.4
	gdb-csl-available-20060303-branchpoint:1.14
	gdb-csl-20060226-branch:1.14.0.2
	gdb-csl-20060226-branchpoint:1.14
	gdb_6_4-20051202-release:1.13
	msnyder-fork-checkpoint-branch:1.13.0.10
	msnyder-fork-checkpoint-branchpoint:1.13
	gdb-csl-gxxpro-6_3-branch:1.13.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.13
	gdb_6_4-branch:1.13.0.6
	gdb_6_4-2005-11-01-branchpoint:1.13
	gdb-csl-arm-20051020-branch:1.13.0.4
	gdb-csl-arm-20051020-branchpoint:1.13
	msnyder-tracepoint-checkpoint-branch:1.13.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.13
	gdb-csl-arm-20050325-2005-q1b:1.12
	gdb-csl-arm-20050325-2005-q1a:1.12
	csl-arm-20050325-branch:1.12.0.2
	csl-arm-20050325-branchpoint:1.12
	gdb-post-i18n-errorwarning-20050211:1.12
	gdb-pre-i18n-errorwarning-20050211:1.12
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.4
	gdb_6_3-20041019-branchpoint:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.11.0.6
	jimb-gdb_6_2-e500-branchpoint:1.11
	gdb_6_2-20040730-release:1.11
	gdb_6_2-branch:1.11.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.11
	gdb_6_1_1-20040616-release:1.9
	gdb_6_1-2004-04-05-release:1.9
	drow_intercu-merge-20040402:1.10
	drow_intercu-merge-20040327:1.10
	ezannoni_pie-20040323-branch:1.10.0.2
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.9.0.18
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow_intercu-20040221-branch:1.9.0.14
	drow_intercu-20040221-branchpoint:1.9
	cagney_bfdfile-20040213-branch:1.9.0.12
	cagney_bfdfile-20040213-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	cagney_bigcore-20040122-branch:1.9.0.10
	cagney_bigcore-20040122-branchpoint:1.9
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-branch:1.9.0.8
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.7.18.1
	kettenis_sparc-20030918-branch:1.9.0.6
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.4
	cagney_x86i386-20030821-branch:1.9.0.2
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.18
	gdb_6_0-2003-06-23-branchpoint:1.7
	jimb-ppc64-linux-20030613-branch:1.7.0.16
	jimb-ppc64-linux-20030613-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.14
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.12
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.7.0.10
	jimb-ppc64-linux-20030528-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.8
	cagney_fileio-20030521-branchpoint:1.7
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.6
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.7.0.4
	kettenis_i386newframe-20030419-branchpoint:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	kettenis_i386newframe-20030406-branch:1.7.0.2
	kettenis_i386newframe-20030406-branchpoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.6
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.4
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.2
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.2
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.3.0.8
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.6
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-branch:1.3.0.4
	carlton_dictionary-20030207-merge:1.3
	interps-20030203-mergepoint:1.3
	interps-20030202-branch:1.3.0.2
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.34
date	2013.01.01.06.32.42;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2012.08.06.19.20.43;	author tromey;	state Exp;
branches;
next	1.32;

1.32
date	2012.01.04.08.17.02;	author brobecke;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2011.03.18.18.52.30;	author palves;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2011.02.27.16.25.37;	author msnyder;	state Exp;
branches;
next	1.29;

1.29
date	2011.02.22.17.51.24;	author palves;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2011.01.01.15.33.04;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2010.08.11.13.22.57;	author jkratoch;	state Exp;
branches;
next	1.25;

1.25
date	2010.01.01.07.31.31;	author brobecke;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.02.17.09.28;	author uweigand;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2008.05.06.18.37.46;	author brobecke;	state Exp;
branches;
next	1.21;

1.21
date	2008.05.03.23.24.17;	author bauermann;	state Exp;
branches;
next	1.20;

1.20
date	2008.04.30.21.16.45;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.23.18.08.31;	author brobecke;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.12.15.21.26;	author schwab;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.31.17.33.30;	author fnf;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches
	1.14.14.1;
next	1.13;

1.13
date	2005.05.22.14.53.33;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.09.01.16.42;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.08.20.03.52;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.21.22.28.52;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2003.07.16.22.29.13;	author cagney;	state Exp;
branches
	1.9.8.1
	1.9.14.1
	1.9.18.1;
next	1.8;

1.8
date	2003.07.15.17.35.00;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.05.03.55.59;	author cagney;	state Exp;
branches
	1.7.18.1;
next	1.6;

1.6
date	2003.03.17.14.23.49;	author cagney;	state Exp;
branches
	1.6.6.1;
next	1.5;

1.5
date	2003.03.12.15.39.30;	author cagney;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.03.10.15.28.40;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.19.17.39.16;	author cagney;	state Exp;
branches
	1.3.4.1
	1.3.6.1
	1.3.8.1;
next	1.2;

1.2
date	2003.01.18.17.25.23;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.13.17.03.53;	author cagney;	state dead;
branches
	1.1.2.1;
next	;

1.32.2.1
date	2012.08.06.19.21.51;	author tromey;	state Exp;
branches;
next	;

1.31.4.1
date	2012.01.06.04.43.12;	author brobecke;	state Exp;
branches;
next	;

1.14.14.1
date	2006.08.28.07.48.49;	author nickrob;	state Exp;
branches;
next	;

1.9.8.1
date	2003.12.14.20.27.14;	author drow;	state Exp;
branches;
next	;

1.9.14.1
date	2004.03.27.17.37.46;	author drow;	state Exp;
branches;
next	1.9.14.2;

1.9.14.2
date	2004.09.16.17.01.03;	author drow;	state Exp;
branches;
next	;

1.9.18.1
date	2004.03.09.22.58.58;	author cagney;	state Exp;
branches;
next	1.9.18.2;

1.9.18.2
date	2004.03.16.16.05.54;	author cagney;	state Exp;
branches;
next	1.9.18.3;

1.9.18.3
date	2004.03.21.23.57.34;	author cagney;	state Exp;
branches;
next	;

1.7.18.1
date	2003.07.15.17.45.29;	author cagney;	state Exp;
branches;
next	;

1.6.6.1
date	2003.04.10.21.33.48;	author cagney;	state Exp;
branches;
next	;

1.5.2.1
date	2003.03.13.17.33.52;	author cagney;	state Exp;
branches;
next	;

1.3.4.1
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.08.05.17.13.06;	author carlton;	state Exp;
branches;
next	;

1.3.6.1
date	2003.03.04.23.15.23;	author cagney;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2003.03.06.19.21.30;	author cagney;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2003.03.07.14.24.29;	author cagney;	state Exp;
branches;
next	1.3.6.4;

1.3.6.4
date	2003.03.11.23.00.25;	author cagney;	state Exp;
branches;
next	;

1.3.8.1
date	2003.03.16.14.01.48;	author kettenis;	state Exp;
branches;
next	;

1.1.2.1
date	2003.01.13.17.03.53;	author cagney;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.01.20.00.38.14;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Definitions for a frame unwinder, for GDB, the GNU debugger.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#if !defined (FRAME_UNWIND_H)
#define FRAME_UNWIND_H 1

struct frame_data;
struct frame_info;
struct frame_id;
struct frame_unwind;
struct gdbarch;
struct regcache;
struct value;

#include "frame.h"		/* For enum frame_type.  */

/* The following unwind functions assume a chain of frames forming the
   sequence: (outer) prev <-> this <-> next (inner).  All the
   functions are called with this frame's `struct frame_info' and
   prologue cache.

   THIS frame's register values can be obtained by unwinding NEXT
   frame's registers (a recursive operation).

   THIS frame's prologue cache can be used to cache information such
   as where this frame's prologue stores the previous frame's
   registers.  */

/* Given THIS frame, take a whiff of its registers (namely
   the PC and attributes) and if SELF is the applicable unwinder,
   return non-zero.  Possibly also initialize THIS_PROLOGUE_CACHE; but
   only if returning 1.  Initializing THIS_PROLOGUE_CACHE in other
   cases (0 return, or exception) is invalid.  */

typedef int (frame_sniffer_ftype) (const struct frame_unwind *self,
				   struct frame_info *this_frame,
				   void **this_prologue_cache);

typedef enum unwind_stop_reason (frame_unwind_stop_reason_ftype)
  (struct frame_info *this_frame, void **this_prologue_cache);

/* A default frame sniffer which always accepts the frame.  Used by
   fallback prologue unwinders.  */

int default_frame_sniffer (const struct frame_unwind *self,
			   struct frame_info *this_frame,
			   void **this_prologue_cache);

/* A default stop_reason callback which always claims the frame is
   unwindable.  */

enum unwind_stop_reason
  default_frame_unwind_stop_reason (struct frame_info *this_frame,
				    void **this_cache);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use THIS frame, and through it the NEXT frame's register unwind
   method, to determine the frame ID of THIS frame.

   A frame ID provides an invariant that can be used to re-identify an
   instance of a frame.  It is a combination of the frame's `base' and
   the frame's function's code address.

   Traditionally, THIS frame's ID was determined by examining THIS
   frame's function's prologue, and identifying the register/offset
   used as THIS frame's base.

   Example: An examination of THIS frame's prologue reveals that, on
   entry, it saves the PC(+12), SP(+8), and R1(+4) registers
   (decrementing the SP by 12).  Consequently, the frame ID's base can
   be determined by adding 12 to the THIS frame's stack-pointer, and
   the value of THIS frame's SP can be obtained by unwinding the NEXT
   frame's SP.

   THIS_PROLOGUE_CACHE can be used to share any prolog analysis data
   with the other unwind methods.  Memory for that cache should be
   allocated using FRAME_OBSTACK_ZALLOC().  */

typedef void (frame_this_id_ftype) (struct frame_info *this_frame,
				    void **this_prologue_cache,
				    struct frame_id *this_id);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use THIS frame, and implicitly the NEXT frame's register unwind
   method, to unwind THIS frame's registers (returning the value of
   the specified register REGNUM in the previous frame).

   Traditionally, THIS frame's registers were unwound by examining
   THIS frame's function's prologue and identifying which registers
   that prolog code saved on the stack.

   Example: An examination of THIS frame's prologue reveals that, on
   entry, it saves the PC(+12), SP(+8), and R1(+4) registers
   (decrementing the SP by 12).  Consequently, the value of the PC
   register in the previous frame is found in memory at SP+12, and
   THIS frame's SP can be obtained by unwinding the NEXT frame's SP.

   This function takes THIS_FRAME as an argument.  It can find the
   values of registers in THIS frame by calling get_frame_register
   (THIS_FRAME), and reinvoke itself to find other registers in the
   PREVIOUS frame by calling frame_unwind_register (THIS_FRAME).

   The result is a GDB value object describing the register value.  It
   may be a lazy reference to memory, a lazy reference to the value of
   a register in THIS frame, or a non-lvalue.

   THIS_PROLOGUE_CACHE can be used to share any prolog analysis data
   with the other unwind methods.  Memory for that cache should be
   allocated using FRAME_OBSTACK_ZALLOC().  */

typedef struct value * (frame_prev_register_ftype)
  (struct frame_info *this_frame, void **this_prologue_cache,
   int regnum);

/* Deallocate extra memory associated with the frame cache if any.  */

typedef void (frame_dealloc_cache_ftype) (struct frame_info *self,
					  void *this_cache);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use THIS frame, and implicitly the NEXT frame's register unwind
   method, return PREV frame's architecture.  */

typedef struct gdbarch *(frame_prev_arch_ftype) (struct frame_info *this_frame,
						 void **this_prologue_cache);

struct frame_unwind
{
  /* The frame's type.  Should this instead be a collection of
     predicates that test the frame for various attributes?  */
  enum frame_type type;
  /* Should an attribute indicating the frame's address-in-block go
     here?  */
  frame_unwind_stop_reason_ftype *stop_reason;
  frame_this_id_ftype *this_id;
  frame_prev_register_ftype *prev_register;
  const struct frame_data *unwind_data;
  frame_sniffer_ftype *sniffer;
  frame_dealloc_cache_ftype *dealloc_cache;
  frame_prev_arch_ftype *prev_arch;
};

/* Register a frame unwinder, _prepending_ it to the front of the
   search list (so it is sniffed before previously registered
   unwinders).  By using a prepend, later calls can install unwinders
   that override earlier calls.  This allows, for instance, an OSABI
   to install a more specific sigtramp unwinder that overrides the
   traditional brute-force unwinder.  */
extern void frame_unwind_prepend_unwinder (struct gdbarch *,
					   const struct frame_unwind *);

/* Add a frame sniffer to the list.  The predicates are polled in the
   order that they are appended.  The initial list contains the dummy
   frame sniffer.  */

extern void frame_unwind_append_unwinder (struct gdbarch *gdbarch,
					  const struct frame_unwind *unwinder);

/* Iterate through sniffers for THIS_FRAME frame until one returns with an
   unwinder implementation.  THIS_FRAME->UNWIND must be NULL, it will get set
   by this function.  Possibly initialize THIS_CACHE.  */

extern void frame_unwind_find_by_frame (struct frame_info *this_frame,
					void **this_cache);

/* Helper functions for value-based register unwinding.  These return
   a (possibly lazy) value of the appropriate type.  */

/* Return a value which indicates that FRAME did not save REGNUM.  */

struct value *frame_unwind_got_optimized (struct frame_info *frame,
					  int regnum);

/* Return a value which indicates that FRAME copied REGNUM into
   register NEW_REGNUM.  */

struct value *frame_unwind_got_register (struct frame_info *frame, int regnum,
					 int new_regnum);

/* Return a value which indicates that FRAME saved REGNUM in memory at
   ADDR.  */

struct value *frame_unwind_got_memory (struct frame_info *frame, int regnum,
				       CORE_ADDR addr);

/* Return a value which indicates that FRAME's saved version of
   REGNUM has a known constant (computed) value of VAL.  */

struct value *frame_unwind_got_constant (struct frame_info *frame, int regnum,
					 ULONGEST val);

/* Return a value which indicates that FRAME's saved version of
   REGNUM has a known constant (computed) value which is stored
   inside BUF.  */

struct value *frame_unwind_got_bytes (struct frame_info *frame, int regnum,
                                      gdb_byte *buf);

/* Return a value which indicates that FRAME's saved version of REGNUM
   has a known constant (computed) value of ADDR.  Convert the
   CORE_ADDR to a target address if necessary.  */

struct value *frame_unwind_got_address (struct frame_info *frame, int regnum,
					CORE_ADDR addr);

#endif
@


1.33
log
@	* dwarf2-frame.c (clear_pointer_cleanup): New function.
	(dwarf2_frame_cache): Use it.
	* frame-unwind.h (frame_sniffer_ftype): Document prologue
	cache initialization constraint.
@
text
@d3 1
a3 1
   Copyright (C) 2003-2004, 2007-2012 Free Software Foundation, Inc.
@


1.32
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d47 3
a49 1
   return non-zero.  Possibly also initialize THIS_PROLOGUE_CACHE.  */
@


1.32.2.1
log
@	* dwarf2-frame.c (clear_pointer_cleanup): New function.
	(dwarf2_frame_cache): Use it.
	* frame-unwind.h (frame_sniffer_ftype): Document prologue
	cache initialization constraint.
@
text
@d47 1
a47 3
   return non-zero.  Possibly also initialize THIS_PROLOGUE_CACHE; but
   only if returning 1.  Initializing THIS_PROLOGUE_CACHE in other
   cases (0 return, or exception) is invalid.  */
@


1.31
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.31.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003-2004, 2007-2012 Free Software Foundation, Inc.
@


1.30
log
@2011-02-27  Michael Snyder  <msnyder@@vmware.com>

	* darwin-nat-info.c: Fix comment typo.
	* dwarf2expr.h: Ditto.
	* fbsd-nat.c: Ditto.
	* fbsd-nat.h: Ditto.
	* frame-unwind.h: Ditto.
	* frame.h: Ditto.
	* hppa-hpux-tdep.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* linux-nat.c: Ditto.
	* nbsd-nat.c: Ditto.
	* nbsd-nat.h: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* serial.c: Ditto.
	* ui-file.h: Ditto.
	* tui/tui-winsource.c: Ditto.
@
text
@d54 3
d64 7
d149 1
@


1.29
log
@	gdb/
	* frame-unwind.h: Fix comment to mention the this frame, not the
	next.
@
text
@d151 1
a151 1
   to install a a more specific sigtramp unwinder that overrides the
@


1.28
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d36 2
a37 2
   functions are called with the next frame's `struct frame_info'
   and this frame's prologue cache.
@


1.27
log
@run copyright.sh for 2011.
@
text
@d153 2
a154 2
extern void frame_unwind_prepend_unwinder (struct gdbarch *gdbarch,
					   const struct frame_unwind *unwinder);
@


1.26
log
@gdb/
	Code cleanup.
	* frame-unwind.c (frame_unwind_find_by_frame): Remove the return type
	and returned value.  New comment from frame-unwind.h.
	* frame-unwind.h (frame_unwind_find_by_frame): Remove the return type.
	Extend the comment.
	* frame.c (get_frame_id, frame_unwind_register_value)
	(create_new_frame, get_prev_frame_1, frame_unwinder_is)
	(get_frame_type, frame_unwind_arch): Do not use the return value of
	frame_unwind_find_by_frame.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2007, 2008, 2009, 2010
@


1.25
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d163 3
a165 2
/* Iterate through sniffers for THIS frame until one returns with an
   unwinder implementation.  Possibly initialize THIS_CACHE.  */
d167 2
a168 2
extern const struct frame_unwind *frame_unwind_find_by_frame (struct frame_info *this_frame,
							      void **this_cache);
@


1.24
log
@	* frame.h (frame_unwind_arch): New.
	(frame_unwind_caller_arch): Likewise.
	* frame-unwind.h (frame_prev_arch_ftype): New type.
	(struct frame_unwind): New member prev_arch.
	* frame.c (struct frame_info): New member prev_arch.
	(frame_unwind_arch): New function.
	(frame_unwind_caller_arch): Likewise..
	(get_frame_arch): Reimplement in terms of frame_unwind_arch.
	* sentinel-frame.c (sentinel_frame_prev_arch): New function.
	(sentinel_frame_unwinder): Install it.

	* frame.c (frame_pc_unwind): Use frame_unwind_arch instead
	of get_frame_arch.
	(frame_unwind_register_value): Likewise.
	(frame_unwind_register_signed): Likewise.
	(frame_unwind_register_unsigned): Likewise.
	* frame-unwind.c (frame_unwind_got_optimized): Likewise.
	(frame_unwind_got_register): Likewise.
	(frame_unwind_got_constant): Likewise.
	(frame_unwind_got_bytes): Likewise.
	(frame_unwind_got_address): Likewise.

	* frame.h (enum frame_type): New value ARCH_FRAME.
	* frame.c (fprint_frame_type): Handle ARCH_FRAME.
	* stack.c (print_frame_info): Likewise.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2004, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.23
log
@        Updated copyright notices for most files.
@
text
@d124 7
d143 1
@


1.22
log
@        * frame-unwind.c (frame_unwind_got_bytes): New function.
        * frame-unwind.h (frame_unwind_got_bytes): Add declaration.
        * libunwind-frame.h, libunwind-frame.c, ia64-tdep.c: Update
        for unwinder changes.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.21
log
@2008-05-03  Luis Machado  <luisgpm@@br.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* cli/cli-decode.c (lookup_cmd_1): Fix indentation.
	* doublest.c (convert_typed_floating): Fix typo in comment.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame-unwind.h (frame_sniffer_ftype): Likewise.
	* frame.c (frame_unwind_address_in_block): Likewise.
	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): Likewise.
	* symtab.h (struct symbol): Likewise.
	* tramp-frame.h (struct trad_frame_cache): Likewise.
	* value.c (allocate_repeat_value): Likewise.
@
text
@d186 7
@


1.20
log
@	Convert frame unwinders to use the current frame and
	"struct value".

	* frame.c (frame_debug): Make global.
	(get_frame_id): Pass this frame to unwinder routines.
	(frame_pc_unwind): Remove unused unwind->prev_pc support.
	(do_frame_register_read): Do not discard the return value of
	frame_register_read.
	(frame_register_unwind): Remove debug messages.  Use
	frame_unwind_register_value.
	(frame_unwind_register_value, get_frame_register_value): New
	functions.
	(create_new_frame, get_frame_base_address, get_frame_locals_address)
	(get_frame_args_address, get_frame_type): Pass this frame to
	unwinder routines.
	(frame_cleanup_after_sniffer, frame_prepare_for_sniffer): New
	functions.
	* frame.h: Update comments.
	(frame_debug, frame_unwind_register_value, get_frame_register_value)
	(frame_prepare_for_sniffer): Declare.
	* frame-unwind.h: Update comments and parameter names.
	(default_frame_sniffer): Declare.
	(frame_prev_register_ftype): Return a struct value *.
	(struct frame_unwind): Remove prev_pc member.
	(frame_unwind_sniffer_ftype, frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): Declare.
	* frame-base.h: Update comments and parameter names.
	* valops.c (value_fetch_lazy): Use get_frame_register_value.  Iterate
	if necessary.  Add debugging output.
	* sentinel-frame.c (sentinel_frame_prev_register)
	(sentinel_frame_this_id): Update for new signature.
	(sentinel_frame_prev_pc): Delete.
	(sentinel_frame_unwinder): Remove prev_pc.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Do not initialize
	prev_pc.
	* libunwind-frame.c (libunwind_frame_unwind): Likewise.
	* frame-unwind.c (struct frame_unwind_table_entry): Remove sniffer.
	(frame_unwind_append_sniffer): Delete.
	(frame_unwind_append_unwinder): New function.
	(frame_unwind_find_by_frame): Take this frame.  Only use sniffers
	from unwinders.  Use frame_prepare_for_sniffer.
	(default_frame_sniffer, frame_unwind_got_optimized)
	(frame_unwind_got_register, frame_unwind_got_memory)
	(frame_unwind_got_constant, frame_unwind_got_address): New functions.
	* dummy-frame.c (dummy_frame_sniffer): Use gdbarch_dummy_id.
	(dummy_frame_prev_register, dummy_frame_this_id): Update for new
	signature.
	* gdbarch.sh: Replace unwind_dummy_id with dummy_id.
	* gdbarch.c, gdbarch.c: Regenerated.
	* frame-base.c (default_frame_base_address)
	(default_frame_locals_address, default_frame_args_address): Update
	for new signature.
	(frame_base_find_by_frame): Pass this frame to unwinder routines.
	* infcall.c (call_function_by_hand): Update comments.
	* Makefile.in (frame-unwind.o): Update dependencies.

	* gdbint.texinfo (Stack Frames): New chapter.
	(Algorithms): Move Frames text to the new chapter.
	(Target Conditionals): Delete SAVE_DUMMY_FRAME_TOS.  Document
	gdbarch_dummy_id instead of gdbarch_unwind_dummy_id.
@
text
@d35 2
a36 2
   functions are called with called with the next frame's `struct
   frame_info' and and this frame's prologue cache.
@


1.19
log
@	Updated copyright notices for most files.
@
text
@d29 1
d45 1
a45 1
/* Given the NEXT frame, take a wiff of THIS frame's registers (namely
d50 1
a50 1
				   struct frame_info *next_frame,
d53 7
d61 2
a62 2
   use the NEXT frame, and its register unwind method, to determine
   the frame ID of THIS frame.
d83 1
a83 1
typedef void (frame_this_id_ftype) (struct frame_info *next_frame,
d88 3
a90 3
   use the NEXT frame, and its register unwind method, to unwind THIS
   frame's registers (returning the value of the specified register
   REGNUM in the previous frame).
d102 8
a109 12
   Why not pass in THIS_FRAME?  By passing in NEXT frame and THIS
   cache, the supplied parameters are consistent with the sibling
   function THIS_ID.

   Can the code call ``frame_register (get_prev_frame (NEXT_FRAME))''?
   Won't the call frame_register (THIS_FRAME) be faster?  Well,
   ignoring the possability that the previous frame does not yet
   exist, the ``frame_register (FRAME)'' function is expanded to
   ``frame_register_unwind (get_next_frame (FRAME)'' and hence that
   call will expand to ``frame_register_unwind (get_next_frame
   (get_prev_frame (NEXT_FRAME)))''.  Might as well call
   ``frame_register_unwind (NEXT_FRAME)'' directly.
d115 3
a117 14
typedef void (frame_prev_register_ftype) (struct frame_info *next_frame,
					  void **this_prologue_cache,
					  int prev_regnum,
					  int *optimized,
					  enum lval_type * lvalp,
					  CORE_ADDR *addrp,
					  int *realnump, gdb_byte *valuep);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to return the PREV
   frame's program-counter.  */

typedef CORE_ADDR (frame_prev_pc_ftype) (struct frame_info *next_frame,
					 void **this_prologue_cache);
a134 1
  frame_prev_pc_ftype *prev_pc;
a146 6
/* Given the NEXT frame, take a wiff of THIS frame's registers (namely
   the PC and attributes) and if it is the applicable unwinder return
   the unwind methods, or NULL if it is not.  */

typedef const struct frame_unwind *(frame_unwind_sniffer_ftype) (struct frame_info *next_frame);

d151 2
a152 2
extern void frame_unwind_append_sniffer (struct gdbarch *gdbarch,
					 frame_unwind_sniffer_ftype *sniffer);
d154 1
a154 1
/* Iterate through the next frame's sniffers until one returns with an
d157 1
a157 1
extern const struct frame_unwind *frame_unwind_find_by_frame (struct frame_info *next_frame,
d160 33
@


1.18
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004, 2007 Free Software Foundation, Inc.
@


1.17
log
@	* frame-unwind.h (frame_dealloc_cache_ftype): Define.
	(struct frame_unwind): Add dealloc_cache.
	* frame.c (reinit_frame_cache): Call dealloc_cache on all caches.

	* libunwind-frame.h (libunwind_frame_dealloc_cache): Declare.
	* libunwind-frame.c (libunwind_frame_dealloc_cache): Define.
	(libunwind_frame_unwind): Set dealloc_cache.
	* ia64-tdep.c (ia64_libunwind_frame_unwind): Set dealloc_cache.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d18 1
a18 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.16
log
@Copyright updates for 2007.
@
text
@d128 4
d145 1
@


1.15
log
@Reviewed by Daniel Jacobowitz <drow@@false.org>

	2006-07-31  Fred Fish  <fnf@@specifix.com>
	* arm-tdep.c (arm_make_prologue_cache): Use FRAME_OBSTACK_ZALLOC
	instead of calling frame_obstack_zalloc directly.
	(arm_make_stub_cache): Ditto.
	* frame-unwind.h: Ditto.
	* frame.c (create_new_frame): Ditto.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
@


1.14
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d75 1
a75 1
   allocated using frame_obstack_zalloc().  */
d111 1
a111 1
   allocated using frame_obstack_zalloc().  */
@


1.14.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d75 1
a75 1
   allocated using FRAME_OBSTACK_ZALLOC().  */
d111 1
a111 1
   allocated using FRAME_OBSTACK_ZALLOC().  */
@


1.13
log
@2005-05-22  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (frame_register_unwind, frame_unwind_register)
	(get_frame_register, frame_register, put_frame_register)
	(get_frame_memory, safe_frame_unwind_memory)
	(frame_register_read): Use gdb_byte for byte buffer parameters.
	* trad-frame.h (trad_frame_get_register)
	(frame_get_prev_register): Ditto.
	* frame-unwind.h (frame_prev_register_ftype): Ditto.
	* frame.c (frame_pop, frame_register, frame_unwind_register)
	(get_frame_register, frame_unwind_register_signed)
	(frame_unwind_register_unsigned, frame_unwind_unsigned_register)
	(frame_register_read, get_frame_memory): Update.
	* trad-frame.c (trad_frame_get_prev_register): Update.
	(trad_frame_get_register): Update.
	* gdbcore.h (deprecated_read_memory_nobpt, read_memory): Ditto.
	* breakpoint.c (deprecated_read_memory_nobpt): Update.
	* corefile.c (read_memory): Update.
	* tramp-frame.c (tramp_frame_prev_register): Update.
	* valops.c (value_assign): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Update.
	* std-regs.c (value_of_builtin_frame_fp_reg)
	(value_of_builtin_frame_pc_reg): Update.
	* infcmd.c (default_print_registers_info): Update
	* dummy-frame.c (dummy_frame_prev_register): Update.
	* findvar.c (value_of_register, value_from_register): Update.
	* tui/tui-regs.c (tui_register_format, tui_get_register): Update.
	* mi/mi-main.c (register_changed_p, get_register): Update.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.12
log
@2004-11-08  Andrew Cagney  <cagney@@gnu.org>

	* sentinel-frame.c (sentinel_frame_prev_pc): New function.
	(sentinel_frame_unwinder): Add the prev_pc method.
	* frame.c (frame_pc_unwind): Use the per-frame pc unwinder when
	available.  Do not handle the sentinel-frame case.
	* frame-unwind.h (frame_prev_register_ftype): Define.
	(struct frame_unwind): Add prev_pc;
@
text
@d119 1
a119 1
					  int *realnump, void *valuep);
@


1.11
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* frame-unwind.c (struct frame_unwind_table, frame_unwind_init)
	(frame_unwind_prepend_unwinder, frame_unwind_append_sniffer)
	(frame_unwind_find_by_frame): Re-implement the unwind code so
	that it can both prepend and append sniffers.  Replace
	frame_unwind_register_unwinder with frame_unwind_prepend_unwinder.
	* tramp-frame.c (tramp_frame_append): Use
	frame_unwind_prepend_unwinder.
	* frame-unwind.h (frame_unwind_prepend_unwinder): Replace
	frame_unwind_register_unwinder.
	* tramp-frame.h (tramp_frame_prepend_unwinder): Rename
	tramp_frame_append.
	* tramp-frame.c (tramp_frame_prepend_unwinder): Update.
	* mips-linux-tdep.c (mips_linux_init_abi, mips_linux_init_abi)
	(mips_linux_init_abi): Update.
@
text
@d121 8
d140 1
@


1.10
log
@2004-03-21  Andrew Cagney  <cagney@@redhat.com>

	* frame-unwind.h: Update copyright.
	(struct frame_data): Add opaque declaration.
	(frame_sniffer_ftype): Declare.
	(struct frame_unwind): Add "unwind_data" and "sniffer".
	(frame_unwind_register_unwinder): Declare.
	(frame_unwind_find_by_frame): Add parameter "this_cache".
	* frame.c (get_frame_id, create_new_frame, legacy_get_prev_frame)
	(legacy_get_prev_frame, legacy_get_prev_frame)
	(get_frame_type): Pass the prologue_cache to
	frame_unwind_find_by_frame.
	* frame-unwind.c (struct frame_unwind_table_entry): Add field
	"unwinder".
	(frame_unwind_register_unwinder): New function.
	(frame_unwind_find_by_frame): Handle an unwind sniffer.
@
text
@d134 8
a141 5
/* Register a frame unwinder, _appending_ it to the end of the search
   list.  */
extern void frame_unwind_register_unwinder (struct gdbarch *gdbarch,
					    const struct frame_unwind *unwinder);

@


1.9
log
@2003-07-16  Andrew Cagney  <cagney@@redhat.com>

	* frame-base.h (frame_base_p_ftype): Delete definition.
	(frame_base_append_predicate): Delete declaration.
	* frame-unwind.h (frame_unwind_p_ftype): Delete definition.
	(frame_unwind_append_predicate): Delete declaration.
	* frame-unwind.c (struct frame_unwind_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_unwind_append_predicate): Delete function.
	(frame_unwind_append_sniffer): Update call to append_predicate.
	(frame_unwind_free): Delete function.
	(_initialize_frame_unwind): Pass NULL as "free" to
	register_gdbarch_data.
	(frame_unwind_init): Append the dummy_frame_sniffer.
	(frame_unwind_find_by_frame): Simplify.
	* frame-base.c (struct frame_base_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_base_append_predicate): Delete function.
	(frame_base_append_sniffer): Update call to append_predicate.
	(frame_base_free): Delete function.
	(frame_base_find_by_frame): Simplify.
	(_initialize_frame_base): Pass NULL as "free" to
	register_gdbarch_data.
	* x86-64-tdep.c (x86_64_frame_sniffer): Replace "x86_64_frame_p".
	(x86_64_sigtramp_frame_sniffer): Replace
	"x86_64_sigtramp_frame_p".
	(x86_64_init_abi): Set the frame unwind sniffers.
	* m68k-tdep.c (m68k_frame_sniffer): Replace "m68k_frame_p".
	(m68k_sigtramp_frame_sniffer): Replace "m68k_sigtramp_frame_p"
	(m68k_gdbarch_init): Set the frame unwind sniffers.
	* i386-tdep.c (i386_sigtramp_frame_sniffer): Replace
	"i386_sigtramp_frame_p".
	(i386_frame_sniffer): Replace "i386_frame_p".
	(i386_gdbarch_init): Set the frame unwind sniffers.
	* avr-tdep.c (avr_frame_sniffer): Replace "avr_frame_sniffer".
	(avr_gdbarch_init): Set the frame unwind sniffers.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Replace
	"alpha_sigtramp_frame_p"
	(alpha_heuristic_frame_sniffer): Replace
	"alpha_heuristic_frame_p".
	(alpha_gdbarch_init): Set the frame unwind sniffers.
	(alpha_dwarf2_init_abi): Ditto.
	* alpha-mdebug-tdep.c (alpha_mdebug_frame_sniffer): Replace
	"alpha_debug_frame_p".
	(alpha_mdebug_frame_base_sniffer): Replace
	"alpha_mdebug_frame_base_p".
	(alpha_mdebug_init_abi): Set the frame unwind sniffers.
	* d10v-tdep.c (d10v_frame_sniffer): Replace "d10v_frame_p".
	(d10v_gdbarch_init): Set the frame unwind sniffer.
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dummy-frame.c (dummy_frame_sniffer): Replace "dummy_frame_p".
	* dummy-frame.h (dummy_frame_sniffer): Replace "dummy_frame_p".
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
d25 1
d46 8
d130 2
d134 6
d154 1
a154 1
   unwinder implementation.  */
d156 2
a157 1
extern const struct frame_unwind *frame_unwind_find_by_frame (struct frame_info *next_frame);
@


1.9.14.1
log
@Merge mainline to intercu branch.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
a24 1
struct frame_data;
a44 8
/* Given the NEXT frame, take a wiff of THIS frame's registers (namely
   the PC and attributes) and if SELF is the applicable unwinder,
   return non-zero.  Possibly also initialize THIS_PROLOGUE_CACHE.  */

typedef int (frame_sniffer_ftype) (const struct frame_unwind *self,
				   struct frame_info *next_frame,
				   void **this_prologue_cache);

a120 2
  const struct frame_data *unwind_data;
  frame_sniffer_ftype *sniffer;
a122 6
/* Register a frame unwinder, _appending_ it to the end of the search
   list.  */
extern void frame_unwind_register_unwinder (struct gdbarch *gdbarch,
					    const struct frame_unwind *unwinder);


d137 1
a137 1
   unwinder implementation.  Possibly initialize THIS_CACHE.  */
d139 1
a139 2
extern const struct frame_unwind *frame_unwind_find_by_frame (struct frame_info *next_frame,
							      void **this_cache);
@


1.9.14.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d134 5
a138 8
/* Register a frame unwinder, _prepending_ it to the front of the
   search list (so it is sniffed before previously registered
   unwinders).  By using a prepend, later calls can install unwinders
   that override earlier calls.  This allows, for instance, an OSABI
   to install a a more specific sigtramp unwinder that overrides the
   traditional brute-force unwinder.  */
extern void frame_unwind_prepend_unwinder (struct gdbarch *gdbarch,
					   const struct frame_unwind *unwinder);
@


1.9.18.1
log
@Jumbo patch.  Experiments with tramp-frame.
@
text
@d68 1
a68 2
typedef void (frame_this_id_ftype) (const struct frame_unwind *self,
				    struct frame_info *next_frame,
d104 7
a110 9
typedef void (frame_prev_register_ftype)
     (const struct frame_unwind *self,
      struct frame_info *next_frame,
      void **this_prologue_cache,
      int prev_regnum,
      int *optimized,
      enum lval_type * lvalp,
      CORE_ADDR *addrp,
      int *realnump, void *valuep);
a120 1
  const struct frame_data *unwind_data;
d127 1
a127 11
struct frame_unwind_sniffer;

typedef const struct frame_unwind *(frame_unwind_sniffer_ftype)
     (const struct frame_unwind_sniffer *self,
      struct frame_info *next_frame);

struct frame_unwind_sniffer
{
  frame_unwind_sniffer_ftype *sniffer;
  const struct frame_data *sniffer_data;
};
d133 2
a134 4
void frame_unwind_append_sniffer (struct gdbarch *gdbarch,
				  frame_unwind_sniffer_ftype *sniffer);
void frame_unwind_sniffer_append (struct gdbarch *gdbarch,
				  const struct frame_unwind_sniffer *sniffer);
@


1.9.18.2
log
@Dump of tramp-frame stuff.
@
text
@d3 1
a3 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
a24 1
struct frame_data;
a32 7
/* Given the NEXT frame, take a wiff of THIS frame's registers (namely
   the PC and attributes) and if it is the applicable unwinder, return
   an unwind cache (allocated using frame_obstack_zalloc).  */

typedef void *(frame_sniffer_ftype) (const struct frame_unwind *self,
				     struct frame_info *next_frame);

d105 9
a113 8
typedef void (frame_prev_register_ftype) (const struct frame_unwind *self,
					  struct frame_info *next_frame,
					  void **this_prologue_cache,
					  int prev_regnum,
					  int *optimized,
					  enum lval_type * lvalp,
					  CORE_ADDR *addrp,
					  int *realnump, void *valuep);
a124 1
  frame_sniffer_ftype *sniffer;
a126 6
/* Register a frame unwinder, appending it to the end of the search
   list.  */
extern void frame_unwind_append (struct gdbarch *gdbarch,
				 const struct frame_unwind *unwinder);


d131 11
a141 1
typedef const struct frame_unwind *(frame_unwind_sniffer_ftype) (struct frame_info *next_frame);
d147 4
a150 2
extern void frame_unwind_append_sniffer (struct gdbarch *gdbarch,
					 frame_unwind_sniffer_ftype *sniffer);
d153 1
a153 1
   unwinder implementation.  Possibly initialize THIS_CACHE.  */
d155 1
a155 2
extern const struct frame_unwind *frame_unwind_find_by_frame (struct frame_info *next_frame,
							      void **this_cache);
@


1.9.18.3
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d34 7
a52 8
/* Given the NEXT frame, take a wiff of THIS frame's registers (namely
   the PC and attributes) and if SELF is the applicable unwinder,
   return non-zero.  Possibly also initialize THIS_PROLOGUE_CACHE.  */

typedef int (frame_sniffer_ftype) (const struct frame_unwind *self,
				   struct frame_info *next_frame,
				   void **this_prologue_cache);

d76 2
a77 1
typedef void (frame_this_id_ftype) (struct frame_info *next_frame,
d113 2
a114 1
typedef void (frame_prev_register_ftype) (struct frame_info *next_frame,
d135 1
a135 1
/* Register a frame unwinder, _appending_ it to the end of the search
d137 2
a138 2
extern void frame_unwind_register_unwinder (struct gdbarch *gdbarch,
					    const struct frame_unwind *unwinder);
@


1.9.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.8
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): Use frame_unwind_find_by_frame.
	(frame_register_unwind, create_new_frame): Ditto.
	(legacy_get_prev_frame, get_frame_type): Ditto.
	(get_frame_base_address): Use frame_base_find_by_frame.
	(get_frame_locals_address): Use frame_base_find_by_frame.
	(get_frame_args_address): Use frame_base_find_by_frame.
	* frame-base.h (frame_base_sniffer_ftype): Declare.
	(frame_base_append_sniffer): Declare.
	(frame_base_find_by_frame): Replace frame_base_find_by_pc.
	* frame-base.c (append_predicate): Add a "sniffer" parameter.
	(frame_base_append_sniffer): New function.
	(frame_base_append_predicate): Add a NULL sniffer.
	(frame_base_find_by_frame): Replace "frame_base_find_by_pc".
	(struct frame_base_table): Add "sniffer".
	(frame_base_free): Free the "sniffer" table.
	* frame-unwind.h (frame_unwind_sniffer_ftype): Define.
	(frame_unwind_append_sniffer): Declare.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
	* frame-unwind.c (frame_unwind_free): Free the "sniffer" table.
	(struct frame_unwind_table): Add "sniffer", delete "middle".
	(append_predicate): Add "sniffer" parameter, append the sniffer.
	(frame_unwind_init): Update append_predicate call.
	(frame_unwind_append_sniffer): New function.
	(frame_unwind_append_predicate): Update append_predicate call.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
@
text
@a32 6
/* For compatibility with the old frame code.  See end of header for
   new methods.  */
typedef const struct frame_unwind *(frame_unwind_p_ftype) (CORE_ADDR pc);
extern void frame_unwind_append_predicate (struct gdbarch *gdbarch,
					   frame_unwind_p_ftype *p);

@


1.7
log
@2003-04-04  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_prev_frame): Do not call frame_type_from_pc.  Set
	the frame's type from the unwinder.
	(get_frame_type): Map UNKNOWN_FRAME onto NORMAL_FRAME.
	(create_new_frame, legacy_get_prev_frame): When the unwinder's
	type isn't UNKNOWN_FRAME, initalize "type" from the unwinder.
	(get_frame_base_address): Use get_frame_type.
	(get_frame_locals_address, get_frame_args_address): Ditto.
	(legacy_saved_regs_unwinder): Set the type to UNKNOWN_TYPE.
	* frame.h (enum frame_type): Add UNKNOWN_FRAME.
	(struct frame_info): Add comment explaining why the frame contains
	a "type" field.
	* dummy-frame.c (dummy_frame_unwind): Set the type to DUMMY_FRAME.
	* d10v-tdep.c (d10v_frame_unwind): Set the type to NORMAL_FRAME.
	* sentinel-frame.c (sentinel_frame_unwinder): Set the type to
	NORMAL_FRAME.
	* frame-unwind.h: Include "frame.h".
	(struct frame_unwind): Add "type" field.
	* Makefile.in (frame_unwind_h): Add $(frame_h).
@
text
@d33 2
a34 3
/* Return the frame unwind methods for the function that contains PC,
   or NULL if this this unwinder can't handle this frame.  */

a35 5

/* Add a frame unwinder to the list.  The predicates are polled in the
   order that they are appended.  The initial list contains the dummy
   frame's predicate.  */

a38 7
/* Iterate through the list of frame unwinders until one returns an
   implementation.  */

extern const struct frame_unwind *frame_unwind_find_by_pc (struct gdbarch
							   *gdbarch,
							   CORE_ADDR pc);

d128 18
@


1.7.18.1
log
@2003-07-15  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_frame_id): Use frame_unwind_find_by_frame.
	(frame_register_unwind, create_new_frame): Ditto.
	(legacy_get_prev_frame, get_frame_type): Ditto.
	(get_frame_base_address): Use frame_base_find_by_frame.
	(get_frame_locals_address): Use frame_base_find_by_frame.
	(get_frame_args_address): Use frame_base_find_by_frame.
	* frame-base.h (frame_base_sniffer_ftype): Declare.
	(frame_base_append_sniffer): Declare.
	(frame_base_find_by_frame): Replace frame_base_find_by_pc.
	* frame-base.c (append_predicate): Add a "sniffer" parameter.
	(frame_base_append_sniffer): New function.
	(frame_base_append_predicate): Add a NULL sniffer.
	(frame_base_find_by_frame): Replace "frame_base_find_by_pc".
	(struct frame_base_table): Add "sniffer".
	(frame_base_free): Free the "sniffer" table.
	* frame-unwind.h (frame_unwind_sniffer_ftype): Define.
	(frame_unwind_append_sniffer): Declare.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
	* frame-unwind.c (frame_unwind_free): Free the "sniffer" table.
	(struct frame_unwind_table): Add "sniffer", delete "middle".
	(append_predicate): Add "sniffer" parameter, append the sniffer.
	(frame_unwind_init): Update append_predicate call.
	(frame_unwind_append_sniffer): New function.
	(frame_unwind_append_predicate): Update append_predicate call.
	(frame_unwind_find_by_frame): Replace frame_unwind_find_by_pc.
@
text
@d33 3
a35 2
/* For compatibility with the old frame code.  See end of header for
   new methods.  */
d37 5
d45 7
a140 18

/* Given the NEXT frame, take a wiff of THIS frame's registers (namely
   the PC and attributes) and if it is the applicable unwinder return
   the unwind methods, or NULL if it is not.  */

typedef const struct frame_unwind *(frame_unwind_sniffer_ftype) (struct frame_info *next_frame);

/* Add a frame sniffer to the list.  The predicates are polled in the
   order that they are appended.  The initial list contains the dummy
   frame sniffer.  */

extern void frame_unwind_append_sniffer (struct gdbarch *gdbarch,
					 frame_unwind_sniffer_ftype *sniffer);

/* Iterate through the next frame's sniffers until one returns with an
   unwinder implementation.  */

extern const struct frame_unwind *frame_unwind_find_by_frame (struct frame_info *next_frame);
@


1.6
log
@2003-03-17  Andrew Cagney  <cagney@@redhat.com>

	Fix frame off-by-one bug.
	* frame-unwind.h (frame_this_id_ftype): Replace
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Replace frame_unwind_reg_ftype.
	(struct frame_unwind): Replace "id" with "this_id".  Replace "reg"
	with "prev_register".
	* frame-unwind.c (frame_unwind_find_by_pc): Return
	legacy_saved_regs_unwind instead of trad_frame_unwind.  Update
	comment.
	* dummy-frame.c (cached_find_dummy_frame): Delete function.
	(dummy_frame_this_id): Replace dummy_frame_id_unwind.
	(dummy_frame_prev_register): Replace dummy_frame_register_unwind.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_prev_register): Replace
	sentinel_frame_register_unwind.
	(sentinel_frame_this_id): Replace sentinel_frame_id_unwind.
	(sentinel_frame_unwinder): Update.
	* frame.h (legacy_saved_regs_unwind): Replace trad_frame_unwind.
	(struct frame_info): Rename "unwind_cache" to "prologue_cache".
	* frame.c (create_sentinel_frame): Update. Initialize
	"prologue_cache" instead of "unwind_cache".
	(frame_register_unwind): Call this frame's prev_register with the
	next frame and this frame's prologue cache.
	(get_prev_frame): Simplify.  Always call prev frame's this_id with
	this frame and prev frame's prologue cache.  Document that this
	call is shifted one to the left when compared to the
	frame_register_unwind call.
	(legacy_saved_regs_prev_register): Replace
	frame_saved_regs_register_unwind.
	(legacy_saved_regs_this_id): Replace frame_saved_regs_id_unwind.
	(legacy_saved_regs_unwinder): Replace trad_frame_unwinder.
	(legacy_saved_regs_unwind): Replace trad_frame_unwind.
	* d10v-tdep.c (d10v_frame_this_id): Replace d10v_frame_id_unwind.
	(d10v_frame_unwind): Update.
	(d10v_frame_prev_register): Replace d10v_frame_register_unwind.
	(d10v_frame_unwind_cache): Replace this "fi" with "next_frame".
	(saved_regs_unwinder): Replace this "frame" with "next_frame", and
	"saved_regs" with "this_saved_regs".
@
text
@d31 2
d133 3
a135 1
  /* Should the frame's type go here? */
@


1.6.6.1
log
@Merge with mainline.
@
text
@a30 2
#include "frame.h"		/* For enum frame_type.  */

d131 1
a131 3
  /* The frame's type.  Should this instead be a collection of
     predicates that test the frame for various attributes?  */
  enum frame_type type;
@


1.5
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	Eliminate the need for POP_FRAME.
	* frame.c (do_frame_unwind_register): New function.
	(frame_pop): When no POP_FRAME, pop the frame using register
	unwind and a scratch regcache.
	(frame_saved_regs_pop): Delete function.
	(trad_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pop): Delete function.
	(d10v_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pop): Delete function.
	(sentinel_frame_unwinder): Update.
	* dummy-frame.c (dummy_frame_pop): Delete function.
	(dummy_frame_unwind): Update.
	* frame-unwind.h (frame_unwind_pop_ftype): Delete definition.
	(struct frame_unwind): Update.
@
text
@d50 78
a127 28
/* Return the location (and possibly value) of REGNUM for the previous
   (older, up) frame.  All parameters except VALUEP can be assumed to
   be non NULL.  When VALUEP is NULL, just the location of the
   register should be returned.

   UNWIND_CACHE is provided as mechanism for implementing a per-frame
   local cache.  It's initial value being NULL.  Memory for that cache
   should be allocated using frame_obstack_zalloc().

   Register window architectures (eg SPARC) should note that REGNUM
   identifies the register for the previous frame.  For instance, a
   request for the value of "o1" for the previous frame would be found
   in the register "i1" in this FRAME.  */

typedef void (frame_unwind_reg_ftype) (struct frame_info * frame,
				       void **unwind_cache,
				       int regnum,
				       int *optimized,
				       enum lval_type * lvalp,
				       CORE_ADDR *addrp,
				       int *realnump, void *valuep);

/* Same as for registers above, but return the ID of the frame that
   called this one.  */

typedef void (frame_unwind_id_ftype) (struct frame_info * frame,
				      void **unwind_cache,
				      struct frame_id * id);
d134 2
a135 2
  frame_unwind_id_ftype *id;
  frame_unwind_reg_ftype *reg;
@


1.5.2.1
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_this_id): Replace d10v_frame_id_unwind.
	(d10v_frame_unwind): Update.
	(d10v_frame_prev_register): Replace d10v_frame_register_unwind.
	(d10v_frame_unwind_cache): Replace this "fi" with "next_frame".
	(saved_regs_unwinder): Replace this "frame" with "next_frame", and
	"saved_regs" with "this_saved_regs".

	* dummy-frame.c (dummy_frame_unwind): Update.
	(cached_find_dummy_frame): Delete.

	* frame.c (legacy_frame_p): New function.
	(get_prev_frame): Call legacy_frame_p.
	* frame.h (legacy_frame_p): Declare.

	* dummy-frame.c (dummy_frame_prev_register): Rename
	dummy_frame_register_unwind.
	(dummy_frame_this_id): Replace dummy_frame_id_unwind.


	* sentinel-frame.c (sentinel_frame_prev_register): Replace
	sentinel_frame_register_unwind.
	(sentinel_frame_this_id): Replace sentinel_frame_id_unwind.
	(sentinel_frame_unwinder): Update.

	* frame-unwind.c (frame_unwind_find_by_pc): Return
	legacy_saved_regs_unwind instead of trad_frame_unwind.  Update
	comment.

	* frame.c (create_sentinel_frame): Initialize prologue_cache.
	(frame_register_unwind): Call this frame's prev_register with the
	next frame and this frame's prologue cache.  Add commented out
	code to cache the value.
	(get_prev_frame): Call prev frame's this_id with this frame and
	prev frame's prologue cache.  Document that this call is shifted
	one to the left when compared to the frame_register_unwind call.
	(legacy_saved_regs_prev_register): Replace
	frame_saved_regs_register_unwind.
	(legacy_saved_regs_this_id): Replace frame_saved_regs_id_unwind.
	(legacy_saved_regs_unwinder): Replace trad_frame_unwinder.
	(legacy_saved_regs_unwind): Replace trad_frame_unwind.

	* frame.h (legacy_saved_regs_unwind): Replace trad_frame_unwind.
	(struct frame_info): Rename "unwind_cache" to "prolog_cache".

	* frame-unwind.h (frame_this_id_ftype): Replace
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Replace frame_unwind_reg_ftype.
	(struct frame_unwind): Update.  Rename "id" to "this_id".  Rename
	"reg" to "prev_register".
@
text
@d50 28
a77 78
/* The following unwind functions assume a chain of frames forming the
   sequence: (outer) prev <-> this <-> next (inner).  All the
   functions are called with called with the next frame's `struct
   frame_info' and and this frame's prologue cache.

   THIS frame's register values can be obtained by unwinding NEXT
   frame's registers (a recursive operation).

   THIS frame's prologue cache can be used to cache information such
   as where this frame's prologue stores the previous frame's
   registers.  */

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to determine
   the frame ID of THIS frame.

   A frame ID provides an invariant that can be used to re-identify an
   instance of a frame.  It is a combination of the frame's `base' and
   the frame's function's code address.

   Traditionally, THIS frame's ID was determined by examining THIS
   frame's function's prologue, and identifying the register/offset
   used as THIS frame's base.

   Example: An examination of THIS frame's prologue reveals that, on
   entry, it saves the PC(+12), SP(+8), and R1(+4) registers
   (decrementing the SP by 12).  Consequently, the frame ID's base can
   be determined by adding 12 to the THIS frame's stack-pointer, and
   the value of THIS frame's SP can be obtained by unwinding the NEXT
   frame's SP.

   THIS_PROLOGUE_CACHE can be used to share any prolog analysis data
   with the other unwind methods.  Memory for that cache should be
   allocated using frame_obstack_zalloc().  */

typedef void (frame_this_id_ftype) (struct frame_info *next_frame,
				    void **this_prologue_cache,
				    struct frame_id *this_id);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to unwind THIS
   frame's registers (returning the value of the specified register
   REGNUM in the previous frame).

   Traditionally, THIS frame's registers were unwound by examining
   THIS frame's function's prologue and identifying which registers
   that prolog code saved on the stack.

   Example: An examination of THIS frame's prologue reveals that, on
   entry, it saves the PC(+12), SP(+8), and R1(+4) registers
   (decrementing the SP by 12).  Consequently, the value of the PC
   register in the previous frame is found in memory at SP+12, and
   THIS frame's SP can be obtained by unwinding the NEXT frame's SP.

   Why not pass in THIS_FRAME?  By passing in NEXT frame and THIS
   cache, the supplied parameters are consistent with the sibling
   function THIS_ID.

   Can the code call ``frame_register (get_prev_frame (NEXT_FRAME))''?
   Won't the call frame_register (THIS_FRAME) be faster?  Well,
   ignoring the possability that the previous frame does not yet
   exist, the ``frame_register (FRAME)'' function is expanded to
   ``frame_register_unwind (get_next_frame (FRAME)'' and hence that
   call will expand to ``frame_register_unwind (get_next_frame
   (get_prev_frame (NEXT_FRAME)))''.  Might as well call
   ``frame_register_unwind (NEXT_FRAME)'' directly.

   THIS_PROLOGUE_CACHE can be used to share any prolog analysis data
   with the other unwind methods.  Memory for that cache should be
   allocated using frame_obstack_zalloc().  */

typedef void (frame_prev_register_ftype) (struct frame_info *next_frame,
					  void **this_prologue_cache,
					  int prev_regnum,
					  int *optimized,
					  enum lval_type * lvalp,
					  CORE_ADDR *addrp,
					  int *realnump, void *valuep);
d84 2
a85 2
  frame_this_id_ftype *this_id;
  frame_prev_register_ftype *prev_register;
@


1.4
log
@2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_unwind_pc): New method.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (frame_pc_unwind): Rewrite.  Prefer gdbarch_unwind_pc,
	but use read_pc and FRAME_SAVED_PC as fall backs.
	(frame_saved_regs_pc_unwind): Delete function.
	(trad_frame_unwinder): Update.
	* frame-unwind.h (frame_unwind_pc_ftype): Delete declaration.
	(struct frame_unwind): Update.
	* dummy-frame.c (dummy_frame_pc_unwind): Delete function.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pc_unwind): Delete function.
	(sentinel_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pc_unwind): Delete function.
	(d10v_frame_unwind): Update.
	(d10v_unwind_pc): New function.
	(d10v_gdbarch_init): Set unwind_pc.

Index: doc/ChangeLog
2003-03-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Cross reference
	FRAME_SAVED_PC to unwind_pc.  Document unwind_pc.
@
text
@a78 15
/* Discard the frame by restoring the registers (in regcache) back to
   that of the caller.  */
/* NOTE: cagney/2003-01-19: While at present the callers all pop each
   frame in turn, the implementor should try to code things so that
   any frame can be popped directly.  */
/* FIXME: cagney/2003-01-19: Since both FRAME and REGCACHE refer to a
   common register cache, care must be taken when restoring the
   registers.  The `correct fix' is to first first save the registers
   in a scratch cache, and second write that scratch cache back to to
   the real register cache.  */

typedef void (frame_unwind_pop_ftype) (struct frame_info *frame,
				       void **unwind_cache,
				       struct regcache *regcache);

a83 1
  frame_unwind_pop_ftype *pop;
@


1.3
log
@2003-01-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame-unwind.h (frame_unwind_pop_ftype): Declare.
	(struct frame_unwind): Add field pop.
	* frame.h (frame_pop): Declare.
	* frame.c (frame_saved_regs_pop): New function.
	(trad_frame_unwinder): Add frame_saved_regs_pop.
	(frame_pop): New function.
	* dummy-frame.c (dummy_frame_pop): New function.
	(discard_innermost_dummy): New function.
	(generic_pop_dummy_frame): Use discard_innermost_dummy.
	(dummy_frame_unwind): Add dummy_frame_pop.
	* infrun.c (normal_stop): Call frame_pop instead of POP_FRAME.
	* valops.c (hand_function_call): Ditto.
	* stack.c (return_command): Ditto.
@
text
@a71 6
/* Same as for registers above, but return the address at which the
   calling frame would resume.  */

typedef CORE_ADDR (frame_unwind_pc_ftype) (struct frame_info * frame,
					   void **unwind_cache);

a99 1
  frame_unwind_pc_ftype *pc;
@


1.3.8.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d72 6
d85 15
d105 2
@


1.3.6.1
log
@2003-03-04  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_unwind_cache): Update to work with
	NEXT_FRAME and THIS_CACHE.
	(d10v_frame_pc_unwind): Ditto.
	(d10v_frame_id_unwind): Ditto.
	(saved_regs_unwinder): Ditto.
	(d10v_frame_register_unwind): Ditto.
	* dummy-frame.c (dummy_frame_register_unwind): Ditto.
	(dummy_frame_pc_unwind): Ditto.
	(cached_find_dummy_frame): Ditto.
	(dummy_frame_id_unwind): Ditto.
	(dummy_frame_pop): Ditto.
	* sentinel-frame.c (sentinel_frame_register_unwind): Ditto.
	(sentinel_frame_pc_unwind): Ditto.
	(sentinel_frame_id_unwind): Ditto.
	(sentinel_frame_pop): Ditto.
	* frame.c (frame_id_unwind): Reinstate function.
	* frame.h (frame_id_unwind): Reinstate declaration.
	* frame.c (frame_pc_unwind): Pass frame->next to the PC's unwind
	method.
	(frame_pop, frame_register_unwind): Ditto.
	* frame-unwind.h (frame_unwind_id_ftype, frame_unwind_reg_ftype)
	(frame_unwind_pc_ftype, frame_unwind_pop_ftype): Re-specify
	behavior in terms of PREV_REGNUM, THIS_CACHE and NEXT_FRAME.
@
text
@d50 17
a66 50
/* The following unwind functions all assume a frame chain like:
   (outer) prev <-> this <-> next (inner); Even though some unwind to
   THIS frame (frame ID) and others unwind the PREV frame, they are
   all, consistently passed NEXT frame and THIS cache.

   The intent is to clarify the relationship between NEXT frame and
   THIS cache.  It is, of course, at the expense of confusing somewhat
   the expected unwind behavior of PC/REG unwind VS ID unwind.  Sigh.  */

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to determine
   the frame ID of THIS frame.

   A frame ID provides an invariant that can be used to re-identify an
   instance of a frame.  It is a combination of the frame's `base' and
   the frame's function's code.

   Traditionally, THIS frame's ID was determined by examining THIS
   frame's function's prologue and identifying which register/offset
   are being used as THIS frame's base.

   THIS_CACHE can be used to share any prolog analysis data with the
   other unwind methods.  Memory for that cache should be allocated
   using frame_obstack_zalloc().  */

typedef void (frame_unwind_id_ftype) (struct frame_info *next_frame,
				      void **this_cache,
				      struct frame_id *this_id);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to unwind THIS
   frame's registers, returning the value of REGNUM in PREV frame.

   Traditionally, THIS frame's registers were unwound by examining
   THIS frame's function's prologue and identifying which registers
   that prolog code saved on the stack.

   Ex: Assuming THIS is a frameless function that has saved the return
   address (to PREV) in R1, then: a request to unwind THIS's PC
   (returning the value of PC in PREV), becomes a request for the
   value of R1 in THIS (that is where the value was saved), which
   becomes a request to unwind R1 from NEXT.

   THIS_CACHE can be used to share any prologue analysis data with the
   other unwind methods.  Memory for that cache should be allocated
   using frame_obstack_zalloc().  */

typedef void (frame_unwind_reg_ftype) (struct frame_info *next_frame,
				       void **this_cache,
				       int prev_regnum,
d72 2
a73 24
/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to unwind THIS
   frame's PC, returning the value of PC (the return address) in PREV
   frame.

   Traditionally, THIS frame's PC was unwound by examining THIS
   frame's function prolog and identifying where (in a register or on
   the stack) that return address was saved.

   Please note that this per-frame method may be superseeded by an
   architecture specific method that determines the unwound PC (aka
   return address) using just the register unwind methods.

   THIS_CACHE can be used to share any prologue analysis data with the
   other unwind methods.  Memory for that cache should be allocated
   using frame_obstack_zalloc().  */

typedef CORE_ADDR (frame_unwind_pc_ftype) (struct frame_info *next_frame,
					   void **this_cache);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to unwind THIS
   frame's entire stack, writing PREV's frames register values into
   REGCACHE.
d75 13
a87 1
   NOTE: cagney/2003-01-19: While at present the callers all pop each
d89 2
a90 3
   any frame can be popped directly.

   FIXME: cagney/2003-01-19: Since both FRAME and REGCACHE refer to a
d94 1
a94 5
   the real register cache.

   FIXME: cagney/2003-03-04: Isn't this entire function redundant?
   Shouldn't the code instead just iterate through the restore
   reggroup unwinding those registers?  */
d96 2
a97 2
typedef void (frame_unwind_pop_ftype) (struct frame_info *next_frame,
				       void **this_cache,
@


1.3.6.2
log
@2003-03-06  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (gdbarch_unwind_pc): New method.
	* gdbarch.h, gdbarch.c: Regenerate.
	* frame.c (frame_pc_unwind): Rewrite.  Prefer gdbarch_unwind_pc,
	but use read_pc and FRAME_SAVED_PC as fall backs.
	(frame_saved_regs_pc_unwind): Delete function.
	(trad_frame_unwinder): Update.
	* frame-unwind.h (frame_unwind_pc_ftype): Delete declaration.
	(struct frame_unwind): Update.
	* dummy-frame.c (dummy_frame_pc_unwind): Delete function.
	(dummy_frame_unwind): Update.
	* sentinel-frame.c (sentinel_frame_pc_unwind): Delete function.
	(sentinel_frame_unwinder): Update.
	* d10v-tdep.c (d10v_frame_pc_unwind): Delete function.
	(d10v_frame_unwind): Update.
	(d10v_unwind_pc): New function.
	(d10v_gdbarch_init): Set unwind_pc.

2003-03-05  Andrew Cagney  <cagney@@redhat.com>

	* dummy-frame.c (dummy_frame_id_unwind): Abort if called.
	(cached_find_dummy_frame): Add hack to obtain this thread's id
	without calling id unwind.
	* frame.h: Merge with mainline.
	* d10v-tdep.c: Merge with mainline.
	* frame.c: Merge with mainline.
@
text
@d107 20
d154 1
@


1.3.6.3
log
@2003-03-06  Andrew Cagney  <cagney@@redhat.com>

	* d10v-tdep.c (d10v_frame_pop): Delete function.
	(d10v_frame_unwind): Update.
	* frame.c: Include "reggroups.h".
	* regcache.c (regcache_raw_write): Allow writes to a readonly
	regcache.
	* frame.c (frame_saved_regs_pop): Delete function.
	(trad_frame_unwinder): Update
	(frame_pop): Rewrite.
	* sentinel-frame.c (sentinel_frame_pop): Delete function.
	(sentinel_frame_unwinder): Update.
	* dummy-frame.c (dummy_frame_pop): Delete function.
	(dummy_frame_unwind): Update.
	* frame-unwind.h (frame_unwind_pop_ftype): Delete definition.
	(struct frame_unwind): Update.
@
text
@d105 23
d133 1
@


1.3.6.4
log
@2003-03-11  Andrew Cagney  <cagney@@redhat.com>

	* frame-unwind.h (frame_this_id_ftype): Rename
	frame_unwind_id_ftype.
	(frame_prev_register_ftype): Rename frame_unwind_reg_ftype.
	(struct frame_unwind): Update.  Rename "id" to "this_id", and
	"reg" to "prev_register".
	* frame.c (get_prev_frame): Update.  Rename parameter next_frame
	to this frame.
	(frame_register_unwind): Update.
@
text
@d75 3
a77 3
typedef void (frame_this_id_ftype) (struct frame_info *next_frame,
				    void **this_cache,
				    struct frame_id *this_id);
d97 7
a103 7
typedef void (frame_prev_register_ftype) (struct frame_info *next_frame,
					  void **this_cache,
					  int prev_regnum,
					  int *optimized,
					  enum lval_type * lvalp,
					  CORE_ADDR *addrp,
					  int *realnump, void *valuep);
d110 2
a111 2
  frame_this_id_ftype *this_id;
  frame_prev_register_ftype *prev_register;
@


1.3.4.1
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@@


1.3.4.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a30 2
#include "frame.h"		/* For enum frame_type.  */

d50 49
a98 78
/* The following unwind functions assume a chain of frames forming the
   sequence: (outer) prev <-> this <-> next (inner).  All the
   functions are called with called with the next frame's `struct
   frame_info' and and this frame's prologue cache.

   THIS frame's register values can be obtained by unwinding NEXT
   frame's registers (a recursive operation).

   THIS frame's prologue cache can be used to cache information such
   as where this frame's prologue stores the previous frame's
   registers.  */

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to determine
   the frame ID of THIS frame.

   A frame ID provides an invariant that can be used to re-identify an
   instance of a frame.  It is a combination of the frame's `base' and
   the frame's function's code address.

   Traditionally, THIS frame's ID was determined by examining THIS
   frame's function's prologue, and identifying the register/offset
   used as THIS frame's base.

   Example: An examination of THIS frame's prologue reveals that, on
   entry, it saves the PC(+12), SP(+8), and R1(+4) registers
   (decrementing the SP by 12).  Consequently, the frame ID's base can
   be determined by adding 12 to the THIS frame's stack-pointer, and
   the value of THIS frame's SP can be obtained by unwinding the NEXT
   frame's SP.

   THIS_PROLOGUE_CACHE can be used to share any prolog analysis data
   with the other unwind methods.  Memory for that cache should be
   allocated using frame_obstack_zalloc().  */

typedef void (frame_this_id_ftype) (struct frame_info *next_frame,
				    void **this_prologue_cache,
				    struct frame_id *this_id);

/* Assuming the frame chain: (outer) prev <-> this <-> next (inner);
   use the NEXT frame, and its register unwind method, to unwind THIS
   frame's registers (returning the value of the specified register
   REGNUM in the previous frame).

   Traditionally, THIS frame's registers were unwound by examining
   THIS frame's function's prologue and identifying which registers
   that prolog code saved on the stack.

   Example: An examination of THIS frame's prologue reveals that, on
   entry, it saves the PC(+12), SP(+8), and R1(+4) registers
   (decrementing the SP by 12).  Consequently, the value of the PC
   register in the previous frame is found in memory at SP+12, and
   THIS frame's SP can be obtained by unwinding the NEXT frame's SP.

   Why not pass in THIS_FRAME?  By passing in NEXT frame and THIS
   cache, the supplied parameters are consistent with the sibling
   function THIS_ID.

   Can the code call ``frame_register (get_prev_frame (NEXT_FRAME))''?
   Won't the call frame_register (THIS_FRAME) be faster?  Well,
   ignoring the possability that the previous frame does not yet
   exist, the ``frame_register (FRAME)'' function is expanded to
   ``frame_register_unwind (get_next_frame (FRAME)'' and hence that
   call will expand to ``frame_register_unwind (get_next_frame
   (get_prev_frame (NEXT_FRAME)))''.  Might as well call
   ``frame_register_unwind (NEXT_FRAME)'' directly.

   THIS_PROLOGUE_CACHE can be used to share any prolog analysis data
   with the other unwind methods.  Memory for that cache should be
   allocated using frame_obstack_zalloc().  */

typedef void (frame_prev_register_ftype) (struct frame_info *next_frame,
					  void **this_prologue_cache,
					  int prev_regnum,
					  int *optimized,
					  enum lval_type * lvalp,
					  CORE_ADDR *addrp,
					  int *realnump, void *valuep);
d102 1
a102 3
  /* The frame's type.  Should this instead be a collection of
     predicates that test the frame for various attributes?  */
  enum frame_type type;
d105 4
a108 2
  frame_this_id_ftype *this_id;
  frame_prev_register_ftype *prev_register;
@


1.3.4.3
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d33 19
a140 18

/* Given the NEXT frame, take a wiff of THIS frame's registers (namely
   the PC and attributes) and if it is the applicable unwinder return
   the unwind methods, or NULL if it is not.  */

typedef const struct frame_unwind *(frame_unwind_sniffer_ftype) (struct frame_info *next_frame);

/* Add a frame sniffer to the list.  The predicates are polled in the
   order that they are appended.  The initial list contains the dummy
   frame sniffer.  */

extern void frame_unwind_append_sniffer (struct gdbarch *gdbarch,
					 frame_unwind_sniffer_ftype *sniffer);

/* Iterate through the next frame's sniffers until one returns with an
   unwinder implementation.  */

extern const struct frame_unwind *frame_unwind_find_by_frame (struct frame_info *next_frame);
@


1.2
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* dummy-frame.h (dummy_frame_id_unwind): Delete declaration.
	(dummy_frame_pc_unwind, dummy_frame_register_unwind): Ditto.
	(struct frame_unwind): Declare opaque.
	(dummy_frame_p): Declare function.
	* dummy-frame.c (dummy_frame_id_unwind): Make static.
	(dummy_frame_pc_unwind, dummy_frame_register_unwind): Ditto.
	* dummy-frame.c: Include "frame-unwind.h".
	(dummy_frame_p): New function.
	(dummy_frame_unwind): New variable.
	* frame.c: Include "frame-unwind.h".
	(frame_pc_unwind, frame_id_unwind, frame_register_unwind): Update
	to use the new unwind field.
	(set_unwind_by_pc): Delete function.
	(create_new_frame, get_prev_frame): Set unwind field using
	frame_unwind_find_by_pc.
	(trad_frame_unwind, trad_frame_unwinder): New variables.
	* frame.h (trad_frame_unwind): Declare variable.
	(frame_id_unwind_ftype): Delete declaration.
	(frame_pc_unwind_ftype, frame_register_unwind_ftype): Ditto.
	(struct frame_unwind): Declare opaque.
	(struct frame_info): Replace the fields id_unwind, pc_unwind and
	register_unwind with a single unwind pointer.
	* frame-unwind.h, frame-unwind.c: New files.
	* Makefile.in (SFILES): Add frame-unwind.c.
	(frame_unwind_h): Define.
	(COMMON_OBS): Add frame-unwind.o.
	(frame-unwind.o): Specify dependencies.
	(frame.o, dummy-frame.o): Update dependencies.
@
text
@d85 14
d105 1
@


1.1
log
@file frame-unwind.h was initially added on branch cagney-unwind-20030108-branch.
@
text
@d1 96
@


1.1.2.1
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* d10v-tdep.c: Include "d10v-tdep.h".  Update to use D10V_
	prefixed enums.
	(do_d10v_pop_frame): Delete.  Use version in d10v-frame.c.

	* frame.c (frame_read_unsigned_register): Do not use
	get_next_frame.
	(frame_read_signed_register): Do not use get_next_frame.
	(get_frame_base): Use frame_id_unwind.

	* d10v-tdep.h: New file.
	* d10v-frame.h: New file.
	* d10v-frame.c: New file.

	* frame.c (frame_id_unwind): Update.
	(create_sentinel_frame): Update.
	(legacy_get_prev_frame): Use frame_unwind_find_by_pc.
	(get_prev_frame): Ditto.

	* frame.h (struct frame_info): Replace pc_unwind, id_unwind and
	register_unwind with unwind structure.

	* frame.c (set_unwind_by_pc): Delete function.
	(create_new_frame): Use frame_unwind_find_by_pc;

	* Makefile.in (frame_h): Add $(frame_unwind_h).
	* frame.h: Include "frame-unwind.h".
	(frame_register_unwind_ftype): Delete.
	(frame_id_unwind_ftype): Delete.
	(frame_pc_unwind_ftype): Delete.

	* Makefile.in (dummy-frame.o): Update dependencies.
	(legacy-frame.o): Update dependencies.

	* dummy-frame.c: Include "frame-unwind.h".
	(dummy_frame_unwind): New static variable.
	(dummy_frame_p): New function.
	* legacy-frame.c: Include "frame-unwind.h".
	(legacy_frame_unwind): New static variable.
	(legacy_frame_p): New function.
	* legacy-frame.h (legacy_frame_p): Declare.
	* dummy-frame.h (dummy_frame_p): Declare.

	* Makefile.in (frame_unwind_h): Define.
	* frame-unwind.h: New file.
	* frame-unwind.c: New file.
@
text
@a0 92
/* Definitions for a frame unwinder, for GDB, the GNU debugger.

   Copyright 2003 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#if !defined (FRAME_UNWIND_H)
#define FRAME_UNWIND_H 1

struct frame_info;
struct frame_unwind_cache;
struct frame_unwind;
struct frame_id;
struct gdbarch;

/* Return the corresponding frame descriptor this method is capable of
   unwinding the frame containing PC.  */

typedef const struct frame_unwind *(frame_unwind_p_ftype) (CORE_ADDR pc);

/* Append a descriptor predicate.  Descriptors are polled in append
   order.  The list is initialized with just the dummy frame.  */

extern void frame_unwind_append_predicate (struct gdbarch *gdbarch,
					   frame_unwind_p_ftype *p);

/* Iterate through the list of frame descriptor predicates for the
   first one to return a frame descriptor.  */

extern const struct frame_unwind *frame_unwind_find_by_pc (struct gdbarch *gdbarch,
							   CORE_ADDR pc);

/* Return the location (and possibly value) of REGNUM for the previous
   (older, up) frame.  All parameters except VALUEP can be assumed to
   be non NULL.  When VALUEP is NULL, just the location of the
   register should be returned.

   UNWIND_CACHE is provided as mechanism for implementing a per-frame
   local cache.  It's initial value being NULL.  Memory for that cache
   should be allocated using frame_obstack_zalloc().

   Register window architectures (eg SPARC) should note that REGNUM
   identifies the register for the previous frame.  For instance, a
   request for the value of "o1" for the previous frame would be found
   in the register "i1" in this FRAME.  */

typedef void (frame_register_unwind_ftype) (struct frame_info *frame,
					    struct frame_unwind_cache **unwind_cache,
					    int regnum,
					    int *optimized,
					    enum lval_type *lvalp,
					    CORE_ADDR *addrp,
					    int *realnump,
					    void *valuep);

/* Same as for registers above, but return the address at which the
   calling frame would resume.  */

typedef CORE_ADDR (frame_pc_unwind_ftype) (struct frame_info *frame,
					   struct frame_unwind_cache **unwind_cache);

/* Same as for registers above, but return the ID of the frame that
   called this one.  */

typedef void (frame_id_unwind_ftype) (struct frame_info *frame,
				      struct frame_unwind_cache **unwind_cache,
				      struct frame_id *id);

struct frame_unwind
{
  /* FIXME: Should the frame's type go here? */
  frame_pc_unwind_ftype *pc;
  frame_id_unwind_ftype *id;
  frame_register_unwind_ftype *reg;
};

#endif
@


1.1.2.2
log
@Merge branch with mainline:
POP_FRAME_P;
frame-unwind.h.
@
text
@d26 2
a28 1
struct frame_unwind;
a29 1
struct regcache;
d31 2
a32 2
/* Return the frame unwind methods for the function that contains PC,
   or NULL if this this unwinder can't handle this frame.  */
d36 2
a37 3
/* Add a frame unwinder to the list.  The predicates are polled in the
   order that they are appended.  The initial list contains the dummy
   frame's predicate.  */
d42 2
a43 2
/* Iterate through the list of frame unwinders until one returns an
   implementation.  */
d45 1
a45 2
extern const struct frame_unwind *frame_unwind_find_by_pc (struct gdbarch
							   *gdbarch,
d62 8
a69 7
typedef void (frame_unwind_reg_ftype) (struct frame_info * frame,
				       void **unwind_cache,
				       int regnum,
				       int *optimized,
				       enum lval_type * lvalp,
				       CORE_ADDR *addrp,
				       int *realnump, void *valuep);
d74 2
a75 2
typedef CORE_ADDR (frame_unwind_pc_ftype) (struct frame_info * frame,
					   void **unwind_cache);
d80 3
a82 18
typedef void (frame_unwind_id_ftype) (struct frame_info * frame,
				      void **unwind_cache,
				      struct frame_id * id);

/* Discard the frame by restoring the registers (in regcache) back to
   that of the caller.  */
/* NOTE: cagney/2003-01-19: While at present the callers all pop each
   frame in turn, the implementor should try to code things so that
   any frame can be popped directly.  */
/* FIXME: cagney/2003-01-19: Since both FRAME and REGCACHE refer to a
   common register cache, care must be taken when restoring the
   registers.  The `correct fix' is to first first save the registers
   in a scratch cache, and second write that scratch cache back to to
   the real register cache.  */

typedef void (frame_unwind_pop_ftype) (struct frame_info *frame,
				       void **unwind_cache,
				       struct regcache *regcache);
d86 4
a89 7
  /* Should the frame's type go here? */
  /* Should an attribute indicating the frame's address-in-block go
     here?  */
  frame_unwind_pop_ftype *pop;
  frame_unwind_pc_ftype *pc;
  frame_unwind_id_ftype *id;
  frame_unwind_reg_ftype *reg;
@


