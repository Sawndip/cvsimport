head	1.96;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.92
	gdb_7_6-2013-04-26-release:1.92
	gdb_7_6-branch:1.92.0.2
	gdb_7_6-2013-03-12-branchpoint:1.92
	gdb_7_5_1-2012-11-29-release:1.87
	gdb_7_5-2012-08-17-release:1.87
	gdb_7_5-branch:1.87.0.2
	gdb_7_5-2012-07-18-branchpoint:1.87
	gdb_7_4_1-2012-04-26-release:1.83.4.1
	gdb_7_4-2012-01-24-release:1.83.4.1
	gdb_7_4-branch:1.83.0.4
	gdb_7_4-2011-12-13-branchpoint:1.83
	gdb_7_3_1-2011-09-04-release:1.83
	gdb_7_3-2011-07-26-release:1.83
	gdb_7_3-branch:1.83.0.2
	gdb_7_3-2011-04-01-branchpoint:1.83
	gdb_7_2-2010-09-02-release:1.81
	gdb_7_2-branch:1.81.0.2
	gdb_7_2-2010-07-07-branchpoint:1.81
	gdb_7_1-2010-03-18-release:1.80
	gdb_7_1-branch:1.80.0.2
	gdb_7_1-2010-02-18-branchpoint:1.80
	gdb_7_0_1-2009-12-22-release:1.77
	gdb_7_0-2009-10-06-release:1.77
	gdb_7_0-branch:1.77.0.4
	gdb_7_0-2009-09-16-branchpoint:1.77
	arc-sim-20090309:1.56
	msnyder-checkpoint-072509-branch:1.77.0.2
	msnyder-checkpoint-072509-branchpoint:1.77
	arc-insight_6_8-branch:1.56.0.8
	arc-insight_6_8-branchpoint:1.56
	insight_6_8-branch:1.56.0.6
	insight_6_8-branchpoint:1.56
	reverse-20081226-branch:1.61.0.4
	reverse-20081226-branchpoint:1.61
	multiprocess-20081120-branch:1.61.0.2
	multiprocess-20081120-branchpoint:1.61
	reverse-20080930-branch:1.60.0.2
	reverse-20080930-branchpoint:1.60
	reverse-20080717-branch:1.57.0.2
	reverse-20080717-branchpoint:1.57
	msnyder-reverse-20080609-branch:1.56.0.4
	msnyder-reverse-20080609-branchpoint:1.56
	drow-reverse-20070409-branch:1.49.0.2
	drow-reverse-20070409-branchpoint:1.49
	gdb_6_8-2008-03-27-release:1.56
	gdb_6_8-branch:1.56.0.2
	gdb_6_8-2008-02-26-branchpoint:1.56
	gdb_6_7_1-2007-10-29-release:1.54
	gdb_6_7-2007-10-10-release:1.54
	gdb_6_7-branch:1.54.0.2
	gdb_6_7-2007-09-07-branchpoint:1.54
	insight_6_6-20070208-release:1.48
	gdb_6_6-2006-12-18-release:1.48
	gdb_6_6-branch:1.48.0.18
	gdb_6_6-2006-11-15-branchpoint:1.48
	insight_6_5-20061003-release:1.48
	gdb-csl-symbian-6_4_50_20060226-12:1.48
	gdb-csl-sourcerygxx-3_4_4-25:1.46.8.1
	nickrob-async-20060828-mergepoint:1.48
	gdb-csl-symbian-6_4_50_20060226-11:1.48
	gdb-csl-sourcerygxx-4_1-17:1.48
	gdb-csl-20060226-branch-local-2:1.48
	gdb-csl-sourcerygxx-4_1-14:1.48
	gdb-csl-sourcerygxx-4_1-13:1.48
	gdb-csl-sourcerygxx-4_1-12:1.48
	gdb-csl-sourcerygxx-3_4_4-21:1.48
	gdb_6_5-20060621-release:1.48
	gdb-csl-sourcerygxx-4_1-9:1.48
	gdb-csl-sourcerygxx-4_1-8:1.48
	gdb-csl-sourcerygxx-4_1-7:1.48
	gdb-csl-arm-2006q1-6:1.48
	gdb-csl-sourcerygxx-4_1-6:1.48
	gdb-csl-symbian-6_4_50_20060226-10:1.48
	gdb-csl-symbian-6_4_50_20060226-9:1.48
	gdb-csl-symbian-6_4_50_20060226-8:1.48
	gdb-csl-coldfire-4_1-11:1.48
	gdb-csl-sourcerygxx-3_4_4-19:1.48
	gdb-csl-coldfire-4_1-10:1.48
	gdb_6_5-branch:1.48.0.16
	gdb_6_5-2006-05-14-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-5:1.48
	nickrob-async-20060513-branch:1.48.0.14
	nickrob-async-20060513-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-4:1.48
	msnyder-reverse-20060502-branch:1.48.0.12
	msnyder-reverse-20060502-branchpoint:1.48
	gdb-csl-morpho-4_1-4:1.48
	gdb-csl-sourcerygxx-3_4_4-17:1.48
	readline_5_1-import-branch:1.48.0.10
	readline_5_1-import-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.48
	gdb-csl-symbian-20060226-branch:1.48.0.8
	gdb-csl-symbian-20060226-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.48
	msnyder-reverse-20060331-branch:1.48.0.6
	msnyder-reverse-20060331-branchpoint:1.48
	gdb-csl-available-20060303-branch:1.48.0.4
	gdb-csl-available-20060303-branchpoint:1.48
	gdb-csl-20060226-branch:1.48.0.2
	gdb-csl-20060226-branchpoint:1.48
	gdb_6_4-20051202-release:1.46
	msnyder-fork-checkpoint-branch:1.46.0.10
	msnyder-fork-checkpoint-branchpoint:1.46
	gdb-csl-gxxpro-6_3-branch:1.46.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.46
	gdb_6_4-branch:1.46.0.6
	gdb_6_4-2005-11-01-branchpoint:1.46
	gdb-csl-arm-20051020-branch:1.46.0.4
	gdb-csl-arm-20051020-branchpoint:1.46
	msnyder-tracepoint-checkpoint-branch:1.46.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.46
	gdb-csl-arm-20050325-2005-q1b:1.45
	gdb-csl-arm-20050325-2005-q1a:1.45
	csl-arm-20050325-branch:1.45.0.2
	csl-arm-20050325-branchpoint:1.45
	gdb-post-i18n-errorwarning-20050211:1.42
	gdb-pre-i18n-errorwarning-20050211:1.41
	gdb_6_3-20041109-release:1.41
	gdb_6_3-branch:1.41.0.2
	gdb_6_3-20041019-branchpoint:1.41
	drow_intercu-merge-20040921:1.40
	drow_intercu-merge-20040915:1.40
	jimb-gdb_6_2-e500-branch:1.38.0.6
	jimb-gdb_6_2-e500-branchpoint:1.38
	gdb_6_2-20040730-release:1.38
	gdb_6_2-branch:1.38.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.38
	gdb_6_1_1-20040616-release:1.37
	gdb_6_1-2004-04-05-release:1.37
	drow_intercu-merge-20040402:1.37
	drow_intercu-merge-20040327:1.37
	ezannoni_pie-20040323-branch:1.37.0.12
	ezannoni_pie-20040323-branchpoint:1.37
	cagney_tramp-20040321-mergepoint:1.37
	cagney_tramp-20040309-branch:1.37.0.10
	cagney_tramp-20040309-branchpoint:1.37
	gdb_6_1-branch:1.37.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.37
	drow_intercu-20040221-branch:1.37.0.6
	drow_intercu-20040221-branchpoint:1.37
	cagney_bfdfile-20040213-branch:1.37.0.4
	cagney_bfdfile-20040213-branchpoint:1.37
	drow-cplus-merge-20040208:1.37
	carlton_dictionary-20040126-merge:1.37
	cagney_bigcore-20040122-branch:1.37.0.2
	cagney_bigcore-20040122-branchpoint:1.37
	drow-cplus-merge-20040113:1.37
	drow-cplus-merge-20031224:1.36
	drow-cplus-merge-20031220:1.36
	carlton_dictionary-20031215-merge:1.36
	drow-cplus-merge-20031214:1.36
	carlton-dictionary-20031111-merge:1.36
	gdb_6_0-2003-10-04-release:1.34
	kettenis_sparc-20030918-branch:1.35.0.4
	kettenis_sparc-20030918-branchpoint:1.35
	carlton_dictionary-20030917-merge:1.35
	ezannoni_pie-20030916-branchpoint:1.35
	ezannoni_pie-20030916-branch:1.35.0.2
	cagney_x86i386-20030821-branch:1.34.0.36
	cagney_x86i386-20030821-branchpoint:1.34
	carlton_dictionary-20030805-merge:1.34
	carlton_dictionary-20030627-merge:1.34
	gdb_6_0-branch:1.34.0.34
	gdb_6_0-2003-06-23-branchpoint:1.34
	jimb-ppc64-linux-20030613-branch:1.34.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.34
	cagney_convert-20030606-branch:1.34.0.30
	cagney_convert-20030606-branchpoint:1.34
	cagney_writestrings-20030508-branch:1.34.0.28
	cagney_writestrings-20030508-branchpoint:1.34
	jimb-ppc64-linux-20030528-branch:1.34.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.34
	carlton_dictionary-20030523-merge:1.34
	cagney_fileio-20030521-branch:1.34.0.24
	cagney_fileio-20030521-branchpoint:1.34
	kettenis_i386newframe-20030517-mergepoint:1.34
	jimb-ppc64-linux-20030509-branch:1.34.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.34
	kettenis_i386newframe-20030504-mergepoint:1.34
	carlton_dictionary-20030430-merge:1.34
	kettenis_i386newframe-20030419-branch:1.34.0.20
	kettenis_i386newframe-20030419-branchpoint:1.34
	carlton_dictionary-20030416-merge:1.34
	cagney_frameaddr-20030409-mergepoint:1.34
	kettenis_i386newframe-20030406-branch:1.34.0.18
	kettenis_i386newframe-20030406-branchpoint:1.34
	cagney_frameaddr-20030403-branchpoint:1.34
	cagney_frameaddr-20030403-branch:1.34.0.16
	cagney_framebase-20030330-mergepoint:1.34
	cagney_framebase-20030326-branch:1.34.0.14
	cagney_framebase-20030326-branchpoint:1.34
	cagney_lazyid-20030317-branch:1.34.0.12
	cagney_lazyid-20030317-branchpoint:1.34
	kettenis-i386newframe-20030316-mergepoint:1.34
	offbyone-20030313-branch:1.34.0.10
	offbyone-20030313-branchpoint:1.34
	kettenis-i386newframe-20030308-branch:1.34.0.8
	kettenis-i386newframe-20030308-branchpoint:1.34
	carlton_dictionary-20030305-merge:1.34
	cagney_offbyone-20030303-branch:1.34.0.6
	cagney_offbyone-20030303-branchpoint:1.34
	carlton_dictionary-20030207-merge:1.34
	interps-20030203-mergepoint:1.34
	interps-20030202-branch:1.34.0.4
	interps-20030202-branchpoint:1.34
	cagney-unwind-20030108-branch:1.34.0.2
	cagney-unwind-20030108-branchpoint:1.34
	carlton_dictionary-20021223-merge:1.34
	gdb_5_3-2002-12-12-release:1.33
	carlton_dictionary-20021115-merge:1.34
	kseitz_interps-20021105-merge:1.33
	kseitz_interps-20021103-merge:1.33
	drow-cplus-merge-20021020:1.33
	drow-cplus-merge-20021025:1.33
	carlton_dictionary-20021025-merge:1.33
	carlton_dictionary-20021011-merge:1.33
	drow-cplus-branch:1.33.0.14
	drow-cplus-branchpoint:1.33
	kseitz_interps-20020930-merge:1.33
	carlton_dictionary-20020927-merge:1.33
	carlton_dictionary-branch:1.33.0.12
	carlton_dictionary-20020920-branchpoint:1.33
	gdb_5_3-branch:1.33.0.10
	gdb_5_3-2002-09-04-branchpoint:1.33
	kseitz_interps-20020829-merge:1.33
	cagney_sysregs-20020825-branch:1.33.0.8
	cagney_sysregs-20020825-branchpoint:1.33
	readline_4_3-import-branch:1.33.0.6
	readline_4_3-import-branchpoint:1.33
	gdb_5_2_1-2002-07-23-release:1.30.2.1
	kseitz_interps-20020528-branch:1.33.0.4
	kseitz_interps-20020528-branchpoint:1.33
	cagney_regbuf-20020515-branch:1.33.0.2
	cagney_regbuf-20020515-branchpoint:1.33
	jimb-macro-020506-branch:1.32.0.2
	jimb-macro-020506-branchpoint:1.32
	gdb_5_2-2002-04-29-release:1.30.2.1
	gdb_5_2-branch:1.30.0.2
	gdb_5_2-2002-03-03-branchpoint:1.30
	gdb_5_1_1-2002-01-24-release:1.20.2.4
	gdb_5_1_0_1-2002-01-03-release:1.20.2.3
	cygnus_cvs_20020108_pre:1.26
	gdb_5_1_0_1-2002-01-03-branchpoint:1.20.2.3
	gdb_5_1_0_1-2002-01-03-branch:1.20.2.3.0.4
	gdb_5_1-2001-11-21-release:1.20.2.3
	gdb_s390-2001-09-26-branch:1.20.2.3.0.2
	gdb_s390-2001-09-26-branchpoint:1.20.2.3
	gdb_5_1-2001-07-29-branch:1.20.0.2
	gdb_5_1-2001-07-29-branchpoint:1.20
	dberlin-typesystem-branch:1.15.0.2
	dberlin-typesystem-branchpoint:1.15
	gdb-post-ptid_t-2001-05-03:1.14
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.5
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.4.2.1
	gdb_4_18_2-2000-05-18-release:1.4.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.4.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.4.2.1
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.10
	gdb-2000-02-01:1.1.1.10
	gdb-2000-01-31:1.1.1.10
	gdb-2000-01-26:1.1.1.10
	gdb-2000-01-24:1.1.1.10
	gdb-2000-01-17:1.1.1.10
	gdb-2000-01-10:1.1.1.10
	gdb-2000-01-05:1.1.1.10
	gdb-1999-12-21:1.1.1.10
	gdb-1999-12-13:1.1.1.10
	gdb-1999-12-07:1.1.1.10
	gdb-1999-12-06:1.1.1.10
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.8
	gdb-1999-11-01:1.1.1.8
	gdb-1999-10-25:1.1.1.8
	gdb-1999-10-18:1.1.1.8
	gdb-1999-10-11:1.1.1.8
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.4
	gdb-1999-08-09:1.1.1.4
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.2
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.96
date	2013.07.01.11.24.16;	author palves;	state Exp;
branches;
next	1.95;

1.95
date	2013.06.19.22.29.36;	author vapier;	state Exp;
branches;
next	1.94;

1.94
date	2013.05.14.20.32.15;	author tromey;	state Exp;
branches;
next	1.93;

1.93
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.92;

1.92
date	2013.03.07.21.57.29;	author kseitz;	state Exp;
branches;
next	1.91;

1.91
date	2013.01.01.06.32.44;	author brobecke;	state Exp;
branches;
next	1.90;

1.90
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.89;

1.89
date	2012.11.07.20.10.13;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2012.07.31.06.16.09;	author qiyao;	state Exp;
branches;
next	1.87;

1.87
date	2012.05.24.16.51.34;	author palves;	state Exp;
branches;
next	1.86;

1.86
date	2012.05.24.16.39.08;	author palves;	state Exp;
branches;
next	1.85;

1.85
date	2012.01.04.08.17.03;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2011.12.14.17.20.30;	author palves;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.07.19.36.19;	author msnyder;	state Exp;
branches
	1.83.4.1;
next	1.82;

1.82
date	2011.01.01.15.33.05;	author brobecke;	state Exp;
branches;
next	1.81;

1.81
date	2010.04.05.22.18.53;	author muller;	state Exp;
branches;
next	1.80;

1.80
date	2010.01.01.07.31.32;	author brobecke;	state Exp;
branches;
next	1.79;

1.79
date	2009.10.20.16.34.00;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2009.10.19.09.51.41;	author palves;	state Exp;
branches;
next	1.77;

1.77
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.76;

1.76
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.75;

1.75
date	2009.05.14.09.36.59;	author muller;	state Exp;
branches;
next	1.74;

1.74
date	2009.05.04.09.54.17;	author palves;	state Exp;
branches;
next	1.73;

1.73
date	2009.05.01.17.45.43;	author eliz;	state Exp;
branches;
next	1.72;

1.72
date	2009.05.01.08.14.00;	author eliz;	state Exp;
branches;
next	1.71;

1.71
date	2009.04.19.18.29.33;	author eliz;	state Exp;
branches;
next	1.70;

1.70
date	2009.04.18.08.16.34;	author eliz;	state Exp;
branches;
next	1.69;

1.69
date	2009.04.17.11.59.35;	author eliz;	state Exp;
branches;
next	1.68;

1.68
date	2009.04.11.17.57.34;	author eliz;	state Exp;
branches;
next	1.67;

1.67
date	2009.03.17.19.28.08;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2009.03.16.19.00.27;	author brobecke;	state Exp;
branches;
next	1.65;

1.65
date	2009.02.23.00.03.49;	author palves;	state Exp;
branches;
next	1.64;

1.64
date	2009.02.20.10.52.23;	author muller;	state Exp;
branches;
next	1.63;

1.63
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.62;

1.62
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.09.11.27.17;	author vprus;	state Exp;
branches;
next	1.60;

1.60
date	2008.09.22.15.16.51;	author palves;	state Exp;
branches;
next	1.59;

1.59
date	2008.08.09.21.26.22;	author palves;	state Exp;
branches;
next	1.58;

1.58
date	2008.08.09.21.25.00;	author palves;	state Exp;
branches;
next	1.57;

1.57
date	2008.07.09.22.49.56;	author palves;	state Exp;
branches;
next	1.56;

1.56
date	2008.01.01.22.53.10;	author drow;	state Exp;
branches;
next	1.55;

1.55
date	2007.10.30.21.54.06;	author uweigand;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.23.18.08.33;	author brobecke;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2007.05.06.14.34.37;	author uweigand;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.06.14.28.27;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2005.12.17.22.34.00;	author eliz;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.12.21.23.17;	author eliz;	state Exp;
branches
	1.46.4.1
	1.46.8.1;
next	1.45;

1.45
date	2005.02.15.15.49.10;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.14.18.10.08;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.11.18.13.50;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.11.04.05.50;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2004.10.08.20.29.47;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2004.07.24.01.00.19;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2004.07.22.01.31.48;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.25.14.58.26;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.29.07.42.43;	author eliz;	state Exp;
branches
	1.37.6.1;
next	1.36;

1.36
date	2003.09.28.13.35.44;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.23.08.56.45;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.08.16.52.37;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.11.17.22.26;	author thorpej;	state Exp;
branches
	1.33.12.1
	1.33.14.1;
next	1.32;

1.32
date	2002.04.19.19.28.48;	author eliz;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.27.21.35.35;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.28.16.49.10;	author eliz;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2002.02.19.10.54.26;	author muller;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.21.23.03.13;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.13.09.51.22;	author eliz;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.06.08.15.37;	author muller;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.25.11.29.31;	author eliz;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.15.06.43.10;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.24.05.00.05;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.02.11.58.29;	author eliz;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.29.08.06.28;	author eliz;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.26.14.41.16;	author eliz;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.07.23.16.10.24;	author eliz;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.15.10.28.12;	author eliz;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.11.10.11.31;	author eliz;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.08.10.28.20;	author eliz;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.04.07.29.00;	author eliz;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.04.04.15.24;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.01.14.01.52;	author eliz;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.26.11.26.45;	author eliz;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.22.09.35.19;	author eliz;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.18.07.22.16;	author eliz;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.04.07.24.57;	author eliz;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.06.07.19.38;	author eliz;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.12.17.04.42;	author eliz;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.03.15.27.42;	author eliz;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.03.13.15.59.02;	author eliz;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.45;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.27.01.24.18;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.83.4.1
date	2012.01.06.04.43.15;	author brobecke;	state Exp;
branches;
next	;

1.46.4.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.46.8.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.37.6.1
date	2004.09.16.17.01.07;	author drow;	state Exp;
branches;
next	;

1.33.12.1
date	2002.11.15.19.18.44;	author carlton;	state Exp;
branches;
next	1.33.12.2;

1.33.12.2
date	2003.09.17.21.28.20;	author carlton;	state Exp;
branches;
next	1.33.12.3;

1.33.12.3
date	2003.11.11.23.50.44;	author carlton;	state Exp;
branches;
next	1.33.12.4;

1.33.12.4
date	2004.01.26.19.11.24;	author carlton;	state Exp;
branches;
next	;

1.33.14.1
date	2003.12.14.20.27.16;	author drow;	state Exp;
branches;
next	1.33.14.2;

1.33.14.2
date	2004.01.13.16.11.56;	author drow;	state Exp;
branches;
next	;

1.30.2.1
date	2002.04.19.19.13.45;	author eliz;	state Exp;
branches;
next	;

1.20.2.1
date	2001.07.29.08.21.32;	author eliz;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.08.02.12.05.57;	author eliz;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.08.24.04.56.51;	author cagney;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2002.01.13.09.53.19;	author eliz;	state Exp;
branches;
next	;

1.4.2.1
date	2000.04.12.17.06.18;	author eliz;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.27.01.24.18;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.05.05.14.42.30;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.06.07.19.17.28;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.06.33;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.23.22.35.03;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.31.01.05.04;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.22.03.24.33;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.05.23.08.17;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.11.17.02.30.24;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	99.12.07.03.56.01;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.96
log
@Reimplement DJGPP's .gdbinit -> gdb.ini renaming.

This simplifies the .gdbinit filename selection logic.

We have a GDBINIT_FILENAME define that supposedly configurations would
override, but none do so.  Instead, the only configuration that wants
a different file name instead of ".gdbinit", djgpp, does a strcpy over
the gdbinit global array.  This means the array needs to be sized, and
the code that does that is doing the usual
'PATH_MAX/FILENAME_MAX/fallback constant/etc.' mess.

Instead of all that, it's much simpler to have configure specificy the
.gdbinit filename.  As bonus, we can then make the "gdbinit" global
array const.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* configure.ac (GDBINIT): Define, depending on host.
	* go32-nat.c (init_go32_ops): Don't override gdbinit here.
	* top.c (PATH_MAX): Delete fallback definition.
	(GDBINIT_FILENAME): Delete.
	(gdbinit): Reimplement as const char array set to the GDBINIT
	string constant.
	* top.h (gdbinit): Make const.
@
text
@/* Native debugging support for Intel x86 running DJGPP.
   Copyright (C) 1997-2013 Free Software Foundation, Inc.
   Written by Robert Hoehne.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* To whomever it may concern, here's a general description of how
   debugging in DJGPP works, and the special quirks GDB does to
   support that.

   When the DJGPP port of GDB is debugging a DJGPP program natively,
   there aren't 2 separate processes, the debuggee and GDB itself, as
   on other systems.  (This is DOS, where there can only be one active
   process at any given time, remember?)  Instead, GDB and the
   debuggee live in the same process.  So when GDB calls
   go32_create_inferior below, and that function calls edi_init from
   the DJGPP debug support library libdbg.a, we load the debuggee's
   executable file into GDB's address space, set it up for execution
   as the stub loader (a short real-mode program prepended to each
   DJGPP executable) normally would, and do a lot of preparations for
   swapping between GDB's and debuggee's internal state, primarily wrt
   the exception handlers.  This swapping happens every time we resume
   the debuggee or switch back to GDB's code, and it includes:

    . swapping all the segment registers
    . swapping the PSP (the Program Segment Prefix)
    . swapping the signal handlers
    . swapping the exception handlers
    . swapping the FPU status
    . swapping the 3 standard file handles (more about this below)

   Then running the debuggee simply means longjmp into it where its PC
   is and let it run until it stops for some reason.  When it stops,
   GDB catches the exception that stopped it and longjmp's back into
   its own code.  All the possible exit points of the debuggee are
   watched; for example, the normal exit point is recognized because a
   DOS program issues a special system call to exit.  If one of those
   exit points is hit, we mourn the inferior and clean up after it.
   Cleaning up is very important, even if the process exits normally,
   because otherwise we might leave behind traces of previous
   execution, and in several cases GDB itself might be left hosed,
   because all the exception handlers were not restored.

   Swapping of the standard handles (in redir_to_child and
   redir_to_debugger) is needed because, since both GDB and the
   debuggee live in the same process, as far as the OS is concerned,
   the share the same file table.  This means that the standard
   handles 0, 1, and 2 point to the same file table entries, and thus
   are connected to the same devices.  Therefore, if the debugger
   redirects its standard output, the standard output of the debuggee
   is also automagically redirected to the same file/device!
   Similarly, if the debuggee redirects its stdout to a file, you
   won't be able to see debugger's output (it will go to the same file
   where the debuggee has its output); and if the debuggee closes its
   standard input, you will lose the ability to talk to debugger!

   For this reason, every time the debuggee is about to be resumed, we
   call redir_to_child, which redirects the standard handles to where
   the debuggee expects them to be.  When the debuggee stops and GDB
   regains control, we call redir_to_debugger, which redirects those 3
   handles back to where GDB expects.

   Note that only the first 3 handles are swapped, so if the debuggee
   redirects or closes any other handles, GDB will not notice.  In
   particular, the exit code of a DJGPP program forcibly closes all
   file handles beyond the first 3 ones, so when the debuggee exits,
   GDB currently loses its stdaux and stdprn streams.  Fortunately,
   GDB does not use those as of this writing, and will never need
   to.  */

#include "defs.h"

#include <fcntl.h>

#include "i386-nat.h"
#include "inferior.h"
#include "gdbthread.h"
#include "gdb_wait.h"
#include "gdbcore.h"
#include "command.h"
#include "gdbcmd.h"
#include "floatformat.h"
#include "buildsym.h"
#include "i387-tdep.h"
#include "i386-tdep.h"
#include "i386-cpuid.h"
#include "value.h"
#include "regcache.h"
#include "gdb_string.h"
#include "top.h"
#include "cli/cli-utils.h"

#include <stdio.h>		/* might be required for __DJGPP_MINOR__ */
#include <stdlib.h>
#include <ctype.h>
#include <errno.h>
#include <unistd.h>
#include <sys/utsname.h>
#include <io.h>
#include <dos.h>
#include <dpmi.h>
#include <go32.h>
#include <sys/farptr.h>
#include <debug/v2load.h>
#include <debug/dbgcom.h>
#if __DJGPP_MINOR__ > 2
#include <debug/redir.h>
#endif

#include <langinfo.h>

#if __DJGPP_MINOR__ < 3
/* This code will be provided from DJGPP 2.03 on.  Until then I code it
   here.  */
typedef struct
  {
    unsigned short sig0;
    unsigned short sig1;
    unsigned short sig2;
    unsigned short sig3;
    unsigned short exponent:15;
    unsigned short sign:1;
  }
NPXREG;

typedef struct
  {
    unsigned int control;
    unsigned int status;
    unsigned int tag;
    unsigned int eip;
    unsigned int cs;
    unsigned int dataptr;
    unsigned int datasel;
    NPXREG reg[8];
  }
NPX;

static NPX npx;

static void save_npx (void);	/* Save the FPU of the debugged program.  */
static void load_npx (void);	/* Restore the FPU of the debugged program.  */

/* ------------------------------------------------------------------------- */
/* Store the contents of the NPX in the global variable `npx'.  */
/* *INDENT-OFF* */

static void
save_npx (void)
{
  asm ("inb    $0xa0, %%al  \n\
       testb $0x20, %%al    \n\
       jz 1f 	    	    \n\
       xorb %%al, %%al	    \n\
       outb %%al, $0xf0     \n\
       movb $0x20, %%al	    \n\
       outb %%al, $0xa0     \n\
       outb %%al, $0x20     \n\
1:     	       	   	    \n\
       fnsave %0	    \n\
       fwait "
:     "=m" (npx)
:				/* No input */
:     "%eax");
}

/* *INDENT-ON* */


/* ------------------------------------------------------------------------- */
/* Reload the contents of the NPX from the global variable `npx'.  */

static void
load_npx (void)
{
  asm ("frstor %0":"=m" (npx));
}
/* ------------------------------------------------------------------------- */
/* Stubs for the missing redirection functions.  */
typedef struct {
  char *command;
  int redirected;
} cmdline_t;

void
redir_cmdline_delete (cmdline_t *ptr)
{
  ptr->redirected = 0;
}

int
redir_cmdline_parse (const char *args, cmdline_t *ptr)
{
  return -1;
}

int
redir_to_child (cmdline_t *ptr)
{
  return 1;
}

int
redir_to_debugger (cmdline_t *ptr)
{
  return 1;
}

int
redir_debug_init (cmdline_t *ptr)
{
  return 0;
}
#endif /* __DJGPP_MINOR < 3 */

typedef enum { wp_insert, wp_remove, wp_count } wp_op;

/* This holds the current reference counts for each debug register.  */
static int dr_ref_count[4];

#define SOME_PID 42

static int prog_has_started = 0;
static void go32_open (char *name, int from_tty);
static void go32_close (void);
static void go32_attach (struct target_ops *ops, char *args, int from_tty);
static void go32_detach (struct target_ops *ops, char *args, int from_tty);
static void go32_resume (struct target_ops *ops,
			 ptid_t ptid, int step,
			 enum gdb_signal siggnal);
static void go32_fetch_registers (struct target_ops *ops,
				  struct regcache *, int regno);
static void store_register (const struct regcache *, int regno);
static void go32_store_registers (struct target_ops *ops,
				  struct regcache *, int regno);
static void go32_prepare_to_store (struct regcache *);
static int go32_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len,
			     int write,
			     struct mem_attrib *attrib,
			     struct target_ops *target);
static void go32_files_info (struct target_ops *target);
static void go32_kill_inferior (struct target_ops *ops);
static void go32_create_inferior (struct target_ops *ops, char *exec_file,
				  char *args, char **env, int from_tty);
static void go32_mourn_inferior (struct target_ops *ops);
static int go32_can_run (void);

static struct target_ops go32_ops;
static void go32_terminal_init (void);
static void go32_terminal_inferior (void);
static void go32_terminal_ours (void);

#define r_ofs(x) (offsetof(TSS,x))

static struct
{
  size_t tss_ofs;
  size_t size;
}
regno_mapping[] =
{
  {r_ofs (tss_eax), 4},	/* normal registers, from a_tss */
  {r_ofs (tss_ecx), 4},
  {r_ofs (tss_edx), 4},
  {r_ofs (tss_ebx), 4},
  {r_ofs (tss_esp), 4},
  {r_ofs (tss_ebp), 4},
  {r_ofs (tss_esi), 4},
  {r_ofs (tss_edi), 4},
  {r_ofs (tss_eip), 4},
  {r_ofs (tss_eflags), 4},
  {r_ofs (tss_cs), 2},
  {r_ofs (tss_ss), 2},
  {r_ofs (tss_ds), 2},
  {r_ofs (tss_es), 2},
  {r_ofs (tss_fs), 2},
  {r_ofs (tss_gs), 2},
  {0, 10},		/* 8 FP registers, from npx.reg[] */
  {1, 10},
  {2, 10},
  {3, 10},
  {4, 10},
  {5, 10},
  {6, 10},
  {7, 10},
	/* The order of the next 7 registers must be consistent
	   with their numbering in config/i386/tm-i386.h, which see.  */
  {0, 2},		/* control word, from npx */
  {4, 2},		/* status word, from npx */
  {8, 2},		/* tag word, from npx */
  {16, 2},		/* last FP exception CS from npx */
  {12, 4},		/* last FP exception EIP from npx */
  {24, 2},		/* last FP exception operand selector from npx */
  {20, 4},		/* last FP exception operand offset from npx */
  {18, 2}		/* last FP opcode from npx */
};

static struct
  {
    int go32_sig;
    enum gdb_signal gdb_sig;
  }
sig_map[] =
{
  {0, GDB_SIGNAL_FPE},
  {1, GDB_SIGNAL_TRAP},
  /* Exception 2 is triggered by the NMI.  DJGPP handles it as SIGILL,
     but I think SIGBUS is better, since the NMI is usually activated
     as a result of a memory parity check failure.  */
  {2, GDB_SIGNAL_BUS},
  {3, GDB_SIGNAL_TRAP},
  {4, GDB_SIGNAL_FPE},
  {5, GDB_SIGNAL_SEGV},
  {6, GDB_SIGNAL_ILL},
  {7, GDB_SIGNAL_EMT},	/* no-coprocessor exception */
  {8, GDB_SIGNAL_SEGV},
  {9, GDB_SIGNAL_SEGV},
  {10, GDB_SIGNAL_BUS},
  {11, GDB_SIGNAL_SEGV},
  {12, GDB_SIGNAL_SEGV},
  {13, GDB_SIGNAL_SEGV},
  {14, GDB_SIGNAL_SEGV},
  {16, GDB_SIGNAL_FPE},
  {17, GDB_SIGNAL_BUS},
  {31, GDB_SIGNAL_ILL},
  {0x1b, GDB_SIGNAL_INT},
  {0x75, GDB_SIGNAL_FPE},
  {0x78, GDB_SIGNAL_ALRM},
  {0x79, GDB_SIGNAL_INT},
  {0x7a, GDB_SIGNAL_QUIT},
  {-1, GDB_SIGNAL_LAST}
};

static struct {
  enum gdb_signal gdb_sig;
  int djgpp_excepno;
} excepn_map[] = {
  {GDB_SIGNAL_0, -1},
  {GDB_SIGNAL_ILL, 6},	/* Invalid Opcode */
  {GDB_SIGNAL_EMT, 7},	/* triggers SIGNOFP */
  {GDB_SIGNAL_SEGV, 13},	/* GPF */
  {GDB_SIGNAL_BUS, 17},	/* Alignment Check */
  /* The rest are fake exceptions, see dpmiexcp.c in djlsr*.zip for
     details.  */
  {GDB_SIGNAL_TERM, 0x1b},	/* triggers Ctrl-Break type of SIGINT */
  {GDB_SIGNAL_FPE, 0x75},
  {GDB_SIGNAL_INT, 0x79},
  {GDB_SIGNAL_QUIT, 0x7a},
  {GDB_SIGNAL_ALRM, 0x78},	/* triggers SIGTIMR */
  {GDB_SIGNAL_PROF, 0x78},
  {GDB_SIGNAL_LAST, -1}
};

static void
go32_open (char *name, int from_tty)
{
  printf_unfiltered ("Done.  Use the \"run\" command to run the program.\n");
}

static void
go32_close (void)
{
}

static void
go32_attach (struct target_ops *ops, char *args, int from_tty)
{
  error (_("\
You cannot attach to a running program on this platform.\n\
Use the `run' command to run DJGPP programs."));
}

static void
go32_detach (struct target_ops *ops, char *args, int from_tty)
{
}

static int resume_is_step;
static int resume_signal = -1;

static void
go32_resume (struct target_ops *ops,
	     ptid_t ptid, int step, enum gdb_signal siggnal)
{
  int i;

  resume_is_step = step;

  if (siggnal != GDB_SIGNAL_0 && siggnal != GDB_SIGNAL_TRAP)
  {
    for (i = 0, resume_signal = -1;
	 excepn_map[i].gdb_sig != GDB_SIGNAL_LAST; i++)
      if (excepn_map[i].gdb_sig == siggnal)
      {
	resume_signal = excepn_map[i].djgpp_excepno;
	break;
      }
    if (resume_signal == -1)
      printf_unfiltered ("Cannot deliver signal %s on this platform.\n",
			 gdb_signal_to_name (siggnal));
  }
}

static char child_cwd[FILENAME_MAX];

static ptid_t
go32_wait (struct target_ops *ops,
	   ptid_t ptid, struct target_waitstatus *status, int options)
{
  int i;
  unsigned char saved_opcode;
  unsigned long INT3_addr = 0;
  int stepping_over_INT = 0;

  a_tss.tss_eflags &= 0xfeff;	/* Reset the single-step flag (TF).  */
  if (resume_is_step)
    {
      /* If the next instruction is INT xx or INTO, we need to handle
	 them specially.  Intel manuals say that these instructions
	 reset the single-step flag (a.k.a. TF).  However, it seems
	 that, at least in the DPMI environment, and at least when
	 stepping over the DPMI interrupt 31h, the problem is having
	 TF set at all when INT 31h is executed: the debuggee either
	 crashes (and takes the system with it) or is killed by a
	 SIGTRAP.

	 So we need to emulate single-step mode: we put an INT3 opcode
	 right after the INT xx instruction, let the debuggee run
	 until it hits INT3 and stops, then restore the original
	 instruction which we overwrote with the INT3 opcode, and back
	 up the debuggee's EIP to that instruction.  */
      read_child (a_tss.tss_eip, &saved_opcode, 1);
      if (saved_opcode == 0xCD || saved_opcode == 0xCE)
	{
	  unsigned char INT3_opcode = 0xCC;

	  INT3_addr
	    = saved_opcode == 0xCD ? a_tss.tss_eip + 2 : a_tss.tss_eip + 1;
	  stepping_over_INT = 1;
	  read_child (INT3_addr, &saved_opcode, 1);
	  write_child (INT3_addr, &INT3_opcode, 1);
	}
      else
	a_tss.tss_eflags |= 0x0100; /* normal instruction: set TF */
    }

  /* The special value FFFFh in tss_trap indicates to run_child that
     tss_irqn holds a signal to be delivered to the debuggee.  */
  if (resume_signal <= -1)
    {
      a_tss.tss_trap = 0;
      a_tss.tss_irqn = 0xff;
    }
  else
    {
      a_tss.tss_trap = 0xffff;	/* run_child looks for this.  */
      a_tss.tss_irqn = resume_signal;
    }

  /* The child might change working directory behind our back.  The
     GDB users won't like the side effects of that when they work with
     relative file names, and GDB might be confused by its current
     directory not being in sync with the truth.  So we always make a
     point of changing back to where GDB thinks is its cwd, when we
     return control to the debugger, but restore child's cwd before we
     run it.  */
  /* Initialize child_cwd, before the first call to run_child and not
     in the initialization, so the child get also the changed directory
     set with the gdb-command "cd ..."  */
  if (!*child_cwd)
    /* Initialize child's cwd with the current one.  */
    getcwd (child_cwd, sizeof (child_cwd));

  chdir (child_cwd);

#if __DJGPP_MINOR__ < 3
  load_npx ();
#endif
  run_child ();
#if __DJGPP_MINOR__ < 3
  save_npx ();
#endif

  /* Did we step over an INT xx instruction?  */
  if (stepping_over_INT && a_tss.tss_eip == INT3_addr + 1)
    {
      /* Restore the original opcode.  */
      a_tss.tss_eip--;	/* EIP points *after* the INT3 instruction.  */
      write_child (a_tss.tss_eip, &saved_opcode, 1);
      /* Simulate a TRAP exception.  */
      a_tss.tss_irqn = 1;
      a_tss.tss_eflags |= 0x0100;
    }

  getcwd (child_cwd, sizeof (child_cwd)); /* in case it has changed */
  chdir (current_directory);

  if (a_tss.tss_irqn == 0x21)
    {
      status->kind = TARGET_WAITKIND_EXITED;
      status->value.integer = a_tss.tss_eax & 0xff;
    }
  else
    {
      status->value.sig = GDB_SIGNAL_UNKNOWN;
      status->kind = TARGET_WAITKIND_STOPPED;
      for (i = 0; sig_map[i].go32_sig != -1; i++)
	{
	  if (a_tss.tss_irqn == sig_map[i].go32_sig)
	    {
#if __DJGPP_MINOR__ < 3
	      if ((status->value.sig = sig_map[i].gdb_sig) !=
		  GDB_SIGNAL_TRAP)
		status->kind = TARGET_WAITKIND_SIGNALLED;
#else
	      status->value.sig = sig_map[i].gdb_sig;
#endif
	      break;
	    }
	}
    }
  return pid_to_ptid (SOME_PID);
}

static void
fetch_register (struct regcache *regcache, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  if (regno < gdbarch_fp0_regnum (gdbarch))
    regcache_raw_supply (regcache, regno,
			 (char *) &a_tss + regno_mapping[regno].tss_ofs);
  else if (i386_fp_regnum_p (gdbarch, regno) || i386_fpc_regnum_p (gdbarch,
								   regno))
    i387_supply_fsave (regcache, regno, &npx);
  else
    internal_error (__FILE__, __LINE__,
		    _("Invalid register no. %d in fetch_register."), regno);
}

static void
go32_fetch_registers (struct target_ops *ops,
		      struct regcache *regcache, int regno)
{
  if (regno >= 0)
    fetch_register (regcache, regno);
  else
    {
      for (regno = 0;
	   regno < gdbarch_fp0_regnum (get_regcache_arch (regcache));
	   regno++)
	fetch_register (regcache, regno);
      i387_supply_fsave (regcache, -1, &npx);
    }
}

static void
store_register (const struct regcache *regcache, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  if (regno < gdbarch_fp0_regnum (gdbarch))
    regcache_raw_collect (regcache, regno,
			  (char *) &a_tss + regno_mapping[regno].tss_ofs);
  else if (i386_fp_regnum_p (gdbarch, regno) || i386_fpc_regnum_p (gdbarch,
								   regno))
    i387_collect_fsave (regcache, regno, &npx);
  else
    internal_error (__FILE__, __LINE__,
		    _("Invalid register no. %d in store_register."), regno);
}

static void
go32_store_registers (struct target_ops *ops,
		      struct regcache *regcache, int regno)
{
  unsigned r;

  if (regno >= 0)
    store_register (regcache, regno);
  else
    {
      for (r = 0; r < gdbarch_fp0_regnum (get_regcache_arch (regcache)); r++)
	store_register (regcache, r);
      i387_collect_fsave (regcache, -1, &npx);
    }
}

static void
go32_prepare_to_store (struct regcache *regcache)
{
}

static int
go32_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
		  struct mem_attrib *attrib, struct target_ops *target)
{
  if (write)
    {
      if (write_child (memaddr, myaddr, len))
	{
	  return 0;
	}
      else
	{
	  return len;
	}
    }
  else
    {
      if (read_child (memaddr, myaddr, len))
	{
	  return 0;
	}
      else
	{
	  return len;
	}
    }
}

static cmdline_t child_cmd;	/* Parsed child's command line kept here.  */

static void
go32_files_info (struct target_ops *target)
{
  printf_unfiltered ("You are running a DJGPP V2 program.\n");
}

static void
go32_kill_inferior (struct target_ops *ops)
{
  go32_mourn_inferior (ops);
}

static void
go32_create_inferior (struct target_ops *ops, char *exec_file,
		      char *args, char **env, int from_tty)
{
  extern char **environ;
  jmp_buf start_state;
  char *cmdline;
  char **env_save = environ;
  size_t cmdlen;
  struct inferior *inf;

  /* If no exec file handed to us, get it from the exec-file command -- with
     a good, common error message if none is specified.  */
  if (exec_file == 0)
    exec_file = get_exec_file (1);

  resume_signal = -1;
  resume_is_step = 0;

  /* Initialize child's cwd as empty to be initialized when starting
     the child.  */
  *child_cwd = 0;

  /* Init command line storage.  */
  if (redir_debug_init (&child_cmd) == -1)
    internal_error (__FILE__, __LINE__,
		    _("Cannot allocate redirection storage: "
		      "not enough memory.\n"));

  /* Parse the command line and create redirections.  */
  if (strpbrk (args, "<>"))
    {
      if (redir_cmdline_parse (args, &child_cmd) == 0)
	args = child_cmd.command;
      else
	error (_("Syntax error in command line."));
    }
  else
    child_cmd.command = xstrdup (args);

  cmdlen = strlen (args);
  /* v2loadimage passes command lines via DOS memory, so it cannot
     possibly handle commands longer than 1MB.  */
  if (cmdlen > 1024*1024)
    error (_("Command line too long."));

  cmdline = xmalloc (cmdlen + 4);
  strcpy (cmdline + 1, args);
  /* If the command-line length fits into DOS 126-char limits, use the
     DOS command tail format; otherwise, tell v2loadimage to pass it
     through a buffer in conventional memory.  */
  if (cmdlen < 127)
    {
      cmdline[0] = strlen (args);
      cmdline[cmdlen + 1] = 13;
    }
  else
    cmdline[0] = 0xff;	/* Signal v2loadimage it's a long command.  */

  environ = env;

  if (v2loadimage (exec_file, cmdline, start_state))
    {
      environ = env_save;
      printf_unfiltered ("Load failed for image %s\n", exec_file);
      exit (1);
    }
  environ = env_save;
  xfree (cmdline);

  edi_init (start_state);
#if __DJGPP_MINOR__ < 3
  save_npx ();
#endif

  inferior_ptid = pid_to_ptid (SOME_PID);
  inf = current_inferior ();
  inferior_appeared (inf, SOME_PID);

  push_target (&go32_ops);

  add_thread_silent (inferior_ptid);

  clear_proceed_status ();
  insert_breakpoints ();
  prog_has_started = 1;
}

static void
go32_mourn_inferior (struct target_ops *ops)
{
  ptid_t ptid;

  redir_cmdline_delete (&child_cmd);
  resume_signal = -1;
  resume_is_step = 0;

  cleanup_client ();

  /* We need to make sure all the breakpoint enable bits in the DR7
     register are reset when the inferior exits.  Otherwise, if they
     rerun the inferior, the uncleared bits may cause random SIGTRAPs,
     failure to set more watchpoints, and other calamities.  It would
     be nice if GDB itself would take care to remove all breakpoints
     at all times, but it doesn't, probably under an assumption that
     the OS cleans up when the debuggee exits.  */
  i386_cleanup_dregs ();

  ptid = inferior_ptid;
  inferior_ptid = null_ptid;
  delete_thread_silent (ptid);
  prog_has_started = 0;

  unpush_target (ops);
  generic_mourn_inferior ();
}

static int
go32_can_run (void)
{
  return 1;
}

/* Hardware watchpoint support.  */

#define D_REGS edi.dr
#define CONTROL D_REGS[7]
#define STATUS D_REGS[6]

/* Pass the address ADDR to the inferior in the I'th debug register.
   Here we just store the address in D_REGS, the watchpoint will be
   actually set up when go32_wait runs the debuggee.  */
static void
go32_set_dr (int i, CORE_ADDR addr)
{
  if (i < 0 || i > 3)
    internal_error (__FILE__, __LINE__, 
		    _("Invalid register %d in go32_set_dr.\n"), i);
  D_REGS[i] = addr;
}

/* Pass the value VAL to the inferior in the DR7 debug control
   register.  Here we just store the address in D_REGS, the watchpoint
   will be actually set up when go32_wait runs the debuggee.  */
static void
go32_set_dr7 (unsigned long val)
{
  CONTROL = val;
}

/* Get the value of the DR6 debug status register from the inferior.
   Here we just return the value stored in D_REGS, as we've got it
   from the last go32_wait call.  */
static unsigned long
go32_get_dr6 (void)
{
  return STATUS;
}

/* Get the value of the DR7 debug status register from the inferior.
   Here we just return the value stored in D_REGS, as we've got it
   from the last go32_wait call.  */

static unsigned long
go32_get_dr7 (void)
{
  return CONTROL;
}

/* Get the value of the DR debug register I from the inferior.  Here
   we just return the value stored in D_REGS, as we've got it from the
   last go32_wait call.  */

static CORE_ADDR
go32_get_dr (int i)
{
  if (i < 0 || i > 3)
    internal_error (__FILE__, __LINE__,
		    _("Invalid register %d in go32_get_dr.\n"), i);
  return D_REGS[i];
}

/* Put the device open on handle FD into either raw or cooked
   mode, return 1 if it was in raw mode, zero otherwise.  */

static int
device_mode (int fd, int raw_p)
{
  int oldmode, newmode;
  __dpmi_regs regs;

  regs.x.ax = 0x4400;
  regs.x.bx = fd;
  __dpmi_int (0x21, &regs);
  if (regs.x.flags & 1)
    return -1;
  newmode = oldmode = regs.x.dx;

  if (raw_p)
    newmode |= 0x20;
  else
    newmode &= ~0x20;

  if (oldmode & 0x80)	/* Only for character dev.  */
  {
    regs.x.ax = 0x4401;
    regs.x.bx = fd;
    regs.x.dx = newmode & 0xff;   /* Force upper byte zero, else it fails.  */
    __dpmi_int (0x21, &regs);
    if (regs.x.flags & 1)
      return -1;
  }
  return (oldmode & 0x20) == 0x20;
}


static int inf_mode_valid = 0;
static int inf_terminal_mode;

/* This semaphore is needed because, amazingly enough, GDB calls
   target.to_terminal_ours more than once after the inferior stops.
   But we need the information from the first call only, since the
   second call will always see GDB's own cooked terminal.  */
static int terminal_is_ours = 1;

static void
go32_terminal_init (void)
{
  inf_mode_valid = 0;	/* Reinitialize, in case they are restarting child.  */
  terminal_is_ours = 1;
}

static void
go32_terminal_info (const char *args, int from_tty)
{
  printf_unfiltered ("Inferior's terminal is in %s mode.\n",
		     !inf_mode_valid
		     ? "default" : inf_terminal_mode ? "raw" : "cooked");

#if __DJGPP_MINOR__ > 2
  if (child_cmd.redirection)
  {
    int i;

    for (i = 0; i < DBG_HANDLES; i++)
    {
      if (child_cmd.redirection[i]->file_name)
	printf_unfiltered ("\tFile handle %d is redirected to `%s'.\n",
			   i, child_cmd.redirection[i]->file_name);
      else if (_get_dev_info (child_cmd.redirection[i]->inf_handle) == -1)
	printf_unfiltered
	  ("\tFile handle %d appears to be closed by inferior.\n", i);
      /* Mask off the raw/cooked bit when comparing device info words.  */
      else if ((_get_dev_info (child_cmd.redirection[i]->inf_handle) & 0xdf)
	       != (_get_dev_info (i) & 0xdf))
	printf_unfiltered
	  ("\tFile handle %d appears to be redirected by inferior.\n", i);
    }
  }
#endif
}

static void
go32_terminal_inferior (void)
{
  /* Redirect standard handles as child wants them.  */
  errno = 0;
  if (redir_to_child (&child_cmd) == -1)
  {
    redir_to_debugger (&child_cmd);
    error (_("Cannot redirect standard handles for program: %s."),
	   safe_strerror (errno));
  }
  /* Set the console device of the inferior to whatever mode
     (raw or cooked) we found it last time.  */
  if (terminal_is_ours)
  {
    if (inf_mode_valid)
      device_mode (0, inf_terminal_mode);
    terminal_is_ours = 0;
  }
}

static void
go32_terminal_ours (void)
{
  /* Switch to cooked mode on the gdb terminal and save the inferior
     terminal mode to be restored when it is resumed.  */
  if (!terminal_is_ours)
  {
    inf_terminal_mode = device_mode (0, 0);
    if (inf_terminal_mode != -1)
      inf_mode_valid = 1;
    else
      /* If device_mode returned -1, we don't know what happens with
	 handle 0 anymore, so make the info invalid.  */
      inf_mode_valid = 0;
    terminal_is_ours = 1;

    /* Restore debugger's standard handles.  */
    errno = 0;
    if (redir_to_debugger (&child_cmd) == -1)
    {
      redir_to_child (&child_cmd);
      error (_("Cannot redirect standard handles for debugger: %s."),
	     safe_strerror (errno));
    }
  }
}

static int
go32_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  return !ptid_equal (inferior_ptid, null_ptid);
}

static char *
go32_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  return normal_pid_to_str (ptid);
}

static void
init_go32_ops (void)
{
  go32_ops.to_shortname = "djgpp";
  go32_ops.to_longname = "djgpp target process";
  go32_ops.to_doc =
    "Program loaded by djgpp, when gdb is used as an external debugger";
  go32_ops.to_open = go32_open;
  go32_ops.to_close = go32_close;
  go32_ops.to_attach = go32_attach;
  go32_ops.to_detach = go32_detach;
  go32_ops.to_resume = go32_resume;
  go32_ops.to_wait = go32_wait;
  go32_ops.to_fetch_registers = go32_fetch_registers;
  go32_ops.to_store_registers = go32_store_registers;
  go32_ops.to_prepare_to_store = go32_prepare_to_store;
  go32_ops.deprecated_xfer_memory = go32_xfer_memory;
  go32_ops.to_files_info = go32_files_info;
  go32_ops.to_insert_breakpoint = memory_insert_breakpoint;
  go32_ops.to_remove_breakpoint = memory_remove_breakpoint;
  go32_ops.to_terminal_init = go32_terminal_init;
  go32_ops.to_terminal_inferior = go32_terminal_inferior;
  go32_ops.to_terminal_ours_for_output = go32_terminal_ours;
  go32_ops.to_terminal_ours = go32_terminal_ours;
  go32_ops.to_terminal_info = go32_terminal_info;
  go32_ops.to_kill = go32_kill_inferior;
  go32_ops.to_create_inferior = go32_create_inferior;
  go32_ops.to_mourn_inferior = go32_mourn_inferior;
  go32_ops.to_can_run = go32_can_run;
  go32_ops.to_thread_alive = go32_thread_alive;
  go32_ops.to_pid_to_str = go32_pid_to_str;
  go32_ops.to_stratum = process_stratum;
  go32_ops.to_has_all_memory = default_child_has_all_memory;
  go32_ops.to_has_memory = default_child_has_memory;
  go32_ops.to_has_stack = default_child_has_stack;
  go32_ops.to_has_registers = default_child_has_registers;
  go32_ops.to_has_execution = default_child_has_execution;

  i386_use_watchpoints (&go32_ops);


  i386_dr_low.set_control = go32_set_dr7;
  i386_dr_low.set_addr = go32_set_dr;
  i386_dr_low.get_status = go32_get_dr6;
  i386_dr_low.get_control = go32_get_dr7;
  i386_dr_low.get_addr = go32_get_dr;
  i386_set_debug_register_length (4);

  go32_ops.to_magic = OPS_MAGIC;

  /* Initialize child's cwd as empty to be initialized when starting
     the child.  */
  *child_cwd = 0;

  /* Initialize child's command line storage.  */
  if (redir_debug_init (&child_cmd) == -1)
    internal_error (__FILE__, __LINE__,
		    _("Cannot allocate redirection storage: "
		      "not enough memory.\n"));

  /* We are always processing GCC-compiled programs.  */
  processing_gcc_compilation = 2;
}

/* Return the current DOS codepage number.  */
static int
dos_codepage (void)
{
  __dpmi_regs regs;

  regs.x.ax = 0x6601;
  __dpmi_int (0x21, &regs);
  if (!(regs.x.flags & 1))
    return regs.x.bx & 0xffff;
  else
    return 437;	/* default */
}

/* Limited emulation of `nl_langinfo', for charset.c.  */
char *
nl_langinfo (nl_item item)
{
  char *retval;

  switch (item)
    {
      case CODESET:
	{
	  /* 8 is enough for SHORT_MAX + "CP" + null.  */
	  char buf[8];
	  int blen = sizeof (buf);
	  int needed = snprintf (buf, blen, "CP%d", dos_codepage ());

	  if (needed > blen)	/* Should never happen.  */
	    buf[0] = 0;
	  retval = xstrdup (buf);
	}
	break;
      default:
	retval = xstrdup ("");
	break;
    }
  return retval;
}

unsigned short windows_major, windows_minor;

/* Compute the version Windows reports via Int 2Fh/AX=1600h.  */
static void
go32_get_windows_version(void)
{
  __dpmi_regs r;

  r.x.ax = 0x1600;
  __dpmi_int(0x2f, &r);
  if (r.h.al > 2 && r.h.al != 0x80 && r.h.al != 0xff
      && (r.h.al > 3 || r.h.ah > 0))
    {
      windows_major = r.h.al;
      windows_minor = r.h.ah;
    }
  else
    windows_major = 0xff;	/* meaning no Windows */
}

/* A subroutine of go32_sysinfo to display memory info.  */
static void
print_mem (unsigned long datum, const char *header, int in_pages_p)
{
  if (datum != 0xffffffffUL)
    {
      if (in_pages_p)
	datum <<= 12;
      puts_filtered (header);
      if (datum > 1024)
	{
	  printf_filtered ("%lu KB", datum >> 10);
	  if (datum > 1024 * 1024)
	    printf_filtered (" (%lu MB)", datum >> 20);
	}
      else
	printf_filtered ("%lu Bytes", datum);
      puts_filtered ("\n");
    }
}

/* Display assorted information about the underlying OS.  */
static void
go32_sysinfo (char *arg, int from_tty)
{
  static const char test_pattern[] =
    "deadbeafdeadbeafdeadbeafdeadbeafdeadbeaf"
    "deadbeafdeadbeafdeadbeafdeadbeafdeadbeaf"
    "deadbeafdeadbeafdeadbeafdeadbeafdeadbeafdeadbeaf";
  struct utsname u;
  char cpuid_vendor[13];
  unsigned cpuid_max = 0, cpuid_eax, cpuid_ebx, cpuid_ecx, cpuid_edx;
  unsigned true_dos_version = _get_dos_version (1);
  unsigned advertized_dos_version = ((unsigned int)_osmajor << 8) | _osminor;
  int dpmi_flags;
  char dpmi_vendor_info[129];
  int dpmi_vendor_available;
  __dpmi_version_ret dpmi_version_data;
  long eflags;
  __dpmi_free_mem_info mem_info;
  __dpmi_regs regs;

  cpuid_vendor[0] = '\0';
  if (uname (&u))
    strcpy (u.machine, "Unknown x86");
  else if (u.machine[0] == 'i' && u.machine[1] > 4)
    {
      /* CPUID with EAX = 0 returns the Vendor ID.  */
#if 0
      /* Ideally we would use i386_cpuid(), but it needs someone to run
         native tests first to make sure things actually work.  They should.
         http://sourceware.org/ml/gdb-patches/2013-05/msg00164.html  */
      unsigned int eax, ebx, ecx, edx;

      if (i386_cpuid (0, &eax, &ebx, &ecx, &edx))
	{
	  cpuid_max = eax;
	  memcpy (&vendor[0], &ebx, 4);
	  memcpy (&vendor[4], &ecx, 4);
	  memcpy (&vendor[8], &edx, 4);
	  cpuid_vendor[12] = '\0';
	}
#else
      __asm__ __volatile__ ("xorl   %%ebx, %%ebx;"
			    "xorl   %%ecx, %%ecx;"
			    "xorl   %%edx, %%edx;"
			    "movl   $0,    %%eax;"
			    "cpuid;"
			    "movl   %%ebx,  %0;"
			    "movl   %%edx,  %1;"
			    "movl   %%ecx,  %2;"
			    "movl   %%eax,  %3;"
			    : "=m" (cpuid_vendor[0]),
			      "=m" (cpuid_vendor[4]),
			      "=m" (cpuid_vendor[8]),
			      "=m" (cpuid_max)
			    :
			    : "%eax", "%ebx", "%ecx", "%edx");
      cpuid_vendor[12] = '\0';
#endif
    }

  printf_filtered ("CPU Type.......................%s", u.machine);
  if (cpuid_vendor[0])
    printf_filtered (" (%s)", cpuid_vendor);
  puts_filtered ("\n");

  /* CPUID with EAX = 1 returns processor signature and features.  */
  if (cpuid_max >= 1)
    {
      static char *brand_name[] = {
	"",
	" Celeron",
	" III",
	" III Xeon",
	"", "", "", "",
	" 4"
      };
      char cpu_string[80];
      char cpu_brand[20];
      unsigned brand_idx;
      int intel_p = strcmp (cpuid_vendor, "GenuineIntel") == 0;
      int amd_p = strcmp (cpuid_vendor, "AuthenticAMD") == 0;
      unsigned cpu_family, cpu_model;

#if 0
      /* See comment above about cpuid usage.  */
      i386_cpuid (1, &cpuid_eax, &cpuid_ebx, NULL, &cpuid_edx);
#else
      __asm__ __volatile__ ("movl   $1, %%eax;"
			    "cpuid;"
			    : "=a" (cpuid_eax),
			      "=b" (cpuid_ebx),
			      "=d" (cpuid_edx)
			    :
			    : "%ecx");
#endif
      brand_idx = cpuid_ebx & 0xff;
      cpu_family = (cpuid_eax >> 8) & 0xf;
      cpu_model  = (cpuid_eax >> 4) & 0xf;
      cpu_brand[0] = '\0';
      if (intel_p)
	{
	  if (brand_idx > 0
	      && brand_idx < sizeof(brand_name)/sizeof(brand_name[0])
	      && *brand_name[brand_idx])
	    strcpy (cpu_brand, brand_name[brand_idx]);
	  else if (cpu_family == 5)
	    {
	      if (((cpuid_eax >> 12) & 3) == 0 && cpu_model == 4)
		strcpy (cpu_brand, " MMX");
	      else if (cpu_model > 1 && ((cpuid_eax >> 12) & 3) == 1)
		strcpy (cpu_brand, " OverDrive");
	      else if (cpu_model > 1 && ((cpuid_eax >> 12) & 3) == 2)
		strcpy (cpu_brand, " Dual");
	    }
	  else if (cpu_family == 6 && cpu_model < 8)
	    {
	      switch (cpu_model)
		{
		  case 1:
		    strcpy (cpu_brand, " Pro");
		    break;
		  case 3:
		    strcpy (cpu_brand, " II");
		    break;
		  case 5:
		    strcpy (cpu_brand, " II Xeon");
		    break;
		  case 6:
		    strcpy (cpu_brand, " Celeron");
		    break;
		  case 7:
		    strcpy (cpu_brand, " III");
		    break;
		}
	    }
	}
      else if (amd_p)
	{
	  switch (cpu_family)
	    {
	      case 4:
		strcpy (cpu_brand, "486/5x86");
		break;
	      case 5:
		switch (cpu_model)
		  {
		    case 0:
		    case 1:
		    case 2:
		    case 3:
		      strcpy (cpu_brand, "-K5");
		      break;
		    case 6:
		    case 7:
		      strcpy (cpu_brand, "-K6");
		      break;
		    case 8:
		      strcpy (cpu_brand, "-K6-2");
		      break;
		    case 9:
		      strcpy (cpu_brand, "-K6-III");
		      break;
		  }
		break;
	      case 6:
		switch (cpu_model)
		  {
		    case 1:
		    case 2:
		    case 4:
		      strcpy (cpu_brand, " Athlon");
		      break;
		    case 3:
		      strcpy (cpu_brand, " Duron");
		      break;
		  }
		break;
	    }
	}
      xsnprintf (cpu_string, sizeof (cpu_string), "%s%s Model %d Stepping %d",
	         intel_p ? "Pentium" : (amd_p ? "AMD" : "ix86"),
	         cpu_brand, cpu_model, cpuid_eax & 0xf);
      printfi_filtered (31, "%s\n", cpu_string);
      if (((cpuid_edx & (6 | (0x0d << 23))) != 0)
	  || ((cpuid_edx & 1) == 0)
	  || (amd_p && (cpuid_edx & (3 << 30)) != 0))
	{
	  puts_filtered ("CPU Features...................");
	  /* We only list features which might be useful in the DPMI
	     environment.  */
	  if ((cpuid_edx & 1) == 0)
	    puts_filtered ("No FPU "); /* It's unusual to not have an FPU.  */
	  if ((cpuid_edx & (1 << 1)) != 0)
	    puts_filtered ("VME ");
	  if ((cpuid_edx & (1 << 2)) != 0)
	    puts_filtered ("DE ");
	  if ((cpuid_edx & (1 << 4)) != 0)
	    puts_filtered ("TSC ");
	  if ((cpuid_edx & (1 << 23)) != 0)
	    puts_filtered ("MMX ");
	  if ((cpuid_edx & (1 << 25)) != 0)
	    puts_filtered ("SSE ");
	  if ((cpuid_edx & (1 << 26)) != 0)
	    puts_filtered ("SSE2 ");
	  if (amd_p)
	    {
	      if ((cpuid_edx & (1 << 31)) != 0)
		puts_filtered ("3DNow! ");
	      if ((cpuid_edx & (1 << 30)) != 0)
		puts_filtered ("3DNow!Ext");
	    }
	  puts_filtered ("\n");
	}
    }
  puts_filtered ("\n");
  printf_filtered ("DOS Version....................%s %s.%s",
		   _os_flavor, u.release, u.version);
  if (true_dos_version != advertized_dos_version)
    printf_filtered (" (disguised as v%d.%d)", _osmajor, _osminor);
  puts_filtered ("\n");
  if (!windows_major)
    go32_get_windows_version ();
  if (windows_major != 0xff)
    {
      const char *windows_flavor;

      printf_filtered ("Windows Version................%d.%02d (Windows ",
		       windows_major, windows_minor);
      switch (windows_major)
	{
	  case 3:
	    windows_flavor = "3.X";
	    break;
	  case 4:
	    switch (windows_minor)
	      {
		case 0:
		  windows_flavor = "95, 95A, or 95B";
		  break;
		case 3:
		  windows_flavor = "95B OSR2.1 or 95C OSR2.5";
		  break;
		case 10:
		  windows_flavor = "98 or 98 SE";
		  break;
		case 90:
		  windows_flavor = "ME";
		  break;
		default:
		  windows_flavor = "9X";
		  break;
	      }
	    break;
	  default:
	    windows_flavor = "??";
	    break;
	}
      printf_filtered ("%s)\n", windows_flavor);
    }
  else if (true_dos_version == 0x532 && advertized_dos_version == 0x500)
    printf_filtered ("Windows Version................"
		     "Windows NT family (W2K/XP/W2K3/Vista/W2K8)\n");
  puts_filtered ("\n");
  /* On some versions of Windows, __dpmi_get_capabilities returns
     zero, but the buffer is not filled with info, so we fill the
     buffer with a known pattern and test for it afterwards.  */
  memcpy (dpmi_vendor_info, test_pattern, sizeof(dpmi_vendor_info));
  dpmi_vendor_available =
    __dpmi_get_capabilities (&dpmi_flags, dpmi_vendor_info);
  if (dpmi_vendor_available == 0
      && memcmp (dpmi_vendor_info, test_pattern,
		 sizeof(dpmi_vendor_info)) != 0)
    {
      /* The DPMI spec says the vendor string should be ASCIIZ, but
	 I don't trust the vendors to follow that...  */
      if (!memchr (&dpmi_vendor_info[2], 0, 126))
	dpmi_vendor_info[128] = '\0';
      printf_filtered ("DPMI Host......................"
		       "%s v%d.%d (capabilities: %#x)\n",
		       &dpmi_vendor_info[2],
		       (unsigned)dpmi_vendor_info[0],
		       (unsigned)dpmi_vendor_info[1],
		       ((unsigned)dpmi_flags & 0x7f));
    }
  else
    printf_filtered ("DPMI Host......................(Info not available)\n");
  __dpmi_get_version (&dpmi_version_data);
  printf_filtered ("DPMI Version...................%d.%02d\n",
		   dpmi_version_data.major, dpmi_version_data.minor);
  printf_filtered ("DPMI Info......................"
		   "%s-bit DPMI, with%s Virtual Memory support\n",
		   (dpmi_version_data.flags & 1) ? "32" : "16",
		   (dpmi_version_data.flags & 4) ? "" : "out");
  printfi_filtered (31, "Interrupts reflected to %s mode\n",
		   (dpmi_version_data.flags & 2) ? "V86" : "Real");
  printfi_filtered (31, "Processor type: i%d86\n",
		   dpmi_version_data.cpu);
  printfi_filtered (31, "PIC base interrupt: Master: %#x  Slave: %#x\n",
		   dpmi_version_data.master_pic, dpmi_version_data.slave_pic);

  /* a_tss is only initialized when the debuggee is first run.  */
  if (prog_has_started)
    {
      __asm__ __volatile__ ("pushfl ; popl %0" : "=g" (eflags));
      printf_filtered ("Protection....................."
		       "Ring %d (in %s), with%s I/O protection\n",
		       a_tss.tss_cs & 3, (a_tss.tss_cs & 4) ? "LDT" : "GDT",
		       (a_tss.tss_cs & 3) > ((eflags >> 12) & 3) ? "" : "out");
    }
  puts_filtered ("\n");
  __dpmi_get_free_memory_information (&mem_info);
  print_mem (mem_info.total_number_of_physical_pages,
	     "DPMI Total Physical Memory.....", 1);
  print_mem (mem_info.total_number_of_free_pages,
	     "DPMI Free Physical Memory......", 1);
  print_mem (mem_info.size_of_paging_file_partition_in_pages,
	     "DPMI Swap Space................", 1);
  print_mem (mem_info.linear_address_space_size_in_pages,
	     "DPMI Total Linear Address Size.", 1);
  print_mem (mem_info.free_linear_address_space_in_pages,
	     "DPMI Free Linear Address Size..", 1);
  print_mem (mem_info.largest_available_free_block_in_bytes,
	     "DPMI Largest Free Memory Block.", 0);

  regs.h.ah = 0x48;
  regs.x.bx = 0xffff;
  __dpmi_int (0x21, &regs);
  print_mem (regs.x.bx << 4, "Free DOS Memory................", 0);
  regs.x.ax = 0x5800;
  __dpmi_int (0x21, &regs);
  if ((regs.x.flags & 1) == 0)
    {
      static const char *dos_hilo[] = {
	"Low", "", "", "", "High", "", "", "", "High, then Low"
      };
      static const char *dos_fit[] = {
	"First", "Best", "Last"
      };
      int hilo_idx = (regs.x.ax >> 4) & 0x0f;
      int fit_idx  = regs.x.ax & 0x0f;

      if (hilo_idx > 8)
	hilo_idx = 0;
      if (fit_idx > 2)
	fit_idx = 0;
      printf_filtered ("DOS Memory Allocation..........%s memory, %s fit\n",
		       dos_hilo[hilo_idx], dos_fit[fit_idx]);
      regs.x.ax = 0x5802;
      __dpmi_int (0x21, &regs);
      if ((regs.x.flags & 1) != 0)
	regs.h.al = 0;
      printfi_filtered (31, "UMBs %sin DOS memory chain\n",
			regs.h.al == 0 ? "not " : "");
    }
}

struct seg_descr {
  unsigned short limit0;
  unsigned short base0;
  unsigned char  base1;
  unsigned       stype:5;
  unsigned       dpl:2;
  unsigned       present:1;
  unsigned       limit1:4;
  unsigned       available:1;
  unsigned       dummy:1;
  unsigned       bit32:1;
  unsigned       page_granular:1;
  unsigned char  base2;
} __attribute__ ((packed));

struct gate_descr {
  unsigned short offset0;
  unsigned short selector;
  unsigned       param_count:5;
  unsigned       dummy:3;
  unsigned       stype:5;
  unsigned       dpl:2;
  unsigned       present:1;
  unsigned short offset1;
} __attribute__ ((packed));

/* Read LEN bytes starting at logical address ADDR, and put the result
   into DEST.  Return 1 if success, zero if not.  */
static int
read_memory_region (unsigned long addr, void *dest, size_t len)
{
  unsigned long dos_ds_limit = __dpmi_get_segment_limit (_dos_ds);
  int retval = 1;

  /* For the low memory, we can simply use _dos_ds.  */
  if (addr <= dos_ds_limit - len)
    dosmemget (addr, len, dest);
  else
    {
      /* For memory above 1MB we need to set up a special segment to
	 be able to access that memory.  */
      int sel = __dpmi_allocate_ldt_descriptors (1);

      if (sel <= 0)
	retval = 0;
      else
	{
	  int access_rights = __dpmi_get_descriptor_access_rights (sel);
	  size_t segment_limit = len - 1;

	  /* Make sure the crucial bits in the descriptor access
	     rights are set correctly.  Some DPMI providers might barf
	     if we set the segment limit to something that is not an
	     integral multiple of 4KB pages if the granularity bit is
	     not set to byte-granular, even though the DPMI spec says
	     it's the host's responsibility to set that bit correctly.  */
	  if (len > 1024 * 1024)
	    {
	      access_rights |= 0x8000;
	      /* Page-granular segments should have the low 12 bits of
		 the limit set.  */
	      segment_limit |= 0xfff;
	    }
	  else
	    access_rights &= ~0x8000;

	  if (__dpmi_set_segment_base_address (sel, addr) != -1
	      && __dpmi_set_descriptor_access_rights (sel, access_rights) != -1
	      && __dpmi_set_segment_limit (sel, segment_limit) != -1
	      /* W2K silently fails to set the segment limit, leaving
		 it at zero; this test avoids the resulting crash.  */
	      && __dpmi_get_segment_limit (sel) >= segment_limit)
	    movedata (sel, 0, _my_ds (), (unsigned)dest, len);
	  else
	    retval = 0;

	  __dpmi_free_ldt_descriptor (sel);
	}
    }
  return retval;
}

/* Get a segment descriptor stored at index IDX in the descriptor
   table whose base address is TABLE_BASE.  Return the descriptor
   type, or -1 if failure.  */
static int
get_descriptor (unsigned long table_base, int idx, void *descr)
{
  unsigned long addr = table_base + idx * 8; /* 8 bytes per entry */

  if (read_memory_region (addr, descr, 8))
    return (int)((struct seg_descr *)descr)->stype;
  return -1;
}

struct dtr_reg {
  unsigned short limit __attribute__((packed));
  unsigned long  base  __attribute__((packed));
};

/* Display a segment descriptor stored at index IDX in a descriptor
   table whose type is TYPE and whose base address is BASE_ADDR.  If
   FORCE is non-zero, display even invalid descriptors.  */
static void
display_descriptor (unsigned type, unsigned long base_addr, int idx, int force)
{
  struct seg_descr descr;
  struct gate_descr gate;

  /* Get the descriptor from the table.  */
  if (idx == 0 && type == 0)
    puts_filtered ("0x000: null descriptor\n");
  else if (get_descriptor (base_addr, idx, &descr) != -1)
    {
      /* For each type of descriptor table, this has a bit set if the
	 corresponding type of selectors is valid in that table.  */
      static unsigned allowed_descriptors[] = {
	  0xffffdafeL,   /* GDT */
	  0x0000c0e0L,   /* IDT */
	  0xffffdafaL    /* LDT */
      };

      /* If the program hasn't started yet, assume the debuggee will
	 have the same CPL as the debugger.  */
      int cpl = prog_has_started ? (a_tss.tss_cs & 3) : _my_cs () & 3;
      unsigned long limit = (descr.limit1 << 16) | descr.limit0;

      if (descr.present
	  && (allowed_descriptors[type] & (1 << descr.stype)) != 0)
	{
	  printf_filtered ("0x%03x: ",
			   type == 1
			   ? idx : (idx * 8) | (type ? (cpl | 4) : 0));
	  if (descr.page_granular)
	    limit = (limit << 12) | 0xfff; /* big segment: low 12 bit set */
	  if (descr.stype == 1 || descr.stype == 2 || descr.stype == 3
	      || descr.stype == 9 || descr.stype == 11
	      || (descr.stype >= 16 && descr.stype < 32))
	    printf_filtered ("base=0x%02x%02x%04x limit=0x%08lx",
			     descr.base2, descr.base1, descr.base0, limit);

	  switch (descr.stype)
	    {
	      case 1:
	      case 3:
		printf_filtered (" 16-bit TSS  (task %sactive)",
				 descr.stype == 3 ? "" : "in");
		break;
	      case 2:
		puts_filtered (" LDT");
		break;
	      case 4:
		memcpy (&gate, &descr, sizeof gate);
		printf_filtered ("selector=0x%04x  offs=0x%04x%04x",
				 gate.selector, gate.offset1, gate.offset0);
		printf_filtered (" 16-bit Call Gate (params=%d)",
				 gate.param_count);
		break;
	      case 5:
		printf_filtered ("TSS selector=0x%04x", descr.base0);
		printfi_filtered (16, "Task Gate");
		break;
	      case 6:
	      case 7:
		memcpy (&gate, &descr, sizeof gate);
		printf_filtered ("selector=0x%04x  offs=0x%04x%04x",
				 gate.selector, gate.offset1, gate.offset0);
		printf_filtered (" 16-bit %s Gate",
				 descr.stype == 6 ? "Interrupt" : "Trap");
		break;
	      case 9:
	      case 11:
		printf_filtered (" 32-bit TSS (task %sactive)",
				 descr.stype == 3 ? "" : "in");
		break;
	      case 12:
		memcpy (&gate, &descr, sizeof gate);
		printf_filtered ("selector=0x%04x  offs=0x%04x%04x",
				 gate.selector, gate.offset1, gate.offset0);
		printf_filtered (" 32-bit Call Gate (params=%d)",
				 gate.param_count);
		break;
	      case 14:
	      case 15:
		memcpy (&gate, &descr, sizeof gate);
		printf_filtered ("selector=0x%04x  offs=0x%04x%04x",
				 gate.selector, gate.offset1, gate.offset0);
		printf_filtered (" 32-bit %s Gate",
				 descr.stype == 14 ? "Interrupt" : "Trap");
		break;
	      case 16:		/* data segments */
	      case 17:
	      case 18:
	      case 19:
	      case 20:
	      case 21:
	      case 22:
	      case 23:
		printf_filtered (" %s-bit Data (%s Exp-%s%s)",
				 descr.bit32 ? "32" : "16",
				 descr.stype & 2
				 ? "Read/Write," : "Read-Only, ",
				 descr.stype & 4 ? "down" : "up",
				 descr.stype & 1 ? "" : ", N.Acc");
		break;
	      case 24:		/* code segments */
	      case 25:
	      case 26:
	      case 27:
	      case 28:
	      case 29:
	      case 30:
	      case 31:
		printf_filtered (" %s-bit Code (%s,  %sConf%s)",
				 descr.bit32 ? "32" : "16",
				 descr.stype & 2 ? "Exec/Read" : "Exec-Only",
				 descr.stype & 4 ? "" : "N.",
				 descr.stype & 1 ? "" : ", N.Acc");
		break;
	      default:
		printf_filtered ("Unknown type 0x%02x", descr.stype);
		break;
	    }
	  puts_filtered ("\n");
	}
      else if (force)
	{
	  printf_filtered ("0x%03x: ",
			   type == 1
			   ? idx : (idx * 8) | (type ? (cpl | 4) : 0));
	  if (!descr.present)
	    puts_filtered ("Segment not present\n");
	  else
	    printf_filtered ("Segment type 0x%02x is invalid in this table\n",
			     descr.stype);
	}
    }
  else if (force)
    printf_filtered ("0x%03x: Cannot read this descriptor\n", idx);
}

static void
go32_sldt (char *arg, int from_tty)
{
  struct dtr_reg gdtr;
  unsigned short ldtr = 0;
  int ldt_idx;
  struct seg_descr ldt_descr;
  long ldt_entry = -1L;
  int cpl = (prog_has_started ? a_tss.tss_cs : _my_cs ()) & 3;

  if (arg && *arg)
    {
      arg = skip_spaces (arg);

      if (*arg)
	{
	  ldt_entry = parse_and_eval_long (arg);
	  if (ldt_entry < 0
	      || (ldt_entry & 4) == 0
	      || (ldt_entry & 3) != (cpl & 3))
	    error (_("Invalid LDT entry 0x%03lx."), (unsigned long)ldt_entry);
	}
    }

  __asm__ __volatile__ ("sgdt   %0" : "=m" (gdtr) : /* no inputs */ );
  __asm__ __volatile__ ("sldt   %0" : "=m" (ldtr) : /* no inputs */ );
  ldt_idx = ldtr / 8;
  if (ldt_idx == 0)
    puts_filtered ("There is no LDT.\n");
  /* LDT's entry in the GDT must have the type LDT, which is 2.  */
  else if (get_descriptor (gdtr.base, ldt_idx, &ldt_descr) != 2)
    printf_filtered ("LDT is present (at %#x), but unreadable by GDB.\n",
		     ldt_descr.base0
		     | (ldt_descr.base1 << 16)
		     | (ldt_descr.base2 << 24));
  else
    {
      unsigned base =
	ldt_descr.base0
	| (ldt_descr.base1 << 16)
	| (ldt_descr.base2 << 24);
      unsigned limit = ldt_descr.limit0 | (ldt_descr.limit1 << 16);
      int max_entry;

      if (ldt_descr.page_granular)
	/* Page-granular segments must have the low 12 bits of their
	   limit set.  */
	limit = (limit << 12) | 0xfff;
      /* LDT cannot have more than 8K 8-byte entries, i.e. more than
	 64KB.  */
      if (limit > 0xffff)
	limit = 0xffff;

      max_entry = (limit + 1) / 8;

      if (ldt_entry >= 0)
	{
	  if (ldt_entry > limit)
	    error (_("Invalid LDT entry %#lx: outside valid limits [0..%#x]"),
		   (unsigned long)ldt_entry, limit);

	  display_descriptor (ldt_descr.stype, base, ldt_entry / 8, 1);
	}
      else
	{
	  int i;

	  for (i = 0; i < max_entry; i++)
	    display_descriptor (ldt_descr.stype, base, i, 0);
	}
    }
}

static void
go32_sgdt (char *arg, int from_tty)
{
  struct dtr_reg gdtr;
  long gdt_entry = -1L;
  int max_entry;

  if (arg && *arg)
    {
      arg = skip_spaces (arg);

      if (*arg)
	{
	  gdt_entry = parse_and_eval_long (arg);
	  if (gdt_entry < 0 || (gdt_entry & 7) != 0)
	    error (_("Invalid GDT entry 0x%03lx: "
		     "not an integral multiple of 8."),
		   (unsigned long)gdt_entry);
	}
    }

  __asm__ __volatile__ ("sgdt   %0" : "=m" (gdtr) : /* no inputs */ );
  max_entry = (gdtr.limit + 1) / 8;

  if (gdt_entry >= 0)
    {
      if (gdt_entry > gdtr.limit)
	error (_("Invalid GDT entry %#lx: outside valid limits [0..%#x]"),
	       (unsigned long)gdt_entry, gdtr.limit);

      display_descriptor (0, gdtr.base, gdt_entry / 8, 1);
    }
  else
    {
      int i;

      for (i = 0; i < max_entry; i++)
	display_descriptor (0, gdtr.base, i, 0);
    }
}

static void
go32_sidt (char *arg, int from_tty)
{
  struct dtr_reg idtr;
  long idt_entry = -1L;
  int max_entry;

  if (arg && *arg)
    {
      arg = skip_spaces (arg);

      if (*arg)
	{
	  idt_entry = parse_and_eval_long (arg);
	  if (idt_entry < 0)
	    error (_("Invalid (negative) IDT entry %ld."), idt_entry);
	}
    }

  __asm__ __volatile__ ("sidt   %0" : "=m" (idtr) : /* no inputs */ );
  max_entry = (idtr.limit + 1) / 8;
  if (max_entry > 0x100)	/* No more than 256 entries.  */
    max_entry = 0x100;

  if (idt_entry >= 0)
    {
      if (idt_entry > idtr.limit)
	error (_("Invalid IDT entry %#lx: outside valid limits [0..%#x]"),
	       (unsigned long)idt_entry, idtr.limit);

      display_descriptor (1, idtr.base, idt_entry, 1);
    }
  else
    {
      int i;

      for (i = 0; i < max_entry; i++)
	display_descriptor (1, idtr.base, i, 0);
    }
}

/* Cached linear address of the base of the page directory.  For
   now, available only under CWSDPMI.  Code based on ideas and
   suggestions from Charles Sandmann <sandmann@@clio.rice.edu>.  */
static unsigned long pdbr;

static unsigned long
get_cr3 (void)
{
  unsigned offset;
  unsigned taskreg;
  unsigned long taskbase, cr3;
  struct dtr_reg gdtr;

  if (pdbr > 0 && pdbr <= 0xfffff)
    return pdbr;

  /* Get the linear address of GDT and the Task Register.  */
  __asm__ __volatile__ ("sgdt   %0" : "=m" (gdtr) : /* no inputs */ );
  __asm__ __volatile__ ("str    %0" : "=m" (taskreg) : /* no inputs */ );

  /* Task Register is a segment selector for the TSS of the current
     task.  Therefore, it can be used as an index into the GDT to get
     at the segment descriptor for the TSS.  To get the index, reset
     the low 3 bits of the selector (which give the CPL).  Add 2 to the
     offset to point to the 3 low bytes of the base address.  */
  offset = gdtr.base + (taskreg & 0xfff8) + 2;


  /* CWSDPMI's task base is always under the 1MB mark.  */
  if (offset > 0xfffff)
    return 0;

  _farsetsel (_dos_ds);
  taskbase  = _farnspeekl (offset) & 0xffffffU;
  taskbase += _farnspeekl (offset + 2) & 0xff000000U;
  if (taskbase > 0xfffff)
    return 0;

  /* CR3 (a.k.a. PDBR, the Page Directory Base Register) is stored at
     offset 1Ch in the TSS.  */
  cr3 = _farnspeekl (taskbase + 0x1c) & ~0xfff;
  if (cr3 > 0xfffff)
    {
#if 0  /* Not fullly supported yet.  */
      /* The Page Directory is in UMBs.  In that case, CWSDPMI puts
	 the first Page Table right below the Page Directory.  Thus,
	 the first Page Table's entry for its own address and the Page
	 Directory entry for that Page Table will hold the same
	 physical address.  The loop below searches the entire UMB
	 range of addresses for such an occurence.  */
      unsigned long addr, pte_idx;

      for (addr = 0xb0000, pte_idx = 0xb0;
	   pte_idx < 0xff;
	   addr += 0x1000, pte_idx++)
	{
	  if (((_farnspeekl (addr + 4 * pte_idx) & 0xfffff027) ==
	       (_farnspeekl (addr + 0x1000) & 0xfffff027))
	      && ((_farnspeekl (addr + 4 * pte_idx + 4) & 0xfffff000) == cr3))
	    {
	      cr3 = addr + 0x1000;
	      break;
	    }
	}
#endif

      if (cr3 > 0xfffff)
	cr3 = 0;
    }

  return cr3;
}

/* Return the N'th Page Directory entry.  */
static unsigned long
get_pde (int n)
{
  unsigned long pde = 0;

  if (pdbr && n >= 0 && n < 1024)
    {
      pde = _farpeekl (_dos_ds, pdbr + 4*n);
    }
  return pde;
}

/* Return the N'th entry of the Page Table whose Page Directory entry
   is PDE.  */
static unsigned long
get_pte (unsigned long pde, int n)
{
  unsigned long pte = 0;

  /* pde & 0x80 tests the 4MB page bit.  We don't support 4MB
     page tables, for now.  */
  if ((pde & 1) && !(pde & 0x80) && n >= 0 && n < 1024)
    {
      pde &= ~0xfff;	/* Clear non-address bits.  */
      pte = _farpeekl (_dos_ds, pde + 4*n);
    }
  return pte;
}

/* Display a Page Directory or Page Table entry.  IS_DIR, if non-zero,
   says this is a Page Directory entry.  If FORCE is non-zero, display
   the entry even if its Present flag is off.  OFF is the offset of the
   address from the page's base address.  */
static void
display_ptable_entry (unsigned long entry, int is_dir, int force, unsigned off)
{
  if ((entry & 1) != 0)
    {
      printf_filtered ("Base=0x%05lx000", entry >> 12);
      if ((entry & 0x100) && !is_dir)
	puts_filtered (" Global");
      if ((entry & 0x40) && !is_dir)
	puts_filtered (" Dirty");
      printf_filtered (" %sAcc.", (entry & 0x20) ? "" : "Not-");
      printf_filtered (" %sCached", (entry & 0x10) ? "" : "Not-");
      printf_filtered (" Write-%s", (entry & 8) ? "Thru" : "Back");
      printf_filtered (" %s", (entry & 4) ? "Usr" : "Sup");
      printf_filtered (" Read-%s", (entry & 2) ? "Write" : "Only");
      if (off)
	printf_filtered (" +0x%x", off);
      puts_filtered ("\n");
    }
  else if (force)
    printf_filtered ("Page%s not present or not supported; value=0x%lx.\n",
		     is_dir ? " Table" : "", entry >> 1);
}

static void
go32_pde (char *arg, int from_tty)
{
  long pde_idx = -1, i;

  if (arg && *arg)
    {
      arg = skip_spaces (arg);

      if (*arg)
	{
	  pde_idx = parse_and_eval_long (arg);
	  if (pde_idx < 0 || pde_idx >= 1024)
	    error (_("Entry %ld is outside valid limits [0..1023]."), pde_idx);
	}
    }

  pdbr = get_cr3 ();
  if (!pdbr)
    puts_filtered ("Access to Page Directories is "
		   "not supported on this system.\n");
  else if (pde_idx >= 0)
    display_ptable_entry (get_pde (pde_idx), 1, 1, 0);
  else
    for (i = 0; i < 1024; i++)
      display_ptable_entry (get_pde (i), 1, 0, 0);
}

/* A helper function to display entries in a Page Table pointed to by
   the N'th entry in the Page Directory.  If FORCE is non-zero, say
   something even if the Page Table is not accessible.  */
static void
display_page_table (long n, int force)
{
  unsigned long pde = get_pde (n);

  if ((pde & 1) != 0)
    {
      int i;

      printf_filtered ("Page Table pointed to by "
		       "Page Directory entry 0x%lx:\n", n);
      for (i = 0; i < 1024; i++)
	display_ptable_entry (get_pte (pde, i), 0, 0, 0);
      puts_filtered ("\n");
    }
  else if (force)
    printf_filtered ("Page Table not present; value=0x%lx.\n", pde >> 1);
}

static void
go32_pte (char *arg, int from_tty)
{
  long pde_idx = -1L, i;

  if (arg && *arg)
    {
      arg = skip_spaces (arg);

      if (*arg)
	{
	  pde_idx = parse_and_eval_long (arg);
	  if (pde_idx < 0 || pde_idx >= 1024)
	    error (_("Entry %ld is outside valid limits [0..1023]."), pde_idx);
	}
    }

  pdbr = get_cr3 ();
  if (!pdbr)
    puts_filtered ("Access to Page Tables is not supported on this system.\n");
  else if (pde_idx >= 0)
    display_page_table (pde_idx, 1);
  else
    for (i = 0; i < 1024; i++)
      display_page_table (i, 0);
}

static void
go32_pte_for_address (char *arg, int from_tty)
{
  CORE_ADDR addr = 0, i;

  if (arg && *arg)
    {
      arg = skip_spaces (arg);

      if (*arg)
	addr = parse_and_eval_address (arg);
    }
  if (!addr)
    error_no_arg (_("linear address"));

  pdbr = get_cr3 ();
  if (!pdbr)
    puts_filtered ("Access to Page Tables is not supported on this system.\n");
  else
    {
      int pde_idx = (addr >> 22) & 0x3ff;
      int pte_idx = (addr >> 12) & 0x3ff;
      unsigned offs = addr & 0xfff;

      printf_filtered ("Page Table entry for address %s:\n",
		       hex_string(addr));
      display_ptable_entry (get_pte (get_pde (pde_idx), pte_idx), 0, 1, offs);
    }
}

static struct cmd_list_element *info_dos_cmdlist = NULL;

static void
go32_info_dos_command (char *args, int from_tty)
{
  help_list (info_dos_cmdlist, "info dos ", class_info, gdb_stdout);
}

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_go32_nat;

void
_initialize_go32_nat (void)
{
  init_go32_ops ();
  add_target (&go32_ops);

  add_prefix_cmd ("dos", class_info, go32_info_dos_command, _("\
Print information specific to DJGPP (aka MS-DOS) debugging."),
		  &info_dos_cmdlist, "info dos ", 0, &infolist);

  add_cmd ("sysinfo", class_info, go32_sysinfo, _("\
Display information about the target system, including CPU, OS, DPMI, etc."),
	   &info_dos_cmdlist);
  add_cmd ("ldt", class_info, go32_sldt, _("\
Display entries in the LDT (Local Descriptor Table).\n\
Entry number (an expression) as an argument means display only that entry."),
	   &info_dos_cmdlist);
  add_cmd ("gdt", class_info, go32_sgdt, _("\
Display entries in the GDT (Global Descriptor Table).\n\
Entry number (an expression) as an argument means display only that entry."),
	   &info_dos_cmdlist);
  add_cmd ("idt", class_info, go32_sidt, _("\
Display entries in the IDT (Interrupt Descriptor Table).\n\
Entry number (an expression) as an argument means display only that entry."),
	   &info_dos_cmdlist);
  add_cmd ("pde", class_info, go32_pde, _("\
Display entries in the Page Directory.\n\
Entry number (an expression) as an argument means display only that entry."),
	   &info_dos_cmdlist);
  add_cmd ("pte", class_info, go32_pte, _("\
Display entries in Page Tables.\n\
Entry number (an expression) as an argument means display only entries\n\
from the Page Table pointed to by the specified Page Directory entry."),
	   &info_dos_cmdlist);
  add_cmd ("address-pte", class_info, go32_pte_for_address, _("\
Display a Page Table entry for a linear address.\n\
The address argument must be a linear address, after adding to\n\
it the base address of the appropriate segment.\n\
The base address of variables and functions in the debuggee's data\n\
or code segment is stored in the variable __djgpp_base_address,\n\
so use `__djgpp_base_address + (char *)&var' as the argument.\n\
For other segments, look up their base address in the output of\n\
the `info dos ldt' command."),
	   &info_dos_cmdlist);
}

pid_t
tcgetpgrp (int fd)
{
  if (isatty (fd))
    return SOME_PID;
  errno = ENOTTY;
  return -1;
}

int
tcsetpgrp (int fd, pid_t pgid)
{
  if (isatty (fd) && pgid == SOME_PID)
    return 0;
  errno = pgid == SOME_PID ? ENOTTY : ENOSYS;
  return -1;
}
@


1.95
log
@gdb: clean up x86 cpuid implementations

We've currently got 3 files doing open coded implementations of cpuid.
Each has its own set of workarounds and varying levels of how well
they're written and are generally hardcoded to specific cpuid functions.
If you try to build the latest gdb as a PIE on an i386 system, the build
will fail because one of them lacks PIC workarounds (wrt ebx).

Specifically, we have:
common/linux-btrace.c:
	two copies of cpuid asm w/specific args, one has no workarounds
	while the other implicitly does to avoid memcpy
go32-nat.c:
	two copies of cpuid asm w/specific args, one has workarounds to
	avoid memcpy
gdb/testsuite/gdb.arch/i386-cpuid.h:
	one general cpuid asm w/many workarounds copied from older gcc

Fortunately, that last header there is pretty damn good -- it handles
lots of edge cases, the code is nice & tight (uses gcc asm operands
rather than manual movs), and is already almost a general library type
header.  It's also the basis of what is now the public cpuid.h that is
shipped with gcc-4.3+.

So what I've done is pull that test header out and into gdb/common/
(not sure if there's a better place), synced to the version found in
gcc-4.8.0, put a wrapper API around it, and then cut over all the
existing call points to this new header.

Since the func already has support for "is cpuid supported on this proc",
it makes it trivial to push the i386/x86_64 ifdefs down into this wrapper
API too.  Now it can be safely used for all targets and gcc will elide
the unused code for us.

I've verified the gdb.arch testsuite still passes, and this code compiles
for an armv7a host as well as x86_64.  The go32-nat code has been left
ifdef-ed out until someone can test & verify the new stuff works (and if
it doesn't, figure out how to make the new code work).

URL: https://bugs.gentoo.org/467806
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@a1030 3

  /* Override the default name of the GDB init file.  */
  strcpy (gdbinit, "gdb.ini");
@


1.94
log
@	* go32-nat.c (go32_terminal_info): Make 'args' const.
	* inferior.h (child_terminal_info): Update.
	* inflow.c (child_terminal_info): Make 'args' const.
	* target.c (default_terminal_info): Make 'args' const.
	(debug_to_terminal_save_ours): Likewise.
	* target.h (struct target_ops) <to_terminal_info>: Make argument
	const.
@
text
@d99 1
d1145 15
d1176 1
d1202 4
d1213 1
@


1.93
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d879 1
a879 1
go32_terminal_info (char *args, int from_tty)
@


1.92
log
@	* breakpoint.c (catch_syscall_split_args): Use skip_spaces.
	(trace_pass_command): Likewise.
	* cli/cli-cmds.c: Include cli/cli-utils.h.
	(source_command): Use skip-spaces.
	(disassemble_command): Likewise.
	* findcmd.c: Include cli/cli-utils.h.
	(parse_find_args): Use skip_spaces.
	* go32-nat.c: Include cli/cli-utils.h.
	(go32_sldt): Use skip_spaces.
	(go32_sgdt): Likewise.
	(go32_sidt): Likewise.
	(go32_pde): Likewise.
	(go32_pte): Likewise.
	(go32_pte_for_address): Likewise.
	* infcmd.c: Include cli/cli-utils.h.
	(registers_info): Use skip_spaces.
	* linux-tdep.c (read_mapping): Use skip_spaces_const.
	(linux_info_proc): Likewise.
	* linux-thread-db.c: Include cli/cli-utils.h.
	(info_auto_load_libthread_db): Use skip_spaces_const.
	* m32r-rom.c: Include cli/cli-utils.h.
	(m32r_upload_command): Use skip_spaces.
	* maint.c: Include cli/cli-utils.h.
	(maintenance_translate_address): Use skip_spaces.
	* mi/mi-parse.c: Include cli/cli-utils.h.
	(mi_parse_argv): Use skip_spaces.
	(mi_parse): Likewise.
	* minsyms.c: Include cli/cli-utils.h.
	(msymbol_hash_iw): Use skip_spaces_const.
	* objc-lang.c: Include cli/cli-utils.h.
	(parse_selector): Use skip_spaces.
	(parse_method): Likewise.
	* python/python.c: Include cli/cli-utils.h.
	(python_interactive_command)[HAVE_PYTHON]: Use skip_spaces.
	(python_command)[HAVE_PYTHON]: Likewise.
	(python_interactive_command)[!HAVE_PYTHON]: Likewise.
	* remote-m32r-sdi.c: Include cli/cli-utils.h.
	(m32r_load): Use skip_spaces.
	* serial.c: Include cli/cli-utils.h.
	(serial_open): Use skip_spaces_const.
	* stack.c: Include cli/cli-utils.h.
	(parse_frame_specification_1): Use skip_spaces_const.
	* symfile.c: Include cli/cli-utils.h.
	(set_ext_lang_command): Use skip_spaces.
	* symtab.c: Include cli/cli-utils.h.
	(rbreak_command): Use skip_spaces.
	* thread.c (thread_name_command): Use skip_spaces.
	* tracepoint.c (validate_actionline): Use skip_spaces.
	(encode_actions_1): Likewise.
	(trace_find_range_command): Likewise.
	(trace_find_outside_command): Likewise.
	(trace_dump_actions): Likewise.
@
text
@d237 1
a237 1
static void go32_close (int quitting);
d373 1
a373 1
go32_close (int quitting)
@


1.91
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d103 1
d1706 1
a1706 2
      while (*arg && isspace(*arg))
	arg++;
d1776 1
a1776 2
      while (*arg && isspace(*arg))
	arg++;
d1817 1
a1817 2
      while (*arg && isspace(*arg))
	arg++;
d1987 1
a1987 2
      while (*arg && isspace(*arg))
	arg++;
d2037 1
a2037 2
      while (*arg && isspace(*arg))
	arg++;
d2064 1
a2064 2
      while (*arg && isspace(*arg))
	arg++;
@


1.90
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d2 1
a2 2
   Copyright (C) 1997, 1999-2001, 2005-2012 Free Software Foundation,
   Inc.
@


1.89
log
@2012-11-07  Pedro Alves  <palves@@redhat.com>

	* arm-tdep.c: Make defs.h be the first include.
	* coff-pe-read.c: Ditto.
	* gnu-nat.c: Ditto.
	* go32-nat.c: Ditto.
	* i386-nat.c: Ditto.
	* ppcnbsd-nat.c: Ditto.
	* ada-varobj.h: Don't include defs.h.
	* i386-darwin-tdep.h: Ditto.
	* i386-nat.h: Ditto.
@
text
@d1276 3
a1278 3
      sprintf (cpu_string, "%s%s Model %d Stepping %d",
	       intel_p ? "Pentium" : (amd_p ? "AMD" : "ix86"),
	       cpu_brand, cpu_model, cpuid_eax & 0xf);
@


1.88
log
@gdb/
	* go32-nat.c: Declare _initialize_go32_nat.
	* ser-go32.c: Declare _initialize_ser_dos.
	* top.c (do_chdir_cleanup): Add 'static'.
@
text
@d85 2
a88 1
#include "defs.h"
@


1.87
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d2100 3
@


1.86
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d316 2
a317 2
  {0, TARGET_SIGNAL_FPE},
  {1, TARGET_SIGNAL_TRAP},
d321 22
a342 22
  {2, TARGET_SIGNAL_BUS},
  {3, TARGET_SIGNAL_TRAP},
  {4, TARGET_SIGNAL_FPE},
  {5, TARGET_SIGNAL_SEGV},
  {6, TARGET_SIGNAL_ILL},
  {7, TARGET_SIGNAL_EMT},	/* no-coprocessor exception */
  {8, TARGET_SIGNAL_SEGV},
  {9, TARGET_SIGNAL_SEGV},
  {10, TARGET_SIGNAL_BUS},
  {11, TARGET_SIGNAL_SEGV},
  {12, TARGET_SIGNAL_SEGV},
  {13, TARGET_SIGNAL_SEGV},
  {14, TARGET_SIGNAL_SEGV},
  {16, TARGET_SIGNAL_FPE},
  {17, TARGET_SIGNAL_BUS},
  {31, TARGET_SIGNAL_ILL},
  {0x1b, TARGET_SIGNAL_INT},
  {0x75, TARGET_SIGNAL_FPE},
  {0x78, TARGET_SIGNAL_ALRM},
  {0x79, TARGET_SIGNAL_INT},
  {0x7a, TARGET_SIGNAL_QUIT},
  {-1, TARGET_SIGNAL_LAST}
d349 5
a353 5
  {TARGET_SIGNAL_0, -1},
  {TARGET_SIGNAL_ILL, 6},	/* Invalid Opcode */
  {TARGET_SIGNAL_EMT, 7},	/* triggers SIGNOFP */
  {TARGET_SIGNAL_SEGV, 13},	/* GPF */
  {TARGET_SIGNAL_BUS, 17},	/* Alignment Check */
d356 7
a362 7
  {TARGET_SIGNAL_TERM, 0x1b},	/* triggers Ctrl-Break type of SIGINT */
  {TARGET_SIGNAL_FPE, 0x75},
  {TARGET_SIGNAL_INT, 0x79},
  {TARGET_SIGNAL_QUIT, 0x7a},
  {TARGET_SIGNAL_ALRM, 0x78},	/* triggers SIGTIMR */
  {TARGET_SIGNAL_PROF, 0x78},
  {TARGET_SIGNAL_LAST, -1}
d400 1
a400 1
  if (siggnal != TARGET_SIGNAL_0 && siggnal != TARGET_SIGNAL_TRAP)
d403 1
a403 1
	 excepn_map[i].gdb_sig != TARGET_SIGNAL_LAST; i++)
d516 1
a516 1
      status->value.sig = TARGET_SIGNAL_UNKNOWN;
d524 1
a524 1
		  TARGET_SIGNAL_TRAP)
@


1.85
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d241 1
a241 1
			 enum target_signal siggnal);
d312 1
a312 1
    enum target_signal gdb_sig;
d346 1
a346 1
  enum target_signal gdb_sig;
d394 1
a394 1
	     ptid_t ptid, int step, enum target_signal siggnal)
d411 1
a411 1
			 target_signal_to_name (siggnal));
@


1.84
log
@gdb/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* linux-nat.c (linux_nat_new_thread): Change parameter to an lwp
	pointer.
	(linux_nat_prepare_to_resume): New global.
	(lwp_free): New.
	(purge_lwp_list): Use it.
	(add_lwp): Call linux_nat_new_thread even on the first LWP.
	Adjust to interface change.
	(delete_lwp): Call lwp_free instead of xfree.
	(detach_callback, linux_nat_detach, resume_lwp, linux_nat_resume)
	(linux_handle_syscall_trap, linux_handle_extended_wait)
	(linux_nat_filter_event, resume_stopped_resumed_lwps): Call
	linux_nat_prepare_to_resume before resuming.
	(linux_stop_lwp): New.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.
	* linux-nat.h (struct arch_lwp_info): Forward declare.
	(struct lwp_info) <arch_private>: New field.
	(linux_stop_lwp): Declare.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.

	* i386-nat.c (DR_NADDR, DR_STATUS, DR_CONTROL)
	(struct i386_debug_reg_state): Move to i386-nat.h.
	(dr_mirror): Comment.
	(i386_debug_reg_state): New.
	(i386_update_inferior_debug_regs): Simplify.
	(i386_stopped_data_address): Use the debug register state from the
	inferior, not from the local cache.
	* i386-nat.h (struct i386_dr_low_type): Delete reset_addr and
	unset_status fields.  New get_addr and get_control fields.
	(DR_FIRSTADDR, DR_LASTADDR, DR_CONTROL): Moved from i386-nat.c.
	(DR_NADDR, DR_STATUS): New.
	(struct i386_debug_reg_state): Moved from i386-nat.c.

	* amd64-linux-nat.c (struct arch_lwp_info): New.
	(amd64_linux_dr): Delete global.
	(amd64_linux_dr_get_addr): New.
	(amd64_linux_dr_get_control): New.
	(amd64_linux_dr_unset_status): Delete.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_dr_reset_addr): Delete.
	(update_debug_registers_callback): New.
	(amd64_linux_dr_set_control): Reimplement.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_prepare_to_resume): New.
	(amd64_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_amd64_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	amd64_linux_dr_get_control as i386_dr_low.get_control.  Install
	amd64_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	amd64_linux_prepare_to_resume.
	* i386-linux-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(struct arch_lwp_info): New.
	(i386_linux_dr): Delete global.
	(i386_linux_dr_set_control): Reimplement.
	(i386_linux_dr_get_addr): New.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_dr_get_control): New.
	(update_debug_registers_callback): New.
	(i386_linux_dr_unset_status): Delete.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_prepare_to_resume): New.
	(i386_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_i386_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386_linux_dr_get_control as i386_dr_low.get_control.  Install
	i386_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	i386_linux_prepare_to_resume.

	* arm-linux-nat.c (arm_linux_new_thread): Change parameter to an
	lwp pointer.  Adjust.
	* ia64-linux-nat.c (ia64_linux_new_thread): Likewise.
	* mips-linux-nat.c (mips_linux_new_thread): Likewise.
	* ppc-linux-nat.c (ppc_linux_new_thread): Likewise.
	* s390-nat.c (s390_fix_watch_points): Likewise.

	* i386-darwin-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(i386_darwin_dr_reset_addr): Delete.
	(i386_darwin_dr_get_addr): New.
	(i386_darwin_dr_get_control): New.
	* go32-nat.c
	(go32_get_dr7, go32_get_dr): New.
	(init_go32_ops): No longer install i386_dr_low.reset_addr.
	Install go32_get_dr7 as i386_dr_low.get_control.  Install
	go32_get_dr as i386_dr_low.get_addr.
	* i386bsd-nat.c (i386bsd_dr_get): New.
	(i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_status): Use i386bsd_dr_get.
	(i386bsd_dr_get_control): New.
	* i386bsd-nat.h (i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_control): New.
	* i386fbsd-nat.c (_initialize_i386fbsd_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386bsd_dr_get_control as i386_dr_low.get_control.  Install
	i386bsd_dr_get_addr as i386_dr_low.get_addr.
	* windows-nat.c (init_windows_ops): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	cygwin_get_dr7 as i386_dr_low.get_control.  Install cygwin_get_dr
	as i386_dr_low.get_addr.
	(cygwin_get_dr): New.
	(cygwin_get_dr7): New.

gdb/testsuite/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* gdb.mi/watch-nonstop.c: New file.
 	* gdb.mi/mi-watch-nonstop.exp: New file.
@
text
@d2 2
a3 2
   Copyright (C) 1997, 1999, 2000, 2001, 2005, 2006, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
@


1.83
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d804 23
a1009 1
  i386_dr_low.reset_addr = NULL;
d1011 2
@


1.83.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1997, 1999-2001, 2005-2012 Free Software Foundation,
   Inc.
@


1.82
log
@run copyright.sh for 2011.
@
text
@d124 2
a125 2
/* This code will be provided from DJGPP 2.03 on. Until then I code it
   here */
d152 2
a153 2
static void save_npx (void);	/* Save the FPU of the debugged program */
static void load_npx (void);	/* Restore the FPU of the debugged program */
d426 1
a426 1
  a_tss.tss_eflags &= 0xfeff;	/* reset the single-step flag (TF) */
d467 1
a467 1
      a_tss.tss_trap = 0xffff;	/* run_child looks for this */
d480 1
a480 1
     set with the gdb-command "cd ..." */
d499 1
a499 1
      a_tss.tss_eip--;	/* EIP points *after* the INT3 instruction */
d543 2
a544 1
  else if (i386_fp_regnum_p (gdbarch, regno) || i386_fpc_regnum_p (gdbarch, regno))
d574 2
a575 1
  else if (i386_fp_regnum_p (gdbarch, regno) || i386_fpc_regnum_p (gdbarch, regno))
d631 1
a631 1
static cmdline_t child_cmd;	/* parsed child's command line kept here */
d671 2
a672 1
		    _("Cannot allocate redirection storage: not enough memory.\n"));
d702 1
a702 1
    cmdline[0] = 0xff;	/* signal v2loadimage it's a long command */
d825 1
a825 1
  if (oldmode & 0x80)	/* Only for character dev */
d829 1
a829 1
    regs.x.dx = newmode & 0xff;   /* Force upper byte zero, else it fails */
d850 1
a850 1
  inf_mode_valid = 0;	/* reinitialize, in case they are restarting child */
d895 2
a896 2
  /* set the console device of the inferior to whatever mode
     (raw or cooked) we found it last time */
d909 1
a909 1
     terminal mode to be restored when it is resumed */
d1000 2
a1001 1
		    _("Cannot allocate redirection storage: not enough memory.\n"));
d1039 1
a1039 1
	  if (needed > blen)	/* should never happen */
d1263 1
a1263 1
	    puts_filtered ("No FPU "); /* it's unusual to not have an FPU */
d1332 2
a1333 1
    printf_filtered ("Windows Version................Windows NT family (W2K/XP/W2K3/Vista/W2K8)\n");
d1349 2
a1350 1
      printf_filtered ("DPMI Host......................%s v%d.%d (capabilities: %#x)\n",
d1361 2
a1362 1
  printf_filtered ("DPMI Info......................%s-bit DPMI, with%s Virtual Memory support\n",
d1376 2
a1377 1
      printf_filtered ("Protection.....................Ring %d (in %s), with%s I/O protection\n",
d1628 2
a1629 1
				 descr.stype & 2 ? "Read/Write," : "Read-Only, ",
d1759 2
a1760 1
	    error (_("Invalid GDT entry 0x%03lx: not an integral multiple of 8."),
d1807 1
a1807 1
  if (max_entry > 0x100)	/* no more than 256 entries */
d1870 1
a1870 1
#if 0  /* not fullly supported yet */
d1924 1
a1924 1
      pde &= ~0xfff;	/* clear non-address bits */
d1978 2
a1979 1
    puts_filtered ("Access to Page Directories is not supported on this system.\n");
d1999 2
a2000 1
      printf_filtered ("Page Table pointed to by Page Directory entry 0x%lx:\n", n);
@


1.81
log
@	Remove remaining "%ll" uses.
	* go32-nat.c (go32_pte_for_address): Replace "0x%llx" using
	hex_string call.
	* rs6000-nat.c (rs6000_ptrace64): Idem.
	* solib-pa64.c (pa64_current_sos): Idem.
	* solib-spu.c (spu_current_sos): Idem.
	* linux-nat.c (linux_nat_find_memory_regions): Replace "%lld" using
	plongest call.
	* nto-procfs.c (procfs_meminfo): Replace "0x%016llx" using
	phex (VAR, 8) call.
	* sh64-tdep.c (sh64_show_media_regs): Idem.
@
text
@d2 2
a3 2
   Copyright (C) 1997, 1999, 2000, 2001, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.
@


1.80
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2050 2
a2051 2
      printf_filtered ("Page Table entry for address 0x%llx:\n",
		       (unsigned long long)addr);
@


1.79
log
@	* go32-nat.c (go32_create_inferior): Use inferior_appeared, not
	inferior_appeared_silent.
	* remote-sim.c (gdbsim_create_inferior): Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1999, 2000, 2001, 2005, 2006, 2007, 2008, 2009
@


1.78
log
@2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	Add base multi-executable/process support to GDB.

	gdb/
	* Makefile.in (SFILES): Add progspace.c.
	(COMMON_OBS): Add progspace.o.
	* progspace.h: New.
	* progspace.c: New.

	* breakpoint.h (struct bp_target_info) <placed_address_space>: New
	field.
	(struct bp_location) <pspace>: New field.
	(struct breakpoint) <pspace>: New field.
	(bpstat_stop_status, breakpoint_here_p)
	(moribund_breakpoint_here_p, breakpoint_inserted_here_p)
	(regular_breakpoint_inserted_here_p)
	(software_breakpoint_inserted_here_p, breakpoint_thread_match)
	(set_default_breakpoint): Adjust prototypes.
	(remove_breakpoints_pid, breakpoint_program_space_exit): Declare.
	(insert_single_step_breakpoint, deprecated_insert_raw_breakpoint):
	Adjust prototypes.
	* breakpoint.c (executing_startup): Delete.
	(default_breakpoint_sspace): New.
	(breakpoint_restore_shadows): Skip if the address space doesn't
	match.
	(update_watchpoint): Record the frame's program space in the
	breakpoint location.
	(insert_bp_location): Record the address space in target_info.
	Adjust to pass the symbol space to solib_name_from_address.
	(breakpoint_program_space_exit): New.
	(insert_breakpoint_locations): Switch the symbol space and thread
	when inserting breakpoints.  Don't insert breakpoints in a vfork
	parent waiting for vfork done if we're not attached to the vfork
	child.
	(remove_breakpoints_pid): New.
	(reattach_breakpoints): Switch to a thread of PID.  Ignore
	breakpoints of other symbol spaces.
	(create_internal_breakpoint): Store the symbol space in the sal.
	(create_longjmp_master_breakpoint): Iterate over all symbol
	spaces.
	(update_breakpoints_after_exec): Ignore breakpoints for other
	symbol spaces.
	(remove_breakpoint): Rename to ...
	(remove_breakpoint_1): ... this.  Pass the breakpoints symbol
	space to solib_name_from_address.
	(remove_breakpoint): New.
	(mark_breakpoints_out): Ignore breakpoints from other symbol
	spaces.
	(breakpoint_init_inferior): Ditto.
	(breakpoint_here_p): Add an address space argument and adjust to
	use breakpoint_address_match.
	(moribund_breakpoint_here_p): Ditto.
	(regular_breakpoint_inserted_here_p): Ditto.
	(breakpoint_inserted_here_p): Ditto.
	(software_breakpoint_inserted_here_p): Ditto.
	(breakpoint_thread_match): Ditto.
	(bpstat_check_location): Ditto.
	(bpstat_stop_status): Ditto.
	(print_breakpoint_location): If there's a location to print,
	switch the current symbol space.
	(print_one_breakpoint_location): Add `allflag' argument.
	(print_one_breakpoint): Ditto.	Adjust.
	(do_captured_breakpoint_query): Adjust.
	(breakpoint_1): Adjust.
	(breakpoint_has_pc): Also match the symbol space.
	(describe_other_breakpoints): Add a symbol space argument and
	adjust.
	(set_default_breakpoint): Add a symbol space argument.	Set
	default_breakpoint_sspace.
	(breakpoint_address_match): New.
	(check_duplicates_for): Add an address space argument, and adjust.
	(set_raw_breakpoint): Record the symbol space in the location and
	in the breakpoint.
	(set_longjmp_breakpoint): Skip longjmp master breakpoints from
	other symbol spaces.
	(remove_thread_event_breakpoints, remove_solib_event_breakpoints)
	(disable_breakpoints_in_shlibs): Skip breakpoints from other
	symbol spaces.
	(disable_breakpoints_in_unloaded_shlib): Match symbol spaces.
	(create_catchpoint): Set the symbol space in the sal.
	(disable_breakpoints_before_startup): Skip breakpoints from other
	symbol spaces.	Set executing_startup in the current symbol space.
	(enable_breakpoints_after_startup): Clear executing_startup in the
	current symbol space.  Skip breakpoints from other symbol spaces.
	(clone_momentary_breakpoint): Also copy the symbol space.
	(add_location_to_breakpoint): Set the location's symbol space.
	(bp_loc_is_permanent): Switch thread and symbol space.
	(create_breakpoint): Adjust.
	(expand_line_sal_maybe): Expand comment to mention symbol spaces.
	Switch thread and symbol space when reading memory.
	(parse_breakpoint_sals): Set the symbol space in the sal.
	(break_command_really): Ditto.
	(skip_prologue_sal): Switch and space.
	(resolve_sal_pc): Ditto.
	(watch_command_1): Record the symbol space in the sal.
	(create_ada_exception_breakpoint): Adjust.
	(clear_command): Adjust.  Match symbol spaces.
	(update_global_location_list): Use breakpoint_address_match.
	(breakpoint_re_set_one): Switch thread and space.
	(breakpoint_re_set): Save symbol space.
	(breakpoint_re_set_thread): Also reset the symbol space.
	(deprecated_insert_raw_breakpoint): Add an address space argument.
	Adjust.
	(insert_single_step_breakpoint): Ditto.
	(single_step_breakpoint_inserted_here_p): Ditto.
	(clear_syscall_counts): New.
	(_initialize_breakpoint): Install it as inferior_exit observer.

	* exec.h: Include "progspace.h".
	(exec_bfd, exec_bfd_mtime): New defines.
	(exec_close): Declare.
	* exec.c: Include "gdbthread.h" and "progspace.h".
	(exec_bfd, exec_bfd_mtime, current_target_sections_1): Delete.
	(using_exec_ops): New.
	(exec_close_1): Rename to exec_close, and make public.
	(exec_close): Rename to exec_close_1, and adjust all callers.  Add
	description.  Remove target sections and close executables from
	all program spaces.
	(exec_file_attach): Add comment.
	(add_target_sections): Check on `using_exec_ops' to check if the
	target should be pushed.
	(remove_target_sections): Only unpush the target if there are no
	more target sections in any symbol space.
	* gdbcore.h: Include "exec.h".
	(exec_bfd, exec_bfd_mtime): Remove declarations.

	* frame.h (get_frame_program_space, get_frame_address_space)
	(frame_unwind_program_space): Declare.
	* frame.c (struct frame_info) <pspace, aspace>: New fields.
	(create_sentinel_frame): Add program space argument.  Set the
	pspace and aspace fields of the frame object.
	(get_current_frame, create_new_frame): Adjust.
	(get_frame_program_space): New.
	(frame_unwind_program_space): New.
	(get_frame_address_space): New.
	* stack.c (print_frame_info): Adjust.
	(print_frame): Use the frame's program space.

	* gdbthread.h (any_live_thread_of_process): Declare.
	* thread.c (any_live_thread_of_process): New.
	(switch_to_thread): Switch the program space as well.
	(restore_selected_frame): Don't warn if trying to restore frame
	level 0.

	* inferior.h: Include "progspace.h".
	(detach_fork): Declare.
	(struct inferior) <removable, aspace, pspace>
	<vfork_parent, vfork_child, pending_detach>
	<waiting_for_vfork_done>: New fields.
	<terminal_info>: Remove field.
	<data, num_data>: New fields.
	(register_inferior_data, register_inferior_data_with_cleanup)
	(clear_inferior_data, set_inferior_data, inferior_data): Declare.
	(exit_inferior, exit_inferior_silent, exit_inferior_num_silent)
	(inferior_appeared): Declare.
	(find_inferior_pid): Typo.
	(find_inferior_id, find_inferior_for_program_space): Declare.
	(set_current_inferior, save_current_inferior, prune_inferiors)
	(number_of_inferiors): Declare.
	(inferior_list): Declare.
	* inferior.c: Include "gdbcore.h" and "symfile.h".
	(inferior_list): Make public.
	(delete_inferior_1): Always delete thread silently.
	(find_inferior_id): Make public.
	(current_inferior_): New.
	(current_inferior): Use it.
	(set_current_inferior): New.
	(restore_inferior): New.
	(save_current_inferior): New.
	(free_inferior): Free the per-inferior data.
	(add_inferior_silent): Allocate per-inferior data.
	Call inferior_appeared.
	(delete_threads_of_inferior): New.
	(delete_inferior_1): Adjust interface to take an inferior pointer.
	(delete_inferior): Adjust.
	(delete_inferior_silent): Adjust.
	(exit_inferior_1): New.
	(exit_inferior): New.
	(exit_inferior_silent): New.
	(exit_inferior_num_silent): New.
	(detach_inferior): Adjust.
	(inferior_appeared): New.
	(discard_all_inferiors): Adjust.
	(find_inferior_id): Make public.  Assert pid is not zero.
	(find_inferior_for_program_space): New.
	(have_inferiors): Check if we have any inferior with pid not zero.
	(have_live_inferiors): Go over all pushed targets looking for
	process_stratum.
	(prune_inferiors): New.
	(number_of_inferiors): New.
	(print_inferior): Add executable column.  Print vfork parent/child
	relationships.
	(inferior_command): Adjust to cope with not running inferiors.
	(remove_inferior_command): New.
	(add_inferior_command): New.
	(clone_inferior_command): New.
	(struct inferior_data): New.
	(struct inferior_data_registration): New.
	(struct inferior_data_registry): New.
	(inferior_data_registry): New.
	(register_inferior_data_with_cleanup): New.
	(register_inferior_data): New.
	(inferior_alloc_data): New.
	(inferior_free_data): New.
	(clear_inferior_data): New.
	(set_inferior_data): New.
	(inferior_data): New.
	(initialize_inferiors): New.
	(_initialize_inferiors): Register "add-inferior",
	"remove-inferior" and "clone-inferior" commands.

	* objfiles.h: Include "progspace.h".
	(struct objfile) <pspace>: New field.
	(symfile_objfile, object_files): Don't declare.
	(ALL_PSPACE_OBJFILES): New.
	(ALL_PSPACE_OBJFILES_SAFE): New.
	(ALL_OBJFILES, ALL_OBJFILES_SAFE): Adjust.
	(ALL_PSPACE_SYMTABS): New.
	(ALL_PRIMARY_SYMTABS): Adjust.
	(ALL_PSPACE_PRIMARY_SYMTABS): New.
	(ALL_PSYMTABS): Adjust.
	(ALL_PSPACE_PSYMTABS): New.
	* objfiles.c (object_files, symfile_objfile): Delete.
	(struct objfile_sspace_info): New.
	(objfiles_pspace_data): New.
	(objfiles_pspace_data_cleanup): New.
	(get_objfile_pspace_data): New.
	(objfiles_changed_p): Delete.
	(allocate_objfile): Set the objfile's program space.  Adjust to
	reference objfiles_changed_p in pspace data.
	(free_objfile): Adjust to reference objfiles_changed_p in pspace
	data.
	(objfile_relocate): Ditto.
	(update_section_map): Add pspace argument.  Adjust to iterate over
	objfiles in the passed in pspace.
	(find_pc_section): Delete sections and num_sections statics.
	Adjust to refer to program space's objfiles_changed_p.	Adjust to
	refer to sections and num_sections store in the objfile's pspace
	data.
	(objfiles_changed): Adjust to reference objfiles_changed_p in
	pspace data.
	(_initialize_objfiles): New.
	* linespec.c (decode_all_digits, decode_dollar): Set the sal's
	program space.
	* source.c (current_source_pspace): New.
	(get_current_source_symtab_and_line): Set the sal's program space.
	(set_current_source_symtab_and_line): Set current_source_pspace.
	(select_source_symtab): Ditto.	Use ALL_OBJFILES.
	(forget_cached_source_info): Iterate over all program spaces.
	* symfile.c (clear_symtab_users): Adjust.
	* symmisc.c (print_symbol_bcache_statistics): Iterate over all
	program spaces.
	(print_objfile_statistics): Ditto.
	(maintenance_print_msymbols): Ditto.
	(maintenance_print_objfiles): Ditto.
	(maintenance_info_symtabs): Ditto.
	(maintenance_info_psymtabs): Ditto.
	* symtab.h (SYMTAB_PSPACE): New.
	(struct symtab_and_line) <pspace>: New field.
	* symtab.c (init_sal): Clear the sal's program space.
	(find_pc_sect_symtab): Set the sal's program space.  Switch thread
	and space.
	(append_expanded_sal): Add program space argument.  Iterate over
	all program spaces.
	(expand_line_sal): Iterate over all program spaces.  Switch
	program space.

	* target.h (enum target_waitkind) <TARGET_WAITKIND_VFORK_DONE>: New.
	(struct target_ops) <to_thread_address_space>: New field.
	(target_thread_address_space): Define.
	* target.c (target_detach): Only remove breakpoints from the
	inferior we're detaching.
	(target_thread_address_space): New.

	* defs.h (initialize_progspace): Declare.
	* top.c (gdb_init): Call it.

	* solist.h (struct so_list) <sspace>: New field.
	* solib.h (struct program_space): Forward declare.
	(solib_name_from_address): Adjust prototype.
	* solib.c (so_list_head): Replace with a macro referencing the
	program space.
	(update_solib_list): Set the so's program space.
	(solib_name_from_address): Add a program space argument and adjust.

	* solib-svr4.c (struct svr4_info) <pid>: Delete field.
	<interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low>
	<interp_plt_sect_high>: New fields.
	(svr4_info_p, svr4_info): Delete.
	(solib_svr4_sspace_data): New.
	(get_svr4_info): Rewrite.
	(svr4_sspace_data_cleanup): New.
	(open_symbol_file_object): Adjust.
	(svr4_default_sos): Adjust.
	(svr4_fetch_objfile_link_map): Adjust.
	(interp_text_sect_low, interp_text_sect_high, interp_plt_sect_low)
	(interp_plt_sect_high): Delete.
	(svr4_in_dynsym_resolve_code): Adjust.
	(enable_break): Adjust.
	(svr4_clear_solib): Revert bit that removed the svr4_info here,
	and reinstate clearing debug_base, debug_loader_offset_p,
	debug_loader_offset and debug_loader_name.
	(_initialize_svr4_solib): Register solib_svr4_pspace_data.  Don't
	install an inferior_exit observer anymore.

	* printcmd.c (struct display) <pspace>: New field.
	(display_command): Set the display's sspace.
	(do_one_display): Match the display's sspace.
	(display_uses_solib_p): Ditto.

	* linux-fork.c (detach_fork): Moved to infrun.c.
	(_initialize_linux_fork): Moved "detach-on-fork" command to
	infrun.c.
	* infrun.c (detach_fork): Moved from linux-fork.c.
	(proceed_after_vfork_done): New.
	(handle_vfork_child_exec_or_exit): New.
	(follow_exec_mode_replace, follow_exec_mode_keep)
	(follow_exec_mode_names, follow_exec_mode_string)
	(show_follow_exec_mode_string): New.
	(follow_exec): New.  Reinstate the mark_breakpoints_out call.
	Remove shared libraries before attaching new executable.  If user
	wants to keep the inferior, keep it.
	(displaced_step_fixup): Adjust to pass an address space to the
	breakpoints module.
	(resume): Ditto.
	(clear_proceed_status): In all-stop mode, always clear the proceed
	status of all threads.
	(prepare_to_proceed): Adjust to pass an address space to the
	breakpoints module.
	(proceed): Ditto.
	(adjust_pc_after_break): Ditto.
	(handle_inferior_event): When handling a process exit, switch the
	program space to the inferior's that had exited.  Call
	handle_vfork_child_exec_or_exit.  Adjust to pass an address space
	to the breakpoints module.  In non-stop mode, when following a
	fork and detach-fork is off, also resume the other branch.  Handle
	TARGET_WAITKIND_VFORK_DONE.  Set the program space in sals.
	(normal_stop): Prune inferiors.
	(_initialize_infrun): Install the new "follow-exec-mode" command.
	"detach-on-fork" moved here.

	* regcache.h (get_regcache_aspace): Declare.
	* regcache.c (struct regcache) <aspace>: New field.
	(regcache_xmalloc): Clear the aspace.
	(get_regcache_aspace): New.
	(regcache_cpy): Copy the aspace field.
	(regcache_cpy_no_passthrough): Ditto.
	(get_thread_regcache): Fetch the thread's address space from the
	target, and store it in the regcache.

	* infcall.c (call_function_by_hand): Set the sal's pspace.

	* arch-utils.c (default_has_shared_address_space): New.
	* arch-utils.h (default_has_shared_address_space): Declare.

	* gdbarch.sh (has_shared_address_space): New.
	* gdbarch.h, gdbarch.c: Regenerate.

	* linux-tdep.c: Include auxv.h, target.h, elf/common.h.
	(linux_has_shared_address_space): New.
	(_initialize_linux_tdep): Declare.

	* arm-tdep.c (arm_software_single_step): Pass the frame's address
	space to insert_single_step_breakpoint.
	* arm-linux-tdep.c (arm_linux_software_single_step): Pass the
	frame's pspace to breakpoint functions.
	* cris-tdep.c (crisv32_single_step_through_delay): Ditto.
	(cris_software_single_step): Ditto.
	* mips-tdep.c (deal_with_atomic_sequence): Add frame argument.
	Pass the frame's pspace to breakpoint functions.
	(mips_software_single_step): Adjust.
	(mips_single_step_through_delay): Adjust.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Adjust.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Adjust.
	* solib-irix.c (enable_break): Adjust to pass the current frame's
	address space to breakpoint functions.
	* sparc-tdep.c (sparc_software_single_step): Ditto.
	* spu-tdep.c (spu_software_single_step): Ditto.
	* alpha-tdep.c (alpha_software_single_step): Ditto.
	* record.c (record_wait): Adjust to pass an address space to the
	breakpoints module.

	* fork-child.c (fork_inferior): Set the new inferior's program and
	address spaces.
	* inf-ptrace.c (inf_ptrace_follow_fork): Copy the parent's program
	and address spaces.
	(inf_ptrace_attach): Set the inferior's program and address spaces.
	* linux-nat.c: Include "solib.h".
	(linux_child_follow_fork): Manage parent and child's program and
	address spaces.	 Clone the parent's program space if necessary.
	Don't wait for the vfork to be done here.  Refuse to resume if
	following the vfork parent while leaving the child stopped.
	(resume_callback): Don't resume a vfork parent.
	(linux_nat_resume): Also check for pending events in the
	lp->waitstatus field.
	(linux_handle_extended_wait): Report TARGET_WAITKIND_VFORK_DONE
	events to the core.
	(stop_wait_callback): Don't wait for SIGSTOP on vfork parents.
	(cancel_breakpoint): Adjust.
	* linux-thread-db.c (thread_db_wait): Don't remove thread event
	breakpoints here.
	(thread_db_mourn_inferior): Don't mark breakpoints out here.
	Remove thread event breakpoints after mourning.
	* corelow.c: Include progspace.h.
	(core_open): Set the inferior's program and address spaces.
	* remote.c (remote_add_inferior): Set the new inferior's program
	and address spaces.
	(remote_start_remote): Update address spaces.
	(extended_remote_create_inferior_1): Don't init the thread list if
	we already debugging other inferiors.
	* darwin-nat.c (darwin_attach): Set the new inferior's program and
	address spaces.
	* gnu-nat.c (gnu_attach): Ditto.
	* go32-nat.c (go32_create_inferior): Ditto.
	* inf-ttrace.c (inf_ttrace_follow_fork, inf_ttrace_attach): Ditto.
	* monitor.c (monitor_open): Ditto.
	* nto-procfs.c (procfs_attach, procfs_create_inferior): Ditto.
	* procfs.c (do_attach): Ditto.
	* windows-nat.c (do_initial_windows_stuff): Ditto.

	* inflow.c (inferior_process_group)
	(terminal_init_inferior_with_pgrp, terminal_inferior,
	(terminal_ours_1, inflow_inferior_exit, copy_terminal_info)
	(child_terminal_info, new_tty_postfork, set_sigint_trap): Adjust
	to use per-inferior data instead of inferior->terminal_info.
	(inflow_inferior_data): New.
	(inflow_new_inferior): Delete.
	(inflow_inferior_data_cleanup): New.
	(get_inflow_inferior_data): New.

	* mi/mi-interp.c (mi_new_inferior): Rename to...
	(mi_inferior_appeared): ... this.
	(mi_interpreter_init): Adjust.

	* tui/tui-disasm.c: Include "progspace.h".
	(tui_set_disassem_content): Pass an address space to
	breakpoint_here_p.

	* NEWS: Mention multi-program debugging support.  Mention new
	commands "add-inferior", "clone-inferior", "remove-inferior",
	"maint info program-spaces", and new option "set
	follow-exec-mode".

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* observer.texi (new_inferior): Rename to...
	(inferior_appeared): ... this.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/testsuite/
	* gdb.base/foll-vfork.exp: Adjust to spell out "follow-fork".
	* gdb.base/foll-exec.exp: Adjust to expect a process id before
	"Executing new program".
	* gdb.base/foll-fork.exp: Adjust to spell out "follow-fork".
	* gdb.base/multi-forks.exp: Ditto.  Adjust to the inferior being
	left listed after having been killed.
	* gdb.base/attach.exp: Adjust to spell out "symbol-file".
	* gdb.base/maint.exp: Adjust test.

	* Makefile.in (ALL_SUBDIRS): Add gdb.multi.
	* gdb.multi/Makefile.in: New.
	* gdb.multi/base.exp: New.
	* gdb.multi/goodbye.c: New.
	* gdb.multi/hangout.c: New.
	* gdb.multi/hello.c: New.
	* gdb.multi/bkpt-multi-exec.c: New.
	* gdb.multi/bkpt-multi-exec.exp: New.
	* gdb.multi/crashme.c: New.

2009-10-19  Pedro Alves	 <pedro@@codesourcery.com>
	    Stan Shebs	<stan@@codesourcery.com>

	gdb/doc/
	* gdb.texinfo (Inferiors): Rename node to ...
	(Inferiors and Programs): ... this.  Mention running multiple
	programs in the same debug session.
	<info inferiors>: Mention the new 'Executable' column if "info
	inferiors".  Update examples.  Document the "add-inferior",
	"clone-inferior", "remove-inferior" and "maint info
	program-spaces" commands.
	(Process): Rename node to...
	(Forks): ... this.  Document "set|show follow-exec-mode".
@
text
@d719 1
a719 1
  inferior_appeared_silent (inf, SOME_PID);
@


1.77
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d652 1
d718 2
a719 1
  add_inferior_silent (SOME_PID);
@


1.76
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d971 5
a975 5
  go32_ops.to_has_all_memory = 1;
  go32_ops.to_has_memory = 1;
  go32_ops.to_has_stack = 1;
  go32_ops.to_has_registers = 1;
  go32_ops.to_has_execution = 1;
@


1.75
log
@	Remove all i386 debug register low level macros in config nm files.
	(I386_DR_LOW_SET_ADDR, I386_DR_LOW_RESET_ADDR): Remove.
	(I386_DR_LOW_GET_STATUS, I386_DR_LOW_SET_CONTROL): Remove.
	(I386_USE_GENERIC_WATCHPOIINTS): Remove.

	* i386-nat.h: New file (adapted from config/i386/nm-i386.h).
	(struct i386_dr_low_type): New type.
	(i386_dr_low): New global variable.
	* i386-nat.c (TARGET_HAS_DR_LEN_8): Update macro.
	(i386_insert_aligned_watchpoint): Replace i386 dr low macros by
	i386_dr_low struct variable fields.
	(i386_remove_aligned_watchpoint): Likewise.
	(i386_stopped_data_address): Likewise.
	(i386_stopped_by_hwbp): Likewise.
	(show_debug_regs_command_added): New static variable.
	(add_show_debug_regs_command): New static function.
	(i386_use_watchpoints): Call add_show_debug_regs_command if not done.
	(i386_set_debug_register_length): New function.
	(_initialize_i386_nat): Delete.

	* amd64-linux-nat.c: Include "i386-nat.h".
	(amd64_linux_dr_set_control):  Change to static.
	(amd64_linux_dr_get_status): Change to static.
	(amd64_linux_dr_set_addr,amd64_linux_dr_reset_addr): Likewise.
	(_initialize_amd64_linux_nat): Set i386_dr_low variable fields.

	* go32-nat.c: Include "i386-nat.h".
	(go32_set_addr): Change to static.
	(go32_set_dr7): Change to static. Change arg type to unisgned long.
	(go32_get_dr6): Change to static. Change return type to unisnged long.
	(init_go32_ops):  Set i386_dr_low variable fields.
	* i386-linux-nat.c: Include "i386-nat.h".
	(i386_linux_dr_set_control, i386_linux_dr_get_status): Change to static.
	(i386_linux_dr_set_addr, i386_linux_dr_reset_addr): Idem.
	(_initialize_i386_linux_nat):  Set i386_dr_low variable fields.
	* i386bsd-nat.h: Declare functions used for
	i386_dr_low fields in i386fbsd-nat.c.
	* i386fbsd-nat.c: Include "i386-nat.h".
	(_initialize_i386fbsd_nat): Set i386_dr_low variable fields.
	* windows-nat.c: Include "i386-nat.h".
	(cygwin_set_dr, cygwin_get_dr6, cygwin_set_dr7): Add prototypes.
	Change to static.
	(cygwin_get_dr6): Change return type to unisnged long.
	(cygwin_set_dr7): Change arg type to unisgned long.
	(init_windows_ops): Set i386_dr_low function fields.

	* amd64-windows-nat.c (_initialize_amd64_windows_nat): Call
	i386_set_debug_register_length.
	* i386-windows-nat.c (_initialize_i386_windows_nat): Likewise.

	* config/i386/nm-cygwin.h: Remove all I386_* macros.
	* config/i386/nm-cygwin64.h: Likewise.
	* config/i386/nm-fbsd.h: Likewise.
	* config/i386/nm-linux.h: Likewise.
	* config/i386/nm-i386.h: Remove completely.
	* config/i386/nm-go32.h: Remove completely.
	* config/i386/nm-linux64.h: Remove completely.
	* config/i386/go32.mh (NAT_FILE): Remove entry.
	* config/i386/linux64.h (NAT_FILE): Change to config/nm-linux.h.
@
text
@d419 1
a419 1
	   ptid_t ptid, struct target_waitstatus *status)
@


1.74
log
@	* go32-nat.c (go32_stop): Delete.
	(go32_kill_inferior): Rewrite to only call go32_mourn_inferior.
	(go32_create_inferior): Don't call go32_stop or
	go32_kill_inferior.
	(go32_mourn_inferior): Inline go32_stop and go32_kill_inferior
	here.
	(init_go32_ops): Don't register go32_stop.
@
text
@d88 1
d772 1
a772 1
void
d784 2
a785 2
void
go32_set_dr7 (unsigned val)
d793 1
a793 1
unsigned
d979 7
@


1.73
log
@
	* go32-nat.c: Add comments about dirty secrets of DJGPP debugging.
@
text
@a251 1
static void go32_stop (ptid_t);
a636 11
go32_stop (ptid_t ptid)
{
  normal_stop ();
  cleanup_client ();
  ptid = inferior_ptid;
  inferior_ptid = null_ptid;
  delete_thread_silent (ptid);
  prog_has_started = 0;
}

static void
d639 1
a639 6
  redir_cmdline_delete (&child_cmd);
  resume_signal = -1;
  resume_is_step = 0;
  if (!ptid_equal (inferior_ptid, null_ptid))
    delete_thread_silent (inferior_ptid);
  unpush_target (&go32_ops);
a656 5
  if (prog_has_started)
    {
      go32_stop (inferior_ptid);
      go32_kill_inferior (ops);
    }
d730 8
d746 7
a752 1
  go32_kill_inferior (ops);
a966 1
  go32_ops.to_stop = go32_stop;
@


1.72
log
@
	* go32-nat.c (go32_pid_to_str): Call normal_pid_to_str instead of
	printing a bogus "Thread <main>".
	(go32_thread_alive): Don't return 1 for null_ptid.
@
text
@d21 64
@


1.71
log
@
	Set default host and target charsets in the DJGPP port.

	* config/djgpp/config.sed (am_cv_langinfo_codeset)
	(bash_cv_langinfo_codeset, ac_cv_header_nl_types_h): Set to "yes"
	in all configure scripts that define ac_cv_env_CPP_value.
	* go32-nat.c (dos_codepage, nl_langinfo): New functions.
	Include langinfo.h.
	* config/djgpp/nl_types.h: New file.
	* config/djgpp/langinfo.h: New file.
	* config/i386/go32.mh (MH_CFLAGS): Add $(srcdir)/config/djgpp.
@
text
@d873 1
a873 1
  return 1;
d879 1
a879 3
  static char buf[64];
  xsnprintf (buf, sizeof buf, "Thread <main>");
  return buf;
@


1.70
log
@
	* go32-nat.c (go32_sysinfo): Check if the call to
	__dpmi_get_capabilities fills the buffer with information, and
	don't use the buffer if not.
@
text
@d56 2
d943 41
@


1.69
log
@
	* go32-nat.c (go32_sysinfo): Update list of Windows versions of
	the NT family.
@
text
@d986 4
d997 1
a997 2
  int dpmi_vendor_available =
    __dpmi_get_capabilities (&dpmi_flags, dpmi_vendor_info);
d1224 9
a1232 1
  if (dpmi_vendor_available == 0)
d1244 2
@


1.68
log
@	* go32-nat.c (go32_attach, go32_detach:) Fix prototypes to be
	consistent with the change from 2009-03-17.
@
text
@d1219 1
a1219 1
    printf_filtered ("Windows Version................Windows NT or Windows 2000\n");
@


1.67
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d170 2
a171 2
static void go32_attach (char *args, int from_tty);
static void go32_detach (char *args, int from_tty);
@


1.66
log
@        * go32-nat.c (go32_create_inferior): Add missing ops parameter.
@
text
@d187 1
a187 1
static void go32_kill_inferior (void);
d583 1
a583 1
go32_kill_inferior (void)
d611 1
a611 1
      go32_kill_inferior ();
d694 1
a694 1
  go32_kill_inferior ();
@


1.65
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d594 2
a595 1
go32_create_inferior (char *exec_file, char *args, char **env, int from_tty)
@


1.64
log
@	* Extend use of i386_use_watchpoints to all i386 native files
	using hardware watchpoints.
	go32-nat.c (init_go32_ops): Call i386_use_watchpoints.
	i386fbsd-nat.c (_initialize_i386fbsd_nat): Ditto.
	windows-nat.c (init_windows_ops): Ditto.
	config/i386/nm-cygwin.h: Define I386_WATCHPOINTS_IN_TARGET_VECTOR.
	config/i386/nm-cygwin64.h: Ditto.
	config/i386/nm-fbsd.h: Ditto.
	config/i386/nm-go32.h: Ditto.
@
text
@d172 5
a176 3
static void go32_resume (ptid_t ptid, int step,
                         enum target_signal siggnal);
static void go32_fetch_registers (struct regcache *, int regno);
d178 2
a179 1
static void go32_store_registers (struct regcache *, int regno);
d327 2
a328 1
go32_resume (ptid_t ptid, int step, enum target_signal siggnal)
d485 2
a486 1
go32_fetch_registers (struct regcache *regcache, int regno)
d515 2
a516 1
go32_store_registers (struct regcache *regcache, int regno)
d868 1
a868 1
go32_thread_alive (ptid_t ptid)
@


1.63
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@d913 3
@


1.62
log
@        Updated copyright notices for most files.
@
text
@a173 2
static ptid_t go32_wait (ptid_t ptid,
                               struct target_waitstatus *status);
d348 2
a349 1
go32_wait (ptid_t ptid, struct target_waitstatus *status)
d868 1
a868 1
go32_pid_to_str (ptid_t ptid)
@


1.61
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1999, 2000, 2001, 2005, 2006, 2007, 2008
@


1.60
log
@	* gnu-nat.c (gnu_attach): Add process to inferiors table.
	(gnu_detach): Remove it.
	* go32-nat.c (go32_create_inferior): Add process to gdb's inferior
	table.
	* inf-ptrace.c (inf_ptrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ptrace_attach): Add new process to inferior table.
	(inf_ptrace_detach): Remove it.
	* inf-ttrace.c (inf_ttrace_follow_fork): Delete and add inferiors
	to inferior table accordingly.
	(inf_ttrace_attach): Add process to inferior table.
	(inf_ttrace_detach): Remove it.
	* linux-fork.c (init_fork_list): Delete any left over inferior.
	(linux_fork_mourn_inferior, detach_fork_command): Also delete
	processes from inferior list.
	* monitor.c (monitor_open): Add process to inferior list.
	(monitor_close): Remove it.
	* nto-procfs.c (procfs_attach): Add process to inferior list.
	Find threads after pushing the target.
	(procfs_detach): Remove process from inferior list.
	(procfs_create_inferior): Add process to inferior list.
	* procfs.c (procfs_detach): Remove process from inferior list.
	(do_attach): Add process to inferior list.
	* remote-sim.c (sim_create_inferior): Add process to inferior list.
	(gdbsim_close): Remove it.
	* target.c (generic_mourn_inferior): If inferior_ptid is not
	null_ptid, remove the corresponding inferior from inferior list.
	* win32-nat.c (do_initial_win32_stuff): Add process to inferior list.
	(win32_detach): Remove it.
	* linux-nat.c (linux_child_follow_fork): Delete and add inferiors
	to inferior list accordingly.
	* fork-child.c (fork_inferior): Add process to inferior list.
	* corelow.c (CORELOW_PID): Define.
	(core_close): Remove core from inferior list.
	(core_open): Add it.
@
text
@d187 3
a189 2
static void go32_create_inferior (char *exec_file, char *args, char **env, int from_tty);
static void go32_mourn_inferior (void);
d310 1
a310 1
go32_attach (char *args, int from_tty)
d318 1
a318 1
go32_detach (char *args, int from_tty)
d678 1
a678 1
go32_mourn_inferior (void)
@


1.59
log
@	* go32-nat.c: Include "gdbthread.h".
	(go32_stop, go32_kill_inferior): Delete the main thread.
	(go32_create_inferior): Add it.
	(go32_thread_alive, go32_pid_to_str): New.
	(init_go32_ops): Register go32_thread_alive and go32_pid_to_str.
@
text
@d665 2
@


1.58
log
@	* go32-nat.c (fetch_register, store_register): Pass the regcache
	gdbarch to i386_fp_regnum_p and i386_fpc_regnum_p.
	(go32_xfer_memory): Change type of myaddr parameter to gdb_byte.
	(struct seg_descr, struct seg_descr): pack the whole struct
	instead of each member individually.
@
text
@d25 1
d570 1
d572 1
d582 2
d666 3
d859 14
d903 2
@


1.57
log
@	Adjust all targets to new target_stop interface.

	* gnu-nat.c (gnu_stop): Add ptid argument.
	* go32-nat.c (go32_stop): Add ptid argument.
	(go32_create_inferior): Pass inferior_ptid to go32_stop.
	* hpux-thread.c (hpux_thread_stop): Add ptid argument.
	* monitor.c (monitor_stop): Add ptid argument.
	(monitor_open): Pass inferior_ptid to monitor_stop.
	(monitor_interrupt): Pass inferior_ptid to target_stop.
	(monitor_stop): Add ptid argument.
	* nto-procfs.c (nto_interrupt): Pass inferior_ptid to target_stop.
	(procfs_create_inferior): Add ptid argument.
	* procfs.c (procfs_stop): Add ptid argument.
	* remote-m32r-sdi.c (m32r_stop): Add ptid argument.
	* remote-sim.c (gdbsim_stop): Add ptid argument.
	* sol-thread.c (sol_thread_stop): Add ptid argument.
	* win32-nat.c (win32_stop): Add ptid argument.
@
text
@d179 1
a179 1
static int go32_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
d468 2
a469 1
  if (regno < gdbarch_fp0_regnum (get_regcache_arch (regcache)))
d472 1
a472 1
  else if (i386_fp_regnum_p (regno) || i386_fpc_regnum_p (regno))
d497 2
a498 1
  if (regno < gdbarch_fp0_regnum (get_regcache_arch (regcache)))
d501 1
a501 1
  else if (i386_fp_regnum_p (regno) || i386_fpc_regnum_p (regno))
d529 1
a529 1
go32_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
d1266 13
a1278 13
  unsigned short limit0          __attribute__((packed));
  unsigned short base0           __attribute__((packed));
  unsigned char  base1           __attribute__((packed));
  unsigned       stype:5         __attribute__((packed));
  unsigned       dpl:2           __attribute__((packed));
  unsigned       present:1       __attribute__((packed));
  unsigned       limit1:4        __attribute__((packed));
  unsigned       available:1     __attribute__((packed));
  unsigned       dummy:1         __attribute__((packed));
  unsigned       bit32:1         __attribute__((packed));
  unsigned       page_granular:1 __attribute__((packed));
  unsigned char  base2           __attribute__((packed));
};
d1281 9
a1289 9
  unsigned short offset0         __attribute__((packed));
  unsigned short selector        __attribute__((packed));
  unsigned       param_count:5   __attribute__((packed));
  unsigned       dummy:3         __attribute__((packed));
  unsigned       stype:5         __attribute__((packed));
  unsigned       dpl:2           __attribute__((packed));
  unsigned       present:1       __attribute__((packed));
  unsigned short offset1         __attribute__((packed));
};
@


1.56
log
@	Updated copyright notices for most files.
@
text
@d184 1
a184 1
static void go32_stop (void);
d563 1
a563 1
go32_stop (void)
d596 1
a596 1
      go32_stop ();
@


1.55
log
@2007-10-30  Markus Deuling  <deuling@@de.ibm.com>

	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Use get_regcache_arch to get at the current
	architecture by regcache.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1999, 2000, 2001, 2005, 2006, 2007
@


1.54
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d468 1
a468 1
  if (regno < gdbarch_fp0_regnum (current_gdbarch))
d485 3
a487 1
      for (regno = 0; regno < gdbarch_fp0_regnum (current_gdbarch); regno++)
d496 1
a496 1
  if (regno < gdbarch_fp0_regnum (current_gdbarch))
d515 1
a515 1
      for (r = 0; r < gdbarch_fp0_regnum (current_gdbarch); r++)
@


1.53
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.52
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d470 1
a470 1
  if (regno < FP0_REGNUM)
d487 1
a487 1
      for (regno = 0; regno < FP0_REGNUM; regno++)
d496 1
a496 1
  if (regno < FP0_REGNUM)
d515 1
a515 1
      for (r = 0; r < FP0_REGNUM; r++)
@


1.51
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d180 1
a180 1
static void go32_prepare_to_store (void);
d522 1
a522 1
go32_prepare_to_store (void)
@


1.50
log
@	* i387-tdep.c (i387_fill_fsave, i387_fill_fxsave): Remove.
	* i387-tdep.h (i387_fill_fsave, i387_fill_fxsave): Remove prototypes.
	* i368-linux-nat.c (supply_fpregset, supply_fpxregset): Replace
	i387_fill_fsave and i387_fill_fxsave calls by inline copies.
	* i386-nto-tdep.c (i386nto_regset_fill): Likewise.
	* i386gnu-nat.c (store_fpregs): Likewise.
	* i386v4-nat.c (fill_fpregset): Likewise.
	* go32-nat.c (store_register, go32_store_registers): Likewise.
@
text
@d177 3
a179 3
static void go32_fetch_registers (int regno);
static void store_register (int regno);
static void go32_store_registers (int regno);
d468 1
a468 1
fetch_register (int regno)
d471 1
a471 1
    regcache_raw_supply (current_regcache, regno,
d474 1
a474 1
    i387_supply_fsave (current_regcache, regno, &npx);
d481 1
a481 1
go32_fetch_registers (int regno)
d484 1
a484 1
    fetch_register (regno);
d488 2
a489 2
	fetch_register (regno);
      i387_supply_fsave (current_regcache, -1, &npx);
d494 1
a494 1
store_register (int regno)
d497 1
a497 1
    regcache_raw_collect (current_regcache, regno,
d500 1
a500 1
    i387_collect_fsave (current_regcache, regno, &npx);
d507 1
a507 1
go32_store_registers (int regno)
d512 1
a512 1
    store_register (regno);
d516 2
a517 2
	store_register (r);
      i387_collect_fsave (current_regcache, -1, &npx);
@


1.49
log
@Copyright updates for 2007.
@
text
@d500 1
a500 1
    i387_fill_fsave ((char *) &npx, regno);
d517 1
a517 1
      i387_fill_fsave ((char *) &npx, -1);
@


1.48
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1999, 2000, 2001, 2005, 2006
@


1.47
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2 2
a3 1
   Copyright (C) 1997, 1999, 2000, 2001, 2005 Free Software Foundation, Inc.
a660 1
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
@


1.46
log
@
	* Makefile.in (go32-nat.o): Add $(top_h) to prerequisites.

	* go32-nat.c: Include top.h.  Update copyright years.
	(init_go32_ops): Override the default value of gdbinit[] with
	"gdb.ini".

	* cli/cli-cmds.c (init_cli_cmds): Use gdbinit[] instead of a
	compile-time literal string GDBINIT_FILENAME.

	* top.c (PATH_MAX): Define if not defined.
	(gdbinit): Declare with a constant size PATH_MAX.

	* config/i386/go32.mh (XM_FILE): Remove.

	* config/i386/xm-go32.h: Remove file.
@
text
@d2 1
a2 1
   Copyright 1997, 1999, 2000, 2001, 2005 Free Software Foundation, Inc.
d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.46.8.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d660 1
@


1.46.4.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d660 1
@


1.45
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d2 1
a2 1
   Copyright 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
d37 1
d898 3
@


1.44
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_cmd.
	* arch-utils.c, avr-tdep.c, breakpoint.c, corefile.c: Update.
	* cp-abi.c, cp-namespace.c, cp-support.c, dummy-frame.c: Update.
	* exec.c, gnu-nat.c, go32-nat.c, hppa-tdep.c, infcmd.c: Update.
	* infrun.c, interps.c, macrocmd.c, maint.c, memattr.c: Update.
	* mips-tdep.c, ocd.c, osabi.c, printcmd.c, regcache.c: Update.
	* reggroups.c, remote-fileio.c, remote-rdi.c, remote.c: Update.
	* sol-thread.c, source.c, stack.c, symfile-mem.c: Update.
	* symfile.c, thread.c, tracepoint.c, valprint.c, value.c: Update.
	* win32-nat.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-regs.c: Update.
@
text
@d1909 2
a1910 2
  add_prefix_cmd ("dos", class_info, go32_info_dos_command,
		  "Print information specific to DJGPP (aka MS-DOS) debugging.",
@


1.43
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d1913 2
a1914 2
  add_cmd ("sysinfo", class_info, go32_sysinfo,
	    "Display information about the target system, including CPU, OS, DPMI, etc.",
d1916 30
a1945 30
  add_cmd ("ldt", class_info, go32_sldt,
	   "Display entries in the LDT (Local Descriptor Table).\n"
	   "Entry number (an expression) as an argument means display only that entry.",
	   &info_dos_cmdlist);
  add_cmd ("gdt", class_info, go32_sgdt,
	   "Display entries in the GDT (Global Descriptor Table).\n"
	   "Entry number (an expression) as an argument means display only that entry.",
	   &info_dos_cmdlist);
  add_cmd ("idt", class_info, go32_sidt,
	   "Display entries in the IDT (Interrupt Descriptor Table).\n"
	   "Entry number (an expression) as an argument means display only that entry.",
	   &info_dos_cmdlist);
  add_cmd ("pde", class_info, go32_pde,
	   "Display entries in the Page Directory.\n"
	   "Entry number (an expression) as an argument means display only that entry.",
	   &info_dos_cmdlist);
  add_cmd ("pte", class_info, go32_pte,
	   "Display entries in Page Tables.\n"
	   "Entry number (an expression) as an argument means display only entries\n"
	   "from the Page Table pointed to by the specified Page Directory entry.",
	   &info_dos_cmdlist);
  add_cmd ("address-pte", class_info, go32_pte_for_address,
	   "Display a Page Table entry for a linear address.\n"
	   "The address argument must be a linear address, after adding to\n"
	   "it the base address of the appropriate segment.\n"
	   "The base address of variables and functions in the debuggee's data\n"
	   "or code segment is stored in the variable __djgpp_base_address,\n"
	   "so use `__djgpp_base_address + (char *)&var' as the argument.\n"
	   "For other segments, look up their base address in the output of\n"
	   "the `info dos ldt' command.",
@


1.42
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d475 1
a475 1
		    "Invalid register no. %d in fetch_register.", regno);
d501 1
a501 1
		    "Invalid register no. %d in store_register.", regno);
d607 1
a607 1
		    "Cannot allocate redirection storage: not enough memory.\n");
d698 1
a698 1
		    "Invalid register %d in go32_set_dr.\n", i);
d893 1
a893 1
		    "Cannot allocate redirection storage: not enough memory.\n");
d1878 1
a1878 1
    error_no_arg ("linear address");
@


1.41
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d310 1
a310 1
  error ("\
d312 1
a312 1
Use the `run' command to run DJGPP programs.");
d615 1
a615 1
	error ("Syntax error in command line.");
d624 1
a624 1
    error ("Command line too long.");
d808 1
a808 1
    error ("Cannot redirect standard handles for program: %s.",
d842 1
a842 1
      error ("Cannot redirect standard handles for debugger: %s.",
d1520 1
a1520 1
	    error ("Invalid LDT entry 0x%03lx.", (unsigned long)ldt_entry);
d1558 1
a1558 1
	    error ("Invalid LDT entry %#lx: outside valid limits [0..%#x]",
d1589 1
a1589 1
	    error ("Invalid GDT entry 0x%03lx: not an integral multiple of 8.",
d1600 1
a1600 1
	error ("Invalid GDT entry %#lx: outside valid limits [0..%#x]",
d1630 1
a1630 1
	    error ("Invalid (negative) IDT entry %ld.", idt_entry);
d1642 1
a1642 1
	error ("Invalid IDT entry %#lx: outside valid limits [0..%#x]",
d1801 1
a1801 1
	    error ("Entry %ld is outside valid limits [0..1023].", pde_idx);
d1850 1
a1850 1
	    error ("Entry %ld is outside valid limits [0..1023].", pde_idx);
@


1.40
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d864 1
a864 1
  go32_ops.to_xfer_memory = go32_xfer_memory;
@


1.39
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d495 2
a496 1
    regcache_collect (regno, (char *) &a_tss + regno_mapping[regno].tss_ofs);
@


1.38
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d469 2
a470 1
    supply_register (regno, (char *) &a_tss + regno_mapping[regno].tss_ofs);
@


1.37
log
@	* go32-nat.c (go32_sldt, go32_sgdt, go32_sidt, go32_pte): Fix
	mismatches between format string and arguments (avoids compiler
	warnings).
@
text
@d186 1
a186 1
static void go32_create_inferior (char *exec_file, char *args, char **env);
d577 1
a577 1
go32_create_inferior (char *exec_file, char *args, char **env)
@


1.37.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d186 1
a186 1
static void go32_create_inferior (char *exec_file, char *args, char **env, int from_tty);
d469 1
a469 2
    regcache_raw_supply (current_regcache, regno,
			 (char *) &a_tss + regno_mapping[regno].tss_ofs);
d494 1
a494 2
    regcache_raw_collect (current_regcache, regno,
			  (char *) &a_tss + regno_mapping[regno].tss_ofs);
d577 1
a577 1
go32_create_inferior (char *exec_file, char *args, char **env, int from_tty)
@


1.36
log
@* i387-tdep.c (i387_supply_fsave, i387_supply_fxsave): Add
regcache argument and reverse the order of the other two
arguments.  Remove local regcache variable.  Determine
architecture from REGCACHE.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Add regcache argument and
reverse the order of the other two arguments.  Remove local
regcache variable.  Determine architecture from REGCACHE.  Update
comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fxsave): Adjust
prototypes.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Adjust prototype.  Adjust
comment.
* amd64fbsd-nat.c (supply_fpregset, fetch_inferior_registers):
Update.
* go32-nat.c (fetch_register, go32_fetch_registers): Update.
* i386-interix-nat.c (supply_fpregset): Update.
* i386-linux-nat.c (supply_fpregset, supply_fpxregset): Update.
* i386-nto-tdep.c (i386nto_supply_fpregset): Update.
* i386gnu-nat.c (fetch_fpregs, supply_fpregset): Update.
* i386bsd-nat.c (supply_fpregset, fetch_inferior_registers): Update.
* i386nbsd-tdep.c (fetch_core_registers, fetch_elfcore_registers):
Update.
* i386obsd-tdep.c (fetch_core_registers): Update.
* i386v4-nat.c (supply_fpregset): Update.
* x86-64-linux-nat.c (supply_fpregset): Update.
* x86-64-linux-tdep.c (fetch_core_registers): Update.
@
text
@d1518 1
a1518 1
	    error ("Invalid LDT entry 0x%03x.", ldt_entry);
d1556 2
a1557 2
	    error ("Invalid LDT entry %#x: outside valid limits [0..%#x]",
		   ldt_entry, limit);
d1587 2
a1588 2
	    error ("Invalid GDT entry 0x%03x: not an integral multiple of 8.",
		   gdt_entry);
d1598 2
a1599 2
	error ("Invalid GDT entry %#x: outside valid limits [0..%#x]",
	       gdt_entry, gdtr.limit);
d1628 1
a1628 1
	    error ("Invalid (negative) IDT entry %d.", idt_entry);
d1640 2
a1641 2
	error ("Invalid IDT entry %#x: outside valid limits [0..%#x]",
	       idt_entry, idtr.limit);
d1837 1
a1837 1
  long pde_idx = -1, i;
d1848 1
a1848 1
	    error ("Entry %d is outside valid limits [0..1023].", pde_idx);
@


1.35
log
@* go32-nat.c (fetch_register): Call i387_supply_fsave instead of
i387_supply_register.
(go32_fetch_registers): Adjust call to i387_supply_fsave.
* i386nbsd-tdep.c (fetch_core_registers): Adjust call to
i387_supply_fsave.
(fetch_elfcore_registers): Adjust call to i387_supply_fsave and
i387_supply_fxsave.
* i386obsd-tdep.c (fetch_core_registers): Adjust call to
i387_supply_fsave.
* i386bsd-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
(fetch_inferior_registers): Remove extraneous whitespace.  Adjust
call to i387_supply_fxsave.  Call i387_supply_fsave instead of
supply_fpregset.
(store_inferior_registers): Remove extraneous whitespace.  Call
i387_fill_fsave instead of fill_fpregset.
* i386gnu-nat.c (fetch_fpregs): Adjust call to i387_supply_fsave.
(supply_fpregset): Likewise.
* i386v4-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
* i386-interix-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
* i386-linux-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
(supply_fpxregset): Adjust call to i387_adjust_fxsave.
* i386-nto-tdep.c (i386nto_supply_fpregset): Adjust calls to
i387supply_fsave and i387_supply_fxsave.
* i387-tdep.c (i387_supply_fsave): Add `regnum' argument.
Incorporate code from `i387_supply_register.
(i387_supply_register): Remove.
(i387_supply_fxsave): Add `regnum' argument.
Update comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fsxave): Adjust
prototype.
(i387_supply_register): remove prototype.
Update comments.
@
text
@d471 1
a471 1
    i387_supply_fsave ((const char *) &npx, regno);
d486 1
a486 1
      i387_supply_fsave ((const char *) &npx, -1);
@


1.34
log
@2002-11-06  Andrew Cagney  <cagney@@redhat.com>

	* i386-tdep.c (i386_mmx_regnum_p): Rename mmx_regnum_p.  Update
	all callers.
	(i386_fp_regnum_p): New function.  Use instead of FP_REGNUM_P.
	(i386_fpc_regnum_p): New function.  Use instead of FPC_REGNUM_P.
	(i386_sse_regnum_p): New function.  Use instead of SSE_REGNUM_P.
	(i386_mxcsr_regnum_p): new function.  Use instead of
	MXCSR_REGNUM_P.
	* i386-tdep.h (SSE_REGNUM_P): Delete macro.
	(i386_sse_regnum_p): Declare.
	(i386_mxcsr_regnum_p): Declare.
	(FP_REGNUM_P, FPC_REGNUM_P): Delete macros.
	(i386_fp_regnum_p, i386_fpc_regnum_p): Declare.
	(IS_FP_REGNUM): Update definition.
	(IS_FPU_CTRL_REGNUM): Update definition..
	(IS_SSE_REGNUM): Update definition..
	* i386v-nat.c (register_u_addr): Update.
	* go32-nat.c (fetch_register): Update.
	(store_register): Update.
@
text
@d471 1
a471 1
    i387_supply_register (regno, (char *) &npx);
d486 1
a486 1
      i387_supply_fsave ((char *) &npx);
@


1.33
log
@* Makefile.in (ALLDEPFILES): Remove i387-nat.c.
(i387-nat.o): Delete dependency list.
(go32-nat.o): Change i387-nat.h to i387-tdep.h.
(x86-64-linux-nat.o): Likewise.
* i387-nat.c: Delete file, moving contents to...
* i387-tdep.c: ...here.
* i387-nat.h: Rename...
* i387-tdep.h: ...to this.
* go32-nat.c: Include i387-tdep.h instead of i387-nat.h.
* i386-linux-nat.c: Likewise.
* i386bsd-nat.c: Likewise.
* i386gnu-nat.c: Likewise.
* i386nbsd-nat.c: Likewise.
* i386v4-nat.c: Likewise.
* x86-64-linux-nat.c: Likewise.
* config/i386/fbsd.mh (NATDEPFILES): Remove i387-nat.o.
* config/i386/go32.mh (NATDEPFILES): Likewise.
* config/i386/i386gnu.mh (NATDEPFILES): Likewise.
* config/i386/i386sol2.mh (NATDEPFILES): Likewise.
* config/i386/i386v42mp.mh (NATDEPFILES): Likewise.
* config/i386/linux.mh (NATDEPFILES): Likewise.
* config/i386/nbsd.mh (NATDEPFILES): Likewise.
* config/i386/nbsdelf.mh (NATDEPFILES): Likewise.
* config/i386/obsd.mh (NATDEPFILES): Likewise.
* config/i386/x86-64linux.mh (NATDEPFILES): Likewise.
@
text
@d470 1
a470 1
  else if (FP_REGNUM_P (regno) || FPC_REGNUM_P (regno))
d495 1
a495 1
  else if (FP_REGNUM_P (regno) || FPC_REGNUM_P (regno))
@


1.33.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d470 2
a471 2
  else if (i386_fp_regnum_p (regno) || i386_fpc_regnum_p (regno))
    i387_supply_fsave (current_regcache, regno, &npx);
d486 1
a486 1
      i387_supply_fsave (current_regcache, -1, &npx);
d495 1
a495 1
  else if (i386_fp_regnum_p (regno) || i386_fpc_regnum_p (regno))
@


1.33.14.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d1518 1
a1518 1
	    error ("Invalid LDT entry 0x%03lx.", (unsigned long)ldt_entry);
d1556 2
a1557 2
	    error ("Invalid LDT entry %#lx: outside valid limits [0..%#x]",
		   (unsigned long)ldt_entry, limit);
d1587 2
a1588 2
	    error ("Invalid GDT entry 0x%03lx: not an integral multiple of 8.",
		   (unsigned long)gdt_entry);
d1598 2
a1599 2
	error ("Invalid GDT entry %#lx: outside valid limits [0..%#x]",
	       (unsigned long)gdt_entry, gdtr.limit);
d1628 1
a1628 1
	    error ("Invalid (negative) IDT entry %ld.", idt_entry);
d1640 2
a1641 2
	error ("Invalid IDT entry %#lx: outside valid limits [0..%#x]",
	       (unsigned long)idt_entry, idtr.limit);
d1837 1
a1837 1
  long pde_idx = -1L, i;
d1848 1
a1848 1
	    error ("Entry %ld is outside valid limits [0..1023].", pde_idx);
@


1.33.12.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d470 1
a470 1
  else if (i386_fp_regnum_p (regno) || i386_fpc_regnum_p (regno))
d495 1
a495 1
  else if (i386_fp_regnum_p (regno) || i386_fpc_regnum_p (regno))
@


1.33.12.2
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d471 1
a471 1
    i387_supply_fsave ((const char *) &npx, regno);
d486 1
a486 1
      i387_supply_fsave ((const char *) &npx, -1);
@


1.33.12.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d471 1
a471 1
    i387_supply_fsave (current_regcache, regno, &npx);
d486 1
a486 1
      i387_supply_fsave (current_regcache, -1, &npx);
@


1.33.12.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d1518 1
a1518 1
	    error ("Invalid LDT entry 0x%03lx.", (unsigned long)ldt_entry);
d1556 2
a1557 2
	    error ("Invalid LDT entry %#lx: outside valid limits [0..%#x]",
		   (unsigned long)ldt_entry, limit);
d1587 2
a1588 2
	    error ("Invalid GDT entry 0x%03lx: not an integral multiple of 8.",
		   (unsigned long)gdt_entry);
d1598 2
a1599 2
	error ("Invalid GDT entry %#lx: outside valid limits [0..%#x]",
	       (unsigned long)gdt_entry, gdtr.limit);
d1628 1
a1628 1
	    error ("Invalid (negative) IDT entry %ld.", idt_entry);
d1640 2
a1641 2
	error ("Invalid IDT entry %#lx: outside valid limits [0..%#x]",
	       (unsigned long)idt_entry, idtr.limit);
d1837 1
a1837 1
  long pde_idx = -1L, i;
d1848 1
a1848 1
	    error ("Entry %ld is outside valid limits [0..1023].", pde_idx);
@


1.32
log
@go32-nat.c (store_register): Cast &a_tss to `char *', to avoid compiler
warning.

config/djgpp/README: Update.
@
text
@d32 1
a32 1
#include "i387-nat.h"
@


1.31
log
@s/strerror/safe_strerror/
@
text
@d494 1
a494 1
    regcache_collect (regno, (void *) &a_tss + regno_mapping[regno].tss_ofs);
@


1.30
log
@	* go32-nat.c (_initialize_go32_nat): Don't use periods in the
	first line of the doc string for "info dos", except at the end of
	the sentence, since the short help stops at the first period.
@
text
@d807 1
a807 1
	   strerror (errno));
d841 1
a841 1
	     strerror (errno));
@


1.30.2.1
log
@(store_register): Cast &a_tss to `char *', to avoid compiler warning.
@
text
@d494 1
a494 1
    regcache_collect (regno, (char *) &a_tss + regno_mapping[regno].tss_ofs);
@


1.29
log
@ * fix compilation failure by adding #include "i386-tdep.h"
@
text
@d1908 1
a1908 1
		  "Print information specific to DJGPP (a.k.a. MS-DOS) debugging.",
@


1.28
log
@* go32-nat.c (fetch_register): Use FP_REGNUM_P and FPC_REGNUM_P
macros instead of LAST_FPU_CTRL_REGNUM.
(store_register): Likewise.
@
text
@d33 1
@


1.27
log
@	* go32-nat.c (save_npx) [__DJGPP_MINOR__ < 3]: Remove extraneous
	white space which prevented compilation.  Reported by DSK
	<dsk@@student.unsw.edu.au>.
@
text
@d469 1
a469 1
  else if (regno <= LAST_FPU_CTRL_REGNUM)
d494 2
a495 2
  else if (regno <= LAST_FPU_CTRL_REGNUM)
    i387_fill_fsave ((char *)&npx, regno);
@


1.26
log
@2001-12-04  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* go32-nat.c (go32_fetch_registers): Remove call to register_buffer
	(which is now a static function in regcache.c)
	and use regcache_collect instead.
@
text
@d96 2
a97 2
       xorb %% al, %%al	    \n\
       outb %% al, $0xf0    \n\
d99 2
a100 2
       outb %% al, $0xa0    \n\
       outb %% al, $0x20    \n\
d102 1
a102 1
       fnsave % 0	    \n\
a109 3



@


1.25
log
@	* go32-nat.c (save_npx): Avoid a warning from GCC 3.x.
@
text
@a494 3
  void *rp;
  void *v = (void *) register_buffer (regno);

d496 1
a496 2
    memcpy ((char *) &a_tss + regno_mapping[regno].tss_ofs,
	    v, regno_mapping[regno].size);
@


1.24
log
@* TODO (register_buffer): Delete.
* regcache.c (register_buffer): Make static.
(regcache_collect): New function.
* regcache.h (register_buffer): Delete declaration.
(regcache_collect): Declare.
* remote.c (store_register_using_P): Rewrite using
regcache_collect.
(remote_store_registers): Ditto.
* go32-nat.c (store_register): Ditto.
@
text
@d93 10
a102 10
  asm ("inb    $0xa0, %%al
       testb $0x20, %%al
       jz 1f
       xorb %% al, %%al
       outb %% al, $0xf0
       movb $0x20, %%al
       outb %% al, $0xa0
       outb %% al, $0x20
1:
       fnsave % 0
d496 1
a496 2
  void *v = alloca (MAX_REGISTER_RAW_SIZE);
  regcache_collect (regno, v);
d1703 1
a1703 1
#if 0  /* not fully supported yet */
@


1.23
log
@* go32-nat.c (go32_create_inferior): Use xfree instead of free.
* config/djgpp/fnchange.lst: Add entries for i386bsd-tdep.c and
i386bsd-nat.c.
@
text
@d496 2
a497 1
  void *v = (void *) register_buffer (regno);
@


1.22
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".
	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d652 1
a652 1
  free (cmdline);
@


1.21
log
@	* go32-nat.c (get_cr3): Temporary disable support for page tables
	in UMBs, as it is incomplete.
@
text
@a43 2
/* breakpoint.h defines `disable' which is an enum member.  */
#define disable interrup_disable
a44 1
#undef disable
@


1.20
log
@	* go32-nat.c (read_memory_region): Make sure the segment limit was
	indeed set, to work around a Windows 2000 bug.
@
text
@d1706 1
d1727 1
@


1.20.2.1
log
@	* go32-nat.c (get_cr3): Temporary disable support for page tables
	in UMBs, as it is incomplete.
@
text
@a1705 1
#if 0  /* not fullly supported yet */
a1725 1
#endif
@


1.20.2.2
log
@	The following changes avoid polluting global namespace with the
	`enable' and `disable' identifiers, because some platforms define
	in their system headers symbols with global scope that go by those
	names.

	* breakpoint.h (enum enable_state): Rename from `enum enable'.
	Also rename all the enum members to have the "bp_" prefix.
	(struct breakpoint): Rename the `enable' member to `enable_state'.
	(enum bpdisp): Rename all members to have the "disp_" prefix.

	* breakpoint.c: All users of `enum enable' and `enum bpdisp'
	changed.
	(args_for_catchpoint_enable): Rename the `enable' member to
	`enable_p'.  All users changed.

	* tracepoint.h (enum enable): Remove.
	(struct tracepoint): The member `enabled' is now `int enabled_p'.

	* tracepoint.c: All users of the `enabled' member changed.

	* printcmd.c (struct display): The `status' member is now an int.

	* memattr.h (struct mem_region): Rename the `status' member to
	`enabled_p'.
	(enum enable): Remove.

	* memattr.c: Change all users of the `status' member of struct
	mem_region to use `enabled_p' instead.

	* infcmd.c (run_stack_dummy): Use disp_del instead of del.

	* go32-nat.c: Remove the kludgey work-around for conflicts between
	<dos.h> and "breakpoint.h".

	* tui/tuiSourceWin.c: Use disp_del instead of del.

	* tui/tuiSource.c: Use disp_del instead of del.

	* tui/tuiDisassem.c: Use disp_del instead of del.
@
text
@d44 2
d47 1
@


1.20.2.3
log
@* go32-nat.c (go32_create_inferior): Use xfree instead of free.
* config/djgpp/fnchange.lst: Add entries for i386bsd-tdep.c and
i386bsd-nat.c.
@
text
@d652 1
a652 1
  xfree (cmdline);
@


1.20.2.4
log
@	* go32-nat.c (save_npx) [__DJGPP_MINOR__ < 3]: Remove extraneous
	white space which prevented compilation.  Reported by DSK
	<dsk@@student.unsw.edu.au>.
@
text
@d96 2
a97 2
       xorb %%al, %%al
       outb %%al, $0xf0
d99 2
a100 2
       outb %%al, $0xa0
       outb %%al, $0x20
d102 1
a102 1
       fnsave %0
d110 4
@


1.19
log
@Add new DJGPP-specific commands and document them in the manual.
Make the function which reads memory regions be more defensive
about buggy DPMI providers.
@
text
@d1334 4
a1337 1
	      && __dpmi_set_segment_limit (sel, segment_limit) != -1)
@


1.18
log
@	* go32-nat.c (go32_create_inferior): Support command lines longer
	than 126 characters.
@
text
@d50 1
d1298 1
d1309 32
a1340 6
      if (sel <= 0
	  || __dpmi_set_segment_base_address (sel, addr) == -1
	  || __dpmi_set_segment_limit (sel, len - 1) == -1)
	return 0;
      movedata (sel, 0, _my_ds (), (unsigned)dest, len);
      __dpmi_free_ldt_descriptor (sel);
d1342 1
a1342 1
  return 1;
d1634 1
a1634 1
	    error ("Invalid (negative) IDT entry 0x%03x.", idt_entry);
d1660 237
d1929 19
@


1.17
log
@	* go32-nat.c (info_dos_cmdlist): New variable.
	(go32_info_dos_command): New function.
	(_initialize_go32_nat): Convert all DOS-specific commands into
	subcommands of "info dos".  Suggested by Andrew Cagney
	<ac131313@@redhat.com>.
@
text
@d591 1
d626 7
a632 2
  cmdline = (char *) alloca (strlen (args) + 4);
  cmdline[0] = strlen (args);
d634 10
a643 1
  cmdline[strlen (args) + 1] = 13;
d654 1
@


1.16
log
@	* go32-nat.c (go32_get_windows_version, print_mem, go32_sysinfo)
	(read_memory_region, get_descriptor, display_descriptor)
	(go32_sldt, go32_sgdt, go32_sidt): New functions.
	(top-level): Include ctype.h, utsname.h, dos.h, and go32.h.  Ifdef
	away `disable' from dos.h, since breakpoint.h defines an enum
	member of the same name, and GCC 2.7.2 barfs.
	(_initialize_go32_nat): Provide new commands dos-sysinfo, dos-ldt,
	dos-gdt, and dos-idt, all of them in the "info" class
@
text
@d29 1
d1616 8
d1630 19
a1648 11
  add_info ("dos-sysinfo", go32_sysinfo,
	    "Display information about the target system, including CPU, OS, DPMI, etc.");
  add_info ("dos-ldt", go32_sldt,
	    "Display entries in the LDT (Local Descriptor Table).\n"
	    "Entry number (an expression) as an argument means display only that entry.");
  add_info ("dos-gdt", go32_sgdt,
	    "Display entries in the GDT (Global Descriptor Table).\n"
	    "Entry number (an expression) as an argument means display only that entry.");
  add_info ("dos-idt", go32_sidt,
	    "Display entries in the IDT (Interrupt Descriptor Table).\n"
	    "Entry number (an expression) as an argument means display only that entry.");
@


1.15
log
@	* go32-nat.c (go32_wait): Change the return value to ptid_t.

	* config/djgpp/fnchange.lst: Add two new files in the
	gdb/testsuite/gdb.c++/ directory to the remapped names.

	* config/djgpp/djconfig.sh (lt_cv_sys_max_cmd_len): Set to 12KB.
@
text
@d36 1
a36 1
#include <stdio.h>		/* required for __DJGPP_MINOR__ */
d38 1
d41 1
d43 4
d48 1
d888 727
d1620 12
@


1.14
log
@Phase 1 of the ptid_t changes.
@
text
@d343 1
a343 1
static int
d458 1
a458 1
  return SOME_PID;
@


1.13
log
@        * go32-nat.c: Minor tweaks, to pacify the ari script.
@
text
@d167 4
a170 2
static void go32_resume (int pid, int step, enum target_signal siggnal);
static int go32_wait (int pid, struct target_waitstatus *status);
d320 1
a320 1
go32_resume (int pid, int step, enum target_signal siggnal)
d344 1
a344 1
go32_wait (int pid, struct target_waitstatus *status)
d563 1
a563 1
  inferior_pid = 0;
d637 1
a637 1
  inferior_pid = SOME_PID;
@


1.12
log
@	* config/djgpp/djconfig.sh: Add copyright notice.

	* ser-go32.c (rawclock): Remove prototype; include time.h instead.
	(ISR, dos_hookirq, isr_t): Convert K&R definition to ANSI C.
	(top level) <string.h>: Include gdb_string.h instead.
	(dos_noop, dos_raw, dos_noflush_set_tty_state)
	(dos_print_tty_state, dos_info): Remove ATTRIBUTE_UNUSED.

	* go32-nat.c (go32_create_inferior): Move the declaration of
	`environ' to here from the top level.
	(top level) <_initialize_go32_nat>: Remove redundant prototype.
	<gdb_string.h>: Include it instead of string.h.
	(store_register): Call register_buffer instead of accessing
	registers[] directly.
	(redir_cmdline_delete, redir_cmdline_parse, redir_to_debugger)
	(redir_to_debugger, redir_debug_init) [__DJGPP_MINOR__ < 3]: Put
	the function names at the start of the line.
	(go32_set_dr): Throw internal_error if the argument is not a valid
	debug register number.
	(go32_open, go32_close, go32_attach, go32_detach, go32_resume)
	(go32_wait, go32_xfer_memory, go32_files_info)
	(go32_terminal_info): Remove ATTRIBUTE_UNUSED.
@
text
@d115 1
a115 1
asm ("frstor %0":"=m" (npx));
d125 4
a128 1
redir_cmdline_delete (cmdline_t *ptr) {ptr->redirected = 0;}
d135 1
d141 1
d147 1
d149 4
a152 1
redir_debug_init (cmdline_t *ptr) { return 0; }
@


1.11
log
@	* config/i386/nm-go32.h <top level>: Don't include nm-i386v.h,
	include nm-i386.h instead.
	(TARGET_HAS_HARDWARE_WATCHPOINTS, HAVE_CONTINUABLE_WATCHPOINT)
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT, STOPPED_BY_WATCHPOINT)
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT, DECR_PC_AFTER_HW_BREAK)
	(target_stopped_data_address, target_insert_watchpoint)
	(target_remove_watchpoint, target_insert_hw_breakpoint)
	(target_remove_hw_breakpoint): Don't define.
	(I386_USE_GENERIC_WATCHPOINTS, I386_DR_LOW_SET_CONTROL)
	(I386_DR_LOW_SET_ADDR, I386_DR_LOW_RESET_ADDR)
	(I386_DR_LOW_GET_STATUS): Define to call appropriate go32_*
	functions from go32-nat.c.

	* config/i386/go32.mh (NATDEPFILES): Add i386-nat.o.

	* go32-nat.c <top level>: Remove prototypes for watchpoint-
	related functions.  Remove definitions of watchpoint-related
	macros.
	(go32_mourn_inferior): Call i386_cleanup_dregs instead of the
	private cleanup_dregs function.
	(cleanup_dregs, go32_insert_watchpoint)
	(go32_insert_aligned_watchpoint, go32_handle_nonaligned_watchpoint)
	(go32_remove_watchpoint, go32_remove_aligned_watchpoint)
	(go32_region_ok_for_watchpoint, go32_stopped_by_watchpoint)
	(go32_remove_hw_breakpoint, go32_insert_hw_breakpoint): Remove.
	(go32_set_dr, go32_set_dr7, go32_get_dr6): New functions.
@
text
@d32 1
d34 1
a37 1
#include <string.h>
d124 5
a128 2
void redir_cmdline_delete (cmdline_t *ptr) {ptr->redirected = 0;}
int  redir_cmdline_parse (const char *args, cmdline_t *ptr)
d132 2
a133 1
int redir_to_child (cmdline_t *ptr)
d137 2
a138 1
int redir_to_debugger (cmdline_t *ptr)
d142 2
a143 1
int redir_debug_init (cmdline_t *ptr) { return 0; }
a145 2
extern void _initialize_go32_nat (void);

a150 2
extern char **environ;

d282 1
a282 1
go32_open (char *name ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
d288 1
a288 1
go32_close (int quitting ATTRIBUTE_UNUSED)
d293 1
a293 1
go32_attach (char *args ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
d301 1
a301 1
go32_detach (char *args ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
d309 1
a309 1
go32_resume (int pid ATTRIBUTE_UNUSED, int step, enum target_signal siggnal)
d333 1
a333 1
go32_wait (int pid ATTRIBUTE_UNUSED, struct target_waitstatus *status)
d398 1
a398 1
    
d479 1
a479 1
  void *v = (void *) &registers[REGISTER_BYTE (regno)];
d513 1
a513 2
		  struct mem_attrib *attrib ATTRIBUTE_UNUSED,
		  struct target_ops *target ATTRIBUTE_UNUSED)
d542 1
a542 1
go32_files_info (struct target_ops *target ATTRIBUTE_UNUSED)
d568 1
d667 3
d742 1
a742 1
go32_terminal_info (char *args ATTRIBUTE_UNUSED, int from_tty ATTRIBUTE_UNUSED)
@


1.10
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1997, 1999, 2001 Free Software Foundation, Inc.
a168 1
static void cleanup_dregs (void);
a170 6
static int go32_insert_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
					   int len, int rw);
static int go32_remove_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
					   int len, int rw);
static int go32_handle_nonaligned_watchpoint (wp_op what, CORE_ADDR waddr,
					      CORE_ADDR addr, int len, int rw);
d641 1
a641 1
  cleanup_dregs ();
a653 17
#define DR_STATUS 6
#define DR_CONTROL 7
#define DR_ENABLE_SIZE 2
#define DR_LOCAL_ENABLE_SHIFT 0
#define DR_GLOBAL_ENABLE_SHIFT 1
#define DR_LOCAL_SLOWDOWN 0x100
#define DR_GLOBAL_SLOWDOWN 0x200
#define DR_CONTROL_SHIFT 16
#define DR_CONTROL_SIZE 4
#define DR_RW_READWRITE 0x3
#define DR_RW_WRITE 0x1
#define DR_CONTROL_MASK 0xf
#define DR_ENABLE_MASK 0x3
#define DR_LEN_1 0x0
#define DR_LEN_2 0x4
#define DR_LEN_4 0xc

d655 2
a656 220
#define CONTROL D_REGS[DR_CONTROL]
#define STATUS D_REGS[DR_STATUS]

#define IS_REG_FREE(index) \
  (!(CONTROL & (3 << (DR_ENABLE_SIZE * (index)))))

#define LOCAL_ENABLE_REG(index) \
  (CONTROL |= (1 << (DR_LOCAL_ENABLE_SHIFT + DR_ENABLE_SIZE * (index))))

#define GLOBAL_ENABLE_REG(index) \
  (CONTROL |= (1 << (DR_GLOBAL_ENABLE_SHIFT + DR_ENABLE_SIZE * (index))))

#define DISABLE_REG(index) \
  (CONTROL &= ~(3 << (DR_ENABLE_SIZE * (index))))

#define SET_LOCAL_EXACT() \
  (CONTROL |= DR_LOCAL_SLOWDOWN)

#define SET_GLOBAL_EXACT() \
  (CONTROL |= DR_GLOBAL_SLOWDOWN)

#define RESET_LOCAL_EXACT() \
   (CONTROL &= ~(DR_LOCAL_SLOWDOWN))

#define RESET_GLOBAL_EXACT() \
   (CONTROL &= ~(DR_GLOBAL_SLOWDOWN))

#define SET_BREAK(index,address) \
  do {\
    CONTROL &= ~(DR_CONTROL_MASK << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * (index)));\
    D_REGS[index] = address;\
    dr_ref_count[index]++;\
  } while(0)

#define SET_WATCH(index,address,rw,len) \
  do {\
    SET_BREAK(index,address);\
    CONTROL |= ((len)|(rw)) << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * (index));\
  } while (0)

#define IS_WATCH(index) \
  (CONTROL & (DR_CONTROL_MASK << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE*(index))))

#define WATCH_HIT(index) ((STATUS & (1 << (index))) && IS_WATCH(index))

#define DR_DEF(index) \
  ((CONTROL >> (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * (index))) & 0x0f)
    

#if 0 /* use debugging macro */
#define SHOW_DR(text,len) \
do { \
  if (!getenv ("GDB_SHOW_DR")) break; \
  fprintf(stderr,"%08x %08x ",edi.dr[7],edi.dr[6]); \
  fprintf(stderr,"%08x %d %08x %d ", \
	  edi.dr[0],dr_ref_count[0],edi.dr[1],dr_ref_count[1]); \
  fprintf(stderr,"%08x %d %08x %d ", \
	  edi.dr[2],dr_ref_count[2],edi.dr[3],dr_ref_count[3]); \
  fprintf(stderr,(len)?"(%s:%d)\n":"(%s)\n",#text,len); \
} while (0)
#else
#define SHOW_DR(text,len) do {} while (0)
#endif

static void
cleanup_dregs (void)
{
  int i;

  CONTROL = 0;
  STATUS = 0;
  for (i = 0; i < 4; i++)
    {
      D_REGS[i] = 0;
      dr_ref_count[i] = 0;
    }
}

/* Insert a watchpoint.  */

int
go32_insert_watchpoint (int pid ATTRIBUTE_UNUSED, CORE_ADDR addr,
			int len, int rw)
{
  int ret = go32_insert_aligned_watchpoint (addr, addr, len, rw);

  SHOW_DR (insert_watch, len);
  return ret;
}

static int
go32_insert_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
				int len, int rw)
{
  int i;
  int read_write_bits, len_bits;

  /* Values of rw: 0 - write, 1 - read, 2 - access (read and write).
     However, x86 doesn't support read-only data breakpoints.  */
  read_write_bits = rw ? DR_RW_READWRITE : DR_RW_WRITE;

  switch (len)
  {
  case 4:
    len_bits = DR_LEN_4;
    break;
  case 2:
    len_bits = DR_LEN_2;
    break;
  case 1:
    len_bits = DR_LEN_1;
    break;
  default:
    /* The debug registers only have 2 bits for the length, so
       so this value will always fail the loop below.  */
    len_bits = 0x10;
  }

  /* Look for an occupied debug register with the same address and the
     same RW and LEN definitions.  If we find one, we can use it for
     this watchpoint as well (and save a register).  */
  for (i = 0; i < 4; i++)
  {
    if (!IS_REG_FREE (i) && D_REGS[i] == addr
	&& DR_DEF (i) == (unsigned)(len_bits | read_write_bits))
    {
      dr_ref_count[i]++;
      return 0;
    }
  }

  /* Look for a free debug register.  */
  for (i = 0; i <= 3; i++)
  {
    if (IS_REG_FREE (i))
      break;
  }

  /* No more debug registers!  */
  if (i > 3)
    return -1;

  if (len == 2)
  {
    if (addr % 2)
      return go32_handle_nonaligned_watchpoint (wp_insert, waddr, addr,
						len, rw);
  }
  else if (len == 4)
  {
    if (addr % 4)
      return go32_handle_nonaligned_watchpoint (wp_insert, waddr, addr,
						len, rw);
  }
  else if (len != 1)
    return go32_handle_nonaligned_watchpoint (wp_insert, waddr, addr, len, rw);

  SET_WATCH (i, addr, read_write_bits, len_bits);
  LOCAL_ENABLE_REG (i);
  SET_LOCAL_EXACT ();
  SET_GLOBAL_EXACT ();
  return 0;
}

static int
go32_handle_nonaligned_watchpoint (wp_op what, CORE_ADDR waddr, CORE_ADDR addr,
				   int len, int rw)
{
  int align;
  int size;
  int rv = 0, status = 0;

  static int size_try_array[4][4] =
  {
    { 1, 1, 1, 1 },		/* trying size one */
    { 2, 1, 2, 1 },		/* trying size two */
    { 2, 1, 2, 1 },		/* trying size three */
    { 4, 1, 2, 1 }		/* trying size four */
  };

  while (len > 0)
    {
      align = addr % 4;
      /* Four is the maximum length a 386 debug register can watch.  */
      size = size_try_array[len > 4 ? 3 : len - 1][align];
      if (what == wp_insert)
	status = go32_insert_aligned_watchpoint (waddr, addr, size, rw);
      else if (what == wp_remove)
	status = go32_remove_aligned_watchpoint (waddr, addr, size, rw);
      else if (what == wp_count)
	rv++;
      else
	status = EINVAL;
      /* We keep the loop going even after a failure, because some of
	 the other aligned watchpoints might still succeed, e.g. if
	 they watch addresses that are already watched, and thus just
	 increment the reference counts of occupied debug registers.
	 If we break out of the loop too early, we could cause those
	 addresses watched by other watchpoints to be disabled when
	 GDB reacts to our failure to insert this watchpoint and tries
	 to remove it.  */
      if (status)
	rv = status;
      addr += size;
      len -= size;
    }
  return rv;
}

/* Remove a watchpoint.  */

int
go32_remove_watchpoint (int pid ATTRIBUTE_UNUSED, CORE_ADDR addr,
			int len, int rw)
{
  int ret = go32_remove_aligned_watchpoint (addr, addr, len, rw);

  SHOW_DR (remove_watch, len);
  return ret;
}
d658 5
a662 3
static int
go32_remove_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
				int len, int rw)
d664 1
a664 53
  int i;
  int read_write_bits, len_bits;

  /* Values of rw: 0 - write, 1 - read, 2 - access (read and write).
     However, x86 doesn't support read-only data breakpoints.  */
  read_write_bits = rw ? DR_RW_READWRITE : DR_RW_WRITE;

  switch (len)
    {
      case 4:
	len_bits = DR_LEN_4;
	break;
      case 2:
	len_bits = DR_LEN_2;
	break;
      case 1:
	len_bits = DR_LEN_1;
	break;
      default:
	/* The debug registers only have 2 bits for the length, so
	   so this value will always fail the loop below.  */
	len_bits = 0x10;
    }

  if (len == 2)
    {
      if (addr % 2)
	return go32_handle_nonaligned_watchpoint (wp_remove, waddr, addr,
						  len, rw);
    }
  else if (len == 4)
    {
      if (addr % 4)
	return go32_handle_nonaligned_watchpoint (wp_remove, waddr, addr,
						  len, rw);
    }
  else if (len != 1)
    return go32_handle_nonaligned_watchpoint (wp_remove, waddr, addr, len, rw);

  for (i = 0; i <= 3; i++)
    {
      if (!IS_REG_FREE (i) && D_REGS[i] == addr
	  && DR_DEF (i) == (unsigned)(len_bits | read_write_bits))
	{
	  dr_ref_count[i]--;
	  if (dr_ref_count[i] == 0)
	    DISABLE_REG (i);
	}
    }
  RESET_LOCAL_EXACT ();
  RESET_GLOBAL_EXACT ();

  return 0;
d667 5
a671 5
/* Can we use debug registers to watch a region whose address is ADDR
   and whose length is LEN bytes?  */

int
go32_region_ok_for_watchpoint (CORE_ADDR addr, int len)
d673 1
a673 5
  /* Compute how many aligned watchpoints we would need to cover this
     region.  */
  int nregs = go32_handle_nonaligned_watchpoint (wp_count, addr, addr, len, 0);

  return nregs <= 4 ? 1 : 0;
d676 5
a680 5
/* Check if stopped by a data watchpoint.  If so, return the address
   whose access triggered the watchpoint.  */

CORE_ADDR
go32_stopped_by_watchpoint (int pid ATTRIBUTE_UNUSED, int data_watchpoint)
d682 1
a682 70
  int i, ret = 0;
  int status;

  status = edi.dr[DR_STATUS];
  SHOW_DR (stopped_by, 0);
  for (i = 0; i <= 3; i++)
    {
      if (WATCH_HIT (i) && data_watchpoint)
	{
	  SHOW_DR (WP_HIT, 0);
	  ret = D_REGS[i];
	}
    }

  return ret;
}

/* Remove a breakpoint.  */

int
go32_remove_hw_breakpoint (CORE_ADDR addr, void *shadow ATTRIBUTE_UNUSED)
{
  int i;
  for (i = 0; i <= 3; i++)
    {
      if (!IS_REG_FREE (i) && D_REGS[i] == addr && DR_DEF (i) == 0)
	{
	  dr_ref_count[i]--;
	  if (dr_ref_count[i] == 0)
	    DISABLE_REG (i);
	}
    }
  SHOW_DR (remove_hw, 0);
  return 0;
}

int
go32_insert_hw_breakpoint (CORE_ADDR addr, void *shadow ATTRIBUTE_UNUSED)
{
  int i;

  /* Look for an occupied debug register with the same address and the
     same RW and LEN definitions.  If we find one, we can use it for
     this breakpoint as well (and save a register).  */
  for (i = 0; i < 4; i++)
    {
      if (!IS_REG_FREE (i) && D_REGS[i] == addr && DR_DEF (i) == 0)
	{
	  dr_ref_count[i]++;
	  SHOW_DR (insert_hw, 0);
	  return 0;
	}
    }

  /* Look for a free debug register.  */
  for (i = 0; i <= 3; i++)
    {
      if (IS_REG_FREE (i))
	break;
    }

  /* No more debug registers?  */
  if (i < 4)
    {
      SET_BREAK (i, addr);
      LOCAL_ENABLE_REG (i);
    }
  SHOW_DR (insert_hw, 0);

  return i < 4 ? 0 : EBUSY;
@


1.9
log
@	* go32-nat.c: Include i387-nat.h.
	(fetch_register): New function, uses some of the guts of
	go32_fetch_registers and i387_supply_register.
	(go32_fetch_registers): Most of the code moved into
	fetch_register.  Use i387_supply_fsave.
	(store_register): Use i387_fill_fsave instead of custom code.
	(go32_store_registers): Use i387_fill_fsave.

	* Makefile.in (go32-nat.o): Depend on i387-nat.h.

	* config/i386/go32.mh (NATDEPFILES): Add i387-nat.o.
@
text
@d32 1
@


1.8
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d31 1
d454 12
d468 3
a470 4
  /*JHW */
  int end_reg = regno + 1;	/* just one reg initially */

  if (regno < 0)		/* do the all registers */
d472 3
a474 42
      regno = 0;		/* start at first register */
      /* # regs in table */
      end_reg = sizeof (regno_mapping) / sizeof (regno_mapping[0]);
    }

  for (; regno < end_reg; regno++)
    {
      if (regno < 16)
	supply_register (regno,
			 (char *) &a_tss + regno_mapping[regno].tss_ofs);
      else if (regno < 24)
	supply_register (regno,
			 (char *) &npx.reg[regno_mapping[regno].tss_ofs]);
      else if (regno < 32)
	{
	  unsigned regval;

	  switch (regno_mapping[regno].size)
	    {
	      case 2:
		regval = *(unsigned short *)
		  ((char *) &npx + regno_mapping[regno].tss_ofs);
		regval &= 0xffff;
		if (regno == FOP_REGNUM && regval)
		  /* Feature: restore the 5 bits of the opcode
		     stripped by FSAVE/FNSAVE.  */
		  regval |= 0xd800;
		break;
	      case 4:
		regval = *(unsigned *)
		  ((char *) &npx + regno_mapping[regno].tss_ofs);
		break;
	      default:
		internal_error (__FILE__, __LINE__, "\
Invalid native size for register no. %d in go32_fetch_register.", regno);
	    }
	  supply_register (regno, (char *) &regval);
	}
      else
	internal_error (__FILE__, __LINE__,
			"Invalid register no. %d in go32_fetch_register.",
			regno);
d484 5
a488 6
  if (regno < 16)
    rp = (char *) &a_tss + regno_mapping[regno].tss_ofs;
  else if (regno < 24)
    rp = (char *) &npx.reg[regno_mapping[regno].tss_ofs];
  else if (regno < 32)
    rp = (char *) &npx + regno_mapping[regno].tss_ofs;
a491 3
  memcpy (rp, v, regno_mapping[regno].size);
  if (regno == FOP_REGNUM)
    *(short *)rp &= 0x07ff; /* strip high 5 bits, in case they added them */
d503 1
a503 1
      for (r = 0; r < sizeof (regno_mapping) / sizeof (regno_mapping[0]); r++)
d505 1
@


1.7
log
@	* go32-nat.c (go32_xfer_memory): Make the argument list consistent
	with target.h's to_xfer_memory member.
@
text
@d2 1
a2 1
   Copyright 1997, 1999 Free Software Foundation, Inc.
d493 1
a493 1
		internal_error ("\
d499 2
a500 1
	internal_error ("Invalid register no. %d in go32_fetch_register.",
d518 2
a519 1
    internal_error ("Invalid register no. %d in store_register.", regno);
d625 2
a626 1
    internal_error ("Cannot allocate redirection storage: not enough memory.\n");
d1251 2
a1252 1
    internal_error ("Cannot allocate redirection storage: not enough memory.\n");
@


1.6
log
@	* go32-nat.c: (go32_wait): If child_cwd[] is empty, initialize
	it to GDB's current directory.
	(go32_create_inferior, init_go32_ops): Initialize child_cwd[] to
	an empty string, to signal an uninitialized value.
	From Robert Hoehne <robert.hoehne@@gmx.net>.
@
text
@d160 3
a162 1
			     int write, struct target_ops *target);
d544 1
@


1.5
log
@	* go32-nat.c (go32_insert_hw_breakpoint): When there are no more
	hardware breakpoint resources, return EBUSY.
	(go32_handle_nonaligned_watchpoint): If the argument WHAT is not
	one of the enumerated values, return EINVAL.
@
text
@d392 7
d613 5
d1239 3
a1241 2
  /* Initialize child's cwd with the current one.  */
  getcwd (child_cwd, sizeof (child_cwd));
@


1.4
log
@	* go32-nat.c (go32_handle_nonaligned_watchpoint): Use a
	two-dimensional array instead of faking it with index
	arithmetics.
@
text
@d882 1
a882 1
	status = -1;
d1058 1
a1058 1
  return i < 4 ? 0 : -1;
@


1.4.2.1
log
@	* go32-nat.c (go32_insert_hw_breakpoint): When there are no more
	hardware breakpoint resources, return EBUSY.
	(go32_handle_nonaligned_watchpoint): If the argument WHAT is not
	one of the enumerated values, return EINVAL.
@
text
@d882 1
a882 1
	status = EINVAL;
d1058 1
a1058 1
  return i < 4 ? 0 : EBUSY;
@


1.3
log
@	* go32-nat.c (struct env387): Remove declaration.
	(print_387_status, i386_go32_float_info): Remove redundant
	functions.
	(regno_mapping, sig_map, excepn_map): Add braces around inner
	initializers.
	(many functions): Use ATTRIBUTE_UNUSED to shut up the compiler;
	fix code which mixed signed with unsigned.
	(go32_resume): Use TARGET_SIGNAL_LAST instead of -1.
	(go32_wait): Initialize INT3_addr.
	(go32_fetch_registers): Extend all FP registers that are shorter
	than 4 bytes to 32 bits.  Support 32 standard FP registers defined
	on config/i386/tm-i386.h.
	(store_register): Support 32 FP registers.
	(go32_create_inferior): Don't crash if handed a NULL pointer
	instead of exec file name.
	(ignore): Remove unused function.
	(go32_insert_hw_breakpoint): Remove unused variables.
	(init_go32_ops): Set value of processing_gcc_compilation to 2.
@
text
@d862 1
a862 1
  static int size_try_array[16] =
d864 4
a867 4
    1, 1, 1, 1,			/* trying size one */
    2, 1, 2, 1,			/* trying size two */
    2, 1, 2, 1,			/* trying size three */
    4, 1, 2, 1			/* trying size four */
d873 2
a874 3
      /* Four is the maximum length for 386.  */
      size = (len > 4) ? 3 : len - 1;
      size = size_try_array[size * 4 + align];
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@a24 1
#include "frame.h"		/* required by inferior.h */
a25 1
#include "target.h"
d30 1
a138 17
struct env387
  {
    unsigned short control;
    unsigned short r0;
    unsigned short status;
    unsigned short r1;
    unsigned short tag;
    unsigned short r2;
    unsigned long eip;
    unsigned short code_seg;
    unsigned short opcode;
    unsigned long operand;
    unsigned short operand_seg;
    unsigned short r3;
    unsigned char regs[8][10];
  };

a148 1
static void print_387_status (unsigned short status, struct env387 *ep);
a167 2
static void ignore (void);
static void ignore2 (char *a, int b);
a179 86
static void
print_387_status (unsigned short status, struct env387 *ep)
{
  int i;
  int bothstatus;
  int top;
  int fpreg;

  bothstatus = ((status != 0) && (ep->status != 0));
  if (status != 0)
    {
      if (bothstatus)
	printf_unfiltered ("u: ");
      print_387_status_word (status);
    }

  if (ep->status != 0)
    {
      if (bothstatus)
	printf_unfiltered ("e: ");
      print_387_status_word (ep->status);
    }

  print_387_control_word (ep->control & 0xffff);
  /* Other platforms say "last exception", but that's not true: the
     FPU stores the last non-control instruction there.  */
  printf_unfiltered ("last FP instruction: ");
  /* The ORing with D800h restores the upper 5 bits of the opcode that
     are not stored by the FPU (since these bits are the same for all
     floating-point instructions).  */
  printf_unfiltered ("opcode %s; ",
		     local_hex_string (ep->opcode ? (ep->opcode|0xd800) : 0));
  printf_unfiltered ("pc %s:", local_hex_string (ep->code_seg));
  printf_unfiltered ("%s; ", local_hex_string (ep->eip));
  printf_unfiltered ("operand %s", local_hex_string (ep->operand_seg));
  printf_unfiltered (":%s\n", local_hex_string (ep->operand));

  top = (ep->status >> 11) & 7;

  printf_unfiltered ("regno tag     msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--)
    {
      /* FNSAVE saves the FP registers in their logical TOP-relative
	 order, beginning with ST(0).  Since we need to print them in
	 their physical order, we have to remap them.  */
      int  regno = fpreg - top;
      long double val;

      if (regno < 0)
	regno += 8;

      printf_unfiltered ("%s %d: ", fpreg == top ? "=>" : "  ", fpreg);

      switch ((ep->tag >> (fpreg * 2)) & 3)
	{
	case 0:
	  printf_unfiltered ("valid   ");
	  break;
	case 1:
	  printf_unfiltered ("zero    ");
	  break;
	case 2:
	  /* All other versions of print_387_status use TRAP here, but I
	     think this is misleading, since Intel manuals say SPECIAL.  */
	  printf_unfiltered ("special ");
	  break;
	case 3:
	  printf_unfiltered ("empty   ");
	  break;
	}
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep->regs[regno][i]);

      REGISTER_CONVERT_TO_VIRTUAL (FP0_REGNUM+regno, builtin_type_long_double,
				   &ep->regs[regno], &val);

      printf_unfiltered ("  %.19LG\n", val);
    }
}

void
i386_go32_float_info (void)
{
  print_387_status (0, (struct env387 *) &npx);
}

d189 24
a212 24
  r_ofs (tss_eax), 4,	/* normal registers, from a_tss */
    r_ofs (tss_ecx), 4,
    r_ofs (tss_edx), 4,
    r_ofs (tss_ebx), 4,
    r_ofs (tss_esp), 4,
    r_ofs (tss_ebp), 4,
    r_ofs (tss_esi), 4,
    r_ofs (tss_edi), 4,
    r_ofs (tss_eip), 4,
    r_ofs (tss_eflags), 4,
    r_ofs (tss_cs), 2,
    r_ofs (tss_ss), 2,
    r_ofs (tss_ds), 2,
    r_ofs (tss_es), 2,
    r_ofs (tss_fs), 2,
    r_ofs (tss_gs), 2,
    0, 10,		/* 8 FP registers, from npx.reg[] */
    1, 10,
    2, 10,
    3, 10,
    4, 10,
    5, 10,
    6, 10,
    7, 10,
d214 9
a222 8
	   with their numbering in config/i386/tm-go32.h, which see.  */
  0, 2,			/* control word, from npx */
  4, 2,			/* status word, from npx */
  8, 2,			/* tag word, from npx */
  16, 2,		/* last FP exception CS from npx */
  24, 2,		/* last FP exception operand selector from npx */
  12, 4,		/* last FP exception EIP from npx */
  20, 4			/* last FP exception operand offset from npx */
d228 1
a228 1
    int gdb_sig;
d232 2
a233 2
  0, TARGET_SIGNAL_FPE,
    1, TARGET_SIGNAL_TRAP,
d237 22
a258 22
    2, TARGET_SIGNAL_BUS,
    3, TARGET_SIGNAL_TRAP,
    4, TARGET_SIGNAL_FPE,
    5, TARGET_SIGNAL_SEGV,
    6, TARGET_SIGNAL_ILL,
    7, TARGET_SIGNAL_EMT,	/* no-coprocessor exception */
    8, TARGET_SIGNAL_SEGV,
    9, TARGET_SIGNAL_SEGV,
    10, TARGET_SIGNAL_BUS,
    11, TARGET_SIGNAL_SEGV,
    12, TARGET_SIGNAL_SEGV,
    13, TARGET_SIGNAL_SEGV,
    14, TARGET_SIGNAL_SEGV,
    16, TARGET_SIGNAL_FPE,
    17, TARGET_SIGNAL_BUS,
    31, TARGET_SIGNAL_ILL,
    0x1b, TARGET_SIGNAL_INT,
    0x75, TARGET_SIGNAL_FPE,
    0x78, TARGET_SIGNAL_ALRM,
    0x79, TARGET_SIGNAL_INT,
    0x7a, TARGET_SIGNAL_QUIT,
    -1, -1
d265 5
a269 5
  TARGET_SIGNAL_0, -1,
  TARGET_SIGNAL_ILL, 6,		/* Invalid Opcode */
  TARGET_SIGNAL_EMT, 7,		/* triggers SIGNOFP */
  TARGET_SIGNAL_SEGV, 13,	/* GPF */
  TARGET_SIGNAL_BUS, 17,	/* Alignment Check */
d272 7
a278 7
  TARGET_SIGNAL_TERM, 0x1b,	/* triggers Ctrl-Break type of SIGINT */
  TARGET_SIGNAL_FPE, 0x75,
  TARGET_SIGNAL_INT, 0x79,
  TARGET_SIGNAL_QUIT, 0x7a,
  TARGET_SIGNAL_ALRM, 0x78,	/* triggers SIGTIMR */
  TARGET_SIGNAL_PROF, 0x78,
  -1, -1
d282 1
a282 1
go32_open (char *name, int from_tty)
d288 1
a288 1
go32_close (int quitting)
d293 1
a293 1
go32_attach (char *args, int from_tty)
d301 1
a301 1
go32_detach (char *args, int from_tty)
d309 1
a309 1
go32_resume (int pid, int step, enum target_signal siggnal)
d317 2
a318 1
    for (i = 0, resume_signal = -1; excepn_map[i].gdb_sig != -1; i++)
d333 1
a333 1
go32_wait (int pid, struct target_waitstatus *status)
d337 1
a337 1
  unsigned long INT3_addr;
d464 25
a488 3
      else if (regno < 31)
	supply_register (regno,
			 (char *) &npx + regno_mapping[regno].tss_ofs);
d505 1
a505 1
  else if (regno < 31)
d510 2
d517 1
a517 1
  int r;
d535 1
a535 1
		  struct target_ops *target)
d564 1
a564 1
go32_files_info (struct target_ops *target)
d594 5
a669 5
static void
ignore (void)
{
}

d771 2
a772 1
go32_insert_watchpoint (int pid, CORE_ADDR addr, int len, int rw)
d814 1
a814 1
	&& DR_DEF (i) == (len_bits | read_write_bits))
d903 2
a904 1
go32_remove_watchpoint (int pid, CORE_ADDR addr, int len, int rw)
d958 1
a958 1
	  && DR_DEF (i) == (len_bits | read_write_bits))
d988 1
a988 1
go32_stopped_by_watchpoint (int pid, int data_watchpoint)
d1010 1
a1010 1
go32_remove_hw_breakpoint (CORE_ADDR addr, CORE_ADDR shadow)
d1027 1
a1027 1
go32_insert_hw_breakpoint (CORE_ADDR addr, CORE_ADDR shadow)
a1029 3
  int read_write_bits, len_bits;
  int free_debug_register;
  int register_number;
d1113 1
a1113 1
go32_terminal_info (char *args, int from_tty)
d1234 3
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d28 1
a28 1
#include "wait.h"
d33 1
d36 1
d38 2
d42 95
d141 20
a160 15
{
  unsigned short control;
  unsigned short r0;
  unsigned short status;
  unsigned short r1;
  unsigned short tag;
  unsigned short r2;
  unsigned long eip;
  unsigned short code_seg;
  unsigned short opcode;
  unsigned long operand;
  unsigned short operand_seg;
  unsigned short r3;
  unsigned char regs[8][10];
};
d166 29
a194 1
/* FIXME add decls of all static functions here */
d196 4
a199 1
static int prog_has_started = 0;
d225 8
a232 2
  printf_unfiltered ("last exception: ");
  printf_unfiltered ("opcode %s; ", local_hex_string (ep->opcode));
d240 2
a241 2
  printf_unfiltered ("regno tag   msb          lsb  value\n");
  for (fpreg = 0; fpreg < 8; fpreg++)
d243 4
d249 3
d257 1
a257 1
	  printf_unfiltered ("valid ");
d260 1
a260 1
	  printf_unfiltered ("zero  ");
d263 3
a265 1
	  printf_unfiltered ("trap  ");
d268 1
a268 1
	  printf_unfiltered ("empty ");
d271 2
a272 2
      for (i = 0; i < 8; i++)
	printf_unfiltered ("%02x", ep->regs[fpreg][i]);
d274 2
a275 2
      REGISTER_CONVERT_TO_VIRTUAL (FP0_REGNUM + fpreg, builtin_type_long_double,
				   &ep->regs[fpreg], &val);
d277 1
a277 1
      printf_unfiltered ("  %LG\n", val);
d287 1
a287 1
#define r_ofs(x) ((int)(&(((TSS *)0)->x)))
d291 2
a292 2
  int tss_ofs;
  int size;
d296 33
a328 31
  r_ofs (tss_eax), 4,
  r_ofs (tss_ecx), 4,
  r_ofs (tss_edx), 4,
  r_ofs (tss_ebx), 4,
  r_ofs (tss_esp), 4,
  r_ofs (tss_ebp), 4,
  r_ofs (tss_esi), 4,
  r_ofs (tss_edi), 4,
  r_ofs (tss_eip), 4,
  r_ofs (tss_eflags), 4,
  r_ofs (tss_cs), 2,
  r_ofs (tss_ss), 2,
  r_ofs (tss_ds), 2,
  r_ofs (tss_es), 2,
  r_ofs (tss_fs), 2,
  r_ofs (tss_gs), 2,
  0, 10,
  1, 10,
  2, 10,
  3, 10,
  4, 10,
  5, 10,
  6, 10,
  7, 10,
  0, 2,
  4, 2,
  8, 2,
  12, 4,
  16, 2,
  20, 4,
  24, 2
d339 45
a383 19
  1, TARGET_SIGNAL_TRAP,
  2, TARGET_SIGNAL_UNKNOWN,
  3, TARGET_SIGNAL_TRAP,
  4, TARGET_SIGNAL_FPE,
  5, TARGET_SIGNAL_SEGV,
  6, TARGET_SIGNAL_ILL,
  7, TARGET_SIGNAL_FPE,
  8, TARGET_SIGNAL_SEGV,
  9, TARGET_SIGNAL_SEGV,
  10, TARGET_SIGNAL_BUS,
  11, TARGET_SIGNAL_SEGV,
  12, TARGET_SIGNAL_SEGV,
  13, TARGET_SIGNAL_ABRT,
  14, TARGET_SIGNAL_SEGV,
  16, TARGET_SIGNAL_FPE,
  31, TARGET_SIGNAL_ILL,
  0x75, TARGET_SIGNAL_FPE,
  0x79, TARGET_SIGNAL_INT,
  0x1b, TARGET_SIGNAL_INT,
d390 1
a390 1
  printf_unfiltered ("Use the `run' command to run go32 programs\n");
d401 3
a403 1
  printf_unfiltered ("Use the `run' command to run go32 programs\n");
d412 1
d416 6
d423 9
a431 1
    resume_is_step = step;
d433 3
d441 3
d445 1
d447 37
a483 1
    a_tss.tss_eflags |= 0x0100;
d485 13
a497 1
    a_tss.tss_eflags &= 0xfeff;
d499 3
d503 17
d534 1
d538 3
d551 1
a551 1
  /*JHW*/
d571 1
a571 1
			 (char *) &npx.reg + regno_mapping[regno].tss_ofs);
d573 2
a574 5
	{
	  printf_unfiltered ("Invalid register in go32_fetch_register(%d)",
			     regno);
	  exit (1);
	}
d588 1
a588 1
  else if (regno > 31)
d591 1
a591 4
    {
      printf_unfiltered ("Invalid register in store_register(%d)", regno);
      exit (1);
    }
d642 2
d647 1
a647 1
  printf_unfiltered ("You are running a DJGPP V2 program\n");
d662 3
a664 1
  go32_stop ();
d677 1
d680 16
d713 3
d721 2
a722 1
  proceed ((CORE_ADDR) - 1, TARGET_SIGNAL_0, 0);
d728 8
a750 5
static void
ignore2 (char *a, int b)
{
}

d762 1
a762 1
#define DR_RW_READ 0x3
d775 1
a775 1
  (!(CONTROL & (3 << (DR_ENABLE_SIZE * index))))
d778 1
a778 1
  (CONTROL |= (1 << (DR_LOCAL_ENABLE_SHIFT + DR_ENABLE_SIZE * index)))
d781 1
a781 1
  (CONTROL |= (1 << (DR_GLOBAL_ENABLE_SHIFT + DR_ENABLE_SIZE * index)))
d784 1
a784 1
  (CONTROL &= ~(3 << (DR_ENABLE_SIZE * index)))
d792 6
d800 1
a800 1
    CONTROL &= ~(DR_CONTROL_MASK << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * index));\
d802 1
d808 1
a808 1
    CONTROL |= (len | rw) << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * index);\
d811 8
a818 5
#define WATCH_HIT(index) \
  (\
   (STATUS & (1 << index)) && \
   (CONTROL & (DR_CONTROL_MASK << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * index)))\
  )
d821 1
a821 1
#define SHOW_DR(text) \
d823 1
d825 5
a829 3
  fprintf(stderr,"%08x %08x ",edi.dr[0],edi.dr[1]); \
  fprintf(stderr,"%08x %08x ",edi.dr[2],edi.dr[3]); \
  fprintf(stderr,"(%s)\n",#text); \
d832 1
a832 1
#define SHOW_DR(text) do {} while (0)
d835 4
a838 2
static int go32_insert_aligned_watchpoint (int pid, CORE_ADDR waddr,
					   CORE_ADDR addr, int len, int rw);
d840 8
a847 2
static int go32_insert_nonaligned_watchpoint (int pid, CORE_ADDR waddr,
					      CORE_ADDR addr, int len, int rw);
d854 1
a854 1
  int ret = go32_insert_aligned_watchpoint (pid, addr, addr, len, rw);
d856 1
a856 1
  SHOW_DR (insert_watch);
d861 1
a861 1
go32_insert_aligned_watchpoint (int pid, CORE_ADDR waddr, CORE_ADDR addr,
d867 34
d903 4
a906 4
    {
      if (IS_REG_FREE (i))
	break;
    }
d912 6
a917 10
  read_write_bits = ((rw & 1) ? DR_RW_READ : 0) | ((rw & 2) ? DR_RW_WRITE : 0);

  if (len == 1)
    len_bits = DR_LEN_1;
  else if (len == 2)
    {
      if (addr % 2)
	return go32_insert_nonaligned_watchpoint (pid, waddr, addr, len, rw);
      len_bits = DR_LEN_2;
    }
d919 7
a925 7
    {
      if (addr % 4)
	return go32_insert_nonaligned_watchpoint (pid, waddr, addr, len, rw);
      len_bits = DR_LEN_4;
    }
  else
    return go32_insert_nonaligned_watchpoint (pid, waddr, addr, len, rw);
d930 2
d935 1
a935 1
go32_insert_nonaligned_watchpoint (int pid, CORE_ADDR waddr, CORE_ADDR addr,
d940 1
a940 1
  int rv = 0;
d956 18
a973 6
      rv = go32_insert_aligned_watchpoint (pid, waddr, addr, size, rw);
      if (rv)
	{
	  go32_remove_watchpoint (pid, waddr, size);
	  return rv;
	}
d983 11
a993 1
go32_remove_watchpoint (int pid, CORE_ADDR addr, int len)
d996 37
d1036 2
a1037 1
      if (D_REGS[i] == addr)
d1039 3
a1041 1
	  DISABLE_REG (i);
d1044 2
a1045 1
  SHOW_DR (remove_watch);
d1050 15
a1064 1
/* Check if stopped by a watchpoint.  */
d1067 1
a1067 1
go32_stopped_by_watchpoint (int pid)
d1073 1
a1073 1
  SHOW_DR (stopped_by);
d1076 1
a1076 1
      if (WATCH_HIT (i))
d1078 1
a1078 1
	  SHOW_DR (HIT);
a1081 7
  /* this is a hack to GDB. If we stopped at a hardware breakpoint,
     the stop_pc must incremented by DECR_PC_AFTER_BREAK. I tried everything
     with the DECR_PC_AFTER_HW_BREAK, but nothing works. */
  /* This is probably fixed by jtc's recent patch -sts 2/19/99 */
  if (STATUS && !ret)
    stop_pc += DECR_PC_AFTER_BREAK;
  STATUS = 0;
d1094 1
a1094 1
      if (D_REGS[i] == addr)
d1096 3
a1098 1
	  DISABLE_REG (i);
d1101 1
a1101 1
  SHOW_DR (remove_hw);
d1113 13
d1133 24
a1156 2
  /* No more debug registers!  */
  if (i > 3)
d1158 6
d1165 58
a1222 3
  SET_BREAK (i, addr);
  LOCAL_ENABLE_REG (i);
  SHOW_DR (insert_hw);
d1224 19
a1242 1
  return 0;
d1245 26
a1270 1
static struct target_ops go32_ops;
d1281 1
d1292 5
a1296 5
  go32_ops.to_terminal_init = ignore;
  go32_ops.to_terminal_inferior = ignore;
  go32_ops.to_terminal_ours_for_output = ignore;
  go32_ops.to_terminal_ours = ignore;
  go32_ops.to_terminal_info = ignore2;
d1309 7
d1323 18
@


1.1.1.1
log
@import gdb-19990422 snapshot
@
text
@@


1.1.1.2
log
@import gdb-19990504 snapshot
@
text
@a31 1
#include <stdio.h>     /* required for __DJGPP_MINOR__ */
a37 59
#if __DJGPP_MINOR__ < 3
/* This code will be provided from DJGPP 2.03 on. Until then I code it
   here */
typedef struct {
  unsigned short sig0;
  unsigned short sig1;
  unsigned short sig2;
  unsigned short sig3;
  unsigned short exponent:15;
  unsigned short sign:1;
} NPXREG;

typedef struct {
  unsigned int control;
  unsigned int status;
  unsigned int tag;
  unsigned int eip;
  unsigned int cs;
  unsigned int dataptr;
  unsigned int datasel;
  NPXREG reg[8];
} NPX;

static NPX npx;

static void save_npx (void); /* Save the FPU of the debugged program */
static void load_npx (void); /* Restore the FPU of the debugged program */

/* ------------------------------------------------------------------------- */
/* Store the contents of the NPX in the global variable `npx'.  */

static void
save_npx (void)
{
  asm ("inb    $0xa0, %%al
       testb   $0x20, %%al
       jz      1f
       xorb    %%al, %%al
       outb    %%al, $0xf0
       movb    $0x20, %%al
       outb    %%al, $0xa0
       outb    %%al, $0x20
1:
       fnsave  %0
       fwait"
       : "=m" (npx)
       : /* No input */
       : "%eax");
}
/* ------------------------------------------------------------------------- */
/* Reload the contents of the NPX from the global variable `npx'.  */

static void
load_npx (void)
{
  asm ("frstor %0" : "=m" (npx));
}
#endif /* __DJGPP_MINOR < 3 */

d61 2
a63 47
static void
print_387_status (unsigned short status, struct env387 *ep);
static void
go32_open (char *name, int from_tty);
static void
go32_close (int quitting);
static void
go32_attach (char *args, int from_tty);
static void
go32_detach (char *args, int from_tty);
static void
go32_resume (int pid, int step, enum target_signal siggnal);
static int
go32_wait (int pid, struct target_waitstatus *status);
static void
go32_fetch_registers (int regno);
static void
store_register (int regno);
static void
go32_store_registers (int regno);
static void
go32_prepare_to_store (void);
static int
go32_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
                 struct target_ops *target);
static void
go32_files_info (struct target_ops *target);
static void
go32_stop (void);
static void
go32_kill_inferior (void);
static void
go32_create_inferior (char *exec_file, char *args, char **env);
static void
go32_mourn_inferior (void);
static int
go32_can_run (void);
static void
ignore (void);
static void
ignore2 (char *a, int b);
static int go32_insert_aligned_watchpoint (int pid, CORE_ADDR waddr,
                                          CORE_ADDR addr, int len, int rw);
static int go32_insert_nonaligned_watchpoint (int pid, CORE_ADDR waddr,
                                             CORE_ADDR addr, int len, int rw);

static struct target_ops go32_ops;
a247 3
#if __DJGPP_MINOR__ < 3
  save_npx ();
#endif
a248 3
#if __DJGPP_MINOR__ < 3
  load_npx ();
#endif
d391 1
a403 1
      go32_stop ();
a428 1
  prog_has_started = 1;
d525 6
d708 2
@


1.1.1.3
log
@import gdb-1999-06-07 snapshot
@
text
@a168 6
static void
go32_terminal_init (void);
static void
go32_terminal_inferior (void);
static void
go32_terminal_ours (void);
a814 35
static int inf_flags_valid = 0;
static int inf_in_flag;
static int inf_out_flag;

static void
go32_terminal_init (void)
{
  /* Save the filemodes for stdin/stout */
  inf_in_flag = setmode(0, 0);
  setmode(0, inf_in_flag);
  inf_out_flag = setmode(1, 0);
  setmode(1, inf_out_flag);
  inf_flags_valid = 1;
}

static void
go32_terminal_inferior (void)
{
  /* set the filemodes for stdin/stdout of the inferior */
  if (inf_flags_valid)
  {
    setmode(0, inf_in_flag);
    setmode(1, inf_out_flag);
  }
}

static void
go32_terminal_ours (void)
{
  /* Switch to text mode on stdin/stdout always on the gdb terminal and
     save the inferior modes to be restored later */
  inf_in_flag = setmode(0, O_TEXT);
  inf_out_flag = setmode(1, O_TEXT);
}

d834 2
a835 2
  go32_ops.to_terminal_init = go32_terminal_init;
  go32_ops.to_terminal_inferior = go32_terminal_inferior;
d837 1
a837 1
  go32_ops.to_terminal_ours = go32_terminal_ours;
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d32 1
a32 1
#include <stdio.h>		/* required for __DJGPP_MINOR__ */
d42 19
a60 23
typedef struct
  {
    unsigned short sig0;
    unsigned short sig1;
    unsigned short sig2;
    unsigned short sig3;
    unsigned short exponent:15;
    unsigned short sign:1;
  }
NPXREG;

typedef struct
  {
    unsigned int control;
    unsigned int status;
    unsigned int tag;
    unsigned int eip;
    unsigned int cs;
    unsigned int dataptr;
    unsigned int datasel;
    NPXREG reg[8];
  }
NPX;
d64 2
a65 2
static void save_npx (void);	/* Save the FPU of the debugged program */
static void load_npx (void);	/* Restore the FPU of the debugged program */
a68 1
/* *INDENT-OFF* */
d74 7
a80 7
       testb $0x20, %%al
       jz 1f
       xorb %% al, %%al
       outb %% al, $0xf0
       movb $0x20, %%al
       outb %% al, $0xa0
       outb %% al, $0x20
d82 5
a86 5
       fnsave % 0
       fwait "
:     "=m" (npx)
:				/* No input */
:     "%eax");
a87 7

/* *INDENT-ON* */





d94 1
a94 1
asm ("frstor %0":"=m" (npx));
d101 15
a115 15
  {
    unsigned short control;
    unsigned short r0;
    unsigned short status;
    unsigned short r1;
    unsigned short tag;
    unsigned short r2;
    unsigned long eip;
    unsigned short code_seg;
    unsigned short opcode;
    unsigned long operand;
    unsigned short operand_seg;
    unsigned short r3;
    unsigned char regs[8][10];
  };
d122 41
a162 21
static void print_387_status (unsigned short status, struct env387 *ep);
static void go32_open (char *name, int from_tty);
static void go32_close (int quitting);
static void go32_attach (char *args, int from_tty);
static void go32_detach (char *args, int from_tty);
static void go32_resume (int pid, int step, enum target_signal siggnal);
static int go32_wait (int pid, struct target_waitstatus *status);
static void go32_fetch_registers (int regno);
static void store_register (int regno);
static void go32_store_registers (int regno);
static void go32_prepare_to_store (void);
static int go32_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
			     int write, struct target_ops *target);
static void go32_files_info (struct target_ops *target);
static void go32_stop (void);
static void go32_kill_inferior (void);
static void go32_create_inferior (char *exec_file, char *args, char **env);
static void go32_mourn_inferior (void);
static int go32_can_run (void);
static void ignore (void);
static void ignore2 (char *a, int b);
d164 1
a164 1
					   CORE_ADDR addr, int len, int rw);
d166 1
a166 1
					   CORE_ADDR addr, int len, int rw);
d169 6
a174 3
static void go32_terminal_init (void);
static void go32_terminal_inferior (void);
static void go32_terminal_ours (void);
d257 30
a286 30
    r_ofs (tss_ecx), 4,
    r_ofs (tss_edx), 4,
    r_ofs (tss_ebx), 4,
    r_ofs (tss_esp), 4,
    r_ofs (tss_ebp), 4,
    r_ofs (tss_esi), 4,
    r_ofs (tss_edi), 4,
    r_ofs (tss_eip), 4,
    r_ofs (tss_eflags), 4,
    r_ofs (tss_cs), 2,
    r_ofs (tss_ss), 2,
    r_ofs (tss_ds), 2,
    r_ofs (tss_es), 2,
    r_ofs (tss_fs), 2,
    r_ofs (tss_gs), 2,
    0, 10,
    1, 10,
    2, 10,
    3, 10,
    4, 10,
    5, 10,
    6, 10,
    7, 10,
    0, 2,
    4, 2,
    8, 2,
    12, 4,
    16, 2,
    20, 4,
    24, 2
d297 20
a316 20
    1, TARGET_SIGNAL_TRAP,
    2, TARGET_SIGNAL_UNKNOWN,
    3, TARGET_SIGNAL_TRAP,
    4, TARGET_SIGNAL_FPE,
    5, TARGET_SIGNAL_SEGV,
    6, TARGET_SIGNAL_ILL,
    7, TARGET_SIGNAL_FPE,
    8, TARGET_SIGNAL_SEGV,
    9, TARGET_SIGNAL_SEGV,
    10, TARGET_SIGNAL_BUS,
    11, TARGET_SIGNAL_SEGV,
    12, TARGET_SIGNAL_SEGV,
    13, TARGET_SIGNAL_ABRT,
    14, TARGET_SIGNAL_SEGV,
    16, TARGET_SIGNAL_FPE,
    31, TARGET_SIGNAL_ILL,
    0x75, TARGET_SIGNAL_FPE,
    0x79, TARGET_SIGNAL_INT,
    0x1b, TARGET_SIGNAL_INT,
    -1, -1
d345 3
a347 3
{
  resume_is_step = step;
}
d393 1
a393 1
  /*JHW */
d631 1
a631 1
#if 0				/* use debugging macro */
d829 4
a832 4
  inf_in_flag = setmode (0, 0);
  setmode (0, inf_in_flag);
  inf_out_flag = setmode (1, 0);
  setmode (1, inf_out_flag);
d841 4
a844 4
    {
      setmode (0, inf_in_flag);
      setmode (1, inf_out_flag);
    }
d852 2
a853 2
  inf_in_flag = setmode (0, O_TEXT);
  inf_out_flag = setmode (1, O_TEXT);
@


1.1.1.5
log
@import gdb-1999-08-23 snapshot
@
text
@a35 1
#include <errno.h>
a36 2
#include <io.h>
#include <dpmi.h>
a38 3
#if __DJGPP_MINOR__ > 2
#include <debug/redir.h>
#endif
a108 21
/* ------------------------------------------------------------------------- */
/* Stubs for the missing redirection functions.  */
typedef struct {
  char *command;
  int redirected;
} cmdline_t;

void redir_cmdline_delete (cmdline_t *ptr) {ptr->redirected = 0;}
int  redir_cmdline_parse (const char *args, cmdline_t *ptr)
{
  return -1;
}
int redir_to_child (cmdline_t *ptr)
{
  return 1;
}
int redir_to_debugger (cmdline_t *ptr)
{
  return 1;
}
int redir_debug_init (cmdline_t *ptr) { return 0; }
a129 5
typedef enum { wp_insert, wp_remove, wp_count } wp_op;

/* This holds the current reference counts for each debug register.  */
static int dr_ref_count[4];

a151 1
static void cleanup_dregs (void);
d156 4
a159 6
static int go32_insert_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
					   int len, int rw);
static int go32_remove_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
					   int len, int rw);
static int go32_handle_nonaligned_watchpoint (wp_op what, CORE_ADDR waddr,
					      CORE_ADDR addr, int len, int rw);
d190 2
a191 8
  /* Other platforms say "last exception", but that's not true: the
     FPU stores the last non-control instruction there.  */
  printf_unfiltered ("last FP instruction: ");
  /* The ORing with D800h restores the upper 5 bits of the opcode that
     are not stored by the FPU (since these bits are the same for all
     floating-point instructions).  */
  printf_unfiltered ("opcode %s; ",
		     local_hex_string (ep->opcode ? (ep->opcode|0xd800) : 0));
d199 2
a200 2
  printf_unfiltered ("regno tag     msb              lsb  value\n");
  for (fpreg = 7; fpreg >= 0; fpreg--)
a201 4
      /* FNSAVE saves the FP registers in their logical TOP-relative
	 order, beginning with ST(0).  Since we need to print them in
	 their physical order, we have to remap them.  */
      int  regno = fpreg - top;
a203 3
      if (regno < 0)
	regno += 8;

d209 1
a209 1
	  printf_unfiltered ("valid   ");
d212 1
a212 1
	  printf_unfiltered ("zero    ");
d215 1
a215 3
	  /* All other versions of print_387_status use TRAP here, but I
	     think this is misleading, since Intel manuals say SPECIAL.  */
	  printf_unfiltered ("special ");
d218 1
a218 1
	  printf_unfiltered ("empty   ");
d221 2
a222 2
      for (i = 9; i >= 0; i--)
	printf_unfiltered ("%02x", ep->regs[regno][i]);
d224 2
a225 2
      REGISTER_CONVERT_TO_VIRTUAL (FP0_REGNUM+regno, builtin_type_long_double,
				   &ep->regs[regno], &val);
d227 1
a227 1
      printf_unfiltered ("  %.19LG\n", val);
d237 1
a237 1
#define r_ofs(x) (offsetof(TSS,x))
d241 2
a242 2
  size_t tss_ofs;
  size_t size;
d246 1
a246 1
  r_ofs (tss_eax), 4,	/* normal registers, from a_tss */
d262 1
a262 1
    0, 10,		/* 8 FP registers, from npx.reg[] */
d270 7
a276 9
	/* The order of the next 7 registers must be consistent
	   with their numbering in config/i386/tm-go32.h, which see.  */
  0, 2,			/* control word, from npx */
  4, 2,			/* status word, from npx */
  8, 2,			/* tag word, from npx */
  16, 2,		/* last FP exception CS from npx */
  24, 2,		/* last FP exception operand selector from npx */
  12, 4,		/* last FP exception EIP from npx */
  20, 4			/* last FP exception operand offset from npx */
d288 1
a288 4
  /* Exception 2 is triggered by the NMI.  DJGPP handles it as SIGILL,
     but I think SIGBUS is better, since the NMI is usually activated
     as a result of a memory parity check failure.  */
    2, TARGET_SIGNAL_BUS,
d299 1
a299 1
    13, TARGET_SIGNAL_SEGV,
a301 1
    17, TARGET_SIGNAL_BUS,
a302 1
    0x1b, TARGET_SIGNAL_INT,
a303 1
    0x78, TARGET_SIGNAL_ALRM,
d305 1
a305 1
    0x7a, TARGET_SIGNAL_QUIT,
a308 20
static struct {
  enum target_signal gdb_sig;
  int djgpp_excepno;
} excepn_map[] = {
  TARGET_SIGNAL_0, -1,
  TARGET_SIGNAL_ILL, 6,		/* Invalid Opcode */
  TARGET_SIGNAL_EMT, 7,		/* triggers SIGNOFP */
  TARGET_SIGNAL_SEGV, 13,	/* GPF */
  TARGET_SIGNAL_BUS, 17,	/* Alignment Check */
  /* The rest are fake exceptions, see dpmiexcp.c in djlsr*.zip for
     details.  */
  TARGET_SIGNAL_TERM, 0x1b,	/* triggers Ctrl-Break type of SIGINT */
  TARGET_SIGNAL_FPE, 0x75,
  TARGET_SIGNAL_INT, 0x79,
  TARGET_SIGNAL_QUIT, 0x7a,
  TARGET_SIGNAL_ALRM, 0x78,	/* triggers SIGTIMR */
  TARGET_SIGNAL_PROF, 0x78,
  -1, -1
};

d312 1
a312 1
  printf_unfiltered ("Done.  Use the \"run\" command to run the program.\n");
d323 1
a323 3
  error ("\
You cannot attach to a running program on this platform.\n\
Use the `run' command to run DJGPP programs.");
a331 1
static int resume_signal = -1;
a335 2
  int i;

a336 13

  if (siggnal != TARGET_SIGNAL_0 && siggnal != TARGET_SIGNAL_TRAP)
  {
    for (i = 0, resume_signal = -1; excepn_map[i].gdb_sig != -1; i++)
      if (excepn_map[i].gdb_sig == siggnal)
      {
	resume_signal = excepn_map[i].djgpp_excepno;
	break;
      }
    if (resume_signal == -1)
      printf_unfiltered ("Cannot deliver signal %s on this platform.\n",
			 target_signal_to_name (siggnal));
  }
a338 2
static char child_cwd[FILENAME_MAX];

a342 3
  unsigned char saved_opcode;
  unsigned long INT3_addr;
  int stepping_over_INT = 0;
a343 1
  a_tss.tss_eflags &= 0xfeff;	/* reset the single-step flag (TF) */
d345 1
a345 37
    {
      /* If the next instruction is INT xx or INTO, we need to handle
	 them specially.  Intel manuals say that these instructions
	 reset the single-step flag (a.k.a. TF).  However, it seems
	 that, at least in the DPMI environment, and at least when
	 stepping over the DPMI interrupt 31h, the problem is having
	 TF set at all when INT 31h is executed: the debuggee either
	 crashes (and takes the system with it) or is killed by a
	 SIGTRAP.

	 So we need to emulate single-step mode: we put an INT3 opcode
	 right after the INT xx instruction, let the debuggee run
	 until it hits INT3 and stops, then restore the original
	 instruction which we overwrote with the INT3 opcode, and back
	 up the debuggee's EIP to that instruction.  */
      read_child (a_tss.tss_eip, &saved_opcode, 1);
      if (saved_opcode == 0xCD || saved_opcode == 0xCE)
	{
	  unsigned char INT3_opcode = 0xCC;

	  INT3_addr
	    = saved_opcode == 0xCD ? a_tss.tss_eip + 2 : a_tss.tss_eip + 1;
	  stepping_over_INT = 1;
	  read_child (INT3_addr, &saved_opcode, 1);
	  write_child (INT3_addr, &INT3_opcode, 1);
	}
      else
	a_tss.tss_eflags |= 0x0100; /* normal instruction: set TF */
    }

  /* The special value FFFFh in tss_trap indicates to run_child that
     tss_irqn holds a signal to be delivered to the debuggee.  */
  if (resume_signal <= -1)
    {
      a_tss.tss_trap = 0;
      a_tss.tss_irqn = 0xff;
    }
d347 1
a347 13
    {
      a_tss.tss_trap = 0xffff;	/* run_child looks for this */
      a_tss.tss_irqn = resume_signal;
    }

  /* The child might change working directory behind our back.  The
     GDB users won't like the side effects of that when they work with
     relative file names, and GDB might be confused by its current
     directory not being in sync with the truth.  So we always make a
     point of changing back to where GDB thinks is its cwd, when we
     return control to the debugger, but restore child's cwd before we
     run it.  */
  chdir (child_cwd);
d350 1
a350 1
  load_npx ();
d354 1
a354 1
  save_npx ();
a356 14
  /* Did we step over an INT xx instruction?  */
  if (stepping_over_INT && a_tss.tss_eip == INT3_addr + 1)
    {
      /* Restore the original opcode.  */
      a_tss.tss_eip--;	/* EIP points *after* the INT3 instruction */
      write_child (a_tss.tss_eip, &saved_opcode, 1);
      /* Simulate a TRAP exception.  */
      a_tss.tss_irqn = 1;
      a_tss.tss_eflags |= 0x0100;
    }

  getcwd (child_cwd, sizeof (child_cwd)); /* in case it has changed */
  chdir (current_directory);

a369 1
#if __DJGPP_MINOR__ < 3
a372 3
#else
	      status->value.sig = sig_map[i].gdb_sig;
#endif
d403 1
a403 1
			 (char *) &npx + regno_mapping[regno].tss_ofs);
d405 5
a409 1
	fatal ("Invalid register no. %d in go32_fetch_register.", regno);
d423 1
a423 1
  else if (regno < 31)
d426 4
a429 1
    fatal ("Invalid register no. %d in store_register.", regno);
a479 2
static cmdline_t child_cmd;	/* parsed child's command line kept here */

d483 1
a483 1
  printf_unfiltered ("You are running a DJGPP V2 program.\n");
a497 3
  redir_cmdline_delete (&child_cmd);
  resume_signal = -1;
  resume_is_step = 0;
a512 16
  resume_signal = -1;
  resume_is_step = 0;
  /* Init command line storage.  */
  if (redir_debug_init (&child_cmd) == -1)
    fatal ("Cannot allocate redirection storage: not enough memory.\n");

  /* Parse the command line and create redirections.  */
  if (strpbrk (args, "<>"))
    {
      if (redir_cmdline_parse (args, &child_cmd) == 0)
	args = child_cmd.command;
      else
	error ("Syntax error in command line.");
    }
  else
    child_cmd.command = strdup (args);
a529 3
#if __DJGPP_MINOR__ < 3
  save_npx ();
#endif
a541 8
  /* We need to make sure all the breakpoint enable bits in the DR7
     register are reset when the inferior exits.  Otherwise, if they
     rerun the inferior, the uncleared bits may cause random SIGTRAPs,
     failure to set more watchpoints, and other calamities.  It would
     be nice if GDB itself would take care to remove all breakpoints
     at all times, but it doesn't, probably under an assumption that
     the OS cleans up when the debuggee exits.  */
  cleanup_dregs ();
d557 5
d573 1
a573 1
#define DR_RW_READWRITE 0x3
d586 1
a586 1
  (!(CONTROL & (3 << (DR_ENABLE_SIZE * (index)))))
d589 1
a589 1
  (CONTROL |= (1 << (DR_LOCAL_ENABLE_SHIFT + DR_ENABLE_SIZE * (index))))
d592 1
a592 1
  (CONTROL |= (1 << (DR_GLOBAL_ENABLE_SHIFT + DR_ENABLE_SIZE * (index))))
d595 1
a595 1
  (CONTROL &= ~(3 << (DR_ENABLE_SIZE * (index))))
a602 6
#define RESET_LOCAL_EXACT() \
   (CONTROL &= ~(DR_LOCAL_SLOWDOWN))

#define RESET_GLOBAL_EXACT() \
   (CONTROL &= ~(DR_GLOBAL_SLOWDOWN))

d605 1
a605 1
    CONTROL &= ~(DR_CONTROL_MASK << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * (index)));\
d612 1
a612 1
    CONTROL |= ((len)|(rw)) << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * (index));\
a614 3
#define IS_WATCH(index) \
  (CONTROL & (DR_CONTROL_MASK << (DR_CONTROL_SHIFT + DR_CONTROL_SIZE*(index))))

d621 2
a622 6
#define DR_DEF(index) \
  ((CONTROL >> (DR_CONTROL_SHIFT + DR_CONTROL_SIZE * (index))) & 0x0f)
    

#if 0 /* use debugging macro */
#define SHOW_DR(text,len) \
a623 1
  if (!getenv ("GDB_SHOW_DR")) break; \
d625 3
a627 5
  fprintf(stderr,"%08x %d %08x %d ", \
	  edi.dr[0],dr_ref_count[0],edi.dr[1],dr_ref_count[1]); \
  fprintf(stderr,"%08x %d %08x %d ", \
	  edi.dr[2],dr_ref_count[2],edi.dr[3],dr_ref_count[3]); \
  fprintf(stderr,(len)?"(%s:%d)\n":"(%s)\n",#text,len); \
d630 1
a630 1
#define SHOW_DR(text,len) do {} while (0)
a632 14
static void
cleanup_dregs (void)
{
  int i;

  CONTROL = 0;
  STATUS = 0;
  for (i = 0; i < 4; i++)
    {
      D_REGS[i] = 0;
      dr_ref_count[i] = 0;
    }
}

d638 1
a638 1
  int ret = go32_insert_aligned_watchpoint (addr, addr, len, rw);
d640 1
a640 1
  SHOW_DR (insert_watch, len);
d645 1
a645 1
go32_insert_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
d651 2
a652 28
  /* Values of rw: 0 - write, 1 - read, 2 - access (read and write).
     However, x86 doesn't support read-only data breakpoints.  */
  read_write_bits = rw ? DR_RW_READWRITE : DR_RW_WRITE;

  switch (len)
  {
  case 4:
    len_bits = DR_LEN_4;
    break;
  case 2:
    len_bits = DR_LEN_2;
    break;
  case 1:
    len_bits = DR_LEN_1;
    break;
  default:
    /* The debug registers only have 2 bits for the length, so
       so this value will always fail the loop below.  */
    len_bits = 0x10;
  }

  /* Look for an occupied debug register with the same address and the
     same RW and LEN definitions.  If we find one, we can use it for
     this watchpoint as well (and save a register).  */
  for (i = 0; i < 4; i++)
  {
    if (!IS_REG_FREE (i) && D_REGS[i] == addr
	&& DR_DEF (i) == (len_bits | read_write_bits))
d654 2
a655 2
      dr_ref_count[i]++;
      return 0;
a656 8
  }

  /* Look for a free debug register.  */
  for (i = 0; i <= 3; i++)
  {
    if (IS_REG_FREE (i))
      break;
  }
d662 10
a671 6
  if (len == 2)
  {
    if (addr % 2)
      return go32_handle_nonaligned_watchpoint (wp_insert, waddr, addr,
						len, rw);
  }
d673 7
a679 7
  {
    if (addr % 4)
      return go32_handle_nonaligned_watchpoint (wp_insert, waddr, addr,
						len, rw);
  }
  else if (len != 1)
    return go32_handle_nonaligned_watchpoint (wp_insert, waddr, addr, len, rw);
a683 2
  SET_GLOBAL_EXACT ();
  return 0;
d687 1
a687 1
go32_handle_nonaligned_watchpoint (wp_op what, CORE_ADDR waddr, CORE_ADDR addr,
d692 1
a692 1
  int rv = 0, status = 0;
d708 6
a713 18
      if (what == wp_insert)
	status = go32_insert_aligned_watchpoint (waddr, addr, size, rw);
      else if (what == wp_remove)
	status = go32_remove_aligned_watchpoint (waddr, addr, size, rw);
      else if (what == wp_count)
	rv++;
      else
	status = -1;
      /* We keep the loop going even after a failure, because some of
	 the other aligned watchpoints might still succeed, e.g. if
	 they watch addresses that are already watched, and thus just
	 increment the reference counts of occupied debug registers.
	 If we break out of the loop too early, we could cause those
	 addresses watched by other watchpoints to be disabled when
	 GDB reacts to our failure to insert this watchpoint and tries
	 to remove it.  */
      if (status)
	rv = status;
d723 1
a723 11
go32_remove_watchpoint (int pid, CORE_ADDR addr, int len, int rw)
{
  int ret = go32_remove_aligned_watchpoint (addr, addr, len, rw);

  SHOW_DR (remove_watch, len);
  return ret;
}

static int
go32_remove_aligned_watchpoint (CORE_ADDR waddr, CORE_ADDR addr,
				int len, int rw)
a725 37
  int read_write_bits, len_bits;

  /* Values of rw: 0 - write, 1 - read, 2 - access (read and write).
     However, x86 doesn't support read-only data breakpoints.  */
  read_write_bits = rw ? DR_RW_READWRITE : DR_RW_WRITE;

  switch (len)
    {
      case 4:
	len_bits = DR_LEN_4;
	break;
      case 2:
	len_bits = DR_LEN_2;
	break;
      case 1:
	len_bits = DR_LEN_1;
	break;
      default:
	/* The debug registers only have 2 bits for the length, so
	   so this value will always fail the loop below.  */
	len_bits = 0x10;
    }

  if (len == 2)
    {
      if (addr % 2)
	return go32_handle_nonaligned_watchpoint (wp_remove, waddr, addr,
						  len, rw);
    }
  else if (len == 4)
    {
      if (addr % 4)
	return go32_handle_nonaligned_watchpoint (wp_remove, waddr, addr,
						  len, rw);
    }
  else if (len != 1)
    return go32_handle_nonaligned_watchpoint (wp_remove, waddr, addr, len, rw);
d729 1
a729 2
      if (!IS_REG_FREE (i) && D_REGS[i] == addr
	  && DR_DEF (i) == (len_bits | read_write_bits))
d731 1
a731 3
	  dr_ref_count[i]--;
	  if (dr_ref_count[i] == 0)
	    DISABLE_REG (i);
d734 1
a734 2
  RESET_LOCAL_EXACT ();
  RESET_GLOBAL_EXACT ();
d739 1
a739 15
/* Can we use debug registers to watch a region whose address is ADDR
   and whose length is LEN bytes?  */

int
go32_region_ok_for_watchpoint (CORE_ADDR addr, int len)
{
  /* Compute how many aligned watchpoints we would need to cover this
     region.  */
  int nregs = go32_handle_nonaligned_watchpoint (wp_count, addr, addr, len, 0);

  return nregs <= 4 ? 1 : 0;
}

/* Check if stopped by a data watchpoint.  If so, return the address
   whose access triggered the watchpoint.  */
d742 1
a742 1
go32_stopped_by_watchpoint (int pid, int data_watchpoint)
d748 1
a748 1
  SHOW_DR (stopped_by, 0);
d751 1
a751 1
      if (WATCH_HIT (i) && data_watchpoint)
d753 1
a753 1
	  SHOW_DR (WP_HIT, 0);
d757 7
d776 1
a776 1
      if (!IS_REG_FREE (i) && D_REGS[i] == addr && DR_DEF (i) == 0)
d778 1
a778 3
	  dr_ref_count[i]--;
	  if (dr_ref_count[i] == 0)
	    DISABLE_REG (i);
d781 1
a781 1
  SHOW_DR (remove_hw, 0);
a792 13
  /* Look for an occupied debug register with the same address and the
     same RW and LEN definitions.  If we find one, we can use it for
     this breakpoint as well (and save a register).  */
  for (i = 0; i < 4; i++)
    {
      if (!IS_REG_FREE (i) && D_REGS[i] == addr && DR_DEF (i) == 0)
	{
	  dr_ref_count[i]++;
	  SHOW_DR (insert_hw, 0);
	  return 0;
	}
    }

d800 7
a806 7
  /* No more debug registers?  */
  if (i < 4)
    {
      SET_BREAK (i, addr);
      LOCAL_ENABLE_REG (i);
    }
  SHOW_DR (insert_hw, 0);
d808 1
a808 1
  return i < 4 ? 0 : -1;
a814 43
/* Put the device open on handle FD into either raw or cooked
   mode, return 1 if it was in raw mode, zero otherwise.  */

static int
device_mode (int fd, int raw_p)
{
  int oldmode, newmode;
  __dpmi_regs regs;

  regs.x.ax = 0x4400;
  regs.x.bx = fd;
  __dpmi_int (0x21, &regs);
  if (regs.x.flags & 1)
    return -1;
  newmode = oldmode = regs.x.dx;

  if (raw_p)
    newmode |= 0x20;
  else
    newmode &= ~0x20;

  if (oldmode & 0x80)	/* Only for character dev */
  {
    regs.x.ax = 0x4401;
    regs.x.bx = fd;
    regs.x.dx = newmode & 0xff;   /* Force upper byte zero, else it fails */
    __dpmi_int (0x21, &regs);
    if (regs.x.flags & 1)
      return -1;
  }
  return (oldmode & 0x20) == 0x20;
}


static int inf_mode_valid = 0;
static int inf_terminal_mode;

/* This semaphore is needed because, amazingly enough, GDB calls
   target.to_terminal_ours more than once after the inferior stops.
   But we need the information from the first call only, since the
   second call will always see GDB's own cooked terminal.  */
static int terminal_is_ours = 1;

d818 6
a823 2
  inf_mode_valid = 0;	/* reinitialize, in case they are restarting child */
  terminal_is_ours = 1;
d827 1
a827 1
go32_terminal_info (char *args, int from_tty)
d829 2
a830 10
  printf_unfiltered ("Inferior's terminal is in %s mode.\n",
		     !inf_mode_valid
		     ? "default" : inf_terminal_mode ? "raw" : "cooked");

#if __DJGPP_MINOR__ > 2
  if (child_cmd.redirection)
  {
    int i;

    for (i = 0; i < DBG_HANDLES; i++)
d832 2
a833 11
      if (child_cmd.redirection[i]->file_name)
	printf_unfiltered ("\tFile handle %d is redirected to `%s'.\n",
			   i, child_cmd.redirection[i]->file_name);
      else if (_get_dev_info (child_cmd.redirection[i]->inf_handle) == -1)
	printf_unfiltered
	  ("\tFile handle %d appears to be closed by inferior.\n", i);
      /* Mask off the raw/cooked bit when comparing device info words.  */
      else if ((_get_dev_info (child_cmd.redirection[i]->inf_handle) & 0xdf)
	       != (_get_dev_info (i) & 0xdf))
	printf_unfiltered
	  ("\tFile handle %d appears to be redirected by inferior.\n", i);
a834 23
  }
#endif
}

static void
go32_terminal_inferior (void)
{
  /* Redirect standard handles as child wants them.  */
  errno = 0;
  if (redir_to_child (&child_cmd) == -1)
  {
    redir_to_debugger (&child_cmd);
    error ("Cannot redirect standard handles for program: %s.",
	   strerror (errno));
  }
  /* set the console device of the inferior to whatever mode
     (raw or cooked) we found it last time */
  if (terminal_is_ours)
  {
    if (inf_mode_valid)
      device_mode (0, inf_terminal_mode);
    terminal_is_ours = 0;
  }
d840 4
a843 22
  /* Switch to cooked mode on the gdb terminal and save the inferior
     terminal mode to be restored when it is resumed */
  if (!terminal_is_ours)
  {
    inf_terminal_mode = device_mode (0, 0);
    if (inf_terminal_mode != -1)
      inf_mode_valid = 1;
    else
      /* If device_mode returned -1, we don't know what happens with
	 handle 0 anymore, so make the info invalid.  */
      inf_mode_valid = 0;
    terminal_is_ours = 1;

    /* Restore debugger's standard handles.  */
    errno = 0;
    if (redir_to_debugger (&child_cmd) == -1)
    {
      redir_to_child (&child_cmd);
      error ("Cannot redirect standard handles for debugger: %s.",
	     strerror (errno));
    }
  }
a854 1
  go32_ops.to_attach = go32_attach;
d867 1
a867 1
  go32_ops.to_terminal_ours_for_output = go32_terminal_ours;
d869 1
a869 1
  go32_ops.to_terminal_info = go32_terminal_info;
a881 7

  /* Initialize child's cwd with the current one.  */
  getcwd (child_cwd, sizeof (child_cwd));

  /* Initialize child's command line storage.  */
  if (redir_debug_init (&child_cmd) == -1)
    fatal ("Cannot allocate redirection storage: not enough memory.\n");
a888 18
}

pid_t
tcgetpgrp (int fd)
{
  if (isatty (fd))
    return SOME_PID;
  errno = ENOTTY;
  return -1;
}

int
tcsetpgrp (int fd, pid_t pgid)
{
  if (isatty (fd) && pgid == SOME_PID)
    return 0;
  errno = pgid == SOME_PID ? ENOTTY : ENOSYS;
  return -1;
@


1.1.1.6
log
@import gdb-1999-08-30 snapshot
@
text
@d37 1
@


1.1.1.7
log
@import gdb-1999-09-21
@
text
@a36 1
#include <unistd.h>
a799 1
    dr_ref_count[index]++;\
d811 5
a815 1
#define WATCH_HIT(index) ((STATUS & (1 << (index))) && IS_WATCH(index))
d1144 4
@


1.1.1.8
log
@import gdb-1999-10-04 snapshot
@
text
@d720 1
a720 1
  proceed ((CORE_ADDR) -1, TARGET_SIGNAL_0, 0);
@


1.1.1.9
log
@import gdb-1999-11-16 snapshot
@
text
@d348 1
a348 1
    7, TARGET_SIGNAL_EMT,	/* no-coprocessor exception */
d573 1
a573 2
	internal_error ("Invalid register no. %d in go32_fetch_register.",
			regno);
d590 1
a590 1
    internal_error ("Invalid register no. %d in store_register.", regno);
d683 1
a683 1
    internal_error ("Cannot allocate redirection storage: not enough memory.\n");
d1314 1
a1314 1
    internal_error ("Cannot allocate redirection storage: not enough memory.\n");
@


1.1.1.10
log
@import gdb-1999-12-06 snapshot
@
text
@d695 1
a695 1
    child_cmd.command = xstrdup (args);
@


