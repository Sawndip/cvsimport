head	1.31;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.27
	gdb_7_6-2013-04-26-release:1.27
	gdb_7_6-branch:1.27.0.2
	gdb_7_6-2013-03-12-branchpoint:1.27
	gdb_7_5_1-2012-11-29-release:1.24
	gdb_7_5-2012-08-17-release:1.24
	gdb_7_5-branch:1.24.0.2
	gdb_7_5-2012-07-18-branchpoint:1.24
	gdb_7_4_1-2012-04-26-release:1.23.2.1
	gdb_7_4-2012-01-24-release:1.23.2.1
	gdb_7_4-branch:1.23.0.2
	gdb_7_4-2011-12-13-branchpoint:1.23
	gdb_7_3_1-2011-09-04-release:1.20
	gdb_7_3-2011-07-26-release:1.20
	gdb_7_3-branch:1.20.0.2
	gdb_7_3-2011-04-01-branchpoint:1.20
	gdb_7_2-2010-09-02-release:1.16
	gdb_7_2-branch:1.16.0.2
	gdb_7_2-2010-07-07-branchpoint:1.16
	gdb_7_1-2010-03-18-release:1.14
	gdb_7_1-branch:1.14.0.2
	gdb_7_1-2010-02-18-branchpoint:1.14
	gdb_7_0_1-2009-12-22-release:1.12
	gdb_7_0-2009-10-06-release:1.12
	gdb_7_0-branch:1.12.0.4
	gdb_7_0-2009-09-16-branchpoint:1.12
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.12.0.2
	msnyder-checkpoint-072509-branchpoint:1.12
	arc-insight_6_8-branch:1.8.0.6
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.4
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.9.0.10
	reverse-20081226-branchpoint:1.9
	multiprocess-20081120-branch:1.9.0.8
	multiprocess-20081120-branchpoint:1.9
	reverse-20080930-branch:1.9.0.6
	reverse-20080930-branchpoint:1.9
	reverse-20080717-branch:1.9.0.4
	reverse-20080717-branchpoint:1.9
	msnyder-reverse-20080609-branch:1.9.0.2
	msnyder-reverse-20080609-branchpoint:1.9
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.2
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.5.2.1
	gdb_6_7-2007-10-10-release:1.5
	gdb_6_7-branch:1.5.0.2
	gdb_6_7-2007-09-07-branchpoint:1.5
	gdb-csl-symbian-6_4_50_20060226-12:1.1.2.2
	gdb-csl-symbian-6_4_50_20060226-11:1.1.2.2
	gdb-csl-symbian-6_4_50_20060226-10:1.1.2.2
	gdb-csl-symbian-6_4_50_20060226-9:1.1.2.2
	gdb-csl-symbian-6_4_50_20060226-8:1.1.2.2
	gdb-csl-symbian-20060226-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.31
date	2013.07.16.20.41.55;	author devans;	state Exp;
branches;
next	1.30;

1.30
date	2013.06.24.22.18.32;	author macro;	state Exp;
branches;
next	1.29;

1.29
date	2013.05.04.06.19.31;	author devans;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.08.20.04.42;	author tromey;	state Exp;
branches;
next	1.27;

1.27
date	2013.01.31.13.52.52;	author aristovski;	state Exp;
branches;
next	1.26;

1.26
date	2013.01.01.06.32.51;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2012.12.14.23.27.13;	author muller;	state Exp;
branches;
next	1.24;

1.24
date	2012.01.04.08.17.11;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2011.08.05.16.38.40;	author ppluzhnikov;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.29.17.38.47;	author tromey;	state Exp;
branches;
next	1.20;

1.20
date	2011.02.02.16.12.59;	author palves;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.25.09.49.59;	author palves;	state Exp;
branches;
next	1.18;

1.18
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.17;

1.17
date	2011.01.01.15.33.15;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.15.17.57.38;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2010.05.16.23.49.58;	author msnyder;	state Exp;
branches;
next	1.14;

1.14
date	2010.01.08.22.52.03;	author jkratoch;	state Exp;
branches;
next	1.13;

1.13
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2009.07.17.17.08.23;	author uweigand;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.22.23.49.13;	author palves;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2008.03.14.22.30.07;	author palves;	state Exp;
branches;
next	1.8;

1.8
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.7;

1.7
date	2007.10.24.21.16.30;	author uweigand;	state Exp;
branches;
next	1.6;

1.6
date	2007.10.12.21.52.07;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2007.08.05.09.57.06;	author palves;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.08.19.31.11;	author palves;	state Exp;
branches;
next	1.2;

1.2
date	2007.07.02.22.01.09;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.12.18.11.40;	author drow;	state dead;
branches
	1.1.2.1;
next	;

1.23.2.1
date	2012.01.06.04.43.30;	author brobecke;	state Exp;
branches;
next	;

1.5.2.1
date	2007.10.13.06.00.36;	author brobecke;	state Exp;
branches;
next	;

1.1.2.1
date	2006.04.12.18.11.40;	author drow;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2006.05.08.15.39.13;	author drow;	state Exp;
branches;
next	;


desc
@@


1.31
log
@	* target.h (struct target_section): Delete member bfd.
	All users updated to use the_bfd_section->owner instead.
	* exec.c (add_to_section_table): Assert bfd is expected value.
	Remove initialization of target_section.bfd.
	(remove_target_sections): Update.
	(section_table_available_memory): Update.
	(section_table_xfer_memory_partial): Update.
	(print_section_info): Update.
	(exec_set_section_address): Update.
	* record-full.c (record_full_core_xfer_partial): Update.
	* solib-svr4.c (svr4_relocate_section_addresses): Update.
	* solib-target.c (solib_target_relocate_section_addresses): Update.
	* symfile.c (build_section_addr_info_from_section_table): Update.
	* target.c (memory_xfer_live_readonly_partial): Update.
	(memory_xfer_partial_1): Update.
@
text
@/* Definitions for targets which report shared library events.

   Copyright (C) 2007-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "objfiles.h"
#include "solist.h"
#include "symtab.h"
#include "symfile.h"
#include "target.h"
#include "vec.h"
#include "solib-target.h"

#include "gdb_string.h"

/* Private data for each loaded library.  */
struct lm_info
{
  /* The library's name.  The name is normally kept in the struct
     so_list; it is only here during XML parsing.  */
  char *name;

  /* The target can either specify segment bases or section bases, not
     both.  */

  /* The base addresses for each independently relocatable segment of
     this shared library.  */
  VEC(CORE_ADDR) *segment_bases;

  /* The base addresses for each independently allocatable,
     relocatable section of this shared library.  */
  VEC(CORE_ADDR) *section_bases;

  /* The cached offsets for each section of this shared library,
     determined from SEGMENT_BASES, or SECTION_BASES.  */
  struct section_offsets *offsets;
};

typedef struct lm_info *lm_info_p;
DEF_VEC_P(lm_info_p);

#if !defined(HAVE_LIBEXPAT)

static VEC(lm_info_p) *
solib_target_parse_libraries (const char *library)
{
  static int have_warned;

  if (!have_warned)
    {
      have_warned = 1;
      warning (_("Can not parse XML library list; XML support was disabled "
		 "at compile time"));
    }

  return NULL;
}

#else /* HAVE_LIBEXPAT */

#include "xml-support.h"

/* Handle the start of a <segment> element.  */

static void
library_list_start_segment (struct gdb_xml_parser *parser,
			    const struct gdb_xml_element *element,
			    void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  VEC(lm_info_p) **list = user_data;
  struct lm_info *last = VEC_last (lm_info_p, *list);
  ULONGEST *address_p = xml_find_attribute (attributes, "address")->value;
  CORE_ADDR address = (CORE_ADDR) *address_p;

  if (last->section_bases != NULL)
    gdb_xml_error (parser,
		   _("Library list with both segments and sections"));

  VEC_safe_push (CORE_ADDR, last->segment_bases, address);
}

static void
library_list_start_section (struct gdb_xml_parser *parser,
			    const struct gdb_xml_element *element,
			    void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  VEC(lm_info_p) **list = user_data;
  struct lm_info *last = VEC_last (lm_info_p, *list);
  ULONGEST *address_p = xml_find_attribute (attributes, "address")->value;
  CORE_ADDR address = (CORE_ADDR) *address_p;

  if (last->segment_bases != NULL)
    gdb_xml_error (parser,
		   _("Library list with both segments and sections"));

  VEC_safe_push (CORE_ADDR, last->section_bases, address);
}

/* Handle the start of a <library> element.  */

static void
library_list_start_library (struct gdb_xml_parser *parser,
			    const struct gdb_xml_element *element,
			    void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  VEC(lm_info_p) **list = user_data;
  struct lm_info *item = XZALLOC (struct lm_info);
  const char *name = xml_find_attribute (attributes, "name")->value;

  item->name = xstrdup (name);
  VEC_safe_push (lm_info_p, *list, item);
}

static void
library_list_end_library (struct gdb_xml_parser *parser,
			  const struct gdb_xml_element *element,
			  void *user_data, const char *body_text)
{
  VEC(lm_info_p) **list = user_data;
  struct lm_info *lm_info = VEC_last (lm_info_p, *list);

  if (lm_info->segment_bases == NULL
      && lm_info->section_bases == NULL)
    gdb_xml_error (parser,
		   _("No segment or section bases defined"));
}


/* Handle the start of a <library-list> element.  */

static void
library_list_start_list (struct gdb_xml_parser *parser,
			 const struct gdb_xml_element *element,
			 void *user_data, VEC(gdb_xml_value_s) *attributes)
{
  char *version = xml_find_attribute (attributes, "version")->value;

  if (strcmp (version, "1.0") != 0)
    gdb_xml_error (parser,
		   _("Library list has unsupported version \"%s\""),
		   version);
}

/* Discard the constructed library list.  */

static void
solib_target_free_library_list (void *p)
{
  VEC(lm_info_p) **result = p;
  struct lm_info *info;
  int ix;

  for (ix = 0; VEC_iterate (lm_info_p, *result, ix, info); ix++)
    {
      xfree (info->name);
      VEC_free (CORE_ADDR, info->segment_bases);
      VEC_free (CORE_ADDR, info->section_bases);
      xfree (info);
    }
  VEC_free (lm_info_p, *result);
  *result = NULL;
}

/* The allowed elements and attributes for an XML library list.
   The root element is a <library-list>.  */

static const struct gdb_xml_attribute segment_attributes[] = {
  { "address", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute section_attributes[] = {
  { "address", GDB_XML_AF_NONE, gdb_xml_parse_attr_ulongest, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element library_children[] = {
  { "segment", segment_attributes, NULL,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    library_list_start_segment, NULL },
  { "section", section_attributes, NULL,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    library_list_start_section, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute library_attributes[] = {
  { "name", GDB_XML_AF_NONE, NULL, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element library_list_children[] = {
  { "library", library_attributes, library_children,
    GDB_XML_EF_REPEATABLE | GDB_XML_EF_OPTIONAL,
    library_list_start_library, library_list_end_library },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static const struct gdb_xml_attribute library_list_attributes[] = {
  { "version", GDB_XML_AF_NONE, NULL, NULL },
  { NULL, GDB_XML_AF_NONE, NULL, NULL }
};

static const struct gdb_xml_element library_list_elements[] = {
  { "library-list", library_list_attributes, library_list_children,
    GDB_XML_EF_NONE, library_list_start_list, NULL },
  { NULL, NULL, NULL, GDB_XML_EF_NONE, NULL, NULL }
};

static VEC(lm_info_p) *
solib_target_parse_libraries (const char *library)
{
  VEC(lm_info_p) *result = NULL;
  struct cleanup *back_to = make_cleanup (solib_target_free_library_list,
					  &result);

  if (gdb_xml_parse_quick (_("target library list"), "library-list.dtd",
			   library_list_elements, library, &result) == 0)
    {
      /* Parsed successfully, keep the result.  */
      discard_cleanups (back_to);
      return result;
    }

  do_cleanups (back_to);
  return NULL;
}
#endif

static struct so_list *
solib_target_current_sos (void)
{
  struct so_list *new_solib, *start = NULL, *last = NULL;
  char *library_document;
  struct cleanup *old_chain;
  VEC(lm_info_p) *library_list;
  struct lm_info *info;
  int ix;

  /* Fetch the list of shared libraries.  */
  library_document = target_read_stralloc (&current_target,
					   TARGET_OBJECT_LIBRARIES,
					   NULL);
  if (library_document == NULL)
    return NULL;

  /* solib_target_parse_libraries may throw, so we use a cleanup.  */
  old_chain = make_cleanup (xfree, library_document);

  /* Parse the list.  */
  library_list = solib_target_parse_libraries (library_document);

  /* library_document string is not needed behind this point.  */
  do_cleanups (old_chain);

  if (library_list == NULL)
    return NULL;

  /* Build a struct so_list for each entry on the list.  */
  for (ix = 0; VEC_iterate (lm_info_p, library_list, ix, info); ix++)
    {
      new_solib = XZALLOC (struct so_list);
      strncpy (new_solib->so_name, info->name, SO_NAME_MAX_PATH_SIZE - 1);
      new_solib->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
      strncpy (new_solib->so_original_name, info->name,
	       SO_NAME_MAX_PATH_SIZE - 1);
      new_solib->so_original_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
      new_solib->lm_info = info;

      /* We no longer need this copy of the name.  */
      xfree (info->name);
      info->name = NULL;

      /* Add it to the list.  */
      if (!start)
	last = start = new_solib;
      else
	{
	  last->next = new_solib;
	  last = new_solib;
	}
    }

  /* Free the library list, but not its members.  */
  VEC_free (lm_info_p, library_list);

  return start;
}

static void
solib_target_special_symbol_handling (void)
{
  /* Nothing needed.  */
}

static void
solib_target_solib_create_inferior_hook (int from_tty)
{
  /* Nothing needed.  */
}

static void
solib_target_clear_solib (void)
{
  /* Nothing needed.  */
}

static void
solib_target_free_so (struct so_list *so)
{
  gdb_assert (so->lm_info->name == NULL);
  xfree (so->lm_info->offsets);
  VEC_free (CORE_ADDR, so->lm_info->segment_bases);
  xfree (so->lm_info);
}

static void
solib_target_relocate_section_addresses (struct so_list *so,
					 struct target_section *sec)
{
  CORE_ADDR offset;

  /* Build the offset table only once per object file.  We can not do
     it any earlier, since we need to open the file first.  */
  if (so->lm_info->offsets == NULL)
    {
      int num_sections = gdb_bfd_count_sections (so->abfd);

      so->lm_info->offsets = xzalloc (SIZEOF_N_SECTION_OFFSETS (num_sections));

      if (so->lm_info->section_bases)
	{
	  int i;
	  asection *sect;
	  int num_section_bases
	    = VEC_length (CORE_ADDR, so->lm_info->section_bases);
	  int num_alloc_sections = 0;

	  for (i = 0, sect = so->abfd->sections;
	       sect != NULL;
	       i++, sect = sect->next)
	    if ((bfd_get_section_flags (so->abfd, sect) & SEC_ALLOC))
	      num_alloc_sections++;

	  if (num_alloc_sections != num_section_bases)
	    warning (_("\
Could not relocate shared library \"%s\": wrong number of ALLOC sections"),
		     so->so_name);
	  else
	    {
	      int bases_index = 0;
	      int found_range = 0;
	      CORE_ADDR *section_bases;

	      section_bases = VEC_address (CORE_ADDR,
					   so->lm_info->section_bases);

	      so->addr_low = ~(CORE_ADDR) 0;
	      so->addr_high = 0;
	      for (i = 0, sect = so->abfd->sections;
		   sect != NULL;
		   i++, sect = sect->next)
		{
		  if (!(bfd_get_section_flags (so->abfd, sect) & SEC_ALLOC))
		    continue;
		  if (bfd_section_size (so->abfd, sect) > 0)
		    {
		      CORE_ADDR low, high;

		      low = section_bases[i];
		      high = low + bfd_section_size (so->abfd, sect) - 1;

		      if (low < so->addr_low)
			so->addr_low = low;
		      if (high > so->addr_high)
			so->addr_high = high;
		      gdb_assert (so->addr_low <= so->addr_high);
		      found_range = 1;
		    }
		  so->lm_info->offsets->offsets[i]
		    = section_bases[bases_index];
		  bases_index++;
		}
	      if (!found_range)
		so->addr_low = so->addr_high = 0;
	      gdb_assert (so->addr_low <= so->addr_high);
	    }
	}
      else if (so->lm_info->segment_bases)
	{
	  struct symfile_segment_data *data;

	  data = get_symfile_segment_data (so->abfd);
	  if (data == NULL)
	    warning (_("\
Could not relocate shared library \"%s\": no segments"), so->so_name);
	  else
	    {
	      ULONGEST orig_delta;
	      int i;
	      int num_bases;
	      CORE_ADDR *segment_bases;

	      num_bases = VEC_length (CORE_ADDR, so->lm_info->segment_bases);
	      segment_bases = VEC_address (CORE_ADDR,
					   so->lm_info->segment_bases);

	      if (!symfile_map_offsets_to_segments (so->abfd, data,
						    so->lm_info->offsets,
						    num_bases, segment_bases))
		warning (_("\
Could not relocate shared library \"%s\": bad offsets"), so->so_name);

	      /* Find the range of addresses to report for this library in
		 "info sharedlibrary".  Report any consecutive segments
		 which were relocated as a single unit.  */
	      gdb_assert (num_bases > 0);
	      orig_delta = segment_bases[0] - data->segment_bases[0];

	      for (i = 1; i < data->num_segments; i++)
		{
		  /* If we have run out of offsets, assume all
		     remaining segments have the same offset.  */
		  if (i >= num_bases)
		    continue;

		  /* If this segment does not have the same offset, do
		     not include it in the library's range.  */
		  if (segment_bases[i] - data->segment_bases[i] != orig_delta)
		    break;
		}

	      so->addr_low = segment_bases[0];
	      so->addr_high = (data->segment_bases[i - 1]
			       + data->segment_sizes[i - 1]
			       + orig_delta);
	      gdb_assert (so->addr_low <= so->addr_high);

	      free_symfile_segment_data (data);
	    }
	}
    }

  offset = so->lm_info->offsets->offsets[gdb_bfd_section_index
					 (sec->the_bfd_section->owner,
					  sec->the_bfd_section)];
  sec->addr += offset;
  sec->endaddr += offset;
}

static int
solib_target_open_symbol_file_object (void *from_ttyp)
{
  /* We can't locate the main symbol file based on the target's
     knowledge; the user has to specify it.  */
  return 0;
}

static int
solib_target_in_dynsym_resolve_code (CORE_ADDR pc)
{
  /* We don't have a range of addresses for the dynamic linker; there
     may not be one in the program's address space.  So only report
     PLT entries (which may be import stubs).  */
  return in_plt_section (pc);
}

struct target_so_ops solib_target_so_ops;

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_solib_target;

void
_initialize_solib_target (void)
{
  solib_target_so_ops.relocate_section_addresses
    = solib_target_relocate_section_addresses;
  solib_target_so_ops.free_so = solib_target_free_so;
  solib_target_so_ops.clear_solib = solib_target_clear_solib;
  solib_target_so_ops.solib_create_inferior_hook
    = solib_target_solib_create_inferior_hook;
  solib_target_so_ops.special_symbol_handling
    = solib_target_special_symbol_handling;
  solib_target_so_ops.current_sos = solib_target_current_sos;
  solib_target_so_ops.open_symbol_file_object
    = solib_target_open_symbol_file_object;
  solib_target_so_ops.in_dynsym_resolve_code
    = solib_target_in_dynsym_resolve_code;
  solib_target_so_ops.bfd_open = solib_bfd_open;

  /* Set current_target_so_ops to solib_target_so_ops if not already
     set.  */
  if (current_target_so_ops == 0)
    current_target_so_ops = &solib_target_so_ops;
}
@


1.30
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@d459 3
a461 2
  offset = so->lm_info->offsets->offsets[gdb_bfd_section_index (sec->bfd,
								sec->the_bfd_section)];
@


1.29
log
@	* objfiles.c (objfile_relocate): Use gdb_bfd_count_sections instead
	of bfd_count_sections.
	* solib-target.c (solib_target_relocate_section_addresses): Ditto.
	* symfile.c (default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Ditto.  Make dummy addrs list an array of
	one entry, not bfd_count_sections entries.
@
text
@d479 1
a479 1
  return in_plt_section (pc, NULL);
@


1.28
log
@	* coffread.c (cs_to_section): Use gdb_bfd_section_index.
	* elfread.c (record_minimal_symbol, elf_symtab_read): Use
	gdb_bfd_section_index.
	* gdb_bfd.c (gdb_bfd_section_index, gdb_bfd_count_sections):
	New functions.
	* gdb_bfd.h (gdb_bfd_section_index, gdb_bfd_count_sections):
	Declare.
	* machoread.c (macho_symtab_add_minsym, macho_symfile_offsets):
	Update.
	* objfiles.c (add_to_objfile_sections_full): New function.
	(add_to_objfile_sections): Use it.
	(build_section_table): Rewrite.
	(objfile_relocate1): Use gdb_bfd_section_index.  Update.
	* objfiles.h (obj_section_offset): Use gdb_bfd_section_index.
	(struct objfile) <sections>: Update comment.
	(ALL_OBJFILE_OSECTIONS): Skip sections where the_bfd_section
	is NULL.
	(ALL_OBJSECTIONS): Use it.
	* solib-dsbt.c (dsbt_relocate_main_executable): Update.
	* solib-frv.c (frv_relocate_main_executable): Update.
	* solib-target.c (solib_target_relocate_section_addresses):
	Use gdb_bfd_section_index.
	* symfile.c (build_section_addr_info_from_section_table):
	Use gdb_bfd_section_index.
	(build_section_addr_info_from_bfd, place_section): Likewise.
	* symtab.c (fixup_section): Update.
	* xcoffread.c (find_targ_sec): Use gdb_bfd_section_index.
@
text
@d342 1
a342 1
      int num_sections = bfd_count_sections (so->abfd);
@


1.27
log
@        * solib-svr4.c (svr4_keep_data_in_core): Remove unused lmo.
        (svr4_read_so_list): Remove unused lmo.
        * solib-target.c (solib_target_relocate_section_addresses): Remove
        unused flags.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00744.html
@
text
@d459 2
a460 1
  offset = so->lm_info->offsets->offsets[sec->the_bfd_section->index];
@


1.26
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a335 1
  int flags = bfd_get_section_flags (sec->bfd, sec->the_bfd_section);
@


1.25
log
@	* solib-target.c (solib_target_current_sos): Remove 'const'
	qualifier from type of library_document local variable to be
	able to free it and avoid a memory leak.
	Use cleanup chain to avoid leak even if exceptino is generated.
@
text
@d3 1
a3 1
   Copyright (C) 2007-2012 Free Software Foundation, Inc.
@


1.24
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d249 2
a250 1
  const char *library_document;
d262 3
d267 4
@


1.23
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d3 1
a3 1
   Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.23.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2007-2012 Free Software Foundation, Inc.
@


1.22
log
@2011-08-05  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* solib-target.c (segment_attributes): Make them static.
	(section_attributes, library_children, library_attributes): Likewise.
	(library_list_children, library_list_attributes): Likesise.
	(library_list_elements): Likewise.
@
text
@a30 2
DEF_VEC_I(CORE_ADDR);

@


1.21
log
@	* solib-target.c: Use DEF_VEC_I, not DEF_VEC_O.
	(library_list_start_segment): Update.
	(library_list_start_section): Update.
@
text
@d184 1
a184 1
const struct gdb_xml_attribute segment_attributes[] = {
d189 1
a189 1
const struct gdb_xml_attribute section_attributes[] = {
d194 1
a194 1
const struct gdb_xml_element library_children[] = {
d204 1
a204 1
const struct gdb_xml_attribute library_attributes[] = {
d209 1
a209 1
const struct gdb_xml_element library_list_children[] = {
d216 1
a216 1
const struct gdb_xml_attribute library_list_attributes[] = {
d221 1
a221 1
const struct gdb_xml_element library_list_elements[] = {
@


1.20
log
@	* xml-support.c (xml_find_attribute): New.
	(xinclude_start_include): Use it.
	* xml-support.h (xml_find_attribute): Declare.
	* memory-map.c (memory_map_start_memory)
	(memory_map_start_property): Use xml_find_attribute.
	* osdata.c (osdata_start_osdata, osdata_start_column): Use
	xml_find_attribute.
	* remote.c (start_thread): Use xml_find_attribute.
	* solib-target.c (library_list_start_segment)
	(library_list_start_section, library_list_start_library)
	(library_list_start_list): Use xml_find_attribute.
	* xml-tdesc.c (tdesc_start_target, tdesc_start_feature)
	(tdesc_start_union, tdesc_start_struct, tdesc_start_flags)
	(tdesc_start_field): Use xml_find_attribute.
@
text
@d31 1
a31 1
DEF_VEC_O(CORE_ADDR);
d96 1
a96 1
  VEC_safe_push (CORE_ADDR, last->segment_bases, &address);
d113 1
a113 1
  VEC_safe_push (CORE_ADDR, last->section_bases, &address);
@


1.19
log
@	Simplify XML parsing a bit.

	* xml-support.h (gdb_xml_parse_quick): Declare.
	* xml-support.c (gdb_xml_create_parser_and_cleanup_1): Renamed
	from gdb_xml_create_parser_and_cleanup, and added `old_chain'
	parameter.
	(gdb_xml_create_parser_and_cleanup): Reimplement on top of
	gdb_xml_create_parser_and_cleanup_1.
	(gdb_xml_parse_quick): New.
	* memory-map.c (parse_memory_map): Use gdb_xml_parse_quick.
	* osdata.c (osdata_parse): Ditto.
	* remote.c (remote_threads_info): Ditto.
	* solib-target.c (solib_target_parse_libraries): Ditto.
	* xml-syscall.c (syscall_parse_xml): Ditto.
	* xml-tdesc.c (tdesc_parse_xml): Ditto.
@
text
@d89 1
a89 1
  ULONGEST *address_p = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d106 1
a106 1
  ULONGEST *address_p = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d125 1
a125 1
  const char *name = VEC_index (gdb_xml_value_s, attributes, 0)->value;
d153 1
a153 1
  char *version = VEC_index (gdb_xml_value_s, attributes, 0)->value;
@


1.18
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@a229 1
  struct gdb_xml_parser *parser;
d231 2
a232 1
  struct cleanup *before_deleting_result, *back_to;
d234 7
a240 11
  back_to = make_cleanup (null_cleanup, NULL);
  parser = gdb_xml_create_parser_and_cleanup (_("target library list"),
					      library_list_elements, &result);
  gdb_xml_use_dtd (parser, "library-list.dtd");

  before_deleting_result = make_cleanup (solib_target_free_library_list,
					 &result);

  if (gdb_xml_parse (parser, library) == 0)
    /* Parsed successfully, don't need to delete the result.  */
    discard_cleanups (before_deleting_result);
d243 1
a243 1
  return result;
@


1.17
log
@run copyright.sh for 2011.
@
text
@d394 2
a395 1
		  so->lm_info->offsets->offsets[i] = section_bases[bases_index];
d482 2
a483 1
extern initialize_file_ftype _initialize_solib_target; /* -Wmissing-prototypes */
@


1.16
log
@	* Makefile.in (ALL_TARGET_OBS): Remove solib-target.o.
	(SFILES): Remove solib-null.c, add solib-target.c.
	(COMMON_OBS): Remove solib-null.o, add solib-target.o.
	(ALLDEPFILES): Remove solib-target.c.
	* solib-target.c (_initialize_solib_target): Set
	current_target_so_ops to solib_target_so_ops if not already set.
	* solib-null.c: Delete.
@
text
@d3 1
a3 1
   Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.15
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* scm-exp.c: White space.
	* scm-lang.c: White space.
	* scm-valprint.c: White space.
	* sentinel-frame.c: White space.
	* ser-base.c: White space.
	* ser-go32.c: White space.
	* serial.c: White space.
	* ser-mingw.c: White space.
	* ser-pipe.c: White space.
	* ser-tcp.c: White space.
	* ser-unix.c: White space.
	* solib.c: White space.
	* solib-darwin.c: White space.
	* solib-frv.c: White space.
	* solib-irix.c: White space.
	* solib-osf.c: White space.
	* solib-pa64.c: White space.
	* solib-som.c: White space.
	* solib-spu.c: White space.
	* solib-svr4.c: White space.
	* solib-target.c: White space.
	* source.c: White space.
	* stabsread.c: White space.
	* stack.c: White space.
	* std-regs.c: White space.
	* symfile.c: White space.
	* symmisc.c: White space.
	* symtab.c: White space.
@
text
@d500 5
@


1.14
log
@gdb/
	Add from_tty to solib_create_inferior_hook.
	* infcmd.c (post_create_inferior): Move solib_add after
	solib_create_inferior_hook.  Pass from_tty to
	solib_create_inferior_hook.  Call solib_add and SOLIB_ADD with
	0 from_tty and comment why.
	* infrun.c (follow_exec): Pass from_tty solib_create_inferior_hook as 0.
	* linux-nat.c (linux_child_follow_fork): Likewise.
	* nto-procfs.c (procfs_post_attach, procfs_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-frv.c (frv_solib_create_inferior_hook): Likewise.
	* solib-irix.c (irix_solib_create_inferior_hook): Likewise.
	* solib-null.c (null_solib_create_inferior_hook): Likewise.
	* solib-osf.c (osf_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-som.c (som_solib_create_inferior_hook): Likewise.
	* solib-spu.c (spu_solib_create_inferior_hook): New parameter from_tty.
	Pass it to svr4_so_ops.solib_create_inferior_hook.
	* solib-sunos.c (sunos_solib_create_inferior_hook): New parameter
	from_tty.
	* solib-svr4.c (enable_break): New parameter from_tty.  Pass it to
	solib_add.
	(svr4_solib_create_inferior_hook): New parameter from_tty.  Pass it to
	enable_break.
	* solib-target.c (solib_target_solib_create_inferior_hook): New
	parameter from_tty.
	* solib.c (solib_create_inferior_hook): New parameter from_tty.  Pass
	it to ops->solib_create_inferior_hook.
	(reload_shared_libraries): Pass from_tty to solib_create_inferior_hook.
	Move solib_add after solib_create_inferior_hook, call it now with
	from_tty as 0.  New comment there.
	* solib.h (solib_create_inferior_hook): New parameter from_tty.
	* solist.h (struct target_so_ops <solib_create_inferior_hook>):
	Likewise.
@
text
@d138 1
d368 1
d383 1
d405 1
@


1.13
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d309 1
a309 1
solib_target_solib_create_inferior_hook (void)
@


1.12
log
@	* solib.c (solib_bfd_open): Do not call ops->bfd_open.
	(solib_map_sections): Call ops->bfd_open instead of solib_bfd_open.
	* solib-frv.c (_initialize_frv_solib): Initialize bfd_open member.
	* solib-irix.c (_initialize_irix_solib): Likewise.
	* solib-null.c (_initialize_null_solib): Likewise.
	* solib-osf.c (_initialize_osf_solib): Likewise.
	* solib-pa64.c (_initialize_pa64_solib): Likewise.
	* solib-som.c (_initialize_som_solib): Likewise.
	* solib-sunos.c (_initialize_sunos_solib): Likewise.
	* solib-svr4.c (_initialize_svr4_solib): Likewise.
	* solib-target.c (_initialize_solib_target): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.11
log
@	* target.h (struct section_table): Rename to ...
	(struct target_section): ... this.
	* exec.c: Adjust all references.
	* exec.h: Adjust all references.
	* nto-tdep.c: Adjust all references.
	* nto-tdep.h: Adjust all references.
	* ppc-linux-tdep.c: Adjust all references.
	* rs6000-nat.c: Adjust all references.
	* s390-tdep.c: Adjust all references.
	* solib-darwin.c: Adjust all references.
	* solib-frv.c: Adjust all references.
	* solib-irix.c: Adjust all references.
	* solib-null.c: Adjust all references.
	* solib-osf.c: Adjust all references.
	* solib-pa64.c: Adjust all references.
	* solib-som.c: Adjust all references.
	* solib-sunos.c: Adjust all references.
	* solib-svr4.c: Adjust all references.
	* solib-target.c: Adjust all references.
	* solib.c: Adjust all references.
	* solist.h: Adjust all references.
	* symfile.c: Adjust all references.
	* symfile.h: Adjust all references.
	* target.c: Adjust all references.
@
text
@d495 1
@


1.10
log
@        Updated copyright notices for most files.
@
text
@d331 1
a331 1
					 struct section_table *sec)
@


1.9
log
@	* features/library-list.dtd: Allow "section" elements as children
	of "library".  Add "section" element and describe its attributes.

	* solib-target.c (struct lm_info): Add section_bases member.
	(library_list_start_segment): Error out if seen a section element.
	(library_list_start_section): New.
	(library_list_end_library): New.
	(solib_target_free_library_list): Free section_bases.
	(section_attributes): New.
	(library_children): Make "segment" optional.  Add "section" child.
	(library_list_children): Register library_list_end_library.
	(solib_target_relocate_section_addresses): Handle section bases.

	* NEWS: Mention new qXfer:libraries:read section offsets support.

doc/
	* gdb.texinfo (Library List Format): Update to mention the
	possibility to pass section addresses instead of segment
	addresses.
@
text
@d3 1
a3 1
   Copyright (C) 2007, 2008 Free Software Foundation, Inc.
@


1.8
log
@	Updated copyright notices for most files.
@
text
@d40 3
d47 4
d52 1
a52 1
     determined from SEGMENT_BASES.  */
d92 4
d99 17
d131 14
d173 1
d188 5
d194 2
a195 1
  { "segment", segment_attributes, NULL, GDB_XML_EF_REPEATABLE,
d197 3
d211 1
a211 1
    library_list_start_library, NULL },
a339 1
      struct symfile_segment_data *data;
d344 1
a344 5
      data = get_symfile_segment_data (so->abfd);
      if (data == NULL)
	warning (_("Could not relocate shared library \"%s\": no segments"),
		 so->so_name);
      else
a345 1
	  ULONGEST orig_delta;
d347 14
a360 8
	  int num_bases = VEC_length (CORE_ADDR, so->lm_info->segment_bases);
	  CORE_ADDR *segment_bases = VEC_address (CORE_ADDR,
						  so->lm_info->segment_bases);

	  if (!symfile_map_offsets_to_segments (so->abfd, data,
						so->lm_info->offsets,
						num_bases, segment_bases))
	    warning (_("Could not relocate shared library \"%s\": bad offsets"),
d362 1
a362 8

	  /* Find the range of addresses to report for this library in
	     "info sharedlibrary".  Report any consecutive segments
	     which were relocated as a single unit.  */
	  gdb_assert (num_bases > 0);
	  orig_delta = segment_bases[0] - data->segment_bases[0];

	  for (i = 1; i < data->num_segments; i++)
d364 33
a396 9
	      /* If we have run out of offsets, assume all remaining segments
		 have the same offset.  */
	      if (i >= num_bases)
		continue;

	      /* If this segment does not have the same offset, do not include
		 it in the library's range.  */
	      if (segment_bases[i] - data->segment_bases[i] != orig_delta)
		break;
d398 49
d448 2
a449 7
	  so->addr_low = segment_bases[0];
	  so->addr_high = (data->segment_bases[i - 1]
			   + data->segment_sizes[i - 1]
			   + orig_delta);
	  gdb_assert (so->addr_low <= so->addr_high);

	  free_symfile_segment_data (data);
@


1.7
log
@	* arm-wince-tdep.c: Include "solib.h" and "solib-target.h".
	(arm_wince_init_abi): Call set_solib_ops.
	* i386-cygwin-tdep.c: Include "solib.h" and "solib-target.h".
	(i386_cygwin_init_abi): Call set_solib_ops.
	* solib-target.c: Include "solib-target.h".
	(solib_target_so_ops): Make global.
	(_initialize_solib_target): Do not set current_target_so_ops.
	* solib-target.h: New file.
	* Makefile.in: Update dependencies.
@
text
@d3 1
a3 2
   Copyright (C) 2007
   Free Software Foundation, Inc.
@


1.6
log
@        * solib-target.c (solib_target_parse_libraries)
        [HAVEHAVE_LIBEXPAT not defined]: Fix thinko in return type.
@
text
@d28 1
d363 1
a363 1
static struct target_so_ops solib_target_so_ops;
a382 2

  current_target_so_ops = &solib_target_so_ops;
@


1.5
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d54 1
a54 1
static VEC(lm_info_p)
@


1.5.2.1
log
@        * solib-target.c (solib_target_parse_libraries)
        [HAVEHAVE_LIBEXPAT not defined]: Fix thinko in return type.
@
text
@d54 1
a54 1
static VEC(lm_info_p) *
@


1.4
log
@	* solib-target.c (solib_target_relocate_section_addresses): Add
	orig_delta to addr_high.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.3
log
@	* solib-target.c (library_list_start_segment): Cast address to
	CORE_ADDR.
@
text
@d335 2
a336 1
			   /* FIXME this must be needed! + orig_delta */);
@


1.2
log
@	* Makefile.in (XMLFILES): Add library-list.dtd.
	(ALLDEPFILES): Add solib-target.o.
	(solib-target.o): New rule.
	* remote.c (PACKET_qXfer_libraries): New constant.
	(remote_protocol_features): Add qXfer:libraries:read.
	(remote_wait): Recognize library stop replies.
	(remote_async_wait): Likewise.  Fix typo.
	(remote_xfer_partial): Handle TARGET_OBJECT_LIBRARIES.
	(init_remote_async_ops): Fix typo.
	(_initialize_remote): Register "set remote library-info-packet".
	* solib-som.c (som_current_sos): Set addr_low and addr_high.
	* solib-target.c: New file.
	* solib.c (solib_map_sections): Use addr_low and addr_high instead
	of textsection.
	(info_sharedlibrary_command): Likewise.
	(solib_add_library, solib_remove_library): New.
	* solist.h (struct so_list): Replace textsection with addr_low and
	addr_high.
	* target.h (enum target_object): Add TARGET_OBJECT_LIBRARIES.
	* NEWS: Describe new qXfer:libraries:read and shared library
	event support.
	* features/library-list.dtd: New.

	* gdb.texinfo (Remote Configuration): Document library-info-packet.
	Add other missing entries.  Adjust the table size to fit.
	(Stop Reply Packets): Use @@itemize instead of @@enumerate.  Document
	stop reasons including the new "library" event.
	(General Query Packets): Adjust table widths for qSupported.  Mention
	qXfer:libraries:read reply to qSupported and document the new packet.
	(Library List Format): New section.
@
text
@d85 1
d87 1
a87 1
  VEC_safe_push (CORE_ADDR, last->segment_bases, address_p);
@


1.1
log
@file solib-target.c was initially added on branch gdb-csl-symbian-20060226-branch.
@
text
@d1 384
@


1.1.2.1
log
@Add experimental support for SymbianOS-related protocol features.
@
text
@a0 270
/* Definitions for targets which report shared library events.

   Copyright (C) 2006
   Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "defs.h"
#include "solist.h"
#include "symtab.h"
#include "symfile.h"
#include "target.h"

#include "gdb_string.h"

struct lm_info
{
  CORE_ADDR textSeg, dataSeg;
};

static struct so_list *solib_start;
static int solibs_fetched;

static struct so_list *
solib_target_current_sos (void)
{
  struct so_list *sop;
  struct so_list *start = NULL;
  struct so_list *last = NULL;

  /* If we have not asked the target for the list of shared libraries
     yet, do it now.  */
  if (!solibs_fetched)
    {
      solibs_fetched = 1;
      target_get_shared_libraries ();
    }

  for (sop = solib_start; sop; sop = sop->next)
    {
      struct so_list *new;

      /* Duplicate the recorded solib.  */
      new = XZALLOC (struct so_list);
      strcpy (new->so_name, sop->so_name);
      strcpy (new->so_original_name, sop->so_original_name);
      new->lm_info = XMALLOC (struct lm_info);
      *new->lm_info = *sop->lm_info;

      /* Add it to the list.  */
      if (!start)
	last = start = new;
      else
	{
	  last->next = new;
	  last = new;
	}
    }

  return start;
}

static void
solib_target_special_symbol_handling (void)
{
  /* Nothing needed.  */
}

static void
solib_target_solib_create_inferior_hook (void)
{
  /* Nothing needed.  */
}

static void
solib_target_clear_solib (void)
{
  struct so_list *sop, *next;

  for (sop = solib_start; sop; sop = next)
    {
      next = sop->next;

      free_so (sop);
    }

  solib_start = NULL;
  solibs_fetched = 0;
}

static void
solib_target_free_so (struct so_list *so)
{
  xfree (so->lm_info);
}

static void
solib_target_relocate_section_addresses (struct so_list *so,
					 struct section_table *sec)
{
  int flags = bfd_get_section_flags (sec->bfd, sec->the_bfd_section);
  CORE_ADDR offset;

  offset = symfile_section_offset_from_segment (sec->bfd, sec->the_bfd_section,
						so->lm_info->textSeg,
						so->lm_info->dataSeg);

  sec->addr += offset;
  sec->endaddr += offset;

  /* If we haven't set these yet, do so now.  If this fails, we may waste some
     cycles uselessly retrying it, but that is rare and harmless.  */
  if (so->addr_low == 0 && so->addr_high == 0)
    {
      CORE_ADDR text_len, data_len;

      symfile_find_segment_lengths (sec->bfd, &text_len, &data_len);

      if (text_len)
	{
	  so->addr_low = so->lm_info->textSeg;
	  so->addr_high = so->addr_low + text_len;
	}
      else if (data_len)
	{
	  so->addr_low = so->lm_info->dataSeg;
	  so->addr_high = so->addr_low + data_len;
	}
    }
}

static int
solib_target_open_symbol_file_object (void *from_ttyp)
{
  /* We can't locate the main symbol file based on the target's
     knowledge; the user has to specify it.  */
  return 0;
}

static int
solib_target_in_dynsym_resolve_code (CORE_ADDR pc)
{
  /* Assume there isn't target dynsym resolution code.  DLL targets
     generally have only import stubs (which GDB treats as "PLT entries"),
     and no runtime binding code.  */
  return 0;
}

static void
solib_target_add_one_solib (char *soname, CORE_ADDR textSeg,
			    CORE_ADDR dataSeg)
{
  struct so_list *new_solib, *so;

  /* We should already have queried the target for shared libraries
     before this point.  If we haven't, we may have just connected;
     we'll be querying shortly.  */
  if (!solibs_fetched)
    return;

  /* Check for duplicates already on the list.  This can happen, for
     instance, if we are stopped at a DLL load event when we first
     connect to a remote target: the DLL will already be in the
     queried list, but also be reported by the initial wait.  */
  for (so = solib_start; so; so = so->next)
    if (strcmp (so->so_name, soname) == 0
	&& so->lm_info->textSeg == textSeg
	&& so->lm_info->dataSeg == dataSeg)
      return;

  new_solib = XZALLOC (struct so_list);
  strncpy (new_solib->so_name, soname, SO_NAME_MAX_PATH_SIZE - 1);
  new_solib->so_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';
  strncpy (new_solib->so_original_name, soname, SO_NAME_MAX_PATH_SIZE - 1);
  new_solib->so_original_name[SO_NAME_MAX_PATH_SIZE - 1] = '\0';

  new_solib->lm_info = XZALLOC (struct lm_info);
  new_solib->lm_info->textSeg = textSeg;
  new_solib->lm_info->dataSeg = dataSeg;

  if (solib_start == NULL)
    solib_start = new_solib;
  else
    {
      so = solib_start;
      while (so->next)
	so = so->next;
      so->next = new_solib;
    }

  /* We do not trigger symbol reading here; the target will do it,
     after all load events have been processed.  */
}

static void
solib_target_remove_one_solib (char *soname, CORE_ADDR textSeg,
			       CORE_ADDR dataSeg)
{
  struct so_list **slot, *removed;

  /* We should already have queried the target for shared libraries
     before this point.  If we haven't, we may have just connected;
     we'll be querying shortly.  */
  if (!solibs_fetched)
    return;

  slot = &solib_start;
  while (*slot)
    {
      if (textSeg != ~(CORE_ADDR) 0 && textSeg != (*slot)->lm_info->textSeg)
	continue;
      if (dataSeg != ~(CORE_ADDR) 0 && dataSeg != (*slot)->lm_info->dataSeg)
	continue;
      if (soname != NULL && strcmp (soname, (*slot)->so_name) != 0)
	continue;
      break;
    }

  if (*slot == NULL)
    return;

  removed = *slot;
  *slot = removed->next;

  free_so (removed);

  /* We do not trigger symbol unloading here; the target will do it,
     after all unload events have been processed.  */
}

static struct target_so_ops solib_target_so_ops;

extern initialize_file_ftype _initialize_solib_target; /* -Wmissing-prototypes */

void
_initialize_solib_target (void)
{
  solib_target_so_ops.relocate_section_addresses
    = solib_target_relocate_section_addresses;
  solib_target_so_ops.free_so = solib_target_free_so;
  solib_target_so_ops.clear_solib = solib_target_clear_solib;
  solib_target_so_ops.solib_create_inferior_hook
    = solib_target_solib_create_inferior_hook;
  solib_target_so_ops.special_symbol_handling
    = solib_target_special_symbol_handling;
  solib_target_so_ops.current_sos = solib_target_current_sos;
  solib_target_so_ops.open_symbol_file_object
    = solib_target_open_symbol_file_object;
  solib_target_so_ops.in_dynsym_resolve_code
    = solib_target_in_dynsym_resolve_code;
  solib_target_so_ops.add_one_solib = solib_target_add_one_solib;
  solib_target_so_ops.remove_one_solib = solib_target_remove_one_solib;

  current_target_so_ops = &solib_target_so_ops;
}
@


1.1.2.2
log
@	* gdb/solib-target.c (solib_target_remove_one_solib): Correct loop
	logic.
@
text
@d222 2
a223 1
  for (slot = &solib_start; *slot != NULL; slot = &(*slot)->next)
@


