head	1.125;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.118
	gdb_7_6-2013-04-26-release:1.118
	gdb_7_6-branch:1.118.0.2
	gdb_7_6-2013-03-12-branchpoint:1.118
	gdb_7_5_1-2012-11-29-release:1.114
	gdb_7_5-2012-08-17-release:1.114
	gdb_7_5-branch:1.114.0.2
	gdb_7_5-2012-07-18-branchpoint:1.114
	gdb_7_4_1-2012-04-26-release:1.105.2.2
	gdb_7_4-2012-01-24-release:1.105.2.2
	gdb_7_4-branch:1.105.0.2
	gdb_7_4-2011-12-13-branchpoint:1.105
	gdb_7_3_1-2011-09-04-release:1.102.2.1
	gdb_7_3-2011-07-26-release:1.102.2.1
	gdb_7_3-branch:1.102.0.2
	gdb_7_3-2011-04-01-branchpoint:1.102
	gdb_7_2-2010-09-02-release:1.95.2.1
	gdb_7_2-branch:1.95.0.2
	gdb_7_2-2010-07-07-branchpoint:1.95
	gdb_7_1-2010-03-18-release:1.92
	gdb_7_1-branch:1.92.0.2
	gdb_7_1-2010-02-18-branchpoint:1.92
	gdb_7_0_1-2009-12-22-release:1.91
	gdb_7_0-2009-10-06-release:1.91
	gdb_7_0-branch:1.91.0.2
	gdb_7_0-2009-09-16-branchpoint:1.91
	arc-sim-20090309:1.78
	msnyder-checkpoint-072509-branch:1.90.0.2
	msnyder-checkpoint-072509-branchpoint:1.90
	arc-insight_6_8-branch:1.78.0.6
	arc-insight_6_8-branchpoint:1.78
	insight_6_8-branch:1.78.0.4
	insight_6_8-branchpoint:1.78
	reverse-20081226-branch:1.84.0.4
	reverse-20081226-branchpoint:1.84
	multiprocess-20081120-branch:1.84.0.2
	multiprocess-20081120-branchpoint:1.84
	reverse-20080930-branch:1.83.0.2
	reverse-20080930-branchpoint:1.83
	reverse-20080717-branch:1.80.0.4
	reverse-20080717-branchpoint:1.80
	msnyder-reverse-20080609-branch:1.80.0.2
	msnyder-reverse-20080609-branchpoint:1.80
	drow-reverse-20070409-branch:1.62.0.2
	drow-reverse-20070409-branchpoint:1.62
	gdb_6_8-2008-03-27-release:1.78
	gdb_6_8-branch:1.78.0.2
	gdb_6_8-2008-02-26-branchpoint:1.78
	gdb_6_7_1-2007-10-29-release:1.70
	gdb_6_7-2007-10-10-release:1.70
	gdb_6_7-branch:1.70.0.2
	gdb_6_7-2007-09-07-branchpoint:1.70
	insight_6_6-20070208-release:1.61
	gdb_6_6-2006-12-18-release:1.61
	gdb_6_6-branch:1.61.0.6
	gdb_6_6-2006-11-15-branchpoint:1.61
	insight_6_5-20061003-release:1.61
	gdb-csl-symbian-6_4_50_20060226-12:1.58
	gdb-csl-sourcerygxx-3_4_4-25:1.55
	nickrob-async-20060828-mergepoint:1.61
	gdb-csl-symbian-6_4_50_20060226-11:1.58
	gdb-csl-sourcerygxx-4_1-17:1.58
	gdb-csl-20060226-branch-local-2:1.58
	gdb-csl-sourcerygxx-4_1-14:1.58
	gdb-csl-sourcerygxx-4_1-13:1.58
	gdb-csl-sourcerygxx-4_1-12:1.58
	gdb-csl-sourcerygxx-3_4_4-21:1.58
	gdb_6_5-20060621-release:1.61
	gdb-csl-sourcerygxx-4_1-9:1.58
	gdb-csl-sourcerygxx-4_1-8:1.58
	gdb-csl-sourcerygxx-4_1-7:1.58
	gdb-csl-arm-2006q1-6:1.58
	gdb-csl-sourcerygxx-4_1-6:1.58
	gdb-csl-symbian-6_4_50_20060226-10:1.58
	gdb-csl-symbian-6_4_50_20060226-9:1.58
	gdb-csl-symbian-6_4_50_20060226-8:1.58
	gdb-csl-coldfire-4_1-11:1.58
	gdb-csl-sourcerygxx-3_4_4-19:1.58
	gdb-csl-coldfire-4_1-10:1.58
	gdb_6_5-branch:1.61.0.4
	gdb_6_5-2006-05-14-branchpoint:1.61
	gdb-csl-sourcerygxx-4_1-5:1.58
	nickrob-async-20060513-branch:1.61.0.2
	nickrob-async-20060513-branchpoint:1.61
	gdb-csl-sourcerygxx-4_1-4:1.58
	msnyder-reverse-20060502-branch:1.60.0.6
	msnyder-reverse-20060502-branchpoint:1.60
	gdb-csl-morpho-4_1-4:1.58
	gdb-csl-sourcerygxx-3_4_4-17:1.58
	readline_5_1-import-branch:1.60.0.4
	readline_5_1-import-branchpoint:1.60
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.58
	gdb-csl-symbian-20060226-branch:1.58.0.4
	gdb-csl-symbian-20060226-branchpoint:1.58
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.58
	msnyder-reverse-20060331-branch:1.60.0.2
	msnyder-reverse-20060331-branchpoint:1.60
	gdb-csl-available-20060303-branch:1.59.0.2
	gdb-csl-available-20060303-branchpoint:1.59
	gdb-csl-20060226-branch:1.58.0.2
	gdb-csl-20060226-branchpoint:1.58
	gdb_6_4-20051202-release:1.55
	msnyder-fork-checkpoint-branch:1.55.0.8
	msnyder-fork-checkpoint-branchpoint:1.55
	gdb-csl-gxxpro-6_3-branch:1.55.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.55
	gdb_6_4-branch:1.55.0.4
	gdb_6_4-2005-11-01-branchpoint:1.55
	gdb-csl-arm-20051020-branch:1.55.0.2
	gdb-csl-arm-20051020-branchpoint:1.55
	msnyder-tracepoint-checkpoint-branch:1.54.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.54
	gdb-csl-arm-20050325-2005-q1b:1.54
	gdb-csl-arm-20050325-2005-q1a:1.54
	csl-arm-20050325-branch:1.54.0.2
	csl-arm-20050325-branchpoint:1.54
	gdb-post-i18n-errorwarning-20050211:1.53
	gdb-pre-i18n-errorwarning-20050211:1.53
	gdb_6_3-20041109-release:1.52
	gdb_6_3-branch:1.52.0.2
	gdb_6_3-20041019-branchpoint:1.52
	drow_intercu-merge-20040921:1.52
	drow_intercu-merge-20040915:1.52
	jimb-gdb_6_2-e500-branch:1.45.2.2.2.2.0.2
	jimb-gdb_6_2-e500-branchpoint:1.45.2.2
	gdb_6_2-20040730-release:1.45.2.2
	gdb_6_2-branch:1.45.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.45
	gdb_6_1_1-20040616-release:1.27
	gdb_6_1-2004-04-05-release:1.27
	drow_intercu-merge-20040402:1.29
	drow_intercu-merge-20040327:1.29
	ezannoni_pie-20040323-branch:1.29.0.2
	ezannoni_pie-20040323-branchpoint:1.29
	cagney_tramp-20040321-mergepoint:1.29
	cagney_tramp-20040309-branch:1.28.0.2
	cagney_tramp-20040309-branchpoint:1.28
	gdb_6_1-branch:1.27.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.27
	drow_intercu-20040221-branch:1.27.0.6
	drow_intercu-20040221-branchpoint:1.27
	cagney_bfdfile-20040213-branch:1.27.0.4
	cagney_bfdfile-20040213-branchpoint:1.27
	drow-cplus-merge-20040208:1.27
	carlton_dictionary-20040126-merge:1.27
	cagney_bigcore-20040122-branch:1.27.0.2
	cagney_bigcore-20040122-branchpoint:1.27
	drow-cplus-merge-20040113:1.27
	drow-cplus-merge-20031224:1.27
	drow-cplus-merge-20031220:1.27
	carlton_dictionary-20031215-merge:1.27
	drow-cplus-merge-20031214:1.27
	carlton-dictionary-20031111-merge:1.26
	gdb_6_0-2003-10-04-release:1.24
	kettenis_sparc-20030918-branch:1.25.0.4
	kettenis_sparc-20030918-branchpoint:1.25
	carlton_dictionary-20030917-merge:1.25
	ezannoni_pie-20030916-branchpoint:1.25
	ezannoni_pie-20030916-branch:1.25.0.2
	cagney_x86i386-20030821-branch:1.24.0.6
	cagney_x86i386-20030821-branchpoint:1.24
	carlton_dictionary-20030805-merge:1.24
	carlton_dictionary-20030627-merge:1.24
	gdb_6_0-branch:1.24.0.4
	gdb_6_0-2003-06-23-branchpoint:1.24
	jimb-ppc64-linux-20030613-branch:1.24.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.24
	cagney_convert-20030606-branch:1.22.0.2
	cagney_convert-20030606-branchpoint:1.22
	cagney_writestrings-20030508-branch:1.21.0.8
	cagney_writestrings-20030508-branchpoint:1.21
	jimb-ppc64-linux-20030528-branch:1.21.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.21
	carlton_dictionary-20030523-merge:1.21
	cagney_fileio-20030521-branch:1.21.0.4
	cagney_fileio-20030521-branchpoint:1.21
	kettenis_i386newframe-20030517-mergepoint:1.21
	jimb-ppc64-linux-20030509-branch:1.21.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.21
	kettenis_i386newframe-20030504-mergepoint:1.20
	carlton_dictionary-20030430-merge:1.20
	kettenis_i386newframe-20030419-branch:1.20.0.16
	kettenis_i386newframe-20030419-branchpoint:1.20
	carlton_dictionary-20030416-merge:1.20
	cagney_frameaddr-20030409-mergepoint:1.20
	kettenis_i386newframe-20030406-branch:1.20.0.14
	kettenis_i386newframe-20030406-branchpoint:1.20
	cagney_frameaddr-20030403-branchpoint:1.20
	cagney_frameaddr-20030403-branch:1.20.0.12
	cagney_framebase-20030330-mergepoint:1.20
	cagney_framebase-20030326-branch:1.20.0.10
	cagney_framebase-20030326-branchpoint:1.20
	cagney_lazyid-20030317-branch:1.20.0.8
	cagney_lazyid-20030317-branchpoint:1.20
	kettenis-i386newframe-20030316-mergepoint:1.20
	offbyone-20030313-branch:1.20.0.6
	offbyone-20030313-branchpoint:1.20
	kettenis-i386newframe-20030308-branch:1.20.0.4
	kettenis-i386newframe-20030308-branchpoint:1.20
	carlton_dictionary-20030305-merge:1.20
	cagney_offbyone-20030303-branch:1.20.0.2
	cagney_offbyone-20030303-branchpoint:1.20
	carlton_dictionary-20030207-merge:1.20
	interps-20030203-mergepoint:1.19
	interps-20030202-branch:1.19.0.4
	interps-20030202-branchpoint:1.19
	cagney-unwind-20030108-branch:1.19.0.2
	cagney-unwind-20030108-branchpoint:1.19
	carlton_dictionary-20021223-merge:1.19
	gdb_5_3-2002-12-12-release:1.18
	carlton_dictionary-20021115-merge:1.18
	kseitz_interps-20021105-merge:1.18
	kseitz_interps-20021103-merge:1.18
	drow-cplus-merge-20021020:1.18
	drow-cplus-merge-20021025:1.18
	carlton_dictionary-20021025-merge:1.18
	carlton_dictionary-20021011-merge:1.18
	drow-cplus-branch:1.18.0.10
	drow-cplus-branchpoint:1.18
	kseitz_interps-20020930-merge:1.18
	carlton_dictionary-20020927-merge:1.18
	carlton_dictionary-branch:1.18.0.8
	carlton_dictionary-20020920-branchpoint:1.18
	gdb_5_3-branch:1.18.0.6
	gdb_5_3-2002-09-04-branchpoint:1.18
	kseitz_interps-20020829-merge:1.18
	cagney_sysregs-20020825-branch:1.18.0.4
	cagney_sysregs-20020825-branchpoint:1.18
	readline_4_3-import-branch:1.18.0.2
	readline_4_3-import-branchpoint:1.18
	gdb_5_2_1-2002-07-23-release:1.16
	kseitz_interps-20020528-branch:1.17.0.6
	kseitz_interps-20020528-branchpoint:1.17
	cagney_regbuf-20020515-branch:1.17.0.4
	cagney_regbuf-20020515-branchpoint:1.17
	jimb-macro-020506-branch:1.17.0.2
	jimb-macro-020506-branchpoint:1.17
	gdb_5_2-2002-04-29-release:1.16
	gdb_5_2-branch:1.16.0.2
	gdb_5_2-2002-03-03-branchpoint:1.16
	gdb_5_1_1-2002-01-24-release:1.9
	gdb_5_1_0_1-2002-01-03-release:1.9
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branchpoint:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.9.0.8
	gdb_5_1-2001-11-21-release:1.9
	gdb_s390-2001-09-26-branch:1.9.0.6
	gdb_s390-2001-09-26-branchpoint:1.9
	gdb_5_1-2001-07-29-branch:1.9.0.4
	gdb_5_1-2001-07-29-branchpoint:1.9
	dberlin-typesystem-branch:1.9.0.2
	dberlin-typesystem-branchpoint:1.9
	gdb-post-ptid_t-2001-05-03:1.8
	gdb-pre-ptid_t-2001-05-03:1.8
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.4
	gdb-pre-protoization-2000-07-29:1.3
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.3
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2;
locks; strict;
comment	@ * @;


1.125
date	2013.09.30.11.50.11;	author luisgpm;	state Exp;
branches;
next	1.124;

1.124
date	2013.08.02.16.41.08;	author tromey;	state Exp;
branches;
next	1.123;

1.123
date	2013.07.22.13.17.51;	author uweigand;	state Exp;
branches;
next	1.122;

1.122
date	2013.07.15.16.01.26;	author uweigand;	state Exp;
branches;
next	1.121;

1.121
date	2013.07.01.11.28.30;	author palves;	state Exp;
branches;
next	1.120;

1.120
date	2013.05.17.23.05.00;	author emachado;	state Exp;
branches;
next	1.119;

1.119
date	2013.05.07.07.43.33;	author luisgpm;	state Exp;
branches;
next	1.118;

1.118
date	2013.03.01.15.38.25;	author palves;	state Exp;
branches;
next	1.117;

1.117
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.116;

1.116
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.115;

1.115
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.114;

1.114
date	2012.07.06.16.49.43;	author jkratoch;	state Exp;
branches;
next	1.113;

1.113
date	2012.05.31.22.07.31;	author emachado;	state Exp;
branches;
next	1.112;

1.112
date	2012.05.30.13.37.17;	author emachado;	state Exp;
branches;
next	1.111;

1.111
date	2012.03.21.13.43.54;	author tschwinge;	state Exp;
branches;
next	1.110;

1.110
date	2012.03.02.13.38.39;	author uweigand;	state Exp;
branches;
next	1.109;

1.109
date	2012.02.12.19.25.29;	author jkratoch;	state Exp;
branches;
next	1.108;

1.108
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.107;

1.107
date	2011.12.21.15.27.29;	author schwab;	state Exp;
branches;
next	1.106;

1.106
date	2011.12.14.17.20.31;	author palves;	state Exp;
branches;
next	1.105;

1.105
date	2011.10.07.17.15.15;	author palves;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2011.05.06.18.46.31;	author bauermann;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.06.03.24.24;	author bauermann;	state Exp;
branches;
next	1.102;

1.102
date	2011.03.31.14.32.48;	author bauermann;	state Exp;
branches
	1.102.2.1;
next	1.101;

1.101
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.12.20.09.53;	author bauermann;	state Exp;
branches;
next	1.99;

1.99
date	2011.01.11.19.23.02;	author bauermann;	state Exp;
branches;
next	1.98;

1.98
date	2011.01.10.20.38.49;	author msnyder;	state Exp;
branches;
next	1.97;

1.97
date	2011.01.01.15.33.12;	author brobecke;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.26.17.06.26;	author bauermann;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.07.16.15.16;	author bauermann;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2010.04.23.12.36.05;	author brobecke;	state Exp;
branches;
next	1.93;

1.93
date	2010.04.22.22.26.36;	author bauermann;	state Exp;
branches;
next	1.92;

1.92
date	2010.01.01.07.31.38;	author brobecke;	state Exp;
branches;
next	1.91;

1.91
date	2009.07.31.15.23.20;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2009.07.02.17.25.57;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2009.05.09.03.19.17;	author sergiodj;	state Exp;
branches;
next	1.88;

1.88
date	2009.04.03.16.07.04;	author uweigand;	state Exp;
branches;
next	1.87;

1.87
date	2009.03.25.21.15.04;	author bauermann;	state Exp;
branches;
next	1.86;

1.86
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.85;

1.85
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.84;

1.84
date	2008.11.18.21.39.47;	author bauermann;	state Exp;
branches;
next	1.83;

1.83
date	2008.08.15.15.18.33;	author luisgpm;	state Exp;
branches;
next	1.82;

1.82
date	2008.08.12.18.20.14;	author uweigand;	state Exp;
branches;
next	1.81;

1.81
date	2008.08.08.15.30.27;	author luisgpm;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.03.17.16.43;	author uweigand;	state Exp;
branches;
next	1.79;

1.79
date	2008.05.02.11.07.25;	author schwab;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.16.04.48.55;	author deuling;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.11.14.43.14;	author deuling;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.75;

1.75
date	2007.11.16.04.53.46;	author deuling;	state Exp;
branches;
next	1.74;

1.74
date	2007.11.09.17.15.17;	author luisgpm;	state Exp;
branches;
next	1.73;

1.73
date	2007.10.15.19.49.53;	author drow;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.02.16.39.29;	author uweigand;	state Exp;
branches;
next	1.71;

1.71
date	2007.10.01.00.22.50;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.30.13.13.59;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.66;

1.66
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.65;

1.65
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.64;

1.64
date	2007.05.06.14.32.30;	author uweigand;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.25.22.10.08;	author uweigand;	state Exp;
branches;
next	1.62;

1.62
date	2007.01.09.17.58.55;	author drow;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.05.20.45.03;	author pgilliam;	state Exp;
branches;
next	1.60;

1.60
date	2006.03.24.23.08.16;	author drow;	state Exp;
branches;
next	1.59;

1.59
date	2006.02.26.23.42.59;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2006.02.08.07.00.06;	author woodzltc;	state Exp;
branches;
next	1.57;

1.57
date	2006.02.08.05.41.06;	author woodzltc;	state Exp;
branches;
next	1.56;

1.56
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.10.18.11.04;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2005.02.11.18.13.51;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.08.21.00.16;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.04.17.45.30;	author jimb;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.04.17.17.55;	author jimb;	state Exp;
branches;
next	1.50;

1.50
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.24.01.00.19;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.17.14.24.07;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.17.14.15.30;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.07.23.37.20;	author jimb;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2004.06.05.03.25.22;	author jimb;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.04.23.07.28;	author jimb;	state Exp;
branches;
next	1.42;

1.42
date	2004.06.02.18.24.35;	author jimb;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.02.18.17.05;	author jimb;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.21.23.30.47;	author jimb;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.13.19.36.05;	author jimb;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.13.19.27.07;	author jimb;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.11.04.55.31;	author jimb;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.10.18.58.44;	author jimb;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.10.17.07.02;	author jimb;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.05.01.48.37;	author jimb;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.05.01.46.55;	author jimb;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.04.17.58.31;	author jimb;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.04.17.43.52;	author jimb;	state Exp;
branches;
next	1.30;

1.30
date	2004.04.22.08.37.06;	author jimb;	state Exp;
branches;
next	1.29;

1.29
date	2004.03.15.21.35.25;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2004.03.08.01.45.02;	author cagney;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2003.12.03.19.37.03;	author cagney;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.13.00.03.03;	author jimb;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.12.23.28.36;	author jimb;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.28.22.39.02;	author jimb;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches
	1.21.2.1
	1.21.6.1;
next	1.20;

1.20
date	2003.02.07.04.49.34;	author cagney;	state Exp;
branches
	1.20.16.1;
next	1.19;

1.19
date	2002.12.06.16.59.05;	author ezannoni;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.30.19.03.49;	author drow;	state Exp;
branches
	1.18.8.1
	1.18.10.1;
next	1.17;

1.17
date	2002.04.11.19.08.56;	author kevinb;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	2002.02.21.22.04.46;	author ezannoni;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.18.15.08.40;	author ezannoni;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.24.02.58.24;	author ezannoni;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.20.23.31.26;	author ezannoni;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.09.21.39.53;	author ezannoni;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.30.02.14.08;	author ezannoni;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.20.16.35.24;	author ezannoni;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.05.23.22.04;	author drow;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.03.06.08.21.11;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.30.05.41.39;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.18.01.08.23;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.26.23.22.40;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.22.18.47.41;	author kevinb;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.22.01.19.11;	author kevinb;	state Exp;
branches;
next	;

1.105.2.1
date	2011.12.22.11.34.33;	author schwab;	state Exp;
branches;
next	1.105.2.2;

1.105.2.2
date	2012.01.06.04.43.22;	author brobecke;	state Exp;
branches;
next	;

1.102.2.1
date	2011.04.18.21.29.18;	author bauermann;	state Exp;
branches;
next	;

1.95.2.1
date	2010.07.27.16.13.48;	author bauermann;	state Exp;
branches;
next	;

1.45.2.1
date	2004.07.17.14.16.14;	author cagney;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2004.07.17.14.24.17;	author cagney;	state Exp;
branches
	1.45.2.2.2.1;
next	;

1.45.2.2.2.1
date	2004.09.01.17.39.04;	author jimb;	state Exp;
branches;
next	1.45.2.2.2.2;

1.45.2.2.2.2
date	2004.09.01.18.09.58;	author jimb;	state Exp;
branches;
next	;

1.28.2.1
date	2004.03.21.23.57.34;	author cagney;	state Exp;
branches;
next	;

1.27.6.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.27.6.2;

1.27.6.2
date	2004.09.16.17.01.16;	author drow;	state Exp;
branches;
next	;

1.21.2.1
date	2003.05.13.00.08.58;	author jimb;	state Exp;
branches;
next	;

1.21.6.1
date	2003.05.28.16.51.21;	author jimb;	state Exp;
branches;
next	1.21.6.2;

1.21.6.2
date	2003.05.28.20.14.13;	author jimb;	state Exp;
branches;
next	1.21.6.3;

1.21.6.3
date	2003.05.28.20.20.21;	author jimb;	state Exp;
branches;
next	1.21.6.4;

1.21.6.4
date	2003.06.06.06.59.02;	author jimb;	state Exp;
branches;
next	1.21.6.5;

1.21.6.5
date	2003.06.10.16.18.12;	author jimb;	state Exp;
branches;
next	1.21.6.6;

1.21.6.6
date	2003.06.10.16.24.48;	author jimb;	state Exp;
branches;
next	;

1.20.16.1
date	2003.05.18.09.44.18;	author kettenis;	state Exp;
branches;
next	;

1.18.8.1
date	2002.12.23.19.38.38;	author carlton;	state Exp;
branches;
next	1.18.8.2;

1.18.8.2
date	2003.02.07.19.17.51;	author carlton;	state Exp;
branches;
next	1.18.8.3;

1.18.8.3
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.18.8.4;

1.18.8.4
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.18.8.5;

1.18.8.5
date	2003.09.17.21.28.27;	author carlton;	state Exp;
branches;
next	1.18.8.6;

1.18.8.6
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	1.18.8.7;

1.18.8.7
date	2003.12.16.00.00.45;	author carlton;	state Exp;
branches;
next	;

1.18.10.1
date	2003.12.14.20.27.27;	author drow;	state Exp;
branches;
next	;

1.17.6.1
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	;

1.9.2.1
date	2001.07.06.19.17.02;	author dberlin;	state Exp;
branches;
next	;


desc
@@


1.125
log
@	* aarch64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* aix-thread.c (BUILD_THREAD, BUILD_LWP): Remove.
	Replace BUILD_THREAD with ptid_build.
	Replace BUILD_LWP with ptid_build.
	Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* alphabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* amd64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* amd64bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* arm-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	Replace GET_LWP with ptid_get_lwp.
	* armnbsd-nat.c: Replace PIDGET with ptid_get_pid.
	* auxv.c: Likewise.
	* breakpoint.c: Likewise.
	* common/ptid.c (ptid_is_pid): Condense check for
	null_ptid and minus_one_ptid.
	(ptid_lwp_p): New function.
	(ptid_tid_p): New function.
	* common/ptid.h: Update comments for accessors.
	(ptid_lwp_p): New prototype.
	(ptid_tid_p): New prototype.
	* defs.h (PIDGET, TIDGET, MERGEPID): Do not define.
	* gcore.c: Replace PIDGET with ptid_get_pid.
	* gdbthread.h: Likewise.
	* gnu-nat.c: Likewise.
	* hppa-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* hppabsd-nat.c: Replace PIDGET with ptid_get_pid.
	* hppanbsd-nat.c: Likewise.
	* i386-linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace TIDGET with ptid_get_lwp.
	* i386bsd-nat.c: Replace PIDGET with ptid_get_pid.
	* ia64-linux-nat.c: Replace PIDGET with ptid_get_pid.
	* infcmd.c: Likewise.
	* inferior.h: Likewise.
	* inflow.c: Likewise.
	* infrun.c: Likewise.
	* linux-fork.c: Likewise.
	* linux-nat.c: Replace PIDGET with ptid_get_pid.
	Replace GET_PID with ptid_get_pid.
	Replace is_lwp with ptid_lwp_p.
	Replace GET_LWP with ptid_get_lwp.
	Replace BUILD_LWP with ptid_build.
@
text
@/* PPC GNU/Linux native support.

   Copyright (C) 1988-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_string.h"
#include "observer.h"
#include "frame.h"
#include "inferior.h"
#include "gdbthread.h"
#include "gdbcore.h"
#include "regcache.h"
#include "gdb_assert.h"
#include "target.h"
#include "linux-nat.h"

#include <stdint.h>
#include <sys/types.h>
#include <signal.h>
#include <sys/user.h>
#include <sys/ioctl.h>
#include "gdb_wait.h"
#include <fcntl.h>
#include <sys/procfs.h>
#include <sys/ptrace.h>

/* Prototypes for supply_gregset etc.  */
#include "gregset.h"
#include "ppc-tdep.h"
#include "ppc-linux-tdep.h"

/* Required when using the AUXV.  */
#include "elf/common.h"
#include "auxv.h"

/* This sometimes isn't defined.  */
#ifndef PT_ORIG_R3
#define PT_ORIG_R3 34
#endif
#ifndef PT_TRAP
#define PT_TRAP 40
#endif

/* The PPC_FEATURE_* defines should be provided by <asm/cputable.h>.
   If they aren't, we can provide them ourselves (their values are fixed
   because they are part of the kernel ABI).  They are used in the AT_HWCAP
   entry of the AUXV.  */
#ifndef PPC_FEATURE_CELL
#define PPC_FEATURE_CELL 0x00010000
#endif
#ifndef PPC_FEATURE_BOOKE
#define PPC_FEATURE_BOOKE 0x00008000
#endif
#ifndef PPC_FEATURE_HAS_DFP
#define PPC_FEATURE_HAS_DFP	0x00000400  /* Decimal Floating Point.  */
#endif

/* Glibc's headers don't define PTRACE_GETVRREGS so we cannot use a
   configure time check.  Some older glibc's (for instance 2.2.1)
   don't have a specific powerpc version of ptrace.h, and fall back on
   a generic one.  In such cases, sys/ptrace.h defines
   PTRACE_GETFPXREGS and PTRACE_SETFPXREGS to the same numbers that
   ppc kernel's asm/ptrace.h defines PTRACE_GETVRREGS and
   PTRACE_SETVRREGS to be.  This also makes a configury check pretty
   much useless.  */

/* These definitions should really come from the glibc header files,
   but Glibc doesn't know about the vrregs yet.  */
#ifndef PTRACE_GETVRREGS
#define PTRACE_GETVRREGS 18
#define PTRACE_SETVRREGS 19
#endif

/* PTRACE requests for POWER7 VSX registers.  */
#ifndef PTRACE_GETVSXREGS
#define PTRACE_GETVSXREGS 27
#define PTRACE_SETVSXREGS 28
#endif

/* Similarly for the ptrace requests for getting / setting the SPE
   registers (ev0 -- ev31, acc, and spefscr).  See the description of
   gdb_evrregset_t for details.  */
#ifndef PTRACE_GETEVRREGS
#define PTRACE_GETEVRREGS 20
#define PTRACE_SETEVRREGS 21
#endif

/* Similarly for the hardware watchpoint support.  These requests are used
   when the PowerPC HWDEBUG ptrace interface is not available.  */
#ifndef PTRACE_GET_DEBUGREG
#define PTRACE_GET_DEBUGREG    25
#endif
#ifndef PTRACE_SET_DEBUGREG
#define PTRACE_SET_DEBUGREG    26
#endif
#ifndef PTRACE_GETSIGINFO
#define PTRACE_GETSIGINFO    0x4202
#endif

/* These requests are used when the PowerPC HWDEBUG ptrace interface is
   available.  It exposes the debug facilities of PowerPC processors, as well
   as additional features of BookE processors, such as ranged breakpoints and
   watchpoints and hardware-accelerated condition evaluation.  */
#ifndef PPC_PTRACE_GETHWDBGINFO

/* Not having PPC_PTRACE_GETHWDBGINFO defined means that the PowerPC HWDEBUG 
   ptrace interface is not present in ptrace.h, so we'll have to pretty much
   include it all here so that the code at least compiles on older systems.  */
#define PPC_PTRACE_GETHWDBGINFO 0x89
#define PPC_PTRACE_SETHWDEBUG   0x88
#define PPC_PTRACE_DELHWDEBUG   0x87

struct ppc_debug_info
{
        uint32_t version;               /* Only version 1 exists to date.  */
        uint32_t num_instruction_bps;
        uint32_t num_data_bps;
        uint32_t num_condition_regs;
        uint32_t data_bp_alignment;
        uint32_t sizeof_condition;      /* size of the DVC register.  */
        uint64_t features;
};

/* Features will have bits indicating whether there is support for:  */
#define PPC_DEBUG_FEATURE_INSN_BP_RANGE         0x1
#define PPC_DEBUG_FEATURE_INSN_BP_MASK          0x2
#define PPC_DEBUG_FEATURE_DATA_BP_RANGE         0x4
#define PPC_DEBUG_FEATURE_DATA_BP_MASK          0x8

struct ppc_hw_breakpoint
{
        uint32_t version;               /* currently, version must be 1 */
        uint32_t trigger_type;          /* only some combinations allowed */
        uint32_t addr_mode;             /* address match mode */
        uint32_t condition_mode;        /* break/watchpoint condition flags */
        uint64_t addr;                  /* break/watchpoint address */
        uint64_t addr2;                 /* range end or mask */
        uint64_t condition_value;       /* contents of the DVC register */
};

/* Trigger type.  */
#define PPC_BREAKPOINT_TRIGGER_EXECUTE  0x1
#define PPC_BREAKPOINT_TRIGGER_READ     0x2
#define PPC_BREAKPOINT_TRIGGER_WRITE    0x4
#define PPC_BREAKPOINT_TRIGGER_RW       0x6

/* Address mode.  */
#define PPC_BREAKPOINT_MODE_EXACT               0x0
#define PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE     0x1
#define PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE     0x2
#define PPC_BREAKPOINT_MODE_MASK                0x3

/* Condition mode.  */
#define PPC_BREAKPOINT_CONDITION_NONE   0x0
#define PPC_BREAKPOINT_CONDITION_AND    0x1
#define PPC_BREAKPOINT_CONDITION_EXACT  0x1
#define PPC_BREAKPOINT_CONDITION_OR     0x2
#define PPC_BREAKPOINT_CONDITION_AND_OR 0x3
#define PPC_BREAKPOINT_CONDITION_BE_ALL 0x00ff0000
#define PPC_BREAKPOINT_CONDITION_BE_SHIFT       16
#define PPC_BREAKPOINT_CONDITION_BE(n)  \
        (1<<((n)+PPC_BREAKPOINT_CONDITION_BE_SHIFT))
#endif /* PPC_PTRACE_GETHWDBGINFO */

/* Feature defined on Linux kernel v3.9: DAWR interface, that enables wider
   watchpoint (up to 512 bytes).  */
#ifndef PPC_DEBUG_FEATURE_DATA_BP_DAWR
#define PPC_DEBUG_FEATURE_DATA_BP_DAWR	0x10
#endif /* PPC_DEBUG_FEATURE_DATA_BP_DAWR */

/* Similarly for the general-purpose (gp0 -- gp31)
   and floating-point registers (fp0 -- fp31).  */
#ifndef PTRACE_GETREGS
#define PTRACE_GETREGS 12
#endif
#ifndef PTRACE_SETREGS
#define PTRACE_SETREGS 13
#endif
#ifndef PTRACE_GETFPREGS
#define PTRACE_GETFPREGS 14
#endif
#ifndef PTRACE_SETFPREGS
#define PTRACE_SETFPREGS 15
#endif

/* This oddity is because the Linux kernel defines elf_vrregset_t as
   an array of 33 16 bytes long elements.  I.e. it leaves out vrsave.
   However the PTRACE_GETVRREGS and PTRACE_SETVRREGS requests return
   the vrsave as an extra 4 bytes at the end.  I opted for creating a
   flat array of chars, so that it is easier to manipulate for gdb.

   There are 32 vector registers 16 bytes longs, plus a VSCR register
   which is only 4 bytes long, but is fetched as a 16 bytes
   quantity.  Up to here we have the elf_vrregset_t structure.
   Appended to this there is space for the VRSAVE register: 4 bytes.
   Even though this vrsave register is not included in the regset
   typedef, it is handled by the ptrace requests.

   Note that GNU/Linux doesn't support little endian PPC hardware,
   therefore the offset at which the real value of the VSCR register
   is located will be always 12 bytes.

   The layout is like this (where x is the actual value of the vscr reg): */

/* *INDENT-OFF* */
/*
   |.|.|.|.|.....|.|.|.|.||.|.|.|x||.|
   <------->     <-------><-------><->
     VR0           VR31     VSCR    VRSAVE
*/
/* *INDENT-ON* */

#define SIZEOF_VRREGS 33*16+4

typedef char gdb_vrregset_t[SIZEOF_VRREGS];

/* This is the layout of the POWER7 VSX registers and the way they overlap
   with the existing FPR and VMX registers.

                    VSR doubleword 0               VSR doubleword 1
           ----------------------------------------------------------------
   VSR[0]  |             FPR[0]            |                              |
           ----------------------------------------------------------------
   VSR[1]  |             FPR[1]            |                              |
           ----------------------------------------------------------------
           |              ...              |                              |
           |              ...              |                              |
           ----------------------------------------------------------------
   VSR[30] |             FPR[30]           |                              |
           ----------------------------------------------------------------
   VSR[31] |             FPR[31]           |                              |
           ----------------------------------------------------------------
   VSR[32] |                             VR[0]                            |
           ----------------------------------------------------------------
   VSR[33] |                             VR[1]                            |
           ----------------------------------------------------------------
           |                              ...                             |
           |                              ...                             |
           ----------------------------------------------------------------
   VSR[62] |                             VR[30]                           |
           ----------------------------------------------------------------
   VSR[63] |                             VR[31]                           |
          ----------------------------------------------------------------

   VSX has 64 128bit registers.  The first 32 registers overlap with
   the FP registers (doubleword 0) and hence extend them with additional
   64 bits (doubleword 1).  The other 32 regs overlap with the VMX
   registers.  */
#define SIZEOF_VSXREGS 32*8

typedef char gdb_vsxregset_t[SIZEOF_VSXREGS];

/* On PPC processors that support the Signal Processing Extension
   (SPE) APU, the general-purpose registers are 64 bits long.
   However, the ordinary Linux kernel PTRACE_PEEKUSER / PTRACE_POKEUSER
   ptrace calls only access the lower half of each register, to allow
   them to behave the same way they do on non-SPE systems.  There's a
   separate pair of calls, PTRACE_GETEVRREGS / PTRACE_SETEVRREGS, that
   read and write the top halves of all the general-purpose registers
   at once, along with some SPE-specific registers.

   GDB itself continues to claim the general-purpose registers are 32
   bits long.  It has unnamed raw registers that hold the upper halves
   of the gprs, and the full 64-bit SIMD views of the registers,
   'ev0' -- 'ev31', are pseudo-registers that splice the top and
   bottom halves together.

   This is the structure filled in by PTRACE_GETEVRREGS and written to
   the inferior's registers by PTRACE_SETEVRREGS.  */
struct gdb_evrregset_t
{
  unsigned long evr[32];
  unsigned long long acc;
  unsigned long spefscr;
};

/* Non-zero if our kernel may support the PTRACE_GETVSXREGS and
   PTRACE_SETVSXREGS requests, for reading and writing the VSX
   POWER7 registers 0 through 31.  Zero if we've tried one of them and
   gotten an error.  Note that VSX registers 32 through 63 overlap
   with VR registers 0 through 31.  */
int have_ptrace_getsetvsxregs = 1;

/* Non-zero if our kernel may support the PTRACE_GETVRREGS and
   PTRACE_SETVRREGS requests, for reading and writing the Altivec
   registers.  Zero if we've tried one of them and gotten an
   error.  */
int have_ptrace_getvrregs = 1;

/* Non-zero if our kernel may support the PTRACE_GETEVRREGS and
   PTRACE_SETEVRREGS requests, for reading and writing the SPE
   registers.  Zero if we've tried one of them and gotten an
   error.  */
int have_ptrace_getsetevrregs = 1;

/* Non-zero if our kernel may support the PTRACE_GETREGS and
   PTRACE_SETREGS requests, for reading and writing the
   general-purpose registers.  Zero if we've tried one of
   them and gotten an error.  */
int have_ptrace_getsetregs = 1;

/* Non-zero if our kernel may support the PTRACE_GETFPREGS and
   PTRACE_SETFPREGS requests, for reading and writing the
   floating-pointers registers.  Zero if we've tried one of
   them and gotten an error.  */
int have_ptrace_getsetfpregs = 1;

/* *INDENT-OFF* */
/* registers layout, as presented by the ptrace interface:
PT_R0, PT_R1, PT_R2, PT_R3, PT_R4, PT_R5, PT_R6, PT_R7,
PT_R8, PT_R9, PT_R10, PT_R11, PT_R12, PT_R13, PT_R14, PT_R15,
PT_R16, PT_R17, PT_R18, PT_R19, PT_R20, PT_R21, PT_R22, PT_R23,
PT_R24, PT_R25, PT_R26, PT_R27, PT_R28, PT_R29, PT_R30, PT_R31,
PT_FPR0, PT_FPR0 + 2, PT_FPR0 + 4, PT_FPR0 + 6,
PT_FPR0 + 8, PT_FPR0 + 10, PT_FPR0 + 12, PT_FPR0 + 14,
PT_FPR0 + 16, PT_FPR0 + 18, PT_FPR0 + 20, PT_FPR0 + 22,
PT_FPR0 + 24, PT_FPR0 + 26, PT_FPR0 + 28, PT_FPR0 + 30,
PT_FPR0 + 32, PT_FPR0 + 34, PT_FPR0 + 36, PT_FPR0 + 38,
PT_FPR0 + 40, PT_FPR0 + 42, PT_FPR0 + 44, PT_FPR0 + 46,
PT_FPR0 + 48, PT_FPR0 + 50, PT_FPR0 + 52, PT_FPR0 + 54,
PT_FPR0 + 56, PT_FPR0 + 58, PT_FPR0 + 60, PT_FPR0 + 62,
PT_NIP, PT_MSR, PT_CCR, PT_LNK, PT_CTR, PT_XER, PT_MQ */
/* *INDENT_ON * */

static int
ppc_register_u_addr (struct gdbarch *gdbarch, int regno)
{
  int u_addr = -1;
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (long);

  /* General purpose registers occupy 1 slot each in the buffer.  */
  if (regno >= tdep->ppc_gp0_regnum 
      && regno < tdep->ppc_gp0_regnum + ppc_num_gprs)
    u_addr = ((regno - tdep->ppc_gp0_regnum + PT_R0) * wordsize);

  /* Floating point regs: eight bytes each in both 32- and 64-bit
     ptrace interfaces.  Thus, two slots each in 32-bit interface, one
     slot each in 64-bit interface.  */
  if (tdep->ppc_fp0_regnum >= 0
      && regno >= tdep->ppc_fp0_regnum
      && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)
    u_addr = (PT_FPR0 * wordsize) + ((regno - tdep->ppc_fp0_regnum) * 8);

  /* UISA special purpose registers: 1 slot each.  */
  if (regno == gdbarch_pc_regnum (gdbarch))
    u_addr = PT_NIP * wordsize;
  if (regno == tdep->ppc_lr_regnum)
    u_addr = PT_LNK * wordsize;
  if (regno == tdep->ppc_cr_regnum)
    u_addr = PT_CCR * wordsize;
  if (regno == tdep->ppc_xer_regnum)
    u_addr = PT_XER * wordsize;
  if (regno == tdep->ppc_ctr_regnum)
    u_addr = PT_CTR * wordsize;
#ifdef PT_MQ
  if (regno == tdep->ppc_mq_regnum)
    u_addr = PT_MQ * wordsize;
#endif
  if (regno == tdep->ppc_ps_regnum)
    u_addr = PT_MSR * wordsize;
  if (regno == PPC_ORIG_R3_REGNUM)
    u_addr = PT_ORIG_R3 * wordsize;
  if (regno == PPC_TRAP_REGNUM)
    u_addr = PT_TRAP * wordsize;
  if (tdep->ppc_fpscr_regnum >= 0
      && regno == tdep->ppc_fpscr_regnum)
    {
      /* NOTE: cagney/2005-02-08: On some 64-bit GNU/Linux systems the
	 kernel headers incorrectly contained the 32-bit definition of
	 PT_FPSCR.  For the 32-bit definition, floating-point
	 registers occupy two 32-bit "slots", and the FPSCR lives in
	 the second half of such a slot-pair (hence +1).  For 64-bit,
	 the FPSCR instead occupies the full 64-bit 2-word-slot and
	 hence no adjustment is necessary.  Hack around this.  */
      if (wordsize == 8 && PT_FPSCR == (48 + 32 + 1))
	u_addr = (48 + 32) * wordsize;
      /* If the FPSCR is 64-bit wide, we need to fetch the whole 64-bit
	 slot and not just its second word.  The PT_FPSCR supplied when
	 GDB is compiled as a 32-bit app doesn't reflect this.  */
      else if (wordsize == 4 && register_size (gdbarch, regno) == 8
	       && PT_FPSCR == (48 + 2*32 + 1))
	u_addr = (48 + 2*32) * wordsize;
      else
	u_addr = PT_FPSCR * wordsize;
    }
  return u_addr;
}

/* The Linux kernel ptrace interface for POWER7 VSX registers uses the
   registers set mechanism, as opposed to the interface for all the
   other registers, that stores/fetches each register individually.  */
static void
fetch_vsx_register (struct regcache *regcache, int tid, int regno)
{
  int ret;
  gdb_vsxregset_t regs;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int vsxregsize = register_size (gdbarch, tdep->ppc_vsr0_upper_regnum);

  ret = ptrace (PTRACE_GETVSXREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
	{
	  have_ptrace_getsetvsxregs = 0;
	  return;
	}
      perror_with_name (_("Unable to fetch VSX register"));
    }

  regcache_raw_supply (regcache, regno,
		       regs + (regno - tdep->ppc_vsr0_upper_regnum)
		       * vsxregsize);
}

/* The Linux kernel ptrace interface for AltiVec registers uses the
   registers set mechanism, as opposed to the interface for all the
   other registers, that stores/fetches each register individually.  */
static void
fetch_altivec_register (struct regcache *regcache, int tid, int regno)
{
  int ret;
  int offset = 0;
  gdb_vrregset_t regs;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int vrregsize = register_size (gdbarch, tdep->ppc_vr0_regnum);

  ret = ptrace (PTRACE_GETVRREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getvrregs = 0;
          return;
        }
      perror_with_name (_("Unable to fetch AltiVec register"));
    }
 
  /* VSCR is fetched as a 16 bytes quantity, but it is really 4 bytes
     long on the hardware.  We deal only with the lower 4 bytes of the
     vector.  VRSAVE is at the end of the array in a 4 bytes slot, so
     there is no need to define an offset for it.  */
  if (regno == (tdep->ppc_vrsave_regnum - 1))
    offset = vrregsize - register_size (gdbarch, tdep->ppc_vrsave_regnum);
  
  regcache_raw_supply (regcache, regno,
		       regs + (regno
			       - tdep->ppc_vr0_regnum) * vrregsize + offset);
}

/* Fetch the top 32 bits of TID's general-purpose registers and the
   SPE-specific registers, and place the results in EVRREGSET.  If we
   don't support PTRACE_GETEVRREGS, then just fill EVRREGSET with
   zeros.

   All the logic to deal with whether or not the PTRACE_GETEVRREGS and
   PTRACE_SETEVRREGS requests are supported is isolated here, and in
   set_spe_registers.  */
static void
get_spe_registers (int tid, struct gdb_evrregset_t *evrregset)
{
  if (have_ptrace_getsetevrregs)
    {
      if (ptrace (PTRACE_GETEVRREGS, tid, 0, evrregset) >= 0)
        return;
      else
        {
          /* EIO means that the PTRACE_GETEVRREGS request isn't supported;
             we just return zeros.  */
          if (errno == EIO)
            have_ptrace_getsetevrregs = 0;
          else
            /* Anything else needs to be reported.  */
            perror_with_name (_("Unable to fetch SPE registers"));
        }
    }

  memset (evrregset, 0, sizeof (*evrregset));
}

/* Supply values from TID for SPE-specific raw registers: the upper
   halves of the GPRs, the accumulator, and the spefscr.  REGNO must
   be the number of an upper half register, acc, spefscr, or -1 to
   supply the values of all registers.  */
static void
fetch_spe_register (struct regcache *regcache, int tid, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct gdb_evrregset_t evrregs;

  gdb_assert (sizeof (evrregs.evr[0])
              == register_size (gdbarch, tdep->ppc_ev0_upper_regnum));
  gdb_assert (sizeof (evrregs.acc)
              == register_size (gdbarch, tdep->ppc_acc_regnum));
  gdb_assert (sizeof (evrregs.spefscr)
              == register_size (gdbarch, tdep->ppc_spefscr_regnum));

  get_spe_registers (tid, &evrregs);

  if (regno == -1)
    {
      int i;

      for (i = 0; i < ppc_num_gprs; i++)
        regcache_raw_supply (regcache, tdep->ppc_ev0_upper_regnum + i,
                             &evrregs.evr[i]);
    }
  else if (tdep->ppc_ev0_upper_regnum <= regno
           && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    regcache_raw_supply (regcache, regno,
                         &evrregs.evr[regno - tdep->ppc_ev0_upper_regnum]);

  if (regno == -1
      || regno == tdep->ppc_acc_regnum)
    regcache_raw_supply (regcache, tdep->ppc_acc_regnum, &evrregs.acc);

  if (regno == -1
      || regno == tdep->ppc_spefscr_regnum)
    regcache_raw_supply (regcache, tdep->ppc_spefscr_regnum,
                         &evrregs.spefscr);
}

static void
fetch_register (struct regcache *regcache, int tid, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* This isn't really an address.  But ptrace thinks of it as one.  */
  CORE_ADDR regaddr = ppc_register_u_addr (gdbarch, regno);
  int bytes_transferred;
  unsigned int offset;         /* Offset of registers within the u area.  */
  gdb_byte buf[MAX_REGISTER_SIZE];

  if (altivec_register_p (gdbarch, regno))
    {
      /* If this is the first time through, or if it is not the first
         time through, and we have comfirmed that there is kernel
         support for such a ptrace request, then go and fetch the
         register.  */
      if (have_ptrace_getvrregs)
       {
         fetch_altivec_register (regcache, tid, regno);
         return;
       }
     /* If we have discovered that there is no ptrace support for
        AltiVec registers, fall through and return zeroes, because
        regaddr will be -1 in this case.  */
    }
  if (vsx_register_p (gdbarch, regno))
    {
      if (have_ptrace_getsetvsxregs)
	{
	  fetch_vsx_register (regcache, tid, regno);
	  return;
	}
    }
  else if (spe_register_p (gdbarch, regno))
    {
      fetch_spe_register (regcache, tid, regno);
      return;
    }

  if (regaddr == -1)
    {
      memset (buf, '\0', register_size (gdbarch, regno));   /* Supply zeroes */
      regcache_raw_supply (regcache, regno, buf);
      return;
    }

  /* Read the raw register using sizeof(long) sized chunks.  On a
     32-bit platform, 64-bit floating-point registers will require two
     transfers.  */
  for (bytes_transferred = 0;
       bytes_transferred < register_size (gdbarch, regno);
       bytes_transferred += sizeof (long))
    {
      long l;

      errno = 0;
      l = ptrace (PTRACE_PEEKUSER, tid, (PTRACE_TYPE_ARG3) regaddr, 0);
      regaddr += sizeof (long);
      if (errno != 0)
	{
          char message[128];
	  xsnprintf (message, sizeof (message), "reading register %s (#%d)",
		     gdbarch_register_name (gdbarch, regno), regno);
	  perror_with_name (message);
	}
      memcpy (&buf[bytes_transferred], &l, sizeof (l));
    }

  /* Now supply the register.  Keep in mind that the regcache's idea
     of the register's size may not be a multiple of sizeof
     (long).  */
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
    {
      /* Little-endian values are always found at the left end of the
         bytes transferred.  */
      regcache_raw_supply (regcache, regno, buf);
    }
  else if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      /* Big-endian values are found at the right end of the bytes
         transferred.  */
      size_t padding = (bytes_transferred - register_size (gdbarch, regno));
      regcache_raw_supply (regcache, regno, buf + padding);
    }
  else 
    internal_error (__FILE__, __LINE__,
                    _("fetch_register: unexpected byte order: %d"),
                    gdbarch_byte_order (gdbarch));
}

static void
supply_vsxregset (struct regcache *regcache, gdb_vsxregset_t *vsxregsetp)
{
  int i;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int vsxregsize = register_size (gdbarch, tdep->ppc_vsr0_upper_regnum);

  for (i = 0; i < ppc_num_vshrs; i++)
    {
	regcache_raw_supply (regcache, tdep->ppc_vsr0_upper_regnum + i,
			     *vsxregsetp + i * vsxregsize);
    }
}

static void
supply_vrregset (struct regcache *regcache, gdb_vrregset_t *vrregsetp)
{
  int i;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int num_of_vrregs = tdep->ppc_vrsave_regnum - tdep->ppc_vr0_regnum + 1;
  int vrregsize = register_size (gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (gdbarch, tdep->ppc_vrsave_regnum);

  for (i = 0; i < num_of_vrregs; i++)
    {
      /* The last 2 registers of this set are only 32 bit long, not
         128.  However an offset is necessary only for VSCR because it
         occupies a whole vector, while VRSAVE occupies a full 4 bytes
         slot.  */
      if (i == (num_of_vrregs - 2))
        regcache_raw_supply (regcache, tdep->ppc_vr0_regnum + i,
			     *vrregsetp + i * vrregsize + offset);
      else
        regcache_raw_supply (regcache, tdep->ppc_vr0_regnum + i,
			     *vrregsetp + i * vrregsize);
    }
}

static void
fetch_vsx_registers (struct regcache *regcache, int tid)
{
  int ret;
  gdb_vsxregset_t regs;

  ret = ptrace (PTRACE_GETVSXREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
	{
	  have_ptrace_getsetvsxregs = 0;
	  return;
	}
      perror_with_name (_("Unable to fetch VSX registers"));
    }
  supply_vsxregset (regcache, &regs);
}

static void
fetch_altivec_registers (struct regcache *regcache, int tid)
{
  int ret;
  gdb_vrregset_t regs;
  
  ret = ptrace (PTRACE_GETVRREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
	{
          have_ptrace_getvrregs = 0;
	  return;
	}
      perror_with_name (_("Unable to fetch AltiVec registers"));
    }
  supply_vrregset (regcache, &regs);
}

/* This function actually issues the request to ptrace, telling
   it to get all general-purpose registers and put them into the
   specified regset.
   
   If the ptrace request does not exist, this function returns 0
   and properly sets the have_ptrace_* flag.  If the request fails,
   this function calls perror_with_name.  Otherwise, if the request
   succeeds, then the regcache gets filled and 1 is returned.  */
static int
fetch_all_gp_regs (struct regcache *regcache, int tid)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  gdb_gregset_t gregset;

  if (ptrace (PTRACE_GETREGS, tid, 0, (void *) &gregset) < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getsetregs = 0;
          return 0;
        }
      perror_with_name (_("Couldn't get general-purpose registers."));
    }

  supply_gregset (regcache, (const gdb_gregset_t *) &gregset);

  return 1;
}

/* This is a wrapper for the fetch_all_gp_regs function.  It is
   responsible for verifying if this target has the ptrace request
   that can be used to fetch all general-purpose registers at one
   shot.  If it doesn't, then we should fetch them using the
   old-fashioned way, which is to iterate over the registers and
   request them one by one.  */
static void
fetch_gp_regs (struct regcache *regcache, int tid)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int i;

  if (have_ptrace_getsetregs)
    if (fetch_all_gp_regs (regcache, tid))
      return;

  /* If we've hit this point, it doesn't really matter which
     architecture we are using.  We just need to read the
     registers in the "old-fashioned way".  */
  for (i = 0; i < ppc_num_gprs; i++)
    fetch_register (regcache, tid, tdep->ppc_gp0_regnum + i);
}

/* This function actually issues the request to ptrace, telling
   it to get all floating-point registers and put them into the
   specified regset.
   
   If the ptrace request does not exist, this function returns 0
   and properly sets the have_ptrace_* flag.  If the request fails,
   this function calls perror_with_name.  Otherwise, if the request
   succeeds, then the regcache gets filled and 1 is returned.  */
static int
fetch_all_fp_regs (struct regcache *regcache, int tid)
{
  gdb_fpregset_t fpregs;

  if (ptrace (PTRACE_GETFPREGS, tid, 0, (void *) &fpregs) < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getsetfpregs = 0;
          return 0;
        }
      perror_with_name (_("Couldn't get floating-point registers."));
    }

  supply_fpregset (regcache, (const gdb_fpregset_t *) &fpregs);

  return 1;
}

/* This is a wrapper for the fetch_all_fp_regs function.  It is
   responsible for verifying if this target has the ptrace request
   that can be used to fetch all floating-point registers at one
   shot.  If it doesn't, then we should fetch them using the
   old-fashioned way, which is to iterate over the registers and
   request them one by one.  */
static void
fetch_fp_regs (struct regcache *regcache, int tid)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int i;

  if (have_ptrace_getsetfpregs)
    if (fetch_all_fp_regs (regcache, tid))
      return;
 
  /* If we've hit this point, it doesn't really matter which
     architecture we are using.  We just need to read the
     registers in the "old-fashioned way".  */
  for (i = 0; i < ppc_num_fprs; i++)
    fetch_register (regcache, tid, tdep->ppc_fp0_regnum + i);
}

static void 
fetch_ppc_registers (struct regcache *regcache, int tid)
{
  int i;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  fetch_gp_regs (regcache, tid);
  if (tdep->ppc_fp0_regnum >= 0)
    fetch_fp_regs (regcache, tid);
  fetch_register (regcache, tid, gdbarch_pc_regnum (gdbarch));
  if (tdep->ppc_ps_regnum != -1)
    fetch_register (regcache, tid, tdep->ppc_ps_regnum);
  if (tdep->ppc_cr_regnum != -1)
    fetch_register (regcache, tid, tdep->ppc_cr_regnum);
  if (tdep->ppc_lr_regnum != -1)
    fetch_register (regcache, tid, tdep->ppc_lr_regnum);
  if (tdep->ppc_ctr_regnum != -1)
    fetch_register (regcache, tid, tdep->ppc_ctr_regnum);
  if (tdep->ppc_xer_regnum != -1)
    fetch_register (regcache, tid, tdep->ppc_xer_regnum);
  if (tdep->ppc_mq_regnum != -1)
    fetch_register (regcache, tid, tdep->ppc_mq_regnum);
  if (ppc_linux_trap_reg_p (gdbarch))
    {
      fetch_register (regcache, tid, PPC_ORIG_R3_REGNUM);
      fetch_register (regcache, tid, PPC_TRAP_REGNUM);
    }
  if (tdep->ppc_fpscr_regnum != -1)
    fetch_register (regcache, tid, tdep->ppc_fpscr_regnum);
  if (have_ptrace_getvrregs)
    if (tdep->ppc_vr0_regnum != -1 && tdep->ppc_vrsave_regnum != -1)
      fetch_altivec_registers (regcache, tid);
  if (have_ptrace_getsetvsxregs)
    if (tdep->ppc_vsr0_upper_regnum != -1)
      fetch_vsx_registers (regcache, tid);
  if (tdep->ppc_ev0_upper_regnum >= 0)
    fetch_spe_register (regcache, tid, -1);
}

/* Fetch registers from the child process.  Fetch all registers if
   regno == -1, otherwise fetch all general registers or all floating
   point registers depending upon the value of regno.  */
static void
ppc_linux_fetch_inferior_registers (struct target_ops *ops,
				    struct regcache *regcache, int regno)
{
  /* Overload thread id onto process id.  */
  int tid = ptid_get_lwp (inferior_ptid);

  /* No thread id, just use process id.  */
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid);

  if (regno == -1)
    fetch_ppc_registers (regcache, tid);
  else 
    fetch_register (regcache, tid, regno);
}

/* Store one VSX register.  */
static void
store_vsx_register (const struct regcache *regcache, int tid, int regno)
{
  int ret;
  gdb_vsxregset_t regs;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int vsxregsize = register_size (gdbarch, tdep->ppc_vsr0_upper_regnum);

  ret = ptrace (PTRACE_GETVSXREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
	{
	  have_ptrace_getsetvsxregs = 0;
	  return;
	}
      perror_with_name (_("Unable to fetch VSX register"));
    }

  regcache_raw_collect (regcache, regno, regs +
			(regno - tdep->ppc_vsr0_upper_regnum) * vsxregsize);

  ret = ptrace (PTRACE_SETVSXREGS, tid, 0, &regs);
  if (ret < 0)
    perror_with_name (_("Unable to store VSX register"));
}

/* Store one register.  */
static void
store_altivec_register (const struct regcache *regcache, int tid, int regno)
{
  int ret;
  int offset = 0;
  gdb_vrregset_t regs;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int vrregsize = register_size (gdbarch, tdep->ppc_vr0_regnum);

  ret = ptrace (PTRACE_GETVRREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getvrregs = 0;
          return;
        }
      perror_with_name (_("Unable to fetch AltiVec register"));
    }

  /* VSCR is fetched as a 16 bytes quantity, but it is really 4 bytes
     long on the hardware.  */
  if (regno == (tdep->ppc_vrsave_regnum - 1))
    offset = vrregsize - register_size (gdbarch, tdep->ppc_vrsave_regnum);

  regcache_raw_collect (regcache, regno,
			regs + (regno
				- tdep->ppc_vr0_regnum) * vrregsize + offset);

  ret = ptrace (PTRACE_SETVRREGS, tid, 0, &regs);
  if (ret < 0)
    perror_with_name (_("Unable to store AltiVec register"));
}

/* Assuming TID referrs to an SPE process, set the top halves of TID's
   general-purpose registers and its SPE-specific registers to the
   values in EVRREGSET.  If we don't support PTRACE_SETEVRREGS, do
   nothing.

   All the logic to deal with whether or not the PTRACE_GETEVRREGS and
   PTRACE_SETEVRREGS requests are supported is isolated here, and in
   get_spe_registers.  */
static void
set_spe_registers (int tid, struct gdb_evrregset_t *evrregset)
{
  if (have_ptrace_getsetevrregs)
    {
      if (ptrace (PTRACE_SETEVRREGS, tid, 0, evrregset) >= 0)
        return;
      else
        {
          /* EIO means that the PTRACE_SETEVRREGS request isn't
             supported; we fail silently, and don't try the call
             again.  */
          if (errno == EIO)
            have_ptrace_getsetevrregs = 0;
          else
            /* Anything else needs to be reported.  */
            perror_with_name (_("Unable to set SPE registers"));
        }
    }
}

/* Write GDB's value for the SPE-specific raw register REGNO to TID.
   If REGNO is -1, write the values of all the SPE-specific
   registers.  */
static void
store_spe_register (const struct regcache *regcache, int tid, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  struct gdb_evrregset_t evrregs;

  gdb_assert (sizeof (evrregs.evr[0])
              == register_size (gdbarch, tdep->ppc_ev0_upper_regnum));
  gdb_assert (sizeof (evrregs.acc)
              == register_size (gdbarch, tdep->ppc_acc_regnum));
  gdb_assert (sizeof (evrregs.spefscr)
              == register_size (gdbarch, tdep->ppc_spefscr_regnum));

  if (regno == -1)
    /* Since we're going to write out every register, the code below
       should store to every field of evrregs; if that doesn't happen,
       make it obvious by initializing it with suspicious values.  */
    memset (&evrregs, 42, sizeof (evrregs));
  else
    /* We can only read and write the entire EVR register set at a
       time, so to write just a single register, we do a
       read-modify-write maneuver.  */
    get_spe_registers (tid, &evrregs);

  if (regno == -1)
    {
      int i;

      for (i = 0; i < ppc_num_gprs; i++)
        regcache_raw_collect (regcache,
                              tdep->ppc_ev0_upper_regnum + i,
                              &evrregs.evr[i]);
    }
  else if (tdep->ppc_ev0_upper_regnum <= regno
           && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    regcache_raw_collect (regcache, regno,
                          &evrregs.evr[regno - tdep->ppc_ev0_upper_regnum]);

  if (regno == -1
      || regno == tdep->ppc_acc_regnum)
    regcache_raw_collect (regcache,
                          tdep->ppc_acc_regnum,
                          &evrregs.acc);

  if (regno == -1
      || regno == tdep->ppc_spefscr_regnum)
    regcache_raw_collect (regcache,
                          tdep->ppc_spefscr_regnum,
                          &evrregs.spefscr);

  /* Write back the modified register set.  */
  set_spe_registers (tid, &evrregs);
}

static void
store_register (const struct regcache *regcache, int tid, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  /* This isn't really an address.  But ptrace thinks of it as one.  */
  CORE_ADDR regaddr = ppc_register_u_addr (gdbarch, regno);
  int i;
  size_t bytes_to_transfer;
  gdb_byte buf[MAX_REGISTER_SIZE];

  if (altivec_register_p (gdbarch, regno))
    {
      store_altivec_register (regcache, tid, regno);
      return;
    }
  if (vsx_register_p (gdbarch, regno))
    {
      store_vsx_register (regcache, tid, regno);
      return;
    }
  else if (spe_register_p (gdbarch, regno))
    {
      store_spe_register (regcache, tid, regno);
      return;
    }

  if (regaddr == -1)
    return;

  /* First collect the register.  Keep in mind that the regcache's
     idea of the register's size may not be a multiple of sizeof
     (long).  */
  memset (buf, 0, sizeof buf);
  bytes_to_transfer = align_up (register_size (gdbarch, regno), sizeof (long));
  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
    {
      /* Little-endian values always sit at the left end of the buffer.  */
      regcache_raw_collect (regcache, regno, buf);
    }
  else if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      /* Big-endian values sit at the right end of the buffer.  */
      size_t padding = (bytes_to_transfer - register_size (gdbarch, regno));
      regcache_raw_collect (regcache, regno, buf + padding);
    }

  for (i = 0; i < bytes_to_transfer; i += sizeof (long))
    {
      long l;

      memcpy (&l, &buf[i], sizeof (l));
      errno = 0;
      ptrace (PTRACE_POKEUSER, tid, (PTRACE_TYPE_ARG3) regaddr, l);
      regaddr += sizeof (long);

      if (errno == EIO 
          && (regno == tdep->ppc_fpscr_regnum
	      || regno == PPC_ORIG_R3_REGNUM
	      || regno == PPC_TRAP_REGNUM))
	{
	  /* Some older kernel versions don't allow fpscr, orig_r3
	     or trap to be written.  */
	  continue;
	}

      if (errno != 0)
	{
          char message[128];
	  xsnprintf (message, sizeof (message), "writing register %s (#%d)",
		     gdbarch_register_name (gdbarch, regno), regno);
	  perror_with_name (message);
	}
    }
}

static void
fill_vsxregset (const struct regcache *regcache, gdb_vsxregset_t *vsxregsetp)
{
  int i;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int vsxregsize = register_size (gdbarch, tdep->ppc_vsr0_upper_regnum);

  for (i = 0; i < ppc_num_vshrs; i++)
    regcache_raw_collect (regcache, tdep->ppc_vsr0_upper_regnum + i,
			  *vsxregsetp + i * vsxregsize);
}

static void
fill_vrregset (const struct regcache *regcache, gdb_vrregset_t *vrregsetp)
{
  int i;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int num_of_vrregs = tdep->ppc_vrsave_regnum - tdep->ppc_vr0_regnum + 1;
  int vrregsize = register_size (gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (gdbarch, tdep->ppc_vrsave_regnum);

  for (i = 0; i < num_of_vrregs; i++)
    {
      /* The last 2 registers of this set are only 32 bit long, not
         128, but only VSCR is fetched as a 16 bytes quantity.  */
      if (i == (num_of_vrregs - 2))
        regcache_raw_collect (regcache, tdep->ppc_vr0_regnum + i,
			      *vrregsetp + i * vrregsize + offset);
      else
        regcache_raw_collect (regcache, tdep->ppc_vr0_regnum + i,
			      *vrregsetp + i * vrregsize);
    }
}

static void
store_vsx_registers (const struct regcache *regcache, int tid)
{
  int ret;
  gdb_vsxregset_t regs;

  ret = ptrace (PTRACE_GETVSXREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
	{
	  have_ptrace_getsetvsxregs = 0;
	  return;
	}
      perror_with_name (_("Couldn't get VSX registers"));
    }

  fill_vsxregset (regcache, &regs);

  if (ptrace (PTRACE_SETVSXREGS, tid, 0, &regs) < 0)
    perror_with_name (_("Couldn't write VSX registers"));
}

static void
store_altivec_registers (const struct regcache *regcache, int tid)
{
  int ret;
  gdb_vrregset_t regs;

  ret = ptrace (PTRACE_GETVRREGS, tid, 0, &regs);
  if (ret < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getvrregs = 0;
          return;
        }
      perror_with_name (_("Couldn't get AltiVec registers"));
    }

  fill_vrregset (regcache, &regs);
  
  if (ptrace (PTRACE_SETVRREGS, tid, 0, &regs) < 0)
    perror_with_name (_("Couldn't write AltiVec registers"));
}

/* This function actually issues the request to ptrace, telling
   it to store all general-purpose registers present in the specified
   regset.
   
   If the ptrace request does not exist, this function returns 0
   and properly sets the have_ptrace_* flag.  If the request fails,
   this function calls perror_with_name.  Otherwise, if the request
   succeeds, then the regcache is stored and 1 is returned.  */
static int
store_all_gp_regs (const struct regcache *regcache, int tid, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  gdb_gregset_t gregset;

  if (ptrace (PTRACE_GETREGS, tid, 0, (void *) &gregset) < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getsetregs = 0;
          return 0;
        }
      perror_with_name (_("Couldn't get general-purpose registers."));
    }

  fill_gregset (regcache, &gregset, regno);

  if (ptrace (PTRACE_SETREGS, tid, 0, (void *) &gregset) < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getsetregs = 0;
          return 0;
        }
      perror_with_name (_("Couldn't set general-purpose registers."));
    }

  return 1;
}

/* This is a wrapper for the store_all_gp_regs function.  It is
   responsible for verifying if this target has the ptrace request
   that can be used to store all general-purpose registers at one
   shot.  If it doesn't, then we should store them using the
   old-fashioned way, which is to iterate over the registers and
   store them one by one.  */
static void
store_gp_regs (const struct regcache *regcache, int tid, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int i;

  if (have_ptrace_getsetregs)
    if (store_all_gp_regs (regcache, tid, regno))
      return;

  /* If we hit this point, it doesn't really matter which
     architecture we are using.  We just need to store the
     registers in the "old-fashioned way".  */
  for (i = 0; i < ppc_num_gprs; i++)
    store_register (regcache, tid, tdep->ppc_gp0_regnum + i);
}

/* This function actually issues the request to ptrace, telling
   it to store all floating-point registers present in the specified
   regset.
   
   If the ptrace request does not exist, this function returns 0
   and properly sets the have_ptrace_* flag.  If the request fails,
   this function calls perror_with_name.  Otherwise, if the request
   succeeds, then the regcache is stored and 1 is returned.  */
static int
store_all_fp_regs (const struct regcache *regcache, int tid, int regno)
{
  gdb_fpregset_t fpregs;

  if (ptrace (PTRACE_GETFPREGS, tid, 0, (void *) &fpregs) < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getsetfpregs = 0;
          return 0;
        }
      perror_with_name (_("Couldn't get floating-point registers."));
    }

  fill_fpregset (regcache, &fpregs, regno);

  if (ptrace (PTRACE_SETFPREGS, tid, 0, (void *) &fpregs) < 0)
    {
      if (errno == EIO)
        {
          have_ptrace_getsetfpregs = 0;
          return 0;
        }
      perror_with_name (_("Couldn't set floating-point registers."));
    }

  return 1;
}

/* This is a wrapper for the store_all_fp_regs function.  It is
   responsible for verifying if this target has the ptrace request
   that can be used to store all floating-point registers at one
   shot.  If it doesn't, then we should store them using the
   old-fashioned way, which is to iterate over the registers and
   store them one by one.  */
static void
store_fp_regs (const struct regcache *regcache, int tid, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  int i;

  if (have_ptrace_getsetfpregs)
    if (store_all_fp_regs (regcache, tid, regno))
      return;

  /* If we hit this point, it doesn't really matter which
     architecture we are using.  We just need to store the
     registers in the "old-fashioned way".  */
  for (i = 0; i < ppc_num_fprs; i++)
    store_register (regcache, tid, tdep->ppc_fp0_regnum + i);
}

static void
store_ppc_registers (const struct regcache *regcache, int tid)
{
  int i;
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
 
  store_gp_regs (regcache, tid, -1);
  if (tdep->ppc_fp0_regnum >= 0)
    store_fp_regs (regcache, tid, -1);
  store_register (regcache, tid, gdbarch_pc_regnum (gdbarch));
  if (tdep->ppc_ps_regnum != -1)
    store_register (regcache, tid, tdep->ppc_ps_regnum);
  if (tdep->ppc_cr_regnum != -1)
    store_register (regcache, tid, tdep->ppc_cr_regnum);
  if (tdep->ppc_lr_regnum != -1)
    store_register (regcache, tid, tdep->ppc_lr_regnum);
  if (tdep->ppc_ctr_regnum != -1)
    store_register (regcache, tid, tdep->ppc_ctr_regnum);
  if (tdep->ppc_xer_regnum != -1)
    store_register (regcache, tid, tdep->ppc_xer_regnum);
  if (tdep->ppc_mq_regnum != -1)
    store_register (regcache, tid, tdep->ppc_mq_regnum);
  if (tdep->ppc_fpscr_regnum != -1)
    store_register (regcache, tid, tdep->ppc_fpscr_regnum);
  if (ppc_linux_trap_reg_p (gdbarch))
    {
      store_register (regcache, tid, PPC_ORIG_R3_REGNUM);
      store_register (regcache, tid, PPC_TRAP_REGNUM);
    }
  if (have_ptrace_getvrregs)
    if (tdep->ppc_vr0_regnum != -1 && tdep->ppc_vrsave_regnum != -1)
      store_altivec_registers (regcache, tid);
  if (have_ptrace_getsetvsxregs)
    if (tdep->ppc_vsr0_upper_regnum != -1)
      store_vsx_registers (regcache, tid);
  if (tdep->ppc_ev0_upper_regnum >= 0)
    store_spe_register (regcache, tid, -1);
}

/* Fetch the AT_HWCAP entry from the aux vector.  */
static unsigned long
ppc_linux_get_hwcap (void)
{
  CORE_ADDR field;

  if (target_auxv_search (&current_target, AT_HWCAP, &field))
    return (unsigned long) field;

  return 0;
}

/* The cached DABR value, to install in new threads.
   This variable is used when the PowerPC HWDEBUG ptrace
   interface is not available.  */
static long saved_dabr_value;

/* Global structure that will store information about the available
   features provided by the PowerPC HWDEBUG ptrace interface.  */
static struct ppc_debug_info hwdebug_info;

/* Global variable that holds the maximum number of slots that the
   kernel will use.  This is only used when PowerPC HWDEBUG ptrace interface
   is available.  */
static size_t max_slots_number = 0;

struct hw_break_tuple
{
  long slot;
  struct ppc_hw_breakpoint *hw_break;
};

/* This is an internal VEC created to store information about *points inserted
   for each thread.  This is used when PowerPC HWDEBUG ptrace interface is
   available.  */
typedef struct thread_points
  {
    /* The TID to which this *point relates.  */
    int tid;
    /* Information about the *point, such as its address, type, etc.

       Each element inside this vector corresponds to a hardware
       breakpoint or watchpoint in the thread represented by TID.  The maximum
       size of these vector is MAX_SLOTS_NUMBER.  If the hw_break element of
       the tuple is NULL, then the position in the vector is free.  */
    struct hw_break_tuple *hw_breaks;
  } *thread_points_p;
DEF_VEC_P (thread_points_p);

VEC(thread_points_p) *ppc_threads = NULL;

/* The version of the PowerPC HWDEBUG kernel interface that we will use, if
   available.  */
#define PPC_DEBUG_CURRENT_VERSION 1

/* Returns non-zero if we support the PowerPC HWDEBUG ptrace interface.  */
static int
have_ptrace_hwdebug_interface (void)
{
  static int have_ptrace_hwdebug_interface = -1;

  if (have_ptrace_hwdebug_interface == -1)
    {
      int tid;

      tid = ptid_get_lwp (inferior_ptid);
      if (tid == 0)
	tid = ptid_get_pid (inferior_ptid);

      /* Check for kernel support for PowerPC HWDEBUG ptrace interface.  */
      if (ptrace (PPC_PTRACE_GETHWDBGINFO, tid, 0, &hwdebug_info) >= 0)
	{
	  /* Check whether PowerPC HWDEBUG ptrace interface is functional and
	     provides any supported feature.  */
	  if (hwdebug_info.features != 0)
	    {
	      have_ptrace_hwdebug_interface = 1;
	      max_slots_number = hwdebug_info.num_instruction_bps
	        + hwdebug_info.num_data_bps
	        + hwdebug_info.num_condition_regs;
	      return have_ptrace_hwdebug_interface;
	    }
	}
      /* Old school interface and no PowerPC HWDEBUG ptrace support.  */
      have_ptrace_hwdebug_interface = 0;
      memset (&hwdebug_info, 0, sizeof (struct ppc_debug_info));
    }

  return have_ptrace_hwdebug_interface;
}

static int
ppc_linux_can_use_hw_breakpoint (int type, int cnt, int ot)
{
  int total_hw_wp, total_hw_bp;

  if (have_ptrace_hwdebug_interface ())
    {
      /* When PowerPC HWDEBUG ptrace interface is available, the number of
	 available hardware watchpoints and breakpoints is stored at the
	 hwdebug_info struct.  */
      total_hw_bp = hwdebug_info.num_instruction_bps;
      total_hw_wp = hwdebug_info.num_data_bps;
    }
  else
    {
      /* When we do not have PowerPC HWDEBUG ptrace interface, we should
	 consider having 1 hardware watchpoint and no hardware breakpoints.  */
      total_hw_bp = 0;
      total_hw_wp = 1;
    }

  if (type == bp_hardware_watchpoint || type == bp_read_watchpoint
      || type == bp_access_watchpoint || type == bp_watchpoint)
    {
      if (cnt + ot > total_hw_wp)
	return -1;
    }
  else if (type == bp_hardware_breakpoint)
    {
      if (cnt > total_hw_bp)
	return -1;
    }

  if (!have_ptrace_hwdebug_interface ())
    {
      int tid;
      ptid_t ptid = inferior_ptid;

      /* We need to know whether ptrace supports PTRACE_SET_DEBUGREG
	 and whether the target has DABR.  If either answer is no, the
	 ptrace call will return -1.  Fail in that case.  */
      tid = ptid_get_lwp (ptid);
      if (tid == 0)
	tid = ptid_get_pid (ptid);

      if (ptrace (PTRACE_SET_DEBUGREG, tid, 0, 0) == -1)
	return 0;
    }

  return 1;
}

static int
ppc_linux_region_ok_for_hw_watchpoint (CORE_ADDR addr, int len)
{
  /* Handle sub-8-byte quantities.  */
  if (len <= 0)
    return 0;

  /* The PowerPC HWDEBUG ptrace interface tells if there are alignment
     restrictions for watchpoints in the processors.  In that case, we use that
     information to determine the hardcoded watchable region for
     watchpoints.  */
  if (have_ptrace_hwdebug_interface ())
    {
      int region_size;
      /* Embedded DAC-based processors, like the PowerPC 440 have ranged
	 watchpoints and can watch any access within an arbitrary memory
	 region. This is useful to watch arrays and structs, for instance.  It
         takes two hardware watchpoints though.  */
      if (len > 1
	  && hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE
	  && ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
	return 2;
      /* Check if the processor provides DAWR interface.  */
      if (hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_DAWR)
	/* DAWR interface allows to watch up to 512 byte wide ranges which
	   can't cross a 512 byte boundary.  */
	region_size = 512;
      else
	region_size = hwdebug_info.data_bp_alignment;
      /* Server processors provide one hardware watchpoint and addr+len should
         fall in the watchable region provided by the ptrace interface.  */
      if (region_size
	  && (addr + len > (addr & ~(region_size - 1)) + region_size))
	return 0;
    }
  /* addr+len must fall in the 8 byte watchable region for DABR-based
     processors (i.e., server processors).  Without the new PowerPC HWDEBUG 
     ptrace interface, DAC-based processors (i.e., embedded processors) will
     use addresses aligned to 4-bytes due to the way the read/write flags are
     passed in the old ptrace interface.  */
  else if (((ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
	   && (addr + len) > (addr & ~3) + 4)
	   || (addr + len) > (addr & ~7) + 8)
    return 0;

  return 1;
}

/* This function compares two ppc_hw_breakpoint structs field-by-field.  */
static int
hwdebug_point_cmp (struct ppc_hw_breakpoint *a, struct ppc_hw_breakpoint *b)
{
  return (a->trigger_type == b->trigger_type
	  && a->addr_mode == b->addr_mode
	  && a->condition_mode == b->condition_mode
	  && a->addr == b->addr
	  && a->addr2 == b->addr2
	  && a->condition_value == b->condition_value);
}

/* This function can be used to retrieve a thread_points by the TID of the
   related process/thread.  If nothing has been found, and ALLOC_NEW is 0,
   it returns NULL.  If ALLOC_NEW is non-zero, a new thread_points for the
   provided TID will be created and returned.  */
static struct thread_points *
hwdebug_find_thread_points_by_tid (int tid, int alloc_new)
{
  int i;
  struct thread_points *t;

  for (i = 0; VEC_iterate (thread_points_p, ppc_threads, i, t); i++)
    if (t->tid == tid)
      return t;

  t = NULL;

  /* Do we need to allocate a new point_item
     if the wanted one does not exist?  */
  if (alloc_new)
    {
      t = xmalloc (sizeof (struct thread_points));
      t->hw_breaks
	= xzalloc (max_slots_number * sizeof (struct hw_break_tuple));
      t->tid = tid;
      VEC_safe_push (thread_points_p, ppc_threads, t);
    }

  return t;
}

/* This function is a generic wrapper that is responsible for inserting a
   *point (i.e., calling `ptrace' in order to issue the request to the
   kernel) and registering it internally in GDB.  */
static void
hwdebug_insert_point (struct ppc_hw_breakpoint *b, int tid)
{
  int i;
  long slot;
  struct ppc_hw_breakpoint *p = xmalloc (sizeof (struct ppc_hw_breakpoint));
  struct hw_break_tuple *hw_breaks;
  struct cleanup *c = make_cleanup (xfree, p);
  struct thread_points *t;
  struct hw_break_tuple *tuple;

  memcpy (p, b, sizeof (struct ppc_hw_breakpoint));

  errno = 0;
  slot = ptrace (PPC_PTRACE_SETHWDEBUG, tid, 0, p);
  if (slot < 0)
    perror_with_name (_("Unexpected error setting breakpoint or watchpoint"));

  /* Everything went fine, so we have to register this *point.  */
  t = hwdebug_find_thread_points_by_tid (tid, 1);
  gdb_assert (t != NULL);
  hw_breaks = t->hw_breaks;

  /* Find a free element in the hw_breaks vector.  */
  for (i = 0; i < max_slots_number; i++)
    if (hw_breaks[i].hw_break == NULL)
      {
	hw_breaks[i].slot = slot;
	hw_breaks[i].hw_break = p;
	break;
      }

  gdb_assert (i != max_slots_number);

  discard_cleanups (c);
}

/* This function is a generic wrapper that is responsible for removing a
   *point (i.e., calling `ptrace' in order to issue the request to the
   kernel), and unregistering it internally at GDB.  */
static void
hwdebug_remove_point (struct ppc_hw_breakpoint *b, int tid)
{
  int i;
  struct hw_break_tuple *hw_breaks;
  struct thread_points *t;

  t = hwdebug_find_thread_points_by_tid (tid, 0);
  gdb_assert (t != NULL);
  hw_breaks = t->hw_breaks;

  for (i = 0; i < max_slots_number; i++)
    if (hw_breaks[i].hw_break && hwdebug_point_cmp (hw_breaks[i].hw_break, b))
      break;

  gdb_assert (i != max_slots_number);

  /* We have to ignore ENOENT errors because the kernel implements hardware
     breakpoints/watchpoints as "one-shot", that is, they are automatically
     deleted when hit.  */
  errno = 0;
  if (ptrace (PPC_PTRACE_DELHWDEBUG, tid, 0, hw_breaks[i].slot) < 0)
    if (errno != ENOENT)
      perror_with_name (_("Unexpected error deleting "
			  "breakpoint or watchpoint"));

  xfree (hw_breaks[i].hw_break);
  hw_breaks[i].hw_break = NULL;
}

/* Return the number of registers needed for a ranged breakpoint.  */

static int
ppc_linux_ranged_break_num_registers (struct target_ops *target)
{
  return ((have_ptrace_hwdebug_interface ()
	   && hwdebug_info.features & PPC_DEBUG_FEATURE_INSN_BP_RANGE)?
	  2 : -1);
}

/* Insert the hardware breakpoint described by BP_TGT.  Returns 0 for
   success, 1 if hardware breakpoints are not supported or -1 for failure.  */

static int
ppc_linux_insert_hw_breakpoint (struct gdbarch *gdbarch,
				  struct bp_target_info *bp_tgt)
{
  struct lwp_info *lp;
  struct ppc_hw_breakpoint p;

  if (!have_ptrace_hwdebug_interface ())
    return -1;

  p.version = PPC_DEBUG_CURRENT_VERSION;
  p.trigger_type = PPC_BREAKPOINT_TRIGGER_EXECUTE;
  p.condition_mode = PPC_BREAKPOINT_CONDITION_NONE;
  p.addr = (uint64_t) bp_tgt->placed_address;
  p.condition_value = 0;

  if (bp_tgt->length)
    {
      p.addr_mode = PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE;

      /* The breakpoint will trigger if the address of the instruction is
	 within the defined range, as follows: p.addr <= address < p.addr2.  */
      p.addr2 = (uint64_t) bp_tgt->placed_address + bp_tgt->length;
    }
  else
    {
      p.addr_mode = PPC_BREAKPOINT_MODE_EXACT;
      p.addr2 = 0;
    }

  ALL_LWPS (lp)
    hwdebug_insert_point (&p, ptid_get_lwp (lp->ptid));

  return 0;
}

static int
ppc_linux_remove_hw_breakpoint (struct gdbarch *gdbarch,
				  struct bp_target_info *bp_tgt)
{
  struct lwp_info *lp;
  struct ppc_hw_breakpoint p;

  if (!have_ptrace_hwdebug_interface ())
    return -1;

  p.version = PPC_DEBUG_CURRENT_VERSION;
  p.trigger_type = PPC_BREAKPOINT_TRIGGER_EXECUTE;
  p.condition_mode = PPC_BREAKPOINT_CONDITION_NONE;
  p.addr = (uint64_t) bp_tgt->placed_address;
  p.condition_value = 0;

  if (bp_tgt->length)
    {
      p.addr_mode = PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE;

      /* The breakpoint will trigger if the address of the instruction is within
	 the defined range, as follows: p.addr <= address < p.addr2.  */
      p.addr2 = (uint64_t) bp_tgt->placed_address + bp_tgt->length;
    }
  else
    {
      p.addr_mode = PPC_BREAKPOINT_MODE_EXACT;
      p.addr2 = 0;
    }

  ALL_LWPS (lp)
    hwdebug_remove_point (&p, ptid_get_lwp (lp->ptid));

  return 0;
}

static int
get_trigger_type (int rw)
{
  int t;

  if (rw == hw_read)
    t = PPC_BREAKPOINT_TRIGGER_READ;
  else if (rw == hw_write)
    t = PPC_BREAKPOINT_TRIGGER_WRITE;
  else
    t = PPC_BREAKPOINT_TRIGGER_READ | PPC_BREAKPOINT_TRIGGER_WRITE;

  return t;
}

/* Insert a new masked watchpoint at ADDR using the mask MASK.
   RW may be hw_read for a read watchpoint, hw_write for a write watchpoint
   or hw_access for an access watchpoint.  Returns 0 on success and throws
   an error on failure.  */

static int
ppc_linux_insert_mask_watchpoint (struct target_ops *ops, CORE_ADDR addr,
				  CORE_ADDR mask, int rw)
{
  struct lwp_info *lp;
  struct ppc_hw_breakpoint p;

  gdb_assert (have_ptrace_hwdebug_interface ());

  p.version = PPC_DEBUG_CURRENT_VERSION;
  p.trigger_type = get_trigger_type (rw);
  p.addr_mode = PPC_BREAKPOINT_MODE_MASK;
  p.condition_mode = PPC_BREAKPOINT_CONDITION_NONE;
  p.addr = addr;
  p.addr2 = mask;
  p.condition_value = 0;

  ALL_LWPS (lp)
    hwdebug_insert_point (&p, ptid_get_lwp (lp->ptid));

  return 0;
}

/* Remove a masked watchpoint at ADDR with the mask MASK.
   RW may be hw_read for a read watchpoint, hw_write for a write watchpoint
   or hw_access for an access watchpoint.  Returns 0 on success and throws
   an error on failure.  */

static int
ppc_linux_remove_mask_watchpoint (struct target_ops *ops, CORE_ADDR addr,
				  CORE_ADDR mask, int rw)
{
  struct lwp_info *lp;
  struct ppc_hw_breakpoint p;

  gdb_assert (have_ptrace_hwdebug_interface ());

  p.version = PPC_DEBUG_CURRENT_VERSION;
  p.trigger_type = get_trigger_type (rw);
  p.addr_mode = PPC_BREAKPOINT_MODE_MASK;
  p.condition_mode = PPC_BREAKPOINT_CONDITION_NONE;
  p.addr = addr;
  p.addr2 = mask;
  p.condition_value = 0;

  ALL_LWPS (lp)
    hwdebug_remove_point (&p, ptid_get_lwp (lp->ptid));

  return 0;
}

/* Check whether we have at least one free DVC register.  */
static int
can_use_watchpoint_cond_accel (void)
{
  struct thread_points *p;
  int tid = ptid_get_lwp (inferior_ptid);
  int cnt = hwdebug_info.num_condition_regs, i;
  CORE_ADDR tmp_value;

  if (!have_ptrace_hwdebug_interface () || cnt == 0)
    return 0;

  p = hwdebug_find_thread_points_by_tid (tid, 0);

  if (p)
    {
      for (i = 0; i < max_slots_number; i++)
	if (p->hw_breaks[i].hw_break != NULL
	    && (p->hw_breaks[i].hw_break->condition_mode
		!= PPC_BREAKPOINT_CONDITION_NONE))
	  cnt--;

      /* There are no available slots now.  */
      if (cnt <= 0)
	return 0;
    }

  return 1;
}

/* Calculate the enable bits and the contents of the Data Value Compare
   debug register present in BookE processors.

   ADDR is the address to be watched, LEN is the length of watched data
   and DATA_VALUE is the value which will trigger the watchpoint.
   On exit, CONDITION_MODE will hold the enable bits for the DVC, and
   CONDITION_VALUE will hold the value which should be put in the
   DVC register.  */
static void
calculate_dvc (CORE_ADDR addr, int len, CORE_ADDR data_value,
	       uint32_t *condition_mode, uint64_t *condition_value)
{
  int i, num_byte_enable, align_offset, num_bytes_off_dvc,
      rightmost_enabled_byte;
  CORE_ADDR addr_end_data, addr_end_dvc;

  /* The DVC register compares bytes within fixed-length windows which
     are word-aligned, with length equal to that of the DVC register.
     We need to calculate where our watch region is relative to that
     window and enable comparison of the bytes which fall within it.  */

  align_offset = addr % hwdebug_info.sizeof_condition;
  addr_end_data = addr + len;
  addr_end_dvc = (addr - align_offset
		  + hwdebug_info.sizeof_condition);
  num_bytes_off_dvc = (addr_end_data > addr_end_dvc)?
			 addr_end_data - addr_end_dvc : 0;
  num_byte_enable = len - num_bytes_off_dvc;
  /* Here, bytes are numbered from right to left.  */
  rightmost_enabled_byte = (addr_end_data < addr_end_dvc)?
			      addr_end_dvc - addr_end_data : 0;

  *condition_mode = PPC_BREAKPOINT_CONDITION_AND;
  for (i = 0; i < num_byte_enable; i++)
    *condition_mode
      |= PPC_BREAKPOINT_CONDITION_BE (i + rightmost_enabled_byte);

  /* Now we need to match the position within the DVC of the comparison
     value with where the watch region is relative to the window
     (i.e., the ALIGN_OFFSET).  */

  *condition_value = ((uint64_t) data_value >> num_bytes_off_dvc * 8
		      << rightmost_enabled_byte * 8);
}

/* Return the number of memory locations that need to be accessed to
   evaluate the expression which generated the given value chain.
   Returns -1 if there's any register access involved, or if there are
   other kinds of values which are not acceptable in a condition
   expression (e.g., lval_computed or lval_internalvar).  */
static int
num_memory_accesses (struct value *v)
{
  int found_memory_cnt = 0;
  struct value *head = v;

  /* The idea here is that evaluating an expression generates a series
     of values, one holding the value of every subexpression.  (The
     expression a*b+c has five subexpressions: a, b, a*b, c, and
     a*b+c.)  GDB's values hold almost enough information to establish
     the criteria given above --- they identify memory lvalues,
     register lvalues, computed values, etcetera.  So we can evaluate
     the expression, and then scan the chain of values that leaves
     behind to determine the memory locations involved in the evaluation
     of an expression.

     However, I don't think that the values returned by inferior
     function calls are special in any way.  So this function may not
     notice that an expression contains an inferior function call.
     FIXME.  */

  for (; v; v = value_next (v))
    {
      /* Constants and values from the history are fine.  */
      if (VALUE_LVAL (v) == not_lval || deprecated_value_modifiable (v) == 0)
	continue;
      else if (VALUE_LVAL (v) == lval_memory)
	{
	  /* A lazy memory lvalue is one that GDB never needed to fetch;
	     we either just used its address (e.g., `a' in `a.b') or
	     we never needed it at all (e.g., `a' in `a,b').  */
	  if (!value_lazy (v))
	    found_memory_cnt++;
	}
      /* Other kinds of values are not fine.  */
      else
	return -1;
    }

  return found_memory_cnt;
}

/* Verifies whether the expression COND can be implemented using the
   DVC (Data Value Compare) register in BookE processors.  The expression
   must test the watch value for equality with a constant expression.
   If the function returns 1, DATA_VALUE will contain the constant against
   which the watch value should be compared and LEN will contain the size
   of the constant.  */
static int
check_condition (CORE_ADDR watch_addr, struct expression *cond,
		 CORE_ADDR *data_value, int *len)
{
  int pc = 1, num_accesses_left, num_accesses_right;
  struct value *left_val, *right_val, *left_chain, *right_chain;

  if (cond->elts[0].opcode != BINOP_EQUAL)
    return 0;

  fetch_subexp_value (cond, &pc, &left_val, NULL, &left_chain, 0);
  num_accesses_left = num_memory_accesses (left_chain);

  if (left_val == NULL || num_accesses_left < 0)
    {
      free_value_chain (left_chain);

      return 0;
    }

  fetch_subexp_value (cond, &pc, &right_val, NULL, &right_chain, 0);
  num_accesses_right = num_memory_accesses (right_chain);

  if (right_val == NULL || num_accesses_right < 0)
    {
      free_value_chain (left_chain);
      free_value_chain (right_chain);

      return 0;
    }

  if (num_accesses_left == 1 && num_accesses_right == 0
      && VALUE_LVAL (left_val) == lval_memory
      && value_address (left_val) == watch_addr)
    {
      *data_value = value_as_long (right_val);

      /* DATA_VALUE is the constant in RIGHT_VAL, but actually has
	 the same type as the memory region referenced by LEFT_VAL.  */
      *len = TYPE_LENGTH (check_typedef (value_type (left_val)));
    }
  else if (num_accesses_left == 0 && num_accesses_right == 1
	   && VALUE_LVAL (right_val) == lval_memory
	   && value_address (right_val) == watch_addr)
    {
      *data_value = value_as_long (left_val);

      /* DATA_VALUE is the constant in LEFT_VAL, but actually has
	 the same type as the memory region referenced by RIGHT_VAL.  */
      *len = TYPE_LENGTH (check_typedef (value_type (right_val)));
    }
  else
    {
      free_value_chain (left_chain);
      free_value_chain (right_chain);

      return 0;
    }

  free_value_chain (left_chain);
  free_value_chain (right_chain);

  return 1;
}

/* Return non-zero if the target is capable of using hardware to evaluate
   the condition expression, thus only triggering the watchpoint when it is
   true.  */
static int
ppc_linux_can_accel_watchpoint_condition (CORE_ADDR addr, int len, int rw,
					  struct expression *cond)
{
  CORE_ADDR data_value;

  return (have_ptrace_hwdebug_interface ()
	  && hwdebug_info.num_condition_regs > 0
	  && check_condition (addr, cond, &data_value, &len));
}

/* Set up P with the parameters necessary to request a watchpoint covering
   LEN bytes starting at ADDR and if possible with condition expression COND
   evaluated by hardware.  INSERT tells if we are creating a request for
   inserting or removing the watchpoint.  */

static void
create_watchpoint_request (struct ppc_hw_breakpoint *p, CORE_ADDR addr,
			   int len, int rw, struct expression *cond,
			   int insert)
{
  if (len == 1
      || !(hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE))
    {
      int use_condition;
      CORE_ADDR data_value;

      use_condition = (insert? can_use_watchpoint_cond_accel ()
			: hwdebug_info.num_condition_regs > 0);
      if (cond && use_condition && check_condition (addr, cond,
						    &data_value, &len))
	calculate_dvc (addr, len, data_value, &p->condition_mode,
		       &p->condition_value);
      else
	{
	  p->condition_mode = PPC_BREAKPOINT_CONDITION_NONE;
	  p->condition_value = 0;
	}

      p->addr_mode = PPC_BREAKPOINT_MODE_EXACT;
      p->addr2 = 0;
    }
  else
    {
      p->addr_mode = PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE;
      p->condition_mode = PPC_BREAKPOINT_CONDITION_NONE;
      p->condition_value = 0;

      /* The watchpoint will trigger if the address of the memory access is
	 within the defined range, as follows: p->addr <= address < p->addr2.

	 Note that the above sentence just documents how ptrace interprets
	 its arguments; the watchpoint is set to watch the range defined by
	 the user _inclusively_, as specified by the user interface.  */
      p->addr2 = (uint64_t) addr + len;
    }

  p->version = PPC_DEBUG_CURRENT_VERSION;
  p->trigger_type = get_trigger_type (rw);
  p->addr = (uint64_t) addr;
}

static int
ppc_linux_insert_watchpoint (CORE_ADDR addr, int len, int rw,
			     struct expression *cond)
{
  struct lwp_info *lp;
  int ret = -1;

  if (have_ptrace_hwdebug_interface ())
    {
      struct ppc_hw_breakpoint p;

      create_watchpoint_request (&p, addr, len, rw, cond, 1);

      ALL_LWPS (lp)
	hwdebug_insert_point (&p, ptid_get_lwp (lp->ptid));

      ret = 0;
    }
  else
    {
      long dabr_value;
      long read_mode, write_mode;

      if (ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
	{
	  /* PowerPC 440 requires only the read/write flags to be passed
	     to the kernel.  */
	  read_mode = 1;
	  write_mode = 2;
	}
      else
	{
	  /* PowerPC 970 and other DABR-based processors are required to pass
	     the Breakpoint Translation bit together with the flags.  */
	  read_mode = 5;
	  write_mode = 6;
	}

      dabr_value = addr & ~(read_mode | write_mode);
      switch (rw)
	{
	  case hw_read:
	    /* Set read and translate bits.  */
	    dabr_value |= read_mode;
	    break;
	  case hw_write:
	    /* Set write and translate bits.  */
	    dabr_value |= write_mode;
	    break;
	  case hw_access:
	    /* Set read, write and translate bits.  */
	    dabr_value |= read_mode | write_mode;
	    break;
	}

      saved_dabr_value = dabr_value;

      ALL_LWPS (lp)
	if (ptrace (PTRACE_SET_DEBUGREG, ptid_get_lwp (lp->ptid), 0,
		    saved_dabr_value) < 0)
	  return -1;

      ret = 0;
    }

  return ret;
}

static int
ppc_linux_remove_watchpoint (CORE_ADDR addr, int len, int rw,
			     struct expression *cond)
{
  struct lwp_info *lp;
  int ret = -1;

  if (have_ptrace_hwdebug_interface ())
    {
      struct ppc_hw_breakpoint p;

      create_watchpoint_request (&p, addr, len, rw, cond, 0);

      ALL_LWPS (lp)
	hwdebug_remove_point (&p, ptid_get_lwp (lp->ptid));

      ret = 0;
    }
  else
    {
      saved_dabr_value = 0;
      ALL_LWPS (lp)
	if (ptrace (PTRACE_SET_DEBUGREG, ptid_get_lwp (lp->ptid), 0,
		    saved_dabr_value) < 0)
	  return -1;

      ret = 0;
    }

  return ret;
}

static void
ppc_linux_new_thread (struct lwp_info *lp)
{
  int tid = ptid_get_lwp (lp->ptid);

  if (have_ptrace_hwdebug_interface ())
    {
      int i;
      struct thread_points *p;
      struct hw_break_tuple *hw_breaks;

      if (VEC_empty (thread_points_p, ppc_threads))
	return;

      /* Get a list of breakpoints from any thread.  */
      p = VEC_last (thread_points_p, ppc_threads);
      hw_breaks = p->hw_breaks;

      /* Copy that thread's breakpoints and watchpoints to the new thread.  */
      for (i = 0; i < max_slots_number; i++)
	if (hw_breaks[i].hw_break)
	  {
	    /* Older kernels did not make new threads inherit their parent
	       thread's debug state, so we always clear the slot and replicate
	       the debug state ourselves, ensuring compatibility with all
	       kernels.  */

	    /* The ppc debug resource accounting is done through "slots".
	       Ask the kernel the deallocate this specific *point's slot.  */
	    ptrace (PPC_PTRACE_DELHWDEBUG, tid, 0, hw_breaks[i].slot);

	    hwdebug_insert_point (hw_breaks[i].hw_break, tid);
	  }
    }
  else
    ptrace (PTRACE_SET_DEBUGREG, tid, 0, saved_dabr_value);
}

static void
ppc_linux_thread_exit (struct thread_info *tp, int silent)
{
  int i;
  int tid = ptid_get_lwp (tp->ptid);
  struct hw_break_tuple *hw_breaks;
  struct thread_points *t = NULL, *p;

  if (!have_ptrace_hwdebug_interface ())
    return;

  for (i = 0; VEC_iterate (thread_points_p, ppc_threads, i, p); i++)
    if (p->tid == tid)
      {
	t = p;
	break;
      }

  if (t == NULL)
    return;

  VEC_unordered_remove (thread_points_p, ppc_threads, i);

  hw_breaks = t->hw_breaks;

  for (i = 0; i < max_slots_number; i++)
    if (hw_breaks[i].hw_break)
      xfree (hw_breaks[i].hw_break);

  xfree (t->hw_breaks);
  xfree (t);
}

static int
ppc_linux_stopped_data_address (struct target_ops *target, CORE_ADDR *addr_p)
{
  siginfo_t siginfo;

  if (!linux_nat_get_siginfo (inferior_ptid, &siginfo))
    return 0;

  if (siginfo.si_signo != SIGTRAP
      || (siginfo.si_code & 0xffff) != 0x0004 /* TRAP_HWBKPT */)
    return 0;

  if (have_ptrace_hwdebug_interface ())
    {
      int i;
      struct thread_points *t;
      struct hw_break_tuple *hw_breaks;
      /* The index (or slot) of the *point is passed in the si_errno field.  */
      int slot = siginfo.si_errno;

      t = hwdebug_find_thread_points_by_tid (ptid_get_lwp (inferior_ptid), 0);

      /* Find out if this *point is a hardware breakpoint.
	 If so, we should return 0.  */
      if (t)
	{
	  hw_breaks = t->hw_breaks;
	  for (i = 0; i < max_slots_number; i++)
	   if (hw_breaks[i].hw_break && hw_breaks[i].slot == slot
	       && hw_breaks[i].hw_break->trigger_type
		    == PPC_BREAKPOINT_TRIGGER_EXECUTE)
	     return 0;
	}
    }

  *addr_p = (CORE_ADDR) (uintptr_t) siginfo.si_addr;
  return 1;
}

static int
ppc_linux_stopped_by_watchpoint (void)
{
  CORE_ADDR addr;
  return ppc_linux_stopped_data_address (&current_target, &addr);
}

static int
ppc_linux_watchpoint_addr_within_range (struct target_ops *target,
					CORE_ADDR addr,
					CORE_ADDR start, int length)
{
  int mask;

  if (have_ptrace_hwdebug_interface ()
      && ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
    return start <= addr && start + length >= addr;
  else if (ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
    mask = 3;
  else
    mask = 7;

  addr &= ~mask;

  /* Check whether [start, start+length-1] intersects [addr, addr+mask].  */
  return start <= addr + mask && start + length - 1 >= addr;
}

/* Return the number of registers needed for a masked hardware watchpoint.  */

static int
ppc_linux_masked_watch_num_registers (struct target_ops *target,
				      CORE_ADDR addr, CORE_ADDR mask)
{
  if (!have_ptrace_hwdebug_interface ()
	   || (hwdebug_info.features & PPC_DEBUG_FEATURE_DATA_BP_MASK) == 0)
    return -1;
  else if ((mask & 0xC0000000) != 0xC0000000)
    {
      warning (_("The given mask covers kernel address space "
		 "and cannot be used.\n"));

      return -2;
    }
  else
    return 2;
}

static void
ppc_linux_store_inferior_registers (struct target_ops *ops,
				    struct regcache *regcache, int regno)
{
  /* Overload thread id onto process id.  */
  int tid = ptid_get_lwp (inferior_ptid);

  /* No thread id, just use process id.  */
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid);

  if (regno >= 0)
    store_register (regcache, tid, regno);
  else
    store_ppc_registers (regcache, tid);
}

/* Functions for transferring registers between a gregset_t or fpregset_t
   (see sys/ucontext.h) and gdb's regcache.  The word size is that used
   by the ptrace interface, not the current program's ABI.  Eg. if a
   powerpc64-linux gdb is being used to debug a powerpc32-linux app, we
   read or write 64-bit gregsets.  This is to suit the host libthread_db.  */

void
supply_gregset (struct regcache *regcache, const gdb_gregset_t *gregsetp)
{
  const struct regset *regset = ppc_linux_gregset (sizeof (long));

  ppc_supply_gregset (regset, regcache, -1, gregsetp, sizeof (*gregsetp));
}

void
fill_gregset (const struct regcache *regcache,
	      gdb_gregset_t *gregsetp, int regno)
{
  const struct regset *regset = ppc_linux_gregset (sizeof (long));

  if (regno == -1)
    memset (gregsetp, 0, sizeof (*gregsetp));
  ppc_collect_gregset (regset, regcache, regno, gregsetp, sizeof (*gregsetp));
}

void
supply_fpregset (struct regcache *regcache, const gdb_fpregset_t * fpregsetp)
{
  const struct regset *regset = ppc_linux_fpregset ();

  ppc_supply_fpregset (regset, regcache, -1,
		       fpregsetp, sizeof (*fpregsetp));
}

void
fill_fpregset (const struct regcache *regcache,
	       gdb_fpregset_t *fpregsetp, int regno)
{
  const struct regset *regset = ppc_linux_fpregset ();

  ppc_collect_fpregset (regset, regcache, regno,
			fpregsetp, sizeof (*fpregsetp));
}

static int
ppc_linux_target_wordsize (void)
{
  int wordsize = 4;

  /* Check for 64-bit inferior process.  This is the case when the host is
     64-bit, and in addition the top bit of the MSR register is set.  */
#ifdef __powerpc64__
  long msr;

  int tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid);

  errno = 0;
  msr = (long) ptrace (PTRACE_PEEKUSER, tid, PT_MSR * 8, 0);
  if (errno == 0 && msr < 0)
    wordsize = 8;
#endif

  return wordsize;
}

static int
ppc_linux_auxv_parse (struct target_ops *ops, gdb_byte **readptr,
                      gdb_byte *endptr, CORE_ADDR *typep, CORE_ADDR *valp)
{
  int sizeof_auxv_field = ppc_linux_target_wordsize ();
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  gdb_byte *ptr = *readptr;

  if (endptr == ptr)
    return 0;

  if (endptr - ptr < sizeof_auxv_field * 2)
    return -1;

  *typep = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);
  ptr += sizeof_auxv_field;
  *valp = extract_unsigned_integer (ptr, sizeof_auxv_field, byte_order);
  ptr += sizeof_auxv_field;

  *readptr = ptr;
  return 1;
}

static const struct target_desc *
ppc_linux_read_description (struct target_ops *ops)
{
  int altivec = 0;
  int vsx = 0;
  int isa205 = 0;
  int cell = 0;

  int tid = ptid_get_lwp (inferior_ptid);
  if (tid == 0)
    tid = ptid_get_pid (inferior_ptid);

  if (have_ptrace_getsetevrregs)
    {
      struct gdb_evrregset_t evrregset;

      if (ptrace (PTRACE_GETEVRREGS, tid, 0, &evrregset) >= 0)
        return tdesc_powerpc_e500l;

      /* EIO means that the PTRACE_GETEVRREGS request isn't supported.
	 Anything else needs to be reported.  */
      else if (errno != EIO)
	perror_with_name (_("Unable to fetch SPE registers"));
    }

  if (have_ptrace_getsetvsxregs)
    {
      gdb_vsxregset_t vsxregset;

      if (ptrace (PTRACE_GETVSXREGS, tid, 0, &vsxregset) >= 0)
	vsx = 1;

      /* EIO means that the PTRACE_GETVSXREGS request isn't supported.
	 Anything else needs to be reported.  */
      else if (errno != EIO)
	perror_with_name (_("Unable to fetch VSX registers"));
    }

  if (have_ptrace_getvrregs)
    {
      gdb_vrregset_t vrregset;

      if (ptrace (PTRACE_GETVRREGS, tid, 0, &vrregset) >= 0)
        altivec = 1;

      /* EIO means that the PTRACE_GETVRREGS request isn't supported.
	 Anything else needs to be reported.  */
      else if (errno != EIO)
	perror_with_name (_("Unable to fetch AltiVec registers"));
    }

  /* Power ISA 2.05 (implemented by Power 6 and newer processors) increases
     the FPSCR from 32 bits to 64 bits.  Even though Power 7 supports this
     ISA version, it doesn't have PPC_FEATURE_ARCH_2_05 set, only
     PPC_FEATURE_ARCH_2_06.  Since for now the only bits used in the higher
     half of the register are for Decimal Floating Point, we check if that
     feature is available to decide the size of the FPSCR.  */
  if (ppc_linux_get_hwcap () & PPC_FEATURE_HAS_DFP)
    isa205 = 1;

  if (ppc_linux_get_hwcap () & PPC_FEATURE_CELL)
    cell = 1;

  if (ppc_linux_target_wordsize () == 8)
    {
      if (cell)
	return tdesc_powerpc_cell64l;
      else if (vsx)
	return isa205? tdesc_powerpc_isa205_vsx64l : tdesc_powerpc_vsx64l;
      else if (altivec)
	return isa205
	  ? tdesc_powerpc_isa205_altivec64l : tdesc_powerpc_altivec64l;

      return isa205? tdesc_powerpc_isa205_64l : tdesc_powerpc_64l;
    }

  if (cell)
    return tdesc_powerpc_cell32l;
  else if (vsx)
    return isa205? tdesc_powerpc_isa205_vsx32l : tdesc_powerpc_vsx32l;
  else if (altivec)
    return isa205? tdesc_powerpc_isa205_altivec32l : tdesc_powerpc_altivec32l;

  return isa205? tdesc_powerpc_isa205_32l : tdesc_powerpc_32l;
}

void _initialize_ppc_linux_nat (void);

void
_initialize_ppc_linux_nat (void)
{
  struct target_ops *t;

  /* Fill in the generic GNU/Linux methods.  */
  t = linux_target ();

  /* Add our register access methods.  */
  t->to_fetch_registers = ppc_linux_fetch_inferior_registers;
  t->to_store_registers = ppc_linux_store_inferior_registers;

  /* Add our breakpoint/watchpoint methods.  */
  t->to_can_use_hw_breakpoint = ppc_linux_can_use_hw_breakpoint;
  t->to_insert_hw_breakpoint = ppc_linux_insert_hw_breakpoint;
  t->to_remove_hw_breakpoint = ppc_linux_remove_hw_breakpoint;
  t->to_region_ok_for_hw_watchpoint = ppc_linux_region_ok_for_hw_watchpoint;
  t->to_insert_watchpoint = ppc_linux_insert_watchpoint;
  t->to_remove_watchpoint = ppc_linux_remove_watchpoint;
  t->to_insert_mask_watchpoint = ppc_linux_insert_mask_watchpoint;
  t->to_remove_mask_watchpoint = ppc_linux_remove_mask_watchpoint;
  t->to_stopped_by_watchpoint = ppc_linux_stopped_by_watchpoint;
  t->to_stopped_data_address = ppc_linux_stopped_data_address;
  t->to_watchpoint_addr_within_range = ppc_linux_watchpoint_addr_within_range;
  t->to_can_accel_watchpoint_condition
    = ppc_linux_can_accel_watchpoint_condition;
  t->to_masked_watch_num_registers = ppc_linux_masked_watch_num_registers;
  t->to_ranged_break_num_registers = ppc_linux_ranged_break_num_registers;

  t->to_read_description = ppc_linux_read_description;
  t->to_auxv_parse = ppc_linux_auxv_parse;

  observer_attach_thread_exit (ppc_linux_thread_exit);

  /* Register the target.  */
  linux_nat_add_target (t);
  linux_nat_set_new_thread (t, ppc_linux_new_thread);
}
@


1.124
log
@fix PR symtab/15719

This patch fixes PR symtab/15719.

The bug is that "watch -location" crashes on a certain expression.

The problem is that fetch_subexp_value is catching an exception.
For ordinary watchpoints this is ok; but for location watchpoints,
it is better for the exception to propagate.

Built and regtested on x86-64 Fedora 18.
New test case included.

	PR symtab/15719:
	* breakpoint.c (update_watchpoint, watchpoint_check)
	(watch_command_1): Update.
	* eval.c (fetch_subexp_value): Add "preserve_errors"
	parameter.
	* ppc-linux-nat.c (check_condition): Update.
	* value.h (fetch_subexp_value): Update.

	* gdb.base/watchpoint.c (struct foo5): New.
	(nullptr): New global.
	* gdb.base/watchpoint.exp (test_watch_location): Add test.
@
text
@d867 1
a867 1
  int tid = TIDGET (inferior_ptid);
d871 1
a871 1
    tid = PIDGET (inferior_ptid);
d1420 1
a1420 1
      tid = TIDGET (inferior_ptid);
d1422 1
a1422 1
	tid = PIDGET (inferior_ptid);
d1487 1
a1487 1
      tid = TIDGET (ptid);
d1489 1
a1489 1
	tid = PIDGET (ptid);
d1705 1
a1705 1
    hwdebug_insert_point (&p, TIDGET (lp->ptid));
d1741 1
a1741 1
    hwdebug_remove_point (&p, TIDGET (lp->ptid));
d1784 1
a1784 1
    hwdebug_insert_point (&p, TIDGET (lp->ptid));
d1812 1
a1812 1
    hwdebug_remove_point (&p, TIDGET (lp->ptid));
d1822 1
a1822 1
  int tid = TIDGET (inferior_ptid);
d2089 1
a2089 1
	hwdebug_insert_point (&p, TIDGET (lp->ptid));
d2133 1
a2133 1
	if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (lp->ptid), 0,
d2157 1
a2157 1
	hwdebug_remove_point (&p, TIDGET (lp->ptid));
d2165 1
a2165 1
	if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (lp->ptid), 0,
d2178 1
a2178 1
  int tid = TIDGET (lp->ptid);
d2217 1
a2217 1
  int tid = TIDGET (tp->ptid);
d2266 1
a2266 1
      t = hwdebug_find_thread_points_by_tid (TIDGET (inferior_ptid), 0);
d2338 1
a2338 1
  int tid = TIDGET (inferior_ptid);
d2342 1
a2342 1
    tid = PIDGET (inferior_ptid);
d2404 1
a2404 1
  int tid = TIDGET (inferior_ptid);
d2406 1
a2406 1
    tid = PIDGET (inferior_ptid);
d2448 1
a2448 1
  int tid = TIDGET (inferior_ptid);
d2450 1
a2450 1
    tid = PIDGET (inferior_ptid);
@


1.123
log
@2013-07-22  Edjunior Barbosa Machado  <emachado@@linux.vnet.ibm.com>

	* ppc-linux-nat.c (PPC_DEBUG_FEATURE_DATA_BP_DAWR): New define.
	(ppc_linux_region_ok_for_hw_watchpoint): Add checking to use the new
	DAWR interface for longer ranges hardware watchpoint (up to 512 bytes).
@
text
@d1955 1
a1955 1
  fetch_subexp_value (cond, &pc, &left_val, NULL, &left_chain);
d1965 1
a1965 1
  fetch_subexp_value (cond, &pc, &right_val, NULL, &right_chain);
@


1.122
log
@2013-07-15  Edjunior Barbosa Machado  <emachado@@linux.vnet.ibm.com>

	* ppc-linux-nat.c: Since the new PowerPC specific ptrace interface is
	now available for embedded (BookE) and server (BookS) processors,
	correct mentions of 'booke' and adjust comments accordingly in order to
	avoid confusion. Rename struct 'booke_debug_info' to 'hwdebug_info'.
	(have_ptrace_booke_interface): Rename function and variable
	'have_ptrace_booke_interface' to 'have_ptrace_hwdebug_interface'.
	Rename struct 'booke_debug_info' to 'hwdebug_info'. Update all uses.
	(booke_cmp_hw_point): Rename function 'booke_cmp_hw_point' to
	'hwdebug_point_cmp'. Update all uses.
	(booke_find_thread_points_by_tid): Rename function
	'booke_find_thread_points_by_tid' to
	'hwdebug_find_thread_points_by_tid'. Update all uses.
	(booke_insert_point): Rename function 'booke_insert_point' to
	'hwdebug_insert_point'. Update all uses.
	(booke_remove_point): Rename function 'booke_remove_point' to
	'hwdebug_remove_point'. Update all uses.
@
text
@d180 5
a184 1

d1511 1
d1520 7
d1529 2
a1530 3
      if (hwdebug_info.data_bp_alignment
	  && (addr + len > (addr & ~(hwdebug_info.data_bp_alignment - 1))
	      + hwdebug_info.data_bp_alignment))
@


1.121
log
@Normalize on PATH_MAX instead of MAXPATHLEN throughout.

With the pathmax gnulib module in place, we can use PATH_MAX
consistently throughout, instead of the current mixbag of PATH_MAX and
MAXPATHLEN uses.  It's no longer necessary to include sys/param.h
(supposedly, I can't check all ports touched here) for MAXPATHLEN.

Don't remove sys/param.h from GDB's configure.ac, as later tests in
the file use HAVE_SYS_PARAM_H checks.

Tested on x86_64 Fedora 17.

Also cross-built for --host=i686-w64-mingw32, and --host=i586-pc-msdosdjgpp.

gdb/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* defs.h: Include "pathmax.h".
	* utils.c: Don't include sys/param.h.
	(gdb_realpath): Remove code that checks for MAXPATHLEN.
	* solib-ia64-hpux.c (ia64_hpux_handle_load_event): Use PATH_MAX
	instead of MAXPATHLEN.
	* solib-sunos.c: Don't include sys/param.h.
	* xcoffread.c: Don't include sys/param.h.
	* bsd-kvm.c: Don't include sys/param.h.
	* darwin-nat.c: Don't include sys/param.h.
	(darwin_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* darwin-nat-info.c: Don't include sys/param.h.
	* fbsd-nat.c (fbsd_pid_to_exec_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* i386obsd-nat.c: Don't include sys/param.h.
	* inf-child.c: Don't include sys/param.h.
	(inf_child_fileio_readlink): Use PATH_MAX instead of MAXPATHLEN.
	* linux-fork.c: Don't include sys/param.h.
	(fork_save_infrun_state): Use PATH_MAX instead of MAXPATHLEN.
	* linux-nat.c: Don't include sys/param.h.
	(linux_child_pid_to_exec_file, linux_proc_pending_signals)
	(linux_proc_pending_signals): Use PATH_MAX instead of MAXPATHLEN.
	* m68klinux-nat.c: Don't include sys/param.h.
	* nbsd-nat.c: Don't include sys/param.h.
	(nbsd_pid_to_exec_file): Use PATH_MAX instead of MAXPATHLEN.
	* ppc-linux-nat.c: Don't include sys/param.h.
	* rs6000-nat.c: Don't include sys/param.h.
	* spu-linux-nat.c. Don't include sys/param.h.
	* windows-nat.c: Don't include sys/param.h.
	* xtensa-linux-nat.c: Don't include sys/param.h.
	* config/i386/nm-fbsd.h: Don't include sys/param.h.

gdb/gdbserver/
2013-07-01  Pedro Alves  <palves@@redhat.com>

	* server.h: Include "pathmax.h".
	* linux-low.c: Don't include sys/param.h.
	(linux_pid_exe_is_elf_64_file): Use PATH_MAX instead of
	MAXPATHLEN.
	* win32-low.c: Don't include sys/param.h.
	(win32_create_inferior): Use PATH_MAX instead of MAXPATHLEN.
@
text
@d104 1
a104 1
   when the BookE kernel interface is not available.  */
d115 4
a118 4
/* These requests are used when the BookE kernel interface is available.
   It exposes the additional debug features of BookE processors, such as
   ranged breakpoints and watchpoints and hardware-accelerated condition
   evaluation.  */
d121 3
a123 3
/* Not having PPC_PTRACE_GETHWDBGINFO defined means that the new BookE
   interface is not present in ptrace.h, so we'll have to pretty much include
   it all here so that the code at least compiles on older systems.  */
d1364 2
a1365 2
   This variable is used when we are dealing with non-BookE
   processors.  */
d1369 2
a1370 2
   features on this BookE processor.  */
static struct ppc_debug_info booke_debug_info;
d1373 2
a1374 1
   kernel will use.  This is only used when the processor is BookE.  */
d1384 2
a1385 1
   for each thread.  This is used for BookE processors.  */
d1402 2
a1403 2
/* The version of the kernel interface that we will use if the processor is
   BookE.  */
d1406 1
a1406 2
/* Returns non-zero if we support the ptrace interface which enables
   booke debugging resources.  */
d1408 1
a1408 1
have_ptrace_booke_interface (void)
d1410 1
a1410 1
  static int have_ptrace_booke_interface = -1;
d1412 1
a1412 1
  if (have_ptrace_booke_interface == -1)
d1420 2
a1421 2
      /* Check for kernel support for BOOKE debug registers.  */
      if (ptrace (PPC_PTRACE_GETHWDBGINFO, tid, 0, &booke_debug_info) >= 0)
d1423 1
a1423 1
	  /* Check whether ptrace BOOKE interface is functional and
d1425 1
a1425 1
	  if (booke_debug_info.features != 0)
d1427 5
a1431 5
	      have_ptrace_booke_interface = 1;
	      max_slots_number = booke_debug_info.num_instruction_bps
	        + booke_debug_info.num_data_bps
	        + booke_debug_info.num_condition_regs;
	      return have_ptrace_booke_interface;
d1434 3
a1436 3
      /* Old school interface and no BOOKE debug registers support.  */
      have_ptrace_booke_interface = 0;
      memset (&booke_debug_info, 0, sizeof (struct ppc_debug_info));
d1439 1
a1439 1
  return have_ptrace_booke_interface;
d1447 1
a1447 1
  if (have_ptrace_booke_interface ())
d1449 5
a1453 5
      /* For PPC BookE processors, the number of available hardware
         watchpoints and breakpoints is stored at the booke_debug_info
	 struct.  */
      total_hw_bp = booke_debug_info.num_instruction_bps;
      total_hw_wp = booke_debug_info.num_data_bps;
d1457 2
a1458 2
      /* For PPC server processors, we accept 1 hardware watchpoint and 0
	 hardware breakpoints.  */
d1475 1
a1475 1
  if (!have_ptrace_booke_interface ())
d1501 5
a1505 4
  /* The new BookE ptrace interface tells if there are alignment restrictions
     for watchpoints in the processors.  In that case, we use that information
     to determine the hardcoded watchable region for watchpoints.  */
  if (have_ptrace_booke_interface ())
d1512 1
a1512 1
	  && booke_debug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE
d1517 3
a1519 3
      if (booke_debug_info.data_bp_alignment
	  && (addr + len > (addr & ~(booke_debug_info.data_bp_alignment - 1))
	      + booke_debug_info.data_bp_alignment))
d1523 3
a1525 3
     processors (i.e., server processors).  Without the new BookE ptrace
     interface, DAC-based processors (i.e., embedded processors) will use
     addresses aligned to 4-bytes due to the way the read/write flags are
d1537 1
a1537 1
booke_cmp_hw_point (struct ppc_hw_breakpoint *a, struct ppc_hw_breakpoint *b)
d1552 1
a1552 1
booke_find_thread_points_by_tid (int tid, int alloc_new)
d1581 1
a1581 1
booke_insert_point (struct ppc_hw_breakpoint *b, int tid)
d1599 1
a1599 1
  t = booke_find_thread_points_by_tid (tid, 1);
d1621 1
a1621 1
booke_remove_point (struct ppc_hw_breakpoint *b, int tid)
d1627 1
a1627 1
  t = booke_find_thread_points_by_tid (tid, 0);
d1632 1
a1632 1
    if (hw_breaks[i].hw_break && booke_cmp_hw_point (hw_breaks[i].hw_break, b))
d1655 2
a1656 2
  return ((have_ptrace_booke_interface ()
	   && booke_debug_info.features & PPC_DEBUG_FEATURE_INSN_BP_RANGE)?
d1670 1
a1670 1
  if (!have_ptrace_booke_interface ())
d1694 1
a1694 1
    booke_insert_point (&p, TIDGET (lp->ptid));
d1706 1
a1706 1
  if (!have_ptrace_booke_interface ())
d1730 1
a1730 1
    booke_remove_point (&p, TIDGET (lp->ptid));
d1762 1
a1762 1
  gdb_assert (have_ptrace_booke_interface ());
d1773 1
a1773 1
    booke_insert_point (&p, TIDGET (lp->ptid));
d1790 1
a1790 1
  gdb_assert (have_ptrace_booke_interface ());
d1801 1
a1801 1
    booke_remove_point (&p, TIDGET (lp->ptid));
d1812 1
a1812 1
  int cnt = booke_debug_info.num_condition_regs, i;
d1815 1
a1815 1
  if (!have_ptrace_booke_interface () || cnt == 0)
d1818 1
a1818 1
  p = booke_find_thread_points_by_tid (tid, 0);
d1857 1
a1857 1
  align_offset = addr % booke_debug_info.sizeof_condition;
d1860 1
a1860 1
		  + booke_debug_info.sizeof_condition);
d2008 2
a2009 2
  return (have_ptrace_booke_interface ()
	  && booke_debug_info.num_condition_regs > 0
d2024 1
a2024 1
      || !(booke_debug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE))
d2030 1
a2030 1
			: booke_debug_info.num_condition_regs > 0);
d2071 1
a2071 1
  if (have_ptrace_booke_interface ())
d2078 1
a2078 1
	booke_insert_point (&p, TIDGET (lp->ptid));
d2139 1
a2139 1
  if (have_ptrace_booke_interface ())
d2146 1
a2146 1
	booke_remove_point (&p, TIDGET (lp->ptid));
d2169 1
a2169 1
  if (have_ptrace_booke_interface ())
d2195 1
a2195 1
	    booke_insert_point (hw_breaks[i].hw_break, tid);
d2210 1
a2210 1
  if (!have_ptrace_booke_interface ())
d2247 1
a2247 1
  if (have_ptrace_booke_interface ())
d2255 1
a2255 1
      t = booke_find_thread_points_by_tid (TIDGET (inferior_ptid), 0);
d2288 1
a2288 1
  if (have_ptrace_booke_interface ()
d2308 2
a2309 2
  if (!have_ptrace_booke_interface ()
	   || (booke_debug_info.features & PPC_DEBUG_FEATURE_DATA_BP_MASK) == 0)
@


1.120
log
@2013-05-17  Edjunior Machado  <emachado@@linux.vnet.ibm.com>

	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint): Check if the
	region is ok for a hardware watchpoint using the new ptrace interface
	on Power servers.
@
text
@a33 1
#include <sys/param.h>
@


1.119
log
@	gdb/
	* ppc-linux-nat.c (ppc_linux_new_thread): Clear the new thread's
	debug state prior to replicating existing hardware watchpoints or
	breakpoints.

	gdb/testsuite/
	* gdb.threads/wp-replication.c: New file.
	* gdb.threads/wp-replication.exp: New file.
@
text
@d1506 4
a1509 4
      /* DAC-based processors (i.e., embedded processors), like the PowerPC 440
	 have ranged watchpoints and can watch any access within an arbitrary
	 memory region.  This is useful to watch arrays and structs, for
	 instance.  It takes two hardware watchpoints though.  */
d1511 2
a1512 1
	  && booke_debug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE)
d1514 5
a1518 3
      else if (booke_debug_info.data_bp_alignment
	       && (addr + len > (addr & ~(booke_debug_info.data_bp_alignment - 1))
		   + booke_debug_info.data_bp_alignment))
@


1.118
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d2181 12
a2192 1
	  booke_insert_point (hw_breaks[i].hw_break, tid);
@


1.117
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d550 1
a550 1
  char buf[MAX_REGISTER_SIZE];
d1037 1
a1037 1
  char buf[MAX_REGISTER_SIZE];
@


1.116
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d3 1
a3 2
   Copyright (C) 1988-1989, 1991-1992, 1994, 1996, 2000-2012 Free
   Software Foundation, Inc.
@


1.115
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d604 2
a605 2
	  sprintf (message, "reading register %s (#%d)", 
		   gdbarch_register_name (gdbarch, regno), regno);
d1098 2
a1099 2
	  sprintf (message, "writing register %s (#%d)", 
		   gdbarch_register_name (gdbarch, regno), regno);
@


1.114
log
@gdb/
	Code cleanup for the next patch.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Change variable
	siginfo_p to siginfo, update its users incl. the linux_nat_get_siginfo
	call for it.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	(ia64_linux_stopped_data_address):
	* linux-nat.c (linux_nat_get_siginfo): Add parameter siginfo, change
	the return value.
	* linux-nat.h (linux_nat_get_siginfo): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Change variable
	siginfo_p to siginfo, update its users incl. the linux_nat_get_siginfo
	call for it.
@
text
@d2397 1
a2397 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
@


1.113
log
@* ppc-linux-nat.c (have_ptrace_booke_interface): Disable ptrace
BookE interface for PowerPC server processors if not available
in the Linux Kernel.
@
text
@d2224 1
a2224 1
  siginfo_t *siginfo_p;
d2226 2
a2227 1
  siginfo_p = linux_nat_get_siginfo (inferior_ptid);
d2229 2
a2230 2
  if (siginfo_p->si_signo != SIGTRAP
      || (siginfo_p->si_code & 0xffff) != 0x0004 /* TRAP_HWBKPT */)
d2239 1
a2239 1
      int slot = siginfo_p->si_errno;
d2256 1
a2256 1
  *addr_p = (CORE_ADDR) (uintptr_t) siginfo_p->si_addr;
@


1.112
log
@* ppc-linux-nat.c (ppc_linux_can_use_hw_breakpoint): fix
accounting of hw watchpoints on ppc.
@
text
@d1424 10
a1433 10
	  have_ptrace_booke_interface = 1;
	  max_slots_number = booke_debug_info.num_instruction_bps
	    + booke_debug_info.num_data_bps
	    + booke_debug_info.num_condition_regs;
	}
      else
	{
	  /* Old school interface and no BOOKE debug registers support.  */
	  have_ptrace_booke_interface = 0;
	  memset (&booke_debug_info, 0, sizeof (struct ppc_debug_info));
d1435 3
@


1.111
log
@struct siginfo vs. siginfo_t

gdb/
	* amd64-linux-nat.c (amd64_linux_siginfo_fixup): Use siginfo_t instead
	of struct siginfo.
	* arm-linux-nat.c (arm_linux_stopped_data_address): Likewise.
	* ia64-linux-nat.c (ia64_linux_stopped_data_address): Likewise.
	* linux-nat.c (linux_nat_siginfo_fixup, siginfo_fixup)
	(linux_xfer_siginfo, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-nat.h (struct lwp_info, linux_nat_set_siginfo_fixup)
	(linux_nat_get_siginfo): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Likewise.
	* procfs.c (gdb_siginfo_t): Likewise.

gdbserver/
	* linux-arm-low.c (arm_stopped_by_watchpoint): Use siginfo_t instead of
	struct siginfo.
	* linux-low.c (siginfo_fixup, linux_xfer_siginfo): Likewise.
	* linux-x86-low.c (x86_siginfo_fixup): Likewise.
	* linux-low.h: Include <signal.h>.
	(struct siginfo): Remove forward declaration.
	(struct linux_target_ops) <siginfo_fixup>: Use siginfo_t instead of
	struct siginfo.
@
text
@d1464 1
a1464 1
      if (cnt > total_hw_wp)
@


1.110
log
@	Fix -Wmissing-prototypes build.
	* ppc-linux-nat.c (ppc_linux_get_hwcap): Make static.
	* remote-sim.c (gdbsim_has_all_memory): Likewise.
	(gdbsim_has_memory): Likewise.
@
text
@d2221 1
a2221 1
  struct siginfo *siginfo_p;
@


1.109
log
@gdb/
	* ppc-linux-nat.c (fetch_register, store_register): Fix GCC aliasing
	compilation warning.
@
text
@d1354 2
a1355 1
unsigned long ppc_linux_get_hwcap (void)
@


1.108
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d596 2
d599 1
a599 2
      *(long *) &buf[bytes_transferred]
        = ptrace (PTRACE_PEEKUSER, tid, (PTRACE_TYPE_ARG3) regaddr, 0);
d608 1
d1078 3
d1082 1
a1082 2
      ptrace (PTRACE_POKEUSER, tid, (PTRACE_TYPE_ARG3) regaddr,
	      *(long *) &buf[i]);
@


1.107
log
@* ppc-linux-nat.c (create_watchpoint_request): Only use ranged
watchpoints when supported.
@
text
@d3 2
a4 3
   Copyright (C) 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.106
log
@gdb/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* linux-nat.c (linux_nat_new_thread): Change parameter to an lwp
	pointer.
	(linux_nat_prepare_to_resume): New global.
	(lwp_free): New.
	(purge_lwp_list): Use it.
	(add_lwp): Call linux_nat_new_thread even on the first LWP.
	Adjust to interface change.
	(delete_lwp): Call lwp_free instead of xfree.
	(detach_callback, linux_nat_detach, resume_lwp, linux_nat_resume)
	(linux_handle_syscall_trap, linux_handle_extended_wait)
	(linux_nat_filter_event, resume_stopped_resumed_lwps): Call
	linux_nat_prepare_to_resume before resuming.
	(linux_stop_lwp): New.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.
	* linux-nat.h (struct arch_lwp_info): Forward declare.
	(struct lwp_info) <arch_private>: New field.
	(linux_stop_lwp): Declare.
	(linux_nat_set_new_thread): Adjust.
	(linux_nat_set_prepare_to_resume): New.

	* i386-nat.c (DR_NADDR, DR_STATUS, DR_CONTROL)
	(struct i386_debug_reg_state): Move to i386-nat.h.
	(dr_mirror): Comment.
	(i386_debug_reg_state): New.
	(i386_update_inferior_debug_regs): Simplify.
	(i386_stopped_data_address): Use the debug register state from the
	inferior, not from the local cache.
	* i386-nat.h (struct i386_dr_low_type): Delete reset_addr and
	unset_status fields.  New get_addr and get_control fields.
	(DR_FIRSTADDR, DR_LASTADDR, DR_CONTROL): Moved from i386-nat.c.
	(DR_NADDR, DR_STATUS): New.
	(struct i386_debug_reg_state): Moved from i386-nat.c.

	* amd64-linux-nat.c (struct arch_lwp_info): New.
	(amd64_linux_dr): Delete global.
	(amd64_linux_dr_get_addr): New.
	(amd64_linux_dr_get_control): New.
	(amd64_linux_dr_unset_status): Delete.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_dr_reset_addr): Delete.
	(update_debug_registers_callback): New.
	(amd64_linux_dr_set_control): Reimplement.
	(amd64_linux_dr_set_addr): Reimplement.
	(amd64_linux_prepare_to_resume): New.
	(amd64_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_amd64_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	amd64_linux_dr_get_control as i386_dr_low.get_control.  Install
	amd64_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	amd64_linux_prepare_to_resume.
	* i386-linux-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(struct arch_lwp_info): New.
	(i386_linux_dr): Delete global.
	(i386_linux_dr_set_control): Reimplement.
	(i386_linux_dr_get_addr): New.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_dr_get_control): New.
	(update_debug_registers_callback): New.
	(i386_linux_dr_unset_status): Delete.
	(i386_linux_dr_set_addr): Reimplement.
	(i386_linux_prepare_to_resume): New.
	(i386_linux_new_thread): Change parameter to an lwp pointer.
	Reimplement.
	(_initialize_i386_linux_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386_linux_dr_get_control as i386_dr_low.get_control.  Install
	i386_linux_dr_get_addr as i386_dr_low.get_addr.  Install
	i386_linux_prepare_to_resume.

	* arm-linux-nat.c (arm_linux_new_thread): Change parameter to an
	lwp pointer.  Adjust.
	* ia64-linux-nat.c (ia64_linux_new_thread): Likewise.
	* mips-linux-nat.c (mips_linux_new_thread): Likewise.
	* ppc-linux-nat.c (ppc_linux_new_thread): Likewise.
	* s390-nat.c (s390_fix_watch_points): Likewise.

	* i386-darwin-nat.c (DR_FIRSTADDR, DR_LASTADDR, DR_STATUS)
	(DR_CONTROL): Delete.
	(i386_darwin_dr_reset_addr): Delete.
	(i386_darwin_dr_get_addr): New.
	(i386_darwin_dr_get_control): New.
	* go32-nat.c
	(go32_get_dr7, go32_get_dr): New.
	(init_go32_ops): No longer install i386_dr_low.reset_addr.
	Install go32_get_dr7 as i386_dr_low.get_control.  Install
	go32_get_dr as i386_dr_low.get_addr.
	* i386bsd-nat.c (i386bsd_dr_get): New.
	(i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_status): Use i386bsd_dr_get.
	(i386bsd_dr_get_control): New.
	* i386bsd-nat.h (i386bsd_dr_reset_addr): Delete.
	(i386bsd_dr_get_addr): New.
	(i386bsd_dr_get_control): New.
	* i386fbsd-nat.c (_initialize_i386fbsd_nat): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	i386bsd_dr_get_control as i386_dr_low.get_control.  Install
	i386bsd_dr_get_addr as i386_dr_low.get_addr.
	* windows-nat.c (init_windows_ops): No longer install
	i386_dr_low.reset_addr and i386_dr_low.unset_status.  Install
	cygwin_get_dr7 as i386_dr_low.get_control.  Install cygwin_get_dr
	as i386_dr_low.get_addr.
	(cygwin_get_dr): New.
	(cygwin_get_dr7): New.

gdb/testsuite/
2011-12-14  Pedro Alves  <pedro@@codesourcery.com>

	PR threads/10729

	* gdb.mi/watch-nonstop.c: New file.
 	* gdb.mi/mi-watch-nonstop.exp: New file.
@
text
@d2013 2
a2014 1
  if (len == 1)
@


1.105
log
@2011-10-07  Pedro Alves  <pedro@@codesourcery.com>

	* linux-nat.h (ALL_LWPS): Remove the ptid parameter.
	* amd64-linux-nat.c (amd64_linux_dr_set_control)
	(amd64_linux_dr_set_addr, amd64_linux_dr_unset_status): Adjust.
	* arm-linux-nat.c (arm_linux_insert_hw_breakpoint)
	(arm_linux_remove_hw_breakpoint, arm_linux_insert_watchpoint)
	(arm_linux_remove_watchpoint): Adjust.
	* i386-linux-nat.c (i386_linux_dr_set_control)
	(i386_linux_dr_set_addr, i386_linux_dr_unset_status): Adjust.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint)
	(ia64_linux_remove_watchpoint): Adjust.
	* mips-linux-nat.c (write_watchpoint_regs): Adjust.
	* ppc-linux-nat.c (ppc_linux_insert_hw_breakpoint)
	(ppc_linux_insert_hw_breakpoint, ppc_linux_remove_hw_breakpoint)
	(ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint, ppc_linux_insert_watchpoint)
	(ppc_linux_remove_watchpoint): Adjust.
	* s390-nat.c (s390_insert_watchpoint, s390_remove_watchpoint):
	Adjust.
@
text
@d2154 1
a2154 1
ppc_linux_new_thread (ptid_t ptid)
d2156 1
a2156 1
  int tid = TIDGET (ptid);
@


1.105.2.1
log
@* ppc-linux-nat.c (create_watchpoint_request): Only use ranged
watchpoints when supported.
@
text
@d2013 1
a2013 2
  if (len == 1
      || !(booke_debug_info.features & PPC_DEBUG_FEATURE_DATA_BP_RANGE))
@


1.105.2.2
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1988-1989, 1991-1992, 1994, 1996, 2000-2012 Free
   Software Foundation, Inc.
@


1.104
log
@2011-05-06  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE masked watchpoints.

gdb/
	* NEWS: Mention masked watchpoint support.  Create "Changed commands"
	section.
	* breakpoint.h (struct breakpoint_ops) <works_in_software_mode>: New
	method.  Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <hw_wp_mask>: New field.
	* breakpoint.c (is_masked_watchpoint): Add prototype.
	(update_watchpoint): Don't set b->val for masked watchpoints.  Call
	breakpoint's breakpoint_ops.works_in_software_mode if available.
	(watchpoints_triggered): Handle the case of a hardware masked
	watchpoint trigger.
	(watchpoint_check): Likewise.
	(works_in_software_mode_watchpoint): New function.
	(insert_masked_watchpoint, remove_masked_watchpoint)
	(resources_needed_masked_watchpoint)
	(works_in_software_mode_masked_watchpoint, print_it_masked_watchpoint)
	(print_one_detail_masked_watchpoint, print_mention_masked_watchpoint)
	(print_recreate_masked_watchpoint, is_masked_watchpoint): New
	functions.
	(masked_watchpoint_breakpoint_ops): New structure.
	(watch_command_1): Check for the existence of the `mask' parameter.
	Set b->ops according to the type of hardware watchpoint being created.
	* ppc-linux-nat.c (ppc_linux_insert_mask_watchpoint)
	(ppc_linux_remove_mask_watchpoint)
	(ppc_linux_masked_watch_num_registers): New functions.
	(_initialize_ppc_linux_nat): Initialize to_insert_mask_watchpoint,
	to_remove_mask_watchpoint and to_masked_watch_num_registers.
	* target.c (update_current_target): Mention to_insert_mask_watchpoint,
	to_remove_mask_watchpoint, and to_masked_watch_num_registers.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): New functions.
	* target.h (struct target_ops) <to_insert_mask_watchpoint>,
	<to_remove_mask_watchpoint>, <to_masked_watch_num_registers>: New
	methods.
	(target_insert_mask_watchpoint, target_remove_mask_watchpoint)
	(target_masked_watch_num_registers): Add prototypes.

gdb/doc/
	* gdb.texinfo (Set Watchpoints): Document mask parameter.
	(PowerPC Embedded): Mention support of masked watchpoints.
@
text
@a1656 1
  ptid_t ptid;
d1683 2
a1684 2
  ALL_LWPS (lp, ptid)
    booke_insert_point (&p, TIDGET (ptid));
a1692 1
  ptid_t ptid;
d1719 2
a1720 2
  ALL_LWPS (lp, ptid)
    booke_remove_point (&p, TIDGET (ptid));
a1748 1
  ptid_t ptid;
d1762 2
a1763 2
  ALL_LWPS (lp, ptid)
    booke_insert_point (&p, TIDGET (ptid));
a1776 1
  ptid_t ptid;
d1790 2
a1791 2
  ALL_LWPS (lp, ptid)
    booke_remove_point (&p, TIDGET (ptid));
a2057 1
  ptid_t ptid;
d2066 2
a2067 2
      ALL_LWPS (lp, ptid)
	booke_insert_point (&p, TIDGET (ptid));
d2110 2
a2111 2
      ALL_LWPS (lp, ptid)
	if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (ptid), 0,
a2125 1
  ptid_t ptid;
d2134 2
a2135 2
      ALL_LWPS (lp, ptid)
	booke_remove_point (&p, TIDGET (ptid));
d2142 2
a2143 2
      ALL_LWPS (lp, ptid)
	if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (ptid), 0,
@


1.103
log
@	* ppc-linux-nat.c (check_condition): Add len output parameter.
	Set it based on the memory region referenced in the condition
	expression.  Update all callers.
@
text
@d1742 58
d2285 20
d2519 2
d2526 1
@


1.102
log
@2011-03-31  Thiago Jung Bauermann  <bauerman@@br.ibm.com>
	    Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>

	Implement support for PowerPC BookE ranged breakpoints.

gdb/
	* NEWS: Mention support for ranged breakpoints on embedded PowerPC.
	* breakpoint.h (struct bp_target_info) <length>: New member
	variable.
	(struct breakpoint_ops) <breakpoint_hit>: Take struct bp_location
	instead of struct breakpoint as argument, and also add ASPACE
	and BP_ADDR arguments.  Update all callers.
	(struct breakpoint_ops) <print_one_detail>: New method.
	(struct breakpoint) <addr_string_range_end>: New member variable.
	* breakpoint.c (breakpoint_location_address_match): Add function
	prototype.
	(insert_bp_location): Set bl->target_info.length.
	(breakpoint_here_p): Call breakpoint_location_address_match.
	(moribund_breakpoint_here_p): Likewise.
	(regular_breakpoint_inserted_here_p): Likewise.
	(breakpoint_thread_match): Likewise.
	(bpstat_stop_status): Likewise.
	(bpstat_check_location): Move call to
	breakpoint_ops.breakpoint_hit to the top.
	(print_one_breakpoint_location): Call
	breakpoint_ops.print_one_detail if available.
	(breakpoint_address_match_range): New function.
	(breakpoint_location_address_match): Likewise.
	(breakpoint_locations_match): Compare the length field of the
	locations too.
	(hw_breakpoint_used_count): Count resources used by all locations
	in a breakpoint, and use breakpoint_ops.resources_needed if
	available.
	(breakpoint_hit_ranged_breakpoint): New function.
	(resources_needed_ranged_breakpoint): Likewise.
	(print_it_ranged_breakpoint): Likewise.
	(print_one_ranged_breakpoint): Likewise.
	(print_one_detail_ranged_breakpoint): Likewise.
	(print_mention_ranged_breakpoint): Likewise.
	(print_recreate_ranged_breakpoint): Likewise.
	(ranged_breakpoint_ops): New structure.
	(find_breakpoint_range_end): New function.
	(break_range_command): Likewise.
	(delete_breakpoint): Free addr_string_range_end.
	(update_breakpoint_locations): Add SALS_END argument.  Update
	all callers.  Calculate breakpoint length if a non-zero SALS_END
	is given.  Call breakpoint_locations_match instead of
	breakpoint_address_match.
	(reset_breakpoint): Find SaL of the end of the range if B is a
	ranged breakpoint.
	(_initialize_breakpoint): Register break-range command.
	* defs.h (print_core_address): Add function prototype.
	* ppc-linux-nat.c (ppc_linux_ranged_break_num_registers): New
	function.
	(ppc_linux_insert_hw_breakpoint): Support ranged breakpoints.
	(ppc_linux_remove_hw_breakpoint): Likewise.
	(_initialize_ppc_linux_nat): Initialize
	to_ranged_break_num_registers.
	* target.c (update_current_target): Add comment about
	to_ranged_break_num_registers.
	(target_ranged_break_num_registers): New function.
	* target.h (struct target_ops) <to_ranged_break_num_registers>:
	New method.
	(target_ranged_break_num_registers): Add function prototype.
	* ui-out.c (ui_out_field_core_addr): Move address-printing logic to ...
	* utils.c (print_core_address): ... here.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged breakpoints.
@
text
@d1868 2
a1869 1
   which the watch value should be compared.  */
d1872 1
a1872 1
		 CORE_ADDR *data_value)
d1904 7
a1910 1
    *data_value = value_as_long (right_val);
d1914 7
a1920 1
    *data_value = value_as_long (left_val);
d1946 1
a1946 1
	  && check_condition (addr, cond, &data_value));
d1966 2
a1967 1
      if (cond && use_condition && check_condition (addr, cond, &data_value))
@


1.102.2.1
log
@	* ppc-linux-nat.c (check_condition): Add len output parameter.
	Set it based on the memory region referenced in the condition
	expression.  Update all callers.
@
text
@d1868 1
a1868 2
   which the watch value should be compared and LEN will contain the size
   of the constant.  */
d1871 1
a1871 1
		 CORE_ADDR *data_value, int *len)
d1903 1
a1903 7
    {
      *data_value = value_as_long (right_val);

      /* DATA_VALUE is the constant in RIGHT_VAL, but actually has
	 the same type as the memory region referenced by LEFT_VAL.  */
      *len = TYPE_LENGTH (check_typedef (value_type (left_val)));
    }
d1907 1
a1907 7
    {
      *data_value = value_as_long (left_val);

      /* DATA_VALUE is the constant in LEFT_VAL, but actually has
	 the same type as the memory region referenced by RIGHT_VAL.  */
      *len = TYPE_LENGTH (check_typedef (value_type (right_val)));
    }
d1933 1
a1933 1
	  && check_condition (addr, cond, &data_value, &len));
d1953 1
a1953 2
      if (cond && use_condition && check_condition (addr, cond,
						    &data_value, &len))
@


1.101
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d1640 13
a1665 1
  p.addr_mode = PPC_BREAKPOINT_MODE_EXACT;
a1667 1
  p.addr2 = 0;
d1670 14
a1702 1
  p.addr_mode = PPC_BREAKPOINT_MODE_EXACT;
a1704 1
  p.addr2 = 0;
d1707 14
d2432 1
@


1.100
log
@2011-01-12  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* ppc-linux-nat.c (booke_cmp_hw_point): Fix whitespace.
	(ppc_linux_insert_hw_breakpoint): Likewise.
	(ppc_linux_remove_hw_breakpoint): Likewise.
	(ppc_linux_insert_watchpoint): Likewise.
@
text
@d267 1
a267 1
/* On PPC processors that support the the Signal Processing Extension
d278 1
a278 1
   of the gprs, and the the full 64-bit SIMD views of the registers,
@


1.99
log
@2011-01-11  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Implement support for PowerPC BookE ranged watchpoints.

gdb/
	* breakpoint.h
	(struct breakpoint_ops) <resources_needed>: New method.
	Initialize to NULL in all existing breakpoint_ops instances.
	(struct breakpoint) <exact>: New field.
	(target_exact_watchpoints): Declare external global.
	* breakpoint.c (target_exact_watchpoints): New global flag.
	(update_watchpoint): Set b->type to bp_hardware_watchpoint and
	b->enable_state to bp_enabled before calling
	hw_watchpoint_used_count.
	(hw_watchpoint_used_count): Iterate over all bp_locations in a
	watchpoint.  Call breakpoint's breakpoint_ops.resources_needed
	if available.
	(insert_watchpoint, remove_watchpoint): Use fixed length of 1 byte
	if the watchpoint is exact.
	(resources_needed_watchpoint): New function.
	(watchpoint_breakpoint_ops): Add resources_needed_watchpoint.
	(watch_command_1): Set b->exact if the user asked for an exact
	watchpoint and one can be set.
	(can_use_hardware_watchpoint): Add exact_watchpoints argument.
	Pass fixed length of 1 to target_region_ok_for_hw_watchpoint if
	the user asks for an exact watchpoint and one can be set.  Return
	number of needed debug registers to watch the expression.
	* gdbtypes.c (is_scalar_type): New function, based on
	valprint.c:scalar_type_p.
	(is_scalar_type_recursive): New function.
	* gdbtypes.h (is_scalar_type_recursive): Declare.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint): Always
	handle regions when ranged watchpoints are available.
	(create_watchpoint_request): New function.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	create_watchpoint_request.
	* rs6000-tdep.c (show_powerpc_exact_watchpoints): New function.
	(_initialize_rs6000_tdep): Add `exact-watchpoints' boolean to the
	`set powerpc' and `show powerpc' commands.
	* target.h (struct target_ops) <to_region_ok_for_hw_watchpoint>:
	Mention documentation comment in the target macro.
	(target_region_ok_for_hw_watchpoint): Document return value.

gdb/doc/
	* gdb.texinfo (PowerPC Embedded): Document ranged watchpoints and
	the "set powerpc exact-watchpoints" flag.
@
text
@d1529 5
a1533 5
  return (a->trigger_type       == b->trigger_type
	  && a->addr_mode       == b->addr_mode
	  && a->condition_mode  == b->condition_mode
	  && a->addr            == b->addr
	  && a->addr2           == b->addr2
d1651 6
a1656 6
  p.version         = PPC_DEBUG_CURRENT_VERSION;
  p.trigger_type    = PPC_BREAKPOINT_TRIGGER_EXECUTE;
  p.addr_mode       = PPC_BREAKPOINT_MODE_EXACT;
  p.condition_mode  = PPC_BREAKPOINT_CONDITION_NONE;
  p.addr            = (uint64_t) bp_tgt->placed_address;
  p.addr2           = 0;
d1676 6
a1681 6
  p.version         = PPC_DEBUG_CURRENT_VERSION;
  p.trigger_type    = PPC_BREAKPOINT_TRIGGER_EXECUTE;
  p.addr_mode       = PPC_BREAKPOINT_MODE_EXACT;
  p.condition_mode  = PPC_BREAKPOINT_CONDITION_NONE;
  p.addr            = (uint64_t) bp_tgt->placed_address;
  p.addr2           = 0;
d1976 1
a1976 1
	  read_mode  = 1;
d1983 1
a1983 1
	  read_mode  = 5;
@


1.98
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d1500 10
a1509 3
      if (booke_debug_info.data_bp_alignment
	  && (addr + len > (addr & ~(booke_debug_info.data_bp_alignment - 1))
	      + booke_debug_info.data_bp_alignment))
d1899 49
a1958 11
      CORE_ADDR data_value;

      if (cond && can_use_watchpoint_cond_accel ()
	  && check_condition (addr, cond, &data_value))
	calculate_dvc (addr, len, data_value, &p.condition_mode,
		       &p.condition_value);
      else
	{
	  p.condition_mode  = PPC_BREAKPOINT_CONDITION_NONE;
	  p.condition_value = 0;
	}
d1960 1
a1960 5
      p.version         = PPC_DEBUG_CURRENT_VERSION;
      p.trigger_type    = get_trigger_type (rw);
      p.addr_mode       = PPC_BREAKPOINT_MODE_EXACT;
      p.addr            = (uint64_t) addr;
      p.addr2           = 0;
a2027 11
      CORE_ADDR data_value;

      if (cond && booke_debug_info.num_condition_regs > 0
	  && check_condition (addr, cond, &data_value))
	calculate_dvc (addr, len, data_value, &p.condition_mode,
		       &p.condition_value);
      else
	{
	  p.condition_mode  = PPC_BREAKPOINT_CONDITION_NONE;
	  p.condition_value = 0;
	}
d2029 1
a2029 5
      p.version         = PPC_DEBUG_CURRENT_VERSION;
      p.trigger_type    = get_trigger_type (rw);
      p.addr_mode       = PPC_BREAKPOINT_MODE_EXACT;
      p.addr            = (uint64_t) addr;
      p.addr2           = 0;
@


1.97
log
@run copyright.sh for 2011.
@
text
@d45 1
a45 1
/* Prototypes for supply_gregset etc. */
d133 1
a133 1
        uint32_t version;               /* Only version 1 exists to date */
d138 1
a138 1
        uint32_t sizeof_condition;      /* size of the DVC register */
d208 1
a208 1
   quantity. Up to here we have the elf_vrregset_t structure.
d328 8
a335 4
PT_FPR0, PT_FPR0 + 2, PT_FPR0 + 4, PT_FPR0 + 6, PT_FPR0 + 8, PT_FPR0 + 10, PT_FPR0 + 12, PT_FPR0 + 14,
PT_FPR0 + 16, PT_FPR0 + 18, PT_FPR0 + 20, PT_FPR0 + 22, PT_FPR0 + 24, PT_FPR0 + 26, PT_FPR0 + 28, PT_FPR0 + 30,
PT_FPR0 + 32, PT_FPR0 + 34, PT_FPR0 + 36, PT_FPR0 + 38, PT_FPR0 + 40, PT_FPR0 + 42, PT_FPR0 + 44, PT_FPR0 + 46,
PT_FPR0 + 48, PT_FPR0 + 50, PT_FPR0 + 52, PT_FPR0 + 54, PT_FPR0 + 56, PT_FPR0 + 58, PT_FPR0 + 60, PT_FPR0 + 62,
d348 1
a348 1
  /* General purpose registers occupy 1 slot each in the buffer */
d361 1
a361 1
  /* UISA special purpose registers: 1 slot each */
d466 2
a467 1
		       regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
d551 1
a551 1
  unsigned int offset;         /* Offset of registers within the u area. */
d863 1
a863 1
  /* Overload thread id onto process id */
d866 1
a866 1
  /* No thread id, just use process id */
d876 1
a876 1
/* Store one VSX register. */
d905 1
a905 1
/* Store one register. */
d933 2
a934 1
			regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
d1422 2
a1423 1
	    + booke_debug_info.num_data_bps + booke_debug_info.num_condition_regs;
d1474 3
a1476 3
      /* We need to know whether ptrace supports PTRACE_SET_DEBUGREG and whether
	 the target has DABR.  If either answer is no, the ptrace call will
	 return -1.  Fail in that case.  */
d1551 2
a1552 1
      t->hw_breaks = xzalloc (max_slots_number * sizeof (struct hw_break_tuple));
d1626 2
a1627 1
      perror_with_name (_("Unexpected error deleting breakpoint or watchpoint"));
d1762 2
a1763 1
    *condition_mode |= PPC_BREAKPOINT_CONDITION_BE (i + rightmost_enabled_byte);
d1812 1
a1812 1
      /* Other kinds of values are not fine. */
d2038 1
a2038 1
      /* Get a list of breakpoints from any thread. */
d2042 1
a2042 1
      /* Copy that thread's breakpoints and watchpoints to the new thread. */
d2146 1
a2146 1
  /* Check whether [start, start+length-1] intersects [addr, addr+mask]. */
d2154 1
a2154 1
  /* Overload thread id onto process id */
d2157 1
a2157 1
  /* No thread id, just use process id */
d2169 1
a2169 1
   by the ptrace interface, not the current program's ABI.  eg. If a
d2309 1
a2309 1
     the FPSCR from 32 bits to 64 bits. Even though Power 7 supports this
d2327 2
a2328 1
	return isa205? tdesc_powerpc_isa205_altivec64l : tdesc_powerpc_altivec64l;
d2367 2
a2368 1
  t->to_can_accel_watchpoint_condition = ppc_linux_can_accel_watchpoint_condition;
@


1.96
log
@	* ppc-linux-nat.c (store_vsx_register): Use PTRACE_GETVSXREGS to get
	VSX registers contents.
@
text
@d4 2
a5 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.95
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@d880 1
a880 1
  ret = ptrace (PTRACE_SETVSXREGS, tid, 0, &regs);
@


1.95.2.1
log
@	* ppc-linux-nat.c (store_vsx_register): Use PTRACE_GETVSXREGS to get
	VSX registers contents.
@
text
@d880 1
a880 1
  ret = ptrace (PTRACE_GETVSXREGS, tid, 0, &regs);
@


1.94
log
@Fix ARI warning.

        * ppc-linux-nat.c (booke_cmp_hw_point): Do not mark inline.
@
text
@d1495 1
a1495 1
	  return 0;
d1688 1
d1690 194
a1883 1
ppc_linux_insert_watchpoint (CORE_ADDR addr, int len, int rw)
d1892 11
a1906 1
      p.condition_mode  = PPC_BREAKPOINT_CONDITION_NONE;
a1908 1
      p.condition_value = 0;
d1955 2
a1956 1
	if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (ptid), 0, saved_dabr_value) < 0)
d1966 2
a1967 1
ppc_linux_remove_watchpoint (CORE_ADDR addr, int len, int rw)
d1976 11
a1990 1
      p.condition_mode  = PPC_BREAKPOINT_CONDITION_NONE;
a1992 1
      p.condition_value = 0;
d2003 2
a2004 1
	if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (ptid), 0, saved_dabr_value) < 0)
d2355 1
@


1.93
log
@2010-04-22  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* ppc-linux-nat.c (PTRACE_GET_DEBUGREG): Update comment.
	(PPC_PTRACE_GETWDBGINFO, PPC_PTRACE_SETHWDEBUG, PPC_PTRACE_DELHWDEBUG,
	ppc_debug_info, PPC_DEBUG_FEATURE_INSN_BP_RANGE,
	PPC_DEBUG_FEATURE_INSN_BP_MASK, PPC_DEBUG_FEATURE_DATA_BP_RANGE,
	PPC_DEBUG_FEATURE_DATA_BP_MASK, ppc_hw_breakpoint,
	PPC_BREAKPOINT_TRIGGER_EXECUTE, PPC_BREAKPOINT_TRIGGER READ,
	PPC_BREAKPOINT_TRIGGER_WRITE, PPC_BREAKPOINT_TRIGGER_RW,
	PPC_BREAKPOINT_MODE_EXACT PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE,
	PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE, PPC_BREAKPOINT_MODE_MASK,
	PPC_BREAKPOINT_CONDITION_NONE, PPC_BREAKPOINT_CONDITION_AND,
	PPC_BREAKPOINT_CONDITION_EXACT, PPC_BREAKPOINT_CONDITION_OR,
	PPC_BREAKPOINT_CONDITION_AND_OR, PPC_BREAKPOINT_CONDITION_BE_ALL,
	PPC_BREAKPOINT_CONDITION_BE_SHIFT, PPC_BREAKPOINT_CONDITION_BE):
	Define, in case <ptrace.h> doesn't provide it.
	(booke_debug_info): New variable.
	(max_slots_number): Ditto.
	(hw_break_tuple): New struct.
	(thread_points): Ditto.
	(ppc_threads): New variable.
	(PPC_DEBUG_CURRENT_VERSION): New define.
	(have_ptrace_new_debug_booke): New function.
	(ppc_linux_check_watch_resources): Renamed to ...
	(ppc_linux_can_use_hw_breakpoint): ... this.  Handle BookE processors.
	(ppc_linux_region_ok_for_hw_watchpoint): Handle BookE processors.
	(booke_cmp_hw_point): New function.
	(booke_find_thread_points_by_tid): Ditto.
	(booke_insert_point): Ditto.
	(booke_remove_point): Ditto.
	(ppc_linux_insert_hw_breakpoint): Ditto.
	(ppc_linux_remove_hw_breakpoint): Ditto.
	(get_trigger_type): Ditto.
	(ppc_linux_insert_watchpoint): Handle BookE processors.
	(ppc_linux_remove_watchpoint): Ditto.
	(ppc_linux_new_thread): Ditto.
	(ppc_linux_thread_exit): New function..
	(ppc_linux_stopped_data_address): Handle BookE processors.
	(ppc_linux_watchpoint_addr_within_range): Ditto.
	(_initialize_ppc_linux_nat): Initialize to_insert_hw_breakpoint and
	to_remove_hw_breakpoint fields of the target operations struct.
	Add observe for the thread_exit event.
@
text
@d1511 1
a1511 1
static inline int
@


1.92
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d23 1
d26 1
d105 2
a106 1
/* Similarly for the hardware watchpoint support.  */
d117 67
d1343 54
d1398 1
a1398 1
ppc_linux_check_watch_resources (int type, int cnt, int ot)
d1400 5
a1404 2
  int tid;
  ptid_t ptid = inferior_ptid;
d1406 3
a1408 5
  /* DABR (data address breakpoint register) is optional for PPC variants.
     Some variants have one DABR, others have none.  So CNT can't be larger
     than 1.  */
  if (cnt > 1)
    return 0;
d1410 14
a1423 6
  /* We need to know whether ptrace supports PTRACE_SET_DEBUGREG and whether
     the target has DABR.  If either answer is no, the ptrace call will
     return -1.  Fail in that case.  */
  tid = TIDGET (ptid);
  if (tid == 0)
    tid = PIDGET (ptid);
d1425 1
a1425 3
  if (ptrace (PTRACE_SET_DEBUGREG, tid, 0, 0) == -1)
    return 0;
  return 1;
d1428 2
a1429 2
/* Fetch the AT_HWCAP entry from the aux vector.  */
unsigned long ppc_linux_get_hwcap (void)
d1431 41
a1471 1
  CORE_ADDR field;
d1473 3
a1475 2
  if (target_auxv_search (&current_target, AT_HWCAP, &field))
    return (unsigned long) field;
d1477 1
a1477 1
  return 0;
d1487 10
d1498 2
a1499 1
     processors.  DAC-based processors, like the PowerPC 440, will use
d1501 4
a1504 4
     passed at the moment.  */
  if (((ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
      && (addr + len) > (addr & ~3) + 4)
      || (addr + len) > (addr & ~7) + 8)
d1510 177
a1686 2
/* The cached DABR value, to install in new threads.  */
static long saved_dabr_value;
a1687 1
/* Set a watchpoint of type TYPE at address ADDR.  */
d1693 16
a1708 2
  long dabr_value;
  long read_mode, write_mode;
d1710 2
a1711 7
  if (ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
  {
  /* PowerPC 440 requires only the read/write flags to be passed
     to the kernel.  */
    read_mode  = 1;
    write_mode = 2;
  }
d1713 37
a1749 23
  {
  /* PowerPC 970 and other DABR-based processors are required to pass
     the Breakpoint Translation bit together with the flags.  */
    read_mode  = 5;
    write_mode = 6;
  }

  dabr_value = addr & ~(read_mode | write_mode);
  switch (rw)
    {
    case hw_read:
      /* Set read and translate bits.  */
      dabr_value |= read_mode;
      break;
    case hw_write:
      /* Set write and translate bits.  */
      dabr_value |= write_mode;
      break;
    case hw_access:
      /* Set read, write and translate bits.  */
      dabr_value |= read_mode | write_mode;
      break;
    }
d1751 3
a1753 1
  saved_dabr_value = dabr_value;
d1755 2
a1756 3
  ALL_LWPS (lp, ptid)
    if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (ptid), 0, saved_dabr_value) < 0)
      return -1;
d1758 1
a1758 1
  return 0;
d1766 25
a1790 1
  long dabr_value = 0;
d1792 4
a1795 5
  saved_dabr_value = 0;
  ALL_LWPS (lp, ptid)
    if (ptrace (PTRACE_SET_DEBUGREG, TIDGET (ptid), 0, saved_dabr_value) < 0)
      return -1;
  return 0;
d1801 55
a1855 1
  ptrace (PTRACE_SET_DEBUGREG, TIDGET (ptid), 0, saved_dabr_value);
d1869 23
d1910 4
a1913 1
  if (ppc_linux_get_hwcap () & PPC_FEATURE_BOOKE)
d2130 4
a2133 2
  /* Add our watchpoint methods.  */
  t->to_can_use_hw_breakpoint = ppc_linux_check_watch_resources;
d2144 2
@


1.91
log
@ChangeLog:

	* features/Makefile: Allow sub-platform specific expedite settings.
	(WHICH): Add rs6000/powerpc-cell32l and rs6000/powerpc-cell64l.
	(rs6000/powerpc-cell32l-expedite): Define.
	(rs6000/powerpc-cell64l-expedite): Likewise.
	* features/rs6000/powerpc-cell32l.xml: New file.
	* features/rs6000/powerpc-cell64l.xml: New file.
	* features/rs6000/powerpc-cell32l.c: New generated file.
	* features/rs6000/powerpc-cell64l.c: New generated file.

	* regformats/rs6000/powerpc-cell32l.dat: New generated file.
	* regformats/rs6000/powerpc-cell64l.dat: New generated file.

	* config/djgpp/fnchange.lst: Add mappings for new files.

	* ppc-linux-tdep.h (tdesc_powerpc_cell32l): Add prototype.
	(tdesc_powerpc_cell64l): Likewise.
	* ppc-linux-tdep.c: Include "features/rs6000/powerpc-cell32l.c"
	and "features/rs6000/powerpc-cell64l.c".
	(_initialize_ppc_linux_tdep): Initialize target descriptions.
	(ppc_linux_spu_section): New function.
	(ppc_linux_core_read_description): Detect Cell/B.E. core files.
	* ppc-linux-nat.c (PPC_FEATURE_CELL): Define.
	(ppc_linux_read_description): Detect Cell/B.E. architecture.

	* rs6000-tdep.c (rs6000_gdbarch_init): Do not trust BFD wordsize
	if exec file is not PowerPC architecture.

gdbserver/ChangeLog:

	* configure.srv (powerpc*-*-linux*): Add powerpc-cell32l.o
	and powerpc-cell64l.o to srv_regobj.  Add rs6000/powerpc-cell32l.xml
	and rs6000/powerpc-cell64l.xml to srv_xmlfiles.
	* Makefile.in (powerpc-cell32l.o, powerpc-cell32l.c): New rules.
	(powerpc-cell64l.o, powerpc-cell64l.c): Likewise.
	(clean): Handle powerpc-cell32l.c and powerpc-cell64l.c.
	* linux-ppc-low.c (PPC_FEATURE_CELL): Define.
	(init_registers_powerpc_cell32l): Add prototype.
	(init_registers_powerpc_cell64l): Likewise.
	(ppc_arch_setup): Detect Cell/B.E. architecture.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.90
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d63 3
d1553 1
d1607 3
d1612 3
a1614 1
      if (vsx)
d1622 3
a1624 1
  if (vsx)
@


1.89
log
@	* ppc-linux-nat.c (have_ptrace_getsetregs): New variable.
	(have_ptrace_getsetfpregs): Likewise.
	fetch_all_gp_regs): New function.
	(fetch_gp_regs): New function.
	(fetch_all_fp_regs): Likewise.
	(fetch_fp_regs): New function.
	(fetch_ppc_registers): Using the new methods to fetch general-
	purpose and floating-pointer registers.
	(store_all_gp_regs): New function.
	(store_gp_regs): Likewise.
	(store_all_fp_regs): New function.
	(store_fp_regs): Likewise.
	(store_ppc_registers): Using the new methods to store general-
	purpose and floating-pointer registers.
@
text
@d1526 1
d1535 1
a1535 1
  *typep = extract_unsigned_integer (ptr, sizeof_auxv_field);
d1537 1
a1537 1
  *valp = extract_unsigned_integer (ptr, sizeof_auxv_field);
@


1.88
log
@	* ppc-linux-nat.c (ppc_linux_target_wordsize): New function.
	(ppc_linux_auxv_parse): New function.
	(ppc_linux_read_description): Use ppc_linux_target_wordsize.
	(_initialize_ppc_linux_nat): Install ppc_linux_auxv_parse.
@
text
@d111 15
d236 12
d631 106
d744 1
a744 2
  for (i = 0; i < ppc_num_gprs; i++)
    fetch_register (regcache, tid, tdep->ppc_gp0_regnum + i);
d746 1
a746 2
    for (i = 0; i < ppc_num_fprs; i++)
      fetch_register (regcache, tid, tdep->ppc_fp0_regnum + i);
d1104 126
d1236 2
a1237 3
  
  for (i = 0; i < ppc_num_gprs; i++)
    store_register (regcache, tid, tdep->ppc_gp0_regnum + i);
d1239 1
a1239 2
    for (i = 0; i < ppc_num_fprs; i++)
      store_register (regcache, tid, tdep->ppc_fp0_regnum + i);
@


1.87
log
@gdb/
	  Fix size of FPSCR in Power 7 processors.
	* ppc-linux-nat.c (PPC_FEATURE_ARCH_2_05): Remove #define.
	(PPC_FEATURE_HAS_DFP): New #define.
	(ppc_linux_read_description): Check for DFP feature instead of
	ISA 2.05 to decide on size of the FPSCR.

gdbserver/
	Fix size of FPSCR in Power 7 processors.
	* linux-ppc-low.c (PPC_FEATURE_ARCH_2_05): Remove #define.
	(PPC_FEATURE_HAS_DFP): New #define.
	(ppc_arch_setup): Check for DFP feature instead of ISA 2.05 to decide on
	size of the FPSCR.
@
text
@d1243 45
d1347 9
a1355 18
  /* Check for 64-bit inferior process.  This is the case when the host is
     64-bit, and in addition the top bit of the MSR register is set.  */
#ifdef __powerpc64__
  {
    long msr;
    errno = 0;
    msr = (long) ptrace (PTRACE_PEEKUSER, tid, PT_MSR * 8, 0);
    if (errno == 0 && msr < 0)
      {
	if (vsx)
	  return isa205? tdesc_powerpc_isa205_vsx64l : tdesc_powerpc_vsx64l;
	else if (altivec)
	  return isa205? tdesc_powerpc_isa205_altivec64l : tdesc_powerpc_altivec64l;

	return isa205? tdesc_powerpc_isa205_64l : tdesc_powerpc_64l;
      }
  }
#endif
d1389 1
@


1.86
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d66 2
a67 2
#ifndef PPC_FEATURE_ARCH_2_05
#define PPC_FEATURE_ARCH_2_05	0x00001000 /* ISA 2.05 */
d1293 7
a1299 1
  if (ppc_linux_get_hwcap () & PPC_FEATURE_ARCH_2_05)
@


1.85
log
@        Updated copyright notices for most files.
@
text
@d650 2
a651 1
ppc_linux_fetch_inferior_registers (struct regcache *regcache, int regno)
d1183 2
a1184 1
ppc_linux_store_inferior_registers (struct regcache *regcache, int regno)
@


1.84
log
@gdb/
	* ppc-linux-nat.c (ppc_register_u_addr): Add special case to return
	offset for full 64-bit slot of FPSCR when in 32-bits.
	(ppc_linux_read_description): Return target description with 64-bit
	FPSCR when inferior is running on an ISA 2.05 or later processor.
	* ppc-linux-tdep.c (_initialize_ppc_linux_tdep): Call
	initialize_tdec_powerpc_isa205_32l,
	initialize_tdec_powerpc_isa205_altivec32l,
	initialize_tdec_powerpc_isa205_vsx32l,
	initialize_tdec_powerpc_isa205_64l,
	initialize_tdec_powerpc_isa205_altivec64l and
	initialize_tdec_powerpc_isa205_vsx64l.
	* ppc-linux-tdep.h: Add external declaration for
	tdesc_powerpc_isa205_32l, tdesc_powerpc_isa205_altivec32l,
	tdesc_powerpc_isa205_vsx32l, tdesc_powerpc_isa205_64l,
	tdesc_powerpc_isa205_altivec64l and tdesc_powerpc_isa205_vsx64l.
	* features/rs600/powerpc-fpu-isa205.xml: New file.
	* features/rs600/powerpc-isa205-32l.xml: New file.
	* features/rs600/powerpc-isa205-64l.xml: New file.
	* features/rs600/powerpc-isa205-altivec32l.xml: New file.
	* features/rs600/powerpc-isa205-altivec64l.xml: New file.
	* features/rs600/powerpc-isa205-vsx32l.xml: New file.
	* features/rs600/powerpc-isa205-vsx64l.xml: New file.
	* features/rs600/powerpc-isa205-32l.c: Generate.
	* features/rs600/powerpc-isa205-64l.c: Generate.
	* features/rs600/powerpc-isa205-altivec32l.c: Generate.
	* features/rs600/powerpc-isa205-altivec64l.c: Generate.
	* features/rs600/powerpc-isa205-vsx32l.c: Generate.
	* features/rs600/powerpc-isa205-vsx64l.c: Generate.

gdb/testsuite/
	* gdb.arch/ppc-dfp.exp: New file.
	* gdb.arch/ppc-dfp.c: New file.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.83
log
@	* rs6000-tdep: Include "features/rs6000/powerpc-vsx32.c".
	Include "features/rs6000/powerpc-vsx64.c".
	(ppc_supply_vsxregset): New function.
	(ppc_collect_vsxregset): New function.
	(IS_VSX_PSEUDOREG): New macro.
	(IS_EFP_PSEUDOREG): New macro.
	(vsx_register_p): New function.
	(ppc_vsx_support_p): New function.
	(rs6000_builtin_type_vec128): New function.
	(rs6000_register_name): Hide upper halves of vs0~vs31.  Return
	correct names for VSX registers and EFPR registers.
	(rs6000_pseudo_register_type): Return correct types for VSX
	and EFPR registers.
	(rs6000_pseudo_register_reggroup_p): Return correct group for
	VSX and EFPR registers.
	(ppc_pseudo_register_read): Rename to dfp_pseudo_register_read.
	(ppc_pseudo_register_write): Rename to dfp_pseudo_register_write.
	(vsx_pseudo_register_read): New function.
	(vsx_pseudo_register_write): New function.
	(efpr_pseudo_register_read): New function.
	(efpr_pseudo_register_write): New function.
	(rs6000_pseudo_register_read): Call new VSX and EFPR read functions.
	(rs6000_pseudo_register_write): Call new VSX and EFPR write functions.
	(rs6000_gdbarch_init): Declare have_vsx.
	Initialize new upper half VSX registers.
	Initialize VSX-related and EFPR-related pseudo-registers variables.
	Adjust the number of pseudo registers accordingly.

	* ppc-linux-nat.c: Define PTRACE_GETVSXREGS, PTRACE_SETVSXREGS
	and SIZEOF_VSRREGS.
	(gdb_vsxregset_t): New type.
	(have_ptrace_getsetvsxregs): New variable.
	(fetch_vsx_register): New function.
	(fetch_register): Handle VSX registers.
	(fetch_vsx_registers): New function.
	(fetch_ppc_registers): Handle VSX registers.
	(store_ppc_registers): Handle VSX registers.
	(store_vsx_register): New function.
	(store_register): Handle VSX registers.
	(store_vsx_registers): New function.
	(ppc_linux_read_description): Handle VSX-enabled inferiors.
	(gdb_vsxregset_t): New type.
	(supply_vsxregset): New function.
	(fill_vsxregset): New function.

	* ppc-tdep.h (vsx_register_p): New prototype.
	(vsx_support_p): New prototype.
	(ppc_vsr0_regnum): New variable.
	(ppc_vsr0_upper_regnum): Likewise.
	(ppc_efpr0_regnum): Likewise.
	(ppc_builtin_type_vec128): New type.
	(ppc_num_vsrs): New constant.
	(ppc_num_vshrs): New constant.
	(ppc_num_efprs): Likewise.
	Define POWERPC_VEC_VSX PPC_VSR0_UPPER_REGNUM and PPC_VSR31_UPPER_REGNUM.
	(ppc_supply_vsxregset): New prototype.
	(ppc_collect_vsxregset): New prototype.

	* ppc-linux-tdep.c: Include "features/rs6000/powerpc-vsx32l.c"
	Include "features/rs6000/powerpc-vsx64l.c".
	(_initialize_ppc_linux_tdep): Initialize VSX-enabled targets.
	(ppc_linux_regset_sections): Add new ".reg-ppc-vsx" field.
	(ppc32_linux_vsxregset): New 32-bit VSX-enabled regset.
	(ppc_linux_regset_from_core_section): Handle VSX core section.
	(ppc_linux_core_read_description): Support VSX-enabled core files.

	* ppc-linux-tdep.h: Declare *tdesc_powerpc_vsx32l
	Declare tdesc_powerpc_vsx64l

	* corelow.c (get_core_register_section): Support VSX-enabled
	core files.

	* features/rs6000/power-vsx.xml: New VSX descriptions.
	* features/rs6000/powerpc-vsx32.xml: New file.
	* features/rs6000/powerpc-vsx32l.xml: New file.
	* features/rs6000/powerpc-vsx64.xml: New file.
	* features/rs6000/powerpc-vsx64l.xml: New file.
	* features/rs6000/powerpc-vsx32.c: New file (generated).
	* features/rs6000/powerpc-vsx32l.c: New file (generated).
	* features/rs6000/powerpc-vsx64.c: New file (generated).
	* features/rs6000/powerpc-vsx64l.c: New file (generated).
	* features/Makefile: Updated with new descriptions.
	* regformats/rs6000/powerpc-vsx32l.dat: New file (generated).
	* regformats/rs6000/powerpc-vsx64l.dat: New file (generated).

	* testsuite/gdb.arch/vsx-regs.c: New source file.
	* testsuite/gdb.arch/vsx-regs.exp: New testcase.
	* testsuite/lib/gdb.exp (skip_vsx_tests): New function.
@
text
@d59 4
d66 3
d284 1
a284 1
	 the secondhalf of such a slot-pair (hence +1).  For 64-bit,
d289 6
d1246 1
d1291 3
d1304 1
a1304 1
	  return tdesc_powerpc_vsx64l;
d1306 1
a1306 1
	  return tdesc_powerpc_altivec64l;
d1308 1
a1308 1
	return tdesc_powerpc_64l;
d1314 1
a1314 1
    return tdesc_powerpc_vsx32l;
d1316 1
a1316 1
    return tdesc_powerpc_altivec32l;
d1318 1
a1318 1
  return tdesc_powerpc_32l;
@


1.82
log
@	* ppc-linux-nat.c (ppc_linux_get_hwcap): Really get AT_HWCAP.
@
text
@d79 5
d135 35
d195 6
d288 28
d450 8
d514 15
d554 19
d626 3
d652 29
d819 5
d878 13
d914 23
d994 3
d1232 1
d1251 13
d1285 8
a1292 1
      return altivec? tdesc_powerpc_altivec64l : tdesc_powerpc_64l;
d1296 6
a1301 1
  return altivec? tdesc_powerpc_altivec32l : tdesc_powerpc_32l;
@


1.81
log
@	* ppc-linux-nat.c: Include "auxv.h" and "elf/common.h".
	Define PPC_FEATURE_BOOKE.
	(ppc_linux_get_hwcap): New function.
	(ppc_linux_region_ok_for_hw_watchpoint): Handle PowerPC 440
	4-bytes alignment restrictions.
	(ppc_linux_insert_watchpoint): Handle PowerPC 440-specific
	positioning of the read/write flags.
	(ppc_linux_watchpoint_addr_within_range): Handle PowerPC 440
	4-bytes alignment.
@
text
@d838 1
a838 1
  if (target_auxv_search (&current_target, AT_PLATFORM, &field))
@


1.80
log
@ChangeLog:

	* Makefile.in (ppc_linux_tdep_h): New macro.
	(powerpc_32l_c, powerpc_altivec32_c, powerpc_altivec32l_c): Likewise.
	(powerpc_64l_c, powerpc_altivec64_c, powerpc_altivec64l_c): Likewise.
	(powerpc_e500l_c): Likewise.
	(ppc-linux-nat.o): Update dependencies.
	(ppc-linux-tdep.o): Update dependencies.
	(rs6000-tdep.o): Update dependencies.

	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Remove.
	(ppc_linux_svr4_fetch_link_map_offsets): Remove.
	(ppc_linux_gregset, ppc_linux_fpregset): Move to ppc-linux-tdep.h
	(ppc_supply_reg, ppc_collect_reg): Add prototypes.
	(tdesc_powerpc_e500): Remove.

	* rs6000.c: Include "features/rs6000/powerpc-altivec32.c"
	and "features/rs6000/powerpc-altivec64.c".
	(ppc_supply_reg, ppc_collect_reg): Make global.
	(variants): Use tdesc_powerpc_32 for "powerpc" and
	tdesc_powerpc_altivec64 for "powerpc64".
	(_initialize_rs6000_tdep): Initialize AltiVec descriptions.

	* ppc-linux-tdep.h: New file.

	* ppc-linux-tdep.c: Include "ppc-linux-tdep.c".
	Include "features/rs6000/powerpc-32l.c".
	Include "features/rs6000/powerpc-altivec32l.c".
	Include "features/rs6000/powerpc-64l.c".
	Include "features/rs6000/powerpc-altivec64l.c".
	Include "features/rs6000/powerpc-e500l.c".
	(ppc_linux_supply_gregset): New function.
	(ppc_linux_collect_gregset): Handle orig_r3 and trap registers.
	(ppc32_linux_gregset): Use ppc_linux_supply_gregset.
	(ppc64_linux_gregset): Likewise.
	(ppc_linux_sigtramp_cache): Handle orig_r3 and trap registers.
	(ppc_linux_trap_reg_p): New function.
	(ppc_linux_write_pc): New function.
	(ppc_linux_core_read_description): New function.
	(ppc_linux_init_abi): Install ppc_linux_write_pc and
	ppc_linux_core_read_description.  Install orig_r3 and trap
	registers if present in the target description.
	(_initialize_ppc_linux_tdep): Initialize Linux target descriptions.

	* ppc-linux-nat.c: Include "ppc-linux-tdep.h".
	(PT_ORIG_R3, PT_TRAP): Define if necessary.
	(ppc_register_u_addr): Handle orig_r3 and trap registers.
	(fetch_ppc_registers): Likewise.
	(store_ppc_registers): Likewise.
	(store_register): Likewise.
	(ppc_linux_read_description): Check whether AltiVec is supported.
	Check whether inferior is 32-bit or 64-bit.  Return the appropriate
	Linux target description.

	* features/Makefile (WHICH): Use rs6000/powerpc-32l and
	rs6000/powerpc-altivec32l instead of rs6000/powerpc-32.
	Use rs6000/powerpc-64l and rs6000/powerpc-altivec64l instead
	of rs6000/powerpc-64.  Use rs6000/powerpc-e500l instead of
	rs6000/powerpc-e500.  Update -expedite variables accordingly.

	* features/rs6000/power-spe.xml: Use regnum 73 for "acc".
	* features/rs6000/powerpc-32.xml: Do not include power-altivec.xml.
	* features/rs6000/powerpc-64.xml: Do not include power-altivec.xml.
	* features/rs6000/powerpc-e500.c: Regenerate.
	* features/rs6000/powerpc-32.c: Regenerate.
	* features/rs6000/powerpc-64.c: Regenerate.

	* features/rs6000/power-linux.xml: New file.
	* features/rs6000/power64-linux.xml: New file.
	* features/rs6000/powerpc-32l.xml: New file.
	* features/rs6000/powerpc-altivec32l.xml: New file.
	* features/rs6000/powerpc-64l.xml: New file.
	* features/rs6000/powerpc-altivec64l.xml: New file.
	* features/rs6000/powerpc-e500l.xml: New file.
	* features/rs6000/powerpc-32l.c: New (generated) file.
	* features/rs6000/powerpc-altivec32l.c: New (generated) file.
	* features/rs6000/powerpc-64l.c: New (generated) file.
	* features/rs6000/powerpc-altivec64l.c: New (generated) file.
	* features/rs6000/powerpc-e500l.xml: New (generated) file.

	* regformats/reg-ppc.dat: Remove.
	* regformats/reg-ppc64.dat: Remove.
	* regformats/rs6000/powerpc-32.dat: Remove.
	* regformats/rs6000/powerpc-64.dat: Remove.
	* regformats/rs6000/powerpc-e500.dat: Remove.
	* regformats/rs6000/powerpc-32l.dat: New (generated) file.
	* regformats/rs6000/powerpc-altivec32l.dat: New (generated) file.
	* regformats/rs6000/powerpc-64l.dat: New (generated) file.
	* regformats/rs6000/powerpc-altivec64l.dat: New (generated) file.
	* regformats/rs6000/powerpc-e500l.dat: New (generated) file.

gdbserver/ChangeLog:

	* configure.srv (powerpc*-*-linux*): Set srv_regobj to
	powerpc-32l.o, powerpc-altivec32l.o, powerpc-e500l.o,
	powerpc-64l.o, and powerpc-altivec64l.o.
	Remove rs6000/powerpc-32.xml, rs6000/powerpc-64.xml, and
	rs6000/powerpc-e500.xml; add rs6000/powerpc-32l.xml,
	rs6000/powerpc-altivec32l.xml, rs6000/powerpc-e500l.xml,
	rs6000/powerpc-64l.xml, rs6000/powerpc-altivec64l.xml,
	rs6000/power-linux.xml, and rs6000/power64-linux.xml
	to srv_xmlfiles.

	* Makefile.in (reg-ppc.o, reg-ppc.c): Remove, replace by ...
	(powerpc-32l.o, powerpc-32l.c): ... these new rules.
	(powerpc-32.o, powerpc-32.c): Remove, replace by ...
	(powerpc-altivec32l.o, powerpc-altivec32l.c): ... these new rules.
	(powerpc-e500.o, powerpc-e500.c): Remove, replace by ...
	(powerpc-e500l.o, powerpc-e500l.c): ... these new rules.
	(reg-ppc64.o, reg-ppc64.c): Remove, replace by ...
	(powerpc-64l.o, powerpc-64l.c): ... these new rules.
	(powerpc-64.o, powerpc-64.c): Remove, replace by ...
	(powerpc-altivec64l.o, powerpc-altivec64l.c): ... these new rules.
	(clean): Update.

	* linux-ppc-low.c (init_registers_ppc): Remove, replace by ...
	(init_registers_powerpc_32l): ... this new prototype.
	(init_registers_powerpc_32): Remove, replace by ...
	(init_registers_powerpc_altivec32l): ... this new prototype.
	(init_registers_powerpc_e500): Remove, replace by ...
	(init_registers_powerpc_e500l): ... this new prototype.
	(init_registers_ppc64): Remove, replace by ...
	(init_registers_powerpc_64l): ... this new prototype.
	(init_registers_powerpc_64): Remove, replace by ...
	(init_registers_powerpc_altivec64l): ... this new prototype.
	(ppc_num_regs): Set to 73.
	(PT_ORIG_R3, PT_TRAP): Define if necessary.
	(ppc_regmap, ppc_regmap_e500): Add values for orig_r3 and trap.
	(ppc_cannot_store_register): Handle orig_r3 and trap.
	(ppc_arch_setup): Update init_registers_... calls.
	(ppc_fill_gregset): Handle orig_r3 and trap.

	* inferiors.c (clear_inferiors): Reset current_inferior.
@
text
@d47 4
d59 4
d833 11
d851 7
a857 2
  /* addr+len must fall in the 8 byte watchable region.  */
  if ((addr + len) > (addr & ~7) + 8)
d873 1
d875 16
a890 1
  dabr_value = addr & ~7;
d895 1
a895 1
      dabr_value |= 5;
d899 1
a899 1
      dabr_value |= 6;
d903 1
a903 1
      dabr_value |= 7;
d963 11
a973 3
  addr &= ~7;
  /* Check whether [start, start+length-1] intersects [addr, addr+7]. */
  return start <= addr + 7 && start + length - 1 >= addr;
@


1.79
log
@* target.h (struct target_ops): Add
to_watchpoint_addr_within_range.
(target_watchpoint_addr_within_range): New function.
* target.c (update_current_target): Inherit
to_watchpoint_addr_within_range, defaulting to
default_watchpoint_addr_within_range.
(default_watchpoint_addr_within_range): New function.
(debug_to_watchpoint_addr_within_range): New function.
(setup_target_debug): Set to_watchpoint_addr_within_range.
* ppc-linux-nat.c (ppc_linux_watchpoint_addr_within_range):
New function.
(_initialize_ppc_linux_nat): Set to_watchpoint_addr_within_range.
* breakpoint.c (watchpoints_triggered): Use
target_watchpoint_addr_within_range.

* gdbint.texinfo (Algorithms): Describe
target_watchpoint_addr_within_range.
@
text
@d45 9
d212 4
d492 5
d697 3
a699 1
          && regno == tdep->ppc_fpscr_regnum)
d701 2
a702 1
	  /* Some older kernel versions don't allow fpscr to be written.  */
d789 5
d991 6
a999 1
      int tid = TIDGET (inferior_ptid);
d1001 2
a1002 2
      if (tid == 0)
	tid = PIDGET (inferior_ptid);
d1004 4
a1007 11
      if (ptrace (PTRACE_GETEVRREGS, tid, 0, &evrregset) >= 0)
        return tdesc_powerpc_e500;
      else
        {
          /* EIO means that the PTRACE_GETEVRREGS request isn't supported.  */
          if (errno == EIO)
	    return NULL;
	  else
            /* Anything else needs to be reported.  */
            perror_with_name (_("Unable to fetch SPE registers"));
	}
d1010 26
a1035 1
  return NULL;
@


1.78
log
@
	* ppc-linux-nat.c (ppc_register_u_addr): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch. Update caller.
@
text
@d892 10
d1010 1
@


1.77
log
@	* alpha-tdep.c (alpha_heuristic_proc_start)
	(alpha_sigtramp_register_address): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.

	(alpha_heuristic_frame_unwind_cache): Use get_frame_arch to get at the
	current architecture by frame_info. Update alpha_heuristic_proc_start
	call.

	(alpha_sigtramp_frame_this_id, alpha_sigtramp_frame_prev_register): Use
	get_frame_arch to get at the current architecture by frame_info. Update
	alpha_sigtramp_register_address call.

	* arm-tdep.c (thumb_scan_prologue): Add gdbarch as parameter and replace
	current_gdbarch by gdbarch. Update caller.
	(convert_to_extended, convert_from_extended): Add endianess parameter
	for comparison. Update caller.
	(arm_extract_return_value, arm_store_return_value): Use
	get_regcache_arch to get at the current	architecture.

	* cris-tdep.c (cris_register_size): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.
	(cris_gdb_func, move_to_preg_op, none_reg_mode_move_from_preg_op): Add
	gdbarch as parameter. Update caller. Replace current_gdbarch by gdbarch.

	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM, E_PSEUDO_EXR_REGNUM, BINWORD): Add
	gdbarch	as parameter. Update caller.
	(h8300_init_frame_cache): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* hppa-tdep.c (skip_prologue_hard_way): Add gdbarch as parameter and
	update caller. Replace current_gdbarch by gdbarch.

	* m32c-tdep.c (m32c_skip_trampoline_code): Use get_frame_arch to get at
	the current architecture. Replace current_gdbarch by gdbarch.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Likewise.
	(STACK_CORRECTION, USE_PAGE_REGISTER): Replace M6811_TDEP by its
	expression. Add gdbarch as parameter and replace current_gdbarch with
	it. Update caller.
	(M6811_TDEP): Remove.
	(m68hc11_frame_prev_register): Use get_frame_arch to get at the current
	architecture.
	(m68hc11_scan_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* m68k-tdep.c (m68k_analyze_prologue): Add gdbarch as parameter and
	update caller.
	(m68k_analyze_register_saves): Likewise. Also replace current_gdbarch
	by gdbarch.

	* rs6000-tdep.c (skip_prologue): Add gdbarch as parameter and update
	caller. Relace current_gdbarch by gdbarch.
	(altivec_register_p, spe_register_p): Likewise.
	* ppc-tdep.h (altivec_register_p, spe_register_p): Add gdbarch as
	parameter.
	* ppc-linux-nat.c (fetch_register, store_register): Update caller of
	altivec_register_p and spe_register_p.

	* score-tdep.c (score_fetch_inst): Add gdbarch as parameter. Update
	caller. Replace current_gdbarch by gdbarch.
	(score_analyze_prologue): use get_frame_arch to get at the current
	architecture.

	* sparc-tdep.h (sparc_analyze_prologue): Add gdbarch as parameter.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise. Replace
	current_gdbarch by gdbarch. Update caller.
	(sparc_frame_cache): Use get_frame_arch to get at the current
	architecture.
	* sparce64-tdep.c (sparc64_skip_prologue): Update call of
	sparc_analyze_prologue.

	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Add gdbarch as
	parameter.
@
text
@d165 1
a165 1
ppc_register_u_addr (int regno)
d168 1
a168 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d187 1
a187 1
  if (regno == gdbarch_pc_regnum (current_gdbarch))
d335 1
a335 1
  CORE_ADDR regaddr = ppc_register_u_addr (regno);
d635 1
a635 1
  CORE_ADDR regaddr = ppc_register_u_addr (regno);
@


1.76
log
@	Updated copyright notices for most files.
@
text
@d340 1
a340 1
  if (altivec_register_p (regno))
d355 1
a355 1
  else if (spe_register_p (regno))
d640 1
a640 1
  if (altivec_register_p (regno))
d645 1
a645 1
  else if (spe_register_p (regno))
@


1.75
log
@2007-11-16  Markus Deuling  <deuling@@de.ibm.com>

	* m32r-rom.c (m32r_supply_register): Use get_regcache_arch to get at
	the current architecture by regcache.
	* ppcnbsd-nat.c (ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, fetch_ppc_registers)
	(store_altivec_register, store_spe_register, store_register)
	(fill_vrregset, store_ppc_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Likewise.

	* trad-frame.c (trad_frame_alloc_saved_regs): Replace current_gdbarch by
	gdbarch.
	* user-regs.c (user_reg_map_name_to_regnum): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_return_value): Likewise.
	* m32c-tdep.c (m32c_register_reggroup_p): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.

	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Use get_frame_arch to
	get at the current architecture by frame_info.
	* gcore.c (derive_stack_segment): Likewise.

	* shnbsd-nat.c (GETREGS_SUPPLIES): Add gdbarch parameter.
	(shnbsd_fetch_inferior_registers, shnbsd_store_inferior_registers): Add
	gdbarch to GETREGS_SUPPLIES call.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.74
log
@        * ppc-linux-nat.c (ppc_linux_insert_watchpoint): Move
        saved_dabr_value assignment to the correct position.
@
text
@d230 3
a232 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
d250 1
a250 1
    offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d293 2
a294 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d298 1
a298 1
              == register_size (current_gdbarch, tdep->ppc_ev0_upper_regnum));
d300 1
a300 1
              == register_size (current_gdbarch, tdep->ppc_acc_regnum));
d302 1
a302 1
              == register_size (current_gdbarch, tdep->ppc_spefscr_regnum));
d332 2
a333 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d363 1
a363 1
      memset (buf, '\0', register_size (current_gdbarch, regno));   /* Supply zeroes */
d372 1
a372 1
       bytes_transferred < register_size (current_gdbarch, regno);
d383 1
a383 1
		   gdbarch_register_name (current_gdbarch, regno), regno);
d391 1
a391 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d397 1
a397 1
  else if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d401 1
a401 2
      size_t padding = (bytes_transferred
                        - register_size (current_gdbarch, regno));
d407 1
a407 1
                    gdbarch_byte_order (current_gdbarch));
d414 2
a415 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d417 2
a418 2
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d458 2
a459 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d466 1
a466 1
  fetch_register (regcache, tid, gdbarch_pc_regnum (current_gdbarch));
d514 3
a516 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
d532 1
a532 1
    offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d577 2
a578 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d582 1
a582 1
              == register_size (current_gdbarch, tdep->ppc_ev0_upper_regnum));
d584 1
a584 1
              == register_size (current_gdbarch, tdep->ppc_acc_regnum));
d586 1
a586 1
              == register_size (current_gdbarch, tdep->ppc_spefscr_regnum));
d632 2
a633 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d658 2
a659 3
  bytes_to_transfer = align_up (register_size (current_gdbarch, regno),
                                sizeof (long));
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d664 1
a664 1
  else if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d667 1
a667 2
      size_t padding = (bytes_to_transfer
                        - register_size (current_gdbarch, regno));
d689 1
a689 1
		   gdbarch_register_name (current_gdbarch, regno), regno);
d699 2
a700 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d702 2
a703 2
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d745 2
a746 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d753 1
a753 1
  store_register (regcache, tid, gdbarch_pc_regnum (current_gdbarch));
@


1.73
log
@	* ppc-linux-nat.c (ppc_linux_read_description): New.
	(_initialize_ppc_linux_nat): Set to_read_description.
	* ppc-tdep.h (tdesc_powerpc_e500): Declare.
@
text
@d834 2
d839 1
a839 1
  saved_dabr_value = dabr_value;
@


1.72
log
@	* ppc-linux-nat.c (ppc_linux_stopped_data_address): Cast
	pointer to uintptr_t before casting to CORE_ADDR.
@
text
@d943 27
d992 2
@


1.71
log
@	* linux-nat.c (linux_nat_new_thread): New variable.
	(linux_child_follow_fork): Set inferior_ptid to include LWP ID.  Use
	linux_nat_switch_fork.
	(lwp_list): Make public.
	(add_lwp): Call linux_nat_new_thread.
	(lin_lwp_attach_lwp, linux_nat_attach): Call add_lwp after stopping
	the new thread.
	(resume_callback): Clear lp->siginfo.  Remove unused variable.
	(linux_nat_resume): Assert that the LWP list is already initialized.
	Clear lp->siginfo.
	(save_siginfo): New.
	(stop_wait_callback, linux_nat_wait): Call it.
	(linux_nat_set_new_thread, linux_nat_get_siginfo): New.
	* linux-nat.h (struct lwp_info): Add siginfo.
	(lwp_list, linux_nat_set_new_thread, linux_nat_get_siginfo): Declare.
	(ALL_LWPS): Define.

	* amd64-linux-nat.c (amd64_linux_dr): New.
	(amd64_linux_dr_get): Take a PTID argument.  Correct typo.
	(amd64_linux_dr_set): Take a PTID argument.
	(amd64_linux_dr_set_control, amd64_linux_dr_set_addr): Use ALL_LWPS.
	(amd64_linux_dr_reset_addr): Use amd64_linux_dr_set_addr.
	(amd64_linux_dr_get_status): Pass inferior_ptid to amd64_linux_dr_get.
	(amd64_linux_new_thread): New.
	(_initialize_amd64_linux_nat): Call linux_nat_set_new_thread.
	* i386-linux-nat.c (i386_linux_dr): New.
	(i386_linux_dr_get, i386_linux_dr_set): Take a PTID argument.
	(i386_linux_dr_set_control, i386_linux_dr_set_addr): Use ALL_LWPS.
	(i386_linux_dr_reset_addr): Use i386_linux_dr_set_addr.
	(i386_linux_dr_get_status): Pass inferior_ptid to i386_linux_dr_get.
	(i386_linux_new_thread): New.
	(i386_linux_resume): Remove unnecessary PID check.
	(_initialize_i386_linux_nat): Call linux_nat_set_new_thread.
	* ia64-linux-nat.c (enable_watchpoints_in_psr): Take PTID argument.
	(fetch_debug_register, fetch_debug_register_pair): Delete.
	(debug_registers): New.
	(ia64_linux_insert_watchpoint, ia64_linux_remove_watchpoint): Use
	ALL_LWPS and debug_registers.
	(ia64_linux_new_thread): New.
	(ia64_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(_initialize_ia64_linux_nat): Call linux_nat_set_new_thread.
	* ppc-linux-nat.c (last_stopped_data_address): Delete.
	(saved_dabr_value): New.
	(ppc_linux_insert_watchpoint, ppc_linux_remove_watchpoint): Use
	ALL_LWPS.
	(ppc_linux_new_thread): New.
	(ppc_linux_stopped_data_address): Use linux_nat_get_siginfo.
	(ppc_linux_stopped_by_watchpoint): Call ppc_linux_stopped_data_address.
	(_initialize_ppc_linux_nat): Call linux_nat_set_new_thread.
	* s390-nat.c (s390_stopped_by_watchpoint): Clear the watchpoint status
	after reading it.
	(s390_fix_watch_points): Take a PTID argument.
	(s390_insert_watchpoint, s390_remove_watchpoint): Use ALL_LWPS.
	(_initialize_s390_nat): Call linux_nat_set_new_thread.
@
text
@d872 1
a872 1
  *addr_p = (CORE_ADDR) siginfo_p->si_addr;
@


1.70
log
@	* ppc-linux-nat.c (right_fill_reg): Delete.
	(supply_gregset): Use ppc_supply_gregset.
	(supply_fpregset): Use ppc_supply_fpregset.
	(fill_gregset): Use ppc_collect_gregset.
	(fill_fpregset): Use ppc_collect_fpregset.
	* ppc-linux-tdep.c (PPC_LINUX_PT_*): Don't define.
	(right_supply_register, ppc_linux_supply_gregset): Delete.
	(ppc32_linux_supply_gregset, ppc64_linux_supply_gregset): Delete.
	(ppc_linux_supply_fpregset): Delete.
	(ppc_linux_collect_gregset): New function.
	(ppc32_linux_reg_offsets, ppc64_linux_reg_offsets): New.
	(ppc32_linux_gregset, ppc64_linux_gregset): Update to use reg offsets,
	ppc_linux_supply_gregset, and ppc_collect_gregset.
	(ppc_linux_fpregset): Rename to ppc32_linux_fpregset and update.
	(ppc_linux_gregset, ppc_linux_fpregset): New functions.
	(ppc_linux_regset_from_core_section): Update.
	* ppc-tdep.h (ppc_linux_gregset, ppc_linux_fpregset): Declare.
	(ppc_linux_supply_gregset, ppc_linux_supply_fpregset): Delete.
	(struct ppc_reg_offsets): Add gpr_size, xr_size, fpscr_size fields.
	* ppcobsd-tdep.c (ppcobsd_supply_gregset): Delete FIXME and assert.
	(ppcobsd_collect_gregset): Likewise.
	(_initialize_ppcnbsd_tdep): Init gpr_size, xr_size, fpscr_size.
	* ppcnbsd-tdep.c (_initialize_ppcobsd_tdep): Likewise.
	* ppcobsd-nat.c (_initialize_ppcobsd_nat): Likewise.
	* rs6000-aix-tdep.c (rs6000_aix32_reg_offsets): Likewise.
	(rs6000_aix64_reg_offsets): Likewise.
	(rs6000_aix_supply_regset): Call ppc_supply_fpregset without testing
	ppc_floating_point_unit_p.
	(rs6000_aix_collect_regset): Similarly.
	* rs6000-tdep.c (ppc_supply_reg): Add regsize param.  Adjust offset
	when regsize is larger than regcache register size.
	(ppc_collect_reg): Similarly zero pad when regsize is larger than
	regcache register size.
	(ppc_greg_offset): New function, split out from..
	(ppc_supply_gregset): ..here.  Separate code handling all regs from
	single reg case.  Correct xer offset.
	(ppc_fpreg_offset): New function, split out from..
	(ppc_supply_fpregset): ..here.  Separate code handling all regs from
	single reg case.
	(ppc_collect_gregset, ppc_collect_fpregset): Likewise.
	(ppc_supply_fpregset, ppc_collect_fpregset): Don't assert we have
	a fp unit, instead return if no fp.
@
text
@a144 2
static CORE_ADDR last_stopped_data_address = 0;

d806 3
d813 2
a814 1
  int tid;
a815 1
  ptid_t ptid = inferior_ptid;
d834 5
a838 5
  tid = TIDGET (ptid);
  if (tid == 0)
    tid = PIDGET (ptid);

  return ptrace (PTRACE_SET_DEBUGREG, tid, 0, dabr_value);
d844 9
a852 8
  int tid;
  ptid_t ptid = inferior_ptid;

  tid = TIDGET (ptid);
  if (tid == 0)
    tid = PIDGET (ptid);

  return ptrace (PTRACE_SET_DEBUGREG, tid, 0, 0);
d855 2
a856 2
static int
ppc_linux_stopped_data_address (struct target_ops *target, CORE_ADDR *addr_p)
d858 1
a858 7
  if (last_stopped_data_address)
    {
      *addr_p = last_stopped_data_address;
      last_stopped_data_address = 0;
      return 1;
    }
  return 0;
d862 1
a862 1
ppc_linux_stopped_by_watchpoint (void)
d864 1
a864 4
  int tid;
  struct siginfo siginfo;
  ptid_t ptid = inferior_ptid;
  CORE_ADDR *addr_p;
d866 1
a866 3
  tid = TIDGET(ptid);
  if (tid == 0)
    tid = PIDGET (ptid);
d868 2
a869 5
  errno = 0;
  ptrace (PTRACE_GETSIGINFO, tid, (PTRACE_TYPE_ARG3) 0, &siginfo);

  if (errno != 0 || siginfo.si_signo != SIGTRAP ||
      (siginfo.si_code & 0xffff) != 0x0004)
d872 1
a872 1
  last_stopped_data_address = (uintptr_t) siginfo.si_addr;
d876 7
d967 1
@


1.69
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d904 6
d913 1
a913 6
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (long);
  ppc_linux_supply_gregset (regcache, -1, gregsetp,
			    sizeof (gdb_gregset_t), wordsize);
}
d915 1
a915 11
static void
right_fill_reg (const struct regcache *regcache, int regnum, void *reg)
{
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (long);
  /* Right fill the register.  */
  regcache_raw_collect (regcache, regnum,
			((bfd_byte *) reg
			 + wordsize
			 - register_size (current_gdbarch, regnum)));
d922 5
a926 36
  int regi;
  elf_greg_t *regp = (elf_greg_t *) gregsetp;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
  const int elf_ngreg = 48;


  /* Start with zeros.  */
  memset (regp, 0, elf_ngreg * sizeof (*regp));

  for (regi = 0; regi < ppc_num_gprs; regi++)
    {
      if ((regno == -1) || regno == tdep->ppc_gp0_regnum + regi)
	right_fill_reg (regcache, tdep->ppc_gp0_regnum + regi,
			(regp + PT_R0 + regi));
    }

  if ((regno == -1) || regno == gdbarch_pc_regnum (current_gdbarch))
    right_fill_reg (regcache, gdbarch_pc_regnum (current_gdbarch),
		    regp + PT_NIP);
  if ((regno == -1) || regno == tdep->ppc_lr_regnum)
    right_fill_reg (regcache, tdep->ppc_lr_regnum, regp + PT_LNK);
  if ((regno == -1) || regno == tdep->ppc_cr_regnum)
    regcache_raw_collect (regcache, tdep->ppc_cr_regnum,
			  regp + PT_CCR);
  if ((regno == -1) || regno == tdep->ppc_xer_regnum)
    regcache_raw_collect (regcache, tdep->ppc_xer_regnum,
			  regp + PT_XER);
  if ((regno == -1) || regno == tdep->ppc_ctr_regnum)
    right_fill_reg (regcache, tdep->ppc_ctr_regnum, regp + PT_CTR);
#ifdef PT_MQ
  if (((regno == -1) || regno == tdep->ppc_mq_regnum)
      && (tdep->ppc_mq_regnum != -1))
    right_fill_reg (regcache, tdep->ppc_mq_regnum, regp + PT_MQ);
#endif
  if ((regno == -1) || regno == tdep->ppc_ps_regnum)
    right_fill_reg (regcache, tdep->ppc_ps_regnum, regp + PT_MSR);
d932 4
a935 2
  ppc_linux_supply_fpregset (NULL, regcache, -1, fpregsetp,
			     sizeof (gdb_fpregset_t));
a937 4
/* Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's
   idea of the current floating point register set.  If REGNO is -1,
   update them all.  */
d942 4
a945 15
  int regi;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
  bfd_byte *fpp = (void *) fpregsetp;
  
  if (ppc_floating_point_unit_p (current_gdbarch))
    {
      for (regi = 0; regi < ppc_num_fprs; regi++)
        {
          if ((regno == -1) || (regno == tdep->ppc_fp0_regnum + regi))
            regcache_raw_collect (regcache, tdep->ppc_fp0_regnum + regi,
				  fpp + 8 * regi);
        }
      if (regno == -1 || regno == tdep->ppc_fpscr_regnum)
        right_fill_reg (regcache, tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
    }
@


1.68
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.67
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d191 1
a191 1
  if (regno == PC_REGNUM)
d466 1
a466 1
  fetch_register (regcache, tid, PC_REGNUM);
d750 1
a750 1
  store_register (regcache, tid, PC_REGNUM);
d949 3
a951 2
  if ((regno == -1) || regno == PC_REGNUM)
    right_fill_reg (regcache, PC_REGNUM, regp + PT_NIP);
@


1.66
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d384 1
a384 1
		   REGISTER_NAME (regno), regno);
d688 1
a688 1
		   REGISTER_NAME (regno), regno);
@


1.65
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d657 1
a657 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d662 1
a662 1
  else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
@


1.64
log
@	* gregset.h (struct regcache): Add forward declaration.
	(supply_gregset): Add REGCACHE parameter, make GREGS const.
	(supply_fpregset): Add REGCACHE parameter, make FPREGS const.
	(supply_fpxregset): Add REGCACHE parameter, make FPXREGS const.
	(fill_gregset): Add REGCACHE parameter.
	(fill_fpregset): Likewise.
	(fill_fpxregset): Likewise.

	Update all definitions accordingly:
	* alphabsd-nat.c, alpha-linux-nat.c, alpha-nat.c, amd64-linux-nat.c,
	arm-linux-nat.c, hppa-linux-nat.c, i386gnu-nat.c, i386-linux-nat.c,
	i386-sol2-nat.c, i386v4-nat.c, ia64-linux-nat.c, irix5-nat.c,
	m32r-linux-nat.c, m68klinux-nat.c, mips-linux-nat.c, ppc-linux-nat.c,
	s390-nat.c, sparc64-linux-nat.c, sparc-linux-nat.c, sparc-sol2-nat.c
	(supply_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make GREGSETP parameter const, adapt casts.
	(supply_fpregset): Add REGCACHE parameter, use it instead of
	current_regcache.  Make FPREGSETP parameter const, adapt casts.
	(fill_gregset): Add REGCACHE parameter, use it instead of
	current_regcache.
	(fill_fpregset): Likewise.

	Update all callers to pass in current_regcache as the new argument:
	* core-regset.c: Include "regcache.h".
	(fetch_core_registers): Update supply_gregset,and supply_fpregset calls.
	* procfs.c: Include "regcache.h".
	(procfs_fetch_registers): Update supply_gregset, supply_fpregset calls.
	(procfs_store_registers): Update fill_gregset, fill_fpregset calls.
	(procfs_do_thread_registers): Likewise.
	(procfs_make_note_section): Likewise.
	* proc-service.c: Include "regcache.h".
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.
	* sol-thread.c (sol_thread_fetch_registers): Update supply_gregset,
	supply_fpregset calls.
	(sol_thread_store_registers): Update fill_gregset, fill_fpregset calls.
	(ps_lgetregs): Update fill_gregset call.
	(ps_lsetregs): Update supply_gregset call.
	(ps_lgetfpregs): Update fill_fpregset call.
	(ps_lsetfpregs): Update supply_fpregset call.

	* linux-nat.c (linux_nat_do_thread_registers): Update fill_gregset,
	fill_fpregset, and fill_fpxregset calls.
	* i386-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_fpxregs): Update supply_fpxregset call.
	(store_fpxregs): Update fill_fpxregset call.
	* m32r-linux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	* m68klinux-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.
	(fetch_core_registers): Update supply_gregset, supply_fpregset calls.
	* s390-nat.c (fetch_regs): Update supply_gregset call.
	(store_regs): Update fill_gregset call.
	(fetch_fpregs): Update supply_fpregset call.
	(store_fpregs): Update fill_fpregset call.

	* Makefile.in (core-regset.o, procfs.o, proc-service.o): Update
	dependencies.
@
text
@d229 1
a229 1
fetch_altivec_register (int tid, int regno)
d255 1
a255 1
  regcache_raw_supply (current_regcache, regno,
d294 1
a294 1
fetch_spe_register (int tid, int regno)
d313 1
a313 1
        regcache_raw_supply (current_regcache, tdep->ppc_ev0_upper_regnum + i,
d318 1
a318 1
    regcache_raw_supply (current_regcache, regno,
d323 1
a323 1
    regcache_raw_supply (current_regcache, tdep->ppc_acc_regnum, &evrregs.acc);
d327 1
a327 1
    regcache_raw_supply (current_regcache, tdep->ppc_spefscr_regnum,
d332 1
a332 1
fetch_register (int tid, int regno)
d349 1
a349 1
         fetch_altivec_register (tid, regno);
d358 1
a358 1
      fetch_spe_register (tid, regno);
d365 1
a365 1
      regcache_raw_supply (current_regcache, regno, buf);
d396 1
a396 1
      regcache_raw_supply (current_regcache, regno, buf);
d404 1
a404 1
      regcache_raw_supply (current_regcache, regno, buf + padding);
d413 1
a413 1
supply_vrregset (gdb_vrregset_t *vrregsetp)
d428 1
a428 1
        regcache_raw_supply (current_regcache, tdep->ppc_vr0_regnum + i,
d431 1
a431 1
        regcache_raw_supply (current_regcache, tdep->ppc_vr0_regnum + i,
d437 1
a437 1
fetch_altivec_registers (int tid)
d452 1
a452 1
  supply_vrregset (&regs);
d456 1
a456 1
fetch_ppc_registers (int tid)
d462 1
a462 1
    fetch_register (tid, tdep->ppc_gp0_regnum + i);
d465 2
a466 2
      fetch_register (tid, tdep->ppc_fp0_regnum + i);
  fetch_register (tid, PC_REGNUM);
d468 1
a468 1
    fetch_register (tid, tdep->ppc_ps_regnum);
d470 1
a470 1
    fetch_register (tid, tdep->ppc_cr_regnum);
d472 1
a472 1
    fetch_register (tid, tdep->ppc_lr_regnum);
d474 1
a474 1
    fetch_register (tid, tdep->ppc_ctr_regnum);
d476 1
a476 1
    fetch_register (tid, tdep->ppc_xer_regnum);
d478 1
a478 1
    fetch_register (tid, tdep->ppc_mq_regnum);
d480 1
a480 1
    fetch_register (tid, tdep->ppc_fpscr_regnum);
d483 1
a483 1
      fetch_altivec_registers (tid);
d485 1
a485 1
    fetch_spe_register (tid, -1);
d492 1
a492 1
ppc_linux_fetch_inferior_registers (int regno)
d502 1
a502 1
    fetch_ppc_registers (tid);
d504 1
a504 1
    fetch_register (tid, regno);
d509 1
a509 1
store_altivec_register (int tid, int regno)
d533 1
a533 1
  regcache_raw_collect (current_regcache, regno,
d574 1
a574 1
store_spe_register (int tid, int regno)
d602 1
a602 1
        regcache_raw_collect (current_regcache,
d608 1
a608 1
    regcache_raw_collect (current_regcache, regno,
d613 1
a613 1
    regcache_raw_collect (current_regcache,
d619 1
a619 1
    regcache_raw_collect (current_regcache,
d628 1
a628 1
store_register (int tid, int regno)
d639 1
a639 1
      store_altivec_register (tid, regno);
d644 1
a644 1
      store_spe_register (tid, regno);
d660 1
a660 1
      regcache_raw_collect (current_regcache, regno, buf);
d667 1
a667 1
      regcache_raw_collect (current_regcache, regno, buf + padding);
d695 1
a695 1
fill_vrregset (gdb_vrregset_t *vrregsetp)
d708 1
a708 1
        regcache_raw_collect (current_regcache, tdep->ppc_vr0_regnum + i,
d711 1
a711 1
        regcache_raw_collect (current_regcache, tdep->ppc_vr0_regnum + i,
d717 1
a717 1
store_altivec_registers (int tid)
d733 1
a733 1
  fill_vrregset (&regs);
d740 1
a740 1
store_ppc_registers (int tid)
d746 1
a746 1
    store_register (tid, tdep->ppc_gp0_regnum + i);
d749 2
a750 2
      store_register (tid, tdep->ppc_fp0_regnum + i);
  store_register (tid, PC_REGNUM);
d752 1
a752 1
    store_register (tid, tdep->ppc_ps_regnum);
d754 1
a754 1
    store_register (tid, tdep->ppc_cr_regnum);
d756 1
a756 1
    store_register (tid, tdep->ppc_lr_regnum);
d758 1
a758 1
    store_register (tid, tdep->ppc_ctr_regnum);
d760 1
a760 1
    store_register (tid, tdep->ppc_xer_regnum);
d762 1
a762 1
    store_register (tid, tdep->ppc_mq_regnum);
d764 1
a764 1
    store_register (tid, tdep->ppc_fpscr_regnum);
d767 1
a767 1
      store_altivec_registers (tid);
d769 1
a769 1
    store_spe_register (tid, -1);
d891 1
a891 1
ppc_linux_store_inferior_registers (int regno)
d901 1
a901 1
    store_register (tid, regno);
d903 1
a903 1
    store_ppc_registers (tid);
d960 1
a960 1
    right_fill_reg (tdep->ppc_ctr_regnum, regp + PT_CTR);
d998 1
a998 1
        right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
@


1.63
log
@	* core-aout.c: Delete file.
	* Makefile.in (ALLDEPFILES): Remove core-aout.c.
	(core-aout.o): Delete rule.
	* gdbcore.h (kernel_u_addr, KERNEL_U_ADDR): Remove.

        * config/alpha/nm-linux.h (U_REGS_OFFSET): Remove.

        * arm-linux-nat.c (arm_linux_kernel_u_size): Remove.
        * config/arm/nm-linux.h (U_REGS_OFFSET, KERNEL_U_SIZE,
        KERNEL_U_ADDR): Remove.

        * i386-linux-nat.c (register_u_addr, kernel_u_size): Remove.
        (cannot_fetch_register, cannot_store_register): Remove.
        (fetch_register): Inline cannot_fetch_register and register_addr.
        (store_register): Inline cannot_store_register and register_addr.
        * config/i386/linux.mh (NATDEPFILES): Remove core-aout.o.
        * config/i386/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR,
        REGISTER_U_ADDR, CANNOT_FETCH_REGISTER, CANNOT_STORE_REGISTER):
        Remove.

        * m68klinux-nat.c (m68k_linux_register_u_addr, kernel_u_size): Remove.
        (fetch_register): Inline register_addr.
        (store_register): Inline register_addr.
        * config/m68k/linux.mh (NATDEPFILES): Remove core-aout.o.
        * config/m68k/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR,
        U_REGS_OFFSET, REGISTER_U_ADDR): Remove.

        * config/mips/nm-irix5.h (REGISTER_U_ADDR): Remove.
        * config/mips/nm-linux.h (KERNEL_U_SIZE, U_REGS_OFFSET,
        REGISTER_U_ADDR): Remove.

        * hppa-linux-nat.c (register_addr): Rename to ...
        (hppa_linux_register_addr): ... this.  Make static.
        (fetch_register, store_register): Adapt callers.
        * config/pa/nm-linux.h (U_REGS_OFFSET): Remove.

        * ppc-linux-nat.c (kernel_u_size): Remove.
        * config/powerpc/nm-linux.h (KERNEL_U_SIZE, KERNEL_U_ADDR): Remove.

	* vax-nat.c (vax_kernel_u_addr, vax_register_u_addr): Make static.
	* config/vax/vax.mh (NATDEPFILES): Remove core-aout.o.
	(NAT_FILE): Remove.
	* config/vax/nm-vax.h: Delete file.
@
text
@d907 1
a907 1
supply_gregset (gdb_gregset_t *gregsetp)
d912 1
a912 1
  ppc_linux_supply_gregset (current_regcache, -1, gregsetp,
d917 1
a917 1
right_fill_reg (int regnum, void *reg)
d923 1
a923 1
  regcache_raw_collect (current_regcache, regnum,
d930 2
a931 1
fill_gregset (gdb_gregset_t *gregsetp, int regno)
d945 2
a946 1
	right_fill_reg (tdep->ppc_gp0_regnum + regi, (regp + PT_R0 + regi));
d950 1
a950 1
    right_fill_reg (PC_REGNUM, regp + PT_NIP);
d952 1
a952 1
    right_fill_reg (tdep->ppc_lr_regnum, regp + PT_LNK);
d954 1
a954 1
    regcache_raw_collect (current_regcache, tdep->ppc_cr_regnum,
d957 1
a957 1
    regcache_raw_collect (current_regcache, tdep->ppc_xer_regnum,
d964 1
a964 1
    right_fill_reg (tdep->ppc_mq_regnum, regp + PT_MQ);
d967 1
a967 1
    right_fill_reg (tdep->ppc_ps_regnum, regp + PT_MSR);
d971 1
a971 1
supply_fpregset (gdb_fpregset_t * fpregsetp)
d973 1
a973 1
  ppc_linux_supply_fpregset (NULL, current_regcache, -1, fpregsetp,
d982 2
a983 1
fill_fpregset (gdb_fpregset_t *fpregsetp, int regno)
d994 1
a994 1
            regcache_raw_collect (current_regcache, tdep->ppc_fp0_regnum + regi,
@


1.62
log
@Copyright updates for 2007.
@
text
@a154 6
int
kernel_u_size (void)
{
  return (sizeof (struct user));
}

@


1.61
log
@2006-05-05:  Paul Gilliam  <pgilliam@@us.ibm.com>

        * ppc-linux-nat.c: Clean up types for ptrace.
        Replace (CORE_ADDR) with  (uintptr_t) to avoid the size difference
        between a CORE_ADDR and a void* on ppc64 systems compiled for 32-bits.
@
text
@d3 2
a4 2
   Copyright (C) 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002,
   2003, 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.60
log
@	* linux-nat.c (linux_ops_saved): New.
	(super_mourn_inferior, kill_inferior, threaded, linux_nat_ops)
	(child_mourn_inferior, child_wait, linux_nat_create_inferior)
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior, init_linux_nat_ops): Delete.
	(init_lwp_list): Don't set threaded.
	(add_lwp): Don't modify threaded.
	(delete_lwp): Don't mention non-threaded mode.
	(linux_nat_switch_fork): New.
	(linux_nat_attach): Update inferior_ptid.
	(linux_nat_wait): Handle num_lwps == 0 at entry.  Don't check
	threaded flag.
	(linux_nat_kill): Handle pending forks and saved forks.
	(linux_nat_mourn_inferior): Handle saved forks.
	(linux_nat_pid_to_str): Don't use the LWP form when there is
	only one thread.
	(linux_target): Don't set to_wait, to_kill, or to_mourn_inferior.
	(linux_nat_add_target): New.
	(_initialize_linux_nat): Don't initialize the linux native target
	here.
	* linux-nat.h (linux_nat_add_target, linux_nat_switch_fork): New
	prototypes.
	* linux-fork.c: Include "linux-nat.h".
	(add_fork): Update initial PID.
	(fork_load_infrun_state): Call linux_nat_switch_fork.
	* Makefile.in (linux-fork.o): Update.

	* alpha-linux-nat.c (_initialize_alpha_linux_nat): Use
	linux_nat_add_target instead of add_target.
	* amd64-linux-nat.c (_initialize_amd64_linux_nat): Likewise.
	* arm-linux-nat.c (_initialize_arm_linux_nat): Likewise.
	* hppa-linux-nat.c (_initialize_hppa_linux_nat): Likewise.
	* ia64-linux-nat.c (_initialize_ia64_linux_nat): Likewise.
	* i386-linux-nat.c (_initialize_i386_linux_nat): Likewise.
	* m32r-linux-nat.c (_initialize_m32r_linux_nat): Likewise.
	* m68klinux-nat.c (_initialize_m68k_linux_nat): Likewise.
	* mips-linux-nat.c (_initialize_mips_linux_nat): Likewise.
	* ppc-linux-nat.c (_initialize_ppc_linux_nat): Likewise.
	* s390-nat.c (_initialize_s390_nat): Likewise.
	* sparc-linux-nat.c (_initialize_sparc_linux_nat): Likewise.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Likewise.
@
text
@d33 1
a47 12
#ifndef PT_READ_U
#define PT_READ_U PTRACE_PEEKUSR
#endif
#ifndef PT_WRITE_U
#define PT_WRITE_U PTRACE_POKEUSR
#endif

/* Default the type of the ptrace transfer to int.  */
#ifndef PTRACE_XFER_TYPE
#define PTRACE_XFER_TYPE int
#endif

d118 6
a123 7
   However, the ordinary Linux kernel PTRACE_PEEKUSR / PTRACE_POKEUSR
   / PT_READ_U / PT_WRITE_U ptrace calls only access the lower half of
   each register, to allow them to behave the same way they do on
   non-SPE systems.  There's a separate pair of calls,
   PTRACE_GETEVRREGS / PTRACE_SETEVRREGS, that read and write the top
   halves of all the general-purpose registers at once, along with
   some SPE-specific registers.
d181 1
a181 1
  int wordsize = sizeof (PTRACE_XFER_TYPE);
d375 1
a375 1
  /* Read the raw register using PTRACE_XFER_TYPE sized chunks.  On a
d380 1
a380 1
       bytes_transferred += sizeof (PTRACE_XFER_TYPE))
d383 3
a385 3
      *(PTRACE_XFER_TYPE *) & buf[bytes_transferred]
        = ptrace (PT_READ_U, tid, (PTRACE_ARG3_TYPE) regaddr, 0);
      regaddr += sizeof (PTRACE_XFER_TYPE);
d397 1
a397 1
     (PTRACE_XFER_TYPE).  */
d659 1
a659 1
     (PTRACE_XFER_TYPE).  */
d662 1
a662 1
                                sizeof (PTRACE_XFER_TYPE));
d676 1
a676 1
  for (i = 0; i < bytes_to_transfer; i += sizeof (PTRACE_XFER_TYPE))
d679 3
a681 3
      ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
	      *(PTRACE_XFER_TYPE *) & buf[i]);
      regaddr += sizeof (PTRACE_XFER_TYPE);
d892 1
a892 1
  last_stopped_data_address = (CORE_ADDR) siginfo.si_addr;
d917 1
a917 1
  int wordsize = sizeof (PTRACE_XFER_TYPE);
d927 1
a927 1
  int wordsize = sizeof (PTRACE_XFER_TYPE);
@


1.59
log
@	* ppc-linux-nat.c (ppc_linux_insert_watchpoint): Correct return type.
	(ppc_linux_remove_watchpoint): Likewise, and args.
@
text
@d1040 1
a1040 1
  add_target (t);
@


1.58
log
@	* config/i386/nm-i386sol2.h: Update copyright year.
        * config/mips/nm-irix5.h: Ditto.
        * config/sparc/nm-sol2.h: Ditto.
        * s390-nat.c: Ditto.
        * ppc-linux-nat.c: Ditto.
@
text
@d829 1
a829 1
static long
d860 2
a861 2
static long
ppc_linux_remove_watchpoint (CORE_ADDR addr, int len)
@


1.57
log
@	* ppc-linux-nat.c (PTRACE_GET_DEBUGREG, PTRACE_SET_DEBUGREG,
	PTRACE_GETSIGINFO): Define.
	(last_stopped_data_address): New.
	(ppc_linux_check_watch_resources): New function.
	(ppc_linux_region_ok_for_hw_watchpoint): New function.
	(ppc_linux_insert_watchpoint): New function.
	(ppc_linux_remove_watchpoint): New function.
	(ppc_linux_stopped_data_address): New function.
	(ppc_linux_stopped_by_watchpoint): New function.
	(_initialize_ppc_linux_nat): Set the above hardware watchpoint
	related target vectors.
	* rs6000-tdep.c (rs6000_gdbarch_init): Set PPC architectures
	to have nonsteppable watchpoint.
	* target.c (default_region_ok_for_hw_watchpoint,
	debug_to_region_ok_for_hw_watchpoint): New prototypes.
	(update_current_target): Inherit to_region_ok_for_hw_watchpoint
	and set default to_region_ok_for_hw_watchpoint.
	(default_region_ok_for_hw_watchpoint): New function.
	(debug_to_region_ok_for_hw_watchpoint): New function.
	(setup_target_debug): Set to_region_ok_for_hw_watchpoint of
	debug_target.
	* target.h (struct target_ops): Add a new target vector
	to_region_ok_for_hw_watchpoint.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT): Define this if it is not
	defined anyplace else.
@
text
@d4 1
a4 1
   2003, 2004, 2005 Free Software Foundation, Inc.
@


1.56
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d84 10
d159 1
a166 1

d790 118
d1031 8
@


1.55
log
@	* Makefile.in (ALLDEPFILES): Update.
	(alpha-linux-nat.o, sparc-linux-nat.o): New rules.
	(amd64-linux-nat.o, arm-linux-nat.o, hppa-linux-nat.o)
	(i386-linux-nat.o, ia64-linux-nat.o, linux-nat.o, m32r-linux-nat.o)
	(m68klinux-nat.o, mips-linux-nat.o, ppc-linux-nat.o, s390-nat.o)
	(sparc64-linux-nat.o): Update dependencies.
	* alpha-linux-nat.c, sparc-linux-nat.c: New files.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(amd64_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(amd64_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_amd64_linux_nat): Set it.  Call linux_target and
	add_target.
	* arm-linux-nat.c (arm_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(arm_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_arm_linux_nat): Add a prototype.  Use linux_target and
	add_target.
	* hppa-linux-nat.c (hppa_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(hppa_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_hppa_linux_nat): New function.
	* i386-linux-nat.c (i386_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(i386_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(i386_linux_resume): Renamed from child_resume and made static.
	(i386_linux_child_post_start_inferior): Renamed from
	child_post_startup_inferior and made static.  Call
	super_post_startup_inferior.
	(super_post_startup_inferior): New.
	(_initialize_i386_linux_nat): New function.
	* i386-nat.c: Remove LINUX_CHILD_POST_STARTUP_INFERIOR #ifndef.
	* ia64-linux-nat.c (ia64_linux_xfer_unwind_table): Remove.
	(super_xfer_partial): New.
	(ia64_linux_xfer_partial): New function.  Use it.
	(_initialize_ia64_linux_nat): New function.
	* ia64-tdep.c (getunwind_table): Revert 2005-06-08 change; use
	target_read_partial and document the problem.
	* inf-ptrace.c (inf_ptrace_fetch_register): Use
	CANNOT_FETCH_REGISTER.  Fix some comments.
	(inf_ptrace_store_register): Use CANNOT_STORE_REGISTER.  Fix some
	comments.
	* linux-nat.c: Include "inf-ptrace.h" and "auxv.h".
	(linux_ops, super_xfer_partial): New variables.
	(linux_child_post_startup_inferior): Make static.
	(child_post_startup_inferior): Delete.
	(linux_nat_attach, linux_nat_detach, resume_callback)
	(linux_nat_resume, linux_nat_wait, linux_nat_create_inferior)
	(linux_nat_mourn_inferior): Use linux_ops instead of
	deprecated_child_ops.
	(child_wait): Do not depend on CHILD_WAIT.
	(linux_nat_xfer_memory): Remove, replace by ...
	(linux_nat_xfer_partial): ... this.  Use linux_ops->to_xfer_partial
	instead of linux_proc_xfer_memory and child_xfer_memory.
	(linux_nat_fetch_registers, linux_nat_store_registers)
	(linux_nat_child_post_startup_inferior): New functions.
	(init_linux_nat_ops): Use the new functions.
	(linux_proc_xfer_memory): Remove, replace by ...
	(linux_proc_xfer_partial): ... this.  Make static.
	(linux_xfer_partial, linux_register_u_offset, linux_target): New
	functions.
	(_initialize_linux_nat): Do not modify deprecated_child_ops.
	* linux-nat.h (linux_proc_xfer_memory): Remove prototype.
	(struct mem_attrib, struct target_ops): Remove forward declarations.
	(linux_child_post_startup_inferior): Remove prototype.
	(linux_target): Add prototype.
	* linux-thread-db.c (thread_db_xfer_memory): Remove, replace by ...
	(thread_db_xfer_partial): ... this.
	(init_thread_db_ops): Set to_xfer_partial instead of
	deprecated_xfer_memory.
	* m32r-linux-nat.c (m32r_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m32r_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_m32r_linux_nat): New function.
	* m68klinux-nat.c (m68k_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(m68k_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(old_fetch_inferior_registers, old_store_inferior_registers): Made
	static.
	(_initialize_m68k_linux_nat): Use linux_target and add_target.
	* mips-linux-nat.c (_initialize_mips_linux_nat): New function.
	* ppc-linux-nat.c (ppc_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(ppc_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_ppc_linux_nat): New function.
	* s390-nat.c (s390_linux_fetch_inferior_registers): Renamed
	from fetch_inferior_registers and made static.
	(s390_linux_store_inferior_registers): Renamed from
	store_inferior_registers and made static.
	(_initialize_s390_nat): New function.
	* sparc64-linux-nat.c (_initialize_sparc64_linux_nat): Use
	linux_target and add_target.
	* config/nm-linux.h: Don't include "auxv.h".
	(struct target_waitstatus, child_wait, CHILD_WAIT)
	(CHILD_PID_TO_EXEC_FILE, CHILD_INSERT_FORK_CATCHPOINT)
	(CHILD_INSERT_VFORK_CATCHPOINT, CHILD_INSERT_EXEC_CATCHPOINT)
	(CHILD_POST_STARTUP_INFERIOR, CHILD_POST_ATTACH, CHILD_FOLLOW_FORK)
	(DEPRECATED_KILL_INFERIOR, NATIVE_XFER_AUXV): Delete.
	* config/alpha/alpha-linux.mh (NATDEPFILES): Replace infptrace.o
	and inftarg.o with inf-ptrace.o and alpha-linux-nat.o.
	* config/sparc/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with sparc-linux-nat.o.
	* config/sparc/linux64.mh (NATDEPFILES): Remove infptrace.o and
	inftarg.o.
	* config/arm/linux.mh (NATDEPFILES): Replace infptrace.o and
	inftarg.o with inf-ptrace.o.
	* config/i386/linux.mh (NATDEPFILES): Likewise.
	* config/i386/linux64.mh (NATDEPFILES): Likewise.
	* config/ia64/linux.mh (NATDEPFILES): Likewise.
	* config/m32r/linux.mh (NATDEPFILES): Likewise.
	* config/m68k/linux.mh (NATDEPFILES): Likewise.
	* config/mips/linux.mh (NATDEPFILES): Likewise.
	* config/pa/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/linux.mh (NATDEPFILES): Likewise.
	* config/powerpc/ppc64-linux.mh (NATDEPFILES): Likewise.
	* config/s390/s390.mh (NATDEPFILES): Likewise.
	* config/i386/nm-linux.h (DEPRECATED_CHILD_RESUME): Don't define.
	(LINUX_CHILD_POST_STARTUP_INFERIOR): Don't define.
	* config/i386/nm-linux64.h (LINUX_CHILD_POST_STARTUP_INFERIOR):
	Don't define.
	* config/ia64/nm-linux.h: Don't include "target.h".
	(NATIVE_XFER_UNWIND_TABLE, ia64_linux_xfer_unwind_table): Remove.
	* config/djgpp/fnchange.lst: Add alpha-linux-tdep.c,
	alpha-linux-nat.c, sparc-linux-tdep.c, and sparc-linux-nat.c.
@
text
@d3 1
a3 1
   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.54
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d4 1
a4 1
   2003 Free Software Foundation, Inc.
d30 2
d499 2
a500 2
void
fetch_inferior_registers (int regno)
d780 2
a781 2
void
store_inferior_registers (int regno)
d888 18
@


1.53
log
@2005-02-08  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-nat.c (ppc_register_u_addr): Hack around 64-bit
	PT_FPSCR breakage.
@
text
@d251 1
a251 1
      perror_with_name ("Unable to fetch AltiVec register");
d288 1
a288 1
            perror_with_name ("Unable to fetch SPE registers");
d414 1
a414 1
                    "fetch_register: unexpected byte order: %d",
d456 1
a456 1
      perror_with_name ("Unable to fetch AltiVec registers");
d531 1
a531 1
      perror_with_name ("Unable to fetch AltiVec register");
d544 1
a544 1
    perror_with_name ("Unable to store AltiVec register");
d571 1
a571 1
            perror_with_name ("Unable to set SPE registers");
d736 1
a736 1
      perror_with_name ("Couldn't get AltiVec registers");
d742 1
a742 1
    perror_with_name ("Couldn't write AltiVec registers");
@


1.52
log
@* ppc-linux-nat.c (fetch_register): Replace 'gdb_assert (0)' with
a call to 'internal_error', with a more helpful error message.
* rs6000-tdep.c (e500_pseudo_register_read,
e500_pseudo_register_write): Same.
@
text
@d215 13
a227 2
    u_addr = PT_FPSCR * wordsize;

@


1.51
log
@Change the layout of the PowerPC E500 raw register cache to allow
the lower 32-bit halves of the GPRS to be their own raw registers,
not pseudoregisters.
* ppc-tdep.h (struct gdbarch_tdep): Remove ppc_gprs_pseudo_p flag;
add ppc_ev0_upper_regnum flag.
* rs6000-tdep.c: #include "reggroups.h".
(spe_register_p): Recognize the ev upper half registers as SPE
registers.
(init_sim_regno_table): Build gdb->sim mappings for the upper-half
registers.
(e500_move_ev_register): New function.
(e500_pseudo_register_read, e500_pseudo_register_write): The 'ev'
vector registers are the pseudo-registers now, formed by splicing
together the gprs and the upper-half registers.
(e500_register_reggroup_p): New function.
(P): Macro deleted.
(P8, A4): New macro.
(PPC_EV_REGS, PPC_GPRS_PSEUDO_REGS): Macros deleted.
(PPC_SPE_GP_REGS, PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): New
macros.
(registers_e500): Rearrange register set so that the raw register
set contains 32-bit GPRs and upper-half registers, and the SPE
vector registers become pseudo-registers.
(rs6000_gdbarch_init): Don't initialize tdep->ppc_gprs_pseudo_p;
it has been deleted.  Initialize ppc_ev0_upper_regnum.  Many other
register numbers are now the same for the E500 as they are for
other PowerPC variants.  Register e500_register_reggroup_p as the
register group function for the E500.
* Makefile.in (rs6000-tdep.o): Update dependencies.

Adapt PPC E500 native support to the new raw regcache layout.
* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fixes.
(read_spliced_spe_reg, write_spliced_spe_reg): Deleted.
(fetch_spe_register, store_spe_register): Handle fetching/storing
all the SPE registers at once, if regno == -1.  These now take
over the job of fetch_spe_registers and store_spe_registers.
(fetch_spe_registers, store_spe_registers): Deleted.
(fetch_ppc_registers, store_ppc_registers): Fetch/store gprs
unconditionally; they're always raw.  Fetch/store SPE upper half
registers, if present, instead of ev registers.
(fetch_register, store_register): Remove sanity checks: gprs are
never pseudo-registers now, so we never need to even mention any
registers that are ever pseudoregisters.
@
text
@d402 3
a404 1
    gdb_assert (0);
@


1.50
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d126 4
a129 6
   bits long; the full 64-bit registers are called 'ev0' -- 'ev31'.
   The ev registers are raw registers, and the GPR's are pseudo-
   registers mapped onto their lower halves.  This means that reading
   and writing ev registers involves a mix of regset-at-once
   PTRACE_{GET,SET}EVRREGS calls and register-at-a-time
   PTRACE_{PEEK,POKE}USR calls.
d284 4
a287 70
/* Assuming TID refers to an SPE process, store the full 64-bit value
   of TID's ev register EV_REGNUM in DEST, getting the high bits from
   EVRREGS and the low bits from the kernel via ptrace.  */
static void
read_spliced_spe_reg (int tid, int ev_regnum,
                      struct gdb_evrregset_t *evrregs,
                      char *dest)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* Make sure we're trying to read an EV register; that's all we
     handle.  */
  gdb_assert (tdep->ppc_ev0_regnum <= ev_regnum
              && ev_regnum <= tdep->ppc_ev31_regnum);

  /* Make sure the sizes for the splicing add up.  */
  gdb_assert (sizeof (evrregs->evr[0]) + sizeof (PTRACE_XFER_TYPE)
              == register_size (current_gdbarch, ev_regnum));

  {
    /* The index of ev_regnum in evrregs->evr[].  */
    int ev_index = ev_regnum - tdep->ppc_ev0_regnum;

    /* The number of the corresponding general-purpose register, which
       holds the lower 32 bits of the EV register.  */
    int gpr_regnum = tdep->ppc_gp0_regnum + ev_index;

    /* The offset of gpr_regnum in the process's uarea.  */
    CORE_ADDR gpr_uoffset = ppc_register_u_addr (gpr_regnum);

    /* The low word of the EV register's value.  */
    PTRACE_XFER_TYPE low_word;

    /* The PTRACE_PEEKUSR / PT_READ_U ptrace requests need to be able
       to return arbitrary register values, so they can't return -1 to
       indicate an error.  So we clear errno, and then check it after
       the call.  */
    errno = 0;
    low_word = ptrace (PT_READ_U, tid, (PTRACE_ARG3_TYPE) gpr_uoffset, 0);
  
    if (errno != 0)
      {
        char message[128];
        sprintf (message, "reading register %s (#%d)",
                 REGISTER_NAME (ev_regnum), ev_regnum);
        perror_with_name (message);
      }

    if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
      {
        memcpy (dest, &evrregs->evr[ev_index],
                sizeof (evrregs->evr[ev_index]));
        * (PTRACE_XFER_TYPE *) (dest + sizeof (evrregs->evr[ev_index]))
          = low_word;
      }
    else if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
      {
        * (PTRACE_XFER_TYPE *) dest = low_word;
        memcpy (dest + sizeof (PTRACE_XFER_TYPE),
                &evrregs->evr[ev_index], sizeof (evrregs->evr[ev_index]));
      }
    else
      gdb_assert (0);
  }
}


/* On SPE machines, supply the full value of the SPE register REGNO
   from TID.  This handles ev0 -- ev31 and acc, which are 64 bits
   long, and spefscr, which is 32 bits long.  */
d294 7
d303 1
a303 2
  if (tdep->ppc_ev0_regnum <= regno
      && regno <= tdep->ppc_ev31_regnum)
d305 19
a323 18
      char buf[MAX_REGISTER_SIZE];
      read_spliced_spe_reg (tid, regno, &evrregs, buf);
      regcache_raw_supply (current_regcache, regno, buf);
    }
  else if (regno == tdep->ppc_acc_regnum)
    {
      gdb_assert (sizeof (evrregs.acc)
                  == register_size (current_gdbarch, regno));
      regcache_raw_supply (current_regcache, regno, &evrregs.acc);
    }
  else if (regno == tdep->ppc_spefscr_regnum)
    {
      gdb_assert (sizeof (evrregs.spefscr)
                  == register_size (current_gdbarch, regno));
      regcache_raw_supply (current_regcache, regno, &evrregs.spefscr);
    }
  else
    gdb_assert (0);
a335 6
  /* Sanity check: this function should only be called to fetch raw
     registers' values, never pseudoregisters' values.  */
  if (tdep->ppc_gp0_regnum <= regno
      && regno < tdep->ppc_gp0_regnum + ppc_num_gprs)
    gdb_assert (! tdep->ppc_gprs_pseudo_p);

a447 27
/* On SPE machines, fetch the full 64 bits of all the general-purpose
   registers, as well as the SPE-specific registers 'acc' and
   'spefscr'.  */
static void
fetch_spe_registers (int tid)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct gdb_evrregset_t evrregs;
  int i;

  get_spe_registers (tid, &evrregs);

  /* Splice and supply each of the EV registers.  */
  for (i = 0; i < ppc_num_gprs; i++)
    {
      char buf[MAX_REGISTER_SIZE];

      read_spliced_spe_reg (tid, tdep->ppc_ev0_regnum + i, &evrregs, buf);
      regcache_raw_supply (current_regcache, tdep->ppc_ev0_regnum + i, buf);
    }

  /* Supply the SPE-specific registers.  */
  regcache_raw_supply (current_regcache, tdep->ppc_acc_regnum, &evrregs.acc);
  regcache_raw_supply (current_regcache, tdep->ppc_spefscr_regnum,
		       &evrregs.spefscr);
}

d454 2
a455 3
  if (! tdep->ppc_gprs_pseudo_p)
    for (i = 0; i < ppc_num_gprs; i++)
      fetch_register (tid, tdep->ppc_gp0_regnum + i);
d477 2
a478 2
  if (tdep->ppc_ev0_regnum >= 0)
    fetch_spe_registers (tid);
d563 3
a565 62
/* Store the bytes at SRC as the contents of TID's EV register EV_REGNUM.
   Write the less significant word to TID using ptrace, and copy the
   more significant word to the appropriate slot in EVRREGS.  */
static void
write_spliced_spe_reg (int tid, int ev_regnum,
                       struct gdb_evrregset_t *evrregs,
                       char *src)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  /* Make sure we're trying to write an EV register; that's all we
     handle.  */
  gdb_assert (tdep->ppc_ev0_regnum <= ev_regnum
              && ev_regnum <= tdep->ppc_ev31_regnum);

  /* Make sure the sizes for the splicing add up.  */
  gdb_assert (sizeof (evrregs->evr[0]) + sizeof (PTRACE_XFER_TYPE)
              == register_size (current_gdbarch, ev_regnum));

  {
    int ev_index = ev_regnum - tdep->ppc_ev0_regnum;

    /* The number of the corresponding general-purpose register, which
       holds the lower 32 bits of the EV register.  */
    int gpr_regnum = tdep->ppc_gp0_regnum + ev_index;

    /* The offset of gpr_regnum in the process's uarea.  */
    CORE_ADDR gpr_uoffset = ppc_register_u_addr (gpr_regnum);

    /* The PTRACE_POKEUSR / PT_WRITE_U ptrace requests need to be able
       to return arbitrary register values, so they can't return -1 to
       indicate an error.  So we clear errno, and check it again
       afterwards.  */
    errno = 0;

    if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
      {
        memcpy (&evrregs->evr[ev_index], src, sizeof (evrregs->evr[ev_index]));
        ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) gpr_uoffset,
                * (PTRACE_XFER_TYPE *) (src + sizeof (evrregs->evr[0])));
      }
    else if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
      {
        ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) gpr_uoffset,
                * (PTRACE_XFER_TYPE *) src);
        memcpy (&evrregs->evr[ev_index], src + sizeof (PTRACE_XFER_TYPE),
                sizeof (evrregs->evr[ev_index]));
      }
    else 
      gdb_assert (0);

    if (errno != 0)
      {
        char message[128];
        sprintf (message, "writing register %s (#%d)", 
                 REGISTER_NAME (ev_regnum), ev_regnum);
        perror_with_name (message);
      }
  }
}

/* Write GDB's value for the SPE register REGNO to TID.  */
d572 17
a588 4
  /* We can only read and write the entire EVR register set at a time,
     so to write just a single register, we do a read-modify-write
     maneuver.  */
  get_spe_registers (tid, &evrregs);
d590 1
a590 2
  if (tdep->ppc_ev0_regnum >= 0
      && tdep->ppc_ev0_regnum <= regno && regno <= tdep->ppc_ev31_regnum)
d592 23
a614 20
      char buf[MAX_REGISTER_SIZE];
      regcache_raw_collect (current_regcache, regno, buf);
      write_spliced_spe_reg (tid, regno, &evrregs, buf);
    }
  else if (tdep->ppc_acc_regnum >= 0
           && regno == tdep->ppc_acc_regnum)
    {
      gdb_assert (sizeof (evrregs.acc)
                  == register_size (current_gdbarch, regno));
      regcache_raw_collect (current_regcache, regno, &evrregs.acc);
    }
  else if (tdep->ppc_spefscr_regnum >= 0
           && regno == tdep->ppc_spefscr_regnum)
    {
      gdb_assert (sizeof (evrregs.spefscr)
                  == register_size (current_gdbarch, regno));
      regcache_raw_collect (current_regcache, regno, &evrregs.spefscr);
    }
  else
    gdb_assert (0);
a629 6
  /* Sanity check: this function should only be called to store raw
     registers' values, never pseudoregisters' values.  */
  if (tdep->ppc_gp0_regnum <= regno
      && regno < tdep->ppc_gp0_regnum + ppc_num_gprs)
    gdb_assert (! tdep->ppc_gprs_pseudo_p);

a732 30
store_spe_registers (int tid)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct gdb_evrregset_t evrregs;
  int i;

  /* The code below should store to every field of evrregs; if that
     doesn't happen, make it obvious by initializing it with
     suspicious values.  */
  memset (&evrregs, 42, sizeof (evrregs));

  for (i = 0; i < ppc_num_gprs; i++)
    {
      char buf[MAX_REGISTER_SIZE];

      regcache_raw_collect (current_regcache, tdep->ppc_ev0_regnum + i, buf);
      write_spliced_spe_reg (tid, tdep->ppc_ev0_regnum + i, &evrregs, buf);
    }

  gdb_assert (sizeof (evrregs.acc)
              == register_size (current_gdbarch, tdep->ppc_acc_regnum));
  regcache_raw_collect (current_regcache, tdep->ppc_acc_regnum, &evrregs.acc);
  gdb_assert (sizeof (evrregs.spefscr)
              == register_size (current_gdbarch, tdep->ppc_spefscr_regnum));
  regcache_raw_collect (current_regcache, tdep->ppc_acc_regnum, &evrregs.spefscr);

  set_spe_registers (tid, &evrregs);
}

static void
d738 2
a739 3
  if (! tdep->ppc_gprs_pseudo_p)
    for (i = 0; i < ppc_num_gprs; i++)
      store_register (tid, tdep->ppc_gp0_regnum + i);
d761 2
a762 2
  if (tdep->ppc_ev0_regnum >= 0)
    store_spe_registers (tid);
@


1.49
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d232 1
a232 1
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d250 1
a250 1
    offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d426 1
a426 1
      memset (buf, '\0', DEPRECATED_REGISTER_RAW_SIZE (regno));   /* Supply zeroes */
d478 2
a479 2
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d603 1
a603 1
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d619 1
a619 1
    offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d838 2
a839 2
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
@


1.48
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d621 2
a622 2
  regcache_collect (regno,
                    regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
d735 1
a735 1
      regcache_collect (regno, buf);
d743 1
a743 1
      regcache_collect (regno, &evrregs.acc);
d750 1
a750 1
      regcache_collect (regno, &evrregs.spefscr);
d846 2
a847 2
        regcache_collect (tdep->ppc_vr0_regnum + i,
                          *vrregsetp + i * vrregsize + offset);
d849 2
a850 1
        regcache_collect (tdep->ppc_vr0_regnum + i, *vrregsetp + i * vrregsize);
d893 1
a893 1
      regcache_collect (tdep->ppc_ev0_regnum + i, buf);
d899 1
a899 1
  regcache_collect (tdep->ppc_acc_regnum, &evrregs.acc);
d902 1
a902 1
  regcache_collect (tdep->ppc_acc_regnum, &evrregs.spefscr);
d1003 2
a1004 1
    regcache_collect (tdep->ppc_cr_regnum, regp + PT_CCR);
d1006 2
a1007 1
    regcache_collect (tdep->ppc_xer_regnum, regp + PT_XER);
d1042 2
a1043 1
            regcache_collect (tdep->ppc_fp0_regnum + regi, fpp + 8 * regi);
@


1.47
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-nat.c (store_spe_registers): Eliminate K&R C.
	* tui/tui-win.c (tui_get_cmd_list): Ditto.
	* symfile-mem.c (_initialize_symfile_mem): Ditto.
@
text
@d252 2
a253 2
  supply_register (regno,
                   regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
d369 1
a369 1
      supply_register (regno, buf);
d375 1
a375 1
      supply_register (regno, &evrregs.acc);
d381 1
a381 1
      supply_register (regno, &evrregs.spefscr);
d427 1
a427 1
      supply_register (regno, buf);
d488 2
a489 2
        supply_register (tdep->ppc_vr0_regnum + i,
                         *vrregsetp + i * vrregsize + offset);
d491 2
a492 1
        supply_register (tdep->ppc_vr0_regnum + i, *vrregsetp + i * vrregsize);
d533 1
a533 1
      supply_register (tdep->ppc_ev0_regnum + i, buf);
d537 3
a539 2
  supply_register (tdep->ppc_acc_regnum, &evrregs.acc);
  supply_register (tdep->ppc_spefscr_regnum, &evrregs.spefscr);
@


1.46
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Add [sic] to Linux.
	* ppc-linux-nat.c: Use "Linux kernel".
	* hppa-linux-tdep.c: Use GNU/Linux.
	* hppa-linux-nat.c: Use GNU/Linux.
	* dwarfread.c: Add [sic] to use of Linux.
@
text
@d875 1
a875 1
store_spe_registers (tid)
@


1.45
log
@Add native Linux support for the PowerPC E500.
* ppc-tdep.h (struct gdbarch_tdep): New member: 'ppc_gprs_pseudo_p'.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize it to false on
all architectures except the E500.
* ppc-linux-nat.c: (PTRACE_GETEVRREGS, PTRACE_SETEVRREGS): New
#definitions.
(struct gdb_evrregset_t): New type.
(have_ptrace_getsetevrregs): New variable.
(get_spe_registers, read_spliced_spe_reg, fetch_spe_register,
fetch_spe_registers): New functions.
(fetch_register): Call fetch_spe_register as appropriate.
Assert that we're only passed raw register numbers.
(fetch_ppc_registers): Call fetch_spe_registers as appropriate.
Don't fetch gprs if they're pseudoregisters.
(set_spe_registers, write_spliced_spe_reg, store_spe_register,
store_spe_registers): New functions.
(store_register): Call store_spe_register as appropriate.
Assert that we're only passed raw register numbers.
(store_ppc_registers): Call store_spe_registers as appropriate.
Don't store gprs if they're pseudoregisters.
@
text
@d117 2
a118 2
   However, the ordinary Linux PTRACE_PEEKUSR / PTRACE_POKEUSR /
   PT_READ_U / PT_WRITE_U ptrace calls only access the lower half of
@


1.45.2.1
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-tdep.c (ppc_linux_init_abi): Add [sic] to Linux.
	* ppc-linux-nat.c: Use "Linux kernel".
	* hppa-linux-tdep.c: Use GNU/Linux.
	* hppa-linux-nat.c: Use GNU/Linux.
	* dwarfread.c: Add [sic] to use of Linux.
@
text
@d117 2
a118 2
   However, the ordinary Linux kernel PTRACE_PEEKUSR / PTRACE_POKEUSR
   / PT_READ_U / PT_WRITE_U ptrace calls only access the lower half of
@


1.45.2.2
log
@2004-07-17  Andrew Cagney  <cagney@@gnu.org>

	* ppc-linux-nat.c (store_spe_registers): Eliminate K&R C.
	* tui/tui-win.c (tui_get_cmd_list): Ditto.
	* symfile-mem.c (_initialize_symfile_mem): Ditto.
@
text
@d875 1
a875 1
store_spe_registers (int tid)
@


1.45.2.2.2.1
log
@gdb/ChangeLog:
2004-08-25  Jim Blandy  <jimb@@redhat.com>

	Merge changes from trunk:

	2004-08-09  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (set_sim_regno, init_sim_regno_table,
	rs6000_register_sim_regno): Doc fixes.

	2004-08-04  Jim Blandy  <jimb@@redhat.com>

	* ppc-linux-nat.c (fetch_register): Replace 'gdb_assert (0)' with
	a call to 'internal_error', with a more helpful error message.
	* rs6000-tdep.c (e500_pseudo_register_read,
	e500_pseudo_register_write, rs6000_store_return_value): Same.

	Change the layout of the PowerPC E500 raw register cache to allow
	the lower 32-bit halves of the GPRS to be their own raw registers,
	not pseudoregisters.
	* ppc-tdep.h (struct gdbarch_tdep): Remove ppc_gprs_pseudo_p flag;
	add ppc_ev0_upper_regnum flag.
	* rs6000-tdep.c: #include "reggroups.h".
	(spe_register_p): Recognize the ev upper half registers as SPE
	registers.
	(init_sim_regno_table): Build gdb->sim mappings for the upper-half
	registers.
	(e500_move_ev_register): New function.
	(e500_pseudo_register_read, e500_pseudo_register_write): The 'ev'
	vector registers are the pseudo-registers now, formed by splicing
	together the gprs and the upper-half registers.
	(e500_register_reggroup_p): New function.
	(P): Macro deleted.
	(P8, A4): New macro.
	(PPC_EV_REGS, PPC_GPRS_PSEUDO_REGS): Macros deleted.
	(PPC_SPE_GP_REGS, PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): New
	macros.
	(registers_e500): Rearrange register set so that the raw register
	set contains 32-bit GPRs and upper-half registers, and the SPE
	vector registers become pseudo-registers.
	(rs6000_gdbarch_init): Don't initialize tdep->ppc_gprs_pseudo_p;
	it has been deleted.  Initialize ppc_ev0_upper_regnum.  Many other
	register numbers are now the same for the E500 as they are for
	other PowerPC variants.  Register e500_register_reggroup_p as the
	register group function for the E500.
	* Makefile.in (rs6000-tdep.o): Update dependencies.

	Adapt PPC E500 native support to the new raw regcache layout.
	* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fixes.
	(read_spliced_spe_reg, write_spliced_spe_reg): Deleted.
	(fetch_spe_register, store_spe_register): Handle fetching/storing
	all the SPE registers at once, if regno == -1.  These now take
	over the job of fetch_spe_registers and store_spe_registers.
	(fetch_spe_registers, store_spe_registers): Deleted.
	(fetch_ppc_registers, store_ppc_registers): Fetch/store gprs
	unconditionally; they're always raw.  Fetch/store SPE upper half
	registers, if present, instead of ev registers.
	(fetch_register, store_register): Remove sanity checks: gprs are
	never pseudo-registers now, so we never need to even mention any
	registers that are ever pseudoregisters.

	Use a fixed register numbering when communicating with the PowerPC
	simulator.
	* ppc-tdep.h (struct gdbarch_tdep): New member: 'sim_regno'.
	* rs6000-tdep.c: #include "sim-regno.h" and "gdb/sim-ppc.h".
	(set_sim_regno, init_sim_regno_table, rs6000_register_sim_regno):
	New functions.
	(rs6000_gdbarch_init): Register rs6000_register_sim_regno.  Call
	init_sim_regno_table.
	* Makefile.in (gdb_sim_ppc_h): New variable.
	(rs6000-tdep.o): Update dependencies.

	2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	...
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.

	2004-07-20  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (rs6000_gdbarch_init): The register set used for
	bfd_mach_ppc has no segment registers.

	Include PowerPC SPR numbers for special-purpose registers.
	* rs6000-tdep.c (struct reg): Add new member, 'spr_num'.
	(R, R4, R8, R16, F, P, R32, R64, R0): Include value for
	new member in initializer.
	(S, S4, SN4, S64): New macros for defining special-purpose
	registers.
	(PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS, PPC_OEA_SPRS, registers_power,
	registers_403, registers_403GC, registers_505, registers_860,
	registers_601, registers_602, registers_603, registers_604,
	registers_750, registers_e500): Use them.

	* rs6000-tdep.c (rs6000_gdbarch_init): Delete variable 'power';
	replace references with expression used to initialize variable.

	2004-07-16  Jim Blandy  <jimb@@redhat.com>

	* ppc-tdep.h (ppc_spr_asr): Add missing OEA SPR.
        (ppc_spr_mi_dbcam, ppc_spr_mi_dbram0, ppc_spr_mi_dbram1)
	(ppc_spr_md_cam, ppc_spr_md_ram0, ppc_spr_md_ram1): Add
	missing MPC823 SPRs.
	(ppc_spr_m_twb): Renamed from ppc_spr_md_twb; the old name was
	incorrect.  (This was corrected in GDB's register name tables on
	2004-07-14.)

	* rs6000-tdep.c (registers_602): Correct register name: "esassr"
	should be "esasrr" ("ESA Save and Restore Register").

	2004-07-15  Jim Blandy  <jimb@@redhat.com>

	* ppc-tdep.h (struct gdbarch_tdep): New member: ppc_sr0_regnum.
	* rs6000-tdep.c (rs6000_gdbarch_init): Initialize it.

	2004-07-14  Jim Blandy  <jimb@@redhat.com>

	* rs6000-tdep.c (COMMON_UISA_NOFP_REGS): Delete; unused.

	* ppc-tdep.h (ppc_num_vrs): New enum constant.

	* ppc-tdep.h (ppc_num_srs): New enum constant.

	* ppc-tdep.h (ppc_spr_mq, ppc_spr_xer, ppc_spr_rtcu, ppc_spr_rtcl)
	(ppc_spr_lr, ppc_spr_ctr, ppc_spr_cnt, ppc_spr_dsisr, ppc_spr_dar)
	(ppc_spr_dec, ppc_spr_sdr1, ppc_spr_srr0, ppc_spr_srr1)
	(ppc_spr_eie, ppc_spr_eid, ppc_spr_nri, ppc_spr_sp, ppc_spr_cmpa)
	(ppc_spr_cmpb, ppc_spr_cmpc, ppc_spr_cmpd, ppc_spr_icr)
	(ppc_spr_der, ppc_spr_counta, ppc_spr_countb, ppc_spr_cmpe)
	(ppc_spr_cmpf, ppc_spr_cmpg, ppc_spr_cmph, ppc_spr_lctrl1)
	(ppc_spr_lctrl2, ppc_spr_ictrl, ppc_spr_bar, ppc_spr_vrsave)
	(ppc_spr_sprg0, ppc_spr_sprg1, ppc_spr_sprg2, ppc_spr_sprg3)
	(ppc_spr_ear, ppc_spr_tbl, ppc_spr_tbu, ppc_spr_pvr)
	(ppc_spr_spefscr, ppc_spr_ibat0u, ppc_spr_ibat0l, ppc_spr_ibat1u)
	(ppc_spr_ibat1l, ppc_spr_ibat2u, ppc_spr_ibat2l, ppc_spr_ibat3u)
	(ppc_spr_ibat3l, ppc_spr_dbat0u, ppc_spr_dbat0l, ppc_spr_dbat1u)
	(ppc_spr_dbat1l, ppc_spr_dbat2u, ppc_spr_dbat2l, ppc_spr_dbat3u)
	(ppc_spr_dbat3l, ppc_spr_ic_cst, ppc_spr_ic_adr, ppc_spr_ic_dat)
	(ppc_spr_dc_cst, ppc_spr_dc_adr, ppc_spr_dc_dat, ppc_spr_dpdr)
	(ppc_spr_dpir, ppc_spr_immr, ppc_spr_mi_ctr, ppc_spr_mi_ap)
	(ppc_spr_mi_epn, ppc_spr_mi_twc, ppc_spr_mi_rpn, ppc_spr_mi_cam)
	(ppc_spr_mi_ram0, ppc_spr_mi_ram1, ppc_spr_md_ctr, ppc_spr_m_casid)
	(ppc_spr_md_ap, ppc_spr_md_epn, ppc_spr_md_twb, ppc_spr_md_twc)
	(ppc_spr_md_rpn, ppc_spr_m_tw, ppc_spr_md_dbcam, ppc_spr_md_dbram0)
	(ppc_spr_md_dbram1, ppc_spr_ummcr0, ppc_spr_upmc1, ppc_spr_upmc2)
	(ppc_spr_usia, ppc_spr_ummcr1, ppc_spr_upmc3, ppc_spr_upmc4)
	(ppc_spr_zpr, ppc_spr_pid, ppc_spr_mmcr0, ppc_spr_pmc1)
	(ppc_spr_sgr, ppc_spr_pmc2, ppc_spr_dcwr, ppc_spr_sia)
	(ppc_spr_mmcr1, ppc_spr_pmc3, ppc_spr_pmc4, ppc_spr_sda)
	(ppc_spr_tbhu, ppc_spr_tblu, ppc_spr_dmiss, ppc_spr_dcmp)
	(ppc_spr_hash1, ppc_spr_hash2, ppc_spr_icdbdr, ppc_spr_imiss)
	(ppc_spr_esr, ppc_spr_icmp, ppc_spr_dear, ppc_spr_rpa)
	(ppc_spr_evpr, ppc_spr_cdbcr, ppc_spr_tsr, ppc_spr_602_tcr)
	(ppc_spr_403_tcr, ppc_spr_ibr, ppc_spr_pit, ppc_spr_esasrr)
	(ppc_spr_tbhi, ppc_spr_tblo, ppc_spr_srr2, ppc_spr_sebr)
	(ppc_spr_srr3, ppc_spr_ser, ppc_spr_hid0, ppc_spr_dbsr)
	(ppc_spr_hid1, ppc_spr_iabr, ppc_spr_dbcr, ppc_spr_iac1)
	(ppc_spr_dabr, ppc_spr_iac2, ppc_spr_dac1, ppc_spr_dac2)
	(ppc_spr_l2cr, ppc_spr_dccr, ppc_spr_ictc, ppc_spr_iccr)
	(ppc_spr_thrm1, ppc_spr_pbl1, ppc_spr_thrm2, ppc_spr_pbu1)
	(ppc_spr_thrm3, ppc_spr_pbl2, ppc_spr_fpecr, ppc_spr_lt)
	(ppc_spr_pir, ppc_spr_pbu2): New enum constants for PowerPC
	special-purpose register numbers.

	* rs6000-tdep.c (registers_860): Correct register name.  (No PPC
	manual mentions 'md_twb', but many mention 'm_twb', and at that
	point in the register list.)

include/gdb/ChangeLog:
2004-08-04  Andrew Cagney  <cagney@@gnu.org>

	* sim-ppc.h: Add extern "C" wrapper.
	(enum sim_ppc_regnum): Add full list of SPRs.

2004-08-04  Jim Blandy  <jimb@@redhat.com>

	* sim-ppc.h: New file.

sim/ppc/ChangeLog:
2004-08-04  Andrew Cagney  <cagney@@gnu.org>
	    Jim Blandy <jimb@@redhat.com>

	* sim_callbacks.h (simulator): Declare.
	* Makefile.in (gdb-sim.o): New rule.
	(MAIN_SRC, GDB_OBJ): Add gdb-sim.o, gdb-sim.c.
	(DEFS_H): Delete.
	(GDB_SIM_PPC_H): Define.
	* gdb-sim.c: New file.
	* sim_calls.c: Do not include "defs.h".
	(simulator): Drop static.
	(sim_store_register, sim_fetch_register): Delete.
@
text
@d126 6
a131 4
   bits long.  It has unnamed raw registers that hold the upper halves
   of the gprs, and the the full 64-bit SIMD views of the registers,
   'ev0' -- 'ev31', are pseudo-registers that splice the top and
   bottom halves together.
d232 1
a232 1
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
d250 1
a250 1
    offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d252 2
a253 2
  regcache_raw_supply (current_regcache, regno,
		       regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
d286 70
a355 4
/* Supply values from TID for SPE-specific raw registers: the upper
   halves of the GPRs, the accumulator, and the spefscr.  REGNO must
   be the number of an upper half register, acc, spefscr, or -1 to
   supply the values of all registers.  */
a361 7
  gdb_assert (sizeof (evrregs.evr[0])
              == register_size (current_gdbarch, tdep->ppc_ev0_upper_regnum));
  gdb_assert (sizeof (evrregs.acc)
              == register_size (current_gdbarch, tdep->ppc_acc_regnum));
  gdb_assert (sizeof (evrregs.spefscr)
              == register_size (current_gdbarch, tdep->ppc_spefscr_regnum));

d364 14
a377 1
  if (regno == -1)
d379 6
a384 19
      int i;

      for (i = 0; i < ppc_num_gprs; i++)
        regcache_raw_supply (current_regcache, tdep->ppc_ev0_upper_regnum + i,
                             &evrregs.evr[i]);
    }
  else if (tdep->ppc_ev0_upper_regnum <= regno
           && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    regcache_raw_supply (current_regcache, regno,
                         &evrregs.evr[regno - tdep->ppc_ev0_upper_regnum]);

  if (regno == -1
      || regno == tdep->ppc_acc_regnum)
    regcache_raw_supply (current_regcache, tdep->ppc_acc_regnum, &evrregs.acc);

  if (regno == -1
      || regno == tdep->ppc_spefscr_regnum)
    regcache_raw_supply (current_regcache, tdep->ppc_spefscr_regnum,
                         &evrregs.spefscr);
d397 6
d426 2
a427 2
      memset (buf, '\0', register_size (current_gdbarch, regno));   /* Supply zeroes */
      regcache_raw_supply (current_regcache, regno, buf);
d469 1
a469 3
    internal_error (__FILE__, __LINE__,
                    "fetch_register: unexpected byte order: %d",
                    gdbarch_byte_order (current_gdbarch));
d478 2
a479 2
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d488 2
a489 2
        regcache_raw_supply (current_regcache, tdep->ppc_vr0_regnum + i,
			     *vrregsetp + i * vrregsize + offset);
d491 1
a491 2
        regcache_raw_supply (current_regcache, tdep->ppc_vr0_regnum + i,
			     *vrregsetp + i * vrregsize);
d514 26
d546 3
a548 2
  for (i = 0; i < ppc_num_gprs; i++)
    fetch_register (tid, tdep->ppc_gp0_regnum + i);
d570 2
a571 2
  if (tdep->ppc_ev0_upper_regnum >= 0)
    fetch_spe_register (tid, -1);
d601 1
a601 1
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
d617 1
a617 1
    offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d619 2
a620 2
  regcache_raw_collect (current_regcache, regno,
			regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
d656 62
a717 3
/* Write GDB's value for the SPE-specific raw register REGNO to TID.
   If REGNO is -1, write the values of all the SPE-specific
   registers.  */
d724 4
a727 6
  gdb_assert (sizeof (evrregs.evr[0])
              == register_size (current_gdbarch, tdep->ppc_ev0_upper_regnum));
  gdb_assert (sizeof (evrregs.acc)
              == register_size (current_gdbarch, tdep->ppc_acc_regnum));
  gdb_assert (sizeof (evrregs.spefscr)
              == register_size (current_gdbarch, tdep->ppc_spefscr_regnum));
d729 21
a749 5
  if (regno == -1)
    /* Since we're going to write out every register, the code below
       should store to every field of evrregs; if that doesn't happen,
       make it obvious by initializing it with suspicious values.  */
    memset (&evrregs, 42, sizeof (evrregs));
d751 1
a751 30
    /* We can only read and write the entire EVR register set at a
       time, so to write just a single register, we do a
       read-modify-write maneuver.  */
    get_spe_registers (tid, &evrregs);

  if (regno == -1)
    {
      int i;

      for (i = 0; i < ppc_num_gprs; i++)
        regcache_raw_collect (current_regcache,
                              tdep->ppc_ev0_upper_regnum + i,
                              &evrregs.evr[i]);
    }
  else if (tdep->ppc_ev0_upper_regnum <= regno
           && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    regcache_raw_collect (current_regcache, regno,
                          &evrregs.evr[regno - tdep->ppc_ev0_upper_regnum]);

  if (regno == -1
      || regno == tdep->ppc_acc_regnum)
    regcache_raw_collect (current_regcache,
                          tdep->ppc_acc_regnum,
                          &evrregs.acc);

  if (regno == -1
      || regno == tdep->ppc_spefscr_regnum)
    regcache_raw_collect (current_regcache,
                          tdep->ppc_spefscr_regnum,
                          &evrregs.spefscr);
d767 6
d836 2
a837 2
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d844 2
a845 2
        regcache_raw_collect (current_regcache, tdep->ppc_vr0_regnum + i,
			      *vrregsetp + i * vrregsize + offset);
d847 1
a847 2
        regcache_raw_collect (current_regcache, tdep->ppc_vr0_regnum + i,
			      *vrregsetp + i * vrregsize);
d875 30
d910 3
a912 2
  for (i = 0; i < ppc_num_gprs; i++)
    store_register (tid, tdep->ppc_gp0_regnum + i);
d934 2
a935 2
  if (tdep->ppc_ev0_upper_regnum >= 0)
    store_spe_register (tid, -1);
d1000 1
a1000 2
    regcache_raw_collect (current_regcache, tdep->ppc_cr_regnum,
			  regp + PT_CCR);
d1002 1
a1002 2
    regcache_raw_collect (current_regcache, tdep->ppc_xer_regnum,
			  regp + PT_XER);
d1037 1
a1037 2
            regcache_raw_collect (current_regcache, tdep->ppc_fp0_regnum + regi,
				  fpp + 8 * regi);
@


1.45.2.2.2.2
log
@Allow access to all 64 bits of the SPE GPR's in multi-threaded
programs.
* ppc-tdep.h (struct speregset): New struct type.
* ppc-linux-tdep.c: #include "gdb_assert.h".
(ppc_linux_supply_speregset, ppc_linux_collect_speregset): New
functions.
(ppc_linux_speregset): New structure.
(ppc_linux_init_abi): Describe how to pass the full 64-bit values
of the SPE GPRs across the thread-db interface.
* ppc-linux-nat.c (struct gdb_evrregset_t): Doc fix.
* Makefile.in (ppc-linux-tdep.o): Update dependencies.

Allow targets to specify an extended register set, to be passed
through libthread_db via its 'xregs' functions.
* gdbarch.sh (XREGS_REGSET, XREGS_SIZE, XREGS_NAME): New gdbarch
members.
* gdbarch.c, gdbarch.h: Regenerated.
* proc-service.c: #include "regset.h" and "regcache.h".
(ps_lgetxregsize, ps_lgetxregs, ps_lsetxregs): Fill in real
implementations of these functions.
* thread-db.c: #include "regset.h".
(td_thr_getxregsize_p, td_thr_getxregs_p, td_thr_setxregs_p): New
variables.
(thread_db_load): Initialize them.
(warned_xregs_not_implemented): New variable.
(thread_db_new_objfile): Clear it here.
(thread_db_fetch_registers, thread_db_store_registers): Supply and
collect the xregset, too, if the architecture says it has one, and
libthread_db seems to be able to support it.
* Makefile.in (proc-service.o, thread-db.o): Update dependencies.
@
text
@d132 1
a132 6
   the inferior's registers by PTRACE_SETEVRREGS.

   Note that this is not the same as 'struct speregset', which
   describes how the ABI says the kernel dumps SPE-style 64-bit GPR's
   in core files.  It would be nicer if PTRACE_{GET,SET}EVRREGS and
   core files used the same layout, but they don't.  */
@


1.44
log
@* ppc-linux-nat.c (fetch_register): Don't forget to pass the
gdbarch argument to register_size.
@
text
@d73 10
d114 33
a146 1
/* For runtime check of ptrace support for VRREGS.  */
d149 8
d256 131
d397 6
d418 5
d514 26
d546 3
a548 2
  for (i = 0; i < ppc_num_gprs; i++)
    fetch_register (tid, tdep->ppc_gp0_regnum + i);
d570 2
d627 130
d767 6
d778 5
d875 30
d910 3
a912 2
  for (i = 0; i < ppc_num_gprs; i++)
    store_register (tid, tdep->ppc_gp0_regnum + i);
d934 2
@


1.43
log
@* ppc-linux-nat.c (store_register, fetch_register): Remove
incorrect assertions.  Simplify and generalize handling of
transfers whose sizes are not multiples of, or less than, sizeof
(PTRACE_XFER_TYPE).
@
text
@d243 1
a243 1
       bytes_transferred < register_size (regno);
@


1.42
log
@* ppc-linux-nat.c (store_register): Remove unused local 'offset'.
@
text
@d212 1
a212 1
  int i;
a238 5
  /* If the current architecture has no floating-point registers, we
     should never reach this point: ppc_register_u_addr should have
     returned -1, and we should have caught that above.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

d242 3
a244 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d247 2
a248 2
      *(PTRACE_XFER_TYPE *) & buf[i] = ptrace (PT_READ_U, tid,
					       (PTRACE_ARG3_TYPE) regaddr, 0);
d259 19
a277 13
  /* Now supply the register.  Be careful to map between ptrace's and
     the current_regcache's idea of the current wordsize.  */
  if ((regno >= tdep->ppc_fp0_regnum
       && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)
      || gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
    /* FPs are always 64 bits.  Little endian values are always found
       at the left-hand end of the register.  */
    regcache_raw_supply (current_regcache, regno, buf);
  else
    /* Big endian register, need to fetch the right-hand end.  */
    regcache_raw_supply (current_regcache, regno,
                        (buf + sizeof (PTRACE_XFER_TYPE)
                         - register_size (current_gdbarch, regno)));
d413 1
d425 3
a427 7
  /* If the current architecture has no floating-point registers, we
     should never reach this point: ppc_register_u_addr should have
     returned -1, and we should have caught that above.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

  /* First collect the register value from the regcache.  Be careful
     to to convert the regcache's wordsize into ptrace's wordsize.  */
d429 14
a442 12
  if ((regno >= tdep->ppc_fp0_regnum
       && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)
      || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
    /* Floats are always 64-bit.  Little endian registers are always
       at the left-hand end of the register cache.  */
    regcache_raw_collect (current_regcache, regno, buf);
  else
    /* Big-endian registers belong at the right-hand end of the
       buffer.  */
    regcache_raw_collect (current_regcache, regno,
                         (buf + sizeof (PTRACE_XFER_TYPE)
                          - register_size (current_gdbarch, regno)));
d444 1
a444 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
@


1.41
log
@* ppc-linux-nat.c (store_register, fetch_register): Rename 'mess'
to 'message', and make it local to the lone block that uses it.
@
text
@a409 1
  unsigned int offset;         /* Offset of registers within the u area.  */
@


1.40
log
@* ppc-linux-nat.c (fetch_register): Move code back to be next
to the comment that describes it.  (Moved code, instead of
comment, for symmetry with store_register.)
@
text
@a211 1
  char mess[128];              /* For messages */
d255 2
a256 1
	  sprintf (mess, "reading register %s (#%d)", 
d258 1
a258 1
	  perror_with_name (mess);
a408 1
  char mess[128];              /* For messages */
d459 2
a460 1
	  sprintf (mess, "writing register %s (#%d)", 
d462 1
a462 1
	  perror_with_name (mess);
@


1.39
log
@* aix-thread.c (pdc_read_regs, supply_gprs64, supply_fprs)
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Use
ppc_num_gprs and ppc_num_fprs instead of '32' and '31'.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset)
(ppc_linux_sigtramp_cache): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg)
(ppcnbsd_sigtramp_cache_init): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
(rs6000_frame_cache): Same.
@
text
@d211 1
a215 1
  CORE_ADDR regaddr = ppc_register_u_addr (regno);
@


1.38
log
@* aix-thread.c (supply_gprs64, fetch_regs_user_thread)
(store_regs_user_thread): Use tdep->ppc_gp0_regnum, instead
of assuming that the gprs are numbered starting with zero.
* ppc-linux-nat.c (fill_gregset): Same.
* ppc-linux-tdep.c (ppc_linux_supply_gregset): Same.
* ppcnbsd-nat.c (getregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_fill_reg): Same.
* rs6000-nat.c (fetch_core_registers): Same.
* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset): Same.
@
text
@d593 1
a593 1
  for (regi = 0; regi < 32; regi++)
@


1.37
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@d595 2
a596 2
      if ((regno == -1) || regno == regi)
	right_fill_reg (regi, (regp + PT_R0 + regi));
@


1.36
log
@Back out change.  The NetBSD changes need Jason Thorpe's approval, but
he hasn't reviewed it yet.
@
text
@d29 1
d143 2
a144 1
  if (regno >= tdep->ppc_fp0_regnum
d165 2
a166 1
  if (regno == tdep->ppc_fpscr_regnum)
d240 5
d423 5
d452 1
a452 1
          && regno == gdbarch_tdep (current_gdbarch)->ppc_fpscr_regnum)
d636 1
a636 1
  for (regi = 0; regi < 32; regi++)
d638 7
a644 2
      if ((regno == -1) || (regno == tdep->ppc_fp0_regnum + regi))
	regcache_collect (tdep->ppc_fp0_regnum + regi, fpp + 8 * regi);
a645 2
  if ((regno == -1) || regno == tdep->ppc_fpscr_regnum)
    right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
@


1.35
log
@* ppc-tdep.h (struct gdbarch_tdep): Change definition of
ppc_fp0_regnum and ppc_fpscr_regnum: if they are -1, then this
processor variant lacks those registers.
(ppc_floating_point_unit_p): Change description to make it clear
that this returns info about the ISA, not the ABI.
* rs6000-tdep.c (ppc_floating_point_unit_p): Decide whether to
return true or false by checking tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum.  The original code replicated the BFD
arch/mach switching done in rs6000_gdbarch_init; it's better to
keep that logic there, and just check the results here.
(rs6000_gdbarch_init): On the E500, set tdep->ppc_fp0_regnum and
tdep->ppc_fpscr_regnum to -1 to indicate that we have no
floating-point registers.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_store_return_value): Assert that we have floating-point
registers.
(rs6000_dwarf2_stab_reg_to_regnum): Add FIXME.
(rs6000_frame_cache): Don't note the locations at which
floating-point registers were saved if we have no fprs.
* aix-thread.c (supply_fprs, fill_fprs): Assert that we have FP
registers.
(fetch_regs_user_thread, fetch_regs_kernel_thread)
(store_regs_user_thread, store_regs_kernel_thread): Only call
supply_fprs / fill_fprs if we actually have floating-point
registers.
(special_register_p): Check ppc_fpscr_regnum before matching
against it.
(supply_sprs64, supply_sprs32, fill_sprs64, fill_sprs32): Don't
supply / collect fpscr if we don't have it.
* ppc-bdm.c: #include "gdb_assert.h".
(bdm_ppc_fetch_registers, bdm_ppc_store_registers): Assert that we
have floating-point registers, since I can't test this code on
FP-free systems to adapt it.
* ppc-linux-nat.c (ppc_register_u_addr): Don't match against the
fpscr and floating point register numbers if they don't exist.
(fetch_register): Assert that we have floating-point registers
before we reach the code that handles them.
(store_register): Same.  And use tdep instead of calling
gdbarch_tdep again.
(fill_fpregset): Don't try to collect FP registers and fpscr if we
don't have them.
(ppc_linux_sigtramp_cache): Don't record the saved locations of
fprs and fpscr if we don't have them.
(ppc_linux_supply_fpregset): Don't supply fp regs and fpscr if we
don't have them.
* ppcnbsd-nat.c: #include "gdb_assert.h".
(getfpregs_supplies): Assert that we have floating-point registers.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg): Same.
* ppcobsd-tdep.c: #include "gdb_assert.h".
(ppcobsd_supply_gregset, ppcobsd_collect_gregset): Assert that we
have floating-point registers.
* rs6000-nat.c (regmap): Don't match against the fpscr and
floating point register numbers if they don't exist.
(fetch_inferior_registers, store_inferior_registers,
fetch_core_registers): Only fetch / store / supply the
floating-point registers and the fpscr if we have them.
* Makefile.in (ppc-bdm.o, ppc-linux-nat.o, ppcnbsd-nat.o)
(ppcobsd-tdep.o): Update dependencies.
@
text
@a28 1
#include "gdb_assert.h"
d142 1
a142 2
  if (tdep->ppc_fp0_regnum >= 0
      && regno >= tdep->ppc_fp0_regnum
d163 1
a163 2
  if (tdep->ppc_fpscr_regnum >= 0
      && regno == tdep->ppc_fpscr_regnum)
a236 5
  /* If the current architecture has no floating-point registers, we
     should never reach this point: ppc_register_u_addr should have
     returned -1, and we should have caught that above.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

a414 5
  /* If the current architecture has no floating-point registers, we
     should never reach this point: ppc_register_u_addr should have
     returned -1, and we should have caught that above.  */
  gdb_assert (ppc_floating_point_unit_p (current_gdbarch));

d439 1
a439 1
          && regno == tdep->ppc_fpscr_regnum)
d623 1
a623 1
  if (ppc_floating_point_unit_p (current_gdbarch))
d625 2
a626 7
      for (regi = 0; regi < ppc_num_fprs; regi++)
        {
          if ((regno == -1) || (regno == tdep->ppc_fp0_regnum + regi))
            regcache_collect (tdep->ppc_fp0_regnum + regi, fpp + 8 * regi);
        }
      if (regno == -1 || regno == tdep->ppc_fpscr_regnum)
        right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
d628 2
@


1.34
log
@* ppc-linux-nat.c (fetch_ppc_registers, store_ppc_registers):
Don't assume that the gprs, fprs, and UISA sprs are
contiguous, start at register number zero, and end with fpscr.
Instead, use the numbers from the tdep structure.
@
text
@d29 1
d143 2
a144 1
  if (regno >= tdep->ppc_fp0_regnum
d165 2
a166 1
  if (regno == tdep->ppc_fpscr_regnum)
d240 5
d423 5
d452 1
a452 1
          && regno == gdbarch_tdep (current_gdbarch)->ppc_fpscr_regnum)
d636 1
a636 1
  for (regi = 0; regi < 32; regi++)
d638 7
a644 2
      if ((regno == -1) || (regno == tdep->ppc_fp0_regnum + regi))
	regcache_collect (tdep->ppc_fp0_regnum + regi, fpp + 8 * regi);
a645 2
  if ((regno == -1) || regno == tdep->ppc_fpscr_regnum)
    right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
@


1.33
log
@* config/rs6000/tm-rs6000.h (FP0_REGNUM): Document that this
should no longer be used in code specific to the RS6000 and its
derivatives.
* ppc-tdep.h (struct gdbarch_tdep): Add 'ppc_fp0_regnum' member.
* rs6000-tdep.c (rs6000_gdbarch_init): Initialize
tdep->ppc_fp0_regnum.
(ppc_supply_fpregset, ppc_collect_fpregset)
(rs6000_push_dummy_call, rs6000_extract_return_value)
(rs6000_dwarf2_stab_reg_to_regnum, rs6000_store_return_value)
(rs6000_frame_cache): Use tdep->ppc_fp0_regnum instead of
FP0_REGNUM.
* aix-thread.c (supply_fprs, fetch_regs_kernel_thread)
(fill_gprs64, fill_gprs32, fill_fprs, store_regs_kernel_thread):
Same.
* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_fetch_registers,
bdm_ppc_store_registers): Same.
* ppc-linux-nat.c (ppc_register_u_addr, fetch_register)
(store_register, fill_fpregset): Same.
* ppc-linux-tdep.c (ppc_linux_sigtramp_cache)
(ppc_linux_supply_fpregset): Same.
* ppcnbsd-nat.c (getfpregs_supplies): Same.
* ppcnbsd-tdep.c (ppcnbsd_supply_fpreg, ppcnbsd_fill_fpreg):
Same.
* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
ppc64_sysv_abi_return_value): Same.
* rs6000-nat.c (regmap, fetch_inferior_registers)
(store_inferior_registers, fetch_core_registers): Same.
@
text
@d317 16
a332 2
  for (i = 0; i <= tdep->ppc_fpscr_regnum; i++)
    fetch_register (tid, i);
d335 2
d504 16
a519 2
  for (i = 0; i <= tdep->ppc_fpscr_regnum; i++)
    store_register (tid, i);
d522 2
@


1.32
log
@* config/ppc-tdep.h (struct gdbarch_tdep): Delete
'ppc_gplast_regnum' member.
(ppc_num_gprs): New enum constant.
* ppc-linux-nat.c (ppc_register_u_addr): Use tdep->ppc_gp0_regnum
and ppc_num_gprs instead of tdep->ppc_gplast_regnum.
* rs6000-nat.c (regmap, fetch_inferior_registers,
store_inferior_registers): Same.
* rs6000-tdep.c (e500_pseudo_register_read)
(e500_pseudo_register_write): Same.
(rs6000_gdbarch_init): Don't initialize tdep->ppc_gplast_regnum.
@
text
@d142 3
a144 2
  if (regno >= FP0_REGNUM && regno < FP0_REGNUM + ppc_num_fprs)
    u_addr = (PT_FPR0 * wordsize) + ((regno - FP0_REGNUM) * 8);
d206 1
d256 2
a257 1
  if ((regno >= FP0_REGNUM && regno < FP0_REGNUM +32)
d382 1
d402 2
a403 1
  if ((regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
d593 2
a594 2
      if ((regno == -1) || (regno == FP0_REGNUM + regi))
	regcache_collect (FP0_REGNUM + regi, fpp + 8 * regi);
@


1.31
log
@* config/rs6000/tm-rs6000.h (FPLAST_REGNUM): Delete #definition.
* ppc-tdep.h (ppc_num_fprs): New enum constant.
* aix-thread.c (fetch_regs_kernel_thread, fill_fprs,
store_regs_kernel_thread): Use FP0_REGNUM + ppc_num_fprs, not
FPLAST_REGNUM.
* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_store_registers):
Same.
* ppc-linux-nat.c (ppc_register_u_addr): Same.
* rs6000-nat.c (regmap, fetch_inferior_registers)
(store_inferior_registers): Same.
@
text
@d135 2
a136 1
  if (regno >= tdep->ppc_gp0_regnum && regno <= tdep->ppc_gplast_regnum )
@


1.30
log
@* ppc-linux-nat.c (ppc_register_u_addr): Don't assume that r0 is
register number zero.
@
text
@d141 1
a141 1
  if (regno >= FP0_REGNUM && regno <= FPLAST_REGNUM)
@


1.29
log
@2004-03-15  Andrew Cagney  <cagney@@redhat.com>

	* ppc-tdep.h: Update copyright.
	(ppc_linux_supply_gregset, ppc_linux_supply_fpregset): Change
	function signatures to match "regsets.h".
	* ppc-linux-tdep.c: Include "regset.h".
	(ELF_GREGSET_SIZE): Delete.
	(right_supply_register): New function.
	(ppc_linux_supply_fpregset, ppc_linux_supply_gregset): Rewrite
	using right_supply_register.
	(ppc32_linux_supply_gregset, ppc64_linux_supply_gregset): New
	functions.
	(ppc64_linux_gregset, ppc32_linux_gregset): Define.
	(ppc_linux_init_abi): Register ppc_linux_regset_from_core_section.
	(_initialize_ppc_linux_tdep): Do not register
	ppc_linux_regset_core_fns.
	(ppc_linux_regset_from_core_section): Replace
	fetch_core_registers.
	(ppc_linux_regset_core_fns): Delete.
	* ppc-linux-nat.c: (right_fill_reg): New function.
	(supply_gregset): Update call to ppc_linux_supply_gregset.
	(fill_gregset): Clear the register set, use right_fill_reg.
	(supply_fpregset): Update call to ppc_linux_supply_fpregset.
	(fill_fpregset): Use right_fill_reg, correctly compute FP offsets.

Index: ppc-linux-nat.c
===================================================================
RCS file: /cvs/src/src/gdb/ppc-linux-nat.c,v
retrieving revision 1.28
diff -u -r1.28 ppc-linux-nat.c
--- ppc-linux-nat.c	8 Mar 2004 01:45:02 -0000	1.28
+++ ppc-linux-nat.c	15 Mar 2004 21:28:31 -0000
@@@@ -507,7 +507,24 @@@@
 void
 supply_gregset (gdb_gregset_t *gregsetp)
 {
-  ppc_linux_supply_gregset ((char *) gregsetp);
+  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
+     interface, and not the wordsize of the program's ABI.  */
+  int wordsize = sizeof (PTRACE_XFER_TYPE);
+  ppc_linux_supply_gregset (current_regcache, -1, gregsetp,
+			    sizeof (gdb_gregset_t), wordsize);
+}
+
+static void
+right_fill_reg (int regnum, void *reg)
+{
+  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
+     interface, and not the wordsize of the program's ABI.  */
+  int wordsize = sizeof (PTRACE_XFER_TYPE);
+  /* Right fill the register.  */
+  regcache_raw_collect (current_regcache, regnum,
+			((bfd_byte *) reg
+			 + wordsize
+			 - register_size (current_gdbarch, regnum)));
 }

 void
@@@@ -516,36 +533,42 @@@@
   int regi;
   elf_greg_t *regp = (elf_greg_t *) gregsetp;
   struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  const int elf_ngreg = 48;
+
+
+  /* Start with zeros.  */
+  memset (regp, 0, elf_ngreg * sizeof (*regp));

   for (regi = 0; regi < 32; regi++)
     {
       if ((regno == -1) || regno == regi)
-        regcache_collect (regi, regp + PT_R0 + regi);
+	right_fill_reg (regi, (regp + PT_R0 + regi));
     }

   if ((regno == -1) || regno == PC_REGNUM)
-    regcache_collect (PC_REGNUM, regp + PT_NIP);
+    right_fill_reg (PC_REGNUM, regp + PT_NIP);
   if ((regno == -1) || regno == tdep->ppc_lr_regnum)
-    regcache_collect (tdep->ppc_lr_regnum, regp + PT_LNK);
+    right_fill_reg (tdep->ppc_lr_regnum, regp + PT_LNK);
   if ((regno == -1) || regno == tdep->ppc_cr_regnum)
     regcache_collect (tdep->ppc_cr_regnum, regp + PT_CCR);
   if ((regno == -1) || regno == tdep->ppc_xer_regnum)
     regcache_collect (tdep->ppc_xer_regnum, regp + PT_XER);
   if ((regno == -1) || regno == tdep->ppc_ctr_regnum)
-    regcache_collect (tdep->ppc_ctr_regnum, regp + PT_CTR);
+    right_fill_reg (tdep->ppc_ctr_regnum, regp + PT_CTR);
 #ifdef PT_MQ
   if (((regno == -1) || regno == tdep->ppc_mq_regnum)
       && (tdep->ppc_mq_regnum != -1))
-    regcache_collect (tdep->ppc_mq_regnum, regp + PT_MQ);
+    right_fill_reg (tdep->ppc_mq_regnum, regp + PT_MQ);
 #endif
   if ((regno == -1) || regno == tdep->ppc_ps_regnum)
-    regcache_collect (tdep->ppc_ps_regnum, regp + PT_MSR);
+    right_fill_reg (tdep->ppc_ps_regnum, regp + PT_MSR);
 }

 void
 supply_fpregset (gdb_fpregset_t * fpregsetp)
 {
-  ppc_linux_supply_fpregset ((char *) fpregsetp);
+  ppc_linux_supply_fpregset (NULL, current_regcache, -1, fpregsetp,
+			     sizeof (gdb_fpregset_t));
 }

 /* Given a pointer to a floating point register set in /proc format
@@@@ -557,12 +580,13 @@@@
 {
   int regi;
   struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  bfd_byte *fpp = (void *) fpregsetp;

   for (regi = 0; regi < 32; regi++)
     {
       if ((regno == -1) || (regno == FP0_REGNUM + regi))
-	regcache_collect (FP0_REGNUM + regi, (char *) (*fpregsetp + regi));
+	regcache_collect (FP0_REGNUM + regi, fpp + 8 * regi);
     }
   if ((regno == -1) || regno == tdep->ppc_fpscr_regnum)
-    regcache_collect (tdep->ppc_fpscr_regnum, (char *) (*fpregsetp + regi));
+    right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
 }
Index: ppc-linux-tdep.c
===================================================================
RCS file: /cvs/src/src/gdb/ppc-linux-tdep.c,v
retrieving revision 1.50
diff -u -r1.50 ppc-linux-tdep.c
--- ppc-linux-tdep.c	16 Feb 2004 21:49:22 -0000	1.50
+++ ppc-linux-tdep.c	15 Mar 2004 21:28:31 -0000
@@@@ -32,7 +32,7 @@@@
 #include "regcache.h"
 #include "value.h"
 #include "osabi.h"
-
+#include "regset.h"
 #include "solib-svr4.h"
 #include "ppc-tdep.h"

@@@@ -959,81 +959,114 @@@@
 };

 enum {
-  ELF_GREGSET_SIZE = (ELF_NGREG * 4),
   ELF_FPREGSET_SIZE = (ELF_NFPREG * 8)
 };

+static void
+right_supply_register (struct regcache *regcache, int wordsize, int regnum,
+		       const bfd_byte *buf)
+{
+  regcache_raw_supply (regcache, regnum,
+		       (buf + wordsize
+			- register_size (current_gdbarch, regnum)));
+}
+
+/* Extract the register values found in the WORDSIZED ABI GREGSET,
+   storing their values in REGCACHE.  Note that some are left-aligned,
+   while others are right aligned.  */
+
 void
-ppc_linux_supply_gregset (char *buf)
+ppc_linux_supply_gregset (struct regcache *regcache,
+			  int regnum, const void *gregs, size_t size,
+			  int wordsize)
 {
   int regi;
-  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
+  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
+  const bfd_byte *buf = gregs;

   for (regi = 0; regi < 32; regi++)
-    supply_register (regi, buf + 4 * regi);
+    right_supply_register (regcache, wordsize, regi, buf + wordsize * regi);
+
+  right_supply_register (regcache, wordsize, gdbarch_pc_regnum (regcache_arch),
+			 buf + wordsize * PPC_LINUX_PT_NIP);
+  right_supply_register (regcache, wordsize, regcache_tdep->ppc_lr_regnum,
+			 buf + wordsize * PPC_LINUX_PT_LNK);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_cr_regnum,
+		       buf + wordsize * PPC_LINUX_PT_CCR);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_xer_regnum,
+		       buf + wordsize * PPC_LINUX_PT_XER);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_ctr_regnum,
+		       buf + wordsize * PPC_LINUX_PT_CTR);
+  if (regcache_tdep->ppc_mq_regnum != -1)
+    right_supply_register (regcache, wordsize, regcache_tdep->ppc_mq_regnum,
+			   buf + wordsize * PPC_LINUX_PT_MQ);
+  right_supply_register (regcache, wordsize, regcache_tdep->ppc_ps_regnum,
+			 buf + wordsize * PPC_LINUX_PT_MSR);
+}

-  supply_register (PC_REGNUM, buf + 4 * PPC_LINUX_PT_NIP);
-  supply_register (tdep->ppc_lr_regnum, buf + 4 * PPC_LINUX_PT_LNK);
-  supply_register (tdep->ppc_cr_regnum, buf + 4 * PPC_LINUX_PT_CCR);
-  supply_register (tdep->ppc_xer_regnum, buf + 4 * PPC_LINUX_PT_XER);
-  supply_register (tdep->ppc_ctr_regnum, buf + 4 * PPC_LINUX_PT_CTR);
-  if (tdep->ppc_mq_regnum != -1)
-    supply_register (tdep->ppc_mq_regnum, buf + 4 * PPC_LINUX_PT_MQ);
-  supply_register (tdep->ppc_ps_regnum, buf + 4 * PPC_LINUX_PT_MSR);
+static void
+ppc32_linux_supply_gregset (const struct regset *regset,
+			    struct regcache *regcache,
+			    int regnum, const void *gregs, size_t size)
+{
+  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 4);
 }

+static struct regset ppc32_linux_gregset = {
+  NULL, ppc32_linux_supply_gregset
+};
+
+static void
+ppc64_linux_supply_gregset (const struct regset *regset,
+			    struct regcache * regcache,
+			    int regnum, const void *gregs, size_t size)
+{
+  ppc_linux_supply_gregset (regcache, regnum, gregs, size, 8);
+}
+
+static struct regset ppc64_linux_gregset = {
+  NULL, ppc64_linux_supply_gregset
+};
+
 void
-ppc_linux_supply_fpregset (char *buf)
+ppc_linux_supply_fpregset (const struct regset *regset,
+			   struct regcache * regcache,
+			   int regnum, const void *fpset, size_t size)
 {
   int regi;
-  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
+  struct gdbarch *regcache_arch = get_regcache_arch (regcache);
+  struct gdbarch_tdep *regcache_tdep = gdbarch_tdep (regcache_arch);
+  const bfd_byte *buf = fpset;

   for (regi = 0; regi < 32; regi++)
-    supply_register (FP0_REGNUM + regi, buf + 8 * regi);
+    regcache_raw_supply (regcache, FP0_REGNUM + regi, buf + 8 * regi);

   /* The FPSCR is stored in the low order word of the last doubleword in the
      fpregset.  */
-  supply_register (tdep->ppc_fpscr_regnum, buf + 8 * 32 + 4);
+  regcache_raw_supply (regcache, regcache_tdep->ppc_fpscr_regnum,
+		       buf + 8 * 32 + 4);
 }

-/*
-  Use a local version of this function to get the correct types for regsets.
-*/
+static struct regset ppc_linux_fpregset = { NULL, ppc_linux_supply_fpregset };

-static void
-fetch_core_registers (char *core_reg_sect,
-		      unsigned core_reg_size,
-		      int which,
-		      CORE_ADDR reg_addr)
+static const struct regset *
+ppc_linux_regset_from_core_section (struct gdbarch *core_arch,
+				    const char *sect_name, size_t sect_size)
 {
-  if (which == 0)
+  struct gdbarch_tdep *tdep = gdbarch_tdep (core_arch);
+  if (strcmp (sect_name, ".reg") == 0)
     {
-      if (core_reg_size == ELF_GREGSET_SIZE)
-	ppc_linux_supply_gregset (core_reg_sect);
+      if (tdep->wordsize == 4)
+	return &ppc32_linux_gregset;
       else
-	warning ("wrong size gregset struct in core file");
-    }
-  else if (which == 2)
-    {
-      if (core_reg_size == ELF_FPREGSET_SIZE)
-	ppc_linux_supply_fpregset (core_reg_sect);
-      else
-	warning ("wrong size fpregset struct in core file");
+	return &ppc64_linux_gregset;
     }
+  if (strcmp (sect_name, ".reg2") == 0)
+    return &ppc_linux_fpregset;
+  return NULL;
 }

-/* Register that we are able to handle ELF file formats using standard
-   procfs "regset" structures.  */
-
-static struct core_fns ppc_linux_regset_core_fns =
-{
-  bfd_target_elf_flavour,	/* core_flavour */
-  default_check_format,		/* check_format */
-  default_core_sniffer,		/* core_sniffer */
-  fetch_core_registers,		/* core_read_registers */
-  NULL				/* next */
-};
-
 static void
 ppc_linux_init_abi (struct gdbarch_info info,
                     struct gdbarch *gdbarch)
@@@@ -1086,6 +1119,7 @@@@
       /* PPC64 malloc's entry-point is called ".malloc".  */
       set_gdbarch_name_of_malloc (gdbarch, ".malloc");
     }
+  set_gdbarch_regset_from_core_section (gdbarch, ppc_linux_regset_from_core_section);
 }

 void
@@@@ -1099,5 +1133,4 @@@@
                          ppc_linux_init_abi);
   gdbarch_register_osabi (bfd_arch_rs6000, bfd_mach_rs6k, GDB_OSABI_LINUX,
                          ppc_linux_init_abi);
-  add_core_fns (&ppc_linux_regset_core_fns);
 }
Index: ppc-tdep.h
===================================================================
RCS file: /cvs/src/src/gdb/ppc-tdep.h,v
retrieving revision 1.25
diff -u -r1.25 ppc-tdep.h
--- ppc-tdep.h	10 Nov 2003 22:47:28 -0000	1.25
+++ ppc-tdep.h	15 Mar 2004 21:28:31 -0000
@@@@ -1,6 +1,7 @@@@
 /* Target-dependent code for GDB, the GNU debugger.
-   Copyright 2000, 2001, 2002, 2003
-   Free Software Foundation, Inc.
+
+   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation,
+   Inc.

    This file is part of GDB.

@@@@ -62,8 +63,12 @@@@
 						    CORE_ADDR bpaddr);
 int ppc_linux_memory_remove_breakpoint (CORE_ADDR addr, char *contents_cache);
 struct link_map_offsets *ppc_linux_svr4_fetch_link_map_offsets (void);
-void ppc_linux_supply_gregset (char *buf);
-void ppc_linux_supply_fpregset (char *buf);
+void ppc_linux_supply_gregset (struct regcache *regcache,
+			       int regnum, const void *gregs, size_t size,
+			       int wordsize);
+void ppc_linux_supply_fpregset (const struct regset *regset,
+				struct regcache *regcache,
+				int regnum, const void *gregs, size_t size);

 enum return_value_convention ppc64_sysv_abi_return_value (struct gdbarch *gdbarch,
 							  struct type *valtype,
@
text
@d136 1
a136 1
    u_addr =  ((PT_R0 + regno) * wordsize);
@


1.28
log
@2004-03-07  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-nat.c (ppc_ptrace_cannot_fetch_store_register): Delete
	unused function.
@
text
@d510 18
a527 1
  ppc_linux_supply_gregset ((char *) gregsetp);
d536 5
d545 1
a545 1
        regcache_collect (regi, regp + PT_R0 + regi);
d549 1
a549 1
    regcache_collect (PC_REGNUM, regp + PT_NIP);
d551 1
a551 1
    regcache_collect (tdep->ppc_lr_regnum, regp + PT_LNK);
d557 1
a557 1
    regcache_collect (tdep->ppc_ctr_regnum, regp + PT_CTR);
d561 1
a561 1
    regcache_collect (tdep->ppc_mq_regnum, regp + PT_MQ);
d564 1
a564 1
    regcache_collect (tdep->ppc_ps_regnum, regp + PT_MSR);
d570 2
a571 1
  ppc_linux_supply_fpregset ((char *) fpregsetp);
d583 1
d588 1
a588 1
	regcache_collect (FP0_REGNUM + regi, (char *) (*fpregsetp + regi));
d591 1
a591 1
    regcache_collect (tdep->ppc_fpscr_regnum, (char *) (*fpregsetp + regi));
@


1.28.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d510 1
a510 18
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (PTRACE_XFER_TYPE);
  ppc_linux_supply_gregset (current_regcache, -1, gregsetp,
			    sizeof (gdb_gregset_t), wordsize);
}

static void
right_fill_reg (int regnum, void *reg)
{
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (PTRACE_XFER_TYPE);
  /* Right fill the register.  */
  regcache_raw_collect (current_regcache, regnum,
			((bfd_byte *) reg
			 + wordsize
			 - register_size (current_gdbarch, regnum)));
a518 5
  const int elf_ngreg = 48;


  /* Start with zeros.  */
  memset (regp, 0, elf_ngreg * sizeof (*regp));
d523 1
a523 1
	right_fill_reg (regi, (regp + PT_R0 + regi));
d527 1
a527 1
    right_fill_reg (PC_REGNUM, regp + PT_NIP);
d529 1
a529 1
    right_fill_reg (tdep->ppc_lr_regnum, regp + PT_LNK);
d535 1
a535 1
    right_fill_reg (tdep->ppc_ctr_regnum, regp + PT_CTR);
d539 1
a539 1
    right_fill_reg (tdep->ppc_mq_regnum, regp + PT_MQ);
d542 1
a542 1
    right_fill_reg (tdep->ppc_ps_regnum, regp + PT_MSR);
d548 1
a548 2
  ppc_linux_supply_fpregset (NULL, current_regcache, -1, fpregsetp,
			     sizeof (gdb_fpregset_t));
a559 1
  bfd_byte *fpp = (void *) fpregsetp;
d564 1
a564 1
	regcache_collect (FP0_REGNUM + regi, fpp + 8 * regi);
d567 1
a567 1
    right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
@


1.27
log
@2003-12-03  Andrew Cagney  <cagney@@redhat.com>

	* ppc-linux-nat.c (store_register, fetch_register): Convert
	between ptrace and regcache's wordsize.
	(ppc_register_u_addr): Use the ptrace wordsize.
@
text
@a166 6
static int
ppc_ptrace_cannot_fetch_store_register (int regno)
{
  return (ppc_register_u_addr (regno) == -1);
}

@


1.27.6.1
log
@Merge mainline to intercu branch.
@
text
@d167 6
d516 1
a516 18
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (PTRACE_XFER_TYPE);
  ppc_linux_supply_gregset (current_regcache, -1, gregsetp,
			    sizeof (gdb_gregset_t), wordsize);
}

static void
right_fill_reg (int regnum, void *reg)
{
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (PTRACE_XFER_TYPE);
  /* Right fill the register.  */
  regcache_raw_collect (current_regcache, regnum,
			((bfd_byte *) reg
			 + wordsize
			 - register_size (current_gdbarch, regnum)));
a524 5
  const int elf_ngreg = 48;


  /* Start with zeros.  */
  memset (regp, 0, elf_ngreg * sizeof (*regp));
d529 1
a529 1
	right_fill_reg (regi, (regp + PT_R0 + regi));
d533 1
a533 1
    right_fill_reg (PC_REGNUM, regp + PT_NIP);
d535 1
a535 1
    right_fill_reg (tdep->ppc_lr_regnum, regp + PT_LNK);
d541 1
a541 1
    right_fill_reg (tdep->ppc_ctr_regnum, regp + PT_CTR);
d545 1
a545 1
    right_fill_reg (tdep->ppc_mq_regnum, regp + PT_MQ);
d548 1
a548 1
    right_fill_reg (tdep->ppc_ps_regnum, regp + PT_MSR);
d554 1
a554 2
  ppc_linux_supply_fpregset (NULL, current_regcache, -1, fpregsetp,
			     sizeof (gdb_fpregset_t));
a565 1
  bfd_byte *fpp = (void *) fpregsetp;
d570 1
a570 1
	regcache_collect (FP0_REGNUM + regi, fpp + 8 * regi);
d573 1
a573 1
    right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
@


1.27.6.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@a28 1
#include "gdb_assert.h"
a71 10

/* Similarly for the ptrace requests for getting / setting the SPE
   registers (ev0 -- ev31, acc, and spefscr).  See the description of
   gdb_evrregset_t for details.  */
#ifndef PTRACE_GETEVRREGS
#define PTRACE_GETEVRREGS 20
#define PTRACE_SETEVRREGS 21
#endif


d103 1
a103 31

/* On PPC processors that support the the Signal Processing Extension
   (SPE) APU, the general-purpose registers are 64 bits long.
   However, the ordinary Linux kernel PTRACE_PEEKUSR / PTRACE_POKEUSR
   / PT_READ_U / PT_WRITE_U ptrace calls only access the lower half of
   each register, to allow them to behave the same way they do on
   non-SPE systems.  There's a separate pair of calls,
   PTRACE_GETEVRREGS / PTRACE_SETEVRREGS, that read and write the top
   halves of all the general-purpose registers at once, along with
   some SPE-specific registers.

   GDB itself continues to claim the general-purpose registers are 32
   bits long.  It has unnamed raw registers that hold the upper halves
   of the gprs, and the the full 64-bit SIMD views of the registers,
   'ev0' -- 'ev31', are pseudo-registers that splice the top and
   bottom halves together.

   This is the structure filled in by PTRACE_GETEVRREGS and written to
   the inferior's registers by PTRACE_SETEVRREGS.  */
struct gdb_evrregset_t
{
  unsigned long evr[32];
  unsigned long long acc;
  unsigned long spefscr;
};


/* Non-zero if our kernel may support the PTRACE_GETVRREGS and
   PTRACE_SETVRREGS requests, for reading and writing the Altivec
   registers.  Zero if we've tried one of them and gotten an
   error.  */
a105 8

/* Non-zero if our kernel may support the PTRACE_GETEVRREGS and
   PTRACE_SETEVRREGS requests, for reading and writing the SPE
   registers.  Zero if we've tried one of them and gotten an
   error.  */
int have_ptrace_getsetevrregs = 1;


d135 2
a136 3
  if (regno >= tdep->ppc_gp0_regnum 
      && regno < tdep->ppc_gp0_regnum + ppc_num_gprs)
    u_addr = ((regno - tdep->ppc_gp0_regnum + PT_R0) * wordsize);
d141 2
a142 4
  if (tdep->ppc_fp0_regnum >= 0
      && regno >= tdep->ppc_fp0_regnum
      && regno < tdep->ppc_fp0_regnum + ppc_num_fprs)
    u_addr = (PT_FPR0 * wordsize) + ((regno - tdep->ppc_fp0_regnum) * 8);
d161 1
a161 2
  if (tdep->ppc_fpscr_regnum >= 0
      && regno == tdep->ppc_fpscr_regnum)
d177 1
a177 1
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
d195 1
a195 1
    offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d197 2
a198 74
  regcache_raw_supply (current_regcache, regno,
		       regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
}

/* Fetch the top 32 bits of TID's general-purpose registers and the
   SPE-specific registers, and place the results in EVRREGSET.  If we
   don't support PTRACE_GETEVRREGS, then just fill EVRREGSET with
   zeros.

   All the logic to deal with whether or not the PTRACE_GETEVRREGS and
   PTRACE_SETEVRREGS requests are supported is isolated here, and in
   set_spe_registers.  */
static void
get_spe_registers (int tid, struct gdb_evrregset_t *evrregset)
{
  if (have_ptrace_getsetevrregs)
    {
      if (ptrace (PTRACE_GETEVRREGS, tid, 0, evrregset) >= 0)
        return;
      else
        {
          /* EIO means that the PTRACE_GETEVRREGS request isn't supported;
             we just return zeros.  */
          if (errno == EIO)
            have_ptrace_getsetevrregs = 0;
          else
            /* Anything else needs to be reported.  */
            perror_with_name ("Unable to fetch SPE registers");
        }
    }

  memset (evrregset, 0, sizeof (*evrregset));
}

/* Supply values from TID for SPE-specific raw registers: the upper
   halves of the GPRs, the accumulator, and the spefscr.  REGNO must
   be the number of an upper half register, acc, spefscr, or -1 to
   supply the values of all registers.  */
static void
fetch_spe_register (int tid, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct gdb_evrregset_t evrregs;

  gdb_assert (sizeof (evrregs.evr[0])
              == register_size (current_gdbarch, tdep->ppc_ev0_upper_regnum));
  gdb_assert (sizeof (evrregs.acc)
              == register_size (current_gdbarch, tdep->ppc_acc_regnum));
  gdb_assert (sizeof (evrregs.spefscr)
              == register_size (current_gdbarch, tdep->ppc_spefscr_regnum));

  get_spe_registers (tid, &evrregs);

  if (regno == -1)
    {
      int i;

      for (i = 0; i < ppc_num_gprs; i++)
        regcache_raw_supply (current_regcache, tdep->ppc_ev0_upper_regnum + i,
                             &evrregs.evr[i]);
    }
  else if (tdep->ppc_ev0_upper_regnum <= regno
           && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    regcache_raw_supply (current_regcache, regno,
                         &evrregs.evr[regno - tdep->ppc_ev0_upper_regnum]);

  if (regno == -1
      || regno == tdep->ppc_acc_regnum)
    regcache_raw_supply (current_regcache, tdep->ppc_acc_regnum, &evrregs.acc);

  if (regno == -1
      || regno == tdep->ppc_spefscr_regnum)
    regcache_raw_supply (current_regcache, tdep->ppc_spefscr_regnum,
                         &evrregs.spefscr);
a203 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d205 2
a206 2
  CORE_ADDR regaddr = ppc_register_u_addr (regno);
  int bytes_transferred;
d209 1
a225 5
  else if (spe_register_p (regno))
    {
      fetch_spe_register (tid, regno);
      return;
    }
d229 2
a230 2
      memset (buf, '\0', register_size (current_gdbarch, regno));   /* Supply zeroes */
      regcache_raw_supply (current_regcache, regno, buf);
d237 1
a237 3
  for (bytes_transferred = 0;
       bytes_transferred < register_size (current_gdbarch, regno);
       bytes_transferred += sizeof (PTRACE_XFER_TYPE))
d240 2
a241 2
      *(PTRACE_XFER_TYPE *) & buf[bytes_transferred]
        = ptrace (PT_READ_U, tid, (PTRACE_ARG3_TYPE) regaddr, 0);
d245 1
a245 2
          char message[128];
	  sprintf (message, "reading register %s (#%d)", 
d247 1
a247 1
	  perror_with_name (message);
d251 12
a262 21
  /* Now supply the register.  Keep in mind that the regcache's idea
     of the register's size may not be a multiple of sizeof
     (PTRACE_XFER_TYPE).  */
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
    {
      /* Little-endian values are always found at the left end of the
         bytes transferred.  */
      regcache_raw_supply (current_regcache, regno, buf);
    }
  else if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
    {
      /* Big-endian values are found at the right end of the bytes
         transferred.  */
      size_t padding = (bytes_transferred
                        - register_size (current_gdbarch, regno));
      regcache_raw_supply (current_regcache, regno, buf + padding);
    }
  else 
    internal_error (__FILE__, __LINE__,
                    "fetch_register: unexpected byte order: %d",
                    gdbarch_byte_order (current_gdbarch));
d271 2
a272 2
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d281 2
a282 2
        regcache_raw_supply (current_regcache, tdep->ppc_vr0_regnum + i,
			     *vrregsetp + i * vrregsize + offset);
d284 1
a284 2
        regcache_raw_supply (current_regcache, tdep->ppc_vr0_regnum + i,
			     *vrregsetp + i * vrregsize);
d313 2
a314 16
  for (i = 0; i < ppc_num_gprs; i++)
    fetch_register (tid, tdep->ppc_gp0_regnum + i);
  if (tdep->ppc_fp0_regnum >= 0)
    for (i = 0; i < ppc_num_fprs; i++)
      fetch_register (tid, tdep->ppc_fp0_regnum + i);
  fetch_register (tid, PC_REGNUM);
  if (tdep->ppc_ps_regnum != -1)
    fetch_register (tid, tdep->ppc_ps_regnum);
  if (tdep->ppc_cr_regnum != -1)
    fetch_register (tid, tdep->ppc_cr_regnum);
  if (tdep->ppc_lr_regnum != -1)
    fetch_register (tid, tdep->ppc_lr_regnum);
  if (tdep->ppc_ctr_regnum != -1)
    fetch_register (tid, tdep->ppc_ctr_regnum);
  if (tdep->ppc_xer_regnum != -1)
    fetch_register (tid, tdep->ppc_xer_regnum);
a316 2
  if (tdep->ppc_fpscr_regnum != -1)
    fetch_register (tid, tdep->ppc_fpscr_regnum);
a319 2
  if (tdep->ppc_ev0_upper_regnum >= 0)
    fetch_spe_register (tid, -1);
d349 1
a349 1
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
d365 1
a365 1
    offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d367 2
a368 2
  regcache_raw_collect (current_regcache, regno,
			regs + (regno - tdep->ppc_vr0_regnum) * vrregsize + offset);
a374 86
/* Assuming TID referrs to an SPE process, set the top halves of TID's
   general-purpose registers and its SPE-specific registers to the
   values in EVRREGSET.  If we don't support PTRACE_SETEVRREGS, do
   nothing.

   All the logic to deal with whether or not the PTRACE_GETEVRREGS and
   PTRACE_SETEVRREGS requests are supported is isolated here, and in
   get_spe_registers.  */
static void
set_spe_registers (int tid, struct gdb_evrregset_t *evrregset)
{
  if (have_ptrace_getsetevrregs)
    {
      if (ptrace (PTRACE_SETEVRREGS, tid, 0, evrregset) >= 0)
        return;
      else
        {
          /* EIO means that the PTRACE_SETEVRREGS request isn't
             supported; we fail silently, and don't try the call
             again.  */
          if (errno == EIO)
            have_ptrace_getsetevrregs = 0;
          else
            /* Anything else needs to be reported.  */
            perror_with_name ("Unable to set SPE registers");
        }
    }
}

/* Write GDB's value for the SPE-specific raw register REGNO to TID.
   If REGNO is -1, write the values of all the SPE-specific
   registers.  */
static void
store_spe_register (int tid, int regno)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct gdb_evrregset_t evrregs;

  gdb_assert (sizeof (evrregs.evr[0])
              == register_size (current_gdbarch, tdep->ppc_ev0_upper_regnum));
  gdb_assert (sizeof (evrregs.acc)
              == register_size (current_gdbarch, tdep->ppc_acc_regnum));
  gdb_assert (sizeof (evrregs.spefscr)
              == register_size (current_gdbarch, tdep->ppc_spefscr_regnum));

  if (regno == -1)
    /* Since we're going to write out every register, the code below
       should store to every field of evrregs; if that doesn't happen,
       make it obvious by initializing it with suspicious values.  */
    memset (&evrregs, 42, sizeof (evrregs));
  else
    /* We can only read and write the entire EVR register set at a
       time, so to write just a single register, we do a
       read-modify-write maneuver.  */
    get_spe_registers (tid, &evrregs);

  if (regno == -1)
    {
      int i;

      for (i = 0; i < ppc_num_gprs; i++)
        regcache_raw_collect (current_regcache,
                              tdep->ppc_ev0_upper_regnum + i,
                              &evrregs.evr[i]);
    }
  else if (tdep->ppc_ev0_upper_regnum <= regno
           && regno < tdep->ppc_ev0_upper_regnum + ppc_num_gprs)
    regcache_raw_collect (current_regcache, regno,
                          &evrregs.evr[regno - tdep->ppc_ev0_upper_regnum]);

  if (regno == -1
      || regno == tdep->ppc_acc_regnum)
    regcache_raw_collect (current_regcache,
                          tdep->ppc_acc_regnum,
                          &evrregs.acc);

  if (regno == -1
      || regno == tdep->ppc_spefscr_regnum)
    regcache_raw_collect (current_regcache,
                          tdep->ppc_spefscr_regnum,
                          &evrregs.spefscr);

  /* Write back the modified register set.  */
  set_spe_registers (tid, &evrregs);
}

a377 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d380 1
d382 1
a382 1
  size_t bytes_to_transfer;
a389 5
  else if (spe_register_p (regno))
    {
      store_spe_register (tid, regno);
      return;
    }
d394 2
a395 3
  /* First collect the register.  Keep in mind that the regcache's
     idea of the register's size may not be a multiple of sizeof
     (PTRACE_XFER_TYPE).  */
d397 11
a407 14
  bytes_to_transfer = align_up (register_size (current_gdbarch, regno),
                                sizeof (PTRACE_XFER_TYPE));
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
    {
      /* Little-endian values always sit at the left end of the buffer.  */
      regcache_raw_collect (current_regcache, regno, buf);
    }
  else if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      /* Big-endian values sit at the right end of the buffer.  */
      size_t padding = (bytes_to_transfer
                        - register_size (current_gdbarch, regno));
      regcache_raw_collect (current_regcache, regno, buf + padding);
    }
d409 1
a409 1
  for (i = 0; i < bytes_to_transfer; i += sizeof (PTRACE_XFER_TYPE))
d417 1
a417 1
          && regno == tdep->ppc_fpscr_regnum)
d425 1
a425 2
          char message[128];
	  sprintf (message, "writing register %s (#%d)", 
d427 1
a427 1
	  perror_with_name (message);
d438 2
a439 2
  int vrregsize = register_size (current_gdbarch, tdep->ppc_vr0_regnum);
  int offset = vrregsize - register_size (current_gdbarch, tdep->ppc_vrsave_regnum);
d446 2
a447 2
        regcache_raw_collect (current_regcache, tdep->ppc_vr0_regnum + i,
			      *vrregsetp + i * vrregsize + offset);
d449 1
a449 2
        regcache_raw_collect (current_regcache, tdep->ppc_vr0_regnum + i,
			      *vrregsetp + i * vrregsize);
d482 2
a483 16
  for (i = 0; i < ppc_num_gprs; i++)
    store_register (tid, tdep->ppc_gp0_regnum + i);
  if (tdep->ppc_fp0_regnum >= 0)
    for (i = 0; i < ppc_num_fprs; i++)
      store_register (tid, tdep->ppc_fp0_regnum + i);
  store_register (tid, PC_REGNUM);
  if (tdep->ppc_ps_regnum != -1)
    store_register (tid, tdep->ppc_ps_regnum);
  if (tdep->ppc_cr_regnum != -1)
    store_register (tid, tdep->ppc_cr_regnum);
  if (tdep->ppc_lr_regnum != -1)
    store_register (tid, tdep->ppc_lr_regnum);
  if (tdep->ppc_ctr_regnum != -1)
    store_register (tid, tdep->ppc_ctr_regnum);
  if (tdep->ppc_xer_regnum != -1)
    store_register (tid, tdep->ppc_xer_regnum);
a485 2
  if (tdep->ppc_fpscr_regnum != -1)
    store_register (tid, tdep->ppc_fpscr_regnum);
a488 2
  if (tdep->ppc_ev0_upper_regnum >= 0)
    store_spe_register (tid, -1);
d542 1
a542 1
  for (regi = 0; regi < ppc_num_gprs; regi++)
d544 2
a545 2
      if ((regno == -1) || regno == tdep->ppc_gp0_regnum + regi)
	right_fill_reg (tdep->ppc_gp0_regnum + regi, (regp + PT_R0 + regi));
d553 1
a553 2
    regcache_raw_collect (current_regcache, tdep->ppc_cr_regnum,
			  regp + PT_CCR);
d555 1
a555 2
    regcache_raw_collect (current_regcache, tdep->ppc_xer_regnum,
			  regp + PT_XER);
d585 1
a585 1
  if (ppc_floating_point_unit_p (current_gdbarch))
d587 2
a588 8
      for (regi = 0; regi < ppc_num_fprs; regi++)
        {
          if ((regno == -1) || (regno == tdep->ppc_fp0_regnum + regi))
            regcache_raw_collect (current_regcache, tdep->ppc_fp0_regnum + regi,
				  fpp + 8 * regi);
        }
      if (regno == -1 || regno == tdep->ppc_fpscr_regnum)
        right_fill_reg (tdep->ppc_fpscr_regnum, (fpp + 8 * 32));
d590 2
@


1.26
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d130 3
a132 1
  int wordsize = tdep->wordsize;
d240 3
d256 13
a268 1
  supply_register (regno, buf);
d400 15
a414 1
  regcache_collect (regno, buf);
@


1.25
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d181 1
a181 1
  int vrregsize = REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d199 1
a199 1
    offset = vrregsize - REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d233 1
a233 1
      memset (buf, '\0', REGISTER_RAW_SIZE (regno));   /* Supply zeroes */
d238 1
a238 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d260 2
a261 2
  int vrregsize = REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d338 1
a338 1
  int vrregsize = REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d354 1
a354 1
    offset = vrregsize - REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d384 1
a384 1
  for (i = 0; i < REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d413 2
a414 2
  int vrregsize = REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
@


1.24
log
@* ppc-linux-nat.c (ppc_register_u_addr): Correctly compute u-area
register offsets for both the 32- and 64-bit interfaces.
@
text
@d210 1
a210 1
  register int i;
d370 1
a370 1
  register int i;
@


1.23
log
@* ppc-linux-nat.c (ppc_register_u_addr, fill_gregset): If PT_MQ
isn't #defined, assume the register doesn't exist: act as if
tdep->ppc_mq_regnum were -1.
@
text
@d130 1
d134 1
a134 1
    u_addr =  ((PT_R0 + regno) * 4);
d136 3
a138 1
  /* Floating point regs: 2 slots each */
d140 1
a140 1
    u_addr = ((PT_FPR0 + (regno - FP0_REGNUM) * 2) * 4);
d144 1
a144 1
    u_addr = PT_NIP * 4;
d146 1
a146 1
    u_addr = PT_LNK * 4;
d148 1
a148 1
    u_addr = PT_CCR * 4;
d150 1
a150 1
    u_addr = PT_XER * 4;
d152 1
a152 1
    u_addr = PT_CTR * 4;
d155 1
a155 1
    u_addr = PT_MQ * 4;
d158 1
a158 1
    u_addr = PT_MSR * 4;
d160 1
a160 1
    u_addr = PT_FPSCR * 4;
@


1.22
log
@* ppc-linux-nat.c (store_altivec_registers): Don't cast fourth
argument to ptrace to int; the system headers should give it the
right type, and pointers don't fit in ints on powerpc64-*-*.
@
text
@d150 1
d153 1
d508 1
d512 1
@


1.21
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d429 1
a429 1
  ret = ptrace (PTRACE_GETVRREGS, tid, 0, (int) &regs);
d442 1
a442 1
  if (ptrace (PTRACE_SETVRREGS, tid, 0, (int) &regs) < 0)
@


1.21.6.1
log
@* configure.host, configure.tgt: Add entries for
powerpc64-*-linux, selecting powerpc/ppc64-linux.mh and
powerpc/linux.mt.
* config/powerpc/ppc64-linux.mh, config/powerpc/nm-ppc64-linux.mh:
New files.

* ppc-linux-nat.c (ppc_register_u_addr, fill_gregset): If PT_MQ
isn't #defined, assume the register doesn't exist: act as if
tdep->ppc_mq_regnum were -1.
@
text
@a149 1
#ifdef PT_MQ
a151 1
#endif
a505 1
#ifdef PT_MQ
a508 1
#endif
@


1.21.6.2
log
@* ppc-linux-nat.c (ppc_register_u_addr): Compute u-area offsets
using the tdep's wordsize, not just '4'.
@
text
@a129 1
  int wordsize = tdep->wordsize;
d133 1
a133 1
    u_addr =  ((PT_R0 + regno) * wordsize);
d141 1
a141 1
    u_addr = PT_NIP * wordsize;
d143 1
a143 1
    u_addr = PT_LNK * wordsize;
d145 1
a145 1
    u_addr = PT_CCR * wordsize;
d147 1
a147 1
    u_addr = PT_XER * wordsize;
d149 1
a149 1
    u_addr = PT_CTR * wordsize;
d152 1
a152 1
    u_addr = PT_MQ * wordsize;
d155 1
a155 1
    u_addr = PT_MSR * wordsize;
d157 1
a157 1
    u_addr = PT_FPSCR * wordsize;
@


1.21.6.3
log
@* ppc-linux-nat.c (store_altivec_registers): Don't cast fourth
argument to ptrace to int; the system headers should give it the
right type, and pointers don't fit in ints on powerpc64-*-*.
@
text
@d432 1
a432 1
  ret = ptrace (PTRACE_GETVRREGS, tid, 0, &regs);
d445 1
a445 1
  if (ptrace (PTRACE_SETVRREGS, tid, 0, &regs) < 0)
@


1.21.6.4
log
@* ppc-linux-nat.c (ppc_register_u_addr): Correctly compute u-area
offsets for floating-point registers in both 32- and 64-bit
interfaces.
@
text
@d136 1
a136 3
  /* Floating point regs: eight bytes in both 32- and 64-bit ptrace
     interfaces.  Thus, two slots each in 32-bit interface, one slot
     each in 64-bit interface.  */
d138 1
a138 1
    u_addr = (PT_FPR0 * wordsize) + ((regno - FP0_REGNUM) * 8);
@


1.21.6.5
log
@Revert change for revision.
@
text
@d130 1
d134 1
a134 1
    u_addr =  ((PT_R0 + regno) * 4);
d136 3
a138 1
  /* Floating point regs: 2 slots each */
d140 1
a140 1
    u_addr = ((PT_FPR0 + (regno - FP0_REGNUM) * 2) * 4);
d144 1
a144 1
    u_addr = PT_NIP * 4;
d146 1
a146 1
    u_addr = PT_LNK * 4;
d148 1
a148 1
    u_addr = PT_CCR * 4;
d150 1
a150 1
    u_addr = PT_XER * 4;
d152 1
a152 1
    u_addr = PT_CTR * 4;
d155 1
a155 1
    u_addr = PT_MQ * 4;
d158 1
a158 1
    u_addr = PT_MSR * 4;
d160 1
a160 1
    u_addr = PT_FPSCR * 4;
@


1.21.6.6
log
@* ppc-linux-nat.c (ppc_register_u_addr): Correctly compute u-area
register offsets for both the 32- and 64-bit interfaces.
@
text
@a129 1
  int wordsize = tdep->wordsize;
d133 1
a133 1
    u_addr =  ((PT_R0 + regno) * wordsize);
d135 1
a135 3
  /* Floating point regs: eight bytes each in both 32- and 64-bit
     ptrace interfaces.  Thus, two slots each in 32-bit interface, one
     slot each in 64-bit interface.  */
d137 1
a137 1
    u_addr = (PT_FPR0 * wordsize) + ((regno - FP0_REGNUM) * 8);
d141 1
a141 1
    u_addr = PT_NIP * wordsize;
d143 1
a143 1
    u_addr = PT_LNK * wordsize;
d145 1
a145 1
    u_addr = PT_CCR * wordsize;
d147 1
a147 1
    u_addr = PT_XER * wordsize;
d149 1
a149 1
    u_addr = PT_CTR * wordsize;
d152 1
a152 1
    u_addr = PT_MQ * wordsize;
d155 1
a155 1
    u_addr = PT_MSR * wordsize;
d157 1
a157 1
    u_addr = PT_FPSCR * wordsize;
@


1.21.2.1
log
@Patch from Will Schmidt <willschm@@us.ibm.com>:

These changes enable support of PPC64 architecture.
* config/powerpc/ppc64linux.mh: New file.
* config/powerpc/ppc64linux.mt: New file.
* config/powerpc/tm-ppc64linux.h: New file.
* ppc64-linux-tdep.c: New file.
* configure.host: Add clause for powerpc64-*-linux*
* configure.tgt: Add clause for powerpc64-*-linux*
* elfread.c (record_minimal_symbol_and_info): If
DROP_TEXT_NAME_PREFIX_CHAR is #defined, then drop a leading
instance of that char from the names of text symbols.
(elf_symtab_read): If SKIP_DATA_IN_OPD is #defined, ignore data
symbols in the .opd section.
* ppc-linux-nat.c (PTRACE_XFER_TYPE): Change the default for this
to 'long'.
(PPC_PTRACE_POKEUSR_3264, PPC_PTRACE_PEEKUSR_3264,
PPC_PTRACE_POKEDATA_3264, PPC_PTRACE_PEEKDATA_3264): Provide
default definitions for these.
(ARCH64): New macro.
(ppc_wordsize_pid): New function.
(kernel_u_size): Handle 64-bit case.
(ppc_register_u_addr): Same.
(fetch_register): Use the *_3264 requests when
debugging a 64-bit process from a 32-bit GDB.
(store_register): Same.
(GDB_MAX_ALLOCA, child_xfer_memory, udot_info): Copied from
infptrace.c.
(_initialize_ppc_linux_nat): New function, to register our copy of
the udot_info command.
* ppc-linux-tdep.c (TDEP): New macro.
(ppc64_linux_svr4_fetch_link_map_offsets): New function.
(read_memory_addr): Copied from rs6000-tdep.c.
(ppc64_linux_convert_from_func_ptr_addr): New function.
* rs6000-tdep.c (skip_prologue): Recognize more instructions for
saving the 'lr' and 'cr' registers; don't just pre-emptively mask
in the 'st' opcode as soon as we see an 'mflr' or 'mfcr' opcode.
Recognize more instructions for updating the stack pointer, and
loading the TOC pointer.
(registers_powerpc64, registers_a35): New register tables.
(rs6000_gdbarch_init): Register the 64-bit solib functions.
* solib-svr4.c (solib_break_names): If SOLIB_BREAK_NAME is
#defined, include an entry for it.
(enable_break): Call CONVERT_FROM_FUNC_PTR_ADDR when trying to
guess the linker's base address.
* config/powerpc/tm-linux.h
(ppc64_linux_svr4_fetch_link_map_offsets,
ppc64_linux_convert_from_func_ptr_addr): New declarations.
@
text
@d51 1
a51 1
/* Default the type of the ptrace transfer to long.  */
d53 1
a53 1
#define PTRACE_XFER_TYPE long
a55 97
/* Write DATA into location ADDR within the "user area" on a 64-bit
   process from a 32-bit process. */
#ifndef PPC_PTRACE_POKEUSR_3264
#define PPC_PTRACE_POKEUSR_3264   0x90 
#endif

/* Read a register (specified by ADDR) out of the "user area" on a
   64-bit process from a 32-bit process. */
#ifndef PPC_PTRACE_PEEKUSR_3264
#define PPC_PTRACE_PEEKUSR_3264   0x91
#endif

/* Write word at location ADDR on a 64-bit process from a 32-bit process. */
#ifndef PPC_PTRACE_POKEDATA_3264
#define PPC_PTRACE_POKEDATA_3264   0x92
#endif

/* Read word at location ADDR on a 64-bit process from a 32-bit
   process. */
#ifndef PPC_PTRACE_PEEKDATA_3264
#define PPC_PTRACE_PEEKDATA_3264   0x94
#endif

#define ARCH64() (REGISTER_RAW_SIZE (0) == 8)

/* REALLY SHAMELESS HACK:

   32 bit programs can exec 64 bit programs and so forth. GDB launches
   the inferior process by lauching ${SHELL} -c <program and args>.
   Fortunately, we know that it only tries to get the PC so we only
   have to hack that.. I THINK.

   At this time we are not ready to unify ppc32 and ppc64 as
   rs/6000-aix is. and there is know easy way to find out if a process
   is running 32 or 64 bits so we have this little hack.

   EVEN MORE SHAMELESS HACK: rs6000-nat.c solves this problem by
   expecting the first few ptracex() calls to fail.

*/
#include <sys/stat.h>
#include "bfd/elf-bfd.h"
static int
ppc_wordsize_pid(pid_t pid)
{
  static ino_t fino = 0;
  static int last = 0;
  struct stat sb;
  const char fmt[] = "/proc/%u/exe";
  FILE *file;
  char *fname = alloca (sizeof(fmt) + 10); /* 10 digit pid.. why not */
  Elf_Internal_Ehdr elfh;

  if ((gdbarch_tdep (current_gdbarch))->wordsize == 4)
    return 4;

  sprintf (fname, fmt, pid);

  if (stat(fname, &sb) == -1)
    {
      internal_error (__FILE__, __LINE__,
		      "could not stat executable from /proc.");
      return 0;
    }

  if (fino == sb.st_ino)
      return last;

  fino = sb.st_ino;

  /* FIXME: could stat the file and check if inode changed. */
  file = fopen (fname, "rb");
  if (file == NULL)
    {
      internal_error (__FILE__, __LINE__,
		      "could not open executable from /proc.");
      return 0;
    }

  if (fread (elfh.e_ident, EI_NIDENT, 1, file) == 1)
    {
      if (elfh.e_ident [EI_CLASS] == ELFCLASS64)
	last = 8;
      else
	last = 4;
    }
  else
    {
      last = 0;
      internal_error (__FILE__, __LINE__,
		      "could not read executable from /proc.");
    }
  fclose (file);
  
  return last;
}

d109 1
a109 9
  if ((gdbarch_tdep (current_gdbarch))->wordsize == sizeof (PTRACE_XFER_TYPE))
    return (sizeof (struct user));
  else
    {
      /* with a 64-bit kernel, all members of struct user go from 32
         to 64 bit except for the u_comm character array so we can
         double everything and subtract sizeof u_comm. */
      return ((sizeof (struct user) * 2) - sizeof (((struct user*)0)->u_comm));
    }
a129 1
  int wordsize = tdep->wordsize;
d133 1
a133 1
    u_addr =  ((PT_R0 + regno) * wordsize);
d137 1
a137 1
    u_addr = ((PT_FPR0 + (regno - FP0_REGNUM) * 2) * wordsize);
d141 1
a141 1
    u_addr = PT_NIP * wordsize;
d143 1
a143 1
    u_addr = PT_LNK * wordsize;
d145 1
a145 1
    u_addr = PT_CCR * wordsize;
d147 1
a147 1
    u_addr = PT_XER * wordsize;
d149 1
a149 1
    u_addr = PT_CTR * wordsize;
d151 1
a151 1
    u_addr = PT_MQ * wordsize;
d153 1
a153 1
    u_addr = PT_MSR * wordsize;
d155 1
a155 1
    u_addr = PT_FPSCR * wordsize;
a208 10
  int wordsize = (gdbarch_tdep (current_gdbarch))->wordsize;

  /* Do the easy thing for now which is to silently succeed if we are
     attached to a 32-bit process when we are expecting 64-bits */
  if (wordsize != ppc_wordsize_pid(tid))
    {
      /* supplying garbage.. but that's ok */
      supply_register (regno, buf);
      return;
    }
d236 2
a237 13
      if (wordsize != sizeof (PTRACE_XFER_TYPE))
	{
	  PTRACE_XFER_TYPE reg;
	  ptrace (PPC_PTRACE_PEEKUSR_3264, tid,
		  (PTRACE_ARG3_TYPE) regaddr, &reg);
	  *(PTRACE_XFER_TYPE *) & buf[i] = reg;
	}
      else
      {
	  *(PTRACE_XFER_TYPE *) & buf[i] = ptrace (PT_READ_U, tid,
						   (PTRACE_ARG3_TYPE) regaddr, 0);
      }

a367 1
  int wordsize = (gdbarch_tdep (current_gdbarch))->wordsize;
d382 2
a383 12
      if (wordsize != sizeof (PTRACE_XFER_TYPE))
	{
	  PTRACE_XFER_TYPE reg;
	  ptrace (PPC_PTRACE_POKEUSR_3264, tid, (PTRACE_ARG3_TYPE) regaddr,
		  *(PTRACE_XFER_TYPE *) & buf[i]);
	}
      else
      {
	  ptrace (PT_WRITE_U, tid, (PTRACE_ARG3_TYPE) regaddr,
		  *(PTRACE_XFER_TYPE *) & buf[i]);
      }

a535 240
}


#ifdef CHILD_XFER_MEMORY

/* this is a complete rip off from infptrace.c */

#ifndef GDB_MAX_ALLOCA
#define GDB_MAX_ALLOCA 0x1000
#endif /* GDB_MAX_ALLOCA */

/* Copy LEN bytes to or from inferior's memory starting at MEMADDR to
   debugger memory starting at MYADDR.  Copy to inferior if WRITE is
   nonzero.  TARGET is ignored.

   Returns the length copied, which is either the LEN argument or
   zero.  This xfer function does not do partial moves, since
   child_ops doesn't allow memory operations to cross below us in the
   target stack anyway.  */

int
child_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
		   struct mem_attrib *attrib, struct target_ops *target)
{
    int i;
  /* Round starting address down to longword boundary.  */
    CORE_ADDR addr = memaddr & -(CORE_ADDR) sizeof (PTRACE_XFER_TYPE);
  /* Round ending address up; get number of longwords that makes.  */
    int count = ((((memaddr + len) - addr) + sizeof (PTRACE_XFER_TYPE) - 1)
		 / sizeof (PTRACE_XFER_TYPE));
    int alloc = count * sizeof (PTRACE_XFER_TYPE);
    PTRACE_XFER_TYPE *buffer;
    struct cleanup *old_chain = NULL;
    int wordsize = (gdbarch_tdep (current_gdbarch))->wordsize;
    int arch64 = ARCH64();

  /* Allocate buffer of that many longwords.  */
    if (len < GDB_MAX_ALLOCA)
    {
	buffer = (PTRACE_XFER_TYPE *) alloca (alloc);
    }
    else
    {
	buffer = (PTRACE_XFER_TYPE *) xmalloc (alloc);
	old_chain = make_cleanup (xfree, buffer);
    }

  /* WARNING: from kernel source: "when I and D space are separate,
     these will need to be fixed." */
    if (write)
    {
      /* Fill start and end extra bytes of buffer with existing memory
	 data.  */
	if (addr != memaddr || len < (int) sizeof (PTRACE_XFER_TYPE))
	{
	  /* Need part of initial word -- fetch it.  */
	    if (wordsize == sizeof (PTRACE_XFER_TYPE) && (!arch64))
	    {
		buffer[0] = ptrace (PT_READ_I, PIDGET (inferior_ptid), 
				    (PTRACE_ARG3_TYPE) addr, 0);
	    }
	    else
	    {
		if (arch64) {
		    buffer[0] = ptrace (PTRACE_PEEKDATA, PIDGET (inferior_ptid), 
					(unsigned long) addr, 0);
		}
		else 
		{
		    ptrace (PPC_PTRACE_PEEKDATA_3264, PIDGET (inferior_ptid), 
			    (PTRACE_ARG3_TYPE) &addr, buffer);
		}
	    }
	}
	if (count > 1)		/* FIXME, avoid if even boundary.  */
	{
	    CORE_ADDR a64 = (addr + (count - 1) * sizeof (PTRACE_XFER_TYPE));
	    if (wordsize == sizeof (PTRACE_XFER_TYPE) && (!arch64))
	    {
		buffer[count - 1] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
					    (PTRACE_ARG3_TYPE) a64, 0);
	    }
	    else
		if (arch64) {
		    buffer[count-1] = ptrace (PTRACE_PEEKDATA, PIDGET (inferior_ptid),
					      (PTRACE_ARG3_TYPE) &a64, 0);
		}
		else
		{
		    ptrace (PPC_PTRACE_PEEKDATA_3264, PIDGET (inferior_ptid),
			    (PTRACE_ARG3_TYPE) &a64, &buffer[count - 1]);
		}
	}

      /* Copy data to be written over corresponding part of buffer.  */
	memcpy ((char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
		myaddr, len);

      /* Write the entire buffer.  */
	for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
	{
	    errno = 0;
	    if (wordsize == sizeof (PTRACE_XFER_TYPE) && (!arch64))
	    {
		ptrace (PT_WRITE_D, PIDGET (inferior_ptid), 
			(PTRACE_ARG3_TYPE) addr, buffer[i]);
	    }
	    else
		if (arch64) {
		    ptrace (PT_WRITE_D, PIDGET (inferior_ptid), 
			    (unsigned long) addr, buffer[i]);  
		}
		else 
		{
		    ptrace (PPC_PTRACE_POKEDATA_3264, PIDGET (inferior_ptid), 
			    (PTRACE_ARG3_TYPE) &addr, buffer[i]);
		}
	    if (errno)
	    {
		errno = 0;
		if (wordsize == sizeof (PTRACE_XFER_TYPE) && (!arch64))
		{
		    ptrace (PT_WRITE_I, PIDGET (inferior_ptid), 
			    (PTRACE_ARG3_TYPE) addr, buffer[i]);
		}
		else
		    if (arch64) {
			ptrace (PTRACE_POKEDATA, PIDGET (inferior_ptid),  
				(PTRACE_ARG3_TYPE) addr, buffer[i]); 
		    }
		    else 
		    {
			ptrace (PPC_PTRACE_POKEDATA_3264, PIDGET (inferior_ptid), 
				(PTRACE_ARG3_TYPE) &addr, buffer[i]);
		    }
	    }
	    if (errno)
		return 0;
	}
#ifdef CLEAR_INSN_CACHE
	    CLEAR_INSN_CACHE ();
#endif
    }
  else
  {
      /* Read all the longwords.  */
      for (i = 0; i < count; i++, addr += sizeof (PTRACE_XFER_TYPE))
      {
	  errno = 0;
	  if (wordsize == sizeof (PTRACE_XFER_TYPE) && (!arch64))
	  {
	      buffer[i] = ptrace (PT_READ_I, PIDGET (inferior_ptid),
				  (PTRACE_ARG3_TYPE) addr, 0);
	  }
	  else
	  {
	      if (arch64) {
		  buffer[i] = ptrace (PTRACE_PEEKDATA, PIDGET (inferior_ptid),
				      (unsigned long) addr, 0);
	      }
	      else
	      {
		  ptrace (PPC_PTRACE_PEEKDATA_3264, PIDGET (inferior_ptid),
			  (PTRACE_ARG3_TYPE) &addr, &buffer[i]);
	      }
	      if (errno)
		  return 0;
	      QUIT;
	  }

      /* Copy appropriate bytes out of the buffer.  */
	  memcpy (myaddr,
		  (char *) buffer + (memaddr & (sizeof (PTRACE_XFER_TYPE) - 1)),
		  len);
      }
  }
  if (old_chain != NULL)
    do_cleanups (old_chain);
  return len;
    }


/* Did not want to add this originally since the kernel will give us a
   lot of gargabe (and would probably fail if it wasn't for the
   FPU's). But at least you can get the other registers in struct
   pt_regs.  Perhaps we can get the kernels to co-operate. */
static void
udot_info (char *dummy1, int dummy2)
{
  int udot_off;			/* Offset into user struct */
  int udot_val;			/* Value from user struct at udot_off */
  char mess[128];		/* For messages */
  int wordsize = (gdbarch_tdep (current_gdbarch))->wordsize;

  if (!target_has_execution)
    {
      error ("The program is not being run.");
    }

  for (udot_off = 0; udot_off < KERNEL_U_SIZE; udot_off += sizeof (udot_val))
    {
      if ((udot_off % 24) == 0)
	{
	  if (udot_off > 0)
	    {
	      printf_filtered ("\n");
	    }
	  printf_filtered ("%04x:", udot_off);
	}
      if (wordsize != sizeof (PTRACE_XFER_TYPE))
	{
	  PTRACE_XFER_TYPE reg;
	  /* ptrace will place contents in "data" pointer */
	  ptrace (PPC_PTRACE_PEEKUSR_3264, PIDGET (inferior_ptid),
		  (PTRACE_ARG3_TYPE) udot_off, &reg);
	  udot_val = reg;
	}
      else
	udot_val = ptrace (PT_READ_U, PIDGET (inferior_ptid),
			   (PTRACE_ARG3_TYPE) udot_off, 0);
      if (errno != 0)
	{
	  sprintf (mess, "\nreading user struct at offset 0x%x", udot_off);
	  perror_with_name (mess);
	}
      /* Avoid using nonportable (?) "*" in print specs */
      printf_filtered (sizeof (int) == 4 ? " 0x%08x" : " 0x%16x", udot_val);
    }
  printf_filtered ("\n");
}
#endif /* CHILD_XFER_MEMORY */

#include "command.h"
void
_initialize_ppc_linux_nat (void)
{
#ifdef CHILD_XFER_MEMORY
  add_info ("udot", udot_info,
	    "Print contents of kernel ``struct user'' for current child.");
#endif
@


1.20
log
@2003-02-06  Andrew Cagney  <ac131313@@redhat.com>

	* Makefile.in (symm-nat.o): Update dependencies.
	(sparc-nat.o, procfs.o, proc-api.o, ppc-linux-nat.o): Ditto.
	(lynx-nat.o, ia64-linux-nat.): Ditto.
	* symm-nat.c, sparc-nat.c, procfs.c, proc-api.c: Include
	"gdb_wait.h" instead of <wait.h> or <sys/wait.h>.
	* ppc-linux-nat.c, lynx-nat.c, ia64-linux-nat.c: Ditto.
@
text
@d207 1
a207 1
  char *buf = alloca (MAX_REGISTER_RAW_SIZE);
d367 1
a367 1
  char *buf = alloca (MAX_REGISTER_RAW_SIZE);
@


1.20.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d207 1
a207 1
  char buf[MAX_REGISTER_SIZE];
d367 1
a367 1
  char buf[MAX_REGISTER_SIZE];
@


1.19
log
@2002-12-06  Elena Zannoni  <ezannoni@@redhat.com>

	* ia64-linux-nat.c: Include gdb_string.h.
	* alpha-nat.c: Ditto.
	* ia64-linux-nat.c: Ditto.
@
text
@d2 3
a4 2
   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002
   Free Software Foundation, Inc.
d35 1
a35 1
#include <sys/wait.h>
@


1.18
log
@        * ppc-linux-tdep.c (ELF_NGREG, ELF_NFPREG, ELF_NVRREG)
        (ELF_FPREGSET_SIZE, ELF_GREGSET_SIZE): New enums.
        (fetch_core_registers, ppc_linux_supply_gregset)
        (ppc_linux_supply_fpregset): New functions.
        (ppc_linux_regset_core_fns): New.
        (_initialize_ppc_linux_tdep): Call add_core_fns.
        * ppc-tdep.h: Add prototypes for ppc_linux_supply_fpregset
        and ppc_linux_supply_gregset.
        * ppc-linux-nat.c (supply_gregset): Call ppc_linux_supply_gregset.
        (supply_fpregset): Call ppc_linux_supply_fpregset.
        * config/powerpc/linux.mh (NATDEPFILES): Remove core-regset.o and
        corelow.o.
        * config/powerpc/linux.mt (TDEPFILES): Add corelow.o.
@
text
@d23 1
@


1.18.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 2
a3 3

   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
a22 1
#include "gdb_string.h"
d33 1
a33 1
#include "gdb_wait.h"
a127 3
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (PTRACE_XFER_TYPE);
d131 1
a131 1
    u_addr =  ((PT_R0 + regno) * wordsize);
d133 1
a133 3
  /* Floating point regs: eight bytes each in both 32- and 64-bit
     ptrace interfaces.  Thus, two slots each in 32-bit interface, one
     slot each in 64-bit interface.  */
d135 1
a135 1
    u_addr = (PT_FPR0 * wordsize) + ((regno - FP0_REGNUM) * 8);
d139 1
a139 1
    u_addr = PT_NIP * wordsize;
d141 1
a141 1
    u_addr = PT_LNK * wordsize;
d143 1
a143 1
    u_addr = PT_CCR * wordsize;
d145 1
a145 1
    u_addr = PT_XER * wordsize;
d147 1
a147 2
    u_addr = PT_CTR * wordsize;
#ifdef PT_MQ
d149 1
a149 2
    u_addr = PT_MQ * wordsize;
#endif
d151 1
a151 1
    u_addr = PT_MSR * wordsize;
d153 1
a153 1
    u_addr = PT_FPSCR * wordsize;
d174 1
a174 1
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d192 1
a192 1
    offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d203 1
a203 1
  int i;
d205 1
a205 1
  char buf[MAX_REGISTER_SIZE];
d226 1
a226 1
      memset (buf, '\0', DEPRECATED_REGISTER_RAW_SIZE (regno));   /* Supply zeroes */
d231 1
a231 4
  /* Read the raw register using PTRACE_XFER_TYPE sized chunks.  On a
     32-bit platform, 64-bit floating-point registers will require two
     transfers.  */
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d244 1
a244 13

  /* Now supply the register.  Be careful to map between ptrace's and
     the current_regcache's idea of the current wordsize.  */
  if ((regno >= FP0_REGNUM && regno < FP0_REGNUM +32)
      || gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
    /* FPs are always 64 bits.  Little endian values are always found
       at the left-hand end of the register.  */
    regcache_raw_supply (current_regcache, regno, buf);
  else
    /* Big endian register, need to fetch the right-hand end.  */
    regcache_raw_supply (current_regcache, regno,
                        (buf + sizeof (PTRACE_XFER_TYPE)
                         - register_size (current_gdbarch, regno)));
d253 2
a254 2
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d331 1
a331 1
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d347 1
a347 1
    offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d363 1
a363 1
  int i;
d365 1
a365 1
  char buf[MAX_REGISTER_SIZE];
d376 2
a377 16
  /* First collect the register value from the regcache.  Be careful
     to to convert the regcache's wordsize into ptrace's wordsize.  */
  memset (buf, 0, sizeof buf);
  if ((regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
      || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
    /* Floats are always 64-bit.  Little endian registers are always
       at the left-hand end of the register cache.  */
    regcache_raw_collect (current_regcache, regno, buf);
  else
    /* Big-endian registers belong at the right-hand end of the
       buffer.  */
    regcache_raw_collect (current_regcache, regno,
                         (buf + sizeof (PTRACE_XFER_TYPE)
                          - register_size (current_gdbarch, regno)));

  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d406 2
a407 2
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d427 1
a427 1
  ret = ptrace (PTRACE_GETVRREGS, tid, 0, &regs);
d440 1
a440 1
  if (ptrace (PTRACE_SETVRREGS, tid, 0, &regs) < 0)
a503 1
#ifdef PT_MQ
a506 1
#endif
@


1.18.8.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a22 1
#include "gdb_string.h"
@


1.18.8.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 2
a3 3

   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002,
   2003 Free Software Foundation, Inc.
d34 1
a34 1
#include "gdb_wait.h"
@


1.18.8.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d207 1
a207 1
  char buf[MAX_REGISTER_SIZE];
d367 1
a367 1
  char buf[MAX_REGISTER_SIZE];
@


1.18.8.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a129 1
  int wordsize = tdep->wordsize;
d133 1
a133 1
    u_addr =  ((PT_R0 + regno) * wordsize);
d135 1
a135 3
  /* Floating point regs: eight bytes each in both 32- and 64-bit
     ptrace interfaces.  Thus, two slots each in 32-bit interface, one
     slot each in 64-bit interface.  */
d137 1
a137 1
    u_addr = (PT_FPR0 * wordsize) + ((regno - FP0_REGNUM) * 8);
d141 1
a141 1
    u_addr = PT_NIP * wordsize;
d143 1
a143 1
    u_addr = PT_LNK * wordsize;
d145 1
a145 1
    u_addr = PT_CCR * wordsize;
d147 1
a147 1
    u_addr = PT_XER * wordsize;
d149 1
a149 2
    u_addr = PT_CTR * wordsize;
#ifdef PT_MQ
d151 1
a151 2
    u_addr = PT_MQ * wordsize;
#endif
d153 1
a153 1
    u_addr = PT_MSR * wordsize;
d155 1
a155 1
    u_addr = PT_FPSCR * wordsize;
d429 1
a429 1
  ret = ptrace (PTRACE_GETVRREGS, tid, 0, &regs);
d442 1
a442 1
  if (ptrace (PTRACE_SETVRREGS, tid, 0, &regs) < 0)
a505 1
#ifdef PT_MQ
a508 1
#endif
@


1.18.8.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d210 1
a210 1
  int i;
d370 1
a370 1
  int i;
@


1.18.8.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d181 1
a181 1
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d199 1
a199 1
    offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d233 1
a233 1
      memset (buf, '\0', DEPRECATED_REGISTER_RAW_SIZE (regno));   /* Supply zeroes */
d238 1
a238 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d260 2
a261 2
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d338 1
a338 1
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
d354 1
a354 1
    offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
d384 1
a384 1
  for (i = 0; i < DEPRECATED_REGISTER_RAW_SIZE (regno); i += sizeof (PTRACE_XFER_TYPE))
d413 2
a414 2
  int vrregsize = DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vr0_regnum);
  int offset = vrregsize - DEPRECATED_REGISTER_RAW_SIZE (tdep->ppc_vrsave_regnum);
@


1.18.8.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d130 1
a130 3
  /* NOTE: cagney/2003-11-25: This is the word size used by the ptrace
     interface, and not the wordsize of the program's ABI.  */
  int wordsize = sizeof (PTRACE_XFER_TYPE);
a237 3
  /* Read the raw register using PTRACE_XFER_TYPE sized chunks.  On a
     32-bit platform, 64-bit floating-point registers will require two
     transfers.  */
d251 1
a251 13

  /* Now supply the register.  Be careful to map between ptrace's and
     the current_regcache's idea of the current wordsize.  */
  if ((regno >= FP0_REGNUM && regno < FP0_REGNUM +32)
      || gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
    /* FPs are always 64 bits.  Little endian values are always found
       at the left-hand end of the register.  */
    regcache_raw_supply (current_regcache, regno, buf);
  else
    /* Big endian register, need to fetch the right-hand end.  */
    regcache_raw_supply (current_regcache, regno,
                        (buf + sizeof (PTRACE_XFER_TYPE)
                         - register_size (current_gdbarch, regno)));
d383 1
a383 15
  /* First collect the register value from the regcache.  Be careful
     to to convert the regcache's wordsize into ptrace's wordsize.  */
  memset (buf, 0, sizeof buf);
  if ((regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
      || TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
    /* Floats are always 64-bit.  Little endian registers are always
       at the left-hand end of the register cache.  */
    regcache_raw_collect (current_regcache, regno, buf);
  else
    /* Big-endian registers belong at the right-hand end of the
       buffer.  */
    regcache_raw_collect (current_regcache, regno,
                         (buf + sizeof (PTRACE_XFER_TYPE)
                          - register_size (current_gdbarch, regno)));

@


1.17
log
@Add support for the fpscr register for Power / PowerPC targets.
@
text
@d478 1
a478 15
  int regi;
  register elf_greg_t *regp = (elf_greg_t *) gregsetp;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  for (regi = 0; regi < 32; regi++)
    supply_register (regi, (char *) (regp + regi));

  supply_register (PC_REGNUM, (char *) (regp + PT_NIP));
  supply_register (tdep->ppc_lr_regnum, (char *) (regp + PT_LNK));
  supply_register (tdep->ppc_cr_regnum, (char *) (regp + PT_CCR));
  supply_register (tdep->ppc_xer_regnum, (char *) (regp + PT_XER));
  supply_register (tdep->ppc_ctr_regnum, (char *) (regp + PT_CTR));
  if (tdep->ppc_mq_regnum != -1)
    supply_register (tdep->ppc_mq_regnum, (char *) (regp + PT_MQ));
  supply_register (tdep->ppc_ps_regnum, (char *) (regp + PT_MSR));
d514 1
a514 6
  int regi;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  for (regi = 0; regi < 32; regi++)
    supply_register (FP0_REGNUM + regi, (char *) (*fpregsetp + regi));
  supply_register (tdep->ppc_fpscr_regnum, (char *) (*fpregsetp + 32));
@


1.17.6.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d478 15
a492 1
  ppc_linux_supply_gregset ((char *) gregsetp);
d528 6
a533 1
  ppc_linux_supply_fpregset ((char *) fpregsetp);
@


1.16
log
@2002-02-21  Elena Zannoni  <ezannoni@@redhat.com>

	* ppc-linux-nat.c (PTRACE_GETVRREGS, PTRACE_SETVRREGS): Define.
	(have_ptrace_getvrregs): Define for run time checks.
	(gdb_vrregset_t): New type for Altivec register handling.
	(fetch_register, store_register): Fetch/store altivec register
	when needed.
	(fetch_altivec_register, store_altivec_register): New functions.
	(supply_vrregset, fill_vrregset): New functions.
	(fetch_altivec_registers, store_altivec_registers): New functions.
	(fetch_ppc_registers, store_ppc_registers): Fetch/store altivec
	registers as well.
@
text
@d152 2
d295 1
a295 1
  for (i = 0; i <= tdep->ppc_mq_regnum; i++)
d297 2
d383 8
d450 1
a450 1
  for (i = 0; i <= tdep->ppc_mq_regnum; i++)
d452 2
d490 2
a491 1
  supply_register (tdep->ppc_mq_regnum, (char *) (regp + PT_MQ));
d518 2
a519 1
  if ((regno == -1) || regno == tdep->ppc_mq_regnum)
d529 1
d533 1
d544 1
d551 2
@


1.15
log
@2002-02-18  Elena Zannoni  <ezannoni@@redhat.com>

	* ppc-linux-nat.c: Update copyright.
	(fetch_register, store_register): Add tid parameter, don't compute
	tid here.
	(fetch_ppc_registers, store_ppc_registers): Add tid
	parameter. Pass it along to callees.
	(fetch_inferior_registers, store_inferior_registers): Compute tid
	here, and pass it to calleed functions.
	(fill_gregset, supply_fpregset): Clean up formatting.
@
text
@d1 1
a1 1
/* PPC linux native support.
d54 50
d162 34
d206 16
d245 42
d291 3
a293 3
  int last_register = gdbarch_tdep (current_gdbarch)->ppc_mq_regnum;
  
  for (i = 0; i <= last_register; i++)
d295 3
d306 1
a306 1
 /* Overload thread id onto process id */
d313 1
a313 1
   if (regno == -1)
d321 33
d363 1
a363 1
  if (regaddr == -1)
d365 1
d369 3
d389 44
d436 1
a436 1
  int last_register = gdbarch_tdep (current_gdbarch)->ppc_mq_regnum;
d438 1
a438 1
  for (i = 0; i <= last_register; i++)
d440 3
d513 1
d518 4
a521 5
/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */

@


1.14
log
@2002-01-23  Elena Zannoni  <ezannoni@@redhat.com>

	* ppc-linux-nat.c (ppc_register_u_addr, supply_gregset,
	fill_gregset): Call gdbarch_tdep() just once, assign result to
	variable and use that, instead of calling the function several
	times.
@
text
@d2 1
a2 1
   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001
d19 2
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d113 1
a113 1
fetch_register (int regno)
a119 1
  int tid;
a128 4
  /* Overload thread id onto process id */
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);      /* no thread id, just use process id */

d146 1
a146 1
fetch_ppc_registers (void)
d152 1
a152 1
    fetch_register (i);
d161 9
a169 2
  if (regno == -1)
    fetch_ppc_registers ();
d171 1
a171 1
    fetch_register (regno);
d176 1
a176 1
store_register (int regno)
a182 1
  int tid;
a189 4
  /* Overload thread id onto process id */
  if ((tid = TIDGET (inferior_ptid)) == 0)
    tid = PIDGET (inferior_ptid);      /* no thread id, just use process id */

d207 1
a207 1
store_ppc_registers (void)
d213 1
a213 1
    store_register (i);
d219 7
d227 1
a227 1
    store_register (regno);
d229 1
a229 1
    store_ppc_registers ();
d266 1
a266 2
  if ((regno == -1) 
      || regno == tdep->ppc_lr_regnum)
d268 1
a268 2
  if ((regno == -1)
      || regno == tdep->ppc_cr_regnum)
d270 1
a270 2
  if ((regno == -1)
      || regno == tdep->ppc_xer_regnum)
d272 1
a272 2
  if ((regno == -1)
      || regno == tdep->ppc_ctr_regnum)
d274 1
a274 2
  if ((regno == -1)
      || regno == tdep->ppc_mq_regnum)
d276 1
a276 2
  if ((regno == -1)
      || regno == tdep->ppc_ps_regnum)
d285 1
a285 3
    {
      supply_register (FP0_REGNUM + regi, (char *) (*fpregsetp + regi));
    }
@


1.13
log
@2001-12-20  Elena Zannoni  <ezannoni@@redhat.com>

	* ppc-linux-nat.c (ppc_ptrace_cannot_fetch_store_register):
	New function.
	(fetch_register): New function.
	(fetch_ppc_registers): New function.
	(fetch_inferior_registers): New function.
	(store_register): New function.
	(store_ppc_registers): New function.
	(store_inferior_registers): New function.
	(ppc_register_u_addr): Eliminate ustart parameter and its
	uses. Make static.
	(PT_READ_U, PT_WRITE_U, PTRACE_XFER_TYPE): Define if needed.
	Include sys/ptrace.h.

	* config/powerpc/nm-linux.h (FETCH_INFERIOR_REGISTERS): Define.
	(U_REGS_OFFSET, REGISTER_U_ADDR): Delete.

	* config/powerpc/linux.mh (NATDEPFILES): Delete core-aout.o.
@
text
@d76 1
d79 1
a79 2
  if (regno >= gdbarch_tdep (current_gdbarch)->ppc_gp0_regnum
      && regno <= gdbarch_tdep (current_gdbarch)->ppc_gplast_regnum )
d89 1
a89 1
  if (regno == gdbarch_tdep (current_gdbarch)->ppc_lr_regnum)
d91 1
a91 1
  if (regno == gdbarch_tdep (current_gdbarch)->ppc_cr_regnum)
d93 1
a93 1
  if (regno == gdbarch_tdep (current_gdbarch)->ppc_xer_regnum)
d95 1
a95 1
  if (regno == gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum)
d97 1
a97 1
  if (regno == gdbarch_tdep (current_gdbarch)->ppc_mq_regnum)
d99 1
a99 1
  if (regno == gdbarch_tdep (current_gdbarch)->ppc_ps_regnum)
d232 1
d238 6
a243 12
  supply_register (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum,
		   (char *) (regp + PT_LNK));
  supply_register (gdbarch_tdep (current_gdbarch)->ppc_cr_regnum,
		   (char *) (regp + PT_CCR));
  supply_register (gdbarch_tdep (current_gdbarch)->ppc_xer_regnum,
		   (char *) (regp + PT_XER));
  supply_register (gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum,
		   (char *) (regp + PT_CTR));
  supply_register (gdbarch_tdep (current_gdbarch)->ppc_mq_regnum,
		   (char *) (regp + PT_MQ));
  supply_register (gdbarch_tdep (current_gdbarch)->ppc_ps_regnum,
		   (char *) (regp + PT_MSR));
d251 1
d262 2
a263 3
      || regno == gdbarch_tdep (current_gdbarch)->ppc_lr_regnum)
    regcache_collect (gdbarch_tdep (current_gdbarch)->ppc_lr_regnum,
		      regp + PT_LNK);
d265 2
a266 3
      || regno == gdbarch_tdep (current_gdbarch)->ppc_cr_regnum)
    regcache_collect (gdbarch_tdep (current_gdbarch)->ppc_cr_regnum,
		      regp + PT_CCR);
d268 2
a269 3
      || regno == gdbarch_tdep (current_gdbarch)->ppc_xer_regnum)
    regcache_collect (gdbarch_tdep (current_gdbarch)->ppc_xer_regnum,
		      regp + PT_XER);
d271 2
a272 3
      || regno == gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum)
    regcache_collect (gdbarch_tdep (current_gdbarch)->ppc_ctr_regnum,
		      regp + PT_CTR);
d274 2
a275 3
      || regno == gdbarch_tdep (current_gdbarch)->ppc_mq_regnum)
    regcache_collect (gdbarch_tdep (current_gdbarch)->ppc_mq_regnum,
		      regp + PT_MQ);
d277 2
a278 3
      || regno == gdbarch_tdep (current_gdbarch)->ppc_ps_regnum)
    regcache_collect (gdbarch_tdep (current_gdbarch)->ppc_ps_regnum,
		      regp + PT_MSR);
@


1.12
log
@2001-12-09  Elena Zannoni  <ezannoni@@redhat.com>

	* config/rs6000/tm-rs6000.h (STAB_REG_TO_REGNUM): Remove
	definition, it is now multiarched.
	* ppc-tdep.h (struct gdbarch_tdep): Move from rs6000-tdep.c.  Add
	fields for special register numbers.
	* rs6000-tdep.c (rs6000_gdbarch_init): Initialize new tdep special
	regnum fields.
	(rs6000_saved_pc_after_call): Use gdbarch_tdep registers fields
	instead of hardcoded macros.
	(branch_dest, rs6000_pop_frame, rs6000_fix_call_dummy,
	ppc_push_return_address, rs6000_frame_saved_pc,
	frame_get_saved_regs, rs6000_frame_chain,
	rs6000_store_return_value): Ditto.
	(rs6000_stab_reg_to_regnum): New function.
	* ppcnbsd-nat.c (fetch_inferior_registers,
	store_inferior_registers, fetch_core_registers): Ditto.
	* ppc-linux-tdep.c (ppc_linux_in_sigtramp,
	ppc_linux_frame_init_saved_regs): Ditto.
	* ppc-linux-nat.c (ppc_register_u_addr, supply_gregset,
	fill_gregset): Ditto.
	* ppc-bdm.c (bdm_ppc_fetch_registers, bdm_ppc_store_registers):
	Ditto.
@
text
@d35 1
d41 12
d72 2
a73 2
int 
ppc_register_u_addr (int ustart, int regno)
d80 1
a80 1
    u_addr =  (ustart + (PT_R0 + regno) * 4);
d84 1
a84 1
    u_addr = (ustart + (PT_FPR0 + (regno - FP0_REGNUM) * 2) * 4);
d88 1
a88 1
    u_addr = ustart + PT_NIP * 4;
d90 1
a90 1
    u_addr = ustart + PT_LNK * 4;
d92 1
a92 1
    u_addr = ustart + PT_CCR * 4;
d94 1
a94 1
    u_addr = ustart + PT_XER * 4;
d96 1
a96 1
    u_addr = ustart + PT_CTR * 4;
d98 1
a98 1
    u_addr = ustart + PT_MQ * 4;
d100 1
a100 1
    u_addr = ustart + PT_MSR * 4;
d105 122
a248 1
 
@


1.11
log
@2001-11-29  Elena Zannoni  <ezannoni@@redhat.com>

	* Makefile.in (ppc-linux-nat.o): Add dependency on ppc-tdep.h.

	* ppc-tdep.h (PPC_GPLAST_REGNUM): Define.

	* ppc-linux-nat.c: Include ppc-tdep.h.
	(ppc_register_u_addr): Don't use the static array regmap[],
	dynamically define the mapping instead.
	(supply_gregset): Ditto.
	(fill_gregset): Ditto.
	(COPY_REG): Delete macro defintion.
	(regmap): Delete array.
@
text
@d65 2
a66 1
  if (regno >= PPC_GP0_REGNUM && regno <= PPC_GPLAST_REGNUM )
d76 1
a76 1
  if (regno == PPC_LR_REGNUM)
d78 1
a78 1
  if (regno == PPC_CR_REGNUM)
d80 1
a80 1
  if (regno == PPC_XER_REGNUM)
d82 1
a82 1
  if (regno == PPC_CTR_REGNUM)
d84 1
a84 1
  if (regno == PPC_MQ_REGNUM)
d86 1
a86 1
  if (regno == PPC_PS_REGNUM)
d102 13
a114 6
  supply_register (PPC_LR_REGNUM, (char *) (regp + PT_LNK));
  supply_register (PPC_CR_REGNUM, (char *) (regp + PT_CCR));
  supply_register (PPC_XER_REGNUM, (char *) (regp + PT_XER));
  supply_register (PPC_CTR_REGNUM, (char *) (regp + PT_CTR));
  supply_register (PPC_MQ_REGNUM, (char *) (regp + PT_MQ));
  supply_register (PPC_PS_REGNUM, (char *) (regp + PT_MSR));
d131 24
a154 12
  if ((regno == -1) || regno == PPC_LR_REGNUM)
    regcache_collect (PPC_LR_REGNUM, regp + PT_LNK);
  if ((regno == -1) || regno == PPC_CR_REGNUM)
    regcache_collect (PPC_CR_REGNUM, regp + PT_CCR);
  if ((regno == -1) || regno == PPC_XER_REGNUM)
    regcache_collect (PPC_XER_REGNUM, regp + PT_XER);
  if ((regno == -1) || regno == PPC_CTR_REGNUM)
    regcache_collect (PPC_CTR_REGNUM, regp + PT_CTR);
  if ((regno == -1) || regno == PPC_MQ_REGNUM)
    regcache_collect (PPC_MQ_REGNUM, regp + PT_MQ);
  if ((regno == -1) || regno == PPC_PS_REGNUM)
    regcache_collect (PPC_PS_REGNUM, regp + PT_MSR);
@


1.10
log
@ 2001-11-19  Elena Zannoni  <ezannoni@@redhat.com>

	* ppc-linux-nat.c (COPY_REG): Use regcache_collect instead of
	accessing registers[].
	(fill_fpregset): Ditto.
@
text
@d38 1
d46 12
a57 10
static int regmap[] =
{PT_R0, PT_R1, PT_R2, PT_R3, PT_R4, PT_R5, PT_R6, PT_R7,
 PT_R8, PT_R9, PT_R10, PT_R11, PT_R12, PT_R13, PT_R14, PT_R15,
 PT_R16, PT_R17, PT_R18, PT_R19, PT_R20, PT_R21, PT_R22, PT_R23,
 PT_R24, PT_R25, PT_R26, PT_R27, PT_R28, PT_R29, PT_R30, PT_R31,
 PT_FPR0, PT_FPR0 + 2, PT_FPR0 + 4, PT_FPR0 + 6, PT_FPR0 + 8, PT_FPR0 + 10, PT_FPR0 + 12, PT_FPR0 + 14,
 PT_FPR0 + 16, PT_FPR0 + 18, PT_FPR0 + 20, PT_FPR0 + 22, PT_FPR0 + 24, PT_FPR0 + 26, PT_FPR0 + 28, PT_FPR0 + 30,
 PT_FPR0 + 32, PT_FPR0 + 34, PT_FPR0 + 36, PT_FPR0 + 38, PT_FPR0 + 40, PT_FPR0 + 42, PT_FPR0 + 44, PT_FPR0 + 46,
 PT_FPR0 + 48, PT_FPR0 + 50, PT_FPR0 + 52, PT_FPR0 + 54, PT_FPR0 + 56, PT_FPR0 + 58, PT_FPR0 + 60, PT_FPR0 + 62,
 PT_NIP, PT_MSR, PT_CCR, PT_LNK, PT_CTR, PT_XER, PT_MQ};
d60 1
a60 1
ppc_register_u_addr (int ustart, int regnum)
d62 27
a88 1
  return (ustart + 4 * regmap[regnum]);
d100 7
a106 2
  for (regi = FIRST_UISA_SP_REGNUM; regi <= LAST_UISA_SP_REGNUM; regi++)
    supply_register (regi, (char *) (regp + regmap[regi]));
a114 4
#define COPY_REG(_idx_,_regi_) \
  if ((regno == -1) || regno == _regi_) \
    regcache_collect (_regi_, regp + _idx_)

d117 2
a118 1
      COPY_REG (regmap[regi], regi);
d121 14
a134 4
  for (regi = FIRST_UISA_SP_REGNUM; regi <= LAST_UISA_SP_REGNUM; regi++)
    {
      COPY_REG (regmap[regi], regi);
    }
@


1.9
log
@        * ppc-linux-nat.c (supply_gregset): Use elf_greg_t instead
        of greg_t.
        (fill_gregset): Likewise.
@
text
@d83 1
a83 2
    memcpy (regp + _idx_, &registers[REGISTER_BYTE (_regi_)], \
	    REGISTER_RAW_SIZE (_regi_))
a114 2
  char *to;
  char *from;
d119 1
a119 5
        {
	  from = (char *) &registers[REGISTER_BYTE (FP0_REGNUM + regi)];
	  to = (char *) (*fpregsetp + regi);
	  memcpy (to, from, REGISTER_RAW_SIZE (FP0_REGNUM + regi));
        }
@


1.9.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@d38 1
a38 1
typedef elf_greg_t greg_t;
@


1.8
log
@Update/correct copyright notices.
@
text
@d66 1
a66 1
  register greg_t *regp = (greg_t *) gregsetp;
d79 1
a79 1
  greg_t *regp = (greg_t *) gregsetp;
@


1.7
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2001 Free Software
   Foundation, Inc.
@


1.6
log
@Make definitions of supply_gregset, fill_gregset, supply_fpregset,
and fill_fpregset match declarations in gregset.h.
@
text
@d2 2
a3 1
   Copyright (C) 1988, 1989, 1991, 1992, 1994, 1996 Free Software Foundation, Inc.
d25 1
@


1.5
log
@Enable Mark Kettenis' linux thread support for Linux/PPC.
@
text
@d61 1
a61 1
supply_gregset (gregset_t * gregsetp)
d74 1
a74 1
fill_gregset (gregset_t *gregsetp, int regno)
d96 1
a96 1
supply_fpregset (fpregset_t * fpregsetp)
d111 1
a111 1
fill_fpregset (fpregset_t *fpregsetp, int regno)
@


1.4
log
@Protoization.
@
text
@d74 22
d102 23
@


1.3
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d38 1
a38 1
kernel_u_size ()
@


1.2
log
@Cleanups and signal handler backtrace fix for GNU/Linux PPC port.
@
text
@d34 3
@


1.1
log
@Changes for GNU/Linux PPC native port of gdb.
@
text
@d57 1
d70 1
@
