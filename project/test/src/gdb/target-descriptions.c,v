head	1.47;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.46
	gdb_7_6-2013-04-26-release:1.46
	gdb_7_6-branch:1.46.0.2
	gdb_7_6-2013-03-12-branchpoint:1.46
	gdb_7_5_1-2012-11-29-release:1.42
	gdb_7_5-2012-08-17-release:1.42
	gdb_7_5-branch:1.42.0.2
	gdb_7_5-2012-07-18-branchpoint:1.42
	gdb_7_4_1-2012-04-26-release:1.39.4.1
	gdb_7_4-2012-01-24-release:1.39.4.1
	gdb_7_4-branch:1.39.0.4
	gdb_7_4-2011-12-13-branchpoint:1.39
	gdb_7_3_1-2011-09-04-release:1.39
	gdb_7_3-2011-07-26-release:1.39
	gdb_7_3-branch:1.39.0.2
	gdb_7_3-2011-04-01-branchpoint:1.39
	gdb_7_2-2010-09-02-release:1.35
	gdb_7_2-branch:1.35.0.2
	gdb_7_2-2010-07-07-branchpoint:1.35
	gdb_7_1-2010-03-18-release:1.31
	gdb_7_1-branch:1.31.0.2
	gdb_7_1-2010-02-18-branchpoint:1.31
	gdb_7_0_1-2009-12-22-release:1.28
	gdb_7_0-2009-10-06-release:1.28
	gdb_7_0-branch:1.28.0.2
	gdb_7_0-2009-09-16-branchpoint:1.28
	arc-sim-20090309:1.15
	msnyder-checkpoint-072509-branch:1.26.0.2
	msnyder-checkpoint-072509-branchpoint:1.26
	arc-insight_6_8-branch:1.15.0.8
	arc-insight_6_8-branchpoint:1.15
	insight_6_8-branch:1.15.0.6
	insight_6_8-branchpoint:1.15
	reverse-20081226-branch:1.19.0.6
	reverse-20081226-branchpoint:1.19
	multiprocess-20081120-branch:1.19.0.4
	multiprocess-20081120-branchpoint:1.19
	reverse-20080930-branch:1.19.0.2
	reverse-20080930-branchpoint:1.19
	reverse-20080717-branch:1.16.0.2
	reverse-20080717-branchpoint:1.16
	msnyder-reverse-20080609-branch:1.15.0.4
	msnyder-reverse-20080609-branchpoint:1.15
	drow-reverse-20070409-branch:1.6.0.2
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.15
	gdb_6_8-branch:1.15.0.2
	gdb_6_8-2008-02-26-branchpoint:1.15
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	gdb_6_7-branch:1.11.0.2
	gdb_6_7-2007-09-07-branchpoint:1.11;
locks; strict;
comment	@ * @;


1.47
date	2013.04.30.12.33.51;	author wtedeschi;	state Exp;
branches;
next	1.46;

1.46
date	2013.01.01.06.32.52;	author brobecke;	state Exp;
branches;
next	1.45;

1.45
date	2012.11.09.19.58.01;	author tromey;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.09.01.47.15;	author palves;	state Exp;
branches;
next	1.43;

1.43
date	2012.07.27.20.23.03;	author jkratoch;	state Exp;
branches;
next	1.42;

1.42
date	2012.04.25.18.36.05;	author sergiodj;	state Exp;
branches;
next	1.41;

1.41
date	2012.04.17.13.55.32;	author palves;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.04.08.17.13;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.02.23.14.32;	author msnyder;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2011.01.11.21.53.25;	author msnyder;	state Exp;
branches;
next	1.37;

1.37
date	2011.01.05.22.22.53;	author msnyder;	state Exp;
branches;
next	1.36;

1.36
date	2011.01.01.15.33.17;	author brobecke;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.17.01.15.20;	author msnyder;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.07.02.09.54;	author msnyder;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.01.17.26.03;	author hjl;	state Exp;
branches;
next	1.32;

1.32
date	2010.03.01.17.19.22;	author drow;	state Exp;
branches;
next	1.31;

1.31
date	2010.02.10.18.45.02;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2010.02.04.17.09.58;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2010.01.01.07.31.42;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.31.14.39.11;	author uweigand;	state Exp;
branches;
next	1.27;

1.27
date	2009.07.28.18.26.49;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.20.18.51.41;	author palves;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.24;

1.24
date	2009.07.02.12.48.54;	author uweigand;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.23.16.59.43;	author uweigand;	state Exp;
branches;
next	1.21;

1.21
date	2009.02.21.16.14.49;	author palves;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.24.18.01.15;	author tromey;	state Exp;
branches;
next	1.16;

1.16
date	2008.07.03.23.14.35;	author msnyder;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.02.14.27.15;	author uweigand;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.15.19.45.30;	author drow;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.15.19.19.17;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2007.08.23.18.08.45;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.03.01.23.01;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.13.18.26.59;	author drow;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.7;

1.7
date	2007.04.13.15.07.15;	author pbrook;	state Exp;
branches;
next	1.6;

1.6
date	2007.02.13.15.48.05;	author drow;	state Exp;
branches;
next	1.5;

1.5
date	2007.02.08.21.00.34;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.01.09.22.55.10;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.09.17.58.59;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.28.22.14.31;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.28.22.10.26;	author drow;	state Exp;
branches;
next	;

1.39.4.1
date	2012.01.06.04.43.31;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.47
log
@Fix display of structures/bitfields in register description.

Add support for displaying structures and bitfields for registers when
executing "maint print c-tdesc". This command is also used when
converting the xml target description file into c file.

Example of the behaviour is given below reporting a snipet of the xml file
and a snippet of the c code generated.

XML file contains:
...
    <union id="vecint">
      <field name="v4" type="v4int8"/>
      <field name="v2" type="v2int16"/>
    </union>

    <struct id="struct1">
      <field name="v4" type="v4int8"/>
      <field name="v2" type="v2int16"/>
    </struct>

    <struct id="struct2" size="8">
      <field name="f1" start="0" end="34"/>
      <field name="f2" start="63" end="63"/>
    </struct>
...

Setting this xml file as target description file and
issuing the maintenance print c-tdesc the following output
is obtained:

  feature = tdesc_create_feature (result, "extra");
  field_type = tdesc_named_type (feature, "int8");
  tdesc_create_vector (feature, "v4int8", field_type, 4);

  field_type = tdesc_named_type (feature, "int16");
  tdesc_create_vector (feature, "v2int16", field_type, 2);

  type = tdesc_create_union (feature, "vecint");
  field_type = tdesc_named_type (feature, "v4int8");
  tdesc_add_field (type, "v4", field_type);
  field_type = tdesc_named_type (feature, "v2int16");
  tdesc_add_field (type, "v2", field_type);

C output is not supported type "struct1".

This is finally the issue.

2013-03-27  Walfred Tedeschi  <walfred.tedeschi@@intel.com>

        * target-descriptions.c (maint_print_c_tdesc_cmd):
        Add case to parse structures as register types and
        bitfields.

testsuite/

	* gdb.xml/maint_print_struct.exp: New file.
	* gdb.xml/maint_print_struct.xml: New file.

Change-Id: I2e20b095d508319c80275e724a9452c7e2834067
Signed-off-by: Walfred Tedeschi <walfred.tedeschi@@intel.com>
@
text
@/* Target description support for GDB.

   Copyright (C) 2006-2013 Free Software Foundation, Inc.

   Contributed by CodeSourcery.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "arch-utils.h"
#include "gdbcmd.h"
#include "gdbtypes.h"
#include "reggroups.h"
#include "target.h"
#include "target-descriptions.h"
#include "vec.h"
#include "xml-support.h"
#include "xml-tdesc.h"
#include "osabi.h"

#include "gdb_assert.h"
#include "gdb_obstack.h"
#include "hashtab.h"
#include "inferior.h"

/* Types.  */

typedef struct property
{
  char *key;
  char *value;
} property_s;
DEF_VEC_O(property_s);

/* An individual register from a target description.  */

typedef struct tdesc_reg
{
  /* The name of this register.  In standard features, it may be
     recognized by the architecture support code, or it may be purely
     for the user.  */
  char *name;

  /* The register number used by this target to refer to this
     register.  This is used for remote p/P packets and to determine
     the ordering of registers in the remote g/G packets.  */
  long target_regnum;

  /* If this flag is set, GDB should save and restore this register
     around calls to an inferior function.  */
  int save_restore;

  /* The name of the register group containing this register, or NULL
     if the group should be automatically determined from the
     register's type.  If this is "general", "float", or "vector", the
     corresponding "info" command should display this register's
     value.  It can be an arbitrary string, but should be limited to
     alphanumeric characters and internal hyphens.  Currently other
     strings are ignored (treated as NULL).  */
  char *group;

  /* The size of the register, in bits.  */
  int bitsize;

  /* The type of the register.  This string corresponds to either
     a named type from the target description or a predefined
     type from GDB.  */
  char *type;

  /* The target-described type corresponding to TYPE, if found.  */
  struct tdesc_type *tdesc_type;
} *tdesc_reg_p;
DEF_VEC_P(tdesc_reg_p);

/* A named type from a target description.  */

typedef struct tdesc_type_field
{
  char *name;
  struct tdesc_type *type;
  int start, end;
} tdesc_type_field;
DEF_VEC_O(tdesc_type_field);

typedef struct tdesc_type_flag
{
  char *name;
  int start;
} tdesc_type_flag;
DEF_VEC_O(tdesc_type_flag);

typedef struct tdesc_type
{
  /* The name of this type.  */
  char *name;

  /* Identify the kind of this type.  */
  enum
  {
    /* Predefined types.  */
    TDESC_TYPE_INT8,
    TDESC_TYPE_INT16,
    TDESC_TYPE_INT32,
    TDESC_TYPE_INT64,
    TDESC_TYPE_INT128,
    TDESC_TYPE_UINT8,
    TDESC_TYPE_UINT16,
    TDESC_TYPE_UINT32,
    TDESC_TYPE_UINT64,
    TDESC_TYPE_UINT128,
    TDESC_TYPE_CODE_PTR,
    TDESC_TYPE_DATA_PTR,
    TDESC_TYPE_IEEE_SINGLE,
    TDESC_TYPE_IEEE_DOUBLE,
    TDESC_TYPE_ARM_FPA_EXT,
    TDESC_TYPE_I387_EXT,

    /* Types defined by a target feature.  */
    TDESC_TYPE_VECTOR,
    TDESC_TYPE_STRUCT,
    TDESC_TYPE_UNION,
    TDESC_TYPE_FLAGS
  } kind;

  /* Kind-specific data.  */
  union
  {
    /* Vector type.  */
    struct
    {
      struct tdesc_type *type;
      int count;
    } v;

    /* Struct or union type.  */
    struct
    {
      VEC(tdesc_type_field) *fields;
      LONGEST size;
    } u;

    /* Flags type.  */
    struct
    {
      VEC(tdesc_type_flag) *flags;
      LONGEST size;
    } f;
  } u;
} *tdesc_type_p;
DEF_VEC_P(tdesc_type_p);

/* A feature from a target description.  Each feature is a collection
   of other elements, e.g. registers and types.  */

typedef struct tdesc_feature
{
  /* The name of this feature.  It may be recognized by the architecture
     support code.  */
  char *name;

  /* The registers associated with this feature.  */
  VEC(tdesc_reg_p) *registers;

  /* The types associated with this feature.  */
  VEC(tdesc_type_p) *types;
} *tdesc_feature_p;
DEF_VEC_P(tdesc_feature_p);

/* A compatible architecture from a target description.  */
typedef const struct bfd_arch_info *arch_p;
DEF_VEC_P(arch_p);

/* A target description.  */

struct target_desc
{
  /* The architecture reported by the target, if any.  */
  const struct bfd_arch_info *arch;

  /* The osabi reported by the target, if any; GDB_OSABI_UNKNOWN
     otherwise.  */
  enum gdb_osabi osabi;

  /* The list of compatible architectures reported by the target.  */
  VEC(arch_p) *compatible;

  /* Any architecture-specific properties specified by the target.  */
  VEC(property_s) *properties;

  /* The features associated with this target.  */
  VEC(tdesc_feature_p) *features;
};

/* Per-architecture data associated with a target description.  The
   target description may be shared by multiple architectures, but
   this data is private to one gdbarch.  */

typedef struct tdesc_arch_reg
{
  struct tdesc_reg *reg;
  struct type *type;
} tdesc_arch_reg;
DEF_VEC_O(tdesc_arch_reg);

struct tdesc_arch_data
{
  /* A list of register/type pairs, indexed by GDB's internal register number.
     During initialization of the gdbarch this list is used to store
     registers which the architecture assigns a fixed register number.
     Registers which are NULL in this array, or off the end, are
     treated as zero-sized and nameless (i.e. placeholders in the
     numbering).  */
  VEC(tdesc_arch_reg) *arch_regs;

  /* Functions which report the register name, type, and reggroups for
     pseudo-registers.  */
  gdbarch_register_name_ftype *pseudo_register_name;
  gdbarch_register_type_ftype *pseudo_register_type;
  gdbarch_register_reggroup_p_ftype *pseudo_register_reggroup_p;
};

/* Info about an inferior's target description.  There's one of these
   for each inferior.  */

struct target_desc_info
{
  /* A flag indicating that a description has already been fetched
     from the target, so it should not be queried again.  */

  int fetched;

  /* The description fetched from the target, or NULL if the target
     did not supply any description.  Only valid when
     target_desc_fetched is set.  Only the description initialization
     code should access this; normally, the description should be
     accessed through the gdbarch object.  */

  const struct target_desc *tdesc;

  /* The filename to read a target description from, as set by "set
     tdesc filename ..."  */

  char *filename;
};

/* Get the inferior INF's target description info, allocating one on
   the stop if necessary.  */

static struct target_desc_info *
get_tdesc_info (struct inferior *inf)
{
  if (inf->tdesc_info == NULL)
    inf->tdesc_info = XCNEW (struct target_desc_info);
  return inf->tdesc_info;
}

/* A handle for architecture-specific data associated with the
   target description (see struct tdesc_arch_data).  */

static struct gdbarch_data *tdesc_data;

/* See target-descriptions.h.  */

int
target_desc_info_from_user_p (struct target_desc_info *info)
{
  return info != NULL && info->filename != NULL;
}

/* See target-descriptions.h.  */

void
copy_inferior_target_desc_info (struct inferior *destinf, struct inferior *srcinf)
{
  struct target_desc_info *src = get_tdesc_info (srcinf);
  struct target_desc_info *dest = get_tdesc_info (destinf);

  dest->fetched = src->fetched;
  dest->tdesc = src->tdesc;
  dest->filename = src->filename != NULL ? xstrdup (src->filename) : NULL;
}

/* See target-descriptions.h.  */

void
target_desc_info_free (struct target_desc_info *tdesc_info)
{
  if (tdesc_info != NULL)
    {
      xfree (tdesc_info->filename);
      xfree (tdesc_info);
    }
}

/* Convenience helper macros.  */

#define target_desc_fetched \
  get_tdesc_info (current_inferior ())->fetched
#define current_target_desc \
  get_tdesc_info (current_inferior ())->tdesc
#define target_description_filename \
  get_tdesc_info (current_inferior ())->filename

/* The string manipulated by the "set tdesc filename ..." command.  */

static char *tdesc_filename_cmd_string;

/* Fetch the current target's description, and switch the current
   architecture to one which incorporates that description.  */

void
target_find_description (void)
{
  /* If we've already fetched a description from the target, don't do
     it again.  This allows a target to fetch the description early,
     during its to_open or to_create_inferior, if it needs extra
     information about the target to initialize.  */
  if (target_desc_fetched)
    return;

  /* The current architecture should not have any target description
     specified.  It should have been cleared, e.g. when we
     disconnected from the previous target.  */
  gdb_assert (gdbarch_target_desc (target_gdbarch ()) == NULL);

  /* First try to fetch an XML description from the user-specified
     file.  */
  current_target_desc = NULL;
  if (target_description_filename != NULL
      && *target_description_filename != '\0')
    current_target_desc
      = file_read_description_xml (target_description_filename);

  /* Next try to read the description from the current target using
     target objects.  */
  if (current_target_desc == NULL)
    current_target_desc = target_read_description_xml (&current_target);

  /* If that failed try a target-specific hook.  */
  if (current_target_desc == NULL)
    current_target_desc = target_read_description (&current_target);

  /* If a non-NULL description was returned, then update the current
     architecture.  */
  if (current_target_desc)
    {
      struct gdbarch_info info;

      gdbarch_info_init (&info);
      info.target_desc = current_target_desc;
      if (!gdbarch_update_p (info))
	warning (_("Architecture rejected target-supplied description"));
      else
	{
	  struct tdesc_arch_data *data;

	  data = gdbarch_data (target_gdbarch (), tdesc_data);
	  if (tdesc_has_registers (current_target_desc)
	      && data->arch_regs == NULL)
	    warning (_("Target-supplied registers are not supported "
		       "by the current architecture"));
	}
    }

  /* Now that we know this description is usable, record that we
     fetched it.  */
  target_desc_fetched = 1;
}

/* Discard any description fetched from the current target, and switch
   the current architecture to one with no target description.  */

void
target_clear_description (void)
{
  struct gdbarch_info info;

  if (!target_desc_fetched)
    return;

  target_desc_fetched = 0;
  current_target_desc = NULL;

  gdbarch_info_init (&info);
  if (!gdbarch_update_p (info))
    internal_error (__FILE__, __LINE__,
		    _("Could not remove target-supplied description"));
}

/* Return the global current target description.  This should only be
   used by gdbarch initialization code; most access should be through
   an existing gdbarch.  */

const struct target_desc *
target_current_description (void)
{
  if (target_desc_fetched)
    return current_target_desc;

  return NULL;
}

/* Return non-zero if this target description is compatible
   with the given BFD architecture.  */

int
tdesc_compatible_p (const struct target_desc *target_desc,
		    const struct bfd_arch_info *arch)
{
  const struct bfd_arch_info *compat;
  int ix;

  for (ix = 0; VEC_iterate (arch_p, target_desc->compatible, ix, compat);
       ix++)
    {
      if (compat == arch
	  || arch->compatible (arch, compat)
	  || compat->compatible (compat, arch))
	return 1;
    }

  return 0;
}


/* Direct accessors for target descriptions.  */

/* Return the string value of a property named KEY, or NULL if the
   property was not specified.  */

const char *
tdesc_property (const struct target_desc *target_desc, const char *key)
{
  struct property *prop;
  int ix;

  for (ix = 0; VEC_iterate (property_s, target_desc->properties, ix, prop);
       ix++)
    if (strcmp (prop->key, key) == 0)
      return prop->value;

  return NULL;
}

/* Return the BFD architecture associated with this target
   description, or NULL if no architecture was specified.  */

const struct bfd_arch_info *
tdesc_architecture (const struct target_desc *target_desc)
{
  return target_desc->arch;
}

/* Return the OSABI associated with this target description, or
   GDB_OSABI_UNKNOWN if no osabi was specified.  */

enum gdb_osabi
tdesc_osabi (const struct target_desc *target_desc)
{
  return target_desc->osabi;
}



/* Return 1 if this target description includes any registers.  */

int
tdesc_has_registers (const struct target_desc *target_desc)
{
  int ix;
  struct tdesc_feature *feature;

  if (target_desc == NULL)
    return 0;

  for (ix = 0;
       VEC_iterate (tdesc_feature_p, target_desc->features, ix, feature);
       ix++)
    if (! VEC_empty (tdesc_reg_p, feature->registers))
      return 1;

  return 0;
}

/* Return the feature with the given name, if present, or NULL if
   the named feature is not found.  */

const struct tdesc_feature *
tdesc_find_feature (const struct target_desc *target_desc,
		    const char *name)
{
  int ix;
  struct tdesc_feature *feature;

  for (ix = 0;
       VEC_iterate (tdesc_feature_p, target_desc->features, ix, feature);
       ix++)
    if (strcmp (feature->name, name) == 0)
      return feature;

  return NULL;
}

/* Return the name of FEATURE.  */

const char *
tdesc_feature_name (const struct tdesc_feature *feature)
{
  return feature->name;
}

/* Predefined types.  */
static struct tdesc_type tdesc_predefined_types[] =
{
  { "int8", TDESC_TYPE_INT8 },
  { "int16", TDESC_TYPE_INT16 },
  { "int32", TDESC_TYPE_INT32 },
  { "int64", TDESC_TYPE_INT64 },
  { "int128", TDESC_TYPE_INT128 },
  { "uint8", TDESC_TYPE_UINT8 },
  { "uint16", TDESC_TYPE_UINT16 },
  { "uint32", TDESC_TYPE_UINT32 },
  { "uint64", TDESC_TYPE_UINT64 },
  { "uint128", TDESC_TYPE_UINT128 },
  { "code_ptr", TDESC_TYPE_CODE_PTR },
  { "data_ptr", TDESC_TYPE_DATA_PTR },
  { "ieee_single", TDESC_TYPE_IEEE_SINGLE },
  { "ieee_double", TDESC_TYPE_IEEE_DOUBLE },
  { "arm_fpa_ext", TDESC_TYPE_ARM_FPA_EXT },
  { "i387_ext", TDESC_TYPE_I387_EXT }
};

/* Return the type associated with ID in the context of FEATURE, or
   NULL if none.  */

struct tdesc_type *
tdesc_named_type (const struct tdesc_feature *feature, const char *id)
{
  int ix;
  struct tdesc_type *type;

  /* First try target-defined types.  */
  for (ix = 0; VEC_iterate (tdesc_type_p, feature->types, ix, type); ix++)
    if (strcmp (type->name, id) == 0)
      return type;

  /* Next try the predefined types.  */
  for (ix = 0; ix < ARRAY_SIZE (tdesc_predefined_types); ix++)
    if (strcmp (tdesc_predefined_types[ix].name, id) == 0)
      return &tdesc_predefined_types[ix];

  return NULL;
}

/* Lookup type associated with ID.  */

struct type *
tdesc_find_type (struct gdbarch *gdbarch, const char *id)
{
  struct tdesc_arch_reg *reg;
  struct tdesc_arch_data *data;
  int i, num_regs;

  data = gdbarch_data (gdbarch, tdesc_data);
  num_regs = VEC_length (tdesc_arch_reg, data->arch_regs);
  for (i = 0; i < num_regs; i++)
    {
      reg = VEC_index (tdesc_arch_reg, data->arch_regs, i);
      if (reg->reg
	  && reg->reg->tdesc_type
	  && reg->type
	  && strcmp (id, reg->reg->tdesc_type->name) == 0)
	return reg->type;
    }

  return NULL;
}

/* Construct, if necessary, and return the GDB type implementing target
   type TDESC_TYPE for architecture GDBARCH.  */

static struct type *
tdesc_gdb_type (struct gdbarch *gdbarch, struct tdesc_type *tdesc_type)
{
  struct type *type;

  switch (tdesc_type->kind)
    {
    /* Predefined types.  */
    case TDESC_TYPE_INT8:
      return builtin_type (gdbarch)->builtin_int8;

    case TDESC_TYPE_INT16:
      return builtin_type (gdbarch)->builtin_int16;

    case TDESC_TYPE_INT32:
      return builtin_type (gdbarch)->builtin_int32;

    case TDESC_TYPE_INT64:
      return builtin_type (gdbarch)->builtin_int64;

    case TDESC_TYPE_INT128:
      return builtin_type (gdbarch)->builtin_int128;

    case TDESC_TYPE_UINT8:
      return builtin_type (gdbarch)->builtin_uint8;

    case TDESC_TYPE_UINT16:
      return builtin_type (gdbarch)->builtin_uint16;

    case TDESC_TYPE_UINT32:
      return builtin_type (gdbarch)->builtin_uint32;

    case TDESC_TYPE_UINT64:
      return builtin_type (gdbarch)->builtin_uint64;

    case TDESC_TYPE_UINT128:
      return builtin_type (gdbarch)->builtin_uint128;

    case TDESC_TYPE_CODE_PTR:
      return builtin_type (gdbarch)->builtin_func_ptr;

    case TDESC_TYPE_DATA_PTR:
      return builtin_type (gdbarch)->builtin_data_ptr;

    default:
      break;
    }

  type = tdesc_find_type (gdbarch, tdesc_type->name);
  if (type)
    return type;

  switch (tdesc_type->kind)
    {
    case TDESC_TYPE_IEEE_SINGLE:
      return arch_float_type (gdbarch, -1, "builtin_type_ieee_single",
			      floatformats_ieee_single);

    case TDESC_TYPE_IEEE_DOUBLE:
      return arch_float_type (gdbarch, -1, "builtin_type_ieee_double",
			      floatformats_ieee_double);

    case TDESC_TYPE_ARM_FPA_EXT:
      return arch_float_type (gdbarch, -1, "builtin_type_arm_ext",
			      floatformats_arm_ext);

    case TDESC_TYPE_I387_EXT:
      return arch_float_type (gdbarch, -1, "builtin_type_i387_ext",
			      floatformats_i387_ext);

    /* Types defined by a target feature.  */
    case TDESC_TYPE_VECTOR:
      {
	struct type *type, *field_type;

	field_type = tdesc_gdb_type (gdbarch, tdesc_type->u.v.type);
	type = init_vector_type (field_type, tdesc_type->u.v.count);
	TYPE_NAME (type) = xstrdup (tdesc_type->name);

	return type;
      }

    case TDESC_TYPE_STRUCT:
      {
	struct type *type, *field_type;
	struct tdesc_type_field *f;
	int ix;

	type = arch_composite_type (gdbarch, NULL, TYPE_CODE_STRUCT);
	TYPE_NAME (type) = xstrdup (tdesc_type->name);
	TYPE_TAG_NAME (type) = TYPE_NAME (type);

	for (ix = 0;
	     VEC_iterate (tdesc_type_field, tdesc_type->u.u.fields, ix, f);
	     ix++)
	  {
	    if (f->type == NULL)
	      {
		/* Bitfield.  */
		struct field *fld;
		struct type *field_type;
		int bitsize, total_size;

		/* This invariant should be preserved while creating
		   types.  */
		gdb_assert (tdesc_type->u.u.size != 0);
		if (tdesc_type->u.u.size > 4)
		  field_type = builtin_type (gdbarch)->builtin_uint64;
		else
		  field_type = builtin_type (gdbarch)->builtin_uint32;

		fld = append_composite_type_field_raw (type, xstrdup (f->name),
						       field_type);

		/* For little-endian, BITPOS counts from the LSB of
		   the structure and marks the LSB of the field.  For
		   big-endian, BITPOS counts from the MSB of the
		   structure and marks the MSB of the field.  Either
		   way, it is the number of bits to the "left" of the
		   field.  To calculate this in big-endian, we need
		   the total size of the structure.  */
		bitsize = f->end - f->start + 1;
		total_size = tdesc_type->u.u.size * TARGET_CHAR_BIT;
		if (gdbarch_bits_big_endian (gdbarch))
		  SET_FIELD_BITPOS (fld[0], total_size - f->start - bitsize);
		else
		  SET_FIELD_BITPOS (fld[0], f->start);
		FIELD_BITSIZE (fld[0]) = bitsize;
	      }
	    else
	      {
		field_type = tdesc_gdb_type (gdbarch, f->type);
		append_composite_type_field (type, xstrdup (f->name),
					     field_type);
	      }
	  }

	if (tdesc_type->u.u.size != 0)
	  TYPE_LENGTH (type) = tdesc_type->u.u.size;
	return type;
      }

    case TDESC_TYPE_UNION:
      {
	struct type *type, *field_type;
	struct tdesc_type_field *f;
	int ix;

	type = arch_composite_type (gdbarch, NULL, TYPE_CODE_UNION);
	TYPE_NAME (type) = xstrdup (tdesc_type->name);

	for (ix = 0;
	     VEC_iterate (tdesc_type_field, tdesc_type->u.u.fields, ix, f);
	     ix++)
	  {
	    field_type = tdesc_gdb_type (gdbarch, f->type);
	    append_composite_type_field (type, xstrdup (f->name), field_type);

	    /* If any of the children of a union are vectors, flag the
	       union as a vector also.  This allows e.g. a union of two
	       vector types to show up automatically in "info vector".  */
	    if (TYPE_VECTOR (field_type))
	      TYPE_VECTOR (type) = 1;
	  }
	return type;
      }

    case TDESC_TYPE_FLAGS:
      {
	struct tdesc_type_flag *f;
	int ix;

	type = arch_flags_type (gdbarch, tdesc_type->name,
				tdesc_type->u.f.size);
	for (ix = 0;
	     VEC_iterate (tdesc_type_flag, tdesc_type->u.f.flags, ix, f);
	     ix++)
	  /* Note that contrary to the function name, this call will
	     just set the properties of an already-allocated
	     field.  */
	  append_flags_type_flag (type, f->start,
				  *f->name ? f->name : NULL);

	return type;
      }
    }

  internal_error (__FILE__, __LINE__,
		  "Type \"%s\" has an unknown kind %d",
		  tdesc_type->name, tdesc_type->kind);
}


/* Support for registers from target descriptions.  */

/* Construct the per-gdbarch data.  */

static void *
tdesc_data_init (struct obstack *obstack)
{
  struct tdesc_arch_data *data;

  data = OBSTACK_ZALLOC (obstack, struct tdesc_arch_data);
  return data;
}

/* Similar, but for the temporary copy used during architecture
   initialization.  */

struct tdesc_arch_data *
tdesc_data_alloc (void)
{
  return XZALLOC (struct tdesc_arch_data);
}

/* Free something allocated by tdesc_data_alloc, if it is not going
   to be used (for instance if it was unsuitable for the
   architecture).  */

void
tdesc_data_cleanup (void *data_untyped)
{
  struct tdesc_arch_data *data = data_untyped;

  VEC_free (tdesc_arch_reg, data->arch_regs);
  xfree (data);
}

/* Search FEATURE for a register named NAME.  */

static struct tdesc_reg *
tdesc_find_register_early (const struct tdesc_feature *feature,
			   const char *name)
{
  int ixr;
  struct tdesc_reg *reg;

  for (ixr = 0;
       VEC_iterate (tdesc_reg_p, feature->registers, ixr, reg);
       ixr++)
    if (strcasecmp (reg->name, name) == 0)
      return reg;

  return NULL;
}

/* Search FEATURE for a register named NAME.  Assign REGNO to it.  */

int
tdesc_numbered_register (const struct tdesc_feature *feature,
			 struct tdesc_arch_data *data,
			 int regno, const char *name)
{
  struct tdesc_arch_reg arch_reg = { 0 };
  struct tdesc_reg *reg = tdesc_find_register_early (feature, name);

  if (reg == NULL)
    return 0;

  /* Make sure the vector includes a REGNO'th element.  */
  while (regno >= VEC_length (tdesc_arch_reg, data->arch_regs))
    VEC_safe_push (tdesc_arch_reg, data->arch_regs, &arch_reg);

  arch_reg.reg = reg;
  VEC_replace (tdesc_arch_reg, data->arch_regs, regno, &arch_reg);
  return 1;
}

/* Search FEATURE for a register named NAME, but do not assign a fixed
   register number to it.  */

int
tdesc_unnumbered_register (const struct tdesc_feature *feature,
			   const char *name)
{
  struct tdesc_reg *reg = tdesc_find_register_early (feature, name);

  if (reg == NULL)
    return 0;

  return 1;
}

/* Search FEATURE for a register whose name is in NAMES and assign
   REGNO to it.  */

int
tdesc_numbered_register_choices (const struct tdesc_feature *feature,
				 struct tdesc_arch_data *data,
				 int regno, const char *const names[])
{
  int i;

  for (i = 0; names[i] != NULL; i++)
    if (tdesc_numbered_register (feature, data, regno, names[i]))
      return 1;

  return 0;
}

/* Search FEATURE for a register named NAME, and return its size in
   bits.  The register must exist.  */

int
tdesc_register_size (const struct tdesc_feature *feature,
		     const char *name)
{
  struct tdesc_reg *reg = tdesc_find_register_early (feature, name);

  gdb_assert (reg != NULL);
  return reg->bitsize;
}

/* Look up a register by its GDB internal register number.  */

static struct tdesc_arch_reg *
tdesc_find_arch_register (struct gdbarch *gdbarch, int regno)
{
  struct tdesc_arch_data *data;

  data = gdbarch_data (gdbarch, tdesc_data);
  if (regno < VEC_length (tdesc_arch_reg, data->arch_regs))
    return VEC_index (tdesc_arch_reg, data->arch_regs, regno);
  else
    return NULL;
}

static struct tdesc_reg *
tdesc_find_register (struct gdbarch *gdbarch, int regno)
{
  struct tdesc_arch_reg *reg = tdesc_find_arch_register (gdbarch, regno);

  return reg? reg->reg : NULL;
}

/* Return the name of register REGNO, from the target description or
   from an architecture-provided pseudo_register_name method.  */

const char *
tdesc_register_name (struct gdbarch *gdbarch, int regno)
{
  struct tdesc_reg *reg = tdesc_find_register (gdbarch, regno);
  int num_regs = gdbarch_num_regs (gdbarch);
  int num_pseudo_regs = gdbarch_num_pseudo_regs (gdbarch);

  if (reg != NULL)
    return reg->name;

  if (regno >= num_regs && regno < num_regs + num_pseudo_regs)
    {
      struct tdesc_arch_data *data = gdbarch_data (gdbarch, tdesc_data);

      gdb_assert (data->pseudo_register_name != NULL);
      return data->pseudo_register_name (gdbarch, regno);
    }

  return "";
}

struct type *
tdesc_register_type (struct gdbarch *gdbarch, int regno)
{
  struct tdesc_arch_reg *arch_reg = tdesc_find_arch_register (gdbarch, regno);
  struct tdesc_reg *reg = arch_reg? arch_reg->reg : NULL;
  int num_regs = gdbarch_num_regs (gdbarch);
  int num_pseudo_regs = gdbarch_num_pseudo_regs (gdbarch);

  if (reg == NULL && regno >= num_regs && regno < num_regs + num_pseudo_regs)
    {
      struct tdesc_arch_data *data = gdbarch_data (gdbarch, tdesc_data);

      gdb_assert (data->pseudo_register_type != NULL);
      return data->pseudo_register_type (gdbarch, regno);
    }

  if (reg == NULL)
    /* Return "int0_t", since "void" has a misleading size of one.  */
    return builtin_type (gdbarch)->builtin_int0;

  if (arch_reg->type == NULL)
    {
      /* First check for a predefined or target defined type.  */
      if (reg->tdesc_type)
        arch_reg->type = tdesc_gdb_type (gdbarch, reg->tdesc_type);

      /* Next try size-sensitive type shortcuts.  */
      else if (strcmp (reg->type, "float") == 0)
	{
	  if (reg->bitsize == gdbarch_float_bit (gdbarch))
	    arch_reg->type = builtin_type (gdbarch)->builtin_float;
	  else if (reg->bitsize == gdbarch_double_bit (gdbarch))
	    arch_reg->type = builtin_type (gdbarch)->builtin_double;
	  else if (reg->bitsize == gdbarch_long_double_bit (gdbarch))
	    arch_reg->type = builtin_type (gdbarch)->builtin_long_double;
	  else
	    {
	      warning (_("Register \"%s\" has an unsupported size (%d bits)"),
		       reg->name, reg->bitsize);
	      arch_reg->type = builtin_type (gdbarch)->builtin_double;
	    }
	}
      else if (strcmp (reg->type, "int") == 0)
	{
	  if (reg->bitsize == gdbarch_long_bit (gdbarch))
	    arch_reg->type = builtin_type (gdbarch)->builtin_long;
	  else if (reg->bitsize == TARGET_CHAR_BIT)
	    arch_reg->type = builtin_type (gdbarch)->builtin_char;
	  else if (reg->bitsize == gdbarch_short_bit (gdbarch))
	    arch_reg->type = builtin_type (gdbarch)->builtin_short;
	  else if (reg->bitsize == gdbarch_int_bit (gdbarch))
	    arch_reg->type = builtin_type (gdbarch)->builtin_int;
	  else if (reg->bitsize == gdbarch_long_long_bit (gdbarch))
	    arch_reg->type = builtin_type (gdbarch)->builtin_long_long;
	  else if (reg->bitsize == gdbarch_ptr_bit (gdbarch))
	  /* A bit desperate by this point...  */
	    arch_reg->type = builtin_type (gdbarch)->builtin_data_ptr;
	  else
	    {
	      warning (_("Register \"%s\" has an unsupported size (%d bits)"),
		       reg->name, reg->bitsize);
	      arch_reg->type = builtin_type (gdbarch)->builtin_long;
	    }
	}

      if (arch_reg->type == NULL)
	internal_error (__FILE__, __LINE__,
			"Register \"%s\" has an unknown type \"%s\"",
			reg->name, reg->type);
    }

  return arch_reg->type;
}

static int
tdesc_remote_register_number (struct gdbarch *gdbarch, int regno)
{
  struct tdesc_reg *reg = tdesc_find_register (gdbarch, regno);

  if (reg != NULL)
    return reg->target_regnum;
  else
    return -1;
}

/* Check whether REGNUM is a member of REGGROUP.  Registers from the
   target description may be classified as general, float, or vector.
   Unlike a gdbarch register_reggroup_p method, this function will
   return -1 if it does not know; the caller should handle registers
   with no specified group.

   Arbitrary strings (other than "general", "float", and "vector")
   from the description are not used; they cause the register to be
   displayed in "info all-registers" but excluded from "info
   registers" et al.  The names of containing features are also not
   used.  This might be extended to display registers in some more
   useful groupings.

   The save-restore flag is also implemented here.  */

int
tdesc_register_in_reggroup_p (struct gdbarch *gdbarch, int regno,
			      struct reggroup *reggroup)
{
  struct tdesc_reg *reg = tdesc_find_register (gdbarch, regno);

  if (reg != NULL && reg->group != NULL)
    {
      int general_p = 0, float_p = 0, vector_p = 0;

      if (strcmp (reg->group, "general") == 0)
	general_p = 1;
      else if (strcmp (reg->group, "float") == 0)
	float_p = 1;
      else if (strcmp (reg->group, "vector") == 0)
	vector_p = 1;

      if (reggroup == float_reggroup)
	return float_p;

      if (reggroup == vector_reggroup)
	return vector_p;

      if (reggroup == general_reggroup)
	return general_p;
    }

  if (reg != NULL
      && (reggroup == save_reggroup || reggroup == restore_reggroup))
    return reg->save_restore;

  return -1;
}

/* Check whether REGNUM is a member of REGGROUP.  Registers with no
   group specified go to the default reggroup function and are handled
   by type.  */

static int
tdesc_register_reggroup_p (struct gdbarch *gdbarch, int regno,
			   struct reggroup *reggroup)
{
  int num_regs = gdbarch_num_regs (gdbarch);
  int num_pseudo_regs = gdbarch_num_pseudo_regs (gdbarch);
  int ret;

  if (regno >= num_regs && regno < num_regs + num_pseudo_regs)
    {
      struct tdesc_arch_data *data = gdbarch_data (gdbarch, tdesc_data);

      if (data->pseudo_register_reggroup_p != NULL)
	return data->pseudo_register_reggroup_p (gdbarch, regno, reggroup);
      /* Otherwise fall through to the default reggroup_p.  */
    }

  ret = tdesc_register_in_reggroup_p (gdbarch, regno, reggroup);
  if (ret != -1)
    return ret;

  return default_register_reggroup_p (gdbarch, regno, reggroup);
}

/* Record architecture-specific functions to call for pseudo-register
   support.  */

void
set_tdesc_pseudo_register_name (struct gdbarch *gdbarch,
				gdbarch_register_name_ftype *pseudo_name)
{
  struct tdesc_arch_data *data = gdbarch_data (gdbarch, tdesc_data);

  data->pseudo_register_name = pseudo_name;
}

void
set_tdesc_pseudo_register_type (struct gdbarch *gdbarch,
				gdbarch_register_type_ftype *pseudo_type)
{
  struct tdesc_arch_data *data = gdbarch_data (gdbarch, tdesc_data);

  data->pseudo_register_type = pseudo_type;
}

void
set_tdesc_pseudo_register_reggroup_p
  (struct gdbarch *gdbarch,
   gdbarch_register_reggroup_p_ftype *pseudo_reggroup_p)
{
  struct tdesc_arch_data *data = gdbarch_data (gdbarch, tdesc_data);

  data->pseudo_register_reggroup_p = pseudo_reggroup_p;
}

/* Update GDBARCH to use the target description for registers.  */

void
tdesc_use_registers (struct gdbarch *gdbarch,
		     const struct target_desc *target_desc,
		     struct tdesc_arch_data *early_data)
{
  int num_regs = gdbarch_num_regs (gdbarch);
  int ixf, ixr;
  struct tdesc_feature *feature;
  struct tdesc_reg *reg;
  struct tdesc_arch_data *data;
  struct tdesc_arch_reg *arch_reg, new_arch_reg = { 0 };
  htab_t reg_hash;

  /* We can't use the description for registers if it doesn't describe
     any.  This function should only be called after validating
     registers, so the caller should know that registers are
     included.  */
  gdb_assert (tdesc_has_registers (target_desc));

  data = gdbarch_data (gdbarch, tdesc_data);
  data->arch_regs = early_data->arch_regs;
  xfree (early_data);

  /* Build up a set of all registers, so that we can assign register
     numbers where needed.  The hash table expands as necessary, so
     the initial size is arbitrary.  */
  reg_hash = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);
  for (ixf = 0;
       VEC_iterate (tdesc_feature_p, target_desc->features, ixf, feature);
       ixf++)
    for (ixr = 0;
	 VEC_iterate (tdesc_reg_p, feature->registers, ixr, reg);
	 ixr++)
      {
	void **slot = htab_find_slot (reg_hash, reg, INSERT);

	*slot = reg;
      }

  /* Remove any registers which were assigned numbers by the
     architecture.  */
  for (ixr = 0;
       VEC_iterate (tdesc_arch_reg, data->arch_regs, ixr, arch_reg);
       ixr++)
    if (arch_reg->reg)
      htab_remove_elt (reg_hash, arch_reg->reg);

  /* Assign numbers to the remaining registers and add them to the
     list of registers.  The new numbers are always above gdbarch_num_regs.
     Iterate over the features, not the hash table, so that the order
     matches that in the target description.  */

  gdb_assert (VEC_length (tdesc_arch_reg, data->arch_regs) <= num_regs);
  while (VEC_length (tdesc_arch_reg, data->arch_regs) < num_regs)
    VEC_safe_push (tdesc_arch_reg, data->arch_regs, &new_arch_reg);
  for (ixf = 0;
       VEC_iterate (tdesc_feature_p, target_desc->features, ixf, feature);
       ixf++)
    for (ixr = 0;
	 VEC_iterate (tdesc_reg_p, feature->registers, ixr, reg);
	 ixr++)
      if (htab_find (reg_hash, reg) != NULL)
	{
	  new_arch_reg.reg = reg;
	  VEC_safe_push (tdesc_arch_reg, data->arch_regs, &new_arch_reg);
	  num_regs++;
	}

  htab_delete (reg_hash);

  /* Update the architecture.  */
  set_gdbarch_num_regs (gdbarch, num_regs);
  set_gdbarch_register_name (gdbarch, tdesc_register_name);
  set_gdbarch_register_type (gdbarch, tdesc_register_type);
  set_gdbarch_remote_register_number (gdbarch,
				      tdesc_remote_register_number);
  set_gdbarch_register_reggroup_p (gdbarch, tdesc_register_reggroup_p);
}


/* Methods for constructing a target description.  */

static void
tdesc_free_reg (struct tdesc_reg *reg)
{
  xfree (reg->name);
  xfree (reg->type);
  xfree (reg->group);
  xfree (reg);
}

void
tdesc_create_reg (struct tdesc_feature *feature, const char *name,
		  int regnum, int save_restore, const char *group,
		  int bitsize, const char *type)
{
  struct tdesc_reg *reg = XZALLOC (struct tdesc_reg);

  reg->name = xstrdup (name);
  reg->target_regnum = regnum;
  reg->save_restore = save_restore;
  reg->group = group ? xstrdup (group) : NULL;
  reg->bitsize = bitsize;
  reg->type = type ? xstrdup (type) : xstrdup ("<unknown>");

  /* If the register's type is target-defined, look it up now.  We may not
     have easy access to the containing feature when we want it later.  */
  reg->tdesc_type = tdesc_named_type (feature, reg->type);

  VEC_safe_push (tdesc_reg_p, feature->registers, reg);
}

static void
tdesc_free_type (struct tdesc_type *type)
{
  switch (type->kind)
    {
    case TDESC_TYPE_STRUCT:
    case TDESC_TYPE_UNION:
      {
	struct tdesc_type_field *f;
	int ix;

	for (ix = 0;
	     VEC_iterate (tdesc_type_field, type->u.u.fields, ix, f);
	     ix++)
	  xfree (f->name);

	VEC_free (tdesc_type_field, type->u.u.fields);
      }
      break;

    case TDESC_TYPE_FLAGS:
      {
	struct tdesc_type_flag *f;
	int ix;

	for (ix = 0;
	     VEC_iterate (tdesc_type_flag, type->u.f.flags, ix, f);
	     ix++)
	  xfree (f->name);

	VEC_free (tdesc_type_flag, type->u.f.flags);
      }
      break;

    default:
      break;
    }

  xfree (type->name);
  xfree (type);
}

struct tdesc_type *
tdesc_create_vector (struct tdesc_feature *feature, const char *name,
		     struct tdesc_type *field_type, int count)
{
  struct tdesc_type *type = XZALLOC (struct tdesc_type);

  type->name = xstrdup (name);
  type->kind = TDESC_TYPE_VECTOR;
  type->u.v.type = field_type;
  type->u.v.count = count;

  VEC_safe_push (tdesc_type_p, feature->types, type);
  return type;
}

struct tdesc_type *
tdesc_create_struct (struct tdesc_feature *feature, const char *name)
{
  struct tdesc_type *type = XZALLOC (struct tdesc_type);

  type->name = xstrdup (name);
  type->kind = TDESC_TYPE_STRUCT;

  VEC_safe_push (tdesc_type_p, feature->types, type);
  return type;
}

/* Set the total length of TYPE.  Structs which contain bitfields may
   omit the reserved bits, so the end of the last field may not
   suffice.  */

void
tdesc_set_struct_size (struct tdesc_type *type, LONGEST size)
{
  gdb_assert (type->kind == TDESC_TYPE_STRUCT);
  type->u.u.size = size;
}

struct tdesc_type *
tdesc_create_union (struct tdesc_feature *feature, const char *name)
{
  struct tdesc_type *type = XZALLOC (struct tdesc_type);

  type->name = xstrdup (name);
  type->kind = TDESC_TYPE_UNION;

  VEC_safe_push (tdesc_type_p, feature->types, type);
  return type;
}

struct tdesc_type *
tdesc_create_flags (struct tdesc_feature *feature, const char *name,
		    LONGEST size)
{
  struct tdesc_type *type = XZALLOC (struct tdesc_type);

  type->name = xstrdup (name);
  type->kind = TDESC_TYPE_FLAGS;
  type->u.f.size = size;

  VEC_safe_push (tdesc_type_p, feature->types, type);
  return type;
}

/* Add a new field.  Return a temporary pointer to the field, which
   is only valid until the next call to tdesc_add_field (the vector
   might be reallocated).  */

void
tdesc_add_field (struct tdesc_type *type, const char *field_name,
		 struct tdesc_type *field_type)
{
  struct tdesc_type_field f = { 0 };

  gdb_assert (type->kind == TDESC_TYPE_UNION
	      || type->kind == TDESC_TYPE_STRUCT);

  f.name = xstrdup (field_name);
  f.type = field_type;

  VEC_safe_push (tdesc_type_field, type->u.u.fields, &f);
}

/* Add a new bitfield.  */

void
tdesc_add_bitfield (struct tdesc_type *type, const char *field_name,
		    int start, int end)
{
  struct tdesc_type_field f = { 0 };

  gdb_assert (type->kind == TDESC_TYPE_STRUCT);

  f.name = xstrdup (field_name);
  f.start = start;
  f.end = end;

  VEC_safe_push (tdesc_type_field, type->u.u.fields, &f);
}

void
tdesc_add_flag (struct tdesc_type *type, int start,
		const char *flag_name)
{
  struct tdesc_type_flag f = { 0 };

  gdb_assert (type->kind == TDESC_TYPE_FLAGS);

  f.name = xstrdup (flag_name);
  f.start = start;

  VEC_safe_push (tdesc_type_flag, type->u.f.flags, &f);
}

static void
tdesc_free_feature (struct tdesc_feature *feature)
{
  struct tdesc_reg *reg;
  struct tdesc_type *type;
  int ix;

  for (ix = 0; VEC_iterate (tdesc_reg_p, feature->registers, ix, reg); ix++)
    tdesc_free_reg (reg);
  VEC_free (tdesc_reg_p, feature->registers);

  for (ix = 0; VEC_iterate (tdesc_type_p, feature->types, ix, type); ix++)
    tdesc_free_type (type);
  VEC_free (tdesc_type_p, feature->types);

  xfree (feature->name);
  xfree (feature);
}

struct tdesc_feature *
tdesc_create_feature (struct target_desc *tdesc, const char *name)
{
  struct tdesc_feature *new_feature = XZALLOC (struct tdesc_feature);

  new_feature->name = xstrdup (name);

  VEC_safe_push (tdesc_feature_p, tdesc->features, new_feature);
  return new_feature;
}

struct target_desc *
allocate_target_description (void)
{
  return XZALLOC (struct target_desc);
}

static void
free_target_description (void *arg)
{
  struct target_desc *target_desc = arg;
  struct tdesc_feature *feature;
  struct property *prop;
  int ix;

  for (ix = 0;
       VEC_iterate (tdesc_feature_p, target_desc->features, ix, feature);
       ix++)
    tdesc_free_feature (feature);
  VEC_free (tdesc_feature_p, target_desc->features);

  for (ix = 0;
       VEC_iterate (property_s, target_desc->properties, ix, prop);
       ix++)
    {
      xfree (prop->key);
      xfree (prop->value);
    }
  VEC_free (property_s, target_desc->properties);

  VEC_free (arch_p, target_desc->compatible);

  xfree (target_desc);
}

struct cleanup *
make_cleanup_free_target_description (struct target_desc *target_desc)
{
  return make_cleanup (free_target_description, target_desc);
}

void
tdesc_add_compatible (struct target_desc *target_desc,
		      const struct bfd_arch_info *compatible)
{
  const struct bfd_arch_info *compat;
  int ix;

  /* If this instance of GDB is compiled without BFD support for the
     compatible architecture, simply ignore it -- we would not be able
     to handle it anyway.  */
  if (compatible == NULL)
    return;

  for (ix = 0; VEC_iterate (arch_p, target_desc->compatible, ix, compat);
       ix++)
    if (compat == compatible)
      internal_error (__FILE__, __LINE__,
		      _("Attempted to add duplicate "
			"compatible architecture \"%s\""),
		      compatible->printable_name);

  VEC_safe_push (arch_p, target_desc->compatible, compatible);
}

void
set_tdesc_property (struct target_desc *target_desc,
		    const char *key, const char *value)
{
  struct property *prop, new_prop;
  int ix;

  gdb_assert (key != NULL && value != NULL);

  for (ix = 0; VEC_iterate (property_s, target_desc->properties, ix, prop);
       ix++)
    if (strcmp (prop->key, key) == 0)
      internal_error (__FILE__, __LINE__,
		      _("Attempted to add duplicate property \"%s\""), key);

  new_prop.key = xstrdup (key);
  new_prop.value = xstrdup (value);
  VEC_safe_push (property_s, target_desc->properties, &new_prop);
}

void
set_tdesc_architecture (struct target_desc *target_desc,
			const struct bfd_arch_info *arch)
{
  target_desc->arch = arch;
}

void
set_tdesc_osabi (struct target_desc *target_desc, enum gdb_osabi osabi)
{
  target_desc->osabi = osabi;
}


static struct cmd_list_element *tdesc_set_cmdlist, *tdesc_show_cmdlist;
static struct cmd_list_element *tdesc_unset_cmdlist;

/* Helper functions for the CLI commands.  */

static void
set_tdesc_cmd (char *args, int from_tty)
{
  help_list (tdesc_set_cmdlist, "set tdesc ", -1, gdb_stdout);
}

static void
show_tdesc_cmd (char *args, int from_tty)
{
  cmd_show_list (tdesc_show_cmdlist, from_tty, "");
}

static void
unset_tdesc_cmd (char *args, int from_tty)
{
  help_list (tdesc_unset_cmdlist, "unset tdesc ", -1, gdb_stdout);
}

static void
set_tdesc_filename_cmd (char *args, int from_tty,
			struct cmd_list_element *c)
{
  xfree (target_description_filename);
  target_description_filename = xstrdup (tdesc_filename_cmd_string);

  target_clear_description ();
  target_find_description ();
}

static void
show_tdesc_filename_cmd (struct ui_file *file, int from_tty,
			 struct cmd_list_element *c,
			 const char *value)
{
  value = target_description_filename;

  if (value != NULL && *value != '\0')
    printf_filtered (_("The target description will be read from \"%s\".\n"),
		     value);
  else
    printf_filtered (_("The target description will be "
		       "read from the target.\n"));
}

static void
unset_tdesc_filename_cmd (char *args, int from_tty)
{
  xfree (target_description_filename);
  target_description_filename = NULL;
  target_clear_description ();
  target_find_description ();
}

static void
maint_print_c_tdesc_cmd (char *args, int from_tty)
{
  const struct target_desc *tdesc;
  const struct bfd_arch_info *compatible;
  const char *filename, *inp;
  char *function, *outp;
  struct property *prop;
  struct tdesc_feature *feature;
  struct tdesc_reg *reg;
  struct tdesc_type *type;
  struct tdesc_type_field *f;
  struct tdesc_type_flag *flag;
  int ix, ix2, ix3;
  int printed_field_type = 0;

  /* Use the global target-supplied description, not the current
     architecture's.  This lets a GDB for one architecture generate C
     for another architecture's description, even though the gdbarch
     initialization code will reject the new description.  */
  tdesc = current_target_desc;
  if (tdesc == NULL)
    error (_("There is no target description to print."));

  if (target_description_filename == NULL)
    error (_("The current target description did not come from an XML file."));

  filename = lbasename (target_description_filename);
  function = alloca (strlen (filename) + 1);
  for (inp = filename, outp = function; *inp != '\0'; inp++)
    if (*inp == '.')
      break;
    else if (*inp == '-')
      *outp++ = '_';
    else
      *outp++ = *inp;
  *outp = '\0';

  /* Standard boilerplate.  */
  printf_unfiltered ("/* THIS FILE IS GENERATED.  "
		     "-*- buffer-read-only: t -*- vi"
		     ":set ro:\n");
  printf_unfiltered ("  Original: %s */\n\n", filename);
  printf_unfiltered ("#include \"defs.h\"\n");
  printf_unfiltered ("#include \"osabi.h\"\n");
  printf_unfiltered ("#include \"target-descriptions.h\"\n");
  printf_unfiltered ("\n");

  printf_unfiltered ("struct target_desc *tdesc_%s;\n", function);
  printf_unfiltered ("static void\n");
  printf_unfiltered ("initialize_tdesc_%s (void)\n", function);
  printf_unfiltered ("{\n");
  printf_unfiltered
    ("  struct target_desc *result = allocate_target_description ();\n");
  printf_unfiltered ("  struct tdesc_feature *feature;\n");

  /* Now we do some "filtering" in order to know which variables to
     declare.  This is needed because otherwise we would declare unused
     variables `field_type' and `type'.  */
  for (ix = 0;
       VEC_iterate (tdesc_feature_p, tdesc->features, ix, feature);
       ix++)
    {
      int printed_desc_type = 0;

      for (ix2 = 0;
	   VEC_iterate (tdesc_type_p, feature->types, ix2, type);
	   ix2++)
	{
	  if (!printed_field_type)
	    {
	      printf_unfiltered ("  struct tdesc_type *field_type;\n");
	      printed_field_type = 1;
	    }

	  if ((type->kind == TDESC_TYPE_UNION
	      || type->kind == TDESC_TYPE_STRUCT)
	      && VEC_length (tdesc_type_field, type->u.u.fields) > 0)
	    {
	      printf_unfiltered ("  struct tdesc_type *type;\n");
	      printed_desc_type = 1;
	      break;
	    }
	}

      if (printed_desc_type)
	break;
    }

  printf_unfiltered ("\n");

  if (tdesc_architecture (tdesc) != NULL)
    {
      printf_unfiltered
	("  set_tdesc_architecture (result, bfd_scan_arch (\"%s\"));\n",
	 tdesc_architecture (tdesc)->printable_name);
      printf_unfiltered ("\n");
    }

  if (tdesc_osabi (tdesc) > GDB_OSABI_UNKNOWN
      && tdesc_osabi (tdesc) < GDB_OSABI_INVALID)
    {
      printf_unfiltered
	("  set_tdesc_osabi (result, osabi_from_tdesc_string (\"%s\"));\n",
	 gdbarch_osabi_name (tdesc_osabi (tdesc)));
      printf_unfiltered ("\n");
    }

  for (ix = 0; VEC_iterate (arch_p, tdesc->compatible, ix, compatible);
       ix++)
    {
      printf_unfiltered
	("  tdesc_add_compatible (result, bfd_scan_arch (\"%s\"));\n",
	 compatible->printable_name);
    }
  if (ix)
    printf_unfiltered ("\n");

  for (ix = 0; VEC_iterate (property_s, tdesc->properties, ix, prop);
       ix++)
    {
      printf_unfiltered ("  set_tdesc_property (result, \"%s\", \"%s\");\n",
	      prop->key, prop->value);
    }

  for (ix = 0;
       VEC_iterate (tdesc_feature_p, tdesc->features, ix, feature);
       ix++)
    {
      printf_unfiltered ("  \
feature = tdesc_create_feature (result, \"%s\");\n",
			 feature->name);

      for (ix2 = 0;
	   VEC_iterate (tdesc_type_p, feature->types, ix2, type);
	   ix2++)
	{
	  switch (type->kind)
	    {
	    case TDESC_TYPE_VECTOR:
	      printf_unfiltered
		("  field_type = tdesc_named_type (feature, \"%s\");\n",
		 type->u.v.type->name);
	      printf_unfiltered
		("  tdesc_create_vector (feature, \"%s\", field_type, %d);\n",
		 type->name, type->u.v.count);
	      break;
	    case TDESC_TYPE_STRUCT:
	      printf_unfiltered
		("  type = tdesc_create_struct (feature, \"%s\");\n",
		 type->name);
	      if (type->u.u.size != 0)
		printf_unfiltered
		  ("  tdesc_set_struct_size (type, %s);\n",
		   plongest (type->u.u.size));
	      for (ix3 = 0;
		   VEC_iterate (tdesc_type_field, type->u.u.fields, ix3, f);
		   ix3++)
		{
		  /* Going first for implicitly sized types, else part handles
		     bitfields.  As reported on xml-tdesc.c implicitly sized types
		     cannot contain a bitfield.  */
		  if (f->start == 0 && f->end == 0)
		    {
		      printf_unfiltered
			("  field_type = tdesc_named_type (feature, \"%s\");\n",
			 f->type->name);
		      printf_unfiltered
			("  tdesc_add_field (type, \"%s\", field_type);\n",
			 f->name);
		    }
		  else
		    printf_unfiltered
		      ("  tdesc_add_bitfield (type, \"%s\", %d, %d);\n",
		       f->name, f->start, f->end);
		}
	      break;
	    case TDESC_TYPE_UNION:
	      printf_unfiltered
		("  type = tdesc_create_union (feature, \"%s\");\n",
		 type->name);
	      for (ix3 = 0;
		   VEC_iterate (tdesc_type_field, type->u.u.fields, ix3, f);
		   ix3++)
		{
		  printf_unfiltered
		    ("  field_type = tdesc_named_type (feature, \"%s\");\n",
		     f->type->name);
		  printf_unfiltered
		    ("  tdesc_add_field (type, \"%s\", field_type);\n",
		     f->name);
		}
	      break;
	    case TDESC_TYPE_FLAGS:
	      printf_unfiltered
		("  field_type = tdesc_create_flags (feature, \"%s\", %d);\n",
		 type->name, (int) type->u.f.size);
	      for (ix3 = 0;
		   VEC_iterate (tdesc_type_flag, type->u.f.flags, ix3,
				flag);
		   ix3++)
		printf_unfiltered
		  ("  tdesc_add_flag (field_type, %d, \"%s\");\n",
		   flag->start, flag->name);
	      break;
	    default:
	      error (_("C output is not supported type \"%s\"."), type->name);
	    }
	  printf_unfiltered ("\n");
	}

      for (ix2 = 0;
	   VEC_iterate (tdesc_reg_p, feature->registers, ix2, reg);
	   ix2++)
	{
	  printf_unfiltered ("  tdesc_create_reg (feature, \"%s\", %ld, %d, ",
			     reg->name, reg->target_regnum, reg->save_restore);
	  if (reg->group)
	    printf_unfiltered ("\"%s\", ", reg->group);
	  else
	    printf_unfiltered ("NULL, ");
	  printf_unfiltered ("%d, \"%s\");\n", reg->bitsize, reg->type);
	}

      printf_unfiltered ("\n");
    }

  printf_unfiltered ("  tdesc_%s = result;\n", function);
  printf_unfiltered ("}\n");
}

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_target_descriptions;

void
_initialize_target_descriptions (void)
{
  tdesc_data = gdbarch_data_register_pre_init (tdesc_data_init);

  add_prefix_cmd ("tdesc", class_maintenance, set_tdesc_cmd, _("\
Set target description specific variables."),
		  &tdesc_set_cmdlist, "set tdesc ",
		  0 /* allow-unknown */, &setlist);
  add_prefix_cmd ("tdesc", class_maintenance, show_tdesc_cmd, _("\
Show target description specific variables."),
		  &tdesc_show_cmdlist, "show tdesc ",
		  0 /* allow-unknown */, &showlist);
  add_prefix_cmd ("tdesc", class_maintenance, unset_tdesc_cmd, _("\
Unset target description specific variables."),
		  &tdesc_unset_cmdlist, "unset tdesc ",
		  0 /* allow-unknown */, &unsetlist);

  add_setshow_filename_cmd ("filename", class_obscure,
			    &tdesc_filename_cmd_string,
			    _("\
Set the file to read for an XML target description"), _("\
Show the file to read for an XML target description"), _("\
When set, GDB will read the target description from a local\n\
file instead of querying the remote target."),
			    set_tdesc_filename_cmd,
			    show_tdesc_filename_cmd,
			    &tdesc_set_cmdlist, &tdesc_show_cmdlist);

  add_cmd ("filename", class_obscure, unset_tdesc_filename_cmd, _("\
Unset the file to read for an XML target description.  When unset,\n\
GDB will read the description from the target."),
	   &tdesc_unset_cmdlist);

  add_cmd ("c-tdesc", class_maintenance, maint_print_c_tdesc_cmd, _("\
Print the current target description as a C source file."),
	   &maintenanceprintlist);
}
@


1.46
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1678 2
a1679 1
	  if (type->kind == TDESC_TYPE_UNION
d1750 30
@


1.45
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3 1
a3 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.44
log
@gdb/
2012-11-09  Pedro Alves  <palves@@redhat.com>

	* gdbarch.sh (target_gdbarch) <gdbarch.h>: Reimplement as macro.
	(get_target_gdbarch) <gdbarch.h>: New function.
	(startup_gdbarch) <gdbarch.h>: Declare.
	<gdbarch.c> (target_gdbarch): Delete.
	<gdbarch.c> (deprecated_target_gdbarch_select_hack): Set the
	current inferior's gdbarch.
	<gdbarch.c> (get_target_gdbarch): New function.
	* inferior.c: Include target-descriptions.h.
	(free_inferior): Free target description info.
	(add_inferior_with_spaces): Set the inferior's initial
	architecture.
	(clone_inferior_command): Copy the original inferior's target
	description if it was user specified.
	(initialize_inferiors): Add comment.
	* inferior.h (struct target_desc_info): Forward declare.
	(struct inferior) <gdbarch>: New field.
	* linux-nat.c: Include target-descriptions.h.
	(linux_child_follow_fork): Copy the parent's architecture and
	target description to the child.
	* target-descriptions.c: Include inferior.h.
	(struct target_desc_info): New structure, holding the equivalents
	of ...
	(target_desc_fetched, current_target_desc)
	(target_description_filename): ... these removed globals.
	(get_tdesc_info, target_desc_info_from_user_p)
	(copy_inferior_target_desc_info, target_desc_info_free): New.
	(target_desc_fetched, current_target_desc)
	(target_description_filename): Reimplemented as convenience
	macros.
	(tdesc_filename_cmd_string): New global.
	(set_tdesc_filename_cmd): Copy the string manipulated by the "set
	tdescs filename ..." commands to the per-inferior equivalent.
	(show_tdesc_filename_cmd): Get the value to show from the
	per-inferior description filename.
	(_initilize_target_descriptions): Change the "set/show tdesc
	filename" commands' variable.
	* target-descriptions.h (struct target_desc, struct target_desc_info)
	(struct inferior): Forward declare.
	(target_find_description, target_clear_description)
	(target_current_description): Adjust comments.
	(copy_inferior_target_desc_info, target_desc_info_free)
	(target_desc_info_from_user_p). Declare.

gdb/testsuite/
2012-11-09  Pedro Alves  <palves@@redhat.com>

	* gdb.multi/multi-arch.exp: New.
@
text
@d337 1
a337 1
  gdb_assert (gdbarch_target_desc (target_gdbarch) == NULL);
d370 1
a370 1
	  data = gdbarch_data (target_gdbarch, tdesc_data);
@


1.43
log
@gdb/
	* copying.awk: Print buffer-read-only and vi ro markers.
	* copying.c: Rebuild.
	* gdbarch.sh (copyright): Print buffer-read-only and vi ro markers.
	* gdbarch.c, gdbarch.h: Rebuild.
	* target-descriptions.c (maint_print_c_tdesc_cmd): Print
	buffer-read-only and vi ro markers.
	* features/arm-with-iwmmxt.c: Rebuild.
	* features/arm-with-m-fpa-layout.c: Rebuild.
	* features/arm-with-m-vfp-d16.c: Rebuild.
	* features/arm-with-m.c: Rebuild.
	* features/arm-with-neon.c: Rebuild.
	* features/arm-with-vfpv2.c: Rebuild.
	* features/arm-with-vfpv3.c: Rebuild.
	* features/i386/amd64-avx-linux.c: Rebuild.
	* features/i386/amd64-avx.c: Rebuild.
	* features/i386/amd64-linux.c: Rebuild.
	* features/i386/amd64.c: Rebuild.
	* features/i386/i386-avx-linux.c: Rebuild.
	* features/i386/i386-avx.c: Rebuild.
	* features/i386/i386-linux.c: Rebuild.
	* features/i386/i386-mmx-linux.c: Rebuild.
	* features/i386/i386-mmx.c: Rebuild.
	* features/i386/i386.c: Rebuild.
	* features/i386/x32-avx-linux.c: Rebuild.
	* features/i386/x32-avx.c: Rebuild.
	* features/i386/x32-linux.c: Rebuild.
	* features/i386/x32.c: Rebuild.
	* features/mips-dsp-linux.c: Rebuild.
	* features/mips-linux.c: Rebuild.
	* features/mips64-dsp-linux.c: Rebuild.
	* features/mips64-linux.c: Rebuild.
	* features/rs6000/powerpc-32.c: Rebuild.
	* features/rs6000/powerpc-32l.c: Rebuild.
	* features/rs6000/powerpc-403.c: Rebuild.
	* features/rs6000/powerpc-403gc.c: Rebuild.
	* features/rs6000/powerpc-405.c: Rebuild.
	* features/rs6000/powerpc-505.c: Rebuild.
	* features/rs6000/powerpc-601.c: Rebuild.
	* features/rs6000/powerpc-602.c: Rebuild.
	* features/rs6000/powerpc-603.c: Rebuild.
	* features/rs6000/powerpc-604.c: Rebuild.
	* features/rs6000/powerpc-64.c: Rebuild.
	* features/rs6000/powerpc-64l.c: Rebuild.
	* features/rs6000/powerpc-7400.c: Rebuild.
	* features/rs6000/powerpc-750.c: Rebuild.
	* features/rs6000/powerpc-860.c: Rebuild.
	* features/rs6000/powerpc-altivec32.c: Rebuild.
	* features/rs6000/powerpc-altivec32l.c: Rebuild.
	* features/rs6000/powerpc-altivec64.c: Rebuild.
	* features/rs6000/powerpc-altivec64l.c: Rebuild.
	* features/rs6000/powerpc-cell32l.c: Rebuild.
	* features/rs6000/powerpc-cell64l.c: Rebuild.
	* features/rs6000/powerpc-e500.c: Rebuild.
	* features/rs6000/powerpc-e500l.c: Rebuild.
	* features/rs6000/powerpc-isa205-32l.c: Rebuild.
	* features/rs6000/powerpc-isa205-64l.c: Rebuild.
	* features/rs6000/powerpc-isa205-altivec32l.c: Rebuild.
	* features/rs6000/powerpc-isa205-altivec64l.c: Rebuild.
	* features/rs6000/powerpc-isa205-vsx32l.c: Rebuild.
	* features/rs6000/powerpc-isa205-vsx64l.c: Rebuild.
	* features/rs6000/powerpc-vsx32.c: Rebuild.
	* features/rs6000/powerpc-vsx32l.c: Rebuild.
	* features/rs6000/powerpc-vsx64.c: Rebuild.
	* features/rs6000/powerpc-vsx64l.c: Rebuild.
	* features/rs6000/rs6000.c: Rebuild.
	* features/s390-linux32.c: Rebuild.
	* features/s390-linux32v1.c: Rebuild.
	* features/s390-linux32v2.c: Rebuild.
	* features/s390-linux64.c: Rebuild.
	* features/s390-linux64v1.c: Rebuild.
	* features/s390-linux64v2.c: Rebuild.
	* features/s390x-linux64.c: Rebuild.
	* features/s390x-linux64v1.c: Rebuild.
	* features/s390x-linux64v2.c: Rebuild.
	* features/tic6x-c62x-linux.c: Rebuild.
	* features/tic6x-c62x.c: Rebuild.
	* features/tic6x-c64x-linux.c: Rebuild.
	* features/tic6x-c64x.c: Rebuild.
	* features/tic6x-c64xp-linux.c: Rebuild.
	* features/tic6x-c64xp.c: Rebuild.
@
text
@d37 1
d235 2
a236 3
/* Global state.  These variables are associated with the current
   target; if GDB adds support for multiple simultaneous targets, then
   these variables should become target-specific data.  */
d238 6
a243 2
/* A flag indicating that a description has already been fetched from
   the current target, so it should not be queried again.  */
d245 5
a249 1
static int target_desc_fetched;
d251 1
a251 5
/* The description fetched from the current target, or NULL if the
   current target did not supply any description.  Only valid when
   target_desc_fetched is set.  Only the description initialization
   code should access this; normally, the description should be
   accessed through the gdbarch object.  */
d253 2
a254 1
static const struct target_desc *current_target_desc;
d256 2
a257 1
/* Other global variables.  */
d259 2
a260 1
/* The filename to read a target description from.  */
d262 7
a268 1
static char *target_description_filename;
d275 46
d1572 3
d1584 2
d1825 1
a1825 1
			    &target_description_filename,
@


1.42
log
@2012-04-25  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* features/arm-with-iwmmxt.c: Regenerate.
	* features/arm-with-m-fpa-layout.c: Likewise.
	* features/arm-with-m.c: Likewise.
	* features/arm-with-neon.c: Likewise.
	* features/arm-with-vfpv2.c: Likewise.
	* features/arm-with-vfpv3.c: Likewise.
	* features/mips-dsp-linux.c: Likewise.
	* features/mips-linux.c: Likewise.
	* features/mips64-dsp-linux.c: Likewise.
	* features/mips64-linux.c: Likewise.
	* features/s390-linux32.c: Likewise.
	* features/s390-linux32v1.c: Likewise.
	* features/s390-linux32v2.c: Likewise.
	* features/s390-linux64.c: Likewise.
	* features/s390-linux64v1.c: Likewise.
	* features/s390-linux64v2.c: Likewise.
	* features/s390x-linux64.c: Likewise.
	* features/s390x-linux64v1.c: Likewise.
	* features/s390x-linux64v2.c: Likewise.
	* features/tic6x-c62x-linux.c: Likewise.
	* features/tic6x-c62x.c: Likewise.
	* features/tic6x-c64x-linux.c: Likewise.
	* features/tic6x-c64x.c: Likewise.
	* features/tic6x-c64xp-linux.c: Likewise.
	* features/tic6x-c64xp.c: Likewise.
	* target-descriptions.c: Only generate `field_type' and `type'
	variables when needed.
@
text
@d1578 4
a1581 2
  printf_unfiltered ("/* THIS FILE IS GENERATED.  Original: %s */\n\n",
		     filename);
@


1.41
log
@2012-04-17  Pedro Alves  <palves@@redhat.com>

	* gdbtypes.h (FIELD_BITPOS): Rename to ...
	(FIELD_BITPOS_LVAL): ... this.
	(FIELD_BITPOS): New.
	(SET_FIELD_BITPOS): Adjust to use FIELD_BITPOS_LVAL.
	* dwarf2read.c (dwarf2_add_field): Use SET_FIELD_BITPOS.
	* gdbtypes.c (append_composite_type_field_aligned): Adjust to use
	SET_FIELD_BITPOS.
	* gnu-v3-abi.c (build_gdb_vtable_type): Adjust to use
	SET_FIELD_BITPOS.
	* stabsread.c (read_cpp_abbrev, read_one_struct_field)
	(read_baseclasses): Adjust to use SET_FIELD_BITPOS.
	* target-descriptions.c (tdesc_gdb_type): Adjust to use
	SET_FIELD_BITPOS.
@
text
@d1553 1
d1592 33
a1624 1
  printf_unfiltered ("  struct tdesc_type *field_type, *type;\n");
@


1.40
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d660 1
a660 1
		  FIELD_BITPOS (fld[0]) = total_size - f->start - bitsize;
d662 1
a662 1
		  FIELD_BITPOS (fld[0]) = f->start;
@


1.39
log
@2011-03-02  Michael Snyder  <msnyder@@vmware.com>

	* target-descriptions.c (tdesc_gdb_type): No need to call
	xstrdup, callee saves a copy.
@
text
@d3 1
a3 2
   Copyright (C) 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.39.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2006-2012 Free Software Foundation, Inc.
@


1.38
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d709 1
a709 1
	type = arch_flags_type (gdbarch, xstrdup (tdesc_type->name),
@


1.37
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d951 1
a951 1
	  /* A bit desperate by this point... */
@


1.36
log
@run copyright.sh for 2011.
@
text
@d1524 1
a1524 2
    printf_filtered (_("\
The target description will be read from \"%s\".\n"),
d1527 2
a1528 2
    printf_filtered (_("\
The target description will be read from the target.\n"));
d1633 2
a1634 1
      printf_unfiltered ("  feature = tdesc_create_feature (result, \"%s\");\n",
@


1.35
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* target.c: White space.
	* target-descriptions.c: White space.
	* target-memory.c: White space.
	* thread.c: White space.
	* top.c: White space.
	* tracepoint.c: White space.
	* trad-frame.c: White space.
	* tramp-frame.c: White space.
	* ui-file.c: White space.
	* ui-out.c: White space.
	* user-regs.c: White space.
	* utils.c: White space.
@
text
@d3 2
a4 1
   Copyright (C) 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.34
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* xml-support.c (xinclude_start_include): Delete unused variable.
	(xml_process_xincludes): Delete unused variable.
	* xml-syscall.c (syscall_parse_xml): Delete unused variable.
	* target-descriptions.c (tdesc_gdb_type): Delete unused variable.
	(tdesc_find_arch_register): Delete unused variable.
	(tdesc_use_registers): Delete unused variable.
	* xml-tdesc.c (tdesc_start_target): Delete unused variable.
	* inferior.c (print_inferior): Delete unused variable.
	* record.c (record_open_1): Delete unused variable.
	(record_restore): Delete unused variable.
	(cmd_record_save): Delete unused variable.
	* gcore.c (derive_heap_segment): Delete unused variable.
	(objfile_find_memory_regions): Use unused variable.
	* jit.c (jit_inferior_init): Delete unused variable.
	* progspace.c (clone_program_space): Delete unused variable.
	(pspace_empty_p): Delete unused variable.
@
text
@d867 1
d887 1
d906 1
d1044 1
a1204 1

@


1.33
log
@Remove TDESC_TYPE_I386_EFLAGS and TDESC_TYPE_I386_MXCSR.

2010-03-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* target-descriptions.c (tdesc_type): Remove
	TDESC_TYPE_I386_EFLAGS and TDESC_TYPE_I386_MXCSR.
	(tdesc_predefined_types): Likewise.
	(tdesc_gdb_type): Likewise.  Pass NULL to append_flags_type_flag
	if flag name is empty.
	(maint_print_c_tdesc_cmd): Handle TDESC_TYPE_FLAGS.

	* features/i386/32bit-core.xml: Define i386_eflags.
	* features/i386/64bit-core.xml: Likewise.

	* features/i386/32bit-sse.xml: Define i386_mxcsr.
	* features/i386/64bit-sse.xml: Likewise.

	* features/i386/amd64-linux.c: Regenerated.
	* features/i386/amd64.c: Likewise.
	* features/i386/i386-linux.c: Likewise.
	* features/i386/i386.c: Likewise.
@
text
@a704 1
	struct type *type, *field_type;
a853 1
  struct tdesc_arch_reg *reg;
d1092 1
a1092 1
  int i, ixf, ixr;
@


1.32
log
@	* gdbtypes.c (append_composite_type_field_raw): New.
	(append_composite_type_field_aligned): Use the new function.
	* gdbtypes.h (append_composite_type_field_raw): Declare.
	* target-descriptions.c (struct tdesc_type_field): Add start and end.
	(struct tdesc_type_flag): New type.
	(struct tdesc_type): Add TDESC_TYPE_STRUCT and TDESC_TYPE_FLAGS to
	kind.  Add size to u.u.  Add u.f for flags.
	(tdesc_gdb_type): Handle TDESC_TYPE_STRUCT and TDESC_TYPE_FLAGS.
	(tdesc_free_type): Likewise.
	(tdesc_create_struct, tdesc_set_struct_size, tdesc_create_flags): New.
	(tdesc_add_field): Handle TDESC_TYPE_STRUCT.
	(tdesc_add_bitfield, tdesc_add_flag): New.
	* target-descriptions.h (tdesc_create_struct, tdesc_set_struct_size)
	(tdesc_create_flags, tdesc_add_bitfield, tdesc_add_flag): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Rename current_union to
	current_type.  Add current_type_size and current_type_is_flags.
	(tdesc_start_union): Clear the new fields.
	(tdesc_start_struct, tdesc_start_flags): New.
	(tdesc_start_field): Handle struct fields, including bitfields.
	(field_attributes): Make type optional.  Add start and end.
	(union_children): Rename to struct_union_children.
	(union_attributes): Rename to struct_union_attributes.  Add optional
	size.
	(flags_attributes): New.
	(feature_children): Add struct and flags.
	* features/gdb-target.dtd: Add flags and struct to features.
	Make field type optional.  Add field start and end.

	doc/
	* gdb.texinfo (Types): Describe <struct> and <flags>.

	testsuite/
	* gdb.xml/extra-regs.xml: Add struct1, struct2, and flags
	types.  Add structreg, bitfields, and flags registers.
	* gdb.xml/tdesc-regs.exp: Test structreg and bitfields
	registers.
@
text
@a128 2
    TDESC_TYPE_I386_EFLAGS,
    TDESC_TYPE_I386_MXCSR,
d484 1
a484 3
  { "i387_ext", TDESC_TYPE_I387_EXT },
  { "i386_eflags", TDESC_TYPE_I386_EFLAGS },
  { "i386_mxcsr", TDESC_TYPE_I386_MXCSR }
a605 51
    case TDESC_TYPE_I386_EFLAGS:
      {
	struct type *type;

	type = arch_flags_type (gdbarch, "builtin_type_i386_eflags", 4);
	append_flags_type_flag (type, 0, "CF");
	append_flags_type_flag (type, 1, NULL);
	append_flags_type_flag (type, 2, "PF");
	append_flags_type_flag (type, 4, "AF");
	append_flags_type_flag (type, 6, "ZF");
	append_flags_type_flag (type, 7, "SF");
	append_flags_type_flag (type, 8, "TF");
	append_flags_type_flag (type, 9, "IF");
	append_flags_type_flag (type, 10, "DF");
	append_flags_type_flag (type, 11, "OF");
	append_flags_type_flag (type, 14, "NT");
	append_flags_type_flag (type, 16, "RF");
	append_flags_type_flag (type, 17, "VM");
	append_flags_type_flag (type, 18, "AC");
	append_flags_type_flag (type, 19, "VIF");
	append_flags_type_flag (type, 20, "VIP");
	append_flags_type_flag (type, 21, "ID");

	return type;
      }
    break;

    case TDESC_TYPE_I386_MXCSR:
      {
	struct type *type;

	type = arch_flags_type (gdbarch, "builtin_type_i386_mxcsr", 4);
	append_flags_type_flag (type, 0, "IE");
	append_flags_type_flag (type, 1, "DE");
	append_flags_type_flag (type, 2, "ZE");
	append_flags_type_flag (type, 3, "OE");
	append_flags_type_flag (type, 4, "UE");
	append_flags_type_flag (type, 5, "PE");
	append_flags_type_flag (type, 6, "DAZ");
	append_flags_type_flag (type, 7, "IM");
	append_flags_type_flag (type, 8, "DM");
	append_flags_type_flag (type, 9, "ZM");
	append_flags_type_flag (type, 10, "OM");
	append_flags_type_flag (type, 11, "UM");
	append_flags_type_flag (type, 12, "PM");
	append_flags_type_flag (type, 15, "FZ");

	return type;
      }
    break;

d717 2
a718 1
	  append_flags_type_flag (type, f->start, f->name);
d1551 1
d1665 12
@


1.31
log
@Add i387_ext, i386_eflags and i386_mxcsr.

2010-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* target-descriptions.c (tdesc_type): Add TDESC_TYPE_I387_EXT,
	TDESC_TYPE_I386_EFLAGS and TDESC_TYPE_I386_MXCSR.
	(tdesc_predefined_types): Add i387_ext, i386_eflags and
	i386_mxcsr.
	(tdesc_find_type): New.
	(tdesc_gdb_type): Use tdesc_find_type.  Handle TDESC_TYPE_I387_EXT,
	TDESC_TYPE_I386_EFLAGS and TDESC_TYPE_I386_MXCSR.

	* target-descriptions.h (tdesc_find_type): New.
@
text
@d93 1
d97 7
d134 3
a136 1
    TDESC_TYPE_UNION
d149 1
a149 1
    /* Union type.  */
d153 1
d155 7
d673 60
d749 1
a749 1
	    /* If any of the children of this union are vectors, flag the
d755 18
d1260 1
d1275 14
d1313 23
d1347 18
d1371 2
a1372 1
  gdb_assert (type->kind == TDESC_TYPE_UNION);
d1380 31
@


1.30
log
@Generate set_tdesc_osabi for valid OSABI.

2010-02-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* target-descriptions.c: Include "osabi.h".
	(maint_print_c_tdesc_cmd): Generate set_tdesc_osabi for valid
	OSABI.
@
text
@d120 3
d467 4
a470 1
  { "arm_fpa_ext", TDESC_TYPE_ARM_FPA_EXT }
d495 24
d525 2
d566 10
d588 55
@


1.29
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d32 1
d1352 1
d1374 9
@


1.28
log
@ChangeLog:

	* features/gdb-target.dtd (target): Accept optional
	<compatible> elements.
	(compatible): Define element.

	* target-descriptions.h (tdesc_compatible_p): New.
	(tdesc_add_compatible): New.
	* target-descriptions.c (arch_p): New VEC_P type.
	(struct target_desc): New member compatible.
	(free_target_description): Handle it.
	(maint_print_c_tdesc_cmd): Likewise.
	(tdesc_compatible_p): New function.
	(tdesc_add_compatible): New function.

	* xml-tdesc.c (tdesc_end_compatible): New function.
	(target_children): Handle <compatible> element.

	* arch-utils.c (choose_architecture_for_target): Accept target
	description instead of BFD architecture as input.  Query target
	description for compatible architectures.
	(gdbarch_info_fill): Update call.

	* NEWS: Mention <compatible> element of target descriptions.

doc/ChangeLog:

	* gdb.texinfo (Target Descriptions): Document <compatible> element.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.27
log
@	* NEWS: Mention ARM VFP support.
	* target-descriptions.c (tdesc_register_type): Make public.
	(tdesc_unnumbered_register): New function.
	(tdesc_register_reggroup_p): Allow missing
	pseudo_register_reggroup_p.
	* target-descriptions.h (tdesc_register_type): Declare.
	(tdesc_unnumbered_register): Declare.
	* arm-tdep.c (arm_neon_quad_read, arm_neon_quad_write): New functions.
	(arm_push_dummy_call): Use arm_neon_quad_write.
	(arm_neon_double_type, arm_neon_quad_type): New functions.
	(arm_register_type): Handle VFP and NEON registers.  Override the
	types of double-precision registers for NEON.  Disable FPA registers
	if they are not present.
	(arm_dwarf_reg_to_regnum): Add current VFP and NEON register numbers.
	(arm_return_value): Use arm_neon_quad_write and arm_neon_quad_read.
	(arm_register_name): Handle VFP single and NEON quad registers.
	(arm_pseudo_read, arm_pseudo_write): New functions.
	(arm_gdbarch_init): Check for VFP and NEON in the target description.
	Assign numbers to double-precision registers.  Register VFP and NEON
	pseudo registers.  Remove a shadowed "i" variable.
	* arm-tdep.h (enum gdb_regnum): Add ARM_D0_REGNUM and
	ARM_D31_REGNUM.
	(struct gdbarch_tdep): Add have_neon_pseudos, have_neon,
	have_vfp_registers, have_vfp_pseudos, neon_double_type,
	and neon_quad_type.

	* features/Makefile: Make expedite settings only architecture
	specific.
	(WHICH): Add new ARM descriptions.
	* features/arm-with-neon.xml, features/arm-with-vfpv2.c,
	features/arm-with-vfpv3.c, features/arm-vfpv2.xml,
	features/arm-vfpv3.xml, features/arm-with-vfpv2.xml,
	features/arm-with-vfpv3.xml, features/arm-with-neon.c: New files.
	* regformats/arm-with-neon.dat, regformats/arm-with-vfpv2.dat,
	regformats/arm-with-vfpv3.dat: Generate.

	doc/
	* gdb.texinfo (ARM Features): Document org.gnu.gdb.arm.vfp and
	org.gnu.gdb.arm.neon.

	gdbserver/
	* linux-low.c (linux_write_memory): Update debugging output.
	* Makefile.in (clean): Add new descriptions.
	(arm-with-vfpv2.o, arm-with-vfpv2.c, arm-with-vfpv3.o)
	(arm-with-vfpv3.c, arm-with-neon.o, arm-with-neon.c): New rules.
	* configure.srv: Add new files for arm*-*-linux*.
	* linux-arm-low.c: Add new declarations.
	(PTRACE_GETVFPREGS, PTRACE_SETVFPREGS): Define if undefined.
	(arm_hwcap, HWCAP_VFP, HWCAP_IWMMXT, HWCAP_NEON, HWCAP_VFPv3)
	(HWCAP_VFPv3D16): New.
	(arm_fill_wmmxregset, arm_store_wmmxregset): Check HWCAP_IWMMXT
	instead of __IWMMXT__.
	(arm_fill_vfpregset, arm_store_vfpregset, arm_get_hwcap)
	(arm_arch_setup): New.
	(target_regsets): Remove #ifdef.  Add VFP regset.
	(the_low_target): Use arm_arch_setup.

	testsuite/
	* gdb.base/float.exp: Handle VFP registers.
@
text
@d161 4
d176 3
d336 22
d1188 2
d1200 24
d1315 1
d1372 10
@


1.26
log
@2009-07-20  Pedro Alves  <pedro@@codesourcery.com>

	* features/gdb-target.dtd (target): Accept an optional 'osabi'
	element.
	(osabi): Define element.
	* features/mips-linux.xml (target): Add an osabi subelement set to
	GNU/Linux.
	* regformats/regdat.sh (xmlarch, xmlosabi): New variables.  Don't
	write the architecture into $xmltarget.  Store it in $xmlarch.
	Handle the 'osabi' type.  Handle outputting the osabi element of
	the target description.
	* regformats/reg-x86-64-linux.dat (osabi): Set to GNU/Linux.
	* regformats/reg-i386-linux.dat (osabi): Set to GNU/Linux.

	* target-descriptions.h (tdesc_osabi, set_tdesc_osabi): Declare.
	* target-descriptions.c (struct target_desc) <osabi>: New field.
	(tdesc_osabi): New function.
	(set_tdesc_osabi): New function.
	* xml-tdesc.c: Include osabi.h.
	(tdesc_end_osabi): New.
	(target_children): Parse "osabi" elements.
	* arch-utils.c (gdbarch_info_fill): Try to get the osabi from the
	target description if the user didn't override it or it is not
	extractable from the bfd.  If that still fails, fallback to the
	configured in default.
	* osabi.h (osabi_from_tdesc_string): Declare.
	* osabi.c (osabi_from_tdesc_string): New.
	(gdbarch_lookup_osabi): Return GDB_OSABI_UNKNOWN instead of
	GDB_OSABI_DEFAULT.

	* NEWS: Mention that target descriptions can now describe the
	target OS ABI.

2009-07-20  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Target Description Format): Mention the new <osabi>
	optional element.
	(subsection OS ABI): New subsection.
@
text
@d636 15
d726 1
a726 1
static struct type *
d874 3
a876 2
      gdb_assert (data->pseudo_register_reggroup_p != NULL);
      return data->pseudo_register_reggroup_p (gdbarch, regno, reggroup);
@


1.25
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d168 4
d358 10
d1178 6
@


1.24
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d491 1
a491 1
      return init_float_type (-1, "builtin_type_ieee_single",
d495 1
a495 1
      return init_float_type (-1, "builtin_type_ieee_double",
d499 1
a499 1
      return init_float_type (-1, "builtin_type_arm_ext",
d520 1
a520 1
	type = init_composite_type (NULL, TYPE_CODE_UNION);
@


1.23
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d491 2
a492 1
      return builtin_type_ieee_single;
d495 2
a496 1
      return builtin_type_ieee_double;
d499 2
a500 1
      return builtin_type_arm_ext;
@


1.22
log
@	* target-descriptions.h (struct type): Do not declare.
	(struct tdesc_type): Declare.
	(tdesc_named_type): Change return type to struct tdesc_type *.
	(tdesc_record_type): Remove.
	(tdesc_create_vector): Add prototype.
	(tdesc_create_union): Likewise.
	(tdesc_add_field): Likewise.

	* target-descriptions.c (struct tdesc_reg): Replace gdb_type
	member by tdesc_type member.
	(struct tdesc_type_field, tdesc_type_field): Add type and vector def.
	(struct tdesc_type, tdesc_type_p): Likewise.
	(struct tdesc_arch_reg, tdesc_arch_reg): Likewise.
	(struct tdesc_feature): Change type of "types" to VEC(tdesc_type_p).
	(struct tdesc_arch_data): Replace registers member by arch_regs.

	(tdesc_predefined_types): Change to array of pre-defined
	struct tdesc_type structures.  Add "code_ptr" and "data_ptr".
	(tdesc_named_type): Return struct tdesc_type * instead of GDB type.
	(tdesc_gdb_type): New function.

	(target_find_description): Update for data structure changes.
	(tdesc_data_cleanup): Likewise.
	(tdesc_numbered_register): Likewise.
	(tdesc_use_registers): Likewise.
	(tdesc_create_reg): Likewise.

	(tdesc_find_arch_register): New function.
	(tdesc_find_register): Use it.
	(tdesc_register_type): Use tdesc_gdb_type to generate GDB type from
	tdesc_type on demand; cache generated types in tdesc_arch_reg.

	(tdesc_free_type): New function.
	(tdesc_free_feature): Call it.

	(tdesc_create_vector): New function.
	(tdesc_create_union): Likewise.
	(tdesc_add_field): Likewise.
	(tdesc_record_type): Remove.

	(tdesc_type_id): Remove.
	(maint_print_c_tdesc_cmd): Update for data structure changes.  Update
	generated code to create tdesc_type structures instead of GDB types.

	* xml-tdesc.c: Do not include "gdbtypes.h".
	(struct tdesc_parsing_data): Change type of current_union to
	struct tdesc_type *.
	(tdesc_start_reg): Do not special-case "code_ptr" or "data_ptr".
	(tdesc_start_union): Call tdesc_create_union.
	(tdesc_start_field): Call tdesc_add_field.
	(tdesc_start_vector): Call tdesc_create_vector.
	(tdesc_end_union): Remove.
	(feature_children): Remove reference to tdesc_end_union.

	* features/arm-with-iwmmxt.c: Regenerate.
	* features/mips-linux.c: Regenerate.
	* features/mips64-linux.c: Regenerate.
	* features/rs6000/powerpc-32.c: Regenerate.
	* features/rs6000/powerpc-32l.c: Regenerate.
	* features/rs6000/powerpc-403.c: Regenerate.
	* features/rs6000/powerpc-403gc.c: Regenerate.
	* features/rs6000/powerpc-505.c: Regenerate.
	* features/rs6000/powerpc-601.c: Regenerate.
	* features/rs6000/powerpc-602.c: Regenerate.
	* features/rs6000/powerpc-603.c: Regenerate.
	* features/rs6000/powerpc-604.c: Regenerate.
	* features/rs6000/powerpc-64.c: Regenerate.
	* features/rs6000/powerpc-64l.c: Regenerate.
	* features/rs6000/powerpc-7400.c: Regenerate.
	* features/rs6000/powerpc-750.c: Regenerate.
	* features/rs6000/powerpc-860.c: Regenerate.
	* features/rs6000/powerpc-altivec32.c: Regenerate.
	* features/rs6000/powerpc-altivec32l.c: Regenerate.
	* features/rs6000/powerpc-altivec64.c: Regenerate.
	* features/rs6000/powerpc-altivec64l.c: Regenerate.
	* features/rs6000/powerpc-e500.c: Regenerate.
	* features/rs6000/powerpc-e500l.c: Regenerate.
	* features/rs6000/powerpc-isa205-32l.c: Regenerate.
	* features/rs6000/powerpc-isa205-64l.c: Regenerate.
	* features/rs6000/powerpc-isa205-altivec32l.c: Regenerate.
	* features/rs6000/powerpc-isa205-altivec64l.c: Regenerate.
	* features/rs6000/powerpc-isa205-vsx32l.c: Regenerate.
	* features/rs6000/powerpc-isa205-vsx64l.c: Regenerate.
	* features/rs6000/powerpc-vsx32.c: Regenerate.
	* features/rs6000/powerpc-vsx32l.c: Regenerate.
	* features/rs6000/powerpc-vsx64.c: Regenerate.
	* features/rs6000/powerpc-vsx64l.c: Regenerate.
	* features/rs6000/rs6000.c: Regenerate.
@
text
@d455 1
a455 1
      return builtin_type_int8;
d458 1
a458 1
      return builtin_type_int16;
d461 1
a461 1
      return builtin_type_int32;
d464 1
a464 1
      return builtin_type_int64;
d467 1
a467 1
      return builtin_type_int128;
d470 1
a470 1
      return builtin_type_uint8;
d473 1
a473 1
      return builtin_type_uint16;
d476 1
a476 1
      return builtin_type_uint32;
d479 1
a479 1
      return builtin_type_uint64;
d482 1
a482 1
      return builtin_type_uint128;
d711 1
a711 1
    return builtin_type_int0;
@


1.21
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d82 1
a82 1
  struct type *gdb_type;
d87 56
a142 2
typedef struct type *type_p;
DEF_VEC_P(type_p);
d157 1
a157 1
  VEC(type_p) *types;
d179 7
d188 1
a188 1
  /* A list of registers, indexed by GDB's internal register number.
d194 1
a194 1
  VEC(tdesc_reg_p) *registers;
d282 1
a282 1
	      && data->registers == NULL)
d403 19
a421 23
/* Predefined types.  Note that none of these types depend on the
   current architecture; some of the builtin_type_foo variables are
   swapped based on the architecture.  */
static struct
{
  const char *name;
  struct type **type;
} tdesc_predefined_types[] =
  {
    { "int8", &builtin_type_int8 },
    { "int16", &builtin_type_int16 },
    { "int32", &builtin_type_int32 },
    { "int64", &builtin_type_int64 },
    { "int128", &builtin_type_int128 },
    { "uint8", &builtin_type_uint8 },
    { "uint16", &builtin_type_uint16 },
    { "uint32", &builtin_type_uint32 },
    { "uint64", &builtin_type_uint64 },
    { "uint128", &builtin_type_uint128 },
    { "ieee_single", &builtin_type_ieee_single },
    { "ieee_double", &builtin_type_ieee_double },
    { "arm_fpa_ext", &builtin_type_arm_ext }
  };
d426 1
a426 1
struct type *
d430 1
a430 1
  struct type *gdb_type;
d433 3
a435 3
  for (ix = 0; VEC_iterate (type_p, feature->types, ix, gdb_type); ix++)
    if (strcmp (TYPE_NAME (gdb_type), id) == 0)
      return gdb_type;
d440 1
a440 1
      return *tdesc_predefined_types[ix].type;
d444 98
d575 1
a575 1
  VEC_free (tdesc_reg_p, data->registers);
d604 1
d611 5
a615 3
  while (regno >= VEC_length (tdesc_reg_p, data->registers))
    VEC_safe_push (tdesc_reg_p, data->registers, NULL);
  VEC_replace (tdesc_reg_p, data->registers, regno, reg);
d651 2
a652 2
static struct tdesc_reg *
tdesc_find_register (struct gdbarch *gdbarch, int regno)
d654 1
a654 1
  struct tdesc_reg *reg;
d658 2
a659 2
  if (regno < VEC_length (tdesc_reg_p, data->registers))
    return VEC_index (tdesc_reg_p, data->registers, regno);
d664 7
d697 2
a698 1
  struct tdesc_reg *reg = tdesc_find_register (gdbarch, regno);
d713 44
a756 3
  /* First check for a predefined or target defined type.  */
  if (reg->gdb_type)
    return reg->gdb_type;
d758 4
a761 25
  /* Next try size-sensitive type shortcuts.  */
  if (strcmp (reg->type, "float") == 0)
    {
      if (reg->bitsize == gdbarch_float_bit (gdbarch))
	return builtin_type (gdbarch)->builtin_float;
      else if (reg->bitsize == gdbarch_double_bit (gdbarch))
	return builtin_type (gdbarch)->builtin_double;
      else if (reg->bitsize == gdbarch_long_double_bit (gdbarch))
	return builtin_type (gdbarch)->builtin_long_double;
    }
  else if (strcmp (reg->type, "int") == 0)
    {
      if (reg->bitsize == gdbarch_long_bit (gdbarch))
	return builtin_type (gdbarch)->builtin_long;
      else if (reg->bitsize == TARGET_CHAR_BIT)
	return builtin_type (gdbarch)->builtin_char;
      else if (reg->bitsize == gdbarch_short_bit (gdbarch))
	return builtin_type (gdbarch)->builtin_short;
      else if (reg->bitsize == gdbarch_int_bit (gdbarch))
	return builtin_type (gdbarch)->builtin_int;
      else if (reg->bitsize == gdbarch_long_long_bit (gdbarch))
	return builtin_type (gdbarch)->builtin_long_long;
      else if (reg->bitsize == gdbarch_ptr_bit (gdbarch))
	/* A bit desperate by this point... */
	return builtin_type (gdbarch)->builtin_data_ptr;
a762 8
  else if (strcmp (reg->type, "code_ptr") == 0)
    return builtin_type (gdbarch)->builtin_func_ptr;
  else if (strcmp (reg->type, "data_ptr") == 0)
    return builtin_type (gdbarch)->builtin_data_ptr;
  else
    internal_error (__FILE__, __LINE__,
		    "Register \"%s\" has an unknown type \"%s\"",
		    reg->name, reg->type);
d764 1
a764 3
  warning (_("Register \"%s\" has an unsupported size (%d bits)"),
	   reg->name, reg->bitsize);
  return builtin_type (gdbarch)->builtin_long;
d896 1
d906 1
a906 1
  data->registers = early_data->registers;
d927 5
a931 3
  for (ixr = 0; VEC_iterate (tdesc_reg_p, data->registers, ixr, reg); ixr++)
    if (reg)
      htab_remove_elt (reg_hash, reg);
d938 3
a940 3
  gdb_assert (VEC_length (tdesc_reg_p, data->registers) <= num_regs);
  while (VEC_length (tdesc_reg_p, data->registers) < num_regs)
    VEC_safe_push (tdesc_reg_p, data->registers, NULL);
d949 2
a950 1
	  VEC_safe_push (tdesc_reg_p, data->registers, reg);
d993 1
a993 1
  reg->gdb_type = tdesc_named_type (feature, reg->type);
d999 69
d1071 1
d1078 3
a1080 6
  /* There is no easy way to free xmalloc-allocated types, nor is
     there a way to allocate types on an obstack not associated with
     an objfile.  Therefore we never free types.  Since we only ever
     parse an identical XML document once, this memory leak is mostly
     contained.  */
  VEC_free (type_p, feature->types);
a1096 9
void
tdesc_record_type (struct tdesc_feature *feature, struct type *type)
{
  /* The type's ID should be used as its TYPE_NAME.  */
  gdb_assert (TYPE_NAME (type) != NULL);

  VEC_safe_push (type_p, feature->types, type);
}

a1216 13
static const char *
tdesc_type_id (struct type *type)
{
  int ix;

  for (ix = 0; ix < ARRAY_SIZE (tdesc_predefined_types); ix++)
    if (TYPE_MAIN_TYPE (*tdesc_predefined_types[ix].type)
	== TYPE_MAIN_TYPE (type))
      return tdesc_predefined_types[ix].name;

  return TYPE_NAME (type);
}

d1226 2
a1227 1
  struct type *type;
a1255 1
  printf_unfiltered ("#include \"gdbtypes.h\"\n");
d1266 1
a1266 1
  printf_unfiltered ("  struct type *field_type, *type;\n");
d1292 1
a1292 1
	   VEC_iterate (type_p, feature->types, ix2, type);
d1295 1
a1295 1
	  switch (TYPE_CODE (type))
d1297 1
a1297 1
	    case TYPE_CODE_ARRAY:
d1300 1
a1300 1
		 tdesc_type_id (TYPE_TARGET_TYPE (type)));
d1302 2
a1303 4
		("  type = init_vector_type (field_type, %d);\n",
		 TYPE_LENGTH (type) / TYPE_LENGTH (TYPE_TARGET_TYPE (type)));
	      printf_unfiltered
		("  TYPE_NAME (type) = xstrdup (\"%s\");\n", TYPE_NAME (type));
d1305 1
a1305 3
	    case TYPE_CODE_UNION:
	      printf_unfiltered
		("  type = init_composite_type (NULL, TYPE_CODE_UNION);\n");
d1307 5
a1311 2
		("  TYPE_NAME (type) = xstrdup (\"%s\");\n", TYPE_NAME (type));
	      for (ix3 = 0; ix3 < TYPE_NFIELDS (type); ix3++)
d1315 1
a1315 1
		     tdesc_type_id (TYPE_FIELD_TYPE (type, ix3)));
d1317 2
a1318 3
		    ("  append_composite_type_field (type, "
		     "xstrdup (\"%s\"), field_type);\n",
		     TYPE_FIELD_NAME (type, ix3));
a1319 3
	      if (TYPE_VECTOR (type))
		printf_unfiltered
		  ("  TYPE_VECTOR (type) = 1;\n");
d1322 1
a1322 1
	      error (_("C output is not supported type \"%s\"."), TYPE_NAME (type));
a1323 1
	  printf_unfiltered ("  tdesc_record_type (feature, type);\n");
@


1.20
log
@        Updated copyright notices for most files.
@
text
@d1128 3
@


1.19
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.18
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d555 1
a555 1
	return builtin_type_float;
d557 1
a557 1
	return builtin_type_double;
d559 1
a559 1
	return builtin_type_long_double;
d564 1
a564 1
	return builtin_type_long;
d566 1
a566 1
	return builtin_type_char;
d568 1
a568 1
	return builtin_type_short;
d570 1
a570 1
	return builtin_type_int;
d572 1
a572 1
	return builtin_type_long_long;
d575 1
a575 1
	return builtin_type_void_data_ptr;
d578 1
a578 1
    return builtin_type_void_func_ptr;
d580 1
a580 1
    return builtin_type_void_data_ptr;
d588 1
a588 1
  return builtin_type_long;
@


1.17
log
@	* rs6000-tdep.c (rs6000_builtin_type_vec128): Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-vsx32l.c
	(initialize_tdesc_powerpc_vsx32l): Update.
	* features/rs6000/powerpc-vsx32.c
	(initialize_tdesc_powerpc_vsx32): Update.
	* features/rs6000/powerpc-vsx64.c
	(initialize_tdesc_powerpc_vsx64): Update.
	* features/rs6000/powerpc-vsx64l.c
	(initialize_tdesc_powerpc_vsx64l): Update.
	* target-descriptions.c (maint_print_c_tdesc_cmd): Emit
	TYPE_VECTOR, not TYPE_FLAGS.
@
text
@d186 1
a186 1
  gdb_assert (gdbarch_target_desc (current_gdbarch) == NULL);
d219 1
a219 1
	  data = gdbarch_data (current_gdbarch, tdesc_data);
@


1.16
log
@2008-06-21  Hui Zhu  <teawater@@gmail.com>

	* target-descriptions.c (maint_print_c_tdesc_cmd): Fix a memory leak.
@
text
@d1099 1
a1099 1
		  ("  TYPE_FLAGS (type) |= TYPE_FLAG_VECTOR;\n");
@


1.15
log
@	Updated copyright notices for most files.
@
text
@d1016 1
a1016 1
  function = xmalloc (strlen (filename) + 1);
@


1.14
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d3 1
a3 1
   Copyright (C) 2006, 2007 Free Software Foundation, Inc.
@


1.13
log
@	* NEWS: Document target described register support for PowerPC.
	* ppc-tdep.h: Remove ppc_spr constants.
	(struct gdbarch_tdep): Remove regs, ppc_sr0_regnum, and
	ppc_builtin_type_vec128 members.
	(PPC_R0_REGNUM, PPC_F0_REGNUM, PPC_PC_REGNUM, PPC_MSR_REGNUM)
	(PPC_CR_REGNUM, PPC_LR_REGNUM, PPC_CTR_REGNUM, PPC_XER_REGNUM)
	(PPC_FPSCR_REGNUM, PPC_MQ_REGNUM, PPC_SPE_UPPER_GP0_REGNUM)
	(PPC_SPE_ACC_REGNUM, PPC_SPE_FSCR_REGNUM, PPC_VR0_REGNUM)
	(PPC_VSCR_REGNUM, PPC_VRSAVE_REGNUM, PPC_NUM_REGS): New constants.
	* rs6000-tdep.c: Include preparsed descriptions.
	(init_sim_regno_table): Do not iterate over pseudo registers.
	Look up segment registers by name.  Use sim_spr_register_name
	for SPRs.
	(rs6000_register_sim_regno): Call init_sim_regno_table here.
	(rs6000_builtin_type_vec128): Delete.
	(rs6000_register_name): Only handle SPE pseudo registers and upper
	halves.  Call tdesc_register_name for everything else.
	(rs6000_register_type): Delete.  Replace with...
	(rs6000_pseudo_register_type): ...this new function.  Only handle
	SPE pseudo registers.
	(rs6000_register_reggroup_p): Delete.  Replace with...
	(rs6000_pseudo_register_reggroup_p): ...this new function.  Only
	handle SPE pseudo registers.
	(rs6000_convert_register_p): Use ppc_fp0_regnum instead of
	"struct reg".
	(rs6000_register_to_value, rs6000_value_to_register): Remove check
	of reg->fpr.
	(e500_register_reggroup_p): Delete.
	(STR, R, R4, R8, R16, F, P8, R32, R64, R0, A4, S, S4, SN4, S64)
	(COMMON_UISA_REGS, PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS)
	(PPC_SEGMENT_REGS, PPC_OEA_SPRS, PPC_ALTIVEC_REGS, PPC_SPE_GP_REGS)
	(PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): Delete macros.
	(registers_powerpc, registers_403, registers_403GC, registers_505)
	(registers_860, registers_601, registers_602, registers_603)
	(registers_604, registers_750, registers_7400, registers_e500): Delete
	variables.
	(struct variant): Delete nregs, npregs, num_tot_regs, and regs.  Add
	tdesc.
	(tot_num_registers, num_registers, num_pseudo_registers): Delete.
	(variants): Delete outdated comment.  Use standard target descriptions
	instead of "struct reg" arrays.
	(init_variants): Delete.
	(rs6000_gdbarch_init): Do not guess word size from the BFD
	architecture if we have a target description.  Select a variant
	before creating a new architecture.  Use the variant's target
	description if the target did not define a register layout.
	Validate target-supplied registers.  Reject mismatches.  Use
	fixed register numbers and new constants instead of magic
	numbers.  Call set_gdbarch_ps_regnum.  Call tdesc_use_registers.
	(_initialize_rs6000_tdep): Initialize the preparsed target
	descriptions.
	* target-descriptions.c (tdesc_predefined_types): Add int128 and
	uint128.
	(tdesc_find_register_early): New function.
	(tdesc_numbered_register): Use it.
	(tdesc_register_size): New function.
	(tdesc_use_registers): Take a target_desc argument.  Do not use
	gdbarch_target_desc.
	* target-descriptions.h (tdesc_use_registers): Update prototype
	and comment.
	(tdesc_register_size): New prototype.
	* Makefile.in (powerpc_32_c, powerpc_403_c, powerpc_403gc_c)
	(powerpc_505_c, powerpc_601_c, powerpc_602_c, powerpc_603_c)
	(powerpc_604_c, powerpc_64_c, powerpc_7400_c, powerpc_750_c)
	(powerpc_860_c, powerpc_e500_c, rs6000_c): New macros.
	(rs6000-tdep.o): Update.
	* arm-tdep.c (arm_gdbarch_init): Update call to tdesc_use_registers.
	* m68k-tdep.c (m68k_gdbarch_init): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.

	* gdb.texinfo (Predefined Target Types): Add int128
	and uint128.
	(Standard Target Features): Add PowerPC features.

	* gdb.xml/tdesc-regs.exp: Add PowerPC support.

	* sim-ppc.h (sim_spr_register_name): New prototype.

	* gdb-sim.c (regnum2spr): Rename to...
	(sim_spr_register_name): ... this.  Make global.
@
text
@d510 1
a510 1
tdesc_register_name (int regno)
d512 3
a514 3
  struct tdesc_reg *reg = tdesc_find_register (current_gdbarch, regno);
  int num_regs = gdbarch_num_regs (current_gdbarch);
  int num_pseudo_regs = gdbarch_num_pseudo_regs (current_gdbarch);
d521 1
a521 2
      struct tdesc_arch_data *data = gdbarch_data (current_gdbarch,
						   tdesc_data);
d523 1
a523 1
      return data->pseudo_register_name (regno);
@


1.12
log
@	* target-descriptions.c (tdesc_predefined_types): New.
	(tdesc_named_type): Use it.
	(tdesc_type_id, maint_print_c_tdesc_cmd): New functions.
	(_intialize_target_descriptions): Register "maint print c-tdesc".
	* features/Makefile (XMLTOC, CFILES, GDB): New macros.
	(cfiles, %.c): New rules.
	* features/arm-with-iwmmxt.c, features/mips-linux.c,
	features/mips64-linux.c: New generated files.

	* arm-linux-nat.c: Include preparsed description instead of
	"xml-support.h".
	(super_xfer_partial, arm_linux_xfer_partial): Remove.
	(arm_linux_read_description): New function.
	(_initialize_arm_linux_nat): Set to_read_description instead of
	to_xfer_partial.  Initialize preparsed description.
	* config/arm/linux.mh (TDEP_XML): Delete.
	* mips-linux-nat.c: Include preparsed descriptions instead of
	"xml-support.h".
	(super_xfer_partial, mips_linux_xfer_partial): Remove.
	(mips_linux_read_description): New function.
	(_initialize_mips_linux_nat): Set to_read_description instead of
	to_xfer_partial.  Initialize preparsed description.
	* config/mips/linux.mh (TDEP_XML): Delete.
	* Makefile.in (XMLFILES): Remove $(TDEP_XML).
	(features_headers, arm_with_iwmmxt_c, mips_linux_c)
	(mips64_linux_c): New macros.
	(arm-linux-nat.o, mips-linux-nat.o): Update.

	* gdb.texinfo (Maintenance Commands): Document "maint print c-tdesc".
@
text
@d355 1
d360 1
d426 3
a428 4
int
tdesc_numbered_register (const struct tdesc_feature *feature,
			 struct tdesc_arch_data *data,
			 int regno, const char *name)
d437 16
a452 7
      {
	/* Make sure the vector includes a REGNO'th element.  */
	while (regno >= VEC_length (tdesc_reg_p, data->registers))
	  VEC_safe_push (tdesc_reg_p, data->registers, NULL);
	VEC_replace (tdesc_reg_p, data->registers, regno, reg);
	return 1;
      }
d454 5
a458 1
  return 0;
d461 2
a462 1
/* Search FEATURE for a register whose name is in NAMES.  */
d478 13
d713 1
a717 1
  const struct target_desc *target_desc;
a722 2
  target_desc = gdbarch_target_desc (gdbarch);

@


1.11
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d342 22
d378 4
a381 35
  /* Next try some predefined types.  Note that none of these types
     depend on the current architecture; some of the builtin_type_foo
     variables are swapped based on the architecture.  */
  if (strcmp (id, "int8") == 0)
    return builtin_type_int8;

  if (strcmp (id, "int16") == 0)
    return builtin_type_int16;

  if (strcmp (id, "int32") == 0)
    return builtin_type_int32;

  if (strcmp (id, "int64") == 0)
    return builtin_type_int64;

  if (strcmp (id, "uint8") == 0)
    return builtin_type_uint8;

  if (strcmp (id, "uint16") == 0)
    return builtin_type_uint16;

  if (strcmp (id, "uint32") == 0)
    return builtin_type_uint32;

  if (strcmp (id, "uint64") == 0)
    return builtin_type_uint64;

  if (strcmp (id, "ieee_single") == 0)
    return builtin_type_ieee_single;

  if (strcmp (id, "ieee_double") == 0)
    return builtin_type_ieee_double;

  if (strcmp (id, "arm_fpa_ext") == 0)
    return builtin_type_arm_ext;
d954 149
d1136 4
@


1.10
log
@	* target-descriptions.c (tdesc_create_reg): Do not set reg->type
	to NULL.

	* cli/cli-script.c (build_command_line): Update NULL check.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.9
log
@	* Makefile.in (mips-tdep.o): Update.
	* mips-tdep.c (struct register_alias, mips_o32_aliases)
	(mips_n32_n64_aliases, mips_register_aliases): New.
	(mips_register_name): Call tdesc_register_name.
	(mips_tdesc_register_reggroup_p): New.
	(mips_pseudo_register_type, value_of_mips_user_reg): New.
	(mips_gdbarch_init): Add target-described register support.
	Register aliases for register names.
	* target-descriptions.c (tdesc_register_name): Make global.
	(tdesc_register_in_reggroup_p): New function, broken out from
	tdesc_register_reggroup_p.
	(tdesc_register_reggroup_p): Use it.
	* target-descriptions.h (tdesc_register_name)
	(tdesc_register_in_reggroup_p): New prototypes.
	* NEWS: Correct formatting.  Mention MIPS register support.
	* features/mips-cp0.xml, features/mips-fpu.xml,
	features/mips64-cp0.xml, gdb/features/mips64-fpu.xml, mips-cpu.xml,
	features/mips64-cpu.xml: New files.

	* gdb.xml/tdesc-regs.exp: Add MIPS support.  Allow multiple
	required features to be included.

	* gdb.texinfo (MIPS Features): New subsection.
@
text
@d795 1
a795 1
  reg->type = type ? xstrdup (type) : NULL;
@


1.8
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d489 4
a492 1
static const char *
d588 3
a590 2
   Registers with no group specified go to the default reggroup
   function and are handled by type.
d601 3
a603 3
static int
tdesc_register_reggroup_p (struct gdbarch *gdbarch, int regno,
			   struct reggroup *reggroup)
a604 2
  int num_regs = gdbarch_num_regs (gdbarch);
  int num_pseudo_regs = gdbarch_num_pseudo_regs (gdbarch);
a606 7
  if (reg == NULL && regno >= num_regs && regno < num_regs + num_pseudo_regs)
    {
      struct tdesc_arch_data *data = gdbarch_data (gdbarch, tdesc_data);
      gdb_assert (data->pseudo_register_reggroup_p != NULL);
      return data->pseudo_register_reggroup_p (gdbarch, regno, reggroup);
    }

d632 26
@


1.7
log
@2007-04-13  Paul Brook  <paul@@codesourcery.com>

	* target-descriptions.c (tdesc_named_type): Add ieee_single and
	ieee_double.
	* doc/gdb.texinfo: Document ieee_single and ieee_double target types.
@
text
@d720 1
a720 1
     list of registers.  The new numbers are always above NUM_REGS.
@


1.6
log
@	* target-descriptions.c (tdesc_named_type): Move code_ptr and data_ptr
	handling from here...
	(tdesc_register_type): ...to here.
	* xml-tdesc.c (tdesc_start_reg): Allow code_ptr and data_ptr.
	* features/arm-core.xml: Use code_ptr and data_ptr.
@
text
@d385 6
@


1.5
log
@	* Makefile.in (arm-tdep.o, eval.o, target-descriptions.o)
	(xml-tdesc.o): Update.
	* xml-support.c: Add a comment.
	(gdb_xml_enums_boolean): New variable.
	(gdb_xml_parse_attr_enum): Use strcasecmp.
	* xml-support.h (gdb_xml_enums_boolean): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Record current_feature,
	next_regnum, and current_union.
	(tdesc_start_feature, tdesc_start_reg, tdesc_start_union)
	(tdesc_end_union, tdesc_start_field, tdesc_start_vector)
	(field_attributes, union_children, reg_attributes, union_attributes)
	(vector_attributes, feature_attributes, feature_children): New.
	(target_children): Make static.  Add <feature>.
	(tdesc_elements): Make static.
	* target-descriptions.c (struct tdesc_reg, tdesc_reg_p, type_p)
	(struct tdesc_feature, tdesc_feature_p): New types.
	(struct target_desc): Add features member.
	(struct tdesc_arch_data, tdesc_data): New.
	(target_find_description): Clarify error message.  Warn about
	ignored register descriptions.
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_data_init, tdesc_data_alloc)
	(tdesc_data_cleanup, tdesc_numbered_register)
	(tdesc_numbered_register_choices, tdesc_find_register)
	(tdesc_register_name, tdesc_register_type)
	(tdesc_remote_register_number, tdesc_register_reggroup_p)
	(set_tdesc_pseudo_register_name, set_tdesc_pseudo_register_type)
	(set_tdesc_pseudo_register_reggroup_p, tdesc_use_registers)
	(tdesc_free_reg, tdesc_create_reg, tdesc_free_feature)
	(tdesc_create_feature, tdesc_record_type): New.
	(free_target_description): Free features.
	(_initialize_target_descriptions): Initialize tdesc_data.
	* arch-utils.c (default_remote_register_number): New.
	* arch-utils.h (default_remote_register_number): New prototype.
	* target-descriptions.h (set_tdesc_pseudo_register_name)
	(set_tdesc_pseudo_register_type, set_tdesc_pseudo_register_reggroup_p)
	(tdesc_use_registers, tdesc_data_alloc, tdesc_data_cleanup)
	(tdesc_numbered_register, tdesc_numbered_register_choices)
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_create_feature, tdesc_record_type)
	(tdesc_create_reg): Declare.
	* gdbarch.sh (remote_register_number): New entry.
	* gdbarch.c, gdbarch.h: Regenerate.
	* remote.c (init_remote_state): Use gdbarch_remote_register_number.
	* features/gdb-target.dtd: Add feature, reg, vector, union, and field.

	* arm-tdep.c (arm_register_aliases): New.
	(arm_register_name_strings): Rename to...
	(arm_register_names): ...this.  Make const.  Delete the old version.
	(current_option, arm_register_byte): Delete.
	(set_disassembly_style): Simplify.  Do not adjust arm_register_names.
	(value_of_arm_user_reg): New.
	(arm_gdbarch_init): Verify any described registers.  Call
	tdesc_use_registers.  Don't use arm_register_byte.  Create aliases
	for standard register names.
	(_initialize_arm_tdep): Do not adjust arm_register_names.
	* user-regs.c (struct user_reg): Add baton member.
	(append_user_reg, user_reg_add_builtin, user_regs_init)
	(user_reg_add, value_of_user_reg): Use a baton for user
	register functions.
	* std-regs.c: Update.
	* user-regs.h (user_reg_read_ftype, user_reg_add_builtin)
	(user_reg_add): Add baton argument.
	* NEWS: Mention target description register support.
	* features/arm-core.xml, features/arm-fpa.xml: New.
	* eval.c (evaluate_subexp_standard): Allow ptype $register
	when the program is not running.

	* gdb.texinfo (-target-disconnect): Use @@smallexample.
	(Requirements): Add anchor for Expat.  Update description.
	(Target Descriptions): Mention Expat.
	(Target Description Format): Document new elements.  Use
	@@smallexample.
	(Predefined Target Types, Standard Target Features): New sections.
	* doc/gdbint.texinfo (Target Descriptions): New section.

	* gdb.xml/single-reg.xml, gdb.xml/tdesc-regs.exp,
	gdb.xml/core-only.xml, gdb.xml/extra-regs.xml: New files.
@
text
@a384 6
  if (strcmp (id, "code_ptr") == 0)
    return builtin_type_void_func_ptr;

  if (strcmp (id, "data_ptr") == 0)
    return builtin_type_void_data_ptr;

d552 4
@


1.4
log
@XML feature description support.

	* NEWS: Mention target descriptions, "set tdesc filename",
	"unset tdesc filename", "show tdesc filename", and
	qXfer:features:read.
	* arch-utils.c (choose_architecture_for_target): New function.
	(gdbarch_info_fill): Call it.
	* target-descriptions.c (struct property): Make members non-const.
	(struct target_desc): Add arch member.
	(target_description_filename): New variable.
	(target_find_description): Try via XML first.
	(tdesc_architecture): New.
	(free_target_description, make_cleanup_free_target_description): New.
	(set_tdesc_property): Call xstrdup.
	(set_tdesc_architecture, tdesc_set_cmdlist, tdesc_show_cmdlist)
	(tdesc_unset_cmdlist, unset_tdesc_cmd, unset_tdesc_filename_cmd)
	(set_tdesc_cmd, show_tdesc_cmd, set_tdesc_filename_cmd)
	(show_tdesc_filename_cmd, _initialize_target_descriptions): New.
	* target-descriptions.h (tdesc_architecture)
	(make_cleanup_free_target_description, set_tdesc_architecture): New
	prototypes.
	* Makefile.in (SFILES): Add xml-tdesc.c.
	(COMMON_OBS): Add xml-tdesc.o.
	(target-descriptions.o): Update.
	(xml-tdesc.o): New rule.
	* xml-tdesc.c, xml-tdesc.h: New files.
	* remote.c (PACKET_qXfer_features): New enum.
	(remote_protocol_features): Add qXfer:features:read.
	(remote_xfer_partial): Handle TARGET_OBJECT_AVAILABLE_FEATURES.
	(_initialize_remote): Register qXfer:features:read.
	* target.h (enum target_object): Add TARGET_OBJECT_AVAILABLE_FEATURES.
	* features/gdb-target.dtd: New file.

	* linux-i386-low.c (the_low_target): Set arch_string.
	* linux-x86-64-low.c (the_low_target): Likewise.
	* linux-low.c (linux_arch_string): New.
	(linux_target_ops): Add it.
	* linux-low.h (struct linux_target_ops): Add arch_string.
	* server.c (write_qxfer_response): Use const void * for DATA.
	(get_features_xml): New.
	(handle_query): Handle qXfer:features:read.  Report it for qSupported.
	* target.h (struct target_ops): Add arch_string method.

	* gdb.texinfo (Target Descriptions): New section.
	(General Query Packets): Add QPassSignals anchor.  Mention
	qXfer:features:read under qSupported.  Expand mentions of
	qXfer:memory-map:read and QPassSignals.  Document
	qXfer:features:read.
@
text
@d27 2
d32 1
d36 2
d48 63
d118 24
d167 5
d216 11
a226 1
	warning (_("Could not use target-supplied description"));
d268 1
a268 1
/* Direct accessors for feature sets.  */
d297 450
d749 71
d830 1
d835 6
d943 2
@


1.3
log
@Copyright updates for 2007.
@
text
@d26 1
d30 1
d38 2
a39 2
  const char *key;
  const char *value;
d45 3
d69 6
d93 16
a108 1
  current_target_desc = target_read_description (&current_target);
d159 3
d180 10
d198 25
d238 2
a239 2
  new_prop.key = key;
  new_prop.value = value;
d242 95
@


1.2
log
@	* Makefile.in (mips-tdep.o, target-descriptions.o): Update.
	* target-descriptions.c (struct property): New.
	(struct target_desc): Add properties member.
	(tdesc_property, set_tdesc_property): New.
	* target-descriptions.h (tdesc_property, set_tdesc_property):
	Declare.
	* mips-tdep.c (PROPERTY_GP32, PROPERTY_GP64): New constants.
	(struct gdbarch_tdep): Add register_size_valid_p and register_size.
	(mips_isa_regsize): Use them.
	(mips_register_g_packet_guesses): New.
	(mips_gdbarch_init): Call it.  If a target description is supplied,
	check for internal properties.  Check for register size mismatches.
	* remote.c (send_g_packet, process_g_packet): New functions, split
	out from fetch_registers_using_g.
	(fetch_registers_using_g): Use them.
	(struct remote_g_packet_guess, remote_g_packet_guess_s)
	(struct remote_g_packet_data, remote_g_packet_data_handle)
	(remote_g_packet_data_init, register_remote_g_packet_guess)
	(remote_read_description): New.
	(init_remote_ops, init_remote_async_ops): Set to_read_description.
	(_initialize_remote): Register remote_g_packet_data_handle.
	* remote.h (register_remote_g_packet_guess): Declare.
@
text
@d3 1
a3 2
   Copyright (C) 2006
   Free Software Foundation, Inc.
@


1.1
log
@	* Makefile.in (SFILES): Add new and missed files.
	(target_descriptions_h): New.
	(COMMON_OBS): Add target-descriptions.o.
	(arch-utils.o, infcmd.o, remote.o, target.o): Update.
	(target-descriptions.o): New.
	* arch-utils.c (gdbarch_info_fill): Check for a target
	description.
	* target-descriptions.c, target-descriptions.h: New files.
	* gdbarch.sh: Add target_desc to info.  Declare it in gdbarch.h.
	Correct typos.
	(gdbarch_list_lookup_by_info): Check target_desc.
	* gdbarch.c, gdbarch.h: Regenerated.
	* target.c (update_current_target): Mention to_read_description.
	(target_pre_inferior): Call target_clear_description.
	(target_read_description): New.
	* target.h (struct target_ops): Add to_read_description.
	(target_read_description): New prototype.
	* infcmd.c (post_create_inferior): Call target_find_description.
	* remote.c (remote_open_1): Likewise.
	(extended_remote_create_inferior): Add a comment.
	(extended_remote_async_create_inferior): Likewise.
@
text
@d29 1
d35 7
d44 2
d135 17
d159 20
@

