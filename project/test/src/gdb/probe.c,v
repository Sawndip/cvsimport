head	1.12;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.6
	gdb_7_6-2013-04-26-release:1.6
	gdb_7_6-branch:1.6.0.2
	gdb_7_6-2013-03-12-branchpoint:1.6
	gdb_7_5_1-2012-11-29-release:1.3
	gdb_7_5-2012-08-17-release:1.3
	gdb_7_5-branch:1.3.0.2
	gdb_7_5-2012-07-18-branchpoint:1.3;
locks; strict;
comment	@ * @;


1.12
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.11;

1.11
date	2013.09.24.13.54.42;	author jkratoch;	state Exp;
branches;
next	1.10;

1.10
date	2013.07.24.19.50.32;	author sergiodj;	state Exp;
branches;
next	1.9;

1.9
date	2013.06.04.12.50.20;	author gary;	state Exp;
branches;
next	1.8;

1.8
date	2013.05.30.17.39.34;	author tromey;	state Exp;
branches;
next	1.7;

1.7
date	2013.04.15.18.13.00;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.18.16.20.43;	author sergiodj;	state Exp;
branches;
next	1.4;

1.4
date	2012.07.18.16.12.17;	author sergiodj;	state Exp;
branches;
next	1.3;

1.3
date	2012.05.08.01.35.34;	author sergiodj;	state Exp;
branches;
next	1.2;

1.2
date	2012.04.28.04.52.33;	author sergiodj;	state Exp;
branches;
next	1.1;

1.1
date	2012.04.27.20.47.55;	author sergiodj;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@/* Generic static probe support for GDB.

   Copyright (C) 2012-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "probe.h"
#include "command.h"
#include "cli/cli-cmds.h"
#include "cli/cli-utils.h"
#include "objfiles.h"
#include "symtab.h"
#include "progspace.h"
#include "filenames.h"
#include "exceptions.h"
#include "linespec.h"
#include "gdb_regex.h"
#include "frame.h"
#include "arch-utils.h"
#include <ctype.h>



/* See definition in probe.h.  */

struct symtabs_and_lines
parse_probes (char **argptr, struct linespec_result *canonical)
{
  char *arg_start, *arg_end, *arg;
  char *objfile_namestr = NULL, *provider = NULL, *name, *p;
  struct cleanup *cleanup;
  struct symtabs_and_lines result;
  struct objfile *objfile;
  struct program_space *pspace;
  const struct probe_ops *probe_ops;
  const char *cs;

  result.sals = NULL;
  result.nelts = 0;

  arg_start = *argptr;

  cs = *argptr;
  probe_ops = probe_linespec_to_ops (&cs);
  gdb_assert (probe_ops != NULL);

  arg = (char *) cs;
  arg = skip_spaces (arg);
  if (!*arg)
    error (_("argument to `%s' missing"), arg_start);

  arg_end = skip_to_space (arg);

  /* We make a copy here so we can write over parts with impunity.  */
  arg = savestring (arg, arg_end - arg);
  cleanup = make_cleanup (xfree, arg);

  /* Extract each word from the argument, separated by ":"s.  */
  p = strchr (arg, ':');
  if (p == NULL)
    {
      /* This is `-p name'.  */
      name = arg;
    }
  else
    {
      char *hold = p + 1;

      *p = '\0';
      p = strchr (hold, ':');
      if (p == NULL)
	{
	  /* This is `-p provider:name'.  */
	  provider = arg;
	  name = hold;
	}
      else
	{
	  /* This is `-p objfile:provider:name'.  */
	  *p = '\0';
	  objfile_namestr = arg;
	  provider = hold;
	  name = p + 1;
	}
    }

  if (*name == '\0')
    error (_("no probe name specified"));
  if (provider && *provider == '\0')
    error (_("invalid provider name"));
  if (objfile_namestr && *objfile_namestr == '\0')
    error (_("invalid objfile name"));

  ALL_PSPACES (pspace)
    ALL_PSPACE_OBJFILES (pspace, objfile)
      {
	VEC (probe_p) *probes;
	struct probe *probe;
	int ix;

	if (!objfile->sf || !objfile->sf->sym_probe_fns)
	  continue;

	if (objfile_namestr
	    && FILENAME_CMP (objfile_name (objfile), objfile_namestr) != 0
	    && FILENAME_CMP (lbasename (objfile_name (objfile)),
			     objfile_namestr) != 0)
	  continue;

	probes = objfile->sf->sym_probe_fns->sym_get_probes (objfile);

	for (ix = 0; VEC_iterate (probe_p, probes, ix, probe); ix++)
	  {
	    struct symtab_and_line *sal;

	    if (probe_ops != &probe_ops_any && probe->pops != probe_ops)
	      continue;

	    if (provider && strcmp (probe->provider, provider) != 0)
	      continue;

	    if (strcmp (probe->name, name) != 0)
	      continue;

	    ++result.nelts;
	    result.sals = xrealloc (result.sals,
				    result.nelts
				    * sizeof (struct symtab_and_line));
	    sal = &result.sals[result.nelts - 1];

	    init_sal (sal);

	    sal->pc = probe->address;
	    sal->explicit_pc = 1;
	    sal->section = find_pc_overlay (sal->pc);
	    sal->pspace = pspace;
	    sal->probe = probe;
	  }
      }

  if (result.nelts == 0)
    {
      throw_error (NOT_FOUND_ERROR,
		   _("No probe matching objfile=`%s', provider=`%s', name=`%s'"),
		   objfile_namestr ? objfile_namestr : _("<any>"),
		   provider ? provider : _("<any>"),
		   name);
    }

  if (canonical)
    {
      canonical->special_display = 1;
      canonical->pre_expanded = 1;
      canonical->addr_string = savestring (*argptr, arg_end - *argptr);
    }

  *argptr = arg_end;
  do_cleanups (cleanup);

  return result;
}

/* See definition in probe.h.  */

VEC (probe_p) *
find_probes_in_objfile (struct objfile *objfile, const char *provider,
			const char *name)
{
  VEC (probe_p) *probes, *result = NULL;
  int ix;
  struct probe *probe;

  if (!objfile->sf || !objfile->sf->sym_probe_fns)
    return NULL;

  probes = objfile->sf->sym_probe_fns->sym_get_probes (objfile);
  for (ix = 0; VEC_iterate (probe_p, probes, ix, probe); ix++)
    {
      if (strcmp (probe->provider, provider) != 0)
	continue;

      if (strcmp (probe->name, name) != 0)
	continue;

      VEC_safe_push (probe_p, result, probe);
    }

  return result;
}

/* See definition in probe.h.  */

struct probe *
find_probe_by_pc (CORE_ADDR pc)
{
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
  {
    VEC (probe_p) *probes;
    int ix;
    struct probe *probe;

    if (!objfile->sf || !objfile->sf->sym_probe_fns)
      continue;

    /* If this proves too inefficient, we can replace with a hash.  */
    probes = objfile->sf->sym_probe_fns->sym_get_probes (objfile);
    for (ix = 0; VEC_iterate (probe_p, probes, ix, probe); ix++)
      if (probe->address == pc)
	return probe;
  }

  return NULL;
}



/* Make a vector of probes matching OBJNAME, PROVIDER, and PROBE_NAME.
   If POPS is not NULL, only probes of this certain probe_ops will match.
   Each argument is a regexp, or NULL, which matches anything.  */

static VEC (probe_p) *
collect_probes (char *objname, char *provider, char *probe_name,
		const struct probe_ops *pops)
{
  struct objfile *objfile;
  VEC (probe_p) *result = NULL;
  struct cleanup *cleanup, *cleanup_temps;
  regex_t obj_pat, prov_pat, probe_pat;

  cleanup = make_cleanup (VEC_cleanup (probe_p), &result);

  cleanup_temps = make_cleanup (null_cleanup, NULL);
  if (provider != NULL)
    compile_rx_or_error (&prov_pat, provider, _("Invalid provider regexp"));
  if (probe_name != NULL)
    compile_rx_or_error (&probe_pat, probe_name, _("Invalid probe regexp"));
  if (objname != NULL)
    compile_rx_or_error (&obj_pat, objname, _("Invalid object file regexp"));

  ALL_OBJFILES (objfile)
    {
      VEC (probe_p) *probes;
      struct probe *probe;
      int ix;

      if (! objfile->sf || ! objfile->sf->sym_probe_fns)
	continue;

      if (objname)
	{
	  if (regexec (&obj_pat, objfile_name (objfile), 0, NULL, 0) != 0)
	    continue;
	}

      probes = objfile->sf->sym_probe_fns->sym_get_probes (objfile);

      for (ix = 0; VEC_iterate (probe_p, probes, ix, probe); ix++)
	{
	  if (pops != NULL && probe->pops != pops)
	    continue;

	  if (provider
	      && regexec (&prov_pat, probe->provider, 0, NULL, 0) != 0)
	    continue;

	  if (probe_name
	      && regexec (&probe_pat, probe->name, 0, NULL, 0) != 0)
	    continue;

	  VEC_safe_push (probe_p, result, probe);
	}
    }

  do_cleanups (cleanup_temps);
  discard_cleanups (cleanup);
  return result;
}

/* A qsort comparison function for probe_p objects.  */

static int
compare_probes (const void *a, const void *b)
{
  const struct probe *pa = *((const struct probe **) a);
  const struct probe *pb = *((const struct probe **) b);
  int v;

  v = strcmp (pa->provider, pb->provider);
  if (v)
    return v;

  v = strcmp (pa->name, pb->name);
  if (v)
    return v;

  if (pa->address < pb->address)
    return -1;
  if (pa->address > pb->address)
    return 1;

  return strcmp (objfile_name (pa->objfile), objfile_name (pb->objfile));
}

/* Helper function that generate entries in the ui_out table being
   crafted by `info_probes_for_ops'.  */

static void
gen_ui_out_table_header_info (VEC (probe_p) *probes,
			      const struct probe_ops *p)
{
  /* `headings' refers to the names of the columns when printing `info
     probes'.  */
  VEC (info_probe_column_s) *headings = NULL;
  struct cleanup *c;
  info_probe_column_s *column;
  size_t headings_size;
  int ix;

  gdb_assert (p != NULL);

  if (p->gen_info_probes_table_header == NULL
      && p->gen_info_probes_table_values == NULL)
    return;

  gdb_assert (p->gen_info_probes_table_header != NULL
	      && p->gen_info_probes_table_values != NULL);

  c = make_cleanup (VEC_cleanup (info_probe_column_s), &headings);
  p->gen_info_probes_table_header (&headings);

  headings_size = VEC_length (info_probe_column_s, headings);

  for (ix = 0;
       VEC_iterate (info_probe_column_s, headings, ix, column);
       ++ix)
    {
      struct probe *probe;
      int jx;
      size_t size_max = strlen (column->print_name);

      for (jx = 0; VEC_iterate (probe_p, probes, jx, probe); ++jx)
	{
	  /* `probe_fields' refers to the values of each new field that this
	     probe will display.  */
	  VEC (const_char_ptr) *probe_fields = NULL;
	  struct cleanup *c2;
	  const char *val;
	  int kx;

	  if (probe->pops != p)
	    continue;

	  c2 = make_cleanup (VEC_cleanup (const_char_ptr), &probe_fields);
	  p->gen_info_probes_table_values (probe, &probe_fields);

	  gdb_assert (VEC_length (const_char_ptr, probe_fields)
		      == headings_size);

	  for (kx = 0; VEC_iterate (const_char_ptr, probe_fields, kx, val);
	       ++kx)
	    {
	      /* It is valid to have a NULL value here, which means that the
		 backend does not have something to write and this particular
		 field should be skipped.  */
	      if (val == NULL)
		continue;

	      size_max = max (strlen (val), size_max);
	    }
	  do_cleanups (c2);
	}

      ui_out_table_header (current_uiout, size_max, ui_left,
			   column->field_name, column->print_name);
    }

  do_cleanups (c);
}

/* Helper function to print extra information about a probe and an objfile
   represented by PROBE.  */

static void
print_ui_out_info (struct probe *probe)
{
  int ix;
  int j = 0;
  /* `values' refers to the actual values of each new field in the output
     of `info probe'.  `headings' refers to the names of each new field.  */
  VEC (const_char_ptr) *values = NULL;
  VEC (info_probe_column_s) *headings = NULL;
  info_probe_column_s *column;
  struct cleanup *c;

  gdb_assert (probe != NULL);
  gdb_assert (probe->pops != NULL);

  if (probe->pops->gen_info_probes_table_header == NULL
      && probe->pops->gen_info_probes_table_values == NULL)
    return;

  gdb_assert (probe->pops->gen_info_probes_table_header != NULL
	      && probe->pops->gen_info_probes_table_values != NULL);

  c = make_cleanup (VEC_cleanup (info_probe_column_s), &headings);
  make_cleanup (VEC_cleanup (const_char_ptr), &values);

  probe->pops->gen_info_probes_table_header (&headings);
  probe->pops->gen_info_probes_table_values (probe, &values);

  gdb_assert (VEC_length (info_probe_column_s, headings)
	      == VEC_length (const_char_ptr, values));

  for (ix = 0;
       VEC_iterate (info_probe_column_s, headings, ix, column);
       ++ix)
    {
      const char *val = VEC_index (const_char_ptr, values, j++);

      if (val == NULL)
	ui_out_field_skip (current_uiout, column->field_name);
      else
	ui_out_field_string (current_uiout, column->field_name, val);
    }

  do_cleanups (c);
}

/* Helper function that returns the number of extra fields which POPS will
   need.  */

static int
get_number_extra_fields (const struct probe_ops *pops)
{
  VEC (info_probe_column_s) *headings = NULL;
  struct cleanup *c;
  int n;

  if (pops->gen_info_probes_table_header == NULL)
    return 0;

  c = make_cleanup (VEC_cleanup (info_probe_column_s), &headings);
  pops->gen_info_probes_table_header (&headings);

  n = VEC_length (info_probe_column_s, headings);

  do_cleanups (c);

  return n;
}

/* See comment in probe.h.  */

void
info_probes_for_ops (char *arg, int from_tty, const struct probe_ops *pops)
{
  char *provider, *probe_name = NULL, *objname = NULL;
  struct cleanup *cleanup = make_cleanup (null_cleanup, NULL);
  VEC (probe_p) *probes;
  int i, any_found;
  int ui_out_extra_fields = 0;
  size_t size_addr;
  size_t size_name = strlen ("Name");
  size_t size_objname = strlen ("Object");
  size_t size_provider = strlen ("Provider");
  struct probe *probe;
  struct gdbarch *gdbarch = get_current_arch ();

  /* Do we have a `provider:probe:objfile' style of linespec?  */
  provider = extract_arg (&arg);
  if (provider)
    {
      make_cleanup (xfree, provider);

      probe_name = extract_arg (&arg);
      if (probe_name)
	{
	  make_cleanup (xfree, probe_name);

	  objname = extract_arg (&arg);
	  if (objname)
	    make_cleanup (xfree, objname);
	}
    }

  if (pops == NULL)
    {
      const struct probe_ops *po;
      int ix;

      /* If the probe_ops is NULL, it means the user has requested a "simple"
	 `info probes', i.e., she wants to print all information about all
	 probes.  For that, we have to identify how many extra fields we will
	 need to add in the ui_out table.

	 To do that, we iterate over all probe_ops, querying each one about
	 its extra fields, and incrementing `ui_out_extra_fields' to reflect
	 that number.  */

      for (ix = 0; VEC_iterate (probe_ops_cp, all_probe_ops, ix, po); ++ix)
	ui_out_extra_fields += get_number_extra_fields (po);
    }
  else
    ui_out_extra_fields = get_number_extra_fields (pops);

  probes = collect_probes (objname, provider, probe_name, pops);
  make_cleanup (VEC_cleanup (probe_p), &probes);
  make_cleanup_ui_out_table_begin_end (current_uiout,
				       4 + ui_out_extra_fields,
				       VEC_length (probe_p, probes),
				       "StaticProbes");

  if (!VEC_empty (probe_p, probes))
    qsort (VEC_address (probe_p, probes), VEC_length (probe_p, probes),
	   sizeof (probe_p), compare_probes);

  /* What's the size of an address in our architecture?  */
  size_addr = gdbarch_addr_bit (gdbarch) == 64 ? 18 : 10;

  /* Determining the maximum size of each field (`provider', `name' and
     `objname').  */
  for (i = 0; VEC_iterate (probe_p, probes, i, probe); ++i)
    {
      size_name = max (strlen (probe->name), size_name);
      size_provider = max (strlen (probe->provider), size_provider);
      size_objname = max (strlen (objfile_name (probe->objfile)), size_objname);
    }

  ui_out_table_header (current_uiout, size_provider, ui_left, "provider",
		       _("Provider"));
  ui_out_table_header (current_uiout, size_name, ui_left, "name", _("Name"));
  ui_out_table_header (current_uiout, size_addr, ui_left, "addr", _("Where"));

  if (pops == NULL)
    {
      const struct probe_ops *po;
      int ix;

      /* We have to generate the table header for each new probe type that we
	 will print.  */
      for (ix = 0; VEC_iterate (probe_ops_cp, all_probe_ops, ix, po); ++ix)
	gen_ui_out_table_header_info (probes, po);
    }
  else
    gen_ui_out_table_header_info (probes, pops);

  ui_out_table_header (current_uiout, size_objname, ui_left, "object",
		       _("Object"));
  ui_out_table_body (current_uiout);

  for (i = 0; VEC_iterate (probe_p, probes, i, probe); ++i)
    {
      struct cleanup *inner;

      inner = make_cleanup_ui_out_tuple_begin_end (current_uiout, "probe");

      ui_out_field_string (current_uiout, "provider", probe->provider);
      ui_out_field_string (current_uiout, "name", probe->name);
      ui_out_field_core_addr (current_uiout, "addr",
			      get_objfile_arch (probe->objfile),
			      probe->address);

      if (pops == NULL)
	{
	  const struct probe_ops *po;
	  int ix;

	  for (ix = 0; VEC_iterate (probe_ops_cp, all_probe_ops, ix, po);
	       ++ix)
	    if (probe->pops == po)
	      print_ui_out_info (probe);
	}
      else
	print_ui_out_info (probe);

      ui_out_field_string (current_uiout, "object",
			   objfile_name (probe->objfile));
      ui_out_text (current_uiout, "\n");

      do_cleanups (inner);
    }

  any_found = !VEC_empty (probe_p, probes);
  do_cleanups (cleanup);

  if (!any_found)
    ui_out_message (current_uiout, 0, _("No probes matched.\n"));
}

/* Implementation of the `info probes' command.  */

static void
info_probes_command (char *arg, int from_tty)
{
  info_probes_for_ops (arg, from_tty, NULL);
}

/* See comments in probe.h.  */

unsigned
get_probe_argument_count (struct probe *probe)
{
  const struct sym_probe_fns *probe_fns;

  gdb_assert (probe->objfile != NULL);
  gdb_assert (probe->objfile->sf != NULL);

  probe_fns = probe->objfile->sf->sym_probe_fns;

  gdb_assert (probe_fns != NULL);

  return probe_fns->sym_get_probe_argument_count (probe);
}

/* See comments in probe.h.  */

int
can_evaluate_probe_arguments (struct probe *probe)
{
  const struct sym_probe_fns *probe_fns;

  gdb_assert (probe->objfile != NULL);
  gdb_assert (probe->objfile->sf != NULL);

  probe_fns = probe->objfile->sf->sym_probe_fns;

  gdb_assert (probe_fns != NULL);

  return probe_fns->can_evaluate_probe_arguments (probe);
}

/* See comments in probe.h.  */

struct value *
evaluate_probe_argument (struct probe *probe, unsigned n)
{
  const struct sym_probe_fns *probe_fns;

  gdb_assert (probe->objfile != NULL);
  gdb_assert (probe->objfile->sf != NULL);

  probe_fns = probe->objfile->sf->sym_probe_fns;

  gdb_assert (probe_fns != NULL);

  return probe_fns->sym_evaluate_probe_argument (probe, n);
}

/* See comments in probe.h.  */

struct value *
probe_safe_evaluate_at_pc (struct frame_info *frame, unsigned n)
{
  struct probe *probe;
  unsigned n_args;

  probe = find_probe_by_pc (get_frame_pc (frame));
  if (!probe)
    return NULL;

  n_args = get_probe_argument_count (probe);
  if (n >= n_args)
    return NULL;

  return evaluate_probe_argument (probe, n);
}

/* See comment in probe.h.  */

const struct probe_ops *
probe_linespec_to_ops (const char **linespecp)
{
  int ix;
  const struct probe_ops *probe_ops;

  for (ix = 0; VEC_iterate (probe_ops_cp, all_probe_ops, ix, probe_ops); ix++)
    if (probe_ops->is_linespec (linespecp))
      return probe_ops;

  return NULL;
}

/* See comment in probe.h.  */

int
probe_is_linespec_by_keyword (const char **linespecp, const char *const *keywords)
{
  const char *s = *linespecp;
  const char *const *csp;

  for (csp = keywords; *csp; csp++)
    {
      const char *keyword = *csp;
      size_t len = strlen (keyword);

      if (strncmp (s, keyword, len) == 0 && isspace (s[len]))
	{
	  *linespecp += len + 1;
	  return 1;
	}
    }

  return 0;
}

/* Implementation of `is_linespec' method for `struct probe_ops'.  */

static int
probe_any_is_linespec (const char **linespecp)
{
  static const char *const keywords[] = { "-p", "-probe", NULL };

  return probe_is_linespec_by_keyword (linespecp, keywords);
}

/* Dummy method used for `probe_ops_any'.  */

static void
probe_any_get_probes (VEC (probe_p) **probesp, struct objfile *objfile)
{
  /* No probes can be provided by this dummy backend.  */
}

/* Operations associated with a generic probe.  */

const struct probe_ops probe_ops_any =
{
  probe_any_is_linespec,
  probe_any_get_probes,
};

/* See comments in probe.h.  */

struct cmd_list_element **
info_probes_cmdlist_get (void)
{
  static struct cmd_list_element *info_probes_cmdlist;

  if (info_probes_cmdlist == NULL)
    add_prefix_cmd ("probes", class_info, info_probes_command,
		    _("\
Show available static probes.\n\
Usage: info probes [all|TYPE [ARGS]]\n\
TYPE specifies the type of the probe, and can be one of the following:\n\
  - stap\n\
If you specify TYPE, there may be additional arguments needed by the\n\
subcommand.\n\
If you do not specify any argument, or specify `all', then the command\n\
will show information about all types of probes."),
		    &info_probes_cmdlist, "info probes ",
		    0/*allow-unknown*/, &infolist);

  return &info_probes_cmdlist;
}

VEC (probe_ops_cp) *all_probe_ops;

void _initialize_probe (void);

void
_initialize_probe (void)
{
  VEC_safe_push (probe_ops_cp, all_probe_ops, &probe_ops_any);

  add_cmd ("all", class_info, info_probes_command,
	   _("\
Show information about all type of probes."),
	   info_probes_cmdlist_get ());
}
@


1.11
log
@Code cleanup: rename variable

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup.
	* probe.c (parse_probes): Rename variable objfile_name to
	objfile_namestr.
@
text
@d119 3
a121 2
	    && FILENAME_CMP (objfile->name, objfile_namestr) != 0
	    && FILENAME_CMP (lbasename (objfile->name), objfile_namestr) != 0)
d267 1
a267 1
	  if (regexec (&obj_pat, objfile->name, 0, NULL, 0) != 0)
d317 1
a317 1
  return strcmp (pa->objfile->name, pb->objfile->name);
d542 1
a542 1
      size_objname = max (strlen (probe->objfile->name), size_objname);
d592 2
a593 1
      ui_out_field_string (current_uiout, "object", probe->objfile->name);
@


1.10
log
@2013-07-24  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* breakpoint.c (create_longjmp_master_breakpoint): Check if probe
	interface can evaluate arguments.  Fallback to the old mode if it
	cannot.
	(create_exception_master_breakpoint): Likewise.
	* elfread.c (elf_can_evaluate_probe_arguments): New function.
	(struct sym_probe_fns elf_probe_fns): Export function above to the
	probe interface.
	* probe.c (can_evaluate_probe_arguments): New function.
	* probe.h (struct probe_ops) <can_evaluate_probe_arguments>: New
	function pointer.
	(can_evaluate_probe_arguments): New function prototype.
	* solib-svr4.c (svr4_create_solib_event_breakpoints): Check if
	probe interface can evaluate arguments.  Fallback to the old mode
	if it cannot.
	* stap-probe.c (stap_get_probe_argument_count): Check if probe
	interface can evaluate arguments.  Warning the user if it cannot.
	(stap_can_evaluate_probe_arguments): New function.
	(struct probe_ops stap_probe_ops): Export function above to the
	probe interface.
	* symfile.h (struct sym_probe_fns) <can_evaluate_probe_arguments>:
	New function pointer.
@
text
@d44 1
a44 1
  char *objfile_name = NULL, *provider = NULL, *name, *p;
d95 1
a95 1
	  objfile_name = arg;
d105 1
a105 1
  if (objfile_name && *objfile_name == '\0')
d118 3
a120 3
	if (objfile_name
	    && FILENAME_CMP (objfile->name, objfile_name) != 0
	    && FILENAME_CMP (lbasename (objfile->name), objfile_name) != 0)
d158 1
a158 1
		   objfile_name ? objfile_name : _("<any>"),
@


1.9
log
@2013-06-04  Gary Benson  <gbenson@@redhat.com>

	* probe.h (get_probe_argument_count): New declaration.
	(evaluate_probe_argument): Likewise.
	* probe.c (get_probe_argument_count): New function.
	(evaluate_probe_argument): Likewise.
	(probe_safe_evaluate_at_pc): Use the above new functions.
@
text
@d631 17
@


1.8
log
@fix compile_rx_or_error

compile_rx_or_error looks like a constructor, but it can return NULL.
This patch changes it to remove the NULL return, making it work
like any other cleanup constructor.

This is a stylistic patch but I think it is also better for code to
follow the normal conventions.

	* probe.c (collect_probes): Check arguments for NULL before
	calling compile_rx_or_error.
	* utils.c (compile_rx_or_error): Require 'rx' to be non-NULL.
	Remove NULL return.
@
text
@d614 34
a651 1
  const struct sym_probe_fns *probe_fns;
d658 1
a658 7
  gdb_assert (probe->objfile != NULL);
  gdb_assert (probe->objfile->sf != NULL);
  gdb_assert (probe->objfile->sf->sym_probe_fns != NULL);

  probe_fns = probe->objfile->sf->sym_probe_fns;
  n_args = probe_fns->sym_get_probe_argument_count (probe);

d662 1
a662 1
  return probe_fns->sym_evaluate_probe_argument (probe, n);
@


1.7
log
@	PR c++/13588:
	* NEWS: Update.
	* break-catch-throw.c (struct exception_catchpoint)
	<exception_rx, pattern>: New fields.
	(fetch_probe_arguments, dtor_exception_catchpoint)
	(check_status_exception_catchpoint)
	(print_one_detail_exception_catchpoint): New functions.
	(handle_gnu_v3_exceptions): Add "except_rx" argument.
	Compile regular expression if needed.
	(extract_exception_regexp): New function.
	(catch_exception_command_1): Use extract_exception_regexp.
	(compute_exception): Use fetch_probe_arguments.
	(initialize_throw_catchpoint_ops): Set dtor, print_one_detail,
	and check_status fields.
	* cp-abi.c (cplus_typename_from_type_info): New function.
	* cp-abi.h (cplus_typename_from_type_info): Declare.
	(struct cp_abi_ops) <get_typename_from_type_info>: New field.
	* gdb_regex.h (compile_rx_or_error): Declare.
	* gnu-v3-abi.c (gnuv3_get_typename_from_type_info): Update
	comment.
	(init_gnuv3_ops): Set get_type_from_type_info field.
	* probe.c (compile_rx_or_error): Move...
	* utils.c (compile_rx_or_error): ... here.
gdb/doc
	* gdb.texinfo (Set Catchpoints): Document regexp syntax for
	exception catchpoints.
gdb/testsuite
	* gdb.cp/exceptprint.exp: Add regexp catchpoint tests.
@
text
@d248 6
a253 3
  compile_rx_or_error (&prov_pat, provider, _("Invalid provider regexp"));
  compile_rx_or_error (&probe_pat, probe_name, _("Invalid probe regexp"));
  compile_rx_or_error (&obj_pat, objname, _("Invalid object file regexp"));
@


1.6
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a231 24
/* A helper function for collect_probes that compiles a regexp and
   throws an exception on error.  This installs a cleanup to free the
   resulting pattern on success.  If RX is NULL, this does nothing.  */

static void
compile_rx_or_error (regex_t *pattern, const char *rx, const char *message)
{
  int code;

  if (!rx)
    return;

  code = regcomp (pattern, rx, REG_NOSUB);
  if (code == 0)
    make_regfree_cleanup (pattern);
  else
    {
      char *err = get_regcomp_error (code, pattern);

      make_cleanup (xfree, err);
      error (("%s: %s"), message, err);
    }
}

@


1.5
log
@2012-07-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* probe.c (probe_safe_evaluate_at_pc): Rename variable `n_probes'.
	* stap-probe.c (compile_probe_arg): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2012 Free Software Foundation, Inc.
@


1.4
log
@2012-07-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* elfread.c (elf_get_probe_argument_count): Remove `objfile' argument.
	(elf_compile_to_ax): Likewise.
	* infrun.c (insert_exception_resume_from_probe): Likewise.
	(check_exception_resume): Remove `objfile' variable.
	* probe.c (find_probe_by_pc): Remove `objfile' argument.
	(struct probe_and_objfile, probe_and_objfile_s): Delete.
	(collect_probes): Adjust return value to `VEC (probe_p) *'.
	(compare_entries): Rename to...
	(compare_probes): ...this.  Adjust function to work with
	`struct probe *'.  Rename variables `ea' and `eb' to `pa' and `pb'
	respectively.
	(gen_ui_out_table_header_info): Adjust `probes' argument to be
	`VEC (probe_p) *'.
	(print_ui_out_info): Adjust argument to be `struct probe *'.
	(info_probes_for_ops): Adjust internal computations to use
	`VEC (probe_p) *'.
	(probe_safe_evaluate_at_pc): Refactor to not pass `objfile' anymore.
	* probe.h (struct probe_ops) <get_probe_argument_count, compile_to_ax,
	gen_info_probes_table_values>: Remove `objfile' argument.
	(struct probe) <objfile>: New field.
	(find_probe_by_pc): Remove `objfile' argument.
	* stap-probe.c (stap_parse_probe_arguments): Likewise.
	(stap_get_probe_argument_count): Likewise.
	(stap_get_arg): Likewise.
	(stap_evaluate_probe_argument): Likewise.
	(stap_compile_to_ax): Likewise.
	(compile_probe_arg): Refactor not to pass `objfile' anymore.
	(handle_stap_probe): Fill `objfile' field from `struct probe'.
	(stap_gen_info_probes_table_header): Remove `objfile' argument.
	* symfile.h (struct sym_probe_fns) <sym_evaluate_probe_argument,
	sym_compile_to_ax>: Likewise.
@
text
@d640 1
a640 1
  unsigned n_probes;
d651 1
a651 1
  n_probes = probe_fns->sym_get_probe_argument_count (probe);
d653 1
a653 1
  if (n >= n_probes)
@


1.3
log
@2012-05-07  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* probe.c (parse_probes): Move conditional to check for
	debuginfo files from here...
	* stap-probe.c (stap_get_probes): ... to here.
@
text
@d207 1
a207 1
find_probe_by_pc (CORE_ADDR pc, struct objfile **objfile_out)
d224 1
a224 4
	{
	  *objfile_out = objfile;
	  return probe;
	}
a231 15
/* A utility structure.  A VEC of these is built when handling "info
   probes".  */

struct probe_and_objfile
{
  /* The probe.  */
  struct probe *probe;

  /* The probe's objfile.  */
  struct objfile *objfile;
};

typedef struct probe_and_objfile probe_and_objfile_s;
DEF_VEC_O (probe_and_objfile_s);

d260 1
a260 1
static VEC (probe_and_objfile_s) *
d265 1
a265 1
  VEC (probe_and_objfile_s) *result = NULL;
d269 1
a269 1
  cleanup = make_cleanup (VEC_cleanup (probe_and_objfile_s), &result);
a294 2
	  probe_and_objfile_s entry;

d306 1
a306 3
	  entry.probe = probe;
	  entry.objfile = objfile;
	  VEC_safe_push (probe_and_objfile_s, result, &entry);
d315 1
a315 1
/* A qsort comparison function for probe_and_objfile_s objects.  */
d318 1
a318 1
compare_entries (const void *a, const void *b)
d320 2
a321 2
  const probe_and_objfile_s *ea = a;
  const probe_and_objfile_s *eb = b;
d324 1
a324 1
  v = strcmp (ea->probe->provider, eb->probe->provider);
d328 1
a328 1
  v = strcmp (ea->probe->name, eb->probe->name);
d332 1
a332 1
  if (ea->probe->address < eb->probe->address)
d334 1
a334 1
  if (ea->probe->address > eb->probe->address)
d337 1
a337 1
  return strcmp (ea->objfile->name, eb->objfile->name);
d344 1
a344 1
gen_ui_out_table_header_info (VEC (probe_and_objfile_s) *probes,
d373 1
a373 1
      probe_and_objfile_s *entry;
d377 1
a377 1
      for (jx = 0; VEC_iterate (probe_and_objfile_s, probes, jx, entry); ++jx)
d386 1
a386 1
	  if (entry->probe->pops != p)
d390 1
a390 2
	  p->gen_info_probes_table_values (entry->probe, entry->objfile,
					   &probe_fields);
d417 1
a417 1
   represented by ENTRY.  */
d420 1
a420 1
print_ui_out_info (probe_and_objfile_s *entry)
d431 2
a432 3
  gdb_assert (entry != NULL);
  gdb_assert (entry->probe != NULL);
  gdb_assert (entry->probe->pops != NULL);
d434 2
a435 2
  if (entry->probe->pops->gen_info_probes_table_header == NULL
      && entry->probe->pops->gen_info_probes_table_values == NULL)
d438 2
a439 2
  gdb_assert (entry->probe->pops->gen_info_probes_table_header != NULL
	      && entry->probe->pops->gen_info_probes_table_values != NULL);
d444 2
a445 3
  entry->probe->pops->gen_info_probes_table_header (&headings);
  entry->probe->pops->gen_info_probes_table_values (entry->probe,
						    entry->objfile, &values);
d493 1
a493 1
  char *provider, *probe = NULL, *objname = NULL;
d495 1
a495 1
  VEC (probe_and_objfile_s) *items;
d502 1
a502 1
  probe_and_objfile_s *entry;
d511 2
a512 2
      probe = extract_arg (&arg);
      if (probe)
d514 1
a514 1
	  make_cleanup (xfree, probe);
d542 2
a543 2
  items = collect_probes (objname, provider, probe, pops);
  make_cleanup (VEC_cleanup (probe_and_objfile_s), &items);
d546 1
a546 1
				       VEC_length (probe_and_objfile_s, items),
d549 3
a551 4
  if (!VEC_empty (probe_and_objfile_s, items))
    qsort (VEC_address (probe_and_objfile_s, items),
	   VEC_length (probe_and_objfile_s, items),
	   sizeof (probe_and_objfile_s), compare_entries);
d558 1
a558 1
  for (i = 0; VEC_iterate (probe_and_objfile_s, items, i, entry); ++i)
d560 3
a562 3
      size_name = max (strlen (entry->probe->name), size_name);
      size_provider = max (strlen (entry->probe->provider), size_provider);
      size_objname = max (strlen (entry->objfile->name), size_objname);
d578 1
a578 1
	gen_ui_out_table_header_info (items, po);
d581 1
a581 1
    gen_ui_out_table_header_info (items, pops);
d587 1
a587 1
  for (i = 0; VEC_iterate (probe_and_objfile_s, items, i, entry); ++i)
d593 2
a594 2
      ui_out_field_string (current_uiout, "provider", entry->probe->provider);
      ui_out_field_string (current_uiout, "name", entry->probe->name);
d596 2
a597 2
			      get_objfile_arch (entry->objfile),
			      entry->probe->address);
d606 2
a607 2
	    if (entry->probe->pops == po)
	      print_ui_out_info (entry);
d610 1
a610 1
	print_ui_out_info (entry);
d612 1
a612 1
      ui_out_field_string (current_uiout, "object", entry->objfile->name);
d618 1
a618 1
  any_found = !VEC_empty (probe_and_objfile_s, items);
d639 1
a639 1
  struct objfile *objfile;
d642 1
a642 1
  probe = find_probe_by_pc (get_frame_pc (frame), &objfile);
a644 1
  gdb_assert (objfile->sf && objfile->sf->sym_probe_fns);
d646 7
a652 3
  n_probes
    = objfile->sf->sym_probe_fns->sym_get_probe_argument_count (objfile,
								probe);
d656 1
a656 3
  return objfile->sf->sym_probe_fns->sym_evaluate_probe_argument (objfile,
								  probe,
								  n);
@


1.2
log
@2012-04-28  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* probe.c (compile_rx_or_error): Silence ARI warning about missing
	 gettext function on `error'.
@
text
@a122 3
	if (objfile->separate_debug_objfile_backlink != NULL)
	  continue;

@


1.1
log
@2012-04-27  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* Makefile.in (SFILES): Add `probe' and `stap-probe'.
	(COMMON_OBS): Likewise.
	(HFILES_NO_SRCDIR): Add `probe'.
	* NEWS: Mention support for static and SystemTap probes.
	* amd64-tdep.c (amd64_init_abi): Initializing proper fields used by
	SystemTap probes' arguments parser.
	* arm-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(arm_stap_is_single_operand): New function.
	(arm_stap_parse_special_token): Likewise.
	(arm_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* ax-gdb.c (require_rvalue): Removing static declaration.
	(gen_expr): Likewise.
	* ax-gdb.h (gen_expr): Declaring function.
	(require_rvalue): Likewise.
	* breakpoint.c: Include `gdb_regex.h' and `probe.h'.
	(bkpt_probe_breakpoint_ops): New variable.
	(momentary_breakpoint_from_master): Set the `probe' value.
	(add_location_to_breakpoint): Likewise.
	(break_command_1): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(bkpt_probe_insert_location): New function.
	(bkpt_probe_remove_location): Likewise.
	(bkpt_probe_create_sals_from_address): Likewise.
	(bkpt_probe_decode_linespec): Likewise.
	(tracepoint_probe_create_sals_from_address): Likewise.
	(tracepoint_probe_decode_linespec): Likewise.
	(tracepoint_probe_breakpoint_ops): New variable.
	(trace_command): Using proper breakpoint_ops according to the
	argument passed by the user in the command line.
	(initialize_breakpoint_ops): Initializing breakpoint_ops for
	static probes on breakpoints and tracepoints.
	* breakpoint.h (struct bp_location) <probe>: New field.
	* cli-utils.c (skip_spaces_const): New function.
	(extract_arg): Likewise.
	* cli-utils.h (skip_spaces_const): Likewise.
	(extract_arg): Likewise.
	* coffread.c (coff_sym_fns): Add `sym_probe_fns' value.
	* configure.ac: Append `stap-probe.o' to be generated when ELF
	support is present.
	* configure: Regenerate.
	* dbxread.c (aout_sym_fns): Add `sym_probe_fns' value.
	* elfread.c: Include `probe.h' and `arch-utils.h'.
	(probe_key): New variable.
	(elf_get_probes): New function.
	(elf_get_probe_argument_count): Likewise.
	(elf_evaluate_probe_argument): Likewise.
	(elf_compile_to_ax): Likewise.
	(elf_symfile_relocate_probe): Likewise.
	(stap_probe_key_free): Likewise.
	(elf_probe_fns): New variable.
	(elf_sym_fns): Add `sym_probe_fns' value.
	(elf_sym_fns_lazy_psyms): Likewise.
	(elf_sym_fns_gdb_index): Likewise.
	(_initialize_elfread): Initialize objfile cache for static
	probes.
	* gdb_vecs.h (struct probe): New forward declaration.
	(probe_p): New VEC declaration.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* gdbarch.sh (stap_integer_prefix): New variable.
	(stap_integer_suffix): Likewise.
	(stap_register_prefix): Likewise.
	(stap_register_suffix): Likewise.
	(stap_register_indirection_prefix): Likewise.
	(stap_register_indirection_suffix): Likewise.
	(stap_gdb_register_prefix): Likewise.
	(stap_gdb_register_suffix): Likewise.
	(stap_is_single_operand): New function.
	(stap_parse_special_token): Likewise.
	(struct stap_parse_info): Forward declaration.
	* i386-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	(i386_elf_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* i386-tdep.h (i386_stap_is_single_operand): New function.
	(i386_stap_parse_special_token): Likewise.
	* machoread.c (macho_sym_fns): Add `sym_probe_fns' value.
	* mipsread.c (ecoff_sym_fns): Likewise.
	* objfiles.c (objfile_relocate1): Support relocation for static
	probes.
	* parse.c (prefixify_expression): Remove static declaration.
	(initialize_expout): Likewise.
	(reallocate_expout): Likewise.
	* parser-defs.h (initialize_expout): Declare function.
	(reallocate_expout): Likewise.
	(prefixify_expression): Likewise.
	* ppc-linux-tdep.c: Including headers needed to perform the parsing
	of SystemTap probes' arguments.
	(ppc_stap_is_single_operand): New function.
	(ppc_stap_parse_special_token): Likewise.
	(ppc_linux_init_abi): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* probe.c: New file, for generic statically defined probe support.
	* probe.h: Likewise.
	* s390-tdep.c: Including headers needed to perform the parsing of
	SystemTap probes' arguments.
	(s390_stap_is_single_operand): New function.
	(s390_gdbarch_init): Initializing proper fields used by SystemTap
	probes' arguments parser.
	* somread.c (som_sym_fns): Add `sym_probe_fns' value.
	* stap-probe.c: New file, for SystemTap probe support.
	* stap-probe.h: Likewise.
	* symfile.h: Include `gdb_vecs.h'.
	(struct sym_probe_fns): New struct.
	(struct sym_fns) <sym_probe_fns>: New field.
	* symtab.c (init_sal): Initialize `probe' field.
	* symtab.h (struct probe): Forward declaration.
	(struct symtab_and_line) <probe>: New field.
	* tracepoint.c (start_tracing): Adjust semaphore on breakpoints
	locations.
	(stop_tracing): Likewise.
	* xcoffread.c (xcoff_sym_fns): Add `sym_probe_fns' value.
@
text
@d273 1
a273 1
      error ("%s: %s", message, err);
@

