head	1.185;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.179
	gdb_7_6-2013-04-26-release:1.179
	gdb_7_6-branch:1.179.0.2
	gdb_7_6-2013-03-12-branchpoint:1.179
	gdb_7_5_1-2012-11-29-release:1.165
	gdb_7_5-2012-08-17-release:1.165
	gdb_7_5-branch:1.165.0.2
	gdb_7_5-2012-07-18-branchpoint:1.165
	gdb_7_4_1-2012-04-26-release:1.155.2.1
	gdb_7_4-2012-01-24-release:1.155.2.1
	gdb_7_4-branch:1.155.0.2
	gdb_7_4-2011-12-13-branchpoint:1.155
	gdb_7_3_1-2011-09-04-release:1.149
	gdb_7_3-2011-07-26-release:1.149
	gdb_7_3-branch:1.149.0.2
	gdb_7_3-2011-04-01-branchpoint:1.149
	gdb_7_2-2010-09-02-release:1.137
	gdb_7_2-branch:1.137.0.2
	gdb_7_2-2010-07-07-branchpoint:1.137
	gdb_7_1-2010-03-18-release:1.127
	gdb_7_1-branch:1.127.0.2
	gdb_7_1-2010-02-18-branchpoint:1.127
	gdb_7_0_1-2009-12-22-release:1.119.4.3
	gdb_7_0-2009-10-06-release:1.119.4.3
	gdb_7_0-branch:1.119.0.4
	gdb_7_0-2009-09-16-branchpoint:1.119
	arc-sim-20090309:1.80
	msnyder-checkpoint-072509-branch:1.119.0.2
	msnyder-checkpoint-072509-branchpoint:1.119
	arc-insight_6_8-branch:1.80.0.6
	arc-insight_6_8-branchpoint:1.80
	insight_6_8-branch:1.80.0.4
	insight_6_8-branchpoint:1.80
	reverse-20081226-branch:1.102.0.4
	reverse-20081226-branchpoint:1.102
	multiprocess-20081120-branch:1.102.0.2
	multiprocess-20081120-branchpoint:1.102
	reverse-20080930-branch:1.98.0.2
	reverse-20080930-branchpoint:1.98
	reverse-20080717-branch:1.85.0.4
	reverse-20080717-branchpoint:1.85
	msnyder-reverse-20080609-branch:1.85.0.2
	msnyder-reverse-20080609-branchpoint:1.85
	drow-reverse-20070409-branch:1.68.0.2
	drow-reverse-20070409-branchpoint:1.68
	gdb_6_8-2008-03-27-release:1.80
	gdb_6_8-branch:1.80.0.2
	gdb_6_8-2008-02-26-branchpoint:1.80
	gdb_6_7_1-2007-10-29-release:1.71
	gdb_6_7-2007-10-10-release:1.71
	gdb_6_7-branch:1.71.0.2
	gdb_6_7-2007-09-07-branchpoint:1.71
	insight_6_6-20070208-release:1.64
	gdb_6_6-2006-12-18-release:1.64
	gdb_6_6-branch:1.64.0.2
	gdb_6_6-2006-11-15-branchpoint:1.64
	insight_6_5-20061003-release:1.61
	gdb-csl-symbian-6_4_50_20060226-12:1.61
	gdb-csl-sourcerygxx-3_4_4-25:1.59
	nickrob-async-20060828-mergepoint:1.63
	gdb-csl-symbian-6_4_50_20060226-11:1.61
	gdb-csl-sourcerygxx-4_1-17:1.61.2.2
	gdb-csl-20060226-branch-local-2:1.61.2.2
	gdb-csl-sourcerygxx-4_1-14:1.61.2.2
	gdb-csl-sourcerygxx-4_1-13:1.61.2.2
	gdb-csl-sourcerygxx-4_1-12:1.61.2.2
	gdb-csl-sourcerygxx-3_4_4-21:1.61.2.2
	gdb_6_5-20060621-release:1.61
	gdb-csl-sourcerygxx-4_1-9:1.61.2.2
	gdb-csl-sourcerygxx-4_1-8:1.61.2.2
	gdb-csl-sourcerygxx-4_1-7:1.61.2.2
	gdb-csl-arm-2006q1-6:1.61.2.2
	gdb-csl-sourcerygxx-4_1-6:1.61.2.2
	gdb-csl-symbian-6_4_50_20060226-10:1.61
	gdb-csl-symbian-6_4_50_20060226-9:1.61
	gdb-csl-symbian-6_4_50_20060226-8:1.61
	gdb-csl-coldfire-4_1-11:1.61.2.2
	gdb-csl-sourcerygxx-3_4_4-19:1.61.2.2
	gdb-csl-coldfire-4_1-10:1.61.2.2
	gdb_6_5-branch:1.61.0.16
	gdb_6_5-2006-05-14-branchpoint:1.61
	gdb-csl-sourcerygxx-4_1-5:1.61.2.2
	nickrob-async-20060513-branch:1.61.0.14
	nickrob-async-20060513-branchpoint:1.61
	gdb-csl-sourcerygxx-4_1-4:1.61.2.2
	msnyder-reverse-20060502-branch:1.61.0.12
	msnyder-reverse-20060502-branchpoint:1.61
	gdb-csl-morpho-4_1-4:1.61
	gdb-csl-sourcerygxx-3_4_4-17:1.61
	readline_5_1-import-branch:1.61.0.10
	readline_5_1-import-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.61
	gdb-csl-symbian-20060226-branch:1.61.0.8
	gdb-csl-symbian-20060226-branchpoint:1.61
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.61
	msnyder-reverse-20060331-branch:1.61.0.6
	msnyder-reverse-20060331-branchpoint:1.61
	gdb-csl-available-20060303-branch:1.61.0.4
	gdb-csl-available-20060303-branchpoint:1.61
	gdb-csl-20060226-branch:1.61.0.2
	gdb-csl-20060226-branchpoint:1.61
	gdb_6_4-20051202-release:1.59
	msnyder-fork-checkpoint-branch:1.59.0.8
	msnyder-fork-checkpoint-branchpoint:1.59
	gdb-csl-gxxpro-6_3-branch:1.59.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.59
	gdb_6_4-branch:1.59.0.4
	gdb_6_4-2005-11-01-branchpoint:1.59
	gdb-csl-arm-20051020-branch:1.59.0.2
	gdb-csl-arm-20051020-branchpoint:1.59
	msnyder-tracepoint-checkpoint-branch:1.55.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.55
	gdb-csl-arm-20050325-2005-q1b:1.54
	gdb-csl-arm-20050325-2005-q1a:1.54
	csl-arm-20050325-branch:1.54.0.2
	csl-arm-20050325-branchpoint:1.54
	gdb-post-i18n-errorwarning-20050211:1.53
	gdb-pre-i18n-errorwarning-20050211:1.52
	gdb_6_3-20041109-release:1.42
	gdb_6_3-branch:1.42.0.2
	gdb_6_3-20041019-branchpoint:1.42
	drow_intercu-merge-20040921:1.42
	drow_intercu-merge-20040915:1.42
	jimb-gdb_6_2-e500-branch:1.41.0.6
	jimb-gdb_6_2-e500-branchpoint:1.41
	gdb_6_2-20040730-release:1.41
	gdb_6_2-branch:1.41.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.41
	gdb_6_1_1-20040616-release:1.40
	gdb_6_1-2004-04-05-release:1.40
	drow_intercu-merge-20040402:1.40
	drow_intercu-merge-20040327:1.40
	ezannoni_pie-20040323-branch:1.40.0.8
	ezannoni_pie-20040323-branchpoint:1.40
	cagney_tramp-20040321-mergepoint:1.40
	cagney_tramp-20040309-branch:1.40.0.6
	cagney_tramp-20040309-branchpoint:1.40
	gdb_6_1-branch:1.40.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.40
	drow_intercu-20040221-branch:1.40.0.2
	drow_intercu-20040221-branchpoint:1.40
	cagney_bfdfile-20040213-branch:1.39.0.4
	cagney_bfdfile-20040213-branchpoint:1.39
	drow-cplus-merge-20040208:1.39
	carlton_dictionary-20040126-merge:1.39
	cagney_bigcore-20040122-branch:1.39.0.2
	cagney_bigcore-20040122-branchpoint:1.39
	drow-cplus-merge-20040113:1.39
	drow-cplus-merge-20031224:1.39
	drow-cplus-merge-20031220:1.39
	carlton_dictionary-20031215-merge:1.39
	drow-cplus-merge-20031214:1.39
	carlton-dictionary-20031111-merge:1.38
	gdb_6_0-2003-10-04-release:1.30
	kettenis_sparc-20030918-branch:1.36.0.4
	kettenis_sparc-20030918-branchpoint:1.36
	carlton_dictionary-20030917-merge:1.36
	ezannoni_pie-20030916-branchpoint:1.36
	ezannoni_pie-20030916-branch:1.36.0.2
	cagney_x86i386-20030821-branch:1.31.0.2
	cagney_x86i386-20030821-branchpoint:1.31
	carlton_dictionary-20030805-merge:1.31
	carlton_dictionary-20030627-merge:1.30
	gdb_6_0-branch:1.30.0.14
	gdb_6_0-2003-06-23-branchpoint:1.30
	jimb-ppc64-linux-20030613-branch:1.30.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.30
	cagney_convert-20030606-branch:1.30.0.10
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.30.0.8
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.30.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.30
	carlton_dictionary-20030523-merge:1.30
	cagney_fileio-20030521-branch:1.30.0.4
	cagney_fileio-20030521-branchpoint:1.30
	kettenis_i386newframe-20030517-mergepoint:1.30
	jimb-ppc64-linux-20030509-branch:1.30.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	kettenis_i386newframe-20030419-branch:1.28.0.12
	kettenis_i386newframe-20030419-branchpoint:1.28
	carlton_dictionary-20030416-merge:1.28
	cagney_frameaddr-20030409-mergepoint:1.28
	kettenis_i386newframe-20030406-branch:1.28.0.10
	kettenis_i386newframe-20030406-branchpoint:1.28
	cagney_frameaddr-20030403-branchpoint:1.28
	cagney_frameaddr-20030403-branch:1.28.0.8
	cagney_framebase-20030330-mergepoint:1.28
	cagney_framebase-20030326-branch:1.28.0.6
	cagney_framebase-20030326-branchpoint:1.28
	cagney_lazyid-20030317-branch:1.28.0.4
	cagney_lazyid-20030317-branchpoint:1.28
	kettenis-i386newframe-20030316-mergepoint:1.28
	offbyone-20030313-branch:1.28.0.2
	offbyone-20030313-branchpoint:1.28
	kettenis-i386newframe-20030308-branch:1.27.0.6
	kettenis-i386newframe-20030308-branchpoint:1.27
	carlton_dictionary-20030305-merge:1.27
	cagney_offbyone-20030303-branch:1.27.0.4
	cagney_offbyone-20030303-branchpoint:1.27
	carlton_dictionary-20030207-merge:1.27
	interps-20030203-mergepoint:1.27
	interps-20030202-branch:1.27.0.2
	interps-20030202-branchpoint:1.27
	cagney-unwind-20030108-branch:1.26.0.2
	cagney-unwind-20030108-branchpoint:1.26
	carlton_dictionary-20021223-merge:1.25
	gdb_5_3-2002-12-12-release:1.23.6.1
	carlton_dictionary-20021115-merge:1.24
	kseitz_interps-20021105-merge:1.24
	kseitz_interps-20021103-merge:1.24
	drow-cplus-merge-20021020:1.24
	drow-cplus-merge-20021025:1.24
	carlton_dictionary-20021025-merge:1.24
	carlton_dictionary-20021011-merge:1.24
	drow-cplus-branch:1.24.0.2
	drow-cplus-branchpoint:1.24
	kseitz_interps-20020930-merge:1.24
	carlton_dictionary-20020927-merge:1.24
	carlton_dictionary-branch:1.23.0.8
	carlton_dictionary-20020920-branchpoint:1.23
	gdb_5_3-branch:1.23.0.6
	gdb_5_3-2002-09-04-branchpoint:1.23
	kseitz_interps-20020829-merge:1.23
	cagney_sysregs-20020825-branch:1.23.0.4
	cagney_sysregs-20020825-branchpoint:1.23
	readline_4_3-import-branch:1.23.0.2
	readline_4_3-import-branchpoint:1.23
	gdb_5_2_1-2002-07-23-release:1.19
	kseitz_interps-20020528-branch:1.22.0.6
	kseitz_interps-20020528-branchpoint:1.22
	cagney_regbuf-20020515-branch:1.22.0.4
	cagney_regbuf-20020515-branchpoint:1.22
	jimb-macro-020506-branch:1.22.0.2
	jimb-macro-020506-branchpoint:1.22
	gdb_5_2-2002-04-29-release:1.19
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.19
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.8
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.6
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.4
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.13.0.2
	dberlin-typesystem-branchpoint:1.13
	gdb-post-ptid_t-2001-05-03:1.13
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.6
	gdb-premipsmulti-2000-06-06-branch:1.6.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb-post-params-removal-2000-06-04:1.6
	gdb-pre-params-removal-2000-06-04:1.6
	gdb-post-params-removal-2000-05-28:1.6
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.3
	gdb_4_18_2-2000-05-18-release:1.3
	gdb_4_95_1-2000-05-11-snapshot:1.3
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.4
	gdb-1999-09-28:1.1.1.4
	gdb-1999-09-21:1.1.1.4
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.4
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.3
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.185
date	2013.08.02.16.41.08;	author tromey;	state Exp;
branches;
next	1.184;

1.184
date	2013.05.14.20.37.57;	author tromey;	state Exp;
branches;
next	1.183;

1.183
date	2013.05.13.16.51.51;	author tromey;	state Exp;
branches;
next	1.182;

1.182
date	2013.04.15.17.36.13;	author tromey;	state Exp;
branches;
next	1.181;

1.181
date	2013.03.25.17.26.18;	author tromey;	state Exp;
branches;
next	1.180;

1.180
date	2013.03.20.18.35.22;	author tromey;	state Exp;
branches;
next	1.179;

1.179
date	2013.03.12.17.39.43;	author kseitz;	state Exp;
branches;
next	1.178;

1.178
date	2013.02.14.12.43.45;	author palves;	state Exp;
branches;
next	1.177;

1.177
date	2013.01.25.22.31.43;	author sivachandra;	state Exp;
branches;
next	1.176;

1.176
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.175;

1.175
date	2012.11.29.07.55.10;	author qiyao;	state Exp;
branches;
next	1.174;

1.174
date	2012.11.27.07.59.11;	author qiyao;	state Exp;
branches;
next	1.173;

1.173
date	2012.11.02.00.14.37;	author qiyao;	state Exp;
branches;
next	1.172;

1.172
date	2012.09.21.09.24.41;	author siddhesh;	state Exp;
branches;
next	1.171;

1.171
date	2012.08.16.07.36.19;	author qiyao;	state Exp;
branches;
next	1.170;

1.170
date	2012.08.13.01.02.07;	author qiyao;	state Exp;
branches;
next	1.169;

1.169
date	2012.08.13.00.54.04;	author qiyao;	state Exp;
branches;
next	1.168;

1.168
date	2012.08.08.21.17.04;	author devans;	state Exp;
branches;
next	1.167;

1.167
date	2012.07.19.15.38.16;	author tromey;	state Exp;
branches;
next	1.166;

1.166
date	2012.07.19.15.33.24;	author tromey;	state Exp;
branches;
next	1.165;

1.165
date	2012.07.09.14.20.51;	author tromey;	state Exp;
branches;
next	1.164;

1.164
date	2012.07.06.14.48.47;	author tromey;	state Exp;
branches;
next	1.163;

1.163
date	2012.06.27.18.08.40;	author tromey;	state Exp;
branches;
next	1.162;

1.162
date	2012.05.21.19.47.53;	author tromey;	state Exp;
branches;
next	1.161;

1.161
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.160;

1.160
date	2012.05.16.14.35.03;	author macro;	state Exp;
branches;
next	1.159;

1.159
date	2012.02.21.13.48.59;	author xgsa;	state Exp;
branches;
next	1.158;

1.158
date	2012.02.07.04.48.19;	author devans;	state Exp;
branches;
next	1.157;

1.157
date	2012.01.09.20.27.48;	author kseitz;	state Exp;
branches;
next	1.156;

1.156
date	2012.01.04.08.17.01;	author brobecke;	state Exp;
branches;
next	1.155;

1.155
date	2011.10.14.20.22.16;	author kseitz;	state Exp;
branches
	1.155.2.1;
next	1.154;

1.154
date	2011.10.09.19.41.16;	author jkratoch;	state Exp;
branches;
next	1.153;

1.153
date	2011.09.08.14.54.19;	author jkratoch;	state Exp;
branches;
next	1.152;

1.152
date	2011.07.27.19.31.30;	author jkratoch;	state Exp;
branches;
next	1.151;

1.151
date	2011.06.17.20.35.09;	author tromey;	state Exp;
branches;
next	1.150;

1.150
date	2011.06.17.20.24.22;	author tromey;	state Exp;
branches;
next	1.149;

1.149
date	2011.03.28.20.21.03;	author jkratoch;	state Exp;
branches;
next	1.148;

1.148
date	2011.03.04.20.07.22;	author bauermann;	state Exp;
branches;
next	1.147;

1.147
date	2011.02.28.23.47.39;	author msnyder;	state Exp;
branches;
next	1.146;

1.146
date	2011.01.12.16.16.21;	author jkratoch;	state Exp;
branches;
next	1.145;

1.145
date	2011.01.07.19.36.16;	author msnyder;	state Exp;
branches;
next	1.144;

1.144
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.143;

1.143
date	2011.01.01.15.33.03;	author brobecke;	state Exp;
branches;
next	1.142;

1.142
date	2010.11.05.14.31.27;	author kwerner;	state Exp;
branches;
next	1.141;

1.141
date	2010.11.03.13.49.37;	author kwerner;	state Exp;
branches;
next	1.140;

1.140
date	2010.10.19.20.53.14;	author swagiaal;	state Exp;
branches;
next	1.139;

1.139
date	2010.08.11.16.48.26;	author kwerner;	state Exp;
branches;
next	1.138;

1.138
date	2010.07.21.14.59.05;	author swagiaal;	state Exp;
branches;
next	1.137;

1.137
date	2010.07.07.16.15.15;	author bauermann;	state Exp;
branches;
next	1.136;

1.136
date	2010.06.07.16.11.31;	author swagiaal;	state Exp;
branches;
next	1.135;

1.135
date	2010.05.21.20.56.49;	author tromey;	state Exp;
branches;
next	1.134;

1.134
date	2010.05.14.18.35.11;	author msnyder;	state Exp;
branches;
next	1.133;

1.133
date	2010.05.11.16.54.28;	author tromey;	state Exp;
branches;
next	1.132;

1.132
date	2010.05.10.20.20.21;	author tromey;	state Exp;
branches;
next	1.131;

1.131
date	2010.05.07.14.46.26;	author swagiaal;	state Exp;
branches;
next	1.130;

1.130
date	2010.05.06.18.26.13;	author msnyder;	state Exp;
branches;
next	1.129;

1.129
date	2010.03.15.17.29.36;	author swagiaal;	state Exp;
branches;
next	1.128;

1.128
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.127;

1.127
date	2010.02.08.20.55.42;	author tromey;	state Exp;
branches;
next	1.126;

1.126
date	2010.01.26.16.53.43;	author tromey;	state Exp;
branches;
next	1.125;

1.125
date	2010.01.18.20.54.33;	author tromey;	state Exp;
branches;
next	1.124;

1.124
date	2010.01.01.07.31.31;	author brobecke;	state Exp;
branches;
next	1.123;

1.123
date	2009.11.10.22.17.58;	author kseitz;	state Exp;
branches;
next	1.122;

1.122
date	2009.10.06.23.27.05;	author muller;	state Exp;
branches;
next	1.121;

1.121
date	2009.09.29.00.48.31;	author uweigand;	state Exp;
branches;
next	1.120;

1.120
date	2009.09.22.17.39.53;	author tromey;	state Exp;
branches;
next	1.119;

1.119
date	2009.07.02.17.04.22;	author uweigand;	state Exp;
branches
	1.119.4.1;
next	1.118;

1.118
date	2009.07.02.12.57.14;	author uweigand;	state Exp;
branches;
next	1.117;

1.117
date	2009.07.02.12.20.17;	author uweigand;	state Exp;
branches;
next	1.116;

1.116
date	2009.07.02.12.11.19;	author uweigand;	state Exp;
branches;
next	1.115;

1.115
date	2009.06.29.13.24.41;	author uweigand;	state Exp;
branches;
next	1.114;

1.114
date	2009.06.24.16.45.49;	author uweigand;	state Exp;
branches;
next	1.113;

1.113
date	2009.06.23.16.37.18;	author brobecke;	state Exp;
branches;
next	1.112;

1.112
date	2009.06.17.18.47.35;	author uweigand;	state Exp;
branches;
next	1.111;

1.111
date	2009.06.17.18.43.24;	author uweigand;	state Exp;
branches;
next	1.110;

1.110
date	2009.06.11.16.49.47;	author tromey;	state Exp;
branches;
next	1.109;

1.109
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.108;

1.108
date	2009.03.21.03.03.53;	author bauermann;	state Exp;
branches;
next	1.107;

1.107
date	2009.03.20.22.00.11;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2009.02.21.16.14.47;	author palves;	state Exp;
branches;
next	1.105;

1.105
date	2009.01.15.15.38.07;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.103;

1.103
date	2008.12.28.14.14.19;	author jkratoch;	state Exp;
branches;
next	1.102;

1.102
date	2008.11.04.15.32.54;	author drow;	state Exp;
branches;
next	1.101;

1.101
date	2008.10.28.17.19.56;	author tromey;	state Exp;
branches;
next	1.100;

1.100
date	2008.10.08.12.49.12;	author jkratoch;	state Exp;
branches;
next	1.99;

1.99
date	2008.10.02.22.06.07;	author jkratoch;	state Exp;
branches;
next	1.98;

1.98
date	2008.09.11.14.27.34;	author uweigand;	state Exp;
branches;
next	1.97;

1.97
date	2008.09.11.14.22.32;	author uweigand;	state Exp;
branches;
next	1.96;

1.96
date	2008.09.11.14.20.15;	author uweigand;	state Exp;
branches;
next	1.95;

1.95
date	2008.09.11.14.17.58;	author uweigand;	state Exp;
branches;
next	1.94;

1.94
date	2008.09.11.14.16.51;	author uweigand;	state Exp;
branches;
next	1.93;

1.93
date	2008.09.11.14.15.01;	author uweigand;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.11.14.14.20;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2008.09.11.14.13.46;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.11.14.12.57;	author uweigand;	state Exp;
branches;
next	1.89;

1.89
date	2008.09.11.14.12.15;	author uweigand;	state Exp;
branches;
next	1.88;

1.88
date	2008.09.11.14.11.40;	author uweigand;	state Exp;
branches;
next	1.87;

1.87
date	2008.09.11.14.10.24;	author uweigand;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.21.20.13.08;	author uweigand;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.06.20.58.08;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.83;

1.83
date	2008.04.22.11.03.41;	author corinna;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.22.06.53.18;	author deuling;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.21.15.02.37;	author drow;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.04.00.23.04;	author devans;	state Exp;
branches;
next	1.79;

1.79
date	2008.01.30.18.46.08;	author brobecke;	state Exp;
branches;
next	1.78;

1.78
date	2008.01.30.07.31.07;	author muller;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.18.17.07.39;	author deuling;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.07.22.33.57;	author bauermann;	state Exp;
branches;
next	1.75;

1.75
date	2008.01.03.04.11.15;	author brobecke;	state Exp;
branches;
next	1.74;

1.74
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.73;

1.73
date	2007.10.25.18.01.58;	author bauermann;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.12.15.34.45;	author uweigand;	state Exp;
branches;
next	1.71;

1.71
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.13.17.11.09;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2007.06.05.22.47.50;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2007.02.08.21.00.29;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.66;

1.66
date	2007.01.04.21.59.10;	author drow;	state Exp;
branches;
next	1.65;

1.65
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.10.03.17.53;	author drow;	state Exp;
branches;
next	1.63;

1.63
date	2006.07.25.04.24.50;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2006.07.20.22.50.07;	author drow;	state Exp;
branches;
next	1.61;

1.61
date	2006.02.18.20.47.54;	author fnf;	state Exp;
branches
	1.61.2.1
	1.61.14.1;
next	1.60;

1.60
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.59;

1.59
date	2005.09.20.06.25.34;	author woodzltc;	state Exp;
branches;
next	1.58;

1.58
date	2005.07.06.06.52.25;	author woodzltc;	state Exp;
branches;
next	1.57;

1.57
date	2005.06.28.20.48.14;	author kettenis;	state Exp;
branches;
next	1.56;

1.56
date	2005.06.13.07.23.15;	author woodzltc;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.26.20.48.58;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.08.14.35.17;	author nathan;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.11.04.05.46;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.09.00.04.29;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.07.23.51.03;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2005.02.07.17.06.29;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2005.02.07.00.09.53;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.02.22.34.34;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.02.00.20.02;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.12.21.45.06;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.11.10.18.52.23;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.09.14.43.25;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.10.29.20.23.06;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.29.10.12.23;	author dsl;	state Exp;
branches;
next	1.41;

1.41
date	2004.04.08.21.18.12;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.18.04.22.35;	author jimb;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.25.16.39.38;	author carlton;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.25.08.40.45;	author hilfingr;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.13.21.31.33;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.09.23.09.37;	author dsl;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.09.16.51.54;	author dsl;	state Exp;
branches;
next	1.31;

1.31
date	2003.07.07.14.36.57;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.04.30.01.27.53;	author fedor;	state Exp;
branches
	1.30.8.1;
next	1.29;

1.29
date	2003.04.21.16.48.37;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.12.22.39.15;	author cagney;	state Exp;
branches
	1.28.12.1;
next	1.27;

1.27
date	2003.01.14.00.49.03;	author cagney;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	2003.01.02.14.27.26;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.29.19.15.14;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.09.25.20.30.37;	author cagney;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2002.08.01.17.18.32;	author cagney;	state Exp;
branches
	1.23.6.1
	1.23.8.1;
next	1.22;

1.22
date	2002.04.12.22.54.17;	author msnyder;	state Exp;
branches
	1.22.6.1;
next	1.21;

1.21
date	2002.03.16.20.51.44;	author schauer;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.16.02.57.42;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.04.17.51.38;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.25.22.24.38;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.10.23.05.00;	author fnf;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.12.21.20.18;	author jimb;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.10.20.15.13;	author cagney;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.16.01.58.07;	author cagney;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.27.00.19.09;	author jimb;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.03.19.23.31.41;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.07.02.57.08;	author jtc;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.30.15.32.51;	author taylor;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.01.23.50.17;	author davea;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.12.41.48;	author phdm;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.18.43.41;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.04.04.53.49;	author dberlin;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.14.17.01.04;	author ezannoni;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.00;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.155.2.1
date	2012.01.06.04.43.11;	author brobecke;	state Exp;
branches;
next	;

1.119.4.1
date	2009.09.22.17.38.30;	author tromey;	state Exp;
branches;
next	1.119.4.2;

1.119.4.2
date	2009.09.29.00.49.18;	author uweigand;	state Exp;
branches;
next	1.119.4.3;

1.119.4.3
date	2009.09.29.18.59.39;	author uweigand;	state Exp;
branches;
next	;

1.61.2.1
date	2006.05.03.01.51.29;	author pbrook;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2006.05.03.16.30.56;	author pbrook;	state Exp;
branches;
next	;

1.61.14.1
date	2006.08.28.07.48.49;	author nickrob;	state Exp;
branches;
next	;

1.40.2.1
date	2004.09.16.17.01.03;	author drow;	state Exp;
branches;
next	;

1.30.8.1
date	2003.06.03.20.54.34;	author cagney;	state Exp;
branches;
next	;

1.28.12.1
date	2003.05.04.11.37.40;	author kettenis;	state Exp;
branches;
next	;

1.27.6.1
date	2003.03.16.14.01.48;	author kettenis;	state Exp;
branches;
next	;

1.24.2.1
date	2003.12.14.20.27.12;	author drow;	state Exp;
branches;
next	;

1.23.6.1
date	2002.09.25.20.43.21;	author cagney;	state Exp;
branches;
next	;

1.23.8.1
date	2002.09.27.20.03.05;	author carlton;	state Exp;
branches;
next	1.23.8.2;

1.23.8.2
date	2002.11.23.00.42.54;	author carlton;	state Exp;
branches;
next	1.23.8.3;

1.23.8.3
date	2002.12.23.19.38.21;	author carlton;	state Exp;
branches;
next	1.23.8.4;

1.23.8.4
date	2003.01.21.01.02.29;	author carlton;	state Exp;
branches;
next	1.23.8.5;

1.23.8.5
date	2003.01.25.01.04.30;	author carlton;	state Exp;
branches;
next	1.23.8.6;

1.23.8.6
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.23.8.7;

1.23.8.7
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.23.8.8;

1.23.8.8
date	2003.05.01.00.46.47;	author carlton;	state Exp;
branches;
next	1.23.8.9;

1.23.8.9
date	2003.05.08.01.10.52;	author carlton;	state Exp;
branches;
next	1.23.8.10;

1.23.8.10
date	2003.08.05.17.13.05;	author carlton;	state Exp;
branches;
next	1.23.8.11;

1.23.8.11
date	2003.09.17.21.28.17;	author carlton;	state Exp;
branches;
next	1.23.8.12;

1.23.8.12
date	2003.09.20.00.32.31;	author carlton;	state Exp;
branches;
next	1.23.8.13;

1.23.8.13
date	2003.11.11.23.50.42;	author carlton;	state Exp;
branches;
next	1.23.8.14;

1.23.8.14
date	2003.12.16.00.00.30;	author carlton;	state Exp;
branches;
next	;

1.22.6.1
date	2002.08.09.18.34.24;	author kseitz;	state Exp;
branches;
next	1.22.6.2;

1.22.6.2
date	2002.10.01.00.46.07;	author kseitz;	state Exp;
branches;
next	;

1.13.2.1
date	2001.07.06.19.16.59;	author dberlin;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.00;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.06.07.19.17.17;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.05.51;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.08.23.59.08;	author shebs;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.10.12.04.37.20;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.19.02.46.35;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.12.14.01.05.30;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.185
log
@fix PR symtab/15719

This patch fixes PR symtab/15719.

The bug is that "watch -location" crashes on a certain expression.

The problem is that fetch_subexp_value is catching an exception.
For ordinary watchpoints this is ok; but for location watchpoints,
it is better for the exception to propagate.

Built and regtested on x86-64 Fedora 18.
New test case included.

	PR symtab/15719:
	* breakpoint.c (update_watchpoint, watchpoint_check)
	(watch_command_1): Update.
	* eval.c (fetch_subexp_value): Add "preserve_errors"
	parameter.
	* ppc-linux-nat.c (check_condition): Update.
	* value.h (fetch_subexp_value): Update.

	* gdb.base/watchpoint.c (struct foo5): New.
	(nullptr): New global.
	* gdb.base/watchpoint.exp (test_watch_location): Add test.
@
text
@/* Evaluate expressions for GDB.

   Copyright (C) 1986-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "gdb_string.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "value.h"
#include "expression.h"
#include "target.h"
#include "frame.h"
#include "language.h"		/* For CAST_IS_CONVERSION.  */
#include "f-lang.h"		/* For array bound stuff.  */
#include "cp-abi.h"
#include "infcall.h"
#include "objc-lang.h"
#include "block.h"
#include "parser-defs.h"
#include "cp-support.h"
#include "ui-out.h"
#include "exceptions.h"
#include "regcache.h"
#include "user-regs.h"
#include "valprint.h"
#include "gdb_obstack.h"
#include "objfiles.h"
#include "python/python.h"

#include "gdb_assert.h"

#include <ctype.h>

/* This is defined in valops.c */
extern int overload_resolution;

/* Prototypes for local functions.  */

static struct value *evaluate_subexp_for_sizeof (struct expression *, int *);

static struct value *evaluate_subexp_for_address (struct expression *,
						  int *, enum noside);

static struct value *evaluate_struct_tuple (struct value *,
					    struct expression *, int *,
					    enum noside, int);

static LONGEST init_array_element (struct value *, struct value *,
				   struct expression *, int *, enum noside,
				   LONGEST, LONGEST);

struct value *
evaluate_subexp (struct type *expect_type, struct expression *exp,
		 int *pos, enum noside noside)
{
  return (*exp->language_defn->la_exp_desc->evaluate_exp) 
    (expect_type, exp, pos, noside);
}

/* Parse the string EXP as a C expression, evaluate it,
   and return the result as a number.  */

CORE_ADDR
parse_and_eval_address (const char *exp)
{
  struct expression *expr = parse_expression (exp);
  CORE_ADDR addr;
  struct cleanup *old_chain =
    make_cleanup (free_current_contents, &expr);

  addr = value_as_address (evaluate_expression (expr));
  do_cleanups (old_chain);
  return addr;
}

/* Like parse_and_eval_address, but treats the value of the expression
   as an integer, not an address, returns a LONGEST, not a CORE_ADDR.  */
LONGEST
parse_and_eval_long (const char *exp)
{
  struct expression *expr = parse_expression (exp);
  LONGEST retval;
  struct cleanup *old_chain =
    make_cleanup (free_current_contents, &expr);

  retval = value_as_long (evaluate_expression (expr));
  do_cleanups (old_chain);
  return (retval);
}

struct value *
parse_and_eval (const char *exp)
{
  struct expression *expr = parse_expression (exp);
  struct value *val;
  struct cleanup *old_chain =
    make_cleanup (free_current_contents, &expr);

  val = evaluate_expression (expr);
  do_cleanups (old_chain);
  return val;
}

/* Parse up to a comma (or to a closeparen)
   in the string EXPP as an expression, evaluate it, and return the value.
   EXPP is advanced to point to the comma.  */

struct value *
parse_to_comma_and_eval (const char **expp)
{
  struct expression *expr = parse_exp_1 (expp, 0, (struct block *) 0, 1);
  struct value *val;
  struct cleanup *old_chain =
    make_cleanup (free_current_contents, &expr);

  val = evaluate_expression (expr);
  do_cleanups (old_chain);
  return val;
}

/* Evaluate an expression in internal prefix form
   such as is constructed by parse.y.

   See expression.h for info on the format of an expression.  */

struct value *
evaluate_expression (struct expression *exp)
{
  int pc = 0;

  return evaluate_subexp (NULL_TYPE, exp, &pc, EVAL_NORMAL);
}

/* Evaluate an expression, avoiding all memory references
   and getting a value whose type alone is correct.  */

struct value *
evaluate_type (struct expression *exp)
{
  int pc = 0;

  return evaluate_subexp (NULL_TYPE, exp, &pc, EVAL_AVOID_SIDE_EFFECTS);
}

/* Evaluate a subexpression, avoiding all memory references and
   getting a value whose type alone is correct.  */

struct value *
evaluate_subexpression_type (struct expression *exp, int subexp)
{
  return evaluate_subexp (NULL_TYPE, exp, &subexp, EVAL_AVOID_SIDE_EFFECTS);
}

/* Find the current value of a watchpoint on EXP.  Return the value in
   *VALP and *RESULTP and the chain of intermediate and final values
   in *VAL_CHAIN.  RESULTP and VAL_CHAIN may be NULL if the caller does
   not need them.

   If PRESERVE_ERRORS is true, then exceptions are passed through.
   Otherwise, if PRESERVE_ERRORS is false, then if a memory error
   occurs while evaluating the expression, *RESULTP will be set to
   NULL.  *RESULTP may be a lazy value, if the result could not be
   read from memory.  It is used to determine whether a value is
   user-specified (we should watch the whole value) or intermediate
   (we should watch only the bit used to locate the final value).

   If the final value, or any intermediate value, could not be read
   from memory, *VALP will be set to NULL.  *VAL_CHAIN will still be
   set to any referenced values.  *VALP will never be a lazy value.
   This is the value which we store in struct breakpoint.

   If VAL_CHAIN is non-NULL, *VAL_CHAIN will be released from the
   value chain.  The caller must free the values individually.  If
   VAL_CHAIN is NULL, all generated values will be left on the value
   chain.  */

void
fetch_subexp_value (struct expression *exp, int *pc, struct value **valp,
		    struct value **resultp, struct value **val_chain,
		    int preserve_errors)
{
  struct value *mark, *new_mark, *result;
  volatile struct gdb_exception ex;

  *valp = NULL;
  if (resultp)
    *resultp = NULL;
  if (val_chain)
    *val_chain = NULL;

  /* Evaluate the expression.  */
  mark = value_mark ();
  result = NULL;

  TRY_CATCH (ex, RETURN_MASK_ALL)
    {
      result = evaluate_subexp (NULL_TYPE, exp, pc, EVAL_NORMAL);
    }
  if (ex.reason < 0)
    {
      /* Ignore memory errors if we want watchpoints pointing at
	 inaccessible memory to still be created; otherwise, throw the
	 error to some higher catcher.  */
      switch (ex.error)
	{
	case MEMORY_ERROR:
	  if (!preserve_errors)
	    break;
	default:
	  throw_exception (ex);
	  break;
	}
    }

  new_mark = value_mark ();
  if (mark == new_mark)
    return;
  if (resultp)
    *resultp = result;

  /* Make sure it's not lazy, so that after the target stops again we
     have a non-lazy previous value to compare with.  */
  if (result != NULL)
    {
      if (!value_lazy (result))
	*valp = result;
      else
	{
	  volatile struct gdb_exception except;

	  TRY_CATCH (except, RETURN_MASK_ERROR)
	    {
	      value_fetch_lazy (result);
	      *valp = result;
	    }
	}
    }

  if (val_chain)
    {
      /* Return the chain of intermediate values.  We use this to
	 decide which addresses to watch.  */
      *val_chain = new_mark;
      value_release_to_mark (mark);
    }
}

/* Extract a field operation from an expression.  If the subexpression
   of EXP starting at *SUBEXP is not a structure dereference
   operation, return NULL.  Otherwise, return the name of the
   dereferenced field, and advance *SUBEXP to point to the
   subexpression of the left-hand-side of the dereference.  This is
   used when completing field names.  */

char *
extract_field_op (struct expression *exp, int *subexp)
{
  int tem;
  char *result;

  if (exp->elts[*subexp].opcode != STRUCTOP_STRUCT
      && exp->elts[*subexp].opcode != STRUCTOP_PTR)
    return NULL;
  tem = longest_to_int (exp->elts[*subexp + 1].longconst);
  result = &exp->elts[*subexp + 2].string;
  (*subexp) += 1 + 3 + BYTES_TO_EXP_ELEM (tem + 1);
  return result;
}

/* This function evaluates brace-initializers (in C/C++) for
   structure types.  */

static struct value *
evaluate_struct_tuple (struct value *struct_val,
		       struct expression *exp,
		       int *pos, enum noside noside, int nargs)
{
  struct type *struct_type = check_typedef (value_type (struct_val));
  struct type *field_type;
  int fieldno = -1;

  while (--nargs >= 0)
    {
      struct value *val = NULL;
      int bitpos, bitsize;
      bfd_byte *addr;

      fieldno++;
      /* Skip static fields.  */
      while (fieldno < TYPE_NFIELDS (struct_type)
	     && field_is_static (&TYPE_FIELD (struct_type,
					      fieldno)))
	fieldno++;
      if (fieldno >= TYPE_NFIELDS (struct_type))
	error (_("too many initializers"));
      field_type = TYPE_FIELD_TYPE (struct_type, fieldno);
      if (TYPE_CODE (field_type) == TYPE_CODE_UNION
	  && TYPE_FIELD_NAME (struct_type, fieldno)[0] == '0')
	error (_("don't know which variant you want to set"));

      /* Here, struct_type is the type of the inner struct,
	 while substruct_type is the type of the inner struct.
	 These are the same for normal structures, but a variant struct
	 contains anonymous union fields that contain substruct fields.
	 The value fieldno is the index of the top-level (normal or
	 anonymous union) field in struct_field, while the value
	 subfieldno is the index of the actual real (named inner) field
	 in substruct_type.  */

      field_type = TYPE_FIELD_TYPE (struct_type, fieldno);
      if (val == 0)
	val = evaluate_subexp (field_type, exp, pos, noside);

      /* Now actually set the field in struct_val.  */

      /* Assign val to field fieldno.  */
      if (value_type (val) != field_type)
	val = value_cast (field_type, val);

      bitsize = TYPE_FIELD_BITSIZE (struct_type, fieldno);
      bitpos = TYPE_FIELD_BITPOS (struct_type, fieldno);
      addr = value_contents_writeable (struct_val) + bitpos / 8;
      if (bitsize)
	modify_field (struct_type, addr,
		      value_as_long (val), bitpos % 8, bitsize);
      else
	memcpy (addr, value_contents (val),
		TYPE_LENGTH (value_type (val)));

    }
  return struct_val;
}

/* Recursive helper function for setting elements of array tuples for
   (the deleted) Chill.  The target is ARRAY (which has bounds
   LOW_BOUND to HIGH_BOUND); the element value is ELEMENT; EXP, POS
   and NOSIDE are as usual.  Evaluates index expresions and sets the
   specified element(s) of ARRAY to ELEMENT.  Returns last index
   value.  */

static LONGEST
init_array_element (struct value *array, struct value *element,
		    struct expression *exp, int *pos,
		    enum noside noside, LONGEST low_bound, LONGEST high_bound)
{
  LONGEST index;
  int element_size = TYPE_LENGTH (value_type (element));

  if (exp->elts[*pos].opcode == BINOP_COMMA)
    {
      (*pos)++;
      init_array_element (array, element, exp, pos, noside,
			  low_bound, high_bound);
      return init_array_element (array, element,
				 exp, pos, noside, low_bound, high_bound);
    }
  else if (exp->elts[*pos].opcode == BINOP_RANGE)
    {
      LONGEST low, high;

      (*pos)++;
      low = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
      high = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
      if (low < low_bound || high > high_bound)
	error (_("tuple range index out of range"));
      for (index = low; index <= high; index++)
	{
	  memcpy (value_contents_raw (array)
		  + (index - low_bound) * element_size,
		  value_contents (element), element_size);
	}
    }
  else
    {
      index = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
      if (index < low_bound || index > high_bound)
	error (_("tuple index out of range"));
      memcpy (value_contents_raw (array) + (index - low_bound) * element_size,
	      value_contents (element), element_size);
    }
  return index;
}

static struct value *
value_f90_subarray (struct value *array,
		    struct expression *exp, int *pos, enum noside noside)
{
  int pc = (*pos) + 1;
  LONGEST low_bound, high_bound;
  struct type *range = check_typedef (TYPE_INDEX_TYPE (value_type (array)));
  enum f90_range_type range_type = longest_to_int (exp->elts[pc].longconst);
 
  *pos += 3;

  if (range_type == LOW_BOUND_DEFAULT || range_type == BOTH_BOUND_DEFAULT)
    low_bound = TYPE_LOW_BOUND (range);
  else
    low_bound = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));

  if (range_type == HIGH_BOUND_DEFAULT || range_type == BOTH_BOUND_DEFAULT)
    high_bound = TYPE_HIGH_BOUND (range);
  else
    high_bound = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));

  return value_slice (array, low_bound, high_bound - low_bound + 1);
}


/* Promote value ARG1 as appropriate before performing a unary operation
   on this argument.
   If the result is not appropriate for any particular language then it
   needs to patch this function.  */

void
unop_promote (const struct language_defn *language, struct gdbarch *gdbarch,
	      struct value **arg1)
{
  struct type *type1;

  *arg1 = coerce_ref (*arg1);
  type1 = check_typedef (value_type (*arg1));

  if (is_integral_type (type1))
    {
      switch (language->la_language)
	{
	default:
	  /* Perform integral promotion for ANSI C/C++.
	     If not appropropriate for any particular language
	     it needs to modify this function.  */
	  {
	    struct type *builtin_int = builtin_type (gdbarch)->builtin_int;

	    if (TYPE_LENGTH (type1) < TYPE_LENGTH (builtin_int))
	      *arg1 = value_cast (builtin_int, *arg1);
	  }
	  break;
	}
    }
}

/* Promote values ARG1 and ARG2 as appropriate before performing a binary
   operation on those two operands.
   If the result is not appropriate for any particular language then it
   needs to patch this function.  */

void
binop_promote (const struct language_defn *language, struct gdbarch *gdbarch,
	       struct value **arg1, struct value **arg2)
{
  struct type *promoted_type = NULL;
  struct type *type1;
  struct type *type2;

  *arg1 = coerce_ref (*arg1);
  *arg2 = coerce_ref (*arg2);

  type1 = check_typedef (value_type (*arg1));
  type2 = check_typedef (value_type (*arg2));

  if ((TYPE_CODE (type1) != TYPE_CODE_FLT
       && TYPE_CODE (type1) != TYPE_CODE_DECFLOAT
       && !is_integral_type (type1))
      || (TYPE_CODE (type2) != TYPE_CODE_FLT
	  && TYPE_CODE (type2) != TYPE_CODE_DECFLOAT
	  && !is_integral_type (type2)))
    return;

  if (TYPE_CODE (type1) == TYPE_CODE_DECFLOAT
      || TYPE_CODE (type2) == TYPE_CODE_DECFLOAT)
    {
      /* No promotion required.  */
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_FLT
	   || TYPE_CODE (type2) == TYPE_CODE_FLT)
    {
      switch (language->la_language)
	{
	case language_c:
	case language_cplus:
	case language_asm:
	case language_objc:
	case language_opencl:
	  /* No promotion required.  */
	  break;

	default:
	  /* For other languages the result type is unchanged from gdb
	     version 6.7 for backward compatibility.
	     If either arg was long double, make sure that value is also long
	     double.  Otherwise use double.  */
	  if (TYPE_LENGTH (type1) * 8 > gdbarch_double_bit (gdbarch)
	      || TYPE_LENGTH (type2) * 8 > gdbarch_double_bit (gdbarch))
	    promoted_type = builtin_type (gdbarch)->builtin_long_double;
	  else
	    promoted_type = builtin_type (gdbarch)->builtin_double;
	  break;
	}
    }
  else if (TYPE_CODE (type1) == TYPE_CODE_BOOL
	   && TYPE_CODE (type2) == TYPE_CODE_BOOL)
    {
      /* No promotion required.  */
    }
  else
    /* Integral operations here.  */
    /* FIXME: Also mixed integral/booleans, with result an integer.  */
    {
      const struct builtin_type *builtin = builtin_type (gdbarch);
      unsigned int promoted_len1 = TYPE_LENGTH (type1);
      unsigned int promoted_len2 = TYPE_LENGTH (type2);
      int is_unsigned1 = TYPE_UNSIGNED (type1);
      int is_unsigned2 = TYPE_UNSIGNED (type2);
      unsigned int result_len;
      int unsigned_operation;

      /* Determine type length and signedness after promotion for
         both operands.  */
      if (promoted_len1 < TYPE_LENGTH (builtin->builtin_int))
	{
	  is_unsigned1 = 0;
	  promoted_len1 = TYPE_LENGTH (builtin->builtin_int);
	}
      if (promoted_len2 < TYPE_LENGTH (builtin->builtin_int))
	{
	  is_unsigned2 = 0;
	  promoted_len2 = TYPE_LENGTH (builtin->builtin_int);
	}

      if (promoted_len1 > promoted_len2)
	{
	  unsigned_operation = is_unsigned1;
	  result_len = promoted_len1;
	}
      else if (promoted_len2 > promoted_len1)
	{
	  unsigned_operation = is_unsigned2;
	  result_len = promoted_len2;
	}
      else
	{
	  unsigned_operation = is_unsigned1 || is_unsigned2;
	  result_len = promoted_len1;
	}

      switch (language->la_language)
	{
	case language_c:
	case language_cplus:
	case language_asm:
	case language_objc:
	  if (result_len <= TYPE_LENGTH (builtin->builtin_int))
	    {
	      promoted_type = (unsigned_operation
			       ? builtin->builtin_unsigned_int
			       : builtin->builtin_int);
	    }
	  else if (result_len <= TYPE_LENGTH (builtin->builtin_long))
	    {
	      promoted_type = (unsigned_operation
			       ? builtin->builtin_unsigned_long
			       : builtin->builtin_long);
	    }
	  else
	    {
	      promoted_type = (unsigned_operation
			       ? builtin->builtin_unsigned_long_long
			       : builtin->builtin_long_long);
	    }
	  break;
	case language_opencl:
	  if (result_len <= TYPE_LENGTH (lookup_signed_typename
					 (language, gdbarch, "int")))
	    {
	      promoted_type =
		(unsigned_operation
		 ? lookup_unsigned_typename (language, gdbarch, "int")
		 : lookup_signed_typename (language, gdbarch, "int"));
	    }
	  else if (result_len <= TYPE_LENGTH (lookup_signed_typename
					      (language, gdbarch, "long")))
	    {
	      promoted_type =
		(unsigned_operation
		 ? lookup_unsigned_typename (language, gdbarch, "long")
		 : lookup_signed_typename (language, gdbarch,"long"));
	    }
	  break;
	default:
	  /* For other languages the result type is unchanged from gdb
	     version 6.7 for backward compatibility.
	     If either arg was long long, make sure that value is also long
	     long.  Otherwise use long.  */
	  if (unsigned_operation)
	    {
	      if (result_len > gdbarch_long_bit (gdbarch) / HOST_CHAR_BIT)
		promoted_type = builtin->builtin_unsigned_long_long;
	      else
		promoted_type = builtin->builtin_unsigned_long;
	    }
	  else
	    {
	      if (result_len > gdbarch_long_bit (gdbarch) / HOST_CHAR_BIT)
		promoted_type = builtin->builtin_long_long;
	      else
		promoted_type = builtin->builtin_long;
	    }
	  break;
	}
    }

  if (promoted_type)
    {
      /* Promote both operands to common type.  */
      *arg1 = value_cast (promoted_type, *arg1);
      *arg2 = value_cast (promoted_type, *arg2);
    }
}

static int
ptrmath_type_p (const struct language_defn *lang, struct type *type)
{
  type = check_typedef (type);
  if (TYPE_CODE (type) == TYPE_CODE_REF)
    type = TYPE_TARGET_TYPE (type);

  switch (TYPE_CODE (type))
    {
    case TYPE_CODE_PTR:
    case TYPE_CODE_FUNC:
      return 1;

    case TYPE_CODE_ARRAY:
      return TYPE_VECTOR (type) ? 0 : lang->c_style_arrays;

    default:
      return 0;
    }
}

/* Constructs a fake method with the given parameter types.
   This function is used by the parser to construct an "expected"
   type for method overload resolution.  */

static struct type *
make_params (int num_types, struct type **param_types)
{
  struct type *type = XZALLOC (struct type);
  TYPE_MAIN_TYPE (type) = XZALLOC (struct main_type);
  TYPE_LENGTH (type) = 1;
  TYPE_CODE (type) = TYPE_CODE_METHOD;
  TYPE_VPTR_FIELDNO (type) = -1;
  TYPE_CHAIN (type) = type;
  if (num_types > 0)
    {
      if (param_types[num_types - 1] == NULL)
	{
	  --num_types;
	  TYPE_VARARGS (type) = 1;
	}
      else if (TYPE_CODE (check_typedef (param_types[num_types - 1]))
	       == TYPE_CODE_VOID)
	{
	  --num_types;
	  /* Caller should have ensured this.  */
	  gdb_assert (num_types == 0);
	  TYPE_PROTOTYPED (type) = 1;
	}
    }

  TYPE_NFIELDS (type) = num_types;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ZALLOC (type, sizeof (struct field) * num_types);

  while (num_types-- > 0)
    TYPE_FIELD_TYPE (type, num_types) = param_types[num_types];

  return type;
}

struct value *
evaluate_subexp_standard (struct type *expect_type,
			  struct expression *exp, int *pos,
			  enum noside noside)
{
  enum exp_opcode op;
  int tem, tem2, tem3;
  int pc, pc2 = 0, oldpos;
  struct value *arg1 = NULL;
  struct value *arg2 = NULL;
  struct value *arg3;
  struct type *type;
  int nargs;
  struct value **argvec;
  int code;
  int ix;
  long mem_offset;
  struct type **arg_types;
  int save_pos1;
  struct symbol *function = NULL;
  char *function_name = NULL;

  pc = (*pos)++;
  op = exp->elts[pc].opcode;

  switch (op)
    {
    case OP_SCOPE:
      tem = longest_to_int (exp->elts[pc + 2].longconst);
      (*pos) += 4 + BYTES_TO_EXP_ELEM (tem + 1);
      if (noside == EVAL_SKIP)
	goto nosideret;
      arg1 = value_aggregate_elt (exp->elts[pc + 1].type,
				  &exp->elts[pc + 3].string,
				  expect_type, 0, noside);
      if (arg1 == NULL)
	error (_("There is no field named %s"), &exp->elts[pc + 3].string);
      return arg1;

    case OP_LONG:
      (*pos) += 3;
      return value_from_longest (exp->elts[pc + 1].type,
				 exp->elts[pc + 2].longconst);

    case OP_DOUBLE:
      (*pos) += 3;
      return value_from_double (exp->elts[pc + 1].type,
				exp->elts[pc + 2].doubleconst);

    case OP_DECFLOAT:
      (*pos) += 3;
      return value_from_decfloat (exp->elts[pc + 1].type,
				  exp->elts[pc + 2].decfloatconst);

    case OP_ADL_FUNC:
    case OP_VAR_VALUE:
      (*pos) += 3;
      if (noside == EVAL_SKIP)
	goto nosideret;

      /* JYG: We used to just return value_zero of the symbol type
	 if we're asked to avoid side effects.  Otherwise we return
	 value_of_variable (...).  However I'm not sure if
	 value_of_variable () has any side effect.
	 We need a full value object returned here for whatis_exp ()
	 to call evaluate_type () and then pass the full value to
	 value_rtti_target_type () if we are dealing with a pointer
	 or reference to a base class and print object is on.  */

      {
	volatile struct gdb_exception except;
	struct value *ret = NULL;

	TRY_CATCH (except, RETURN_MASK_ERROR)
	  {
	    ret = value_of_variable (exp->elts[pc + 2].symbol,
				     exp->elts[pc + 1].block);
	  }

	if (except.reason < 0)
	  {
	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      ret = value_zero (SYMBOL_TYPE (exp->elts[pc + 2].symbol),
				not_lval);
	    else
	      throw_exception (except);
	  }

	return ret;
      }

    case OP_VAR_ENTRY_VALUE:
      (*pos) += 2;
      if (noside == EVAL_SKIP)
	goto nosideret;

      {
	struct symbol *sym = exp->elts[pc + 1].symbol;
	struct frame_info *frame;

	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  return value_zero (SYMBOL_TYPE (sym), not_lval);

	if (SYMBOL_COMPUTED_OPS (sym) == NULL
	    || SYMBOL_COMPUTED_OPS (sym)->read_variable_at_entry == NULL)
	  error (_("Symbol \"%s\" does not have any specific entry value"),
		 SYMBOL_PRINT_NAME (sym));

	frame = get_selected_frame (NULL);
	return SYMBOL_COMPUTED_OPS (sym)->read_variable_at_entry (sym, frame);
      }

    case OP_LAST:
      (*pos) += 2;
      return
	access_value_history (longest_to_int (exp->elts[pc + 1].longconst));

    case OP_REGISTER:
      {
	const char *name = &exp->elts[pc + 2].string;
	int regno;
	struct value *val;

	(*pos) += 3 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);
	regno = user_reg_map_name_to_regnum (exp->gdbarch,
					     name, strlen (name));
	if (regno == -1)
	  error (_("Register $%s not available."), name);

        /* In EVAL_AVOID_SIDE_EFFECTS mode, we only need to return
           a value with the appropriate register type.  Unfortunately,
           we don't have easy access to the type of user registers.
           So for these registers, we fetch the register value regardless
           of the evaluation mode.  */
	if (noside == EVAL_AVOID_SIDE_EFFECTS
	    && regno < gdbarch_num_regs (exp->gdbarch)
			+ gdbarch_num_pseudo_regs (exp->gdbarch))
	  val = value_zero (register_type (exp->gdbarch, regno), not_lval);
	else
	  val = value_of_register (regno, get_selected_frame (NULL));
	if (val == NULL)
	  error (_("Value of register %s not available."), name);
	else
	  return val;
      }
    case OP_BOOL:
      (*pos) += 2;
      type = language_bool_type (exp->language_defn, exp->gdbarch);
      return value_from_longest (type, exp->elts[pc + 1].longconst);

    case OP_INTERNALVAR:
      (*pos) += 2;
      return value_of_internalvar (exp->gdbarch,
				   exp->elts[pc + 1].internalvar);

    case OP_STRING:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      if (noside == EVAL_SKIP)
	goto nosideret;
      type = language_string_char_type (exp->language_defn, exp->gdbarch);
      return value_string (&exp->elts[pc + 2].string, tem, type);

    case OP_OBJC_NSSTRING:		/* Objective C Foundation Class
					   NSString constant.  */
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      if (noside == EVAL_SKIP)
	{
	  goto nosideret;
	}
      return value_nsstring (exp->gdbarch, &exp->elts[pc + 2].string, tem + 1);

    case OP_ARRAY:
      (*pos) += 3;
      tem2 = longest_to_int (exp->elts[pc + 1].longconst);
      tem3 = longest_to_int (exp->elts[pc + 2].longconst);
      nargs = tem3 - tem2 + 1;
      type = expect_type ? check_typedef (expect_type) : NULL_TYPE;

      if (expect_type != NULL_TYPE && noside != EVAL_SKIP
	  && TYPE_CODE (type) == TYPE_CODE_STRUCT)
	{
	  struct value *rec = allocate_value (expect_type);

	  memset (value_contents_raw (rec), '\0', TYPE_LENGTH (type));
	  return evaluate_struct_tuple (rec, exp, pos, noside, nargs);
	}

      if (expect_type != NULL_TYPE && noside != EVAL_SKIP
	  && TYPE_CODE (type) == TYPE_CODE_ARRAY)
	{
	  struct type *range_type = TYPE_INDEX_TYPE (type);
	  struct type *element_type = TYPE_TARGET_TYPE (type);
	  struct value *array = allocate_value (expect_type);
	  int element_size = TYPE_LENGTH (check_typedef (element_type));
	  LONGEST low_bound, high_bound, index;

	  if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)
	    {
	      low_bound = 0;
	      high_bound = (TYPE_LENGTH (type) / element_size) - 1;
	    }
	  index = low_bound;
	  memset (value_contents_raw (array), 0, TYPE_LENGTH (expect_type));
	  for (tem = nargs; --nargs >= 0;)
	    {
	      struct value *element;
	      int index_pc = 0;

	      if (exp->elts[*pos].opcode == BINOP_RANGE)
		{
		  index_pc = ++(*pos);
		  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
		}
	      element = evaluate_subexp (element_type, exp, pos, noside);
	      if (value_type (element) != element_type)
		element = value_cast (element_type, element);
	      if (index_pc)
		{
		  int continue_pc = *pos;

		  *pos = index_pc;
		  index = init_array_element (array, element, exp, pos, noside,
					      low_bound, high_bound);
		  *pos = continue_pc;
		}
	      else
		{
		  if (index > high_bound)
		    /* To avoid memory corruption.  */
		    error (_("Too many array elements"));
		  memcpy (value_contents_raw (array)
			  + (index - low_bound) * element_size,
			  value_contents (element),
			  element_size);
		}
	      index++;
	    }
	  return array;
	}

      if (expect_type != NULL_TYPE && noside != EVAL_SKIP
	  && TYPE_CODE (type) == TYPE_CODE_SET)
	{
	  struct value *set = allocate_value (expect_type);
	  gdb_byte *valaddr = value_contents_raw (set);
	  struct type *element_type = TYPE_INDEX_TYPE (type);
	  struct type *check_type = element_type;
	  LONGEST low_bound, high_bound;

	  /* Get targettype of elementtype.  */
	  while (TYPE_CODE (check_type) == TYPE_CODE_RANGE
		 || TYPE_CODE (check_type) == TYPE_CODE_TYPEDEF)
	    check_type = TYPE_TARGET_TYPE (check_type);

	  if (get_discrete_bounds (element_type, &low_bound, &high_bound) < 0)
	    error (_("(power)set type with unknown size"));
	  memset (valaddr, '\0', TYPE_LENGTH (type));
	  for (tem = 0; tem < nargs; tem++)
	    {
	      LONGEST range_low, range_high;
	      struct type *range_low_type, *range_high_type;
	      struct value *elem_val;

	      if (exp->elts[*pos].opcode == BINOP_RANGE)
		{
		  (*pos)++;
		  elem_val = evaluate_subexp (element_type, exp, pos, noside);
		  range_low_type = value_type (elem_val);
		  range_low = value_as_long (elem_val);
		  elem_val = evaluate_subexp (element_type, exp, pos, noside);
		  range_high_type = value_type (elem_val);
		  range_high = value_as_long (elem_val);
		}
	      else
		{
		  elem_val = evaluate_subexp (element_type, exp, pos, noside);
		  range_low_type = range_high_type = value_type (elem_val);
		  range_low = range_high = value_as_long (elem_val);
		}
	      /* Check types of elements to avoid mixture of elements from
	         different types. Also check if type of element is "compatible"
	         with element type of powerset.  */
	      if (TYPE_CODE (range_low_type) == TYPE_CODE_RANGE)
		range_low_type = TYPE_TARGET_TYPE (range_low_type);
	      if (TYPE_CODE (range_high_type) == TYPE_CODE_RANGE)
		range_high_type = TYPE_TARGET_TYPE (range_high_type);
	      if ((TYPE_CODE (range_low_type) != TYPE_CODE (range_high_type))
		  || (TYPE_CODE (range_low_type) == TYPE_CODE_ENUM
		      && (range_low_type != range_high_type)))
		/* different element modes.  */
		error (_("POWERSET tuple elements of different mode"));
	      if ((TYPE_CODE (check_type) != TYPE_CODE (range_low_type))
		  || (TYPE_CODE (check_type) == TYPE_CODE_ENUM
		      && range_low_type != check_type))
		error (_("incompatible POWERSET tuple elements"));
	      if (range_low > range_high)
		{
		  warning (_("empty POWERSET tuple range"));
		  continue;
		}
	      if (range_low < low_bound || range_high > high_bound)
		error (_("POWERSET tuple element out of range"));
	      range_low -= low_bound;
	      range_high -= low_bound;
	      for (; range_low <= range_high; range_low++)
		{
		  int bit_index = (unsigned) range_low % TARGET_CHAR_BIT;

		  if (gdbarch_bits_big_endian (exp->gdbarch))
		    bit_index = TARGET_CHAR_BIT - 1 - bit_index;
		  valaddr[(unsigned) range_low / TARGET_CHAR_BIT]
		    |= 1 << bit_index;
		}
	    }
	  return set;
	}

      argvec = (struct value **) alloca (sizeof (struct value *) * nargs);
      for (tem = 0; tem < nargs; tem++)
	{
	  /* Ensure that array expressions are coerced into pointer
	     objects.  */
	  argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
	}
      if (noside == EVAL_SKIP)
	goto nosideret;
      return value_array (tem2, tem3, argvec);

    case TERNOP_SLICE:
      {
	struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	int lowbound
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
	int upper
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));

	if (noside == EVAL_SKIP)
	  goto nosideret;
	return value_slice (array, lowbound, upper - lowbound + 1);
      }

    case TERNOP_COND:
      /* Skip third and second args to evaluate the first one.  */
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (value_logical_not (arg1))
	{
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  return evaluate_subexp (NULL_TYPE, exp, pos, noside);
	}
      else
	{
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  return arg2;
	}

    case OP_OBJC_SELECTOR:
      {				/* Objective C @@selector operator.  */
	char *sel = &exp->elts[pc + 2].string;
	int len = longest_to_int (exp->elts[pc + 1].longconst);
	struct type *selector_type;

	(*pos) += 3 + BYTES_TO_EXP_ELEM (len + 1);
	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (sel[len] != 0)
	  sel[len] = 0;		/* Make sure it's terminated.  */

	selector_type = builtin_type (exp->gdbarch)->builtin_data_ptr;
	return value_from_longest (selector_type,
				   lookup_child_selector (exp->gdbarch, sel));
      }

    case OP_OBJC_MSGCALL:
      {				/* Objective C message (method) call.  */

	CORE_ADDR responds_selector = 0;
	CORE_ADDR method_selector = 0;

	CORE_ADDR selector = 0;

	int struct_return = 0;
	int sub_no_side = 0;

	struct value *msg_send = NULL;
	struct value *msg_send_stret = NULL;
	int gnu_runtime = 0;

	struct value *target = NULL;
	struct value *method = NULL;
	struct value *called_method = NULL; 

	struct type *selector_type = NULL;
	struct type *long_type;

	struct value *ret = NULL;
	CORE_ADDR addr = 0;

	selector = exp->elts[pc + 1].longconst;
	nargs = exp->elts[pc + 2].longconst;
	argvec = (struct value **) alloca (sizeof (struct value *) 
					   * (nargs + 5));

	(*pos) += 3;

	long_type = builtin_type (exp->gdbarch)->builtin_long;
	selector_type = builtin_type (exp->gdbarch)->builtin_data_ptr;

	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  sub_no_side = EVAL_NORMAL;
	else
	  sub_no_side = noside;

	target = evaluate_subexp (selector_type, exp, pos, sub_no_side);

	if (value_as_long (target) == 0)
 	  return value_from_longest (long_type, 0);
	
	if (lookup_minimal_symbol ("objc_msg_lookup", 0, 0))
	  gnu_runtime = 1;
	
	/* Find the method dispatch (Apple runtime) or method lookup
	   (GNU runtime) function for Objective-C.  These will be used
	   to lookup the symbol information for the method.  If we
	   can't find any symbol information, then we'll use these to
	   call the method, otherwise we can call the method
	   directly.  The msg_send_stret function is used in the special
	   case of a method that returns a structure (Apple runtime 
	   only).  */
	if (gnu_runtime)
	  {
	    struct type *type = selector_type;

	    type = lookup_function_type (type);
	    type = lookup_pointer_type (type);
	    type = lookup_function_type (type);
	    type = lookup_pointer_type (type);

	    msg_send = find_function_in_inferior ("objc_msg_lookup", NULL);
	    msg_send_stret
	      = find_function_in_inferior ("objc_msg_lookup", NULL);

	    msg_send = value_from_pointer (type, value_as_address (msg_send));
	    msg_send_stret = value_from_pointer (type, 
					value_as_address (msg_send_stret));
	  }
	else
	  {
	    msg_send = find_function_in_inferior ("objc_msgSend", NULL);
	    /* Special dispatcher for methods returning structs.  */
	    msg_send_stret
	      = find_function_in_inferior ("objc_msgSend_stret", NULL);
	  }

	/* Verify the target object responds to this method.  The
	   standard top-level 'Object' class uses a different name for
	   the verification method than the non-standard, but more
	   often used, 'NSObject' class.  Make sure we check for both.  */

	responds_selector
	  = lookup_child_selector (exp->gdbarch, "respondsToSelector:");
	if (responds_selector == 0)
	  responds_selector
	    = lookup_child_selector (exp->gdbarch, "respondsTo:");
	
	if (responds_selector == 0)
	  error (_("no 'respondsTo:' or 'respondsToSelector:' method"));
	
	method_selector
	  = lookup_child_selector (exp->gdbarch, "methodForSelector:");
	if (method_selector == 0)
	  method_selector
	    = lookup_child_selector (exp->gdbarch, "methodFor:");
	
	if (method_selector == 0)
	  error (_("no 'methodFor:' or 'methodForSelector:' method"));

	/* Call the verification method, to make sure that the target
	 class implements the desired method.  */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (long_type, responds_selector);
	argvec[3] = value_from_longest (long_type, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    /* Function objc_msg_lookup returns a pointer.  */
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }
	if (value_as_long (ret) == 0)
	  error (_("Target does not respond to this message selector."));

	/* Call "methodForSelector:" method, to get the address of a
	   function method that implements this selector for this
	   class.  If we can find a symbol at that address, then we
	   know the return type, parameter types etc.  (that's a good
	   thing).  */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (long_type, method_selector);
	argvec[3] = value_from_longest (long_type, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }

	/* ret should now be the selector.  */

	addr = value_as_long (ret);
	if (addr)
	  {
	    struct symbol *sym = NULL;

	    /* The address might point to a function descriptor;
	       resolve it to the actual code address instead.  */
	    addr = gdbarch_convert_from_func_ptr_addr (exp->gdbarch, addr,
						       &current_target);

	    /* Is it a high_level symbol?  */
	    sym = find_pc_function (addr);
	    if (sym != NULL) 
	      method = value_of_variable (sym, 0);
	  }

	/* If we found a method with symbol information, check to see
           if it returns a struct.  Otherwise assume it doesn't.  */

	if (method)
	  {
	    CORE_ADDR funaddr;
	    struct type *val_type;

	    funaddr = find_function_addr (method, &val_type);

	    block_for_pc (funaddr);

	    CHECK_TYPEDEF (val_type);
	  
	    if ((val_type == NULL) 
		|| (TYPE_CODE(val_type) == TYPE_CODE_ERROR))
	      {
		if (expect_type != NULL)
		  val_type = expect_type;
	      }

	    struct_return = using_struct_return (exp->gdbarch, method,
						 val_type);
	  }
	else if (expect_type != NULL)
	  {
	    struct_return = using_struct_return (exp->gdbarch, NULL,
						 check_typedef (expect_type));
	  }
	
	/* Found a function symbol.  Now we will substitute its
	   value in place of the message dispatcher (obj_msgSend),
	   so that we call the method directly instead of thru
	   the dispatcher.  The main reason for doing this is that
	   we can now evaluate the return value and parameter values
	   according to their known data types, in case we need to
	   do things like promotion, dereferencing, special handling
	   of structs and doubles, etc.
	  
	   We want to use the type signature of 'method', but still
	   jump to objc_msgSend() or objc_msgSend_stret() to better
	   mimic the behavior of the runtime.  */
	
	if (method)
	  {
	    if (TYPE_CODE (value_type (method)) != TYPE_CODE_FUNC)
	      error (_("method address has symbol information "
		       "with non-function type; skipping"));

	    /* Create a function pointer of the appropriate type, and
	       replace its value with the value of msg_send or
	       msg_send_stret.  We must use a pointer here, as
	       msg_send and msg_send_stret are of pointer type, and
	       the representation may be different on systems that use
	       function descriptors.  */
	    if (struct_return)
	      called_method
		= value_from_pointer (lookup_pointer_type (value_type (method)),
				      value_as_address (msg_send_stret));
	    else
	      called_method
		= value_from_pointer (lookup_pointer_type (value_type (method)),
				      value_as_address (msg_send));
	  }
	else
	  {
	    if (struct_return)
	      called_method = msg_send_stret;
	    else
	      called_method = msg_send;
	  }

	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  {
	    /* If the return type doesn't look like a function type,
	       call an error.  This can happen if somebody tries to
	       turn a variable into a function call.  This is here
	       because people often want to call, eg, strcmp, which
	       gdb doesn't know is a function.  If gdb isn't asked for
	       it's opinion (ie. through "whatis"), it won't offer
	       it.  */

	    struct type *type = value_type (called_method);

	    if (type && TYPE_CODE (type) == TYPE_CODE_PTR)
	      type = TYPE_TARGET_TYPE (type);
	    type = TYPE_TARGET_TYPE (type);

	    if (type)
	    {
	      if ((TYPE_CODE (type) == TYPE_CODE_ERROR) && expect_type)
		return allocate_value (expect_type);
	      else
		return allocate_value (type);
	    }
	    else
	      error (_("Expression of type other than "
		       "\"method returning ...\" used as a method"));
	  }

	/* Now depending on whether we found a symbol for the method,
	   we will either call the runtime dispatcher or the method
	   directly.  */

	argvec[0] = called_method;
	argvec[1] = target;
	argvec[2] = value_from_longest (long_type, selector);
	/* User-supplied arguments.  */
	for (tem = 0; tem < nargs; tem++)
	  argvec[tem + 3] = evaluate_subexp_with_coercion (exp, pos, noside);
	argvec[tem + 3] = 0;

	if (gnu_runtime && (method != NULL))
	  {
	    /* Function objc_msg_lookup returns a pointer.  */
	    deprecated_set_value_type (argvec[0],
				       lookup_pointer_type (lookup_function_type (value_type (argvec[0]))));
	    argvec[0]
	      = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	  }

	ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	return ret;
      }
      break;

    case OP_FUNCALL:
      (*pos) += 2;
      op = exp->elts[*pos].opcode;
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      /* Allocate arg vector, including space for the function to be
         called in argvec[0] and a terminating NULL.  */
      argvec = (struct value **)
	alloca (sizeof (struct value *) * (nargs + 3));
      if (op == STRUCTOP_MEMBER || op == STRUCTOP_MPTR)
	{
	  /* First, evaluate the structure into arg2.  */
	  pc2 = (*pos)++;

	  if (noside == EVAL_SKIP)
	    goto nosideret;

	  if (op == STRUCTOP_MEMBER)
	    {
	      arg2 = evaluate_subexp_for_address (exp, pos, noside);
	    }
	  else
	    {
	      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	    }

	  /* If the function is a virtual function, then the
	     aggregate value (providing the structure) plays
	     its part by providing the vtable.  Otherwise,
	     it is just along for the ride: call the function
	     directly.  */

	  arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

	  type = check_typedef (value_type (arg1));
	  if (TYPE_CODE (type) == TYPE_CODE_METHODPTR)
	    {
	      if (noside == EVAL_AVOID_SIDE_EFFECTS)
		arg1 = value_zero (TYPE_TARGET_TYPE (type), not_lval);
	      else
		arg1 = cplus_method_ptr_to_value (&arg2, arg1);

	      /* Now, say which argument to start evaluating from.  */
	      nargs++;
	      tem = 2;
	      argvec[1] = arg2;
	    }
	  else if (TYPE_CODE (type) == TYPE_CODE_MEMBERPTR)
	    {
	      struct type *type_ptr
		= lookup_pointer_type (TYPE_DOMAIN_TYPE (type));
	      struct type *target_type_ptr
		= lookup_pointer_type (TYPE_TARGET_TYPE (type));

	      /* Now, convert these values to an address.  */
	      arg2 = value_cast (type_ptr, arg2);

	      mem_offset = value_as_long (arg1);

	      arg1 = value_from_pointer (target_type_ptr,
					 value_as_long (arg2) + mem_offset);
	      arg1 = value_ind (arg1);
	      tem = 1;
	    }
	  else
	    error (_("Non-pointer-to-member value used in pointer-to-member "
		     "construct"));
	}
      else if (op == STRUCTOP_STRUCT || op == STRUCTOP_PTR)
	{
	  /* Hair for method invocations.  */
	  int tem2;

	  nargs++;
	  /* First, evaluate the structure into arg2.  */
	  pc2 = (*pos)++;
	  tem2 = longest_to_int (exp->elts[pc2 + 1].longconst);
	  *pos += 3 + BYTES_TO_EXP_ELEM (tem2 + 1);
	  if (noside == EVAL_SKIP)
	    goto nosideret;

	  if (op == STRUCTOP_STRUCT)
	    {
	      /* If v is a variable in a register, and the user types
	         v.method (), this will produce an error, because v has
	         no address.

	         A possible way around this would be to allocate a
	         copy of the variable on the stack, copy in the
	         contents, call the function, and copy out the
	         contents.  I.e. convert this from call by reference
	         to call by copy-return (or whatever it's called).
	         However, this does not work because it is not the
	         same: the method being called could stash a copy of
	         the address, and then future uses through that address
	         (after the method returns) would be expected to
	         use the variable itself, not some copy of it.  */
	      arg2 = evaluate_subexp_for_address (exp, pos, noside);
	    }
	  else
	    {
	      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

	      /* Check to see if the operator '->' has been
	         overloaded.  If the operator has been overloaded
	         replace arg2 with the value returned by the custom
	         operator and continue evaluation.  */
	      while (unop_user_defined_p (op, arg2))
		{
		  volatile struct gdb_exception except;
		  struct value *value = NULL;
		  TRY_CATCH (except, RETURN_MASK_ERROR)
		    {
		      value = value_x_unop (arg2, op, noside);
		    }

		  if (except.reason < 0)
		    {
		      if (except.error == NOT_FOUND_ERROR)
			break;
		      else
			throw_exception (except);
		    }
		  arg2 = value;
		}
	    }
	  /* Now, say which argument to start evaluating from.  */
	  tem = 2;
	}
      else if (op == OP_SCOPE
	       && overload_resolution
	       && (exp->language_defn->la_language == language_cplus))
	{
	  /* Unpack it locally so we can properly handle overload
	     resolution.  */
	  char *name;
	  int local_tem;

	  pc2 = (*pos)++;
	  local_tem = longest_to_int (exp->elts[pc2 + 2].longconst);
	  (*pos) += 4 + BYTES_TO_EXP_ELEM (local_tem + 1);
	  type = exp->elts[pc2 + 1].type;
	  name = &exp->elts[pc2 + 3].string;

	  function = NULL;
	  function_name = NULL;
	  if (TYPE_CODE (type) == TYPE_CODE_NAMESPACE)
	    {
	      function = cp_lookup_symbol_namespace (TYPE_TAG_NAME (type),
						     name,
						     get_selected_block (0),
						     VAR_DOMAIN);
	      if (function == NULL)
		error (_("No symbol \"%s\" in namespace \"%s\"."), 
		       name, TYPE_TAG_NAME (type));

	      tem = 1;
	    }
	  else
	    {
	      gdb_assert (TYPE_CODE (type) == TYPE_CODE_STRUCT
			  || TYPE_CODE (type) == TYPE_CODE_UNION);
	      function_name = name;

	      arg2 = value_zero (type, lval_memory);
	      ++nargs;
	      tem = 2;
	    }
	}
      else if (op == OP_ADL_FUNC)
        {
          /* Save the function position and move pos so that the arguments
             can be evaluated.  */
          int func_name_len;

          save_pos1 = *pos;
          tem = 1;

          func_name_len = longest_to_int (exp->elts[save_pos1 + 3].longconst);
          (*pos) += 6 + BYTES_TO_EXP_ELEM (func_name_len + 1);
        }
      else
	{
	  /* Non-method function call.  */
	  save_pos1 = *pos;
	  tem = 1;

	  /* If this is a C++ function wait until overload resolution.  */
	  if (op == OP_VAR_VALUE
	      && overload_resolution
	      && (exp->language_defn->la_language == language_cplus))
	    {
	      (*pos) += 4; /* Skip the evaluation of the symbol.  */
	      argvec[0] = NULL;
	    }
	  else
	    {
	      argvec[0] = evaluate_subexp_with_coercion (exp, pos, noside);
	      type = value_type (argvec[0]);
	      if (type && TYPE_CODE (type) == TYPE_CODE_PTR)
		type = TYPE_TARGET_TYPE (type);
	      if (type && TYPE_CODE (type) == TYPE_CODE_FUNC)
		{
		  for (; tem <= nargs && tem <= TYPE_NFIELDS (type); tem++)
		    {
		      argvec[tem] = evaluate_subexp (TYPE_FIELD_TYPE (type,
								      tem - 1),
						     exp, pos, noside);
		    }
		}
	    }
	}

      /* Evaluate arguments.  */
      for (; tem <= nargs; tem++)
	{
	  /* Ensure that array expressions are coerced into pointer
	     objects.  */
	  argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
	}

      /* Signal end of arglist.  */
      argvec[tem] = 0;
      if (op == OP_ADL_FUNC)
        {
          struct symbol *symp;
          char *func_name;
          int  name_len;
          int string_pc = save_pos1 + 3;

          /* Extract the function name.  */
          name_len = longest_to_int (exp->elts[string_pc].longconst);
          func_name = (char *) alloca (name_len + 1);
          strcpy (func_name, &exp->elts[string_pc + 1].string);

          find_overload_match (&argvec[1], nargs, func_name,
                               NON_METHOD, /* not method */
                               NULL, NULL, /* pass NULL symbol since
					      symbol is unknown */
                               NULL, &symp, NULL, 0);

          /* Now fix the expression being evaluated.  */
          exp->elts[save_pos1 + 2].symbol = symp;
          argvec[0] = evaluate_subexp_with_coercion (exp, &save_pos1, noside);
        }

      if (op == STRUCTOP_STRUCT || op == STRUCTOP_PTR
	  || (op == OP_SCOPE && function_name != NULL))
	{
	  int static_memfuncp;
	  char *tstr;

	  /* Method invocation : stuff "this" as first parameter.  */
	  argvec[1] = arg2;

	  if (op != OP_SCOPE)
	    {
	      /* Name of method from expression.  */
	      tstr = &exp->elts[pc2 + 2].string;
	    }
	  else
	    tstr = function_name;

	  if (overload_resolution && (exp->language_defn->la_language
				      == language_cplus))
	    {
	      /* Language is C++, do some overload resolution before
		 evaluation.  */
	      struct value *valp = NULL;

	      (void) find_overload_match (&argvec[1], nargs, tstr,
	                                  METHOD, /* method */
					  &arg2,  /* the object */
					  NULL, &valp, NULL,
					  &static_memfuncp, 0);

	      if (op == OP_SCOPE && !static_memfuncp)
		{
		  /* For the time being, we don't handle this.  */
		  error (_("Call to overloaded function %s requires "
			   "`this' pointer"),
			 function_name);
		}
	      argvec[1] = arg2;	/* the ``this'' pointer */
	      argvec[0] = valp;	/* Use the method found after overload
				   resolution.  */
	    }
	  else
	    /* Non-C++ case -- or no overload resolution.  */
	    {
	      struct value *temp = arg2;

	      argvec[0] = value_struct_elt (&temp, argvec + 1, tstr,
					    &static_memfuncp,
					    op == STRUCTOP_STRUCT
				       ? "structure" : "structure pointer");
	      /* value_struct_elt updates temp with the correct value
	 	 of the ``this'' pointer if necessary, so modify argvec[1] to
		 reflect any ``this'' changes.  */
	      arg2
		= value_from_longest (lookup_pointer_type(value_type (temp)),
				      value_address (temp)
				      + value_embedded_offset (temp));
	      argvec[1] = arg2;	/* the ``this'' pointer */
	    }

	  if (static_memfuncp)
	    {
	      argvec[1] = argvec[0];
	      nargs--;
	      argvec++;
	    }
	}
      else if (op == STRUCTOP_MEMBER || op == STRUCTOP_MPTR)
	{
	  /* Pointer to member.  argvec[1] is already set up.  */
	  argvec[0] = arg1;
	}
      else if (op == OP_VAR_VALUE || (op == OP_SCOPE && function != NULL))
	{
	  /* Non-member function being called.  */
          /* fn: This can only be done for C++ functions.  A C-style function
             in a C++ program, for instance, does not have the fields that 
             are expected here.  */

	  if (overload_resolution && (exp->language_defn->la_language
				      == language_cplus))
	    {
	      /* Language is C++, do some overload resolution before
		 evaluation.  */
	      struct symbol *symp;
	      int no_adl = 0;

	      /* If a scope has been specified disable ADL.  */
	      if (op == OP_SCOPE)
		no_adl = 1;

	      if (op == OP_VAR_VALUE)
		function = exp->elts[save_pos1+2].symbol;

	      (void) find_overload_match (&argvec[1], nargs,
					  NULL,        /* no need for name */
	                                  NON_METHOD,  /* not method */
	                                  NULL, function, /* the function */
					  NULL, &symp, NULL, no_adl);

	      if (op == OP_VAR_VALUE)
		{
		  /* Now fix the expression being evaluated.  */
		  exp->elts[save_pos1+2].symbol = symp;
		  argvec[0] = evaluate_subexp_with_coercion (exp, &save_pos1,
							     noside);
		}
	      else
		argvec[0] = value_of_variable (symp, get_selected_block (0));
	    }
	  else
	    {
	      /* Not C++, or no overload resolution allowed.  */
	      /* Nothing to be done; argvec already correctly set up.  */
	    }
	}
      else
	{
	  /* It is probably a C-style function.  */
	  /* Nothing to be done; argvec already correctly set up.  */
	}

    do_call_it:

      if (noside == EVAL_SKIP)
	goto nosideret;
      if (argvec[0] == NULL)
	error (_("Cannot evaluate function -- may be inlined"));
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  /* If the return type doesn't look like a function type, call an
	     error.  This can happen if somebody tries to turn a variable into
	     a function call.  This is here because people often want to
	     call, eg, strcmp, which gdb doesn't know is a function.  If
	     gdb isn't asked for it's opinion (ie. through "whatis"),
	     it won't offer it.  */

	  struct type *ftype = value_type (argvec[0]);

	  if (TYPE_CODE (ftype) == TYPE_CODE_INTERNAL_FUNCTION)
	    {
	      /* We don't know anything about what the internal
		 function might return, but we have to return
		 something.  */
	      return value_zero (builtin_type (exp->gdbarch)->builtin_int,
				 not_lval);
	    }
	  else if (TYPE_GNU_IFUNC (ftype))
	    return allocate_value (TYPE_TARGET_TYPE (TYPE_TARGET_TYPE (ftype)));
	  else if (TYPE_TARGET_TYPE (ftype))
	    return allocate_value (TYPE_TARGET_TYPE (ftype));
	  else
	    error (_("Expression of type other than "
		     "\"Function returning ...\" used as function"));
	}
      if (TYPE_CODE (value_type (argvec[0])) == TYPE_CODE_INTERNAL_FUNCTION)
	return call_internal_function (exp->gdbarch, exp->language_defn,
				       argvec[0], nargs, argvec + 1);

      return call_function_by_hand (argvec[0], nargs, argvec + 1);
      /* pai: FIXME save value from call_function_by_hand, then adjust
	 pc by adjust_fn_pc if +ve.  */

    case OP_F77_UNDETERMINED_ARGLIST:

      /* Remember that in F77, functions, substring ops and 
         array subscript operations cannot be disambiguated 
         at parse time.  We have made all array subscript operations, 
         substring operations as well as function calls  come here 
         and we now have to discover what the heck this thing actually was.
         If it is a function, we process just as if we got an OP_FUNCALL.  */

      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 2;

      /* First determine the type code we are dealing with.  */
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      type = check_typedef (value_type (arg1));
      code = TYPE_CODE (type);

      if (code == TYPE_CODE_PTR)
	{
	  /* Fortran always passes variable to subroutines as pointer.
	     So we need to look into its target type to see if it is
	     array, string or function.  If it is, we need to switch
	     to the target value the original one points to.  */ 
	  struct type *target_type = check_typedef (TYPE_TARGET_TYPE (type));

	  if (TYPE_CODE (target_type) == TYPE_CODE_ARRAY
	      || TYPE_CODE (target_type) == TYPE_CODE_STRING
	      || TYPE_CODE (target_type) == TYPE_CODE_FUNC)
	    {
	      arg1 = value_ind (arg1);
	      type = check_typedef (value_type (arg1));
	      code = TYPE_CODE (type);
	    }
	} 

      switch (code)
	{
	case TYPE_CODE_ARRAY:
	  if (exp->elts[*pos].opcode == OP_F90_RANGE)
	    return value_f90_subarray (arg1, exp, pos, noside);
	  else
	    goto multi_f77_subscript;

	case TYPE_CODE_STRING:
	  if (exp->elts[*pos].opcode == OP_F90_RANGE)
	    return value_f90_subarray (arg1, exp, pos, noside);
	  else
	    {
	      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
	      return value_subscript (arg1, value_as_long (arg2));
	    }

	case TYPE_CODE_PTR:
	case TYPE_CODE_FUNC:
	  /* It's a function call.  */
	  /* Allocate arg vector, including space for the function to be
	     called in argvec[0] and a terminating NULL.  */
	  argvec = (struct value **)
	    alloca (sizeof (struct value *) * (nargs + 2));
	  argvec[0] = arg1;
	  tem = 1;
	  for (; tem <= nargs; tem++)
	    argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);
	  argvec[tem] = 0;	/* signal end of arglist */
	  goto do_call_it;

	default:
	  error (_("Cannot perform substring on this type"));
	}

    case OP_COMPLEX:
      /* We have a complex number, There should be 2 floating 
         point numbers that compose it.  */
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      return value_literal_complex (arg1, arg2, exp->elts[pc + 1].type);

    case STRUCTOP_STRUCT:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      arg3 = value_struct_elt (&arg1, NULL, &exp->elts[pc + 2].string,
			       NULL, "structure");
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	arg3 = value_zero (value_type (arg3), not_lval);
      return arg3;

    case STRUCTOP_PTR:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;

      /* Check to see if operator '->' has been overloaded.  If so replace
         arg1 with the value returned by evaluating operator->().  */
      while (unop_user_defined_p (op, arg1))
	{
	  volatile struct gdb_exception except;
	  struct value *value = NULL;
	  TRY_CATCH (except, RETURN_MASK_ERROR)
	    {
	      value = value_x_unop (arg1, op, noside);
	    }

	  if (except.reason < 0)
	    {
	      if (except.error == NOT_FOUND_ERROR)
		break;
	      else
		throw_exception (except);
	    }
	  arg1 = value;
	}

      /* JYG: if print object is on we need to replace the base type
	 with rtti type in order to continue on with successful
	 lookup of member / method only available in the rtti type.  */
      {
        struct type *type = value_type (arg1);
        struct type *real_type;
        int full, top, using_enc;
	struct value_print_options opts;

	get_user_print_options (&opts);
        if (opts.objectprint && TYPE_TARGET_TYPE(type)
            && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_CLASS))
          {
            real_type = value_rtti_indirect_type (arg1, &full, &top,
						  &using_enc);
            if (real_type)
                arg1 = value_cast (real_type, arg1);
          }
      }

      arg3 = value_struct_elt (&arg1, NULL, &exp->elts[pc + 2].string,
			       NULL, "structure pointer");
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	arg3 = value_zero (value_type (arg3), not_lval);
      return arg3;

    case STRUCTOP_MEMBER:
    case STRUCTOP_MPTR:
      if (op == STRUCTOP_MEMBER)
	arg1 = evaluate_subexp_for_address (exp, pos, noside);
      else
	arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      if (noside == EVAL_SKIP)
	goto nosideret;

      type = check_typedef (value_type (arg2));
      switch (TYPE_CODE (type))
	{
	case TYPE_CODE_METHODPTR:
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return value_zero (TYPE_TARGET_TYPE (type), not_lval);
	  else
	    {
	      arg2 = cplus_method_ptr_to_value (&arg1, arg2);
	      gdb_assert (TYPE_CODE (value_type (arg2)) == TYPE_CODE_PTR);
	      return value_ind (arg2);
	    }

	case TYPE_CODE_MEMBERPTR:
	  /* Now, convert these values to an address.  */
	  arg1 = value_cast_pointers (lookup_pointer_type (TYPE_DOMAIN_TYPE (type)),
				      arg1, 1);

	  mem_offset = value_as_long (arg2);

	  arg3 = value_from_pointer (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
				     value_as_long (arg1) + mem_offset);
	  return value_ind (arg3);

	default:
	  error (_("non-pointer-to-member value used "
		   "in pointer-to-member construct"));
	}

    case TYPE_INSTANCE:
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      arg_types = (struct type **) alloca (nargs * sizeof (struct type *));
      for (ix = 0; ix < nargs; ++ix)
	arg_types[ix] = exp->elts[pc + 1 + ix + 1].type;

      expect_type = make_params (nargs, arg_types);
      *(pos) += 3 + nargs;
      arg1 = evaluate_subexp_standard (expect_type, exp, pos, noside);
      xfree (TYPE_FIELDS (expect_type));
      xfree (TYPE_MAIN_TYPE (expect_type));
      xfree (expect_type);
      return arg1;

    case BINOP_CONCAT:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, noside);
      else
	return value_concat (arg1, arg2);

    case BINOP_ASSIGN:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);

      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, noside);
      else
	return value_assign (arg1, arg2);

    case BINOP_ASSIGN_MODIFY:
      (*pos) += 2;
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;
      op = exp->elts[pc + 1].opcode;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, BINOP_ASSIGN_MODIFY, op, noside);
      else if (op == BINOP_ADD && ptrmath_type_p (exp->language_defn,
						  value_type (arg1))
	       && is_integral_type (value_type (arg2)))
	arg2 = value_ptradd (arg1, value_as_long (arg2));
      else if (op == BINOP_SUB && ptrmath_type_p (exp->language_defn,
						  value_type (arg1))
	       && is_integral_type (value_type (arg2)))
	arg2 = value_ptradd (arg1, - value_as_long (arg2));
      else
	{
	  struct value *tmp = arg1;

	  /* For shift and integer exponentiation operations,
	     only promote the first argument.  */
	  if ((op == BINOP_LSH || op == BINOP_RSH || op == BINOP_EXP)
	      && is_integral_type (value_type (arg2)))
	    unop_promote (exp->language_defn, exp->gdbarch, &tmp);
	  else
	    binop_promote (exp->language_defn, exp->gdbarch, &tmp, &arg2);

	  arg2 = value_binop (tmp, arg2, op);
	}
      return value_assign (arg1, arg2);

    case BINOP_ADD:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, noside);
      else if (ptrmath_type_p (exp->language_defn, value_type (arg1))
	       && is_integral_type (value_type (arg2)))
	return value_ptradd (arg1, value_as_long (arg2));
      else if (ptrmath_type_p (exp->language_defn, value_type (arg2))
	       && is_integral_type (value_type (arg1)))
	return value_ptradd (arg2, value_as_long (arg1));
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  return value_binop (arg1, arg2, BINOP_ADD);
	}

    case BINOP_SUB:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, noside);
      else if (ptrmath_type_p (exp->language_defn, value_type (arg1))
	       && ptrmath_type_p (exp->language_defn, value_type (arg2)))
	{
	  /* FIXME -- should be ptrdiff_t */
	  type = builtin_type (exp->gdbarch)->builtin_long;
	  return value_from_longest (type, value_ptrdiff (arg1, arg2));
	}
      else if (ptrmath_type_p (exp->language_defn, value_type (arg1))
	       && is_integral_type (value_type (arg2)))
	return value_ptradd (arg1, - value_as_long (arg2));
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  return value_binop (arg1, arg2, BINOP_SUB);
	}

    case BINOP_EXP:
    case BINOP_MUL:
    case BINOP_DIV:
    case BINOP_INTDIV:
    case BINOP_REM:
    case BINOP_MOD:
    case BINOP_LSH:
    case BINOP_RSH:
    case BINOP_BITWISE_AND:
    case BINOP_BITWISE_IOR:
    case BINOP_BITWISE_XOR:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, noside);
      else
	{
	  /* If EVAL_AVOID_SIDE_EFFECTS and we're dividing by zero,
	     fudge arg2 to avoid division-by-zero, the caller is
	     (theoretically) only looking for the type of the result.  */
	  if (noside == EVAL_AVOID_SIDE_EFFECTS
	      /* ??? Do we really want to test for BINOP_MOD here?
		 The implementation of value_binop gives it a well-defined
		 value.  */
	      && (op == BINOP_DIV
		  || op == BINOP_INTDIV
		  || op == BINOP_REM
		  || op == BINOP_MOD)
	      && value_logical_not (arg2))
	    {
	      struct value *v_one, *retval;

	      v_one = value_one (value_type (arg2));
	      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &v_one);
	      retval = value_binop (arg1, v_one, op);
	      return retval;
	    }
	  else
	    {
	      /* For shift and integer exponentiation operations,
		 only promote the first argument.  */
	      if ((op == BINOP_LSH || op == BINOP_RSH || op == BINOP_EXP)
		  && is_integral_type (value_type (arg2)))
		unop_promote (exp->language_defn, exp->gdbarch, &arg1);
	      else
		binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);

	      return value_binop (arg1, arg2, op);
	    }
	}

    case BINOP_RANGE:
      evaluate_subexp (NULL_TYPE, exp, pos, noside);
      evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      error (_("':' operator used in invalid context"));

    case BINOP_SUBSCRIPT:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	return value_x_binop (arg1, arg2, op, OP_NULL, noside);
      else
	{
	  /* If the user attempts to subscript something that is not an
	     array or pointer type (like a plain int variable for example),
	     then report this as an error.  */

	  arg1 = coerce_ref (arg1);
	  type = check_typedef (value_type (arg1));
	  if (TYPE_CODE (type) != TYPE_CODE_ARRAY
	      && TYPE_CODE (type) != TYPE_CODE_PTR)
	    {
	      if (TYPE_NAME (type))
		error (_("cannot subscript something of type `%s'"),
		       TYPE_NAME (type));
	      else
		error (_("cannot subscript requested type"));
	    }

	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    return value_zero (TYPE_TARGET_TYPE (type), VALUE_LVAL (arg1));
	  else
	    return value_subscript (arg1, value_as_long (arg2));
	}

    case BINOP_IN:
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      type = language_bool_type (exp->language_defn, exp->gdbarch);
      return value_from_longest (type, (LONGEST) value_in (arg1, arg2));

    case MULTI_SUBSCRIPT:
      (*pos) += 2;
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      while (nargs-- > 0)
	{
	  arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
	  /* FIXME:  EVAL_SKIP handling may not be correct.  */
	  if (noside == EVAL_SKIP)
	    {
	      if (nargs > 0)
		{
		  continue;
		}
	      else
		{
		  goto nosideret;
		}
	    }
	  /* FIXME:  EVAL_AVOID_SIDE_EFFECTS handling may not be correct.  */
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      /* If the user attempts to subscript something that has no target
	         type (like a plain int variable for example), then report this
	         as an error.  */

	      type = TYPE_TARGET_TYPE (check_typedef (value_type (arg1)));
	      if (type != NULL)
		{
		  arg1 = value_zero (type, VALUE_LVAL (arg1));
		  noside = EVAL_SKIP;
		  continue;
		}
	      else
		{
		  error (_("cannot subscript something of type `%s'"),
			 TYPE_NAME (value_type (arg1)));
		}
	    }

	  if (binop_user_defined_p (op, arg1, arg2))
	    {
	      arg1 = value_x_binop (arg1, arg2, op, OP_NULL, noside);
	    }
	  else
	    {
	      arg1 = coerce_ref (arg1);
	      type = check_typedef (value_type (arg1));

	      switch (TYPE_CODE (type))
		{
		case TYPE_CODE_PTR:
		case TYPE_CODE_ARRAY:
		case TYPE_CODE_STRING:
		  arg1 = value_subscript (arg1, value_as_long (arg2));
		  break;

		default:
		  if (TYPE_NAME (type))
		    error (_("cannot subscript something of type `%s'"),
			   TYPE_NAME (type));
		  else
		    error (_("cannot subscript requested type"));
		}
	    }
	}
      return (arg1);

    multi_f77_subscript:
      {
	LONGEST subscript_array[MAX_FORTRAN_DIMS];
	int ndimensions = 1, i;
	struct value *array = arg1;

	if (nargs > MAX_FORTRAN_DIMS)
	  error (_("Too many subscripts for F77 (%d Max)"), MAX_FORTRAN_DIMS);

	ndimensions = calc_f77_array_dims (type);

	if (nargs != ndimensions)
	  error (_("Wrong number of subscripts"));

	gdb_assert (nargs > 0);

	/* Now that we know we have a legal array subscript expression 
	   let us actually find out where this element exists in the array.  */

	/* Take array indices left to right.  */
	for (i = 0; i < nargs; i++)
	  {
	    /* Evaluate each subscript; it must be a legal integer in F77.  */
	    arg2 = evaluate_subexp_with_coercion (exp, pos, noside);

	    /* Fill in the subscript array.  */

	    subscript_array[i] = value_as_long (arg2);
	  }

	/* Internal type of array is arranged right to left.  */
	for (i = nargs; i > 0; i--)
	  {
	    struct type *array_type = check_typedef (value_type (array));
	    LONGEST index = subscript_array[i - 1];

	    array = value_subscripted_rvalue (array, index,
					      f77_get_lowerbound (array_type));
	  }

	return array;
      }

    case BINOP_LOGICAL_AND:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	{
	  evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  goto nosideret;
	}

      oldpos = *pos;
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      *pos = oldpos;

      if (binop_user_defined_p (op, arg1, arg2))
	{
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  tem = value_logical_not (arg1);
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos,
				  (tem ? EVAL_SKIP : noside));
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type,
			     (LONGEST) (!tem && !value_logical_not (arg2)));
	}

    case BINOP_LOGICAL_OR:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	{
	  evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  goto nosideret;
	}

      oldpos = *pos;
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      *pos = oldpos;

      if (binop_user_defined_p (op, arg1, arg2))
	{
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  tem = value_logical_not (arg1);
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos,
				  (!tem ? EVAL_SKIP : noside));
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type,
			     (LONGEST) (!tem || !value_logical_not (arg2)));
	}

    case BINOP_EQUAL:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	{
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  tem = value_equal (arg1, arg2);
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) tem);
	}

    case BINOP_NOTEQUAL:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	{
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  tem = value_equal (arg1, arg2);
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) ! tem);
	}

    case BINOP_LESS:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	{
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  tem = value_less (arg1, arg2);
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) tem);
	}

    case BINOP_GTR:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	{
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  tem = value_less (arg2, arg1);
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) tem);
	}

    case BINOP_GEQ:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	{
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  tem = value_less (arg2, arg1) || value_equal (arg1, arg2);
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) tem);
	}

    case BINOP_LEQ:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (binop_user_defined_p (op, arg1, arg2))
	{
	  return value_x_binop (arg1, arg2, op, OP_NULL, noside);
	}
      else
	{
	  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);
	  tem = value_less (arg1, arg2) || value_equal (arg1, arg2);
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) tem);
	}

    case BINOP_REPEAT:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      type = check_typedef (value_type (arg2));
      if (TYPE_CODE (type) != TYPE_CODE_INT)
	error (_("Non-integral right operand for \"@@\" operator."));
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  return allocate_repeat_value (value_type (arg1),
				     longest_to_int (value_as_long (arg2)));
	}
      else
	return value_repeat (arg1, longest_to_int (value_as_long (arg2)));

    case BINOP_COMMA:
      evaluate_subexp (NULL_TYPE, exp, pos, noside);
      return evaluate_subexp (NULL_TYPE, exp, pos, noside);

    case UNOP_PLUS:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return value_x_unop (arg1, op, noside);
      else
	{
	  unop_promote (exp->language_defn, exp->gdbarch, &arg1);
	  return value_pos (arg1);
	}
      
    case UNOP_NEG:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return value_x_unop (arg1, op, noside);
      else
	{
	  unop_promote (exp->language_defn, exp->gdbarch, &arg1);
	  return value_neg (arg1);
	}

    case UNOP_COMPLEMENT:
      /* C++: check for and handle destructor names.  */
      op = exp->elts[*pos].opcode;

      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (unop_user_defined_p (UNOP_COMPLEMENT, arg1))
	return value_x_unop (arg1, UNOP_COMPLEMENT, noside);
      else
	{
	  unop_promote (exp->language_defn, exp->gdbarch, &arg1);
	  return value_complement (arg1);
	}

    case UNOP_LOGICAL_NOT:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return value_x_unop (arg1, op, noside);
      else
	{
	  type = language_bool_type (exp->language_defn, exp->gdbarch);
	  return value_from_longest (type, (LONGEST) value_logical_not (arg1));
	}

    case UNOP_IND:
      if (expect_type && TYPE_CODE (expect_type) == TYPE_CODE_PTR)
	expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      type = check_typedef (value_type (arg1));
      if (TYPE_CODE (type) == TYPE_CODE_METHODPTR
	  || TYPE_CODE (type) == TYPE_CODE_MEMBERPTR)
	error (_("Attempt to dereference pointer "
		 "to member without an object"));
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (unop_user_defined_p (op, arg1))
	return value_x_unop (arg1, op, noside);
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  type = check_typedef (value_type (arg1));
	  if (TYPE_CODE (type) == TYPE_CODE_PTR
	      || TYPE_CODE (type) == TYPE_CODE_REF
	  /* In C you can dereference an array to get the 1st elt.  */
	      || TYPE_CODE (type) == TYPE_CODE_ARRAY
	    )
	    return value_zero (TYPE_TARGET_TYPE (type),
			       lval_memory);
	  else if (TYPE_CODE (type) == TYPE_CODE_INT)
	    /* GDB allows dereferencing an int.  */
	    return value_zero (builtin_type (exp->gdbarch)->builtin_int,
			       lval_memory);
	  else
	    error (_("Attempt to take contents of a non-pointer value."));
	}

      /* Allow * on an integer so we can cast it to whatever we want.
	 This returns an int, which seems like the most C-like thing to
	 do.  "long long" variables are rare enough that
	 BUILTIN_TYPE_LONGEST would seem to be a mistake.  */
      if (TYPE_CODE (type) == TYPE_CODE_INT)
	return value_at_lazy (builtin_type (exp->gdbarch)->builtin_int,
			      (CORE_ADDR) value_as_address (arg1));
      return value_ind (arg1);

    case UNOP_ADDR:
      /* C++: check for and handle pointer to members.  */

      op = exp->elts[*pos].opcode;

      if (noside == EVAL_SKIP)
	{
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  goto nosideret;
	}
      else
	{
	  struct value *retvalp = evaluate_subexp_for_address (exp, pos,
							       noside);

	  return retvalp;
	}

    case UNOP_SIZEOF:
      if (noside == EVAL_SKIP)
	{
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  goto nosideret;
	}
      return evaluate_subexp_for_sizeof (exp, pos);

    case UNOP_CAST:
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
      arg1 = evaluate_subexp (type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (type != value_type (arg1))
	arg1 = value_cast (type, arg1);
      return arg1;

    case UNOP_CAST_TYPE:
      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      type = value_type (arg1);
      arg1 = evaluate_subexp (type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (type != value_type (arg1))
	arg1 = value_cast (type, arg1);
      return arg1;

    case UNOP_DYNAMIC_CAST:
      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      type = value_type (arg1);
      arg1 = evaluate_subexp (type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      return value_dynamic_cast (type, arg1);

    case UNOP_REINTERPRET_CAST:
      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      type = value_type (arg1);
      arg1 = evaluate_subexp (type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      return value_reinterpret_cast (type, arg1);

    case UNOP_MEMVAL:
      (*pos) += 2;
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (exp->elts[pc + 1].type, lval_memory);
      else
	return value_at_lazy (exp->elts[pc + 1].type,
			      value_as_address (arg1));

    case UNOP_MEMVAL_TYPE:
      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      type = value_type (arg1);
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (type, lval_memory);
      else
	return value_at_lazy (type, value_as_address (arg1));

    case UNOP_MEMVAL_TLS:
      (*pos) += 3;
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP)
	goto nosideret;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (exp->elts[pc + 2].type, lval_memory);
      else
	{
	  CORE_ADDR tls_addr;

	  tls_addr = target_translate_tls_address (exp->elts[pc + 1].objfile,
						   value_as_address (arg1));
	  return value_at_lazy (exp->elts[pc + 2].type, tls_addr);
	}

    case UNOP_PREINCREMENT:
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;
      else if (unop_user_defined_p (op, arg1))
	{
	  return value_x_unop (arg1, op, noside);
	}
      else
	{
	  if (ptrmath_type_p (exp->language_defn, value_type (arg1)))
	    arg2 = value_ptradd (arg1, 1);
	  else
	    {
	      struct value *tmp = arg1;

	      arg2 = value_one (value_type (arg1));
	      binop_promote (exp->language_defn, exp->gdbarch, &tmp, &arg2);
	      arg2 = value_binop (tmp, arg2, BINOP_ADD);
	    }

	  return value_assign (arg1, arg2);
	}

    case UNOP_PREDECREMENT:
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;
      else if (unop_user_defined_p (op, arg1))
	{
	  return value_x_unop (arg1, op, noside);
	}
      else
	{
	  if (ptrmath_type_p (exp->language_defn, value_type (arg1)))
	    arg2 = value_ptradd (arg1, -1);
	  else
	    {
	      struct value *tmp = arg1;

	      arg2 = value_one (value_type (arg1));
	      binop_promote (exp->language_defn, exp->gdbarch, &tmp, &arg2);
	      arg2 = value_binop (tmp, arg2, BINOP_SUB);
	    }

	  return value_assign (arg1, arg2);
	}

    case UNOP_POSTINCREMENT:
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;
      else if (unop_user_defined_p (op, arg1))
	{
	  return value_x_unop (arg1, op, noside);
	}
      else
	{
	  arg3 = value_non_lval (arg1);

	  if (ptrmath_type_p (exp->language_defn, value_type (arg1)))
	    arg2 = value_ptradd (arg1, 1);
	  else
	    {
	      struct value *tmp = arg1;

	      arg2 = value_one (value_type (arg1));
	      binop_promote (exp->language_defn, exp->gdbarch, &tmp, &arg2);
	      arg2 = value_binop (tmp, arg2, BINOP_ADD);
	    }

	  value_assign (arg1, arg2);
	  return arg3;
	}

    case UNOP_POSTDECREMENT:
      arg1 = evaluate_subexp (expect_type, exp, pos, noside);
      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)
	return arg1;
      else if (unop_user_defined_p (op, arg1))
	{
	  return value_x_unop (arg1, op, noside);
	}
      else
	{
	  arg3 = value_non_lval (arg1);

	  if (ptrmath_type_p (exp->language_defn, value_type (arg1)))
	    arg2 = value_ptradd (arg1, -1);
	  else
	    {
	      struct value *tmp = arg1;

	      arg2 = value_one (value_type (arg1));
	      binop_promote (exp->language_defn, exp->gdbarch, &tmp, &arg2);
	      arg2 = value_binop (tmp, arg2, BINOP_SUB);
	    }

	  value_assign (arg1, arg2);
	  return arg3;
	}

    case OP_THIS:
      (*pos) += 1;
      return value_of_this (exp->language_defn);

    case OP_TYPE:
      /* The value is not supposed to be used.  This is here to make it
         easier to accommodate expressions that contain types.  */
      (*pos) += 2;
      if (noside == EVAL_SKIP)
        goto nosideret;
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  struct type *type = exp->elts[pc + 1].type;

	  /* If this is a typedef, then find its immediate target.  We
	     use check_typedef to resolve stubs, but we ignore its
	     result because we do not want to dig past all
	     typedefs.  */
	  check_typedef (type);
	  if (TYPE_CODE (type) == TYPE_CODE_TYPEDEF)
	    type = TYPE_TARGET_TYPE (type);
	  return allocate_value (type);
	}
      else
        error (_("Attempt to use a type name as an expression"));

    case OP_TYPEOF:
    case OP_DECLTYPE:
      if (noside == EVAL_SKIP)
	{
	  evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
	  goto nosideret;
	}
      else if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  enum exp_opcode sub_op = exp->elts[*pos].opcode;
	  struct value *result;

	  result = evaluate_subexp (NULL_TYPE, exp, pos,
				    EVAL_AVOID_SIDE_EFFECTS);

	  /* 'decltype' has special semantics for lvalues.  */
	  if (op == OP_DECLTYPE
	      && (sub_op == BINOP_SUBSCRIPT
		  || sub_op == STRUCTOP_MEMBER
		  || sub_op == STRUCTOP_MPTR
		  || sub_op == UNOP_IND
		  || sub_op == STRUCTOP_STRUCT
		  || sub_op == STRUCTOP_PTR
		  || sub_op == OP_SCOPE))
	    {
	      struct type *type = value_type (result);

	      if (TYPE_CODE (check_typedef (type)) != TYPE_CODE_REF)
		{
		  type = lookup_reference_type (type);
		  result = allocate_value (type);
		}
	    }

	  return result;
	}
      else
        error (_("Attempt to use a type as an expression"));

    case OP_TYPEID:
      {
	struct value *result;
	enum exp_opcode sub_op = exp->elts[*pos].opcode;

	if (sub_op == OP_TYPE || sub_op == OP_DECLTYPE || sub_op == OP_TYPEOF)
	  result = evaluate_subexp (NULL_TYPE, exp, pos,
				    EVAL_AVOID_SIDE_EFFECTS);
	else
	  result = evaluate_subexp (NULL_TYPE, exp, pos, noside);

	if (noside != EVAL_NORMAL)
	  return allocate_value (cplus_typeid_type (exp->gdbarch));

	return cplus_typeid (result);
      }

    default:
      /* Removing this case and compiling with gcc -Wall reveals that
         a lot of cases are hitting this case.  Some of these should
         probably be removed from expression.h; others are legitimate
         expressions which are (apparently) not fully implemented.

         If there are any cases landing here which mean a user error,
         then they should be separate cases, with more descriptive
         error messages.  */

      error (_("GDB does not (yet) know how to "
	       "evaluate that kind of expression"));
    }

nosideret:
  return value_from_longest (builtin_type (exp->gdbarch)->builtin_int, 1);
}

/* Evaluate a subexpression of EXP, at index *POS,
   and return the address of that subexpression.
   Advance *POS over the subexpression.
   If the subexpression isn't an lvalue, get an error.
   NOSIDE may be EVAL_AVOID_SIDE_EFFECTS;
   then only the type of the result need be correct.  */

static struct value *
evaluate_subexp_for_address (struct expression *exp, int *pos,
			     enum noside noside)
{
  enum exp_opcode op;
  int pc;
  struct symbol *var;
  struct value *x;
  int tem;

  pc = (*pos);
  op = exp->elts[pc].opcode;

  switch (op)
    {
    case UNOP_IND:
      (*pos)++;
      x = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      /* We can't optimize out "&*" if there's a user-defined operator*.  */
      if (unop_user_defined_p (op, x))
	{
	  x = value_x_unop (x, op, noside);
	  goto default_case_after_eval;
	}

      return coerce_array (x);

    case UNOP_MEMVAL:
      (*pos) += 3;
      return value_cast (lookup_pointer_type (exp->elts[pc + 1].type),
			 evaluate_subexp (NULL_TYPE, exp, pos, noside));

    case UNOP_MEMVAL_TYPE:
      {
	struct type *type;

	(*pos) += 1;
	x = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
	type = value_type (x);
	return value_cast (lookup_pointer_type (type),
			   evaluate_subexp (NULL_TYPE, exp, pos, noside));
      }

    case OP_VAR_VALUE:
      var = exp->elts[pc + 2].symbol;

      /* C++: The "address" of a reference should yield the address
       * of the object pointed to.  Let value_addr() deal with it.  */
      if (TYPE_CODE (SYMBOL_TYPE (var)) == TYPE_CODE_REF)
	goto default_case;

      (*pos) += 4;
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  struct type *type =
	    lookup_pointer_type (SYMBOL_TYPE (var));
	  enum address_class sym_class = SYMBOL_CLASS (var);

	  if (sym_class == LOC_CONST
	      || sym_class == LOC_CONST_BYTES
	      || sym_class == LOC_REGISTER)
	    error (_("Attempt to take address of register or constant."));

	  return
	    value_zero (type, not_lval);
	}
      else
	return address_of_variable (var, exp->elts[pc + 1].block);

    case OP_SCOPE:
      tem = longest_to_int (exp->elts[pc + 2].longconst);
      (*pos) += 5 + BYTES_TO_EXP_ELEM (tem + 1);
      x = value_aggregate_elt (exp->elts[pc + 1].type,
			       &exp->elts[pc + 3].string,
			       NULL, 1, noside);
      if (x == NULL)
	error (_("There is no field named %s"), &exp->elts[pc + 3].string);
      return x;

    default:
    default_case:
      x = evaluate_subexp (NULL_TYPE, exp, pos, noside);
    default_case_after_eval:
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  struct type *type = check_typedef (value_type (x));

	  if (TYPE_CODE (type) == TYPE_CODE_REF)
	    return value_zero (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
			       not_lval);
	  else if (VALUE_LVAL (x) == lval_memory || value_must_coerce_to_target (x))
	    return value_zero (lookup_pointer_type (value_type (x)),
			       not_lval);
	  else
	    error (_("Attempt to take address of "
		     "value not located in memory."));
	}
      return value_addr (x);
    }
}

/* Evaluate like `evaluate_subexp' except coercing arrays to pointers.
   When used in contexts where arrays will be coerced anyway, this is
   equivalent to `evaluate_subexp' but much faster because it avoids
   actually fetching array contents (perhaps obsolete now that we have
   value_lazy()).

   Note that we currently only do the coercion for C expressions, where
   arrays are zero based and the coercion is correct.  For other languages,
   with nonzero based arrays, coercion loses.  Use CAST_IS_CONVERSION
   to decide if coercion is appropriate.  */

struct value *
evaluate_subexp_with_coercion (struct expression *exp,
			       int *pos, enum noside noside)
{
  enum exp_opcode op;
  int pc;
  struct value *val;
  struct symbol *var;
  struct type *type;

  pc = (*pos);
  op = exp->elts[pc].opcode;

  switch (op)
    {
    case OP_VAR_VALUE:
      var = exp->elts[pc + 2].symbol;
      type = check_typedef (SYMBOL_TYPE (var));
      if (TYPE_CODE (type) == TYPE_CODE_ARRAY
	  && !TYPE_VECTOR (type)
	  && CAST_IS_CONVERSION (exp->language_defn))
	{
	  (*pos) += 4;
	  val = address_of_variable (var, exp->elts[pc + 1].block);
	  return value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
			     val);
	}
      /* FALLTHROUGH */

    default:
      return evaluate_subexp (NULL_TYPE, exp, pos, noside);
    }
}

/* Evaluate a subexpression of EXP, at index *POS,
   and return a value for the size of that subexpression.
   Advance *POS over the subexpression.  */

static struct value *
evaluate_subexp_for_sizeof (struct expression *exp, int *pos)
{
  /* FIXME: This should be size_t.  */
  struct type *size_type = builtin_type (exp->gdbarch)->builtin_int;
  enum exp_opcode op;
  int pc;
  struct type *type;
  struct value *val;

  pc = (*pos);
  op = exp->elts[pc].opcode;

  switch (op)
    {
      /* This case is handled specially
         so that we avoid creating a value for the result type.
         If the result type is very big, it's desirable not to
         create a value unnecessarily.  */
    case UNOP_IND:
      (*pos)++;
      val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      type = check_typedef (value_type (val));
      if (TYPE_CODE (type) != TYPE_CODE_PTR
	  && TYPE_CODE (type) != TYPE_CODE_REF
	  && TYPE_CODE (type) != TYPE_CODE_ARRAY)
	error (_("Attempt to take contents of a non-pointer value."));
      type = check_typedef (TYPE_TARGET_TYPE (type));
      return value_from_longest (size_type, (LONGEST) TYPE_LENGTH (type));

    case UNOP_MEMVAL:
      (*pos) += 3;
      type = check_typedef (exp->elts[pc + 1].type);
      return value_from_longest (size_type, (LONGEST) TYPE_LENGTH (type));

    case UNOP_MEMVAL_TYPE:
      (*pos) += 1;
      val = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      type = check_typedef (value_type (val));
      return value_from_longest (size_type, (LONGEST) TYPE_LENGTH (type));

    case OP_VAR_VALUE:
      (*pos) += 4;
      type = check_typedef (SYMBOL_TYPE (exp->elts[pc + 2].symbol));
      return
	value_from_longest (size_type, (LONGEST) TYPE_LENGTH (type));

    default:
      val = evaluate_subexp (NULL_TYPE, exp, pos, EVAL_AVOID_SIDE_EFFECTS);
      return value_from_longest (size_type,
				 (LONGEST) TYPE_LENGTH (value_type (val)));
    }
}

/* Parse a type expression in the string [P..P+LENGTH).  */

struct type *
parse_and_eval_type (char *p, int length)
{
  char *tmp = (char *) alloca (length + 4);
  struct expression *expr;

  tmp[0] = '(';
  memcpy (tmp + 1, p, length);
  tmp[length + 1] = ')';
  tmp[length + 2] = '0';
  tmp[length + 3] = '\0';
  expr = parse_expression (tmp);
  if (expr->elts[0].opcode != UNOP_CAST)
    error (_("Internal error in eval_type."));
  return expr->elts[1].type;
}

int
calc_f77_array_dims (struct type *array_type)
{
  int ndimen = 1;
  struct type *tmp_type;

  if ((TYPE_CODE (array_type) != TYPE_CODE_ARRAY))
    error (_("Can't get dimensions for a non-array type"));

  tmp_type = array_type;

  while ((tmp_type = TYPE_TARGET_TYPE (tmp_type)))
    {
      if (TYPE_CODE (tmp_type) == TYPE_CODE_ARRAY)
	++ndimen;
    }
  return ndimen;
}
@


1.184
log
@	* eval.c (parse_and_eval_long): Make 'exp' const.
	* value.h (parse_and_eval_long): Update.
@
text
@d174 6
a179 4
   If a memory error occurs while evaluating the expression, *RESULTP will
   be set to NULL.  *RESULTP may be a lazy value, if the result could
   not be read from memory.  It is used to determine whether a value
   is user-specified (we should watch the whole value) or intermediate
d194 2
a195 1
		    struct value **resultp, struct value **val_chain)
d216 1
a216 1
      /* Ignore memory errors, we want watchpoints pointing at
d222 2
a223 1
	  break;
@


1.183
log
@	PR exp/15364:
	* eval.c (evaluate_subexp_standard) <STRUCTOP_STRUCT,
	STRUCTOP_PTR>: Return a not_lval value for
	EVAL_AVOID_SIDE_EFFECTS.
	* opencl-lang.c (evaluate_subexp_opencl): Return a not_lval value
	for EVAL_AVOID_SIDE_EFFECTS.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add regression test.
	* gdb.base/exprs.c (null_t_struct): New global.
@
text
@d94 1
a94 1
parse_and_eval_long (char *exp)
@


1.182
log
@	PR c++/9065:
	* NEWS: Update.
	* breakpoint.c (watchpoint_exp_is_const): Add OP_TYPEID.
	* c-exp.y (TYPEID): New token.
	(exp): Add new TYPEID productions.
	(ident_tokens): Add "typeid".
	* cp-abi.c (cplus_typeid, cplus_typeid_type): New functions.
	* cp-abi.h (cplus_typeid, cplus_typeid_type): Declare.
	(struct cp_abi_ops) <get_typeid, get_typeid_type>: New fields.
	* eval.c (evaluate_subexp_standard) <OP_TYPEID>: New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEID>: New
	case.
	* gnu-v3-abi.c (std_type_info_gdbarch_data): New global.
	(build_std_type_info_type, gnuv3_get_typeid_type)
	(gnuv3_get_typeid): New functions.
	(init_gnuv3_ops): Initialize std_type_info_gdbarch_data.  Set
	new fields on ABI object.
	* parse.c (operator_length_standard) <OP_TYPEID>: New case.
	* std-operator.def (OP_TYPEID): New.
gdb/testsuite
	* gdb.cp/typeid.cc: New file.
	* gdb.cp/typeid.exp: New file.
@
text
@d1850 1
a1850 2
      /* Also handle EVAL_AVOID_SIDE_EFFECTS.  */
      return value_struct_elt (&arg1, NULL, &exp->elts[pc + 2].string,
d1852 3
d1904 1
a1904 2
      /* Also handle EVAL_AVOID_SIDE_EFFECTS.  */
      return value_struct_elt (&arg1, NULL, &exp->elts[pc + 2].string,
d1906 3
@


1.181
log
@	PR c++/9197:
	* opencl-lang.c (evaluate_subexp_opencl) <STRUCTOP_STRUCT>: Use
	value_struct_elt, not lookup_struct_elt_type.
	* eval.c (evaluate_subexp_standard) <STRUCTOP_STRUCT,
	STRUCTOP_PTR>: Use value_struct_elt, not lookup_struct_elt_type.
	* expression.h (EVAL_AVOID_SIDE_EFFECTS): Update comment.
gdb/testsuite
	* gdb.cp/m-static.exp: Add constructor ptype tests.
	* gdb.cp/m-static.cc (single_constructor): New class.
	(main): Make instance of single_constructor.
@
text
@d2801 17
@


1.180
log
@	* ax-gdb.c (gen_var_ref): Unconditionally call via computed ops,
	if possible.
	* dwarf2read.c (read_func_scope): Remove old FIXME.
	* eval.c (evaluate_subexp_standard): Check SYMBOL_COMPUTED_OPS,
	not LOC_COMPUTED.
	* findvar.c (symbol_read_needs_frame, default_read_var_value):
	Unconditionally call via computed ops, if possible.
	* printcmd.c (address_info): Unconditionally call via computed ops,
	if possible.
	* stack.c (read_frame_arg): Unconditionally call via computed ops,
	if possible.
	* symtab.c (register_symbol_computed_impl): Sanity check 'ops'.
	* tracepoint.c (scope_info): Unconditionally call via computed ops,
	if possible.
@
text
@d1850 3
a1852 12
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (lookup_struct_elt_type (value_type (arg1),
						   &exp->elts[pc + 2].string,
						   0),
			   lval_memory);
      else
	{
	  struct value *temp = arg1;

	  return value_struct_elt (&temp, NULL, &exp->elts[pc + 2].string,
				   NULL, "structure");
	}
d1902 3
a1904 12
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	return value_zero (lookup_struct_elt_type (value_type (arg1),
						   &exp->elts[pc + 2].string,
						   0),
			   lval_memory);
      else
	{
	  struct value *temp = arg1;

	  return value_struct_elt (&temp, NULL, &exp->elts[pc + 2].string,
				   NULL, "structure pointer");
	}
@


1.179
log
@	* ada-lang.c (ada_read_renaming_var_value): Pass const
	pointer to expression string to parse_exp_1.
	(create_excep_cond_exprs): Likewise.
	* ax-gdb.c (agent_eval_command_one): Likewise.
	(maint_agent_printf_command): Likewise.
	Constify much of the string handling/parsing.
	* breakpoint.c (set_breakpoint_condition): Pass const
	pointer to expression string to parse_exp_1.
	(update_watchpoint): Likewise.
	(parse_cmd_to_aexpr): Constify string handling.
	Pass const pointer to parse_exp_1.
	(init_breakpoint_sal): Pass const pointer to parse_exp_1.
	(find_condition_and_thread): Likewise.
	Make TOK const.
	(watch_command_1): Make "arg" const.
	Constify string handling.
	Copy the expression string instead of changing the input
	string.
	(update_breakpoint_location): Pass const pointer to
	parse_exp_1.
	* eval.c (parse_and_eval_address): Make "exp" const.
	(parse_to_comma_and_eval): Make "expp" const.
	(parse_and_eval): Make "exp" const.
	* expression.h (parse_expression): Make argument const.
	(parse_exp_1): Make first argument const.
	* findcmd.c (parse_find_args): Treat "args" as const.
	* linespec.c (parse_linespec): Pass const pointer to
	linespec_expression_to_pc.
	(linespec_expression_to_pc): Make "exp_ptr" const.
	* parse.c (parse_exp_1): Make "stringptr" const.
	Make a copy of the expression to pass to parse_exp_in_context until
	this whole interface can be constified.
	(parse_expression): Make "string" const.
	* printcmd.c (ui_printf): Treat "arg" as const.
	Handle const strings.
	* tracepoint.c (validate_actionline): Pass const pointer to
	all calls to parse_exp_1.
	(encode_actions_1): Likewise.
	* value.h (parse_to_comma_and_eval): Make argument const.
	(parse_and_eval_address): Likewise.
	(parse_and_eval): Likewise.
	* varobj.c (varobj_create): Pass const pointer to parse_exp_1.
	(varobj_set_value): Likewise.
	* cli/cli-cmds.c (disassemble_command): Treat "arg" as const and
	constify string handling.
	Pass const pointers to parse_and_eval_address and
	parse_to_comman_and_eval.
	* cli/cli-utils.c (skip_to_space): Rename to ...
	(skip_to_space_const): ... this. Handle const strings.
	* cli/cli-utils.h (skip_to_space): Turn into macro which invokes
	skip_to_space_const.
	(skip_to_space_const): Declare.
	* common/format.c (parse_format_string): Make "arg" const.
	Handle const strings.
	* common/format.h (parse_format_string): Make "arg" const.
	* gdbserver/ax.c (ax_printf): Make "format" const.
	* python/python.c (gdbpy_parse_and_eval): Do not make a copy
	of the expression string.
@
text
@d795 1
a795 1
	if (SYMBOL_CLASS (sym) != LOC_COMPUTED
@


1.178
log
@Fix ptype bug actually exercised in userdef.exp

I happened to notice a bug with ptype &Ref, and found out userdef.exp
actually exercises the bug.  With:

class Container
{
public:
  Member m;

  Member& operator* ();
};

Member& Container::operator* ()
{
  return this->m;
}

And 'c' is of type Container:

(gdb) p c
$1 = {m = {z = -9192}}
(gdb) p *c
$2 = (Member &) @@0x7fffffffda20: {z = -9192}
(gdb) ptype *c
type = class Member {
  public:
    int z;
} &

(gdb) p &*c
$3 = (Member *) 0x7fffffffda20

(gdb) ptype &*c
type = class Member {
  public:
    int z;
} &*
(gdb)

Notice that last print (&*c) on says the type is a pointer - that's
how you get the address behind a reference.  But notice the last ptype
instead says the type of the same expression is a pointer _reference_.
This looks like a bug to me.

This patch fixes it.  The issue is that we're entering the VALUE_LVAL
(x) == lval_memory branch by mistake for references.  The fix is just
to swap the tests so references are checked first, like value_addr
also handles references first.

Tested on x86_64 Fedora 17.

2013-02-14  Pedro Alves  <palves@@redhat.com>

	* eval.c (evaluate_subexp_for_address) <default_case_after_eval,
	EVAL_AVOID_SIDE_EFFECTS>: Swap and handle TYPE_CODE_REF before
	lval_memory.

2013-02-14  Pedro Alves  <palves@@redhat.com>

	* gdb.cp/userdef.exp (ptype &*c): Don't expect an &.
@
text
@d79 1
a79 1
parse_and_eval_address (char *exp)
d107 1
a107 1
parse_and_eval (char *exp)
d124 1
a124 1
parse_to_comma_and_eval (char **expp)
@


1.177
log
@	* valops.c (find_overload_match): Remove unused argument 'lax'.
	* value.h: Remove unused argument 'lax' from the declaration of
	find_overload_match.
	* eval.c (value_subexp_standard): Do not pass a 'lax' argument
	to find_overload_match.
	* valarith.c (value_user_defined_cpp_op): Do not pass a 'lax'
	argument to find_overload_match.
@
text
@d2932 4
a2935 1
	  if (VALUE_LVAL (x) == lval_memory || value_must_coerce_to_target (x))
a2937 3
	  else if (TYPE_CODE (type) == TYPE_CODE_REF)
	    return value_zero (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
			       not_lval);
@


1.176
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@a1592 1
			       0,          /* strict match */
a1627 1
					  0,      /* strict match */
a1698 1
					  0,           /* strict match */
@


1.175
log
@gdb/
2012-11-29  Yao Qi  <yao@@codesourcery.com>
	    Tom Tromey  <tromey@@redhat.com>

	* eval.c (evaluate_subexp_standard): Get the correct pointer
	type for TYPE_CODE_MEMBERPTR.
@
text
@d3 1
a3 1
   Copyright (C) 1986-2003, 2005-2012 Free Software Foundation, Inc.
@


1.174
log
@gdb/
2012-11-27  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* eval.c (evaluate_subexp_standard): Add handling of
	TYPE_CODE_MEMBERPTR when calling functions.  Correct the
	result of ptype for calling a TYPE_CODE_METHODPTR.

gdb/testsuite/
2012-11-27  Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb.cp/member-ptr.cc (class Diamond): Add func_ptr.
	(func): New function.
	(main): Initialize diamond.func_ptr and add diamond_pfunc_ptr.
	* gdb.cp/member-ptr.exp: Add new tests for ptype and for
	pointers to members with pointer-to-function type.
@
text
@d1407 2
d1415 1
a1415 1
	      arg1 = value_from_pointer (type_ptr,
@


1.173
log
@gdb:

2012-11-02  Yao Qi  <yao@@codesourcery.com>

	* std-operator.def: Remove OP_LABELED.
	* eval.c: Remove the declaration of 'get_label'.
	(get_label): Remove.
	(evaluate_struct_tuple): Remove code handling OP_LABELED.
	Update comment.
	Remove local variable 'variantno' and related code.
	Replace 'substruct_type' with 'struct_type'.  Replace 'subfieldno'
	with 'fieldno'.
	* expprint.c (print_subexp_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.

gdb/testsuite:

2012-11-02  Yao Qi  <yao@@codesourcery.com>

	* gdb.base/setvar.exp: Test setting nested struct.
	* gdb.base/setvar.c (v_struct3): New.
@
text
@a1366 1
	  nargs++;
d1390 7
a1396 4
	  if (TYPE_CODE (check_typedef (value_type (arg1)))
	      != TYPE_CODE_METHODPTR)
	    error (_("Non-pointer-to-member value used in pointer-to-member "
		     "construct"));
d1398 6
a1403 1
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
d1405 5
a1409 1
	      struct type *method_type = check_typedef (value_type (arg1));
d1411 6
a1416 1
	      arg1 = value_zero (method_type, not_lval);
d1419 2
a1420 4
	    arg1 = cplus_method_ptr_to_value (&arg2, arg1);

	  /* Now, say which argument to start evaluating from.  */
	  tem = 2;
d1671 1
a1671 1
	  argvec[1] = arg2;
@


1.172
log
@	* eval.c (evaluate_subexp_standard): Eliminate single-use
	variable LOWER.
@
text
@a58 2
static char *get_label (struct expression *, int *);

d281 2
a282 21
/* If the next expression is an OP_LABELED, skips past it,
   returning the label.  Otherwise, does nothing and returns NULL.  */

static char *
get_label (struct expression *exp, int *pos)
{
  if (exp->elts[*pos].opcode == OP_LABELED)
    {
      int pc = (*pos)++;
      char *name = &exp->elts[pc + 2].string;
      int tem = longest_to_int (exp->elts[pc + 1].longconst);

      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      return name;
    }
  else
    return NULL;
}

/* This function evaluates tuples (in (the deleted) Chill) or
   brace-initializers (in C/C++) for structure types.  */
a289 1
  struct type *substruct_type = struct_type;
a291 2
  int variantno = -1;
  int subfieldno = -1;
a294 1
      int pc = *pos;
a295 1
      int nlabels = 0;
d299 41
a339 29
      /* Skip past the labels, and count them.  */
      while (get_label (exp, pos) != NULL)
	nlabels++;

      do
	{
	  char *label = get_label (exp, &pc);

	  if (label)
	    {
	      for (fieldno = 0; fieldno < TYPE_NFIELDS (struct_type);
		   fieldno++)
		{
		  const char *field_name =
		    TYPE_FIELD_NAME (struct_type, fieldno);

		  if (field_name != NULL && strcmp (field_name, label) == 0)
		    {
		      variantno = -1;
		      subfieldno = fieldno;
		      substruct_type = struct_type;
		      goto found;
		    }
		}
	      for (fieldno = 0; fieldno < TYPE_NFIELDS (struct_type);
		   fieldno++)
		{
		  const char *field_name =
		    TYPE_FIELD_NAME (struct_type, fieldno);
a340 93
		  field_type = TYPE_FIELD_TYPE (struct_type, fieldno);
		  if ((field_name == 0 || *field_name == '\0')
		      && TYPE_CODE (field_type) == TYPE_CODE_UNION)
		    {
		      variantno = 0;
		      for (; variantno < TYPE_NFIELDS (field_type);
			   variantno++)
			{
			  substruct_type
			    = TYPE_FIELD_TYPE (field_type, variantno);
			  if (TYPE_CODE (substruct_type) == TYPE_CODE_STRUCT)
			    {
			      for (subfieldno = 0;
				 subfieldno < TYPE_NFIELDS (substruct_type);
				   subfieldno++)
				{
				  if (strcmp(TYPE_FIELD_NAME (substruct_type,
							      subfieldno),
					     label) == 0)
				    {
				      goto found;
				    }
				}
			    }
			}
		    }
		}
	      error (_("there is no field named %s"), label);
	    found:
	      ;
	    }
	  else
	    {
	      /* Unlabelled tuple element - go to next field.  */
	      if (variantno >= 0)
		{
		  subfieldno++;
		  if (subfieldno >= TYPE_NFIELDS (substruct_type))
		    {
		      variantno = -1;
		      substruct_type = struct_type;
		    }
		}
	      if (variantno < 0)
		{
		  fieldno++;
		  /* Skip static fields.  */
		  while (fieldno < TYPE_NFIELDS (struct_type)
			 && field_is_static (&TYPE_FIELD (struct_type,
							  fieldno)))
		    fieldno++;
		  subfieldno = fieldno;
		  if (fieldno >= TYPE_NFIELDS (struct_type))
		    error (_("too many initializers"));
		  field_type = TYPE_FIELD_TYPE (struct_type, fieldno);
		  if (TYPE_CODE (field_type) == TYPE_CODE_UNION
		      && TYPE_FIELD_NAME (struct_type, fieldno)[0] == '0')
		    error (_("don't know which variant you want to set"));
		}
	    }

	  /* Here, struct_type is the type of the inner struct,
	     while substruct_type is the type of the inner struct.
	     These are the same for normal structures, but a variant struct
	     contains anonymous union fields that contain substruct fields.
	     The value fieldno is the index of the top-level (normal or
	     anonymous union) field in struct_field, while the value
	     subfieldno is the index of the actual real (named inner) field
	     in substruct_type.  */

	  field_type = TYPE_FIELD_TYPE (substruct_type, subfieldno);
	  if (val == 0)
	    val = evaluate_subexp (field_type, exp, pos, noside);

	  /* Now actually set the field in struct_val.  */

	  /* Assign val to field fieldno.  */
	  if (value_type (val) != field_type)
	    val = value_cast (field_type, val);

	  bitsize = TYPE_FIELD_BITSIZE (substruct_type, subfieldno);
	  bitpos = TYPE_FIELD_BITPOS (struct_type, fieldno);
	  if (variantno >= 0)
	    bitpos += TYPE_FIELD_BITPOS (substruct_type, subfieldno);
	  addr = value_contents_writeable (struct_val) + bitpos / 8;
	  if (bitsize)
	    modify_field (struct_type, addr,
			  value_as_long (val), bitpos % 8, bitsize);
	  else
	    memcpy (addr, value_contents (val),
		    TYPE_LENGTH (value_type (val)));
	}
      while (--nlabels > 0);
@


1.171
log
@gdb/
	* gdbtypes.h (enum type_code): Define TYPE_CODE_BITSTRING -1.
	* arm-tdep.c (arm_type_align): Remove code handling TYPE_CODE_BITSTRING.
	* c-typeprint.c (c_type_print_varspec_prefix): Likewise.
	(c_type_print_varspec_suffix): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* f-typeprint.c (f_type_print_varspec_prefix): Likewise.
	(f_type_print_varspec_suffix): Likewise.
	* gdbtypes.c (is_scalar_type): Likewise.
	(recursive_dump_type): Likewise.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix): Likewise.
	(pascal_type_print_varspec_suffix): Likewise.
	(pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_val_print): Likewise.
	* valops.c (value_slice): Likewise.
	* valprint.c (scalar_type_p): Likewise.
	* valarith.c (value_bitstring_subscript): Remove.
	(value_concat): Remove code handling TYPE_CODE_BITSTRING.
	Remove comment on TYPE_CODE_BITSTRING.

	* stabsread.c (read_type): Don't set TYPE_CODE (type) to
	TYPE_CODE_BITSTRING.

	* python/py-type.c (pyty_codes): Move ENTRY (TYPE_CODE_BITSTRING) to
	slot 0.

gdb/doc:
	* gdb.texinfo (Types In Python): Mention gdb.TYPE_CODE_BITSTRING
	is deprecated.
@
text
@a812 1
  int lower;
d2372 2
a2373 2
	    lower = f77_get_lowerbound (array_type);
	    array = value_subscripted_rvalue (array, index, lower);
@


1.170
log
@gdb/
	* std-operator.def: Remove TERNOP_SLICE_COUNT.
	* breakpoint.c (watchpoint_exp_is_const): Remove handling to
	TERNOP_SLICE_COUNT.
	* eval.c (evaluate_subexp_standard): Likewise.
	* expprint.c (print_subexp_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
@
text
@a2325 6
		case TYPE_CODE_BITSTRING:
		  type = language_bool_type (exp->language_defn, exp->gdbarch);
		  arg1 = value_bitstring_subscript (type, arg1,
						    value_as_long (arg2));
		  break;

@


1.169
log
@gdb/
	* std-operator.def: Remove OP_BITSTRING.
	* breakpoint.c (watchpoint_exp_is_const): Update.
	* eval.c (evaluate_subexp_standard): Remove handling to
	OP_BITSTRING.
	* expprint.c (print_subexp_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
	* valops.c (value_bitstring): Remove.
	* value.h: Remove the declaration of 'value_bitstring'.
@
text
@a1142 11
    case TERNOP_SLICE_COUNT:
      {
	struct value *array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
	int lowbound
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
	int length
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));

	return value_slice (array, lowbound, length);
      }

@


1.168
log
@	* eval.c (evaluate_subexp_standard): Fix thinko in handling
	UNOP_MEMVAL_TYPE.
	* expprint.c (print_subexp_standard, case OP_TYPE): New.
	(print_subexp_standard, case UNOP_CAST_TYPE): Don't increment pos.
	(print_subexp_standard, case UNOP_DYNAMIC_CAST): Ditto.
	(print_subexp_standard, case UNOP_REINTERPRET_CAST): Ditto.
	(print_subexp_standard, case UNOP_MEMVAL_TYPE): Ditto.
	(dump_subexp_body_standard, case UNOP_DYNAMIC_CAST): Don't increment
	elt.
	(dump_subexp_body_standard, case UNOP_REINTERPRET_CAST): Ditto.
	(dump_subexp_body_standard, case UNOP_CAST_TYPE): Ditto.
	(dump_subexp_body_standard, case UNOP_MEMVAL_TYPE): Ditto.
	(dump_prefix_expression): Handle OP_TYPE.

	testsuite/
	* gdb.base/debug-expr.c: New file.
	* gdb.base/debug-expr.exp: New file.
	* gdb.base/exprs.exp: Test {type} casts.
	* gdb.cp/debug-expr.exp: New file.
@
text
@a972 10
    case OP_BITSTRING:
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos)
	+= 3 + BYTES_TO_EXP_ELEM ((tem + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT);
      if (noside == EVAL_SKIP)
	goto nosideret;
      return value_bitstring (&exp->elts[pc + 2].string, tem,
			      builtin_type (exp->gdbarch)->builtin_int);
      break;

@


1.167
log
@	PR exp/13206:
	* ax-gdb.c (gen_expr) <OP_TYPEOF, OP_DECLTYPE>: New cases.
	* breakpoint.c (watchpoint_exp_is_const) <OP_TYPEOF,
	OP_DECLTYPE>: New cases.
	* c-exp.y (TYPEOF, DECLTYPE): New tokens.
	(type_exp): Add new productions.
	(ident_tokens): Add __typeof__, typeof, __typeof, __decltype,
	and decltype.
	* eval.c (evaluate_subexp_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* expprint.c (dump_subexp_body_standard) <OP_TYPEOF,
	OP_DECLTYPE>: New case.
	* parse.c (operator_length_standard) <OP_TYPEOF, OP_DECLTYPE>:
	New case.
	* std-operator.def (OP_TYPEOF, OP_DECLTYPE): New constants.
	* varobj.c (varobj_create): Handle OP_TYPEOF, OP_DECLTYPE.
gdb/testsuite
	* gdb.cp/casts.exp: Add tests for typeof and decltype.
	* gdb.cp/casts.cc (decltype): New function.
	(main): Use it.
@
text
@d2754 1
a2754 1
	return value_zero (exp->elts[pc + 1].type, lval_memory);
d2756 1
a2756 2
	return value_at_lazy (exp->elts[pc + 1].type,
			      value_as_address (arg1));
@


1.166
log
@	* ax-gdb.c (gen_expr): Handle UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE.
	* breakpoint.c (watchpoint_exp_is_const): Handle UNOP_CAST_TYPE,
	UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.
	* c-exp.y (exp): Emit UNOP_MEMVAL_TYPE, UNOP_CAST_TYPE.  Update
	for changes to UNOP_REINTERPRET_CAST, UNOP_DYNAMIC_CAST.  Use
	type_exp production where appropriate.
	* eval.c (evaluate_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_DYNAMIC_CAST, UNOP_REINTERPRET_CAST>: Update.
	<UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_address) <UNOP_MEMVAL_TYPE>: New case.
	(evaluate_subexp_for_sizeof) <UNOP_MEMVAL_TYPE>: New case.
	* expprint.c (print_subexp_standard) <UNOP_CAST_TYPE>: New case.
	<UNOP_MEMVAL_TYPE>: New case.
	(dump_subexp_body_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* parse.c (operator_length_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: Update.
	<UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE>: New cases.
	* stack.c (return_command): Also check for UNOP_CAST_TYPE.
	* std-operator.def (UNOP_CAST_TYPE, UNOP_MEMVAL_TYPE): New
	constants.
@
text
@d2903 39
@


1.165
log
@	* c-exp.y (check_parameter_typelist): New function.
	(parameter_typelist): Call it.
	* eval.c (make_params): Handle '(void)' case.
	* gdbtypes.c (lookup_function_type_with_arguments): Handle
	'(void)' case.
testsuite
	* gdb.base/whatis.exp: Add error checks for improper 'void' uses.
	* gdb.base/callfuncs.exp: Add cast-based test.
	* gdb.base/callfuncs.c (voidfunc): New function.
@
text
@d2710 10
d2721 2
a2722 2
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
d2729 2
a2730 2
      (*pos) += 2;
      type = exp->elts[pc + 1].type;
d2747 12
d2961 11
d3114 6
@


1.164
log
@	* c-exp.y (DOTDOTDOT): New token.
	(func_mod, exp): Use parameter_typelist.
	(parameter_typelist): New production.
	(tokentab3): Add "..." token.
	* eval.c (make_params): Handle varargs.
	* gdbtypes.c (lookup_function_type_with_arguments): Handle
	varargs.
testsuite
	* gdb.base/whatis.exp: Add test.
@
text
@d772 1
a772 1
  if (num_types > 0 && param_types[num_types - 1] == NULL)
d774 13
a786 2
      --num_types;
      TYPE_VARARGS (type) = 1;
d788 1
@


1.163
log
@	PR macros/7961:
	* varobj.c (varobj_create): Update.
	(varobj_set_value): Update.
	* tracepoint.c (validate_actionline): Update.
	(encode_actions_1): Update.
	* parse.c (parse_exp_1): Add 'pc' argument.
	(parse_exp_in_context): Add 'pc' argument.  Change how
	expression_context_pc is set.
	(parse_expression): Update.
	(parse_field_expression): Update.
	* expression.h (parse_exp_1): Update.
	* eval.c (parse_to_comma_and_eval): Update.
	* breakpoint.c (set_breakpoint_condition): Update.
	(update_watchpoint): Update.
	(init_breakpoint_sal): Update
	(find_condition_and_thread): Update.
	(watch_command_1): Update.
	(update_breakpoint_locations): Update.
	* ada-lang.c (ada_read_renaming_var_value): Update.
	(create_excep_cond_exprs): Update.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add breakpoint comment.
	* gdb.base/macscp.exp (maybe_kfail): Add test for macro scope.
@
text
@d772 5
@


1.162
log
@	PR c++/7173:
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Return early for Java
	types.
	* value.h (value_cast_pointers): Update.
	* valops.c (value_cast_pointers): Add 'subclass_check' argument.
	(value_cast): Update.
	(update_search_result): New function.
	(do_search_struct_field): New, from search_struct_field.  Check
	for ambiguous results.
	(search_struct_field): Rewrite.
	* infcall.c (value_arg_coerce): Update.
	* eval.c (evaluate_subexp_standard) <STRUCTOP_MEMBER>: Use
	value_cast_pointers.
	* ada-lang.c (ada_convert_actual): Update.
testsuite
	* gdb.cp/inherit.exp (test_print_mi_members): Expect errors.
	Remove kfails.
	(test_print_mi_member_types): Likewise.
@
text
@d128 1
a128 1
  struct expression *expr = parse_exp_1 (expp, (struct block *) 0, 1);
@


1.161
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d2050 2
a2051 2
	  arg1 = value_cast (lookup_pointer_type (TYPE_DOMAIN_TYPE (type)),
			     arg1);
@


1.160
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@d796 1
a796 1
  int upper, lower;
@


1.159
log
@gdb/
	* c-valprint.c (c_value_print): Use value_rtti_indirect_type
	instead of value_rtti_target_type.
	* eval.c (evaluate_subexp_standard): Use value_rtti_indirect_type
	instead of value_rtti_target_type.
	* typeprint.c (whatis_exp): Use value_rtti_indirect_type instead of
	value_rtti_target_type.
	* valops.c (value_ind): Extract function readjust_indirect_value_type.
	(value_rtti_target_type): Rename to ...
	(value_rtti_indirect_type): ... here and make it indirect.  Update
	function comment.
	* value.c (readjust_indirect_value_type): New function.
	(coerce_ref): Support for enclosing type setting for references
	with readjust_indirect_value_type.
	* value.h (readjust_value_type): New declaration.
	(value_rtti_target_type): Rename to ...
	(value_rtti_indirect_type): ... here.
@
text
@d1361 1
a1361 2
	    struct_return = using_struct_return (exp->gdbarch,
						 value_type (method),
@


1.158
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@d2004 2
a2005 1
            real_type = value_rtti_target_type (arg1, &full, &top, &using_enc);
a2006 6
              {
                if (TYPE_CODE (type) == TYPE_CODE_PTR)
                  real_type = lookup_pointer_type (real_type);
                else
                  real_type = lookup_reference_type (real_type);

a2007 1
              }
@


1.157
log
@	* Makefile.in (SFILES): Remove wrapper.c.
	(HFILES_NO_SRCDIR): Remove wrapper.h.
	(COMMON_OBS): Remove wrapper.o.
	* cli/cli-interp.c: Don't inlude wrapper.h.
	* corelow.c: Likewise.
	(core_open): Replace gdb_target_find_new_threads with
	TRY_CATCH around target_find_new_threads.
	* eval.c (fetch_subexp_value): Likewise for value_fetch_lazy.
	* gdbtypes.c (safe_parse_type): Likewise for parse_and_eval_type.
	* varobj.c (varobj_create): Likewise for parse_exp_1 and
	evaluate_expression.
	(varobj_set_value): Likewise for evaluate_expression and
	value_assign.
	(install_new_variable): Likewise for value_fetch_lazy.
	(adjust_value_for_child_access): Likewise for value_ind.
	(c_describe_child): Likewise for value_subscript and
	value_ind.
	(c_value_of_root): Likewise for evaluate_expression.
	* wrapper.c: Remove.
	* wrapper.h: Remove.
@
text
@d338 2
a339 1
		  char *field_name = TYPE_FIELD_NAME (struct_type, fieldno);
d352 2
a353 1
		  char *field_name = TYPE_FIELD_NAME (struct_type, fieldno);
@


1.156
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@a43 1
#include "wrapper.h"
d236 15
a250 3
  if (result != NULL
      && (!value_lazy (result) || gdb_value_fetch_lazy (result)))
    *valp = result;
@


1.155
log
@	PR c++/13225
	* eval.c (evaluate_subexp_standard): Do not construct
	an array of types; pass the value array directly to
	find_overload_match.
	* gdbtypes.h (NULL_POINTER_CONVERSION_BADNESS): Declare.
	(rank_function): Take an array of values instead of types.
	(rank_one_type): Add struct value * parameter.
	* gdbtypes.c (NULL_POINTER_CONVERSION_BADNESS): Define.
	(rank_function): For each argument, pass the argument's
	value to rank_one_type.
	(rank_one_type): Add VALUE parameter.
	If the parameter type is a pointer and the argument type
	is an integer, return NULL_POINTER_CONVERSION_BADNESS if
	VALUE is zero.
	Update all calls to rank_one_type, passing NULL for new
	VALUE parameter.
	* valarith.c (value_user_defined_cpp_op): Do not construct
	an array of types; pass the value array directly to
	find_overload_match.
	* valops.c (find_overload_method_list): Take an array of
	values instead of types.
	Save the type of OBJP for later use.
	Update calls to find_oload_champ, and find_oload_champ_namespace.
	(find_oload_champ_namespace): Take an array of values instead
	of types.
	(find_oload_champ_namespace_loop): Likewise.
	(find_oload_champ): Likewise.
	(classify_oload_match): Inspect all arguments
	until INCOMPATIBLE is found. Return the worst badness found
	otherwise.
	(compare_parameters): Update call to rank_one_type.
	* value.h (find_overload_match): Take an array of values instead
	of types.
@
text
@d3 1
a3 3
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008,
   2009, 2010, 2011 Free Software Foundation, Inc.
@


1.155.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1986-2003, 2005-2012 Free Software Foundation, Inc.
@


1.154
log
@gdb/
	Support @@entry in input expressions.
	* c-exp.y (ENTRY, unknown_cpp_name): New.
	(exp: UNKNOWN_CPP_NAME): Change to `exp: unknown_cpp_name'.
	(unknown_cpp_name: UNKNOWN_CPP_NAME, unknown_cpp_name: ENTRY)
	(variable: name_not_typename '@@' ENTRY, name: ENTRY)
	(name_not_typename: ENTRY): New.
	(yylex): Recognize ENTRY.
	* eval.c (evaluate_subexp_standard): Support also OP_VAR_ENTRY_VALUE.
	* expprint.c (print_subexp_standard, dump_subexp_body_standard):
	Likewise.
	* parse.c (operator_length_standard): Likewise.
	* std-operator.def: New operator OP_VAR_ENTRY_VALUE.

gdb/doc/
	Support @@entry in input expressions.
	* gdb.texinfo (Variables): Describe @@entry names suffix.
	(Print Settings): Add anchor for `set print entry-values'.

gdb/testsuite/
	Support @@entry in input expressions.
	* gdb.arch/amd64-entry-value.exp (entry: p i@@entry, entry: p j@@entry)
	(entry_stack: p s1@@entry, entry_stack: p s2@@entry)
	(entry_stack: p d9@@entry, entry_stack: p da@@entry, tailcall: p i@@entry)
	(tailcall: p j@@entry): New tests.
	* gdb.cp/koenig.cc (A::entry): New function.
	(main): Call it.
	* gdb.cp/koenig.exp (p entry (c)): New test.
@
text
@d1677 1
a1677 7
          /* Prepare list of argument types for overload resolution.  */
          arg_types = (struct type **)
	    alloca (nargs * (sizeof (struct type *)));
          for (ix = 1; ix <= nargs; ix++)
            arg_types[ix - 1] = value_type (argvec[ix]);

          find_overload_match (arg_types, nargs, func_name,
d1713 1
a1713 7
	      /* Prepare list of argument types for overload resolution.  */
	      arg_types = (struct type **)
		alloca (nargs * (sizeof (struct type *)));
	      for (ix = 1; ix <= nargs; ix++)
		arg_types[ix - 1] = value_type (argvec[ix]);

	      (void) find_overload_match (arg_types, nargs, tstr,
d1784 1
a1784 7
	      /* Prepare list of argument types for overload resolution.  */
	      arg_types = (struct type **)
		alloca (nargs * (sizeof (struct type *)));
	      for (ix = 1; ix <= nargs; ix++)
		arg_types[ix - 1] = value_type (argvec[ix]);

	      (void) find_overload_match (arg_types, nargs,
@


1.153
log
@gdb/
	* eval.c (evaluate_subexp_standard) <OP_THIS>: Update the value_of_this
	caller to value_of_this.
	* p-exp.y: Update the value_of_this caller to value_of_this_silent.
	Twice.
	* valops.c (value_of_this): Remove parameter complain and variable ret.
	Update function comment.  Never return NULL by this code.
	(value_of_this_silent): New function.
	* value.h (value_of_this): Remove parameter complain.
	(value_of_this_silent): New declaration.
@
text
@d863 21
@


1.152
log
@gdb/
2011-07-27  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* eval.c (evaluate_subexp_standard): Remove not_lval from all calls of
	value_one.
	* valops.c (value_one): Remove parameter lv.  Do not pass it to itself.
	Assert the result kind.
	* value.h (value_one): Remove parameter lv.
@
text
@d2833 1
a2833 1
      return value_of_this (exp->language_defn, 1);
@


1.151
log
@	* value.h (value_of_this): Update.
	(value_of_local): Remove.
	* valops.c (value_of_this): Rename from value_of_local.  Change
	parameters.
	* p-exp.y (exp): Update.
	(variable): Likewise.
	* eval.c (evaluate_subexp_standard) <OP_THIS>: Use value_of_this.
@
text
@d2201 1
a2201 1
	      v_one = value_one (value_type (arg2), not_lval);
d2745 1
a2745 1
	      arg2 = value_one (value_type (arg1), not_lval);
d2769 1
a2769 1
	      arg2 = value_one (value_type (arg1), not_lval);
d2795 1
a2795 1
	      arg2 = value_one (value_type (arg1), not_lval);
d2822 1
a2822 1
	      arg2 = value_one (value_type (arg1), not_lval);
@


1.150
log
@	* valops.c (value_of_local): Complain if NAME is NULL.
	* std-operator.def (OP_OBJC_SELF): Remove.
	* parse.c (operator_length_standard) <OP_OBJC_SELF>: Remove.
	* objc-exp.y (name_not_typename): Use OP_THIS.
	* expprint.c (print_subexp_standard) <OP_THIS>: Print language's
	name for "this".
	<OP_OBJC_SELF>: Remove.
	* eval.c (evaluate_subexp_standard) <OP_OBJC_SELF>: Remove.
@
text
@d2833 1
a2833 1
      return value_of_local (exp->language_defn->la_name_of_this, 1);
@


1.149
log
@gdb/
	GDB internal type support for STT_GNU_IFUNC.
	* elfread.c (record_minimal_symbol): Support mst_text_gnu_ifunc.
	(elf_symtab_read): Set mst_text_gnu_ifunc for
	BSF_GNU_INDIRECT_FUNCTION.
	* eval.c (evaluate_subexp_standard): Support TYPE_GNU_IFUNC.
	* gdbtypes.c (init_type): Support TYPE_FLAG_GNU_IFUNC,
	builtin_func_func, nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* gdbtypes.h (enum type_flag_value): New entry TYPE_FLAG_GNU_IFUNC.
	(TYPE_GNU_IFUNC): New.
	(struct main_type): New field flag_gnu_ifunc.
	(struct builtin_type): New field builtin_func_func.
	(struct objfile_type): New fields nodebug_text_gnu_ifunc_symbol and
	nodebug_got_plt_symbol.
	* minsyms.c (lookup_minimal_symbol_text): Support mst_text_gnu_ifunc.
	(in_gnu_ifunc_stub): New.
	(prim_record_minimal_symbol, find_solib_trampoline_target): Support
	mst_text_gnu_ifunc.
	* parse.c (write_exp_msymbol): New variable ifunc_msym.  Detect and
	support mst_text_gnu_ifunc.  Support mst_slot_got_plt.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Return true also for
	in_gnu_ifunc_stub.
	* symmisc.c (dump_msymbols): Support mst_text_gnu_ifunc.
	* symtab.c (search_symbols): Likewise.
	* symtab.h (enum minimal_symbol_type): New fields mst_text_gnu_ifunc
	and mst_slot_got_plt.
	(in_gnu_ifunc_stub): New declaration.
@
text
@d2833 1
a2833 5
      return value_of_this (1);

    case OP_OBJC_SELF:
      (*pos) += 1;
      return value_of_local ("self", 1);
@


1.148
log
@	* eval.c (parse_and_eval_address_1): Remove function.
	* linespec.c (decode_indirect): Call parse_to_comma_and_eval
	instead of parse_and_eval_address_1.
	* value.h (parse_and_eval_address_1): Remove prototype.
@
text
@d1835 2
@


1.147
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* eval.c (evaluate_subexp_standard): Delete unused variable,
	and discard unused values.
@
text
@a95 16
/* Like parse_and_eval_address but takes a pointer to a char * variable
   and advanced that variable across the characters parsed.  */

CORE_ADDR
parse_and_eval_address_1 (char **expptr)
{
  struct expression *expr = parse_exp_1 (expptr, (struct block *) 0, 0);
  CORE_ADDR addr;
  struct cleanup *old_chain =
    make_cleanup (free_current_contents, &expr);

  addr = value_as_address (evaluate_expression (expr));
  do_cleanups (old_chain);
  return addr;
}

@


1.146
log
@gdb/
	PR fortran/11104 and DWARF unbound arrays detection.
	* dwarf2read.c (read_subrange_type): Set zero length on unspecified
	upper bound.  Set TYPE_HIGH_BOUND_UNDEFINED if not language_ada on
	unspecified upper bound.
	* eval.c (evaluate_subexp_standard) <multi_f77_subscript>: Remove
	variables array_size_array, tmp_type and offset_item.  New variable
	array.  Remove call to f77_get_upperbound.  New variables array_type
	and index.  Call value_subscripted_rvalue for each dimenasion.  Remove
	the final call to deprecated_set_value_type.

gdb/testsuite/
	PR fortran/11104 and DWARF unbound arrays detection.
	* gdb.fortran/multi-dim.exp: New file.
	* gdb.fortran/multi-dim.f90: New file.
@
text
@a1328 1
	    struct block *b;
d1334 1
a1334 1
	    b = block_for_pc (funaddr);
d2235 2
a2236 2
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d2401 1
a2401 1
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d2428 1
a2428 1
	  arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
@


1.145
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d2357 1
a2357 2
	int subscript_array[MAX_FORTRAN_DIMS];
	int array_size_array[MAX_FORTRAN_DIMS];
d2359 1
a2359 2
	struct type *tmp_type;
	int offset_item;	/* The array offset where the item lives.  */
a2363 1
	tmp_type = check_typedef (value_type (arg1));
a2373 1
	offset_item = 0;
d2380 1
a2380 1
	    /* Fill in the subscript and array size arrays.  */
d2386 1
a2386 1
	for (i = 0; i < nargs; i++)
d2388 2
a2389 8
	    upper = f77_get_upperbound (tmp_type);
	    lower = f77_get_lowerbound (tmp_type);

	    array_size_array[nargs - i - 1] = upper - lower + 1;

	    /* Zero-normalize subscripts so that offsetting will work.  */

	    subscript_array[nargs - i - 1] -= lower;
d2391 2
a2392 10
	    /* If we are at the bottom of a multidimensional 
	       array type then keep a ptr to the last ARRAY
	       type around for use when calling value_subscript()
	       below.  This is done because we pretend to value_subscript
	       that we actually have a one-dimensional array 
	       of base element type that we apply a simple 
	       offset to.  */

	    if (i < nargs - 1)
	      tmp_type = check_typedef (TYPE_TARGET_TYPE (tmp_type));
d2395 1
a2395 17
	/* Now let us calculate the offset for this item.  */

	offset_item = subscript_array[ndimensions - 1];

	for (i = ndimensions - 1; i > 0; --i)
	  offset_item =
	    array_size_array[i - 1] * offset_item + subscript_array[i - 1];

	/* Let us now play a dirty trick: we will take arg1 
	   which is a value node pointing to the topmost level
	   of the multidimensional array-set and pretend
	   that it is actually a array of the final element 
	   type, this will ensure that value_subscript()
	   returns the correct type value.  */

	deprecated_set_value_type (arg1, tmp_type);
	return value_subscripted_rvalue (arg1, offset_item, 0);
@


1.144
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d30 2
a31 2
#include "language.h"		/* For CAST_IS_CONVERSION */
#include "f-lang.h"		/* for array bound stuff */
d55 1
a55 1
/* Prototypes for local functions. */
d113 1
a113 1
   as an integer, not an address, returns a LONGEST, not a CORE_ADDR */
d291 1
a291 1
   returning the label.  Otherwise, does nothing and returns NULL. */
d332 1
a332 1
      /* Skip past the labels, and count them. */
d393 1
a393 1
	      /* Unlabelled tuple element - go to next field. */
d428 1
a428 1
	     in substruct_type. */
d434 1
a434 1
	  /* Now actually set the field in struct_val. */
d436 1
a436 1
	  /* Assign val to field fieldno. */
d855 1
a855 1
	 or reference to a base class and print object is on. */
d1007 1
a1007 1
		    /* to avoid memory corruption */
d1028 1
a1028 1
	  /* get targettype of elementtype */
d1058 1
a1058 1
	      /* check types of elements to avoid mixture of elements from
d1060 1
a1060 1
	         with element type of powerset */
d1068 1
a1068 1
		/* different element modes */
d1099 2
a1100 1
	  /* Ensure that array expressions are coerced into pointer objects. */
d1217 1
a1217 1
	   directly. The msg_send_stret function is used in the special
d1240 1
a1240 1
	    /* Special dispatcher for methods returning structs */
d1245 1
a1245 1
	/* Verify the target object responds to this method. The
d1248 1
a1248 1
	   often used, 'NSObject' class. Make sure we check for both. */
d1269 1
a1269 1
	 class implements the desired method. */
d1291 1
a1291 1
	   thing). */
d1405 1
a1405 1
	       turn a variable into a function call. This is here
d1409 1
a1409 1
	       it. */
d1460 1
a1460 1
         called in argvec[0] and a terminating NULL */
d1466 1
a1466 1
	  /* First, evaluate the structure into arg2 */
d1503 1
a1503 1
	  /* Now, say which argument to start evaluating from */
d1508 1
a1508 1
	  /* Hair for method invocations */
d1512 1
a1512 1
	  /* First, evaluate the structure into arg2 */
d1564 1
a1564 1
	  /* Now, say which argument to start evaluating from */
d1621 1
a1621 1
	  /* Non-method function call */
d1651 1
a1651 1
      /* Evaluate arguments */
d1654 2
a1655 1
	  /* Ensure that array expressions are coerced into pointer objects. */
d1659 1
a1659 1
      /* signal end of arglist */
d1673 1
a1673 1
          /* Prepare list of argument types for overload resolution */
d1697 1
a1697 1
	  /* Method invocation : stuff "this" as first parameter */
d1702 1
a1702 1
	      /* Name of method from expression */
d1712 1
a1712 1
		 evaluation */
d1715 1
a1715 1
	      /* Prepare list of argument types for overload resolution */
d1736 2
a1737 2
	      argvec[0] = valp;	/* use the method found after overload
				   resolution */
d1740 1
a1740 1
	    /* Non-C++ case -- or no overload resolution */
d1772 1
a1772 1
	  /* Non-member function being called */
d1775 1
a1775 1
             are expected here */
d1781 1
a1781 1
		 evaluation */
d1792 1
a1792 1
	      /* Prepare list of argument types for overload resolution */
d1807 1
a1807 1
		  /* Now fix the expression being evaluated */
d1817 2
a1818 2
	      /* Not C++, or no overload resolution allowed */
	      /* nothing to be done; argvec already correctly set up */
d1823 2
a1824 2
	  /* It is probably a C-style function */
	  /* nothing to be done; argvec already correctly set up */
d1837 1
a1837 1
	     a function call. This is here because people often want to
d1840 1
a1840 1
	     it won't offer it. */
d1872 2
a1873 2
         and we now have to discover what the heck this thing actually was.  
         If it is a function, we process just as if we got an OP_FUNCALL. */
d1920 1
a1920 1
	  /* It's a function call. */
d1922 1
a1922 1
	     called in argvec[0] and a terminating NULL */
d1938 1
a1938 1
         point numbers that compose it */
d1994 1
a1994 1
	 lookup of member / method only available in the rtti type. */
d2253 1
a2253 1
	     then report this as an error. */
d2288 1
a2288 1
	  /* FIXME:  EVAL_SKIP handling may not be correct. */
d2300 1
a2300 1
	  /* FIXME:  EVAL_AVOID_SIDE_EFFECTS handling may not be correct. */
d2305 1
a2305 1
	         as an error. */
d2361 1
a2361 1
	int offset_item;	/* The array offset where the item lives */
d2375 1
a2375 1
	   let us actually find out where this element exists in the array. */
d2378 1
a2378 1
	/* Take array indices left to right */
d2381 1
a2381 1
	    /* Evaluate each subscript, It must be a legal integer in F77 */
d2384 1
a2384 1
	    /* Fill in the subscript and array size arrays */
d2389 1
a2389 1
	/* Internal type of array is arranged right to left */
d2397 1
a2397 1
	    /* Zero-normalize subscripts so that offsetting will work. */
d2404 1
a2404 1
	       below. This is done because we pretend to value_subscript
d2407 1
a2407 1
	       offset to. */
d2413 1
a2413 1
	/* Now let us calculate the offset for this item */
d2426 1
a2426 1
	   returns the correct type value */
d2972 1
a2972 1
       * of the object pointed to. Let value_addr() deal with it. */
d3035 1
a3035 3
   to decide if coercion is appropriate.

 */
d3123 1
a3123 1
/* Parse a type expression in the string [P..P+LENGTH). */
@


1.143
log
@run copyright.sh for 2011.
@
text
@d870 2
a871 1
	      ret = value_zero (SYMBOL_TYPE (exp->elts[pc + 2].symbol), not_lval);
d930 2
a931 1
    case OP_OBJC_NSSTRING:		/* Objective C Foundation Class NSString constant.  */
d1346 2
a1347 1
						 value_type (method), val_type);
d1371 2
a1372 1
	      error (_("method address has symbol information with non-function type; skipping"));
d1374 5
a1378 4
	    /* Create a function pointer of the appropriate type, and replace
	       its value with the value of msg_send or msg_send_stret.  We must
	       use a pointer here, as msg_send and msg_send_stret are of pointer
	       type, and the representation may be different on systems that use
d1424 2
a1425 1
	      error (_("Expression of type other than \"method returning ...\" used as a method"));
d1445 2
a1446 1
	    argvec[0] = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
d1460 2
a1461 1
      argvec = (struct value **) alloca (sizeof (struct value *) * (nargs + 3));
d1540 3
a1542 2
	      /* Check to see if the operator '->' has been overloaded.  If the operator
	         has been overloaded replace arg2 with the value returned by the custom
d1642 2
a1643 1
		      argvec[tem] = evaluate_subexp (TYPE_FIELD_TYPE (type, tem - 1),
d1672 2
a1673 1
          arg_types = (struct type **) alloca (nargs * (sizeof (struct type *)));
d1678 4
a1681 2
                               NON_METHOD /* not method */ , 0 /* strict match */ ,
                               NULL, NULL /* pass NULL symbol since symbol is unknown */ ,
d1706 2
a1707 1
	  if (overload_resolution && (exp->language_defn->la_language == language_cplus))
d1709 2
a1710 1
	      /* Language is C++, do some overload resolution before evaluation */
d1714 2
a1715 1
	      arg_types = (struct type **) alloca (nargs * (sizeof (struct type *)));
d1720 5
a1724 3
	                                  METHOD /* method */ , 0 /* strict match */ ,
					  &arg2 /* the object */ , NULL,
					  &valp, NULL, &static_memfuncp, 0);
d1734 2
a1735 1
	      argvec[0] = valp;	/* use the method found after overload resolution */
d1749 4
a1752 3
	      arg2 = value_from_longest (lookup_pointer_type(value_type (temp)),
					 value_address (temp)
					 + value_embedded_offset (temp));
d1775 2
a1776 1
	  if (overload_resolution && (exp->language_defn->la_language == language_cplus))
d1778 2
a1779 1
	      /* Language is C++, do some overload resolution before evaluation */
d1791 2
a1792 1
	      arg_types = (struct type **) alloca (nargs * (sizeof (struct type *)));
d1796 5
a1800 3
	      (void) find_overload_match (arg_types, nargs, NULL /* no need for name */ ,
	                                  NON_METHOD /* not method */ , 0 /* strict match */ ,
	                                  NULL, function /* the function */ ,
d1853 2
a1854 1
	    error (_("Expression of type other than \"Function returning ...\" used as function"));
d1861 2
a1862 1
      /* pai: FIXME save value from call_function_by_hand, then adjust pc by adjust_fn_pc if +ve  */
d1921 2
a1922 1
	  argvec = (struct value **) alloca (sizeof (struct value *) * (nargs + 2));
d2066 2
a2067 1
	  error (_("non-pointer-to-member value used in pointer-to-member construct"));
d2664 2
a2665 1
	error (_("Attempt to dereference pointer to member without an object"));
d2709 2
a2710 1
	  struct value *retvalp = evaluate_subexp_for_address (exp, pos, noside);
d2918 2
a2919 2
      error (_("\
GDB does not (yet) know how to evaluate that kind of expression"));
d3017 2
a3018 1
	    error (_("Attempt to take address of value not located in memory."));
@


1.142
log
@gdb:
	* NEWS: Mention OpenCL C language support.
	* Makefile.in (SFILES): Add opencl-lang.c.
	(COMMON_OBS): Add opencl-lang.o.
	* opencl-lang.c: New File
	* defs.h (enum language): Add language_opencl.
	* dwarf2read.c (read_file_scope): Handle DW_AT_producer for the
	IBM XL C OpenCL compiler.
	* c-lang.h: Include "parser-defs.h".
	(evaluate_subexp_c): Declare.
	* c-lang.c (evaluate_subexp_c): Remove the static qualifier.
	(c_op_print_tab): Add declaration.
	* eval.c (binop_promote): Handle language_opencl.
	* c-exp.y: Lookup the primitive types instead of referring to the
	builtins.

gdb/testsuite:
	* Makefile.in (ALL_SUBDIRS): Add gdb.opencl.
	* configure.ac (AC_OUTPUT): Add gdb.opencl/Makefile.
	* configure: Regenerate.
	* gdb.opencl/Makefile.in: New File.
	* gdb.opencl/datatypes.exp: Likewise.
	* gdb.opencl/datatypes.cl: Likewise.
	* gdb.opencl/operators.exp: Likewise.
	* gdb.opencl/operators.cl: Likewise.
	* gdb.opencl/vec_comps.exp: Likewise.
	* gdb.opencl/vec_comps.cl: Likewise.
	* gdb.opencl/convs_casts.exp: Likewise.
	* gdb.opencl/convs_casts.cl: Likewise.
	* lib/opencl.exp: Likewise.
	* lib/opencl_hostapp.c: Likewise.
	* lib/opencl_kernel.cl: Likewise.
	* lib/cl_util.c: Likewise.
	* lib/cl_util.c: Likewise.
	* gdb.base/default.exp (set language): Add "opencl" to the list of
	languages.

gdb/doc:
	* gdb.texinfo: (Summary) Add mention about OpenCL C language support.
	(OpenCL C): New node.
@
text
@d5 1
a5 1
   2009, 2010 Free Software Foundation, Inc.
@


1.141
log
@gdb:
	* value.h (value_non_lval): Declare.
	* value.c (value_non_lval): New function.
	* eval.c (evaluate_subexp_standard) <UNOP_POSTINCREMENT,
	UNOP_POSTDECREMENT>: Call value_non_lval to ensure to return a
	non-lvalue.

gdb/testsuite:
	* gdb.base/exprs.exp: Add tests for pre-/post- in-/decrement operators.
@
text
@d606 1
d694 18
a711 1

@


1.140
log
@Support overloading of 'operator->'.

2010-10-19  Sami Wagiaalla  <swagiaal@@redhat.com>

	 PR C++/11500:
	* valarith.c (value_x_unop): Handle STRUCTOP_PTR.
	* eval.c (evaluate_subexp_standard): Check for overload of
	'operator->'.
	* valarith.c (value_x_binop): Throw NOT_FOUND_ERROR.
	(value_x_unop): Ditto.
	* valops.c: Include "exceptions.h".
	(find_overload_match): Throw NOT_FOUND_ERROR.
	(value_struct_elt): Ditto.

2010-10-19  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/smartp.exp: New test.
	* gdb.cp/smartp.cc : New test.
@
text
@d2785 2
d2799 1
a2799 1
	  return arg1;
d2812 2
d2826 1
a2826 1
	  return arg1;
@


1.139
log
@gdb/ChangeLog:* gdb/valarith.c (vector_binop): New function.(scalar_binop): Likewise.(value_binop): Call scalar_binop or vector_binop depending on the types.* gdb/eval.c (ptrmath_type_p): Return 0 in case of TYPE_VECTOR.(evaluate_subexp_with_coercion): Add vector check to not convert vectorsto pointers.* gdb/value.c (coerce_array): Add vector check to not coerce vectors.testsuite/ChangeLog:* gdb.base/Makefile.in (EXECUTABLES): Add gnu_vector.* gdb.base/gnu_vector.c: New File.* gdb.base/gnu_vector.exp: Likewise.
@
text
@d1513 22
d1923 21
@


1.138
log
@Corrected pre-overload-resolution function evaluation.

2010-07-21  Sami Wagiaalla  <swagiaal@@redhat.com>

	* eval.c (evaluate_subexp_standard): Disabled evaluation of C++
	function symbols before overload resolution.

2010-07-21  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/fpointer.cc: New test.
	* gdb.cp/fpointer.exp: New test.
@
text
@d739 1
a739 1
      return lang->c_style_arrays;
d2959 1
@


1.137
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@a1572 1
	  argvec[0] = evaluate_subexp_with_coercion (exp, pos, noside);
d1574 10
a1583 4
	  type = value_type (argvec[0]);
	  if (type && TYPE_CODE (type) == TYPE_CODE_PTR)
	    type = TYPE_TARGET_TYPE (type);
	  if (type && TYPE_CODE (type) == TYPE_CODE_FUNC)
d1585 5
a1589 1
	      for (; tem <= nargs && tem <= TYPE_NFIELDS (type); tem++)
d1591 5
a1595 4
		  /* pai: FIXME This seems to be coercing arguments before
		   * overload resolution has been done! */
		  argvec[tem] = evaluate_subexp (TYPE_FIELD_TYPE (type, tem - 1),
						 exp, pos, noside);
@


1.136
log
@Test and support all cpp operator types.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* value.h: Created oload_search_type enum.
	(find_overload_match): Use oload_search_type enum.
	* valops.c (find_overload_match): Support combined member and
	non-member search.
	* eval.c (evaluate_subexp_standard): Calls to
	find_overload_match now use oload_search_type enum.
	(oload_method_static): Verify index is a proper value.
	* valarith.c (value_user_defined_cpp_op): Search for and handle
	both member and non-member operators.
	(value_user_defined_cpp_op): New function.
	(value_user_defined_op): New function.
	(value_x_unop): Use value_user_defined_op.
	(value_x_binop): Ditto.
	* cp-support.c (make_symbol_overload_list_using): Added block
	iteration.
	Add check for namespace aliases and imported declarations.

2010-06-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: Test for ADL operators.
	* gdb.cp/koenig.cc: Added ADL operators.
	* gdb.cp/operator.exp: New test.
	* gdb.cp/operator.cc: New test.
@
text
@d46 1
d190 78
@


1.135
log
@gdb
	* eval.c (evaluate_subexp_standard) <BINOP_SUBSCRIPT>: Call
	evaluate_subexp, not evaluate_subexp_with_coercion.
gdb/testsuite
	* gdb.dwarf2/pieces.exp (pieces_test_f2): New proc.
	Call it.
@
text
@d1538 1
a1538 1
                               0 /* not method */ , 0 /* strict match */ ,
d1575 1
a1575 1
				     1 /* method */ , 0 /* strict match */ ,
d1645 2
a1646 2
				 0 /* not method */ , 0 /* strict match */ ,
		      NULL, function /* the function */ ,
@


1.134
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* elfread.c: White space.
	* environ.c: White space.
	* eval.c: White space.
	* event-loop.c: White space.
	* event-top.c: White space.
	* exceptions.c: White space.
	* exec.c: White space.
	* expprint.c: White space.
@
text
@d2062 2
a2063 2
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
@


1.133
log
@	* eval.c (evaluate_subexp_standard): Revert inadvertent change.
@
text
@d165 1
d176 1
d201 1
d222 1
d244 1
d260 1
d267 1
d280 1
d392 1
d404 1
d477 1
d862 1
d875 1
d887 1
d899 1
d942 1
d987 1
d1011 1
a1011 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d1013 2
a1014 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d1024 1
a1024 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d1026 2
a1027 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d1123 1
d1309 1
d1391 1
d1483 1
d1593 1
d1800 1
d1846 1
d2530 1
d2589 1
d2610 1
d2634 1
d2658 1
d2683 1
d2710 1
d2793 1
a2793 1
	  lookup_pointer_type (SYMBOL_TYPE (var));
d2943 1
@


1.132
log
@	* eval.c (ptrmath_type_p): Add 'lang' argument.
	(evaluate_subexp_standard): Update.
	(evaluate_subexp_with_coercion): Update.
	* language.h (CAST_IS_CONVERSION): Add 'LANG' argument.
@
text
@d2036 2
a2037 2
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
@


1.131
log
@Add ADL support

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/7943:
	* valops.c (find_overload_match): Handle fsym == NULL case.
	Add int no_adl argument.
	(find_oload_champ_namespace_loop): Call make_symbol_overload_list_adl
	when appropriate.
	Add int no_adl argument.
	(find_oload_champ_namespace): 	Add int no_adl argument.
	* parse.c (operator_length_standard): Return length for OP_ADL_FUNC
	expression.
	* expprint.c (op_name_standard): Added string for OP_ADL_FUNC case.
	* eval.c (evaluate_subexp_standard): Added OP_ADL_FUNC case.
	Evaluate arguments and use them to perform ADL lookup.
	Pass no_adl argument to find_overload_match.
	Disable adl lookup when evaluating a fully qualified OP_FUNCALL.
	* cp-support.h: Added prototype for
	make_symbol_overload_list_namespace.
	* cp-support.c (make_symbol_overload_list_namespace): New function.
	(make_symbol_overload_list_adl_namespace): New function.
	(make_symbol_overload_list_adl): New function.
	(make_symbol_overload_list_using): Moved code to add function to
	overload set to make_symbol_overload_list_namespace.
	* c-exp.y: create UNKNOWN_CPP_NAME token.
	Add parse rule for ADL functions.
	(classify_name): Recognize an UNKNOWN_CPP_NAME.

2010-05-07  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/koenig.exp: New test.
	* gdb.cp/koenig.cc: New test program.
@
text
@d636 1
a636 1
ptrmath_type_p (struct type *type)
d649 1
a649 1
      return current_language->c_style_arrays;
d1909 2
a1910 1
      else if (op == BINOP_ADD && ptrmath_type_p (value_type (arg1))
d1913 2
a1914 1
      else if (op == BINOP_SUB && ptrmath_type_p (value_type (arg1))
d1940 1
a1940 1
      else if (ptrmath_type_p (value_type (arg1))
d1943 1
a1943 1
      else if (ptrmath_type_p (value_type (arg2))
d1959 2
a1960 2
      else if (ptrmath_type_p (value_type (arg1))
	       && ptrmath_type_p (value_type (arg2)))
d1966 1
a1966 1
      else if (ptrmath_type_p (value_type (arg1))
d2036 2
a2037 2
      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);
      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);
d2577 1
a2577 1
	  if (ptrmath_type_p (value_type (arg1)))
d2600 1
a2600 1
	  if (ptrmath_type_p (value_type (arg1)))
d2623 1
a2623 1
	  if (ptrmath_type_p (value_type (arg1)))
d2647 1
a2647 1
	  if (ptrmath_type_p (value_type (arg1)))
d2837 1
a2837 1
	  && CAST_IS_CONVERSION)
@


1.130
log
@2010-05-06  Michael Snyder  <msnyder@@vmware.com>

	* eval.c (evaluate_subexp_standard): Delete unused variable.
	* valops.c (value_cast_pointers): Delete unused variable.
	(value_dynamic_cast): Delete unused variable.
	(value_array): Delete unused variable.
	(find_overload_match): Delete unused variable.
	* valarith.c (value_subscript): Delete unused variable.
	(value_binop): Delete unused variable.
	* valprint.c (_initialize_valprint): Delete unused variable.
	* printcmd.c (print_command_1): Delete unused variable.
	(address_info): Delete unused variable.
	(printf_command): Delete unused variable.
@
text
@d734 1
d1456 11
d1497 26
d1554 1
a1554 1
					  &valp, NULL, &static_memfuncp);
d1606 5
d1623 1
a1623 1
					  NULL, &symp, NULL);
@


1.129
log
@
    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        PR c++/7936:
        * cp-support.h: Added char *declaration element to using_direct
        data struct.
        (cp_add_using): Added char *declaration argument.
        (cp_add_using_directive): Ditto.
        (cp_lookup_symbol_imports): made extern.
        * cp-namespace.c: Updated with the above changes.
        * dwarf2read.c (read_import_statement): Ditto.
        (read_namespace): Ditto.
        (read_import_statement): Support import declarations.
        * cp-namespace.c (cp_lookup_symbol_imports): Check for imported
        declarations.
        Added support for 'declaration_only' search.
        (cp_lookup_symbol_namespace): Attempt to search for the name as
        is before consideration of imports.
        * symtab.c (lookup_symbol_aux_local): Added a 'declaration_only'
        search at every block level search.
        Now takes language argument.
        (lookup_symbol_aux): Updated.

    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        * gdb.cp/shadow.exp: Removed kfail; test has been fix.
        * gdb.cp/nsusing.exp: Ditto.
@
text
@d693 1
a693 1
  int upper, lower, retcode;
a1420 1
	  struct type *qual_type;
@


1.128
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d1438 1
a1438 1
						     VAR_DOMAIN, 1);
@


1.127
log
@gdb
	PR c++/8017:
	* value.h: Update.
	* valops.c (search_struct_field): Make 'name' const.
	(search_struct_method): Likewise.
	(find_method_list): Make 'method' const.
	(value_struct_elt): Make 'name' and 'err' const.
	(value_find_oload_method_list): Make 'method' const.
	(find_overload_match): Make 'name' const.
	* eval.c (evaluate_subexp_standard): New locals function,
	function_name.
	<OP_FUNCALL>: Handle OP_SCOPE specially.
gdb/testsuite
	PR c++/8017:
	* gdb.cp/overload.exp: Add tests.
	* gdb.cp/overload.cc (struct K): New.
	(namespace N): New.
	(main): Call new functions.
	(K::staticoverload): Define.
@
text
@d1436 1
a1436 1
						     name, NULL,
@


1.126
log
@gdb
	PR exp/7643:
	* eval.c (evaluate_subexp_for_address) <UNOP_IND>: Call
	coerce_array on result.
gdb/testsuite
	PR exp/7643:
	* gdb.base/printcmds.exp (test_print_string_constants): Remove
	setup_kfail.
@
text
@d699 2
d1415 41
d1487 2
a1488 1
      if (op == STRUCTOP_STRUCT || op == STRUCTOP_PTR)
d1491 1
a1491 1
	  char tstr[256];
d1495 8
a1502 2
	  /* Name of method from expression */
	  strcpy (tstr, &exp->elts[pc2 + 2].string);
d1519 7
a1525 1

d1558 1
a1558 1
      else if (op == OP_VAR_VALUE)
d1570 3
d1580 1
a1580 1
		      NULL, exp->elts[save_pos1+2].symbol /* the function */ ,
d1583 9
a1591 3
	      /* Now fix the expression being evaluated */
	      exp->elts[save_pos1+2].symbol = symp;
	      argvec[0] = evaluate_subexp_with_coercion (exp, &save_pos1, noside);
@


1.125
log
@gdb
	PR c++/9680:
	* c-exp.y (REINTERPRET_CAST, DYNAMIC_CAST, STATIC_CAST)
	(CONST_CAST): New tokens.
	(exp): Add new productions.
	(ident_tokens): Add const_cast, dynamic_cast, static_cast, and
	reinterpret_cast.
	(is_cast_operator): New function.
	(yylex): Handle cast operators specially.
	* eval.c (evaluate_subexp_standard) <UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST>: New cases.
	* expprint.c (print_subexp_standard): Likewise.
	(op_name_standard): Likewise.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
	* expression.h (enum exp_opcode): New constants UNOP_DYNAMIC_CAST,
	UNOP_REINTERPRET_CAST.
	* gdbtypes.c (class_types_same_p): New function.
	(is_ancestor): Use it.
	(is_public_ancestor): New function.
	(is_unique_ancestor_worker): Likewise.
	(is_unique_ancestor): Likewise.
	* gdbtypes.h (class_types_same_p, is_public_ancestor)
	(is_unique_ancestor): Declare.
	* valops.c (value_reinterpret_cast): New function.
	(dynamic_cast_check_1): Likewise.
	(dynamic_cast_check_2): Likewise.
	(value_dynamic_cast): Likewise.
	* value.h (value_reinterpret_cast, value_dynamic_cast): Declare.
gdb/testsuite
	PR c++/9680:
	* gdb.cp/casts.cc: Add new classes and variables.
	* gdb.cp/casts.exp: Test new operators.
@
text
@d2632 1
a2632 1
      return x;
@


1.124
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d2416 16
@


1.123
log
@	* c-exp.y: Add new rule for resolving method overloads.
	* eval.c (make_params): New function.
	(free_param_types): New function.
	(evaluate_subexp_standard): Pass expect_type to value_aggregate_elt.
	Handle case TYPE_INSTANCE.
	(evaluate_subexp_for_address): Pass expect_type to value_aggregate_elt.
	* expression.h (enum exp_opcode): Add TYPE_INSTANCE.
	(compare_parameters): Add declaration.
	* parse.c (operator_length_standard): Add TYPE_INSTANCE.
	* valops.c (value_aggregate_elt): Add new expect_type parameter.
	Pass expect_type to value_struct_elt_for_reference.
	(value_struct_elt_for_reference): Add expect_type parameter and use
	compare_parameters.
	Check for overload matches with and without artificial parameters.
	Skip artificial methods.
	(compare_parameters): New function.
	* value.h (value_aggregate_elt): Add new expect_type parameter.
@
text
@d5 1
a5 1
   2009 Free Software Foundation, Inc.
@


1.122
log
@	ARI fix: OP eol rule.
	* doublest.c (floatformat_from_length): Avoid operator at end of line.
	* dwarf2-frame.c (dwarf2_build_frame_info): Idem.
	* dwarf2read.c (read_array_order, dwarf_decode_macros): Idem.
	* eval.c (evaluate_subexp_standard): Idem.
	* event-loop.c (create_timer, handle_timer_event): Idem.
	* expprint.c (print_subexp_standard): Idem.
	* f-exp.y (variable): Idem.
	* f-typeprint.c (f_print_type): Idem.
@
text
@d43 2
d656 23
d712 1
a712 1
				  0, noside);
d1758 14
d2654 1
a2654 1
			       1, noside);
@


1.121
log
@	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d887 2
a888 2
	  while (TYPE_CODE (check_type) == TYPE_CODE_RANGE ||
		 TYPE_CODE (check_type) == TYPE_CODE_TYPEDEF)
d922 3
a924 3
	      if ((TYPE_CODE (range_low_type) != TYPE_CODE (range_high_type)) ||
		  (TYPE_CODE (range_low_type) == TYPE_CODE_ENUM &&
		   (range_low_type != range_high_type)))
d927 3
a929 3
	      if ((TYPE_CODE (check_type) != TYPE_CODE (range_low_type)) ||
		  (TYPE_CODE (check_type) == TYPE_CODE_ENUM &&
		   range_low_type != check_type))
d1665 2
a1666 2
        if (opts.objectprint && TYPE_TARGET_TYPE(type) &&
            (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_CLASS))
@


1.120
log
@gdb
	PR python/10680:
	* eval.c (evaluate_subexp_standard) <do_call_it>: Handle internal
	functions in EVAL_AVOID_SIDE_EFFECTS case.
gdb/testsuite
	* gdb.python/py-function.exp: Add regression tests.
@
text
@d1164 6
a1170 1

d1224 6
d1231 3
a1233 1
	      set_value_address (method, value_as_address (msg_send_stret));
d1235 3
a1237 2
	      set_value_address (method, value_as_address (msg_send));
	    called_method = method;
d1292 1
a1292 1
				       lookup_function_type (lookup_pointer_type (value_type (argvec[0]))));
@


1.119
log
@	* python/python-internal.h (struct language_defn): Declare.
	(python_gdbarch, python_language): Likewise.
	(ensure_python_env): Add prototype.
	(make_cleanup_py_restore_gil): Remove prototype.

	* python/python.c: Include "arch-utils.h", "value.h" and "language.h".
	(python_gdbarch, python_language): New global variables.
	(struct python_env): New data type.
	(ensure_python_env, restore_python_env): New functions.
	(eval_python_from_control_command): Call ensure_python_env to
	install current architecture and language.
	(python_command, gdbpy_new_objfile): Likewise.
	* python/python-cmd.c: Include "arch-utils.h" and "language.h".
	(cmdpy_destroyer, cmdpy_function, cmdpy_completer): Call
	ensure_python_env.
	* python/python-type.c (clean_up_objfile_types): Likewise.
	* python/python-objfile.c: Include "language.h".
	(clean_up_objfile): Call ensure_python_env.
	* python/python-prettyprint.c (apply_val_pretty_printer): Likewise.
	(apply_varobj_pretty_printer): Do not call PyGILState_Ensure.
	* varobj.c (varobj_ensure_python_env): New helper function.
	(varobj_get_display_hint, update_dynamic_varobj_children,
	install_default_visualizer, varobj_set_visualizer, free_variable,
	value_get_print_value): Call it.
	(value_get_print_value): Add varobj argument instead of pretty
	printer argument.  Update all callers.

	* python/python-utils.c (py_gil_restore, make_cleanup_py_restore_gil):
	Remove.

	* value.h (internal_function_fn): Add GDBARCH and LANGUAGE argument.
	(call_internal_function): Likewise.
	* value.c (call_internal_function): Likewise.  Pass to handler.
	* eval.c (evaluate_subexp_standard): Update call.
	* python/python-function.c: Include "language.h".
	(fnpy_call): Add GDBARCH and LANGAUAGE arguments and call
	make_cleanup_python_env.

	* python/python-value.c (builtin_type_pyint, builtin_type_pyfloat,
	builtin_type_pylong, builtin_type_pybool, builtin_type_pychar,
	valpy_str): Use python_gdbarch and python_language instead of
	current_gdbarch and current_language.
	* python/python-type.c (typy_lookup_typename): Likewise.
@
text
@d1516 1
a1516 2
	  struct type *ftype =
	  TYPE_TARGET_TYPE (value_type (argvec[0]));
d1518 10
a1527 2
	  if (ftype)
	    return allocate_value (TYPE_TARGET_TYPE (value_type (argvec[0])));
@


1.119.4.1
log
@gdb
	PR python/10680:
	* eval.c (evaluate_subexp_standard) <do_call_it>: Handle internal
	functions in EVAL_AVOID_SIDE_EFFECTS case.
gdb/testsuite
	* gdb.python/py-function.exp: Add regression tests.
@
text
@d1516 2
a1517 1
	  struct type *ftype = value_type (argvec[0]);
d1519 2
a1520 10
	  if (TYPE_CODE (ftype) == TYPE_CODE_INTERNAL_FUNCTION)
	    {
	      /* We don't know anything about what the internal
		 function might return, but we have to return
		 something.  */
	      return value_zero (builtin_type (exp->gdbarch)->builtin_int,
				 not_lval);
	    }
	  else if (TYPE_TARGET_TYPE (ftype))
	    return allocate_value (TYPE_TARGET_TYPE (ftype));
@


1.119.4.2
log
@	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d1164 1
a1165 6
	    /* The address might point to a function descriptor;
	       resolve it to the actual code address instead.  */
	    addr = gdbarch_convert_from_func_ptr_addr (exp->gdbarch, addr,
						       &current_target);

	    /* Is it a high_level symbol?  */
a1218 6

	    /* Create a function pointer of the appropriate type, and replace
	       its value with the value of msg_send or msg_send_stret.  We must
	       use a pointer here, as msg_send and msg_send_stret are of pointer
	       type, and the representation may be different on systems that use
	       function descriptors.  */
d1220 1
a1220 3
	      called_method
		= value_from_pointer (lookup_pointer_type (value_type (method)),
				      value_as_address (msg_send_stret));
d1222 2
a1223 3
	      called_method
		= value_from_pointer (lookup_pointer_type (value_type (method)),
				      value_as_address (msg_send));
d1278 1
a1278 1
				       lookup_pointer_type (lookup_function_type (value_type (argvec[0]))));
@


1.119.4.3
log
@	Revert 2009-09-28 commit:
	* eval.c (evaluate_subexp_standard) [OP_OBJC_MSGCALL]: Support
	platforms that use function descriptors.  Prefer to use function
	pointer types instead of function types.
	* linespec.c (decode_objc): Support function descriptors.  Fully
	initialize SAL result.
	* objc-lang.c (find_methods): Support function descriptors.
	Do not require function symbol to point to text section.

	* ppc-sysv-tdep.c (ppc64_sysv_abi_push_dummy_call): When calling
	via a function pointer, use the descriptor it points to.
@
text
@d1164 6
a1170 1

d1224 6
d1231 3
a1233 1
	      set_value_address (method, value_as_address (msg_send_stret));
d1235 3
a1237 2
	      set_value_address (method, value_as_address (msg_send));
	    called_method = method;
d1292 1
a1292 1
				       lookup_function_type (lookup_pointer_type (value_type (argvec[0]))));
@


1.118
log
@	* gdbtypes.c (make_pointer_type, make_reference_type,
	smash_to_memberptr_type, lookup_array_range_type, check_stub_method):
	Use type architecture instead of current_gdbarch.

	* gdbtypes.h (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH paramter.
	* gdbtypes.c (address_space_name_to_int, address_space_int_to_name):
	Add GDBARCH parameter.   Use it instead of current_gdbarch.
	* c-typeprint.c (c_type_print_modifier): Update call.
	* parse.c (push_type_address_space): Likewise.

	* findvar.c (extract_typed_address, store_typed_address): Use type
	architecture instead of current_gdbarch.

	* value.c (value_as_address, unpack_field_as_long): Use type architecture
	instead of current_gdbarch.

	* doublest.c (floatformat_from_length): Add GDBARCH argument.  Use it
	instead of current_gdbarch.
	(floatformat_from_type): Pass type architecture.

	* infcall.c (find_function_addr): Use type architecture instead
	of current_gdbarch.

	* valarith.c (value_bitstring_subscript, value_x_binop, value_neg,
	value_bit_index): Use type architecture instead of current_gdbarch.
	* valops.c (value_cast, value_slice): Likewise.

	* value.h (modify_field): Add TYPE argument.
	* value.c (modify_field): Add TYPE argument.  Use type architecture
	instead of current_gdbarch.
	(set_internalvar_component): Likewise.
	* eval.c (evaluate_struct_tuple): Update call.
	* valops.c (value_assign): Likewise.
	* ada-lang.c (modify_general_field): Likewise.  Add TYPE argument.
	(make_array_descriptor): Update calls.
	(move_bits): Add BITS_BIG_ENDIAN_P argument.  Use it instead of
	current_gdbarch.
	(ada_value_assign, value_assign_to_component): Update calls.
	(decode_packed_array, ada_value_primitive_packed_val, ada_value_assign,
	value_assign_to_component): Use type arch instead of current_gdbarch.

	* printcmd.c (float_type_from_length): Remove GDBARCH argument,
	use type architecture instead.
	(print_scalar_formatted, printf_command): Update calls.  Use type
	architecture instead of current_gdbarch.
	* valprint.c (val_print_type_code_int): Use type architecture
	instead of current_gdbarch.
	* varobj.c (value_get_print_value): Likewise.
	* python/python-prettyprint.c (print_string_repr): Add GDBARCH
	argument.  Use it instead of current_gdbarch.
	(apply_val_pretty_printer): Update call.

	* ada-valprint.c (ada_val_print_1): Use type architecture instead
	of current_gdbarch.
	* c-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(c_val_print): Update calls passing type architecture.
	* f-valprint.c (f_val_print): Use type architecture instead of
	current_gdbarch.
	* jv-valprint (java_value_print): Likewise.
	* m2-valprint.c (print_function_pointer_address): Add GDBARCH argument.
	Use it instead of current_gdbarch.
	(print_unpacked_pointer): Update calls passing type architecture.
	* scm-valprint.c (scm_scmval_print): Use type architecture instead of
	current_gdbarch.

	* gnu-v3-abi.c (get_class_arch): Remove.
	(gnuv3_rtti_type): Use get_type_arch instead of get_class_arch.  Remove
	special-case check for Java classes.
	(gnuv3_virtual_fn_field, gnuv3_baseclass_offset, gnuv3_print_method_ptr,
	gnuv3_method_ptr_size, gnuv3_make_method_ptr, gnuv3_method_ptr_to_value):
	Use get_type_arch instead of get_class_arch.
@
text
@d1525 2
a1526 1
	return call_internal_function (argvec[0], nargs, argvec + 1);
@


1.117
log
@	* ada-lang.c (assign_component): Use platform-specific integer type
	instead of builtin_type_int32 type.
	(ada_evaluate_subexp) [OP_ATR_SIZE]: Likewise.

	* ax-gdb.c (gen_expr) [UNOP_NEG]: Use platform-specific integer type
	instead of builtin_type_int8 type.
	* valarith.c (value_x_unop): Likewise.
	* python/python-value.c (valpy_absolute): Avoid reference to
	builtin_type_int8 type.

	* eval.c (evaluate_subexp_standard): Use platform-specific integer
	type instead of builtin_type_int8 as EVAL_SKIP return value type.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
	* jv-lang.c (evaluate_subexp_java): Likewise.
	* m2-lang.c (evaluate_subexp_modula2): Likewise.
	* scm-lang.c (evaluate_exp): Likewise.

	* value.h (value_bitstring): Add INDEX_TYPE argument.
	* valops.c (value_bitstring): Add INDEX_TYPE argument, use it instead
	of builtin_type_int32 as base range type.
	* eval.c (evaluate_subexp_standard): Update value_bitstring call.
@
text
@d357 2
a358 2
	    modify_field (addr, value_as_long (val),
			  bitpos % 8, bitsize);
@


1.116
log
@	* gdbtypes.h (struct builtin_type): Add internal_fn member.
	* gdbtypes.c (gdbtypes_post_init): Initialize it.
	* value.c (internal_fn_type): Remove.
	(_initialize_values): Do not initialize it.

	* value.c (struct internalvar): Add enum internalvar_kind type and
	kind member.  Restructure union internalvar_data type.  Remove type,
	canonical, and make_value members.
	(init_if_undefined_command): Update for data structure changes.
	(create_internalvar): Likewise.
	(create_internalvar_type_lazy): Likewise.
	(get_internalvar_integer): Likewise.
	(get_internalvar_function): Likewise.
	(set_internalvar_component): Likewise.
	(set_internalvar): Likewise.
	(set_internalvar_integer): Likewise.
	(set_internalvar_function): Likewise.
	(clear_internalvar): Likewise.
	(add_internal_function): Likewise.
	(preserve_one_internalvar): New function.
	(preserve_values): Call it.

	* value.h (value_of_internalvar): Add GDBARCH parameter.
	(internalvar_make_value): Likewise.
	* value.c (value_of_internalvar): Add GDBARCH parameter.  Pass it to
	make_value callback.  Use it to generate per-architecture result value
	types for internal variables with no pre-defined type.  Update for data
	structure changes.
	(show_convenience): Pass architecture to value_of_internalvar.
	* eval.c (evaluate_subexp_standard): Likewise.
	* infrun.c (siginfo_make_value): Add GDBARCH parameter.  Use it
	instead of current frame architecture.  Return per-architecture type.

	* value.h (set_internalvar_string): Add prototype.
	* value.c (set_internalvar_string): New function.
	* tracepoint.c (set_traceframe_context): Use it.
@
text
@d808 2
a809 1
      return value_bitstring (&exp->elts[pc + 2].string, tem);
d2519 1
a2519 1
  return value_from_longest (builtin_type_int8, (LONGEST) 1);
@


1.115
log
@	* value.h (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.
	* valarith.c (value_subscript, value_subscripted_rvalue,
	value_bitstring_subscript, value_ptradd): Use LONGEST instead
	of value as type of the index argument.
	(value_ptrsub): Remove.

	* wrapper.h (gdb_value_subscript): Use LONGEST instead of
	value as type of the index argument.
	* wrapper.c (gdb_value_subscript): Likewise.

	Update calls to gdb_value_subscript, value_subscript,
	value_subscripted_rvalue, value_bitstring_subscript and
	value_ptradd to use LONGEST instead of value as index
	argument type.  Use value_ptradd instead of value_ptrsub.
	* ada-lang.c (ada_value_subscript, ada_value_ptr_subscript,
	ada_tag_name_2): Update.
	* ada-tasks.c (read_atcb): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* valarith.c (value_subscript): Update.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Update.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	gnuv3_method_ptr_to_value): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* m2-lang.c (evaluate_subexp_modula2): Update.
	* python/python-value.c (valpy_getitem, valpy_binop): Update.
	* wrapper.c (gdb_value_subscript): Update.
	* varobj.c (c_describe_child): Update.
@
text
@d782 2
a783 1
      return value_of_internalvar (exp->elts[pc + 1].internalvar);
@


1.114
log
@	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* infrun.c (handle_inferior_event): Avoid unncessary reference
	to current_gdbarch and get_current_frame ().
@
text
@d1577 1
a1577 1
	      return value_subscript (arg1, arg2);
d1739 6
a1744 4
      else if (op == BINOP_ADD && ptrmath_type_p (value_type (arg1)))
	arg2 = value_ptradd (arg1, arg2);
      else if (op == BINOP_SUB && ptrmath_type_p (value_type (arg1)))
	arg2 = value_ptrsub (arg1, arg2);
d1768 6
a1773 4
      else if (ptrmath_type_p (value_type (arg1)))
	return value_ptradd (arg1, arg2);
      else if (ptrmath_type_p (value_type (arg2)))
	return value_ptradd (arg2, arg1);
d1787 2
a1788 1
      else if (ptrmath_type_p (value_type (arg1)))
d1790 7
a1796 9
	  if (ptrmath_type_p (value_type (arg2)))
	    {
	      /* FIXME -- should be ptrdiff_t */
	      type = builtin_type (exp->gdbarch)->builtin_long;
	      return value_from_longest (type, value_ptrdiff (arg1, arg2));
	    }
	  else
	    return value_ptrsub (arg1, arg2);
	}
d1891 1
a1891 1
	    return value_subscript (arg1, arg2);
d1956 1
a1956 1
		  arg1 = value_subscript (arg1, arg2);
d1961 2
a1962 1
		  arg1 = value_bitstring_subscript (type, arg1, arg2);
a2041 4
	/* Construct a value node with the value of the offset */

	arg2 = value_from_longest (builtin_type_int32, offset_item);

d2050 1
a2050 1
	return value_subscripted_rvalue (arg1, arg2, 0);
a2388 1
	  arg2 = value_from_longest (builtin_type_uint8, (LONGEST) 1);
d2390 1
a2390 1
	    arg2 = value_ptradd (arg1, arg2);
d2394 1
a2411 1
	  arg2 = value_from_longest (builtin_type_uint8, (LONGEST) 1);
d2413 1
a2413 1
	    arg2 = value_ptrsub (arg1, arg2);
d2417 1
a2434 1
	  arg2 = value_from_longest (builtin_type_uint8, (LONGEST) 1);
d2436 1
a2436 1
	    arg2 = value_ptradd (arg1, arg2);
d2440 1
a2458 1
	  arg2 = value_from_longest (builtin_type_uint8, (LONGEST) 1);
d2460 1
a2460 1
	    arg2 = value_ptrsub (arg1, arg2);
d2464 1
@


1.113
log
@        * ada-lang.c (evaluate_subexp): Delete.  Use the version from eval.c.
        (evaluate_subexp_type): Reimplement using evaluate_subexp.
        * value.h (evaluate_subexp): Add declaration.
        * eval.c (evaluate_subexp): Make non-static.
        * objc-lang.c (print_object_command): Use evaluate_subexp.
@
text
@d941 1
a941 1
		  if (gdbarch_bits_big_endian (current_gdbarch))
@


1.112
log
@	* gdbtypes.c (create_string_type): Receive character type as argument.
	* gdbtypes.h (create_string_type): Add character type argument.
        * dwarf2read.c (read_tag_string_type): Pass character type to
	create_string_type.

	* value.h (value_string): Add character type argument.
	* valops.c (value_string): Add character type argument.  Pass it to
	create_string_type.  Do not allocate space in inferior.
	* valarith.c (value_concat): Pass character type to value_string.

	* value.h (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* valops.c (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* c-lang.c (evaluate_subexp_c): Update.

	* python/python-value.c (builtin_type_pychar): New define.
	(convert_value_from_python): Call value_cstring instead
	of value_from_string.
	* value.c (value_from_string): Remove.
	* value.h (value_from_string): Remove.

	* eval.c (evaluate_subexp_standard): Pass character type to
	value_string.  Pass expression architecture to value_nsstring
	and lookup_child_selector.
	* objc-lang.h (lookup_objc_class): Add GDBARCH parameter.
	(lookup_child_selector): Likewise.
	(value_nsstring): Likewise.
	* objc-lang.c (lookup_objc_class): Add GDBARCH parameter.
	Pass character type to value_string..
	(lookup_child_selector): Likewise.
	(value_nsstring): Add GDBARCH parameter, use it instead of
	objfile architecture.  Pass architecture to lookup_objc_class
	and lookup_child_selector. Pass character type to value_string.
	(end_msglist): Pass architecture to lookup_objc_class.
	* objc-exp.y: Pass architecture to lookup_objc_class.
@
text
@a58 3
static struct value *evaluate_subexp (struct type *, struct expression *,
				      int *, enum noside);

d69 1
a69 1
static struct value *
@


1.111
log
@	* dummy-frame.c (deprecated_pc_in_call_dummy): Add GDBARCH parameter,
	use it instead of current_gdbarch.
	* frame.h (deprecated_pc_in_call_dummy): Add GDBARCH parameter.
	* arm-tdep.c (arm_skip_prologue): Pass architecture to
	deprecated_pc_in_call_dummy.

	* symtab.c (skip_prologue_using_sal): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	* symtab.h (skip_prologue_using_sal): Add GDBARCH parameter.
	* breakpoint.c (expand_line_sal_maybe): Pass architecture to
	skip_prologue_using_sal.
	* arm-tdep.c (skip_prologue_using_sal): Likewise.
	* lm32-tdep.c (lm32_skip_prologue): Likewise.
	* m32-tdep.c (m32c_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* moxie-tdep.c (moxie_skip_prologue): Likewise.
	* mt-tdep.c (mt_frame_unwind_cache): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* frv-tdep.c (frv_analyze_prologue): Add GDBARCH parameter, pass
	it to skip_prologue_using_sal.  Update call sites ...
	(frv_skip_prologue, frv_frame_unwind_cache): ... here.

	* mn10300-tdep.c (struct mn10300_prologue): Add GDBARCH member.
	(check_for_saved): Use it instead of current_gdbarch.
	(mn10300_analyze_prologue): Set it.

	* value.c (using_struct_return): Add GDBARCH parameter.  Use it
	instead of current_gdbarch.
	* value.h (using_struct_return): Add GDBARCH parameter.
	* eval.c (evaluate_subexp_standard): Pass architecture to
	using_struct_return.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* symtab.c (in_prologue): Add GDBARCH parameter.  Use it instead of
	current_gdbarch.
	* symtab.h (in_prologue): Add GDBARCH parameter.
	* infrun.c (handle_inferior_event): Pass architecture to in_prologue.

	* eval.c (evaluate_subexp_standard): Use expression architecture
	instead of current_gdbarch.

	* c-lang.c (evaluate_subexp_c): Use expression architecture and
	language instead of current_gdbarch and current_language.

	* printcmd.c (do_one_display): Use expression architecture instead
	of current_gdbarch.

	* infcmd.c (print_return_value): Use architecture of stop_regcache
	instead of current_gdbarch.
	(print_vector_info, print_float_info): Remove GDBARCH argument,
	use frame architecture instead.
	(vector_info, float_info): Update calls.

	* objc-lang.c (objc_skip_trampoline): Use frame architecture
	instead of current_gdbarch.

	* parse.c (write_dollar_variable): Use parse architecture instead
	of current_gdbarch.

	* source.c (line_info): Use objfile architecture instead of
	current_gdbarch.

	* symtab.c (find_function_start_sal): Use gdbarch instead of
	current_gdbarch.
	(print_msymbol_info): Use objfile architecture instead of
	current_gdbarch.

	* valops.c (value_assign): Use frame architecture instead of
	current_gdbarch.
@
text
@d792 2
a793 1
      return value_string (&exp->elts[pc + 2].string, tem);
d802 1
a802 1
      return (struct value *) value_nsstring (&exp->elts[pc + 2].string, tem + 1);
d1014 2
a1015 1
	return value_from_longest (selector_type, lookup_child_selector (sel));
d1103 2
a1104 1
	responds_selector = lookup_child_selector ("respondsToSelector:");
d1106 2
a1107 1
	  responds_selector = lookup_child_selector ("respondsTo:");
d1112 2
a1113 1
	method_selector = lookup_child_selector ("methodForSelector:");
d1115 2
a1116 1
	  method_selector = lookup_child_selector ("methodFor:");
@


1.110
log
@	* eval.c (evaluate_subexp_standard) <OP_OBJC_MSGCALL>: Remove
	'static' from local variable definitions.
@
text
@d757 1
a757 1
	regno = user_reg_map_name_to_regnum (current_gdbarch,
d768 3
a770 3
	    && regno < gdbarch_num_regs (current_gdbarch)
	       + gdbarch_num_pseudo_regs (current_gdbarch))
	  val = value_zero (register_type (current_gdbarch, regno), not_lval);
d1188 2
a1189 1
	    struct_return = using_struct_return (value_type (method), val_type);
d1193 1
a1193 1
	    struct_return = using_struct_return (NULL,
@


1.109
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d1019 2
a1020 2
	static CORE_ADDR responds_selector = 0;
	static CORE_ADDR method_selector = 0;
d1027 3
a1029 3
	static struct value *msg_send = NULL;
	static struct value *msg_send_stret = NULL;
	static int gnu_runtime = 0;
@


1.108
log
@gdb/
2009-03-05  Tom Tromey  <tromey@@redhat.com>

	Add support for convenience functions in Python.
	* Makefile.in (SUBDIR_PYTHON_OBS): Add python-function.o.
	(SUBDIR_PYTHON_SRCS): Add python-function.c.
	(python-function.o): New target.
	* eval.c: Include "python/python.h" and <ctype.h>.
	(evaluate_subexp_standard): Handle values of type
	TYPE_CODE_INTERNAL_FUNCTION.
	* gdbtypes.h (type_code): Add TYPE_CODE_INTERNAL_FUNCTION.
	* parse.c (write_exp_string): Remove duplicate word in comment.
	* python/python-function.c: New file.
	* python/python-internal.h (gdbpy_initialize_functions): Add
	prototype.
	* python/python.c (_initialize_python): Call
	gdbpy_initialize_functions.
	* valprint.c (value_check_printable): Handle values of type
	TYPE_CODE_INTERNAL_FUNCTION.
	* value.c: Include "cli/cli-decode.h".
	(internal_function): New struct.
	(functionlist, internal_fn_type): New static variables.
	(lookup_only_internalvar,
	lookup_internalvar): Add const qualifier to name argument.
	(create_internalvar): Likewise.  Initialize new field.
	(set_internal_var): Fix typo in comment.  Don't allow assignment
	to canonical variable.
	(value_create_internal_function, value_internal_function_name,
	call_internal_function, function_command, function_destroyer,
	add_internal_function): New functions.
	(_initialize_values): Create `function' placeholder command.
	Initialize internal_fn_type.
	* value.h (lookup_only_internalvar, create_internalvar,
	lookup_internalvar): Add const qualifier to name argument.
	(internal_function_fn, add_internal_function, call_internal_function,
	value_internal_function_name): Add prototypes.
	(struct internalvar) <canonical>: New field.

gdb/doc/
2008-03-05  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Convenience Vars): Document convenience functions.
	(Functions In Python): New node.
	(Python API): Update.

gdb/testsuite/
2009-03-05  Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* gdb.python/python-function.exp: New file.
@
text
@d1214 1
a1214 1
	      VALUE_ADDRESS (method) = value_as_address (msg_send_stret);
d1216 1
a1216 1
	      VALUE_ADDRESS (method) = value_as_address (msg_send);
d1440 1
a1440 1
					 VALUE_ADDRESS (temp) + value_offset (temp)
@


1.107
log
@2009-03-20  Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* dwarf2read.c (process_die): Handle DW_TAG_typedef.
	* eval.c (evaluate_subexp_standard) <OP_TYPE>: Strip a single
	typedef.
	* ada-lang.c (decode_packed_array_type): Call CHECK_TYPEDEF on the
	SYMBOL_TYPE result.
	* ada-typeprint.c (print_array_type): Do the NULL check
	unconditionally.
@
text
@d43 1
d47 2
d1518 3
@


1.106
log
@2008-02-21  Pedro Alves  <pedro@@codesorcery.com>

	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
	* amd64-nat.c: Include "amd64-nat.h".
	* fork-child.c (_initialize_fork_child): Ditto.
	* gcore.c (_initialize_gcore): Ditto.
	* inf-ptrace.c: Include "inf-ptrace.h".
	(inf_ptrace_store_registers): Make it static.
	* linux-nat.c (linux_nat_terminal_ours): Make it static.
	(_initialize_linux_nat): Declare before definition.
	* linux-tdep.c: Include "linux-tdep.h".
	* linux-thread-db.c (_initialize_thread_db): Declare before
	definition.
	* proc-service.c (_initialize_proc_service): Ditto.
	* remote.c (remote_send_printf): Make it static.
	* solib.c: Include "solib.h".
	* symfile-mem.c (_initialize_symfile_mem): Declare before
	definition.
	* ada-lang.c (ada_la_decode, ada_match_name)
	(ada_suppress_symbol_printing, ada_is_array_type)
	(ada_value_ptr_subscript, ada_array_length)
	(ada_to_static_fixed_value): Make them static.
	(_initialize_ada_language): Declare before definition.
	* ada-tasks.c (ada_get_task_number, ada_get_environment_task)
	(ada_task_list_changed, ada_new_objfile_observer): Make them
	static.
	(_initialize_tasks): Declare before definition.
	* addrmap.c (_initialize_addrmap): Declare before definition.
	* auxv.c (default_auxv_parse): Make it static.
	* bfd-target.c (target_bfd_xfer_partial, target_bfd_xclose): Make
	them static.
	* breakpoint.c (remove_sal): Add line break.
	(expand_line_sal_maybe): Make it static.
	* cp-name-parser.y: Include "cp-support.h".
	* cp-valprint.c (cp_find_class_member): Make it static.
	* eval.c (value_f90_subarray): Ditto.
	* exceptions.c (print_any_exception): Ditto.
	* findcmd.c (_initialize_mem_search): Declare before definition.
	* frame.c (frame_observer_target_changed): Make it static.
	* gnu-v3-abi.c (gnuv3_find_method_in): Make it static.
	* inf-child.c: Include "inf-child.h".
	* inferior.h (valid_inferior_id): Rename to ...
	(valid_gdb_inferior_id): ... this.
	* infrun.c (infrun_thread_stop_requested, siginfo_make_value):
	Make them static.
	* jv-lang.c (java_language_arch_info): Make it static.
	* m2-typeprint.c (m2_get_discrete_bounds): Ditto.
	* osdata.c (info_osdata_command): Make it static.
	* regcache.c (regcache_observer_target_changed): Make it static.
	* reverse.c (_initialize_reverse): Declare before definition.
	* stabsread.c (cleanup_undefined_types_noname)
	(cleanup_undefined_types_1): Make them static.
	* symfile.c (place_section): Make it static.
	* symtab.c (find_pc_sect_psymtab_closer): Make it static.
	* target-descriptions.c (_initialize_target_descriptions): Declare
	before definition.
	* target.c (default_get_ada_task_ptid, find_default_can_async_p)
	(find_default_is_async_p, find_default_supports_non_stop): Make
	them static.
	(target_supports_non_stop): Add prototype.
	(dummy_pid_to_str): Make it static.
	* utils.c (_initialize_utils): Declare before definition.
	* ada-exp.y (_initialize_ada_exp): Declare before definition.
	* solib-svr4.c (HAS_LM_DYNAMIC_FROM_LINK_MAP): Add a prototype.
	* target.h (struct target_ops): Add a prototype to the
	to_can_execute_reverse callback.
	* macroscope.c (_initialize_macroscope): Declare before definition.
	* cp-namespace.c (_initialize_cp_namespace): Declare before definition.
	* python/python.c (_initialize_python): Declare before definition.
	* tui/tui-command.c: Include "tui/tui-command.h".
	* tui/tui-data.c (init_content_element, init_win_info): Make them
	static.
	* tui/tui-disasm.c: Include "tui/tui-disasm.h".
	* tui/tui-interp.c (_initialize_tui_interp): Declare before
	definition.
	* tui/tui-layout.c: Include "tui/tui-layout.h".
	(_initialize_tui_layout): Declare before definition.
	* tui/tui-regs.c: Include "tui/tui-regs.h".
	(tui_display_reg_element_at_line): Make it static.
	(_initialize_tui_regs): Declare before definition.
	* tui/tui-stack.c (_initialize_tui_stack): Declare before
	definition.
	* tui/tui-win.c: Include "tui/tui-win.h".
	(_initialize_tui_win): Declare before definition.
	(tui_sigwinch_handler): Make it static.  Wrap in ifdef SIGWINCH.
	* tui/tui-win.h (tui_sigwinch_handler): Delete declaration.
	(tui_get_cmd_list): Add a prototype.
	* tui/tui-windata.c: Include tui-windata.h.
	* tui/tui-wingeneral.c (box_win): Make it static.
	* cli/cli-logging.c (show_logging_command): Make it static.
	(_initialize_cli_logging): Declare before definition.
	* mi/mi-common.c (_initialize_gdb_mi_common): Declare before
	definition.
@
text
@d2478 11
a2488 1
        return allocate_value (exp->elts[pc + 1].type);
@


1.105
log
@	* value.h (address_of_variable): Add prototype.
	(locate_var_value): Remove prototype.

	* findvar.c (read_var_value): Do not attempt to default frame
	to selected frame.
	(locate_var_value): Remove function.
	* valops.c (value_of_variable): Retrieve selected frame for
	symbols that require a frame when called with NULL block.
	* valops.c (address_of_variable): New function.

	* eval.c (evaluate_subexp_for_address): Call address_of_variable
	instead of calling locate_var_value.
	(evaluate_subexp_with_coercion): Likewise.
@
text
@d416 1
a416 1
struct value *
@


1.104
log
@        Updated copyright notices for most files.
@
text
@a2562 5
      else if (symbol_read_needs_frame (var))
	return
	  locate_var_value
	  (var,
	   block_innermost_frame (exp->elts[pc + 1].block));
d2564 1
a2564 1
	return locate_var_value (var, NULL);
d2618 1
d2627 2
a2628 1
      if (TYPE_CODE (check_typedef (SYMBOL_TYPE (var))) == TYPE_CODE_ARRAY
d2632 2
a2633 4
	  val =
	    locate_var_value
	    (var, block_innermost_frame (exp->elts[pc + 1].block));
	  return value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (check_typedef (SYMBOL_TYPE (var)))),
@


1.103
log
@	Fix TYPE_HIGH_BOUND for TYPE_CODE_RANGE using arbitrary TYPE_NFIELDS in
	preparation for supporting DW_AT_byte_stride.
	* ada-lang.c (packed_array_type, ada_index_type): Use TYPE_INDEX_TYPE.
	(ada_array_bound_from_type): Move `index_type' declaration to the
	function start.  New variable `retval'.  Return the bounds for
	TYPE_CODE_RANGE using TYPE_LOW_BOUND and TYPE_HIGH_BOUND.  Abort on
	invalid index type codes.
	* ada-typeprint.c (print_range): Set `upper_bound' for TYPE_CODE_RANGE
	now using TYPE_HIGH_BOUND.
	* ada-valprint.c (val_print_packed_array_elements): Use `index_type'.
	* eval.c (evaluate_subexp_standard): Use TYPE_INDEX_TYPE.
	* gdbtypes.c (create_range_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	refer to the number of fields only through TYPE_NFIELDS.
	(create_array_type): Use TYPE_INDEX_TYPE.
	(check_typedef): Use TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
	* gdbtypes.h (TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): Use TYPE_INDEX_TYPE.
	(TYPE_ARRAY_UPPER_BOUND_VALUE, TYPE_ARRAY_LOWER_BOUND_VALUE): Use
	TYPE_INDEX_TYPE, TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* hppa-tdep.c (hppa_alignof <TYPE_CODE_ARRAY>): Use TYPE_INDEX_TYPE.
	* mdebugread.c (parse_type): Use TYPE_LOW_BOUND, TYPE_HIGH_BOUND,
	* valarith.c (value_bit_index): Use TYPE_INDEX_TYPE.
@
text
@d4 2
a5 2
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
@


1.102
log
@	* eval.c (evaluate_subexp_standard): Assert that there is at
	least one array dimension.
@
text
@d827 1
a827 1
	  struct type *range_type = TYPE_FIELD_TYPE (type, 0);
@


1.101
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d1979 2
@


1.100
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d42 1
a48 4
/* JYG: lookup rtti type of STRUCTOP_PTR when this is set to continue
   on with successful lookup for member/method of the rtti type. */
extern int objectprint;

d1628 4
a1631 2
        
        if (objectprint && TYPE_TARGET_TYPE(type) &&
@


1.99
log
@gdb/
	Replace TYPE_ARRAY_{UPPER,LOWER}_BOUND_TYPE by a bit if {un,}defined.
	* c-typeprint.c (c_type_print_varspec_suffix), m2-typeprint.c
	(m2_array), p-typeprint.c (pascal_type_print_varspec_prefix),
	valops.c (value_cast), varobj.c (c_number_of_children): Replace
	TYPE_ARRAY_UPPER_BOUND_TYPE compared to BOUND_CANNOT_BE_DETERMINED by
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* parse.c (follow_types): Use TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	* f-valprint.c (f77_get_dynamic_upperbound): Replace with ...
	(f77_get_upperbound): ... this function handling now only
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_lowerbound): Replace with ...
	(f77_get_lowerbound): ... this function handling now only
	TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED.
	(f77_get_dynamic_length_of_aggregate, f77_create_arrayprint_offset_tbl):
	Update their callers.
	* eval.c (evaluate_subexp_standard): Update their callers.
	* f-lang.h (f77_get_dynamic_upperbound, f77_get_upperbound)
	(f77_get_dynamic_lowerbound, f77_get_lowerbound): Update their
	prototypes.
	(BOUND_FETCH_OK, BOUND_FETCH_ERROR): Remove.
	* f-typeprint.c (f_type_print_varspec_suffix, f_type_print_base): Remove
	the lower_bound_was_default variable.  Update the
	f77_get_dynamic_upperbound, f77_get_upperbound and
	TYPE_ARRAY_UPPER_BOUND_TYPE calls.
	* gdbtypes.c (print_bound_type): Remove the function.
	(recursive_dump_type): Remove its calls printing UPPER_BOUND_TYPE and
	LOWER_BOUND_TYPE.
	* gdbtypes.h (enum array_bound_type): Remove.
	(struct main_type): Remove the fields upper_bound_type and
	lower_bound_type.  Comment the new overload of the field artificial.
	(TYPE_ARRAY_UPPER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED): ... this macro.
	(TYPE_ARRAY_LOWER_BOUND_TYPE): Replace by ...
	(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED): ... this macro.

gdb/testsuite/
	* gdb.base/maint.exp (maint print type): Remove printing
	UPPER_BOUND_TYPE and LOWER_BOUND_TYPE.
@
text
@d322 2
a323 1
			 && TYPE_FIELD_STATIC_KIND (struct_type, fieldno))
@


1.98
log
@	* valops.c: Include "objfiles.h" and "symtab.h".
	(find_function_in_inferior): New argument OBJF_P.  Use it to return
	objfile where function is defined.  Use per-objfile arch types
	instead of builtin_type_ to define default return type.

	* linux-fork.c (checkpoint_command): Update calls.  Use per-objfile
	architecture to define inferior call argument types.
	* gcore.c (derive_heap_segment): Likewise.
	* objc-lang.c (value_nsstring): Likewise.
	* scm-lang.c (scm_lookup_name): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* valops.c (value_allocate_space_in_inferior): Likewise.

	* eval.c (evaluate_subexp_standard): Update calls.
	* objc-lang.c (lookup_objc_class, print_object_command): Likewise.

	* linux-fork.c: Include "objfiles.h".
	* scm-lang.c: Include "objfiles.h".
	* scm-valprint.c: Include "objfiles.h".
@
text
@d1997 2
a1998 7
	    retcode = f77_get_dynamic_upperbound (tmp_type, &upper);
	    if (retcode == BOUND_FETCH_ERROR)
	      error (_("Cannot obtain dynamic upper bound"));

	    retcode = f77_get_dynamic_lowerbound (tmp_type, &lower);
	    if (retcode == BOUND_FETCH_ERROR)
	      error (_("Cannot obtain dynamic lower bound"));
@


1.97
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@d1079 3
a1081 2
	    msg_send = find_function_in_inferior ("objc_msg_lookup");
	    msg_send_stret = find_function_in_inferior ("objc_msg_lookup");
d1089 1
a1089 1
	    msg_send = find_function_in_inferior ("objc_msgSend");
d1091 2
a1092 1
	    msg_send_stret = find_function_in_inferior ("objc_msgSend_stret");
@


1.96
log
@	* eval.c (evaluate_subexp_standard): Use exp->gdbarch types instead
	of builtin_type_ macros when handling OP_OBJC_ operations.
	* objc-lang.c (print_object_command): Likewise.
@
text
@d2031 1
a2031 1
	arg2 = value_from_longest (builtin_type_f_integer, offset_item);
@


1.95
log
@	* valops.c (value_ind): No longer allow dereferencing an
	integer type.
	* eval.c (evaluate_subexp_standard): Handle deferencing an
	integer type here.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
@
text
@d1002 1
d1010 3
a1012 2
	return value_from_longest (lookup_pointer_type (builtin_type_void),
				   lookup_child_selector (sel));
d1035 1
d1047 3
a1049 1
	selector_type = lookup_pointer_type (builtin_type_void);
d1058 1
a1058 1
 	  return value_from_longest (builtin_type_long, 0);
d1073 1
a1073 2
	    struct type *type;
	    type = lookup_pointer_type (builtin_type_void);
d1117 2
a1118 2
	argvec[2] = value_from_longest (builtin_type_long, responds_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
d1139 2
a1140 2
	argvec[2] = value_from_longest (builtin_type_long, method_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
d1259 1
a1259 1
	argvec[2] = value_from_longest (builtin_type_long, selector);
@


1.94
log
@	* eval.c (evaluate_subexp_standard): Use builtin_type_int8
	to construct the EVAL_SKIP dummy return value.
	* ada-lang.c (ada_evaluate_subexp): Likewise.
	* jv-lang.c (evaluate_subexp_java): Likewise.
	* m2-lang.c (evaluate_subexp_modula2): Likewise.
	* scm-lang.c (evaluate_exp): Likewise.
@
text
@d2291 2
a2292 1
	    return value_zero (builtin_type_int, lval_memory);
d2296 8
@


1.93
log
@	* eval.c (evaluate_subexp_standard): Add calls to binop_promote
	and unop_promote before calling value_binop et. al.
	* ada-lang.c (ada_evaluate_subexp): Add calls to binop_promote
	and unop_promote before calling value_binop et. al.

	* valarith.c (value_binop): Do not call binop_promote or unop_promote.
	(value_pos): Do not call unop_promote.
	(value_neg, value_complement): Likewise.
@
text
@d2485 1
a2485 1
  return value_from_longest (builtin_type_long, (LONGEST) 1);
@


1.92
log
@	* value.h (unop_promote, binop_promote): Add prototypes.
	* eval.c (unop_promote, binop_promote): New functions.
	* valarith.c (unop_result_type, binop_result_type): Remove.
	(value_binop): Call binop_promote or unop_promote.
	Inline remaining parts of binop_result_type.  Remove special
	code to truncate integer values for unsigned operations.
	(value_pos): Call unop_promote.  Inline remaining parts of
	unop_result_type.
	(value_neg, value_complement): Likewise.
@
text
@d1728 13
a1740 1
	arg2 = value_binop (arg1, arg2, op);
d1755 4
a1758 1
	return value_binop (arg1, arg2, BINOP_ADD);
d1779 4
a1782 1
	return value_binop (arg1, arg2, BINOP_SUB);
d1819 1
d1824 11
a1834 1
	    return value_binop (arg1, arg2, op);
d2105 1
d2122 1
d2139 1
d2156 1
d2173 1
d2190 1
d2223 4
a2226 1
	return value_pos (arg1);
d2235 4
a2238 1
	return value_neg (arg1);
d2250 4
a2253 1
	return value_complement (arg1);
d2371 5
a2375 1
	    arg2 = value_binop (arg1, arg2, BINOP_ADD);
d2394 5
a2398 1
	    arg2 = value_binop (arg1, arg2, BINOP_SUB);
d2417 5
a2421 1
	    arg2 = value_binop (arg1, arg2, BINOP_ADD);
d2441 5
a2445 1
	    arg2 = value_binop (arg1, arg2, BINOP_SUB);
@


1.91
log
@	* value.h (value_add, value_sub): Remove.
	(value_ptradd, value_ptrsub, value_ptrdiff): Add prototypes.
	* valarith.c (value_add, value_sub): Remove.
	(value_ptradd, value_ptrsub, value_ptrdiff): New functions.
	(find_size_for_pointer_math): Add assertion.  Update comment.
	(value_binop): Update comment.

	* eval.c (ptrmath_type_p): New function.
	(evaluate_subexp_standard): Replace value_add and value_sub
	by value_ptradd, value_ptrsub, value_ptrdiff or value_binop.
	Use builtin_type_uint8 instead of builtin_type_char to hold
	the increment for BINOP_{PRE,POST}{IN,DE}CREMENT operations.
	* valarith.c (value_subscript): Replace value_add by
	value_ptradd.  Replace value_sub by value_binop.
	* ada-lang.c (ada_value_ptr_subscript): Likewise.
	(ada_tag_name_2): Replace value_add by value_ptradd.
	(ada_evaluate_subexp): Replace value_add and value_sub by
	value_binop.
	* m2-lang.c (evaluate_subexp_modula2): Replace value_add
	by value_ptradd.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_method_ptr_to_value): Likewise.
@
text
@d442 193
@


1.90
log
@	* eval.c (evaluate_subexp_for_sizeof): Use builtin_int type of
	the expression architecture instead of builtin_type_int as the
	sizeof return type.
@
text
@d442 21
d1530 4
a1533 4
      else if (op == BINOP_ADD)
	arg2 = value_add (arg1, arg2);
      else if (op == BINOP_SUB)
	arg2 = value_sub (arg1, arg2);
d1545 4
d1550 1
a1550 1
	return value_add (arg1, arg2);
d1559 11
d1571 1
a1571 1
	return value_sub (arg1, arg2);
d2130 6
a2135 2
	  arg2 = value_add (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
d2149 6
a2154 2
	  arg2 = value_sub (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
d2168 6
a2173 2
	  arg2 = value_add (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
d2188 6
a2193 2
	  arg2 = value_sub (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
@


1.89
log
@	* expression.h (enum exp_opcode): Document OP_COMPLEX to take
	a type parameter as expression element.
	* eval.c (evaluate_subexp_standard) [OP_COMPLEX]: Retrieve result
	type as expression element.
	* f-exp.y: Pass in type when buildin OP_COMPLEX expression.
	* parse.c (operator_length_standard): Update length of OP_COMPLEX.
@
text
@d2338 2
d2363 1
a2363 2
      return value_from_longest (builtin_type_int, (LONGEST)
				 TYPE_LENGTH (type));
d2368 1
a2368 2
      return value_from_longest (builtin_type_int,
				 (LONGEST) TYPE_LENGTH (type));
d2374 1
a2374 1
	value_from_longest (builtin_type_int, (LONGEST) TYPE_LENGTH (type));
d2378 1
a2378 1
      return value_from_longest (builtin_type_int,
@


1.88
log
@	* language.h (struct language_arch_info): New members
	bool_type_default and bool_type_symbol.
	(lang_bool_type): Remove prototype.
	(LA_BOOL_TYPE): Remove macro.
	(language_bool_type): Add prototype.
	* language.c (lang_bool_type): Remove.
	(language_bool_type): New function.

	* value.h (value_in): Change return value to int.
	* value.c (value_in): Return int instead of struct value *.

	* eval.c (evaluate_subexp_standard): Call language_bool_type instead
	of using LA_BOOL_TYPE.  Update call to value_in.
	* ada-lang.c (ada_evaluate_subexp): Call language_bool_type instead
	of using LA_BOOL_TYPE or builtin_type_int for boolean values.

	* language.c (unknown_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	* ada-lang.c (ada_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* c-lang.c (c_language_arch_info): Set bool_type_default member
	of struct language_arch_info.
	(cplus_language_arch_info): Set bool_type_symbol and bool_type_default
	members of struct language_arch_info.
	* f-lang.c (f_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* jv-lang.c (java_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* m2-lang.c (m2_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
	* p-lang.c (p_language_arch_info): Set bool_type_symbol and
	bool_type_default members of struct language_arch_info.
@
text
@d1372 1
d1376 1
a1376 1
      return value_literal_complex (arg1, arg2, builtin_type_f_complex_s16);
@


1.87
log
@	* value.h (value_bitstring_subscript): New prototype.
	* valarith.h (value_bitstring_subscript): New function.
	(value_subscript): No longer handle TYPE_CODE_BITSTRING.
	* eval.c (evaluate_subexp_standard): Call value_bitstring_subscript
	instead of value_subscript to handle TYPE_CODE_BITSTRING.
@
text
@d565 2
a566 2
      return value_from_longest (LA_BOOL_TYPE,
				 exp->elts[pc + 1].longconst);
d1621 2
a1622 1
      return value_in (arg1, arg2);
d1682 2
a1683 1
		  arg1 = value_bitstring_subscript (LA_BOOL_TYPE, arg1, arg2);
d1803 2
a1804 1
	  return value_from_longest (LA_BOOL_TYPE,
d1830 2
a1831 1
	  return value_from_longest (LA_BOOL_TYPE,
d1847 2
a1848 1
	  return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);
d1863 2
a1864 1
	  return value_from_longest (LA_BOOL_TYPE, (LONGEST) ! tem);
d1879 2
a1880 1
	  return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);
d1895 2
a1896 1
	  return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);
d1911 2
a1912 1
	  return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);
d1927 2
a1928 1
	  return value_from_longest (LA_BOOL_TYPE, (LONGEST) tem);
d1988 4
a1991 2
	return value_from_longest (LA_BOOL_TYPE,
				   (LONGEST) value_logical_not (arg1));
@


1.86
log
@	* frame.h (frame_map_regnum_to_name): Remove prototype.
	(frame_map_name_to_regnum): Remove prototype.
	* frame.c (frame_map_regnum_to_name): Remove.
	(frame_map_name_to_regnum): Remove.
	(frame_unwind_register_value): Use user_reg_map_regnum_to_name
	instead of frame_map_regnum_to_name.
	* ax-gdb.c: Include "user-regs.h".
	(gen_expr): Use user_reg_map_name_to_regnum instead of
	frame_map_name_to_regnum.
	* eval.c:  Include "user-regs.h".
	(evaluate_subexp_standard): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* infcmd.c (registers_info): Likewise.
	* parse.c: Include "user-regs.h".
	(write_dollar_variable): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* tracepoint.c: Include "user-regs.h".
	(encode_actions): Use user_reg_map_name_to_regnum
	instead of frame_map_name_to_regnum.
	* valops.c: Include "user-regs.h".
	(value_fetch_lazy): Use user_reg_map_regnum_to_name instead
	of frame_map_regnum_to_name.
@
text
@d1669 22
a1690 1
	      arg1 = value_subscript (arg1, arg2);
@


1.85
log
@gdb
	* value.h (evaluate_subexpression_type, extract_field_op):
	Declare.
	* printcmd.c (_initialize_printcmd): Use expression_completer for
	'p', 'inspect', 'call'.
	* parser-defs.h (parse_field_expression): Declare.
	* parse.c: Include exceptions.h.
	(in_parse_field, expout_last_struct): New globals.
	(mark_struct_expression): New function.
	(prefixify_expression): Return int.
	(prefixify_subexp): Return int.  Use expout_last_struct.
	(parse_exp_1): Update.
	(parse_exp_in_context): Add 'out_subexp' argument.  Handle
	in_parse_field.
	(parse_field_expression): New function.
	* expression.h (parse_field_expression): Declare.
	(in_parse_field): Likewise.
	* eval.c (evaluate_subexpression_type): New function.
	(extract_field_op): Likewise.
	* completer.h (expression_completer): Declare.
	* completer.c (expression_completer): New function.
	(count_struct_fields, add_struct_fields): New functions.
	* c-exp.y (yyparse): Redefine.
	(COMPLETE): New token.
	(exp): New productions.
	(saw_name_at_eof, last_was_structop): New globals.
	(yylex): Return COMPLETE when needed.  Recognize in_parse_field.
	(c_parse): New function.
	* breakpoint.c (_initialize_breakpoint): Use expression_completer
	for watch, awatch, and rwatch.
	* Makefile.in (parse.o): Depend on exceptions_h.
gdb/testsuite
	* gdb.base/break1.c (struct some_struct): New struct.
	(values): New global.
	* gdb.base/completion.exp: Add field name completion test.
gdb/doc
	* gdb.texinfo (Completion): Add field name example.
@
text
@d41 1
d542 2
a543 2
	regno = frame_map_name_to_regnum (deprecated_safe_get_selected_frame (),
					  name, strlen (name));
@


1.84
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d178 30
@


1.83
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d2175 1
a2175 2
	      || sym_class == LOC_REGISTER
	      || sym_class == LOC_REGPARM)
@


1.82
log
@
	* eval.c (evaluate_subexp_standard): Use value_subscripted_rvalue for
	multi_f77_subscript to support values from registers.
	* valarith.c (value_subscripted_rvalue): Remove prototype and static.
	* value.h (value_subscripted_rvalue): Add prototype.

	* f-typeprint.c (f_type_print_base): Add support for TYPE_CODE_UNION.
	Fix output.
	* f-valprint.c (f_val_print): Likewise.
@
text
@d921 1
a921 1
	    struct type *value_type;
d923 1
a923 1
	    funaddr = find_function_addr (method, &value_type);
d927 1
a927 1
	    CHECK_TYPEDEF (value_type);
d929 2
a930 2
	    if ((value_type == NULL) 
		|| (TYPE_CODE(value_type) == TYPE_CODE_ERROR))
d933 1
a933 1
		  value_type = expect_type;
d936 1
a936 1
	    struct_return = using_struct_return (value_type);
d940 2
a941 1
	    struct_return = using_struct_return (check_typedef (expect_type));
@


1.81
log
@	* eval.c (evaluate_subexp_for_address): Clarify error message.
	Use value_must_coerce_to_target.
	* infcall.c (value_arg_coerce): Call value_coerce_to_target.
	* valops.c (value_assign): Call value_coerce_to_target when
	assigning to anything but internalvars.  Leave GDB-side arrays
	as arrays when assigning to internalvars.
	(value_must_coerce_to_target, value_coerce_to_target): New.
	(value_coerce_array, value_addr): Call value_coerce_to_target.
	(value_array): Create the array in GDB's memory instead of
	the inferior's.
	* value.h (value_must_coerce_to_target, value_coerce_to_target):
	Declare.

	* gdb.texinfo (Expressions): Update description of malloced arrays.

	* gdb.base/printcmds.exp (test_print_array_constants): Do not expect
	*& to work on created array elements.
	(Top level): Test print $pc with a file.  Test string operations
	without a target.
	* gdb.base/ptype.exp: Do not expect *& to work on created array
	elements.
@
text
@d1723 1
a1723 1
	return value_ind (value_add (value_coerce_array (arg1), arg2));
@


1.80
log
@	* eval.c (evaluate_subexp_standard): Fix type of result of mixed
	integer/float division operations when EVAL_AVOID_SIDE_EFFECTS.
	* valops.c (value_one): New function.
	* value.h (value_one): Declare.

	Fix argument promotion for binary arithmetic ops for C.
	* valarith.c (unop_result_type): New fn.
	(binop_result_type): New fn.
	(value_binop): Move result type computation to binop_result_type.
	(value_pos, value_neg, value_complement): Move result type
	computation to unop_result_type.

	* gdb.base/whatis-exp.exp: Fix expected result of whatis x+y, x-y, x*y.
@
text
@d2207 1
a2207 1
	  if (VALUE_LVAL (x) == lval_memory)
d2214 1
a2214 1
	    error (_("Attempt to take address of non-lval"));
@


1.79
log
@        * eval.c (evaluate_subexp_standard): Add handling of user
        registers when in EVAL_AVOID_SIDE_EFFECTS mode.
@
text
@a1520 4
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
	       && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD
		   || op == BINOP_INTDIV))
	return value_zero (value_type (arg1), not_lval);
d1522 23
a1544 1
	return value_binop (arg1, arg2, op);
@


1.78
log
@2008-01-25  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* eval.c (evaluate_subexp_standard): Support
	BINOP_INTDIV opcode.
@
text
@d515 9
a523 1
	if (noside == EVAL_AVOID_SIDE_EFFECTS)
@


1.77
log
@	* gdbarch.sh (function_list): Add new property bits_big_endian to
	gdbarch structure.
	* gdbarch.{c,h}: Regenerate.

	* value.c (struct value): Replace BITS_BIG_ENDIAN by
	gdbarch_bits_big_endian (comment).
	(unpack_field_as_long, modify_field): Likewise.
	* value.h: Likewise (comment).
	* valops.c (value_slice): Likewise.
	* valarith.c (value_subscript, value_bit_index): Likewise.
	* gdbtypes.h (field): Likewise (comment).
	* eval.c (evaluate_subexp_standard): Likewise.
	* dwarf2read.c (dwarf2_add_field): Likewise.
	* ada-lang.c (decode_packed_array, ada_value_primitive_packed_val)
	(move_bits, ada_value_assign, value_assign_to_component): Likewise.

	* defs.h (BITS_BIG_ENDIAN): Remove.



	* gdbint.texinfo (Target Conditionals): Replace the description of
	BITS_BIG_ENDIAN with a description of gdbarch_bits_big_endian.
@
text
@d1499 1
d1514 2
a1515 1
	       && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
@


1.76
log
@	* Makefile.in (dfp.o): Depend on expression.h, gdbtypes.h and value.h.
	(valarith.o): Depend on dfp.h.
	(valops.o): Likewise.
	* dfp.c: Include expression.h, gdbtypes.h, value.h and dfp.h.
	(set_decnumber_context): New function.
	(decimal_check_errors): Likewise.
	(decimal_from_number): Likewise.
	(decimal_to_number): Likewise.
	(decimal_from_string): Use set_decnumber_context and
	decimal_check_errors.
	(decimal_from_integral): New function.
	(decimal_from_floating): Likewise.
	(decimal_to_double): Likewise.
	(promote_decimal): Likewise.
	(decimal_binop): Likewise.
	(decimal_is_zero): Likewise.
	(decimal_compare): Likewise.
	(decimal_convert): Likewise.
	* dfp.h (decimal_from_integral): New prototype.
	(decimal_from_floating): Likewise.
	(decimal_to_double): Likewise.
	(decimal_binop): Likewise.
	(decimal_is_zero): Likewise.
	(decimal_compare): Likewise.
	(decimal_convert): Likewise.
	* eval.c (evaluate_subexp_standard): Remove expect_type argument from
	call to value_from_decfloat.
	* valarith.c: Include dfp.h.
	(value_args_as_decimal): New function.
	(value_binop): Add if block to handle TYPE_CODE_DECFLOAT values.
	(value_logical_not): Likewise.
	(value_equal): Likewise.
	(value_less): Likewise.
	(value_pos): Likewise.
	(value_neg): Formatting fix.
	* valops.c: Include dfp.h.
	(value_cast): Add if block to handle TYPE_CODE_DECFLOAT values.
	* value.c (unpack_long): Add case to handle TYPE_CODE_DECFLOAT.
	(unpack_double): Add if block to handle TYPE_CODE_DECFLOAT.
	(value_from_decfloat): Remove expect_type argument.
	* value.h (value_from_decfloat): Update prototype.
@
text
@d689 1
a689 1
		  if (BITS_BIG_ENDIAN)
@


1.75
log
@        * eval.c (evaluate_subexp_for_address): Provide frame address to
        locate_var_value only if it will be needed.
@
text
@d461 2
a462 2
      return value_from_decfloat (expect_type, exp->elts[pc + 1].type,
				exp->elts[pc + 2].decfloatconst);
@


1.74
log
@	Updated copyright notices for most files.
@
text
@d2153 1
a2153 1
      else
d2158 2
@


1.73
log
@2007-10-25  Wu Zhou  <woodzltc@@cn.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* c-exp.y (YYSTYPE): Add typed_val_decfloat for decimal
	floating point in YYSTYPE union.
	(DECFLOAT) Add token and expression element handling code.
	(parse_number): Parse DFP constants, which end with suffix 'df',
	'dd' or 'dl'.  Return DECFLOAT.
	* eval.c (evaluate_subexp_standard): Call value_from_decfloat to
	handle OP_DECFLOAT.
	* expression.h (enum exp_opcode): Add an opcode (OP_DECFLOAT)
	for DFP constants.
	(union exp_element): Add decfloatconst to represent DFP
	elements, which is 16 bytes by default.
	* parse.c (write_exp_elt_decfloatcst): New function to write a
	decimal float const into the expression.
	(operator_length_standard): Set operator length for OP_DECFLOAT
	to 4.
	* parser-defs.h (write_exp_elt_decfloatcst): Prototype.
	* valarith.c (value_neg): Add code to handle the negation
	operation of DFP values.
	* value.c (value_from_decfloat): New function to get the value
	from a decimal floating point.
	* value.h (value_from_decfloat): Prototype.
@
text
@d4 1
a4 1
   1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
@


1.72
log
@	* block.h (struct block): Remove "gcc_compile_flag" member.
	(BLOCK_GCC_COMPILED): Remove.
	* block.c (allocate_block): Do not clear BLOCK_GCC_COMPILED.
	* buildsym.c (finish_block): Do not set it.
	* symmisc.c (dump_symtab_1): Do not dump it.

	* value.h (using_struct_return): Remove "gcc_p" argument.
	* value.c (using_struct_return): Likewise.
	* eval.c (evaluate_subexp_standard): Adapt callers.
	* infcall.c (call_function_by_hand): Likewise.
	* stack.c (return_command): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.

	* gdbarch.sh (push_dummy_code): Remove "using_gcc" parameter.
	* gdbarch.c, gdbarch.h: Regenerate.
	* cris-tdep.c (cris_push_dummy_code): Adapt prototype.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_code): Likewise.
	* infcall.c (generic_push_dummy_code, push_dummy_code): Likewise.
	(push_dummy_code, call_function_by_hand): Adapt callers.
@
text
@d459 5
@


1.71
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@a762 1
	int using_gcc = 0;
a913 3
	    /* If compiled without -g, assume GCC 2.  */
	    using_gcc = (b == NULL ? 2 : BLOCK_GCC_COMPILED (b));

d923 1
a923 1
	    struct_return = using_struct_return (value_type, using_gcc);
d927 1
a927 1
	    struct_return = using_struct_return (check_typedef (expect_type), using_gcc);
@


1.70
log
@	* expression.h (enum exp_opcode): Document a register name for
	OP_REGISTER.
	* parse.c (write_dollar_variable): Write the register name for
	OP_REGISTER.
	(operator_length_standard): Expect the register name following
	OP_REGISTER.
	* ada-lang.c (resolve_subexp): Likewise.
	* ax-gdb.c (gen_expr): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* expprint.c (print_subexp_standard, dump_subexp_body_standard):
	Likewise.
	* tracepoint.c (encode_actions): Likewise.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.69
log
@	* hppa-hpux-tdep.c (args_for_find_stub, HP_ACC_EH_notify_hook,
	HP_ACC_EH_set_hook_value, HP_ACC_EH_notify_callback, HP_ACC_EH_break,
	HP_ACC_EH_catch_throw, HP_ACC_EH_catch_catch, __eh_notification,
	hp_cxx_exception_support, hp_cxx_exception_support_initialized,
	eh_notify_hook_addr, eh_notify_callback_addr, eh_break_addr,
	eh_catch_throw_addr, break_callback_sal, setup_d_pid_in_inferior,
	find_stub_with_shl_get, cover_find_stub_with_shl_get,
	initialize_hp_cxx_exception_support, child_enable_exception_callback,
	current_ex_event, child_get_current_exception_event): Remove.
	(hppa_hpux_inferior_created): Remove.
	(hppa_hpux_init_abi): Do not install hppa_hpux_inferior_created.

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile): Remove.
	(deprecated_exception_support_initialized): Remove.
	(breakpoint_init_inferior): Remove handling of non-zero
	deprecated_exception_catchpoints_are_fragile.

	* symtab.h (deprecated_hp_som_som_object_present): Remove.
	* symtab.c (deprecated_hp_som_som_object_present): Remove.
	* c-typeprint.c (c_type_print_base): Remove handling of non-zero
	deprecated_hp_som_som_object_present.
	* eval.c (evaluate_subexp_standard): Likewise.
	* valops.c (value_cast): Likewise.

	* parse.c (parse_nested_classes_for_hpacc, coloncolon): Remove.
	* parser-defs.h (parse_nested_classes_for_hpacc): Remove.
	* c-exp.y (yylex): Do not call parse_nested_classes_for_hpacc.
@
text
@d503 2
a504 1
	int regno = longest_to_int (exp->elts[pc + 1].longconst);
d506 6
a511 1
	(*pos) += 2;
d517 1
a517 2
	  error (_("Value of register %s not available."),
		 frame_map_regnum_to_name (get_selected_frame (NULL), regno));
@


1.68
log
@	* Makefile.in (arm-tdep.o, eval.o, target-descriptions.o)
	(xml-tdesc.o): Update.
	* xml-support.c: Add a comment.
	(gdb_xml_enums_boolean): New variable.
	(gdb_xml_parse_attr_enum): Use strcasecmp.
	* xml-support.h (gdb_xml_enums_boolean): Declare.
	* xml-tdesc.c (struct tdesc_parsing_data): Record current_feature,
	next_regnum, and current_union.
	(tdesc_start_feature, tdesc_start_reg, tdesc_start_union)
	(tdesc_end_union, tdesc_start_field, tdesc_start_vector)
	(field_attributes, union_children, reg_attributes, union_attributes)
	(vector_attributes, feature_attributes, feature_children): New.
	(target_children): Make static.  Add <feature>.
	(tdesc_elements): Make static.
	* target-descriptions.c (struct tdesc_reg, tdesc_reg_p, type_p)
	(struct tdesc_feature, tdesc_feature_p): New types.
	(struct target_desc): Add features member.
	(struct tdesc_arch_data, tdesc_data): New.
	(target_find_description): Clarify error message.  Warn about
	ignored register descriptions.
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_data_init, tdesc_data_alloc)
	(tdesc_data_cleanup, tdesc_numbered_register)
	(tdesc_numbered_register_choices, tdesc_find_register)
	(tdesc_register_name, tdesc_register_type)
	(tdesc_remote_register_number, tdesc_register_reggroup_p)
	(set_tdesc_pseudo_register_name, set_tdesc_pseudo_register_type)
	(set_tdesc_pseudo_register_reggroup_p, tdesc_use_registers)
	(tdesc_free_reg, tdesc_create_reg, tdesc_free_feature)
	(tdesc_create_feature, tdesc_record_type): New.
	(free_target_description): Free features.
	(_initialize_target_descriptions): Initialize tdesc_data.
	* arch-utils.c (default_remote_register_number): New.
	* arch-utils.h (default_remote_register_number): New prototype.
	* target-descriptions.h (set_tdesc_pseudo_register_name)
	(set_tdesc_pseudo_register_type, set_tdesc_pseudo_register_reggroup_p)
	(tdesc_use_registers, tdesc_data_alloc, tdesc_data_cleanup)
	(tdesc_numbered_register, tdesc_numbered_register_choices)
	(tdesc_has_registers, tdesc_find_feature, tdesc_feature_name)
	(tdesc_named_type, tdesc_create_feature, tdesc_record_type)
	(tdesc_create_reg): Declare.
	* gdbarch.sh (remote_register_number): New entry.
	* gdbarch.c, gdbarch.h: Regenerate.
	* remote.c (init_remote_state): Use gdbarch_remote_register_number.
	* features/gdb-target.dtd: Add feature, reg, vector, union, and field.

	* arm-tdep.c (arm_register_aliases): New.
	(arm_register_name_strings): Rename to...
	(arm_register_names): ...this.  Make const.  Delete the old version.
	(current_option, arm_register_byte): Delete.
	(set_disassembly_style): Simplify.  Do not adjust arm_register_names.
	(value_of_arm_user_reg): New.
	(arm_gdbarch_init): Verify any described registers.  Call
	tdesc_use_registers.  Don't use arm_register_byte.  Create aliases
	for standard register names.
	(_initialize_arm_tdep): Do not adjust arm_register_names.
	* user-regs.c (struct user_reg): Add baton member.
	(append_user_reg, user_reg_add_builtin, user_regs_init)
	(user_reg_add, value_of_user_reg): Use a baton for user
	register functions.
	* std-regs.c: Update.
	* user-regs.h (user_reg_read_ftype, user_reg_add_builtin)
	(user_reg_add): Add baton argument.
	* NEWS: Mention target description register support.
	* features/arm-core.xml, features/arm-fpa.xml: New.
	* eval.c (evaluate_subexp_standard): Allow ptype $register
	when the program is not running.

	* gdb.texinfo (-target-disconnect): Use @@smallexample.
	(Requirements): Add anchor for Expat.  Update description.
	(Target Descriptions): Mention Expat.
	(Target Description Format): Document new elements.  Use
	@@smallexample.
	(Predefined Target Types, Standard Target Features): New sections.
	* doc/gdbint.texinfo (Target Descriptions): New section.

	* gdb.xml/single-reg.xml, gdb.xml/tdesc-regs.exp,
	gdb.xml/core-only.xml, gdb.xml/extra-regs.xml: New files.
@
text
@a1024 8
	  /* 1997-08-01 Currently we do not support function invocation
	     via pointers-to-methods with HP aCC. Pointer does not point
	     to the function, but possibly to some thunk. */
	  if (deprecated_hp_som_som_object_present)
	    {
	      error (_("Not implemented: function invocation through pointer to method with HP aCC"));
	    }

a1409 8
	  if (deprecated_hp_som_som_object_present)
	    {
	      /* With HP aCC, pointers to methods do not point to the
		 function code.  */
	      /* 1997-08-19 */
	      error (_("Pointers to methods not supported with HP aCC"));
	    }

a1424 8
	  if (deprecated_hp_som_som_object_present)
	    {
	      /* HP aCC generates offsets that have bit #29 set; turn it off to get
		 a real offset to the member. */
	      if (!mem_offset)	/* no bias -> really null */
		error (_("Attempted dereference of null pointer-to-member"));
	      mem_offset &= ~0x20000000;
	    }
a1447 18
      /* Do special stuff for HP aCC pointers to members */
      if (deprecated_hp_som_som_object_present)
	{
	  /* 1997-08-19 Can't assign HP aCC pointers to methods. No details of
	     the implementation yet; but the pointer appears to point to a code
	     sequence (thunk) in memory -- in any case it is *not* the address
	     of the function as it would be in a naive implementation. */
	  if (TYPE_CODE (value_type (arg1)) == TYPE_CODE_METHODPTR)
	    error (_("Assignment to pointers to methods not implemented with HP aCC"));

	  /* HP aCC pointers to data members require a constant bias.  */
	  if (TYPE_CODE (value_type (arg1)) == TYPE_CODE_MEMBERPTR)
	    {
	      unsigned int *ptr = (unsigned int *) value_contents (arg2);	/* forces evaluation */
	      *ptr |= 0x20000000;	/* set 29th bit */
	    }
	}

a1938 7
	  /* If HP aCC object, use bias for pointers to members */
	  if (deprecated_hp_som_som_object_present
	      && TYPE_CODE (value_type (retvalp)) == TYPE_CODE_MEMBERPTR)
	    {
	      unsigned int *ptr = (unsigned int *) value_contents (retvalp);	/* forces evaluation */
	      *ptr |= 0x20000000;	/* set 29th bit */
	    }
@


1.67
log
@Copyright updates for 2007.
@
text
@d42 1
d504 1
a504 1
	struct value *val = value_of_register (regno, get_selected_frame (NULL));
d506 4
@


1.66
log
@	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (c_value_of_root): Initialize new_val.

	* gdb.mi/mi-var-cmd.exp: Add tests for unreadable varobjs.
@
text
@d3 2
a4 2
   Copyright (C) 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
@


1.65
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d40 2
d474 20
a493 2
	return value_of_variable (exp->elts[pc + 2].symbol,
				  exp->elts[pc + 1].block);
@


1.64
log
@2006-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* Makefile.in (expprint.o, parse.o, target.o): Update.
	* dwarf2loc.c (dwarf_expr_tls_address): Move body to
	target_translate_tls_address.  Call it.
	* eval.c (evaluate_subexp_standard): Handle UNOP_MEMVAL_TLS.
	* expprint.c (print_subexp_standard): Likewise.
	(op_name_standard, dump_subexp_body_standard): Likewise.
	* expression.h (enum exp_opcode): Add UNOP_MEMVAL_TLS.
	(union exp_element): Add objfile.
	* parse.c (write_exp_elt_objfile): New function.
	(msym_tls_symbol_type): New.
	(write_exp_msymbol): Handle TLS.
	(operator_length_standard): Handle UNOP_MEMVAL_TLS.
	(build_parse): Initialize msym_tls_symbol_type.
	* parser-defs.h (write_exp_elt_objfile): New prototype.
	* target.c (target_translate_tls_address): New.
	* target.h (target_translate_tls_address): Add prototype.

2006-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.threads/tls-nodebug.c, gdb.threads/tls-nodebug.exp: New test.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005 Free
   Software Foundation, Inc.
d41 2
d439 2
d443 1
a443 1
				  noside);
a999 2
	  LONGEST fnptr;

d1032 4
a1035 1
	  fnptr = value_as_long (arg1);
d1037 1
a1037 1
	  if (METHOD_PTR_IS_VIRTUAL (fnptr))
d1039 2
a1040 25
	      int fnoffset = METHOD_PTR_TO_VOFFSET (fnptr);
	      struct type *basetype;
	      struct type *domain_type =
	      TYPE_DOMAIN_TYPE (TYPE_TARGET_TYPE (value_type (arg1)));
	      int i, j;
	      basetype = TYPE_TARGET_TYPE (value_type (arg2));
	      if (domain_type != basetype)
		arg2 = value_cast (lookup_pointer_type (domain_type), arg2);
	      basetype = TYPE_VPTR_BASETYPE (domain_type);
	      for (i = TYPE_NFN_FIELDS (basetype) - 1; i >= 0; i--)
		{
		  struct fn_field *f = TYPE_FN_FIELDLIST1 (basetype, i);
		  /* If one is virtual, then all are virtual.  */
		  if (TYPE_FN_FIELD_VIRTUAL_P (f, 0))
		    for (j = TYPE_FN_FIELDLIST_LENGTH (basetype, i) - 1; j >= 0; --j)
		      if ((int) TYPE_FN_FIELD_VOFFSET (f, j) == fnoffset)
			{
			  struct value *temp = value_ind (arg2);
			  arg1 = value_virtual_fn_field (&temp, f, j, domain_type, 0);
			  arg2 = value_addr (temp);
			  goto got_it;
			}
		}
	      if (i < 0)
		error (_("virtual function at index %d not found"), fnoffset);
d1043 1
a1043 4
	    {
	      deprecated_set_value_type (arg1, lookup_pointer_type (TYPE_TARGET_TYPE (value_type (arg1))));
	    }
	got_it:
d1378 6
a1383 1
      arg1 = evaluate_subexp_for_address (exp, pos, noside);
d1386 14
a1399 5
      /* With HP aCC, pointers to methods do not point to the function code */
      if (deprecated_hp_som_som_object_present &&
	  (TYPE_CODE (value_type (arg2)) == TYPE_CODE_PTR) &&
      (TYPE_CODE (TYPE_TARGET_TYPE (value_type (arg2))) == TYPE_CODE_METHOD))
	error (_("Pointers to methods not supported with HP aCC"));	/* 1997-08-19 */
d1401 8
a1408 2
      mem_offset = value_as_long (arg2);
      goto handle_pointer_to_member;
d1410 18
a1427 3
    case STRUCTOP_MPTR:
      arg1 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d1429 2
a1430 16
      /* With HP aCC, pointers to methods do not point to the function code */
      if (deprecated_hp_som_som_object_present &&
	  (TYPE_CODE (value_type (arg2)) == TYPE_CODE_PTR) &&
      (TYPE_CODE (TYPE_TARGET_TYPE (value_type (arg2))) == TYPE_CODE_METHOD))
	error (_("Pointers to methods not supported with HP aCC"));	/* 1997-08-19 */

      mem_offset = value_as_long (arg2);

    handle_pointer_to_member:
      /* HP aCC generates offsets that have bit #29 set; turn it off to get
         a real offset to the member. */
      if (deprecated_hp_som_som_object_present)
	{
	  if (!mem_offset)	/* no bias -> really null */
	    error (_("Attempted dereference of null pointer-to-member"));
	  mem_offset &= ~0x20000000;
a1431 18
      if (noside == EVAL_SKIP)
	goto nosideret;
      type = check_typedef (value_type (arg2));
      if (TYPE_CODE (type) != TYPE_CODE_PTR)
	goto bad_pointer_to_member;
      type = check_typedef (TYPE_TARGET_TYPE (type));
      if (TYPE_CODE (type) == TYPE_CODE_METHOD)
	error (_("not implemented: pointer-to-method in pointer-to-member construct"));
      if (TYPE_CODE (type) != TYPE_CODE_MEMBER)
	goto bad_pointer_to_member;
      /* Now, convert these values to an address.  */
      arg1 = value_cast (lookup_pointer_type (TYPE_DOMAIN_TYPE (type)),
			 arg1);
      arg3 = value_from_pointer (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
				 value_as_long (arg1) + mem_offset);
      return value_ind (arg3);
    bad_pointer_to_member:
      error (_("non-pointer-to-member value used in pointer-to-member construct"));
d1454 1
a1454 2
	  if ((TYPE_CODE (value_type (arg1)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (value_type (arg1))) == TYPE_CODE_METHOD))
d1457 2
a1458 3
	  /* HP aCC pointers to data members require a constant bias */
	  if ((TYPE_CODE (value_type (arg1)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (value_type (arg1))) == TYPE_CODE_MEMBER))
d1917 3
a1919 3
      if ((TYPE_TARGET_TYPE (value_type (arg1))) &&
	  ((TYPE_CODE (TYPE_TARGET_TYPE (value_type (arg1))) == TYPE_CODE_METHOD) ||
	   (TYPE_CODE (TYPE_TARGET_TYPE (value_type (arg1))) == TYPE_CODE_MEMBER)))
d1950 1
a1950 7
	  if (op == OP_SCOPE)
	    {
	      int temm = longest_to_int (exp->elts[pc + 3].longconst);
	      (*pos) += 3 + BYTES_TO_EXP_ELEM (temm + 1);
	    }
	  else
	    evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
d1957 2
a1958 3
	  if (deprecated_hp_som_som_object_present &&
	      (TYPE_CODE (value_type (retvalp)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (value_type (retvalp))) == TYPE_CODE_MEMBER))
d2124 1
d2139 1
a2139 9
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      if (VALUE_LVAL (x) == lval_memory)
		return value_zero (lookup_pointer_type (value_type (x)),
				   not_lval);
	      else
		error (_("Attempt to take address of non-lval"));
	    }
	  return value_addr (x);
d2179 10
d2192 1
d2195 2
d2200 3
@


1.63
log
@gdb/
	* eval.c (evaluate_subexp_for_address): Don't incorrectly discard
	calls to C++ operator*.
gdb/testsuite/
	* gdb.cp/userdef.cc, gdb.cp/userdef.exp: New tests for unary
	operator*.
@
text
@d2022 15
@


1.62
log
@gdb/
	* eval.c (evaluate_struct_tuple): Skip static fields.
gdb/testsuite/
	* gdb.cp/bs15503.exp: Update comment for no longer crashing
	test.
@
text
@d2135 1
d2144 18
a2161 1
      return evaluate_subexp (NULL_TYPE, exp, pos, noside);
d2200 1
a2202 1
	  struct value *x = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d2209 1
a2209 1
      return value_addr (evaluate_subexp (NULL_TYPE, exp, pos, noside));
@


1.61
log
@	2006-02-16  Fred Fish  <fnf@@specifix.com>
	* eval.c (evaluate_subexp_standard):  For OP_TYPE, return
	a non lval value zero, of the appropriate type, when avoiding
	side effects.
	* typeprint.c (ptype_eval): Remove function and declaration.
	(ptype_command): Simplify to just a call to whatis_exp.
@
text
@d286 4
@


1.61.14.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a285 4
		  /* Skip static fields.  */
		  while (fieldno < TYPE_NFIELDS (struct_type)
			 && TYPE_FIELD_STATIC_KIND (struct_type, fieldno))
		    fieldno++;
a2130 1
  struct value *x;
d2139 1
a2139 18
      x = evaluate_subexp (NULL_TYPE, exp, pos, noside);

      /* We can't optimize out "&*" if there's a user-defined operator*.  */
      if (unop_user_defined_p (op, x))
	{
	  x = value_x_unop (x, op, noside);
	  if (noside == EVAL_AVOID_SIDE_EFFECTS)
	    {
	      if (VALUE_LVAL (x) == lval_memory)
		return value_zero (lookup_pointer_type (value_type (x)),
				   not_lval);
	      else
		error (_("Attempt to take address of non-lval"));
	    }
	  return value_addr (x);
	}

      return x;
a2177 1
      x = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d2180 1
d2187 1
a2187 1
      return value_addr (x);
@


1.61.2.1
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>

	* gdb/dwarf2read.c (field_info): Add baseclasses.
	(dwarf2_add_field): Check base classes.
	(dwarf2_attach_fields_to_type): Ditto.

	* gdb/gnu-v3-abi.c (gnuv3_rtti_type): Check for NULL base_type.
	(gnuv3_virtual_fn_field): Handle missing base.
	(gnuv3_baseclass_offset): Handle missing vptr.
	* gdb/varobj.c (cplus_class_num_children): Call fill_in_vptr_fieldno.
	(cplus_name_of_child): Ditto.
	* gdb/eval.c (evaluate_subexp_standard): Ditto.
	* gdb/dwarf2read.c (read_structure_type): Search for vtable pointer
	by name in objects built by ARM compiler.

	* gdb/dwarf2read.c (dwarf2_add_member_fn): Calculate virtual function
	offset for classes without DW_AT_containing_type.
@
text
@a1037 1
	      fill_in_vptr_fieldno (domain_type);
@


1.61.2.2
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/c-valprint.c: Handle class member typedefs.

	* gdb/symtab.c (skip_prologue_using_sal): Treat two consecutive lines
	at the same address as a prolouge marker.
	* gdb/arm-tdep.c (arm_skip_prologue): Use skip_prologue_using_sal.

	* gdb/dwarf2expr.c (execute_stack_op): Check for bogus DW_OP_reg.

	* gdb/dwarf2read.c (read_structure_type): Use tag name for C++/Java
	classes.

	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (varobj_create): Call release_value after evaluate_type.
	(c_value_of_root): Initialize new_val.  Don't release_value a NULL
	value.

	* gdb/c-typeprint.c (cp_type_print_method_args): Don't print type
	details.

	* gdb/dwarf2read.c (dwarf2_debug_line_missing_file_complaint): New
	function.
	(dwarf_decode_lines): Check for line info without a file.
@
text
@a39 2
#include "ui-out.h"
#include "exceptions.h"
d464 2
a465 20
      {
	volatile struct gdb_exception except;
	struct value *ret = NULL;

	TRY_CATCH (except, RETURN_MASK_ERROR)
	  {
	    ret = value_of_variable (exp->elts[pc + 2].symbol,
				     exp->elts[pc + 1].block);
	  }

	if (except.reason < 0)
	  {
	    if (noside == EVAL_AVOID_SIDE_EFFECTS)
	      ret = value_zero (SYMBOL_TYPE (exp->elts[pc + 2].symbol), not_lval);
	    else
	      throw_exception (except);
	  }

	return ret;
      }
@


1.60
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d2089 9
a2097 1
      error (_("Attempt to use a type name as an expression"));
@


1.59
log
@        * expression.h (enum exp_opcode): Add a new operator for F90
        subrange.
        * f-lang.h (enum f90_range_type): New enumeration type to identify
        F90 subrange type.
        * f-exp.y (yyparse): Add support for parsing F90 subrange and
        change substring parsing to subrange parsing.
        * parse.c (operator_length_standard): Set the operator length
        and args number for OP_F90_RANGE.
        * eval.c (evaluate_subexp_standard): Add code to evaluate F90
        array section and substring.
        (value_f90_subarray): New function to evaluate F90 array section.
        (evaluate_subexp_standard): Delete label op_f77_substr and its code
        because the logic is implemented by function value_f90_subarray now.
@
text
@d3 1
a3 1
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.58
log
@	* f-exp.y (yyparse): Add code to support exponentiation expression.
	(yylex): Add code to scan exponentiation operator.
	* eval.c (evaluate_subexp_standard): Add support for BINOP_EXP.
	* valarith.c (value_binop): Reset errno to 0 before calling pow
	to do exponentiation operation.
@
text
@d381 24
d1294 4
a1297 1
	  goto multi_f77_subscript;
d1300 7
a1306 1
	  goto op_f77_substr;
a1324 21
    op_f77_substr:
      /* We have a substring operation on our hands here, 
         let us get the string we will be dealing with */

      /* Now evaluate the 'from' and 'to' */

      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);

      if (nargs < 2)
	return value_subscript (arg1, arg2);

      arg3 = evaluate_subexp_with_coercion (exp, pos, noside);

      if (noside == EVAL_SKIP)
	goto nosideret;

      tem2 = value_as_long (arg2);
      tem3 = value_as_long (arg3);

      return value_slice (arg1, tem2, tem3 - tem2 + 1);

@


1.57
log
@* eval.c (evaluate_struct_tuple): Use strcmp instead of
DEPRECATED_STREQ.
@
text
@d1513 1
@


1.56
log
@	* eval.c (evaluate_subexp_standard): Add code to check the target
	type of a TYPE_CODE_PTR value when we encounter a f77 undetermined
	arglist.  If it is array, string or function, work on the target
	value instead.
@
text
@d228 1
a228 1
		  if (field_name != NULL && DEPRECATED_STREQ (field_name, label))
d256 1
a256 1
				  if (DEPRECATED_STREQ (TYPE_FIELD_NAME (substruct_type,
d258 1
a258 1
					     label))
@


1.55
log
@2005-05-26  Andrew Cagney  <cagney@@gnu.org>

	* command.h (add_setshow_integer_cmd): Make VAR an integer.
	* cli/cli-decode.c (add_setshow_integer_cmd): Update to match.
	* valops.c (value_string): Add a cast.
	* eval.c (evaluate_subexp_standard): Use gdb_byte for byte buffers.
	* breakpoint.c (re_enable_breakpoints_in_shlibs): Use gdb_byte for
	byte buffers.
	* target.h (struct target_ops): For to_insert_hw_breakpoint and
	to_remove_hw_breakpoint use gdb_byte for byte buffer parameters.
	* breakpoint.h (struct bp_location): Make shadow_contents a
	gdb_byte buffer.
	* cli/cli-setshow.c (do_setshow_command): Fix cast.
	* cli/cli-dump.c (restore_section_callback)
	(restore_binary_file): Use gdb_byte for byte buffers.
	* proc-service.c (ps_ptwrite, ps_ptread, ps_pdwrite): Fix casts.
	(ps_xfer_memory): Use gdb_byte for byte buffers.
	* tracepoint.c (mem2hex): Use gdb_byte for byte buffers, and char
	for string buffers.
	* ser-tcp.c (net_open): Make len a socklen_t.
@
text
@d1249 18
@


1.54
log
@	* ax-gdb.c (gen_expr): Add UNOP_PLUS case.
	* c-exp.y (exp): Add unary plus.
	* eval.c (evaluate_subexp_standard): Add UNOP_PLUS case.
	* valarith.c (value_x_unop): Add UNOP_PLUS case.
	(value_pos): New.
	* value.h (value_pos): Declare.

	* gdb.cp/userdef.cc (A1::operator+): New unary plus.
	(A2): New class.
	(main): Test operator+.
	* gdb.cp/userdef.exp: Test unary plus.  Use A2::operator+ for
	breakpoint test.
@
text
@d562 1
a562 1
	  char *valaddr = value_contents_raw (set);
@


1.53
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d1858 9
@


1.52
log
@2005-02-08  Andrew Cagney  <cagney@@gnu.org>

	* value.h (METHOD_PTR_IS_VIRTUAL, METHOD_PTR_FROM_VOFFSET)
	(METHOD_PTR_TO_VOFFSET): Move from here ...
	* cp-support.h (METHOD_PTR_IS_VIRTUAL, METHOD_PTR_FROM_VOFFSET)
	(METHOD_PTR_TO_VOFFSET): ... to here.
	* cp-valprint.c, p-valprint.c, eval.c: Include "cp-support.h".
	* Makefile.in: Update dependencies.
@
text
@d267 1
a267 1
	      error ("there is no field named %s", label);
d288 1
a288 1
		    error ("too many initializers");
d292 1
a292 1
		    error ("don't know which variant you want to set");
d361 1
a361 1
	error ("tuple range index out of range");
d373 1
a373 1
	error ("tuple index out of range");
d413 1
a413 1
	error ("There is no field named %s", &exp->elts[pc + 3].string);
d454 1
a454 1
	  error ("Value of register %s not available.",
d547 1
a547 1
		    error ("Too many array elements");
d573 1
a573 1
	    error ("(power)set type with unknown size");
d607 1
a607 1
		error ("POWERSET tuple elements of different mode");
d611 1
a611 1
		error ("incompatible POWERSET tuple elements");
d614 1
a614 1
		  warning ("empty POWERSET tuple range");
d618 1
a618 1
		error ("POWERSET tuple element out of range");
d782 1
a782 1
	  error ("no 'respondsTo:' or 'respondsToSelector:' method");
d789 1
a789 1
	  error ("no 'methodFor:' or 'methodForSelector:' method");
d808 1
a808 1
	  error ("Target does not respond to this message selector.");
d890 1
a890 1
	      error ("method address has symbol information with non-function type; skipping");
d931 1
a931 1
	      error ("Expression of type other than \"method returning ...\" used as a method");
d975 1
a975 1
	      error ("Not implemented: function invocation through pointer to method with HP aCC");
d1030 1
a1030 1
		error ("virtual function at index %d not found", fnoffset);
d1211 1
a1211 1
	error ("Cannot evaluate function -- may be inlined");
d1227 1
a1227 1
	    error ("Expression of type other than \"Function returning ...\" used as function");
d1271 1
a1271 1
	  error ("Cannot perform substring on this type");
d1372 1
a1372 1
	error ("Pointers to methods not supported with HP aCC");	/* 1997-08-19 */
d1385 1
a1385 1
	error ("Pointers to methods not supported with HP aCC");	/* 1997-08-19 */
d1395 1
a1395 1
	    error ("Attempted dereference of null pointer-to-member");
d1405 1
a1405 1
	error ("not implemented: pointer-to-method in pointer-to-member construct");
d1415 1
a1415 1
      error ("non-pointer-to-member value used in pointer-to-member construct");
d1440 1
a1440 1
	    error ("Assignment to pointers to methods not implemented with HP aCC");
d1521 1
a1521 1
      error ("':' operator used in invalid context");
d1542 1
a1542 1
		error ("cannot subscript something of type `%s'",
d1545 1
a1545 1
		error ("cannot subscript requested type");
d1596 1
a1596 1
		  error ("cannot subscript something of type `%s'",
d1621 1
a1621 1
	  error ("Too many subscripts for F77 (%d Max)", MAX_FORTRAN_DIMS);
d1627 1
a1627 1
	  error ("Wrong number of subscripts");
d1649 1
a1649 1
	      error ("Cannot obtain dynamic upper bound");
d1653 1
a1653 1
	      error ("Cannot obtain dynamic lower bound");
d1845 1
a1845 1
	error ("Non-integral right operand for \"@@\" operator.");
d1896 1
a1896 1
	error ("Attempt to dereference pointer to member without an object");
d1915 1
a1915 1
	    error ("Attempt to take contents of a non-pointer value.");
d2049 1
a2049 1
      error ("Attempt to use a type name as an expression");
d2061 2
a2062 2
      error ("\
GDB does not (yet) know how to evaluate that kind of expression");
d2117 1
a2117 1
	    error ("Attempt to take address of register or constant.");
d2137 1
a2137 1
	    error ("Attempt to take address of non-lval");
d2217 1
a2217 1
	error ("Attempt to take contents of a non-pointer value.");
d2255 1
a2255 1
    error ("Internal error in eval_type.");
d2266 1
a2266 1
    error ("Can't get dimensions for a non-array type");
@


1.51
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (deprecated_set_value_type): Declare.
	* value.c (deprecated_set_value_type): Define.
	* hpacc-abi.c, gnu-v2-abi.c, cp-valprint.c: Update.
	* c-valprint.c, jv-lang.c, objc-lang.c, ada-lang.c: Update.
	* infcall.c, printcmd.c, valops.c, eval.c, p-exp.y: Update.
	* ax-gdb.c, tracepoint.c: Update.
@
text
@d39 1
@


1.50
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_embedded_offset): Delete.
	(value_embedded_offset): Declare.
	* value.c (value_embedded_offset): Define.
	* valops.c, p-valprint.c, mi/mi-main.c, hpacc-abi.c: Update.
	* gnu-v3-abi.c, eval.c, c-valprint.c, cp-valprint.c: Update.
	* cp-abi.h: Update.
@
text
@d948 2
a949 2
	    argvec[0]->type
	      = lookup_function_type (lookup_pointer_type (value_type (argvec[0])));
d1033 1
a1033 1
	      arg1->type = lookup_pointer_type (TYPE_TARGET_TYPE (value_type (arg1)));
d1691 1
a1691 1
	arg1->type = tmp_type;
@


1.49
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d1151 1
a1151 1
					 + VALUE_EMBEDDED_OFFSET (temp));
@


1.48
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (value_lazy): Declare.
	* varobj.c, value.c, valops.c, valarith.c, printcmd.c: Update.
	* cp-valprint.c, breakpoint.c, ada-lang.c: Update.
@
text
@d212 1
a212 1
      char *addr;
d318 1
a318 1
	  addr = VALUE_CONTENTS (struct_val) + bitpos / 8;
d323 1
a323 1
	    memcpy (addr, VALUE_CONTENTS (val),
d365 1
a365 1
		  VALUE_CONTENTS (element), element_size);
d374 1
a374 1
	      VALUE_CONTENTS (element), element_size);
d549 1
a549 1
			  VALUE_CONTENTS (element),
d1445 1
a1445 1
	      unsigned int *ptr = (unsigned int *) VALUE_CONTENTS (arg2);	/* forces evaluation */
d1942 1
a1942 1
	      unsigned int *ptr = (unsigned int *) VALUE_CONTENTS (retvalp);	/* forces evaluation */
@


1.47
log
@2005-02-01  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents_all_raw)
	(value_contents_raw): New functions.
	* value.h (VALUE_CONTENTS_ALL_RAW, VALUE_CONTENTS_RAW): Delete.
	(value_contents_raw, value_contents_all_raw): Declare functions.
	(VALUE_CONTENTS, VALUE_CONTENTS_ALL): Update.
	* std-regs.c, valarith.c, valops.c, eval.c: Update.
	* tracepoint.c, findvar.c: Update.
@
text
@d2146 1
a2146 1
   VALUE_LAZY).
@


1.46
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_TYPE, VALUE_NEXT, VALUE_OFFSET, VALUE_BITSIZE)
	(VALUE_BITPOS): Delete.
	(value_type, value_offset, value_bitsize, value_bitpos): Declare.
	* value.c (value_type, value_offset, value_bitpos)
	(value_bitsize): New functions.  Update references.
	* arm-tdep.c, gnu-v3-abi.c, hpacc-abi.c, gnu-v2-abi.c: Update.
	* f-valprint.c, cp-valprint.c, c-valprint.c: Update.
	* ada-valprint.c, typeprint.c, scm-valprint.c, scm-exp.c: Update.
	* p-valprint.c, jv-valprint.c, jv-lang.c, varobj.c: Update.
	* objc-lang.c, ada-lang.c, std-regs.c, stack.c: Update.
	* infcall.c, linespec.c, printcmd.c, valarith.c: Update.
	* valops.c, eval.c, findvar.c, breakpoint.c: Update.
	* tracepoint.c, ax-gdb.c, mi/mi-main.c, cli/cli-dump.c:
	* rs6000-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d4 2
a5 2
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
d363 1
a363 1
	  memcpy (VALUE_CONTENTS_RAW (array)
d373 1
a373 1
      memcpy (VALUE_CONTENTS_RAW (array) + (index - low_bound) * element_size,
d503 1
a503 1
	  memset (VALUE_CONTENTS_RAW (rec), '\0', TYPE_LENGTH (type));
d521 1
a521 1
	  memset (VALUE_CONTENTS_RAW (array), 0, TYPE_LENGTH (expect_type));
d547 1
a547 1
		  memcpy (VALUE_CONTENTS_RAW (array)
d561 1
a561 1
	  char *valaddr = VALUE_CONTENTS_RAW (set);
@


1.45
log
@2004-11-10  Andrew Cagney  <cagney@@gnu.org>

	* value.h (COERCE_REF, COERCE_ARRAY, COERCE_NUMBER, COERCE_ENUM)
	(coerce_ref, coerce_array, coerce_number, coerce_enum): Replace
	macros with function declarations.
	* value.c (coerce_ref, coerce_array, coerce_number)
	(coerce_enum): New functions.
	(value_as_long, value_as_address): Update.
	* ada-lang.c (ada_coerce_ref, ada_value_binop)
	(ada_evaluate_subexp, ada_value_assign, ada_value_struct_elt): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* valarith.c (value_less, value_neg, value_complement)
	(value_binop, value_add, value_subscript, value_x_binop)
	(value_logical_not, value_sub): Update.
	* valops.c (check_field, value_struct_elt, value_ind)
	(value_find_oload_method_list, value_cast, value_assign): Update.
	* eval.c (evaluate_subexp_standard): Update.
@
text
@d200 1
a200 1
  struct type *struct_type = check_typedef (VALUE_TYPE (struct_val));
d311 1
a311 1
	  if (VALUE_TYPE (val) != field_type)
d324 1
a324 1
		    TYPE_LENGTH (VALUE_TYPE (val)));
d344 1
a344 1
  int element_size = TYPE_LENGTH (VALUE_TYPE (element));
d532 1
a532 1
	      if (VALUE_TYPE (element) != element_type)
d583 1
a583 1
		  range_low_type = VALUE_TYPE (elem_val);
d586 1
a586 1
		  range_high_type = VALUE_TYPE (elem_val);
d592 1
a592 1
		  range_low_type = range_high_type = VALUE_TYPE (elem_val);
d888 1
a888 1
	    if (TYPE_CODE (VALUE_TYPE (method)) != TYPE_CODE_FUNC)
d917 1
a917 1
	    struct type *type = VALUE_TYPE (called_method);
d948 2
a949 2
	    VALUE_TYPE (argvec[0]) = lookup_function_type 
			    (lookup_pointer_type (VALUE_TYPE (argvec[0])));
d1008 1
a1008 1
	      TYPE_DOMAIN_TYPE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1)));
d1010 1
a1010 1
	      basetype = TYPE_TARGET_TYPE (VALUE_TYPE (arg2));
d1033 1
a1033 1
	      VALUE_TYPE (arg1) = lookup_pointer_type (TYPE_TARGET_TYPE (VALUE_TYPE (arg1)));
d1084 1
a1084 1
	  type = VALUE_TYPE (argvec[0]);
d1127 1
a1127 1
		arg_types[ix - 1] = VALUE_TYPE (argvec[ix]);
d1149 3
a1151 3
	      arg2 = value_from_longest (lookup_pointer_type(VALUE_TYPE (temp)),
			     VALUE_ADDRESS (temp) + VALUE_OFFSET (temp)
			     + VALUE_EMBEDDED_OFFSET (temp));
d1182 1
a1182 1
		arg_types[ix - 1] = VALUE_TYPE (argvec[ix]);
d1221 1
a1221 1
	  TYPE_TARGET_TYPE (VALUE_TYPE (argvec[0]));
d1224 1
a1224 1
	    return allocate_value (TYPE_TARGET_TYPE (VALUE_TYPE (argvec[0])));
d1245 1
a1245 1
      type = check_typedef (VALUE_TYPE (arg1));
d1309 1
a1309 1
	return value_zero (lookup_struct_elt_type (VALUE_TYPE (arg1),
d1331 1
a1331 1
        struct type *type = VALUE_TYPE (arg1);
d1352 1
a1352 1
	return value_zero (lookup_struct_elt_type (VALUE_TYPE (arg1),
d1369 2
a1370 2
	  (TYPE_CODE (VALUE_TYPE (arg2)) == TYPE_CODE_PTR) &&
      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
d1382 2
a1383 2
	  (TYPE_CODE (VALUE_TYPE (arg2)) == TYPE_CODE_PTR) &&
      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
d1399 1
a1399 1
      type = check_typedef (VALUE_TYPE (arg2));
d1428 1
a1428 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1437 2
a1438 2
	  if ((TYPE_CODE (VALUE_TYPE (arg1)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_METHOD))
d1442 2
a1443 2
	  if ((TYPE_CODE (VALUE_TYPE (arg1)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_MEMBER))
d1460 1
a1460 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1511 1
a1511 1
	return value_zero (VALUE_TYPE (arg1), not_lval);
d1536 1
a1536 1
	  type = check_typedef (VALUE_TYPE (arg1));
d1586 1
a1586 1
	      type = TYPE_TARGET_TYPE (check_typedef (VALUE_TYPE (arg1)));
d1596 1
a1596 1
			 TYPE_NAME (VALUE_TYPE (arg1)));
d1622 1
a1622 1
	tmp_type = check_typedef (VALUE_TYPE (arg1));
d1691 1
a1691 1
	VALUE_TYPE (arg1) = tmp_type;
d1749 1
a1749 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1764 1
a1764 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1779 1
a1779 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1794 1
a1794 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1809 1
a1809 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1824 1
a1824 1
      arg2 = evaluate_subexp (VALUE_TYPE (arg1), exp, pos, noside);
d1842 1
a1842 1
      type = check_typedef (VALUE_TYPE (arg2));
d1847 1
a1847 1
	  return allocate_repeat_value (VALUE_TYPE (arg1),
d1892 3
a1894 3
      if ((TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) &&
	  ((TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_METHOD) ||
	   (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_MEMBER)))
d1902 1
a1902 1
	  type = check_typedef (VALUE_TYPE (arg1));
d1939 2
a1940 2
	      (TYPE_CODE (VALUE_TYPE (retvalp)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (retvalp))) == TYPE_CODE_MEMBER))
d1962 1
a1962 1
      if (type != VALUE_TYPE (arg1))
d2133 1
a2133 1
	    return value_zero (lookup_pointer_type (VALUE_TYPE (x)),
d2212 1
a2212 1
      type = check_typedef (VALUE_TYPE (val));
d2236 1
a2236 1
				 (LONGEST) TYPE_LENGTH (VALUE_TYPE (val)));
@


1.44
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* value.h (struct value): Delete field bfd_section.
	(VALUE_BFD_SECTION): Delete macro.
	(COERCE_REF): Update.
	(value_at, value_at_lazy): Delete asection parameter.
	* printcmd.c (print_formatted, x_command): Update.
	(do_examine): Delete asection parameter.
	(next_section): Delete variable.
	* valops.c (value_cast, value_at, value_at_lazy)
	(value_coerce_function, value_addr, value_ind, value_string)
	(find_rt_vbase_offset, value_full_object): Update.
	* hpacc-abi.c (hpacc_virtual_fn_field)
	(hpacc_value_rtti_type): Update.
	* gnu-v3-abi.c (gnuv3_rtti_type, gnuv3_virtual_fn_field)
	(gnuv3_baseclass_offset): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* p-valprint.c (pascal_val_print): Update.
	* jv-valprint.c (java_value_print): Update.
	* jv-lang.c (java_class_from_object, evaluate_subexp_java): Update.
	* ada-lang.c (ada_value_primitive_packed_val)
	(ada_evaluate_subexp): Update.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Update.
	* expprint.c (print_subexp_standard): Update.
	* infcall.c (call_function_by_hand): Update.
	* valarith.c (value_add): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* values.c (allocate_value, value_copy, value_static_field): Update.
	* findvar.c (read_var_value, locate_var_value): Update.
@
text
@d1535 1
a1535 1
	  COERCE_REF (arg1);
@


1.43
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d1975 1
a1975 2
			      value_as_address (arg1),
			      NULL);
@


1.42
log
@2004-08-29  David Lecomber  <david@@streamline-computing.com>

	Fix PR gdb/648
	* language.h (enum array_ordering): New enum.
	* language.h (struct language_defn): New la_array_ordering
	attribute.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Ditto.
	* ada-lang.c (ada_language_defn): Ditto.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* m2-lang.c (f_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* p-lang.c (pascal_language_defn): Ditto.
	* scm-lang.c (scm_language_defn): Ditto.
	* eval.c (evaluate_subexp_standard): Assume Fortran arrays are
	oriented large to small in type structure.
	* dwarf2read.c (read_array_order): New function.
	(read_array_type): Use read_array_order to check row/column
	major ordering.
@
text
@d450 1
a450 1
	struct value *val = value_of_register (regno, get_selected_frame ());
d454 1
a454 1
		 frame_map_regnum_to_name (get_selected_frame (), regno));
@


1.41
log
@2004-04-08  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.h (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Declare.
	* hppa-hpux-tdep.c (initialize_hp_cxx_exception_support)
	(initialize_hp_cxx_exception_support)
	(child_enable_exception_callback): Update.
	* breakpoint.c (deprecated_exception_catchpoints_are_fragile)
	(deprecated_exception_support_initialized): Rename
	deprecated_exception_catchpoints_are_fragile and
	deprecated_exception_support_initialized.
	(breakpoint_init_inferior, breakpoint_init_inferior): Update.

	* symtab.c (deprecated_hp_som_som_object_present): Rename
	hp_som_som_object_present.
	* symtab.h (deprecated_hp_som_som_object_present): Declare.
	* symfile.c (hp_som_som_object_present, RESET_HP_UX_GLOBALS):
	Update.  Delete extern declaration.
	* valops.c (hp_som_som_object_present): Ditto.
	* parse.c (deprecated_hp_som_som_object_present)
	(parse_nested_classes_for_hpacc): Ditto.
	* hpread.c (hp_som_som_object_present, hpread_expand_symtab): Ditto.
	* hppa-hpux-tdep.c (hp_som_som_object_present)
	(initialize_hp_cxx_exception_support): Ditto.
	* eval.c (hp_som_som_object_present, evaluate_subexp_standard): Ditto.
	* cp-valprint.c (hp_som_som_object_present)
	(cp_print_class_method): Ditto.
	* c-typeprint.c (hp_som_som_object_present):
	(c_type_print_base): Ditto.
	* c-exp.y (hp_som_som_object_present): Ditto.
@
text
@d1613 2
a1614 3
	int subscript_array[MAX_FORTRAN_DIMS + 1];	/* 1-based array of 
							   subscripts, max == 7 */
	int array_size_array[MAX_FORTRAN_DIMS + 1];
d1632 2
a1633 1
	for (i = 1; i <= nargs; i++)
d1641 1
d1643 3
d1654 1
a1654 1
	    array_size_array[i] = upper - lower + 1;
d1658 1
a1658 1
	    subscript_array[i] -= lower;
d1668 1
a1668 1
	    if (i < nargs)
d1674 1
a1674 1
	offset_item = subscript_array[ndimensions];
d1676 1
a1676 1
	for (i = ndimensions - 1; i >= 1; i--)
d1678 1
a1678 1
	    array_size_array[i] * offset_item + subscript_array[i];
@


1.40
log
@2004-02-17  Ulrich Weigand <Ulrich.Weigand@@de.ibm.com>

	Committed by Jim Blandy  <jimb@@redhat.com>.

	* eval.c (evaluate_subexp_standard, case OP_OBJC_MSGCALL): Use
	CORE_ADDR as type for selectors.  Correct types for GNU run time
	message lookup function to use double indirection.
	* objc-lang.c (lookup_child_selector): Use CORE_ADDR as return type.
	* objc-lang.h (lookup_child_selector): Adapt prototype.
@
text
@a39 3
/* Defined in symtab.c */
extern int hp_som_som_object_present;

d972 1
a972 1
	  if (hp_som_som_object_present)
d1368 1
a1368 1
      if (hp_som_som_object_present &&
d1381 1
a1381 1
      if (hp_som_som_object_present &&
d1391 1
a1391 1
      if (hp_som_som_object_present)
d1431 1
a1431 1
      if (hp_som_som_object_present)
d1934 1
a1934 1
	  if (hp_som_som_object_present &&
@


1.40.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d40 3
d975 1
a975 1
	  if (deprecated_hp_som_som_object_present)
d1371 1
a1371 1
      if (deprecated_hp_som_som_object_present &&
d1384 1
a1384 1
      if (deprecated_hp_som_som_object_present &&
d1394 1
a1394 1
      if (deprecated_hp_som_som_object_present)
d1434 1
a1434 1
      if (deprecated_hp_som_som_object_present)
d1616 3
a1618 2
	int subscript_array[MAX_FORTRAN_DIMS];
	int array_size_array[MAX_FORTRAN_DIMS];
d1636 1
a1636 2
	/* Take array indices left to right */
	for (i = 0; i < nargs; i++)
a1643 1
	  }
a1644 3
	/* Internal type of array is arranged right to left */
	for (i = 0; i < nargs; i++)
	  {
d1653 1
a1653 1
	    array_size_array[nargs - i - 1] = upper - lower + 1;
d1657 1
a1657 1
	    subscript_array[nargs - i - 1] -= lower;
d1667 1
a1667 1
	    if (i < nargs - 1)
d1673 1
a1673 1
	offset_item = subscript_array[ndimensions - 1];
d1675 1
a1675 1
	for (i = ndimensions - 1; i > 0; --i)
d1677 1
a1677 1
	    array_size_array[i - 1] * offset_item + subscript_array[i - 1];
d1937 1
a1937 1
	  if (deprecated_hp_som_som_object_present &&
@


1.39
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d700 2
a701 2
	static unsigned long responds_selector = 0;
	static unsigned long method_selector = 0;
d703 1
a703 1
	unsigned long selector = 0;
d753 7
d762 4
a949 1
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
d951 3
a953 2
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
a954 2
	else
	  ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
d956 1
@


1.38
log
@2003-09-25  David Carlton  <carlton@@kealia.com>

	* c-exp.y: Include cp-support.h.  Add qualified_type.
	(yylex): Delete nested type hack; add comments.
	* cp-namespace.c (cp_lookup_nested_type): New function.
	* cp-support.h: Declare cp_lookup_nested_type.
	* eval.c (evaluate_subexp_standard): Call value_aggregate_elt
	instead of value_struct_elt_for_reference.
	* valops.c: Include cp-support.h.
	(value_aggregate_elt): New function.
	(value_namespace_elt): Ditto.
	(value_struct_elt_for_reference): Make static.
	* value.h: Delete declaration of value_struct_elt_for_reference;
	add declaration for value_aggregate_elt.
	* Makefile.in (c-exp.tab.o): Depend on $(cp_support_h).
	(valops.o): Ditto.

2003-09-25  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Tweak comments.  Add non-quoted versions
	of some print tests, where appropriate.  Add tests for C::D::cd,
	E::ce, F::cXfX, G::XgX.
	* gdb.cp/namespace.cc: Add XgX, cXfX, ce.
@
text
@d230 1
a230 1
		  if (field_name != NULL && STREQ (field_name, label))
d258 1
a258 1
				  if (STREQ (TYPE_FIELD_NAME (substruct_type,
@


1.37
log
@* parser-defs.h (struct exp_descriptor): New definition, containing
language-specific info for printing, prefixifying, dumping, and
evaluating expressions.
(exp_descriptor_standard): Declare new variable.
(print_subexp): Make global and declare here (from expprint.c).
(dump_subexp): Ditto.
(dump_subexp_body_standard): Declare.
(operator_length_standard): Declare.
(op_name_standard): Declare.
(print_subexp): Declare.
(print_subexp_standard): Declare.

* language.h (struct language_defn): Add la_exp_desc field to hold
pointer to table for language-specific operators.
Remove evaluate_exp field, which is now in struct exp_descriptor.

* parse.c (operator_length): Move most code to new
operator_length_standard function.  Use language-specific information.
(operator_length_standard): New function taking most code from
operator_length.
(exp_descriptor_standard): New constant.

* expression.h (enum exp_opcode): Add definitions of OP_EXTENDED0
and OP_EXTENDED_LAST.

* expprint.c (print_subexp): Use language-specific print_subexp.
Make global; remove static declaration.
Move most code to print_subexp_standard.
(print_subexp_standard): New function, containing code formerly in
print_subexp.
(op_name): Add expression to argument signature.
Use langauge-specific op_name.
Move most code to op_name_standard.
(op_name_standard): New function, containing code formerly in op_name.
(dump_subexp): 	Use new version of op_name function.
Use language-specific dump_subexp_body, and move most existing code to
dump_subexp_body_standard.
(dump_raw_expression): Use new op_name interface.
(dump_subexp_body): Move most code to dump_subexp_body_standard.
(dump_subexp_body_standard): New function, containing code formerly
in dump_subexp_body.

* language.c (unknown_language): Add default la_exp_desc field and
remove evaluate_exp field.
(auto_language): Ditto.
(local_language): Ditto.
* f-lang.c (f_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* p-lang.c (pascal_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.

* jv-lang.c (exp_descriptor_java): New variable, containing
Java-specific expression evaluator.
(java_language_defn): Add la_exp_desc field and remove evaluate_exp
field.
* scm-lang.c (exp_descriptor_scm): New variable, containing
Scheme-specific expression evaluator.
(scm_language_defn): Add la_exp_desc field and remove evaluate_exp
field.
* objc-lang.c (print_object_command): Take evaluate_exp from the
la_exp_desc field.

* Makefile.in (eval.o): Add dependency on parser-defs.h.

* eval.c: Include parser-defs.h for the full declaration of
la_exp_desc's type.
(evaluate_subexp): Get evaluate_exp out of la_exp_desc field.
@
text
@d411 3
a413 5
      arg1 = value_struct_elt_for_reference (exp->elts[pc + 1].type,
					     0,
					     exp->elts[pc + 1].type,
					     &exp->elts[pc + 3].string,
					     NULL_TYPE);
@


1.36
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d38 1
d74 2
a75 1
  return (*exp->language_defn->evaluate_exp) (expect_type, exp, pos, noside);
@


1.35
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d70 2
a71 2
evaluate_subexp (struct type *expect_type, register struct expression *exp,
		 register int *pos, enum noside noside)
d179 1
a179 1
get_label (register struct expression *exp, int *pos)
d198 2
a199 2
		       register struct expression *exp,
		       register int *pos, enum noside noside, int nargs)
d341 1
a341 1
		    register struct expression *exp, register int *pos,
d382 1
a382 1
			  register struct expression *exp, register int *pos,
d2066 1
a2066 1
evaluate_subexp_for_address (register struct expression *exp, register int *pos,
d2146 2
a2147 2
evaluate_subexp_with_coercion (register struct expression *exp,
			       register int *pos, enum noside noside)
d2183 1
a2183 1
evaluate_subexp_for_sizeof (register struct expression *exp, register int *pos)
@


1.34
log
@2003-09-13  Andrew Cagney  <cagney@@redhat.com>

	* values.c (using_struct_return): Delete "function" and "funcaddr"
	parameters.
	* value.h (using_struct_return): Update declaration.
	* infcmd.c (finish_command_continuation): Update.
	(finish_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* eval.c (evaluate_subexp_standard): Update.
@
text
@d83 2
a84 2
  register CORE_ADDR addr;
  register struct cleanup *old_chain =
d99 2
a100 2
  register CORE_ADDR addr;
  register struct cleanup *old_chain =
d114 2
a115 2
  register LONGEST retval;
  register struct cleanup *old_chain =
d128 1
a128 1
  register struct cleanup *old_chain =
d145 1
a145 1
  register struct cleanup *old_chain =
d387 1
a387 1
  register int pc, pc2 = 0, oldpos;
d2070 1
a2070 1
  register int pc;
d2149 2
a2150 2
  register enum exp_opcode op;
  register int pc;
d2186 1
a2186 1
  register int pc;
@


1.33
log
@
Reverting until I learn how to conform..
@
text
@d858 1
a858 1
	    struct_return = using_struct_return (method, funaddr, value_type, using_gcc);
d862 1
a862 1
	    struct_return = using_struct_return (NULL, addr, check_typedef (expect_type), using_gcc);
@


1.32
log
@


Change array element access to something similar to way C works.
The old method would drag in the entire array, then look for the
single element.  This method just gets the right element out instead.
Saves memory, and saves a crash for array with (*) as one of the
dimensions when it would previously have allocated (unsigned int) -1 bytes.
@
text
@d1669 4
d1681 1
a1681 9

	f77_get_dynamic_lowerbound (tmp_type, &lower);

	/* Construct a value node with the value of the offset */
	/* lower will get subtracted off in value_subscript, hence add it here */

	arg2 = value_from_longest (builtin_type_f_integer, offset_item + lower);

	return value_subscript(arg1, arg2);
@


1.31
log
@2003-07-07  Andrew Cagney  <cagney@@redhat.com>

	* expprint.c: Include "user-regs.h" instead of "frame.h".
	(print_subexp): Use user_reg_map_regnum_to_name, instead of
	frame_map_regnum_to_name.
	* frame.c: Include "user-regs.h" instead of "builtin-regs.h".
	(frame_map_name_to_regnum): Simplify, call
	user_reg_map_name_to_regnum.
	(frame_map_regnum_to_name): Simplify, call
	user_reg_map_regnum_to_name.
	(frame_register_unwind): Update.
	* std-regs.c: Include "user-regs.h" instead of "builtin-regs.h".
	(_initialize_frame_reg): Call user_reg_add_builtin.
	* findvar.c: Include "user-regs.h" instead of "builtin-regs.h".
	(value_of_register): Use value_of_user_reg.
	* eval.c (evaluate_subexp_standard): Update.
	* parse.c (write_dollar_variable): Update.
	* d10v-tdep.c (d10v_print_registers_info): Update.
	* infcmd.c (registers_info): Update.
	* Makefile.in (SFILES): Delete "builtin-regs.c", add "user-regs.c".
	(builtin_regs_h): Delete macro.
	(user_regs_h): Define.
	(COMMON_OBS): Delete "builtin-regs.o", add "user-regs.o".
	(builtin-regs.o): Delete target.
	(user-regs.o): Specify dependencies.
	(expprint.o): Update dependencies.
	(findvar.o): Update dependencies.
	(frame.o): Update dependencies.
	(std-regs.o): Update dependencies.
@
text
@a1668 4
	/* Construct a value node with the value of the offset */

	arg2 = value_from_longest (builtin_type_f_integer, offset_item);

d1677 9
a1685 1
	return value_ind (value_add (value_coerce_array (arg1), arg2));
@


1.30
log
@* eval.c (evaluate_subexp_standard): Handle ObjC ops.
* infcall.c (find_function_addr): Make non-static.
* infcall.h (find_function_addr): Declare.
* Makefile.in (eval.o): Update dependencies.
@
text
@d457 1
a457 1
		 frame_map_regnum_to_name (regno));
@


1.30.8.1
log
@Snap const char * mess.
@
text
@d80 1
a80 1
parse_and_eval_address (const char *exp)
d96 1
a96 1
parse_and_eval_address_1 (const char **expptr)
d111 1
a111 1
parse_and_eval_long (const char *exp)
d124 1
a124 1
parse_and_eval (const char *exp)
d141 1
a141 1
parse_to_comma_and_eval (const char **expp)
@


1.29
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d36 2
d477 9
d682 269
d2032 4
@


1.28
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (get_current_frame): Check target_has_registers before
	checking target_has_stack.
	* eval.c (evaluate_subexp_standard): Use get_selected_frame,
	instead of deprecated_selected_frame.
	* findvar.c (value_of_register): Pass "frame", not
	deprecated_selected_frame, to value_of_builtin_reg.
@
text
@d35 1
@


1.28.12.1
log
@Merge from mainline.
@
text
@a34 3
#include "infcall.h"
#include "objc-lang.h"
#include "block.h"
a473 9
    case OP_OBJC_NSSTRING:		/* Objective C Foundation Class NSString constant.  */
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      if (noside == EVAL_SKIP)
	{
	  goto nosideret;
	}
      return (struct value *) value_nsstring (&exp->elts[pc + 2].string, tem + 1);

a669 269
    case OP_OBJC_SELECTOR:
      {				/* Objective C @@selector operator.  */
	char *sel = &exp->elts[pc + 2].string;
	int len = longest_to_int (exp->elts[pc + 1].longconst);

	(*pos) += 3 + BYTES_TO_EXP_ELEM (len + 1);
	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (sel[len] != 0)
	  sel[len] = 0;		/* Make sure it's terminated.  */
	return value_from_longest (lookup_pointer_type (builtin_type_void),
				   lookup_child_selector (sel));
      }

    case OP_OBJC_MSGCALL:
      {				/* Objective C message (method) call.  */

	static unsigned long responds_selector = 0;
	static unsigned long method_selector = 0;

	unsigned long selector = 0;

	int using_gcc = 0;
	int struct_return = 0;
	int sub_no_side = 0;

	static struct value *msg_send = NULL;
	static struct value *msg_send_stret = NULL;
	static int gnu_runtime = 0;

	struct value *target = NULL;
	struct value *method = NULL;
	struct value *called_method = NULL; 

	struct type *selector_type = NULL;

	struct value *ret = NULL;
	CORE_ADDR addr = 0;

	selector = exp->elts[pc + 1].longconst;
	nargs = exp->elts[pc + 2].longconst;
	argvec = (struct value **) alloca (sizeof (struct value *) 
					   * (nargs + 5));

	(*pos) += 3;

	selector_type = lookup_pointer_type (builtin_type_void);
	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  sub_no_side = EVAL_NORMAL;
	else
	  sub_no_side = noside;

	target = evaluate_subexp (selector_type, exp, pos, sub_no_side);

	if (value_as_long (target) == 0)
 	  return value_from_longest (builtin_type_long, 0);
	
	if (lookup_minimal_symbol ("objc_msg_lookup", 0, 0))
	  gnu_runtime = 1;
	
	/* Find the method dispatch (Apple runtime) or method lookup
	   (GNU runtime) function for Objective-C.  These will be used
	   to lookup the symbol information for the method.  If we
	   can't find any symbol information, then we'll use these to
	   call the method, otherwise we can call the method
	   directly. The msg_send_stret function is used in the special
	   case of a method that returns a structure (Apple runtime 
	   only).  */
	if (gnu_runtime)
	  {
	    msg_send = find_function_in_inferior ("objc_msg_lookup");
	    msg_send_stret = find_function_in_inferior ("objc_msg_lookup");
	  }
	else
	  {
	    msg_send = find_function_in_inferior ("objc_msgSend");
	    /* Special dispatcher for methods returning structs */
	    msg_send_stret = find_function_in_inferior ("objc_msgSend_stret");
	  }

	/* Verify the target object responds to this method. The
	   standard top-level 'Object' class uses a different name for
	   the verification method than the non-standard, but more
	   often used, 'NSObject' class. Make sure we check for both. */

	responds_selector = lookup_child_selector ("respondsToSelector:");
	if (responds_selector == 0)
	  responds_selector = lookup_child_selector ("respondsTo:");
	
	if (responds_selector == 0)
	  error ("no 'respondsTo:' or 'respondsToSelector:' method");
	
	method_selector = lookup_child_selector ("methodForSelector:");
	if (method_selector == 0)
	  method_selector = lookup_child_selector ("methodFor:");
	
	if (method_selector == 0)
	  error ("no 'methodFor:' or 'methodForSelector:' method");

	/* Call the verification method, to make sure that the target
	 class implements the desired method. */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, responds_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    /* Function objc_msg_lookup returns a pointer.  */
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }
	if (value_as_long (ret) == 0)
	  error ("Target does not respond to this message selector.");

	/* Call "methodForSelector:" method, to get the address of a
	   function method that implements this selector for this
	   class.  If we can find a symbol at that address, then we
	   know the return type, parameter types etc.  (that's a good
	   thing). */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, method_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }

	/* ret should now be the selector.  */

	addr = value_as_long (ret);
	if (addr)
	  {
	    struct symbol *sym = NULL;
	    /* Is it a high_level symbol?  */

	    sym = find_pc_function (addr);
	    if (sym != NULL) 
	      method = value_of_variable (sym, 0);
	  }

	/* If we found a method with symbol information, check to see
           if it returns a struct.  Otherwise assume it doesn't.  */

	if (method)
	  {
	    struct block *b;
	    CORE_ADDR funaddr;
	    struct type *value_type;

	    funaddr = find_function_addr (method, &value_type);

	    b = block_for_pc (funaddr);

	    /* If compiled without -g, assume GCC 2.  */
	    using_gcc = (b == NULL ? 2 : BLOCK_GCC_COMPILED (b));

	    CHECK_TYPEDEF (value_type);
	  
	    if ((value_type == NULL) 
		|| (TYPE_CODE(value_type) == TYPE_CODE_ERROR))
	      {
		if (expect_type != NULL)
		  value_type = expect_type;
	      }

	    struct_return = using_struct_return (method, funaddr, value_type, using_gcc);
	  }
	else if (expect_type != NULL)
	  {
	    struct_return = using_struct_return (NULL, addr, check_typedef (expect_type), using_gcc);
	  }
	
	/* Found a function symbol.  Now we will substitute its
	   value in place of the message dispatcher (obj_msgSend),
	   so that we call the method directly instead of thru
	   the dispatcher.  The main reason for doing this is that
	   we can now evaluate the return value and parameter values
	   according to their known data types, in case we need to
	   do things like promotion, dereferencing, special handling
	   of structs and doubles, etc.
	  
	   We want to use the type signature of 'method', but still
	   jump to objc_msgSend() or objc_msgSend_stret() to better
	   mimic the behavior of the runtime.  */
	
	if (method)
	  {
	    if (TYPE_CODE (VALUE_TYPE (method)) != TYPE_CODE_FUNC)
	      error ("method address has symbol information with non-function type; skipping");
	    if (struct_return)
	      VALUE_ADDRESS (method) = value_as_address (msg_send_stret);
	    else
	      VALUE_ADDRESS (method) = value_as_address (msg_send);
	    called_method = method;
	  }
	else
	  {
	    if (struct_return)
	      called_method = msg_send_stret;
	    else
	      called_method = msg_send;
	  }

	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  {
	    /* If the return type doesn't look like a function type,
	       call an error.  This can happen if somebody tries to
	       turn a variable into a function call. This is here
	       because people often want to call, eg, strcmp, which
	       gdb doesn't know is a function.  If gdb isn't asked for
	       it's opinion (ie. through "whatis"), it won't offer
	       it. */

	    struct type *type = VALUE_TYPE (called_method);
	    if (type && TYPE_CODE (type) == TYPE_CODE_PTR)
	      type = TYPE_TARGET_TYPE (type);
	    type = TYPE_TARGET_TYPE (type);

	    if (type)
	    {
	      if ((TYPE_CODE (type) == TYPE_CODE_ERROR) && expect_type)
		return allocate_value (expect_type);
	      else
		return allocate_value (type);
	    }
	    else
	      error ("Expression of type other than \"method returning ...\" used as a method");
	  }

	/* Now depending on whether we found a symbol for the method,
	   we will either call the runtime dispatcher or the method
	   directly.  */

	argvec[0] = called_method;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, selector);
	/* User-supplied arguments.  */
	for (tem = 0; tem < nargs; tem++)
	  argvec[tem + 3] = evaluate_subexp_with_coercion (exp, pos, noside);
	argvec[tem + 3] = 0;

	if (gnu_runtime && (method != NULL))
	  {
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	    /* Function objc_msg_lookup returns a pointer.  */
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	  }
	else
	  ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);

	return ret;
      }
      break;

a1750 4

    case OP_OBJC_SELF:
      (*pos) += 1;
      return value_of_local ("self", 1);
@


1.27
log
@2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* ax-gdb.c, c-valprint.c, charset.c, corefile.c: Update copyright.
	* demangle.c, disasm.c, dwarf2cfi.c, dwarfread.c: Update copyright.
	* elfread.c, eval.c, expprint.c, expression.h: Update copyright.
	* f-typeprint.c, findvar.c, gcore.c, gdb_mbuild.sh: Update copyright.
	* gdbtypes.h, gnu-v2-abi.c, inferior.h, inftarg.c: Update copyright.
	* language.c, language.h, m32r-tdep.c: Update copyright.
	* mn10200-tdep.c, scm-lang.c, scm-lang.h: Update copyright.
	* somsolib.c, somsolib.h, symfile.c, symtab.h: Update copyright.
	* thread-db.c, typeprint.c, utils.c, valarith.c: Update copyright.
	* values.c, win32-nat.c, x86-64-linux-nat.c: Update copyright.
	* x86-64-linux-tdep.c, z8k-tdep.c: Update copyright.
	* cli/cli-decode.h, config/h8500/tm-h8500.h: Update copyright.

Index: mi/ChangeLog
2003-01-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-cmd-env.c: Update copyright.
@
text
@d450 1
a450 1
	struct value *val = value_of_register (regno, deprecated_selected_frame);
@


1.27.6.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d450 1
a450 1
	struct value *val = value_of_register (regno, get_selected_frame ());
@


1.26
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* valarith.c (value_binop): Delete obsolete code and comments.
	* configure.host: Ditto.
	* buildsym.h (make_blockvector): Ditto.
	* buildsym.c (make_blockvector): Ditto.
	* defs.h (enum language): Ditto.
	(chill_demangle): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* dwarfread.c (CHILL_PRODUCER): Ditto.
	(set_cu_language): Ditto.
	(handle_producer): Ditto.
	* expprint.c (print_subexp): Ditto.
	* gdbtypes.c (chill_varying_type): Ditto.
	* gdbtypes.h (builtin_type_chill_bool): Ditto.
	(builtin_type_chill_char, builtin_type_chill_long): Ditto.
	(builtin_type_chill_ulong, builtin_type_chill_real): Ditto.
	(chill_varying_type): Ditto.
	* language.h (_LANG_chill): Ditto.
	* language.c (binop_result_type, integral_type): Ditto.
	(character_type, string_type, structured_type): Ditto.
	(lang_bool_type, binop_type_check): Ditto.
	* stabsread.h (os9k_stabs): Ditto.
	* stabsread.c (os9k_type_vector, dbx_lookup_type): Ditto.
	(define_symbol, read_type, read_struct_fields): Ditto.
	(read_array_type, read_enum_type, read_huge_number): Ditto.
	(read_range_type, start_stabs): Ditto.
	* symfile.c (init_filename_language_table): Ditto.
	(add_psymbol_with_dem_name_to_list): Ditto.
	* symtab.c (symbol_init_language_specific): Ditto.
	(symbol_init_demangled_name, symbol_demangled_name): Ditto.
	* symtab.h (struct general_symbol_info): Ditto.
	(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
	* typeprint.c (typedef_print): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* valops.c (value_cast, search_struct_field, value_slice): Delete
	obsolete code.
	(varying_to_slice): Delete function.
	* value.h (COERCE_VARYING_ARRAY): Delete obsolete macro contents.
	(varying_to_slice): Delete declaration.
	* MAINTAINERS: Update.
@
text
@d2 4
a5 3
   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995,
   1996, 1997, 1998, 1999, 2000, 2001, 2002
   Free Software Foundation, Inc.
@


1.25
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d189 1
a189 1
/* This function evaluates tuples (in (OBSOLETE) Chill) or
d329 5
a333 4
   (OBSOLETE) Chill.  The target is ARRAY (which has bounds LOW_BOUND
   to HIGH_BOUND); the element value is ELEMENT; EXP, POS and NOSIDE
   are as usual.  Evaluates index expresions and sets the specified
   element(s) of ARRAY to ELEMENT.  Returns last index value.  */
@


1.24
log
@2002-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.c: Include "gdb_string.h" and "builtin-regs.h".
	(frame_map_regnum_to_name): New function.
	(frame_map_name_to_regnum): New function.
	* frame.h (frame_map_name_to_regnum): Declare.
	(frame_map_regnum_to_name): Declare.
	* builtin-regs.c (builtin_reg_map_regnum_to_name): New function.
	* builtin-regs.h (builtin_reg_map_regnum_to_name): Declare.
	* parse.c: Do not include "builtin-regs.h".
	(target_map_name_to_register): Delete function.
	(write_dollar_variable): Use frame_map_name_to_regnum.
	* parser-defs.h (target_map_name_to_register): Delete declaration.
	* expprint.c: Include "frame.h".
	(print_subexp): Use frame_map_regnum_to_name.
	* eval.c (evaluate_subexp_standard): Use frame_map_regnum_to_name.
	* infcmd.c (registers_info): Use frame_map_name_to_regnum.

2002-09-25  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/pc-fp.exp, gdb.base/pc-fp.c: New test.
@
text
@d448 1
a448 1
	struct value *val = value_of_register (regno, selected_frame);
@


1.24.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
a33 4
#include "infcall.h"
#include "objc-lang.h"
#include "block.h"
#include "parser-defs.h"
d66 2
a67 2
evaluate_subexp (struct type *expect_type, struct expression *exp,
		 int *pos, enum noside noside)
d69 1
a69 2
  return (*exp->language_defn->la_exp_desc->evaluate_exp) 
    (expect_type, exp, pos, noside);
d79 2
a80 2
  CORE_ADDR addr;
  struct cleanup *old_chain =
d95 2
a96 2
  CORE_ADDR addr;
  struct cleanup *old_chain =
d110 2
a111 2
  LONGEST retval;
  struct cleanup *old_chain =
d124 1
a124 1
  struct cleanup *old_chain =
d141 1
a141 1
  struct cleanup *old_chain =
d175 1
a175 1
get_label (struct expression *exp, int *pos)
d189 1
a189 1
/* This function evaluates tuples (in (the deleted) Chill) or
d194 2
a195 2
		       struct expression *exp,
		       int *pos, enum noside noside, int nargs)
d224 1
a224 1
		  if (field_name != NULL && DEPRECATED_STREQ (field_name, label))
d252 1
a252 1
				  if (DEPRECATED_STREQ (TYPE_FIELD_NAME (substruct_type,
d329 4
a332 5
   (the deleted) Chill.  The target is ARRAY (which has bounds
   LOW_BOUND to HIGH_BOUND); the element value is ELEMENT; EXP, POS
   and NOSIDE are as usual.  Evaluates index expresions and sets the
   specified element(s) of ARRAY to ELEMENT.  Returns last index
   value.  */
d336 1
a336 1
		    struct expression *exp, int *pos,
d377 1
a377 1
			  struct expression *exp, int *pos,
d382 1
a382 1
  int pc, pc2 = 0, oldpos;
d404 5
a408 3
      arg1 = value_aggregate_elt (exp->elts[pc + 1].type,
				  &exp->elts[pc + 3].string,
				  noside);
d448 1
a448 1
	struct value *val = value_of_register (regno, get_selected_frame ());
d452 1
a452 1
		 frame_map_regnum_to_name (get_selected_frame (), regno));
a471 9
    case OP_OBJC_NSSTRING:		/* Objective C Foundation Class NSString constant.  */
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      if (noside == EVAL_SKIP)
	{
	  goto nosideret;
	}
      return (struct value *) value_nsstring (&exp->elts[pc + 2].string, tem + 1);

a667 269
    case OP_OBJC_SELECTOR:
      {				/* Objective C @@selector operator.  */
	char *sel = &exp->elts[pc + 2].string;
	int len = longest_to_int (exp->elts[pc + 1].longconst);

	(*pos) += 3 + BYTES_TO_EXP_ELEM (len + 1);
	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (sel[len] != 0)
	  sel[len] = 0;		/* Make sure it's terminated.  */
	return value_from_longest (lookup_pointer_type (builtin_type_void),
				   lookup_child_selector (sel));
      }

    case OP_OBJC_MSGCALL:
      {				/* Objective C message (method) call.  */

	static unsigned long responds_selector = 0;
	static unsigned long method_selector = 0;

	unsigned long selector = 0;

	int using_gcc = 0;
	int struct_return = 0;
	int sub_no_side = 0;

	static struct value *msg_send = NULL;
	static struct value *msg_send_stret = NULL;
	static int gnu_runtime = 0;

	struct value *target = NULL;
	struct value *method = NULL;
	struct value *called_method = NULL; 

	struct type *selector_type = NULL;

	struct value *ret = NULL;
	CORE_ADDR addr = 0;

	selector = exp->elts[pc + 1].longconst;
	nargs = exp->elts[pc + 2].longconst;
	argvec = (struct value **) alloca (sizeof (struct value *) 
					   * (nargs + 5));

	(*pos) += 3;

	selector_type = lookup_pointer_type (builtin_type_void);
	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  sub_no_side = EVAL_NORMAL;
	else
	  sub_no_side = noside;

	target = evaluate_subexp (selector_type, exp, pos, sub_no_side);

	if (value_as_long (target) == 0)
 	  return value_from_longest (builtin_type_long, 0);
	
	if (lookup_minimal_symbol ("objc_msg_lookup", 0, 0))
	  gnu_runtime = 1;
	
	/* Find the method dispatch (Apple runtime) or method lookup
	   (GNU runtime) function for Objective-C.  These will be used
	   to lookup the symbol information for the method.  If we
	   can't find any symbol information, then we'll use these to
	   call the method, otherwise we can call the method
	   directly. The msg_send_stret function is used in the special
	   case of a method that returns a structure (Apple runtime 
	   only).  */
	if (gnu_runtime)
	  {
	    msg_send = find_function_in_inferior ("objc_msg_lookup");
	    msg_send_stret = find_function_in_inferior ("objc_msg_lookup");
	  }
	else
	  {
	    msg_send = find_function_in_inferior ("objc_msgSend");
	    /* Special dispatcher for methods returning structs */
	    msg_send_stret = find_function_in_inferior ("objc_msgSend_stret");
	  }

	/* Verify the target object responds to this method. The
	   standard top-level 'Object' class uses a different name for
	   the verification method than the non-standard, but more
	   often used, 'NSObject' class. Make sure we check for both. */

	responds_selector = lookup_child_selector ("respondsToSelector:");
	if (responds_selector == 0)
	  responds_selector = lookup_child_selector ("respondsTo:");
	
	if (responds_selector == 0)
	  error ("no 'respondsTo:' or 'respondsToSelector:' method");
	
	method_selector = lookup_child_selector ("methodForSelector:");
	if (method_selector == 0)
	  method_selector = lookup_child_selector ("methodFor:");
	
	if (method_selector == 0)
	  error ("no 'methodFor:' or 'methodForSelector:' method");

	/* Call the verification method, to make sure that the target
	 class implements the desired method. */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, responds_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    /* Function objc_msg_lookup returns a pointer.  */
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }
	if (value_as_long (ret) == 0)
	  error ("Target does not respond to this message selector.");

	/* Call "methodForSelector:" method, to get the address of a
	   function method that implements this selector for this
	   class.  If we can find a symbol at that address, then we
	   know the return type, parameter types etc.  (that's a good
	   thing). */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, method_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }

	/* ret should now be the selector.  */

	addr = value_as_long (ret);
	if (addr)
	  {
	    struct symbol *sym = NULL;
	    /* Is it a high_level symbol?  */

	    sym = find_pc_function (addr);
	    if (sym != NULL) 
	      method = value_of_variable (sym, 0);
	  }

	/* If we found a method with symbol information, check to see
           if it returns a struct.  Otherwise assume it doesn't.  */

	if (method)
	  {
	    struct block *b;
	    CORE_ADDR funaddr;
	    struct type *value_type;

	    funaddr = find_function_addr (method, &value_type);

	    b = block_for_pc (funaddr);

	    /* If compiled without -g, assume GCC 2.  */
	    using_gcc = (b == NULL ? 2 : BLOCK_GCC_COMPILED (b));

	    CHECK_TYPEDEF (value_type);
	  
	    if ((value_type == NULL) 
		|| (TYPE_CODE(value_type) == TYPE_CODE_ERROR))
	      {
		if (expect_type != NULL)
		  value_type = expect_type;
	      }

	    struct_return = using_struct_return (value_type, using_gcc);
	  }
	else if (expect_type != NULL)
	  {
	    struct_return = using_struct_return (check_typedef (expect_type), using_gcc);
	  }
	
	/* Found a function symbol.  Now we will substitute its
	   value in place of the message dispatcher (obj_msgSend),
	   so that we call the method directly instead of thru
	   the dispatcher.  The main reason for doing this is that
	   we can now evaluate the return value and parameter values
	   according to their known data types, in case we need to
	   do things like promotion, dereferencing, special handling
	   of structs and doubles, etc.
	  
	   We want to use the type signature of 'method', but still
	   jump to objc_msgSend() or objc_msgSend_stret() to better
	   mimic the behavior of the runtime.  */
	
	if (method)
	  {
	    if (TYPE_CODE (VALUE_TYPE (method)) != TYPE_CODE_FUNC)
	      error ("method address has symbol information with non-function type; skipping");
	    if (struct_return)
	      VALUE_ADDRESS (method) = value_as_address (msg_send_stret);
	    else
	      VALUE_ADDRESS (method) = value_as_address (msg_send);
	    called_method = method;
	  }
	else
	  {
	    if (struct_return)
	      called_method = msg_send_stret;
	    else
	      called_method = msg_send;
	  }

	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  {
	    /* If the return type doesn't look like a function type,
	       call an error.  This can happen if somebody tries to
	       turn a variable into a function call. This is here
	       because people often want to call, eg, strcmp, which
	       gdb doesn't know is a function.  If gdb isn't asked for
	       it's opinion (ie. through "whatis"), it won't offer
	       it. */

	    struct type *type = VALUE_TYPE (called_method);
	    if (type && TYPE_CODE (type) == TYPE_CODE_PTR)
	      type = TYPE_TARGET_TYPE (type);
	    type = TYPE_TARGET_TYPE (type);

	    if (type)
	    {
	      if ((TYPE_CODE (type) == TYPE_CODE_ERROR) && expect_type)
		return allocate_value (expect_type);
	      else
		return allocate_value (type);
	    }
	    else
	      error ("Expression of type other than \"method returning ...\" used as a method");
	  }

	/* Now depending on whether we found a symbol for the method,
	   we will either call the runtime dispatcher or the method
	   directly.  */

	argvec[0] = called_method;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, selector);
	/* User-supplied arguments.  */
	for (tem = 0; tem < nargs; tem++)
	  argvec[tem + 3] = evaluate_subexp_with_coercion (exp, pos, noside);
	argvec[tem + 3] = 0;

	if (gnu_runtime && (method != NULL))
	  {
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	    /* Function objc_msg_lookup returns a pointer.  */
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	  }
	else
	  ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);

	return ret;
      }
      break;

a1749 4
    case OP_OBJC_SELF:
      (*pos) += 1;
      return value_of_local ("self", 1);

d1779 1
a1779 1
evaluate_subexp_for_address (struct expression *exp, int *pos,
d1783 1
a1783 1
  int pc;
d1859 2
a1860 2
evaluate_subexp_with_coercion (struct expression *exp,
			       int *pos, enum noside noside)
d1862 2
a1863 2
  enum exp_opcode op;
  int pc;
d1896 1
a1896 1
evaluate_subexp_for_sizeof (struct expression *exp, int *pos)
d1899 1
a1899 1
  int pc;
@


1.23
log
@2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* NEWS: Menion that CHILL has been made obsolete.

* gdbtypes.c (chill_varying_type): Make chill references obsolete.
* gdbserver/Makefile.in: Ditto.
* stabsread.c (read_range_type): Ditto.
* gdbtypes.h: Ditto.
* language.c (binop_type_check): Ditto.
(binop_result_type): Ditto.
(integral_type): Ditto.
(character_type): Ditto.
(string_type): Ditto.
(boolean_type): Ditto.
(structured_type): Ditto.
(lang_bool_type): Ditto.
(binop_type_check): Ditto.
* language.h (_LANG_chill): Ditto.
* dwarfread.c (set_cu_language): Ditto.
* dwarfread.c (CHILL_PRODUCER): Ditto.
* dwarfread.c (handle_producer): Ditto.
* expression.h (enum exp_opcode): Ditto.
* eval.c: Ditto for comments.
* typeprint.c (typedef_print) [_LANG_chill]: Ditto.
* expprint.c (print_subexp): Ditto.
(print_subexp): Ditto.
* valops.c (value_cast): Ditto.
(search_struct_field): Ditto.
* value.h (COERCE_VARYING_ARRAY): Ditto.
* symfile.c (init_filename_language_table): Ditto.
(add_psymbol_with_dem_name_to_list): Ditto.
* valarith.c (value_binop): Ditto.
(value_neg): Ditto.
* valops.c (value_slice): Ditto.
* symtab.h (union language_specific): Ditto.
(SYMBOL_INIT_LANGUAGE_SPECIFIC): Ditto.
(SYMBOL_DEMANGLED_NAME): Ditto.
(SYMBOL_CHILL_DEMANGLED_NAME): Ditto.
* defs.h (enum language): Ditto.
* symtab.c (got_symtab): Ditto.
* utils.c (fprintf_symbol_filtered): Ditto.

* ch-typeprint.c: Make file obsolete.
* ch-valprint.c: Make file obsolete.
* ch-lang.h: Make file obsolete.
* ch-exp.c: Make file obsolete.
* ch-lang.c: Make file obsolete.

* Makefile.in (FLAGS_TO_PASS): Do not pass CHILL or CHILLFLAGS or
CHILL_LIB.
(TARGET_FLAGS_TO_PASS): Ditto.
(CHILLFLAGS): Obsolete.
(CHILL): Obsolete.
(CHILL_FOR_TARGET): Obsolete.
(CHILL_LIB): Obsolete.
(SFILES): Remove ch-exp.c, ch-lang.c, ch-typeprint.c and
ch-valprint.c.
(HFILES_NO_SRCDIR): Remove ch-lang.h.
(COMMON_OBS): Remove ch-valprint.o, ch-typeprint.o, ch-exp.o and
ch-lang.o.
(ch-exp.o, ch-lang.o, ch-typeprint.o, ch-valprint.o): Delete
targets.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* stabs.texinfo, gdb.texinfo, gdbint.texinfo: Obsolete references
to CHILL.

2002-08-01  Andrew Cagney  <cagney@@redhat.com>

* Makefile.in (TARGET_FLAGS_TO_PASS): Remove CHILLFLAGS, CHILL,
CHILL_FOR_TARGET and CHILL_LIB.
* configure.in (configdirs): Remove gdb.chill.
* configure: Regenerate.
* lib/gdb.exp: Obsolete references to chill.
* gdb.fortran/types.exp: Ditto.
* gdb.fortran/exprs.exp: Ditto.
@
text
@d451 2
a452 1
	  error ("Value of register %s not available.", REGISTER_NAME (regno));
@


1.23.8.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d451 1
a451 2
	  error ("Value of register %s not available.",
		 frame_map_regnum_to_name (regno));
@


1.23.8.2
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (examine_compound_token): Rewrite as switch
	statement, and add FIXME comment.
	* frame.h: Make arg of block_innermost_frame const.
	* blockframe.c (block_innermost_frame): Make arg const.
	* block.h: Make args to block_function, contained_in const.
	* block.c (block_function): Make arg const.
	(contained_in): Ditto.
	* value.h: Make arg of symbol_read_needs_frame const.
	* findvar.c (symbol_read_needs_frame): Make arg const.
	* symtab.h: Make first arg of symbol_demangled_name const.
	* symtab.c (symbol_demangled_name): Make arg const.
	* value.h: Make first arg of read_var_value const.
	* findvar.c (read_var_value): Make first arg const.
	* Makefile.in (valops.o): Depend on cp_support_h.
	* valops.c: #include "cp-support.h"
	* symtab.h: Add FIXME about name of namespace_enum.
	Add opaque declaration of struct using_direct_node.
	* symtab.c (lookup_symbol_namespace): Make extern; rename args.
	* symtab.h: Declare lookup_symbol_namespace.
	* valops.c (value_struct_elt_for_reference): Make 'name' a const
	char *.
	(value_namespace_elt): New function.
	* expprint.c (print_subexp): Ditto.
	(dump_subexp): Ditto.
	* parse.c (length_of_subexp): Ditto.
	(prefixify_subexp): Ditto.
	* expression.h: Update comment to reflect the block in OP_SCOPE.
	* c-exp.y: Set block in OP_SCOPE expression.
	* jv-exp.y (push_qualified_expression_name): Put a NULL block in
	OP_SCOPE expression.
	* objc-exp.y: Ditto.
	* p-exp.y: Ditto.
	* eval.c (evaluate_subexp_standard): Handle OP_SCOPE via
	value_aggregate_elt.
	* value.h: Add declaration for value_aggregate_elt; delete
	declaration for value_struct_elt_for_reference.
	* valops.c (value_aggregate_elt): New function.
	(value_struct_elt_for_reference): Make static.  Don't check type
	of curtype.
	* c-exp.y: Accept TYPE_CODE_NAMESPACE in qualified_name.
	* cp-support.c (cp_check_namespace_symbol): Set TYPE_NAME (type).

2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change a couple of tests to not use
	single quotes.
@
text
@d402 7
a408 5
      tem = longest_to_int (exp->elts[pc + 3].longconst);
      (*pos) += 5 + BYTES_TO_EXP_ELEM (tem + 1);
      arg1 = value_aggregate_elt (exp->elts[pc + 1].type,
				  exp->elts[pc + 2].block,
				  &exp->elts[pc + 4].string);
d410 1
a410 1
	error ("There is no field named %s", &exp->elts[pc + 4].string);
d1633 2
a1634 2
	      int temm = longest_to_int (exp->elts[pc + 4].longconst);
	      (*pos) += 4 + BYTES_TO_EXP_ELEM (temm + 1);
@


1.23.8.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d446 1
a446 1
	struct value *val = value_of_register (regno, deprecated_selected_frame);
@


1.23.8.4
log
@2003-01-20  David Carlton  <carlton@@math.stanford.edu>

	* p-exp.y: Add block to OP_FUNCALL.
	* objc-exp.y: Add block to OP_FUNCALL.
	* m2-exp.y: Add block to OP_FUNCALL.
	* c-exp.y: Add block to OP_FUNCALL.
	* ada-exp.y: Add block to OP_FUNCALL.
	(write_object_renaming): Ditto.
	* parse.c (length_of_subexp): Split off OP_FUNCALL.
	(prefixify_subexp): Ditto.
	* expprint.c (print_subexp): Change offset for OP_FUNCALL.
	(dump_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Change offset for
	OP_FUNCALL.
	* ada-lang.c (ada_resolve_subexp): Add comment on OP_FUNCALL.
	(replace_operator_with_call): Add block to OP_FUNCALL.
	(ada_evaluate_subexp): Change offset for OP_FUNCALL.
	* expression.h (exp_opcode): Change comments before OP_FUNCALL and
	OP_F77_UNDETERMINED_ARGLIST.

2003-01-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Add comment.
	(lookup_symbol_aux_using): Function name should start line.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_block_symbol): Add comment.

2003-01-13  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Add comment.
	(add_partial_structure): Ditto.
	* symtab.c (lookup_transparent_type): Add comment.
@
text
@d667 1
a667 1
      (*pos) += 3;
@


1.23.8.5
log
@2003-01-24  David Carlton  <carlton@@math.stanford.edu>

	* valops.c (find_oload_champ): New function.
	(find_overload_match): Separate code into find_oload_champ and
	oload_method_static.
	(find_oload_champ): Call oload_method_static.
	(oload_method_static): New function.
	(find_overload_match): Call classify_oload_match.
	(classify_oload_match): New function.
	* value.h: Update declaration of find_overload_match.
	* eval.c (evaluate_subexp_standard): Pass current block to
	find_overload_match.
	* valops.c (find_overload_match): Add CURRENT_BLOCK arg.

2003-01-24  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/overload.exp: Add tests involving overloadNamespace.
	Delete comment about GDB crashing.
	* gdb.c++/overload.cc: Add dummyClass, dummyInstance,
	overloadNamespace, and XXX.
@
text
@a394 1
  const struct block *current_block;
a669 2
      current_block = exp->elts[pc + 2].block;

d837 4
a840 6
	      find_overload_match (arg_types, nargs, tstr,
				   1 /* method */,
				   0 /* strict match */ ,
				   &arg2 /* the object */, NULL,
				   current_block,
				   &valp, NULL, &static_memfuncp);
d892 4
a895 8
	      find_overload_match (arg_types, nargs,
				   NULL /* no need for name */ ,
				   0 /* not method */,
				   0 /* strict match */ ,
				   NULL,
				   exp->elts[save_pos1+2].symbol /* the function */ ,
				   current_block,
				   NULL, &symp, NULL);
@


1.23.8.6
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 3
a4 4

   Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,
   1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software
   Foundation, Inc.
d189 1
a189 1
/* This function evaluates tuples (in (the deleted) Chill) or
d329 4
a332 5
   (the deleted) Chill.  The target is ARRAY (which has bounds
   LOW_BOUND to HIGH_BOUND); the element value is ELEMENT; EXP, POS
   and NOSIDE are as usual.  Evaluates index expresions and sets the
   specified element(s) of ARRAY to ELEMENT.  Returns last index
   value.  */
@


1.23.8.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d449 1
a449 1
	struct value *val = value_of_register (regno, get_selected_frame ());
@


1.23.8.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@a34 3
#include "infcall.h"
#include "objc-lang.h"
#include "block.h"
a472 9
    case OP_OBJC_NSSTRING:		/* Objective C Foundation Class NSString constant.  */
      tem = longest_to_int (exp->elts[pc + 1].longconst);
      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);
      if (noside == EVAL_SKIP)
	{
	  goto nosideret;
	}
      return (struct value *) value_nsstring (&exp->elts[pc + 2].string, tem + 1);

a668 269
    case OP_OBJC_SELECTOR:
      {				/* Objective C @@selector operator.  */
	char *sel = &exp->elts[pc + 2].string;
	int len = longest_to_int (exp->elts[pc + 1].longconst);

	(*pos) += 3 + BYTES_TO_EXP_ELEM (len + 1);
	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (sel[len] != 0)
	  sel[len] = 0;		/* Make sure it's terminated.  */
	return value_from_longest (lookup_pointer_type (builtin_type_void),
				   lookup_child_selector (sel));
      }

    case OP_OBJC_MSGCALL:
      {				/* Objective C message (method) call.  */

	static unsigned long responds_selector = 0;
	static unsigned long method_selector = 0;

	unsigned long selector = 0;

	int using_gcc = 0;
	int struct_return = 0;
	int sub_no_side = 0;

	static struct value *msg_send = NULL;
	static struct value *msg_send_stret = NULL;
	static int gnu_runtime = 0;

	struct value *target = NULL;
	struct value *method = NULL;
	struct value *called_method = NULL; 

	struct type *selector_type = NULL;

	struct value *ret = NULL;
	CORE_ADDR addr = 0;

	selector = exp->elts[pc + 1].longconst;
	nargs = exp->elts[pc + 2].longconst;
	argvec = (struct value **) alloca (sizeof (struct value *) 
					   * (nargs + 5));

	(*pos) += 3;

	selector_type = lookup_pointer_type (builtin_type_void);
	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  sub_no_side = EVAL_NORMAL;
	else
	  sub_no_side = noside;

	target = evaluate_subexp (selector_type, exp, pos, sub_no_side);

	if (value_as_long (target) == 0)
 	  return value_from_longest (builtin_type_long, 0);
	
	if (lookup_minimal_symbol ("objc_msg_lookup", 0, 0))
	  gnu_runtime = 1;
	
	/* Find the method dispatch (Apple runtime) or method lookup
	   (GNU runtime) function for Objective-C.  These will be used
	   to lookup the symbol information for the method.  If we
	   can't find any symbol information, then we'll use these to
	   call the method, otherwise we can call the method
	   directly. The msg_send_stret function is used in the special
	   case of a method that returns a structure (Apple runtime 
	   only).  */
	if (gnu_runtime)
	  {
	    msg_send = find_function_in_inferior ("objc_msg_lookup");
	    msg_send_stret = find_function_in_inferior ("objc_msg_lookup");
	  }
	else
	  {
	    msg_send = find_function_in_inferior ("objc_msgSend");
	    /* Special dispatcher for methods returning structs */
	    msg_send_stret = find_function_in_inferior ("objc_msgSend_stret");
	  }

	/* Verify the target object responds to this method. The
	   standard top-level 'Object' class uses a different name for
	   the verification method than the non-standard, but more
	   often used, 'NSObject' class. Make sure we check for both. */

	responds_selector = lookup_child_selector ("respondsToSelector:");
	if (responds_selector == 0)
	  responds_selector = lookup_child_selector ("respondsTo:");
	
	if (responds_selector == 0)
	  error ("no 'respondsTo:' or 'respondsToSelector:' method");
	
	method_selector = lookup_child_selector ("methodForSelector:");
	if (method_selector == 0)
	  method_selector = lookup_child_selector ("methodFor:");
	
	if (method_selector == 0)
	  error ("no 'methodFor:' or 'methodForSelector:' method");

	/* Call the verification method, to make sure that the target
	 class implements the desired method. */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, responds_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    /* Function objc_msg_lookup returns a pointer.  */
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }
	if (value_as_long (ret) == 0)
	  error ("Target does not respond to this message selector.");

	/* Call "methodForSelector:" method, to get the address of a
	   function method that implements this selector for this
	   class.  If we can find a symbol at that address, then we
	   know the return type, parameter types etc.  (that's a good
	   thing). */

	argvec[0] = msg_send;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, method_selector);
	argvec[3] = value_from_longest (builtin_type_long, selector);
	argvec[4] = 0;

	ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	if (gnu_runtime)
	  {
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], 3, argvec + 1);
	  }

	/* ret should now be the selector.  */

	addr = value_as_long (ret);
	if (addr)
	  {
	    struct symbol *sym = NULL;
	    /* Is it a high_level symbol?  */

	    sym = find_pc_function (addr);
	    if (sym != NULL) 
	      method = value_of_variable (sym, 0);
	  }

	/* If we found a method with symbol information, check to see
           if it returns a struct.  Otherwise assume it doesn't.  */

	if (method)
	  {
	    struct block *b;
	    CORE_ADDR funaddr;
	    struct type *value_type;

	    funaddr = find_function_addr (method, &value_type);

	    b = block_for_pc (funaddr);

	    /* If compiled without -g, assume GCC 2.  */
	    using_gcc = (b == NULL ? 2 : BLOCK_GCC_COMPILED (b));

	    CHECK_TYPEDEF (value_type);
	  
	    if ((value_type == NULL) 
		|| (TYPE_CODE(value_type) == TYPE_CODE_ERROR))
	      {
		if (expect_type != NULL)
		  value_type = expect_type;
	      }

	    struct_return = using_struct_return (method, funaddr, value_type, using_gcc);
	  }
	else if (expect_type != NULL)
	  {
	    struct_return = using_struct_return (NULL, addr, check_typedef (expect_type), using_gcc);
	  }
	
	/* Found a function symbol.  Now we will substitute its
	   value in place of the message dispatcher (obj_msgSend),
	   so that we call the method directly instead of thru
	   the dispatcher.  The main reason for doing this is that
	   we can now evaluate the return value and parameter values
	   according to their known data types, in case we need to
	   do things like promotion, dereferencing, special handling
	   of structs and doubles, etc.
	  
	   We want to use the type signature of 'method', but still
	   jump to objc_msgSend() or objc_msgSend_stret() to better
	   mimic the behavior of the runtime.  */
	
	if (method)
	  {
	    if (TYPE_CODE (VALUE_TYPE (method)) != TYPE_CODE_FUNC)
	      error ("method address has symbol information with non-function type; skipping");
	    if (struct_return)
	      VALUE_ADDRESS (method) = value_as_address (msg_send_stret);
	    else
	      VALUE_ADDRESS (method) = value_as_address (msg_send);
	    called_method = method;
	  }
	else
	  {
	    if (struct_return)
	      called_method = msg_send_stret;
	    else
	      called_method = msg_send;
	  }

	if (noside == EVAL_SKIP)
	  goto nosideret;

	if (noside == EVAL_AVOID_SIDE_EFFECTS)
	  {
	    /* If the return type doesn't look like a function type,
	       call an error.  This can happen if somebody tries to
	       turn a variable into a function call. This is here
	       because people often want to call, eg, strcmp, which
	       gdb doesn't know is a function.  If gdb isn't asked for
	       it's opinion (ie. through "whatis"), it won't offer
	       it. */

	    struct type *type = VALUE_TYPE (called_method);
	    if (type && TYPE_CODE (type) == TYPE_CODE_PTR)
	      type = TYPE_TARGET_TYPE (type);
	    type = TYPE_TARGET_TYPE (type);

	    if (type)
	    {
	      if ((TYPE_CODE (type) == TYPE_CODE_ERROR) && expect_type)
		return allocate_value (expect_type);
	      else
		return allocate_value (type);
	    }
	    else
	      error ("Expression of type other than \"method returning ...\" used as a method");
	  }

	/* Now depending on whether we found a symbol for the method,
	   we will either call the runtime dispatcher or the method
	   directly.  */

	argvec[0] = called_method;
	argvec[1] = target;
	argvec[2] = value_from_longest (builtin_type_long, selector);
	/* User-supplied arguments.  */
	for (tem = 0; tem < nargs; tem++)
	  argvec[tem + 3] = evaluate_subexp_with_coercion (exp, pos, noside);
	argvec[tem + 3] = 0;

	if (gnu_runtime && (method != NULL))
	  {
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	    /* Function objc_msg_lookup returns a pointer.  */
	    argvec[0] = ret;
	    ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);
	  }
	else
	  ret = call_function_by_hand (argvec[0], nargs + 2, argvec + 1);

	return ret;
      }
      break;

a1757 4

    case OP_OBJC_SELF:
      (*pos) += 1;
      return value_of_local ("self", 1);
@


1.23.8.9
log
@2003-05-07  David Carlton  <carlton@@bactrian.org>

	* valops.c (value_aggregate_elt): Add 'noside' argument.
	(value_struct_elt_for_reference): Add 'block', 'noside'
	arguments.  Call value_maybe_namespace_elt.
	(value_namespace_elt): Add 'noside' argument.  Break out code into
	value_maybe_namespace_elt.
	(value_maybe_namespace_elt): New.  Handle types.
	* value.h: Update declaration for value_aggregate_elt.
	* eval.c (evaluate_subexp_standard): Pass 'noside' to
	value_aggregate_elt.
	* c-exp.y: Added 'qualified_type'.
	(yylex): Comment out nested type stuff.

2003-05-07  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Update messages to match new parser
	changes.
@
text
@d412 1
a412 2
				  &exp->elts[pc + 4].string,
				  noside);
@


1.23.8.10
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d457 1
a457 1
		 frame_map_regnum_to_name (get_selected_frame (), regno));
@


1.23.8.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d70 2
a71 2
evaluate_subexp (struct type *expect_type, struct expression *exp,
		 int *pos, enum noside noside)
d83 2
a84 2
  CORE_ADDR addr;
  struct cleanup *old_chain =
d99 2
a100 2
  CORE_ADDR addr;
  struct cleanup *old_chain =
d114 2
a115 2
  LONGEST retval;
  struct cleanup *old_chain =
d128 1
a128 1
  struct cleanup *old_chain =
d145 1
a145 1
  struct cleanup *old_chain =
d179 1
a179 1
get_label (struct expression *exp, int *pos)
d198 2
a199 2
		       struct expression *exp,
		       int *pos, enum noside noside, int nargs)
d341 1
a341 1
		    struct expression *exp, int *pos,
d382 1
a382 1
			  struct expression *exp, int *pos,
d387 1
a387 1
  int pc, pc2 = 0, oldpos;
d858 1
a858 1
	    struct_return = using_struct_return (value_type, using_gcc);
d862 1
a862 1
	    struct_return = using_struct_return (check_typedef (expect_type), using_gcc);
d2074 1
a2074 1
evaluate_subexp_for_address (struct expression *exp, int *pos,
d2078 1
a2078 1
  int pc;
d2154 2
a2155 2
evaluate_subexp_with_coercion (struct expression *exp,
			       int *pos, enum noside noside)
d2157 2
a2158 2
  enum exp_opcode op;
  int pc;
d2191 1
a2191 1
evaluate_subexp_for_sizeof (struct expression *exp, int *pos)
d2194 1
a2194 1
  int pc;
@


1.23.8.12
log
@2003-09-19  David Carlton  <carlton@@kealia.com>

	* expression.h (enum exp_opcode): Revert to mainline's OP_FUNCALL,
	OP_SCOPE.
	* ada-exp.y, m2-exp.y, objc-exp.y, p-exp.y: Ditto.
	* jv-exp.y (push_qualified_expression_name): Ditto.
	* ada-lang.c (ada_resolve_subexp, replace_operator_with_call)
	(ada_evaluate_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Ditto.
	* expprint.c (print_subexp, dump_subexp): Ditto.
	* parse.c (length_of_subexp, prefixify_subexp): Ditto.
	* c-exp.y: Ditto, and add comment.
	* cp-support.c (make_symbol_overload_list): Delete 'block'
	argument; change calls to make_symbol_overload_list_using
	appropriately.
	(make_symbol_overload_list_using): Delete 'block' argument;
	replace it by get_selected_block (0).
	* cp-support.h: Delete 'block' argument from
	make_symbol_overload_list.
	* valops.c (find_overload_match): Delete 'block' argument, and
	update calls using it.
	(find_oload_champ_namespace, find_oload_champ_namespace_loop)
	(value_aggregate_elt, value_struct_elt_for_reference)
	(value_namespace_elt): Ditto.
	(value_maybe_namespace_elt): Delete 'block' argument, and use
	get_selected_block (0) instead.
	* value.h: Delete 'block' argument from value_struct_elt,
	value_find_oload.
@
text
@d400 1
d408 2
a409 2
      tem = longest_to_int (exp->elts[pc + 2].longconst);
      (*pos) += 4 + BYTES_TO_EXP_ELEM (tem + 1);
d411 2
a412 1
				  &exp->elts[pc + 3].string,
d415 1
a415 1
	error ("There is no field named %s", &exp->elts[pc + 3].string);
d952 1
a952 1
      (*pos) += 2;
d955 2
d1128 1
d1187 1
d1924 2
a1925 2
	      int temm = longest_to_int (exp->elts[pc + 3].longconst);
	      (*pos) += 3 + BYTES_TO_EXP_ELEM (temm + 1);
@


1.23.8.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a37 1
#include "parser-defs.h"
d73 1
a73 2
  return (*exp->language_defn->la_exp_desc->evaluate_exp) 
    (expect_type, exp, pos, noside);
@


1.23.8.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d230 1
a230 1
		  if (field_name != NULL && DEPRECATED_STREQ (field_name, label))
d258 1
a258 1
				  if (DEPRECATED_STREQ (TYPE_FIELD_NAME (substruct_type,
@


1.23.6.1
log
@* frame.c: Include "gdb_string.h" and "builtin-regs.h".
(frame_map_regnum_to_name): New function.
(frame_map_name_to_regnum): New function.
* frame.h (frame_map_name_to_regnum): Declare.
(frame_map_regnum_to_name): Declare.
* builtin-regs.c (builtin_reg_map_regnum_to_name): New function.
* builtin-regs.h (builtin_reg_map_regnum_to_name): Declare.
* parse.c: Do not include "builtin-regs.h".
(target_map_name_to_register): Delete function.
(write_dollar_variable): Use frame_map_name_to_regnum.
* parser-defs.h (target_map_name_to_register): Delete declaration.
* expprint.c: Include "frame.h".
(print_subexp): Use frame_map_regnum_to_name.
* eval.c (evaluate_subexp_standard): Use frame_map_regnum_to_name.
* infcmd.c (registers_info): Use frame_map_name_to_regnum.

Testsuite:

* gdb.base/pc-fp.exp, gdb.base/pc-fp.c: New test.
@
text
@d451 1
a451 2
	  error ("Value of register %s not available.",
		 frame_map_regnum_to_name (regno));
@


1.22
log
@2002-04-12  Michael Snyder  <msnyder@@redhat.com>

	* eval.c: Indentation fix-ups.
@
text
@d189 2
a190 2
/* This function evaluates tuples (in Chill) or brace-initializers
   (in C/C++) for structure types.  */
d328 5
a332 7
/* Recursive helper function for setting elements of array tuples for Chill.
   The target is ARRAY (which has bounds LOW_BOUND to HIGH_BOUND);
   the element value is ELEMENT;
   EXP, POS and NOSIDE are as usual.
   Evaluates index expresions and sets the specified element(s) of
   ARRAY to ELEMENT.
   Returns last index value.  */
@


1.22.6.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d189 2
a190 2
/* This function evaluates tuples (in (OBSOLETE) Chill) or
   brace-initializers (in C/C++) for structure types.  */
d328 7
a334 5
/* Recursive helper function for setting elements of array tuples for
   (OBSOLETE) Chill.  The target is ARRAY (which has bounds LOW_BOUND
   to HIGH_BOUND); the element value is ELEMENT; EXP, POS and NOSIDE
   are as usual.  Evaluates index expresions and sets the specified
   element(s) of ARRAY to ELEMENT.  Returns last index value.  */
@


1.22.6.2
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d451 1
a451 2
	  error ("Value of register %s not available.",
		 frame_map_regnum_to_name (regno));
@


1.21
log
@	* eval.c (evaluate_subexp_standard): Fix setup of ``this'' pointer
	for method resolution.  Restore adjustment of ``this'' pointer after
	calling value_struct_elt, which was accidentally removed during the
	HP merge.
@
text
@d81 1
a81 1
  make_cleanup (free_current_contents, &expr);
d97 1
a97 1
  make_cleanup (free_current_contents, &expr);
d124 2
a125 2
  register struct cleanup *old_chain
  = make_cleanup (free_current_contents, &expr);
d141 2
a142 2
  register struct cleanup *old_chain
  = make_cleanup (free_current_contents, &expr);
@


1.20
log
@* eval.c (evaluate_subexp_standard): Pass ``selected_frame'' to
value_of_register.
* findvar.c (value_of_register): Add ``frame'' parameter.  Pass to
get_saved_register.
* value.h (value_of_register): Update.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000, 2001
a822 1
	  struct value *temp = arg2;
d826 1
a826 5
	  /* pai: this used to have lookup_pointer_type for some reason,
	   * but temp is already a pointer to the object */
	  argvec[1]
	    = value_from_pointer (VALUE_TYPE (temp),
				  VALUE_ADDRESS (temp) + VALUE_OFFSET (temp));
d852 1
a852 1
	      temp = arg2;
d857 6
@


1.19
log
@2002-01-04  Daniel Jacobowitz  <drow@@mvista.com>

        * valops.c (find_overload_match): Accept obj as a
        reference parameter.  Update it before returning.
        * value.h (find_overload_match): Update prototype.
        * eval.c (evaluate_subexp_standard): Pass object to
        find_overload_match by reference.
@
text
@d450 1
a450 2
	struct value *val = value_of_register (regno);

@


1.18
log
@* cli/cli-script.c (execute_control_command): Replace value_ptr
with a struct value pointer.
* ch-lang.c (evaluate_subexp_chill): Ditto.
* printcmd.c (printf_command): Ditto.
* tracepoint.c (set_traceframe_context): Ditto.
(encode_actions): Ditto.
* eval.c (evaluate_subexp_standard): Ditto.
@
text
@d848 1
a848 1
					  arg2 /* the object */ , NULL,
@


1.17
log
@Approved by Jim Blandy:

	2001-12-10  Fred Fish  <fnf@@redhat.com>
	* values.c (value_fn_field): Add physname variable.  Use a minimal
	symbol if we don't find a full symbol.  Remove setting of the new
	value's type since that was already done by allocate_value().
	Remove obsolete commented out error call since callees need to
	handle a NULL return, which is possible result not an error.
	* eval.c (evaluate_subexp_standard): Move check for inlined
	functions to precede attempt to dereference a NULL argvec[0].
@
text
@d623 1
a623 1
      argvec = (value_ptr *) alloca (sizeof (value_ptr) * nargs);
d676 1
a676 1
      argvec = (value_ptr *) alloca (sizeof (value_ptr) * (nargs + 3));
d972 1
a972 1
	  argvec = (value_ptr *) alloca (sizeof (value_ptr) * (nargs + 2));
@


1.16
log
@Patch from Andreas Schwab <schwab@@suse.de>:
* eval.c (evaluate_subexp_standard): Fix memory leak: use alloca
instead of xmalloc.
@
text
@d920 2
a938 2
      if (argvec[0] == NULL)
	error ("Cannot evaluate function -- may be inlined");
@


1.15
log
@s/value_ptr/struct value */
@
text
@d842 1
a842 1
	      arg_types = (struct type **) xmalloc (nargs * (sizeof (struct type *)));
d891 1
a891 1
	      arg_types = (struct type **) xmalloc (nargs * (sizeof (struct type *)));
@


1.14
log
@* value.h (value_as_address): Rename value_as_pointer.
* eval.c, findvar.c, gnu-v2-abi.c, gnu-v3-abi.c, jv-lang.c,
jv-valprint.c, printcmd.c, stack.c, top.c, valarith.c, valops.c,
values.c: Update.
@
text
@d3 1
a3 1
   1996, 1997, 1998, 1999, 2000
d47 1
a47 1
static value_ptr evaluate_subexp_for_sizeof (struct expression *, int *);
d49 2
a50 2
static value_ptr evaluate_subexp_for_address (struct expression *,
					      int *, enum noside);
d52 2
a53 2
static value_ptr evaluate_subexp (struct type *, struct expression *,
				  int *, enum noside);
d57 7
a63 3
static value_ptr
evaluate_struct_tuple (value_ptr, struct expression *, int *,
		       enum noside, int);
d65 1
a65 5
static LONGEST
init_array_element (value_ptr, value_ptr, struct expression *,
		    int *, enum noside, LONGEST, LONGEST);

static value_ptr
d119 1
a119 1
value_ptr
d123 1
a123 1
  register value_ptr val;
d136 1
a136 1
value_ptr
d140 1
a140 1
  register value_ptr val;
d154 1
a154 1
value_ptr
d164 1
a164 1
value_ptr
d192 3
a194 2
static value_ptr
evaluate_struct_tuple (value_ptr struct_val, register struct expression *exp,
d206 1
a206 1
      value_ptr val = NULL;
d337 1
a337 1
init_array_element (value_ptr array, value_ptr element,
d377 1
a377 1
value_ptr
d385 3
a387 1
  register value_ptr arg1 = NULL, arg2 = NULL, arg3;
d390 1
a390 1
  value_ptr *argvec;
d450 1
a450 1
	value_ptr val = value_of_register (regno);
d493 1
a493 1
	  value_ptr rec = allocate_value (expect_type);
d503 1
a503 1
	  value_ptr array = allocate_value (expect_type);
d515 1
a515 1
	      value_ptr element;
d551 1
a551 1
	  value_ptr set = allocate_value (expect_type);
d569 1
a569 1
	      value_ptr elem_val;
d635 1
a635 1
	value_ptr array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d647 1
a647 1
	value_ptr array = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d734 1
a734 1
			  value_ptr temp = value_ind (arg2);
d824 1
a824 1
	  value_ptr temp = arg2;
d839 1
a839 1
	      value_ptr valp = NULL;
d1026 1
a1026 1
	  value_ptr temp = arg1;
d1069 1
a1069 1
	  value_ptr temp = arg1;
d1643 1
a1643 1
	  value_ptr retvalp = evaluate_subexp_for_address (exp, pos, noside);
d1779 1
a1779 1
static value_ptr
d1835 1
a1835 1
	  value_ptr x = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d1859 1
a1859 1
value_ptr
d1865 1
a1865 1
  register value_ptr val;
d1896 1
a1896 1
static value_ptr
d1902 1
a1902 1
  value_ptr val;
@


1.13
log
@(Changes from Daniel Berlin, with revisions by Jim Blandy.)

Abstract out operations specific to particular C++ ABI's, and
invoke them through a function table.  This removes the C++ ABI
dependencies scattered throughout the code, and allows us to
cleanly add support for new C++ ABI's.
* cp-abi.h, cp-abi.h, gnu-v2-abi.c, hpacc-abi.c: New files.
* c-typeprint.c, c-valprint.c, dbxread.c, eval.c, gdbtypes.c,
jv-typeprint.c, linespec.c, symtab.c, typeprint.c, valops.c:
#include "cp-abi.h".  These files all use functions now declared
there.
* symtab.h (OPNAME_PREFIX_P, VTBL_PREFIX_P, DESTRUCTOR_PREFIX_P):
Deleted.  These services are now provided by functions declared in
cp-abi.h.
* value.h (value_rtti_type, value_virtual_fn_field): Same.
* values.c (value_virtual_fn_field): Same, for this definition.
* valops.c (value_rtti_type): Same.
* c-typeprint.c (c_type_print_base): Use the functions from
"cp-abi.h", instead of the old macros, or hard-coded ABI-specific
tests.
* dbxread.c (record_minimal_symbol): Same.
* gdbtypes.c (get_destructor_fn_field, virtual_base_index,
virtual_base_index_skip_primaries): Same.
* jv-typeprint.c (java_type_print_base): Same.
* linespec.c (find_methods, decode_line_1): Same.
* symtab.c (gdb_mangle_name): Same.
* Makefile.in (SFILES): Add the new .c files mentioned above.
(cp_abi_h): New variable.
(COMMON_OBS): Add gnu-v2-abi.o, hpacc-abi.o, and cp-abi.o.
(cp-abi.o, gnu-v2-abi.o, hpacc-abi.o): New targets.
(c-typeprint.o, c-valprint.o, dbxread.o, eval.o, gdbtypes.o,
jv-typeprint.o, symtab.o, linespec.o, typeprint.o, valops.o): Add
dependency on $(cp_abi_h).
@
text
@d83 1
a83 1
  addr = value_as_pointer (evaluate_expression (expr));
d99 1
a99 1
  addr = value_as_pointer (evaluate_expression (expr));
d1679 1
a1679 1
			      value_as_pointer (arg1),
@


1.13.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@a374 50
/* Given a function "f" which is a member of a class, find
 * the classname that it is a member of. Used to construct
 * the name (e.g., "c::f") which GDB will put in the
 * "demangled name" field of the function's symbol.
 * Called from hpread_process_one_debug_symbol()
 * If "f" is not a member function, return NULL.
 */
const char *
class_of (functype)
     struct type *functype;
{
  struct type *first_param_type;
  char *first_param_name;
  struct type *pointed_to_type;
  const char *class_name;

  /* Check that the function has a first argument "this",
   * and that "this" is a pointer to a class. If not,
   * functype is not a member function, so return NULL.
   */
  if (TYPE_NFIELDS (functype) == 0)
    return NULL;
  first_param_name = TYPE_FIELD_NAME (functype, 0);
  if (first_param_name == NULL)
    return NULL;		/* paranoia */
  if (strcmp (first_param_name, "this"))
    return NULL;
  first_param_type = TYPE_FIELD_TYPE (functype, 0);
  if (first_param_type == NULL)
    return NULL;		/* paranoia */
  if (TYPE_CODE (first_param_type) != TYPE_CODE_PTR)
    return NULL;

  /* Get the thing that "this" points to, check that
   * it's a class, and get its class name.
   */
  pointed_to_type = POINTER_TARGET_TYPE (first_param_type);
  if (pointed_to_type == NULL)
    return NULL;		/* paranoia */
  if (TYPE_CODE (pointed_to_type) != TYPE_CODE_CLASS)
    return NULL;
  class_name = TYPE_NAME (pointed_to_type);
  if (class_name == NULL)
    return NULL;		/* paranoia */

  /* The class name may be of the form "class c", in which case
   * we want to strip off the leading "class ".
   */
  if (strncmp (class_name, "class ", 6) == 0)
    class_name += 6;
a375 2
  return class_name;
}
a400 2
      {
      int look_for_this = 0;
a402 55
	/* Handle class_name::member. If it is a static data member,
	   the compiler generates a fully qualified symbol name for it. 'yylex'
	   routine has already looked ahead in order to get a symbol for it.
	   However, if it is not a static data member, it is simply a field of
	   its class. To get around the problem, a flag 'look_for_this' is
	   used to tell the callees to check if it is a data member of 'this'.
	*/
	if (current_language->la_language == language_cplus)
          {
	    if (pc && exp->elts[pc - 1].opcode == UNOP_ADDR)
              {
		/* If we see 'object.class_name::member', it is not a member of
		   'this'. */
                look_for_this = 0;                                 
	      }
	    else
              {
		char * class_name = TYPE_TAG_NAME(exp->elts[pc + 1].type);
		if (selected_frame)
                  {
		    /* If pc is in a member function of its class or the class
		       is dervied from virtual class, it can be member of
		       'this'. */ 
		    struct symbol * func_sym =
		      find_pc_function (selected_frame->pc);

		    if (func_sym)
                      {

			const char * func_class_name =
			  class_of (SYMBOL_TYPE (func_sym));

			/* it could be a data member in which case we
			   will just save some time digging up info for
			   class functions. */
			if (func_class_name != NULL)
			  {
			    if (!strcmp(class_name, func_class_name))
			      look_for_this = 1;
			    else
			      {
				struct symbol * func_class_sym = 
				  lookup_symbol (func_class_name, 0,
						 VAR_NAMESPACE, 0, 0);

				fill_in_vptr_fieldno (SYMBOL_TYPE (func_class_sym));
				if (func_class_sym && 
				    TYPE_VPTR_FIELDNO (SYMBOL_TYPE (func_class_sym)) != -1)
				  look_for_this = 1;
			      }
			  }
		      }
		  }
	      }
	  }
d407 1
a407 1
					     NULL_TYPE, look_for_this);
d411 1
a411 1
      }
d498 2
a499 2
	  struct range_type *range_type = ARRAY_RANGE_TYPE (type);
	  struct type *element_type = ARRAY_ELEMENT_TYPE (type);
d503 5
a507 2
	  low_bound = RANGE_LOWER_BOUND (range_type);
	  high_bound = RANGE_UPPER_BOUND (range_type);
d544 1
d550 2
a551 2
	  struct range_type *element_type = SET_RANGE_TYPE (type);
	  struct type *check_type;
d553 7
a559 6
	  check_type = check_typedef ((struct type *)element_type);
	  while (TYPE_CODE (check_type) == TYPE_CODE_RANGE)
		  check_type = check_typedef (RANGE_INDEX_TYPE (check_type));
	  low_bound = RANGE_LOWER_BOUND (element_type);
	  high_bound = RANGE_UPPER_BOUND (element_type);
	  if (low_bound < 0 || high_bound < 0)
d570 1
a570 1
		  elem_val = evaluate_subexp ((struct type *)element_type, exp, pos, noside);
d573 1
a573 1
		  elem_val = evaluate_subexp ((struct type *)element_type, exp, pos, noside);
d579 1
a579 1
		  elem_val = evaluate_subexp ((struct type *)element_type, exp, pos, noside);
d587 1
a587 1
		range_low_type = RANGE_INDEX_TYPE (range_low_type);
d589 1
a589 1
		range_high_type = RANGE_INDEX_TYPE (range_high_type);
d619 1
d795 1
a795 1
	    type = POINTER_TARGET_TYPE (type);
d798 1
a798 1
	      for (; tem <= nargs && tem <= FUNCTION_NUM_ARGUMENTS (type); tem++)
d802 1
a802 1
		  argvec[tem] = evaluate_subexp (FUNCTION_ARGUMENT_TYPE (type, tem - 1),
d1042 3
a1044 2
        if (objectprint && POINTER_TARGET_TYPE(type) &&
            (TYPE_CODE (POINTER_TARGET_TYPE (type)) == TYPE_CODE_CLASS))
d1078 1
a1078 1
      (TYPE_CODE (POINTER_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
d1091 1
a1091 1
      (TYPE_CODE (POINTER_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
d1110 1
a1110 1
      type = check_typedef (POINTER_TARGET_TYPE (type));
d1146 1
a1146 1
	      (TYPE_CODE (POINTER_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_METHOD))
d1151 1
a1151 1
	      (TYPE_CODE (POINTER_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_MEMBER))
d1256 1
a1256 6
	  {
	    if (TYPE_CODE (type) == TYPE_CODE_PTR)
		    return value_zero (POINTER_TARGET_TYPE (type), VALUE_LVAL (arg1));
	    else
		    return value_zero (TYPE_TARGET_TYPE (type), VALUE_LVAL (arg1));
	  }
d1594 1
a1594 1
	expect_type = POINTER_TARGET_TYPE (check_typedef (expect_type));
d1596 3
a1598 3
      if ((POINTER_TARGET_TYPE (VALUE_TYPE (arg1))) &&
	  ((TYPE_CODE (POINTER_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_METHOD) ||
	   (TYPE_CODE (POINTER_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_MEMBER)))
a1606 1
	  /* TYPEFIX */
d1608 5
a1612 2
	      || TYPE_CODE (type) == TYPE_CODE_REF)
	    return value_zero (POINTER_TARGET_TYPE (type),
a1613 3
	  /* In C you can dereference an array to get the 1st elt. */
	  else if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
	    return value_zero (ARRAY_ELEMENT_TYPE (type), lval_memory);
d1644 1
a1644 1
	      (TYPE_CODE (POINTER_TARGET_TYPE (VALUE_TYPE (retvalp))) == TYPE_CODE_MEMBER))
d1879 1
a1879 1
	  return value_cast (lookup_pointer_type (ARRAY_ELEMENT_TYPE (check_typedef (SYMBOL_TYPE (var)))),
d1918 3
a1920 13
	if (TYPE_CODE (type) == TYPE_CODE_ARRAY)
	  {
	    type = check_typedef (ARRAY_ELEMENT_TYPE (type));
	    return value_from_longest (builtin_type_int, (LONGEST) TYPE_LENGTH (type));
	  }
	else
	  {    
	    type = check_typedef (POINTER_TARGET_TYPE (type));
	    return value_from_longest (builtin_type_int, (LONGEST)
				       TYPE_LENGTH (type));
	  }
	
      
d1970 1
a1970 1
  while ((tmp_type = ARRAY_ELEMENT_TYPE (tmp_type)))
@


1.12
log
@Zap __STDC__ references.
@
text
@d33 1
@


1.11
log
@2001-03-06  J.T. Conklin  <jtc@@redback.com>

        * symtab.h (decode_line_1): Removed declaration.

        * symfile.c (#include <assert.h>): Removed.

        * arch-utils.c (#include <ctype.h>): Removed.
        * c-typeprint.c: Likewise.
        * dbxread.c: Likewise.
        * gdbtypes.c: Likewise.
        * target.c: Likewise.
        * os9kread.c: Likewise.

        * c-valprint.c (#include "demangle.h"): Removed.
        * ch-typeprint.c: Likewise.
        * eval.c: Likewise.
        * f-typeprint.c: Likewise.
        * f-valprint.c: Likewise.
        * m2-typeprint.c: Likewise.
        * typeprint.c: Likewise.
        * p-typeprint.c: Likewise.
        * valarith.c: Likewise.
        * valprint.c: Likewise.

        * m2-typeprint.c (#include "gdb_string.h"): Removed.
        * nlmread.c: Likewise.

        * mdebugread.c (#include "gdb-stabs.h"): Removed.
        * minsyms.c: Likewise.
        * mipsread.c: Likewise.
        * nlmread.c: Likewise.

        * m2-typeprint.c (#include "obstack.h"): Removed.
        * m2-valprint.c: Likewise.

        * event-loop.c (#include <setjmp.h>): Removed.
@
text
@a63 3
#if defined (__GNUC__) && !__STDC__
inline
#endif
@


1.10
log
@Update/correct copyright notices.
@
text
@a30 1
#include "demangle.h"
@


1.9
log
@	* eval.c (parse_and_eval_long): New function.
	* value.h: Declare it.

	* breakpoint.c (breakpoints_info, maintenance_info_breakpoints):
	Call parse_and_eval_long, not parse_and_eval_address.
	* command.c (do_setshow_command): Ditto.
	* infcmd.c (step_1, signal_command, continue_command): Ditto.
	* infrun.c (signals_info): Ditto.
	* stack.c (set_backtrace_limit_command, backtrace_command_1,
	up_silently_base, down_silently_base): Ditto.
	* tracepoints.c (tracepoints_info, trace_find_command,
 	trace_find_tracepoint_command): Ditto.
	* valprint.c (set_radix): Ditto.
	* values.c (show_values): Ditto.
@
text
@d2 2
a3 1
   Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.8
log
@
Correct spelling in comment: tupes -> tuples.
@
text
@d106 15
@


1.7
log
@Protoization.
@
text
@d176 1
a176 1
/* This function evaluates tupes (in Chill) or brace-initializers
@


1.6
log
@PARAMS removal.
@
text
@d68 2
a69 5
evaluate_subexp (expect_type, exp, pos, noside)
     struct type *expect_type;
     register struct expression *exp;
     register int *pos;
     enum noside noside;
d78 1
a78 2
parse_and_eval_address (exp)
     char *exp;
d94 1
a94 2
parse_and_eval_address_1 (expptr)
     char **expptr;
d107 1
a107 2
parse_and_eval (exp)
     char *exp;
d124 1
a124 2
parse_to_comma_and_eval (expp)
     char **expp;
d142 1
a142 2
evaluate_expression (exp)
     struct expression *exp;
d152 1
a152 2
evaluate_type (exp)
     struct expression *exp;
d162 1
a162 3
get_label (exp, pos)
     register struct expression *exp;
     int *pos;
d180 2
a181 6
evaluate_struct_tuple (struct_val, exp, pos, noside, nargs)
     value_ptr struct_val;
     register struct expression *exp;
     register int *pos;
     enum noside noside;
     int nargs;
d323 3
a325 6
init_array_element (array, element, exp, pos, noside, low_bound, high_bound)
     value_ptr array, element;
     register struct expression *exp;
     register int *pos;
     enum noside noside;
     LONGEST low_bound, high_bound;
d364 3
a366 5
evaluate_subexp_standard (expect_type, exp, pos, noside)
     struct type *expect_type;
     register struct expression *exp;
     register int *pos;
     enum noside noside;
d1764 2
a1765 4
evaluate_subexp_for_address (exp, pos, noside)
     register struct expression *exp;
     register int *pos;
     enum noside noside;
d1844 2
a1845 4
evaluate_subexp_with_coercion (exp, pos, noside)
     register struct expression *exp;
     register int *pos;
     enum noside noside;
d1881 1
a1881 3
evaluate_subexp_for_sizeof (exp, pos)
     register struct expression *exp;
     register int *pos;
d1931 1
a1931 3
parse_and_eval_type (p, length)
     char *p;
     int length;
d1947 1
a1947 2
calc_f77_array_dims (array_type)
     struct type *array_type;
@


1.5
log
@	* ax-gdb.c (agent_command): Remove now useless cast of
	`free_current_contents' when passed to `make_cleanup'.
	* coffread.c (coff_symfile_read): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn, read_array_type): Ditto.
	(dwarf_decode_lines): Ditto.
	* eval.c (parse_and_eval_address, parse_and_eval_address_1): Ditto.
	(parse_and_eval, parse_to_comma_and_eval): Ditto.
	* parse.c (parse_exp_1): Ditto.
	* printcmd.c (print_command_1, output_command, set_command): Ditto.
	(x_command, print_frame_args, printf_command): Ditto.
	* top.c (execute_control_command): Ditto.
	* tracepoint.c (validate_actionline): Ditto.
	* typeprint.c (whatis_exp, ptype_command): Ditto.
	(maintenance_print_type): Ditto.
@
text
@d46 1
a46 2
static value_ptr evaluate_subexp_for_sizeof PARAMS ((struct expression *,
						     int *));
d48 2
a49 2
static value_ptr evaluate_subexp_for_address PARAMS ((struct expression *,
						      int *, enum noside));
d51 2
a52 2
static value_ptr evaluate_subexp PARAMS ((struct type *, struct expression *,
					  int *, enum noside));
d54 1
a54 1
static char *get_label PARAMS ((struct expression *, int *));
d57 2
a58 2
  evaluate_struct_tuple PARAMS ((value_ptr, struct expression *, int *,
				 enum noside, int));
d61 2
a62 2
  init_array_element PARAMS ((value_ptr, value_ptr, struct expression *,
			      int *, enum noside, LONGEST, LONGEST));
@


1.4
log
@* gdbarch.sh (POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Two new
functions which architectures can redefine, defaulting to
generic_pointer_to_address and generic_address_to_pointer.
* findvar.c (extract_typed_address, store_typed_address,
generic_pointer_to_address, generic_address_to_pointer): New
functions.
(POINTER_TO_ADDRESS, ADDRESS_TO_POINTER): Provide default
definitions.
(extract_address, store_address): Doc fixes.
* values.c (value_as_pointer): Doc fix.
(value_from_pointer): New function.
* defs.h (extract_typed_address, store_typed_address): New
declarations.
* inferior.h (generic_address_to_pointer,
generic_pointer_to_address): New declarations.
* value.h (value_from_pointer): New declaration.

* ax-gdb.c (const_var_ref): Use value_from_pointer, not
value_from_longest.
* blockframe.c (generic_push_dummy_frame): Use read_pc and
read_sp, not read_register.
* c-valprint.c (c_val_print): Use extract_typed_address instead of
extract_address to extract vtable entries and references.
* cp-valprint.c (cp_print_value_fields): Use value_from_pointer
instead of value_from_longest to extract the vtable's address.
* eval.c (evaluate_subexp_standard): Use value_from_pointer
instead of value_from_longest to compute `this', and for doing
pointer-to-member dereferencing.
* findvar.c (read_register): Use extract_unsigned_integer, not
extract_address.
(read_var_value): Use store_typed_address instead of store_address
for building label values.
(locate_var_value): Use value_from_pointer instead of
value_from_longest.
* hppa-tdep.c (find_stub_with_shl_get): Use value_from_pointer,
instead of value_from_longest, to build arguments to __d_shl_get.
* printcmd.c (set_next_address): Use value_from_pointer, not
value_from_longest.
(x_command): Use value_from_pointer, not value_from_longest.
* tracepoint.c (set_traceframe_context): Use value_from_pointer,
not value_from_longest.
* valarith.c (value_add, value_sub): Use value_from_pointer, not
value_from_longest.
* valops.c (find_function_in_inferior, value_coerce_array,
value_coerce_function, value_addr, hand_function_call): Same.
* value.h (COERCE_REF): Use unpack_pointer, not unpack_long.
* values.c (unpack_long): Use extract_typed_address to produce
addresses from pointers and references, not extract_address.
(value_from_longest): Use store_typed_address instead of
store_address to produce pointer and reference values.
@
text
@d88 1
a88 1
  make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d105 1
a105 1
  make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d119 1
a119 1
  = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d137 1
a137 1
  = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
@


1.3
log
@C++ changes for 5.0, finally committed.
@
text
@d835 3
a837 2
	  argvec[1] = value_from_longest (VALUE_TYPE (temp),
				VALUE_ADDRESS (temp) + VALUE_OFFSET (temp));
d1126 1
a1126 1
      arg3 = value_from_longest (lookup_pointer_type (TYPE_TARGET_TYPE (type)),
@


1.2
log
@2000-03-14  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* eval.c (evaluate_subexp_with_coercion): Add call to
 	check_typedef, to handle typedeffed vars correctly.

	* gdb.base/printcmds.c: Add typedeffed arrays.

	* gdb.base/printcmds.exp (test_print_typedef_arrays): New
 	procedure to test arrays that are typedef'd.
@
text
@d40 3
a433 17
      if (noside == EVAL_AVOID_SIDE_EFFECTS)
	{
	  struct symbol *sym = exp->elts[pc + 2].symbol;
	  enum lval_type lv;

	  switch (SYMBOL_CLASS (sym))
	    {
	    case LOC_CONST:
	    case LOC_LABEL:
	    case LOC_CONST_BYTES:
	      lv = not_lval;
	      break;

	    case LOC_REGISTER:
	    case LOC_REGPARM:
	      lv = lval_register;
	      break;
d435 8
a442 4
	    default:
	      lv = lval_memory;
	      break;
	    }
a443 3
	  return value_zero (SYMBOL_TYPE (sym), lv);
	}
      else
d1041 25
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
This file is part of GDB.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 2
a32 2
#include "language.h"	/* For CAST_IS_CONVERSION */
#include "f-lang.h"	/* for array bound stuff */
d34 1
a34 1
/* Defined in symtab.c */ 
d37 1
a37 1
/* This is defined in valops.c */ 
d55 2
a56 2
evaluate_struct_tuple PARAMS ((value_ptr, struct expression *, int *,
			       enum noside, int));
d59 2
a60 2
init_array_element PARAMS ((value_ptr, value_ptr, struct expression *,
			    int *, enum noside, LONGEST, LONGEST));
d62 1
a62 1
#ifdef __GNUC__
d84 2
a85 2
  register struct cleanup *old_chain = 
      make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d99 1
a99 1
  struct expression *expr = parse_exp_1 (expptr, (struct block *)0, 0);
d102 1
a102 1
      make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d116 1
a116 1
    = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d134 1
a134 1
    = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d168 1
a168 1
static char*
d202 1
a202 1
   while (--nargs >= 0)
d209 1
a209 1
      
d246 1
a246 1
			    { 
d248 1
a248 1
				   subfieldno < TYPE_NFIELDS (substruct_type);
d321 2
a322 1
	} while (--nlabels > 0);
d361 1
a361 1
      for (index = low ; index <= high; index++)
d393 1
a393 1
  int upper, lower, retcode; 
d397 1
a397 2
  struct symbol * sym;
  struct type ** arg_types;
a399 13
  /* This expect_type crap should not be used for C.  C expressions do
     not have any notion of expected types, never has and (goddess
     willing) never will.  The C++ code uses it for some twisted
     purpose (I haven't investigated but I suspect it just the usual
     combination of Stroustrup figuring out some crazy language
     feature and Tiemann figuring out some crazier way to try to
     implement it).  CHILL has the tuple stuff; I don't know enough
     about CHILL to know whether expected types is the way to do it.
     FORTRAN I don't know.  */
  if (exp->language_defn->la_language != language_cplus
      && exp->language_defn->la_language != language_chill)
    expect_type = NULL_TYPE;

d412 1
a412 1
					     expect_type);
d433 1
a433 1
	  struct symbol * sym = exp->elts[pc + 2].symbol;
d467 1
a467 1
	int regno     = longest_to_int (exp->elts[pc + 1].longconst);
d479 1
a479 1
				   exp->elts[pc + 1].longconst);
d531 1
a531 1
	  for (tem = nargs;  --nargs >= 0;  )
d605 2
a606 2
		 different types. Also check if type of element is "compatible"
		 with element type of powerset */
d629 1
a629 1
	      for ( ; range_low <= range_high; range_low++)
d634 1
a634 1
		  valaddr [(unsigned) range_low / TARGET_CHAR_BIT]
d655 1
a655 1
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d657 1
a657 1
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d667 1
a667 1
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d669 1
a669 1
	  = value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d693 1
a693 1
	 called in argvec[0] and a terminating NULL */
d699 7
a705 7
          /* 1997-08-01 Currently we do not support function invocation
             via pointers-to-methods with HP aCC. Pointer does not point
             to the function, but possibly to some thunk. */
          if (hp_som_som_object_present)
            {
              error ("Not implemented: function invocation through pointer to method with HP aCC");
            }
d733 1
a733 1
	  if (METHOD_PTR_IS_VIRTUAL(fnptr))
d735 1
a735 1
	      int fnoffset = METHOD_PTR_TO_VOFFSET(fnptr);
d738 1
a738 1
		  TYPE_DOMAIN_TYPE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1)));
d742 1
a742 1
		  arg2 = value_cast(lookup_pointer_type (domain_type), arg2);
d786 2
a787 2
		 v.method (), this will produce an error, because v has
		 no address.
d789 10
a798 10
		 A possible way around this would be to allocate a
		 copy of the variable on the stack, copy in the
		 contents, call the function, and copy out the
		 contents.  I.e. convert this from call by reference
		 to call by copy-return (or whatever it's called).
		 However, this does not work because it is not the
		 same: the method being called could stash a copy of
		 the address, and then future uses through that address
		 (after the method returns) would be expected to
		 use the variable itself, not some copy of it.  */
d821 3
a823 3
                  /* pai: FIXME This seems to be coercing arguments before
                   * overload resolution has been done! */
		  argvec[tem] = evaluate_subexp (TYPE_FIELD_TYPE (type, tem-1),
d844 4
a847 8
          struct fn_field * fns_ptr;
          int num_fns;
          struct type * basetype;
          int boffset;

          /* Method invocation : stuff "this" as first parameter */
          /* pai: this used to have lookup_pointer_type for some reason,
           * but temp is already a pointer to the object */
d849 33
a881 32
                                          VALUE_ADDRESS (temp)+VALUE_OFFSET (temp));
          /* Name of method from expression */ 
          strcpy(tstr, &exp->elts[pc2+2].string);
          
          if (overload_resolution && (exp->language_defn->la_language == language_cplus))
            {
              /* Language is C++, do some overload resolution before evaluation */
              value_ptr valp = NULL;
              
              /* Prepare list of argument types for overload resolution */ 
              arg_types = (struct type **) xmalloc (nargs * (sizeof (struct type *)));
              for (ix=1; ix <= nargs; ix++)
                arg_types[ix-1] = VALUE_TYPE (argvec[ix]);

              (void) find_overload_match (arg_types, nargs, tstr,
                                          1 /* method */, 0 /* strict match */,
                                          arg2 /* the object */, NULL,
                                          &valp, NULL, &static_memfuncp);


              argvec[1] = arg2;  /* the ``this'' pointer */
              argvec[0] = valp;  /* use the method found after overload resolution */ 
            }
          else /* Non-C++ case -- or no overload resolution */ 
            {
              temp = arg2;
              argvec[0] = value_struct_elt (&temp, argvec+1, tstr,
                                            &static_memfuncp,
                                            op == STRUCTOP_STRUCT
                                            ? "structure" : "structure pointer");
              argvec[1] = arg2; /* the ``this'' pointer */
            }
d895 2
a896 2
      else
        { 
d898 3
d902 30
a931 25
          if (overload_resolution && (exp->language_defn->la_language == language_cplus))
            {
              /* Language is C++, do some overload resolution before evaluation */
             struct symbol * symp;

              /* Prepare list of argument types for overload resolution */ 
              arg_types = (struct type **) xmalloc (nargs * (sizeof (struct type *)));
              for (ix=1; ix <= nargs; ix++)
                arg_types[ix-1] = VALUE_TYPE (argvec[ix]);

              (void) find_overload_match (arg_types, nargs, NULL /* no need for name */,
                                          0 /* not method */, 0 /* strict match */,
                                          NULL, exp->elts[5].symbol /* the function */,
                                          NULL, &symp, NULL);
              
              /* Now fix the expression being evaluated */ 
              exp->elts[5].symbol = symp;
              argvec[0] = evaluate_subexp_with_coercion (exp, &save_pos1, noside);
            } 
          else
            {
              /* Not C++, or no overload resolution allowed */ 
              /* nothing to be done; argvec already correctly set up */ 
            }
        }
d947 1
a947 1
	    TYPE_TARGET_TYPE (VALUE_TYPE (argvec[0]));
d955 1
a955 1
        error ("Cannot evaluate function -- may be inlined");
d959 1
a959 1
    case OP_F77_UNDETERMINED_ARGLIST: 
d966 1
a966 1
	 If it is a function, we process just as if we got an OP_FUNCALL. */
d968 1
a968 1
      nargs = longest_to_int (exp->elts[pc+1].longconst);
d971 1
a971 1
      /* First determine the type code we are dealing with.  */ 
d976 1
a976 1
      switch (code) 
d994 1
a994 1
	  argvec[tem] = 0; /* signal end of arglist */
d998 1
a998 1
              error ("Cannot perform substring on this type"); 
d1015 2
a1016 2
        goto nosideret;
      
d1019 1
a1019 1
      
d1024 1
a1024 1
	 point numbers that compose it */ 
d1026 1
a1026 1
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside); 
d1070 1
a1070 1
      /* With HP aCC, pointers to methods do not point to the function code */ 
d1072 4
a1075 4
          (TYPE_CODE (VALUE_TYPE (arg2)) == TYPE_CODE_PTR) &&
          (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
        error ("Pointers to methods not supported with HP aCC"); /* 1997-08-19 */
        
d1083 1
a1083 1
      /* With HP aCC, pointers to methods do not point to the function code */ 
d1085 3
a1087 3
          (TYPE_CODE (VALUE_TYPE (arg2)) == TYPE_CODE_PTR) &&
          (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
        error ("Pointers to methods not supported with HP aCC"); /* 1997-08-19 */
d1091 1
a1091 1
handle_pointer_to_member:
d1095 5
a1099 5
        {
          if (!mem_offset) /* no bias -> really null */ 
            error ("Attempted dereference of null pointer-to-member");
          mem_offset &= ~0x20000000;
        }
d1116 2
a1117 2
bad_pointer_to_member:
      error("non-pointer-to-member value used in pointer-to-member construct");
d1133 1
a1133 1
      /* Do special stuff for HP aCC pointers to members */ 
d1135 18
a1152 18
        {
          /* 1997-08-19 Can't assign HP aCC pointers to methods. No details of
             the implementation yet; but the pointer appears to point to a code
             sequence (thunk) in memory -- in any case it is *not* the address
             of the function as it would be in a naive implementation. */ 
          if ((TYPE_CODE (VALUE_TYPE (arg1)) == TYPE_CODE_PTR) &&
              (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_METHOD))
            error ("Assignment to pointers to methods not implemented with HP aCC");

          /* HP aCC pointers to data members require a constant bias */ 
          if ((TYPE_CODE (VALUE_TYPE (arg1)) == TYPE_CODE_PTR) &&
              (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_MEMBER))
              {
                unsigned int * ptr = (unsigned int *) VALUE_CONTENTS (arg2); /* forces evaluation */ 
                *ptr |= 0x20000000; /* set 29th bit */
              }
        }
                                                    
d1212 3
a1214 4
      else
	if (noside == EVAL_AVOID_SIDE_EFFECTS
	    && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
	  return value_zero (VALUE_TYPE (arg1), not_lval);
d1233 1
a1233 1
        {
d1254 1
a1254 1
        }
d1262 1
a1262 1
      
d1286 3
a1288 3
		 type (like a plain int variable for example), then report this
		 as an error. */
	      
d1302 1
a1302 1
	  
d1315 7
a1321 7
      { 
	int subscript_array[MAX_FORTRAN_DIMS+1]; /* 1-based array of 
						    subscripts, max == 7 */
	int array_size_array[MAX_FORTRAN_DIMS+1];
	int ndimensions=1,i;
	struct type *tmp_type; 
	int offset_item;   /* The array offset where the item lives */ 
d1333 1
a1333 1
	   let us actually find out where this element exists in the array. */ 
d1335 1
a1335 1
	offset_item = 0; 
d1338 1
a1338 1
	    /* Evaluate each subscript, It must be a legal integer in F77 */ 
d1341 1
a1341 1
	    /* Fill in the subscript and array size arrays */ 
d1344 1
a1344 1
               
d1347 1
a1347 1
	      error ("Cannot obtain dynamic upper bound"); 
d1349 1
a1349 1
	    retcode = f77_get_dynamic_lowerbound (tmp_type, &lower); 
d1351 1
a1351 1
	      error("Cannot obtain dynamic lower bound"); 
d1354 3
a1356 3
               
	    /* Zero-normalize subscripts so that offsetting will work. */ 
               
d1365 1
a1365 1
	       offset to. */ 
d1367 2
a1368 2
	    if (i < nargs) 
	      tmp_type = check_typedef (TYPE_TARGET_TYPE (tmp_type)); 
d1373 2
a1374 2
	offset_item = subscript_array[ndimensions]; 
         
d1376 1
a1376 1
	  offset_item = 
d1381 1
a1381 1
	arg2 = value_from_longest (builtin_type_f_integer, offset_item); 
d1390 1
a1390 1
	VALUE_TYPE (arg1) = tmp_type; 
d1401 1
a1401 1
      
d1405 2
a1406 2
      
      if (binop_user_defined_p (op, arg1, arg2)) 
d1417 1
a1417 1
				  (LONGEST) (!tem && !value_logical_not (arg2)));
d1427 1
a1427 1
      
d1431 2
a1432 2
      
      if (binop_user_defined_p (op, arg1, arg2)) 
d1443 1
a1443 1
				  (LONGEST) (!tem || !value_logical_not (arg2)));
d1530 1
a1530 1
      else 
d1547 1
a1547 1
					longest_to_int (value_as_long (arg2)));
d1589 1
a1589 1
        expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
d1594 1
a1594 1
        error ("Attempt to dereference pointer to member without an object");
d1604 1
a1604 1
	      /* In C you can dereference an array to get the 1st elt.  */
d1606 1
a1606 1
	      )
d1619 1
a1619 1
      
d1626 1
a1626 1
	      int temm = longest_to_int (exp->elts[pc+3].longconst);
d1630 1
a1630 1
	    evaluate_subexp (expect_type, exp, pos, EVAL_SKIP);
d1633 14
a1646 14
      else 
        {
          value_ptr retvalp = evaluate_subexp_for_address (exp, pos, noside);
          /* If HP aCC object, use bias for pointers to members */ 
          if (hp_som_som_object_present &&
              (TYPE_CODE (VALUE_TYPE (retvalp)) == TYPE_CODE_PTR) &&
              (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (retvalp))) == TYPE_CODE_MEMBER))
            {
              unsigned int * ptr = (unsigned int *) VALUE_CONTENTS (retvalp); /* forces evaluation */
              *ptr |= 0x20000000; /* set 29th bit */
            }
          return retvalp;
        }
      
d1687 2
a1688 2
	  arg2 = value_add (arg1, value_from_longest (builtin_type_char, 
						   (LONGEST) 1));
d1702 2
a1703 2
	  arg2 = value_sub (arg1, value_from_longest (builtin_type_char, 
						   (LONGEST) 1));
d1717 2
a1718 2
	  arg2 = value_add (arg1, value_from_longest (builtin_type_char, 
						   (LONGEST) 1));
d1733 2
a1734 2
	  arg2 = value_sub (arg1, value_from_longest (builtin_type_char, 
						   (LONGEST) 1));
d1738 1
a1738 1
	
d1748 7
a1754 8
	 a lot of cases are hitting this case.  Some of these should
	 probably be removed from expression.h (e.g. do we need a BINOP_SCOPE
	 and an OP_SCOPE?); others are legitimate expressions which are
	 (apparently) not fully implemented.

	 If there are any cases landing here which mean a user error,
	 then they should be separate cases, with more descriptive
	 error messages.  */
d1760 1
a1760 1
 nosideret:
d1801 1
a1801 1
        goto default_case;
d1807 1
a1807 1
	    lookup_pointer_type (SYMBOL_TYPE (var));
d1816 2
a1817 2
	return
	  value_zero (type, not_lval);
d1822 2
a1823 2
	    (var,
	     block_innermost_frame (exp->elts[pc + 1].block));
d1851 1
a1851 1
   */
d1877 2
a1878 2
	      (var, block_innermost_frame (exp->elts[pc + 1].block));
	  return value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (SYMBOL_TYPE (var))),
d1908 3
a1910 3
	 so that we avoid creating a value for the result type.
	 If the result type is very big, it's desirable not to
	 create a value unnecessarily.  */
d1921 1
a1921 1
		      TYPE_LENGTH (type));
d1938 1
a1938 1
			      (LONGEST) TYPE_LENGTH (VALUE_TYPE (val)));
d1949 11
a1959 11
    char *tmp = (char *)alloca (length + 4);
    struct expression *expr;
    tmp[0] = '(';
    memcpy (tmp+1, p, length);
    tmp[length+1] = ')';
    tmp[length+2] = '0';
    tmp[length+3] = '\0';
    expr = parse_expression (tmp);
    if (expr->elts[0].opcode != UNOP_CAST)
	error ("Internal error in eval_type.");
    return expr->elts[1].type;
d1969 1
a1969 1
  if ((TYPE_CODE(array_type) != TYPE_CODE_ARRAY))
d1971 2
a1972 2
   
  tmp_type = array_type; 
d1979 1
a1979 1
  return ndimen; 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-06-07 snapshot
@
text
@d399 13
d424 1
a424 1
					     NULL_TYPE);
d1638 1
a1638 1
	    evaluate_subexp (NULL_TYPE, exp, pos, EVAL_SKIP);
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d5 1
a5 1
   This file is part of GDB.
d7 13
a19 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d30 2
a31 2
#include "language.h"		/* For CAST_IS_CONVERSION */
#include "f-lang.h"		/* for array bound stuff */
d33 1
a33 1
/* Defined in symtab.c */
d36 1
a36 1
/* This is defined in valops.c */
d54 2
a55 2
  evaluate_struct_tuple PARAMS ((value_ptr, struct expression *, int *,
				 enum noside, int));
d58 2
a59 2
  init_array_element PARAMS ((value_ptr, value_ptr, struct expression *,
			      int *, enum noside, LONGEST, LONGEST));
d83 2
a84 2
  register struct cleanup *old_chain =
  make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d98 1
a98 1
  struct expression *expr = parse_exp_1 (expptr, (struct block *) 0, 0);
d101 1
a101 1
  make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d115 1
a115 1
  = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d133 1
a133 1
  = make_cleanup ((make_cleanup_func) free_current_contents, &expr);
d167 1
a167 1
static char *
d201 1
a201 1
  while (--nargs >= 0)
d208 1
a208 1

d245 1
a245 1
			    {
d247 1
a247 1
				 subfieldno < TYPE_NFIELDS (substruct_type);
d320 1
a320 2
	}
      while (--nlabels > 0);
d359 1
a359 1
      for (index = low; index <= high; index++)
d391 1
a391 1
  int upper, lower, retcode;
d395 2
a396 2
  struct symbol *sym;
  struct type **arg_types;
d432 1
a432 1
	  struct symbol *sym = exp->elts[pc + 2].symbol;
d466 1
a466 1
	int regno = longest_to_int (exp->elts[pc + 1].longconst);
d478 1
a478 1
				 exp->elts[pc + 1].longconst);
d530 1
a530 1
	  for (tem = nargs; --nargs >= 0;)
d604 2
a605 2
	         different types. Also check if type of element is "compatible"
	         with element type of powerset */
d628 1
a628 1
	      for (; range_low <= range_high; range_low++)
d633 1
a633 1
		  valaddr[(unsigned) range_low / TARGET_CHAR_BIT]
d654 1
a654 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d656 1
a656 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d666 1
a666 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d668 1
a668 1
	= value_as_long (evaluate_subexp (NULL_TYPE, exp, pos, noside));
d692 1
a692 1
         called in argvec[0] and a terminating NULL */
d698 7
a704 7
	  /* 1997-08-01 Currently we do not support function invocation
	     via pointers-to-methods with HP aCC. Pointer does not point
	     to the function, but possibly to some thunk. */
	  if (hp_som_som_object_present)
	    {
	      error ("Not implemented: function invocation through pointer to method with HP aCC");
	    }
d732 1
a732 1
	  if (METHOD_PTR_IS_VIRTUAL (fnptr))
d734 1
a734 1
	      int fnoffset = METHOD_PTR_TO_VOFFSET (fnptr);
d737 1
a737 1
	      TYPE_DOMAIN_TYPE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1)));
d741 1
a741 1
		arg2 = value_cast (lookup_pointer_type (domain_type), arg2);
d785 2
a786 2
	         v.method (), this will produce an error, because v has
	         no address.
d788 10
a797 10
	         A possible way around this would be to allocate a
	         copy of the variable on the stack, copy in the
	         contents, call the function, and copy out the
	         contents.  I.e. convert this from call by reference
	         to call by copy-return (or whatever it's called).
	         However, this does not work because it is not the
	         same: the method being called could stash a copy of
	         the address, and then future uses through that address
	         (after the method returns) would be expected to
	         use the variable itself, not some copy of it.  */
d820 3
a822 3
		  /* pai: FIXME This seems to be coercing arguments before
		   * overload resolution has been done! */
		  argvec[tem] = evaluate_subexp (TYPE_FIELD_TYPE (type, tem - 1),
d843 8
a850 8
	  struct fn_field *fns_ptr;
	  int num_fns;
	  struct type *basetype;
	  int boffset;

	  /* Method invocation : stuff "this" as first parameter */
	  /* pai: this used to have lookup_pointer_type for some reason,
	   * but temp is already a pointer to the object */
d852 32
a883 33
				VALUE_ADDRESS (temp) + VALUE_OFFSET (temp));
	  /* Name of method from expression */
	  strcpy (tstr, &exp->elts[pc2 + 2].string);

	  if (overload_resolution && (exp->language_defn->la_language == language_cplus))
	    {
	      /* Language is C++, do some overload resolution before evaluation */
	      value_ptr valp = NULL;

	      /* Prepare list of argument types for overload resolution */
	      arg_types = (struct type **) xmalloc (nargs * (sizeof (struct type *)));
	      for (ix = 1; ix <= nargs; ix++)
		arg_types[ix - 1] = VALUE_TYPE (argvec[ix]);

	      (void) find_overload_match (arg_types, nargs, tstr,
				     1 /* method */ , 0 /* strict match */ ,
					  arg2 /* the object */ , NULL,
					  &valp, NULL, &static_memfuncp);


	      argvec[1] = arg2;	/* the ``this'' pointer */
	      argvec[0] = valp;	/* use the method found after overload resolution */
	    }
	  else
	    /* Non-C++ case -- or no overload resolution */
	    {
	      temp = arg2;
	      argvec[0] = value_struct_elt (&temp, argvec + 1, tstr,
					    &static_memfuncp,
					    op == STRUCTOP_STRUCT
				       ? "structure" : "structure pointer");
	      argvec[1] = arg2;	/* the ``this'' pointer */
	    }
d898 1
a898 1
	{
d901 25
a925 25
	  if (overload_resolution && (exp->language_defn->la_language == language_cplus))
	    {
	      /* Language is C++, do some overload resolution before evaluation */
	      struct symbol *symp;

	      /* Prepare list of argument types for overload resolution */
	      arg_types = (struct type **) xmalloc (nargs * (sizeof (struct type *)));
	      for (ix = 1; ix <= nargs; ix++)
		arg_types[ix - 1] = VALUE_TYPE (argvec[ix]);

	      (void) find_overload_match (arg_types, nargs, NULL /* no need for name */ ,
				 0 /* not method */ , 0 /* strict match */ ,
			      NULL, exp->elts[5].symbol /* the function */ ,
					  NULL, &symp, NULL);

	      /* Now fix the expression being evaluated */
	      exp->elts[5].symbol = symp;
	      argvec[0] = evaluate_subexp_with_coercion (exp, &save_pos1, noside);
	    }
	  else
	    {
	      /* Not C++, or no overload resolution allowed */
	      /* nothing to be done; argvec already correctly set up */
	    }
	}
d941 1
a941 1
	  TYPE_TARGET_TYPE (VALUE_TYPE (argvec[0]));
d949 1
a949 1
	error ("Cannot evaluate function -- may be inlined");
d953 1
a953 1
    case OP_F77_UNDETERMINED_ARGLIST:
d960 1
a960 1
         If it is a function, we process just as if we got an OP_FUNCALL. */
d962 1
a962 1
      nargs = longest_to_int (exp->elts[pc + 1].longconst);
d965 1
a965 1
      /* First determine the type code we are dealing with.  */
d970 1
a970 1
      switch (code)
d988 1
a988 1
	  argvec[tem] = 0;	/* signal end of arglist */
d992 1
a992 1
	  error ("Cannot perform substring on this type");
d1009 2
a1010 2
	goto nosideret;

d1013 1
a1013 1

d1018 1
a1018 1
         point numbers that compose it */
d1020 1
a1020 1
      arg2 = evaluate_subexp (NULL_TYPE, exp, pos, noside);
d1064 1
a1064 1
      /* With HP aCC, pointers to methods do not point to the function code */
d1066 4
a1069 4
	  (TYPE_CODE (VALUE_TYPE (arg2)) == TYPE_CODE_PTR) &&
      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
	error ("Pointers to methods not supported with HP aCC");	/* 1997-08-19 */

d1077 1
a1077 1
      /* With HP aCC, pointers to methods do not point to the function code */
d1079 3
a1081 3
	  (TYPE_CODE (VALUE_TYPE (arg2)) == TYPE_CODE_PTR) &&
      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg2))) == TYPE_CODE_METHOD))
	error ("Pointers to methods not supported with HP aCC");	/* 1997-08-19 */
d1085 1
a1085 1
    handle_pointer_to_member:
d1089 5
a1093 5
	{
	  if (!mem_offset)	/* no bias -> really null */
	    error ("Attempted dereference of null pointer-to-member");
	  mem_offset &= ~0x20000000;
	}
d1110 2
a1111 2
    bad_pointer_to_member:
      error ("non-pointer-to-member value used in pointer-to-member construct");
d1127 1
a1127 1
      /* Do special stuff for HP aCC pointers to members */
d1129 18
a1146 18
	{
	  /* 1997-08-19 Can't assign HP aCC pointers to methods. No details of
	     the implementation yet; but the pointer appears to point to a code
	     sequence (thunk) in memory -- in any case it is *not* the address
	     of the function as it would be in a naive implementation. */
	  if ((TYPE_CODE (VALUE_TYPE (arg1)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_METHOD))
	    error ("Assignment to pointers to methods not implemented with HP aCC");

	  /* HP aCC pointers to data members require a constant bias */
	  if ((TYPE_CODE (VALUE_TYPE (arg1)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (arg1))) == TYPE_CODE_MEMBER))
	    {
	      unsigned int *ptr = (unsigned int *) VALUE_CONTENTS (arg2);	/* forces evaluation */
	      *ptr |= 0x20000000;	/* set 29th bit */
	    }
	}

d1206 4
a1209 3
      else if (noside == EVAL_AVOID_SIDE_EFFECTS
	       && (op == BINOP_DIV || op == BINOP_REM || op == BINOP_MOD))
	return value_zero (VALUE_TYPE (arg1), not_lval);
d1228 1
a1228 1
	{
d1249 1
a1249 1
	}
d1257 1
a1257 1

d1281 3
a1283 3
	         type (like a plain int variable for example), then report this
	         as an error. */

d1297 1
a1297 1

d1310 7
a1316 7
      {
	int subscript_array[MAX_FORTRAN_DIMS + 1];	/* 1-based array of 
							   subscripts, max == 7 */
	int array_size_array[MAX_FORTRAN_DIMS + 1];
	int ndimensions = 1, i;
	struct type *tmp_type;
	int offset_item;	/* The array offset where the item lives */
d1328 1
a1328 1
	   let us actually find out where this element exists in the array. */
d1330 1
a1330 1
	offset_item = 0;
d1333 1
a1333 1
	    /* Evaluate each subscript, It must be a legal integer in F77 */
d1336 1
a1336 1
	    /* Fill in the subscript and array size arrays */
d1339 1
a1339 1

d1342 1
a1342 1
	      error ("Cannot obtain dynamic upper bound");
d1344 1
a1344 1
	    retcode = f77_get_dynamic_lowerbound (tmp_type, &lower);
d1346 1
a1346 1
	      error ("Cannot obtain dynamic lower bound");
d1349 3
a1351 3

	    /* Zero-normalize subscripts so that offsetting will work. */

d1360 1
a1360 1
	       offset to. */
d1362 2
a1363 2
	    if (i < nargs)
	      tmp_type = check_typedef (TYPE_TARGET_TYPE (tmp_type));
d1368 2
a1369 2
	offset_item = subscript_array[ndimensions];

d1371 1
a1371 1
	  offset_item =
d1376 1
a1376 1
	arg2 = value_from_longest (builtin_type_f_integer, offset_item);
d1385 1
a1385 1
	VALUE_TYPE (arg1) = tmp_type;
d1396 1
a1396 1

d1400 2
a1401 2

      if (binop_user_defined_p (op, arg1, arg2))
d1412 1
a1412 1
			     (LONGEST) (!tem && !value_logical_not (arg2)));
d1422 1
a1422 1

d1426 2
a1427 2

      if (binop_user_defined_p (op, arg1, arg2))
d1438 1
a1438 1
			     (LONGEST) (!tem || !value_logical_not (arg2)));
d1525 1
a1525 1
      else
d1542 1
a1542 1
				     longest_to_int (value_as_long (arg2)));
d1584 1
a1584 1
	expect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));
d1589 1
a1589 1
	error ("Attempt to dereference pointer to member without an object");
d1599 1
a1599 1
	  /* In C you can dereference an array to get the 1st elt.  */
d1601 1
a1601 1
	    )
d1614 1
a1614 1

d1621 1
a1621 1
	      int temm = longest_to_int (exp->elts[pc + 3].longconst);
d1628 14
a1641 14
      else
	{
	  value_ptr retvalp = evaluate_subexp_for_address (exp, pos, noside);
	  /* If HP aCC object, use bias for pointers to members */
	  if (hp_som_som_object_present &&
	      (TYPE_CODE (VALUE_TYPE (retvalp)) == TYPE_CODE_PTR) &&
	      (TYPE_CODE (TYPE_TARGET_TYPE (VALUE_TYPE (retvalp))) == TYPE_CODE_MEMBER))
	    {
	      unsigned int *ptr = (unsigned int *) VALUE_CONTENTS (retvalp);	/* forces evaluation */
	      *ptr |= 0x20000000;	/* set 29th bit */
	    }
	  return retvalp;
	}

d1682 2
a1683 2
	  arg2 = value_add (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
d1697 2
a1698 2
	  arg2 = value_sub (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
d1712 2
a1713 2
	  arg2 = value_add (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
d1728 2
a1729 2
	  arg2 = value_sub (arg1, value_from_longest (builtin_type_char,
						      (LONGEST) 1));
d1733 1
a1733 1

d1743 8
a1750 8
         a lot of cases are hitting this case.  Some of these should
         probably be removed from expression.h (e.g. do we need a BINOP_SCOPE
         and an OP_SCOPE?); others are legitimate expressions which are
         (apparently) not fully implemented.

         If there are any cases landing here which mean a user error,
         then they should be separate cases, with more descriptive
         error messages.  */
d1756 1
a1756 1
nosideret:
d1797 1
a1797 1
	goto default_case;
d1803 1
a1803 1
	  lookup_pointer_type (SYMBOL_TYPE (var));
d1812 2
a1813 2
	  return
	    value_zero (type, not_lval);
d1818 2
a1819 2
	  (var,
	   block_innermost_frame (exp->elts[pc + 1].block));
d1847 1
a1847 1
 */
d1873 1
a1873 1
	    (var, block_innermost_frame (exp->elts[pc + 1].block));
d1904 3
a1906 3
         so that we avoid creating a value for the result type.
         If the result type is very big, it's desirable not to
         create a value unnecessarily.  */
d1917 1
a1917 1
				 TYPE_LENGTH (type));
d1934 1
a1934 1
				 (LONGEST) TYPE_LENGTH (VALUE_TYPE (val)));
d1945 11
a1955 11
  char *tmp = (char *) alloca (length + 4);
  struct expression *expr;
  tmp[0] = '(';
  memcpy (tmp + 1, p, length);
  tmp[length + 1] = ')';
  tmp[length + 2] = '0';
  tmp[length + 3] = '\0';
  expr = parse_expression (tmp);
  if (expr->elts[0].opcode != UNOP_CAST)
    error ("Internal error in eval_type.");
  return expr->elts[1].type;
d1965 1
a1965 1
  if ((TYPE_CODE (array_type) != TYPE_CODE_ARRAY))
d1967 2
a1968 2

  tmp_type = array_type;
d1975 1
a1975 1
  return ndimen;
@


1.1.1.4
log
@import gdb-1999-09-08 snapshot
@
text
@d397 1
d845 4
@


1.1.1.5
log
@import gdb-1999-10-11 snapshot
@
text
@d1741 3
a1743 2
         probably be removed from expression.h; others are legitimate
         expressions which are (apparently) not fully implemented.
@


1.1.1.6
log
@import gdb-1999-10-18 snapshot
@
text
@d895 1
a895 1
      else if (op == OP_VAR_VALUE)
a897 3
          /* fn: This can only be done for C++ functions.  A C-style function
             in a C++ program, for instance, does not have the fields that 
             are expected here */
d911 1
a911 1
		      NULL, exp->elts[save_pos1+2].symbol /* the function */ ,
d915 1
a915 1
	      exp->elts[save_pos1+2].symbol = symp;
a922 5
	}
      else
	{
	  /* It is probably a C-style function */
	  /* nothing to be done; argvec already correctly set up */
@


1.1.1.7
log
@import gdb-1999-12-13 snapshot
@
text
@d62 1
a62 1
#if defined (__GNUC__) && !__STDC__
@


