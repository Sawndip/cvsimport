head	1.162;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.162
	gdb_7_6-2013-04-26-release:1.162
	gdb_7_6-branch:1.162.0.2
	gdb_7_6-2013-03-12-branchpoint:1.162
	gdb_7_5_1-2012-11-29-release:1.158
	gdb_7_5-2012-08-17-release:1.158
	gdb_7_5-branch:1.158.0.2
	gdb_7_5-2012-07-18-branchpoint:1.158
	gdb_7_4_1-2012-04-26-release:1.154.4.1
	gdb_7_4-2012-01-24-release:1.154.4.1
	gdb_7_4-branch:1.154.0.4
	gdb_7_4-2011-12-13-branchpoint:1.154
	gdb_7_3_1-2011-09-04-release:1.154
	gdb_7_3-2011-07-26-release:1.154
	gdb_7_3-branch:1.154.0.2
	gdb_7_3-2011-04-01-branchpoint:1.154
	gdb_7_2-2010-09-02-release:1.150
	gdb_7_2-branch:1.150.0.4
	gdb_7_2-2010-07-07-branchpoint:1.150
	gdb_7_1-2010-03-18-release:1.150
	gdb_7_1-branch:1.150.0.2
	gdb_7_1-2010-02-18-branchpoint:1.150
	gdb_7_0_1-2009-12-22-release:1.145
	gdb_7_0-2009-10-06-release:1.145
	gdb_7_0-branch:1.145.0.2
	gdb_7_0-2009-09-16-branchpoint:1.145
	arc-sim-20090309:1.133
	msnyder-checkpoint-072509-branch:1.144.0.2
	msnyder-checkpoint-072509-branchpoint:1.144
	arc-insight_6_8-branch:1.133.0.6
	arc-insight_6_8-branchpoint:1.133
	insight_6_8-branch:1.133.0.4
	insight_6_8-branchpoint:1.133
	reverse-20081226-branch:1.138.0.6
	reverse-20081226-branchpoint:1.138
	multiprocess-20081120-branch:1.138.0.4
	multiprocess-20081120-branchpoint:1.138
	reverse-20080930-branch:1.138.0.2
	reverse-20080930-branchpoint:1.138
	reverse-20080717-branch:1.137.0.4
	reverse-20080717-branchpoint:1.137
	msnyder-reverse-20080609-branch:1.137.0.2
	msnyder-reverse-20080609-branchpoint:1.137
	drow-reverse-20070409-branch:1.112.0.2
	drow-reverse-20070409-branchpoint:1.112
	gdb_6_8-2008-03-27-release:1.133
	gdb_6_8-branch:1.133.0.2
	gdb_6_8-2008-02-26-branchpoint:1.133
	gdb_6_7_1-2007-10-29-release:1.123
	gdb_6_7-2007-10-10-release:1.123
	gdb_6_7-branch:1.123.0.2
	gdb_6_7-2007-09-07-branchpoint:1.123
	insight_6_6-20070208-release:1.108
	gdb_6_6-2006-12-18-release:1.108
	gdb_6_6-branch:1.108.0.2
	gdb_6_6-2006-11-15-branchpoint:1.108
	insight_6_5-20061003-release:1.105
	gdb-csl-symbian-6_4_50_20060226-12:1.105.2.2
	gdb-csl-sourcerygxx-3_4_4-25:1.104
	nickrob-async-20060828-mergepoint:1.107
	gdb-csl-symbian-6_4_50_20060226-11:1.105.2.2
	gdb-csl-sourcerygxx-4_1-17:1.105.2.8
	gdb-csl-20060226-branch-local-2:1.105.2.8
	gdb-csl-sourcerygxx-4_1-14:1.105.2.8
	gdb-csl-sourcerygxx-4_1-13:1.105.2.8
	gdb-csl-sourcerygxx-4_1-12:1.105.2.8
	gdb-csl-sourcerygxx-3_4_4-21:1.105.2.8
	gdb_6_5-20060621-release:1.105
	gdb-csl-sourcerygxx-4_1-9:1.105.2.8
	gdb-csl-sourcerygxx-4_1-8:1.105.2.7
	gdb-csl-sourcerygxx-4_1-7:1.105.2.6
	gdb-csl-arm-2006q1-6:1.105.2.5
	gdb-csl-sourcerygxx-4_1-6:1.105.2.5
	gdb-csl-symbian-6_4_50_20060226-10:1.105.2.2
	gdb-csl-symbian-6_4_50_20060226-9:1.105.2.2
	gdb-csl-symbian-6_4_50_20060226-8:1.105.2.2
	gdb-csl-coldfire-4_1-11:1.105.2.2
	gdb-csl-sourcerygxx-3_4_4-19:1.105.2.2
	gdb-csl-coldfire-4_1-10:1.105.2.2
	gdb_6_5-branch:1.105.0.14
	gdb_6_5-2006-05-14-branchpoint:1.105
	gdb-csl-sourcerygxx-4_1-5:1.105.2.2
	nickrob-async-20060513-branch:1.105.0.12
	nickrob-async-20060513-branchpoint:1.105
	gdb-csl-sourcerygxx-4_1-4:1.105.2.2
	msnyder-reverse-20060502-branch:1.105.0.10
	msnyder-reverse-20060502-branchpoint:1.105
	gdb-csl-morpho-4_1-4:1.105.2.2
	gdb-csl-sourcerygxx-3_4_4-17:1.105.2.2
	readline_5_1-import-branch:1.105.0.8
	readline_5_1-import-branchpoint:1.105
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.105.2.2
	gdb-csl-symbian-20060226-branch:1.105.2.2.0.2
	gdb-csl-symbian-20060226-branchpoint:1.105.2.2
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.105.2.2
	msnyder-reverse-20060331-branch:1.105.0.6
	msnyder-reverse-20060331-branchpoint:1.105
	gdb-csl-available-20060303-branch:1.105.0.4
	gdb-csl-available-20060303-branchpoint:1.105
	gdb-csl-20060226-branch:1.105.0.2
	gdb-csl-20060226-branchpoint:1.105
	gdb_6_4-20051202-release:1.104
	msnyder-fork-checkpoint-branch:1.104.0.8
	msnyder-fork-checkpoint-branchpoint:1.104
	gdb-csl-gxxpro-6_3-branch:1.104.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.104
	gdb_6_4-branch:1.104.0.4
	gdb_6_4-2005-11-01-branchpoint:1.104
	gdb-csl-arm-20051020-branch:1.104.0.2
	gdb-csl-arm-20051020-branchpoint:1.104
	msnyder-tracepoint-checkpoint-branch:1.101.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.101
	gdb-csl-arm-20050325-2005-q1b:1.100
	gdb-csl-arm-20050325-2005-q1a:1.100
	csl-arm-20050325-branch:1.100.0.2
	csl-arm-20050325-branchpoint:1.100
	gdb-post-i18n-errorwarning-20050211:1.99
	gdb-pre-i18n-errorwarning-20050211:1.98
	gdb_6_3-20041109-release:1.95
	gdb_6_3-branch:1.95.0.2
	gdb_6_3-20041019-branchpoint:1.95
	drow_intercu-merge-20040921:1.95
	drow_intercu-merge-20040915:1.95
	jimb-gdb_6_2-e500-branch:1.92.0.6
	jimb-gdb_6_2-e500-branchpoint:1.92
	gdb_6_2-20040730-release:1.92
	gdb_6_2-branch:1.92.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.92
	gdb_6_1_1-20040616-release:1.80
	gdb_6_1-2004-04-05-release:1.80
	drow_intercu-merge-20040402:1.81
	drow_intercu-merge-20040327:1.81
	ezannoni_pie-20040323-branch:1.81.0.2
	ezannoni_pie-20040323-branchpoint:1.81
	cagney_tramp-20040321-mergepoint:1.80
	cagney_tramp-20040309-branch:1.80.0.6
	cagney_tramp-20040309-branchpoint:1.80
	gdb_6_1-branch:1.80.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.80
	drow_intercu-20040221-branch:1.80.0.2
	drow_intercu-20040221-branchpoint:1.80
	cagney_bfdfile-20040213-branch:1.79.0.2
	cagney_bfdfile-20040213-branchpoint:1.79
	drow-cplus-merge-20040208:1.79
	carlton_dictionary-20040126-merge:1.77
	cagney_bigcore-20040122-branch:1.77.0.2
	cagney_bigcore-20040122-branchpoint:1.77
	drow-cplus-merge-20040113:1.75
	drow-cplus-merge-20031224:1.75
	drow-cplus-merge-20031220:1.75
	carlton_dictionary-20031215-merge:1.75
	drow-cplus-merge-20031214:1.75
	carlton-dictionary-20031111-merge:1.75
	gdb_6_0-2003-10-04-release:1.69.4.2
	kettenis_sparc-20030918-branch:1.74.0.4
	kettenis_sparc-20030918-branchpoint:1.74
	carlton_dictionary-20030917-merge:1.74
	ezannoni_pie-20030916-branchpoint:1.74
	ezannoni_pie-20030916-branch:1.74.0.2
	cagney_x86i386-20030821-branch:1.72.0.2
	cagney_x86i386-20030821-branchpoint:1.72
	carlton_dictionary-20030805-merge:1.72
	carlton_dictionary-20030627-merge:1.69
	gdb_6_0-branch:1.69.0.4
	gdb_6_0-2003-06-23-branchpoint:1.69
	jimb-ppc64-linux-20030613-branch:1.69.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.69
	cagney_convert-20030606-branch:1.65.0.2
	cagney_convert-20030606-branchpoint:1.65
	cagney_writestrings-20030508-branch:1.59.0.4
	cagney_writestrings-20030508-branchpoint:1.59
	jimb-ppc64-linux-20030528-branch:1.63.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.63
	carlton_dictionary-20030523-merge:1.61
	cagney_fileio-20030521-branch:1.61.0.2
	cagney_fileio-20030521-branchpoint:1.61
	kettenis_i386newframe-20030517-mergepoint:1.60
	jimb-ppc64-linux-20030509-branch:1.59.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.59
	kettenis_i386newframe-20030504-mergepoint:1.58
	carlton_dictionary-20030430-merge:1.58
	kettenis_i386newframe-20030419-branch:1.56.0.2
	kettenis_i386newframe-20030419-branchpoint:1.56
	carlton_dictionary-20030416-merge:1.56
	cagney_frameaddr-20030409-mergepoint:1.55
	kettenis_i386newframe-20030406-branch:1.55.0.2
	kettenis_i386newframe-20030406-branchpoint:1.55
	cagney_frameaddr-20030403-branchpoint:1.54
	cagney_frameaddr-20030403-branch:1.54.0.2
	cagney_framebase-20030330-mergepoint:1.52
	cagney_framebase-20030326-branch:1.51.0.2
	cagney_framebase-20030326-branchpoint:1.51
	cagney_lazyid-20030317-branch:1.47.0.2
	cagney_lazyid-20030317-branchpoint:1.47
	kettenis-i386newframe-20030316-mergepoint:1.47
	offbyone-20030313-branch:1.46.0.2
	offbyone-20030313-branchpoint:1.46
	kettenis-i386newframe-20030308-branch:1.45.0.4
	kettenis-i386newframe-20030308-branchpoint:1.45
	carlton_dictionary-20030305-merge:1.45
	cagney_offbyone-20030303-branch:1.45.0.2
	cagney_offbyone-20030303-branchpoint:1.45
	carlton_dictionary-20030207-merge:1.42
	interps-20030203-mergepoint:1.42
	interps-20030202-branch:1.42.0.4
	interps-20030202-branchpoint:1.42
	cagney-unwind-20030108-branch:1.42.0.2
	cagney-unwind-20030108-branchpoint:1.42
	carlton_dictionary-20021223-merge:1.37
	gdb_5_3-2002-12-12-release:1.24
	carlton_dictionary-20021115-merge:1.26
	kseitz_interps-20021105-merge:1.24
	kseitz_interps-20021103-merge:1.24
	drow-cplus-merge-20021020:1.24
	drow-cplus-merge-20021025:1.24
	carlton_dictionary-20021025-merge:1.24
	carlton_dictionary-20021011-merge:1.24
	drow-cplus-branch:1.24.0.10
	drow-cplus-branchpoint:1.24
	kseitz_interps-20020930-merge:1.24
	carlton_dictionary-20020927-merge:1.24
	carlton_dictionary-branch:1.24.0.8
	carlton_dictionary-20020920-branchpoint:1.24
	gdb_5_3-branch:1.24.0.6
	gdb_5_3-2002-09-04-branchpoint:1.24
	kseitz_interps-20020829-merge:1.24
	cagney_sysregs-20020825-branch:1.24.0.4
	cagney_sysregs-20020825-branchpoint:1.24
	readline_4_3-import-branch:1.24.0.2
	readline_4_3-import-branchpoint:1.24
	gdb_5_2_1-2002-07-23-release:1.14
	kseitz_interps-20020528-branch:1.14.0.8
	kseitz_interps-20020528-branchpoint:1.14
	cagney_regbuf-20020515-branch:1.14.0.6
	cagney_regbuf-20020515-branchpoint:1.14
	jimb-macro-020506-branch:1.14.0.4
	jimb-macro-020506-branchpoint:1.14
	gdb_5_2-2002-04-29-release:1.14
	gdb_5_2-branch:1.14.0.2
	gdb_5_2-2002-03-03-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.8
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.6
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.4
	gdb_5_1-2001-07-29-branchpoint:1.13
	dberlin-typesystem-branch:1.13.0.2
	dberlin-typesystem-branchpoint:1.13
	gdb-post-ptid_t-2001-05-03:1.13
	gdb-pre-ptid_t-2001-05-03:1.13
	insight-precleanup-2001-01-01:1.9
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.3.2.1
	gdb_4_18_2-2000-05-18-release:1.3.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.3.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.3
	gdb_5_0-2000-04-10-branch:1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.3
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.5
	gdb-1999-09-08:1.1.1.5
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.4
	gdb-1999-06-28:1.1.1.4
	gdb-1999-06-21:1.1.1.4
	gdb-1999-06-14:1.1.1.4
	gdb-1999-06-07:1.1.1.4
	gdb-1999-06-01:1.1.1.4
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.4
	gdb-1999-05-19:1.1.1.3
	gdb-1999-05-10:1.1.1.3
	gdb-19990504:1.1.1.3
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.162
date	2013.01.01.06.32.46;	author brobecke;	state Exp;
branches;
next	1.161;

1.161
date	2012.11.02.18.53.54;	author tromey;	state Exp;
branches;
next	1.160;

1.160
date	2012.09.17.08.52.18;	author siddhesh;	state Exp;
branches;
next	1.159;

1.159
date	2012.07.24.16.37.24;	author schwab;	state Exp;
branches;
next	1.158;

1.158
date	2012.06.08.14.24.57;	author qiyao;	state Exp;
branches;
next	1.157;

1.157
date	2012.05.18.21.02.49;	author sergiodj;	state Exp;
branches;
next	1.156;

1.156
date	2012.05.16.14.35.06;	author macro;	state Exp;
branches;
next	1.155;

1.155
date	2012.01.04.08.17.05;	author brobecke;	state Exp;
branches;
next	1.154;

1.154
date	2011.03.18.18.52.31;	author palves;	state Exp;
branches
	1.154.4.1;
next	1.153;

1.153
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.152;

1.152
date	2011.01.09.03.20.33;	author msnyder;	state Exp;
branches;
next	1.151;

1.151
date	2011.01.01.15.33.10;	author brobecke;	state Exp;
branches;
next	1.150;

1.150
date	2010.01.01.07.31.37;	author brobecke;	state Exp;
branches;
next	1.149;

1.149
date	2009.11.17.17.59.42;	author mkuvyrkov;	state Exp;
branches;
next	1.148;

1.148
date	2009.11.17.17.56.11;	author mkuvyrkov;	state Exp;
branches;
next	1.147;

1.147
date	2009.11.06.19.26.18;	author vprus;	state Exp;
branches;
next	1.146;

1.146
date	2009.11.06.17.22.33;	author vprus;	state Exp;
branches;
next	1.145;

1.145
date	2009.09.07.17.52.41;	author jkratoch;	state Exp;
branches;
next	1.144;

1.144
date	2009.07.02.17.25.55;	author uweigand;	state Exp;
branches;
next	1.143;

1.143
date	2009.07.02.12.55.30;	author uweigand;	state Exp;
branches;
next	1.142;

1.142
date	2009.07.02.12.52.52;	author uweigand;	state Exp;
branches;
next	1.141;

1.141
date	2009.07.02.12.48.54;	author uweigand;	state Exp;
branches;
next	1.140;

1.140
date	2009.07.02.12.46.19;	author uweigand;	state Exp;
branches;
next	1.139;

1.139
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.138;

1.138
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.137;

1.137
date	2008.06.02.16.05.57;	author brobecke;	state Exp;
branches;
next	1.136;

1.136
date	2008.05.16.00.27.23;	author drow;	state Exp;
branches;
next	1.135;

1.135
date	2008.05.05.20.47.02;	author schwab;	state Exp;
branches;
next	1.134;

1.134
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2008.01.11.14.43.14;	author deuling;	state Exp;
branches;
next	1.132;

1.132
date	2008.01.11.13.20.01;	author deuling;	state Exp;
branches;
next	1.131;

1.131
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.130;

1.130
date	2007.12.06.16.33.00;	author deuling;	state Exp;
branches;
next	1.129;

1.129
date	2007.11.09.05.32.19;	author deuling;	state Exp;
branches;
next	1.128;

1.128
date	2007.11.07.06.33.00;	author deuling;	state Exp;
branches;
next	1.127;

1.127
date	2007.11.02.14.27.14;	author uweigand;	state Exp;
branches;
next	1.126;

1.126
date	2007.10.24.20.29.14;	author drow;	state Exp;
branches;
next	1.125;

1.125
date	2007.10.15.19.45.30;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2007.10.08.12.54.07;	author uweigand;	state Exp;
branches;
next	1.123;

1.123
date	2007.08.23.18.08.35;	author brobecke;	state Exp;
branches;
next	1.122;

1.122
date	2007.06.30.17.15.15;	author schwab;	state Exp;
branches;
next	1.121;

1.121
date	2007.06.30.15.35.19;	author schwab;	state Exp;
branches;
next	1.120;

1.120
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.119;

1.119
date	2007.06.15.22.41.13;	author uweigand;	state Exp;
branches;
next	1.118;

1.118
date	2007.06.15.20.19.17;	author vprus;	state Exp;
branches;
next	1.117;

1.117
date	2007.06.13.17.30.01;	author uweigand;	state Exp;
branches;
next	1.116;

1.116
date	2007.06.07.05.00.42;	author vprus;	state Exp;
branches;
next	1.115;

1.115
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.114;

1.114
date	2007.04.29.19.44.22;	author uweigand;	state Exp;
branches;
next	1.113;

1.113
date	2007.04.12.23.03.00;	author uweigand;	state Exp;
branches;
next	1.112;

1.112
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.111;

1.111
date	2007.02.16.21.49.59;	author drow;	state Exp;
branches;
next	1.110;

1.110
date	2007.01.29.17.31.06;	author drow;	state Exp;
branches;
next	1.109;

1.109
date	2007.01.09.17.58.52;	author drow;	state Exp;
branches;
next	1.108;

1.108
date	2006.09.09.23.07.32;	author schwab;	state Exp;
branches;
next	1.107;

1.107
date	2006.07.13.09.30.46;	author nathan;	state Exp;
branches;
next	1.106;

1.106
date	2006.06.08.19.11.45;	author nathan;	state Exp;
branches;
next	1.105;

1.105
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches
	1.105.2.1
	1.105.12.1;
next	1.104;

1.104
date	2005.08.31.20.48.21;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2005.08.17.18.34.17;	author kettenis;	state Exp;
branches;
next	1.102;

1.102
date	2005.06.12.13.37.39;	author kettenis;	state Exp;
branches;
next	1.101;

1.101
date	2005.05.14.13.14.00;	author kettenis;	state Exp;
branches;
next	1.100;

1.100
date	2005.02.11.18.13.51;	author cagney;	state Exp;
branches;
next	1.99;

1.99
date	2005.02.11.04.05.56;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2005.02.02.21.36.14;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2005.02.02.20.31.33;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2004.10.29.14.00.56;	author cagney;	state Exp;
branches;
next	1.95;

1.95
date	2004.09.02.19.16.36;	author cagney;	state Exp;
branches;
next	1.94;

1.94
date	2004.07.24.01.00.19;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.07.02.02.51;	author tausq;	state Exp;
branches;
next	1.91;

1.91
date	2004.05.16.23.04.15;	author kettenis;	state Exp;
branches;
next	1.90;

1.90
date	2004.05.09.18.51.38;	author kettenis;	state Exp;
branches;
next	1.89;

1.89
date	2004.05.08.16.10.07;	author kettenis;	state Exp;
branches;
next	1.88;

1.88
date	2004.05.08.15.52.15;	author kettenis;	state Exp;
branches;
next	1.87;

1.87
date	2004.05.05.15.42.52;	author cagney;	state Exp;
branches;
next	1.86;

1.86
date	2004.05.04.20.04.58;	author msnyder;	state Exp;
branches;
next	1.85;

1.85
date	2004.05.03.21.56.09;	author kettenis;	state Exp;
branches;
next	1.84;

1.84
date	2004.05.01.15.10.15;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.30.21.47.07;	author kettenis;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.18.13.03.13;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2004.03.23.14.47.56;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches
	1.80.2.1;
next	1.79;

1.79
date	2004.02.05.01.16.38;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.26.20.52.11;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.19.01.20.11;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.13.21.38.46;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2003.09.25.09.10.30;	author schwab;	state Exp;
branches;
next	1.74;

1.74
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2003.09.09.04.41.32;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.16.22.29.13;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.09.21.36.08;	author schwab;	state Exp;
branches;
next	1.70;

1.70
date	2003.07.07.15.03.58;	author schwab;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.13.04.40.32;	author cagney;	state Exp;
branches
	1.69.4.1;
next	1.68;

1.68
date	2003.06.11.13.16.27;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.09.17.35.57;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.07.22.38.55;	author cagney;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.02.22.56.52;	author schwab;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.02.02.09.39;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2003.05.25.21.15.20;	author schwab;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.25.18.50.54;	author schwab;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.20.23.44.23;	author schwab;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.17.05.59.58;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.28.16.17.28;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.11.18.15.38;	author cagney;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2003.04.01.14.38.50;	author cagney;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2003.03.31.19.01.20;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2003.03.30.14.59.00;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.25.22.56.40;	author cagney;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2003.03.25.18.54.15;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.13.21.45.40;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.12.16.50.44;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.03.20.50.19;	author cagney;	state Exp;
branches
	1.45.4.1;
next	1.44;

1.44
date	2003.03.02.04.02.24;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.08.15.56.37;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2003.01.05.01.39.54;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2003.01.03.23.53.48;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.29.19.33.17;	author schwab;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.28.21.38.43;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.26.19.01.29;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.23.19.45.11;	author schwab;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.23.01.39.25;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.22.23.59.20;	author schwab;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.22.00.02.03;	author schwab;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.18.22.19.28;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.14.20.37.28;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.24.00.21.34;	author cagney;	state Exp;
branches
	1.24.8.1
	1.24.10.1;
next	1.23;

1.23
date	2002.07.11.13.50.49;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.02.18.13.51;	author graces;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.26.17.09.29;	author graces;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.24.17.48.42;	author graces;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.21.20.23.24;	author graces;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.21.15.47.35;	author graces;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.21.14.56.15;	author graces;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.19.20.44.13;	author graces;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.17.21.39.01;	author graces;	state Exp;
branches;
next	1.14;

1.14
date	2001.12.01.23.06.46;	author cagney;	state Exp;
branches
	1.14.6.1
	1.14.8.1;
next	1.13;

1.13
date	2001.04.17.21.20.48;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.06.08.21.09;	author kevinb;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.08.12.26.15;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.08.11.55.34;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.09.20.09.01;	author msnyder;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.26.23.22.40;	author msnyder;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.28.05.50.19;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.24.17.55.13;	author phdm;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.03.24.11.12.11;	author phdm;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.154.4.1
date	2012.01.06.04.43.19;	author brobecke;	state Exp;
branches;
next	;

1.105.2.1
date	2006.03.29.07.40.35;	author nathan;	state Exp;
branches;
next	1.105.2.2;

1.105.2.2
date	2006.03.31.16.21.03;	author nathan;	state Exp;
branches;
next	1.105.2.3;

1.105.2.3
date	2006.06.05.14.51.35;	author nathan;	state Exp;
branches;
next	1.105.2.4;

1.105.2.4
date	2006.06.05.15.00.39;	author nathan;	state Exp;
branches;
next	1.105.2.5;

1.105.2.5
date	2006.06.05.15.11.01;	author nathan;	state Exp;
branches;
next	1.105.2.6;

1.105.2.6
date	2006.06.08.07.23.04;	author nathan;	state Exp;
branches;
next	1.105.2.7;

1.105.2.7
date	2006.06.09.12.12.03;	author nathan;	state Exp;
branches;
next	1.105.2.8;

1.105.2.8
date	2006.06.12.08.01.53;	author nathan;	state Exp;
branches;
next	;

1.105.12.1
date	2006.08.28.07.48.48;	author nickrob;	state Exp;
branches;
next	;

1.80.2.1
date	2004.03.27.17.37.50;	author drow;	state Exp;
branches;
next	1.80.2.2;

1.80.2.2
date	2004.09.16.17.01.12;	author drow;	state Exp;
branches;
next	;

1.69.4.1
date	2003.07.07.15.07.23;	author schwab;	state Exp;
branches;
next	1.69.4.2;

1.69.4.2
date	2003.07.09.21.37.13;	author schwab;	state Exp;
branches;
next	;

1.56.2.1
date	2003.05.04.11.37.44;	author kettenis;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2003.05.18.09.44.16;	author kettenis;	state Exp;
branches;
next	;

1.54.2.1
date	2003.04.10.21.33.49;	author cagney;	state Exp;
branches;
next	;

1.51.2.1
date	2003.03.30.16.35.21;	author cagney;	state Exp;
branches;
next	;

1.45.4.1
date	2003.03.16.14.01.49;	author kettenis;	state Exp;
branches;
next	;

1.24.8.1
date	2002.11.15.19.18.50;	author carlton;	state Exp;
branches;
next	1.24.8.2;

1.24.8.2
date	2002.12.23.19.38.33;	author carlton;	state Exp;
branches;
next	1.24.8.3;

1.24.8.3
date	2003.02.07.19.17.50;	author carlton;	state Exp;
branches;
next	1.24.8.4;

1.24.8.4
date	2003.03.06.00.56.30;	author carlton;	state Exp;
branches;
next	1.24.8.5;

1.24.8.5
date	2003.04.16.19.56.53;	author carlton;	state Exp;
branches;
next	1.24.8.6;

1.24.8.6
date	2003.05.01.00.46.51;	author carlton;	state Exp;
branches;
next	1.24.8.7;

1.24.8.7
date	2003.05.23.18.40.41;	author carlton;	state Exp;
branches;
next	1.24.8.8;

1.24.8.8
date	2003.06.27.21.50.05;	author carlton;	state Exp;
branches;
next	1.24.8.9;

1.24.8.9
date	2003.08.05.17.13.11;	author carlton;	state Exp;
branches;
next	1.24.8.10;

1.24.8.10
date	2003.09.17.21.28.25;	author carlton;	state Exp;
branches;
next	1.24.8.11;

1.24.8.11
date	2003.11.11.23.50.49;	author carlton;	state Exp;
branches;
next	1.24.8.12;

1.24.8.12
date	2004.01.26.19.11.27;	author carlton;	state Exp;
branches;
next	;

1.24.10.1
date	2003.12.14.20.27.20;	author drow;	state Exp;
branches;
next	1.24.10.2;

1.24.10.2
date	2004.02.09.19.43.43;	author drow;	state Exp;
branches;
next	;

1.14.6.1
date	2002.06.21.16.19.27;	author cagney;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2002.06.21.16.46.52;	author cagney;	state Exp;
branches;
next	1.14.6.3;

1.14.6.3
date	2002.06.25.20.02.41;	author cagney;	state Exp;
branches;
next	1.14.6.4;

1.14.6.4
date	2002.06.28.23.19.25;	author cagney;	state Exp;
branches;
next	1.14.6.5;

1.14.6.5
date	2002.07.03.18.43.57;	author cagney;	state Exp;
branches;
next	;

1.14.8.1
date	2002.06.20.01.32.38;	author kseitz;	state Exp;
branches;
next	1.14.8.2;

1.14.8.2
date	2002.07.22.21.47.00;	author kseitz;	state Exp;
branches;
next	1.14.8.3;

1.14.8.3
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	;

1.3.2.1
date	2000.04.28.05.48.25;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.43;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.05.14.42.40;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.05.25.18.02.34;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.07.48;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.10.05.23.08.28;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.162
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Target-dependent code for the Motorola 68000 series.

   Copyright (C) 1990-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "dwarf2-frame.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "gdbtypes.h"
#include "symtab.h"
#include "gdbcore.h"
#include "value.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "inferior.h"
#include "regcache.h"
#include "arch-utils.h"
#include "osabi.h"
#include "dis-asm.h"
#include "target-descriptions.h"

#include "m68k-tdep.h"


#define P_LINKL_FP	0x480e
#define P_LINKW_FP	0x4e56
#define P_PEA_FP	0x4856
#define P_MOVEAL_SP_FP	0x2c4f
#define P_ADDAW_SP	0xdefc
#define P_ADDAL_SP	0xdffc
#define P_SUBQW_SP	0x514f
#define P_SUBQL_SP	0x518f
#define P_LEA_SP_SP	0x4fef
#define P_LEA_PC_A5	0x4bfb0170
#define P_FMOVEMX_SP	0xf227
#define P_MOVEL_SP	0x2f00
#define P_MOVEML_SP	0x48e7

/* Offset from SP to first arg on stack at first instruction of a function.  */
#define SP_ARG0 (1 * 4)

#if !defined (BPT_VECTOR)
#define BPT_VECTOR 0xf
#endif

static const gdb_byte *
m68k_local_breakpoint_from_pc (struct gdbarch *gdbarch,
			       CORE_ADDR *pcptr, int *lenptr)
{
  static gdb_byte break_insn[] = {0x4e, (0x40 | BPT_VECTOR)};
  *lenptr = sizeof (break_insn);
  return break_insn;
}


/* Construct types for ISA-specific registers.  */
static struct type *
m68k_ps_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->m68k_ps_type)
    {
      struct type *type;

      type = arch_flags_type (gdbarch, "builtin_type_m68k_ps", 4);
      append_flags_type_flag (type, 0, "C");
      append_flags_type_flag (type, 1, "V");
      append_flags_type_flag (type, 2, "Z");
      append_flags_type_flag (type, 3, "N");
      append_flags_type_flag (type, 4, "X");
      append_flags_type_flag (type, 8, "I0");
      append_flags_type_flag (type, 9, "I1");
      append_flags_type_flag (type, 10, "I2");
      append_flags_type_flag (type, 12, "M");
      append_flags_type_flag (type, 13, "S");
      append_flags_type_flag (type, 14, "T0");
      append_flags_type_flag (type, 15, "T1");

      tdep->m68k_ps_type = type;
    }

  return tdep->m68k_ps_type;
}

static struct type *
m68881_ext_type (struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (!tdep->m68881_ext_type)
    tdep->m68881_ext_type
      = arch_float_type (gdbarch, -1, "builtin_type_m68881_ext",
			 floatformats_m68881_ext);

  return tdep->m68881_ext_type;
}

/* Return the GDB type object for the "standard" data type of data in
   register N.  This should be int for D0-D7, SR, FPCONTROL and
   FPSTATUS, long double for FP0-FP7, and void pointer for all others
   (A0-A7, PC, FPIADDR).  Note, for registers which contain
   addresses return pointer to void, not pointer to char, because we
   don't want to attempt to print the string after printing the
   address.  */

static struct type *
m68k_register_type (struct gdbarch *gdbarch, int regnum)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->fpregs_present)
    {
      if (regnum >= gdbarch_fp0_regnum (gdbarch)
	  && regnum <= gdbarch_fp0_regnum (gdbarch) + 7)
	{
	  if (tdep->flavour == m68k_coldfire_flavour)
	    return builtin_type (gdbarch)->builtin_double;
	  else
	    return m68881_ext_type (gdbarch);
	}

      if (regnum == M68K_FPI_REGNUM)
	return builtin_type (gdbarch)->builtin_func_ptr;

      if (regnum == M68K_FPC_REGNUM || regnum == M68K_FPS_REGNUM)
	return builtin_type (gdbarch)->builtin_int32;
    }
  else
    {
      if (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FPI_REGNUM)
	return builtin_type (gdbarch)->builtin_int0;
    }

  if (regnum == gdbarch_pc_regnum (gdbarch))
    return builtin_type (gdbarch)->builtin_func_ptr;

  if (regnum >= M68K_A0_REGNUM && regnum <= M68K_A0_REGNUM + 7)
    return builtin_type (gdbarch)->builtin_data_ptr;

  if (regnum == M68K_PS_REGNUM)
    return m68k_ps_type (gdbarch);

  return builtin_type (gdbarch)->builtin_int32;
}

static const char *m68k_register_names[] = {
    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
    "a0", "a1", "a2", "a3", "a4", "a5", "fp", "sp",
    "ps", "pc",
    "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7",
    "fpcontrol", "fpstatus", "fpiaddr"
  };

/* Function: m68k_register_name
   Returns the name of the standard m68k register regnum.  */

static const char *
m68k_register_name (struct gdbarch *gdbarch, int regnum)
{
  if (regnum < 0 || regnum >= ARRAY_SIZE (m68k_register_names))
    internal_error (__FILE__, __LINE__,
		    _("m68k_register_name: illegal register number %d"),
		    regnum);
  else if (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FPI_REGNUM
	   && gdbarch_tdep (gdbarch)->fpregs_present == 0)
    return "";
  else
    return m68k_register_names[regnum];
}

/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
m68k_convert_register_p (struct gdbarch *gdbarch,
			 int regnum, struct type *type)
{
  if (!gdbarch_tdep (gdbarch)->fpregs_present)
    return 0;
  return (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FP0_REGNUM + 7
	  && type != register_type (gdbarch, M68K_FP0_REGNUM));
}

/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */

static int
m68k_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, gdb_byte *to,
			int *optimizedp, int *unavailablep)
{
  gdb_byte from[M68K_MAX_REGISTER_SIZE];
  struct type *fpreg_type = register_type (get_frame_arch (frame),
					   M68K_FP0_REGNUM);

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning (_("Cannot convert floating-point register value "
	       "to non-floating-point type."));
      *optimizedp = *unavailablep = 0;
      return 0;
    }

  /* Convert to TYPE.  */

  /* Convert to TYPE.  */
  if (!get_frame_register_bytes (frame, regnum, 0, TYPE_LENGTH (type),
				 from, optimizedp, unavailablep))
    return 0;

  convert_typed_floating (from, fpreg_type, to, type);
  *optimizedp = *unavailablep = 0;
  return 1;
}

/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */

static void
m68k_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const gdb_byte *from)
{
  gdb_byte to[M68K_MAX_REGISTER_SIZE];
  struct type *fpreg_type = register_type (get_frame_arch (frame),
					   M68K_FP0_REGNUM);

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning (_("Cannot convert non-floating-point type "
	       "to floating-point register value."));
      return;
    }

  /* Convert from TYPE.  */
  convert_typed_floating (from, type, to, fpreg_type);
  put_frame_register (frame, regnum, to);
}


/* There is a fair number of calling conventions that are in somewhat
   wide use.  The 68000/08/10 don't support an FPU, not even as a
   coprocessor.  All function return values are stored in %d0/%d1.
   Structures are returned in a static buffer, a pointer to which is
   returned in %d0.  This means that functions returning a structure
   are not re-entrant.  To avoid this problem some systems use a
   convention where the caller passes a pointer to a buffer in %a1
   where the return values is to be stored.  This convention is the
   default, and is implemented in the function m68k_return_value.

   The 68020/030/040/060 do support an FPU, either as a coprocessor
   (68881/2) or built-in (68040/68060).  That's why System V release 4
   (SVR4) instroduces a new calling convention specified by the SVR4
   psABI.  Integer values are returned in %d0/%d1, pointer return
   values in %a0 and floating values in %fp0.  When calling functions
   returning a structure the caller should pass a pointer to a buffer
   for the return value in %a0.  This convention is implemented in the
   function m68k_svr4_return_value, and by appropriately setting the
   struct_value_regnum member of `struct gdbarch_tdep'.

   GNU/Linux returns values in the same way as SVR4 does, but uses %a1
   for passing the structure return value buffer.

   GCC can also generate code where small structures are returned in
   %d0/%d1 instead of in memory by using -freg-struct-return.  This is
   the default on NetBSD a.out, OpenBSD and GNU/Linux and several
   embedded systems.  This convention is implemented by setting the
   struct_return member of `struct gdbarch_tdep' to reg_struct_return.  */

/* Read a function return value of TYPE from REGCACHE, and copy that
   into VALBUF.  */

static void
m68k_extract_return_value (struct type *type, struct regcache *regcache,
			   gdb_byte *valbuf)
{
  int len = TYPE_LENGTH (type);
  gdb_byte buf[M68K_MAX_REGISTER_SIZE];

  if (len <= 4)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (4 - len), len);
    }
  else if (len <= 8)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (8 - len), len - 4);
      regcache_raw_read (regcache, M68K_D1_REGNUM, valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("Cannot extract return value of %d bytes long."), len);
}

static void
m68k_svr4_extract_return_value (struct type *type, struct regcache *regcache,
				gdb_byte *valbuf)
{
  gdb_byte buf[M68K_MAX_REGISTER_SIZE];
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->float_return && TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      struct type *fpreg_type = register_type (gdbarch, M68K_FP0_REGNUM);
      regcache_raw_read (regcache, M68K_FP0_REGNUM, buf);
      convert_typed_floating (buf, fpreg_type, valbuf, type);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)
    regcache_raw_read (regcache, M68K_A0_REGNUM, valbuf);
  else
    m68k_extract_return_value (type, regcache, valbuf);
}

/* Write a function return value of TYPE from VALBUF into REGCACHE.  */

static void
m68k_store_return_value (struct type *type, struct regcache *regcache,
			 const gdb_byte *valbuf)
{
  int len = TYPE_LENGTH (type);

  if (len <= 4)
    regcache_raw_write_part (regcache, M68K_D0_REGNUM, 4 - len, len, valbuf);
  else if (len <= 8)
    {
      regcache_raw_write_part (regcache, M68K_D0_REGNUM, 8 - len,
			       len - 4, valbuf);
      regcache_raw_write (regcache, M68K_D1_REGNUM, valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    _("Cannot store return value of %d bytes long."), len);
}

static void
m68k_svr4_store_return_value (struct type *type, struct regcache *regcache,
			      const gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->float_return && TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      struct type *fpreg_type = register_type (gdbarch, M68K_FP0_REGNUM);
      gdb_byte buf[M68K_MAX_REGISTER_SIZE];
      convert_typed_floating (valbuf, type, buf, fpreg_type);
      regcache_raw_write (regcache, M68K_FP0_REGNUM, buf);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)
    {
      regcache_raw_write (regcache, M68K_A0_REGNUM, valbuf);
      regcache_raw_write (regcache, M68K_D0_REGNUM, valbuf);
    }
  else
    m68k_store_return_value (type, regcache, valbuf);
}

/* Return non-zero if TYPE, which is assumed to be a structure, union or
   complex type, should be returned in registers for architecture
   GDBARCH.  */

static int
m68k_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);

  gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION
	      || code == TYPE_CODE_COMPLEX);

  if (tdep->struct_return == pcc_struct_return)
    return 0;

  return (len == 1 || len == 2 || len == 4 || len == 8);
}

/* Determine, for architecture GDBARCH, how a return value of TYPE
   should be returned.  If it is supposed to be returned in registers,
   and READBUF is non-zero, read the appropriate value from REGCACHE,
   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
   from WRITEBUF into REGCACHE.  */

static enum return_value_convention
m68k_return_value (struct gdbarch *gdbarch, struct value *function,
		   struct type *type, struct regcache *regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  enum type_code code = TYPE_CODE (type);

  /* GCC returns a `long double' in memory too.  */
  if (((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION
	|| code == TYPE_CODE_COMPLEX)
       && !m68k_reg_struct_return_p (gdbarch, type))
      || (code == TYPE_CODE_FLT && TYPE_LENGTH (type) == 12))
    {
      /* The default on m68k is to return structures in static memory.
         Consequently a function must return the address where we can
         find the return value.  */

      if (readbuf)
	{
	  ULONGEST addr;

	  regcache_raw_read_unsigned (regcache, M68K_D0_REGNUM, &addr);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }

  if (readbuf)
    m68k_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    m68k_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}

static enum return_value_convention
m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,
			struct type *type, struct regcache *regcache,
			gdb_byte *readbuf, const gdb_byte *writebuf)
{
  enum type_code code = TYPE_CODE (type);

  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION
       || code == TYPE_CODE_COMPLEX)
      && !m68k_reg_struct_return_p (gdbarch, type))
    {
      /* The System V ABI says that:

	 "A function returning a structure or union also sets %a0 to
	 the value it finds in %a0.  Thus when the caller receives
	 control again, the address of the returned object resides in
	 register %a0."

	 So the ABI guarantees that we can always find the return
	 value just after the function has returned.  */

      if (readbuf)
	{
	  ULONGEST addr;

	  regcache_raw_read_unsigned (regcache, M68K_A0_REGNUM, &addr);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }

  /* This special case is for structures consisting of a single
     `float' or `double' member.  These structures are returned in
     %fp0.  For these structures, we call ourselves recursively,
     changing TYPE into the type of the first member of the structure.
     Since that should work for all structures that have only one
     member, we don't bother to check the member's type here.  */
  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
    {
      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
      return m68k_svr4_return_value (gdbarch, function, type, regcache,
				     readbuf, writebuf);
    }

  if (readbuf)
    m68k_svr4_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    m68k_svr4_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
}


/* Always align the frame to a 4-byte boundary.  This is required on
   coldfire and harmless on the rest.  */

static CORE_ADDR
m68k_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align the stack to four bytes.  */
  return sp & ~3;
}

static CORE_ADDR
m68k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  gdb_byte buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
    {
      struct type *value_type = value_enclosing_type (args[i]);
      int len = TYPE_LENGTH (value_type);
      int container_len = (len + 3) & ~3;
      int offset;

      /* Non-scalars bigger than 4 bytes are left aligned, others are
	 right aligned.  */
      if ((TYPE_CODE (value_type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (value_type) == TYPE_CODE_UNION
	   || TYPE_CODE (value_type) == TYPE_CODE_ARRAY)
	  && len > 4)
	offset = 0;
      else
	offset = container_len - len;
      sp -= container_len;
      write_memory (sp + offset, value_contents_all (args[i]), len);
    }

  /* Store struct value address.  */
  if (struct_return)
    {
      store_unsigned_integer (buf, 4, byte_order, struct_addr);
      regcache_cooked_write (regcache, tdep->struct_value_regnum, buf);
    }

  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, byte_order, bp_addr);
  write_memory (sp, buf, 4);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 4, byte_order, sp);
  regcache_cooked_write (regcache, M68K_SP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, M68K_FP_REGNUM, buf);

  /* DWARF2/GCC uses the stack address *before* the function call as a
     frame's CFA.  */
  return sp + 8;
}

/* Convert a dwarf or dwarf2 regnumber to a GDB regnum.  */

static int
m68k_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int num)
{
  if (num < 8)
    /* d0..7 */
    return (num - 0) + M68K_D0_REGNUM;
  else if (num < 16)
    /* a0..7 */
    return (num - 8) + M68K_A0_REGNUM;
  else if (num < 24 && gdbarch_tdep (gdbarch)->fpregs_present)
    /* fp0..7 */
    return (num - 16) + M68K_FP0_REGNUM;
  else if (num == 25)
    /* pc */
    return M68K_PC_REGNUM;
  else
    return gdbarch_num_regs (gdbarch) + gdbarch_num_pseudo_regs (gdbarch);
}


struct m68k_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[M68K_NUM_REGS];
  CORE_ADDR saved_sp;

  /* Stack space reserved for local variables.  */
  long locals;
};

/* Allocate and initialize a frame cache.  */

static struct m68k_frame_cache *
m68k_alloc_frame_cache (void)
{
  struct m68k_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct m68k_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %fp is supposed to be stored).  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    cache->saved_regs[i] = -1;

  /* Frameless until proven otherwise.  */
  cache->locals = -1;

  return cache;
}

/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */

static CORE_ADDR
m68k_analyze_frame_setup (struct gdbarch *gdbarch,
			  CORE_ADDR pc, CORE_ADDR current_pc,
			  struct m68k_frame_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int op;

  if (pc >= current_pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 2, byte_order);

  if (op == P_LINKW_FP || op == P_LINKL_FP || op == P_PEA_FP)
    {
      cache->saved_regs[M68K_FP_REGNUM] = 0;
      cache->sp_offset += 4;
      if (op == P_LINKW_FP)
	{
	  /* link.w %fp, #-N */
	  /* link.w %fp, #0; adda.l #-N, %sp */
	  cache->locals = -read_memory_integer (pc + 2, 2, byte_order);

	  if (pc + 4 < current_pc && cache->locals == 0)
	    {
	      op = read_memory_unsigned_integer (pc + 4, 2, byte_order);
	      if (op == P_ADDAL_SP)
		{
		  cache->locals = read_memory_integer (pc + 6, 4, byte_order);
		  return pc + 10;
		}
	    }

	  return pc + 4;
	}
      else if (op == P_LINKL_FP)
	{
	  /* link.l %fp, #-N */
	  cache->locals = -read_memory_integer (pc + 2, 4, byte_order);
	  return pc + 6;
	}
      else
	{
	  /* pea (%fp); movea.l %sp, %fp */
	  cache->locals = 0;

	  if (pc + 2 < current_pc)
	    {
	      op = read_memory_unsigned_integer (pc + 2, 2, byte_order);

	      if (op == P_MOVEAL_SP_FP)
		{
		  /* move.l %sp, %fp */
		  return pc + 4;
		}
	    }

	  return pc + 2;
	}
    }
  else if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
    {
      /* subq.[wl] #N,%sp */
      /* subq.[wl] #8,%sp; subq.[wl] #N,%sp */
      cache->locals = (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
      if (pc + 2 < current_pc)
	{
	  op = read_memory_unsigned_integer (pc + 2, 2, byte_order);
	  if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
	    {
	      cache->locals += (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
	      return pc + 4;
	    }
	}
      return pc + 2;
    }
  else if (op == P_ADDAW_SP || op == P_LEA_SP_SP)
    {
      /* adda.w #-N,%sp */
      /* lea (-N,%sp),%sp */
      cache->locals = -read_memory_integer (pc + 2, 2, byte_order);
      return pc + 4;
    }
  else if (op == P_ADDAL_SP)
    {
      /* adda.l #-N,%sp */
      cache->locals = -read_memory_integer (pc + 2, 4, byte_order);
      return pc + 6;
    }

  return pc;
}

/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */

static CORE_ADDR
m68k_analyze_register_saves (struct gdbarch *gdbarch, CORE_ADDR pc,
			     CORE_ADDR current_pc,
			     struct m68k_frame_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  if (cache->locals >= 0)
    {
      CORE_ADDR offset;
      int op;
      int i, mask, regno;

      offset = -4 - cache->locals;
      while (pc < current_pc)
	{
	  op = read_memory_unsigned_integer (pc, 2, byte_order);
	  if (op == P_FMOVEMX_SP
	      && gdbarch_tdep (gdbarch)->fpregs_present)
	    {
	      /* fmovem.x REGS,-(%sp) */
	      op = read_memory_unsigned_integer (pc + 2, 2, byte_order);
	      if ((op & 0xff00) == 0xe000)
		{
		  mask = op & 0xff;
		  for (i = 0; i < 16; i++, mask >>= 1)
		    {
		      if (mask & 1)
			{
			  cache->saved_regs[i + M68K_FP0_REGNUM] = offset;
			  offset -= 12;
			}
		    }
		  pc += 4;
		}
	      else
		break;
	    }
	  else if ((op & 0177760) == P_MOVEL_SP)
	    {
	      /* move.l %R,-(%sp) */
	      regno = op & 017;
	      cache->saved_regs[regno] = offset;
	      offset -= 4;
	      pc += 2;
	    }
	  else if (op == P_MOVEML_SP)
	    {
	      /* movem.l REGS,-(%sp) */
	      mask = read_memory_unsigned_integer (pc + 2, 2, byte_order);
	      for (i = 0; i < 16; i++, mask >>= 1)
		{
		  if (mask & 1)
		    {
		      cache->saved_regs[15 - i] = offset;
		      offset -= 4;
		    }
		}
	      pc += 4;
	    }
	  else
	    break;
	}
    }

  return pc;
}


/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.

   We handle all cases that can be generated by gcc.

   For allocating a stack frame:

   link.w %a6,#-N
   link.l %a6,#-N
   pea (%fp); move.l %sp,%fp
   link.w %a6,#0; add.l #-N,%sp
   subq.l #N,%sp
   subq.w #N,%sp
   subq.w #8,%sp; subq.w #N-8,%sp
   add.w #-N,%sp
   lea (-N,%sp),%sp
   add.l #-N,%sp

   For saving registers:

   fmovem.x REGS,-(%sp)
   move.l R1,-(%sp)
   move.l R1,-(%sp); move.l R2,-(%sp)
   movem.l REGS,-(%sp)

   For setting up the PIC register:

   lea (%pc,N),%a5

   */

static CORE_ADDR
m68k_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,
		       CORE_ADDR current_pc, struct m68k_frame_cache *cache)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned int op;

  pc = m68k_analyze_frame_setup (gdbarch, pc, current_pc, cache);
  pc = m68k_analyze_register_saves (gdbarch, pc, current_pc, cache);
  if (pc >= current_pc)
    return current_pc;

  /* Check for GOT setup.  */
  op = read_memory_unsigned_integer (pc, 4, byte_order);
  if (op == P_LEA_PC_A5)
    {
      /* lea (%pc,N),%a5 */
      return pc + 8;
    }

  return pc;
}

/* Return PC of first real instruction.  */

static CORE_ADDR
m68k_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  struct m68k_frame_cache cache;
  CORE_ADDR pc;

  cache.locals = -1;
  pc = m68k_analyze_prologue (gdbarch, start_pc, (CORE_ADDR) -1, &cache);
  if (cache.locals < 0)
    return start_pc;
  return pc;
}

static CORE_ADDR
m68k_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  gdb_byte buf[8];

  frame_unwind_register (next_frame, gdbarch_pc_regnum (gdbarch), buf);
  return extract_typed_address (buf, builtin_type (gdbarch)->builtin_func_ptr);
}

/* Normal frames.  */

static struct m68k_frame_cache *
m68k_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  struct m68k_frame_cache *cache;
  gdb_byte buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, %fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */

  get_frame_register (this_frame, M68K_FP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4, byte_order);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %pc is stored at 4(%fp).  */
  cache->saved_regs[M68K_PC_REGNUM] = 4;

  cache->pc = get_frame_func (this_frame);
  if (cache->pc != 0)
    m68k_analyze_prologue (get_frame_arch (this_frame), cache->pc,
			   get_frame_pc (this_frame), cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      get_frame_register (this_frame, M68K_SP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4, byte_order)
		    + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %sp in the calling frame.  */
  cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;

  return cache;
}

static void
m68k_frame_this_id (struct frame_info *this_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (this_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, cache->pc);
}

static struct value *
m68k_frame_prev_register (struct frame_info *this_frame, void **this_cache,
			  int regnum)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (this_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == M68K_SP_REGNUM && cache->saved_sp)
    return frame_unwind_got_constant (this_frame, regnum, cache->saved_sp);

  if (regnum < M68K_NUM_REGS && cache->saved_regs[regnum] != -1)
    return frame_unwind_got_memory (this_frame, regnum,
				    cache->saved_regs[regnum]);

  return frame_unwind_got_register (this_frame, regnum, regnum);
}

static const struct frame_unwind m68k_frame_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  m68k_frame_this_id,
  m68k_frame_prev_register,
  NULL,
  default_frame_sniffer
};

static CORE_ADDR
m68k_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base m68k_frame_base =
{
  &m68k_frame_unwind,
  m68k_frame_base_address,
  m68k_frame_base_address,
  m68k_frame_base_address
};

static struct frame_id
m68k_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR fp;

  fp = get_frame_register_unsigned (this_frame, M68K_FP_REGNUM);

  /* See the end of m68k_push_dummy_call.  */
  return frame_id_build (fp + 8, get_frame_pc (this_frame));
}


/* Figure out where the longjmp will land.  Slurp the args out of the stack.
   We expect the first arg to be a pointer to the jmp_buf structure from which
   we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.
   This routine returns true on success.  */

static int
m68k_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)
{
  gdb_byte *buf;
  CORE_ADDR sp, jb_addr;
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  if (tdep->jb_pc < 0)
    {
      internal_error (__FILE__, __LINE__,
		      _("m68k_get_longjmp_target: not implemented"));
      return 0;
    }

  buf = alloca (gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT);
  sp = get_frame_register_unsigned (frame, gdbarch_sp_regnum (gdbarch));

  if (target_read_memory (sp + SP_ARG0,	/* Offset of first arg on stack.  */
			  buf, gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT))
    return 0;

  jb_addr = extract_unsigned_integer (buf, gdbarch_ptr_bit (gdbarch)
					     / TARGET_CHAR_BIT, byte_order);

  if (target_read_memory (jb_addr + tdep->jb_pc * tdep->jb_elt_size, buf,
			  gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT),
			  byte_order)
    return 0;

  *pc = extract_unsigned_integer (buf, gdbarch_ptr_bit (gdbarch)
					 / TARGET_CHAR_BIT, byte_order);
  return 1;
}


/* This is the implementation of gdbarch method
   return_in_first_hidden_param_p.  */

static int
m68k_return_in_first_hidden_param_p (struct gdbarch *gdbarch,
				     struct type *type)
{
  return 0;
}

/* System V Release 4 (SVR4).  */

void
m68k_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* SVR4 uses a different calling convention.  */
  set_gdbarch_return_value (gdbarch, m68k_svr4_return_value);

  /* SVR4 uses %a0 instead of %a1.  */
  tdep->struct_value_regnum = M68K_A0_REGNUM;
}


/* Function: m68k_gdbarch_init
   Initializer function for the m68k gdbarch vector.
   Called by gdbarch.  Sets up the gdbarch vector(s) for this target.  */

static struct gdbarch *
m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep = NULL;
  struct gdbarch *gdbarch;
  struct gdbarch_list *best_arch;
  struct tdesc_arch_data *tdesc_data = NULL;
  int i;
  enum m68k_flavour flavour = m68k_no_flavour;
  int has_fp = 1;
  const struct floatformat **long_double_format = floatformats_m68881_ext;

  /* Check any target description for validity.  */
  if (tdesc_has_registers (info.target_desc))
    {
      const struct tdesc_feature *feature;
      int valid_p;

      feature = tdesc_find_feature (info.target_desc,
				    "org.gnu.gdb.m68k.core");

      if (feature == NULL)
	{
	  feature = tdesc_find_feature (info.target_desc,
					"org.gnu.gdb.coldfire.core");
	  if (feature != NULL)
	    flavour = m68k_coldfire_flavour;
	}

      if (feature == NULL)
	{
	  feature = tdesc_find_feature (info.target_desc,
					"org.gnu.gdb.fido.core");
	  if (feature != NULL)
	    flavour = m68k_fido_flavour;
	}

      if (feature == NULL)
	return NULL;

      tdesc_data = tdesc_data_alloc ();

      valid_p = 1;
      for (i = 0; i <= M68K_PC_REGNUM; i++)
	valid_p &= tdesc_numbered_register (feature, tdesc_data, i,
					    m68k_register_names[i]);

      if (!valid_p)
	{
	  tdesc_data_cleanup (tdesc_data);
	  return NULL;
	}

      feature = tdesc_find_feature (info.target_desc,
				    "org.gnu.gdb.coldfire.fp");
      if (feature != NULL)
	{
	  valid_p = 1;
	  for (i = M68K_FP0_REGNUM; i <= M68K_FPI_REGNUM; i++)
	    valid_p &= tdesc_numbered_register (feature, tdesc_data, i,
						m68k_register_names[i]);
	  if (!valid_p)
	    {
	      tdesc_data_cleanup (tdesc_data);
	      return NULL;
	    }
	}
      else
	has_fp = 0;
    }

  /* The mechanism for returning floating values from function
     and the type of long double depend on whether we're
     on ColdFire or standard m68k.  */

  if (info.bfd_arch_info && info.bfd_arch_info->mach != 0)
    {
      const bfd_arch_info_type *coldfire_arch = 
	bfd_lookup_arch (bfd_arch_m68k, bfd_mach_mcf_isa_a_nodiv);

      if (coldfire_arch
	  && ((*info.bfd_arch_info->compatible) 
	      (info.bfd_arch_info, coldfire_arch)))
	flavour = m68k_coldfire_flavour;
    }
  
  /* If there is already a candidate, use it.  */
  for (best_arch = gdbarch_list_lookup_by_info (arches, &info);
       best_arch != NULL;
       best_arch = gdbarch_list_lookup_by_info (best_arch->next, &info))
    {
      if (flavour != gdbarch_tdep (best_arch->gdbarch)->flavour)
	continue;

      if (has_fp != gdbarch_tdep (best_arch->gdbarch)->fpregs_present)
	continue;

      break;
    }

  if (best_arch != NULL)
    {
      if (tdesc_data != NULL)
	tdesc_data_cleanup (tdesc_data);
      return best_arch->gdbarch;
    }

  tdep = xzalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);
  tdep->fpregs_present = has_fp;
  tdep->flavour = flavour;

  if (flavour == m68k_coldfire_flavour || flavour == m68k_fido_flavour)
    long_double_format = floatformats_ieee_double;
  set_gdbarch_long_double_format (gdbarch, long_double_format);
  set_gdbarch_long_double_bit (gdbarch, long_double_format[0]->totalsize);

  set_gdbarch_skip_prologue (gdbarch, m68k_skip_prologue);
  set_gdbarch_breakpoint_from_pc (gdbarch, m68k_local_breakpoint_from_pc);

  /* Stack grows down.  */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_frame_align (gdbarch, m68k_frame_align);

  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
  if (flavour == m68k_coldfire_flavour || flavour == m68k_fido_flavour)
    set_gdbarch_decr_pc_after_break (gdbarch, 2);

  set_gdbarch_frame_args_skip (gdbarch, 8);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, m68k_dwarf_reg_to_regnum);

  set_gdbarch_register_type (gdbarch, m68k_register_type);
  set_gdbarch_register_name (gdbarch, m68k_register_name);
  set_gdbarch_num_regs (gdbarch, M68K_NUM_REGS);
  set_gdbarch_sp_regnum (gdbarch, M68K_SP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, M68K_PC_REGNUM);
  set_gdbarch_ps_regnum (gdbarch, M68K_PS_REGNUM);
  set_gdbarch_convert_register_p (gdbarch, m68k_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  m68k_register_to_value);
  set_gdbarch_value_to_register (gdbarch, m68k_value_to_register);

  if (has_fp)
    set_gdbarch_fp0_regnum (gdbarch, M68K_FP0_REGNUM);

  /* Try to figure out if the arch uses floating registers to return
     floating point values from functions.  */
  if (has_fp)
    {
      /* On ColdFire, floating point values are returned in D0.  */
      if (flavour == m68k_coldfire_flavour)
	tdep->float_return = 0;
      else
	tdep->float_return = 1;
    }
  else
    {
      /* No floating registers, so can't use them for returning values.  */
      tdep->float_return = 0;
    }

  /* Function call & return.  */
  set_gdbarch_push_dummy_call (gdbarch, m68k_push_dummy_call);
  set_gdbarch_return_value (gdbarch, m68k_return_value);
  set_gdbarch_return_in_first_hidden_param_p (gdbarch,
					      m68k_return_in_first_hidden_param_p);


  /* Disassembler.  */
  set_gdbarch_print_insn (gdbarch, print_insn_m68k);

#if defined JB_PC && defined JB_ELEMENT_SIZE
  tdep->jb_pc = JB_PC;
  tdep->jb_elt_size = JB_ELEMENT_SIZE;
#else
  tdep->jb_pc = -1;
#endif
  tdep->struct_value_regnum = M68K_A1_REGNUM;
  tdep->struct_return = reg_struct_return;

  /* Frame unwinder.  */
  set_gdbarch_dummy_id (gdbarch, m68k_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, m68k_unwind_pc);

  /* Hook in the DWARF CFI frame unwinder.  */
  dwarf2_append_unwinders (gdbarch);

  frame_base_set_default (gdbarch, &m68k_frame_base);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  /* Now we have tuned the configuration, set a few final things,
     based on what the OS ABI has told us.  */

  if (tdep->jb_pc >= 0)
    set_gdbarch_get_longjmp_target (gdbarch, m68k_get_longjmp_target);

  frame_unwind_append_unwinder (gdbarch, &m68k_frame_unwind);

  if (tdesc_data)
    tdesc_use_registers (gdbarch, info.target_desc, tdesc_data);

  return gdbarch;
}


static void
m68k_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep == NULL)
    return;
}

extern initialize_file_ftype _initialize_m68k_tdep; /* -Wmissing-prototypes */

void
_initialize_m68k_tdep (void)
{
  gdbarch_register (bfd_arch_m68k, m68k_gdbarch_init, m68k_dump_tdep);
}
@


1.161
log
@	* configure: Rebuild.
	* configure.ac (build_warnings): Add -Wempty-body.
	* m68k-tdep.c (m68k_gdbarch_init): Remove empty 'if'.
	* remote.c (handle_notification): Use braces for empty 'else' body.
	* s390-tdep.c (s390_analyze_prologue): Use braces for empty
	'else' body.
	* sh64-tdep.c (sh64_push_dummy_call): Use braces for empty
	'else' body.
	* solib-som.c (som_relocate_section_addresses): Use braces
	for empty 'else' body.
	* ui-file.c (stdio_file_write): Use braces for empty 'if' body.
	(stdio_file_write_async_safe, stdio_file_fputs): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1990-1996, 1999-2012 Free Software Foundation, Inc.
@


1.160
log
@	* m2-valprint.c (m2_print_array_contents): Eliminate variable
	ELTLEN and use TYPE_LENGTH directly.
	(m2_val_print): Likewise.
	* m68k-tdep.c (m68k_svr4_extract_return_value): Eliminate
	variable LEN and use TYPE_LENGTH directly.
	(m68k_svr4_store_return_value): Likewise.
	* mips-tdep.c (mips_o32_push_dummy_call): Eliminate variable
	ARGLEN and use TYPE_LENGTH directly.
	(mips_o64_push_dummy_call): Likewise.
	* s390-tdep (s390_function_arg_pass_by_reference): Eliminate
	variable LENGTH and use TYPE_LENGTH directly.
	(s390_function_arg_float): Likewise.
	(s390_function_arg_integer): Likewise.
	(s390_push_dummy_call): Likewise.
	(s390_return_value_convention): Likewise.
	* spu-tdep.c (spu_push_dummy_call): Eliminate LEN and use
	TYPE_LENGTH directly.
@
text
@a1102 3
      if (feature != NULL)
	/* Do nothing.  */
	;
@


1.159
log
@* m68k-tdep.c (m68k_reg_struct_return_p): Accept complex types.
(m68k_return_value): Handle complex types like structures.
(m68k_svr4_return_value): Likewise.
@
text
@a317 1
  int len = TYPE_LENGTH (type);
d328 1
a328 1
  else if (TYPE_CODE (type) == TYPE_CODE_PTR && len == 4)
a358 1
  int len = TYPE_LENGTH (type);
d369 1
a369 1
  else if (TYPE_CODE (type) == TYPE_CODE_PTR && len == 4)
@


1.158
log
@gdb/
	* arch-utils.c (default_return_in_first_hidden_param_p): New.
	* arch-utils.h: Declare.
	* gdbarch.sh: Add return_in_first_hidden_param_p.
	* gdbarch.c, gdbarch.h: Regenerated.
	* infcall.c (call_function_by_hand): Call
	gdbarch_return_in_first_hidden_param_p instead of
	language_pass_by_reference.

	* m68k-tdep.c (m68k_return_in_first_hidden_param_p): New.
	(m68k_gdbarch_init): Install m68k_return_in_first_hidden_param_p.
	* sh-tdep.c (sh_return_in_first_hidden_param_p): New.
	(sh_gdbarch_init): Install sh_return_in_first_hidden_param_p.
	* tic6x-tdep.c (tic6x_push_dummy_call): Remove local variable
	`cplus_return_struct_by_reference'.
	(tic6x_return_value): Handle language cplusplus.
	(tic6x_return_in_first_hidden_param_p): New.
	(tic6x_gdbarch_init): Install tic6x_return_in_first_hidden_param_p.
@
text
@d380 2
a381 2
/* Return non-zero if TYPE, which is assumed to be a structure or
   union type, should be returned in registers for architecture
d391 2
a392 1
  gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION);
d414 2
a415 1
  if (((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
d449 2
a450 1
  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
@


1.157
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d1053 10
d1248 2
@


1.156
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a856 1
  int op;
@


1.155
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d406 1
a406 1
m68k_return_value (struct gdbarch *gdbarch, struct type *func_type,
d441 1
a441 1
m68k_svr4_return_value (struct gdbarch *gdbarch, struct type *func_type,
d480 1
a480 1
      return m68k_svr4_return_value (gdbarch, func_type, type, regcache,
@


1.154
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d3 1
a3 3
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.154.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1990-1996, 1999-2012 Free Software Foundation, Inc.
@


1.153
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d979 1
@


1.152
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* m2-exp.y: Comment cleanup, mostly periods and spaces.
	* m2-lang.c: Ditto.
	* m2-typeprint.c: Ditto.
	* m2-valprint.c: Ditto.
	* m32c-tdep.c: Ditto.
	* m32r-linux-nat.c: Ditto.
	* m32r-rom.c: Ditto.
	* m32r-tdep.c: Ditto.
	* m32r-tdep.h: Ditto.
	* m68hc11-tdep.c: Ditto.
	* m58klinux-nat.c: Ditto.
	* m68k-tdep.c: Ditto.
	* m88k-tdep.c: Ditto.
	* m88k-tdep.h: Ditto.
	* machoread.c: Ditto.
	* macrocmd.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* mdebugread.h: Ditto.
	* memattr.c: Ditto.
	* memattr.h: Ditto.
	* memory-map.h: Ditto.
	* mep-tdep.c: Ditto.
	* microblaze-rom.c: Ditto.
	* microblaze-tdep.c: Ditto.
	* minsyms.c: Ditto.
	* mips-irix-tdep.c: Ditto.
	* mips-linux-nat.c: Ditto.
	* mips-linux-tdep.c: Ditto.
	* mips-linux-tdep.h: Ditto.
	* mipsnbsd-nat.c: Ditto.
	* mipsnbsd-tdep.c: Ditto.
	* mipsread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mips-tdep.h: Ditto.
	* mn10300-linux-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* mn10300-tdep.h: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* moxie-tdep.c: Ditto.
	* moxie-tdep.h: Ditto.
	* mt-tdep.c: Ditto.
@
text
@d206 1
a206 1
static void
d208 2
a209 1
			struct type *type, gdb_byte *to)
d220 2
a221 1
      return;
d225 6
a230 1
  get_frame_register (frame, regnum, from);
d232 2
@


1.151
log
@run copyright.sh for 2011.
@
text
@d57 1
a57 1
/* Offset from SP to first arg on stack at first instruction of a function */
d174 1
a174 1
   Returns the name of the standard m68k register regnum. */
d181 2
a182 1
		    _("m68k_register_name: illegal register number %d"), regnum);
d194 2
a195 1
m68k_convert_register_p (struct gdbarch *gdbarch, int regnum, struct type *type)
d1007 1
a1007 1
   This routine returns true on success. */
d1028 1
a1028 1
  if (target_read_memory (sp + SP_ARG0,	/* Offset of first arg on stack */
d1063 1
a1063 1
   Called by gdbarch.  Sets up the gdbarch vector(s) for this target. */
d1141 1
a1141 1
     on ColdFire or standard m68k. */
d1188 1
a1188 1
  /* Stack grows down. */
d1228 1
a1228 1
  /* Function call & return */
@


1.150
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.149
log
@2009-11-17  Daniel Jacobowitz  <dan@@codesourcery.com>

	* m68k-tdep.c (m68k_gdbarch_init): Reuse previous initialization.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.148
log
@2009-11-17  Daniel Jacobowitz  <dan@@codesourcery.com>

	* m68k-tdep.c (m68k_register_name): Check fpregs_present.
	(m68k_gdbarch_init): Remove a duplicate of set_gdbarch_fp0_regnum.
@
text
@d1166 7
@


1.147
log
@	* m68k-tdep.c (m68k_convert_register_p): Correct
	messup.
@
text
@d182 3
a1195 1
  set_gdbarch_fp0_regnum (gdbarch, M68K_FP0_REGNUM);
@


1.146
log
@	* m68k-tdep.c (m68k_convert_register_p): Compare with
	the actual type of fp registers, not one of the possible
	values.
@
text
@a194 1
	  && type != m68881_ext_type (gdbarch)
@


1.145
log
@gdb/
	* m68k-tdep.c (m68k_gdbarch_init): Allocate TDEP as cleared.
	* sparc-tdep.c (sparc32_gdbarch_init): Allocate TDEP as cleared.
	Remove explicit clearing of TDEP fields.
@
text
@d195 2
a196 1
	  && type != m68881_ext_type (gdbarch));
@


1.144
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d1163 1
a1163 1
  tdep = xmalloc (sizeof (struct gdbarch_tdep));
@


1.143
log
@	* gdbtypes.h (TYPE_OBJFILE_OWNED, TYPE_OWNER): New macros.
	(TYPE_OBJFILE, TYPE_ALLOC, TYPE_ZALLOC): Reimplement.
	(alloc_type_arch): Add prototype.
	(alloc_type_copy): Likewise.
	(get_type_arch): Likewise.
	(arch_type): Likewise.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.

	* gdbtypes.c (alloc_type): No longer support NULL objfile.
	(init_type): Likewise.
	(alloc_type_arch): New function.
	(alloc_type_copy): New function.
	(get_type_arch): New function.

	(smash_type): Preserve type ownership information.
	(make_pointer_type, make_reference_type, make_function_type,
	smash_to_memberptr_type, smash_to_method_type): No longer
	preserve OBJFILE across smash_type calls.
	(make_pointer_type, make_reference_type, make_function_type,
	lookup_memberptr_type, lookup_methodptr_type, allocate_stub_method,
	create_range_type, create_array_type, create_set_type, copy_type):
	Use alloc_type_copy when allocating types.
	(check_typedef): Use alloc_type_arch.
	(copy_type_recursive): Likewise.  Preserve type ownership data
	after copying type.
	(recursive_dump_type): Dump type ownership data.
	(alloc_type_instance): Update type ownership check.
	(copy_type, copy_type_recursive): Likewise.

	(arch_type): New function.
	(arch_integer_type): Likewise.
	(arch_character_type): Likewise.
	(arch_boolean_type): Likewise.
	(init_float_type): Remove, replace by ...
	(arch_float_type): ... this.
	(init_complex_type): Remove, replace by ...
	(arch_complex_type): ... this.
	(init_flags_type): Remove, replace by ...
	(arch_flags_type): ... this.
	(append_flags_type_flag): Move down.
	(init_composite_type): Remove, replace by ...
	(arch_composite_type): ... this.
	(append_composite_type_field_aligned,
	append_composite_type_field): Move down.

	* gdbarch.c (gdbtypes_post_init): Allocate all types
	using per-architecture routines.
	* ada-lang.c (ada_language_arch_info): Likewise.
	* f-lang.c (build_fortran_types): Likewise.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* scm-lang.c (build_scm_types): Likewise.

	* ada-lang.c (ada_type_of_array): Use alloc_type_copy.
	(packed_array_type): Likewise.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_variant_branch_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_fixed_range_type): Likewise.
	(empty_record): Use type instead of objfile argument.
	Use alloc_type_copy.
	(to_fixed_variant_branch_type): Update call to empty_record.
	* jv-lang.c (type_from_class): Use alloc_type_arch.

	* arm-tdep.c (arm_ext_type): Allocate per-architecture type.
	* i386-tdep.c (i386_eflags_type, i386_mxcsr_type, i387_ext_type,
	i386_mmx_type, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_ext_type): Likewise.
	* m32c-tdep.c (make_types): Likewise.
	* m68k-tdep.c (m68k_ps_type, m68881_ext_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* sparc-tdep.c (sparc_psr_type, sparc_fsr_type): Likewise.
	* sparc64-tdep.c (sparc64_pstate_type, sparc64_fsr_type,
	sparc64_fprs_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.
	* linux-tdep.c (linux_get_siginfo_type): Likewise.
	* target-descriptions.c (tdesc_gdb_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
@
text
@d498 1
d526 1
a526 1
      store_unsigned_integer (buf, 4, struct_addr);
d532 1
a532 1
  store_unsigned_integer (buf, 4, bp_addr);
d536 1
a536 1
  store_unsigned_integer (buf, 4, sp);
d617 2
a618 1
m68k_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
d621 1
d627 1
a627 1
  op = read_memory_unsigned_integer (pc, 2);
d637 1
a637 1
	  cache->locals = -read_memory_integer (pc + 2, 2);
d641 1
a641 1
	      op = read_memory_unsigned_integer (pc + 4, 2);
d644 1
a644 1
		  cache->locals = read_memory_integer (pc + 6, 4);
d654 1
a654 1
	  cache->locals = -read_memory_integer (pc + 2, 4);
d664 1
a664 1
	      op = read_memory_unsigned_integer (pc + 2, 2);
d683 1
a683 1
	  op = read_memory_unsigned_integer (pc + 2, 2);
d696 1
a696 1
      cache->locals = -read_memory_integer (pc + 2, 2);
d702 1
a702 1
      cache->locals = -read_memory_integer (pc + 2, 4);
d719 2
d730 1
a730 1
	  op = read_memory_unsigned_integer (pc, 2);
d735 1
a735 1
	      op = read_memory_unsigned_integer (pc + 2, 2);
d763 1
a763 1
	      mask = read_memory_unsigned_integer (pc + 2, 2);
d819 1
d822 1
a822 1
  pc = m68k_analyze_frame_setup (pc, current_pc, cache);
d828 1
a828 1
  op = read_memory_unsigned_integer (pc, 4);
d868 2
d890 1
a890 1
  cache->base = extract_unsigned_integer (buf, 4);
d913 2
a914 1
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
d1010 2
a1011 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
d1028 1
a1028 1
					     / TARGET_CHAR_BIT);
d1031 2
a1032 1
			  gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT))
d1036 1
a1036 1
					 / TARGET_CHAR_BIT);
@


1.142
log
@	* i386-tdep.h (struct gdbarch_tdep): Add i386_eflags_type and
	i386_mxcsr_type members.
	(i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	* i386-tdep.c (i386_eflags_type): Make into function.
	(i386_mxcsr_type): Likewise.
	(i386_register_type): Update uses.
	(i386_init_types): Remove.
	(_initialize_i386_tdep): Do not call it.
	* amd64-tdep.c (amd64_register_type): Update uses.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68k_ps_type member.
	* m68k-tdep.c (m68k_ps_type): Make into function.
	(m68k_register_type): Update use.
	(m68k_init_types): Remove.
	(_initialize_m68k_tdep): Do not call it.

	* sparc-tdep.h (struct gdbarch_tdep): Add sparc_psr_type,
	sparc_fsr_type, sparc64_pstate_type, sparc64_fsr_type, and
	sparc64_fprs_type members.
	* sparc-tdep.c (sparc_psr_type): Make into function.
	(sparc_fsr_type): Likewise.
	(sparc32_register_type): Update uses.
	(sparc_init_types): Remove.
	(_initialize_sparc_tdep): Do not call it.
	* sparc64-tdep.c (sparc64_pstate_type): Make into function.
	(sparc64_fsr_type): Likewise.
	(sparc64_fprs_type): Likewise.
	(sparc64_register_type): Update uses.
	(sparc64_init_types): Remove.
	(_initialize_sparc64_tdep): Likewise.
@
text
@d84 1
a84 1
      type = init_flags_type ("builtin_type_m68k_ps", 4);
d111 1
a111 1
      = init_float_type (-1, "builtin_type_m68881_ext",
@


1.141
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@a73 3
/* Type for %ps.  */
struct type *m68k_ps_type;

d75 2
a76 2
static void
m68k_init_types (void)
d78 19
a96 1
  struct type *type;
d98 4
a101 14
  type = init_flags_type ("builtin_type_m68k_ps", 4);
  append_flags_type_flag (type, 0, "C");
  append_flags_type_flag (type, 1, "V");
  append_flags_type_flag (type, 2, "Z");
  append_flags_type_flag (type, 3, "N");
  append_flags_type_flag (type, 4, "X");
  append_flags_type_flag (type, 8, "I0");
  append_flags_type_flag (type, 9, "I1");
  append_flags_type_flag (type, 10, "I2");
  append_flags_type_flag (type, 12, "M");
  append_flags_type_flag (type, 13, "S");
  append_flags_type_flag (type, 14, "T0");
  append_flags_type_flag (type, 15, "T1");
  m68k_ps_type = type;
d160 1
a160 1
    return m68k_ps_type;
a1264 3

  /* Initialize the m68k-specific register types.  */
  m68k_init_types ();
@


1.140
log
@	* gdbtypes.h (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(struct builtin_type): New members builtin_int0, builtin_int8,
	builtin_uint8, builtin_int16, builtin_uint16, builtin_int32,
	builtin_uint32, builtin_int64, builtin_uint64, builtin_int128,
	and builtin_uint128.
	* gdbtypes.c (builtin_type_int0, builtin_type_int8, builtin_type_uint8,
	builtin_type_int16, builtin_type_uint16, builtin_type_int32,
	builtin_type_uint32, builtin_type_int64, builtin_type_uint64,
	builtin_type_int128, builtin_type_uint128): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(gdbtypes_post_init): Initialize fixed-size integer types.

	* dwarf2expr.c (unsigned_address_type, signed_address_type): Add
	GDBARCH argument.  Return platform-specific type.
	(dwarf2_read_address, execute_stack_op): Update calls.

	* target-descriptions.c (tdesc_gdb_type): Use platform-specific types
	instead of global builtin_int_... variables.
	* mi/mi-main.c (mi_cmd_data_read_memory): Likewise.
	* printcmd.c (do_examine): Likewise.
	* jv-exp.y (parse_number): Likewise.

	* alpha-tdep.c (alpha_register_type, alpha_push_dummy_call,
	alpha_store_return_value): Likewise.
	* amd64-linux-tdep.c (amd64_linux_register_type): Likewise.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c h8300_register_type): Likewise.
	* hppa-tdep.c (hppa64_push_dummy_call, hppa32_register_type,
	hppa64_register_type): Likewise.
	* i386-tdep.c (i386_mmx_type, i386_sse_type): Likewise.
	* iq2000-tdep.c (iq2000_register_type): Likewise.
	* lm32-tdep.c (lm32_register_type, lm32_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68hc11-tdep.c (m68hc11_register_type, m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m88k-tdep.c (m88k_register_type, m88k_store_arguments): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_register_type, mips_pseudo_register_type,
	mips_print_fp_register): Likewise.
	* moxie-tdep.c (moxie_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type, mt_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64,
	rs6000_builtin_type_vec128): Likewise.
	* score-tdep.c (score_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type, sparc32_store_arguments):
	Likewise.
	* sparc64-tdep.c (sparc64_register_type, sparc64_store_arguments):
	Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* xstormy16-tdep.c (xstormy16_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type): Likewise.

	* mt-tdep.c (struct gdbarch_tdep): New data structure.
	(mt_gdbarch_init): Alloc TDEP structures.
	(mt_register_type): Cache coprocessor type in TDEP instead of
	static global variable.

	* xtensa-tdep.h (struct gdbarch_tdep): Add type_entries member.
	* xtensa-tdep.c (type_entries): Remove.
	(xtensa_register_type): Cache fixed-size types in TDEP instead
	of in global variable.
@
text
@d99 13
d133 1
a133 1
	    return builtin_type_m68881_ext;
d190 1
a190 1
	  && type != builtin_type_m68881_ext);
@


1.139
log
@        Updated copyright notices for most files.
@
text
@d127 1
a127 1
	return builtin_type_int32;
d132 1
a132 1
	return builtin_type_int0;
d144 1
a144 1
  return builtin_type_int32;
@


1.138
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d4 2
a5 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.137
log
@        * m68k-tdep.c (m68k_analyze_prologue): Fix length of lea insn.
@
text
@d123 1
a123 1
	return builtin_type_void_func_ptr;
d135 1
a135 1
    return builtin_type_void_func_ptr;
d138 1
a138 1
    return builtin_type_void_data_ptr;
d835 1
a835 1
  return extract_typed_address (buf, builtin_type_void_func_ptr);
@


1.136
log
@	* gdbarch.sh: Delete dwarf_reg_to_regnum.
	* gdbarch.c, gdbarch.h: Regenerated.
	* amd64-tdep.c, arm-tdep.c, h8300-tdep.c, hppa-linux-tdep.c,
	hppa-tdep.c, i386-tdep.c, m32c-tdep.c, m68k-tdep.c, mips-tdep.c,
	s390-tdep.c, xtensa-tdep.c: Do not set dwarf_reg_to_regnum.

	* gdbint.texinfo (Target Conditionals): Delete entry for
	gdbarch_dwarf_reg_to_regnum.
@
text
@d807 1
a807 1
      return pc + 6;
@


1.135
log
@Update m68k port for unwinder changes.
* m68k-tdep.c (m68k_frame_cache): Expect this_frame.
(m68k_frame_this_id, m68k_frame_prev_register): Update signature.
(m68k_frame_unwind): Use default_frame_sniffer.
(m68k_frame_sniffer): Remove.
(m68k_frame_base_address): Expect this_frame.
(m68k_dummy_id): Renamed from m68k_unwind_dummy_id.  Expect
this_frame.
(m68k_gdbarch_init): Use set_gdbarch_dummy_id,
dwarf2_append_unwinders, and frame_unwind_append_unwinder.
* m68klinux-tdep.c (m68k_linux_pc_in_sigtramp): Expect frame_info
parameter instead of pc value.
(m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
Expect this_frame.
(m68k_linux_sigtramp_frame_this_id)
(m68k_linux_sigtramp_frame_prev_register)
(m68k_linux_sigtramp_frame_sniffer): Update signature.
(m68k_linux_sigtramp_frame_unwind): Use
m68k_linux_sigtramp_frame_sniffer.
(m68k_linux_init_abi): Use frame_unwind_append_unwinder.

* m68klinux-nat.c (store_register): Fix typo.
@
text
@a1154 1
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, m68k_dwarf_reg_to_regnum);
@


1.134
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d841 1
a841 1
m68k_frame_cache (struct frame_info *next_frame, void **this_cache)
d862 1
a862 1
  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
d870 1
a870 1
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d872 2
a873 2
    m68k_analyze_prologue (get_frame_arch (next_frame), cache->pc,
			   frame_pc_unwind (next_frame), cache);
d885 1
a885 1
      frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
d903 1
a903 1
m68k_frame_this_id (struct frame_info *next_frame, void **this_cache,
d906 1
a906 1
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);
d916 3
a918 5
static void
m68k_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *valuep)
d920 1
a920 1
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);
d925 1
a925 12
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
	}
      return;
    }
d928 2
a929 13
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (get_frame_arch (next_frame), regnum));
	}
      return;
    }
d931 1
a931 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, (*realnump), valuep);
d938 3
a940 1
  m68k_frame_prev_register
a941 6

static const struct frame_unwind *
m68k_frame_sniffer (struct frame_info *next_frame)
{
  return &m68k_frame_unwind;
}
d944 1
a944 1
m68k_frame_base_address (struct frame_info *next_frame, void **this_cache)
d946 1
a946 1
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);
d960 1
a960 1
m68k_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
a961 1
  gdb_byte buf[4];
d964 1
a964 2
  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);
d967 1
a967 1
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
d1206 1
a1206 1
  set_gdbarch_unwind_dummy_id (gdbarch, m68k_unwind_dummy_id);
d1210 1
a1210 1
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
d1223 1
a1223 1
  frame_unwind_append_sniffer (gdbarch, m68k_frame_sniffer);
@


1.133
log
@	* alpha-tdep.c (alpha_heuristic_proc_start)
	(alpha_sigtramp_register_address): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.

	(alpha_heuristic_frame_unwind_cache): Use get_frame_arch to get at the
	current architecture by frame_info. Update alpha_heuristic_proc_start
	call.

	(alpha_sigtramp_frame_this_id, alpha_sigtramp_frame_prev_register): Use
	get_frame_arch to get at the current architecture by frame_info. Update
	alpha_sigtramp_register_address call.

	* arm-tdep.c (thumb_scan_prologue): Add gdbarch as parameter and replace
	current_gdbarch by gdbarch. Update caller.
	(convert_to_extended, convert_from_extended): Add endianess parameter
	for comparison. Update caller.
	(arm_extract_return_value, arm_store_return_value): Use
	get_regcache_arch to get at the current	architecture.

	* cris-tdep.c (cris_register_size): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.
	(cris_gdb_func, move_to_preg_op, none_reg_mode_move_from_preg_op): Add
	gdbarch as parameter. Update caller. Replace current_gdbarch by gdbarch.

	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM, E_PSEUDO_EXR_REGNUM, BINWORD): Add
	gdbarch	as parameter. Update caller.
	(h8300_init_frame_cache): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* hppa-tdep.c (skip_prologue_hard_way): Add gdbarch as parameter and
	update caller. Replace current_gdbarch by gdbarch.

	* m32c-tdep.c (m32c_skip_trampoline_code): Use get_frame_arch to get at
	the current architecture. Replace current_gdbarch by gdbarch.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Likewise.
	(STACK_CORRECTION, USE_PAGE_REGISTER): Replace M6811_TDEP by its
	expression. Add gdbarch as parameter and replace current_gdbarch with
	it. Update caller.
	(M6811_TDEP): Remove.
	(m68hc11_frame_prev_register): Use get_frame_arch to get at the current
	architecture.
	(m68hc11_scan_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch. Update caller.

	* m68k-tdep.c (m68k_analyze_prologue): Add gdbarch as parameter and
	update caller.
	(m68k_analyze_register_saves): Likewise. Also replace current_gdbarch
	by gdbarch.

	* rs6000-tdep.c (skip_prologue): Add gdbarch as parameter and update
	caller. Relace current_gdbarch by gdbarch.
	(altivec_register_p, spe_register_p): Likewise.
	* ppc-tdep.h (altivec_register_p, spe_register_p): Add gdbarch as
	parameter.
	* ppc-linux-nat.c (fetch_register, store_register): Update caller of
	altivec_register_p and spe_register_p.

	* score-tdep.c (score_fetch_inst): Add gdbarch as parameter. Update
	caller. Replace current_gdbarch by gdbarch.
	(score_analyze_prologue): use get_frame_arch to get at the current
	architecture.

	* sparc-tdep.h (sparc_analyze_prologue): Add gdbarch as parameter.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise. Replace
	current_gdbarch by gdbarch. Update caller.
	(sparc_frame_cache): Use get_frame_arch to get at the current
	architecture.
	* sparce64-tdep.c (sparc64_skip_prologue): Update call of
	sparc_analyze_prologue.

	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Add gdbarch as
	parameter.
@
text
@d375 3
a377 3
m68k_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache, gdb_byte *readbuf,
		   const gdb_byte *writebuf)
d410 3
a412 3
m68k_svr4_return_value (struct gdbarch *gdbarch, struct type *type,
			struct regcache *regcache, gdb_byte *readbuf,
			const gdb_byte *writebuf)
d449 1
a449 1
      return m68k_svr4_return_value (gdbarch, type, regcache,
@


1.132
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d693 2
a694 1
m68k_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
d708 1
a708 1
	      && gdbarch_tdep (current_gdbarch)->fpregs_present)
d792 2
a793 2
m68k_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		       struct m68k_frame_cache *cache)
d798 1
a798 1
  pc = m68k_analyze_register_saves (pc, current_pc, cache);
d823 1
a823 1
  pc = m68k_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache);
d872 2
a873 1
    m68k_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);
@


1.131
log
@	Updated copyright notices for most files.
@
text
@d815 1
a815 1
m68k_skip_prologue (CORE_ADDR start_pc)
@


1.130
log
@	* gdbarch.sh (stab_reg_to_regnum, dwarf_reg_to_regnum)
	( dwarf2_reg_to_regnum, sdb_reg_to_regnum, ecoff_reg_to_regnum): Add
	gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* xtensa-tdep.c (xtensa_reg_to_regnum): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* s390-tdep.c (s390_dwarf_reg_to_regnum): Likewise.
	* rs6000-tdep.c (rs6000_stab_reg_to_regnum)
	(rs6000_dwarf2_reg_to_regnum): Likewise.
	* mips-tdep.c (mips_stab_reg_to_regnum)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum): Likewise.
	* mep-tdep.c (mep_debug_reg_to_regnum): Likewise.
	* m32c-tdep.c (m32c_debug_info_reg_to_regnum): Likewise.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise
	* h8300-tdep.c (h8300s_dbg_reg_to_regnum)
	(h8300_dbg_reg_to_regnum): Likewise.
	* amd64-tdep.c (amd64_dwarf_reg_to_regnum): Likewise.
	* arch-utils.c (no_op_reg_to_regnum): Likewise.
	* arch-utils.h (no_op_reg_to_regnum): Likewise.
	* arm-tdep.c (arm_dwarf_reg_to_regnum): Likewise.
	* cris-tdep.c (cris_dwarf2_reg_to_regnum): Likewise.
	* hppa-tdep.c (hppa64_dwarf_reg_to_regnum): Likewise.
	* ia64-tdep.c (ia64_dwarf_reg_to_regnum): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.129
log
@	* gdbarch.sh (convert_register_p): Add gdbarch as parameter.
	* ia64-tdep.c (ia64_convert_register_p): Likewise.
	* i387-tdep.c (i387_convert_register_p): Likewise.
	* i387-tdep.h (i387_convert_register_p): Likewise.
	* alpha-tdep.c (alpha_convert_register_p): Likewise.
	* gdbarch.{c,h}: Regenerate.

	* rs6000-tdep.c (rs6000_convert_register_p): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* mips-tdep.c (mips_convert_register_p): Likewise.
	* m68k-tdep.c (m68k_convert_register_p): Likewise.
	* i386-tdep.c (i386_convert_register_p): Likewise.
@
text
@d530 1
a530 1
m68k_dwarf_reg_to_regnum (int num)
d538 1
a538 1
  else if (num < 24 && gdbarch_tdep (current_gdbarch)->fpregs_present)
d545 1
a545 2
    return gdbarch_num_regs (current_gdbarch)
	   + gdbarch_num_pseudo_regs (current_gdbarch);
@


1.128
log
@*** empty log message ***
@
text
@d171 1
a171 1
m68k_convert_register_p (int regnum, struct type *type)
d173 1
a173 1
  if (!gdbarch_tdep (current_gdbarch)->fpregs_present)
@


1.127
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d64 2
a65 1
m68k_local_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
@


1.126
log
@	* amd64-tdep.c (amd64_convert_register_p): Delete.
	(amd64_init_abi): Use i387_convert_register_p.
	* alpha-tdep.c (alpha_convert_register_p): Return zero for
	eight byte types.
	(alpha_register_to_value, alpha_value_to_register): Do not handle
	eight byte types.
	* i386-tdep.c (i386_convert_register_p): Use i387_convert_register_p.
	* i387-tdep.c (i387_convert_register_p): New.
	(i387_register_to_value, i387_value_to_register): Update comments.
	* i387-tdep.h (i387_convert_register_p): Declare.
	* ia64-tdep.c (ia64_convert_register_p): Return zero for
	builtin_type_ia64_ext.
	(ia64_gdbarch_init): Do not initialize builtin_type_ia64_ext here.
	(_initialize_ia64_tdep): Initialize builtin_type_ia64_ext here.
	* m68k-tdep.c (m68k_convert_register_p): Return zero for
	builtin_type_m68881_ext.
	(m68k_register_to_value, m68k_value_to_register): Update comments.

	* gdbint.texinfo (Register and Memory Data, Target Conditionals):
	Document that gdbarch_convert_register_p should return zero for no-op
	conversions.
@
text
@d157 1
a157 1
m68k_register_name (int regnum)
@


1.125
log
@	* NEWS: Document target described register support for PowerPC.
	* ppc-tdep.h: Remove ppc_spr constants.
	(struct gdbarch_tdep): Remove regs, ppc_sr0_regnum, and
	ppc_builtin_type_vec128 members.
	(PPC_R0_REGNUM, PPC_F0_REGNUM, PPC_PC_REGNUM, PPC_MSR_REGNUM)
	(PPC_CR_REGNUM, PPC_LR_REGNUM, PPC_CTR_REGNUM, PPC_XER_REGNUM)
	(PPC_FPSCR_REGNUM, PPC_MQ_REGNUM, PPC_SPE_UPPER_GP0_REGNUM)
	(PPC_SPE_ACC_REGNUM, PPC_SPE_FSCR_REGNUM, PPC_VR0_REGNUM)
	(PPC_VSCR_REGNUM, PPC_VRSAVE_REGNUM, PPC_NUM_REGS): New constants.
	* rs6000-tdep.c: Include preparsed descriptions.
	(init_sim_regno_table): Do not iterate over pseudo registers.
	Look up segment registers by name.  Use sim_spr_register_name
	for SPRs.
	(rs6000_register_sim_regno): Call init_sim_regno_table here.
	(rs6000_builtin_type_vec128): Delete.
	(rs6000_register_name): Only handle SPE pseudo registers and upper
	halves.  Call tdesc_register_name for everything else.
	(rs6000_register_type): Delete.  Replace with...
	(rs6000_pseudo_register_type): ...this new function.  Only handle
	SPE pseudo registers.
	(rs6000_register_reggroup_p): Delete.  Replace with...
	(rs6000_pseudo_register_reggroup_p): ...this new function.  Only
	handle SPE pseudo registers.
	(rs6000_convert_register_p): Use ppc_fp0_regnum instead of
	"struct reg".
	(rs6000_register_to_value, rs6000_value_to_register): Remove check
	of reg->fpr.
	(e500_register_reggroup_p): Delete.
	(STR, R, R4, R8, R16, F, P8, R32, R64, R0, A4, S, S4, SN4, S64)
	(COMMON_UISA_REGS, PPC_UISA_SPRS, PPC_UISA_NOFP_SPRS)
	(PPC_SEGMENT_REGS, PPC_OEA_SPRS, PPC_ALTIVEC_REGS, PPC_SPE_GP_REGS)
	(PPC_SPE_UPPER_GP_REGS, PPC_EV_PSEUDO_REGS): Delete macros.
	(registers_powerpc, registers_403, registers_403GC, registers_505)
	(registers_860, registers_601, registers_602, registers_603)
	(registers_604, registers_750, registers_7400, registers_e500): Delete
	variables.
	(struct variant): Delete nregs, npregs, num_tot_regs, and regs.  Add
	tdesc.
	(tot_num_registers, num_registers, num_pseudo_registers): Delete.
	(variants): Delete outdated comment.  Use standard target descriptions
	instead of "struct reg" arrays.
	(init_variants): Delete.
	(rs6000_gdbarch_init): Do not guess word size from the BFD
	architecture if we have a target description.  Select a variant
	before creating a new architecture.  Use the variant's target
	description if the target did not define a register layout.
	Validate target-supplied registers.  Reject mismatches.  Use
	fixed register numbers and new constants instead of magic
	numbers.  Call set_gdbarch_ps_regnum.  Call tdesc_use_registers.
	(_initialize_rs6000_tdep): Initialize the preparsed target
	descriptions.
	* target-descriptions.c (tdesc_predefined_types): Add int128 and
	uint128.
	(tdesc_find_register_early): New function.
	(tdesc_numbered_register): Use it.
	(tdesc_register_size): New function.
	(tdesc_use_registers): Take a target_desc argument.  Do not use
	gdbarch_target_desc.
	* target-descriptions.h (tdesc_use_registers): Update prototype
	and comment.
	(tdesc_register_size): New prototype.
	* Makefile.in (powerpc_32_c, powerpc_403_c, powerpc_403gc_c)
	(powerpc_505_c, powerpc_601_c, powerpc_602_c, powerpc_603_c)
	(powerpc_604_c, powerpc_64_c, powerpc_7400_c, powerpc_750_c)
	(powerpc_860_c, powerpc_e500_c, rs6000_c): New macros.
	(rs6000-tdep.o): Update.
	* arm-tdep.c (arm_gdbarch_init): Update call to tdesc_use_registers.
	* m68k-tdep.c (m68k_gdbarch_init): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.

	* gdb.texinfo (Predefined Target Types): Add int128
	and uint128.
	(Standard Target Features): Add PowerPC features.

	* gdb.xml/tdesc-regs.exp: Add PowerPC support.

	* sim-ppc.h (sim_spr_register_name): New prototype.

	* gdb-sim.c (regnum2spr): Rename to...
	(sim_spr_register_name): ... this.  Make global.
@
text
@d174 2
a175 1
  return (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FP0_REGNUM + 7);
d197 1
a197 2
  /* Convert to TYPE.  This should be a no-op if TYPE is equivalent to
     the extended floating-point format used by the FPU.  */
d221 1
a221 2
  /* Convert from TYPE.  This should be a no-op if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
@


1.124
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* m68k-tdep.c (m68k_register_to_value, m68k_value_to_register)
	(m68k_svr4_extract_return_value, m68k_svr4_store_return_value)
	(m68k_frame_prev_register, m68k_get_longjmp_target): Use
	get_regcache_arch or get_frame_arch to get at the current architecture
	by regcache or by frame, respectively.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_cache): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers)
	(store_register, old_store_inferior_registers, supply_gregset)
	(supply_fpregset, fill_fpregset): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc, m68k_dump_tdep):
	Replace current_gdbarch by gdbarch.
@
text
@d1260 1
a1260 1
    tdesc_use_registers (gdbarch, tdesc_data);
@


1.123
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d108 1
a108 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d112 2
a113 2
      if (regnum >= gdbarch_fp0_regnum (current_gdbarch)
	  && regnum <= gdbarch_fp0_regnum (current_gdbarch) + 7)
d133 1
a133 1
  if (regnum == gdbarch_pc_regnum (current_gdbarch))
d185 2
a186 1
  struct type *fpreg_type = register_type (current_gdbarch, M68K_FP0_REGNUM);
d210 2
a211 1
  struct type *fpreg_type = register_type (current_gdbarch, M68K_FP0_REGNUM);
d289 2
a290 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d294 1
a294 2
      struct type *fpreg_type = register_type 
	(current_gdbarch, M68K_FP0_REGNUM);
d330 2
a331 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d335 1
a335 2
      struct type *fpreg_type = register_type 
	(current_gdbarch, M68K_FP0_REGNUM);
d834 1
a834 1
  frame_unwind_register (next_frame, gdbarch_pc_regnum (current_gdbarch), buf);
d949 1
a949 1
		       register_size (current_gdbarch, regnum));
d1015 1
d1025 2
a1026 2
  buf = alloca (gdbarch_ptr_bit (current_gdbarch) / TARGET_CHAR_BIT);
  sp = get_frame_register_unsigned (frame, gdbarch_sp_regnum (current_gdbarch));
d1029 1
a1029 2
			  buf,
			  gdbarch_ptr_bit (current_gdbarch) / TARGET_CHAR_BIT))
d1032 1
a1032 1
  jb_addr = extract_unsigned_integer (buf, gdbarch_ptr_bit (current_gdbarch)
d1036 1
a1036 1
			  gdbarch_ptr_bit (current_gdbarch) / TARGET_CHAR_BIT))
d1039 1
a1039 1
  *pc = extract_unsigned_integer (buf, gdbarch_ptr_bit (current_gdbarch)
d1267 1
a1267 1
m68k_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
d1269 1
a1269 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.122
log
@	* m68k-tdep.c (m68k_ps_type): New.
	(m68k_init_types): New.
	(m68k_register_type): Use m68k_ps_type for PS register.
	(_initialize_m68k_tdep): Call m68k_init_types.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.121
log
@	* m68k-tdep.c (m68k_gdbarch_init): Don't infer coldfire flavour
	from the generic m68k arch.
@
text
@d72 26
d141 3
d1281 3
@


1.120
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1113 1
a1113 1
  if (info.bfd_arch_info)
d1119 2
a1120 2
	  && (*info.bfd_arch_info->compatible) 
	  (info.bfd_arch_info, coldfire_arch))
@


1.119
log
@	* gdbarch.sh (get_longjmp_target): Add FRAME argument.
	* gdbarch.c, gdbarch.h: Regenerate.
	* infrun.c (handle_inferior_event): Pass current frame to
	gdbarch_get_longjmp_target.

	* alpha-tdep.c (alpha_get_longjmp_target): Add FRAME argument.
	Read registers from FRAME instead of using read_register.
	Use get_frame_arch instead of current_gdbarch.
	* arm-tdep.c (arm_get_longjmp_target): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Likewise.
	(mips64_linux_get_longjmp_target): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Likewise.
@
text
@d88 2
a89 1
      if (regnum >= FP0_REGNUM && regnum <= FP0_REGNUM + 7)
d109 1
a109 1
  if (regnum == PC_REGNUM)
d805 1
a805 1
  frame_unwind_register (next_frame, PC_REGNUM, buf);
d996 1
a996 1
  sp = get_frame_register_unsigned (frame, SP_REGNUM);
@


1.118
log
@	* m68k-tdep.h (enum m68k_flavour): New.
	(struct gdbarch_tdep): New fields
	float_return, flavour and fpregs_present.
	* m68k-tdep.c (m68k_register_type): Use
	fpregs_present and conditionalize floating
	registers type on flavour.
	(m68k_register_names): New.
	(m68k_register_name): Use the above.
	(m68k_convert_register_p): Consult fpregs_present.
	(m68k_register_to_value, m68k_value_to_register):
	Use register_type to obtain the type of floating
	point registers.
	(m68k_svr4_extract_return_value): Check tdep->float_return.
	Use register_type to get the type of floating
	point regiters.
	(m68k_svr4_store_return_value): Likewise.
	(m68k_dwarf_reg_to_regnum): Check tdep->fpregs_present.
	(m68k_analyze_register_saves): Likewise.
	(m68k_gdbarch_init): Extract infromation
	from XML description, if present.  Guess coldfire by
	looking at the file, if present. Conditionalize
	setting of long double format.  Set decr_pc_after_break
	to 2 on coldfire and fido.  Enable XML-driven
	register description.
	* m68kbsd-tdep.c (m68kbsd_fpreg_offset): Use
	size of tdep->fpreg_type, as opposed to hardcoded value.
	* Makefile.in (m68k-tdep.o): Update dependencies.
@
text
@d981 1
a981 1
m68k_get_longjmp_target (CORE_ADDR *pc)
d985 1
a985 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d995 1
a995 1
  sp = read_register (SP_REGNUM);
@


1.117
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_PTR_BIT): Replace with gdbarch_ptr_bit.
	* solib-svr4.c (svr4_truncate_ptr): Likewise.
	* solib-pa64.c (read_dynamic_info): Likewise.
	* solib-legacy.c (legacy_svr4_fetch_link_map_offsets): Likewise.
	* solib.c (info_sharedlibrary_command): Likewise.
	* s390-nat.c (SUBOFF): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	* procfs.c (info_proc_mappings): Likewise.
	* printcmd.c (decode_format): Likewise.
	* nto-tdep.c (nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* jv-valprint.c (java_value_print): Likewise.
	* jv-lang.c (get_java_object_header_size): Likewise.
	* hppa-tdep.c (skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_skip_trampoline_code)
	(hppa_hpux_unwind_adjust_stub): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* gdbtypes.c (make_pointer_type, make_reference_type)
	(smash_to_memberptr_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d39 1
d84 1
a84 2
  if (regnum >= FP0_REGNUM && regnum <= FP0_REGNUM + 7)
    return builtin_type_m68881_ext;
d86 23
a108 1
  if (regnum == M68K_FPI_REGNUM || regnum == PC_REGNUM)
a110 4
  if (regnum == M68K_FPC_REGNUM || regnum == M68K_FPS_REGNUM
      || regnum == PS_REGNUM)
    return builtin_type_int32;

d117 8
d131 1
a131 9
  static char *register_names[] = {
    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
    "a0", "a1", "a2", "a3", "a4", "a5", "fp", "sp",
    "ps", "pc",
    "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7",
    "fpcontrol", "fpstatus", "fpiaddr", "fpcode", "fpflags"
  };

  if (regnum < 0 || regnum >= ARRAY_SIZE (register_names))
d135 1
a135 1
    return register_names[regnum];
d144 2
d157 1
d170 1
a170 1
  convert_typed_floating (from, builtin_type_m68881_ext, to, type);
d181 1
d193 1
a193 1
  convert_typed_floating (from, type, to, builtin_type_m68881_ext);
d259 1
d261 1
a261 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d263 2
d266 1
a266 1
      convert_typed_floating (buf, builtin_type_m68881_ext, valbuf, type);
d300 1
d302 1
a302 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d304 2
d307 1
a307 1
      convert_typed_floating (valbuf, type, buf, builtin_type_m68881_ext);
d508 1
a508 1
  else if (num < 24)
d677 2
a678 1
	  if (op == P_FMOVEMX_SP)
d1039 18
d1058 78
a1135 4
  /* find a candidate among the list of pre-declared architectures. */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return (arches->gdbarch);
d1139 2
d1142 4
a1145 2
  set_gdbarch_long_double_format (gdbarch, floatformats_m68881_ext);
  set_gdbarch_long_double_bit (gdbarch, 96);
d1155 2
d1173 20
d1196 1
d1229 3
@


1.116
log
@	* remote.c (process_g_packet): Don't check size.
	* gdbarch.sh: Remove register_bytes_ok.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* m68k-tdep.c (REGISTER_BYTES_NOFP): Remove.
	(m68k_register_bytes_ok): Remove.
	(m68k_gdbarch_init): Don't register m68k_register_bytes_ok.
@
text
@d965 1
a965 1
  buf = alloca (TARGET_PTR_BIT / TARGET_CHAR_BIT);
d969 2
a970 1
			  buf, TARGET_PTR_BIT / TARGET_CHAR_BIT))
d973 2
a974 1
  jb_addr = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
d977 1
a977 1
			  TARGET_PTR_BIT / TARGET_CHAR_BIT))
d980 2
a981 1
  *pc = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
@


1.115
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@a56 4

#define REGISTER_BYTES_FP (16*4 + 8 + 8*12 + 3*4)
#define REGISTER_BYTES_NOFP (16*4 + 8)

a71 8

static int
m68k_register_bytes_ok (long numbytes)
{
  return ((numbytes == REGISTER_BYTES_FP)
	  || (numbytes == REGISTER_BYTES_NOFP));
}

a1034 1
  set_gdbarch_register_bytes_ok (gdbarch, m68k_register_bytes_ok);
@


1.114
log
@	* m68klinux-nat.c: Remove #ifndef USE_PROC_FS check.
	* m68k-tdep.c: Remove code within #ifdef USE_PROC_FS.

	* mips-linux-nat.c: Include "gregset.h".
	(supply_gregset, fill_gregset, supply_fpregset, fill_fpregset): Move
	from mips-linux-tdep.c.  Change parameter type to gdb_gregset_t.
	* mips-linux-tdep.c (supply_gregset, fill_gregset, supply_fpregset,
	fill_fpregset): Move to mips-linux-nat.c.

	* Makefile.in (m68k-tdep.o, mips-linux-nat.o): Update dependencies.
@
text
@d499 2
a500 1
    return NUM_REGS + NUM_PSEUDO_REGS;
@


1.113
log
@	* config/m68k/tm-monitor.h: Delete file.
	* config/m68k/monitor.mt (DEPRECATED_TM_FILE): Remove.
	* m68k-tdep.c (m68k_gdbarch_init): set_gdbarch_decr_pc_after_break
	call moved to ...
	* m68kbsd-tdep.c (m68kbsd_init_abi): ... here and ...
	* m68klinux-tdep.c (m68k_linux_init_abi): ... here.
@
text
@a955 133
#ifdef USE_PROC_FS		/* Target dependent support for /proc */

#include <sys/procfs.h>

/* Prototypes for supply_gregset etc. */
#include "gregset.h"

/*  The /proc interface divides the target machine's register set up into
   two different sets, the general register set (gregset) and the floating
   point register set (fpregset).  For each set, there is an ioctl to get
   the current register set and another ioctl to set the current values.

   The actual structure passed through the ioctl interface is, of course,
   naturally machine dependent, and is different for each set of registers.
   For the m68k for example, the general register set is typically defined
   by:

   typedef int gregset_t[18];

   #define      R_D0    0
   ...
   #define      R_PS    17

   and the floating point set by:

   typedef      struct fpregset {
   int  f_pcr;
   int  f_psr;
   int  f_fpiaddr;
   int  f_fpregs[8][3];         (8 regs, 96 bits each)
   } fpregset_t;

   These routines provide the packing and unpacking of gregset_t and
   fpregset_t formatted data.

 */

/* Atari SVR4 has R_SR but not R_PS */

#if !defined (R_PS) && defined (R_SR)
#define R_PS R_SR
#endif

/*  Given a pointer to a general register set in /proc format (gregset_t *),
   unpack the register contents and supply them as gdb's idea of the current
   register values. */

void
supply_gregset (gregset_t *gregsetp)
{
  int regi;
  greg_t *regp = (greg_t *) gregsetp;

  for (regi = 0; regi < R_PC; regi++)
    {
      regcache_raw_supply (current_regcache, regi, (char *) (regp + regi));
    }
  regcache_raw_supply (current_regcache, PS_REGNUM, (char *) (regp + R_PS));
  regcache_raw_supply (current_regcache, PC_REGNUM, (char *) (regp + R_PC));
}

void
fill_gregset (gregset_t *gregsetp, int regno)
{
  int regi;
  greg_t *regp = (greg_t *) gregsetp;

  for (regi = 0; regi < R_PC; regi++)
    {
      if (regno == -1 || regno == regi)
	regcache_raw_collect (current_regcache, regi, regp + regi);
    }
  if (regno == -1 || regno == PS_REGNUM)
    regcache_raw_collect (current_regcache, PS_REGNUM, regp + R_PS);
  if (regno == -1 || regno == PC_REGNUM)
    regcache_raw_collect (current_regcache, PC_REGNUM, regp + R_PC);
}

#if defined (FP0_REGNUM)

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), unpack the register contents and supply them as gdb's
   idea of the current floating point register values. */

void
supply_fpregset (fpregset_t *fpregsetp)
{
  int regi;
  char *from;

  for (regi = FP0_REGNUM; regi < M68K_FPC_REGNUM; regi++)
    {
      from = (char *) &(fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
      regcache_raw_supply (current_regcache, regi, from);
    }
  regcache_raw_supply (current_regcache, M68K_FPC_REGNUM,
		       (char *) &(fpregsetp->f_pcr));
  regcache_raw_supply (current_regcache, M68K_FPS_REGNUM,
		       (char *) &(fpregsetp->f_psr));
  regcache_raw_supply (current_regcache, M68K_FPI_REGNUM,
		       (char *) &(fpregsetp->f_fpiaddr));
}

/*  Given a pointer to a floating point register set in /proc format
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */

void
fill_fpregset (fpregset_t *fpregsetp, int regno)
{
  int regi;

  for (regi = FP0_REGNUM; regi < M68K_FPC_REGNUM; regi++)
    {
      if (regno == -1 || regno == regi)
	regcache_raw_collect (current_regcache, regi,
			      &fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
    }
  if (regno == -1 || regno == M68K_FPC_REGNUM)
    regcache_raw_collect (current_regcache, M68K_FPC_REGNUM,
			  &fpregsetp->f_pcr);
  if (regno == -1 || regno == M68K_FPS_REGNUM)
    regcache_raw_collect (current_regcache, M68K_FPS_REGNUM,
			  &fpregsetp->f_psr);
  if (regno == -1 || regno == M68K_FPI_REGNUM)
    regcache_raw_collect (current_regcache, M68K_FPI_REGNUM,
			  &fpregsetp->f_fpiaddr);
}

#endif /* defined (FP0_REGNUM) */

#endif /* USE_PROC_FS */
@


1.112
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@a1170 1
  set_gdbarch_decr_pc_after_break (gdbarch, 2);
@


1.111
log
@	* avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c, m68k-tdep.c, mips-linux-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c: Include "gdbtypes.h" instead of "floatformat.h".
	* Makefile.in (avr-tdep.o, hppabsd-tdep.o, hppa-tdep.o, i386-tdep.o)
	(ia64-tdep.o, m68k-tdep.o, mips-linux-tdep.o, ppcobsd-tdep.o)
	(sparc-linux-tdep.o): Update.
@
text
@d822 1
a822 1
  cache->pc = frame_func_unwind (next_frame);
@


1.110
log
@	* doublest.c (floatformat_from_length): Use the right element from
	gdbarch floatformats.
	(floatformat_from_type, extract_typed_floating)
	(store_typed_floating): Likewise.
	* doublest.h: Remove declarations for undefined floatformat arrays.
	* gdbarch.sh (float_format, double_format, long_double_format): Change
	to pairs.
	(pformat): Update for pairs.
	* gdbarch.c, gdbarch.h: Regenerated.
	* gdbtypes.c (floatformats_ieee_single, floatformats_ieee_double)
	(floatformats_ieee_double_littlebyte_bigword)
	(floatformats_i387_ext, floatformats_m68881_ext, floatformats_arm_ext)
	(floatformats_ia64_spill, floatformats_ia64_quad, floatformats_vax_f)
	(floatformats_vax_d): New variables.
	(builtin_type_ieee_single, builtin_type_ieee_double)
	(builtin_type_arm_ext, builtin_type_ia64_spill)
	(builtin_type_ia64_quad): Replace arrays with individual types.
	(builtin_type_ieee_single_big, builtin_type_ieee_single_little)
	(builtin_type_ieee_double_big, builtin_type_ieee_double_little)
	(builtin_type_ieee_double_littlebyte_bigword, builtin_type_i960_ext)
	(builtin_type_m88110_ext, builtin_type_m88110_harris_ext)
	(builtin_type_arm_ext_big, builtin_type_arm_ext_littlebyte_bigword)
	(builtin_type_ia64_spill_big, builtin_type_ia64_spill_little)
	(builtin_type_ia64_quad_big, builtin_type_ia64_quad_little): Delete
	unused and endian-specific types.
	(recursive_dump_type): Update for floatformat pairs.
	(build_flt): Move higher.  Handle bit == -1.  Take a floatformat pair.
	(build_gdbtypes): Use build_flt.
	(_initialize_gdbtypes): Update set of initialized types.
	* gdbtypes.h: Update declarations to match gdbtypes.c.
	(struct main_type): Store a pointer to two floatformats.
	* arch-utils.c (default_float_format, default_double_format): Delete.
	* arch-utils.h (default_float_format, default_double_format): Delete.

	* arm-tdep.c, avr-tdep.c, hppa-tdep.c, hppabsd-tdep.c, i386-tdep.c,
	ia64-tdep.c,  iq2000-tdep.c, m68k-tdep.c, m88k-tdep.c,
	mips-linux-tdep.c, mips-tdep.c, mt-tdep.c, ppcobsd-tdep.c,
	sparc-linux-tdep.c, sparc-tdep.c, sparcnbsd-tdep.c, spu-tdep.c,
	vax-tdep.c, alpha-tdep.c, ppc-sysv-tdep.c: Update.
@
text
@d28 1
a28 1
#include "floatformat.h"
@


1.109
log
@Copyright updates for 2007.
@
text
@d1160 1
a1160 1
  set_gdbarch_long_double_format (gdbarch, &floatformat_m68881_ext);
@


1.108
log
@	* m68k-tdep.c (m68k_analyze_register_saves): Fix decoding of
	`move.l %R,-(%sp)'.
@
text
@d3 2
a4 2
   Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
@


1.107
log
@	* m68k-tdep.c (m68k_frame_align): New.
	(m68k_gdbarch_init): Set frame_align here.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d680 1
a680 1
	  else if ((op & 0170677) == P_MOVEL_SP)
d683 1
a683 1
	      regno = ((op & 07000) >> 9) | ((op & 0100) >> 3);
@


1.106
log
@	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): New.
	(m68k_gdbarch_init): Set it for dwarf & dwarf2 reg number
	conversion. Use M68K_NUM_REGS for number of regs.
@
text
@d416 10
d1168 1
@


1.105
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d470 22
d1163 2
d1168 1
a1168 1
  set_gdbarch_num_regs (gdbarch, 29);
@


1.105.12.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@a415 10
/* Always align the frame to a 4-byte boundary.  This is required on
   coldfire and harmless on the rest.  */

static CORE_ADDR
m68k_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align the stack to four bytes.  */
  return sp & ~3;
}

a469 22

/* Convert a dwarf or dwarf2 regnumber to a GDB regnum.  */

static int
m68k_dwarf_reg_to_regnum (int num)
{
  if (num < 8)
    /* d0..7 */
    return (num - 0) + M68K_D0_REGNUM;
  else if (num < 16)
    /* a0..7 */
    return (num - 8) + M68K_A0_REGNUM;
  else if (num < 24)
    /* fp0..7 */
    return (num - 16) + M68K_FP0_REGNUM;
  else if (num == 25)
    /* pc */
    return M68K_PC_REGNUM;
  else
    return NUM_REGS + NUM_PSEUDO_REGS;
}

a1135 1
  set_gdbarch_frame_align (gdbarch, m68k_frame_align);
a1140 2
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, m68k_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, m68k_dwarf_reg_to_regnum);
d1144 1
a1144 1
  set_gdbarch_num_regs (gdbarch, M68K_NUM_REGS);
@


1.105.2.1
log
@	* gdb/m68k-tdep.c (M68K_FPREG_TYPE, M68K_LONG_DOUBLE_FORMAT,
	M68K_RETURN_FP0): New.  Set for Coldfire.
	(m68k_register_type, m68k_register_to_value,
	m68k_svr4_extract_return_value, m68k_svr4_store_return_value,
	m68k_gdbarch_init): Use them.
@
text
@a41 11
/* Set the floating point register type.  This is a stop gap measure
   until we can implement a more flexible general solution.  */
#if 0
#define M68K_FPREG_TYPE builtin_type_m68881_ext
#define M68K_LONG_DOUBLE_FORMAT floatformat_m68881_ext
#define M68K_RETURN_FP0 1
#else
#define M68K_FPREG_TYPE builtin_type_double
#define M68K_LONG_DOUBLE_FORMAT floatformat_ieee_double_big
#define M68K_RETURN_FP0 0
#endif
d96 1
a96 1
    return M68K_FPREG_TYPE;
d161 1
a161 1
  convert_typed_floating (from, M68K_FPREG_TYPE, to, type);
d183 1
a183 1
  convert_typed_floating (from, type, to, M68K_FPREG_TYPE);
d250 1
a250 1
  if (M68K_RETURN_FP0 && TYPE_CODE (type) == TYPE_CODE_FLT)
d253 1
a253 1
      convert_typed_floating (buf, M68K_FPREG_TYPE, valbuf, type);
d288 1
a288 1
  if (M68K_RETURN_FP0 && TYPE_CODE (type) == TYPE_CODE_FLT)
d291 1
a291 1
      convert_typed_floating (valbuf, type, buf, M68K_FPREG_TYPE);
d1128 2
a1129 2
  set_gdbarch_long_double_format (gdbarch, &M68K_LONG_DOUBLE_FORMAT);
  set_gdbarch_long_double_bit (gdbarch, M68K_LONG_DOUBLE_FORMAT.totalsize);
@


1.105.2.2
log
@	* gdb/m68k-tdep.c (M68K_FPREG_SIZE): Define.
	(REGISTER_BYTES_FP): Use it.

	* gdb/configure.tgt (m68k-*-uclinux*): target is linux.
@
text
@a45 1
#define M68K_FPREG_SIZE 12
a49 1
#define M68K_FPREG_SIZE 8
d68 2
a70 1
#define REGISTER_BYTES_FP (REGISTER_BYTES_NOFP + 8*M68K_FPREG_SIZE + 3*4)
@


1.105.2.3
log
@i	* gdb/configure.tgt (gdb_osabi): uclinux is like linux.
	* gdb/m68k-tdep.c (m68k_svr4_extract_return_value): Return value
	is never in %a0.
	(m68k_reg_struct_return_p): Duplicate gcc's struct mode algorithm.
	(m68k_svr4_return_value) Use VALUE_STRUCT_CONVENTION.  do not rely
	on %a0.
	(m68k_push_dummy_call): Force stack alignment.
	(m68k_svr4_init_abi): Set struct_return convention.
	(m68k_aout_init_abi): New.
	(m68k_gdbarch_init): Default to bare elf ABI that gcc provides.
	* gdb/m68k-tdep.h (m68k_aout_init_abi): Declare.
	* gdb/m68kbsd-tdep.c (m68kbsd_aout_init_abi): Use m68k_aout_init_abi.
	(m68kbsd_elf_init_abi): Add comment.
	* gdb/m68klinux-tdep.c (m68k_linux_init_abi): Just set the struct
	pointer register here.
@
text
@a266 2
#if 0
  /* GCC never differentiates pointer return types this way.  */
a268 1
#endif
a324 3
  int align;
  int ix;
  struct type *union_field_type = NULL;
d331 1
a331 82
  /* Unfortunately GCC incorrectly implements this optimization.
     Rather than simply return all small structs, or even just those
     of size 2^N, it uses the mode of the structure to determine this.
     BLKmode structs will be returned by memory and QI,HI,SI,DI,SF&DF
     mode structs will be returned by register.  For m68k a struct is
     BLKmode unless it's size is 2^N and the mode for that size does
     not need a greater alignment than the structure itself.  Unions
     will get the mode of last member whose size matches that of the
     union itself.  This is horrible.  */
  
  if (len > 8 || (len & -len) != len)
    /* Length is not 2^n or is too big. */
    return 0;

  align = len > 4 ? 4 : len;
  for (ix = 0; ix != TYPE_NFIELDS (type); ix++)
    {
      struct type *field_type;
      int field_len;
      
      if (TYPE_FIELD_STATIC (type, ix))
	/* Skip static fields.  */
	continue;

      field_type = TYPE_FIELD_TYPE (type, ix);
      field_type = check_typedef (field_type);
      field_len = TYPE_LENGTH (field_type);
      
      if (code == TYPE_CODE_STRUCT)
	{
	  /* Look through arrays.  */
	  while (TYPE_CODE (field_type) == TYPE_CODE_ARRAY)
	    {
	      field_type = TYPE_TARGET_TYPE (field_type);
	      field_type = check_typedef (field_type);
	      field_len = TYPE_LENGTH (field_type);
	    }
	  
	  /* If the field's alignment is finer than the structs, we
	     won't be in registers. */
	  if (field_len < align)
	    return 0;

	  /* If the field itself is a struct or union, then check it
	     can be passed in registers.  */
	  if ((TYPE_CODE (field_type) == TYPE_CODE_STRUCT
	       || TYPE_CODE (field_type) == TYPE_CODE_UNION)
	      && !m68k_reg_struct_return_p (gdbarch, field_type))
	    return 0;
	}
      else
	{
	  /* If this field accounts for the whole union, remember it.
	     Note that we remember the last such field to match GCC's
	     algorithm.  */
	  if (field_len == len)
	    union_field_type = field_type;
	}
    }

  if (code == TYPE_CODE_UNION)
    {
      if (!union_field_type)
	return 0;
      /* Look through arrays. */
      while (TYPE_CODE (union_field_type) == TYPE_CODE_ARRAY)
	{
	  union_field_type = TYPE_TARGET_TYPE (union_field_type);
	  union_field_type = check_typedef (union_field_type);
	}
      /* If this field's alignment is too small, then we won't be in
	 registers.  */
      if (TYPE_LENGTH (union_field_type) < align)
	return 0;
      
      if (TYPE_CODE (union_field_type) == TYPE_CODE_STRUCT
	  || TYPE_CODE (union_field_type) == TYPE_CODE_UNION)
	return m68k_reg_struct_return_p (gdbarch, union_field_type);
    }
  
  /* It will be returned in registers */
  return 1;
d385 19
a403 5
      /* Although they SYSV ABI specifies that a function returning a
	 structure this way should preserve %a0, GCC doesn't do that.
	 Furthermore there's no point changeing GCC to make it do it,
	 as that would just be bloat. */
      return RETURN_VALUE_STRUCT_CONVENTION;
a437 3
  /* Align the stack down to 4 bytes.  Needed for coldfire. */
  sp &= ~3;
  
d1117 1
a1117 1
  /* SVR4 uses %a0.  */
a1118 14
  tdep->struct_return = reg_struct_return;
}

/* a.out */

void
m68k_aout_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  set_gdbarch_return_value (gdbarch, m68k_return_value);

  tdep->struct_value_regnum = M68K_A1_REGNUM;
  tdep->struct_return = reg_struct_return;
a1165 1
  /* Function call & return */
d1167 1
a1167 5
  /* These values are for bare metal -- os specific ABIs can override
     them */
  set_gdbarch_return_value (gdbarch, m68k_svr4_return_value);
  tdep->struct_value_regnum = M68K_A0_REGNUM;
  tdep->struct_return = reg_struct_return;
@


1.105.2.4
log
@	* gdb/m68k-tdep.c (m68k_dwarf_reg_to_regnum): New.
	(m68k_gdbarch_init): Set it for dwarf & dwarf2 reg number
	conversion. Use M68K_NUM_REGS for number of regs.
@
text
@a557 22

/* Convert a dwarf or dwarf2 regnumber to a GDB regnum */

static int
m68k_dwarf_reg_to_regnum (int num)
{
  if (num < 8)
    /* d0..7 */
    return (num - 0) + M68K_D0_REGNUM;
  else if (num < 16)
    /* a0..7 */
    return (num - 8) + M68K_A0_REGNUM;
  else if (num < 24)
    /* fp0..7 */
    return (num - 16) + M68K_FP0_REGNUM;
  else if (num == 25)
    /* pc */
    return M68K_PC_REGNUM;
  else
    return NUM_REGS + NUM_PSEUDO_REGS;
}

a1242 2
  set_gdbarch_dwarf_reg_to_regnum (gdbarch, m68k_dwarf_reg_to_regnum);
  set_gdbarch_dwarf2_reg_to_regnum (gdbarch, m68k_dwarf_reg_to_regnum);
d1246 1
a1246 1
  set_gdbarch_num_regs (gdbarch, M68K_NUM_REGS);
@


1.105.2.5
log
@	* gdb/m68k-tdep.c (M68K_FPREG_SIZE): Remove.
	(REGISTER_BYTES_FP): Use tdep->fpreg_type.
	(m68k_register_bytes_ok): adjust.
	(m68k_register_type): Use tdep->fpreg_type.
	(m68k_register_to_value, m68k_value_to_register): Likewise.
	(m68k_svr4_extract_return_value): Use tdep->float_return &
	tdep->fpreg_type.
	(m68k_svr4_store_return_value): Likewise.
	(m68k_gdbarch_init): Set tdep->float_return & tdep->fpreg_type.
	* gdb/m68k-tdep.h (struct gdbarch_tdep): Add floar_return &
	fpreg_type fields.
	* gdb/m68kbsd-tdep.c (m68kbsd_fpreg_offset): Use tdep->fpreg_type.
@
text
@d46 1
d51 1
d71 1
a71 1
#define REGISTER_BYTES_FP(ARCH) (REGISTER_BYTES_NOFP + 8*TYPE_LENGTH(*gdbarch_tdep(ARCH)->fpreg_type) + 3*4)
d92 1
a92 1
  return ((numbytes == REGISTER_BYTES_FP (current_gdbarch))
d108 1
a108 1
    return *gdbarch_tdep (gdbarch)->fpreg_type;
d173 1
a173 2
  convert_typed_floating (from, *gdbarch_tdep (current_gdbarch)->fpreg_type,
			  to, type);
d195 1
a195 2
  convert_typed_floating (from, type, to,
			  *gdbarch_tdep (current_gdbarch)->fpreg_type);
a260 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d262 1
a262 1
  if (tdep->float_return && TYPE_CODE (type) == TYPE_CODE_FLT)
d265 1
a265 1
      convert_typed_floating (buf, *tdep->fpreg_type, valbuf, type);
a301 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d303 1
a303 1
  if (tdep->float_return && TYPE_CODE (type) == TYPE_CODE_FLT)
d306 1
a306 1
      convert_typed_floating (valbuf, type, buf, *tdep->fpreg_type);
a1286 2
  tdep->float_return = M68K_RETURN_FP0;
  tdep->fpreg_type = &M68K_FPREG_TYPE;
d1297 2
@


1.105.2.6
log
@	* gdb/m68k-tdep.c (m68k_svr4_extract_return_value): Use
	tdep->ptr_value_regnum for pointer returns.
	(m68k_svr4_store_return_value): Likewise.
	(m68k_reg_struct_return_r): New, broken out of ...
	(m68k_reg_struct_return_p): ... here.  Implement gcc's structure
	mode algorithm.
	(m68k_svr4_init_abi, m68k_aout_init_abi): Set ptr_value_regnum.
	(m68k_gdbarch_init): Likewise.
	* gdb/m68k-tdep.h (struct gdbarch_tdep): Add ptr_value_regnum
	field.
@
text
@d268 2
d271 2
a272 3
    regcache_raw_read (regcache,
		       gdbarch_tdep (current_gdbarch)->ptr_value_regnum,
		       valbuf);
d312 4
a315 3
    regcache_raw_write (regcache,
			gdbarch_tdep (current_gdbarch)->ptr_value_regnum,
			valbuf);
d322 1
a322 10
   GDBARCH.
   
   Unfortunately GCC incorrectly implements this optimization.  Rather
   than simply return all small structs, or even just those of size
   2^N, it uses the mode of the structure to determine this.  BLKmode
   structs will be returned by memory and QI,HI,SI,DI,SF&DF mode
   structs will be returned by register.  For m68k a struct is BLKmode
   unless it's size is 2^N and the mode for that size does not need a
   greater alignment than the structure itself.  This is horrible.  */
  
d325 1
a325 1
m68k_reg_struct_return_r (struct type *type, int *align_p)
d327 1
d330 1
a330 2
  int field_align = 1;
  int my_align = len > 2 ? 2 : len;
d332 16
d349 2
a350 9
  if (code != TYPE_CODE_STRUCT && code != TYPE_CODE_UNION)
    {
      if (align_p && my_align > *align_p)
	*align_p = my_align;
      return 1;
    }
  
  if ((len & -len) != len)
    /* Length is not 2^n. */
d353 1
d367 1
a367 2
      /* Look through arrays.  */
      while (TYPE_CODE (field_type) == TYPE_CODE_ARRAY)
d369 19
a387 3
	  field_type = TYPE_TARGET_TYPE (field_type);
	  field_type = check_typedef (field_type);
	  field_len = TYPE_LENGTH (field_type);
d389 9
d399 13
a411 1
      if (!m68k_reg_struct_return_r (field_type, &field_align))
d413 4
a417 3

  if (align_p && field_align > *align_p)
    *align_p = field_align;
d419 2
a420 27
  return align_p || my_align <= field_align;
}

/* Return non-zero if TYPE, which is assumed to be a structure or
   union type, should be returned in registers for architecture
   GDBARCH.  */

static int
m68k_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
  int align;
  int ix;
  struct type *union_field_type = NULL;

  gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION);

  if (tdep->struct_return == pcc_struct_return)
    return 0;

  if (len > 8)
    /* Length is too big. */
    return 0;

  return m68k_reg_struct_return_r (type, NULL);
a1219 2
  /* Pointers are returned in %a0 */
  tdep->ptr_value_regnum = M68K_A0_REGNUM;
a1230 1
  /* aout uses %a1 */
a1232 2
  /* Pointers are returned in %a0 */
  tdep->ptr_value_regnum = M68K_A0_REGNUM;
a1288 1
  tdep->ptr_value_regnum = M68K_D0_REGNUM;
@


1.105.2.7
log
@	gdb/
	* m68k-tdep.c (m68k_frame_align): New.
	(m68k_push_dummy_call): Don't align here.
	(m68k_gdbarch_init): Set frame_align here.
@
text
@a487 10
/* Always align the frame to a 4-byte boundary.  This is required on
   some platforms and harmless on the rest.  */

static CORE_ADDR
m68k_frame_align (struct gdbarch *gdbarch, CORE_ADDR sp)
{
  /* Align the stack to four bytes.  */
  return sp & ~3;
}

d498 3
a1251 1
  set_gdbarch_frame_align (gdbarch, m68k_frame_align);
@


1.105.2.8
log
@	gdb/
	* m68k-tdep.c (m68k_frame_align): Say which archs need alignment.

	gdb/testsuite/
	* gdb.base/charset.exp: Use ${srcfile}.
@
text
@d489 1
a489 1
   Coldfire cores and harmless on the others.  */
@


1.104
log
@* m68k-tdep.c (m68k_register_name): Use ARRAY_SIZE.
@
text
@d3 1
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.103
log
@* m68k-tdep.c (m68k_return_value): Properly return contents of
structures passed in memory.
@
text
@d125 1
a125 2
  if (regnum < 0 ||
      regnum >= sizeof (register_names) / sizeof (register_names[0]))
@


1.102
log
@* m68k-tdep.c (m68k_frame_prev_register): Change type of last
argument to `gdb_byte *'.
@
text
@d336 16
a351 3
  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
      && !m68k_reg_struct_return_p (gdbarch, type))
    return RETURN_VALUE_STRUCT_CONVENTION;
d353 2
a354 3
  /* GCC returns a `long double' in memory.  */
  if (code == TYPE_CODE_FLT && TYPE_LENGTH (type) == 12)
    return RETURN_VALUE_STRUCT_CONVENTION;
@


1.101
log
@* m68k-tdep.c (m68k_local_breakpoint_from_pc): Change return type
to `const gdb_byte *'.  Use gdb_byte for break_insn.
(m68k_register_to_value): Change type of last argument to
`gdb_byte *'.  Use gdb_byte for from.
(m68k_value_to_register): Change type of last argument to
`gdb_byte *'.  Use gdb_byte for to.
(m68k_extract_return_value): Change type of last argument to
`gdb_byte *'.  Use gdb_byte for buf.  Remove unnecessary cast.
(m68k_svr4_extract_return_value): Change type of last argument to
`gdb_byte *'.  Use gdb_byte for buf.
(m68k_store_return_value): Change type of last argument to
`gdb_byte *'.  Remove unnecessary cast.
(m68k_svr4_store_return_value): Change type of last argument to
`gdb_byte *'.  Use gdb_byte for buf.
(m68k_return_value, m68k_svr4_return_value): Change type of
readbuf and writebuf arguments to `gdb_byte *'.
(m68k_push_dummy_call, m68k_unwind_pc, m68k_frame_cache)
(m68k_unwind_dummy_id): Use gdb_byte for buf.
(m68k_get_longjmp_target): Use `gdb_byte *' for buf.
* m68kbsd-tdep.c (m68kbsd_supply_fpregset)
(m68kbsd_supply_gregset): Use `gdb_byte *' for regs.
@
text
@d828 1
a828 1
			  int *realnump, void *valuep)
@


1.100
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d68 1
a68 1
static const unsigned char *
d71 1
a71 1
  static unsigned char break_insn[] = {0x4e, (0x40 | BPT_VECTOR)};
d147 1
a147 1
			struct type *type, void *to)
d149 1
a149 1
  char from[M68K_MAX_REGISTER_SIZE];
d170 1
a170 1
			struct type *type, const void *from)
d172 1
a172 1
  char to[M68K_MAX_REGISTER_SIZE];
d223 1
a223 1
			   void *valbuf)
d226 1
a226 1
  char buf[M68K_MAX_REGISTER_SIZE];
d237 1
a237 2
      regcache_raw_read (regcache, M68K_D1_REGNUM,
			 (char *) valbuf + (len - 4));
d246 1
a246 1
				void *valbuf)
d249 1
a249 1
  char buf[M68K_MAX_REGISTER_SIZE];
d266 1
a266 1
			 const void *valbuf)
d276 1
a276 2
      regcache_raw_write (regcache, M68K_D1_REGNUM,
			  (char *) valbuf + (len - 4));
d285 1
a285 1
			      const void *valbuf)
d291 1
a291 1
      char buf[M68K_MAX_REGISTER_SIZE];
d331 2
a332 2
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
d354 2
a355 2
			struct regcache *regcache, void *readbuf,
			const void *writebuf)
d412 1
a412 1
  char buf[4];
d741 1
a741 1
  char buf[8];
d753 1
a753 1
  char buf[4];
d903 1
a903 1
  char buf[4];
d1055 1
a1055 1
  char *buf;
@


1.99
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d128 1
a128 1
		    "m68k_register_name: illegal register number %d", regnum);
d242 1
a242 1
		    "Cannot extract return value of %d bytes long.", len);
d282 1
a282 1
		    "Cannot store return value of %d bytes long.", len);
d1064 1
a1064 1
		      "m68k_get_longjmp_target: not implemented");
@


1.98
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_CONTENTS_ALL): Delete.
	(value_contents_all): Declare.
	* value.c (value_contents_all): New function.
	* hpacc-abi.c, cp-valprint.c, valops.c, c-valprint.c: Update.
	* m68k-tdep.c, i386-tdep.c, infcall.c, valops.c: Update.
@
text
@d154 2
a155 2
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
d177 2
a178 2
      warning ("Cannot convert non-floating-point type "
	       "to floating-point register value.");
@


1.97
log
@2005-02-02  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_enclosing_type): New function.
	* value.h (VALUE_ENCLOSING_TYPE): Delete.
	(value_enclosing_type): Declare.
	* xstormy16-tdep.c, vax-tdep.c, m68k-tdep.c, i386-tdep.c: Update.
	* gnu-v3-abi.c, hpacc-abi.c, infcall.c, valops.c: Update.
@
text
@d435 1
a435 1
      write_memory (sp + offset, VALUE_CONTENTS_ALL (args[i]), len);
@


1.96
log
@2004-10-27  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Use
	frame_unwind_register instead of frame_register_unwind, do not
	recurse the register's location.
	* xstormy16-tdep.c (xstormy16_frame_prev_register):
	* sparc-tdep.c (sparc32_frame_prev_register): Ditto.
	* sparc64-tdep.c (sparc64_frame_prev_register): Ditto.
	* sh-tdep.c (sh_frame_prev_register): Ditto.
	* m68k-tdep.c (m68k_frame_prev_register): Ditto.
	* i386-tdep.c (i386_frame_prev_register): Ditto.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Ditto.
	* amd64-tdep.c (amd64_frame_prev_register): Ditto.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d420 1
a420 1
      struct type *value_type = VALUE_ENCLOSING_TYPE (args[i]);
@


1.95
log
@2004-09-02  Andrew Cagney  <cagney@@gnu.org>

	* config/m68k/tm-vx68.h: Do not include "tm-m68k.h".
	* config/m68k/tm-os68k.h: Ditto.
	* config/m68k/tm-monitor.h: Ditto.
	* config/m68k/tm-cisco.h: Ditto.
	* config/m68k/st2000.mt (TM_FILE): Delete.
	* config/m68k/tm-vx68.h (GET_LONGJMP_TARGET): Delete.
	* config/m68k/tm-cisco.h (GET_LONGJMP_TARGET): Delete.
	* config/m68k/tm-m68k.h (m68k_get_longjmp_target): Delete file.
	* m68k-tdep.c (m68k_get_longjmp_target): Make static.
@
text
@d865 6
a870 2
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
@


1.94
log
@2004-07-23  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_collect instead of regcache_collect.
	* regcache.h (regcache_collect): Delete declaration.
	* regcache.c (regcache_colect): Delete function.
	* win32-nat.c (do_child_store_inferior_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_fill_reg): Update.
	* rs6000-nat.c (store_register): Update.
	* remote.c (store_register_using_P, remote_store_registers): Update.
	* ppcnbsd-tdep.c (ppcnbsd_fill_reg): Update.
	* ppc-linux-nat.c (store_altivec_register, store_spe_register)
	(fill_vrregset, store_spe_registers, fill_gregset)
	(fill_gregset): Update.
	* nto-procfs.c (procfs_store_registers): Update.
	* mipsnbsd-tdep.c (mipsnbsd_fill_reg): Update.
	* mips-linux-tdep.c (fill_gregset, mips64_fill_gregset): Update.
	* m68klinux-nat.c (store_register, fill_gregset): Update.
	* m68k-tdep.c (fill_gregset): Update.
	* infptrace.c (store_register): Update.
	* i386-nto-tdep.c (i386nto_regset_fill): Update.
	* i386-linux-nat.c (store_register, fill_gregset): Update.
	* hppa-linux-nat.c (fill_gregset): Update.
	* go32-nat.c (store_register): Update.
	* armnbsd-nat.c (store_register, store_regs, store_fp_register)
	(store_fp_regs): Update.
	* arm-linux-nat.c (store_nwfpe_single, store_nwfpe_double)
	(store_nwfpe_extended, store_fpregister, store_fpregs)
	(store_register, store_regs, fill_gregset, fill_fpregset): Update.
	* alpha-tdep.c (alpha_fill_int_regs, alpha_fill_fp_regs): Update.
	* aix-thread.c (fill_gprs64, fill_fprs, fill_sprs64, fill_sprs32)
	(store_regs_user_thread, store_regs_kernel_thread): Update.
@
text
@d1050 1
a1050 1
int
@


1.93
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d981 1
a981 1
	regcache_collect (regi, regp + regi);
d984 1
a984 1
    regcache_collect (PS_REGNUM, regp + R_PS);
d986 1
a986 1
    regcache_collect (PC_REGNUM, regp + R_PC);
d1027 2
a1028 1
	regcache_collect (regi, &fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
d1031 2
a1032 1
    regcache_collect (M68K_FPC_REGNUM, &fpregsetp->f_pcr);
d1034 2
a1035 1
    regcache_collect (M68K_FPS_REGNUM, &fpregsetp->f_psr);
d1037 2
a1038 1
    regcache_collect (M68K_FPI_REGNUM, &fpregsetp->f_fpiaddr);
@


1.92
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d966 1
a966 1
      supply_register (regi, (char *) (regp + regi));
d968 2
a969 2
  supply_register (PS_REGNUM, (char *) (regp + R_PS));
  supply_register (PC_REGNUM, (char *) (regp + R_PC));
d1004 1
a1004 1
      supply_register (regi, from);
d1006 6
a1011 3
  supply_register (M68K_FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (M68K_FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (M68K_FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
@


1.91
log
@* m68k-tdep.c (m68k_svr4_return_value): Implement
RETURN_VALUE_ABI_RETURNS_ADDRESS.
@
text
@d408 1
a408 1
m68k_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
@


1.90
log
@* m68k-tdep.c (m68k_convert_register_p, m68k_register_to_value)
(m68k_value_to_register): New functions.
(m68k_gdbarch_init): Set convert_register_p, register_to_value and
value_to_register.
@
text
@d363 21
a383 1
    return RETURN_VALUE_STRUCT_CONVENTION;
@


1.89
log
@* delta68-nat.c: Remove file.
* m68k-tdep.c (delta68_in_sigtramp, delta68_frame_args_address)
(delta68_frame_saved_pc, delta68_frame_num_args): Remove functions.
* Makefile.in (ALLDEPFILES): Remove delta68-nat.c.
(delta68-nat.o): Remove dependency.
@
text
@d133 56
d1110 3
@


1.88
log
@* m68k-tdep.c (m68k_frameless_function_invocation): Remove
function.
(m68k_gdbarch_init): Don't set
deprecated_frameless_function_invocation.
@
text
@a329 56
int
delta68_in_sigtramp (CORE_ADDR pc, char *name)
{
  if (name != NULL)
    return strcmp (name, "_sigcode") == 0;
  else
    return 0;
}

CORE_ADDR
delta68_frame_args_address (struct frame_info *frame_info)
{
  /* we assume here that the only frameless functions are the system calls
     or other functions who do not put anything on the stack. */
  if (get_frame_type (frame_info) == SIGTRAMP_FRAME)
    return get_frame_base (frame_info) + 12;
  else if (legacy_frameless_look_for_prologue (frame_info))
    {
      /* Check for an interrupted system call */
      if (get_next_frame (frame_info) && (get_frame_type (get_next_frame (frame_info)) == SIGTRAMP_FRAME))
	return get_frame_base (get_next_frame (frame_info)) + 16;
      else
	return get_frame_base (frame_info) + 4;
    }
  else
    return get_frame_base (frame_info);
}

CORE_ADDR
delta68_frame_saved_pc (struct frame_info *frame_info)
{
  return read_memory_unsigned_integer (delta68_frame_args_address (frame_info)
				       + 4, 4);
}

int
delta68_frame_num_args (struct frame_info *fi)
{
  int val;
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
  int insn = read_memory_unsigned_integer (pc, 2);
  val = 0;
  if (insn == 0047757 || insn == 0157374)	/* lea W(sp),sp or addaw #W,sp */
    val = read_memory_integer (pc + 2, 2);
  else if ((insn & 0170777) == 0050217	/* addql #N, sp */
	   || (insn & 0170777) == 0050117)	/* addqw */
    {
      val = (insn >> 9) & 7;
      if (val == 0)
	val = 8;
    }
  else if (insn == 0157774)	/* addal #WW, sp */
    val = read_memory_integer (pc + 2, 4);
  val >>= 2;
  return val;
}
@


1.87
log
@2004-05-05  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PARM_BOUNDARY): Delete.
	gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (PARM_BOUNDARY): Delete macro.
	(value_push): Delete PARM_BOUNDARY code.
	* m68k-tdep.c (m68k_gdbarch_init): Do not set parm_boundary.
@
text
@a329 14

/* A function that tells us whether the function invocation represented
   by fi does not have a frame on the stack associated with it.  If it
   does not, FRAMELESS is set to 1, else 0.  */

static int
m68k_frameless_function_invocation (struct frame_info *fi)
{
  if (get_frame_type (fi) == SIGTRAMP_FRAME)
    return 0;
  else
    return legacy_frameless_look_for_prologue (fi);
}

a1099 1
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, m68k_frameless_function_invocation);
@


1.86
log
@2004-05-04  Michael Snyder  <msnyder@@redhat.com>

        * m68k-tdep.c (m68k_gdbarch_init): Default to using
        reg_struct_return method (as gcc usually does for cross targets).
@
text
@a1109 1
  set_gdbarch_parm_boundary (gdbarch, 32);
@


1.85
log
@* m68k-tdep.h (struct gdbarch_tdep): Add member
struct_value_regnum.
(m68k_svr4_init_abi): New prototype.
* m68k-tdep.c: Include "floatformat.h".  Add comment about all the
different calling conventions.
(m68k_extract_return_value): Remove code dealing with single-field
structs.
(m68k_store_return_value): Remove code dealing with single-field
structs.  Correctly store return values of 5, 6, 7 or 8 bytes.
(m68k_extract_struct_value_address): Remove function.
(m68k_svr4_extract_return_value,m68k_svr4_store_return_value)
(m68k_reg_struct_return_p, m68k_return_value)
(m68k_svr4_return_value): New functions.
(m68k_use_struct_convention): Remove function.
(m68k_push_dummy_call): Use new struct_value_regnum member of
`struct gdbarch_tdep' instead of hardcoded register number to
store STRUCT_ADDR.
(m68k_svr4_init_abi): New function.
(m68k_gdbarch_init): Don't set extract_return_value,
store_return_values, deprecated_extract_struct_value_address and
use_struct_convention.  Set return_value instead.  Initialize new
struct_value_regnum member of `struct gdbarch_tdep'.
* m68klinux-tdep.c: Update copyright year.
(m68k_linux_extract_return_value, m68k_linux_store_return_value)
(m68k_linux_extract_struct_value_address): Remove function.
(m68k_linux_init_abi): Don't set extract_return_value,
store_return_values, deprecated_extract_struct_value_address and
use_struct_convention.  Call m68k_svr4_init_abi but override the
new struct_value_regnum member of `struct gdbarch_tdep'.
* Makefile.in (m68k-tdep.o): Update dependencies.
@
text
@d1140 1
a1140 1
  tdep->struct_return = pcc_struct_return;
@


1.84
log
@2004-05-01  Andrew Cagney  <cagney@@redhat.com>

	* Makefile.in (m68klinux-nat.o): Update dependencies.
	* m68klinux-tdep.c: Include "trad-frame.h" and "frame-unwind.h".
	(m68k_linux_sigtramp_frame_cache)
	(m68k_linux_sigtramp_frame_this_id)
	(m68k_linux_sigtramp_frame_prev_register)
	(m68k_linux_sigtramp_frame_unwind)
	(m68k_linux_sigtramp_frame_sniffer)
	(struct m68k_linux_sigtramp_info, m68k_linux_init_abi): Code from
	m68k-tdep.h and m68k-tdep.c, add "linux" to function and variable
	names, use trad-frame.h.
	* m68k-tdep.h (struct gdbarch_tdep): Delete get_sigtramp_info.
	(struct m68k_sigtramp_info): Delete.
	* m68k-tdep.c (m68k_sigtramp_frame_cache)
	(m68k_sigtramp_frame_this_id, m68k_sigtramp_frame_prev_register)
	(m68k_sigtramp_frame_unwind, m68k_sigtramp_frame_sniffer)
	(m68k_gdbarch_init): Delete all the sigtramp code, moved to
	"m68klinux-tdep.c".
@
text
@d28 1
d133 30
a162 2
/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that, in virtual format,
a171 7
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_extract_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }

d189 19
a207 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE, given in virtual format.  */
a214 7
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_store_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }

d219 1
a219 1
      regcache_raw_write_part (regcache, M68K_D1_REGNUM, 8 - len,
d221 1
a221 1
      regcache_raw_write (regcache, M68K_D0_REGNUM,
d229 45
a273 3
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d275 4
a278 2
static CORE_ADDR
m68k_extract_struct_value_address (struct regcache *regcache)
d280 14
a293 1
  char buf[4];
d295 1
a295 2
  regcache_cooked_read (regcache, M68K_D0_REGNUM, buf);
  return extract_unsigned_integer (buf, 4);
d298 4
a301 2
static int
m68k_use_struct_convention (int gcc_p, struct type *type)
d303 5
a307 1
  enum struct_return struct_return;
d309 19
a327 3
  struct_return = gdbarch_tdep (current_gdbarch)->struct_return;
  return generic_use_struct_convention (struct_return == reg_struct_return,
					type);
d329 1
d407 1
d436 1
a436 1
      regcache_cooked_write (regcache, M68K_A1_REGNUM, buf);
d1067 16
a1114 5
  set_gdbarch_extract_return_value (gdbarch, m68k_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, m68k_store_return_value);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, m68k_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, m68k_use_struct_convention);

d1128 1
d1139 1
@


1.83
log
@* m68k-tdep.c (REMOTE_BPT_VECTOR): Remove define.
* config/m68k/tm-nbsd.h (REMOTE_BPT_VECTOR): Remove define.
@
text
@a763 79
/* Signal trampolines.  */

static struct m68k_frame_cache *
m68k_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct m68k_sigtramp_info info;
  char buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();

  frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4) - 4;

  info = tdep->get_sigtramp_info (next_frame);

  for (i = 0; i < M68K_NUM_REGS; i++)
    if (info.sc_reg_offset[i] != -1)
      cache->saved_regs[i] = info.sigcontext_addr + info.sc_reg_offset[i];

  *this_cache = cache;
  return cache;
}

static void
m68k_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct m68k_frame_cache *cache =
    m68k_sigtramp_frame_cache (next_frame, this_cache);

  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
}

static void
m68k_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  m68k_sigtramp_frame_cache (next_frame, this_cache);

  m68k_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind m68k_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  m68k_sigtramp_frame_this_id,
  m68k_sigtramp_frame_prev_register
};

static const struct frame_unwind *
m68k_sigtramp_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;

  /* We shouldn't even bother to try if the OSABI didn't register
     a get_sigtramp_info handler.  */
  if (!gdbarch_tdep (current_gdbarch)->get_sigtramp_info)
    return NULL;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
    return &m68k_sigtramp_frame_unwind;

  return NULL;
}

a1014 1
  tdep->get_sigtramp_info = NULL;
a1034 1
  frame_unwind_append_sniffer (gdbarch, m68k_sigtramp_frame_sniffer);
@


1.82
log
@* m68k-tdep.h: Tweak comments.
* m68k-tdep.c: Tweak comment.
@
text
@a66 5
#if !defined (REMOTE_BPT_VECTOR)
#define REMOTE_BPT_VECTOR 1
#endif


@


1.81
log
@2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (PC_IN_SIGTRAMP): Change to a function with
	predicate, deprecate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-linux-tdep.c (alpha_linux_init_abi): Update.
	* alpha-osf1-tdep.c (alpha_osf1_init_abi): Update.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Update.
	* alphafbsd-tdep.c (alphafbsd_init_abi): Update.
	* alphanbsd-tdep.c (alphanbsd_init_abi): Update.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Update.
	* amd64-tdep.c (amd64_sigtramp_frame_sniffer): Update.
	* amd64nbsd-tdep.c (amd64nbsd_init_abi): Update.
	* amd64obsd-tdep.c (amd64obsd_init_abi): Update.
	* arm-tdep.c (arm_sigtramp_unwind_sniffer): Update.
	* blockframe.c (find_pc_partial_function): Update.
	* breakpoint.c (bpstat_what): Update.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update.
	* frv-linux-tdep.c (frv_linux_init_abi): Update.
	* frv-tdep.c (frv_sigtramp_frame_sniffer): Update.
	* hppa-hpux-tdep.c (hppa_hpux_init_abi): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* i386-nto-tdep.c (i386nto_init_abi): Update.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Update.
	* i386-tdep.c (i386_sigtramp_frame_sniffer)
	(i386_svr4_init_abi, i386_go32_init_abi, i386_gdbarch_init): Update.
	* i386bsd-tdep.c (i386bsd_init_abi): Update.
	* i386nbsd-tdep.c (i386nbsd_init_abi): Update.
	* i386obsd-tdep.c (i386obsd_init_abi): Update.
	* ia64-tdep.c (ia64_sigtramp_frame_sniffer): Update.
	* infrun.c (pc_in_sigtramp): Update.
	* m68k-tdep.c (m68k_sigtramp_frame_sniffer): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mipsnbsd-tdep.c (mipsnbsd_init_abi): Update.
	* ppc-linux-tdep.c: Update comment.
	* ppcnbsd-tdep.c (ppcnbsd_init_abi): Update.
	* shnbsd-tdep.c (shnbsd_init_abi): Update.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Update.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Update.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_init_abi): Update.
	* sparc64nbsd-tdep.c (sparc64nbsd_init_abi): Update.
	* sparc64obsd-tdep.c (sparc64obsd_init_abi): Update.
	* sparcnbsd-tdep.c (sparc32nbsd_init_abi): Update.
	* sparcobsd-tdep.c (sparc32obsd_init_abi): Update.

Index: doc/ChangeLog
2004-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	references to PC_IN_SIGTRAMP.
@
text
@d1 1
a1 1
/* Target dependent code for the Motorola 68000 series.
@


1.80
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d842 1
a842 1
  if (PC_IN_SIGTRAMP (pc, name))
@


1.80.2.1
log
@Merge mainline to intercu branch.
@
text
@d842 1
a842 1
  if (DEPRECATED_PC_IN_SIGTRAMP (pc, name))
@


1.80.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1 1
a1 1
/* Target-dependent code for the Motorola 68000 series.
a27 1
#include "floatformat.h"
d67 5
d137 2
a138 86
/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

static int
m68k_convert_register_p (int regnum, struct type *type)
{
  return (regnum >= M68K_FP0_REGNUM && regnum <= M68K_FP0_REGNUM + 7);
}

/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */

static void
m68k_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
{
  char from[M68K_MAX_REGISTER_SIZE];

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
      return;
    }

  /* Convert to TYPE.  This should be a no-op if TYPE is equivalent to
     the extended floating-point format used by the FPU.  */
  get_frame_register (frame, regnum, from);
  convert_typed_floating (from, builtin_type_m68881_ext, to, type);
}

/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */

static void
m68k_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
{
  char to[M68K_MAX_REGISTER_SIZE];

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert non-floating-point type "
	       "to floating-point register value.");
      return;
    }

  /* Convert from TYPE.  This should be a no-op if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
  convert_typed_floating (from, type, to, builtin_type_m68881_ext);
  put_frame_register (frame, regnum, to);
}


/* There is a fair number of calling conventions that are in somewhat
   wide use.  The 68000/08/10 don't support an FPU, not even as a
   coprocessor.  All function return values are stored in %d0/%d1.
   Structures are returned in a static buffer, a pointer to which is
   returned in %d0.  This means that functions returning a structure
   are not re-entrant.  To avoid this problem some systems use a
   convention where the caller passes a pointer to a buffer in %a1
   where the return values is to be stored.  This convention is the
   default, and is implemented in the function m68k_return_value.

   The 68020/030/040/060 do support an FPU, either as a coprocessor
   (68881/2) or built-in (68040/68060).  That's why System V release 4
   (SVR4) instroduces a new calling convention specified by the SVR4
   psABI.  Integer values are returned in %d0/%d1, pointer return
   values in %a0 and floating values in %fp0.  When calling functions
   returning a structure the caller should pass a pointer to a buffer
   for the return value in %a0.  This convention is implemented in the
   function m68k_svr4_return_value, and by appropriately setting the
   struct_value_regnum member of `struct gdbarch_tdep'.

   GNU/Linux returns values in the same way as SVR4 does, but uses %a1
   for passing the structure return value buffer.

   GCC can also generate code where small structures are returned in
   %d0/%d1 instead of in memory by using -freg-struct-return.  This is
   the default on NetBSD a.out, OpenBSD and GNU/Linux and several
   embedded systems.  This convention is implemented by setting the
   struct_return member of `struct gdbarch_tdep' to reg_struct_return.  */

/* Read a function return value of TYPE from REGCACHE, and copy that
d148 7
d172 3
d176 2
a177 2
m68k_svr4_extract_return_value (struct type *type, struct regcache *regcache,
				void *valbuf)
a179 1
  char buf[M68K_MAX_REGISTER_SIZE];
d181 2
a182 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d184 2
a185 2
      regcache_raw_read (regcache, M68K_FP0_REGNUM, buf);
      convert_typed_floating (buf, builtin_type_m68881_ext, valbuf, type);
a186 13
  else if (TYPE_CODE (type) == TYPE_CODE_PTR && len == 4)
    regcache_raw_read (regcache, M68K_A0_REGNUM, valbuf);
  else
    m68k_extract_return_value (type, regcache, valbuf);
}

/* Write a function return value of TYPE from VALBUF into REGCACHE.  */

static void
m68k_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
{
  int len = TYPE_LENGTH (type);
d192 1
a192 1
      regcache_raw_write_part (regcache, M68K_D0_REGNUM, 8 - len,
d194 1
a194 1
      regcache_raw_write (regcache, M68K_D1_REGNUM,
d202 6
a207 3
static void
m68k_svr4_store_return_value (struct type *type, struct regcache *regcache,
			      const void *valbuf)
d209 1
a209 1
  int len = TYPE_LENGTH (type);
d211 2
a212 13
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      char buf[M68K_MAX_REGISTER_SIZE];
      convert_typed_floating (valbuf, type, buf, builtin_type_m68881_ext);
      regcache_raw_write (regcache, M68K_FP0_REGNUM, buf);
    }
  else if (TYPE_CODE (type) == TYPE_CODE_PTR && len == 4)
    {
      regcache_raw_write (regcache, M68K_A0_REGNUM, valbuf);
      regcache_raw_write (regcache, M68K_D0_REGNUM, valbuf);
    }
  else
    m68k_store_return_value (type, regcache, valbuf);
a214 4
/* Return non-zero if TYPE, which is assumed to be a structure or
   union type, should be returned in registers for architecture
   GDBARCH.  */

d216 1
a216 1
m68k_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)
d218 6
a223 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum type_code code = TYPE_CODE (type);
  int len = TYPE_LENGTH (type);
d225 3
a227 1
  gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION);
d229 4
a232 1
  if (tdep->struct_return == pcc_struct_return)
d234 3
d238 7
a244 1
  return (len == 1 || len == 2 || len == 4 || len == 8);
d247 18
a264 5
/* Determine, for architecture GDBARCH, how a return value of TYPE
   should be returned.  If it is supposed to be returned in registers,
   and READBUF is non-zero, read the appropriate value from REGCACHE,
   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
   from WRITEBUF into REGCACHE.  */
d266 2
a267 4
static enum return_value_convention
m68k_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache, void *readbuf,
		   const void *writebuf)
d269 2
a270 16
  enum type_code code = TYPE_CODE (type);

  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
      && !m68k_reg_struct_return_p (gdbarch, type))
    return RETURN_VALUE_STRUCT_CONVENTION;

  /* GCC returns a `long double' in memory.  */
  if (code == TYPE_CODE_FLT && TYPE_LENGTH (type) == 12)
    return RETURN_VALUE_STRUCT_CONVENTION;

  if (readbuf)
    m68k_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    m68k_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
d273 2
a274 4
static enum return_value_convention
m68k_svr4_return_value (struct gdbarch *gdbarch, struct type *type,
			struct regcache *regcache, void *readbuf,
			const void *writebuf)
d276 8
a283 33
  enum type_code code = TYPE_CODE (type);

  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
      && !m68k_reg_struct_return_p (gdbarch, type))
    {
      /* The System V ABI says that:

	 "A function returning a structure or union also sets %a0 to
	 the value it finds in %a0.  Thus when the caller receives
	 control again, the address of the returned object resides in
	 register %a0."

	 So the ABI guarantees that we can always find the return
	 value just after the function has returned.  */

      if (readbuf)
	{
	  ULONGEST addr;

	  regcache_raw_read_unsigned (regcache, M68K_A0_REGNUM, &addr);
	  read_memory (addr, readbuf, TYPE_LENGTH (type));
	}

      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
    }

  /* This special case is for structures consisting of a single
     `float' or `double' member.  These structures are returned in
     %fp0.  For these structures, we call ourselves recursively,
     changing TYPE into the type of the first member of the structure.
     Since that should work for all structures that have only one
     member, we don't bother to check the member's type here.  */
  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)
d285 3
a287 3
      type = check_typedef (TYPE_FIELD_TYPE (type, 0));
      return m68k_svr4_return_value (gdbarch, type, regcache,
				     readbuf, writebuf);
d289 4
a292 7

  if (readbuf)
    m68k_svr4_extract_return_value (type, regcache, readbuf);
  if (writebuf)
    m68k_svr4_store_return_value (type, regcache, writebuf);

  return RETURN_VALUE_REGISTER_CONVENTION;
a293 1

d296 1
a296 1
m68k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,
a300 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d329 1
a329 1
      regcache_cooked_write (regcache, tdep->struct_value_regnum, buf);
d769 79
d932 1
a932 1
      regcache_raw_supply (current_regcache, regi, (char *) (regp + regi));
d934 2
a935 2
  regcache_raw_supply (current_regcache, PS_REGNUM, (char *) (regp + R_PS));
  regcache_raw_supply (current_regcache, PC_REGNUM, (char *) (regp + R_PC));
d947 1
a947 1
	regcache_raw_collect (current_regcache, regi, regp + regi);
d950 1
a950 1
    regcache_raw_collect (current_regcache, PS_REGNUM, regp + R_PS);
d952 1
a952 1
    regcache_raw_collect (current_regcache, PC_REGNUM, regp + R_PC);
d970 1
a970 1
      regcache_raw_supply (current_regcache, regi, from);
d972 3
a974 6
  regcache_raw_supply (current_regcache, M68K_FPC_REGNUM,
		       (char *) &(fpregsetp->f_pcr));
  regcache_raw_supply (current_regcache, M68K_FPS_REGNUM,
		       (char *) &(fpregsetp->f_psr));
  regcache_raw_supply (current_regcache, M68K_FPI_REGNUM,
		       (char *) &(fpregsetp->f_fpiaddr));
d990 1
a990 2
	regcache_raw_collect (current_regcache, regi,
			      &fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
d993 1
a993 2
    regcache_raw_collect (current_regcache, M68K_FPC_REGNUM,
			  &fpregsetp->f_pcr);
d995 1
a995 2
    regcache_raw_collect (current_regcache, M68K_FPS_REGNUM,
			  &fpregsetp->f_psr);
d997 1
a997 2
    regcache_raw_collect (current_regcache, M68K_FPI_REGNUM,
			  &fpregsetp->f_fpiaddr);
d1009 1
a1009 1
static int
a1038 16


/* System V Release 4 (SVR4).  */

void
m68k_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  /* SVR4 uses a different calling convention.  */
  set_gdbarch_return_value (gdbarch, m68k_svr4_return_value);

  /* SVR4 uses %a0 instead of %a1.  */
  tdep->struct_value_regnum = M68K_A0_REGNUM;
}

d1066 1
d1071 6
a1086 3
  set_gdbarch_convert_register_p (gdbarch, m68k_convert_register_p);
  set_gdbarch_register_to_value (gdbarch,  m68k_register_to_value);
  set_gdbarch_value_to_register (gdbarch, m68k_value_to_register);
a1088 1
  set_gdbarch_return_value (gdbarch, m68k_return_value);
d1099 2
a1100 2
  tdep->struct_value_regnum = M68K_A1_REGNUM;
  tdep->struct_return = reg_struct_return;
d1120 1
@


1.79
log
@2004-02-04  Andrew Cagney  <cagney@@redhat.com>

	* m68k-tdep.c (m68k_saved_pc_after_call): Delete #ifdef
	SYSCALL_TRAP function.
	(m68k_gdbarch_init): Delete #ifdef SYSCALL_TRAP code.
@
text
@d235 1
a235 1
    return frameless_look_for_prologue (fi);
d254 1
a254 1
  else if (frameless_look_for_prologue (frame_info))
d1076 1
a1076 2
  set_gdbarch_frameless_function_invocation (gdbarch,
					     m68k_frameless_function_invocation);
@


1.78
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a1039 20
#ifdef SYSCALL_TRAP
/* Immediately after a function call, return the saved pc before the frame
   is setup.  For sun3's, we check for the common case of being inside of a
   system call, and if so, we know that Sun pushes the call # on the stack
   prior to doing the trap. */

static CORE_ADDR
m68k_saved_pc_after_call (struct frame_info *frame)
{
  int op;

  op = read_memory_unsigned_integer (frame->pc - SYSCALL_TRAP_OFFSET, 2);

  if (op == SYSCALL_TRAP)
    return read_memory_unsigned_integer (read_register (SP_REGNUM) + 4, 4);
  else
    return read_memory_unsigned_integer (read_register (SP_REGNUM), 4);
}
#endif /* SYSCALL_TRAP */

a1061 3
#ifdef SYSCALL_TRAP
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, m68k_saved_pc_after_call);
#endif
@


1.77
log
@2004-01-18  Andrew Cagney  <cagney@@redhat.com>

	* remote-sds.c (tohex): Delete unused function.  Update copyright.
	* xstormy16-tdep.c (xstormy16_register_virtual_size): Ditto.
	* v850-tdep.c (v850_register_virtual_size): Ditto.
	* target.c (normal_target_post_startup_inferior): Ditto.
	* source.c (ambiguous_line_spec): Ditto.
	* remote.c (adapt_remote_get_threadinfo): Ditto.
	* mi/mi-out.c (out_field_fmt): Ditto.
	* mi/mi-interp.c (mi_interp_read_one_line_hook): Ditto.
	(output_control_change_notification): Ditto.
	* m68k-tdep.c (m68k_register_byte): Ditto.
	(m68k_remote_breakpoint_from_pc): Ditto.
	* ui-out.c (init_ui_out_state): Delete unused declaration.
	* stabsread.c (search_value): Ditto.
	* mi/mi-cmd-env.c (env_cli_command): Ditto.
	* maint.c (print_section_table): Ditto.
	* infrun.c (set_follow_fork_mode_command): Ditto.
@
text
@d1096 1
a1096 2
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m68k_extract_struct_value_address);
@


1.76
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d2 3
a4 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,
   2002, 2003
   Free Software Foundation, Inc.
a71 11
/* gdbarch_breakpoint_from_pc is set to m68k_local_breakpoint_from_pc
   so m68k_remote_breakpoint_from_pc is currently not used.  */

static const unsigned char *
m68k_remote_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char break_insn[] = {0x4e, (0x40 | REMOTE_BPT_VECTOR)};
  *lenptr = sizeof (break_insn);
  return break_insn;
}

a134 14
}

/* Index within `registers' of the first byte of the space for
   register regnum.  */

static int
m68k_register_byte (int regnum)
{
  if (regnum >= M68K_FPC_REGNUM)
    return (((regnum - M68K_FPC_REGNUM) * 4) + 168);
  else if (regnum >= FP0_REGNUM)
    return (((regnum - FP0_REGNUM) * 12) + 72);
  else
    return (regnum * 4);
@


1.75
log
@	* m68k-tdep.c: Include "dwarf2-frame.h".
	(m68k_gdbarch_init): Add the DWARF CFI frame unwinder.
	* Makefile.in (m68k-tdep.o): Update dependencies.
@
text
@a1105 2
  set_gdbarch_function_start_offset (gdbarch, 0);

@


1.74
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d24 1
d1157 4
@


1.73
log
@2003-09-04  Andrew Cagney  <cagney@@redhat.com>

	* avr-tdep.c: Include "dis-asm.h".
	* cris-tdep.c: Include "dis-asm.h".
	(cris_delayed_get_disassembler): Use "struct disassemble_info"
	instead of corresponding typedef.
	* h8300-tdep.c: Include "dis-asm.h".
	* ia64-tdep.c: Include "dis-asm.h".
	* i386-tdep.c: Include "dis-asm.h".
	(i386_print_insn): Use "struct disassemble_info" instead of
	corresponding typedef.
	* m68k-tdep.c: Include "dis-asm.h".
	* mcore-tdep.c: Include "dis-asm.h".
	* mips-tdep.c: Include "dis-asm.h".
	(gdb_print_insn_mips): Make static, use "struct disassemble_info"
	instead of corresponding typedef.
	* ns32k-tdep.c: Include "dis-asm.h".
	* s390-tdep.c: Include "dis-asm.h".
	* sparc-tdep.c: Include "dis-asm.h".
	* vax-tdep.c: Include "dis-asm.h".
	* v850-tdep.c: Include "dis-asm.h".
	* mn10300-tdep.c: Include "dis-asm.h".
	* rs6000-tdep.c: Include "dis-asm.h".
	* xstormy16-tdep.c: Include "dis-asm.h".
	(_initialize_xstormy16_tdep): Delete "extern" declaration of
	print_insn_xstormy16.
	* Makefile.in (v850-tdep.o): Update dependencies.
	(vax-tdep.o, sparc-tdep.o, s390-tdep.o): Ditto.
	(ns32k-tdep.o, mips-tdep.o, mcore-tdep.o): Ditto.
	(m68k-tdep.o, ia64-tdep.o, i386-tdep.o): Ditto.
	(h8300-tdep.o, cris-tdep.o, avr-tdep.o): Ditto.
	(mn10300-tdep.o, xstormy16-tdep.o, disasm.o): Ditto.
	(gdbarch_h): Remove $(dis_asm_h).
	* disasm.c: Include "dis-asm.h".
	(dis_asm_read_memory): Use "struct disassemble_info" instead of
	corresponding typedef.
	(dis_asm_memory_error, dump_insns, do_assembly_only): Ditto.
	(gdb_disassemble_info, gdb_disassembly, gdb_print_insn): Ditto.
	* gdbarch.sh: Do not include "dis-asm.h".
	(struct disassemble_info): Declare opaque.
	(TARGET_PRINT_INSN): Update declaration.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d951 2
a952 2
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d965 2
a966 2
  register int regi;
  register greg_t *regp = (greg_t *) gregsetp;
d988 1
a988 1
  register int regi;
@


1.72
log
@2003-07-16  Andrew Cagney  <cagney@@redhat.com>

	* frame-base.h (frame_base_p_ftype): Delete definition.
	(frame_base_append_predicate): Delete declaration.
	* frame-unwind.h (frame_unwind_p_ftype): Delete definition.
	(frame_unwind_append_predicate): Delete declaration.
	* frame-unwind.c (struct frame_unwind_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_unwind_append_predicate): Delete function.
	(frame_unwind_append_sniffer): Update call to append_predicate.
	(frame_unwind_free): Delete function.
	(_initialize_frame_unwind): Pass NULL as "free" to
	register_gdbarch_data.
	(frame_unwind_init): Append the dummy_frame_sniffer.
	(frame_unwind_find_by_frame): Simplify.
	* frame-base.c (struct frame_base_table): Delete field "p".
	(append_predicate): Delete parameter "p".
	(frame_base_append_predicate): Delete function.
	(frame_base_append_sniffer): Update call to append_predicate.
	(frame_base_free): Delete function.
	(frame_base_find_by_frame): Simplify.
	(_initialize_frame_base): Pass NULL as "free" to
	register_gdbarch_data.
	* x86-64-tdep.c (x86_64_frame_sniffer): Replace "x86_64_frame_p".
	(x86_64_sigtramp_frame_sniffer): Replace
	"x86_64_sigtramp_frame_p".
	(x86_64_init_abi): Set the frame unwind sniffers.
	* m68k-tdep.c (m68k_frame_sniffer): Replace "m68k_frame_p".
	(m68k_sigtramp_frame_sniffer): Replace "m68k_sigtramp_frame_p"
	(m68k_gdbarch_init): Set the frame unwind sniffers.
	* i386-tdep.c (i386_sigtramp_frame_sniffer): Replace
	"i386_sigtramp_frame_p".
	(i386_frame_sniffer): Replace "i386_frame_p".
	(i386_gdbarch_init): Set the frame unwind sniffers.
	* avr-tdep.c (avr_frame_sniffer): Replace "avr_frame_sniffer".
	(avr_gdbarch_init): Set the frame unwind sniffers.
	* alpha-tdep.c (alpha_sigtramp_frame_sniffer): Replace
	"alpha_sigtramp_frame_p"
	(alpha_heuristic_frame_sniffer): Replace
	"alpha_heuristic_frame_p".
	(alpha_gdbarch_init): Set the frame unwind sniffers.
	(alpha_dwarf2_init_abi): Ditto.
	* alpha-mdebug-tdep.c (alpha_mdebug_frame_sniffer): Replace
	"alpha_debug_frame_p".
	(alpha_mdebug_frame_base_sniffer): Replace
	"alpha_mdebug_frame_base_p".
	(alpha_mdebug_init_abi): Set the frame unwind sniffers.
	* d10v-tdep.c (d10v_frame_sniffer): Replace "d10v_frame_p".
	(d10v_gdbarch_init): Set the frame unwind sniffer.
	* dwarf2-frame.c (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dwarf2-frame.h (dwarf2_frame_sniffer): Replace "dwarf2_frame_p".
	(dwarf2_frame_base_sniffer): Replace "dwarf2_frame_base_p".
	* dummy-frame.c (dummy_frame_sniffer): Replace "dummy_frame_p".
	* dummy-frame.h (dummy_frame_sniffer): Replace "dummy_frame_p".
@
text
@d36 1
@


1.71
log
@	* m68k-tdep.h (enum struct_return): Define.
	(struct gdbarch_tdep): Add struct_return.
	* m68k-tdep.c (m68k_push_dummy_call): Non-scalars bigger than 4
	bytes are padded to the right, not to the left.  Pass struct value
	address in register %a1, not on stack.
	(m68k_use_struct_convention): New function.
	(m68k_gdbarch_init): Set use_struct_convention.  Initialize
	struct_return in tdep to pcc_struct_return.
	* m68klinux-tdep.c (m68k_linux_init_abi): Set struct_return to
	reg_struct_return.
@
text
@d787 1
a787 1
m68k_frame_p (CORE_ADDR pc)
d854 1
a854 1
m68k_sigtramp_frame_p (CORE_ADDR pc)
d856 1
d1166 2
a1167 2
  frame_unwind_append_predicate (gdbarch, m68k_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, m68k_frame_p);
@


1.70
log
@	* Makefile.in (m68k-tdep.o, m68klinux-tdep.o): Update
	dependencies.
	* m68k-tdep.c (NUM_FREGS): Delete.
	(SIG_PC_FP_OFFSET): Delete.
	(TARGET_M68K): Delete.
	(P_MOVEAL_SP_FP, P_ADDAW_SP, P_ADDAL_SP, P_SUBQW_SP,
	P_SUBQL_SP, P_LEA_SP_SP, P_LEA_PC_A5, P_FMOVEMX_SP,
	P_MOVEL_SP, P_MOVEML_SP): Define.
	(P_MOVL_SP_FP, P_MOVL, P_JSR, P_BSR, P_LEAL, P_MOVML, P_FMOVM,
	P_TRAP): Delete.
        (m68k_register_raw_size): Delete.
	(m68k_register_virtual_size): Delete.
	(m68k_register_type): Renamed from m68k_register_virtual_type and
	add gdbarch argument.
	(m68k_store_struct_return): Delete.
	(m68k_deprecated_extract_return_value): Delete.
	(m68k_deprecated_extract_struct_value_address): Delete.
	(m68k_frame_chain): Delete.
	(m68k_frame_saved_pc): Delete.
	(m68k_fix_call_dummy): Delete.
	(m68k_push_dummy_frame): Delete.
	(m68k_pop_frame): Delete.
	(m68k_extract_return_value): New function.
	(m68k_store_return_value): Rewrite using regcache.
	(m68k_extract_struct_value_address): Rewrite using regcache.
	(m68k_push_dummy_call): New function.
	(struct m68k_frame_cache): Define.
	(m68k_alloc_frame_cache): New function.
	(m68k_analyze_frame_setup): New function.
	(m68k_analyze_register_saves): New function.
	(m68k_analyze_prologue): New function.
	(m68k_skip_prologue): Rewrite using above functions.
	(m68k_unwind_pc): New function.
	(m68k_frame_cache): New function.
	(m68k_frame_this_id): New function.
	(m68k_frame_prev_register): New function.
	(m68k_frame_unwind): New variable.
	(m68k_frame_p): New function.
	(m68k_sigtramp_frame_cache): New function.
	(m68k_sigtramp_frame_this_id): New function.
	(m68k_sigtramp_frame_prev_register): New function.
	(m68k_sigtramp_frame_unwind): New variable.
	(m68k_sigtramp_frame_p): New function.
	(m68k_frame_base_address): New function.
	(m68k_frame_base): New function.
	(m68k_unwind_dummy_id): New function.
	(fill_gregset): Use regcache_collect.
	(fill_fpregset): Likewise.
	(m68k_saved_pc_after_call): Only define if SYSCALL_TRAP is
	defined.
	(m68k_gdbarch_init): Don't define call_dummy_words.  Don't set
	deprecated_init_frame_pc, deprecated_store_struct_return,
	deprecated_extract_return_value, deprecated_store_return_value,
	deprecated_frame_chain, deprecated_frame_saved_pc,
	deprecated_frame_init_saved_regs, deprecated_register_raw_size,
	deprecated_register_virtual_size,
	deprecated_max_register_raw_size,
	deprecated_max_register_virtual_size,
	deprecated_register_virtual_type, deprecated_register_size,
	deprecated_register_byte, deprecated_register_bytes,
	deprecated_fp_regnum, deprecated_use_generic_dummy_frames,
	call_dummy_location, deprecated_call_dummy_breakpoint_offset,
	deprecated_pc_in_call_dummy, deprecated_call_dummy_length,
	deprecated_call_dummy_start_offset, deprecated_call_dummy_words,
	deprecated_sizeof_call_dummy_words, deprecated_fix_call_dummy,
	deprecated_push_dummy_frame, deprecated_pop_frame,
	deprecated_dummy_write_sp.  Set deprecated_saved_pc_after_call
	only if SYSCALL_TRAP is defined.  Set extract_return_value,
	store_return_value, extract_struct_value_address, register_type,
	push_dummy_call, unwind_dummy_id, unwind_pc.  Add two frame unwind
	predicates.
	* m68k-tdep.h (M68K_D1_REGNUM, M68K_NUM_REGS,
	M68K_MAX_REGISTER_SIZE): Define.
	(struct m68k_sigtramp_info): Define.
	(struct gdbarch_tdep): Add get_sigtramp_info.
	* m68klinux-nat.c (fetch_register): Use register_size instead of
	REGISTER_RAW_SIZE.  Don't put assignment in if.
	(store_register): Likewise.
	(fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* m68klinux-tdep.c (m68k_linux_sigtramp_saved_pc): Delete.
	(m68k_linux_frame_saved_pc): Delete.
	(m68k_linux_sigcontext_reg_offset,
	m68k_linux_ucontext_reg_offset): Define.
	(m68k_linux_get_sigtramp_info): New function.
	(m68k_linux_extract_return_value): Rewrite using regcache.
	(m68k_linux_store_return_value): Likewise.
	(m68k_linux_extract_struct_value_address): Likewise.
	(m68k_linux_init_abi): Set get_sigtramp_info in tdep structure.
	Don't set deprecated_frame_saved_pc,
	deprecated_extract_return_value, deprecated_store_return_value,
	deprecated_extract_struct_value_address.  Set
	extract_return_value, store_return_value,
	extract_struct_value_address.
@
text
@d238 10
d330 2
a331 1
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));
d333 1
a333 1
      int offset = container_len - len;
d335 9
d348 1
a348 1
  /* Push value address.  */
a350 1
      sp -= 4;
d352 1
a352 1
      write_memory (sp, buf, 4);
d1122 1
d1149 1
@


1.69
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d25 2
d31 1
d43 10
a52 8
#define P_MOVL_SP_FP	0x2c4f
#define P_MOVL		0x207c
#define P_JSR		0x4eb9
#define P_BSR		0x61ff
#define P_LEAL		0x43fb
#define P_MOVML		0x48ef
#define P_FMOVM		0xf237
#define P_TRAP		0x4e40
a57 2
#define NUM_FREGS (NUM_REGS-24)

a58 1

a60 12
/* This was determined by experimentation on hp300 BSD 4.3.  Perhaps
   it corresponds to some offset in /usr/include/sys/user.h or
   something like that.  Using some system include file would
   have the advantage of probably being more robust in the face
   of OS upgrades, but the disadvantage of being wrong for
   cross-debugging.  */

#define SIG_PC_FP_OFFSET 530

#define TARGET_M68K


a69 3
static void m68k_frame_init_saved_regs (struct frame_info *frame_info);


a96 20
/* Number of bytes of storage in the actual machine representation
   for register regnum.  On the 68000, all regs are 4 bytes
   except the floating point regs which are 12 bytes.  */

static int
m68k_register_raw_size (int regnum)
{
  return (regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 8 ? 12 : 4);
}

/* Number of bytes of storage in the program's representation
   for register regnum.  On the 68000, all regs are 4 bytes
   except the floating point regs which are 12-byte long doubles.  */

static int
m68k_register_virtual_size (int regnum)
{
  return (regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 8 ? 12 : 4);
}

d106 1
a106 1
m68k_register_virtual_type (int regnum)
d159 4
a162 3

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function. */
d165 2
a166 1
m68k_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
d168 2
a169 2
  write_register (M68K_A1_REGNUM, addr);
}
d171 6
a176 4
/* Extract from an array regbuf containing the (raw) register state
   a function return value of type type, and copy that, in virtual format,
   into valbuf.  This is assuming that floating point values are returned
   as doubles in d0/d1.  */
d178 15
a192 17
static void
m68k_deprecated_extract_return_value (struct type *type, char *regbuf,
				      char *valbuf)
{
  int offset = 0;
  int typeLength = TYPE_LENGTH (type);

  if (typeLength < 4)
    offset = 4 - typeLength;

  memcpy (valbuf, regbuf + offset, typeLength);
}

static CORE_ADDR
m68k_deprecated_extract_struct_value_address (char *regbuf)
{
  return (*(CORE_ADDR *) (regbuf));
d195 2
a196 3
/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  Assumes floats are passed
   in d0/d1.  */
d199 2
a200 1
m68k_store_return_value (struct type *type, char *valbuf)
d202 1
a202 2
  deprecated_write_register_bytes (0, valbuf, TYPE_LENGTH (type));
}
d204 6
a209 2
/* Describe the pointer in each stack frame to the previous stack frame
   (its caller).  */
d211 13
a223 4
/* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and produces
   the frame's chain-pointer.  In the case of the 68000, the frame's
   nominal address is the address of a 4-byte word containing the
   calling frame's address.  */
d225 3
a227 3
/* If we are chaining from sigtramp, then manufacture a sigtramp frame
   (which isn't really on the stack.  I'm not sure this is right for anything
   but BSD4.3 on an hp300.  */
d230 1
a230 1
m68k_frame_chain (struct frame_info *thisframe)
d232 4
a235 6
  if (get_frame_type (thisframe) == SIGTRAMP_FRAME)
    return get_frame_base (thisframe);
  else if (!inside_entry_file (get_frame_pc (thisframe)))
    return read_memory_unsigned_integer (get_frame_base (thisframe), 4);
  else
    return 0;
a250 17
static CORE_ADDR
m68k_frame_saved_pc (struct frame_info *frame)
{
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
    {
      if (get_next_frame (frame))
	return read_memory_unsigned_integer (get_frame_base (get_next_frame (frame))
					     + SIG_PC_FP_OFFSET, 4);
      else
	return read_memory_unsigned_integer (read_register (SP_REGNUM)
					     + SIG_PC_FP_OFFSET - 8, 4);
    }
  else
    return read_memory_unsigned_integer (get_frame_base (frame) + 4, 4);
}


d308 27
a334 3
/* Insert the specified number of args and function address
   into a call sequence of the above form stored at DUMMYNAME.
   We use the BFD routines to store a big-endian value of known size.  */
d336 18
a353 3
static void
m68k_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *type, int gcc_p)
d355 8
a362 4
  bfd_putb32 (fun, (unsigned char *) dummy + DEPRECATED_CALL_DUMMY_START_OFFSET + 2);
  bfd_putb32 (nargs * 4,
	      (unsigned char *) dummy + DEPRECATED_CALL_DUMMY_START_OFFSET + 8);
}
d364 3
d368 1
a368 1
/* Push an empty stack frame, to record the current PC, etc.  */
d370 2
a371 2
static void
m68k_push_dummy_frame (void)
d373 9
a381 3
  register CORE_ADDR sp = read_register (SP_REGNUM);
  register int regnum;
  char raw_buffer[12];
d383 4
a386 3
  sp = push_word (sp, read_register (PC_REGNUM));
  sp = push_word (sp, read_register (DEPRECATED_FP_REGNUM));
  write_register (DEPRECATED_FP_REGNUM, sp);
d388 2
a389 7
  /* Always save the floating-point registers, whether they exist on
     this target or not.  */
  for (regnum = FP0_REGNUM + 7; regnum >= FP0_REGNUM; regnum--)
    {
      deprecated_read_register_bytes (REGISTER_BYTE (regnum), raw_buffer, 12);
      sp = push_bytes (sp, raw_buffer, 12);
    }
d391 1
a391 6
  for (regnum = DEPRECATED_FP_REGNUM - 1; regnum >= 0; regnum--)
    {
      sp = push_word (sp, read_register (regnum));
    }
  sp = push_word (sp, read_register (PS_REGNUM));
  write_register (SP_REGNUM, sp);
d394 5
a398 2
/* Discard from the stack the innermost frame,
   restoring all saved registers.  */
d400 3
a402 2
static void
m68k_pop_frame (void)
d404 8
a411 8
  register struct frame_info *frame = get_current_frame ();
  register CORE_ADDR fp;
  register int regnum;
  char raw_buffer[12];

  fp = get_frame_base (frame);
  m68k_frame_init_saved_regs (frame);
  for (regnum = FP0_REGNUM + 7; regnum >= FP0_REGNUM; regnum--)
d413 21
a433 1
      if (get_frame_saved_regs (frame)[regnum])
d435 21
a455 3
	  read_memory (get_frame_saved_regs (frame)[regnum], raw_buffer, 12);
	  deprecated_write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,
					   12);
d458 1
a458 1
  for (regnum = DEPRECATED_FP_REGNUM - 1; regnum >= 0; regnum--)
d460 4
a463 1
      if (get_frame_saved_regs (frame)[regnum])
d465 6
a470 2
	  write_register (regnum,
			  read_memory_integer (get_frame_saved_regs (frame)[regnum], 4));
d472 8
d481 1
a481 1
  if (get_frame_saved_regs (frame)[PS_REGNUM])
d483 3
a485 2
      write_register (PS_REGNUM,
		      read_memory_integer (get_frame_saved_regs (frame)[PS_REGNUM], 4));
d487 2
a488 4
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, 4));
  write_register (PC_REGNUM, read_memory_integer (fp + 4, 4));
  write_register (SP_REGNUM, fp + 8);
  flush_cached_frames ();
a489 1

d491 4
a494 5
/* Given an ip value corresponding to the start of a function,
   return the ip of the first instruction after the function 
   prologue.  This is the generic m68k support.  Machines which
   require something different can override the SKIP_PROLOGUE
   macro to point elsewhere.
d496 9
a504 2
   Some instructions which typically may appear in a function
   prologue include:
d506 53
a558 1
   A link instruction, word form:
a559 1
   link.w       %a6,&0                  4e56  XXXX
d561 3
a563 1
   A link instruction, long form:
d565 1
a565 1
   link.l  %fp,&F%1             480e  XXXX  XXXX
d567 1
a567 1
   A movm instruction to preserve integer regs:
d569 10
a578 1
   movm.l  &M%1,(4,%sp)         48ef  XXXX  XXXX
d580 1
a580 1
   A fmovm instruction to preserve float regs:
d582 4
a585 1
   fmovm   &FPM%1,(FPO%1,%sp)   f237  XXXX  XXXX  XXXX  XXXX
d587 1
a587 1
   Some profiling setup code (FIXME, not recognized yet):
d589 1
a589 2
   lea.l   (.L3,%pc),%a1                43fb  XXXX  XXXX  XXXX
   bsr     _mcount                      61ff  XXXX  XXXX
d591 1
a591 1
 */
d594 2
a595 1
m68k_skip_prologue (CORE_ADDR ip)
d597 1
a597 6
  register CORE_ADDR limit;
  struct symtab_and_line sal;
  register int op;

  /* Find out if there is a known limit for the extent of the prologue.
     If so, ensure we don't go past it.  If not, assume "infinity". */
d599 4
a602 2
  sal = find_pc_line (ip, 0);
  limit = (sal.end) ? sal.end : (CORE_ADDR) ~0;
d604 3
a606 1
  while (ip < limit)
d608 3
a610 1
      op = read_memory_unsigned_integer (ip, 2);
d612 1
a612 16
      if (op == P_LINKW_FP)
	ip += 4;		/* Skip link.w */
      else if (op == P_PEA_FP)
	ip += 2;		/* Skip pea %fp */
      else if (op == P_MOVL_SP_FP)
	ip += 2;		/* Skip move.l %sp, %fp */
      else if (op == P_LINKL_FP)
	ip += 6;		/* Skip link.l */
      else if (op == P_MOVML)
	ip += 6;		/* Skip movm.l */
      else if (op == P_FMOVM)
	ip += 10;		/* Skip fmovm */
      else
	break;			/* Found unknown code, bail out. */
    }
  return (ip);
d615 1
a615 5
/* Store the addresses of the saved registers of the frame described by 
   FRAME_INFO in its saved_regs field.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */
d617 2
a618 2
static void
m68k_frame_init_saved_regs (struct frame_info *frame_info)
d620 3
a622 4
  register int regnum;
  register int regmask;
  register CORE_ADDR next_addr;
  register CORE_ADDR pc;
d624 6
a629 3
  /* First possible address for a pc in a call dummy for this frame.  */
  CORE_ADDR possible_call_dummy_start =
    get_frame_base (frame_info) - 28 - DEPRECATED_FP_REGNUM * 4 - 4 - 8 * 12;
d631 4
a634 1
  int nextinsn;
d636 5
a640 2
  if (get_frame_saved_regs (frame_info))
    return;
d642 57
a698 1
  frame_saved_regs_zalloc (frame_info);
d700 2
a701 1
  memset (get_frame_saved_regs (frame_info), 0, SIZEOF_FRAME_SAVED_REGS);
d703 5
a707 3
  if (get_frame_pc (frame_info) >= possible_call_dummy_start
      && get_frame_pc (frame_info) <= get_frame_base (frame_info))
    {
d709 3
a711 4
      /* It is a call dummy.  We could just stop now, since we know
         what the call dummy saves and where.  But this code proceeds
         to parse the "prologue" which is part of the call dummy.
         This is needlessly complex and confusing.  FIXME.  */
d713 3
a715 6
      next_addr = get_frame_base (frame_info);
      pc = possible_call_dummy_start;
    }
  else
    {
      pc = get_frame_func (frame_info);
d717 17
a733 13
      nextinsn = read_memory_unsigned_integer (pc, 2);
      if (P_PEA_FP == nextinsn
	  && P_MOVL_SP_FP == read_memory_unsigned_integer (pc + 2, 2))
	{
	  /* pea %fp
	     move.l %sp, %fp */
	  next_addr = get_frame_base (frame_info);
	  pc += 4;
	}
      else if (P_LINKL_FP == nextinsn)
	/* link.l %fp */
	/* Find the address above the saved   
	   regs using the amount of storage from the link instruction.  */
d735 2
a736 2
	  next_addr = get_frame_base (frame_info) + read_memory_integer (pc + 2, 4);
	  pc += 6;
d738 1
a738 14
      else if (P_LINKW_FP == nextinsn)
	/* link.w %fp */
	/* Find the address above the saved   
	   regs using the amount of storage from the link instruction.  */
	{
	  next_addr = get_frame_base (frame_info) + read_memory_integer (pc + 2, 2);
	  pc += 4;
	}
      else
	goto lose;

      /* If have an addal #-n, sp next, adjust next_addr.  */
      if (read_memory_unsigned_integer (pc, 2) == 0157774)
	next_addr += read_memory_integer (pc += 2, 4), pc += 4;
d741 1
a741 1
  for (;;)
d743 5
a747 4
      nextinsn = read_memory_unsigned_integer (pc, 2);
      regmask = read_memory_unsigned_integer (pc + 2, 2);
      /* fmovemx to -(sp) */
      if (0xf227 == nextinsn && (regmask & 0xff00) == 0xe000)
d749 3
a751 5
	  /* Regmask's low bit is for register fp7, the first pushed */
	  for (regnum = FP0_REGNUM + 8; --regnum >= FP0_REGNUM; regmask >>= 1)
	    if (regmask & 1)
	      get_frame_saved_regs (frame_info)[regnum] = (next_addr -= 12);
	  pc += 4;
d753 94
a846 4
      /* fmovemx to (fp + displacement) */
      else if (0171056 == nextinsn && (regmask & 0xff00) == 0xf000)
	{
	  register CORE_ADDR addr;
d848 7
a854 26
	  addr = get_frame_base (frame_info) + read_memory_integer (pc + 4, 2);
	  /* Regmask's low bit is for register fp7, the first pushed */
	  for (regnum = FP0_REGNUM + 8; --regnum >= FP0_REGNUM; regmask >>= 1)
	    if (regmask & 1)
	      {
		get_frame_saved_regs (frame_info)[regnum] = addr;
		addr += 12;
	      }
	  pc += 6;
	}
      /* moveml to (sp) */
      else if (0044327 == nextinsn)
	{
	  /* Regmask's low bit is for register 0, the first written */
	  for (regnum = 0; regnum < 16; regnum++, regmask >>= 1)
	    if (regmask & 1)
	      {
		get_frame_saved_regs (frame_info)[regnum] = next_addr;
		next_addr += 4;
	      }
	  pc += 4;
	}
      /* moveml to (fp + displacement) */
      else if (0044356 == nextinsn)
	{
	  register CORE_ADDR addr;
d856 1
a856 57
	  addr = get_frame_base (frame_info) + read_memory_integer (pc + 4, 2);
	  /* Regmask's low bit is for register 0, the first written */
	  for (regnum = 0; regnum < 16; regnum++, regmask >>= 1)
	    if (regmask & 1)
	      {
		get_frame_saved_regs (frame_info)[regnum] = addr;
		addr += 4;
	      }
	  pc += 6;
	}
      /* moveml to -(sp) */
      else if (0044347 == nextinsn)
	{
	  /* Regmask's low bit is for register 15, the first pushed */
	  for (regnum = 16; --regnum >= 0; regmask >>= 1)
	    if (regmask & 1)
	      get_frame_saved_regs (frame_info)[regnum] = (next_addr -= 4);
	  pc += 4;
	}
      /* movl r,-(sp) */
      else if (0x2f00 == (0xfff0 & nextinsn))
	{
	  regnum = 0xf & nextinsn;
	  get_frame_saved_regs (frame_info)[regnum] = (next_addr -= 4);
	  pc += 2;
	}
      /* fmovemx to index of sp */
      else if (0xf236 == nextinsn && (regmask & 0xff00) == 0xf000)
	{
	  /* Regmask's low bit is for register fp0, the first written */
	  for (regnum = FP0_REGNUM + 8; --regnum >= FP0_REGNUM; regmask >>= 1)
	    if (regmask & 1)
	      {
		get_frame_saved_regs (frame_info)[regnum] = next_addr;
		next_addr += 12;
	      }
	  pc += 10;
	}
      /* clrw -(sp); movw ccr,-(sp) */
      else if (0x4267 == nextinsn && 0x42e7 == regmask)
	{
	  get_frame_saved_regs (frame_info)[PS_REGNUM] = (next_addr -= 4);
	  pc += 4;
	}
      else
	break;
    }
lose:;
  get_frame_saved_regs (frame_info)[SP_REGNUM] = get_frame_base (frame_info) + 8;
  get_frame_saved_regs (frame_info)[DEPRECATED_FP_REGNUM] = get_frame_base (frame_info);
  get_frame_saved_regs (frame_info)[PC_REGNUM] = get_frame_base (frame_info) + 4;
#ifdef SIG_SP_FP_OFFSET
  /* Adjust saved SP_REGNUM for fake _sigtramp frames.  */
  if ((get_frame_type (frame_info) == SIGTRAMP_FRAME) && frame_info->next)
    frame_info->saved_regs[SP_REGNUM] =
      frame_info->next->frame + SIG_SP_FP_OFFSET;
#endif
d859 7
d867 13
d949 2
a950 12
      if ((regno == -1) || (regno == regi))
	{
	  *(regp + regi) = *(int *) &deprecated_registers[REGISTER_BYTE (regi)];
	}
    }
  if ((regno == -1) || (regno == PS_REGNUM))
    {
      *(regp + R_PS) = *(int *) &deprecated_registers[REGISTER_BYTE (PS_REGNUM)];
    }
  if ((regno == -1) || (regno == PC_REGNUM))
    {
      *(regp + R_PC) = *(int *) &deprecated_registers[REGISTER_BYTE (PC_REGNUM)];
d952 4
a988 2
  char *to;
  char *from;
d992 2
a993 18
      if ((regno == -1) || (regno == regi))
	{
	  from = (char *) &deprecated_registers[REGISTER_BYTE (regi)];
	  to = (char *) &(fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
	  memcpy (to, from, REGISTER_RAW_SIZE (regi));
	}
    }
  if ((regno == -1) || (regno == M68K_FPC_REGNUM))
    {
      fpregsetp->f_pcr = *(int *) &deprecated_registers[REGISTER_BYTE (M68K_FPC_REGNUM)];
    }
  if ((regno == -1) || (regno == M68K_FPS_REGNUM))
    {
      fpregsetp->f_psr = *(int *) &deprecated_registers[REGISTER_BYTE (M68K_FPS_REGNUM)];
    }
  if ((regno == -1) || (regno == M68K_FPI_REGNUM))
    {
      fpregsetp->f_fpiaddr = *(int *) &deprecated_registers[REGISTER_BYTE (M68K_FPI_REGNUM)];
d995 6
d1043 1
a1051 1
#ifdef SYSCALL_TRAP
a1058 1
#endif /* SYSCALL_TRAP */
d1061 1
a1069 4
  static LONGEST call_dummy_words[7] = { 0xf227e0ff, 0x48e7fffc, 0x426742e7,
    0x4eb93232, 0x3232dffc, 0x69696969,
    (0x4e404e71 | (BPT_VECTOR << 16))
  };
a1080 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d1087 1
d1089 1
d1099 5
a1103 8
  set_gdbarch_deprecated_store_struct_return (gdbarch, m68k_store_struct_return);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       m68k_deprecated_extract_return_value);
  set_gdbarch_deprecated_store_return_value (gdbarch, m68k_store_return_value);

  set_gdbarch_deprecated_frame_chain (gdbarch, m68k_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, m68k_frame_saved_pc);
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, m68k_frame_init_saved_regs);
d1108 1
a1108 5
  set_gdbarch_deprecated_register_raw_size (gdbarch, m68k_register_raw_size);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, m68k_register_virtual_size);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 12);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 12);
  set_gdbarch_deprecated_register_virtual_type (gdbarch, m68k_register_virtual_type);
a1109 2
  set_gdbarch_deprecated_register_size (gdbarch, 4);
  set_gdbarch_deprecated_register_byte (gdbarch, m68k_register_byte);
a1111 1
  set_gdbarch_deprecated_register_bytes (gdbarch, (16 * 4 + 8 + 8 * 12 + 3 * 4));
a1112 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, M68K_FP_REGNUM);
d1117 1
a1117 15
  set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 24);
  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
  set_gdbarch_deprecated_call_dummy_length (gdbarch, 28);
  set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 12);

  set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_words));
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, m68k_fix_call_dummy);
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, m68k_push_dummy_frame);
  set_gdbarch_deprecated_pop_frame (gdbarch, m68k_pop_frame);

  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
d1128 6
d1143 3
@


1.69.4.1
log
@	* Makefile.in (m68k-tdep.o, m68klinux-tdep.o): Update
	dependencies.
	* m68k-tdep.c (NUM_FREGS): Delete.
	(SIG_PC_FP_OFFSET): Delete.
	(TARGET_M68K): Delete.
	(P_MOVEAL_SP_FP, P_ADDAW_SP, P_ADDAL_SP, P_SUBQW_SP,
	P_SUBQL_SP, P_LEA_SP_SP, P_LEA_PC_A5, P_FMOVEMX_SP,
	P_MOVEL_SP, P_MOVEML_SP): Define.
	(P_MOVL_SP_FP, P_MOVL, P_JSR, P_BSR, P_LEAL, P_MOVML, P_FMOVM,
	P_TRAP): Delete.
        (m68k_register_raw_size): Delete.
	(m68k_register_virtual_size): Delete.
	(m68k_register_type): Renamed from m68k_register_virtual_type and
	add gdbarch argument.
	(m68k_store_struct_return): Delete.
	(m68k_deprecated_extract_return_value): Delete.
	(m68k_deprecated_extract_struct_value_address): Delete.
	(m68k_frame_chain): Delete.
	(m68k_frame_saved_pc): Delete.
	(m68k_fix_call_dummy): Delete.
	(m68k_push_dummy_frame): Delete.
	(m68k_pop_frame): Delete.
	(m68k_extract_return_value): New function.
	(m68k_store_return_value): Rewrite using regcache.
	(m68k_extract_struct_value_address): Rewrite using regcache.
	(m68k_push_dummy_call): New function.
	(struct m68k_frame_cache): Define.
	(m68k_alloc_frame_cache): New function.
	(m68k_analyze_frame_setup): New function.
	(m68k_analyze_register_saves): New function.
	(m68k_analyze_prologue): New function.
	(m68k_skip_prologue): Rewrite using above functions.
	(m68k_unwind_pc): New function.
	(m68k_frame_cache): New function.
	(m68k_frame_this_id): New function.
	(m68k_frame_prev_register): New function.
	(m68k_frame_unwind): New variable.
	(m68k_frame_p): New function.
	(m68k_sigtramp_frame_cache): New function.
	(m68k_sigtramp_frame_this_id): New function.
	(m68k_sigtramp_frame_prev_register): New function.
	(m68k_sigtramp_frame_unwind): New variable.
	(m68k_sigtramp_frame_p): New function.
	(m68k_frame_base_address): New function.
	(m68k_frame_base): New function.
	(m68k_unwind_dummy_id): New function.
	(fill_gregset): Use regcache_collect.
	(fill_fpregset): Likewise.
	(m68k_saved_pc_after_call): Only define if SYSCALL_TRAP is
	defined.
	(m68k_gdbarch_init): Don't define call_dummy_words.  Don't set
	deprecated_init_frame_pc, deprecated_store_struct_return,
	deprecated_extract_return_value, deprecated_store_return_value,
	deprecated_frame_chain, deprecated_frame_saved_pc,
	deprecated_frame_init_saved_regs, deprecated_register_raw_size,
	deprecated_register_virtual_size,
	deprecated_max_register_raw_size,
	deprecated_max_register_virtual_size,
	deprecated_register_virtual_type, deprecated_register_size,
	deprecated_register_byte, deprecated_register_bytes,
	deprecated_fp_regnum, deprecated_use_generic_dummy_frames,
	call_dummy_location, deprecated_call_dummy_breakpoint_offset,
	deprecated_pc_in_call_dummy, deprecated_call_dummy_length,
	deprecated_call_dummy_start_offset, deprecated_call_dummy_words,
	deprecated_sizeof_call_dummy_words, deprecated_fix_call_dummy,
	deprecated_push_dummy_frame, deprecated_pop_frame,
	deprecated_dummy_write_sp.  Set deprecated_saved_pc_after_call
	only if SYSCALL_TRAP is defined.  Set extract_return_value,
	store_return_value, extract_struct_value_address, register_type,
	push_dummy_call, unwind_dummy_id, unwind_pc.  Add two frame unwind
	predicates.
	* m68k-tdep.h (M68K_D1_REGNUM, M68K_NUM_REGS,
	M68K_MAX_REGISTER_SIZE): Define.
	(struct m68k_sigtramp_info): Define.
	(struct gdbarch_tdep): Add get_sigtramp_info.
	* m68klinux-nat.c (fetch_register): Use register_size instead of
	REGISTER_RAW_SIZE.  Don't put assignment in if.
	(store_register): Likewise.
	(fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* m68klinux-tdep.c (m68k_linux_sigtramp_saved_pc): Delete.
	(m68k_linux_frame_saved_pc): Delete.
	(m68k_linux_sigcontext_reg_offset,
	m68k_linux_ucontext_reg_offset): Define.
	(m68k_linux_get_sigtramp_info): New function.
	(m68k_linux_extract_return_value): Rewrite using regcache.
	(m68k_linux_store_return_value): Likewise.
	(m68k_linux_extract_struct_value_address): Likewise.
	(m68k_linux_init_abi): Set get_sigtramp_info in tdep structure.
	Don't set deprecated_frame_saved_pc,
	deprecated_extract_return_value, deprecated_store_return_value,
	deprecated_extract_struct_value_address.  Set
	extract_return_value, store_return_value,
	extract_struct_value_address.
@
text
@a24 2
#include "frame-base.h"
#include "frame-unwind.h"
a28 1
#include "gdb_assert.h"
d40 8
a47 10
#define P_MOVEAL_SP_FP	0x2c4f
#define P_ADDAW_SP	0xdefc
#define P_ADDAL_SP	0xdffc
#define P_SUBQW_SP	0x514f
#define P_SUBQL_SP	0x518f
#define P_LEA_SP_SP	0x4fef
#define P_LEA_PC_A5	0x4bfb0170
#define P_FMOVEMX_SP	0xf227
#define P_MOVEL_SP	0x2f00
#define P_MOVEML_SP	0x48e7
d53 2
d56 1
d59 12
d80 3
d110 20
d139 1
a139 1
m68k_register_type (struct gdbarch *gdbarch, int regnum)
d192 14
a205 4

/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that, in virtual format,
   into VALBUF.  */
d208 2
a209 2
m68k_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
d211 5
a215 2
  int len = TYPE_LENGTH (type);
  char buf[M68K_MAX_REGISTER_SIZE];
d217 2
a218 6
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_extract_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }
d220 4
a223 15
  if (len <= 4)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (4 - len), len);
    }
  else if (len <= 8)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (8 - len), len - 4);
      regcache_raw_read (regcache, M68K_D1_REGNUM,
			 (char *) valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
d226 3
a228 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE, given in virtual format.  */
d231 1
a231 2
m68k_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d233 2
a234 1
  int len = TYPE_LENGTH (type);
d236 2
a237 6
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_store_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }
d239 4
a242 13
  if (len <= 4)
    regcache_raw_write_part (regcache, M68K_D0_REGNUM, 4 - len, len, valbuf);
  else if (len <= 8)
    {
      regcache_raw_write_part (regcache, M68K_D1_REGNUM, 8 - len,
			       len - 4, valbuf);
      regcache_raw_write (regcache, M68K_D0_REGNUM,
			  (char *) valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot store return value of %d bytes long.", len);
}
d244 3
a246 3
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */
d249 1
a249 1
m68k_extract_struct_value_address (struct regcache *regcache)
d251 6
a256 4
  char buf[4];

  regcache_cooked_read (regcache, M68K_D0_REGNUM, buf);
  return extract_unsigned_integer (buf, 4);
d272 17
d346 7
a352 5
static CORE_ADDR
m68k_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
d354 3
a356 37
  char buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
    {
      int len = TYPE_LENGTH (VALUE_ENCLOSING_TYPE (args[i]));
      int container_len = (len + 3) & ~3;
      int offset = container_len - len;

      sp -= container_len;
      write_memory (sp + offset, VALUE_CONTENTS_ALL (args[i]), len);
    }

  /* Push value address.  */
  if (struct_return)
    {
      sp -= 4;
      store_unsigned_integer (buf, 4, struct_addr);
      write_memory (sp, buf, 4);
    }

  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, bp_addr);
  write_memory (sp, buf, 4);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 4, sp);
  regcache_cooked_write (regcache, M68K_SP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, M68K_FP_REGNUM, buf);

  /* DWARF2/GCC uses the stack address *before* the function call as a
     frame's CFA.  */
  return sp + 8;
a357 7

struct m68k_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;
a358 3
  /* Saved registers.  */
  CORE_ADDR saved_regs[M68K_NUM_REGS];
  CORE_ADDR saved_sp;
d360 1
a360 3
  /* Stack space reserved for local variables.  */
  long locals;
};
d362 2
a363 4
/* Allocate and initialize a frame cache.  */

static struct m68k_frame_cache *
m68k_alloc_frame_cache (void)
d365 3
a367 2
  struct m68k_frame_cache *cache;
  int i;
d369 3
a371 1
  cache = FRAME_OBSTACK_ZALLOC (struct m68k_frame_cache);
d373 7
a379 4
  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;
d381 6
a386 9
  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %fp is supposed to be stored).  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    cache->saved_regs[i] = -1;

  /* Frameless until proven otherwise.  */
  cache->locals = -1;

  return cache;
d389 2
a390 5
/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */
d392 2
a393 3
static CORE_ADDR
m68k_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct m68k_frame_cache *cache)
d395 8
a402 8
  int op;

  if (pc >= current_pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 2);

  if (op == P_LINKW_FP || op == P_LINKL_FP || op == P_PEA_FP)
d404 1
a404 21
      cache->saved_regs[M68K_FP_REGNUM] = 0;
      cache->sp_offset += 4;
      if (op == P_LINKW_FP)
	{
	  /* link.w %fp, #-N */
	  /* link.w %fp, #0; adda.l #-N, %sp */
	  cache->locals = -read_memory_integer (pc + 2, 2);

	  if (pc + 4 < current_pc && cache->locals == 0)
	    {
	      op = read_memory_unsigned_integer (pc + 4, 2);
	      if (op == P_ADDAL_SP)
		{
		  cache->locals = read_memory_integer (pc + 6, 4);
		  return pc + 10;
		}
	    }

	  return pc + 4;
	}
      else if (op == P_LINKL_FP)
d406 3
a408 21
	  /* link.l %fp, #-N */
	  cache->locals = -read_memory_integer (pc + 2, 4);
	  return pc + 6;
	}
      else
	{
	  /* pea (%fp); movea.l %sp, %fp */
	  cache->locals = 0;

	  if (pc + 2 < current_pc)
	    {
	      op = read_memory_unsigned_integer (pc + 2, 2);

	      if (op == P_MOVEAL_SP_FP)
		{
		  /* move.l %sp, %fp */
		  return pc + 4;
		}
	    }

	  return pc + 2;
d411 1
a411 1
  else if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
d413 1
a413 4
      /* subq.[wl] #N,%sp */
      /* subq.[wl] #8,%sp; subq.[wl] #N,%sp */
      cache->locals = (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
      if (pc + 2 < current_pc)
d415 2
a416 6
	  op = read_memory_unsigned_integer (pc + 2, 2);
	  if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
	    {
	      cache->locals += (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
	      return pc + 4;
	    }
a417 8
      return pc + 2;
    }
  else if (op == P_ADDAW_SP || op == P_LEA_SP_SP)
    {
      /* adda.w #-N,%sp */
      /* lea (-N,%sp),%sp */
      cache->locals = -read_memory_integer (pc + 2, 2);
      return pc + 4;
d419 1
a419 1
  else if (op == P_ADDAL_SP)
d421 2
a422 3
      /* adda.l #-N,%sp */
      cache->locals = -read_memory_integer (pc + 2, 4);
      return pc + 6;
d424 4
a427 2

  return pc;
d429 1
d431 5
a435 4
/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */
d437 2
a438 9
static CORE_ADDR
m68k_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
			     struct m68k_frame_cache *cache)
{
  if (cache->locals >= 0)
    {
      CORE_ADDR offset;
      int op;
      int i, mask, regno;
d440 1
a440 50
      offset = -4 - cache->locals;
      while (pc < current_pc)
	{
	  op = read_memory_unsigned_integer (pc, 2);
	  if (op == P_FMOVEMX_SP)
	    {
	      /* fmovem.x REGS,-(%sp) */
	      op = read_memory_unsigned_integer (pc + 2, 2);
	      if ((op & 0xff00) == 0xe000)
		{
		  mask = op & 0xff;
		  for (i = 0; i < 16; i++, mask >>= 1)
		    {
		      if (mask & 1)
			{
			  cache->saved_regs[i + M68K_FP0_REGNUM] = offset;
			  offset -= 12;
			}
		    }
		  pc += 4;
		}
	      else
		break;
	    }
	  else if ((op & 0170677) == P_MOVEL_SP)
	    {
	      /* move.l %R,-(%sp) */
	      regno = ((op & 07000) >> 9) | ((op & 0100) >> 3);
	      cache->saved_regs[regno] = offset;
	      offset -= 4;
	      pc += 2;
	    }
	  else if (op == P_MOVEML_SP)
	    {
	      /* movem.l REGS,-(%sp) */
	      mask = read_memory_unsigned_integer (pc + 2, 2);
	      for (i = 0; i < 16; i++, mask >>= 1)
		{
		  if (mask & 1)
		    {
		      cache->saved_regs[15 - i] = offset;
		      offset -= 4;
		    }
		}
	      pc += 4;
	    }
	  else
	    break;
	}
    }
d442 1
a442 2
  return pc;
}
d444 1
d446 1
a446 3
/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.
d448 1
a448 1
   We handle all cases that can be generated by gcc.
d450 1
a450 1
   For allocating a stack frame:
d452 1
a452 10
   link.w %a6,#-N
   link.l %a6,#-N
   pea (%fp); move.l %sp,%fp
   link.w %a6,#0; add.l #-N,%sp
   subq.l #N,%sp
   subq.w #N,%sp
   subq.w #8,%sp; subq.w #N-8,%sp
   add.w #-N,%sp
   lea (-N,%sp),%sp
   add.l #-N,%sp
d454 1
a454 1
   For saving registers:
d456 1
a456 4
   fmovem.x REGS,-(%sp)
   move.l R1,-(%sp)
   move.l R1,-(%sp); move.l R2,-(%sp)
   movem.l REGS,-(%sp)
d458 2
a459 1
   For setting up the PIC register:
d461 1
a461 3
   lea (%pc,N),%a5

   */
d464 1
a464 2
m68k_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		       struct m68k_frame_cache *cache)
d466 6
a471 1
  unsigned int op;
d473 2
a474 4
  pc = m68k_analyze_frame_setup (pc, current_pc, cache);
  pc = m68k_analyze_register_saves (pc, current_pc, cache);
  if (pc >= current_pc)
    return current_pc;
d476 1
a476 3
  /* Check for GOT setup.  */
  op = read_memory_unsigned_integer (pc, 4);
  if (op == P_LEA_PC_A5)
d478 16
a493 2
      /* lea (%pc,N),%a5 */
      return pc + 6;
d495 1
a495 2

  return pc;
d498 5
a502 1
/* Return PC of first real instruction.  */
d504 2
a505 2
static CORE_ADDR
m68k_skip_prologue (CORE_ADDR start_pc)
d507 4
a510 3
  struct m68k_frame_cache cache;
  CORE_ADDR pc;
  int op;
d512 3
a514 6
  cache.locals = -1;
  pc = m68k_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache);
  if (cache.locals < 0)
    return start_pc;
  return pc;
}
d516 1
a516 4
static CORE_ADDR
m68k_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[8];
d518 2
a519 5
  frame_unwind_register (next_frame, PC_REGNUM, buf);
  return extract_typed_address (buf, builtin_type_void_func_ptr);
}

/* Normal frames.  */
d521 1
a521 57
static struct m68k_frame_cache *
m68k_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache;
  char buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, %fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */

  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %pc is stored at 4(%fp).  */
  cache->saved_regs[M68K_PC_REGNUM] = 4;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    m68k_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %sp in the calling frame.  */
  cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;
d523 1
a523 2
  return cache;
}
d525 3
a527 5
static void
m68k_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);
d529 4
a532 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d534 6
a539 3
  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, cache->pc);
}
d541 21
a561 17
static void
m68k_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == M68K_SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
d563 2
a564 2
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
d566 6
a571 1
      return;
d574 1
a574 1
  if (regnum < M68K_NUM_REGS && cache->saved_regs[regnum] != -1)
d576 4
a579 5
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
d581 5
a585 3
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
d587 4
a590 2
      return;
    }
d592 26
a617 3
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}
d619 57
a675 11
static const struct frame_unwind m68k_frame_unwind =
{
  NORMAL_FRAME,
  m68k_frame_this_id,
  m68k_frame_prev_register
};

static const struct frame_unwind *
m68k_frame_p (CORE_ADDR pc)
{
  return &m68k_frame_unwind;
a676 19

/* Signal trampolines.  */

static struct m68k_frame_cache *
m68k_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct m68k_sigtramp_info info;
  char buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();

  frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4) - 4;
a677 9
  info = tdep->get_sigtramp_info (next_frame);

  for (i = 0; i < M68K_NUM_REGS; i++)
    if (info.sc_reg_offset[i] != -1)
      cache->saved_regs[i] = info.sigcontext_addr + info.sc_reg_offset[i];

  *this_cache = cache;
  return cache;
}
a678 78
static void
m68k_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct m68k_frame_cache *cache =
    m68k_sigtramp_frame_cache (next_frame, this_cache);

  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
}

static void
m68k_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  m68k_sigtramp_frame_cache (next_frame, this_cache);

  m68k_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind m68k_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  m68k_sigtramp_frame_this_id,
  m68k_sigtramp_frame_prev_register
};

static const struct frame_unwind *
m68k_sigtramp_frame_p (CORE_ADDR pc)
{
  char *name;

  /* We shouldn't even bother to try if the OSABI didn't register
     a get_sigtramp_info handler.  */
  if (!gdbarch_tdep (current_gdbarch)->get_sigtramp_info)
    return NULL;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &m68k_sigtramp_frame_unwind;

  return NULL;
}

static CORE_ADDR
m68k_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base m68k_frame_base =
{
  &m68k_frame_unwind,
  m68k_frame_base_address,
  m68k_frame_base_address,
  m68k_frame_base_address
};

static struct frame_id
m68k_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[4];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);

  /* See the end of m68k_push_dummy_call.  */
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
}

d748 12
a759 2
      if (regno == -1 || regno == regi)
	regcache_collect (regi, regp + regi);
a760 4
  if (regno == -1 || regno == PS_REGNUM)
    regcache_collect (PS_REGNUM, regp + R_PS);
  if (regno == -1 || regno == PC_REGNUM)
    regcache_collect (PC_REGNUM, regp + R_PC);
d794 2
d799 18
a816 2
      if (regno == -1 || regno == regi)
	regcache_collect (regi, &fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
a817 6
  if (regno == -1 || regno == M68K_FPC_REGNUM)
    regcache_collect (M68K_FPC_REGNUM, &fpregsetp->f_pcr);
  if (regno == -1 || regno == M68K_FPS_REGNUM)
    regcache_collect (M68K_FPS_REGNUM, &fpregsetp->f_psr);
  if (regno == -1 || regno == M68K_FPI_REGNUM)
    regcache_collect (M68K_FPI_REGNUM, &fpregsetp->f_fpiaddr);
a859 1
#ifdef SYSCALL_TRAP
d868 1
d876 1
a878 1
#endif /* SYSCALL_TRAP */
d887 4
d902 4
a911 1
#ifdef SYSCALL_TRAP
a912 1
#endif
d922 8
a929 5
  set_gdbarch_extract_return_value (gdbarch, m68k_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, m68k_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m68k_extract_struct_value_address);

d934 5
a938 1
  set_gdbarch_register_type (gdbarch, m68k_register_type);
d940 2
d944 1
d946 1
d951 15
a965 1
  set_gdbarch_push_dummy_call (gdbarch, m68k_push_dummy_call);
a975 6
  tdep->get_sigtramp_info = NULL;

  /* Frame unwinder.  */
  set_gdbarch_unwind_dummy_id (gdbarch, m68k_unwind_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, m68k_unwind_pc);
  frame_base_set_default (gdbarch, &m68k_frame_base);
a984 3

  frame_unwind_append_predicate (gdbarch, m68k_sigtramp_frame_p);
  frame_unwind_append_predicate (gdbarch, m68k_frame_p);
@


1.69.4.2
log
@	* m68k-tdep.h (enum struct_return): Define.
	(struct gdbarch_tdep): Add struct_return.
	* m68k-tdep.c (m68k_push_dummy_call): Non-scalars bigger than 4
	bytes are padded to the right, not to the left.  Pass struct value
	address in register %a1, not on stack.
	(m68k_use_struct_convention): New function.
	(m68k_gdbarch_init): Set use_struct_convention.  Initialize
	struct_return in tdep to pcc_struct_return.
	* m68klinux-tdep.c (m68k_linux_init_abi): Set struct_return to
	reg_struct_return.
@
text
@a237 10
static int
m68k_use_struct_convention (int gcc_p, struct type *type)
{
  enum struct_return struct_return;

  struct_return = gdbarch_tdep (current_gdbarch)->struct_return;
  return generic_use_struct_convention (struct_return == reg_struct_return,
					type);
}

d320 1
a320 2
      struct type *value_type = VALUE_ENCLOSING_TYPE (args[i]);
      int len = TYPE_LENGTH (value_type);
d322 1
a322 1
      int offset;
a323 9
      /* Non-scalars bigger than 4 bytes are left aligned, others are
	 right aligned.  */
      if ((TYPE_CODE (value_type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (value_type) == TYPE_CODE_UNION
	   || TYPE_CODE (value_type) == TYPE_CODE_ARRAY)
	  && len > 4)
	offset = 0;
      else
	offset = container_len - len;
d328 1
a328 1
  /* Store struct value address.  */
d331 1
d333 1
a333 1
      regcache_cooked_write (regcache, M68K_A1_REGNUM, buf);
a1102 1
  set_gdbarch_use_struct_convention (gdbarch, m68k_use_struct_convention);
a1128 1
  tdep->struct_return = pcc_struct_return;
@


1.68
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d934 2
a935 2
  set_gdbarch_register_raw_size (gdbarch, m68k_register_raw_size);
  set_gdbarch_register_virtual_size (gdbarch, m68k_register_virtual_size);
d938 1
a938 1
  set_gdbarch_register_virtual_type (gdbarch, m68k_register_virtual_type);
d941 1
a941 1
  set_gdbarch_register_byte (gdbarch, m68k_register_byte);
@


1.67
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d999 2
@


1.66
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (deprecated_write_sp): Replace
	generic_target_write_sp.
	* regcache.c (deprecated_write_sp): Replace
	generic_target_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Update.
@
text
@a931 2
  /* OK to default this value to 'unknown'. */
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.65
log
@	* m68k-tdep.c (m68k_gdbarch_init): Use set_gdbarch_print_insn ...
	(_initialize_m68k_tdep): ... instead of deprecated_tm_print_insn.
@
text
@d967 1
a967 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.64
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (extract_address): Delete declaration.
	* findvar.c (extract_address): Delete function.
	* xstormy16-tdep.c (xstormy16_extract_return_value): Replace
	extract_address with the inline equivalent,
	extract_unsigned_integer.
	(xstormy16_extract_struct_value_address): Ditto.
	(xstormy16_pointer_to_address): Ditto.
	* vax-tdep.c (vax_extract_struct_value_address): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	(v850_extract_return_value): Ditto.
	(v850_extract_struct_value_address): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_get_longjmp_target_32): Ditto.
	(sparcnbsd_get_longjmp_target_64): Ditto.
	* sparc-tdep.c (sparc_frame_saved_pc): Ditto.
	(get_longjmp_target): Ditto.
	* sh-tdep.c (sh_extract_struct_value_address): Ditto.
	(sh64_extract_struct_value_address): Ditto.
	(sh_push_arguments): Ditto.
	(sh64_push_arguments): Ditto.
	* remote-vxsparc.c (vx_read_register): Ditto.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Ditto.
	* ns32k-tdep.c (ns32k_extract_struct_value_address): Ditto.
	* mn10300-tdep.c (mn10300_extract_struct_value_address): Ditto.
	* mipsv4-nat.c (get_longjmp_target): Ditto.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Ditto.
	* mips-nat.c (get_longjmp_target): Ditto.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Ditto.
	* mcore-tdep.c (mcore_extract_struct_value_address): Ditto.
	* m68k-tdep.c (m68k_get_longjmp_target): Ditto.
	* m68hc11-tdep.c (m68hc11_extract_struct_value_address): Ditto.
	* irix5-nat.c (get_longjmp_target): Ditto.
	* irix4-nat.c (get_longjmp_target): Ditto.
	* ia64-tdep.c (generic_elf_find_global_pointer): Ditto.
	(ia64_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_store_registers): Ditto.
	* h8300-tdep.c (h8300_push_arguments): Ditto.
	(h8300_store_return_value): Ditto.
	(h8300_extract_struct_value_address): Ditto.
	* frv-tdep.c (frv_extract_struct_value_address): Ditto.
	(frv_push_arguments): Ditto.
	* avr-tdep.c (avr_pointer_to_address): Ditto.
	(avr_push_arguments): Ditto.
	* arm-tdep.c (arm_push_dummy_call): Ditto.
	(arm_get_longjmp_target): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_extract_struct_value_address): Ditto.
	(alpha_get_longjmp_target): Ditto.
@
text
@d969 3
a1004 1
  deprecated_tm_print_insn = print_insn_m68k;
@


1.63
log
@	* m68k-tdep.c (m68k_gdbarch_init): Set parm_boundary instead of
	stack_align and deprecated_extra_stack_alignment_needed.
	(m68k_stack_align): Delete.
@
text
@d850 1
a850 1
  jb_addr = extract_address (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
d856 1
a856 1
  *pc = extract_address (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
@


1.62
log
@	* m68k-tdep.c (m68k_register_raw_size): Remove cast.
	(m68k_register_virtual_size): Likewise.
	(altos_skip_prologue): Remove obsolete function.
	(isi_frame_num_args): Likewise.
	(news_frame_num_args): Likewise.
	(m68k_fix_call_dummy): Make static.
	(m68k_push_dummy_frame): Likewise.
	(m68k_pop_frame): Likewise.
	(m68k_skip_prologue): Likewise.
	(m68k_frame_init_saved_regs): Likewise.
	(m68k_saved_pc_after_call): Likewise.
	(m68k_get_longjmp_target): Make multi-arch.
	(m68k_gdbarch_init): Allocate and initialize gdbarch_tdep
	structure.  Register m68k_get_longjmp_target if enabled.
	* m68k-tdep.h (struct gdbarch_tdep): Define.
	* config/m68k/tm-m68k.h: Don't include "regcache.h".

	* Makefile.in (config.status): Also depend on configure.tgt
	and configure.host.
	(m68klinux-tdep.o): Update dependencies.
	* configure.tgt (m68*-*-linux*): Set gdb_multi_arch to 1.
	* m68klinux-tdep.c (M68K_LINUX_JB_ELEMENT_SIZE): Define.
	(M68K_LINUX_JB_PC): Define.
	(m68k_linux_pc_in_sigtramp): Renamed from m68k_linux_in_sigtramp
	and take additional parameter.
	(m68k_linux_sigtramp_saved_pc): Update.
	(m68k_linux_init_abi): Set jb_pc and jb_elt_size.  Register
	m68k_linux_pc_in_sigtramp, in_plt_section,
	find_solib_trampoline_target.
	* config/m68k/tm-linux.h: Don't include any tm headers.
	(START_INFERIOR_TRAPS_EXPECTED): Remove definition.
	(JB_ELEMENT_SIZE): Likewise.
	(JB_PC): Likewise.
	(GET_LONGJMP_TARGET): Likewise.
	(IN_SIGTRAMP): Likewise.
	(SVR4_SHARED_LIBS): Define this and include "solib.h".
@
text
@a178 8
/* Stack must be kept short aligned when doing function calls.  */

static CORE_ADDR
m68k_stack_align (CORE_ADDR addr)
{
  return ((addr + 1) & ~1);
}

d917 1
a917 2
  set_gdbarch_stack_align (gdbarch, m68k_stack_align);
  set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
@


1.61
log
@	* Makefile.in (m68k-tdep.o, m68klinux-tdep.o): Update
	dependencies.
	* m68k-tdep.c (m68k_gdbarch_init): Call gdbarch_init_osabi at the
	end.
	* m68klinux-tdep.c (m68k_linux_init_abi): New function.
	(_initialize_m68k_linux_tdep): New function.
	(m68k_linux_frame_saved_pc): Make static.
	(m68k_linux_extract_return_value): Likewise.
	(m68k_linux_store_return_value): Likewise.
	(m68k_linux_extract_struct_value_address): Likewise.
	* config/m68k/tm-linux.h (DEPRECATED_EXTRACT_RETURN_VALUE):
	Remove.
	(DEPRECATED_STORE_RETURN_VALUE): Remove.
	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Remove.
	(DEPRECATED_FRAME_SAVED_PC): Remove.
@
text
@d80 1
a80 1
void m68k_frame_init_saved_regs (struct frame_info *frame_info);
d86 1
a86 1
const static unsigned char *
d94 1
a94 1
const static unsigned char *
a112 2
/* Note that the unsigned cast here forces the result of the
   subtraction to very high positive values if regnum < FP0_REGNUM */
d117 1
a117 1
  return (((unsigned) (regnum) - FP0_REGNUM) < 8 ? 12 : 4);
d127 1
a127 1
  return (((unsigned) (regnum) - FP0_REGNUM) < 8 ? 12 : 4);
a296 22
/* The only reason this is here is the tm-altos.h reference below.  It
   was moved back here from tm-m68k.h.  FIXME? */

extern CORE_ADDR
altos_skip_prologue (CORE_ADDR pc)
{
  register int op = read_memory_unsigned_integer (pc, 2);
  if (op == P_LINKW_FP)
    pc += 4;			/* Skip link #word */
  else if (op == P_LINKL_FP)
    pc += 6;			/* Skip link #long */
  /* Not sure why branches are here.  */
  /* From tm-altos.h */
  else if (op == 0060000)
    pc += 4;			/* Skip bra #word */
  else if (op == 00600377)
    pc += 6;			/* skip bra #long */
  else if ((op & 0177400) == 0060000)
    pc += 2;			/* skip bra #char */
  return pc;
}

a331 25
/* Return number of args passed to a frame.
   Can return -1, meaning no way to tell.  */

int
isi_frame_num_args (struct frame_info *fi)
{
  int val;
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
  int insn = read_memory_unsigned_integer (pc, 2);
  val = 0;
  if (insn == 0047757 || insn == 0157374)	/* lea W(sp),sp or addaw #W,sp */
    val = read_memory_integer (pc + 2, 2);
  else if ((insn & 0170777) == 0050217	/* addql #N, sp */
	   || (insn & 0170777) == 0050117)	/* addqw */
    {
      val = (insn >> 9) & 7;
      if (val == 0)
	val = 8;
    }
  else if (insn == 0157774)	/* addal #WW, sp */
    val = read_memory_integer (pc + 2, 4);
  val >>= 2;
  return val;
}

a353 22
int
news_frame_num_args (struct frame_info *fi)
{
  int val;
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
  int insn = read_memory_unsigned_integer (pc, 2);
  val = 0;
  if (insn == 0047757 || insn == 0157374)	/* lea W(sp),sp or addaw #W,sp */
    val = read_memory_integer (pc + 2, 2);
  else if ((insn & 0170777) == 0050217	/* addql #N, sp */
	   || (insn & 0170777) == 0050117)	/* addqw */
    {
      val = (insn >> 9) & 7;
      if (val == 0)
	val = 8;
    }
  else if (insn == 0157774)	/* addal #WW, sp */
    val = read_memory_integer (pc + 2, 4);
  val >>= 2;
  return val;
}

d358 1
a358 1
void
d370 1
a370 1
void
d400 1
a400 1
void
d471 1
a471 1
CORE_ADDR
d512 1
a512 1
void
a836 5
/* NOTE: cagney/2000-11-08: For this function to be fully multi-arched
   the macro's JB_PC and JB_ELEMENT_SIZE would need to be moved into
   the ``struct gdbarch_tdep'' object and then set on a target ISA/ABI
   dependant basis. */

a839 1
#if defined (JB_PC) && defined (JB_ELEMENT_SIZE)
d842 8
d860 1
a860 1
  if (target_read_memory (jb_addr + JB_PC * JB_ELEMENT_SIZE, buf,
a864 1

a865 5
#else
  internal_error (__FILE__, __LINE__,
		  "m68k_get_longjmp_target: not implemented");
  return 0;
#endif
d873 1
a873 1
CORE_ADDR
d907 2
a908 5
#if 0
  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
#endif
 
  gdbarch = gdbarch_alloc (&info, 0);
d978 7
d988 6
d1001 1
d1003 2
@


1.60
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d32 1
d1055 3
@


1.59
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d1032 1
a1032 1
  set_gdbarch_register_bytes (gdbarch, (16 * 4 + 8 + 8 * 12 + 3 * 4));
@


1.58
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d432 1
a432 1
  bfd_putb32 (fun, (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 2);
d434 1
a434 1
	      (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 8);
d1028 1
a1028 1
  set_gdbarch_register_size (gdbarch, 4);
d1041 1
a1041 1
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 24);
d1043 2
a1044 2
  set_gdbarch_call_dummy_length (gdbarch, 28);
  set_gdbarch_call_dummy_start_offset (gdbarch, 12);
d1046 3
a1048 3
  set_gdbarch_call_dummy_words (gdbarch, call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_words));
  set_gdbarch_fix_call_dummy (gdbarch, m68k_fix_call_dummy);
@


1.57
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (deprecated_tm_print_insn): Rename tm_print_insn.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (_initialize_xstormy16_tdep): Update.
	* vax-tdep.c (_initialize_vax_tdep): Update.
	* v850-tdep.c (_initialize_v850_tdep): Update.
	* sparc-tdep.c (_initialize_sparc_tdep): Update.
	* s390-tdep.c (_initialize_s390_tdep): Update.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Update.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* m68k-tdep.c (_initialize_m68k_tdep): Update.
	* ia64-tdep.c (_initialize_ia64_tdep): Update.
	* hppa-tdep.c (_initialize_hppa_tdep): Update.
	* h8300-tdep.c (_initialize_h8300_tdep): Update.
	* frv-tdep.c (_initialize_frv_tdep): Update.
	* cris-tdep.c (cris_delayed_get_disassembler): Update.
	(_initialize_cris_tdep): Update.
	* arch-utils.c (legacy_print_insn): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	"tm_print_insn" to "deprecated_tm_print_insn".
@
text
@d448 2
a449 2
  sp = push_word (sp, read_register (FP_REGNUM));
  write_register (FP_REGNUM, sp);
d459 1
a459 1
  for (regnum = FP_REGNUM - 1; regnum >= 0; regnum--)
d489 1
a489 1
  for (regnum = FP_REGNUM - 1; regnum >= 0; regnum--)
d502 1
a502 1
  write_register (FP_REGNUM, read_memory_integer (fp, 4));
d592 1
a592 1
    get_frame_base (frame_info) - 28 - FP_REGNUM * 4 - 4 - 8 * 12;
d746 1
a746 1
  get_frame_saved_regs (frame_info)[FP_REGNUM] = get_frame_base (frame_info);
d1034 1
a1034 1
  set_gdbarch_fp_regnum (gdbarch, M68K_FP_REGNUM);
@


1.56
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d1069 1
a1069 1
  tm_print_insn = print_insn_m68k;
@


1.56.2.1
log
@Merge from mainline.
@
text
@d448 2
a449 2
  sp = push_word (sp, read_register (DEPRECATED_FP_REGNUM));
  write_register (DEPRECATED_FP_REGNUM, sp);
d459 1
a459 1
  for (regnum = DEPRECATED_FP_REGNUM - 1; regnum >= 0; regnum--)
d489 1
a489 1
  for (regnum = DEPRECATED_FP_REGNUM - 1; regnum >= 0; regnum--)
d502 1
a502 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, 4));
d592 1
a592 1
    get_frame_base (frame_info) - 28 - DEPRECATED_FP_REGNUM * 4 - 4 - 8 * 12;
d746 1
a746 1
  get_frame_saved_regs (frame_info)[DEPRECATED_FP_REGNUM] = get_frame_base (frame_info);
d1034 1
a1034 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, M68K_FP_REGNUM);
d1069 1
a1069 1
  deprecated_tm_print_insn = print_insn_m68k;
@


1.56.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d432 1
a432 1
  bfd_putb32 (fun, (unsigned char *) dummy + DEPRECATED_CALL_DUMMY_START_OFFSET + 2);
d434 1
a434 1
	      (unsigned char *) dummy + DEPRECATED_CALL_DUMMY_START_OFFSET + 8);
d1028 1
a1028 1
  set_gdbarch_deprecated_register_size (gdbarch, 4);
d1032 1
a1032 1
  set_gdbarch_deprecated_register_bytes (gdbarch, (16 * 4 + 8 + 8 * 12 + 3 * 4));
d1041 1
a1041 1
  set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 24);
d1043 2
a1044 2
  set_gdbarch_deprecated_call_dummy_length (gdbarch, 28);
  set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 12);
d1046 3
a1048 3
  set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_words));
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, m68k_fix_call_dummy);
@


1.55
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d997 1
a997 1
  set_gdbarch_saved_pc_after_call (gdbarch, m68k_saved_pc_after_call);
@


1.54
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d617 1
a617 1
      pc = get_pc_function_start (get_frame_pc (frame_info));
@


1.54.2.1
log
@Merge with mainline.
@
text
@d617 1
a617 1
      pc = get_frame_func (frame_info);
@


1.53
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a1040 1
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
@


1.52
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a1043 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.51
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Replace
	EXTRA_STACK_ALIGNMENT_NEEDED.  Default to 0 not 1.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h
	(DEPRECATED_EXTRA_STACK_ALIGNMENT_NEEDED): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Set
	deprecated_extra_stack_alignment_needed.
	* config/pa/tm-hppa.h (EXTRA_STACK_ALIGNMENT_NEEDED): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not clear
	extra_stack_alignment_needed.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@d1054 3
@


1.51.2.1
log
@Merge with mainline.
@
text
@a1053 3
  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);

@


1.50
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d1003 1
a1003 1

@


1.49
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d1008 1
a1008 1
  set_gdbarch_store_struct_return (gdbarch, m68k_store_struct_return);
@


1.48
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@a1044 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
a1049 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.47
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d248 4
a251 4
/* FRAME_CHAIN takes a frame's nominal address and produces the frame's
   chain-pointer.
   In the case of the 68000, the frame's nominal address
   is the address of a 4-byte word containing the calling frame's address.  */
d1013 1
a1013 1
  set_gdbarch_frame_chain (gdbarch, m68k_frame_chain);
@


1.46
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d1054 1
a1054 1
  set_gdbarch_pop_frame (gdbarch, m68k_pop_frame);
@


1.45
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d362 1
a362 1
  CORE_ADDR pc = FRAME_SAVED_PC (fi);
d384 1
a384 1
  CORE_ADDR pc = FRAME_SAVED_PC (fi);
d406 1
a406 1
  CORE_ADDR pc = FRAME_SAVED_PC (fi);
d1014 1
a1014 1
  set_gdbarch_frame_saved_pc (gdbarch, m68k_frame_saved_pc);
@


1.45.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d362 1
a362 1
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
d384 1
a384 1
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
d406 1
a406 1
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
d1014 1
a1014 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, m68k_frame_saved_pc);
d1054 1
a1054 1
  set_gdbarch_deprecated_pop_frame (gdbarch, m68k_pop_frame);
@


1.44
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d1024 2
a1025 2
  set_gdbarch_max_register_raw_size (gdbarch, 12);
  set_gdbarch_max_register_virtual_size (gdbarch, 12);
@


1.43
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d1015 1
a1015 1
  set_gdbarch_frame_init_saved_regs (gdbarch, m68k_frame_init_saved_regs);
@


1.42
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d1053 1
a1053 1
  set_gdbarch_push_dummy_frame (gdbarch, m68k_push_dummy_frame);
@


1.41
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d286 2
a287 2
      if (frame->next)
	return read_memory_unsigned_integer (get_frame_base (frame->next)
d339 2
a340 2
      if (frame_info->next && (get_frame_type (frame_info->next) == SIGTRAMP_FRAME))
	return get_frame_base (frame_info->next) + 16;
@


1.40
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d261 1
a261 1
    return thisframe->frame;
d263 1
a263 1
    return read_memory_unsigned_integer (thisframe->frame, 4);
d287 1
a287 1
	return read_memory_unsigned_integer (frame->next->frame
d294 1
a294 1
    return read_memory_unsigned_integer (frame->frame + 4, 4);
d335 1
a335 1
    return frame_info->frame + 12;
d340 1
a340 1
	return frame_info->next->frame + 16;
d342 1
a342 1
	return frame_info->frame + 4;
d345 1
a345 1
    return frame_info->frame;
d592 1
a592 1
    frame_info->frame - 28 - FP_REGNUM * 4 - 4 - 8 * 12;
d604 1
a604 1
      && get_frame_pc (frame_info) <= frame_info->frame)
d612 1
a612 1
      next_addr = frame_info->frame;
d625 1
a625 1
	  next_addr = frame_info->frame;
d633 1
a633 1
	  next_addr = frame_info->frame + read_memory_integer (pc + 2, 4);
d641 1
a641 1
	  next_addr = frame_info->frame + read_memory_integer (pc + 2, 2);
d670 1
a670 1
	  addr = frame_info->frame + read_memory_integer (pc + 4, 2);
d697 1
a697 1
	  addr = frame_info->frame + read_memory_integer (pc + 4, 2);
d745 3
a747 3
  get_frame_saved_regs (frame_info)[SP_REGNUM] = (frame_info)->frame + 8;
  get_frame_saved_regs (frame_info)[FP_REGNUM] = (frame_info)->frame;
  get_frame_saved_regs (frame_info)[PC_REGNUM] = (frame_info)->frame + 4;
@


1.39
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
a1013 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);
@


1.38
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d481 1
a481 1
      if (frame->saved_regs[regnum])
d483 1
a483 1
	  read_memory (frame->saved_regs[regnum], raw_buffer, 12);
d490 1
a490 1
      if (frame->saved_regs[regnum])
d493 1
a493 1
			  read_memory_integer (frame->saved_regs[regnum], 4));
d496 1
a496 1
  if (frame->saved_regs[PS_REGNUM])
d499 1
a499 1
		      read_memory_integer (frame->saved_regs[PS_REGNUM], 4));
d595 1
a595 1
  if (frame_info->saved_regs)
d600 1
a600 1
  memset (frame_info->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
d661 1
a661 1
	      frame_info->saved_regs[regnum] = (next_addr -= 12);
d674 1
a674 1
		frame_info->saved_regs[regnum] = addr;
d686 1
a686 1
		frame_info->saved_regs[regnum] = next_addr;
d701 1
a701 1
		frame_info->saved_regs[regnum] = addr;
d712 1
a712 1
	      frame_info->saved_regs[regnum] = (next_addr -= 4);
d719 1
a719 1
	  frame_info->saved_regs[regnum] = (next_addr -= 4);
d729 1
a729 1
		frame_info->saved_regs[regnum] = next_addr;
d737 1
a737 1
	  frame_info->saved_regs[PS_REGNUM] = (next_addr -= 4);
d744 3
a746 3
  frame_info->saved_regs[SP_REGNUM] = (frame_info)->frame + 8;
  frame_info->saved_regs[FP_REGNUM] = (frame_info)->frame;
  frame_info->saved_regs[PC_REGNUM] = (frame_info)->frame + 4;
@


1.37
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d261 1
a261 1
  else if (!inside_entry_file (thisframe->pc))
d602 2
a603 2
  if (frame_info->pc >= possible_call_dummy_start
      && frame_info->pc <= frame_info->frame)
d616 1
a616 1
      pc = get_pc_function_start (frame_info->pc);
@


1.36
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d986 4
@


1.35
log
@	* m68k-tdep.c (m68k_frame_chain, m68k_frame_saved_pc)
	(altos_skip_prologue, delta68_frame_saved_pc, isi_frame_num_args)
	(delta68_frame_num_args, news_frame_num_args, m68k_skip_prologue)
	(m68k_frame_init_saved_regs, m68k_saved_pc_after_call): Use
	read_memory_unsigned_integer instead of read_memory_integer when
	dealing with addresses and instruction opcodes.
	* m68klinux-tdep.c (m68k_linux_sigtramp_saved_pc)
	(m68k_linux_frame_saved_pc): Likewise.
@
text
@d1039 1
a1039 1
  set_gdbarch_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
@


1.34
log
@2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_USE_GENERIC_DUMMY_FRAMES): Rename
	USE_GENERIC_DUMMY_FRAMES.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c, frame.c: Update.
	* config/z8k/tm-z8k.h, config/mn10200/tm-mn10200.h: Update.
	* config/m32r/tm-m32r.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, blockframe.c: Update.
	* vax-tdep.c, sparc-tdep.c, ns32k-tdep.c: Ditto.
	* m68k-tdep.c, alpha-tdep.c: Ditto.

	* arm-tdep.c: Eliminate USE_GENERIC_DUMMY_FRAMES as always 1.
	* mips-tdep.c: Ditto.

Index: doc/ChangeLog
2002-11-28  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Host Definition): Delete documentation on
	USE_GENERIC_DUMMY_FRAMES.
@
text
@d262 1
a262 1
    return read_memory_integer (thisframe->frame, 4);
d286 2
a287 1
	return read_memory_integer (frame->next->frame + SIG_PC_FP_OFFSET, 4);
d289 2
a290 2
	return read_memory_integer (read_register (SP_REGNUM)
				    + SIG_PC_FP_OFFSET - 8, 4);
d293 1
a293 1
    return read_memory_integer (frame->frame + 4, 4);
d303 1
a303 1
  register int op = read_memory_integer (pc, 2);
d350 2
a351 1
  return read_memory_integer (delta68_frame_args_address (frame_info) + 4, 4);
d362 1
a362 1
  int insn = 0177777 & read_memory_integer (pc, 2);
d384 1
a384 1
  int insn = 0177777 & read_memory_integer (pc, 2);
d406 1
a406 1
  int insn = 0177777 & read_memory_integer (pc, 2);
d555 1
a555 2
      op = read_memory_integer (ip, 2);
      op &= 0xFFFF;
d591 1
a591 1
    (frame_info)->frame - 28 - FP_REGNUM * 4 - 4 - 8 * 12;
d602 2
a603 2
  if ((frame_info)->pc >= possible_call_dummy_start
      && (frame_info)->pc <= (frame_info)->frame)
d611 1
a611 1
      next_addr = (frame_info)->frame;
d616 1
a616 1
      pc = get_pc_function_start ((frame_info)->pc);
d618 1
a618 1
      nextinsn = read_memory_integer (pc, 2);
d620 1
a620 1
	  && P_MOVL_SP_FP == read_memory_integer (pc + 2, 2))
d632 1
a632 1
	  next_addr = (frame_info)->frame + read_memory_integer (pc + 2, 4);
d640 1
a640 1
	  next_addr = (frame_info)->frame + read_memory_integer (pc + 2, 2);
d647 1
a647 1
      if ((0177777 & read_memory_integer (pc, 2)) == 0157774)
d653 2
a654 2
      nextinsn = 0xffff & read_memory_integer (pc, 2);
      regmask = read_memory_integer (pc + 2, 2);
d669 1
a669 1
	  addr = (frame_info)->frame + read_memory_integer (pc + 4, 2);
d696 1
a696 1
	  addr = (frame_info)->frame + read_memory_integer (pc + 4, 2);
d952 1
a952 1
  op = read_memory_integer (frame->pc - SYSCALL_TRAP_OFFSET, 2);
d955 1
a955 1
    return read_memory_integer (read_register (SP_REGNUM) + 4, 4);
d958 1
a958 1
    return read_memory_integer (read_register (SP_REGNUM), 4);
@


1.33
log
@2002-11-26  Andrew Cagney  <ac131313@@redhat.com>

	* inferior.h (deprecated_pc_in_call_dummy_before_text_end): Rename
	pc_in_call_dummy_before_text_end
	(deprecated_pc_in_call_dummy_after_text_end): Rename
	pc_in_call_dummy_after_text_end.
	(deprecated_pc_in_call_dummy_on_stack): Rename
	pc_in_call_dummy_on_stack.
	(deprecated_pc_in_call_dummy_at_entry_point): Rename
	pc_in_call_dummy_at_entry_point.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (PC_IN_CALL_DUMMY): Update.
	* blockframe.c (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end)
	(deprecated_pc_in_call_dummy_on_stack)
	(deprecated_pc_in_call_dummy_at_entry_point): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d1034 1
a1034 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);
@


1.32
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@d1038 1
a1038 1
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
@


1.31
log
@	* Makefile.in (m68k_tdep_h): Define.
	(abug-rom.o, cpu32bug-rom.o, dbug-rom.o, m68k-tdep.o, m68klinux-nat.o)
	(remote-est.o, rom68k-rom.o): Add $(m68k_tdep_h).
	* m68k-tdep.c: Move register number enum ...
	* m68k-tdep.h: ... to this new file and rename the constants from
	E_* to M68K_*.  All uses changed.
	* config/m68k/tm-m68k.h (D0_REGNUM, A0_REGNUM): Remove definitions.
	* abug-rom.c: Include "m68k-tdep.h".  Use
	M68K_D0_REGNUM/M68K_A0_REGNUM instead of D0_REGNUM/A0_REGNUM.
	* cpu32bug-rom.c: Likewise.
	* dbug-rom.c: Likewise.
	* m68k-tdep.c: Likewise.
	* m68klinux-nat.c: Likewise.
	* remote-est.c: Likewise.
	* rom68k-rom.c: Likewise.
	* config/m68k/tm-linux.h: Likewise.
@
text
@d475 1
a475 1
  fp = FRAME_FP (frame);
@


1.30
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS): Default
	to default_frame_address.
	* gdbarch.h, gdbarch.c: Re-generate.

	* d10v-tdep.c (d10v_gdbarch_init): Do not set frame_args_address
	or frame_locals_address to default_frame_address.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.

	* cris-tdep.c (cris_frame_args_address): Delete function.
	(cris_frame_locals_address): Delete function.
	(cris_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
@
text
@d31 2
a47 23
/* Register numbers of various important registers.
   Note that some of these values are "real" register numbers,
   and correspond to the general registers of the machine,
   and some are "phony" register numbers which are too large
   to be actual register numbers as far as the user is concerned
   but do serve to get the desired values when passed to read_register.  */

/* Note: Since they are used in files other than this (monitor files), 
   D0_REGNUM and A0_REGNUM are currently defined in tm-m68k.h.  */

enum
{
  E_A1_REGNUM = 9,
  E_FP_REGNUM = 14,		/* Contains address of executing stack frame */
  E_SP_REGNUM = 15,		/* Contains address of top of stack */
  E_PS_REGNUM = 16,		/* Contains processor status */
  E_PC_REGNUM = 17,		/* Contains program counter */
  E_FP0_REGNUM = 18,		/* Floating point register 0 */
  E_FPC_REGNUM = 26,		/* 68881 control register */
  E_FPS_REGNUM = 27,		/* 68881 status register */
  E_FPI_REGNUM = 28
};

d144 1
a144 1
  if (regnum == E_FPI_REGNUM || regnum == PC_REGNUM)
d147 2
a148 1
  if (regnum == E_FPC_REGNUM || regnum == E_FPS_REGNUM || regnum == PS_REGNUM)
d151 1
a151 1
  if (regnum >= A0_REGNUM && regnum <= A0_REGNUM + 7)
d193 2
a194 2
  if (regnum >= E_FPC_REGNUM)
    return (((regnum - E_FPC_REGNUM) * 4) + 168);
d207 1
a207 1
  write_register (E_A1_REGNUM, addr);
d259 1
a259 1
  if ((get_frame_type (thisframe) == SIGTRAMP_FRAME))
d261 2
a262 2
  else if (!inside_entry_file ((thisframe)->pc))
    return read_memory_integer ((thisframe)->frame, 4);
d274 1
a274 1
  if ((get_frame_type (fi) == SIGTRAMP_FRAME))
d283 1
a283 1
  if ((get_frame_type (frame) == SIGTRAMP_FRAME))
d332 1
a332 1
  if ((get_frame_type (frame_info) == SIGTRAMP_FRAME))
d851 1
a851 1
  for (regi = FP0_REGNUM; regi < E_FPC_REGNUM; regi++)
d856 3
a858 3
  supply_register (E_FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (E_FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (E_FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
d873 1
a873 1
  for (regi = FP0_REGNUM; regi < E_FPC_REGNUM; regi++)
d882 1
a882 1
  if ((regno == -1) || (regno == E_FPC_REGNUM))
d884 1
a884 1
      fpregsetp->f_pcr = *(int *) &deprecated_registers[REGISTER_BYTE (E_FPC_REGNUM)];
d886 1
a886 1
  if ((regno == -1) || (regno == E_FPS_REGNUM))
d888 1
a888 1
      fpregsetp->f_psr = *(int *) &deprecated_registers[REGISTER_BYTE (E_FPS_REGNUM)];
d890 1
a890 1
  if ((regno == -1) || (regno == E_FPI_REGNUM))
d892 1
a892 1
      fpregsetp->f_fpiaddr = *(int *) &deprecated_registers[REGISTER_BYTE (E_FPI_REGNUM)];
d1028 5
a1032 5
  set_gdbarch_sp_regnum (gdbarch, E_SP_REGNUM);
  set_gdbarch_fp_regnum (gdbarch, E_FP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, E_PC_REGNUM);
  set_gdbarch_ps_regnum (gdbarch, E_PS_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, E_FP0_REGNUM);
@


1.29
log
@	* m68k-tdep.c (m68k_register_virtual_type): Use architecture
	invariant return values.
@
text
@a1035 2
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
@


1.28
log
@	* m68k-tdep.c (m68k_register_virtual_type): Return int for SR, FPC
	and FPS registers.
@
text
@d162 13
a174 12
  if (regnum == E_FPI_REGNUM)
    return lookup_pointer_type (builtin_type_void);
  else if ((unsigned) regnum >= E_FPC_REGNUM)
    return builtin_type_int;
  else if ((unsigned) regnum >= FP0_REGNUM)
    return builtin_type_long_double;
  else if (regnum == PS_REGNUM)
    return builtin_type_int;
  else if ((unsigned) regnum >= A0_REGNUM)
    return lookup_pointer_type (builtin_type_void);
  else
    return builtin_type_int;
@


1.27
log
@2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (enum frame_type): Define.
	(get_frame_type): Declare.
	(struct frame_info): Add field `type'.  Delete field
	signal_handler_caller.
	(deprecated_set_frame_signal_handler_caller): Declare.
	* frame.c (get_frame_type): New function.
	(deprecated_set_frame_type): New function.
	(create_new_frame): Set the frame's type.
	(get_prev_frame): Similar.
	* sparc-tdep.c: Use get_frame_type instead of signal_handler_caller.
	* s390-tdep.c: Ditto.
	* m68klinux-nat.c: Ditto.
	* ns32k-tdep.c: Ditto.
	* x86-64-linux-tdep.c: Ditto.
	* vax-tdep.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* i386-interix-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* m68k-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* cris-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* i386-tdep.c: Ditto.
	* stack.c: Ditto.
	* ada-lang.c: Ditto.
	* blockframe.c: Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Use
	deprecated_set_frame_type instead of signal_handler_caller.
	* ppc-linux-tdep.c (ppc_linux_init_extra_frame_info): Ditto.
	* rs6000-tdep.c (rs6000_init_extra_frame_info): Ditto.
	* breakpoint.h: Delete FIXME suggesting get_frame_type.

Index: tui/ChangeLog
2002-11-18  Andrew Cagney  <ac131313@@redhat.com>

	* tuiStack.c (tuiShowFrameInfo): Use get_frame_type instead of
	signal_handler_caller.
@
text
@d151 7
a157 6
/* Return the GDB type object for the "standard" data type of data 
   in register N.  This should be int for D0-D7, long double for FP0-FP7,
   and void pointer for all others (A0-A7, PC, SR, FPCONTROL etc).
   Note, for registers which contain addresses return pointer to void, 
   not pointer to char, because we don't want to attempt to print 
   the string after printing the address.  */
d162 1
a162 1
  if ((unsigned) regnum >= E_FPC_REGNUM)
d164 2
d168 2
@


1.26
log
@2002-11-14  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_registers): Rename registers.
	* a68v-nat.c, alpha-nat.c, arch-utils.c, core-sol2.c: Update.
	* hp300ux-nat.c, hppab-nat.c, hppah-nat.c: Update.
	* hppam3-nat.c, hpux-thread.c, i386gnu-nat.c: Update.
	* ia64-aix-nat.c, ia64-linux-nat.c, ia64-tdep.c: Update.
	* irix4-nat.c, irix5-nat.c, lynx-nat.c, m68k-tdep.c: Update.
	* m68knbsd-nat.c, mips-linux-tdep.c, mipsm3-nat.c: Update.
	* mipsv4-nat.c, ns32knbsd-nat.c, ppc-bdm.c: Update.
	* ppc-sysv-tdep.c, ptx4-nat.c, regcache.c, remote-es.c: Update.
	* remote-sds.c, remote-vx68.c, remote-vxmips.c: Update.
	* remote-vxsparc.c, rs6000-tdep.c, sol-thread.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, symm-nat.c: Update.
	* v850ice.c: Update.
@
text
@d273 1
a273 1
  if (thisframe->signal_handler_caller)
d288 1
a288 1
  if (fi->signal_handler_caller)
d297 1
a297 1
  if (frame->signal_handler_caller)
d346 1
a346 1
  if (frame_info->signal_handler_caller)
d351 1
a351 1
      if (frame_info->next && frame_info->next->signal_handler_caller)
d762 1
a762 1
  if (frame_info->signal_handler_caller && frame_info->next)
@


1.25
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@d840 1
a840 1
	  *(regp + regi) = *(int *) &registers[REGISTER_BYTE (regi)];
d845 1
a845 1
      *(regp + R_PS) = *(int *) &registers[REGISTER_BYTE (PS_REGNUM)];
d849 1
a849 1
      *(regp + R_PC) = *(int *) &registers[REGISTER_BYTE (PC_REGNUM)];
d891 1
a891 1
	  from = (char *) &registers[REGISTER_BYTE (regi)];
d898 1
a898 1
      fpregsetp->f_pcr = *(int *) &registers[REGISTER_BYTE (E_FPC_REGNUM)];
d902 1
a902 1
      fpregsetp->f_psr = *(int *) &registers[REGISTER_BYTE (E_FPS_REGNUM)];
d906 1
a906 1
      fpregsetp->f_fpiaddr = *(int *) &registers[REGISTER_BYTE (E_FPI_REGNUM)];
@


1.24
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d255 1
a255 1
  write_register_bytes (0, valbuf, TYPE_LENGTH (type));
d466 1
a466 1
      read_register_bytes (REGISTER_BYTE (regnum), raw_buffer, 12);
d496 2
a497 1
	  write_register_bytes (REGISTER_BYTE (regnum), raw_buffer, 12);
@


1.24.10.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,
   2002, 2003
a22 1
#include "dwarf2-frame.h"
a23 2
#include "frame-base.h"
#include "frame-unwind.h"
a27 1
#include "gdb_assert.h"
a30 4
#include "osabi.h"
#include "dis-asm.h"

#include "m68k-tdep.h"
d36 32
a67 11
#define P_MOVEAL_SP_FP	0x2c4f
#define P_ADDAW_SP	0xdefc
#define P_ADDAL_SP	0xdffc
#define P_SUBQW_SP	0x514f
#define P_SUBQL_SP	0x518f
#define P_LEA_SP_SP	0x4fef
#define P_LEA_PC_A5	0x4bfb0170
#define P_FMOVEMX_SP	0xf227
#define P_MOVEL_SP	0x2f00
#define P_MOVEML_SP	0x48e7

d72 2
d75 1
d78 12
d99 3
d105 1
a105 1
static const unsigned char *
d113 1
a113 1
static const unsigned char *
d129 5
a133 7
/* Return the GDB type object for the "standard" data type of data in
   register N.  This should be int for D0-D7, SR, FPCONTROL and
   FPSTATUS, long double for FP0-FP7, and void pointer for all others
   (A0-A7, PC, FPIADDR).  Note, for registers which contain
   addresses return pointer to void, not pointer to char, because we
   don't want to attempt to print the string after printing the
   address.  */
d135 2
a136 2
static struct type *
m68k_register_type (struct gdbarch *gdbarch, int regnum)
d138 2
a139 2
  if (regnum >= FP0_REGNUM && regnum <= FP0_REGNUM + 7)
    return builtin_type_m68881_ext;
d141 3
a143 2
  if (regnum == M68K_FPI_REGNUM || regnum == PC_REGNUM)
    return builtin_type_void_func_ptr;
d145 5
a149 3
  if (regnum == M68K_FPC_REGNUM || regnum == M68K_FPS_REGNUM
      || regnum == PS_REGNUM)
    return builtin_type_int32;
d151 6
a156 2
  if (regnum >= M68K_A0_REGNUM && regnum <= M68K_A0_REGNUM + 7)
    return builtin_type_void_data_ptr;
d158 11
a168 1
  return builtin_type_int32;
d193 8
d207 2
a208 2
  if (regnum >= M68K_FPC_REGNUM)
    return (((regnum - M68K_FPC_REGNUM) * 4) + 168);
d214 3
a216 4

/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that, in virtual format,
   into VALBUF.  */
d219 1
a219 2
m68k_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
d221 1
a221 25
  int len = TYPE_LENGTH (type);
  char buf[M68K_MAX_REGISTER_SIZE];

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_extract_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }

  if (len <= 4)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (4 - len), len);
    }
  else if (len <= 8)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (8 - len), len - 4);
      regcache_raw_read (regcache, M68K_D1_REGNUM,
			 (char *) valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
d224 4
a227 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE, given in virtual format.  */
d230 2
a231 2
m68k_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d233 2
a234 1
  int len = TYPE_LENGTH (type);
d236 2
a237 6
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_store_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }
d239 1
a239 12
  if (len <= 4)
    regcache_raw_write_part (regcache, M68K_D0_REGNUM, 4 - len, len, valbuf);
  else if (len <= 8)
    {
      regcache_raw_write_part (regcache, M68K_D1_REGNUM, 8 - len,
			       len - 4, valbuf);
      regcache_raw_write (regcache, M68K_D0_REGNUM,
			  (char *) valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot store return value of %d bytes long.", len);
a241 4
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */

d243 1
a243 1
m68k_extract_struct_value_address (struct regcache *regcache)
d245 6
a250 1
  char buf[4];
d252 4
a255 2
  regcache_cooked_read (regcache, M68K_D0_REGNUM, buf);
  return extract_unsigned_integer (buf, 4);
d258 14
a271 2
static int
m68k_use_struct_convention (int gcc_p, struct type *type)
d273 6
a278 5
  enum struct_return struct_return;

  struct_return = gdbarch_tdep (current_gdbarch)->struct_return;
  return generic_use_struct_convention (struct_return == reg_struct_return,
					type);
d288 1
a288 1
  if (get_frame_type (fi) == SIGTRAMP_FRAME)
d294 38
d346 2
a347 2
  if (get_frame_type (frame_info) == SIGTRAMP_FRAME)
    return get_frame_base (frame_info) + 12;
d351 2
a352 2
      if (get_next_frame (frame_info) && (get_frame_type (get_next_frame (frame_info)) == SIGTRAMP_FRAME))
	return get_frame_base (get_next_frame (frame_info)) + 16;
d354 1
a354 1
	return get_frame_base (frame_info) + 4;
d357 1
a357 1
    return get_frame_base (frame_info);
d363 1
a363 2
  return read_memory_unsigned_integer (delta68_frame_args_address (frame_info)
				       + 4, 4);
d366 3
d370 1
a370 1
delta68_frame_num_args (struct frame_info *fi)
d373 2
a374 2
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
  int insn = read_memory_unsigned_integer (pc, 2);
d391 15
a405 28
static CORE_ADDR
m68k_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  char buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
    {
      struct type *value_type = VALUE_ENCLOSING_TYPE (args[i]);
      int len = TYPE_LENGTH (value_type);
      int container_len = (len + 3) & ~3;
      int offset;

      /* Non-scalars bigger than 4 bytes are left aligned, others are
	 right aligned.  */
      if ((TYPE_CODE (value_type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (value_type) == TYPE_CODE_UNION
	   || TYPE_CODE (value_type) == TYPE_CODE_ARRAY)
	  && len > 4)
	offset = 0;
      else
	offset = container_len - len;
      sp -= container_len;
      write_memory (sp + offset, VALUE_CONTENTS_ALL (args[i]), len);
d407 5
d413 11
a423 2
  /* Store struct value address.  */
  if (struct_return)
d425 3
a427 2
      store_unsigned_integer (buf, 4, struct_addr);
      regcache_cooked_write (regcache, M68K_A1_REGNUM, buf);
d429 5
d435 3
a437 4
  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, bp_addr);
  write_memory (sp, buf, 4);
d439 7
a445 10
  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 4, sp);
  regcache_cooked_write (regcache, M68K_SP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, M68K_FP_REGNUM, buf);

  /* DWARF2/GCC uses the stack address *before* the function call as a
     frame's CFA.  */
  return sp + 8;
a446 11

struct m68k_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;

  /* Saved registers.  */
  CORE_ADDR saved_regs[M68K_NUM_REGS];
  CORE_ADDR saved_sp;
a447 3
  /* Stack space reserved for local variables.  */
  long locals;
};
d449 1
a449 1
/* Allocate and initialize a frame cache.  */
d451 2
a452 2
static struct m68k_frame_cache *
m68k_alloc_frame_cache (void)
d454 3
a456 2
  struct m68k_frame_cache *cache;
  int i;
d458 3
a460 1
  cache = FRAME_OBSTACK_ZALLOC (struct m68k_frame_cache);
d462 7
a468 4
  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;
d470 6
a475 9
  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %fp is supposed to be stored).  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    cache->saved_regs[i] = -1;

  /* Frameless until proven otherwise.  */
  cache->locals = -1;

  return cache;
d478 2
a479 5
/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */
d481 2
a482 3
static CORE_ADDR
m68k_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct m68k_frame_cache *cache)
d484 8
a491 8
  int op;

  if (pc >= current_pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 2);

  if (op == P_LINKW_FP || op == P_LINKL_FP || op == P_PEA_FP)
d493 1
a493 21
      cache->saved_regs[M68K_FP_REGNUM] = 0;
      cache->sp_offset += 4;
      if (op == P_LINKW_FP)
	{
	  /* link.w %fp, #-N */
	  /* link.w %fp, #0; adda.l #-N, %sp */
	  cache->locals = -read_memory_integer (pc + 2, 2);

	  if (pc + 4 < current_pc && cache->locals == 0)
	    {
	      op = read_memory_unsigned_integer (pc + 4, 2);
	      if (op == P_ADDAL_SP)
		{
		  cache->locals = read_memory_integer (pc + 6, 4);
		  return pc + 10;
		}
	    }

	  return pc + 4;
	}
      else if (op == P_LINKL_FP)
d495 2
a496 21
	  /* link.l %fp, #-N */
	  cache->locals = -read_memory_integer (pc + 2, 4);
	  return pc + 6;
	}
      else
	{
	  /* pea (%fp); movea.l %sp, %fp */
	  cache->locals = 0;

	  if (pc + 2 < current_pc)
	    {
	      op = read_memory_unsigned_integer (pc + 2, 2);

	      if (op == P_MOVEAL_SP_FP)
		{
		  /* move.l %sp, %fp */
		  return pc + 4;
		}
	    }

	  return pc + 2;
d499 1
a499 1
  else if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
d501 1
a501 4
      /* subq.[wl] #N,%sp */
      /* subq.[wl] #8,%sp; subq.[wl] #N,%sp */
      cache->locals = (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
      if (pc + 2 < current_pc)
d503 2
a504 6
	  op = read_memory_unsigned_integer (pc + 2, 2);
	  if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
	    {
	      cache->locals += (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
	      return pc + 4;
	    }
a505 1
      return pc + 2;
d507 1
a507 1
  else if (op == P_ADDAW_SP || op == P_LEA_SP_SP)
d509 2
a510 10
      /* adda.w #-N,%sp */
      /* lea (-N,%sp),%sp */
      cache->locals = -read_memory_integer (pc + 2, 2);
      return pc + 4;
    }
  else if (op == P_ADDAL_SP)
    {
      /* adda.l #-N,%sp */
      cache->locals = -read_memory_integer (pc + 2, 4);
      return pc + 6;
d512 6
d519 5
a523 2
  return pc;
}
d525 2
a526 4
/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */
d528 1
a528 9
static CORE_ADDR
m68k_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
			     struct m68k_frame_cache *cache)
{
  if (cache->locals >= 0)
    {
      CORE_ADDR offset;
      int op;
      int i, mask, regno;
d530 1
a530 50
      offset = -4 - cache->locals;
      while (pc < current_pc)
	{
	  op = read_memory_unsigned_integer (pc, 2);
	  if (op == P_FMOVEMX_SP)
	    {
	      /* fmovem.x REGS,-(%sp) */
	      op = read_memory_unsigned_integer (pc + 2, 2);
	      if ((op & 0xff00) == 0xe000)
		{
		  mask = op & 0xff;
		  for (i = 0; i < 16; i++, mask >>= 1)
		    {
		      if (mask & 1)
			{
			  cache->saved_regs[i + M68K_FP0_REGNUM] = offset;
			  offset -= 12;
			}
		    }
		  pc += 4;
		}
	      else
		break;
	    }
	  else if ((op & 0170677) == P_MOVEL_SP)
	    {
	      /* move.l %R,-(%sp) */
	      regno = ((op & 07000) >> 9) | ((op & 0100) >> 3);
	      cache->saved_regs[regno] = offset;
	      offset -= 4;
	      pc += 2;
	    }
	  else if (op == P_MOVEML_SP)
	    {
	      /* movem.l REGS,-(%sp) */
	      mask = read_memory_unsigned_integer (pc + 2, 2);
	      for (i = 0; i < 16; i++, mask >>= 1)
		{
		  if (mask & 1)
		    {
		      cache->saved_regs[15 - i] = offset;
		      offset -= 4;
		    }
		}
	      pc += 4;
	    }
	  else
	    break;
	}
    }
d532 1
a532 2
  return pc;
}
d534 1
d536 1
a536 3
/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.
d538 1
a538 1
   We handle all cases that can be generated by gcc.
d540 1
a540 1
   For allocating a stack frame:
d542 1
a542 10
   link.w %a6,#-N
   link.l %a6,#-N
   pea (%fp); move.l %sp,%fp
   link.w %a6,#0; add.l #-N,%sp
   subq.l #N,%sp
   subq.w #N,%sp
   subq.w #8,%sp; subq.w #N-8,%sp
   add.w #-N,%sp
   lea (-N,%sp),%sp
   add.l #-N,%sp
d544 1
a544 1
   For saving registers:
d546 2
a547 4
   fmovem.x REGS,-(%sp)
   move.l R1,-(%sp)
   move.l R1,-(%sp); move.l R2,-(%sp)
   movem.l REGS,-(%sp)
d549 1
a549 1
   For setting up the PIC register:
d551 6
a556 1
   lea (%pc,N),%a5
d558 2
a559 1
   */
d561 2
a562 5
static CORE_ADDR
m68k_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		       struct m68k_frame_cache *cache)
{
  unsigned int op;
d564 1
a564 8
  pc = m68k_analyze_frame_setup (pc, current_pc, cache);
  pc = m68k_analyze_register_saves (pc, current_pc, cache);
  if (pc >= current_pc)
    return current_pc;

  /* Check for GOT setup.  */
  op = read_memory_unsigned_integer (pc, 4);
  if (op == P_LEA_PC_A5)
d566 17
a582 2
      /* lea (%pc,N),%a5 */
      return pc + 6;
d584 1
a584 2

  return pc;
d587 5
a591 1
/* Return PC of first real instruction.  */
d593 2
a594 2
static CORE_ADDR
m68k_skip_prologue (CORE_ADDR start_pc)
d596 4
a599 3
  struct m68k_frame_cache cache;
  CORE_ADDR pc;
  int op;
d601 3
a603 6
  cache.locals = -1;
  pc = m68k_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache);
  if (cache.locals < 0)
    return start_pc;
  return pc;
}
d605 1
a605 4
static CORE_ADDR
m68k_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[8];
d607 2
a608 5
  frame_unwind_register (next_frame, PC_REGNUM, buf);
  return extract_typed_address (buf, builtin_type_void_func_ptr);
}

/* Normal frames.  */
d610 1
a610 57
static struct m68k_frame_cache *
m68k_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache;
  char buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, %fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */

  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %pc is stored at 4(%fp).  */
  cache->saved_regs[M68K_PC_REGNUM] = 4;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    m68k_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %sp in the calling frame.  */
  cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;
d612 1
a612 2
  return cache;
}
d614 3
a616 5
static void
m68k_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);
d618 4
a621 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d623 6
a628 3
  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, cache->pc);
}
d630 21
a650 17
static void
m68k_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == M68K_SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
d652 2
a653 2
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
d655 6
a660 1
      return;
d663 1
a663 1
  if (regnum < M68K_NUM_REGS && cache->saved_regs[regnum] != -1)
d665 4
a668 5
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
d670 5
a674 3
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
d676 4
a679 2
      return;
    }
d681 26
a706 3
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}
d708 57
a764 98
static const struct frame_unwind m68k_frame_unwind =
{
  NORMAL_FRAME,
  m68k_frame_this_id,
  m68k_frame_prev_register
};

static const struct frame_unwind *
m68k_frame_sniffer (struct frame_info *next_frame)
{
  return &m68k_frame_unwind;
}

/* Signal trampolines.  */

static struct m68k_frame_cache *
m68k_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct m68k_sigtramp_info info;
  char buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();

  frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4) - 4;

  info = tdep->get_sigtramp_info (next_frame);

  for (i = 0; i < M68K_NUM_REGS; i++)
    if (info.sc_reg_offset[i] != -1)
      cache->saved_regs[i] = info.sigcontext_addr + info.sc_reg_offset[i];

  *this_cache = cache;
  return cache;
}

static void
m68k_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct m68k_frame_cache *cache =
    m68k_sigtramp_frame_cache (next_frame, this_cache);

  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
}

static void
m68k_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  m68k_sigtramp_frame_cache (next_frame, this_cache);

  m68k_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind m68k_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  m68k_sigtramp_frame_this_id,
  m68k_sigtramp_frame_prev_register
};

static const struct frame_unwind *
m68k_sigtramp_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;

  /* We shouldn't even bother to try if the OSABI didn't register
     a get_sigtramp_info handler.  */
  if (!gdbarch_tdep (current_gdbarch)->get_sigtramp_info)
    return NULL;

  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &m68k_sigtramp_frame_unwind;

  return NULL;
}

static CORE_ADDR
m68k_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);

  return cache->base;
a766 16
static const struct frame_base m68k_frame_base =
{
  &m68k_frame_unwind,
  m68k_frame_base_address,
  m68k_frame_base_address,
  m68k_frame_base_address
};

static struct frame_id
m68k_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[4];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);
a767 4
  /* See the end of m68k_push_dummy_call.  */
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
}

d818 2
a819 2
  int regi;
  greg_t *regp = (greg_t *) gregsetp;
d832 2
a833 2
  int regi;
  greg_t *regp = (greg_t *) gregsetp;
d837 12
a848 2
      if (regno == -1 || regno == regi)
	regcache_collect (regi, regp + regi);
a849 4
  if (regno == -1 || regno == PS_REGNUM)
    regcache_collect (PS_REGNUM, regp + R_PS);
  if (regno == -1 || regno == PC_REGNUM)
    regcache_collect (PC_REGNUM, regp + R_PC);
d861 1
a861 1
  int regi;
d864 1
a864 1
  for (regi = FP0_REGNUM; regi < M68K_FPC_REGNUM; regi++)
d869 3
a871 3
  supply_register (M68K_FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (M68K_FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (M68K_FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
d883 2
d886 1
a886 1
  for (regi = FP0_REGNUM; regi < M68K_FPC_REGNUM; regi++)
d888 18
a905 2
      if (regno == -1 || regno == regi)
	regcache_collect (regi, &fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
a906 6
  if (regno == -1 || regno == M68K_FPC_REGNUM)
    regcache_collect (M68K_FPC_REGNUM, &fpregsetp->f_pcr);
  if (regno == -1 || regno == M68K_FPS_REGNUM)
    regcache_collect (M68K_FPS_REGNUM, &fpregsetp->f_psr);
  if (regno == -1 || regno == M68K_FPI_REGNUM)
    regcache_collect (M68K_FPI_REGNUM, &fpregsetp->f_fpiaddr);
d918 5
d926 1
a928 8
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep->jb_pc < 0)
    {
      internal_error (__FILE__, __LINE__,
		      "m68k_get_longjmp_target: not implemented");
      return 0;
    }
d937 1
a937 1
  jb_addr = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
d939 1
a939 1
  if (target_read_memory (jb_addr + tdep->jb_pc * tdep->jb_elt_size, buf,
d943 2
a944 1
  *pc = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
d946 5
a952 1
#ifdef SYSCALL_TRAP
d958 1
a958 1
static CORE_ADDR
d961 1
d964 1
a964 1
  op = read_memory_unsigned_integer (frame->pc - SYSCALL_TRAP_OFFSET, 2);
d967 1
a967 1
    return read_memory_unsigned_integer (read_register (SP_REGNUM) + 4, 4);
d969 2
a970 1
    return read_memory_unsigned_integer (read_register (SP_REGNUM), 4);
a971 1
#endif /* SYSCALL_TRAP */
d980 4
d992 5
a996 2
  tdep = xmalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);
d1004 1
a1004 3
#ifdef SYSCALL_TRAP
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, m68k_saved_pc_after_call);
#endif
d1009 2
a1010 1
  set_gdbarch_parm_boundary (gdbarch, 32);
d1015 9
a1023 6
  set_gdbarch_extract_return_value (gdbarch, m68k_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, m68k_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m68k_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, m68k_use_struct_convention);

d1026 2
d1029 2
d1032 5
a1036 1
  set_gdbarch_register_type (gdbarch, m68k_register_type);
d1038 2
d1042 23
a1064 39
  set_gdbarch_sp_regnum (gdbarch, M68K_SP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, M68K_PC_REGNUM);
  set_gdbarch_ps_regnum (gdbarch, M68K_PS_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, M68K_FP0_REGNUM);

  set_gdbarch_push_dummy_call (gdbarch, m68k_push_dummy_call);

  /* Disassembler.  */
  set_gdbarch_print_insn (gdbarch, print_insn_m68k);

#if defined JB_PC && defined JB_ELEMENT_SIZE
  tdep->jb_pc = JB_PC;
  tdep->jb_elt_size = JB_ELEMENT_SIZE;
#else
  tdep->jb_pc = -1;
#endif
  tdep->get_sigtramp_info = NULL;
  tdep->struct_return = pcc_struct_return;

  /* Frame unwinder.  */
  set_gdbarch_unwind_dummy_id (gdbarch, m68k_unwind_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, m68k_unwind_pc);

  /* Hook in the DWARF CFI frame unwinder.  */
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);

  frame_base_set_default (gdbarch, &m68k_frame_base);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  /* Now we have tuned the configuration, set a few final things,
     based on what the OS ABI has told us.  */

  if (tdep->jb_pc >= 0)
    set_gdbarch_get_longjmp_target (gdbarch, m68k_get_longjmp_target);

  frame_unwind_append_sniffer (gdbarch, m68k_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, m68k_frame_sniffer);
a1072 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a1073 2
  if (tdep == NULL)
    return;
a1075 2
extern initialize_file_ftype _initialize_m68k_tdep; /* -Wmissing-prototypes */

d1080 1
@


1.24.10.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 3
a4 3

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d72 11
d147 14
d1065 20
d1106 2
d1109 3
d1123 2
a1124 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, m68k_extract_struct_value_address);
@


1.24.8.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d255 1
a255 1
  deprecated_write_register_bytes (0, valbuf, TYPE_LENGTH (type));
d466 1
a466 1
      deprecated_read_register_bytes (REGISTER_BYTE (regnum), raw_buffer, 12);
d496 1
a496 2
	  deprecated_write_register_bytes (REGISTER_BYTE (regnum), raw_buffer,
					   12);
d839 1
a839 1
	  *(regp + regi) = *(int *) &deprecated_registers[REGISTER_BYTE (regi)];
d844 1
a844 1
      *(regp + R_PS) = *(int *) &deprecated_registers[REGISTER_BYTE (PS_REGNUM)];
d848 1
a848 1
      *(regp + R_PC) = *(int *) &deprecated_registers[REGISTER_BYTE (PC_REGNUM)];
d890 1
a890 1
	  from = (char *) &deprecated_registers[REGISTER_BYTE (regi)];
d897 1
a897 1
      fpregsetp->f_pcr = *(int *) &deprecated_registers[REGISTER_BYTE (E_FPC_REGNUM)];
d901 1
a901 1
      fpregsetp->f_psr = *(int *) &deprecated_registers[REGISTER_BYTE (E_FPS_REGNUM)];
d905 1
a905 1
      fpregsetp->f_fpiaddr = *(int *) &deprecated_registers[REGISTER_BYTE (E_FPI_REGNUM)];
@


1.24.8.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a30 2

#include "m68k-tdep.h"
d46 23
d151 6
a156 7
/* Return the GDB type object for the "standard" data type of data in
   register N.  This should be int for D0-D7, SR, FPCONTROL and
   FPSTATUS, long double for FP0-FP7, and void pointer for all others
   (A0-A7, PC, FPIADDR).  Note, for registers which contain
   addresses return pointer to void, not pointer to char, because we
   don't want to attempt to print the string after printing the
   address.  */
d161 8
a168 14
  if (regnum >= FP0_REGNUM && regnum <= FP0_REGNUM + 7)
    return builtin_type_m68881_ext;

  if (regnum == M68K_FPI_REGNUM || regnum == PC_REGNUM)
    return builtin_type_void_func_ptr;

  if (regnum == M68K_FPC_REGNUM || regnum == M68K_FPS_REGNUM
      || regnum == PS_REGNUM)
    return builtin_type_int32;

  if (regnum >= M68K_A0_REGNUM && regnum <= M68K_A0_REGNUM + 7)
    return builtin_type_void_data_ptr;

  return builtin_type_int32;
d207 2
a208 2
  if (regnum >= M68K_FPC_REGNUM)
    return (((regnum - M68K_FPC_REGNUM) * 4) + 168);
d221 1
a221 1
  write_register (M68K_A1_REGNUM, addr);
d273 1
a273 1
  if (get_frame_type (thisframe) == SIGTRAMP_FRAME)
d275 2
a276 2
  else if (!inside_entry_file (thisframe->pc))
    return read_memory_unsigned_integer (thisframe->frame, 4);
d288 1
a288 1
  if (get_frame_type (fi) == SIGTRAMP_FRAME)
d297 1
a297 1
  if (get_frame_type (frame) == SIGTRAMP_FRAME)
d300 1
a300 2
	return read_memory_unsigned_integer (frame->next->frame
					     + SIG_PC_FP_OFFSET, 4);
d302 2
a303 2
	return read_memory_unsigned_integer (read_register (SP_REGNUM)
					     + SIG_PC_FP_OFFSET - 8, 4);
d306 1
a306 1
    return read_memory_unsigned_integer (frame->frame + 4, 4);
d316 1
a316 1
  register int op = read_memory_unsigned_integer (pc, 2);
d346 1
a346 1
  if (get_frame_type (frame_info) == SIGTRAMP_FRAME)
d351 1
a351 1
      if (frame_info->next && (get_frame_type (frame_info->next) == SIGTRAMP_FRAME))
d363 1
a363 2
  return read_memory_unsigned_integer (delta68_frame_args_address (frame_info)
				       + 4, 4);
d374 1
a374 1
  int insn = read_memory_unsigned_integer (pc, 2);
d396 1
a396 1
  int insn = read_memory_unsigned_integer (pc, 2);
d418 1
a418 1
  int insn = read_memory_unsigned_integer (pc, 2);
d489 1
a489 1
  fp = get_frame_base (frame);
d567 2
a568 1
      op = read_memory_unsigned_integer (ip, 2);
d604 1
a604 1
    frame_info->frame - 28 - FP_REGNUM * 4 - 4 - 8 * 12;
d615 2
a616 2
  if (frame_info->pc >= possible_call_dummy_start
      && frame_info->pc <= frame_info->frame)
d624 1
a624 1
      next_addr = frame_info->frame;
d629 1
a629 1
      pc = get_pc_function_start (frame_info->pc);
d631 1
a631 1
      nextinsn = read_memory_unsigned_integer (pc, 2);
d633 1
a633 1
	  && P_MOVL_SP_FP == read_memory_unsigned_integer (pc + 2, 2))
d645 1
a645 1
	  next_addr = frame_info->frame + read_memory_integer (pc + 2, 4);
d653 1
a653 1
	  next_addr = frame_info->frame + read_memory_integer (pc + 2, 2);
d660 1
a660 1
      if (read_memory_unsigned_integer (pc, 2) == 0157774)
d666 2
a667 2
      nextinsn = read_memory_unsigned_integer (pc, 2);
      regmask = read_memory_unsigned_integer (pc + 2, 2);
d682 1
a682 1
	  addr = frame_info->frame + read_memory_integer (pc + 4, 2);
d709 1
a709 1
	  addr = frame_info->frame + read_memory_integer (pc + 4, 2);
d762 1
a762 1
  if ((get_frame_type (frame_info) == SIGTRAMP_FRAME) && frame_info->next)
d865 1
a865 1
  for (regi = FP0_REGNUM; regi < M68K_FPC_REGNUM; regi++)
d870 3
a872 3
  supply_register (M68K_FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (M68K_FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (M68K_FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
d887 1
a887 1
  for (regi = FP0_REGNUM; regi < M68K_FPC_REGNUM; regi++)
d896 1
a896 1
  if ((regno == -1) || (regno == M68K_FPC_REGNUM))
d898 1
a898 1
      fpregsetp->f_pcr = *(int *) &deprecated_registers[REGISTER_BYTE (M68K_FPC_REGNUM)];
d900 1
a900 1
  if ((regno == -1) || (regno == M68K_FPS_REGNUM))
d902 1
a902 1
      fpregsetp->f_psr = *(int *) &deprecated_registers[REGISTER_BYTE (M68K_FPS_REGNUM)];
d904 1
a904 1
  if ((regno == -1) || (regno == M68K_FPI_REGNUM))
d906 1
a906 1
      fpregsetp->f_fpiaddr = *(int *) &deprecated_registers[REGISTER_BYTE (M68K_FPI_REGNUM)];
d965 1
a965 1
  op = read_memory_unsigned_integer (frame->pc - SYSCALL_TRAP_OFFSET, 2);
d968 1
a968 1
    return read_memory_unsigned_integer (read_register (SP_REGNUM) + 4, 4);
d971 1
a971 1
    return read_memory_unsigned_integer (read_register (SP_REGNUM), 4);
a998 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d1030 2
d1044 5
a1048 5
  set_gdbarch_sp_regnum (gdbarch, M68K_SP_REGNUM);
  set_gdbarch_fp_regnum (gdbarch, M68K_FP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, M68K_PC_REGNUM);
  set_gdbarch_ps_regnum (gdbarch, M68K_PS_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, M68K_FP0_REGNUM);
d1050 1
a1050 1
  set_gdbarch_deprecated_use_generic_dummy_frames (gdbarch, 0);
d1054 1
a1054 1
  set_gdbarch_deprecated_pc_in_call_dummy (gdbarch, deprecated_pc_in_call_dummy_on_stack);
@


1.24.8.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001,
   2002, 2003
d260 3
a262 3
    return get_frame_base (thisframe);
  else if (!inside_entry_file (get_frame_pc (thisframe)))
    return read_memory_unsigned_integer (get_frame_base (thisframe), 4);
d285 2
a286 2
      if (get_next_frame (frame))
	return read_memory_unsigned_integer (get_frame_base (get_next_frame (frame))
d293 1
a293 1
    return read_memory_unsigned_integer (get_frame_base (frame) + 4, 4);
d334 1
a334 1
    return get_frame_base (frame_info) + 12;
d338 2
a339 2
      if (get_next_frame (frame_info) && (get_frame_type (get_next_frame (frame_info)) == SIGTRAMP_FRAME))
	return get_frame_base (get_next_frame (frame_info)) + 16;
d341 1
a341 1
	return get_frame_base (frame_info) + 4;
d344 1
a344 1
    return get_frame_base (frame_info);
d481 1
a481 1
      if (get_frame_saved_regs (frame)[regnum])
d483 1
a483 1
	  read_memory (get_frame_saved_regs (frame)[regnum], raw_buffer, 12);
d490 1
a490 1
      if (get_frame_saved_regs (frame)[regnum])
d493 1
a493 1
			  read_memory_integer (get_frame_saved_regs (frame)[regnum], 4));
d496 1
a496 1
  if (get_frame_saved_regs (frame)[PS_REGNUM])
d499 1
a499 1
		      read_memory_integer (get_frame_saved_regs (frame)[PS_REGNUM], 4));
d591 1
a591 1
    get_frame_base (frame_info) - 28 - FP_REGNUM * 4 - 4 - 8 * 12;
d595 1
a595 1
  if (get_frame_saved_regs (frame_info))
d600 1
a600 1
  memset (get_frame_saved_regs (frame_info), 0, SIZEOF_FRAME_SAVED_REGS);
d602 2
a603 2
  if (get_frame_pc (frame_info) >= possible_call_dummy_start
      && get_frame_pc (frame_info) <= get_frame_base (frame_info))
d611 1
a611 1
      next_addr = get_frame_base (frame_info);
d616 1
a616 1
      pc = get_pc_function_start (get_frame_pc (frame_info));
d624 1
a624 1
	  next_addr = get_frame_base (frame_info);
d632 1
a632 1
	  next_addr = get_frame_base (frame_info) + read_memory_integer (pc + 2, 4);
d640 1
a640 1
	  next_addr = get_frame_base (frame_info) + read_memory_integer (pc + 2, 2);
d661 1
a661 1
	      get_frame_saved_regs (frame_info)[regnum] = (next_addr -= 12);
d669 1
a669 1
	  addr = get_frame_base (frame_info) + read_memory_integer (pc + 4, 2);
d674 1
a674 1
		get_frame_saved_regs (frame_info)[regnum] = addr;
d686 1
a686 1
		get_frame_saved_regs (frame_info)[regnum] = next_addr;
d696 1
a696 1
	  addr = get_frame_base (frame_info) + read_memory_integer (pc + 4, 2);
d701 1
a701 1
		get_frame_saved_regs (frame_info)[regnum] = addr;
d712 1
a712 1
	      get_frame_saved_regs (frame_info)[regnum] = (next_addr -= 4);
d719 1
a719 1
	  get_frame_saved_regs (frame_info)[regnum] = (next_addr -= 4);
d729 1
a729 1
		get_frame_saved_regs (frame_info)[regnum] = next_addr;
d737 1
a737 1
	  get_frame_saved_regs (frame_info)[PS_REGNUM] = (next_addr -= 4);
d744 3
a746 3
  get_frame_saved_regs (frame_info)[SP_REGNUM] = get_frame_base (frame_info) + 8;
  get_frame_saved_regs (frame_info)[FP_REGNUM] = get_frame_base (frame_info);
  get_frame_saved_regs (frame_info)[PC_REGNUM] = get_frame_base (frame_info) + 4;
d1013 1
@


1.24.8.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1015 1
a1015 1
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, m68k_frame_init_saved_regs);
d1024 2
a1025 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 12);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 12);
d1053 1
a1053 1
  set_gdbarch_deprecated_push_dummy_frame (gdbarch, m68k_push_dummy_frame);
@


1.24.8.5
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d248 4
a251 4
/* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and produces
   the frame's chain-pointer.  In the case of the 68000, the frame's
   nominal address is the address of a 4-byte word containing the
   calling frame's address.  */
d362 1
a362 1
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
d384 1
a384 1
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
d406 1
a406 1
  CORE_ADDR pc = DEPRECATED_FRAME_SAVED_PC (fi);
d617 1
a617 1
      pc = get_frame_func (frame_info);
d997 1
a997 1
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, m68k_saved_pc_after_call);
d1003 1
a1003 1
  set_gdbarch_deprecated_extra_stack_alignment_needed (gdbarch, 1);
d1008 1
a1008 1
  set_gdbarch_deprecated_store_struct_return (gdbarch, m68k_store_struct_return);
d1013 2
a1014 2
  set_gdbarch_deprecated_frame_chain (gdbarch, m68k_frame_chain);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, m68k_frame_saved_pc);
d1041 1
d1044 2
d1051 1
d1054 1
a1054 4
  set_gdbarch_deprecated_pop_frame (gdbarch, m68k_pop_frame);

  /* Should be using push_dummy_call.  */
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.24.8.6
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d448 2
a449 2
  sp = push_word (sp, read_register (DEPRECATED_FP_REGNUM));
  write_register (DEPRECATED_FP_REGNUM, sp);
d459 1
a459 1
  for (regnum = DEPRECATED_FP_REGNUM - 1; regnum >= 0; regnum--)
d489 1
a489 1
  for (regnum = DEPRECATED_FP_REGNUM - 1; regnum >= 0; regnum--)
d502 1
a502 1
  write_register (DEPRECATED_FP_REGNUM, read_memory_integer (fp, 4));
d592 1
a592 1
    get_frame_base (frame_info) - 28 - DEPRECATED_FP_REGNUM * 4 - 4 - 8 * 12;
d746 1
a746 1
  get_frame_saved_regs (frame_info)[DEPRECATED_FP_REGNUM] = get_frame_base (frame_info);
d1034 1
a1034 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, M68K_FP_REGNUM);
d1069 1
a1069 1
  deprecated_tm_print_insn = print_insn_m68k;
@


1.24.8.7
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a31 1
#include "osabi.h"
d432 1
a432 1
  bfd_putb32 (fun, (unsigned char *) dummy + DEPRECATED_CALL_DUMMY_START_OFFSET + 2);
d434 1
a434 1
	      (unsigned char *) dummy + DEPRECATED_CALL_DUMMY_START_OFFSET + 8);
d1028 1
a1028 1
  set_gdbarch_deprecated_register_size (gdbarch, 4);
d1032 1
a1032 1
  set_gdbarch_deprecated_register_bytes (gdbarch, (16 * 4 + 8 + 8 * 12 + 3 * 4));
d1041 1
a1041 1
  set_gdbarch_deprecated_call_dummy_breakpoint_offset (gdbarch, 24);
d1043 2
a1044 2
  set_gdbarch_deprecated_call_dummy_length (gdbarch, 28);
  set_gdbarch_deprecated_call_dummy_start_offset (gdbarch, 12);
d1046 3
a1048 3
  set_gdbarch_deprecated_call_dummy_words (gdbarch, call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_words));
  set_gdbarch_deprecated_fix_call_dummy (gdbarch, m68k_fix_call_dummy);
a1053 3

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);
@


1.24.8.8
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d80 1
a80 1
static void m68k_frame_init_saved_regs (struct frame_info *frame_info);
d86 1
a86 1
static const unsigned char *
d94 1
a94 1
static const unsigned char *
d113 2
d119 1
a119 1
  return (regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 8 ? 12 : 4);
d129 1
a129 1
  return (regnum >= FP0_REGNUM && regnum < FP0_REGNUM + 8 ? 12 : 4);
d181 8
d299 22
d356 25
d403 22
d429 1
a429 1
static void
d441 1
a441 1
static void
d471 1
a471 1
static void
d542 1
a542 1
static CORE_ADDR
d583 1
a583 1
static void
d908 5
d916 1
a918 8
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep->jb_pc < 0)
    {
      internal_error (__FILE__, __LINE__,
		      "m68k_get_longjmp_target: not implemented");
      return 0;
    }
d927 1
a927 1
  jb_addr = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
d929 1
a929 1
  if (target_read_memory (jb_addr + tdep->jb_pc * tdep->jb_elt_size, buf,
d933 2
a934 1
  *pc = extract_unsigned_integer (buf, TARGET_PTR_BIT / TARGET_CHAR_BIT);
d936 5
d948 1
a948 1
static CORE_ADDR
d982 5
a986 2
  tdep = xmalloc (sizeof (struct gdbarch_tdep));
  gdbarch = gdbarch_alloc (&info, tdep);
d1003 2
a1004 1
  set_gdbarch_parm_boundary (gdbarch, 32);
d1019 2
d1023 2
a1024 2
  set_gdbarch_deprecated_register_raw_size (gdbarch, m68k_register_raw_size);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, m68k_register_virtual_size);
d1027 1
a1027 1
  set_gdbarch_deprecated_register_virtual_type (gdbarch, m68k_register_virtual_type);
d1030 1
a1030 1
  set_gdbarch_deprecated_register_byte (gdbarch, m68k_register_byte);
d1054 1
a1054 11
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);

  /* Disassembler.  */
  set_gdbarch_print_insn (gdbarch, print_insn_m68k);

#if defined JB_PC && defined JB_ELEMENT_SIZE
  tdep->jb_pc = JB_PC;
  tdep->jb_elt_size = JB_ELEMENT_SIZE;
#else
  tdep->jb_pc = -1;
#endif
a1058 6
  /* Now we have tuned the configuration, set a few final things,
     based on what the OS ABI has told us.  */

  if (tdep->jb_pc >= 0)
    set_gdbarch_get_longjmp_target (gdbarch, m68k_get_longjmp_target);

a1065 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a1066 2
  if (tdep == NULL)
    return;
a1068 2
extern initialize_file_ftype _initialize_m68k_tdep; /* -Wmissing-prototypes */

d1073 1
@


1.24.8.9
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a24 2
#include "frame-base.h"
#include "frame-unwind.h"
a28 1
#include "gdb_assert.h"
d40 8
a47 10
#define P_MOVEAL_SP_FP	0x2c4f
#define P_ADDAW_SP	0xdefc
#define P_ADDAL_SP	0xdffc
#define P_SUBQW_SP	0x514f
#define P_SUBQL_SP	0x518f
#define P_LEA_SP_SP	0x4fef
#define P_LEA_PC_A5	0x4bfb0170
#define P_FMOVEMX_SP	0xf227
#define P_MOVEL_SP	0x2f00
#define P_MOVEML_SP	0x48e7
d53 2
d56 1
d59 12
d80 3
d110 20
d139 1
a139 1
m68k_register_type (struct gdbarch *gdbarch, int regnum)
d192 3
a194 4

/* Extract from an array REGBUF containing the (raw) register state, a
   function return value of TYPE, and copy that, in virtual format,
   into VALBUF.  */
d197 1
a197 2
m68k_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
d199 1
a199 25
  int len = TYPE_LENGTH (type);
  char buf[M68K_MAX_REGISTER_SIZE];

  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_extract_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }

  if (len <= 4)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (4 - len), len);
    }
  else if (len <= 8)
    {
      regcache_raw_read (regcache, M68K_D0_REGNUM, buf);
      memcpy (valbuf, buf + (8 - len), len - 4);
      regcache_raw_read (regcache, M68K_D1_REGNUM,
			 (char *) valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot extract return value of %d bytes long.", len);
d202 4
a205 2
/* Write into the appropriate registers a function return value stored
   in VALBUF of type TYPE, given in virtual format.  */
d208 2
a209 2
m68k_store_return_value (struct type *type, struct regcache *regcache,
			 const void *valbuf)
d211 2
a212 1
  int len = TYPE_LENGTH (type);
d214 2
a215 6
  if (TYPE_CODE (type) == TYPE_CODE_STRUCT
      && TYPE_NFIELDS (type) == 1)
    {
      m68k_store_return_value (TYPE_FIELD_TYPE (type, 0), regcache, valbuf);
      return;
    }
d217 1
a217 12
  if (len <= 4)
    regcache_raw_write_part (regcache, M68K_D0_REGNUM, 4 - len, len, valbuf);
  else if (len <= 8)
    {
      regcache_raw_write_part (regcache, M68K_D1_REGNUM, 8 - len,
			       len - 4, valbuf);
      regcache_raw_write (regcache, M68K_D0_REGNUM,
			  (char *) valbuf + (len - 4));
    }
  else
    internal_error (__FILE__, __LINE__,
		    "Cannot store return value of %d bytes long.", len);
a219 4
/* Extract from REGCACHE, which contains the (raw) register state, the
   address in which a function should return its structure value, as a
   CORE_ADDR.  */

d221 1
a221 1
m68k_extract_struct_value_address (struct regcache *regcache)
d223 6
a228 1
  char buf[4];
d230 4
a233 2
  regcache_cooked_read (regcache, M68K_D0_REGNUM, buf);
  return extract_unsigned_integer (buf, 4);
d236 14
a249 2
static int
m68k_use_struct_convention (int gcc_p, struct type *type)
d251 6
a256 5
  enum struct_return struct_return;

  struct_return = gdbarch_tdep (current_gdbarch)->struct_return;
  return generic_use_struct_convention (struct_return == reg_struct_return,
					type);
d272 17
d346 3
a348 29
static CORE_ADDR
m68k_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		      struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		      struct value **args, CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  char buf[4];
  int i;

  /* Push arguments in reverse order.  */
  for (i = nargs - 1; i >= 0; i--)
    {
      struct type *value_type = VALUE_ENCLOSING_TYPE (args[i]);
      int len = TYPE_LENGTH (value_type);
      int container_len = (len + 3) & ~3;
      int offset;

      /* Non-scalars bigger than 4 bytes are left aligned, others are
	 right aligned.  */
      if ((TYPE_CODE (value_type) == TYPE_CODE_STRUCT
	   || TYPE_CODE (value_type) == TYPE_CODE_UNION
	   || TYPE_CODE (value_type) == TYPE_CODE_ARRAY)
	  && len > 4)
	offset = 0;
      else
	offset = container_len - len;
      sp -= container_len;
      write_memory (sp + offset, VALUE_CONTENTS_ALL (args[i]), len);
    }
d350 7
a356 22
  /* Store struct value address.  */
  if (struct_return)
    {
      store_unsigned_integer (buf, 4, struct_addr);
      regcache_cooked_write (regcache, M68K_A1_REGNUM, buf);
    }

  /* Store return address.  */
  sp -= 4;
  store_unsigned_integer (buf, 4, bp_addr);
  write_memory (sp, buf, 4);

  /* Finally, update the stack pointer...  */
  store_unsigned_integer (buf, 4, sp);
  regcache_cooked_write (regcache, M68K_SP_REGNUM, buf);

  /* ...and fake a frame pointer.  */
  regcache_cooked_write (regcache, M68K_FP_REGNUM, buf);

  /* DWARF2/GCC uses the stack address *before* the function call as a
     frame's CFA.  */
  return sp + 8;
a357 7

struct m68k_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  CORE_ADDR sp_offset;
  CORE_ADDR pc;
a358 3
  /* Saved registers.  */
  CORE_ADDR saved_regs[M68K_NUM_REGS];
  CORE_ADDR saved_sp;
d360 1
a360 3
  /* Stack space reserved for local variables.  */
  long locals;
};
d362 2
a363 4
/* Allocate and initialize a frame cache.  */

static struct m68k_frame_cache *
m68k_alloc_frame_cache (void)
d365 3
a367 2
  struct m68k_frame_cache *cache;
  int i;
d369 3
a371 1
  cache = FRAME_OBSTACK_ZALLOC (struct m68k_frame_cache);
d373 7
a379 4
  /* Base address.  */
  cache->base = 0;
  cache->sp_offset = -4;
  cache->pc = 0;
d381 6
a386 9
  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where %fp is supposed to be stored).  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    cache->saved_regs[i] = -1;

  /* Frameless until proven otherwise.  */
  cache->locals = -1;

  return cache;
d389 2
a390 5
/* Check whether PC points at a code that sets up a new stack frame.
   If so, it updates CACHE and returns the address of the first
   instruction after the sequence that sets removes the "hidden"
   argument from the stack or CURRENT_PC, whichever is smaller.
   Otherwise, return PC.  */
d392 2
a393 3
static CORE_ADDR
m68k_analyze_frame_setup (CORE_ADDR pc, CORE_ADDR current_pc,
			  struct m68k_frame_cache *cache)
d395 8
a402 8
  int op;

  if (pc >= current_pc)
    return current_pc;

  op = read_memory_unsigned_integer (pc, 2);

  if (op == P_LINKW_FP || op == P_LINKL_FP || op == P_PEA_FP)
d404 1
a404 3
      cache->saved_regs[M68K_FP_REGNUM] = 0;
      cache->sp_offset += 4;
      if (op == P_LINKW_FP)
d406 3
a408 39
	  /* link.w %fp, #-N */
	  /* link.w %fp, #0; adda.l #-N, %sp */
	  cache->locals = -read_memory_integer (pc + 2, 2);

	  if (pc + 4 < current_pc && cache->locals == 0)
	    {
	      op = read_memory_unsigned_integer (pc + 4, 2);
	      if (op == P_ADDAL_SP)
		{
		  cache->locals = read_memory_integer (pc + 6, 4);
		  return pc + 10;
		}
	    }

	  return pc + 4;
	}
      else if (op == P_LINKL_FP)
	{
	  /* link.l %fp, #-N */
	  cache->locals = -read_memory_integer (pc + 2, 4);
	  return pc + 6;
	}
      else
	{
	  /* pea (%fp); movea.l %sp, %fp */
	  cache->locals = 0;

	  if (pc + 2 < current_pc)
	    {
	      op = read_memory_unsigned_integer (pc + 2, 2);

	      if (op == P_MOVEAL_SP_FP)
		{
		  /* move.l %sp, %fp */
		  return pc + 4;
		}
	    }

	  return pc + 2;
d411 1
a411 1
  else if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
d413 1
a413 4
      /* subq.[wl] #N,%sp */
      /* subq.[wl] #8,%sp; subq.[wl] #N,%sp */
      cache->locals = (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
      if (pc + 2 < current_pc)
d415 2
a416 6
	  op = read_memory_unsigned_integer (pc + 2, 2);
	  if ((op & 0170777) == P_SUBQW_SP || (op & 0170777) == P_SUBQL_SP)
	    {
	      cache->locals += (op & 07000) == 0 ? 8 : (op & 07000) >> 9;
	      return pc + 4;
	    }
a417 8
      return pc + 2;
    }
  else if (op == P_ADDAW_SP || op == P_LEA_SP_SP)
    {
      /* adda.w #-N,%sp */
      /* lea (-N,%sp),%sp */
      cache->locals = -read_memory_integer (pc + 2, 2);
      return pc + 4;
d419 1
a419 1
  else if (op == P_ADDAL_SP)
d421 2
a422 3
      /* adda.l #-N,%sp */
      cache->locals = -read_memory_integer (pc + 2, 4);
      return pc + 6;
d424 4
a427 2

  return pc;
d429 1
d431 5
a435 14
/* Check whether PC points at code that saves registers on the stack.
   If so, it updates CACHE and returns the address of the first
   instruction after the register saves or CURRENT_PC, whichever is
   smaller.  Otherwise, return PC.  */

static CORE_ADDR
m68k_analyze_register_saves (CORE_ADDR pc, CORE_ADDR current_pc,
			     struct m68k_frame_cache *cache)
{
  if (cache->locals >= 0)
    {
      CORE_ADDR offset;
      int op;
      int i, mask, regno;
d437 2
a438 50
      offset = -4 - cache->locals;
      while (pc < current_pc)
	{
	  op = read_memory_unsigned_integer (pc, 2);
	  if (op == P_FMOVEMX_SP)
	    {
	      /* fmovem.x REGS,-(%sp) */
	      op = read_memory_unsigned_integer (pc + 2, 2);
	      if ((op & 0xff00) == 0xe000)
		{
		  mask = op & 0xff;
		  for (i = 0; i < 16; i++, mask >>= 1)
		    {
		      if (mask & 1)
			{
			  cache->saved_regs[i + M68K_FP0_REGNUM] = offset;
			  offset -= 12;
			}
		    }
		  pc += 4;
		}
	      else
		break;
	    }
	  else if ((op & 0170677) == P_MOVEL_SP)
	    {
	      /* move.l %R,-(%sp) */
	      regno = ((op & 07000) >> 9) | ((op & 0100) >> 3);
	      cache->saved_regs[regno] = offset;
	      offset -= 4;
	      pc += 2;
	    }
	  else if (op == P_MOVEML_SP)
	    {
	      /* movem.l REGS,-(%sp) */
	      mask = read_memory_unsigned_integer (pc + 2, 2);
	      for (i = 0; i < 16; i++, mask >>= 1)
		{
		  if (mask & 1)
		    {
		      cache->saved_regs[15 - i] = offset;
		      offset -= 4;
		    }
		}
	      pc += 4;
	    }
	  else
	    break;
	}
    }
d440 1
a440 2
  return pc;
}
d442 1
d444 1
a444 3
/* Do a full analysis of the prologue at PC and update CACHE
   accordingly.  Bail out early if CURRENT_PC is reached.  Return the
   address where the analysis stopped.
d446 1
a446 1
   We handle all cases that can be generated by gcc.
d448 1
a448 1
   For allocating a stack frame:
d450 1
a450 10
   link.w %a6,#-N
   link.l %a6,#-N
   pea (%fp); move.l %sp,%fp
   link.w %a6,#0; add.l #-N,%sp
   subq.l #N,%sp
   subq.w #N,%sp
   subq.w #8,%sp; subq.w #N-8,%sp
   add.w #-N,%sp
   lea (-N,%sp),%sp
   add.l #-N,%sp
d452 1
a452 1
   For saving registers:
d454 1
a454 4
   fmovem.x REGS,-(%sp)
   move.l R1,-(%sp)
   move.l R1,-(%sp); move.l R2,-(%sp)
   movem.l REGS,-(%sp)
d456 1
a456 1
   For setting up the PIC register:
d458 2
a459 1
   lea (%pc,N),%a5
d461 1
a461 1
   */
d464 1
a464 2
m68k_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		       struct m68k_frame_cache *cache)
d466 3
a468 1
  unsigned int op;
d470 2
a471 4
  pc = m68k_analyze_frame_setup (pc, current_pc, cache);
  pc = m68k_analyze_register_saves (pc, current_pc, cache);
  if (pc >= current_pc)
    return current_pc;
d473 4
a476 3
  /* Check for GOT setup.  */
  op = read_memory_unsigned_integer (pc, 4);
  if (op == P_LEA_PC_A5)
d478 16
a493 2
      /* lea (%pc,N),%a5 */
      return pc + 6;
d495 1
a495 2

  return pc;
d498 5
a502 1
/* Return PC of first real instruction.  */
d504 2
a505 2
static CORE_ADDR
m68k_skip_prologue (CORE_ADDR start_pc)
d507 4
a510 3
  struct m68k_frame_cache cache;
  CORE_ADDR pc;
  int op;
d512 3
a514 6
  cache.locals = -1;
  pc = m68k_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache);
  if (cache.locals < 0)
    return start_pc;
  return pc;
}
d516 1
a516 4
static CORE_ADDR
m68k_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[8];
d518 2
a519 5
  frame_unwind_register (next_frame, PC_REGNUM, buf);
  return extract_typed_address (buf, builtin_type_void_func_ptr);
}

/* Normal frames.  */
d521 1
a521 57
static struct m68k_frame_cache *
m68k_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache;
  char buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, %fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  Signal
     trampolines are just a special case of a "frameless" function.
     They (usually) share their frame pointer with the frame that was
     in progress when the signal occurred.  */

  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4);
  if (cache->base == 0)
    return cache;

  /* For normal frames, %pc is stored at 4(%fp).  */
  cache->saved_regs[M68K_PC_REGNUM] = 4;

  cache->pc = frame_func_unwind (next_frame);
  if (cache->pc != 0)
    m68k_analyze_prologue (cache->pc, frame_pc_unwind (next_frame), cache);

  if (cache->locals < 0)
    {
      /* We didn't find a valid frame, which means that CACHE->base
	 currently holds the frame pointer for our calling frame.  If
	 we're at the start of a function, or somewhere half-way its
	 prologue, the function's frame probably hasn't been fully
	 setup yet.  Try to reconstruct the base address for the stack
	 frame by looking at the stack pointer.  For truly "frameless"
	 functions this might work too.  */

      frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
      cache->base = extract_unsigned_integer (buf, 4) + cache->sp_offset;
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of %sp in the calling frame.  */
  cache->saved_sp = cache->base + 8;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < M68K_NUM_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] += cache->base;
d523 1
a523 2
  return cache;
}
d525 3
a527 5
static void
m68k_frame_this_id (struct frame_info *next_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);
d529 4
a532 3
  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;
d534 6
a539 3
  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, cache->pc);
}
d541 21
a561 17
static void
m68k_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, void *valuep)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == M68K_SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
d563 2
a564 2
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
d566 6
a571 1
      return;
d574 1
a574 1
  if (regnum < M68K_NUM_REGS && cache->saved_regs[regnum] != -1)
d576 4
a579 5
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
d581 5
a585 3
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
d587 4
a590 2
      return;
    }
d592 26
a617 3
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}
d619 57
a675 51
static const struct frame_unwind m68k_frame_unwind =
{
  NORMAL_FRAME,
  m68k_frame_this_id,
  m68k_frame_prev_register
};

static const struct frame_unwind *
m68k_frame_sniffer (struct frame_info *next_frame)
{
  return &m68k_frame_unwind;
}

/* Signal trampolines.  */

static struct m68k_frame_cache *
m68k_sigtramp_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  struct m68k_sigtramp_info info;
  char buf[4];
  int i;

  if (*this_cache)
    return *this_cache;

  cache = m68k_alloc_frame_cache ();

  frame_unwind_register (next_frame, M68K_SP_REGNUM, buf);
  cache->base = extract_unsigned_integer (buf, 4) - 4;

  info = tdep->get_sigtramp_info (next_frame);

  for (i = 0; i < M68K_NUM_REGS; i++)
    if (info.sc_reg_offset[i] != -1)
      cache->saved_regs[i] = info.sigcontext_addr + info.sc_reg_offset[i];

  *this_cache = cache;
  return cache;
}

static void
m68k_sigtramp_frame_this_id (struct frame_info *next_frame, void **this_cache,
			     struct frame_id *this_id)
{
  struct m68k_frame_cache *cache =
    m68k_sigtramp_frame_cache (next_frame, this_cache);

  /* See the end of m68k_push_dummy_call.  */
  *this_id = frame_id_build (cache->base + 8, frame_pc_unwind (next_frame));
a677 31
static void
m68k_sigtramp_frame_prev_register (struct frame_info *next_frame,
				   void **this_cache,
				   int regnum, int *optimizedp,
				   enum lval_type *lvalp, CORE_ADDR *addrp,
				   int *realnump, void *valuep)
{
  /* Make sure we've initialized the cache.  */
  m68k_sigtramp_frame_cache (next_frame, this_cache);

  m68k_frame_prev_register (next_frame, this_cache, regnum,
			    optimizedp, lvalp, addrp, realnump, valuep);
}

static const struct frame_unwind m68k_sigtramp_frame_unwind =
{
  SIGTRAMP_FRAME,
  m68k_sigtramp_frame_this_id,
  m68k_sigtramp_frame_prev_register
};

static const struct frame_unwind *
m68k_sigtramp_frame_sniffer (struct frame_info *next_frame)
{
  CORE_ADDR pc = frame_pc_unwind (next_frame);
  char *name;

  /* We shouldn't even bother to try if the OSABI didn't register
     a get_sigtramp_info handler.  */
  if (!gdbarch_tdep (current_gdbarch)->get_sigtramp_info)
    return NULL;
a678 36
  find_pc_partial_function (pc, &name, NULL, NULL);
  if (PC_IN_SIGTRAMP (pc, name))
    return &m68k_sigtramp_frame_unwind;

  return NULL;
}

static CORE_ADDR
m68k_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct m68k_frame_cache *cache = m68k_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base m68k_frame_base =
{
  &m68k_frame_unwind,
  m68k_frame_base_address,
  m68k_frame_base_address,
  m68k_frame_base_address
};

static struct frame_id
m68k_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  char buf[4];
  CORE_ADDR fp;

  frame_unwind_register (next_frame, M68K_FP_REGNUM, buf);
  fp = extract_unsigned_integer (buf, 4);

  /* See the end of m68k_push_dummy_call.  */
  return frame_id_build (fp + 8, frame_pc_unwind (next_frame));
}

d748 12
a759 2
      if (regno == -1 || regno == regi)
	regcache_collect (regi, regp + regi);
a760 4
  if (regno == -1 || regno == PS_REGNUM)
    regcache_collect (PS_REGNUM, regp + R_PS);
  if (regno == -1 || regno == PC_REGNUM)
    regcache_collect (PC_REGNUM, regp + R_PC);
d794 2
d799 18
a816 2
      if (regno == -1 || regno == regi)
	regcache_collect (regi, &fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
a817 6
  if (regno == -1 || regno == M68K_FPC_REGNUM)
    regcache_collect (M68K_FPC_REGNUM, &fpregsetp->f_pcr);
  if (regno == -1 || regno == M68K_FPS_REGNUM)
    regcache_collect (M68K_FPS_REGNUM, &fpregsetp->f_psr);
  if (regno == -1 || regno == M68K_FPI_REGNUM)
    regcache_collect (M68K_FPI_REGNUM, &fpregsetp->f_fpiaddr);
a859 1
#ifdef SYSCALL_TRAP
d868 1
d876 1
a878 1
#endif /* SYSCALL_TRAP */
d887 4
d902 4
a911 1
#ifdef SYSCALL_TRAP
a912 1
#endif
d922 8
a929 6
  set_gdbarch_extract_return_value (gdbarch, m68k_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, m68k_store_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    m68k_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, m68k_use_struct_convention);

d934 5
a938 1
  set_gdbarch_register_type (gdbarch, m68k_register_type);
d940 2
d944 1
d946 1
d951 15
a965 1
  set_gdbarch_push_dummy_call (gdbarch, m68k_push_dummy_call);
a975 7
  tdep->get_sigtramp_info = NULL;
  tdep->struct_return = pcc_struct_return;

  /* Frame unwinder.  */
  set_gdbarch_unwind_dummy_id (gdbarch, m68k_unwind_dummy_id);
  set_gdbarch_unwind_pc (gdbarch, m68k_unwind_pc);
  frame_base_set_default (gdbarch, &m68k_frame_base);
a984 3

  frame_unwind_append_sniffer (gdbarch, m68k_sigtramp_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, m68k_frame_sniffer);
@


1.24.8.10
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a35 1
#include "dis-asm.h"
d950 2
a951 2
  int regi;
  greg_t *regp = (greg_t *) gregsetp;
d964 2
a965 2
  int regi;
  greg_t *regp = (greg_t *) gregsetp;
d987 1
a987 1
  int regi;
@


1.24.8.11
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a23 1
#include "dwarf2-frame.h"
a1155 4

  /* Hook in the DWARF CFI frame unwinder.  */
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);

@


1.24.8.12
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 3
a4 3

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1999, 2000,
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d72 11
d147 14
d1105 2
@


1.23
log
@Fix some K&R isms.
@
text
@d1018 1
a1018 1
  set_gdbarch_store_return_value (gdbarch, m68k_store_return_value);
@


1.22
log
@* m68k-tdep.c (m68k_remote_breakpoint_from_pc): Add. Currently not
used in architecture vector. The default is
m68k_local_breakpoint_from_pc.
(m68k_local_breakpoint_from_pc): Add.
(enum): Add register numbers from tm-m68k.h.
(m68k_gdbarch_init): Add breakpoint_from_pc to architecture vector.
* config/m68k/tm-m68k.h (GDB_MULTI_ARCH): Set to
GDB_MULTI_ARCH_PARTIAL.
(BPT_VECTOR, REGISTER_BYTES_FP, REGISTER_BYTES_NOFP)
(NUM_FREGS, SIG_PC_FP_OFFSET, SP_ARG0, REMOTE_BPT_VECTOR): Move to
m68k-tdep.c.
(BREAKPOINT, REMOTE_BREAKPOINT): Remove.
(A1_REGNUM, FP0_REGNUM, FPC_REGNUM, FPS_REGNUM, FPI_REGNUM): Move
to enum in m68k-tdep.c
@
text
@d123 1
a123 1
m68k_register_bytes_ok (numbytes)
@


1.21
log
@* config/m68k/tm-m68k.h: Rearrange code so macros not in the
gdbarch vector are at the top.
(NUM_REGS): Remove.
(FP_REGNUM, SP_REGNUM, PS_REGNUM, PC_REGNUM, FP0_REGNUM): Remove.
(FRAME_ARGS_ADDRESS): Remove.
(FRAME_LOCALS_ADDRESS): Remove.
(FRAME_NUM_ARGS): Remove.
(FRAME_ARGS_SKIP): Remove.
* m68k-tdep.c (enum): Add eumeration of special register numbers.
(m68k_gdbarch_init): Add gdbarch initializations for macros
undefined in tm-m68k.h
@
text
@d45 11
d58 1
d63 4
a66 1
  E_FP0_REGNUM = 18		/* Floating point register 0 */
d69 30
d101 21
d161 1
a161 1
  if ((unsigned) regnum >= FPC_REGNUM)
d207 2
a208 2
  if (regnum >= FPC_REGNUM)
    return (((regnum - FPC_REGNUM) * 4) + 168);
d221 1
a221 1
  write_register (A1_REGNUM, addr);
d864 1
a864 1
  for (regi = FP0_REGNUM; regi < FPC_REGNUM; regi++)
d869 3
a871 3
  supply_register (FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
d886 1
a886 1
  for (regi = FP0_REGNUM; regi < FPC_REGNUM; regi++)
d895 1
a895 1
  if ((regno == -1) || (regno == FPC_REGNUM))
d897 1
a897 1
      fpregsetp->f_pcr = *(int *) &registers[REGISTER_BYTE (FPC_REGNUM)];
d899 1
a899 1
  if ((regno == -1) || (regno == FPS_REGNUM))
d901 1
a901 1
      fpregsetp->f_psr = *(int *) &registers[REGISTER_BYTE (FPS_REGNUM)];
d903 1
a903 1
  if ((regno == -1) || (regno == FPI_REGNUM))
d905 1
a905 1
      fpregsetp->f_fpiaddr = *(int *) &registers[REGISTER_BYTE (FPI_REGNUM)];
d1005 1
@


1.20
log
@	* config/m68k/tm-m68k.h (DECR_PC_AFTER_BREAK): Remove.
	(REGISTER_BYTES_OK): Remove.
	(REGISTER_BYTES): Remove.
	(STORE_STRUCT_RETURN): Remove.
	(DEPRECATED_EXTRACT_RETURN_VALUE): Remove.
	(STORE_RETURN_VALUE): Remove.
	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Remove.
	(FRAME_CHAIN): Remove.
	(FRAMELESS_FUNCTION_INVOCATION): Remove.
	(FRAME_SAVED_PC): Remove.
	* m68k-tdep.c (m68k_register_bytes_ok):Add.
	(m68k_store_struct_return): Add.
	(m68k_deprecated_extract_return_value): Add.
	(m68k_deprecated_extract_struct_value_address): Add.
	(m68k_store_return_value): Add.
	(m68k_frame_chain): Add.
	(m68k_frameless_function_invocation): Add.
	(m68k_frame_saved_pc): Add.
	(m68k_gdbarch_init): added set_gdbarch calls for new
	functions and deleted macros.
@
text
@d45 9
d929 1
a929 1

d944 2
d954 1
d959 5
d976 5
@


1.19
log
@* config/m68k/tm-m68k.h (REGISTER_BYTE, REGISTER_RAW_SIZE)
(REGISTER_VIRTUAL_SIZE, MAX_REGISTER_RAW_SIZE)
(REGISTER_VIRTUAL_TYPE, REGISTER_NAMES, TARGET_LONG_DOUBLE_FORMAT)
(FUNCTION_START_OFFSET, SKIP_PROLOGUE, SAVED_PC_AFTER_CALL)
(INNER_THAN, STACK_ALIGN, REGISTER_SIZE): Remove macros.

* m68k-tdep.c: Include arch-utils.h
(m68k_register_raw_size): Add.
(m68k_register_virtual_size): Add.
(m68k_register_virtual_type): Add.
(m68k_register_name): Add.
(m68k_stack_align): Add.
(m68k_register_byte): Add.
(m68k_gdbarch_init): Add set_gdbarch calls for macros removed in
tm-m68k.h.
@
text
@d47 7
d140 95
d935 13
d956 3
a958 2

  set_gdbarch_frame_init_saved_regs (gdbarch, m68k_frame_init_saved_regs);
@


1.18
log
@Fixed changelog entry. Indented m68k-tdep.c
@
text
@d30 1
d47 86
d820 21
@


1.17
log
@Replaced frame_find_saved_regs with frame_init_saved_regs. Converted
call dummy macros to multi-arch.
@
text
@d176 2
a177 2
m68k_fix_call_dummy(char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs, 
		    struct value **args, struct type *type, int gcc_p)
d179 3
a181 2
  bfd_putb32 (fun,     (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 2);  
  bfd_putb32 (nargs*4, (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 8);
d239 2
a240 1
	  write_register (regnum, read_memory_integer (frame->saved_regs[regnum], 4));
d716 4
a719 3
  static LONGEST call_dummy_words[7] = {0xf227e0ff, 0x48e7fffc, 0x426742e7, 
					0x4eb93232, 0x3232dffc, 0x69696969, 
					(0x4e404e71 | (BPT_VECTOR << 16))};
d735 1
a735 1
  
d739 1
a739 1
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 24); 
d745 1
a745 1
  
d752 1
a752 1
 
@


1.16
log
@Added functions for multi-arch.
@
text
@d44 2
d171 13
a221 1
  struct frame_saved_regs fsr;
d225 1
a225 1
  get_frame_saved_regs (frame, &fsr);
d228 1
a228 1
      if (fsr.regs[regnum])
d230 1
a230 1
	  read_memory (fsr.regs[regnum], raw_buffer, 12);
d236 1
a236 1
      if (fsr.regs[regnum])
d238 1
a238 1
	  write_register (regnum, read_memory_integer (fsr.regs[regnum], 4));
d241 1
a241 1
  if (fsr.regs[PS_REGNUM])
d244 1
a244 1
		      read_memory_integer (fsr.regs[PS_REGNUM], 4));
d321 6
d328 1
a328 2
m68k_find_saved_regs (struct frame_info *frame_info,
		      struct frame_saved_regs *saved_regs)
d337 1
a337 1
    (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4 - 8 * 12;
d340 8
a347 1
  memset (saved_regs, 0, sizeof (*saved_regs));
d407 1
a407 1
	      saved_regs->regs[regnum] = (next_addr -= 12);
d420 1
a420 1
		saved_regs->regs[regnum] = addr;
d432 1
a432 1
		saved_regs->regs[regnum] = next_addr;
d447 1
a447 1
		saved_regs->regs[regnum] = addr;
d458 1
a458 1
	      saved_regs->regs[regnum] = (next_addr -= 4);
d465 1
a465 1
	  saved_regs->regs[regnum] = (next_addr -= 4);
d475 1
a475 1
		saved_regs->regs[regnum] = next_addr;
d483 1
a483 1
	  saved_regs->regs[PS_REGNUM] = (next_addr -= 4);
d490 3
a492 3
  saved_regs->regs[SP_REGNUM] = (frame_info)->frame + 8;
  saved_regs->regs[FP_REGNUM] = (frame_info)->frame;
  saved_regs->regs[PC_REGNUM] = (frame_info)->frame + 4;
d496 2
a497 1
    saved_regs->regs[SP_REGNUM] = frame_info->next->frame + SIG_SP_FP_OFFSET;
d714 3
d731 19
@


1.15
log
@Indented file using gdb_indent.sh.
@
text
@d680 30
d714 1
@


1.14
log
@Zap sony news (m68k) and ISI (m68k) targets.
@
text
@d84 5
a88 5
    /* Check for an interrupted system call */
    if (frame_info->next && frame_info->next->signal_handler_caller)
      return frame_info->next->frame + 16;
    else
      return frame_info->frame + 4;
d229 2
a230 1
      write_register (PS_REGNUM, read_memory_integer (fsr.regs[PS_REGNUM], 4));
d282 1
a282 1
  limit = (sal.end) ? sal.end : (CORE_ADDR) ~ 0;
d302 1
a302 1
	break;		/* Found unknown code, bail out. */
d318 1
a318 1
  (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4 - 8 * 12;
d371 1
a371 1
  for ( ; ; )
d640 2
a641 3
  if (target_read_memory (sp + SP_ARG0,		/* Offset of first arg on stack */
			  buf,
			  TARGET_PTR_BIT / TARGET_CHAR_BIT))
@


1.14.6.1
log
@Merge with trunk.
@
text
@d84 5
a88 5
      /* Check for an interrupted system call */
      if (frame_info->next && frame_info->next->signal_handler_caller)
	return frame_info->next->frame + 16;
      else
	return frame_info->frame + 4;
d229 1
a229 2
      write_register (PS_REGNUM,
		      read_memory_integer (fsr.regs[PS_REGNUM], 4));
d281 1
a281 1
  limit = (sal.end) ? sal.end : (CORE_ADDR) ~0;
d301 1
a301 1
	break;			/* Found unknown code, bail out. */
d317 1
a317 1
    (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4 - 8 * 12;
d370 1
a370 1
  for (;;)
d639 3
a641 2
  if (target_read_memory (sp + SP_ARG0,	/* Offset of first arg on stack */
			  buf, TARGET_PTR_BIT / TARGET_CHAR_BIT))
a679 30
/* Function: m68k_gdbarch_init
   Initializer function for the m68k gdbarch vector.
   Called by gdbarch.  Sets up the gdbarch vector(s) for this target. */

static struct gdbarch *
m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch_tdep *tdep = NULL;
  struct gdbarch *gdbarch;

  /* find a candidate among the list of pre-declared architectures. */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return (arches->gdbarch);

#if 0
  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
#endif

  gdbarch = gdbarch_alloc (&info, 0);

  return gdbarch;
}


static void
m68k_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{

}
a683 1
  gdbarch_register (bfd_arch_m68k, m68k_gdbarch_init, m68k_dump_tdep);
@


1.14.6.2
log
@More merging.
@
text
@a43 2
void m68k_frame_init_saved_regs (struct frame_info *frame_info);

a168 14
/* Insert the specified number of args and function address
   into a call sequence of the above form stored at DUMMYNAME.
   We use the BFD routines to store a big-endian value of known size.  */

void
m68k_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *type, int gcc_p)
{
  bfd_putb32 (fun, (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 2);
  bfd_putb32 (nargs * 4,
	      (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 8);
}


d207 1
d211 1
a211 1
  m68k_frame_init_saved_regs (frame);
d214 1
a214 1
      if (frame->saved_regs[regnum])
d216 1
a216 1
	  read_memory (frame->saved_regs[regnum], raw_buffer, 12);
d222 1
a222 1
      if (frame->saved_regs[regnum])
d224 1
a224 2
	  write_register (regnum,
			  read_memory_integer (frame->saved_regs[regnum], 4));
d227 1
a227 1
  if (frame->saved_regs[PS_REGNUM])
d230 1
a230 1
		      read_memory_integer (frame->saved_regs[PS_REGNUM], 4));
a306 6
/* Store the addresses of the saved registers of the frame described by 
   FRAME_INFO in its saved_regs field.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */

d308 2
a309 1
m68k_frame_init_saved_regs (struct frame_info *frame_info)
d318 1
a318 1
    (frame_info)->frame - 28 - FP_REGNUM * 4 - 4 - 8 * 12;
d321 1
a321 8

  if (frame_info->saved_regs)
    return;

  frame_saved_regs_zalloc (frame_info);

  memset (frame_info->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);

d381 1
a381 1
	      frame_info->saved_regs[regnum] = (next_addr -= 12);
d394 1
a394 1
		frame_info->saved_regs[regnum] = addr;
d406 1
a406 1
		frame_info->saved_regs[regnum] = next_addr;
d421 1
a421 1
		frame_info->saved_regs[regnum] = addr;
d432 1
a432 1
	      frame_info->saved_regs[regnum] = (next_addr -= 4);
d439 1
a439 1
	  frame_info->saved_regs[regnum] = (next_addr -= 4);
d449 1
a449 1
		frame_info->saved_regs[regnum] = next_addr;
d457 1
a457 1
	  frame_info->saved_regs[PS_REGNUM] = (next_addr -= 4);
d464 3
a466 3
  frame_info->saved_regs[SP_REGNUM] = (frame_info)->frame + 8;
  frame_info->saved_regs[FP_REGNUM] = (frame_info)->frame;
  frame_info->saved_regs[PC_REGNUM] = (frame_info)->frame + 4;
d470 1
a470 2
    frame_info->saved_regs[SP_REGNUM] =
      frame_info->next->frame + SIG_SP_FP_OFFSET;
a686 4
  static LONGEST call_dummy_words[7] = { 0xf227e0ff, 0x48e7fffc, 0x426742e7,
    0x4eb93232, 0x3232dffc, 0x69696969,
    (0x4e404e71 | (BPT_VECTOR << 16))
  };
a699 19

  set_gdbarch_frame_init_saved_regs (gdbarch, m68k_frame_init_saved_regs);

  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 24);
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_call_dummy_length (gdbarch, 28);
  set_gdbarch_call_dummy_start_offset (gdbarch, 12);

  set_gdbarch_call_dummy_words (gdbarch, call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_words));
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_fix_call_dummy (gdbarch, m68k_fix_call_dummy);
  set_gdbarch_push_dummy_frame (gdbarch, m68k_push_dummy_frame);
  set_gdbarch_pop_frame (gdbarch, m68k_pop_frame);
@


1.14.6.3
log
@merge with trunk
@
text
@a29 1
#include "arch-utils.h"
a45 188
static int
m68k_register_bytes_ok (numbytes)
{
  return ((numbytes == REGISTER_BYTES_FP)
	  || (numbytes == REGISTER_BYTES_NOFP));
}

/* Number of bytes of storage in the actual machine representation
   for register regnum.  On the 68000, all regs are 4 bytes
   except the floating point regs which are 12 bytes.  */
/* Note that the unsigned cast here forces the result of the
   subtraction to very high positive values if regnum < FP0_REGNUM */

static int
m68k_register_raw_size (int regnum)
{
  return (((unsigned) (regnum) - FP0_REGNUM) < 8 ? 12 : 4);
}

/* Number of bytes of storage in the program's representation
   for register regnum.  On the 68000, all regs are 4 bytes
   except the floating point regs which are 12-byte long doubles.  */

static int
m68k_register_virtual_size (int regnum)
{
  return (((unsigned) (regnum) - FP0_REGNUM) < 8 ? 12 : 4);
}

/* Return the GDB type object for the "standard" data type of data 
   in register N.  This should be int for D0-D7, long double for FP0-FP7,
   and void pointer for all others (A0-A7, PC, SR, FPCONTROL etc).
   Note, for registers which contain addresses return pointer to void, 
   not pointer to char, because we don't want to attempt to print 
   the string after printing the address.  */

static struct type *
m68k_register_virtual_type (int regnum)
{
  if ((unsigned) regnum >= FPC_REGNUM)
    return lookup_pointer_type (builtin_type_void);
  else if ((unsigned) regnum >= FP0_REGNUM)
    return builtin_type_long_double;
  else if ((unsigned) regnum >= A0_REGNUM)
    return lookup_pointer_type (builtin_type_void);
  else
    return builtin_type_int;
}

/* Function: m68k_register_name
   Returns the name of the standard m68k register regnum. */

static const char *
m68k_register_name (int regnum)
{
  static char *register_names[] = {
    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
    "a0", "a1", "a2", "a3", "a4", "a5", "fp", "sp",
    "ps", "pc",
    "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7",
    "fpcontrol", "fpstatus", "fpiaddr", "fpcode", "fpflags"
  };

  if (regnum < 0 ||
      regnum >= sizeof (register_names) / sizeof (register_names[0]))
    internal_error (__FILE__, __LINE__,
		    "m68k_register_name: illegal register number %d", regnum);
  else
    return register_names[regnum];
}

/* Stack must be kept short aligned when doing function calls.  */

static CORE_ADDR
m68k_stack_align (CORE_ADDR addr)
{
  return ((addr + 1) & ~1);
}

/* Index within `registers' of the first byte of the space for
   register regnum.  */

static int
m68k_register_byte (int regnum)
{
  if (regnum >= FPC_REGNUM)
    return (((regnum - FPC_REGNUM) * 4) + 168);
  else if (regnum >= FP0_REGNUM)
    return (((regnum - FP0_REGNUM) * 12) + 72);
  else
    return (regnum * 4);
}

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function. */

static void
m68k_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (A1_REGNUM, addr);
}

/* Extract from an array regbuf containing the (raw) register state
   a function return value of type type, and copy that, in virtual format,
   into valbuf.  This is assuming that floating point values are returned
   as doubles in d0/d1.  */

static void
m68k_deprecated_extract_return_value (struct type *type, char *regbuf,
				      char *valbuf)
{
  int offset = 0;
  int typeLength = TYPE_LENGTH (type);

  if (typeLength < 4)
    offset = 4 - typeLength;

  memcpy (valbuf, regbuf + offset, typeLength);
}

static CORE_ADDR
m68k_deprecated_extract_struct_value_address (char *regbuf)
{
  return (*(CORE_ADDR *) (regbuf));
}

/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  Assumes floats are passed
   in d0/d1.  */

static void
m68k_store_return_value (struct type *type, char *valbuf)
{
  write_register_bytes (0, valbuf, TYPE_LENGTH (type));
}

/* Describe the pointer in each stack frame to the previous stack frame
   (its caller).  */

/* FRAME_CHAIN takes a frame's nominal address and produces the frame's
   chain-pointer.
   In the case of the 68000, the frame's nominal address
   is the address of a 4-byte word containing the calling frame's address.  */

/* If we are chaining from sigtramp, then manufacture a sigtramp frame
   (which isn't really on the stack.  I'm not sure this is right for anything
   but BSD4.3 on an hp300.  */

static CORE_ADDR
m68k_frame_chain (struct frame_info *thisframe)
{
  if (thisframe->signal_handler_caller)
    return thisframe->frame;
  else if (!inside_entry_file ((thisframe)->pc))
    return read_memory_integer ((thisframe)->frame, 4);
  else
    return 0;
}

/* A function that tells us whether the function invocation represented
   by fi does not have a frame on the stack associated with it.  If it
   does not, FRAMELESS is set to 1, else 0.  */

static int
m68k_frameless_function_invocation (struct frame_info *fi)
{
  if (fi->signal_handler_caller)
    return 0;
  else
    return frameless_look_for_prologue (fi);
}

static CORE_ADDR
m68k_frame_saved_pc (struct frame_info *frame)
{
  if (frame->signal_handler_caller)
    {
      if (frame->next)
	return read_memory_integer (frame->next->frame + SIG_PC_FP_OFFSET, 4);
      else
	return read_memory_integer (read_register (SP_REGNUM)
				    + SIG_PC_FP_OFFSET - 8, 4);
    }
  else
    return read_memory_integer (frame->frame + 4, 4);
}


a733 21
  set_gdbarch_long_double_format (gdbarch, &floatformat_m68881_ext);
  set_gdbarch_long_double_bit (gdbarch, 96);

  set_gdbarch_function_start_offset (gdbarch, 0);

  set_gdbarch_skip_prologue (gdbarch, m68k_skip_prologue);
  set_gdbarch_saved_pc_after_call (gdbarch, m68k_saved_pc_after_call);

  /* Stack grows down. */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_stack_align (gdbarch, m68k_stack_align);

  set_gdbarch_decr_pc_after_break (gdbarch, 2);

  set_gdbarch_store_struct_return (gdbarch, m68k_store_struct_return);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       m68k_deprecated_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, m68k_store_return_value);

  set_gdbarch_frame_chain (gdbarch, m68k_frame_chain);
  set_gdbarch_frame_saved_pc (gdbarch, m68k_frame_saved_pc);
a734 14
  set_gdbarch_frameless_function_invocation (gdbarch,
					     m68k_frameless_function_invocation);

  set_gdbarch_register_raw_size (gdbarch, m68k_register_raw_size);
  set_gdbarch_register_virtual_size (gdbarch, m68k_register_virtual_size);
  set_gdbarch_max_register_raw_size (gdbarch, 12);
  set_gdbarch_max_register_virtual_size (gdbarch, 12);
  set_gdbarch_register_virtual_type (gdbarch, m68k_register_virtual_type);
  set_gdbarch_register_name (gdbarch, m68k_register_name);
  set_gdbarch_register_size (gdbarch, 4);
  set_gdbarch_register_byte (gdbarch, m68k_register_byte);
  set_gdbarch_num_regs (gdbarch, 29);
  set_gdbarch_register_bytes_ok (gdbarch, m68k_register_bytes_ok);
  set_gdbarch_register_bytes (gdbarch, (16 * 4 + 8 + 8 * 12 + 3 * 4));
@


1.14.6.4
log
@merge with trunk
@
text
@a44 9
enum
{
  E_FP_REGNUM = 14,		/* Contains address of executing stack frame */
  E_SP_REGNUM = 15,		/* Contains address of top of stack */
  E_PS_REGNUM = 16,		/* Contains processor status */
  E_PC_REGNUM = 17,		/* Contains program counter */
  E_FP0_REGNUM = 18		/* Floating point register 0 */
};

d920 1
a920 1
 
a934 2

  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
a942 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);
a946 5
  /* OK to default this value to 'unknown'. */
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  set_gdbarch_frame_args_skip (gdbarch, 8);
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
a958 5
  set_gdbarch_sp_regnum (gdbarch, E_SP_REGNUM);
  set_gdbarch_fp_regnum (gdbarch, E_FP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, E_PC_REGNUM);
  set_gdbarch_ps_regnum (gdbarch, E_PS_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, E_FP0_REGNUM);
@


1.14.6.5
log
@merge with trunk.
@
text
@a44 11

/* Register numbers of various important registers.
   Note that some of these values are "real" register numbers,
   and correspond to the general registers of the machine,
   and some are "phony" register numbers which are too large
   to be actual register numbers as far as the user is concerned
   but do serve to get the desired values when passed to read_register.  */

/* Note: Since they are used in files other than this (monitor files), 
   D0_REGNUM and A0_REGNUM are currently defined in tm-m68k.h.  */

a46 1
  E_A1_REGNUM = 9,
d51 1
a51 4
  E_FP0_REGNUM = 18,		/* Floating point register 0 */
  E_FPC_REGNUM = 26,		/* 68881 control register */
  E_FPS_REGNUM = 27,		/* 68881 status register */
  E_FPI_REGNUM = 28
a53 30
#define REGISTER_BYTES_FP (16*4 + 8 + 8*12 + 3*4)
#define REGISTER_BYTES_NOFP (16*4 + 8)

#define NUM_FREGS (NUM_REGS-24)

/* Offset from SP to first arg on stack at first instruction of a function */

#define SP_ARG0 (1 * 4)

/* This was determined by experimentation on hp300 BSD 4.3.  Perhaps
   it corresponds to some offset in /usr/include/sys/user.h or
   something like that.  Using some system include file would
   have the advantage of probably being more robust in the face
   of OS upgrades, but the disadvantage of being wrong for
   cross-debugging.  */

#define SIG_PC_FP_OFFSET 530

#define TARGET_M68K


#if !defined (BPT_VECTOR)
#define BPT_VECTOR 0xf
#endif

#if !defined (REMOTE_BPT_VECTOR)
#define REMOTE_BPT_VECTOR 1
#endif


a55 21

/* gdbarch_breakpoint_from_pc is set to m68k_local_breakpoint_from_pc
   so m68k_remote_breakpoint_from_pc is currently not used.  */

const static unsigned char *
m68k_remote_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char break_insn[] = {0x4e, (0x40 | REMOTE_BPT_VECTOR)};
  *lenptr = sizeof (break_insn);
  return break_insn;
}

const static unsigned char *
m68k_local_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char break_insn[] = {0x4e, (0x40 | BPT_VECTOR)};
  *lenptr = sizeof (break_insn);
  return break_insn;
}


d95 1
a95 1
  if ((unsigned) regnum >= E_FPC_REGNUM)
d141 2
a142 2
  if (regnum >= E_FPC_REGNUM)
    return (((regnum - E_FPC_REGNUM) * 4) + 168);
d155 1
a155 1
  write_register (E_A1_REGNUM, addr);
d798 1
a798 1
  for (regi = FP0_REGNUM; regi < E_FPC_REGNUM; regi++)
d803 3
a805 3
  supply_register (E_FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (E_FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (E_FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
d820 1
a820 1
  for (regi = FP0_REGNUM; regi < E_FPC_REGNUM; regi++)
d829 1
a829 1
  if ((regno == -1) || (regno == E_FPC_REGNUM))
d831 1
a831 1
      fpregsetp->f_pcr = *(int *) &registers[REGISTER_BYTE (E_FPC_REGNUM)];
d833 1
a833 1
  if ((regno == -1) || (regno == E_FPS_REGNUM))
d835 1
a835 1
      fpregsetp->f_psr = *(int *) &registers[REGISTER_BYTE (E_FPS_REGNUM)];
d837 1
a837 1
  if ((regno == -1) || (regno == E_FPI_REGNUM))
d839 1
a839 1
      fpregsetp->f_fpiaddr = *(int *) &registers[REGISTER_BYTE (E_FPI_REGNUM)];
a938 1
  set_gdbarch_breakpoint_from_pc (gdbarch, m68k_local_breakpoint_from_pc);
@


1.14.8.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d84 5
a88 5
      /* Check for an interrupted system call */
      if (frame_info->next && frame_info->next->signal_handler_caller)
	return frame_info->next->frame + 16;
      else
	return frame_info->frame + 4;
d229 1
a229 2
      write_register (PS_REGNUM,
		      read_memory_integer (fsr.regs[PS_REGNUM], 4));
d281 1
a281 1
  limit = (sal.end) ? sal.end : (CORE_ADDR) ~0;
d301 1
a301 1
	break;			/* Found unknown code, bail out. */
d317 1
a317 1
    (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4 - 8 * 12;
d370 1
a370 1
  for (;;)
d639 3
a641 2
  if (target_read_memory (sp + SP_ARG0,	/* Offset of first arg on stack */
			  buf, TARGET_PTR_BIT / TARGET_CHAR_BIT))
@


1.14.8.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a29 1
#include "arch-utils.h"
a43 265

/* Register numbers of various important registers.
   Note that some of these values are "real" register numbers,
   and correspond to the general registers of the machine,
   and some are "phony" register numbers which are too large
   to be actual register numbers as far as the user is concerned
   but do serve to get the desired values when passed to read_register.  */

/* Note: Since they are used in files other than this (monitor files), 
   D0_REGNUM and A0_REGNUM are currently defined in tm-m68k.h.  */

enum
{
  E_A1_REGNUM = 9,
  E_FP_REGNUM = 14,		/* Contains address of executing stack frame */
  E_SP_REGNUM = 15,		/* Contains address of top of stack */
  E_PS_REGNUM = 16,		/* Contains processor status */
  E_PC_REGNUM = 17,		/* Contains program counter */
  E_FP0_REGNUM = 18,		/* Floating point register 0 */
  E_FPC_REGNUM = 26,		/* 68881 control register */
  E_FPS_REGNUM = 27,		/* 68881 status register */
  E_FPI_REGNUM = 28
};

#define REGISTER_BYTES_FP (16*4 + 8 + 8*12 + 3*4)
#define REGISTER_BYTES_NOFP (16*4 + 8)

#define NUM_FREGS (NUM_REGS-24)

/* Offset from SP to first arg on stack at first instruction of a function */

#define SP_ARG0 (1 * 4)

/* This was determined by experimentation on hp300 BSD 4.3.  Perhaps
   it corresponds to some offset in /usr/include/sys/user.h or
   something like that.  Using some system include file would
   have the advantage of probably being more robust in the face
   of OS upgrades, but the disadvantage of being wrong for
   cross-debugging.  */

#define SIG_PC_FP_OFFSET 530

#define TARGET_M68K


#if !defined (BPT_VECTOR)
#define BPT_VECTOR 0xf
#endif

#if !defined (REMOTE_BPT_VECTOR)
#define REMOTE_BPT_VECTOR 1
#endif


void m68k_frame_init_saved_regs (struct frame_info *frame_info);


/* gdbarch_breakpoint_from_pc is set to m68k_local_breakpoint_from_pc
   so m68k_remote_breakpoint_from_pc is currently not used.  */

const static unsigned char *
m68k_remote_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char break_insn[] = {0x4e, (0x40 | REMOTE_BPT_VECTOR)};
  *lenptr = sizeof (break_insn);
  return break_insn;
}

const static unsigned char *
m68k_local_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  static unsigned char break_insn[] = {0x4e, (0x40 | BPT_VECTOR)};
  *lenptr = sizeof (break_insn);
  return break_insn;
}


static int
m68k_register_bytes_ok (long numbytes)
{
  return ((numbytes == REGISTER_BYTES_FP)
	  || (numbytes == REGISTER_BYTES_NOFP));
}

/* Number of bytes of storage in the actual machine representation
   for register regnum.  On the 68000, all regs are 4 bytes
   except the floating point regs which are 12 bytes.  */
/* Note that the unsigned cast here forces the result of the
   subtraction to very high positive values if regnum < FP0_REGNUM */

static int
m68k_register_raw_size (int regnum)
{
  return (((unsigned) (regnum) - FP0_REGNUM) < 8 ? 12 : 4);
}

/* Number of bytes of storage in the program's representation
   for register regnum.  On the 68000, all regs are 4 bytes
   except the floating point regs which are 12-byte long doubles.  */

static int
m68k_register_virtual_size (int regnum)
{
  return (((unsigned) (regnum) - FP0_REGNUM) < 8 ? 12 : 4);
}

/* Return the GDB type object for the "standard" data type of data 
   in register N.  This should be int for D0-D7, long double for FP0-FP7,
   and void pointer for all others (A0-A7, PC, SR, FPCONTROL etc).
   Note, for registers which contain addresses return pointer to void, 
   not pointer to char, because we don't want to attempt to print 
   the string after printing the address.  */

static struct type *
m68k_register_virtual_type (int regnum)
{
  if ((unsigned) regnum >= E_FPC_REGNUM)
    return lookup_pointer_type (builtin_type_void);
  else if ((unsigned) regnum >= FP0_REGNUM)
    return builtin_type_long_double;
  else if ((unsigned) regnum >= A0_REGNUM)
    return lookup_pointer_type (builtin_type_void);
  else
    return builtin_type_int;
}

/* Function: m68k_register_name
   Returns the name of the standard m68k register regnum. */

static const char *
m68k_register_name (int regnum)
{
  static char *register_names[] = {
    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
    "a0", "a1", "a2", "a3", "a4", "a5", "fp", "sp",
    "ps", "pc",
    "fp0", "fp1", "fp2", "fp3", "fp4", "fp5", "fp6", "fp7",
    "fpcontrol", "fpstatus", "fpiaddr", "fpcode", "fpflags"
  };

  if (regnum < 0 ||
      regnum >= sizeof (register_names) / sizeof (register_names[0]))
    internal_error (__FILE__, __LINE__,
		    "m68k_register_name: illegal register number %d", regnum);
  else
    return register_names[regnum];
}

/* Stack must be kept short aligned when doing function calls.  */

static CORE_ADDR
m68k_stack_align (CORE_ADDR addr)
{
  return ((addr + 1) & ~1);
}

/* Index within `registers' of the first byte of the space for
   register regnum.  */

static int
m68k_register_byte (int regnum)
{
  if (regnum >= E_FPC_REGNUM)
    return (((regnum - E_FPC_REGNUM) * 4) + 168);
  else if (regnum >= FP0_REGNUM)
    return (((regnum - FP0_REGNUM) * 12) + 72);
  else
    return (regnum * 4);
}

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function. */

static void
m68k_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (E_A1_REGNUM, addr);
}

/* Extract from an array regbuf containing the (raw) register state
   a function return value of type type, and copy that, in virtual format,
   into valbuf.  This is assuming that floating point values are returned
   as doubles in d0/d1.  */

static void
m68k_deprecated_extract_return_value (struct type *type, char *regbuf,
				      char *valbuf)
{
  int offset = 0;
  int typeLength = TYPE_LENGTH (type);

  if (typeLength < 4)
    offset = 4 - typeLength;

  memcpy (valbuf, regbuf + offset, typeLength);
}

static CORE_ADDR
m68k_deprecated_extract_struct_value_address (char *regbuf)
{
  return (*(CORE_ADDR *) (regbuf));
}

/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.  Assumes floats are passed
   in d0/d1.  */

static void
m68k_store_return_value (struct type *type, char *valbuf)
{
  write_register_bytes (0, valbuf, TYPE_LENGTH (type));
}

/* Describe the pointer in each stack frame to the previous stack frame
   (its caller).  */

/* FRAME_CHAIN takes a frame's nominal address and produces the frame's
   chain-pointer.
   In the case of the 68000, the frame's nominal address
   is the address of a 4-byte word containing the calling frame's address.  */

/* If we are chaining from sigtramp, then manufacture a sigtramp frame
   (which isn't really on the stack.  I'm not sure this is right for anything
   but BSD4.3 on an hp300.  */

static CORE_ADDR
m68k_frame_chain (struct frame_info *thisframe)
{
  if (thisframe->signal_handler_caller)
    return thisframe->frame;
  else if (!inside_entry_file ((thisframe)->pc))
    return read_memory_integer ((thisframe)->frame, 4);
  else
    return 0;
}

/* A function that tells us whether the function invocation represented
   by fi does not have a frame on the stack associated with it.  If it
   does not, FRAMELESS is set to 1, else 0.  */

static int
m68k_frameless_function_invocation (struct frame_info *fi)
{
  if (fi->signal_handler_caller)
    return 0;
  else
    return frameless_look_for_prologue (fi);
}

static CORE_ADDR
m68k_frame_saved_pc (struct frame_info *frame)
{
  if (frame->signal_handler_caller)
    {
      if (frame->next)
	return read_memory_integer (frame->next->frame + SIG_PC_FP_OFFSET, 4);
      else
	return read_memory_integer (read_register (SP_REGNUM)
				    + SIG_PC_FP_OFFSET - 8, 4);
    }
  else
    return read_memory_integer (frame->frame + 4, 4);
}


a168 14
/* Insert the specified number of args and function address
   into a call sequence of the above form stored at DUMMYNAME.
   We use the BFD routines to store a big-endian value of known size.  */

void
m68k_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		     struct value **args, struct type *type, int gcc_p)
{
  bfd_putb32 (fun, (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 2);
  bfd_putb32 (nargs * 4,
	      (unsigned char *) dummy + CALL_DUMMY_START_OFFSET + 8);
}


d207 1
d211 1
a211 1
  m68k_frame_init_saved_regs (frame);
d214 1
a214 1
      if (frame->saved_regs[regnum])
d216 1
a216 1
	  read_memory (frame->saved_regs[regnum], raw_buffer, 12);
d222 1
a222 1
      if (frame->saved_regs[regnum])
d224 1
a224 2
	  write_register (regnum,
			  read_memory_integer (frame->saved_regs[regnum], 4));
d227 1
a227 1
  if (frame->saved_regs[PS_REGNUM])
d230 1
a230 1
		      read_memory_integer (frame->saved_regs[PS_REGNUM], 4));
a306 6
/* Store the addresses of the saved registers of the frame described by 
   FRAME_INFO in its saved_regs field.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special:
   the address we return for it IS the sp for the next frame.  */

d308 2
a309 1
m68k_frame_init_saved_regs (struct frame_info *frame_info)
d318 1
a318 1
    (frame_info)->frame - 28 - FP_REGNUM * 4 - 4 - 8 * 12;
d321 1
a321 8

  if (frame_info->saved_regs)
    return;

  frame_saved_regs_zalloc (frame_info);

  memset (frame_info->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);

d381 1
a381 1
	      frame_info->saved_regs[regnum] = (next_addr -= 12);
d394 1
a394 1
		frame_info->saved_regs[regnum] = addr;
d406 1
a406 1
		frame_info->saved_regs[regnum] = next_addr;
d421 1
a421 1
		frame_info->saved_regs[regnum] = addr;
d432 1
a432 1
	      frame_info->saved_regs[regnum] = (next_addr -= 4);
d439 1
a439 1
	  frame_info->saved_regs[regnum] = (next_addr -= 4);
d449 1
a449 1
		frame_info->saved_regs[regnum] = next_addr;
d457 1
a457 1
	  frame_info->saved_regs[PS_REGNUM] = (next_addr -= 4);
d464 3
a466 3
  frame_info->saved_regs[SP_REGNUM] = (frame_info)->frame + 8;
  frame_info->saved_regs[FP_REGNUM] = (frame_info)->frame;
  frame_info->saved_regs[PC_REGNUM] = (frame_info)->frame + 4;
d470 1
a470 2
    frame_info->saved_regs[SP_REGNUM] =
      frame_info->next->frame + SIG_SP_FP_OFFSET;
d571 1
a571 1
  for (regi = FP0_REGNUM; regi < E_FPC_REGNUM; regi++)
d576 3
a578 3
  supply_register (E_FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (E_FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (E_FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
d593 1
a593 1
  for (regi = FP0_REGNUM; regi < E_FPC_REGNUM; regi++)
d602 1
a602 1
  if ((regno == -1) || (regno == E_FPC_REGNUM))
d604 1
a604 1
      fpregsetp->f_pcr = *(int *) &registers[REGISTER_BYTE (E_FPC_REGNUM)];
d606 1
a606 1
  if ((regno == -1) || (regno == E_FPS_REGNUM))
d608 1
a608 1
      fpregsetp->f_psr = *(int *) &registers[REGISTER_BYTE (E_FPS_REGNUM)];
d610 1
a610 1
  if ((regno == -1) || (regno == E_FPI_REGNUM))
d612 1
a612 1
      fpregsetp->f_fpiaddr = *(int *) &registers[REGISTER_BYTE (E_FPI_REGNUM)];
a679 102
/* Function: m68k_gdbarch_init
   Initializer function for the m68k gdbarch vector.
   Called by gdbarch.  Sets up the gdbarch vector(s) for this target. */

static struct gdbarch *
m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  static LONGEST call_dummy_words[7] = { 0xf227e0ff, 0x48e7fffc, 0x426742e7,
    0x4eb93232, 0x3232dffc, 0x69696969,
    (0x4e404e71 | (BPT_VECTOR << 16))
  };
  struct gdbarch_tdep *tdep = NULL;
  struct gdbarch *gdbarch;

  /* find a candidate among the list of pre-declared architectures. */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return (arches->gdbarch);

#if 0
  tdep = (struct gdbarch_tdep *) xmalloc (sizeof (struct gdbarch_tdep));
#endif
 
  gdbarch = gdbarch_alloc (&info, 0);

  set_gdbarch_long_double_format (gdbarch, &floatformat_m68881_ext);
  set_gdbarch_long_double_bit (gdbarch, 96);

  set_gdbarch_function_start_offset (gdbarch, 0);

  set_gdbarch_skip_prologue (gdbarch, m68k_skip_prologue);
  set_gdbarch_saved_pc_after_call (gdbarch, m68k_saved_pc_after_call);
  set_gdbarch_breakpoint_from_pc (gdbarch, m68k_local_breakpoint_from_pc);

  /* Stack grows down. */
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_stack_align (gdbarch, m68k_stack_align);


  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
  set_gdbarch_decr_pc_after_break (gdbarch, 2);

  set_gdbarch_store_struct_return (gdbarch, m68k_store_struct_return);
  set_gdbarch_deprecated_extract_return_value (gdbarch,
					       m68k_deprecated_extract_return_value);
  set_gdbarch_store_return_value (gdbarch, m68k_store_return_value);

  set_gdbarch_frame_chain (gdbarch, m68k_frame_chain);
  set_gdbarch_frame_chain_valid (gdbarch, generic_func_frame_chain_valid);
  set_gdbarch_frame_saved_pc (gdbarch, m68k_frame_saved_pc);
  set_gdbarch_frame_init_saved_regs (gdbarch, m68k_frame_init_saved_regs);
  set_gdbarch_frameless_function_invocation (gdbarch,
					     m68k_frameless_function_invocation);
  /* OK to default this value to 'unknown'. */
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
  set_gdbarch_frame_args_skip (gdbarch, 8);
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);

  set_gdbarch_register_raw_size (gdbarch, m68k_register_raw_size);
  set_gdbarch_register_virtual_size (gdbarch, m68k_register_virtual_size);
  set_gdbarch_max_register_raw_size (gdbarch, 12);
  set_gdbarch_max_register_virtual_size (gdbarch, 12);
  set_gdbarch_register_virtual_type (gdbarch, m68k_register_virtual_type);
  set_gdbarch_register_name (gdbarch, m68k_register_name);
  set_gdbarch_register_size (gdbarch, 4);
  set_gdbarch_register_byte (gdbarch, m68k_register_byte);
  set_gdbarch_num_regs (gdbarch, 29);
  set_gdbarch_register_bytes_ok (gdbarch, m68k_register_bytes_ok);
  set_gdbarch_register_bytes (gdbarch, (16 * 4 + 8 + 8 * 12 + 3 * 4));
  set_gdbarch_sp_regnum (gdbarch, E_SP_REGNUM);
  set_gdbarch_fp_regnum (gdbarch, E_FP_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, E_PC_REGNUM);
  set_gdbarch_ps_regnum (gdbarch, E_PS_REGNUM);
  set_gdbarch_fp0_regnum (gdbarch, E_FP0_REGNUM);

  set_gdbarch_use_generic_dummy_frames (gdbarch, 0);
  set_gdbarch_call_dummy_location (gdbarch, ON_STACK);
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1);
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 24);
  set_gdbarch_pc_in_call_dummy (gdbarch, pc_in_call_dummy_on_stack);
  set_gdbarch_call_dummy_p (gdbarch, 1);
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_call_dummy_length (gdbarch, 28);
  set_gdbarch_call_dummy_start_offset (gdbarch, 12);

  set_gdbarch_call_dummy_words (gdbarch, call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (call_dummy_words));
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
  set_gdbarch_fix_call_dummy (gdbarch, m68k_fix_call_dummy);
  set_gdbarch_push_dummy_frame (gdbarch, m68k_push_dummy_frame);
  set_gdbarch_pop_frame (gdbarch, m68k_pop_frame);

  return gdbarch;
}


static void
m68k_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{

}
a683 1
  gdbarch_register (bfd_arch_m68k, m68k_gdbarch_init, m68k_dump_tdep);
@


1.14.8.3
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1018 1
a1018 1
  set_gdbarch_deprecated_store_return_value (gdbarch, m68k_store_return_value);
@


1.13
log
@Obsolete NEWS and ISI systems (along with a few redundant m68k targets).
@
text
@a65 22
/* The only reason this is here is the tm-isi.h reference below.  It
   was moved back here from tm-m68k.h.  FIXME? */

/* OBSOLETE extern CORE_ADDR */
/* OBSOLETE isi_skip_prologue (CORE_ADDR pc) */
/* OBSOLETE { */
/* OBSOLETE   register int op = read_memory_integer (pc, 2); */
/* OBSOLETE   if (op == P_LINKW_FP) */
/* OBSOLETE     pc += 4;			 *//* Skip link #word */
/* OBSOLETE   else if (op == P_LINKL_FP) */
/* OBSOLETE     pc += 6;			 *//* Skip link #long */
/* OBSOLETE    *//* Not sure why branches are here.  */
/* OBSOLETE    *//* From tm-isi.h, tm-altos.h */
/* OBSOLETE   else if (op == 0060000) */
/* OBSOLETE     pc += 4;			 *//* Skip bra #word */
/* OBSOLETE   else if (op == 00600377) */
/* OBSOLETE     pc += 6;			 *//* skip bra #long */
/* OBSOLETE   else if ((op & 0177400) == 0060000) */
/* OBSOLETE     pc += 2;			 *//* skip bra #char */
/* OBSOLETE   return pc; */
/* OBSOLETE } */

@


1.12
log
@Update/correct copyright notices.
@
text
@d56 1
a56 1
  /* From tm-isi.h, tm-altos.h */
d69 18
a86 18
extern CORE_ADDR
isi_skip_prologue (CORE_ADDR pc)
{
  register int op = read_memory_integer (pc, 2);
  if (op == P_LINKW_FP)
    pc += 4;			/* Skip link #word */
  else if (op == P_LINKL_FP)
    pc += 6;			/* Skip link #long */
  /* Not sure why branches are here.  */
  /* From tm-isi.h, tm-altos.h */
  else if (op == 0060000)
    pc += 4;			/* Skip bra #word */
  else if (op == 00600377)
    pc += 6;			/* skip bra #long */
  else if ((op & 0177400) == 0060000)
    pc += 2;			/* skip bra #char */
  return pc;
}
@


1.11
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 1992, 1993, 1994, 1995, 1996, 1999, 2000, 2001
@


1.10
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d29 1
@


1.9
log
@Work around targets that don't yet define JB_PC or JB_ELEMENT_SIZE.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 1992, 1993, 1994, 1995, 1996, 1999, 2000
d675 2
a676 1
  internal_error ("m68k_get_longjmp_target: not implemented");
@


1.8
log
@Rename get_longjmp_target to m68k_get_longjmp_target.  Update all m68k
targets.
@
text
@d645 5
d653 1
d674 4
@


1.7
log
@2000-08-09  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * blockframe.c (sigtramp_saved_pc): Use dynamic allocation,
        since TARGET_PTR_BIT is no longer a constant (MULTI_ARCH).
        * irix4-nat.c (get_longjmp_target): Ditto.
        * irix5-nat.c (get_longjmp_target): Ditto.
        * jv-valprint.c (java_value_print): Ditto.
        * m3-nat.c (get_cprocs):            Ditto.
        * m68k-tdep.c (get_longjmp_target): Ditto.
        * mips-nat.c  (get_longjmp_target): Ditto.
        * mipsv4-nat.c(get_longjmp_target): Ditto.
        * pa64solib.c (read_dynamic_info):  Ditto.
        * solib.c (elf_locate_base):        Ditto.
@
text
@a639 1
#ifdef GET_LONGJMP_TARGET
d646 1
a646 1
get_longjmp_target (CORE_ADDR *pc)
a668 1
#endif /* GET_LONGJMP_TARGET */
@


1.6
log
@Protoization.
@
text
@d649 1
a649 1
  char buf[TARGET_PTR_BIT / TARGET_CHAR_BIT];
d652 1
@


1.5
log
@2000-05-26  Michael Snyder  <msnyder@@seadog.cygnus.com>

        * gregset.h: New file.  Typedefs for gdb_gregset_t and
        gdb_fpregset_t, prototypes for supply_gregset and friends.
        * procfs.c: Include gregset.h.  Delete local prototypes for
        supply_gregset etc., and local typedef gdb_gregset_t etc.
        * sol-thread.c: Include gregset.h, delete local prototypes,
        add appropriate casts to gdb_gregset_t.
        * uw-thread.c, lin-thread.c, core-sol2.c, core-regset.c,
        sparc-tdep.c, ptx4-nat.c, ppc-linux-nat.c, mipsv4-nat.c,
        m88k-nat.c, m68klinux-nat.c, m68k-tdep.c, irix5-nat.c,
        irix4-nat.c, ia64-linux-nat.c, i386v4-nat.c, cxux-nat.c,
        arm-linux-nat.c, alpha-nat.c: Include gregset.h.
        * config/nm-linux.h: Define GDB_GREGSET_T, GDB_FPREGET_T.
        * config/sparc/tm-sun4sol2.h: Ditto.
@
text
@d47 1
a47 2
altos_skip_prologue (pc)
     CORE_ADDR pc;
d69 1
a69 2
isi_skip_prologue (pc)
     CORE_ADDR pc;
d88 1
a88 3
delta68_in_sigtramp (pc, name)
     CORE_ADDR pc;
     char *name;
d97 1
a97 2
delta68_frame_args_address (frame_info)
     struct frame_info * frame_info;
d116 1
a116 2
delta68_frame_saved_pc (frame_info)
     struct frame_info * frame_info;
d125 1
a125 2
isi_frame_num_args (fi)
     struct frame_info *fi;
d147 1
a147 2
delta68_frame_num_args (fi)
     struct frame_info *fi;
d169 1
a169 2
news_frame_num_args (fi)
     struct frame_info *fi;
d193 1
a193 1
m68k_push_dummy_frame ()
d223 1
a223 1
m68k_pop_frame ()
d292 1
a292 2
m68k_skip_prologue (ip)
     CORE_ADDR ip;
d328 2
a329 3
m68k_find_saved_regs (frame_info, saved_regs)
     struct frame_info *frame_info;
     struct frame_saved_regs *saved_regs;
d543 1
a543 2
supply_gregset (gregsetp)
     gregset_t *gregsetp;
d557 1
a557 3
fill_gregset (gregsetp, regno)
     gregset_t *gregsetp;
     int regno;
d586 1
a586 2
supply_fpregset (fpregsetp)
     fpregset_t *fpregsetp;
d607 1
a607 3
fill_fpregset (fpregsetp, regno)
     fpregset_t *fpregsetp;
     int regno;
d647 1
a647 2
get_longjmp_target (pc)
     CORE_ADDR *pc;
d677 1
a677 2
m68k_saved_pc_after_call (frame)
     struct frame_info *frame;
d693 1
a693 1
_initialize_m68k_tdep ()
@


1.4
log
@From "Serge Nikulin" <nikulin@@actsw.amat.com>:
Don't trip on NULL function name in sigtramp.
@
text
@d510 3
@


1.3
log
@
	Fix copyright dates in last change.
@
text
@d94 4
a97 1
  return strcmp (name, "_sigcode") == 0;
@


1.3.2.1
log
@From "Serge Nikulin" <nikulin@@actsw.amat.com>:
Don't trip on NULL function name in sigtramp.
@
text
@d94 1
a94 4
  if (name != NULL)
    return strcmp (name, "_sigcode") == 0;
  else
    return 0;
@


1.2
log
@
	* m68k-tdep.c (P_LINKL_FP, P_LINKW_FP): Macros renamed from P_LINK_L
	and P_LINK_W.
	(P_PEA_FP, P_MOVL_SP_FP): New macros.
	(P_MOVL, P_LEAL, P_MOVML): Macros renamed from P_MOV_L, P_LEA_L and
	P_MOVM_L.
	(altos_skip_prologue, isi_skip_prologue): Use P_* macros, not octal
 	constants.
	(delta68_in_sigtramp): New function.
	(delta68_frame_args_address, delta68_frame_saved_pc): Ditto.
	(m68k_skip_prologue): Use P_* macros, not hex constants.
	(m68k_find_saved_regs): Do not expect a fixed sequence of register save
	instructions, but accept them in any order; use P_* macros, not octal
	or hex constants; recognize also `fmovemx to (fp + displacement)' and
 	`moveml to (fp + displacement)'.
	* m68/tm-delta68.h (IN_SIGTRAMP): New macro.
	(FRAME_SAVED_PC, FRAME_ARGS_ADDRESS): Ditto.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 1992 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 167
a194 1

d238 1
a238 1
  for (regnum = FP0_REGNUM + 7 ; regnum >= FP0_REGNUM ; regnum--)
d246 1
a246 1
  for (regnum = FP_REGNUM - 1 ; regnum >= 0 ; regnum--)
d262 1
a263 1

d275 1
a275 1
	link.w	%a6,&0			4e56  XXXX
d279 1
a279 1
	link.l  %fp,&F%1		480e  XXXX  XXXX
d283 1
a283 1
	movm.l  &M%1,(4,%sp)		48ef  XXXX  XXXX
d287 1
a287 1
	fmovm   &FPM%1,(FPO%1,%sp)	f237  XXXX  XXXX  XXXX  XXXX
d291 2
a292 2
	lea.l   (.L3,%pc),%a1		43fb  XXXX  XXXX  XXXX
	bsr     _mcount			61ff  XXXX  XXXX
d294 1
a294 11
  */

#define P_LINK_L	0x480e
#define P_LINK_W	0x4e56
#define P_MOV_L		0x207c
#define P_JSR		0x4eb9
#define P_BSR		0x61ff
#define P_LEA_L		0x43fb
#define P_MOVM_L	0x48ef
#define P_FMOVM		0xf237
#define P_TRAP		0x4e40
d298 1
a298 1
CORE_ADDR ip;
d308 1
a308 1
  limit = (sal.end) ? sal.end : (CORE_ADDR) ~0;
d314 11
a324 17
      
      if (op == P_LINK_W)
	{
	  ip += 4;	/* Skip link.w */
	}
      else if (op == 0x4856)
	ip += 2; /* Skip pea %fp */
      else if (op == 0x2c4f)
	ip += 2; /* Skip move.l %sp, %fp */
      else if (op == P_LINK_L)
	{
	  ip += 6;	/* Skip link.l */
	}
      else if (op == P_MOVM_L)
	{
	  ip += 6;	/* Skip movm.l */
	}
d326 1
a326 3
	{
	  ip += 10;	/* Skip fmovm */
	}
d328 1
a328 3
	{
	  break;	/* Found unknown code, bail out. */
	}
d338 3
a340 3
  register int regnum;							
  register int regmask;							
  register CORE_ADDR next_addr;						
d345 1
a345 1
    (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM*4 - 4 - 8*12;
d354 3
a356 3
	 what the call dummy saves and where.  But this code proceeds
	 to parse the "prologue" which is part of the call dummy.
	 This is needlessly complex and confusing.  FIXME.  */
d361 1
a361 1
  else   								
d363 1
a363 1
      pc = get_pc_function_start ((frame_info)->pc); 			
d365 3
a367 2
      if (0x4856 == read_memory_integer (pc, 2)
	  && 0x2c4f == read_memory_integer (pc + 2, 2))
d369 3
a371 4
	  /*
	    pea %fp
            move.l %sp, %fp */

a372 1
	  next_addr = frame_info->frame;
d374 1
a374 1
      else if (044016 == read_memory_integer (pc, 2))
d378 5
a382 2
	next_addr = (frame_info)->frame + read_memory_integer (pc += 2, 4), pc+=4; 
      else if (047126 == read_memory_integer (pc, 2))			
d386 29
a414 2
	next_addr = (frame_info)->frame + read_memory_integer (pc += 2, 2), pc+=2; 
      else goto lose;
d416 48
a463 36
      /* If have an addal #-n, sp next, adjust next_addr.  */		
      if ((0177777 & read_memory_integer (pc, 2)) == 0157774)		
	next_addr += read_memory_integer (pc += 2, 4), pc += 4;		
    }									
  regmask = read_memory_integer (pc + 2, 2);				

  /* Here can come an fmovem.  Check for it.  */		
  nextinsn = 0xffff & read_memory_integer (pc, 2);			
  if (0xf227 == nextinsn						
      && (regmask & 0xff00) == 0xe000)					
    { pc += 4; /* Regmask's low bit is for register fp7, the first pushed */ 
      for (regnum = FP0_REGNUM + 7; regnum >= FP0_REGNUM; regnum--, regmask >>= 1)		
	if (regmask & 1)						
          saved_regs->regs[regnum] = (next_addr -= 12);		
      regmask = read_memory_integer (pc + 2, 2); }

  /* next should be a moveml to (sp) or -(sp) or a movl r,-(sp) */	
  if (0044327 == read_memory_integer (pc, 2))				
    { pc += 4; /* Regmask's low bit is for register 0, the first written */ 
      for (regnum = 0; regnum < 16; regnum++, regmask >>= 1)		
	if (regmask & 1)						
          saved_regs->regs[regnum] = (next_addr += 4) - 4; }	
  else if (0044347 == read_memory_integer (pc, 2))			
    {
      pc += 4; /* Regmask's low bit is for register 15, the first pushed */ 
      for (regnum = 15; regnum >= 0; regnum--, regmask >>= 1)		
	if (regmask & 1)						
          saved_regs->regs[regnum] = (next_addr -= 4);
    }
  else if (0x2f00 == (0xfff0 & read_memory_integer (pc, 2)))		
    {
      regnum = 0xf & read_memory_integer (pc, 2); pc += 2;		
      saved_regs->regs[regnum] = (next_addr -= 4);
      /* gcc, at least, may use a pair of movel instructions when saving
	 exactly 2 registers.  */
      if (0x2f00 == (0xfff0 & read_memory_integer (pc, 2)))
d465 2
a466 1
	  regnum = 0xf & read_memory_integer (pc, 2);
a467 1
	  saved_regs->regs[regnum] = (next_addr -= 4);
d469 20
d490 4
a493 19

  /* fmovemx to index of sp may follow.  */				
  regmask = read_memory_integer (pc + 2, 2);				
  nextinsn = 0xffff & read_memory_integer (pc, 2);			
  if (0xf236 == nextinsn						
      && (regmask & 0xff00) == 0xf000)					
    { pc += 10; /* Regmask's low bit is for register fp0, the first written */ 
      for (regnum = FP0_REGNUM + 7; regnum >= FP0_REGNUM; regnum--, regmask >>= 1)		
	if (regmask & 1)						
          saved_regs->regs[regnum] = (next_addr += 12) - 12;	
      regmask = read_memory_integer (pc + 2, 2); }			

  /* clrw -(sp); movw ccr,-(sp) may follow.  */				
  if (0x426742e7 == read_memory_integer (pc, 4))			
    saved_regs->regs[PS_REGNUM] = (next_addr -= 4);		
  lose: ;								
  saved_regs->regs[SP_REGNUM] = (frame_info)->frame + 8;		
  saved_regs->regs[FP_REGNUM] = (frame_info)->frame;		
  saved_regs->regs[PC_REGNUM] = (frame_info)->frame + 4;		
d502 1
a502 1
#ifdef USE_PROC_FS	/* Target dependent support for /proc */
d507 23
a529 23
    two different sets, the general register set (gregset) and the floating
    point register set (fpregset).  For each set, there is an ioctl to get
    the current register set and another ioctl to set the current values.

    The actual structure passed through the ioctl interface is, of course,
    naturally machine dependent, and is different for each set of registers.
    For the m68k for example, the general register set is typically defined
    by:

	typedef int gregset_t[18];

	#define	R_D0	0
	...
	#define	R_PS	17

    and the floating point set by:

    	typedef	struct fpregset {
	  int	f_pcr;
	  int	f_psr;
	  int	f_fpiaddr;
	  int	f_fpregs[8][3];		(8 regs, 96 bits each)
	} fpregset_t;
d531 2
a532 2
    These routines provide the packing and unpacking of gregset_t and
    fpregset_t formatted data.
d543 2
a544 2
    unpack the register contents and supply them as gdb's idea of the current
    register values. */
d548 1
a548 1
gregset_t *gregsetp;
d553 1
a553 1
  for (regi = 0 ; regi < R_PC ; regi++)
d563 2
a564 2
gregset_t *gregsetp;
int regno;
a567 1
  extern char registers[];
d569 1
a569 1
  for (regi = 0 ; regi < R_PC ; regi++)
d589 2
a590 2
    (fpregset_t *), unpack the register contents and supply them as gdb's
    idea of the current floating point register values. */
d592 1
a592 1
void 
d594 1
a594 1
fpregset_t *fpregsetp;
d598 2
a599 2
  
  for (regi = FP0_REGNUM ; regi < FPC_REGNUM ; regi++)
d601 1
a601 1
      from = (char *) &(fpregsetp -> f_fpregs[regi-FP0_REGNUM][0]);
d604 3
a606 3
  supply_register (FPC_REGNUM, (char *) &(fpregsetp -> f_pcr));
  supply_register (FPS_REGNUM, (char *) &(fpregsetp -> f_psr));
  supply_register (FPI_REGNUM, (char *) &(fpregsetp -> f_fpiaddr));
d610 3
a612 3
    (fpregset_t *), update the register specified by REGNO from gdb's idea
    of the current floating point register set.  If REGNO is -1, update
    them all. */
d616 2
a617 2
fpregset_t *fpregsetp;
int regno;
a621 1
  extern char registers[];
d623 1
a623 1
  for (regi = FP0_REGNUM ; regi < FPC_REGNUM ; regi++)
d628 1
a628 1
	  to = (char *) &(fpregsetp -> f_fpregs[regi-FP0_REGNUM][0]);
d634 1
a634 1
      fpregsetp -> f_pcr = *(int *) &registers[REGISTER_BYTE (FPC_REGNUM)];
d638 1
a638 1
      fpregsetp -> f_psr = *(int *) &registers[REGISTER_BYTE (FPS_REGNUM)];
d642 1
a642 1
      fpregsetp -> f_fpiaddr = *(int *) &registers[REGISTER_BYTE (FPI_REGNUM)];
d646 1
a646 1
#endif	/* defined (FP0_REGNUM) */
d648 1
a648 1
#endif  /* USE_PROC_FS */
d657 1
a657 1
get_longjmp_target(pc)
d663 1
a663 1
  sp = read_register(SP_REGNUM);
d665 1
a665 1
  if (target_read_memory (sp + SP_ARG0, /* Offset of first arg on stack */
d688 1
a688 1
m68k_saved_pc_after_call(frame)
d702 1
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a25 1
#include "inferior.h"
d375 1
d430 1
@


1.1.1.3
log
@import gdb-19990504 snapshot
@
text
@a28 47
/* The only reason this is here is the tm-altos.h reference below.  It
   was moved back here from tm-m68k.h.  FIXME? */

extern CORE_ADDR
altos_skip_prologue (pc)
     CORE_ADDR pc;
{
  register int op = read_memory_integer (pc, 2);
  if (op == 0047126)
    pc += 4;   /* Skip link #word */
  else if (op == 0044016)
    pc += 6;   /* Skip link #long */
  /* Not sure why branches are here.  */
  /* From tm-isi.h, tm-altos.h */
  else if (op == 0060000)
    pc += 4;   /* Skip bra #word */
  else if (op == 00600377)
    pc += 6;   /* skip bra #long */
  else if ((op & 0177400) == 0060000)
    pc += 2;   /* skip bra #char */
  return pc;
}

/* The only reason this is here is the tm-isi.h reference below.  It
   was moved back here from tm-m68k.h.  FIXME? */

extern CORE_ADDR
isi_skip_prologue (pc)
     CORE_ADDR pc;
{
  register int op = read_memory_integer (pc, 2);
  if (op == 0047126)
    pc += 4;   /* Skip link #word */
  else if (op == 0044016)
    pc += 6;   /* Skip link #long */
  /* Not sure why branches are here.  */
  /* From tm-isi.h, tm-altos.h */
  else if (op == 0060000)
    pc += 4;   /* Skip bra #word */
  else if (op == 00600377)
    pc += 6;   /* skip bra #long */
  else if ((op & 0177400) == 0060000)
    pc += 2;   /* skip bra #char */
  return pc;
}


@


1.1.1.4
log
@import gdb-1999-05-25 snapshot
@
text
@a74 71
/* Return number of args passed to a frame.
   Can return -1, meaning no way to tell.  */

int
isi_frame_num_args (fi)
     struct frame_info *fi;
{
  int val;
  CORE_ADDR pc = FRAME_SAVED_PC (fi);
  int insn = 0177777 & read_memory_integer (pc, 2);
  val = 0;
  if (insn == 0047757 || insn == 0157374)  /* lea W(sp),sp or addaw #W,sp */
    val = read_memory_integer (pc + 2, 2);
  else if ((insn & 0170777) == 0050217 /* addql #N, sp */
	   || (insn & 0170777) == 0050117)  /* addqw */
    {
      val = (insn >> 9) & 7;
      if (val == 0)
	val = 8;
    }
  else if (insn == 0157774) /* addal #WW, sp */
    val = read_memory_integer (pc + 2, 4);
  val >>= 2;
  return val;
}

int
delta68_frame_num_args (fi)
     struct frame_info *fi;
{
  int val;
  CORE_ADDR pc = FRAME_SAVED_PC (fi);
  int insn = 0177777 & read_memory_integer (pc, 2);
  val = 0;
  if (insn == 0047757 || insn == 0157374)  /* lea W(sp),sp or addaw #W,sp */
    val = read_memory_integer (pc + 2, 2);
  else if ((insn & 0170777) == 0050217 /* addql #N, sp */
	   || (insn & 0170777) == 0050117)  /* addqw */
    {
      val = (insn >> 9) & 7;
      if (val == 0)
	val = 8;
    }
  else if (insn == 0157774) /* addal #WW, sp */
    val = read_memory_integer (pc + 2, 4);
  val >>= 2;
  return val;
}

int
news_frame_num_args (fi)
     struct frame_info *fi;
{
  int val;
  CORE_ADDR pc = FRAME_SAVED_PC (fi);
  int insn = 0177777 & read_memory_integer (pc, 2);
  val = 0;
  if (insn == 0047757 || insn == 0157374)  /* lea W(sp),sp or addaw #W,sp */
    val = read_memory_integer (pc + 2, 2);
  else if ((insn & 0170777) == 0050217 /* addql #N, sp */
	   || (insn & 0170777) == 0050117)  /* addqw */
    {
      val = (insn >> 9) & 7;
      if (val == 0)
	val = 8;
    }
  else if (insn == 0157774) /* addal #WW, sp */
    val = read_memory_integer (pc + 2, 4);
  val >>= 2;
  return val;
}
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d27 1
a28 1

d38 1
a38 1
    pc += 4;			/* Skip link #word */
d40 1
a40 1
    pc += 6;			/* Skip link #long */
d44 1
a44 1
    pc += 4;			/* Skip bra #word */
d46 1
a46 1
    pc += 6;			/* skip bra #long */
d48 1
a48 1
    pc += 2;			/* skip bra #char */
d61 1
a61 1
    pc += 4;			/* Skip link #word */
d63 1
a63 1
    pc += 6;			/* Skip link #long */
d67 1
a67 1
    pc += 4;			/* Skip bra #word */
d69 1
a69 1
    pc += 6;			/* skip bra #long */
d71 1
a71 1
    pc += 2;			/* skip bra #char */
d86 1
a86 1
  if (insn == 0047757 || insn == 0157374)	/* lea W(sp),sp or addaw #W,sp */
d88 2
a89 2
  else if ((insn & 0170777) == 0050217	/* addql #N, sp */
	   || (insn & 0170777) == 0050117)	/* addqw */
d95 1
a95 1
  else if (insn == 0157774)	/* addal #WW, sp */
d109 1
a109 1
  if (insn == 0047757 || insn == 0157374)	/* lea W(sp),sp or addaw #W,sp */
d111 2
a112 2
  else if ((insn & 0170777) == 0050217	/* addql #N, sp */
	   || (insn & 0170777) == 0050117)	/* addqw */
d118 1
a118 1
  else if (insn == 0157774)	/* addal #WW, sp */
d132 1
a132 1
  if (insn == 0047757 || insn == 0157374)	/* lea W(sp),sp or addaw #W,sp */
d134 2
a135 2
  else if ((insn & 0170777) == 0050217	/* addql #N, sp */
	   || (insn & 0170777) == 0050117)	/* addqw */
d141 1
a141 1
  else if (insn == 0157774)	/* addal #WW, sp */
d190 1
a190 1
  for (regnum = FP0_REGNUM + 7; regnum >= FP0_REGNUM; regnum--)
d198 1
a198 1
  for (regnum = FP_REGNUM - 1; regnum >= 0; regnum--)
d214 1
a215 1

d227 1
a227 1
   link.w       %a6,&0                  4e56  XXXX
d231 1
a231 1
   link.l  %fp,&F%1             480e  XXXX  XXXX
d235 1
a235 1
   movm.l  &M%1,(4,%sp)         48ef  XXXX  XXXX
d239 1
a239 1
   fmovm   &FPM%1,(FPO%1,%sp)   f237  XXXX  XXXX  XXXX  XXXX
d243 2
a244 2
   lea.l   (.L3,%pc),%a1                43fb  XXXX  XXXX  XXXX
   bsr     _mcount                      61ff  XXXX  XXXX
d246 1
a246 1
 */
d260 1
a260 1
     CORE_ADDR ip;
d270 1
a270 1
  limit = (sal.end) ? sal.end : (CORE_ADDR) ~ 0;
d276 1
a276 1

d279 1
a279 1
	  ip += 4;		/* Skip link.w */
d282 1
a282 1
	ip += 2;		/* Skip pea %fp */
d284 1
a284 1
	ip += 2;		/* Skip move.l %sp, %fp */
d287 1
a287 1
	  ip += 6;		/* Skip link.l */
d291 1
a291 1
	  ip += 6;		/* Skip movm.l */
d295 1
a295 1
	  ip += 10;		/* Skip fmovm */
d299 1
a299 1
	  break;		/* Found unknown code, bail out. */
d310 3
a312 3
  register int regnum;
  register int regmask;
  register CORE_ADDR next_addr;
d317 1
a317 1
  (frame_info)->frame - CALL_DUMMY_LENGTH - FP_REGNUM * 4 - 4 - 8 * 12;
d326 3
a328 3
         what the call dummy saves and where.  But this code proceeds
         to parse the "prologue" which is part of the call dummy.
         This is needlessly complex and confusing.  FIXME.  */
d333 1
a333 1
  else
d335 1
a335 1
      pc = get_pc_function_start ((frame_info)->pc);
d341 2
a342 2
	     pea %fp
	     move.l %sp, %fp */
d351 2
a352 2
	next_addr = (frame_info)->frame + read_memory_integer (pc += 2, 4), pc += 4;
      else if (047126 == read_memory_integer (pc, 2))
d356 2
a357 3
	next_addr = (frame_info)->frame + read_memory_integer (pc += 2, 2), pc += 2;
      else
	goto lose;
d359 28
a386 3
      /* If have an addal #-n, sp next, adjust next_addr.  */
      if ((0177777 & read_memory_integer (pc, 2)) == 0157774)
	next_addr += read_memory_integer (pc += 2, 4), pc += 4;
d388 1
a388 6
  regmask = read_memory_integer (pc + 2, 2);

  /* Here can come an fmovem.  Check for it.  */
  nextinsn = 0xffff & read_memory_integer (pc, 2);
  if (0xf227 == nextinsn
      && (regmask & 0xff00) == 0xe000)
d390 1
a390 26
      pc += 4;			/* Regmask's low bit is for register fp7, the first pushed */
      for (regnum = FP0_REGNUM + 7; regnum >= FP0_REGNUM; regnum--, regmask >>= 1)
	if (regmask & 1)
	  saved_regs->regs[regnum] = (next_addr -= 12);
      regmask = read_memory_integer (pc + 2, 2);
    }

  /* next should be a moveml to (sp) or -(sp) or a movl r,-(sp) */
  if (0044327 == read_memory_integer (pc, 2))
    {
      pc += 4;			/* Regmask's low bit is for register 0, the first written */
      for (regnum = 0; regnum < 16; regnum++, regmask >>= 1)
	if (regmask & 1)
	  saved_regs->regs[regnum] = (next_addr += 4) - 4;
    }
  else if (0044347 == read_memory_integer (pc, 2))
    {
      pc += 4;			/* Regmask's low bit is for register 15, the first pushed */
      for (regnum = 15; regnum >= 0; regnum--, regmask >>= 1)
	if (regmask & 1)
	  saved_regs->regs[regnum] = (next_addr -= 4);
    }
  else if (0x2f00 == (0xfff0 & read_memory_integer (pc, 2)))
    {
      regnum = 0xf & read_memory_integer (pc, 2);
      pc += 2;
d393 1
a393 1
         exactly 2 registers.  */
d402 18
a419 20
  /* fmovemx to index of sp may follow.  */
  regmask = read_memory_integer (pc + 2, 2);
  nextinsn = 0xffff & read_memory_integer (pc, 2);
  if (0xf236 == nextinsn
      && (regmask & 0xff00) == 0xf000)
    {
      pc += 10;			/* Regmask's low bit is for register fp0, the first written */
      for (regnum = FP0_REGNUM + 7; regnum >= FP0_REGNUM; regnum--, regmask >>= 1)
	if (regmask & 1)
	  saved_regs->regs[regnum] = (next_addr += 12) - 12;
      regmask = read_memory_integer (pc + 2, 2);
    }

  /* clrw -(sp); movw ccr,-(sp) may follow.  */
  if (0x426742e7 == read_memory_integer (pc, 4))
    saved_regs->regs[PS_REGNUM] = (next_addr -= 4);
lose:;
  saved_regs->regs[SP_REGNUM] = (frame_info)->frame + 8;
  saved_regs->regs[FP_REGNUM] = (frame_info)->frame;
  saved_regs->regs[PC_REGNUM] = (frame_info)->frame + 4;
d428 1
a428 1
#ifdef USE_PROC_FS		/* Target dependent support for /proc */
d433 23
a455 23
   two different sets, the general register set (gregset) and the floating
   point register set (fpregset).  For each set, there is an ioctl to get
   the current register set and another ioctl to set the current values.

   The actual structure passed through the ioctl interface is, of course,
   naturally machine dependent, and is different for each set of registers.
   For the m68k for example, the general register set is typically defined
   by:

   typedef int gregset_t[18];

   #define      R_D0    0
   ...
   #define      R_PS    17

   and the floating point set by:

   typedef      struct fpregset {
   int  f_pcr;
   int  f_psr;
   int  f_fpiaddr;
   int  f_fpregs[8][3];         (8 regs, 96 bits each)
   } fpregset_t;
d457 2
a458 2
   These routines provide the packing and unpacking of gregset_t and
   fpregset_t formatted data.
d469 2
a470 2
   unpack the register contents and supply them as gdb's idea of the current
   register values. */
d474 1
a474 1
     gregset_t *gregsetp;
d479 1
a479 1
  for (regi = 0; regi < R_PC; regi++)
d489 2
a490 2
     gregset_t *gregsetp;
     int regno;
d495 1
a495 1
  for (regi = 0; regi < R_PC; regi++)
d515 2
a516 2
   (fpregset_t *), unpack the register contents and supply them as gdb's
   idea of the current floating point register values. */
d518 1
a518 1
void
d520 1
a520 1
     fpregset_t *fpregsetp;
d524 2
a525 2

  for (regi = FP0_REGNUM; regi < FPC_REGNUM; regi++)
d527 1
a527 1
      from = (char *) &(fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
d530 3
a532 3
  supply_register (FPC_REGNUM, (char *) &(fpregsetp->f_pcr));
  supply_register (FPS_REGNUM, (char *) &(fpregsetp->f_psr));
  supply_register (FPI_REGNUM, (char *) &(fpregsetp->f_fpiaddr));
d536 3
a538 3
   (fpregset_t *), update the register specified by REGNO from gdb's idea
   of the current floating point register set.  If REGNO is -1, update
   them all. */
d542 2
a543 2
     fpregset_t *fpregsetp;
     int regno;
d549 1
a549 1
  for (regi = FP0_REGNUM; regi < FPC_REGNUM; regi++)
d554 1
a554 1
	  to = (char *) &(fpregsetp->f_fpregs[regi - FP0_REGNUM][0]);
d560 1
a560 1
      fpregsetp->f_pcr = *(int *) &registers[REGISTER_BYTE (FPC_REGNUM)];
d564 1
a564 1
      fpregsetp->f_psr = *(int *) &registers[REGISTER_BYTE (FPS_REGNUM)];
d568 1
a568 1
      fpregsetp->f_fpiaddr = *(int *) &registers[REGISTER_BYTE (FPI_REGNUM)];
d572 1
a572 1
#endif /* defined (FP0_REGNUM) */
d574 1
a574 1
#endif /* USE_PROC_FS */
d583 1
a583 1
get_longjmp_target (pc)
d589 1
a589 1
  sp = read_register (SP_REGNUM);
d591 1
a591 1
  if (target_read_memory (sp + SP_ARG0,		/* Offset of first arg on stack */
d614 1
a614 1
m68k_saved_pc_after_call (frame)
@


1.1.1.6
log
@import gdb-1999-10-04 snapshot
@
text
@a637 1

@


