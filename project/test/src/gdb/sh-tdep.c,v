head	1.252;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.250
	gdb_7_6-2013-04-26-release:1.250
	gdb_7_6-branch:1.250.0.2
	gdb_7_6-2013-03-12-branchpoint:1.250
	gdb_7_5_1-2012-11-29-release:1.245
	gdb_7_5-2012-08-17-release:1.245
	gdb_7_5-branch:1.245.0.2
	gdb_7_5-2012-07-18-branchpoint:1.245
	gdb_7_4_1-2012-04-26-release:1.234.4.1
	gdb_7_4-2012-01-24-release:1.234.4.1
	gdb_7_4-branch:1.234.0.4
	gdb_7_4-2011-12-13-branchpoint:1.234
	gdb_7_3_1-2011-09-04-release:1.234
	gdb_7_3-2011-07-26-release:1.234
	gdb_7_3-branch:1.234.0.2
	gdb_7_3-2011-04-01-branchpoint:1.234
	gdb_7_2-2010-09-02-release:1.230
	gdb_7_2-branch:1.230.0.4
	gdb_7_2-2010-07-07-branchpoint:1.230
	gdb_7_1-2010-03-18-release:1.230
	gdb_7_1-branch:1.230.0.2
	gdb_7_1-2010-02-18-branchpoint:1.230
	gdb_7_0_1-2009-12-22-release:1.227
	gdb_7_0-2009-10-06-release:1.227
	gdb_7_0-branch:1.227.0.4
	gdb_7_0-2009-09-16-branchpoint:1.227
	arc-sim-20090309:1.214
	msnyder-checkpoint-072509-branch:1.227.0.2
	msnyder-checkpoint-072509-branchpoint:1.227
	arc-insight_6_8-branch:1.214.0.6
	arc-insight_6_8-branchpoint:1.214
	insight_6_8-branch:1.214.0.4
	insight_6_8-branchpoint:1.214
	reverse-20081226-branch:1.221.0.6
	reverse-20081226-branchpoint:1.221
	multiprocess-20081120-branch:1.221.0.4
	multiprocess-20081120-branchpoint:1.221
	reverse-20080930-branch:1.221.0.2
	reverse-20080930-branchpoint:1.221
	reverse-20080717-branch:1.217.0.2
	reverse-20080717-branchpoint:1.217
	msnyder-reverse-20080609-branch:1.216.0.2
	msnyder-reverse-20080609-branchpoint:1.216
	drow-reverse-20070409-branch:1.199.0.2
	drow-reverse-20070409-branchpoint:1.199
	gdb_6_8-2008-03-27-release:1.214
	gdb_6_8-branch:1.214.0.2
	gdb_6_8-2008-02-26-branchpoint:1.214
	gdb_6_7_1-2007-10-29-release:1.208
	gdb_6_7-2007-10-10-release:1.208
	gdb_6_7-branch:1.208.0.2
	gdb_6_7-2007-09-07-branchpoint:1.208
	insight_6_6-20070208-release:1.195
	gdb_6_6-2006-12-18-release:1.195
	gdb_6_6-branch:1.195.0.10
	gdb_6_6-2006-11-15-branchpoint:1.195
	insight_6_5-20061003-release:1.195
	gdb-csl-symbian-6_4_50_20060226-12:1.192
	gdb-csl-sourcerygxx-3_4_4-25:1.188
	nickrob-async-20060828-mergepoint:1.195
	gdb-csl-symbian-6_4_50_20060226-11:1.192
	gdb-csl-sourcerygxx-4_1-17:1.192
	gdb-csl-20060226-branch-local-2:1.192
	gdb-csl-sourcerygxx-4_1-14:1.192
	gdb-csl-sourcerygxx-4_1-13:1.192
	gdb-csl-sourcerygxx-4_1-12:1.192
	gdb-csl-sourcerygxx-3_4_4-21:1.192
	gdb_6_5-20060621-release:1.195
	gdb-csl-sourcerygxx-4_1-9:1.192
	gdb-csl-sourcerygxx-4_1-8:1.192
	gdb-csl-sourcerygxx-4_1-7:1.192
	gdb-csl-arm-2006q1-6:1.192
	gdb-csl-sourcerygxx-4_1-6:1.192
	gdb-csl-symbian-6_4_50_20060226-10:1.192
	gdb-csl-symbian-6_4_50_20060226-9:1.192
	gdb-csl-symbian-6_4_50_20060226-8:1.192
	gdb-csl-coldfire-4_1-11:1.192
	gdb-csl-sourcerygxx-3_4_4-19:1.192
	gdb-csl-coldfire-4_1-10:1.192
	gdb_6_5-branch:1.195.0.8
	gdb_6_5-2006-05-14-branchpoint:1.195
	gdb-csl-sourcerygxx-4_1-5:1.192
	nickrob-async-20060513-branch:1.195.0.6
	nickrob-async-20060513-branchpoint:1.195
	gdb-csl-sourcerygxx-4_1-4:1.192
	msnyder-reverse-20060502-branch:1.195.0.4
	msnyder-reverse-20060502-branchpoint:1.195
	gdb-csl-morpho-4_1-4:1.192
	gdb-csl-sourcerygxx-3_4_4-17:1.192
	readline_5_1-import-branch:1.195.0.2
	readline_5_1-import-branchpoint:1.195
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.192
	gdb-csl-symbian-20060226-branch:1.192.0.6
	gdb-csl-symbian-20060226-branchpoint:1.192
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.192
	msnyder-reverse-20060331-branch:1.193.0.2
	msnyder-reverse-20060331-branchpoint:1.193
	gdb-csl-available-20060303-branch:1.192.0.4
	gdb-csl-available-20060303-branchpoint:1.192
	gdb-csl-20060226-branch:1.192.0.2
	gdb-csl-20060226-branchpoint:1.192
	gdb_6_4-20051202-release:1.187
	msnyder-fork-checkpoint-branch:1.188.0.4
	msnyder-fork-checkpoint-branchpoint:1.188
	gdb-csl-gxxpro-6_3-branch:1.188.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.188
	gdb_6_4-branch:1.187.0.6
	gdb_6_4-2005-11-01-branchpoint:1.187
	gdb-csl-arm-20051020-branch:1.187.0.4
	gdb-csl-arm-20051020-branchpoint:1.187
	msnyder-tracepoint-checkpoint-branch:1.187.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.187
	gdb-csl-arm-20050325-2005-q1b:1.185
	gdb-csl-arm-20050325-2005-q1a:1.185
	csl-arm-20050325-branch:1.185.0.2
	csl-arm-20050325-branchpoint:1.185
	gdb-post-i18n-errorwarning-20050211:1.183
	gdb-pre-i18n-errorwarning-20050211:1.182
	gdb_6_3-20041109-release:1.177
	gdb_6_3-branch:1.177.0.2
	gdb_6_3-20041019-branchpoint:1.177
	drow_intercu-merge-20040921:1.173
	drow_intercu-merge-20040915:1.173
	jimb-gdb_6_2-e500-branch:1.170.0.6
	jimb-gdb_6_2-e500-branchpoint:1.170
	gdb_6_2-20040730-release:1.170
	gdb_6_2-branch:1.170.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.170
	gdb_6_1_1-20040616-release:1.165
	gdb_6_1-2004-04-05-release:1.165
	drow_intercu-merge-20040402:1.167
	drow_intercu-merge-20040327:1.167
	ezannoni_pie-20040323-branch:1.167.0.4
	ezannoni_pie-20040323-branchpoint:1.167
	cagney_tramp-20040321-mergepoint:1.167
	cagney_tramp-20040309-branch:1.167.0.2
	cagney_tramp-20040309-branchpoint:1.167
	gdb_6_1-branch:1.165.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.165
	drow_intercu-20040221-branch:1.165.0.2
	drow_intercu-20040221-branchpoint:1.165
	cagney_bfdfile-20040213-branch:1.158.0.2
	cagney_bfdfile-20040213-branchpoint:1.158
	drow-cplus-merge-20040208:1.156
	carlton_dictionary-20040126-merge:1.155
	cagney_bigcore-20040122-branch:1.155.0.2
	cagney_bigcore-20040122-branchpoint:1.155
	drow-cplus-merge-20040113:1.153
	drow-cplus-merge-20031224:1.153
	drow-cplus-merge-20031220:1.153
	carlton_dictionary-20031215-merge:1.153
	drow-cplus-merge-20031214:1.153
	carlton-dictionary-20031111-merge:1.153
	gdb_6_0-2003-10-04-release:1.132
	kettenis_sparc-20030918-branch:1.141.0.4
	kettenis_sparc-20030918-branchpoint:1.141
	carlton_dictionary-20030917-merge:1.141
	ezannoni_pie-20030916-branchpoint:1.141
	ezannoni_pie-20030916-branch:1.141.0.2
	cagney_x86i386-20030821-branch:1.136.0.2
	cagney_x86i386-20030821-branchpoint:1.136
	carlton_dictionary-20030805-merge:1.135
	carlton_dictionary-20030627-merge:1.132
	gdb_6_0-branch:1.132.0.4
	gdb_6_0-2003-06-23-branchpoint:1.132
	jimb-ppc64-linux-20030613-branch:1.132.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.132
	cagney_convert-20030606-branch:1.125.0.2
	cagney_convert-20030606-branchpoint:1.125
	cagney_writestrings-20030508-branch:1.122.0.4
	cagney_writestrings-20030508-branchpoint:1.122
	jimb-ppc64-linux-20030528-branch:1.124.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.124
	carlton_dictionary-20030523-merge:1.124
	cagney_fileio-20030521-branch:1.124.0.2
	cagney_fileio-20030521-branchpoint:1.124
	kettenis_i386newframe-20030517-mergepoint:1.124
	jimb-ppc64-linux-20030509-branch:1.122.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.122
	kettenis_i386newframe-20030504-mergepoint:1.119
	carlton_dictionary-20030430-merge:1.119
	kettenis_i386newframe-20030419-branch:1.117.0.2
	kettenis_i386newframe-20030419-branchpoint:1.117
	carlton_dictionary-20030416-merge:1.117
	cagney_frameaddr-20030409-mergepoint:1.116
	kettenis_i386newframe-20030406-branch:1.115.0.2
	kettenis_i386newframe-20030406-branchpoint:1.115
	cagney_frameaddr-20030403-branchpoint:1.114
	cagney_frameaddr-20030403-branch:1.114.0.2
	cagney_framebase-20030330-mergepoint:1.109
	cagney_framebase-20030326-branch:1.106.0.2
	cagney_framebase-20030326-branchpoint:1.106
	cagney_lazyid-20030317-branch:1.103.0.2
	cagney_lazyid-20030317-branchpoint:1.103
	kettenis-i386newframe-20030316-mergepoint:1.103
	offbyone-20030313-branch:1.101.0.2
	offbyone-20030313-branchpoint:1.101
	kettenis-i386newframe-20030308-branch:1.100.0.4
	kettenis-i386newframe-20030308-branchpoint:1.100
	carlton_dictionary-20030305-merge:1.100
	cagney_offbyone-20030303-branch:1.100.0.2
	cagney_offbyone-20030303-branchpoint:1.100
	carlton_dictionary-20030207-merge:1.96
	interps-20030203-mergepoint:1.96
	interps-20030202-branch:1.95.0.2
	interps-20030202-branchpoint:1.95
	cagney-unwind-20030108-branch:1.93.0.2
	cagney-unwind-20030108-branchpoint:1.93
	carlton_dictionary-20021223-merge:1.82
	gdb_5_3-2002-12-12-release:1.70
	carlton_dictionary-20021115-merge:1.76
	kseitz_interps-20021105-merge:1.75
	kseitz_interps-20021103-merge:1.75
	drow-cplus-merge-20021020:1.72
	drow-cplus-merge-20021025:1.72
	carlton_dictionary-20021025-merge:1.72
	carlton_dictionary-20021011-merge:1.72
	drow-cplus-branch:1.72.0.2
	drow-cplus-branchpoint:1.72
	kseitz_interps-20020930-merge:1.72
	carlton_dictionary-20020927-merge:1.71
	carlton_dictionary-branch:1.71.0.2
	carlton_dictionary-20020920-branchpoint:1.71
	gdb_5_3-branch:1.70.0.6
	gdb_5_3-2002-09-04-branchpoint:1.70
	kseitz_interps-20020829-merge:1.70
	cagney_sysregs-20020825-branch:1.70.0.4
	cagney_sysregs-20020825-branchpoint:1.70
	readline_4_3-import-branch:1.70.0.2
	readline_4_3-import-branchpoint:1.70
	gdb_5_2_1-2002-07-23-release:1.48
	kseitz_interps-20020528-branch:1.61.0.2
	kseitz_interps-20020528-branchpoint:1.61
	cagney_regbuf-20020515-branch:1.58.0.2
	cagney_regbuf-20020515-branchpoint:1.58
	jimb-macro-020506-branch:1.52.0.2
	jimb-macro-020506-branchpoint:1.52
	gdb_5_2-2002-04-29-release:1.48
	gdb_5_2-branch:1.48.0.2
	gdb_5_2-2002-03-03-branchpoint:1.48
	gdb_5_1_1-2002-01-24-release:1.38
	gdb_5_1_0_1-2002-01-03-release:1.38
	cygnus_cvs_20020108_pre:1.42
	gdb_5_1_0_1-2002-01-03-branchpoint:1.38
	gdb_5_1_0_1-2002-01-03-branch:1.38.0.6
	gdb_5_1-2001-11-21-release:1.38
	gdb_s390-2001-09-26-branch:1.38.0.4
	gdb_s390-2001-09-26-branchpoint:1.38
	gdb_5_1-2001-07-29-branch:1.38.0.2
	gdb_5_1-2001-07-29-branchpoint:1.38
	dberlin-typesystem-branch:1.35.0.2
	dberlin-typesystem-branchpoint:1.35
	gdb-post-ptid_t-2001-05-03:1.34
	gdb-pre-ptid_t-2001-05-03:1.34
	insight-precleanup-2001-01-01:1.25
	gdb-post-protoization-2000-07-29:1.13
	gdb-pre-protoization-2000-07-29:1.12
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.5
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.7
	gdb-2000-01-26:1.1.1.7
	gdb-2000-01-24:1.1.1.7
	gdb-2000-01-17:1.1.1.7
	gdb-2000-01-10:1.1.1.7
	gdb-2000-01-05:1.1.1.7
	gdb-1999-12-21:1.1.1.7
	gdb-1999-12-13:1.1.1.7
	gdb-1999-12-07:1.1.1.7
	gdb-1999-12-06:1.1.1.7
	gdb-1999-11-16:1.1.1.7
	gdb-1999-11-08:1.1.1.7
	gdb-1999-11-01:1.1.1.7
	gdb-1999-10-25:1.1.1.7
	gdb-1999-10-18:1.1.1.7
	gdb-1999-10-11:1.1.1.7
	gdb-1999-10-04:1.1.1.7
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.7
	gdb-1999-09-08:1.1.1.7
	gdb-1999-08-30:1.1.1.6
	gdb-1999-08-23:1.1.1.6
	gdb-1999-08-16:1.1.1.6
	gdb-1999-08-09:1.1.1.6
	gdb-1999-08-02:1.1.1.5
	gdb-1999-07-26:1.1.1.5
	gdb-1999-07-19:1.1.1.5
	gdb-1999-07-12:1.1.1.5
	gdb-post-reformat-19990707:1.1.1.5
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.5
	gdb-pre-reformat-19990707:1.1.1.4
	gdb-1999-07-07:1.1.1.4
	gdb-1999-07-05:1.1.1.3
	gdb-1999-06-28:1.1.1.3
	gdb-1999-06-21:1.1.1.3
	gdb-1999-06-14:1.1.1.3
	gdb-1999-06-07:1.1.1.3
	gdb-1999-06-01:1.1.1.3
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.3
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.252
date	2013.06.24.22.18.31;	author macro;	state Exp;
branches;
next	1.251;

1.251
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.250;

1.250
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.249;

1.249
date	2012.09.19.11.10.54;	author tschwinge;	state Exp;
branches;
next	1.248;

1.248
date	2012.09.19.11.09.16;	author tschwinge;	state Exp;
branches;
next	1.247;

1.247
date	2012.09.19.11.07.01;	author tschwinge;	state Exp;
branches;
next	1.246;

1.246
date	2012.07.22.16.52.41;	author siddhesh;	state Exp;
branches;
next	1.245;

1.245
date	2012.06.08.14.24.57;	author qiyao;	state Exp;
branches;
next	1.244;

1.244
date	2012.06.06.18.03.53;	author tschwinge;	state Exp;
branches;
next	1.243;

1.243
date	2012.05.16.14.35.07;	author macro;	state Exp;
branches;
next	1.242;

1.242
date	2012.03.05.15.16.39;	author tschwinge;	state Exp;
branches;
next	1.241;

1.241
date	2012.03.03.01.27.47;	author kevinb;	state Exp;
branches;
next	1.240;

1.240
date	2012.03.01.23.55.39;	author jkratoch;	state Exp;
branches;
next	1.239;

1.239
date	2012.02.27.16.40.48;	author tschwinge;	state Exp;
branches;
next	1.238;

1.238
date	2012.02.24.11.00.07;	author tschwinge;	state Exp;
branches;
next	1.237;

1.237
date	2012.02.17.08.39.57;	author tschwinge;	state Exp;
branches;
next	1.236;

1.236
date	2012.01.28.18.08.20;	author jkratoch;	state Exp;
branches;
next	1.235;

1.235
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.234;

1.234
date	2011.03.18.18.52.32;	author palves;	state Exp;
branches
	1.234.4.1;
next	1.233;

1.233
date	2011.03.18.18.38.43;	author palves;	state Exp;
branches;
next	1.232;

1.232
date	2011.01.11.21.53.23;	author msnyder;	state Exp;
branches;
next	1.231;

1.231
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.230;

1.230
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.229;

1.229
date	2009.10.21.14.14.56;	author ams;	state Exp;
branches;
next	1.228;

1.228
date	2009.10.14.10.17.31;	author ams;	state Exp;
branches;
next	1.227;

1.227
date	2009.07.10.15.27.02;	author tromey;	state Exp;
branches;
next	1.226;

1.226
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.225;

1.225
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.224;

1.224
date	2009.07.02.12.18.46;	author uweigand;	state Exp;
branches;
next	1.223;

1.223
date	2009.02.22.01.02.19;	author palves;	state Exp;
branches;
next	1.222;

1.222
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.221;

1.221
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.220;

1.220
date	2008.09.11.14.22.32;	author uweigand;	state Exp;
branches;
next	1.219;

1.219
date	2008.09.05.11.43.10;	author uweigand;	state Exp;
branches;
next	1.218;

1.218
date	2008.08.24.16.39.57;	author tromey;	state Exp;
branches;
next	1.217;

1.217
date	2008.06.28.17.29.03;	author uweigand;	state Exp;
branches;
next	1.216;

1.216
date	2008.04.30.21.18.28;	author drow;	state Exp;
branches;
next	1.215;

1.215
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.214;

1.214
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.213;

1.213
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.212;

1.212
date	2007.11.19.05.06.24;	author deuling;	state Exp;
branches;
next	1.211;

1.211
date	2007.11.07.06.33.01;	author deuling;	state Exp;
branches;
next	1.210;

1.210
date	2007.11.02.14.27.15;	author uweigand;	state Exp;
branches;
next	1.209;

1.209
date	2007.10.08.12.56.03;	author uweigand;	state Exp;
branches;
next	1.208;

1.208
date	2007.08.23.18.08.37;	author brobecke;	state Exp;
branches;
next	1.207;

1.207
date	2007.06.18.17.56.32;	author uweigand;	state Exp;
branches;
next	1.206;

1.206
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.205;

1.205
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.204;

1.204
date	2007.06.15.22.32.02;	author uweigand;	state Exp;
branches;
next	1.203;

1.203
date	2007.06.15.22.31.01;	author uweigand;	state Exp;
branches;
next	1.202;

1.202
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.201;

1.201
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.200;

1.200
date	2007.05.06.19.37.30;	author uweigand;	state Exp;
branches;
next	1.199;

1.199
date	2007.03.27.19.11.10;	author uweigand;	state Exp;
branches;
next	1.198;

1.198
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.197;

1.197
date	2007.01.21.17.37.51;	author drow;	state Exp;
branches;
next	1.196;

1.196
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.195;

1.195
date	2006.04.05.20.01.19;	author davem;	state Exp;
branches;
next	1.194;

1.194
date	2006.04.03.14.31.14;	author ams;	state Exp;
branches;
next	1.193;

1.193
date	2006.03.27.13.15.01;	author ams;	state Exp;
branches;
next	1.192;

1.192
date	2006.02.21.16.08.26;	author ams;	state Exp;
branches;
next	1.191;

1.191
date	2006.01.23.17.35.22;	author ams;	state Exp;
branches;
next	1.190;

1.190
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.189;

1.189
date	2005.11.23.16.30.36;	author ams;	state Exp;
branches;
next	1.188;

1.188
date	2005.11.02.15.22.24;	author ams;	state Exp;
branches;
next	1.187;

1.187
date	2005.04.27.20.48.25;	author kettenis;	state Exp;
branches;
next	1.186;

1.186
date	2005.04.15.08.01.14;	author corinna;	state Exp;
branches;
next	1.185;

1.185
date	2005.02.15.15.49.19;	author cagney;	state Exp;
branches;
next	1.184;

1.184
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.183;

1.183
date	2005.02.11.04.06.04;	author cagney;	state Exp;
branches;
next	1.182;

1.182
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.181;

1.181
date	2004.12.14.15.40.17;	author corinna;	state Exp;
branches;
next	1.180;

1.180
date	2004.11.13.02.15.33;	author cagney;	state Exp;
branches;
next	1.179;

1.179
date	2004.10.29.20.23.11;	author cagney;	state Exp;
branches;
next	1.178;

1.178
date	2004.10.29.14.00.56;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2004.10.06.08.59.02;	author corinna;	state Exp;
branches;
next	1.176;

1.176
date	2004.10.06.08.57.38;	author corinna;	state Exp;
branches;
next	1.175;

1.175
date	2004.10.06.08.56.40;	author corinna;	state Exp;
branches;
next	1.174;

1.174
date	2004.10.06.08.55.36;	author corinna;	state Exp;
branches;
next	1.173;

1.173
date	2004.09.03.17.13.47;	author cagney;	state Exp;
branches;
next	1.172;

1.172
date	2004.08.02.19.44.40;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2004.08.01.21.38.03;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2004.06.20.17.18.06;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2004.06.07.02.02.54;	author tausq;	state Exp;
branches;
next	1.168;

1.168
date	2004.06.03.11.46.34;	author corinna;	state Exp;
branches;
next	1.167;

1.167
date	2004.03.08.10.18.13;	author corinna;	state Exp;
branches;
next	1.166;

1.166
date	2004.03.08.10.15.33;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2004.02.20.00.16.16;	author fnf;	state Exp;
branches
	1.165.2.1;
next	1.164;

1.164
date	2004.02.19.23.05.07;	author fnf;	state Exp;
branches;
next	1.163;

1.163
date	2004.02.17.16.04.19;	author corinna;	state Exp;
branches;
next	1.162;

1.162
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches;
next	1.161;

1.161
date	2004.02.16.16.52.28;	author corinna;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.16.16.04.18;	author corinna;	state Exp;
branches;
next	1.159;

1.159
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches;
next	1.158;

1.158
date	2004.02.11.15.40.28;	author cagney;	state Exp;
branches;
next	1.157;

1.157
date	2004.02.11.15.36.09;	author corinna;	state Exp;
branches;
next	1.156;

1.156
date	2004.01.26.20.52.12;	author cagney;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.17.15.34.12;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.13.21.38.47;	author cagney;	state Exp;
branches;
next	1.153;

1.153
date	2003.11.03.17.08.23;	author corinna;	state Exp;
branches;
next	1.152;

1.152
date	2003.10.14.15.35.43;	author corinna;	state Exp;
branches;
next	1.151;

1.151
date	2003.10.10.20.30.45;	author corinna;	state Exp;
branches;
next	1.150;

1.150
date	2003.10.10.19.20.31;	author ezannoni;	state Exp;
branches;
next	1.149;

1.149
date	2003.10.10.19.14.08;	author corinna;	state Exp;
branches;
next	1.148;

1.148
date	2003.10.10.07.13.10;	author ksakamot;	state Exp;
branches;
next	1.147;

1.147
date	2003.10.10.03.14.08;	author cagney;	state Exp;
branches;
next	1.146;

1.146
date	2003.10.09.20.23.41;	author ezannoni;	state Exp;
branches;
next	1.145;

1.145
date	2003.10.03.08.13.37;	author corinna;	state Exp;
branches;
next	1.144;

1.144
date	2003.10.02.10.47.05;	author corinna;	state Exp;
branches;
next	1.143;

1.143
date	2003.10.02.10.45.02;	author corinna;	state Exp;
branches;
next	1.142;

1.142
date	2003.09.25.08.55.53;	author corinna;	state Exp;
branches;
next	1.141;

1.141
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.140;

1.140
date	2003.09.16.15.56.03;	author corinna;	state Exp;
branches;
next	1.139;

1.139
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.138;

1.138
date	2003.09.12.18.40.18;	author cagney;	state Exp;
branches;
next	1.137;

1.137
date	2003.09.08.11.26.20;	author corinna;	state Exp;
branches;
next	1.136;

1.136
date	2003.08.21.00.01.31;	author msnyder;	state Exp;
branches;
next	1.135;

1.135
date	2003.08.01.19.52.49;	author msnyder;	state Exp;
branches;
next	1.134;

1.134
date	2003.07.16.09.45.56;	author corinna;	state Exp;
branches;
next	1.133;

1.133
date	2003.07.09.22.23.57;	author msnyder;	state Exp;
branches;
next	1.132;

1.132
date	2003.06.13.04.40.34;	author cagney;	state Exp;
branches;
next	1.131;

1.131
date	2003.06.11.19.38.27;	author cagney;	state Exp;
branches;
next	1.130;

1.130
date	2003.06.11.13.16.29;	author cagney;	state Exp;
branches;
next	1.129;

1.129
date	2003.06.09.17.35.58;	author cagney;	state Exp;
branches;
next	1.128;

1.128
date	2003.06.07.22.38.56;	author cagney;	state Exp;
branches;
next	1.127;

1.127
date	2003.06.07.18.08.24;	author cagney;	state Exp;
branches;
next	1.126;

1.126
date	2003.06.07.16.23.12;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2003.06.02.02.09.39;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2003.05.17.05.59.59;	author cagney;	state Exp;
branches;
next	1.123;

1.123
date	2003.05.13.19.27.28;	author cagney;	state Exp;
branches;
next	1.122;

1.122
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches
	1.122.4.1;
next	1.121;

1.121
date	2003.05.08.20.52.48;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2003.05.05.17.56.55;	author cagney;	state Exp;
branches;
next	1.119;

1.119
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.118;

1.118
date	2003.04.21.16.48.39;	author cagney;	state Exp;
branches;
next	1.117;

1.117
date	2003.04.11.18.15.39;	author cagney;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2003.04.09.15.08.26;	author cagney;	state Exp;
branches;
next	1.115;

1.115
date	2003.04.05.18.54.38;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.04.01.17.17.29;	author cagney;	state Exp;
branches
	1.114.2.1;
next	1.113;

1.113
date	2003.04.01.14.38.50;	author cagney;	state Exp;
branches;
next	1.112;

1.112
date	2003.03.31.23.52.38;	author cagney;	state Exp;
branches;
next	1.111;

1.111
date	2003.03.31.21.58.22;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.03.31.19.01.21;	author cagney;	state Exp;
branches;
next	1.109;

1.109
date	2003.03.30.14.59.01;	author cagney;	state Exp;
branches;
next	1.108;

1.108
date	2003.03.30.14.32.09;	author cagney;	state Exp;
branches;
next	1.107;

1.107
date	2003.03.26.22.39.52;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.03.25.20.38.46;	author cagney;	state Exp;
branches
	1.106.2.1;
next	1.105;

1.105
date	2003.03.25.18.54.16;	author cagney;	state Exp;
branches;
next	1.104;

1.104
date	2003.03.24.03.54.48;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.03.14.16.05.36;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.03.13.21.45.41;	author cagney;	state Exp;
branches;
next	1.101;

1.101
date	2003.03.12.16.50.45;	author cagney;	state Exp;
branches;
next	1.100;

1.100
date	2003.03.03.20.50.20;	author cagney;	state Exp;
branches
	1.100.4.1;
next	1.99;

1.99
date	2003.03.02.04.02.24;	author cagney;	state Exp;
branches;
next	1.98;

1.98
date	2003.03.02.00.11.43;	author cagney;	state Exp;
branches;
next	1.97;

1.97
date	2003.02.27.17.48.47;	author cagney;	state Exp;
branches;
next	1.96;

1.96
date	2003.02.03.14.38.05;	author nickc;	state Exp;
branches;
next	1.95;

1.95
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2003.01.21.19.43.47;	author cagney;	state Exp;
branches;
next	1.93;

1.93
date	2003.01.08.19.45.23;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.01.08.17.21.30;	author cagney;	state Exp;
branches;
next	1.91;

1.91
date	2003.01.08.15.56.37;	author cagney;	state Exp;
branches;
next	1.90;

1.90
date	2003.01.08.01.53.37;	author cagney;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.07.14.51.10;	author cagney;	state Exp;
branches;
next	1.88;

1.88
date	2003.01.05.01.39.55;	author drow;	state Exp;
branches;
next	1.87;

1.87
date	2003.01.04.23.38.45;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2003.01.04.22.37.47;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2003.01.03.23.53.48;	author cagney;	state Exp;
branches;
next	1.84;

1.84
date	2003.01.03.18.23.01;	author cagney;	state Exp;
branches;
next	1.83;

1.83
date	2003.01.02.22.20.46;	author cagney;	state Exp;
branches;
next	1.82;

1.82
date	2002.12.11.02.26.36;	author cagney;	state Exp;
branches;
next	1.81;

1.81
date	2002.12.01.19.07.15;	author cagney;	state Exp;
branches;
next	1.80;

1.80
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.79;

1.79
date	2002.11.28.18.15.59;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.11.24.19.48.13;	author cagney;	state Exp;
branches;
next	1.77;

1.77
date	2002.11.23.01.39.25;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.14.00.25.03;	author cagney;	state Exp;
branches;
next	1.75;

1.75
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.74;

1.74
date	2002.11.01.21.21.49;	author cagney;	state Exp;
branches;
next	1.73;

1.73
date	2002.10.26.17.19.27;	author cagney;	state Exp;
branches;
next	1.72;

1.72
date	2002.09.28.16.11.29;	author corinna;	state Exp;
branches
	1.72.2.1;
next	1.71;

1.71
date	2002.09.17.20.42.01;	author cagney;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2002.08.24.00.21.35;	author cagney;	state Exp;
branches;
next	1.69;

1.69
date	2002.08.02.14.48.19;	author cagney;	state Exp;
branches;
next	1.68;

1.68
date	2002.07.29.16.34.06;	author cagney;	state Exp;
branches;
next	1.67;

1.67
date	2002.07.24.14.38.55;	author cagney;	state Exp;
branches;
next	1.66;

1.66
date	2002.07.17.18.43.28;	author amylaar;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.26.15.28.46;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.20.03.13.51;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.17.23.32.33;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.14.22.55.40;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.21.15.36.02;	author thorpej;	state Exp;
branches
	1.61.2.1;
next	1.60;

1.60
date	2002.05.17.14.36.44;	author amylaar;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.17.06.55.48;	author thorpej;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.10.23.59.09;	author ezannoni;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2002.05.10.23.22.10;	author ezannoni;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.10.23.00.22;	author ezannoni;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.10.22.20.18;	author ezannoni;	state Exp;
branches;
next	1.54;

1.54
date	2002.05.08.14.54.02;	author thorpej;	state Exp;
branches;
next	1.53;

1.53
date	2002.05.07.21.51.34;	author thorpej;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.12.18.18.57;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2002.04.07.22.13.20;	author ezannoni;	state Exp;
branches;
next	1.50;

1.50
date	2002.04.06.00.02.50;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.19.02.51.07;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.08.03.01.11;	author ezannoni;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.23.04.00.55;	author ezannoni;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.22.00.22.38;	author ezannoni;	state Exp;
branches;
next	1.45;

1.45
date	2002.01.20.18.05.51;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.12.16.38.47;	author ezannoni;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.12.16.29.44;	author ezannoni;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.05.04.30.19;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.15.16.53.23;	author cagney;	state Exp;
branches;
next	1.40;

1.40
date	2001.09.05.23.44.44;	author ezannoni;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2001.07.27.03.29.08;	author ezannoni;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.15.20.10.02;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.12.02.29.33;	author ezannoni;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.09.17.51.01;	author ezannoni;	state Exp;
branches;
next	1.34;

1.34
date	2001.04.30.20.57.31;	author ezannoni;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.28.21.42.31;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.06.08.21.16;	author kevinb;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.06.02.00.44;	author ezannoni;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.02.23.51.35;	author msnyder;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.02.20.49.18;	author msnyder;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.02.20.21.53;	author msnyder;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.19.23.20.45;	author ezannoni;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.19.15.41.07;	author ezannoni;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.18.04.36.35;	author ezannoni;	state Exp;
branches;
next	1.22;

1.22
date	2000.12.15.21.44.34;	author ezannoni;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.15.20.54.23;	author ezannoni;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.11.21.34.27;	author msnyder;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.11.21.04.04;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.07.16.40.44;	author ezannoni;	state Exp;
branches;
next	1.17;

1.17
date	2000.12.05.17.50.28;	author ezannoni;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.31.19.35.03;	author msnyder;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.30.21.50.58;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.31.16.25.36;	author ezannoni;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.30.01.48.27;	author kevinb;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.28.15.16.16;	author ezannoni;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.26.23.04.44;	author ezannoni;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.24.20.39.21;	author ezannoni;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.19.14.11.41;	author ezannoni;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.10.14.43.36;	author ezannoni;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.03.18.59.36;	author ezannoni;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.07.04.38.02;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.15.21.12.42;	author amylaar;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.20.07.28.05;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.24.03.31.45;	author cgf;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.14.18.43.48;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.234.4.1
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.165.2.1
date	2004.03.27.17.37.51;	author drow;	state Exp;
branches;
next	1.165.2.2;

1.165.2.2
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.122.4.1
date	2003.06.03.20.54.39;	author cagney;	state Exp;
branches;
next	;

1.117.2.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2003.05.18.09.44.20;	author kettenis;	state Exp;
branches;
next	;

1.114.2.1
date	2003.04.10.21.33.50;	author cagney;	state Exp;
branches;
next	;

1.106.2.1
date	2003.03.30.16.35.22;	author cagney;	state Exp;
branches;
next	;

1.100.4.1
date	2003.03.16.14.01.51;	author kettenis;	state Exp;
branches;
next	;

1.95.2.1
date	2003.02.03.22.00.56;	author cagney;	state Exp;
branches;
next	;

1.72.2.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	2004.02.09.19.43.47;	author drow;	state Exp;
branches;
next	;

1.71.2.1
date	2002.10.11.22.22.56;	author carlton;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2002.11.15.19.18.55;	author carlton;	state Exp;
branches;
next	1.71.2.3;

1.71.2.3
date	2002.12.23.19.38.41;	author carlton;	state Exp;
branches;
next	1.71.2.4;

1.71.2.4
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.71.2.5;

1.71.2.5
date	2003.03.06.00.56.31;	author carlton;	state Exp;
branches;
next	1.71.2.6;

1.71.2.6
date	2003.04.16.19.56.54;	author carlton;	state Exp;
branches;
next	1.71.2.7;

1.71.2.7
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.71.2.8;

1.71.2.8
date	2003.05.23.18.40.44;	author carlton;	state Exp;
branches;
next	1.71.2.9;

1.71.2.9
date	2003.06.27.21.50.08;	author carlton;	state Exp;
branches;
next	1.71.2.10;

1.71.2.10
date	2003.08.05.17.13.13;	author carlton;	state Exp;
branches;
next	1.71.2.11;

1.71.2.11
date	2003.09.17.21.28.31;	author carlton;	state Exp;
branches;
next	1.71.2.12;

1.71.2.12
date	2003.11.11.23.50.54;	author carlton;	state Exp;
branches;
next	1.71.2.13;

1.71.2.13
date	2004.01.26.19.11.30;	author carlton;	state Exp;
branches;
next	;

1.61.2.1
date	2002.06.20.01.33.00;	author kseitz;	state Exp;
branches;
next	1.61.2.2;

1.61.2.2
date	2002.07.22.21.47.02;	author kseitz;	state Exp;
branches;
next	1.61.2.3;

1.61.2.3
date	2002.08.09.18.34.26;	author kseitz;	state Exp;
branches;
next	1.61.2.4;

1.61.2.4
date	2002.08.30.22.52.45;	author kseitz;	state Exp;
branches;
next	1.61.2.5;

1.61.2.5
date	2002.10.01.00.46.14;	author kseitz;	state Exp;
branches;
next	1.61.2.6;

1.61.2.6
date	2002.11.04.00.17.32;	author ezannoni;	state Exp;
branches;
next	;

1.58.2.1
date	2002.06.15.16.42.54;	author cagney;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2002.06.21.16.19.31;	author cagney;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2002.06.28.23.19.26;	author cagney;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.16;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.05.25.18.03.18;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.17.23.07;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.07.07.20.09.54;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.08.09.21.33.53;	author jsm;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.08.23.59.30;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.252
log
@	* objfiles.h (pc_in_section): New prototype.
	(in_plt_section): Remove name argument, replace prototype with
	static inline function.
	* mips-tdep.h: Include "objfiles.h".
	(in_mips_stubs_section): New function.
	* hppa-tdep.h (gdbarch_tdep): Remove name argument of
	in_solib_call_trampoline member.
	(hppa_in_solib_call_trampoline): Remove name argument.
	* objfiles.c (pc_in_section): New function.
	(in_plt_section): Remove function.
	* mips-linux-tdep.c: Include "objfiles.h".
	(mips_linux_in_dynsym_stub): Call in_mips_stubs_section.  Remove
	name argument.  Return 1 rather than the low 16-bit halfword of
	any instruction examined.
	(mips_linux_in_dynsym_resolve_code): Update
	mips_linux_in_dynsym_stub call accordingly.
	* mips-tdep.c (mips_stub_frame_sniffer): Use in_mips_stubs_section
	rather than an equivalent hand-coded sequence.
	* hppa-hpux-tdep.c (in_opd_section): Remove function.
	(hppa32_hpux_in_solib_call_trampoline): Remove name argument.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.
	(hppa64_hpux_find_global_pointer): Use pc_in_section rather than
	in_opd_section.
	* hppa-tdep.c (hppa_stub_unwind_sniffer): Remove name argument
	on call to tdep->in_solib_call_trampoline.
	(hppa_in_solib_call_trampoline): Remove name argument, update
	according to in_plt_section change.
	(hppa_skip_trampoline_code): Update according to in_plt_section
	change.
	* aarch64-tdep.c (aarch64_stub_unwind_sniffer): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code):
	Likewise.
	* arm-tdep.c (arm_stub_unwind_sniffer): Likewise.
	* hppa-linux-tdep.c (hppa_linux_find_global_pointer): Likewise.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Likewise.
	* nios2-tdep.c (nios2_stub_frame_sniffer): Likewise.
	* nto-tdep.c (nto_relocate_section_addresses): Likewise.
	* s390-tdep.c (s390_stub_frame_sniffer): Likewise.
	* sh-tdep.c (sh_stub_unwind_sniffer): Likewise.
	* solib-dsbt.c (dsbt_in_dynsym_resolve_code): Likewise.
	* solib-frv.c (frv_in_dynsym_resolve_code): Likewise.
	* solib-svr4.c (svr4_in_dynsym_resolve_code): Likewise.
	* solib-target.c (solib_target_in_dynsym_resolve_code): Likewise.
	* sparc-tdep.c (sparc_analyze_prologue): Likewise.
	* tic6x-tdep.c (tic6x_stub_unwind_sniffer): Likewise.
@
text
@/* Target-dependent code for Renesas Super-H, for GDB.

   Copyright (C) 1993-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Contributed by Steve Chamberlain
   sac@@cygnus.com.  */

#include "defs.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "dwarf2-frame.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "value.h"
#include "dis-asm.h"
#include "inferior.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "arch-utils.h"
#include "floatformat.h"
#include "regcache.h"
#include "doublest.h"
#include "osabi.h"
#include "reggroups.h"
#include "regset.h"
#include "objfiles.h"

#include "sh-tdep.h"
#include "sh64-tdep.h"

#include "elf-bfd.h"
#include "solib-svr4.h"

/* sh flags */
#include "elf/sh.h"
#include "dwarf2.h"
/* registers numbers shared with the simulator.  */
#include "gdb/sim-sh.h"

/* List of "set sh ..." and "show sh ..." commands.  */
static struct cmd_list_element *setshcmdlist = NULL;
static struct cmd_list_element *showshcmdlist = NULL;

static const char sh_cc_gcc[] = "gcc";
static const char sh_cc_renesas[] = "renesas";
static const char *const sh_cc_enum[] = {
  sh_cc_gcc,
  sh_cc_renesas, 
  NULL
};

static const char *sh_active_calling_convention = sh_cc_gcc;

#define SH_NUM_REGS 67

struct sh_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  LONGEST sp_offset;
  CORE_ADDR pc;

  /* Flag showing that a frame has been created in the prologue code.  */
  int uses_fp;

  /* Saved registers.  */
  CORE_ADDR saved_regs[SH_NUM_REGS];
  CORE_ADDR saved_sp;
};

static int
sh_is_renesas_calling_convention (struct type *func_type)
{
  int val = 0;

  if (func_type)
    {
      func_type = check_typedef (func_type);

      if (TYPE_CODE (func_type) == TYPE_CODE_PTR)
        func_type = check_typedef (TYPE_TARGET_TYPE (func_type));

      if (TYPE_CODE (func_type) == TYPE_CODE_FUNC
          && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GNU_renesas_sh)
        val = 1;
    }

  if (sh_active_calling_convention == sh_cc_renesas)
    val = 1;

  return val;
}

static const char *
sh_sh_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh3_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "ssr", "spc",
    "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1"
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh3e_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "fpul", "fpscr",
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr", "spc",
    "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh2e_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "fpul", "fpscr",
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh2a_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    /* general registers 0-15 */
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    /* 16 - 22 */
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    /* 23, 24 */
    "fpul", "fpscr",
    /* floating point registers 25 - 40 */
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    /* 41, 42 */
    "", "",
    /* 43 - 62.  Banked registers.  The bank number used is determined by
       the bank register (63).  */
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
    "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b",
    "machb", "ivnb", "prb", "gbrb", "maclb",
    /* 63: register bank number, not a real register but used to
       communicate the register bank currently get/set.  This register
       is hidden to the user, who manipulates it using the pseudo
       register called "bank" (67).  See below.  */
    "",
    /* 64 - 66 */
    "ibcr", "ibnr", "tbr",
    /* 67: register bank number, the user visible pseudo register.  */
    "bank",
    /* double precision (pseudo) 68 - 75 */
    "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh2a_nofpu_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    /* general registers 0-15 */
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    /* 16 - 22 */
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    /* 23, 24 */
    "", "",
    /* floating point registers 25 - 40 */
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    /* 41, 42 */
    "", "",
    /* 43 - 62.  Banked registers.  The bank number used is determined by
       the bank register (63).  */
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
    "r8b", "r9b", "r10b", "r11b", "r12b", "r13b", "r14b",
    "machb", "ivnb", "prb", "gbrb", "maclb",
    /* 63: register bank number, not a real register but used to
       communicate the register bank currently get/set.  This register
       is hidden to the user, who manipulates it using the pseudo
       register called "bank" (67).  See below.  */
    "",
    /* 64 - 66 */
    "ibcr", "ibnr", "tbr",
    /* 67: register bank number, the user visible pseudo register.  */
    "bank",
    /* double precision (pseudo) 68 - 75 */
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh_dsp_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "", "",
    "rs", "re", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh3_dsp_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "ssr", "spc",
    "rs", "re", "", "", "", "", "", "",
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh4_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    /* general registers 0-15 */
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    /* 16 - 22 */
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    /* 23, 24 */
    "fpul", "fpscr",
    /* floating point registers 25 - 40 */
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    /* 41, 42 */
    "ssr", "spc",
    /* bank 0 43 - 50 */
    "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
    /* bank 1 51 - 58 */
    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
    /* 59 - 66 */
    "", "", "", "", "", "", "", "",
    /* pseudo bank register.  */
    "",
    /* double precision (pseudo) 68 - 75 */
    "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
    /* vectors (pseudo) 76 - 79 */
    "fv0", "fv4", "fv8", "fv12",
    /* FIXME: missing XF */
    /* FIXME: missing XD */
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh4_nofpu_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    /* general registers 0-15 */
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    /* 16 - 22 */
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    /* 23, 24 */
    "", "",
    /* floating point registers 25 - 40 -- not for nofpu target */
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    /* 41, 42 */
    "ssr", "spc",
    /* bank 0 43 - 50 */
    "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
    /* bank 1 51 - 58 */
    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
    /* 59 - 66 */
    "", "", "", "", "", "", "", "",
    /* pseudo bank register.  */
    "",
    /* double precision (pseudo) 68 - 75 -- not for nofpu target */
    "", "", "", "", "", "", "", "",
    /* vectors (pseudo) 76 - 79 -- not for nofpu target */
    "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh4al_dsp_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "ssr", "spc",
    "rs", "re", "", "", "", "", "", "",
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const unsigned char *
sh_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
{
  /* 0xc3c3 is trapa #c3, and it works in big and little endian modes.  */
  static unsigned char breakpoint[] = { 0xc3, 0xc3 };

  /* For remote stub targets, trapa #20 is used.  */
  if (strcmp (target_shortname, "remote") == 0)
    {
      static unsigned char big_remote_breakpoint[] = { 0xc3, 0x20 };
      static unsigned char little_remote_breakpoint[] = { 0x20, 0xc3 };

      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	{
	  *lenptr = sizeof (big_remote_breakpoint);
	  return big_remote_breakpoint;
	}
      else
	{
	  *lenptr = sizeof (little_remote_breakpoint);
	  return little_remote_breakpoint;
	}
    }

  *lenptr = sizeof (breakpoint);
  return breakpoint;
}

/* Prologue looks like
   mov.l	r14,@@-r15
   sts.l	pr,@@-r15
   mov.l	<regs>,@@-r15
   sub		<room_for_loca_vars>,r15
   mov		r15,r14

   Actually it can be more complicated than this but that's it, basically.  */

#define GET_SOURCE_REG(x)  	(((x) >> 4) & 0xf)
#define GET_TARGET_REG(x)  	(((x) >> 8) & 0xf)

/* JSR @@Rm         0100mmmm00001011 */
#define IS_JSR(x)		(((x) & 0xf0ff) == 0x400b)

/* STS.L PR,@@-r15  0100111100100010
   r15-4-->r15, PR-->(r15) */
#define IS_STS(x)  		((x) == 0x4f22)

/* STS.L MACL,@@-r15  0100111100010010
   r15-4-->r15, MACL-->(r15) */
#define IS_MACL_STS(x)  	((x) == 0x4f12)

/* MOV.L Rm,@@-r15  00101111mmmm0110
   r15-4-->r15, Rm-->(R15) */
#define IS_PUSH(x) 		(((x) & 0xff0f) == 0x2f06)

/* MOV r15,r14     0110111011110011
   r15-->r14  */
#define IS_MOV_SP_FP(x)  	((x) == 0x6ef3)

/* ADD #imm,r15    01111111iiiiiiii
   r15+imm-->r15 */
#define IS_ADD_IMM_SP(x) 	(((x) & 0xff00) == 0x7f00)

#define IS_MOV_R3(x) 		(((x) & 0xff00) == 0x1a00)
#define IS_SHLL_R3(x)		((x) == 0x4300)

/* ADD r3,r15      0011111100111100
   r15+r3-->r15 */
#define IS_ADD_R3SP(x)		((x) == 0x3f3c)

/* FMOV.S FRm,@@-Rn  Rn-4-->Rn, FRm-->(Rn)     1111nnnnmmmm1011
   FMOV DRm,@@-Rn    Rn-8-->Rn, DRm-->(Rn)     1111nnnnmmm01011
   FMOV XDm,@@-Rn    Rn-8-->Rn, XDm-->(Rn)     1111nnnnmmm11011 */
/* CV, 2003-08-28: Only suitable with Rn == SP, therefore name changed to
		   make this entirely clear.  */
/* #define IS_FMOV(x)		(((x) & 0xf00f) == 0xf00b) */
#define IS_FPUSH(x)		(((x) & 0xff0f) == 0xff0b)

/* MOV Rm,Rn          Rm-->Rn        0110nnnnmmmm0011  4 <= m <= 7 */
#define IS_MOV_ARG_TO_REG(x) \
	(((x) & 0xf00f) == 0x6003 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)
/* MOV.L Rm,@@Rn               0010nnnnmmmm0010  n = 14, 4 <= m <= 7 */
#define IS_MOV_ARG_TO_IND_R14(x) \
	(((x) & 0xff0f) == 0x2e02 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)
/* MOV.L Rm,@@(disp*4,Rn)      00011110mmmmdddd  n = 14, 4 <= m <= 7 */
#define IS_MOV_ARG_TO_IND_R14_WITH_DISP(x) \
	(((x) & 0xff00) == 0x1e00 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)

/* MOV.W @@(disp*2,PC),Rn      1001nnnndddddddd */
#define IS_MOVW_PCREL_TO_REG(x)	(((x) & 0xf000) == 0x9000)
/* MOV.L @@(disp*4,PC),Rn      1101nnnndddddddd */
#define IS_MOVL_PCREL_TO_REG(x)	(((x) & 0xf000) == 0xd000)
/* MOVI20 #imm20,Rn           0000nnnniiii0000 */
#define IS_MOVI20(x)		(((x) & 0xf00f) == 0x0000)
/* SUB Rn,R15                 00111111nnnn1000 */
#define IS_SUB_REG_FROM_SP(x)	(((x) & 0xff0f) == 0x3f08)

#define FPSCR_SZ		(1 << 20)

/* The following instructions are used for epilogue testing.  */
#define IS_RESTORE_FP(x)	((x) == 0x6ef6)
#define IS_RTS(x)		((x) == 0x000b)
#define IS_LDS(x)  		((x) == 0x4f26)
#define IS_MACL_LDS(x)  	((x) == 0x4f16)
#define IS_MOV_FP_SP(x)  	((x) == 0x6fe3)
#define IS_ADD_REG_TO_FP(x)	(((x) & 0xff0f) == 0x3e0c)
#define IS_ADD_IMM_FP(x) 	(((x) & 0xff00) == 0x7e00)

static CORE_ADDR
sh_analyze_prologue (struct gdbarch *gdbarch,
		     CORE_ADDR pc, CORE_ADDR limit_pc,
		     struct sh_frame_cache *cache, ULONGEST fpscr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST inst;
  int offset;
  int sav_offset = 0;
  int r3_val = 0;
  int reg, sav_reg = -1;

  cache->uses_fp = 0;
  for (; pc < limit_pc; pc += 2)
    {
      inst = read_memory_unsigned_integer (pc, 2, byte_order);
      /* See where the registers will be saved to.  */
      if (IS_PUSH (inst))
	{
	  cache->saved_regs[GET_SOURCE_REG (inst)] = cache->sp_offset;
	  cache->sp_offset += 4;
	}
      else if (IS_STS (inst))
	{
	  cache->saved_regs[PR_REGNUM] = cache->sp_offset;
	  cache->sp_offset += 4;
	}
      else if (IS_MACL_STS (inst))
	{
	  cache->saved_regs[MACL_REGNUM] = cache->sp_offset;
	  cache->sp_offset += 4;
	}
      else if (IS_MOV_R3 (inst))
	{
	  r3_val = ((inst & 0xff) ^ 0x80) - 0x80;
	}
      else if (IS_SHLL_R3 (inst))
	{
	  r3_val <<= 1;
	}
      else if (IS_ADD_R3SP (inst))
	{
	  cache->sp_offset += -r3_val;
	}
      else if (IS_ADD_IMM_SP (inst))
	{
	  offset = ((inst & 0xff) ^ 0x80) - 0x80;
	  cache->sp_offset -= offset;
	}
      else if (IS_MOVW_PCREL_TO_REG (inst))
	{
	  if (sav_reg < 0)
	    {
	      reg = GET_TARGET_REG (inst);
	      if (reg < 14)
		{
		  sav_reg = reg;
		  offset = (inst & 0xff) << 1;
		  sav_offset =
		    read_memory_integer ((pc + 4) + offset, 2, byte_order);
		}
	    }
	}
      else if (IS_MOVL_PCREL_TO_REG (inst))
	{
	  if (sav_reg < 0)
	    {
	      reg = GET_TARGET_REG (inst);
	      if (reg < 14)
		{
		  sav_reg = reg;
		  offset = (inst & 0xff) << 2;
		  sav_offset =
		    read_memory_integer (((pc & 0xfffffffc) + 4) + offset,
					 4, byte_order);
		}
	    }
	}
      else if (IS_MOVI20 (inst)
	       && (pc + 2 < limit_pc))
        {
	  if (sav_reg < 0)
	    {
	      reg = GET_TARGET_REG (inst);
	      if (reg < 14)
	        {
		  sav_reg = reg;
		  sav_offset = GET_SOURCE_REG (inst) << 16;
		  /* MOVI20 is a 32 bit instruction!  */
		  pc += 2;
		  sav_offset
		    |= read_memory_unsigned_integer (pc, 2, byte_order);
		  /* Now sav_offset contains an unsigned 20 bit value.
		     It must still get sign extended.  */
		  if (sav_offset & 0x00080000)
		    sav_offset |= 0xfff00000;
		}
	    }
	}
      else if (IS_SUB_REG_FROM_SP (inst))
	{
	  reg = GET_SOURCE_REG (inst);
	  if (sav_reg > 0 && reg == sav_reg)
	    {
	      sav_reg = -1;
	    }
	  cache->sp_offset += sav_offset;
	}
      else if (IS_FPUSH (inst))
	{
	  if (fpscr & FPSCR_SZ)
	    {
	      cache->sp_offset += 8;
	    }
	  else
	    {
	      cache->sp_offset += 4;
	    }
	}
      else if (IS_MOV_SP_FP (inst))
	{
	  pc += 2;
	  /* Don't go any further than six more instructions.  */
	  limit_pc = min (limit_pc, pc + (2 * 6));

	  cache->uses_fp = 1;
	  /* At this point, only allow argument register moves to other
	     registers or argument register moves to @@(X,fp) which are
	     moving the register arguments onto the stack area allocated
	     by a former add somenumber to SP call.  Don't allow moving
	     to an fp indirect address above fp + cache->sp_offset.  */
	  for (; pc < limit_pc; pc += 2)
	    {
	      inst = read_memory_integer (pc, 2, byte_order);
	      if (IS_MOV_ARG_TO_IND_R14 (inst))
		{
		  reg = GET_SOURCE_REG (inst);
		  if (cache->sp_offset > 0)
		    cache->saved_regs[reg] = cache->sp_offset;
		}
	      else if (IS_MOV_ARG_TO_IND_R14_WITH_DISP (inst))
		{
		  reg = GET_SOURCE_REG (inst);
		  offset = (inst & 0xf) * 4;
		  if (cache->sp_offset > offset)
		    cache->saved_regs[reg] = cache->sp_offset - offset;
		}
	      else if (IS_MOV_ARG_TO_REG (inst))
		continue;
	      else
		break;
	    }
	  break;
	}
      else if (IS_JSR (inst))
	{
	  /* We have found a jsr that has been scheduled into the prologue.
	     If we continue the scan and return a pc someplace after this,
	     then setting a breakpoint on this function will cause it to
	     appear to be called after the function it is calling via the
	     jsr, which will be very confusing.  Most likely the next
	     instruction is going to be IS_MOV_SP_FP in the delay slot.  If
	     so, note that before returning the current pc.  */
	  if (pc + 2 < limit_pc)
	    {
	      inst = read_memory_integer (pc + 2, 2, byte_order);
	      if (IS_MOV_SP_FP (inst))
		cache->uses_fp = 1;
	    }
	  break;
	}
#if 0		/* This used to just stop when it found an instruction
		   that was not considered part of the prologue.  Now,
		   we just keep going looking for likely
		   instructions.  */
      else
	break;
#endif
    }

  return pc;
}

/* Skip any prologue before the guts of a function.  */
static CORE_ADDR
sh_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR post_prologue_pc, func_addr, func_end_addr, limit_pc;
  struct sh_frame_cache cache;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end_addr))
    {
      post_prologue_pc = skip_prologue_using_sal (gdbarch, func_addr);
      if (post_prologue_pc != 0)
        return max (pc, post_prologue_pc);
    }

  /* Can't determine prologue from the symbol table, need to examine
     instructions.  */

  /* Find an upper limit on the function prologue using the debug
     information.  If the debug information could not be used to provide
     that bound, then use an arbitrary large number as the upper bound.  */
  limit_pc = skip_prologue_using_sal (gdbarch, pc);
  if (limit_pc == 0)
    /* Don't go any further than 28 instructions.  */
    limit_pc = pc + (2 * 28);

  /* Do not allow limit_pc to be past the function end, if we know
     where that end is...  */
  if (func_end_addr != 0)
    limit_pc = min (limit_pc, func_end_addr);

  cache.sp_offset = -4;
  post_prologue_pc = sh_analyze_prologue (gdbarch, pc, limit_pc, &cache, 0);
  if (cache.uses_fp)
    pc = post_prologue_pc;

  return pc;
}

/* The ABI says:

   Aggregate types not bigger than 8 bytes that have the same size and
   alignment as one of the integer scalar types are returned in the
   same registers as the integer type they match.

   For example, a 2-byte aligned structure with size 2 bytes has the
   same size and alignment as a short int, and will be returned in R0.
   A 4-byte aligned structure with size 8 bytes has the same size and
   alignment as a long long int, and will be returned in R0 and R1.

   When an aggregate type is returned in R0 and R1, R0 contains the
   first four bytes of the aggregate, and R1 contains the
   remainder.  If the size of the aggregate type is not a multiple of 4
   bytes, the aggregate is tail-padded up to a multiple of 4
   bytes.  The value of the padding is undefined.  For little-endian
   targets the padding will appear at the most significant end of the
   last element, for big-endian targets the padding appears at the
   least significant end of the last element.

   All other aggregate types are returned by address.  The caller
   function passes the address of an area large enough to hold the
   aggregate value in R2.  The called function stores the result in
   this location.

   To reiterate, structs smaller than 8 bytes could also be returned
   in memory, if they don't pass the "same size and alignment as an
   integer type" rule.

   For example, in

   struct s { char c[3]; } wibble;
   struct s foo(void) {  return wibble; }

   the return value from foo() will be in memory, not
   in R0, because there is no 3-byte integer type.

   Similarly, in 

   struct s { char c[2]; } wibble;
   struct s foo(void) {  return wibble; }

   because a struct containing two chars has alignment 1, that matches
   type char, but size 2, that matches type short.  There's no integer
   type that has alignment 1 and size 2, so the struct is returned in
   memory.  */

static int
sh_use_struct_convention (int renesas_abi, struct type *type)
{
  int len = TYPE_LENGTH (type);
  int nelem = TYPE_NFIELDS (type);

  /* The Renesas ABI returns aggregate types always on stack.  */
  if (renesas_abi && (TYPE_CODE (type) == TYPE_CODE_STRUCT
		      || TYPE_CODE (type) == TYPE_CODE_UNION))
    return 1;

  /* Non-power of 2 length types and types bigger than 8 bytes (which don't
     fit in two registers anyway) use struct convention.  */
  if (len != 1 && len != 2 && len != 4 && len != 8)
    return 1;

  /* Scalar types and aggregate types with exactly one field are aligned
     by definition.  They are returned in registers.  */
  if (nelem <= 1)
    return 0;

  /* If the first field in the aggregate has the same length as the entire
     aggregate type, the type is returned in registers.  */
  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == len)
    return 0;

  /* If the size of the aggregate is 8 bytes and the first field is
     of size 4 bytes its alignment is equal to long long's alignment,
     so it's returned in registers.  */
  if (len == 8 && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)
    return 0;

  /* Otherwise use struct convention.  */
  return 1;
}

static int
sh_use_struct_convention_nofpu (int renesas_abi, struct type *type)
{
  /* The Renesas ABI returns long longs/doubles etc. always on stack.  */
  if (renesas_abi && TYPE_NFIELDS (type) == 0 && TYPE_LENGTH (type) >= 8)
    return 1;
  return sh_use_struct_convention (renesas_abi, type);
}

static CORE_ADDR
sh_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
{
  return sp & ~3;
}

/* Function: push_dummy_call (formerly push_arguments)
   Setup the function arguments for calling a function in the inferior.

   On the Renesas SH architecture, there are four registers (R4 to R7)
   which are dedicated for passing function arguments.  Up to the first
   four arguments (depending on size) may go into these registers.
   The rest go on the stack.

   MVS: Except on SH variants that have floating point registers.
   In that case, float and double arguments are passed in the same
   manner, but using FP registers instead of GP registers.

   Arguments that are smaller than 4 bytes will still take up a whole
   register or a whole 32-bit word on the stack, and will be 
   right-justified in the register or the stack word.  This includes
   chars, shorts, and small aggregate types.

   Arguments that are larger than 4 bytes may be split between two or 
   more registers.  If there are not enough registers free, an argument
   may be passed partly in a register (or registers), and partly on the
   stack.  This includes doubles, long longs, and larger aggregates.
   As far as I know, there is no upper limit to the size of aggregates 
   that will be passed in this way; in other words, the convention of 
   passing a pointer to a large aggregate instead of a copy is not used.

   MVS: The above appears to be true for the SH variants that do not
   have an FPU, however those that have an FPU appear to copy the
   aggregate argument onto the stack (and not place it in registers)
   if it is larger than 16 bytes (four GP registers).

   An exceptional case exists for struct arguments (and possibly other
   aggregates such as arrays) if the size is larger than 4 bytes but 
   not a multiple of 4 bytes.  In this case the argument is never split 
   between the registers and the stack, but instead is copied in its
   entirety onto the stack, AND also copied into as many registers as 
   there is room for.  In other words, space in registers permitting, 
   two copies of the same argument are passed in.  As far as I can tell,
   only the one on the stack is used, although that may be a function 
   of the level of compiler optimization.  I suspect this is a compiler
   bug.  Arguments of these odd sizes are left-justified within the 
   word (as opposed to arguments smaller than 4 bytes, which are 
   right-justified).

   If the function is to return an aggregate type such as a struct, it 
   is either returned in the normal return value register R0 (if its 
   size is no greater than one byte), or else the caller must allocate
   space into which the callee will copy the return value (if the size
   is greater than one byte).  In this case, a pointer to the return 
   value location is passed into the callee in register R2, which does 
   not displace any of the other arguments passed in via registers R4
   to R7.  */

/* Helper function to justify value in register according to endianess.  */
static const gdb_byte *
sh_justify_value_in_reg (struct gdbarch *gdbarch, struct value *val, int len)
{
  static gdb_byte valbuf[4];

  memset (valbuf, 0, sizeof (valbuf));
  if (len < 4)
    {
      /* value gets right-justified in the register or stack word.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	memcpy (valbuf + (4 - len), value_contents (val), len);
      else
	memcpy (valbuf, value_contents (val), len);
      return valbuf;
    }
  return value_contents (val);
}

/* Helper function to eval number of bytes to allocate on stack.  */
static CORE_ADDR
sh_stack_allocsize (int nargs, struct value **args)
{
  int stack_alloc = 0;
  while (nargs-- > 0)
    stack_alloc += ((TYPE_LENGTH (value_type (args[nargs])) + 3) & ~3);
  return stack_alloc;
}

/* Helper functions for getting the float arguments right.  Registers usage
   depends on the ABI and the endianess.  The comments should enlighten how
   it's intended to work.  */

/* This array stores which of the float arg registers are already in use.  */
static int flt_argreg_array[FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM + 1];

/* This function just resets the above array to "no reg used so far".  */
static void
sh_init_flt_argreg (void)
{
  memset (flt_argreg_array, 0, sizeof flt_argreg_array);
}

/* This function returns the next register to use for float arg passing.
   It returns either a valid value between FLOAT_ARG0_REGNUM and
   FLOAT_ARGLAST_REGNUM if a register is available, otherwise it returns 
   FLOAT_ARGLAST_REGNUM + 1 to indicate that no register is available.

   Note that register number 0 in flt_argreg_array corresponds with the
   real float register fr4.  In contrast to FLOAT_ARG0_REGNUM (value is
   29) the parity of the register number is preserved, which is important
   for the double register passing test (see the "argreg & 1" test below).  */
static int
sh_next_flt_argreg (struct gdbarch *gdbarch, int len, struct type *func_type)
{
  int argreg;

  /* First search for the next free register.  */
  for (argreg = 0; argreg <= FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM;
       ++argreg)
    if (!flt_argreg_array[argreg])
      break;

  /* No register left?  */
  if (argreg > FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM)
    return FLOAT_ARGLAST_REGNUM + 1;

  if (len == 8)
    {
      /* Doubles are always starting in a even register number.  */
      if (argreg & 1)
	{
	  /* In gcc ABI, the skipped register is lost for further argument
	     passing now.  Not so in Renesas ABI.  */
	  if (!sh_is_renesas_calling_convention (func_type))
	    flt_argreg_array[argreg] = 1;

	  ++argreg;

	  /* No register left?  */
	  if (argreg > FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM)
	    return FLOAT_ARGLAST_REGNUM + 1;
	}
      /* Also mark the next register as used.  */
      flt_argreg_array[argreg + 1] = 1;
    }
  else if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE
	   && !sh_is_renesas_calling_convention (func_type))
    {
      /* In little endian, gcc passes floats like this: f5, f4, f7, f6, ...  */
      if (!flt_argreg_array[argreg + 1])
	++argreg;
    }
  flt_argreg_array[argreg] = 1;
  return FLOAT_ARG0_REGNUM + argreg;
}

/* Helper function which figures out, if a type is treated like a float type.

   The FPU ABIs have a special way how to treat types as float types.
   Structures with exactly one member, which is of type float or double, are
   treated exactly as the base types float or double:

     struct sf {
       float f;
     };

     struct sd {
       double d;
     };

   are handled the same way as just

     float f;

     double d;

   As a result, arguments of these struct types are pushed into floating point
   registers exactly as floats or doubles, using the same decision algorithm.

   The same is valid if these types are used as function return types.  The
   above structs are returned in fr0 resp. fr0,fr1 instead of in r0, r0,r1
   or even using struct convention as it is for other structs.  */

static int
sh_treat_as_flt_p (struct type *type)
{
  /* Ordinary float types are obviously treated as float.  */
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    return 1;
  /* Otherwise non-struct types are not treated as float.  */
  if (TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return 0;
  /* Otherwise structs with more than one memeber are not treated as float.  */
  if (TYPE_NFIELDS (type) != 1)
    return 0;
  /* Otherwise if the type of that member is float, the whole type is
     treated as float.  */
  if (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_FLT)
    return 1;
  /* Otherwise it's not treated as float.  */
  return 0;
}

static CORE_ADDR
sh_push_dummy_call_fpu (struct gdbarch *gdbarch,
			struct value *function,
			struct regcache *regcache,
			CORE_ADDR bp_addr, int nargs,
			struct value **args,
			CORE_ADDR sp, int struct_return,
			CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int stack_offset = 0;
  int argreg = ARG0_REGNUM;
  int flt_argreg = 0;
  int argnum;
  struct type *func_type = value_type (function);
  struct type *type;
  CORE_ADDR regval;
  const gdb_byte *val;
  int len, reg_size = 0;
  int pass_on_stack = 0;
  int treat_as_flt;
  int last_reg_arg = INT_MAX;

  /* The Renesas ABI expects all varargs arguments, plus the last
     non-vararg argument to be on the stack, no matter how many
     registers have been used so far.  */
  if (sh_is_renesas_calling_convention (func_type)
      && TYPE_VARARGS (func_type))
    last_reg_arg = TYPE_NFIELDS (func_type) - 2;

  /* First force sp to a 4-byte alignment.  */
  sp = sh_frame_align (gdbarch, sp);

  /* Make room on stack for args.  */
  sp -= sh_stack_allocsize (nargs, args);

  /* Initialize float argument mechanism.  */
  sh_init_flt_argreg ();

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  There are 16 bytes
     in four registers available.  Loop thru args from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      type = value_type (args[argnum]);
      len = TYPE_LENGTH (type);
      val = sh_justify_value_in_reg (gdbarch, args[argnum], len);

      /* Some decisions have to be made how various types are handled.
         This also differs in different ABIs.  */
      pass_on_stack = 0;

      /* Find out the next register to use for a floating point value.  */
      treat_as_flt = sh_treat_as_flt_p (type);
      if (treat_as_flt)
	flt_argreg = sh_next_flt_argreg (gdbarch, len, func_type);
      /* In Renesas ABI, long longs and aggregate types are always passed
	 on stack.  */
      else if (sh_is_renesas_calling_convention (func_type)
	       && ((TYPE_CODE (type) == TYPE_CODE_INT && len == 8)
		   || TYPE_CODE (type) == TYPE_CODE_STRUCT
		   || TYPE_CODE (type) == TYPE_CODE_UNION))
	pass_on_stack = 1;
      /* In contrast to non-FPU CPUs, arguments are never split between
	 registers and stack.  If an argument doesn't fit in the remaining
	 registers it's always pushed entirely on the stack.  */
      else if (len > ((ARGLAST_REGNUM - argreg + 1) * 4))
	pass_on_stack = 1;

      while (len > 0)
	{
	  if ((treat_as_flt && flt_argreg > FLOAT_ARGLAST_REGNUM)
	      || (!treat_as_flt && (argreg > ARGLAST_REGNUM
	                            || pass_on_stack))
	      || argnum > last_reg_arg)
	    {
	      /* The data goes entirely on the stack, 4-byte aligned.  */
	      reg_size = (len + 3) & ~3;
	      write_memory (sp + stack_offset, val, reg_size);
	      stack_offset += reg_size;
	    }
	  else if (treat_as_flt && flt_argreg <= FLOAT_ARGLAST_REGNUM)
	    {
	      /* Argument goes in a float argument register.  */
	      reg_size = register_size (gdbarch, flt_argreg);
	      regval = extract_unsigned_integer (val, reg_size, byte_order);
	      /* In little endian mode, float types taking two registers
	         (doubles on sh4, long doubles on sh2e, sh3e and sh4) must
		 be stored swapped in the argument registers.  The below
		 code first writes the first 32 bits in the next but one
		 register, increments the val and len values accordingly
		 and then proceeds as normal by writing the second 32 bits
		 into the next register.  */
	      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE
	          && TYPE_LENGTH (type) == 2 * reg_size)
	        {
		  regcache_cooked_write_unsigned (regcache, flt_argreg + 1,
						  regval);
		  val += reg_size;
		  len -= reg_size;
		  regval = extract_unsigned_integer (val, reg_size,
						     byte_order);
		}
	      regcache_cooked_write_unsigned (regcache, flt_argreg++, regval);
	    }
	  else if (!treat_as_flt && argreg <= ARGLAST_REGNUM)
	    {
	      /* there's room in a register */
	      reg_size = register_size (gdbarch, argreg);
	      regval = extract_unsigned_integer (val, reg_size, byte_order);
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }
	  /* Store the value one register at a time or in one step on
	     stack.  */
	  len -= reg_size;
	  val += reg_size;
	}
    }

  if (struct_return)
    {
      if (sh_is_renesas_calling_convention (func_type))
	/* If the function uses the Renesas ABI, subtract another 4 bytes from
	   the stack and store the struct return address there.  */
	write_memory_unsigned_integer (sp -= 4, 4, byte_order, struct_addr);
      else
	/* Using the gcc ABI, the "struct return pointer" pseudo-argument has
	   its own dedicated register.  */
	regcache_cooked_write_unsigned (regcache,
					STRUCT_RETURN_REGNUM, struct_addr);
    }

  /* Store return address.  */
  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);

  /* Update stack pointer.  */
  regcache_cooked_write_unsigned (regcache,
				  gdbarch_sp_regnum (gdbarch), sp);

  return sp;
}

static CORE_ADDR
sh_push_dummy_call_nofpu (struct gdbarch *gdbarch,
			  struct value *function,
			  struct regcache *regcache,
			  CORE_ADDR bp_addr,
			  int nargs, struct value **args,
			  CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int stack_offset = 0;
  int argreg = ARG0_REGNUM;
  int argnum;
  struct type *func_type = value_type (function);
  struct type *type;
  CORE_ADDR regval;
  const gdb_byte *val;
  int len, reg_size = 0;
  int pass_on_stack = 0;
  int last_reg_arg = INT_MAX;

  /* The Renesas ABI expects all varargs arguments, plus the last
     non-vararg argument to be on the stack, no matter how many
     registers have been used so far.  */
  if (sh_is_renesas_calling_convention (func_type)
      && TYPE_VARARGS (func_type))
    last_reg_arg = TYPE_NFIELDS (func_type) - 2;

  /* First force sp to a 4-byte alignment.  */
  sp = sh_frame_align (gdbarch, sp);

  /* Make room on stack for args.  */
  sp -= sh_stack_allocsize (nargs, args);

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  There are 16 bytes
     in four registers available.  Loop thru args from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
    {
      type = value_type (args[argnum]);
      len = TYPE_LENGTH (type);
      val = sh_justify_value_in_reg (gdbarch, args[argnum], len);

      /* Some decisions have to be made how various types are handled.
	 This also differs in different ABIs.  */
      pass_on_stack = 0;
      /* Renesas ABI pushes doubles and long longs entirely on stack.
	 Same goes for aggregate types.  */
      if (sh_is_renesas_calling_convention (func_type)
	  && ((TYPE_CODE (type) == TYPE_CODE_INT && len >= 8)
	      || (TYPE_CODE (type) == TYPE_CODE_FLT && len >= 8)
	      || TYPE_CODE (type) == TYPE_CODE_STRUCT
	      || TYPE_CODE (type) == TYPE_CODE_UNION))
	pass_on_stack = 1;
      while (len > 0)
	{
	  if (argreg > ARGLAST_REGNUM || pass_on_stack
	      || argnum > last_reg_arg)
	    {
	      /* The remainder of the data goes entirely on the stack,
	         4-byte aligned.  */
	      reg_size = (len + 3) & ~3;
	      write_memory (sp + stack_offset, val, reg_size);
	      stack_offset += reg_size;
	    }
	  else if (argreg <= ARGLAST_REGNUM)
	    {
	      /* There's room in a register.  */
	      reg_size = register_size (gdbarch, argreg);
	      regval = extract_unsigned_integer (val, reg_size, byte_order);
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }
	  /* Store the value reg_size bytes at a time.  This means that things
	     larger than reg_size bytes may go partly in registers and partly
	     on the stack.  */
	  len -= reg_size;
	  val += reg_size;
	}
    }

  if (struct_return)
    {
      if (sh_is_renesas_calling_convention (func_type))
	/* If the function uses the Renesas ABI, subtract another 4 bytes from
	   the stack and store the struct return address there.  */
	write_memory_unsigned_integer (sp -= 4, 4, byte_order, struct_addr);
      else
	/* Using the gcc ABI, the "struct return pointer" pseudo-argument has
	   its own dedicated register.  */
	regcache_cooked_write_unsigned (regcache,
					STRUCT_RETURN_REGNUM, struct_addr);
    }

  /* Store return address.  */
  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);

  /* Update stack pointer.  */
  regcache_cooked_write_unsigned (regcache,
				  gdbarch_sp_regnum (gdbarch), sp);

  return sp;
}

/* Find a function's return value in the appropriate registers (in
   regbuf), and copy it into valbuf.  Extract from an array REGBUF
   containing the (raw) register state a function return value of type
   TYPE, and copy that, in virtual format, into VALBUF.  */
static void
sh_extract_return_value_nofpu (struct type *type, struct regcache *regcache,
			       gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int len = TYPE_LENGTH (type);
  int return_register = R0_REGNUM;
  int offset;

  if (len <= 4)
    {
      ULONGEST c;

      regcache_cooked_read_unsigned (regcache, R0_REGNUM, &c);
      store_unsigned_integer (valbuf, len, byte_order, c);
    }
  else if (len == 8)
    {
      int i, regnum = R0_REGNUM;
      for (i = 0; i < len; i += 4)
	regcache_raw_read (regcache, regnum++, valbuf + i);
    }
  else
    error (_("bad size for return value"));
}

static void
sh_extract_return_value_fpu (struct type *type, struct regcache *regcache,
			     gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  if (sh_treat_as_flt_p (type))
    {
      int len = TYPE_LENGTH (type);
      int i, regnum = gdbarch_fp0_regnum (gdbarch);
      for (i = 0; i < len; i += 4)
	if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	  regcache_raw_read (regcache, regnum++,
			     valbuf + len - 4 - i);
	else
	  regcache_raw_read (regcache, regnum++, valbuf + i);
    }
  else
    sh_extract_return_value_nofpu (type, regcache, valbuf);
}

/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.
   If the architecture is sh4 or sh3e, store a function's return value
   in the R0 general register or in the FP0 floating point register,
   depending on the type of the return value.  In all the other cases
   the result is stored in r0, left-justified.  */
static void
sh_store_return_value_nofpu (struct type *type, struct regcache *regcache,
			     const gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST val;
  int len = TYPE_LENGTH (type);

  if (len <= 4)
    {
      val = extract_unsigned_integer (valbuf, len, byte_order);
      regcache_cooked_write_unsigned (regcache, R0_REGNUM, val);
    }
  else
    {
      int i, regnum = R0_REGNUM;
      for (i = 0; i < len; i += 4)
	regcache_raw_write (regcache, regnum++, valbuf + i);
    }
}

static void
sh_store_return_value_fpu (struct type *type, struct regcache *regcache,
			   const gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  if (sh_treat_as_flt_p (type))
    {
      int len = TYPE_LENGTH (type);
      int i, regnum = gdbarch_fp0_regnum (gdbarch);
      for (i = 0; i < len; i += 4)
	if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	  regcache_raw_write (regcache, regnum++,
			      valbuf + len - 4 - i);
	else
	  regcache_raw_write (regcache, regnum++, valbuf + i);
    }
  else
    sh_store_return_value_nofpu (type, regcache, valbuf);
}

static enum return_value_convention
sh_return_value_nofpu (struct gdbarch *gdbarch, struct value *function,
		       struct type *type, struct regcache *regcache,
		       gdb_byte *readbuf, const gdb_byte *writebuf)
{
  struct type *func_type = function ? value_type (function) : NULL;

  if (sh_use_struct_convention_nofpu (
  	sh_is_renesas_calling_convention (func_type), type))
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (writebuf)
    sh_store_return_value_nofpu (type, regcache, writebuf);
  else if (readbuf)
    sh_extract_return_value_nofpu (type, regcache, readbuf);
  return RETURN_VALUE_REGISTER_CONVENTION;
}

static enum return_value_convention
sh_return_value_fpu (struct gdbarch *gdbarch, struct value *function,
		     struct type *type, struct regcache *regcache,
		     gdb_byte *readbuf, const gdb_byte *writebuf)
{
  struct type *func_type = function ? value_type (function) : NULL;

  if (sh_use_struct_convention (
	sh_is_renesas_calling_convention (func_type), type))
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (writebuf)
    sh_store_return_value_fpu (type, regcache, writebuf);
  else if (readbuf)
    sh_extract_return_value_fpu (type, regcache, readbuf);
  return RETURN_VALUE_REGISTER_CONVENTION;
}

static struct type *
sh_sh2a_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
    return builtin_type (gdbarch)->builtin_float;
  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
    return builtin_type (gdbarch)->builtin_double;
  else
    return builtin_type (gdbarch)->builtin_int;
}

/* Return the GDB type object for the "standard" data type
   of data in register N.  */
static struct type *
sh_sh3e_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
    return builtin_type (gdbarch)->builtin_float;
  else
    return builtin_type (gdbarch)->builtin_int;
}

static struct type *
sh_sh4_build_float_register_type (struct gdbarch *gdbarch, int high)
{
  return lookup_array_range_type (builtin_type (gdbarch)->builtin_float,
				  0, high);
}

static struct type *
sh_sh4_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
    return builtin_type (gdbarch)->builtin_float;
  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
    return builtin_type (gdbarch)->builtin_double;
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
    return sh_sh4_build_float_register_type (gdbarch, 3);
  else
    return builtin_type (gdbarch)->builtin_int;
}

static struct type *
sh_default_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  return builtin_type (gdbarch)->builtin_int;
}

/* Is a register in a reggroup?
   The default code in reggroup.c doesn't identify system registers, some
   float registers or any of the vector registers.
   TODO: sh2a and dsp registers.  */
static int
sh_register_reggroup_p (struct gdbarch *gdbarch, int regnum,
			struct reggroup *reggroup)
{
  if (gdbarch_register_name (gdbarch, regnum) == NULL
      || *gdbarch_register_name (gdbarch, regnum) == '\0')
    return 0;

  if (reggroup == float_reggroup
      && (regnum == FPUL_REGNUM
	  || regnum == FPSCR_REGNUM))
    return 1;

  if (regnum >= FV0_REGNUM && regnum <= FV_LAST_REGNUM)
    {
      if (reggroup == vector_reggroup || reggroup == float_reggroup)
	return 1;
      if (reggroup == general_reggroup)
	return 0;
    }

  if (regnum == VBR_REGNUM
      || regnum == SR_REGNUM
      || regnum == FPSCR_REGNUM
      || regnum == SSR_REGNUM
      || regnum == SPC_REGNUM)
    {
      if (reggroup == system_reggroup)
	return 1;
      if (reggroup == general_reggroup)
	return 0;
    }

  /* The default code can cope with any other registers.  */
  return default_register_reggroup_p (gdbarch, regnum, reggroup);
}

/* On the sh4, the DRi pseudo registers are problematic if the target
   is little endian.  When the user writes one of those registers, for
   instance with 'set var $dr0=1', we want the double to be stored
   like this: 
   fr0 = 0x00 0x00 0xf0 0x3f 
   fr1 = 0x00 0x00 0x00 0x00 

   This corresponds to little endian byte order & big endian word
   order.  However if we let gdb write the register w/o conversion, it
   will write fr0 and fr1 this way:
   fr0 = 0x00 0x00 0x00 0x00
   fr1 = 0x00 0x00 0xf0 0x3f
   because it will consider fr0 and fr1 as a single LE stretch of memory.
   
   To achieve what we want we must force gdb to store things in
   floatformat_ieee_double_littlebyte_bigword (which is defined in
   include/floatformat.h and libiberty/floatformat.c.

   In case the target is big endian, there is no problem, the
   raw bytes will look like:
   fr0 = 0x3f 0xf0 0x00 0x00
   fr1 = 0x00 0x00 0x00 0x00

   The other pseudo registers (the FVs) also don't pose a problem
   because they are stored as 4 individual FP elements.  */

static void
sh_register_convert_to_virtual (struct gdbarch *gdbarch, int regnum,
				struct type *type, gdb_byte *from, gdb_byte *to)
{
  if (gdbarch_byte_order (gdbarch) != BFD_ENDIAN_LITTLE)
    {
      /* It is a no-op.  */
      memcpy (to, from, register_size (gdbarch, regnum));
      return;
    }

  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
    {
      DOUBLEST val;
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
			       from, &val);
      store_typed_floating (to, type, val);
    }
  else
    error
      ("sh_register_convert_to_virtual called with non DR register number");
}

static void
sh_register_convert_to_raw (struct gdbarch *gdbarch, struct type *type,
			    int regnum, const gdb_byte *from, gdb_byte *to)
{
  if (gdbarch_byte_order (gdbarch) != BFD_ENDIAN_LITTLE)
    {
      /* It is a no-op.  */
      memcpy (to, from, register_size (gdbarch, regnum));
      return;
    }

  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
    {
      DOUBLEST val = extract_typed_floating (from, type);
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword,
				 &val, to);
    }
  else
    error (_("sh_register_convert_to_raw called with non DR register number"));
}

/* For vectors of 4 floating point registers.  */
static int
fv_reg_base_num (struct gdbarch *gdbarch, int fv_regnum)
{
  int fp_regnum;

  fp_regnum = gdbarch_fp0_regnum (gdbarch)
	      + (fv_regnum - FV0_REGNUM) * 4;
  return fp_regnum;
}

/* For double precision floating point registers, i.e 2 fp regs.  */
static int
dr_reg_base_num (struct gdbarch *gdbarch, int dr_regnum)
{
  int fp_regnum;

  fp_regnum = gdbarch_fp0_regnum (gdbarch)
	      + (dr_regnum - DR0_REGNUM) * 2;
  return fp_regnum;
}

/* Concatenate PORTIONS contiguous raw registers starting at
   BASE_REGNUM into BUFFER.  */

static enum register_status
pseudo_register_read_portions (struct gdbarch *gdbarch,
			       struct regcache *regcache,
			       int portions,
			       int base_regnum, gdb_byte *buffer)
{
  int portion;

  for (portion = 0; portion < portions; portion++)
    {
      enum register_status status;
      gdb_byte *b;

      b = buffer + register_size (gdbarch, base_regnum) * portion;
      status = regcache_raw_read (regcache, base_regnum + portion, b);
      if (status != REG_VALID)
	return status;
    }

  return REG_VALID;
}

static enum register_status
sh_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			 int reg_nr, gdb_byte *buffer)
{
  int base_regnum;
  gdb_byte temp_buffer[MAX_REGISTER_SIZE];
  enum register_status status;

  if (reg_nr == PSEUDO_BANK_REGNUM)
    return regcache_raw_read (regcache, BANK_REGNUM, buffer);
  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
    {
      base_regnum = dr_reg_base_num (gdbarch, reg_nr);

      /* Build the value in the provided buffer.  */
      /* Read the real regs for which this one is an alias.  */
      status = pseudo_register_read_portions (gdbarch, regcache,
					      2, base_regnum, temp_buffer);
      if (status == REG_VALID)
	{
	  /* We must pay attention to the endiannes. */
	  sh_register_convert_to_virtual (gdbarch, reg_nr,
					  register_type (gdbarch, reg_nr),
					  temp_buffer, buffer);
	}
      return status;
    }
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
    {
      base_regnum = fv_reg_base_num (gdbarch, reg_nr);

      /* Read the real regs for which this one is an alias.  */
      return pseudo_register_read_portions (gdbarch, regcache,
					    4, base_regnum, buffer);
    }
  else
    gdb_assert_not_reached ("invalid pseudo register number");
}

static void
sh_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			  int reg_nr, const gdb_byte *buffer)
{
  int base_regnum, portion;
  gdb_byte temp_buffer[MAX_REGISTER_SIZE];

  if (reg_nr == PSEUDO_BANK_REGNUM)
    {
      /* When the bank register is written to, the whole register bank
         is switched and all values in the bank registers must be read
	 from the target/sim again.  We're just invalidating the regcache
	 so that a re-read happens next time it's necessary.  */
      int bregnum;

      regcache_raw_write (regcache, BANK_REGNUM, buffer);
      for (bregnum = R0_BANK0_REGNUM; bregnum < MACLB_REGNUM; ++bregnum)
        regcache_invalidate (regcache, bregnum);
    }
  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
    {
      base_regnum = dr_reg_base_num (gdbarch, reg_nr);

      /* We must pay attention to the endiannes.  */
      sh_register_convert_to_raw (gdbarch, register_type (gdbarch, reg_nr),
				  reg_nr, buffer, temp_buffer);

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_write (regcache, base_regnum + portion,
			    (temp_buffer
			     + register_size (gdbarch,
					      base_regnum) * portion));
    }
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
    {
      base_regnum = fv_reg_base_num (gdbarch, reg_nr);

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 4; portion++)
	regcache_raw_write (regcache, base_regnum + portion,
			    (buffer
			     + register_size (gdbarch,
					      base_regnum) * portion));
    }
}

static int
sh_dsp_register_sim_regno (struct gdbarch *gdbarch, int nr)
{
  if (legacy_register_sim_regno (gdbarch, nr) < 0)
    return legacy_register_sim_regno (gdbarch, nr);
  if (nr >= DSR_REGNUM && nr <= Y1_REGNUM)
    return nr - DSR_REGNUM + SIM_SH_DSR_REGNUM;
  if (nr == MOD_REGNUM)
    return SIM_SH_MOD_REGNUM;
  if (nr == RS_REGNUM)
    return SIM_SH_RS_REGNUM;
  if (nr == RE_REGNUM)
    return SIM_SH_RE_REGNUM;
  if (nr >= DSP_R0_BANK_REGNUM && nr <= DSP_R7_BANK_REGNUM)
    return nr - DSP_R0_BANK_REGNUM + SIM_SH_R0_BANK_REGNUM;
  return nr;
}

static int
sh_sh2a_register_sim_regno (struct gdbarch *gdbarch, int nr)
{
  switch (nr)
    {
      case TBR_REGNUM:
        return SIM_SH_TBR_REGNUM;
      case IBNR_REGNUM:
        return SIM_SH_IBNR_REGNUM;
      case IBCR_REGNUM:
        return SIM_SH_IBCR_REGNUM;
      case BANK_REGNUM:
        return SIM_SH_BANK_REGNUM;
      case MACLB_REGNUM:
        return SIM_SH_BANK_MACL_REGNUM;
      case GBRB_REGNUM:
        return SIM_SH_BANK_GBR_REGNUM;
      case PRB_REGNUM:
        return SIM_SH_BANK_PR_REGNUM;
      case IVNB_REGNUM:
        return SIM_SH_BANK_IVN_REGNUM;
      case MACHB_REGNUM:
        return SIM_SH_BANK_MACH_REGNUM;
      default:
        break;
    }
  return legacy_register_sim_regno (gdbarch, nr);
}

/* Set up the register unwinding such that call-clobbered registers are
   not displayed in frames >0 because the true value is not certain.
   The 'undefined' registers will show up as 'not available' unless the
   CFI says otherwise.

   This function is currently set up for SH4 and compatible only.  */

static void
sh_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,
                          struct dwarf2_frame_state_reg *reg,
			  struct frame_info *this_frame)
{
  /* Mark the PC as the destination for the return address.  */
  if (regnum == gdbarch_pc_regnum (gdbarch))
    reg->how = DWARF2_FRAME_REG_RA;

  /* Mark the stack pointer as the call frame address.  */
  else if (regnum == gdbarch_sp_regnum (gdbarch))
    reg->how = DWARF2_FRAME_REG_CFA;

  /* The above was taken from the default init_reg in dwarf2-frame.c
     while the below is SH specific.  */

  /* Caller save registers.  */
  else if ((regnum >= R0_REGNUM && regnum <= R0_REGNUM+7)
	   || (regnum >= FR0_REGNUM && regnum <= FR0_REGNUM+11)
	   || (regnum >= DR0_REGNUM && regnum <= DR0_REGNUM+5)
	   || (regnum >= FV0_REGNUM && regnum <= FV0_REGNUM+2)
	   || (regnum == MACH_REGNUM)
	   || (regnum == MACL_REGNUM)
	   || (regnum == FPUL_REGNUM)
	   || (regnum == SR_REGNUM))
    reg->how = DWARF2_FRAME_REG_UNDEFINED;

  /* Callee save registers.  */
  else if ((regnum >= R0_REGNUM+8 && regnum <= R0_REGNUM+15)
	   || (regnum >= FR0_REGNUM+12 && regnum <= FR0_REGNUM+15)
	   || (regnum >= DR0_REGNUM+6 && regnum <= DR0_REGNUM+8)
	   || (regnum == FV0_REGNUM+3))
    reg->how = DWARF2_FRAME_REG_SAME_VALUE;

  /* Other registers.  These are not in the ABI and may or may not
     mean anything in frames >0 so don't show them.  */
  else if ((regnum >= R0_BANK0_REGNUM && regnum <= R0_BANK0_REGNUM+15)
	   || (regnum == GBR_REGNUM)
	   || (regnum == VBR_REGNUM)
	   || (regnum == FPSCR_REGNUM)
	   || (regnum == SSR_REGNUM)
	   || (regnum == SPC_REGNUM))
    reg->how = DWARF2_FRAME_REG_UNDEFINED;
}

static struct sh_frame_cache *
sh_alloc_frame_cache (void)
{
  struct sh_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct sh_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->saved_sp = 0;
  cache->sp_offset = 0;
  cache->pc = 0;

  /* Frameless until proven otherwise.  */
  cache->uses_fp = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where fp is supposed to be stored).  */
  for (i = 0; i < SH_NUM_REGS; i++)
    {
      cache->saved_regs[i] = -1;
    }

  return cache;
}

static struct sh_frame_cache *
sh_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct sh_frame_cache *cache;
  CORE_ADDR current_pc;
  int i;

  if (*this_cache)
    return *this_cache;

  cache = sh_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  */
  cache->base = get_frame_register_unsigned (this_frame, FP_REGNUM);
  if (cache->base == 0)
    return cache;

  cache->pc = get_frame_func (this_frame);
  current_pc = get_frame_pc (this_frame);
  if (cache->pc != 0)
    {
      ULONGEST fpscr;

      /* Check for the existence of the FPSCR register.	 If it exists,
	 fetch its value for use in prologue analysis.	Passing a zero
	 value is the best choice for architecture variants upon which
	 there's no FPSCR register.  */
      if (gdbarch_register_reggroup_p (gdbarch, FPSCR_REGNUM, all_reggroup))
	fpscr = get_frame_register_unsigned (this_frame, FPSCR_REGNUM);
      else
	fpscr = 0;

      sh_analyze_prologue (gdbarch, cache->pc, current_pc, cache, fpscr);
    }

  if (!cache->uses_fp)
    {
      /* We didn't find a valid frame, which means that CACHE->base
         currently holds the frame pointer for our calling frame.  If
         we're at the start of a function, or somewhere half-way its
         prologue, the function's frame probably hasn't been fully
         setup yet.  Try to reconstruct the base address for the stack
         frame by looking at the stack pointer.  For truly "frameless"
         functions this might work too.  */
      cache->base = get_frame_register_unsigned
		     (this_frame, gdbarch_sp_regnum (gdbarch));
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of sp in the calling frame.  */
  cache->saved_sp = cache->base + cache->sp_offset;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < SH_NUM_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] = cache->saved_sp - cache->saved_regs[i] - 4;

  return cache;
}

static struct value *
sh_frame_prev_register (struct frame_info *this_frame,
			void **this_cache, int regnum)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct sh_frame_cache *cache = sh_frame_cache (this_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == gdbarch_sp_regnum (gdbarch) && cache->saved_sp)
    return frame_unwind_got_constant (this_frame, regnum, cache->saved_sp);

  /* The PC of the previous frame is stored in the PR register of
     the current frame.  Frob regnum so that we pull the value from
     the correct place.  */
  if (regnum == gdbarch_pc_regnum (gdbarch))
    regnum = PR_REGNUM;

  if (regnum < SH_NUM_REGS && cache->saved_regs[regnum] != -1)
    return frame_unwind_got_memory (this_frame, regnum,
                                    cache->saved_regs[regnum]);

  return frame_unwind_got_register (this_frame, regnum, regnum);
}

static void
sh_frame_this_id (struct frame_info *this_frame, void **this_cache,
		  struct frame_id *this_id)
{
  struct sh_frame_cache *cache = sh_frame_cache (this_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  *this_id = frame_id_build (cache->saved_sp, cache->pc);
}

static const struct frame_unwind sh_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  sh_frame_this_id,
  sh_frame_prev_register,
  NULL,
  default_frame_sniffer
};

static CORE_ADDR
sh_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame,
					 gdbarch_sp_regnum (gdbarch));
}

static CORE_ADDR
sh_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame,
					 gdbarch_pc_regnum (gdbarch));
}

static struct frame_id
sh_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR sp = get_frame_register_unsigned (this_frame,
					      gdbarch_sp_regnum (gdbarch));
  return frame_id_build (sp, get_frame_pc (this_frame));
}

static CORE_ADDR
sh_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct sh_frame_cache *cache = sh_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base sh_frame_base = {
  &sh_frame_unwind,
  sh_frame_base_address,
  sh_frame_base_address,
  sh_frame_base_address
};

static struct sh_frame_cache *
sh_make_stub_cache (struct frame_info *this_frame)
{
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  struct sh_frame_cache *cache;

  cache = sh_alloc_frame_cache ();

  cache->saved_sp
    = get_frame_register_unsigned (this_frame, gdbarch_sp_regnum (gdbarch));

  return cache;
}

static void
sh_stub_this_id (struct frame_info *this_frame, void **this_cache,
                 struct frame_id *this_id)
{
  struct sh_frame_cache *cache;

  if (*this_cache == NULL)
    *this_cache = sh_make_stub_cache (this_frame);
  cache = *this_cache;

  *this_id = frame_id_build (cache->saved_sp, get_frame_pc (this_frame));
}

static int
sh_stub_unwind_sniffer (const struct frame_unwind *self,
                        struct frame_info *this_frame,
                        void **this_prologue_cache)
{
  CORE_ADDR addr_in_block;

  addr_in_block = get_frame_address_in_block (this_frame);
  if (in_plt_section (addr_in_block))
    return 1;

  return 0;
}

static const struct frame_unwind sh_stub_unwind =
{
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  sh_stub_this_id,
  sh_frame_prev_register,
  NULL,
  sh_stub_unwind_sniffer
};

/* The epilogue is defined here as the area at the end of a function,
   either on the `ret' instruction itself or after an instruction which
   destroys the function's stack frame.  */
static int
sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR func_addr = 0, func_end = 0;

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      ULONGEST inst;
      /* The sh epilogue is max. 14 bytes long.  Give another 14 bytes
         for a nop and some fixed data (e.g. big offsets) which are
         unfortunately also treated as part of the function (which
         means, they are below func_end.  */
      CORE_ADDR addr = func_end - 28;
      if (addr < func_addr + 4)
	addr = func_addr + 4;
      if (pc < addr)
	return 0;

      /* First search forward until hitting an rts.  */
      while (addr < func_end
	     && !IS_RTS (read_memory_unsigned_integer (addr, 2, byte_order)))
	addr += 2;
      if (addr >= func_end)
	return 0;

      /* At this point we should find a mov.l @@r15+,r14 instruction,
         either before or after the rts.  If not, then the function has
         probably no "normal" epilogue and we bail out here.  */
      inst = read_memory_unsigned_integer (addr - 2, 2, byte_order);
      if (IS_RESTORE_FP (read_memory_unsigned_integer (addr - 2, 2,
						       byte_order)))
	addr -= 2;
      else if (!IS_RESTORE_FP (read_memory_unsigned_integer (addr + 2, 2,
							     byte_order)))
	return 0;

      inst = read_memory_unsigned_integer (addr - 2, 2, byte_order);

      /* Step over possible lds.l @@r15+,macl.  */
      if (IS_MACL_LDS (inst))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2, byte_order);
	}

      /* Step over possible lds.l @@r15+,pr.  */
      if (IS_LDS (inst))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2, byte_order);
	}

      /* Step over possible mov r14,r15.  */
      if (IS_MOV_FP_SP (inst))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2, byte_order);
	}

      /* Now check for FP adjustments, using add #imm,r14 or add rX, r14
         instructions.  */
      while (addr > func_addr + 4
	     && (IS_ADD_REG_TO_FP (inst) || IS_ADD_IMM_FP (inst)))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2, byte_order);
	}

      /* On SH2a check if the previous instruction was perhaps a MOVI20.
         That's allowed for the epilogue.  */
      if ((gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a
           || gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh2a_nofpu)
          && addr > func_addr + 6
	  && IS_MOVI20 (read_memory_unsigned_integer (addr - 4, 2,
						      byte_order)))
	addr -= 4;

      if (pc >= addr)
	return 1;
    }
  return 0;
}


/* Supply register REGNUM from the buffer specified by REGS and LEN
   in the register set REGSET to register cache REGCACHE.
   REGTABLE specifies where each register can be found in REGS.
   If REGNUM is -1, do this for all registers in REGSET.  */

void
sh_corefile_supply_regset (const struct regset *regset,
			   struct regcache *regcache,
			   int regnum, const void *regs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct sh_corefile_regmap *regmap = (regset == &sh_corefile_gregset
					     ? tdep->core_gregmap
					     : tdep->core_fpregmap);
  int i;

  for (i = 0; regmap[i].regnum != -1; i++)
    {
      if ((regnum == -1 || regnum == regmap[i].regnum)
	  && regmap[i].offset + 4 <= len)
	regcache_raw_supply (regcache, regmap[i].regnum,
			     (char *)regs + regmap[i].offset);
    }
}

/* Collect register REGNUM in the register set REGSET from register cache
   REGCACHE into the buffer specified by REGS and LEN.
   REGTABLE specifies where each register can be found in REGS.
   If REGNUM is -1, do this for all registers in REGSET.  */

void
sh_corefile_collect_regset (const struct regset *regset,
			    const struct regcache *regcache,
			    int regnum, void *regs, size_t len)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  const struct sh_corefile_regmap *regmap = (regset == &sh_corefile_gregset
					     ? tdep->core_gregmap
					     : tdep->core_fpregmap);
  int i;

  for (i = 0; regmap[i].regnum != -1; i++)
    {
      if ((regnum == -1 || regnum == regmap[i].regnum)
	  && regmap[i].offset + 4 <= len)
	regcache_raw_collect (regcache, regmap[i].regnum,
			      (char *)regs + regmap[i].offset);
    }
}

/* The following two regsets have the same contents, so it is tempting to
   unify them, but they are distiguished by their address, so don't.  */

struct regset sh_corefile_gregset =
{
  NULL,
  sh_corefile_supply_regset,
  sh_corefile_collect_regset
};

static struct regset sh_corefile_fpregset =
{
  NULL,
  sh_corefile_supply_regset,
  sh_corefile_collect_regset
};

static const struct regset *
sh_regset_from_core_section (struct gdbarch *gdbarch, const char *sect_name,
			     size_t sect_size)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (tdep->core_gregmap && strcmp (sect_name, ".reg") == 0)
    return &sh_corefile_gregset;

  if (tdep->core_fpregmap && strcmp (sect_name, ".reg2") == 0)
    return &sh_corefile_fpregset;

  return NULL;
}

/* This is the implementation of gdbarch method
   return_in_first_hidden_param_p.  */

static int
sh_return_in_first_hidden_param_p (struct gdbarch *gdbarch,
				     struct type *type)
{
  return 0;
}



static struct gdbarch *
sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  /* SH5 is handled entirely in sh64-tdep.c.  */
  if (info.bfd_arch_info->mach == bfd_mach_sh5)
    return sh64_gdbarch_init (info, arches);

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* None found, create a new architecture from the information
     provided.  */
  tdep = XZALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_int_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);

  set_gdbarch_num_regs (gdbarch, SH_NUM_REGS);
  set_gdbarch_sp_regnum (gdbarch, 15);
  set_gdbarch_pc_regnum (gdbarch, 16);
  set_gdbarch_fp0_regnum (gdbarch, -1);
  set_gdbarch_num_pseudo_regs (gdbarch, 0);

  set_gdbarch_register_type (gdbarch, sh_default_register_type);
  set_gdbarch_register_reggroup_p (gdbarch, sh_register_reggroup_p);

  set_gdbarch_breakpoint_from_pc (gdbarch, sh_breakpoint_from_pc);

  set_gdbarch_print_insn (gdbarch, print_insn_sh);
  set_gdbarch_register_sim_regno (gdbarch, legacy_register_sim_regno);

  set_gdbarch_return_value (gdbarch, sh_return_value_nofpu);

  set_gdbarch_skip_prologue (gdbarch, sh_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
  set_gdbarch_return_in_first_hidden_param_p (gdbarch,
					      sh_return_in_first_hidden_param_p);

  set_gdbarch_believe_pcc_promotion (gdbarch, 1);

  set_gdbarch_frame_align (gdbarch, sh_frame_align);
  set_gdbarch_unwind_sp (gdbarch, sh_unwind_sp);
  set_gdbarch_unwind_pc (gdbarch, sh_unwind_pc);
  set_gdbarch_dummy_id (gdbarch, sh_dummy_id);
  frame_base_set_default (gdbarch, &sh_frame_base);

  set_gdbarch_in_function_epilogue_p (gdbarch, sh_in_function_epilogue_p);

  dwarf2_frame_set_init_reg (gdbarch, sh_dwarf2_frame_init_reg);

  set_gdbarch_regset_from_core_section (gdbarch, sh_regset_from_core_section);

  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_sh:
      set_gdbarch_register_name (gdbarch, sh_sh_register_name);
      break;

    case bfd_mach_sh2:
      set_gdbarch_register_name (gdbarch, sh_sh_register_name);
      break;

    case bfd_mach_sh2e:
      /* doubles on sh2e and sh3e are actually 4 byte.  */
      set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);
      set_gdbarch_double_format (gdbarch, floatformats_ieee_single);

      set_gdbarch_register_name (gdbarch, sh_sh2e_register_name);
      set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
      break;

    case bfd_mach_sh2a:
      set_gdbarch_register_name (gdbarch, sh_sh2a_register_name);
      set_gdbarch_register_type (gdbarch, sh_sh2a_register_type);
      set_gdbarch_register_sim_regno (gdbarch, sh_sh2a_register_sim_regno);

      set_gdbarch_fp0_regnum (gdbarch, 25);
      set_gdbarch_num_pseudo_regs (gdbarch, 9);
      set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
      set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
      break;

    case bfd_mach_sh2a_nofpu:
      set_gdbarch_register_name (gdbarch, sh_sh2a_nofpu_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_sh2a_register_sim_regno);

      set_gdbarch_num_pseudo_regs (gdbarch, 1);
      set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
      break;

    case bfd_mach_sh_dsp:
      set_gdbarch_register_name (gdbarch, sh_sh_dsp_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
      break;

    case bfd_mach_sh3:
    case bfd_mach_sh3_nommu:
    case bfd_mach_sh2a_nofpu_or_sh3_nommu:
      set_gdbarch_register_name (gdbarch, sh_sh3_register_name);
      break;

    case bfd_mach_sh3e:
    case bfd_mach_sh2a_or_sh3e:
      /* doubles on sh2e and sh3e are actually 4 byte.  */
      set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);
      set_gdbarch_double_format (gdbarch, floatformats_ieee_single);

      set_gdbarch_register_name (gdbarch, sh_sh3e_register_name);
      set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
      break;

    case bfd_mach_sh3_dsp:
      set_gdbarch_register_name (gdbarch, sh_sh3_dsp_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
      break;

    case bfd_mach_sh4:
    case bfd_mach_sh4a:
    case bfd_mach_sh2a_or_sh4:
      set_gdbarch_register_name (gdbarch, sh_sh4_register_name);
      set_gdbarch_register_type (gdbarch, sh_sh4_register_type);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      set_gdbarch_num_pseudo_regs (gdbarch, 13);
      set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
      set_gdbarch_return_value (gdbarch, sh_return_value_fpu);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
      break;

    case bfd_mach_sh4_nofpu:
    case bfd_mach_sh4a_nofpu:
    case bfd_mach_sh4_nommu_nofpu:
    case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
      set_gdbarch_register_name (gdbarch, sh_sh4_nofpu_register_name);
      break;

    case bfd_mach_sh4al_dsp:
      set_gdbarch_register_name (gdbarch, sh_sh4al_dsp_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
      break;

    default:
      set_gdbarch_register_name (gdbarch, sh_sh_register_name);
      break;
    }

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  dwarf2_append_unwinders (gdbarch);
  frame_unwind_append_unwinder (gdbarch, &sh_stub_unwind);
  frame_unwind_append_unwinder (gdbarch, &sh_frame_unwind);

  return gdbarch;
}

static void
show_sh_command (char *args, int from_tty)
{
  help_list (showshcmdlist, "show sh ", all_commands, gdb_stdout);
}

static void
set_sh_command (char *args, int from_tty)
{
  printf_unfiltered
    ("\"set sh\" must be followed by an appropriate subcommand.\n");
  help_list (setshcmdlist, "set sh ", all_commands, gdb_stdout);
}

extern initialize_file_ftype _initialize_sh_tdep;  /* -Wmissing-prototypes */

void
_initialize_sh_tdep (void)
{
  gdbarch_register (bfd_arch_sh, sh_gdbarch_init, NULL);

  add_prefix_cmd ("sh", no_class, set_sh_command, "SH specific commands.",
                  &setshcmdlist, "set sh ", 0, &setlist);
  add_prefix_cmd ("sh", no_class, show_sh_command, "SH specific commands.",
                  &showshcmdlist, "show sh ", 0, &showlist);
  
  add_setshow_enum_cmd ("calling-convention", class_vars, sh_cc_enum,
			&sh_active_calling_convention,
			_("Set calling convention used when calling target "
			  "functions from GDB."),
			_("Show calling convention used when calling target "
			  "functions from GDB."),
			_("gcc       - Use GCC calling convention (default).\n"
			  "renesas   - Enforce Renesas calling convention."),
			NULL, NULL,
			&setshcmdlist, &showshcmdlist);
}
@


1.251
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d2039 1
a2039 1
  if (in_plt_section (addr_in_block, NULL))
@


1.250
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d911 1
a911 1
static char *
d914 1
a914 1
  static char valbuf[4];
d921 1
a921 1
	memcpy (valbuf + (4 - len), (char *) value_contents (val), len);
d923 1
a923 1
	memcpy (valbuf, (char *) value_contents (val), len);
d926 1
a926 1
  return (char *) value_contents (val);
d1071 1
a1071 1
  char *val;
d1212 1
a1212 1
  char *val;
d1305 1
a1305 1
			       void *valbuf)
d1324 1
a1324 1
	regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
d1332 1
a1332 1
			     void *valbuf)
d1342 1
a1342 1
			     (char *) valbuf + len - 4 - i);
d1344 1
a1344 1
	  regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
d1358 1
a1358 1
			     const void *valbuf)
d1374 1
a1374 1
	regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
d1380 1
a1380 1
			   const void *valbuf)
d1390 1
a1390 1
			      (char *) valbuf + len - 4 - i);
d1392 1
a1392 1
	  regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
d1552 1
a1552 1
				struct type *type, char *from, char *to)
d1575 1
a1575 1
			    int regnum, const void *from, void *to)
d1646 1
a1646 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1685 1
a1685 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1721 1
a1721 1
			    ((char *) buffer
@


1.249
log
@gdb/
	* sh-tdep.c (sh_register_convert_to_virtual)
	(sh_register_convert_to_raw): Add a gdbarch parameter.  Update
	all callers.  Just do a memcpy if not the little-endian case.
@
text
@d3 1
a3 1
   Copyright (C) 1993-2005, 2007-2012 Free Software Foundation, Inc.
@


1.248
log
@gdb/
	* h8300-tdep.c (h8300_gdbarch_init): Invoke
	set_gdbarch_double_format and set_gdbarch_long_double_format.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Invoke
	set_gdbarch_double_format.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
@
text
@d345 1
d349 1
a349 1
    /* double precision (pseudo) 59 - 66 */
d351 1
a351 1
    /* vectors (pseudo) 67 - 70 */
d353 2
a354 2
    /* FIXME: missing XF 71 - 86 */
    /* FIXME: missing XD 87 - 94 */
d383 1
d387 1
a387 1
    /* double precision (pseudo) 59 - 66 -- not for nofpu target */
d389 1
a389 1
    /* vectors (pseudo) 67 - 70 -- not for nofpu target */
d1526 1
a1526 1
   instance with 'ser var $dr0=1', we want the double to be stored
d1528 2
a1529 2
   fr0 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f 
   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
d1534 2
a1535 2
   fr0 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00
   fr1 = 0x00 0x00 0x00 0x00 0x00 0xf0 0x3f
d1544 2
a1545 2
   fr0 = 0x3f 0xf0 0x00 0x00 0x00 0x00 0x00
   fr1 = 0x00 0x00 0x00 0x00 0x00 0x00 0x00 
d1551 2
a1552 2
sh_register_convert_to_virtual (int regnum, struct type *type,
				char *from, char *to)
d1554 7
d1574 2
a1575 2
sh_register_convert_to_raw (struct type *type, int regnum,
			    const void *from, void *to)
d1577 7
d1662 1
a1662 1
	  sh_register_convert_to_virtual (reg_nr,
d1704 1
a1704 1
      sh_register_convert_to_raw (register_type (gdbarch, reg_nr),
@


1.247
log
@gdb/
	* NEWS: Document the removal of SH's 'regs' command.
	* sh-tdep.c (_initialize_sh_tdep): Remove the deprecated 'regs'
	command.

gdb/doc/
	* gdb.texinfo: Document the removal of SH's 'regs' command.
@
text
@d2302 1
d2348 1
@


1.246
log
@	* sh-tdep.c (sh_treat_as_flt_p): Remove unused variable LEN.
@
text
@a2418 2
  struct cmd_list_element *c;

a2420 6
  /* We can't use an alias here because 'info registers' has not yet been
     registered.  */
  c = add_com ("regs", class_vars, all_registers_info,
               _("Print all registers"));
  deprecate_cmd (c, "info all-registers");

@


1.245
log
@gdb/
	* arch-utils.c (default_return_in_first_hidden_param_p): New.
	* arch-utils.h: Declare.
	* gdbarch.sh: Add return_in_first_hidden_param_p.
	* gdbarch.c, gdbarch.h: Regenerated.
	* infcall.c (call_function_by_hand): Call
	gdbarch_return_in_first_hidden_param_p instead of
	language_pass_by_reference.

	* m68k-tdep.c (m68k_return_in_first_hidden_param_p): New.
	(m68k_gdbarch_init): Install m68k_return_in_first_hidden_param_p.
	* sh-tdep.c (sh_return_in_first_hidden_param_p): New.
	(sh_gdbarch_init): Install sh_return_in_first_hidden_param_p.
	* tic6x-tdep.c (tic6x_push_dummy_call): Remove local variable
	`cplus_return_struct_by_reference'.
	(tic6x_return_value): Handle language cplusplus.
	(tic6x_return_in_first_hidden_param_p): New.
	(tic6x_gdbarch_init): Install tic6x_return_in_first_hidden_param_p.
@
text
@a1034 2
  int len = TYPE_LENGTH (type);

@


1.244
log
@gdb/
	* NEWS: Document the deprecation of SH's 'regs' command.
	* inferior.h (all_registers_info): Add function declaration.
	* sh-tdep.c (sh_show_regs): Remove variable.
	(sh_generic_show_regs, sh3_show_regs, sh2e_show_regs, sh2a_show_regs)
	(sh2a_nofpu_show_regs, sh3e_show_regs, sh3_dsp_show_regs)
	(sh4_show_regs, sh4_nofpu_show_regs, sh_dsp_show_regs)
	(sh_show_regs_command): Remove functions.
	(sh_gdbarch_init): Don't set sh_show_regs.
	(_initialize_sh_tdep): Make the 'regs' command an deprecated alias to
	'info all-registers'.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs)
	(sh64_show_regs): Remove functions.
	* sh64-tdep.h (sh64_show_regs): Remove function declaration.

gdb/doc/
	* gdb.texinfo: Document the deprecation of SH's 'regs' command.
@
text
@d2212 11
d2274 2
@


1.243
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a71 2
static void (*sh_show_regs) (struct frame_info *);

a1431 708
/* Print the registers in a form similar to the E7000.  */

static void
sh_generic_show_regs (struct frame_info *frame)
{
  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum
					   (get_frame_arch (frame))), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));
}

static void
sh3_show_regs (struct frame_info *frame)
{
  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum
					  (get_frame_arch (frame))), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));
  printf_filtered
    ("     SSR %08lx      SPC %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));
}

static void
sh2e_show_regs (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum (gdbarch)), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));
  printf_filtered
    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM),
     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));

  printf_filtered
    ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
  printf_filtered
    ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
}

static void
sh2a_show_regs (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;

  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum (gdbarch)), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx      TBR %08lx     MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, TBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));
  printf_filtered
    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM),
     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));

  printf_filtered
    (pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	: "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
  printf_filtered
    (pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	: "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
  printf_filtered
    ("BANK=%-3d\n", (int) get_frame_register_unsigned (frame, BANK_REGNUM));
  printf_filtered
    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 0),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 1),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 2),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 3),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 4),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 5),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 6),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 7));
  printf_filtered
    ("R8b-R14b %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 8),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 9),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 10),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 11),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 12),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 13),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 14));
  printf_filtered
    ("MACHb=%08lx IVNb=%08lx PRb=%08lx GBRb=%08lx MACLb=%08lx\n",
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 15),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 16),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 17),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 18),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 19));
}

static void
sh2a_nofpu_show_regs (struct frame_info *frame)
{
  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;

  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum
					  (get_frame_arch (frame))), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx      TBR %08lx     MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, TBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));
  printf_filtered
    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM),
     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));

  printf_filtered
    ("BANK=%-3d\n", (int) get_frame_register_unsigned (frame, BANK_REGNUM));
  printf_filtered
    ("R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 0),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 1),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 2),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 3),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 4),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 5),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 6),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 7));
  printf_filtered
    ("R8b-R14b %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 8),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 9),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 10),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 11),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 12),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 13),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 14));
  printf_filtered
    ("MACHb=%08lx IVNb=%08lx PRb=%08lx GBRb=%08lx MACLb=%08lx\n",
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 15),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 16),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 17),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 18),
     (long) get_frame_register_unsigned (frame, R0_BANK0_REGNUM + 19));
}

static void
sh3e_show_regs (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum (gdbarch)), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));
  printf_filtered
    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM),
     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));

  printf_filtered
    ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
  printf_filtered
    ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
}

static void
sh3_dsp_show_regs (struct frame_info *frame)
{
  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum
					  (get_frame_arch (frame))), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));

  printf_filtered
    ("     SSR %08lx      SPC %08lx      DSR %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM),
     (long) get_frame_register_unsigned (frame, DSR_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));

  printf_filtered
    ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
     (long) get_frame_register_unsigned (frame, A0G_REGNUM) & 0xff,
     (long) get_frame_register_unsigned (frame, A0_REGNUM),
     (long) get_frame_register_unsigned (frame, M0_REGNUM),
     (long) get_frame_register_unsigned (frame, X0_REGNUM),
     (long) get_frame_register_unsigned (frame, Y0_REGNUM),
     (long) get_frame_register_unsigned (frame, RS_REGNUM),
     (long) get_frame_register_unsigned (frame, MOD_REGNUM));
  printf_filtered
    ("A1G=%02lx A1=%08lx M1=%08lx X1=%08lx Y1=%08lx RE=%08lx\n",
     (long) get_frame_register_unsigned (frame, A1G_REGNUM) & 0xff,
     (long) get_frame_register_unsigned (frame, A1_REGNUM),
     (long) get_frame_register_unsigned (frame, M1_REGNUM),
     (long) get_frame_register_unsigned (frame, X1_REGNUM),
     (long) get_frame_register_unsigned (frame, Y1_REGNUM),
     (long) get_frame_register_unsigned (frame, RE_REGNUM));
}

static void
sh4_show_regs (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int pr = get_frame_register_unsigned (frame, FPSCR_REGNUM) & 0x80000;

  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum (gdbarch)), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));
  printf_filtered
    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM),
     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));

  printf_filtered
    (pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	: "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 0),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 1),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 2),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 3),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 4),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 5),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 6),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 7));
  printf_filtered
    (pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	: "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 8),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 9),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 10),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 11),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 12),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 13),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 14),
     (long) get_frame_register_unsigned
	      (frame, gdbarch_fp0_regnum (gdbarch) + 15));
}

static void
sh4_nofpu_show_regs (struct frame_info *frame)
{
  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum
					  (get_frame_arch (frame))), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx                       MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));
  printf_filtered
    ("     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
     (long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long) get_frame_register_unsigned (frame, SPC_REGNUM),
     (long) get_frame_register_unsigned (frame, FPUL_REGNUM),
     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));
}

static void
sh_dsp_show_regs (struct frame_info *frame)
{
  printf_filtered
    ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum
					  (get_frame_arch (frame))), 4),
     (long) get_frame_register_unsigned (frame, SR_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_REGNUM));

  printf_filtered
    ("     GBR %08lx      VBR %08lx      DSR %08lx     MACL %08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_REGNUM),
     (long) get_frame_register_unsigned (frame, VBR_REGNUM),
     (long) get_frame_register_unsigned (frame, DSR_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_REGNUM));

  printf_filtered
    ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 0),
     (long) get_frame_register_unsigned (frame, 1),
     (long) get_frame_register_unsigned (frame, 2),
     (long) get_frame_register_unsigned (frame, 3),
     (long) get_frame_register_unsigned (frame, 4),
     (long) get_frame_register_unsigned (frame, 5),
     (long) get_frame_register_unsigned (frame, 6),
     (long) get_frame_register_unsigned (frame, 7));
  printf_filtered
    ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) get_frame_register_unsigned (frame, 8),
     (long) get_frame_register_unsigned (frame, 9),
     (long) get_frame_register_unsigned (frame, 10),
     (long) get_frame_register_unsigned (frame, 11),
     (long) get_frame_register_unsigned (frame, 12),
     (long) get_frame_register_unsigned (frame, 13),
     (long) get_frame_register_unsigned (frame, 14),
     (long) get_frame_register_unsigned (frame, 15));

  printf_filtered
    ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
     (long) get_frame_register_unsigned (frame, A0G_REGNUM) & 0xff,
     (long) get_frame_register_unsigned (frame, A0_REGNUM),
     (long) get_frame_register_unsigned (frame, M0_REGNUM),
     (long) get_frame_register_unsigned (frame, X0_REGNUM),
     (long) get_frame_register_unsigned (frame, Y0_REGNUM),
     (long) get_frame_register_unsigned (frame, RS_REGNUM),
     (long) get_frame_register_unsigned (frame, MOD_REGNUM));
  printf_filtered ("A1G=%02lx A1=%08lx M1=%08lx X1=%08lx Y1=%08lx RE=%08lx\n",
     (long) get_frame_register_unsigned (frame, A1G_REGNUM) & 0xff,
     (long) get_frame_register_unsigned (frame, A1_REGNUM),
     (long) get_frame_register_unsigned (frame, M1_REGNUM),
     (long) get_frame_register_unsigned (frame, X1_REGNUM),
     (long) get_frame_register_unsigned (frame, Y1_REGNUM),
     (long) get_frame_register_unsigned (frame, RE_REGNUM));
}

static void
sh_show_regs_command (char *args, int from_tty)
{
  if (sh_show_regs)
    (*sh_show_regs) (get_current_frame ());
}

d2220 3
a2222 50
  sh_show_regs = sh_generic_show_regs;
  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_sh2e:
      sh_show_regs = sh2e_show_regs;
      break;
    case bfd_mach_sh2a:
      sh_show_regs = sh2a_show_regs;
      break;
    case bfd_mach_sh2a_nofpu:
      sh_show_regs = sh2a_nofpu_show_regs;
      break;
    case bfd_mach_sh_dsp:
      sh_show_regs = sh_dsp_show_regs;
      break;

    case bfd_mach_sh3:
    case bfd_mach_sh3_nommu:
    case bfd_mach_sh2a_nofpu_or_sh3_nommu:
      sh_show_regs = sh3_show_regs;
      break;

    case bfd_mach_sh3e:
    case bfd_mach_sh2a_or_sh3e:
      sh_show_regs = sh3e_show_regs;
      break;

    case bfd_mach_sh3_dsp:
    case bfd_mach_sh4al_dsp:
      sh_show_regs = sh3_dsp_show_regs;
      break;

    case bfd_mach_sh4:
    case bfd_mach_sh4a:
    case bfd_mach_sh2a_or_sh4:
      sh_show_regs = sh4_show_regs;
      break;

    case bfd_mach_sh4_nofpu:
    case bfd_mach_sh4_nommu_nofpu:
    case bfd_mach_sh4a_nofpu:
    case bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu:
      sh_show_regs = sh4_nofpu_show_regs;
      break;

    case bfd_mach_sh5:
      sh_show_regs = sh64_show_regs;
      /* SH5 is handled entirely in sh64-tdep.c.  */
      return sh64_gdbarch_init (info, arches);
    }
d2412 6
a2417 2
  add_com ("regs", class_vars, sh_show_regs_command, _("Print all registers"));
  
@


1.242
log
@	* sh-tdep.c (sh_skip_prologue): Provide an upper limit on the function
	prologue to sh_analyze_prologue.
	(sh_analyze_prologue): Make better use of such an upper limit, and
	generally be more cautious about accessing memory.
@
text
@d1401 1
a1401 1
sh_return_value_nofpu (struct gdbarch *gdbarch, struct type *func_type,
d1405 2
d1418 1
a1418 1
sh_return_value_fpu (struct gdbarch *gdbarch, struct type *func_type,
d1422 2
@


1.241
log
@	* sh-tdep.c (sh_frame_cache): Don't fetch the FPSCR register
	unless it exists for this architecture.
@
text
@d538 1
a538 1
		     CORE_ADDR pc, CORE_ADDR current_pc,
a542 1
  CORE_ADDR opc;
a547 3
  if (pc >= current_pc)
    return current_pc;

d549 1
a549 1
  for (opc = pc + (2 * 28); pc < opc; pc += 2)
d614 2
a615 1
      else if (IS_MOVI20 (inst))
d657 4
d667 1
a667 2
	  pc += 2;
	  for (opc = pc + 12; pc < opc; pc += 2)
d699 6
a704 3
	  inst = read_memory_integer (pc + 2, 2, byte_order);
	  if (IS_MOV_SP_FP (inst))
	    cache->uses_fp = 1;
d723 1
a723 1
  CORE_ADDR post_prologue_pc, func_addr;
d729 1
a729 1
  if (find_pc_partial_function (pc, NULL, &func_addr, NULL))
d739 13
d753 1
a753 1
  post_prologue_pc = sh_analyze_prologue (gdbarch, pc, (CORE_ADDR) -1, &cache, 0);
@


1.240
log
@gdb/
	Fix -Wmissing-prototypes build.
	* Makefile.in (HFILES_NO_SRCDIR): Add sh64-tdep.h.
	* sh-tdep.c: Include sh64-tdep.h.
	* sh-tdep.h (sh64_gdbarch_init, sh64_show_regs): Remove declarations.
	* sh64-tdep.c: Include sh64-tdep.h.
	* sh64-tdep.h: New file.
@
text
@d2557 10
a2566 1
      fpscr = get_frame_register_unsigned (this_frame, FPSCR_REGNUM);
@


1.239
log
@	* sh-tdep.c (sh_make_stub_cache, sh_stub_this_id)
	(sh_stub_unwind_sniffer): New functions.
	(sh_stub_unwind): New variable.
	(sh_gdbarch_init): Wire everything.
@
text
@d47 1
@


1.238
log
@	* sh-tdep.c (sh_skip_prologue): Use skip_prologue_using_sal.
	(after_prologue): Remove.
@
text
@d44 1
d2670 51
d3110 1
@


1.237
log
@	* sh-tdep.c (sh_is_renesas_calling_convention): Fix handling of
	TYPE_CALLING_CONVENTION annotation.
@
text
@a714 3

/* Skip the prologue using the debug information.  If this fails we'll
   fall back on the 'guess' method below.  */
d716 1
a716 1
after_prologue (CORE_ADDR pc)
d718 1
a718 27
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;

  /* If we can not find the symbol in the partial symbol table, then
     there is no hope we can determine the function's start address
     with this code.  */
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    return 0;

  /* Get the line associated with FUNC_ADDR.  */
  sal = find_pc_line (func_addr, 0);

  /* There are only two cases to consider.  First, the end of the source line
     is within the function bounds.  In that case we return the end of the
     source line.  Second is the end of the source line extends beyond the
     bounds of the current function.  We need to use the slow code to
     examine instructions in that case.  */
  if (sal.end < func_end)
    return sal.end;
  else
    return 0;
}

static CORE_ADDR
sh_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  CORE_ADDR pc;
d724 6
a729 1
  pc = after_prologue (start_pc);
d731 2
a732 4
  /* If after_prologue returned a useful address, then use it.  Else
     fall back on the instruction skipping code.  */
  if (pc)
    return max (pc, start_pc);
d735 3
a737 3
  pc = sh_analyze_prologue (gdbarch, start_pc, (CORE_ADDR) -1, &cache, 0);
  if (!cache.uses_fp)
    return start_pc;
@


1.236
log
@gdb/
	Code cleanup: Make 1440 bytes of data segment read-only.
	* arch-utils.c (endian_enum): Make it const char *const [].
	* arm-tdep.c (fp_model_strings, arm_abi_strings, arm_mode_strings):
	Likewise.
	* breakpoint.c (always_inserted_enums): Likewise.
	* cli/cli-cmds.c (script_ext_enums): Likewise.
	* cli/cli-decode.c (add_setshow_enum_cmd, complete_on_enum): Make the
	enumlist parameter const char *const *.
	* cli/cli-decode.h (struct cmd_list_element): Make the enums field
	const char *const *.
	* command.h (complete_on_enum, add_setshow_enum_cmd): Make the enumlist
	parameter const char *const *.
	* cris-tdep.c (cris_modes): Make it const char *const [].
	* filesystem.c (target_file_system_kinds): Likewise.
	* i386-tdep.c (valid_flavors, valid_conventions): Likewise.
	* infrun.c (follow_fork_mode_kind_names, follow_exec_mode_names)
	(can_use_displaced_stepping_enum, scheduler_enums)
	(exec_direction_names): Likewise.
	* language.c (_initialize_language): Make the type_or_range_names and
	case_sensitive_names variables const char *const [].
	* mips-tdep.c (mips_abi_strings): Make it const char *const [].
	* python/python.c (python_excp_enums): Likewise.
	* remote.c (interrupt_sequence_modes): Likewise.
	* rs6000-tdep.c (powerpc_vector_strings): Likewise.
	* serial.c (logbase_enums): Likewise.
	* sh-tdep.c (sh_cc_enum): Likewise.
	* stack.c (print_frame_arguments_choices, print_entry_values_choices):
	Likewise.
	* symtab.c (multiple_symbols_modes): Likewise.
	* tui/tui-win.c (tui_border_kind_enums, tui_border_mode_enums):
	Likewise.
	* utils.c (internal_problem_modes): Likewise.
@
text
@d92 18
a109 3
  return ((func_type
	   && TYPE_CALLING_CONVENTION (func_type) == DW_CC_GNU_renesas_sh)
	  || sh_active_calling_convention == sh_cc_renesas);
@


1.235
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d62 1
a62 1
static const char *sh_cc_enum[] = {
@


1.234
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d3 1
a3 3
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.234.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1993-2005, 2007-2012 Free Software Foundation, Inc.
@


1.233
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d2638 1
@


1.232
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d2303 26
a2328 1
static void
d2332 1
a2332 1
  int base_regnum, portion;
d2334 1
d2337 2
a2338 3
    regcache_raw_read (regcache, BANK_REGNUM, buffer);
  else
  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
d2344 10
a2353 9
      for (portion = 0; portion < 2; portion++)
	regcache_raw_read (regcache, base_regnum + portion,
			   (temp_buffer
			    + register_size (gdbarch,
					     base_regnum) * portion));
      /* We must pay attention to the endiannes.  */
      sh_register_convert_to_virtual (reg_nr,
				      register_type (gdbarch, reg_nr),
				      temp_buffer, buffer);
d2360 2
a2361 5
      for (portion = 0; portion < 4; portion++)
	regcache_raw_read (regcache, base_regnum + portion,
			   ((char *) buffer
			    + register_size (gdbarch,
					     base_regnum) * portion));
d2363 2
@


1.231
log
@run copyright.sh for 2011.
@
text
@d22 2
a23 4
/*
   Contributed by Steve Chamberlain
   sac@@cygnus.com
 */
d55 1
a55 1
/* registers numbers shared with the simulator */
d83 1
a83 1
  /* Flag showing that a frame has been created in the prologue code. */
d204 1
a204 1
       the bank register (63). */
d244 1
a244 1
       the bank register (63). */
d333 1
a333 1
    /* pseudo bank register. */
d370 1
a370 1
    /* pseudo bank register. */
d410 1
a410 1
  /* 0xc3c3 is trapa #c3, and it works in big and little endian modes */
d442 1
a442 2
   Actually it can be more complicated than this but that's it, basically.
 */
d481 1
a481 1
		   make this entirely clear. */
d512 1
a512 1
/* The following instructions are used for epilogue testing. */
d541 1
a541 1
      /* See where the registers will be saved to */
d612 1
a612 1
		  /* MOVI20 is a 32 bit instruction! */
d650 1
a650 1
	     to an fp indirect address above fp + cache->sp_offset. */
d683 1
a683 1
	     so, note that before returning the current pc. */
d689 4
a692 3
#if 0				/* This used to just stop when it found an instruction that
				   was not considered part of the prologue.  Now, we just
				   keep going looking for likely instructions. */
d701 1
a701 1
/* Skip any prologue before the guts of a function */
d703 2
a704 2
/* Skip the prologue using the debug information. If this fails we'll
   fall back on the 'guess' method below. */
d743 1
a743 1
     fall back on the instruction skipping code. */
d768 1
a768 1
   remainder. If the size of the aggregate type is not a multiple of 4
d770 1
a770 1
   bytes. The value of the padding is undefined. For little-endian
d775 1
a775 1
   All other aggregate types are returned by address. The caller
d777 1
a777 1
   aggregate value in R2. The called function stores the result in
d800 1
a800 3
   memory.

*/
d873 1
a873 1
   stack.  This includes doubles, long longs, and larger aggregates. 
d903 1
a903 1
   to R7.   */
d905 1
a905 1
/* Helper function to justify value in register according to endianess. */
d914 1
a914 1
      /* value gets right-justified in the register or stack word */
d924 1
a924 1
/* Helper function to eval number of bytes to allocate on stack. */
d936 1
a936 1
   it's intended to work. */
d938 1
a938 1
/* This array stores which of the float arg registers are already in use. */
d941 1
a941 1
/* This function just resets the above array to "no reg used so far". */
d956 1
a956 1
   for the double register passing test (see the "argreg & 1" test below). */
d962 1
a962 1
  /* First search for the next free register. */
d968 1
a968 1
  /* No register left? */
d974 1
a974 1
      /* Doubles are always starting in a even register number. */
d984 1
a984 1
	  /* No register left? */
d988 1
a988 1
      /* Also mark the next register as used. */
d994 1
a994 1
      /* In little endian, gcc passes floats like this: f5, f4, f7, f6, ... */
d1081 1
a1081 1
  /* first force sp to a 4-byte alignment */
d1084 1
a1084 1
  /* make room on stack for args */
d1087 1
a1087 1
  /* Initialize float argument mechanism. */
d1100 1
a1100 1
         This also differs in different ABIs. */
d1103 1
a1103 1
      /* Find out the next register to use for a floating point value. */
d1127 1
a1127 1
	      /* The data goes entirely on the stack, 4-byte aligned. */
d1143 1
a1143 1
		 into the next register. */
d1151 2
a1152 1
		  regval = extract_unsigned_integer (val, reg_size, byte_order);
d1163 2
a1164 1
	  /* Store the value one register at a time or in one step on stack.  */
d1183 1
a1183 1
  /* Store return address. */
d1221 1
a1221 1
  /* first force sp to a 4-byte alignment */
d1224 1
a1224 1
  /* make room on stack for args */
d1237 1
a1237 1
	 This also differs in different ABIs. */
d1253 1
a1253 1
	         4-byte aligned. */
d1260 1
a1260 1
	      /* there's room in a register */
d1286 1
a1286 1
  /* Store return address. */
d1338 2
a1339 1
	  regcache_raw_read (regcache, regnum++, (char *) valbuf + len - 4 - i);
d1351 2
a1352 2
   depending on the type of the return value. In all the other cases
   the result is stored in r0, left-justified. */
d1425 1
a1425 1
/* Print the registers in a form similar to the E7000 */
d2226 1
a2226 1
   is little endian. When the user writes one of those registers, for
d2249 1
a2249 1
   because they are stored as 4 individual FP elements. */
d2281 1
a2281 1
/* For vectors of 4 floating point registers. */
d2292 1
a2292 1
/* For double precision floating point registers, i.e 2 fp regs.*/
d2317 1
a2317 1
      /* Build the value in the provided buffer. */
d2324 1
a2324 1
      /* We must pay attention to the endiannes. */
d2353 1
a2353 1
	 from the target/sim again. We're just invalidating the regcache
d2365 1
a2365 1
      /* We must pay attention to the endiannes. */
d2533 1
a2533 1
     actually the frame pointer of the calling frame. */
d2658 1
a2658 1
   destroys the function's stack frame. */
d2671 1
a2671 1
         means, they are below func_end. */
d2678 1
a2678 1
      /* First search forward until hitting an rts. */
d2687 1
a2687 1
         probably no "normal" epilogue and we bail out here. */
d2698 1
a2698 1
      /* Step over possible lds.l @@r15+,macl. */
d2705 1
a2705 1
      /* Step over possible lds.l @@r15+,pr. */
d2712 1
a2712 1
      /* Step over possible mov r14,r15. */
d2720 1
a2720 1
         instructions. */
d2882 1
a2882 1
      /* SH5 is handled entirely in sh64-tdep.c */
d2892 1
a2892 1
     provided. */
d2951 1
a2951 1
      /* doubles on sh2e and sh3e are actually 4 byte. */
d2996 1
a2996 1
      /* doubles on sh2e and sh3e are actually 4 byte. */
d3064 1
a3064 1
extern initialize_file_ftype _initialize_sh_tdep;	/* -Wmissing-prototypes */
@


1.230
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d4 2
a5 1
   2003, 2004, 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.229
log
@2009-10-21  Andrew Stubbs  <ams@@codesourcery.com>
	    Joel Brobecker  <brobecker@@adacore.com>

	* Makefile.in (HFILES_NO_SRCDIR): Remove shnbsd-tdep.h
	* configure.tgt (sh*-*-linux*): Add corelow.o to gdb_target_obs.
	* sh-linux-tdep.c: Include sh-tdep.h.
	(REGSx16): New macro.
	(gregs_table, fpregs_table): New variables.
	(sh_linux_init_abi): Set core_gregmap and fpregmap.
	* sh-tdep.c: Include regset.h.
	(sh_corefile_supply_regset): New function.
	(sh_corefile_collect_regset): New function.
	(sh_corefile_gregset, sh_corefile_fpregset): New variables.
	(sh_regset_from_core_section): New function.
	(sh_gdbarch_init): Set up tdep value.
	Call set_gdbarch_regset_from_core_section.
	* sh-tdep.h (PC_REGNUM): New enum value.
	(struct sh_corefile_regs): New type.
	(sh_corefile_gregset): Export variable.
	(sh_corefile_supply_regset): New prototype.
	(sh_corefile_collect_regset): New prototype.
	* shnbsd-tdep.c: Remove include of regcache.h, gdb_assert.h and
	shnbsd-tdep.h.
	(regmap): Use new definition using struct sh_corefile_regs.
	(shnbsd_supply_gregset, shnbsd_collect_gregset): Delete.
	(shnbsd_gregset): Delete.
	(shnbsd_regset_from_core_section): Delete.
	(shnbsd_supply_reg, shnbsd_fill_reg): Use new regset interface.
	(shnbsd_init_abi): Set core_gregmap.
	(shnbsd_supply_reg): Delete.
	(shnbsd_fill_reg): Delete.
	(SHNBSD_SIZEOF_GREGS): Move ...
	* shnbsd-nat.c (SHNBSD_SIZEOF_GREGS): ... to here.
	Remove include of shnbsd-tdep.h.
	(shnbsd_fetch_inferior_registers): Replace shnbsd_supply_reg call
	with sh_corefile_supply_regset.
	(shnbsd_store_inferior_registers): Replace shnbsd_fill_reg call with
	sh_corefile_collect_regset.
	* shnbsd-tdep.h: Delete file.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.228
log
@2009-10-14  Andrew Stubbs  <ams@@codesourcery.com>

	* sh-tdep.c (sh_gdbarch_init): Add show_regs settings for
	bfd_mach_sh3_nommu, bfd_mach_sh2a_nofpu_or_sh3_nommu,
	bfd_mach_sh2a_or_sh3e, bfd_mach_sh2a_or_sh4, bfd_mach_sh4_nommu_nofpu,
	and bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu.
	Move bfd_mach_sh2a_or_sh4 to use the same configuration as
	bfd_mach_sh4.
@
text
@d46 1
d2742 85
d2833 1
d2893 2
a2894 1
  gdbarch = gdbarch_alloc (&info, NULL);
d2938 2
@


1.227
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d2765 2
d2771 1
d2782 1
d2787 1
d2789 1
d2923 1
a2937 1
    case bfd_mach_sh2a_or_sh4:
@


1.226
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d54 1
a54 1
#include "elf/dwarf2.h"
@


1.225
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d523 2
a524 1
sh_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
d527 1
d541 1
a541 1
      inst = read_memory_unsigned_integer (pc, 2);
d585 1
a585 1
		    read_memory_integer ((pc + 4) + offset, 2);
d599 2
a600 1
		    read_memory_integer (((pc & 0xfffffffc) + 4) + offset, 4);
d615 2
a616 1
		  sav_offset |= read_memory_unsigned_integer (pc, 2);
d655 1
a655 1
	      inst = read_memory_integer (pc, 2);
d685 1
a685 1
	  inst = read_memory_integer (pc + 2, 2);
d748 1
a748 1
  pc = sh_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache, 0);
d1062 1
d1138 1
a1138 1
	      regval = extract_unsigned_integer (val, reg_size);
d1153 1
a1153 1
		  regval = extract_unsigned_integer (val, reg_size);
d1161 1
a1161 1
	      regval = extract_unsigned_integer (val, reg_size);
d1175 1
a1175 1
	write_memory_unsigned_integer (sp -= 4, 4, struct_addr);
d1202 1
d1262 1
a1262 1
	      regval = extract_unsigned_integer (val, reg_size);
d1278 1
a1278 1
	write_memory_unsigned_integer (sp -= 4, 4, struct_addr);
d1304 2
d1315 1
a1315 1
      store_unsigned_integer (valbuf, len, c);
d1356 2
d1363 1
a1363 1
      val = extract_unsigned_integer (valbuf, len);
d2517 1
d2543 1
a2543 1
      sh_analyze_prologue (cache->pc, current_pc, cache, fpscr);
d2556 1
a2556 2
		    (this_frame,
		     gdbarch_sp_regnum (get_frame_arch (this_frame)));
d2661 1
d2679 1
a2679 1
	     && !IS_RTS (read_memory_unsigned_integer (addr, 2)))
d2687 3
a2689 2
      inst = read_memory_unsigned_integer (addr - 2, 2);
      if (IS_RESTORE_FP (read_memory_unsigned_integer (addr - 2, 2)))
d2691 2
a2692 1
      else if (!IS_RESTORE_FP (read_memory_unsigned_integer (addr + 2, 2)))
d2695 1
a2695 1
      inst = read_memory_unsigned_integer (addr - 2, 2);
d2701 1
a2701 1
	  inst = read_memory_unsigned_integer (addr - 2, 2);
d2708 1
a2708 1
	  inst = read_memory_unsigned_integer (addr - 2, 2);
d2715 1
a2715 1
	  inst = read_memory_unsigned_integer (addr - 2, 2);
d2724 1
a2724 1
	  inst = read_memory_unsigned_integer (addr - 2, 2);
d2732 2
a2733 1
	  && IS_MOVI20 (read_memory_unsigned_integer (addr - 4, 2)))
@


1.224
log
@	* gdbtypes.c (lookup_array_range_type): Add prototype.
	(lookup_string_range_type): Likewise.
	* gdbtypes.c (lookup_array_range_type): New function.
	(lookup_string_range_type): Likewise.

	* ax-gdb.c (gen_repeat): Use lookup_array_range_type.
	* parse.c (follow_types): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
	* value.c (allocate_repeat_value): Likewise.
	* valops.c (value_array, value_cstring): Likewise.
	* valops.c (value_string): Use lookup_string_range_type.
@
text
@d1421 3
a1423 3
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum
					   (get_frame_arch (frame)))),
d1461 3
a1463 3
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum
					   (get_frame_arch (frame)))),
d1506 2
a1507 2
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum (gdbarch))),
d1591 2
a1592 2
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum (gdbarch))),
d1706 3
a1708 3
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum
					   (get_frame_arch (frame)))),
d1783 2
a1784 2
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum (gdbarch))),
d1865 3
a1867 3
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum
					   (get_frame_arch (frame)))),
d1932 2
a1933 2
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum (gdbarch))),
d2016 3
a2018 3
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum
					   (get_frame_arch (frame)))),
d2062 3
a2064 3
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum
					   (get_frame_arch (frame)))),
@


1.223
log
@	Silence a few -Wmissing-prototypes warnings.

	PR build/9877:
        * alpha-linux-tdep.c (alpha_linux_regset_from_core_section): Make
	it static.
        * alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Declare.
        * amd64fbsd-tdep.c (amd64fbsd_init_abi): Make it static.
        * amd64nbsd-tdep.c (_initialize_amd64nbsd_ndep): Rename to ...
	(_initialize_amd64nbsd_tdep): ... this.
	* arm-linux-tdep.c (arm_linux_software_single_step): Make it static.
	(_initialize_arm_linux_tdep): Declare.
	* armbsd-tdep.c (armbsd_fpreg_offset): Make it static.
	* armnbsd-tdep.c (_initialize_arm_netbsd_tdep): Declare.
	* armobsd-tdep.c (_initialize_armobsd_tdep): Declare.
	* avr-tdep.c (avr_return_value): Make it static.
	(avr_frame_unwind_cache): Ditto.
	* bsd-uthread.c (bsd_uthread_inferior_created): Ditto.
	(bsd_uthread_solib_loaded): Ditto.
	(bsd_uthread_solib_unloaded): Ditto.
	(bsd_uthread_target): Ditto.
	(_initialize_bsd_uthread): Declare.
	* cris-tdep.c (crisv32_single_step_through_delay): Make it static.
	(cris_frame_unwind_cache): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_use_struct_convention): Ditto.
	(h8300h_use_struct_convention): Ditto.
	* hppa-tdep.c (hppa_sign_extend, hppa_low_hppa_sign_extend):
	Ditto.
	* hppa-tdep.h (hppa_low_sign_extend, hppa_sign_extend): Delete
	declarations.
	* hppabsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_find_global_pointer): Make it static.
	* hppabsd-tdep.h: New.
	* hppanbsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Remove declaration.
	(_initialize_hppabsd_tdep): Remove declaration.
	(_initialize_hppanbsd_tdep): Declare.
	* hppaobsd-tdep.c: Include hppabsd-tdep.h.
	(hppabsd_init_abi): Delete declaration.
	(hppaobsd_init_abi): Make it static.
	* i386-nto-tdep.c (_initialize_i386nto_tdep): Declare.
	* i386nbsd-tdep.c (_initialize_i386nbsd_tdep): Declare.
	* ia64-linux-tdep.c (_initialize_ia64_linux_tdep): Declare.
	* ia64-tdep.c (ia64_register_reggroup_p): Make it static.
	* iq2000-tdep.c (_initialize_iq2000_tdep): Declare.
	* m32c-tdep.c (m32c_register_reggroup_p): Make it static.
	(m32c_analyze_prologue, m32c_virtual_frame_pointer): Ditto.
	(_initialize_m32c_tdep): Declare.
	* m32r-rom.c (_initialize_m32r_rom): Declare.
	* m32r-tdep.c (m32r_skip_prologue): Make it static.
	(m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache): Make it static.
	(m68hc11_return_value): Ditto.
	* m68klinux-tdep.c (_initialize_m68k_linux_tdep): Declare.
	* m88k-tdep.c (m88k_frame_cache): Make it static.
	* mep-tdep.c (mep_gdb_print_insn): Ditto.
	(mep_return_value): Ditto.
	(_initialize_mep_tdep): Declare.
	* mips-irix-tdep.c (_initialize_mips_irix_tdep): Declare.
	* mips-linux-tdep.c (supply_64bit_reg): Make it static.
	(mips_linux_syscall_next_pc): Ditto.
	(_initialize_mips_linux_tdep): Declare.
	* mips-tdep.c (mips_single_step_through_delay): Make it static.
	* mipsnbsd-tdep.c (_initialize_mipsnbsd_tdep): Declare.
	* mn10300-linux-tdep.c (_initialize_mn10300_linux_tdep): Declare.
	* mn10300-tdep.c (_initialize_mn10300_tdep): Declare.
	* mt-tdep.c (_initialize_mt_tdep): Declare.
	* nbsd-tdep.c: Include nbsd-tdep.h.
	* nto-tdep.c (find_load_phdr): Make it static.
	(_initialize_nto_tdep): Declare.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Make it
	static.
	(_initialize_ppc_linux_tdep): Declare.
	* remote-m32r-sdi.c (m32r_can_use_hw_watchpoint)
	(m32r_insert_watchpoint, m32r_remove_watchpoint)
	(m32r_stopped_data_address, m32r_stopped_by_watchpoint): Make
	static.
	* rs6000-aix-tdep.c (_initialize_rs6000_aix_tdep): Declare.
	* rs6000-nat.c: Include xcoffread.h.
	(find_toc_address): Don't extern declare get_toc_offset.  Adjust
	to call xcoff_get_to_offset.
	* rs6000-tdep.c (ppc_vsx_support_p, ppc_displaced_step_fixup)
	(rs6000_skip_main_prologue, rs6000_in_solib_return_trampoline)
	(rs6000_skip_trampoline_code): Make static.
	* s390-tdep.c (s390_regset_from_core_section): Ditto.
	* sh-tdep.c (sh_register_reggroup_p): Ditto.
	* shnbsd-tdep.c (shnbsd_regset_from_core_section): Ditto.
	(_initialize_shnbsd_tdep): Declare.
	* solib-frv.c (displacement_from_map): Make static.
	(_initialize_frv_solib): Declare.
	* solib-irix.c (fetch_lm_info): Make static.
	(_initialize_irix_solib): Declare.
	* solib-som.c: Include solib-som.h.
	(som_solib_select): Line break.
	* sparc-tdep.c (sparc_regset_from_core_section): Make static.
	* sparcnbsd-tdep.c (_initialize_sparnbsd_tdep): Rename to ...
	(_initialize_sparcnbsd_tdep): ... this.
	* spu-tdep.c (spu_software_single_step): Make it static.
	(_initialize_spu_tdep): Declare.
	* vax-tdep.c (vax_frame_cache): Make it static.
	* xcoffread.c: Include xcoffread.h.
	(get_toc_offset): Rename to ...
	(xcoff_get_toc_offset): ... this.
	(_initialize_xcoffread): Declare.
	* xcoffread.h: New.
	* xtensa-linux-tdep.c (_initialize_xtensa_linux_tdep): Declare.
	* xtensa-tdep.c (xtensa_skip_prologue, xtensa_derive_tdep): Make
	static.
	(_initialize_xtensa_tdep): Declare.
@
text
@d2149 2
a2150 4
  struct type *temp;

  temp = create_range_type (NULL, builtin_type_int32, 0, high);
  return create_array_type (NULL, builtin_type (gdbarch)->builtin_float, temp);
@


1.222
log
@        Updated copyright notices for most files.
@
text
@d2179 1
a2179 1
int
@


1.221
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.220
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@d2127 1
a2127 1
    return builtin_type_float;
d2129 1
a2129 1
    return builtin_type_double;
d2131 1
a2131 1
    return builtin_type_int;
d2141 1
a2141 1
    return builtin_type_float;
d2143 1
a2143 1
    return builtin_type_int;
d2147 1
a2147 1
sh_sh4_build_float_register_type (int high)
d2152 1
a2152 1
  return create_array_type (NULL, builtin_type_float, temp);
d2160 1
a2160 1
    return builtin_type_float;
d2162 1
a2162 1
    return builtin_type_double;
d2164 1
a2164 1
    return sh_sh4_build_float_register_type (3);
d2166 1
a2166 1
    return builtin_type_int;
d2172 1
a2172 1
  return builtin_type_int;
@


1.219
log
@	* m68hc11-tdep.c (gdb_print_insn_m68hc11): Use info->arch
	instead of current_gdbarch.

	* sh64-tdep.c (gdb_print_insn_sh64): Remove.
	(sh64_gdbarch_init): Install print_insn_sh64 directly.
	* sh-tdep.c (gdb_print_insn_sh): Remove.
	(sh_gdbarch_init): Install print_insn_sh directly.

	* mips-tdep.c (gdb_print_insn_mips): Do not check mips_abi
	from current_gdbarch.
	(gdb_print_insn_mips_n32, gdb_print_insn_mips_n64): New functions.
	(mips_gdbarch_init): Install them instead of gdb_print_insn_mips
	depending on mips_abi.
@
text
@d2151 1
a2151 1
  temp = create_range_type (NULL, builtin_type_int, 0, high);
@


1.218
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@a521 8
/* Disassemble an instruction.  */
static int
gdb_print_insn_sh (bfd_vma memaddr, disassemble_info * info)
{
  info->endian = gdbarch_byte_order (current_gdbarch);
  return print_insn_sh (memaddr, info);
}

d2810 1
a2810 1
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh);
@


1.217
log
@	* alphafbsd-tdep.c: Update for unwinder changes.
	* alpha-linux-tdep.c: Likewise.
	* alphanbsd-tdep.c: Likewise.
	* alphaobsd-tdep.c: Likewise.
	* avr-tdep.c: Likewise.
	* cris-tdep.c: Likewise.
	* frv-linux-tdep.c: Likewise.
	* frv-tdep.c: Likewise.
	* h8300-tdep.c: Likewise.
	* hppa-linux-tdep.c: Likewise.
	* iq2000-tdep.c: Likewise.
	* m32c-tdep.c: Likewise.
	* m32r-linux-tdep.c: Likewise.
	* m32r-tdep.c: Likewise.
	* m68hc11-tdep.c: Likewise.
	* mep-tdep.c: Likewise.
	* mn10300-tdep.c: Likewise.
	* mt-tdep.c: Likewise.
	* score-tdep.c: Likewise.
	* sh64-tdep.c: Likewise.
	* sh-tdep.c: Likewise.
	* sparc64fbsd-tdep.c: Likewise.
	* sparc64nbsd-tdep.c: Likewise.
	* sparc64obsd-tdep.c: Likewise.
	* v850-tdep.c: Likewise.
	* vaxobsd-tdep.c: Likewise.
	* vax-tdep.c: Likewise.
	* xstormy16-tdep.c: Likewise.
@
text
@d1083 1
a1083 1
      && (TYPE_FLAGS (func_type) & TYPE_FLAG_VARARGS))
d1220 1
a1220 1
      && (TYPE_FLAGS (func_type) & TYPE_FLAG_VARARGS))
@


1.216
log
@	* dwarf2-frame.c (read_reg): Expect this_frame in the baton.
	(execute_stack_op): Put this_frame in the baton.
	(execute_cfa_program): Take this_frame.
	(struct dwarf2_frame_ops): Update comment for signal_frame_p.
	(dwarf2_frame_default_init_reg, dwarf2_frame_init_reg)
	(dwarf2_frame_signal_frame_p, dwarf2_frame_cache)
	(dwarf2_frame_this_id): Adjust to work on this_frame.
	(dwarf2_signal_frame_this_id): Delete.
	(dwarf2_frame_prev_register): Update signature.  Use new frame
	unwind methods.
	(dwarf2_frame_sniffer): Update signature.  Expect this_frame.
	(dwarf2_frame_unwind, dwarf2_signal_frame_unwind): Add
	dwarf2_frame_sniffer.
	(dwarf2_append_unwinders): New.
	(dwarf2_frame_base_address, dwarf2_frame_base_sniffer): Expect
	this_frame.
	* sparc-tdep.c (sparc32_dwarf2_struct_return_p)
	(sparc32_dwarf2_frame_init_reg): Expect this_frame.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Likewise.
	* rs6000-tdep.c (ppc_dwarf2_frame_init_reg): Likewise.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* dwarf2-frame.h (dwarf2_frame_sniffer): Delete declaration.
	(dwarf2_append_unwinders): Declare.
	(dwarf2_frame_base_sniffer): Update declaration.
	* i386-linux-tdep.c (i386_linux_dwarf_signal_frame_p): Expect
	this_frame.
@
text
@d2515 1
a2515 1
sh_frame_cache (struct frame_info *next_frame, void **this_cache)
d2532 1
a2532 1
  cache->base = frame_unwind_register_unsigned (next_frame, FP_REGNUM);
d2536 2
a2537 2
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
  current_pc = frame_pc_unwind (next_frame);
d2541 1
a2541 1
      fpscr = frame_unwind_register_unsigned (next_frame, FPSCR_REGNUM);
d2554 3
a2556 3
      cache->base = frame_unwind_register_unsigned
		    (next_frame,
		     gdbarch_sp_regnum (get_frame_arch (next_frame)));
d2572 3
a2574 5
static void
sh_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			int regnum, int *optimizedp,
			enum lval_type *lvalp, CORE_ADDR *addrp,
			int *realnump, gdb_byte *valuep)
d2576 2
a2577 2
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);
d2582 1
a2582 12
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
	}
      return;
    }
d2591 2
a2592 13
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (gdbarch, regnum));
	}
      return;
    }
d2594 1
a2594 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, (*realnump), valuep);
d2598 1
a2598 1
sh_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2601 1
a2601 1
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);
d2613 3
a2615 1
  sh_frame_prev_register
a2617 6
static const struct frame_unwind *
sh_frame_sniffer (struct frame_info *next_frame)
{
  return &sh_frame_unwind;
}

d2633 1
a2633 1
sh_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2635 3
a2637 2
  return frame_id_build (sh_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
d2641 1
a2641 1
sh_frame_base_address (struct frame_info *next_frame, void **this_cache)
d2643 1
a2643 1
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);
d2833 1
a2833 1
  set_gdbarch_unwind_dummy_id (gdbarch, sh_unwind_dummy_id);
d2944 2
a2945 2
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, sh_frame_sniffer);
@


1.215
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d2445 1
a2445 1
			  struct frame_info *next_frame)
@


1.214
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d54 1
d58 14
d91 8
d809 1
a809 1
sh_use_struct_convention (int gcc_p, struct type *type)
d814 5
d844 9
d964 1
a964 1
sh_next_flt_argreg (struct gdbarch *gdbarch, int len)
d983 4
a986 1
	  flt_argreg_array[argreg] = 1;
d997 2
a998 1
  else if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
d1070 1
d1077 8
a1088 4
  if (struct_return)
    regcache_cooked_write_unsigned (regcache,
				    STRUCT_RETURN_REGNUM, struct_addr);

d1111 8
a1118 1
	flt_argreg = sh_next_flt_argreg (gdbarch, len);
d1129 2
a1130 1
	                            || pass_on_stack)))
d1173 13
d1208 1
d1212 10
a1221 1
  int len, reg_size;
a1225 4
  if (struct_return)
    regcache_cooked_write_unsigned (regcache,
				    STRUCT_RETURN_REGNUM, struct_addr);

d1238 11
d1251 2
a1252 1
	  if (argreg > ARGLAST_REGNUM)
d1275 13
d1393 2
a1394 2
sh_return_value_nofpu (struct gdbarch *gdbarch, struct type *type,
		       struct regcache *regcache,
d1397 2
a1398 1
  if (sh_use_struct_convention (0, type))
d1408 2
a1409 2
sh_return_value_fpu (struct gdbarch *gdbarch, struct type *type,
		     struct regcache *regcache,
d1412 2
a1413 1
  if (sh_use_struct_convention (0, type))
d2982 14
d3006 16
@


1.213
log
@	Updated copyright notices for most files.
@
text
@d713 1
a713 1
sh_skip_prologue (CORE_ADDR start_pc)
@


1.212
log
@2007-11-19  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_sim_regno): Add gdbarch as parameter.
	* gdbarch.{c,h}: Regenerate.

	* arch-utils.h (legacy_register_sim_regno): Add gdbarch as parameter.
	* score-tdep.c (score_register_sim_regno): Likewise.
	* sim-regno.h (one2one_register_sim_regno): Likewise.

	* arch-utils.c (legacy_register_sim_regno): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* sh-tdep.c (sh_sh2a_register_sim_regno)
	(sh_dsp_register_sim_regno): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* mips-tdep.c (mips_register_sim_regno): Likewise.
	* m32c-tdep.c (m32c_register_sim_regno): Likewise.
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* arm-tdep.c (arm_register_sim_regno): Likewise.
	* remote-sim.c (one2one_register_sim_regno): Likewise.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.211
log
@*** empty log message ***
@
text
@d2289 1
a2289 1
sh_dsp_register_sim_regno (int nr)
d2291 2
a2292 2
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
d2307 1
a2307 1
sh_sh2a_register_sim_regno (int nr)
d2332 1
a2332 1
  return legacy_register_sim_regno (nr);
@


1.210
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d385 1
a385 1
sh_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d396 1
a396 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.209
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(sh_register_reggroup_p, sh_dwarf2_frame_init_reg): Replace
	current_gdbarch by gdbarch.
	(sh_generic_show_regs, sh3_show_reg, sh2e_show_regs, sh2a_show_regs)
	(sh2a_nofpu_show_regs, sh3e_show_regs, sh3_dsp_show_regs)
	(sh4_show_regs, sh4_nofpu_show_regs, sh_dsp_show_regs, sh_frame_cache)
	(sh_frame_prev_register, sh_unwind_sp, sh_unwind_pc): Use FRAME to
	recognize current architecture.
@
text
@d77 1
a77 1
sh_sh_register_name (int reg_nr)
d99 1
a99 1
sh_sh3_register_name (int reg_nr)
d121 1
a121 1
sh_sh3e_register_name (int reg_nr)
d143 1
a143 1
sh_sh2e_register_name (int reg_nr)
d165 1
a165 1
sh_sh2a_register_name (int reg_nr)
d205 1
a205 1
sh_sh2a_nofpu_register_name (int reg_nr)
d245 1
a245 1
sh_sh_dsp_register_name (int reg_nr)
d267 1
a267 1
sh_sh3_dsp_register_name (int reg_nr)
d290 1
a290 1
sh_sh4_register_name (int reg_nr)
d327 1
a327 1
sh_sh4_nofpu_register_name (int reg_nr)
d362 1
a362 1
sh_sh4al_dsp_register_name (int reg_nr)
d876 1
a876 1
sh_justify_value_in_reg (struct value *val, int len)
d884 1
a884 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d927 1
a927 1
sh_next_flt_argreg (int len)
d957 1
a957 1
  else if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d1056 1
a1056 1
      val = sh_justify_value_in_reg (args[argnum], len);
d1065 1
a1065 1
	flt_argreg = sh_next_flt_argreg (len);
d1163 1
a1163 1
      val = sh_justify_value_in_reg (args[argnum], len);
d1233 1
d1237 1
a1237 1
      int i, regnum = gdbarch_fp0_regnum (current_gdbarch);
d1239 1
a1239 1
	if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d1278 1
d1282 1
a1282 1
      int i, regnum = gdbarch_fp0_regnum (current_gdbarch);
d1284 1
a1284 1
	if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d2182 1
a2182 1
fv_reg_base_num (int fv_regnum)
d2186 1
a2186 1
  fp_regnum = gdbarch_fp0_regnum (current_gdbarch)
d2193 1
a2193 1
dr_reg_base_num (int dr_regnum)
d2197 1
a2197 1
  fp_regnum = gdbarch_fp0_regnum (current_gdbarch)
d2214 1
a2214 1
      base_regnum = dr_reg_base_num (reg_nr);
d2230 1
a2230 1
      base_regnum = fv_reg_base_num (reg_nr);
d2262 1
a2262 1
      base_regnum = dr_reg_base_num (reg_nr);
d2277 1
a2277 1
      base_regnum = fv_reg_base_num (reg_nr);
@


1.208
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1095 1
a1095 1
	      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE
d1124 1
a1124 1
				  gdbarch_sp_regnum (current_gdbarch), sp);
d1195 1
a1195 1
				  gdbarch_sp_regnum (current_gdbarch), sp);
d1328 2
a1329 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1368 2
a1369 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1409 1
d1413 1
a1413 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1454 1
a1454 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 0),
d1456 1
a1456 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 1),
d1458 1
a1458 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 2),
d1460 1
a1460 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 3),
d1462 1
a1462 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 4),
d1464 1
a1464 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 5),
d1466 1
a1466 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 6),
d1468 1
a1468 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 7));
d1472 1
a1472 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 8),
d1474 1
a1474 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 9),
d1476 1
a1476 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 10),
d1478 1
a1478 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 11),
d1480 1
a1480 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 12),
d1482 1
a1482 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 13),
d1484 1
a1484 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 14),
d1486 1
a1486 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 15));
d1492 1
d1498 1
a1498 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1541 1
a1541 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 0),
d1543 1
a1543 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 1),
d1545 1
a1545 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 2),
d1547 1
a1547 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 3),
d1549 1
a1549 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 4),
d1551 1
a1551 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 5),
d1553 1
a1553 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 6),
d1555 1
a1555 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 7));
d1560 1
a1560 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 8),
d1562 1
a1562 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 9),
d1564 1
a1564 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 10),
d1566 1
a1566 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 11),
d1568 1
a1568 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 12),
d1570 1
a1570 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 13),
d1572 1
a1572 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 14),
d1574 1
a1574 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 15));
d1613 2
a1614 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1686 1
d1690 1
a1690 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1731 1
a1731 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 0),
d1733 1
a1733 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 1),
d1735 1
a1735 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 2),
d1737 1
a1737 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 3),
d1739 1
a1739 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 4),
d1741 1
a1741 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 5),
d1743 1
a1743 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 6),
d1745 1
a1745 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 7));
d1749 1
a1749 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 8),
d1751 1
a1751 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 9),
d1753 1
a1753 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 10),
d1755 1
a1755 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 11),
d1757 1
a1757 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 12),
d1759 1
a1759 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 13),
d1761 1
a1761 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 14),
d1763 1
a1763 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 15));
d1772 2
a1773 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1833 1
d1839 1
a1839 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1881 1
a1881 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 0),
d1883 1
a1883 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 1),
d1885 1
a1885 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 2),
d1887 1
a1887 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 3),
d1889 1
a1889 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 4),
d1891 1
a1891 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 5),
d1893 1
a1893 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 6),
d1895 1
a1895 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 7));
d1900 1
a1900 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 8),
d1902 1
a1902 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 9),
d1904 1
a1904 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 10),
d1906 1
a1906 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 11),
d1908 1
a1908 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 12),
d1910 1
a1910 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 13),
d1912 1
a1912 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 14),
d1914 1
a1914 1
	      (frame, gdbarch_fp0_regnum (current_gdbarch) + 15));
d1923 2
a1924 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1969 2
a1970 1
					 gdbarch_pc_regnum (current_gdbarch))),
d2031 1
a2031 1
  if ((reg_nr >= gdbarch_fp0_regnum (current_gdbarch)
d2045 1
a2045 1
  if ((reg_nr >= gdbarch_fp0_regnum (current_gdbarch)
d2064 1
a2064 1
  if ((reg_nr >= gdbarch_fp0_regnum (current_gdbarch)
d2089 2
a2090 2
  if (gdbarch_register_name (current_gdbarch, regnum) == NULL
      || *gdbarch_register_name (current_gdbarch, regnum) == '\0')
d2346 1
a2346 1
  if (regnum == gdbarch_pc_regnum (current_gdbarch))
d2350 1
a2350 1
  else if (regnum == gdbarch_sp_regnum (current_gdbarch))
d2453 2
a2454 1
		    (next_frame, gdbarch_sp_regnum (current_gdbarch));
d2476 1
d2481 1
a2481 1
  if (regnum == gdbarch_sp_regnum (current_gdbarch) && cache->saved_sp)
d2498 1
a2498 1
  if (regnum == gdbarch_pc_regnum (current_gdbarch))
d2511 1
a2511 1
		       register_size (current_gdbarch, regnum));
d2553 1
a2553 1
					 gdbarch_sp_regnum (current_gdbarch));
d2560 1
a2560 1
					 gdbarch_pc_regnum (current_gdbarch));
@


1.207
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Remove.
	* sh-tdep.c (sh_extract_struct_value_address): Remove.
	(sh_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* sh64-tdep.c (sh64_extract_struct_value_address): Remove.
	(sh64_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* ia64-tdep.c (ia64_extract_struct_value_address): Remove.
	(ia64_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* frv-tdep.c (frv_extract_struct_value_address): Remove.
	(frv_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.206
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a817 12
/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */
static CORE_ADDR
sh_extract_struct_value_address (struct regcache *regcache)
{
  ULONGEST addr;

  regcache_cooked_read_unsigned (regcache, STRUCT_RETURN_REGNUM, &addr);
  return addr;
}

a2741 2
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
					    sh_extract_struct_value_address);
@


1.205
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d1137 2
a1138 1
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp);
d1208 2
a1209 1
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp);
d1250 1
a1250 1
      int i, regnum = FP0_REGNUM;
d1294 1
a1294 1
      int i, regnum = FP0_REGNUM;
d1341 2
a1342 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1380 2
a1381 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1423 2
a1424 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1464 16
a1479 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 0),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 1),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 2),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 3),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 4),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 5),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 6),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 7));
d1482 16
a1497 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 8),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 9),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 10),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 11),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 12),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 13),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 14),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 15));
d1507 2
a1508 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1550 16
a1565 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 0),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 1),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 2),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 3),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 4),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 5),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 6),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 7));
d1569 16
a1584 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 8),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 9),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 10),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 11),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 12),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 13),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 14),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 15));
d1622 2
a1623 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1697 2
a1698 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1738 16
a1753 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 0),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 1),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 2),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 3),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 4),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 5),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 6),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 7));
d1756 16
a1771 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 8),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 9),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 10),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 11),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 12),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 13),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 14),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 15));
d1779 2
a1780 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1844 2
a1845 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1886 16
a1901 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 0),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 1),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 2),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 3),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 4),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 5),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 6),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 7));
d1905 16
a1920 8
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 8),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 9),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 10),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 11),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 12),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 13),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 14),
     (long) get_frame_register_unsigned (frame, FP0_REGNUM + 15));
d1928 2
a1929 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1973 2
a1974 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d2035 1
a2035 1
  if ((reg_nr >= FP0_REGNUM
d2049 1
a2049 1
  if ((reg_nr >= FP0_REGNUM
d2068 1
a2068 1
  if ((reg_nr >= FP0_REGNUM
d2188 2
a2189 1
  fp_regnum = FP0_REGNUM + (fv_regnum - FV0_REGNUM) * 4;
d2199 2
a2200 1
  fp_regnum = FP0_REGNUM + (dr_regnum - DR0_REGNUM) * 2;
d2350 1
a2350 1
  if (regnum == PC_REGNUM)
d2354 1
a2354 1
  else if (regnum == SP_REGNUM)
d2456 2
a2457 1
      cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2483 1
a2483 1
  if (regnum == SP_REGNUM && cache->saved_sp)
d2500 1
a2500 1
  if (regnum == PC_REGNUM)
d2554 2
a2555 1
  return frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2561 2
a2562 1
  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
@


1.204
log
@	* mips-tdep.c (mips16_scan_prologue): Replace read_next_frame_reg
	by frame_unwind_register_signed calls.
	(mips32_scan_prologue): Likewise.  Skip analysis of alloca stack
	frame allocations when called with NULL NEXT_FRAME parameter.
	(read_next_frame_reg): Remove.

	* sh-tdep.c (sh_analyze_prologue): Add FPSCR parameter.  Use it
	instead of reading the FPSCR register.
	(sh_frame_cache): Pass unwound FPSCR register value to
	sh_analyze_prologue.
	(sh_skip_prologue): Pass dummy FPSCR value to sh_analyze_prologue.

	* v850-tdep.c (v850_analyze_prologue): Add CTBP parameter.  Use it
	instead of reading the CTBP register.
	(v850_frame_cache): Pass unwound CTBP register value to
	v850_analyze_prologue.
@
text
@a2671 2
  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);

@


1.203
log
@	* sh-tdep.h (sh_show_regs): Add FRAME parameter.
	* sh-tdep.c (sh_show_regs): Likewise.
	(sh_show_regs_command): Pass current frame to sh_show_regs routine.
	(sh_generic_show_regs): Add FRAME parameter.  Use register
	values from that frame instead of calling read_register.
	(sh3_show_regs, sh2e_show_regs, sh2a_show_regs, sh2a_nofpu_show_regs,
	sh3e_show_regs, sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Likewise.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs,
	sh64_show_regs): Likewise.
@
text
@d511 1
a511 1
		     struct sh_frame_cache *cache)
d618 1
a618 1
	  if (read_register (FPSCR_REGNUM) & FPSCR_SZ)
d731 1
a731 1
  pc = sh_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache);
d2363 5
a2367 1
    sh_analyze_prologue (cache->pc, current_pc, cache);
@


1.202
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d59 1
a59 1
static void (*sh_show_regs) (void);
d1335 1
a1335 1
sh_generic_show_regs (void)
d1337 12
a1348 11
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx                       MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1352 18
a1369 9
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1373 18
a1390 16
sh3_show_regs (void)
{
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx                       MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
  printf_filtered ("     SSR %08lx      SPC %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d1394 18
a1411 9
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1414 64
d1480 23
a1502 19
sh2e_show_regs (void)
{
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx                       MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
  printf_filtered (
	"     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM),
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d1506 95
a1600 194
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
}

static void
sh2a_show_regs (void)
{
  int pr = read_register (FPSCR_REGNUM) & 0x80000;
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx      TBR %08lx     MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (TBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
  printf_filtered (
	"     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM),
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));

  printf_filtered ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0), (long) read_register (1),
		   (long) read_register (2), (long) read_register (3),
		   (long) read_register (4), (long) read_register (5),
		   (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered (
	(pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	    : "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered (
	(pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	    : "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
  printf_filtered ("BANK=%-3d\n", (int) read_register (BANK_REGNUM));
  printf_filtered (
	"R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (R0_BANK0_REGNUM + 0),
		   (long) read_register (R0_BANK0_REGNUM + 1),
		   (long) read_register (R0_BANK0_REGNUM + 2),
		   (long) read_register (R0_BANK0_REGNUM + 3),
		   (long) read_register (R0_BANK0_REGNUM + 4),
		   (long) read_register (R0_BANK0_REGNUM + 5),
		   (long) read_register (R0_BANK0_REGNUM + 6),
		   (long) read_register (R0_BANK0_REGNUM + 7));
  printf_filtered ("R8b-R14b %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (R0_BANK0_REGNUM + 8),
		   (long) read_register (R0_BANK0_REGNUM + 9),
		   (long) read_register (R0_BANK0_REGNUM + 10),
		   (long) read_register (R0_BANK0_REGNUM + 11),
		   (long) read_register (R0_BANK0_REGNUM + 12),
		   (long) read_register (R0_BANK0_REGNUM + 13),
		   (long) read_register (R0_BANK0_REGNUM + 14));
  printf_filtered ("MACHb=%08lx IVNb=%08lx PRb=%08lx GBRb=%08lx MACLb=%08lx\n",
		   (long) read_register (R0_BANK0_REGNUM + 15),
		   (long) read_register (R0_BANK0_REGNUM + 16),
		   (long) read_register (R0_BANK0_REGNUM + 17),
		   (long) read_register (R0_BANK0_REGNUM + 18),
		   (long) read_register (R0_BANK0_REGNUM + 19));
}

static void
sh2a_nofpu_show_regs (void)
{
  int pr = read_register (FPSCR_REGNUM) & 0x80000;
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx      TBR %08lx     MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (TBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
  printf_filtered (
	"     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM),
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));

  printf_filtered ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0), (long) read_register (1),
		   (long) read_register (2), (long) read_register (3),
		   (long) read_register (4), (long) read_register (5),
		   (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered ("BANK=%-3d\n", (int) read_register (BANK_REGNUM));
  printf_filtered (
	"R0b-R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (R0_BANK0_REGNUM + 0),
		   (long) read_register (R0_BANK0_REGNUM + 1),
		   (long) read_register (R0_BANK0_REGNUM + 2),
		   (long) read_register (R0_BANK0_REGNUM + 3),
		   (long) read_register (R0_BANK0_REGNUM + 4),
		   (long) read_register (R0_BANK0_REGNUM + 5),
		   (long) read_register (R0_BANK0_REGNUM + 6),
		   (long) read_register (R0_BANK0_REGNUM + 7));
  printf_filtered ("R8b-R14b %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (R0_BANK0_REGNUM + 8),
		   (long) read_register (R0_BANK0_REGNUM + 9),
		   (long) read_register (R0_BANK0_REGNUM + 10),
		   (long) read_register (R0_BANK0_REGNUM + 11),
		   (long) read_register (R0_BANK0_REGNUM + 12),
		   (long) read_register (R0_BANK0_REGNUM + 13),
		   (long) read_register (R0_BANK0_REGNUM + 14));
  printf_filtered ("MACHb=%08lx IVNb=%08lx PRb=%08lx GBRb=%08lx MACLb=%08lx\n",
		   (long) read_register (R0_BANK0_REGNUM + 15),
		   (long) read_register (R0_BANK0_REGNUM + 16),
		   (long) read_register (R0_BANK0_REGNUM + 17),
		   (long) read_register (R0_BANK0_REGNUM + 18),
		   (long) read_register (R0_BANK0_REGNUM + 19));
}

static void
sh3e_show_regs (void)
{
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx                       MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
  printf_filtered (
	"     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM),
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d1604 47
a1650 28
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
d1654 85
a1738 18
sh3_dsp_show_regs (void)
{
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx                       MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (MACL_REGNUM));

  printf_filtered ("     SSR %08lx      SPC %08lx      DSR %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM),
		   (long) read_register (DSR_REGNUM));
d1742 18
a1759 9
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1763 146
a1908 119
     (long) read_register (A0G_REGNUM) & 0xff,
     (long) read_register (A0_REGNUM), (long) read_register (M0_REGNUM),
     (long) read_register (X0_REGNUM), (long) read_register (Y0_REGNUM),
     (long) read_register (RS_REGNUM), (long) read_register (MOD_REGNUM));
  printf_filtered ("A1G=%02lx A1=%08lx M1=%08lx X1=%08lx Y1=%08lx RE=%08lx\n",
		   (long) read_register (A1G_REGNUM) & 0xff,
		   (long) read_register (A1_REGNUM),
		   (long) read_register (M1_REGNUM),
		   (long) read_register (X1_REGNUM),
		   (long) read_register (Y1_REGNUM),
		   (long) read_register (RE_REGNUM));
}

static void
sh4_show_regs (void)
{
  int pr = read_register (FPSCR_REGNUM) & 0x80000;
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx                       MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
  printf_filtered (
	"     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM),
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));

  printf_filtered ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     		   (long) read_register (0), (long) read_register (1),
     		   (long) read_register (2), (long) read_register (3),
     		   (long) read_register (4), (long) read_register (5),
     		   (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered (
	(pr ? "DR0-DR6  %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	    : "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered (
	(pr ? "DR8-DR14 %08lx%08lx  %08lx%08lx  %08lx%08lx  %08lx%08lx\n"
	    : "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
}

static void
sh4_nofpu_show_regs (void)
{
  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx                       MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (MACL_REGNUM));
  printf_filtered (
	"     SSR %08lx      SPC %08lx     FPUL %08lx    FPSCR %08lx\n",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM),
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));

  printf_filtered ("R0-R7    %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     		   (long) read_register (0), (long) read_register (1),
     		   (long) read_register (2), (long) read_register (3),
     		   (long) read_register (4), (long) read_register (5),
     		   (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
}

static void
sh_dsp_show_regs (void)
{

  printf_filtered ("      PC %s       SR %08lx       PR %08lx     MACH %08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM));

  printf_filtered (
	"     GBR %08lx      VBR %08lx      DSR %08lx     MACL %08lx\n",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM),
		   (long) read_register (DSR_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1912 18
a1929 9
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15   %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1933 7
a1939 4
     (long) read_register (A0G_REGNUM) & 0xff,
     (long) read_register (A0_REGNUM), (long) read_register (M0_REGNUM),
     (long) read_register (X0_REGNUM), (long) read_register (Y0_REGNUM),
     (long) read_register (RS_REGNUM), (long) read_register (MOD_REGNUM));
d1941 6
a1946 6
		   (long) read_register (A1G_REGNUM) & 0xff,
		   (long) read_register (A1_REGNUM),
		   (long) read_register (M1_REGNUM),
		   (long) read_register (X1_REGNUM),
		   (long) read_register (Y1_REGNUM),
		   (long) read_register (RE_REGNUM));
d1953 1
a1953 1
    (*sh_show_regs) ();
@


1.201
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d1893 2
a1894 2
  if (REGISTER_NAME (regnum) == NULL
      || *REGISTER_NAME (regnum) == '\0')
@


1.200
log
@	* regcache.c (regcache_invalidate): New function.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.
	(registers_changed): Use regcache_invalidate instead
	of set_register_cached.
	(regcache_raw_read): Update comment.

	* regcache.h (regcache_invalidate): Add prototype.
	(register_cached): Remove.
	(set_register_cached): Remove.
	(deprecated_registers_fetched): Remove.

	* findvar.c (value_of_register): Do not call register_cached.
	* frame.c (frame_register): Likewise.
	* tui/tui-regs.c (tui_get_register): Likewise.

	* remote.c (fetch_register_using_p): Do not call set_register_cached.
	(process_g_packet): Likewise.
	(remote_fetch_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* mt-tdep.c (mt_select_coprocessor): Replace set_register_cached call
	by regcache_invalidate.
	(mt_pseudo_register_write): Likewise.
	* sh-tdep.c (sh_pseudo_register_write): Likewise.

	* corelow.c (get_core_registers): Replace deprecated_registers_fetched
	call by loop over regcache_raw_supply (..., NULL).
@
text
@d398 1
a398 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d505 1
a505 1
  info->endian = TARGET_BYTE_ORDER;
d898 1
a898 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d971 1
a971 1
  else if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d1109 1
a1109 1
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE
d1250 1
a1250 1
	if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d1294 1
a1294 1
	if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
@


1.199
log
@	* config/sh/tm-sh.h (DEPRECATED_BIG_REMOTE_BREAKPOINT,
	DEPRECATED_LITTLE_REMOTE_BREAKPOINT): Remove.
	* remote.c: Remove code under #ifdef DEPRECATED_REMOTE_BREAKPOINT,
	DEPRECATED_BIG_REMOTE_BREAKPOINT, DEPRECATED_LITTLE_REMOTE_BREAKPOINT.
	* sh-tdep.c (sh_breakpoint_from_pc): Return remote breakpoint
	sequence if target_shortname is "remote".

doc/ChangeLog:

	* gdbint.texinfo (Target Conditionals): Remove mention of
	DEPRECATED_REMOTE_BREAKPOINT, DEPRECATED_BIG_REMOTE_BREAKPOINT,
	and DEPRECATED_LITTLE_REMOTE_BREAKPOINT.
@
text
@d2058 1
a2058 1
        set_register_cached (bregnum, 0);
@


1.198
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d392 18
@


1.197
log
@	* gdbarch.sh (register_type): Update comment.
	* gdbarch.h: Regenerated.
	* arch-utils.c (generic_register_size): Call register_type.
	* ia64-tdep.c (ia64_extract_return_value): Likewise.
	* m32c-tdep.c (check_for_saved): Likewise.
	* mips-tdep.c (mips_print_register, print_gp_register_row)
	(mips_print_registers_info): Likewise.
	* sh-tdep.c (sh_pseudo_register_read, sh_pseudo_register_write):
	Likewise.
	* sh64-tdep.c (sh64_pseudo_register_read, sh64_pseudo_register_write)
	(sh64_do_register, sh64_print_register)
	(sh64_media_print_registers_info): Likewise.
	* tui/tui-regs.c (tui_register_format): Likewise.
@
text
@d2218 1
a2218 1
  cache->pc = frame_func_unwind (next_frame);
@


1.196
log
@Copyright updates for 2007.
@
text
@d2007 1
a2007 1
				      gdbarch_register_type (gdbarch, reg_nr),
d2047 1
a2047 1
      sh_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr),
@


1.195
log
@	* dwarf2-frame.c (dwarf2_frame_ops init_reg): Add "next_frame"
	argument.
	(dwarf2_frame_default_init_reg): Likewise.
	(dwarf2_frame_set_init_reg): Update init_reg arg.
	(dwarf2_frame_init_reg): Take "next_frame" and pass it to
	ops->init_reg().
	(dwarf2_frame_cache): Pass next_frame to dwarf2_frame_init_reg.
	* dwarf2-frame.h (dwarf2-frame_set_init_reg): Update declaration.
	* cris-tdep.c (cris_dwarf2_frame_init_reg): Add next_frame arg.
	* s390-tdep.c (s390_dwarf2_frame_init_reg): Likewise.
	* sh-tdep.c (sh_dwarf2_frame_init_reg): Likewise.
	* sparc64-tdep.c (sparc64_dwarf2_frame_init_reg): Likewise.
	* sparc-tdep.c (sparc32_struct_return_from_sym): New function.
	(sparc32_frame_cache): Call it.
	(sparc32_dwarf2_struct_return_p): New function.
	(sparc_dwarf2_frame_init_reg): Use it to determine if the function
	returns a structure and thus we have to indicate the return PC and
	NPC are 4 bytes later than usual.
@
text
@d3 2
a4 2
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.194
log
@2006-04-03  Andrew Stubbs  <andrew.stubbs@@st.com>

	* sh-tdep.c (sh_dwarf2_frame_init_reg): New function.
	(sh_gdbarch_init): Call dwarf2_frame_set_init_reg().
@
text
@d2126 2
a2127 1
                          struct dwarf2_frame_state_reg *reg)
@


1.193
log
@2006-03-27  Andrew Stubbs  <andrew.stubbs@@st.com>

	* sh-tdep.c (sh_gdbarch_init): Add missing architectures.
@
text
@d2117 51
d2546 2
@


1.192
log
@2006-02-21  Andrew Stubbs  <andrew.stubbs@@st.com>

	* sh-tdep.c (sh_generic_show_regs): Reformat both code and output.
	(sh3_show_regs, sh2e_show_regs, sh2a_show_regs): Likewise.
	(sh2a_nofpu_show_regs, sh3e_show_regs, sh3_dsp_show_regs): Likewise.
	(sh4_show_regs, sh4_nofpu_show_regs, sh_dsp_show_regs): Likewise.
@
text
@d2544 2
d2550 1
d2580 3
@


1.191
log
@2006-01-23  Andrew Stubbs  <andrew.stubbs@@st.com>

	* sh-tdep.c: Include reggroups.h.
	(sh_register_reggroup_p): New function.
	(sh_gdbarch_init): Add call to set_gdbarch_register_reggroup_p.
	* Makefile.in (sh-tdep.o): Add dependency on reggroups.h.
@
text
@d1319 1
a1319 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1323 1
a1323 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1325 2
a1326 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1328 2
a1329 1
		   (long) read_register (VBR_REGNUM));
d1332 1
a1332 1
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1337 1
a1337 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1347 1
a1347 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1351 1
a1351 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1353 2
a1354 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1356 3
a1358 2
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" SSR=%08lx SPC=%08lx",
d1363 1
a1363 1
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1368 1
a1368 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1379 1
a1379 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1383 1
a1383 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1385 2
a1386 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1388 6
a1393 2
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
d1398 1
a1398 1
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1403 1
a1403 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1409 18
a1426 2
  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 0), (long) read_register (FP0_REGNUM + 1), (long) read_register (FP0_REGNUM + 2), (long) read_register (FP0_REGNUM + 3), (long) read_register (FP0_REGNUM + 4), (long) read_register (FP0_REGNUM + 5), (long) read_register (FP0_REGNUM + 6), (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 8), (long) read_register (FP0_REGNUM + 9), (long) read_register (FP0_REGNUM + 10), (long) read_register (FP0_REGNUM + 11), (long) read_register (FP0_REGNUM + 12), (long) read_register (FP0_REGNUM + 13), (long) read_register (FP0_REGNUM + 14), (long) read_register (FP0_REGNUM + 15));
d1433 1
a1433 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1437 1
a1437 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1439 2
a1440 1
  printf_filtered ("GBR=%08lx VBR=%08lx TBR=%08lx",
d1443 6
a1448 2
		   (long) read_register (TBR_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx\n",
d1452 1
a1452 1
  printf_filtered ("R0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1457 1
a1457 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1463 3
a1465 4
  printf_filtered ((pr
		    ? "DR0-DR6  %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n"
		    :
		    "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
d1474 3
a1476 3
  printf_filtered ((pr ?
		    "DR8-DR14 %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n" :
		    "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
d1486 2
a1487 1
  printf_filtered ("R0b - R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1496 1
a1496 1
  printf_filtered ("R8b - R14b %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1516 1
a1516 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1520 1
a1520 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1522 2
a1523 1
  printf_filtered ("GBR=%08lx VBR=%08lx TBR=%08lx",
d1526 6
a1531 2
		   (long) read_register (TBR_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx\n",
d1535 1
a1535 1
  printf_filtered ("R0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1540 1
a1540 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1547 2
a1548 1
  printf_filtered ("R0b - R7b  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1557 1
a1557 1
  printf_filtered ("R8b - R14b %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1576 1
a1576 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1580 1
a1580 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1582 2
a1583 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1585 4
a1588 2
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" SSR=%08lx SPC=%08lx",
d1590 1
a1590 2
		   (long) read_register (SPC_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
d1595 1
a1595 1
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1600 1
a1600 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1606 18
a1623 2
  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 0), (long) read_register (FP0_REGNUM + 1), (long) read_register (FP0_REGNUM + 2), (long) read_register (FP0_REGNUM + 3), (long) read_register (FP0_REGNUM + 4), (long) read_register (FP0_REGNUM + 5), (long) read_register (FP0_REGNUM + 6), (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 8), (long) read_register (FP0_REGNUM + 9), (long) read_register (FP0_REGNUM + 10), (long) read_register (FP0_REGNUM + 11), (long) read_register (FP0_REGNUM + 12), (long) read_register (FP0_REGNUM + 13), (long) read_register (FP0_REGNUM + 14), (long) read_register (FP0_REGNUM + 15));
d1629 1
a1629 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1633 1
a1633 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1635 2
a1636 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1638 2
a1639 1
		   (long) read_register (VBR_REGNUM));
d1641 1
a1641 1
  printf_filtered (" SSR=%08lx SPC=%08lx",
d1643 2
a1644 3
		   (long) read_register (SPC_REGNUM));

  printf_filtered (" DSR=%08lx", (long) read_register (DSR_REGNUM));
d1647 1
a1647 1
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1652 1
a1652 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1677 1
a1677 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1681 1
a1681 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1683 2
a1684 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1686 4
a1689 2
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" SSR=%08lx SPC=%08lx",
d1691 1
a1691 2
		   (long) read_register (SPC_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
d1695 6
a1700 7
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1706 3
a1708 4
  printf_filtered ((pr
		    ? "DR0-DR6  %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n"
		    :
		    "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
d1717 3
a1719 3
  printf_filtered ((pr ?
		    "DR8-DR14 %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n" :
		    "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
d1733 1
a1733 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1737 1
a1737 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1739 2
a1740 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1742 4
a1745 2
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" SSR=%08lx SPC=%08lx",
d1747 3
a1749 1
		   (long) read_register (SPC_REGNUM));
d1751 6
a1756 7
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1766 2
a1767 1
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
d1771 1
a1771 2
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d1773 2
a1774 1
  printf_filtered ("GBR=%08lx VBR=%08lx",
d1776 3
a1778 3
		   (long) read_register (VBR_REGNUM));

  printf_filtered (" DSR=%08lx", (long) read_register (DSR_REGNUM));
d1781 1
a1781 1
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d1786 1
a1786 1
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
@


1.190
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d47 1
d1816 41
d2416 1
@


1.189
log
@2005-11-23  Andrew Stubbs  <andrew.stubbs@@st.com>

	* sh-tdep.c (do_fv_register_info, do_dr_register_info): Delete function.
	(do_bank_register_info, do_bank_register_info): Likewise.
	(sh_print_pseudo_register, sh_do_fp_register): Likewise.
	(sh_do_register, sh_print_register, sh_print_registers_info): Likewise.
	(sh_gdbarch_init): Remove call to set_gdbarch_print_registers_info().
@
text
@d3 1
a3 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.188
log
@2005-11-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* monitor.c (monitor_xfer_memory): Change char to gdb_byte.
	(monitor_insert_breakpoint): Likewise.
	(monitor_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Change void to gdb_byte.
	(sh_return_value_fpu): Likewise.
	(sh_pseudo_register_read): Likewise.
	(sh_pseudo_register_write): Likewise.
	(sh_frame_prev_register): Likewise.
	* sh64-tdep.c (sh64_extract_return_value): Change char to gdb_byte.
	(sh64_return_value): Change void to gdb_byte.
	(sh64_pseudo_register_read): Likewise.
	(sh64_pseudo_register_write): Likewise.
	(sh64_frame_prev_register): Likewise.
@
text
@a1976 178
/* Floating point vector of 4 float registers. */
static void
do_fv_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int fv_regnum)
{
  int first_fp_reg_num = fv_reg_base_num (fv_regnum);
  fprintf_filtered (file, "fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n",
		    fv_regnum - FV0_REGNUM,
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1),
		    (int) read_register (first_fp_reg_num + 2),
		    (int) read_register (first_fp_reg_num + 3));
}

/* Double precision registers. */
static void
do_dr_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int dr_regnum)
{
  int first_fp_reg_num = dr_reg_base_num (dr_regnum);

  fprintf_filtered (file, "dr%d\t0x%08x%08x\n",
		    dr_regnum - DR0_REGNUM,
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1));
}
static void
do_bank_register_info (struct gdbarch *gdbarch, struct ui_file *file)
{
  fprintf_filtered (file, "bank           %d\n",
		    (int) read_register (BANK_REGNUM));
}

static void
sh_print_pseudo_register (struct gdbarch *gdbarch, struct ui_file *file,
			  int regnum)
{
  if (regnum < NUM_REGS || regnum >= NUM_REGS + NUM_PSEUDO_REGS)
    internal_error (__FILE__, __LINE__,
		    _("Invalid pseudo register number %d\n"), regnum);
  else if (regnum == PSEUDO_BANK_REGNUM)
    do_bank_register_info (gdbarch, file);
  else if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
    do_dr_register_info (gdbarch, file, regnum);
  else if (regnum >= FV0_REGNUM && regnum <= FV_LAST_REGNUM)
    do_fv_register_info (gdbarch, file, regnum);
}

static void
sh_do_fp_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
{				/* do values for FP (float) regs */
  char *raw_buffer;
  double flt;			/* double extracted from raw hex data */
  int inv;
  int j;

  /* Allocate space for the float. */
  raw_buffer = (char *) alloca (register_size (gdbarch, FP0_REGNUM));

  /* Get the data in raw format.  */
  if (!frame_register_read (get_selected_frame (NULL), regnum, raw_buffer))
    error (_("can't read register %d (%s)"), regnum, REGISTER_NAME (regnum));

  /* Get the register as a number */
  flt = unpack_double (builtin_type_float, raw_buffer, &inv);

  /* Print the name and some spaces. */
  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);

  /* Print the value. */
  if (inv)
    fprintf_filtered (file, "<invalid float>");
  else
    fprintf_filtered (file, "%-10.9g", flt);

  /* Print the fp register as hex. */
  fprintf_filtered (file, "\t(raw 0x");
  for (j = 0; j < register_size (gdbarch, regnum); j++)
    {
      int idx = (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
		 ? j
		 : register_size (gdbarch, regnum) - 1 - j);
      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
    }
  fprintf_filtered (file, ")");
  fprintf_filtered (file, "\n");
}

static void
sh_do_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
{
  char raw_buffer[MAX_REGISTER_SIZE];

  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);

  /* Get the data in raw format.  */
  if (!frame_register_read (get_selected_frame (NULL), regnum, raw_buffer))
    fprintf_filtered (file, "*value not available*\n");

  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 'x', 1, 0, Val_pretty_default);
  fprintf_filtered (file, "\t");
  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 0, 1, 0, Val_pretty_default);
  fprintf_filtered (file, "\n");
}

static void
sh_print_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
{
  if (regnum < 0 || regnum >= NUM_REGS + NUM_PSEUDO_REGS)
    internal_error (__FILE__, __LINE__,
		    _("Invalid register number %d\n"), regnum);

  else if (regnum >= 0 && regnum < NUM_REGS)
    {
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
	sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
      else
	sh_do_register (gdbarch, file, regnum);	/* All other regs */
    }

  else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
    {
      sh_print_pseudo_register (gdbarch, file, regnum);
    }
}

static void
sh_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			 struct frame_info *frame, int regnum, int fpregs)
{
  if (regnum != -1)		/* do one specified register */
    {
      if (*(REGISTER_NAME (regnum)) == '\0')
	error (_("Not a valid register for the current processor type"));

      sh_print_register (gdbarch, file, regnum);
    }
  else
    /* do all (or most) registers */
    {
      for (regnum = 0; regnum < NUM_REGS; ++regnum)
	{
	  /* If the register name is empty, it is undefined for this
	     processor, so don't display anything.  */
	  if (REGISTER_NAME (regnum) == NULL
	      || *(REGISTER_NAME (regnum)) == '\0')
	    continue;

	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	      TYPE_CODE_FLT)
	    {
	      /* true for "INFO ALL-REGISTERS" command */
	      if (fpregs)
		sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
	    }
	  else
	    sh_do_register (gdbarch, file, regnum);	/* All other regs */
	}

      if (regnum == PSEUDO_BANK_REGNUM
      	  && REGISTER_NAME (regnum)
	  && *REGISTER_NAME (regnum))
	sh_print_pseudo_register (gdbarch, file, regnum++);

      if (fpregs)
	while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
	  {
	    sh_print_pseudo_register (gdbarch, file, regnum);
	    regnum++;
	  }
    }
}

a2374 2
  set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);

@


1.187
log
@* sh-tdep.c (sh_linux_svr4_fetch_link_map_offsets): Remove function.
(sh_gdbarch_init): Remove redundant prototype.
* sh-linux-tdep.c: New file.
* config/sh/tm-linux.h (sh_linux_svr4_fetch_link_map_offsets):
Remove prototype.
(SVR4_FETCH_LINK_MAP_OFFSETS): Remove define.
* config/sh/linux.mt (TDEPFILES): Add sh64-tdep.o, remove
solib-legacy.o.
* Makefile.in (sh-linux-tdep.o): New.
@
text
@d1288 1
a1288 1
		       void *readbuf, const void *writebuf)
d1302 1
a1302 1
		     void *readbuf, const void *writebuf)
d1893 1
a1893 1
			 int reg_nr, void *buffer)
d1932 1
a1932 1
			  int reg_nr, const void *buffer)
d2285 1
a2285 1
			int *realnump, void *valuep)
@


1.186
log
@	* MAINTAINERS: Change sh64-elf state to non-broken.
	* Makefile.in: Fix dependencies for sh64-tdep.o.
	* configure.tgt: Add sh64-*-elf case.
	* sh-tdep.c (sh_gdbarch_init): Reactivate bfd_mach_sh5 case.
	* sh64-tdep.c: Rework to replace all deprecated mechanisms with
	modern methods.
	* config/sh/embed.mt (TDEPFILES): Add sh64-tdep.o.
	* config/sh/sh64.mt: Resurrect.
@
text
@a2154 41
/* Fetch (and possibly build) an appropriate link_map_offsets structure
   for native i386 linux targets using the struct offsets defined in
   link.h (but without actual reference to that file).

   This makes it possible to access i386-linux shared libraries from
   a gdb that was not built on an i386-linux host (for cross debugging).
   */

struct link_map_offsets *
sh_linux_svr4_fetch_link_map_offsets (void)
{
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = 0;

  if (lmp == 0)
    {
      lmp = &lmo;

      lmo.r_debug_size = 8;	/* 20 not actual size but all we need */

      lmo.r_map_offset = 4;
      lmo.r_map_size = 4;

      lmo.link_map_size = 20;	/* 552 not actual size but all we need */

      lmo.l_addr_offset = 0;
      lmo.l_addr_size = 4;

      lmo.l_name_offset = 4;
      lmo.l_name_size = 4;

      lmo.l_next_offset = 12;
      lmo.l_next_size = 4;

      lmo.l_prev_offset = 16;
      lmo.l_prev_size = 4;
    }

  return lmp;
}

d2475 1
a2475 2

static gdbarch_init_ftype sh_gdbarch_init;
@


1.185
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@a2562 1
#if 0
a2566 1
#endif
@


1.184
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2738 1
a2738 1
  add_com ("regs", class_vars, sh_show_regs_command, "Print all registers");
@


1.183
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d2016 1
a2016 1
		    "Invalid pseudo register number %d\n", regnum);
d2091 1
a2091 1
		    "Invalid register number %d\n", regnum);
@


1.182
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d1219 1
a1219 1
    error ("bad size for return value");
d1868 1
a1868 1
    error ("sh_register_convert_to_raw called with non DR register number");
d2038 1
a2038 1
    error ("can't read register %d (%s)", regnum, REGISTER_NAME (regnum));
d2115 1
a2115 1
	error ("Not a valid register for the current processor type");
@


1.181
log
@	* sh-tdep.c (sh_extract_return_value_nofpu): Rename from
	sh_default_extract_return_value.
	(sh_extract_return_value_fpu): Rename from
	sh3e_sh4_extract_return_value.
	(sh_store_return_value_nofpu): Rename from
	sh_default_store_return_value.
	(sh_store_return_value_fpu): Rename from sh3e_sh4_store_return_value.
	(sh_return_value_nofpu): Accomodate above changes.
	(sh_return_value_fpu): Ditto.
@
text
@d2 3
a4 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004 Free Software Foundation, Inc.
d880 1
a880 1
	memcpy (valbuf + (4 - len), (char *) VALUE_CONTENTS (val), len);
d882 1
a882 1
	memcpy (valbuf, (char *) VALUE_CONTENTS (val), len);
d885 1
a885 1
  return (char *) VALUE_CONTENTS (val);
@


1.180
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d1197 2
a1198 2
sh_default_extract_return_value (struct type *type, struct regcache *regcache,
				 void *valbuf)
d1222 2
a1223 2
sh3e_sh4_extract_return_value (struct type *type, struct regcache *regcache,
			       void *valbuf)
d1236 1
a1236 1
    sh_default_extract_return_value (type, regcache, valbuf);
d1246 2
a1247 2
sh_default_store_return_value (struct type *type, struct regcache *regcache,
			       const void *valbuf)
d1266 2
a1267 2
sh3e_sh4_store_return_value (struct type *type, struct regcache *regcache,
			     const void *valbuf)
d1281 1
a1281 1
    sh_default_store_return_value (type, regcache, valbuf);
d1292 1
a1292 1
    sh_default_store_return_value (type, regcache, writebuf);
d1294 1
a1294 1
    sh_default_extract_return_value (type, regcache, readbuf);
d1306 1
a1306 1
    sh3e_sh4_store_return_value (type, regcache, writebuf);
d1308 1
a1308 1
    sh3e_sh4_extract_return_value (type, regcache, readbuf);
@


1.179
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d893 1
a893 1
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[nargs])) + 3) & ~3);
d1048 1
a1048 1
      type = VALUE_TYPE (args[argnum]);
d1154 1
a1154 1
      type = VALUE_TYPE (args[argnum]);
@


1.178
log
@2004-10-27  Andrew Cagney  <cagney@@gnu.org>

	* trad-frame.c (trad_frame_get_prev_register): Use
	frame_unwind_register instead of frame_register_unwind, do not
	recurse the register's location.
	* xstormy16-tdep.c (xstormy16_frame_prev_register):
	* sparc-tdep.c (sparc32_frame_prev_register): Ditto.
	* sparc64-tdep.c (sparc64_frame_prev_register): Ditto.
	* sh-tdep.c (sh_frame_prev_register): Ditto.
	* m68k-tdep.c (m68k_frame_prev_register): Ditto.
	* i386-tdep.c (i386_frame_prev_register): Ditto.
	* dwarf2-frame.c (dwarf2_frame_prev_register): Ditto.
	* amd64-tdep.c (amd64_frame_prev_register): Ditto.
@
text
@d2036 1
a2036 1
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
d2074 1
a2074 1
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
@


1.177
log
@	* sh-tdep.c (sh_return_value_nofpu): New function, implementing
	RETURN_VALUE.
	(sh_return_value_fpu): Ditto for CPUs with FPU.
	(sh_gdbarch_init): Remove STORE_RETURN_VALUE, EXTRACT_RETURN_VALUE,
	RETURN_VALUE_ON_STACK and USE_STRUCT_CONVENTION throughout.
	Install sh_return_value_nofpu resp. sh_return_value_fpu as
	RETURN_VALUE functions.
@
text
@d2366 6
a2371 2
  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
@


1.176
log
@	* sh-tdep.c (sh_pseudo_register_read): Add PSEUDO_BANK_REGNUM handling.
	(sh_pseudo_register_write): Ditto.
@
text
@d1284 28
a2594 1
  set_gdbarch_deprecated_use_struct_convention (gdbarch, sh_use_struct_convention);
d2601 3
a2603 3
  set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
  set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
d2637 1
a2637 3
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
d2650 1
a2650 2
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d2679 1
a2679 3
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
d2696 1
a2696 3
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
@


1.175
log
@	* sh-tdep.c (IS_MACL_STS): New define.
	(IS_MOVI20): Ditto.
	(IS_MACL_LDS): Ditto.
	(sh_analyze_prologue): Recognize STS.L MACL,@@-r15 and MOVI20
	instructions in prologue.
	(sh_in_function_epilogue_p): Recognize LDS.L @@r15+,MACL and MOVI20
	instructions in epilogue.
@
text
@d1869 3
d1908 13
a1920 1
  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
@


1.174
log
@	* sh-tdep.c (SH_NUM_REGS): Define as 67.
	(sh_sh_register_name): Add eight empty register names.
	(sh_sh3_register_name): Ditto.
	(sh_sh3e_register_name): Ditto.
	(sh_sh2e_register_name): Ditto.
	(sh_sh2a_register_name): New function, defining SH2A register set.
	(sh_sh2a_nofpu_register_name): New function, defining SH2A register set
	in nofpu case.
	(sh_sh_dsp_register_name): Add eight empty register names.
	(sh_sh3_dsp_register_name): Ditto.
	(sh_sh4_register_name): Ditto.
	(sh_sh4_nofpu_register_name): Ditto.
	(sh_sh4al_dsp_register_name): Ditto.
	(sh2a_show_regs): New function.
	(sh2a_nofpu_show_regs): New function.
	(sh_sh2a_register_type): New function.
	(do_bank_register_info): New function.
	(sh_print_pseudo_register): Call do_bank_register_info.
	Call sh_print_pseudo_register for valid "bank" register.
	(sh_sh2a_register_sim_regno): New function.
	(sh_gdbarch_init): Add bfd_mach_sh2a and bfd_mach_sh2a_nofpu handling.
	Increment pseudo register count by one for all sh variants with
	pseudo registers to accomodate pseudo bank register.
	* sh-tdep.h: Add register numbers for R0_BANK0_REGNUM, MACHB_REGNUM,
	IVNB_REGNUM, PRB_REGNUM, GBRB_REGNUM, MACLB_REGNUM, BANK_REGNUM,
	IBCR_REGNUM, IBNR_REGNUM, TBR_REGNUM and PSEUDO_BANK_REGNUM.
	Increment pseudo register numbers.
@
text
@d414 4
d465 2
d476 1
d518 5
d568 19
d2423 9
a2432 1
      inst = read_memory_unsigned_integer (addr - 2, 2);
d2455 8
@


1.173
log
@Index: ChangeLog
2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* config/m68k/tm-linux.h (SVR4_SHARED_LIBS): Delete.
	* config/i386/tm-linux64.h (SVR4_SHARED_LIBS): Delete.
	* config/i386/nm-i386sco5.h (SVR4_SHARED_LIBS): Delete.
	* config/tm-linux.h (SVR4_SHARED_LIBS): Delete.
	* config/nm-sysv4.h (SVR4_SHARED_LIBS): Delete.
	* config/nm-linux.h (SVR4_SHARED_LIBS): Delete.
	* config/nm-gnu.h (SVR4_SHARED_LIBS): Delete.
	* sh64-tdep.c [SVR4_SHARED_LIBS]: Delete #ifdef wrapper.
	* sh-tdep.c [SVR4_SHARED_LIBS]: Delete #ifdef wrapper.

Index: doc/ChangeLog
2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Native Debugging): Delete SVR4_SHARED_LIBS.
@
text
@d59 1
a59 1
#define SH_NUM_REGS 59
d89 1
d111 1
d133 1
d155 81
d257 1
d280 1
d309 3
d346 3
d375 1
d1347 135
d1702 12
d1928 6
d1942 2
d2066 5
d2139 29
d2435 6
d2554 23
d2609 1
a2609 1
      set_gdbarch_num_pseudo_regs (gdbarch, 12);
@


1.172
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_frameless_function_invocation): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-tdep.c 	(arm_frameless_function_invocation): Delete.
	(arm_gdbarch_init) Do not set frameless function invocation.
	* frame.h (legacy_frameless_look_for_prologue): Delete declaration.
	* blockframe.c (legacy_frameless_look_for_prologue): Delete function.
	* frv-tdep.c (frv_frameless_function_invocation): Delete.
	(frv_gdbarch_init): Do not set frameless function invocation.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
@
text
@a1826 2
#ifdef SVR4_SHARED_LIBS

a1866 1
#endif /* SVR4_SHARED_LIBS */
@


1.171
log
@2004-08-01  Andrew Cagney  <cagney@@gnu.org>

	* sh-tdep.c (sh_gdbarch_init): Disable call to sh64_gdbarch_init.
	* config/sh/nbsd.mt (TDEPFILES): Remove sh64-tdep.o.
	* config/sh/linux.mt (TDEPFILES): Remove sh64-tdep.o.
	* config/sh/embed.mt (TDEPFILES): Remove sh64-tdep.o.
@
text
@a2235 1
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, legacy_frameless_look_for_prologue);
@


1.170
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@d2183 1
d2188 1
@


1.169
log
@2004-06-06  Randolph Chung  <tausq@@debian.org>

	* gdbarch.sh (PUSH_DUMMY_CALL): Change CORE_ADDR func_addr argument
	to struct value *function.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Likewise.
	* infcall.c (call_function_by_hand): Pass entire function value
	to push_dummy_call.

	* Makefile.in (alpha-tdep.o, frv-tdep.o, ia64-tdep.o, mips-tdep.o)
	(ppc-sysv-tdep.o, rs6000-tdep.o): Update dependencies.
	* alpha-tdep.c (alpha_push_dummy_call): Update call signature.
	* amd64-tdep.c (amd64_push_dummy_call): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* avr-tdep.c (avr_push_dummy_call): Likewise.
	* cris-tdep.c (cris_push_dummy_call): Likewise.
	* d10v-tdep.c (d10v_push_dummy_call): Likewise.
	* frv-tdep.c (frv_push_dummy_call): Likewise.
	* h8300-tdep.c (h8300_push_dummy_call): Likewise.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_push_dummy_call): Likewise.
	* i386-tdep.c (i386_push_dummy_call): Likewise.
	* ia64-tdep.c (ia64_push_dummy_call): Likewise.
	* m32r-tdep.c (m32r_push_dummy_call): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call): Likewise.
	* m68k-tdep.c (m68k_push_dummy_call): Likewise.
	* m88k-tdep.c (m88k_push_dummy_call): Likewise.
	* mips-tdep.c (mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.
	* s390-tdep.c (s390_push_dummy_call): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu)
	(sh_push_dummy_call_nofpu): Likewise.
	* sparc-tdep.c (sparc32_push_dummy_call): Likewise.
	* sparc64-tdep.c (sparc64_push_dummy_call): Likewise.
	* vax-tdep.c (vax_push_dummy_call): Likewise.
@
text
@d2218 1
a2218 1
  set_gdbarch_use_struct_convention (gdbarch, sh_use_struct_convention);
@


1.168
log
@	* sh-tdep.c (sh3e_sh4_store_return_value): Correctly store
	double values in little endian mode.
@
text
@d888 1
a888 1
			CORE_ADDR func_addr,
d1000 1
a1000 1
			  CORE_ADDR func_addr,
@


1.167
log
@	* sh-tdep.c (sh_print_registers_info): Use for loop.
	Don't skip multiple registers when a float register is encountered.
@
text
@d1150 5
a1154 1
	regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
@


1.166
log
@	Fix PR tdep/1291.
	* sh-tdep.c (sh_analyze_prologue): Align PC relative addressing
	to official SH documentation.
@
text
@d1795 1
a1795 2
      regnum = 0;
      while (regnum < NUM_REGS)
d1801 1
a1801 4
	    {
	      regnum++;
	      continue;
	    }
d1806 1
d1808 1
a1808 7
		{
		  /* true for "INFO ALL-REGISTERS" command */
		  sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
		  regnum++;
		}
	      else
		regnum += (FP_LAST_REGNUM - FP0_REGNUM);	/* skip FP regs */
d1811 1
a1811 4
	    {
	      sh_do_register (gdbarch, file, regnum);	/* All other regs */
	      regnum++;
	    }
@


1.165
log
@Reviewed and approved by ezannoni@@redhat.com

	2004-02-19  Fred Fish  <fnf@@redhat.com>
	* sh-tdep.c (sh_analyze_prologue): Eliminate useless test of
	cache->uses_fp prior to setting it.
@
text
@d443 1
a443 1
		  offset = (((inst & 0xff) ^ 0x80) - 0x80) << 1;
d445 1
a445 1
		    read_memory_integer (((pc + 4) & ~3) + offset, 2);
d453 1
a453 1
	      reg = (inst & 0x0f00) >> 8;
d457 1
a457 1
		  offset = (((inst & 0xff) ^ 0x80) - 0x80) << 1;
d459 1
a459 1
		    read_memory_integer (((pc + 4) & ~3) + offset, 4);
@


1.165.2.1
log
@Merge mainline to intercu branch.
@
text
@d443 1
a443 1
		  offset = (inst & 0xff) << 1;
d445 1
a445 1
		    read_memory_integer ((pc + 4) + offset, 2);
d453 1
a453 1
	      reg = GET_TARGET_REG (inst);
d457 1
a457 1
		  offset = (inst & 0xff) << 2;
d459 1
a459 1
		    read_memory_integer (((pc & 0xfffffffc) + 4) + offset, 4);
d1795 2
a1796 1
      for (regnum = 0; regnum < NUM_REGS; ++regnum)
d1802 4
a1805 1
	    continue;
a1809 1
	      /* true for "INFO ALL-REGISTERS" command */
d1811 7
a1817 1
		sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
d1820 4
a1823 1
	    sh_do_register (gdbarch, file, regnum);	/* All other regs */
@


1.165.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d888 1
a888 1
			struct value *function,
d1000 1
a1000 1
			  struct value *function,
d1150 1
a1150 5
	if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	  regcache_raw_write (regcache, regnum++,
			      (char *) valbuf + len - 4 - i);
	else
	  regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
d1823 2
d1865 1
a2178 1
#if 0
a2182 1
#endif
d2214 1
a2214 1
  set_gdbarch_deprecated_use_struct_convention (gdbarch, sh_use_struct_convention);
d2230 1
@


1.164
log
@Reviewed and approved by ezannoni@@redhat.com

	2004-02-19  Fred Fish  <fnf@@redhat.com>
	Fix for PR breakpoint/1558.
	* sh-tdep.c (IS_JSR): New macro.
	(sh_analyze_prologue): Use IS_JSR to terminate prologue scan.
@
text
@d485 1
a485 2
	  if (!cache->uses_fp)
	    cache->uses_fp = 1;
@


1.163
log
@	* sh-tdep.c (sh_dsp_register_sim_regno): Use DSP_Rx_BANK_REGNUM.
	* sh-tdep.h: Rename R0_BANK_REGNUM and R7_BANK_REGNUM to
	DSP_R0_BANK_REGNUM and DSP_R7_BANK_REGNUM.
@
text
@d314 3
d514 14
@


1.162
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d1876 2
a1877 2
  if (nr >= R0_BANK_REGNUM && nr <= R7_BANK_REGNUM)
    return nr - R0_BANK_REGNUM + SIM_SH_R0_BANK_REGNUM;
@


1.161
log
@	* sh-tdep.c (sh_register_convert_to_virtual): Rename from
	sh_sh4_register_convert_to_virtual.
	(sh_register_convert_to_raw): Rename from
	sh_sh4_register_convert_to_raw.
	(sh_pseudo_register_read): Accomodate above name change.
	(sh_pseudo_register_write): Ditto.
@
text
@d2226 1
a2226 2
  set_gdbarch_frameless_function_invocation (gdbarch,
					     frameless_look_for_prologue);
@


1.160
log
@	* sh-tdep.c (sh_generic_register_name): Remove.
	(sh_gdbarch_init): Use sh_sh_register_name in default case.
@
text
@d1522 2
a1523 2
sh_sh4_register_convert_to_virtual (int regnum, struct type *type,
				    char *from, char *to)
d1538 2
a1539 2
sh_sh4_register_convert_to_raw (struct type *type, int regnum,
				const void *from, void *to)
d1590 3
a1592 4
      sh_sh4_register_convert_to_virtual (reg_nr,
					  gdbarch_register_type (gdbarch,
								 reg_nr),
					  temp_buffer, buffer);
d1619 2
a1620 2
      sh_sh4_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr),
				      reg_nr, buffer, temp_buffer);
@


1.159
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@a76 21
sh_generic_register_name (int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "fpul", "fpscr",
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr", "spc",
    "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
d2314 1
a2314 1
      set_gdbarch_register_name (gdbarch, sh_generic_register_name);
@


1.158
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a32 1
#include "symfile.h"
@


1.157
log
@	* sh-tdep.c (sh_sh3_dsp_register_name): Fix formatting. Add missing
	comma.
	(sh_sh4al_dsp_register_name): Ditto.
@
text
@a2248 1
  set_gdbarch_frame_args_skip (gdbarch, 0);
@


1.156
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@d215 2
a216 2
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b"
      "", "", "", "", "", "", "", "",
d303 2
a304 2
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b"
      "", "", "", "", "", "", "", "",
@


1.155
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d2242 1
a2242 2
  set_gdbarch_extract_struct_value_address (gdbarch,
					    sh_extract_struct_value_address);
@


1.154
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@a2246 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.153
log
@	* sh-tdep.c (sh_sh4_nofpu_register_name): New function.
	(sh_sh4al_dsp_register_name): Ditto.
	(sh4_nofpu_show_regs): Ditto.
	(sh_gdbarch_init): Add cases for bfd_mach_sh4al_dsp, bfd_mach_sh4a,
	bfd_mach_sh4_nofpu and bfd_mach_sh4a_nofpu.
@
text
@a2247 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.152
log
@	* sh-tdep.c: Fix two copy/paste hangovers in comments.
	(sh_push_dummy_call_fpu): Accomodate double passing in little endian
	mode.
	(sh3e_sh4_extract_return_value): Ditto.
@
text
@d259 54
d1397 30
d2184 1
d2189 1
d2193 5
d2316 1
d2327 10
@


1.151
log
@	* sh-tdep.c (sh_treat_as_flt_p): New function to recognize float
	types correctly.
	(sh_push_dummy_call_fpu): Fix argument passing rules.
	(sh3e_sh4_extract_return_value): Call sh_treat_as_flt_p to recognize
	float types.
	(sh3e_sh4_store_return_value): Ditto.
@
text
@d546 1
a546 3
/* Should call_function allocate stack space for a struct return?

   The ABI says:
d791 1
a791 1
   Second, the FPU ABIs have a special way how to treat types as float types.
d910 16
d1058 4
a1061 1
	regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
@


1.150
log
@2003-10-10  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_use_struct_convention): Clarify one case in
	comment.
@
text
@d791 49
d857 2
a858 1
  int pass_on_stack;
a884 2
      if (len > 16)
	pass_on_stack = 1;	/* Types bigger than 16 bytes are passed on stack. */
d887 2
a888 1
      if (TYPE_CODE (type) == TYPE_CODE_FLT)
d890 5
d898 3
a900 3
	  if ((TYPE_CODE (type) == TYPE_CODE_FLT
	       && flt_argreg > FLOAT_ARGLAST_REGNUM)
	      || argreg > ARGLAST_REGNUM || pass_on_stack)
d902 1
a902 2
	      /* The remainder of the data goes entirely on the stack,
	         4-byte aligned. */
d907 1
a907 2
	  else if (TYPE_CODE (type) == TYPE_CODE_FLT
		   && flt_argreg <= FLOAT_ARGLAST_REGNUM)
d914 1
a914 1
	  else if (argreg <= ARGLAST_REGNUM)
d921 1
a921 3
	  /* Store the value reg_size bytes at a time.  This means that things
	     larger than reg_size bytes may go partly in registers and partly
	     on the stack.  */
d1039 1
a1039 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
d1080 1
a1080 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
@


1.149
log
@	* sh-tdep.c (sh_use_struct_convention): Clean up to have a
	more readable code.  Accomodate passing of bitfields.
@
text
@d571 1
a571 1
   this location."
d584 10
@


1.148
log
@2003-10-10  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* NEWS: Replace "Hitachi" and "Mitsubishi" with "Renesas".
	* README: Ditto.
	* d10v-tdep.c: Ditto.
	* h8300-tdep.c: Ditto.
	* remote-e7000.c: Ditto.
	* remote-hms.c: Ditto.
	* ser-e7kpc.c: Ditto.
	* sh-stub.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* sh3-rom.c: Ditto.
	* sh64-tdep.c: Ditto.
	* top.c: Ditto.
	* wince.c: Ditto.
	* config/d10v/d10v.mt: Ditto.
	* config/sh/embed.mt: Ditto.
	* config/sh/linux.mt: Ditto.
	* config/sh/tm-linux.h: Ditto.
	* config/sh/tm-sh.h: Ditto.
	* config/sh/wince.mt: Ditto.
@
text
@d592 24
a615 2
  return ((len != 1 && len != 2 && len != 4 && len != 8) || nelem != 1) &&
    (len != 8 || TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) != 4);
@


1.147
log
@2003-10-09  Andrew Cagney  <cagney@@redhat.com>

	Changes from 2003-09-09 Jimi Xenidis <jimix@@watson.ibm.com>:
	* config/rs6000/tm-rs6000.h (SOFTWARE_SINGLE_STEP): Delete macro.
	(SOFTWARE_SINGLE_STEP_P): Ditto.
	* config/powerpc/tm-ppc-eabi.h (SOFTWARE_SINGLE_STEP_P): Ditto.
	* config/powerpc/tm-linux.h (SOFTWARE_SINGLE_STEP): Ditto.
	(SOFTWARE_SINGLE_STEP_P): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): When AIX, set
	software_single_step to rs6000_software_single_step.
@
text
@d1 1
a1 1
/* Target-dependent code for Hitachi Super-H, for GDB.
d617 1
a617 1
   On the Hitachi SH architecture, there are four registers (R4 to R7)
@


1.146
log
@2003-10-09  Elena Zannoni  <ezannoni@@redhat.com>

        * sh-tdep.c (sh_gdbarch_init): Delete setting of push_dummy_code.
        (sh_gdbarch_init): Delete function, it's only used for dummy calls
        on stack.

        Based on input by Stephen Clarke (stephen.clarke@@superh.com):
        * sh-tdep.c (sh_use_struct_convention): Add comment explaining ABI
        in detail.
@
text
@d1554 3
a1556 2
      register int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
	: register_size (gdbarch, regnum) - 1 - j;
@


1.145
log
@	* sh-tdep.c (sh_push_dummy_call_fpu): Initialize flt_argreg and
	reg_size to keep GCC silent.
@
text
@a268 16
static CORE_ADDR
sh_push_dummy_code (struct gdbarch *gdbarch,
		    CORE_ADDR sp, CORE_ADDR funaddr, int using_gcc,
		    struct value **args, int nargs,
		    struct type *value_type,
		    CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  /* Allocate space sufficient for a breakpoint.  */
  sp = (sp - 2) & ~1;
  /* Store the address of that breakpoint */
  *bp_addr = sp;
  /* sh always starts the call at the callee's entry point.  */
  *real_pc = funaddr;
  return sp;
}

d546 41
a586 1
/* Should call_function allocate stack space for a struct return?  */
a2058 1
  set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
@


1.144
log
@	* sh-tdep.c: Running thru gdb_indent.sh.
@
text
@d746 1
a746 1
  int flt_argreg;
d751 1
a751 1
  int len, reg_size;
@


1.143
log
@	* sh-tdep.c (sh_justify_value_in_reg): New function.
	(sh_stack_allocsize): Ditto.
	(flt_argreg_array): New array used for floating point argument
	passing.
	(sh_init_flt_argreg): New function.
	(sh_next_flt_argreg): Ditto.
	(sh_push_dummy_call_fpu): Simplify. Rename "odd_sized_struct" to
	"pass_on_stack". Use new helper functions.  Accomodate Renesas ABI.
	Fix argument passing strategy.
	(sh_push_dummy_call_nofpu): Ditto.
@
text
@d80 4
a83 5
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
d85 3
a87 3
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr",  "spc",
d101 10
a110 11
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
    "",     "",
    "",     "",     "",     "",     "",     "",     "",     "",
    "",     "",     "",     "",     "",     "",     "",     "",
    "",     "",
    "",     "",     "",     "",     "",     "",     "",     "",
    "",     "",     "",     "",     "",     "",     "",     "",
d122 8
a129 9
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
    "",     "",
    "",     "",     "",     "",     "",     "",     "",     "",
    "",     "",     "",     "",     "",     "",     "",     "",
    "ssr",  "spc",
d143 4
a146 5
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
d148 3
a150 3
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr",  "spc",
d164 4
a167 5
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
d169 3
a171 3
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "",  "",
d185 10
a194 11
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
    "",     "dsr",
    "a0g",  "a0",   "a1g",  "a1",   "m0",   "m1",   "x0",   "x1",
    "y0",   "y1",   "",     "",     "",     "",     "",     "mod",
    "",     "",
    "rs",   "re",   "",     "",     "",     "",     "",     "",
    "",     "",     "",     "",     "",     "",     "",     "",
d206 11
a216 12
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
    "",     "dsr",
    "a0g",  "a0",   "a1g",  "a1",   "m0",   "m1",   "x0",   "x1",
    "y0",   "y1",   "",     "",     "",     "",     "",     "mod",
    "ssr",  "spc",
    "rs",   "re",   "",     "",     "",     "",     "",     "",
    "r0b",  "r1b",  "r2b",  "r3b",  "r4b",  "r5b",  "r6b",  "r7b"
    "",     "",     "",     "",     "",     "",     "",     "",
d228 1
a228 2
  static char *register_names[] =
  {
d230 2
a231 2
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
d233 1
a233 1
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
d237 2
a238 2
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
d240 1
a240 1
    "ssr",  "spc",
d246 1
a246 1
    "dr0",  "dr2",  "dr4",  "dr6",  "dr8",  "dr10", "dr12", "dr14",
d248 1
a248 1
    "fv0",  "fv4",  "fv8",  "fv12",
d263 2
a264 2
  static unsigned char breakpoint[] =  {0xc3, 0xc3};
  
d364 1
a364 1
gdb_print_insn_sh (bfd_vma memaddr, disassemble_info *info)
d373 1
a373 1
{ 
d417 1
a417 1
        {
d426 1
a426 1
		  	read_memory_integer (((pc + 4) & ~3) + offset, 2);
d431 1
a431 1
        {
d440 1
a440 1
		  	read_memory_integer (((pc + 4) & ~3) + offset, 4);
d445 1
a445 1
        {
d465 1
a465 1
        {
d478 1
a478 1
	        {
d481 1
a481 1
		  cache->saved_regs[reg] = cache->sp_offset;
d484 1
a484 1
	        {
d491 1
a491 1
	        continue;
d497 3
a499 3
#if 0 /* This used to just stop when it found an instruction that
	 was not considered part of the prologue.  Now, we just
	 keep going looking for likely instructions. */
d569 1
a569 1
	  (len != 8 || TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) != 4);
d648 1
a648 1
  memset (valbuf, 0, sizeof (valbuf)); 
d659 1
a659 1
} 
d700 2
a701 1
  for (argreg = 0; argreg <= FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM; ++argreg)
d713 1
a713 1
        {
d718 1
a718 1
          /* No register left? */
d736 1
a736 1
sh_push_dummy_call_fpu (struct gdbarch *gdbarch, 
d738 1
a738 1
			struct regcache *regcache, 
d740 1
a740 1
			struct value **args, 
d759 1
a759 2
				    STRUCT_RETURN_REGNUM,
				    struct_addr);
d780 1
a780 1
        pass_on_stack = 1; /* Types bigger than 16 bytes are passed on stack. */
d784 1
a784 1
        flt_argreg = sh_next_flt_argreg (len);
d788 1
a788 1
	  if ((TYPE_CODE (type) == TYPE_CODE_FLT 
d790 2
a791 3
	      || argreg > ARGLAST_REGNUM
	      || pass_on_stack)
	    {                    
d831 1
a831 1
sh_push_dummy_call_nofpu (struct gdbarch *gdbarch, 
d833 4
a836 4
			  struct regcache *regcache, 
			  CORE_ADDR bp_addr, 
			  int nargs, struct value **args, 
			  CORE_ADDR sp, int struct_return, 
d852 1
a852 2
				    STRUCT_RETURN_REGNUM,
				    struct_addr);
d861 1
a861 1
    { 
d869 1
a869 1
	    {                   
d874 1
a874 1
	      stack_offset += reg_size; 
d877 1
a877 1
	    {                   
d911 1
a911 1
  
d923 1
a923 1
	regcache_raw_read (regcache, regnum++, (char *)valbuf + i);
d938 1
a938 1
	regcache_raw_read (regcache, regnum++, (char *)valbuf + i);
d966 1
a966 1
        regcache_raw_write (regcache, regnum++, (char *)valbuf + i);
d974 1
a974 1
  if (TYPE_CODE (type) == TYPE_CODE_FLT) 
d979 1
a979 1
        regcache_raw_write (regcache, regnum++, (char *)valbuf + i);
d1001 6
a1006 9
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
d1008 4
a1011 8
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
d1028 1
a1028 1
	           (long) read_register (SSR_REGNUM),
d1031 6
a1036 9
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
d1038 4
a1041 8
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
d1059 2
a1060 2
	  	   (long) read_register (FPUL_REGNUM),
                   (long) read_register (FPSCR_REGNUM));
d1062 6
a1067 9
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
d1069 4
a1072 8
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
d1074 2
a1075 18
  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
d1098 6
a1103 9
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
d1105 4
a1108 8
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
d1110 2
a1111 18
  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
d1132 1
a1132 2
  printf_filtered (" DSR=%08lx", 
		   (long) read_register (DSR_REGNUM));
d1134 6
a1139 9
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
d1141 11
a1151 17
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));

  printf_filtered ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
		   (long) read_register (A0G_REGNUM) & 0xff,
		   (long) read_register (A0_REGNUM),
		   (long) read_register (M0_REGNUM),
		   (long) read_register (X0_REGNUM),
		   (long) read_register (Y0_REGNUM),
		   (long) read_register (RS_REGNUM),
		   (long) read_register (MOD_REGNUM));
d1182 6
a1187 9
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
d1189 4
a1192 8
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
d1196 2
a1197 1
		    : "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
d1206 3
a1208 3
  printf_filtered ((pr
		    ? "DR8-DR14 %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n"
		    : "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
d1233 1
a1233 2
  printf_filtered (" DSR=%08lx", 
		   (long) read_register (DSR_REGNUM));
d1235 6
a1240 9
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
d1242 11
a1252 17
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));

  printf_filtered ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
		   (long) read_register (A0G_REGNUM) & 0xff,
		   (long) read_register (A0_REGNUM),
		   (long) read_register (M0_REGNUM),
		   (long) read_register (X0_REGNUM),
		   (long) read_register (Y0_REGNUM),
		   (long) read_register (RS_REGNUM),
		   (long) read_register (MOD_REGNUM));
d1266 1
a1266 1
    (*sh_show_regs)();
d1275 1
a1275 2
       && (reg_nr <= FP_LAST_REGNUM)) 
      || (reg_nr == FPUL_REGNUM))
d1294 1
a1294 2
       && (reg_nr <= FP_LAST_REGNUM)) 
      || (reg_nr == FPUL_REGNUM))
d1296 1
a1296 2
  else if (reg_nr >= DR0_REGNUM 
	   && reg_nr <= DR_LAST_REGNUM)
d1298 1
a1298 2
  else if  (reg_nr >= FV0_REGNUM 
	   && reg_nr <= FV_LAST_REGNUM)
d1338 1
a1338 1
                                  char *from, char *to)
d1340 1
a1340 2
  if (regnum >= DR0_REGNUM 
      && regnum <= DR_LAST_REGNUM)
d1343 2
a1344 1
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword, from, &val);
d1348 2
a1349 1
    error ("sh_register_convert_to_virtual called with non DR register number");
d1356 1
a1356 2
  if (regnum >= DR0_REGNUM 
      && regnum <= DR_LAST_REGNUM)
d1359 2
a1360 1
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword, &val, to);
d1363 1
a1363 1
    error("sh_register_convert_to_raw called with non DR register number");
d1372 1
a1372 2
  fp_regnum = FP0_REGNUM + 
    (fv_regnum - FV0_REGNUM) * 4;
d1382 1
a1382 2
  fp_regnum = FP0_REGNUM + 
    (dr_regnum - DR0_REGNUM) * 2;
d1393 1
a1393 2
  if (reg_nr >= DR0_REGNUM 
      && reg_nr <= DR_LAST_REGNUM)
d1397 1
a1397 1
      /* Build the value in the provided buffer. */ 
d1400 1
a1400 1
	regcache_raw_read (regcache, base_regnum + portion, 
d1402 2
a1403 1
			    + register_size (gdbarch, base_regnum) * portion));
d1406 2
a1407 1
					  gdbarch_register_type (gdbarch, reg_nr),
d1410 1
a1410 2
  else if (reg_nr >= FV0_REGNUM 
	   && reg_nr <= FV_LAST_REGNUM)
d1416 1
a1416 1
	regcache_raw_read (regcache, base_regnum + portion, 
d1418 2
a1419 1
			    + register_size (gdbarch, base_regnum) * portion));
d1430 1
a1430 2
  if (reg_nr >= DR0_REGNUM
      && reg_nr <= DR_LAST_REGNUM)
d1435 2
a1436 2
      sh_sh4_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr), reg_nr,
				      buffer, temp_buffer);
d1440 1
a1440 1
	regcache_raw_write (regcache, base_regnum + portion, 
d1442 2
a1443 1
			     + register_size (gdbarch, base_regnum) * portion));
d1445 1
a1445 2
  else if (reg_nr >= FV0_REGNUM
	   && reg_nr <= FV_LAST_REGNUM)
d1453 2
a1454 1
			     + register_size (gdbarch, base_regnum) * portion));
d1464 6
a1469 6
  fprintf_filtered (file, "fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
		     fv_regnum - FV0_REGNUM, 
		     (int) read_register (first_fp_reg_num),
		     (int) read_register (first_fp_reg_num + 1),
		     (int) read_register (first_fp_reg_num + 2),
		     (int) read_register (first_fp_reg_num + 3));
d1479 2
a1480 2
  fprintf_filtered (file, "dr%d\t0x%08x%08x\n", 
		    dr_regnum - DR0_REGNUM, 
d1492 1
a1492 2
  else if (regnum >= DR0_REGNUM
	   && regnum <= DR_LAST_REGNUM)
d1494 1
a1494 2
  else if (regnum >= FV0_REGNUM
	   && regnum <= FV_LAST_REGNUM)
d1502 1
a1502 1
  double flt;	/* double extracted from raw hex data */
d1513 1
a1513 1
  /* Get the register as a number */ 
d1549 1
a1549 1
      
d1567 2
a1568 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d1601 1
a1601 1
	    { 
d1606 2
a1607 1
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d1613 1
a1613 1
		  regnum ++;
d1657 1
a1657 1
      lmo.r_map_size   = 4;
d1662 1
a1662 1
      lmo.l_addr_size   = 4;
d1665 1
a1665 1
      lmo.l_name_size   = 4;
d1668 1
a1668 1
      lmo.l_next_size   = 4;
d1671 1
a1671 1
      lmo.l_prev_size   = 4;
d1674 1
a1674 1
    return lmp;
d1712 1
a1712 1
    
d1719 1
a1719 1
  
d1721 1
a1721 1
} 
d1749 1
a1749 1
    
d1792 4
a1795 4
        {
          /* Store the value.  */
          store_unsigned_integer (valuep, 4, cache->saved_sp);
        }
d1812 5
a1816 5
        {
          /* Read the value in from memory.  */
          read_memory (*addrp, valuep,
                       register_size (current_gdbarch, regnum));
        }
d1821 1
a1821 1
                         optimizedp, lvalp, addrp, realnump, valuep);
d1826 2
a1827 2
                    struct frame_id *this_id)
{ 
d1835 1
a1835 1
} 
d1837 1
a1837 2
static const struct frame_unwind sh_frame_unwind =
{
d1870 1
a1870 1
{ 
d1872 1
a1872 1
  
d1875 2
a1876 3
  
static const struct frame_base sh_frame_base =
{
d1881 1
a1881 1
};  
d1896 2
a1897 2
	 unfortunately also treated as part of the function (which
	 means, they are below func_end. */
d1900 1
a1900 1
        addr = func_addr + 4;
d1906 1
a1906 1
             && !IS_RTS (read_memory_unsigned_integer (addr, 2)))
d1909 1
a1909 1
        return 0;
d1913 1
a1913 1
	 probably no "normal" epilogue and we bail out here. */
d1916 1
a1916 1
        addr -= 2;
d1923 1
a1923 1
        {
d1930 1
a1930 1
        {
d1938 1
a1938 1
             && (IS_ADD_REG_TO_FP (inst) || IS_ADD_IMM_FP (inst)))
d1960 6
a1965 6
      case bfd_mach_sh2e:
	sh_show_regs = sh2e_show_regs;
	break;
      case bfd_mach_sh_dsp:
	sh_show_regs = sh_dsp_show_regs;
	break;
d1967 3
a1969 3
      case bfd_mach_sh3:
	sh_show_regs = sh3_show_regs;
	break;
d1971 3
a1973 3
      case bfd_mach_sh3e:
	sh_show_regs = sh3e_show_regs;
	break;
d1975 3
a1977 3
      case bfd_mach_sh3_dsp:
	sh_show_regs = sh3_dsp_show_regs;
	break;
d1979 3
a1981 3
      case bfd_mach_sh4:
	sh_show_regs = sh4_show_regs;
	break;
d1983 4
a1986 4
      case bfd_mach_sh5:
	sh_show_regs = sh64_show_regs;
	/* SH5 is handled entirely in sh64-tdep.c */
	return sh64_gdbarch_init (info, arches);
d2049 1
a2049 2
  set_gdbarch_in_function_epilogue_p (gdbarch,
				      sh_in_function_epilogue_p);
d2059 1
a2059 1
      break;      
d2069 2
a2070 1
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d2091 2
a2092 1
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d2109 2
a2110 1
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d2128 1
a2128 1
extern initialize_file_ftype _initialize_sh_tdep; /* -Wmissing-prototypes */
d2134 1
a2134 1
  
@


1.142
log
@	* sh-tdep.c (struct frame_extra_info): Remove.
	(struct sh_frame_cache): New structure.
	(GET_SOURCE_REG): New macro extracting source register of an opcode.
	(GET_TARGET_REG): Ditto but target register.
	(GET_PUSHED_REG): Remove.
	(IS_MOV_ARG_TO_REG): New macro.
	(IS_MOV_ARG_TO_IND_R14): New macro.
	(IS_MOV_ARG_TO_IND_R14_WITH_DISP): New macro.
	(IS_MOVW_PCREL_TO_REG): New macro.
	(IS_MOVL_PCREL_TO_REG): New macro.
	(IS_SUB_REG_FROM_SP): New macro.
	(IS_ARG_MOV): Remove.
	(IS_MOV_TO_R14): Remove.
	(IS_RESTORE_FP): New macro.
	(IS_RTS): New macro.
	(IS_LDS): New macro.
	(IS_MOV_FP_SP): New macro.
	(IS_ADD_REG_TO_FP): New macro.
	(IS_ADD_IMM_FP): New macro.
	(sh_skip_prologue_hard_way): Remove.
	(sh_saved_pc_after_call): Remove.
	(sh_frame_chain): Remove.
	(sh_find_callers_reg): Remove.
	(sh_nofp_frame_init_saved_regs): Remove.
	(sh_fp_frame_init_saved_regs): Remove.
	(sh_init_extra_frame_info): Remove.
	(sh_analyze_prologue): New function.
	(sh_skip_prologue): Remove deprecated code.  Rely on new function
	sh_analyze_prologue when after_prologue fails.
	(sh_frame_saved_pc): Remove.
	(sh_alloc_frame_cache): New function.
	(sh_frame_cache): Ditto.
	(sh_frame_prev_register): Ditto.
	(sh_frame_this_id): Ditto.
	(sh_frame_unwind): New structure defining the heuristic frame
	sniffer interface.
	(sh_frame_sniffer): New function.
	(sh_unwind_sp): Ditto.
	(sh_unwind_pc): Ditto.
	(sh_unwind_dummy_id): Ditto.
	(sh_frame_base_address): Ditto.
	(sh_frame_base): New structure defining new frame base code.
	(sh_in_function_epilogue_p): New function.
	(sh_gdbarch_init): Restructure and simplify to eliminate deprecated
	code and to call all new code instead.  Initialize dwarf2 and
	heuristic frame sniffer.
@
text
@d650 92
d751 3
a753 2
  int stack_offset, stack_alloc;
  int argreg, flt_argreg;
d758 2
a759 3
  char valbuf[4];
  int len;
  int odd_sized_struct;
d769 5
a773 4
  /* Now make sure there's space on the stack */
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */
d778 1
a778 4

  argreg = ARG0_REGNUM;
  flt_argreg = FLOAT_ARG0_REGNUM;
  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
d782 11
a792 13
      memset (valbuf, 0, sizeof (valbuf));
      if (len < 4)
	{
	  /* value gets right-justified in the register or stack word */
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    memcpy (valbuf + (4 - len),
		    (char *) VALUE_CONTENTS (args[argnum]), len);
	  else
	    memcpy (valbuf, (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
	}
      else
	val = (char *) VALUE_CONTENTS (args[argnum]);
a793 6
      if (len > 4 && (len & 3) != 0)
	odd_sized_struct = 1;	/* Such structs go entirely on stack.  */
      else if (len > 16)
	odd_sized_struct = 1;	/* So do aggregates bigger than 4 words.  */
      else
	odd_sized_struct = 0;
d797 1
a797 1
	       && flt_argreg > FLOAT_ARGLAST_REGNUM) 
d799 7
a805 5
	      || odd_sized_struct)
	    {			
	      /* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
d807 2
a808 5
	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
	     That's because some *&^%$ things get passed on the stack
	     AND in the registers!   */
	  if (TYPE_CODE (type) == TYPE_CODE_FLT &&
	      flt_argreg > 0 && flt_argreg <= FLOAT_ARGLAST_REGNUM)
d810 3
a812 3
	      /* Argument goes in a single-precision fp reg.  */
	      regval = extract_unsigned_integer (val, register_size (gdbarch,
								     argreg));
d816 1
a816 1
	    {			
d818 2
a819 2
	      regval = extract_unsigned_integer (val, register_size (gdbarch,
								     argreg));
d822 2
a823 2
	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
d825 2
a826 2
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
d848 2
a849 2
  int stack_offset, stack_alloc;
  int argreg;
d854 1
a854 3
  char valbuf[4];
  int len;
  int odd_sized_struct;
d864 2
a865 4
  /* Now make sure there's space on the stack */
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */
d870 2
a871 4

  argreg = ARG0_REGNUM;
  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
d874 1
a874 13
      memset (valbuf, 0, sizeof (valbuf));
      if (len < 4)
	{
	  /* value gets right-justified in the register or stack word */
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    memcpy (valbuf + (4 - len),
		    (char *) VALUE_CONTENTS (args[argnum]), len);
	  else
	    memcpy (valbuf, (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
	}
      else
	val = (char *) VALUE_CONTENTS (args[argnum]);
a875 4
      if (len > 4 && (len & 3) != 0)
	odd_sized_struct = 1;	/* such structs go entirely on stack */
      else
	odd_sized_struct = 0;
d878 7
a884 6
	  if (argreg > ARGLAST_REGNUM
	      || odd_sized_struct)
	    {			
	      /* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
d886 2
a887 5
	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
	     That's because some *&^%$ things get passed on the stack
	     AND in the registers!   */
	  if (argreg <= ARGLAST_REGNUM)
	    {			
d889 2
a890 2
	      regval = extract_unsigned_integer (val, register_size (gdbarch,
								     argreg));
d893 2
a894 2
	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
d896 2
a897 2
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
@


1.141
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d29 3
d41 1
d62 1
a62 5
/* Define other aspects of the stack frame.
   we keep a copy of the worked out return pc lying around, since it
   is a useful bit of info */
  
struct frame_extra_info
d64 11
a74 3
  CORE_ADDR return_pc;
  int leaf_function;
  int f_offset;
d294 5
a298 20
   [mov.l       <regs>,@@-r15]...
   [sts.l       pr,@@-r15]
   [mov.l       r14,@@-r15]
   [mov         r15,r14]

   Actually it can be more complicated than this.  For instance, with
   newer gcc's:

   mov.l   r14,@@-r15
   add     #-12,r15
   mov     r15,r14
   mov     r4,r1
   mov     r5,r2
   mov.l   r6,@@(4,r14)
   mov.l   r7,@@(8,r14)
   mov.b   r1,@@r14
   mov     r14,r1
   mov     r14,r1
   add     #2,r1
   mov.w   r2,@@r1
d300 1
d303 3
a313 2
#define GET_PUSHED_REG(x)  	(((x) >> 4) & 0xf)

d320 1
a320 1
#define IS_ADD_IMM_SP(x)	(((x) & 0xff00) == 0x7f00)
d334 25
a358 1
#define IS_FPUSH(x)		(((x) & 0xf00f) == 0xf00b)
a359 14
/* MOV Rm,Rn            Rm-->Rn          0110nnnnmmmm0011 
   MOV.L Rm,@@(disp,Rn)  Rm-->(dispx4+Rn) 0001nnnnmmmmdddd
   MOV.L Rm,@@Rn         Rm-->(Rn)        0010nnnnmmmm0010
   where Rm is one of r4,r5,r6,r7 which are the argument registers. */
#define IS_ARG_MOV(x) \
(((((x) & 0xf00f) == 0x6003) && (((x) & 0x00f0) >= 0x0040 && ((x) & 0x00f0) <= 0x0070)) \
 || ((((x) & 0xf000) == 0x1000) && (((x) & 0x00f0) >= 0x0040 && ((x) & 0x00f0) <= 0x0070)) \
 || ((((x) & 0xf00f) == 0x2002) && (((x) & 0x00f0) >= 0x0040 && ((x) & 0x00f0) <= 0x0070)))

/* MOV.L Rm,@@(disp,r14)  00011110mmmmdddd
   Rm-->(dispx4+r14) where Rm is one of r4,r5,r6,r7 */
#define IS_MOV_TO_R14(x) \
     ((((x) & 0xff00) == 0x1e) && (((x) & 0x00f0) >= 0x0040 && ((x) & 0x00f0) <= 0x0070))
                        
d362 7
a368 109
/* Skip any prologue before the guts of a function */

/* Skip the prologue using the debug information. If this fails we'll
   fall back on the 'guess' method below. */
static CORE_ADDR
after_prologue (CORE_ADDR pc)
{
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;

  /* If we can not find the symbol in the partial symbol table, then
     there is no hope we can determine the function's start address
     with this code.  */
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    return 0;

  /* Get the line associated with FUNC_ADDR.  */
  sal = find_pc_line (func_addr, 0);

  /* There are only two cases to consider.  First, the end of the source line
     is within the function bounds.  In that case we return the end of the
     source line.  Second is the end of the source line extends beyond the
     bounds of the current function.  We need to use the slow code to
     examine instructions in that case.  */
  if (sal.end < func_end)
    return sal.end;
  else
    return 0;
}

/* Here we look at each instruction in the function, and try to guess
   where the prologue ends. Unfortunately this is not always 
   accurate. */
static CORE_ADDR
sh_skip_prologue_hard_way (CORE_ADDR start_pc)
{
  CORE_ADDR here, end;
  int updated_fp = 0;

  if (!start_pc)
    return 0;

  for (here = start_pc, end = start_pc + (2 * 28); here < end;)
    {
      int w = read_memory_integer (here, 2);
      here += 2;
      if (IS_FPUSH (w) || IS_PUSH (w) || IS_STS (w) || IS_MOV_R3 (w)
	  || IS_ADD_R3SP (w) || IS_ADD_IMM_SP (w) || IS_SHLL_R3 (w) 
	  || IS_ARG_MOV (w) || IS_MOV_TO_R14 (w))
	{
	  start_pc = here;
	}
      else if (IS_MOV_SP_FP (w))
	{
	  start_pc = here;
	  updated_fp = 1;
	}
      else
	/* Don't bail out yet, if we are before the copy of sp. */
	if (updated_fp)
	  break;
    }

  return start_pc;
}

static CORE_ADDR
sh_skip_prologue (CORE_ADDR pc)
{
  CORE_ADDR post_prologue_pc;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  post_prologue_pc = after_prologue (pc);

  /* If after_prologue returned a useful address, then use it.  Else
     fall back on the instruction skipping code. */
  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);
  else
    return sh_skip_prologue_hard_way (pc);
}

/* Immediately after a function call, return the saved pc.
   Can't always go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.

   The return address is the value saved in the PR register + 4  */
static CORE_ADDR
sh_saved_pc_after_call (struct frame_info *frame)
{
  return (ADDR_BITS_REMOVE (read_register (PR_REGNUM)));
}

/* Should call_function allocate stack space for a struct return?  */
static int
sh_use_struct_convention (int gcc_p, struct type *type)
{
#if 0
  return (TYPE_LENGTH (type) > 1);
#else
  int len = TYPE_LENGTH (type);
  int nelem = TYPE_NFIELDS (type);
  return ((len != 1 && len != 2 && len != 4 && len != 8) || nelem != 1) &&
	  (len != 8 || TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) != 4);
#endif
}
a377 7
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC
   will be called for the new frame.

   For us, the frame address is its stack pointer value, so we look up
   the function prologue to determine the caller's sp value, and return it.  */
d379 7
a385 56
sh_frame_chain (struct frame_info *frame)
{
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    return get_frame_base (frame);	/* dummy frame same as caller's frame */
  if (get_frame_pc (frame)
      && !deprecated_inside_entry_file (get_frame_pc (frame)))
    return read_memory_integer (get_frame_base (frame)
				+ get_frame_extra_info (frame)->f_offset, 4);
  else
    return 0;
}

/* Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing
   we might want to do here is to check REGNUM against the clobber mask, and
   somehow flag it as invalid if it isn't saved on the stack somewhere.  This
   would provide a graceful failure mode when trying to get the value of
   caller-saves registers for an inner frame.  */
static CORE_ADDR
sh_find_callers_reg (struct frame_info *fi, int regnum)
{
  for (; fi; fi = get_next_frame (fi))
    if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				     get_frame_base (fi)))
      /* When the caller requests PR from the dummy frame, we return PC because
         that's where the previous routine appears to have done a call from. */
      return deprecated_read_register_dummy (get_frame_pc (fi),
					     get_frame_base (fi), regnum);
    else
      {
	DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
	if (!get_frame_pc (fi))
	  return 0;
	if (get_frame_saved_regs (fi)[regnum] != 0)
	  return read_memory_integer (get_frame_saved_regs (fi)[regnum],
				      register_size (current_gdbarch, regnum));
      }
  return read_register (regnum);
}

/* Put here the code to store, into a struct frame_saved_regs, the
   addresses of the saved registers of frame described by FRAME_INFO.
   This includes special registers such as pc and fp saved in special
   ways in the stack frame.  sp is even more special: the address we
   return for it IS the sp for the next frame. */
static void
sh_nofp_frame_init_saved_regs (struct frame_info *fi)
{
  int *where = (int *) alloca ((NUM_REGS + NUM_PSEUDO_REGS) * sizeof(int));
  int rn;
  int have_fp = 0;
  int depth;
  int pc;
  int opc;
  int inst;
d387 1
a387 16
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi),
							  get_frame_base (fi));
  
  if (get_frame_saved_regs (fi) == NULL)
    frame_saved_regs_zalloc (fi);
  else
    memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
  
  if (dummy_regs)
    {
      /* DANGER!  This is ONLY going to work if the char buffer format of
         the saved registers is byte-for-byte identical to the 
         CORE_ADDR regs[NUM_REGS] format used by struct frame_saved_regs! */
      memcpy (get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
      return;
    }
d389 2
a390 18
  get_frame_extra_info (fi)->leaf_function = 1;
  get_frame_extra_info (fi)->f_offset = 0;

  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    where[rn] = -1;

  depth = 0;

  /* Loop around examining the prologue inst until we find something
     that does not appear to be part of the prologue.  But give up
     after 20 of them, since we're getting silly then. */

  pc = get_frame_func (fi);
  if (!pc)
    {
      deprecated_update_frame_pc_hack (fi, 0);
      return;
    }
d392 1
d395 1
a395 1
      inst = read_memory_integer (pc, 2);
d399 2
a400 3
	  rn = GET_PUSHED_REG (inst);
	  where[rn] = depth;
	  depth += 4;
d404 2
a405 4
	  where[PR_REGNUM] = depth;
	  /* If we're storing the pr then this isn't a leaf */
	  get_frame_extra_info (fi)->leaf_function = 0;
	  depth += 4;
d417 1
a417 1
	  depth += -r3_val;
d421 2
a422 1
	  depth -= ((inst & 0xff) ^ 0x80) - 0x80;
d424 13
a436 20
      else if (IS_MOV_SP_FP (inst))
	break;
#if 0 /* This used to just stop when it found an instruction that
	 was not considered part of the prologue.  Now, we just
	 keep going looking for likely instructions. */
      else
	break;
#endif
    }

  /* Now we know how deep things are, we can work out their addresses */

  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    {
      if (where[rn] >= 0)
	{
	  if (rn == DEPRECATED_FP_REGNUM)
	    have_fp = 1;

	  get_frame_saved_regs (fi)[rn] = get_frame_base (fi) - where[rn] + depth - 4;
d438 13
a450 3
      else
	{
	  get_frame_saved_regs (fi)[rn] = 0;
d452 8
a459 116
    }

  if (have_fp)
    {
      get_frame_saved_regs (fi)[SP_REGNUM] = read_memory_integer (get_frame_saved_regs (fi)[DEPRECATED_FP_REGNUM], 4);
    }
  else
    {
      get_frame_saved_regs (fi)[SP_REGNUM] = get_frame_base (fi) - 4;
    }

  get_frame_extra_info (fi)->f_offset = depth - where[DEPRECATED_FP_REGNUM] - 4;
  /* Work out the return pc - either from the saved pr or the pr
     value */
}

/* For vectors of 4 floating point registers. */
static int
fv_reg_base_num (int fv_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + 
    (fv_regnum - FV0_REGNUM) * 4;
  return fp_regnum;
}

/* For double precision floating point registers, i.e 2 fp regs.*/
static int
dr_reg_base_num (int dr_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + 
    (dr_regnum - DR0_REGNUM) * 2;
  return fp_regnum;
}

static void
sh_fp_frame_init_saved_regs (struct frame_info *fi)
{
  int *where = (int *) alloca ((NUM_REGS + NUM_PSEUDO_REGS) * sizeof (int));
  int rn;
  int have_fp = 0;
  int depth;
  int pc;
  int opc;
  int inst;
  int r3_val = 0;
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), get_frame_base (fi));
  
  if (get_frame_saved_regs (fi) == NULL)
    frame_saved_regs_zalloc (fi);
  else
    memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
  
  if (dummy_regs)
    {
      /* DANGER!  This is ONLY going to work if the char buffer format of
         the saved registers is byte-for-byte identical to the 
         CORE_ADDR regs[NUM_REGS] format used by struct frame_saved_regs! */
      memcpy (get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
      return;
    }

  get_frame_extra_info (fi)->leaf_function = 1;
  get_frame_extra_info (fi)->f_offset = 0;

  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    where[rn] = -1;

  depth = 0;

  /* Loop around examining the prologue inst until we find something
     that does not appear to be part of the prologue.  But give up
     after 20 of them, since we're getting silly then. */

  pc = get_frame_func (fi);
  if (!pc)
    {
      deprecated_update_frame_pc_hack (fi, 0);
      return;
    }

  for (opc = pc + (2 * 28); pc < opc; pc += 2)
    {
      inst = read_memory_integer (pc, 2);
      /* See where the registers will be saved to */
      if (IS_PUSH (inst))
	{
	  rn = GET_PUSHED_REG (inst);
	  where[rn] = depth;
	  depth += 4;
	}
      else if (IS_STS (inst))
	{
	  where[PR_REGNUM] = depth;
	  /* If we're storing the pr then this isn't a leaf */
	  get_frame_extra_info (fi)->leaf_function = 0;
	  depth += 4;
	}
      else if (IS_MOV_R3 (inst))
	{
	  r3_val = ((inst & 0xff) ^ 0x80) - 0x80;
	}
      else if (IS_SHLL_R3 (inst))
	{
	  r3_val <<= 1;
	}
      else if (IS_ADD_R3SP (inst))
	{
	  depth += -r3_val;
	}
      else if (IS_ADD_IMM_SP (inst))
	{
	  depth -= ((inst & 0xff) ^ 0x80) - 0x80;
d465 1
a465 1
	      depth += 8;
d469 1
a469 1
	      depth += 4;
d473 32
a504 1
	break;
d513 4
a516 1
  /* Now we know how deep things are, we can work out their addresses */
d518 13
a530 6
  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    {
      if (where[rn] >= 0)
	{
	  if (rn == DEPRECATED_FP_REGNUM)
	    have_fp = 1;
d532 2
a533 7
	  get_frame_saved_regs (fi)[rn] = get_frame_base (fi) - where[rn] + depth - 4;
	}
      else
	{
	  get_frame_saved_regs (fi)[rn] = 0;
	}
    }
d535 7
a541 5
  if (have_fp)
    {
      get_frame_saved_regs (fi)[SP_REGNUM] =
	read_memory_integer (get_frame_saved_regs (fi)[DEPRECATED_FP_REGNUM], 4);
    }
d543 1
a543 7
    {
      get_frame_saved_regs (fi)[SP_REGNUM] = get_frame_base (fi) - 4;
    }

  get_frame_extra_info (fi)->f_offset = depth - where[DEPRECATED_FP_REGNUM] - 4;
  /* Work out the return pc - either from the saved pr or the pr
     value */
d546 2
a547 3
/* Initialize the extra info saved in a FRAME */
static void
sh_init_extra_frame_info (int fromleaf, struct frame_info *fi)
d549 12
d562 4
a565 1
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
d567 2
a568 2
  if (get_next_frame (fi))
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));
d570 8
a577 20
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				   get_frame_base (fi)))
    {
      /* We need to setup fi->frame here because call_function_by_hand
         gets it wrong by assuming it's always FP.  */
      deprecated_update_frame_base_hack (fi, deprecated_read_register_dummy (get_frame_pc (fi), get_frame_base (fi),
									     SP_REGNUM));
      get_frame_extra_info (fi)->return_pc = deprecated_read_register_dummy (get_frame_pc (fi),
								  get_frame_base (fi),
								  PC_REGNUM);
      get_frame_extra_info (fi)->f_offset = -(DEPRECATED_CALL_DUMMY_LENGTH + 4);
      get_frame_extra_info (fi)->leaf_function = 0;
      return;
    }
  else
    {
      DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
      get_frame_extra_info (fi)->return_pc = 
	sh_find_callers_reg (fi, PR_REGNUM);
    }
d587 1
a592 36
sh_frame_saved_pc (struct frame_info *frame)
{
  return (get_frame_extra_info (frame)->return_pc);
}

/* Discard from the stack the innermost frame,
   restoring all saved registers.  */
static void
sh_pop_frame (void)
{
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR fp;
  int regnum;

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    generic_pop_dummy_frame ();
  else
    {
      fp = get_frame_base (frame);
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);

      /* Copy regs from where they were saved in the frame */
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
	if (get_frame_saved_regs (frame)[regnum])
	  write_register (regnum,
			  read_memory_integer (get_frame_saved_regs (frame)[regnum], 4));

      write_register (PC_REGNUM, get_frame_extra_info (frame)->return_pc);
      write_register (SP_REGNUM, fp + 4);
    }
  flush_cached_frames ();
}

static CORE_ADDR
a671 2
  /* The "struct return pointer" pseudo-argument has its own dedicated 
     register */
d673 2
a674 2
    regcache_cooked_write_unsigned (regcache, 
				    STRUCT_RETURN_REGNUM, 
a779 2
  /* The "struct return pointer" pseudo-argument has its own dedicated 
     register */
d1408 22
d1575 1
a1575 1
      int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
d1738 257
a1994 1

d2006 2
a2007 2
        sh_show_regs = sh2e_show_regs;
        break;
d2009 2
a2010 2
        sh_show_regs = sh_dsp_show_regs;
        break;
d2013 2
a2014 2
        sh_show_regs = sh3_show_regs;
        break;
d2017 2
a2018 2
        sh_show_regs = sh3e_show_regs;
        break;
d2021 2
a2022 2
        sh_show_regs = sh3_dsp_show_regs;
        break;
d2025 2
a2026 2
        sh_show_regs = sh4_show_regs;
        break;
d2030 2
a2031 2
        /* SH5 is handled entirely in sh64-tdep.c */
        return sh64_gdbarch_init (info, arches);
a2042 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

a2053 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 14);
d2058 4
d2070 5
d2080 3
d2084 2
a2085 1
  set_gdbarch_frameless_function_invocation (gdbarch, frameless_look_for_prologue);
a2087 6
  set_gdbarch_deprecated_frame_chain (gdbarch, sh_frame_chain);
  set_gdbarch_deprecated_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sh_init_extra_frame_info);
  set_gdbarch_deprecated_pop_frame (gdbarch, sh_pop_frame);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sh_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sh_saved_pc_after_call);
d2089 7
d2101 1
a2101 7
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2102 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      break;
d2105 1
a2105 7
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2106 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      break;      
a2111 1
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
a2112 1
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
d2117 1
a2117 1
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2118 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      break;
a2120 3
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
d2122 1
a2122 4
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2123 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      break;
d2126 1
a2126 7
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2127 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      break;
a2132 1
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
a2133 1
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
d2138 1
a2138 1
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2139 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
      break;
a2141 3
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
d2143 1
a2143 4
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2144 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      break;
a2146 1
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
a2147 1
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
d2155 1
a2155 1
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a2156 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
      break;
a2158 7
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d2164 3
@


1.140
log
@	* sh-tdep.h (struct gdbarch_tdep): Remove.  Change all register
	numbers to enumeration values.
	* sh-tdep.c: Accomodate above change.
	(SH_NUM_REGS): Rename from SH_DEFAULT_NUM_REGS.
	(NUM_PSEUDO_REGS_SH_MEDIA): Remove (sh5 only).
	(NUM_PSEUDO_REGS_SH_COMPACT): Remove (sh5 only).
	(IS_ADD_IMM_SP): Rename from IS_ADD_SP.
	(IS_FPUSH): Rename from IS_FMOV.
	(sh_extract_struct_value_address): Remove useless comment.
	(sh_dsp_register_sim_regno): Use register values from sh-tdep.h
	instead of own local values.
	(sh_dump_tdep): Remove.
	(_initialize_sh_tdep): Accomodate removing sh_dump_tdep.
	* sh3-rom.c (sh3_supply_register): Accomodate sh-tdep.h changes.
@
text
@d1848 1
a1848 1
      register int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
@


1.139
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d56 1
a56 1
#define SH_DEFAULT_NUM_REGS 59
a258 3
#define NUM_PSEUDO_REGS_SH_MEDIA 80
#define NUM_PSEUDO_REGS_SH_COMPACT 51

d325 1
a325 1
#define IS_ADD_SP(x) 		(((x) & 0xff00) == 0x7f00)
d337 3
a339 1
#define IS_FMOV(x)		(((x) & 0xf00f) == 0xf00b)
d403 2
a404 2
      if (IS_FMOV (w) || IS_PUSH (w) || IS_STS (w) || IS_MOV_R3 (w)
	  || IS_ADD_R3SP (w) || IS_ADD_SP (w) || IS_SHLL_R3 (w) 
d538 1
a538 1
  int insn;
d565 1
a565 1
  /* Loop around examining the prologue insns until we find something
d578 1
a578 1
      insn = read_memory_integer (pc, 2);
d580 1
a580 1
      if (IS_PUSH (insn))
d582 1
a582 1
	  rn = GET_PUSHED_REG (insn);
d586 1
a586 1
      else if (IS_STS (insn))
d593 1
a593 1
      else if (IS_MOV_R3 (insn))
d595 1
a595 1
	  r3_val = ((insn & 0xff) ^ 0x80) - 0x80;
d597 1
a597 1
      else if (IS_SHLL_R3 (insn))
d601 1
a601 1
      else if (IS_ADD_R3SP (insn))
d605 1
a605 1
      else if (IS_ADD_SP (insn))
d607 1
a607 1
	  depth -= ((insn & 0xff) ^ 0x80) - 0x80;
d609 1
a609 1
      else if (IS_MOV_SP_FP (insn))
d657 1
a657 1
    (fv_regnum - gdbarch_tdep (current_gdbarch)->FV0_REGNUM) * 4;
d668 1
a668 1
    (dr_regnum - gdbarch_tdep (current_gdbarch)->DR0_REGNUM) * 2;
d681 1
a681 1
  int insn;
a683 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d707 1
a707 1
  /* Loop around examining the prologue insns until we find something
d720 1
a720 1
      insn = read_memory_integer (pc, 2);
d722 1
a722 1
      if (IS_PUSH (insn))
d724 1
a724 1
	  rn = GET_PUSHED_REG (insn);
d728 1
a728 1
      else if (IS_STS (insn))
d735 1
a735 1
      else if (IS_MOV_R3 (insn))
d737 1
a737 1
	  r3_val = ((insn & 0xff) ^ 0x80) - 0x80;
d739 1
a739 1
      else if (IS_SHLL_R3 (insn))
d743 1
a743 1
      else if (IS_ADD_R3SP (insn))
d747 1
a747 1
      else if (IS_ADD_SP (insn))
d749 1
a749 1
	  depth -= ((insn & 0xff) ^ 0x80) - 0x80;
d751 1
a751 1
      else if (IS_FMOV (insn))
d753 1
a753 1
	  if (read_register (tdep->FPSCR_REGNUM) & FPSCR_SZ)
d762 1
a762 1
      else if (IS_MOV_SP_FP (insn))
a842 1
  /*FIXME: Is R0 really correct here?  Not STRUCT_RETURN_REGNUM? */
a958 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
a1068 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
a1237 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

a1271 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

d1283 2
a1284 2
	           (long) read_register (tdep->SSR_REGNUM),
		   (long) read_register (tdep->SPC_REGNUM));
d1321 2
a1322 2
	  	   (long) read_register (gdbarch_tdep (current_gdbarch)->FPUL_REGNUM),
                   (long) read_register (gdbarch_tdep (current_gdbarch)->FPSCR_REGNUM));
a1365 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

d1377 2
a1378 2
		   (long) read_register (tdep->SSR_REGNUM),
		   (long) read_register (tdep->SPC_REGNUM));
d1380 2
a1381 2
		   (long) read_register (tdep->FPUL_REGNUM),
		   (long) read_register (tdep->FPSCR_REGNUM));
a1424 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

d1437 2
a1438 2
		   (long) read_register (tdep->SSR_REGNUM),
		   (long) read_register (tdep->SPC_REGNUM));
d1441 1
a1441 1
		   (long) read_register (tdep->DSR_REGNUM));
d1463 7
a1469 7
		   (long) read_register (tdep->A0G_REGNUM) & 0xff,
		   (long) read_register (tdep->A0_REGNUM),
		   (long) read_register (tdep->M0_REGNUM),
		   (long) read_register (tdep->X0_REGNUM),
		   (long) read_register (tdep->Y0_REGNUM),
		   (long) read_register (tdep->RS_REGNUM),
		   (long) read_register (tdep->MOD_REGNUM));
d1471 6
a1476 6
		   (long) read_register (tdep->A1G_REGNUM) & 0xff,
		   (long) read_register (tdep->A1_REGNUM),
		   (long) read_register (tdep->M1_REGNUM),
		   (long) read_register (tdep->X1_REGNUM),
		   (long) read_register (tdep->Y1_REGNUM),
		   (long) read_register (tdep->RE_REGNUM));
d1482 1
a1482 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  int pr = read_register (tdep->FPSCR_REGNUM) & 0x80000;
d1494 2
a1495 2
		   (long) read_register (tdep->SSR_REGNUM),
		   (long) read_register (tdep->SPC_REGNUM));
d1497 2
a1498 2
		   (long) read_register (tdep->FPUL_REGNUM),
		   (long) read_register (tdep->FPSCR_REGNUM));
a1545 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

d1558 1
a1558 1
		   (long) read_register (tdep->DSR_REGNUM));
d1580 7
a1586 7
		   (long) read_register (tdep->A0G_REGNUM) & 0xff,
		   (long) read_register (tdep->A0_REGNUM),
		   (long) read_register (tdep->M0_REGNUM),
		   (long) read_register (tdep->X0_REGNUM),
		   (long) read_register (tdep->Y0_REGNUM),
		   (long) read_register (tdep->RS_REGNUM),
		   (long) read_register (tdep->MOD_REGNUM));
d1588 6
a1593 6
		   (long) read_register (tdep->A1G_REGNUM) & 0xff,
		   (long) read_register (tdep->A1_REGNUM),
		   (long) read_register (tdep->M1_REGNUM),
		   (long) read_register (tdep->X1_REGNUM),
		   (long) read_register (tdep->Y1_REGNUM),
		   (long) read_register (tdep->RE_REGNUM));
a1607 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

d1609 2
a1610 2
       && (reg_nr <= tdep->FP_LAST_REGNUM)) 
      || (reg_nr == tdep->FPUL_REGNUM))
a1627 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 

d1629 2
a1630 2
       && (reg_nr <= tdep->FP_LAST_REGNUM)) 
      || (reg_nr == tdep->FPUL_REGNUM))
d1632 2
a1633 2
  else if (reg_nr >= tdep->DR0_REGNUM 
	   && reg_nr <= tdep->DR_LAST_REGNUM)
d1635 2
a1636 2
  else if  (reg_nr >= tdep->FV0_REGNUM 
	   && reg_nr <= tdep->FV_LAST_REGNUM)
d1678 2
a1679 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (regnum >= tdep->DR0_REGNUM 
      && regnum <= tdep->DR_LAST_REGNUM)
d1693 2
a1694 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (regnum >= tdep->DR0_REGNUM 
      && regnum <= tdep->DR_LAST_REGNUM)
a1708 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d1710 2
a1711 2
  if (reg_nr >= tdep->DR0_REGNUM 
      && reg_nr <= tdep->DR_LAST_REGNUM)
d1726 2
a1727 2
  else if (reg_nr >= tdep->FV0_REGNUM 
	   && reg_nr <= tdep->FV_LAST_REGNUM)
a1744 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d1746 2
a1747 2
  if (reg_nr >= tdep->DR0_REGNUM
      && reg_nr <= tdep->DR_LAST_REGNUM)
d1761 2
a1762 2
  else if (reg_nr >= tdep->FV0_REGNUM
	   && reg_nr <= tdep->FV_LAST_REGNUM)
d1781 1
a1781 1
		     fv_regnum - gdbarch_tdep (gdbarch)->FV0_REGNUM, 
d1796 1
a1796 1
		    dr_regnum - gdbarch_tdep (gdbarch)->DR0_REGNUM, 
a1804 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 

d1808 2
a1809 2
  else if (regnum >= tdep->DR0_REGNUM
	   && regnum <= tdep->DR_LAST_REGNUM)
d1811 2
a1812 2
  else if (regnum >= tdep->FV0_REGNUM
	   && regnum <= tdep->FV_LAST_REGNUM)
d1932 1
a1932 1
		regnum += (gdbarch_tdep (gdbarch)->FP_LAST_REGNUM - FP0_REGNUM);	/* skip FP regs */
a1993 24

enum
{
   DSP_DSR_REGNUM = 24,
   DSP_A0G_REGNUM,
   DSP_A0_REGNUM,
   DSP_A1G_REGNUM,
   DSP_A1_REGNUM,
   DSP_M0_REGNUM,
   DSP_M1_REGNUM,
   DSP_X0_REGNUM,
   DSP_X1_REGNUM,
   DSP_Y0_REGNUM,
   DSP_Y1_REGNUM,
 
   DSP_MOD_REGNUM = 40,
 
   DSP_RS_REGNUM = 43,
   DSP_RE_REGNUM,
 
   DSP_R0_BANK_REGNUM = 51,
   DSP_R7_BANK_REGNUM = DSP_R0_BANK_REGNUM + 7
};

d1999 3
a2001 3
  if (nr >= DSP_DSR_REGNUM && nr <= DSP_Y1_REGNUM)
    return nr - DSP_DSR_REGNUM + SIM_SH_DSR_REGNUM;
  if (nr == DSP_MOD_REGNUM)
d2003 1
a2003 1
  if (nr == DSP_RS_REGNUM)
d2005 1
a2005 1
  if (nr == DSP_RE_REGNUM)
d2007 2
a2008 2
  if (nr >= DSP_R0_BANK_REGNUM && nr <= DSP_R7_BANK_REGNUM)
    return nr - DSP_R0_BANK_REGNUM + SIM_SH_R0_BANK_REGNUM;
a2017 1
  struct gdbarch_tdep *tdep;
d2058 1
a2058 2
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);
a2063 27
  /* Initialize the register numbers that are not common to all the
     variants to -1, if necessary thse will be overwritten in the case
     statement below. */
  tdep->FPUL_REGNUM = -1;
  tdep->FPSCR_REGNUM = -1;
  tdep->DSR_REGNUM = -1;
  tdep->FP_LAST_REGNUM = -1;
  tdep->A0G_REGNUM = -1;
  tdep->A0_REGNUM = -1;
  tdep->A1G_REGNUM = -1;
  tdep->A1_REGNUM = -1;
  tdep->M0_REGNUM = -1;
  tdep->M1_REGNUM = -1;
  tdep->X0_REGNUM = -1;
  tdep->X1_REGNUM = -1;
  tdep->Y0_REGNUM = -1;
  tdep->Y1_REGNUM = -1;
  tdep->MOD_REGNUM = -1;
  tdep->RS_REGNUM = -1;
  tdep->RE_REGNUM = -1;
  tdep->SSR_REGNUM = -1;
  tdep->SPC_REGNUM = -1;
  tdep->DR0_REGNUM = -1;
  tdep->DR_LAST_REGNUM = -1;
  tdep->FV0_REGNUM = -1;
  tdep->FV_LAST_REGNUM = -1;

d2073 1
a2073 1
  set_gdbarch_num_regs (gdbarch, SH_DEFAULT_NUM_REGS);
a2143 3
      tdep->FPUL_REGNUM = 23;
      tdep->FPSCR_REGNUM = 24;
      tdep->FP_LAST_REGNUM = 40;
a2156 14
      tdep->DSR_REGNUM = 24;
      tdep->A0G_REGNUM = 25;
      tdep->A0_REGNUM = 26;
      tdep->A1G_REGNUM = 27;
      tdep->A1_REGNUM = 28;
      tdep->M0_REGNUM = 29;
      tdep->M1_REGNUM = 30;
      tdep->X0_REGNUM = 31;
      tdep->X1_REGNUM = 32;
      tdep->Y0_REGNUM = 33;
      tdep->Y1_REGNUM = 34;
      tdep->MOD_REGNUM = 40;
      tdep->RS_REGNUM = 43;
      tdep->RE_REGNUM = 44;
a2168 2
      tdep->SSR_REGNUM = 41;
      tdep->SPC_REGNUM = 42;
a2184 5
      tdep->FPUL_REGNUM = 23;
      tdep->FPSCR_REGNUM = 24;
      tdep->FP_LAST_REGNUM = 40;
      tdep->SSR_REGNUM = 41;
      tdep->SPC_REGNUM = 42;
a2197 16
      tdep->DSR_REGNUM = 24;
      tdep->A0G_REGNUM = 25;
      tdep->A0_REGNUM = 26;
      tdep->A1G_REGNUM = 27;
      tdep->A1_REGNUM = 28;
      tdep->M0_REGNUM = 29;
      tdep->M1_REGNUM = 30;
      tdep->X0_REGNUM = 31;
      tdep->X1_REGNUM = 32;
      tdep->Y0_REGNUM = 33;
      tdep->Y1_REGNUM = 34;
      tdep->MOD_REGNUM = 40;
      tdep->RS_REGNUM = 43;
      tdep->RE_REGNUM = 44;
      tdep->SSR_REGNUM = 41;
      tdep->SPC_REGNUM = 42;
a2213 9
      tdep->FPUL_REGNUM = 23;
      tdep->FPSCR_REGNUM = 24;
      tdep->FP_LAST_REGNUM = 40;
      tdep->SSR_REGNUM = 41;
      tdep->SPC_REGNUM = 42;
      tdep->DR0_REGNUM = 59;
      tdep->DR_LAST_REGNUM = 66;
      tdep->FV0_REGNUM = 67;
      tdep->FV_LAST_REGNUM = 70;
a2234 11
static void
sh_dump_tdep (struct gdbarch *current_gdbarch, struct ui_file *file)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (tdep == NULL)
    return;

  /* FIXME: dump the rest of gdbarch_tdep.  */
}

d2242 1
a2242 1
  gdbarch_register (bfd_arch_sh, sh_gdbarch_init, sh_dump_tdep);
@


1.138
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d861 3
a863 3
  register struct frame_info *frame = get_current_frame ();
  register CORE_ADDR fp;
  register int regnum;
@


1.137
log
@	* Makefile.in (ALLDEPFILES): Add sh64-tdep.c.
	(sh64-tdep.o): Add dependencies.
	* configure.tgt: Add FIXME to sh-*-linux*.
	* sh-tdep.c: Move sh64 support to sh64-tdep.c.
	(sh_gdbarch_init): Always set correct sh_show_regs function
	pointer.  Call sh64_gdbarch_init() if machine type is sh5.
	* sh-tdep.h: Move sh64 support to sh64-tdep.c.
	* sh64-tdep.c: New file, containing all sh64 related code from
	sh-tdep.c.
	* config/sh/embed.mt (TDEPFILES): Add sh64-tdep.o.
	* config/sh/linux.mt (TDEPFILES): Ditto.
	* config/sh/nbsd.mt (TDEPFILES): Ditto.
	* config/sh/tm-sh.h: Drop REGISTER_TYPE definition.
	* config/sh/wince.mt (TDEPFILES): Ditto.
@
text
@d490 2
a491 1
  if (get_frame_pc (frame) && !inside_entry_file (get_frame_pc (frame)))
@


1.136
log
@2003-08-20  Michael Snyder  <msnyder@@redhat.com>

        * sh-tdep.h (struct gdbarch_tdep): New member FLOAT_ARGLAST_REG.
        * sh-tdep.c (sh_gdbarch_init): For sh2e, sh3e, and sh4, set
        FLOAT_ARG0_REGNUM and FLOAT_ARGLAST_REGNUM, to be used for
        argument passing.
        (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu): New
        functions, replace sh_push_dummy_call.
        (sh_gdbarch_init): Set push_dummy_call to one of new methods.
@
text
@d49 1
a49 1
/* sh64 flags */
d54 1
a54 2
void (*sh_show_regs) (void);
CORE_ADDR (*skip_prologue_hard_way) (CORE_ADDR);
a258 74
static const char *
sh_sh64_register_name (int reg_nr)
{
  static char *register_names[] =
  {
    /* SH MEDIA MODE (ISA 32) */
    /* general registers (64-bit) 0-63 */
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
    "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",
    "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",
    "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",
    "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",
    "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",

    /* pc (64-bit) 64 */
    "pc",   

    /* status reg., saved status reg., saved pc reg. (64-bit) 65-67 */
    "sr",  "ssr",  "spc", 

    /* target registers (64-bit) 68-75*/
    "tr0",  "tr1",  "tr2",  "tr3",  "tr4",  "tr5",  "tr6",  "tr7",

    /* floating point state control register (32-bit) 76 */
    "fpscr",

    /* single precision floating point registers (32-bit) 77-140*/
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "fr16", "fr17", "fr18", "fr19", "fr20", "fr21", "fr22", "fr23",
    "fr24", "fr25", "fr26", "fr27", "fr28", "fr29", "fr30", "fr31",
    "fr32", "fr33", "fr34", "fr35", "fr36", "fr37", "fr38", "fr39",
    "fr40", "fr41", "fr42", "fr43", "fr44", "fr45", "fr46", "fr47",
    "fr48", "fr49", "fr50", "fr51", "fr52", "fr53", "fr54", "fr55",
    "fr56", "fr57", "fr58", "fr59", "fr60", "fr61", "fr62", "fr63",

    /* double precision registers (pseudo) 141-172 */
    "dr0",  "dr2",  "dr4",  "dr6",  "dr8",  "dr10", "dr12", "dr14",
    "dr16", "dr18", "dr20", "dr22", "dr24", "dr26", "dr28", "dr30",
    "dr32", "dr34", "dr36", "dr38", "dr40", "dr42", "dr44", "dr46",
    "dr48", "dr50", "dr52", "dr54", "dr56", "dr58", "dr60", "dr62",

    /* floating point pairs (pseudo) 173-204*/
    "fp0",  "fp2",  "fp4",  "fp6",  "fp8",  "fp10", "fp12", "fp14",
    "fp16", "fp18", "fp20", "fp22", "fp24", "fp26", "fp28", "fp30",
    "fp32", "fp34", "fp36", "fp38", "fp40", "fp42", "fp44", "fp46",
    "fp48", "fp50", "fp52", "fp54", "fp56", "fp58", "fp60", "fp62",

    /* floating point vectors (4 floating point regs) (pseudo) 205-220*/
    "fv0",  "fv4",  "fv8",  "fv12", "fv16", "fv20", "fv24", "fv28",
    "fv32", "fv36", "fv40", "fv44", "fv48", "fv52", "fv56", "fv60",

    /* SH COMPACT MODE (ISA 16) (all pseudo) 221-272*/
    "r0_c", "r1_c", "r2_c",  "r3_c",  "r4_c",  "r5_c",  "r6_c",  "r7_c",
    "r8_c", "r9_c", "r10_c", "r11_c", "r12_c", "r13_c", "r14_c", "r15_c",
    "pc_c",
    "gbr_c", "mach_c", "macl_c", "pr_c", "t_c",
    "fpscr_c", "fpul_c",
    "fr0_c", "fr1_c", "fr2_c",  "fr3_c",  "fr4_c",  "fr5_c",  "fr6_c",  "fr7_c",
    "fr8_c", "fr9_c", "fr10_c", "fr11_c", "fr12_c", "fr13_c", "fr14_c", "fr15_c",
    "dr0_c", "dr2_c", "dr4_c",  "dr6_c",  "dr8_c",  "dr10_c", "dr12_c", "dr14_c",
    "fv0_c", "fv4_c", "fv8_c",  "fv12_c",
    /* FIXME!!!! XF0 XF15, XD0 XD14 ?????*/
  };

  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

a287 103
/* Macros and functions for setting and testing a bit in a minimal
   symbol that marks it as 32-bit function.  The MSB of the minimal
   symbol's "info" field is used for this purpose. This field is
   already being used to store the symbol size, so the assumption is
   that the symbol size cannot exceed 2^31.

   ELF_MAKE_MSYMBOL_SPECIAL
   tests whether an ELF symbol is "special", i.e. refers
   to a 32-bit function, and sets a "special" bit in a 
   minimal symbol to mark it as a 32-bit function
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol
   MSYMBOL_SIZE         returns the size of the minimal symbol, i.e.
   the "info" field with the "special" bit masked out */

#define MSYMBOL_IS_SPECIAL(msym) \
  (((long) MSYMBOL_INFO (msym) & 0x80000000) != 0)

static void
sh64_elf_make_msymbol_special (asymbol *sym, struct minimal_symbol *msym)
{
  if (msym == NULL)
    return;

  if (((elf_symbol_type *)(sym))->internal_elf_sym.st_other == STO_SH5_ISA32)
    {
      MSYMBOL_INFO (msym) = (char *) (((long) MSYMBOL_INFO (msym)) | 0x80000000);
      SYMBOL_VALUE_ADDRESS (msym) |= 1;
    }
}

/* ISA32 (shmedia) function addresses are odd (bit 0 is set).  Here
   are some macros to test, set, or clear bit 0 of addresses.  */
#define IS_ISA32_ADDR(addr)	 ((addr) & 1)
#define MAKE_ISA32_ADDR(addr)	 ((addr) | 1)
#define UNMAKE_ISA32_ADDR(addr)  ((addr) & ~1)

static int
pc_is_isa32 (bfd_vma memaddr)
{
  struct minimal_symbol *sym;

  /* If bit 0 of the address is set, assume this is a
     ISA32 (shmedia) address. */
  if (IS_ISA32_ADDR (memaddr))
    return 1;

  /* A flag indicating that this is a ISA32 function is stored by elfread.c in
     the high bit of the info field.  Use this to decide if the function is
     ISA16 or ISA32.  */
  sym = lookup_minimal_symbol_by_pc (memaddr);
  if (sym)
    return MSYMBOL_IS_SPECIAL (sym);
  else
    return 0;
}

static const unsigned char *
sh_sh64_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
{
  /* The BRK instruction for shmedia is 
     01101111 11110101 11111111 11110000
     which translates in big endian mode to 0x6f, 0xf5, 0xff, 0xf0
     and in little endian mode to 0xf0, 0xff, 0xf5, 0x6f */

  /* The BRK instruction for shcompact is
     00000000 00111011
     which translates in big endian mode to 0x0, 0x3b
     and in little endian mode to 0x3b, 0x0*/

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    {
      if (pc_is_isa32 (*pcptr))
	{
	  static unsigned char big_breakpoint_media[] = {0x6f, 0xf5, 0xff, 0xf0};
	  *pcptr = UNMAKE_ISA32_ADDR (*pcptr);
	  *lenptr = sizeof (big_breakpoint_media);
	  return big_breakpoint_media;
	}
      else
	{
	  static unsigned char big_breakpoint_compact[] = {0x0, 0x3b};
	  *lenptr = sizeof (big_breakpoint_compact);
	  return big_breakpoint_compact;
	}
    }
  else
    {
      if (pc_is_isa32 (*pcptr))
	{
	  static unsigned char little_breakpoint_media[] = {0xf0, 0xff, 0xf5, 0x6f};
	  *pcptr = UNMAKE_ISA32_ADDR (*pcptr);
	  *lenptr = sizeof (little_breakpoint_media);
	  return little_breakpoint_media;
	}
      else
	{
	  static unsigned char little_breakpoint_compact[] = {0x3b, 0x0};
	  *lenptr = sizeof (little_breakpoint_compact);
	  return little_breakpoint_compact;
	}
    }
}

a311 117
/* PTABS/L Rn, TRa       0110101111110001nnnnnnl00aaa0000 
   with l=1 and n = 18   0110101111110001010010100aaa0000 */
#define IS_PTABSL_R18(x)  (((x) & 0xffffff8f) == 0x6bf14a00)

/* STS.L PR,@@-r0   0100000000100010
   r0-4-->r0, PR-->(r0) */
#define IS_STS_R0(x)  		((x) == 0x4022)

/* STS PR, Rm      0000mmmm00101010
   PR-->Rm */
#define IS_STS_PR(x)            (((x) & 0xf0ff) == 0x2a)

/* MOV.L Rm,@@(disp,r15)  00011111mmmmdddd
   Rm-->(dispx4+r15) */
#define IS_MOV_TO_R15(x)              (((x) & 0xff00) == 0x1f00)

/* MOV.L R14,@@(disp,r15)  000111111110dddd
   R14-->(dispx4+r15) */
#define IS_MOV_R14(x)              (((x) & 0xfff0) == 0x1fe0)

/* ST.Q R14, disp, R18    101011001110dddddddddd0100100000
   R18-->(dispx8+R14) */
#define IS_STQ_R18_R14(x)          (((x) & 0xfff003ff) == 0xace00120)

/* ST.Q R15, disp, R18    101011001111dddddddddd0100100000
   R18-->(dispx8+R15) */
#define IS_STQ_R18_R15(x)          (((x) & 0xfff003ff) == 0xacf00120)

/* ST.L R15, disp, R18    101010001111dddddddddd0100100000
   R18-->(dispx4+R15) */
#define IS_STL_R18_R15(x)          (((x) & 0xfff003ff) == 0xa8f00120)

/* ST.Q R15, disp, R14    1010 1100 1111 dddd dddd dd00 1110 0000
   R14-->(dispx8+R15) */
#define IS_STQ_R14_R15(x)          (((x) & 0xfff003ff) == 0xacf000e0)

/* ST.L R15, disp, R14    1010 1000 1111 dddd dddd dd00 1110 0000
   R14-->(dispx4+R15) */
#define IS_STL_R14_R15(x)          (((x) & 0xfff003ff) == 0xa8f000e0)

/* ADDI.L R15,imm,R15     1101 0100 1111 ssss ssss ss00 1111 0000
   R15 + imm --> R15 */
#define IS_ADDIL_SP_MEDIA(x)         (((x) & 0xfff003ff) == 0xd4f000f0)

/* ADDI R15,imm,R15     1101 0000 1111 ssss ssss ss00 1111 0000
   R15 + imm --> R15 */
#define IS_ADDI_SP_MEDIA(x)         (((x) & 0xfff003ff) == 0xd0f000f0)

/* ADD.L R15,R63,R14    0000 0000 1111 1000 1111 1100 1110 0000 
   R15 + R63 --> R14 */
#define IS_ADDL_SP_FP_MEDIA(x)  	((x) == 0x00f8fce0)

/* ADD R15,R63,R14    0000 0000 1111 1001 1111 1100 1110 0000 
   R15 + R63 --> R14 */
#define IS_ADD_SP_FP_MEDIA(x)  	((x) == 0x00f9fce0)

#define IS_MOV_SP_FP_MEDIA(x)  	(IS_ADDL_SP_FP_MEDIA(x) || IS_ADD_SP_FP_MEDIA(x))

/* MOV #imm, R0    1110 0000 ssss ssss 
   #imm-->R0 */
#define IS_MOV_R0(x) 		(((x) & 0xff00) == 0xe000)

/* MOV.L @@(disp,PC), R0    1101 0000 iiii iiii  */
#define IS_MOVL_R0(x) 		(((x) & 0xff00) == 0xd000)

/* ADD r15,r0      0011 0000 1111 1100
   r15+r0-->r0 */
#define IS_ADD_SP_R0(x)	        ((x) == 0x30fc)

/* MOV.L R14 @@-R0  0010 0000 1110 0110
   R14-->(R0-4), R0-4-->R0 */
#define IS_MOV_R14_R0(x)        ((x) == 0x20e6)

/* ADD Rm,R63,Rn  Rm+R63-->Rn  0000 00mm mmmm 1001 1111 11nn nnnn 0000
   where Rm is one of r2-r9 which are the argument registers. */
/* FIXME: Recognize the float and double register moves too! */
#define IS_MEDIA_IND_ARG_MOV(x) \
((((x) & 0xfc0ffc0f) == 0x0009fc00) && (((x) & 0x03f00000) >= 0x00200000 && ((x) & 0x03f00000) <= 0x00900000))

/* ST.Q Rn,0,Rm  Rm-->Rn+0  1010 11nn nnnn 0000 0000 00mm mmmm 0000
   or ST.L Rn,0,Rm  Rm-->Rn+0  1010 10nn nnnn 0000 0000 00mm mmmm 0000
   where Rm is one of r2-r9 which are the argument registers. */
#define IS_MEDIA_ARG_MOV(x) \
(((((x) & 0xfc0ffc0f) == 0xac000000) || (((x) & 0xfc0ffc0f) == 0xa8000000)) \
   && (((x) & 0x000003f0) >= 0x00000020 && ((x) & 0x000003f0) <= 0x00000090))

/* ST.B R14,0,Rn     Rn-->(R14+0) 1010 0000 1110 0000 0000 00nn nnnn 0000*/
/* ST.W R14,0,Rn     Rn-->(R14+0) 1010 0100 1110 0000 0000 00nn nnnn 0000*/
/* ST.L R14,0,Rn     Rn-->(R14+0) 1010 1000 1110 0000 0000 00nn nnnn 0000*/
/* FST.S R14,0,FRn   Rn-->(R14+0) 1011 0100 1110 0000 0000 00nn nnnn 0000*/
/* FST.D R14,0,DRn   Rn-->(R14+0) 1011 1100 1110 0000 0000 00nn nnnn 0000*/
#define IS_MEDIA_MOV_TO_R14(x)  \
((((x) & 0xfffffc0f) == 0xa0e00000) \
|| (((x) & 0xfffffc0f) == 0xa4e00000) \
|| (((x) & 0xfffffc0f) == 0xa8e00000) \
|| (((x) & 0xfffffc0f) == 0xb4e00000) \
|| (((x) & 0xfffffc0f) == 0xbce00000))

/* MOV Rm, Rn  Rm-->Rn 0110 nnnn mmmm 0011
   where Rm is r2-r9 */
#define IS_COMPACT_IND_ARG_MOV(x) \
((((x) & 0xf00f) == 0x6003) && (((x) & 0x00f0) >= 0x0020) && (((x) & 0x00f0) <= 0x0090))

/* compact direct arg move! 
   MOV.L Rn, @@r14     0010 1110 mmmm 0010 */
#define IS_COMPACT_ARG_MOV(x) \
(((((x) & 0xff0f) == 0x2e02) && (((x) & 0x00f0) >= 0x0020) && ((x) & 0x00f0) <= 0x0090))

/* MOV.B Rm, @@R14     0010 1110 mmmm 0000 
   MOV.W Rm, @@R14     0010 1110 mmmm 0001 */
#define IS_COMPACT_MOV_TO_R14(x) \
((((x) & 0xff0f) == 0x2e00) || (((x) & 0xff0f) == 0x2e01))

#define IS_JSR_R0(x)           ((x) == 0x400b)
#define IS_NOP(x)              ((x) == 0x0009)


a423 172
static CORE_ADDR 
look_for_args_moves (CORE_ADDR start_pc, int media_mode)
{
  CORE_ADDR here, end;
  int w;
  int insn_size = (media_mode ? 4 : 2);

  for (here = start_pc, end = start_pc + (insn_size * 28); here < end;)
    {
      if (media_mode)
	{
	  w = read_memory_integer (UNMAKE_ISA32_ADDR (here), insn_size);
	  here += insn_size;
	  if (IS_MEDIA_IND_ARG_MOV (w))
	    {
	      /* This must be followed by a store to r14, so the argument
		 is where the debug info says it is. This can happen after
		 the SP has been saved, unfortunately. */
	 
	      int next_insn = read_memory_integer (UNMAKE_ISA32_ADDR (here),
						   insn_size);
	      here += insn_size;
	      if (IS_MEDIA_MOV_TO_R14 (next_insn))
		start_pc = here;	  
	    }
	  else if (IS_MEDIA_ARG_MOV (w))
	    {
	      /* These instructions store directly the argument in r14. */
	      start_pc = here;
	    }
	  else
	    break;
	}
      else
	{
	  w = read_memory_integer (here, insn_size);
	  w = w & 0xffff;
	  here += insn_size;
	  if (IS_COMPACT_IND_ARG_MOV (w))
	    {
	      /* This must be followed by a store to r14, so the argument
		 is where the debug info says it is. This can happen after
		 the SP has been saved, unfortunately. */
	 
	      int next_insn = 0xffff & read_memory_integer (here, insn_size);
	      here += insn_size;
	      if (IS_COMPACT_MOV_TO_R14 (next_insn))
		start_pc = here;
	    }
	  else if (IS_COMPACT_ARG_MOV (w))
	    {
	      /* These instructions store directly the argument in r14. */
	      start_pc = here;
	    }
	  else if (IS_MOVL_R0 (w))
	    {
	      /* There is a function that gcc calls to get the arguments
		 passed correctly to the function. Only after this
		 function call the arguments will be found at the place
		 where they are supposed to be. This happens in case the
		 argument has to be stored into a 64-bit register (for
		 instance doubles, long longs).  SHcompact doesn't have
		 access to the full 64-bits, so we store the register in
		 stack slot and store the address of the stack slot in
		 the register, then do a call through a wrapper that
		 loads the memory value into the register.  A SHcompact
		 callee calls an argument decoder
		 (GCC_shcompact_incoming_args) that stores the 64-bit
		 value in a stack slot and stores the address of the
		 stack slot in the register.  GCC thinks the argument is
		 just passed by transparent reference, but this is only
		 true after the argument decoder is called. Such a call
		 needs to be considered part of the prologue. */

	      /* This must be followed by a JSR @@r0 instruction and by
                 a NOP instruction. After these, the prologue is over!  */
	 
	      int next_insn = 0xffff & read_memory_integer (here, insn_size);
	      here += insn_size;
	      if (IS_JSR_R0 (next_insn))
		{
		  next_insn = 0xffff & read_memory_integer (here, insn_size);
		  here += insn_size;

		  if (IS_NOP (next_insn))
		    start_pc = here;
		}
	    }
	  else
	    break;
	}
    }

  return start_pc;
}

static CORE_ADDR
sh64_skip_prologue_hard_way (CORE_ADDR start_pc)
{
  CORE_ADDR here, end;
  int updated_fp = 0;
  int insn_size = 4;
  int media_mode = 1;

  if (!start_pc)
    return 0;

  if (pc_is_isa32 (start_pc) == 0)
    {
      insn_size = 2;
      media_mode = 0;
    }

  for (here = start_pc, end = start_pc + (insn_size * 28); here < end;)
    {

      if (media_mode)
	{
	  int w = read_memory_integer (UNMAKE_ISA32_ADDR (here), insn_size);
	  here += insn_size;
	  if (IS_STQ_R18_R14 (w) || IS_STQ_R18_R15 (w) || IS_STQ_R14_R15 (w)
	      || IS_STL_R14_R15 (w) || IS_STL_R18_R15 (w)
	      || IS_ADDIL_SP_MEDIA (w) || IS_ADDI_SP_MEDIA (w) || IS_PTABSL_R18 (w))
	    {
	      start_pc = here;
	    }
	  else if (IS_MOV_SP_FP (w) || IS_MOV_SP_FP_MEDIA(w))
	    {
	      start_pc = here;
	      updated_fp = 1;
	    }
	  else
	    if (updated_fp)
	      {
		/* Don't bail out yet, we may have arguments stored in
		   registers here, according to the debug info, so that
		   gdb can print the frames correctly. */
		start_pc = look_for_args_moves (here - insn_size, media_mode);
		break;
	      }
	}
      else
	{
	  int w = 0xffff & read_memory_integer (here, insn_size);
	  here += insn_size;

	  if (IS_STS_R0 (w) || IS_STS_PR (w)
	      || IS_MOV_TO_R15 (w) || IS_MOV_R14 (w) 
	      || IS_MOV_R0 (w) || IS_ADD_SP_R0 (w) || IS_MOV_R14_R0 (w))
	    {
	      start_pc = here;
	    }
	  else if (IS_MOV_SP_FP (w))
	    {
	      start_pc = here;
	      updated_fp = 1;
	    }
	  else
	    if (updated_fp)
	      {
		/* Don't bail out yet, we may have arguments stored in
		   registers here, according to the debug info, so that
		   gdb can print the frames correctly. */
		start_pc = look_for_args_moves (here - insn_size, media_mode);
		break;
	      }
	}
    }

  return start_pc;
}

d439 1
a439 1
    return (skip_prologue_hard_way (pc));
d451 1
a451 1
  return (ADDR_BITS_REMOVE (read_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM)));
a467 16
static int
sh64_use_struct_convention (int gcc_p, struct type *type)
{
  return (TYPE_LENGTH (type) > 8);
}

/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function.

   We store structs through a pointer passed in R2 */
static void
sh64_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (STRUCT_RETURN_REGNUM, (addr));
}

a496 50
/* Given a register number RN as it appears in an assembly
   instruction, find the corresponding register number in the GDB
   scheme. */
static int 
translate_insn_rn (int rn, int media_mode)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  /* FIXME: this assumes that the number rn is for a not pseudo
     register only. */
  if (media_mode)
    return rn;
  else
    {
      /* These registers don't have a corresponding compact one. */
      /* FIXME: This is probably not enough. */
#if 0
      if ((rn >= 16 && rn <= 63) || (rn >= 93 && rn <= 140))
	return rn;
#endif
      if (rn >= 0 && rn <= tdep->R0_C_REGNUM)
	return tdep->R0_C_REGNUM + rn;
      else
	return rn;
    }
}

static CORE_ADDR
sh64_frame_chain (struct frame_info *frame)
{
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    return get_frame_base (frame);	/* dummy frame same as caller's frame */
  if (get_frame_pc (frame) && !inside_entry_file (get_frame_pc (frame)))
    {
      int media_mode = pc_is_isa32 (get_frame_pc (frame));
      int size;
      if (gdbarch_tdep (current_gdbarch)->sh_abi == SH_ABI_32)
	size = 4;
      else
	size = REGISTER_RAW_SIZE (translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode));
      return read_memory_integer (get_frame_base (frame)
				  + get_frame_extra_info (frame)->f_offset,
				  size);
    }
  else
    return 0;
}

a523 32
static CORE_ADDR
sh64_get_saved_pr (struct frame_info *fi, int pr_regnum)
{
  int media_mode = 0;

  for (; fi; fi = get_next_frame (fi))
    if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				     get_frame_base (fi)))
      /* When the caller requests PR from the dummy frame, we return PC because
         that's where the previous routine appears to have done a call from. */
      return deprecated_read_register_dummy (get_frame_pc (fi),
					     get_frame_base (fi), pr_regnum);
    else
      {
	DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
	if (!get_frame_pc (fi))
	  return 0;

	media_mode = pc_is_isa32 (get_frame_pc (fi));

	if (get_frame_saved_regs (fi)[pr_regnum] != 0)
	  {
	    int gdb_reg_num = translate_insn_rn (pr_regnum, media_mode);
	    int size = ((gdbarch_tdep (current_gdbarch)->sh_abi == SH_ABI_32)
			? 4
			: REGISTER_RAW_SIZE (gdb_reg_num));
	    return read_memory_integer (get_frame_saved_regs (fi)[pr_regnum], size);
	  }
      }
  return read_register (pr_regnum);
}

d588 1
a588 1
	  where[gdbarch_tdep (current_gdbarch)->PR_REGNUM] = depth;
a671 398
/* For pairs of floating point registers */
static int
fpp_reg_base_num (int fpp_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + 
    (fpp_regnum - gdbarch_tdep (current_gdbarch)->FPP0_REGNUM) * 2;
  return fp_regnum;
}

static int
is_media_pseudo (int rn)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  return (rn >= tdep->DR0_REGNUM 
	  && rn <= tdep->FV_LAST_REGNUM);
}

static int
sh64_get_gdb_regnum (int gcc_regnum, CORE_ADDR pc)
{
  return translate_insn_rn (gcc_regnum, pc_is_isa32 (pc));
}

static int
sh64_media_reg_base_num (int reg_nr)
{
  int base_regnum = -1;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (reg_nr >= tdep->DR0_REGNUM
      && reg_nr <= tdep->DR_LAST_REGNUM)
    base_regnum = dr_reg_base_num (reg_nr);

  else if (reg_nr >= tdep->FPP0_REGNUM 
	   && reg_nr <= tdep->FPP_LAST_REGNUM)
    base_regnum = fpp_reg_base_num (reg_nr);

  else if (reg_nr >= tdep->FV0_REGNUM
	   && reg_nr <= tdep->FV_LAST_REGNUM)
    base_regnum = fv_reg_base_num (reg_nr);

  return base_regnum;
}

/* *INDENT-OFF* */
/*
    SH COMPACT MODE (ISA 16) (all pseudo) 221-272
       GDB_REGNUM  BASE_REGNUM
 r0_c       221      0
 r1_c       222      1
 r2_c       223      2
 r3_c       224      3
 r4_c       225      4
 r5_c       226      5
 r6_c       227      6
 r7_c       228      7
 r8_c       229      8
 r9_c       230      9
 r10_c      231      10
 r11_c      232      11
 r12_c      233      12
 r13_c      234      13
 r14_c      235      14
 r15_c      236      15

 pc_c       237      64
 gbr_c      238      16
 mach_c     239      17
 macl_c     240      17
 pr_c       241      18
 t_c        242      19
 fpscr_c    243      76
 fpul_c     244      109

 fr0_c      245      77
 fr1_c      246      78
 fr2_c      247      79
 fr3_c      248      80
 fr4_c      249      81
 fr5_c      250      82
 fr6_c      251      83
 fr7_c      252      84
 fr8_c      253      85
 fr9_c      254      86
 fr10_c     255      87
 fr11_c     256      88
 fr12_c     257      89
 fr13_c     258      90
 fr14_c     259      91
 fr15_c     260      92

 dr0_c      261      77
 dr2_c      262      79
 dr4_c      263      81
 dr6_c      264      83
 dr8_c      265      85
 dr10_c     266      87
 dr12_c     267      89
 dr14_c     268      91

 fv0_c      269      77
 fv4_c      270      81
 fv8_c      271      85
 fv12_c     272      91
*/
/* *INDENT-ON* */
static int
sh64_compact_reg_base_num (int reg_nr)
{
  int base_regnum = -1;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  /* general register N maps to general register N */
  if (reg_nr >= tdep->R0_C_REGNUM 
      && reg_nr <= tdep->R_LAST_C_REGNUM)
    base_regnum = reg_nr - tdep->R0_C_REGNUM;

  /* floating point register N maps to floating point register N */
  else if (reg_nr >= tdep->FP0_C_REGNUM 
	    && reg_nr <= tdep->FP_LAST_C_REGNUM)
    base_regnum = reg_nr - tdep->FP0_C_REGNUM + FP0_REGNUM;

  /* double prec register N maps to base regnum for double prec register N */
  else if (reg_nr >= tdep->DR0_C_REGNUM 
	    && reg_nr <= tdep->DR_LAST_C_REGNUM)
    base_regnum = dr_reg_base_num (tdep->DR0_REGNUM
				   + reg_nr - tdep->DR0_C_REGNUM);

  /* vector N maps to base regnum for vector register N */
  else if (reg_nr >= tdep->FV0_C_REGNUM 
	    && reg_nr <= tdep->FV_LAST_C_REGNUM)
    base_regnum = fv_reg_base_num (tdep->FV0_REGNUM
				   + reg_nr - tdep->FV0_C_REGNUM);

  else if (reg_nr == tdep->PC_C_REGNUM)
    base_regnum = PC_REGNUM;

  else if (reg_nr == tdep->GBR_C_REGNUM) 
    base_regnum = 16;

  else if (reg_nr == tdep->MACH_C_REGNUM
	   || reg_nr == tdep->MACL_C_REGNUM)
    base_regnum = 17;

  else if (reg_nr == tdep->PR_C_REGNUM) 
    base_regnum = 18;

  else if (reg_nr == tdep->T_C_REGNUM) 
    base_regnum = 19;

  else if (reg_nr == tdep->FPSCR_C_REGNUM) 
    base_regnum = tdep->FPSCR_REGNUM; /*???? this register is a mess. */

  else if (reg_nr == tdep->FPUL_C_REGNUM) 
    base_regnum = FP0_REGNUM + 32;
  
  return base_regnum;
}

/* Given a register number RN (according to the gdb scheme) , return
   its corresponding architectural register.  In media mode, only a
   subset of the registers is pseudo registers. For compact mode, all
   the registers are pseudo. */
static int 
translate_rn_to_arch_reg_num (int rn, int media_mode)
{

  if (media_mode)
    {
      if (!is_media_pseudo (rn))
	return rn;
      else
	return sh64_media_reg_base_num (rn);
    }
  else
    /* All compact registers are pseudo. */
    return sh64_compact_reg_base_num (rn);
}

static int
sign_extend (int value, int bits)
{
  value = value & ((1 << bits) - 1);
  return (value & (1 << (bits - 1))
	  ? value | (~((1 << bits) - 1))
	  : value);
}

static void
sh64_nofp_frame_init_saved_regs (struct frame_info *fi)
{
  int *where = (int *) alloca ((NUM_REGS + NUM_PSEUDO_REGS) * sizeof (int));
  int rn;
  int have_fp = 0;
  int fp_regnum;
  int sp_regnum;
  int depth;
  int pc;
  int opc;
  int insn;
  int r0_val = 0;
  int media_mode = 0;
  int insn_size;
  int gdb_register_number;
  int register_number;
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), get_frame_base (fi));
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
  
  if (get_frame_saved_regs (fi) == NULL)
    frame_saved_regs_zalloc (fi);
  else
    memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
  
  if (dummy_regs)
    {
      /* DANGER!  This is ONLY going to work if the char buffer format of
         the saved registers is byte-for-byte identical to the 
         CORE_ADDR regs[NUM_REGS] format used by struct frame_saved_regs! */
      memcpy (get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
      return;
    }

  get_frame_extra_info (fi)->leaf_function = 1;
  get_frame_extra_info (fi)->f_offset = 0;

  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    where[rn] = -1;

  depth = 0;

  /* Loop around examining the prologue insns until we find something
     that does not appear to be part of the prologue.  But give up
     after 20 of them, since we're getting silly then. */

  pc = get_frame_func (fi);
  if (!pc)
    {
      deprecated_update_frame_pc_hack (fi, 0);
      return;
    }

  if (pc_is_isa32 (pc))
    {
      media_mode = 1;
      insn_size = 4;
    }
  else
    {
      media_mode = 0;
      insn_size = 2;
    }

 /* The frame pointer register is general register 14 in shmedia and
    shcompact modes. In sh compact it is a pseudo register.  Same goes
    for the stack pointer register, which is register 15. */
  fp_regnum = translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode);
  sp_regnum = translate_insn_rn (SP_REGNUM, media_mode);

  for (opc = pc + (insn_size * 28); pc < opc; pc += insn_size)
    {
      insn = read_memory_integer (media_mode ? UNMAKE_ISA32_ADDR (pc) : pc,
				  insn_size);

      if (media_mode == 0)
	{
	  if (IS_STS_PR (insn))
	    {
	      int next_insn = read_memory_integer (pc + insn_size, insn_size);
	      if (IS_MOV_TO_R15 (next_insn))
		{
		  int reg_nr = tdep->PR_C_REGNUM;

		  where[reg_nr] = depth - ((((next_insn & 0xf) ^ 0x8) - 0x8) << 2);
		  get_frame_extra_info (fi)->leaf_function = 0;
		  pc += insn_size;
		}
	    }
	  else if (IS_MOV_R14 (insn))
	    {
	      where[fp_regnum] = depth - ((((insn & 0xf) ^ 0x8) - 0x8) << 2);
	    }

	  else if (IS_MOV_R0 (insn))
	    {
	      /* Put in R0 the offset from SP at which to store some
		 registers. We are interested in this value, because it
		 will tell us where the given registers are stored within
		 the frame.  */
	      r0_val = ((insn & 0xff) ^ 0x80) - 0x80;
	    }
	  else if (IS_ADD_SP_R0 (insn))
	    {
	      /* This instruction still prepares r0, but we don't care.
		 We already have the offset in r0_val. */
	    }
	  else if (IS_STS_R0 (insn))
	    {
	      /* Store PR at r0_val-4 from SP. Decrement r0 by 4*/
	      int reg_nr = tdep->PR_C_REGNUM;
	      where[reg_nr] = depth - (r0_val - 4);
	      r0_val -= 4;
	      get_frame_extra_info (fi)->leaf_function = 0;
	    }
	  else if (IS_MOV_R14_R0 (insn))
	    {
	      /* Store R14 at r0_val-4 from SP. Decrement r0 by 4 */
	      where[fp_regnum] = depth - (r0_val - 4);
	      r0_val -= 4;
	    }

	  else if (IS_ADD_SP (insn))
	    {
	      depth -= ((insn & 0xff) ^ 0x80) - 0x80;
	    }
	  else if (IS_MOV_SP_FP (insn))
	    break;
	}
      else
	{
	  if (IS_ADDIL_SP_MEDIA (insn) 
	      || IS_ADDI_SP_MEDIA (insn))
	    {
	      depth -= sign_extend ((((insn & 0xffc00) ^ 0x80000) - 0x80000) >> 10, 9);
	    }

	  else if (IS_STQ_R18_R15 (insn))
	    {
	      where[tdep->PR_REGNUM] = 
		depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 3);
	      get_frame_extra_info (fi)->leaf_function = 0;
	    }

	  else if (IS_STL_R18_R15 (insn))
	    {
	      where[tdep->PR_REGNUM] = 
		depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 2);
	      get_frame_extra_info (fi)->leaf_function = 0;
	    }

	  else if (IS_STQ_R14_R15 (insn))
	    {
	      where[fp_regnum] = depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 3);
	    }

	  else if (IS_STL_R14_R15 (insn))
	    {
	      where[fp_regnum] = depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 2);
	    }

	  else if (IS_MOV_SP_FP_MEDIA (insn))
	    break;
	}
    }

  /* Now we know how deep things are, we can work out their addresses. */
  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    {
      register_number = translate_rn_to_arch_reg_num (rn, media_mode);

      if (where[rn] >= 0)
	{
	  if (rn == fp_regnum)
	    have_fp = 1;

	  /* Watch out! saved_regs is only for the real registers, and
	     doesn't include space for the pseudo registers. */
	  get_frame_saved_regs (fi)[register_number]= get_frame_base (fi) - where[rn] + depth; 
	    
	} 
      else 
	get_frame_saved_regs (fi)[register_number] = 0; 
    }

  if (have_fp)
    {
      /* SP_REGNUM is 15. For shmedia 15 is the real register. For
	 shcompact 15 is the arch register corresponding to the pseudo
	 register r15 which still is the SP register. */
      /* The place on the stack where fp is stored contains the sp of
         the caller. */
      /* Again, saved_registers contains only space for the real
	 registers, so we store in DEPRECATED_FP_REGNUM position.  */
      int size;
      if (tdep->sh_abi == SH_ABI_32)
	size = 4;
      else
	size = REGISTER_RAW_SIZE (fp_regnum);
      get_frame_saved_regs (fi)[sp_regnum] = read_memory_integer (get_frame_saved_regs (fi)[fp_regnum], size);
    }
  else
    get_frame_saved_regs (fi)[sp_regnum] = get_frame_base (fi);

  get_frame_extra_info (fi)->f_offset = depth - where[fp_regnum]; 
}

d731 1
a731 1
	  where[tdep->PR_REGNUM] = depth;
d831 3
a833 126
      DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
      get_frame_extra_info (fi)->return_pc = 
	sh_find_callers_reg (fi, gdbarch_tdep (current_gdbarch)->PR_REGNUM);
    }
}

static void
sh64_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  int media_mode = pc_is_isa32 (get_frame_pc (fi));

  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));

  if (get_next_frame (fi)) 
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				   get_frame_base (fi)))
    {
      /* We need to setup fi->frame here because call_function_by_hand
         gets it wrong by assuming it's always FP.  */
      deprecated_update_frame_base_hack (fi, deprecated_read_register_dummy (get_frame_pc (fi), get_frame_base (fi), SP_REGNUM));
      get_frame_extra_info (fi)->return_pc = 
	deprecated_read_register_dummy (get_frame_pc (fi),
					get_frame_base (fi), PC_REGNUM);
      get_frame_extra_info (fi)->f_offset = -(DEPRECATED_CALL_DUMMY_LENGTH + 4);
      get_frame_extra_info (fi)->leaf_function = 0;
      return;
    }
  else
    {
      DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
      get_frame_extra_info (fi)->return_pc =
	sh64_get_saved_pr (fi, gdbarch_tdep (current_gdbarch)->PR_REGNUM);
    }
}

static void
sh64_get_saved_register (char *raw_buffer, int *optimized, CORE_ADDR *addrp,
			 struct frame_info *frame, int regnum,
			 enum lval_type *lval)
{
  int media_mode;
  int live_regnum = regnum;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;

  if (addrp)			/* default assumption: not found in memory */
    *addrp = 0;

  if (raw_buffer)
    memset (raw_buffer, 0, sizeof (raw_buffer));

  /* We must do this here, before the following while loop changes
     frame, and makes it NULL. If this is a media register number,
     but we are in compact mode, it will become the corresponding 
     compact pseudo register. If there is no corresponding compact 
     pseudo-register what do we do?*/
  media_mode = pc_is_isa32 (get_frame_pc (frame));
  live_regnum = translate_insn_rn (regnum, media_mode);

  /* Note: since the current frame's registers could only have been
     saved by frames INTERIOR TO the current frame, we skip examining
     the current frame itself: otherwise, we would be getting the
     previous frame's registers which were saved by the current frame.  */

  while (frame && ((frame = get_next_frame (frame)) != NULL))
    {
      if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				       get_frame_base (frame),
				       get_frame_base (frame)))
	{
	  if (lval)		/* found it in a CALL_DUMMY frame */
	    *lval = not_lval;
	  if (raw_buffer)
	    memcpy (raw_buffer,
		    (deprecated_generic_find_dummy_frame (get_frame_pc (frame), get_frame_base (frame))
		     + REGISTER_BYTE (regnum)),
		    REGISTER_RAW_SIZE (regnum));
	  return;
	}

      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
      if (get_frame_saved_regs (frame) != NULL
	  && get_frame_saved_regs (frame)[regnum] != 0)
	{
	  if (lval)		/* found it saved on the stack */
	    *lval = lval_memory;
	  if (regnum == SP_REGNUM)
	    {
	      if (raw_buffer)	/* SP register treated specially */
		store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
					get_frame_saved_regs (frame)[regnum]);
	    }
	  else
	    { /* any other register */
	      
	      if (addrp)
		*addrp = get_frame_saved_regs (frame)[regnum];
	      if (raw_buffer)
		{
		  int size;
		  if (tdep->sh_abi == SH_ABI_32
		      && (live_regnum == DEPRECATED_FP_REGNUM
			  || live_regnum == tdep->PR_REGNUM))
		    size = 4;
		  else
		    size = REGISTER_RAW_SIZE (live_regnum);
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
		    read_memory (get_frame_saved_regs (frame)[regnum], raw_buffer, size);
		  else
		    read_memory (get_frame_saved_regs (frame)[regnum],
				 raw_buffer
				 + REGISTER_RAW_SIZE (live_regnum)
				 - size,
				 size);
		}
	    }
	  return;
	}
a834 10

  /* If we get thru the loop to this point, it means the register was
     not saved in any frame.  Return the actual live-register value.  */

  if (lval)			/* found it in a live register */
    *lval = lval_register;
  if (addrp)
    *addrp = REGISTER_BYTE (live_regnum);
  if (raw_buffer)
    deprecated_read_register_gen (live_regnum, raw_buffer);
a849 7
sh64_extract_struct_value_address (char *regbuf)
{
  return (extract_unsigned_integer ((regbuf + REGISTER_BYTE (STRUCT_RETURN_REGNUM)), 
				    REGISTER_RAW_SIZE (STRUCT_RETURN_REGNUM)));
}

static CORE_ADDR
a884 43
/* Used in the 'return' command. */
static void
sh64_pop_frame (void)
{
  register struct frame_info *frame = get_current_frame ();
  register CORE_ADDR fp;
  register int regnum;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  int media_mode = pc_is_isa32 (get_frame_pc (frame));

  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    generic_pop_dummy_frame ();
  else
    {
      fp = get_frame_base (frame);
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);

      /* Copy regs from where they were saved in the frame */
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
	if (get_frame_saved_regs (frame)[regnum])
	  {
	    int size;
	    if (tdep->sh_abi == SH_ABI_32
		&& (regnum == DEPRECATED_FP_REGNUM
		    || regnum ==  tdep->PR_REGNUM))
	      size = 4;
	    else
	      size = REGISTER_RAW_SIZE (translate_insn_rn (regnum,
							   media_mode));
	    write_register (regnum,
			    read_memory_integer (get_frame_saved_regs (frame)[regnum],
						 size));
	  }

      write_register (PC_REGNUM, get_frame_extra_info (frame)->return_pc);
      write_register (SP_REGNUM, fp + 8);
    }
  flush_cached_frames ();
}

d891 1
a891 1
/* Function: sh_push_dummy_call (formerly push_arguments)
d917 1
a917 1
   have an FPU, however those that have an FPU appear to copy the 
d982 2
a983 2
  argreg = tdep->ARG0_REGNUM;
  flt_argreg = tdep->FLOAT_ARG0_REGNUM;
d1011 2
a1012 2
	       && flt_argreg > tdep->FLOAT_ARGLAST_REGNUM) 
	      || argreg > tdep->ARGLAST_REGNUM
d1023 1
a1023 1
	      flt_argreg > 0 && flt_argreg <= tdep->FLOAT_ARGLAST_REGNUM)
d1030 1
a1030 1
	  else if (argreg <= tdep->ARGLAST_REGNUM)
d1046 1
a1046 1
  regcache_cooked_write_unsigned (regcache, tdep->PR_REGNUM, bp_addr);
d1080 2
a1081 2
    regcache_cooked_write_unsigned (regcache, 
				    STRUCT_RETURN_REGNUM, 
d1093 1
a1093 1
  argreg = tdep->ARG0_REGNUM;
d1118 1
a1118 1
	  if (argreg > tdep->ARGLAST_REGNUM
d1128 1
a1128 1
	  if (argreg <= tdep->ARGLAST_REGNUM)
d1144 1
a1144 1
  regcache_cooked_write_unsigned (regcache, tdep->PR_REGNUM, bp_addr);
a1151 225
/* R2-R9 for integer types and integer equivalent (char, pointers) and
   non-scalar (struct, union) elements (even if the elements are
   floats).  
   FR0-FR11 for single precision floating point (float)
   DR0-DR10 for double precision floating point (double) 
   
   If a float is argument number 3 (for instance) and arguments number
   1,2, and 4 are integer, the mapping will be:
   arg1 -->R2, arg2 --> R3, arg3 -->FR0, arg4 --> R5. I.e. R4 is not used.
   
   If a float is argument number 10 (for instance) and arguments number
   1 through 10 are integer, the mapping will be:
   arg1->R2, arg2->R3, arg3->R4, arg4->R5, arg5->R6, arg6->R7, arg7->R8,
   arg8->R9, arg9->(0,SP)stack(8-byte aligned), arg10->FR0, arg11->stack(16,SP).
   I.e. there is hole in the stack.

   Different rules apply for variable arguments functions, and for functions
   for which the prototype is not known. */

static CORE_ADDR
sh64_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
{
  int stack_offset, stack_alloc;
  int int_argreg;
  int float_argreg;
  int double_argreg;
  int float_arg_index = 0;
  int double_arg_index = 0;
  int argnum;
  struct type *type;
  CORE_ADDR regval;
  char *val;
  char valbuf[8];
  char valbuf_tmp[8];
  int len;
  int argreg_size;
  int fp_args[12];
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  memset (fp_args, 0, sizeof (fp_args));

  /* first force sp to a 8-byte alignment */
  sp = sp & ~7;

  /* The "struct return pointer" pseudo-argument has its own dedicated 
     register */

  if (struct_return)
    write_register (STRUCT_RETURN_REGNUM, struct_addr);

  /* Now make sure there's space on the stack */
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 7) & ~7);
  sp -= stack_alloc;		/* make room on stack for args */

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  There are 64 bytes
     in eight registers available.  Loop thru args from first to last.  */

  int_argreg = tdep->ARG0_REGNUM;
  float_argreg = FP0_REGNUM;
  double_argreg = tdep->DR0_REGNUM;

  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
      type = VALUE_TYPE (args[argnum]);
      len = TYPE_LENGTH (type);
      memset (valbuf, 0, sizeof (valbuf));
      
      if (TYPE_CODE (type) != TYPE_CODE_FLT)
	{
	  argreg_size = REGISTER_RAW_SIZE (int_argreg);

	  if (len < argreg_size)
	    {
	      /* value gets right-justified in the register or stack word */
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
		memcpy (valbuf + argreg_size - len,
			(char *) VALUE_CONTENTS (args[argnum]), len);
	      else
		memcpy (valbuf, (char *) VALUE_CONTENTS (args[argnum]), len);

	      val = valbuf;
	    }
	  else
	    val = (char *) VALUE_CONTENTS (args[argnum]);

	  while (len > 0)
	    {
	      if (int_argreg > tdep->ARGLAST_REGNUM)
		{			
		  /* must go on the stack */
		  write_memory (sp + stack_offset, val, argreg_size);
		  stack_offset += 8;/*argreg_size;*/
		}
	      /* NOTE WELL!!!!!  This is not an "else if" clause!!!
		 That's because some *&^%$ things get passed on the stack
		 AND in the registers!   */
	      if (int_argreg <= tdep->ARGLAST_REGNUM)
		{			
		  /* there's room in a register */
		  regval = extract_unsigned_integer (val, argreg_size);
		  write_register (int_argreg, regval);
		}
	      /* Store the value 8 bytes at a time.  This means that
		 things larger than 8 bytes may go partly in registers
		 and partly on the stack. FIXME: argreg is incremented
		 before we use its size. */
	      len -= argreg_size;
	      val += argreg_size;
	      int_argreg++;
	    }
	}
      else
	{
	  val = (char *) VALUE_CONTENTS (args[argnum]);
	  if (len == 4)
	    {
	      /* Where is it going to be stored? */
	      while (fp_args[float_arg_index])
		float_arg_index ++;

	      /* Now float_argreg points to the register where it
		 should be stored.  Are we still within the allowed
		 register set? */
	      if (float_arg_index <= tdep->FLOAT_ARGLAST_REGNUM)
		{
		  /* Goes in FR0...FR11 */
		  deprecated_write_register_gen (FP0_REGNUM + float_arg_index,
						 val);
		  fp_args[float_arg_index] = 1;
		  /* Skip the corresponding general argument register. */
		  int_argreg ++;
		}
	      else 
		;
		/* Store it as the integers, 8 bytes at the time, if
		   necessary spilling on the stack. */
	      
	    }
	    else if (len == 8)
	      {
		/* Where is it going to be stored? */
		while (fp_args[double_arg_index])
		  double_arg_index += 2;
		/* Now double_argreg points to the register
		   where it should be stored.
		   Are we still within the allowed register set? */
		if (double_arg_index < tdep->FLOAT_ARGLAST_REGNUM)
		  {
		    /* Goes in DR0...DR10 */
		    /* The numbering of the DRi registers is consecutive,
		       i.e. includes odd numbers. */
		    int double_register_offset = double_arg_index / 2;
		    int regnum = tdep->DR0_REGNUM +
		                 double_register_offset;
#if 0
		    if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
		      {
			memset (valbuf_tmp, 0, sizeof (valbuf_tmp));
			DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL (regnum,
								type, val,
								valbuf_tmp);
			val = valbuf_tmp;
		      }
#endif
		    /* Note: must use write_register_gen here instead
		       of regcache_raw_write, because
		       regcache_raw_write works only for real
		       registers, not pseudo.  write_register_gen will
		       call the gdbarch function to do register
		       writes, and that will properly know how to deal
		       with pseudoregs. */
		    deprecated_write_register_gen (regnum, val);
		    fp_args[double_arg_index] = 1;
		    fp_args[double_arg_index + 1] = 1;
		    /* Skip the corresponding general argument register. */
		    int_argreg ++;
		  }
		else
		  ;
		  /* Store it as the integers, 8 bytes at the time, if
                     necessary spilling on the stack. */
	      }
	}
    }
  return sp;
}

/* Function: push_return_address (pc)
   Set up the return address for the inferior function call.
   Needed for targets where we don't actually execute a JSR/BSR instruction */

static CORE_ADDR
sh64_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM,
		  CALL_DUMMY_ADDRESS ());
  return sp;
}

/* Function: fix_call_dummy
   Poke the callee function's address into the destination part of 
   the CALL_DUMMY.  The address is actually stored in a data word 
   following the actualy CALL_DUMMY instructions, which will load
   it into a register using PC-relative addressing.  This function
   expects the CALL_DUMMY to look like this:

   mov.w @@(2,PC), R8
   jsr   @@R8
   nop
   trap
   <destination>
 */

#if 0
void
sh_fix_call_dummy (char *dummy, CORE_ADDR pc, CORE_ADDR fun, int nargs,
		   struct value **args, struct type *type, int gcc_p)
{
  *(unsigned long *) (dummy + 8) = fun;
}
#endif

a1195 53
static void
sh64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
{
  int offset;
  int return_register;
  int len = TYPE_LENGTH (type);
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
  
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      if (len == 4)
	{
	  /* Return value stored in FP0_REGNUM */
	  return_register = FP0_REGNUM;
	  offset = REGISTER_BYTE (return_register);
	  memcpy (valbuf, (char *) regbuf + offset, len); 
	}
      else if (len == 8)
	{
	  /* return value stored in DR0_REGNUM */
	  DOUBLEST val;

	  return_register = tdep->DR0_REGNUM;
	  offset = REGISTER_BYTE (return_register);
	  
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	    floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
				     (char *) regbuf + offset, &val);
	  else
	    floatformat_to_doublest (&floatformat_ieee_double_big,
				     (char *) regbuf + offset, &val);
	  deprecated_store_floating (valbuf, len, val);
	}
    }
  else
    { 
      if (len <= 8)
	{
	  /* Result is in register 2. If smaller than 8 bytes, it is padded 
	     at the most significant end. */
	  return_register = tdep->RETURN_REGNUM;
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    offset = REGISTER_BYTE (return_register) +
	      REGISTER_RAW_SIZE (return_register) - len;
	  else
	    offset = REGISTER_BYTE (return_register);
	  memcpy (valbuf, (char *) regbuf + offset, len);
	}
      else
	error ("bad size for return value");
    }
}

a1236 41
static void
sh64_store_return_value (struct type *type, char *valbuf)
{
  char buf[64];	/* more than enough... */
  int len = TYPE_LENGTH (type);

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      if (len == 4)
	{
	  /* Return value stored in FP0_REGNUM */
	  deprecated_write_register_gen (FP0_REGNUM, valbuf);
	}
      if (len == 8)
	{
	  /* return value stored in DR0_REGNUM */
	  /* FIXME: Implement */
	}
    }
  else
    {
      int return_register = gdbarch_tdep (current_gdbarch)->RETURN_REGNUM;
      int offset = 0;

      if (len <= REGISTER_RAW_SIZE (return_register))
	{
	  /* Pad with zeros. */
	  memset (buf, 0, REGISTER_RAW_SIZE (return_register));
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	    offset = 0; /*REGISTER_RAW_SIZE (return_register) - len;*/
	  else
	    offset = REGISTER_RAW_SIZE (return_register) - len;

	  memcpy (buf + offset, valbuf, len);
	  deprecated_write_register_gen (return_register, buf);
	}
      else
	deprecated_write_register_gen (return_register, valbuf);
    }
}

d1246 2
a1247 2
		   (long) read_register (tdep->SR_REGNUM),
		   (long) read_register (tdep->PR_REGNUM),
d1282 2
a1283 2
		   (long) read_register (tdep->SR_REGNUM),
		   (long) read_register (tdep->PR_REGNUM),
d1378 2
a1379 2
		   (long) read_register (tdep->SR_REGNUM),
		   (long) read_register (tdep->PR_REGNUM),
d1439 2
a1440 2
		   (long) read_register (tdep->SR_REGNUM),
		   (long) read_register (tdep->PR_REGNUM),
d1499 2
a1500 2
		   (long) read_register (tdep->SR_REGNUM),
		   (long) read_register (tdep->PR_REGNUM),
d1564 2
a1565 2
		   (long) read_register (tdep->SR_REGNUM),
		   (long) read_register (tdep->PR_REGNUM),
a1612 92
sh64_show_media_regs (void)
{
  int i;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  printf_filtered ("PC=%s SR=%016llx \n",
		   paddr (read_register (PC_REGNUM)),
		   (long long) read_register (tdep->SR_REGNUM));

  printf_filtered ("SSR=%016llx SPC=%016llx \n",
		   (long long) read_register (tdep->SSR_REGNUM),
		   (long long) read_register (tdep->SPC_REGNUM));
  printf_filtered ("FPSCR=%016lx\n ",
		   (long) read_register (tdep->FPSCR_REGNUM));

  for (i = 0; i < 64; i = i + 4)
    printf_filtered ("\nR%d-R%d  %016llx %016llx %016llx %016llx\n",
		     i, i + 3,
		     (long long) read_register (i + 0),
		     (long long) read_register (i + 1),
		     (long long) read_register (i + 2),
		     (long long) read_register (i + 3));

  printf_filtered ("\n");
  
  for (i = 0; i < 64; i = i + 8)
    printf_filtered ("FR%d-FR%d  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		     i, i + 7,
		     (long) read_register (FP0_REGNUM + i + 0),
		     (long) read_register (FP0_REGNUM + i + 1),
		     (long) read_register (FP0_REGNUM + i + 2),
		     (long) read_register (FP0_REGNUM + i + 3),
		     (long) read_register (FP0_REGNUM + i + 4),
		     (long) read_register (FP0_REGNUM + i + 5),
		     (long) read_register (FP0_REGNUM + i + 6),
		     (long) read_register (FP0_REGNUM + i + 7));
}

static void
sh64_show_compact_regs (void)
{
  int i;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  printf_filtered ("PC=%s \n",
		   paddr (read_register (tdep->PC_C_REGNUM)));

  printf_filtered ("GBR=%08lx MACH=%08lx MACL=%08lx PR=%08lx T=%08lx\n",
		   (long) read_register (tdep->GBR_C_REGNUM),
		   (long) read_register (tdep->MACH_C_REGNUM),
		   (long) read_register (tdep->MACL_C_REGNUM),
		   (long) read_register (tdep->PR_C_REGNUM),
		   (long) read_register (tdep->T_C_REGNUM));
  printf_filtered ("FPSCR=%08lx FPUL=%08lx\n",
		   (long) read_register (tdep->FPSCR_REGNUM),
		   (long) read_register (tdep->FPUL_REGNUM));

  for (i = 0; i < 16; i = i + 4)
    printf_filtered ("\nR%d-R%d  %08lx %08lx %08lx %08lx\n",
		     i, i + 3,
		     (long) read_register (i + 0),
		     (long) read_register (i + 1),
		     (long) read_register (i + 2),
		     (long) read_register (i + 3));

  printf_filtered ("\n");
  
  for (i = 0; i < 16; i = i + 8)
    printf_filtered ("FR%d-FR%d  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		     i, i + 7,
		     (long) read_register (FP0_REGNUM + i + 0),
		     (long) read_register (FP0_REGNUM + i + 1),
		     (long) read_register (FP0_REGNUM + i + 2),
		     (long) read_register (FP0_REGNUM + i + 3),
		     (long) read_register (FP0_REGNUM + i + 4),
		     (long) read_register (FP0_REGNUM + i + 5),
		     (long) read_register (FP0_REGNUM + i + 6),
		     (long) read_register (FP0_REGNUM + i + 7));
}

/*FIXME!!! This only shows the registers for shmedia, excluding the
  pseudo registers. */
static void
sh64_show_regs (void)
{
  if (pc_is_isa32 (get_frame_pc (deprecated_selected_frame)))
    sh64_show_media_regs ();
  else
    sh64_show_compact_regs ();
}

static void
a1618 190
/* *INDENT-OFF* */
/*
    SH MEDIA MODE (ISA 32)
    general registers (64-bit) 0-63
0    r0,   r1,   r2,   r3,   r4,   r5,   r6,   r7,
64   r8,   r9,   r10,  r11,  r12,  r13,  r14,  r15,
128  r16,  r17,  r18,  r19,  r20,  r21,  r22,  r23,
192  r24,  r25,  r26,  r27,  r28,  r29,  r30,  r31,
256  r32,  r33,  r34,  r35,  r36,  r37,  r38,  r39,
320  r40,  r41,  r42,  r43,  r44,  r45,  r46,  r47,
384  r48,  r49,  r50,  r51,  r52,  r53,  r54,  r55,
448  r56,  r57,  r58,  r59,  r60,  r61,  r62,  r63,

    pc (64-bit) 64
512  pc,

    status reg., saved status reg., saved pc reg. (64-bit) 65-67
520  sr,  ssr,  spc,

    target registers (64-bit) 68-75
544  tr0,  tr1,  tr2,  tr3,  tr4,  tr5,  tr6,  tr7,

    floating point state control register (32-bit) 76
608  fpscr,

    single precision floating point registers (32-bit) 77-140
612  fr0,  fr1,  fr2,  fr3,  fr4,  fr5,  fr6,  fr7,
644  fr8,  fr9,  fr10, fr11, fr12, fr13, fr14, fr15,
676  fr16, fr17, fr18, fr19, fr20, fr21, fr22, fr23,
708  fr24, fr25, fr26, fr27, fr28, fr29, fr30, fr31,
740  fr32, fr33, fr34, fr35, fr36, fr37, fr38, fr39,
772  fr40, fr41, fr42, fr43, fr44, fr45, fr46, fr47,
804  fr48, fr49, fr50, fr51, fr52, fr53, fr54, fr55,
836  fr56, fr57, fr58, fr59, fr60, fr61, fr62, fr63,

TOTAL SPACE FOR REGISTERS: 868 bytes

From here on they are all pseudo registers: no memory allocated.
REGISTER_BYTE returns the register byte for the base register.

    double precision registers (pseudo) 141-172
     dr0,  dr2,  dr4,  dr6,  dr8,  dr10, dr12, dr14,
     dr16, dr18, dr20, dr22, dr24, dr26, dr28, dr30,
     dr32, dr34, dr36, dr38, dr40, dr42, dr44, dr46,
     dr48, dr50, dr52, dr54, dr56, dr58, dr60, dr62,
 
    floating point pairs (pseudo) 173-204
     fp0,  fp2,  fp4,  fp6,  fp8,  fp10, fp12, fp14,
     fp16, fp18, fp20, fp22, fp24, fp26, fp28, fp30,
     fp32, fp34, fp36, fp38, fp40, fp42, fp44, fp46,
     fp48, fp50, fp52, fp54, fp56, fp58, fp60, fp62,
 
    floating point vectors (4 floating point regs) (pseudo) 205-220
     fv0,  fv4,  fv8,  fv12, fv16, fv20, fv24, fv28,
     fv32, fv36, fv40, fv44, fv48, fv52, fv56, fv60,
 
    SH COMPACT MODE (ISA 16) (all pseudo) 221-272
     r0_c, r1_c, r2_c,  r3_c,  r4_c,  r5_c,  r6_c,  r7_c,
     r8_c, r9_c, r10_c, r11_c, r12_c, r13_c, r14_c, r15_c,
     pc_c,
     gbr_c, mach_c, macl_c, pr_c, t_c,
     fpscr_c, fpul_c,
     fr0_c, fr1_c, fr2_c,  fr3_c,  fr4_c,  fr5_c,  fr6_c,  fr7_c,
     fr8_c, fr9_c, fr10_c, fr11_c, fr12_c, fr13_c, fr14_c, fr15_c
     dr0_c, dr2_c, dr4_c,  dr6_c,  dr8_c,  dr10_c, dr12_c, dr14_c
     fv0_c, fv4_c, fv8_c,  fv12_c
*/
/* *INDENT-ON* */
static int
sh_sh64_register_byte (int reg_nr)
{
  int base_regnum = -1;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  /* If it is a pseudo register, get the number of the first floating
     point register that is part of it. */
  if (reg_nr >= tdep->DR0_REGNUM 
      && reg_nr <= tdep->DR_LAST_REGNUM)
    base_regnum = dr_reg_base_num (reg_nr);

  else if (reg_nr >= tdep->FPP0_REGNUM 
	    && reg_nr <= tdep->FPP_LAST_REGNUM)
    base_regnum = fpp_reg_base_num (reg_nr);

  else if (reg_nr >= tdep->FV0_REGNUM 
	    && reg_nr <= tdep->FV_LAST_REGNUM)
    base_regnum = fv_reg_base_num (reg_nr);

  /* sh compact pseudo register. FPSCR is a pathological case, need to
     treat it as special. */
  else if ((reg_nr >= tdep->R0_C_REGNUM 
	    && reg_nr <= tdep->FV_LAST_C_REGNUM) 
	   && reg_nr != tdep->FPSCR_C_REGNUM)
    base_regnum = sh64_compact_reg_base_num (reg_nr);

  /* Now return the offset in bytes within the register cache. */
  /* sh media pseudo register, i.e. any of DR, FFP, FV registers. */
  if (reg_nr >= tdep->DR0_REGNUM 
      && reg_nr <= tdep->FV_LAST_REGNUM)
    return (base_regnum - FP0_REGNUM + 1) * 4 
      + (tdep->TR7_REGNUM + 1) * 8;

  /* sh compact pseudo register: general register */
  if ((reg_nr >= tdep->R0_C_REGNUM 
       && reg_nr <= tdep->R_LAST_C_REGNUM))
    return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	    ? base_regnum * 8 + 4
	    : base_regnum * 8);

  /* sh compact pseudo register: */
  if (reg_nr == tdep->PC_C_REGNUM 
       || reg_nr == tdep->GBR_C_REGNUM
       || reg_nr == tdep->MACL_C_REGNUM
       || reg_nr == tdep->PR_C_REGNUM)
    return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	    ? base_regnum * 8 + 4
	    : base_regnum * 8);

  if (reg_nr == tdep->MACH_C_REGNUM) 
    return base_regnum * 8;

  if (reg_nr == tdep->T_C_REGNUM) 
    return base_regnum * 8; /* FIXME??? how do we get bit 0? Do we have to? */

  /* sh compact pseudo register: floating point register */
  else if (reg_nr >=tdep->FP0_C_REGNUM
	   && reg_nr <= tdep->FV_LAST_C_REGNUM)
    return (base_regnum  - FP0_REGNUM) * 4
      + (tdep->TR7_REGNUM + 1) * 8 + 4;

  else if (reg_nr == tdep->FPSCR_C_REGNUM)
    /* This is complicated, for now return the beginning of the
       architectural FPSCR register. */
    return (tdep->TR7_REGNUM + 1) * 8;

  else if (reg_nr == tdep->FPUL_C_REGNUM)
    return ((base_regnum - FP0_REGNUM) * 4 + 
	    (tdep->TR7_REGNUM + 1) * 8 + 4);

  /* It is not a pseudo register. */
  /* It is a 64 bit register. */
  else if (reg_nr <= tdep->TR7_REGNUM)
    return reg_nr * 8;

  /* It is a 32 bit register. */
  else
    if (reg_nr == tdep->FPSCR_REGNUM)
      return (tdep->FPSCR_REGNUM * 8);

  /* It is floating point 32-bit register */
  else
    return ((tdep->TR7_REGNUM + 1) * 8 
      + (reg_nr - FP0_REGNUM + 1) * 4);
}

static int
sh_sh64_register_raw_size (int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if ((reg_nr >= tdep->DR0_REGNUM 
       && reg_nr <= tdep->DR_LAST_REGNUM)
      || (reg_nr >= tdep->FPP0_REGNUM 
	  && reg_nr <= tdep->FPP_LAST_REGNUM)
      || (reg_nr >= tdep->DR0_C_REGNUM 
	  && reg_nr <= tdep->DR_LAST_C_REGNUM)
      || (reg_nr <= tdep->TR7_REGNUM))
    return 8;

  else if ((reg_nr >= tdep->FV0_REGNUM 
	    && reg_nr <= tdep->FV_LAST_REGNUM)
	   || (reg_nr >= tdep->FV0_C_REGNUM 
	       && reg_nr <= tdep->FV_LAST_C_REGNUM))
    return 16;

  else /* this covers also the 32-bit SH compact registers. */
    return 4;
}

/* ??????? FIXME */
static int
sh_sh64_register_virtual_size (int reg_nr)
{
  if (reg_nr >= FP0_REGNUM
      && reg_nr <= gdbarch_tdep (current_gdbarch)->FP_LAST_REGNUM)
    return 4;
  else
    return 8;
}

a1662 32
sh_sh64_register_virtual_type (int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if ((reg_nr >= FP0_REGNUM
       && reg_nr <= tdep->FP_LAST_REGNUM)
      || (reg_nr >= tdep->FP0_C_REGNUM
	  && reg_nr <= tdep->FP_LAST_C_REGNUM))
    return builtin_type_float;
  else if ((reg_nr >= tdep->DR0_REGNUM 
	    && reg_nr <= tdep->DR_LAST_REGNUM)
	   || (reg_nr >= tdep->DR0_C_REGNUM 
	       && reg_nr <= tdep->DR_LAST_C_REGNUM))
    return builtin_type_double;
  else if  (reg_nr >= tdep->FPP0_REGNUM 
	    && reg_nr <= tdep->FPP_LAST_REGNUM)
    return sh_sh4_build_float_register_type (1);
  else if ((reg_nr >= tdep->FV0_REGNUM
	    && reg_nr <= tdep->FV_LAST_REGNUM)
	   ||(reg_nr >= tdep->FV0_C_REGNUM 
	      && reg_nr <= tdep->FV_LAST_C_REGNUM))
    return sh_sh4_build_float_register_type (3);
  else if (reg_nr == tdep->FPSCR_REGNUM)
    return builtin_type_int;
  else if (reg_nr >= tdep->R0_C_REGNUM
	   && reg_nr < tdep->FP0_C_REGNUM)
    return builtin_type_int;
  else
    return builtin_type_long_long;
}

static struct type *
a1711 26
sh_sh64_register_convert_to_virtual (int regnum, struct type *type,
				     char *from, char *to)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (TARGET_BYTE_ORDER != BFD_ENDIAN_LITTLE)
    {
      /* It is a no-op. */
      memcpy (to, from, REGISTER_RAW_SIZE (regnum));
      return;
    }

  if ((regnum >= tdep->DR0_REGNUM 
       && regnum <= tdep->DR_LAST_REGNUM)
      || (regnum >= tdep->DR0_C_REGNUM 
	  && regnum <= tdep->DR_LAST_C_REGNUM))
    {
      DOUBLEST val;
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword, from, &val);
      deprecated_store_floating(to, TYPE_LENGTH(type), val);
    }
  else
    error("sh_register_convert_to_virtual called with non DR register number");
}

static void
a1727 25
sh_sh64_register_convert_to_raw (struct type *type, int regnum,
				 const void *from, void *to)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (TARGET_BYTE_ORDER != BFD_ENDIAN_LITTLE)
    {
      /* It is a no-op. */
      memcpy (to, from, REGISTER_RAW_SIZE (regnum));
      return;
    }

  if ((regnum >= tdep->DR0_REGNUM 
       && regnum <= tdep->DR_LAST_REGNUM)
      || (regnum >= tdep->DR0_C_REGNUM 
	  && regnum <= tdep->DR_LAST_C_REGNUM))
    {
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword, &val, to);
    }
  else
    error("sh_register_convert_to_raw called with non DR register number");
}

static void
a1764 166
sh64_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, void *buffer)
{
  int base_regnum;
  int portion;
  int offset = 0;
  char temp_buffer[MAX_REGISTER_SIZE];
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 

  if (reg_nr >= tdep->DR0_REGNUM 
      && reg_nr <= tdep->DR_LAST_REGNUM)
    {
      base_regnum = dr_reg_base_num (reg_nr);

      /* Build the value in the provided buffer. */ 
      /* DR regs are double precision registers obtained by
	 concatenating 2 single precision floating point registers. */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   (temp_buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));

      /* We must pay attention to the endiannes. */
      sh_sh64_register_convert_to_virtual (reg_nr, REGISTER_VIRTUAL_TYPE (reg_nr),
					   temp_buffer, buffer);

    }

  else if (reg_nr >= tdep->FPP0_REGNUM 
	   && reg_nr <= tdep->FPP_LAST_REGNUM)
    {
      base_regnum = fpp_reg_base_num (reg_nr);

      /* Build the value in the provided buffer. */ 
      /* FPP regs are pairs of single precision registers obtained by
	 concatenating 2 single precision floating point registers. */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
    }

  else if (reg_nr >= tdep->FV0_REGNUM 
	   && reg_nr <= tdep->FV_LAST_REGNUM)
    {
      base_regnum = fv_reg_base_num (reg_nr);

      /* Build the value in the provided buffer. */ 
      /* FV regs are vectors of single precision registers obtained by
	 concatenating 4 single precision floating point registers. */
      for (portion = 0; portion < 4; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
    }

  /* sh compact pseudo registers. 1-to-1 with a shmedia register */
  else if (reg_nr >= tdep->R0_C_REGNUM 
	   && reg_nr <= tdep->T_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);

      /* Build the value in the provided buffer. */ 
      regcache_raw_read (regcache, base_regnum, temp_buffer);
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = 4;
      memcpy (buffer, temp_buffer + offset, 4); /* get LOWER 32 bits only????*/
    }

  else if (reg_nr >= tdep->FP0_C_REGNUM
	   && reg_nr <= tdep->FP_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);

      /* Build the value in the provided buffer. */ 
      /* Floating point registers map 1-1 to the media fp regs,
	 they have the same size and endienness. */
      regcache_raw_read (regcache, base_regnum, buffer);
    }

  else if (reg_nr >= tdep->DR0_C_REGNUM 
	   && reg_nr <= tdep->DR_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);

      /* DR_C regs are double precision registers obtained by
	 concatenating 2 single precision floating point registers. */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   (temp_buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));

      /* We must pay attention to the endiannes. */
      sh_sh64_register_convert_to_virtual (reg_nr, REGISTER_VIRTUAL_TYPE (reg_nr),
					   temp_buffer, buffer);
    }

  else if (reg_nr >= tdep->FV0_C_REGNUM 
	   && reg_nr <= tdep->FV_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);

      /* Build the value in the provided buffer. */ 
      /* FV_C regs are vectors of single precision registers obtained by
	 concatenating 4 single precision floating point registers. */
      for (portion = 0; portion < 4; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
    }

  else if (reg_nr == tdep->FPSCR_C_REGNUM)
    {
      int fpscr_base_regnum;
      int sr_base_regnum;
      unsigned int fpscr_value;
      unsigned int sr_value;
      unsigned int fpscr_c_value;
      unsigned int fpscr_c_part1_value;
      unsigned int fpscr_c_part2_value;

      fpscr_base_regnum = tdep->FPSCR_REGNUM;
      sr_base_regnum = tdep->SR_REGNUM;

      /* Build the value in the provided buffer. */ 
      /* FPSCR_C is a very weird register that contains sparse bits
	 from the FPSCR and the SR architectural registers.
	 Specifically: */
      /* *INDENT-OFF* */
      /*
	 FPSRC_C bit
            0         Bit 0 of FPSCR
            1         reserved
            2-17      Bit 2-18 of FPSCR
            18-20     Bits 12,13,14 of SR
            21-31     reserved
       */
      /* *INDENT-ON* */
      /* Get FPSCR into a local buffer */
      regcache_raw_read (regcache, fpscr_base_regnum, temp_buffer);
      /* Get value as an int. */
      fpscr_value = extract_unsigned_integer (temp_buffer, 4);
      /* Get SR into a local buffer */
      regcache_raw_read (regcache, sr_base_regnum, temp_buffer);
      /* Get value as an int. */
      sr_value = extract_unsigned_integer (temp_buffer, 4);
      /* Build the new value. */
      fpscr_c_part1_value = fpscr_value & 0x3fffd;
      fpscr_c_part2_value = (sr_value & 0x7000) << 6;
      fpscr_c_value = fpscr_c_part1_value | fpscr_c_part2_value;
      /* Store that in out buffer!!! */
      store_unsigned_integer (buffer, 4, fpscr_c_value);
      /* FIXME There is surely an endianness gotcha here. */
    }

  else if (reg_nr == tdep->FPUL_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);

      /* FPUL_C register is floating point register 32,
	 same size, same endianness. */
      regcache_raw_read (regcache, base_regnum, buffer);
    }
}

static void
a1799 167
static void
sh64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const void *buffer)
{
  int base_regnum, portion;
  int offset;
  char temp_buffer[MAX_REGISTER_SIZE];
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);

  if (reg_nr >= tdep->DR0_REGNUM
      && reg_nr <= tdep->DR_LAST_REGNUM)
    {
      base_regnum = dr_reg_base_num (reg_nr);
      /* We must pay attention to the endiannes. */
      sh_sh64_register_convert_to_raw (REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
				       buffer, temp_buffer);
	  

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_write (regcache, base_regnum + portion, 
			    (temp_buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
    }

  else if (reg_nr >= tdep->FPP0_REGNUM 
	   && reg_nr <= tdep->FPP_LAST_REGNUM)
    {
      base_regnum = fpp_reg_base_num (reg_nr);

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_write (regcache, base_regnum + portion,
			    ((char *) buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
    }

  else if (reg_nr >= tdep->FV0_REGNUM
	   && reg_nr <= tdep->FV_LAST_REGNUM)
    {
      base_regnum = fv_reg_base_num (reg_nr);

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 4; portion++)
	regcache_raw_write (regcache, base_regnum + portion,
			    ((char *) buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
    }

  /* sh compact general pseudo registers. 1-to-1 with a shmedia
     register but only 4 bytes of it.  */
  else if (reg_nr >= tdep->R0_C_REGNUM 
	   && reg_nr <= tdep->T_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);
      /* reg_nr is 32 bit here, and base_regnum is 64 bits. */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = 4;
      else 
	offset = 0;
      /* Let's read the value of the base register into a temporary
	 buffer, so that overwriting the last four bytes with the new
	 value of the pseudo will leave the upper 4 bytes unchanged. */
      regcache_raw_read (regcache, base_regnum, temp_buffer);
      /* Write as an 8 byte quantity */
      memcpy (temp_buffer + offset, buffer, 4);
      regcache_raw_write (regcache, base_regnum, temp_buffer);
    }

  /* sh floating point compact pseudo registers. 1-to-1 with a shmedia
     registers. Both are 4 bytes. */
  else if (reg_nr >= tdep->FP0_C_REGNUM
	       && reg_nr <= tdep->FP_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);
      regcache_raw_write (regcache, base_regnum, buffer);
    }

  else if (reg_nr >= tdep->DR0_C_REGNUM 
	   && reg_nr <= tdep->DR_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);
      for (portion = 0; portion < 2; portion++)
	{
	  /* We must pay attention to the endiannes. */
	  sh_sh64_register_convert_to_raw (REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
					   buffer, temp_buffer);

	  regcache_raw_write (regcache, base_regnum + portion,
			      (temp_buffer
			       + REGISTER_RAW_SIZE (base_regnum) * portion));
	}
    }

  else if (reg_nr >= tdep->FV0_C_REGNUM 
	   && reg_nr <= tdep->FV_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);
     
      for (portion = 0; portion < 4; portion++)
	{
	  regcache_raw_write (regcache, base_regnum + portion,
			      ((char *) buffer
			       + REGISTER_RAW_SIZE (base_regnum) * portion));
	}
    }

  else if (reg_nr == tdep->FPSCR_C_REGNUM)
    {      
      int fpscr_base_regnum;
      int sr_base_regnum;
      unsigned int fpscr_value;
      unsigned int sr_value;
      unsigned int old_fpscr_value;
      unsigned int old_sr_value;
      unsigned int fpscr_c_value;
      unsigned int fpscr_mask;
      unsigned int sr_mask;

      fpscr_base_regnum = tdep->FPSCR_REGNUM;
      sr_base_regnum = tdep->SR_REGNUM;

      /* FPSCR_C is a very weird register that contains sparse bits
	 from the FPSCR and the SR architectural registers.
	 Specifically: */
      /* *INDENT-OFF* */
      /*
	 FPSRC_C bit
            0         Bit 0 of FPSCR
            1         reserved
            2-17      Bit 2-18 of FPSCR
            18-20     Bits 12,13,14 of SR
            21-31     reserved
       */
      /* *INDENT-ON* */
      /* Get value as an int. */
      fpscr_c_value = extract_unsigned_integer (buffer, 4);

      /* Build the new values. */
      fpscr_mask = 0x0003fffd;
      sr_mask = 0x001c0000;
       
      fpscr_value = fpscr_c_value & fpscr_mask;
      sr_value = (fpscr_value & sr_mask) >> 6;
      
      regcache_raw_read (regcache, fpscr_base_regnum, temp_buffer);
      old_fpscr_value = extract_unsigned_integer (temp_buffer, 4);
      old_fpscr_value &= 0xfffc0002;
      fpscr_value |= old_fpscr_value;
      store_unsigned_integer (temp_buffer, 4, fpscr_value);
      regcache_raw_write (regcache, fpscr_base_regnum, temp_buffer);
      
      regcache_raw_read (regcache, sr_base_regnum, temp_buffer);
      old_sr_value = extract_unsigned_integer (temp_buffer, 4);
      old_sr_value &= 0xffff8fff;
      sr_value |= old_sr_value;
      store_unsigned_integer (temp_buffer, 4, sr_value);
      regcache_raw_write (regcache, sr_base_regnum, temp_buffer);
    }

  else if (reg_nr == tdep->FPUL_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (reg_nr);
      regcache_raw_write (regcache, base_regnum, buffer);
    }
}

a1813 26
/* Floating point vector of 4 float registers, compact mode. */
static void
do_fv_c_register_info (int fv_regnum)
{
  int first_fp_reg_num = sh64_compact_reg_base_num (fv_regnum);
  printf_filtered ("fv%d_c\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
		     fv_regnum - gdbarch_tdep (current_gdbarch)->FV0_C_REGNUM, 
		     (int) read_register (first_fp_reg_num),
		     (int) read_register (first_fp_reg_num + 1),
		     (int) read_register (first_fp_reg_num + 2),
		     (int) read_register (first_fp_reg_num + 3));
}

/* Pairs of single regs. The DR are instead double precision
   registers. */
static void
do_fpp_register_info (int fpp_regnum)
{
  int first_fp_reg_num = fpp_reg_base_num (fpp_regnum);

  printf_filtered ("fpp%d\t0x%08x\t0x%08x\n", 
		    fpp_regnum - gdbarch_tdep (current_gdbarch)->FPP0_REGNUM, 
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1));
}

a1826 50
/* Double precision registers, compact mode. */
static void
do_dr_c_register_info (int dr_regnum)
{
 int first_fp_reg_num = sh64_compact_reg_base_num (dr_regnum);

 printf_filtered ("dr%d_c\t0x%08x%08x\n",
		  dr_regnum - gdbarch_tdep (current_gdbarch)->DR0_C_REGNUM,
		  (int) read_register (first_fp_reg_num),
		  (int) read_register (first_fp_reg_num +1));
}

/* General register in compact mode. */
static void
do_r_c_register_info (int r_c_regnum)
{
  int regnum =  sh64_compact_reg_base_num (r_c_regnum);

  printf_filtered ("r%d_c\t0x%08x\n", 
		    r_c_regnum - gdbarch_tdep (current_gdbarch)->R0_C_REGNUM, 
		   /*FIXME!!!*/  (int) read_register (regnum));
}

/* FIXME:!! THIS SHOULD TAKE CARE OF GETTING THE RIGHT PORTION OF THE
   shmedia REGISTERS. */
/* Control registers, compact mode. */
static void
do_cr_c_register_info (int cr_c_regnum)
{
  switch (cr_c_regnum)
    {
    case 237: printf_filtered ("pc_c\t0x%08x\n", (int) read_register (cr_c_regnum));
      break;
    case 238: printf_filtered ("gbr_c\t0x%08x\n", (int) read_register (cr_c_regnum));
      break;
    case 239: printf_filtered ("mach_c\t0x%08x\n", (int) read_register (cr_c_regnum));
      break;
    case 240: printf_filtered ("macl_c\t0x%08x\n", (int) read_register (cr_c_regnum));
      break;
    case 241: printf_filtered ("pr_c\t0x%08x\n", (int) read_register (cr_c_regnum));
      break;
    case 242: printf_filtered ("t_c\t0x%08x\n", (int) read_register (cr_c_regnum));
      break;
    case 243: printf_filtered ("fpscr_c\t0x%08x\n", (int) read_register (cr_c_regnum));
      break;
    case 244: printf_filtered ("fpul_c\t0x%08x\n", (int)read_register (cr_c_regnum));
      break;
    }
}

a1884 45
sh64_do_pseudo_register (int regnum)
{
  /* All the sh64-compact mode registers are pseudo registers. */
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (regnum < NUM_REGS 
      || regnum >= NUM_REGS + NUM_PSEUDO_REGS_SH_MEDIA + NUM_PSEUDO_REGS_SH_COMPACT)
    internal_error (__FILE__, __LINE__,
		    "Invalid pseudo register number %d\n", regnum);

  else if ((regnum >= tdep->DR0_REGNUM
	    && regnum <= tdep->DR_LAST_REGNUM))
    do_dr_register_info (current_gdbarch, gdb_stdout, regnum);

  else if ((regnum >= tdep->DR0_C_REGNUM
	    && regnum <= tdep->DR_LAST_C_REGNUM))
    do_dr_c_register_info (regnum);

  else if ((regnum >= tdep->FV0_REGNUM
	    && regnum <= tdep->FV_LAST_REGNUM))
    do_fv_register_info (current_gdbarch, gdb_stdout, regnum);
	   
  else if ((regnum >= tdep->FV0_C_REGNUM
	    && regnum <= tdep->FV_LAST_C_REGNUM))
    do_fv_c_register_info (regnum);

  else if (regnum >= tdep->FPP0_REGNUM
	   && regnum <= tdep->FPP_LAST_REGNUM)
    do_fpp_register_info (regnum);

  else if (regnum >= tdep->R0_C_REGNUM
	   && regnum <= tdep->R_LAST_C_REGNUM)
    do_r_c_register_info (regnum); /* FIXME, this function will not print the right format */

  else if (regnum >= tdep->FP0_C_REGNUM
	   && regnum <= tdep->FP_LAST_C_REGNUM)
    sh_do_fp_register (current_gdbarch, gdb_stdout, regnum); /* this should work also for pseudoregs */

  else if (regnum >= tdep->PC_C_REGNUM
	   && regnum <= tdep->FPUL_C_REGNUM)
    do_cr_c_register_info (regnum);

}

static void
d1921 1
a1921 4
      if (gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh5)
	sh64_do_pseudo_register (regnum);
      else
	sh_print_pseudo_register (gdbarch, file, regnum);
d1972 1
a1972 4
	    if (gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh5)
	      sh64_do_pseudo_register (regnum);
	    else
	      sh_print_pseudo_register (gdbarch, file, regnum);
a1977 36
static void
sh_compact_do_registers_info (int regnum, int fpregs)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
  if (regnum != -1)		/* do one specified register */
    {
      if (*(REGISTER_NAME (regnum)) == '\0')
	error ("Not a valid register for the current processor type");

      if (regnum >= 0 && regnum < tdep->R0_C_REGNUM)
        error ("Not a valid register for the current processor mode.");

      sh_print_register (current_gdbarch, gdb_stdout, regnum);
    }
  else
    /* do all compact registers */
    {
      regnum = tdep->R0_C_REGNUM;
      while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
        {
          sh64_do_pseudo_register (regnum);
          regnum++;
        }
    }
}

static void
sh64_do_registers_info (int regnum, int fpregs)
{
  if (pc_is_isa32 (get_frame_pc (deprecated_selected_frame)))
   sh_print_registers_info (current_gdbarch, gdb_stdout,
			    deprecated_selected_frame, regnum, fpregs);
  else
   sh_compact_do_registers_info (regnum, fpregs); 
}

a2068 1
  static LONGEST sh64_call_dummy_words[] = {0};
d2072 32
a2122 2
  tdep->PR_REGNUM = 17;
  tdep->SR_REGNUM = 22;
a2143 6
  tdep->ARG0_REGNUM = 4;
  tdep->ARGLAST_REGNUM = 7;
  tdep->RETURN_REGNUM = 0;
  tdep->FLOAT_ARGLAST_REGNUM = -1;

  tdep->sh_abi = SH_ABI_UNKNOWN;
a2177 2
  skip_prologue_hard_way = sh_skip_prologue_hard_way;

a2190 1
      sh_show_regs = sh_generic_show_regs;
a2202 1
      sh_show_regs = sh_generic_show_regs;
a2217 1
      sh_show_regs = sh2e_show_regs;
a2227 2
      tdep->FLOAT_ARG0_REGNUM = 29;	/* FIXME use constants! */
      tdep->FLOAT_ARGLAST_REGNUM = 36;	/* FIXME use constants! */
d2229 1
a2229 2
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, 
						    sh_nofp_frame_init_saved_regs);
a2233 1
      sh_show_regs = sh_dsp_show_regs;
a2260 1
      sh_show_regs = sh3_show_regs;
a2277 1
      sh_show_regs = sh3e_show_regs;
a2287 2
      tdep->FLOAT_ARG0_REGNUM = 29;	/* FIXME use constants! */
      tdep->FLOAT_ARGLAST_REGNUM = 36;	/* FIXME use constants! */
a2295 1
      sh_show_regs = sh3_dsp_show_regs;
a2324 1
      sh_show_regs = sh4_show_regs;
a2343 2
      tdep->FLOAT_ARG0_REGNUM = 29;	/* FIXME use constants! */
      tdep->FLOAT_ARGLAST_REGNUM = 36;	/* FIXME use constants! */
a2346 102
    case bfd_mach_sh5:
      tdep->PR_REGNUM = 18;
      tdep->SR_REGNUM = 65;
      tdep->FPSCR_REGNUM = SIM_SH64_FPCSR_REGNUM;
      tdep->FP_LAST_REGNUM = SIM_SH64_FR0_REGNUM + SIM_SH64_NR_FP_REGS - 1;
      tdep->SSR_REGNUM = SIM_SH64_SSR_REGNUM;
      tdep->SPC_REGNUM = SIM_SH64_SPC_REGNUM;
      tdep->TR7_REGNUM = SIM_SH64_TR0_REGNUM + 7;
      tdep->FPP0_REGNUM = 173;
      tdep->FPP_LAST_REGNUM = 204;
      tdep->DR0_REGNUM = 141;
      tdep->DR_LAST_REGNUM = 172;
      tdep->FV0_REGNUM = 205;
      tdep->FV_LAST_REGNUM = 220;
      tdep->R0_C_REGNUM = 221;
      tdep->R_LAST_C_REGNUM = 236;
      tdep->PC_C_REGNUM = 237; 
      tdep->GBR_C_REGNUM = 238;
      tdep->MACH_C_REGNUM = 239;
      tdep->MACL_C_REGNUM = 240;
      tdep->PR_C_REGNUM = 241;
      tdep->T_C_REGNUM = 242;
      tdep->FPSCR_C_REGNUM = 243;
      tdep->FPUL_C_REGNUM = 244;
      tdep->FP0_C_REGNUM = 245;
      tdep->FP_LAST_C_REGNUM = 260;
      tdep->DR0_C_REGNUM = 261;
      tdep->DR_LAST_C_REGNUM = 268;
      tdep->FV0_C_REGNUM = 269;
      tdep->FV_LAST_C_REGNUM = 272;
      tdep->ARG0_REGNUM = 2;
      tdep->ARGLAST_REGNUM = 9;
      tdep->RETURN_REGNUM = 2;
      tdep->FLOAT_ARGLAST_REGNUM = 11;

      set_gdbarch_num_pseudo_regs (gdbarch, NUM_PSEUDO_REGS_SH_MEDIA + NUM_PSEUDO_REGS_SH_COMPACT);
      set_gdbarch_fp0_regnum (gdbarch, SIM_SH64_FR0_REGNUM);
      set_gdbarch_pc_regnum (gdbarch, 64);

      /* Determine the ABI */
      if (bfd_get_arch_size (info.abfd) == 64)
	{
	  /* If the ABI is the 64-bit one, it can only be sh-media. */
	  tdep->sh_abi = SH_ABI_64;
	  set_gdbarch_ptr_bit (gdbarch, 8 * TARGET_CHAR_BIT);
	  set_gdbarch_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
	}
      else
	{
	  /* If the ABI is the 32-bit one it could be either media or
             compact. */
	  tdep->sh_abi = SH_ABI_32;
	  set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
	  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
	}

      /* the number of real registers is the same whether we are in 
	 ISA16(compact) or ISA32(media). */
      set_gdbarch_num_regs (gdbarch, SIM_SH64_NR_REGS);
      set_gdbarch_deprecated_register_size (gdbarch, 8); /*????*/
      set_gdbarch_deprecated_register_bytes (gdbarch,
					     ((SIM_SH64_NR_FP_REGS + 1) * 4)
					     + (SIM_SH64_NR_REGS - SIM_SH64_NR_FP_REGS -1) * 8);

      set_gdbarch_register_name (gdbarch, sh_sh64_register_name);
      sh_show_regs = sh64_show_regs;
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sh_sh64_register_virtual_type);
      set_gdbarch_deprecated_store_return_value (gdbarch, sh64_store_return_value);
      skip_prologue_hard_way = sh64_skip_prologue_hard_way;
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_sh64_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_sh64_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_sh64_register_byte);
      /* This seems awfully wrong!*/
      /*set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);*/
      /* should include the size of the pseudo regs. */
      set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4 * 4);
      /* Or should that go in the virtual_size? */
      /*set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);*/
      set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4 * 4);
      set_gdbarch_pseudo_register_read (gdbarch, sh64_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, sh64_pseudo_register_write);

      set_gdbarch_deprecated_do_registers_info (gdbarch, sh64_do_registers_info);
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh64_nofp_frame_init_saved_regs);
      set_gdbarch_breakpoint_from_pc (gdbarch, sh_sh64_breakpoint_from_pc);
      set_gdbarch_deprecated_call_dummy_words (gdbarch, sh64_call_dummy_words);
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (sh64_call_dummy_words));

      set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sh64_init_extra_frame_info);
      set_gdbarch_deprecated_frame_chain (gdbarch, sh64_frame_chain);
      set_gdbarch_deprecated_get_saved_register (gdbarch, sh64_get_saved_register);
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh64_extract_return_value);
      set_gdbarch_deprecated_push_arguments (gdbarch, sh64_push_arguments);
      set_gdbarch_deprecated_push_return_address (gdbarch, sh64_push_return_address);
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sh64_store_struct_return);
      set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
      set_gdbarch_use_struct_convention (gdbarch, sh64_use_struct_convention);
      set_gdbarch_deprecated_pop_frame (gdbarch, sh64_pop_frame);
      set_gdbarch_elf_make_msymbol_special (gdbarch,
                                            sh64_elf_make_msymbol_special);
      break;
a2349 1
      sh_show_regs = sh_generic_show_regs;
@


1.135
log
@2003-08-01  Michael Snyder  <msnyder@@redhat.com>

	* sh-tdep.c (sh_frame_align): New gdbarch method.
	(sh_gdbarch_init): Set up frame_align method.
@
text
@d2037 1
a2037 1
/* Function: push_arguments
d2045 4
d2062 5
d2090 57
a2146 4
sh_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		    struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		    struct value **args, CORE_ADDR sp, int struct_return,
		    CORE_ADDR struct_addr)
d2148 60
d2226 3
a2228 1
    regcache_cooked_write_unsigned (regcache, STRUCT_RETURN_REGNUM, struct_addr);
d4501 1
a4501 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4514 1
a4514 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4531 1
a4531 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4536 2
d4539 2
a4540 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4551 1
a4551 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4578 1
a4578 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4597 1
a4597 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4602 2
d4618 1
a4618 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4651 1
a4651 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
d4662 2
@


1.134
log
@	* sh-tdep.c (sh_gdbarch_init): Fetch_registers for the sh3-dsp
	should go thru sh_dsp_register_sim_regno, else the dsp regs
	will not get the right values.

	* sh-tdep.c (sh_sh4_register_convert_to_virtual): Substitute call to
	deprecated_store_floating by call to store_typed_floating.
	(sh_sh4_register_convert_to_raw): Substitute call to
	deprecated_extract_floating by call to extract_typed_floating.

	* sh-tdep.c (sh_gdbarch_init): Set double to 4 byte on sh2e and sh3e.

	* sh-tdep.c: Substitute calls to REGISTER_RAW_SIZE by calls to
	register_size and calls to REGISTER_VIRTUAL_TYPE by calls to
	gdbarch_register_type in 32 bit code throughout.  Avoid current_gdbarch
	as possible.
	(do_pseudo_register): Remove.
	(sh_push_dummy_code): New function.
	(sh64_store_struct_return): Rename from sh_store_struct_return.
	Only called for sh64 now.
	(sh_extract_struct_value_address): Regcache'ify.
	(sh_push_dummy_call): Rename from sh_push_arguments.  Regcache'ify
	and accomodate new tasks.
	(sh64_push_return_address): Rename from sh_push_return_address.
	Only called for sh64 now.
	(sh_default_extract_return_value): Rename from sh_extract_return_value.
	Regcache'ify.
	(sh3e_sh4_extract_return_value): Regcache'ify.
	(sh_default_store_return_value): Ditto.
	(sh3e_sh4_store_return_value): Ditto.
	(sh_default_register_byte): Remove.
	(sh_sh4_register_byte): Remove.
	(sh_default_register_raw_size): Remove.
	(sh_sh4_register_raw_size): Remove.
	(sh_register_virtual_size): Remove.
	(sh_sh3e_register_virtual_type): Remove.
	(sh_sh3e_register_type): New function.
	(sh_sh4_register_virtual_type): Remove.
	(sh_sh4_register_type): New function.
	(sh_default_register_virtual_type): Remove.
	(sh_default_register_type): New function.
	(do_fv_register_info): Add parameters to accomodate call from
	sh_print_registers_info.
	(do_dr_register_info): Ditto.
	(sh_print_pseudo_register): Rename from sh_do_pseudo_register.
	Add parameters to accomodate call from sh_print_registers_info.
	(sh_do_fp_register): Ditto.
	(sh64_do_pseudo_register): Call do_dr_register_info,
	do_fv_register_info and sh_do_fp_register with default parameters.
	(sh_do_register): Add parameters to accomodate call from
	sh_print_registers_info.
	(sh_print_register): Ditto.
	(sh_print_registers_info): Rename from sh_do_registers_info.
	Add parameters to be used as gdbarch_print_registers_info
	implementation.  Accomodate removed do_pseudo_register function
	pointer.
	(sh_compact_do_registers_info): Accomodate removed do_pseudo_register
	function pointer. Call sh_print_register with default parameters.
	(sh64_do_registers_info): Call sh_print_registers_info instead of
	sh_do_registers_info.
	(sh_gdbarch_init): Rearrange to cleanup and to allow easier
	detection of deprecated vs. non-deprecated functionality.
	Rename sh_call_dummy_words to sh64_call_dummy_words.  Remove
	function pointer assignments by direct function calls.
@
text
@d2031 6
d2099 1
a2099 1
  sp = sp & ~3;
d4365 1
@


1.133
log
@2003-07-09  Michael Snyder  <msnyder@@redhat.com>

	* sh-tdep.c (sh_dsp_register_sim_regno): Off-by-one error.
@
text
@a55 1
void (*do_pseudo_register) (int);
d347 16
d946 1
a946 1
sh_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
d1052 1
a1052 1
				      REGISTER_RAW_SIZE (regnum));
d1937 1
a1937 1
sh_extract_struct_value_address (char *regbuf)
d1939 4
a1942 1
  return (extract_unsigned_integer ((regbuf), REGISTER_RAW_SIZE (0)));
d2075 5
a2079 2
sh_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
	  	   int struct_return, CORE_ADDR struct_addr)
d2090 1
a2090 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d2098 1
a2098 1
    write_register (STRUCT_RETURN_REGNUM, struct_addr);
d2147 3
a2149 2
	      regval = extract_unsigned_integer (val, REGISTER_RAW_SIZE (argreg));
	      write_register (argreg++, regval);
d2154 2
a2155 2
	  len -= REGISTER_RAW_SIZE (argreg);
	  val += REGISTER_RAW_SIZE (argreg);
d2158 7
d2363 1
a2363 1
sh_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
d2398 2
a2399 1
sh_extract_return_value (struct type *type, char *regbuf, char *valbuf)
d2407 4
a2410 5
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = REGISTER_BYTE (return_register) + 4 - len;
      else
	offset = REGISTER_BYTE (return_register);
      memcpy (valbuf, regbuf + offset, len);
d2412 1
a2412 1
  else if (len <= 8)
d2414 3
a2416 5
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = REGISTER_BYTE (return_register) + 8 - len;
      else
	offset = REGISTER_BYTE (return_register);
      memcpy (valbuf, regbuf + offset, len);
d2423 2
a2424 1
sh3e_sh4_extract_return_value (struct type *type, char *regbuf, char *valbuf)
a2425 4
  int return_register;
  int offset;
  int len = TYPE_LENGTH (type);

a2426 5
    return_register = FP0_REGNUM;
  else
    return_register = R0_REGNUM;
  
  if (len == 8 && TYPE_CODE (type) == TYPE_CODE_FLT)
d2428 4
a2431 26
      DOUBLEST val;
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
				 (char *) regbuf + REGISTER_BYTE (return_register),
				 &val);
      else
	floatformat_to_doublest (&floatformat_ieee_double_big,
				 (char *) regbuf + REGISTER_BYTE (return_register),
				 &val);
      deprecated_store_floating (valbuf, len, val);
    }
  else if (len <= 4)
    {
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = REGISTER_BYTE (return_register) + 4 - len;
      else
	offset = REGISTER_BYTE (return_register);
      memcpy (valbuf, regbuf + offset, len);
    }
  else if (len <= 8)
    {
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	offset = REGISTER_BYTE (return_register) + 8 - len;
      else
	offset = REGISTER_BYTE (return_register);
      memcpy (valbuf, regbuf + offset, len);
d2434 1
a2434 1
    error ("bad size for return value");
d2497 2
a2498 1
sh_default_store_return_value (struct type *type, char *valbuf)
d2500 2
a2501 1
  char buf[32];	/* more than enough... */
d2503 1
a2503 1
  if (TYPE_LENGTH (type) < REGISTER_RAW_SIZE (R0_REGNUM))
d2505 2
a2506 9
      /* Add leading zeros to the value. */
      memset (buf, 0, REGISTER_RAW_SIZE (R0_REGNUM));
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	memcpy (buf + REGISTER_RAW_SIZE (R0_REGNUM) - TYPE_LENGTH (type),
		valbuf, TYPE_LENGTH (type));
      else
	memcpy (buf, valbuf, TYPE_LENGTH (type));
      deprecated_write_register_bytes (REGISTER_BYTE (R0_REGNUM), buf, 
				       REGISTER_RAW_SIZE (R0_REGNUM));
d2509 5
a2513 2
    deprecated_write_register_bytes (REGISTER_BYTE (R0_REGNUM), valbuf, 
				     TYPE_LENGTH (type));
d2517 2
a2518 1
sh3e_sh4_store_return_value (struct type *type, char *valbuf)
d2521 6
a2526 2
    deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM), 
				     valbuf, TYPE_LENGTH (type));
d2528 1
a2528 1
    sh_default_store_return_value (type, valbuf);
a3045 23
/* Index within `registers' of the first byte of the space for
   register N.  */
static int
sh_default_register_byte (int reg_nr)
{
  return (reg_nr * 4);
}

static int
sh_sh4_register_byte (int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (reg_nr >= tdep->DR0_REGNUM 
      && reg_nr <= tdep->DR_LAST_REGNUM)
    return (dr_reg_base_num (reg_nr) * 4);
  else if  (reg_nr >= tdep->FV0_REGNUM 
	    && reg_nr <= tdep->FV_LAST_REGNUM)
    return (fv_reg_base_num (reg_nr) * 4);
  else
    return (reg_nr * 4);
}

a3200 23
/* Number of bytes of storage in the actual machine representation for
   register REG_NR.  */
static int
sh_default_register_raw_size (int reg_nr)
{
  return 4;
}

static int
sh_sh4_register_raw_size (int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (reg_nr >= tdep->DR0_REGNUM 
      && reg_nr <= tdep->DR_LAST_REGNUM)
    return 8;
  else if  (reg_nr >= tdep->FV0_REGNUM 
	    && reg_nr <= tdep->FV_LAST_REGNUM)
    return 16;
  else
    return 4;
}

a3224 8
/* Number of bytes of storage in the program's representation
   for register N.  */
static int
sh_register_virtual_size (int reg_nr)
{
  return 4;
}

d3239 1
a3239 1
sh_sh3e_register_virtual_type (int reg_nr)
d3261 1
a3261 1
sh_sh4_register_virtual_type (int reg_nr)
d3263 1
a3263 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d3312 1
a3312 1
sh_default_register_virtual_type (int reg_nr)
d3354 1
a3354 1
      deprecated_store_floating (to, TYPE_LENGTH (type), val);
d3395 1
a3395 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
d3445 1
a3445 1
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3448 1
a3448 1
					  REGISTER_VIRTUAL_TYPE (reg_nr),
d3460 1
a3460 1
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3644 1
a3644 1
      sh_sh4_register_convert_to_raw (REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
d3651 1
a3651 1
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d3662 1
a3662 1
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d3835 2
a3836 1
do_fv_register_info (int fv_regnum)
d3839 2
a3840 2
  printf_filtered ("fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
		     fv_regnum - gdbarch_tdep (current_gdbarch)->FV0_REGNUM, 
d3875 2
a3876 1
do_dr_register_info (int dr_regnum)
d3880 2
a3881 2
  printf_filtered ("dr%d\t0x%08x%08x\n", 
		    dr_regnum - gdbarch_tdep (current_gdbarch)->DR0_REGNUM, 
d3937 2
a3938 1
sh_do_pseudo_register (int regnum)
d3940 1
a3940 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d3946 2
a3947 2
	   && regnum < tdep->DR_LAST_REGNUM)
    do_dr_register_info (regnum);
d3950 1
a3950 1
    do_fv_register_info (regnum);
d3954 1
a3954 1
sh_do_fp_register (int regnum)
d3962 1
a3962 1
  raw_buffer = (char *) alloca (REGISTER_RAW_SIZE (FP0_REGNUM));
d3965 1
a3965 1
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
d3972 2
a3973 2
  fputs_filtered (REGISTER_NAME (regnum), gdb_stdout);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), gdb_stdout);
d3977 1
a3977 1
    printf_filtered ("<invalid float>");
d3979 1
a3979 1
    printf_filtered ("%-10.9g", flt);
d3982 2
a3983 2
  printf_filtered ("\t(raw 0x");
  for (j = 0; j < REGISTER_RAW_SIZE (regnum); j++)
d3986 2
a3987 2
	: REGISTER_RAW_SIZE (regnum) - 1 - j;
      printf_filtered ("%02x", (unsigned char) raw_buffer[idx]);
d3989 2
a3990 2
  printf_filtered (")");
  printf_filtered ("\n");
d4006 1
a4006 1
    do_dr_register_info (regnum);
d4014 1
a4014 1
    do_fv_register_info (regnum);
d4030 1
a4030 1
    sh_do_fp_register (regnum); /* this should work also for pseudoregs */
d4039 1
a4039 1
sh_do_register (int regnum)
d4043 2
a4044 2
  fputs_filtered (REGISTER_NAME (regnum), gdb_stdout);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), gdb_stdout);
d4047 2
a4048 2
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
    printf_filtered ("*value not available*\n");
d4050 6
a4055 6
  val_print (REGISTER_VIRTUAL_TYPE (regnum), raw_buffer, 0, 0,
	     gdb_stdout, 'x', 1, 0, Val_pretty_default);
  printf_filtered ("\t");
  val_print (REGISTER_VIRTUAL_TYPE (regnum), raw_buffer, 0, 0,
	     gdb_stdout, 0, 1, 0, Val_pretty_default);
  printf_filtered ("\n");
d4059 1
a4059 1
sh_print_register (int regnum)
d4067 2
a4068 2
      if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
	sh_do_fp_register (regnum);	/* FP regs */
d4070 1
a4070 1
	sh_do_register (regnum);	/* All other regs */
d4074 6
a4079 1
    do_pseudo_register (regnum);
d4083 2
a4084 1
sh_do_registers_info (int regnum, int fpregs)
d4091 1
a4091 1
      sh_print_register (regnum);
d4108 1
a4108 1
	  if (TYPE_CODE (REGISTER_VIRTUAL_TYPE (regnum)) == TYPE_CODE_FLT)
d4113 1
a4113 1
		  sh_do_fp_register (regnum);	/* FP regs */
d4117 1
a4117 1
		regnum += (gdbarch_tdep (current_gdbarch)->FP_LAST_REGNUM - FP0_REGNUM);	/* skip FP regs */
d4121 1
a4121 1
	      sh_do_register (regnum);	/* All other regs */
d4129 4
a4132 1
	    do_pseudo_register (regnum);
d4150 1
a4150 1
      sh_print_register (regnum);
d4158 1
a4158 1
          do_pseudo_register (regnum);
d4168 2
a4169 1
   sh_do_registers_info (regnum, fpregs);
d4265 1
a4265 1
  static LONGEST sh_call_dummy_words[] = {0};
a4267 3
  gdbarch_register_name_ftype *sh_register_name;
  gdbarch_deprecated_store_return_value_ftype *sh_store_return_value;
  gdbarch_deprecated_register_virtual_type_ftype *sh_register_virtual_type;
d4318 2
a4319 4
  set_gdbarch_fp0_regnum (gdbarch, -1);
  set_gdbarch_num_pseudo_regs (gdbarch, 0);
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4);
d4321 4
d4326 1
d4331 3
a4333 3
  set_gdbarch_deprecated_register_size (gdbarch, 4);
  set_gdbarch_deprecated_register_bytes (gdbarch, SH_DEFAULT_NUM_REGS * 4);
  set_gdbarch_deprecated_do_registers_info (gdbarch, sh_do_registers_info);
d4335 18
a4355 5
  set_gdbarch_deprecated_extract_return_value (gdbarch, sh_extract_return_value);
  set_gdbarch_deprecated_push_arguments (gdbarch, sh_push_arguments);
  set_gdbarch_deprecated_store_struct_return (gdbarch, sh_store_struct_return);
  set_gdbarch_use_struct_convention (gdbarch, sh_use_struct_convention);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
d4357 2
a4358 4
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh);
  set_gdbarch_register_sim_regno (gdbarch, legacy_register_sim_regno);
  skip_prologue_hard_way = sh_skip_prologue_hard_way;
  do_pseudo_register = sh_do_pseudo_register;
d4363 2
a4364 1
      sh_register_name = sh_sh_register_name;
d4366 7
a4372 2
      sh_store_return_value = sh_default_store_return_value;
      sh_register_virtual_type = sh_default_register_virtual_type;
a4373 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4376 2
a4377 1
      sh_register_name = sh_sh_register_name;
d4379 7
a4385 2
      sh_store_return_value = sh_default_store_return_value;
      sh_register_virtual_type = sh_default_register_virtual_type;
a4386 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4389 5
a4393 1
      sh_register_name = sh_sh2e_register_name;
d4395 2
a4396 6
      sh_store_return_value = sh3e_sh4_store_return_value;
      sh_register_virtual_type = sh_sh3e_register_virtual_type;
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4398 4
d4405 2
d4409 2
a4410 1
      sh_register_name = sh_sh_dsp_register_name;
d4412 2
a4413 6
      sh_store_return_value = sh_default_store_return_value;
      sh_register_virtual_type = sh_default_register_virtual_type;
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4415 4
d4433 2
d4437 2
a4438 1
      sh_register_name = sh_sh3_register_name;
d4440 6
a4445 6
      sh_store_return_value = sh_default_store_return_value;
      sh_register_virtual_type = sh_default_register_virtual_type;
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4448 2
d4452 5
a4456 1
      sh_register_name = sh_sh3e_register_name;
d4458 2
a4459 7
      sh_store_return_value = sh3e_sh4_store_return_value;
      sh_register_virtual_type = sh_sh3e_register_virtual_type;
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d4461 4
d4470 2
d4474 2
a4475 1
      sh_register_name = sh_sh3_dsp_register_name;
d4477 7
a4483 6
      sh_store_return_value = sh_default_store_return_value;
      sh_register_virtual_type = sh_default_register_virtual_type;
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4500 2
d4504 2
a4505 1
      sh_register_name = sh_sh4_register_name;
d4507 2
a4508 4
      sh_store_return_value = sh3e_sh4_store_return_value;
      sh_register_virtual_type = sh_sh4_register_virtual_type;
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
a4509 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_sh4_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_sh4_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_sh4_register_byte);
a4510 2
      set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4 * 4);
      set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4 * 4);
d4513 4
d4526 2
d4589 1
a4589 1
      set_gdbarch_deprecated_register_bytes (gdbarch, 
d4593 1
a4593 1
      sh_register_name = sh_sh64_register_name;
d4595 2
a4596 2
      sh_register_virtual_type = sh_sh64_register_virtual_type;
      sh_store_return_value = sh64_store_return_value;
a4597 1
      do_pseudo_register = sh64_do_pseudo_register;
d4614 3
d4622 3
a4624 1
      /*set_gdbarch_deprecated_store_struct_return (gdbarch, sh64_store_struct_return);*/
d4632 2
a4633 1
      sh_register_name = sh_generic_register_name;
d4635 5
a4639 2
      sh_store_return_value = sh_default_store_return_value;
      sh_register_virtual_type = sh_default_register_virtual_type;
a4640 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
a4642 30

  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);

  set_gdbarch_register_name (gdbarch, sh_register_name);
  set_gdbarch_deprecated_register_virtual_type (gdbarch, sh_register_virtual_type);

  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_int_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);

  set_gdbarch_deprecated_call_dummy_words (gdbarch, sh_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (sh_call_dummy_words));

  set_gdbarch_deprecated_push_return_address (gdbarch, sh_push_return_address);

  set_gdbarch_deprecated_store_return_value (gdbarch, sh_store_return_value);
  set_gdbarch_skip_prologue (gdbarch, sh_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);

  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frameless_function_invocation (gdbarch, frameless_look_for_prologue);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sh_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sh_saved_pc_after_call);
  set_gdbarch_believe_pcc_promotion (gdbarch, 1);
@


1.132
log
@2003-06-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Update comments on registers, re-order.
	(deprecated_register_byte): Rename register_byte.
	(deprecated_register_raw_size): Rename register_raw_size.
	(deprecated_register_virtual_size): Rename register_virtual_size.
	(deprecated_register_virtual_type): Rename register_virtual_type.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c: Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d4288 1
a4288 1
  if (nr >= DSP_DSR_REGNUM && nr < DSP_Y1_REGNUM)
@


1.131
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_CONVERTIBLE): Deprecate
	REGISTER_CONVERTIBLE.
	(DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL): Same.
	(DEPRECATED_REGISTER_CONVERT_TO_RAW): Same, make "from" constant.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (deprecated_register_convertible_not): Rename
	generic_register_convertible_not.
	* arch-utils.c (deprecated_register_convertible_not): Rename
	generic_register_convertible.
	(legacy_convert_register_p, legacy_register_to_value): Update.
	* sh-tdep.c (sh64_push_arguments): Update.
	* m68klinux-tdep.c (m68k_linux_extract_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_EXTRACT_RETURN_VALUE): Update.
	* m68klinux-tdep.c (m68k_linux_store_return_value): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Update.
	* arch-utils.c (legacy_value_to_register): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	(rs6000_register_convert_to_raw): Make parameter "from" const.
	* mips-tdep.c (mips_gdbarch_init): Update.
	(mips_register_convert_to_raw): Make  parameter"virt_buf" const.
	* infcmd.c (default_print_registers_info): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_register_convert_to_raw): Make parameter "from" const.
	* i386-tdep.c (i386_gdbarch_init): Update.
	(i386_register_convert_to_raw): Update.
@
text
@d4311 1
a4311 1
  gdbarch_register_virtual_type_ftype *sh_register_virtual_type;
d4398 3
a4400 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4408 3
a4410 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4418 3
a4420 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4432 3
a4434 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4457 3
a4459 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4469 3
a4471 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4486 3
a4488 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4514 3
a4516 3
      set_gdbarch_register_raw_size (gdbarch, sh_sh4_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_sh4_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_sh4_register_byte);
d4602 3
a4604 3
      set_gdbarch_register_raw_size (gdbarch, sh_sh64_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_sh64_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_sh64_register_byte);
d4636 3
a4638 3
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
d4646 1
a4646 1
  set_gdbarch_register_virtual_type (gdbarch, sh_register_virtual_type);
@


1.130
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d2300 3
a2302 2
			REGISTER_CONVERT_TO_VIRTUAL (regnum,
						     type, val, valbuf_tmp);
@


1.129
log
@2003-06-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_NUM_ARGS): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arch-utils.h (frame_num_args_unknown): Delete both declarations.
	* arch-utils.c (frame_num_args_unknown): Delete function.
	* stack.c (print_args_stub): Use FRAME_NUM_ARGS_P.
	(frame_info): Use FRAME_NUM_ARGS_P.
	* arm-tdep.c (arm_frame_num_args): Delete function.
	(arm_gdbarch_init): Do not set frame_num_args.
	* config/pa/tm-hppa64.h (FRAME_NUM_ARGS): Delete.
	* hppa-tdep.c (hppa_frame_num_args): Delete function.
	(hppa_gdbarch_init): Do not set frame_num_args.
	* config/sparc/tm-sparc.h (FRAME_NUM_ARGS): Delete.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	frame_num_args to default frame_num_args_unknown.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d365 1
a365 1
void
d1242 1
a1242 1
int
d1816 1
a1816 1
void
d3038 2
a3039 1
void sh_show_regs_command (char *args, int from_tty)
d3413 1
a3413 1
void
d3455 1
a3455 1
void
d3480 1
a3480 1
void
d3683 1
a3683 1
void
d3719 1
a3719 1
void
d4127 1
a4127 1
void
d4179 1
a4179 1
void
d4205 1
a4205 1
void
d4687 2
@


1.128
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* inferior.h (deprecated_write_sp): Replace
	generic_target_write_sp.
	* regcache.c (deprecated_write_sp): Replace
	generic_target_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Update.
@
text
@a4667 1
  set_gdbarch_frame_num_args (gdbarch, frame_num_args_unknown);
@


1.127
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_SP): Add predicate, delete default.
	* gdbarch.h, gdbarch.c: Regenerate.
	* mn10300-tdep.c: Include "gdb_assert.h".
	(mn10300_read_fp): New function.
	(mn10300_gdbarch_init): Set deprecated_target_read_fp to
	mn10300_read_fp.  Do not set read_sp to generic_target_read_sp.
	* ia64-tdep.c: Include "gdb_assert.h".
	(ia64_read_fp): New function.
	(ia64_gdbarch_init): Set deprecated_target_read_fp to
	ia64_read_sp.  Do not set read_sp to generic_target_read_sp.
	* regcache.c (generic_target_read_sp): Delete function.
	(read_sp): Try TARGET_READ_SP and SP_REGNUM for the SP register.
	* inferior.h (generic_target_read_sp): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_sp to
	generic_target_read_sp.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* Makefile.in (mn10300-tdep.o, ia64-tdep.o): Update dependencies.
@
text
@d4641 1
a4641 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
@


1.126
log
@2003-06-07  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (TARGET_READ_PC): Add predicate, remove default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c: Update comments on read_pc et.al.
	(generic_target_read_pc): Delete function.
	(read_pc_pid): Try TARGET_READ_PC and PC_REGNUM for a PC register.
	* inferior.h (generic_target_read_pc): Delete declaration.
	* frv-tdep.c (frv_gdbarch_init): Do not set read_pc to
	generic_target_read_pc.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
@
text
@a4640 1
  set_gdbarch_read_sp (gdbarch, generic_target_read_sp);
@


1.125
log
@2003-06-01  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (extract_address): Delete declaration.
	* findvar.c (extract_address): Delete function.
	* xstormy16-tdep.c (xstormy16_extract_return_value): Replace
	extract_address with the inline equivalent,
	extract_unsigned_integer.
	(xstormy16_extract_struct_value_address): Ditto.
	(xstormy16_pointer_to_address): Ditto.
	* vax-tdep.c (vax_extract_struct_value_address): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	(v850_extract_return_value): Ditto.
	(v850_extract_struct_value_address): Ditto.
	* sparcnbsd-tdep.c (sparcnbsd_get_longjmp_target_32): Ditto.
	(sparcnbsd_get_longjmp_target_64): Ditto.
	* sparc-tdep.c (sparc_frame_saved_pc): Ditto.
	(get_longjmp_target): Ditto.
	* sh-tdep.c (sh_extract_struct_value_address): Ditto.
	(sh64_extract_struct_value_address): Ditto.
	(sh_push_arguments): Ditto.
	(sh64_push_arguments): Ditto.
	* remote-vxsparc.c (vx_read_register): Ditto.
	* ppc-linux-tdep.c (ppc_linux_skip_trampoline_code): Ditto.
	* ns32k-tdep.c (ns32k_extract_struct_value_address): Ditto.
	* mn10300-tdep.c (mn10300_extract_struct_value_address): Ditto.
	* mipsv4-nat.c (get_longjmp_target): Ditto.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Ditto.
	* mips-nat.c (get_longjmp_target): Ditto.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target): Ditto.
	* mcore-tdep.c (mcore_extract_struct_value_address): Ditto.
	* m68k-tdep.c (m68k_get_longjmp_target): Ditto.
	* m68hc11-tdep.c (m68hc11_extract_struct_value_address): Ditto.
	* irix5-nat.c (get_longjmp_target): Ditto.
	* irix4-nat.c (get_longjmp_target): Ditto.
	* ia64-tdep.c (generic_elf_find_global_pointer): Ditto.
	(ia64_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_store_registers): Ditto.
	* h8300-tdep.c (h8300_push_arguments): Ditto.
	(h8300_store_return_value): Ditto.
	(h8300_extract_struct_value_address): Ditto.
	* frv-tdep.c (frv_extract_struct_value_address): Ditto.
	(frv_push_arguments): Ditto.
	* avr-tdep.c (avr_pointer_to_address): Ditto.
	(avr_push_arguments): Ditto.
	* arm-tdep.c (arm_push_dummy_call): Ditto.
	(arm_get_longjmp_target): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_extract_struct_value_address): Ditto.
	(alpha_get_longjmp_target): Ditto.
@
text
@a4639 1
  set_gdbarch_read_pc (gdbarch, generic_target_read_pc);
@


1.124
log
@2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTES): Rename REGISTER_BYTES.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_extract_return_value): Delete reference.
	* TODO (REGISTER_BYTES): Delete reference.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	(ns32k_gdbarch_init_32382): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-linux-tdep.c (i386_linux_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* sparc-tdep.c (sparc_pop_frame): Update.
	* rs6000-tdep.c (rs6000_pop_frame): Update.
	* remote.c (init_remote_state): Update.
	(remote_prepare_to_store): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	(sds_prepare_to_store): Update.
	* remote-array.c: Update.
	* regcache.c (init_legacy_regcache_descr): Update.
	(init_regcache_descr): Update.
	* mips-tdep.c (mips_eabi_extract_return_value): Update.
	(mips_o64_extract_return_value): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* irix4-nat.c (fetch_core_registers): Update.
	* i386-tdep.h: Update.
	* hppa-tdep.c (pa_do_registers_info): Update.
	(pa_do_strcat_registers_info): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/sparc/nm-sun4sol2.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-sun4os4.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/nm-nbsd.h (CHILD_PREPARE_TO_STORE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/s390/tm-s390.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-mips.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix6.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/mips/tm-irix5.h (DEPRECATED_REGISTER_BYTES): Update.
	* config/m68k/tm-sun3.h (DEPRECATED_REGISTER_BYTES): Update.
	(REGISTER_BYTES_OK): Update.
	* config/m68k/nm-sun3.h (CHILD_PREPARE_TO_STORE): Update.
	* config/ia64/tm-ia64.h (DEPRECATED_REGISTER_BYTES): Update.

Index: doc/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	REGISTER_BYTES with DEPRECATED_REGISTER_BYTES.  Fix typo,
	DEPRECATED_REGISTER_SIZE instead of REGISTER_BYTE.

Index: mi/ChangeLog
2003-05-16  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_setup_architecture_data):
@
text
@d1924 1
a1924 1
  return (extract_address ((regbuf), REGISTER_RAW_SIZE (0)));
d1930 2
a1931 2
  return (extract_address ((regbuf + REGISTER_BYTE (STRUCT_RETURN_REGNUM)), 
			   REGISTER_RAW_SIZE (STRUCT_RETURN_REGNUM)));
d2126 1
a2126 1
	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
d2241 1
a2241 1
		  regval = extract_address (val, argreg_size);
@


1.123
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d4371 1
a4371 1
  set_gdbarch_register_bytes (gdbarch, SH_DEFAULT_NUM_REGS * 4);
d4590 3
a4592 3
      set_gdbarch_register_bytes (gdbarch, 
				  ((SIM_SH64_NR_FP_REGS + 1) * 4)
				  + (SIM_SH64_NR_REGS - SIM_SH64_NR_FP_REGS -1) * 8);
@


1.122
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@d1876 2
a1877 2
		store_address (raw_buffer, REGISTER_RAW_SIZE (regnum),
			       get_frame_saved_regs (frame)[regnum]);
@


1.122.4.1
log
@Snap const char * mess.
@
text
@d1876 2
a1877 2
		store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
					get_frame_saved_regs (frame)[regnum]);
@


1.121
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Delete references to MAX_REGISTER_RAW_SIZE.
	* gdbarch.h: Re-generate.
	* defs.h (MAX_REGISTER_RAW_SIZE): Delete macro.
	(legacy_max_register_raw_size): Delete declaration.
	* regcache.c (legacy_max_register_raw_size): Delete function.
	* valops.c: Replace MAX_REGISTER_RAW_SIZE with MAX_REGISTER_SIZE.
	* target.c, stack.c, sparc-tdep.c, sh-tdep.c: Update.
	* rs6000-tdep.c, rs6000-nat.c, remote.c, remote-sim.c: Update.
	* remote-rdp.c, remote-array.c, regcache.c: Update.
	* ppc-linux-nat.c, monitor.c, mn10300-tdep.c: Update.
	* mips-tdep.c, mips-linux-tdep.c, m68klinux-nat.c: Update.
	* infptrace.c, ia64-tdep.c, i386-tdep.c, frame.c: Update.
	* findvar.c, dwarf2cfi.c: Update.

Index: tui/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* tuiRegs.c: Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.

Index: mi/ChangeLog
2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (register_changed_p): Use MAX_REGISTER_SIZE instead of
	MAX_REGISTER_RAW_SIZE.
@
text
@d4090 1
a4090 1
  char *raw_buffer = alloca (max_register_size (current_gdbarch));
@


1.120
log
@2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_SIZE): Rename REGISTER_SIZE.
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Rename
	SIZEOF_CALL_DUMMY_WORDS.
	(DEPRECATED_CALL_DUMMY_WORDS): Rename CALL_DUMMY_WORDS.
	(DEPRECATED_FIX_CALL_DUMMY): Rename FIX_CALL_DUMMY.
	(DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET): Rename
	CALL_DUMMY_BREAKPOINT_OFFSET.
	(DEPRECATED_CALL_DUMMY_START_OFFSET): Rename
	CALL_DUMMY_START_OFFSET.
	(DEPRECATED_CALL_DUMMY_LENGTH): Rename CALL_DUMMY_LENGTH.
	* gdbarch.h, gdbarch.c: Re-generate.
	* alpha-tdep.c, alphafbsd-tdep.c, arm-linux-tdep.c: Update.
	* arm-tdep.c, avr-tdep.c, breakpoint.c, cris-tdep.c: Update.
	* dummy-frame.c, dummy-frame.h, frv-tdep.c, gdbarch.c: Update.
	* gdbarch.h, gdbarch.sh, h8300-tdep.c, hppa-tdep.c: Update.
	* i386-tdep.c, ia64-tdep.c, infcall.c, inferior.h: Update.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Update.
	* mips-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* rs6000-tdep.c, s390-tdep.c, sh-tdep.c, sol-thread.c: Update.
	* sparc-tdep.c, target.c, v850-tdep.c, valops.c: Update.
	* vax-tdep.c, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/ia64/tm-ia64.h, config/m68k/tm-vx68.h: Update.
	* config/mips/tm-mips.h, config/pa/nm-hppah.h: Update.
	* config/pa/tm-hppa.h, config/pa/tm-hppa64.h: Update.
	* config/s390/tm-s390.h, config/sparc/tm-sp64.h: Update.
	* config/sparc/tm-sparc.h: Update.

Index: doc/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Make
	CALL_DUMMY_WORDS, SIZEOF_CALL_DUMMY_WORDS, CALL_DUMMY_LENGTH,
	FIX_CALL_DUMMY, CALL_DUMMY_BREAKPOINT_OFFSET and
	CALL_DUMMY_BREAKPOINT_OFFSET deprecated.

Index: mi/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Replace
	REGISTER_SIZE with DEPRECATED_REGISTER_SIZE.

Index: testsuite/ChangeLog
2003-05-03  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/watchpoint.exp: Rename CALL_DUMMY_BREAKPOINT_OFFSET to
	DEPRECATED_CALL_DUMMY_BREAKPOINT_OFFSET in comments.
@
text
@d3484 1
a3484 1
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d3523 1
a3523 1
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d3687 1
a3687 1
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
d3724 1
a3724 1
  char *temp_buffer = (char*) alloca (MAX_REGISTER_RAW_SIZE);
@


1.119
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d1773 1
a1773 1
      get_frame_extra_info (fi)->f_offset = -(CALL_DUMMY_LENGTH + 4);
d1804 1
a1804 1
      get_frame_extra_info (fi)->f_offset = -(CALL_DUMMY_LENGTH + 4);
d4370 1
a4370 1
  set_gdbarch_register_size (gdbarch, 4);
d4589 1
a4589 1
      set_gdbarch_register_size (gdbarch, 8); /*????*/
d4655 2
a4656 2
  set_gdbarch_call_dummy_words (gdbarch, sh_call_dummy_words);
  set_gdbarch_sizeof_call_dummy_words (gdbarch, sizeof (sh_call_dummy_words));
@


1.118
log
@2003-04-21  Andrew Cagney  <cagney@@redhat.com>

	* infcall.c: New file.
	* infcall.h: New file.
	* valarith.c: Include "infcall.h".
	* scm-lang.c, objc-lang.cm, hppa-tdep.c, gcore.c: Ditto.
	* eval.c, ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (valarith.o, scm-lang.o): Update dependencies.
	(objc-lang.o, hppa-tdep.o, gcore.o): Update dependencies.
	(eval.o, ada-valprint.o, ada-lang.o): Update dependencies.
	(SFILES): Add "infcall.c"
	(COMMON_OBS): Add "infcall.o".
	(infcall.o): Specify dependencies.
	* value.h (call_function_by_hand): Delete declaration.
	* inferior.h (run_stack_dummy): Delete declaration.
	* infcmd.c (breakpoint_auto_delete_contents): Move to "infcall.c".
	(run_stack_dummy): Move to "infcall.c", merged into
	call_function_by_hand.
	* valops.c (call_function_by_hand): Moved to "infcall.c".
	(find_function_addr, value_arg_coerce): Ditto.
	(unwindonsignal_p, coerce_float_to_double): Ditto.
	(_initialize_valops): Move "set/show coerce-float-to-double", and
	"set/show unwindonsignal" commands to "infcall.c".
	* v850-tdep.c, target.h: Update comments.
	* sparc-tdep.c (sparc_fix_call_dummy): Update comments.
	* sh-tdep.c (sh_init_extra_frame_info): Update comments.
	(sh64_init_extra_frame_info): Update comments.
	* mn10300-tdep.c: Update comments.
	* mcore-tdep.c (mcore_init_extra_frame_info): Update comments.
	* config/sparc/tm-sparc.h: Update comments.
	* breakpoint.h: Update comments.
	* avr-tdep.c (avr_init_extra_frame_info): Update comments.
	* arm-tdep.c: Update comment.
@
text
@d1006 1
a1006 1
	size = REGISTER_RAW_SIZE (translate_insn_rn (FP_REGNUM, media_mode));
d1175 1
a1175 1
	  if (rn == FP_REGNUM)
d1188 1
a1188 1
      get_frame_saved_regs (fi)[SP_REGNUM] = read_memory_integer (get_frame_saved_regs (fi)[FP_REGNUM], 4);
d1195 1
a1195 1
  get_frame_extra_info (fi)->f_offset = depth - where[FP_REGNUM] - 4;
d1480 1
a1480 1
  fp_regnum = translate_insn_rn (FP_REGNUM, media_mode);
d1605 2
a1606 2
      /* Again, saved_registers contains only space for the real registers,
	 so we store in FP_REGNUM position. */
d1727 1
a1727 1
	  if (rn == FP_REGNUM)
d1741 1
a1741 1
	read_memory_integer (get_frame_saved_regs (fi)[FP_REGNUM], 4);
d1748 1
a1748 1
  get_frame_extra_info (fi)->f_offset = depth - where[FP_REGNUM] - 4;
d1888 1
a1888 1
		      && (live_regnum == FP_REGNUM
d1996 1
a1996 1
		&& (regnum == FP_REGNUM
d4368 1
a4368 1
  set_gdbarch_fp_regnum (gdbarch, 14);
a4641 1
  set_gdbarch_read_fp (gdbarch, generic_target_read_fp);
@


1.117
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_SAVED_PC_AFTER_CALL): Deprecate
	SAVED_PC_AFTER_CALL.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	(ia64_saved_pc_after_call): Update declaration.
	* i386ly-tdep.c (i386lynx_init_abi): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	* infrun.c (step_over_function): Update.
	* i386-linux-tdep.c (skip_hurd_resolver): Update.
	* i386-interix-tdep.c (i386_interix_back_one_frame): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_SAVED_PC_AFTER_CALL): Update.
	* arm-linux-tdep.c (skip_hurd_resolver): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	* x86-64-tdep.h (x86_64_linux_saved_pc_after_call): Update
	declaration.
@
text
@d1766 2
a1767 2
      /* We need to setup fi->frame here because run_stack_dummy gets it wrong
         by assuming it's always FP.  */
d1798 2
a1799 2
      /* We need to setup fi->frame here because run_stack_dummy gets it wrong
         by assuming it's always FP.  */
@


1.117.2.1
log
@Merge from mainline.
@
text
@d1006 1
a1006 1
	size = REGISTER_RAW_SIZE (translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode));
d1175 1
a1175 1
	  if (rn == DEPRECATED_FP_REGNUM)
d1188 1
a1188 1
      get_frame_saved_regs (fi)[SP_REGNUM] = read_memory_integer (get_frame_saved_regs (fi)[DEPRECATED_FP_REGNUM], 4);
d1195 1
a1195 1
  get_frame_extra_info (fi)->f_offset = depth - where[DEPRECATED_FP_REGNUM] - 4;
d1480 1
a1480 1
  fp_regnum = translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode);
d1605 2
a1606 2
      /* Again, saved_registers contains only space for the real
	 registers, so we store in DEPRECATED_FP_REGNUM position.  */
d1727 1
a1727 1
	  if (rn == DEPRECATED_FP_REGNUM)
d1741 1
a1741 1
	read_memory_integer (get_frame_saved_regs (fi)[DEPRECATED_FP_REGNUM], 4);
d1748 1
a1748 1
  get_frame_extra_info (fi)->f_offset = depth - where[DEPRECATED_FP_REGNUM] - 4;
d1766 2
a1767 2
      /* We need to setup fi->frame here because call_function_by_hand
         gets it wrong by assuming it's always FP.  */
d1798 2
a1799 2
      /* We need to setup fi->frame here because call_function_by_hand
         gets it wrong by assuming it's always FP.  */
d1888 1
a1888 1
		      && (live_regnum == DEPRECATED_FP_REGNUM
d1996 1
a1996 1
		&& (regnum == DEPRECATED_FP_REGNUM
d4368 1
a4368 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 14);
d4642 1
@


1.117.2.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1773 1
a1773 1
      get_frame_extra_info (fi)->f_offset = -(DEPRECATED_CALL_DUMMY_LENGTH + 4);
d1804 1
a1804 1
      get_frame_extra_info (fi)->f_offset = -(DEPRECATED_CALL_DUMMY_LENGTH + 4);
d1876 2
a1877 2
		store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
					get_frame_saved_regs (frame)[regnum]);
d3484 1
a3484 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3523 1
a3523 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3687 1
a3687 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3724 1
a3724 1
  char temp_buffer[MAX_REGISTER_SIZE];
d4090 1
a4090 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4370 2
a4371 2
  set_gdbarch_deprecated_register_size (gdbarch, 4);
  set_gdbarch_deprecated_register_bytes (gdbarch, SH_DEFAULT_NUM_REGS * 4);
d4589 4
a4592 4
      set_gdbarch_deprecated_register_size (gdbarch, 8); /*????*/
      set_gdbarch_deprecated_register_bytes (gdbarch, 
					     ((SIM_SH64_NR_FP_REGS + 1) * 4)
					     + (SIM_SH64_NR_REGS - SIM_SH64_NR_FP_REGS -1) * 8);
d4655 2
a4656 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, sh_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (sh_call_dummy_words));
@


1.116
log
@2003-04-09  Andrew Cagney  <cagney@@redhat.com>

	* doublest.h: Update copyright.
	(deprecated_store_floating, deprecated_extract_floating): Rename
	store_floating and extract_floating.  Update comments.
	* doublest.c: Update copyright.
	(extract_floating_by_length): Replace extract_floating.
	(store_floating_by_length): Replace store_floating.
	(deprecated_extract_floating): New function.
	(deprecated_store_floating): New function.
	(extract_typed_floating): Call extract_floating_by_length.
	(store_typed_floating): Call store_floating_by_length.
	* x86-64-tdep.c (x86_64_store_return_value): Update.
	* sh-tdep.c (sh3e_sh4_extract_return_value): Update.
	(sh64_extract_return_value): Update.
	(sh_sh4_register_convert_to_virtual): Update.
	(sh_sh64_register_convert_to_virtual): Update.
	(sh_sh4_register_convert_to_raw): Update.
	(sh_sh64_register_convert_to_raw): Update.
	* rs6000-tdep.c (rs6000_register_convert_to_virtual): Update.
	(rs6000_register_convert_to_raw): Update.
	* ia64-tdep.c (ia64_register_convert_to_virtual): Update.
	(ia64_register_convert_to_raw): Update.
	* config/i386/tm-symmetry.h (REGISTER_CONVERT_TO_RAW): Update.
	(REGISTER_CONVERT_TO_VIRTUAL): Update.
	* arm-linux-tdep.c (arm_linux_push_arguments): Update.
	* alpha-tdep.c (alpha_register_convert_to_virtual): Update.
	(alpha_register_convert_to_raw): Update.
@
text
@d4670 1
a4670 1
  set_gdbarch_saved_pc_after_call (gdbarch, sh_saved_pc_after_call);
@


1.115
log
@2003-04-05  Andrew Cagney  <cagney@@redhat.com>

	* frame.c (frame_func_unwind, get_frame_func): New functions.
	* frame.h (get_frame_func, frame_func_unwind): Declare.
	(struct frame_info): Add field "prev_func" for caching the
	previous frame's function address.
	* arm-tdep.c (arm_frameless_function_invocation): Combine
	get_pc_function_start and get_frame_pc into get_frame_func.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	* s390-tdep.c (s390_function_start): Ditto.
	* rs6000-tdep.c (rs6000_pop_frame): Ditto.
	(rs6000_frameless_function_invocation): Ditto.
	(rs6000_frame_saved_pc): Ditto.
	* m68k-tdep.c (m68k_frame_init_saved_regs): Ditto.
	* ia64-tdep.c (ia64_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frameless_signal_p): Ditto.
	(i386_frame_init_saved_regs): Ditto.
	* hppa-tdep.c (hppa_frame_find_saved_regs): Ditto.
	* d10v-tdep.c (d10v_frame_unwind_cache): Combine
	get_pc_function_start and frame_pc_unwind into frame_func_unwind.
	* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
	* blockframe.c (frameless_look_for_prologue): Ditto.
@
text
@d2417 1
a2417 1
      store_floating (valbuf, len, val);
d2470 1
a2470 1
	  store_floating (valbuf, len, val);
d3406 1
a3406 1
      store_floating (to, TYPE_LENGTH (type), val);
d3432 1
a3432 1
      store_floating(to, TYPE_LENGTH(type), val);
d3447 1
a3447 1
      DOUBLEST val = extract_floating (from, TYPE_LENGTH(type));
d3472 1
a3472 1
      DOUBLEST val = extract_floating (from, TYPE_LENGTH(type));
@


1.114
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_START_OFFSET): Default to zero.
	CALL_DUMMY_LENGTH): Ditto.
	* gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_START_OFFSET): Delete macro.
	(CALL_DUMMY_LENGTH): Delete macro.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set above when zero.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@d1119 1
a1119 1
  pc = get_pc_function_start (get_frame_pc (fi));
d1459 1
a1459 1
  pc = get_pc_function_start (get_frame_pc (fi));
d1660 1
a1660 1
  pc = get_pc_function_start (get_frame_pc (fi));
@


1.114.2.1
log
@Merge with mainline.
@
text
@d1119 1
a1119 1
  pc = get_frame_func (fi);
d1459 1
a1459 1
  pc = get_frame_func (fi);
d1660 1
a1660 1
  pc = get_frame_func (fi);
d2417 1
a2417 1
      deprecated_store_floating (valbuf, len, val);
d2470 1
a2470 1
	  deprecated_store_floating (valbuf, len, val);
d3406 1
a3406 1
      deprecated_store_floating (to, TYPE_LENGTH (type), val);
d3432 1
a3432 1
      deprecated_store_floating(to, TYPE_LENGTH(type), val);
d3447 1
a3447 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
d3472 1
a3472 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
@


1.113
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_BREAKPOINT_OFFSET): Default to zero.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sp64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* config/pa/tm-hppa64.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	* inferior.h (CALL_DUMMY_BREAKPOINT_OFFSET_P): Delete.
	(CALL_DUMMY_BREAKPOINT_OFFSET): Delete.
	* infcmd.c (run_stack_dummy): Simplify assuming
	CALL_DUMMY_BREAKPOINT_OFFSET_P.
	* infrun.c (handle_inferior_event): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set
	call_dummy_breakpoint_offset or call_dummy_breakpoint_offset_p.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
@
text
@a4655 2
  set_gdbarch_call_dummy_length (gdbarch, 0);
  set_gdbarch_call_dummy_start_offset (gdbarch, 0);
@


1.112
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FIX_CALL_DUMMY): Change to function with predicate.
	* gdbarch.h, gdbarch.c: Regenerate.
	* inferior.h (FIX_CALL_DUMMY): Delete macro.
	* valops.c (hand_function_call): Only call FIX_CALL_DUMMY when
	available.
	* frame.h (generic_fix_call_dummy): Delete declaration.
	* dummy-frame.h: Update comment.
	* dummy-frame.c (generic_fix_call_dummy): Delete function.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	fix_call_dummy.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a4656 2
  set_gdbarch_call_dummy_breakpoint_offset_p (gdbarch, 1); /*???*/
  set_gdbarch_call_dummy_breakpoint_offset (gdbarch, 0);
@


1.111
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh: Include "symfile.h".
	(CALL_DUMMY_ADDRESS): Default to entry_point_address.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_ADDRESS): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_address, the default is at entry_point_address.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@a4661 1
  set_gdbarch_fix_call_dummy (gdbarch, generic_fix_call_dummy);
@


1.110
log
@2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_P): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* inferior.h (CALL_DUMMY_P): Delete macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* breakpoint.c (deprecated_frame_in_dummy): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* dummy-frame.c (dummy_frame_this_id): Update comments.
	* rs6000-tdep.c (rs6000_extract_struct_value_address): Ditto.
	* frame.c (legacy_get_prev_frame): Ditto.
	* valops.c (call_function_by_hand): Delete function.
	(hand_function_call): Rename to call_function_by_hand

2003-03-31  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	references to CALL_DUMMY_P.
@
text
@a4656 1
  set_gdbarch_call_dummy_address (gdbarch, entry_point_address);
@


1.109
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DUMMY_WRITE_SP): Replace TARGET_WRITE_SP.
	* gdbarch.h, gdbarch.c: Regenerate.
	* v850-tdep.c (v850_gdbarch_init): Set deprecated_dummy_write_sp.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_push_dummy_frame, sparc_pop_frame): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_DUMMY_WRITE_SP): Update.
	* config/pa/tm-hppa.h (DEPRECATED_DUMMY_WRITE_SP): Define.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* valops.c (hand_function_call): Replace TARGET_WRITE_SP with
	DEPRECATED_DUMMY_WRITE_SP.  Call when the method is available,
	instead of when push_dummy_call is not available.

2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Remove
	reference to TARGET_WRITE_SP.
@
text
@a4662 1
  set_gdbarch_call_dummy_p (gdbarch, 1);
@


1.108
log
@2003-03-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_RETURN_ADDRESS): Replace
	PUSH_RETURN_ADDRESS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* valops.c (hand_function_call): Update.
@
text
@d4644 1
a4644 1
  set_gdbarch_write_sp (gdbarch, generic_target_write_sp);
@


1.107
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_ARGUMENTS): Rename PUSH_ARGUMENTS.
	(push_dummy_call): New pure multi-arch replacement with gdbarch,
	regcache and dummy_addr parameters.
	* gdbarch.h, gdbarch.c: Re-generate.
	* valops.c (hand_function_call): Use gdbarch_push_dummy_call when
	available; assume it will handle stack alignment and return
	address issues.  Fall back to DEPRECATED_PUSH_ARGUMENTS and
	legacy_push_arguments.
	(legacy_push_arguments): Rename default_push_arguments.
	* value.h (legacy_push_arguments): Rename default_push_arguments.
	* i386-tdep.c (i386_push_arguments): Call legacy_push_arguments.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_ARGUMENTS): Update.
	* config/i386/tm-symmetry.h: Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* arm-linux-tdep.c (arm_linux_init_abi): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	PUSH_ARGUMENTS with push_dummy_call, add gdbarch, regcache and
	dummy_addr parameters.
@
text
@d4666 1
a4666 1
  set_gdbarch_push_return_address (gdbarch, sh_push_return_address);
@


1.106
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_STORE_STRUCT_RETURN): Replace
	STORE_STRUCT_RETURN.
	* gdbarch.h, gdbarch.c: Regenerate.
	* d10v-tdep.c (d10v_store_struct_return): Delete function.
	(d10v_push_arguments): Set the struct return register.
	(d10v_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d4378 1
a4378 1
  set_gdbarch_push_arguments (gdbarch, sh_push_arguments);
d4620 1
a4620 1
      set_gdbarch_push_arguments (gdbarch, sh64_push_arguments);
@


1.106.2.1
log
@Merge with mainline.
@
text
@d4378 1
a4378 1
  set_gdbarch_deprecated_push_arguments (gdbarch, sh_push_arguments);
d4620 1
a4620 1
      set_gdbarch_deprecated_push_arguments (gdbarch, sh64_push_arguments);
d4644 1
a4644 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d4666 1
a4666 1
  set_gdbarch_deprecated_push_return_address (gdbarch, sh_push_return_address);
@


1.105
log
@2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_STACK_ADJUST_P): Delete.
	(DEPRECATED_CALL_DUMMY_STACK_ADJUST): Replace
	CALL_DUMMY_STACK_ADJUST with a predicate variable.
	* gdbarch.h, gdbarch.c: Regenerate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_stack_adjust_p.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sparc.h (CALL_DUMMY_STACK_ADJUST): Update.
	* config/sparc/tm-sp64.h (CALL_DUMMY_STACK_ADJUST): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.  Do not set
	call_dummy_stack_adjust_p.
	* inferior.h (CALL_DUMMY_STACK_ADJUST_P): Delete macro.
	(CALL_DUMMY_STACK_ADJUST): Delete macro.
	* sparc-tdep.c (sparc32_push_arguments): Update.
	* valops.c (hand_function_call): Update.

2003-03-25  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	reference to CALL_DUMMY_STACK_ADJUST_P.  Rename
	CALL_DUMMY_STACK_ADJUST to DEPRECATED_CALL_DUMMY_STACK_ADJUST.
	Add reference to PUSH_ARGUMENTS.
@
text
@d4379 1
a4379 1
  set_gdbarch_store_struct_return (gdbarch, sh_store_struct_return);
d4621 1
a4621 1
      /*set_gdbarch_store_struct_return (gdbarch, sh64_store_struct_return);*/
@


1.104
log
@Index: ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_CHAIN): Replace FRAME_CHAIN.
	(DEPRECATED_FRAME_CHAIN_VALID): Replace FRAME_CHAIN_VALID.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update.
	* objfiles.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* frame.c (legacy_saved_regs_this_id): Update.
	(legacy_get_prev_frame, get_prev_frame, legacy_frame_p): Update.
	* dummy-frame.h: Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_CHAIN_VALID): Update.
	* config/m68k/tm-vx68.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-os68k.h (DEPRECATED_FRAME_CHAIN): Update.
	* config/m68k/tm-sun3.h: Update.
	* blockframe.c (inside_main_func, frame_chain_valid): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_frame_chain, sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	(rs6000_gdbarch_init, rs6000_frame_saved_pc): Update.
	(frame_get_saved_regs): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_frame_num_args, i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	(i386_interix_back_one_frame): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	(hppa_init_extra_frame_info): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2003-03-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Algorithms, Target Architecture Definition):
	Deprecate FRAME_CHAIN and FRAME_CHAIN_VALID.
@
text
@a4663 1
  set_gdbarch_call_dummy_stack_adjust_p (gdbarch, 0);
@


1.103
log
@2003-03-14  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_GET_SAVED_REGISTER): Replace
	GET_SAVED_REGISTER.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h: Update comments.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* frame.c (frame_register): Update.
	(get_saved_register): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_GET_SAVED_REGISTER): Update.
@
text
@d4374 1
a4374 1
  set_gdbarch_frame_chain (gdbarch, sh_frame_chain);
d4617 1
a4617 1
      set_gdbarch_frame_chain (gdbarch, sh64_frame_chain);
@


1.102
log
@2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_POP_FRAME): Replace POP_FRAME.
	* gdbarch.h, gdbarch.c: Regenerate.
	* valops.c (hand_function_call): Update comment.
	* stack.c (return_command): Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_POP_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_POP_FRAME): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	POP_FRAME with DEPRECATED_POP_FRAME.  Update description.
@
text
@d4375 1
a4375 1
  set_gdbarch_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
d4618 1
a4618 1
      set_gdbarch_get_saved_register (gdbarch, sh64_get_saved_register);
@


1.101
log
@2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_SAVED_PC): Replace FRAME_SAVED_PC.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.h: Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* sh-tdep.c (sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* ns32knbsd-nat.c (frame_num_args): Update.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Update.
	* xstormy16-tdep.c (xstormy16_pop_frame): Update.
	(xstormy16_frame_chain_valid): Update.
	* vax-tdep.c (vax_saved_pc_after_call): Update.
	* v850-tdep.c (v850_frame_chain): Update.
	(v850_pop_frame): Update.
	(v850_init_extra_frame_info): Update.
	* sparc-tdep.c (setup_arbitrary_frame): Update.
	* ns32k-tdep.c (umax_frame_num_args): Update.
	* s390-tdep.c (s390_pop_frame_regular): Update.
	* mn10300-tdep.c (mn10300_frame_chain): Update.
	(mn10300_pop_frame_regular): Update.
	(mn10300_init_extra_frame_info): Update.
	* mips-tdep.c (mips_init_frame_pc_first): Update.
	(mips_frame_chain): Update.
	(mips_pop_frame): Update.
	* mcore-tdep.c (mcore_frame_chain): Update.
	(mcore_pop_frame): Update.
	(mcore_init_extra_frame_info): Update.
	* arch-utils.c (init_frame_pc_default): Update.
	* m68k-tdep.c (isi_frame_num_args): Update.
	(delta68_frame_num_args): Update.
	(news_frame_num_args): Update.
	* ia64-tdep.c (ia64_pop_frame_regular): Update.
	* alpha-tdep.c (alpha_init_frame_pc_first): Update.
	(alpha_frame_chain): Update.
	(alpha_pop_frame): Update.
	* hppa-tdep.c (hppa_saved_pc_after_call): Update.
	(hppa_init_extra_frame_info): Update.
	(hppa_frame_chain): Update.
	(hppa_frame_chain_valid): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_init_extra_frame_info): Update.
	* arm-tdep.c (arm_frame_chain_valid): Update.
	(arm_init_extra_frame_info): Update.
	(arm_pop_frame): Update.
	* frame.c (frame_pc_unwind): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_SAVED_PC): Update.
	(DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC_FIRST): Update.
	* config/pa/tm-hppa.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-delta68.h (DEPRECATED_FRAME_SAVED_PC): Update.
	* config/m68k/tm-linux.h (DEPRECATED_FRAME_SAVED_PC): Update.

2003-03-12  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_SAVED_PC to DEPRECATED_FRAME_SAVED_PC.
@
text
@d4382 1
a4382 1
  set_gdbarch_pop_frame (gdbarch, sh_pop_frame);
d4624 1
a4624 1
      set_gdbarch_pop_frame (gdbarch, sh64_pop_frame);
@


1.100
log
@2003-03-03  Andrew Cagney  <cagney@@redhat.com>

	Make MAX_REGISTER_RAW_SIZE and MAX_REGISTER_VIRTUAL_SIZE optional.
	* gdbarch.sh (DEPRECATED_MAX_REGISTER_RAW_SIZE): Variable with
	predicate.  Replace MAX_REGISTER_RAW_SIZE.
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto for
	MAX_REGISTER_VIRTUAL_SIZE.
	* regcache.c (legacy_max_register_raw_size): New function.
	(legacy_max_register_virtual_size): New function.
	* defs.h (MAX_REGISTER_VIRTUAL_SIZE): Define.
	(MAX_REGISTER_RAW_SIZE): Define.
	(legacy_max_register_raw_size): Declare.
	(legacy_max_register_virtual_size): Declare.
	* config/sparc/tm-sparc.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Update.
	* config/sparc/tm-sp64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa.h (DEPRECATED_MAX_REGISTER_RAW_SIZE)
	(DEPRECATED_MAX_REGISTER_VIRTUAL_SIZE): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* config/i386/tm-ptx.h (DEPRECATED_MAX_REGISTER_RAW_SIZE): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Do not set
	max_register_raw_size or max_register_virtual_size.
@
text
@d1761 1
a1761 1
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
d1793 1
a1793 1
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
d4677 1
a4677 1
  set_gdbarch_frame_saved_pc (gdbarch, sh_frame_saved_pc);
@


1.100.4.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@d1761 1
a1761 1
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));
d1793 1
a1793 1
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));
d4375 1
a4375 1
  set_gdbarch_deprecated_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
d4382 1
a4382 1
  set_gdbarch_deprecated_pop_frame (gdbarch, sh_pop_frame);
d4618 1
a4618 1
      set_gdbarch_deprecated_get_saved_register (gdbarch, sh64_get_saved_register);
d4624 1
a4624 1
      set_gdbarch_deprecated_pop_frame (gdbarch, sh64_pop_frame);
d4677 1
a4677 1
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sh_frame_saved_pc);
@


1.99
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAME_INIT_SAVED_REGS): Rename
	FRAME_INIT_SAVED_REGS.
	* gdbarch.h, gdbarch.c: Regenerate.
	* stack.c (frame_info): Update.
	* sh-tdep.c (sh_find_callers_reg, sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info, sh64_init_extra_frame_info): Update.
	(sh64_get_saved_register, sh_pop_frame, sh64_pop_frame): Update.
	* ns32k-tdep.c (ns32k_pop_frame): Update.
	* mips-tdep.c (mips_pop_frame): Update.
	* m68hc11-tdep.c (m68hc11_pop_frame): Update.
	* ia64-tdep.c (ia64_frame_chain): Update.
	(ia64_frame_saved_pc, ia64_get_saved_register): Update.
	(ia64_frameless_function_invocation): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_pop_frame_regular): Update.
	* frame.h (struct frame_info): Update comment.
	(DEPRECATED_FRAME_INIT_SAVED_REGS): Rename macro.
	* frame.c (frame_saved_regs_register_unwind): Update.
	(frame_saved_regs_register_unwind): Update.
	(deprecated_generic_get_saved_register): Update.
	* cris-tdep.c: Update comment.
	* config/sparc/tm-sparc.h (DEPRECATED_FRAME_INIT_SAVED_REGS):
	Rename macro.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_init_abi): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	FRAME_INIT_SAVED_REGS to DEPRECATED_FRAME_INIT_SAVED_REGS.
@
text
@d4362 2
a4363 2
  set_gdbarch_max_register_raw_size (gdbarch, 4);
  set_gdbarch_max_register_virtual_size (gdbarch, 4);
d4516 2
a4517 2
      set_gdbarch_max_register_raw_size (gdbarch, 4 * 4);
      set_gdbarch_max_register_virtual_size (gdbarch, 4 * 4);
d4604 1
a4604 1
      /*set_gdbarch_max_register_raw_size (gdbarch, 8);*/
d4606 1
a4606 1
      set_gdbarch_max_register_raw_size (gdbarch, 4 * 4);
d4608 2
a4609 2
      /*set_gdbarch_max_register_virtual_size (gdbarch, 8);*/
      set_gdbarch_max_register_virtual_size (gdbarch, 4 * 4);
@


1.98
log
@2003-03-01  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename
	INIT_EXTRA_FRAME_INFO.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-tdep.c: Update comments.
	* sh-tdep.c, mcore-tdep.c, m68hc11-tdep.c: Ditto.
	* i386-interix-tdep.c, hppa-tdep.c, h8300-tdep.c: Ditto.
	* frame.h, avr-tdep.c: Ditto.
	* frame.c (get_prev_frame): DEPRECATED_INIT_EXTRA_FRAME_INFO.
	(create_new_frame, legacy_get_prev_frame): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_EXTRA_FRAME_INFO): Rename.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Initialize
	deprecated_init_extra_frame_info instead of init_extra_frame_info.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.

Index: doc/ChangeLog
2003-02-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo: Rename INIT_EXTRA_FRAME_INFO to
	DEPRECATED_INIT_EXTRA_FRAME_INFO.
@
text
@d1032 1
a1032 1
	FRAME_INIT_SAVED_REGS (fi);
d1056 1
a1056 1
	FRAME_INIT_SAVED_REGS (fi);
d1779 1
a1779 1
      FRAME_INIT_SAVED_REGS (fi);
d1810 1
a1810 1
      FRAME_INIT_SAVED_REGS (fi);
d1867 1
a1867 1
      FRAME_INIT_SAVED_REGS (frame);
d1956 1
a1956 1
      FRAME_INIT_SAVED_REGS (frame);
d1988 1
a1988 1
      FRAME_INIT_SAVED_REGS (frame);
d4395 1
a4395 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4405 1
a4405 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4415 1
a4415 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4429 1
a4429 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4454 1
a4454 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4466 1
a4466 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
d4483 1
a4483 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4509 1
a4509 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
d4614 1
a4614 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh64_nofp_frame_init_saved_regs);
d4633 1
a4633 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
@


1.97
log
@2003-02-27  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_PUSH_DUMMY_FRAME): Procedure with
	predicate.  Replaces PUSH_DUMMY_FRAME.
	* gdbarch.h, gdbarch.c: Regnerate.
	* valops.c (hand_function_call): Update.  Call
	generic_push_dummy_frame directly.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* config/sparc/tm-sparc.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* config/pa/tm-hppa.h (DEPRECATED_PUSH_DUMMY_FRAME): Update.
	* inferior.h (PUSH_DUMMY_FRAME): Delete definition.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Don't set
	push_dummy_frame to generic_push_dummy_frame.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
@
text
@d946 2
a947 2
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.
d4376 1
a4376 1
  set_gdbarch_init_extra_frame_info (gdbarch, sh_init_extra_frame_info);
d4616 1
a4616 1
      set_gdbarch_init_extra_frame_info (gdbarch, sh64_init_extra_frame_info);
@


1.96
log
@Add support for SH2E processor.
@
text
@a4666 1
  set_gdbarch_push_dummy_frame (gdbarch, generic_push_dummy_frame);
@


1.95
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d160 22
d2650 56
d4410 14
@


1.95.2.1
log
@Merge with interps-20030203-mergepoint.
@
text
@a159 22
sh_sh2e_register_name (int reg_nr)
{
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
    "fpul", "fpscr",
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "",  "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
a2627 56
sh2e_show_regs (void)
{
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));

  printf_filtered ("GBR=%08lx VBR=%08lx",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
	  	   (long) read_register (gdbarch_tdep (current_gdbarch)->FPUL_REGNUM),
                   (long) read_register (gdbarch_tdep (current_gdbarch)->FPSCR_REGNUM));

  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));

  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
}

static void
a4331 14
    case bfd_mach_sh2e:
      sh_register_name = sh_sh2e_register_name;
      sh_show_regs = sh2e_show_regs;
      sh_store_return_value = sh3e_sh4_store_return_value;
      sh_register_virtual_type = sh_sh3e_register_virtual_type;
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      tdep->FPUL_REGNUM = 23;
      tdep->FPSCR_REGNUM = 24;
      tdep->FP_LAST_REGNUM = 40;
      break;
@


1.94
log
@2003-01-21  Andrew Cagney  <ac131313@@redhat.com>

	* exec.c (text_start): Delete global variable.
	(exec_file_attach): Make text_start local to the function.
	* inferior.h (BEFORE_TEXT_END, AFTER_TEXT_END): Delete macros.
	* valops.c (hand_function_call): Delete code that handles
	BEFORE_TEXT_END and AFTER_TEXT_END.
	* gdbarch.sh (CALL_DUMMY_LENGTH): Test call_dummy_length instead
	of CALL_DUMMY_LOCATION.
	* gdbarch.c: Regenerate.
	* inferior.h (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end): Delete declaration.
	* blockframe.c (deprecated_pc_in_call_dummy_before_text_end)
	(deprecated_pc_in_call_dummy_after_text_end): Delete functions.
	(text_end): Delete extern declaration.
@
text
@d4012 1
a4012 1
  char raw_buffer[MAX_REGISTER_RAW_SIZE];
@


1.93
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* cris-tdep.c (cris_frame_init_saved_regs): Use
	get_frame_saved_regs and SIZEOF_FRAME_SAVED_REGS when copying a
	saved_regs buffer.
	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* arm-tdep.c: Use deprecated_set_frame_saved_regs_hack.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
	* mn10300-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d36 1
a36 1
#include "inferior.h"		/* for BEFORE_TEXT_END etc. */
@


1.92
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_extra_info.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, ia64-tdep.c, m68hc11-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10300-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d1081 1
a1081 1
      memcpy (fi->saved_regs, dummy_regs, sizeof (fi->saved_regs));
d1421 1
a1421 1
      memcpy (fi->saved_regs, dummy_regs, sizeof (fi->saved_regs));
d1622 1
a1622 1
      memcpy (fi->saved_regs, dummy_regs, sizeof (fi->saved_regs));
@


1.91
log
@2003-01-08  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_next_frame.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c: Ditto.
	* mips-tdep.c, mn10200-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, sparc-tdep.c: Ditto.
	* v850-tdep.c, vax-tdep.c, x86-64-linux-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
@
text
@d937 2
a938 1
    return read_memory_integer (get_frame_base (frame) + frame->extra_info->f_offset, 4);
d985 3
a987 1
      return read_memory_integer (get_frame_base (frame) + frame->extra_info->f_offset, size);
d1085 2
a1086 2
  fi->extra_info->leaf_function = 1;
  fi->extra_info->f_offset = 0;
d1118 1
a1118 1
	  fi->extra_info->leaf_function = 0;
d1173 1
a1173 1
  fi->extra_info->f_offset = depth - where[FP_REGNUM] - 4;
d1425 2
a1426 2
  fi->extra_info->leaf_function = 1;
  fi->extra_info->f_offset = 0;
d1476 1
a1476 1
		  fi->extra_info->leaf_function = 0;
d1504 1
a1504 1
	      fi->extra_info->leaf_function = 0;
d1532 1
a1532 1
	      fi->extra_info->leaf_function = 0;
d1539 1
a1539 1
	      fi->extra_info->leaf_function = 0;
d1595 1
a1595 1
  fi->extra_info->f_offset = depth - where[fp_regnum]; 
d1626 2
a1627 2
  fi->extra_info->leaf_function = 1;
  fi->extra_info->f_offset = 0;
d1659 1
a1659 1
	  fi->extra_info->leaf_function = 0;
d1726 1
a1726 1
  fi->extra_info->f_offset = depth - where[FP_REGNUM] - 4;
d1748 1
a1748 1
      fi->extra_info->return_pc = deprecated_read_register_dummy (get_frame_pc (fi),
d1751 2
a1752 2
      fi->extra_info->f_offset = -(CALL_DUMMY_LENGTH + 4);
      fi->extra_info->leaf_function = 0;
d1758 1
a1758 1
      fi->extra_info->return_pc = 
d1779 1
a1779 1
      fi->extra_info->return_pc = 
d1782 2
a1783 2
      fi->extra_info->f_offset = -(CALL_DUMMY_LENGTH + 4);
      fi->extra_info->leaf_function = 0;
d1789 1
a1789 1
      fi->extra_info->return_pc =
d1915 1
a1915 1
  return ((frame)->extra_info->return_pc);
d1942 1
a1942 1
      write_register (PC_REGNUM, frame->extra_info->return_pc);
d1985 1
a1985 1
      write_register (PC_REGNUM, frame->extra_info->return_pc);
@


1.90
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use get_frame_base.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* mn10300-tdep.c, ns32k-tdep.c, s390-tdep.c, sh-tdep.c: Ditto.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c: Ditto.
	* x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* config/h8500/tm-h8500.h, config/mn10200/tm-mn10200.h: Ditto.
	* config/sparc/tm-sparc.h: Ditto.
@
text
@d998 1
a998 1
  for (; fi; fi = fi->next)
d1022 1
a1022 1
  for (; fi; fi = fi->next)
d1735 2
a1736 2
  if (fi->next)
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (fi->next));
d1767 2
a1768 2
  if (fi->next) 
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (fi->next));
d1826 1
a1826 1
  while (frame && ((frame = frame->next) != NULL))
@


1.89
log
@2003-01-07  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_init_extra_frame_info): Allocate
	extra_info using frame_extra_info_zalloc.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	* sh-tdep.c (sh_init_extra_frame_info): Ditto.
	(sh64_init_extra_frame_info): Ditto.
	* mn10300-tdep.c (mn10300_init_extra_frame_info): Ditto.
	* s390-tdep.c (s390_init_extra_frame_info): Ditto.
	* mips-tdep.c (mips_init_extra_frame_info): Ditto.
	* mcore-tdep.c (mcore_init_extra_frame_info): Ditto.
	* frv-tdep.c (frv_init_extra_frame_info): Ditto.
	* m68hc11-tdep.c (m68hc11_init_extra_frame_info): Ditto.
	* ia64-tdep.c (ia64_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_init_extra_frame_info): Ditto.
	* d10v-tdep.c (d10v_init_extra_frame_info): Ditto.
	* cris-tdep.c (cris_init_extra_frame_info): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.
	* alpha-tdep.c (alpha_init_extra_frame_info): Ditto.

	* mn10300-tdep.c (analyze_dummy_frame): Use
	deprecated_set_frame_extra_info_hack.
	* mcore-tdep.c (analyze_dummy_frame): Ditto.
@
text
@d932 4
a935 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
    return frame->frame;	/* dummy frame same as caller's frame */
d972 4
a975 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
    return frame->frame;	/* dummy frame same as caller's frame */
d999 2
a1000 1
    if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), fi->frame, fi->frame))
d1003 2
a1004 1
      return deprecated_read_register_dummy (get_frame_pc (fi), fi->frame, regnum);
d1023 2
a1024 1
    if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), fi->frame, fi->frame))
d1027 2
a1028 1
      return deprecated_read_register_dummy (get_frame_pc (fi), fi->frame, pr_regnum);
d1065 2
a1066 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), fi->frame);
d1153 1
a1153 1
	  get_frame_saved_regs (fi)[rn] = fi->frame - where[rn] + depth - 4;
d1167 1
a1167 1
      get_frame_saved_regs (fi)[SP_REGNUM] = fi->frame - 4;
d1405 1
a1405 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), fi->frame);
d1566 1
a1566 1
	  get_frame_saved_regs (fi)[register_number]= fi->frame - where[rn] + depth; 
d1590 1
a1590 1
    get_frame_saved_regs (fi)[sp_regnum] = fi->frame;
d1606 1
a1606 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), fi->frame);
d1705 1
a1705 1
	  get_frame_saved_regs (fi)[rn] = fi->frame - where[rn] + depth - 4;
d1720 1
a1720 1
      get_frame_saved_regs (fi)[SP_REGNUM] = fi->frame - 4;
d1738 2
a1739 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), fi->frame, fi->frame))
d1743 1
a1743 1
      deprecated_update_frame_base_hack (fi, deprecated_read_register_dummy (get_frame_pc (fi), fi->frame,
d1746 1
a1746 1
								  fi->frame,
d1770 2
a1771 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), fi->frame, fi->frame))
d1775 1
a1775 2
      deprecated_update_frame_base_hack (fi, deprecated_read_register_dummy (get_frame_pc (fi), fi->frame,
									     SP_REGNUM));
d1777 2
a1778 1
	deprecated_read_register_dummy (get_frame_pc (fi), fi->frame, PC_REGNUM);
d1828 3
a1830 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
d1836 1
a1836 1
		    (deprecated_generic_find_dummy_frame (get_frame_pc (frame), frame->frame)
d1924 3
a1926 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
d1956 3
a1958 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame), frame->frame, frame->frame))
@


1.88
log
@	* arm-tdep.c (arm_frame_chain_valid):  Remove unnecessary test.
	* d10v-tdep.c (d10v_frame_chain_valid): Remove unnecessary tests.
	* hppa-tdep.c (hppa_frame_chain_valid): Remove unnecessary test.

	* blockframe.c: Include "gdbcmd.h" and "command.h".
	(backtrace_below_main): New variable.
	(file_frame_chain_valid, func_frame_chain_valid)
	(nonnull_frame_chain_valid, generic_file_frame_chain_valid)
	(generic_func_frame_chain_valid): Remove functions.
	(frame_chain_valid, do_flush_frames_sfunc): New functions.
	(_initialize_blockframe): New function.
	* Makefile.in (blockframe.o): Update dependencies.
	* frame.c (frame_saved_regs_id_unwind, get_prev_frame): Remove FIXME
	comment.  Call frame_chain_valid ().
	* frame.h: Remove old prototypes.  Add prototype for
	frame_chain_valid and update comments to match.
	* gdbarch.sh: Change FRAME_CHAIN_VALID into a predicated function.
	Remove old comment.
	* gdbarch.h: Regenerated.
	* gdbarch.c: Regenerated.

Plus updates to all other targets not to provide a FRAME_CHAIN_VALID.
@
text
@d1724 1
a1724 2
  fi->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
d1755 1
a1755 2
  fi->extra_info = (struct frame_extra_info *)
    frame_obstack_alloc (sizeof (struct frame_extra_info));
@


1.87
log
@	* arch-utils.c (gdbarch_info_init): Set osabi to
	GDB_OSABI_UNINITIALIZED.
	* gdbarch.sh: Add osabi to struct gdbarch and to struct
	gdbarch_info.  Include "osabi.h" in gdbarch.c.  Check osabi
	in gdbarch_list_lookup_by_info and in gdbarch_update_p.
	* gdbarch.c: Regenerated.
	* gdbarch.h: Regenerated.
	* osabi.c (gdbarch_lookup_osabi): Return GDB_OSABI_UNINITIALIZED if
	there's no BFD.
	(gdbarch_init_osabi): Remove osabi argument; use info.osabi.
	* osabi.h (enum gdb_osabi): Move to defs.h.
	(gdbarch_init_osabi): Update prototype.
	* defs.h (enum gdb_osabi): Moved here.
	* Makefile.in: Update dependencies.

Plus updates to alpha, arm, hppa, i386, mips, ns32k, ppc, sh, sparc, and vax
ports to match.
@
text
@a4567 1
  set_gdbarch_frame_chain_valid (gdbarch, generic_file_frame_chain_valid);
@


1.86
log
@gdb/
	* buildsym.h (processing_hp_compilation): Remove obsolete variable.
	* gdbarch.sh Remove include of "value.h" in gdbarch.h.
	(COERCE_FLOAT_TO_DOUBLE): Remove.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* Makefile.in: Remove value_h from gdbarch_h.
	* valops.c (coerce_float_to_double): New variable.
	(default_coerce_float_to_double): Remove.
	(standard_coerce_float_to_double): Remove.
	(value_arg_coerce): Use coerce_float_to_double.
	(_initialize_valops): Add "set coerce-float-to-double".
	* value.h (default_coerce_float_to_double): Remove prototype.
	(standard_coerce_float_to_double): Remove prototype.

	* hpread.c (hpread_process_one_debug_symbol): Mark C++ functions as
	prototyped.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Mark all functions as prototyped.

	* hppa-tdep.c (hppa_coerce_float_to_double): Remove.
	* alpha-tdep.c (alpha_gdbarch_init): Remove call to
	set_gdbarch_coerce_float_to_double.
	* arm-tdep.c (arm_gdbarch_init): Likewise.
	* frv-tdep.c (frv_gdbarch_init): Likewise.
	* h8300-tdep.c (h8300_gdbarch_init): Likewise (commented out).
	* i386-sol2-tdep.c (i386_sol2_init_abi): Likewise.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	(mips_coerce_float_to_double): Remove.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	(rs6000_coerce_float_to_double): Remove.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	(sh_coerce_float_to_double): Remove.
	* sparc-tdep.c (sparc_gdbarch_init): Likewise.
	(sparc_coerce_float_to_double): Remove.
	* v850-tdep.c (v850_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.
	* config/m32r/tm-m32r.h (COERCE_FLOAT_TO_DOUBLE): Remove.
	* config/pa/tm-hppa.h: (COERCE_FLOAT_TO_DOUBLE): Remove.
	(hppa_coerce_float_to_double): Remove prototype.
	* config/sparc/tm-sparc.h (COERCE_FLOAT_TO_DOUBLE): Remove.
doc/
	* gdb.texinfo (Controlling GDB): Add ABI section.  Document
	"set coerce-float-to-double".
	* gdbint.texinfo (COERCE_FLOAT_TO_DOUBLE): Remove documentation.
testsuite/
	* gdb.base/callfuncs.exp: Don't XFAIL unprototyped functions for
	stabs.
	* gdb.base/completion.exp: Allow marker1(void) as well as marker1().
	* gdb.base/whatis.exp: Always allow (void) after function names.
@
text
@d42 1
a4213 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d4215 4
a4218 18
  /* Try to determine the ABI of the object we are loading.  */

  if (info.abfd != NULL)
    {
      osabi = gdbarch_lookup_osabi (info.abfd);
      /* If we get "unknown" back, just leave it that way.  */
    }

  /* Find a candidate among the list of pre-declared architectures. */
  for (arches = gdbarch_list_lookup_by_info (arches, &info);
       arches != NULL;
       arches = gdbarch_list_lookup_by_info (arches->next, &info))
    {
      /* Make sure the ABI selection matches.  */
      tdep = gdbarch_tdep (arches->gdbarch);
      if (tdep && tdep->osabi == osabi)
	return arches->gdbarch;
    }
a4228 2
  tdep->osabi = osabi;

d4574 2
a4575 5
  /* Hook in ABI-specific overrides, if they have been registered.

     FIXME: if the ABI is unknown, this is probably an embedded target,
     so we should not warn about this situation.  */
  gdbarch_init_osabi (info, gdbarch, osabi);
d4588 1
a4588 2
  fprintf_unfiltered (file, "sh_dump_tdep: OS ABI = %s\n",
                      gdbarch_osabi_name (tdep->osabi));
@


1.85
log
@2003-01-03  Andrew Cagney  <ac131313@@redhat.com>

	* alpha-tdep.c: Use get_frame_saved_regs.
	* arm-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* h8300-tdep.c, i386-tdep.c, ia64-tdep.c, m68hc11-tdep.c: Ditto.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Ditto.
	* ns32k-tdep.c, s390-tdep.c, sh-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, xstormy16-tdep.c: Ditto.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
a2321 6
static int
sh_coerce_float_to_double (struct type *formal, struct type *actual)
{
  return 1;
}

a4571 2
  set_gdbarch_coerce_float_to_double (gdbarch, 
				      sh_coerce_float_to_double);
@


1.84
log
@2003-01-03  Andrew Cagney  <cagney@@redhat.com>

	* alpha-tdep.c: Use deprecated_update_frame_base_hack.
	* avr-tdep.c, cris-tdep.c: Ditto.
	* mcore-tdep.c, mips-tdep.c, mn10200-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
@
text
@d1003 2
a1004 2
	if (fi->saved_regs[regnum] != 0)
	  return read_memory_integer (fi->saved_regs[regnum],
d1028 1
a1028 1
	if (fi->saved_regs[pr_regnum] != 0)
d1034 1
a1034 1
	    return read_memory_integer (fi->saved_regs[pr_regnum], size);
d1058 1
a1058 1
  if (fi->saved_regs == NULL)
d1061 1
a1061 1
    memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
d1143 1
a1143 1
	  fi->saved_regs[rn] = fi->frame - where[rn] + depth - 4;
d1147 1
a1147 1
	  fi->saved_regs[rn] = 0;
d1153 1
a1153 1
      fi->saved_regs[SP_REGNUM] = read_memory_integer (fi->saved_regs[FP_REGNUM], 4);
d1157 1
a1157 1
      fi->saved_regs[SP_REGNUM] = fi->frame - 4;
d1398 1
a1398 1
  if (fi->saved_regs == NULL)
d1401 1
a1401 1
    memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
d1556 1
a1556 1
	  fi->saved_regs[register_number]= fi->frame - where[rn] + depth; 
d1560 1
a1560 1
	fi->saved_regs[register_number] = 0; 
d1577 1
a1577 1
      fi->saved_regs[sp_regnum] = read_memory_integer (fi->saved_regs[fp_regnum], size);
d1580 1
a1580 1
    fi->saved_regs[sp_regnum] = fi->frame;
d1599 1
a1599 1
  if (fi->saved_regs == NULL)
d1602 1
a1602 1
    memset (fi->saved_regs, 0, SIZEOF_FRAME_SAVED_REGS);
d1695 1
a1695 1
	  fi->saved_regs[rn] = fi->frame - where[rn] + depth - 4;
d1699 1
a1699 1
	  fi->saved_regs[rn] = 0;
d1705 2
a1706 2
      fi->saved_regs[SP_REGNUM] =
	read_memory_integer (fi->saved_regs[FP_REGNUM], 4);
d1710 1
a1710 1
      fi->saved_regs[SP_REGNUM] = fi->frame - 4;
d1831 2
a1832 2
      if (frame->saved_regs != NULL
	  && frame->saved_regs[regnum] != 0)
d1840 1
a1840 1
			       frame->saved_regs[regnum]);
d1846 1
a1846 1
		*addrp = frame->saved_regs[regnum];
d1857 1
a1857 1
		    read_memory (frame->saved_regs[regnum], raw_buffer, size);
d1859 1
a1859 1
		    read_memory (frame->saved_regs[regnum],
d1921 1
a1921 1
	if (frame->saved_regs[regnum])
d1923 1
a1923 1
			  read_memory_integer (frame->saved_regs[regnum], 4));
d1951 1
a1951 1
	if (frame->saved_regs[regnum])
d1962 1
a1962 1
			    read_memory_integer (frame->saved_regs[regnum],
@


1.83
log
@2003-01-02  Andrew Cagney  <ac131313@@redhat.com>

	* arm-tdep.c: Use get_frame_pc and deprecated_update_frame_pc_hack
	frame accessor methods.
	* alpha-tdep.c, avr-tdep.c, cris-tdep.c, d10v-tdep.c: Ditto.
	* dwarf2cfi.c, h8300-tdep.c, i386-tdep.c, ia64-tdep.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, ns32k-tdep.c: Ditto.
	* s390-tdep.c, sh-tdep.c, sparc-tdep.c, v850-tdep.c: Ditto.
	* vax-tdep.c, x86-64-linux-tdep.c, xstormy16-tdep.c: Ditto.
	* z8k-tdep.c: Ditto.
@
text
@d1733 2
a1734 2
      fi->frame = deprecated_read_register_dummy (get_frame_pc (fi), fi->frame,
						  SP_REGNUM);
d1765 2
a1766 2
      fi->frame = deprecated_read_register_dummy (get_frame_pc (fi), fi->frame,
						  SP_REGNUM);
@


1.82
log
@2002-12-10  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
	Change to a function with predicate.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.c (get_prev_frame): Update.  Test
	DEPRECATED_INIT_FRAME_PC_P.
	* config/sparc/tm-sparc.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/rs6000/tm-rs6000.h (DEPRECATED_INIT_FRAME_PC): Update.
	* config/mn10200/tm-mn10200.h (DEPRECATED_INIT_FRAME_PC): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-interix-tdep.c (i386_interix_init_abi): Update.
	* arm-tdep.c: Update comments.
	* h8300-tdep.c (h8300_gdbarch_init): Explicitly set init_frame_pc.
	* config/m32r/tm-m32r.h (DEPRECATED_INIT_FRAME_PC): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* config/z8k/tm-z8k.h (INIT_FRAME_PC_FIRST): Delete macro.
	(DEPRECATED_INIT_FRAME_PC): Rename INIT_FRAME_PC.
@
text
@d931 1
a931 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d933 1
a933 1
  if (frame->pc && !inside_entry_file (frame->pc))
d969 1
a969 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d971 1
a971 1
  if (frame->pc && !inside_entry_file (frame->pc))
d973 1
a973 1
      int media_mode = pc_is_isa32 (frame->pc);
d994 1
a994 1
    if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d997 1
a997 1
      return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
d1001 1
a1001 1
	if (!fi->pc)
d1016 1
a1016 1
    if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1019 1
a1019 1
      return deprecated_read_register_dummy (fi->pc, fi->frame, pr_regnum);
d1023 1
a1023 1
	if (!fi->pc)
d1026 1
a1026 1
	media_mode = pc_is_isa32 (fi->pc);
d1056 1
a1056 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1084 1
a1084 1
  pc = get_pc_function_start (fi->pc);
d1087 1
a1087 1
      fi->pc = 0;
d1395 1
a1395 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1424 1
a1424 1
  pc = get_pc_function_start (fi->pc);
d1427 1
a1427 1
      fi->pc = 0;
d1596 1
a1596 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1625 1
a1625 1
  pc = get_pc_function_start (fi->pc);
d1628 1
a1628 1
      fi->pc = 0;
d1727 1
a1727 1
    fi->pc = FRAME_SAVED_PC (fi->next);
d1729 1
a1729 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1733 1
a1733 1
      fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
d1735 1
a1735 1
      fi->extra_info->return_pc = deprecated_read_register_dummy (fi->pc,
d1753 1
a1753 1
  int media_mode = pc_is_isa32 (fi->pc);
d1758 2
a1759 2
  if (fi->next)
    fi->pc = FRAME_SAVED_PC (fi->next);
d1761 1
a1761 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1765 1
a1765 1
      fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
d1768 1
a1768 1
	deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
d1808 1
a1808 1
  media_mode = pc_is_isa32 (frame->pc);
d1818 1
a1818 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1824 1
a1824 1
		    (deprecated_generic_find_dummy_frame (frame->pc, frame->frame)
d1912 1
a1912 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1940 1
a1940 1
  int media_mode = pc_is_isa32 (frame->pc);
d1942 1
a1942 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d2941 1
a2941 1
  if (pc_is_isa32 (deprecated_selected_frame->pc))
d4116 1
a4116 1
  if (pc_is_isa32 (deprecated_selected_frame->pc))
@


1.81
log
@2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Rename
	PC_IN_CALL_DUMMY.  Change to predicate.  Always allow call.
	* gdbarch.h, gdbarch.c: Re-generate.
	* config/sparc/tm-sparc.h, config/sparc/tm-sp64.h: Update.
	* config/mn10200/tm-mn10200.h, config/h8500/tm-h8500.h: Update.
	* config/pa/tm-hppa.h, frame.h: Update.
	* x86-64-tdep.c, vax-tdep.c, sparc-tdep.c: Update.
	* s390-tdep.c, ns32k-tdep.c, mn10300-tdep.c: Update.
	* m68k-tdep.c, i386-tdep.c, frv-tdep.c: Update.
	* cris-tdep.c, alpha-tdep.c: Update.
	* frame.c (set_unwind_by_pc, create_new_frame): Use either
	DEPRECATED_PC_IN_CALL_DUMMY or pc_in_dummy_frame.
	(get_prev_frame): Ditto.

Index: doc/ChangeLog
2002-12-01  Andrew Cagney  <ac131313@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	PC_IN_CALL_DUMMY.
@
text
@d921 4
a924 3
/* Given a GDB frame, determine the address of the calling function's frame.
   This will be used to create a new GDB frame struct, and then
   INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.
d4244 4
@


1.80
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d930 1
a930 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d968 1
a968 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d993 1
a993 1
    if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1015 1
a1015 1
    if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1728 1
a1728 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1760 1
a1760 1
  if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1817 1
a1817 1
      if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1911 1
a1911 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1941 1
a1941 1
  if (PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
@


1.79
log
@2002-11-27  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (CALL_DUMMY_LOCATION): Default to AT_ENTRY_POINT.
	(USE_GENERIC_DUMMY_FRAMES): Default to true.
	(PC_IN_CALL_DUMMY): Default to generic_pc_in_call_dummy.
	* gdbarch.c, gdbarch.h: Re-generate.
	* inferior.h (USE_GENERIC_DUMMY_FRAMES): Delete macro definition.
	(CALL_DUMMY_LOCATION): Delete macro definition.
	(PC_IN_CALL_DUMMY): Delete macro definitions.

	* arm-tdep.c (arm_gdbarch_init): Do not set pc_in_call_dummy,
	default is already generic_pc_in_call_dummy.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* arm-tdep.c (arm_gdbarch_init): Do not set
	use_generic_dummy_frames, default is already 1.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	call_dummy_location, default is already AT_ENTRY_POINT.
	* x86-64-tdep.c (x86_64_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d2940 1
a2940 1
  if (pc_is_isa32 (selected_frame->pc))
d3922 1
a3922 1
  if (!frame_register_read (selected_frame, regnum, raw_buffer))
d4004 1
a4004 1
  if (!frame_register_read (selected_frame, regnum, raw_buffer))
d4115 1
a4115 1
  if (pc_is_isa32 (selected_frame->pc))
@


1.78
log
@2002-11-19  Andrew Cagney  <ac131313@@redhat.com>

	* frame.h (FRAME_FP): Delete macro.
	(get_frame_base): New function declaration.
	* frame.c (get_frame_base): New function.
	(get_frame_id): Use ->frame.
	(frame_find_by_id): Rewrite to use get_frame_id.
	* blockframe.c: Use get_frame_base instead of FRAME_FP.
	* cris-tdep.c, d10v-tdep.c, findvar.c, h8500-tdep.c: Ditto.
	* hppa-tdep.c, i386-tdep.c, infcmd.c, infrun.c: Ditto.
	* m68hc11-tdep.c, m68k-tdep.c, mcore-tdep.c, mips-tdep.c: Ditto.
	* mn10200-tdep.c, mn10300-tdep.c, rs6000-tdep.c: Ditto.
	* sh-tdep.c, sparc-tdep.c, stack.c, tracepoint.c: Ditto.
	* v850-tdep.c, valops.c, z8k-tdep.c: Ditto.
@
text
@a4562 1
  set_gdbarch_use_generic_dummy_frames (gdbarch, 1);
a4563 1
  set_gdbarch_call_dummy_location (gdbarch, AT_ENTRY_POINT);
a4567 1
  set_gdbarch_pc_in_call_dummy (gdbarch, generic_pc_in_call_dummy);
@


1.77
log
@2002-11-22  Andrew Cagney  <ac131313@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_ADDRESS, FRAME_LOCALS_ADDRESS): Default
	to default_frame_address.
	* gdbarch.h, gdbarch.c: Re-generate.

	* d10v-tdep.c (d10v_gdbarch_init): Do not set frame_args_address
	or frame_locals_address to default_frame_address.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.

	* cris-tdep.c (cris_frame_args_address): Delete function.
	(cris_frame_locals_address): Delete function.
	(cris_gdbarch_init): Do not set frame_args_address or
	frame_locals_address.
@
text
@d933 1
a933 1
    return read_memory_integer (FRAME_FP (frame) + frame->extra_info->f_offset, 4);
d978 1
a978 1
      return read_memory_integer (FRAME_FP (frame) + frame->extra_info->f_offset, size);
d1915 1
a1915 1
      fp = FRAME_FP (frame);
d1945 1
a1945 1
      fp = FRAME_FP (frame);
@


1.76
log
@2002-11-13  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_bytes): Rename
	read_register_bytes.
	(deprecated_write_register_bytes): Rename write_register_bytes.
	* alpha-tdep.c, arm-tdep.c, cris-tdep.c, d10v-tdep.c: Update.
	* dwarf2cfi.c, frv-tdep.c, hppa-tdep.c, ia64-tdep.c: Update.
	* m68k-tdep.c, mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, regcache.c, remote-sds.c, remote-vx.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh-tdep.c: Update.
	* sparc-tdep.c, v850-tdep.c, vax-tdep.c, x86-64-tdep.c: Update.
	* xstormy16-tdep.c, z8k-tdep.c, config/nm-gnu.h: Update.
	* config/nm-m3.h, config/h8500/tm-h8500.h: Update.
	* config/i386/nm-ptx4.h, config/i386/nm-symmetry.h: Update.
	* config/m32r/tm-m32r.h, config/m68k/nm-sun3.h: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-linux.h: Update.
	* config/mn10200/tm-mn10200.h, config/pa/tm-hppa64.h: Update.
	* config/sparc/nm-nbsd.h, config/sparc/nm-sun4os4.h: Update.
	* config/sparc/nm-sun4sol2.h, config/sparc/tm-sparclet.h: Update.

2002-11-13  Andrew Cagney  <ac131313@@redhat.com>

	* mi-main.c (mi_cmd_data_write_register_values): Use
	deprecated_write_register_bytes instead of write_register_bytes.
@
text
@a4591 2
  set_gdbarch_frame_args_address (gdbarch, default_frame_address);
  set_gdbarch_frame_locals_address (gdbarch, default_frame_address);
@


1.75
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d2476 2
a2477 2
      write_register_bytes (REGISTER_BYTE (R0_REGNUM), buf, 
			    REGISTER_RAW_SIZE (R0_REGNUM));
d2480 2
a2481 2
    write_register_bytes (REGISTER_BYTE (R0_REGNUM), valbuf, 
			  TYPE_LENGTH (type));
d2488 2
a2489 2
    write_register_bytes (REGISTER_BYTE (FP0_REGNUM), 
			  valbuf, TYPE_LENGTH (type));
@


1.74
log
@2002-11-01  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_generic_get_saved_register): Rename
	generic_get_saved_register.
	* blockframe.c (deprecated_generic_get_saved_register): Update.
	* xstormy16-tdep.c (xstormy16_get_saved_register): Update.
	(xstormy16_frame_saved_register): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* ia64-tdep.c (ia64_get_saved_register): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/m32r/tm-m32r.h (GET_SAVED_REGISTER): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
@
text
@d1877 1
a1877 1
    read_register_gen (live_regnum, raw_buffer);
d2226 2
a2227 1
		  write_register_gen (FP0_REGNUM + float_arg_index, val);
d2270 1
a2270 1
		    write_register_gen (regnum, val);
d2505 1
a2505 1
	  write_register_gen (FP0_REGNUM, valbuf);
d2528 1
a2528 1
	  write_register_gen (return_register, buf);
d2531 1
a2531 1
	write_register_gen (return_register, valbuf);
@


1.73
log
@2002-10-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	definition of DO_REGISTERS_INFO.

2002-10-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_DO_REGISTERS_INFO): Rename
	DO_REGISTERS_INFO.
	gdbarch.h, gdbarch.c: Re-generate.
	* infcmd.c (default_print_registers_info): Update reference.
	* mips-tdep.c (mips_gdbarch_init): Set deprecated_do_registers_info.
	(mips_dump_tdep): Do not print DO_REGISTERS_INFO.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
@
text
@d4295 1
a4295 1
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
@


1.72
log
@	* sh-tdep.c (sh_use_struct_convention): Use definition according to ABI.
	(sh_push_arguments): Store in register with correct endianess.
	(sh_default_store_return_value): Ditto.
	(sh_gdbarch_init): Set sizeof long double to 8.
@
text
@d4292 1
a4292 1
  set_gdbarch_do_registers_info (gdbarch, sh_do_registers_info);
d4519 1
a4519 1
      set_gdbarch_do_registers_info (gdbarch, sh64_do_registers_info);
@


1.72.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 2
a2 2
/* Target-dependent code for Renesas Super-H, for GDB.
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a28 3
#include "frame-base.h"
#include "frame-unwind.h"
#include "dwarf2-frame.h"
d36 1
a36 1
#include "inferior.h"
a37 1
#include "gdb_assert.h"
a41 1
#include "osabi.h"
d48 1
a48 1
/* sh flags */
d53 15
a67 17
static void (*sh_show_regs) (void);

#define SH_NUM_REGS 59

struct sh_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  LONGEST sp_offset;
  CORE_ADDR pc;

  /* Flag showing that a frame has been created in the prologue code. */
  int uses_fp;

  /* Saved registers.  */
  CORE_ADDR saved_regs[SH_NUM_REGS];
  CORE_ADDR saved_sp;
d73 5
a77 4
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
d79 3
a81 3
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr", "spc",
d95 11
a105 10
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
d117 9
a125 8
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "ssr", "spc",
d139 5
a143 4
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
d145 3
a147 3
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr", "spc",
a158 21
sh_sh2e_register_name (int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "fpul", "fpscr",
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
d161 11
a171 10
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "", "",
    "rs", "re", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
d183 12
a194 11
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "ssr", "spc",
    "rs", "re", "", "", "", "", "", "",
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b"
      "", "", "", "", "", "", "", "",
d206 2
a207 1
  static char *register_names[] = {
d209 2
a210 2
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
d212 1
a212 1
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
d216 2
a217 2
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
d219 1
a219 1
    "ssr", "spc",
d225 1
a225 1
    "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
d227 1
a227 1
    "fv0", "fv4", "fv8", "fv12",
d239 1
a239 1
sh_sh4_nofpu_register_name (int reg_nr)
d241 62
a302 21
  static char *register_names[] = {
    /* general registers 0-15 */
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    /* 16 - 22 */
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    /* 23, 24 */
    "", "",
    /* floating point registers 25 - 40 -- not for nofpu target */
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    /* 41, 42 */
    "ssr", "spc",
    /* bank 0 43 - 50 */
    "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
    /* bank 1 51 - 58 */
    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
    /* double precision (pseudo) 59 - 66 -- not for nofpu target */
    "", "", "", "", "", "", "", "",
    /* vectors (pseudo) 67 - 70 -- not for nofpu target */
    "", "", "", "",
d304 1
d312 2
a313 21
static const char *
sh_sh4al_dsp_register_name (int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "ssr", "spc",
    "rs", "re", "", "", "", "", "", "",
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b"
      "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}
d319 2
a320 2
  static unsigned char breakpoint[] = { 0xc3, 0xc3 };

d325 103
d429 20
a448 5
   mov.l	r14,@@-r15
   sts.l	pr,@@-r15
   mov.l	<regs>,@@-r15
   sub		<room_for_loca_vars>,r15
   mov		r15,r14
a449 1
   Actually it can be more complicated than this but that's it, basically.
d452 116
a567 2
#define GET_SOURCE_REG(x)  	(((x) >> 4) & 0xf)
#define GET_TARGET_REG(x)  	(((x) >> 8) & 0xf)
d577 2
d585 1
a585 1
#define IS_ADD_IMM_SP(x) 	(((x) & 0xff00) == 0x7f00)
d597 1
a597 27
/* CV, 2003-08-28: Only suitable with Rn == SP, therefore name changed to
		   make this entirely clear. */
/* #define IS_FMOV(x)		(((x) & 0xf00f) == 0xf00b) */
#define IS_FPUSH(x)		(((x) & 0xff0f) == 0xff0b)

/* MOV Rm,Rn          Rm-->Rn        0110nnnnmmmm0011  4 <= m <= 7 */
#define IS_MOV_ARG_TO_REG(x) \
	(((x) & 0xf00f) == 0x6003 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)
/* MOV.L Rm,@@Rn               0010nnnnmmmm0010  n = 14, 4 <= m <= 7 */
#define IS_MOV_ARG_TO_IND_R14(x) \
	(((x) & 0xff0f) == 0x2e02 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)
/* MOV.L Rm,@@(disp*4,Rn)      00011110mmmmdddd  n = 14, 4 <= m <= 7 */
#define IS_MOV_ARG_TO_IND_R14_WITH_DISP(x) \
	(((x) & 0xff00) == 0x1e00 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)

/* MOV.W @@(disp*2,PC),Rn      1001nnnndddddddd */
#define IS_MOVW_PCREL_TO_REG(x)	(((x) & 0xf000) == 0x9000)
/* MOV.L @@(disp*4,PC),Rn      1101nnnndddddddd */
#define IS_MOVL_PCREL_TO_REG(x)	(((x) & 0xf000) == 0xd000)
/* SUB Rn,R15                 00111111nnnn1000 */
#define IS_SUB_REG_FROM_SP(x)	(((x) & 0xff0f) == 0x3f08)
d599 14
d615 1
a615 7
/* The following instructions are used for epilogue testing. */
#define IS_RESTORE_FP(x)	((x) == 0x6ef6)
#define IS_RTS(x)		((x) == 0x000b)
#define IS_LDS(x)  		((x) == 0x4f26)
#define IS_MOV_FP_SP(x)  	((x) == 0x6fe3)
#define IS_ADD_REG_TO_FP(x)	(((x) & 0xff0f) == 0x3e0c)
#define IS_ADD_IMM_FP(x) 	(((x) & 0xff00) == 0x7e00)
d617 4
a620 3
/* Disassemble an instruction.  */
static int
gdb_print_insn_sh (bfd_vma memaddr, disassemble_info * info)
d622 21
a642 2
  info->endian = TARGET_BYTE_ORDER;
  return print_insn_sh (memaddr, info);
d645 3
d649 1
a649 2
sh_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		     struct sh_frame_cache *cache)
d651 2
a652 6
  ULONGEST inst;
  CORE_ADDR opc;
  int offset;
  int sav_offset = 0;
  int r3_val = 0;
  int reg, sav_reg = -1;
d654 2
a655 2
  if (pc >= current_pc)
    return current_pc;
d657 1
a657 2
  cache->uses_fp = 0;
  for (opc = pc + (2 * 28); pc < opc; pc += 2)
d659 5
a663 3
      inst = read_memory_unsigned_integer (pc, 2);
      /* See where the registers will be saved to */
      if (IS_PUSH (inst))
d665 1
a665 2
	  cache->saved_regs[GET_SOURCE_REG (inst)] = cache->sp_offset;
	  cache->sp_offset += 4;
d667 1
a667 1
      else if (IS_STS (inst))
d669 2
a670 2
	  cache->saved_regs[PR_REGNUM] = cache->sp_offset;
	  cache->sp_offset += 4;
d672 19
a690 32
      else if (IS_MOV_R3 (inst))
	{
	  r3_val = ((inst & 0xff) ^ 0x80) - 0x80;
	}
      else if (IS_SHLL_R3 (inst))
	{
	  r3_val <<= 1;
	}
      else if (IS_ADD_R3SP (inst))
	{
	  cache->sp_offset += -r3_val;
	}
      else if (IS_ADD_IMM_SP (inst))
	{
	  offset = ((inst & 0xff) ^ 0x80) - 0x80;
	  cache->sp_offset -= offset;
	}
      else if (IS_MOVW_PCREL_TO_REG (inst))
	{
	  if (sav_reg < 0)
	    {
	      reg = GET_TARGET_REG (inst);
	      if (reg < 14)
		{
		  sav_reg = reg;
		  offset = (((inst & 0xff) ^ 0x80) - 0x80) << 1;
		  sav_offset =
		    read_memory_integer (((pc + 4) & ~3) + offset, 2);
		}
	    }
	}
      else if (IS_MOVL_PCREL_TO_REG (inst))
d692 3
a694 1
	  if (sav_reg < 0)
d696 9
a704 8
	      reg = (inst & 0x0f00) >> 8;
	      if (reg < 14)
		{
		  sav_reg = reg;
		  offset = (((inst & 0xff) ^ 0x80) - 0x80) << 1;
		  sav_offset =
		    read_memory_integer (((pc + 4) & ~3) + offset, 4);
		}
d706 1
a706 5
	}
      else if (IS_SUB_REG_FROM_SP (inst))
	{
	  reg = GET_SOURCE_REG (inst);
	  if (sav_reg > 0 && reg == sav_reg)
d708 2
a709 1
	      sav_reg = -1;
d711 2
a712 1
	  cache->sp_offset += sav_offset;
d714 1
a714 1
      else if (IS_FPUSH (inst))
d716 4
a719 1
	  if (read_register (FPSCR_REGNUM) & FPSCR_SZ)
d721 8
a728 1
	      cache->sp_offset += 8;
d730 1
a730 1
	  else
d732 2
a733 1
	      cache->sp_offset += 4;
d735 1
a735 12
	}
      else if (IS_MOV_SP_FP (inst))
	{
	  if (!cache->uses_fp)
	    cache->uses_fp = 1;
	  /* At this point, only allow argument register moves to other
	     registers or argument register moves to @@(X,fp) which are
	     moving the register arguments onto the stack area allocated
	     by a former add somenumber to SP call.  Don't allow moving
	     to an fp indirect address above fp + cache->sp_offset. */
	  pc += 2;
	  for (opc = pc + 12; pc < opc; pc += 2)
d737 24
a760 2
	      inst = read_memory_integer (pc, 2);
	      if (IS_MOV_ARG_TO_IND_R14 (inst))
d762 5
a766 10
		  reg = GET_SOURCE_REG (inst);
		  if (cache->sp_offset > 0)
		    cache->saved_regs[reg] = cache->sp_offset;
		}
	      else if (IS_MOV_ARG_TO_IND_R14_WITH_DISP (inst))
		{
		  reg = GET_SOURCE_REG (inst);
		  offset = (inst & 0xf) * 4;
		  if (cache->sp_offset > offset)
		    cache->saved_regs[reg] = cache->sp_offset - offset;
a767 4
	      else if (IS_MOV_ARG_TO_REG (inst))
		continue;
	      else
		break;
d769 2
a770 1
	  break;
a771 6
#if 0				/* This used to just stop when it found an instruction that
				   was not considered part of the prologue.  Now, we just
				   keep going looking for likely instructions. */
      else
	break;
#endif
d774 1
a774 1
  return pc;
a776 4
/* Skip any prologue before the guts of a function */

/* Skip the prologue using the debug information. If this fails we'll
   fall back on the 'guess' method below. */
d778 1
a778 1
after_prologue (CORE_ADDR pc)
d780 4
a783 2
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;
d785 1
a785 4
  /* If we can not find the symbol in the partial symbol table, then
     there is no hope we can determine the function's start address
     with this code.  */
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
d788 61
a848 2
  /* Get the line associated with FUNC_ADDR.  */
  sal = find_pc_line (func_addr, 0);
d850 1
a850 9
  /* There are only two cases to consider.  First, the end of the source line
     is within the function bounds.  In that case we return the end of the
     source line.  Second is the end of the source line extends beyond the
     bounds of the current function.  We need to use the slow code to
     examine instructions in that case.  */
  if (sal.end < func_end)
    return sal.end;
  else
    return 0;
d854 1
a854 1
sh_skip_prologue (CORE_ADDR start_pc)
d856 1
a856 2
  CORE_ADDR pc;
  struct sh_frame_cache cache;
d861 1
a861 1
  pc = after_prologue (start_pc);
d865 5
a869 2
  if (pc)
    return max (pc, start_pc);
d871 4
a874 4
  cache.sp_offset = -4;
  pc = sh_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache);
  if (!cache.uses_fp)
    return start_pc;
d876 5
a880 1
  return pc;
d883 1
a883 49
/* The ABI says:

   Aggregate types not bigger than 8 bytes that have the same size and
   alignment as one of the integer scalar types are returned in the
   same registers as the integer type they match.

   For example, a 2-byte aligned structure with size 2 bytes has the
   same size and alignment as a short int, and will be returned in R0.
   A 4-byte aligned structure with size 8 bytes has the same size and
   alignment as a long long int, and will be returned in R0 and R1.

   When an aggregate type is returned in R0 and R1, R0 contains the
   first four bytes of the aggregate, and R1 contains the
   remainder. If the size of the aggregate type is not a multiple of 4
   bytes, the aggregate is tail-padded up to a multiple of 4
   bytes. The value of the padding is undefined. For little-endian
   targets the padding will appear at the most significant end of the
   last element, for big-endian targets the padding appears at the
   least significant end of the last element.

   All other aggregate types are returned by address. The caller
   function passes the address of an area large enough to hold the
   aggregate value in R2. The called function stores the result in
   this location.

   To reiterate, structs smaller than 8 bytes could also be returned
   in memory, if they don't pass the "same size and alignment as an
   integer type" rule.

   For example, in

   struct s { char c[3]; } wibble;
   struct s foo(void) {  return wibble; }

   the return value from foo() will be in memory, not
   in R0, because there is no 3-byte integer type.

   Similarly, in 

   struct s { char c[2]; } wibble;
   struct s foo(void) {  return wibble; }

   because a struct containing two chars has alignment 1, that matches
   type char, but size 2, that matches type short.  There's no integer
   type that has alignment 1 and size 2, so the struct is returned in
   memory.

*/

d887 3
d892 4
d897 5
a901 4
  /* Non-power of 2 length types and types bigger than 8 bytes (which don't
     fit in two registers anyway) use struct convention.  */
  if (len != 1 && len != 2 && len != 4 && len != 8)
    return 1;
d903 2
a904 4
  /* Scalar types and aggregate types with exactly one field are aligned
     by definition.  They are returned in registers.  */
  if (nelem <= 1)
    return 0;
d906 6
a911 4
  /* If the first field in the aggregate has the same length as the entire
     aggregate type, the type is returned in registers.  */
  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == len)
    return 0;
d913 7
a919 5
  /* If the size of the aggregate is 8 bytes and the first field is
     of size 4 bytes its alignment is equal to long long's alignment,
     so it's returned in registers.  */
  if (len == 8 && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)
    return 0;
d921 3
a923 3
  /* Otherwise use struct convention.  */
  return 1;
}
d925 2
a926 3
/* Extract from an array REGBUF containing the (raw) register state
   the address in which a function should return its structure value,
   as a CORE_ADDR (or an expression that can be used as one).  */
d928 1
a928 1
sh_extract_struct_value_address (struct regcache *regcache)
d930 7
a936 1
  ULONGEST addr;
d938 25
a962 2
  regcache_cooked_read_unsigned (regcache, STRUCT_RETURN_REGNUM, &addr);
  return addr;
d966 1
a966 1
sh_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
d968 14
a981 1
  return sp & ~3;
d984 338
a1321 2
/* Function: push_dummy_call (formerly push_arguments)
   Setup the function arguments for calling a function in the inferior.
d1323 2
a1324 4
   On the Renesas SH architecture, there are four registers (R4 to R7)
   which are dedicated for passing function arguments.  Up to the first
   four arguments (depending on size) may go into these registers.
   The rest go on the stack.
d1326 2
a1327 3
   MVS: Except on SH variants that have floating point registers.
   In that case, float and double arguments are passed in the same
   manner, but using FP registers instead of GP registers.
d1329 3
a1331 4
   Arguments that are smaller than 4 bytes will still take up a whole
   register or a whole 32-bit word on the stack, and will be 
   right-justified in the register or the stack word.  This includes
   chars, shorts, and small aggregate types.
d1333 2
a1334 7
   Arguments that are larger than 4 bytes may be split between two or 
   more registers.  If there are not enough registers free, an argument
   may be passed partly in a register (or registers), and partly on the
   stack.  This includes doubles, long longs, and larger aggregates. 
   As far as I know, there is no upper limit to the size of aggregates 
   that will be passed in this way; in other words, the convention of 
   passing a pointer to a large aggregate instead of a copy is not used.
d1336 2
a1337 4
   MVS: The above appears to be true for the SH variants that do not
   have an FPU, however those that have an FPU appear to copy the
   aggregate argument onto the stack (and not place it in registers)
   if it is larger than 16 bytes (four GP registers).
d1339 2
a1340 12
   An exceptional case exists for struct arguments (and possibly other
   aggregates such as arrays) if the size is larger than 4 bytes but 
   not a multiple of 4 bytes.  In this case the argument is never split 
   between the registers and the stack, but instead is copied in its
   entirety onto the stack, AND also copied into as many registers as 
   there is room for.  In other words, space in registers permitting, 
   two copies of the same argument are passed in.  As far as I can tell,
   only the one on the stack is used, although that may be a function 
   of the level of compiler optimization.  I suspect this is a compiler
   bug.  Arguments of these odd sizes are left-justified within the 
   word (as opposed to arguments smaller than 4 bytes, which are 
   right-justified).
d1342 5
a1346 8
   If the function is to return an aggregate type such as a struct, it 
   is either returned in the normal return value register R0 (if its 
   size is no greater than one byte), or else the caller must allocate
   space into which the callee will copy the return value (if the size
   is greater than one byte).  In this case, a pointer to the return 
   value location is passed into the callee in register R2, which does 
   not displace any of the other arguments passed in via registers R4
   to R7.   */
d1348 6
a1353 3
/* Helper function to justify value in register according to endianess. */
static char *
sh_justify_value_in_reg (struct value *val, int len)
a1354 1
  static char valbuf[4];
d1356 1
a1356 2
  memset (valbuf, 0, sizeof (valbuf));
  if (len < 4)
d1358 2
a1359 3
      /* value gets right-justified in the register or stack word */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	memcpy (valbuf + (4 - len), (char *) VALUE_CONTENTS (val), len);
d1361 1
a1361 2
	memcpy (valbuf, (char *) VALUE_CONTENTS (val), len);
      return valbuf;
d1363 3
a1365 1
  return (char *) VALUE_CONTENTS (val);
d1368 2
a1369 3
/* Helper function to eval number of bytes to allocate on stack. */
static CORE_ADDR
sh_stack_allocsize (int nargs, struct value **args)
d1371 4
a1374 4
  int stack_alloc = 0;
  while (nargs-- > 0)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[nargs])) + 3) & ~3);
  return stack_alloc;
d1377 184
a1560 3
/* Helper functions for getting the float arguments right.  Registers usage
   depends on the ABI and the endianess.  The comments should enlighten how
   it's intended to work. */
d1562 21
a1582 2
/* This array stores which of the float arg registers are already in use. */
static int flt_argreg_array[FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM + 1];
a1583 1
/* This function just resets the above array to "no reg used so far". */
d1585 1
a1585 1
sh_init_flt_argreg (void)
d1587 128
a1714 1
  memset (flt_argreg_array, 0, sizeof flt_argreg_array);
d1717 4
a1720 4
/* This function returns the next register to use for float arg passing.
   It returns either a valid value between FLOAT_ARG0_REGNUM and
   FLOAT_ARGLAST_REGNUM if a register is available, otherwise it returns 
   FLOAT_ARGLAST_REGNUM + 1 to indicate that no register is available.
d1722 29
a1750 6
   Note that register number 0 in flt_argreg_array corresponds with the
   real float register fr4.  In contrast to FLOAT_ARG0_REGNUM (value is
   29) the parity of the register number is preserved, which is important
   for the double register passing test (see the "argreg & 1" test below). */
static int
sh_next_flt_argreg (int len)
d1752 7
a1758 1
  int argreg;
d1760 19
a1778 5
  /* First search for the next free register. */
  for (argreg = 0; argreg <= FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM;
       ++argreg)
    if (!flt_argreg_array[argreg])
      break;
d1780 34
a1813 3
  /* No register left? */
  if (argreg > FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM)
    return FLOAT_ARGLAST_REGNUM + 1;
d1815 1
a1815 1
  if (len == 8)
d1817 1
a1817 2
      /* Doubles are always starting in a even register number. */
      if (argreg & 1)
d1819 76
a1894 1
	  flt_argreg_array[argreg] = 1;
d1896 5
a1900 1
	  ++argreg;
d1902 24
a1925 6
	  /* No register left? */
	  if (argreg > FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM)
	    return FLOAT_ARGLAST_REGNUM + 1;
	}
      /* Also mark the next register as used. */
      flt_argreg_array[argreg + 1] = 1;
d1927 17
a1943 1
  else if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d1945 22
a1966 3
      /* In little endian, gcc passes floats like this: f5, f4, f7, f6, ... */
      if (!flt_argreg_array[argreg + 1])
	++argreg;
d1968 1
a1968 2
  flt_argreg_array[argreg] = 1;
  return FLOAT_ARG0_REGNUM + argreg;
d1971 2
a1972 1
/* Helper function which figures out, if a type is treated like a float type.
d1974 4
a1977 3
   The FPU ABIs have a special way how to treat types as float types.
   Structures with exactly one member, which is of type float or double, are
   treated exactly as the base types float or double:
d1979 4
a1982 3
     struct sf {
       float f;
     };
d1984 7
a1990 3
     struct sd {
       double d;
     };
d1992 12
a2003 1
   are handled the same way as just
d2005 8
a2012 1
     float f;
d2014 3
a2016 11
     double d;

   As a result, arguments of these struct types are pushed into floating point
   registers exactly as floats or doubles, using the same decision algorithm.

   The same is valid if these types are used as function return types.  The
   above structs are returned in fr0 resp. fr0,fr1 instead of in r0, r0,r1
   or even using struct convention as it is for other structs.  */

static int
sh_treat_as_flt_p (struct type *type)
d2018 2
a2019 31
  int len = TYPE_LENGTH (type);

  /* Ordinary float types are obviously treated as float.  */
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    return 1;
  /* Otherwise non-struct types are not treated as float.  */
  if (TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return 0;
  /* Otherwise structs with more than one memeber are not treated as float.  */
  if (TYPE_NFIELDS (type) != 1)
    return 0;
  /* Otherwise if the type of that member is float, the whole type is
     treated as float.  */
  if (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_FLT)
    return 1;
  /* Otherwise it's not treated as float.  */
  return 0;
}

static CORE_ADDR
sh_push_dummy_call_fpu (struct gdbarch *gdbarch,
			CORE_ADDR func_addr,
			struct regcache *regcache,
			CORE_ADDR bp_addr, int nargs,
			struct value **args,
			CORE_ADDR sp, int struct_return,
			CORE_ADDR struct_addr)
{
  int stack_offset = 0;
  int argreg = ARG0_REGNUM;
  int flt_argreg = 0;
d2024 4
a2027 3
  int len, reg_size = 0;
  int pass_on_stack = 0;
  int treat_as_flt;
d2030 1
a2030 1
  sp = sh_frame_align (gdbarch, sp);
d2032 2
d2035 1
a2035 2
    regcache_cooked_write_unsigned (regcache,
				    STRUCT_RETURN_REGNUM, struct_addr);
d2037 4
a2040 5
  /* make room on stack for args */
  sp -= sh_stack_allocsize (nargs, args);

  /* Initialize float argument mechanism. */
  sh_init_flt_argreg ();
d2045 3
a2047 1
  for (argnum = 0; argnum < nargs; argnum++)
d2051 13
a2063 15
      val = sh_justify_value_in_reg (args[argnum], len);

      /* Some decisions have to be made how various types are handled.
         This also differs in different ABIs. */
      pass_on_stack = 0;

      /* Find out the next register to use for a floating point value. */
      treat_as_flt = sh_treat_as_flt_p (type);
      if (treat_as_flt)
	flt_argreg = sh_next_flt_argreg (len);
      /* In contrast to non-FPU CPUs, arguments are never split between
	 registers and stack.  If an argument doesn't fit in the remaining
	 registers it's always pushed entirely on the stack.  */
      else if (len > ((ARGLAST_REGNUM - argreg + 1) * 4))
	pass_on_stack = 1;
d2065 4
d2071 6
a2076 31
	  if ((treat_as_flt && flt_argreg > FLOAT_ARGLAST_REGNUM)
	      || (!treat_as_flt && (argreg > ARGLAST_REGNUM
	                            || pass_on_stack)))
	    {
	      /* The data goes entirely on the stack, 4-byte aligned. */
	      reg_size = (len + 3) & ~3;
	      write_memory (sp + stack_offset, val, reg_size);
	      stack_offset += reg_size;
	    }
	  else if (treat_as_flt && flt_argreg <= FLOAT_ARGLAST_REGNUM)
	    {
	      /* Argument goes in a float argument register.  */
	      reg_size = register_size (gdbarch, flt_argreg);
	      regval = extract_unsigned_integer (val, reg_size);
	      /* In little endian mode, float types taking two registers
	         (doubles on sh4, long doubles on sh2e, sh3e and sh4) must
		 be stored swapped in the argument registers.  The below
		 code first writes the first 32 bits in the next but one
		 register, increments the val and len values accordingly
		 and then proceeds as normal by writing the second 32 bits
		 into the next register. */
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE
	          && TYPE_LENGTH (type) == 2 * reg_size)
	        {
		  regcache_cooked_write_unsigned (regcache, flt_argreg + 1,
						  regval);
		  val += reg_size;
		  len -= reg_size;
		  regval = extract_unsigned_integer (val, reg_size);
		}
	      regcache_cooked_write_unsigned (regcache, flt_argreg++, regval);
d2078 5
a2082 2
	  else if (!treat_as_flt && argreg <= ARGLAST_REGNUM)
	    {
d2084 2
a2085 3
	      reg_size = register_size (gdbarch, argreg);
	      regval = extract_unsigned_integer (val, reg_size);
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
d2087 5
a2091 3
	  /* Store the value one register at a time or in one step on stack.  */
	  len -= reg_size;
	  val += reg_size;
d2094 2
d2097 15
a2111 5
  /* Store return address. */
  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);

  /* Update stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp);
d2113 2
a2114 2
  return sp;
}
d2117 2
a2118 7
sh_push_dummy_call_nofpu (struct gdbarch *gdbarch,
			  CORE_ADDR func_addr,
			  struct regcache *regcache,
			  CORE_ADDR bp_addr,
			  int nargs, struct value **args,
			  CORE_ADDR sp, int struct_return,
			  CORE_ADDR struct_addr)
d2120 6
a2125 2
  int stack_offset = 0;
  int argreg = ARG0_REGNUM;
d2130 11
a2140 1
  int len, reg_size;
d2142 2
a2143 2
  /* first force sp to a 4-byte alignment */
  sp = sh_frame_align (gdbarch, sp);
d2146 1
a2146 2
    regcache_cooked_write_unsigned (regcache,
				    STRUCT_RETURN_REGNUM, struct_addr);
d2148 4
a2151 2
  /* make room on stack for args */
  sp -= sh_stack_allocsize (nargs, args);
d2154 8
a2161 3
     registers, and push the rest onto the stack.  There are 16 bytes
     in four registers available.  Loop thru args from first to last.  */
  for (argnum = 0; argnum < nargs; argnum++)
d2165 19
a2183 1
      val = sh_justify_value_in_reg (args[argnum], len);
d2185 1
a2185 3
      while (len > 0)
	{
	  if (argreg > ARGLAST_REGNUM)
d2187 22
a2208 5
	      /* The remainder of the data goes entirely on the stack,
	         4-byte aligned. */
	      reg_size = (len + 3) & ~3;
	      write_memory (sp + stack_offset, val, reg_size);
	      stack_offset += reg_size;
d2210 5
a2214 1
	  else if (argreg <= ARGLAST_REGNUM)
d2216 20
a2235 4
	      /* there's room in a register */
	      reg_size = register_size (gdbarch, argreg);
	      regval = extract_unsigned_integer (val, reg_size);
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
d2237 43
a2279 5
	  /* Store the value reg_size bytes at a time.  This means that things
	     larger than reg_size bytes may go partly in registers and partly
	     on the stack.  */
	  len -= reg_size;
	  val += reg_size;
d2282 14
d2297 13
a2309 2
  /* Store return address. */
  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);
d2311 8
a2318 2
  /* Update stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp);
d2320 4
a2323 1
  return sp;
d2331 1
a2331 2
sh_default_extract_return_value (struct type *type, struct regcache *regcache,
				 void *valbuf)
d2336 1
a2336 1

d2339 17
a2355 1
      ULONGEST c;
d2357 32
a2388 2
      regcache_cooked_read_unsigned (regcache, R0_REGNUM, &c);
      store_unsigned_integer (valbuf, len, c);
d2390 1
a2390 1
  else if (len == 8)
d2392 5
a2396 3
      int i, regnum = R0_REGNUM;
      for (i = 0; i < len; i += 4)
	regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
d2403 1
a2403 2
sh3e_sh4_extract_return_value (struct type *type, struct regcache *regcache,
			       void *valbuf)
d2405 6
a2410 1
  if (sh_treat_as_flt_p (type))
d2412 23
a2434 7
      int len = TYPE_LENGTH (type);
      int i, regnum = FP0_REGNUM;
      for (i = 0; i < len; i += 4)
	if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	  regcache_raw_read (regcache, regnum++, (char *) valbuf + len - 4 - i);
	else
	  regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
d2437 16
a2452 1
    sh_default_extract_return_value (type, regcache, valbuf);
d2462 1
a2462 2
sh_default_store_return_value (struct type *type, struct regcache *regcache,
			       const void *valbuf)
d2464 1
a2464 2
  ULONGEST val;
  int len = TYPE_LENGTH (type);
d2466 1
a2466 1
  if (len <= 4)
d2468 9
a2476 2
      val = extract_unsigned_integer (valbuf, len);
      regcache_cooked_write_unsigned (regcache, R0_REGNUM, val);
d2479 12
a2490 5
    {
      int i, regnum = R0_REGNUM;
      for (i = 0; i < len; i += 4)
	regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
    }
d2494 1
a2494 2
sh3e_sh4_store_return_value (struct type *type, struct regcache *regcache,
			     const void *valbuf)
d2496 4
a2499 1
  if (sh_treat_as_flt_p (type))
d2501 10
a2510 4
      int len = TYPE_LENGTH (type);
      int i, regnum = FP0_REGNUM;
      for (i = 0; i < len; i += 4)
	regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
d2513 19
a2531 1
    sh_default_store_return_value (type, regcache, valbuf);
d2539 2
d2543 2
a2544 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2552 9
a2560 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d2562 8
a2569 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d2575 2
d2579 2
a2580 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2588 2
a2589 2
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d2591 9
a2599 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d2601 8
a2608 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d2613 1
a2613 1
sh2e_show_regs (void)
d2615 2
d2619 2
a2620 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2627 3
d2631 2
a2632 2
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d2634 9
a2642 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d2644 8
a2651 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d2653 18
a2670 2
  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 0), (long) read_register (FP0_REGNUM + 1), (long) read_register (FP0_REGNUM + 2), (long) read_register (FP0_REGNUM + 3), (long) read_register (FP0_REGNUM + 4), (long) read_register (FP0_REGNUM + 5), (long) read_register (FP0_REGNUM + 6), (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 8), (long) read_register (FP0_REGNUM + 9), (long) read_register (FP0_REGNUM + 10), (long) read_register (FP0_REGNUM + 11), (long) read_register (FP0_REGNUM + 12), (long) read_register (FP0_REGNUM + 13), (long) read_register (FP0_REGNUM + 14), (long) read_register (FP0_REGNUM + 15));
d2674 1
a2674 1
sh3e_show_regs (void)
d2676 2
d2680 2
a2681 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2688 1
d2690 5
a2694 5
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d2696 9
a2704 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d2706 24
a2729 7
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 0), (long) read_register (FP0_REGNUM + 1), (long) read_register (FP0_REGNUM + 2), (long) read_register (FP0_REGNUM + 3), (long) read_register (FP0_REGNUM + 4), (long) read_register (FP0_REGNUM + 5), (long) read_register (FP0_REGNUM + 6), (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 8), (long) read_register (FP0_REGNUM + 9), (long) read_register (FP0_REGNUM + 10), (long) read_register (FP0_REGNUM + 11), (long) read_register (FP0_REGNUM + 12), (long) read_register (FP0_REGNUM + 13), (long) read_register (FP0_REGNUM + 14), (long) read_register (FP0_REGNUM + 15));
d2733 1
a2733 1
sh3_dsp_show_regs (void)
d2735 3
d2740 2
a2741 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
a2747 1

d2749 5
a2753 2
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d2755 18
a2772 1
  printf_filtered (" DSR=%08lx", (long) read_register (DSR_REGNUM));
d2774 22
a2795 25
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered
    ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
     (long) read_register (A0G_REGNUM) & 0xff,
     (long) read_register (A0_REGNUM), (long) read_register (M0_REGNUM),
     (long) read_register (X0_REGNUM), (long) read_register (Y0_REGNUM),
     (long) read_register (RS_REGNUM), (long) read_register (MOD_REGNUM));
  printf_filtered ("A1G=%02lx A1=%08lx M1=%08lx X1=%08lx Y1=%08lx RE=%08lx\n",
		   (long) read_register (A1G_REGNUM) & 0xff,
		   (long) read_register (A1_REGNUM),
		   (long) read_register (M1_REGNUM),
		   (long) read_register (X1_REGNUM),
		   (long) read_register (Y1_REGNUM),
		   (long) read_register (RE_REGNUM));
d2799 1
a2799 1
sh4_show_regs (void)
d2801 2
a2802 1
  int pr = read_register (FPSCR_REGNUM) & 0x80000;
d2805 2
a2806 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
a2812 6
  printf_filtered (" SSR=%08lx SPC=%08lx",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d2814 308
a3121 11
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d3123 4
a3126 23
  printf_filtered ((pr
		    ? "DR0-DR6  %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n"
		    :
		    "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered ((pr ?
		    "DR8-DR14 %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n" :
		    "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
d3129 4
a3132 2
static void
sh4_nofpu_show_regs (void)
d3134 2
a3135 6
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d3137 4
a3140 6
  printf_filtered ("GBR=%08lx VBR=%08lx",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" SSR=%08lx SPC=%08lx",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d3142 8
a3149 11
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d3152 2
a3153 2
static void
sh_dsp_show_regs (void)
d3155 1
a3155 6
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d3157 14
a3170 3
  printf_filtered ("GBR=%08lx VBR=%08lx",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM));
d3172 3
a3174 1
  printf_filtered (" DSR=%08lx", (long) read_register (DSR_REGNUM));
d3176 6
a3181 25
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered
    ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
     (long) read_register (A0G_REGNUM) & 0xff,
     (long) read_register (A0_REGNUM), (long) read_register (M0_REGNUM),
     (long) read_register (X0_REGNUM), (long) read_register (Y0_REGNUM),
     (long) read_register (RS_REGNUM), (long) read_register (MOD_REGNUM));
  printf_filtered ("A1G=%02lx A1=%08lx M1=%08lx X1=%08lx Y1=%08lx RE=%08lx\n",
		   (long) read_register (A1G_REGNUM) & 0xff,
		   (long) read_register (A1_REGNUM),
		   (long) read_register (M1_REGNUM),
		   (long) read_register (X1_REGNUM),
		   (long) read_register (Y1_REGNUM),
		   (long) read_register (RE_REGNUM));
d3184 3
a3186 2
static void
sh_show_regs_command (char *args, int from_tty)
d3188 5
a3192 2
  if (sh_show_regs)
    (*sh_show_regs) ();
d3198 1
a3198 1
sh_sh3e_register_type (struct gdbarch *gdbarch, int reg_nr)
d3200 2
d3203 2
a3204 1
       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
d3220 1
a3220 1
sh_sh4_register_type (struct gdbarch *gdbarch, int reg_nr)
d3222 2
d3225 2
a3226 1
       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
d3228 2
a3229 1
  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
d3231 2
a3232 1
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
d3239 33
a3271 1
sh_default_register_type (struct gdbarch *gdbarch, int reg_nr)
d3304 18
a3321 1
				    char *from, char *to)
d3323 13
a3335 1
  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
d3338 2
a3339 3
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
			       from, &val);
      store_typed_floating (to, type, val);
d3342 1
a3342 2
    error
      ("sh_register_convert_to_virtual called with non DR register number");
d3349 4
a3352 1
  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
d3354 2
a3355 3
      DOUBLEST val = extract_typed_floating (from, type);
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword,
				 &val, to);
d3358 1
a3358 1
    error ("sh_register_convert_to_raw called with non DR register number");
d3361 3
a3363 3
/* For vectors of 4 floating point registers. */
static int
fv_reg_base_num (int fv_regnum)
d3365 1
a3365 1
  int fp_regnum;
d3367 6
a3372 3
  fp_regnum = FP0_REGNUM + (fv_regnum - FV0_REGNUM) * 4;
  return fp_regnum;
}
d3374 10
a3383 8
/* For double precision floating point registers, i.e 2 fp regs.*/
static int
dr_reg_base_num (int dr_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + (dr_regnum - DR0_REGNUM) * 2;
  return fp_regnum;
d3386 1
a3386 1
static void
d3391 2
a3392 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3394 2
a3395 1
  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
d3399 1
a3399 1
      /* Build the value in the provided buffer. */
d3402 1
a3402 1
	regcache_raw_read (regcache, base_regnum + portion,
d3404 1
a3404 2
			    + register_size (gdbarch,
					     base_regnum) * portion));
d3407 1
a3407 2
					  gdbarch_register_type (gdbarch,
								 reg_nr),
d3410 2
a3411 1
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
d3417 1
a3417 1
	regcache_raw_read (regcache, base_regnum + portion,
d3419 1
a3419 2
			    + register_size (gdbarch,
					     base_regnum) * portion));
d3424 166
d3594 2
a3595 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3597 2
a3598 1
  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
d3603 2
a3604 2
      sh_sh4_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr),
				      reg_nr, buffer, temp_buffer);
d3608 11
d3620 26
d3647 13
a3659 2
			     + register_size (gdbarch,
					      base_regnum) * portion));
d3661 3
a3663 1
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
d3667 186
a3852 7
      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 4; portion++)
	regcache_raw_write (regcache, base_regnum + portion,
			    ((char *) buffer
			     + register_size (gdbarch,
					      base_regnum) * portion));
    }
d3855 1
a3855 1
/* Floating point vector of 4 float registers. */
d3857 1
a3857 2
do_fv_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int fv_regnum)
d3859 5
a3863 7
  int first_fp_reg_num = fv_reg_base_num (fv_regnum);
  fprintf_filtered (file, "fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n",
		    fv_regnum - FV0_REGNUM,
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1),
		    (int) read_register (first_fp_reg_num + 2),
		    (int) read_register (first_fp_reg_num + 3));
d3866 3
a3868 1
/* Double precision registers. */
d3870 1
a3870 2
do_dr_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int dr_regnum)
d3872 19
a3890 6
  int first_fp_reg_num = dr_reg_base_num (dr_regnum);

  fprintf_filtered (file, "dr%d\t0x%08x%08x\n",
		    dr_regnum - DR0_REGNUM,
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1));
d3894 1
a3894 2
sh_print_pseudo_register (struct gdbarch *gdbarch, struct ui_file *file,
			  int regnum)
d3896 2
d3901 6
a3906 4
  else if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
    do_dr_register_info (gdbarch, file, regnum);
  else if (regnum >= FV0_REGNUM && regnum <= FV_LAST_REGNUM)
    do_fv_register_info (gdbarch, file, regnum);
d3910 1
a3910 1
sh_do_fp_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d3913 1
a3913 1
  double flt;			/* double extracted from raw hex data */
d3918 1
a3918 1
  raw_buffer = (char *) alloca (register_size (gdbarch, FP0_REGNUM));
d3921 1
a3921 1
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
d3924 1
a3924 1
  /* Get the register as a number */
d3928 2
a3929 2
  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);
d3933 1
a3933 1
    fprintf_filtered (file, "<invalid float>");
d3935 1
a3935 1
    fprintf_filtered (file, "%-10.9g", flt);
d3938 2
a3939 2
  fprintf_filtered (file, "\t(raw 0x");
  for (j = 0; j < register_size (gdbarch, regnum); j++)
d3941 3
a3943 4
      int idx = (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
		 ? j
		 : register_size (gdbarch, regnum) - 1 - j);
      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
d3945 47
a3991 2
  fprintf_filtered (file, ")");
  fprintf_filtered (file, "\n");
d3995 1
a3995 1
sh_do_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d3997 1
a3997 1
  char raw_buffer[MAX_REGISTER_SIZE];
d3999 2
a4000 2
  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);
d4003 9
a4011 9
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
    fprintf_filtered (file, "*value not available*\n");

  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 'x', 1, 0, Val_pretty_default);
  fprintf_filtered (file, "\t");
  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 0, 1, 0, Val_pretty_default);
  fprintf_filtered (file, "\n");
d4015 1
a4015 1
sh_print_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d4023 2
a4024 3
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
	sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
d4026 1
a4026 1
	sh_do_register (gdbarch, file, regnum);	/* All other regs */
d4030 1
a4030 3
    {
      sh_print_pseudo_register (gdbarch, file, regnum);
    }
d4033 2
a4034 3
static void
sh_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			 struct frame_info *frame, int regnum, int fpregs)
d4041 1
a4041 1
      sh_print_register (gdbarch, file, regnum);
d4053 1
a4053 1
	    {
d4058 1
a4058 2
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	      TYPE_CODE_FLT)
d4063 2
a4064 2
		  sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
		  regnum++;
d4067 1
a4067 1
		regnum += (FP_LAST_REGNUM - FP0_REGNUM);	/* skip FP regs */
d4071 1
a4071 1
	      sh_do_register (gdbarch, file, regnum);	/* All other regs */
d4079 1
a4079 1
	    sh_print_pseudo_register (gdbarch, file, regnum);
d4085 35
d4143 1
a4143 1
      lmo.r_map_size = 4;
d4148 1
a4148 1
      lmo.l_addr_size = 4;
d4151 1
a4151 1
      lmo.l_name_size = 4;
d4154 1
a4154 1
      lmo.l_next_size = 4;
d4157 1
a4157 1
      lmo.l_prev_size = 4;
d4160 1
a4160 1
  return lmp;
d4164 24
d4193 3
a4195 3
  if (nr >= DSR_REGNUM && nr <= Y1_REGNUM)
    return nr - DSR_REGNUM + SIM_SH_DSR_REGNUM;
  if (nr == MOD_REGNUM)
d4197 1
a4197 1
  if (nr == RS_REGNUM)
d4199 1
a4199 1
  if (nr == RE_REGNUM)
d4201 2
a4202 2
  if (nr >= R0_BANK_REGNUM && nr <= R7_BANK_REGNUM)
    return nr - R0_BANK_REGNUM + SIM_SH_R0_BANK_REGNUM;
d4205 2
d4208 2
a4209 2
static struct sh_frame_cache *
sh_alloc_frame_cache (void)
d4211 7
a4217 4
  struct sh_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct sh_frame_cache);
d4219 1
a4219 5
  /* Base address.  */
  cache->base = 0;
  cache->saved_sp = 0;
  cache->sp_offset = 0;
  cache->pc = 0;
d4221 1
a4221 6
  /* Frameless until proven otherwise.  */
  cache->uses_fp = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where fp is supposed to be stored).  */
  for (i = 0; i < SH_NUM_REGS; i++)
d4223 2
a4224 1
      cache->saved_regs[i] = -1;
d4227 4
a4230 31
  return cache;
}

static struct sh_frame_cache *
sh_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct sh_frame_cache *cache;
  CORE_ADDR current_pc;
  int i;

  if (*this_cache)
    return *this_cache;

  cache = sh_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame. */
  cache->base = frame_unwind_register_unsigned (next_frame, FP_REGNUM);
  if (cache->base == 0)
    return cache;

  cache->pc = frame_func_unwind (next_frame);
  current_pc = frame_pc_unwind (next_frame);
  if (cache->pc != 0)
    sh_analyze_prologue (cache->pc, current_pc, cache);

  if (!cache->uses_fp)
d4232 4
a4235 8
      /* We didn't find a valid frame, which means that CACHE->base
         currently holds the frame pointer for our calling frame.  If
         we're at the start of a function, or somewhere half-way its
         prologue, the function's frame probably hasn't been fully
         setup yet.  Try to reconstruct the base address for the stack
         frame by looking at the stack pointer.  For truly "frameless"
         functions this might work too.  */
      cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d4238 4
a4241 3
  /* Now that we have the base address for the stack frame we can
     calculate the value of sp in the calling frame.  */
  cache->saved_sp = cache->base + cache->sp_offset;
d4243 1
a4243 5
  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < SH_NUM_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] = cache->saved_sp - cache->saved_regs[i] - 4;
d4245 32
a4276 2
  return cache;
}
d4278 1
a4278 7
static void
sh_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			int regnum, int *optimizedp,
			enum lval_type *lvalp, CORE_ADDR *addrp,
			int *realnump, void *valuep)
{
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);
d4280 27
a4306 84
  gdb_assert (regnum >= 0);

  if (regnum == SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
	}
      return;
    }

  /* The PC of the previous frame is stored in the PR register of
     the current frame.  Frob regnum so that we pull the value from
     the correct place.  */
  if (regnum == PC_REGNUM)
    regnum = PR_REGNUM;

  if (regnum < SH_NUM_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static void
sh_frame_this_id (struct frame_info *next_frame, void **this_cache,
		  struct frame_id *this_id)
{
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  *this_id = frame_id_build (cache->saved_sp, cache->pc);
}

static const struct frame_unwind sh_frame_unwind = {
  NORMAL_FRAME,
  sh_frame_this_id,
  sh_frame_prev_register
};

static const struct frame_unwind *
sh_frame_sniffer (struct frame_info *next_frame)
{
  return &sh_frame_unwind;
}

static CORE_ADDR
sh_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, SP_REGNUM);
}

static CORE_ADDR
sh_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
}

static struct frame_id
sh_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (sh_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
}
a4307 90
static CORE_ADDR
sh_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base sh_frame_base = {
  &sh_frame_unwind,
  sh_frame_base_address,
  sh_frame_base_address,
  sh_frame_base_address
};

/* The epilogue is defined here as the area at the end of a function,
   either on the `ret' instruction itself or after an instruction which
   destroys the function's stack frame. */
static int
sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR func_addr = 0, func_end = 0;

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      ULONGEST inst;
      /* The sh epilogue is max. 14 bytes long.  Give another 14 bytes
         for a nop and some fixed data (e.g. big offsets) which are
         unfortunately also treated as part of the function (which
         means, they are below func_end. */
      CORE_ADDR addr = func_end - 28;
      if (addr < func_addr + 4)
	addr = func_addr + 4;
      if (pc < addr)
	return 0;

      /* First search forward until hitting an rts. */
      while (addr < func_end
	     && !IS_RTS (read_memory_unsigned_integer (addr, 2)))
	addr += 2;
      if (addr >= func_end)
	return 0;

      /* At this point we should find a mov.l @@r15+,r14 instruction,
         either before or after the rts.  If not, then the function has
         probably no "normal" epilogue and we bail out here. */
      inst = read_memory_unsigned_integer (addr - 2, 2);
      if (IS_RESTORE_FP (read_memory_unsigned_integer (addr - 2, 2)))
	addr -= 2;
      else if (!IS_RESTORE_FP (read_memory_unsigned_integer (addr + 2, 2)))
	return 0;

      /* Step over possible lds.l @@r15+,pr. */
      inst = read_memory_unsigned_integer (addr - 2, 2);
      if (IS_LDS (inst))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2);
	}

      /* Step over possible mov r14,r15. */
      if (IS_MOV_FP_SP (inst))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2);
	}

      /* Now check for FP adjustments, using add #imm,r14 or add rX, r14
         instructions. */
      while (addr > func_addr + 4
	     && (IS_ADD_REG_TO_FP (inst) || IS_ADD_IMM_FP (inst)))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2);
	}

      if (pc >= addr)
	return 1;
    }
  return 0;
}

static gdbarch_init_ftype sh_gdbarch_init;

static struct gdbarch *
sh_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;

  sh_show_regs = sh_generic_show_regs;
d4310 9
a4318 2
    case bfd_mach_sh2e:
      sh_show_regs = sh2e_show_regs;
d4320 10
d4331 1
d4333 21
a4354 1

d4356 1
d4358 8
a4366 1

d4368 1
d4370 13
a4383 1

d4385 1
a4385 1
    case bfd_mach_sh4al_dsp:
d4387 22
a4409 1

d4411 1
a4411 1
    case bfd_mach_sh4a:
d4413 22
d4436 55
d4492 7
a4498 4
    case bfd_mach_sh4_nofpu:
    case bfd_mach_sh4a_nofpu:
      sh_show_regs = sh4_nofpu_show_regs;
      break;
d4500 1
a4500 1
    case bfd_mach_sh5:
d4502 42
a4543 2
      /* SH5 is handled entirely in sh64-tdep.c */
      return sh64_gdbarch_init (info, arches);
d4546 5
a4550 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d4552 2
a4553 3
  /* None found, create a new architecture from the information
     provided. */
  gdbarch = gdbarch_alloc (&info, NULL);
a4556 1
  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
a4560 14
  set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);

  set_gdbarch_num_regs (gdbarch, SH_NUM_REGS);
  set_gdbarch_sp_regnum (gdbarch, 15);
  set_gdbarch_pc_regnum (gdbarch, 16);
  set_gdbarch_fp0_regnum (gdbarch, -1);
  set_gdbarch_num_pseudo_regs (gdbarch, 0);

  set_gdbarch_register_type (gdbarch, sh_default_register_type);

  set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);

  set_gdbarch_breakpoint_from_pc (gdbarch, sh_breakpoint_from_pc);
  set_gdbarch_use_struct_convention (gdbarch, sh_use_struct_convention);
d4562 15
a4576 4
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh);
  set_gdbarch_register_sim_regno (gdbarch, legacy_register_sim_regno);

  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);
d4578 2
a4579 4
  set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
  set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    sh_extract_struct_value_address);
d4581 1
a4586 2
  set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);

d4588 7
a4594 2
  set_gdbarch_frameless_function_invocation (gdbarch,
					     frameless_look_for_prologue);
d4597 1
a4597 5
  set_gdbarch_frame_align (gdbarch, sh_frame_align);
  set_gdbarch_unwind_sp (gdbarch, sh_unwind_sp);
  set_gdbarch_unwind_pc (gdbarch, sh_unwind_pc);
  set_gdbarch_unwind_dummy_id (gdbarch, sh_unwind_dummy_id);
  frame_base_set_default (gdbarch, &sh_frame_base);
d4599 3
a4601 1
  set_gdbarch_in_function_epilogue_p (gdbarch, sh_in_function_epilogue_p);
d4603 2
a4604 5
  switch (info.bfd_arch_info->mach)
    {
    case bfd_mach_sh:
      set_gdbarch_register_name (gdbarch, sh_sh_register_name);
      break;
d4606 4
a4609 3
    case bfd_mach_sh2:
      set_gdbarch_register_name (gdbarch, sh_sh_register_name);
      break;
d4611 2
a4612 71
    case bfd_mach_sh2e:
      /* doubles on sh2e and sh3e are actually 4 byte. */
      set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);

      set_gdbarch_register_name (gdbarch, sh_sh2e_register_name);
      set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
      break;

    case bfd_mach_sh_dsp:
      set_gdbarch_register_name (gdbarch, sh_sh_dsp_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
      break;

    case bfd_mach_sh3:
      set_gdbarch_register_name (gdbarch, sh_sh3_register_name);
      break;

    case bfd_mach_sh3e:
      /* doubles on sh2e and sh3e are actually 4 byte. */
      set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);

      set_gdbarch_register_name (gdbarch, sh_sh3e_register_name);
      set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
      break;

    case bfd_mach_sh3_dsp:
      set_gdbarch_register_name (gdbarch, sh_sh3_dsp_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
      break;

    case bfd_mach_sh4:
    case bfd_mach_sh4a:
      set_gdbarch_register_name (gdbarch, sh_sh4_register_name);
      set_gdbarch_register_type (gdbarch, sh_sh4_register_type);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      set_gdbarch_num_pseudo_regs (gdbarch, 12);
      set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
      break;

    case bfd_mach_sh4_nofpu:
    case bfd_mach_sh4a_nofpu:
      set_gdbarch_register_name (gdbarch, sh_sh4_nofpu_register_name);
      break;

    case bfd_mach_sh4al_dsp:
      set_gdbarch_register_name (gdbarch, sh_sh4al_dsp_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
      break;

    default:
      set_gdbarch_register_name (gdbarch, sh_generic_register_name);
      break;
    }

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);
d4614 2
a4615 4
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, sh_frame_sniffer);

  return gdbarch;
a4617 2
extern initialize_file_ftype _initialize_sh_tdep;	/* -Wmissing-prototypes */

d4622 2
a4623 2

  gdbarch_register (bfd_arch_sh, sh_gdbarch_init, NULL);
@


1.72.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2242 2
a2243 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
d2247 2
@


1.71
log
@2002-09-17  Andrew Cagney  <cagney@@redhat.com>

	* h8300-tdep.c (h8300_frame_chain):
	(h8300_frame_saved_pc):

	* blockframe.c (deprecated_read_register_dummy): Rename
	generic_read_register_dummy.
	* frame.c (frame_unwind_signed_register): New function.
	(frame_unwind_unsigned_register): New function.
	* frame.h (frame_unwind_signed_register): Declare.
	(frame_unwind_unsigned_register): Declare.
	(deprecated_read_register_dummy): Rename
	generic_read_register_dummy.

	* xstormy16-tdep.c (xstormy16_frame_saved_pc): Update.
	* rs6000-tdep.c (rs6000_frame_saved_pc): Update.
	* s390-tdep.c (s390_frame_saved_pc_nofix): Update.
	(s390_frame_chain): Update.
	* v850-tdep.c (v850_find_callers_reg): Update.
	(v850_frame_saved_pc): Update.
	* m32r-tdep.c (m32r_init_extra_frame_info): Update.
	(m32r_find_callers_reg): Update.
	(m32r_frame_saved_pc): Update.
	* sh-tdep.c (sh_find_callers_reg): Update.
	(sh64_get_saved_pr): Update.
	(sh_init_extra_frame_info): Update.
	(sh_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	(sh64_init_extra_frame_info): Update.
	* mcore-tdep.c (mcore_find_callers_reg): Update.
	(mcore_frame_saved_pc): Update.
	(mcore_init_extra_frame_info): Update.
	* i386-tdep.c (i386_frame_saved_pc): Update.
	* ia64-tdep.c (ia64_frame_saved_pc): Update.
	(ia64_init_extra_frame_info): Update.
	(ia64_init_extra_frame_info): Update.
	* d10v-tdep.c (d10v_frame_saved_pc): Update.
	* cris-tdep.c (cris_init_extra_frame_info): Update.
	* avr-tdep.c (avr_frame_chain): Update.
	(avr_init_extra_frame_info): Update.
	(avr_frame_saved_pc): Update.
	* arm-tdep.c (arm_find_callers_reg): Update.
	(arm_init_extra_frame_info): Update.
	(arm_frame_saved_pc): Update.
@
text
@d887 1
d889 6
d2055 5
a2059 2
	  memcpy (valbuf + (4 - len),
		  (char *) VALUE_CONTENTS (args[argnum]), len);
d2470 5
a2474 2
      memcpy (buf + REGISTER_RAW_SIZE (R0_REGNUM) - TYPE_LENGTH (type),
	      valbuf, TYPE_LENGTH (type));
d4560 1
a4560 1
  set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);/*??should be 8?*/
@


1.71.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a886 1
#if 0
a887 6
#else
  int len = TYPE_LENGTH (type);
  int nelem = TYPE_NFIELDS (type);
  return ((len != 1 && len != 2 && len != 4 && len != 8) || nelem != 1) &&
	  (len != 8 || TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) != 4);
#endif
d2048 2
a2049 5
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    memcpy (valbuf + (4 - len),
		    (char *) VALUE_CONTENTS (args[argnum]), len);
	  else
	    memcpy (valbuf, (char *) VALUE_CONTENTS (args[argnum]), len);
d2460 2
a2461 5
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	memcpy (buf + REGISTER_RAW_SIZE (R0_REGNUM) - TYPE_LENGTH (type),
		valbuf, TYPE_LENGTH (type));
      else
	memcpy (buf, valbuf, TYPE_LENGTH (type));
d4547 1
a4547 1
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
@


1.71.2.2
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d1877 1
a1877 1
    deprecated_read_register_gen (live_regnum, raw_buffer);
d2226 1
a2226 2
		  deprecated_write_register_gen (FP0_REGNUM + float_arg_index,
						 val);
d2269 1
a2269 1
		    deprecated_write_register_gen (regnum, val);
d2475 2
a2476 2
      deprecated_write_register_bytes (REGISTER_BYTE (R0_REGNUM), buf, 
				       REGISTER_RAW_SIZE (R0_REGNUM));
d2479 2
a2480 2
    deprecated_write_register_bytes (REGISTER_BYTE (R0_REGNUM), valbuf, 
				     TYPE_LENGTH (type));
d2487 2
a2488 2
    deprecated_write_register_bytes (REGISTER_BYTE (FP0_REGNUM), 
				     valbuf, TYPE_LENGTH (type));
d2504 1
a2504 1
	  deprecated_write_register_gen (FP0_REGNUM, valbuf);
d2527 1
a2527 1
	  deprecated_write_register_gen (return_register, buf);
d2530 1
a2530 1
	deprecated_write_register_gen (return_register, valbuf);
d4292 1
a4292 1
  set_gdbarch_deprecated_do_registers_info (gdbarch, sh_do_registers_info);
d4295 1
a4295 1
  set_gdbarch_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
d4519 1
a4519 1
      set_gdbarch_deprecated_do_registers_info (gdbarch, sh64_do_registers_info);
@


1.71.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d921 3
a923 4
/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC will be
   called for the new frame.
d930 1
a930 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d933 1
a933 1
    return read_memory_integer (get_frame_base (frame) + frame->extra_info->f_offset, 4);
d968 1
a968 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d978 1
a978 1
      return read_memory_integer (get_frame_base (frame) + frame->extra_info->f_offset, size);
d993 1
a993 1
    if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1015 1
a1015 1
    if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1728 1
a1728 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1760 1
a1760 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))
d1817 1
a1817 1
      if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1911 1
a1911 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1915 1
a1915 1
      fp = get_frame_base (frame);
d1941 1
a1941 1
  if (DEPRECATED_PC_IN_CALL_DUMMY (frame->pc, frame->frame, frame->frame))
d1945 1
a1945 1
      fp = get_frame_base (frame);
d2940 1
a2940 1
  if (pc_is_isa32 (deprecated_selected_frame->pc))
d3922 1
a3922 1
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
d4004 1
a4004 1
  if (!frame_register_read (deprecated_selected_frame, regnum, raw_buffer))
d4115 1
a4115 1
  if (pc_is_isa32 (deprecated_selected_frame->pc))
a4243 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);

d4563 1
d4565 1
d4570 1
d4592 2
@


1.71.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d36 1
a36 1
#include "inferior.h"
a41 1
#include "osabi.h"
a158 22
sh_sh2e_register_name (int reg_nr)
{
  static char *register_names[] =
  {
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
    "fpul", "fpscr",
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "",  "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
d931 4
a934 7
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    return get_frame_base (frame);	/* dummy frame same as caller's frame */
  if (get_frame_pc (frame) && !inside_entry_file (get_frame_pc (frame)))
    return read_memory_integer (get_frame_base (frame)
				+ get_frame_extra_info (frame)->f_offset, 4);
d969 3
a971 5
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
    return get_frame_base (frame);	/* dummy frame same as caller's frame */
  if (get_frame_pc (frame) && !inside_entry_file (get_frame_pc (frame)))
d973 1
a973 1
      int media_mode = pc_is_isa32 (get_frame_pc (frame));
d979 1
a979 3
      return read_memory_integer (get_frame_base (frame)
				  + get_frame_extra_info (frame)->f_offset,
				  size);
d993 2
a994 3
  for (; fi; fi = get_next_frame (fi))
    if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				     get_frame_base (fi)))
d997 1
a997 2
      return deprecated_read_register_dummy (get_frame_pc (fi),
					     get_frame_base (fi), regnum);
d1001 1
a1001 1
	if (!get_frame_pc (fi))
d1003 2
a1004 2
	if (get_frame_saved_regs (fi)[regnum] != 0)
	  return read_memory_integer (get_frame_saved_regs (fi)[regnum],
d1015 2
a1016 3
  for (; fi; fi = get_next_frame (fi))
    if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				     get_frame_base (fi)))
d1019 1
a1019 2
      return deprecated_read_register_dummy (get_frame_pc (fi),
					     get_frame_base (fi), pr_regnum);
d1023 1
a1023 1
	if (!get_frame_pc (fi))
d1026 1
a1026 1
	media_mode = pc_is_isa32 (get_frame_pc (fi));
d1028 1
a1028 1
	if (get_frame_saved_regs (fi)[pr_regnum] != 0)
d1034 1
a1034 1
	    return read_memory_integer (get_frame_saved_regs (fi)[pr_regnum], size);
d1056 1
a1056 2
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi),
							  get_frame_base (fi));
d1058 1
a1058 1
  if (get_frame_saved_regs (fi) == NULL)
d1061 1
a1061 1
    memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
d1068 1
a1068 1
      memcpy (get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
d1072 2
a1073 2
  get_frame_extra_info (fi)->leaf_function = 1;
  get_frame_extra_info (fi)->f_offset = 0;
d1084 1
a1084 1
  pc = get_pc_function_start (get_frame_pc (fi));
d1087 1
a1087 1
      deprecated_update_frame_pc_hack (fi, 0);
d1105 1
a1105 1
	  get_frame_extra_info (fi)->leaf_function = 0;
d1143 1
a1143 1
	  get_frame_saved_regs (fi)[rn] = get_frame_base (fi) - where[rn] + depth - 4;
d1147 1
a1147 1
	  get_frame_saved_regs (fi)[rn] = 0;
d1153 1
a1153 1
      get_frame_saved_regs (fi)[SP_REGNUM] = read_memory_integer (get_frame_saved_regs (fi)[FP_REGNUM], 4);
d1157 1
a1157 1
      get_frame_saved_regs (fi)[SP_REGNUM] = get_frame_base (fi) - 4;
d1160 1
a1160 1
  get_frame_extra_info (fi)->f_offset = depth - where[FP_REGNUM] - 4;
d1395 1
a1395 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), get_frame_base (fi));
d1398 1
a1398 1
  if (get_frame_saved_regs (fi) == NULL)
d1401 1
a1401 1
    memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
d1408 1
a1408 1
      memcpy (get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
d1412 2
a1413 2
  get_frame_extra_info (fi)->leaf_function = 1;
  get_frame_extra_info (fi)->f_offset = 0;
d1424 1
a1424 1
  pc = get_pc_function_start (get_frame_pc (fi));
d1427 1
a1427 1
      deprecated_update_frame_pc_hack (fi, 0);
d1463 1
a1463 1
		  get_frame_extra_info (fi)->leaf_function = 0;
d1491 1
a1491 1
	      get_frame_extra_info (fi)->leaf_function = 0;
d1519 1
a1519 1
	      get_frame_extra_info (fi)->leaf_function = 0;
d1526 1
a1526 1
	      get_frame_extra_info (fi)->leaf_function = 0;
d1556 1
a1556 1
	  get_frame_saved_regs (fi)[register_number]= get_frame_base (fi) - where[rn] + depth; 
d1560 1
a1560 1
	get_frame_saved_regs (fi)[register_number] = 0; 
d1577 1
a1577 1
      get_frame_saved_regs (fi)[sp_regnum] = read_memory_integer (get_frame_saved_regs (fi)[fp_regnum], size);
d1580 1
a1580 1
    get_frame_saved_regs (fi)[sp_regnum] = get_frame_base (fi);
d1582 1
a1582 1
  get_frame_extra_info (fi)->f_offset = depth - where[fp_regnum]; 
d1596 1
a1596 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), get_frame_base (fi));
d1599 1
a1599 1
  if (get_frame_saved_regs (fi) == NULL)
d1602 1
a1602 1
    memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
d1609 1
a1609 1
      memcpy (get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
d1613 2
a1614 2
  get_frame_extra_info (fi)->leaf_function = 1;
  get_frame_extra_info (fi)->f_offset = 0;
d1625 1
a1625 1
  pc = get_pc_function_start (get_frame_pc (fi));
d1628 1
a1628 1
      deprecated_update_frame_pc_hack (fi, 0);
d1646 1
a1646 1
	  get_frame_extra_info (fi)->leaf_function = 0;
d1695 1
a1695 1
	  get_frame_saved_regs (fi)[rn] = get_frame_base (fi) - where[rn] + depth - 4;
d1699 1
a1699 1
	  get_frame_saved_regs (fi)[rn] = 0;
d1705 2
a1706 2
      get_frame_saved_regs (fi)[SP_REGNUM] =
	read_memory_integer (get_frame_saved_regs (fi)[FP_REGNUM], 4);
d1710 1
a1710 1
      get_frame_saved_regs (fi)[SP_REGNUM] = get_frame_base (fi) - 4;
d1713 1
a1713 1
  get_frame_extra_info (fi)->f_offset = depth - where[FP_REGNUM] - 4;
d1723 2
a1724 1
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
d1726 2
a1727 2
  if (get_next_frame (fi))
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
d1729 1
a1729 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				   get_frame_base (fi)))
d1733 4
a1736 4
      deprecated_update_frame_base_hack (fi, deprecated_read_register_dummy (get_frame_pc (fi), get_frame_base (fi),
									     SP_REGNUM));
      get_frame_extra_info (fi)->return_pc = deprecated_read_register_dummy (get_frame_pc (fi),
								  get_frame_base (fi),
d1738 2
a1739 2
      get_frame_extra_info (fi)->f_offset = -(CALL_DUMMY_LENGTH + 4);
      get_frame_extra_info (fi)->leaf_function = 0;
d1745 1
a1745 1
      get_frame_extra_info (fi)->return_pc = 
d1753 1
a1753 1
  int media_mode = pc_is_isa32 (get_frame_pc (fi));
d1755 2
a1756 1
  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));
d1758 2
a1759 2
  if (get_next_frame (fi)) 
    deprecated_update_frame_pc_hack (fi, FRAME_SAVED_PC (get_next_frame (fi)));
d1761 1
a1761 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				   get_frame_base (fi)))
d1765 6
a1770 6
      deprecated_update_frame_base_hack (fi, deprecated_read_register_dummy (get_frame_pc (fi), get_frame_base (fi), SP_REGNUM));
      get_frame_extra_info (fi)->return_pc = 
	deprecated_read_register_dummy (get_frame_pc (fi),
					get_frame_base (fi), PC_REGNUM);
      get_frame_extra_info (fi)->f_offset = -(CALL_DUMMY_LENGTH + 4);
      get_frame_extra_info (fi)->leaf_function = 0;
d1776 1
a1776 1
      get_frame_extra_info (fi)->return_pc =
d1808 1
a1808 1
  media_mode = pc_is_isa32 (get_frame_pc (frame));
d1816 1
a1816 1
  while (frame && ((frame = get_next_frame (frame)) != NULL))
d1818 1
a1818 3
      if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				       get_frame_base (frame),
				       get_frame_base (frame)))
d1824 1
a1824 1
		    (deprecated_generic_find_dummy_frame (get_frame_pc (frame), get_frame_base (frame))
d1831 2
a1832 2
      if (get_frame_saved_regs (frame) != NULL
	  && get_frame_saved_regs (frame)[regnum] != 0)
d1840 1
a1840 1
			       get_frame_saved_regs (frame)[regnum]);
d1846 1
a1846 1
		*addrp = get_frame_saved_regs (frame)[regnum];
d1857 1
a1857 1
		    read_memory (get_frame_saved_regs (frame)[regnum], raw_buffer, size);
d1859 1
a1859 1
		    read_memory (get_frame_saved_regs (frame)[regnum],
d1900 1
a1900 1
  return (get_frame_extra_info (frame)->return_pc);
d1912 1
a1912 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
d1921 1
a1921 1
	if (get_frame_saved_regs (frame)[regnum])
d1923 1
a1923 1
			  read_memory_integer (get_frame_saved_regs (frame)[regnum], 4));
d1925 1
a1925 1
      write_register (PC_REGNUM, get_frame_extra_info (frame)->return_pc);
d1940 1
a1940 1
  int media_mode = pc_is_isa32 (get_frame_pc (frame));
d1942 1
a1942 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
d1951 1
a1951 1
	if (get_frame_saved_regs (frame)[regnum])
d1962 1
a1962 1
			    read_memory_integer (get_frame_saved_regs (frame)[regnum],
d1966 1
a1966 1
      write_register (PC_REGNUM, get_frame_extra_info (frame)->return_pc);
d2322 6
a2614 56
sh2e_show_regs (void)
{
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));

  printf_filtered ("GBR=%08lx VBR=%08lx",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
	  	   (long) read_register (gdbarch_tdep (current_gdbarch)->FPUL_REGNUM),
                   (long) read_register (gdbarch_tdep (current_gdbarch)->FPSCR_REGNUM));

  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));

  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 0),
		   (long) read_register (FP0_REGNUM + 1),
		   (long) read_register (FP0_REGNUM + 2),
		   (long) read_register (FP0_REGNUM + 3),
		   (long) read_register (FP0_REGNUM + 4),
		   (long) read_register (FP0_REGNUM + 5),
		   (long) read_register (FP0_REGNUM + 6),
		   (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		   (long) read_register (FP0_REGNUM + 8),
		   (long) read_register (FP0_REGNUM + 9),
		   (long) read_register (FP0_REGNUM + 10),
		   (long) read_register (FP0_REGNUM + 11),
		   (long) read_register (FP0_REGNUM + 12),
		   (long) read_register (FP0_REGNUM + 13),
		   (long) read_register (FP0_REGNUM + 14),
		   (long) read_register (FP0_REGNUM + 15));
}

static void
d2941 1
a2941 1
  if (pc_is_isa32 (get_frame_pc (deprecated_selected_frame)))
d3999 1
a3999 1
  char *raw_buffer = alloca (max_register_size (current_gdbarch));
d4116 1
a4116 1
  if (pc_is_isa32 (get_frame_pc (deprecated_selected_frame)))
d4219 9
d4229 10
a4238 4
  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d4249 2
a4335 14
    case bfd_mach_sh2e:
      sh_register_name = sh_sh2e_register_name;
      sh_show_regs = sh2e_show_regs;
      sh_store_return_value = sh3e_sh4_store_return_value;
      sh_register_virtual_type = sh_sh3e_register_virtual_type;
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
      set_gdbarch_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_register_byte (gdbarch, sh_default_register_byte);
      set_gdbarch_fp0_regnum (gdbarch, 25);
      tdep->FPUL_REGNUM = 23;
      tdep->FPSCR_REGNUM = 24;
      tdep->FP_LAST_REGNUM = 40;
      break;
d4578 2
d4592 1
d4598 5
a4602 2
  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);
d4615 2
a4616 1
  /* FIXME: dump the rest of gdbarch_tdep.  */
@


1.71.2.5
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d946 2
a947 2
   then DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC
   will be called for the new frame.
d1032 1
a1032 1
	DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
d1056 1
a1056 1
	DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
d1779 1
a1779 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
d1810 1
a1810 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
d1867 1
a1867 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d1956 1
a1956 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d1988 1
a1988 1
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
d4362 2
a4363 2
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4);
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4);
d4376 1
a4376 1
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sh_init_extra_frame_info);
d4395 1
a4395 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4405 1
a4405 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4415 1
a4415 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4429 1
a4429 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4454 1
a4454 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4466 1
a4466 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
d4483 1
a4483 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4509 1
a4509 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
d4516 2
a4517 2
      set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4 * 4);
      set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4 * 4);
d4604 1
a4604 1
      /*set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);*/
d4606 1
a4606 1
      set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4 * 4);
d4608 2
a4609 2
      /*set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);*/
      set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4 * 4);
d4614 1
a4614 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh64_nofp_frame_init_saved_regs);
d4616 1
a4616 1
      set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sh64_init_extra_frame_info);
d4633 1
a4633 1
      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4667 1
@


1.71.2.6
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d1119 1
a1119 1
  pc = get_frame_func (fi);
d1459 1
a1459 1
  pc = get_frame_func (fi);
d1660 1
a1660 1
  pc = get_frame_func (fi);
d1761 1
a1761 1
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));
d1793 1
a1793 1
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));
d2417 1
a2417 1
      deprecated_store_floating (valbuf, len, val);
d2470 1
a2470 1
	  deprecated_store_floating (valbuf, len, val);
d3406 1
a3406 1
      deprecated_store_floating (to, TYPE_LENGTH (type), val);
d3432 1
a3432 1
      deprecated_store_floating(to, TYPE_LENGTH(type), val);
d3447 1
a3447 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
d3472 1
a3472 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
d4374 2
a4375 2
  set_gdbarch_deprecated_frame_chain (gdbarch, sh_frame_chain);
  set_gdbarch_deprecated_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
d4378 2
a4379 2
  set_gdbarch_deprecated_push_arguments (gdbarch, sh_push_arguments);
  set_gdbarch_deprecated_store_struct_return (gdbarch, sh_store_struct_return);
d4382 1
a4382 1
  set_gdbarch_deprecated_pop_frame (gdbarch, sh_pop_frame);
d4617 2
a4618 2
      set_gdbarch_deprecated_frame_chain (gdbarch, sh64_frame_chain);
      set_gdbarch_deprecated_get_saved_register (gdbarch, sh64_get_saved_register);
d4620 2
a4621 2
      set_gdbarch_deprecated_push_arguments (gdbarch, sh64_push_arguments);
      /*set_gdbarch_deprecated_store_struct_return (gdbarch, sh64_store_struct_return);*/
d4624 1
a4624 1
      set_gdbarch_deprecated_pop_frame (gdbarch, sh64_pop_frame);
d4644 1
a4644 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, generic_target_write_sp);
d4656 5
d4663 3
d4667 1
a4667 1
  set_gdbarch_deprecated_push_return_address (gdbarch, sh_push_return_address);
d4677 2
a4678 2
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sh_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sh_saved_pc_after_call);
@


1.71.2.7
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d1006 1
a1006 1
	size = REGISTER_RAW_SIZE (translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode));
d1175 1
a1175 1
	  if (rn == DEPRECATED_FP_REGNUM)
d1188 1
a1188 1
      get_frame_saved_regs (fi)[SP_REGNUM] = read_memory_integer (get_frame_saved_regs (fi)[DEPRECATED_FP_REGNUM], 4);
d1195 1
a1195 1
  get_frame_extra_info (fi)->f_offset = depth - where[DEPRECATED_FP_REGNUM] - 4;
d1480 1
a1480 1
  fp_regnum = translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode);
d1605 2
a1606 2
      /* Again, saved_registers contains only space for the real
	 registers, so we store in DEPRECATED_FP_REGNUM position.  */
d1727 1
a1727 1
	  if (rn == DEPRECATED_FP_REGNUM)
d1741 1
a1741 1
	read_memory_integer (get_frame_saved_regs (fi)[DEPRECATED_FP_REGNUM], 4);
d1748 1
a1748 1
  get_frame_extra_info (fi)->f_offset = depth - where[DEPRECATED_FP_REGNUM] - 4;
d1766 2
a1767 2
      /* We need to setup fi->frame here because call_function_by_hand
         gets it wrong by assuming it's always FP.  */
d1798 2
a1799 2
      /* We need to setup fi->frame here because call_function_by_hand
         gets it wrong by assuming it's always FP.  */
d1888 1
a1888 1
		      && (live_regnum == DEPRECATED_FP_REGNUM
d1996 1
a1996 1
		&& (regnum == DEPRECATED_FP_REGNUM
d4368 1
a4368 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 14);
d4642 1
@


1.71.2.8
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1773 1
a1773 1
      get_frame_extra_info (fi)->f_offset = -(DEPRECATED_CALL_DUMMY_LENGTH + 4);
d1804 1
a1804 1
      get_frame_extra_info (fi)->f_offset = -(DEPRECATED_CALL_DUMMY_LENGTH + 4);
d1876 2
a1877 2
		store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
					get_frame_saved_regs (frame)[regnum]);
d3484 1
a3484 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3523 1
a3523 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3687 1
a3687 1
  char temp_buffer[MAX_REGISTER_SIZE];
d3724 1
a3724 1
  char temp_buffer[MAX_REGISTER_SIZE];
d4090 1
a4090 1
  char raw_buffer[MAX_REGISTER_SIZE];
d4370 2
a4371 2
  set_gdbarch_deprecated_register_size (gdbarch, 4);
  set_gdbarch_deprecated_register_bytes (gdbarch, SH_DEFAULT_NUM_REGS * 4);
d4589 4
a4592 4
      set_gdbarch_deprecated_register_size (gdbarch, 8); /*????*/
      set_gdbarch_deprecated_register_bytes (gdbarch, 
					     ((SIM_SH64_NR_FP_REGS + 1) * 4)
					     + (SIM_SH64_NR_REGS - SIM_SH64_NR_FP_REGS -1) * 8);
d4655 2
a4656 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, sh_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (sh_call_dummy_words));
@


1.71.2.9
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d365 1
a365 1
static void
d1242 1
a1242 1
static int
d1816 1
a1816 1
static void
d1924 1
a1924 1
  return (extract_unsigned_integer ((regbuf), REGISTER_RAW_SIZE (0)));
d1930 2
a1931 2
  return (extract_unsigned_integer ((regbuf + REGISTER_BYTE (STRUCT_RETURN_REGNUM)), 
				    REGISTER_RAW_SIZE (STRUCT_RETURN_REGNUM)));
d2126 1
a2126 1
	      regval = extract_unsigned_integer (val, REGISTER_RAW_SIZE (argreg));
d2241 1
a2241 1
		  regval = extract_unsigned_integer (val, argreg_size);
d2300 2
a2301 3
			DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL (regnum,
								type, val,
								valbuf_tmp);
d3038 1
a3038 2
static void
sh_show_regs_command (char *args, int from_tty)
d3412 1
a3412 1
static void
d3454 1
a3454 1
static void
d3479 1
a3479 1
static void
d3682 1
a3682 1
static void
d3718 1
a3718 1
static void
d4126 1
a4126 1
static void
d4178 1
a4178 1
static void
d4204 1
a4204 1
static void
d4309 1
a4309 1
  gdbarch_deprecated_register_virtual_type_ftype *sh_register_virtual_type;
d4396 3
a4398 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4406 3
a4408 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4416 3
a4418 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4430 3
a4432 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4455 3
a4457 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4467 3
a4469 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4484 3
a4486 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4512 3
a4514 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_sh4_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_sh4_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_sh4_register_byte);
d4600 3
a4602 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_sh64_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_sh64_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_sh64_register_byte);
d4634 3
a4636 3
      set_gdbarch_deprecated_register_raw_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_default_register_raw_size);
      set_gdbarch_deprecated_register_byte (gdbarch, sh_default_register_byte);
d4640 1
d4642 2
a4643 1
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
d4646 1
a4646 1
  set_gdbarch_deprecated_register_virtual_type (gdbarch, sh_register_virtual_type);
d4670 1
a4688 2

extern initialize_file_ftype _initialize_sh_tdep; /* -Wmissing-prototypes */
@


1.71.2.10
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d56 1
a347 16
static CORE_ADDR
sh_push_dummy_code (struct gdbarch *gdbarch,
		    CORE_ADDR sp, CORE_ADDR funaddr, int using_gcc,
		    struct value **args, int nargs,
		    struct type *value_type,
		    CORE_ADDR *real_pc, CORE_ADDR *bp_addr)
{
  /* Allocate space sufficient for a breakpoint.  */
  sp = (sp - 2) & ~1;
  /* Store the address of that breakpoint */
  *bp_addr = sp;
  /* sh always starts the call at the callee's entry point.  */
  *real_pc = funaddr;
  return sp;
}

d931 1
a931 1
sh64_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
d1037 1
a1037 1
				      register_size (current_gdbarch, regnum));
d1922 1
a1922 1
sh_extract_struct_value_address (struct regcache *regcache)
d1924 1
a1924 4
  ULONGEST addr;
  /*FIXME: Is R0 really correct here?  Not STRUCT_RETURN_REGNUM? */
  regcache_cooked_read_unsigned (regcache, STRUCT_RETURN_REGNUM, &addr);
  return addr;
a2012 6
static CORE_ADDR
sh_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
{
  return sp & ~3;
}

d2057 2
a2058 5
sh_push_dummy_call (struct gdbarch *gdbarch, CORE_ADDR func_addr,
		    struct regcache *regcache, CORE_ADDR bp_addr, int nargs,
		    struct value **args, CORE_ADDR sp, int struct_return,
		    CORE_ADDR struct_addr)

d2069 1
a2069 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d2072 1
a2072 1
  sp = sh_frame_align (gdbarch, sp);
d2077 1
a2077 1
    regcache_cooked_write_unsigned (regcache, STRUCT_RETURN_REGNUM, struct_addr);
d2126 2
a2127 3
	      regval = extract_unsigned_integer (val, register_size (gdbarch,
								     argreg));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
d2132 2
a2133 2
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
a2135 7

  /* Store return address. */
  regcache_cooked_write_unsigned (regcache, tdep->PR_REGNUM, bp_addr);

  /* Update stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp);

d2334 1
a2334 1
sh64_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
d2369 1
a2369 2
sh_default_extract_return_value (struct type *type, struct regcache *regcache,
				 void *valbuf)
d2377 5
a2381 4
      ULONGEST c;

      regcache_cooked_read_unsigned (regcache, R0_REGNUM, &c);
      store_unsigned_integer (valbuf, len, c);
d2383 1
a2383 1
  else if (len == 8)
d2385 5
a2389 3
      int i, regnum = R0_REGNUM;
      for (i = 0; i < len; i += 4)
	regcache_raw_read (regcache, regnum++, (char *)valbuf + i);
d2396 1
a2396 2
sh3e_sh4_extract_return_value (struct type *type, struct regcache *regcache,
			       void *valbuf)
d2398 4
d2403 18
d2422 13
a2434 4
      int len = TYPE_LENGTH (type);
      int i, regnum = FP0_REGNUM;
      for (i = 0; i < len; i += 4)
	regcache_raw_read (regcache, regnum++, (char *)valbuf + i);
d2437 1
a2437 1
    sh_default_extract_return_value (type, regcache, valbuf);
d2500 1
a2500 2
sh_default_store_return_value (struct type *type, struct regcache *regcache,
			       const void *valbuf)
d2502 1
a2502 2
  ULONGEST val;
  int len = TYPE_LENGTH (type);
d2504 1
a2504 1
  if (len <= 4)
d2506 9
a2514 2
      val = extract_unsigned_integer (valbuf, len);
      regcache_cooked_write_unsigned (regcache, R0_REGNUM, val);
d2517 2
a2518 5
    {
      int i, regnum = R0_REGNUM;
      for (i = 0; i < len; i += 4)
        regcache_raw_write (regcache, regnum++, (char *)valbuf + i);
    }
d2522 1
a2522 2
sh3e_sh4_store_return_value (struct type *type, struct regcache *regcache,
			     const void *valbuf)
d2525 2
a2526 6
    {
      int len = TYPE_LENGTH (type);
      int i, regnum = FP0_REGNUM;
      for (i = 0; i < len; i += 4)
        regcache_raw_write (regcache, regnum++, (char *)valbuf + i);
    }
d2528 1
a2528 1
    sh_default_store_return_value (type, regcache, valbuf);
d3046 23
d3224 23
d3271 8
d3293 1
a3293 1
sh_sh3e_register_type (struct gdbarch *gdbarch, int reg_nr)
d3315 1
a3315 1
sh_sh4_register_type (struct gdbarch *gdbarch, int reg_nr)
d3317 1
a3317 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d3366 1
a3366 1
sh_default_register_type (struct gdbarch *gdbarch, int reg_nr)
d3408 1
a3408 1
      store_typed_floating (to, type, val);
d3449 1
a3449 1
      DOUBLEST val = extract_typed_floating (from, type);
d3499 1
a3499 1
			    + register_size (gdbarch, base_regnum) * portion));
d3502 1
a3502 1
					  gdbarch_register_type (gdbarch, reg_nr),
d3514 1
a3514 1
			    + register_size (gdbarch, base_regnum) * portion));
d3698 1
a3698 1
      sh_sh4_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr), reg_nr,
d3705 1
a3705 1
			     + register_size (gdbarch, base_regnum) * portion));
d3716 1
a3716 1
			     + register_size (gdbarch, base_regnum) * portion));
d3889 1
a3889 2
do_fv_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int fv_regnum)
d3892 2
a3893 2
  fprintf_filtered (file, "fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
		     fv_regnum - gdbarch_tdep (gdbarch)->FV0_REGNUM, 
d3928 1
a3928 2
do_dr_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int dr_regnum)
d3932 2
a3933 2
  fprintf_filtered (file, "dr%d\t0x%08x%08x\n", 
		    dr_regnum - gdbarch_tdep (gdbarch)->DR0_REGNUM, 
d3989 1
a3989 2
sh_print_pseudo_register (struct gdbarch *gdbarch, struct ui_file *file,
			  int regnum)
d3991 1
a3991 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d3997 2
a3998 2
	   && regnum <= tdep->DR_LAST_REGNUM)
    do_dr_register_info (gdbarch, file, regnum);
d4001 1
a4001 1
    do_fv_register_info (gdbarch, file, regnum);
d4005 1
a4005 1
sh_do_fp_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d4013 1
a4013 1
  raw_buffer = (char *) alloca (register_size (gdbarch, FP0_REGNUM));
d4016 1
a4016 1
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
d4023 2
a4024 2
  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);
d4028 1
a4028 1
    fprintf_filtered (file, "<invalid float>");
d4030 1
a4030 1
    fprintf_filtered (file, "%-10.9g", flt);
d4033 2
a4034 2
  fprintf_filtered (file, "\t(raw 0x");
  for (j = 0; j < register_size (gdbarch, regnum); j++)
d4037 2
a4038 2
	: register_size (gdbarch, regnum) - 1 - j;
      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
d4040 2
a4041 2
  fprintf_filtered (file, ")");
  fprintf_filtered (file, "\n");
d4057 1
a4057 1
    do_dr_register_info (current_gdbarch, gdb_stdout, regnum);
d4065 1
a4065 1
    do_fv_register_info (current_gdbarch, gdb_stdout, regnum);
d4081 1
a4081 1
    sh_do_fp_register (current_gdbarch, gdb_stdout, regnum); /* this should work also for pseudoregs */
d4090 1
a4090 1
sh_do_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d4094 2
a4095 2
  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);
d4098 2
a4099 2
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
    fprintf_filtered (file, "*value not available*\n");
d4101 6
a4106 6
  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 'x', 1, 0, Val_pretty_default);
  fprintf_filtered (file, "\t");
  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 0, 1, 0, Val_pretty_default);
  fprintf_filtered (file, "\n");
d4110 1
a4110 1
sh_print_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d4118 2
a4119 2
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
	sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
d4121 1
a4121 1
	sh_do_register (gdbarch, file, regnum);	/* All other regs */
d4125 1
a4125 6
    {
      if (gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh5)
	sh64_do_pseudo_register (regnum);
      else
	sh_print_pseudo_register (gdbarch, file, regnum);
    }
d4129 1
a4129 2
sh_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			 struct frame_info *frame, int regnum, int fpregs)
d4136 1
a4136 1
      sh_print_register (gdbarch, file, regnum);
d4153 1
a4153 1
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d4158 1
a4158 1
		  sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
d4162 1
a4162 1
		regnum += (gdbarch_tdep (gdbarch)->FP_LAST_REGNUM - FP0_REGNUM);	/* skip FP regs */
d4166 1
a4166 1
	      sh_do_register (gdbarch, file, regnum);	/* All other regs */
d4174 1
a4174 4
	    if (gdbarch_bfd_arch_info (gdbarch)->mach == bfd_mach_sh5)
	      sh64_do_pseudo_register (regnum);
	    else
	      sh_print_pseudo_register (gdbarch, file, regnum);
d4192 1
a4192 1
      sh_print_register (current_gdbarch, gdb_stdout, regnum);
d4200 1
a4200 1
          sh64_do_pseudo_register (regnum);
d4210 1
a4210 2
   sh_print_registers_info (current_gdbarch, gdb_stdout,
			    deprecated_selected_frame, regnum, fpregs);
d4288 1
a4288 1
  if (nr >= DSP_DSR_REGNUM && nr <= DSP_Y1_REGNUM)
d4306 1
a4306 1
  static LONGEST sh64_call_dummy_words[] = {0};
d4309 3
d4362 4
a4365 2
  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_int_bit (gdbarch, 4 * TARGET_CHAR_BIT);
a4366 4
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
a4367 1

d4372 3
a4374 3
  set_gdbarch_fp0_regnum (gdbarch, -1);
  set_gdbarch_num_pseudo_regs (gdbarch, 0);

d4376 6
d4383 2
a4384 1

a4386 12

  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);

  set_gdbarch_skip_prologue (gdbarch, sh_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
  set_gdbarch_function_start_offset (gdbarch, 0);

  set_gdbarch_frame_args_skip (gdbarch, 0);
  set_gdbarch_frameless_function_invocation (gdbarch, frameless_look_for_prologue);
  set_gdbarch_believe_pcc_promotion (gdbarch, 1);

d4388 1
a4388 8

  set_gdbarch_deprecated_frame_chain (gdbarch, sh_frame_chain);
  set_gdbarch_deprecated_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sh_init_extra_frame_info);
  set_gdbarch_deprecated_pop_frame (gdbarch, sh_pop_frame);
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sh_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sh_saved_pc_after_call);
  set_gdbarch_frame_align (gdbarch, sh_frame_align);
d4393 1
a4393 2
      set_gdbarch_register_name (gdbarch, sh_sh_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4395 2
a4396 7
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);

d4398 3
d4403 1
a4403 2
      set_gdbarch_register_name (gdbarch, sh_sh_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4405 2
a4406 7
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);

d4408 3
d4413 1
a4413 5
      /* doubles on sh2e and sh3e are actually 4 byte. */
      set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);

      set_gdbarch_register_name (gdbarch, sh_sh2e_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4415 6
a4420 2
      set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
a4421 4
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a4424 2

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4427 1
a4427 2
      set_gdbarch_register_name (gdbarch, sh_sh_dsp_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4429 6
a4434 2
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
a4435 4
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a4449 2

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4452 1
a4452 2
      set_gdbarch_register_name (gdbarch, sh_sh3_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4454 6
a4459 6
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a4461 2

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4464 1
a4464 5
      /* doubles on sh2e and sh3e are actually 4 byte. */
      set_gdbarch_double_bit (gdbarch, 4 * TARGET_CHAR_BIT);

      set_gdbarch_register_name (gdbarch, sh_sh3e_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4466 7
a4472 2
      set_gdbarch_register_type (gdbarch, sh_sh3e_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
a4473 4
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a4478 2

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
d4481 1
a4481 2
      set_gdbarch_register_name (gdbarch, sh_sh3_dsp_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4483 6
a4488 7
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a4504 2

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_nofp_frame_init_saved_regs);
d4507 1
a4507 2
      set_gdbarch_register_name (gdbarch, sh_sh4_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4509 4
a4512 2
      set_gdbarch_register_type (gdbarch, sh_sh4_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
d4514 3
d4518 2
a4521 4
      set_gdbarch_store_return_value (gdbarch, sh3e_sh4_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call);
      set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
a4530 2

      set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
d4592 1
a4592 1
      set_gdbarch_deprecated_register_bytes (gdbarch,
d4596 1
a4596 1
      set_gdbarch_register_name (gdbarch, sh_sh64_register_name);
d4598 2
a4599 2
      set_gdbarch_deprecated_register_virtual_type (gdbarch, sh_sh64_register_virtual_type);
      set_gdbarch_deprecated_store_return_value (gdbarch, sh64_store_return_value);
d4601 1
a4617 3
      set_gdbarch_deprecated_call_dummy_words (gdbarch, sh64_call_dummy_words);
      set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (sh64_call_dummy_words));

d4623 1
a4623 3
      set_gdbarch_deprecated_push_return_address (gdbarch, sh64_push_return_address);
      set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
      set_gdbarch_deprecated_store_struct_return (gdbarch, sh64_store_struct_return);
d4631 1
a4631 2
      set_gdbarch_register_name (gdbarch, sh_generic_register_name);
      set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);
d4633 2
a4634 5
      set_gdbarch_register_type (gdbarch, sh_default_register_type);
      set_gdbarch_push_dummy_code (gdbarch, sh_push_dummy_code);
      set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
      set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);

d4636 3
d4641 30
@


1.71.2.11
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d49 1
a49 1
/* sh flags */
d54 2
a55 1
static void (*sh_show_regs) (void);
d57 1
a57 1
#define SH_NUM_REGS 59
d260 77
d363 103
d490 117
d623 1
a623 1
#define IS_ADD_IMM_SP(x)	(((x) & 0xff00) == 0x7f00)
d635 1
a635 3
/* CV, 2003-08-28: Only suitable with Rn == SP, therefore name changed to
		   make this entirely clear. */
#define IS_FPUSH(x)		(((x) & 0xf00f) == 0xf00b)
d699 2
a700 2
      if (IS_FPUSH (w) || IS_PUSH (w) || IS_STS (w) || IS_MOV_R3 (w)
	  || IS_ADD_R3SP (w) || IS_ADD_IMM_SP (w) || IS_SHLL_R3 (w) 
d719 172
d906 1
a906 1
    return sh_skip_prologue_hard_way (pc);
d918 1
a918 1
  return (ADDR_BITS_REMOVE (read_register (PR_REGNUM)));
d935 16
d973 1
a973 2
  if (get_frame_pc (frame)
      && !deprecated_inside_entry_file (get_frame_pc (frame)))
d980 50
d1057 32
d1103 1
a1103 1
  int inst;
d1130 1
a1130 1
  /* Loop around examining the prologue inst until we find something
d1143 1
a1143 1
      inst = read_memory_integer (pc, 2);
d1145 1
a1145 1
      if (IS_PUSH (inst))
d1147 1
a1147 1
	  rn = GET_PUSHED_REG (inst);
d1151 1
a1151 1
      else if (IS_STS (inst))
d1153 1
a1153 1
	  where[PR_REGNUM] = depth;
d1158 1
a1158 1
      else if (IS_MOV_R3 (inst))
d1160 1
a1160 1
	  r3_val = ((inst & 0xff) ^ 0x80) - 0x80;
d1162 1
a1162 1
      else if (IS_SHLL_R3 (inst))
d1166 1
a1166 1
      else if (IS_ADD_R3SP (inst))
d1170 1
a1170 1
      else if (IS_ADD_IMM_SP (inst))
d1172 1
a1172 1
	  depth -= ((inst & 0xff) ^ 0x80) - 0x80;
d1174 1
a1174 1
      else if (IS_MOV_SP_FP (inst))
d1222 1
a1222 1
    (fv_regnum - FV0_REGNUM) * 4;
d1233 1
a1233 1
    (dr_regnum - DR0_REGNUM) * 2;
d1237 398
d1644 1
a1644 1
  int inst;
d1647 1
d1671 1
a1671 1
  /* Loop around examining the prologue inst until we find something
d1684 1
a1684 1
      inst = read_memory_integer (pc, 2);
d1686 1
a1686 1
      if (IS_PUSH (inst))
d1688 1
a1688 1
	  rn = GET_PUSHED_REG (inst);
d1692 1
a1692 1
      else if (IS_STS (inst))
d1694 1
a1694 1
	  where[PR_REGNUM] = depth;
d1699 1
a1699 1
      else if (IS_MOV_R3 (inst))
d1701 1
a1701 1
	  r3_val = ((inst & 0xff) ^ 0x80) - 0x80;
d1703 1
a1703 1
      else if (IS_SHLL_R3 (inst))
d1707 1
a1707 1
      else if (IS_ADD_R3SP (inst))
d1711 1
a1711 1
      else if (IS_ADD_IMM_SP (inst))
d1713 1
a1713 1
	  depth -= ((inst & 0xff) ^ 0x80) - 0x80;
d1715 1
a1715 1
      else if (IS_FPUSH (inst))
d1717 1
a1717 1
	  if (read_register (FPSCR_REGNUM) & FPSCR_SZ)
d1726 1
a1726 1
      else if (IS_MOV_SP_FP (inst))
d1791 76
a1866 2
    }
  else
d1868 52
a1919 3
      DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
      get_frame_extra_info (fi)->return_pc = 
	sh_find_callers_reg (fi, PR_REGNUM);
d1921 10
d1940 1
d1946 7
d1963 3
a1965 3
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR fp;
  int regnum;
d1988 43
d2037 1
a2037 1
/* Function: push_dummy_call (formerly push_arguments)
a2044 4
   MVS: Except on SH variants that have floating point registers.
   In that case, float and double arguments are passed in the same
   manner, but using FP registers instead of GP registers.

a2057 5
   MVS: The above appears to be true for the SH variants that do not
   have an FPU, however those that have an FPU appear to copy the
   aggregate argument onto the stack (and not place it in registers)
   if it is larger than 16 bytes (four GP registers).

d2081 5
a2085 7
sh_push_dummy_call_fpu (struct gdbarch *gdbarch, 
			CORE_ADDR func_addr,
			struct regcache *regcache, 
			CORE_ADDR bp_addr, int nargs,
			struct value **args, 
			CORE_ADDR sp, int struct_return,
			CORE_ADDR struct_addr)
d2088 1
a2088 1
  int argreg, flt_argreg;
d2096 1
d2104 1
a2104 3
    regcache_cooked_write_unsigned (regcache, 
				    STRUCT_RETURN_REGNUM, 
				    struct_addr);
d2115 1
a2115 2
  argreg = ARG0_REGNUM;
  flt_argreg = FLOAT_ARG0_REGNUM;
d2135 1
a2135 3
	odd_sized_struct = 1;	/* Such structs go entirely on stack.  */
      else if (len > 16)
	odd_sized_struct = 1;	/* So do aggregates bigger than 4 words.  */
d2140 1
a2140 3
	  if ((TYPE_CODE (type) == TYPE_CODE_FLT 
	       && flt_argreg > FLOAT_ARGLAST_REGNUM) 
	      || argreg > ARGLAST_REGNUM
d2150 1
a2150 9
	  if (TYPE_CODE (type) == TYPE_CODE_FLT &&
	      flt_argreg > 0 && flt_argreg <= FLOAT_ARGLAST_REGNUM)
	    {
	      /* Argument goes in a single-precision fp reg.  */
	      regval = extract_unsigned_integer (val, register_size (gdbarch,
								     argreg));
	      regcache_cooked_write_unsigned (regcache, flt_argreg++, regval);
	    }
	  else if (argreg <= ARGLAST_REGNUM)
d2166 1
a2166 1
  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);
d2174 19
d2194 2
a2195 7
sh_push_dummy_call_nofpu (struct gdbarch *gdbarch, 
			  CORE_ADDR func_addr,
			  struct regcache *regcache, 
			  CORE_ADDR bp_addr, 
			  int nargs, struct value **args, 
			  CORE_ADDR sp, int struct_return, 
			  CORE_ADDR struct_addr)
d2198 5
a2202 1
  int argreg;
d2207 2
a2208 1
  char valbuf[4];
d2210 5
a2214 1
  int odd_sized_struct;
d2216 2
a2217 2
  /* first force sp to a 4-byte alignment */
  sp = sh_frame_align (gdbarch, sp);
d2221 1
d2223 1
a2223 3
    regcache_cooked_write_unsigned (regcache,
				    STRUCT_RETURN_REGNUM,
				    struct_addr);
d2227 1
a2227 1
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
d2231 6
a2236 2
     registers, and push the rest onto the stack.  There are 16 bytes
     in four registers available.  Loop thru args from first to last.  */
a2237 1
  argreg = ARG0_REGNUM;
d2243 2
a2244 1
      if (len < 4)
d2246 13
a2258 4
	  /* value gets right-justified in the register or stack word */
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    memcpy (valbuf + (4 - len),
		    (char *) VALUE_CONTENTS (args[argnum]), len);
d2260 27
a2286 2
	    memcpy (valbuf, (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
a2288 7
	val = (char *) VALUE_CONTENTS (args[argnum]);

      if (len > 4 && (len & 3) != 0)
	odd_sized_struct = 1;	/* such structs go entirely on stack */
      else
	odd_sized_struct = 0;
      while (len > 0)
d2290 24
a2313 6
	  if (argreg > ARGLAST_REGNUM
	      || odd_sized_struct)
	    {			
	      /* must go on the stack */
	      write_memory (sp + stack_offset, val, 4);
	      stack_offset += 4;
d2315 44
a2358 15
	  /* NOTE WELL!!!!!  This is not an "else if" clause!!!
	     That's because some *&^%$ things get passed on the stack
	     AND in the registers!   */
	  if (argreg <= ARGLAST_REGNUM)
	    {			
	      /* there's room in a register */
	      regval = extract_unsigned_integer (val, register_size (gdbarch,
								     argreg));
	      regcache_cooked_write_unsigned (regcache, argreg++, regval);
	    }
	  /* Store the value 4 bytes at a time.  This means that things
	     larger than 4 bytes may go partly in registers and partly
	     on the stack.  */
	  len -= register_size (gdbarch, argreg);
	  val += register_size (gdbarch, argreg);
d2361 6
d2368 7
a2374 2
  /* Store return address. */
  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);
d2376 13
a2388 2
  /* Update stack pointer.  */
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp);
d2390 6
a2395 1
  return sp;
d2397 1
d2443 53
d2537 41
d2583 2
d2587 2
a2588 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2619 2
d2623 2
a2624 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2632 2
a2633 2
	           (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d2670 2
a2671 2
	  	   (long) read_register (FPUL_REGNUM),
                   (long) read_register (FPSCR_REGNUM));
d2715 2
d2719 2
a2720 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2728 2
a2729 2
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d2731 2
a2732 2
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d2776 2
d2780 2
a2781 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2790 2
a2791 2
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d2794 1
a2794 1
		   (long) read_register (DSR_REGNUM));
d2816 7
a2822 7
		   (long) read_register (A0G_REGNUM) & 0xff,
		   (long) read_register (A0_REGNUM),
		   (long) read_register (M0_REGNUM),
		   (long) read_register (X0_REGNUM),
		   (long) read_register (Y0_REGNUM),
		   (long) read_register (RS_REGNUM),
		   (long) read_register (MOD_REGNUM));
d2824 6
a2829 6
		   (long) read_register (A1G_REGNUM) & 0xff,
		   (long) read_register (A1_REGNUM),
		   (long) read_register (M1_REGNUM),
		   (long) read_register (X1_REGNUM),
		   (long) read_register (Y1_REGNUM),
		   (long) read_register (RE_REGNUM));
d2835 3
a2837 1
  int pr = read_register (FPSCR_REGNUM) & 0x80000;
d2840 2
a2841 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2849 2
a2850 2
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));
d2852 2
a2853 2
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d2901 2
d2905 2
a2906 2
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
d2915 1
a2915 1
		   (long) read_register (DSR_REGNUM));
d2937 7
a2943 7
		   (long) read_register (A0G_REGNUM) & 0xff,
		   (long) read_register (A0_REGNUM),
		   (long) read_register (M0_REGNUM),
		   (long) read_register (X0_REGNUM),
		   (long) read_register (Y0_REGNUM),
		   (long) read_register (RS_REGNUM),
		   (long) read_register (MOD_REGNUM));
d2945 98
a3042 6
		   (long) read_register (A1G_REGNUM) & 0xff,
		   (long) read_register (A1_REGNUM),
		   (long) read_register (M1_REGNUM),
		   (long) read_register (X1_REGNUM),
		   (long) read_register (Y1_REGNUM),
		   (long) read_register (RE_REGNUM));
d3052 190
d3247 2
d3250 2
a3251 2
       && (reg_nr <= FP_LAST_REGNUM)) 
      || (reg_nr == FPUL_REGNUM))
d3269 21
d3291 3
a3293 2
       && (reg_nr <= FP_LAST_REGNUM)) 
      || (reg_nr == FPUL_REGNUM))
d3295 4
a3298 2
  else if (reg_nr >= DR0_REGNUM 
	   && reg_nr <= DR_LAST_REGNUM)
d3300 13
a3312 3
  else if  (reg_nr >= FV0_REGNUM 
	   && reg_nr <= FV_LAST_REGNUM)
    return sh_sh4_build_float_register_type (3);
d3314 1
a3314 1
    return builtin_type_int;
d3353 4
a3356 2
  if (regnum >= DR0_REGNUM 
      && regnum <= DR_LAST_REGNUM)
d3367 26
d3396 4
a3399 2
  if (regnum >= DR0_REGNUM 
      && regnum <= DR_LAST_REGNUM)
d3409 25
d3439 1
d3441 2
a3442 2
  if (reg_nr >= DR0_REGNUM 
      && reg_nr <= DR_LAST_REGNUM)
d3457 2
a3458 2
  else if (reg_nr >= FV0_REGNUM 
	   && reg_nr <= FV_LAST_REGNUM)
d3471 166
d3642 1
d3644 2
a3645 2
  if (reg_nr >= DR0_REGNUM
      && reg_nr <= DR_LAST_REGNUM)
d3659 2
a3660 2
  else if (reg_nr >= FV0_REGNUM
	   && reg_nr <= FV_LAST_REGNUM)
d3672 167
d3846 14
a3859 1
		     fv_regnum - FV0_REGNUM, 
d3866 13
d3887 1
a3887 1
		    dr_regnum - DR0_REGNUM, 
d3892 50
d3946 2
d3951 2
a3952 2
  else if (regnum >= DR0_REGNUM
	   && regnum <= DR_LAST_REGNUM)
d3954 2
a3955 2
  else if (regnum >= FV0_REGNUM
	   && regnum <= FV_LAST_REGNUM)
d3991 1
a3991 1
      int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
d4000 45
d4081 4
a4084 1
      sh_print_pseudo_register (gdbarch, file, regnum);
d4123 1
a4123 1
		regnum += (FP_LAST_REGNUM - FP0_REGNUM);	/* skip FP regs */
d4135 4
a4138 1
	    sh_print_pseudo_register (gdbarch, file, regnum);
d4144 36
d4224 24
d4253 3
a4255 3
  if (nr >= DSR_REGNUM && nr <= Y1_REGNUM)
    return nr - DSR_REGNUM + SIM_SH_DSR_REGNUM;
  if (nr == MOD_REGNUM)
d4257 1
a4257 1
  if (nr == RS_REGNUM)
d4259 1
a4259 1
  if (nr == RE_REGNUM)
d4261 2
a4262 2
  if (nr >= R0_BANK_REGNUM && nr <= R7_BANK_REGNUM)
    return nr - R0_BANK_REGNUM + SIM_SH_R0_BANK_REGNUM;
d4271 1
d4273 1
a4273 32

  sh_show_regs = sh_generic_show_regs;
  switch (info.bfd_arch_info->mach)
    {
      case bfd_mach_sh2e:
        sh_show_regs = sh2e_show_regs;
        break;
      case bfd_mach_sh_dsp:
        sh_show_regs = sh_dsp_show_regs;
        break;

      case bfd_mach_sh3:
        sh_show_regs = sh3_show_regs;
        break;

      case bfd_mach_sh3e:
        sh_show_regs = sh3e_show_regs;
        break;

      case bfd_mach_sh3_dsp:
        sh_show_regs = sh3_dsp_show_regs;
        break;

      case bfd_mach_sh4:
        sh_show_regs = sh4_show_regs;
        break;

      case bfd_mach_sh5:
	sh_show_regs = sh64_show_regs;
        /* SH5 is handled entirely in sh64-tdep.c */
        return sh64_gdbarch_init (info, arches);
    }
d4282 2
a4283 1
  gdbarch = gdbarch_alloc (&info, NULL);
d4289 35
d4333 1
a4333 1
  set_gdbarch_num_regs (gdbarch, SH_NUM_REGS);
d4357 2
d4372 1
d4377 1
a4377 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
d4385 1
d4390 1
a4390 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
d4401 1
d4407 1
a4407 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
d4409 3
d4418 1
d4424 1
a4424 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
d4426 14
d4446 1
d4451 1
a4451 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
d4453 2
d4464 1
d4470 1
a4470 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
d4472 5
d4483 1
d4489 1
a4489 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);
d4491 16
d4513 1
d4522 1
a4522 1
      set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_fpu);
d4524 9
d4536 102
d4641 1
d4657 11
d4675 1
a4675 1
  gdbarch_register (bfd_arch_sh, sh_gdbarch_init, NULL);
@


1.71.2.12
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1 1
a1 1
/* Target-dependent code for Renesas Super-H, for GDB.
a28 3
#include "frame-base.h"
#include "frame-unwind.h"
#include "dwarf2-frame.h"
a37 1
#include "gdb_assert.h"
d58 9
a66 13
struct sh_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  LONGEST sp_offset;
  CORE_ADDR pc;

  /* Flag showing that a frame has been created in the prologue code. */
  int uses_fp;

  /* Saved registers.  */
  CORE_ADDR saved_regs[SH_NUM_REGS];
  CORE_ADDR saved_sp;
d72 5
a76 4
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
d78 3
a80 3
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr", "spc",
d94 11
a104 10
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
d116 9
a124 8
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "",
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    "ssr", "spc",
d138 5
a142 4
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
d144 3
a146 3
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "ssr", "spc",
d160 5
a164 4
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
d166 3
a168 3
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "", "",
d182 11
a192 10
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "", "",
    "rs", "re", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
d204 12
a215 11
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "ssr", "spc",
    "rs", "re", "", "", "", "", "", "",
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b"
      "", "", "", "", "", "", "", "",
d227 2
a228 1
  static char *register_names[] = {
d230 2
a231 2
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
d233 1
a233 1
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
d237 2
a238 2
    "fr0", "fr1", "fr2", "fr3", "fr4", "fr5", "fr6", "fr7",
    "fr8", "fr9", "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
d240 1
a240 1
    "ssr", "spc",
d246 1
a246 1
    "dr0", "dr2", "dr4", "dr6", "dr8", "dr10", "dr12", "dr14",
d248 1
a248 1
    "fv0", "fv4", "fv8", "fv12",
a258 54
static const char *
sh_sh4_nofpu_register_name (int reg_nr)
{
  static char *register_names[] = {
    /* general registers 0-15 */
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    /* 16 - 22 */
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    /* 23, 24 */
    "", "",
    /* floating point registers 25 - 40 -- not for nofpu target */
    "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "",
    /* 41, 42 */
    "ssr", "spc",
    /* bank 0 43 - 50 */
    "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
    /* bank 1 51 - 58 */
    "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
    /* double precision (pseudo) 59 - 66 -- not for nofpu target */
    "", "", "", "", "", "", "", "",
    /* vectors (pseudo) 67 - 70 -- not for nofpu target */
    "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

static const char *
sh_sh4al_dsp_register_name (int reg_nr)
{
  static char *register_names[] = {
    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15",
    "pc", "pr", "gbr", "vbr", "mach", "macl", "sr",
    "", "dsr",
    "a0g", "a0", "a1g", "a1", "m0", "m1", "x0", "x1",
    "y0", "y1", "", "", "", "", "", "mod",
    "ssr", "spc",
    "rs", "re", "", "", "", "", "", "",
    "r0b", "r1b", "r2b", "r3b", "r4b", "r5b", "r6b", "r7b"
      "", "", "", "", "", "", "", "",
  };
  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

d263 2
a264 2
  static unsigned char breakpoint[] = { 0xc3, 0xc3 };

d269 16
d286 20
a305 5
   mov.l	r14,@@-r15
   sts.l	pr,@@-r15
   mov.l	<regs>,@@-r15
   sub		<room_for_loca_vars>,r15
   mov		r15,r14
a306 1
   Actually it can be more complicated than this but that's it, basically.
a308 3
#define GET_SOURCE_REG(x)  	(((x) >> 4) & 0xf)
#define GET_TARGET_REG(x)  	(((x) >> 8) & 0xf)

d317 2
d325 1
a325 1
#define IS_ADD_IMM_SP(x) 	(((x) & 0xff00) == 0x7f00)
d339 80
a418 2
/* #define IS_FMOV(x)		(((x) & 0xf00f) == 0xf00b) */
#define IS_FPUSH(x)		(((x) & 0xff0f) == 0xff0b)
d420 12
a431 22
/* MOV Rm,Rn          Rm-->Rn        0110nnnnmmmm0011  4 <= m <= 7 */
#define IS_MOV_ARG_TO_REG(x) \
	(((x) & 0xf00f) == 0x6003 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)
/* MOV.L Rm,@@Rn               0010nnnnmmmm0010  n = 14, 4 <= m <= 7 */
#define IS_MOV_ARG_TO_IND_R14(x) \
	(((x) & 0xff0f) == 0x2e02 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)
/* MOV.L Rm,@@(disp*4,Rn)      00011110mmmmdddd  n = 14, 4 <= m <= 7 */
#define IS_MOV_ARG_TO_IND_R14_WITH_DISP(x) \
	(((x) & 0xff00) == 0x1e00 && \
	 ((x) & 0x00f0) >= 0x0040 && \
	 ((x) & 0x00f0) <= 0x0070)

/* MOV.W @@(disp*2,PC),Rn      1001nnnndddddddd */
#define IS_MOVW_PCREL_TO_REG(x)	(((x) & 0xf000) == 0x9000)
/* MOV.L @@(disp*4,PC),Rn      1101nnnndddddddd */
#define IS_MOVL_PCREL_TO_REG(x)	(((x) & 0xf000) == 0xd000)
/* SUB Rn,R15                 00111111nnnn1000 */
#define IS_SUB_REG_FROM_SP(x)	(((x) & 0xff0f) == 0x3f08)
d433 19
a451 1
#define FPSCR_SZ		(1 << 20)
d453 13
a465 7
/* The following instructions are used for epilogue testing. */
#define IS_RESTORE_FP(x)	((x) == 0x6ef6)
#define IS_RTS(x)		((x) == 0x000b)
#define IS_LDS(x)  		((x) == 0x4f26)
#define IS_MOV_FP_SP(x)  	((x) == 0x6fe3)
#define IS_ADD_REG_TO_FP(x)	(((x) & 0xff0f) == 0x3e0c)
#define IS_ADD_IMM_FP(x) 	(((x) & 0xff00) == 0x7e00)
d469 1
a469 1
gdb_print_insn_sh (bfd_vma memaddr, disassemble_info * info)
d475 27
d503 1
a503 2
sh_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
		     struct sh_frame_cache *cache)
d505 34
a538 4
  ULONGEST inst;
  CORE_ADDR opc;
  int offset;
  int sav_offset = 0;
d540 22
a561 1
  int reg, sav_reg = -1;
d563 12
a574 2
  if (pc >= current_pc)
    return current_pc;
a575 1
  cache->uses_fp = 0;
d578 1
a578 1
      inst = read_memory_unsigned_integer (pc, 2);
d582 3
a584 2
	  cache->saved_regs[GET_SOURCE_REG (inst)] = cache->sp_offset;
	  cache->sp_offset += 4;
d588 4
a591 2
	  cache->saved_regs[PR_REGNUM] = cache->sp_offset;
	  cache->sp_offset += 4;
d603 1
a603 1
	  cache->sp_offset += -r3_val;
d607 1
a607 50
	  offset = ((inst & 0xff) ^ 0x80) - 0x80;
	  cache->sp_offset -= offset;
	}
      else if (IS_MOVW_PCREL_TO_REG (inst))
	{
	  if (sav_reg < 0)
	    {
	      reg = GET_TARGET_REG (inst);
	      if (reg < 14)
		{
		  sav_reg = reg;
		  offset = (((inst & 0xff) ^ 0x80) - 0x80) << 1;
		  sav_offset =
		    read_memory_integer (((pc + 4) & ~3) + offset, 2);
		}
	    }
	}
      else if (IS_MOVL_PCREL_TO_REG (inst))
	{
	  if (sav_reg < 0)
	    {
	      reg = (inst & 0x0f00) >> 8;
	      if (reg < 14)
		{
		  sav_reg = reg;
		  offset = (((inst & 0xff) ^ 0x80) - 0x80) << 1;
		  sav_offset =
		    read_memory_integer (((pc + 4) & ~3) + offset, 4);
		}
	    }
	}
      else if (IS_SUB_REG_FROM_SP (inst))
	{
	  reg = GET_SOURCE_REG (inst);
	  if (sav_reg > 0 && reg == sav_reg)
	    {
	      sav_reg = -1;
	    }
	  cache->sp_offset += sav_offset;
	}
      else if (IS_FPUSH (inst))
	{
	  if (read_register (FPSCR_REGNUM) & FPSCR_SZ)
	    {
	      cache->sp_offset += 8;
	    }
	  else
	    {
	      cache->sp_offset += 4;
	    }
d610 4
a613 35
	{
	  if (!cache->uses_fp)
	    cache->uses_fp = 1;
	  /* At this point, only allow argument register moves to other
	     registers or argument register moves to @@(X,fp) which are
	     moving the register arguments onto the stack area allocated
	     by a former add somenumber to SP call.  Don't allow moving
	     to an fp indirect address above fp + cache->sp_offset. */
	  pc += 2;
	  for (opc = pc + 12; pc < opc; pc += 2)
	    {
	      inst = read_memory_integer (pc, 2);
	      if (IS_MOV_ARG_TO_IND_R14 (inst))
		{
		  reg = GET_SOURCE_REG (inst);
		  if (cache->sp_offset > 0)
		    cache->saved_regs[reg] = cache->sp_offset;
		}
	      else if (IS_MOV_ARG_TO_IND_R14_WITH_DISP (inst))
		{
		  reg = GET_SOURCE_REG (inst);
		  offset = (inst & 0xf) * 4;
		  if (cache->sp_offset > offset)
		    cache->saved_regs[reg] = cache->sp_offset - offset;
		}
	      else if (IS_MOV_ARG_TO_REG (inst))
		continue;
	      else
		break;
	    }
	  break;
	}
#if 0				/* This used to just stop when it found an instruction that
				   was not considered part of the prologue.  Now, we just
				   keep going looking for likely instructions. */
d619 1
a619 2
  return pc;
}
d621 6
a626 1
/* Skip any prologue before the guts of a function */
d628 7
a634 7
/* Skip the prologue using the debug information. If this fails we'll
   fall back on the 'guess' method below. */
static CORE_ADDR
after_prologue (CORE_ADDR pc)
{
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;
d636 8
a643 8
  /* If we can not find the symbol in the partial symbol table, then
     there is no hope we can determine the function's start address
     with this code.  */
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    return 0;

  /* Get the line associated with FUNC_ADDR.  */
  sal = find_pc_line (func_addr, 0);
d645 3
a647 9
  /* There are only two cases to consider.  First, the end of the source line
     is within the function bounds.  In that case we return the end of the
     source line.  Second is the end of the source line extends beyond the
     bounds of the current function.  We need to use the slow code to
     examine instructions in that case.  */
  if (sal.end < func_end)
    return sal.end;
  else
    return 0;
d650 3
a652 2
static CORE_ADDR
sh_skip_prologue (CORE_ADDR start_pc)
d654 1
a654 2
  CORE_ADDR pc;
  struct sh_frame_cache cache;
d656 4
a659 4
  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  pc = after_prologue (start_pc);
d661 5
a665 4
  /* If after_prologue returned a useful address, then use it.  Else
     fall back on the instruction skipping code. */
  if (pc)
    return max (pc, start_pc);
d667 3
a669 6
  cache.sp_offset = -4;
  pc = sh_analyze_prologue (start_pc, (CORE_ADDR) -1, &cache);
  if (!cache.uses_fp)
    return start_pc;

  return pc;
d672 26
a697 1
/* The ABI says:
d699 2
a700 3
   Aggregate types not bigger than 8 bytes that have the same size and
   alignment as one of the integer scalar types are returned in the
   same registers as the integer type they match.
d702 2
a703 4
   For example, a 2-byte aligned structure with size 2 bytes has the
   same size and alignment as a short int, and will be returned in R0.
   A 4-byte aligned structure with size 8 bytes has the same size and
   alignment as a long long int, and will be returned in R0 and R1.
d705 1
a705 8
   When an aggregate type is returned in R0 and R1, R0 contains the
   first four bytes of the aggregate, and R1 contains the
   remainder. If the size of the aggregate type is not a multiple of 4
   bytes, the aggregate is tail-padded up to a multiple of 4
   bytes. The value of the padding is undefined. For little-endian
   targets the padding will appear at the most significant end of the
   last element, for big-endian targets the padding appears at the
   least significant end of the last element.
d707 3
a709 4
   All other aggregate types are returned by address. The caller
   function passes the address of an area large enough to hold the
   aggregate value in R2. The called function stores the result in
   this location.
d711 6
a716 3
   To reiterate, structs smaller than 8 bytes could also be returned
   in memory, if they don't pass the "same size and alignment as an
   integer type" rule.
d718 53
a770 1
   For example, in
d772 1
a772 2
   struct s { char c[3]; } wibble;
   struct s foo(void) {  return wibble; }
d774 6
a779 2
   the return value from foo() will be in memory, not
   in R0, because there is no 3-byte integer type.
d781 7
a787 1
   Similarly, in 
d789 9
a797 2
   struct s { char c[2]; } wibble;
   struct s foo(void) {  return wibble; }
d799 4
a802 4
   because a struct containing two chars has alignment 1, that matches
   type char, but size 2, that matches type short.  There's no integer
   type that has alignment 1 and size 2, so the struct is returned in
   memory.
d804 3
a806 4
*/

static int
sh_use_struct_convention (int gcc_p, struct type *type)
a807 2
  int len = TYPE_LENGTH (type);
  int nelem = TYPE_NFIELDS (type);
d809 1
a809 9
  /* Non-power of 2 length types and types bigger than 8 bytes (which don't
     fit in two registers anyway) use struct convention.  */
  if (len != 1 && len != 2 && len != 4 && len != 8)
    return 1;

  /* Scalar types and aggregate types with exactly one field are aligned
     by definition.  They are returned in registers.  */
  if (nelem <= 1)
    return 0;
d811 2
a812 4
  /* If the first field in the aggregate has the same length as the entire
     aggregate type, the type is returned in registers.  */
  if (TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == len)
    return 0;
d814 20
a833 8
  /* If the size of the aggregate is 8 bytes and the first field is
     of size 4 bytes its alignment is equal to long long's alignment,
     so it's returned in registers.  */
  if (len == 8 && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)
    return 0;

  /* Otherwise use struct convention.  */
  return 1;
a842 1

d848 36
d892 1
a892 1
   On the Renesas SH architecture, there are four registers (R4 to R7)
d932 8
a939 150
   If the function is to return an aggregate type such as a struct, it 
   is either returned in the normal return value register R0 (if its 
   size is no greater than one byte), or else the caller must allocate
   space into which the callee will copy the return value (if the size
   is greater than one byte).  In this case, a pointer to the return 
   value location is passed into the callee in register R2, which does 
   not displace any of the other arguments passed in via registers R4
   to R7.   */

/* Helper function to justify value in register according to endianess. */
static char *
sh_justify_value_in_reg (struct value *val, int len)
{
  static char valbuf[4];

  memset (valbuf, 0, sizeof (valbuf));
  if (len < 4)
    {
      /* value gets right-justified in the register or stack word */
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	memcpy (valbuf + (4 - len), (char *) VALUE_CONTENTS (val), len);
      else
	memcpy (valbuf, (char *) VALUE_CONTENTS (val), len);
      return valbuf;
    }
  return (char *) VALUE_CONTENTS (val);
}

/* Helper function to eval number of bytes to allocate on stack. */
static CORE_ADDR
sh_stack_allocsize (int nargs, struct value **args)
{
  int stack_alloc = 0;
  while (nargs-- > 0)
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[nargs])) + 3) & ~3);
  return stack_alloc;
}

/* Helper functions for getting the float arguments right.  Registers usage
   depends on the ABI and the endianess.  The comments should enlighten how
   it's intended to work. */

/* This array stores which of the float arg registers are already in use. */
static int flt_argreg_array[FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM + 1];

/* This function just resets the above array to "no reg used so far". */
static void
sh_init_flt_argreg (void)
{
  memset (flt_argreg_array, 0, sizeof flt_argreg_array);
}

/* This function returns the next register to use for float arg passing.
   It returns either a valid value between FLOAT_ARG0_REGNUM and
   FLOAT_ARGLAST_REGNUM if a register is available, otherwise it returns 
   FLOAT_ARGLAST_REGNUM + 1 to indicate that no register is available.

   Note that register number 0 in flt_argreg_array corresponds with the
   real float register fr4.  In contrast to FLOAT_ARG0_REGNUM (value is
   29) the parity of the register number is preserved, which is important
   for the double register passing test (see the "argreg & 1" test below). */
static int
sh_next_flt_argreg (int len)
{
  int argreg;

  /* First search for the next free register. */
  for (argreg = 0; argreg <= FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM;
       ++argreg)
    if (!flt_argreg_array[argreg])
      break;

  /* No register left? */
  if (argreg > FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM)
    return FLOAT_ARGLAST_REGNUM + 1;

  if (len == 8)
    {
      /* Doubles are always starting in a even register number. */
      if (argreg & 1)
	{
	  flt_argreg_array[argreg] = 1;

	  ++argreg;

	  /* No register left? */
	  if (argreg > FLOAT_ARGLAST_REGNUM - FLOAT_ARG0_REGNUM)
	    return FLOAT_ARGLAST_REGNUM + 1;
	}
      /* Also mark the next register as used. */
      flt_argreg_array[argreg + 1] = 1;
    }
  else if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
    {
      /* In little endian, gcc passes floats like this: f5, f4, f7, f6, ... */
      if (!flt_argreg_array[argreg + 1])
	++argreg;
    }
  flt_argreg_array[argreg] = 1;
  return FLOAT_ARG0_REGNUM + argreg;
}

/* Helper function which figures out, if a type is treated like a float type.

   The FPU ABIs have a special way how to treat types as float types.
   Structures with exactly one member, which is of type float or double, are
   treated exactly as the base types float or double:

     struct sf {
       float f;
     };

     struct sd {
       double d;
     };

   are handled the same way as just

     float f;

     double d;

   As a result, arguments of these struct types are pushed into floating point
   registers exactly as floats or doubles, using the same decision algorithm.

   The same is valid if these types are used as function return types.  The
   above structs are returned in fr0 resp. fr0,fr1 instead of in r0, r0,r1
   or even using struct convention as it is for other structs.  */

static int
sh_treat_as_flt_p (struct type *type)
{
  int len = TYPE_LENGTH (type);

  /* Ordinary float types are obviously treated as float.  */
  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    return 1;
  /* Otherwise non-struct types are not treated as float.  */
  if (TYPE_CODE (type) != TYPE_CODE_STRUCT)
    return 0;
  /* Otherwise structs with more than one memeber are not treated as float.  */
  if (TYPE_NFIELDS (type) != 1)
    return 0;
  /* Otherwise if the type of that member is float, the whole type is
     treated as float.  */
  if (TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_FLT)
    return 1;
  /* Otherwise it's not treated as float.  */
  return 0;
}
d942 1
a942 1
sh_push_dummy_call_fpu (struct gdbarch *gdbarch,
d944 1
a944 1
			struct regcache *regcache,
d946 1
a946 1
			struct value **args,
d950 2
a951 3
  int stack_offset = 0;
  int argreg = ARG0_REGNUM;
  int flt_argreg = 0;
d956 3
a958 3
  int len, reg_size = 0;
  int pass_on_stack = 0;
  int treat_as_flt;
d963 2
d966 8
a973 8
    regcache_cooked_write_unsigned (regcache,
				    STRUCT_RETURN_REGNUM, struct_addr);

  /* make room on stack for args */
  sp -= sh_stack_allocsize (nargs, args);

  /* Initialize float argument mechanism. */
  sh_init_flt_argreg ();
d978 4
a981 1
  for (argnum = 0; argnum < nargs; argnum++)
d985 13
a997 15
      val = sh_justify_value_in_reg (args[argnum], len);

      /* Some decisions have to be made how various types are handled.
         This also differs in different ABIs. */
      pass_on_stack = 0;

      /* Find out the next register to use for a floating point value. */
      treat_as_flt = sh_treat_as_flt_p (type);
      if (treat_as_flt)
	flt_argreg = sh_next_flt_argreg (len);
      /* In contrast to non-FPU CPUs, arguments are never split between
	 registers and stack.  If an argument doesn't fit in the remaining
	 registers it's always pushed entirely on the stack.  */
      else if (len > ((ARGLAST_REGNUM - argreg + 1) * 4))
	pass_on_stack = 1;
d999 6
d1007 8
a1014 8
	  if ((treat_as_flt && flt_argreg > FLOAT_ARGLAST_REGNUM)
	      || (!treat_as_flt && (argreg > ARGLAST_REGNUM
	                            || pass_on_stack)))
	    {
	      /* The data goes entirely on the stack, 4-byte aligned. */
	      reg_size = (len + 3) & ~3;
	      write_memory (sp + stack_offset, val, reg_size);
	      stack_offset += reg_size;
d1016 5
a1020 1
	  else if (treat_as_flt && flt_argreg <= FLOAT_ARGLAST_REGNUM)
d1022 3
a1024 19
	      /* Argument goes in a float argument register.  */
	      reg_size = register_size (gdbarch, flt_argreg);
	      regval = extract_unsigned_integer (val, reg_size);
	      /* In little endian mode, float types taking two registers
	         (doubles on sh4, long doubles on sh2e, sh3e and sh4) must
		 be stored swapped in the argument registers.  The below
		 code first writes the first 32 bits in the next but one
		 register, increments the val and len values accordingly
		 and then proceeds as normal by writing the second 32 bits
		 into the next register. */
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE
	          && TYPE_LENGTH (type) == 2 * reg_size)
	        {
		  regcache_cooked_write_unsigned (regcache, flt_argreg + 1,
						  regval);
		  val += reg_size;
		  len -= reg_size;
		  regval = extract_unsigned_integer (val, reg_size);
		}
d1027 2
a1028 2
	  else if (!treat_as_flt && argreg <= ARGLAST_REGNUM)
	    {
d1030 2
a1031 2
	      reg_size = register_size (gdbarch, argreg);
	      regval = extract_unsigned_integer (val, reg_size);
d1034 5
a1038 3
	  /* Store the value one register at a time or in one step on stack.  */
	  len -= reg_size;
	  val += reg_size;
d1052 1
a1052 1
sh_push_dummy_call_nofpu (struct gdbarch *gdbarch,
d1054 4
a1057 4
			  struct regcache *regcache,
			  CORE_ADDR bp_addr,
			  int nargs, struct value **args,
			  CORE_ADDR sp, int struct_return,
d1060 2
a1061 2
  int stack_offset = 0;
  int argreg = ARG0_REGNUM;
d1066 3
a1068 1
  int len, reg_size;
d1073 2
d1077 2
a1078 1
				    STRUCT_RETURN_REGNUM, struct_addr);
d1080 4
a1083 2
  /* make room on stack for args */
  sp -= sh_stack_allocsize (nargs, args);
d1088 3
a1090 1
  for (argnum = 0; argnum < nargs; argnum++)
d1094 13
a1106 1
      val = sh_justify_value_in_reg (args[argnum], len);
d1108 4
d1114 6
a1119 7
	  if (argreg > ARGLAST_REGNUM)
	    {
	      /* The remainder of the data goes entirely on the stack,
	         4-byte aligned. */
	      reg_size = (len + 3) & ~3;
	      write_memory (sp + stack_offset, val, reg_size);
	      stack_offset += reg_size;
d1121 5
a1125 2
	  else if (argreg <= ARGLAST_REGNUM)
	    {
d1127 2
a1128 2
	      reg_size = register_size (gdbarch, argreg);
	      regval = extract_unsigned_integer (val, reg_size);
d1131 2
a1132 2
	  /* Store the value reg_size bytes at a time.  This means that things
	     larger than reg_size bytes may go partly in registers and partly
d1134 2
a1135 2
	  len -= reg_size;
	  val += reg_size;
d1159 1
a1159 1

d1171 1
a1171 1
	regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
d1181 1
a1181 1
  if (sh_treat_as_flt_p (type))
d1186 1
a1186 4
	if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
	  regcache_raw_read (regcache, regnum++, (char *) valbuf + len - 4 - i);
	else
	  regcache_raw_read (regcache, regnum++, (char *) valbuf + i);
d1214 1
a1214 1
	regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
d1222 1
a1222 1
  if (sh_treat_as_flt_p (type))
d1227 1
a1227 1
	regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
d1249 9
a1257 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d1259 8
a1266 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1283 1
a1283 1
		   (long) read_register (SSR_REGNUM),
d1286 9
a1294 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d1296 8
a1303 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1321 2
a1322 2
		   (long) read_register (FPUL_REGNUM),
		   (long) read_register (FPSCR_REGNUM));
d1324 9
a1332 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d1334 8
a1341 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1343 18
a1360 2
  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 0), (long) read_register (FP0_REGNUM + 1), (long) read_register (FP0_REGNUM + 2), (long) read_register (FP0_REGNUM + 3), (long) read_register (FP0_REGNUM + 4), (long) read_register (FP0_REGNUM + 5), (long) read_register (FP0_REGNUM + 6), (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 8), (long) read_register (FP0_REGNUM + 9), (long) read_register (FP0_REGNUM + 10), (long) read_register (FP0_REGNUM + 11), (long) read_register (FP0_REGNUM + 12), (long) read_register (FP0_REGNUM + 13), (long) read_register (FP0_REGNUM + 14), (long) read_register (FP0_REGNUM + 15));
d1383 9
a1391 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d1393 8
a1400 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1402 18
a1419 2
  printf_filtered (("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 0), (long) read_register (FP0_REGNUM + 1), (long) read_register (FP0_REGNUM + 2), (long) read_register (FP0_REGNUM + 3), (long) read_register (FP0_REGNUM + 4), (long) read_register (FP0_REGNUM + 5), (long) read_register (FP0_REGNUM + 6), (long) read_register (FP0_REGNUM + 7));
  printf_filtered (("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"), (long) read_register (FP0_REGNUM + 8), (long) read_register (FP0_REGNUM + 9), (long) read_register (FP0_REGNUM + 10), (long) read_register (FP0_REGNUM + 11), (long) read_register (FP0_REGNUM + 12), (long) read_register (FP0_REGNUM + 13), (long) read_register (FP0_REGNUM + 14), (long) read_register (FP0_REGNUM + 15));
d1440 2
a1441 1
  printf_filtered (" DSR=%08lx", (long) read_register (DSR_REGNUM));
d1443 9
a1451 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d1453 17
a1469 11
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered
    ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
     (long) read_register (A0G_REGNUM) & 0xff,
     (long) read_register (A0_REGNUM), (long) read_register (M0_REGNUM),
     (long) read_register (X0_REGNUM), (long) read_register (Y0_REGNUM),
     (long) read_register (RS_REGNUM), (long) read_register (MOD_REGNUM));
d1500 9
a1508 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d1510 8
a1517 4
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
d1521 1
a1521 2
		    :
		    "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
d1530 3
a1532 3
  printf_filtered ((pr ?
		    "DR8-DR14 %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n" :
		    "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
a1543 30
sh4_nofpu_show_regs (void)
{
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));

  printf_filtered ("GBR=%08lx VBR=%08lx",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM));
  printf_filtered (" SSR=%08lx SPC=%08lx",
		   (long) read_register (SSR_REGNUM),
		   (long) read_register (SPC_REGNUM));

  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));
}

static void
d1557 2
a1558 1
  printf_filtered (" DSR=%08lx", (long) read_register (DSR_REGNUM));
d1560 9
a1568 6
  printf_filtered
    ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
     (long) read_register (0), (long) read_register (1),
     (long) read_register (2), (long) read_register (3),
     (long) read_register (4), (long) read_register (5),
     (long) read_register (6), (long) read_register (7));
d1570 17
a1586 11
		   (long) read_register (8), (long) read_register (9),
		   (long) read_register (10), (long) read_register (11),
		   (long) read_register (12), (long) read_register (13),
		   (long) read_register (14), (long) read_register (15));

  printf_filtered
    ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
     (long) read_register (A0G_REGNUM) & 0xff,
     (long) read_register (A0_REGNUM), (long) read_register (M0_REGNUM),
     (long) read_register (X0_REGNUM), (long) read_register (Y0_REGNUM),
     (long) read_register (RS_REGNUM), (long) read_register (MOD_REGNUM));
d1600 1
a1600 1
    (*sh_show_regs) ();
d1609 2
a1610 1
       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
d1629 2
a1630 1
       && (reg_nr <= FP_LAST_REGNUM)) || (reg_nr == FPUL_REGNUM))
d1632 2
a1633 1
  else if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
d1635 2
a1636 1
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
d1676 1
a1676 1
				    char *from, char *to)
d1678 2
a1679 1
  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
d1682 1
a1682 2
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
			       from, &val);
d1686 1
a1686 2
    error
      ("sh_register_convert_to_virtual called with non DR register number");
d1693 2
a1694 1
  if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
d1697 1
a1697 2
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword,
				 &val, to);
d1700 1
a1700 21
    error ("sh_register_convert_to_raw called with non DR register number");
}

/* For vectors of 4 floating point registers. */
static int
fv_reg_base_num (int fv_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + (fv_regnum - FV0_REGNUM) * 4;
  return fp_regnum;
}

/* For double precision floating point registers, i.e 2 fp regs.*/
static int
dr_reg_base_num (int dr_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + (dr_regnum - DR0_REGNUM) * 2;
  return fp_regnum;
d1710 2
a1711 1
  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
d1715 1
a1715 1
      /* Build the value in the provided buffer. */
d1718 1
a1718 1
	regcache_raw_read (regcache, base_regnum + portion,
d1720 1
a1720 2
			    + register_size (gdbarch,
					     base_regnum) * portion));
d1723 1
a1723 2
					  gdbarch_register_type (gdbarch,
								 reg_nr),
d1726 2
a1727 1
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
d1733 1
a1733 1
	regcache_raw_read (regcache, base_regnum + portion,
d1735 1
a1735 2
			    + register_size (gdbarch,
					     base_regnum) * portion));
d1746 2
a1747 1
  if (reg_nr >= DR0_REGNUM && reg_nr <= DR_LAST_REGNUM)
d1752 2
a1753 2
      sh_sh4_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr),
				      reg_nr, buffer, temp_buffer);
d1757 1
a1757 1
	regcache_raw_write (regcache, base_regnum + portion,
d1759 1
a1759 2
			     + register_size (gdbarch,
					      base_regnum) * portion));
d1761 2
a1762 1
  else if (reg_nr >= FV0_REGNUM && reg_nr <= FV_LAST_REGNUM)
d1770 1
a1770 2
			     + register_size (gdbarch,
					      base_regnum) * portion));
d1780 6
a1785 6
  fprintf_filtered (file, "fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n",
		    fv_regnum - FV0_REGNUM,
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1),
		    (int) read_register (first_fp_reg_num + 2),
		    (int) read_register (first_fp_reg_num + 3));
d1795 2
a1796 2
  fprintf_filtered (file, "dr%d\t0x%08x%08x\n",
		    dr_regnum - DR0_REGNUM,
d1808 2
a1809 1
  else if (regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM)
d1811 2
a1812 1
  else if (regnum >= FV0_REGNUM && regnum <= FV_LAST_REGNUM)
d1820 1
a1820 1
  double flt;			/* double extracted from raw hex data */
d1831 1
a1831 1
  /* Get the register as a number */
d1848 2
a1849 3
      int idx = (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
		 ? j
		 : register_size (gdbarch, regnum) - 1 - j);
d1867 1
a1867 1

d1885 1
a1885 2
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	  TYPE_CODE_FLT)
d1918 1
a1918 1
	    {
d1923 1
a1923 2
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) ==
	      TYPE_CODE_FLT)
d1929 1
a1929 1
		  regnum++;
d1973 1
a1973 1
      lmo.r_map_size = 4;
d1978 1
a1978 1
      lmo.l_addr_size = 4;
d1981 1
a1981 1
      lmo.l_name_size = 4;
d1984 1
a1984 1
      lmo.l_next_size = 4;
d1987 1
a1987 1
      lmo.l_prev_size = 4;
d1990 1
a1990 1
  return lmp;
d2011 1
a2011 255

static struct sh_frame_cache *
sh_alloc_frame_cache (void)
{
  struct sh_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct sh_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->saved_sp = 0;
  cache->sp_offset = 0;
  cache->pc = 0;

  /* Frameless until proven otherwise.  */
  cache->uses_fp = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where fp is supposed to be stored).  */
  for (i = 0; i < SH_NUM_REGS; i++)
    {
      cache->saved_regs[i] = -1;
    }

  return cache;
}

static struct sh_frame_cache *
sh_frame_cache (struct frame_info *next_frame, void **this_cache)
{
  struct sh_frame_cache *cache;
  CORE_ADDR current_pc;
  int i;

  if (*this_cache)
    return *this_cache;

  cache = sh_alloc_frame_cache ();
  *this_cache = cache;

  /* In principle, for normal frames, fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame. */
  cache->base = frame_unwind_register_unsigned (next_frame, FP_REGNUM);
  if (cache->base == 0)
    return cache;

  cache->pc = frame_func_unwind (next_frame);
  current_pc = frame_pc_unwind (next_frame);
  if (cache->pc != 0)
    sh_analyze_prologue (cache->pc, current_pc, cache);

  if (!cache->uses_fp)
    {
      /* We didn't find a valid frame, which means that CACHE->base
         currently holds the frame pointer for our calling frame.  If
         we're at the start of a function, or somewhere half-way its
         prologue, the function's frame probably hasn't been fully
         setup yet.  Try to reconstruct the base address for the stack
         frame by looking at the stack pointer.  For truly "frameless"
         functions this might work too.  */
      cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of sp in the calling frame.  */
  cache->saved_sp = cache->base + cache->sp_offset;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < SH_NUM_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] = cache->saved_sp - cache->saved_regs[i] - 4;

  return cache;
}

static void
sh_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			int regnum, int *optimizedp,
			enum lval_type *lvalp, CORE_ADDR *addrp,
			int *realnump, void *valuep)
{
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);

  gdb_assert (regnum >= 0);

  if (regnum == SP_REGNUM && cache->saved_sp)
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
	{
	  /* Store the value.  */
	  store_unsigned_integer (valuep, 4, cache->saved_sp);
	}
      return;
    }

  /* The PC of the previous frame is stored in the PR register of
     the current frame.  Frob regnum so that we pull the value from
     the correct place.  */
  if (regnum == PC_REGNUM)
    regnum = PR_REGNUM;

  if (regnum < SH_NUM_REGS && cache->saved_regs[regnum] != -1)
    {
      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
      if (valuep)
	{
	  /* Read the value in from memory.  */
	  read_memory (*addrp, valuep,
		       register_size (current_gdbarch, regnum));
	}
      return;
    }

  frame_register_unwind (next_frame, regnum,
			 optimizedp, lvalp, addrp, realnump, valuep);
}

static void
sh_frame_this_id (struct frame_info *next_frame, void **this_cache,
		  struct frame_id *this_id)
{
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  *this_id = frame_id_build (cache->saved_sp, cache->pc);
}

static const struct frame_unwind sh_frame_unwind = {
  NORMAL_FRAME,
  sh_frame_this_id,
  sh_frame_prev_register
};

static const struct frame_unwind *
sh_frame_sniffer (struct frame_info *next_frame)
{
  return &sh_frame_unwind;
}

static CORE_ADDR
sh_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, SP_REGNUM);
}

static CORE_ADDR
sh_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
}

static struct frame_id
sh_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_id_build (sh_unwind_sp (gdbarch, next_frame),
			 frame_pc_unwind (next_frame));
}

static CORE_ADDR
sh_frame_base_address (struct frame_info *next_frame, void **this_cache)
{
  struct sh_frame_cache *cache = sh_frame_cache (next_frame, this_cache);

  return cache->base;
}

static const struct frame_base sh_frame_base = {
  &sh_frame_unwind,
  sh_frame_base_address,
  sh_frame_base_address,
  sh_frame_base_address
};

/* The epilogue is defined here as the area at the end of a function,
   either on the `ret' instruction itself or after an instruction which
   destroys the function's stack frame. */
static int
sh_in_function_epilogue_p (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR func_addr = 0, func_end = 0;

  if (find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    {
      ULONGEST inst;
      /* The sh epilogue is max. 14 bytes long.  Give another 14 bytes
         for a nop and some fixed data (e.g. big offsets) which are
         unfortunately also treated as part of the function (which
         means, they are below func_end. */
      CORE_ADDR addr = func_end - 28;
      if (addr < func_addr + 4)
	addr = func_addr + 4;
      if (pc < addr)
	return 0;

      /* First search forward until hitting an rts. */
      while (addr < func_end
	     && !IS_RTS (read_memory_unsigned_integer (addr, 2)))
	addr += 2;
      if (addr >= func_end)
	return 0;

      /* At this point we should find a mov.l @@r15+,r14 instruction,
         either before or after the rts.  If not, then the function has
         probably no "normal" epilogue and we bail out here. */
      inst = read_memory_unsigned_integer (addr - 2, 2);
      if (IS_RESTORE_FP (read_memory_unsigned_integer (addr - 2, 2)))
	addr -= 2;
      else if (!IS_RESTORE_FP (read_memory_unsigned_integer (addr + 2, 2)))
	return 0;

      /* Step over possible lds.l @@r15+,pr. */
      inst = read_memory_unsigned_integer (addr - 2, 2);
      if (IS_LDS (inst))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2);
	}

      /* Step over possible mov r14,r15. */
      if (IS_MOV_FP_SP (inst))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2);
	}

      /* Now check for FP adjustments, using add #imm,r14 or add rX, r14
         instructions. */
      while (addr > func_addr + 4
	     && (IS_ADD_REG_TO_FP (inst) || IS_ADD_IMM_FP (inst)))
	{
	  addr -= 2;
	  inst = read_memory_unsigned_integer (addr - 2, 2);
	}

      if (pc >= addr)
	return 1;
    }
  return 0;
}

d2022 27
a2048 34
    case bfd_mach_sh2e:
      sh_show_regs = sh2e_show_regs;
      break;
    case bfd_mach_sh_dsp:
      sh_show_regs = sh_dsp_show_regs;
      break;

    case bfd_mach_sh3:
      sh_show_regs = sh3_show_regs;
      break;

    case bfd_mach_sh3e:
      sh_show_regs = sh3e_show_regs;
      break;

    case bfd_mach_sh3_dsp:
    case bfd_mach_sh4al_dsp:
      sh_show_regs = sh3_dsp_show_regs;
      break;

    case bfd_mach_sh4:
    case bfd_mach_sh4a:
      sh_show_regs = sh4_show_regs;
      break;

    case bfd_mach_sh4_nofpu:
    case bfd_mach_sh4a_nofpu:
      sh_show_regs = sh4_nofpu_show_regs;
      break;

    case bfd_mach_sh5:
      sh_show_regs = sh64_show_regs;
      /* SH5 is handled entirely in sh64-tdep.c */
      return sh64_gdbarch_init (info, arches);
d2060 4
d2075 1
a2079 4
  set_gdbarch_register_type (gdbarch, sh_default_register_type);

  set_gdbarch_print_registers_info (gdbarch, sh_print_registers_info);

a2087 5
  set_gdbarch_store_return_value (gdbarch, sh_default_store_return_value);
  set_gdbarch_extract_return_value (gdbarch, sh_default_extract_return_value);
  set_gdbarch_extract_struct_value_address (gdbarch,
					    sh_extract_struct_value_address);

a2092 2
  set_gdbarch_push_dummy_call (gdbarch, sh_push_dummy_call_nofpu);

d2094 1
a2094 2
  set_gdbarch_frameless_function_invocation (gdbarch,
					     frameless_look_for_prologue);
d2097 6
a2103 6
  set_gdbarch_unwind_sp (gdbarch, sh_unwind_sp);
  set_gdbarch_unwind_pc (gdbarch, sh_unwind_pc);
  set_gdbarch_unwind_dummy_id (gdbarch, sh_unwind_dummy_id);
  frame_base_set_default (gdbarch, &sh_frame_base);

  set_gdbarch_in_function_epilogue_p (gdbarch, sh_in_function_epilogue_p);
d2109 9
a2118 1

d2121 7
a2127 1
      break;
d2129 2
d2136 1
d2138 1
d2141 1
a2141 2
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
d2143 3
a2146 1

d2149 3
d2153 6
a2159 1

d2162 9
a2171 1

d2177 1
d2179 1
d2182 1
a2182 2
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
d2184 3
a2187 1

d2190 3
d2194 6
a2200 1

a2201 1
    case bfd_mach_sh4a:
d2203 1
d2205 1
d2211 1
a2211 2
      set_gdbarch_extract_return_value (gdbarch,
					sh3e_sh4_extract_return_value);
d2213 1
a2213 6
      break;

    case bfd_mach_sh4_nofpu:
    case bfd_mach_sh4a_nofpu:
      set_gdbarch_register_name (gdbarch, sh_sh4_nofpu_register_name);
      break;
d2215 1
a2215 3
    case bfd_mach_sh4al_dsp:
      set_gdbarch_register_name (gdbarch, sh_sh4al_dsp_register_name);
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
a2216 1

d2219 7
a2231 3
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, sh_frame_sniffer);

d2235 1
a2235 1
extern initialize_file_ftype _initialize_sh_tdep;	/* -Wmissing-prototypes */
d2241 1
a2241 1

@


1.71.2.13
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2247 2
@


1.70
log
@Index: ChangeLog
===================================================================
RCS file: /cvs/src/src/gdb/ChangeLog,v
retrieving revision 1.3144
diff -u -r1.3144 ChangeLog
--- ChangeLog	23 Aug 2002 23:05:38 -0000	1.3144
+++ ChangeLog	23 Aug 2002 23:14:45 -0000
@@@@ -1,3 +1,53 @@@@
2002-08-23  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (STORE_RETURN_VALUE): Add regcache parameter.
	(DEPRECATED_STORE_RETURN_VALUE): New method.
	(EXTRACT_RETURN_VALUE): Make buffer parameter a void pointer.
	* gdbarch.h, gdbarch.c: Re-generate.

	* values.c (set_return_value): Pass current_regcache to
	STORE_RETURN_VALUE.
	* arch-utils.h (legacy_store_return_value): Declare.
	* arch-utils.c (legacy_store_return_value): New function.
	(legacy_extract_return_value): Update parameters.

	* config/pa/tm-hppa.h (DEPRECATED_STORE_RETURN_VALUE): Rename
	STORE_RETURN_VALUE.
	* config/pa/tm-hppa64.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/z8k/tm-z8k.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/sparc/tm-sparclet.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/mn10200/tm-mn10200.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-linux.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m68k/tm-delta68.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/m32r/tm-m32r.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8500/tm-h8500.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.
	* config/h8300/tm-h8300.h (DEPRECATED_STORE_RETURN_VALUE): Ditto.

	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* i386-tdep.c (i386_extract_return_value): Update.
	* arch-utils.c (legacy_extract_return_value): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* sparc-tdep.c (sparc_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* i386-tdep.c (i386_gdbarch_init): Update.

Index: doc/ChangeLog
2002-08-21  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Update
	STORE_RETURN_VALUE, mention regcache.
@
text
@d989 1
a989 1
      return generic_read_register_dummy (fi->pc, fi->frame, regnum);
d1011 1
a1011 1
      return generic_read_register_dummy (fi->pc, fi->frame, pr_regnum);
d1725 5
a1729 5
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame,
					       SP_REGNUM);
      fi->extra_info->return_pc = generic_read_register_dummy (fi->pc,
							       fi->frame,
							       PC_REGNUM);
d1757 2
a1758 2
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame,
					       SP_REGNUM);
d1760 1
a1760 1
	generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
@


1.69
log
@2002-08-02  Andrew Cagney  <cagney@@redhat.com>
* gdbarch.sh (pseudo_register_read, pseudo_register_write):
Replace the architecture methods register_read and register_write.
* gdbarch.h, gdbarch.c: Regenerate.
* regcache.c (init_regcache_descr): Update.
(read_register_gen): Update.
(write_register_gen): Update.
(supply_register): Update comment.
* sh-tdep.c (sh_gdbarch_init): Update.
(sh_pseudo_register_read, sh64_pseudo_register_read): Add
`regcache' and `gdbarch' parameters.  Make `buffer' a void
pointer.  Update code.
(sh_pseudo_register_write, sh64_pseudo_register_write): Add
`regcache' and `gdbarch' parameters.  Make `buffer' a constant
void pointer.  Update code.
(sh64_register_write): Delete.
(sh4_register_read): Delete.
(sh64_register_read): Delete.
(sh4_register_write): Delete.
(sh_sh4_register_convert_to_raw): Make `from' parameter a constant
void pointer, `to' parameter a void pointer.
(sh_sh64_register_convert_to_raw): Ditto.
@
text
@d4202 1
a4202 1
  gdbarch_store_return_value_ftype *sh_store_return_value;
d4568 1
a4568 1
  set_gdbarch_store_return_value (gdbarch, sh_store_return_value);
@


1.68
log
@2002-07-26  Andrew Cagney  <ac131313@@redhat.com>

* z8k-tdep.c: Do not include "obstack.h".
* h8300-tdep.c, h8500-tdep.c: Ditto.
* m68hc11-tdep.c, sh-tdep.c: Ditto.
* valprint.c, v850-tdep.c: Ditto.
* d10v-tdep.c, mn10300-tdep.c: Ditto.
* mn10200-tdep.c: Ditto.

* Makefile.in (z8k-tdep.o): Update dependencies.
(m68hc11-tdep.o, valprint.o): Ditto.
(v850-tdep.o, d10v-tdep.o): Ditto.
(mn10300-tdep.o, sparc-tdep.o): Ditto.
(sh-tdep.o, h8500-tdep.o, h8300-tdep.o): Ditto.
(m32r-tdep.o, mn10200-tdep.o): Specify dependencies.
(sh_opc_h, gdb_sim_sh_h): Define.
(elf_sh_h, elf_bfd_h): Define.
(opcode_m68hc11_h): Define.
(OPCODES_SRC, OPCODES_DIR): define.
(OPCODES): Use $(OPCODES_DIR).
(gdb_sim_d10v_h): Rename sim_d10v_h.
(gdb_sim_arm_h): Rename sim_arm_h.
@
text
@d3334 1
a3334 1
				char *from, char *to)
d3350 1
a3350 1
                              char *from, char *to)
d3374 2
a3375 1
sh_pseudo_register_read (int reg_nr, char *buffer)
d3379 1
a3379 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d3389 1
a3389 1
	regcache_raw_read (current_regcache, base_regnum + portion, 
d3404 3
a3406 2
	regcache_raw_read (current_regcache, base_regnum + portion, 
			   buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3411 2
a3412 12
sh4_register_read (struct gdbarch *gdbarch, int reg_nr, char *buffer)
{
  if (reg_nr >= 0 && reg_nr < gdbarch_tdep (current_gdbarch)->DR0_REGNUM)
    /* It is a regular register. */
    regcache_raw_read (current_regcache, reg_nr, buffer);
  else
    /* It is a pseudo register and we need to construct its value */
    sh_pseudo_register_read (reg_nr, buffer);
}

static void
sh64_pseudo_register_read (int reg_nr, char *buffer)
d3418 1
a3418 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d3429 1
a3429 1
	regcache_raw_read (current_regcache, base_regnum + portion, 
d3448 2
a3449 2
	regcache_raw_read (current_regcache, base_regnum + portion, 
			   (buffer
d3462 2
a3463 2
	regcache_raw_read (current_regcache, base_regnum + portion, 
			   (buffer
d3474 1
a3474 1
      regcache_raw_read (current_regcache, base_regnum, temp_buffer);
d3488 1
a3488 1
      regcache_raw_read (current_regcache, base_regnum, buffer);
d3499 1
a3499 1
	regcache_raw_read (current_regcache, base_regnum + portion, 
d3517 2
a3518 2
	regcache_raw_read (current_regcache, base_regnum + portion, 
			   (buffer
d3550 1
a3550 1
      regcache_raw_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3554 1
a3554 1
      regcache_raw_read (current_regcache, sr_base_regnum, temp_buffer);
d3572 1
a3572 1
      regcache_raw_read (current_regcache, base_regnum, buffer);
a3575 12
static void
sh64_register_read (struct gdbarch *gdbarch, int reg_nr, char *buffer)
{

  if (reg_nr >= 0 && reg_nr < gdbarch_tdep (current_gdbarch)->DR0_REGNUM)
    /* It is a regular register. */
    regcache_raw_read (current_regcache, reg_nr, buffer);
  else
    /* It is a pseudo register and we need to construct its value */
    sh64_pseudo_register_read (reg_nr, buffer);
}

d3577 2
a3578 1
sh_pseudo_register_write (int reg_nr, char *buffer)
d3582 1
a3582 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d3595 1
a3595 1
	regcache_raw_write (current_regcache, base_regnum + portion, 
d3606 2
a3607 2
	regcache_raw_write (current_regcache, base_regnum + portion,
			    (buffer
a3611 11
static void
sh4_register_write (struct gdbarch *gdbarch, int reg_nr, char *buffer)
{
  if (reg_nr >= 0 && reg_nr < gdbarch_tdep (current_gdbarch)->DR0_REGNUM)
    /* It is a regular register. */
    regcache_raw_write (current_regcache, reg_nr, buffer);
  else
    /* It is a pseudo register and we need to construct its value */
    sh_pseudo_register_write (reg_nr, buffer);
}

d3613 2
a3614 1
sh64_pseudo_register_write (int reg_nr, char *buffer)
d3619 1
a3619 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d3632 1
a3632 1
	regcache_raw_write (current_regcache, base_regnum + portion, 
d3644 2
a3645 2
	regcache_raw_write (current_regcache, base_regnum + portion,
			    (buffer
d3656 2
a3657 2
	regcache_raw_write (current_regcache, base_regnum + portion,
			    (buffer
d3675 1
a3675 1
      regcache_raw_read (current_regcache, base_regnum, temp_buffer);
d3678 1
a3678 1
      regcache_raw_write (current_regcache, base_regnum, temp_buffer);
d3687 1
a3687 1
      regcache_raw_write (current_regcache, base_regnum, buffer);
d3700 1
a3700 1
	  regcache_raw_write (current_regcache, base_regnum + portion,
d3713 2
a3714 2
	  regcache_raw_write (current_regcache, base_regnum + portion,
			      (buffer
d3757 1
a3757 1
      regcache_raw_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3762 1
a3762 1
      regcache_raw_write (current_regcache, fpscr_base_regnum, temp_buffer);
d3764 1
a3764 1
      regcache_raw_read (current_regcache, sr_base_regnum, temp_buffer);
d3769 1
a3769 1
      regcache_raw_write (current_regcache, sr_base_regnum, temp_buffer);
d3775 1
a3775 1
      regcache_raw_write (current_regcache, base_regnum, buffer);
a3778 11
static void
sh64_register_write (struct gdbarch *gdbarch, int reg_nr, char *buffer)
{
  if (reg_nr >= 0 && reg_nr < gdbarch_tdep (current_gdbarch)->DR0_REGNUM)
    /* It is a regular register. */
    regcache_raw_write (current_regcache, reg_nr, buffer);
  else
    /* It is a pseudo register and we need to construct its value */
    sh64_pseudo_register_write (reg_nr, buffer);
}

d4411 2
a4412 2
      set_gdbarch_register_read (gdbarch, sh4_register_read);
      set_gdbarch_register_write (gdbarch, sh4_register_write);
d4503 2
a4504 2
      set_gdbarch_register_read (gdbarch, sh64_register_read);
      set_gdbarch_register_write (gdbarch, sh64_register_write);
@


1.67
log
@2002-07-24  Andrew Cagney  <cagney@@redhat.com>
* regcache.h (regcache_raw_read, regcache_raw_write): Replace
regcache_read and regcache_write.
(regcache_raw_read_as_address): Replace regcache_read_as_address.
* regcache.c: Update.
* sh-tdep.c (sh64_push_arguments): Update comment.
(sh_pseudo_register_read): Update.
(sh_pseudo_register_write): Update.
(sh4_register_read): Update.
(sh4_register_write): Update.
(sh64_pseudo_register_read): Update.
(sh64_pseudo_register_write): Update.
(sh64_register_read): Update.
(sh64_register_write): Update.
* i386-tdep.c (i386_extract_return_value): Update.
(i386_extract_struct_value_address): Update.
(i386_extract_return_value): Update.
* blockframe.c (generic_read_register_dummy): Update.
(generic_call_dummy_register_unwind): Update
* infrun.c (write_inferior_status_register): Update.
@
text
@a28 1
#include "obstack.h"
@


1.66
log
@include/gdb:
	* sim-sh.h: Add enum constants for sh[1-4], sh3e, sh3?-dsp,
	renumbering the sh-dsp registers to use distinct numbers.
sim/sh:
	* Makefile.in (interp.o): Depend on $(srcroot)/include/gdb/sim-sh.h.
	* interp.c: Include "gdb/sim-sh.h".
	(sim_store_register, sim_fetch_register): Use constants defined there.
gdb:
	* sh-tdep.c (sh_dsp_register_sim_regno): New function.
	(sh_gdbarch_init): Use it for sh-dsp.
@
text
@d2254 6
a2259 5
		       of regcache_write, because regcache_write works
		       only for real registers, not pseudo.
		       write_register_gen will call the gdbarch
		       function to do register writes, and that will
		       properly know how to deal with pseudoregs. */
d3389 3
a3391 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3404 2
a3405 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3414 1
a3414 1
    regcache_read (current_regcache, reg_nr, buffer);
d3438 3
a3440 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3457 3
a3459 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3471 3
a3473 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3483 1
a3483 1
      regcache_read (current_regcache, base_regnum, temp_buffer);
d3497 1
a3497 1
      regcache_read (current_regcache, base_regnum, buffer);
d3508 3
a3510 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3526 3
a3528 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3559 1
a3559 1
      regcache_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3563 1
a3563 1
      regcache_read (current_regcache, sr_base_regnum, temp_buffer);
d3581 1
a3581 1
      regcache_read (current_regcache, base_regnum, buffer);
d3591 1
a3591 1
    regcache_read (current_regcache, reg_nr, buffer);
d3615 3
a3617 3
	regcache_write (current_regcache, base_regnum + portion, 
			(temp_buffer
			 + REGISTER_RAW_SIZE (base_regnum) * portion));
d3626 3
a3628 2
	regcache_write (current_regcache, base_regnum + portion,
			buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3637 1
a3637 1
    regcache_write (current_regcache, reg_nr, buffer);
d3662 3
a3664 3
	regcache_write (current_regcache, base_regnum + portion, 
			(temp_buffer
			 + REGISTER_RAW_SIZE (base_regnum) * portion));
d3674 3
a3676 2
	regcache_write (current_regcache, base_regnum + portion,
			buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3686 3
a3688 2
	regcache_write (current_regcache, base_regnum + portion,
			buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3705 1
a3705 1
      regcache_read (current_regcache, base_regnum, temp_buffer);
d3708 1
a3708 1
      regcache_write (current_regcache, base_regnum, temp_buffer);
d3717 1
a3717 1
      regcache_write (current_regcache, base_regnum, buffer);
d3730 3
a3732 3
	  regcache_write (current_regcache, base_regnum + portion,
			  (temp_buffer
			   + REGISTER_RAW_SIZE (base_regnum) * portion));
d3743 3
a3745 2
	  regcache_write (current_regcache, base_regnum + portion,
			  buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3787 1
a3787 1
      regcache_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3792 1
a3792 1
      regcache_write (current_regcache, fpscr_base_regnum, temp_buffer);
d3794 1
a3794 1
      regcache_read (current_regcache, sr_base_regnum, temp_buffer);
d3799 1
a3799 1
      regcache_write (current_regcache, sr_base_regnum, temp_buffer);
d3805 1
a3805 1
      regcache_write (current_regcache, base_regnum, buffer);
d3814 1
a3814 1
    regcache_write (current_regcache, reg_nr, buffer);
@


1.65
log
@* frame.h (deprecated_generic_find_dummy_frame): Rename
generic_find_dummy_frame.
* blockframe.c (generic_find_dummy_frame): Make static.
(deprecated_generic_find_dummy_frame): New function.
* sh-tdep.c (sh_nofp_frame_init_saved_regs): Replace
generic_find_dummy_frame with deprecated_find_dummy_frame.
(sh64_nofp_frame_init_saved_regs): Ditto.
(sh_fp_frame_init_saved_regs): Ditto.
* s390-tdep.c (s390_frame_saved_pc_nofix): Ditto.
(s390_frame_chain): Ditto.
* cris-tdep.c (cris_frame_init_saved_regs): Ditto.
@
text
@d4185 41
d4324 1
d4359 1
@


1.64
log
@* regcache.h: Update copyright.
(struct regcache, struct gdbarch): Add opaque declarations.
(current_regcache): Declare global variable.
(regcache_read, regcache_write): Add gdbarch parameter.
(regcache_save, regcache_save_no_passthrough)
(regcache_restore, regcache_restore_no_passthrough)
(regcache_dup, regcache_dup_no_passthrough)
(regcache_cpy, regcache_cpy_no_passthrough)
(deprecated_grub_regcache_for_registers)
(deprecated_grub_regcache_for_register_valid)
(regcache_valid_p): Add function declarations.

* regcache.c: Update copyright.
(regcache_descr_handle): New global variable.
(struct regcache_descr): Define.
(init_legacy_regcache_descr, init_regcache_descr): New functions.
(regcache_descr, xfree_regcache_descr): New functions.
(struct regcache): Define.
(regcache_xmalloc, regcache_xfree): New functions.
(regcache_cpy, regcache_cpy_no_passthrough): New functions.
(regcache_dup, regcache_dup_no_passthrough): New functions.
(regcache_valid_p, regcache_read_as_address): New functions.
(deprecated_grub_regcache_for_registers): New function.
(deprecated_grub_regcache_for_register_valid): New function.
(current_regcache): New global variable.
(register_buffer): Add regcache parameter.  Update calls.
(regcache_read, regcache_write): Add regcache parameter.  Rewrite.
(read_register_gen, write_register_gen): Update register_buffer
call.  Test for legacy_p instead of gdbarch_register_read_p or
gdbarch_register_write_p.
(regcache_collect): Update register_buffer call.
(build_regcache): Rewrite.  Use deprecated grub functions.
(regcache_save, regcache_save_no_passthrough): New functions.
(regcache_restore, regcache_restore_no_passthrough): New
functions.
(_initialize_regcache): Create the regcache_data_handle. Swap
current_regcache global variable.

* sh-tdep.c (sh_pseudo_register_read): Add current_regcache
parameter to regcache_read and regcache_write calls.
(sh4_register_read): Ditto.
(sh64_pseudo_register_read): Ditto.
(sh64_register_read): Ditto.
(sh_pseudo_register_write): Ditto.
(sh4_register_write): Ditto.
(sh64_pseudo_register_write): Ditto.
(sh64_register_write): Ditto.

* defs.h (XCALLOC): Define.
@
text
@d1049 1
a1049 1
  char *dummy_regs = generic_find_dummy_frame (fi->pc, fi->frame);
d1388 1
a1388 1
  char *dummy_regs = generic_find_dummy_frame (fi->pc, fi->frame);
d1589 1
a1589 1
  char *dummy_regs = generic_find_dummy_frame (fi->pc, fi->frame);
d1817 2
a1818 2
		    generic_find_dummy_frame (frame->pc, frame->frame) +
		    REGISTER_BYTE (regnum),
@


1.63
log
@* gdbarch.sh (REGISTER_NAME): Change return type a constant string
pointer.
* gdbarch.h, gdbarch.c: Regenerate.
* config/mips/tm-mips.h (mips_register_name): Update.
* i386-tdep.h (i386_register_name): Update.
* mips-tdep.c (mips_register_name): Update
* alpha-tdep.c (alpha_register_name): Update.
* arch-utils.c (legacy_register_name): Update.
* arch-utils.h (legacy_register_name): Update.
* avr-tdep.c (avr_register_name): Update.
* ia64-tdep.c (ia64_register_name): Update.
* i386-tdep.c (i386_register_name): Update.
* sparc-tdep.c (sparc32_register_name): Update.
(sparc64_register_name): Update.
(sparclite_register_name): Update.
(sparclet_register_name):
* sh-tdep.c (sh_generic_register_name): Update.
(sh_sh_register_name): Update.
(sh_sh3_register_name): Update.
(sh_sh3e_register_name): Update.
(sh_sh_dsp_register_name): Update.
(sh_sh3_dsp_register_name): Update.
(sh_sh4_register_name): Update.
(sh_sh64_register_name): Update.
* s390-tdep.c (s390_register_name): Update.
* rs6000-tdep.c (rs6000_register_name): Update.
* ns32k-tdep.c (ns32k_register_name_32082): Update.
(ns32k_register_name_32382): Update.
* d10v-tdep.c (d10v_ts2_register_name): Update.
(d10v_ts3_register_name): Update.
* xstormy16-tdep.c (xstormy16_register_name): Update.
* vax-tdep.c (vax_register_name): Update.
* v850-tdep.c (v850_register_name): Update.
* m68hc11-tdep.c (m68hc11_register_name): Update.
* mn10300-tdep.c (mn10300_generic_register_name): Update.
(am33_register_name): Update.
@
text
@d3388 3
a3390 3
	regcache_read (base_regnum + portion, 
		       temp_buffer
		       + REGISTER_RAW_SIZE (base_regnum) * portion);
d3403 1
a3403 1
	regcache_read (base_regnum + portion, 
d3413 1
a3413 1
    regcache_read (reg_nr, buffer);
d3437 3
a3439 3
	regcache_read (base_regnum + portion, 
				 temp_buffer
				 + REGISTER_RAW_SIZE (base_regnum) * portion);
d3456 2
a3457 2
	regcache_read (base_regnum + portion, 
				 buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3469 2
a3470 2
	regcache_read (base_regnum + portion, 
				 buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3480 1
a3480 1
      regcache_read (base_regnum, temp_buffer);
d3494 1
a3494 1
      regcache_read (base_regnum, buffer);
d3505 3
a3507 3
	regcache_read (base_regnum + portion, 
				 temp_buffer
				 + REGISTER_RAW_SIZE (base_regnum) * portion);
d3523 2
a3524 2
	regcache_read (base_regnum + portion, 
				 buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3555 1
a3555 1
      regcache_read (fpscr_base_regnum, temp_buffer);
d3559 1
a3559 1
      regcache_read (sr_base_regnum, temp_buffer);
d3577 1
a3577 1
      regcache_read (base_regnum, buffer);
d3587 1
a3587 1
    regcache_read (reg_nr, buffer);
d3611 3
a3613 2
	regcache_write (base_regnum + portion, 
			temp_buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3622 1
a3622 1
	regcache_write (base_regnum + portion,
d3632 1
a3632 1
    regcache_write (reg_nr, buffer);
d3657 3
a3659 2
	regcache_write (base_regnum + portion, 
			temp_buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3669 1
a3669 1
	regcache_write (base_regnum + portion,
d3680 1
a3680 1
	regcache_write (base_regnum + portion,
d3698 1
a3698 1
      regcache_read (base_regnum, temp_buffer);
d3701 1
a3701 1
      regcache_write (base_regnum, temp_buffer);
d3710 1
a3710 1
      regcache_write (base_regnum, buffer);
d3723 3
a3725 2
	  regcache_write (base_regnum + portion,
			  temp_buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3736 1
a3736 1
	  regcache_write (base_regnum + portion,
d3779 1
a3779 1
      regcache_read (fpscr_base_regnum, temp_buffer);
d3784 1
a3784 1
      regcache_write (fpscr_base_regnum, temp_buffer);
d3786 1
a3786 1
      regcache_read (sr_base_regnum, temp_buffer);
d3791 1
a3791 1
      regcache_write (sr_base_regnum, temp_buffer);
d3797 1
a3797 1
      regcache_write (base_regnum, buffer);
d3806 1
a3806 1
    regcache_write (reg_nr, buffer);
@


1.62
log
@+	* gdbarch.sh (DEPRECATED_EXTRACT_RETURN_VALUE): Rename
+	EXTRACT_RETURN_VALUE.
+	(DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Rename
+	EXTRACT_STRUCT_VALUE_ADDRESS.
+	* gdbarch.h, gdbarch.c: Regenerate.
+
+	* values.c (value_being_returned): Handle
+	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
+	(EXTRACT_RETURN_VALUE): Define as DEPRECATED_EXTRACT_RETURN_VALUE.
+
+	* arm-linux-tdep.c (arm_linux_init_abi): Update.
+	* arm-tdep.c (arm_gdbarch_init): Update.
+	* avr-tdep.c (avr_gdbarch_init): Update.
+	* cris-tdep.c (cris_gdbarch_init): Update.
+	* d10v-tdep.c (d10v_gdbarch_init): Update.
+	* ia64-tdep.c (ia64_gdbarch_init): Update.
+	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
+	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sh-tdep.c (sh_gdbarch_init): Update.
+	* s390-tdep.c (s390_gdbarch_init): Update.
+	* sparc-tdep.c (sparc_gdbarch_init): Update.
+	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
+	* v850-tdep.c (v850_gdbarch_init): Update.
+	* vax-tdep.c (vax_gdbarch_init): Update.
+	* x86-64-tdep.c (x86_64_gdbarch_init): Update.
+	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
+
+	* config/arc/tm-arc.h: Update.
+	* config/d30v/tm-d30v.h: Update.
+	* config/fr30/tm-fr30.h: Update.
+	* config/h8300/tm-h8300.h: Update.
* config/h8500/tm-h8500.h: Update.
* config/i386/tm-i386.h: Update.
* config/i386/tm-ptx.h: Update.
* config/i386/tm-symmetry.h: Update.
* config/i960/tm-i960.h: Update.
* config/m32r/tm-m32r.h: Update.
* config/m68k/tm-delta68.h: Update.
* config/m68k/tm-linux.h: Update.
* config/m68k/tm-m68k.h: Update.
* config/m88k/tm-m88k.h: Update.
* config/mcore/tm-mcore.h: Update.
* config/mips/tm-mips.h: Update.
* config/mn10200/tm-mn10200.h: Update.
* config/pa/tm-hppa.h: Update.
* config/pa/tm-hppa64.h: Update.
* config/sparc/tm-sp64.h: Update.
* config/sparc/tm-sparc.h: Update.
* config/sparc/tm-sparclet.h: Update.
* config/z8k/tm-z8k.h: Update.
@
text
@d71 1
a71 1
static char *
d93 1
a93 1
static char *
d115 1
a115 1
static char *
d137 1
a137 1
static char *
d159 1
a159 1
static char *
d181 1
a181 1
static char *
d204 1
a204 1
static char *
d239 1
a239 1
static char *
@


1.61
log
@* Makefile.in (SFILES): Add osabi.c.
(COMMON_OBS): Add osabi.o.
(osabi.o): New dependency list.
* osabi.c: New file.
* osabi.h: New file.
* doc/gdbint.texinfo: Document new generic OS ABI framework.

* Makefile.in (alpha_tdep_h): Define and use instead of
alpha-tdep.h.
* alpha-tdep.c (alpha_abi_names, process_note_abi_tag_sections,
get_elfosabi, alpha_abi_handler_list, alpha_gdbarch_register_os_abi):
Remove.
(alpha_gdbarch_init, alpha_dump_tdep): Use generic OS ABI framework.
* alpha-tdep.h: Include osabi.h.
(alpha_abi): Remove.
(gdbarch_tdep): Use generic OS ABI framework.
* alpha-linux-tdep.c (_initialize_alpha_linux_tdep): Use
gdbarch_register_osabi.
* alpha-osf1-tdep.c (_initialize_alpha_osf1_tdep): Likewise.
* alphafbsd-tdep.c (_initialize_alphafbsd_tdep): Likewise.
* alphanbsd-tdep.c (_initialize_alphanbsd_tdep): Likewise.

* Makefile.in (sh_tdep_h): Add osabi.h.
* sh-tdep.h (sh_osabi): Remove.
(gdbarch_tdep): Use generic OS ABI framework.
* sh-tdep.c (sh_osabi_names, process_note_abi_tag_sections,
sh_osabi_handler_list, sh_gdbarch_register_os_abi): Remove.
(sh_gdbarch_init, sh_dump_tdep): Use generic OS ABI framework.
* shnbsd-tdep.c (_initialize_shnbsd_tdep): Use gdbarch_register_osabi.

* Makefile.in (arm_tdep_h): Define and use instead of arm-tdep.h.
* arm-linux-tdep.c (_initialize_arm_linux_tdep): Use
gdbarch_register_osabi.
* arm-tdep.c (arm_abi_names, process_note_abi_tag_sections,
arm_abi_handler_list, arm_gdbarch_register_os_abi): Remove.
(get_elfosabi): Rename to...
(arm_elf_osabi_sniffer): ...this.  Adjust to use generic OS
ABI framework support routines.
(arm_gdbarch_init): Use generic OS ABI framework.
(arm_dump_tdep): Likewise.
(_initialize_arm_tdep): Likewise.
* arm-tdep.h: Include osabi.h.
(arm_abi): Remove.
(gdbarch_tdep): Remove arm_abi and abi_name members.  Add
osabi member.
(arm_gdbarch_register_os_abi): Remove prototype.
* armnbsd-tdep.c (arm_netbsd_aout_osabi_sniffer): New function.
(_initialize_arm_netbsd_tdep): Use gdbarch_register_osabi.

* Makefile.in (mips-tdep.o): Add osabi.h to dependency list.
* mips-tdep.c: Include osabi.h.
(gdbarch_tdep, mips_gdbarch_init, mips_dump_tdep): Use generic
OS ABI framework.
@
text
@d4273 1
a4273 1
  set_gdbarch_extract_return_value (gdbarch, sh_extract_return_value);
d4277 1
a4277 1
  set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
d4350 1
a4350 1
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d4390 1
a4390 1
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d4499 1
a4499 1
      set_gdbarch_extract_return_value (gdbarch, sh64_extract_return_value);
d4502 1
a4502 1
      set_gdbarch_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
@


1.61.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d71 1
a71 1
static const char *
d93 1
a93 1
static const char *
d115 1
a115 1
static const char *
d137 1
a137 1
static const char *
d159 1
a159 1
static const char *
d181 1
a181 1
static const char *
d204 1
a204 1
static const char *
d239 1
a239 1
static const char *
d4273 1
a4273 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, sh_extract_return_value);
d4277 1
a4277 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
d4350 1
a4350 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d4390 1
a4390 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d4499 1
a4499 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh64_extract_return_value);
d4502 1
a4502 1
      set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
@


1.61.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1049 1
a1049 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1388 1
a1388 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1589 1
a1589 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1817 2
a1818 2
		    (deprecated_generic_find_dummy_frame (frame->pc, frame->frame)
		     + REGISTER_BYTE (regnum)),
d3388 3
a3390 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3403 1
a3403 1
	regcache_read (current_regcache, base_regnum + portion, 
d3413 1
a3413 1
    regcache_read (current_regcache, reg_nr, buffer);
d3437 3
a3439 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3456 2
a3457 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3469 2
a3470 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3480 1
a3480 1
      regcache_read (current_regcache, base_regnum, temp_buffer);
d3494 1
a3494 1
      regcache_read (current_regcache, base_regnum, buffer);
d3505 3
a3507 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3523 2
a3524 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3555 1
a3555 1
      regcache_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3559 1
a3559 1
      regcache_read (current_regcache, sr_base_regnum, temp_buffer);
d3577 1
a3577 1
      regcache_read (current_regcache, base_regnum, buffer);
d3587 1
a3587 1
    regcache_read (current_regcache, reg_nr, buffer);
d3611 2
a3612 3
	regcache_write (current_regcache, base_regnum + portion, 
			(temp_buffer
			 + REGISTER_RAW_SIZE (base_regnum) * portion));
d3621 1
a3621 1
	regcache_write (current_regcache, base_regnum + portion,
d3631 1
a3631 1
    regcache_write (current_regcache, reg_nr, buffer);
d3656 2
a3657 3
	regcache_write (current_regcache, base_regnum + portion, 
			(temp_buffer
			 + REGISTER_RAW_SIZE (base_regnum) * portion));
d3667 1
a3667 1
	regcache_write (current_regcache, base_regnum + portion,
d3678 1
a3678 1
	regcache_write (current_regcache, base_regnum + portion,
d3696 1
a3696 1
      regcache_read (current_regcache, base_regnum, temp_buffer);
d3699 1
a3699 1
      regcache_write (current_regcache, base_regnum, temp_buffer);
d3708 1
a3708 1
      regcache_write (current_regcache, base_regnum, buffer);
d3721 2
a3722 3
	  regcache_write (current_regcache, base_regnum + portion,
			  (temp_buffer
			   + REGISTER_RAW_SIZE (base_regnum) * portion));
d3733 1
a3733 1
	  regcache_write (current_regcache, base_regnum + portion,
d3776 1
a3776 1
      regcache_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3781 1
a3781 1
      regcache_write (current_regcache, fpscr_base_regnum, temp_buffer);
d3783 1
a3783 1
      regcache_read (current_regcache, sr_base_regnum, temp_buffer);
d3788 1
a3788 1
      regcache_write (current_regcache, sr_base_regnum, temp_buffer);
d3794 1
a3794 1
      regcache_write (current_regcache, base_regnum, buffer);
d3803 1
a3803 1
    regcache_write (current_regcache, reg_nr, buffer);
a4181 41
enum
{
   DSP_DSR_REGNUM = 24,
   DSP_A0G_REGNUM,
   DSP_A0_REGNUM,
   DSP_A1G_REGNUM,
   DSP_A1_REGNUM,
   DSP_M0_REGNUM,
   DSP_M1_REGNUM,
   DSP_X0_REGNUM,
   DSP_X1_REGNUM,
   DSP_Y0_REGNUM,
   DSP_Y1_REGNUM,
 
   DSP_MOD_REGNUM = 40,
 
   DSP_RS_REGNUM = 43,
   DSP_RE_REGNUM,
 
   DSP_R0_BANK_REGNUM = 51,
   DSP_R7_BANK_REGNUM = DSP_R0_BANK_REGNUM + 7
};

static int
sh_dsp_register_sim_regno (int nr)
{
  if (legacy_register_sim_regno (nr) < 0)
    return legacy_register_sim_regno (nr);
  if (nr >= DSP_DSR_REGNUM && nr < DSP_Y1_REGNUM)
    return nr - DSP_DSR_REGNUM + SIM_SH_DSR_REGNUM;
  if (nr == DSP_MOD_REGNUM)
    return SIM_SH_MOD_REGNUM;
  if (nr == DSP_RS_REGNUM)
    return SIM_SH_RS_REGNUM;
  if (nr == DSP_RE_REGNUM)
    return SIM_SH_RE_REGNUM;
  if (nr >= DSP_R0_BANK_REGNUM && nr <= DSP_R7_BANK_REGNUM)
    return nr - DSP_R0_BANK_REGNUM + SIM_SH_R0_BANK_REGNUM;
  return nr;
}

a4279 1
  set_gdbarch_register_sim_regno (gdbarch, legacy_register_sim_regno);
a4313 1
      set_gdbarch_register_sim_regno (gdbarch, sh_dsp_register_sim_regno);
@


1.61.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d29 1
d2254 5
a2258 6
		       of regcache_raw_write, because
		       regcache_raw_write works only for real
		       registers, not pseudo.  write_register_gen will
		       call the gdbarch function to do register
		       writes, and that will properly know how to deal
		       with pseudoregs. */
d3334 1
a3334 1
				const void *from, void *to)
d3350 1
a3350 1
				 const void *from, void *to)
d3374 1
a3374 2
sh_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			 int reg_nr, void *buffer)
d3378 1
a3378 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d3388 3
a3390 3
	regcache_raw_read (regcache, base_regnum + portion, 
			   (temp_buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3403 2
a3404 3
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3409 12
a3420 2
sh64_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, void *buffer)
d3426 1
a3426 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d3437 3
a3439 3
	regcache_raw_read (regcache, base_regnum + portion, 
			   (temp_buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3456 2
a3457 3
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3469 2
a3470 3
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3480 1
a3480 1
      regcache_raw_read (regcache, base_regnum, temp_buffer);
d3494 1
a3494 1
      regcache_raw_read (regcache, base_regnum, buffer);
d3505 3
a3507 3
	regcache_raw_read (regcache, base_regnum + portion, 
			   (temp_buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3523 2
a3524 3
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d3555 1
a3555 1
      regcache_raw_read (regcache, fpscr_base_regnum, temp_buffer);
d3559 1
a3559 1
      regcache_raw_read (regcache, sr_base_regnum, temp_buffer);
d3577 1
a3577 1
      regcache_raw_read (regcache, base_regnum, buffer);
d3581 12
d3594 1
a3594 2
sh_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			  int reg_nr, const void *buffer)
d3598 1
a3598 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d3611 3
a3613 3
	regcache_raw_write (regcache, base_regnum + portion, 
			    (temp_buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d3622 2
a3623 3
	regcache_raw_write (regcache, base_regnum + portion,
			    ((char *) buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d3627 11
d3639 1
a3639 2
sh64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const void *buffer)
d3644 1
a3644 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
d3657 3
a3659 3
	regcache_raw_write (regcache, base_regnum + portion, 
			    (temp_buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d3669 2
a3670 3
	regcache_raw_write (regcache, base_regnum + portion,
			    ((char *) buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d3680 2
a3681 3
	regcache_raw_write (regcache, base_regnum + portion,
			    ((char *) buffer
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d3698 1
a3698 1
      regcache_raw_read (regcache, base_regnum, temp_buffer);
d3701 1
a3701 1
      regcache_raw_write (regcache, base_regnum, temp_buffer);
d3710 1
a3710 1
      regcache_raw_write (regcache, base_regnum, buffer);
d3723 3
a3725 3
	  regcache_raw_write (regcache, base_regnum + portion,
			      (temp_buffer
			       + REGISTER_RAW_SIZE (base_regnum) * portion));
d3736 2
a3737 3
	  regcache_raw_write (regcache, base_regnum + portion,
			      ((char *) buffer
			       + REGISTER_RAW_SIZE (base_regnum) * portion));
d3779 1
a3779 1
      regcache_raw_read (regcache, fpscr_base_regnum, temp_buffer);
d3784 1
a3784 1
      regcache_raw_write (regcache, fpscr_base_regnum, temp_buffer);
d3786 1
a3786 1
      regcache_raw_read (regcache, sr_base_regnum, temp_buffer);
d3791 1
a3791 1
      regcache_raw_write (regcache, sr_base_regnum, temp_buffer);
d3797 1
a3797 1
      regcache_raw_write (regcache, base_regnum, buffer);
d3801 11
d4444 2
a4445 2
      set_gdbarch_pseudo_register_read (gdbarch, sh_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, sh_pseudo_register_write);
d4536 2
a4537 2
      set_gdbarch_pseudo_register_read (gdbarch, sh64_pseudo_register_read);
      set_gdbarch_pseudo_register_write (gdbarch, sh64_pseudo_register_write);
@


1.61.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d4202 1
a4202 1
  gdbarch_deprecated_store_return_value_ftype *sh_store_return_value;
d4568 1
a4568 1
  set_gdbarch_deprecated_store_return_value (gdbarch, sh_store_return_value);
@


1.61.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a886 1
#if 0
a887 6
#else
  int len = TYPE_LENGTH (type);
  int nelem = TYPE_NFIELDS (type);
  return ((len != 1 && len != 2 && len != 4 && len != 8) || nelem != 1) &&
	  (len != 8 || TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) != 4);
#endif
d989 1
a989 1
      return deprecated_read_register_dummy (fi->pc, fi->frame, regnum);
d1011 1
a1011 1
      return deprecated_read_register_dummy (fi->pc, fi->frame, pr_regnum);
d1725 5
a1729 5
      fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
						  SP_REGNUM);
      fi->extra_info->return_pc = deprecated_read_register_dummy (fi->pc,
								  fi->frame,
								  PC_REGNUM);
d1757 2
a1758 2
      fi->frame = deprecated_read_register_dummy (fi->pc, fi->frame,
						  SP_REGNUM);
d1760 1
a1760 1
	deprecated_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);
d2048 2
a2049 5
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	    memcpy (valbuf + (4 - len),
		    (char *) VALUE_CONTENTS (args[argnum]), len);
	  else
	    memcpy (valbuf, (char *) VALUE_CONTENTS (args[argnum]), len);
d2460 2
a2461 5
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	memcpy (buf + REGISTER_RAW_SIZE (R0_REGNUM) - TYPE_LENGTH (type),
		valbuf, TYPE_LENGTH (type));
      else
	memcpy (buf, valbuf, TYPE_LENGTH (type));
d4547 1
a4547 1
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
@


1.61.2.6
log
@merge from mainline
@
text
@d1877 1
a1877 1
    deprecated_read_register_gen (live_regnum, raw_buffer);
d2226 1
a2226 2
		  deprecated_write_register_gen (FP0_REGNUM + float_arg_index,
						 val);
d2269 1
a2269 1
		    deprecated_write_register_gen (regnum, val);
d2504 1
a2504 1
	  deprecated_write_register_gen (FP0_REGNUM, valbuf);
d2527 1
a2527 1
	  deprecated_write_register_gen (return_register, buf);
d2530 1
a2530 1
	deprecated_write_register_gen (return_register, valbuf);
d4292 1
a4292 1
  set_gdbarch_deprecated_do_registers_info (gdbarch, sh_do_registers_info);
d4295 1
a4295 1
  set_gdbarch_get_saved_register (gdbarch, deprecated_generic_get_saved_register);
d4519 1
a4519 1
      set_gdbarch_deprecated_do_registers_info (gdbarch, sh64_do_registers_info);
@


1.60
log
@print_insn_sh cleanup:

include:
	* dis-asm.h (print_insn_shl, print_insn_sh64l): Remove prototype.
gdb:
	* sh-tdep.c (gdb_print_insn_sh64): Delete.
	(gdb_print_insn_sh): Just set info->endian and use print_insn_sh.
	(sh_gdbarch_init): Always use gdb_print_insn_sh.
opcodes:
	* disassemble.c (disassembler): Just use print_insn_sh for bfd_arch_sh.
	* sh-dis.c (LITTLE_BIT): Delete.
	(print_insn_sh, print_insn_shl): Deleted.
	(print_insn_shx): Renamed to
	(print_insn_sh).  No longer static.  Handle SHmedia instructions.
	Use info->endian to determine endianness.
	* sh64-dis.c (print_insn_sh64, print_insn_sh64l): Delete.
	(print_insn_sh64x): No longer static.  Renamed to
	(print_insn_sh64).  Removed pfun_compact and endian arguments.
	If we got an uneven address to indicate SHmedia, adjust it.
	Return -2 for SHcompact instructions.
sim/sh64:
	* sim-if.c (sh64_disassemble_insn): Use  print_insn_sh instead of
	print_insn_shl.
@
text
@a4181 169
/* This table matches the indices assigned to enum sh_osabi.  Keep
   them in sync.  */
static const char * const sh_osabi_names[] =
{
  "<unknown>",
  "GNU/Linux",
  "NetBSD ELF",
  NULL
};

static void
process_note_abi_tag_sections (bfd *abfd, asection *sect, void *obj)
{
  enum sh_osabi *os_ident_ptr = obj;
  const char *name;
  unsigned int sectsize;

  name = bfd_get_section_name (abfd, sect);
  sectsize = bfd_section_size (abfd, sect);

  if (strcmp (name, ".note.ABI-tag") == 0 && sectsize > 0)
    {
      unsigned int name_length, data_length, note_type;
      char *note;

      /* If the section is larger than this, it's probably not what we are
	 looking for.  */
      if (sectsize > 128)
	sectsize = 128;

      note = alloca (sectsize);

      bfd_get_section_contents (abfd, sect, note,
				(file_ptr) 0, (bfd_size_type) sectsize);

      name_length = bfd_h_get_32 (abfd, note);
      data_length = bfd_h_get_32 (abfd, note + 4);
      note_type   = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 4 && data_length == 16 && note_type == NT_GNU_ABI_TAG
	  && strcmp (note + 12, "GNU") == 0)
	{
	  int os_number = bfd_h_get_32 (abfd, note + 16);

	  /* The case numbers are from abi-tags in glibc.  */
	  switch (os_number)
	    {
	    case GNU_ABI_TAG_LINUX:
	      *os_ident_ptr = SH_OSABI_LINUX;
	      break;

	    case GNU_ABI_TAG_HURD:
	      internal_error
		(__FILE__, __LINE__,
		 "process_note_abi_sections: Hurd objects not supported");
	      break;

	    case GNU_ABI_TAG_SOLARIS:
	      internal_error
		(__FILE__, __LINE__,
		 "process_note_abi_sections: Solaris objects not supported");
	      break;

	    default:
	      internal_error
		(__FILE__, __LINE__,
		 "process_note_abi_sections: unknown OS number %d",
		 os_number);
	    }
	}
    }
  /* NetBSD uses a similar trick.  */
  else if (strcmp (name, ".note.netbsd.ident") == 0 && sectsize > 0)
    {
      unsigned int name_length, desc_length, note_type;
      char *note;

      /* If the section is larger than this, it's probably not what we are
	 looking for.  */
      if (sectsize > 128)
	sectsize = 128;

      note = alloca (sectsize);

      bfd_get_section_contents (abfd, sect, note,
				(file_ptr) 0, (bfd_size_type) sectsize);

      name_length = bfd_h_get_32 (abfd, note);
      desc_length = bfd_h_get_32 (abfd, note + 4);
      note_type   = bfd_h_get_32 (abfd, note + 8);

      if (name_length == 7 && desc_length == 4 && note_type == NT_NETBSD_IDENT
	  && strcmp (note + 12, "NetBSD") == 0)
	/* XXX Should we check the version here?
	   Probably not necessary yet.  */
	*os_ident_ptr = SH_OSABI_NETBSD_ELF;
    }
}

static int
get_elfosabi (bfd *abfd)
{
  int elfosabi;
  enum sh_osabi sh_osabi = SH_OSABI_UNKNOWN;

  elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];

  switch (elfosabi)
    {
    case ELFOSABI_NONE:
      /* When elfosabi is 0 (ELFOSABI_NONE), this is supposed to indicate
	 that we're on a SYSV system.  However, some systems use note sections
	 to record OS/ABI info, but leave e_ident[EI_OSABI] zero.  So we
	 have to check the note sections too.  */
      bfd_map_over_sections (abfd,
			     process_note_abi_tag_sections,
			     &sh_osabi);
      break;

    case ELFOSABI_NETBSD:
      sh_osabi = SH_OSABI_NETBSD_ELF;
      break;

    case ELFOSABI_LINUX:
      sh_osabi = SH_OSABI_LINUX;
      break;
    }

  return (sh_osabi);
}

struct sh_osabi_handler
{
  struct sh_osabi_handler *next;
  enum sh_osabi abi;
  void (*init_osabi)(struct gdbarch_info, struct gdbarch *);
};

struct sh_osabi_handler *sh_osabi_handler_list = NULL;

void
sh_gdbarch_register_os_abi (enum sh_osabi abi,
                            void (*init_osabi)(struct gdbarch_info,
					       struct gdbarch *))
{
  struct sh_osabi_handler **handler_p;

  for (handler_p = &sh_osabi_handler_list; *handler_p != NULL;
       handler_p = &(*handler_p)->next)
    {
      if ((*handler_p)->abi == abi)
	{
	  internal_error
	    (__FILE__, __LINE__,
	     "sh_gdbarch_register_os_abi: A handler for this ABI variant "
	     "(%d) has already been registered", (int) abi);
	  /* If user wants to continue, override previous definition.  */
	  (*handler_p)->init_osabi = init_osabi;
	  return;
	}
    }

  (*handler_p)
    = (struct sh_osabi_handler *) xmalloc (sizeof (struct sh_osabi_handler));
  (*handler_p)->next = NULL;
  (*handler_p)->abi = abi;
  (*handler_p)->init_osabi = init_osabi;
}

d4193 1
a4193 2
  enum sh_osabi sh_osabi = SH_OSABI_UNKNOWN;
  struct sh_osabi_handler *osabi_handler;
d4199 2
a4200 10
      switch (bfd_get_flavour (info.abfd))
	{
	case bfd_target_elf_flavour:
	  sh_osabi = get_elfosabi (info.abfd);
	  break;

	default:
	  /* Just leave it as "unkown".  */
	  break;
	}
d4210 1
a4210 1
      if (tdep && tdep->sh_osabi == sh_osabi)
d4219 1
a4219 9
  tdep->sh_osabi = sh_osabi;
  if (sh_osabi < SH_OSABI_INVALID)
    tdep->osabi_name = sh_osabi_names[sh_osabi];
  else
    {
      internal_error (__FILE__, __LINE__, "Invalid setting of sh_osabi %d",
		      (int) sh_osabi);
      tdep->osabi_name = "<invalid>";
    }
d4571 1
a4571 9
  /* Hook in ABI-specific overrides, if they have been registered.  If
     the ABI is unknown, this is probably an embedded target, so we
     should not warn about this situation.  */
  if (sh_osabi != SH_OSABI_UNKNOWN)
    {
      for (osabi_handler = sh_osabi_handler_list; osabi_handler != NULL;
	   osabi_handler = osabi_handler->next)
	if (osabi_handler->abi == sh_osabi)
	  break;
d4573 3
a4575 16
      if (osabi_handler)
        osabi_handler->init_osabi (info, gdbarch);
      else
        {
	  /* We assume that if GDB_MULTI_ARCH is less than
	     GDB_MULTI_ARCH_TM that an ABI variant can be supported by 
	     overriding definitions in this file.  */
	  if (GDB_MULTI_ARCH > GDB_MULTI_ARCH_PARTIAL) 
	    fprintf_filtered
	      (gdb_stderr,
	       "A handler for the ABI variant \"%s\" is not built into this "
	       "configuration of GDB.  "
	       "Attempting to continue with the default SuperH settings",
	       sh_osabi_names[sh_osabi]);
        }
    }
d4588 2
a4589 6
  if (tdep->osabi_name != NULL)
    fprintf_unfiltered (file, "sh_dump_tdep: OS ABI = %s\n", tdep->osabi_name);
  else
    internal_error (__FILE__, __LINE__,
		    "sh_dump_tdep: illegal setting of tdep->sh_osabi (%d)",
		    (int) tdep->sh_osabi);
@


1.59
log
@* Makefile.in (sh_tdep_h): Define and use.
* config/sh/tm-sh.h (sh_osabi, sh_abi, gdbarch_tdep,
register enum): Move to...
* * sh-tdep.h: ...here.
* sh-tdep.c: Include sh-tdep.h.
* sh3-rom.c: Likewise.
* shnbsd-tdep.c: Likewise.
@
text
@d911 2
a912 23
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
    return print_insn_sh (memaddr, info);
  else
    return print_insn_shl (memaddr, info);
}

/* Disassemble an instruction.  */
static int
gdb_print_insn_sh64 (bfd_vma memaddr, disassemble_info *info)
{
  if (pc_is_isa32 (memaddr))
    {
      /* Round down the instruction address to the appropriate boundary
	 before disassembling it. */
      return print_insn_sh64x_media (UNMAKE_ISA32_ADDR (memaddr), info);
    }
  else
    {
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
	return print_insn_sh (memaddr, info);
      else
	return print_insn_shl (memaddr, info);
    }
a4665 1
      set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh64);
@


1.58
log
@2002-05-10  Elena Zannoni  <ezannoni@@redhat.com>

        * sh-tdep.c: Clean up code erroneously reintroduced by previous
	big patch.
@
text
@d44 2
@


1.58.2.1
log
@merge from trunk
@
text
@a43 2
#include "sh-tdep.h"

d909 23
a931 2
  info->endian = TARGET_BYTE_ORDER;
  return print_insn_sh (memaddr, info);
d4201 169
d4381 2
a4382 1
  enum gdb_osabi osabi = GDB_OSABI_UNKNOWN;
d4388 10
a4397 2
      osabi = gdbarch_lookup_osabi (info.abfd);
      /* If we get "unknown" back, just leave it that way.  */
d4407 1
a4407 1
      if (tdep && tdep->osabi == osabi)
d4416 9
a4424 1
  tdep->osabi = osabi;
d4478 1
a4478 1
  set_gdbarch_deprecated_extract_return_value (gdbarch, sh_extract_return_value);
d4482 1
a4482 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
d4555 1
a4555 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d4595 1
a4595 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d4685 1
d4705 1
a4705 1
      set_gdbarch_deprecated_extract_return_value (gdbarch, sh64_extract_return_value);
d4708 1
a4708 1
      set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
d4777 9
a4785 1
  /* Hook in ABI-specific overrides, if they have been registered.
d4787 16
a4802 3
     FIXME: if the ABI is unknown, this is probably an embedded target,
     so we should not warn about this situation.  */
  gdbarch_init_osabi (info, gdbarch, osabi);
d4815 6
a4820 2
  fprintf_unfiltered (file, "sh_dump_tdep: OS ABI = %s\n",
                      gdbarch_osabi_name (tdep->osabi));
@


1.58.2.2
log
@Merge with trunk.
@
text
@d71 1
a71 1
static const char *
d93 1
a93 1
static const char *
d115 1
a115 1
static const char *
d137 1
a137 1
static const char *
d159 1
a159 1
static const char *
d181 1
a181 1
static const char *
d204 1
a204 1
static const char *
d239 1
a239 1
static const char *
d3388 3
a3390 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3403 1
a3403 1
	regcache_read (current_regcache, base_regnum + portion, 
d3413 1
a3413 1
    regcache_read (current_regcache, reg_nr, buffer);
d3437 3
a3439 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3456 2
a3457 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3469 2
a3470 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3480 1
a3480 1
      regcache_read (current_regcache, base_regnum, temp_buffer);
d3494 1
a3494 1
      regcache_read (current_regcache, base_regnum, buffer);
d3505 3
a3507 3
	regcache_read (current_regcache, base_regnum + portion, 
		       (temp_buffer
			+ REGISTER_RAW_SIZE (base_regnum) * portion));
d3523 2
a3524 2
	regcache_read (current_regcache, base_regnum + portion, 
		       buffer + REGISTER_RAW_SIZE (base_regnum) * portion);
d3555 1
a3555 1
      regcache_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3559 1
a3559 1
      regcache_read (current_regcache, sr_base_regnum, temp_buffer);
d3577 1
a3577 1
      regcache_read (current_regcache, base_regnum, buffer);
d3587 1
a3587 1
    regcache_read (current_regcache, reg_nr, buffer);
d3611 2
a3612 3
	regcache_write (current_regcache, base_regnum + portion, 
			(temp_buffer
			 + REGISTER_RAW_SIZE (base_regnum) * portion));
d3621 1
a3621 1
	regcache_write (current_regcache, base_regnum + portion,
d3631 1
a3631 1
    regcache_write (current_regcache, reg_nr, buffer);
d3656 2
a3657 3
	regcache_write (current_regcache, base_regnum + portion, 
			(temp_buffer
			 + REGISTER_RAW_SIZE (base_regnum) * portion));
d3667 1
a3667 1
	regcache_write (current_regcache, base_regnum + portion,
d3678 1
a3678 1
	regcache_write (current_regcache, base_regnum + portion,
d3696 1
a3696 1
      regcache_read (current_regcache, base_regnum, temp_buffer);
d3699 1
a3699 1
      regcache_write (current_regcache, base_regnum, temp_buffer);
d3708 1
a3708 1
      regcache_write (current_regcache, base_regnum, buffer);
d3721 2
a3722 3
	  regcache_write (current_regcache, base_regnum + portion,
			  (temp_buffer
			   + REGISTER_RAW_SIZE (base_regnum) * portion));
d3733 1
a3733 1
	  regcache_write (current_regcache, base_regnum + portion,
d3776 1
a3776 1
      regcache_read (current_regcache, fpscr_base_regnum, temp_buffer);
d3781 1
a3781 1
      regcache_write (current_regcache, fpscr_base_regnum, temp_buffer);
d3783 1
a3783 1
      regcache_read (current_regcache, sr_base_regnum, temp_buffer);
d3788 1
a3788 1
      regcache_write (current_regcache, sr_base_regnum, temp_buffer);
d3794 1
a3794 1
      regcache_write (current_regcache, base_regnum, buffer);
d3803 1
a3803 1
    regcache_write (current_regcache, reg_nr, buffer);
@


1.58.2.3
log
@merge with trunk
@
text
@d1049 1
a1049 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1388 1
a1388 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1589 1
a1589 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (fi->pc, fi->frame);
d1817 2
a1818 2
		    (deprecated_generic_find_dummy_frame (frame->pc, frame->frame)
		     + REGISTER_BYTE (regnum)),
@


1.57
log
@2002-05-10  Elena Zannoni  <ezannoni@@redhat.com>

        * sh-tdep.c: Include correct file.
@
text
@a44 1

a46 1
#include "elf-bfd.h"
a51 3
#undef XMALLOC
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))

d1393 1
a1393 1
  int *where = (int *) alloca ((NUM_REGS + NUM_PSEUDO_REGS) * sizeof(int));
d1600 1
a1600 1
  int where[NUM_REGS + NUM_PSEUDO_REGS];
a3306 12

int
sh_sh4_register_convertible (int nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
    return (tdep->DR0_REGNUM <= nr
	    && nr <= tdep->DR_LAST_REGNUM);
  else 
    return 0;
}
@


1.56
log
@2002-05-10  Elena Zannoni  <ezannoni@@redhat.com>

        New support for sh64-elf (sh5) target.

        * configure.tgt: For sh64-elf target, default to sh-elf.

        * config/sh/tm-sh.h (enum sh-abi): Possible ABI's.
        (struct gdbarch_tdep): Add new fields for new registers and ABI
        info.

        * sh-tdep.c: Include elf-bfd.h, elf/sh.h, gdb/sim-sh.h.

        (NUM_PSEUDO_REGS_SH_MEDIA, NUM_PSEUDO_REGS_SH_COMPACT,
        MSYMBOL_IS_SPECIAL, IS_ISA32_ADDR, MAKE_ISA32_ADDR,
        UNMAKE_ISA32_ADDR, IS_PTABSL_R18, IS_STS_R0, IS_STS_PR,
        IS_MOV_TO_R15, IS_MOV_R14, IS_STQ_R18_R14, IS_STQ_R18_R15,
        IS_STL_R18_R15, IS_STQ_R14_R15, IS_STL_R14_R15, IS_ADDIL_SP_MEDIA,
        IS_ADDI_SP_MEDIA, IS_ADDL_SP_FP_MEDIA, IS_ADD_SP_FP_MEDIA,
        IS_MOV_SP_FP_MEDIA, IS_MOV_R0, IS_MOVL_R0, IS_ADD_SP_R0,
        IS_MOV_R14_R0, IS_MEDIA_IND_ARG_MOV, IS_MEDIA_ARG_MOV,
        IS_MEDIA_MOV_TO_R14, IS_COMPACT_IND_ARG_MOV, IS_COMPACT_ARG_MOV,
        IS_COMPACT_MOV_TO_R14, IS_JSR_R0, IS_NOP): New macros.

        (sh_sh64_register_name, sh64_elf_make_msymbol_special,
        pc_is_isa32, sh_sh64_breakpoint_from_pc, look_for_args_moves,
        sh64_skip_prologue_hard_way, sh64_use_struct_convention,
        gdb_print_insn_sh64, translate_insn_rn, sh64_frame_chain,
        sh64_get_saved_pr, fpp_reg_base_num, is_media_pseudo,
        sh64_get_gdb_regnum, sh64_media_reg_base_num,
        sh64_compact_reg_base_num, translate_rn_to_arch_reg_num,
        sign_extend, sh64_nofp_frame_init_saved_regs,
        sh64_init_extra_frame_info, sh64_get_saved_register,
        sh64_extract_struct_value_address, sh64_pop_frame,
        sh64_push_arguments, sh64_extract_return_value,
        sh64_store_return_value, sh64_show_media_regs,
        sh64_show_compact_regs, sh64_show_regs, sh_sh64_register_byte,
        sh_sh64_register_raw_size, sh_sh64_register_virtual_size,
        sh_sh64_register_virtual_type,
        sh_sh64_register_convert_to_virtual,
        sh_sh64_register_convert_to_raw, sh64_pseudo_register_read,
        sh64_register_read, sh64_pseudo_register_write,
        sh64_register_write, do_fv_c_register_info, do_dr_c_register_info,
        do_r_c_register_info, do_fpp_register_info, do_cr_c_register_info,
        sh64_do_pseudo_register, sh_compact_do_registers_info,
        sh64_do_registers_info, sh_gdbarch_init): New functions.
@
text
@d52 1
a52 1
#include "gdb/sim-sh64.h"
@


1.55
log
@2002-05-10  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_breakpoint_from_pc): Add 'const' to return type.
@
text
@d48 9
d242 77
d329 103
d456 117
d685 172
d894 6
d920 19
d956 46
d1027 30
d1204 398
d1605 1
a1605 1
  int *where = (int *) alloca ((NUM_REGS + NUM_PSEUDO_REGS) * sizeof(int));
d1751 134
a1884 13
					       SP_REGNUM);
      fi->extra_info->return_pc = generic_read_register_dummy (fi->pc,
							       fi->frame,
							       PC_REGNUM);
      fi->extra_info->f_offset = -(CALL_DUMMY_LENGTH + 4);
      fi->extra_info->leaf_function = 0;
      return;
    }
  else
    {
      FRAME_INIT_SAVED_REGS (fi);
      fi->extra_info->return_pc = 
	sh_find_callers_reg (fi, gdbarch_tdep (current_gdbarch)->PR_REGNUM);
d1886 10
d1908 7
d1948 41
d2112 187
d2306 2
a2307 1
  write_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM, CALL_DUMMY_ADDRESS ());
d2416 53
d2504 41
d2864 92
d2985 155
d3163 24
d3195 11
d3250 32
d3313 12
d3332 27
a3358 1
      && regnum <= tdep->DR_LAST_REGNUM)
d3362 1
a3362 1
      store_floating (to, TYPE_LENGTH (type), val);
d3365 1
a3365 1
    error ("sh_register_convert_to_virtual called with non DR register number");
d3385 25
d3455 174
d3673 172
d3858 26
d3896 50
d4003 45
d4138 35
d4476 2
d4631 99
@


1.54
log
@* sh-tdep.c (sh_osabi_names): Declare.
(process_note_abi_tag_sections): New function.
(get_elfosabi): Ditto.
(sh_gdbarch_register_os_abi): Ditto.
(sh_dump_tdep): Ditto.
_initialize_sh_tdep): Use gdbarch_register to register
sh_gdbarch_init and sh_dump_tdep.
* config/sh/tm-sh.h (sh_osabi): Declare.
(gdbarch_tdep): Add sh_osabi and osabi_name members.
@
text
@d233 1
a233 1
static unsigned char *
@


1.53
log
@* sh-tdep.c (sh_nofp_frame_init_saved_regs): Fix error in
size computation for alloca.
(sh_fp_frame_init_saved_regs): Likewise.
@
text
@d44 2
d1900 170
d2081 18
d2101 9
a2109 3
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;
d2116 10
d2376 27
d2406 16
d2427 1
a2427 1
  register_gdbarch_init (bfd_arch_sh, sh_gdbarch_init);
@


1.52
log
@* defs.h (read_relative_register_raw_bytes): Delete declaration.
* frame.c (frame_register_read): New function.  Return non-zero on
success.
(read_relative_register_raw_bytes_for_frame): Delete.
(read_relative_register_raw_bytes): Delete.
* frame.h (frame_register_read): Declare.
* d30v-tdep.c: Update Copyright.  Use frame_register_read.
* sh-tdep.c: Ditto.
* infcmd.c (do_registers_info): Ditto.
* hppa-tdep.c: Ditto.
* rs6000-tdep.c: Ditto.
* h8500-tdep.c: Ditto.
* mips-tdep.c: Ditto.
* h8300-tdep.c: Ditto.
* z8k-tdep.c: Ditto.
@
text
@d484 1
a484 1
  int *where = (int *) alloca (NUM_REGS + NUM_PSEUDO_REGS);
d626 1
a626 1
  int *where = (int *) alloca (NUM_REGS + NUM_PSEUDO_REGS);
@


1.51
log
@2002-04-07  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_fp_frame_init_saved_regs,
	sh_nofp_frame_init_saved_regs): Use alloca() for 'where'
	information.
@
text
@d1735 1
a1735 1
  if (read_relative_register_raw_bytes (regnum, raw_buffer))
d1772 1
a1772 1
  if (read_relative_register_raw_bytes (regnum, raw_buffer))
@


1.50
log
@* h8500-tdep.c (h8500_write_fp): Delete function.
* dwarf2cfi.c (cfi_write_fp): Document as not used.
* mips-tdep.c (mips_gdbarch_init): Do not set write_fp.
* ia64-tdep.c (ia64_gdbarch_init): Do not set write_fp.
* m68hc11-tdep.c (m68hc11_gdbarch_init): Do not set write_fp.
* rs6000-tdep.c (rs6000_gdbarch_init): Do not set write_fp.
* s390-tdep.c (s390_gdbarch_init): Do not set write_fp.
(s390_write_fp):
* sh-tdep.c (sh_gdbarch_init): Do not set write_fp.
* x86-64-tdep.c (i386_gdbarch_init): Do not set write_fp.
* d10v-tdep.c (d10v_gdbarch_init): Do not set write_fp.
(d10v_write_fp): Delete function.
* inferior.h (write_fp, generic_target_write_fp): Delete
declarations.
* regcache.c (generic_target_write_fp): Delete function.
(write_fp): Delete function.
* gdbarch.sh (TARGET_WRITE_FP): Delete.
* gdbarch.h, gdbarch.c: Regenerate.
* config/v850/tm-v850.h (TARGET_WRITE_FP): Delete macro.
* config/sparc/tm-sp64.h (TARGET_WRITE_FP): Delete macro.
(sparc64_write_fp): Delete declaration.
* config/h8500/tm-h8500.h (TARGET_WRITE_FP): Delete macro.
(h8500_write_fp): Delete declaration.
@
text
@d484 1
a484 1
  int where[NUM_REGS + NUM_PSEUDO_REGS];
d626 1
a626 1
  int where[NUM_REGS + NUM_PSEUDO_REGS];
@


1.49
log
@* defs.h (XMALLOC): Define.
* gdb-events.sh (XMALLOC): Delete macro.
* gdb-events.c, gdb-events.h: Regenerate.
* gdbarch.sh (XMALLOC): Delete macro.
* gdbarch.c: Regenerate.
* serial.c (XMALLOC): Delete macro.
* ui-file.c (XMALLOC): Ditto.
* ser-unix.h (XMALLOC): Ditto.
* sh-tdep.c (XMALLOC): Ditto.
* ui-out.c (XMALLOC): Ditto.
* utils.c (XMALLOC): Ditto.
* i386-tdep.c (XMALLOC): Ditto.
* gdb-events.c (XMALLOC): Ditto.
* d10v-tdep.c (XMALLOC): Ditto.
* cli-out.c (XMALLOC): Ditto.

* cli-out.c, d10v-tdep.c, gdb-events.c: Update copyright.
* gdb-events.sh, i386-tdep.c, ser-unix.h, serial.c: Ditto.
* ui-file.c, ui-out.c: Ditto.
@
text
@a2121 1
  set_gdbarch_write_fp (gdbarch, generic_target_write_fp);
@


1.48
log
@2002-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_nofp_frame_init_saved_regs): Extend where[] array
	to include space for pseudoregs as well. Update loops accordingly.
	(sh_fp_frame_init_saved_regs): Ditto.
	(sh_init_extra_frame_info, sh_pop_frame): Split long lines.
@
text
@a45 3
#undef XMALLOC
#define XMALLOC(TYPE) ((TYPE*) xmalloc (sizeof (TYPE)))

@


1.47
log
@2002-01-22  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_pseudo_register_read): New function. Renamed and
	modified version of obsolete sh_fetch_pseudo_register.
	(sh_fetch_pseudo_register): Rename to sh_pseudo_register_read.
	(sh4_register_read): New function.
	(sh_pseudo_register_write): New function. Renamed and modified
	version of obsolete sh_store_pseudo_register.
	(sh_store_pseudo_register): Rename to sh_pseudo_register_write.
	(sh4_register_write): New function.
	(sh_gdbarch_init): Remove setting of gdbarch function
	fetch_pseudo_register and store_pseudo_register. Remove setting of
	register_convert_to_raw, register_convert_to_virtual,
	register_convertible.
	(sh_sh4_register_convertible): Delete. No longer needed. All is
	taken care by architecture specific functions
	register_read/register_write.
	(sh_sh4_register_convert_to_virtual): Make static.
	(sh_sh4_register_convert_to_raw): Ditto.
@
text
@d487 1
a487 1
  int where[NUM_REGS];
d514 1
a514 1
  for (rn = 0; rn < NUM_REGS; rn++)
d575 1
a575 1
  for (rn = 0; rn < NUM_REGS; rn++)
d629 1
a629 1
  int where[NUM_REGS];
d657 1
a657 1
  for (rn = 0; rn < NUM_REGS; rn++)
d729 1
a729 1
  for (rn = 0; rn < NUM_REGS; rn++)
d746 2
a747 1
      fi->saved_regs[SP_REGNUM] = read_memory_integer (fi->saved_regs[FP_REGNUM], 4);
d776 2
a777 1
      fi->extra_info->return_pc = generic_read_register_dummy (fi->pc, fi->frame,
d786 2
a787 1
      fi->extra_info->return_pc = sh_find_callers_reg (fi, gdbarch_tdep (current_gdbarch)->PR_REGNUM);
d823 1
a823 1
      for (regnum = 0; regnum < NUM_REGS; regnum++)
d825 2
a826 1
	  write_register (regnum, read_memory_integer (frame->saved_regs[regnum], 4));
@


1.46
log
@2002-01-21  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_fp_frame_init_saved_regs, sh_push_arguments,
	sh_generic_show_regs, sh3_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh_dsp_show_regs,
	sh_sh4_register_byte, sh_sh4_register_raw_size,
	sh_sh3e_register_virtual_type, sh_sh4_register_virtual_type,
	sh_sh4_register_convertible, sh_sh4_register_convert_to_virtual,
	sh_sh4_register_convert_to_raw, sh_fetch_pseudo_register,
	sh_store_pseudo_register, sh_do_pseudo_register): Call
	gdbarch_tdep() just once, assign result to variable and use that,
	instead of calling the function several times.
@
text
@d1558 1
a1558 13
int
sh_sh4_register_convertible (int nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
    return (tdep->DR0_REGNUM <= nr
	    && nr <= tdep->DR_LAST_REGNUM);
  else 
    return 0;
}

void
d1575 1
a1575 1
void
d1577 1
a1577 1
                              char *from, char *to)
d1592 1
a1592 1
sh_fetch_pseudo_register (int reg_nr)
d1595 1
d1598 18
a1615 1
  if (!register_cached (reg_nr))
d1617 6
a1622 21
      if (reg_nr >= tdep->DR0_REGNUM 
	  && reg_nr <= tdep->DR_LAST_REGNUM)
        {
	  base_regnum = dr_reg_base_num (reg_nr);

          /* Read the real regs for which this one is an alias.  */
          for (portion = 0; portion < 2; portion++)
            if (!register_cached (base_regnum + portion))
              target_fetch_registers (base_regnum + portion);
        }
      else if (reg_nr >= tdep->FV0_REGNUM 
	       && reg_nr <= tdep->FV_LAST_REGNUM)
        {
	  base_regnum = fv_reg_base_num (reg_nr);

          /* Read the real regs for which this one is an alias.  */
          for (portion = 0; portion < 4; portion++)
            if (!register_cached (base_regnum + portion))
              target_fetch_registers (base_regnum + portion);
        }
      register_valid [reg_nr] = 1;
d1626 11
d1638 1
a1638 1
sh_store_pseudo_register (int reg_nr)
d1641 1
d1649 4
d1655 2
a1656 4
	{
	  register_valid[base_regnum + portion] = 1;
	  target_store_registers (base_regnum + portion);
	}
d1665 2
a1666 4
	{
	  register_valid[base_regnum + portion] = 1;
	  target_store_registers (base_regnum + portion);
	}
d1670 11
a1963 2
  set_gdbarch_fetch_pseudo_register (gdbarch, sh_fetch_pseudo_register);
  set_gdbarch_store_pseudo_register (gdbarch, sh_store_pseudo_register);
d2094 2
a2095 3
      set_gdbarch_register_convert_to_raw (gdbarch, sh_sh4_register_convert_to_raw);
      set_gdbarch_register_convert_to_virtual (gdbarch, sh_sh4_register_convert_to_virtual);
      set_gdbarch_register_convertible (gdbarch, sh_sh4_register_convertible);
@


1.45
log
@Eliminate IEEE_FLOAT.
@
text
@d638 1
d685 1
a685 1
	  where[gdbarch_tdep (current_gdbarch)->PR_REGNUM] = depth;
d708 1
a708 1
	  if (read_register (gdbarch_tdep (current_gdbarch)->FPSCR_REGNUM) & FPSCR_SZ)
d886 1
d905 1
a905 1
  argreg = gdbarch_tdep (current_gdbarch)->ARG0_REGNUM;
d927 1
a927 1
	  if (argreg > gdbarch_tdep (current_gdbarch)->ARGLAST_REGNUM
d937 1
a937 1
	  if (argreg <= gdbarch_tdep (current_gdbarch)->ARGLAST_REGNUM)
d1109 2
d1113 2
a1114 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM),
d1145 2
d1149 2
a1150 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM),
d1158 2
a1159 2
	           (long) read_register (gdbarch_tdep (current_gdbarch)->SSR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SPC_REGNUM));
d1185 2
d1189 2
a1190 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM),
d1198 2
a1199 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SSR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SPC_REGNUM));
d1201 2
a1202 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->FPUL_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->FPSCR_REGNUM));
d1246 2
d1250 2
a1251 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM),
d1260 2
a1261 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SSR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SPC_REGNUM));
d1264 1
a1264 1
		   (long) read_register (gdbarch_tdep (current_gdbarch)->DSR_REGNUM));
d1286 7
a1292 7
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A0G_REGNUM) & 0xff,
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->M0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->X0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->Y0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->RS_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->MOD_REGNUM));
d1294 6
a1299 6
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A1G_REGNUM) & 0xff,
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->M1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->X1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->Y1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->RE_REGNUM));
d1305 3
a1307 1
  int pr = read_register (gdbarch_tdep (current_gdbarch)->FPSCR_REGNUM) & 0x80000;
d1310 2
a1311 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM),
d1319 2
a1320 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SSR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SPC_REGNUM));
d1322 2
a1323 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->FPUL_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->FPSCR_REGNUM));
d1371 2
d1375 2
a1376 2
		   (long) read_register (gdbarch_tdep (current_gdbarch)->SR_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->PR_REGNUM),
d1385 1
a1385 1
		   (long) read_register (gdbarch_tdep (current_gdbarch)->DSR_REGNUM));
d1407 7
a1413 7
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A0G_REGNUM) & 0xff,
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->M0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->X0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->Y0_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->RS_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->MOD_REGNUM));
d1415 6
a1420 6
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A1G_REGNUM) & 0xff,
		   (long) read_register (gdbarch_tdep (current_gdbarch)->A1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->M1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->X1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->Y1_REGNUM),
		   (long) read_register (gdbarch_tdep (current_gdbarch)->RE_REGNUM));
d1440 4
a1443 2
  if (reg_nr >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM 
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1445 2
a1446 2
  else if  (reg_nr >= gdbarch_tdep (current_gdbarch)->FV0_REGNUM 
	    && reg_nr <= gdbarch_tdep (current_gdbarch)->FV_LAST_REGNUM)
d1463 4
a1466 2
  if (reg_nr >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM 
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1468 2
a1469 2
  else if  (reg_nr >= gdbarch_tdep (current_gdbarch)->FV0_REGNUM 
	    && reg_nr <= gdbarch_tdep (current_gdbarch)->FV_LAST_REGNUM)
d1488 2
d1491 2
a1492 2
       && (reg_nr <= gdbarch_tdep (current_gdbarch)->FP_LAST_REGNUM)) 
      || (reg_nr == gdbarch_tdep (current_gdbarch)->FPUL_REGNUM))
d1510 2
d1513 2
a1514 2
       && (reg_nr <= gdbarch_tdep (current_gdbarch)->FP_LAST_REGNUM)) 
      || (reg_nr == gdbarch_tdep (current_gdbarch)->FPUL_REGNUM))
d1516 2
a1517 2
  else if (reg_nr >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM 
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1519 2
a1520 2
  else if  (reg_nr >= gdbarch_tdep (current_gdbarch)->FV0_REGNUM 
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->FV_LAST_REGNUM)
d1561 2
d1564 2
a1565 2
    return (gdbarch_tdep (current_gdbarch)->DR0_REGNUM <= nr
	    && nr <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM);
d1574 4
a1577 2
  if (regnum >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM 
      && regnum <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1591 4
a1594 2
  if (regnum >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM 
      && regnum <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1607 1
d1611 2
a1612 2
      if (reg_nr >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM 
	  && reg_nr <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1621 2
a1622 2
      else if (reg_nr >= gdbarch_tdep (current_gdbarch)->FV0_REGNUM 
	       && reg_nr <= gdbarch_tdep (current_gdbarch)->FV_LAST_REGNUM)
d1639 1
d1641 2
a1642 2
  if (reg_nr >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1653 2
a1654 2
  else if (reg_nr >= gdbarch_tdep (current_gdbarch)->FV0_REGNUM
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->FV_LAST_REGNUM)
d1695 2
d1700 2
a1701 2
  else if (regnum >= gdbarch_tdep (current_gdbarch)->DR0_REGNUM
	   && regnum < gdbarch_tdep (current_gdbarch)->DR_LAST_REGNUM)
d1703 2
a1704 2
  else if (regnum >= gdbarch_tdep (current_gdbarch)->FV0_REGNUM
	   && regnum <= gdbarch_tdep (current_gdbarch)->FV_LAST_REGNUM)
@


1.44
log
@Update Copyright year.
@
text
@a2125 1
  set_gdbarch_ieee_float (gdbarch, 1);
@


1.43
log
@2002-01-12  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_gdbarch_init): Move setting of long_bit earlier in
	the function.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.42
log
@s/BIG_ENDIAN/BFD_ENDIAN_BIG/
@
text
@d1910 1
a2086 1
  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
@


1.41
log
@LITTLE_ENDIAN -> BFD_ENDIAN_LITTLE
@
text
@d431 1
a431 1
  if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1004 1
a1004 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1012 1
a1012 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1049 1
a1049 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1057 1
a1057 1
      if (TARGET_BYTE_ORDER == BIG_ENDIAN)
d1708 1
a1708 1
      register int idx = TARGET_BYTE_ORDER == BIG_ENDIAN ? j
@


1.40
log
@2001-09-05  Elena Zannoni  <ezannoni@@redhat.com>

        * gdbarch.sh: Move include of dis-asm.h so it is generated earlier
        in gdbarch.h.
        (TARGET_PRINT_INSN): Multiarch.
        * gdbarch.h: Regenerate.
        * gdbarch.c: Regenerate.

        * arch-utils.c (legacy_print_insn): New function.
        * arch-utils.h (legacy_print_insn): Export.

        * cris-tdep.c (cris_delayed_get_disassembler): Use
        TARGET_PRINT_INSN, instead of tm_print_insn.
        * d10v-tdep.c (print_insn): Ditto.
        * d30v-tdep.c (print_insn): Ditto.
        * m32r-tdep.c (dump_insn): Ditto.
        * v850-tdep.c (v850_scan_prologue): Ditto.
        * mcore-tdep.c (mcore_dump_insn): Ditto.
        * sh-tdep.c (sh_gdbarch_init): Set print_insn gdbarch field.
@
text
@d1037 1
a1037 1
      if (TARGET_BYTE_ORDER == LITTLE_ENDIAN)
d1539 1
a1539 1
  if (TARGET_BYTE_ORDER == LITTLE_ENDIAN)
@


1.39
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@a49 1
int (*print_sh_insn) (bfd_vma, disassemble_info*);
d1930 1
a1930 1
  print_sh_insn = gdb_print_insn_sh;
a2126 1
  tm_print_insn = print_sh_insn;
@


1.38
log
@2001-07-26  Elena Zannoni  <ezannoni@@redhat.com>

	* sh-tdep.c (sh_gdbarch_init): Use SH_DEFAULT_NUM_REGS instead of
	NUM_REGS.
	(SH_DEFAULT_NUM_REGS): Define.
@
text
@d42 1
@


1.37
log
@s/value_ptr/struct value */
@
text
@d53 2
d1911 1
a1911 1
  set_gdbarch_num_regs (gdbarch, 59);
d1916 1
a1916 1
  set_gdbarch_register_bytes (gdbarch, NUM_REGS * 4);
@


1.36
log
@2001-07-11  Elena Zannoni  <ezannoni@@redhat.com>

	* config/sh/tm-sh.h (struct gdbarch_tdep): Add
	FLOAT_ARGLAST_REGNUM, RETURN_REGNUM, ARG0_REGNUM, ARGLAST_REGNUM,
	PR_REGNUM fields.

	* sh-tdep.c (sh_skip_prologue_hard_way): Rename from
	skip_prologue_hard_way().
	(skip_prologue_hard_way): Make it a function pointer.
        (sh_print_register): Use function pointer do_pseudo_register,
	instead of sh_do_pseudo_register.
        (sh_do_registers_info): Ditto.
        (sh_gdbarch_init): Initialize do_pseudo_register.
	(IS_MOV_TO_R14): Rename from IS_MOV_R14.
	(skip_prologue_hard_way): Update.
	(sh_gdbarch_init): Move setting of frame_chain,
	get_saved_register, init_extra_frame_info, push_arguments,
	extract_return_value, pop_frame, store_struct_return,
	extract_struct_value_address, use_struct_convention,
	init_extra_frame_info to before target specific settings.
	(sh_gdbarch_init): Initialize new tdep fields
	FLOAT_ARGLAST_REGNUM, RETURN_REGNUM, ARG0_REGNUM, ARGLAST_REGNUM,
	PR_REGNUM.
	(sh_push_arguments): Use new gdbarch_tdep fields
	{ARG0,ARGLAST}_REGNUM.
	(sh_saved_pc_after_call, sh_nofp_frame_init_saved_regs,
	sh_init_extra_frame_info, sh_push_return_address,
	sh_generic_show_regs, sh3_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh_dsp_show_regs): Update to use
	gdbarch_tdep->PR_REGNUM.
	(dr_reg_base_num, fv_reg_base_num): Move to earlier in the file.
@
text
@d977 1
a977 1
		   value_ptr *args, struct type *type, int gcc_p)
@


1.35
log
@2001-05-09  Elena Zannoni  <ezannoni@@redhat.com>

	* sh3-rom.c (_initialize_sh3_rom): Get rid of specific _WINDOWS
 	conditional for help with connections through parallel ports,
 	given that the actual code for downloading through a parallel port
 	is not conditionalized.

	* sh-tdep.c: Remove WIN32_WCE conditional. The wince sh target is
 	unmaintaned, and probably on its way to obsolescence.
@
text
@d50 2
d307 1
a307 1
#define IS_MOV_R14(x) \
d346 1
a346 1
skip_prologue_hard_way (CORE_ADDR start_pc)
d360 1
a360 1
	  || IS_ARG_MOV (w) || IS_MOV_R14 (w))
a385 1

d405 1
a405 1
  return (ADDR_BITS_REMOVE(read_register(PR_REGNUM)));
d418 1
a418 1
   We store structs through a pointer passed in R0 */
a456 1

d540 1
a540 1
	  where[PR_REGNUM] = depth;
d602 22
d682 1
a682 1
	  where[PR_REGNUM] = depth;
d781 1
a781 1
      fi->extra_info->return_pc = sh_find_callers_reg (fi, PR_REGNUM);
d872 1
a872 1
		   int struct_return, CORE_ADDR struct_addr)
d901 1
a901 1
  argreg = ARG0_REGNUM;
d923 4
a926 2
	  if (argreg > ARGLAST_REGNUM || odd_sized_struct)
	    {			/* must go on the stack */
d933 3
a935 2
	  if (argreg <= ARGLAST_REGNUM)
	    {			/* there's room in a register */
d956 1
a956 1
  write_register (PR_REGNUM, CALL_DUMMY_ADDRESS ());
d1070 1
a1070 1
   the result is stored in r0. */
a1099 1

d1108 1
a1108 1
		   (long) read_register (PR_REGNUM),
d1142 1
a1142 1
		   (long) read_register (PR_REGNUM),
d1180 1
a1180 1
		   (long) read_register (PR_REGNUM),
d1239 1
a1239 1
		   (long) read_register (PR_REGNUM),
d1297 1
a1297 1
		   (long) read_register (PR_REGNUM),
d1360 1
a1360 1
		   (long) read_register (PR_REGNUM),
a1412 20
static int
fv_reg_base_num (int fv_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + 
    (fv_regnum - gdbarch_tdep (current_gdbarch)->FV0_REGNUM) * 4;
  return fp_regnum;
}

static int
dr_reg_base_num (int dr_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + 
    (dr_regnum - gdbarch_tdep (current_gdbarch)->DR0_REGNUM) * 2;
  return fp_regnum;
}

a1464 1

d1553 1
a1553 1
      store_floating(to, TYPE_LENGTH(type), val);
d1556 1
a1556 1
    error("sh_register_convert_to_virtual called with non DR register number");
a1598 1

d1635 1
d1648 1
a1673 1

d1750 1
a1750 1
    sh_do_pseudo_register (regnum);
d1799 1
a1799 1
	    sh_do_pseudo_register (regnum);
d1876 1
d1899 4
d1919 3
d1923 5
d1929 2
a1994 1
      set_gdbarch_extract_return_value (gdbarch, sh3e_sh4_extract_return_value);
d1999 1
d2038 1
a2039 1
      set_gdbarch_frame_init_saved_regs (gdbarch, sh_fp_frame_init_saved_regs);
a2101 1
  set_gdbarch_get_saved_register (gdbarch, generic_get_saved_register);
a2105 1
  set_gdbarch_push_arguments (gdbarch, sh_push_arguments);
a2108 1
  set_gdbarch_store_struct_return (gdbarch, sh_store_struct_return);
a2109 4
  set_gdbarch_extract_struct_value_address (gdbarch, sh_extract_struct_value_address);
  set_gdbarch_use_struct_convention (gdbarch, sh_use_struct_convention);
  set_gdbarch_init_extra_frame_info (gdbarch, sh_init_extra_frame_info);
  set_gdbarch_pop_frame (gdbarch, sh_pop_frame);
a2116 1
  set_gdbarch_frame_chain (gdbarch, sh_frame_chain);
@


1.34
log
@2001-04-30  Elena Zannoni  <ezannoni@@redhat.com>

      * sh-tdep.c: Get rid of the function prototypes.
      (sh_sh4_build_float_register_type): Move earlier in file.
      (fv_reg_base_num): Ditto.
      (dr_reg_base_num): Ditto.
@
text
@a61 8
#if 0
#ifdef _WIN32_WCE
char **sh_register_names = sh3_reg_names;
#else
char **sh_register_names = sh_generic_reg_names;
#endif
#endif

@


1.33
log
@Gag -Wuninitialized warnings.
Add -Wuninitialized to default warning list.
@
text
@a47 67

/* Frame interpretation related functions. */
static gdbarch_breakpoint_from_pc_ftype sh_breakpoint_from_pc;
static gdbarch_frame_chain_ftype sh_frame_chain;
static gdbarch_frame_saved_pc_ftype sh_frame_saved_pc;
static gdbarch_skip_prologue_ftype sh_skip_prologue;

static gdbarch_frame_init_saved_regs_ftype sh_nofp_frame_init_saved_regs;
static gdbarch_frame_init_saved_regs_ftype sh_fp_frame_init_saved_regs;
static gdbarch_init_extra_frame_info_ftype sh_init_extra_frame_info;
static gdbarch_pop_frame_ftype sh_pop_frame;
static gdbarch_saved_pc_after_call_ftype sh_saved_pc_after_call;

/* Function call related functions. */
static gdbarch_extract_return_value_ftype sh_extract_return_value;
static gdbarch_extract_return_value_ftype sh3e_sh4_extract_return_value;
static gdbarch_extract_struct_value_address_ftype sh_extract_struct_value_address;
static gdbarch_use_struct_convention_ftype sh_use_struct_convention;
static gdbarch_store_struct_return_ftype sh_store_struct_return;
static gdbarch_push_arguments_ftype sh_push_arguments;
static gdbarch_push_return_address_ftype sh_push_return_address;
static gdbarch_coerce_float_to_double_ftype sh_coerce_float_to_double;
static gdbarch_store_return_value_ftype	sh_default_store_return_value;
static gdbarch_store_return_value_ftype	sh3e_sh4_store_return_value;

static gdbarch_register_name_ftype sh_generic_register_name;
static gdbarch_register_name_ftype sh_sh_register_name;
static gdbarch_register_name_ftype sh_sh3_register_name;
static gdbarch_register_name_ftype sh_sh3e_register_name;
static gdbarch_register_name_ftype sh_sh_dsp_register_name;
static gdbarch_register_name_ftype sh_sh3_dsp_register_name;

/* Registers display related functions */
static gdbarch_register_raw_size_ftype sh_default_register_raw_size;
static gdbarch_register_raw_size_ftype sh_sh4_register_raw_size;

static gdbarch_register_virtual_size_ftype sh_register_virtual_size;

static gdbarch_register_byte_ftype sh_default_register_byte;
static gdbarch_register_byte_ftype sh_sh4_register_byte;

static gdbarch_register_virtual_type_ftype sh_sh3e_register_virtual_type;
static gdbarch_register_virtual_type_ftype sh_sh4_register_virtual_type;
static gdbarch_register_virtual_type_ftype sh_default_register_virtual_type;

static void sh_generic_show_regs (void);
static void sh3_show_regs (void);
static void sh3e_show_regs (void);
static void sh3_dsp_show_regs (void);
static void sh_dsp_show_regs (void);
static void sh4_show_regs (void);
static void sh_show_regs_command (char *, int);

static struct type *sh_sh4_build_float_register_type (int high);

static gdbarch_fetch_pseudo_register_ftype sh_fetch_pseudo_register;
static gdbarch_store_pseudo_register_ftype sh_store_pseudo_register;
static int fv_reg_base_num (int);
static int dr_reg_base_num (int);
static gdbarch_do_registers_info_ftype sh_do_registers_info;
static void do_fv_register_info (int fv_regnum);
static void do_dr_register_info (int dr_regnum);
static void sh_do_pseudo_register (int regnum);
static void sh_do_fp_register (int regnum);
static void sh_do_register (int regnum);
static void sh_print_register (int regnum);

d1397 20
d1482 9
a1507 9
sh_sh4_build_float_register_type (int high)
{
  struct type *temp;

  temp = create_range_type (NULL, builtin_type_int, 0, high);
  return create_array_type (NULL, builtin_type_float, temp);
}

static struct type *
a1638 20
}

static int
fv_reg_base_num (int fv_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + 
    (fv_regnum - gdbarch_tdep (current_gdbarch)->FV0_REGNUM) * 4;
  return fp_regnum;
}

static int
dr_reg_base_num (int dr_regnum)
{
  int fp_regnum;

  fp_regnum = FP0_REGNUM + 
    (dr_regnum - gdbarch_tdep (current_gdbarch)->DR0_REGNUM) * 2;
  return fp_regnum;
@


1.32
log
@Update/correct copyright notices.
@
text
@d1769 4
a1772 1
  printf_filtered (inv ? "<invalid float>" : "%-10.9g", flt);
@


1.31
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2001
@


1.30
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d41 1
@


1.29
log
@2001-02-05  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

      * sh-tdep.c: Update copyright.
      (sh_extract_return_value): Rewrite.
      (sh3e_sh4_extract_return_value): New function.
      (sh_gdbarch_init): Initialize gdbarch_extract-return_value to new
      version of the function for sh3e and sh4 CPUs.
@
text
@d1734 2
a1735 1
    internal_error ("Invalid pseudo register number %d\n", regnum);
d1806 2
a1807 1
    internal_error ("Invalid register number %d\n", regnum);
@


1.28
log
@2001-01-02  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * sh-tdep.c (sh_extract_return_value):  Allow for small return type.
        (sh_sh4_extract_return_value): Call sh_extract_return_value for
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 2000 Free Software
   Foundation, Inc.
d62 1
d1046 29
d1076 26
a1101 2
  if (len <= 4)
    memcpy (valbuf, ((char *) regbuf) + 4 - len, len);
d1103 7
a1109 1
    memcpy (valbuf, ((char *) regbuf) + 8 - len, len);
d1980 1
d2046 1
d2089 1
a2157 1
  set_gdbarch_extract_return_value (gdbarch, sh_extract_return_value);
@


1.27
log
@Remove prototypes for obsolete static functions.
@
text
@d1063 14
a1076 2
  write_register_bytes (REGISTER_BYTE (0), 
			valbuf, TYPE_LENGTH (type));
d1086 1
a1086 2
    write_register_bytes (REGISTER_BYTE (0), 
			  valbuf, TYPE_LENGTH (type));
@


1.26
log
@2000-12-20  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

        * arch-utils.c (default_frame_address): New function.  Default
        implementation of frame_args_address and frame_locals_address.
        * arch-utils.h (default_frame_address): Export.
        * d10v-tdep.c (d10v_gdbarch_init): Use default_frame_address.
        (d10v_frame_args_address, d10v_frame_locals_address): Delete.
        * sh-tdep.c (sh_gdbarch_init): Use default_frame_address.
        (sh_frame_args_address, sh_frame_locals_address): Delete.
        * sparc-tdep.c (sparc_gdbarch_init): Use default_frame_address.
        (sparc_frame_address): Delete.
@
text
@a58 2
static gdbarch_frame_args_address_ftype sh_frame_args_address;
static gdbarch_frame_locals_address_ftype sh_frame_locals_address;
@


1.25
log
@2000-12-19  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

      * sh-tdep.c (sh_print_register): Don't leave regnum 0 out of the
       non-pseudo-regs group.
@
text
@a852 12
static CORE_ADDR
sh_frame_args_address (struct frame_info *fi)
{
  return (fi)->frame;
}

static CORE_ADDR
sh_frame_locals_address (struct frame_info *fi)
{
  return (fi)->frame;
}

d2107 2
a2108 2
  set_gdbarch_frame_args_address (gdbarch, sh_frame_args_address);
  set_gdbarch_frame_locals_address (gdbarch, sh_frame_locals_address);
@


1.24
log
@2000-12-19  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* sh-tdep.c (sh_gdbarch_init): Move setting of breakpoint_from_pc
	to before switch statement.
@
text
@d1750 1
a1750 1
  else if (regnum > 0 && regnum < NUM_REGS)
@


1.23
log
@2000-12-17  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * sh-tdep.c (sh_gdbarch_init): Initialize do_registers_info.

        * config/sh/tm-sh.h (DO_REGISTERS_INFO): Remove macro. Use
        multiarch version instead.
@
text
@d1922 1
a2112 1
  set_gdbarch_breakpoint_from_pc (gdbarch, sh_breakpoint_from_pc);
@


1.22
log
@2000-12-15  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh3e_show_regs,
 	sh3_dsp_show_regs, sh4_show_regs, sh_dsp_show_regs): SR_REGNUM is
 	now part of gdbarch_tdep structure.
	(sh_gdbarch_init): Initialize SR_REGNUM.

	* config/sh/tm-sh.h (struct gdbarch_tdep): Add field SR_REGNUM.
@
text
@d107 1
d1921 1
@


1.21
log
@2000-12-15  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* sh-tdep.c (sh_do_pseudo_register): Indent properly. Call
 	do_dr_register_info() only for DR registers.
	(sh_sh4_register_name): Add comments with numbers.
	(_initialize_sh_tdep): Move assignment to disassemble printing
 	function from here...
	(sh_gdbarch_init):...to here. Move some more general settings to
 	before the architecture is recognized.
@
text
@d1099 1
a1099 1
		   (long) read_register (SR_REGNUM),
d1133 1
a1133 1
		   (long) read_register (SR_REGNUM),
d1171 1
a1171 1
		   (long) read_register (SR_REGNUM),
d1230 1
a1230 1
		   (long) read_register (SR_REGNUM),
d1288 1
a1288 1
		   (long) read_register (SR_REGNUM),
d1351 1
a1351 1
		   (long) read_register (SR_REGNUM),
d1884 1
@


1.20
log
@2000-12-11  Michael Snyder  <msnyder@@cleaver.cygnus.com>

	* sh-tdep.c (sh_extract_struct_value_address): Protoize.

2000-12-11  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

	* blockframe.c (get_prev_frame): Add missing paren omitted in
	last check-in.
@
text
@d274 1
d277 1
d279 1
d281 1
d284 1
d286 1
d288 1
d290 1
d292 1
d294 2
d1677 2
a1678 2
  else if (regnum >= NUM_REGS && 
	   regnum < gdbarch_tdep (current_gdbarch)->FV0_REGNUM)
d1680 2
a1681 2
  else if (regnum >= gdbarch_tdep (current_gdbarch)->FV0_REGNUM &&
	   regnum <= gdbarch_tdep (current_gdbarch)->FV_LAST_REGNUM)
d1905 1
d1910 9
a2065 4
  set_gdbarch_num_regs (gdbarch, 59);
  set_gdbarch_sp_regnum (gdbarch, 15);
  set_gdbarch_fp_regnum (gdbarch, 14);
  set_gdbarch_pc_regnum (gdbarch, 16);
a2066 2
  set_gdbarch_register_size (gdbarch, 4);
  set_gdbarch_register_bytes (gdbarch, NUM_REGS * 4);
a2068 1
  set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
d2075 1
a2075 1
  set_gdbarch_long_double_bit (gdbarch, 16 * TARGET_CHAR_BIT);
a2110 2
  set_gdbarch_fetch_pseudo_register (gdbarch, sh_fetch_pseudo_register);
  set_gdbarch_store_pseudo_register (gdbarch, sh_store_pseudo_register);
d2122 1
a2132 1
  tm_print_insn = print_sh_insn;
@


1.19
log
@2000-12-11  Michael Snyder  <msnyder@@cleaver.cygnus.com>

        * sh-tdep.c (sh_extract_struct_value_address): For consistancy,
        change decl from "CORE_ADDR static" to "static CORE_ADDR".
@
text
@d830 1
a830 2
sh_extract_struct_value_address (regbuf)
     char *regbuf;
@


1.18
log
@2000-12-07  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* config/sh/tm-sh.h (struct gdbarch_tdep): Rename fields
        {FP15,DR14,FV12}_REGNUM to {FP,DR,FV}_LAST_REGNUM.
	* sh-tdep.c (sh_sh3e_register_virtual_type,
 	sh_sh4_register_virtual_type, sh_do_registers_info,
 	sh_gdbarch_init, sh_sh4_register_byte, sh_sh4_register_raw_size,
 	sh_sh4_register_convertible, sh_sh4_register_convert_to_virtual,
 	sh_sh4_register_convert_to_raw, sh_fetch_pseudo_register,
 	sh_store_pseudo_register, sh_do_pseudo_register): Ditto.

	* sh-tdep.c (sh_gdbarch_init): Use a function pointer to set the
        disassembly print function.
	(_initialize_sh_tdep): Initialize tm_print_insn using the function
 	pointer.
@
text
@d829 2
a830 2
CORE_ADDR
static sh_extract_struct_value_address (regbuf)
@


1.17
log
@2000-12-05  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * config/sh/tm-sh.h (struct gdbarch_tdep): Get rid of
        DR{2,4,6,8,10,12}_REGNUM, FV{4,8}_REGNUM, they are not used
        anywhere.
        * sh-tdep.c (sh_gdbarch_init): Don't initialize
        DR{2,4,6,8,10,12}_REGNUM, FV{4,8}_REGNUM.
@
text
@d115 1
a115 1

d1407 1
a1407 1
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM)
d1410 1
a1410 1
	    && reg_nr <= gdbarch_tdep (current_gdbarch)->FV12_REGNUM)
d1428 1
a1428 1
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM)
d1431 1
a1431 1
	    && reg_nr <= gdbarch_tdep (current_gdbarch)->FV12_REGNUM)
d1452 1
a1452 1
       && (reg_nr <= gdbarch_tdep (current_gdbarch)->FP15_REGNUM)) 
d1463 1
a1463 1
       && (reg_nr <= gdbarch_tdep (current_gdbarch)->FP15_REGNUM)) 
d1467 1
a1467 1
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM)
d1470 1
a1470 1
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->FV12_REGNUM)
d1522 1
a1522 1
	    && nr <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM);
d1532 1
a1532 1
      && regnum <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM)
d1547 1
a1547 1
      && regnum <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM)
d1564 1
a1564 1
	  && reg_nr <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM)
d1574 1
a1574 1
	       && reg_nr <= gdbarch_tdep (current_gdbarch)->FV12_REGNUM)
d1594 1
a1594 1
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR14_REGNUM)
d1606 1
a1606 1
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->FV12_REGNUM)
d1671 1
a1671 1
	   regnum <= gdbarch_tdep (current_gdbarch)->FV12_REGNUM)
d1785 1
a1785 1
		regnum += (gdbarch_tdep (current_gdbarch)->FP15_REGNUM - FP0_REGNUM);	/* skip FP regs */
d1875 1
a1875 1
  tdep->FP15_REGNUM = -1;
d1892 1
a1892 1
  tdep->DR14_REGNUM = -1;
d1894 1
a1894 1
  tdep->FV12_REGNUM = -1;
d1899 1
d1971 1
a1971 1
      tdep->FP15_REGNUM = 40;
d2019 1
a2019 1
      tdep->FP15_REGNUM = 40;
d2023 1
a2023 1
      tdep->DR14_REGNUM = 66;
d2025 1
a2025 1
      tdep->FV12_REGNUM = 70;
d2121 1
a2121 1
  tm_print_insn = gdb_print_insn_sh;
@


1.16
log
@2000-10-30  Michael Snyder  <msnyder@@cleaver.cygnus.com>

	* config/sh/tm-linux.h: New file.  Include generic tm-linux.h,
	plus tm-sh.h, then define SVR4_FETCH_LINK_MAP_OFFSETS to use
	the sh target function instead of the default link map offsets.
	* config/sh/sh.mt: Add solib.o and solib-svr4.o to TDEPFILES.
	Use sh/tm-linux.h instead of sh/tm-sh.h.
	* sh-tdep.c (sh_linux_svr4_fetch_link_map_offsets):
	New function.  Construct target-specific link map offsets.
	* i386-linux-tdep.c (i386_linux_svr4_fetch_link_map_offsets:
	New function.  Construct target-specific link map offsets.
	* config/i386/tm-linux.h: Use above function instead of default.

2000-10-30  Michael Snyder  <msnyder@@cleaver.cygnus.com>

	* config/i386/tm-linux.h: Remove definition of SVR4_SHARED_LIBS,
	and inclusion of solib.h.  Move up into ../tm-linux.h.
	config/tm-linux.h: Define SVR4_SHARED_LIBS, include solib.h.
@
text
@a1891 6
  tdep->DR2_REGNUM = -1;
  tdep->DR4_REGNUM = -1;
  tdep->DR6_REGNUM = -1;
  tdep->DR8_REGNUM = -1;
  tdep->DR10_REGNUM = -1;
  tdep->DR12_REGNUM = -1;
a1893 2
  tdep->FV4_REGNUM = -1;
  tdep->FV8_REGNUM = -1;
a2021 6
      tdep->DR2_REGNUM = 60;
      tdep->DR4_REGNUM = 61;
      tdep->DR6_REGNUM = 62;
      tdep->DR8_REGNUM = 63;
      tdep->DR10_REGNUM = 64;
      tdep->DR12_REGNUM = 65;
a2023 2
      tdep->FV4_REGNUM = 68;
      tdep->FV8_REGNUM = 69;
@


1.15
log
@* gdbarch.sh, hp-psymtab-read.c, hpread.c, m3-nat.c, mcore-tdep.c,
mips-tdep.c, monitor.c, regcache.c, remote-es.c, ser-unix.c,
somread.c, tracepoint.c: Fix spelling errors in comments.
* gdbarch.c: Regenerate.

* gnu-nat.c (S_exception_raise_request): Fix typos and spelling
errors in strings.
* m3-nat.c (intercept_exec_calls, mach_thread_parse_id): Likewise.
* mcore-tdep.c (mcore_analyze_prologue): Likewise.
* mips-tdep.c (mips16_next_pc, _initialize_mips_tdep): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-rdp.c (handle_swi): Likewise.
* remote-vx.c (vx_load_command): Likewise.
* sh-tdep.c (sh_do_pseudo_register): Likewise.
* sol-thread.c (td_err_string): Likewise.
* symtab.c (decode_line_2): Likewise.
-------------------------------------------------------------------
@
text
@d42 2
d1802 44
@


1.14
log
@2000-07-31  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* sh-tdep.c (sh_push_arguments): Make header match prototype.

	* remote-e7000.c (e7000_start_remote): Use void *, not char * as
 	parameter to avoid compiler warning.
	(fetch_regs_from_dump): Call get_hex() with the correct number of
 	parameters.
@
text
@d1664 1
a1664 1
    internal_error ("Invalid pasudo register number %d\n", regnum);
@


1.13
log
@Protoization.
@
text
@d923 2
a924 2
sh_push_arguments (int nargs, value_ptr *args, CORE_ADDR sp,
		   unsigned char struct_return, CORE_ADDR struct_addr)
@


1.12
log
@2000-07-28  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* sh-tdep.c (sh_gdbarch_init): For sh4 initialize
 	register_convert_to_raw, register_convert_to_virtual,
 	register_convertible.
	(sh_sh4_register_convertible): New function.
	(sh_sh4_register_convert_to_virtual): New function.
	(sh_sh4_register_convert_to_raw): New function.
	Include floatformat.h.
@
text
@d292 1
a292 3
sh_breakpoint_from_pc (pcptr, lenptr)
     CORE_ADDR *pcptr;
     int *lenptr;
d376 1
a376 2
after_prologue (pc)
     CORE_ADDR pc;
d405 1
a405 2
skip_prologue_hard_way (start_pc)
     CORE_ADDR start_pc;
d438 1
a438 2
sh_skip_prologue (pc)
     CORE_ADDR pc;
d463 1
a463 2
sh_saved_pc_after_call (frame)
     struct frame_info *frame;
d470 1
a470 3
sh_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
d480 1
a480 3
sh_store_struct_return (addr, sp)
     CORE_ADDR addr;
     CORE_ADDR sp;
d487 1
a487 3
gdb_print_insn_sh (memaddr, info)
     bfd_vma memaddr;
     disassemble_info *info;
d502 1
a502 2
sh_frame_chain (frame)
     struct frame_info *frame;
d519 1
a519 3
sh_find_callers_reg (fi, regnum)
     struct frame_info *fi;
     int regnum;
d544 1
a544 2
sh_nofp_frame_init_saved_regs (fi)
     struct frame_info *fi;
d664 1
a664 2
sh_fp_frame_init_saved_regs (fi)
     struct frame_info *fi;
d796 1
a796 3
sh_init_extra_frame_info (fromleaf, fi)
     int fromleaf;
     struct frame_info *fi;
d835 1
a835 2
sh_frame_saved_pc (frame)
     struct frame_info *frame;
d841 1
a841 2
sh_frame_args_address (fi)
     struct frame_info *fi;
d847 1
a847 2
sh_frame_locals_address (fi)
     struct frame_info *fi;
d855 1
a855 1
sh_pop_frame ()
d923 2
a924 6
sh_push_arguments (nargs, args, sp, struct_return, struct_addr)
     int nargs;
     value_ptr *args;
     CORE_ADDR sp;
     unsigned char struct_return;
     CORE_ADDR struct_addr;
d1003 1
a1003 3
sh_push_return_address (pc, sp)
     CORE_ADDR pc;
     CORE_ADDR sp;
d1025 2
a1026 8
sh_fix_call_dummy (dummy, pc, fun, nargs, args, type, gcc_p)
     char *dummy;
     CORE_ADDR pc;
     CORE_ADDR fun;
     int nargs;
     value_ptr *args;
     struct type *type;
     int gcc_p;
d1043 1
a1043 4
sh_extract_return_value (type, regbuf, valbuf)
     struct type *type;
     char *regbuf;
     char *valbuf;
d1083 1
a1083 1
sh_generic_show_regs ()
d1117 1
a1117 1
sh3_show_regs ()
d1155 1
a1155 1
sh3e_show_regs ()
d1214 1
a1214 1
sh3_dsp_show_regs ()
d1271 1
a1271 1
sh4_show_regs ()
d1335 1
a1335 1
sh_dsp_show_regs ()
d1396 1
a1396 2
sh_default_register_byte (reg_nr)
     int reg_nr;
d1402 1
a1402 2
sh_sh4_register_byte (reg_nr)
     int reg_nr;
d1417 1
a1417 2
sh_default_register_raw_size (reg_nr)
     int reg_nr;
d1423 1
a1423 2
sh_sh4_register_raw_size (reg_nr)
     int reg_nr;
d1438 1
a1438 2
sh_register_virtual_size (reg_nr)
     int reg_nr;
d1447 1
a1447 2
sh_sh3e_register_virtual_type (reg_nr)
     int reg_nr;
d1458 1
a1458 2
sh_sh4_register_virtual_type (reg_nr)
     int reg_nr;
d1484 1
a1484 2
sh_default_register_virtual_type (reg_nr)
     int reg_nr;
d1804 1
a1804 3
sh_gdbarch_init (info, arches)
     struct gdbarch_info info;
     struct gdbarch_list *arches;
d2085 1
a2085 1
_initialize_sh_tdep ()
@


1.11
log
@2000-07-26  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* sh-tdep.c (sh_sh4_register_name, sh_sh4_register_byte,
 	sh_sh4_register_raw_size, sh_sh4_register_virtual_type,
 	sh_fetch_pseudo_register, sh_store_pseudo_register,
 	sh_do_pseudo_register, sh_gdbarch_init): Fix names for pseudoregs,
 	they should be numbered as drx fvy where x and y are multiples of
 	2 and 4 respectively.

	* config/sh/tm-sh.h: Fix names of pseudo regs.
@
text
@d40 1
d1534 65
d2022 3
@


1.10
log
@2000-07-24  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* config/sh/tm-sh.h (struct gdbarch_tdep): Add sh4 specific
 	pseudo registers.
	(DO_REGISTERS_INFO): Define.

	* sh-tdep.c (sh_sh4_register_name): New function.
	(sh_generic_show_regs, sh3_show_regs, sh3e_show_regs,
 	sh3_dsp_show_regs, sh4_show_regs, sh_dsp_show_regs): Update
 	signature.
	(sh_show_regs_command): New function. Actual function called by
 	the 'regs' command.
	(sh_register_byte): Rename to...
	(sh_default_register_byte): ...New function.
	(sh_sh4_register_byte): New function.
	(sh_register_raw_size): Rename to...
	(sh_default_register_raw_size): ...New function.
	(sh_sh4_register_raw_size): New function.
	(sh_sh4_register_virtual_type): New function.
	(sh_sh4_build_float_register_type): New function.
	(sh_fetch_pseudo_register, sh_store_pseudo_register): New
 	functions.
	(fv_reg_base_num, dr_reg_base_num): New functions.
	(do_fv_register_info, do_dr_register_info, sh_do_pseudo_register,
 	sh_do_fp_register, sh_do_register, sh_print_register,
 	sh_do_registers_info): New functions.
	(sh_gdbarch_init): Initialize sh4 pseudo registers to -1. Update
 	architecture specific parts.
	(_initialize_sh_tdep): Use sh_show_regs_command for 'regs' command.
@
text
@d280 2
a281 2
    "dr0",  "dr1",  "dr2",  "dr3",  "dr4",  "dr5",  "dr6",  "dr7",
    "fv0",  "fv1",  "fv2",  "fv3",
d1443 1
a1443 1
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR7_REGNUM)
d1446 1
a1446 1
	    && reg_nr <= gdbarch_tdep (current_gdbarch)->FV3_REGNUM)
d1466 1
a1466 1
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR7_REGNUM)
d1469 1
a1469 1
	    && reg_nr <= gdbarch_tdep (current_gdbarch)->FV3_REGNUM)
d1508 1
a1508 1
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->DR7_REGNUM)
d1511 1
a1511 1
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->FV3_REGNUM)
d1541 1
a1541 1
	  && reg_nr <= gdbarch_tdep (current_gdbarch)->DR7_REGNUM)
d1551 1
a1551 1
	       && reg_nr <= gdbarch_tdep (current_gdbarch)->FV3_REGNUM)
d1571 1
a1571 1
      && reg_nr <= gdbarch_tdep (current_gdbarch)->DR7_REGNUM)
d1583 1
a1583 1
	   && reg_nr <= gdbarch_tdep (current_gdbarch)->FV3_REGNUM)
d1648 1
a1648 1
	   regnum <= gdbarch_tdep (current_gdbarch)->FV3_REGNUM)
a1826 1
  tdep->DR1_REGNUM = -1;
a1827 1
  tdep->DR3_REGNUM = -1;
a1828 1
  tdep->DR5_REGNUM = -1;
d1830 4
a1833 1
  tdep->DR7_REGNUM = -1;
d1835 3
a1837 3
  tdep->FV1_REGNUM = -1;
  tdep->FV2_REGNUM = -1;
  tdep->FV3_REGNUM = -1;
d1962 7
a1968 7
      tdep->DR1_REGNUM = 60;
      tdep->DR2_REGNUM = 61;
      tdep->DR3_REGNUM = 62;
      tdep->DR4_REGNUM = 63;
      tdep->DR5_REGNUM = 64;
      tdep->DR6_REGNUM = 65;
      tdep->DR7_REGNUM = 66;
d1970 3
a1972 3
      tdep->FV1_REGNUM = 68;
      tdep->FV2_REGNUM = 69;
      tdep->FV3_REGNUM = 70;
@


1.9
log
@2000-07-19  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        Multiarch the sh target.
	* sh-tdep.c:
	(sh_generic_reg_names, sh_reg_names,sh3_reg_names, sh3e_reg_names,
 	sh_dsp_reg_names, sh3_dsp_reg_names, sh_processor_type_table):
 	Remove.
	(XMALLOC): Define.
	(struct frame_extra_info): Define.
	(sh_register_raw_size, sh_register_virtual_size,
 	sh_register_virtual_type, sh_register_byte, sh_breakpoint_from_pc,
 	sh_frame_saved_pc, sh_skip_prologue,
 	sh_nofp_frame_init_saved_regs, sh_fp_frame_init_saved_regs,
 	sh_extract_struct_value_address, sh_use_struct_convention,
 	sh_store_struct_return, sh_push_arguments, sh_push_return_address,
 	sh_saved_pc_after_call, sh_generic_register_name,
 	sh_sh_register_name, sh_sh3_register_name, sh_sh3e_register_name,
 	sh_sh_dsp_register_name, sh_sh3_dsp_register_name,
 	sh_frame_args_address, sh_frame_locals_address,
 	sh_coerce_float_to_double, sh_default_store_return_value,
 	sh3e_sh4_store_return_value, sh_generic_show_regs,
 	sh3_show_regs,sh3e_show_regs, sh3_dsp_show_regs, sh4_show_regs,
 	sh_dsp_show_regs, sh_register_byte, sh_register_raw_size,
 	sh_register_virtual_size, sh_sh3e_register_virtual_type,
 	sh_default_register_virtual_type, sh_gdbarch_init): New functions.
	(sh_target_architecture_hook, sh_frame_find_saved_regs,
 	sh_show_regs): Delete functions.
	(sh_frame_chain, sh_find_callers_reg, sh_init_extra_frame_info,
 	sh_pop_frame, sh_extract_return_value): Update

	* config/sh/tm-sh.h (GDB_MULTI_ARCH): Define to 1.
	(struct gdbarch_tdep): Define.
	Remove all unnecessary defines.

	* remote-e7000.c ({PR,GBR,SR,MACL,VBR,MACH}_REGNUM): Define to -1,
 	for h8300 case.
	(want_sh,want_nopc_sh,want_nopc_sh3): Make nomenclature
 	consistent.
	(e7000_fetch_registers): Remove ifdef GDB_TARGET_IS_SH, use
 	runtime check instead.
	(e7000_wait): Ditto.

	* sh3-rom.c (sh3_supply_register): Use gdbarch_tdep to get the SSR
 	and SPC register numbers.
	(sh3_regnames, sh3e_regnames): Don't specify a size.

	* config/h8300/tm-h8300.h: Add comment.
@
text
@d44 2
a45 4
static gdbarch_register_raw_size_ftype sh_register_raw_size;
static gdbarch_register_virtual_size_ftype sh_register_virtual_size;
static gdbarch_register_virtual_type_ftype sh_register_virtual_type;
static gdbarch_register_byte_ftype sh_register_byte;
d50 1
d53 7
a62 1
static gdbarch_init_extra_frame_info_ftype sh_init_extra_frame_info;
d66 3
a68 2
static gdbarch_pop_frame_ftype sh_pop_frame;
static gdbarch_saved_pc_after_call_ftype sh_saved_pc_after_call;
d77 3
a79 5
static gdbarch_frame_args_address_ftype sh_frame_args_address;
static gdbarch_frame_locals_address_ftype sh_frame_locals_address;
static gdbarch_coerce_float_to_double_ftype sh_coerce_float_to_double;
static gdbarch_store_return_value_ftype	sh_default_store_return_value;
static gdbarch_store_return_value_ftype	sh3e_sh4_store_return_value;
a80 2
static gdbarch_register_byte_ftype sh_register_byte;
static gdbarch_register_raw_size_ftypesh_register_raw_size;
d82 4
d87 1
d90 23
a112 6
static void sh_generic_show_regs (char *, int);
static void sh3_show_regs (char *, int);
static void sh3e_show_regs (char *, int);
static void sh3_dsp_show_regs (char *, int);
static void sh_dsp_show_regs (char *, int);
static void sh4_show_regs (char *, int);
a113 2
void (*sh_show_regs) (char *, int);
 
d266 24
a351 1
   or
a352 1
   or
a356 1
   or
a357 1
   or
d1119 1
a1119 3
sh_generic_show_regs (args, from_tty)
     char *args;
     int from_tty;
d1153 1
a1153 3
sh3_show_regs (args, from_tty)
     char *args;
     int from_tty;
d1189 1
d1191 1
a1191 3
sh3e_show_regs (args, from_tty)
     char *args;
     int from_tty;
d1250 1
a1250 3
sh3_dsp_show_regs (args, from_tty)
     char *args;
     int from_tty;
d1307 1
a1307 3
sh4_show_regs (args, from_tty)
     char *args;
     int from_tty;
d1371 1
a1371 3
sh_dsp_show_regs (args, from_tty)
     char *args;
     int from_tty;
d1423 6
d1432 1
a1432 1
sh_register_byte (reg_nr)
d1438 14
d1455 1
a1455 1
sh_register_raw_size (reg_nr)
d1461 14
d1500 27
d1533 247
d1826 12
d1839 3
d1851 3
d1861 3
d1871 3
d1895 3
d1907 3
d1923 3
d1944 2
a1945 2
      sh_register_name = sh_generic_register_name;
      sh_show_regs = sh_generic_show_regs;
d1947 1
a1947 1
      sh_register_virtual_type = sh_sh3e_register_virtual_type;
d1950 6
d1961 12
d1980 3
a1999 5
  set_gdbarch_register_byte (gdbarch, sh_register_byte);
  set_gdbarch_register_raw_size (gdbarch, sh_register_raw_size);
  set_gdbarch_max_register_raw_size (gdbarch, 4);
  set_gdbarch_register_virtual_size (gdbarch, sh_register_virtual_size);
  set_gdbarch_max_register_virtual_size (gdbarch, 4);
d2045 2
d2070 1
a2070 1
  add_com ("regs", class_vars, sh_show_regs, "Print all registers");
@


1.8
log
@2000-07-10  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

	* config/sh/tm-sh.h (STORE_RETURN_VALUE): Redefine as
 	sh_store_return_value().
	* sh-tdep.c (sh_store_return_value): New function. Store the
 	value returned by a function into the appropriate register.

2000-07-10  Elena Zannoni  <ezannoni@@kwikemart.cygnus.com>

        * sh-tdep.c (sh_skip_prologue): Before looking at the actual
 	instructions, try to see if the symbol table can be of help, by
 	calling after_prologue(). If this doesn't work, call
 	skip_prologue_hard_way().
	(skip_prologue_hard_way): Renamed from sh_skip_prologue. Add some
 	more instruction pattern matching for pushing of arguments, and
 	manipulation of r14.
	(after_prologue): New function. Use symbol table info to determine
 	the end of the prologue, if possible.
@
text
@d41 2
a42 14
/* A set of original names, to be used when restoring back to generic
   registers from a specific set.  */
/* *INDENT-OFF* */
static char *sh_generic_reg_names[] = {
  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
  "fpul", "fpscr",
  "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
  "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
  "ssr",  "spc",
  "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
  "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
};
d44 57
a100 10
static char *sh_reg_names[] = {
  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
  "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
d103 1
a103 49
static char *sh3_reg_names[] = {
  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
  "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
  "ssr",  "spc",
  "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
  "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1"
};

static char *sh3e_reg_names[] = {
  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
  "fpul", "fpscr",
  "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
  "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
  "ssr",  "spc",
  "r0b0", "r1b0", "r2b0", "r3b0", "r4b0", "r5b0", "r6b0", "r7b0",
  "r0b1", "r1b1", "r2b1", "r3b1", "r4b1", "r5b1", "r6b1", "r7b1",
};

static char *sh_dsp_reg_names[] = {
  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
  "",     "dsr",
  "a0g",  "a0",   "a1g",  "a1",   "m0",   "m1",   "x0",   "x1",
  "y0",   "y1",   "",     "",     "",     "",     "",     "mod",
  "",     "",
  "rs",   "re",   "",     "",     "",     "",     "",     "",
  "",     "",     "",     "",     "",     "",     "",     "",
};

static char *sh3_dsp_reg_names[] = {
  "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
  "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
  "pc",   "pr",   "gbr",  "vbr",  "mach", "macl", "sr",
  "",     "dsr",
  "a0g",  "a0",   "a1g",  "a1",   "m0",   "m1",   "x0",   "x1",
  "y0",   "y1",   "",     "",     "",     "",     "",     "mod",
  "ssr",  "spc",
  "rs",   "re",   "",     "",     "",     "",     "",     "",
  "r0b",  "r1b",  "r2b",  "r3b",  "r4b",  "r5b",  "r6b",  "r7b",
};
/* *INDENT-ON* */

d109 1
d111 4
a114 1
struct
d116 19
a134 4
    char **regnames;
    int mach;
  }
sh_processor_type_table[] =
d136 1
d138 21
a158 3
    sh_reg_names, bfd_mach_sh
  }
  ,
d160 21
a180 3
    sh_reg_names, bfd_mach_sh2
  }
  ,
d182 21
a202 3
    sh_dsp_reg_names, bfd_mach_sh_dsp
  }
  ,
d204 21
a224 3
    sh3_reg_names, bfd_mach_sh3
  }
  ,
d226 29
a254 11
    sh3_dsp_reg_names, bfd_mach_sh3_dsp
  }
  ,
  {
    sh3e_reg_names, bfd_mach_sh3e
  }
  ,
  {
    NULL, 0
  }
};
d320 2
a321 2
|| ((((x) & 0xf000) == 0x1000) && (((x) & 0x00f0) >= 0x0040 && ((x) & 0x00f0) <= 0x0070)) \
|| ((((x) & 0xf00f) == 0x2002) && (((x) & 0x00f0) >= 0x0040 && ((x) & 0x00f0) <= 0x0070)))
d326 1
a326 1
((((x) & 0xff00) == 0x1e) && (((x) & 0x00f0) >= 0x0040 && ((x) & 0x00f0) <= 0x0070))
a329 9
/* Should call_function allocate stack space for a struct return?  */
int
sh_use_struct_convention (gcc_p, type)
     int gcc_p;
     struct type *type;
{
  return (TYPE_LENGTH (type) > 1);
}

d398 1
a398 1
CORE_ADDR
d418 34
d453 1
a453 2

int
d470 1
a470 2

CORE_ADDR
d477 1
a477 1
    return read_memory_integer (FRAME_FP (frame) + frame->f_offset, 4);
d488 1
a488 1
CORE_ADDR
a492 2
  struct frame_saved_regs fsr;

d500 1
a500 1
	FRAME_FIND_SAVED_REGS (fi, fsr);
d503 2
a504 2
	if (fsr.regs[regnum] != 0)
	  return read_memory_integer (fsr.regs[regnum],
d515 33
d549 89
a637 2
void
sh_frame_find_saved_regs (fi, fsr)
a638 1
     struct frame_saved_regs *fsr;
d649 6
a654 1

d660 1
a660 1
      memcpy (&fsr->regs, dummy_regs, sizeof (fsr));
d664 2
a665 2
  fi->leaf_function = 1;
  fi->f_offset = 0;
d697 1
a697 1
	  fi->leaf_function = 0;
d718 1
a718 1
	  if (read_register (FPSCR_REGNUM) & FPSCR_SZ)
d746 1
a746 1
	  fsr->regs[rn] = fi->frame - where[rn] + depth - 4;
d750 1
a750 1
	  fsr->regs[rn] = 0;
d756 1
a756 1
      fsr->regs[SP_REGNUM] = read_memory_integer (fsr->regs[FP_REGNUM], 4);
d760 1
a760 1
      fsr->regs[SP_REGNUM] = fi->frame - 4;
d763 1
a763 1
  fi->f_offset = depth - where[FP_REGNUM] - 4;
d768 2
a769 3
/* initialize the extra info saved in a FRAME */

void
d774 3
a776 1
  struct frame_saved_regs fsr;
d787 4
a790 4
      fi->return_pc = generic_read_register_dummy (fi->pc, fi->frame,
						   PC_REGNUM);
      fi->f_offset = -(CALL_DUMMY_LENGTH + 4);
      fi->leaf_function = 0;
d795 2
a796 2
      FRAME_FIND_SAVED_REGS (fi, fsr);
      fi->return_pc = sh_find_callers_reg (fi, PR_REGNUM);
d800 31
d833 1
a833 2

void
a838 1
  struct frame_saved_regs fsr;
d845 1
a845 1
      get_frame_saved_regs (frame, &fsr);
d849 2
a850 2
	if (fsr.regs[regnum])
	  write_register (regnum, read_memory_integer (fsr.regs[regnum], 4));
d852 1
a852 1
      write_register (PC_REGNUM, frame->return_pc);
a891 1

d901 1
a901 1
CORE_ADDR
d928 1
a928 2
  for (argnum = 0, stack_alloc = 0;
       argnum < nargs; argnum++)
a931 1

d943 2
a944 1
	{			/* value gets right-justified in the register or stack word */
d985 1
a985 1
CORE_ADDR
d1023 107
d1131 19
a1149 1
/* Modify the actual processor type. */
d1151 4
a1154 3
int
sh_target_architecture_hook (ap)
     const bfd_arch_info_type *ap;
d1156 6
a1161 1
  int i, j;
d1163 9
a1171 2
  if (ap->arch != bfd_arch_sh)
    return 0;
d1173 18
a1190 8
  for (i = 0; sh_processor_type_table[i].regnames != NULL; i++)
    {
      if (sh_processor_type_table[i].mach == ap->mach)
	{
	  sh_register_names = sh_processor_type_table[i].regnames;
	  return 1;
	}
    }
d1192 18
a1209 1
  internal_error ("Architecture `%s' unreconized", ap->printable_name);
d1212 58
a1269 1
/* Print the registers in a form similar to the E7000 */
d1272 1
a1272 1
sh_show_regs (args, from_tty)
d1276 60
a1335 5
  int cpu;
  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    cpu = TARGET_ARCHITECTURE->mach;
  else
    cpu = 0;
d1337 5
d1352 3
a1354 15
  if (cpu == bfd_mach_sh3 || cpu == bfd_mach_sh3e || cpu == bfd_mach_sh3_dsp
      || cpu == bfd_mach_sh4)
    {
      printf_filtered (" SSR=%08lx SPC=%08lx",
		       (long) read_register (SSR_REGNUM),
		       (long) read_register (SPC_REGNUM));
      if (cpu == bfd_mach_sh3e || cpu == bfd_mach_sh4)
	{
	  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
			   (long) read_register (FPUL_REGNUM),
			   (long) read_register (FPSCR_REGNUM));
	}
    }
  if (cpu == bfd_mach_sh_dsp || cpu == bfd_mach_sh3_dsp)
    printf_filtered (" DSR=%08lx", (long) read_register (DSR_REGNUM));
a1373 3
  if (cpu == bfd_mach_sh3e || cpu == bfd_mach_sh4)
    {
      int pr = cpu == bfd_mach_sh4 && (read_register (FPSCR_REGNUM) & 0x80000);
d1375 24
a1398 42
      printf_filtered ((pr
			? "DR0-DR6  %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n"
			: "FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		       (long) read_register (FP0_REGNUM + 0),
		       (long) read_register (FP0_REGNUM + 1),
		       (long) read_register (FP0_REGNUM + 2),
		       (long) read_register (FP0_REGNUM + 3),
		       (long) read_register (FP0_REGNUM + 4),
		       (long) read_register (FP0_REGNUM + 5),
		       (long) read_register (FP0_REGNUM + 6),
		       (long) read_register (FP0_REGNUM + 7));
      printf_filtered ((pr
			? "DR8-DR14 %08lx%08lx %08lx%08lx %08lx%08lx %08lx%08lx\n"
			: "FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n"),
		       (long) read_register (FP0_REGNUM + 8),
		       (long) read_register (FP0_REGNUM + 9),
		       (long) read_register (FP0_REGNUM + 10),
		       (long) read_register (FP0_REGNUM + 11),
		       (long) read_register (FP0_REGNUM + 12),
		       (long) read_register (FP0_REGNUM + 13),
		       (long) read_register (FP0_REGNUM + 14),
		       (long) read_register (FP0_REGNUM + 15));
    }
  /* FIXME: sh4 has more registers */
  if (cpu == bfd_mach_sh_dsp || cpu == bfd_mach_sh3_dsp)
    {
      printf_filtered ("A0G=%02lx A0=%08lx M0=%08lx X0=%08lx Y0=%08lx RS=%08lx MOD=%08lx\n",
		       (long) read_register (A0G_REGNUM) & 0xff,
		       (long) read_register (A0_REGNUM),
		       (long) read_register (M0_REGNUM),
		       (long) read_register (X0_REGNUM),
		       (long) read_register (Y0_REGNUM),
		       (long) read_register (RS_REGNUM),
		       (long) read_register (MOD_REGNUM));
      printf_filtered ("A1G=%02lx A1=%08lx M1=%08lx X1=%08lx Y1=%08lx RE=%08lx\n",
		       (long) read_register (A1G_REGNUM) & 0xff,
		       (long) read_register (A1_REGNUM),
		       (long) read_register (M1_REGNUM),
		       (long) read_register (X1_REGNUM),
		       (long) read_register (Y1_REGNUM),
		       (long) read_register (RE_REGNUM));
    }
d1401 8
a1408 3
/* Function: extract_return_value
   Find a function's return value in the appropriate registers (in regbuf),
   and copy it into valbuf.  */
d1410 5
a1414 5
void
sh_extract_return_value (type, regbuf, valbuf)
     struct type *type;
     void *regbuf;
     void *valbuf;
d1416 5
a1420 1
  int len = TYPE_LENGTH (type);
d1422 8
a1429 4
  if (len <= 4)
    memcpy (valbuf, ((char *) regbuf) + 4 - len, len);
  else if (len <= 8)
    memcpy (valbuf, ((char *) regbuf) + 8 - len, len);
d1431 8
a1438 1
    error ("bad size for return value");
d1441 6
a1446 6
/* If the architecture is sh4 or sh3e, store a function's return value
   in the R0 general register or in the FP0 floating point register,
   depending on the type of the return value. In all the other cases
   the result is stored in r0. */
void
sh_store_return_value (struct type *type, void *valbuf)
d1448 42
a1489 6
  int cpu;
  if (TARGET_ARCHITECTURE->arch == bfd_arch_sh)
    cpu = TARGET_ARCHITECTURE->mach;
  else
    cpu = 0;
  if (cpu == bfd_mach_sh3e || cpu == bfd_mach_sh4)
d1491 100
a1590 4
      if (TYPE_CODE (type) == TYPE_CODE_FLT) 
	write_register_bytes (REGISTER_BYTE (FP0_REGNUM), valbuf, TYPE_LENGTH (type));
      else
	write_register_bytes (REGISTER_BYTE (0), valbuf, TYPE_LENGTH (type));
d1592 78
a1669 2
  else
    write_register_bytes (REGISTER_BYTE (0), valbuf, TYPE_LENGTH (type));
d1676 2
a1677 1

a1678 2

  target_architecture_hook = sh_target_architecture_hook;
@


1.7
log
@2000-07-03  Christopher Faylor  <cgf@@cygnus.com>

	Committed by Elena Zannoni <ezannoni@@cygnus.com>
	* sh-tdep.c (sh_skip_prologue): Change prologue matching for modern
	compilers.
	(sh_frame_find_saved_regs): Ditto.
	(sh_find_callers_reg): Stop if pc is zero.
@
text
@d164 17
d183 2
d186 3
d190 1
d192 3
d196 3
d200 1
d203 3
d207 6
d214 17
a232 1

d242 10
d253 19
a271 1
/* Skip any prologue before the guts of a function */
d273 5
a277 2
CORE_ADDR
sh_skip_prologue (start_pc)
d281 1
d291 6
a296 4
	  || IS_ADD_R3SP (w) || IS_ADD_SP (w) || IS_SHLL_R3 (w))
	start_pc = here;

      if (IS_MOV_SP_FP (w))
d299 5
a304 1
	}
d310 20
d900 23
@


1.6
log
@The attatched moves the remaining guff from gdbarch.{h,c,sh} to
arch-utils.{h,c}.  The ``set architecutre'' and ``set endian''
commands (part of the move) were implemented to use add_set_enum_cmd()
so that ``set architecture <tab>'' works.
@
text
@d194 1
a194 1
  int w;
d196 4
a199 9
  w = read_memory_integer (start_pc, 2);
  while (IS_STS (w)
	 || IS_FMOV (w)
	 || IS_PUSH (w)
	 || IS_MOV_SP_FP (w)
	 || IS_MOV_R3 (w)
	 || IS_ADD_R3SP (w)
	 || IS_ADD_SP (w)
	 || IS_SHLL_R3 (w))
d201 11
a211 2
      start_pc += 2;
      w = read_memory_integer (start_pc, 2);
d243 1
a243 1
  if (!inside_entry_file (frame->pc))
d270 2
a308 4
  opc = pc = get_pc_function_start (fi->pc);

  insn = read_memory_integer (pc, 2);

d321 8
a328 1
  while (pc < opc + 20 * 2)
d330 1
a333 1
	  pc += 2;
a335 1
	  insn = read_memory_integer (pc, 2);
a339 1
	  pc += 2;
a340 1
	  insn = read_memory_integer (pc, 2);
a347 2
	  pc += 2;
	  insn = read_memory_integer (pc, 2);
a351 2
	  pc += 2;
	  insn = read_memory_integer (pc, 2);
a355 2
	  pc += 2;
	  insn = read_memory_integer (pc, 2);
a358 1
	  pc += 2;
a359 1
	  insn = read_memory_integer (pc, 2);
a362 2
	  pc += 2;
	  insn = read_memory_integer (pc, 2);
d372 5
d379 1
@


1.5
log
@sh-dsp support, simulator speedup by using host byte order:

sim:
	* Makefile.in (interp.o): Depends on ppi.c .
	(ppi.c): New rule.
	* gencode.c (printonmatch, think, genopc): Deleted.
	(MAX_NR_STUFF): Now 42.
	(tab): Add SH-DSP CPU instructions.
	Amalgamate ldc / stc / lds / sts instructions with similar
	bit patterns.  Fix opcodes of stc Rm_BANK,@@-<REG_N>.
	Fix semantics of lds.l @@<REG_N>+,MACH (no sign extend).
	(movsxy_tab): New array.
	For movs, change MMMM field to GGGG, and mmmm field to MMMM.
	Added entries for movx, movy and parallel processing insns.
	(ppi_tab): New array.
	(qfunc): Stabilize sort.
	(expand_opcode): Handle [01][01]NN, [01][01]xx and [01][01]yy.
	Handle 'M', 'G' 's' 'X', 'a', 'Y' and 'A'.
	(dumptable): Now takes three arguments.  Changed all callers.
	Emit just one contigous jump table.
	(filltable): Now takes an argument.  Changed all callers.
	Make index static.
	(ppi_moves, expand_ppi_code, ppi_filltable, ppi_gensim): New functions.
	(gensim_caselist): New function, broken out of gensim.
	Handle opcode fields 'x', 'y', 's', 'M', 'G', 'X', 'a', and 'Y'.
	Handle ref '9'.
	(gensim): Handle 'N' in code field and '8' in refs field.
	Call gensim_caselist - twice.
	(ppi_index): New static variable.
	(main): Unsupport default action.
	Add dsp support for -x / -s option.  Add -p option.
	* interp.c (sh_jump_table, sh_dsp_table, ppi_table): Declare.
	(saved_state_type): Rearrange to allow amalgamated ldc / stc /
	lds / sts to work efficiently.
	(target_dsp): New static variable.
	(GBR, VBR, SSR, SPC, MACH, MACL): Reflect saved_state_type change.
	(FPUL, Rn_BANK, SET_Rn_BANK, M, Q, S, T, SR_BL, SR_RB): Likewise.
	(SR_MD, SR_RC, SET_SR_BIT, GET_SR, SET_RC, GET_FPSCR): Likewise.
	(RS, RE, MOD, MOD_ME, DSP_R): Likewise.
	(set_fpscr1): Likewise.  Use target_dsp to check for dsp.
	(MOD_MSi, SIG_BUS_FETCH): Deleted.
	(CREG, SREG, PR, SR_MASK_DMY, SR_MASK_DMX, SR_DMY): New macros.
	(SR_DMX, DSR, MOD_DELTA, GET_DSP_GRD): Likewise.
	(SET_MOD): Reflect saved_state_type change.  Set MOD_DELTA instead
	of MOD_MS, and encode SR_DMY / SR_DMX into high word of MOD_ME.
	(set_sr): Reflect saved_state_type change.  Fix SR_RB handling.
	Use SET_MOD.
	(MA, L, TL, TB): Now controlled by ACE_FAST.
	(SEXT32): Just cast to int.
	(SIGN32): Fixed to only shift by 31.
	(CHECK_INSN_PTR): SIGBUS at insn fetch now represented by insn_end 0.
	(ppi_insn): Declare.
	(ppi.c): Include.
	(init_dsp): Set target_dsp.  When it changes, switch end of
	sh_jump_table with sh_dsp_table.
	(sim_resume) Don't declare sh_jump_table0.  Use sh_jump_table instead.
	Don't Declare PR if it's #defined.
	Fix single-stepping (Was broken in Mar  6 16:59:10 patch).
	(sim_store_register, sim_read_register): Translate accesses to
	reflect saved_state_type change.

	* interp.c (set_sr): Set sr.
	(SET_RC, MOD, MOD_MS, MOD_ME, SET_MOD, MOD_MS, MOD_ME): New macros.
	(set_fpscr1): Don't bank-switch fpu registers when simulating sh-dsp.
	(DSP_R): Fix definition.
	(sim_resume): Remove outdated SET_SR use.

	* interp.c (saved_state): New members for struct member asregs:
	rs, re, insn_end, xram_start, yram_start.
	(struct loop_bounds): New struct.
	(SKIP_INSN): New macro.
	(get_loop_bounds): New function.
	(endianw): Renamed to global_endianw.
	(maskw): negated bits.
	(PC): Now insn_ptr.
	(SR_MASK_RC, SR_RC_INCREMENT, SR_RC, RAISE_EXCEPTION): New macros.
	(RS, RE, DSP_R, DSP_GRD, A1, A0, X0, X1, Y0, Y1, M0, A1G): Likewise.
	(M1, A0G, RIAT, PT2H, PH2T, SET_NIP, CHECK_INSN_PTR): Likewise.
	(SIG_BUS_FETCH): Likewise
	(raise_exception, riat_fast): New functions.
	(raise_buserror, sim_stop): Use raise_exception.
	(PROCESS_SPECIAL_ADDRESS): Use xram_start / yram_start.
	(BUSERROR, WRITE_BUSERROR, READ_BUSERROR):
	Reverse sense of mask argument.
	(FP_OP, set_dr): Use RAISE_EXCEPTION.
	(wlat_fast, wwat_fast, wbat_fast, rlat_fast, rwat_fast, rbat_fast):
	Declare.  Remove redundant masking.
	(wwat_fast, rwat_fast): Add argument endianw.  Changed callers.
	(MA): Updated for change pc -> PC.
	(Delay_Slot): Use RIAT.
	(empty): Deleted.
	(trap): Remove argument little_endian.  Add argument endianw.
	Changed all callers.  Use raise_exception.
	(macw): Add argument endainw.  Changed all callers.
	(init_dsp): New function, extended after broken out of init_pointers.
	(sim_resume): Replace pc with insn_ptr.  Replace little_endian with
	endianw.  Replace nia with nip.  Reverse sense of maskb / maskw /
	maskl.  Implement logic for zero-overhead loops.  Don't try to
	interpret garbage when getting a SIGBUS at insn fetch.
	(sim_open): Call init_dsp.
	* gencode.c (tab): Use SET_NIP instead of nia = .  Use PH2T / PT2H /
	RAISE_EXCEPTION where appropriate.
	Add extra cycles for brai, braf , bsr, bsrf, jmp, jsr.

	* interp.c (sim_store_register, sim_fetch_register):
	Do proper endianness switch.

	* interp.c (saved_state_type): New members for struct member asregs:
	xymem_select, xmem, ymem, xmem_offset, ymem_offset.
	(special_address): Delete.
	(BUSERROR): Now a two-argument predicate.
	(PROCESS_SPECIAL_ADDRESS, WRITE_BUSERROR, READ_BUSERROR): New macros.
	(wlat_little, wwat_little, wbat_any, wlat_big, wwat_big): Delete.
	(process_wlat_addr, process_wwat_addr): New functions.
	(process_wbat_addr, process_rlat_addr, process_rwat_addr): Likewise.
	(process_rbat_addr): Likewise.
	(wlat_fast, wwat_fast, wbat_fast): Use WRITE_BUSERROR.
	(rlat_little, rwat_little, rbat_any, rlat_big, rwat_big): Delete.
	(rlat_fast, rwat_fast, rbat_fast): Use READ_BUSERROR.
	(RWAT, RLAT, RBAT, WWAT, WLAT, WBAT): Delete SLOW versions.
	(do_rdat, trap): Delete SLOW code.
	(SEXT32, SIGN32): New macros.
	(swap, swap16): Now integer in - integer out.  Changed all callers.
	(strswaplen, strnswap): Delete SLOW versions.
	(init_pointers): Initialize dsp memory selection (preliminary).
	(sim_store_register, sim_fetch_register): Use swap instead of
	big / little endian read / write functions.

	* interp.c (maskl): Deleted.
	(endianw, endianb): New variables.
	(special_address): Now inline.
	(bp_holder): Put raising of buserror there, rename to:
	(raise_buserror).
	(BUSERROR): Now yields a value.  Changed all users.
	(wbat_big): Delete.
	(wlat_fast, wwat_fast, wbat_fast): New functions.
	(rlat_fast, rwat_fast, rbat_fast): Likewise.
	(RWAT, RLAT, RBAT, WWAT, WLAT, WBAT): Use new functions.
	(do_rdat, do_wdat): Likewise.  Take maskl argument instead of
	little_endian one.  Changed caller macros.
	(swap, swap16): Use w[rw]lat_big / w[rw]lat_little directly.
	(strswaplen, strnswap): New functions.
	(trap): Use them to fix up endian mismatches;
	disable SYS_execve and SYS_execv; fix double address translation for
	SYS_pipe and SYS_stat.
	(sym_write, sym_read): Add endianness translation.
	(sym_store_register, sym_fetch_register): Add maskl local variable.
	(sim_open): Set endianw and endianb.

gdb:

	* sh-tdep.c (sh_dsp_reg_names, sh3_dsp_reg_names): New arrays.
	(sh_processor_type_table): Add entries for bfd_mach_sh_dsp and
	 bfd_mach_sh3_dsp.
	(sh_show_regs): Floating point registers are called fr0-fr15.
	For sh4, display fpul, fpscr and fr0-fr15 / dr0-dr14 as appropriate.
	Handle sh-dsp and sh3-dsp.
	config/sh/tm-sh.h (REGISTER_VIRTUAL_TYPE): sh-dsp / sh3-dsp
	don't have floating point registers.
	(DSR_REGNUM, A0G_REGNUM, A0_REGNUM, A1G_REGNUM, A1_REGNUM): Define.
	(M0_REGNUM, M1_REGNUM, X0_REGNUM, X1_REGNUM, Y0_REGNUM): Likewise.
	(Y1_REGNUM, MOD_REGNUM, RS_REGNUM, RE_REGNUM, R0B_REGNUM): Likewise.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
d39 1
@


1.4
log
@Add sh2 to list of known architectures.
@
text
@d89 24
d137 4
d145 4
d683 2
a684 1
  if (cpu == bfd_mach_sh3 || cpu == bfd_mach_sh3e)
d689 1
a689 1
      if (cpu == bfd_mach_sh3e)
d696 2
d717 1
a717 1
  if (cpu == bfd_mach_sh3e)
d719 5
a723 1
      printf_filtered ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d732 3
a734 1
      printf_filtered ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
d743 19
@


1.3
log
@* configure.tgt: Add arm, mips, sh wince targets.
* config/arm/tm-wince.h: New file.
* config/arm/wince.mt New file.
* config/sh/tm-wince.h: New file.
* config/sh/wince.mt New file.
* config/mips/tm-wince.h: New file.
* config/mips/wince.mt New file.
* wince.c: New file.
* wince-stub.c: New file.
* wince-stub.h: New file.
* sh-tdep.c: Use correct register names for Windows CE.
@
text
@d109 4
@


1.2
log
@Remove extraneous code.
@
text
@d91 3
a93 2


d95 1
@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d22 2
a23 2
 Contributed by Steve Chamberlain
                sac@@cygnus.com
d41 1
a41 1

d89 3
d95 22
a116 9

struct {
  char **regnames;
  int mach;
} sh_processor_type_table[] = {
  { sh_reg_names, bfd_mach_sh },
  { sh3_reg_names, bfd_mach_sh3 },
  { sh3e_reg_names, bfd_mach_sh3e },
  { NULL, 0 }
d120 5
a124 5
   [mov.l	<regs>,@@-r15]...
   [sts.l	pr,@@-r15]
   [mov.l	r14,@@-r15]
   [mov		r15,r14]
*/
d221 1
a221 1
	 that's where the previous routine appears to have done a call from. */
d223 1
a223 1
    else 
d225 1
a225 1
	FRAME_FIND_SAVED_REGS(fi, fsr);
d227 2
a228 2
	  return read_memory_integer (fsr.regs[regnum], 
				      REGISTER_RAW_SIZE(regnum));
d252 1
a252 1
  char * dummy_regs = generic_find_dummy_frame (fi->pc, fi->frame);
d257 3
a259 3
	 the saved registers is byte-for-byte identical to the 
	 CORE_ADDR regs[NUM_REGS] format used by struct frame_saved_regs! */
      memcpy (&fsr->regs, dummy_regs, sizeof(fsr));
d386 4
a389 4
	 by assuming it's always FP.  */
      fi->frame     = generic_read_register_dummy (fi->pc, fi->frame, 
						   SP_REGNUM);
      fi->return_pc = generic_read_register_dummy (fi->pc, fi->frame, 
d416 3
a418 3
  {
    fp = FRAME_FP (frame);
    get_frame_saved_regs (frame, &fsr);
d420 4
a423 4
    /* Copy regs from where they were saved in the frame */
    for (regnum = 0; regnum < NUM_REGS; regnum++)
      if (fsr.regs[regnum])
	write_register (regnum, read_memory_integer (fsr.regs[regnum], 4));
d425 3
a427 3
    write_register (PC_REGNUM, frame->return_pc);
    write_register (SP_REGNUM, fp + 4);
  }
d464 1
a464 1
 
d499 1
a499 1
      write_register (STRUCT_RETURN_REGNUM, struct_addr);
d504 2
a505 2
    stack_alloc += ((TYPE_LENGTH(VALUE_TYPE(args[argnum])) + 3) & ~3);
  sp -= stack_alloc;    /* make room on stack for args */
d516 2
a517 2
      len  = TYPE_LENGTH (type);
      memset(valbuf, 0, sizeof(valbuf));
d519 5
a523 5
        { /* value gets right-justified in the register or stack word */
          memcpy(valbuf + (4 - len), 
		 (char *) VALUE_CONTENTS (args[argnum]), len);
          val = valbuf;
        }
d525 1
a525 1
        val = (char *) VALUE_CONTENTS (args[argnum]);
d528 2
a529 2
	odd_sized_struct = 1;		/* such structs go entirely on stack */
      else 
d534 1
a534 1
	    {				/* must go on the stack */
d542 2
a543 2
	    {				/* there's room in a register */
	      regval = extract_address (val, REGISTER_RAW_SIZE(argreg));
d549 2
a550 2
	  len -= REGISTER_RAW_SIZE(argreg);
	  val += REGISTER_RAW_SIZE(argreg);
d576 6
a581 6
        mov.w @@(2,PC), R8
        jsr   @@R8
        nop
        trap
        <destination>
  */
a597 16
/* Function: get_saved_register
   Just call the generic_get_saved_register function.  */

void
get_saved_register (raw_buffer, optimized, addrp, frame, regnum, lval)
     char *raw_buffer;
     int *optimized;
     CORE_ADDR *addrp;
     struct frame_info *frame;
     int regnum;
     enum lval_type *lval;
{
  generic_get_saved_register (raw_buffer, optimized, addrp, 
			      frame, regnum, lval);
}

d619 1
a619 1
  fatal ("Architecture `%s' unreconized", ap->printable_name);
d635 10
a644 10
  printf_filtered ("PC=%08x SR=%08x PR=%08x MACH=%08x MACHL=%08x\n",
		   read_register (PC_REGNUM),
		   read_register (SR_REGNUM),
		   read_register (PR_REGNUM),
		   read_register (MACH_REGNUM),
		   read_register (MACL_REGNUM));

  printf_filtered ("GBR=%08x VBR=%08x",
                   read_register (GBR_REGNUM),
                   read_register (VBR_REGNUM));
d647 3
a649 3
      printf_filtered (" SSR=%08x SPC=%08x",
                       read_register (SSR_REGNUM),
                       read_register (SPC_REGNUM));
d651 25
a675 25
        {
          printf_filtered (" FPUL=%08x FPSCR=%08x",
                           read_register (FPUL_REGNUM),
                           read_register (FPSCR_REGNUM));
        }
    }

  printf_filtered ("\nR0-R7  %08x %08x %08x %08x %08x %08x %08x %08x\n",
		   read_register (0),
		   read_register (1),
		   read_register (2),
		   read_register (3),
		   read_register (4),
		   read_register (5),
		   read_register (6),
		   read_register (7));
  printf_filtered ("R8-R15 %08x %08x %08x %08x %08x %08x %08x %08x\n",
		   read_register (8),
		   read_register (9),
		   read_register (10),
		   read_register (11),
		   read_register (12),
		   read_register (13),
		   read_register (14),
		   read_register (15));
d678 18
a695 18
      printf_filtered ("FP0-FP7  %08x %08x %08x %08x %08x %08x %08x %08x\n",
                       read_register (FP0_REGNUM + 0),
                       read_register (FP0_REGNUM + 1),
                       read_register (FP0_REGNUM + 2),
                       read_register (FP0_REGNUM + 3),
                       read_register (FP0_REGNUM + 4),
                       read_register (FP0_REGNUM + 5),
                       read_register (FP0_REGNUM + 6),
                       read_register (FP0_REGNUM + 7));
      printf_filtered ("FP8-FP15 %08x %08x %08x %08x %08x %08x %08x %08x\n",
                       read_register (FP0_REGNUM + 8),
                       read_register (FP0_REGNUM + 9),
                       read_register (FP0_REGNUM + 10),
                       read_register (FP0_REGNUM + 11),
                       read_register (FP0_REGNUM + 12),
                       read_register (FP0_REGNUM + 13),
                       read_register (FP0_REGNUM + 14),
                       read_register (FP0_REGNUM + 15));
d709 1
a709 1
  int len = TYPE_LENGTH(type);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a98 1
  { sh3e_reg_names, bfd_mach_sh4 },
d581 16
a632 4

  /* FIXME: sh4 has more registers */
  if (cpu == bfd_mach_sh4)
    cpu = bfd_mach_sh3;
@


1.1.1.3
log
@import gdb-1999-05-25 snapshot
@
text
@d91 1
@


1.1.1.4
log
@import gdb-1999-07-07 pre reformat
@
text
@a40 1
/* *INDENT-OFF* */
a87 1
/* *INDENT-ON* */
@


1.1.1.5
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d21 2
a22 2
   Contributed by Steve Chamberlain
   sac@@cygnus.com
d40 1
a90 2


d93 9
a101 26
struct
  {
    char **regnames;
    int mach;
  }
sh_processor_type_table[] =
{
  {
    sh_reg_names, bfd_mach_sh
  }
  ,
  {
    sh3_reg_names, bfd_mach_sh3
  }
  ,
  {
    sh3e_reg_names, bfd_mach_sh3e
  }
  ,
  {
    sh3e_reg_names, bfd_mach_sh4
  }
  ,
  {
    NULL, 0
  }
d105 5
a109 5
   [mov.l       <regs>,@@-r15]...
   [sts.l       pr,@@-r15]
   [mov.l       r14,@@-r15]
   [mov         r15,r14]
 */
d206 1
a206 1
         that's where the previous routine appears to have done a call from. */
d208 1
a208 1
    else
d210 1
a210 1
	FRAME_FIND_SAVED_REGS (fi, fsr);
d212 2
a213 2
	  return read_memory_integer (fsr.regs[regnum],
				      REGISTER_RAW_SIZE (regnum));
d237 1
a237 1
  char *dummy_regs = generic_find_dummy_frame (fi->pc, fi->frame);
d242 3
a244 3
         the saved registers is byte-for-byte identical to the 
         CORE_ADDR regs[NUM_REGS] format used by struct frame_saved_regs! */
      memcpy (&fsr->regs, dummy_regs, sizeof (fsr));
d371 4
a374 4
         by assuming it's always FP.  */
      fi->frame = generic_read_register_dummy (fi->pc, fi->frame,
					       SP_REGNUM);
      fi->return_pc = generic_read_register_dummy (fi->pc, fi->frame,
d401 3
a403 3
    {
      fp = FRAME_FP (frame);
      get_frame_saved_regs (frame, &fsr);
d405 4
a408 4
      /* Copy regs from where they were saved in the frame */
      for (regnum = 0; regnum < NUM_REGS; regnum++)
	if (fsr.regs[regnum])
	  write_register (regnum, read_memory_integer (fsr.regs[regnum], 4));
d410 3
a412 3
      write_register (PC_REGNUM, frame->return_pc);
      write_register (SP_REGNUM, fp + 4);
    }
d449 1
a449 1

d484 1
a484 1
    write_register (STRUCT_RETURN_REGNUM, struct_addr);
d489 2
a490 2
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 3) & ~3);
  sp -= stack_alloc;		/* make room on stack for args */
d501 2
a502 2
      len = TYPE_LENGTH (type);
      memset (valbuf, 0, sizeof (valbuf));
d504 5
a508 5
	{			/* value gets right-justified in the register or stack word */
	  memcpy (valbuf + (4 - len),
		  (char *) VALUE_CONTENTS (args[argnum]), len);
	  val = valbuf;
	}
d510 1
a510 1
	val = (char *) VALUE_CONTENTS (args[argnum]);
d513 2
a514 2
	odd_sized_struct = 1;	/* such structs go entirely on stack */
      else
d519 1
a519 1
	    {			/* must go on the stack */
d527 2
a528 2
	    {			/* there's room in a register */
	      regval = extract_address (val, REGISTER_RAW_SIZE (argreg));
d534 2
a535 2
	  len -= REGISTER_RAW_SIZE (argreg);
	  val += REGISTER_RAW_SIZE (argreg);
d561 6
a566 6
   mov.w @@(2,PC), R8
   jsr   @@R8
   nop
   trap
   <destination>
 */
d632 2
a633 2
		   read_register (GBR_REGNUM),
		   read_register (VBR_REGNUM));
d637 2
a638 2
		       read_register (SSR_REGNUM),
		       read_register (SPC_REGNUM));
d640 5
a644 5
	{
	  printf_filtered (" FPUL=%08x FPSCR=%08x",
			   read_register (FPUL_REGNUM),
			   read_register (FPSCR_REGNUM));
	}
d668 8
a675 8
		       read_register (FP0_REGNUM + 0),
		       read_register (FP0_REGNUM + 1),
		       read_register (FP0_REGNUM + 2),
		       read_register (FP0_REGNUM + 3),
		       read_register (FP0_REGNUM + 4),
		       read_register (FP0_REGNUM + 5),
		       read_register (FP0_REGNUM + 6),
		       read_register (FP0_REGNUM + 7));
d677 8
a684 8
		       read_register (FP0_REGNUM + 8),
		       read_register (FP0_REGNUM + 9),
		       read_register (FP0_REGNUM + 10),
		       read_register (FP0_REGNUM + 11),
		       read_register (FP0_REGNUM + 12),
		       read_register (FP0_REGNUM + 13),
		       read_register (FP0_REGNUM + 14),
		       read_register (FP0_REGNUM + 15));
d698 1
a698 1
  int len = TYPE_LENGTH (type);
@


1.1.1.6
log
@import gdb-1999-08-09 snapshot
@
text
@d623 1
a623 1
  internal_error ("Architecture `%s' unreconized", ap->printable_name);
@


1.1.1.7
log
@import gdb-1999-09-08 snapshot
@
text
@d643 6
a648 6
  printf_filtered ("PC=%s SR=%08lx PR=%08lx MACH=%08lx MACHL=%08lx\n",
		   paddr (read_register (PC_REGNUM)),
		   (long) read_register (SR_REGNUM),
		   (long) read_register (PR_REGNUM),
		   (long) read_register (MACH_REGNUM),
		   (long) read_register (MACL_REGNUM));
d650 3
a652 3
  printf_filtered ("GBR=%08lx VBR=%08lx",
		   (long) read_register (GBR_REGNUM),
		   (long) read_register (VBR_REGNUM));
d655 3
a657 3
      printf_filtered (" SSR=%08lx SPC=%08lx",
		       (long) read_register (SSR_REGNUM),
		       (long) read_register (SPC_REGNUM));
d660 3
a662 3
	  printf_filtered (" FPUL=%08lx FPSCR=%08lx",
			   (long) read_register (FPUL_REGNUM),
			   (long) read_register (FPSCR_REGNUM));
d666 18
a683 18
  printf_filtered ("\nR0-R7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (0),
		   (long) read_register (1),
		   (long) read_register (2),
		   (long) read_register (3),
		   (long) read_register (4),
		   (long) read_register (5),
		   (long) read_register (6),
		   (long) read_register (7));
  printf_filtered ("R8-R15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		   (long) read_register (8),
		   (long) read_register (9),
		   (long) read_register (10),
		   (long) read_register (11),
		   (long) read_register (12),
		   (long) read_register (13),
		   (long) read_register (14),
		   (long) read_register (15));
d686 18
a703 18
      printf_filtered ("FP0-FP7  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		       (long) read_register (FP0_REGNUM + 0),
		       (long) read_register (FP0_REGNUM + 1),
		       (long) read_register (FP0_REGNUM + 2),
		       (long) read_register (FP0_REGNUM + 3),
		       (long) read_register (FP0_REGNUM + 4),
		       (long) read_register (FP0_REGNUM + 5),
		       (long) read_register (FP0_REGNUM + 6),
		       (long) read_register (FP0_REGNUM + 7));
      printf_filtered ("FP8-FP15 %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		       (long) read_register (FP0_REGNUM + 8),
		       (long) read_register (FP0_REGNUM + 9),
		       (long) read_register (FP0_REGNUM + 10),
		       (long) read_register (FP0_REGNUM + 11),
		       (long) read_register (FP0_REGNUM + 12),
		       (long) read_register (FP0_REGNUM + 13),
		       (long) read_register (FP0_REGNUM + 14),
		       (long) read_register (FP0_REGNUM + 15));
@


