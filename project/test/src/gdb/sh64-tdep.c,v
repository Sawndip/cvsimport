head	1.93;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.89
	gdb_7_6-2013-04-26-release:1.89
	gdb_7_6-branch:1.89.0.2
	gdb_7_6-2013-03-12-branchpoint:1.89
	gdb_7_5_1-2012-11-29-release:1.85
	gdb_7_5-2012-08-17-release:1.85
	gdb_7_5-branch:1.85.0.2
	gdb_7_5-2012-07-18-branchpoint:1.85
	gdb_7_4_1-2012-04-26-release:1.80.4.1
	gdb_7_4-2012-01-24-release:1.80.4.1
	gdb_7_4-branch:1.80.0.4
	gdb_7_4-2011-12-13-branchpoint:1.80
	gdb_7_3_1-2011-09-04-release:1.80
	gdb_7_3-2011-07-26-release:1.80
	gdb_7_3-branch:1.80.0.2
	gdb_7_3-2011-04-01-branchpoint:1.80
	gdb_7_2-2010-09-02-release:1.75
	gdb_7_2-branch:1.75.0.2
	gdb_7_2-2010-07-07-branchpoint:1.75
	gdb_7_1-2010-03-18-release:1.72
	gdb_7_1-branch:1.72.0.2
	gdb_7_1-2010-02-18-branchpoint:1.72
	gdb_7_0_1-2009-12-22-release:1.71
	gdb_7_0-2009-10-06-release:1.71
	gdb_7_0-branch:1.71.0.4
	gdb_7_0-2009-09-16-branchpoint:1.71
	arc-sim-20090309:1.58
	msnyder-checkpoint-072509-branch:1.71.0.2
	msnyder-checkpoint-072509-branchpoint:1.71
	arc-insight_6_8-branch:1.58.0.6
	arc-insight_6_8-branchpoint:1.58
	insight_6_8-branch:1.58.0.4
	insight_6_8-branchpoint:1.58
	reverse-20081226-branch:1.66.0.4
	reverse-20081226-branchpoint:1.66
	multiprocess-20081120-branch:1.66.0.2
	multiprocess-20081120-branchpoint:1.66
	reverse-20080930-branch:1.64.0.2
	reverse-20080930-branchpoint:1.64
	reverse-20080717-branch:1.61.0.2
	reverse-20080717-branchpoint:1.61
	msnyder-reverse-20080609-branch:1.60.0.2
	msnyder-reverse-20080609-branchpoint:1.60
	drow-reverse-20070409-branch:1.44.0.2
	drow-reverse-20070409-branchpoint:1.44
	gdb_6_8-2008-03-27-release:1.58
	gdb_6_8-branch:1.58.0.2
	gdb_6_8-2008-02-26-branchpoint:1.58
	gdb_6_7_1-2007-10-29-release:1.53
	gdb_6_7-2007-10-10-release:1.53
	gdb_6_7-branch:1.53.0.2
	gdb_6_7-2007-09-07-branchpoint:1.53
	insight_6_6-20070208-release:1.40
	gdb_6_6-2006-12-18-release:1.40
	gdb_6_6-branch:1.40.0.18
	gdb_6_6-2006-11-15-branchpoint:1.40
	insight_6_5-20061003-release:1.40
	gdb-csl-symbian-6_4_50_20060226-12:1.40
	gdb-csl-sourcerygxx-3_4_4-25:1.39
	nickrob-async-20060828-mergepoint:1.40
	gdb-csl-symbian-6_4_50_20060226-11:1.40
	gdb-csl-sourcerygxx-4_1-17:1.40
	gdb-csl-20060226-branch-local-2:1.40
	gdb-csl-sourcerygxx-4_1-14:1.40
	gdb-csl-sourcerygxx-4_1-13:1.40
	gdb-csl-sourcerygxx-4_1-12:1.40
	gdb-csl-sourcerygxx-3_4_4-21:1.40
	gdb_6_5-20060621-release:1.40
	gdb-csl-sourcerygxx-4_1-9:1.40
	gdb-csl-sourcerygxx-4_1-8:1.40
	gdb-csl-sourcerygxx-4_1-7:1.40
	gdb-csl-arm-2006q1-6:1.40
	gdb-csl-sourcerygxx-4_1-6:1.40
	gdb-csl-symbian-6_4_50_20060226-10:1.40
	gdb-csl-symbian-6_4_50_20060226-9:1.40
	gdb-csl-symbian-6_4_50_20060226-8:1.40
	gdb-csl-coldfire-4_1-11:1.40
	gdb-csl-sourcerygxx-3_4_4-19:1.40
	gdb-csl-coldfire-4_1-10:1.40
	gdb_6_5-branch:1.40.0.16
	gdb_6_5-2006-05-14-branchpoint:1.40
	gdb-csl-sourcerygxx-4_1-5:1.40
	nickrob-async-20060513-branch:1.40.0.14
	nickrob-async-20060513-branchpoint:1.40
	gdb-csl-sourcerygxx-4_1-4:1.40
	msnyder-reverse-20060502-branch:1.40.0.12
	msnyder-reverse-20060502-branchpoint:1.40
	gdb-csl-morpho-4_1-4:1.40
	gdb-csl-sourcerygxx-3_4_4-17:1.40
	readline_5_1-import-branch:1.40.0.10
	readline_5_1-import-branchpoint:1.40
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.40
	gdb-csl-symbian-20060226-branch:1.40.0.8
	gdb-csl-symbian-20060226-branchpoint:1.40
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.40
	msnyder-reverse-20060331-branch:1.40.0.6
	msnyder-reverse-20060331-branchpoint:1.40
	gdb-csl-available-20060303-branch:1.40.0.4
	gdb-csl-available-20060303-branchpoint:1.40
	gdb-csl-20060226-branch:1.40.0.2
	gdb-csl-20060226-branchpoint:1.40
	gdb_6_4-20051202-release:1.38
	msnyder-fork-checkpoint-branch:1.39.0.4
	msnyder-fork-checkpoint-branchpoint:1.39
	gdb-csl-gxxpro-6_3-branch:1.39.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.39
	gdb_6_4-branch:1.38.0.6
	gdb_6_4-2005-11-01-branchpoint:1.38
	gdb-csl-arm-20051020-branch:1.38.0.4
	gdb-csl-arm-20051020-branchpoint:1.38
	msnyder-tracepoint-checkpoint-branch:1.38.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.38
	gdb-csl-arm-20050325-2005-q1b:1.36
	gdb-csl-arm-20050325-2005-q1a:1.36
	csl-arm-20050325-branch:1.36.0.2
	csl-arm-20050325-branchpoint:1.36
	gdb-post-i18n-errorwarning-20050211:1.35
	gdb-pre-i18n-errorwarning-20050211:1.35
	gdb_6_3-20041109-release:1.32
	gdb_6_3-branch:1.32.0.2
	gdb_6_3-20041019-branchpoint:1.32
	drow_intercu-merge-20040921:1.32
	drow_intercu-merge-20040915:1.32
	jimb-gdb_6_2-e500-branch:1.29.0.6
	jimb-gdb_6_2-e500-branchpoint:1.29
	gdb_6_2-20040730-release:1.29
	gdb_6_2-branch:1.29.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.29
	gdb_6_1_1-20040616-release:1.23
	gdb_6_1-2004-04-05-release:1.23
	drow_intercu-merge-20040402:1.24
	drow_intercu-merge-20040327:1.24
	ezannoni_pie-20040323-branch:1.24.0.2
	ezannoni_pie-20040323-branchpoint:1.24
	cagney_tramp-20040321-mergepoint:1.23
	cagney_tramp-20040309-branch:1.23.0.6
	cagney_tramp-20040309-branchpoint:1.23
	gdb_6_1-branch:1.23.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.23
	drow_intercu-20040221-branch:1.23.0.2
	drow_intercu-20040221-branchpoint:1.23
	cagney_bfdfile-20040213-branch:1.21.0.2
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.20
	carlton_dictionary-20040126-merge:1.19
	cagney_bigcore-20040122-branch:1.19.0.2
	cagney_bigcore-20040122-branchpoint:1.19
	drow-cplus-merge-20040113:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-branch:1.15.0.2
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.11
	kettenis_sparc-20030918-branch:1.6.0.4
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-branch:1.6.0.2
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.2;
locks; strict;
comment	@ * @;


1.93
date	2013.09.23.09.18.44;	author aburgess;	state Exp;
branches;
next	1.92;

1.92
date	2013.09.04.16.34.07;	author aburgess;	state Exp;
branches;
next	1.91;

1.91
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.90;

1.90
date	2013.04.08.19.59.09;	author tromey;	state Exp;
branches;
next	1.89;

1.89
date	2013.03.01.15.38.26;	author palves;	state Exp;
branches;
next	1.88;

1.88
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.87;

1.87
date	2012.11.12.21.59.07;	author brobecke;	state Exp;
branches;
next	1.86;

1.86
date	2012.11.02.18.53.54;	author tromey;	state Exp;
branches;
next	1.85;

1.85
date	2012.06.06.18.03.53;	author tschwinge;	state Exp;
branches;
next	1.84;

1.84
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.83;

1.83
date	2012.05.16.14.35.07;	author macro;	state Exp;
branches;
next	1.82;

1.82
date	2012.03.01.23.55.40;	author jkratoch;	state Exp;
branches;
next	1.81;

1.81
date	2012.01.04.08.17.11;	author brobecke;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.18.18.52.32;	author palves;	state Exp;
branches
	1.80.4.1;
next	1.79;

1.79
date	2011.03.18.18.38.44;	author palves;	state Exp;
branches;
next	1.78;

1.78
date	2011.01.11.21.53.24;	author msnyder;	state Exp;
branches;
next	1.77;

1.77
date	2011.01.10.17.14.13;	author msnyder;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.01.15.33.14;	author brobecke;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.01.15.36.17;	author palves;	state Exp;
branches;
next	1.74;

1.74
date	2010.06.11.15.36.05;	author tromey;	state Exp;
branches;
next	1.73;

1.73
date	2010.04.05.22.18.53;	author muller;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.01.07.31.41;	author brobecke;	state Exp;
branches;
next	1.71;

1.71
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.70;

1.70
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.69;

1.69
date	2009.07.02.12.18.46;	author uweigand;	state Exp;
branches;
next	1.68;

1.68
date	2009.05.18.13.43.35;	author uweigand;	state Exp;
branches;
next	1.67;

1.67
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.66;

1.66
date	2008.10.28.17.19.57;	author tromey;	state Exp;
branches;
next	1.65;

1.65
date	2008.10.01.16.41.27;	author tromey;	state Exp;
branches;
next	1.64;

1.64
date	2008.09.11.14.23.15;	author uweigand;	state Exp;
branches;
next	1.63;

1.63
date	2008.09.11.14.22.32;	author uweigand;	state Exp;
branches;
next	1.62;

1.62
date	2008.09.05.11.43.10;	author uweigand;	state Exp;
branches;
next	1.61;

1.61
date	2008.06.28.17.29.03;	author uweigand;	state Exp;
branches;
next	1.60;

1.60
date	2008.05.06.21.34.59;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2008.04.22.11.03.42;	author corinna;	state Exp;
branches;
next	1.58;

1.58
date	2008.01.11.13.20.02;	author deuling;	state Exp;
branches;
next	1.57;

1.57
date	2008.01.01.22.53.13;	author drow;	state Exp;
branches;
next	1.56;

1.56
date	2007.11.07.06.33.01;	author deuling;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.02.14.27.15;	author uweigand;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.08.12.57.04;	author uweigand;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.23.18.08.38;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.18.17.56.32;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.15.22.44.56;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.15.22.31.01;	author uweigand;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.09.13.42.16;	author uweigand;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.06.15.32.25;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.31.20.57.41;	author uweigand;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.27.20.17.19;	author drow;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.27.19.46.04;	author drow;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.21.17.37.51;	author drow;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.09.17.58.58;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2005.12.17.22.34.02;	author eliz;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.02.15.22.24;	author ams;	state Exp;
branches;
next	1.38;

1.38
date	2005.05.02.15.23.37;	author corinna;	state Exp;
branches;
next	1.37;

1.37
date	2005.04.15.08.01.14;	author corinna;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.11.18.13.53;	author cagney;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.07.00.09.55;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2004.11.13.02.15.33;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2004.10.29.20.23.12;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2004.09.03.17.13.47;	author cagney;	state Exp;
branches;
next	1.31;

1.31
date	2004.08.03.02.02.23;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2004.08.02.19.44.40;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.20.17.18.06;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.10.13.22.07;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.08.21.27.02;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2004.04.30.20.44.59;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.02.23.20.49;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.22.16.58.08;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.16.21.49.22;	author cagney;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2004.02.14.15.46.33;	author ezannoni;	state Exp;
branches;
next	1.21;

1.21
date	2004.02.11.15.40.28;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.26.20.52.12;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.17.19.38.58;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.17.15.34.12;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.17.01.05.06;	author cagney;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.13.21.38.47;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.13.00.04.59;	author msnyder;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2003.11.12.22.45.41;	author msnyder;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.12.22.12.59;	author msnyder;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.11.20.04.52;	author chastain;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.10.07.13.11;	author ksakamot;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.30.13.29.44;	author cagney;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.27.15.51.02;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.25.20.44.01;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.17.14.24.30;	author cagney;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.14.16.32.14;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.12.18.40.18;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.09.15.00.23;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.08.11.26.20;	author corinna;	state Exp;
branches;
next	;

1.80.4.1
date	2012.01.06.04.43.29;	author brobecke;	state Exp;
branches;
next	;

1.23.2.1
date	2004.03.27.17.37.51;	author drow;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2004.09.16.17.01.19;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2003.12.14.20.27.30;	author drow;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2004.02.09.19.43.47;	author drow;	state Exp;
branches;
next	;

1.6.2.1
date	2003.09.17.21.28.31;	author carlton;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.11.11.23.50.54;	author carlton;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.12.16.00.00.48;	author carlton;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2004.01.26.19.11.30;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.93
log
@Reuse print_hex_chars.

  https://sourceware.org/ml/gdb-patches/2013-09/msg00768.html

gdb/ChangeLog

        * sh64-tdep.c (sh64_do_fp_register): Use print_hex_chars.
@
text
@/* Target-dependent code for Renesas Super-H, for GDB.

   Copyright (C) 1993-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* Contributed by Steve Chamberlain
   sac@@cygnus.com.  */

#include "defs.h"
#include "frame.h"
#include "frame-base.h"
#include "frame-unwind.h"
#include "dwarf2-frame.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "value.h"
#include "dis-asm.h"
#include "inferior.h"
#include "gdb_string.h"
#include "gdb_assert.h"
#include "arch-utils.h"
#include "regcache.h"
#include "osabi.h"
#include "valprint.h"

#include "elf-bfd.h"

/* sh flags */
#include "elf/sh.h"
/* Register numbers shared with the simulator.  */
#include "gdb/sim-sh.h"
#include "language.h"
#include "sh64-tdep.h"

/* Information that is dependent on the processor variant.  */
enum sh_abi
  {
    SH_ABI_UNKNOWN,
    SH_ABI_32,
    SH_ABI_64
  };

struct gdbarch_tdep
  {
    enum sh_abi sh_abi;
  };

struct sh64_frame_cache
{
  /* Base address.  */
  CORE_ADDR base;
  LONGEST sp_offset;
  CORE_ADDR pc;

  /* Flag showing that a frame has been created in the prologue code.  */
  int uses_fp;

  int media_mode;

  /* Saved registers.  */
  CORE_ADDR saved_regs[SIM_SH64_NR_REGS];
  CORE_ADDR saved_sp;
};

/* Registers of SH5 */
enum
  {
    R0_REGNUM = 0,
    DEFAULT_RETURN_REGNUM = 2,
    STRUCT_RETURN_REGNUM = 2,
    ARG0_REGNUM = 2,
    ARGLAST_REGNUM = 9,
    FLOAT_ARGLAST_REGNUM = 11,
    MEDIA_FP_REGNUM = 14,
    PR_REGNUM = 18,
    SR_REGNUM = 65,
    DR0_REGNUM = 141,
    DR_LAST_REGNUM = 172,
    /* FPP stands for Floating Point Pair, to avoid confusion with
       GDB's gdbarch_fp0_regnum, which is the number of the first Floating
       point register.  Unfortunately on the sh5, the floating point
       registers are called FR, and the floating point pairs are called FP.  */
    FPP0_REGNUM = 173,
    FPP_LAST_REGNUM = 204,
    FV0_REGNUM = 205,
    FV_LAST_REGNUM = 220,
    R0_C_REGNUM = 221,
    R_LAST_C_REGNUM = 236,
    PC_C_REGNUM = 237,
    GBR_C_REGNUM = 238,
    MACH_C_REGNUM = 239,
    MACL_C_REGNUM = 240,
    PR_C_REGNUM = 241,
    T_C_REGNUM = 242,
    FPSCR_C_REGNUM = 243,
    FPUL_C_REGNUM = 244,
    FP0_C_REGNUM = 245,
    FP_LAST_C_REGNUM = 260,
    DR0_C_REGNUM = 261,
    DR_LAST_C_REGNUM = 268,
    FV0_C_REGNUM = 269,
    FV_LAST_C_REGNUM = 272,
    FPSCR_REGNUM = SIM_SH64_FPCSR_REGNUM,
    SSR_REGNUM = SIM_SH64_SSR_REGNUM,
    SPC_REGNUM = SIM_SH64_SPC_REGNUM,
    TR7_REGNUM = SIM_SH64_TR0_REGNUM + 7,
    FP_LAST_REGNUM = SIM_SH64_FR0_REGNUM + SIM_SH64_NR_FP_REGS - 1
  };

static const char *
sh64_register_name (struct gdbarch *gdbarch, int reg_nr)
{
  static char *register_names[] =
  {
    /* SH MEDIA MODE (ISA 32) */
    /* general registers (64-bit) 0-63 */
    "r0",   "r1",   "r2",   "r3",   "r4",   "r5",   "r6",   "r7",
    "r8",   "r9",   "r10",  "r11",  "r12",  "r13",  "r14",  "r15",
    "r16",  "r17",  "r18",  "r19",  "r20",  "r21",  "r22",  "r23",
    "r24",  "r25",  "r26",  "r27",  "r28",  "r29",  "r30",  "r31",
    "r32",  "r33",  "r34",  "r35",  "r36",  "r37",  "r38",  "r39",
    "r40",  "r41",  "r42",  "r43",  "r44",  "r45",  "r46",  "r47",
    "r48",  "r49",  "r50",  "r51",  "r52",  "r53",  "r54",  "r55",
    "r56",  "r57",  "r58",  "r59",  "r60",  "r61",  "r62",  "r63",

    /* pc (64-bit) 64 */
    "pc",   

    /* status reg., saved status reg., saved pc reg. (64-bit) 65-67 */
    "sr",  "ssr",  "spc", 

    /* target registers (64-bit) 68-75 */
    "tr0",  "tr1",  "tr2",  "tr3",  "tr4",  "tr5",  "tr6",  "tr7",

    /* floating point state control register (32-bit) 76 */
    "fpscr",

    /* single precision floating point registers (32-bit) 77-140 */
    "fr0",  "fr1",  "fr2",  "fr3",  "fr4",  "fr5",  "fr6",  "fr7",
    "fr8",  "fr9",  "fr10", "fr11", "fr12", "fr13", "fr14", "fr15",
    "fr16", "fr17", "fr18", "fr19", "fr20", "fr21", "fr22", "fr23",
    "fr24", "fr25", "fr26", "fr27", "fr28", "fr29", "fr30", "fr31",
    "fr32", "fr33", "fr34", "fr35", "fr36", "fr37", "fr38", "fr39",
    "fr40", "fr41", "fr42", "fr43", "fr44", "fr45", "fr46", "fr47",
    "fr48", "fr49", "fr50", "fr51", "fr52", "fr53", "fr54", "fr55",
    "fr56", "fr57", "fr58", "fr59", "fr60", "fr61", "fr62", "fr63",

    /* double precision registers (pseudo) 141-172 */
    "dr0",  "dr2",  "dr4",  "dr6",  "dr8",  "dr10", "dr12", "dr14",
    "dr16", "dr18", "dr20", "dr22", "dr24", "dr26", "dr28", "dr30",
    "dr32", "dr34", "dr36", "dr38", "dr40", "dr42", "dr44", "dr46",
    "dr48", "dr50", "dr52", "dr54", "dr56", "dr58", "dr60", "dr62",

    /* floating point pairs (pseudo) 173-204 */
    "fp0",  "fp2",  "fp4",  "fp6",  "fp8",  "fp10", "fp12", "fp14",
    "fp16", "fp18", "fp20", "fp22", "fp24", "fp26", "fp28", "fp30",
    "fp32", "fp34", "fp36", "fp38", "fp40", "fp42", "fp44", "fp46",
    "fp48", "fp50", "fp52", "fp54", "fp56", "fp58", "fp60", "fp62",

    /* floating point vectors (4 floating point regs) (pseudo) 205-220 */
    "fv0",  "fv4",  "fv8",  "fv12", "fv16", "fv20", "fv24", "fv28",
    "fv32", "fv36", "fv40", "fv44", "fv48", "fv52", "fv56", "fv60",

    /* SH COMPACT MODE (ISA 16) (all pseudo) 221-272 */
    "r0_c", "r1_c", "r2_c",  "r3_c",  "r4_c",  "r5_c",  "r6_c",  "r7_c",
    "r8_c", "r9_c", "r10_c", "r11_c", "r12_c", "r13_c", "r14_c", "r15_c",
    "pc_c",
    "gbr_c", "mach_c", "macl_c", "pr_c", "t_c",
    "fpscr_c", "fpul_c",
    "fr0_c",  "fr1_c",  "fr2_c",  "fr3_c",
    "fr4_c",  "fr5_c",  "fr6_c",  "fr7_c",
    "fr8_c",  "fr9_c",  "fr10_c", "fr11_c",
    "fr12_c", "fr13_c", "fr14_c", "fr15_c",
    "dr0_c",  "dr2_c",  "dr4_c",  "dr6_c",
    "dr8_c",  "dr10_c", "dr12_c", "dr14_c",
    "fv0_c", "fv4_c", "fv8_c",  "fv12_c",
    /* FIXME!!!! XF0 XF15, XD0 XD14 ?????  */
  };

  if (reg_nr < 0)
    return NULL;
  if (reg_nr >= (sizeof (register_names) / sizeof (*register_names)))
    return NULL;
  return register_names[reg_nr];
}

#define NUM_PSEUDO_REGS_SH_MEDIA 80
#define NUM_PSEUDO_REGS_SH_COMPACT 51

/* Macros and functions for setting and testing a bit in a minimal
   symbol that marks it as 32-bit function.  The MSB of the minimal
   symbol's "info" field is used for this purpose.

   gdbarch_elf_make_msymbol_special tests whether an ELF symbol is "special",
   i.e. refers to a 32-bit function, and sets a "special" bit in a
   minimal symbol to mark it as a 32-bit function
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol  */

#define MSYMBOL_IS_SPECIAL(msym) \
  MSYMBOL_TARGET_FLAG_1 (msym)

static void
sh64_elf_make_msymbol_special (asymbol *sym, struct minimal_symbol *msym)
{
  if (msym == NULL)
    return;

  if (((elf_symbol_type *)(sym))->internal_elf_sym.st_other == STO_SH5_ISA32)
    {
      MSYMBOL_TARGET_FLAG_1 (msym) = 1;
      SYMBOL_VALUE_ADDRESS (msym) |= 1;
    }
}

/* ISA32 (shmedia) function addresses are odd (bit 0 is set).  Here
   are some macros to test, set, or clear bit 0 of addresses.  */
#define IS_ISA32_ADDR(addr)	 ((addr) & 1)
#define MAKE_ISA32_ADDR(addr)	 ((addr) | 1)
#define UNMAKE_ISA32_ADDR(addr)  ((addr) & ~1)

static int
pc_is_isa32 (bfd_vma memaddr)
{
  struct bound_minimal_symbol sym;

  /* If bit 0 of the address is set, assume this is a
     ISA32 (shmedia) address.  */
  if (IS_ISA32_ADDR (memaddr))
    return 1;

  /* A flag indicating that this is a ISA32 function is stored by elfread.c in
     the high bit of the info field.  Use this to decide if the function is
     ISA16 or ISA32.  */
  sym = lookup_minimal_symbol_by_pc (memaddr);
  if (sym.minsym)
    return MSYMBOL_IS_SPECIAL (sym.minsym);
  else
    return 0;
}

static const unsigned char *
sh64_breakpoint_from_pc (struct gdbarch *gdbarch,
			 CORE_ADDR *pcptr, int *lenptr)
{
  /* The BRK instruction for shmedia is 
     01101111 11110101 11111111 11110000
     which translates in big endian mode to 0x6f, 0xf5, 0xff, 0xf0
     and in little endian mode to 0xf0, 0xff, 0xf5, 0x6f */

  /* The BRK instruction for shcompact is
     00000000 00111011
     which translates in big endian mode to 0x0, 0x3b
     and in little endian mode to 0x3b, 0x0 */

  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
    {
      if (pc_is_isa32 (*pcptr))
	{
	  static unsigned char big_breakpoint_media[] = {
	    0x6f, 0xf5, 0xff, 0xf0
	  };
	  *pcptr = UNMAKE_ISA32_ADDR (*pcptr);
	  *lenptr = sizeof (big_breakpoint_media);
	  return big_breakpoint_media;
	}
      else
	{
	  static unsigned char big_breakpoint_compact[] = {0x0, 0x3b};
	  *lenptr = sizeof (big_breakpoint_compact);
	  return big_breakpoint_compact;
	}
    }
  else
    {
      if (pc_is_isa32 (*pcptr))
	{
	  static unsigned char little_breakpoint_media[] = {
	    0xf0, 0xff, 0xf5, 0x6f
	  };
	  *pcptr = UNMAKE_ISA32_ADDR (*pcptr);
	  *lenptr = sizeof (little_breakpoint_media);
	  return little_breakpoint_media;
	}
      else
	{
	  static unsigned char little_breakpoint_compact[] = {0x3b, 0x0};
	  *lenptr = sizeof (little_breakpoint_compact);
	  return little_breakpoint_compact;
	}
    }
}

/* Prologue looks like
   [mov.l       <regs>,@@-r15]...
   [sts.l       pr,@@-r15]
   [mov.l       r14,@@-r15]
   [mov         r15,r14]

   Actually it can be more complicated than this.  For instance, with
   newer gcc's:

   mov.l   r14,@@-r15
   add     #-12,r15
   mov     r15,r14
   mov     r4,r1
   mov     r5,r2
   mov.l   r6,@@(4,r14)
   mov.l   r7,@@(8,r14)
   mov.b   r1,@@r14
   mov     r14,r1
   mov     r14,r1
   add     #2,r1
   mov.w   r2,@@r1

 */

/* PTABS/L Rn, TRa       0110101111110001nnnnnnl00aaa0000 
   with l=1 and n = 18   0110101111110001010010100aaa0000 */
#define IS_PTABSL_R18(x)  (((x) & 0xffffff8f) == 0x6bf14a00)

/* STS.L PR,@@-r0   0100000000100010
   r0-4-->r0, PR-->(r0) */
#define IS_STS_R0(x)  		((x) == 0x4022)

/* STS PR, Rm      0000mmmm00101010
   PR-->Rm */
#define IS_STS_PR(x)            (((x) & 0xf0ff) == 0x2a)

/* MOV.L Rm,@@(disp,r15)  00011111mmmmdddd
   Rm-->(dispx4+r15) */
#define IS_MOV_TO_R15(x)              (((x) & 0xff00) == 0x1f00)

/* MOV.L R14,@@(disp,r15)  000111111110dddd
   R14-->(dispx4+r15) */
#define IS_MOV_R14(x)              (((x) & 0xfff0) == 0x1fe0)

/* ST.Q R14, disp, R18    101011001110dddddddddd0100100000
   R18-->(dispx8+R14) */
#define IS_STQ_R18_R14(x)          (((x) & 0xfff003ff) == 0xace00120)

/* ST.Q R15, disp, R18    101011001111dddddddddd0100100000
   R18-->(dispx8+R15) */
#define IS_STQ_R18_R15(x)          (((x) & 0xfff003ff) == 0xacf00120)

/* ST.L R15, disp, R18    101010001111dddddddddd0100100000
   R18-->(dispx4+R15) */
#define IS_STL_R18_R15(x)          (((x) & 0xfff003ff) == 0xa8f00120)

/* ST.Q R15, disp, R14    1010 1100 1111 dddd dddd dd00 1110 0000
   R14-->(dispx8+R15) */
#define IS_STQ_R14_R15(x)          (((x) & 0xfff003ff) == 0xacf000e0)

/* ST.L R15, disp, R14    1010 1000 1111 dddd dddd dd00 1110 0000
   R14-->(dispx4+R15) */
#define IS_STL_R14_R15(x)          (((x) & 0xfff003ff) == 0xa8f000e0)

/* ADDI.L R15,imm,R15     1101 0100 1111 ssss ssss ss00 1111 0000
   R15 + imm --> R15 */
#define IS_ADDIL_SP_MEDIA(x)         (((x) & 0xfff003ff) == 0xd4f000f0)

/* ADDI R15,imm,R15     1101 0000 1111 ssss ssss ss00 1111 0000
   R15 + imm --> R15 */
#define IS_ADDI_SP_MEDIA(x)         (((x) & 0xfff003ff) == 0xd0f000f0)

/* ADD.L R15,R63,R14    0000 0000 1111 1000 1111 1100 1110 0000 
   R15 + R63 --> R14 */
#define IS_ADDL_SP_FP_MEDIA(x)  	((x) == 0x00f8fce0)

/* ADD R15,R63,R14    0000 0000 1111 1001 1111 1100 1110 0000 
   R15 + R63 --> R14 */
#define IS_ADD_SP_FP_MEDIA(x)  	((x) == 0x00f9fce0)

#define IS_MOV_SP_FP_MEDIA(x)  	\
  (IS_ADDL_SP_FP_MEDIA(x) || IS_ADD_SP_FP_MEDIA(x))

/* MOV #imm, R0    1110 0000 ssss ssss 
   #imm-->R0 */
#define IS_MOV_R0(x) 		(((x) & 0xff00) == 0xe000)

/* MOV.L @@(disp,PC), R0    1101 0000 iiii iiii  */
#define IS_MOVL_R0(x) 		(((x) & 0xff00) == 0xd000)

/* ADD r15,r0      0011 0000 1111 1100
   r15+r0-->r0 */
#define IS_ADD_SP_R0(x)	        ((x) == 0x30fc)

/* MOV.L R14 @@-R0  0010 0000 1110 0110
   R14-->(R0-4), R0-4-->R0 */
#define IS_MOV_R14_R0(x)        ((x) == 0x20e6)

/* ADD Rm,R63,Rn  Rm+R63-->Rn  0000 00mm mmmm 1001 1111 11nn nnnn 0000
   where Rm is one of r2-r9 which are the argument registers.  */
/* FIXME: Recognize the float and double register moves too!  */
#define IS_MEDIA_IND_ARG_MOV(x) \
  ((((x) & 0xfc0ffc0f) == 0x0009fc00) \
   && (((x) & 0x03f00000) >= 0x00200000 \
       && ((x) & 0x03f00000) <= 0x00900000))

/* ST.Q Rn,0,Rm  Rm-->Rn+0  1010 11nn nnnn 0000 0000 00mm mmmm 0000
   or ST.L Rn,0,Rm  Rm-->Rn+0  1010 10nn nnnn 0000 0000 00mm mmmm 0000
   where Rm is one of r2-r9 which are the argument registers.  */
#define IS_MEDIA_ARG_MOV(x) \
(((((x) & 0xfc0ffc0f) == 0xac000000) || (((x) & 0xfc0ffc0f) == 0xa8000000)) \
   && (((x) & 0x000003f0) >= 0x00000020 && ((x) & 0x000003f0) <= 0x00000090))

/* ST.B R14,0,Rn     Rn-->(R14+0) 1010 0000 1110 0000 0000 00nn nnnn 0000 */
/* ST.W R14,0,Rn     Rn-->(R14+0) 1010 0100 1110 0000 0000 00nn nnnn 0000 */
/* ST.L R14,0,Rn     Rn-->(R14+0) 1010 1000 1110 0000 0000 00nn nnnn 0000 */
/* FST.S R14,0,FRn   Rn-->(R14+0) 1011 0100 1110 0000 0000 00nn nnnn 0000 */
/* FST.D R14,0,DRn   Rn-->(R14+0) 1011 1100 1110 0000 0000 00nn nnnn 0000 */
#define IS_MEDIA_MOV_TO_R14(x)  \
((((x) & 0xfffffc0f) == 0xa0e00000) \
|| (((x) & 0xfffffc0f) == 0xa4e00000) \
|| (((x) & 0xfffffc0f) == 0xa8e00000) \
|| (((x) & 0xfffffc0f) == 0xb4e00000) \
|| (((x) & 0xfffffc0f) == 0xbce00000))

/* MOV Rm, Rn  Rm-->Rn 0110 nnnn mmmm 0011
   where Rm is r2-r9 */
#define IS_COMPACT_IND_ARG_MOV(x) \
  ((((x) & 0xf00f) == 0x6003) && (((x) & 0x00f0) >= 0x0020) \
   && (((x) & 0x00f0) <= 0x0090))

/* compact direct arg move! 
   MOV.L Rn, @@r14     0010 1110 mmmm 0010 */
#define IS_COMPACT_ARG_MOV(x) \
  (((((x) & 0xff0f) == 0x2e02) && (((x) & 0x00f0) >= 0x0020) \
    && ((x) & 0x00f0) <= 0x0090))

/* MOV.B Rm, @@R14     0010 1110 mmmm 0000 
   MOV.W Rm, @@R14     0010 1110 mmmm 0001 */
#define IS_COMPACT_MOV_TO_R14(x) \
((((x) & 0xff0f) == 0x2e00) || (((x) & 0xff0f) == 0x2e01))

#define IS_JSR_R0(x)           ((x) == 0x400b)
#define IS_NOP(x)              ((x) == 0x0009)


/* MOV r15,r14     0110111011110011
   r15-->r14  */
#define IS_MOV_SP_FP(x)  	((x) == 0x6ef3)

/* ADD #imm,r15    01111111iiiiiiii
   r15+imm-->r15 */
#define IS_ADD_SP(x) 		(((x) & 0xff00) == 0x7f00)

/* Skip any prologue before the guts of a function.  */

/* Skip the prologue using the debug information.  If this fails we'll
   fall back on the 'guess' method below.  */
static CORE_ADDR
after_prologue (CORE_ADDR pc)
{
  struct symtab_and_line sal;
  CORE_ADDR func_addr, func_end;

  /* If we can not find the symbol in the partial symbol table, then
     there is no hope we can determine the function's start address
     with this code.  */
  if (!find_pc_partial_function (pc, NULL, &func_addr, &func_end))
    return 0;


  /* Get the line associated with FUNC_ADDR.  */
  sal = find_pc_line (func_addr, 0);

  /* There are only two cases to consider.  First, the end of the source line
     is within the function bounds.  In that case we return the end of the
     source line.  Second is the end of the source line extends beyond the
     bounds of the current function.  We need to use the slow code to
     examine instructions in that case.  */
  if (sal.end < func_end)
    return sal.end;
  else
    return 0;
}

static CORE_ADDR 
look_for_args_moves (struct gdbarch *gdbarch,
		     CORE_ADDR start_pc, int media_mode)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR here, end;
  int w;
  int insn_size = (media_mode ? 4 : 2);

  for (here = start_pc, end = start_pc + (insn_size * 28); here < end;)
    {
      if (media_mode)
	{
	  w = read_memory_integer (UNMAKE_ISA32_ADDR (here),
				   insn_size, byte_order);
	  here += insn_size;
	  if (IS_MEDIA_IND_ARG_MOV (w))
	    {
	      /* This must be followed by a store to r14, so the argument
		 is where the debug info says it is.  This can happen after
		 the SP has been saved, unfortunately.  */
	 
	      int next_insn = read_memory_integer (UNMAKE_ISA32_ADDR (here),
						   insn_size, byte_order);
	      here += insn_size;
	      if (IS_MEDIA_MOV_TO_R14 (next_insn))
		start_pc = here;	  
	    }
	  else if (IS_MEDIA_ARG_MOV (w))
	    {
	      /* These instructions store directly the argument in r14.  */
	      start_pc = here;
	    }
	  else
	    break;
	}
      else
	{
	  w = read_memory_integer (here, insn_size, byte_order);
	  w = w & 0xffff;
	  here += insn_size;
	  if (IS_COMPACT_IND_ARG_MOV (w))
	    {
	      /* This must be followed by a store to r14, so the argument
		 is where the debug info says it is.  This can happen after
		 the SP has been saved, unfortunately.  */
	 
	      int next_insn = 0xffff & read_memory_integer (here, insn_size,
							    byte_order);
	      here += insn_size;
	      if (IS_COMPACT_MOV_TO_R14 (next_insn))
		start_pc = here;
	    }
	  else if (IS_COMPACT_ARG_MOV (w))
	    {
	      /* These instructions store directly the argument in r14.  */
	      start_pc = here;
	    }
	  else if (IS_MOVL_R0 (w))
	    {
	      /* There is a function that gcc calls to get the arguments
		 passed correctly to the function.  Only after this
		 function call the arguments will be found at the place
		 where they are supposed to be.  This happens in case the
		 argument has to be stored into a 64-bit register (for
		 instance doubles, long longs).  SHcompact doesn't have
		 access to the full 64-bits, so we store the register in
		 stack slot and store the address of the stack slot in
		 the register, then do a call through a wrapper that
		 loads the memory value into the register.  A SHcompact
		 callee calls an argument decoder
		 (GCC_shcompact_incoming_args) that stores the 64-bit
		 value in a stack slot and stores the address of the
		 stack slot in the register.  GCC thinks the argument is
		 just passed by transparent reference, but this is only
		 true after the argument decoder is called.  Such a call
		 needs to be considered part of the prologue.  */

	      /* This must be followed by a JSR @@r0 instruction and by
                 a NOP instruction.  After these, the prologue is over!  */
	 
	      int next_insn = 0xffff & read_memory_integer (here, insn_size,
							    byte_order);
	      here += insn_size;
	      if (IS_JSR_R0 (next_insn))
		{
		  next_insn = 0xffff & read_memory_integer (here, insn_size,
							    byte_order);
		  here += insn_size;

		  if (IS_NOP (next_insn))
		    start_pc = here;
		}
	    }
	  else
	    break;
	}
    }

  return start_pc;
}

static CORE_ADDR
sh64_skip_prologue_hard_way (struct gdbarch *gdbarch, CORE_ADDR start_pc)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  CORE_ADDR here, end;
  int updated_fp = 0;
  int insn_size = 4;
  int media_mode = 1;

  if (!start_pc)
    return 0;

  if (pc_is_isa32 (start_pc) == 0)
    {
      insn_size = 2;
      media_mode = 0;
    }

  for (here = start_pc, end = start_pc + (insn_size * 28); here < end;)
    {

      if (media_mode)
	{
	  int w = read_memory_integer (UNMAKE_ISA32_ADDR (here),
				       insn_size, byte_order);
	  here += insn_size;
	  if (IS_STQ_R18_R14 (w) || IS_STQ_R18_R15 (w) || IS_STQ_R14_R15 (w)
	      || IS_STL_R14_R15 (w) || IS_STL_R18_R15 (w)
	      || IS_ADDIL_SP_MEDIA (w) || IS_ADDI_SP_MEDIA (w)
	      || IS_PTABSL_R18 (w))
	    {
	      start_pc = here;
	    }
	  else if (IS_MOV_SP_FP (w) || IS_MOV_SP_FP_MEDIA(w))
	    {
	      start_pc = here;
	      updated_fp = 1;
	    }
	  else
	    if (updated_fp)
	      {
		/* Don't bail out yet, we may have arguments stored in
		   registers here, according to the debug info, so that
		   gdb can print the frames correctly.  */
		start_pc = look_for_args_moves (gdbarch,
						here - insn_size, media_mode);
		break;
	      }
	}
      else
	{
	  int w = 0xffff & read_memory_integer (here, insn_size, byte_order);
	  here += insn_size;

	  if (IS_STS_R0 (w) || IS_STS_PR (w)
	      || IS_MOV_TO_R15 (w) || IS_MOV_R14 (w) 
	      || IS_MOV_R0 (w) || IS_ADD_SP_R0 (w) || IS_MOV_R14_R0 (w))
	    {
	      start_pc = here;
	    }
	  else if (IS_MOV_SP_FP (w))
	    {
	      start_pc = here;
	      updated_fp = 1;
	    }
	  else
	    if (updated_fp)
	      {
		/* Don't bail out yet, we may have arguments stored in
		   registers here, according to the debug info, so that
		   gdb can print the frames correctly.  */
		start_pc = look_for_args_moves (gdbarch,
						here - insn_size, media_mode);
		break;
	      }
	}
    }

  return start_pc;
}

static CORE_ADDR
sh64_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)
{
  CORE_ADDR post_prologue_pc;

  /* See if we can determine the end of the prologue via the symbol table.
     If so, then return either PC, or the PC after the prologue, whichever
     is greater.  */
  post_prologue_pc = after_prologue (pc);

  /* If after_prologue returned a useful address, then use it.  Else
     fall back on the instruction skipping code.  */
  if (post_prologue_pc != 0)
    return max (pc, post_prologue_pc);
  else
    return sh64_skip_prologue_hard_way (gdbarch, pc);
}

/* Should call_function allocate stack space for a struct return?  */
static int
sh64_use_struct_convention (struct type *type)
{
  return (TYPE_LENGTH (type) > 8);
}

/* For vectors of 4 floating point registers.  */
static int
sh64_fv_reg_base_num (struct gdbarch *gdbarch, int fv_regnum)
{
  int fp_regnum;

  fp_regnum = gdbarch_fp0_regnum (gdbarch) + (fv_regnum - FV0_REGNUM) * 4;
  return fp_regnum;
}

/* For double precision floating point registers, i.e 2 fp regs.  */
static int
sh64_dr_reg_base_num (struct gdbarch *gdbarch, int dr_regnum)
{
  int fp_regnum;

  fp_regnum = gdbarch_fp0_regnum (gdbarch) + (dr_regnum - DR0_REGNUM) * 2;
  return fp_regnum;
}

/* For pairs of floating point registers.  */
static int
sh64_fpp_reg_base_num (struct gdbarch *gdbarch, int fpp_regnum)
{
  int fp_regnum;

  fp_regnum = gdbarch_fp0_regnum (gdbarch) + (fpp_regnum - FPP0_REGNUM) * 2;
  return fp_regnum;
}

/* *INDENT-OFF* */
/*
    SH COMPACT MODE (ISA 16) (all pseudo) 221-272
       GDB_REGNUM  BASE_REGNUM
 r0_c       221      0
 r1_c       222      1
 r2_c       223      2
 r3_c       224      3
 r4_c       225      4
 r5_c       226      5
 r6_c       227      6
 r7_c       228      7
 r8_c       229      8
 r9_c       230      9
 r10_c      231      10
 r11_c      232      11
 r12_c      233      12
 r13_c      234      13
 r14_c      235      14
 r15_c      236      15

 pc_c       237      64
 gbr_c      238      16
 mach_c     239      17
 macl_c     240      17
 pr_c       241      18
 t_c        242      19
 fpscr_c    243      76
 fpul_c     244      109

 fr0_c      245      77
 fr1_c      246      78
 fr2_c      247      79
 fr3_c      248      80
 fr4_c      249      81
 fr5_c      250      82
 fr6_c      251      83
 fr7_c      252      84
 fr8_c      253      85
 fr9_c      254      86
 fr10_c     255      87
 fr11_c     256      88
 fr12_c     257      89
 fr13_c     258      90
 fr14_c     259      91
 fr15_c     260      92

 dr0_c      261      77
 dr2_c      262      79
 dr4_c      263      81
 dr6_c      264      83
 dr8_c      265      85
 dr10_c     266      87
 dr12_c     267      89
 dr14_c     268      91

 fv0_c      269      77
 fv4_c      270      81
 fv8_c      271      85
 fv12_c     272      91
*/
/* *INDENT-ON* */
static int
sh64_compact_reg_base_num (struct gdbarch *gdbarch, int reg_nr)
{
  int base_regnum = reg_nr;

  /* general register N maps to general register N */
  if (reg_nr >= R0_C_REGNUM 
      && reg_nr <= R_LAST_C_REGNUM)
    base_regnum = reg_nr - R0_C_REGNUM;

  /* floating point register N maps to floating point register N */
  else if (reg_nr >= FP0_C_REGNUM 
	    && reg_nr <= FP_LAST_C_REGNUM)
    base_regnum = reg_nr - FP0_C_REGNUM + gdbarch_fp0_regnum (gdbarch);

  /* double prec register N maps to base regnum for double prec register N */
  else if (reg_nr >= DR0_C_REGNUM 
	    && reg_nr <= DR_LAST_C_REGNUM)
    base_regnum = sh64_dr_reg_base_num (gdbarch,
					DR0_REGNUM + reg_nr - DR0_C_REGNUM);

  /* vector N maps to base regnum for vector register N */
  else if (reg_nr >= FV0_C_REGNUM 
	    && reg_nr <= FV_LAST_C_REGNUM)
    base_regnum = sh64_fv_reg_base_num (gdbarch,
					FV0_REGNUM + reg_nr - FV0_C_REGNUM);

  else if (reg_nr == PC_C_REGNUM)
    base_regnum = gdbarch_pc_regnum (gdbarch);

  else if (reg_nr == GBR_C_REGNUM) 
    base_regnum = 16;

  else if (reg_nr == MACH_C_REGNUM
	   || reg_nr == MACL_C_REGNUM)
    base_regnum = 17;

  else if (reg_nr == PR_C_REGNUM) 
    base_regnum = PR_REGNUM;

  else if (reg_nr == T_C_REGNUM) 
    base_regnum = 19;

  else if (reg_nr == FPSCR_C_REGNUM) 
    base_regnum = FPSCR_REGNUM; /*???? this register is a mess.  */

  else if (reg_nr == FPUL_C_REGNUM) 
    base_regnum = gdbarch_fp0_regnum (gdbarch) + 32;
  
  return base_regnum;
}

static int
sign_extend (int value, int bits)
{
  value = value & ((1 << bits) - 1);
  return (value & (1 << (bits - 1))
	  ? value | (~((1 << bits) - 1))
	  : value);
}

static void
sh64_analyze_prologue (struct gdbarch *gdbarch,
		       struct sh64_frame_cache *cache,
		       CORE_ADDR func_pc,
		       CORE_ADDR current_pc)
{
  int pc;
  int opc;
  int insn;
  int r0_val = 0;
  int insn_size;
  int gdb_register_number;
  int register_number;
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  
  cache->sp_offset = 0;

  /* Loop around examining the prologue insns until we find something
     that does not appear to be part of the prologue.  But give up
     after 20 of them, since we're getting silly then.  */

  pc = func_pc;

  if (cache->media_mode)
    insn_size = 4;
  else
    insn_size = 2;

  opc = pc + (insn_size * 28);
  if (opc > current_pc)
    opc = current_pc;
  for ( ; pc <= opc; pc += insn_size)
    {
      insn = read_memory_integer (cache->media_mode ? UNMAKE_ISA32_ADDR (pc)
						    : pc,
				  insn_size, byte_order);

      if (!cache->media_mode)
	{
	  if (IS_STS_PR (insn))
	    {
	      int next_insn = read_memory_integer (pc + insn_size,
						   insn_size, byte_order);
	      if (IS_MOV_TO_R15 (next_insn))
		{
		  cache->saved_regs[PR_REGNUM]
		    = cache->sp_offset - ((((next_insn & 0xf) ^ 0x8)
					   - 0x8) << 2);
		  pc += insn_size;
		}
	    }

	  else if (IS_MOV_R14 (insn))
	    cache->saved_regs[MEDIA_FP_REGNUM] =
	      cache->sp_offset - ((((insn & 0xf) ^ 0x8) - 0x8) << 2);

	  else if (IS_MOV_R0 (insn))
	    {
	      /* Put in R0 the offset from SP at which to store some
		 registers.  We are interested in this value, because it
		 will tell us where the given registers are stored within
		 the frame.  */
	      r0_val = ((insn & 0xff) ^ 0x80) - 0x80;
	    }

	  else if (IS_ADD_SP_R0 (insn))
	    {
	      /* This instruction still prepares r0, but we don't care.
		 We already have the offset in r0_val.  */
	    }

	  else if (IS_STS_R0 (insn))
	    {
	      /* Store PR at r0_val-4 from SP.  Decrement r0 by 4.  */
	      cache->saved_regs[PR_REGNUM] = cache->sp_offset - (r0_val - 4);
	      r0_val -= 4;
	    }

	  else if (IS_MOV_R14_R0 (insn))
	    {
	      /* Store R14 at r0_val-4 from SP.  Decrement r0 by 4.  */
	      cache->saved_regs[MEDIA_FP_REGNUM] = cache->sp_offset
	      					   - (r0_val - 4);
	      r0_val -= 4;
	    }

	  else if (IS_ADD_SP (insn))
	    cache->sp_offset -= ((insn & 0xff) ^ 0x80) - 0x80;

	  else if (IS_MOV_SP_FP (insn))
	    break;
	}
      else
	{
	  if (IS_ADDIL_SP_MEDIA (insn) || IS_ADDI_SP_MEDIA (insn))
	    cache->sp_offset -=
	      sign_extend ((((insn & 0xffc00) ^ 0x80000) - 0x80000) >> 10, 9);

	  else if (IS_STQ_R18_R15 (insn))
	    cache->saved_regs[PR_REGNUM]
	      = cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10,
						 9) << 3);

	  else if (IS_STL_R18_R15 (insn))
	    cache->saved_regs[PR_REGNUM]
	      = cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10,
						 9) << 2);

	  else if (IS_STQ_R14_R15 (insn))
	    cache->saved_regs[MEDIA_FP_REGNUM]
	      = cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10,
						 9) << 3);

	  else if (IS_STL_R14_R15 (insn))
	    cache->saved_regs[MEDIA_FP_REGNUM]
	      = cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10,
						 9) << 2);

	  else if (IS_MOV_SP_FP_MEDIA (insn))
	    break;
	}
    }

  if (cache->saved_regs[MEDIA_FP_REGNUM] >= 0)
    cache->uses_fp = 1;
}

static CORE_ADDR
sh64_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
{
  return sp & ~7;
}

/* Function: push_dummy_call
   Setup the function arguments for calling a function in the inferior.

   On the Renesas SH architecture, there are four registers (R4 to R7)
   which are dedicated for passing function arguments.  Up to the first
   four arguments (depending on size) may go into these registers.
   The rest go on the stack.

   Arguments that are smaller than 4 bytes will still take up a whole
   register or a whole 32-bit word on the stack, and will be 
   right-justified in the register or the stack word.  This includes
   chars, shorts, and small aggregate types.

   Arguments that are larger than 4 bytes may be split between two or 
   more registers.  If there are not enough registers free, an argument
   may be passed partly in a register (or registers), and partly on the
   stack.  This includes doubles, long longs, and larger aggregates.
   As far as I know, there is no upper limit to the size of aggregates 
   that will be passed in this way; in other words, the convention of 
   passing a pointer to a large aggregate instead of a copy is not used.

   An exceptional case exists for struct arguments (and possibly other
   aggregates such as arrays) if the size is larger than 4 bytes but 
   not a multiple of 4 bytes.  In this case the argument is never split 
   between the registers and the stack, but instead is copied in its
   entirety onto the stack, AND also copied into as many registers as 
   there is room for.  In other words, space in registers permitting, 
   two copies of the same argument are passed in.  As far as I can tell,
   only the one on the stack is used, although that may be a function 
   of the level of compiler optimization.  I suspect this is a compiler
   bug.  Arguments of these odd sizes are left-justified within the 
   word (as opposed to arguments smaller than 4 bytes, which are 
   right-justified).

   If the function is to return an aggregate type such as a struct, it 
   is either returned in the normal return value register R0 (if its 
   size is no greater than one byte), or else the caller must allocate
   space into which the callee will copy the return value (if the size
   is greater than one byte).  In this case, a pointer to the return 
   value location is passed into the callee in register R2, which does 
   not displace any of the other arguments passed in via registers R4
   to R7.  */

/* R2-R9 for integer types and integer equivalent (char, pointers) and
   non-scalar (struct, union) elements (even if the elements are
   floats).  
   FR0-FR11 for single precision floating point (float)
   DR0-DR10 for double precision floating point (double) 
   
   If a float is argument number 3 (for instance) and arguments number
   1,2, and 4 are integer, the mapping will be:
   arg1 -->R2, arg2 --> R3, arg3 -->FR0, arg4 --> R5.  I.e. R4 is not used.
   
   If a float is argument number 10 (for instance) and arguments number
   1 through 10 are integer, the mapping will be:
   arg1->R2, arg2->R3, arg3->R4, arg4->R5, arg5->R6, arg6->R7, arg7->R8,
   arg8->R9, arg9->(0,SP)stack(8-byte aligned), arg10->FR0,
   arg11->stack(16,SP).  I.e. there is hole in the stack.

   Different rules apply for variable arguments functions, and for functions
   for which the prototype is not known.  */

static CORE_ADDR
sh64_push_dummy_call (struct gdbarch *gdbarch,
		      struct value *function,
		      struct regcache *regcache,
		      CORE_ADDR bp_addr,
		      int nargs, struct value **args,
		      CORE_ADDR sp, int struct_return,
		      CORE_ADDR struct_addr)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int stack_offset, stack_alloc;
  int int_argreg;
  int float_argreg;
  int double_argreg;
  int float_arg_index = 0;
  int double_arg_index = 0;
  int argnum;
  struct type *type;
  CORE_ADDR regval;
  const gdb_byte *val;
  gdb_byte valbuf[8];
  int len;
  int argreg_size;
  int fp_args[12];

  memset (fp_args, 0, sizeof (fp_args));

  /* First force sp to a 8-byte alignment.  */
  sp = sh64_frame_align (gdbarch, sp);

  /* The "struct return pointer" pseudo-argument has its own dedicated 
     register.  */

  if (struct_return)
    regcache_cooked_write_unsigned (regcache, 
				    STRUCT_RETURN_REGNUM, struct_addr);

  /* Now make sure there's space on the stack.  */
  for (argnum = 0, stack_alloc = 0; argnum < nargs; argnum++)
    stack_alloc += ((TYPE_LENGTH (value_type (args[argnum])) + 7) & ~7);
  sp -= stack_alloc;		/* Make room on stack for args.  */

  /* Now load as many as possible of the first arguments into
     registers, and push the rest onto the stack.  There are 64 bytes
     in eight registers available.  Loop thru args from first to last.  */

  int_argreg = ARG0_REGNUM;
  float_argreg = gdbarch_fp0_regnum (gdbarch);
  double_argreg = DR0_REGNUM;

  for (argnum = 0, stack_offset = 0; argnum < nargs; argnum++)
    {
      type = value_type (args[argnum]);
      len = TYPE_LENGTH (type);
      memset (valbuf, 0, sizeof (valbuf));
      
      if (TYPE_CODE (type) != TYPE_CODE_FLT)
	{
	  argreg_size = register_size (gdbarch, int_argreg);

	  if (len < argreg_size)
	    {
	      /* value gets right-justified in the register or stack word.  */
	      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
		memcpy (valbuf + argreg_size - len,
			value_contents (args[argnum]), len);
	      else
		memcpy (valbuf, value_contents (args[argnum]), len);

	      val = valbuf;
	    }
	  else
	    val = value_contents (args[argnum]);

	  while (len > 0)
	    {
	      if (int_argreg > ARGLAST_REGNUM)
		{			
		  /* Must go on the stack.  */
		  write_memory (sp + stack_offset, val, argreg_size);
		  stack_offset += 8;/*argreg_size;*/
		}
	      /* NOTE WELL!!!!!  This is not an "else if" clause!!!
		 That's because some *&^%$ things get passed on the stack
		 AND in the registers!   */
	      if (int_argreg <= ARGLAST_REGNUM)
		{			
		  /* There's room in a register.  */
		  regval = extract_unsigned_integer (val, argreg_size,
						     byte_order);
		  regcache_cooked_write_unsigned (regcache,
						  int_argreg, regval);
		}
	      /* Store the value 8 bytes at a time.  This means that
		 things larger than 8 bytes may go partly in registers
		 and partly on the stack.  FIXME: argreg is incremented
		 before we use its size.  */
	      len -= argreg_size;
	      val += argreg_size;
	      int_argreg++;
	    }
	}
      else
	{
	  val = value_contents (args[argnum]);
	  if (len == 4)
	    {
	      /* Where is it going to be stored?  */
	      while (fp_args[float_arg_index])
		float_arg_index ++;

	      /* Now float_argreg points to the register where it
		 should be stored.  Are we still within the allowed
		 register set?  */
	      if (float_arg_index <= FLOAT_ARGLAST_REGNUM)
		{
		  /* Goes in FR0...FR11 */
		  regcache_cooked_write (regcache,
					 gdbarch_fp0_regnum (gdbarch)
					 + float_arg_index,
					 val);
		  fp_args[float_arg_index] = 1;
		  /* Skip the corresponding general argument register.  */
		  int_argreg ++;
		}
	      else 
		{
		  /* Store it as the integers, 8 bytes at the time, if
		     necessary spilling on the stack.  */
		}
	    }
	    else if (len == 8)
	      {
		/* Where is it going to be stored?  */
		while (fp_args[double_arg_index])
		  double_arg_index += 2;
		/* Now double_argreg points to the register
		   where it should be stored.
		   Are we still within the allowed register set?  */
		if (double_arg_index < FLOAT_ARGLAST_REGNUM)
		  {
		    /* Goes in DR0...DR10 */
		    /* The numbering of the DRi registers is consecutive,
		       i.e. includes odd numbers.  */
		    int double_register_offset = double_arg_index / 2;
		    int regnum = DR0_REGNUM + double_register_offset;
		    regcache_cooked_write (regcache, regnum, val);
		    fp_args[double_arg_index] = 1;
		    fp_args[double_arg_index + 1] = 1;
		    /* Skip the corresponding general argument register.  */
		    int_argreg ++;
		  }
		else
		  {
		    /* Store it as the integers, 8 bytes at the time, if
		       necessary spilling on the stack.  */
		  }
	      }
	}
    }
  /* Store return address.  */
  regcache_cooked_write_unsigned (regcache, PR_REGNUM, bp_addr);

  /* Update stack pointer.  */
  regcache_cooked_write_unsigned (regcache,
				  gdbarch_sp_regnum (gdbarch), sp);

  return sp;
}

/* Find a function's return value in the appropriate registers (in
   regbuf), and copy it into valbuf.  Extract from an array REGBUF
   containing the (raw) register state a function return value of type
   TYPE, and copy that, in virtual format, into VALBUF.  */
static void
sh64_extract_return_value (struct type *type, struct regcache *regcache,
			   void *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int len = TYPE_LENGTH (type);

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      if (len == 4)
	{
	  /* Return value stored in gdbarch_fp0_regnum.  */
	  regcache_raw_read (regcache,
			     gdbarch_fp0_regnum (gdbarch), valbuf);
	}
      else if (len == 8)
	{
	  /* return value stored in DR0_REGNUM.  */
	  DOUBLEST val;
	  gdb_byte buf[8];

	  regcache_cooked_read (regcache, DR0_REGNUM, buf);
	  
	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	    floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword,
				     buf, &val);
	  else
	    floatformat_to_doublest (&floatformat_ieee_double_big,
				     buf, &val);
	  store_typed_floating (valbuf, type, val);
	}
    }
  else
    { 
      if (len <= 8)
	{
	  int offset;
	  gdb_byte buf[8];
	  /* Result is in register 2.  If smaller than 8 bytes, it is padded 
	     at the most significant end.  */
	  regcache_raw_read (regcache, DEFAULT_RETURN_REGNUM, buf);

	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	    offset = register_size (gdbarch, DEFAULT_RETURN_REGNUM)
		     - len;
	  else
	    offset = 0;
	  memcpy (valbuf, buf + offset, len);
	}
      else
	error (_("bad size for return value"));
    }
}

/* Write into appropriate registers a function return value
   of type TYPE, given in virtual format.
   If the architecture is sh4 or sh3e, store a function's return value
   in the R0 general register or in the FP0 floating point register,
   depending on the type of the return value.  In all the other cases
   the result is stored in r0, left-justified.  */

static void
sh64_store_return_value (struct type *type, struct regcache *regcache,
			 const gdb_byte *valbuf)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  gdb_byte buf[64];	/* more than enough...  */
  int len = TYPE_LENGTH (type);

  if (TYPE_CODE (type) == TYPE_CODE_FLT)
    {
      int i, regnum = gdbarch_fp0_regnum (gdbarch);
      for (i = 0; i < len; i += 4)
	if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	  regcache_raw_write (regcache, regnum++,
			      valbuf + len - 4 - i);
	else
	  regcache_raw_write (regcache, regnum++, valbuf + i);
    }
  else
    {
      int return_register = DEFAULT_RETURN_REGNUM;
      int offset = 0;

      if (len <= register_size (gdbarch, return_register))
	{
	  /* Pad with zeros.  */
	  memset (buf, 0, register_size (gdbarch, return_register));
	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	    offset = 0; /*register_size (gdbarch, 
			  return_register) - len;*/
	  else
	    offset = register_size (gdbarch, return_register) - len;

	  memcpy (buf + offset, valbuf, len);
	  regcache_raw_write (regcache, return_register, buf);
	}
      else
	regcache_raw_write (regcache, return_register, valbuf);
    }
}

static enum return_value_convention
sh64_return_value (struct gdbarch *gdbarch, struct value *function,
		   struct type *type, struct regcache *regcache,
		   gdb_byte *readbuf, const gdb_byte *writebuf)
{
  if (sh64_use_struct_convention (type))
    return RETURN_VALUE_STRUCT_CONVENTION;
  if (writebuf)
    sh64_store_return_value (type, regcache, writebuf);
  else if (readbuf)
    sh64_extract_return_value (type, regcache, readbuf);
  return RETURN_VALUE_REGISTER_CONVENTION;
}

/* *INDENT-OFF* */
/*
    SH MEDIA MODE (ISA 32)
    general registers (64-bit) 0-63
0    r0,   r1,   r2,   r3,   r4,   r5,   r6,   r7,
64   r8,   r9,   r10,  r11,  r12,  r13,  r14,  r15,
128  r16,  r17,  r18,  r19,  r20,  r21,  r22,  r23,
192  r24,  r25,  r26,  r27,  r28,  r29,  r30,  r31,
256  r32,  r33,  r34,  r35,  r36,  r37,  r38,  r39,
320  r40,  r41,  r42,  r43,  r44,  r45,  r46,  r47,
384  r48,  r49,  r50,  r51,  r52,  r53,  r54,  r55,
448  r56,  r57,  r58,  r59,  r60,  r61,  r62,  r63,

    pc (64-bit) 64
512  pc,

    status reg., saved status reg., saved pc reg. (64-bit) 65-67
520  sr,  ssr,  spc,

    target registers (64-bit) 68-75
544  tr0,  tr1,  tr2,  tr3,  tr4,  tr5,  tr6,  tr7,

    floating point state control register (32-bit) 76
608  fpscr,

    single precision floating point registers (32-bit) 77-140
612  fr0,  fr1,  fr2,  fr3,  fr4,  fr5,  fr6,  fr7,
644  fr8,  fr9,  fr10, fr11, fr12, fr13, fr14, fr15,
676  fr16, fr17, fr18, fr19, fr20, fr21, fr22, fr23,
708  fr24, fr25, fr26, fr27, fr28, fr29, fr30, fr31,
740  fr32, fr33, fr34, fr35, fr36, fr37, fr38, fr39,
772  fr40, fr41, fr42, fr43, fr44, fr45, fr46, fr47,
804  fr48, fr49, fr50, fr51, fr52, fr53, fr54, fr55,
836  fr56, fr57, fr58, fr59, fr60, fr61, fr62, fr63,

TOTAL SPACE FOR REGISTERS: 868 bytes

From here on they are all pseudo registers: no memory allocated.
REGISTER_BYTE returns the register byte for the base register.

    double precision registers (pseudo) 141-172
     dr0,  dr2,  dr4,  dr6,  dr8,  dr10, dr12, dr14,
     dr16, dr18, dr20, dr22, dr24, dr26, dr28, dr30,
     dr32, dr34, dr36, dr38, dr40, dr42, dr44, dr46,
     dr48, dr50, dr52, dr54, dr56, dr58, dr60, dr62,
 
    floating point pairs (pseudo) 173-204
     fp0,  fp2,  fp4,  fp6,  fp8,  fp10, fp12, fp14,
     fp16, fp18, fp20, fp22, fp24, fp26, fp28, fp30,
     fp32, fp34, fp36, fp38, fp40, fp42, fp44, fp46,
     fp48, fp50, fp52, fp54, fp56, fp58, fp60, fp62,
 
    floating point vectors (4 floating point regs) (pseudo) 205-220
     fv0,  fv4,  fv8,  fv12, fv16, fv20, fv24, fv28,
     fv32, fv36, fv40, fv44, fv48, fv52, fv56, fv60,
 
    SH COMPACT MODE (ISA 16) (all pseudo) 221-272
     r0_c, r1_c, r2_c,  r3_c,  r4_c,  r5_c,  r6_c,  r7_c,
     r8_c, r9_c, r10_c, r11_c, r12_c, r13_c, r14_c, r15_c,
     pc_c,
     gbr_c, mach_c, macl_c, pr_c, t_c,
     fpscr_c, fpul_c,
     fr0_c, fr1_c, fr2_c,  fr3_c,  fr4_c,  fr5_c,  fr6_c,  fr7_c,
     fr8_c, fr9_c, fr10_c, fr11_c, fr12_c, fr13_c, fr14_c, fr15_c
     dr0_c, dr2_c, dr4_c,  dr6_c,  dr8_c,  dr10_c, dr12_c, dr14_c
     fv0_c, fv4_c, fv8_c,  fv12_c
*/

static struct type *
sh64_build_float_register_type (struct gdbarch *gdbarch, int high)
{
  return lookup_array_range_type (builtin_type (gdbarch)->builtin_float,
				  0, high);
}

/* Return the GDB type object for the "standard" data type
   of data in register REG_NR.  */
static struct type *
sh64_register_type (struct gdbarch *gdbarch, int reg_nr)
{
  if ((reg_nr >= gdbarch_fp0_regnum (gdbarch)
       && reg_nr <= FP_LAST_REGNUM)
      || (reg_nr >= FP0_C_REGNUM
	  && reg_nr <= FP_LAST_C_REGNUM))
    return builtin_type (gdbarch)->builtin_float;
  else if ((reg_nr >= DR0_REGNUM 
	    && reg_nr <= DR_LAST_REGNUM)
	   || (reg_nr >= DR0_C_REGNUM 
	       && reg_nr <= DR_LAST_C_REGNUM))
    return builtin_type (gdbarch)->builtin_double;
  else if  (reg_nr >= FPP0_REGNUM 
	    && reg_nr <= FPP_LAST_REGNUM)
    return sh64_build_float_register_type (gdbarch, 1);
  else if ((reg_nr >= FV0_REGNUM
	    && reg_nr <= FV_LAST_REGNUM)
	   ||(reg_nr >= FV0_C_REGNUM 
	      && reg_nr <= FV_LAST_C_REGNUM))
    return sh64_build_float_register_type (gdbarch, 3);
  else if (reg_nr == FPSCR_REGNUM)
    return builtin_type (gdbarch)->builtin_int;
  else if (reg_nr >= R0_C_REGNUM
	   && reg_nr < FP0_C_REGNUM)
    return builtin_type (gdbarch)->builtin_int;
  else
    return builtin_type (gdbarch)->builtin_long_long;
}

static void
sh64_register_convert_to_virtual (struct gdbarch *gdbarch, int regnum,
				  struct type *type, gdb_byte *from, gdb_byte *to)
{
  if (gdbarch_byte_order (gdbarch) != BFD_ENDIAN_LITTLE)
    {
      /* It is a no-op.  */
      memcpy (to, from, register_size (gdbarch, regnum));
      return;
    }

  if ((regnum >= DR0_REGNUM 
       && regnum <= DR_LAST_REGNUM)
      || (regnum >= DR0_C_REGNUM 
	  && regnum <= DR_LAST_C_REGNUM))
    {
      DOUBLEST val;
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword, 
			       from, &val);
      store_typed_floating (to, type, val);
    }
  else
    error (_("sh64_register_convert_to_virtual "
	     "called with non DR register number"));
}

static void
sh64_register_convert_to_raw (struct gdbarch *gdbarch, struct type *type,
			      int regnum, const void *from, void *to)
{
  if (gdbarch_byte_order (gdbarch) != BFD_ENDIAN_LITTLE)
    {
      /* It is a no-op.  */
      memcpy (to, from, register_size (gdbarch, regnum));
      return;
    }

  if ((regnum >= DR0_REGNUM 
       && regnum <= DR_LAST_REGNUM)
      || (regnum >= DR0_C_REGNUM 
	  && regnum <= DR_LAST_C_REGNUM))
    {
      DOUBLEST val = extract_typed_floating (from, type);
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword, 
				 &val, to);
    }
  else
    error (_("sh64_register_convert_to_raw called "
	     "with non DR register number"));
}

/* Concatenate PORTIONS contiguous raw registers starting at
   BASE_REGNUM into BUFFER.  */

static enum register_status
pseudo_register_read_portions (struct gdbarch *gdbarch,
			       struct regcache *regcache,
			       int portions,
			       int base_regnum, gdb_byte *buffer)
{
  int portion;

  for (portion = 0; portion < portions; portion++)
    {
      enum register_status status;
      gdb_byte *b;

      b = buffer + register_size (gdbarch, base_regnum) * portion;
      status = regcache_raw_read (regcache, base_regnum + portion, b);
      if (status != REG_VALID)
	return status;
    }

  return REG_VALID;
}

static enum register_status
sh64_pseudo_register_read (struct gdbarch *gdbarch, struct regcache *regcache,
			   int reg_nr, gdb_byte *buffer)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int base_regnum;
  int offset = 0;
  gdb_byte temp_buffer[MAX_REGISTER_SIZE];
  enum register_status status;

  if (reg_nr >= DR0_REGNUM 
      && reg_nr <= DR_LAST_REGNUM)
    {
      base_regnum = sh64_dr_reg_base_num (gdbarch, reg_nr);

      /* Build the value in the provided buffer.  */ 
      /* DR regs are double precision registers obtained by
	 concatenating 2 single precision floating point registers.  */
      status = pseudo_register_read_portions (gdbarch, regcache,
					      2, base_regnum, temp_buffer);
      if (status == REG_VALID)
	{
	  /* We must pay attention to the endianness.  */
	  sh64_register_convert_to_virtual (gdbarch, reg_nr,
					    register_type (gdbarch, reg_nr),
					    temp_buffer, buffer);
	}

      return status;
    }

  else if (reg_nr >= FPP0_REGNUM
	   && reg_nr <= FPP_LAST_REGNUM)
    {
      base_regnum = sh64_fpp_reg_base_num (gdbarch, reg_nr);

      /* Build the value in the provided buffer.  */ 
      /* FPP regs are pairs of single precision registers obtained by
	 concatenating 2 single precision floating point registers.  */
      return pseudo_register_read_portions (gdbarch, regcache,
					    2, base_regnum, buffer);
    }

  else if (reg_nr >= FV0_REGNUM 
	   && reg_nr <= FV_LAST_REGNUM)
    {
      base_regnum = sh64_fv_reg_base_num (gdbarch, reg_nr);

      /* Build the value in the provided buffer.  */ 
      /* FV regs are vectors of single precision registers obtained by
	 concatenating 4 single precision floating point registers.  */
      return pseudo_register_read_portions (gdbarch, regcache,
					    4, base_regnum, buffer);
    }

  /* sh compact pseudo registers.  1-to-1 with a shmedia register.  */
  else if (reg_nr >= R0_C_REGNUM 
	   && reg_nr <= T_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);

      /* Build the value in the provided buffer.  */ 
      status = regcache_raw_read (regcache, base_regnum, temp_buffer);
      if (status != REG_VALID)
	return status;
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	offset = 4;
      memcpy (buffer,
	      temp_buffer + offset, 4); /* get LOWER 32 bits only????  */
      return REG_VALID;
    }

  else if (reg_nr >= FP0_C_REGNUM
	   && reg_nr <= FP_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);

      /* Build the value in the provided buffer.  */ 
      /* Floating point registers map 1-1 to the media fp regs,
	 they have the same size and endianness.  */
      return regcache_raw_read (regcache, base_regnum, buffer);
    }

  else if (reg_nr >= DR0_C_REGNUM 
	   && reg_nr <= DR_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);

      /* DR_C regs are double precision registers obtained by
	 concatenating 2 single precision floating point registers.  */
      status = pseudo_register_read_portions (gdbarch, regcache,
					      2, base_regnum, temp_buffer);
      if (status == REG_VALID)
	{
	  /* We must pay attention to the endianness.  */
	  sh64_register_convert_to_virtual (gdbarch, reg_nr,
					    register_type (gdbarch, reg_nr),
					    temp_buffer, buffer);
	}
      return status;
    }

  else if (reg_nr >= FV0_C_REGNUM 
	   && reg_nr <= FV_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);

      /* Build the value in the provided buffer.  */ 
      /* FV_C regs are vectors of single precision registers obtained by
	 concatenating 4 single precision floating point registers.  */
      return pseudo_register_read_portions (gdbarch, regcache,
					    4, base_regnum, buffer);
    }

  else if (reg_nr == FPSCR_C_REGNUM)
    {
      int fpscr_base_regnum;
      int sr_base_regnum;
      unsigned int fpscr_value;
      unsigned int sr_value;
      unsigned int fpscr_c_value;
      unsigned int fpscr_c_part1_value;
      unsigned int fpscr_c_part2_value;

      fpscr_base_regnum = FPSCR_REGNUM;
      sr_base_regnum = SR_REGNUM;

      /* Build the value in the provided buffer.  */ 
      /* FPSCR_C is a very weird register that contains sparse bits
	 from the FPSCR and the SR architectural registers.
	 Specifically: */
      /* *INDENT-OFF* */
      /*
	 FPSRC_C bit
            0         Bit 0 of FPSCR
            1         reserved
            2-17      Bit 2-18 of FPSCR
            18-20     Bits 12,13,14 of SR
            21-31     reserved
       */
      /* *INDENT-ON* */
      /* Get FPSCR into a local buffer.  */
      status = regcache_raw_read (regcache, fpscr_base_regnum, temp_buffer);
      if (status != REG_VALID)
	return status;
      /* Get value as an int.  */
      fpscr_value = extract_unsigned_integer (temp_buffer, 4, byte_order);
      /* Get SR into a local buffer */
      status = regcache_raw_read (regcache, sr_base_regnum, temp_buffer);
      if (status != REG_VALID)
	return status;
      /* Get value as an int.  */
      sr_value = extract_unsigned_integer (temp_buffer, 4, byte_order);
      /* Build the new value.  */
      fpscr_c_part1_value = fpscr_value & 0x3fffd;
      fpscr_c_part2_value = (sr_value & 0x7000) << 6;
      fpscr_c_value = fpscr_c_part1_value | fpscr_c_part2_value;
      /* Store that in out buffer!!!  */
      store_unsigned_integer (buffer, 4, byte_order, fpscr_c_value);
      /* FIXME There is surely an endianness gotcha here.  */

      return REG_VALID;
    }

  else if (reg_nr == FPUL_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);

      /* FPUL_C register is floating point register 32,
	 same size, same endianness.  */
      return regcache_raw_read (regcache, base_regnum, buffer);
    }
  else
    gdb_assert_not_reached ("invalid pseudo register number");
}

static void
sh64_pseudo_register_write (struct gdbarch *gdbarch, struct regcache *regcache,
			    int reg_nr, const gdb_byte *buffer)
{
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  int base_regnum, portion;
  int offset;
  gdb_byte temp_buffer[MAX_REGISTER_SIZE];

  if (reg_nr >= DR0_REGNUM
      && reg_nr <= DR_LAST_REGNUM)
    {
      base_regnum = sh64_dr_reg_base_num (gdbarch, reg_nr);
      /* We must pay attention to the endianness.  */
      sh64_register_convert_to_raw (gdbarch, register_type (gdbarch, reg_nr),
				    reg_nr,
				    buffer, temp_buffer);

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_write (regcache, base_regnum + portion, 
			    (temp_buffer
			     + register_size (gdbarch,
					      base_regnum) * portion));
    }

  else if (reg_nr >= FPP0_REGNUM 
	   && reg_nr <= FPP_LAST_REGNUM)
    {
      base_regnum = sh64_fpp_reg_base_num (gdbarch, reg_nr);

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 2; portion++)
	regcache_raw_write (regcache, base_regnum + portion,
			    (buffer + register_size (gdbarch,
						     base_regnum) * portion));
    }

  else if (reg_nr >= FV0_REGNUM
	   && reg_nr <= FV_LAST_REGNUM)
    {
      base_regnum = sh64_fv_reg_base_num (gdbarch, reg_nr);

      /* Write the real regs for which this one is an alias.  */
      for (portion = 0; portion < 4; portion++)
	regcache_raw_write (regcache, base_regnum + portion,
			    (buffer + register_size (gdbarch,
						     base_regnum) * portion));
    }

  /* sh compact general pseudo registers.  1-to-1 with a shmedia
     register but only 4 bytes of it.  */
  else if (reg_nr >= R0_C_REGNUM 
	   && reg_nr <= T_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);
      /* reg_nr is 32 bit here, and base_regnum is 64 bits.  */
      if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_BIG)
	offset = 4;
      else 
	offset = 0;
      /* Let's read the value of the base register into a temporary
	 buffer, so that overwriting the last four bytes with the new
	 value of the pseudo will leave the upper 4 bytes unchanged.  */
      regcache_raw_read (regcache, base_regnum, temp_buffer);
      /* Write as an 8 byte quantity.  */
      memcpy (temp_buffer + offset, buffer, 4);
      regcache_raw_write (regcache, base_regnum, temp_buffer);
    }

  /* sh floating point compact pseudo registers.  1-to-1 with a shmedia
     registers.  Both are 4 bytes.  */
  else if (reg_nr >= FP0_C_REGNUM
	       && reg_nr <= FP_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);
      regcache_raw_write (regcache, base_regnum, buffer);
    }

  else if (reg_nr >= DR0_C_REGNUM 
	   && reg_nr <= DR_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);
      for (portion = 0; portion < 2; portion++)
	{
	  /* We must pay attention to the endianness.  */
	  sh64_register_convert_to_raw (gdbarch,
					register_type (gdbarch, reg_nr),
					reg_nr,
					buffer, temp_buffer);

	  regcache_raw_write (regcache, base_regnum + portion,
			      (temp_buffer
			       + register_size (gdbarch, 
						base_regnum) * portion));
	}
    }

  else if (reg_nr >= FV0_C_REGNUM 
	   && reg_nr <= FV_LAST_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);
     
      for (portion = 0; portion < 4; portion++)
	{
	  regcache_raw_write (regcache, base_regnum + portion,
			      (buffer
			       + register_size (gdbarch, 
						base_regnum) * portion));
	}
    }

  else if (reg_nr == FPSCR_C_REGNUM)
    {      
      int fpscr_base_regnum;
      int sr_base_regnum;
      unsigned int fpscr_value;
      unsigned int sr_value;
      unsigned int old_fpscr_value;
      unsigned int old_sr_value;
      unsigned int fpscr_c_value;
      unsigned int fpscr_mask;
      unsigned int sr_mask;

      fpscr_base_regnum = FPSCR_REGNUM;
      sr_base_regnum = SR_REGNUM;

      /* FPSCR_C is a very weird register that contains sparse bits
	 from the FPSCR and the SR architectural registers.
	 Specifically: */
      /* *INDENT-OFF* */
      /*
	 FPSRC_C bit
            0         Bit 0 of FPSCR
            1         reserved
            2-17      Bit 2-18 of FPSCR
            18-20     Bits 12,13,14 of SR
            21-31     reserved
       */
      /* *INDENT-ON* */
      /* Get value as an int.  */
      fpscr_c_value = extract_unsigned_integer (buffer, 4, byte_order);

      /* Build the new values.  */
      fpscr_mask = 0x0003fffd;
      sr_mask = 0x001c0000;
       
      fpscr_value = fpscr_c_value & fpscr_mask;
      sr_value = (fpscr_value & sr_mask) >> 6;
      
      regcache_raw_read (regcache, fpscr_base_regnum, temp_buffer);
      old_fpscr_value = extract_unsigned_integer (temp_buffer, 4, byte_order);
      old_fpscr_value &= 0xfffc0002;
      fpscr_value |= old_fpscr_value;
      store_unsigned_integer (temp_buffer, 4, byte_order, fpscr_value);
      regcache_raw_write (regcache, fpscr_base_regnum, temp_buffer);
      
      regcache_raw_read (regcache, sr_base_regnum, temp_buffer);
      old_sr_value = extract_unsigned_integer (temp_buffer, 4, byte_order);
      old_sr_value &= 0xffff8fff;
      sr_value |= old_sr_value;
      store_unsigned_integer (temp_buffer, 4, byte_order, sr_value);
      regcache_raw_write (regcache, sr_base_regnum, temp_buffer);
    }

  else if (reg_nr == FPUL_C_REGNUM)
    {
      base_regnum = sh64_compact_reg_base_num (gdbarch, reg_nr);
      regcache_raw_write (regcache, base_regnum, buffer);
    }
}

/* FIXME:!! THIS SHOULD TAKE CARE OF GETTING THE RIGHT PORTION OF THE
   shmedia REGISTERS.  */
/* Control registers, compact mode.  */
static void
sh64_do_cr_c_register_info (struct ui_file *file, struct frame_info *frame,
			    int cr_c_regnum)
{
  switch (cr_c_regnum)
    {
    case PC_C_REGNUM:
      fprintf_filtered (file, "pc_c\t0x%08x\n",
	  (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    case GBR_C_REGNUM: 
      fprintf_filtered (file, "gbr_c\t0x%08x\n",
      	  (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    case MACH_C_REGNUM: 
      fprintf_filtered (file, "mach_c\t0x%08x\n",
      	  (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    case MACL_C_REGNUM: 
      fprintf_filtered (file, "macl_c\t0x%08x\n",
      	  (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    case PR_C_REGNUM: 
      fprintf_filtered (file, "pr_c\t0x%08x\n",
      	  (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    case T_C_REGNUM: 
      fprintf_filtered (file, "t_c\t0x%08x\n",
      	  (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    case FPSCR_C_REGNUM: 
      fprintf_filtered (file, "fpscr_c\t0x%08x\n",
      	  (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    case FPUL_C_REGNUM:
      fprintf_filtered (file, "fpul_c\t0x%08x\n",
          (int) get_frame_register_unsigned (frame, cr_c_regnum));
      break;
    }
}

static void
sh64_do_fp_register (struct gdbarch *gdbarch, struct ui_file *file,
		     struct frame_info *frame, int regnum)
{				/* Do values for FP (float) regs.  */
  unsigned char *raw_buffer;
  double flt;	/* Double extracted from raw hex data.  */
  int inv;
  int j;

  /* Allocate space for the float.  */
  raw_buffer = (unsigned char *)
    alloca (register_size (gdbarch, gdbarch_fp0_regnum (gdbarch)));

  /* Get the data in raw format.  */
  if (!deprecated_frame_register_read (frame, regnum, raw_buffer))
    error (_("can't read register %d (%s)"),
	   regnum, gdbarch_register_name (gdbarch, regnum));

  /* Get the register as a number.  */ 
  flt = unpack_double (builtin_type (gdbarch)->builtin_float,
		       raw_buffer, &inv);

  /* Print the name and some spaces.  */
  fputs_filtered (gdbarch_register_name (gdbarch, regnum), file);
  print_spaces_filtered (15 - strlen (gdbarch_register_name
					(gdbarch, regnum)), file);

  /* Print the value.  */
  if (inv)
    fprintf_filtered (file, "<invalid float>");
  else
    fprintf_filtered (file, "%-10.9g", flt);

  /* Print the fp register as hex.  */
  fprintf_filtered (file, "\t(raw ");
  print_hex_chars (file, raw_buffer,
		   register_size (gdbarch, regnum),
		   gdbarch_byte_order (gdbarch));
  fprintf_filtered (file, ")");
  fprintf_filtered (file, "\n");
}

static void
sh64_do_pseudo_register (struct gdbarch *gdbarch, struct ui_file *file,
			 struct frame_info *frame, int regnum)
{
  /* All the sh64-compact mode registers are pseudo registers.  */

  if (regnum < gdbarch_num_regs (gdbarch)
      || regnum >= gdbarch_num_regs (gdbarch)
		   + NUM_PSEUDO_REGS_SH_MEDIA
		   + NUM_PSEUDO_REGS_SH_COMPACT)
    internal_error (__FILE__, __LINE__,
		    _("Invalid pseudo register number %d\n"), regnum);

  else if ((regnum >= DR0_REGNUM && regnum <= DR_LAST_REGNUM))
    {
      int fp_regnum = sh64_dr_reg_base_num (gdbarch, regnum);
      fprintf_filtered (file, "dr%d\t0x%08x%08x\n", regnum - DR0_REGNUM, 
	  (unsigned) get_frame_register_unsigned (frame, fp_regnum),
	  (unsigned) get_frame_register_unsigned (frame, fp_regnum + 1));
    }

  else if ((regnum >= DR0_C_REGNUM && regnum <= DR_LAST_C_REGNUM))
    {
      int fp_regnum = sh64_compact_reg_base_num (gdbarch, regnum);
      fprintf_filtered (file, "dr%d_c\t0x%08x%08x\n", regnum - DR0_C_REGNUM,
	  (unsigned) get_frame_register_unsigned (frame, fp_regnum),
	  (unsigned) get_frame_register_unsigned (frame, fp_regnum + 1));
    }

  else if ((regnum >= FV0_REGNUM && regnum <= FV_LAST_REGNUM))
    {
      int fp_regnum = sh64_fv_reg_base_num (gdbarch, regnum);
      fprintf_filtered (file, "fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
	   regnum - FV0_REGNUM, 
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum),
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum + 1),
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum + 2),
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum + 3));
    }
	   
  else if ((regnum >= FV0_C_REGNUM && regnum <= FV_LAST_C_REGNUM))
    {
      int fp_regnum = sh64_compact_reg_base_num (gdbarch, regnum);
      fprintf_filtered (file, "fv%d_c\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
	   regnum - FV0_C_REGNUM, 
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum),
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum + 1),
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum + 2),
	   (unsigned) get_frame_register_unsigned (frame, fp_regnum + 3));
    }

  else if (regnum >= FPP0_REGNUM && regnum <= FPP_LAST_REGNUM)
    {
      int fp_regnum = sh64_fpp_reg_base_num (gdbarch, regnum);
      fprintf_filtered (file, "fpp%d\t0x%08x\t0x%08x\n", regnum - FPP0_REGNUM, 
	  (unsigned) get_frame_register_unsigned (frame, fp_regnum),
	  (unsigned) get_frame_register_unsigned (frame, fp_regnum + 1));
    }

  else if (regnum >= R0_C_REGNUM && regnum <= R_LAST_C_REGNUM)
    {
      int c_regnum = sh64_compact_reg_base_num (gdbarch, regnum);
      fprintf_filtered (file, "r%d_c\t0x%08x\n", regnum - R0_C_REGNUM, 
	   (unsigned) get_frame_register_unsigned (frame, c_regnum));
    }
  else if (regnum >= FP0_C_REGNUM && regnum <= FP_LAST_C_REGNUM)
    /* This should work also for pseudoregs.  */
    sh64_do_fp_register (gdbarch, file, frame, regnum);
  else if (regnum >= PC_C_REGNUM && regnum <= FPUL_C_REGNUM)
    sh64_do_cr_c_register_info (file, frame, regnum);
}

static void
sh64_do_register (struct gdbarch *gdbarch, struct ui_file *file,
		  struct frame_info *frame, int regnum)
{
  unsigned char raw_buffer[MAX_REGISTER_SIZE];
  struct value_print_options opts;

  fputs_filtered (gdbarch_register_name (gdbarch, regnum), file);
  print_spaces_filtered (15 - strlen (gdbarch_register_name
				      (gdbarch, regnum)), file);

  /* Get the data in raw format.  */
  if (!deprecated_frame_register_read (frame, regnum, raw_buffer))
    {
      fprintf_filtered (file, "*value not available*\n");
      return;
    }

  get_formatted_print_options (&opts, 'x');
  opts.deref_ref = 1;
  val_print (register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 0, NULL, &opts, current_language);
  fprintf_filtered (file, "\t");
  get_formatted_print_options (&opts, 0);
  opts.deref_ref = 1;
  val_print (register_type (gdbarch, regnum), raw_buffer, 0, 0,
	     file, 0, NULL, &opts, current_language);
  fprintf_filtered (file, "\n");
}

static void
sh64_print_register (struct gdbarch *gdbarch, struct ui_file *file,
		     struct frame_info *frame, int regnum)
{
  if (regnum < 0 || regnum >= gdbarch_num_regs (gdbarch)
			      + gdbarch_num_pseudo_regs (gdbarch))
    internal_error (__FILE__, __LINE__,
		    _("Invalid register number %d\n"), regnum);

  else if (regnum >= 0 && regnum < gdbarch_num_regs (gdbarch))
    {
      if (TYPE_CODE (register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
	sh64_do_fp_register (gdbarch, file, frame, regnum);	/* FP regs */
      else
	sh64_do_register (gdbarch, file, frame, regnum);
    }

  else if (regnum < gdbarch_num_regs (gdbarch)
		    + gdbarch_num_pseudo_regs (gdbarch))
    sh64_do_pseudo_register (gdbarch, file, frame, regnum);
}

static void
sh64_media_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
				 struct frame_info *frame, int regnum,
				 int fpregs)
{
  if (regnum != -1)		/* Do one specified register.  */
    {
      if (*(gdbarch_register_name (gdbarch, regnum)) == '\0')
	error (_("Not a valid register for the current processor type"));

      sh64_print_register (gdbarch, file, frame, regnum);
    }
  else
    /* Do all (or most) registers.  */
    {
      regnum = 0;
      while (regnum < gdbarch_num_regs (gdbarch))
	{
	  /* If the register name is empty, it is undefined for this
	     processor, so don't display anything.  */
	  if (gdbarch_register_name (gdbarch, regnum) == NULL
	      || *(gdbarch_register_name (gdbarch, regnum)) == '\0')
	    { 
	      regnum++;
	      continue;
	    }

	  if (TYPE_CODE (register_type (gdbarch, regnum))
	      == TYPE_CODE_FLT)
	    {
	      if (fpregs)
		{
		  /* true for "INFO ALL-REGISTERS" command.  */
		  sh64_do_fp_register (gdbarch, file, frame, regnum);
		  regnum ++;
		}
	      else
		regnum += FP_LAST_REGNUM - gdbarch_fp0_regnum (gdbarch);
		/* skip FP regs */
	    }
	  else
	    {
	      sh64_do_register (gdbarch, file, frame, regnum);
	      regnum++;
	    }
	}

      if (fpregs)
	while (regnum < gdbarch_num_regs (gdbarch)
			+ gdbarch_num_pseudo_regs (gdbarch))
	  {
	    sh64_do_pseudo_register (gdbarch, file, frame, regnum);
	    regnum++;
	  }
    }
}

static void
sh64_compact_print_registers_info (struct gdbarch *gdbarch,
				   struct ui_file *file,
				   struct frame_info *frame, int regnum,
				   int fpregs)
{
  if (regnum != -1)		/* Do one specified register.  */
    {
      if (*(gdbarch_register_name (gdbarch, regnum)) == '\0')
	error (_("Not a valid register for the current processor type"));

      if (regnum >= 0 && regnum < R0_C_REGNUM)
        error (_("Not a valid register for the current processor mode."));

      sh64_print_register (gdbarch, file, frame, regnum);
    }
  else
    /* Do all compact registers.  */
    {
      regnum = R0_C_REGNUM;
      while (regnum < gdbarch_num_regs (gdbarch)
		      + gdbarch_num_pseudo_regs (gdbarch))
        {
          sh64_do_pseudo_register (gdbarch, file, frame, regnum);
          regnum++;
        }
    }
}

static void
sh64_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			   struct frame_info *frame, int regnum, int fpregs)
{
  if (pc_is_isa32 (get_frame_pc (frame)))
    sh64_media_print_registers_info (gdbarch, file, frame, regnum, fpregs);
  else
    sh64_compact_print_registers_info (gdbarch, file, frame, regnum, fpregs);
}

static struct sh64_frame_cache *
sh64_alloc_frame_cache (void)
{
  struct sh64_frame_cache *cache;
  int i;

  cache = FRAME_OBSTACK_ZALLOC (struct sh64_frame_cache);

  /* Base address.  */
  cache->base = 0;
  cache->saved_sp = 0;
  cache->sp_offset = 0;
  cache->pc = 0;

  /* Frameless until proven otherwise.  */
  cache->uses_fp = 0;

  /* Saved registers.  We initialize these to -1 since zero is a valid
     offset (that's where fp is supposed to be stored).  */
  for (i = 0; i < SIM_SH64_NR_REGS; i++)
    {
      cache->saved_regs[i] = -1;
    }

  return cache;
}

static struct sh64_frame_cache *
sh64_frame_cache (struct frame_info *this_frame, void **this_cache)
{
  struct gdbarch *gdbarch;
  struct sh64_frame_cache *cache;
  CORE_ADDR current_pc;
  int i;

  if (*this_cache)
    return *this_cache;

  gdbarch = get_frame_arch (this_frame);
  cache = sh64_alloc_frame_cache ();
  *this_cache = cache;

  current_pc = get_frame_pc (this_frame);
  cache->media_mode = pc_is_isa32 (current_pc);

  /* In principle, for normal frames, fp holds the frame pointer,
     which holds the base address for the current stack frame.
     However, for functions that don't need it, the frame pointer is
     optional.  For these "frameless" functions the frame pointer is
     actually the frame pointer of the calling frame.  */
  cache->base = get_frame_register_unsigned (this_frame, MEDIA_FP_REGNUM);
  if (cache->base == 0)
    return cache;

  cache->pc = get_frame_func (this_frame);
  if (cache->pc != 0)
    sh64_analyze_prologue (gdbarch, cache, cache->pc, current_pc);

  if (!cache->uses_fp)
    {
      /* We didn't find a valid frame, which means that CACHE->base
         currently holds the frame pointer for our calling frame.  If
         we're at the start of a function, or somewhere half-way its
         prologue, the function's frame probably hasn't been fully
         setup yet.  Try to reconstruct the base address for the stack
         frame by looking at the stack pointer.  For truly "frameless"
         functions this might work too.  */
      cache->base = get_frame_register_unsigned
		    (this_frame, gdbarch_sp_regnum (gdbarch));
    }

  /* Now that we have the base address for the stack frame we can
     calculate the value of sp in the calling frame.  */
  cache->saved_sp = cache->base + cache->sp_offset;

  /* Adjust all the saved registers such that they contain addresses
     instead of offsets.  */
  for (i = 0; i < SIM_SH64_NR_REGS; i++)
    if (cache->saved_regs[i] != -1)
      cache->saved_regs[i] = cache->saved_sp - cache->saved_regs[i];

  return cache;
}

static struct value *
sh64_frame_prev_register (struct frame_info *this_frame,
			  void **this_cache, int regnum)
{
  struct sh64_frame_cache *cache = sh64_frame_cache (this_frame, this_cache);
  struct gdbarch *gdbarch = get_frame_arch (this_frame);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  gdb_assert (regnum >= 0);

  if (regnum == gdbarch_sp_regnum (gdbarch) && cache->saved_sp)
    frame_unwind_got_constant (this_frame, regnum, cache->saved_sp);

  /* The PC of the previous frame is stored in the PR register of
     the current frame.  Frob regnum so that we pull the value from
     the correct place.  */
  if (regnum == gdbarch_pc_regnum (gdbarch))
    regnum = PR_REGNUM;

  if (regnum < SIM_SH64_NR_REGS && cache->saved_regs[regnum] != -1)
    {
      if (gdbarch_tdep (gdbarch)->sh_abi == SH_ABI_32
          && (regnum == MEDIA_FP_REGNUM || regnum == PR_REGNUM))
        {
	  CORE_ADDR val;
	  val = read_memory_unsigned_integer (cache->saved_regs[regnum],
					      4, byte_order);
	  return frame_unwind_got_constant (this_frame, regnum, val);
        }

      return frame_unwind_got_memory (this_frame, regnum,
				      cache->saved_regs[regnum]);
    }

  return frame_unwind_got_register (this_frame, regnum, regnum);
}

static void
sh64_frame_this_id (struct frame_info *this_frame, void **this_cache,
		    struct frame_id *this_id)
{
  struct sh64_frame_cache *cache = sh64_frame_cache (this_frame, this_cache);

  /* This marks the outermost frame.  */
  if (cache->base == 0)
    return;

  *this_id = frame_id_build (cache->saved_sp, cache->pc);
}

static const struct frame_unwind sh64_frame_unwind = {
  NORMAL_FRAME,
  default_frame_unwind_stop_reason,
  sh64_frame_this_id,
  sh64_frame_prev_register,
  NULL,
  default_frame_sniffer
};

static CORE_ADDR
sh64_unwind_sp (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame,
					 gdbarch_sp_regnum (gdbarch));
}

static CORE_ADDR
sh64_unwind_pc (struct gdbarch *gdbarch, struct frame_info *next_frame)
{
  return frame_unwind_register_unsigned (next_frame,
					 gdbarch_pc_regnum (gdbarch));
}

static struct frame_id
sh64_dummy_id (struct gdbarch *gdbarch, struct frame_info *this_frame)
{
  CORE_ADDR sp = get_frame_register_unsigned (this_frame,
					      gdbarch_sp_regnum (gdbarch));
  return frame_id_build (sp, get_frame_pc (this_frame));
}

static CORE_ADDR
sh64_frame_base_address (struct frame_info *this_frame, void **this_cache)
{
  struct sh64_frame_cache *cache = sh64_frame_cache (this_frame, this_cache);

  return cache->base;
}

static const struct frame_base sh64_frame_base = {
  &sh64_frame_unwind,
  sh64_frame_base_address,
  sh64_frame_base_address,
  sh64_frame_base_address
};


struct gdbarch *
sh64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
{
  struct gdbarch *gdbarch;
  struct gdbarch_tdep *tdep;

  /* If there is already a candidate, use it.  */
  arches = gdbarch_list_lookup_by_info (arches, &info);
  if (arches != NULL)
    return arches->gdbarch;

  /* None found, create a new architecture from the information
     provided.  */
  tdep = XMALLOC (struct gdbarch_tdep);
  gdbarch = gdbarch_alloc (&info, tdep);

  /* Determine the ABI */
  if (info.abfd && bfd_get_arch_size (info.abfd) == 64)
    {
      /* If the ABI is the 64-bit one, it can only be sh-media.  */
      tdep->sh_abi = SH_ABI_64;
      set_gdbarch_ptr_bit (gdbarch, 8 * TARGET_CHAR_BIT);
      set_gdbarch_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
    }
  else
    {
      /* If the ABI is the 32-bit one it could be either media or
	 compact.  */
      tdep->sh_abi = SH_ABI_32;
      set_gdbarch_ptr_bit (gdbarch, 4 * TARGET_CHAR_BIT);
      set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
    }

  set_gdbarch_short_bit (gdbarch, 2 * TARGET_CHAR_BIT);
  set_gdbarch_int_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_long_long_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_float_bit (gdbarch, 4 * TARGET_CHAR_BIT);
  set_gdbarch_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);
  set_gdbarch_long_double_bit (gdbarch, 8 * TARGET_CHAR_BIT);

  /* The number of real registers is the same whether we are in 
     ISA16(compact) or ISA32(media).  */
  set_gdbarch_num_regs (gdbarch, SIM_SH64_NR_REGS);
  set_gdbarch_sp_regnum (gdbarch, 15);
  set_gdbarch_pc_regnum (gdbarch, 64);
  set_gdbarch_fp0_regnum (gdbarch, SIM_SH64_FR0_REGNUM);
  set_gdbarch_num_pseudo_regs (gdbarch, NUM_PSEUDO_REGS_SH_MEDIA
  					+ NUM_PSEUDO_REGS_SH_COMPACT);

  set_gdbarch_register_name (gdbarch, sh64_register_name);
  set_gdbarch_register_type (gdbarch, sh64_register_type);

  set_gdbarch_pseudo_register_read (gdbarch, sh64_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, sh64_pseudo_register_write);

  set_gdbarch_breakpoint_from_pc (gdbarch, sh64_breakpoint_from_pc);

  set_gdbarch_print_insn (gdbarch, print_insn_sh);
  set_gdbarch_register_sim_regno (gdbarch, legacy_register_sim_regno);

  set_gdbarch_return_value (gdbarch, sh64_return_value);

  set_gdbarch_skip_prologue (gdbarch, sh64_skip_prologue);
  set_gdbarch_inner_than (gdbarch, core_addr_lessthan);

  set_gdbarch_push_dummy_call (gdbarch, sh64_push_dummy_call);

  set_gdbarch_believe_pcc_promotion (gdbarch, 1);

  set_gdbarch_frame_align (gdbarch, sh64_frame_align);
  set_gdbarch_unwind_sp (gdbarch, sh64_unwind_sp);
  set_gdbarch_unwind_pc (gdbarch, sh64_unwind_pc);
  set_gdbarch_dummy_id (gdbarch, sh64_dummy_id);
  frame_base_set_default (gdbarch, &sh64_frame_base);

  set_gdbarch_print_registers_info (gdbarch, sh64_print_registers_info);

  set_gdbarch_elf_make_msymbol_special (gdbarch,
					sh64_elf_make_msymbol_special);

  /* Hook in ABI-specific overrides, if they have been registered.  */
  gdbarch_init_osabi (info, gdbarch);

  dwarf2_append_unwinders (gdbarch);
  frame_unwind_append_unwinder (gdbarch, &sh64_frame_unwind);

  return gdbarch;
}
@


1.92
log
@Avoid printing unavailable/optimized out registers (sh64-tdep.c)

  https://sourceware.org/ml/gdb-patches/2013-08/msg00834.html

gdb/ChangeLog

        * sh64-tdep.c (sh64_do_register): Return after printing message
        about unavailable register contents.
@
text
@d1951 4
a1954 8
  fprintf_filtered (file, "\t(raw 0x");
  for (j = 0; j < register_size (gdbarch, regnum); j++)
    {
      int idx = gdbarch_byte_order (gdbarch)
		== BFD_ENDIAN_BIG ? j : register_size
		(gdbarch, regnum) - 1 - j;
      fprintf_filtered (file, "%02x", raw_buffer[idx]);
    }
@


1.91
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d2048 4
a2051 1
    fprintf_filtered (file, "*value not available*\n");
@


1.90
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d1070 2
a1071 2
  char *val;
  char valbuf[8];
d1116 1
a1116 1
			(char *) value_contents (args[argnum]), len);
d1118 1
a1118 1
		memcpy (valbuf, (char *) value_contents (args[argnum]), len);
d1123 1
a1123 1
	    val = (char *) value_contents (args[argnum]);
d1130 1
a1130 2
		  write_memory (sp + stack_offset, (const bfd_byte *) val,
		  		argreg_size);
d1155 1
a1155 1
	  val = (char *) value_contents (args[argnum]);
d1289 1
a1289 1
			 const void *valbuf)
d1301 1
a1301 1
			      (char *) valbuf + len - 4 - i);
d1303 1
a1303 1
	  regcache_raw_write (regcache, regnum++, (char *) valbuf + i);
d1451 1
a1451 1
				  struct type *type, char *from, char *to)
d1532 1
a1532 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1708 1
a1708 1
  char temp_buffer[MAX_REGISTER_SIZE];
d1723 1
a1723 1
			     + register_size (gdbarch, 
d1735 2
a1736 3
			    ((char *) buffer
			     + register_size (gdbarch, 
					      base_regnum) * portion));
d1747 2
a1748 3
			    ((char *) buffer
			     + register_size (gdbarch, 
					      base_regnum) * portion));
d1807 1
a1807 1
			      ((char *) buffer
@


1.89
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d240 1
a240 1
  struct minimal_symbol *sym;
d251 2
a252 2
  if (sym)
    return MSYMBOL_IS_SPECIAL (sym);
@


1.88
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1264 1
a1264 1
	  char buf[8];
d1293 1
a1293 1
  char buf[64];	/* more than enough...  */
@


1.87
log
@rename frame_register_read into deprecated_frame_register_read.

gdb/ChangeLog:

        * frame.h (deprecated_frame_register_read): Renames
        frame_register_read.
        * frame.c (deprecated_frame_register_read): Renames
        frame_register_read.  Update all callers.
        * i386-tdep.c: Update all callers of frame_register_read.
        * infcmd.c: Likewise.
        * jit.c: Likewise.
        * mips-tdep.c: Likewise.
        * mt-tdep.c: Likewise.
        * sh64-tdep.c: Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1993-2005, 2007-2012 Free Software Foundation, Inc.
@


1.86
log
@	* configure: Rebuild.
	* configure.ac (build_warnings): Add -Wempty-body.
	* m68k-tdep.c (m68k_gdbarch_init): Remove empty 'if'.
	* remote.c (handle_notification): Use braces for empty 'else' body.
	* s390-tdep.c (s390_analyze_prologue): Use braces for empty
	'else' body.
	* sh64-tdep.c (sh64_push_dummy_call): Use braces for empty
	'else' body.
	* solib-som.c (som_relocate_section_addresses): Use braces
	for empty 'else' body.
	* ui-file.c (stdio_file_write): Use braces for empty 'if' body.
	(stdio_file_write_async_safe, stdio_file_fputs): Likewise.
@
text
@d1934 1
a1934 1
  if (!frame_register_read (frame, regnum, raw_buffer))
d2050 1
a2050 1
  if (!frame_register_read (frame, regnum, raw_buffer))
@


1.85
log
@gdb/
	* NEWS: Document the deprecation of SH's 'regs' command.
	* inferior.h (all_registers_info): Add function declaration.
	* sh-tdep.c (sh_show_regs): Remove variable.
	(sh_generic_show_regs, sh3_show_regs, sh2e_show_regs, sh2a_show_regs)
	(sh2a_nofpu_show_regs, sh3e_show_regs, sh3_dsp_show_regs)
	(sh4_show_regs, sh4_nofpu_show_regs, sh_dsp_show_regs)
	(sh_show_regs_command): Remove functions.
	(sh_gdbarch_init): Don't set sh_show_regs.
	(_initialize_sh_tdep): Make the 'regs' command an deprecated alias to
	'info all-registers'.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs)
	(sh64_show_regs): Remove functions.
	* sh64-tdep.h (sh64_show_regs): Remove function declaration.

gdb/doc/
	* gdb.texinfo: Document the deprecation of SH's 'regs' command.
@
text
@d1178 4
a1181 4
		;
		/* Store it as the integers, 8 bytes at the time, if
		   necessary spilling on the stack.  */
	      
d1205 4
a1208 3
		  ;
		  /* Store it as the integers, 8 bytes at the time, if
                     necessary spilling on the stack.  */
@


1.84
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@a1341 119
static void
sh64_show_media_regs (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int i;

  printf_filtered
    ("PC=%s SR=%s\n",
     phex (get_frame_register_unsigned (frame,
					gdbarch_pc_regnum (gdbarch)), 8),
     phex (get_frame_register_unsigned (frame, SR_REGNUM), 8));

  printf_filtered
    ("SSR=%s SPC=%s\n",
     phex (get_frame_register_unsigned (frame, SSR_REGNUM), 8),
     phex (get_frame_register_unsigned (frame, SPC_REGNUM), 8));
  printf_filtered
    ("FPSCR=%s\n ",
     phex (get_frame_register_unsigned (frame, FPSCR_REGNUM), 8));

  for (i = 0; i < 64; i = i + 4)
    printf_filtered
      ("\nR%d-R%d  %s %s %s %s\n",
       i, i + 3,
      phex (get_frame_register_unsigned (frame, i + 0), 8),
      phex (get_frame_register_unsigned (frame, i + 1), 8),
      phex (get_frame_register_unsigned (frame, i + 2), 8),
      phex (get_frame_register_unsigned (frame, i + 3), 8));

  printf_filtered ("\n");
  
  for (i = 0; i < 64; i = i + 8)
    printf_filtered
      ("FR%d-FR%d  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
       i, i + 7,
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 0),
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 1),
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 2),
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 3),
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 4),
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 5),
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 6),
       (long) get_frame_register_unsigned
	        (frame, gdbarch_fp0_regnum (gdbarch) + i + 7));
}

static void
sh64_show_compact_regs (struct frame_info *frame)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  int i;

  printf_filtered
    ("PC=%s\n",
     phex (get_frame_register_unsigned (frame, PC_C_REGNUM), 8));

  printf_filtered
    ("GBR=%08lx MACH=%08lx MACL=%08lx PR=%08lx T=%08lx\n",
     (long) get_frame_register_unsigned (frame, GBR_C_REGNUM),
     (long) get_frame_register_unsigned (frame, MACH_C_REGNUM),
     (long) get_frame_register_unsigned (frame, MACL_C_REGNUM),
     (long) get_frame_register_unsigned (frame, PR_C_REGNUM),
     (long) get_frame_register_unsigned (frame, T_C_REGNUM));
  printf_filtered
    ("FPSCR=%08lx FPUL=%08lx\n",
     (long) get_frame_register_unsigned (frame, FPSCR_C_REGNUM),
     (long) get_frame_register_unsigned (frame, FPUL_C_REGNUM));

  for (i = 0; i < 16; i = i + 4)
    printf_filtered
      ("\nR%d-R%d  %08lx %08lx %08lx %08lx\n",
       i, i + 3,
       (long) get_frame_register_unsigned (frame, i + 0),
       (long) get_frame_register_unsigned (frame, i + 1),
       (long) get_frame_register_unsigned (frame, i + 2),
       (long) get_frame_register_unsigned (frame, i + 3));

  printf_filtered ("\n");
  
  for (i = 0; i < 16; i = i + 8)
    printf_filtered
      ("FR%d-FR%d  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
       i, i + 7,
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 0),
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 1),
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 2),
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 3),
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 4),
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 5),
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 6),
       (long) get_frame_register_unsigned
		(frame, gdbarch_fp0_regnum (gdbarch) + i + 7));
}

/* FIXME!!! This only shows the registers for shmedia, excluding the
   pseudo registers.  */
void
sh64_show_regs (struct frame_info *frame)
{
  if (pc_is_isa32 (get_frame_pc (frame)))
    sh64_show_media_regs (frame);
  else
    sh64_show_compact_regs (frame);
}

@


1.83
log
@	gdb/
	* breakpoint.h (bp_location): Add related_address member.
	* inferior.h (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* value.h (using_struct_return): Likewise.
	* gdbarch.sh (return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	* breakpoint.c (set_breakpoint_location_function): Initialize
	related_address for bp_gnu_ifunc_resolver breakpoints.
	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Pass the
	requested function's address to gdbarch_return_value.
	* eval.c (evaluate_subexp_standard): Pass the requested
	function's address to using_struct_return.
	* infcall.c (call_function_by_hand): Pass the requested
	function's address to using_struct_return and
	gdbarch_return_value.
	* infcmd.c (get_return_value): Take a pointer to struct value
	instead of struct type for the function requested.
	(print_return_value): Update accordingly.
	(finish_command_continuation): Likewise.
	* stack.c (return_command): Pass the requested function's
	address to using_struct_return and gdbarch_return_value.
	* value.c (using_struct_return): Take a pointer to struct value
	instead of struct type for the function requested.  Pass the
	requested function's address to gdbarch_return_value.
	* python/py-finishbreakpoint.c (finish_breakpoint_object):
	New function_value member, replacing function_type.
	(bpfinishpy_dealloc): Update accordingly.
	(bpfinishpy_pre_stop_hook): Likewise.
	(bpfinishpy_init): Likewise.  Record the requested function's
	address.
	* mips-tdep.c (mips_fval_reg): New enum.
	(mips_o32_push_dummy_call): For MIPS16 FP doubles do not swap
	words put in GP registers.
	(mips_o64_push_dummy_call): Update a comment.
	(mips_o32_return_value): Take a pointer to struct value instead
	of struct type for the function requested and use it to check if
	using the MIPS16 calling convention.  Return the designated
	general purpose registers for floating-point values returned in
	MIPS16 mode.
	(mips_o64_return_value): Likewise.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Update prototype.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* alpha-tdep.c (alpha_return_value): Take a pointer to struct
	value instead of struct type for the function requested.
	* amd64-tdep.c (amd64_return_value): Likewise.
	* amd64-windows-tdep.c (amd64_windows_return_value): Likewise.
	* arm-tdep.c (arm_return_value): Likewise.
	* avr-tdep.c (avr_return_value): Likewise.
	* bfin-tdep.c (bfin_return_value): Likewise.
	* cris-tdep.c (cris_return_value): Likewise.
	* frv-tdep.c (frv_return_value): Likewise.
	* h8300-tdep.c (h8300_return_value): Likewise.
	(h8300h_return_value): Likewise.
	* hppa-tdep.c (hppa32_return_value): Likewise.
	(hppa64_return_value): Likewise.
	* i386-tdep.c (i386_return_value): Likewise.
	* ia64-tdep.c (ia64_return_value): Likewise.
	* iq2000-tdep.c (iq2000_return_value): Likewise.
	* lm32-tdep.c (lm32_return_value): Likewise.
	* m32c-tdep.c (m32c_return_value): Likewise.
	* m32r-tdep.c (m32r_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_return_value): Likewise.
	* m68k-tdep.c (m68k_return_value): Likewise.
	(m68k_svr4_return_value): Likewise.
	* m88k-tdep.c (m88k_return_value): Likewise.
	* mep-tdep.c (mep_return_value): Likewise.
	* microblaze-tdep.c (microblaze_return_value): Likewise.
	* mn10300-tdep.c (mn10300_return_value): Likewise.
	* moxie-tdep.c (moxie_return_value): Likewise.
	* mt-tdep.c (mt_return_value): Likewise.
	* ppc-linux-tdep.c (ppc_linux_return_value): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Likewise.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_return_value): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Likewise.
	* rl78-tdep.c (rl78_return_value): Likewise.
	* rs6000-aix-tdep.c (rs6000_return_value): Likewise.
	* rx-tdep.c (rx_return_value): Likewise.
	* s390-tdep.c (s390_return_value): Likewise.
	* score-tdep.c (score_return_value): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Likewise.
	(sh_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_return_value): Likewise.
	* sparc-tdep.c (sparc32_return_value): Likewise.
	* sparc64-tdep.c (sparc64_return_value): Likewise.
	* spu-tdep.c (spu_return_value): Likewise.
	* tic6x-tdep.c (tic6x_return_value): Likewise.
	* v850-tdep.c (v850_return_value): Likewise.
	* vax-tdep.c (vax_return_value): Likewise.
	* xstormy16-tdep.c (xstormy16_return_value): Likewise.
	* xtensa-tdep.c (xtensa_return_value): Likewise.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.

	gdb/testsuite/
	* gdb.base/return-nodebug.exp: Also test float and double types.
@
text
@a860 1
  int reg_nr;
a1071 1
  char valbuf_tmp[8];
@


1.82
log
@gdb/
	Fix -Wmissing-prototypes build.
	* Makefile.in (HFILES_NO_SRCDIR): Add sh64-tdep.h.
	* sh-tdep.c: Include sh64-tdep.h.
	* sh-tdep.h (sh64_gdbarch_init, sh64_show_regs): Remove declarations.
	* sh64-tdep.c: Include sh64-tdep.h.
	* sh64-tdep.h: New file.
@
text
@d1331 1
a1331 1
sh64_return_value (struct gdbarch *gdbarch, struct type *func_type,
@


1.81
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d49 1
@


1.80
log
@	gdb/
	* frame.c (frame_unwind_register): Throw an error if unwinding the
	register failed.
	* get_prev_frame_1 (get_prev_frame_1): Ask the unwinder if there's
	an unwind stop reason.
	(frame_stop_reason_string): Handle UNWIND_UNAVAILABLE.
	* frame.h (enum unwind_stop_reason) <UNWIND_OUTERMOST,
	UNWIND_UNAVAILABLE>: New.
	* inline-frame.c (inline_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* frame-unwind.c: Include "exceptions.h".
	(frame_unwind_find_by_frame): Swallow NOT_AVAILABLE_ERROR errors.
	(default_frame_unwind_stop_reason): New.
	* frame-unwind.h (frame_unwind_stop_reason_ftype): New typedef.
	(default_frame_unwind_stop_reason): Declare.
	(struct frame_unwind) <stop_reason>: New function pointer.

	* dummy-frame.c: Install default_frame_unwind_stop_reason.
	* dwarf2-frame.c: Include exceptions.h.
	(struct dwarf2_frame_cache) <unavailable_retaddr>: New field.
	(dwarf2_frame_cache): Swallow NOT_AVAILABLE_ERROR errors when
	computing the CFA.  If such an error was thrown, set
	unavailable_retaddr.
	(dwarf2_frame_unwind_stop_reason): New.
	(dwarf2_frame_this_id): Don't build a frame id if the CFA was
	unavailable.
	(dwarf2_frame_unwind): Install dwarf2_frame_unwind_stop_reason.
	(dwarf2_signal_frame_unwind): Ditto.

	* amd64-tdep.c: Include "exceptions.h".
	(struct amd64_frame_cache): New field "base_p".
	(amd64_init_frame_cache): Clear it.
	(amd64_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(amd64_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(amd64_frame_unwind_stop_reason): New.
	(amd64_frame_this_id): Don't build a frame id if the frame base
	was unavailable.
	(amd64_frame_unwind): Install amd64_frame_unwind_stop_reason.
	(amd64_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_sigtramp_frame_unwind_stop_reason): New.
	(amd64_sigtramp_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_sigtramp_frame_unwind): Install
	amd64_sigtramp_frame_unwind_stop_reason.
	(amd64_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(amd64_epilogue_frame_unwind_stop_reason): New.
	(amd64_epilogue_frame_this_id): Don't build a frame id if the
	frame base was unavailable.
	(amd64_epilogue_frame_unwind): Install
	amd64_epilogue_frame_unwind_stop_reason.
	* i386-tdep.c: Include "exceptions.h".
	(struct i386_frame_cache): New field "base_p".
	(i386_init_frame_cache): Clear it.
	(i386_frame_cache_1): New, factored out from amd64_frame_cache.
	Avoid reading registers with functions that throw if the register
	is not necessary to compute the frame base.
	(i386_frame_cache): Reimplement wrapping amd64_frame_cache_1, and
	swallowing NOT_AVAILABLE_ERROR.
	(i386_frame_unwind_stop_reason): New.
	(i386_frame_this_id): Don't build a frame id if the frame base was
	unavailable.
	(i386_frame_prev_register): Handle unavailable SP.
	(i386_frame_unwind): Install i386_frame_unwind_stop_reason.
	(i386_epilogue_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_epilogue_frame_unwind_stop_reason): New.
	(i386_epilogue_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_epilogue_frame_unwind): Install
	i386_epilogue_frame_unwind_stop_reason.
	(i386_sigtramp_frame_cache): Swallow NOT_AVAILABLE_ERROR, and set
	base_p if the frame base was computable.
	(i386_sigtramp_frame_unwind_stop_reason): New.
	(i386_sigtramp_frame_this_id): Don't build a frame id if the frame
	base was unavailable.
	(i386_sigtramp_frame_unwind): Install
	i386_sigtramp_frame_unwind_stop_reason.
	* sentinel-frame.c (sentinel_frame_prev_register): Use the value
	type's size, not the register's.
	(sentinel_frame_unwind): Install default_frame_unwind_stop_reason.

	* alpha-mdebug-tdep.c (alpha_mdebug_frame_unwind): Install
	default_frame_unwind_stop_reason.
	* alpha-tdep.c (alpha_sigtramp_frame_unwind)
	(alpha_heuristic_frame_unwind): Ditto.
	* amd64obsd-tdep.c (amd64obsd_trapframe_unwind): Ditto.
	* arm-tdep.c (arm_prologue_unwind, arm_stub_unwind): Ditto.
	* avr-tdep.c (avr_frame_unwind): Ditto.
	* cris-tdep.c (cris_sigtramp_frame_unwind, cris_frame_unwind):
	Ditto.
	* frv-linux-tdep.c (frv_linux_sigtramp_frame_unwind): Ditto.
	* frv-tdep.c (frv_frame_unwind): Ditto.
	* h8300-tdep.c (h8300_frame_unwind): Ditto.
	* hppa-hpux-tdep.c (hppa_hpux_sigtramp_frame_unwind): Ditto.
	* hppa-linux-tdep.c (hppa_linux_sigtramp_frame_unwind): Ditto.
	* hppa-tdep.c (hppa_frame_unwind, hppa_fallback_frame_unwind)
	(hppa_stub_frame_unwind): Ditto.
	* i386obsd-tdep.c (i386obsd_trapframe_unwind): Ditto.
	* ia64-tdep.c (ia64_frame_unwind, ia64_sigtramp_frame_unwind)
	(ia64_libunwind_frame_unwind)
	(ia64_libunwind_sigtramp_frame_unwind): Ditto.
	* iq2000-tdep.c (iq2000_frame_unwind): Ditto.
	* lm32-tdep.c (lm32_frame_unwind): Ditto.
	* m32c-tdep.c (m32c_unwind): Ditto.
	* m32r-linux-tdep.c (m32r_linux_sigtramp_frame_unwind): Ditto.
	* m32r-tdep.c (m32r_frame_unwind): Ditto.
	* m68hc11-tdep.c (m68hc11_frame_unwind): Ditto.
	* m68k-tdep.c (m68k_frame_unwind): Ditto.
	* m68klinux-tdep.c (m68k_linux_sigtramp_frame_unwind): Ditto.
	* m88k-tdep.c (m88k_frame_unwind): Ditto.
	* mep-tdep.c (mep_frame_unwind): Ditto.
	* microblaze-tdep.c (microblaze_frame_unwind): Ditto.
	* mips-tdep.c (mips_insn16_frame_unwind, mips_insn32_frame_unwind)
	(mips_stub_frame_unwind): Ditto.
	* mn10300-tdep.c (mn10300_frame_unwind): Ditto.
	* moxie-tdep.c (moxie_frame_unwind): Ditto.
	* mt-tdep.c (mt_frame_unwind): Ditto.
	* ppc-linux-tdep.c (ppu2spu_unwind): Ditto.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_unwind): Ditto.
	* rs6000-tdep.c (rs6000_frame_unwind): Ditto.
	* s390-tdep.c (s390_frame_unwind, s390_stub_frame_unwind)
	(s390_sigtramp_frame_unwind): Ditto.
	* score-tdep.c (score_prologue_unwind): Ditto.
	* sh-tdep.c (sh_frame_unwind): Ditto.
	* sh64-tdep.c (sh64_frame_unwind): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_sigtramp_frame_unwind): Ditto.
	* sparc-tdep.c (sparc32_frame_unwind): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_sigtramp_frame_unwind): Ditto.
	* sparc64-tdep.c (sparc64_frame_unwind): Ditto.
	* sparc64fbsd-tdep.c (sparc64fbsd_sigtramp_frame_unwind): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_frame_unwind): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_frame_unwind)
	(sparc64obsd_trapframe_unwind): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_sigcontext_frame_unwind): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_sigtramp_frame_unwind): Ditto.
	* spu-tdep.c (spu_frame_unwind, spu2ppu_unwind): Ditto.
	* v850-tdep.c (v850_frame_unwind): Ditto.
	* vax-tdep.c (vax_frame_unwind): Ditto.
	* vaxobsd-tdep.c (vaxobsd_sigtramp_frame_unwind): Ditto.
	* xstormy16-tdep.c (frame_unwind xstormy16_frame_unwind): Ditto.
	* xtensa-tdep.c (xtensa_unwind): Ditto.
@
text
@d3 1
a3 3
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.80.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1993-2005, 2007-2012 Free Software Foundation, Inc.
@


1.79
log
@	gdb/
	* regcache.h (regcache_raw_read, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_signed)
	(regcache_raw_read_unsigned, regcache_raw_read_part)
	(regcache_cooked_read, regcache_cooked_read_signed)
	(regcache_cooked_read_unsigned, regcache_cooked_read_part)
	(regcache_cooked_read_ftype): Change return to enum
	register_status.
	* regcache.c: Include exceptions.h
	(regcache_save): Adjust to handle REG_UNAVAILABLE registers.
	(do_cooked_read): Change return to enum register_status.  Always
	forward to regcache_cooked_read.
	(regcache_raw_read): Change return to enum register_status.  If
	the register is not REG_VALID, memset the buffer.  Return the
	register's status.
	(regcache_raw_read_signed): Handle non-REG_VALID registers and
	return the register's status.
	(regcache_raw_read_unsigned): Ditto.
	(regcache_cooked_read): Change return to enum register_status.
	Assert that with read-only regcaches, the register's status must
	be known.  If the regcache is read-only, and the register is not
	REG_VALID, memset the buffer.  Return the register's status.
	(regcache_cooked_read_signed): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_cooked_read_unsigned): Change return to enum
	register_status.  Handle non-REG_VALID registers and return the
	register's status.
	(regcache_xfer_part, regcache_raw_read_part)
	(regcache_cooked_read_part): Change return to enum
	register_status.  Return the register's status.
	(regcache_read_pc): Throw NOT_AVAILABLE_ERROR if the register is
	unavailable.
	(regcache_dump): Handle unavailable cooked registers.
	* frame.c (do_frame_register_read): Adjust interface to match
	regcache_cooked_read_ftype.
	* gdbarch.sh (pseudo_register_read): Change return to enum
	register_status.
	* gdbarch.h, gdbarch.c: Regenerate.

	* i386-tdep.h (i386_pseudo_register_read): Change return to enum
	register_status.
	* i386-tdep.c (i386_pseudo_register_read): Change return to enum
	register_status.  If reading a raw register indicates the raw
	register is not valid, return the raw register's status,
	otherwise, return REG_VALID.
	* amd64-tdep.c (amd64_pseudo_register_read): Change return to enum
	register_status.  Handle non-REG_VALID raw registers and return
	the register's status.
	* arm-tdep.c (arm_neon_quad_read)
	(arm_pseudo_read): Change return to enum register_status.  Handle
	non-REG_VALID raw registers and return the register's status.
	* avr-tdep.c (avr_pseudo_register_read): Ditto.
	* frv-tdep.c (frv_pseudo_register_read): Ditto.
	* h8300-tdep.c (h8300_pseudo_register_read): Ditto.
	* hppa-tdep.c (hppa_pseudo_register_read): Ditto.
	* m32c-tdep.c (m32c_move_reg_t): Change return to enum
	register_status.
	(m32c_raw_read, m32c_raw_write, m32c_banked_read)
	(m32c_banked_write, m32c_sb_read, m32c_sb_write, m32c_part_read)
	(m32c_part_write, m32c_cat_read, m32c_cat_write)
	(m32c_r3r2r1r0_read, m32c_r3r2r1r0_write)
	(m32c_pseudo_register_read): Change return to enum
	register_status.  Adjust.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* mep-tdep.c (mep_pseudo_cr32_read): Change return to enum
	register_status.  Return the register's status.
	(mep_pseudo_cr64_read, mep_pseudo_register_read): Ditto.
	* mips-tdep.c (mips_pseudo_register_read): Ditto.
	* mt-tdep.c (mt_pseudo_register_read): Ditto.
	* rs6000-tdep.c (move_ev_register_func): New typedef.
	(e500_move_ev_register): Use it.  Change return to enum
	register_status.  Return the register's status.
	(do_regcache_raw_read): New function.
	(do_regcache_raw_write): New function.
	(e500_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.  Use
	do_regcache_raw_read.
	(e500_pseudo_register_write): Adjust.  Use do_regcache_raw_write.
	(dfp_pseudo_register_read): Change return to enum register_status.
	Return the register's status.
	(vsx_pseudo_register_read): Ditto.
	(efpr_pseudo_register_read): Ditto.
	(rs6000_pseudo_register_read): Ditto.
	* s390-tdep.c (s390_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh64-tdep.c (pseudo_register_read_portions): New function.
	(sh64_pseudo_register_read): Change return to enum
	register_status.  Use pseudo_register_read_portions.  Return the
	register's status.
	* ia64-tdep.c (ia64_pseudo_register_read): Change return to enum
	register_status.  Return the register's status.
	* sh-tdep.c (pseudo_register_read_portions): New function.
	(sh_pseudo_register_read): Change return to enum register_status.
	Use pseudo_register_read_portions.  Return the register's status.
	* sparc-tdep.c (sparc32_pseudo_register_read): Change return to
	enum register_status.  Return the register's status.
	* sparc64-tdep.c (sparc64_pseudo_register_read): Ditto.
	* spu-tdep.c (spu_pseudo_register_read_spu)
	(spu_pseudo_register_read): Ditto.
	* xtensa-tdep.c (xtensa_register_read_masked)
	(xtensa_pseudo_register_read): Ditto.
	* bfin-tdep.c (bfin_pseudo_register_read): Ditto.
@
text
@d2440 1
@


1.78
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* s390-tdep.c: Comment cleanup, mostly periods and spaces.
	* score-tdep.c: Ditto.
	* score-tdep.h: Ditto.
	* ser-base.c: Ditto.
	* ser-go32.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* ser-mingw.c: Ditto.
	* ser-pipe.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* sh64-tdep.c: Ditto.
	* shnbsd-nat.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* solib.c: Ditto.
	* solib-darwin.c: Ditto.
	* solib-frv.c: Ditto.
	* solib.h: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-spu.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solist.h: Ditto.
	* sol-thread.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* source.h: Ditto.
	* sparc64-linux-tdep.c: Ditto.
	* sparc64-tdep.c: Ditto.
	* sparc-linux-nat.c: Ditto.
	* sparc-linux-tdep.c: Ditto.
	* sparc-sol2-nat.c: Ditto.
	* sparc-sol2-tdep.c: Ditto.
	* sparc-tdep.c: Ditto.
	* sparc-tdep.h: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.h: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target.c: Ditto.
	* target-descriptions.c: Ditto.
	* target-descriptions.h: Ditto.
	* target.h: Ditto.
	* target-memory.c: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* trad-frame.h: Ditto.
	* typeprint.c: Ditto.
@
text
@d1622 26
a1647 1
static void
a1652 1
  int portion;
d1655 1
d1665 9
a1673 9
      for (portion = 0; portion < 2; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   (temp_buffer
			    + register_size (gdbarch, base_regnum) * portion));

      /* We must pay attention to the endianness.  */
      sh64_register_convert_to_virtual (gdbarch, reg_nr,
					register_type (gdbarch, reg_nr),
					temp_buffer, buffer);
d1675 1
d1678 1
a1678 1
  else if (reg_nr >= FPP0_REGNUM 
d1686 2
a1687 4
      for (portion = 0; portion < 2; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + register_size (gdbarch, base_regnum) * portion));
d1698 2
a1699 4
      for (portion = 0; portion < 4; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + register_size (gdbarch, base_regnum) * portion));
d1709 3
a1711 1
      regcache_raw_read (regcache, base_regnum, temp_buffer);
d1716 1
d1727 1
a1727 1
      regcache_raw_read (regcache, base_regnum, buffer);
d1737 10
a1746 9
      for (portion = 0; portion < 2; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   (temp_buffer
			    + register_size (gdbarch, base_regnum) * portion));

      /* We must pay attention to the endianness.  */
      sh64_register_convert_to_virtual (gdbarch, reg_nr, 
					register_type (gdbarch, reg_nr),
					temp_buffer, buffer);
d1757 2
a1758 4
      for (portion = 0; portion < 4; portion++)
	regcache_raw_read (regcache, base_regnum + portion, 
			   ((char *) buffer
			    + register_size (gdbarch, base_regnum) * portion));
d1789 3
a1791 1
      regcache_raw_read (regcache, fpscr_base_regnum, temp_buffer);
d1795 3
a1797 1
      regcache_raw_read (regcache, sr_base_regnum, temp_buffer);
d1807 2
d1817 1
a1817 1
      regcache_raw_read (regcache, base_regnum, buffer);
d1819 2
@


1.77
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* charset.c (validate): Internationalization.
	* coffread.c (read_one_sym): Ditto.
	* dwarf2read.c (dwarf2_attach_fields_to_type): Ditto.
	* h8300-tdep.c (H8300_extract_return_value): Ditto.
	* inflow.c (new_tty): Ditto.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* mep-tdep.c (mep_store_return_value): Ditto.
	* score-tdep.c (score7_fetch_insn): Ditto.
	* ser-mingw.c (pipe_windows_open): Ditto.
	* sh64-tdep.c (sh64_extract_return_value): Ditto.
	* spu-tdep.c (spu_register_type): Ditto.
	* tracepoint.c (trace_find_command): Ditto.
	* valarith.c (value_pos): Ditto.
@
text
@d22 2
a23 4
/*
   Contributed by Steve Chamberlain
   sac@@cygnus.com
 */
d48 1
a48 1
/* registers numbers shared with the simulator */
d72 1
a72 1
  /* Flag showing that a frame has been created in the prologue code. */
d98 1
a98 1
       point register. Unfortunately on the sh5, the floating point
d149 1
a149 1
    /* target registers (64-bit) 68-75*/
d155 1
a155 1
    /* single precision floating point registers (32-bit) 77-140*/
d171 1
a171 1
    /* floating point pairs (pseudo) 173-204*/
d177 1
a177 1
    /* floating point vectors (4 floating point regs) (pseudo) 205-220*/
d181 1
a181 1
    /* SH COMPACT MODE (ISA 16) (all pseudo) 221-272*/
d187 6
a192 3
    "fr0_c", "fr1_c", "fr2_c",  "fr3_c",  "fr4_c",  "fr5_c",  "fr6_c",  "fr7_c",
    "fr8_c", "fr9_c", "fr10_c", "fr11_c", "fr12_c", "fr13_c", "fr14_c", "fr15_c",
    "dr0_c", "dr2_c", "dr4_c",  "dr6_c",  "dr8_c",  "dr10_c", "dr12_c", "dr14_c",
d194 1
a194 1
    /* FIXME!!!! XF0 XF15, XD0 XD14 ?????*/
d259 2
a260 1
sh64_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pcptr, int *lenptr)
d270 1
a270 1
     and in little endian mode to 0x3b, 0x0*/
d276 3
a278 1
	  static unsigned char big_breakpoint_media[] = {0x6f, 0xf5, 0xff, 0xf0};
d294 3
a296 1
	  static unsigned char little_breakpoint_media[] = {0xf0, 0xff, 0xf5, 0x6f};
d390 2
a391 1
#define IS_MOV_SP_FP_MEDIA(x)  	(IS_ADDL_SP_FP_MEDIA(x) || IS_ADD_SP_FP_MEDIA(x))
d410 1
a410 1
/* FIXME: Recognize the float and double register moves too! */
d412 3
a414 1
((((x) & 0xfc0ffc0f) == 0x0009fc00) && (((x) & 0x03f00000) >= 0x00200000 && ((x) & 0x03f00000) <= 0x00900000))
d423 5
a427 5
/* ST.B R14,0,Rn     Rn-->(R14+0) 1010 0000 1110 0000 0000 00nn nnnn 0000*/
/* ST.W R14,0,Rn     Rn-->(R14+0) 1010 0100 1110 0000 0000 00nn nnnn 0000*/
/* ST.L R14,0,Rn     Rn-->(R14+0) 1010 1000 1110 0000 0000 00nn nnnn 0000*/
/* FST.S R14,0,FRn   Rn-->(R14+0) 1011 0100 1110 0000 0000 00nn nnnn 0000*/
/* FST.D R14,0,DRn   Rn-->(R14+0) 1011 1100 1110 0000 0000 00nn nnnn 0000*/
d438 2
a439 1
((((x) & 0xf00f) == 0x6003) && (((x) & 0x00f0) >= 0x0020) && (((x) & 0x00f0) <= 0x0090))
d444 2
a445 1
(((((x) & 0xff0f) == 0x2e02) && (((x) & 0x00f0) >= 0x0020) && ((x) & 0x00f0) <= 0x0090))
d464 1
a464 1
/* Skip any prologue before the guts of a function */
d514 1
a514 1
		 is where the debug info says it is. This can happen after
d539 1
a539 1
		 is where the debug info says it is. This can happen after
d556 1
a556 1
		 passed correctly to the function. Only after this
d558 1
a558 1
		 where they are supposed to be. This happens in case the
d570 1
a570 1
		 true after the argument decoder is called. Such a call
d574 1
a574 1
                 a NOP instruction. After these, the prologue is over!  */
d625 2
a626 1
	      || IS_ADDIL_SP_MEDIA (w) || IS_ADDI_SP_MEDIA (w) || IS_PTABSL_R18 (w))
d713 1
a713 1
/* For double precision floating point registers, i.e 2 fp regs.*/
d723 1
a723 1
/* For pairs of floating point registers */
d903 3
a905 2
		  cache->saved_regs[PR_REGNUM] =
		    cache->sp_offset - ((((next_insn & 0xf) ^ 0x8) - 0x8) << 2);
d917 1
a917 1
		 registers. We are interested in this value, because it
d931 1
a931 1
	      /* Store PR at r0_val-4 from SP. Decrement r0 by 4*/
d938 1
a938 1
	      /* Store R14 at r0_val-4 from SP. Decrement r0 by 4 */
d957 3
a959 2
	    cache->saved_regs[PR_REGNUM] = 
	      cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10, 9) << 3);
d962 3
a964 2
	    cache->saved_regs[PR_REGNUM] = 
	      cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10, 9) << 2);
d967 3
a969 2
	    cache->saved_regs[MEDIA_FP_REGNUM] =
	      cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10, 9) << 3);
d972 3
a974 2
	    cache->saved_regs[MEDIA_FP_REGNUM] =
	      cache->sp_offset - (sign_extend ((insn & 0xffc00) >> 10, 9) << 2);
d1007 1
a1007 1
   stack.  This includes doubles, long longs, and larger aggregates. 
d1032 1
a1032 1
   to R7.   */
d1042 1
a1042 1
   arg1 -->R2, arg2 --> R3, arg3 -->FR0, arg4 --> R5. I.e. R4 is not used.
d1047 2
a1048 2
   arg8->R9, arg9->(0,SP)stack(8-byte aligned), arg10->FR0, arg11->stack(16,SP).
   I.e. there is hole in the stack.
d1081 1
a1081 1
  /* first force sp to a 8-byte alignment */
d1085 1
a1085 1
     register */
d1091 1
a1091 1
  /* Now make sure there's space on the stack */
d1094 1
a1094 1
  sp -= stack_alloc;		/* make room on stack for args */
d1116 1
a1116 1
	      /* value gets right-justified in the register or stack word */
d1132 1
a1132 1
		  /* must go on the stack */
d1142 1
a1142 1
		  /* there's room in a register */
d1145 2
a1146 1
		  regcache_cooked_write_unsigned (regcache, int_argreg, regval);
d1150 1
a1150 1
		 and partly on the stack. FIXME: argreg is incremented
d1162 1
a1162 1
	      /* Where is it going to be stored? */
d1168 1
a1168 1
		 register set? */
d1188 1
a1188 1
		/* Where is it going to be stored? */
d1193 1
a1193 1
		   Are we still within the allowed register set? */
d1214 1
a1214 1
  /* Store return address. */
d1240 1
a1240 1
	  /* Return value stored in gdbarch_fp0_regnum */
d1246 1
a1246 1
	  /* return value stored in DR0_REGNUM */
d1267 1
a1267 1
	  /* Result is in register 2. If smaller than 8 bytes, it is padded 
d1287 1
a1287 1
   depending on the type of the return value. In all the other cases
d1680 1
a1680 1
  /* sh compact pseudo registers. 1-to-1 with a shmedia register */
d1690 2
a1691 1
      memcpy (buffer, temp_buffer + offset, 4); /* get LOWER 32 bits only????*/
d1764 1
a1764 1
      /* Get FPSCR into a local buffer */
d1776 1
a1776 1
      /* Store that in out buffer!!! */
d1843 1
a1843 1
  /* sh compact general pseudo registers. 1-to-1 with a shmedia
d1858 1
a1858 1
      /* Write as an 8 byte quantity */
d1863 2
a1864 2
  /* sh floating point compact pseudo registers. 1-to-1 with a shmedia
     registers. Both are 4 bytes.  */
d2012 1
a2012 1
{				/* do values for FP (float) regs */
d2014 1
a2014 1
  double flt;	/* double extracted from raw hex data */
d2019 2
a2020 4
  raw_buffer = (unsigned char *) alloca
				 (register_size (gdbarch,
						 gdbarch_fp0_regnum
						   (gdbarch)));
d2027 3
a2029 2
  /* Get the register as a number */ 
  flt = unpack_double (builtin_type (gdbarch)->builtin_float, raw_buffer, &inv);
d2181 1
a2181 1
  if (regnum != -1)		/* do one specified register */
d2189 1
a2189 1
    /* do all (or most) registers */
d2208 1
a2208 1
		  /* true for "INFO ALL-REGISTERS" command */
d2239 1
a2239 1
  if (regnum != -1)		/* do one specified register */
d2250 1
a2250 1
    /* do all compact registers */
d2321 1
a2321 1
     actually the frame pointer of the calling frame. */
@


1.76
log
@run copyright.sh for 2011.
@
text
@d1261 1
a1261 1
	error ("bad size for return value");
d1575 2
a1576 1
    error ("sh64_register_convert_to_virtual called with non DR register number");
d1600 2
a1601 1
    error ("sh64_register_convert_to_raw called with non DR register number");
d2007 1
a2007 1
    error ("can't read register %d (%s)",
d2166 1
a2166 1
	error ("Not a valid register for the current processor type");
d2224 1
a2224 1
	error ("Not a valid register for the current processor type");
d2227 1
a2227 1
        error ("Not a valid register for the current processor mode.");
@


1.75
log
@	* breakpoint.c (update_watchpoint, _initialize_breakpoint): Remove
	unnecessary space in string.
	* filesystem.c (_initialize_filesystem): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* infcmd.c (step_once): Ditto.
	* infrun.c (_initialize_infrun): Ditto.
	* linux-nat.c (linux_child_follow_fork): Ditto.
	* maint.c (maintenance_deprecate): Ditto.
	* memattr.c (_initialize_mem): Ditto.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* monitor.c (monitor_open): Ditto.
	* procfs.c (procfs_xfer_memory): Ditto.
	* reverse.c (bookmarks_info): Ditto.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Ditto.
	* stack.c (_initialize_stack): Ditto.
	* tracepoint.c (_initialize_tracepoint): Ditto.
	* xtensa-tdep.c (xtensa_supply_gregset,
	xtensa_regset_from_core_section): Ditto.
@
text
@d4 2
a5 1
   2003, 2004, 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.74
log
@gdb
	PR gdb/9977, PR exp/11636:
	* value.h (value_offset): Update.
	(struct lval_funcs) <check_validity>: New field.
	<copy_closure>: Make argument const.
	(value_computed_closure): Update.
	(value_contents_for_printing): Declare.
	(value_bits_valid): Likewise.
	(val_print): Likewise.
	(set_value_component_location): Update.
	(value_entirely_optimized_out): Declare.
	* value.c (value_offset): Argument now const.
	(require_not_optimized_out): New function.
	(value_contents_for_printing): New function.
	(value_contents_all): Call require_not_optimized_out.
	(value_contents): Likewise.
	(value_bits_valid): New function.
	(value_computed_closure): Argument now const.
	(set_value_component_location): Make 'whole' argument const.
	(value_entirely_optimized_out): New function.
	(value_bitsize): Argument now 'const'.
	(value_bitpos): Likewise.
	(value_type): Likewise.
	* valprint.h (val_print_array_elements): Update.
	* valprint.c (val_print): Add 'val' argument.  Use
	valprint_check_validity.
	(valprint_check_validity): New function.
	(value_check_printable): Use value_entirely_optimized_out.
	(common_val_print): Update.
	(value_print): Likewise.
	(val_print_array_elements): Add 'val' argument.
	* valops.c (value_fetch_lazy): Use value_contents_for_printing,
	value_bits_valid.  Reinit frame cache for lval_computed.
	* sh64-tdep.c (sh64_do_register): Update.
	* scm-valprint.c (scm_val_print): Add 'val' argument.
	* scm-lang.h (scm_val_print): Update.
	* python/python.h (apply_val_pretty_printer): Update.
	* python/py-prettyprint.c (apply_val_pretty_printer): Add 'val'
	argument.  Call set_value_component_location.
	* printcmd.c (print_scalar_formatted): Update.
	* p-valprint.c (pascal_val_print): Add 'val' argument.
	(pascal_object_print_value_fields): Likewise.
	(pascal_object_print_value): Likewise.
	(pascal_object_print_static_field): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* mt-tdep.c (mt_registers_info): Update.
	* mi/mi-main.c (get_register): Update.
	(mi_cmd_data_evaluate_expression): Use common_val_print.
	* m2-valprint.c (m2_print_array_contents): Add 'val' argument.
	(m2_print_unbounded_array): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* language.h (struct language_defn) <la_val_print>: Add 'val'
	argument.
	(LA_VAL_PRINT): Likewise.
	* language.c (unk_lang_val_print): Add 'val' argument.
	* jv-valprint.c (java_print_value_fields): Add 'val' argument.
	(java_val_print): Likewise.
	* jv-lang.h (java_val_print): Add 'val' argument.
	* infcmd.c (default_print_registers_info): Update.
	* f-valprint.c (f77_print_array_1): Add 'val' argument.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Add 'val' argument.
	* dwarf2loc.c (read_pieced_value): Use value_bitsize and
	value_bitpos.
	<DWARF_VALUE_OPTIMIZED_OUT>: Don't print warning.  Call
	set_value_optimized_out.
	(write_pieced_value): Use value_bitsize and value_bitpos.
	<default>: Don't exit loop.
	(check_pieced_value_validity): New function.
	(pieced_value_funcs): Reference check_pieced_value_validity,
	check_pieced_value_invalid.
	(copy_pieced_value_closure): Update.
	(check_pieced_value_bits): New function.
	(check_pieced_value_invalid): New function.
	* d-valprint.c (dynamic_array_type): Add 'val' argument.
	(d_val_print): Likewise.
	* d-lang.h (d_val_print): Update.
	* cp-valprint.c (cp_print_value_fields): Add 'val' argument.
	(cp_print_value_fields_rtti): Likewise.
	(cp_print_value): Likewise.
	(cp_print_static_field): Update.
	* c-valprint.c (c_val_print): Add 'val' argument.
	(c_value_print): Update.
	* c-lang.h (c_val_print): Update.
	(cp_print_value_fields): Likewise.
	(cp_print_value_fields_rtti): Likewise.
	* ada-valprint.c (struct ada_val_print_args): Remove.
	(val_print_packed_array_elements): Add 'val' argument.
	(ada_val_print): Likewise.  Rewrite.
	(ada_val_print_stub): Remove.
	(ada_val_print_array): Add 'val' argument.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Update.
	(print_record): Add 'val' argument.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print): Update.
gdb/testsuite
	PR gdb/9977, PR exp/11636::
	* gdb.dwarf2/pieces.exp (pieces_test_f3): Remove kfail.
	(pieces_test_f6): Update expected output.
@
text
@d1333 1
a1333 1
    ("PC=%s SR=%s \n",
d1339 1
a1339 1
    ("SSR=%s SPC=%s \n",
d1386 1
a1386 1
    ("PC=%s \n",
@


1.73
log
@	Remove remaining "%ll" uses.
	* go32-nat.c (go32_pte_for_address): Replace "0x%llx" using
	hex_string call.
	* rs6000-nat.c (rs6000_ptrace64): Idem.
	* solib-pa64.c (pa64_current_sos): Idem.
	* solib-spu.c (spu_current_sos): Idem.
	* linux-nat.c (linux_nat_find_memory_regions): Replace "%lld" using
	plongest call.
	* nto-procfs.c (procfs_meminfo): Replace "0x%016llx" using
	phex (VAR, 8) call.
	* sh64-tdep.c (sh64_show_media_regs): Idem.
@
text
@d2124 1
a2124 1
	     file, 0, &opts, current_language);
d2129 1
a2129 1
	     file, 0, &opts, current_language);
@


1.72
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d1333 1
a1333 1
    ("PC=%s SR=%016llx \n",
d1336 1
a1336 1
     (long long) get_frame_register_unsigned (frame, SR_REGNUM));
d1339 3
a1341 3
    ("SSR=%016llx SPC=%016llx \n",
     (long long) get_frame_register_unsigned (frame, SSR_REGNUM),
     (long long) get_frame_register_unsigned (frame, SPC_REGNUM));
d1343 2
a1344 2
    ("FPSCR=%016lx\n ",
     (long) get_frame_register_unsigned (frame, FPSCR_REGNUM));
d1348 1
a1348 1
      ("\nR%d-R%d  %016llx %016llx %016llx %016llx\n",
d1350 4
a1353 4
      (long long) get_frame_register_unsigned (frame, i + 0),
      (long long) get_frame_register_unsigned (frame, i + 1),
      (long long) get_frame_register_unsigned (frame, i + 2),
      (long long) get_frame_register_unsigned (frame, i + 3));
@


1.71
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.70
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d484 2
a485 1
look_for_args_moves (CORE_ADDR start_pc, int media_mode)
d487 1
d496 2
a497 1
	  w = read_memory_integer (UNMAKE_ISA32_ADDR (here), insn_size);
d506 1
a506 1
						   insn_size);
d521 1
a521 1
	  w = read_memory_integer (here, insn_size);
d530 2
a531 1
	      int next_insn = 0xffff & read_memory_integer (here, insn_size);
d564 2
a565 1
	      int next_insn = 0xffff & read_memory_integer (here, insn_size);
d569 2
a570 1
		  next_insn = 0xffff & read_memory_integer (here, insn_size);
d586 1
a586 1
sh64_skip_prologue_hard_way (CORE_ADDR start_pc)
d588 1
d608 2
a609 1
	  int w = read_memory_integer (UNMAKE_ISA32_ADDR (here), insn_size);
d628 2
a629 1
		start_pc = look_for_args_moves (here - insn_size, media_mode);
d635 1
a635 1
	  int w = 0xffff & read_memory_integer (here, insn_size);
d655 2
a656 1
		start_pc = look_for_args_moves (here - insn_size, media_mode);
d680 1
a680 1
    return sh64_skip_prologue_hard_way (pc);
d858 1
d880 1
a880 1
				  insn_size);
d886 2
a887 1
	      int next_insn = read_memory_integer (pc + insn_size, insn_size);
d1044 1
d1125 2
a1126 1
		  regval = extract_unsigned_integer (val, argreg_size);
d1214 1
d1605 1
d1745 1
a1745 1
      fpscr_value = extract_unsigned_integer (temp_buffer, 4);
d1749 1
a1749 1
      sr_value = extract_unsigned_integer (temp_buffer, 4);
d1755 1
a1755 1
      store_unsigned_integer (buffer, 4, fpscr_c_value);
d1773 1
d1912 1
a1912 1
      fpscr_c_value = extract_unsigned_integer (buffer, 4);
d1922 1
a1922 1
      old_fpscr_value = extract_unsigned_integer (temp_buffer, 4);
d1925 1
a1925 1
      store_unsigned_integer (temp_buffer, 4, fpscr_value);
d1929 1
a1929 1
      old_sr_value = extract_unsigned_integer (temp_buffer, 4);
d1932 1
a1932 1
      store_unsigned_integer (temp_buffer, 4, sr_value);
d2341 1
d2360 2
a2361 1
	  val = read_memory_unsigned_integer (cache->saved_regs[regnum], 4);
@


1.69
log
@	* gdbtypes.c (lookup_array_range_type): Add prototype.
	(lookup_string_range_type): Likewise.
	* gdbtypes.c (lookup_array_range_type): New function.
	(lookup_string_range_type): Likewise.

	* ax-gdb.c (gen_repeat): Use lookup_array_range_type.
	* parse.c (follow_types): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* gnu-v3-abi.c (build_gdb_vtable_type): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
	* value.c (allocate_repeat_value): Likewise.
	* valops.c (value_array, value_cstring): Likewise.
	* valops.c (value_string): Use lookup_string_range_type.
@
text
@d1319 2
a1320 2
     paddr (get_frame_register_unsigned (frame,
					 gdbarch_pc_regnum (gdbarch))),
d1372 1
a1372 1
     paddr (get_frame_register_unsigned (frame, PC_C_REGNUM)));
@


1.68
log
@	* doublest.c (NAN): Remove unused define.
	(extract_floating_by_length, deprecated_extract_floating): Remove.
	(store_floating_by_length, deprecated_store_floating): Remove.
	(extract_typed_floating): Do not call extract_floating_by_length.
	(store_typed_floating): Do not call store_floating_by_length.
	(convert_typed_floating): Remove redundant assertions.
	* doublest.h (deprecated_extract_floating): Remove.
	(deprecated_store_floating): Remove.
	* sh64-tdep.c (sh64_register_convert_to_raw): Call
	extract_typed_floating instead of deprecated_extract_floating.
@
text
@d1501 2
a1502 4
  struct type *temp;

  temp = create_range_type (NULL, builtin_type_int32, 0, high);
  return create_array_type (NULL, builtin_type (gdbarch)->builtin_float, temp);
@


1.67
log
@        Updated copyright notices for most files.
@
text
@d1580 1
a1580 1
      DOUBLEST val = deprecated_extract_floating (from, TYPE_LENGTH(type));
@


1.66
log
@gdb
	* varobj.c (value_get_print_value): Include valprint.h.
	(value_get_print_value): Use get_formatted_print_options.
	* value.h (struct value_print_options): Declare.
	(value_print, val_print, common_val_print, val_print_string):
	Update.
	* value.c: Include valprint.h.
	(show_values): Use get_user_print_options.
	(show_convenience): Likewise.
	* valprint.h (prettyprint_arrays, prettyprint_structs): Don't
	declare.
	(struct value_print_options): New type.
	(vtblprint, unionprint, addressprint, objectprint, print_max,
	inspect_it, repeat_count_threshold, output_format,
	stop_print_at_null): Don't declare.
	(user_print_options, get_user_print_options,
	get_raw_print_options, get_formatted_print_options): Declare.
	(print_array_indexes_p): Don't declare.
	(maybe_print_array_index, val_print_array_elements): Update.
	* valprint.c (print_max): Remove.
	(user_print_options): New global.
	(get_user_print_options, get_raw_print_options,
	get_formatted_print_options): New functions.
	(print_array_indexes, repeat_count_threshold, stop_print_at_null,
	prettyprint_structs, prettyprint_arrays, unionprint,
	addressprint): Remove.
	(val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(common_val_print): Likewise.
	(print_array_indexes_p): Remove.
	(maybe_print_array_index): Remove format, pretty arguments; add
	options.  Update.
	(val_print_array_elements): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(val_print_string): Add options argument.  Update.
	(_initialize_valprint): Use user_print_options.
	(output_format): Remove.
	(set_output_radix_1): Use user_print_options.
	* typeprint.c: Include valprint.h.
	(objectprint): Don't declare.
	(whatis_exp): Use get_user_print_options.
	* tui/tui-regs.c: Include valprint.h.
	(tui_register_format): Use get_formatted_print_options.
	* tracepoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(trace_mention): Use get_user_print_options.
	(tracepoints_info): Likewise.
	* stack.c (print_frame_args): Use get_raw_print_options.
	(print_frame_info): Use get_user_print_options.
	(print_frame): Likewise.
	* sh64-tdep.c: Include valprint.h
	(sh64_do_register): Use get_formatted_print_options.
	* scm-valprint.c (scm_inferior_print): Remove format, deref_ref,
	pretty arguments; add options.
	(scm_scmlist_print): Likewise.  Update.
	(scm_scmval_print): Likewise.
	(scm_val_print): Likewise.
	(scm_value_print): Remove format, pretty arguments; add options.
	Update.
	* scm-lang.h (scm_value_print, scm_val_print, scm_scmval_print):
	Update.
	* scm-lang.c (scm_printstr): Add options argument.
	* python/python-value.c: Include valprint.h.
	(valpy_str): Use get_user_print_options.
	* printcmd.c: Include valprint.h.
	(addressprint): Don't declare.
	(inspect_it): Remove.
	(print_formatted): Remove format option; add options.  Update.
	(print_scalar_formatted): Likewise.
	(print_address_demangle): Use get_user_print_options.
	(do_examine): Use get_formatted_print_options.
	(print_command_1): Likewise.
	(output_command): Use get_formatted_print_options.
	(do_one_display): Likewise.
	(print_variable_value): Use get_user_print_options.
	* p-valprint.c (pascal_val_print): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(pascal_value_print): Remove format, pretty arguments; add
	options.  Update.
	(vtblprint, objectprint): Don't declare.
	(pascal_static_field_print): Remove.
	(pascal_object_print_value_fields): Remove format, pretty
	arguments; add options.  Update.
	(pascal_object_print_static_field): Likewise.
	(_initialize_pascal_valprint): Use user_print_options.  Update.
	* p-lang.h (pascal_val_print, pascal_value_print,
	pascal_printstr, pascal_object_print_value_fields): Update.
	(vtblprint, static_field_print): Don't declare.
	* p-lang.c (pascal_printstr): Add options argument.  Update.
	* objc-lang.c (objc_printstr): Add options argument.  Update.
	* mt-tdep.c: Include valprint.h.
	(mt_registers_info): Use get_raw_print_options.
	* mips-tdep.c: Include valprint.h.
	(mips_print_fp_register): Use get_formatted_print_options.
	(mips_print_register): Likewise.
	* mi/mi-main.c: Include valprint.h.
	(get_register): Use get_user_print_options.
	(mi_cmd_data_evaluate_expression): Likewise.
	(mi_cmd_data_read_memory): Use get_formatted_print_options.
	* mi/mi-cmd-stack.c: Include valprint.h.
	(list_args_or_locals): Use get_raw_print_options.
	* m2-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(m2_print_long_set): Remove format, pretty arguments.
	(m2_print_unbounded_array): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(print_unpacked_pointer): Remove format argument; add options.
	Now static.  Update.
	(print_variable_at_address): Remove format, deref_ref, pretty
	arguments; add options.  Update.
	(m2_print_array_contents): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* m2-lang.c (m2_printstr): Add options argument. Update.
	* language.h (struct value_print_options): Declare.
	(struct language_defn) <la_printstr>: Add options argument.
	<la_val_print>: Remove format, deref_ref, pretty argument; add
	options.
	<la_value_print>: Remove format, pretty arguments; add options.
	<la_print_array_index>: Likewise.
	(LA_VAL_PRINT, LA_VALUE_PRINT, LA_PRINT_STRING,
	LA_PRINT_ARRAY_INDEX): Update.
	(default_print_array_index): Update.
	* language.c (default_print_array_index): Remove format, pretty
	arguments; add options.  Update.
	(unk_lang_printstr): Add options argument.
	(unk_lang_val_print): Remove format, deref_ref, pretty arguments;
	add options.
	(unk_lang_value_print): Remove format, pretty arguments; add
	options.
	* jv-valprint.c (java_value_print): Remove format, pretty
	arguments; add options.  Update.
	(java_print_value_fields): Likewise.
	(java_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	* jv-lang.h (java_val_print, java_value_print): Declare.
	* infcmd.c: Include valprint.h.
	(print_return_value): Use get_raw_print_options.
	(default_print_registers_info): Use get_user_print_options,
	get_formatted_print_options.
	(registers_info): Use get_formatted_print_options.
	* gdbtypes.h (struct value_print_options): Declare.
	(print_scalar_formatted): Update.
	* f-valprint.c (f77_print_array_1): Remove format, deref_ref,
	pretty arguments; add options.  Update.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Update.
	* f-lang.c (f_printstr): Add options argument.  Update.
	(c_value_print): Update declaration.
	* expprint.c: Include valprint.h.
	(print_subexp_standard): Use get_raw_print_options,
	get_user_print_options.
	* eval.c: Include valprint.h.
	(objectprint): Don't declare.
	(evaluate_subexp_standard): Use get_user_print_options.
	* cp-valprint.c (vtblprint, objectprint, static_field_print):
	Remove.
	(cp_print_value_fields): Remove format, pretty arguments; add
	options.  Update.
	(cp_print_value): Likewise.
	(cp_print_static_field): Likewise.
	(_initialize_cp_valprint): Use user_print_options.  Update.
	* c-valprint.c (print_function_pointer_address): Add addressprint
	argument.
	(c_val_print): Remove format, deref_ref, pretty arguments; add
	options.  Update.
	(c_value_print): Add options argument.  Update.
	* c-lang.h (c_val_print, c_value_print, c_printstr): Update.
	(vtblprint, static_field_print): Don't declare.
	(cp_print_value_fields): Update.
	* c-lang.c (c_printstr): Add options argument.  Update.
	* breakpoint.c: Include valprint.h.
	(addressprint): Don't declare.
	(watchpoint_value_print): Use get_user_print_options.
	(print_one_breakpoint_location): Likewise.
	(breakpoint_1, print_it_catch_fork, print_it_catch_vfork, mention,
	print_exception_catchpoint): Likewise.
	* auxv.c (fprint_target_auxv): Don't declare addressprint.  Use
	get_user_print_options.
	* ada-valprint.c (struct ada_val_print_args): Remove format,
	deref_ref, and pretty; add options.
	(print_optional_low_bound): Add options argument.
	(val_print_packed_array_elements): Remove format and pretty
	arguments; add options.  Update.
	(printstr): Add options argument.  Update.
	(ada_printstr): Likewise.
	(ada_val_print): Remove format, deref_ref, pretty arguments; add
	options argument.  Update.
	(ada_val_print_stub): Update.
	(ada_val_print_array): Remove format, deref_ref, pretty arguments;
	add options.  Update.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Remove format, pretty arguments; add options.
	Update.
	(print_record): Likewise.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print, ada_value_print, ada_printstr):
	Update.
	* ada-lang.c (ada_print_array_index): Add options argument; remove
	format and pretty arguments.
	(print_one_exception): Use get_user_print_options.
gdb/testsuite
	* gdb.base/exprs.exp (test_expr): Add enum formatting tests.
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.65
log
@	* xcoffread.c (RECORD_MINIMAL_SYMBOL): Update.
	(scan_xcoff_symtab): Update.
	* mdebugread.c (record_minimal_symbol): Update.
	(parse_partial_symbols): Update.
	* elfread.c (record_minimal_symbol): Update.
	* dbxread.c (record_minimal_symbol): Update.
	* coffread.c (record_minimal_symbol): Update.
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Redefine.
	(sh64_elf_make_msymbol_special): Update.
	* mips-tdep.c (mips_elf_make_msymbol_special): Use
	MSYMBOL_TARGET_FLAG_1.
	(mips_elf_make_msymbol_special): Likewise.
	(msymbol_is_special): Likewise.
	* minsyms.c (prim_record_minimal_symbol_and_info): Update.
	(install_minimal_symbols): Likewise.
	(prim_record_minimal_symbol): Update.
	(prim_record_minimal_symbol_and_info): Remove 'info' argument.
	* m68hc11-tdep.c (MSYMBOL_SET_RTC): Redefine.
	(MSYMBOL_SET_RTI): Redefine.
	(MSYMBOL_IS_RTC): Redefine.
	(MSYMBOL_IS_RTI): Redefine.
	* arm-tdep.c (MSYMBOL_SET_SPECIAL): Redefine.
	(MSYMBOL_IS_SPECIAL): Redefine.
	* symtab.h (struct minimal_symbol) <info>: Remove.
	<target_flag_1, target_flag_2>: New fields.
	(MSYMBOL_INFO): Remove.
	(MSYMBOL_TARGET_FLAG_1): New macro.
	(MSYMBOL_TARGET_FLAG_2): Likewise.
	(prim_record_minimal_symbol_and_info): Update.
@
text
@d43 1
d2096 1
d2105 3
a2107 1
      
d2109 1
a2109 1
	     file, 'x', 1, 0, Val_pretty_default, current_language);
d2111 2
d2114 1
a2114 1
	     file, 0, 1, 0, Val_pretty_default, current_language);
@


1.64
log
@	* alpha-tdep.c (alpha_register_type): Use builtin_type (gdbarch)
	instead of builtin_type_ macros.
	* amd64-tdep.c (amd64_register_type): Likewise.
	(amd64_get_longjmp_target): Likewise.
	* arm-tdep.c (arm_register_type): Likewise.
	* avr-tdep.c (avr_register_type): Likewise.
	* cris-tdep.c (cris_register_type, crisv32_register_type): Likewise.
	* frv-tdep.c (frv_register_type): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* hppa-tdep.c (hppa32_convert_from_func_ptr_addr,
	hppa_skip_trampoline_code): Likewise.
	* i386-tdep.c (i386_register_type): Likewise.
	(i386_unwind_pc, i386_sse_type): Likewise.
	* ia64-tdep.c (ia64_register_type): Likewise.
	* m32r-tdep.c (m32r_register_type): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m88k-tdep.c (m88k_register_type): Likewise.
	* mep-tdep.c (mep_register_type): Likewise.
	* mips-tdep.c (mips_pseudo_register_type): Likewise.
	* mn10300-tdep.c (mn10300_register_type): Likewise.
	* mt-tdep.c (mt_copro_register_type): Likewise.
	* rs6000-tdep.c (rs6000_builtin_type_vec64): Likewise.
	(rs6000_convert_register_p, rs6000_register_to_value,
	rs6000_value_to_register): Likewise.
	* s390-tdep.c (s390_register_type): Likewise.
	* sh64-tdep.c (sh64_register_type): Likewise.
	(sh64_build_float_register_type, sh64_do_fp_register): Likewise.
	* sh-tdep.c (sh_sh2a_register_type, sh_sh3e_register_type,
	sh_sh4_build_float_register_type, sh_sh4_register_type,
	sh_default_register_type): Likewise.
	* sparc64-tdep.c (sparc64_register_type): Likewise.
	* sparc-tdep.c (sparc32_register_type): Likewise.
	* spu-tdep.c (spu_builtin_type_vec128, spu_register_type): Likewise.
	* v850-tdep.c (v850_register_type): Likewise.
	* vax-tdep.c (vax_register_type): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_unwind_pc,
	xtensa_push_dummy_call): Likewise.

	* std-regs.c (value_of_builtin_frame_fp_reg,
	value_of_builtin_frame_pc_reg): Likewise.
	* target-descriptions.c (tdesc_register_type): Likewise.
@
text
@d214 1
a214 1
  (((long) MSYMBOL_INFO (msym) & 0x80000000) != 0)
d224 1
a224 1
      MSYMBOL_INFO (msym) = (char *) (((long) MSYMBOL_INFO (msym)) | 0x80000000);
@


1.63
log
@	* ada-lang.c (ada_coerce_to_simple_array_type): Use builtin_type_int32
	instead of builtin_type_int as default unspecified integral type.
	(ada_index_type, ada_array_bound_from_type, ada_variant_discrim_type,
	assign_component, to_fixed_range_type): Likewise.
	* ada-typeprint.c (print_range, print_range_bound,
	print_range_type_named): Likewise.
	* ada-valprint.c (print_optional_low_bound, ada_val_print_1): Likewise.
	* eval.c (evaluate_subexp_standard): Likewise.
	* gnu-v2-abi.c (gnuv2_virtual_fn_field): Likewise.
	* gnu-v3-abi.c (gnuv3_get_virtual_fn, gnuv3_baseclass_offset,
	build_gdb_vtable_type): Likewise.
	* jv-lang.c (java_array_type): Likewise.
	* m2-typeprint.c (m2_print_bounds, m2_is_long_set_of_type): Likewise.
	* m2-valprint.c (m2_print_long_set): Likewise.
	* parse.c (follow_types): Likewise.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* valops.c (value_one, value_array, value_string,
	value_bitstring): Likewise.
	* value.c (allocate_repeat_value, value_from_string): Likewise.
	* varobj.c (c_describe_child): Likewise.
	* mt-tdep.c (mt_register_type): Likewise.
	* sh-tdep.c (sh_sh4_build_float_register_type): Likewise.
	* sh64-tdep.c (sh64_build_float_register_type): Likewise.
@
text
@d1498 1
a1498 1
sh64_build_float_register_type (int high)
d1503 1
a1503 1
  return create_array_type (NULL, builtin_type_float, temp);
d1515 1
a1515 1
    return builtin_type_float;
d1520 1
a1520 1
    return builtin_type_double;
d1523 1
a1523 1
    return sh64_build_float_register_type (1);
d1528 1
a1528 1
    return sh64_build_float_register_type (3);
d1530 1
a1530 1
    return builtin_type_int;
d1533 1
a1533 1
    return builtin_type_int;
d1535 1
a1535 1
    return builtin_type_long_long;
d1992 1
a1992 1
  flt = unpack_double (builtin_type_float, raw_buffer, &inv);
@


1.62
log
@	* m68hc11-tdep.c (gdb_print_insn_m68hc11): Use info->arch
	instead of current_gdbarch.

	* sh64-tdep.c (gdb_print_insn_sh64): Remove.
	(sh64_gdbarch_init): Install print_insn_sh64 directly.
	* sh-tdep.c (gdb_print_insn_sh): Remove.
	(sh_gdbarch_init): Install print_insn_sh directly.

	* mips-tdep.c (gdb_print_insn_mips): Do not check mips_abi
	from current_gdbarch.
	(gdb_print_insn_mips_n32, gdb_print_insn_mips_n64): New functions.
	(mips_gdbarch_init): Install them instead of gdb_print_insn_mips
	depending on mips_abi.
@
text
@d1502 1
a1502 1
  temp = create_range_type (NULL, builtin_type_int, 0, high);
@


1.61
log
@	* alphafbsd-tdep.c: Update for unwinder changes.
	* alpha-linux-tdep.c: Likewise.
	* alphanbsd-tdep.c: Likewise.
	* alphaobsd-tdep.c: Likewise.
	* avr-tdep.c: Likewise.
	* cris-tdep.c: Likewise.
	* frv-linux-tdep.c: Likewise.
	* frv-tdep.c: Likewise.
	* h8300-tdep.c: Likewise.
	* hppa-linux-tdep.c: Likewise.
	* iq2000-tdep.c: Likewise.
	* m32c-tdep.c: Likewise.
	* m32r-linux-tdep.c: Likewise.
	* m32r-tdep.c: Likewise.
	* m68hc11-tdep.c: Likewise.
	* mep-tdep.c: Likewise.
	* mn10300-tdep.c: Likewise.
	* mt-tdep.c: Likewise.
	* score-tdep.c: Likewise.
	* sh64-tdep.c: Likewise.
	* sh-tdep.c: Likewise.
	* sparc64fbsd-tdep.c: Likewise.
	* sparc64nbsd-tdep.c: Likewise.
	* sparc64obsd-tdep.c: Likewise.
	* v850-tdep.c: Likewise.
	* vaxobsd-tdep.c: Likewise.
	* vax-tdep.c: Likewise.
	* xstormy16-tdep.c: Likewise.
@
text
@a678 8
/* Disassemble an instruction.  */
static int
gdb_print_insn_sh64 (bfd_vma memaddr, disassemble_info *info)
{
  info->endian = gdbarch_byte_order (current_gdbarch);
  return print_insn_sh (memaddr, info);
}

d2466 1
a2466 1
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh64);
@


1.60
log
@        * valprint.c (val_print): Add new language parameter and use it
        instead of using the current_language. Update calls to val_print
        throughout.
        (common_val_print): Add new langauge parameter and pass it to
        val_print.
        * value.h (struct language_defn): Add opaque declaration.
        (val_print, common_val_print): Update declarations.
        * stack.c (print_frame_args): Update call to common_val_print
        using the appropriate language.
        * mi/mi-cmd-stack.c (list_args_or_locals): Likewise.
        * c-valprint, f-valprint.c, m2-valprint.c, mt-tdep.c, infcmd.c,
        mi/mi-main.c, jv-valprint.c, ada-valprint.c, varobj.c, p-valprint.c,
        scm-valprint.c, cp-valprint.c, sh64-tdep.c, printcmd.c:
        #include "language.h" if necessary.
        Update calls to val_print and common_val_print.
        * Makefile.in (mt-tdep.o, sh64-tdep.o, mi-cmds.o, mi-main.o):
        Update dependencies.
@
text
@d2266 1
a2266 1
sh64_frame_cache (struct frame_info *next_frame, void **this_cache)
d2276 1
a2276 1
  gdbarch = get_frame_arch (next_frame);
d2280 1
a2280 1
  current_pc = frame_pc_unwind (next_frame);
d2288 1
a2288 1
  cache->base = frame_unwind_register_unsigned (next_frame, MEDIA_FP_REGNUM);
d2292 1
a2292 1
  cache->pc = frame_func_unwind (next_frame, NORMAL_FRAME);
d2305 2
a2306 2
      cache->base = frame_unwind_register_unsigned
		    (next_frame, gdbarch_sp_regnum (gdbarch));
d2322 3
a2324 5
static void
sh64_frame_prev_register (struct frame_info *next_frame, void **this_cache,
			  int regnum, int *optimizedp,
			  enum lval_type *lvalp, CORE_ADDR *addrp,
			  int *realnump, gdb_byte *valuep)
d2326 2
a2327 2
  struct sh64_frame_cache *cache = sh64_frame_cache (next_frame, this_cache);
  struct gdbarch *gdbarch = get_frame_arch (next_frame);
d2332 1
a2332 15
    {
      *optimizedp = 0;
      *lvalp = not_lval;
      *addrp = 0;
      *realnump = -1;
      if (valuep)
        {
          /* Store the value.  */
          store_unsigned_integer (valuep,
	  			  register_size (gdbarch,
				  gdbarch_sp_regnum (gdbarch)),
				  cache->saved_sp);
        }
      return;
    }
a2341 7
      int reg_size = register_size (gdbarch, regnum);
      int size;

      *optimizedp = 0;
      *lvalp = lval_memory;
      *addrp = cache->saved_regs[regnum];
      *realnump = -1;
a2343 4
	size = 4;
      else
        size = reg_size;
      if (valuep)
d2345 3
a2347 5
	  memset (valuep, 0, reg_size);
	  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)
	    read_memory (*addrp, valuep, size);
	  else
	    read_memory (*addrp, (char *) valuep + reg_size - size, size);
d2349 3
a2351 1
      return;
d2354 1
a2354 6
  *optimizedp = 0;
  *lvalp = lval_register;
  *addrp = 0;
  *realnump = regnum;
  if (valuep)
    frame_unwind_register (next_frame, (*realnump), valuep);
d2358 1
a2358 1
sh64_frame_this_id (struct frame_info *next_frame, void **this_cache,
d2361 1
a2361 1
  struct sh64_frame_cache *cache = sh64_frame_cache (next_frame, this_cache);
d2373 3
a2375 1
  sh64_frame_prev_register
a2377 6
static const struct frame_unwind *
sh64_frame_sniffer (struct frame_info *next_frame)
{
  return &sh64_frame_unwind;
}

d2393 1
a2393 1
sh64_unwind_dummy_id (struct gdbarch *gdbarch, struct frame_info *next_frame)
d2395 3
a2397 2
  return frame_id_build (sh64_unwind_sp (gdbarch, next_frame),
                         frame_pc_unwind (next_frame));
d2401 1
a2401 1
sh64_frame_base_address (struct frame_info *next_frame, void **this_cache)
d2403 1
a2403 1
  struct sh64_frame_cache *cache = sh64_frame_cache (next_frame, this_cache);
d2489 1
a2489 1
  set_gdbarch_unwind_dummy_id (gdbarch, sh64_unwind_dummy_id);
d2500 2
a2501 2
  frame_unwind_append_sniffer (gdbarch, dwarf2_frame_sniffer);
  frame_unwind_append_sniffer (gdbarch, sh64_frame_sniffer);
@


1.59
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d50 1
d2113 1
a2113 1
	     file, 'x', 1, 0, Val_pretty_default);
d2116 1
a2116 1
	     file, 0, 1, 0, Val_pretty_default);
@


1.58
log
@
	* gdbarch.sh (skip_prologue): Add gdbarch
	as parameter.
	* gdbarch.{c,h}: Regenerate.

	* alpha-tdep.c (alpha_skip_prologue): Add gdbarch as parameter.
	* amd64-tdep.c (amd64_skip_prologue): Likewise.
	* avr-tdep.c (avr_skip_prologue): Likewise.
	* cris-tdep.c (cris_skip_prologue): Likewise.
	* frv-tdep.c (frv_skip_prologue): Likewise.
	* h8300-tdep.c (h8300_skip_prologue): Likewise.
	* hppa-tdep.c (hppa_skip_prologue): Likewise.
	* i386-tdep.c (i386_skip_prologue): Likewise.
	* ia64-tdep.c (ia64_skip_prologue): Likewise.
	* iq2000-tdep.c (iq2000_skip_prologue): Likewise.
	* m32r-tdep.c (m32r_skip_prologue): Likewise.
	* m68hc11-tdep.c (m68hc11_skip_prologue): Likewise.
	* m68k-tdep.c (m68k_skip_prologue): Likewise.
	* m88k-tdep.c (m88k_skip_prologue): Likewise.
	* mep-tdep.c (mep_skip_prologue): Likewise.
	* mips-tdep.c (mips_skip_prologue): Likewise.
	* mn10300-tdep.c (mn10300_skip_prologue): Likewise.
	* mt-tdep.c (mt_skip_prologue): Likewise.
	* rs6000-tdep.c (rs6000_skip_prologue): Likewise.
	* score-tdep.c (score_skip_prologue): Likewise.
	* sh64-tdep.c (sh64_skip_prologue): Likewise.
	* sh-tdep.c (sh_skip_prologue): Likewise.
	* sparc64-tdep.c (sparc64_skip_prologue): Likewise.
	* sparc-tdep.c (sparc32_skip_prologue): Likewise.
	* spu-tdep.c (spu_skip_prologue): Likewise.
	* v850-tdep.c (v850_skip_prologue): Likewise.
	* vax-tdep.c (vax_skip_prologue): Likewise.
	* xstormy16-tdep.c (xstormy16_skip_prologue): Likewise.
	* xtensa-tdep.c (xtensa_skip_prologue): Likewise.

	* arm-tdep.c (arm_skip_prologue): Add gdbarch as parameter. Replace
	current_gdbarch by gdbarch.
	* m32c-tdep.c (m32c_skip_prologue): Likewise.
	* s390-tdep.c (s390_skip_prologue): Likewise.
@
text
@d1304 2
a1305 2
sh64_return_value (struct gdbarch *gdbarch, struct type *type,
		   struct regcache *regcache,
@


1.57
log
@	Updated copyright notices for most files.
@
text
@d654 1
a654 1
sh64_skip_prologue (CORE_ADDR pc)
@


1.56
log
@*** empty log message ***
@
text
@d4 1
a4 1
   2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.55
log
@2007-11-02  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (register_name): Add gdbarch parameter.
	* gdbarch.{c,h}: Regenerate.

	* target-descriptions.c (tdesc_register_name): Add gdbarch parameter.
	(tdesc_register_name): Replace current_gdbarch by gdbarch.
	* target-descriptions.h (tdesc_register_name): Add gdbarch parameter.

	* xstormy16-tdep.c (xstormy16_register_name): Add gdbarch parameter.
	* vax-tdep.c (vax_register_name): Add gdbarch parameter.
	* spu-tdep.c (spu_register_name): Add gdbarch parameter.
	* s390-tdep.c (s390_register_name): Add gdbarch parameter.
	* mt-tdep.c (mt_register_name): Add gdbarch parameter.
	(mt_registers_info): Replace current_gdbarch by gdbarch.
	(mt_register_reggroup_p): Add gdbarch to mt_register_name call.
	* mips-tdep.c (mips_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mips_register_name): Add gdbarch to tdesc_register_name call.
	* mep-tdep.c (mep_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(mep_register_reggroup_p): Add gdbarch to mep_register_name call.
	* m32c-tdep.c (m32c_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* m88k-tdep.c (m88k_register_name): Add gdbarch parameter.
	* m68k-tdep.c (m68k_register_name): Add gdbarch parameter.
	* m32r-tdep.c (m32r_register_name): Add gdbarch parameter.
	(m32r_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	* iq2000-tdep.c (iq2000_register_name): Add gdbarch parameter.
	* ia64-tdep.c (ia64_register_name): Add gdbarch parameter.
	* hppa-tdep.c (hppa32_register_name, hppa64_register_name): Add gdbarch
	parameter.
	* h8300-tdep.c (h8300_register_name, h8300s_register_name)
	(h8300sx_register_name): Add gdbarch parameter.
	* cris-tdep.c (cris_register_name, crisv32_register_name): Add
	gdbarch parameter. Replace current_gdbarch by gdbarch.
	(cris_gdbarch_init): Replace current_gdbarch by gdbarch (comment).
	* avr-tdep.c (avr_register_name): Add gdbarch parameter.
	* arm-tdep.c (arm_register_name): Add gdbarch paramete
	* amd64-tdep.c (amd64_register_name): Add gdbarch parameter. Update
	caller.
	* amd64-tdep.h (amd64_register_name): Add gdbarch parameter.
	* amd64-linux-tdep.c (amd64_linux_register_name): Add gdbarch parameter.
	* alpha-tdep.c (alpha_register_name): Add gdbarch parameter.
	(alpha_cannot_fetch_register, alpha_cannot_store_register): Update call
	of alpha_register_name.
	* frv-tdep.c (frv_register_name): Add gdbarch parameter.
	* i386-tdep.c (i386_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(i386_register_type): Replace ?current_gdbarch by gdbarch.
	* i386-tdep.h (i386_register_name): Add gdbarch parameter.
	* i386-linux-tdep.c (i386_linux_register_name): Add gdbarch parameter.

	* m68hc11-tdep.c (m68hc11_register_name): Add gdbarch parameter.
	(m68hc11_register_reggroup_p): Add gdbarch to call of
	m68hc11_register_name.
	* mn10300-tdep.c (mn10300_generic_register_name, am33_register_name)
	(am33_2_register_name): Add gdbarch parameter.
	(mn10300_frame_unwind_cache): Use get_frame_arch to get at the current
	architecture by frame_info.
	(mn10300_dump_tdep): Replace current_gdbarch by gdbarch.
	* rs6000-tdep.c (rs6000_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	* score-tdep.c (score_register_name): Add gdbarch parameter.
	(score_return_value, score_push_dummy_call): Replace current_gdbarch
	by gdbarch.
	* sh64-tdep.c (sh64_register_name): Add gdbarch parameter.
	(sh64_compact_reg_base_num, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_fv_reg_base_num)
	(sh64_dr_reg_base_num, sh64_fpp_reg_base_num): Add gdbarch parameter
	and update caller. Replace current_gdbarch by gdbarch.
	(sh64_extract_return_value, sh64_store_return_value): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sh-tdep.c (sh_sh_register_name, sh_sh3_register_name)
	(sh_sh3e_register_name, sh_sh2e_register_name, sh_sh2a_register_name)
	(sh_sh2a_nofpu_register_name, sh_sh_dsp_register_name)
	(sh_sh3_dsp_register_name, sh_sh4_register_name)
	(sh_sh4_nofpu_register_name, sh_sh4al_dsp_register_name): Add gdbarch
	parameter.
	(fv_reg_base_num, dr_reg_base_num, sh_justify_value_in_reg)
	(sh_next_flt_argreg): Add gdbarch parameter and update caller. Replace
	current_gdbarch by gdbarch.
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Use
	get_regcache_arch to get at the current architecture by regcache.
	* sparc-tdep.c (sparc32_register_name): Add gdbarch parameter.
	* sparc64-tdep.c (sparc64_register_name): Add gdbarch parameter.
	* v850-tdep.c (v850_register_name, v850e_register_name): Add gdbarch
	parameter.
	(v850_unwind_sp, v850_unwind_pc): Replace current_gdbarch by gdbarch.
	* xtensa-tdep.c (xtensa_register_name): Add gdbarch parameter. Replace
	current_gdbarch by gdbarch.
	(xtensa_pseudo_register_read, xtensa_pseudo_register_write)
	(xtensa_frame_prev_register): Add gdbarch parameter to
	xtensa_register_name call.
@
text
@d255 1
a255 1
sh64_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d267 1
a267 1
  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
@


1.54
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* sh64-tdep.c (sh64_push_dummy_call, sh64_register_type)
	(sh64_pseudo_register_read, sh64_pseudo_register_write)
	(sh64_do_fp_register, sh64_do_pseudo_register, sh64_do_register)
	(sh64_print_register, sh64_media_print_registers_info)
	(sh64_compact_print_registers_info, sh64_unwind_sp)
	(sh64_unwind_pc): Replace current_gdbarch by gdbarch.
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_frame_cache)
	(sh64_frame_prev_register): Use FRAME to recognize current
	architecture.
@
text
@d127 1
a127 1
sh64_register_name (int reg_nr)
d688 1
a688 1
sh64_fv_reg_base_num (int fv_regnum)
d692 1
a692 2
  fp_regnum = gdbarch_fp0_regnum (current_gdbarch) +
    (fv_regnum - FV0_REGNUM) * 4;
d698 1
a698 1
sh64_dr_reg_base_num (int dr_regnum)
d702 1
a702 2
  fp_regnum = gdbarch_fp0_regnum (current_gdbarch) +
    (dr_regnum - DR0_REGNUM) * 2;
d708 1
a708 1
sh64_fpp_reg_base_num (int fpp_regnum)
d712 1
a712 2
  fp_regnum = gdbarch_fp0_regnum (current_gdbarch) +
    (fpp_regnum - FPP0_REGNUM) * 2;
d779 1
a779 1
sh64_compact_reg_base_num (int reg_nr)
d791 1
a791 1
    base_regnum = reg_nr - FP0_C_REGNUM + gdbarch_fp0_regnum (current_gdbarch);
d796 2
a797 1
    base_regnum = sh64_dr_reg_base_num (DR0_REGNUM + reg_nr - DR0_C_REGNUM);
d802 2
a803 1
    base_regnum = sh64_fv_reg_base_num (FV0_REGNUM + reg_nr - FV0_C_REGNUM);
d806 1
a806 1
    base_regnum = gdbarch_pc_regnum (current_gdbarch);
d825 1
a825 1
    base_regnum = gdbarch_fp0_regnum (current_gdbarch) + 32;
d1205 1
d1207 1
a1207 1
  
d1214 1
a1214 1
			     gdbarch_fp0_regnum (current_gdbarch), valbuf);
d1224 1
a1224 1
	  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d1243 2
a1244 2
	  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
	    offset = register_size (current_gdbarch, DEFAULT_RETURN_REGNUM)
d1266 1
d1272 1
a1272 1
      int i, regnum = gdbarch_fp0_regnum (current_gdbarch);
d1274 1
a1274 1
	if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d1285 1
a1285 1
      if (len <= register_size (current_gdbarch, return_register))
d1288 3
a1290 3
	  memset (buf, 0, register_size (current_gdbarch, return_register));
	  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
	    offset = 0; /*register_size (current_gdbarch, 
d1293 1
a1293 1
	    offset = register_size (current_gdbarch, return_register) - len;
d1546 2
a1547 2
sh64_register_convert_to_virtual (int regnum, struct type *type,
				     char *from, char *to)
d1549 1
a1549 1
  if (gdbarch_byte_order (current_gdbarch) != BFD_ENDIAN_LITTLE)
d1552 1
a1552 1
      memcpy (to, from, register_size (current_gdbarch, regnum));
d1571 2
a1572 2
sh64_register_convert_to_raw (struct type *type, int regnum,
				 const void *from, void *to)
d1574 1
a1574 1
  if (gdbarch_byte_order (current_gdbarch) != BFD_ENDIAN_LITTLE)
d1577 1
a1577 1
      memcpy (to, from, register_size (current_gdbarch, regnum));
d1606 1
a1606 1
      base_regnum = sh64_dr_reg_base_num (reg_nr);
d1617 1
a1617 1
      sh64_register_convert_to_virtual (reg_nr, 
d1626 1
a1626 1
      base_regnum = sh64_fpp_reg_base_num (reg_nr);
d1640 1
a1640 1
      base_regnum = sh64_fv_reg_base_num (reg_nr);
d1655 1
a1655 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1667 1
a1667 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1678 1
a1678 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1688 1
a1688 1
      sh64_register_convert_to_virtual (reg_nr, 
d1696 1
a1696 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1753 1
a1753 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1772 1
a1772 1
      base_regnum = sh64_dr_reg_base_num (reg_nr);
d1774 1
a1774 1
      sh64_register_convert_to_raw (register_type (gdbarch, reg_nr),
d1789 1
a1789 1
      base_regnum = sh64_fpp_reg_base_num (reg_nr);
d1802 1
a1802 1
      base_regnum = sh64_fv_reg_base_num (reg_nr);
d1817 1
a1817 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1837 1
a1837 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1844 1
a1844 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1848 2
a1849 1
	  sh64_register_convert_to_raw (register_type (gdbarch, reg_nr),
d1863 1
a1863 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d1929 1
a1929 1
      base_regnum = sh64_compact_reg_base_num (reg_nr);
d2040 1
a2040 1
      int fp_regnum = sh64_dr_reg_base_num (regnum);
d2048 1
a2048 1
      int fp_regnum = sh64_compact_reg_base_num (regnum);
d2056 1
a2056 1
      int fp_regnum = sh64_fv_reg_base_num (regnum);
d2067 1
a2067 1
      int fp_regnum = sh64_compact_reg_base_num (regnum);
d2078 1
a2078 1
      int fp_regnum = sh64_fpp_reg_base_num (regnum);
d2086 1
a2086 1
      int c_regnum = sh64_compact_reg_base_num (regnum);
@


1.53
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1077 1
a1077 1
  float_argreg = gdbarch_fp0_regnum (current_gdbarch);
d1088 1
a1088 1
	  argreg_size = register_size (current_gdbarch, int_argreg);
d1093 1
a1093 1
	      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1147 1
a1147 1
					 gdbarch_fp0_regnum (current_gdbarch)
d1193 1
a1193 1
				  gdbarch_sp_regnum (current_gdbarch), sp);
d1319 1
d1325 1
a1325 1
					 gdbarch_pc_regnum (current_gdbarch))),
d1352 1
a1352 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 0),
d1354 1
a1354 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 1),
d1356 1
a1356 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 2),
d1358 1
a1358 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 3),
d1360 1
a1360 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 4),
d1362 1
a1362 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 5),
d1364 1
a1364 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 6),
d1366 1
a1366 1
	        (frame, gdbarch_fp0_regnum (current_gdbarch) + i + 7));
d1372 1
d1407 1
a1407 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 0),
d1409 1
a1409 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 1),
d1411 1
a1411 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 2),
d1413 1
a1413 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 3),
d1415 1
a1415 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 4),
d1417 1
a1417 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 5),
d1419 1
a1419 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 6),
d1421 1
a1421 1
		(frame, gdbarch_fp0_regnum (current_gdbarch) + i + 7));
d1517 1
a1517 1
  if ((reg_nr >= gdbarch_fp0_regnum (current_gdbarch)
d1658 1
a1658 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1818 1
a1818 1
      if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_BIG)
d1989 1
a1989 1
						 (current_gdbarch)));
d1994 1
a1994 1
	   regnum, gdbarch_register_name (current_gdbarch, regnum));
d2000 1
a2000 1
  fputs_filtered (gdbarch_register_name (current_gdbarch, regnum), file);
d2002 1
a2002 1
					(current_gdbarch, regnum)), file);
d2014 1
a2014 1
      int idx = gdbarch_byte_order (current_gdbarch)
d2029 2
a2030 2
  if (regnum < gdbarch_num_regs (current_gdbarch)
      || regnum >= gdbarch_num_regs (current_gdbarch)
d2101 1
a2101 1
  fputs_filtered (gdbarch_register_name (current_gdbarch, regnum), file);
d2103 1
a2103 1
				      (current_gdbarch, regnum)), file);
d2121 2
a2122 2
  if (regnum < 0 || regnum >= gdbarch_num_regs (current_gdbarch)
			      + gdbarch_num_pseudo_regs (current_gdbarch))
d2126 1
a2126 1
  else if (regnum >= 0 && regnum < gdbarch_num_regs (current_gdbarch))
d2134 2
a2135 2
  else if (regnum < gdbarch_num_regs (current_gdbarch)
		    + gdbarch_num_pseudo_regs (current_gdbarch))
d2146 1
a2146 1
      if (*(gdbarch_register_name (current_gdbarch, regnum)) == '\0')
d2155 1
a2155 1
      while (regnum < gdbarch_num_regs (current_gdbarch))
d2159 2
a2160 2
	  if (gdbarch_register_name (current_gdbarch, regnum) == NULL
	      || *(gdbarch_register_name (current_gdbarch, regnum)) == '\0')
d2176 1
a2176 1
		regnum += FP_LAST_REGNUM - gdbarch_fp0_regnum (current_gdbarch);
d2187 2
a2188 2
	while (regnum < gdbarch_num_regs (current_gdbarch)
			+ gdbarch_num_pseudo_regs (current_gdbarch))
d2204 1
a2204 1
      if (*(gdbarch_register_name (current_gdbarch, regnum)) == '\0')
d2216 2
a2217 2
      while (regnum < gdbarch_num_regs (current_gdbarch)
		      + gdbarch_num_pseudo_regs (current_gdbarch))
d2265 1
d2273 1
d2291 1
a2291 1
    sh64_analyze_prologue (current_gdbarch, cache, cache->pc, current_pc);
d2303 1
a2303 1
		    (next_frame, gdbarch_sp_regnum (current_gdbarch));
d2326 1
d2330 1
a2330 1
  if (regnum == gdbarch_sp_regnum (current_gdbarch) && cache->saved_sp)
d2340 2
a2341 2
	  			  register_size (current_gdbarch,
				  gdbarch_sp_regnum (current_gdbarch)),
d2350 1
a2350 1
  if (regnum == gdbarch_pc_regnum (current_gdbarch))
d2355 1
a2355 1
      int reg_size = register_size (current_gdbarch, regnum);
d2362 1
a2362 1
      if (gdbarch_tdep (current_gdbarch)->sh_abi == SH_ABI_32
d2370 1
a2370 1
	  if (gdbarch_byte_order (current_gdbarch) == BFD_ENDIAN_LITTLE)
d2415 1
a2415 1
					 gdbarch_sp_regnum (current_gdbarch));
d2422 1
a2422 1
					 gdbarch_pc_regnum (current_gdbarch));
@


1.52
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS): Remove.
	* sh-tdep.c (sh_extract_struct_value_address): Remove.
	(sh_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* sh64-tdep.c (sh64_extract_struct_value_address): Remove.
	(sh64_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* ia64-tdep.c (ia64_extract_struct_value_address): Remove.
	(ia64_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* frv-tdep.c (frv_extract_struct_value_address): Remove.
	(frv_gdbarch_init): Remove
	set_gdbarch_deprecated_extract_struct_value_address.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.51
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a964 11
sh64_extract_struct_value_address (struct regcache *regcache)
{
  /* FIXME: cagney/2004-01-17: Does the ABI guarantee that the return
     address regster is preserved across function calls?  Probably
     not, making this function wrong.  */
  ULONGEST val;
  regcache_raw_read_unsigned (regcache, STRUCT_RETURN_REGNUM, &val);
  return val;
}

static CORE_ADDR
a2506 2
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch,
					    sh64_extract_struct_value_address);
@


1.50
log
@	* gdbarch.sh (read_pc): Add REGCACHE argument.  Remove PTID argument.
	(write_pc): Likewise.  Remove default implementation, add predicate.
	* gdbarch.c, gdbarch.h: Regenerate.
	* regcache.c (read_pc_pid): Use current regcache instead of calling
	read_register_pid.
	(write_pc_pid): Check gdbarch_write_pc predicate, implement default
	case inline.
	(generic_target_write_pc): Remove.
	* inferior.h (generic_target_write_pc): Remove.
	* frv-tdep.c (frv_gdbarch_init): Do not install it.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Likewise.
	* rs6000-tdep.c (rs6000_gdbarch_init): Likewise.
	* sh64-tdep.c (sh64_gdbarch_init): Likewise.
	* sh-tdep.c (sh_gdbarch_init): Likewise.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Likewise.

	* avr-tdep.c (avr_read_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling read_register_pid.
	* hppa-hpux-tdep.c (hppa_hpux_read_pc): Likewise.
	* hppa-tdep.c (hppa_read_pc): Likewise.
	* hppa-tdep.h (hppa_read_pc): Likewise.
	* ia64-tdep.c (ia64_read_pc): Likewise.
	* m32r-tdep.c (m32r_read_pc): Likewise.
	* mep-tdep.c (mep_read_pc): Likewise.
	* mn10300-tdep.c (mn10300_read_pc): Likewise.
	* spu-tdep.c (spu_read_pc): Likewise.

	* arm-tdep.c (arm_write_pc): Add REGCACHE argument.  Remove PTID
	argument.  Use REGCACHE instead of calling write_register_pid.
	* avr-tdep.c (avr_write_pc): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_write_pc): Likewise.
	* hppa-tdep.c (hppa_write_pc): Likewise.
	* hppa-tdep.h (hppa_write_pc): Likewise.
	* i386-linux-tdep.c (i386_linux_write_pc): Likewise.
	* amd64-linux-tdep.c (amd64_linux_write_pc): Likewise.
	* ia64-linux-tdep.c (ia64_linux_write_pc): Likewise.
	* ia64-tdep.c (ia64_write_pc): Likewise.
	* ia64-tdep.h (ia64_write_pc): Likewise.
	* m32r-tdep.c (m32r_write_pc): Likewise.
	* m88k-tdep.c (m88k_write_pc): Likewise.
	* mep-tdep.c (mep_write_pc): Likewise.
	* mips-tdep.c (mips_write_pc): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.
	* mn10300-tdep.c (mn10300_write_pc): Likewise.
	* sparc-tdep.c (sparc_write_pc): Likewise.
	* spu-tdep.c (spu_write_pc): Likewise.

	* mips-tdep.c (read_signed_register): Remove.
	(read_signed_register_pid): Likewise.
	(mips_read_pc): Add REGCACHE argument.  Remove PTID argument.
	Use REGCACHE instead of calling read_signed_register_pid.
@
text
@d98 1
a98 1
       GDB's FP0_REGNUM, which is the number of the first Floating
d694 1
a694 1
  fp_regnum = FP0_REGNUM + 
d705 1
a705 1
  fp_regnum = FP0_REGNUM + 
d716 1
a716 1
  fp_regnum = FP0_REGNUM + 
d796 1
a796 1
    base_regnum = reg_nr - FP0_C_REGNUM + FP0_REGNUM;
d809 1
a809 1
    base_regnum = PC_REGNUM;
d828 1
a828 1
    base_regnum = FP0_REGNUM + 32;
d1090 1
a1090 1
  float_argreg = FP0_REGNUM;
d1160 2
a1161 1
					 FP0_REGNUM + float_arg_index,
d1205 2
a1206 1
  regcache_cooked_write_unsigned (regcache, SP_REGNUM, sp);
d1225 3
a1227 2
	  /* Return value stored in FP0_REGNUM */
	  regcache_raw_read (regcache, FP0_REGNUM, valbuf);
d1284 1
a1284 1
      int i, regnum = FP0_REGNUM;
d1336 2
a1337 1
     paddr (get_frame_register_unsigned (frame, PC_REGNUM)),
d1363 16
a1378 8
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 0),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 1),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 2),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 3),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 4),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 5),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 6),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 7));
d1417 16
a1432 8
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 0),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 1),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 2),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 3),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 4),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 5),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 6),
       (long) get_frame_register_unsigned (frame, FP0_REGNUM + i + 7));
d1528 1
a1528 1
  if ((reg_nr >= FP0_REGNUM
d1997 4
a2000 1
  raw_buffer = (unsigned char *) alloca (register_size (gdbarch, FP0_REGNUM));
d2187 2
a2188 1
		regnum += FP_LAST_REGNUM - FP0_REGNUM;	/* skip FP regs */
d2311 2
a2312 1
      cache->base = frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2338 1
a2338 1
  if (regnum == SP_REGNUM && cache->saved_sp)
d2348 2
a2349 1
	  			  register_size (current_gdbarch, SP_REGNUM),
d2358 1
a2358 1
  if (regnum == PC_REGNUM)
d2422 2
a2423 1
  return frame_unwind_register_unsigned (next_frame, SP_REGNUM);
d2429 2
a2430 1
  return frame_unwind_register_unsigned (next_frame, PC_REGNUM);
@


1.49
log
@	* sh-tdep.h (sh_show_regs): Add FRAME parameter.
	* sh-tdep.c (sh_show_regs): Likewise.
	(sh_show_regs_command): Pass current frame to sh_show_regs routine.
	(sh_generic_show_regs): Add FRAME parameter.  Use register
	values from that frame instead of calling read_register.
	(sh3_show_regs, sh2e_show_regs, sh2a_show_regs, sh2a_nofpu_show_regs,
	sh3e_show_regs, sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Likewise.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs,
	sh64_show_regs): Likewise.
@
text
@a2488 2
  set_gdbarch_write_pc (gdbarch, generic_target_write_pc);

@


1.48
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1327 1
a1327 1
sh64_show_media_regs (void)
d1331 12
a1342 9
  printf_filtered ("PC=%s SR=%016llx \n",
		   paddr (read_register (PC_REGNUM)),
		   (long long) read_register (SR_REGNUM));

  printf_filtered ("SSR=%016llx SPC=%016llx \n",
		   (long long) read_register (SSR_REGNUM),
		   (long long) read_register (SPC_REGNUM));
  printf_filtered ("FPSCR=%016lx\n ",
		   (long) read_register (FPSCR_REGNUM));
d1345 7
a1351 6
    printf_filtered ("\nR%d-R%d  %016llx %016llx %016llx %016llx\n",
		     i, i + 3,
		     (long long) read_register (i + 0),
		     (long long) read_register (i + 1),
		     (long long) read_register (i + 2),
		     (long long) read_register (i + 3));
d1356 11
a1366 10
    printf_filtered ("FR%d-FR%d  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		     i, i + 7,
		     (long) read_register (FP0_REGNUM + i + 0),
		     (long) read_register (FP0_REGNUM + i + 1),
		     (long) read_register (FP0_REGNUM + i + 2),
		     (long) read_register (FP0_REGNUM + i + 3),
		     (long) read_register (FP0_REGNUM + i + 4),
		     (long) read_register (FP0_REGNUM + i + 5),
		     (long) read_register (FP0_REGNUM + i + 6),
		     (long) read_register (FP0_REGNUM + i + 7));
d1370 1
a1370 1
sh64_show_compact_regs (void)
d1374 15
a1388 12
  printf_filtered ("PC=%s \n",
		   paddr (read_register (PC_C_REGNUM)));

  printf_filtered ("GBR=%08lx MACH=%08lx MACL=%08lx PR=%08lx T=%08lx\n",
		   (long) read_register (GBR_C_REGNUM),
		   (long) read_register (MACH_C_REGNUM),
		   (long) read_register (MACL_C_REGNUM),
		   (long) read_register (PR_C_REGNUM),
		   (long) read_register (T_C_REGNUM));
  printf_filtered ("FPSCR=%08lx FPUL=%08lx\n",
		   (long) read_register (FPSCR_C_REGNUM),
		   (long) read_register (FPUL_C_REGNUM));
d1391 7
a1397 6
    printf_filtered ("\nR%d-R%d  %08lx %08lx %08lx %08lx\n",
		     i, i + 3,
		     (long) read_register (i + 0),
		     (long) read_register (i + 1),
		     (long) read_register (i + 2),
		     (long) read_register (i + 3));
d1402 11
a1412 10
    printf_filtered ("FR%d-FR%d  %08lx %08lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
		     i, i + 7,
		     (long) read_register (FP0_REGNUM + i + 0),
		     (long) read_register (FP0_REGNUM + i + 1),
		     (long) read_register (FP0_REGNUM + i + 2),
		     (long) read_register (FP0_REGNUM + i + 3),
		     (long) read_register (FP0_REGNUM + i + 4),
		     (long) read_register (FP0_REGNUM + i + 5),
		     (long) read_register (FP0_REGNUM + i + 6),
		     (long) read_register (FP0_REGNUM + i + 7));
d1418 1
a1418 1
sh64_show_regs (void)
d1420 2
a1421 2
  if (pc_is_isa32 (get_frame_pc (get_selected_frame (NULL))))
    sh64_show_media_regs ();
d1423 1
a1423 1
    sh64_show_compact_regs ();
@


1.47
log
@2007-06-06  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (COFF_MAKE_MSYMBOL_SPECIAL): Replace by
	gdbarch_coff_make_msymbol_special.
	* coffread.c (coff_symtab_read): Likewise.
	* gdbarch.sh (ELF_MAKE_MSYMBOL_SPECIAL): Replace by
	gdbarch_elf_make_msymbol_special.
	* elfread.c (elf_symtab_read): Likewise.
	* mips-tdep.c (mips_elf_make_msymbol_special): Likewise (comment).
	* sh64-tdep.c (MSYMBOL_IS_SPECIAL): Likewise (comment).
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1971 2
a1972 1
    error ("can't read register %d (%s)", regnum, REGISTER_NAME (regnum));
d1978 3
a1980 2
  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);
d2079 3
a2081 2
  fputs_filtered (REGISTER_NAME (regnum), file);
  print_spaces_filtered (15 - strlen (REGISTER_NAME (regnum)), file);
d2124 1
a2124 1
      if (*(REGISTER_NAME (regnum)) == '\0')
d2137 2
a2138 2
	  if (REGISTER_NAME (regnum) == NULL
	      || *(REGISTER_NAME (regnum)) == '\0')
d2181 1
a2181 1
      if (*(REGISTER_NAME (regnum)) == '\0')
@


1.46
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* xtensa-tdep.c (XTENSA_IS_ENTRY, extract_call_winsize)
	(xtensa_register_write_masked, xtensa_register_read_masked)
	(xtensa_extract_return_value, xtensa_store_return_value
	(xtensa_push_dummy_call, xtensa_breakpoint_from_pc): Replace
	TARGET_BYTE_ORDER by gdbarch_byte_order.
	* sh-tdep.c (sh_breakpoint_from_pc, gdb_print_insn_sh)
	(sh_justify_value_in_reg, sh_next_flt_argreg, sh_push_dummy_call_fpu)
	(sh_extract_return_value_fpu, sh_store_return_value_fpu): Likewise.
	* sh64-tdep.c (sh64_breakpoint_from_pc, gdb_print_insn_sh64)
	(sh64_push_dummy_call, sh64_extract_return_value)
	(sh64_store_return_value, sh64_register_convert_to_virtual)
	(sh64_register_convert_to_raw, sh64_pseudo_register_read)
	(sh64_pseudo_register_write, sh64_do_fp_register)
	(sh64_frame_prev_register): Likewise.
	* score-tdep.c (score_print_insn, score_breakpoint_from_pc)
	(score_return_value, score_push_dummy_call, score_fetch_inst): Likewise.
	* rs6000-tdep.c (rs6000_breakpoint_from_pc, rs6000_push_dummy_call)
	(e500_move_ev_register,gdb_print_insn_powerpc): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* ppc-linux-nat.c (store_register): Likewise.
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* mips-tdep.c (mips_pseudo_register_read, mips_pseudo_register_write)
	(mips_convert_register_p, mips_eabi_push_dummy_call)
	(mips_n32n64_push_dummy_call, mips_n32n64_return_value)
	(mips_o32_push_dummy_call, mips_o32_return_value)
	(mips_o64_push_dummy_call, mips_o64_return_value, mips_o64_return_value)
	(mips_read_fp_register_single, mips_read_fp_register_double)
	(mips_print_register, print_gp_register_row, gdb_print_insn_mips)
	(mips_breakpoint_from_pc): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_sigtramp_offset): Likewise.
	* mips-linux-tdep.c (mips64_supply_fpregset, mips64_fill_fpregset)
	(mips_linux_o32_sigframe_init): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint, m32r_breakpoint_from_pc): Likewise.
	* libunwind-frame.c (libunwind_frame_cache, libunwind_frame_sniffer)
	(libunwind_sigtramp_frame_sniffer, libunwind_get_reg_special): Likewise.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* arm-tdep.c (convert_from_extended, convert_to_extended)
	(gdb_print_insn_arm): Likewise.
@
text
@d209 2
a210 3
   ELF_MAKE_MSYMBOL_SPECIAL
   tests whether an ELF symbol is "special", i.e. refers
   to a 32-bit function, and sets a "special" bit in a 
@


1.45
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d270 1
a270 1
  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d685 1
a685 1
  info->endian = TARGET_BYTE_ORDER;
d1107 1
a1107 1
	      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1235 1
a1235 1
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d1254 1
a1254 1
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1284 1
a1284 1
	if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d1299 1
a1299 1
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
d1530 1
a1530 1
  if (TARGET_BYTE_ORDER != BFD_ENDIAN_LITTLE)
d1555 1
a1555 1
  if (TARGET_BYTE_ORDER != BFD_ENDIAN_LITTLE)
d1640 1
a1640 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1800 1
a1800 1
      if (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG)
d1991 3
a1993 2
      int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
	: register_size (gdbarch, regnum) - 1 - j;
d2340 1
a2340 1
	  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
@


1.44
log
@	* dwarf2-frame.c (dwarf2_frame_cache, dwarf2_frame_this_id)
	(dwarf2_frame_sniffer): Update.
	(dwarf2_signal_frame_this_id): New function.
	(dwarf2_signal_frame_unwind): Use it.
	(dwarf2_frame_base_sniffer): Use frame_unwind_address_in_block.
	* frame.c (frame_func_unwind): Add this_type argument.
	(get_frame_func): Update.
	(frame_unwind_address_in_block): Add this_type argument and check it.
	Fix a typo.
	(get_frame_address_in_block): Update.
	* frame.h (enum frame_type): Move higher in the file.
	(frame_unwind_address_in_block, frame_func_unwind): Add enum frame_type
	argument.

	* alpha-mdebug-tdep.c, alpha-tdep.c, amd64-tdep.c, amd64obsd-tdep.c,
	arm-tdep.c, avr-tdep.c, cris-tdep.c, frv-tdep.c, h8300-tdep.c,
	hppa-tdep.c, i386-tdep.c, i386obsd-tdep.c, ia64-tdep.c,
	libunwind-frame.c, m32c-tdep.c, m32r-linux-tdep.c, m32r-tdep.c,
	m68hc11-tdep.c, m68k-tdep.c, m88k-tdep.c, mips-mdebug-tdep.c,
	mips-tdep.c, mn10300-tdep.c, mt-tdep.c, rs6000-tdep.c, s390-tdep.c,
	score-tdep.c, sh-tdep.c, sh64-tdep.c, sparc-tdep.c,
	sparc64obsd-tdep.c, spu-tdep.c, v850-tdep.c, vax-tdep.c,
	xstormy16-tdep.c, xtensa-tdep.c: Update calls to
	frame_func_unwind and frame_unwind_address_in_block to specify
	the frame type.  Use frame_unwind_address_in_block instead of
	frame_pc_unwind in sniffers.

	* gdb.arch/i386-signal.c, gdb.arch/i386-signal.exp: New files.
@
text
@d2005 4
a2008 3
  if (regnum < NUM_REGS 
      || regnum >= NUM_REGS + NUM_PSEUDO_REGS_SH_MEDIA
			    + NUM_PSEUDO_REGS_SH_COMPACT)
d2096 2
a2097 1
  if (regnum < 0 || regnum >= NUM_REGS + NUM_PSEUDO_REGS)
d2101 1
a2101 1
  else if (regnum >= 0 && regnum < NUM_REGS)
d2109 2
a2110 1
  else if (regnum < NUM_REGS + NUM_PSEUDO_REGS)
d2130 1
a2130 1
      while (regnum < NUM_REGS)
d2161 2
a2162 1
	while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
d2190 2
a2191 1
      while (regnum < NUM_REGS + NUM_PSEUDO_REGS)
@


1.43
log
@	* frame.c (deprecated_selected_frame): Rename to...
	(selected_frame): ...this.  Make static.
	(get_selected_frame, select_frame): Update.
	* frame.h (deprected_select_frame): Delete.
	(deprecated_safe_get_selected_frame): Update comments.

	* breakpoint.c, cli/cli-cmds.c, f-valprint.c, infcmd.c, inflow.c,
	infrun.c, stack.c, tui/tui-disasm.c, tui/tui-source.c,
	tui/tui-winsource.c, valops.c, varobj.c, findvar.c, macroscope.c,
	parse.c, regcache.h, sh64-tdep.c, tui/tui-hooks.c, tui/tui-win.c,
	tui/tui.c: Replace references to deprecated_selected_frame.
@
text
@d2256 1
a2256 1
  cache->pc = frame_func_unwind (next_frame);
@


1.42
log
@	* gdbarch.sh (register_type): Update comment.
	* gdbarch.h: Regenerated.
	* arch-utils.c (generic_register_size): Call register_type.
	* ia64-tdep.c (ia64_extract_return_value): Likewise.
	* m32c-tdep.c (check_for_saved): Likewise.
	* mips-tdep.c (mips_print_register, print_gp_register_row)
	(mips_print_registers_info): Likewise.
	* sh-tdep.c (sh_pseudo_register_read, sh_pseudo_register_write):
	Likewise.
	* sh64-tdep.c (sh64_pseudo_register_read, sh64_pseudo_register_write)
	(sh64_do_register, sh64_print_register)
	(sh64_media_print_registers_info): Likewise.
	* tui/tui-regs.c (tui_register_format): Likewise.
@
text
@d1411 1
a1411 2
  if (deprecated_selected_frame
      && pc_is_isa32 (get_frame_pc (deprecated_selected_frame)))
@


1.41
log
@Copyright updates for 2007.
@
text
@d1600 1
a1600 2
					gdbarch_register_type (gdbarch, 
							       reg_nr),
d1671 1
a1671 2
					gdbarch_register_type (gdbarch, 
							       reg_nr),
d1756 1
a1756 1
      sh64_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr),
d1830 1
a1830 2
	  sh64_register_convert_to_raw (gdbarch_register_type (gdbarch,
							       reg_nr), 
d2084 1
a2084 1
  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
d2087 1
a2087 1
  val_print (gdbarch_register_type (gdbarch, regnum), raw_buffer, 0, 0,
d2102 1
a2102 1
      if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d2139 1
a2139 1
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum))
@


1.40
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.39
log
@2005-11-02  Andrew Stubbs  <andrew.stubbs@@st.com>

	* monitor.c (monitor_xfer_memory): Change char to gdb_byte.
	(monitor_insert_breakpoint): Likewise.
	(monitor_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
	* sh-tdep.c (sh_return_value_nofpu): Change void to gdb_byte.
	(sh_return_value_fpu): Likewise.
	(sh_pseudo_register_read): Likewise.
	(sh_pseudo_register_write): Likewise.
	(sh_frame_prev_register): Likewise.
	* sh64-tdep.c (sh64_extract_return_value): Change char to gdb_byte.
	(sh64_return_value): Change void to gdb_byte.
	(sh64_pseudo_register_read): Likewise.
	(sh64_pseudo_register_write): Likewise.
	(sh64_frame_prev_register): Likewise.
@
text
@d3 1
a3 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.38
log
@	* MAINTAINERS: Remove hint that sh64 doesn't build.
	* sh64-tdep.c (sh64_push_dummy_call): Cast buf in call to write_memory.
	(sh64_do_fp_register): make raw_buffer unsigned.
	(sh64_do_register): Ditto.
@
text
@d1231 1
a1231 1
	  char buf[8];
d1233 1
a1233 1
	  regcache_cooked_read (regcache, DR0_REGNUM, &buf);
d1316 1
a1316 1
		   void *readbuf, const void *writebuf)
d1578 1
a1578 1
			   int reg_nr, void *buffer)
d1747 1
a1747 1
			    int reg_nr, const void *buffer)
d2293 1
a2293 1
			  int *realnump, void *valuep)
@


1.37
log
@	* MAINTAINERS: Change sh64-elf state to non-broken.
	* Makefile.in: Fix dependencies for sh64-tdep.o.
	* configure.tgt: Add sh64-*-elf case.
	* sh-tdep.c (sh_gdbarch_init): Reactivate bfd_mach_sh5 case.
	* sh64-tdep.c: Rework to replace all deprecated mechanisms with
	modern methods.
	* config/sh/embed.mt (TDEPFILES): Add sh64-tdep.o.
	* config/sh/sh64.mt: Resurrect.
@
text
@d1123 2
a1124 1
		  write_memory (sp + stack_offset, val, argreg_size);
d1966 1
a1966 1
  char *raw_buffer;
d1972 1
a1972 1
  raw_buffer = (char *) alloca (register_size (gdbarch, FP0_REGNUM));
d1997 1
a1997 1
      fprintf_filtered (file, "%02x", (unsigned char) raw_buffer[idx]);
d2078 1
a2078 1
  char raw_buffer[MAX_REGISTER_SIZE];
@


1.36
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d30 3
a33 1
#include "objfiles.h"
d41 1
a42 1
#include "floatformat.h"
a43 1
#include "doublest.h"
a46 1
#include "solib-svr4.h"
d66 17
d92 1
a127 12

/* Define other aspects of the stack frame.
   we keep a copy of the worked out return pc lying around, since it
   is a useful bit of info */
  
struct frame_extra_info
{
  CORE_ADDR return_pc;
  int leaf_function;
  int f_offset;
};

d469 1
d657 1
a657 1
sh_skip_prologue (CORE_ADDR pc)
a673 12
/* Immediately after a function call, return the saved pc.
   Can't always go through the frames for this because on some machines
   the new frame is not set up until the new function executes
   some instructions.

   The return address is the value saved in the PR register + 4  */
static CORE_ADDR
sh_saved_pc_after_call (struct frame_info *frame)
{
  return (ADDR_BITS_REMOVE (read_register (PR_REGNUM)));
}

d676 1
a676 1
sh64_use_struct_convention (int gcc_p, struct type *type)
a680 10
/* Store the address of the place in which to copy the structure the
   subroutine will return.  This is called from call_function.

   We store structs through a pointer passed in R2 */
static void
sh64_store_struct_return (CORE_ADDR addr, CORE_ADDR sp)
{
  write_register (STRUCT_RETURN_REGNUM, (addr));
}

d683 1
a683 1
gdb_print_insn_sh (bfd_vma memaddr, disassemble_info *info)
a688 87
/* Given a register number RN as it appears in an assembly
   instruction, find the corresponding register number in the GDB
   scheme.  */
static int 
translate_insn_rn (int rn, int media_mode)
{
  /* FIXME: this assumes that the number rn is for a not pseudo
     register only.  */
  if (media_mode)
    return rn;
  else
    {
      /* These registers don't have a corresponding compact one.  */
      /* FIXME: This is probably not enough.  */
#if 0
      if ((rn >= 16 && rn <= 63) || (rn >= 93 && rn <= 140))
	return rn;
#endif
      if (rn >= 0 && rn <= R0_C_REGNUM)
	return R0_C_REGNUM + rn;
      else
	return rn;
    }
}

/* Given a GDB frame, determine the address of the calling function's
   frame.  This will be used to create a new GDB frame struct, and
   then DEPRECATED_INIT_EXTRA_FRAME_INFO and DEPRECATED_INIT_FRAME_PC
   will be called for the new frame.

   For us, the frame address is its stack pointer value, so we look up
   the function prologue to determine the caller's sp value, and return it.  */
static CORE_ADDR
sh64_frame_chain (struct frame_info *frame)
{
  if (deprecated_pc_in_call_dummy (get_frame_pc (frame)))
    return get_frame_base (frame);    /* dummy frame same as caller's frame */
  if (get_frame_pc (frame))
    {
      int media_mode = pc_is_isa32 (get_frame_pc (frame));
      int size;
      if (gdbarch_tdep (current_gdbarch)->sh_abi == SH_ABI_32)
	size = 4;
      else
	size = register_size (current_gdbarch, 
			      translate_insn_rn (DEPRECATED_FP_REGNUM, 
						 media_mode));
      return read_memory_integer (get_frame_base (frame)
				  + get_frame_extra_info (frame)->f_offset,
				  size);
    }
  else
    return 0;
}

static CORE_ADDR
sh64_get_saved_pr (struct frame_info *fi, int pr_regnum)
{
  int media_mode = 0;

  for (; fi; fi = get_next_frame (fi))
    if (deprecated_pc_in_call_dummy (get_frame_pc (fi)))
      /* When the caller requests PR from the dummy frame, we return
         PC because that's where the previous routine appears to have
         done a call from.  */
      return deprecated_read_register_dummy (get_frame_pc (fi),
					     get_frame_base (fi), pr_regnum);
    else
      {
	DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
	if (!get_frame_pc (fi))
	  return 0;

	media_mode = pc_is_isa32 (get_frame_pc (fi));

	if (deprecated_get_frame_saved_regs (fi)[pr_regnum] != 0)
	  {
	    int gdb_reg_num = translate_insn_rn (pr_regnum, media_mode);
	    int size = ((gdbarch_tdep (current_gdbarch)->sh_abi == SH_ABI_32)
			? 4
			: register_size (current_gdbarch, gdb_reg_num));
	    return read_memory_integer (deprecated_get_frame_saved_regs (fi)[pr_regnum], size);
	  }
      }
  return read_register (pr_regnum);
}

d691 1
a691 1
fv_reg_base_num (int fv_regnum)
d702 1
a702 1
dr_reg_base_num (int dr_regnum)
d713 1
a713 1
fpp_reg_base_num (int fpp_regnum)
a721 26
static int
is_media_pseudo (int rn)
{
  return (rn >= DR0_REGNUM && rn <= FV_LAST_REGNUM);
}

static int
sh64_media_reg_base_num (int reg_nr)
{
  int base_regnum = -1;

  if (reg_nr >= DR0_REGNUM
      && reg_nr <= DR_LAST_REGNUM)
    base_regnum = dr_reg_base_num (reg_nr);

  else if (reg_nr >= FPP0_REGNUM 
	   && reg_nr <= FPP_LAST_REGNUM)
    base_regnum = fpp_reg_base_num (reg_nr);

  else if (reg_nr >= FV0_REGNUM
	   && reg_nr <= FV_LAST_REGNUM)
    base_regnum = fv_reg_base_num (reg_nr);

  return base_regnum;
}

d787 1
a787 1
  int base_regnum = -1;
d802 1
a802 2
    base_regnum = dr_reg_base_num (DR0_REGNUM
				   + reg_nr - DR0_C_REGNUM);
d807 1
a807 2
    base_regnum = fv_reg_base_num (FV0_REGNUM
				   + reg_nr - FV0_C_REGNUM);
d820 1
a820 1
    base_regnum = 18;
a833 20
/* Given a register number RN (according to the gdb scheme) , return
   its corresponding architectural register.  In media mode, only a
   subset of the registers is pseudo registers. For compact mode, all
   the registers are pseudo.  */
static int 
translate_rn_to_arch_reg_num (int rn, int media_mode)
{

  if (media_mode)
    {
      if (!is_media_pseudo (rn))
	return rn;
      else
	return sh64_media_reg_base_num (rn);
    }
  else
    /* All compact registers are pseudo.  */
    return sh64_compact_reg_base_num (rn);
}

d844 4
a847 1
sh64_nofp_frame_init_saved_regs (struct frame_info *fi)
d849 1
a849 6
  int *where = (int *) alloca ((NUM_REGS + NUM_PSEUDO_REGS) * sizeof (int));
  int rn;
  int have_fp = 0;
  int fp_regnum;
  int sp_regnum;
  int depth;
a853 1
  int media_mode = 0;
d857 1
a857 3
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), 
							  get_frame_base (fi));
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d859 1
a859 21
  if (deprecated_get_frame_saved_regs (fi) == NULL)
    frame_saved_regs_zalloc (fi);
  else
    memset (deprecated_get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
  
  if (dummy_regs)
    {
      /* DANGER!  This is ONLY going to work if the char buffer format of
         the saved registers is byte-for-byte identical to the 
         CORE_ADDR regs[NUM_REGS] format used by struct frame_saved_regs! */
      memcpy (deprecated_get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
      return;
    }

  get_frame_extra_info (fi)->leaf_function = 1;
  get_frame_extra_info (fi)->f_offset = 0;

  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    where[rn] = -1;

  depth = 0;
d865 1
a865 6
  pc = get_frame_func (fi);
  if (!pc)
    {
      deprecated_update_frame_pc_hack (fi, 0);
      return;
    }
d867 2
a868 5
  if (pc_is_isa32 (pc))
    {
      media_mode = 1;
      insn_size = 4;
    }
d870 1
a870 4
    {
      media_mode = 0;
      insn_size = 2;
    }
d872 4
a875 7
 /* The frame pointer register is general register 14 in shmedia and
    shcompact modes. In sh compact it is a pseudo register.  Same goes
    for the stack pointer register, which is register 15.  */
  fp_regnum = translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode);
  sp_regnum = translate_insn_rn (SP_REGNUM, media_mode);

  for (opc = pc + (insn_size * 28); pc < opc; pc += insn_size)
d877 2
a878 1
      insn = read_memory_integer (media_mode ? UNMAKE_ISA32_ADDR (pc) : pc,
d881 1
a881 1
      if (media_mode == 0)
d888 2
a889 4
		  int reg_nr = PR_C_REGNUM;

		  where[reg_nr] = depth - ((((next_insn & 0xf) ^ 0x8) - 0x8) << 2);
		  get_frame_extra_info (fi)->leaf_function = 0;
d893 1
d895 2
a896 3
	    {
	      where[fp_regnum] = depth - ((((insn & 0xf) ^ 0x8) - 0x8) << 2);
	    }
d906 1
d912 1
d916 1
a916 2
	      int reg_nr = PR_C_REGNUM;
	      where[reg_nr] = depth - (r0_val - 4);
a917 1
	      get_frame_extra_info (fi)->leaf_function = 0;
d919 1
d923 2
a924 1
	      where[fp_regnum] = depth - (r0_val - 4);
d929 2
a930 3
	    {
	      depth -= ((insn & 0xff) ^ 0x80) - 0x80;
	    }
d936 3
a938 5
	  if (IS_ADDIL_SP_MEDIA (insn) 
	      || IS_ADDI_SP_MEDIA (insn))
	    {
	      depth -= sign_extend ((((insn & 0xffc00) ^ 0x80000) - 0x80000) >> 10, 9);
	    }
d941 2
a942 5
	    {
	      where[PR_REGNUM] = 
		depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 3);
	      get_frame_extra_info (fi)->leaf_function = 0;
	    }
d945 2
a946 5
	    {
	      where[PR_REGNUM] = 
		depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 2);
	      get_frame_extra_info (fi)->leaf_function = 0;
	    }
d949 2
a950 3
	    {
	      where[fp_regnum] = depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 3);
	    }
d953 2
a954 3
	    {
	      where[fp_regnum] = depth - (sign_extend ((insn & 0xffc00) >> 10, 9) << 2);
	    }
d961 2
a962 175
  /* Now we know how deep things are, we can work out their addresses.  */
  for (rn = 0; rn < NUM_REGS + NUM_PSEUDO_REGS; rn++)
    {
      register_number = translate_rn_to_arch_reg_num (rn, media_mode);

      if (where[rn] >= 0)
	{
	  if (rn == fp_regnum)
	    have_fp = 1;

	  /* Watch out! saved_regs is only for the real registers, and
	     doesn't include space for the pseudo registers.  */
	  deprecated_get_frame_saved_regs (fi)[register_number] 
	    = get_frame_base (fi) - where[rn] + depth;
	} 
      else 
	deprecated_get_frame_saved_regs (fi)[register_number] = 0;
    }

  if (have_fp)
    {
      /* SP_REGNUM is 15. For shmedia 15 is the real register. For
	 shcompact 15 is the arch register corresponding to the pseudo
	 register r15 which still is the SP register.  */
      /* The place on the stack where fp is stored contains the sp of
         the caller.  */
      /* Again, saved_registers contains only space for the real
	 registers, so we store in DEPRECATED_FP_REGNUM position.  */
      int size;
      if (tdep->sh_abi == SH_ABI_32)
	size = 4;
      else
	size = register_size (current_gdbarch, fp_regnum);
      deprecated_get_frame_saved_regs (fi)[sp_regnum] 
	= read_memory_integer (deprecated_get_frame_saved_regs (fi)[fp_regnum],
			       size);
    }
  else
    deprecated_get_frame_saved_regs (fi)[sp_regnum] = get_frame_base (fi);

  get_frame_extra_info (fi)->f_offset = depth - where[fp_regnum];
}

/* Initialize the extra info saved in a FRAME */
static void
sh64_init_extra_frame_info (int fromleaf, struct frame_info *fi)
{
  int media_mode = pc_is_isa32 (get_frame_pc (fi));

  frame_extra_info_zalloc (fi, sizeof (struct frame_extra_info));

  if (get_next_frame (fi)) 
    deprecated_update_frame_pc_hack (fi, DEPRECATED_FRAME_SAVED_PC (get_next_frame (fi)));

  if (deprecated_pc_in_call_dummy (get_frame_pc (fi)))
    {
      /* We need to setup fi->frame here because call_function_by_hand
         gets it wrong by assuming it's always FP.  */
      deprecated_update_frame_base_hack (fi, deprecated_read_register_dummy (get_frame_pc (fi), get_frame_base (fi), SP_REGNUM));
      get_frame_extra_info (fi)->return_pc = 
	deprecated_read_register_dummy (get_frame_pc (fi),
					get_frame_base (fi), PC_REGNUM);
      get_frame_extra_info (fi)->f_offset = -4;
      get_frame_extra_info (fi)->leaf_function = 0;
      return;
    }
  else
    {
      DEPRECATED_FRAME_INIT_SAVED_REGS (fi);
      get_frame_extra_info (fi)->return_pc =
	sh64_get_saved_pr (fi, PR_REGNUM);
    }
}

static void
sh64_get_saved_register (char *raw_buffer, int *optimized, CORE_ADDR *addrp,
			 struct frame_info *frame, int regnum,
			 enum lval_type *lval)
{
  int media_mode;
  int live_regnum = regnum;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  if (!target_has_registers)
    error ("No registers.");

  /* Normal systems don't optimize out things with register numbers.  */
  if (optimized != NULL)
    *optimized = 0;

  if (addrp)			/* default assumption: not found in memory */
    *addrp = 0;

  if (raw_buffer)
    memset (raw_buffer, 0, sizeof (raw_buffer));

  /* We must do this here, before the following while loop changes
     frame, and makes it NULL. If this is a media register number,
     but we are in compact mode, it will become the corresponding 
     compact pseudo register. If there is no corresponding compact 
     pseudo-register what do we do?*/
  media_mode = pc_is_isa32 (get_frame_pc (frame));
  live_regnum = translate_insn_rn (regnum, media_mode);

  /* Note: since the current frame's registers could only have been
     saved by frames INTERIOR TO the current frame, we skip examining
     the current frame itself: otherwise, we would be getting the
     previous frame's registers which were saved by the current frame.  */

  while (frame && ((frame = get_next_frame (frame)) != NULL))
    {
      if (deprecated_pc_in_call_dummy (get_frame_pc (frame)))
	{
	  if (lval)		/* found it in a CALL_DUMMY frame */
	    *lval = not_lval;
	  if (raw_buffer)
	    memcpy (raw_buffer,
		    (deprecated_generic_find_dummy_frame (get_frame_pc (frame), get_frame_base (frame))
		     + DEPRECATED_REGISTER_BYTE (regnum)),
		    register_size (current_gdbarch, regnum));
	  return;
	}

      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);
      if (deprecated_get_frame_saved_regs (frame) != NULL
	  && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
	{
	  if (lval)		/* found it saved on the stack */
	    *lval = lval_memory;
	  if (regnum == SP_REGNUM)
	    {
	      if (raw_buffer)	/* SP register treated specially */
		store_unsigned_integer (raw_buffer, 
					register_size (current_gdbarch, 
						       regnum),
					deprecated_get_frame_saved_regs (frame)[regnum]);
	    }
	  else
	    { /* any other register */
	      
	      if (addrp)
		*addrp = deprecated_get_frame_saved_regs (frame)[regnum];
	      if (raw_buffer)
		{
		  int size;
		  if (tdep->sh_abi == SH_ABI_32
		      && (live_regnum == DEPRECATED_FP_REGNUM
			  || live_regnum == PR_REGNUM))
		    size = 4;
		  else
		    size = register_size (current_gdbarch, live_regnum);
		  if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum], 
				 raw_buffer, size);
		  else
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum],
				 raw_buffer
				 + register_size (current_gdbarch, live_regnum)
				 - size,
				 size);
		}
	    }
	  return;
	}
    }

  /* If we get thru the loop to this point, it means the register was
     not saved in any frame.  Return the actual live-register value.  */

  if (lval)			/* found it in a live register */
    *lval = lval_register;
  if (addrp)
    *addrp = DEPRECATED_REGISTER_BYTE (live_regnum);
  if (raw_buffer)
    deprecated_read_register_gen (live_regnum, raw_buffer);
d977 1
a977 49
sh_frame_saved_pc (struct frame_info *frame)
{
  return (get_frame_extra_info (frame)->return_pc);
}

/* Discard from the stack the innermost frame, restoring all saved registers.
   Used in the 'return' command.  */
static void
sh64_pop_frame (void)
{
  struct frame_info *frame = get_current_frame ();
  CORE_ADDR fp;
  int regnum;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  int media_mode = pc_is_isa32 (get_frame_pc (frame));

  if (deprecated_pc_in_call_dummy (get_frame_pc (frame)))
    deprecated_pop_dummy_frame ();
  else
    {
      fp = get_frame_base (frame);
      DEPRECATED_FRAME_INIT_SAVED_REGS (frame);

      /* Copy regs from where they were saved in the frame */
      for (regnum = 0; regnum < NUM_REGS + NUM_PSEUDO_REGS; regnum++)
	if (deprecated_get_frame_saved_regs (frame)[regnum])
	  {
	    int size;
	    if (tdep->sh_abi == SH_ABI_32
		&& (regnum == DEPRECATED_FP_REGNUM
		    || regnum ==  PR_REGNUM))
	      size = 4;
	    else
	      size = register_size (current_gdbarch, 
				    translate_insn_rn (regnum, media_mode));
	    write_register (regnum,
			    read_memory_integer (deprecated_get_frame_saved_regs (frame)[regnum],
						 size));
	  }

      write_register (PC_REGNUM, get_frame_extra_info (frame)->return_pc);
      write_register (SP_REGNUM, fp + 8);
    }
  flush_cached_frames ();
}

static CORE_ADDR
sh_frame_align (struct gdbarch *ignore, CORE_ADDR sp)
d979 1
a979 1
  return sp & ~3;
d982 1
a982 1
/* Function: push_arguments
d1045 7
a1051 2
sh64_push_arguments (int nargs, struct value **args, CORE_ADDR sp,
		     int struct_return, CORE_ADDR struct_addr)
d1072 1
a1072 1
  sp = sp & ~7;
d1078 2
a1079 1
    write_register (STRUCT_RETURN_REGNUM, struct_addr);
d1133 1
a1133 1
		  write_register (int_argreg, regval);
d1159 3
a1161 2
		  deprecated_write_register_gen (FP0_REGNUM + float_arg_index,
						 val);
d1186 2
a1187 20
		    int regnum = DR0_REGNUM +
		                 double_register_offset;
#if 0
		    if (TARGET_BYTE_ORDER == BFD_ENDIAN_LITTLE)
		      {
			memset (valbuf_tmp, 0, sizeof (valbuf_tmp));
			DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL (regnum,
								type, val,
								valbuf_tmp);
			val = valbuf_tmp;
		      }
#endif
		    /* Note: must use write_register_gen here instead
		       of regcache_raw_write, because
		       regcache_raw_write works only for real
		       registers, not pseudo.  write_register_gen will
		       call the gdbarch function to do register
		       writes, and that will properly know how to deal
		       with pseudoregs.  */
		    deprecated_write_register_gen (regnum, val);
d1200 2
a1201 2
  return sp;
}
d1203 2
a1204 3
/* Function: push_return_address (pc)
   Set up the return address for the inferior function call.
   Needed for targets where we don't actually execute a JSR/BSR instruction */
a1205 4
static CORE_ADDR
sh64_push_return_address (CORE_ADDR pc, CORE_ADDR sp)
{
  write_register (PR_REGNUM, entry_point_address ());
d1214 2
a1215 1
sh64_extract_return_value (struct type *type, char *regbuf, char *valbuf)
a1216 2
  int offset;
  int return_register;
d1224 1
a1224 3
	  return_register = FP0_REGNUM;
	  offset = DEPRECATED_REGISTER_BYTE (return_register);
	  memcpy (valbuf, (char *) regbuf + offset, len);
d1230 1
d1232 1
a1232 2
	  return_register = DR0_REGNUM;
	  offset = DEPRECATED_REGISTER_BYTE (return_register);
d1236 1
a1236 1
				     (char *) regbuf + offset, &val);
d1239 1
a1239 1
				     (char *) regbuf + offset, &val);
d1247 2
d1251 2
a1252 1
	  return_register = DEFAULT_RETURN_REGNUM;
d1254 2
a1255 2
	    offset = DEPRECATED_REGISTER_BYTE (return_register) +
	      register_size (current_gdbarch, return_register) - len;
d1257 2
a1258 2
	    offset = DEPRECATED_REGISTER_BYTE (return_register);
	  memcpy (valbuf, (char *) regbuf + offset, len);
d1273 2
a1274 1
sh64_store_return_value (struct type *type, char *valbuf)
d1281 7
a1287 10
      if (len == 4)
	{
	  /* Return value stored in FP0_REGNUM */
	  deprecated_write_register_gen (FP0_REGNUM, valbuf);
	}
      if (len == 8)
	{
	  /* return value stored in DR0_REGNUM */
	  /* FIXME: Implement */
	}
d1305 1
a1305 1
	  deprecated_write_register_gen (return_register, buf);
d1308 1
a1308 1
	deprecated_write_register_gen (return_register, valbuf);
d1312 14
a1483 85
/* *INDENT-ON* */
static int
sh64_register_byte (int reg_nr)
{
  int base_regnum = -1;

  /* If it is a pseudo register, get the number of the first floating
     point register that is part of it.  */
  if (reg_nr >= DR0_REGNUM 
      && reg_nr <= DR_LAST_REGNUM)
    base_regnum = dr_reg_base_num (reg_nr);

  else if (reg_nr >= FPP0_REGNUM 
	    && reg_nr <= FPP_LAST_REGNUM)
    base_regnum = fpp_reg_base_num (reg_nr);

  else if (reg_nr >= FV0_REGNUM 
	    && reg_nr <= FV_LAST_REGNUM)
    base_regnum = fv_reg_base_num (reg_nr);

  /* sh compact pseudo register. FPSCR is a pathological case, need to
     treat it as special.  */
  else if ((reg_nr >= R0_C_REGNUM 
	    && reg_nr <= FV_LAST_C_REGNUM) 
	   && reg_nr != FPSCR_C_REGNUM)
    base_regnum = sh64_compact_reg_base_num (reg_nr);

  /* Now return the offset in bytes within the register cache.  */
  /* sh media pseudo register, i.e. any of DR, FFP, FV registers.  */
  if (reg_nr >= DR0_REGNUM 
      && reg_nr <= FV_LAST_REGNUM)
    return (base_regnum - FP0_REGNUM + 1) * 4 
      + (TR7_REGNUM + 1) * 8;

  /* sh compact pseudo register: general register */
  if ((reg_nr >= R0_C_REGNUM 
       && reg_nr <= R_LAST_C_REGNUM))
    return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	    ? base_regnum * 8 + 4
	    : base_regnum * 8);

  /* sh compact pseudo register: */
  if (reg_nr == PC_C_REGNUM 
       || reg_nr == GBR_C_REGNUM
       || reg_nr == MACL_C_REGNUM
       || reg_nr == PR_C_REGNUM)
    return (TARGET_BYTE_ORDER == BFD_ENDIAN_BIG
	    ? base_regnum * 8 + 4
	    : base_regnum * 8);

  if (reg_nr == MACH_C_REGNUM) 
    return base_regnum * 8;

  if (reg_nr == T_C_REGNUM) 
    return base_regnum * 8; /* FIXME??? how do we get bit 0? Do we have to? */

  /* sh compact pseudo register: floating point register */
  else if (reg_nr >= FP0_C_REGNUM
	   && reg_nr <= FV_LAST_C_REGNUM)
    return (base_regnum  - FP0_REGNUM) * 4
      + (TR7_REGNUM + 1) * 8 + 4;

  else if (reg_nr == FPSCR_C_REGNUM)
    /* This is complicated, for now return the beginning of the
       architectural FPSCR register.  */
    return (TR7_REGNUM + 1) * 8;

  else if (reg_nr == FPUL_C_REGNUM)
    return ((base_regnum - FP0_REGNUM) * 4 + 
	    (TR7_REGNUM + 1) * 8 + 4);

  /* It is not a pseudo register.  */
  /* It is a 64 bit register.  */
  else if (reg_nr <= TR7_REGNUM)
    return reg_nr * 8;

  /* It is a 32 bit register.  */
  else if (reg_nr == FPSCR_REGNUM)
    return (FPSCR_REGNUM * 8);

  /* It is floating point 32-bit register */
  else
    return ((TR7_REGNUM + 1) * 8 
      + (reg_nr - FP0_REGNUM + 1) * 4);
}
d1587 1
a1587 1
      base_regnum = dr_reg_base_num (reg_nr);
d1608 1
a1608 1
      base_regnum = fpp_reg_base_num (reg_nr);
d1622 1
a1622 1
      base_regnum = fv_reg_base_num (reg_nr);
d1755 1
a1755 1
      base_regnum = dr_reg_base_num (reg_nr);
d1772 1
a1772 1
      base_regnum = fpp_reg_base_num (reg_nr);
d1785 1
a1785 1
      base_regnum = fv_reg_base_num (reg_nr);
a1916 76
/* Floating point vector of 4 float registers.  */
static void
do_fv_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int fv_regnum)
{
  int first_fp_reg_num = fv_reg_base_num (fv_regnum);
  fprintf_filtered (file, "fv%d\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
		     fv_regnum - FV0_REGNUM, 
		     (int) read_register (first_fp_reg_num),
		     (int) read_register (first_fp_reg_num + 1),
		     (int) read_register (first_fp_reg_num + 2),
		     (int) read_register (first_fp_reg_num + 3));
}

/* Floating point vector of 4 float registers, compact mode.  */
static void
do_fv_c_register_info (int fv_regnum)
{
  int first_fp_reg_num = sh64_compact_reg_base_num (fv_regnum);
  printf_filtered ("fv%d_c\t0x%08x\t0x%08x\t0x%08x\t0x%08x\n", 
		     fv_regnum - FV0_C_REGNUM, 
		     (int) read_register (first_fp_reg_num),
		     (int) read_register (first_fp_reg_num + 1),
		     (int) read_register (first_fp_reg_num + 2),
		     (int) read_register (first_fp_reg_num + 3));
}

/* Pairs of single regs. The DR are instead double precision
   registers.  */
static void
do_fpp_register_info (int fpp_regnum)
{
  int first_fp_reg_num = fpp_reg_base_num (fpp_regnum);

  printf_filtered ("fpp%d\t0x%08x\t0x%08x\n", 
		    fpp_regnum - FPP0_REGNUM, 
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1));
}

/* Double precision registers.  */
static void
do_dr_register_info (struct gdbarch *gdbarch, struct ui_file *file,
		     int dr_regnum)
{
  int first_fp_reg_num = dr_reg_base_num (dr_regnum);

  fprintf_filtered (file, "dr%d\t0x%08x%08x\n", 
		    dr_regnum - DR0_REGNUM, 
		    (int) read_register (first_fp_reg_num),
		    (int) read_register (first_fp_reg_num + 1));
}

/* Double precision registers, compact mode.  */
static void
do_dr_c_register_info (int dr_regnum)
{
 int first_fp_reg_num = sh64_compact_reg_base_num (dr_regnum);

 printf_filtered ("dr%d_c\t0x%08x%08x\n",
		  dr_regnum - DR0_C_REGNUM,
		  (int) read_register (first_fp_reg_num),
		  (int) read_register (first_fp_reg_num +1));
}

/* General register in compact mode.  */
static void
do_r_c_register_info (int r_c_regnum)
{
  int regnum =  sh64_compact_reg_base_num (r_c_regnum);

  printf_filtered ("r%d_c\t0x%08x\n", 
		    r_c_regnum - R0_C_REGNUM, 
		   /*FIXME!!!*/  (int) read_register (regnum));
}

d1921 2
a1922 1
do_cr_c_register_info (int cr_c_regnum)
d1926 3
a1928 1
    case 237: printf_filtered ("pc_c\t0x%08x\n", (int) read_register (cr_c_regnum));
d1930 3
a1932 1
    case 238: printf_filtered ("gbr_c\t0x%08x\n", (int) read_register (cr_c_regnum));
d1934 3
a1936 1
    case 239: printf_filtered ("mach_c\t0x%08x\n", (int) read_register (cr_c_regnum));
d1938 3
a1940 1
    case 240: printf_filtered ("macl_c\t0x%08x\n", (int) read_register (cr_c_regnum));
d1942 3
a1944 1
    case 241: printf_filtered ("pr_c\t0x%08x\n", (int) read_register (cr_c_regnum));
d1946 3
a1948 1
    case 242: printf_filtered ("t_c\t0x%08x\n", (int) read_register (cr_c_regnum));
d1950 3
a1952 1
    case 243: printf_filtered ("fpscr_c\t0x%08x\n", (int) read_register (cr_c_regnum));
d1954 3
a1956 1
    case 244: printf_filtered ("fpul_c\t0x%08x\n", (int)read_register (cr_c_regnum));
d1962 2
a1963 1
sh_do_fp_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d1974 1
a1974 1
  if (!frame_register_read (get_selected_frame (NULL), regnum, raw_buffer))
d2003 2
a2004 1
sh64_do_pseudo_register (int regnum)
d2009 2
a2010 1
      || regnum >= NUM_REGS + NUM_PSEUDO_REGS_SH_MEDIA + NUM_PSEUDO_REGS_SH_COMPACT)
d2014 26
a2039 11
  else if ((regnum >= DR0_REGNUM
	    && regnum <= DR_LAST_REGNUM))
    do_dr_register_info (current_gdbarch, gdb_stdout, regnum);

  else if ((regnum >= DR0_C_REGNUM
	    && regnum <= DR_LAST_C_REGNUM))
    do_dr_c_register_info (regnum);

  else if ((regnum >= FV0_REGNUM
	    && regnum <= FV_LAST_REGNUM))
    do_fv_register_info (current_gdbarch, gdb_stdout, regnum);
d2041 26
a2066 14
  else if ((regnum >= FV0_C_REGNUM
	    && regnum <= FV_LAST_C_REGNUM))
    do_fv_c_register_info (regnum);

  else if (regnum >= FPP0_REGNUM
	   && regnum <= FPP_LAST_REGNUM)
    do_fpp_register_info (regnum);

  else if (regnum >= R0_C_REGNUM
	   && regnum <= R_LAST_C_REGNUM)
    /* FIXME, this function will not print the right format.  */
    do_r_c_register_info (regnum);
  else if (regnum >= FP0_C_REGNUM
	   && regnum <= FP_LAST_C_REGNUM)
d2068 3
a2070 4
    sh_do_fp_register (current_gdbarch, gdb_stdout, regnum);
  else if (regnum >= PC_C_REGNUM
	   && regnum <= FPUL_C_REGNUM)
    do_cr_c_register_info (regnum);
d2074 2
a2075 1
sh_do_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d2083 1
a2083 1
  if (!frame_register_read (get_selected_frame (NULL), regnum, raw_buffer))
d2095 2
a2096 1
sh_print_register (struct gdbarch *gdbarch, struct ui_file *file, int regnum)
d2105 1
a2105 1
	sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
d2107 1
a2107 1
	sh_do_register (gdbarch, file, regnum);	/* All other regs */
d2111 1
a2111 1
    sh64_do_pseudo_register (regnum);
d2115 3
a2117 2
sh_print_registers_info (struct gdbarch *gdbarch, struct ui_file *file,
			 struct frame_info *frame, int regnum, int fpregs)
d2124 1
a2124 1
      sh_print_register (gdbarch, file, regnum);
d2141 2
a2142 1
	  if (TYPE_CODE (gdbarch_register_type (gdbarch, regnum)) == TYPE_CODE_FLT)
d2147 1
a2147 1
		  sh_do_fp_register (gdbarch, file, regnum);	/* FP regs */
d2155 1
a2155 1
	      sh_do_register (gdbarch, file, regnum);	/* All other regs */
d2163 1
a2163 1
	    sh64_do_pseudo_register (regnum);
d2170 4
a2173 1
sh_compact_do_registers_info (int regnum, int fpregs)
d2183 1
a2183 1
      sh_print_register (current_gdbarch, gdb_stdout, regnum);
d2191 1
a2191 1
          sh64_do_pseudo_register (regnum);
d2198 2
a2199 1
sh64_do_registers_info (int regnum, int fpregs)
d2201 2
a2202 3
  if (pc_is_isa32 (get_frame_pc (deprecated_selected_frame)))
   sh_print_registers_info (current_gdbarch, gdb_stdout,
			    deprecated_selected_frame, regnum, fpregs);
d2204 1
a2204 1
   sh_compact_do_registers_info (regnum, fpregs);
d2207 7
a2213 3
/* Fetch (and possibly build) an appropriate link_map_offsets structure
   for native i386 linux targets using the struct offsets defined in
   link.h (but without actual reference to that file).
d2215 5
a2219 3
   This makes it possible to access i386-linux shared libraries from
   a gdb that was not built on an i386-linux host (for cross debugging).
   */
d2221 15
a2235 2
struct link_map_offsets *
sh_linux_svr4_fetch_link_map_offsets (void)
d2237 25
a2261 2
  static struct link_map_offsets lmo;
  static struct link_map_offsets *lmp = 0;
d2263 1
a2263 1
  if (lmp == 0)
d2265 19
a2283 1
      lmp = &lmo;
d2285 2
a2286 1
      lmo.r_debug_size = 8;	/* 20 not actual size but all we need */
d2288 7
a2294 2
      lmo.r_map_offset = 4;
      lmo.r_map_size   = 4;
d2296 1
a2296 1
      lmo.link_map_size = 20;	/* 552 not actual size but all we need */
d2298 15
a2312 2
      lmo.l_addr_offset = 0;
      lmo.l_addr_size   = 4;
d2314 5
a2318 2
      lmo.l_name_offset = 4;
      lmo.l_name_size   = 4;
d2320 4
a2323 2
      lmo.l_next_offset = 12;
      lmo.l_next_size   = 4;
d2325 18
a2342 2
      lmo.l_prev_offset = 16;
      lmo.l_prev_size   = 4;
d2345 43
a2387 1
    return lmp;
d2390 22
a2411 1
gdbarch_init_ftype sh64_gdbarch_init;
a2428 4
  /* NOTE: cagney/2002-12-06: This can be deleted when this arch is
     ready to unwind the PC first (see frame.c:get_prev_frame()).  */
  set_gdbarch_deprecated_init_frame_pc (gdbarch, deprecated_init_frame_pc_default);

d2448 1
d2454 3
d2458 12
a2469 1
  set_gdbarch_deprecated_fp_regnum (gdbarch, 14);
d2471 1
a2471 1
  set_gdbarch_print_insn (gdbarch, gdb_print_insn_sh);
d2476 5
a2480 1
  set_gdbarch_skip_prologue (gdbarch, sh_skip_prologue);
d2483 2
d2487 5
a2491 3
  set_gdbarch_deprecated_frame_saved_pc (gdbarch, sh_frame_saved_pc);
  set_gdbarch_deprecated_saved_pc_after_call (gdbarch, sh_saved_pc_after_call);
  set_gdbarch_frame_align (gdbarch, sh_frame_align);
d2493 1
a2493 3
  set_gdbarch_num_pseudo_regs (gdbarch, NUM_PSEUDO_REGS_SH_MEDIA + NUM_PSEUDO_REGS_SH_COMPACT);
  set_gdbarch_fp0_regnum (gdbarch, SIM_SH64_FR0_REGNUM);
  set_gdbarch_pc_regnum (gdbarch, 64);
a2494 26
  /* The number of real registers is the same whether we are in 
     ISA16(compact) or ISA32(media).  */
  set_gdbarch_num_regs (gdbarch, SIM_SH64_NR_REGS);

  set_gdbarch_register_name (gdbarch, sh64_register_name);
  set_gdbarch_register_type (gdbarch, sh64_register_type);
  set_gdbarch_deprecated_store_return_value (gdbarch, sh64_store_return_value);
  set_gdbarch_deprecated_register_byte (gdbarch, sh64_register_byte);
  set_gdbarch_pseudo_register_read (gdbarch, sh64_pseudo_register_read);
  set_gdbarch_pseudo_register_write (gdbarch, sh64_pseudo_register_write);

  set_gdbarch_deprecated_do_registers_info (gdbarch, sh64_do_registers_info);
  set_gdbarch_deprecated_frame_init_saved_regs (gdbarch, sh64_nofp_frame_init_saved_regs);
  set_gdbarch_breakpoint_from_pc (gdbarch, sh64_breakpoint_from_pc);

  set_gdbarch_deprecated_init_extra_frame_info (gdbarch, sh64_init_extra_frame_info);
  set_gdbarch_deprecated_frame_chain (gdbarch, sh64_frame_chain);
  set_gdbarch_deprecated_get_saved_register (gdbarch, sh64_get_saved_register);
  set_gdbarch_deprecated_extract_return_value (gdbarch, sh64_extract_return_value);
  set_gdbarch_deprecated_push_arguments (gdbarch, sh64_push_arguments);
  set_gdbarch_deprecated_push_return_address (gdbarch, sh64_push_return_address);
  set_gdbarch_deprecated_dummy_write_sp (gdbarch, deprecated_write_sp);
  set_gdbarch_deprecated_store_struct_return (gdbarch, sh64_store_struct_return);
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
  set_gdbarch_deprecated_use_struct_convention (gdbarch, sh64_use_struct_convention);
  set_gdbarch_deprecated_pop_frame (gdbarch, sh64_pop_frame);
d2501 3
@


1.35
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.c (value_contents, value_contents_writeable): New
	functions.
	* value.h (VALUE_CONTENTS): Delete macro.
	(value_contents, value_contents_writeable): Declare.
	* xstormy16-tdep.c, value.c, valops.c, valarith.c: Update.
	* stack.c, sparc-tdep.c, sparc64-tdep.c, sh-tdep.c: Update.
	* sh64-tdep.c, scm-valprint.c, scm-exp.c, s390-tdep.c: Update.
	* rs6000-tdep.c, p-valprint.c, printcmd.c: Update.
	* ppc-sysv-tdep.c, mips-tdep.c, mi/mi-main.c: Update.
	* m88k-tdep.c, m68hc11-tdep.c, m32r-tdep.c: Update.
	* jv-valprint.c, ia64-tdep.c, hppa-tdep.c: Update.
	* hpacc-abi.c, f-valprint.c, frv-tdep.c, eval.c: Update.
	* c-valprint.c, cris-tdep.c, cp-valprint.c: Update.
	* cli/cli-dump.c, breakpoint.c, avr-tdep.c, arm-tdep.c: Update.
	* arm-linux-tdep.c, amd64-tdep.c, alpha-tdep.c: Update.
	* ada-valprint.c, ada-lang.c: Update.
@
text
@d2577 1
a2577 1
		    "Invalid pseudo register number %d\n", regnum);
d2637 1
a2637 1
		    "Invalid register number %d\n", regnum);
@


1.34
log
@2004-11-12  Andrew Cagney  <cagney@@gnu.org>

	* sparc-tdep.c: Replace VALUE_TYPE with value_type.
	* v850-tdep.c, sparc64-tdep.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, s390-tdep.c, mcore-tdep.c: Ditto.
	* h8300-tdep.c, arm-linux-tdep.c, amd64-tdep.c: Ditto.
	* hppa-tdep.c, mips-tdep.c, m88k-tdep.c: Ditto.
	* m68hc11-tdep.c, m32r-tdep.c, ia64-tdep.c: Ditto.
	* frv-tdep.c, cris-tdep.c, avr-tdep.c, alpha-tdep.c: Ditto.
@
text
@d4 1
a4 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d1523 1
a1523 1
			(char *) VALUE_CONTENTS (args[argnum]), len);
d1525 1
a1525 1
		memcpy (valbuf, (char *) VALUE_CONTENTS (args[argnum]), len);
d1530 1
a1530 1
	    val = (char *) VALUE_CONTENTS (args[argnum]);
d1560 1
a1560 1
	  val = (char *) VALUE_CONTENTS (args[argnum]);
@


1.33
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d1497 1
a1497 1
    stack_alloc += ((TYPE_LENGTH (VALUE_TYPE (args[argnum])) + 7) & ~7);
d1510 1
a1510 1
      type = VALUE_TYPE (args[argnum]);
@


1.32
log
@Index: ChangeLog
2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* config/m68k/tm-linux.h (SVR4_SHARED_LIBS): Delete.
	* config/i386/tm-linux64.h (SVR4_SHARED_LIBS): Delete.
	* config/i386/nm-i386sco5.h (SVR4_SHARED_LIBS): Delete.
	* config/tm-linux.h (SVR4_SHARED_LIBS): Delete.
	* config/nm-sysv4.h (SVR4_SHARED_LIBS): Delete.
	* config/nm-linux.h (SVR4_SHARED_LIBS): Delete.
	* config/nm-gnu.h (SVR4_SHARED_LIBS): Delete.
	* sh64-tdep.c [SVR4_SHARED_LIBS]: Delete #ifdef wrapper.
	* sh-tdep.c [SVR4_SHARED_LIBS]: Delete #ifdef wrapper.

Index: doc/ChangeLog
2004-09-03  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Native Debugging): Delete SVR4_SHARED_LIBS.
@
text
@d2541 1
a2541 1
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
d2621 1
a2621 1
  if (!frame_register_read (get_selected_frame (), regnum, raw_buffer))
@


1.31
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_register_bytes): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* regcache.c (deprecated_register_bytes): New function.
	* regcache.h (deprecated_register_bytes): Declare.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init_32082): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* remote.c (init_remote_state): Update.
	* remote-vx.c (vx_prepare_to_store): Update.
	* remote-sds.c (sds_fetch_registers, sds_prepare_to_store): Update.
	* irix5-nat.c (fetch_core_registers): Update.
	* cris-tdep.c (cris_register_bytes_ok): Update.
	* config/nm-gnu.h (CHILD_PREPARE_TO_STORE): Update.
@
text
@a2738 2
#ifdef SVR4_SHARED_LIBS

a2778 1
#endif /* SVR4_SHARED_LIBS */
@


1.30
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (deprecated_frameless_function_invocation): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-tdep.c 	(arm_frameless_function_invocation): Delete.
	(arm_gdbarch_init) Do not set frameless function invocation.
	* frame.h (legacy_frameless_look_for_prologue): Delete declaration.
	* blockframe.c (legacy_frameless_look_for_prologue): Delete function.
	* frv-tdep.c (frv_frameless_function_invocation): Delete.
	(frv_gdbarch_init): Do not set frameless function invocation.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
@
text
@a2852 3
  set_gdbarch_deprecated_register_bytes (gdbarch,
					 ((SIM_SH64_NR_FP_REGS + 1) * 4)
					 + (SIM_SH64_NR_REGS - SIM_SH64_NR_FP_REGS -1) * 8);
@


1.29
log
@2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_USE_STRUCT_CONVENTION): Deprecated.
	* gdbarch.h, gdbarch.c: Re-generate.
	* values.c (using_struct_return): Update call.
	* mcore-tdep.c: Update comment.
	* infcall.c (call_function_by_hand): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* arch-utils.h (always_use_struct_convention): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-06-20  Andrew Cagney  <cagney@@gnu.org>

	* gdbint.texinfo (Target Architecture Definition): Deprecate
	USE_STRUCT_CONVENTION.
@
text
@a2839 1
  set_gdbarch_deprecated_frameless_function_invocation (gdbarch, legacy_frameless_look_for_prologue);
@


1.28
log
@2004-06-10  Andrew Cagney  <cagney@@gnu.org>

	* gdbarch.sh (DEPRECATED_PC_IN_CALL_DUMMY): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* frame.h (deprecated_pc_in_call_dummy): Delete "sp" and "fp"
	parameters.
	* dummy-frame.c (deprecated_pc_in_call_dummy): Update.
	* arm-tdep.c (arm_pc_is_thumb_dummy): Call
	deprecated_pc_in_call_dummy instead of
	DEPRECATED_PC_IN_CALL_DUMMY.
	(arm_skip_prologue): Ditto.
	* xstormy16-tdep.c (xstormy16_pop_frame, xstormy16_scan_prologue)
	(xstormy16_frame_saved_pc, xstormy16_frame_chain): Ditto.
	* v850-tdep.c (v850_find_callers_reg, v850_frame_chain)
	(v850_pop_frame, v850_frame_saved_pc, v850_frame_init_saved_regs):
	Ditto.
	* sh64-tdep.c (sh64_frame_chain, sh64_get_saved_pr)
	(sh64_init_extra_frame_info, sh64_get_saved_register)
	(sh64_pop_frame): Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* mcore-tdep.c (mcore_find_callers_reg, mcore_frame_saved_pc)
	(mcore_pop_frame, mcore_init_extra_frame_info): Ditto.
	* h8300-tdep.c (h8300_frame_chain, h8300_frame_saved_pc)
	(h8300_pop_frame): Ditto.
	* blockframe.c (legacy_inside_entry_func)
	(legacy_frame_chain_valid): Ditto.
	* frame.c (frame_type_from_pc, legacy_get_prev_frame): Update call
	to deprecated_pc_in_call_dummy.
@
text
@d2878 1
a2878 1
  set_gdbarch_use_struct_convention (gdbarch, sh64_use_struct_convention);
@


1.27
log
@2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_CALL_DUMMY_WORDS)
	(DEPRECATED_SIZEOF_CALL_DUMMY_WORDS): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
	* arm-linux-tdep.c (arm_linux_call_dummy_words)
	(arm_linux_init_abi): Do not set deprecated_call_dummy_words or
	deprecated_sizeof_call_dummy_words.
	* arm-tdep.c (arm_call_dummy_words, arm_gdbarch_init): Ditto.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_call_dummy_words, ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* arch-utils.h (legacy_call_dummy_words)
	(legacy_sizeof_call_dummy_words): Delete declarations.
	* arch-utils.c (legacy_call_dummy_words)
	(legacy_sizeof_call_dummy_words): Delete variables.

Index: doc/ChangeLog
2004-05-08  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Delete
	description of DEPRECATED_CALL_DUMMY_WORDS,
	DEPRECATED_SIZEOF_CALL_DUMMY_WORDS, and CALL_DUMMY.
@
text
@d739 1
a739 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
d765 1
a765 2
    if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				     get_frame_base (fi)))
d1214 1
a1214 2
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (fi), get_frame_base (fi),
				   get_frame_base (fi)))
d1271 1
a1271 3
      if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				       get_frame_base (frame),
				       get_frame_base (frame)))
d1366 1
a1366 3
  if (DEPRECATED_PC_IN_CALL_DUMMY (get_frame_pc (frame),
				   get_frame_base (frame),
				   get_frame_base (frame)))
@


1.26
log
@2004-04-30  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (deprecated_inside_entry_file): Delete declaration.
	* blockframe.c (deprecated_inside_entry_file): Delete function.
	(legacy_frame_chain_valid): Delete call.
	* sh64-tdep.c (sh64_frame_chain): Delete call.
	* objfiles.h: Update comments.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Delete
	call.
	* frame.c (get_prev_frame): Delete call, update comments.
@
text
@a2795 1
  static LONGEST sh64_call_dummy_words[] = {0};
a2875 2
  set_gdbarch_deprecated_call_dummy_words (gdbarch, sh64_call_dummy_words);
  set_gdbarch_deprecated_sizeof_call_dummy_words (gdbarch, sizeof (sh64_call_dummy_words));
@


1.25
log
@2004-04-02  Andrew Cagney  <cagney@@redhat.com>

	* sh64-tdep.c (sh64_init_extra_frame_info): Replace
	DEPRECATED_CALL_DUMMY_LENGTH with 0, simplify.
	* dummy-frame.h: Delete out-of-date comments.
	* gdbarch.sh (DEPRECATED_CALL_DUMMY_LENGTH): Delete.
	* gdbarch.h, gdbarch.c: Re-generate.
@
text
@d743 1
a743 2
  if (get_frame_pc (frame)
      && !deprecated_inside_entry_file (get_frame_pc (frame)))
@


1.24
log
@2004-03-22  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (generic_pop_current_frame): Delete declaration.
	(deprecate_pop_dummy_frame): Deprecate
	generic_pop_dummy_frame.
	* dummy-frame.c (deprecated_pop_dummy_frame): Update.
	(generic_pop_current_frame): Delete function.
	* mn10300-tdep.c (mn10300_pop_frame): Eliminate call to
	generic_pop_current_frame.
	* v850-tdep.c (v850_pop_frame): Update.
	* mcore-tdep.c (mcore_pop_frame): Update.
	* sh64-tdep.c (sh64_pop_frame): Update.
	* h8300-tdep.c (h8300_pop_frame): Update.
@
text
@d1227 1
a1227 1
      get_frame_extra_info (fi)->f_offset = -(DEPRECATED_CALL_DUMMY_LENGTH + 4);
@


1.23
log
@2004-02-09  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_FRAMELESS_FUNCTION_INVOCATION): Predicate
	and function replacing FRAMELESS_FUNCTION_INVOCATION.
	* blockframe.c (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* frame.h (legacy_frameless_look_for_prologue): Rename
	frameless_look_for_prologue.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* ppc-linux-tdep.c (ppc_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	(delta68_frame_args_address): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	(frv_frameless_function_invocation): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	(cris_frameless_function_invocation): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* stack.c (frame_info): Update, call predicate.
	* rs6000-tdep.c (rs6000_frame_chain): Update, call predicate..
	* frame.c (legacy_get_prev_frame): Update, call predicate..
	* arch-utils.c (generic_frameless_function_invocation_not): Delete.
	* arch-utils.h (generic_frameless_function_invocation_not): Delete.
	* alpha-tdep.c (alpha_gdbarch_init): Do not set frameless function
	invocation.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
@
text
@d1376 1
a1376 1
    generic_pop_dummy_frame ();
@


1.23.2.1
log
@Merge mainline to intercu branch.
@
text
@d1376 1
a1376 1
    deprecated_pop_dummy_frame ();
@


1.23.2.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d739 3
a741 1
  if (deprecated_pc_in_call_dummy (get_frame_pc (frame)))
d743 2
a744 1
  if (get_frame_pc (frame))
d768 2
a769 1
    if (deprecated_pc_in_call_dummy (get_frame_pc (fi)))
d1218 2
a1219 1
  if (deprecated_pc_in_call_dummy (get_frame_pc (fi)))
d1227 1
a1227 1
      get_frame_extra_info (fi)->f_offset = -4;
d1276 3
a1278 1
      if (deprecated_pc_in_call_dummy (get_frame_pc (frame)))
d1373 3
a1375 1
  if (deprecated_pc_in_call_dummy (get_frame_pc (frame)))
d2748 2
d2790 1
d2797 1
d2850 1
d2864 3
d2878 2
d2890 1
a2890 1
  set_gdbarch_deprecated_use_struct_convention (gdbarch, sh64_use_struct_convention);
@


1.22
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d2850 1
a2850 1
  set_gdbarch_frameless_function_invocation (gdbarch, frameless_look_for_prologue);
@


1.21
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FRAME_ARGS_SKIP): Default to 0.
	* gdbarch.h, gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* mn10300-tdep.c (mn10300_gdbarch_init): Update.
	* mips-tdep.c (mips_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* hppa-tdep.c (hppa_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* d10v-tdep.c (d10v_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* avr-tdep.c (avr_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.
@
text
@d31 1
a31 1
#include "symfile.h"
@


1.20
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (EXTRACT_STRUCT_VALUE_ADDRESS): Deprecate.  Add
	comments mentioning extract_returned_value_address.
	* infcmd.c (print_return_value): Update.  Add comments on
	extract_returned_value_address.
	* stack.c (return_command): Add comments on
	extract_returned_value_address.
	* values.c: Update comment.
	* m32r-tdep.c: Update comment.
	* sparc-tdep.c: Update comment.
	* ia64-tdep.c (ia64_use_struct_convention): Update comment.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* sh-tdep.c (sh_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* rs6000-tdep.c (rs6000_gdbarch_init): Update.
	* m68klinux-tdep.c (m68k_linux_init_abi): Update.
	* m68k-tdep.c (m68k_gdbarch_init): Update.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Update.
	* m32r-tdep.c (m32r_gdbarch_init): Update.
	* ia64-tdep.c (ia64_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* frv-tdep.c (frv_gdbarch_init): Update.
	* arm-tdep.c (arm_gdbarch_init): Update.
	* alpha-tdep.c (alpha_gdbarch_init): Update.

Index: doc/ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	EXTRACT_STRUCT_VALUE_ADDRESS to
	DEPRECATED_EXTRACT_STRUCT_VALUE_ADDRESS.
@
text
@a2849 1
  set_gdbarch_frame_args_skip (gdbarch, 0);
@


1.19
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c: Update copyright.
	(xstormy16_extract_struct_value_address): Update to current
	extract struct value address interface.
	(xstormy16_gdbarch_init): Set extract_struct_value_address.
	* sh64-tdep.c (sh64_extract_struct_value_address): Update to
	current extract struct value address interface.
	(sh64_gdbarch_init): Set extract_struct_value_address.
@
text
@d2890 1
a2890 1
  set_gdbarch_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
@


1.18
log
@2004-01-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DECR_PC_AFTER_BREAK): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	DECR_PC_AFTER_BREAK to zero.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-interix-tdep.c (i386_interix_init_abi): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* i386-nto-tdep.c (i386nto_init_abi): Add comment.
@
text
@d1345 1
a1345 1
sh64_extract_struct_value_address (char *regbuf)
d1347 6
a1352 3
  return (extract_unsigned_integer ((regbuf + DEPRECATED_REGISTER_BYTE (STRUCT_RETURN_REGNUM)), 
				    register_size (current_gdbarch, 
						   STRUCT_RETURN_REGNUM)));
d2890 1
a2890 1
  set_gdbarch_deprecated_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
@


1.17
log
@2004-01-16  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c: Update copyright year.
	(compare_symbols): Delete unused function.
	* stabsread.c: Update copyright year.
	(lrs_general_complaint): Delete unused function.
	(ref_search_value): Ditto.
	(get_substring): Delete declaration.
	* sh64-tdep.c: Update copyright year.
	(sh64_get_gdb_regnum): Delete unused function.
	* dwarf2read.c (dwarf2_unsupported_at_frame_base_complaint):
	Delete unused function.
@
text
@a2845 1
  set_gdbarch_decr_pc_after_break (gdbarch, 0);
@


1.16
log
@2004-01-13  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (FUNCTION_START_OFFSET): Make zero the default.
	* gdbarch.c: Re-generate.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Do not set
	FUNCTION_START_OFFSET.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc32_gdbarch_init): Ditto.
	* sh64-tdep.c (sh64_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* ns32k-tdep.c (ns32k_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* m32r-tdep.c (m32r_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* d10v-tdep.c (d10v_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.
@
text
@d2 3
a4 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
a831 6
}

static int
sh64_get_gdb_regnum (int gcc_regnum, CORE_ADDR pc)
{
  return translate_insn_rn (gcc_regnum, pc_is_isa32 (pc));
@


1.15
log
@2003-11-12  Michael Snyder  <msnyder@@redhat.com>

        * sh64_tdep.c: Regularize some names.
        (sh_sh64_register_name): Rename to sh64_register_name.
        (sh_sh64_breakpoint_from_pc): Rename to sh64_breakpoint_from_pc.
        (sh_sh64_register_byte): Rename to sh64_register_byte.
        (sh_sh64_build_float_register_type):
        Rename to sh64_build_float_register_type.
        (sh_sh64_register_convert_to_virtual):
        Rename to sh64_register_convert_to_virtual.
        (sh_sh64_register_convert_to_raw):
        Rename to sh64_register_convert_to_raw.
@
text
@a2851 1
  set_gdbarch_function_start_offset (gdbarch, 0);
@


1.15.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.15.2.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 2
a3 3

   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
d834 6
d1350 1
a1350 1
sh64_extract_struct_value_address (struct regcache *regcache)
d1352 3
a1354 6
  /* FIXME: cagney/2004-01-17: Does the ABI guarantee that the return
     address regster is preserved across function calls?  Probably
     not, making this function wrong.  */
  ULONGEST val;
  regcache_raw_read_unsigned (regcache, STRUCT_RETURN_REGNUM, &val);
  return val;
d2851 2
@


1.14
log
@2003-11-12  Michael Snyder  <msnyder@@redhat.com>

	* sh64-tdep.c (translate_insn_rn, is_media_pseudo,
	sh64_media_reg_base_num, sh64_compact_reg_base_num,
	sh64_nofp_frame_init_saved_regs, sh64_push_arguments,
	sh64_extract_return_value, sh64_show_media_regs,
	sh64_show_compact_regs, sh_sh64_register_byte, sh64_register_type,
	sh_sh64_register_convert_to_virtual, sh_sh64_register_convert_to_raw,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_do_pseudo_register, sh_compact_print_registers_info):
	Delete unused variable 'tdep'.
@
text
@d122 1
a122 1
sh_sh64_register_name (int reg_nr)
d251 1
a251 1
sh_sh64_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d1324 2
a1325 1
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum], raw_buffer, size);
d1921 1
a1921 1
sh_sh64_register_byte (int reg_nr)
d2006 1
a2006 1
sh_sh64_build_float_register_type (int high)
d2031 1
a2031 1
    return sh_sh64_build_float_register_type (1);
d2036 1
a2036 1
    return sh_sh64_build_float_register_type (3);
d2047 1
a2047 1
sh_sh64_register_convert_to_virtual (int regnum, struct type *type,
d2065 1
a2065 1
      store_typed_floating(to, type, val);
d2068 1
a2068 1
    error("sh64_register_convert_to_virtual called with non DR register number");
d2072 1
a2072 1
sh_sh64_register_convert_to_raw (struct type *type, int regnum,
d2092 1
a2092 1
    error("sh64_register_convert_to_raw called with non DR register number");
d2118 4
a2121 4
      sh_sh64_register_convert_to_virtual (reg_nr, 
					   gdbarch_register_type (gdbarch, 
								  reg_nr),
					   temp_buffer, buffer);
d2190 4
a2193 4
      sh_sh64_register_convert_to_virtual (reg_nr, 
					   gdbarch_register_type (gdbarch, 
								  reg_nr),
					   temp_buffer, buffer);
d2277 3
a2279 4
      sh_sh64_register_convert_to_raw (gdbarch_register_type (gdbarch, 
							      reg_nr), reg_nr,
				       buffer, temp_buffer);
	  
d2351 4
a2354 4
	  sh_sh64_register_convert_to_raw (gdbarch_register_type (gdbarch,
								  reg_nr), 
					   reg_nr,
					   buffer, temp_buffer);
d2873 1
a2873 1
  set_gdbarch_register_name (gdbarch, sh_sh64_register_name);
d2876 1
a2876 1
  set_gdbarch_deprecated_register_byte (gdbarch, sh_sh64_register_byte);
d2882 1
a2882 1
  set_gdbarch_breakpoint_from_pc (gdbarch, sh_sh64_breakpoint_from_pc);
@


1.13
log
@2003-11-12  Michael Snyder  <msnyder@@redhat.com>

	* sh64-tdep.c: Coding standard and spelling comment fixes.
	(sh64_extract_return_value): Replace deprecated_store_floating
	with store_typed_floating.
	(sh_sh64_register_convert_to_raw): Replace
	deprecated_store_floating with store_typed_floating.
	(sh_sh64_register_virtual_type): Convert to sh64_register_type.
	(sh64_frame_chain, sh64_get_saved_pr, sh64_get_saved_register,
	sh64_nofp_frame_init_saved_regs, sh64_push_arguments,
	sh64_extract_struct_value_address, sh64_pop_frame,
	sh64_extract_return_value, sh64_store_return_value,
	sh_sh64_register_convert_to_virtual, sh64_pseudo_register_read,
	sh_sh64_register_convert_to_raw, sh_pseudo_register_write):
	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	Replace DEPRECATED_REGISTER_VIRTUAL_TYPE with register_type.
	(sh64_gdbarch_init): Don't set deprecated_register_bytes,
	deprecated_register_virtual_type, deprecated_register_raw_size,
	deprecated_max_register_raw_size, or
	deprecated_max_register_virtual_size.  Instead, just set
	gdbarch_register_type.
@
text
@a708 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

d830 1
a830 4
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

  return (rn >= DR0_REGNUM 
	  && rn <= FV_LAST_REGNUM);
a842 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a924 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1019 2
a1020 1
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), get_frame_base (fi));
a1492 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a1664 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a1763 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a1801 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a1922 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a2017 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

a2048 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

a2073 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);

a2101 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a2269 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
a2583 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
a2717 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.12
log
@2003-11-07  Michael Chastain  <mec@@shout.net>

	* symtab.h (struct minimal_symbol): Add size.
	* dbxread.c: Use it.
	* elfread.c: (record_minimal_symbol_and_info): Do not use info.
	Rename to record_minimal_symbol.
	(elf_symtab_read): Set MSYMBOL_SIZE explicitly.
	* minsyms.c (prim_record_minimal_symbol_and_info): Initialize MSYMBOL_SIZE.
	(install_minimal_symbols): Ditto.
	* objfiles.c (terminate_minimal_symbol_table): Ditto.
	* arm-tdep.c: Delete unused MSYMBOL_SIZE.
	* m68hc11-tdep.c: Ditto.
	* mips-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
@
text
@d52 1
a52 1
/* Information that is dependent on the processor variant. */
d81 1
a81 1
       registers are called FR, and the floating point pairs are called FP. */
d236 1
a236 1
     ISA32 (shmedia) address. */
d395 1
a395 1
   where Rm is one of r2-r9 which are the argument registers. */
d402 1
a402 1
   where Rm is one of r2-r9 which are the argument registers. */
d448 2
a449 2
/* Skip the prologue using the debug information. If this fails we'll
   fall back on the 'guess' method below. */
d493 1
a493 1
		 the SP has been saved, unfortunately. */
d503 1
a503 1
	      /* These instructions store directly the argument in r14. */
d518 1
a518 1
		 the SP has been saved, unfortunately. */
d527 1
a527 1
	      /* These instructions store directly the argument in r14. */
d548 1
a548 1
		 needs to be considered part of the prologue. */
d612 1
a612 1
		   gdb can print the frames correctly. */
d638 1
a638 1
		   gdb can print the frames correctly. */
d659 1
a659 1
     fall back on the instruction skipping code. */
d705 1
a705 1
   scheme. */
d709 1
a709 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d712 1
a712 1
     register only. */
d717 2
a718 2
      /* These registers don't have a corresponding compact one. */
      /* FIXME: This is probably not enough. */
d743 1
a743 1
    return get_frame_base (frame);	/* dummy frame same as caller's frame */
d752 3
a754 1
	size = DEPRECATED_REGISTER_RAW_SIZE (translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode));
d771 3
a773 2
      /* When the caller requests PR from the dummy frame, we return PC because
         that's where the previous routine appears to have done a call from. */
d789 1
a789 1
			: DEPRECATED_REGISTER_RAW_SIZE (gdb_reg_num));
d796 1
a796 1
/* For vectors of 4 floating point registers. */
d832 1
a832 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d848 1
a848 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d931 1
a931 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d972 1
a972 1
    base_regnum = FPSCR_REGNUM; /*???? this register is a mess. */
d983 1
a983 1
   the registers are pseudo. */
d996 1
a996 1
    /* All compact registers are pseudo. */
d1027 1
a1027 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1053 1
a1053 1
     after 20 of them, since we're getting silly then. */
d1075 1
a1075 1
    for the stack pointer register, which is register 15. */
d1114 1
a1114 1
		 We already have the offset in r0_val. */
d1175 1
a1175 1
  /* Now we know how deep things are, we can work out their addresses. */
d1186 3
a1188 3
	     doesn't include space for the pseudo registers. */
	  deprecated_get_frame_saved_regs (fi)[register_number]= get_frame_base (fi) - where[rn] + depth; 
	    
d1191 1
a1191 1
	deprecated_get_frame_saved_regs (fi)[register_number] = 0; 
d1198 1
a1198 1
	 register r15 which still is the SP register. */
d1200 1
a1200 1
         the caller. */
d1207 4
a1210 2
	size = DEPRECATED_REGISTER_RAW_SIZE (fp_regnum);
      deprecated_get_frame_saved_regs (fi)[sp_regnum] = read_memory_integer (deprecated_get_frame_saved_regs (fi)[fp_regnum], size);
d1215 1
a1215 1
  get_frame_extra_info (fi)->f_offset = depth - where[fp_regnum]; 
d1257 1
a1257 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1297 1
a1297 1
		    DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1310 3
a1312 1
		store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum),
d1328 1
a1328 1
		    size = DEPRECATED_REGISTER_RAW_SIZE (live_regnum);
d1334 1
a1334 1
				 + DEPRECATED_REGISTER_RAW_SIZE (live_regnum)
d1358 2
a1359 1
				    DEPRECATED_REGISTER_RAW_SIZE (STRUCT_RETURN_REGNUM)));
d1369 1
a1369 1
   Used in the 'return' command. */
d1376 1
a1376 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1399 2
a1400 2
	      size = DEPRECATED_REGISTER_RAW_SIZE (translate_insn_rn (regnum,
							   media_mode));
d1478 1
a1478 1
   for which the prototype is not known. */
d1499 1
a1499 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1533 1
a1533 1
	  argreg_size = DEPRECATED_REGISTER_RAW_SIZE (int_argreg);
d1569 1
a1569 1
		 before we use its size. */
d1593 1
a1593 1
		  /* Skip the corresponding general argument register. */
d1599 1
a1599 1
		   necessary spilling on the stack. */
d1614 1
a1614 1
		       i.e. includes odd numbers. */
d1634 1
a1634 1
		       with pseudoregs. */
d1638 1
a1638 1
		    /* Skip the corresponding general argument register. */
d1644 1
a1644 1
                     necessary spilling on the stack. */
d1672 1
a1672 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1681 1
a1681 1
	  memcpy (valbuf, (char *) regbuf + offset, len); 
d1697 1
a1697 1
	  deprecated_store_floating (valbuf, len, val);
d1705 1
a1705 1
	     at the most significant end. */
d1709 1
a1709 1
	      DEPRECATED_REGISTER_RAW_SIZE (return_register) - len;
d1724 1
a1724 1
   the result is stored in r0, left-justified. */
d1729 1
a1729 1
  char buf[64];	/* more than enough... */
d1750 1
a1750 1
      if (len <= DEPRECATED_REGISTER_RAW_SIZE (return_register))
d1752 2
a1753 2
	  /* Pad with zeros. */
	  memset (buf, 0, DEPRECATED_REGISTER_RAW_SIZE (return_register));
d1755 2
a1756 1
	    offset = 0; /*DEPRECATED_REGISTER_RAW_SIZE (return_register) - len;*/
d1758 1
a1758 1
	    offset = DEPRECATED_REGISTER_RAW_SIZE (return_register) - len;
d1772 1
a1772 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1811 1
a1811 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1849 2
a1850 2
/*FIXME!!! This only shows the registers for shmedia, excluding the
  pseudo registers. */
d1933 1
a1933 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d1936 1
a1936 1
     point register that is part of it. */
d1950 1
a1950 1
     treat it as special. */
d1956 2
a1957 2
  /* Now return the offset in bytes within the register cache. */
  /* sh media pseudo register, i.e. any of DR, FFP, FV registers. */
d1993 1
a1993 1
       architectural FPSCR register. */
d2000 2
a2001 2
  /* It is not a pseudo register. */
  /* It is a 64 bit register. */
d2005 1
a2005 1
  /* It is a 32 bit register. */
a2014 35
static int
sh_sh64_register_raw_size (int reg_nr)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 

  if ((reg_nr >= DR0_REGNUM 
       && reg_nr <= DR_LAST_REGNUM)
      || (reg_nr >= FPP0_REGNUM 
	  && reg_nr <= FPP_LAST_REGNUM)
      || (reg_nr >= DR0_C_REGNUM 
	  && reg_nr <= DR_LAST_C_REGNUM)
      || (reg_nr <= TR7_REGNUM))
    return 8;

  else if ((reg_nr >= FV0_REGNUM 
	    && reg_nr <= FV_LAST_REGNUM)
	   || (reg_nr >= FV0_C_REGNUM 
	       && reg_nr <= FV_LAST_C_REGNUM))
    return 16;

  else /* this covers also the 32-bit SH compact registers. */
    return 4;
}

/* ??????? FIXME */
static int
sh_sh64_register_virtual_size (int reg_nr)
{
  if (reg_nr >= FP0_REGNUM
      && reg_nr <= FP_LAST_REGNUM)
    return 4;
  else
    return 8;
}

d2024 2
d2027 1
a2027 1
sh_sh64_register_virtual_type (int reg_nr)
d2029 1
a2029 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d2062 1
a2062 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d2066 2
a2067 2
      /* It is a no-op. */
      memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d2077 3
a2079 2
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword, from, &val);
      deprecated_store_floating(to, TYPE_LENGTH(type), val);
d2082 1
a2082 1
    error("sh_register_convert_to_virtual called with non DR register number");
d2089 1
a2089 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d2093 2
a2094 2
      /* It is a no-op. */
      memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d2104 2
a2105 1
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword, &val, to);
d2108 1
a2108 1
    error("sh_register_convert_to_raw called with non DR register number");
d2119 1
a2119 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch); 
d2126 1
a2126 1
      /* Build the value in the provided buffer. */ 
d2128 1
a2128 1
	 concatenating 2 single precision floating point registers. */
d2132 1
a2132 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2134 4
a2137 2
      /* We must pay attention to the endiannes. */
      sh_sh64_register_convert_to_virtual (reg_nr, DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr),
d2147 1
a2147 1
      /* Build the value in the provided buffer. */ 
d2149 1
a2149 1
	 concatenating 2 single precision floating point registers. */
d2153 1
a2153 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2161 1
a2161 1
      /* Build the value in the provided buffer. */ 
d2163 1
a2163 1
	 concatenating 4 single precision floating point registers. */
d2167 1
a2167 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2176 1
a2176 1
      /* Build the value in the provided buffer. */ 
d2188 1
a2188 1
      /* Build the value in the provided buffer. */ 
d2190 1
a2190 1
	 they have the same size and endienness. */
d2200 1
a2200 1
	 concatenating 2 single precision floating point registers. */
d2204 1
a2204 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2206 4
a2209 2
      /* We must pay attention to the endiannes. */
      sh_sh64_register_convert_to_virtual (reg_nr, DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr),
d2218 1
a2218 1
      /* Build the value in the provided buffer. */ 
d2220 1
a2220 1
	 concatenating 4 single precision floating point registers. */
d2224 1
a2224 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2240 1
a2240 1
      /* Build the value in the provided buffer. */ 
d2256 1
a2256 1
      /* Get value as an int. */
d2260 1
a2260 1
      /* Get value as an int. */
d2262 1
a2262 1
      /* Build the new value. */
d2268 1
a2268 1
      /* FIXME There is surely an endianness gotcha here. */
d2276 1
a2276 1
	 same size, same endianness. */
d2294 3
a2296 2
      /* We must pay attention to the endiannes. */
      sh_sh64_register_convert_to_raw (DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
d2304 2
a2305 1
			     + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2317 2
a2318 1
			     + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2330 2
a2331 1
			     + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2340 1
a2340 1
      /* reg_nr is 32 bit here, and base_regnum is 64 bits. */
d2347 1
a2347 1
	 value of the pseudo will leave the upper 4 bytes unchanged. */
d2355 1
a2355 1
     registers. Both are 4 bytes. */
d2369 4
a2372 2
	  /* We must pay attention to the endiannes. */
	  sh_sh64_register_convert_to_raw (DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
d2377 2
a2378 1
			       + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2391 2
a2392 1
			       + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2424 1
a2424 1
      /* Get value as an int. */
d2427 1
a2427 1
      /* Build the new values. */
d2456 1
a2456 1
/* Floating point vector of 4 float registers. */
d2470 1
a2470 1
/* Floating point vector of 4 float registers, compact mode. */
d2484 1
a2484 1
   registers. */
d2496 1
a2496 1
/* Double precision registers. */
d2509 1
a2509 1
/* Double precision registers, compact mode. */
d2521 1
a2521 1
/* General register in compact mode. */
d2533 2
a2534 2
   shmedia REGISTERS. */
/* Control registers, compact mode. */
d2567 1
a2567 1
  /* Allocate space for the float. */
d2577 1
a2577 1
  /* Print the name and some spaces. */
d2581 1
a2581 1
  /* Print the value. */
d2587 1
a2587 1
  /* Print the fp register as hex. */
d2602 2
a2603 2
  /* All the sh64-compact mode registers are pseudo registers. */
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d2632 2
a2633 2
    do_r_c_register_info (regnum); /* FIXME, this function will not print the right format */

d2636 2
a2637 2
    sh_do_fp_register (current_gdbarch, gdb_stdout, regnum); /* this should work also for pseudoregs */

a2640 1

d2738 1
a2738 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch); 
d2768 1
a2768 1
   sh_compact_do_registers_info (regnum, fpregs); 
d2830 1
a2830 1
     provided. */
d2841 1
a2841 1
      /* If the ABI is the 64-bit one, it can only be sh-media. */
d2849 1
a2849 1
	 compact. */
d2887 2
a2888 2
  /* the number of real registers is the same whether we are in 
     ISA16(compact) or ISA32(media). */
a2889 1
  set_gdbarch_deprecated_register_size (gdbarch, 8); /*????*/
d2895 1
a2895 1
  set_gdbarch_deprecated_register_virtual_type (gdbarch, sh_sh64_register_virtual_type);
a2896 2
  set_gdbarch_deprecated_register_raw_size (gdbarch, sh_sh64_register_raw_size);
  set_gdbarch_deprecated_register_virtual_size (gdbarch, sh_sh64_register_raw_size);
a2897 7
  /* This seems awfully wrong!*/
  /*set_gdbarch_deprecated_max_register_raw_size (gdbarch, 8);*/
  /* should include the size of the pseudo regs. */
  set_gdbarch_deprecated_max_register_raw_size (gdbarch, 4 * 4);
  /* Or should that go in the virtual_size? */
  /*set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 8);*/
  set_gdbarch_deprecated_max_register_virtual_size (gdbarch, 4 * 4);
@


1.11
log
@2003-10-10  Kei Sakamoto  <sakamoto.kei@@renesas.com>

	* NEWS: Replace "Hitachi" and "Mitsubishi" with "Renesas".
	* README: Ditto.
	* d10v-tdep.c: Ditto.
	* h8300-tdep.c: Ditto.
	* remote-e7000.c: Ditto.
	* remote-hms.c: Ditto.
	* ser-e7kpc.c: Ditto.
	* sh-stub.c: Ditto.
	* sh-tdep.c: Ditto.
	* sh-tdep.h: Ditto.
	* sh3-rom.c: Ditto.
	* sh64-tdep.c: Ditto.
	* top.c: Ditto.
	* wince.c: Ditto.
	* config/d10v/d10v.mt: Ditto.
	* config/sh/embed.mt: Ditto.
	* config/sh/linux.mt: Ditto.
	* config/sh/tm-linux.h: Ditto.
	* config/sh/tm-sh.h: Ditto.
	* config/sh/wince.mt: Ditto.
@
text
@d200 1
a200 3
   symbol's "info" field is used for this purpose. This field is
   already being used to store the symbol size, so the assumption is
   that the symbol size cannot exceed 2^31.
d206 1
a206 3
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol
   MSYMBOL_SIZE         returns the size of the minimal symbol, i.e.
   the "info" field with the "special" bit masked out */
@


1.10
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@d1 1
a1 1
/* Target-dependent code for Hitachi Super-H, for GDB.
d1417 1
a1417 1
   On the Hitachi SH architecture, there are four registers (R4 to R7)
@


1.9
log
@2003-09-29  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_VIRTUAL_TYPE): Rename
	DEPRECATED_REGISTER_VIRTUAL_TYPE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arch-utils.c,	hppa-tdep.c, regcache.c, regcache.h: Update.
	* sh64-tdep.c, sparc-tdep.c: Update.

2003-09-30  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_VIRTUAL_TYPE to DEPRECATED_REGISTER_VIRTUAL_TYPE.
@
text
@d756 1
a756 1
	size = REGISTER_RAW_SIZE (translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode));
d790 1
a790 1
			: REGISTER_RAW_SIZE (gdb_reg_num));
d1208 1
a1208 1
	size = REGISTER_RAW_SIZE (fp_regnum);
d1296 1
a1296 1
		    REGISTER_RAW_SIZE (regnum));
d1309 1
a1309 1
		store_unsigned_integer (raw_buffer, REGISTER_RAW_SIZE (regnum),
d1325 1
a1325 1
		    size = REGISTER_RAW_SIZE (live_regnum);
d1331 1
a1331 1
				 + REGISTER_RAW_SIZE (live_regnum)
d1355 1
a1355 1
				    REGISTER_RAW_SIZE (STRUCT_RETURN_REGNUM)));
d1395 1
a1395 1
	      size = REGISTER_RAW_SIZE (translate_insn_rn (regnum,
d1529 1
a1529 1
	  argreg_size = REGISTER_RAW_SIZE (int_argreg);
d1705 1
a1705 1
	      REGISTER_RAW_SIZE (return_register) - len;
d1746 1
a1746 1
      if (len <= REGISTER_RAW_SIZE (return_register))
d1749 1
a1749 1
	  memset (buf, 0, REGISTER_RAW_SIZE (return_register));
d1751 1
a1751 1
	    offset = 0; /*REGISTER_RAW_SIZE (return_register) - len;*/
d1753 1
a1753 1
	    offset = REGISTER_RAW_SIZE (return_register) - len;
d2095 1
a2095 1
      memcpy (to, from, REGISTER_RAW_SIZE (regnum));
d2121 1
a2121 1
      memcpy (to, from, REGISTER_RAW_SIZE (regnum));
d2158 1
a2158 1
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d2177 1
a2177 1
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d2191 1
a2191 1
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d2228 1
a2228 1
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d2246 1
a2246 1
			    + REGISTER_RAW_SIZE (base_regnum) * portion));
d2325 1
a2325 1
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d2337 1
a2337 1
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d2349 1
a2349 1
			     + REGISTER_RAW_SIZE (base_regnum) * portion));
d2393 1
a2393 1
			       + REGISTER_RAW_SIZE (base_regnum) * portion));
d2406 1
a2406 1
			       + REGISTER_RAW_SIZE (base_regnum) * portion));
@


1.8
log
@2003-09-27  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.c (deprecated_init_frame_pc_default): Rename
	"init_frame_pc_default".
	* arch-utils.h (deprecated_init_frame_pc_default): Update.
	* xstormy16-tdep.c (xstormy16_gdbarch_init): Update.
	* vax-tdep.c (vax_gdbarch_init): Update.
	* v850-tdep.c (v850_gdbarch_init): Update.
	* sh64-tdep.c (sh64_gdbarch_init): Update.
	* s390-tdep.c (s390_gdbarch_init): Update.
	* ns32k-tdep.c (ns32k_gdbarch_init): Update.
	* mcore-tdep.c (mcore_gdbarch_init): Update.
	* h8300-tdep.c (h8300_gdbarch_init): Update.
	* cris-tdep.c (cris_gdbarch_init): Update.
	* config/pa/tm-hppa.h (DEPRECATED_INIT_FRAME_PC): Update.
@
text
@d2161 1
a2161 1
      sh_sh64_register_convert_to_virtual (reg_nr, REGISTER_VIRTUAL_TYPE (reg_nr),
d2231 1
a2231 1
      sh_sh64_register_convert_to_virtual (reg_nr, REGISTER_VIRTUAL_TYPE (reg_nr),
d2317 1
a2317 1
      sh_sh64_register_convert_to_raw (REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
d2388 1
a2388 1
	  sh_sh64_register_convert_to_raw (REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
@


1.7
log
@2003-09-25  Andrew Cagney  <cagney@@redhat.com>

	* frame.h (deprecated_frame_saved_regs): Rename
	get_frame_saved_regs.
	* cris-tdep.c, frame.c, h8300-tdep.c, hppa-tdep.c: Update.
	* mcore-tdep.c, mips-tdep.c, mn10300-tdep.c: Update.
	* ns32k-tdep.c, ppc-linux-tdep.c, rs6000-tdep.c: Update.
	* s390-tdep.c, sh64-tdep.c, stack.c: Update.
	* v850-tdep.c, vax-tdep.c, xstormy16-tdep.c: Update.
@
text
@d2851 1
a2851 1
  set_gdbarch_deprecated_init_frame_pc (gdbarch, init_frame_pc_default);
@


1.6
log
@2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_BYTE): Rename REGISTER_BYTE.
	* gdbarch.h, gdbarch.c: Regenerate.
	* arm-linux-tdep.c, core-sol2.c, cris-tdep.c: Update.
	* d10v-tdep.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, irix5-nat.c, lynx-nat.c, m68knbsd-nat.c: Update.
	* mcore-tdep.c, mips-linux-tdep.c, mips-tdep.c: Update.
	* mipsv4-nat.c, mn10300-tdep.c, ns32k-tdep.c: Update.
	* ns32knbsd-nat.c, ppc-bdm.c, regcache.c, remote-sds.c: Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Update.
	* remote.c, rs6000-tdep.c, s390-tdep.c, sh64-tdep.c: Update.
	* sparc-nat.c, sparc-tdep.c, sun3-nat.c, v850-tdep.c: Update.
	* v850ice.c, vax-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-cisco.h, config/m68k/tm-delta68.h: Update.
	* config/pa/nm-hppah.h: Update.

2003-09-17  Andrew Cagney  <cagney@@redhat.com>

	* mi/mi-main.c: Rename REGISTER_BYTE to DEPRECATED_REGISTER_BYTE.
@
text
@d785 1
a785 1
	if (get_frame_saved_regs (fi)[pr_regnum] != 0)
d791 1
a791 1
	    return read_memory_integer (get_frame_saved_regs (fi)[pr_regnum], size);
d1030 1
a1030 1
  if (get_frame_saved_regs (fi) == NULL)
d1033 1
a1033 1
    memset (get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
d1040 1
a1040 1
      memcpy (get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
d1188 1
a1188 1
	  get_frame_saved_regs (fi)[register_number]= get_frame_base (fi) - where[rn] + depth; 
d1192 1
a1192 1
	get_frame_saved_regs (fi)[register_number] = 0; 
d1209 1
a1209 1
      get_frame_saved_regs (fi)[sp_regnum] = read_memory_integer (get_frame_saved_regs (fi)[fp_regnum], size);
d1212 1
a1212 1
    get_frame_saved_regs (fi)[sp_regnum] = get_frame_base (fi);
d1301 2
a1302 2
      if (get_frame_saved_regs (frame) != NULL
	  && get_frame_saved_regs (frame)[regnum] != 0)
d1310 1
a1310 1
					get_frame_saved_regs (frame)[regnum]);
d1316 1
a1316 1
		*addrp = get_frame_saved_regs (frame)[regnum];
d1327 1
a1327 1
		    read_memory (get_frame_saved_regs (frame)[regnum], raw_buffer, size);
d1329 1
a1329 1
		    read_memory (get_frame_saved_regs (frame)[regnum],
d1387 1
a1387 1
	if (get_frame_saved_regs (frame)[regnum])
d1398 1
a1398 1
			    read_memory_integer (get_frame_saved_regs (frame)[regnum],
@


1.6.2.1
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@@


1.6.2.2
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1 1
a1 1
/* Target-dependent code for Renesas Super-H, for GDB.
d756 1
a756 1
	size = DEPRECATED_REGISTER_RAW_SIZE (translate_insn_rn (DEPRECATED_FP_REGNUM, media_mode));
d785 1
a785 1
	if (deprecated_get_frame_saved_regs (fi)[pr_regnum] != 0)
d790 2
a791 2
			: DEPRECATED_REGISTER_RAW_SIZE (gdb_reg_num));
	    return read_memory_integer (deprecated_get_frame_saved_regs (fi)[pr_regnum], size);
d1030 1
a1030 1
  if (deprecated_get_frame_saved_regs (fi) == NULL)
d1033 1
a1033 1
    memset (deprecated_get_frame_saved_regs (fi), 0, SIZEOF_FRAME_SAVED_REGS);
d1040 1
a1040 1
      memcpy (deprecated_get_frame_saved_regs (fi), dummy_regs, SIZEOF_FRAME_SAVED_REGS);
d1188 1
a1188 1
	  deprecated_get_frame_saved_regs (fi)[register_number]= get_frame_base (fi) - where[rn] + depth; 
d1192 1
a1192 1
	deprecated_get_frame_saved_regs (fi)[register_number] = 0; 
d1208 2
a1209 2
	size = DEPRECATED_REGISTER_RAW_SIZE (fp_regnum);
      deprecated_get_frame_saved_regs (fi)[sp_regnum] = read_memory_integer (deprecated_get_frame_saved_regs (fi)[fp_regnum], size);
d1212 1
a1212 1
    deprecated_get_frame_saved_regs (fi)[sp_regnum] = get_frame_base (fi);
d1296 1
a1296 1
		    DEPRECATED_REGISTER_RAW_SIZE (regnum));
d1301 2
a1302 2
      if (deprecated_get_frame_saved_regs (frame) != NULL
	  && deprecated_get_frame_saved_regs (frame)[regnum] != 0)
d1309 2
a1310 2
		store_unsigned_integer (raw_buffer, DEPRECATED_REGISTER_RAW_SIZE (regnum),
					deprecated_get_frame_saved_regs (frame)[regnum]);
d1316 1
a1316 1
		*addrp = deprecated_get_frame_saved_regs (frame)[regnum];
d1325 1
a1325 1
		    size = DEPRECATED_REGISTER_RAW_SIZE (live_regnum);
d1327 1
a1327 1
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum], raw_buffer, size);
d1329 1
a1329 1
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum],
d1331 1
a1331 1
				 + DEPRECATED_REGISTER_RAW_SIZE (live_regnum)
d1355 1
a1355 1
				    DEPRECATED_REGISTER_RAW_SIZE (STRUCT_RETURN_REGNUM)));
d1387 1
a1387 1
	if (deprecated_get_frame_saved_regs (frame)[regnum])
d1395 1
a1395 1
	      size = DEPRECATED_REGISTER_RAW_SIZE (translate_insn_rn (regnum,
d1398 1
a1398 1
			    read_memory_integer (deprecated_get_frame_saved_regs (frame)[regnum],
d1417 1
a1417 1
   On the Renesas SH architecture, there are four registers (R4 to R7)
d1529 1
a1529 1
	  argreg_size = DEPRECATED_REGISTER_RAW_SIZE (int_argreg);
d1705 1
a1705 1
	      DEPRECATED_REGISTER_RAW_SIZE (return_register) - len;
d1746 1
a1746 1
      if (len <= DEPRECATED_REGISTER_RAW_SIZE (return_register))
d1749 1
a1749 1
	  memset (buf, 0, DEPRECATED_REGISTER_RAW_SIZE (return_register));
d1751 1
a1751 1
	    offset = 0; /*DEPRECATED_REGISTER_RAW_SIZE (return_register) - len;*/
d1753 1
a1753 1
	    offset = DEPRECATED_REGISTER_RAW_SIZE (return_register) - len;
d2095 1
a2095 1
      memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d2121 1
a2121 1
      memcpy (to, from, DEPRECATED_REGISTER_RAW_SIZE (regnum));
d2158 1
a2158 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2161 1
a2161 1
      sh_sh64_register_convert_to_virtual (reg_nr, DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr),
d2177 1
a2177 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2191 1
a2191 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2228 1
a2228 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2231 1
a2231 1
      sh_sh64_register_convert_to_virtual (reg_nr, DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr),
d2246 1
a2246 1
			    + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2317 1
a2317 1
      sh_sh64_register_convert_to_raw (DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
d2325 1
a2325 1
			     + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2337 1
a2337 1
			     + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2349 1
a2349 1
			     + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2388 1
a2388 1
	  sh_sh64_register_convert_to_raw (DEPRECATED_REGISTER_VIRTUAL_TYPE (reg_nr), reg_nr,
d2393 1
a2393 1
			       + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2406 1
a2406 1
			       + DEPRECATED_REGISTER_RAW_SIZE (base_regnum) * portion));
d2851 1
a2851 1
  set_gdbarch_deprecated_init_frame_pc (gdbarch, deprecated_init_frame_pc_default);
@


1.6.2.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d52 1
a52 1
/* Information that is dependent on the processor variant.  */
d81 1
a81 1
       registers are called FR, and the floating point pairs are called FP.  */
d122 1
a122 1
sh64_register_name (int reg_nr)
d200 3
a202 1
   symbol's "info" field is used for this purpose.
d208 3
a210 1
   MSYMBOL_IS_SPECIAL   tests the "special" bit in a minimal symbol  */
d240 1
a240 1
     ISA32 (shmedia) address.  */
d255 1
a255 1
sh64_breakpoint_from_pc (CORE_ADDR *pcptr, int *lenptr)
d399 1
a399 1
   where Rm is one of r2-r9 which are the argument registers.  */
d406 1
a406 1
   where Rm is one of r2-r9 which are the argument registers.  */
d452 2
a453 2
/* Skip the prologue using the debug information.  If this fails we'll
   fall back on the 'guess' method below.  */
d497 1
a497 1
		 the SP has been saved, unfortunately.  */
d507 1
a507 1
	      /* These instructions store directly the argument in r14.  */
d522 1
a522 1
		 the SP has been saved, unfortunately.  */
d531 1
a531 1
	      /* These instructions store directly the argument in r14.  */
d552 1
a552 1
		 needs to be considered part of the prologue.  */
d616 1
a616 1
		   gdb can print the frames correctly.  */
d642 1
a642 1
		   gdb can print the frames correctly.  */
d663 1
a663 1
     fall back on the instruction skipping code.  */
d709 1
a709 1
   scheme.  */
d713 2
d716 1
a716 1
     register only.  */
d721 2
a722 2
      /* These registers don't have a corresponding compact one.  */
      /* FIXME: This is probably not enough.  */
d747 1
a747 1
    return get_frame_base (frame);    /* dummy frame same as caller's frame */
d756 1
a756 3
	size = register_size (current_gdbarch, 
			      translate_insn_rn (DEPRECATED_FP_REGNUM, 
						 media_mode));
d773 2
a774 3
      /* When the caller requests PR from the dummy frame, we return
         PC because that's where the previous routine appears to have
         done a call from.  */
d790 1
a790 1
			: register_size (current_gdbarch, gdb_reg_num));
d797 1
a797 1
/* For vectors of 4 floating point registers.  */
d833 4
a836 1
  return (rn >= DR0_REGNUM && rn <= FV_LAST_REGNUM);
d849 1
d932 1
d973 1
a973 1
    base_regnum = FPSCR_REGNUM; /*???? this register is a mess.  */
d984 1
a984 1
   the registers are pseudo.  */
d997 1
a997 1
    /* All compact registers are pseudo.  */
d1027 2
a1028 3
  char *dummy_regs = deprecated_generic_find_dummy_frame (get_frame_pc (fi), 
							  get_frame_base (fi));
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1054 1
a1054 1
     after 20 of them, since we're getting silly then.  */
d1076 1
a1076 1
    for the stack pointer register, which is register 15.  */
d1115 1
a1115 1
		 We already have the offset in r0_val.  */
d1176 1
a1176 1
  /* Now we know how deep things are, we can work out their addresses.  */
d1187 3
a1189 3
	     doesn't include space for the pseudo registers.  */
	  deprecated_get_frame_saved_regs (fi)[register_number] 
	    = get_frame_base (fi) - where[rn] + depth;
d1192 1
a1192 1
	deprecated_get_frame_saved_regs (fi)[register_number] = 0;
d1199 1
a1199 1
	 register r15 which still is the SP register.  */
d1201 1
a1201 1
         the caller.  */
d1208 2
a1209 4
	size = register_size (current_gdbarch, fp_regnum);
      deprecated_get_frame_saved_regs (fi)[sp_regnum] 
	= read_memory_integer (deprecated_get_frame_saved_regs (fi)[fp_regnum],
			       size);
d1214 1
a1214 1
  get_frame_extra_info (fi)->f_offset = depth - where[fp_regnum];
d1256 1
a1256 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1296 1
a1296 1
		    register_size (current_gdbarch, regnum));
d1309 1
a1309 3
		store_unsigned_integer (raw_buffer, 
					register_size (current_gdbarch, 
						       regnum),
d1325 1
a1325 1
		    size = register_size (current_gdbarch, live_regnum);
d1327 1
a1327 2
		    read_memory (deprecated_get_frame_saved_regs (frame)[regnum], 
				 raw_buffer, size);
d1331 1
a1331 1
				 + register_size (current_gdbarch, live_regnum)
d1355 1
a1355 2
				    register_size (current_gdbarch, 
						   STRUCT_RETURN_REGNUM)));
d1365 1
a1365 1
   Used in the 'return' command.  */
d1372 1
a1372 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d1395 2
a1396 2
	      size = register_size (current_gdbarch, 
				    translate_insn_rn (regnum, media_mode));
d1474 1
a1474 1
   for which the prototype is not known.  */
d1495 1
d1529 1
a1529 1
	  argreg_size = register_size (current_gdbarch, int_argreg);
d1565 1
a1565 1
		 before we use its size.  */
d1589 1
a1589 1
		  /* Skip the corresponding general argument register.  */
d1595 1
a1595 1
		   necessary spilling on the stack.  */
d1610 1
a1610 1
		       i.e. includes odd numbers.  */
d1630 1
a1630 1
		       with pseudoregs.  */
d1634 1
a1634 1
		    /* Skip the corresponding general argument register.  */
d1640 1
a1640 1
                     necessary spilling on the stack.  */
d1668 1
d1677 1
a1677 1
	  memcpy (valbuf, (char *) regbuf + offset, len);
d1693 1
a1693 1
	  store_typed_floating (valbuf, type, val);
d1701 1
a1701 1
	     at the most significant end.  */
d1705 1
a1705 1
	      register_size (current_gdbarch, return_register) - len;
d1720 1
a1720 1
   the result is stored in r0, left-justified.  */
d1725 1
a1725 1
  char buf[64];	/* more than enough...  */
d1746 1
a1746 1
      if (len <= register_size (current_gdbarch, return_register))
d1748 2
a1749 2
	  /* Pad with zeros.  */
	  memset (buf, 0, register_size (current_gdbarch, return_register));
d1751 1
a1751 2
	    offset = 0; /*register_size (current_gdbarch, 
			  return_register) - len;*/
d1753 1
a1753 1
	    offset = register_size (current_gdbarch, return_register) - len;
d1767 1
d1806 1
d1844 2
a1845 2
/* FIXME!!! This only shows the registers for shmedia, excluding the
   pseudo registers.  */
d1925 1
a1925 1
sh64_register_byte (int reg_nr)
d1928 1
d1931 1
a1931 1
     point register that is part of it.  */
d1945 1
a1945 1
     treat it as special.  */
d1951 2
a1952 2
  /* Now return the offset in bytes within the register cache.  */
  /* sh media pseudo register, i.e. any of DR, FFP, FV registers.  */
d1988 1
a1988 1
       architectural FPSCR register.  */
d1995 2
a1996 2
  /* It is not a pseudo register.  */
  /* It is a 64 bit register.  */
d2000 1
a2000 1
  /* It is a 32 bit register.  */
d2010 35
d2046 1
a2046 1
sh64_build_float_register_type (int high)
a2053 2
/* Return the GDB type object for the "standard" data type
   of data in register REG_NR.  */
d2055 1
a2055 1
sh64_register_type (struct gdbarch *gdbarch, int reg_nr)
d2057 2
d2071 1
a2071 1
    return sh64_build_float_register_type (1);
d2076 1
a2076 1
    return sh64_build_float_register_type (3);
d2087 1
a2087 1
sh64_register_convert_to_virtual (int regnum, struct type *type,
d2090 2
d2094 2
a2095 2
      /* It is a no-op.  */
      memcpy (to, from, register_size (current_gdbarch, regnum));
d2105 2
a2106 3
      floatformat_to_doublest (&floatformat_ieee_double_littlebyte_bigword, 
			       from, &val);
      store_typed_floating (to, type, val);
d2109 1
a2109 1
    error ("sh64_register_convert_to_virtual called with non DR register number");
d2113 1
a2113 1
sh64_register_convert_to_raw (struct type *type, int regnum,
d2116 2
d2120 2
a2121 2
      /* It is a no-op.  */
      memcpy (to, from, register_size (current_gdbarch, regnum));
d2131 1
a2131 2
      floatformat_from_doublest (&floatformat_ieee_double_littlebyte_bigword, 
				 &val, to);
d2134 1
a2134 1
    error ("sh64_register_convert_to_raw called with non DR register number");
d2145 1
d2152 1
a2152 1
      /* Build the value in the provided buffer.  */ 
d2154 1
a2154 1
	 concatenating 2 single precision floating point registers.  */
d2158 1
a2158 1
			    + register_size (gdbarch, base_regnum) * portion));
d2160 3
a2162 5
      /* We must pay attention to the endianness.  */
      sh64_register_convert_to_virtual (reg_nr, 
					gdbarch_register_type (gdbarch, 
							       reg_nr),
					temp_buffer, buffer);
d2171 1
a2171 1
      /* Build the value in the provided buffer.  */ 
d2173 1
a2173 1
	 concatenating 2 single precision floating point registers.  */
d2177 1
a2177 1
			    + register_size (gdbarch, base_regnum) * portion));
d2185 1
a2185 1
      /* Build the value in the provided buffer.  */ 
d2187 1
a2187 1
	 concatenating 4 single precision floating point registers.  */
d2191 1
a2191 1
			    + register_size (gdbarch, base_regnum) * portion));
d2200 1
a2200 1
      /* Build the value in the provided buffer.  */ 
d2212 1
a2212 1
      /* Build the value in the provided buffer.  */ 
d2214 1
a2214 1
	 they have the same size and endianness.  */
d2224 1
a2224 1
	 concatenating 2 single precision floating point registers.  */
d2228 1
a2228 1
			    + register_size (gdbarch, base_regnum) * portion));
d2230 3
a2232 5
      /* We must pay attention to the endianness.  */
      sh64_register_convert_to_virtual (reg_nr, 
					gdbarch_register_type (gdbarch, 
							       reg_nr),
					temp_buffer, buffer);
d2240 1
a2240 1
      /* Build the value in the provided buffer.  */ 
d2242 1
a2242 1
	 concatenating 4 single precision floating point registers.  */
d2246 1
a2246 1
			    + register_size (gdbarch, base_regnum) * portion));
d2262 1
a2262 1
      /* Build the value in the provided buffer.  */ 
d2278 1
a2278 1
      /* Get value as an int.  */
d2282 1
a2282 1
      /* Get value as an int.  */
d2284 1
a2284 1
      /* Build the new value.  */
d2290 1
a2290 1
      /* FIXME There is surely an endianness gotcha here.  */
d2298 1
a2298 1
	 same size, same endianness.  */
d2310 1
d2316 4
a2319 4
      /* We must pay attention to the endianness.  */
      sh64_register_convert_to_raw (gdbarch_register_type (gdbarch, reg_nr),
				    reg_nr,
				    buffer, temp_buffer);
d2325 1
a2325 2
			     + register_size (gdbarch, 
					      base_regnum) * portion));
d2337 1
a2337 2
			     + register_size (gdbarch, 
					      base_regnum) * portion));
d2349 1
a2349 2
			     + register_size (gdbarch, 
					      base_regnum) * portion));
d2358 1
a2358 1
      /* reg_nr is 32 bit here, and base_regnum is 64 bits.  */
d2365 1
a2365 1
	 value of the pseudo will leave the upper 4 bytes unchanged.  */
d2373 1
a2373 1
     registers. Both are 4 bytes.  */
d2387 3
a2389 5
	  /* We must pay attention to the endianness.  */
	  sh64_register_convert_to_raw (gdbarch_register_type (gdbarch,
							       reg_nr), 
					reg_nr,
					buffer, temp_buffer);
d2393 1
a2393 2
			       + register_size (gdbarch, 
						base_regnum) * portion));
d2406 1
a2406 2
			       + register_size (gdbarch, 
						base_regnum) * portion));
d2438 1
a2438 1
      /* Get value as an int.  */
d2441 1
a2441 1
      /* Build the new values.  */
d2470 1
a2470 1
/* Floating point vector of 4 float registers.  */
d2484 1
a2484 1
/* Floating point vector of 4 float registers, compact mode.  */
d2498 1
a2498 1
   registers.  */
d2510 1
a2510 1
/* Double precision registers.  */
d2523 1
a2523 1
/* Double precision registers, compact mode.  */
d2535 1
a2535 1
/* General register in compact mode.  */
d2547 2
a2548 2
   shmedia REGISTERS.  */
/* Control registers, compact mode.  */
d2581 1
a2581 1
  /* Allocate space for the float.  */
d2591 1
a2591 1
  /* Print the name and some spaces.  */
d2595 1
a2595 1
  /* Print the value.  */
d2601 1
a2601 1
  /* Print the fp register as hex.  */
d2616 2
a2617 1
  /* All the sh64-compact mode registers are pseudo registers.  */
d2646 2
a2647 2
    /* FIXME, this function will not print the right format.  */
    do_r_c_register_info (regnum);
d2650 2
a2651 2
    /* This should work also for pseudoregs.  */
    sh_do_fp_register (current_gdbarch, gdb_stdout, regnum);
d2655 1
d2753 1
d2783 1
a2783 1
   sh_compact_do_registers_info (regnum, fpregs);
d2845 1
a2845 1
     provided.  */
d2856 1
a2856 1
      /* If the ABI is the 64-bit one, it can only be sh-media.  */
d2864 1
a2864 1
	 compact.  */
d2902 2
a2903 2
  /* The number of real registers is the same whether we are in 
     ISA16(compact) or ISA32(media).  */
d2905 1
d2910 2
a2911 2
  set_gdbarch_register_name (gdbarch, sh64_register_name);
  set_gdbarch_register_type (gdbarch, sh64_register_type);
d2913 10
a2922 1
  set_gdbarch_deprecated_register_byte (gdbarch, sh64_register_byte);
d2928 1
a2928 1
  set_gdbarch_breakpoint_from_pc (gdbarch, sh64_breakpoint_from_pc);
@


1.6.2.4
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 2
a3 3

   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004 Free Software Foundation, Inc.
d834 6
d1350 1
a1350 1
sh64_extract_struct_value_address (struct regcache *regcache)
d1352 3
a1354 6
  /* FIXME: cagney/2004-01-17: Does the ABI guarantee that the return
     address regster is preserved across function calls?  Probably
     not, making this function wrong.  */
  ULONGEST val;
  regcache_raw_read_unsigned (regcache, STRUCT_RETURN_REGNUM, &val);
  return val;
d2851 2
d2894 1
a2894 1
  set_gdbarch_extract_struct_value_address (gdbarch, sh64_extract_struct_value_address);
@


1.5
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@d1295 1
a1295 1
		     + REGISTER_BYTE (regnum)),
d1346 1
a1346 1
    *addrp = REGISTER_BYTE (live_regnum);
d1354 1
a1354 1
  return (extract_unsigned_integer ((regbuf + REGISTER_BYTE (STRUCT_RETURN_REGNUM)), 
d1676 1
a1676 1
	  offset = REGISTER_BYTE (return_register);
d1685 1
a1685 1
	  offset = REGISTER_BYTE (return_register);
d1704 1
a1704 1
	    offset = REGISTER_BYTE (return_register) +
d1707 1
a1707 1
	    offset = REGISTER_BYTE (return_register);
@


1.4
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d2605 1
a2605 1
      register int idx = TARGET_BYTE_ORDER == BFD_ENDIAN_BIG ? j
@


1.3
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d1369 3
a1371 3
  register struct frame_info *frame = get_current_frame ();
  register CORE_ADDR fp;
  register int regnum;
@


1.2
log
@2003-09-09  Andrew Cagney  <cagney@@redhat.com>

	* sh64-tdep.c (sh64_push_return_address): Use ENTRY_POINT_ADDRESS
	instead of CALL_DUMMY_ADDRESS.
@
text
@d748 2
a749 1
  if (get_frame_pc (frame) && !inside_entry_file (get_frame_pc (frame)))
@


1.1
log
@	* Makefile.in (ALLDEPFILES): Add sh64-tdep.c.
	(sh64-tdep.o): Add dependencies.
	* configure.tgt: Add FIXME to sh-*-linux*.
	* sh-tdep.c: Move sh64 support to sh64-tdep.c.
	(sh_gdbarch_init): Always set correct sh_show_regs function
	pointer.  Call sh64_gdbarch_init() if machine type is sh5.
	* sh-tdep.h: Move sh64 support to sh64-tdep.c.
	* sh64-tdep.c: New file, containing all sh64 related code from
	sh-tdep.c.
	* config/sh/embed.mt (TDEPFILES): Add sh64-tdep.o.
	* config/sh/linux.mt (TDEPFILES): Ditto.
	* config/sh/nbsd.mt (TDEPFILES): Ditto.
	* config/sh/tm-sh.h: Drop REGISTER_TYPE definition.
	* config/sh/wince.mt (TDEPFILES): Ditto.
@
text
@d1653 1
a1653 1
  write_register (PR_REGNUM, CALL_DUMMY_ADDRESS ());
@

