head	1.146;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.138
	gdb_7_6-2013-04-26-release:1.138
	gdb_7_6-branch:1.138.0.2
	gdb_7_6-2013-03-12-branchpoint:1.138
	gdb_7_5_1-2012-11-29-release:1.128
	gdb_7_5-2012-08-17-release:1.128
	gdb_7_5-branch:1.128.0.2
	gdb_7_5-2012-07-18-branchpoint:1.128
	gdb_7_4_1-2012-04-26-release:1.122.2.1
	gdb_7_4-2012-01-24-release:1.122.2.1
	gdb_7_4-branch:1.122.0.2
	gdb_7_4-2011-12-13-branchpoint:1.122
	gdb_7_3_1-2011-09-04-release:1.121
	gdb_7_3-2011-07-26-release:1.121
	gdb_7_3-branch:1.121.0.2
	gdb_7_3-2011-04-01-branchpoint:1.121
	gdb_7_2-2010-09-02-release:1.115
	gdb_7_2-branch:1.115.0.2
	gdb_7_2-2010-07-07-branchpoint:1.115
	gdb_7_1-2010-03-18-release:1.107
	gdb_7_1-branch:1.107.0.2
	gdb_7_1-2010-02-18-branchpoint:1.107
	gdb_7_0_1-2009-12-22-release:1.106
	gdb_7_0-2009-10-06-release:1.106
	gdb_7_0-branch:1.106.0.4
	gdb_7_0-2009-09-16-branchpoint:1.106
	arc-sim-20090309:1.87
	msnyder-checkpoint-072509-branch:1.106.0.2
	msnyder-checkpoint-072509-branchpoint:1.106
	arc-insight_6_8-branch:1.87.0.8
	arc-insight_6_8-branchpoint:1.87
	insight_6_8-branch:1.87.0.6
	insight_6_8-branchpoint:1.87
	reverse-20081226-branch:1.92.0.4
	reverse-20081226-branchpoint:1.92
	multiprocess-20081120-branch:1.92.0.2
	multiprocess-20081120-branchpoint:1.92
	reverse-20080930-branch:1.90.0.2
	reverse-20080930-branchpoint:1.90
	reverse-20080717-branch:1.88.0.2
	reverse-20080717-branchpoint:1.88
	msnyder-reverse-20080609-branch:1.87.0.4
	msnyder-reverse-20080609-branchpoint:1.87
	drow-reverse-20070409-branch:1.72.0.2
	drow-reverse-20070409-branchpoint:1.72
	gdb_6_8-2008-03-27-release:1.87
	gdb_6_8-branch:1.87.0.2
	gdb_6_8-2008-02-26-branchpoint:1.87
	gdb_6_7_1-2007-10-29-release:1.82
	gdb_6_7-2007-10-10-release:1.82
	gdb_6_7-branch:1.82.0.2
	gdb_6_7-2007-09-07-branchpoint:1.82
	insight_6_6-20070208-release:1.69
	gdb_6_6-2006-12-18-release:1.69
	gdb_6_6-branch:1.69.0.10
	gdb_6_6-2006-11-15-branchpoint:1.69
	insight_6_5-20061003-release:1.69
	gdb-csl-symbian-6_4_50_20060226-12:1.68.8.1
	gdb-csl-sourcerygxx-3_4_4-25:1.66.8.1
	nickrob-async-20060828-mergepoint:1.69
	gdb-csl-symbian-6_4_50_20060226-11:1.68.8.1
	gdb-csl-sourcerygxx-4_1-17:1.68
	gdb-csl-20060226-branch-local-2:1.68
	gdb-csl-sourcerygxx-4_1-14:1.68
	gdb-csl-sourcerygxx-4_1-13:1.68
	gdb-csl-sourcerygxx-4_1-12:1.68
	gdb-csl-sourcerygxx-3_4_4-21:1.68
	gdb_6_5-20060621-release:1.69
	gdb-csl-sourcerygxx-4_1-9:1.68
	gdb-csl-sourcerygxx-4_1-8:1.68
	gdb-csl-sourcerygxx-4_1-7:1.68
	gdb-csl-arm-2006q1-6:1.68
	gdb-csl-sourcerygxx-4_1-6:1.68
	gdb-csl-symbian-6_4_50_20060226-10:1.68.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.68.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.68.8.1
	gdb-csl-coldfire-4_1-11:1.68
	gdb-csl-sourcerygxx-3_4_4-19:1.68
	gdb-csl-coldfire-4_1-10:1.68
	gdb_6_5-branch:1.69.0.8
	gdb_6_5-2006-05-14-branchpoint:1.69
	gdb-csl-sourcerygxx-4_1-5:1.68
	nickrob-async-20060513-branch:1.69.0.6
	nickrob-async-20060513-branchpoint:1.69
	gdb-csl-sourcerygxx-4_1-4:1.68
	msnyder-reverse-20060502-branch:1.69.0.4
	msnyder-reverse-20060502-branchpoint:1.69
	gdb-csl-morpho-4_1-4:1.68
	gdb-csl-sourcerygxx-3_4_4-17:1.68
	readline_5_1-import-branch:1.69.0.2
	readline_5_1-import-branchpoint:1.69
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.68
	gdb-csl-symbian-20060226-branch:1.68.0.8
	gdb-csl-symbian-20060226-branchpoint:1.68
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.68
	msnyder-reverse-20060331-branch:1.68.0.6
	msnyder-reverse-20060331-branchpoint:1.68
	gdb-csl-available-20060303-branch:1.68.0.4
	gdb-csl-available-20060303-branchpoint:1.68
	gdb-csl-20060226-branch:1.68.0.2
	gdb-csl-20060226-branchpoint:1.68
	gdb_6_4-20051202-release:1.66
	msnyder-fork-checkpoint-branch:1.66.0.10
	msnyder-fork-checkpoint-branchpoint:1.66
	gdb-csl-gxxpro-6_3-branch:1.66.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.66
	gdb_6_4-branch:1.66.0.6
	gdb_6_4-2005-11-01-branchpoint:1.66
	gdb-csl-arm-20051020-branch:1.66.0.4
	gdb-csl-arm-20051020-branchpoint:1.66
	msnyder-tracepoint-checkpoint-branch:1.66.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.66
	gdb-csl-arm-20050325-2005-q1b:1.65
	gdb-csl-arm-20050325-2005-q1a:1.65
	csl-arm-20050325-branch:1.65.0.2
	csl-arm-20050325-branchpoint:1.65
	gdb-post-i18n-errorwarning-20050211:1.60
	gdb-pre-i18n-errorwarning-20050211:1.60
	gdb_6_3-20041109-release:1.52
	gdb_6_3-branch:1.52.0.2
	gdb_6_3-20041019-branchpoint:1.52
	drow_intercu-merge-20040921:1.51
	drow_intercu-merge-20040915:1.51
	jimb-gdb_6_2-e500-branch:1.48.0.6
	jimb-gdb_6_2-e500-branchpoint:1.48
	gdb_6_2-20040730-release:1.48
	gdb_6_2-branch:1.48.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.48
	gdb_6_1_1-20040616-release:1.44
	gdb_6_1-2004-04-05-release:1.44
	drow_intercu-merge-20040402:1.44
	drow_intercu-merge-20040327:1.44
	ezannoni_pie-20040323-branch:1.44.0.12
	ezannoni_pie-20040323-branchpoint:1.44
	cagney_tramp-20040321-mergepoint:1.44
	cagney_tramp-20040309-branch:1.44.0.10
	cagney_tramp-20040309-branchpoint:1.44
	gdb_6_1-branch:1.44.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.44
	drow_intercu-20040221-branch:1.44.0.6
	drow_intercu-20040221-branchpoint:1.44
	cagney_bfdfile-20040213-branch:1.44.0.4
	cagney_bfdfile-20040213-branchpoint:1.44
	drow-cplus-merge-20040208:1.44
	carlton_dictionary-20040126-merge:1.44
	cagney_bigcore-20040122-branch:1.44.0.2
	cagney_bigcore-20040122-branchpoint:1.44
	drow-cplus-merge-20040113:1.43
	drow-cplus-merge-20031224:1.43
	drow-cplus-merge-20031220:1.43
	carlton_dictionary-20031215-merge:1.43
	drow-cplus-merge-20031214:1.43
	carlton-dictionary-20031111-merge:1.41
	gdb_6_0-2003-10-04-release:1.36
	kettenis_sparc-20030918-branch:1.39.0.4
	kettenis_sparc-20030918-branchpoint:1.39
	carlton_dictionary-20030917-merge:1.39
	ezannoni_pie-20030916-branchpoint:1.39
	ezannoni_pie-20030916-branch:1.39.0.2
	cagney_x86i386-20030821-branch:1.37.0.2
	cagney_x86i386-20030821-branchpoint:1.37
	carlton_dictionary-20030805-merge:1.37
	carlton_dictionary-20030627-merge:1.36
	gdb_6_0-branch:1.36.0.4
	gdb_6_0-2003-06-23-branchpoint:1.36
	jimb-ppc64-linux-20030613-branch:1.36.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.36
	cagney_convert-20030606-branch:1.35.0.6
	cagney_convert-20030606-branchpoint:1.35
	cagney_writestrings-20030508-branch:1.34.0.4
	cagney_writestrings-20030508-branchpoint:1.34
	jimb-ppc64-linux-20030528-branch:1.35.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.35
	carlton_dictionary-20030523-merge:1.35
	cagney_fileio-20030521-branch:1.35.0.2
	cagney_fileio-20030521-branchpoint:1.35
	kettenis_i386newframe-20030517-mergepoint:1.35
	jimb-ppc64-linux-20030509-branch:1.34.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.34
	kettenis_i386newframe-20030504-mergepoint:1.33
	carlton_dictionary-20030430-merge:1.33
	kettenis_i386newframe-20030419-branch:1.32.0.18
	kettenis_i386newframe-20030419-branchpoint:1.32
	carlton_dictionary-20030416-merge:1.32
	cagney_frameaddr-20030409-mergepoint:1.32
	kettenis_i386newframe-20030406-branch:1.32.0.16
	kettenis_i386newframe-20030406-branchpoint:1.32
	cagney_frameaddr-20030403-branchpoint:1.32
	cagney_frameaddr-20030403-branch:1.32.0.14
	cagney_framebase-20030330-mergepoint:1.32
	cagney_framebase-20030326-branch:1.32.0.12
	cagney_framebase-20030326-branchpoint:1.32
	cagney_lazyid-20030317-branch:1.32.0.10
	cagney_lazyid-20030317-branchpoint:1.32
	kettenis-i386newframe-20030316-mergepoint:1.32
	offbyone-20030313-branch:1.32.0.8
	offbyone-20030313-branchpoint:1.32
	kettenis-i386newframe-20030308-branch:1.32.0.6
	kettenis-i386newframe-20030308-branchpoint:1.32
	carlton_dictionary-20030305-merge:1.32
	cagney_offbyone-20030303-branch:1.32.0.4
	cagney_offbyone-20030303-branchpoint:1.32
	carlton_dictionary-20030207-merge:1.32
	interps-20030203-mergepoint:1.32
	interps-20030202-branch:1.32.0.2
	interps-20030202-branchpoint:1.32
	cagney-unwind-20030108-branch:1.30.0.2
	cagney-unwind-20030108-branchpoint:1.30
	carlton_dictionary-20021223-merge:1.30
	gdb_5_3-2002-12-12-release:1.27
	carlton_dictionary-20021115-merge:1.28
	kseitz_interps-20021105-merge:1.27
	kseitz_interps-20021103-merge:1.27
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.27
	carlton_dictionary-20021025-merge:1.27
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.27.0.16
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.27
	carlton_dictionary-branch:1.27.0.14
	carlton_dictionary-20020920-branchpoint:1.27
	gdb_5_3-branch:1.27.0.12
	gdb_5_3-2002-09-04-branchpoint:1.27
	kseitz_interps-20020829-merge:1.27
	cagney_sysregs-20020825-branch:1.27.0.10
	cagney_sysregs-20020825-branchpoint:1.27
	readline_4_3-import-branch:1.27.0.8
	readline_4_3-import-branchpoint:1.27
	gdb_5_2_1-2002-07-23-release:1.26
	kseitz_interps-20020528-branch:1.27.0.6
	kseitz_interps-20020528-branchpoint:1.27
	cagney_regbuf-20020515-branch:1.27.0.4
	cagney_regbuf-20020515-branchpoint:1.27
	jimb-macro-020506-branch:1.27.0.2
	jimb-macro-020506-branchpoint:1.27
	gdb_5_2-2002-04-29-release:1.26
	gdb_5_2-branch:1.26.0.2
	gdb_5_2-2002-03-03-branchpoint:1.26
	gdb_5_1_1-2002-01-24-release:1.23
	gdb_5_1_0_1-2002-01-03-release:1.23
	cygnus_cvs_20020108_pre:1.24
	gdb_5_1_0_1-2002-01-03-branchpoint:1.23
	gdb_5_1_0_1-2002-01-03-branch:1.23.0.6
	gdb_5_1-2001-11-21-release:1.23
	gdb_s390-2001-09-26-branch:1.23.0.4
	gdb_s390-2001-09-26-branchpoint:1.23
	gdb_5_1-2001-07-29-branch:1.23.0.2
	gdb_5_1-2001-07-29-branchpoint:1.23
	dberlin-typesystem-branch:1.21.0.2
	dberlin-typesystem-branchpoint:1.21
	gdb-post-ptid_t-2001-05-03:1.21
	gdb-pre-ptid_t-2001-05-03:1.20
	insight-precleanup-2001-01-01:1.11
	gdb-post-protoization-2000-07-29:1.7
	gdb-pre-protoization-2000-07-29:1.6
	gdb-premipsmulti-2000-06-06-branch:1.3.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.3
	gdb-post-params-removal-2000-06-04:1.3
	gdb-pre-params-removal-2000-06-04:1.3
	gdb-post-params-removal-2000-05-28:1.3
	gdb-pre-params-removal-2000-05-28:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.7
	insight-2000-02-04:1.1.1.7
	gdb-2000-02-04:1.1.1.7
	gdb-2000-02-02:1.1.1.7
	gdb-2000-02-01:1.1.1.7
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.6
	gdb-1999-11-16:1.1.1.6
	gdb-1999-11-08:1.1.1.6
	gdb-1999-11-01:1.1.1.6
	gdb-1999-10-25:1.1.1.6
	gdb-1999-10-18:1.1.1.6
	gdb-1999-10-11:1.1.1.6
	gdb-1999-10-04:1.1.1.6
	gdb-1999-09-28:1.1.1.6
	gdb-1999-09-21:1.1.1.6
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.4
	gdb-1999-07-19:1.1.1.4
	gdb-1999-07-12:1.1.1.4
	gdb-post-reformat-19990707:1.1.1.4
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.4
	gdb-pre-reformat-19990707:1.1.1.3
	gdb-1999-07-07:1.1.1.3
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.146
date	2013.09.17.18.26.39;	author palves;	state Exp;
branches;
next	1.145;

1.145
date	2013.07.31.15.36.49;	author aburgess;	state Exp;
branches;
next	1.144;

1.144
date	2013.07.31.12.44.33;	author aburgess;	state Exp;
branches;
next	1.143;

1.143
date	2013.07.25.14.34.50;	author tromey;	state Exp;
branches;
next	1.142;

1.142
date	2013.05.30.17.03.00;	author tromey;	state Exp;
branches;
next	1.141;

1.141
date	2013.04.19.15.28.42;	author palves;	state Exp;
branches;
next	1.140;

1.140
date	2013.04.19.15.09.46;	author palves;	state Exp;
branches;
next	1.139;

1.139
date	2013.03.20.15.46.24;	author jkratoch;	state Exp;
branches;
next	1.138;

1.138
date	2013.03.01.15.38.26;	author palves;	state Exp;
branches;
next	1.137;

1.137
date	2013.01.01.06.32.50;	author brobecke;	state Exp;
branches;
next	1.136;

1.136
date	2012.11.09.19.58.00;	author tromey;	state Exp;
branches;
next	1.135;

1.135
date	2012.08.22.17.48.52;	author tromey;	state Exp;
branches;
next	1.134;

1.134
date	2012.08.22.16.24.38;	author tromey;	state Exp;
branches;
next	1.133;

1.133
date	2012.07.23.14.57.55;	author tromey;	state Exp;
branches;
next	1.132;

1.132
date	2012.07.23.14.56.10;	author tromey;	state Exp;
branches;
next	1.131;

1.131
date	2012.07.18.19.42.26;	author tromey;	state Exp;
branches;
next	1.130;

1.130
date	2012.07.18.19.38.39;	author tromey;	state Exp;
branches;
next	1.129;

1.129
date	2012.07.18.19.33.34;	author tromey;	state Exp;
branches;
next	1.128;

1.128
date	2012.05.24.16.51.35;	author palves;	state Exp;
branches;
next	1.127;

1.127
date	2012.05.24.16.39.11;	author palves;	state Exp;
branches;
next	1.126;

1.126
date	2012.05.18.21.02.50;	author sergiodj;	state Exp;
branches;
next	1.125;

1.125
date	2012.03.02.00.06.12;	author jkratoch;	state Exp;
branches;
next	1.124;

1.124
date	2012.02.02.20.19.16;	author devans;	state Exp;
branches;
next	1.123;

1.123
date	2012.01.04.08.17.10;	author brobecke;	state Exp;
branches;
next	1.122;

1.122
date	2011.07.17.19.22.32;	author jkratoch;	state Exp;
branches
	1.122.2.1;
next	1.121;

1.121
date	2011.03.29.15.49.51;	author muller;	state Exp;
branches;
next	1.120;

1.120
date	2011.03.16.17.59.02;	author muller;	state Exp;
branches;
next	1.119;

1.119
date	2011.01.26.23.13.22;	author kevinb;	state Exp;
branches;
next	1.118;

1.118
date	2011.01.11.15.10.01;	author msnyder;	state Exp;
branches;
next	1.117;

1.117
date	2011.01.10.20.38.51;	author msnyder;	state Exp;
branches;
next	1.116;

1.116
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.115;

1.115
date	2010.07.07.16.15.16;	author bauermann;	state Exp;
branches;
next	1.114;

1.114
date	2010.05.16.21.11.14;	author msnyder;	state Exp;
branches;
next	1.113;

1.113
date	2010.05.02.23.52.14;	author jkratoch;	state Exp;
branches;
next	1.112;

1.112
date	2010.03.11.03.45.49;	author kevinb;	state Exp;
branches;
next	1.111;

1.111
date	2010.03.08.19.06.34;	author kevinb;	state Exp;
branches;
next	1.110;

1.110
date	2010.03.08.18.22.06;	author kevinb;	state Exp;
branches;
next	1.109;

1.109
date	2010.03.05.16.18.54;	author kevinb;	state Exp;
branches;
next	1.108;

1.108
date	2010.02.26.23.11.24;	author kevinb;	state Exp;
branches;
next	1.107;

1.107
date	2010.01.01.07.31.40;	author brobecke;	state Exp;
branches;
next	1.106;

1.106
date	2009.07.02.17.25.58;	author uweigand;	state Exp;
branches;
next	1.105;

1.105
date	2009.07.02.17.21.06;	author uweigand;	state Exp;
branches;
next	1.104;

1.104
date	2009.07.02.17.12.26;	author uweigand;	state Exp;
branches;
next	1.103;

1.103
date	2009.06.07.16.46.48;	author palves;	state Exp;
branches;
next	1.102;

1.102
date	2009.05.21.15.48.41;	author palves;	state Exp;
branches;
next	1.101;

1.101
date	2009.05.11.11.13.08;	author muller;	state Exp;
branches;
next	1.100;

1.100
date	2009.05.05.13.24.49;	author uweigand;	state Exp;
branches;
next	1.99;

1.99
date	2009.03.17.19.28.09;	author brobecke;	state Exp;
branches;
next	1.98;

1.98
date	2009.03.16.21.12.46;	author brobecke;	state Exp;
branches;
next	1.97;

1.97
date	2009.03.16.19.38.32;	author brobecke;	state Exp;
branches;
next	1.96;

1.96
date	2009.02.25.02.14.22;	author teawater;	state Exp;
branches;
next	1.95;

1.95
date	2009.02.23.00.03.50;	author palves;	state Exp;
branches;
next	1.94;

1.94
date	2009.02.06.22.21.26;	author palves;	state Exp;
branches;
next	1.93;

1.93
date	2009.01.03.05.57.53;	author brobecke;	state Exp;
branches;
next	1.92;

1.92
date	2008.11.09.11.27.18;	author vprus;	state Exp;
branches;
next	1.91;

1.91
date	2008.10.03.16.36.10;	author ppluzhnikov;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.04.22.49.30;	author devans;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.26.17.21.29;	author uweigand;	state Exp;
branches;
next	1.88;

1.88
date	2008.07.14.11.25.12;	author deuling;	state Exp;
branches;
next	1.87;

1.87
date	2008.02.06.09.37.56;	author macro;	state Exp;
branches;
next	1.86;

1.86
date	2008.01.01.22.53.12;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2007.12.12.17.14.52;	author macro;	state Exp;
branches;
next	1.84;

1.84
date	2007.12.07.15.02.11;	author macro;	state Exp;
branches;
next	1.83;

1.83
date	2007.10.10.17.04.38;	author uweigand;	state Exp;
branches;
next	1.82;

1.82
date	2007.08.23.18.08.36;	author brobecke;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.18.18.37.12;	author uweigand;	state Exp;
branches;
next	1.80;

1.80
date	2007.06.18.17.45.26;	author uweigand;	state Exp;
branches;
next	1.79;

1.79
date	2007.06.16.17.16.25;	author uweigand;	state Exp;
branches;
next	1.78;

1.78
date	2007.06.13.17.53.51;	author uweigand;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.09.13.49.20;	author uweigand;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.31.17.32.21;	author uweigand;	state Exp;
branches;
next	1.75;

1.75
date	2007.05.06.18.55.41;	author uweigand;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.06.14.34.38;	author uweigand;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.13.14.17.46;	author drow;	state Exp;
branches;
next	1.72;

1.72
date	2007.03.22.14.21.02;	author macro;	state Exp;
branches;
next	1.71;

1.71
date	2007.02.28.17.35.01;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2007.01.09.17.58.56;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.18.19.20.06;	author drow;	state Exp;
branches;
next	1.68;

1.68
date	2006.01.24.22.09.28;	author drow;	state Exp;
branches
	1.68.8.1;
next	1.67;

1.67
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.66;

1.66
date	2005.04.22.12.49.26;	author eliz;	state Exp;
branches
	1.66.4.1
	1.66.8.1;
next	1.65;

1.65
date	2005.02.21.06.21.08;	author cagney;	state Exp;
branches;
next	1.64;

1.64
date	2005.02.18.18.58.56;	author cagney;	state Exp;
branches;
next	1.63;

1.63
date	2005.02.18.15.25.27;	author cagney;	state Exp;
branches;
next	1.62;

1.62
date	2005.02.15.15.49.15;	author cagney;	state Exp;
branches;
next	1.61;

1.61
date	2005.02.11.18.13.52;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2005.01.19.21.15.44;	author cagney;	state Exp;
branches;
next	1.59;

1.59
date	2005.01.15.02.33.19;	author cagney;	state Exp;
branches;
next	1.58;

1.58
date	2005.01.14.01.03.41;	author msnyder;	state Exp;
branches;
next	1.57;

1.57
date	2005.01.12.18.31.32;	author cagney;	state Exp;
branches;
next	1.56;

1.56
date	2004.10.31.18.19.59;	author cagney;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.30.22.36.34;	author cagney;	state Exp;
branches;
next	1.54;

1.54
date	2004.10.30.20.54.54;	author cagney;	state Exp;
branches;
next	1.53;

1.53
date	2004.10.29.20.23.10;	author cagney;	state Exp;
branches;
next	1.52;

1.52
date	2004.10.08.20.29.54;	author cagney;	state Exp;
branches;
next	1.51;

1.51
date	2004.08.03.00.57.26;	author cagney;	state Exp;
branches;
next	1.50;

1.50
date	2004.07.26.14.53.04;	author cagney;	state Exp;
branches;
next	1.49;

1.49
date	2004.07.22.01.31.49;	author cagney;	state Exp;
branches;
next	1.48;

1.48
date	2004.06.15.01.04.19;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.25.14.58.30;	author cagney;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.28.16.36.25;	author cagney;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.21.23.52.20;	author cagney;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.21.15.37.11;	author cagney;	state Exp;
branches
	1.44.6.1;
next	1.43;

1.43
date	2003.11.16.22.46.49;	author cagney;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.16.19.24.05;	author cagney;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.09.14.34.04;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.02.20.28.30;	author cagney;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.14.16.32.13;	author cagney;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.29.16.18.06;	author cagney;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.05.02.44.50;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.11.13.16.28;	author cagney;	state Exp;
branches
	1.36.4.1;
next	1.35;

1.35
date	2003.05.15.22.58.38;	author cagney;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.08.22.33.14;	author cagney;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.29.01.49.47;	author cagney;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.02.05.46.14;	author cagney;	state Exp;
branches
	1.32.18.1;
next	1.31;

1.31
date	2003.01.18.15.55.52;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.29.19.40.30;	author cagney;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.29.19.15.15;	author cagney;	state Exp;
branches;
next	1.28;

1.28
date	2002.11.07.02.40.28;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.05.01.15.13;	author cagney;	state Exp;
branches
	1.27.14.1
	1.27.16.1;
next	1.26;

1.26
date	2002.02.10.04.08.42;	author cagney;	state Exp;
branches;
next	1.25;

1.25
date	2002.01.19.03.32.37;	author cagney;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.23.19.27.52;	author hunt;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.15.20.34.13;	author cagney;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.11.17.52.32;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.04.04.15.26;	author kevinb;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.03.01.51.26;	author jtc;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.06.08.21.12;	author kevinb;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.01.01.39.21;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.25.04.45.11;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.08.06.03.53;	author cagney;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.02.23.04.14;	author jtc;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.02.19.14.33;	author jtc;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.31.01.24.01;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.23.22.48.55;	author jtc;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.15.01.01.48;	author kevinb;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.12.17.20.09;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2000.09.01.00.12.10;	author jtc;	state Exp;
branches;
next	1.8;

1.8
date	2000.08.03.08.41.23;	author cagney;	state Exp;
branches;
next	1.7;

1.7
date	2000.07.30.01.48.26;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.11.09.25.22;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.17.14.00.31;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.06.06.19.57;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.28.01.12.29;	author kevinb;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.09.08.52.46;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.122.2.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	;

1.68.8.1
date	2006.04.11.21.58.24;	author drow;	state Exp;
branches;
next	;

1.66.4.1
date	2006.01.26.18.05.55;	author drow;	state Exp;
branches;
next	;

1.66.8.1
date	2006.01.26.18.10.22;	author drow;	state Exp;
branches;
next	;

1.44.6.1
date	2004.09.16.17.01.17;	author drow;	state Exp;
branches;
next	;

1.36.4.1
date	2003.10.09.14.34.53;	author drow;	state Exp;
branches;
next	;

1.32.18.1
date	2003.05.04.11.37.45;	author kettenis;	state Exp;
branches;
next	1.32.18.2;

1.32.18.2
date	2003.05.18.09.44.19;	author kettenis;	state Exp;
branches;
next	;

1.27.14.1
date	2002.11.15.19.18.53;	author carlton;	state Exp;
branches;
next	1.27.14.2;

1.27.14.2
date	2002.12.23.19.38.39;	author carlton;	state Exp;
branches;
next	1.27.14.3;

1.27.14.3
date	2003.02.07.19.17.52;	author carlton;	state Exp;
branches;
next	1.27.14.4;

1.27.14.4
date	2003.05.01.00.46.52;	author carlton;	state Exp;
branches;
next	1.27.14.5;

1.27.14.5
date	2003.05.23.18.40.43;	author carlton;	state Exp;
branches;
next	1.27.14.6;

1.27.14.6
date	2003.06.27.21.50.07;	author carlton;	state Exp;
branches;
next	1.27.14.7;

1.27.14.7
date	2003.08.05.17.13.13;	author carlton;	state Exp;
branches;
next	1.27.14.8;

1.27.14.8
date	2003.09.17.21.28.28;	author carlton;	state Exp;
branches;
next	1.27.14.9;

1.27.14.9
date	2003.11.11.23.50.52;	author carlton;	state Exp;
branches;
next	1.27.14.10;

1.27.14.10
date	2003.12.16.00.00.47;	author carlton;	state Exp;
branches;
next	1.27.14.11;

1.27.14.11
date	2004.01.26.19.11.29;	author carlton;	state Exp;
branches;
next	;

1.27.16.1
date	2003.12.14.20.27.28;	author drow;	state Exp;
branches;
next	1.27.16.2;

1.27.16.2
date	2004.02.09.19.43.46;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.03;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.25.03;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.17.22.44;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.07.07.20.09.06;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.33.47;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.26;	author shebs;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2000.02.02.00.21.09;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.146
log
@PR gdb/15911: "info threads" changes the default source and line (for "break", "list")

"info threads" changes the default source for "break" and "list", to
whatever the location of the first/bottom thread in the thread list
is...

 (gdb) b start
 (gdb) c
 ...
 (gdb) list
 *lists "start"*
 (gdb) b 23
 Breakpoint 3 at 0x400614: file test.c, line 23.
 (gdb) info threads
   Id   Target Id         Frame
 * 2    Thread 0x7ffff7fcb700 (LWP 1760) "test" start (arg=0x0) at test.c:23
   1    Thread 0x7ffff7fcc740 (LWP 1748) "test" 0x000000323dc08e60 in pthread_join (threadid=140737353922304, thread_return=0x0) at pthread_join.c:93
 (gdb) b 23
 Breakpoint 4 at 0x323dc08d90: file pthread_join.c, line 23.
                                    ^^^^^^^^^^^^^^^
 (gdb) list
 93          lll_wait_tid (pd->tid);
 94
 95
 96        /* Restore cancellation mode.  */
 97        CANCEL_RESET (oldtype);
 98
 99        /* Remove the handler.  */
 100       pthread_cleanup_pop (0);
 101
 102

The issue is that print_stack_frame always sets the current sal to the
frame's sal.  print_frame_info (which print_stack_frame calls to do
most of the work) also sets the last displayed sal, but only if
print_what isn't LOCATION.  Now the call in question, from within
thread.c:print_thread_info, does pass in LOCATION as print_what, but
print_stack_frame doesn't have the same check print_frame_info has.
We could consider adding it, but setting these globals depending on
print_what isn't very clean, IMO.  What we have is two logically
distinct operations mixed in the same function(s):

  #1 - print frame, in the format specified by {print_what,
    print_level and print_args}.

  #2 - We're displaying a frame to the user, and I want the default
    sal to point here, because the program stopped here, or the user
    did some context-changing command (up, down, etc.).

So I added a new parameter to print_stack_frame & friends for point
#2, and went through all calls in the tree adjusting as necessary.

Tested on x86_64 Fedora 17.

gdb/
2013-09-17  Pedro Alves  <palves@@redhat.com>

	PR gdb/15911
	* ada-tasks.c (task_command_1): Adjust call to print_stack_frame.
	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd):
	* corelow.c (core_open):
	* frame.h (print_stack_frame, print_frame_info): New
	'set_current_sal' parameter.
	* infcmd.c (finish_command, kill_command): Adjust call to
	print_stack_frame.
	* inferior.c (inferior_command): Likewise.
	* infrun.c (normal_stop): Likewise.
	* linux-fork.c (linux_fork_context): Likewise.
	* record-full.c (record_full_goto_entry, record_full_restore):
	Likewise.
	* remote-mips.c (common_open): Likewise.
	* stack.c (print_stack_frame): New 'set_current_sal' parameter.
	Use it.
	(print_frame_info): New 'set_current_sal' parameter.  Set the last
	displayed sal depending on the new paremeter instead of looking at
	print_what.
	(backtrace_command_1, select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Adjust call to
	print_stack_frame.
	* thread.c (print_thread_info, restore_selected_frame)
	(do_captured_thread_select): Adjust call to print_stack_frame.
	* tracepoint.c (tfind_1): Likewise.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames)
	(mi_cmd_stack_info_frame): Likewise.
	* mi/mi-interp.c (mi_on_normal_stop): Likewise.
	* mi/mi-main.c (mi_cmd_exec_return, mi_cmd_trace_find): Likewise.

	gdb/testsuite/
	* gdb.threads/info-threads-cur-sal-2.c: New file.
	* gdb.threads/info-threads-cur-sal.c: New file.
	* gdb.threads/info-threads-cur-sal.exp: New file.
@
text
@/* Remote debugging interface for MIPS remote debugging protocol.

   Copyright (C) 1993-2013 Free Software Foundation, Inc.

   Contributed by Cygnus Support.  Written by Ian Lance Taylor
   <ian@@cygnus.com>.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "inferior.h"
#include "bfd.h"
#include "symfile.h"
#include "gdbcmd.h"
#include "gdbcore.h"
#include "serial.h"
#include "target.h"
#include "exceptions.h"
#include "gdb_string.h"
#include "gdb_stat.h"
#include "gdb_usleep.h"
#include "regcache.h"
#include <ctype.h>
#include "mips-tdep.h"
#include "gdbthread.h"
#include "gdb_bfd.h"


/* Breakpoint types.  Values 0, 1, and 2 must agree with the watch
   types passed by breakpoint.c to target_insert_watchpoint.
   Value 3 is our own invention, and is used for ordinary instruction
   breakpoints.  Value 4 is used to mark an unused watchpoint in tables.  */
enum break_type
  {
    BREAK_WRITE,		/* 0 */
    BREAK_READ,			/* 1 */
    BREAK_ACCESS,		/* 2 */
    BREAK_FETCH,		/* 3 */
    BREAK_UNUSED		/* 4 */
  };

/* Prototypes for local functions.  */

static int mips_readchar (int timeout);

static int mips_receive_header (unsigned char *hdr, int *pgarbage,
				int ch, int timeout);

static int mips_receive_trailer (unsigned char *trlr, int *pgarbage,
				 int *pch, int timeout);

static int mips_cksum (const unsigned char *hdr,
		       const char *data, int len);

static void mips_send_packet (const char *s, int get_ack);

static void mips_send_command (const char *cmd, int prompt);

static int mips_receive_packet (char *buff, int throw_error, int timeout);

static ULONGEST mips_request (int cmd, ULONGEST addr, ULONGEST data,
			      int *perr, int timeout, char *buff);

static void mips_initialize (void);

static void mips_open (char *name, int from_tty);

static void pmon_open (char *name, int from_tty);

static void ddb_open (char *name, int from_tty);

static void lsi_open (char *name, int from_tty);

static void mips_close (void);

static void mips_detach (struct target_ops *ops, char *args, int from_tty);

static int mips_map_regno (struct gdbarch *, int);

static void mips_set_register (int regno, ULONGEST value);

static void mips_prepare_to_store (struct regcache *regcache);

static int mips_fetch_word (CORE_ADDR addr, unsigned int *valp);

static int mips_store_word (CORE_ADDR addr, unsigned int value,
			    int *old_contents);

static int mips_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len,
			     int write, 
			     struct mem_attrib *attrib,
			     struct target_ops *target);

static void mips_files_info (struct target_ops *ignore);

static void mips_mourn_inferior (struct target_ops *ops);

static int pmon_makeb64 (unsigned long v, char *p, int n, unsigned int *chksum);

static int pmon_zeroset (int recsize, char **buff, unsigned int *amount,
			 unsigned int *chksum);

static int pmon_checkset (int recsize, char **buff, unsigned int *value);

static void pmon_make_fastrec (char **outbuf, unsigned char *inbuf,
			       int *inptr, int inamount, int *recsize,
			       unsigned int *csum, unsigned int *zerofill);

static int pmon_check_ack (char *mesg);

static void pmon_start_download (void);

static void pmon_end_download (int final, int bintotal);

static void pmon_download (char *buffer, int length);

static void pmon_load_fast (char *file);

static void mips_load (char *file, int from_tty);

static int mips_make_srec (char *buffer, int type, CORE_ADDR memaddr,
			   unsigned char *myaddr, int len);

static int mips_set_breakpoint (CORE_ADDR addr, int len, enum break_type type);

static int mips_clear_breakpoint (CORE_ADDR addr, int len,
				  enum break_type type);

static int mips_common_breakpoint (int set, CORE_ADDR addr, int len,
				   enum break_type type);

/* Forward declarations.  */
extern struct target_ops mips_ops;
extern struct target_ops pmon_ops;
extern struct target_ops ddb_ops;
extern struct target_ops rockhopper_ops;
/* *INDENT-OFF* */
/* The MIPS remote debugging interface is built on top of a simple
   packet protocol.  Each packet is organized as follows:

   SYN  The first character is always a SYN (ASCII 026, or ^V).  SYN
   may not appear anywhere else in the packet.  Any time a SYN is
   seen, a new packet should be assumed to have begun.

   TYPE_LEN
   This byte contains the upper five bits of the logical length
   of the data section, plus a single bit indicating whether this
   is a data packet or an acknowledgement.  The documentation
   indicates that this bit is 1 for a data packet, but the actual
   board uses 1 for an acknowledgement.  The value of the byte is
   0x40 + (ack ? 0x20 : 0) + (len >> 6)
   (we always have 0 <= len < 1024).  Acknowledgement packets do
   not carry data, and must have a data length of 0.

   LEN1 This byte contains the lower six bits of the logical length of
   the data section.  The value is
   0x40 + (len & 0x3f)

   SEQ  This byte contains the six bit sequence number of the packet.
   The value is
   0x40 + seq
   An acknowlegment packet contains the sequence number of the
   packet being acknowledged plus 1 modulo 64.  Data packets are
   transmitted in sequence.  There may only be one outstanding
   unacknowledged data packet at a time.  The sequence numbers
   are independent in each direction.  If an acknowledgement for
   the previous packet is received (i.e., an acknowledgement with
   the sequence number of the packet just sent) the packet just
   sent should be retransmitted.  If no acknowledgement is
   received within a timeout period, the packet should be
   retransmitted.  This has an unfortunate failure condition on a
   high-latency line, as a delayed acknowledgement may lead to an
   endless series of duplicate packets.

   DATA The actual data bytes follow.  The following characters are
   escaped inline with DLE (ASCII 020, or ^P):
   SYN (026)    DLE S
   DLE (020)    DLE D
   ^C  (003)    DLE C
   ^S  (023)    DLE s
   ^Q  (021)    DLE q
   The additional DLE characters are not counted in the logical
   length stored in the TYPE_LEN and LEN1 bytes.

   CSUM1
   CSUM2
   CSUM3
   These bytes contain an 18 bit checksum of the complete
   contents of the packet excluding the SEQ byte and the
   CSUM[123] bytes.  The checksum is simply the twos complement
   addition of all the bytes treated as unsigned characters.  The
   values of the checksum bytes are:
   CSUM1: 0x40 + ((cksum >> 12) & 0x3f)
   CSUM2: 0x40 + ((cksum >> 6) & 0x3f)
   CSUM3: 0x40 + (cksum & 0x3f)

   It happens that the MIPS remote debugging protocol always
   communicates with ASCII strings.  Because of this, this
   implementation doesn't bother to handle the DLE quoting mechanism,
   since it will never be required.  */
/* *INDENT-ON* */


/* The SYN character which starts each packet.  */
#define SYN '\026'

/* The 0x40 used to offset each packet (this value ensures that all of
   the header and trailer bytes, other than SYN, are printable ASCII
   characters).  */
#define HDR_OFFSET 0x40

/* The indices of the bytes in the packet header.  */
#define HDR_INDX_SYN 0
#define HDR_INDX_TYPE_LEN 1
#define HDR_INDX_LEN1 2
#define HDR_INDX_SEQ 3
#define HDR_LENGTH 4

/* The data/ack bit in the TYPE_LEN header byte.  */
#define TYPE_LEN_DA_BIT 0x20
#define TYPE_LEN_DATA 0
#define TYPE_LEN_ACK TYPE_LEN_DA_BIT

/* How to compute the header bytes.  */
#define HDR_SET_SYN(data, len, seq) (SYN)
#define HDR_SET_TYPE_LEN(data, len, seq) \
  (HDR_OFFSET \
   + ((data) ? TYPE_LEN_DATA : TYPE_LEN_ACK) \
   + (((len) >> 6) & 0x1f))
#define HDR_SET_LEN1(data, len, seq) (HDR_OFFSET + ((len) & 0x3f))
#define HDR_SET_SEQ(data, len, seq) (HDR_OFFSET + (seq))

/* Check that a header byte is reasonable.  */
#define HDR_CHECK(ch) (((ch) & HDR_OFFSET) == HDR_OFFSET)

/* Get data from the header.  These macros evaluate their argument
   multiple times.  */
#define HDR_IS_DATA(hdr) \
  (((hdr)[HDR_INDX_TYPE_LEN] & TYPE_LEN_DA_BIT) == TYPE_LEN_DATA)
#define HDR_GET_LEN(hdr) \
  ((((hdr)[HDR_INDX_TYPE_LEN] & 0x1f) << 6) + (((hdr)[HDR_INDX_LEN1] & 0x3f)))
#define HDR_GET_SEQ(hdr) ((unsigned int)(hdr)[HDR_INDX_SEQ] & 0x3f)

/* The maximum data length.  */
#define DATA_MAXLEN 1023

/* The trailer offset.  */
#define TRLR_OFFSET HDR_OFFSET

/* The indices of the bytes in the packet trailer.  */
#define TRLR_INDX_CSUM1 0
#define TRLR_INDX_CSUM2 1
#define TRLR_INDX_CSUM3 2
#define TRLR_LENGTH 3

/* How to compute the trailer bytes.  */
#define TRLR_SET_CSUM1(cksum) (TRLR_OFFSET + (((cksum) >> 12) & 0x3f))
#define TRLR_SET_CSUM2(cksum) (TRLR_OFFSET + (((cksum) >>  6) & 0x3f))
#define TRLR_SET_CSUM3(cksum) (TRLR_OFFSET + (((cksum)      ) & 0x3f))

/* Check that a trailer byte is reasonable.  */
#define TRLR_CHECK(ch) (((ch) & TRLR_OFFSET) == TRLR_OFFSET)

/* Get data from the trailer.  This evaluates its argument multiple
   times.  */
#define TRLR_GET_CKSUM(trlr) \
  ((((trlr)[TRLR_INDX_CSUM1] & 0x3f) << 12) \
   + (((trlr)[TRLR_INDX_CSUM2] & 0x3f) <<  6) \
   + ((trlr)[TRLR_INDX_CSUM3] & 0x3f))

/* The sequence number modulos.  */
#define SEQ_MODULOS (64)

/* PMON commands to load from the serial port or UDP socket.  */
#define LOAD_CMD	"load -b -s tty0\r"
#define LOAD_CMD_UDP	"load -b -s udp\r"

/* The target vectors for the four different remote MIPS targets.
   These are initialized with code in _initialize_remote_mips instead
   of static initializers, to make it easier to extend the target_ops
   vector later.  */
struct target_ops mips_ops, pmon_ops, ddb_ops, rockhopper_ops, lsi_ops;

enum mips_monitor_type
  {
    /* IDT/SIM monitor being used: */
    MON_IDT,
    /* PMON monitor being used: */
    MON_PMON,			/* 3.0.83 [COGENT,EB,FP,NET]
				   Algorithmics Ltd. Nov  9 1995 17:19:50 */
    MON_DDB,			/* 2.7.473 [DDBVR4300,EL,FP,NET]
				   Risq Modular Systems,
				   Thu Jun 6 09:28:40 PDT 1996 */
    MON_LSI,			/* 4.3.12 [EB,FP],
				   LSI LOGIC Corp. Tue Feb 25 13:22:14 1997 */
    MON_ROCKHOPPER,
    /* Last and unused value, for sizing vectors, etc.  */
    MON_LAST
  };
static enum mips_monitor_type mips_monitor = MON_LAST;

/* The monitor prompt text.  If the user sets the PMON prompt
   to some new value, the GDB `set monitor-prompt' command must also
   be used to inform GDB about the expected prompt.  Otherwise, GDB
   will not be able to connect to PMON in mips_initialize().
   If the `set monitor-prompt' command is not used, the expected
   default prompt will be set according the target:
   target               prompt
   -----                -----
   pmon         PMON> 
   ddb          NEC010>
   lsi          PMON>
 */
static char *mips_monitor_prompt;

/* Set to 1 if the target is open.  */
static int mips_is_open;

/* Currently active target description (if mips_is_open == 1).  */
static struct target_ops *current_ops;

/* Set to 1 while the connection is being initialized.  */
static int mips_initializing;

/* Set to 1 while the connection is being brought down.  */
static int mips_exiting;

/* The next sequence number to send.  */
static unsigned int mips_send_seq;

/* The next sequence number we expect to receive.  */
static unsigned int mips_receive_seq;

/* The time to wait before retransmitting a packet, in seconds.  */
static int mips_retransmit_wait = 3;

/* The number of times to try retransmitting a packet before giving up.  */
static int mips_send_retries = 10;

/* The number of garbage characters to accept when looking for an
   SYN for the next packet.  */
static int mips_syn_garbage = 10;

/* The time to wait for a packet, in seconds.  */
static int mips_receive_wait = 5;

/* Set if we have sent a packet to the board but have not yet received
   a reply.  */
static int mips_need_reply = 0;

/* Handle used to access serial I/O stream.  */
static struct serial *mips_desc;

/* UDP handle used to download files to target.  */
static struct serial *udp_desc;
static int udp_in_use;

/* TFTP filename used to download files to DDB board, in the form
   host:filename.  */
static char *tftp_name;		/* host:filename */
static char *tftp_localname;	/* filename portion of above */
static int tftp_in_use;
static FILE *tftp_file;

/* Counts the number of times the user tried to interrupt the target (usually
   via ^C.  */
static int interrupt_count;

/* If non-zero, means that the target is running.  */
static int mips_wait_flag = 0;

/* If non-zero, monitor supports breakpoint commands.  */
static int monitor_supports_breakpoints = 0;

/* Data cache header.  */

#if 0				/* not used (yet?)  */
static DCACHE *mips_dcache;
#endif

/* Non-zero means that we've just hit a read or write watchpoint.  */
static int hit_watchpoint;

/* Table of breakpoints/watchpoints (used only on LSI PMON target).
   The table is indexed by a breakpoint number, which is an integer
   from 0 to 255 returned by the LSI PMON when a breakpoint is set.  */

#define MAX_LSI_BREAKPOINTS 256
struct lsi_breakpoint_info
  {
    enum break_type type;	/* type of breakpoint */
    CORE_ADDR addr;		/* address of breakpoint */
    int len;			/* length of region being watched */
    unsigned long value;	/* value to watch */
  }
lsi_breakpoints[MAX_LSI_BREAKPOINTS];

/* Error/warning codes returned by LSI PMON for breakpoint commands.
   Warning values may be ORed together; error values may not.  */
#define W_WARN	0x100		/* This bit is set if the error code
				   is a warning */
#define W_MSK   0x101		/* warning: Range feature is supported
				   via mask */
#define W_VAL   0x102		/* warning: Value check is not
				   supported in hardware */
#define W_QAL   0x104		/* warning: Requested qualifiers are
				   not supported in hardware */

#define E_ERR	0x200		/* This bit is set if the error code
				   is an error */
#define E_BPT   0x200		/* error: No such breakpoint number */
#define E_RGE   0x201		/* error: Range is not supported */
#define E_QAL   0x202		/* error: The requested qualifiers can
				   not be used */
#define E_OUT   0x203		/* error: Out of hardware resources */
#define E_NON   0x204		/* error: Hardware breakpoint not supported */

struct lsi_error
  {
    int code;			/* error code */
    char *string;		/* string associated with this code */
  };

struct lsi_error lsi_warning_table[] =
{
  {W_MSK, "Range feature is supported via mask"},
  {W_VAL, "Value check is not supported in hardware"},
  {W_QAL, "Requested qualifiers are not supported in hardware"},
  {0, NULL}
};

struct lsi_error lsi_error_table[] =
{
  {E_BPT, "No such breakpoint number"},
  {E_RGE, "Range is not supported"},
  {E_QAL, "The requested qualifiers can not be used"},
  {E_OUT, "Out of hardware resources"},
  {E_NON, "Hardware breakpoint not supported"},
  {0, NULL}
};

/* Set to 1 with the 'set monitor-warnings' command to enable printing
   of warnings returned by PMON when hardware breakpoints are used.  */
static int monitor_warnings;

/* This is the ptid we use while we're connected to the remote.  Its
   value is arbitrary, as the remote-mips target doesn't have a notion of
   processes or threads, but we need something non-null to place in
   inferior_ptid.  */
static ptid_t remote_mips_ptid;

/* Close any ports which might be open.  Reset certain globals indicating
   the state of those ports.  */

static void
close_ports (void)
{
  mips_is_open = 0;
  serial_close (mips_desc);

  if (udp_in_use)
    {
      serial_close (udp_desc);
      udp_in_use = 0;
    }
  tftp_in_use = 0;
}

/* Handle low-level error that we can't recover from.  Note that just
   error()ing out from target_wait or some such low-level place will cause
   all hell to break loose--the rest of GDB will tend to get left in an
   inconsistent state.  */

static void ATTRIBUTE_NORETURN
mips_error (char *string,...)
{
  va_list args;
  char *fmt;

  target_terminal_ours ();
  wrap_here ("");		/* Force out any buffered output.  */
  gdb_flush (gdb_stdout);
  gdb_flush (gdb_stderr);

  /* Clean up in such a way that mips_close won't try to talk to the
     board (it almost surely won't work since we weren't able to talk to
     it).  */
  close_ports ();

  if (!ptid_equal (inferior_ptid, null_ptid))
    target_mourn_inferior ();

  fmt = concat (_("Ending remote MIPS debugging: "),
		string, (char *) NULL);
  make_cleanup (xfree, fmt);

  va_start (args, string);
  throw_verror (TARGET_CLOSE_ERROR, fmt, args);
  va_end (args);
}

/* putc_readable - print a character, displaying non-printable chars in
   ^x notation or in hex.  */

static void
fputc_readable (int ch, struct ui_file *file)
{
  if (ch == '\n')
    fputc_unfiltered ('\n', file);
  else if (ch == '\r')
    fprintf_unfiltered (file, "\\r");
  else if (ch < 0x20)		/* ASCII control character */
    fprintf_unfiltered (file, "^%c", ch + '@@');
  else if (ch >= 0x7f)		/* non-ASCII characters (rubout or greater) */
    fprintf_unfiltered (file, "[%02x]", ch & 0xff);
  else
    fputc_unfiltered (ch, file);
}


/* puts_readable - print a string, displaying non-printable chars in
   ^x notation or in hex.  */

static void
fputs_readable (const char *string, struct ui_file *file)
{
  int c;

  while ((c = *string++) != '\0')
    fputc_readable (c, file);
}


/* Read P as a hex value.  Return true if every character made sense,
   storing the result in *RESULT.  Leave *RESULT unchanged otherwise.  */

static int
read_hex_value (const char *p, ULONGEST *result)
{
  ULONGEST retval;

  retval = 0;
  while (*p != 0)
    {
      retval <<= 4;
      if (*p >= '0' && *p <= '9')
	retval |= *p - '0';
      else if (*p >= 'A' && *p <= 'F')
	retval |= *p - 'A' + 10;
      else if (*p >= 'a' && *p <= 'f')
	retval |= *p - 'a' + 10;
      else
	return 0;
      p++;
    }
  *result = retval;
  return 1;
}


/* Wait until STRING shows up in mips_desc.  Returns 1 if successful, else 0 if
   timed out.  TIMEOUT specifies timeout value in seconds.  */

static int
mips_expect_timeout (const char *string, int timeout)
{
  const char *p = string;

  if (remote_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Expected \"");
      fputs_readable (string, gdb_stdlog);
      fprintf_unfiltered (gdb_stdlog, "\", got \"");
    }

  immediate_quit++;
  QUIT;
  while (1)
    {
      int c;

      /* Must use serial_readchar() here cuz mips_readchar would get
	 confused if we were waiting for the mips_monitor_prompt...  */

      c = serial_readchar (mips_desc, timeout);

      if (c == SERIAL_TIMEOUT)
	{
	  if (remote_debug)
	    fprintf_unfiltered (gdb_stdlog, "\": FAIL\n");
	  return 0;
	}

      if (remote_debug)
	fputc_readable (c, gdb_stdlog);

      if (c == *p++)
	{
	  if (*p == '\0')
	    {
	      immediate_quit--;
	      if (remote_debug)
		fprintf_unfiltered (gdb_stdlog, "\": OK\n");
	      return 1;
	    }
	}
      else
	{
	  p = string;
	  if (c == *p)
	    p++;
	}
    }
}

/* Wait until STRING shows up in mips_desc.  Returns 1 if successful, else 0 if
   timed out.  The timeout value is hard-coded to 2 seconds.  Use
   mips_expect_timeout if a different timeout value is needed.  */

static int
mips_expect (const char *string)
{
  return mips_expect_timeout (string, remote_timeout);
}

/* Read a character from the remote, aborting on error.  Returns
   SERIAL_TIMEOUT on timeout (since that's what serial_readchar()
   returns).  FIXME: If we see the string mips_monitor_prompt from the
   board, then we are debugging on the main console port, and we have
   somehow dropped out of remote debugging mode.  In this case, we
   automatically go back in to remote debugging mode.  This is a hack,
   put in because I can't find any way for a program running on the
   remote board to terminate without also ending remote debugging
   mode.  I assume users won't have any trouble with this; for one
   thing, the IDT documentation generally assumes that the remote
   debugging port is not the console port.  This is, however, very
   convenient for DejaGnu when you only have one connected serial
   port.  */

static int
mips_readchar (int timeout)
{
  int ch;
  static int state = 0;
  int mips_monitor_prompt_len = strlen (mips_monitor_prompt);

  { /* FIXME this whole block is dead code!  */
    int i;

    i = timeout;
    if (i == -1 && watchdog > 0)
      i = watchdog;
  }

  if (state == mips_monitor_prompt_len)
    timeout = 1;
  ch = serial_readchar (mips_desc, timeout);

  if (ch == SERIAL_TIMEOUT && timeout == -1)	/* Watchdog went off.  */
    {
      target_mourn_inferior ();
      error (_("Watchdog has expired.  Target detached."));
    }

  if (ch == SERIAL_EOF)
    mips_error (_("End of file from remote"));
  if (ch == SERIAL_ERROR)
    mips_error (_("Error reading from remote: %s"), safe_strerror (errno));
  if (remote_debug > 1)
    {
      /* Don't use _filtered; we can't deal with a QUIT out of
         target_wait, and I think this might be called from there.  */
      if (ch != SERIAL_TIMEOUT)
	fprintf_unfiltered (gdb_stdlog, "Read '%c' %d 0x%x\n", ch, ch, ch);
      else
	fprintf_unfiltered (gdb_stdlog, "Timed out in read\n");
    }

  /* If we have seen mips_monitor_prompt and we either time out, or
     we see a @@ (which was echoed from a packet we sent), reset the
     board as described above.  The first character in a packet after
     the SYN (which is not echoed) is always an @@ unless the packet is
     more than 64 characters long, which ours never are.  */
  if ((ch == SERIAL_TIMEOUT || ch == '@@')
      && state == mips_monitor_prompt_len
      && !mips_initializing
      && !mips_exiting)
    {
      if (remote_debug > 0)
	/* Don't use _filtered; we can't deal with a QUIT out of
	   target_wait, and I think this might be called from there.  */
	fprintf_unfiltered (gdb_stdlog,
			    "Reinitializing MIPS debugging mode\n");

      mips_need_reply = 0;
      mips_initialize ();

      state = 0;

      /* At this point, about the only thing we can do is abort the command
         in progress and get back to command level as quickly as possible.  */

      error (_("Remote board reset, debug protocol re-initialized."));
    }

  if (ch == mips_monitor_prompt[state])
    ++state;
  else
    state = 0;

  return ch;
}

/* Get a packet header, putting the data in the supplied buffer.
   PGARBAGE is a pointer to the number of garbage characters received
   so far.  CH is the last character received.  Returns 0 for success,
   or -1 for timeout.  */

static int
mips_receive_header (unsigned char *hdr, int *pgarbage, int ch, int timeout)
{
  int i;

  while (1)
    {
      /* Wait for a SYN.  mips_syn_garbage is intended to prevent
         sitting here indefinitely if the board sends us one garbage
         character per second.  ch may already have a value from the
         last time through the loop.  */
      while (ch != SYN)
	{
	  ch = mips_readchar (timeout);
	  if (ch == SERIAL_TIMEOUT)
	    return -1;
	  if (ch != SYN)
	    {
	      /* Printing the character here lets the user of gdb see
	         what the program is outputting, if the debugging is
	         being done on the console port.  Don't use _filtered:
	         we can't deal with a QUIT out of target_wait and
	         buffered target output confuses the user.  */
 	      if (!mips_initializing || remote_debug > 0)
  		{
		  if (isprint (ch) || isspace (ch))
		    {
		      fputc_unfiltered (ch, gdb_stdtarg);
		    }
		  else
		    {
		      fputc_readable (ch, gdb_stdtarg);
		    }
		  gdb_flush (gdb_stdtarg);
  		}
	      
	      /* Only count unprintable characters.  */
	      if (! (isprint (ch) || isspace (ch)))
		(*pgarbage) += 1;

	      if (mips_syn_garbage > 0
		  && *pgarbage > mips_syn_garbage)
		mips_error (_("Debug protocol failure:  more "
			    "than %d characters before a sync."),
			    mips_syn_garbage);
	    }
	}

      /* Get the packet header following the SYN.  */
      for (i = 1; i < HDR_LENGTH; i++)
	{
	  ch = mips_readchar (timeout);
	  if (ch == SERIAL_TIMEOUT)
	    return -1;
	  /* Make sure this is a header byte.  */
	  if (ch == SYN || !HDR_CHECK (ch))
	    break;

	  hdr[i] = ch;
	}

      /* If we got the complete header, we can return.  Otherwise we
         loop around and keep looking for SYN.  */
      if (i >= HDR_LENGTH)
	return 0;
    }
}

/* Get a packet header, putting the data in the supplied buffer.
   PGARBAGE is a pointer to the number of garbage characters received
   so far.  The last character read is returned in *PCH.  Returns 0
   for success, -1 for timeout, -2 for error.  */

static int
mips_receive_trailer (unsigned char *trlr, int *pgarbage,
		      int *pch, int timeout)
{
  int i;
  int ch;

  for (i = 0; i < TRLR_LENGTH; i++)
    {
      ch = mips_readchar (timeout);
      *pch = ch;
      if (ch == SERIAL_TIMEOUT)
	return -1;
      if (!TRLR_CHECK (ch))
	return -2;
      trlr[i] = ch;
    }
  return 0;
}

/* Get the checksum of a packet.  HDR points to the packet header.
   DATASTR points to the packet data.  LEN is the length of DATASTR.  */

static int
mips_cksum (const unsigned char *hdr, const char *datastr, int len)
{
  const unsigned char *p;
  const unsigned char *data = (const unsigned char *) datastr;
  int c;
  int cksum;

  cksum = 0;

  /* The initial SYN is not included in the checksum.  */
  c = HDR_LENGTH - 1;
  p = hdr + 1;
  while (c-- != 0)
    cksum += *p++;

  c = len;
  p = data;
  while (c-- != 0)
    cksum += *p++;

  return cksum;
}

/* Send a packet containing the given ASCII string.  */

static void
mips_send_packet (const char *s, int get_ack)
{
  /* unsigned */ int len;
  unsigned char *packet;
  int cksum;
  int try;

  len = strlen (s);
  if (len > DATA_MAXLEN)
    mips_error (_("MIPS protocol data packet too long: %s"), s);

  packet = (unsigned char *) alloca (HDR_LENGTH + len + TRLR_LENGTH + 1);

  packet[HDR_INDX_SYN] = HDR_SET_SYN (1, len, mips_send_seq);
  packet[HDR_INDX_TYPE_LEN] = HDR_SET_TYPE_LEN (1, len, mips_send_seq);
  packet[HDR_INDX_LEN1] = HDR_SET_LEN1 (1, len, mips_send_seq);
  packet[HDR_INDX_SEQ] = HDR_SET_SEQ (1, len, mips_send_seq);

  memcpy (packet + HDR_LENGTH, s, len);

  cksum = mips_cksum (packet, (char *) packet + HDR_LENGTH, len);
  packet[HDR_LENGTH + len + TRLR_INDX_CSUM1] = TRLR_SET_CSUM1 (cksum);
  packet[HDR_LENGTH + len + TRLR_INDX_CSUM2] = TRLR_SET_CSUM2 (cksum);
  packet[HDR_LENGTH + len + TRLR_INDX_CSUM3] = TRLR_SET_CSUM3 (cksum);

  /* Increment the sequence number.  This will set mips_send_seq to
     the sequence number we expect in the acknowledgement.  */
  mips_send_seq = (mips_send_seq + 1) % SEQ_MODULOS;

  /* We can only have one outstanding data packet, so we just wait for
     the acknowledgement here.  Keep retransmitting the packet until
     we get one, or until we've tried too many times.  */
  for (try = 0; try < mips_send_retries; try++)
    {
      int garbage;
      int ch;

      if (remote_debug > 0)
	{
	  /* Don't use _filtered; we can't deal with a QUIT out of
	     target_wait, and I think this might be called from there.  */
	  packet[HDR_LENGTH + len + TRLR_LENGTH] = '\0';
	  fprintf_unfiltered (gdb_stdlog, "Writing \"%s\"\n", packet + 1);
	}

      if (serial_write (mips_desc, packet,
			HDR_LENGTH + len + TRLR_LENGTH) != 0)
	mips_error (_("write to target failed: %s"), safe_strerror (errno));

      if (!get_ack)
	return;

      garbage = 0;
      ch = 0;
      while (1)
	{
	  unsigned char hdr[HDR_LENGTH + 1];
	  unsigned char trlr[TRLR_LENGTH + 1];
	  int err;
	  unsigned int seq;

	  /* Get the packet header.  If we time out, resend the data
	     packet.  */
	  err = mips_receive_header (hdr, &garbage, ch, mips_retransmit_wait);
	  if (err != 0)
	    break;

	  ch = 0;

	  /* If we get a data packet, assume it is a duplicate and
	     ignore it.  FIXME: If the acknowledgement is lost, this
	     data packet may be the packet the remote sends after the
	     acknowledgement.  */
	  if (HDR_IS_DATA (hdr))
	    {
	      int i;

	      /* Ignore any errors raised whilst attempting to ignore
	         packet.  */

	      len = HDR_GET_LEN (hdr);

	      for (i = 0; i < len; i++)
		{
		  int rch;

		  rch = mips_readchar (remote_timeout);
		  if (rch == SYN)
		    {
		      ch = SYN;
		      break;
		    }
		  if (rch == SERIAL_TIMEOUT)
		    break;
		  /* Ignore the character.  */
		}

	      if (i == len)
		(void) mips_receive_trailer (trlr, &garbage, &ch,
					     remote_timeout);

	      /* We don't bother checking the checksum, or providing an
	         ACK to the packet.  */
	      continue;
	    }

	  /* If the length is not 0, this is a garbled packet.  */
	  if (HDR_GET_LEN (hdr) != 0)
	    continue;

	  /* Get the packet trailer.  */
	  err = mips_receive_trailer (trlr, &garbage, &ch,
				      mips_retransmit_wait);

	  /* If we timed out, resend the data packet.  */
	  if (err == -1)
	    break;

	  /* If we got a bad character, reread the header.  */
	  if (err != 0)
	    continue;

	  /* If the checksum does not match the trailer checksum, this
	     is a bad packet; ignore it.  */
	  if (mips_cksum (hdr, NULL, 0) != TRLR_GET_CKSUM (trlr))
	    continue;

	  if (remote_debug > 0)
	    {
	      hdr[HDR_LENGTH] = '\0';
	      trlr[TRLR_LENGTH] = '\0';
	      /* Don't use _filtered; we can't deal with a QUIT out of
	         target_wait, and I think this might be called from there.  */
	      fprintf_unfiltered (gdb_stdlog, "Got ack %d \"%s%s\"\n",
				  HDR_GET_SEQ (hdr), hdr + 1, trlr);
	    }

	  /* If this ack is for the current packet, we're done.  */
	  seq = HDR_GET_SEQ (hdr);
	  if (seq == mips_send_seq)
	    return;

	  /* If this ack is for the last packet, resend the current
	     packet.  */
	  if ((seq + 1) % SEQ_MODULOS == mips_send_seq)
	    break;

	  /* Otherwise this is a bad ack; ignore it.  Increment the
	     garbage count to ensure that we do not stay in this loop
	     forever.  */
	  ++garbage;
	}
    }

  mips_error (_("Remote did not acknowledge packet"));
}

/* Receive and acknowledge a packet, returning the data in BUFF (which
   should be DATA_MAXLEN + 1 bytes).  The protocol documentation
   implies that only the sender retransmits packets, so this code just
   waits silently for a packet.  It returns the length of the received
   packet.  If THROW_ERROR is nonzero, call error() on errors.  If not,
   don't print an error message and return -1.  */

static int
mips_receive_packet (char *buff, int throw_error, int timeout)
{
  int ch;
  int garbage;
  int len;
  unsigned char ack[HDR_LENGTH + TRLR_LENGTH + 1];
  int cksum;

  ch = 0;
  garbage = 0;
  while (1)
    {
      unsigned char hdr[HDR_LENGTH];
      unsigned char trlr[TRLR_LENGTH];
      int i;
      int err;

      if (mips_receive_header (hdr, &garbage, ch, timeout) != 0)
	{
	  if (throw_error)
	    mips_error (_("Timed out waiting for remote packet"));
	  else
	    return -1;
	}

      ch = 0;

      /* An acknowledgement is probably a duplicate; ignore it.  */
      if (!HDR_IS_DATA (hdr))
	{
	  len = HDR_GET_LEN (hdr);
	  /* Check if the length is valid for an ACK, we may aswell
	     try and read the remainder of the packet: */
	  if (len == 0)
	    {
	      /* Ignore the error condition, since we are going to
	         ignore the packet anyway.  */
	      (void) mips_receive_trailer (trlr, &garbage, &ch, timeout);
	    }
	  /* Don't use _filtered; we can't deal with a QUIT out of
	     target_wait, and I think this might be called from there.  */
	  if (remote_debug > 0)
	    fprintf_unfiltered (gdb_stdlog, "Ignoring unexpected ACK\n");
	  continue;
	}

      len = HDR_GET_LEN (hdr);
      for (i = 0; i < len; i++)
	{
	  int rch;

	  rch = mips_readchar (timeout);
	  if (rch == SYN)
	    {
	      ch = SYN;
	      break;
	    }
	  if (rch == SERIAL_TIMEOUT)
	    {
	      if (throw_error)
		mips_error (_("Timed out waiting for remote packet"));
	      else
		return -1;
	    }
	  buff[i] = rch;
	}

      if (i < len)
	{
	  /* Don't use _filtered; we can't deal with a QUIT out of
	     target_wait, and I think this might be called from there.  */
	  if (remote_debug > 0)
	    fprintf_unfiltered (gdb_stdlog,
				"Got new SYN after %d chars (wanted %d)\n",
				i, len);
	  continue;
	}

      err = mips_receive_trailer (trlr, &garbage, &ch, timeout);
      if (err == -1)
	{
	  if (throw_error)
	    mips_error (_("Timed out waiting for packet"));
	  else
	    return -1;
	}
      if (err == -2)
	{
	  /* Don't use _filtered; we can't deal with a QUIT out of
	     target_wait, and I think this might be called from there.  */
	  if (remote_debug > 0)
	    fprintf_unfiltered (gdb_stdlog, "Got SYN when wanted trailer\n");
	  continue;
	}

      /* If this is the wrong sequence number, ignore it.  */
      if (HDR_GET_SEQ (hdr) != mips_receive_seq)
	{
	  /* Don't use _filtered; we can't deal with a QUIT out of
	     target_wait, and I think this might be called from there.  */
	  if (remote_debug > 0)
	    fprintf_unfiltered (gdb_stdlog,
				"Ignoring sequence number %d (want %d)\n",
				HDR_GET_SEQ (hdr), mips_receive_seq);
	  continue;
	}

      if (mips_cksum (hdr, buff, len) == TRLR_GET_CKSUM (trlr))
	break;

      if (remote_debug > 0)
	/* Don't use _filtered; we can't deal with a QUIT out of
	   target_wait, and I think this might be called from there.  */
	printf_unfiltered ("Bad checksum; data %d, trailer %d\n",
			   mips_cksum (hdr, buff, len),
			   TRLR_GET_CKSUM (trlr));

      /* The checksum failed.  Send an acknowledgement for the
         previous packet to tell the remote to resend the packet.  */
      ack[HDR_INDX_SYN] = HDR_SET_SYN (0, 0, mips_receive_seq);
      ack[HDR_INDX_TYPE_LEN] = HDR_SET_TYPE_LEN (0, 0, mips_receive_seq);
      ack[HDR_INDX_LEN1] = HDR_SET_LEN1 (0, 0, mips_receive_seq);
      ack[HDR_INDX_SEQ] = HDR_SET_SEQ (0, 0, mips_receive_seq);

      cksum = mips_cksum (ack, NULL, 0);

      ack[HDR_LENGTH + TRLR_INDX_CSUM1] = TRLR_SET_CSUM1 (cksum);
      ack[HDR_LENGTH + TRLR_INDX_CSUM2] = TRLR_SET_CSUM2 (cksum);
      ack[HDR_LENGTH + TRLR_INDX_CSUM3] = TRLR_SET_CSUM3 (cksum);

      if (remote_debug > 0)
	{
	  ack[HDR_LENGTH + TRLR_LENGTH] = '\0';
	  /* Don't use _filtered; we can't deal with a QUIT out of
	     target_wait, and I think this might be called from there.  */
	  printf_unfiltered ("Writing ack %d \"%s\"\n", mips_receive_seq,
			     ack + 1);
	}

      if (serial_write (mips_desc, ack, HDR_LENGTH + TRLR_LENGTH) != 0)
	{
	  if (throw_error)
	    mips_error (_("write to target failed: %s"),
	                safe_strerror (errno));
	  else
	    return -1;
	}
    }

  if (remote_debug > 0)
    {
      buff[len] = '\0';
      /* Don't use _filtered; we can't deal with a QUIT out of
         target_wait, and I think this might be called from there.  */
      printf_unfiltered ("Got packet \"%s\"\n", buff);
    }

  /* We got the packet.  Send an acknowledgement.  */
  mips_receive_seq = (mips_receive_seq + 1) % SEQ_MODULOS;

  ack[HDR_INDX_SYN] = HDR_SET_SYN (0, 0, mips_receive_seq);
  ack[HDR_INDX_TYPE_LEN] = HDR_SET_TYPE_LEN (0, 0, mips_receive_seq);
  ack[HDR_INDX_LEN1] = HDR_SET_LEN1 (0, 0, mips_receive_seq);
  ack[HDR_INDX_SEQ] = HDR_SET_SEQ (0, 0, mips_receive_seq);

  cksum = mips_cksum (ack, NULL, 0);

  ack[HDR_LENGTH + TRLR_INDX_CSUM1] = TRLR_SET_CSUM1 (cksum);
  ack[HDR_LENGTH + TRLR_INDX_CSUM2] = TRLR_SET_CSUM2 (cksum);
  ack[HDR_LENGTH + TRLR_INDX_CSUM3] = TRLR_SET_CSUM3 (cksum);

  if (remote_debug > 0)
    {
      ack[HDR_LENGTH + TRLR_LENGTH] = '\0';
      /* Don't use _filtered; we can't deal with a QUIT out of
         target_wait, and I think this might be called from there.  */
      printf_unfiltered ("Writing ack %d \"%s\"\n", mips_receive_seq,
			 ack + 1);
    }

  if (serial_write (mips_desc, ack, HDR_LENGTH + TRLR_LENGTH) != 0)
    {
      if (throw_error)
	mips_error (_("write to target failed: %s"), safe_strerror (errno));
      else
	return -1;
    }

  return len;
}

/* Optionally send a request to the remote system and optionally wait
   for the reply.  This implements the remote debugging protocol,
   which is built on top of the packet protocol defined above.  Each
   request has an ADDR argument and a DATA argument.  The following
   requests are defined:

   \0   don't send a request; just wait for a reply
   i    read word from instruction space at ADDR
   d    read word from data space at ADDR
   I    write DATA to instruction space at ADDR
   D    write DATA to data space at ADDR
   r    read register number ADDR
   R    set register number ADDR to value DATA
   c    continue execution (if ADDR != 1, set pc to ADDR)
   s    single step (if ADDR != 1, set pc to ADDR)

   The read requests return the value requested.  The write requests
   return the previous value in the changed location.  The execution
   requests return a UNIX wait value (the approximate signal which
   caused execution to stop is in the upper eight bits).

   If PERR is not NULL, this function waits for a reply.  If an error
   occurs, it sets *PERR to 1 and sets errno according to what the
   target board reports.  */

static ULONGEST
mips_request (int cmd,
	      ULONGEST addr,
	      ULONGEST data,
	      int *perr,
	      int timeout,
	      char *buff)
{
  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;
  char myBuff[DATA_MAXLEN + 1];
  char response_string[17];
  int len;
  int rpid;
  char rcmd;
  int rerrflg;
  ULONGEST rresponse;

  if (buff == (char *) NULL)
    buff = myBuff;

  if (cmd != '\0')
    {
      if (mips_need_reply)
	internal_error (__FILE__, __LINE__,
			_("mips_request: Trying to send "
			  "command before reply"));
      /* 'T' sets a register to a 64-bit value, so make sure we use
	 the right conversion function.  */
      if (cmd == 'T')
	sprintf (buff, "0x0 %c 0x%s 0x%s", cmd,
		 phex_nz (addr, addr_size), phex_nz (data, 8));
      else
	sprintf (buff, "0x0 %c 0x%s 0x%s", cmd,
	         phex_nz (addr, addr_size), phex_nz (data, addr_size));

      mips_send_packet (buff, 1);
      mips_need_reply = 1;
    }

  if (perr == (int *) NULL)
    return 0;

  if (!mips_need_reply)
    internal_error (__FILE__, __LINE__,
		    _("mips_request: Trying to get reply before command"));

  mips_need_reply = 0;

  len = mips_receive_packet (buff, 1, timeout);
  buff[len] = '\0';

  if (sscanf (buff, "0x%x %c 0x%x 0x%16s",
	      &rpid, &rcmd, &rerrflg, response_string) != 4
      || !read_hex_value (response_string, &rresponse)
      || (cmd != '\0' && rcmd != cmd))
    mips_error (_("Bad response from remote board"));

  if (rerrflg != 0)
    {
      *perr = 1;

      /* FIXME: This will returns MIPS errno numbers, which may or may
         not be the same as errno values used on other systems.  If
         they stick to common errno values, they will be the same, but
         if they don't, they must be translated.  */
      errno = rresponse;

      return 0;
    }

  *perr = 0;
  return rresponse;
}

/* Cleanup associated with mips_initialize().  */

static void
mips_initialize_cleanups (void *arg)
{
  mips_initializing = 0;
}

/* Cleanup associated with mips_exit_debug().  */

static void
mips_exit_cleanups (void *arg)
{
  mips_exiting = 0;
}

/* Send a command and wait for that command to be echoed back.  Wait,
   too, for the following prompt.  */

static void
mips_send_command (const char *cmd, int prompt)
{
  serial_write (mips_desc, cmd, strlen (cmd));
  mips_expect (cmd);
  mips_expect ("\n");
  if (prompt)
    mips_expect (mips_monitor_prompt);
}

/* Enter remote (dbx) debug mode: */

static void
mips_enter_debug (void)
{
  /* Reset the sequence numbers, ready for the new debug sequence: */
  mips_send_seq = 0;
  mips_receive_seq = 0;

  if (mips_monitor != MON_IDT)
    mips_send_command ("debug\r", 0);
  else				/* Assume IDT monitor by default.  */
    mips_send_command ("db tty0\r", 0);

  gdb_usleep (1000000);
  serial_write (mips_desc, "\r", sizeof "\r" - 1);

  /* We don't need to absorb any spurious characters here, since the
     mips_receive_header will eat up a reasonable number of characters
     whilst looking for the SYN, however this avoids the "garbage"
     being displayed to the user.  */
  if (mips_monitor != MON_IDT)
    mips_expect ("\r");

  {
    char buff[DATA_MAXLEN + 1];

    if (mips_receive_packet (buff, 1, 3) < 0)
      mips_error (_("Failed to initialize (didn't receive packet)."));
  }
}

/* Exit remote (dbx) debug mode, returning to the monitor prompt: */

static int
mips_exit_debug (void)
{
  int err;
  struct cleanup *old_cleanups = make_cleanup (mips_exit_cleanups, NULL);

  mips_exiting = 1;

  if (mips_monitor != MON_IDT && mips_monitor != MON_ROCKHOPPER)
    {
      /* The DDB (NEC) and MiniRISC (LSI) versions of PMON exit immediately,
         so we do not get a reply to this command: */
      mips_request ('x', 0, 0, NULL, mips_receive_wait, NULL);
      mips_need_reply = 0;
      if (!mips_expect (" break!"))
	{
	  do_cleanups (old_cleanups);
	  return -1;
	}
    }
  else
    mips_request ('x', 0, 0, &err, mips_receive_wait, NULL);

  if (!mips_expect (mips_monitor_prompt))
    {
      do_cleanups (old_cleanups);
      return -1;
    }

  do_cleanups (old_cleanups);

  return 0;
}

/* Initialize a new connection to the MIPS board, and make sure we are
   really connected.  */

static void
mips_initialize (void)
{
  int err;
  struct cleanup *old_cleanups;
  int j;

  /* What is this code doing here?  I don't see any way it can happen, and
     it might mean mips_initializing didn't get cleared properly.
     So I'll make it a warning.  */

  if (mips_initializing)
    {
      warning (_("internal error: mips_initialize called twice"));
      return;
    }

  old_cleanups = make_cleanup (mips_initialize_cleanups, NULL);

  mips_wait_flag = 0;
  mips_initializing = 1;

  /* At this point, the packit protocol isn't responding.  We'll try getting
     into the monitor, and restarting the protocol.  */

  /* Force the system into the monitor.  After this we *should* be at
     the mips_monitor_prompt.  */
  if (mips_monitor != MON_IDT)
    j = 0;			/* Start by checking if we are already
				   at the prompt.  */
  else
    j = 1;			/* Start by sending a break.  */
  for (; j <= 4; j++)
    {
      switch (j)
	{
	case 0:		/* First, try sending a CR.  */
	  serial_flush_input (mips_desc);
	  serial_write (mips_desc, "\r", 1);
	  break;
	case 1:		/* First, try sending a break.  */
	  serial_send_break (mips_desc);
	  break;
	case 2:		/* Then, try a ^C.  */
	  serial_write (mips_desc, "\003", 1);
	  break;
	case 3:		/* Then, try escaping from download.  */
	  {
	    if (mips_monitor != MON_IDT)
	      {
		char tbuff[7];

		/* We shouldn't need to send multiple termination
		   sequences, since the target performs line (or
		   block) reads, and then processes those
		   packets.  In-case we were downloading a large packet
		   we flush the output buffer before inserting a
		   termination sequence.  */
		serial_flush_output (mips_desc);
		sprintf (tbuff, "\r/E/E\r");
		serial_write (mips_desc, tbuff, 6);
	      }
	    else
	      {
		char srec[10];
		int i;

		/* We are possibly in binary download mode, having
		   aborted in the middle of an S-record.  ^C won't
		   work because of binary mode.  The only reliable way
		   out is to send enough termination packets (8 bytes)
		   to fill up and then overflow the largest size
		   S-record (255 bytes in this case).  This amounts to
		   256/8 + 1 packets.  */

		mips_make_srec (srec, '7', 0, NULL, 0);

		for (i = 1; i <= 33; i++)
		  {
		    serial_write (mips_desc, srec, 8);

		    if (serial_readchar (mips_desc, 0) >= 0)
		      break;	/* Break immediatly if we get something from
				   the board.  */
		  }
	      }
	  }
	  break;
	case 4:
	  mips_error (_("Failed to initialize."));
	}

      if (mips_expect (mips_monitor_prompt))
	break;
    }

  if (mips_monitor != MON_IDT)
    {
      /* Sometimes PMON ignores the first few characters in the first
         command sent after a load.  Sending a blank command gets
         around that.  */
      mips_send_command ("\r", -1);

      /* Ensure the correct target state: */
      if (mips_monitor != MON_LSI)
	mips_send_command ("set regsize 64\r", -1);
      mips_send_command ("set hostport tty0\r", -1);
      mips_send_command ("set brkcmd \"\"\r", -1);
      /* Delete all the current breakpoints: */
      mips_send_command ("db *\r", -1);
      /* NOTE: PMON does not have breakpoint support through the
         "debug" mode, only at the monitor command-line.  */
    }

  mips_enter_debug ();

  /* Clear all breakpoints: */
  if ((mips_monitor == MON_IDT
       && mips_clear_breakpoint (-1, 0, BREAK_UNUSED) == 0)
      || mips_monitor == MON_LSI)
    monitor_supports_breakpoints = 1;
  else
    monitor_supports_breakpoints = 0;

  do_cleanups (old_cleanups);

  /* If this doesn't call error, we have connected; we don't care if
     the request itself succeeds or fails.  */

  mips_request ('r', 0, 0, &err, mips_receive_wait, NULL);
}

/* Open a connection to the remote board.  */

static void
common_open (struct target_ops *ops, char *name, int from_tty,
	     enum mips_monitor_type new_monitor,
	     const char *new_monitor_prompt)
{
  char *serial_port_name;
  char *remote_name = 0;
  char *local_name = 0;
  char **argv;
  struct cleanup *cleanup;

  if (name == 0)
    error (_("\
To open a MIPS remote debugging connection, you need to specify what\n\
serial device is attached to the target board (e.g., /dev/ttya).\n\
If you want to use TFTP to download to the board, specify the name of a\n\
temporary file to be used by GDB for downloads as the second argument.\n\
This filename must be in the form host:filename, where host is the name\n\
of the host running the TFTP server, and the file must be readable by the\n\
world.  If the local name of the temporary file differs from the name as\n\
seen from the board via TFTP, specify that name as the third parameter.\n"));

  /* Parse the serial port name, the optional TFTP name, and the
     optional local TFTP name.  */
  argv = gdb_buildargv (name);
  cleanup = make_cleanup_freeargv (argv);

  serial_port_name = xstrdup (argv[0]);
  if (argv[1])			/* Remote TFTP name specified?  */
    {
      remote_name = argv[1];
      if (argv[2])		/* Local TFTP filename specified?  */
	local_name = argv[2];
    }

  target_preopen (from_tty);

  if (mips_is_open)
    unpush_target (current_ops);

  /* Open and initialize the serial port.  */
  mips_desc = serial_open (serial_port_name);
  if (mips_desc == NULL)
    perror_with_name (serial_port_name);

  if (baud_rate != -1)
    {
      if (serial_setbaudrate (mips_desc, baud_rate))
	{
	  serial_close (mips_desc);
	  perror_with_name (serial_port_name);
	}
    }

  serial_raw (mips_desc);

  /* Open and initialize the optional download port.  If it is in the form
     hostname#portnumber, it's a UDP socket.  If it is in the form
     hostname:filename, assume it's the TFTP filename that must be
     passed to the DDB board to tell it where to get the load file.  */
  if (remote_name)
    {
      if (strchr (remote_name, '#'))
	{
	  udp_desc = serial_open (remote_name);
	  if (!udp_desc)
	    perror_with_name (_("Unable to open UDP port"));
	  udp_in_use = 1;
	}
      else
	{
	  /* Save the remote and local names of the TFTP temp file.  If
	     the user didn't specify a local name, assume it's the same
	     as the part of the remote name after the "host:".  */
	  if (tftp_name)
	    xfree (tftp_name);
	  if (tftp_localname)
	    xfree (tftp_localname);
	  if (local_name == NULL)
	    if ((local_name = strchr (remote_name, ':')) != NULL)
	      local_name++;	/* Skip over the colon.  */
	  if (local_name == NULL)
	    local_name = remote_name;	/* Local name same as remote name.  */
	  tftp_name = xstrdup (remote_name);
	  tftp_localname = xstrdup (local_name);
	  tftp_in_use = 1;
	}
    }

  current_ops = ops;
  mips_is_open = 1;

  /* Reset the expected monitor prompt if it's never been set before.  */
  if (mips_monitor_prompt == NULL)
    mips_monitor_prompt = xstrdup (new_monitor_prompt);
  mips_monitor = new_monitor;

  mips_initialize ();

  if (from_tty)
    printf_unfiltered ("Remote MIPS debugging using %s\n", serial_port_name);

  /* Switch to using remote target now.  */
  push_target (ops);

  inferior_ptid = remote_mips_ptid;
  inferior_appeared (current_inferior (), ptid_get_pid (inferior_ptid));
  add_thread_silent (inferior_ptid);

  /* Try to figure out the processor model if possible.  */
  deprecated_mips_set_processor_regs_hack ();

  /* This is really the job of start_remote however, that makes an
     assumption that the target is about to print out a status message
     of some sort.  That doesn't happen here (in fact, it may not be
     possible to get the monitor to send the appropriate packet).  */

  reinit_frame_cache ();
  registers_changed ();
  stop_pc = regcache_read_pc (get_current_regcache ());
  print_stack_frame (get_selected_frame (NULL), 0, SRC_AND_LOC, 1);
  xfree (serial_port_name);

  do_cleanups (cleanup);
}

/* Open a connection to an IDT board.  */

static void
mips_open (char *name, int from_tty)
{
  const char *monitor_prompt = NULL;
  if (gdbarch_bfd_arch_info (target_gdbarch ()) != NULL
      && gdbarch_bfd_arch_info (target_gdbarch ())->arch == bfd_arch_mips)
    {
    switch (gdbarch_bfd_arch_info (target_gdbarch ())->mach)
      {
      case bfd_mach_mips4100:
      case bfd_mach_mips4300:
      case bfd_mach_mips4600:
      case bfd_mach_mips4650:
      case bfd_mach_mips5000:
	monitor_prompt = "<RISQ> ";
	break;
      }
    }
  if (monitor_prompt == NULL)
    monitor_prompt = "<IDT>";
  common_open (&mips_ops, name, from_tty, MON_IDT, monitor_prompt);
}

/* Open a connection to a PMON board.  */

static void
pmon_open (char *name, int from_tty)
{
  common_open (&pmon_ops, name, from_tty, MON_PMON, "PMON> ");
}

/* Open a connection to a DDB board.  */

static void
ddb_open (char *name, int from_tty)
{
  common_open (&ddb_ops, name, from_tty, MON_DDB, "NEC010>");
}

/* Open a connection to a rockhopper board.  */

static void
rockhopper_open (char *name, int from_tty)
{
  common_open (&rockhopper_ops, name, from_tty, MON_ROCKHOPPER, "NEC01>");
}

/* Open a connection to an LSI board.  */

static void
lsi_open (char *name, int from_tty)
{
  int i;

  /* Clear the LSI breakpoint table.  */
  for (i = 0; i < MAX_LSI_BREAKPOINTS; i++)
    lsi_breakpoints[i].type = BREAK_UNUSED;

  common_open (&lsi_ops, name, from_tty, MON_LSI, "PMON> ");
}

/* Close a connection to the remote board.  */

static void
mips_close (void)
{
  if (mips_is_open)
    {
      /* Get the board out of remote debugging mode.  */
      (void) mips_exit_debug ();

      close_ports ();
    }

  generic_mourn_inferior ();
}

/* Detach from the remote board.  */

static void
mips_detach (struct target_ops *ops, char *args, int from_tty)
{
  if (args)
    error (_("Argument given to \"detach\" when remotely debugging."));

  unpush_target (ops);

  if (from_tty)
    printf_unfiltered ("Ending remote MIPS debugging.\n");
}

/* Tell the target board to resume.  This does not wait for a reply
   from the board, except in the case of single-stepping on LSI boards,
   where PMON does return a reply.  */

static void
mips_resume (struct target_ops *ops,
	     ptid_t ptid, int step, enum gdb_signal siggnal)
{
  int err;

  /* LSI PMON requires returns a reply packet "0x1 s 0x0 0x57f" after
     a single step, so we wait for that.  */
  mips_request (step ? 's' : 'c', 1, siggnal,
		mips_monitor == MON_LSI && step ? &err : (int *) NULL,
		mips_receive_wait, NULL);
}

/* Return the signal corresponding to SIG, where SIG is the number which
   the MIPS protocol uses for the signal.  */

static enum gdb_signal
mips_signal_from_protocol (int sig)
{
  /* We allow a few more signals than the IDT board actually returns, on
     the theory that there is at least *some* hope that perhaps the numbering
     for these signals is widely agreed upon.  */
  if (sig <= 0
      || sig > 31)
    return GDB_SIGNAL_UNKNOWN;

  /* Don't want to use gdb_signal_from_host because we are converting
     from MIPS signal numbers, not host ones.  Our internal numbers
     match the MIPS numbers for the signals the board can return, which
     are: SIGINT, SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP.  */
  return (enum gdb_signal) sig;
}

/* Set the register designated by REGNO to the value designated by VALUE.  */

static void
mips_set_register (int regno, ULONGEST value)
{
  gdb_byte buf[MAX_REGISTER_SIZE];
  struct regcache *regcache = get_current_regcache ();
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);

  /* We got the number the register holds, but gdb expects to see a
     value in the target byte ordering.  */

  if (mips_monitor != MON_ROCKHOPPER
      && (regno == mips_regnum (gdbarch)->pc || regno < 32))
    /* Some 64-bit boards have monitors that only send the bottom 32 bits.
       In such cases we can only really debug 32-bit code properly so,
       when reading a GPR or the PC, assume that the full 64-bit
       value is the sign extension of the lower 32 bits.  */
    store_signed_integer (buf, register_size (gdbarch, regno), byte_order,
                          value);
  else
    store_unsigned_integer (buf, register_size (gdbarch, regno), byte_order,
                            value);

  regcache_raw_supply (regcache, regno, buf);
}

/* Wait until the remote stops, and return a wait status.  */

static ptid_t
mips_wait (struct target_ops *ops,
	   ptid_t ptid, struct target_waitstatus *status, int options)
{
  int rstatus;
  int err;
  char buff[DATA_MAXLEN];
  ULONGEST rpc, rfp, rsp;
  char pc_string[17], fp_string[17], sp_string[17], flags[20];
  int nfields;

  interrupt_count = 0;
  hit_watchpoint = 0;

  /* If we have not sent a single step or continue command, then the
     board is waiting for us to do something.  Return a status
     indicating that it is stopped.  */
  if (!mips_need_reply)
    {
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = GDB_SIGNAL_TRAP;
      return inferior_ptid;
    }

  /* No timeout; we sit here as long as the program continues to execute.  */
  mips_wait_flag = 1;
  rstatus = mips_request ('\000', 0, 0, &err, -1, buff);
  mips_wait_flag = 0;
  if (err)
    mips_error (_("Remote failure: %s"), safe_strerror (errno));

  /* On returning from a continue, the PMON monitor seems to start
     echoing back the messages we send prior to sending back the
     ACK.  The code can cope with this, but to try and avoid the
     unnecessary serial traffic, and "spurious" characters displayed
     to the user, we cheat and reset the debug protocol.  The problems
     seems to be caused by a check on the number of arguments, and the
     command length, within the monitor causing it to echo the command
     as a bad packet.  */
  if (mips_monitor == MON_PMON)
    {
      mips_exit_debug ();
      mips_enter_debug ();
    }

  /* See if we got back extended status.  If so, pick out the pc, fp,
     sp, etc...  */

  nfields = sscanf (buff,
		    "0x%*x %*c 0x%*x 0x%*x 0x%16s 0x%16s 0x%16s 0x%*x %s",
		    pc_string, fp_string, sp_string, flags);
  if (nfields >= 3
      && read_hex_value (pc_string, &rpc)
      && read_hex_value (fp_string, &rfp)
      && read_hex_value (sp_string, &rsp))
    {
      struct regcache *regcache = get_current_regcache ();
      struct gdbarch *gdbarch = get_regcache_arch (regcache);

      mips_set_register (gdbarch_pc_regnum (gdbarch), rpc);
      mips_set_register (30, rfp);
      mips_set_register (gdbarch_sp_regnum (gdbarch), rsp);

      if (nfields == 9)
	{
	  int i;

	  for (i = 0; i <= 2; i++)
	    if (flags[i] == 'r' || flags[i] == 'w')
	      hit_watchpoint = 1;
	    else if (flags[i] == '\000')
	      break;
	}
    }

  if (strcmp (target_shortname, "lsi") == 0)
    {
#if 0
      /* If this is an LSI PMON target, see if we just hit a
         hardrdware watchpoint.  Right now, PMON doesn't give us
         enough information to determine which breakpoint we hit.  So
         we have to look up the PC in our own table of breakpoints,
         and if found, assume it's just a normal instruction fetch
         breakpoint, not a data watchpoint.  FIXME when PMON provides
         some way to tell us what type of breakpoint it is.  */
      int i;
      CORE_ADDR pc = regcache_read_pc (get_current_regcache ());

      hit_watchpoint = 1;
      for (i = 0; i < MAX_LSI_BREAKPOINTS; i++)
	{
	  if (lsi_breakpoints[i].addr == pc
	      && lsi_breakpoints[i].type == BREAK_FETCH)
	    {
	      hit_watchpoint = 0;
	      break;
	    }
	}
#else
      /* If a data breakpoint was hit, PMON returns the following packet:
         0x1 c 0x0 0x57f 0x1
         The return packet from an ordinary breakpoint doesn't have the
         extra 0x01 field tacked onto the end.  */
      if (nfields == 1 && rpc == 1)
	hit_watchpoint = 1;
#endif
    }

  /* NOTE: The following (sig) numbers are defined by PMON:
     SPP_SIGTRAP     5       breakpoint
     SPP_SIGINT      2
     SPP_SIGSEGV     11
     SPP_SIGBUS      10
     SPP_SIGILL      4
     SPP_SIGFPE      8
     SPP_SIGTERM     15 */

  /* Translate a MIPS waitstatus.  We use constants here rather than WTERMSIG
     and so on, because the constants we want here are determined by the
     MIPS protocol and have nothing to do with what host we are running on.  */
  if ((rstatus & 0xff) == 0)
    {
      status->kind = TARGET_WAITKIND_EXITED;
      status->value.integer = (((rstatus) >> 8) & 0xff);
    }
  else if ((rstatus & 0xff) == 0x7f)
    {
      status->kind = TARGET_WAITKIND_STOPPED;
      status->value.sig = mips_signal_from_protocol (((rstatus) >> 8) & 0xff);

      /* If the stop PC is in the _exit function, assume
         we hit the 'break 0x3ff' instruction in _exit, so this
         is not a normal breakpoint.  */
      if (strcmp (target_shortname, "lsi") == 0)
	{
	  const char *func_name;
	  CORE_ADDR func_start;
	  CORE_ADDR pc = regcache_read_pc (get_current_regcache ());

	  find_pc_partial_function (pc, &func_name, &func_start, NULL);
	  if (func_name != NULL && strcmp (func_name, "_exit") == 0
	      && func_start == pc)
	    status->kind = TARGET_WAITKIND_EXITED;
	}
    }
  else
    {
      status->kind = TARGET_WAITKIND_SIGNALLED;
      status->value.sig = mips_signal_from_protocol (rstatus & 0x7f);
    }

  return inferior_ptid;
}

/* We have to map between the register numbers used by gdb and the
   register numbers used by the debugging protocol.  */

#define REGNO_OFFSET 96

static int
mips_map_regno (struct gdbarch *gdbarch, int regno)
{
  if (regno < 32)
    return regno;
  if (regno >= mips_regnum (gdbarch)->fp0
      && regno < mips_regnum (gdbarch)->fp0 + 32)
    return regno - mips_regnum (gdbarch)->fp0 + 32;
  else if (regno == mips_regnum (gdbarch)->pc)
    return REGNO_OFFSET + 0;
  else if (regno == mips_regnum (gdbarch)->cause)
    return REGNO_OFFSET + 1;
  else if (regno == mips_regnum (gdbarch)->hi)
    return REGNO_OFFSET + 2;
  else if (regno == mips_regnum (gdbarch)->lo)
    return REGNO_OFFSET + 3;
  else if (regno == mips_regnum (gdbarch)->fp_control_status)
    return REGNO_OFFSET + 4;
  else if (regno == mips_regnum (gdbarch)->fp_implementation_revision)
    return REGNO_OFFSET + 5;
  else
    /* FIXME: Is there a way to get the status register?  */
    return 0;
}

/* Fetch the remote registers.  */

static void
mips_fetch_registers (struct target_ops *ops,
		      struct regcache *regcache, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  ULONGEST val;
  int err;

  if (regno == -1)
    {
      for (regno = 0; regno < gdbarch_num_regs (gdbarch); regno++)
	mips_fetch_registers (ops, regcache, regno);
      return;
    }

  if (regno == gdbarch_deprecated_fp_regnum (gdbarch)
      || regno == MIPS_ZERO_REGNUM)
    /* gdbarch_deprecated_fp_regnum on the mips is a hack which is just
       supposed to read zero (see also mips-nat.c).  */
    val = 0;
  else
    {
      /* If PMON doesn't support this register, don't waste serial
         bandwidth trying to read it.  */
      int pmon_reg = mips_map_regno (gdbarch, regno);

      if (regno != 0 && pmon_reg == 0)
	val = 0;
      else
	{
	  /* Unfortunately the PMON version in the Vr4300 board has been
	     compiled without the 64bit register access commands.  This
	     means we cannot get hold of the full register width.  */
	  if (mips_monitor == MON_DDB || mips_monitor == MON_ROCKHOPPER)
	    val = mips_request ('t', pmon_reg, 0,
				&err, mips_receive_wait, NULL);
	  else
	    val = mips_request ('r', pmon_reg, 0,
				&err, mips_receive_wait, NULL);
	  if (err)
	    mips_error (_("Can't read register %d: %s"), regno,
			safe_strerror (errno));
	}
    }

  mips_set_register (regno, val);
}

/* Prepare to store registers.  The MIPS protocol can store individual
   registers, so this function doesn't have to do anything.  */

static void
mips_prepare_to_store (struct regcache *regcache)
{
}

/* Store remote register(s).  */

static void
mips_store_registers (struct target_ops *ops,
		      struct regcache *regcache, int regno)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  ULONGEST val;
  int err;

  if (regno == -1)
    {
      for (regno = 0; regno < gdbarch_num_regs (gdbarch); regno++)
	mips_store_registers (ops, regcache, regno);
      return;
    }

  regcache_cooked_read_unsigned (regcache, regno, &val);
  mips_request (mips_monitor == MON_ROCKHOPPER ? 'T' : 'R',
  		mips_map_regno (gdbarch, regno),
		val,
		&err, mips_receive_wait, NULL);
  if (err)
    mips_error (_("Can't write register %d: %s"), regno,
                safe_strerror (errno));
}

/* Fetch a word from the target board.  Return word fetched in location
   addressed by VALP.  Return 0 when successful; return positive error
   code when not.  */

static int
mips_fetch_word (CORE_ADDR addr, unsigned int *valp)
{
  int err;

  *valp = mips_request ('d', addr, 0, &err, mips_receive_wait, NULL);
  if (err)
    {
      /* Data space failed; try instruction space.  */
      *valp = mips_request ('i', addr, 0, &err,
			    mips_receive_wait, NULL);
    }
  return err;
}

/* Store a word to the target board.  Returns errno code or zero for
   success.  If OLD_CONTENTS is non-NULL, put the old contents of that
   memory location there.  */

/* FIXME! make sure only 32-bit quantities get stored!  */
static int
mips_store_word (CORE_ADDR addr, unsigned int val, int *old_contents)
{
  int err;
  unsigned int oldcontents;

  oldcontents = mips_request ('D', addr, val, &err,
			      mips_receive_wait, NULL);
  if (err)
    {
      /* Data space failed; try instruction space.  */
      oldcontents = mips_request ('I', addr, val, &err,
				  mips_receive_wait, NULL);
      if (err)
	return errno;
    }
  if (old_contents != NULL)
    *old_contents = oldcontents;
  return 0;
}

/* Read or write LEN bytes from inferior memory at MEMADDR,
   transferring to or from debugger address MYADDR.  Write to inferior
   if SHOULD_WRITE is nonzero.  Returns length of data written or
   read; 0 for error.  Note that protocol gives us the correct value
   for a longword, since it transfers values in ASCII.  We want the
   byte values, so we have to swap the longword values.  */

static int mask_address_p = 1;

static int
mips_xfer_memory (CORE_ADDR memaddr, gdb_byte *myaddr, int len, int write,
		  struct mem_attrib *attrib, struct target_ops *target)
{
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());
  int i;
  CORE_ADDR addr;
  int count;
  gdb_byte *buffer;
  int status;

  /* PMON targets do not cope well with 64 bit addresses.  Mask the
     value down to 32 bits.  */
  if (mask_address_p)
    memaddr &= (CORE_ADDR) 0xffffffff;

  /* Round starting address down to longword boundary.  */
  addr = memaddr & ~3;
  /* Round ending address up; get number of longwords that makes.  */
  count = (((memaddr + len) - addr) + 3) / 4;
  /* Allocate buffer of that many longwords.  */
  buffer = alloca (count * 4);

  if (write)
    {
      /* Fill start and end extra bytes of buffer with existing data.  */
      if (addr != memaddr || len < 4)
	{
	  unsigned int val;

	  if (mips_fetch_word (addr, &val))
	    return 0;

	  /* Need part of initial word -- fetch it.  */
	  store_unsigned_integer (&buffer[0], 4, byte_order, val);
	}

      if (count > 1)
	{
	  unsigned int val;

	  /* Need part of last word -- fetch it.  FIXME: we do this even
	     if we don't need it.  */
	  if (mips_fetch_word (addr + (count - 1) * 4, &val))
	    return 0;

	  store_unsigned_integer (&buffer[(count - 1) * 4],
				  4, byte_order, val);
	}

      /* Copy data to be written over corresponding part of buffer.  */

      memcpy ((char *) buffer + (memaddr & 3), myaddr, len);

      /* Write the entire buffer.  */

      for (i = 0; i < count; i++, addr += 4)
	{
	  int word;

	  word = extract_unsigned_integer (&buffer[i * 4], 4, byte_order);
	  status = mips_store_word (addr, word, NULL);
	  /* Report each kilobyte (we download 32-bit words at a time).  */
	  if (i % 256 == 255)
	    {
	      printf_unfiltered ("*");
	      gdb_flush (gdb_stdout);
	    }
	  if (status)
	    {
	      errno = status;
	      return 0;
	    }
	  /* FIXME: Do we want a QUIT here?  */
	}
      if (count >= 256)
	printf_unfiltered ("\n");
    }
  else
    {
      /* Read all the longwords.  */
      for (i = 0; i < count; i++, addr += 4)
	{
	  unsigned int val;

	  if (mips_fetch_word (addr, &val))
	    return 0;

	  store_unsigned_integer (&buffer[i * 4], 4, byte_order, val);
	  QUIT;
	}

      /* Copy appropriate bytes out of the buffer.  */
      memcpy (myaddr, buffer + (memaddr & 3), len);
    }
  return len;
}

/* Print info on this target.  */

static void
mips_files_info (struct target_ops *ignore)
{
  printf_unfiltered ("Debugging a MIPS board over a serial line.\n");
}

/* Kill the process running on the board.  This will actually only
   work if we are doing remote debugging over the console input.  I
   think that if IDT/sim had the remote debug interrupt enabled on the
   right port, we could interrupt the process with a break signal.  */

static void
mips_kill (struct target_ops *ops)
{
  if (!mips_wait_flag)
    {
      target_mourn_inferior ();
      return;
    }

  interrupt_count++;

  if (interrupt_count >= 2)
    {
      interrupt_count = 0;

      target_terminal_ours ();

      if (query (_("Interrupted while waiting for the program.\n\
Give up (and stop debugging it)? ")))
	{
	  /* Clean up in such a way that mips_close won't try to talk
	     to the board (it almost surely won't work since we
	     weren't able to talk to it).  */
	  mips_wait_flag = 0;
	  close_ports ();

	  printf_unfiltered ("Ending remote MIPS debugging.\n");
	  target_mourn_inferior ();
	  quit ();
	}

      target_terminal_inferior ();
    }

  if (remote_debug > 0)
    printf_unfiltered ("Sending break\n");

  serial_send_break (mips_desc);

  target_mourn_inferior ();

#if 0
  if (mips_is_open)
    {
      char cc;

      /* Send a ^C.  */
      cc = '\003';
      serial_write (mips_desc, &cc, 1);
      sleep (1);
      target_mourn_inferior ();
    }
#endif
}

/* Start running on the target board.  */

static void
mips_create_inferior (struct target_ops *ops, char *execfile,
		      char *args, char **env, int from_tty)
{
  CORE_ADDR entry_pt;

  if (args && *args)
    {
      warning (_("\
Can't pass arguments to remote MIPS board; arguments ignored."));
      /* And don't try to use them on the next "run" command.  */
      execute_command ("set args", 0);
    }

  if (execfile == 0 || exec_bfd == 0)
    error (_("No executable file specified"));

  entry_pt = (CORE_ADDR) bfd_get_start_address (exec_bfd);

  init_wait_for_inferior ();

  regcache_write_pc (get_current_regcache (), entry_pt);
}

/* Clean up after a process. The bulk of the work is done in mips_close(),
   which is called when unpushing the target.  */

static void
mips_mourn_inferior (struct target_ops *ops)
{
  if (current_ops != NULL)
    unpush_target (current_ops);
}

/* We can write a breakpoint and read the shadow contents in one
   operation.  */

/* Insert a breakpoint.  On targets that don't have built-in
   breakpoint support, we read the contents of the target location and
   stash it, then overwrite it with a breakpoint instruction.  ADDR is
   the target location in the target machine.  BPT is the breakpoint
   being inserted or removed, which contains memory for saving the
   target contents.  */

static int
mips_insert_breakpoint (struct gdbarch *gdbarch,
			struct bp_target_info *bp_tgt)
{
  if (monitor_supports_breakpoints)
    return mips_set_breakpoint (bp_tgt->placed_address, MIPS_INSN32_SIZE,
				BREAK_FETCH);
  else
    return memory_insert_breakpoint (gdbarch, bp_tgt);
}

/* Remove a breakpoint.  */

static int
mips_remove_breakpoint (struct gdbarch *gdbarch,
			struct bp_target_info *bp_tgt)
{
  if (monitor_supports_breakpoints)
    return mips_clear_breakpoint (bp_tgt->placed_address, MIPS_INSN32_SIZE,
				  BREAK_FETCH);
  else
    return memory_remove_breakpoint (gdbarch, bp_tgt);
}

/* Tell whether this target can support a hardware breakpoint.  CNT
   is the number of hardware breakpoints already installed.  This
   implements the target_can_use_hardware_watchpoint macro.  */

static int
mips_can_use_watchpoint (int type, int cnt, int othertype)
{
  return cnt < MAX_LSI_BREAKPOINTS && strcmp (target_shortname, "lsi") == 0;
}


/* Compute a don't care mask for the region bounding ADDR and ADDR + LEN - 1.
   This is used for memory ref breakpoints.  */

static unsigned long
calculate_mask (CORE_ADDR addr, int len)
{
  unsigned long mask;
  int i;

  mask = addr ^ (addr + len - 1);

  for (i = 32; i >= 0; i--)
    if (mask == 0)
      break;
    else
      mask >>= 1;

  mask = (unsigned long) 0xffffffff >> i;

  return mask;
}


/* Set a data watchpoint.  ADDR and LEN should be obvious.  TYPE is 0
   for a write watchpoint, 1 for a read watchpoint, or 2 for a read/write
   watchpoint.  */

static int
mips_insert_watchpoint (CORE_ADDR addr, int len, int type,
			struct expression *cond)
{
  if (mips_set_breakpoint (addr, len, type))
    return -1;

  return 0;
}

/* Remove a watchpoint.  */

static int
mips_remove_watchpoint (CORE_ADDR addr, int len, int type,
			struct expression *cond)
{
  if (mips_clear_breakpoint (addr, len, type))
    return -1;

  return 0;
}

/* Test to see if a watchpoint has been hit.  Return 1 if so; return 0,
   if not.  */

static int
mips_stopped_by_watchpoint (void)
{
  return hit_watchpoint;
}


/* Insert a breakpoint.  */

static int
mips_set_breakpoint (CORE_ADDR addr, int len, enum break_type type)
{
  return mips_common_breakpoint (1, addr, len, type);
}


/* Clear a breakpoint.  */

static int
mips_clear_breakpoint (CORE_ADDR addr, int len, enum break_type type)
{
  return mips_common_breakpoint (0, addr, len, type);
}


/* Check the error code from the return packet for an LSI breakpoint
   command.  If there's no error, just return 0.  If it's a warning,
   print the warning text and return 0.  If it's an error, print
   the error text and return 1.  <ADDR> is the address of the breakpoint
   that was being set.  <RERRFLG> is the error code returned by PMON.
   This is a helper function for mips_common_breakpoint.  */

static int
mips_check_lsi_error (CORE_ADDR addr, int rerrflg)
{
  struct lsi_error *err;
  const char *saddr = paddress (target_gdbarch (), addr);

  if (rerrflg == 0)		/* no error */
    return 0;

  /* Warnings can be ORed together, so check them all.  */
  if (rerrflg & W_WARN)
    {
      if (monitor_warnings)
	{
	  int found = 0;

	  for (err = lsi_warning_table; err->code != 0; err++)
	    {
	      if ((err->code & rerrflg) == err->code)
		{
		  found = 1;
		  fprintf_unfiltered (gdb_stderr, "\
mips_common_breakpoint (%s): Warning: %s\n",
				      saddr,
				      err->string);
		}
	    }
	  if (!found)
	    fprintf_unfiltered (gdb_stderr, "\
mips_common_breakpoint (%s): Unknown warning: 0x%x\n",
				saddr,
				rerrflg);
	}
      return 0;
    }

  /* Errors are unique, i.e. can't be ORed together.  */
  for (err = lsi_error_table; err->code != 0; err++)
    {
      if ((err->code & rerrflg) == err->code)
	{
	  fprintf_unfiltered (gdb_stderr, "\
mips_common_breakpoint (%s): Error: %s\n",
			      saddr,
			      err->string);
	  return 1;
	}
    }
  fprintf_unfiltered (gdb_stderr, "\
mips_common_breakpoint (%s): Unknown error: 0x%x\n",
		      saddr,
		      rerrflg);
  return 1;
}


/* This routine sends a breakpoint command to the remote target.

   <SET> is 1 if setting a breakpoint, or 0 if clearing a breakpoint.
   <ADDR> is the address of the breakpoint.
   <LEN> the length of the region to break on.
   <TYPE> is the type of breakpoint:
   0 = write                    (BREAK_WRITE)
   1 = read                     (BREAK_READ)
   2 = read/write               (BREAK_ACCESS)
   3 = instruction fetch        (BREAK_FETCH)

   Return 0 if successful; otherwise 1.  */

static int
mips_common_breakpoint (int set, CORE_ADDR addr, int len, enum break_type type)
{
  int addr_size = gdbarch_addr_bit (target_gdbarch ()) / 8;
  char buf[DATA_MAXLEN + 1];
  char cmd, rcmd;
  int rpid, rerrflg, rresponse, rlen;
  int nfields;

  addr = gdbarch_addr_bits_remove (target_gdbarch (), addr);

  if (mips_monitor == MON_LSI)
    {
      if (set == 0)		/* clear breakpoint */
	{
	  /* The LSI PMON "clear breakpoint" has this form:
	     <pid> 'b' <bptn> 0x0
	     reply:
	     <pid> 'b' 0x0 <code>

	     <bptn> is a breakpoint number returned by an earlier 'B' command.
	     Possible return codes: OK, E_BPT.  */

	  int i;

	  /* Search for the breakpoint in the table.  */
	  for (i = 0; i < MAX_LSI_BREAKPOINTS; i++)
	    if (lsi_breakpoints[i].type == type
		&& lsi_breakpoints[i].addr == addr
		&& lsi_breakpoints[i].len == len)
	      break;

	  /* Clear the table entry and tell PMON to clear the breakpoint.  */
	  if (i == MAX_LSI_BREAKPOINTS)
	    {
	      warning (_("\
mips_common_breakpoint: Attempt to clear bogus breakpoint at %s"),
		       paddress (target_gdbarch (), addr));
	      return 1;
	    }

	  lsi_breakpoints[i].type = BREAK_UNUSED;
	  sprintf (buf, "0x0 b 0x%x 0x0", i);
	  mips_send_packet (buf, 1);

	  rlen = mips_receive_packet (buf, 1, mips_receive_wait);
	  buf[rlen] = '\0';

	  nfields = sscanf (buf, "0x%x b 0x0 0x%x", &rpid, &rerrflg);
	  if (nfields != 2)
	    mips_error (_("mips_common_breakpoint: "
			"Bad response from remote board: %s"),
			buf);

	  return (mips_check_lsi_error (addr, rerrflg));
	}
      else
	/* set a breakpoint */
	{
	  /* The LSI PMON "set breakpoint" command has this form:
	     <pid> 'B' <addr> 0x0
	     reply:
	     <pid> 'B' <bptn> <code>

	     The "set data breakpoint" command has this form:

	     <pid> 'A' <addr1> <type> [<addr2>  [<value>]]

	     where: type= "0x1" = read
	     "0x2" = write
	     "0x3" = access (read or write)

	     The reply returns two values:
	     bptn - a breakpoint number, which is a small integer with
	     possible values of zero through 255.
	     code - an error return code, a value of zero indicates a
	     succesful completion, other values indicate various
	     errors and warnings.

	     Possible return codes: OK, W_QAL, E_QAL, E_OUT, E_NON.  */

	  if (type == BREAK_FETCH)	/* instruction breakpoint */
	    {
	      cmd = 'B';
	      sprintf (buf, "0x0 B 0x%s 0x0", phex_nz (addr, addr_size));
	    }
	  else
	    /* watchpoint */
	    {
	      cmd = 'A';
	      sprintf (buf, "0x0 A 0x%s 0x%x 0x%s",
		       phex_nz (addr, addr_size),
		       type == BREAK_READ ? 1 : (type == BREAK_WRITE ? 2 : 3),
		       phex_nz (addr + len - 1, addr_size));
	    }
	  mips_send_packet (buf, 1);

	  rlen = mips_receive_packet (buf, 1, mips_receive_wait);
	  buf[rlen] = '\0';

	  nfields = sscanf (buf, "0x%x %c 0x%x 0x%x",
			    &rpid, &rcmd, &rresponse, &rerrflg);
	  if (nfields != 4 || rcmd != cmd || rresponse > 255)
	    mips_error (_("mips_common_breakpoint: "
			"Bad response from remote board: %s"),
			buf);

	  if (rerrflg != 0)
	    if (mips_check_lsi_error (addr, rerrflg))
	      return 1;

	  /* rresponse contains PMON's breakpoint number.  Record the
	     information for this breakpoint so we can clear it later.  */
	  lsi_breakpoints[rresponse].type = type;
	  lsi_breakpoints[rresponse].addr = addr;
	  lsi_breakpoints[rresponse].len = len;

	  return 0;
	}
    }
  else
    {
      /* On non-LSI targets, the breakpoint command has this form:
         0x0 <CMD> <ADDR> <MASK> <FLAGS>
         <MASK> is a don't care mask for addresses.
         <FLAGS> is any combination of `r', `w', or `f' for 
	 read/write/fetch.  */

      unsigned long mask;

      mask = calculate_mask (addr, len);
      addr &= ~mask;

      if (set)			/* set a breakpoint */
	{
	  char *flags;

	  switch (type)
	    {
	    case BREAK_WRITE:	/* write */
	      flags = "w";
	      break;
	    case BREAK_READ:	/* read */
	      flags = "r";
	      break;
	    case BREAK_ACCESS:	/* read/write */
	      flags = "rw";
	      break;
	    case BREAK_FETCH:	/* fetch */
	      flags = "f";
	      break;
	    default:
	      internal_error (__FILE__, __LINE__,
			      _("failed internal consistency check"));
	    }

	  cmd = 'B';
	  sprintf (buf, "0x0 B 0x%s 0x%s %s", phex_nz (addr, addr_size),
		   phex_nz (mask, addr_size), flags);
	}
      else
	{
	  cmd = 'b';
	  sprintf (buf, "0x0 b 0x%s", phex_nz (addr, addr_size));
	}

      mips_send_packet (buf, 1);

      rlen = mips_receive_packet (buf, 1, mips_receive_wait);
      buf[rlen] = '\0';

      nfields = sscanf (buf, "0x%x %c 0x%x 0x%x",
			&rpid, &rcmd, &rerrflg, &rresponse);

      if (nfields != 4 || rcmd != cmd)
	mips_error (_("mips_common_breakpoint: "
		    "Bad response from remote board: %s"),
		    buf);

      if (rerrflg != 0)
	{
	  /* Ddb returns "0x0 b 0x16 0x0\000", whereas
	     Cogent returns "0x0 b 0xffffffff 0x16\000": */
	  if (mips_monitor == MON_DDB)
	    rresponse = rerrflg;
	  if (rresponse != 22)	/* invalid argument */
	    fprintf_unfiltered (gdb_stderr, "\
mips_common_breakpoint (%s):  Got error: 0x%x\n",
				paddress (target_gdbarch (), addr), rresponse);
	  return 1;
	}
    }
  return 0;
}

/* Send one S record as specified by SREC of length LEN, starting
   at ADDR.  Note, however, that ADDR is not used except to provide
   a useful message to the user in the event that a NACK is received
   from the board.  */

static void
send_srec (char *srec, int len, CORE_ADDR addr)
{
  while (1)
    {
      int ch;

      serial_write (mips_desc, srec, len);

      ch = mips_readchar (remote_timeout);

      switch (ch)
	{
	case SERIAL_TIMEOUT:
	  error (_("Timeout during download."));
	  break;
	case 0x6:		/* ACK */
	  return;
	case 0x15:		/* NACK */
	  fprintf_unfiltered (gdb_stderr,
			      "Download got a NACK at byte %s!  Retrying.\n",
			      paddress (target_gdbarch (), addr));
	  continue;
	default:
	  error (_("Download got unexpected ack char: 0x%x, retrying."),
		 ch);
	}
    }
}

/*  Download a binary file by converting it to S records.  */

static void
mips_load_srec (char *args)
{
  bfd *abfd;
  asection *s;
  char srec[1024];
  bfd_byte *buffer;
  unsigned int i;
  unsigned int srec_frame = 200;
  int reclen;
  struct cleanup *cleanup;
  static int hashmark = 1;

  buffer = alloca (srec_frame * 2 + 256);

  abfd = gdb_bfd_open (args, NULL, -1);
  if (!abfd)
    {
      printf_filtered ("Unable to open file %s\n", args);
      return;
    }

  cleanup = make_cleanup_bfd_unref (abfd);
  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      do_cleanups (cleanup);
      return;
    }

/* This actually causes a download in the IDT binary format: */
  mips_send_command (LOAD_CMD, 0);

  for (s = abfd->sections; s; s = s->next)
    {
      if (s->flags & SEC_LOAD)
	{
	  unsigned int numbytes;

	  /* FIXME!  vma too small?????  */
	  printf_filtered ("%s\t: 0x%4lx .. 0x%4lx  ", s->name,
			   (long) s->vma,
			   (long) (s->vma + bfd_get_section_size (s)));
	  gdb_flush (gdb_stdout);

	  for (i = 0; i < bfd_get_section_size (s); i += numbytes)
	    {
	      numbytes = min (srec_frame, bfd_get_section_size (s) - i);

	      bfd_get_section_contents (abfd, s, buffer, i, numbytes);

	      reclen = mips_make_srec (srec, '3', s->vma + i, 
				       buffer, numbytes);
	      send_srec (srec, reclen, s->vma + i);

	      if (deprecated_ui_load_progress_hook)
		deprecated_ui_load_progress_hook (s->name, i);

	      if (hashmark)
		{
		  putchar_unfiltered ('#');
		  gdb_flush (gdb_stdout);
		}

	    }			/* Per-packet (or S-record) loop */

	  putchar_unfiltered ('\n');
	}			/* Loadable sections */
    }
  if (hashmark)
    putchar_unfiltered ('\n');

  /* Write a type 7 terminator record. no data for a type 7, and there
     is no data, so len is 0.  */

  reclen = mips_make_srec (srec, '7', abfd->start_address, NULL, 0);

  send_srec (srec, reclen, abfd->start_address);

  serial_flush_input (mips_desc);
  do_cleanups (cleanup);
}

/*
 * mips_make_srec -- make an srecord.  This writes each line, one at a
 *      time, each with it's own header and trailer line.
 *      An srecord looks like this:
 *
 * byte count-+     address
 * start ---+ |        |       data        +- checksum
 *          | |        |                   |
 *        S01000006F6B692D746573742E73726563E4
 *        S315000448600000000000000000FC00005900000000E9
 *        S31A0004000023C1400037DE00F023604000377B009020825000348D
 *        S30B0004485A0000000000004E
 *        S70500040000F6
 *
 *      S<type><length><address><data><checksum>
 *
 *      Where
 *      - length
 *        is the number of bytes following upto the checksum.  Note that
 *        this is not the number of chars following, since it takes two
 *        chars to represent a byte.
 *      - type
 *        is one of:
 *        0) header record
 *        1) two byte address data record
 *        2) three byte address data record
 *        3) four byte address data record
 *        7) four byte address termination record
 *        8) three byte address termination record
 *        9) two byte address termination record
 *       
 *      - address
 *        is the start address of the data following, or in the case of
 *        a termination record, the start address of the image
 *      - data
 *        is the data.
 *      - checksum
 *        is the sum of all the raw byte data in the record, from the length
 *        upwards, modulo 256 and subtracted from 255.
 *
 * This routine returns the length of the S-record.
 *
 */

static int
mips_make_srec (char *buf, int type, CORE_ADDR memaddr, unsigned char *myaddr,
		int len)
{
  unsigned char checksum;
  int i;

  /* Create the header for the srec.  addr_size is the number of bytes
     in the address, and 1 is the number of bytes in the count.  */

  /* FIXME!! bigger buf required for 64-bit!  */
  buf[0] = 'S';
  buf[1] = type;
  buf[2] = len + 4 + 1;		/* len + 4 byte address + 1 byte checksum */
  /* This assumes S3 style downloads (4byte addresses).  There should
     probably be a check, or the code changed to make it more
     explicit.  */
  buf[3] = memaddr >> 24;
  buf[4] = memaddr >> 16;
  buf[5] = memaddr >> 8;
  buf[6] = memaddr;
  memcpy (&buf[7], myaddr, len);

  /* Note that the checksum is calculated on the raw data, not the
     hexified data.  It includes the length, address and the data
     portions of the packet.  */
  checksum = 0;
  buf += 2;			/* Point at length byte.  */
  for (i = 0; i < len + 4 + 1; i++)
    checksum += *buf++;

  *buf = ~checksum;

  return len + 8;
}

/* The following manifest controls whether we enable the simple flow
   control support provided by the monitor.  If enabled the code will
   wait for an affirmative ACK between transmitting packets.  */
#define DOETXACK (1)

/* The PMON fast-download uses an encoded packet format constructed of
   3byte data packets (encoded as 4 printable ASCII characters), and
   escape sequences (preceded by a '/'):

   'K'     clear checksum
   'C'     compare checksum (12bit value, not included in checksum calculation)
   'S'     define symbol name (for addr) terminated with ","
           and padded to 4char boundary
   'Z'     zero fill multiple of 3bytes
   'B'     byte (12bit encoded value, of 8bit data)
   'A'     address (36bit encoded value)
   'E'     define entry as original address, and exit load

   The packets are processed in 4 character chunks, so the escape
   sequences that do not have any data (or variable length data)
   should be padded to a 4 character boundary.  The decoder will give
   an error if the complete message block size is not a multiple of
   4bytes (size of record).

   The encoding of numbers is done in 6bit fields.  The 6bit value is
   used to index into this string to get the specific character
   encoding for the value: */
static char encoding[] =
  "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,.";

/* Convert the number of bits required into an encoded number, 6bits
   at a time (range 0..63).  Keep a checksum if required (passed
   pointer non-NULL).  The function returns the number of encoded
   characters written into the buffer.  */

static int
pmon_makeb64 (unsigned long v, char *p, int n, unsigned int *chksum)
{
  int count = (n / 6);

  if ((n % 12) != 0)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Fast encoding bitcount must be a "
			  "multiple of 12bits: %dbit%s\n",
			  n, (n == 1) ? "" : "s");
      return (0);
    }
  if (n > 36)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Fast encoding cannot process more "
			  "than 36bits at the moment: %dbits\n", n);
      return (0);
    }

  /* Deal with the checksum: */
  if (chksum != NULL)
    {
      switch (n)
	{
	case 36:
	  *chksum += ((v >> 24) & 0xFFF);
	case 24:
	  *chksum += ((v >> 12) & 0xFFF);
	case 12:
	  *chksum += ((v >> 0) & 0xFFF);
	}
    }

  do
    {
      n -= 6;
      *p++ = encoding[(v >> n) & 0x3F];
    }
  while (n > 0);

  return (count);
}

/* Shorthand function (that could be in-lined) to output the zero-fill
   escape sequence into the data stream.  */

static int
pmon_zeroset (int recsize, char **buff,
	      unsigned int *amount, unsigned int *chksum)
{
  int count;

  sprintf (*buff, "/Z");
  count = pmon_makeb64 (*amount, (*buff + 2), 12, chksum);
  *buff += (count + 2);
  *amount = 0;
  return (recsize + count + 2);
}

/* Add the checksum specified by *VALUE to end of the record under
   construction.  *BUF specifies the location at which to begin
   writing characters comprising the checksum information.  RECSIZE
   specifies the size of the record constructed thus far.  (A trailing
   NUL character may be present in the buffer holding the record, but
   the record size does not include this character.)

   Return the total size of the record after adding the checksum escape,
   the checksum itself, and the trailing newline.
   
   The checksum specified by *VALUE is zeroed out prior to returning.
   Additionally, *BUF is updated to refer to the location just beyond
   the record elements added by this call.  */

static int
pmon_checkset (int recsize, char **buff, unsigned int *value)
{
  int count;

  /* Add the checksum (without updating the value): */
  sprintf (*buff, "/C");
  count = pmon_makeb64 (*value, (*buff + 2), 12, NULL);
  *buff += (count + 2);
  sprintf (*buff, "\n");
  *buff += 2;			/* Include zero terminator.  */
  /* Forcing a checksum validation clears the sum: */
  *value = 0;
  return (recsize + count + 3);
}

/* Amount of padding we leave after at the end of the output buffer,
   for the checksum and line termination characters: */
#define CHECKSIZE (4 + 4 + 4 + 2)
/* zero-fill, checksum, transfer end and line termination space.  */

/* The amount of binary data loaded from the object file in a single
   operation: */
#define BINCHUNK (1024)

/* Maximum line of data accepted by the monitor: */
#define MAXRECSIZE (550)
/* NOTE: This constant depends on the monitor being used.  This value
   is for PMON 5.x on the Cogent Vr4300 board.  */

/* Create a FastLoad format record.

   *OUTBUF is the buffer into which a FastLoad formatted record is
   written.  On return, the pointer position represented by *OUTBUF
   is updated to point at the end of the data, i.e. the next position
   in the buffer that may be written.  No attempt is made to NUL-
   terminate this portion of the record written to the buffer.
   
   INBUF contains the binary input data from which the FastLoad
   formatted record will be built.  *INPTR is an index into this
   buffer.  *INPTR is updated as the input is consumed.  Thus, on
   return, the caller has access to the position of the next input
   byte yet to be processed.  INAMOUNT is the size, in bytes, of the
   input data.

   *RECSIZE will be written with the size of the record written to the
   output buffer prior to returning.  This size does not include a
   NUL-termination byte as none is written to the output buffer.

   *CSUM is the output buffer checksum.  It is updated as data is
   written to the output buffer.
   
   *ZEROFILL is the current number of 3-byte zero sequences that have
   been encountered.  It is both an input and an output to this
   function.  */

static void
pmon_make_fastrec (char **outbuf, unsigned char *inbuf, int *inptr,
		   int inamount, int *recsize, unsigned int *csum,
		   unsigned int *zerofill)
{
  int count = 0;
  char *p = *outbuf;

  /* This is a simple check to ensure that our data will fit within
     the maximum allowable record size.  Each record output is 4bytes
     in length.  We must allow space for a pending zero fill command,
     the record, and a checksum record.  */
  while ((*recsize < (MAXRECSIZE - CHECKSIZE)) && ((inamount - *inptr) > 0))
    {
      /* Process the binary data: */
      if ((inamount - *inptr) < 3)
	{
	  if (*zerofill != 0)
	    *recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
	  sprintf (p, "/B");
	  count = pmon_makeb64 (inbuf[*inptr], &p[2], 12, csum);
	  p += (2 + count);
	  *recsize += (2 + count);
	  (*inptr)++;
	}
      else
	{
	  unsigned int value = ((inbuf[*inptr + 0] << 16)
				| (inbuf[*inptr + 1] << 8)
				| (inbuf[*inptr + 2]));

	  /* Simple check for zero data.  TODO: A better check would be
	     to check the last, and then the middle byte for being zero
	     (if the first byte is not).  We could then check for
	     following runs of zeros, and if above a certain size it is
	     worth the 4 or 8 character hit of the byte insertions used
	     to pad to the start of the zeroes.  NOTE: This also depends
	     on the alignment at the end of the zero run.  */
	  if (value == 0x00000000)
	    {
	      (*zerofill)++;
	      if (*zerofill == 0xFFF)	/* 12bit counter */
		*recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
	    }
	  else
	    {
	      if (*zerofill != 0)
		*recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
	      count = pmon_makeb64 (value, p, 24, csum);
	      p += count;
	      *recsize += count;
	    }
	  *inptr += 3;
	}
    }

  *outbuf = p;
  return;
}

/* Attempt to read an ACK.  If an ACK is not read in a timely manner,
   output the message specified by MESG.  Return -1 for failure, 0
   for success.  */

static int
pmon_check_ack (char *mesg)
{
#if defined(DOETXACK)
  int c;

  if (!tftp_in_use)
    {
      c = serial_readchar (udp_in_use ? udp_desc : mips_desc,
			   remote_timeout);
      if ((c == SERIAL_TIMEOUT) || (c != 0x06))
	{
	  fprintf_unfiltered (gdb_stderr,
			      "Failed to receive valid ACK for %s\n", mesg);
	  return (-1);		/* Terminate the download.  */
	}
    }
#endif /* DOETXACK */
  return (0);
}

/* pmon_download - Send a sequence of characters to the PMON download port,
   which is either a serial port or a UDP socket.  */

static void
pmon_start_download (void)
{
  if (tftp_in_use)
    {
      /* Create the temporary download file.  */
      if ((tftp_file = fopen (tftp_localname, "w")) == NULL)
	perror_with_name (tftp_localname);
    }
  else
    {
      mips_send_command (udp_in_use ? LOAD_CMD_UDP : LOAD_CMD, 0);
      mips_expect ("Downloading from ");
      mips_expect (udp_in_use ? "udp" : "tty0");
      mips_expect (", ^C to abort\r\n");
    }
}

/* Look for the string specified by STRING sent from the target board
   during a download operation.  If the string in question is not
   seen, output an error message, remove the temporary file, if
   appropriate, and return 0.  Otherwise, return 1 to indicate
   success.  */

static int
mips_expect_download (char *string)
{
  if (!mips_expect (string))
    {
      fprintf_unfiltered (gdb_stderr, "Load did not complete successfully.\n");
      if (tftp_in_use)
	remove (tftp_localname);	/* Remove temporary file.  */
      return 0;
    }
  else
    return 1;
}

/* Look for messages from the target board associated with the entry
   address.

   NOTE: This function doesn't indicate success or failure, so we
   have no way to determine whether or not the output from the board
   was correctly seen.  However, given that other items are checked
   after this, it seems unlikely that those checks will pass if this
   check doesn't first (silently) pass.  */

static void
pmon_check_entry_address (char *entry_address, int final)
{
  char hexnumber[9];		/* Includes '\0' space.  */

  mips_expect_timeout (entry_address, tftp_in_use ? 15 : remote_timeout);
  sprintf (hexnumber, "%x", final);
  mips_expect (hexnumber);
  mips_expect ("\r\n");
}

/* Look for messages from the target board showing the total number of
   bytes downloaded to the board.  Output 1 for success if the tail
   end of the message was read correctly, 0 otherwise.  */

static int
pmon_check_total (int bintotal)
{
  char hexnumber[9];		/* Includes '\0' space.  */

  mips_expect ("\r\ntotal = 0x");
  sprintf (hexnumber, "%x", bintotal);
  mips_expect (hexnumber);
  return mips_expect_download (" bytes\r\n");
}

/* Look for the termination messages associated with the end of
   a download to the board.

   Also, when `tftp_in_use' is set, issue the load command to the
   board causing the file to be transferred.  (This is done prior
   to looking for the above mentioned termination messages.)  */
   
static void
pmon_end_download (int final, int bintotal)
{
  char hexnumber[9];		/* Includes '\0' space.  */

  if (tftp_in_use)
    {
      static char *load_cmd_prefix = "load -b -s ";
      char *cmd;
      struct stat stbuf;

      /* Close off the temporary file containing the load data.  */
      fclose (tftp_file);
      tftp_file = NULL;

      /* Make the temporary file readable by the world.  */
      if (stat (tftp_localname, &stbuf) == 0)
	chmod (tftp_localname, stbuf.st_mode | S_IROTH);

      /* Must reinitialize the board to prevent PMON from crashing.  */
      if (mips_monitor != MON_ROCKHOPPER)
	mips_send_command ("initEther\r", -1);

      /* Send the load command.  */
      cmd = xmalloc (strlen (load_cmd_prefix) + strlen (tftp_name) + 2);
      strcpy (cmd, load_cmd_prefix);
      strcat (cmd, tftp_name);
      strcat (cmd, "\r");
      mips_send_command (cmd, 0);
      xfree (cmd);
      if (!mips_expect_download ("Downloading from "))
	return;
      if (!mips_expect_download (tftp_name))
	return;
      if (!mips_expect_download (", ^C to abort\r\n"))
	return;
    }

  /* Wait for the stuff that PMON prints after the load has completed.
     The timeout value for use in the tftp case (15 seconds) was picked
     arbitrarily but might be too small for really large downloads.  FIXME.  */
  switch (mips_monitor)
    {
    case MON_LSI:
      pmon_check_ack ("termination");
      pmon_check_entry_address ("Entry address is ", final);
      if (!pmon_check_total (bintotal))
	return;
      break;
    case MON_ROCKHOPPER:
      if (!pmon_check_total (bintotal))
	return;
      pmon_check_entry_address ("Entry Address  = ", final);
      break;
    default:
      pmon_check_entry_address ("Entry Address  = ", final);
      pmon_check_ack ("termination");
      if (!pmon_check_total (bintotal))
	return;
      break;
    }

  if (tftp_in_use)
    remove (tftp_localname);	/* Remove temporary file.  */
}

/* Write the buffer specified by BUFFER of length LENGTH to either
   the board or the temporary file that'll eventually be transferred
   to the board.  */

static void
pmon_download (char *buffer, int length)
{
  if (tftp_in_use)
    {
      size_t written;

      written = fwrite (buffer, 1, length, tftp_file);
      if (written < length)
	perror_with_name (tftp_localname);
    }
  else
    serial_write (udp_in_use ? udp_desc : mips_desc, buffer, length);
}

/* Open object or executable file, FILE, and send it to the board
   using the FastLoad format.  */

static void
pmon_load_fast (char *file)
{
  bfd *abfd;
  asection *s;
  unsigned char *binbuf;
  char *buffer;
  int reclen;
  unsigned int csum = 0;
  int hashmark = !tftp_in_use;
  int bintotal = 0;
  int final = 0;
  int finished = 0;
  struct cleanup *cleanup;

  buffer = (char *) xmalloc (MAXRECSIZE + 1);
  binbuf = (unsigned char *) xmalloc (BINCHUNK);

  abfd = gdb_bfd_open (file, NULL, -1);
  if (!abfd)
    {
      printf_filtered ("Unable to open file %s\n", file);
      return;
    }
  cleanup = make_cleanup_bfd_unref (abfd);

  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      do_cleanups (cleanup);
      return;
    }

  /* Setup the required download state: */
  mips_send_command ("set dlproto etxack\r", -1);
  mips_send_command ("set dlecho off\r", -1);
  /* NOTE: We get a "cannot set variable" message if the variable is
     already defined to have the argument we give.  The code doesn't
     care, since it just scans to the next prompt anyway.  */
  /* Start the download: */
  pmon_start_download ();

  /* Zero the checksum.  */
  sprintf (buffer, "/Kxx\n");
  reclen = strlen (buffer);
  pmon_download (buffer, reclen);
  finished = pmon_check_ack ("/Kxx");

  for (s = abfd->sections; s && !finished; s = s->next)
    if (s->flags & SEC_LOAD)	/* Only deal with loadable sections.  */
      {
	bintotal += bfd_get_section_size (s);
	final = (s->vma + bfd_get_section_size (s));

	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name,
			 (unsigned int) s->vma,
			 (unsigned int) (s->vma + bfd_get_section_size (s)));
	gdb_flush (gdb_stdout);

	/* Output the starting address.  */
	sprintf (buffer, "/A");
	reclen = pmon_makeb64 (s->vma, &buffer[2], 36, &csum);
	buffer[2 + reclen] = '\n';
	buffer[3 + reclen] = '\0';
	reclen += 3;	/* For the initial escape code and carriage return.  */
	pmon_download (buffer, reclen);
	finished = pmon_check_ack ("/A");

	if (!finished)
	  {
	    unsigned int binamount;
	    unsigned int zerofill = 0;
	    char *bp = buffer;
	    unsigned int i;

	    reclen = 0;

	    for (i = 0;
		 i < bfd_get_section_size (s) && !finished;
		 i += binamount)
	      {
		int binptr = 0;

		binamount = min (BINCHUNK, bfd_get_section_size (s) - i);

		bfd_get_section_contents (abfd, s, binbuf, i, binamount);

		/* This keeps a rolling checksum, until we decide to output
		   the line: */
		for (; ((binamount - binptr) > 0);)
		  {
		    pmon_make_fastrec (&bp, binbuf, &binptr, binamount, 
				       &reclen, &csum, &zerofill);
		    if (reclen >= (MAXRECSIZE - CHECKSIZE))
		      {
			reclen = pmon_checkset (reclen, &bp, &csum);
			pmon_download (buffer, reclen);
			finished = pmon_check_ack ("data record");
			if (finished)
			  {
			    zerofill = 0;	/* Do not transmit pending
						   zerofills.  */
			    break;
			  }

			if (deprecated_ui_load_progress_hook)
			  deprecated_ui_load_progress_hook (s->name, i);

			if (hashmark)
			  {
			    putchar_unfiltered ('#');
			    gdb_flush (gdb_stdout);
			  }

			bp = buffer;
			reclen = 0;	/* buffer processed */
		      }
		  }
	      }

	    /* Ensure no out-standing zerofill requests: */
	    if (zerofill != 0)
	      reclen = pmon_zeroset (reclen, &bp, &zerofill, &csum);

	    /* and then flush the line: */
	    if (reclen > 0)
	      {
		reclen = pmon_checkset (reclen, &bp, &csum);
		/* Currently pmon_checkset outputs the line terminator by
		   default, so we write out the buffer so far: */
		pmon_download (buffer, reclen);
		finished = pmon_check_ack ("record remnant");
	      }
	  }

	putchar_unfiltered ('\n');
      }

  /* Terminate the transfer.  We know that we have an empty output
     buffer at this point.  */
  sprintf (buffer, "/E/E\n");	/* Include dummy padding characters.  */
  reclen = strlen (buffer);
  pmon_download (buffer, reclen);

  if (finished)
    {				/* Ignore the termination message: */
      serial_flush_input (udp_in_use ? udp_desc : mips_desc);
    }
  else
    {				/* Deal with termination message: */
      pmon_end_download (final, bintotal);
    }

  do_cleanups (cleanup);
  return;
}

/* mips_load -- download a file.  */

static void
mips_load (char *file, int from_tty)
{
  struct regcache *regcache;

  /* Get the board out of remote debugging mode.  */
  if (mips_exit_debug ())
    error (_("mips_load:  Couldn't get into monitor mode."));

  if (mips_monitor != MON_IDT)
    pmon_load_fast (file);
  else
    mips_load_srec (file);

  mips_initialize ();

  /* Finally, make the PC point at the start address.  */
  regcache = get_current_regcache ();
  if (mips_monitor != MON_IDT)
    {
      /* Work around problem where PMON monitor updates the PC after a load
         to a different value than GDB thinks it has.  The following ensures
         that the regcache_write_pc() WILL update the PC value: */
      regcache_invalidate (regcache,
			   mips_regnum (get_regcache_arch (regcache))->pc);
    }
  if (exec_bfd)
    regcache_write_pc (regcache, bfd_get_start_address (exec_bfd));
}

/* Check to see if a thread is still alive.  */
 
static int
mips_thread_alive (struct target_ops *ops, ptid_t ptid)
{
  if (ptid_equal (ptid, remote_mips_ptid))
    /* The monitor's task is always alive.  */
    return 1;

  return 0;
}

/* Convert a thread ID to a string.  Returns the string in a static
   buffer.  */

static char *
mips_pid_to_str (struct target_ops *ops, ptid_t ptid)
{
  static char buf[64];

  if (ptid_equal (ptid, remote_mips_ptid))
    {
      xsnprintf (buf, sizeof buf, "Thread <main>");
      return buf;
    }

  return normal_pid_to_str (ptid);
}

/* Pass the command argument as a packet to PMON verbatim.  */

static void
pmon_command (char *args, int from_tty)
{
  char buf[DATA_MAXLEN + 1];
  int rlen;

  sprintf (buf, "0x0 %s", args);
  mips_send_packet (buf, 1);
  printf_filtered ("Send packet: %s\n", buf);

  rlen = mips_receive_packet (buf, 1, mips_receive_wait);
  buf[rlen] = '\0';
  printf_filtered ("Received packet: %s\n", buf);
}

/* -Wmissing-prototypes */
extern initialize_file_ftype _initialize_remote_mips;

/* Initialize mips_ops, lsi_ops, ddb_ops, pmon_ops, and rockhopper_ops.
   Create target specific commands and perform other initializations
   specific to this file.  */

void
_initialize_remote_mips (void)
{
  /* Initialize the fields in mips_ops that are common to all four targets.  */
  mips_ops.to_longname = "Remote MIPS debugging over serial line";
  mips_ops.to_close = mips_close;
  mips_ops.to_detach = mips_detach;
  mips_ops.to_resume = mips_resume;
  mips_ops.to_fetch_registers = mips_fetch_registers;
  mips_ops.to_store_registers = mips_store_registers;
  mips_ops.to_prepare_to_store = mips_prepare_to_store;
  mips_ops.deprecated_xfer_memory = mips_xfer_memory;
  mips_ops.to_files_info = mips_files_info;
  mips_ops.to_insert_breakpoint = mips_insert_breakpoint;
  mips_ops.to_remove_breakpoint = mips_remove_breakpoint;
  mips_ops.to_insert_watchpoint = mips_insert_watchpoint;
  mips_ops.to_remove_watchpoint = mips_remove_watchpoint;
  mips_ops.to_stopped_by_watchpoint = mips_stopped_by_watchpoint;
  mips_ops.to_can_use_hw_breakpoint = mips_can_use_watchpoint;
  mips_ops.to_kill = mips_kill;
  mips_ops.to_load = mips_load;
  mips_ops.to_create_inferior = mips_create_inferior;
  mips_ops.to_mourn_inferior = mips_mourn_inferior;
  mips_ops.to_thread_alive = mips_thread_alive;
  mips_ops.to_pid_to_str = mips_pid_to_str;
  mips_ops.to_log_command = serial_log_command;
  mips_ops.to_stratum = process_stratum;
  mips_ops.to_has_all_memory = default_child_has_all_memory;
  mips_ops.to_has_memory = default_child_has_memory;
  mips_ops.to_has_stack = default_child_has_stack;
  mips_ops.to_has_registers = default_child_has_registers;
  mips_ops.to_has_execution = default_child_has_execution;
  mips_ops.to_magic = OPS_MAGIC;

  /* Copy the common fields to all four target vectors.  */
  rockhopper_ops = pmon_ops = ddb_ops = lsi_ops = mips_ops;

  /* Initialize target-specific fields in the target vectors.  */
  mips_ops.to_shortname = "mips";
  mips_ops.to_doc = "\
Debug a board using the MIPS remote debugging protocol over a serial line.\n\
The argument is the device it is connected to or, if it contains a colon,\n\
HOST:PORT to access a board over a network";
  mips_ops.to_open = mips_open;
  mips_ops.to_wait = mips_wait;

  pmon_ops.to_shortname = "pmon";
  pmon_ops.to_doc = "\
Debug a board using the PMON MIPS remote debugging protocol over a serial\n\
line. The argument is the device it is connected to or, if it contains a\n\
colon, HOST:PORT to access a board over a network";
  pmon_ops.to_open = pmon_open;
  pmon_ops.to_wait = mips_wait;

  ddb_ops.to_shortname = "ddb";
  ddb_ops.to_doc = "\
Debug a board using the PMON MIPS remote debugging protocol over a serial\n\
line. The first argument is the device it is connected to or, if it contains\n\
a colon, HOST:PORT to access a board over a network.  The optional second\n\
parameter is the temporary file in the form HOST:FILENAME to be used for\n\
TFTP downloads to the board.  The optional third parameter is the local name\n\
of the TFTP temporary file, if it differs from the filename seen by the board.";
  ddb_ops.to_open = ddb_open;
  ddb_ops.to_wait = mips_wait;

  rockhopper_ops.to_shortname = "rockhopper";
  rockhopper_ops.to_doc = ddb_ops.to_doc;
  rockhopper_ops.to_open = rockhopper_open;
  rockhopper_ops.to_wait = mips_wait;

  lsi_ops.to_shortname = "lsi";
  lsi_ops.to_doc = pmon_ops.to_doc;
  lsi_ops.to_open = lsi_open;
  lsi_ops.to_wait = mips_wait;

  /* Add the targets.  */
  add_target (&mips_ops);
  add_target (&pmon_ops);
  add_target (&ddb_ops);
  add_target (&lsi_ops);
  add_target (&rockhopper_ops);

  add_setshow_zinteger_cmd ("timeout", no_class, &mips_receive_wait, _("\
Set timeout in seconds for remote MIPS serial I/O."), _("\
Show timeout in seconds for remote MIPS serial I/O."), NULL,
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);

  add_setshow_zinteger_cmd ("retransmit-timeout", no_class,
			    &mips_retransmit_wait, _("\
Set retransmit timeout in seconds for remote MIPS serial I/O."), _("\
Show retransmit timeout in seconds for remote MIPS serial I/O."), _("\
This is the number of seconds to wait for an acknowledgement to a packet\n\
before resending the packet."),
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);

  add_setshow_zinteger_cmd ("syn-garbage-limit", no_class,
			    &mips_syn_garbage,  _("\
Set the maximum number of characters to ignore when scanning for a SYN."), _("\
Show the maximum number of characters to ignore when scanning for a SYN."), _("\
This is the maximum number of characters GDB will ignore when trying to\n\
synchronize with the remote system.  A value of -1 means that there is no\n\
limit. (Note that these characters are printed out even though they are\n\
ignored.)"),
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);

  add_setshow_string_cmd ("monitor-prompt", class_obscure,
			  &mips_monitor_prompt, _("\
Set the prompt that GDB expects from the monitor."), _("\
Show the prompt that GDB expects from the monitor."), NULL,
			  NULL,
			  NULL, /* FIXME: i18n: */
			  &setlist, &showlist);

  add_setshow_zinteger_cmd ("monitor-warnings", class_obscure,
			    &monitor_warnings, _("\
Set printing of monitor warnings."), _("\
Show printing of monitor warnings."), _("\
When enabled, monitor warnings about hardware breakpoints will be displayed."),
			    NULL,
			    NULL, /* FIXME: i18n: */
			    &setlist, &showlist);

  add_com ("pmon", class_obscure, pmon_command,
	   _("Send a packet to PMON (must be in debug mode)."));

  add_setshow_boolean_cmd ("mask-address", no_class, &mask_address_p, _("\
Set zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets."), _("\
Show zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets."), _("\
Use \"on\" to enable the masking and \"off\" to disable it."),
			   NULL,
			   NULL, /* FIXME: i18n: */
			   &setlist, &showlist);
  remote_mips_ptid = ptid_build (42000, 0, 42000);
}
@


1.145
log
@Remove deprecated_throw_reason from mips_error.

  http://sourceware.org/ml/gdb-patches/2013-07/msg00777.html

gdb/ChangeLog

        * remote-mips.c (mips_error): Replace use of
        deprecated_throw_reason with throw_verror.  Use the error message
        passed to mips_error as the error message for throw_verror.
@
text
@d1664 1
a1664 1
  print_stack_frame (get_selected_frame (NULL), 0, SRC_AND_LOC);
@


1.144
log
@Replace most uses of deprecated_throw_reason with quit.

  http://sourceware.org/ml/gdb-patches/2013-07/msg00778.html

gdb/ChangeLog

        * monitor.c (monitor_interrupt_query): Replace use of
        deprecated_throw_reason with quit.
        * nto-procfs.c (interrupt_query): Likewise.
        * remote-fileio.c (remote_fileio_sig_exit): Likewise.
        * remote-mips.c (mips_kill): Likewise.
        * remote.c (interrupt_query): Likewise.
@
text
@d491 1
a491 2

  va_start (args, string);
a495 5
  if (error_pre_print)
    fputs_filtered (error_pre_print, gdb_stderr);
  vfprintf_filtered (gdb_stderr, string, args);
  fprintf_filtered (gdb_stderr, "\n");
  va_end (args);
a502 1
  printf_unfiltered ("Ending remote MIPS debugging.\n");
d506 7
a512 1
  deprecated_throw_reason (RETURN_ERROR);
@


1.143
log
@remove pop_target

This patch fixes the target double-close problem (PR remote/15266),
and in the process removes pop_target entire (PR remote/15256).

The first issue is that pop_target calls target_close.  However, it
then calls unpush_target, which also calls target_close.  This means
targets must be able to be closed twice.  Not only is this strange,
but it also directly contradicts the contract of to_xclose targets.
(We currently have just a single such target, and it is never pushed;
but I plan to add more, and so this latent bug is triggered.)

The second issue is that it seems to me that calling pop_target is
often unsafe.  This is what cropped up in 15256, where the remote
target assumed that it could pop_target -- but there was another
target higher on the stack, leading to confusion.

But, it is always just as easy to call unpush_target as it is to call
pop_target; and it is also safer.  So, removing pop_target seemed like
an improvement.

Finally, this adds an assertion to target_close to ensure that no
currently-pushed target can be closed.

Built and regtested on x86-64 Fedora 18; both natively and using the
native-gdbserver board file.

	PR remote/15256, PR remote/15266:
	* bfd-target.c (target_bfd_reopen): Initialize to_magic.
	* monitor.c (monitor_detach): Use unpush_target.
	* remote-m32r-sdi.c (m32r_detach): Use unpush_target.
	* remote-mips.c (mips_detach): Use unpush_target.  Don't
	call mips_close.
	* remote-sim.c (gdbsim_detach): Use unpush_target.
	* target.c (pop_target): Remove.
	(pop_all_targets_above): Don't call target_close.
	(target_close): Assert that the target is unpushed.
	* target.h (pop_target): Don't declare.
	* tracepoint.c (tfile_open): Use unpush_target.
@
text
@d2294 1
a2294 2

	  deprecated_throw_reason (RETURN_QUIT);
@


1.142
log
@cleanup fixes for remote-mips.c

remote-mips.c has a few 'return's where cleanups are not run.

	* remote-mips.c (mips_exit_debug): Call do_cleanups on all
	return paths.
	(mips_initialize): Likewise.
	(common_open): Call do_cleanups.
@
text
@d1758 1
a1758 3
  pop_target ();

  mips_close ();
@


1.141
log
@-Wpointer-sign: remote-mips.c.

remote-mips.c has a bunch of -Wpointer-sign warnings:

../../src/gdb/remote-mips.c: In function ‘mips_receive_packet’:
../../src/gdb/remote-mips.c:1128:7: error: pointer targets in passing argument 2 of ‘mips_cksum’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:830:1: note: expected ‘const unsigned char *’ but argument is of type ‘char *’
../../src/gdb/remote-mips.c:1135:7: error: pointer targets in passing argument 2 of ‘mips_cksum’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:830:1: note: expected ‘const unsigned char *’ but argument is of type ‘char *’
../../src/gdb/remote-mips.c: In function ‘mips_load_srec’:
../../src/gdb/remote-mips.c:2830:12: error: pointer targets in passing argument 4 of ‘mips_make_srec’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:134:12: note: expected ‘unsigned char *’ but argument is of type ‘char *’
../../src/gdb/remote-mips.c: In function ‘pmon_zeroset’:
../../src/gdb/remote-mips.c:3030:3: error: pointer targets in passing argument 4 of ‘pmon_makeb64’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:2977:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c: In function ‘pmon_make_fastrec’:
../../src/gdb/remote-mips.c:3124:6: error: pointer targets in passing argument 3 of ‘pmon_zeroset’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:3025:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c:3126:4: error: pointer targets in passing argument 4 of ‘pmon_makeb64’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:2977:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c:3148:3: error: pointer targets in passing argument 3 of ‘pmon_zeroset’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:3025:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c:3153:3: error: pointer targets in passing argument 3 of ‘pmon_zeroset’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:3025:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c:3154:8: error: pointer targets in passing argument 4 of ‘pmon_makeb64’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:2977:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c: In function ‘pmon_load_fast’:
../../src/gdb/remote-mips.c:3423:2: error: pointer targets in passing argument 4 of ‘pmon_makeb64’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:2977:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c:3457:4: error: pointer targets in passing argument 3 of ‘pmon_checkset’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:3051:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c:3484:8: error: pointer targets in passing argument 3 of ‘pmon_zeroset’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:3025:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’
../../src/gdb/remote-mips.c:3489:3: error: pointer targets in passing argument 3 of ‘pmon_checkset’ differ in signedness [-Werror=pointer-sign]
../../src/gdb/remote-mips.c:3051:1: note: expected ‘int *’ but argument is of type ‘unsigned int *’

The mips packet payload is ASCII, so it makes sense for
mips_send_packet and mips_receive_packet to expose 'char *'-based
interfaces, as currently they do.  But, mips packets have a binary
header, so if you look at e.g., mips_receive_packet's implementation,
you'll see "unsigned char" buffers in use.  I find it the most natural
to make the payload pointer passed to mips_cksum 'char *' too.

The other changes are straightforward adjustments -- a checksum is
naturally unsigned, and there's one point where we're reading a bfd section.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* remote-mips.c (mips_cksum): Rename 'data' parameter to 'datastr'
	and change its type to 'const char *'.  Adjust.
	(mips_send_packet): Add cast to 'char *', and remove cast to
	'unsigned char *'.
	(mips_receive_packet): Remove cast to 'unsigned char *'.
	(mips_load_srec): Use bfd_byte.
	(pmon_makeb64, pmon_zeroset): Make 'chksum' parameter unsigned.
	(pmon_checkset): Make 'value' parameter unsigned.
@
text
@d1389 4
a1392 1
	return -1;
d1398 4
a1401 1
    return -1;
d1415 1
a1415 1
  struct cleanup *old_cleanups = make_cleanup (mips_initialize_cleanups, NULL);
d1428 2
d1554 1
d1570 1
a1570 1
  make_cleanup_freeargv (argv);
d1667 2
@


1.140
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d66 1
a66 1
		       const unsigned char *data, int len);
d111 1
a111 1
static int pmon_makeb64 (unsigned long v, char *p, int n, int *chksum);
d113 1
a113 1
static int pmon_zeroset (int recsize, char **buff, int *amount,
d116 1
a116 1
static int pmon_checkset (int recsize, char **buff, int *value);
d827 1
a827 1
   DATA points to the packet data.  LEN is the length of DATA.  */
d830 1
a830 1
mips_cksum (const unsigned char *hdr, const unsigned char *data, int len)
d833 1
d876 1
a876 1
  cksum = mips_cksum (packet, packet + HDR_LENGTH, len);
d980 1
a980 2
	  if (mips_cksum (hdr, (unsigned char *) NULL, 0)
	      != TRLR_GET_CKSUM (trlr))
d1145 1
a1145 1
      cksum = mips_cksum (ack, (unsigned char *) NULL, 0);
d1186 1
a1186 1
  cksum = mips_cksum (ack, (unsigned char *) NULL, 0);
d2784 2
a2785 1
  char *buffer, srec[1024];
d2978 1
a2978 1
pmon_makeb64 (unsigned long v, char *p, int n, int *chksum)
d3026 2
a3027 1
pmon_zeroset (int recsize, char **buff, int *amount, unsigned int *chksum)
d3053 1
a3053 1
pmon_checkset (int recsize, char **buff, int *value)
@


1.139
log
@gdb/
	Code cleanup.
	* bfd-target.c (target_bfd_xclose): Remove parameter quitting.
	* bsd-kvm.c (bsd_kvm_close): Likewise.
	* bsd-uthread.c (bsd_uthread_close): Likewise.
	* corelow.c (core_close): Likewise.
	(core_close_cleanup): Remove parameter quitting from a caller.
	* event-top.c (async_disconnect): Likewise.
	* exec.c (exec_close_1): Remove parameter quitting.
	* go32-nat.c (go32_close): Likewise.
	* linux-nat.c (linux_nat_close): Remove parameter quitting.  Remove
	parameter quitting from a caller.
	* mips-linux-nat.c (super_close): Remove parameter quitting from the
	variable.
	(mips_linux_close): Remove parameter quitting.  Remove parameter
	quitting from a caller.
	* monitor.c (monitor_close): Remove parameter quitting.
	* monitor.h (monitor_close): Likewise.
	* record-btrace.c (record_btrace_close): Likewise.
	* record-full.c (record_full_close): Likewise.
	* remote-m32r-sdi.c (m32r_close): Remove parameter quitting and remove
	it also from fprintf_unfiltered.
	* remote-mips.c (mips_close): Remove parameter quitting.
	(mips_detach): Remove parameter quitting from a caller.
	* remote-sim.c (gdbsim_close): Remove parameter quitting.
	(gdbsim_close): Remove duplicate function comment.  Remove parameter
	quitting and remove it also from printf_filtered.
	* remote.c (remote_close): Remove parameter quitting.
	* solib-svr4.c (enable_break): Remove parameter quitting from a caller.
	* target.c (update_current_target): Remove parameter int from to_close
	de_fault.
	(push_target, unpush_target, pop_target): Remove parameter quitting from
	a caller.
	(pop_all_targets_above, pop_all_targets): Remove parameter quitting.
	Remove parameter quitting from a caller.
	(target_preopen): Remove parameter quitting from a caller.
	(target_close): Remove parameter quitting.  Remove parameter quitting
	from a caller two times.  Remove parameter quitting also from
	fprintf_unfiltered.
	* target.h (struct target_ops): Remove parameter quitting and as int
	from fields to_xclose and to_close.
	(extern struct target_ops current_target):
	(target_close, pop_all_targets): Remove parameter quitting.  Update the
	comment.
	(pop_all_targets_above): Remove parameter quitting.
	* top.c (quit_target): Remove parameter quitting from a caller.
	* tracepoint.c (tfile_close): Remove parameter quitting.
	* windows-nat.c (windows_close): Remove parameter quitting.
@
text
@d2154 1
a2154 1
  char *buffer;
@


1.138
log
@Use gdb_byte for bytes from the program being debugged.

gdb_byte should be used for bytes from the program being debugged.  We
have many places using char or unsigned char instead all over the
existing ports, and more ends up added over time due to copy/paste as
new code is based on old code.

I've greped the tree for "char buf[", and fixed all I found.

Tested by building with --enable-targets=all.

2013-03-01  Pedro Alves  <palves@@redhat.com>

	Use gdb_byte for bytes from the program being debugged.

	* arm-tdep.c (arm_store_return_value, arm_get_longjmp_target):
	Change type of local 'buf' to gdb_byte.
	* avr-tdep.c (avr_frame_prev_register, avr_push_dummy_call): Likewise.
	* bfin-tdep.c (bfin_push_dummy_call): Likewise.
	* cris-tdep.c (cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache): Likewise.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp)
	(frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Likewise.
	* frv-tdep.c (frv_pseudo_register_write, frv_analyze_prologue): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_find_global_pointer)
	(hppa32_hpux_search_dummy_call_sequence)
	(hppa_hpux_supply_save_state): Likewise.
	* hppa-linux-tdep.c (insns_match_pattern)
	(hppa_linux_find_global_pointer): Likewise.
	* hppa-tdep.c (hppa_in_function_epilogue_p)
	(skip_prologue_hard_way, hppa_frame_cache): Likewise.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Likewise.
	* i386fbsd-tdep.c (i386fbsd_supply_uthread)
	(i386fbsd_collect_uthread): Likewise.
	* ia64-hpux-tdep.c (ia64_hpux_push_dummy_code): Likewise.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Likewise.
	* ia64-tdep.c (examine_prologue, ia64_frame_cache)
	(ia64_frame_prev_register, ia64_sigtramp_frame_cache)
	(ia64_sigtramp_frame_prev_register, ia64_access_reg)
	(ia64_access_rse_reg, ia64_libunwind_frame_this_id)
	(ia64_libunwind_frame_prev_register)
	(ia64_libunwind_sigtramp_frame_this_id)
	(ia64_find_global_pointer_from_dynamic_section)
	(find_extant_func_descr, find_func_descr, ia64_dummy_id)
	(ia64_unwind_pc): Likewise.
	* iq2000-tdep.c (iq2000_store_return_value): Likewise.
	* m68hc11-tdep.c (m68hc11_push_dummy_call)
	(m68hc11_extract_return_value): Likewise.
	* m68klinux-nat.c (fetch_register, store_register): Likewise.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_cr32_write)
	(mep_get_insn, mep_push_dummy_call): Likewise.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips_linux_in_dynsym_stub): Likewise.
	* mn10300-tdep.c (mep_pseudo_cr32_write): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* regcache.c (dump_endian_bytes): Change type of parameter 'buf'
	to gdb_byte.
	* remote-mips.c (mips_set_register): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* score-tdep.c (score7_fetch_inst): Change type of parameter
	'memblock' and local 'buf' to gdb_byte.
	(score7_malloc_and_get_memblock): Change return type to gdb_byte.
	Change type of local 'buf' to gdb_byte.  Adjust.
	(score7_adjust_memblock_ptr): Change type of parameter 'memblock'
	to gdb_byte**.
	(score7_analyze_prologue): Change type of 'memblock' and
	'memblock_ptr' locals to gdb_byte*.
	* sh64-tdep.c (sh64_extract_return_value)
	(sh64_store_return_value): Change type of local 'buf' to gdb_byte.
	* solib-darwin.c (darwin_current_sos, darwin_read_exec_load_addr):
	* solib-pa64.c (pa64_solib_create_inferior_hook)
	(pa64_open_symbol_file_object): Remove local 'buf'.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start)
	(som_open_symbol_file_object): Likewise.
	* solib-spu.c (spu_current_sos): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	* spu-multiarch.c (parse_spufs_run, spu_fetch_registers)
	(spu_store_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	* tic6x-tdep.c (tic6x_get_longjmp_target): Likewise.
	* xstormy16-tdep.c (xstormy16_store_return_value)
	(xstormy16_push_dummy_call, xstormy16_resolve_jmp_table_entry)
	(xstormy16_find_jmp_table_entry): Likewise.
@
text
@d87 1
a87 1
static void mips_close (int quitting);
d1726 1
a1726 1
mips_close (int quitting)
d1749 1
a1749 1
  mips_close (1);
@


1.137
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d1797 1
a1797 1
  char buf[MAX_REGISTER_SIZE];
@


1.136
log
@	* gdbarch.sh (target_gdbarch): Remove macro.
	(get_target_gdbarch): Rename to target_gdbarch.
	* gdbarch.c, gdbarch.h: Rebuild.
	* ada-tasks.c, aix-thread.c, amd64-linux-nat.c, arch-utils.c,
	arm-tdep.c, auxv.c, breakpoint.c, bsd-uthread.c, corefile.c,
	darwin-nat-info.c, dcache.c, dsrec.c, exec.c, fbsd-nat.c,
	filesystem.c, gcore.c, gnu-nat.c, i386-darwin-nat.c, i386-nat.c,
	ia64-vms-tdep.c, inf-ptrace.c, infcmd.c, jit.c, linux-nat.c,
	linux-tdep.c, linux-thread-db.c, m32r-rom.c, memattr.c,
	mep-tdep.c, microblaze-tdep.c, mips-linux-nat.c,
	mips-linux-tdep.c, mips-tdep.c, monitor.c, moxie-tdep.c,
	nto-procfs.c, nto-tdep.c, ppc-linux-nat.c, proc-service.c,
	procfs.c, progspace.c, ravenscar-thread.c, record.c,
	remote-m32r-sdi.c, remote-mips.c, remote-sim.c, remote.c,
	rl78-tdep.c, rs6000-nat.c, rx-tdep.c, s390-nat.c, sol-thread.c,
	solib-darwin.c, solib-dsbt.c, solib-frv.c, solib-ia64-hpux.c,
	solib-irix.c, solib-pa64.c, solib-som.c, solib-spu.c,
	solib-sunos.c, solib-svr4.c, solib.c, spu-linux-nat.c,
	spu-multiarch.c, spu-tdep.c, symfile-mem.c, symfile.c, symtab.c,
	target-descriptions.c, target.c, target.h, tracepoint.c,
	windows-nat.c, windows-tdep.c, xcoffsolib.c, cli/cli-dump.c,
	common/agent.c, mi/mi-interp.c, python/py-finishbreakpoint.c,
	python/py-inferior.c, python/python.c: Update.
@
text
@d3 1
a3 1
   Copyright (C) 1993-2004, 2006-2012 Free Software Foundation, Inc.
@


1.135
log
@	* defs.h (quit_flag): Don't declare.
	(clear_quit_flag, check_quit_flag, set_quit_flag): Declare.
	(QUIT): Use new functions.
	* event-top.c (command_handler): Use clear_quit_flag.
	(handle_sigint): Use set_quit_flag.
	(async_request_quit): Use check_quit_flag.  Don't check
	immediate_quit.
	* exceptions.c (throw_exception): Use clear_quit_flag.
	* main.c (captured_main): Use clear_quit_flag.
	* python/python.c (clear_quit_flag, set_quit_flag)
	(check_quit_flag): New functions.
	* remote-sim.c (gdb_os_poll_quit): Use check_quit_flag,
	clear_quit_flag.
	* remote.c (remote_wait_as): Use check_quit_flag,
	clear_quit_flag.
	(remote_start_remote): Call QUIT.
	* symfile.c (load_progress): Use check_quit_flag.
	* top.c (command_loop): Use clear_quit_flag.
	(command_line_input): Call QUIT.
	* utils.c (quit_flag): Conditionally define.
	(clear_quit_flag, check_quit_flag, set_quit_flag): New
	functions.
	(prompt_for_continue): Call QUIT.  Use quit, not
	async_request_quit.
	* remote-mips.c (mips_expect_timeout): Call QUIT.
	* monitor.c (monitor_expect): Call QUIT.
@
text
@d1245 1
a1245 1
  int addr_size = gdbarch_addr_bit (target_gdbarch) / 8;
d1666 2
a1667 2
  if (gdbarch_bfd_arch_info (target_gdbarch) != NULL
      && gdbarch_bfd_arch_info (target_gdbarch)->arch == bfd_arch_mips)
d1669 1
a1669 1
    switch (gdbarch_bfd_arch_info (target_gdbarch)->mach)
d2150 1
a2150 1
  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch);
d2482 1
a2482 1
  const char *saddr = paddress (target_gdbarch, addr);
d2550 1
a2550 1
  int addr_size = gdbarch_addr_bit (target_gdbarch) / 8;
d2556 1
a2556 1
  addr = gdbarch_addr_bits_remove (target_gdbarch, addr);
d2584 1
a2584 1
		       paddress (target_gdbarch, addr));
d2735 1
a2735 1
				paddress (target_gdbarch, addr), rresponse);
d2768 1
a2768 1
			      paddress (target_gdbarch, addr));
@


1.134
log
@	* windows-nat.c (windows_make_so): Use gdb_bfd_open.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_open.
	(symfile_bfd_open): Likewise.
	(generic_load): Likewise.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_open.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_open.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_open.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_open.
	* remote-mips.c (mips_load_srec): Use gdb_bfd_open.
	(pmon_load_fast): Likewise.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_open.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_open.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_open.
	(macho_check_dsym): Likewise.
	* m32r-rom.c (m32r_load): Use gdb_bfd_open.
	(m32r_upload_command): Likewise.
	* gdb_bfd.h (gdb_bfd_cache): Declare.
	* gdb_bfd.c (struct gdb_bfd_data): New.
	(gdb_bfd_cache): New global.
	(struct gdb_bfd_cache_search): New.
	(hash_bfd): New function.
	(eq_bfd): Likewise.
	(gdb_bfd_open): Likewise.
	(gdb_bfd_ref): Allocate a gdb_bfd_data and attach to the BFD.
	(gdb_bfd_unref): Remove closed BFD from cache.  Update for
	gdb_bfd_data.
	* exec.c (exec_file_attach): Use gdb_bfd_open.
	* dsrec.c (load_srec): Use gdb_bfd_open.
@
text
@d591 1
@


1.133
log
@	* cli/cli-dump.c (bfd_openr_with_cleanup): Use gdb_bfd_openr.
	(bfd_openw_with_cleanup): Use gdb_bfd_openw.
	* corelow.c (core_open): Use gdb_bfd_fopen.
	* dsrec.c (load_srec): Use gdb_bfd_openr.
	* exec.c (exec_file_attach): Use gdb_bfd_fopen.
	* gcore.c (gcore_memory_sections): Use gdb_bfd_openw.
	* gdb_bfd.c (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): New functions.
	* gdb_bfd.h (gdb_bfd_fopen, gdb_bfd_openr, gdb_bfd_openw)
	(gdb_bfd_openr_iovec, gdb_bfd_openr_next_archived_file)
	(gdb_bfd_fdopenr): Declare.
	* jit.c (bfd_open_from_target_memory): Use gdb_bfd_openr_iovec.
	* m32-rom.c (m32r_load, m32r_upload_command): Use gdb_bfd_openr.
	* machoread.c (macho_symfile_read_all_oso): Use gdb_bfd_openr,
	gdb_bfd_openr_next_archived_file.
	(macho_check_dsym): Use gdb_bfd_openr.
	(macho_add_oso_symfile): Don't call gdb_bfd_stash_filename.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_fdopenr.
	* remote-m32r-sdi.c (m32r_load): Use gdb_bfd_openr.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Use
	gdb_bfd_openr.
	* remote.c (remote_bfd_open): Use gdb_bfd_openr_iovec.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_openr, gdb_bfd_fdopenr,
	gdb_bfd_openr_next_archived_file.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use gdb_bfd_openr.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use
	gdb_bfd_openr.
	* solib-spu.c (spu_bfd_fopen): Use gdb_bfd_openr_iovec.
	* solib.c (solib_bfd_fopen): Use gdb_bfd_fopen.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_openr_iovec.
	* symfile.c (bfd_open_maybe_remote): Use gdb_bfd_openr.
	(symfile_bfd_open): Use gdb_bfd_fopen.
	(generic_load): Use gdb_bfd_openr.
	* windows-nat.c (windows_make_so): Use gdb_bfd_openr.
@
text
@d2792 1
a2792 1
  abfd = gdb_bfd_openr (args, 0);
d3379 1
a3379 1
  abfd = gdb_bfd_openr (file, 0);
@


1.132
log
@	* bfd-target.c (target_bfd_reopen): Update.
	* cli/cli-dump.c (bfd_openr_with_cleanup)
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* exec.c (exec_file_attach): Update.
	* gcore.c (create_gcore_bfd): Update.
	* gdb_bfd.c (gdb_bfd_ref): Return void.
	(gdb_bfd_open): Update.
	* gdb_bfd.h (gdb_bfd_ref): Return void.
	Update comments.
	* jit.c (jit_bfd_try_read_symtab): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* machoread.c (macho_symfile_read_all_oso): Update.
	(macho_check_dsym): Update.
	* procfs.c (insert_dbx_link_bpt_in_file): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec, pmon_load_fast): Update.
	* rs6000-nat.c (add_vmap): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-spu.c (spu_bfd_open): Update.
	* solib.c (solib_bfd_fopen, solib_read_symbols): Update.
	* spu-linux-nat.c (spu_bfd_open): Update.
	* symfile.c (bfd_open_maybe_remote, symfile_bfd_open)
	(generic_load): Update.
	* windows-nat.c (windows_make_so): Update.
@
text
@d2792 1
a2792 2
  abfd = bfd_openr (args, 0);
  gdb_bfd_ref (abfd);
d3379 1
a3379 2
  abfd = bfd_openr (file, 0);
  gdb_bfd_ref (abfd);
@


1.131
log
@	* utils.c (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* defs.h (make_cleanup_bfd_unref): Rename from
	make_cleanup_bfd_close.
	* cli/cli-dump.c (bfd_openr_with_cleanup): Update.
	(bfd_openw_with_cleanup): Update.
	* corelow.c (core_open): Update.
	* dsrec.c (load_srec): Update.
	* m32r-rom.c (m32r_load, m32r_upload_command): Update.
	* remote-m32r-sdi.c (m32r_load): Update.
	* remote-mips.c (mips_load_srec): Update.
	(pmon_load_fast): Update.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Update.
	(darwin_bfd_open): Update.
	* solib.c (solib_bfd_fopen): Update.
	* symfile-mem.c (symbol_file_add_from_memory): Update.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Update.
	(symfile_bfd_open): Update.
	(generic_load): Update.
@
text
@d2792 2
a2793 1
  abfd = gdb_bfd_ref (bfd_openr (args, 0));
d3380 2
a3381 1
  abfd = gdb_bfd_ref (bfd_openr (file, 0));
@


1.130
log
@	* remote-mips.c (mips_load_srec): Use make_cleanup_bfd_close.
	(pmon_load_fast): Likewise.
	* m32r-rom.c (m32r_load): Use make_cleanup_bfd_close.
	(m32r_upload_command): Likewise.
	* dsrec.c (load_srec): Use make_cleanup_bfd_close.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Use make_cleanup_bfd_close.
@
text
@d2799 1
a2799 1
  cleanup = make_cleanup_bfd_close (abfd);
d3385 1
a3385 1
  cleanup = make_cleanup_bfd_close (abfd);
@


1.129
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d2787 1
d2799 1
d2803 1
d2857 1
d3374 1
d3385 1
d3390 1
d3514 1
@


1.128
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d39 1
d2791 1
a2791 1
  abfd = bfd_openr (args, 0);
d3374 1
a3374 1
  abfd = bfd_openr (file, 0);
@


1.127
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

	Replace target_signal with gdb_signal throughout.
@
text
@d1781 1
a1781 1
    return TARGET_SIGNAL_UNKNOWN;
d1840 1
a1840 1
      status->value.sig = TARGET_SIGNAL_TRAP;
@


1.126
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d1759 1
a1759 1
	     ptid_t ptid, int step, enum target_signal siggnal)
d1773 1
a1773 1
static enum target_signal
d1783 1
a1783 1
  /* Don't want to use target_signal_from_host because we are converting
d1787 1
a1787 1
  return (enum target_signal) sig;
@


1.125
log
@gdb/
	Fix -Wmissing-prototypes build.
	* alpha-tdep.c (alpha_deal_with_atomic_sequence): Make it static.
	* amd64-darwin-tdep.c (_initialize_amd64_darwin_tdep): New prototype.
	* amd64-windows-tdep.c (_initialize_amd64_windows_tdep): Likewise.
	* arm-symbian-tdep.c (arm_symbian_skip_trampoline_code): Make it static.
	(_initialize_arm_symbian_tdep): New prototype.
	* arm-wince-tdep.c (arm_wince_skip_main_prologue): Make it static.
	* i386-darwin-tdep.c (_initialize_i386_darwin_tdep): New prototype.
	* i386-linux-tdep.c (i386_linux_displaced_step_copy_insn): Make it
	static.
	* lm32-tdep.c (_initialize_lm32_tdep): New prototype.
	* microblaze-linux-tdep.c (_initialize_microblaze_linux_tdep): New
	prototype.
	* microblaze-tdep.c (microblaze_debug, microblaze_fetch_instruction)
	(microblaze_skip_prologue, microblaze_frame_cache): Make them static.
	* mips-linux-tdep.c (mips_linux_regset_from_core_section): Make it
	static.
	* moxie-tdep.c (moxie_process_record): Likewise.
	* remote-mips.c (mips_can_use_watchpoint, mips_insert_watchpoint)
	(mips_remove_watchpoint, mips_stopped_by_watchpoint): Make them static.
	* rl78-tdep.c (rl78_breakpoint_from_pc): Make it static.
	(_initialize_rl78_tdep): New prototype.
	* rx-tdep.c (rx_breakpoint_from_pc): Make it static.
	(_initialize_rx_tdep): New prototype.
	* solib-darwin.c (darwin_in_dynsym_resolve_code): Make it static.
	(_initialize_darwin_solib): New prototype.
	* solib-spu.c: Include solib-spu.h.
	(_initialize_spu_solib): New prototype.
	* spu-multiarch.c (_initialize_spu_multiarch): New prototype.
	* tic6x-tdep.c (tic6x_analyze_prologue, tic6x_skip_prologue)
	(tic6x_breakpoint_from_pc, tic6x_frame_unwind_cache)
	(tic6x_software_single_step): Make it static.
	(_initialize_tic6x_tdep): New prototype.
@
text
@a1539 1
  char *ptype;
a1829 1
  int i;
@


1.124
log
@	* blockframe.c (find_pc_partial_function_gnu_ifunc): Change type of
	"name" parameter to const char ** from char **.  All callers updated.
	(find_pc_partial_function): Ditto.
	(cache_pc_function_name): Change type to const char * from char *.
	* symtab.h ((find_pc_partial_function_gnu_ifunc): Update.
	(find_pc_partial_function): Update.
	* alpha-tdep.h (struct gdbarch_tdep, member pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	All uses updated.
	* arch-utils.c (generic_in_solib_return_trampoline): Change
	type of "name" parameter to const char * from char *.
	* arch-utils.h (generic_in_solib_return_trampoline): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* gdbarch.sh (in_solib_return_trampoline): Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Update.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Update.
	* m32r-linux-tdep.c (m32r_linux_pc_in_sigtramp): Change
	type of "name" parameter to const char * from char *.
	* skip.c (skip_function_pc): Ditto.
	* sparc-sol2-tdep.c (sparc_sol2_pc_in_sigtramp): Ditto.
	* sparc-tdep.h (sparc_sol2_pc_in_sigtramp): Update.
	* sparc64fbsd-tdep.c (sparc64fbsd_pc_in_sigtramp): Ditto.
	* sparc64nbsd-tdep.c (sparc64nbsd_pc_in_sigtramp): Ditto.
	* sparc64obsd-tdep.c (sparc64obsd_pc_in_sigtramp): Ditto.
	* sparcnbsd-tdep.c (sparc32nbsd_pc_in_sigtramp): Ditto.
	* sparcobsd-tdep.c (sparc32obsd_pc_in_sigtramp): Ditto.
	* nbsd-tdep.c (nbsd_pc_in_sigtramp): Similary for "func_name".
	* nbsd-tdep.h (nbsd_pc_in_sigtramp): Update.
@
text
@d2387 1
a2387 1
int
d2421 1
a2421 1
int
d2433 1
a2433 1
int
d2446 1
a2446 1
int
@


1.123
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1957 1
a1957 1
	  char *func_name;
@


1.122
log
@gdb/
	* remote-mips.c (pmon_download): Fix ignored return value GCC warning.
@
text
@d3 1
a3 3
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.122.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1993-2004, 2006-2012 Free Software Foundation, Inc.
@


1.121
log
@	Fix mingw compilation with --enable-targets=all.
	* remote-mips.c (gdb_usleep.h): Include header.
	(mips_enter_debug): Use gdb_usleep instead of sleep.
@
text
@d3346 7
a3352 1
    fwrite (buffer, 1, length, tftp_file);
@


1.120
log
@	Fix ARI warnings about new lines at the end of messages, which
	are unneeded as there is a new line added at the end of the message
	automatically.
	* darwin-nat.c (darwin_stop_inferior): Ditto.
	* dec-thread.c (dec_thread_get_ada_task_ptid): Ditto.
	* dfp.c (decimal_to_number): Ditto.
	* exec.c (print_section_info): Ditto.
	* i386-darwin-nat.c (darwin_set_sstep): Ditto.
	* osdata.c (get_osdata): Ditto.
	* record.c (bfdcore_write): Ditto.
	* remote-mips.c (mips_readchar): Ditto.
	* remote.c (read_ptid): Ditto.
	* ser-mingw.c (ser_windows_raw): Ditto.
	* tracepoint.c (add_local_symbols): Ditto.
	* windows-nat.c (fake_create_process): Ditto.
@
text
@d36 1
d1354 1
a1354 1
  sleep (1);
@


1.119
log
@	* remote-mips.c: Add internationalization mark ups.  Remove
	trailing \n from already marked up strings.
@
text
@d675 1
a675 1
      error (_("Watchdog has expired.  Target detached.\n"));
@


1.118
log
@2011-01-11  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Internationalization.
	* c-lang.c: Ditto.
	* charset.c: Ditto.
	* fork-child.c: Ditto.
	* nto-procfs.c: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* procfs.c: Ditto.
	* remote-mips.c: Ditto.
	* remote.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* target.c: Ditto.
	* valops.c: Ditto.
	* value.c: Ditto.
	* xml-support.c: Ditto.
	* mi/mi-cmd-break.c: Ditto.
	* mi/mi-cmd-var.c: Ditto.
	* mi/mi-interp.c: Ditto.
	* mi/mi-main.c: Ditto.
@
text
@d679 1
a679 1
    mips_error ("End of file from remote");
d681 1
a681 1
    mips_error ("Error reading from remote: %s", safe_strerror (errno));
d774 2
a775 2
		mips_error ("Debug protocol failure:  more "
			    "than %d characters before a sync.",
d863 1
a863 1
    mips_error ("MIPS protocol data packet too long: %s", s);
d901 1
a901 1
	mips_error ("write to target failed: %s", safe_strerror (errno));
d1009 1
a1009 1
  mips_error ("Remote did not acknowledge packet");
d1040 1
a1040 1
	    mips_error ("Timed out waiting for remote packet");
d1080 1
a1080 1
		mips_error ("Timed out waiting for remote packet");
d1102 1
a1102 1
	    mips_error ("Timed out waiting for packet");
d1162 2
a1163 1
	    mips_error ("write to target failed: %s", safe_strerror (errno));
d1203 1
a1203 1
	mips_error ("write to target failed: %s", safe_strerror (errno));
d1291 1
a1291 1
    mips_error ("Bad response from remote board");
d1367 1
a1367 1
      mips_error ("Failed to initialize (didn't receive packet).");
d1417 1
a1417 1
      warning ("internal error: mips_initialize called twice");
d1491 1
a1491 1
	  mips_error ("Failed to initialize.");
d1852 1
a1852 1
    mips_error ("Remote failure: %s", safe_strerror (errno));
d2050 1
a2050 1
	    mips_error ("Can't read register %d: %s", regno,
d2089 2
a2090 1
    mips_error ("Can't write register %d: %s", regno, safe_strerror (errno));
d2324 2
a2325 2
      warning ("\
Can't pass arguments to remote MIPS board; arguments ignored.");
d2583 2
a2584 2
	      warning ("\
mips_common_breakpoint: Attempt to clear bogus breakpoint at %s\n",
d2598 2
a2599 2
	    mips_error ("mips_common_breakpoint: "
			"Bad response from remote board: %s",
d2651 2
a2652 2
	    mips_error ("mips_common_breakpoint: "
			"Bad response from remote board: %s",
d2723 2
a2724 2
	mips_error ("mips_common_breakpoint: "
		    "Bad response from remote board: %s",
d2772 1
a2772 1
	  error (_("Download got unexpected ack char: 0x%x, retrying.\n"),
@


1.117
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d675 1
a675 1
      error ("Watchdog has expired.  Target detached.\n");
d716 1
a716 1
      error ("Remote board reset, debug protocol re-initialized.");
d1601 1
a1601 1
	    perror_with_name ("Unable to open UDP port");
d1744 1
a1744 1
    error ("Argument given to \"detach\" when remotely debugging.");
d2329 1
a2329 1
    error ("No executable file specified");
d2596 2
a2597 2
	    mips_error ("\
mips_common_breakpoint: Bad response from remote board: %s",
d2649 2
a2650 2
	    mips_error ("\
mips_common_breakpoint: Bad response from remote board: %s",
d2721 2
a2722 2
	mips_error ("\
mips_common_breakpoint: Bad response from remote board: %s",
d2760 1
a2760 1
	  error ("Timeout during download.");
d2770 2
a2771 1
	  error ("Download got unexpected ack char: 0x%x, retrying.\n", ch);
d3513 1
a3513 1
    error ("mips_load:  Couldn't get into monitor mode.");
@


1.116
log
@run copyright.sh for 2011.
@
text
@d302 7
a308 3
    MON_PMON,			/* 3.0.83 [COGENT,EB,FP,NET] Algorithmics Ltd. Nov  9 1995 17:19:50 */
    MON_DDB,			/* 2.7.473 [DDBVR4300,EL,FP,NET] Risq Modular Systems,  Thu Jun 6 09:28:40 PDT 1996 */
    MON_LSI,			/* 4.3.12 [EB,FP], LSI LOGIC Corp. Tue Feb 25 13:22:14 1997 */
d310 1
a310 1
    /* Last and unused value, for sizing vectors, etc. */
d332 1
a332 1
/* Currently active target description (if mips_is_open == 1) */
d382 1
a382 1
/* If non-zero, means that the target is running. */
d385 1
a385 1
/* If non-zero, monitor supports breakpoint commands. */
d390 1
a390 1
#if 0				/* not used (yet?) */
d394 1
a394 1
/* Non-zero means that we've just hit a read or write watchpoint */
d399 2
a400 2
   from 0 to 255 returned by the LSI PMON when a breakpoint is set.
 */
d413 8
a420 4
#define W_WARN	0x100		/* This bit is set if the error code is a warning */
#define W_MSK   0x101		/* warning: Range feature is supported via mask */
#define W_VAL   0x102		/* warning: Value check is not supported in hardware */
#define W_QAL   0x104		/* warning: Requested qualifiers are not supported in hardware */
d422 2
a423 1
#define E_ERR	0x200		/* This bit is set if the error code is an error */
d426 2
a427 1
#define E_QAL   0x202		/* error: The requested qualifiers can not be used */
d495 1
a495 1
  wrap_here ("");		/* Force out any buffered output */
d576 1
a576 2
   timed out.  TIMEOUT specifies timeout value in seconds.
 */
d596 1
a596 1
	 confused if we were waiting for the mips_monitor_prompt... */
d631 1
a631 2
   mips_expect_timeout if a different timeout value is needed.
 */
d660 1
a660 1
  { /* FIXME this whole block is dead code! */
d672 1
a672 1
  if (ch == SERIAL_TIMEOUT && timeout == -1)	/* Watchdog went off */
d705 2
a706 1
	fprintf_unfiltered (gdb_stdlog, "Reinitializing MIPS debugging mode\n");
d714 1
a714 1
         in progress and get back to command level as quickly as possible. */
d754 1
a754 1
	         buffered target output confuses the user. */
d768 1
a768 1
	      /* Only count unprintable characters. */
d774 2
a775 1
		mips_error ("Debug protocol failure:  more than %d characters before a sync.",
d806 2
a807 1
mips_receive_trailer (unsigned char *trlr, int *pgarbage, int *pch, int timeout)
d932 1
a932 1
	         packet. */
d948 1
a948 1
		  /* ignore the character */
d956 1
a956 1
	         ACK to the packet. */
d1056 1
a1056 1
	         ignore the packet anyway. */
d1259 2
a1260 1
			_("mips_request: Trying to send command before reply"));
d1349 1
a1349 1
  else				/* assume IDT monitor by default */
d1358 1
a1358 1
     being displayed to the user. */
d1429 2
a1430 1
    j = 0;			/* start by checking if we are already at the prompt */
d1432 1
a1432 1
    j = 1;			/* start by sending a break */
d1437 1
a1437 1
	case 0:		/* First, try sending a CR */
d1441 1
a1441 1
	case 1:		/* First, try sending a break */
d1444 1
a1444 1
	case 2:		/* Then, try a ^C */
d1447 1
a1447 1
	case 3:		/* Then, try escaping from download */
d1456 1
a1456 1
		   packets. In-case we were downloading a large packet
d1458 1
a1458 1
		   termination sequence. */
d1474 1
a1474 2
		   256/8 + 1 packets.
		 */
d1484 1
a1484 1
				   the board. */
d1512 1
a1512 1
         "debug" mode, only at the monitor command-line. */
d1547 9
a1555 9
    error (
	    "To open a MIPS remote debugging connection, you need to specify what serial\n\
device is attached to the target board (e.g., /dev/ttya).\n"
	    "If you want to use TFTP to download to the board, specify the name of a\n"
	    "temporary file to be used by GDB for downloads as the second argument.\n"
	    "This filename must be in the form host:filename, where host is the name\n"
	    "of the host running the TFTP server, and the file must be readable by the\n"
	    "world.  If the local name of the temporary file differs from the name as\n"
	    "seen from the board via TFTP, specify that name as the third parameter.\n");
d1563 1
a1563 1
  if (argv[1])			/* remote TFTP name specified? */
d1566 1
a1566 1
      if (argv[2])		/* local TFTP filename specified? */
d1615 1
a1615 1
	      local_name++;	/* skip over the colon */
d1617 1
a1617 1
	    local_name = remote_name;	/* local name same as remote name */
d1855 1
a1855 1
     ACK. The code can cope with this, but to try and avoid the
d1857 1
a1857 1
     to the user, we cheat and reset the debug protocol. The problems
d1860 1
a1860 1
     as a bad packet. */
d1867 2
a1868 1
  /* See if we got back extended status.  If so, pick out the pc, fp, sp, etc... */
d1870 2
a1871 1
  nfields = sscanf (buff, "0x%*x %*c 0x%*x 0x%*x 0x%16s 0x%16s 0x%16s 0x%*x %s",
d1900 7
a1906 6
      /* If this is an LSI PMON target, see if we just hit a hardrdware watchpoint.
         Right now, PMON doesn't give us enough information to determine which
         breakpoint we hit.  So we have to look up the PC in our own table
         of breakpoints, and if found, assume it's just a normal instruction
         fetch breakpoint, not a data watchpoint.  FIXME when PMON
         provides some way to tell us what type of breakpoint it is.  */
d2040 2
a2041 2
	     compiled without the 64bit register access commands. This
	     means we cannot get hold of the full register width. */
d2114 1
a2114 1
/* FIXME! make sure only 32-bit quantities get stored! */
d2157 1
a2157 1
     value down to 32 bits. */
d2191 2
a2192 1
	  store_unsigned_integer (&buffer[(count - 1) * 4], 4, byte_order, val);
d2195 1
a2195 1
      /* Copy data to be written over corresponding part of buffer */
d2207 1
a2207 1
	  /* Report each kilobyte (we download 32-bit words at a time) */
d2225 1
a2225 1
      /* Read all the longwords */
d2276 3
a2278 3
	  /* Clean up in such a way that mips_close won't try to talk to the
	     board (it almost surely won't work since we weren't able to talk to
	     it).  */
d2418 1
a2418 1
   watchpoint. */
d2474 1
a2474 1
   that was being set.  <RERRFLG> is the error code returned by PMON. 
d2625 1
a2625 3
	     Possible return codes: OK, W_QAL, E_QAL, E_OUT, E_NON.  

	   */
d2671 3
a2673 2
         <FLAGS> is any combination of `r', `w', or `f' for read/write/fetch.
       */
d2698 2
a2699 1
	      internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d2765 2
a2766 1
	  fprintf_unfiltered (gdb_stderr, "Download got a NACK at byte %s!  Retrying.\n",
d2775 1
a2775 1
/*  Download a binary file by converting it to S records. */
d2812 1
a2812 1
	  /* FIXME!  vma too small????? */
d2856 1
a2856 1
 * mips_make_srec -- make an srecord. This writes each line, one at a
d2873 1
a2873 1
 *        is the number of bytes following upto the checksum. Note that
d2906 2
a2907 2
  /* Create the header for the srec. addr_size is the number of bytes in the address,
     and 1 is the number of bytes in the count.  */
d2909 1
a2909 1
  /* FIXME!! bigger buf required for 64-bit! */
d2913 1
a2913 1
  /* This assumes S3 style downloads (4byte addresses). There should
d2915 1
a2915 1
     explicit. */
d2926 1
a2926 1
  buf += 2;			/* Point at length byte */
d2936 2
a2937 2
   control support provided by the monitor. If enabled the code will
   wait for an affirmative ACK between transmitting packets. */
d2946 2
a2947 1
   'S'     define symbol name (for addr) terminated with "," and padded to 4char boundary
d2962 2
a2963 1
static char encoding[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,.";
d2967 2
a2968 2
   pointer non-NULL). The function returns the number of encoded
   characters written into the buffer. */
d2978 3
a2980 1
			  "Fast encoding bitcount must be a multiple of 12bits: %dbit%s\n", n, (n == 1) ? "" : "s");
d2986 2
a2987 1
			  "Fast encoding cannot process more than 36bits at the moment: %dbits\n", n);
d3016 1
a3016 1
   escape sequence into the data stream. */
d3040 1
a3040 1
   The checksum specified by *VALUE is zeroed out prior to returning. 
d3054 1
a3054 1
  *buff += 2;			/* include zero terminator */
d3063 1
a3063 1
/* zero-fill, checksum, transfer end and line termination space. */
d3071 2
a3072 2
/* NOTE: This constant depends on the monitor being used. This value
   is for PMON 5.x on the Cogent Vr4300 board. */
d3109 3
a3111 3
     the maximum allowable record size. Each record output is 4bytes
     in length. We must allow space for a pending zero fill command,
     the record, and a checksum record. */
d3127 3
a3129 1
	  unsigned int value = ((inbuf[*inptr + 0] << 16) | (inbuf[*inptr + 1] << 8) | inbuf[*inptr + 2]);
d3131 1
a3131 1
	  /* Simple check for zero data. TODO: A better check would be
d3133 1
a3133 1
	     (if the first byte is not). We could then check for
d3136 2
a3137 2
	     to pad to the start of the zeroes. NOTE: This also depends
	     on the alignment at the end of the zero run. */
d3178 1
a3178 1
	  return (-1);		/* terminate the download */
d3219 1
a3219 1
	remove (tftp_localname);	/* Remove temporary file */
d3238 1
a3238 1
  char hexnumber[9];		/* includes '\0' space */
d3253 1
a3253 1
  char hexnumber[9];		/* includes '\0' space */
d3271 1
a3271 1
  char hexnumber[9];		/* includes '\0' space */
d3308 1
a3308 1
     arbitrarily but might be too small for really large downloads. FIXME. */
d3331 1
a3331 1
    remove (tftp_localname);	/* Remove temporary file */
d3384 2
a3385 2
     already defined to have the argument we give. The code doesn't
     care, since it just scans to the next prompt anyway. */
d3389 1
a3389 1
  /* Zero the checksum */
d3396 1
a3396 1
    if (s->flags & SEC_LOAD)	/* only deal with loadable sections */
d3401 2
a3402 1
	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, (unsigned int) s->vma,
d3406 1
a3406 1
	/* Output the starting address */
d3411 1
a3411 1
	reclen += 3;		/* for the initial escape code and carriage return */
d3447 2
a3448 1
			    zerofill = 0;	/* do not transmit pending zerofills */
d3485 3
a3487 3
  /* Terminate the transfer. We know that we have an empty output
     buffer at this point. */
  sprintf (buffer, "/E/E\n");	/* include dummy padding characters */
d3503 1
a3503 1
/* mips_load -- download a file. */
d3521 1
a3521 1
  /* Finally, make the PC point at the start address */
d3526 1
a3526 1
         to a different value than GDB thinks it has. The following ensures
d3581 2
a3582 1
extern initialize_file_ftype _initialize_remote_mips; /* -Wmissing-prototypes */
@


1.115
log
@2010-07-07  Sergio Durigan Junior  <sergiodj@@linux.vnet.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	Support for hw accelerated condition watchpoints in booke powerpc.

	* breakpoint.c (fetch_watchpoint_value): Rename to fetch_subexp_value
	and move to eval.c.  Change callers.
	(insert_bp_location): Pass watchpoint condition in
	target_insert_watchpoint.
	(remove_breakpoint_1) Pass watchpoint condition in
	target_remove_watchpoint.
	(watchpoint_locations_match): Call
	target_can_accel_watchpoint_condition.
	* eval.c: Include wrapper.h.
	(fetch_subexp_value): Moved from breakpoint.c.
	* ppc-linux-nat.c (ppc_linux_region_ok_for_hw_watchpoint):
	Formatting fix.
	(can_use_watchpoint_cond_accel): New function.
	(calculate_dvc): Likewise.
	(num_memory_accesses): Likewise.
	(check_condition): Likewise.
	(ppc_linux_can_accel_watchpoint_condition): Likewise
	(ppc_linux_insert_watchpoint): Call can_use_watchpoint_cond_accel,
	check_condition and calculate_dvc.
	(ppc_linux_remove_watchpoint): Likewise.
	(_initialize_ppc_linux_nat): Set to_can_accel_watchpoint_condition to
	ppc_linux_can_accel_watchpoint_condition
	* target.c (debug_to_insert_watchpoint): Add argument for watchpoint
	condition.
	(debug_to_remove_watchpoint): Likewise.
	(debug_to_can_accel_watchpoint_condition): New function.
	(update_current_target): Set to_can_accel_watchpoint_condition.
	(setup_target_debug): Set to_can_accel_watchpoint_condition.
	* target.h: Add opaque declaration for struct expression.
	(struct target_ops) <to_insert_watchpoint>,
	<to_remove_watchpoint>: Add new arguments to pass the watchpoint
	<to_can_accel_watchpoint_condition>: New member.
	condition.  Update all callers and implementations.
	(target_can_accel_watchpoint_condition): New macro.
	* value.c (free_value_chain): New function.
	* value.h (fetch_subexp_value): New prototype.
	(free_value_chain): Likewise.
@
text
@d4 2
a5 1
   2003, 2004, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.114
log
@2010-05-16  Michael Snyder  <msnyder@@vmware.com>

	* record.c: White space.
	* regcache.c: White space.
	* reggroups.c: White space.
	* remote-fileio.c: White space.
	* remote-m32r-sdi.c: White space.
	* remote-mips.c: White space.
	* remote-sim.c: White space.
@
text
@d2404 2
a2405 1
mips_insert_watchpoint (CORE_ADDR addr, int len, int type)
d2416 2
a2417 1
mips_remove_watchpoint (CORE_ADDR addr, int len, int type)
@


1.113
log
@gdb/
	* cli/cli-cmds.h (error_no_arg): Remove.  Move the comment ...
	* command.h (error_no_arg): ... here.  Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* defs.h (NORETURN, ATTR_NORETURN): Remove.
	(perror_with_name, verror, error, error_stream, vfatal, fatal)
	(internal_verror, internal_error, nomem): Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* exceptions.c (throw_exception, deprecated_throw_reason, throw_verror)
	(throw_vfatal, throw_error): Remove NORETURN.
	(throw_it): Remove NORETURN, change ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* exceptions.h (throw_exception, throw_verror, throw_vfatal)
	(throw_error, deprecated_throw_reason): Remove NORETURN, change
	ATTR_NORETURN to ATTRIBUTE_NORETURN.
	* linespec.c (cplusplus_error): Remove NORETURN, change ATTR_NORETURN
	to ATTRIBUTE_NORETURN for prototype, for the definition only remove
	NORETURN.
	* remote-mips.c (mips_error): Change NORETURN to ATTRIBUTE_NORETURN.
	* remote-sim.c (gdb_os_error): Change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.
	* target.c (tcomplain): Likewise.
	* target.h (noprocess): Remove NORETURN, change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.
	* utils.c (verror, error, vfatal, fatal, error_stream, internal_verror)
	(internal_error, perror_with_name, nomem): Remove NORETURN.
	* xml-support.h (gdb_xml_error): Change ATTR_NORETURN to
	ATTRIBUTE_NORETURN.

gdb/doc/
	* gdbint.texinfo (Host Definition): Remove items NORETURN and
	ATTR_NORETURN.
@
text
@d651 1
a651 1
  {
d1351 1
d2018 1
d2187 1
d2473 1
d2664 1
d3103 1
d3212 1
d3227 1
@


1.112
log
@	* remote-mips.c (close_ports, mips_initialize_cleanups)
	(mips_exit_cleanups, mips_send_command, mips_open, pmon_open)
	(ddb_open, lsi_open, mips_remove_breakpoint, mips_remove_watchpoint)
	(mips_stopped_by_watchpoint, send_srec, pmon_checkset)
	(pmon_make_fastrec, pmon_check_ack, mips_expect_download)
	(pmon_check_entry_address, pmon_check_total, pmon_end_download)
	(pmon_download, pmon_load_fast, _initialize_remote_mips): Add
	comments describing each of these functions.
	(mips_enter_debug, mips_exit_debug, common_open)
	(mips_signal_from_protocol, pmon_makeb64, pmon_zeroset): Add
	blank line after the comment describing the function.
@
text
@d476 1
a476 1
static NORETURN void
@


1.111
log
@	* remote-mips.c (rockhopper_ops): New target_ops struct.
	(MON_ROCKHOPPER): New mips_monitor_type.
	(read_hex_value): New function.
	(mips_request): Send 8-byte values with a 'T' packet.  Read the
	packet argument as a string and use read_hex_value to parse it.
	(mips_exit_debug): Wait for response when using MON_ROCKHOPPER.
	(rockhopper_open): New function.
	(mips_wait): Read the PC, FP and SP fields as strings.  Use
	read_hex_value to parse them and mips_set_register to commit them.
	(mips_set_register): New function.
	(mips_fetch_registers): Do not cast register value to "unsigned"
	when reading a MON_ROCKHOPPER 't' packet.  Use mips_set_register.
	(mips_store_registers): Use a 'T' packet to set registers when
	using MON_ROCKHOPPER.
	(pmon_end_download): Don't run initEther if using MON_ROCKHOPPER
	and expect the total to be printed before the entry address.
	(_initialize_remote_mips): Initialize and add rockhopper_ops.
@
text
@d454 3
d1296 2
d1304 2
d1312 3
d1326 1
d1357 1
d1520 1
d1645 2
d1670 2
d1678 2
d1694 2
d1759 1
d2349 2
d2409 2
d2420 3
d2717 5
d2942 1
d2987 1
d3000 14
d3044 26
d3127 4
d3173 6
d3193 9
d3212 4
d3226 7
d3299 4
d3312 3
d3546 4
@


1.110
log
@	* remote-mips.c (mips_fetch_word): Add new parameter, `valp'.
	Change return value to int.  Store value fetched in location
	addressed by `val'.  Use function's return value as success
	or failure indicator.  Adjust all callers.
@
text
@d92 2
d148 1
d294 1
a294 1
struct target_ops mips_ops, pmon_ops, ddb_ops, lsi_ops;
d304 1
d534 27
d1230 1
d1235 1
a1235 1
  unsigned long rresponse;
d1245 9
a1253 2
      sprintf (buff, "0x0 %c 0x%s 0x%s", cmd,
	       phex_nz (addr, addr_size), phex_nz (data, addr_size));
d1270 3
a1272 2
  if (sscanf (buff, "0x%x %c 0x%x 0x%lx",
	      &rpid, &rcmd, &rerrflg, &rresponse) != 4
d1354 1
a1354 1
  if (mips_monitor != MON_IDT)
d1667 8
d1755 28
d1792 2
a1793 2
  int rpc, rfp, rsp;
  char flags[20];
d1833 6
a1838 3
  nfields = sscanf (buff, "0x%*x %*c 0x%*x 0x%*x 0x%x 0x%x 0x%x 0x%*x %s",
		    &rpc, &rfp, &rsp, flags);
  if (nfields >= 3)
a1841 2
      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
      char buf[MAX_REGISTER_SIZE];
d1843 3
a1845 20
      store_unsigned_integer
	(buf, register_size (gdbarch, gdbarch_pc_regnum (gdbarch)),
	 byte_order, rpc);
      regcache_raw_supply (regcache, gdbarch_pc_regnum (gdbarch), buf);

      store_unsigned_integer
	(buf, register_size (gdbarch, gdbarch_pc_regnum (gdbarch)),
	 byte_order, rfp);
      regcache_raw_supply (regcache, 30, buf);	/* This register they are avoiding and so it is unnamed */

      store_unsigned_integer
	(buf, register_size (gdbarch, gdbarch_sp_regnum (gdbarch)),
	 byte_order, rsp);
      regcache_raw_supply (regcache, gdbarch_sp_regnum (gdbarch), buf);

      store_unsigned_integer
	(buf, register_size (gdbarch, gdbarch_deprecated_fp_regnum (gdbarch)),
	 byte_order, 0);
      regcache_raw_supply (regcache,
			   gdbarch_deprecated_fp_regnum (gdbarch), buf);
d1975 1
a1975 1
  unsigned LONGEST val;
d2002 3
a2004 3
	  if (mips_monitor == MON_DDB)
	    val = (unsigned) mips_request ('t', pmon_reg, 0,
					   &err, mips_receive_wait, NULL);
d2014 1
a2014 9
  {
    char buf[MAX_REGISTER_SIZE];

    /* We got the number the register holds, but gdb expects to see a
       value in the target byte ordering.  */
    store_unsigned_integer (buf, register_size (gdbarch, regno),
			    byte_order, val);
    regcache_raw_supply (regcache, regno, buf);
  }
d2043 3
a2045 1
  mips_request ('R', mips_map_regno (gdbarch, regno), val,
d2430 1
a2430 1
  char *saddr = paddress (target_gdbarch, addr);
d3147 2
a3148 1
      mips_send_command ("initEther\r", -1);
d3176 5
d3468 1
a3468 1
  pmon_ops = ddb_ops = lsi_ops = mips_ops;
d3498 5
d3513 1
@


1.109
log
@	* remote-mips.c (gdbthread.h): Include.
	(remote_mips_ptid): Declare.
	(mips_error): Only mourn the inferior when inferior_ptid is non-null.
	(common_open): Set inferior_ptid, add it as an inferior, and
	as a thread too.  Delete FIXME comment regarding start_remote().
	(mips_close): Invoke generic_mourn_inferior().
	(mips_kill): Make sure that target_mourn_inferior is invoked.
	(mips_mourn_inferior): Don't invoke generic_mourn_inferior, as
	it's now invoked from mips_close().
	(mips_load): Don't null out inferior_ptid.  Don't call
	clear_symtab_users().
	(mips_thread_alive, mips_pid_to_str): New functions.
	(_initialize_remote_mips): Initialize remote_mips_ptid.  Initialize
	to_thread_alive and to_pid_to_str operations.
@
text
@d94 1
a94 1
static unsigned int mips_fetch_word (CORE_ADDR addr);
d1997 3
a1999 1
/* Fetch a word from the target board.  */
d2001 2
a2002 2
static unsigned int
mips_fetch_word (CORE_ADDR addr)
a2003 1
  unsigned int val;
d2006 1
a2006 1
  val = mips_request ('d', addr, 0, &err, mips_receive_wait, NULL);
d2010 2
a2011 5
      val = mips_request ('i', addr, 0, &err,
			  mips_receive_wait, NULL);
      if (err)
	mips_error ("Can't read address %s: %s",
		    paddress (target_gdbarch, addr), safe_strerror (errno));
d2013 1
a2013 1
  return val;
d2079 5
d2085 1
a2085 2
	  store_unsigned_integer (&buffer[0], 4, byte_order,
				  mips_fetch_word (addr));
d2090 2
d2094 4
a2097 2
	  store_unsigned_integer (&buffer[(count - 1) * 4], 4, byte_order,
				  mips_fetch_word (addr + (count - 1) * 4));
d2132 6
a2137 2
	  store_unsigned_integer (&buffer[i * 4], 4, byte_order,
				  mips_fetch_word (addr));
@


1.108
log
@	* remote-mips.c (mips_load): Don't use pseudo-register when
	invalidating regcache.
@
text
@d38 1
d444 5
d492 2
a493 1
  target_mourn_inferior ();
d1573 3
a1575 1
  /* FIXME: Should we call start_remote here?  */
d1651 2
d2154 4
a2157 1
    return;
d2190 2
a2228 2
  /* FIXME: Should we set inferior_ptid here?  */

d2232 2
a2233 1
/* Clean up after a process.  Actually nothing to do.  */
a2239 1
  generic_mourn_inferior ();
d3313 1
d3315 11
a3325 1
  inferior_ptid = null_ptid;	/* No process now */
d3327 2
a3328 5
/* This is necessary because many things were based on the PC at the time that
   we attached to the monitor, which is no longer valid now that we have loaded
   new code (and just changed the PC).  Another way to do this might be to call
   normal_stop, except that the stack may not be valid, and things would get
   horribly confused... */
d3330 12
a3341 1
  clear_symtab_users ();
a3343 1

d3386 2
d3495 1
@


1.107
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d3295 1
a3295 1
			   gdbarch_pc_regnum (get_regcache_arch (regcache)));
@


1.106
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d4 1
a4 1
   2003, 2004, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.105
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d96 1
a96 1
			    char *old_contents);
d1752 1
d1755 3
a1757 3
      store_unsigned_integer (buf,
			      register_size
			        (gdbarch, gdbarch_pc_regnum (gdbarch)), rpc);
d1761 2
a1762 1
	(buf, register_size (gdbarch, gdbarch_pc_regnum (gdbarch)), rfp);
d1765 3
a1767 2
      store_unsigned_integer (buf, register_size (gdbarch,
			      gdbarch_sp_regnum (gdbarch)), rsp);
d1770 3
a1772 5
      store_unsigned_integer (buf,
			      register_size (gdbarch,
					     gdbarch_deprecated_fp_regnum
					       (gdbarch)),
			      0);
d1903 1
d1948 2
a1949 1
    store_unsigned_integer (buf, register_size (gdbarch, regno), val);
d2013 1
a2013 1
mips_store_word (CORE_ADDR addr, unsigned int val, char *old_contents)
d2029 1
a2029 1
    store_unsigned_integer (old_contents, 4, oldcontents);
d2046 1
d2071 2
a2072 1
	  store_unsigned_integer (&buffer[0], 4, mips_fetch_word (addr));
d2079 1
a2079 1
	  store_unsigned_integer (&buffer[(count - 1) * 4], 4,
d2091 3
a2093 3
	  status = mips_store_word (addr,
			       extract_unsigned_integer (&buffer[i * 4], 4),
				    NULL);
d2115 2
a2116 1
	  store_unsigned_integer (&buffer[i * 4], 4, mips_fetch_word (addr));
@


1.104
log
@	* breakpoint.h (struct breakpoint): New member GDBARCH.
	* breakpoint.c: Include "arch-utils.h".
	(set_raw_breakpoint_without_location): Add GDBARCH parameter.
	Use it to set breakpoint architecture.
	(set_raw_breakpoint): Add GDBARCH parameter.
	(create_internal_breakpoint): Likewise.
	(create_catchpoint): Likewise.
	(create_fork_vfork_event_catchpoint): Likewise.
	(create_breakpoint): Likewise.
	(create_breakpoints): Likewise.
	(break_command_really): Likewise.
	(create_ada_exception_breakpoint): Likewise.
	Update local callers to pass architecture:
	(create_internal_breakpoint): Update.
	(create_overlay_event_breakpoint): Update.
	(create_longjmp_master_breakpoint): Update.
	(create_thread_event_breakpoint): Update.
	(create_solib_event_breakpoint): Update.
	(create_catchpoint): Update.
	(create_fork_vfork_event_catchpoint): Update.
	(set_momentary_breakpoint): Update.
	(clone_momentary_breakpoint): Update.
	(create_breakpoint): Update.
	(create_breakpoints): Update.
	(break_command_really): Update.
	(break_command_1): Update.
	(set_breakpoint): Update.
	(watch_command_1): Update.
	(catch_fork_command_1): Update.
	(catch_exec_commnd_1): Update.
	(handle_gnu_v3_exceptions): Update.
	(create_ada_exception_breakpoint): Update.
	(catch_ada_exception_command): Update.
	(catch_assert_command): Update.
	(trace_command): Update.

	* breakpoint.h (struct bp_location): New member GDBARCH.
	* breakpoint.c (get_sal_arch): New function.
	(set_raw_breakpoint): Set location architecture.
	(add_location_to_breakpoint): Likewise.
	(clone_momentary_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(update_watchpoint): Likewise.
	(bp_loc_is_permanent): Use location architecture instead of
	current_gdbarch.
	(adjust_breakpoint_address): Add GDBARCH parameter; use it
	instead of current_gdbarch.
	Update callers of adjust_breakpoint_address to pass
	breakpoint location architecture:
	(set_raw_breakpoint): Update.
	(watch_command_1): Update.

        * tracepoint.c: (collect_symbol): Add GDBARCH parameter, use instead
	of current_gdbarch.
	(add_local_symbols): Add GDBARCH parameter.  Pass to collect_symbol.
	(encode_actions): Pass tracepoint architecture to add_local_symbols
	(encode_actions): Use tracepoint architecture instead of
	current_gdbarch.  Pass it to add_local_symbols and collect_symbol.

	* breakpoint.h (struct breakpoint_ops): Replace last_addr parameter
	of print_one callback with last_loc.
	* breakpoint.c (print_one_breakpoint_location): Replace last_addr
	parameter with last_loc.
	(print_one_breakpoint): Likewise.
	(do_captured_breakpoint_query): Update call.
	(breakpoint_1): Pass last_loc instead of last_addr to
	print_one_breakpoint.  Pass last location architecture instead of
	current_gdbarch to set_next_address.
	Update all implementations of the print_one callback:
	* breakpoint.c (print_one_catch_fork): Update.
	(print_one_catch_vfork): Update.
	(print_one_catch_exec): Update.
	(print_one_exception_catchpoint): Update.
	* ada-lang.c (print_one_exception): Update.
	(print_one_catch_exception): Update.
	(print_one_catch_exception_unhandled): Update.
	(print_one_catch_assert): Update.

	* breakpoint.c (print_one_breakpoint_location): Add PRINT_ADDRESS_BITS
	parameter.  Use it instead of gdbarch_addr_bit (current_gdbarch).
	(print_one_breakpoint): Add PRINT_ADDRESS_BITS parameter and pass it
	to print_one_breakpoint_location.
	(breakpoint_address_bits): New function.
	(do_captured_breakpoint_query): Compute number of address bits to print
	and pass it to print_one_breakpoint.
	(breakpoint_1): Likewise.  Use it instead of current_gdbarch.

	* breakpoint.h (create_thread_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_thread_event_breakpoint): Likewise.
	Update callers to create_thread_event_breakpoint:
	* aix-thread.c (pd_enable): Update.
	* linux-thread-db.c (enable_thread_event): Update.

	* breakpoint.h (create_solib_event_breakpoint): Add GDBARCH.
	* breakpoint.c (create_solib_event_breakpoint): Likewise.
	Update callers to create_solib_event_breakpoint:
	* solib-frv.c (enable_break, enable_break2): Update.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Update.
	* solib-som.c (som_solib_create_inferior_hook): Update.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Update.
	* solib-svr4.c (enable_break): Update.

	* breakpoint.h (insert_single_step_breakpoint): Add GDBARCH.
	* breakpoint.c (insert_single_step_breakpoint): Likewise.
	Update callers to insert_single_step_breakpoint:
	* alpha-tdep.c (alpha_software_single_step): Update.
	* arm-linux-tdep.c (arm_linux_software_single_step): Update.
	* arm-tdep.c (arm_software_single_step): Update.
	* cris-tdep.c (cris_software_single_step): Update.
	* rs6000-aix-tdep.c (rs6000_software_single_step): Update.
	* rs6000-tdep.c (ppc_deal_with_atomic_sequence): Update.
	* sparc-tdep.c (sparc_software_single_step): Update.
	* spu-tdep.c (spu_software_single_step): Update.
	* mips-tdep.c (deal_with_atomic_sequence): Add GDBARCH parameter.
	Pass it to insert_single_step_breakpoint.
	(mips_software_single_step): Pass architecture to
	deal_with_atomic_sequence and insert_single_step_breakpoint.

	* breakpoint.h (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	* breakpoint.c (deprecated_insert_raw_breakpoint): Add GDBARCH.
	(deprecated_remove_raw_breakpoint): Likewise.
	Update callers to deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint:
	* breakpoint.c (single_step_gdbarch): New static variable.
	(insert_single_step_breakpoint): Pass GDBARCH parameter to
	deprecated_insert_raw_breakpoint.  Store it in single_step_gdbarch.
	(remove_single_step_breakpoints): Pass architecture stored in
	single_step_gdbarch to deprecated_remove_raw_breakpoint.
	* rs6000-nat.c (exec_one_dummy_insn): Update.
	* solib-irix.c (enable_break, disable_break): Update.
	* procfs.c (procfs_mourn_inferior): Update.
	(remove_dbx_link_breakpoint): Update.

	* breakpoint.h (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	* breakpoint.c (set_breakpoint): Add GDBARCH parameter.
	(set_momentary_breakpoint, set_momentary_breakpoint_at_pc): Likewise.
	Update callers to set_breakpoint, set_momentary_breakpoint and
	set_momentary_breakpoint_at_pc:
	* breakpoint.c (set_momentary_breakpoint_at_pc): Update.
	(until_break_command): Update.
	* infcall.c (call_function_by_hand): Update.
	* infcmd.c (finish_backward, finish_forward): Update.
	* infrun.c (insert_step_resume_breakpoint_at_sal): Add GDBARCH
	parameter.  Pass it to set_momentary_breakpoint.
	(insert_longjmp_resume_breakpoint): Add GDBARCH parameter.
	Pass it to set_momentary_breakpoint_at_pc.
	(handle_inferior_event): Update.
	(insert_step_resume_breakpoint_at_frame): Update.
	(insert_step_resume_breakpoint_at_caller): Update..
	* mi/mi-cmd-break.c: Include "arch-utils.h".
	(mi_cmd_break_insert): Update.

	* target.h (struct target_ops): Add GDBARCH parameter to
	to_insert_breakpoint, to_remove_breakpoint, to_insert_hw_breakpoint,
	and to_remove_hw_breakpoint members.
	(target_insert_breakpoint, target_remove_breakpoint,
	target_insert_hw_breakpoint, target_remove_hw_breakpoint): Add GDBARCH
	parameter, pass to target routine.
	(memory_remove_breakpoint, memory_insert_breakpoint): Add GDBARCH
	parameter.
	* target.c (debug_to_insert_breakpoint, debug_to_remove_breakpoint,
	debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint): Add
	GDBARCH parameter, pass to target routine.
	(update_current_target): Update function signature.
	* breakpoint.c (insert_bp_location, remove_breakpoint,
	deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint):
	Pass architecture to target_ routines.
	Update all implementations of the target breakpoint routines to take
	GDBARCH parameter and use it instead of GDBARCH as appropriate:
	* corelow.c (ignore): Update.
	* exec.c (ignore): Update.
	* mem-break.c (memory_insert_breakpoint): Update.
	(memory_remove_breakpoint): Update.
	* monitor.c (monitor_insert_breakpoint): Update.
	(monitor_remove_breakpoint): Update.
	* record.c (record_insert_breakpoint): Update.
	(record_beneath_to_insert_breakpoint): Update.
	(record_remove_breakpoint): Update.
	(record_beneath_to_remove_breakpoint): Update.
	* remote.c (remote_insert_breakpoint): Update.
	(remote_remove_breakpoint): Update.
	(remote_insert_hw_breakpoint): Update.
	(remote_remove_hw_breakpoint): Update.
	* remote-m32r-sdi.c (m32r_insert_breakpoint): Update.
	(m32r_remove_breakpoint): Update.
	* remote-mips.c (mips_insert_breakpoint): Update.
	(mips_remove_breakpoint): Update.
	* i386-nat.c (i386_insert_hw_breakpoint): Update.
	(i386_remove_hw_breakpoint): Update.
	* nto-procfs.c (procfs_insert_breakpoint):  Update.
	(procfs_remove_breakpoint): Update.
	(procfs_insert_hw_breakpoint): Update.
	(procfs_remove_hw_breakpoint): Update.

doc/ChangeLog:

	* gdbint.texi (Examples of Use of @@code{ui_out} functions):
	Update example code extrated from breakpoint.c.
@
text
@d1190 1
d1206 2
a1207 1
      sprintf (buff, "0x0 %c 0x%s 0x%s", cmd, paddr_nz (addr), paddr_nz (data));
d1998 2
a1999 2
	mips_error ("Can't read address 0x%s: %s",
		    paddr_nz (addr), safe_strerror (errno));
d2346 1
a2346 1
  char *saddr = paddr_nz (addr);	/* printable address string */
d2363 1
a2363 1
mips_common_breakpoint (0x%s): Warning: %s\n",
d2370 1
a2370 1
mips_common_breakpoint (0x%s): Unknown warning: 0x%x\n",
d2383 1
a2383 1
mips_common_breakpoint (0x%s): Error: %s\n",
d2390 1
a2390 1
mips_common_breakpoint (0x%s): Unknown error: 0x%x\n",
d2413 1
d2447 1
a2447 1
		       paddr_nz (addr));
d2496 1
a2496 1
	      sprintf (buf, "0x0 B 0x%s 0x0", paddr_nz (addr));
d2502 4
a2505 3
	      sprintf (buf, "0x0 A 0x%s 0x%x 0x%s", paddr_nz (addr),
		     type == BREAK_READ ? 1 : (type == BREAK_WRITE ? 2 : 3),
		       paddr_nz (addr + len - 1));
d2566 2
a2567 2
	  sprintf (buf, "0x0 B 0x%s 0x%s %s", paddr_nz (addr),
		   paddr_nz (mask), flags);
d2572 1
a2572 1
	  sprintf (buf, "0x0 b 0x%s", paddr_nz (addr));
d2596 2
a2597 2
mips_common_breakpoint (0x%s):  Got error: 0x%x\n",
				paddr_nz (addr), rresponse);
d2623 2
a2624 1
	  fprintf_unfiltered (gdb_stderr, "Download got a NACK at byte 0x%s!  Retrying.\n", paddr_nz (addr));
@


1.103
log
@	* target.h (struct target_ops): Make to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	methods instead of variables.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1)
	(target_has_registers_1, target_has_execution_1): Declare
	functions.
	(target_has_all_memory): Rewrite to call target_has_all_memory_1.
	(target_has_memory): Rewrite to call target_has_memory_1.
	(target_has_stack): Rewrite to call target_has_all_stack_1.
	(target_has_registers): Rewrite to call target_has_registers_1.
	(target_has_execution): Rewrite to call target_has_execution_1.
	(default_child_has_all_memory, default_child_has_memory)
	(default_child_has_stack, default_child_has_registers)
	(default_child_has_execution): Declare.
	(target_mark_running, target_mark_exited): Delete declarations.
	* target.c (default_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution): New.
	(target_has_all_memory_1, target_has_memory_1, target_has_stack_1,
	target_has_registers_1, target_has_execution_1): New.
	(add_target): Default the to_has_all_memory, to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers and to_has_execution
	callbacks to return 0.
	(update_current_target): Do not inherit to_has_all_memory,
	to_has_memory, to_has_stack, to_has_registers or to_has_execution.
	(target_mark_running, target_mark_exited): Delete.
	(memory_xfer_partial): Adjust.
	(target_read_memory, target_write_memory, target_search_memory):
	Dispatch to the the top-most target, not the flattened
	current_target.
	(target_info): Adjust.
	(init_dummy_target): Install return_zero as callback for
	to_has_all_memory, to_has_memory, to_has_stack, to_has_registers,
	to_has_execution.
	(set_maintenance_target_async_permitted): Use have_live_inferiors
	instead of target_has_execution.
	* target-memory.c (target_write_memory_blocks): Dispatch memory
	writes to the the top-most target, not the flattened
	current_target.

	* breakpoint.c (insert_breakpoints): Don't check for
	target_has_execution here.
	(update_global_location_list): Check if there are live inferiors
	to debug instead of target_has_execution.
	* infcmd.c (kill_command, detach_command): Check if there are
	inferiors instead of target_has_execution.
	* inferior.h (have_live_inferiors): Declare.
	* inferior.c (have_live_inferiors): New.
	* infrun.c (normal_stop): Don't check for target_has_execution to
	finish the thread states.
	* thread.c (is_thread_state, is_stopped, is_exited, is_running)
	(any_running, is_executing): Remove checks for
	target_has_execution.
	* top.c (kill_or_detach): Don't try to kill core inferiors.
	(quit_target): Don't check for target_has_execution.

	* corelow.c (core_has_memory, core_has_stack, core_has_registers):
	New.
	(init_core_ops): Install core_has_memory, core_has_stack and
	core_has_registers.
	* exec.c (exec_has_memory): New.
	(init_exec_ops): Install exec_has_memory.
	* remote.c (remote_add_inferior): Don't call target_mark_running.
	(remote_start_remote): Don't call target_mark_exited or call
	target_mark_running.
	(remote_open_1): Use have_inferiors instead of
	target_has_execution.  Don't use target_mark_exited.
	(init_remote_ops): Install deafult_child_has_all_memory,
	default_child_has_memory, default_child_has_stack,
	default_child_has_registers, default_child_has_execution.
	* bsd-kvm.c (bsd_kvm_return_one): New.
	(bsd_kvm_add_target): Register bsd_kvm_return_one as
	to_has_memory, to_has_stack and to_has_registers callbacks.
	* remote-m32r-sdi.c (m32r_return_one): New.
	(init_m32r_ops): Register it.
	* inf-child.c (inf_child_target): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.
	* gnu-nat.c (init_gnu_ops): Likewise.
	* go32-nat.c (init_go32_ops): Likewise.
	* hpux-thread.c (init_hpux_thread_ops): Likewise.
	* monitor.c (init_base_monitor_ops): Likewise.
	* nto-procfs.c (init_procfs_ops): Likewise.
	* remote-mips.c (_initialize_remote_mips): Likewise.
	* windows-nat.c (init_windows_ops): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Don't use
	target_mark_running or target_mark_exited.
	(gdbsim_mourn_inferior): Don't call target_mark_exited.
	(init_gdbsim_ops): Adjust to register
	default_child_has_all_memory, default_child_has_memory,
	default_child_has_stack, default_child_has_registers,
	default_child_has_execution callbacks.

	* linux-nat.c (linux_nat_xfer_partial): If reading memory, and
	there's no inferior selected, defer to a lower stratum.
@
text
@d2231 2
a2232 1
mips_insert_breakpoint (struct bp_target_info *bp_tgt)
d2238 1
a2238 1
    return memory_insert_breakpoint (bp_tgt);
d2242 2
a2243 1
mips_remove_breakpoint (struct bp_target_info *bp_tgt)
d2249 1
a2249 1
    return memory_remove_breakpoint (bp_tgt);
@


1.102
log
@	* target.h (TARGET_WNOHANG): New.
	* target.c (target_wait): Add `options' argument.  Adjust.
	(struct target_ops) <to_wait>: Add `options' argument.
	(target_wait): Add `options' argument.
	* infrun.c (wait_for_inferior): Pass 0 as options to
	target_wait (blocking wait).
	(fetch_inferior_event): Pass TARGET_WNOHANG as options to
	target_wait.
	* fork-child.c (startup_inferior): Pass 0 as options to
	target_wait (blocking wait).
	* linux-nat.c (linux_nat_create_inferior): Remove async masking.
	(linux_nat_wait_1): Add `target_options' argument.  Use it instead
	of checking on target_can_async_p.
	(linux_nat_wait): Add `target_options' argument.  Adjust.
	* remote.c (remote_wait_ns): Add `options' argument.  Adjust to
	check on TARGET_WNOWAIT instead of checking on remote_is_async_p.
	(remote_wait_as): Add `options' argument.  Adjust to check on
	TARGET_WNOWAIT instead of checking on remote_is_async_p.  If doing
	a blocking wait, keep waiting until an interesting event comes
	out.
	(remote_wait): Add `options' argument.  Don't loop here if the
	target is in async mode, and a blocking wait has been requested.

	* top.c (deprecated_target_wait_hook): Add `options' argument.
	* linux-thread-db.c (thread_db_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ptrace.c (inf_ptrace_wait): Add `options' argument.
	* record.c (record_beneath_to_wait): Add `options' argument.
	(record_wait): Add `options' argument, and pass it down to the
	layer beneath.
	* bsd-uthread.c (bsd_uthread_wait): Add `options' argument.
	* darwin-nat.c (darwin_wait): Likewise.
	* defs.h (deprecated_target_wait_hook): Likewise.
	* gnu-nat.c (gnu_wait): Add `options' argument.
	* go32-nat.c (go32_wait): Likewise.
	* hpux-thread.c (hpux_thread_wait): Add `options' argument, and
	pass it down to the layer beneath.
	* inf-ttrace.c (inf_ttrace_wait): Add `options' argument.
	* monitor.c (monitor_wait): Likewise.
	* nto-procfs.c (procfs_wait): Likewise.
	* remote-mips.c (mips_wait): Add `options' argument.
	* remote-sim.c (gdbsim_wait): Likewise.
	* rs6000-nat.c (rs6000_wait): Add `options' argument.
	* sol-thread.c (sol_thread_wait): Add `options' argument, and pass
	it down to the layer beneath.
	* spu-linux-nat.c (spu_child_wait): Add `options' argument.
	* windows-nat.c (windows_wait): Likewise.
	* tui/tui-hooks.c (tui_target_wait_hook): Likewise.  Adjust.
@
text
@d3343 5
a3347 5
  mips_ops.to_has_all_memory = 1;
  mips_ops.to_has_memory = 1;
  mips_ops.to_has_stack = 1;
  mips_ops.to_has_registers = 1;
  mips_ops.to_has_execution = 1;
@


1.101
log
@	Unify target macros.

	* target.h (STOPPED_BY_WATCHPOINT): Delete, replaced by ...
	(target_stoppped_by_watchpoint): New macro.
	(HAVE_STEPPABLE_WATCHPOINT): Delete, replaced by ...
	(target_have_steppable_watchpoint): New macro.
	(HAVE_CONTINUABLE_WATCHPOINT): Delete, replace by ...
	(target_have_continuable_watchpoint): New macro.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT):Delete, replaced by ...
	(target_can_use_hardware_watchpoint): New macro.
	(TARGET_REGION_OK_FOR_HW_WATCHPOINT):Delete, replaced by ...
	(target_region_ok_for_hw_watchpoint): New macro.

	* breakpoint.c (update_watchpoint): Use new macros.
	(bpstat_alloc): Likewise.
	(create_breakpoint): Likewise.
	(watch_command_1): Likewise.
	(can_use_hardware_watchpoint): Likewise.
	(do_enable_breakpoint): Likewise.
	* infrun.c (handle_inferior_event): Adapt to new macros.
	* mips-tdep.c (mips_gdbarch_init): Update comments.
	* procfs.c (procfs_set_watchpoint): Update comment.
	(procfs_insert_watchpoint): Adapt to new macros.
	* remote-m32r-sdi.c (m32r_stop):
	* remote-mips.c (mips_remove_breakpoint):
	* target.c (debug_to_region_ok_for_hw_watchpoint): Update to new macros.
	(debug_to_stopped_by_watchpoint): Likewise.
@
text
@d1698 1
a1698 1
	   ptid_t ptid, struct target_waitstatus *status)
@


1.100
log
@	* inferior.h (read_pc, write_pc): Remove.
	* regcache.c (read_pc, write_pc): Remove.

	* infrun.c (displaced_step_fixup): Use regcache_read_pc instead
	of read_pc.
	(handle_inferior_event): Use regcache_read_pc instead of read_pc
	when determining value of stop_pc.  Replace subsequent uses of
	read_pc by inspecting already-retrieved stop_pc value.
	(keep_going): Use regcache_read_pc instead of read_pc.

	* breakpoint.c (watchpoint_check): Use current frame architecture
	and PC instead of current_gdbarch and read_pc ().
	* tracepoint.c (set_traceframe_context): Replace PC argument
	with FRAME argument.
	(trace_start_command, finish_tfind_command): Update calls.
	(finish_tfind_command): Compare frame IDs to identify transitions
	between frames.
	(trace_find_pc_command): Use regcache_read_pc instead of read_pc.
	* rs6000-nat.c (exec_one_dummy_insn): Pass in regcache instead
	of gdbarch.  Use regcache_read_pc and regcache_write_pc instead
	of read_pc and write_pc.
	(store_register): Make regcache argument non-const.  Update call
	to exec_one_dummy_insn.

	* thread.c (switch_to_thread): Use regcache_read_pc instead of read_pc.
	* infcmd.c (post_create_inferior): Likewise.
	* solib-darwin.c (darwin_solib_create_inferior_hook): Likewise.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (enable_break, svr4_relocate_main_executable): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code): Likewise.
	* record.c (record_wait): Likewise.
	* procfs.c (procfs_wait): Likewise.
	* remote-mips.c (common_open, mips_wait): Likewise.
	* remote-m32r-sdi.c (m32r_resume): Likewise.

	* symfile.c (generic_load): Use regcache_write_pc instead of write_pc.
	* monitor.c (monitor_create_inferior, monitor_load): Likewise.
	* m32r-rom.c (m32r_load, m32r_upload_command): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior, m32r_load): Likewise.
	* remote-mips.c (mips_create_inferior, mips_load): Likewise.

	* solib-darwin.c: Include "regcache.h".
	* solib-pa64.c: Include "regcache.h".
	* solib-svr4.c: Include "regcache.h.".

	* symfile.c: Do not mention read_pc or write_pc in comments.
	* dink32-rom.c: Likewise.
	* m32r-rom.c: Likewise.
	* mips-tdep.c: Likewise.
@
text
@d2252 1
a2252 1
   implements the TARGET_CAN_USE_HARDWARE_WATCHPOINT macro.  */
@


1.99
log
@        Add a target_ops parameter to the to_kill method in struct target_ops.

        * target.h (struct target_ops): Add a "target_ops *" parameter to
        method to_kill.
        (target_kill): Remove macro. Add declaration.
        * target.c (debug_to_kill): Delete, no longer necessary.
        (target_kill): New function.
        (update_current_target):  Stop inheriting the to_kill method.
        Do not de_fault it to no_process either.
        (setup_target_debug): Do not set current_target.to_kill.
        * gnu-nat.c, go32-nat.c, hpux-thread.c, inf-ptrace.c, inf-ttrace.c,
        linux-nat.c, monitor.c, nto-procfs.c, procfs.c, remote-m32r-sdi.c,
        remote-mips.c, remote-sim.c, remote.c, windows-nat.c: Update
        accordingly.
@
text
@d1576 1
a1576 1
  stop_pc = read_pc ();
d1795 1
a1795 1
      CORE_ADDR pc = read_pc ();
d1846 1
a1846 1
	  CORE_ADDR pc = read_pc ();
d2207 1
a2207 1
  write_pc (entry_pt);
d3261 2
d3275 1
d3280 1
a3280 2
         that the write_pc() WILL update the PC value: */
      struct regcache *regcache = get_current_regcache ();
d3285 1
a3285 1
    write_pc (bfd_get_start_address (exec_bfd));
@


1.98
log
@        * remote-mips.c (mips_load): Replace call to regcache_set_valid_p,
        which is undefined, by call to regcache_invalidate, which should
        do what the original author wanted to do.
@
text
@d2132 1
a2132 1
mips_kill (void)
a3278 1

@


1.97
log
@        * remote-mips.c (mips_mourn_inferior): Add missing ops parameter.
        (mips_create_inferior): Likewise.
@
text
@d3279 3
a3281 3
      regcache_set_valid_p (regcache,
			    gdbarch_pc_regnum (get_regcache_arch (regcache)),
					       0);
@


1.96
log
@2009-02-25  Hui Zhu  <teawater@@gmail.com>

	* cli/cli-script.c (define_command): Add _() to query.
	* gnu-nat.c (inf_validate_task_sc): Ditto.
	* infcmd.c (kill_if_already_running): Ditto.
	(jump_command): Ditto.
	(attach_command): Ditto.
	* inflow.c (kill_command): Ditto.
	* infrun.c (handle_command): Ditto.
	* maint.c (maintenance_dump_me): Ditto.
	* memattr.c (mem_delete_command): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* printcmd.c (undisplay_command): Ditto.
	* remote-mips.c (mips_kill): Ditto.
	* remote.c (interrupt_query): Ditto.
	* solib-irix.c (irix_open_symbol_file_object): Ditto.
	* solib-osf.c (osf_open_symbol_file_object): Ditto.
	* solib-pa64.c (pa64_open_symbol_file_object): Ditto.
	* solib-som.c (som_open_symbol_file_object): Ditto.
	* solib-svr4.c (open_symbol_file_object): Ditto.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Ditto.
	* target.c (kill_or_be_killed): Ditto.
	* tracepoint.c (delete_trace_command): Ditto.
	* top.c (quit_confirm): Add _() to s that will be used
	in query.
@
text
@d105 1
a105 1
static void mips_mourn_inferior (void);
d2185 2
a2186 1
mips_create_inferior (char *execfile, char *args, char **env, int from_tty)
d2213 1
a2213 1
mips_mourn_inferior (void)
@


1.95
log
@	* corelow.c (get_core_registers): Adjust.
	(core_file_thread_alive): Rename to...
	(core_thread_alive): ... this.
	(core_pid_to_str): Try gdbarch_core_pid_to_str first.
	(init_core_ops): Adjust.
	(coreops_suppress_target): Delete.
	(_initialize_corelow): Unconditionally add core_ops.
	* procfs.c: Include "inf-child.h".
	(procfs_ops): Delete.
	(init_procfs_ops): Delete.  Reimplement as...
	(procfs_target): ... this, inheriting from inf-child.
	(procfs_attach, procfs_detach, procfs_fetch_registers): Adjust.
	(procfs_prepare_to_store): Delete.
	(procfs_store_registers, procfs_resume): Adjust.
	(procfs_open): Delete.
	(procfs_suppress_run): Delete.
	(procfs_can_run): Delete.
	(procfs_mourn_inferior): Adjust.
	(procfs_init_inferior): Add target_ops parameter.  Adjust.
	(procfs_create_inferior): Don't pass procfs_init_inferior to
	fork_inferior.  Instead call it after fork_inferior returns.
	(procfs_find_new_threads): Adjust.
	(_initialize_procfs): Adjust to use procfs_target instead of
	init_procfs_ops.
	* sol-thread.c (orig_core_ops, sol_core_ops): Delete.
	(lwp_to_thread): Use target_thread_alive.
	(sol_thread_open): Delete.
	(sol_thread_attach): Delete.
	(sol_thread_detach, sol_thread_resume, sol_thread_wait)
	(sol_thread_fetch_registers, sol_thread_store_registers): Adjust
	to use find_target_beneath.
	(sol_thread_prepare_to_store, sol_thread_xfer_memory): Delete.
	(sol_thread_xfer_partial): Adjust to use find_target_beneath.
	(sol_thread_files_info, sol_thread_kill_inferior): Delete.
	(check_for_thread_db): New.
	(sol_thread_notice_signals, sol_thread_create_inferior): Delete.
	(sol_thread_new_objfile): Call check_for_thread_db.
	(sol_thread_mourn_inferior): Adjust to use find_target_beneath.
	(sol_thread_can_run): Delete.
	(sol_thread_alive): Adjust to use find_target_beneath.
	(sol_thread_stop): Delete.
	(rw_common): Use target_write_memory or target_read_memory.
	(ps_lgetregs, ps_lgetfpregs): Use target_fetch_registers.
	(ps_lsetregs, ps_lsetfpregs): Use target_store_registers.
	(solaris_pid_to_str): Remove check for libthread_db initialization
	failing.
	(sol_find_new_threads): Remove check for libthread_db
	initialization failing, or for an invalid inferior_ptid.  Adjust
	to use find_target_beneath.
	(sol_core_open, sol_core_close, sol_core_detach,
	sol_core_files_info, sol_find_memory_regions,
	sol_make_note_section, ignore): Delete.
	(init_sol_thread_ops): Make it a thread_stratum target.  Remove
	unneeded callback settings.
	(init_sol_core_ops): Delete.
	(_initialize_sol_thread): No longer call init_sol_core_ops, set
	procfs_suppress_run, or hack with core_ops.

	* target.h (struct target_ops): Add a target_ops * parameter to
	to_resume, to_fetch_registers, to_store_registers, to_thread_alive
	and to_find_new_threads.
	(target_fetch_registers, target_store_registers)
	(target_thread_alive, target_find_new_threads): Redeclare as
	function.

	* target.c (update_current_target): Do not inherit or de_fault
	to_resume, to_fetch_registers, to_store_registers,
	to_thread_alive, to_find_new_threads.
	(target_resume): Adjust.
	(target_thread_alive, target_find_new_threads): New.
	(debug_to_resume, debug_to_fetch_registers): Delete.
	(target_fetch_registers): New.
	(debug_to_store_registers): Delete.
	(target_store_registers): New.
	(debug_to_thread_alive, debug_to_find_new_threads): Delete.
	(setup_target_debug): Adjust.

	* gdbcore.h (core_ops): Delete declaration.

	* inf-ptrace.c, linux-nat.c, remote.c, amd64-linux-nat.c,
	inf-child.c, linux-thread-db.c, bsd-uthread.c, inf-ttrace.c,
	i386-sol2-tdep.c, darwin-nat.c, gnu-nat.c, go32-nat.c,
	hpux-thread.c, i386-linux-nat.c, i386fbsd-nat.c, monitor.c,
	nto-procfs.c, remote-m32r-sdi.c, remote-mips.c, windows-nat.c,
	alphabsd-nat.c, amd64bsd-nat.c, arm-linux-nat.c, armnbsd-nat.c,
	bsd-kvm.c, hppa-hpux-nat.c, hppa-linux-nat.c, hppabsd-nat.c,
	hppanbsd-nat.c, i386-darwin-nat.c, i386bsd-nat.c,
	ia64-linux-nat.c, m32r-linux-nat.c, m68kbsd-nat.c,
	m68klinux-nat.c, m88kbsd-nat.c, mips-linux-nat.c,
	mips64obsd-nat.c, mipsnbsd-nat.c, ppc-linux-nat.c, ppcnbsd-nat.c,
	ppcobsd-nat.c, remote-sim.c, rs6000-nat.c, s390-nat.c,
	shnbsd-nat.c, sparc-nat.c, sparc-nat.h, spu-linux-nat.c,
	vaxbsd-nat.c, xtensa-linux-nat.c: Adjust to target_ops changes.

	* gdbarch.sh (core_pid_to_str): New gdbarch callback.
	* gdbarch.h, gdbarch.c: Regenerate.

	* sol2-tdep.c: Include "inferior.h".
	(sol2_core_pid_to_str): New.
	* sol2-tdep.h (sol2_core_pid_to_str): Declare.

	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Set it.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Set it.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Set it.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Set it.
@
text
@d2145 2
a2146 2
      if (query ("Interrupted while waiting for the program.\n\
Give up (and stop debugging it)? "))
@


1.94
log
@	* linux-nat.c (linux_nat_wait): Adjust.
	(linux_nat_pid_to_str): Adjust.  Remove call to thread_db_init.
	* linux-nat.h (thread_db_init): Delete declaration.
	* linux-thread-db.c (target_beneath): Delete.
	(thread_db_init): Delete.
	(thread_db_detach): Use find_target_beneath.
	(thread_db_wait): Adjust interface.  Use find_target_beneath.
	(thread_db_mourn_inferior): Use find_target_beneath.
	(thread_db_can_async_p, thread_db_is_async_p, thread_db_async)
	(thread_db_async_mask): Delete.
	(thread_db_pid_to_str): Adjust interface.  Use
	find_target_beneath.
	(thread_db_get_thread_local_address): Adjust interface.  Use
	find_target_beneath.
	(init_thread_db_ops): Delete references to delete functions.
	* target.c (update_current_target): Don't inherit or default
	to_wait.  Don't inherit to_pid_to_str and
	to_get_thread_local_address.
	(target_translate_tls_address): Look for a pushed target that
	implements to_get_thread_local_address, and use it instead of
	checking for target_get_thread_local_address_p.
	(target_wait, target_pid_to_str): Reimplement as functions.
	(dummy_pid_to_str): New.
	(init_dummy_target): Register it.
	(debug_to_wait): Delete.
	* target.h (struct target_ops): Make to_wait, to_pid_to_str and
	to_get_thread_local_address accept a pointer to struct target_ops.
	(target_wait): Delete macro, and declare as function.
	(target_pid_to_str): Likewise.
	(target_get_thread_local_address)
	(target_get_thread_local_address_p): Delete.
	(noprocess): Add NORETURN and ATTR_NORETURN tags.
	* inf-ptrace.c (inf_ptrace_wait): Adjust.
	(inf_ptrace_pid_to_str): New.
	(inf_ptrace_target): Use inf_ptrace_pid_to_str.
	* aix-thread.c (aix_thread_wait, aix_thread_pid_to_str): Adjust.
	* bsd-kvm.c (bsd_kvm_pid_to_str): Adjust.
	* bsd-uthread.c (bsd_uthread_wait, bsd_uthread_pid_to_str):
	Adjust.
	* corelow.c (core_pid_to_str): Adjust.
	* darwin-nat.c (darwin_wait, darwin_pid_to_str): Adjust.
	* dec-thread.c (dec_thread_wait, dec_thread_pid_to_str): Adjust.
	* gnu-nat.c (gnu_wait, gnu_pid_to_str): Adjust.
	* go32-nat.c (go32_wait, go32_pid_to_str): Adjust.
	* hpux-thread.c (hpux_thread_wait): Adjust.
	* inf-ttrace.c (inf_ttrace_wait, inf_ttrace_pid_to_str): Adjust.
	* monitor.c (monitor_wait, monitor_pid_to_str): Adjust.
	* nto-procfs.c (procfs_wait, procfs_pid_to_str): Adjust.
	* procfs.c (procfs_pid_to_str): Adjust.
	* remote-m32r-sdi.c (m32r_wait, m32r_pid_to_str): Adjust.
	* remote-mips.c (mips_wait): Adjust.
	* remote-sim.c (gdbsim_wait, gdbsim_pid_to_str): Adjust.
	* remote.c (remote_wait, remote_pid_to_str)
	(remote_get_thread_local_address): Adjust.
	* rs6000-nat.c (rs6000_wait): Adjust.
	* sol-thread.c (procfs_pid_to_str): Adjust declaration.
	(sol_thread_wait, solaris_pid_to_str): Adjust.
	* spu-linux-nat.c (spu_child_wait): Adjust.
	* windows-nat.c (windows_wait, windows_pid_to_str): Adjust.
@
text
@a88 3
static void mips_resume (ptid_t ptid, int step,
                         enum target_signal siggnal);

a90 2
static void mips_fetch_registers (struct regcache *regcache, int regno);

a92 2
static void mips_store_registers (struct regcache *regcache, int regno);

d1663 2
a1664 1
mips_resume (ptid_t ptid, int step, enum target_signal siggnal)
d1896 2
a1897 1
mips_fetch_registers (struct regcache *regcache, int regno)
d1906 1
a1906 1
	mips_fetch_registers (regcache, regno);
d1960 2
a1961 1
mips_store_registers (struct regcache *regcache, int regno)
d1970 1
a1970 1
	mips_store_registers (regcache, regno);
@


1.93
log
@        Updated copyright notices for most files.
@
text
@a91 3
static ptid_t mips_wait (ptid_t ptid,
                               struct target_waitstatus *status);

d1703 2
a1704 1
mips_wait (ptid_t ptid, struct target_waitstatus *status)
@


1.92
log
@	Kill pthread_ops_hack

	* target.h (struct target_ops): Make to_attach, to_detach,
	to_create_inferior and to_mourn_inferior accept a pointer
    	to struct target_ops.
	(target_attach, target_create_inferior, target_create_inferior):
	Convert from macros to function.  Find the right target to
	invoke a method of.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.
	* corefile.c (core_file_command): Pass target to to_detach.
	* corelow.c (core_detach): Add 'ops' parameter.
	* fork-child.c (fork_inferior): Return the pid.  Allow
	init_trace_fun to be NULL.
	* inf-ptrace (ptrace_ops_hack): Remove.
	(inf_ptrace_him): Remove, moving all logic into....
	(inf_ptrace_create_inferior): ... here.  Push the target
	passed as parameter.
	(inf_ptrace_mourn_inferior, inf_ptrace_attach, inf_ptrace_detach):
	Push/pop target passed as parameter, no ptrace_ops_hack.
	(inf_ptrace_target): Don't remember result.
	* inferior.h (fork_inferior): Adjust prototype.
	* linux-nat.c (linux_nat_create_inferior, linux_nat_attach)
	(linux_nat_detach, linux_nat_mourn_inferior): New parameter ops.
	Pass it to linux_ops target.
	* linux-thread-db.c (thread_db_detach, thread_db_mourn_inferior):
	New parameter ops. Pass it to the target beneath.
	* remote.c (remote_mourn, extended_remote_mourn, remote_detach)
	(extended_remote_create_inferior): New parameter ops. Pass it
	further.
	* target.c (debug_to_attach, debug_to_detach)
	(debug_to_mourn_inferior): New parameter ops.
	(target_create_inferior): New.
	(update_current_target): Do not inherit to_attach, to_detach,
	to_create_inferiour, to_mourn_inferior.  Do not default
	to_detach and to_mourn_inferior.
	(target_detach): Find the right target to use.
	(target_mourn_inferior): New.
	(find_default_attach, find_default_create_inferior): New parameter
	ops.  Pass the found target when calling its method.
	(init_dummy_target): Provide fallback definition of to_detach.
	(target_attach): New.
	(debug_to_attach, debug_to_detach, debug_to_create_inferior)
	(debug_to_mourn_inferiour): New parameter ops.
        * aix-thread.c: Adjust.
        * bsd-uthread.c: Adjust.
        * gnu-nat.c: Adjust.
        * go32-nat.c: Adjust.
        * hpux-thread.c: Adjust.
        * inf-ttrace.c: Ajust.
        * monitor.c: Adjust.
        * nto-procfs.c: Adjust.
        * procfs.c: Adjust.
        * remote-m32r-sdi.c: Adjust.
        * remote-mips.c: Adjust.
        * remote-sim.c: Adjust.
        * rs6000-nat.c: Adjust.
        * sol-thread.c: Adjust.
        * win32-nat.c: Adjust.
	* dec-thread.c: Adjust.
@
text
@d4 1
a4 1
   2003, 2004, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.91
log
@2008-10-03  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* utils.c, defs.h (gdb_buildargv): New fn. Wrap buildargv
	and check for out-of-memory condition.
	* exec.c (exec_file_command): Call it.
	* infrun.c (handle_command, xdb_handle_command): Likewise.
	* interps.c (interpreter_exec_cmd): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* procfs.c (info_proc_cmd): Likewise.
	* remote-mips.c (common_open): Likewise.
	* remote-sim.c (gdbsim_kill, gdbsim_create_inferior)
	(gdbsim_open): Likewise.
	* remote.c (extended_remote_run, remote_put_command)
	(remote_get_command, remote_delete_command): Likewise.
	* ser-mingw.c (pipe_windows_open): Likesise.
	* source.c (add_path, show_substitute_path_command)
	(unset_substitute_path_command, set_substitute_path_command):
	Likewise.
	* stack.c (backtrace_command): Likewise.
	* symfile.c (symbol_file_command, generic_load)
	(add_symbol_file_command): Likesise.
	* symmisc.c (maintenance_print_symbols, maintenance_print_psymbols)
	(maintenance_print_msymbols): Likewise.
@
text
@d87 1
a87 1
static void mips_detach (char *args, int from_tty);
d1655 1
a1655 1
mips_detach (char *args, int from_tty)
@


1.90
log
@	* defs.h (plongest,pulongest): Renamed from paddr_u,paddr_d.
	Change argument of pulongest from CORE_ADDR to ULONGEST.
	All callers updated.
	* utils.c (plongest): Renamed from paddr_d.
	(pulongest): Renamed from paddr_u, change arg type to ULONGEST.
	* remote-mips.c (send_srec): Use paddr_nz instead of paddr_u in
	`CORE_ADDR addr' arg of error message.
@
text
@d1493 1
a1493 2
  if ((argv = buildargv (name)) == NULL)
    nomem (0);
@


1.89
log
@	* gdbarch.sh (target_gdbarch): New global variable.
	(deprecated_current_gdbarch_select_hack): Set it.
	* gdbarch.c, gdbarch.h: Regenerate.

	* arch-utils.c (gdbarch_update_p): Use target_gdbarch instead
	of current_gdbarch.
	* target-descriptions.c (target_find_description): Likewise.
	* arm-tdep.c (arm_update_current_architecture): Likewise.
	(show_fp_model, arm_show_abi, arm_show_fallback_mode,
	arm_show_force_mode): Likewise.
	* mips-tdep.c (show_mask_address, show_mipsfpu_command,
	show_mips_abi): Likewise.
	* mep-tdep.c (me_module_register_set, current_me_module): Likewise.

	* target.c (target_translate_tls_address): Use target_gdbarch
	instead of current_gdbarch.
	* remote.c (struct packet_reg): Likewise.
	(get_remote_arch_state, packet_reg_from_regnum,
	packet_reg_from_pnum, remote_check_symbols, remote_wait,
	remote_address_masked, remote_insert_breakpoint,
	remote_insert_hw_breakpoint, remote_read_description): Likewise.
	* remote-m32r-sdi.c (m32r_resume, m32r_wait): Likewise.
	* remote-mips.c (mips_open, mips_common_breakpoint): Likewise.
	* cris-tdep.c (cris_can_use_hardware_watchpoint): Likewise.

	* solib.c (solib_open, solib_map_sections, solib_read_symbols,
	solib_add, info_sharedlibrary_command, solib_address,
	solib_create_inferior_hook, in_solib_dynsym_resolve_code,
	solib_global_lookup): Likewise.
	* solib-frv.c (enable_break2, frv_relocate_main_executable): Likewise.
	* solib-irix.c (irix_current_sos, irix_open_symbol_file_object):
	Likewise.
	* solib-sunos.c (sunos_solib_create_inferior_hook): Likewise.
	* solib-svr4.c (exec_entry_point, enable_break, svr4_free_so,
	set_solib_svr4_fetch_link_map_offsets, svr4_fetch_link_map_offsets):
	Likewise.
	* nto-tdep.c (nto_find_and_open_solib, nto_init_solib_absolute_prefix,
	nto_truncate_ptr): Likewise.
	* mips-linux-tdep.c (mips_linux_in_dynsym_stub): Likewise.
@
text
@d2623 1
a2623 1
	  fprintf_unfiltered (gdb_stderr, "Download got a NACK at byte %s!  Retrying.\n", paddr_u (addr));
@


1.88
log
@
	* mips-tdep.c (fp_register_arg_p): Add gdbarch as paramter.
	(mips_n32n64_push_dummy_call, mips_o64_return_value)
	(mips_eabi_push_dummy_call): Update call to fp_register_arg_p.

	(MIPS_FPU_TYPE): Add gdbarch as parameter and replace current_gdbarch.
	(fp_register_arg_p, mips_dump_tdep, show_mipsfpu_command)
	(mips_n32n64_fp_arg_chunk_p): Update caller.

	(mips_n32n64_fp_arg_chunk_p): Add gdbarch as paramter.
	(mips_n32n64_push_dummy_call): Update caller.

	(MIPS_LAST_ARG_REGNUM): Add gdbarch as parameter and replace
	current_gdbarch.
	(mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call)
	(mips_o32_push_dummy_call, mips_o64_push_dummy_call): Update caller.


	(MIPS_LAST_FP_ARG_REGNUM): Add gdbarch as parameter and replace
	current_gdbarch.
	(mips_eabi_push_dummy_call, mips_o32_push_dummy_call)
	(mips_o64_push_dummy_call): Update caller.

	(MIPS_EABI): Add gdbarch as parameter and replace current_gdbarch.
	(fp_register_arg_p, mips_dump_tdep): Update caller.

	(set_reg_offset): Add gdbarch as parameter and replace current_gdbarch.
	(mips16_scan_prologue, mips32_scan_prologue): Update caller.

	(reset_saved_regs): Make static.  Add gdbarch as parameter.  Replace
	current_gdbarch.
	(mips32_scan_prologue): Update caller.

	(heuristic_proc_start): Add gdbarch as parameter. Replace
	current_gdbarch.
	(mips_insn16_frame_cache, mips_insn32_frame_cache): Update caller.

	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Use get_regcache_arch to get at
	the current architecture. Update call to getregs_supplies.
	(getregs_supplies): Add gdbarch as parameter and replace
	current_gdbarch.

	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use get_frame_arch to
	get at the current architecture. Update call to NBSD_MIPS_JB_OFFSET and
	NBSD_MIPS_JB_ELEMENT_SIZE.
	(NBSD_MIPS_JB_ELEMENT_SIZE, NBSD_MIPS_JB_OFFSET): Add gdbarch and
	replace current_gdbarch.

	* remote-mips.c (mips_map_regno): Add gdbarch as parameter and replace
	current_gdbarch.
	(mips_fetch_registers, mips_store_registers): Update call
	to mips_map_regno.
	(mips_load): Use get_regcache_arch to get at the current_architecture
	and replace current_gdbarch.
@
text
@d1596 2
a1597 2
  if (gdbarch_bfd_arch_info (current_gdbarch) != NULL
      && gdbarch_bfd_arch_info (current_gdbarch)->arch == bfd_arch_mips)
d1599 1
a1599 1
    switch (gdbarch_bfd_arch_info (current_gdbarch)->mach)
d2420 1
a2420 1
  addr = gdbarch_addr_bits_remove (current_gdbarch, addr);
@


1.87
log
@* remote-mips.c (set_breakpoint): Rename to...
(mips_set_breakpoint): ... this.
(clear_breakpoint): Rename to...
(mips_clear_breakpoint): ... this.
(common_breakpoint): Rename to...
(mips_common_breakpoint): ... this.
(check_lsi_error): Rename to...
(mips_check_lsi_error): ... this.
@
text
@d95 1
a95 1
static int mips_map_regno (int regno);
d1878 1
a1878 1
mips_map_regno (int regno)
d1882 4
a1885 4
  if (regno >= mips_regnum (current_gdbarch)->fp0
      && regno < mips_regnum (current_gdbarch)->fp0 + 32)
    return regno - mips_regnum (current_gdbarch)->fp0 + 32;
  else if (regno == mips_regnum (current_gdbarch)->pc)
d1887 1
a1887 1
  else if (regno == mips_regnum (current_gdbarch)->cause)
d1889 1
a1889 1
  else if (regno == mips_regnum (current_gdbarch)->hi)
d1891 1
a1891 1
  else if (regno == mips_regnum (current_gdbarch)->lo)
d1893 1
a1893 1
  else if (regno == mips_regnum (current_gdbarch)->fp_control_status)
d1895 1
a1895 1
  else if (regno == mips_regnum (current_gdbarch)->fp_implementation_revision)
d1927 1
a1927 1
      int pmon_reg = mips_map_regno (regno);
d1982 1
a1982 1
  mips_request ('R', mips_map_regno (regno), val,
d3284 4
a3287 2
      regcache_set_valid_p (get_current_regcache (),
			    gdbarch_pc_regnum (current_gdbarch), 0);
@


1.86
log
@	Updated copyright notices for most files.
@
text
@d143 1
a143 1
static int set_breakpoint (CORE_ADDR addr, int len, enum break_type type);
d145 2
a146 1
static int clear_breakpoint (CORE_ADDR addr, int len, enum break_type type);
d148 2
a149 2
static int common_breakpoint (int set, CORE_ADDR addr, int len,
			      enum break_type type);
d1454 1
a1454 1
       && clear_breakpoint (-1, 0, BREAK_UNUSED) == 0)
d2240 2
a2241 2
    return set_breakpoint (bp_tgt->placed_address, MIPS_INSN32_SIZE,
			   BREAK_FETCH);
d2250 2
a2251 2
    return clear_breakpoint (bp_tgt->placed_address, MIPS_INSN32_SIZE,
			     BREAK_FETCH);
d2297 1
a2297 1
  if (set_breakpoint (addr, len, type))
d2306 1
a2306 1
  if (clear_breakpoint (addr, len, type))
d2322 1
a2322 1
set_breakpoint (CORE_ADDR addr, int len, enum break_type type)
d2324 1
a2324 1
  return common_breakpoint (1, addr, len, type);
d2331 1
a2331 1
clear_breakpoint (CORE_ADDR addr, int len, enum break_type type)
d2333 1
a2333 1
  return common_breakpoint (0, addr, len, type);
d2342 1
a2342 1
   This is a helper function for common_breakpoint.  */
d2345 1
a2345 1
check_lsi_error (CORE_ADDR addr, int rerrflg)
d2364 2
a2365 2
		  fprintf_unfiltered (gdb_stderr,
				  "common_breakpoint (0x%s): Warning: %s\n",
d2371 2
a2372 2
	    fprintf_unfiltered (gdb_stderr,
			"common_breakpoint (0x%s): Unknown warning: 0x%x\n",
d2384 2
a2385 2
	  fprintf_unfiltered (gdb_stderr,
			      "common_breakpoint (0x%s): Error: %s\n",
d2391 2
a2392 2
  fprintf_unfiltered (gdb_stderr,
		      "common_breakpoint (0x%s): Unknown error: 0x%x\n",
d2413 1
a2413 1
common_breakpoint (int set, CORE_ADDR addr, int len, enum break_type type)
d2446 2
a2447 1
	      warning ("common_breakpoint: Attempt to clear bogus breakpoint at %s\n",
d2461 3
a2463 1
	    mips_error ("common_breakpoint: Bad response from remote board: %s", buf);
d2465 1
a2465 1
	  return (check_lsi_error (addr, rerrflg));
d2515 3
a2517 1
	    mips_error ("common_breakpoint: Bad response from remote board: %s", buf);
d2520 1
a2520 1
	    if (check_lsi_error (addr, rerrflg))
d2584 2
a2585 1
	mips_error ("common_breakpoint: Bad response from remote board: %s",
d2595 2
a2596 2
	    fprintf_unfiltered (gdb_stderr,
			     "common_breakpoint (0x%s):  Got error: 0x%x\n",
@


1.85
log
@* remote-mips.c (mips_load): Use regcache_set_valid_p() instead
of setting deprecated_register_valid array directly.
@
text
@d4 1
a4 1
   2003, 2004, 2006, 2007 Free Software Foundation, Inc.
@


1.84
log
@* target.c (update_current_target): Inherit to_log_command.
* target.h (struct target_ops). Add to_log_command.
(target_log_command): New macro.
* top.c (execute_command): Call target_log_command() rather than
serial_log_command().
* monitor.c (init_base_monitor_ops): Initialize to_log_command.
* remote-m32r-sdi.c (init_m32r_ops): Likewise.
* remote-mips.c (_initialize_remote_mips): Likewise.
* remote.c (init_remote_ops): Likewise.
@
text
@d3277 2
a3278 1
      deprecated_register_valid[gdbarch_pc_regnum (current_gdbarch)] = 0;
@


1.83
log
@2007-10-10  Markus Deuling  <deuling@@de.ibm.com>

	* remote-mips.c (mips_wait, mips_fetch_registers)
	(mips_store_registers): Use get_regcache_arch to get at the
	current architecture by regcache.

	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg)
	(mipsnbsd_supply_fpreg, mipsnbsd_fill_fpreg): Use get_regcache_arch to
	get at the current architecture by regcache.
	(mipsnbsd_sigtramp_offset): Use get_frame_arch to get at the current
	architecture by frame_info.

	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Use get_regcache_arch to get at
	the current architecture by regcache.

	* mips-linux-tdep.c (mips_linux_get_longjmp_target)
	(mips64_linux_get_longjmp_target, mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Use get_frame_arch to get at the
	current architecture by frame_info.
	(supply_32bit_reg, mips_supply_gregset, mips_fill_gregset)
	(mips_supply_fpregset, mips_fill_fpregset, supply_64bit_reg)
	(mips64_supply_gregset, mips64_fill_gregset, mips64_supply_fpregset)
	(mips64_fill_fpregset, mips_linux_write_pc): Use get_regcache_arch to
	get at the current architecture by regcache.

	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Replace current_gdbarch by gdbarch.
	(supply_gregset, fill_gregset, supply_fpregset, fill_fpregset)
	(mips64_linux_regsets_fetch_registers)
	(mips64_linux_regsets_store_registers): Use get_regcache_arch to get at
	the current architecture by regcache.

	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Use get_frame_arch to
	get at the current architecture by frame_info.
@
text
@d3336 1
@


1.82
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d1757 1
d1762 2
a1763 3
			        (current_gdbarch, gdbarch_pc_regnum
						    (current_gdbarch)), rpc);
      regcache_raw_supply (regcache, gdbarch_pc_regnum (current_gdbarch), buf);
d1766 1
a1766 2
	(buf, register_size (current_gdbarch,
	 gdbarch_pc_regnum (current_gdbarch)), rfp);
d1769 3
a1771 3
      store_unsigned_integer (buf, register_size (current_gdbarch,
			      gdbarch_sp_regnum (current_gdbarch)), rsp);
      regcache_raw_supply (regcache, gdbarch_sp_regnum (current_gdbarch), buf);
d1774 1
a1774 1
			      register_size (current_gdbarch,
d1776 1
a1776 1
					       (current_gdbarch)),
d1779 1
a1779 1
			   gdbarch_deprecated_fp_regnum (current_gdbarch), buf);
d1906 1
d1912 1
a1912 1
      for (regno = 0; regno < gdbarch_num_regs (current_gdbarch); regno++)
d1917 1
a1917 1
  if (regno == gdbarch_deprecated_fp_regnum (current_gdbarch)
d1951 1
a1951 1
    store_unsigned_integer (buf, register_size (current_gdbarch, regno), val);
d1969 1
d1975 1
a1975 1
      for (regno = 0; regno < gdbarch_num_regs (current_gdbarch); regno++)
@


1.81
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (DEPRECATED_FP_REGNUM): Replace by
	gdbarch_deprecated_fp_regnum.
	* std-regs.c (value_of_builtin_frame_fp_reg): Likewise.
	* remote-mips.c (mips_wait, mips_fetch_registers): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* arch-utils.h (gdbarch_virtual_frame_pointer_ftype): Likewise
	(comment).
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
d22 1
a22 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.80
log
@2007-06-18  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (SP_REGNUM): Replace by gdbarch_sp_regnum.
	* v850-tdep.c (v850_unwind_sp): Likewise.
	* std-regs.c (value_of_builtin_frame_sp_reg): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh-tdep.c (sh_push_dummy_call_fpu, sh_push_dummy_call_nofpu)
	(sh_dwarf2_frame_init_reg, sh_frame_cache, sh_frame_prev_register)
	(sh_unwind_sp): Likewise.
	* sh64-tdep.c (sh64_push_dummy_call, sh64_frame_cache)
	(sh64_frame_prev_register, sh64_unwind_sp): Likewise.
	* rs6000-tdep.c (rs6000_push_dummy_call, rs6000_unwind_dummy_id)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (store_register): Likewise.
	* remote-mips.c (mips_wait): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call)
	(ppc64_sysv_abi_push_dummy_call): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* m32r-rom.c (m32r_supply_register): Likewise.
	* frame.c (frame_sp_unwind): Likewise.
	* mips-tdep.c (mips_insn16_frame_cache)
	(mips_insn32_frame_cache): Likewise (comment).
	* m68klinux-nat.c (supply_gregset): Likewise.
	* m68k-tdep.c (m68k_get_longjmp_target): Likewise.
	* ia64-tdep.c (ia64_frame_prev_register): Likewise.
	* i386-tdep.c (i386_get_longjmp_target): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* cris-tdep.c (cris_regnums, cris_sigcontext_addr)
	(cris_sigtramp_frame_unwind_cache, cris_push_dummy_call)
	(cris_scan_prologue, crisv32_scan_prologue, cris_unwind_sp)
	(cris_register_type, crisv32_register_type)
	(cris_dwarf2_frame_init_reg): Likewise.
	* arch-utils.c (legacy_virtual_frame_pointer): Likewise.
	* amd64-tdep.c (amd64_frame_prev_register): Likewise.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Likewise.
	* libunwind-frame.c (libunwind_frame_cache): Likewise.

	* gdbarch.sh (PC_REGNUM): Replace by gdbarch_pc_regnum.
	* regcache.c (read_pc_pid, generic_target_write_pc): Likewise.
	* xtensa-tdep.c (xtensa_register_type, xtensa_supply_gregset)
	(xtensa_unwind_pc, xtensa_frame_cache, xtensa_frame_prev_register)
	(xtensa_extract_return_value, xtensa_store_return_value): Likewise.
	* v850-tdep.c (v850_unwind_pc): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs)
	(sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs)
	(sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs)
	(sh_dwarf2_frame_init_reg, sh_frame_prev_register, sh_unwind_pc)
	(sh_dsp_show_regs): Likewise.
	* shnbsd-tdep.c (shnbsd_supply_gregset)
	(shnbsd_collect_gregset): Likewise.
	* shnbsd-nat.c (GETREGS_SUPPLIES): Likewise.
	* sh64-tdep.c (sh64_compact_reg_base_num, sh64_show_media_regs)
	(sh64_frame_prev_register, sh64_unwind_pc): Likewise.
	* rs6000-tdep.c (ppc_supply_gregset, ppc_collect_gregset)
	(6000_register_reggroup_p, rs6000_unwind_pc)
	(rs6000_frame_cache): Likewise.
	* rs6000-nat.c (regmap, rs6000_fetch_inferior_registers)
	(rs6000_store_inferior_registers): Likewise.
	* remote-mips.c (mips_wait, mips_load): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_cache): Likewise.
	* ppcobsd-nat.c (ppcobsd_supply_pcb): Likewise.
	* ppcnbsd-tdep.c (ppcnbsd_sigtramp_cache_init): Likewise.
	* ppcnbsd-nat.c (getregs_supplies, ppcnbsd_supply_pcb): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* ppc-linux-nat.c (ppc_register_u_addr, fetch_ppc_registers)
	(store_ppc_registers, fill_gregset): Likewise.
	* mips-tdep.c (mips_stub_frame_cache, mips_gdbarch_init): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg, mipsnbsd_fill_reg): Likewise.
	* mipsnbsd-nat.c (getregs_supplies): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_unwind_pc): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.
	* irix5-nat.c (fill_gregset): Likewise.
	* i386-tdep.c (i386_unwind_pc): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* frame.c (get_prev_frame_1): Likewise.
	* dwarf2-frame.c (dwarf2_frame_default_init_reg): Likewise.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* cris-tdep.c (cris_sigtramp_frame_unwind_cache, cris_scan_prologue)
	(crisv32_scan_prologue, cris_unwind_pc, cris_register_size)
	(cris_register_type, crisv32_register_type, crisv32_register_name)
	(cris_dwarf2_frame_init_reg, find_step_target)
	(cris_software_single_step, cris_supply_gregset)
	(cris_regnums): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* aix-thread.c (special_register_p, supply_sprs64, supply_sprs32)
	(fill_sprs64, fill_sprs32, store_regs_user_thread): Likewise.
	* mips-linux-tdep.c (mips_linux_write_pc): Likewise.

	* gdbarch.sh (PS_REGNUM): Replace by gdbarch_ps_regnum.
	* dbug-rom.c (dbug_supply_register): Likewise.
	* xtensa-tdep.c (xtensa_supply_gregset, xtensa_frame_cache)
	(xtensa_frame_prev_register, xtensa_push_dummy_call): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* std-regs.c (value_of_builtin_frame_ps_reg)
	(value_of_builtin_frame_pc_reg): Likewise.
	* m68k-tdep.c (m68k_register_type): Likewise.
	* m68klinux-nat.c (supply_gregset): Likewise.

	* gdbarch.sh (FP0_REGNUM): Replace by gdbarch_fp0_regnum.
	* sh-tdep.c (sh_extract_return_value_fpu, sh_store_return_value_fpu)
	(sh2e_show_regs, sh2a_show_regs, sh3e_show_regs, sh4_show_regs)
	(sh_sh2a_register_type, sh_sh3e_register_type, sh_sh4_register_type)
	(fv_reg_base_num, dr_reg_base_num): Likewise.
	* sh64-tdep.c (sh64_fv_reg_base_num, sh64_dr_reg_base_num)
	(sh64_fpp_reg_base_num, sh64_compact_reg_base_num, sh64_push_dummy_call)
	(sh64_extract_return_value, sh64_store_return_value)
	(sh64_show_media_regs, sh64_show_compact_regs, sh64_register_type)
	(sh64_do_fp_register, sh64_media_print_registers_info): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers)
	(invalidate_cache): Likewise.
	* ppc-linux-tdep.c (ppc_linux_sigtramp_cache): Likewise.
	* mipsnbsd-tdep.c (mipsnbsd_supply_fpreg)
	(mipsnbsd_fill_fpreg): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers)
	(mipsnbsd_store_inferior_registers): Likewise.
	* mips-linux-tdep.c (mips_supply_fpregset, mips_fill_fpregset)
	(mips64_supply_fpregset, mips64_fill_fpregset): Likewise.
	* mips-linux-nat.c (mips64_linux_register_addr): Likewise.
	* m68k-tdep.c (m68k_register_type, m68k_convert_register_p): Likewise.
	* m68klinux-nat.c (getfpregs_supplies, supply_fpregset)
	(fill_fpregset): Likewise.
	* irix5-nat.c (supply_fpregset, fill_fpregset): Likewise.
	* i386-tdep.h (struct_return): Likewise (comment).
	* i386-nto-tdep.c (i386nto_register_area): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register)
	(go32_store_registers): Likewise.
	* alpha-tdep.c (alpha_next_pc): Likewise.
	* alpha-linux-nat.c (alpha_linux_register_u_offset): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers)
	(alphabsd_store_inferior_registers): Likewise.
	* core-regset.c (fetch_core_registers): Likewise.
	* i386v4-nat.c (supply_fpregset, fill_fpregset): Likewise.

	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1776 7
a1782 2
      store_unsigned_integer (buf, register_size (current_gdbarch, DEPRECATED_FP_REGNUM), 0);
      regcache_raw_supply (regcache, DEPRECATED_FP_REGNUM, buf);
d1919 3
a1921 2
  if (regno == DEPRECATED_FP_REGNUM || regno == MIPS_ZERO_REGNUM)
    /* DEPRECATED_FP_REGNUM on the mips is a hack which is just
@


1.79
log
@	* regcache.c (struct regcache): Add ptid_t member.
	(regcache_xmalloc): Initialize it.
	(regcache_cpy_no_passthrough): Do not refer to current_regcache.
	(regcache_dup): Likewise.
	(regcache_dup_no_passthrough): Likewise.
	(current_regcache): Make static.
	(registers_ptid): Remove variable.
	(get_thread_regcache): New function.
	(get_current_regcache): New function.
	(registers_changed): Implement by freeing current regcache.
	(regcache_raw_read): Do not refer to current_regcache.  Set
	inferior_ptid to regcache->ptid while calling target routines.
	(regcache_raw_write): Likewise.
	(regcache_raw_supply): Do not refer to current_regcache.
	(read_pc_pid): Use thread regcache.  Do not modify inferior_ptid.
	(write_pc_pid): Likewise.
	(build_regcache): Remove.
	(_initialize_regcache): Do not call DEPRECATED_REGISTER_GDBARCH_SWAP
	or deprecated_register_gdbarch_swap.  Do not initialize
	registers_ptid.
	* regcache.h (get_current_regcache): Add prototype.
	(get_thread_regcache): Likewise.
	(current_regcache): Remove declaration.

	* corelow.c (core_open): Replace current_regcache by
	get_current_regcache ().
	* frame.c (frame_pop): Likewise.
	(put_frame_register): Likewise.
	(get_current_frame, create_new_frame): Likewise.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Likewise.
	* stack.c (return_command): Likewise.
	* infcall.c (call_function_by_hand): Likewise.
	* infrun.c (resume): Likewise.
	(save_inferior_status, restore_inferior_status): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	(fork_save_infrun_state): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* i386fbsd-nat.c (i386fbsd_resume): Likewise.
	* monitor.c (monitor_wait): Likewise.
	* remote.c (remote_wait): Likewise.
	* remote-mips.c (mips_wait): Likewise.

	* bsd-kvm.c (bsd_kvm_open): Likewise
	(bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Likewise.
	* fbsd-nat.c (fbsd_make_corefile_notes): Likewise.
	* i386-linux-nat.c (i386_linux_resume): Likewise.
	* ia64-linux-nat.c (ia64_linux_insert_watchpoint): Likewise.
	(ia64_linux_stopped_data_address): Likewise.

	* frv-tdep.c (frv_fdpic_loadmap_addresses): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* mep-tdep.c (current_me_module, current_options): Likewise.
	* mips-tdep.c (deprecated_mips_set_processor_regs_hack): Likewise.

	* linux-nat.c (linux_nat_do_thread_registers): Use thread
	regcache instead of current_regcache.  Call target_fetch_registers.
	(linux_nat_corefile_thread_callback): Update call site.
	(linux_nat_do_registers): Likewise.
	* procfs.c (procfs_do_thread_registers): Use thread regcache instead
	of current_regcache.
	(procfs_make_note_section): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs): Likewise.
	(ps_lgetfpregs, ps_lsetfpregs): Likewise.
@
text
@d1761 9
a1769 4
      store_unsigned_integer (buf, register_size (current_gdbarch, PC_REGNUM), rpc);
      regcache_raw_supply (regcache, PC_REGNUM, buf);

      store_unsigned_integer (buf, register_size (current_gdbarch, PC_REGNUM), rfp);
d1772 3
a1774 2
      store_unsigned_integer (buf, register_size (current_gdbarch, SP_REGNUM), rsp);
      regcache_raw_supply (regcache, SP_REGNUM, buf);
d3272 1
a3272 1
      deprecated_register_valid[PC_REGNUM] = 0;
@


1.78
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ARCHITECTURE): Replace by gdbarch_bfd_arch_info.
	* arch-utils.c (show_architecture): Likewise.
	* remote-mips.c (mips_open): Likewise
	* nto-tdep.c (nto_find_and_open_solib)
	(nto_init_solib_absolute_prefix): Likewise.
	* nto-procfs (procfs_open): Likewise.
	* m68hc11-tdep.c (gdb_print_insn_m68hc11): Likewise.
	* gcore.c (default_gcore_mach, default_gcore_arch): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1758 1
d1762 1
a1762 1
      regcache_raw_supply (current_regcache, PC_REGNUM, buf);
d1765 1
a1765 1
      regcache_raw_supply (current_regcache, 30, buf);	/* This register they are avoiding and so it is unnamed */
d1768 1
a1768 1
      regcache_raw_supply (current_regcache, SP_REGNUM, buf);
d1771 1
a1771 1
      regcache_raw_supply (current_regcache, DEPRECATED_FP_REGNUM, buf);
@


1.77
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDR_BITS_REMOVE): Replace by gdbarch_addr_bits_remove.
	* value.c (value_as_address): Likewise (comment).
	* remote-mips.c (common_breakpoint): Likewise.
	* regcache.c (read_pc_pid): Likewise.
	* printcmd.c (do_one_display): Likewise.
	* monitor.c (monitor_write_memory, monitor_read_memory)
	(monitor_insert_breakpoint): Likewise.
	* mips-tdep.c (heuristic_proc_start): Likewise.
	* infrun.c (insert_step_resume_breakpoint_at_frame)
	(insert_step_resume_breakpoint_at_caller): Likewise.
	* buildsym.c (record_line): Likewise.
	* arm-tdep.c (arm_scan_prologue, thumb_get_next_pc)
	(arm_get_next_pc): Likewise.
	* armnbsd-nat.c (arm_supply_gregset, fetch_register, store_register)
	(store_regs): Likewise.
	* arm-linux-tdep.c (arm_linux_supply_gregset): Likewise.
	* arm-linux-nat.c (fetch_register, fetch_regs): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d1597 2
a1598 2
  if (TARGET_ARCHITECTURE != NULL
      && TARGET_ARCHITECTURE->arch == bfd_arch_mips)
d1600 1
a1600 1
    switch (TARGET_ARCHITECTURE->mach)
@


1.76
log
@2007-05-31  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (NUM_REGS): Replace by gdbarch_num_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_registers)
	(inf_ptrace_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* i386-linux-nat.c (supply_gregset, fill_gregset)
	(i386_linux_fetch_inferior_registers)
	(i386_linux_store_inferior_registers): Likewise.
	* remote.c (init_remote_state,packet_reg_from_regnum)
	(packet_reg_from_pnum,process_g_packet,remote_fetch_registers)
	(remote_prepare_to_store,store_registers_using_G)
	(remote_store_registers,remote_arch_state): Likewise.
	* tracepoint.c (encode_actions): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* tui/tui-regs.c (tui_show_register_group)
	(tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* xtensa-tdep.c (xtensa_register_name,xtensa_register_type)
	(xtensa_reg_to_regnum,xtensa_pseudo_register_read)
	(xtensa_pseudo_register_write,xtensa_register_reggroup_p): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers)
	(do_win32_store_inferior_registers,fetch_elf_core_registers
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target-descriptions.c (tdesc_use_registers): Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_do_pseudo_register,sh64_print_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* rs6000-nat.c (fetch_register,store_register): Likewise.
	* remote-sim.c (one2one_register_sim_regno,gdbsim_fetch_register)
	(gdbsim_fetch_register,gdbsim_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers,mips_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers)
	(m32r_store_registers): Likewise.
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save)
	(regcache_restore,regcache_dump): Likewise.
	* monitor.c (monitor_fetch_registers,monitor_store_registers): Likewise.
	* mips-tdep.c (mips_xfer_register,mips_register_name)
	(mips_register_reggroup_p,mips_pseudo_register_read)
	(mips_pseudo_register_write,mips_convert_register_p,mips_register_type)
	(mips_unwind_pc,mips_unwind_sp,mips_unwind_dummy_id,set_reg_offset)
	(mips16_scan_prologue,mips_insn16_frame_cache,reset_saved_regs)
	(mips32_scan_prologue,mips_insn32_frame_cache,read_next_frame_reg)
	(mips_n32n64_return_value,mips_o32_return_value,mips_o64_return_value)
	(print_gp_register_row,mips_print_registers_info)
	(mips_stab_reg_to_regnum,mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_register_sim_regno): Likewise.
	* mips-linux-tdep.c (mips_linux_o32_sigframe_init)
	(mips_linux_n32n64_sigframe_init): Likewise.
	* mips-linux-nat.c (mips_linux_register_addr)
	(mips64_linux_register_addr): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* mips64obsd-tdep.c (mips64obsd_sigframe_init): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache(: Likewise.
	* m32r-tdep.c (m32r_frame_unwind_cache): Likewise.
	* ia64-linux-nat.c (ia64_register_addr,ia64_cannot_fetch_register)
	(ia64_cannot_store_register,ia64_linux_fetch_registers)
	(ia64_linux_store_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Likewise.
	* h8300-tdep.c (E_PSEUDO_CCR_REGNUM,E_PSEUDO_EXR_REGNUM)
	(h8300_init_frame_cache,h8300_frame_cache,h8300_frame_prev_register)
	(h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache)
	(dwarf2_frame_state_alloc_regs): Likewise.
	* cris-tdep.c (cris_register_size,cris_cannot_fetch_register)
	(cris_cannot_store_register,crisv32_cannot_fetch_register)
	(crisv32_cannot_store_register,cris_register_name): Likewise.
	* avr-tdep.c (avr_frame_unwind_cache): Likewise.
	* arch-utils.c (legacy_register_sim_regno)
	(legacy_virtual_frame_pointer): Likewise.
	* arm-tdep.c (arm_make_prologue_cache,arm_register_sim_regno):Likewise.
	* arm-tdep.h: Likewise (comment).
	* frv-tdep.c (frv_register_sim_regno): Likewise.
	* m68klinux-nat.c (old_fetch_inferior_registers)
	(old_store_inferior_registers): Likewise.
	* m32c-tdep.c (m32c_virtual_frame_pointer): Likewise.
	* irix5-nat.c (fetch_core_registers): Likewise.
	* hppa-tdep.c (hppa_frame_cache): Likewise.
	* hppa-linux-nat.c (hppa_linux_register_addr)
	(hppa_linux_fetch_inferior_registers)
	(hppa_linux_store_inferior_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_inferior_registers)
	(hppa_hpux_store_inferior_registers): Likewise.
	* amd64-nat.c (amd64_native_gregset_reg_offset)
	(amd64_supply_native_gregset,amd64_collect_native_gregset): Likewise.
	* dbug-rom.c (dbug_regname): Likewise.
	* m68hc11-tdep.c (m68hc11_frame_unwind_cache)
	(HARD_PAGE_REGNUM (comment)): Likewise.
	* gdbarch.sh (NUM_PSEUDO_REGS): Replace by gdbarch_num_pseudo_regs.
	* i386-tdep.c (i386_dbx_reg_to_regnum)
	(i386_svr4_reg_to_regnum): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers,mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
	* tui/tui-regs.c (tui_show_register_group): Likewise.
	* xtensa-tdep.h (FP_ALIAS): Likewise.
	* user-regs.h: Likewise (comment).
	* user-regs.c (user_reg, user_reg_map_name_to_regnum): Likewise.
	* trad-frame.c (trad_frame_alloc_saved_regs): Likewise.
	* target-descriptions.h: Likewise (comment).
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* sh64-tdep.c (sh64_print_register,sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_sim_regno): Likewise.
	* regcache.c (init_regcache_descr,register_size,regcache,regcache_save
	(regcache_restore,regcache_dump): Likewise.
	* mips-tdep.c (print_gp_register_row,mips_print_registers_info)
	(mips_dwarf_dwarf2_ecoff_reg_to_regnum)
	(mips_stab_reg_to_regnum): Likewise.
	* findvar.c (value_of_register): Likewise.
	* infcmd.c (default_print_registers_info,registers_info)
	(print_vector_info,print_float_info): Likewise.
	* m68k-tdep.c (m68k_dwarf_reg_to_regnum): Likewise.
	* h8300-tdep.c (h8300_register_type): Likewise.
	* dwarf2-frame.c (dwarf2_frame_cache): Likewise.
	* frame.h (SIZEOF_FRAME_SAVED_REGS): Likewise.
	* xtensa-tdep.c (xtensa_register_type,xtensa_reg_to_regnum)
	(xtensa_pseudo_register_read,xtensa_pseudo_register_write): Likewise.
	* parse.c: Remove comment.
	* gdbarch.c, gdbarch.h: Regenerate
@
text
@d2407 1
a2407 1
  addr = ADDR_BITS_REMOVE (addr);
@


1.75
log
@	* target.h (struct target_ops): Add REGCACHE parameter to
	to_prepare_to_store.
	(target_prepare_to_store): Likewise.
	* target.c (debug_to_prepare_to_store): Add REGCACHE parameter.
	(update_current_target): Adapt prepare_to_store de_fault rule.

	* regcache.c (regcache_raw_write): Pass regcache to
	target_prepare_to_store.

	* inftarg.c (child_prepare_to_store): Add REGCACHE parameter.
	Do not call CHILD_PREPARE_TO_STORE.
	* gnu-nat.c (gnu_prepare_to_store): Likewise.
	* procfs.c (procfs_prepare_to_store): Likewise.

	* inf-child.c (inf_child_prepare_to_store): Add REGCACHE parameter.
	* go32-nat.c (go32_prepare_to_store): Likewise.
	* monitor.c (monitor_prepare_to_store): Likewise.
	* nto-procfs.c (procfs_prepare_to_store): Likewise.
	* remote-m32r-sdi.c (m32r_prepare_to_store): Likewise.
	* remote-mips.c (mips_prepare_to_store): Likewise.
	* remote-sim.c (gdbsim_prepare_to_store): Likewise.
	* win32-nat.c (win32_prepare_to_store): Likewise.

	* remote.c (remote_prepare_to_store): Add REGCACHE parameter.
	Use it instead of current_regcache.

	* hpux-thread.c (hpux_thread_prepare_to_store): Add REGCACHE
	parameter.  Pass it on to next target.
	* sol-thread.c (sol_thread_prepare_to_store): Likewise.
@
text
@d1902 1
a1902 1
      for (regno = 0; regno < NUM_REGS; regno++)
d1963 1
a1963 1
      for (regno = 0; regno < NUM_REGS; regno++)
@


1.74
log
@	* target.h (struct regcache): Add forward declaration.
	(struct target_ops): Add REGCACHE parameter to to_fetch_registers
	and to_store_registers target operations.
	(target_fetch_registers, target_store_registers): Update.

	* regcache.c (regcache_raw_read): Replace register_cached by
	regcache_valid_p.  Pass regcache to target_fetch_registers.
	(regcache_raw_write): Pass regcache to target_store_registers.

	* arm-linux-nat.c (store_fpregister, store_fpregs, store_register,
	store_regs, store_wmmx_regs): Replace register_cached by
	regcache_valid_p.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd): Pass current_regcache
	to target_fetch_registers calls.
	* corelow.c (core_open): Likewise.
	* linux-nat.c (linux_nat_corefile_thread_callback): Likewise.
	* proc-service.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* sol-thread.c (ps_lgetregs, ps_lsetregs, ps_lgetfpregs,
	ps_lsetfpregs): Likewise.
	* win32-nat.c (win32_resume): Likewise.
	* ia64-tdep.c (ia64_store_return_value): Pass current_regcache
	to target_store_registers call.
	* rs6000-tdep.c (rs6000_push_dummy_call): Likewise.

	* inferior.h (store_inferior_registers): Update prototype.
	(fetch_inferior_registers): Likewise.
	* gnu-nat.c (gnu_store_registers, gnu_fetch_registers): Likewise.
	* mips-linux-nat.c (super_fetch_registers, super_store_registers):
	Update function pointer signatures.

	* aix-thread.c (aix_thread_fetch_registers): Add REGCACHE parameter,
	use it instead of current_regcache, update calls.
	(aix_thread_store_registers): Likewise.
	* alphabsd-nat.c (alphabsd_fetch_inferior_registers): Likewise.
	(alphabsd_store_inferior_registers): Likewise.
	* amd64bsd-nat.c (amd64bsd_fetch_inferior_registers): Likewise.
	(amd64bsd_store_inferior_registers): Likewise.
	* amd64-linux-nat.c (amd64_linux_fetch_inferior_registers): Likewise.
	(amd64_linux_store_inferior_registers): Likewise.
	* arm-linux-nat.c (fetch_fpregister, fetch_fpregs, store_fpregister,
	store_fpregs, fetch_register, fetch_regs, store_register, store_regs,
	fetch_wmmx_regs, store_wmmx_regs): Likewise.
	(arm_linux_fetch_inferior_registers): Likewise.
	(arm_linux_store_inferior_registers): Likewise.
	* armnbsd-nat.c (fetch_register, fetch_regs, fetch_fp_register,
	fetch_fp_regs, armnbsd_fetch_registers): Likewise.
	(store_register, store_regs, store_fp_register, store_fp_regs,
	armnbsd_store_registers): Likewise.
	* bsd-kvm.c (bsd_kvm_fetch_pcb, bsd_kvm_fetch_registers): Likewise.
	* bsd-uthread.c (bsd_uthread_fetch_registers): Likewise.
	(bsd_uthread_store_registers): Likewise.
	* corelow.c (get_core_registers): Likewise.
	* go32-nat.c (fetch_register, go32_fetch_registers, store_register,
	go32_store_registers): Likewise.
	* hppabsd-nat.c (hppabsd_fetch_registers): Likewise.
	(hppabsd_store_registers): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register): Likewise.
	(hppa_hpux_fetch_inferior_registers): Likewise.
	(hppa_hpux_store_register): Likewise.
	(hppa_hpux_store_inferior_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	(hppa_linux_fetch_inferior_registers): Likewise.
	(hppa_linux_store_inferior_registers): Likewise.
	* hpux-thread.c (hpux_thread_fetch_registers): Likewise.
	(hpux_thread_store_registers): Likewise.
	* i386bsd-nat.c (i386bsd_fetch_inferior_registers): Likewise.
	(i386bsd_store_inferior_registers): Likewise.
	* i386gnu-nat.c (fetch_fpregs, gnu_fetch_registers, store_fpregs,
	gnu_store_registers): Likewise.
	* i386-linux-nat.c (fetch_register, store_register, fetch_regs,
	store_regs, fetch_fpregs, store_fpregs, fetch_fpxregs, store_fpxregs):
	Likewise.
	(i386_linux_fetch_inferior_registers): Likewise.
	(i386_linux_store_inferior_registers): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register): Likewise.
	(ia64_linux_fetch_registers): Likewise.
	(ia64_linux_store_register): Likewise.
	(ia64_linux_store_registers): Likewise.
	* inf-child.c (inf_child_fetch_inferior_registers): Likewise.
	(inf_child_store_inferior_registers): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register): Likewise.
	(inf_ptrace_fetch_registers): Likewise.
	(inf_ptrace_store_register): Likewise.
	(inf_ptrace_store_registers): Likewise.
	* infptrace.c (fetch_register, store_register): Likewise.
	(fetch_inferior_registers, store_inferior_registers): Likewise.
	* m32r-linux-nat.c (fetch_regs, store_regs): Likewise.
	(m32r_linux_fetch_inferior_registers): Likewise.
	(m32r_linux_store_inferior_registers): Likewise.
	* m68kbsd-nat.c (m68kbsd_fetch_inferior_registers): Likewise.
	(m68kbsd_store_inferior_registers): Likewise.
	* m68klinux-nat.c (fetch_register, old_fetch_inferior_registers,
	store_register, old_store_inferior_registers, fetch_regs, store_regs,
	fetch_fpregs, store_fpregs): Likewise.
	(m68k_linux_fetch_inferior_registers): Likewise.
	(m68k_linux_store_inferior_registers): Likewise.
	* m88kbsd-nat.c (m88kbsd_fetch_inferior_registers): Likewise.
	(m88kbsd_store_inferior_registers): Likewise.
	* mips64obsd-nat.c (mips64obsd_fetch_inferior_registers): Likewise.
	(mips64obsd_store_inferior_registers): Likewise.
	* mips-linux-nat.c (mips64_linux_regsets_fetch_registers): Likewise.
	(mips64_linux_regsets_store_registers): Likewise.
	(mips64_linux_fetch_registers): Likewise.
	(mips64_linux_store_registers): Likewise.
	* mipsnbsd-nat.c (mipsnbsd_fetch_inferior_registers): Likewise.
	(mipsnbsd_store_inferior_registers): Likewise.
	* monitor.c (monitor_fetch_register, monitor_store_register): Likewise.
	(monitor_fetch_registers, monitor_store_registers): Likewise.
	* nto-procfs.c (procfs_fetch_registers): Likewise.
	(procfs_store_registers): Likewise.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register,
	fetch_register, supply_vrregset, fetch_altivec_registers,
	fetch_ppc_registers, ppc_linux_fetch_inferior_registers): Likewise.
	(store_altivec_register, store_spe_register, store_register,
	fill_vrregset, store_altivec_registers, store_ppc_registers,
	ppc_linux_store_inferior_registers): Likewise.
	* ppcnbsd-nat.c (ppcnbsd_fetch_inferior_registers): Likewise.
	(ppcnbsd_store_inferior_registers): Likewise.
	* ppcobsd-nat.c (ppcobsd_fetch_registers): Likewise.
	(ppcobsd_store_registers): Likewise.
	* procfs.c (procfs_fetch_registers, procfs_store_registers): Likewise.
	* remote.c (fetch_register_using_p, process_g_packet,
	fetch_registers_using_g, remote_fetch_registers): Likewise.
	(store_register_using_P, store_registers_using_G,
	remote_store_registers): Likewise.
	* remote-m32r-sdi.c (m32r_fetch_registers, m32r_fetch_register,
	m32r_store_register, m32r_store_register): Likewise.
	* remote-mips.c (mips_fetch_registers, mips_store_registers): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	(gdbsim_store_register): Likewise.
	* rs6000-nat.c (fetch_register, store_register): Likewise.
	(rs6000_fetch_inferior_registers): Likewise.
	(rs6000_store_inferior_registers): Likewise.
	* s390-nat.c (fetch_regs, store_regs): Likewise.
	(fetch_fpregs, store_fpregs): Likewise.
	(s390_linux_fetch_inferior_registers): Likewise.
	(s390_linux_store_inferior_registers): Likewise.
	* shnbsd-nat.c (shnbsd_fetch_inferior_registers): Likewise.
	(shnbsd_store_inferior_registers): Likewise.
	* sol-thread.c (sol_thread_fetch_registers): Likewise.
	(sol_thread_store_registers): Likewise.
	* sparc-nat.c (fetch_inferior_registers): Likewise.
	(store_inferior_registers): Likewise.
	* spu-linux-nat.c (spu_fetch_inferior_registers): Likewise.
	(spu_store_inferior_registers): Likewise.
	* target.c (debug_print_register): Likewise.
	(debug_to_fetch_registers, debug_to_store_registers): Likewise.
	* vaxbsd-nat.c (vaxbsd_fetch_inferior_registers): Likewise.
	(vaxbsd_store_inferior_registers): Likewise.
	* win32-nat.c (do_win32_fetch_inferior_registers): Likewise.
	(win32_fetch_inferior_registers): Likewise.
	(win32_store_inferior_registers): Likewise.
@
text
@d101 1
a101 1
static void mips_prepare_to_store (void);
d1949 1
a1949 1
mips_prepare_to_store (void)
@


1.73
log
@	* mips-mdebug-tdep.c, mips-mdebug-tdep.h, ocd.c, ocd.h, ppc-bdm.c,
	remote-e7000.c, remote-hms.c, remote-utils.c, remote-utils.h,
	scm-exp.c, scm-lang.c, scm-lang.h, scm-tags.h, scm-valprint.c,
	ser-e7kpc.c, sh3-rom.c, stop-gdb.c: Delete.
	* Makefile.in: Remove references to deleted files.
	* README: Do not mention deleted ROM monitor interfaces.
	* defs.h (enum language): Delete language_scm.
	* expprint.c (print_subexp_standard): Do not handle OP_EXPRSTRING.
	(dump_subexp_body_standard): Likewise.
	* parse.c (operator_length_standard): Likewise.
	* expression.h (enum exp_opcode): Delete OP_EXPRSTRING.
	* remote-mips.c: Do not include remote-utils.h.
	* remote-sim.c: Likewise.  Use remote_debug instead of sr_get_debug
	throughout.
	* value.c: Do not include scm-lang.h.
	(unpack_long): Delete scm_unpack call.
	* config/h8300/h8300.mt, config/mips/embed.mt,
	config/powerpc/ppc-eabi.mt, config/powerpc/ppc-sim.mt,
	config/sh/embed.mt, config/sh/linux.mt: Remove references to
	deleted files.
	* NEWS: Mention removed files.

	* gdb.texinfo (Memory): Reference Remote Debugging chapter.
	(Character Sets, Caching Data of Remote Targets): Likewise.
	(Targets): Delete Remote node.  Move its text...
	(Debugging Remote Programs): ...to here.  Delete description
	of the "remote" command.
	(Remote configuration): Delete description of "set remotedevice"
	and "show remotedevice".
	(Embedded Processors): Delete H8/300, H8/500, and SH nodes.
@
text
@d99 1
a99 1
static void mips_fetch_registers (int regno);
d103 1
a103 1
static void mips_store_registers (int regno);
d1895 1
a1895 1
mips_fetch_registers (int regno)
d1903 1
a1903 1
	mips_fetch_registers (regno);
d1941 1
a1941 1
    regcache_raw_supply (current_regcache, regno, buf);
d1956 1
a1956 1
mips_store_registers (int regno)
d1958 1
d1964 1
a1964 1
	mips_store_registers (regno);
d1968 2
a1969 2
  mips_request ('R', mips_map_regno (regno),
		read_register (regno),
@


1.72
log
@* remote-mips.c (mips_xfer_memory): Update prototype.
@
text
@a34 1
#include "remote-utils.h"
@


1.71
log
@	* frame.c (frame_pop, frame_observer_target_changed): Call
	reinit_frame_cache.
	(flush_cached_frames): Rename to reinit_frame_cache and delete
	old implementation.
	* frame.h (flush_cached_frames): Delete prototype and update comment.

	* bsd-kvm.c (bsd_kvm_open, bsd_kvm_proc_cmd, bsd_kvm_pcb_cmd): Call
	reinit_frame_cache instead of flush_cached_frames.  Do not call
	select_frame after reinit_frame_cache.
	* corelow.c (core_open): Likewise.
	* gdbarch.sh (deprecated_current_gdbarch_select_hack): Likewise.
	* infrun.c (prepare_to_proceed, context_switch)
	(handle_inferior_event): Likewise.
	* linux-fork.c (fork_load_infrun_state): Likewise.
	* ocd.c (ocd_start_remote): Likewise.
	* remote-e7000.c (e7000_start_remote): Likewise.
	* remote-mips.c (device): Likewise.
	* thread.c (switch_to_thread): Likewise.
	* tracepoint.c (finish_tfind_command): Likewise.
	* gdbarch.c: Regenerated.
@
text
@d111 1
a111 1
static int mips_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len,
d2032 1
a2032 1
mips_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, int write,
@


1.70
log
@Copyright updates for 2007.
@
text
@d1587 1
a1587 1
  flush_cached_frames ();
@


1.69
log
@gdb/
	* breakpoint.c (deprecated_read_memory_nobpt): Update to use
	shadow_len.
	(insert_bp_location, reattach_breakpoints, remove_breakpoint)
	(delete_breakpoint): Update calls to changed methods.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(single_step_breakpoints, insert_single_step_breakpoint)
	(remove_single_step_breakpoints): New.
	* breakpoint.h (struct bp_target_info): New.
	(struct bp_location): Replace shadow_contents with
	target_info and overlay_target_info.
	(deprecated_insert_raw_breakpoint, deprecated_remove_raw_breakpoint)
	(insert_single_step_breakpoint, remove_single_step_breakpoints): New
	prototypes.
	* gdbarch.sh: Forward declare struct bp_target_info in gdbarch.h.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update second
	argument.
	* mem-break.c (default_memory_insert_breakpoint): Update.  Set
	placed_address, placed_size, and shadow_len.
	(default_memory_remove_breakpoint): Update.  Don't use
	BREAKPOINT_FROM_PC.
	(memory_insert_breakpoint, memory_remove_breakpoint): Update.
	* target.c (update_current_target): Update prototypes for changed
	functions.
	(debug_to_insert_breakpoint, debug_to_remove_breakpoint)
	(debug_to_insert_hw_breakpoint, debug_to_remove_hw_breakpoint):
	Update.
	* target.h: Forward declare struct bp_target_info.
	(struct target_ops): Use a bp_target_info argument for
	to_insert_breakpoint, to_remove_breakpoint,
	to_insert_hw_breakpoint, and to_remove_hw_breakpoint.
	(target_insert_breakpoint, target_remove_breakpoint)
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint)
	(memory_insert_breakpoint, memory_remove_breakpoint)
	(default_memory_insert_breakpoint, default_memory_remove_breakpoint):
	Update.
	* config/i386/nm-i386.h: Forward declare struct bp_target_info.
	(i386_insert_hw_breakpoint, i386_remove_hw_breakpoint): Update.
	(target_insert_hw_breakpoint, target_remove_hw_breakpoint): Likewise.

	* gdbarch.c, gdbarch.h: Regenerated.

	* alpha-tdep.c (alpha_software_single_step): Use
	insert_single_step_breakpoint and remove_single_step_breakpoints.
	Remove unused statics.
	* arm-tdep.c (arm_software_single_step): Likewise.  Add a note.
	* cris-tdep.c (cris_software_single_step): Likewise.
	* mips-tdep.c (mips_software_single_step): Likewise.
	* rs6000-tdep.c (rs6000_software_single_step): Likewise.
	* sparc-tdep.c (sparc_software_single_step): Likewise.
	* wince.c (struct thread_info_struct): Remove step_prev.
	(undoSStep): Use remove_single_step_breakpoints.
	(wince_software_single_step): Use insert_single_step_breakpoint.

	* corelow.c (ignore): Remove unneeded prototype.  Update arguments.
	* exec.c (ignore): Likewise.
	* sol-thread.c (ignore): Likewise.

	* procfs.c (dbx_link_shadow_contents): Delete.
	(dbx_link_bpt): New.
	(procfs_mourn_inferior): Remove it if necessary.
	(remove_dbx_link_breakpoint): Use it.
	(insert_dbx_link_bpt_in_file): Set it.
	(procfs_init_inferior): Don't update dbx_link_bpt_addr.
	* rs6000-nat.c (exec_one_dummy_insn): Use
	deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* solib-irix.c (shadow_contents, breakpoint_addr): Delete.
	(base_breakpoint): New.
	(disable_break): Use it.
	(enable_break): Set it.

	* i386-nat.c (i386_insert_hw_breakpoint, i386_remove_hw_breakpoint):
	Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint)
	(ia64_memory_remove_breakpoint): Likewise.
	* m32r-tdep.c (m32r_memory_insert_breakpoint)
	(m32r_memory_remove_breakpoint): Likewise.
	* monitor.c (monitor_insert_breakpoint, monitor_remove_breakpoint):
	Likewise.  Remove unnecessary prototypes.  Use placed_address
	and placed_size.  Removed useless read from memory.
	* nto-procfs.c (procfs_insert_breakpoint)
	(procfs_remove_breakpoint, procfs_insert_hw_breakpoint)
	(procfs_remove_hw_breakpoint): Update.
	* ocd.c (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ocd.h (ocd_insert_breakpoint, ocd_remove_breakpoint): Likewise.
	* ppc-linux-tdep.c (ppc_linux_memory_remove_breakpoint): Likewise.
	* ppc-tdep.h (ppc_linux_memory_remove_breakpoint): Likewise.
	* remote-e7000.c (e7000_insert_breakpoint)
	(e7000_remove_breakpoint): Likewise.
	* remote-m32r-sdi.c (m32r_insert_breakpoint)
	(m32r_remove_breakpoint): Likewise.
	* remote-mips.c (mips_insert_breakpoint)
	(mips_remove_breakpoint): Likewise.
	* remote-rdp.c (remote_rdp_insert_breakpoint)
	(remote_rdp_remove_breakpoint): Likewise.
	(rdp_step): Use deprecated_insert_raw_breakpoint and
	deprecated_remove_raw_breakpoint.
	* remote-sds.c (sds_insert_breakpoint, sds_remove_breakpoint):
	Update.
	* remote-sim.c (gdbsim_insert_breakpoint, gdbsim_remove_breakpoint):
	Delete.
	(init_gdbsim_ops): Use memory_insert_breakpoint and
	memory_remove_breakpoint.
	* remote-st.c (st2000_insert_breakpoint)
	(st2000_remove_breakpoint): Update.  Remove unused
	BREAKPOINT_FROM_PC.
	* remote.c (remote_insert_breakpoint, remote_remove_breakpoint):
	Update.  Use placed_address and placed_size.
	(remote_insert_hw_breakpoint, remote_remove_hw_breakpoint): Likewise.
gdb/doc/
	* gdbint.texinfo (x86 Watchpoints, Target Conditionals): Update insert
	and remove breakpoint prototypes.
	(Watchpoints): Move description of target_insert_hw_breakpoint and
	target_remove_hw_breakpoint ...
	(Breakpoints): ... to here.  Document target_insert_breakpoint and
	target_remove_breakpoint.
@
text
@d3 2
a4 2
   Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2006 Free Software Foundation, Inc.
@


1.68
log
@	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.

	* gnu-nat.c (gnu_create_inferior): Don't call proceed.
	* go32-nat.c (go32_create_inferior): Likewise.
	* nto-procfs.c (procfs_create_inferior): Likewise.
	* procfs.c (procfs_create_inferior): Likewise.
	* remote-sim.c (gdbsim_create_inferior): Likewise.
	* remote.c (extended_remote_create_inferior)
	(extended_remote_async_create_inferior): Likewise.
	* win32-nat.c (win32_create_inferior): Likewise.
	* wince.c (child_create_inferior): Likewise.

	* monitor.c (monitor_create_inferior): Don't call proceed.
	Set the PC manually.
	* ocd.c (ocd_create_inferior): Likewise.
	* remote-e7000.c (e7000_create_inferior): Likewise.
	* remote-m32r-sdi.c (m32r_create_inferior): Likewise.
	* remote-mips.c (mips_create_inferior): Likewise.
	* remote-rdp.c (remote_rdp_create_inferior): Likewise.
	* remote-sds.c (sds_create_inferior): Likewise.
	* remote-st.c (st2000_create_inferior): Likewise.

	* inf-ptrace.c (inf_ptrace_create_inferior): Don't call
	proceed or observer_notify_inferior_created.
	* inf-ttrace.c (inf_ttrace_create_inferior): Likewise.
	* inftarg.c (child_create_inferior): Likewise.
@
text
@d2219 3
a2221 4
   the target location in the target machine.  CONTENTS_CACHE is a
   pointer to memory allocated for saving the target contents.  It is
   guaranteed by the caller to be long enough to save the breakpoint
   length returned by BREAKPOINT_FROM_PC.  */
d2224 1
a2224 1
mips_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
d2227 2
a2228 1
    return set_breakpoint (addr, MIPS_INSN32_SIZE, BREAK_FETCH);
d2230 1
a2230 1
    return memory_insert_breakpoint (addr, contents_cache);
d2234 1
a2234 1
mips_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
d2237 2
a2238 1
    return clear_breakpoint (addr, MIPS_INSN32_SIZE, BREAK_FETCH);
d2240 1
a2240 1
    return memory_remove_breakpoint (addr, contents_cache);
@


1.68.8.1
log
@Merge to branch:
  http://sourceware.org/ml/gdb-patches/2006-04/msg00139.html
@
text
@d2219 4
a2222 3
   the target location in the target machine.  BPT is the breakpoint
   being inserted or removed, which contains memory for saving the
   target contents.  */
d2225 1
a2225 1
mips_insert_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d2230 1
a2230 1
    return memory_insert_breakpoint (addr, bpt);
d2234 1
a2234 1
mips_remove_breakpoint (CORE_ADDR addr, struct bp_location *bpt)
d2239 1
a2239 1
    return memory_remove_breakpoint (addr, bpt);
@


1.67
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d4 1
a4 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d2200 1
a2200 1
  proceed (entry_pt, TARGET_SIGNAL_DEFAULT, 0);
@


1.66
log
@	* remote-st.c (_initialize_remote_st2000): Remove the extraneous
	"<command>" string from the call to add_com.
	* remote-sim.c (_initialize_remote_sim): Ditto.
	* remote-utils.c (_initialize_sr_support): Ditto.
	* remote-mips.c (_initialize_remote_mips): Ditto.
@
text
@d3 1
a3 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
d23 2
a24 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.66.8.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d2200 1
a2200 1
  write_pc (entry_pt);
@


1.66.4.1
log
@	Backport:
	2006-01-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	* infcmd.c: Include "observer.h".
	(post_create_inferior): New function.
	(run_command_1): Call it.  Also call proceed.
	* inferior.h (post_create_inferior): New prototype.
	* Makefile.in (infcmd.o): Update.
...
@
text
@d2200 1
a2200 1
  write_pc (entry_pt);
@


1.65
log
@2005-02-21  Andrew Cagney  <cagney@@gnu.org>

	Add more uses of add_setshow_string_cmd, add_setshow_integer_cmd,
	and add_setshow_string_noescape_cmd.
	* cli/cli-setshow.c (deprecated_show_value_hack): Do not print a
	NULL command's value.
	* kod.c, language.c, ocd.c, remote-e7000.c, remote-mips.c: Update.
	* remote-sds.c, remote.c, symfile.c, top.c: Update.
@
text
@d3419 1
a3419 1
  add_com ("pmon <command>", class_obscure, pmon_command,
@


1.64
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_zinteger_cmd through out.  Re-sync gdbarch.sh
	and gdbarch.c.
	* breakpoint.c, frame.c, gdb-events.sh, gdbarch.sh: Update.
	* gdbtypes.c, infrun.c, linux-nat.c, maint.c, monitor.c: Update.
	* pa64solib.c, parse.c, remote-mips.c, ser-go32.c: Update.
	* serial.c, solib-frv.c, somsolib.c, target.c, top.c: Update.
	* varobj.c, cli/cli-cmds.c: Update.
	* gdbarch.c, gdb-events.c: Regenerate.
@
text
@d3402 7
a3408 6
  deprecated_add_show_from_set
    (add_set_cmd ("monitor-prompt", class_obscure, var_string,
		  (char *) &mips_monitor_prompt,
		  "Set the prompt that GDB expects from the monitor.",
		  &setlist),
     &showlist);
@


1.63
log
@2005-02-18  Andrew Cagney  <cagney@@gnu.org>

	Use add_setshow_boolean_command through out.  Delete #ifdef 0'ed
	code adding set/show boolean commands.
	* cp-valprint.c, dcache.c, exec.c, gdbtypes.c, infrun.c: Update.
	* monitor.c, p-valprint.c, pa64solib.c, printcmd.c: Update.
	* proc-api.c, remote-mips.c, remote.c, solib.c: Update.
	* somsolib.c, symfile.c, top.c, utils.c, valops.c: Update.
	* valprint.c, win32-nat.c, wince.c, xcoffsolib.c: Update.
	* cli/cli-cmds.c: Update.
@
text
@d3373 11
a3383 11
  deprecated_add_show_from_set
    (add_set_cmd ("timeout", no_class, var_zinteger,
		  (char *) &mips_receive_wait,
		  "Set timeout in seconds for remote MIPS serial I/O.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("retransmit-timeout", no_class, var_zinteger,
		  (char *) &mips_retransmit_wait, "\
Set retransmit timeout in seconds for remote MIPS serial I/O.\n\
d3385 9
a3393 7
before resending the packet.", &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("syn-garbage-limit", no_class, var_zinteger,
		  (char *) &mips_syn_garbage, "\
Set the maximum number of characters to ignore when scanning for a SYN.\n\
d3397 4
a3400 3
ignored.)",
		  &setlist),
     &showlist);
d3409 8
a3416 8
  deprecated_add_show_from_set
    (add_set_cmd ("monitor-warnings", class_obscure, var_zinteger,
		  (char *) &monitor_warnings,
		  "Set printing of monitor warnings.\n"
		  "When enabled, monitor warnings about hardware breakpoints "
		  "will be displayed.",
		  &setlist),
     &showlist);
@


1.62
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d3418 7
a3424 7
  deprecated_add_show_from_set
    (add_set_cmd ("mask-address", no_class,
		  var_boolean, &mask_address_p, "\
Set zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets.\n\
Use \"on\" to enable the masking and \"off\" to disable it.\n",
		  &setlist),
     &showlist);
@


1.61
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d3416 1
a3416 1
	   "Send a packet to PMON (must be in debug mode).");
@


1.60
log
@2005-01-19  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (deprecated_throw_reason): Rename throw_reason.
	* exceptions.c (deprecated_throw_reason): Rename throw_reason.
	* utils.c (internal_verror, quit): Update.
	* remote-sds.c (interrupt_query): Update.
	* remote-mips.c (mips_error, mips_kill): Update.
	* remote-fileio.c (remote_fileio_ctrl_c_signal_handler): Update.
	* remote.c (interrupt_query): Update.
	* ocd.c (interrupt_query): Update.
	* nto-procfs.c (interrupt_query): Update.
	* monitor.c (monitor_interrupt_query): Update.
	* breakpoint.c (break_command_1): Update.
@
text
@d1216 1
a1216 1
			"mips_request: Trying to send command before reply");
d1227 1
a1227 1
		    "mips_request: Trying to get reply before command");
d2543 1
a2543 1
	      internal_error (__FILE__, __LINE__, "failed internal consistency check");
@


1.59
log
@2005-01-14  Andrew Cagney  <cagney@@gnu.org>

	* remote-sds.c (interrupt_query): Call throw_reason instead of
	throw_exception.
	* remote-mips.c (mips_error, mips_kill): Ditto
	* ocd.c (interrupt_query): Ditto.
	* nto-procfs.c (interrupt_query): Ditto.
	* monitor.c (monitor_interrupt_query): Ditto.
@
text
@d500 1
a500 1
  throw_reason (RETURN_ERROR);
d2151 1
a2151 1
	  throw_reason (RETURN_QUIT);
@


1.58
log
@2005-01-13  Michael Snyder  <msnyder@@redhat.com>

	* remote-mips.c: Whitespace tweaks.
@
text
@d500 1
a500 1
  throw_exception (RETURN_ERROR);
d2151 1
a2151 1
	  throw_exception (RETURN_QUIT);
@


1.57
log
@2005-01-12  Andrew Cagney  <cagney@@gnu.org>

	* exceptions.h (enum return_reason, RETURN_MASK)
	(RETURN_MASK_QUIT, RETURN_MASK_ERROR, RETURN_MASK_ALL)
	(return_mask, throw_exception, catch_exceptions_ftype)
	(catch_exceptions_with_msg, catch_errors_ftype, catch_errors)
	(catch_command_errors_ftype, catch_command_errors): Move to
	exceptions.h.
	* exceptions.c, exceptions.h: New files.
	* top.c: Do not include <setjmp.h>.
	(SIGJMP_BUF, SIGSETJMP, SIGLONGJMP, catch_return)
	(throw_exception, catcher, catch_exceptions)
	(catch_exceptions_with_msg, struct catch_errors_args)
	(do_catch_errors, catch_errors, struct captured_command_args)
	(do_captured_command, catch_command_errors): Move to exceptions.c.
	* wrapper.c, wince.c, win32-nat.c, utils.c: Include "exceptions.h".
	* tui/tui-interp.c, top.c, thread.c, symmisc.c: Ditto.
	* symfile-mem.c, stack.c, solib.c, rs6000-nat.c: Ditto.
	* remote-sds.c, remote-mips.c, remote-fileio.c: Ditto.
	* remote-e7000.c, objc-lang.c, ocd.c: Ditto.
	* remote.c, nto-procfs.c, monitor.c, mi/mi-main.c: Ditto.
	* main.c, m32r-rom.c, infrun.c, inf-loop.c: Ditto.
	* hppa-hpux-tdep.c, frame.c, event-top.c, event-loop.c: Ditto.
	* corelow.c, corefile.c, cli/cli-interp.c, breakpoint.c: Ditto.
	* ada-valprint.c, ada-lang.c: Ditto.
	* Makefile.in (HFILES_NO_SRCDIR, COMMON_OBS): Add exceptions.h and
	exceptions.o.  Update all dependencies.
@
text
@d2660 2
a2661 1
	      reclen = mips_make_srec (srec, '3', s->vma + i, buffer, numbytes);
d3178 2
a3179 1
		    pmon_make_fastrec (&bp, binbuf, &binptr, binamount, &reclen, &csum, &zerofill);
@


1.56
log
@2004-10-31  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-mips.h: Delete file.
	* remote-mips.c: Delete tm-mips.h from comment.
	* config/mips/embed.mt (DEPRECATED_TM_FILE): Delete.
	* config/mips/tm-nbsd.h: Don't include tm-mips.h.
	* config/mips/irix6.mt (DEPRECATED_TM_FILE): Delete.
	* config/mips/tm-linux.h: Don't include tm-mips.h.
	* config/mips/tm-vxmips.h: Don't include tm-mips.h.
	* config/mips/irix5.mt (DEPRECATED_TM_FILE):
	* config/mips/tm-wince.h: Don't include.
@
text
@d34 1
@


1.55
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* mips-tdep.h: Add comments on registers.
	(MIPS_UNUSED_REGNUM): Define.
	* config/mips/tm-mips.h (ZERO_REGNUM, UNUSED_REGNUM)
	(T9_REGNUM, V0_REGNUM, A0_REGNUM): Delete.
	* irix5-nat.c, mipsv4-nat.c, mips-linux-tdep.c: Update.
	* mips-linux-nat.c, remote-mips.c: Update.
@
text
@d1863 1
a1863 2
   register numbers used by the debugging protocol.  This function
   assumes that we are using tm-mips.h.  */
@


1.54
log
@2004-10-30  Andrew Cagney  <cagney@@gnu.org>

	* config/mips/tm-mips.h (MIPS16_INSTLEN, MIPS_NUMREGS)
	(MIPS_INSTLEN): Delete.
	* mips-tdep.h (enum mips_insn_size): Rename MIPS32_INSN_SIZE and
	MIPS16_INSN_SIZE to MIPS_INSN32_SIZE and MIPS_INSN16_SIZE.
	* remote-mips.c, mips-tdep.c: Update.
@
text
@d1908 1
a1908 1
  if (regno == DEPRECATED_FP_REGNUM || regno == ZERO_REGNUM)
@


1.53
log
@2004-10-29  Andrew Cagney  <cagney@@gnu.org>

	* frame.h (get_selected_frame): Add message parameter.
	* frame.c (get_selected_frame): Add and use message parameter.
	* stack.c (current_frame_command, return_command, locals_info)
	(catch_info, args_info, up_silently_base, down_silently_base): Use
	get_selected_frame with an explicit message.
	* thread.c, stack.c, sh-tdep.c, sh64-tdep.c: Update.
	* remote-rdp.c, remote-mips.c, remote-e7000.c: Update.
	* ocd.c, mi/mi-main.c, mi/mi-cmd-stack.c: Update.
	* infrun.c, inflow.c, infcmd.c, frame.c: Update.
	* findvar.c, eval.c, corelow.c, bsd-kvm.c: Update.
	* breakpoint.c: Update.
@
text
@d2228 1
a2228 1
    return set_breakpoint (addr, MIPS_INSTLEN, BREAK_FETCH);
d2237 1
a2237 1
    return clear_breakpoint (addr, MIPS_INSTLEN, BREAK_FETCH);
@


1.52
log
@2004-10-08  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Rename to_xfer_memory to
	deprecated_xfer_memory.
	* target.c: Update.
	(deprecated_debug_xfer_memory): Rename debug_to_xfer_memory.
	* wince.c: Update.
	* win32-nat.c: Update.
	* v850ice.c: Update.
	* uw-thread.c: Update.
	* thread-db.c: Update.
	* sol-thread.c: Update.
	* remote.c: Update.
	* remote-vx.c: Update.
	* remote-st.c: Update.
	* remote-sim.c: Update.
	* remote-sds.c: Update.
	* remote-rdp.c: Update.
	* remote-rdi.c: Update.
	* remote-mips.c: Update.
	* remote-m32r-sdi.c: Update.
	* remote-e7000.c: Update.
	* procfs.c: Update.
	* ppc-bdm.c: Update.
	* nto-procfs.c: Update.
	* monitor.c: Update.
	* linux-nat.c: Update.
	* inftarg.c: Update.
	* hpux-thread.c: Update.
	* go32-nat.c: Update.
	* gnu-nat.c: Update.
	* exec.c: Update.
	* corelow.c: Update.
	* bsd-kvm.c: Update.
	* aix-thread.c: Update.
@
text
@d1589 1
a1589 1
  print_stack_frame (get_selected_frame (), 0, SRC_AND_LOC);
@


1.51
log
@2004-08-02  Andrew Cagney  <cagney@@gnu.org>

	Replace DEPRECATED_REGISTER_RAW_SIZE with register_size.
	* rs6000-tdep.c (rs6000_push_dummy_call)
	(rs6000_extract_return_value): Use register_size.
	* xstormy16-tdep.c (xstormy16_get_saved_register)
	(xstormy16_extract_return_value): Ditto.
	* valops.c (value_assign): Ditto.
	* v850ice.c (v850ice_fetch_registers, v850ice_store_registers):
	* v850-tdep.c (v850_extract_return_value): Ditto.
	* tracepoint.c (collect_symbol): Ditto.
	* target.c (debug_print_register): Ditto.
	* stack.c (frame_info): Ditto.
	* rs6000-nat.c (ARCH64, fetch_register, store_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote.c (struct packet_reg, remote_wait, remote_async_wait)
	(store_register_using_P): Ditto.
	* remote-vxmips.c (vx_read_register, vx_write_register): Ditto.
	* remote-sim.c (gdbsim_fetch_register, gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump, sub2_from_pc): Ditto.
	* regcache.c (deprecated_read_register_bytes)
	(deprecated_write_register_bytes, read_register)
	(write_register): Ditto.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_register)
	(supply_vrregset, store_altivec_register, fill_vrregset): Ditto.
	* monitor.c (monitor_supply_register, monitor_fetch_register)
	(monitor_store_register): Ditto.
	* mn10300-tdep.c (mn10300_pop_frame_regular)
	(mn10300_print_register): Ditto.
	* mipsv4-nat.c (fill_fpregset): Ditto.
	* mips-linux-tdep.c (supply_32bit_reg, fill_fpregset)
	(mips64_fill_fpregset): Ditto.
	* mi/mi-main.c (register_changed_p, get_register)
	(mi_cmd_data_write_register_values): Ditto.
	* lynx-nat.c (fetch_inferior_registers, store_inferior_registers):
	* irix5-nat.c (fill_gregset, fetch_core_registers):
	* infrun.c (write_inferior_status_register): Ditto.
	* infptrace.c (fetch_register, store_register): Ditto.
	* infcmd.c (default_print_registers_info): Ditto.
	* ia64-linux-nat.c (COPY_REG, fill_fpregset): Ditto.
	* ia64-aix-nat.c (COPY_REG, fill_gregset): Ditto.
	* i386gnu-nat.c (gnu_store_registers, fill): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers)
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (store_inferior_registers, fetch_register):
	* findvar.c (value_from_register): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register):
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* alpha-tdep.h: Ditto.
	* aix-thread.c (pd_enable, fill_sprs64, fill_sprs32): Ditto.
@
text
@d3309 1
a3309 1
  mips_ops.to_xfer_memory = mips_xfer_memory;
@


1.50
log
@2004-07-26  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (deprecated_add_show_from_set): Deprecate.
	* xcoffsolib.c (_initialize_xcoffsolib): Update.
	* wince.c (_initialize_wince): Update.
	* win32-nat.c (_initialize_win32_nat): Update.
	* varobj.c (_initialize_varobj): Update.
	* valops.c (_initialize_valops): Update.
	* utils.c (initialize_utils, initialize_utils): Update.
	* tui/tui-win.c (_initialize_tui_win): Update.
	* top.c (init_main): Update.
	* symfile.c (_initialize_symfile): Update.
	* source.c (_initialize_source): Update.
	* somsolib.c (_initialize_som_solib): Update.
	* solib.c (_initialize_solib): Update.
	* solib-frv.c (_initialize_frv_solib): Update.
	* serial.c (_initialize_serial): Update.
	* ser-go32.c (_initialize_ser_dos, _initialize_ser_dos): Update.
	* remote.c (_initialize_remote, _initialize_remote): Update.
	* remote-vx.c (_initialize_vx): Update.
	* remote-utils.c (_initialize_sr_support): Update.
	* remote-sds.c (_initialize_remote_sds): Update.
	* remote-mips.c (_initialize_remote_mips): Update.
	* remote-e7000.c (_initialize_remote_e7000): Update.
	* proc-api.c (_initialize_proc_api): Update.
	* printcmd.c: Update.
	* parse.c (_initialize_parse): Update.
	* pa64solib.c (_initialize_pa64_solib): Update.
	* p-valprint.c (_initialize_pascal_valprint): Update.
	* monitor.c (_initialize_remote_monitors): Update.
	* mips-tdep.c (_initialize_mips_tdep): Update.
	* mcore-tdep.c (_initialize_mcore_tdep): Update.
	* maint.c (_initialize_maint_cmds): Update.
	* lin-lwp.c (_initialize_lin_lwp): Update.
	* language.c (_initialize_language): Update.
	* kod.c (_initialize_kod): Update.
	* infrun.c (set_schedlock_func, _initialize_infrun): Update.
	* i386-tdep.c (_initialize_i386_tdep): Update.
	* gdbtypes.c (build_gdbtypes, _initialize_gdbtypes): Update.
	* gdbarch.sh: Update.
	* gdbarch.c: Re-generate.
	* gdb-events.sh: Update.
	* gdb-events.c: Re-generate.
	* frame.c (_initialize_frame): Update.
	* exec.c: Update.
	* demangle.c (_initialize_demangler): Update.
	* dcache.c (_initialize_dcache): Update.
	* cris-tdep.c (_initialize_cris_tdep, cris_version_update): Update.
	* cp-valprint.c (_initialize_cp_valprint): Update.
	* corefile.c (_initialize_core): Update.
	* command.h: Update.
	* cli/cli-decode.h: Update.
	* cli/cli-cmds.c (init_cli_cmds): Update.
	* charset.c (_initialize_charset): Update.
	* breakpoint.c (_initialize_breakpoint): Update.
	* arm-tdep.c (_initialize_arm_tdep_initialize_arm_tdep): Update.
	* alpha-tdep.c (_initialize_alpha_tdep): Update.
	* aix-thread.c (_initialize_aix_thread): Update.
@
text
@d1760 1
a1760 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM), rpc);
d1763 1
a1763 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM), rfp);
d1766 1
a1766 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (SP_REGNUM), rsp);
d1769 1
a1769 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (DEPRECATED_FP_REGNUM), 0);
d1941 1
a1941 1
    store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regno), val);
@


1.49
log
@2004-07-21  Andrew Cagney  <cagney@@gnu.org>

	Use regcache_raw_supply instead of supply_register.
	* regcache.h (supply_register): Delete declaration.
	* regcache.c (supply_register): Delete function.
	* wince.c (do_child_fetch_inferior_registers): Update.
	* win32-nat.c (do_child_fetch_inferior_registers)
	(fetch_elf_core_registers): Update.
	* v850ice.c (v850ice_fetch_registers): Update.
	* thread-db.c (thread_db_store_registers): Update.
	* sol-thread.c (sol_thread_store_registers): Update.
	* shnbsd-tdep.c (shnbsd_supply_reg): Update.
	* rs6000-nat.c (fetch_register): Update.
	* rom68k-rom.c (rom68k_supply_one_register): Update.
	* remote.c (remote_wait, remote_async_wait): Update.
	* remote-st.c (get_hex_regs): Update.
	* remote-sim.c (gdbsim_fetch_register): Update.
	* remote-sds.c (sds_fetch_registers): Update.
	* remote-rdp.c (remote_rdp_fetch_register): Update.
	* remote-rdi.c (arm_rdi_fetch_registers): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-hms.c (init_hms_cmds): Update.
	* remote-est.c (init_est_cmds): Update.
	* remote-e7000.c (get_hex_regs, fetch_regs_from_dump)
	(e7000_fetch_registers, sub2_from_pc, e7000_wait): Update.
	* ppcnbsd-tdep.c (ppcnbsd_supply_reg, ppcnbsd_supply_fpreg): Update.
	* ppc-linux-nat.c (fetch_altivec_register, fetch_spe_register)
	(fetch_register, supply_vrregset, supply_vrregset)
	(fetch_spe_registers): Update.
	* ppc-bdm.c (bdm_ppc_fetch_registers): Update.
	* monitor.c (monitor_supply_register): Update.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Update.
	* mipsnbsd-tdep.c (mipsnbsd_supply_reg)
	(mipsnbsd_supply_fpreg): Update.
	* mips-nat.c (fetch_inferior_registers)
	(fetch_core_registers): Update.
	* mips-linux-tdep.c (supply_32bit_reg, supply_gregset)
	(supply_fpregset, mips64_supply_gregset)
	(mips64_supply_fpregset): Update.
	* m68klinux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* m68k-tdep.c (supply_gregset, supply_fpregset): Update.
	* m32r-rom.c (init_m32r_cmds, init_mon2000_cmds): Update.
	* lynx-nat.c (fetch_inferior_registers, fetch_core_registers): Update.
	* irix5-nat.c (supply_gregset, supply_fpregset): Update.
	* infptrace.c (fetch_register): Update.
	* ia64-linux-nat.c (supply_gregset, supply_fpregset): Update.
	* ia64-aix-nat.c (supply_gregset, supply_fpregset): Update.
	* i386gnu-nat.c (fetch_fpregs, supply_gregset)
	(gnu_fetch_registers, gnu_store_registers): Update.
	* i386-nto-tdep.c (i386nto_supply_gregset): Update.
	* i386-linux-nat.c (fetch_register, supply_gregset)
	(dummy_sse_values): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* hppah-nat.c (fetch_register): Update.
	* hppa-linux-nat.c (fetch_register, supply_gregset)
	(supply_fpregset): Update.
	* go32-nat.c (fetch_register): Update.
	* dve3900-rom.c (fetch_bitmapped_register)
	(_initialize_r3900_rom): Update.
	* cris-tdep.c (supply_gregset): Update.
	* abug-rom.c (init_abug_cmds): Update.
	* core-aout.c (fetch_core_registers): Update.
	* armnbsd-nat.c (supply_gregset, supply_fparegset)
	(fetch_register, fetch_fp_register): Update.
	* arm-linux-nat.c (fetch_nwfpe_single, fetch_nwfpe_none)
	(fetch_nwfpe_extended, fetch_fpregister, fetch_fpregs)
	(fetch_register, fetch_regs, supply_gregset, supply_fpregset): Update.
	* alphanbsd-tdep.c (fetch_core_registers): Update.
	* alpha-tdep.c (alpha_supply_int_regs, alpha_supply_fp_regs): Update.
	* alpha-nat.c (fetch_osf_core_registers)
	(fetch_osf_core_registers, fetch_osf_core_registers): Update.
	* aix-thread.c (supply_gprs64, supply_reg32, supply_fprs)
	(supply_sprs64, supply_sprs32, fetch_regs_kernel_thread): Update.
@
text
@d3371 11
a3381 11
  add_show_from_set (
		      add_set_cmd ("timeout", no_class, var_zinteger,
				   (char *) &mips_receive_wait,
		       "Set timeout in seconds for remote MIPS serial I/O.",
				   &setlist),
		      &showlist);

  add_show_from_set (
		  add_set_cmd ("retransmit-timeout", no_class, var_zinteger,
			       (char *) &mips_retransmit_wait,
			       "Set retransmit timeout in seconds for remote MIPS serial I/O.\n\
d3384 1
a3384 1
		      &showlist);
d3386 4
a3389 4
  add_show_from_set (
		   add_set_cmd ("syn-garbage-limit", no_class, var_zinteger,
				(char *) &mips_syn_garbage,
				"Set the maximum number of characters to ignore when scanning for a SYN.\n\
d3391 5
a3395 4
synchronize with the remote system.  A value of -1 means that there is no limit\n\
(Note that these characters are printed out even though they are ignored.)",
				&setlist),
		      &showlist);
d3397 1
a3397 1
  add_show_from_set
d3404 8
a3411 8
  add_show_from_set (
	       add_set_cmd ("monitor-warnings", class_obscure, var_zinteger,
			    (char *) &monitor_warnings,
			    "Set printing of monitor warnings.\n"
		"When enabled, monitor warnings about hardware breakpoints "
			    "will be displayed.",
			    &setlist),
		      &showlist);
d3416 4
a3419 3
  add_show_from_set (add_set_cmd ("mask-address", no_class,
				  var_boolean, &mask_address_p,
				  "Set zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets.\n\
d3421 2
a3422 2
				  &setlist),
		     &showlist);
@


1.48
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@d1761 1
a1761 1
      supply_register (PC_REGNUM, buf);
d1764 1
a1764 1
      supply_register (30, buf);	/* This register they are avoiding and so it is unnamed */
d1767 1
a1767 1
      supply_register (SP_REGNUM, buf);
d1770 1
a1770 1
      supply_register (DEPRECATED_FP_REGNUM, buf);
d1942 1
a1942 1
    supply_register (regno, buf);
@


1.47
log
@2004-05-25  Andrew Cagney  <cagney@@gnu.org>

	* target.h (struct target_ops): Add from_tty to
	to_create_inferior.
	(target_create_inferior, find_default_create_inferior): Update.
	* infcmd.c (run_command): Update.
	* wince.c (child_create_inferior): Update.
	* win32-nat.c (child_create_inferior): Update.
	* uw-thread.c (uw_thread_create_inferior): Update.
	* thread-db.c (thread_db_create_inferior): Update.
	* target.c (debug_to_create_inferior)
	(find_default_create_inferior): Update.
	(maybe_kill_then_create_inferior): Update.
	* sol-thread.c (sol_thread_create_inferior): Update.
	* remote.c (extended_remote_async_create_inferior)
	(extended_remote_create_inferior): Update.
	* remote-vx.c (vx_create_inferior): Update.
	* remote-st.c (st2000_create_inferior): Update.
	* remote-sim.c (gdbsim_create_inferior): Update.
	* remote-sds.c (sds_create_inferior): Update.
	* remote-rdp.c (remote_rdp_create_inferior): Update.
	* remote-rdi.c (arm_rdi_create_inferior): Update.
	* remote-m32r-sdi.c (m32r_create_inferior): Update.
	* remote-e7000.c (e7000_create_inferior): Update.
	* procfs.c (procfs_create_inferior): Update.
	* ocd.c (ocd_create_inferior): Update.
	* ocd.h (ocd_create_inferior): Update.
	* nto-procfs.c (procfs_create_inferior): Update.
	* monitor.c (monitor_create_inferior): Update.
	* lin-lwp.c (lin_lwp_create_inferior): Update.
	* inftarg.c (child_create_inferior): Update.
	* hpux-thread.c (hpux_thread_create_inferior): Update.
	* gnu-nat.c (gnu_create_inferior): Update.
@
text
@d4 1
a4 1
   2002 Free Software Foundation, Inc.
d2651 1
a2651 1
			   (long) (s->vma + s->_raw_size));
d2654 1
a2654 1
	  for (i = 0; i < s->_raw_size; i += numbytes)
d2656 1
a2656 1
	      numbytes = min (srec_frame, s->_raw_size - i);
d3138 2
a3139 2
	bintotal += s->_raw_size;
	final = (s->vma + s->_raw_size);
d3142 1
a3142 1
			 (unsigned int) (s->vma + s->_raw_size));
d3163 3
a3165 1
	    for (i = 0; ((i < s->_raw_size) && !finished); i += binamount)
d3169 1
a3169 1
		binamount = min (BINCHUNK, s->_raw_size - i);
@


1.46
log
@2004-04-28  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (print_stack_frame_stub): Delete declaration.
	(struct print_stack_frame_args, print_stack_frame)
	(print_frame_info, print_frame): Replace "source" with print what.
	Replace "print" with "print_level".  Replace "args" with
	"print_args".
	* frame.h (show_and_print_stack_frame, print_stack_frame)
	(print_frame_info): Update declarations.
	* stack.c (select_and_print_frame, frame_command)
	(current_frame_command, up_command, down_command): Update calls -
	use get_selected_frame, pass "enum print_what" for source, do not
	call frame_relative_level.
	* mi/mi-cmd-stack.c (mi_cmd_stack_list_frames): Ditto.
	* remote-rdp.c (remote_rdp_open): Ditto.
	* remote-mips.c (common_open): Ditto.
	* remote-e7000.c (e7000_start_remote): Ditto.
	* ocd.c (ocd_start_remote): Ditto.
	* mi/mi-main.c (mi_cmd_exec_return): Ditto.
	* infrun.c (normal_stop): Ditto.
	* inflow.c (kill_command): Ditto.
	* infcmd.c (finish_command): Ditto.
	* corelow.c (core_open): Ditto.
	* tracepoint.c (finish_tfind_command): Ditto.
	* thread.c (info_threads_command, info_threads_command)
	(restore_current_thread, do_captured_thread_select): Ditto.
	* ada-tasks.c (task_command): Ditto.
@
text
@a116 2
static void mips_create_inferior (char *execfile, char *args, char **env);

d2179 1
a2179 1
mips_create_inferior (char *execfile, char *args, char **env)
@


1.45
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* annotate.h (deprecated_annotate_starting_hook)
	(deprecated_annotate_stopped_hook)
	(deprecated_annotate_exited_hook)
	(deprecated_annotate_signal_hook)
	(deprecated_annotate_signalled_hook): Deprecate.
	* tracepoint.h (deprecated_create_tracepoint_hook)
	(deprecated_delete_tracepoint_hook)
	(deprecated_modify_tracepoint_hook)
	(deprecated_trace_find_hook)
	(deprecated_trace_start_stop_hook): Deprecate.
	* target.h (deprecated_target_new_objfile_hook): Deprecate.
	* remote.h (deprecated_target_resume_hook)
	(deprecated_target_wait_loop_hook): Deprecate.
	* gdbcore.h (deprecated_exec_file_display_hook)
	(deprecated_file_changed_hook): Deprecate.
	* frame.h (deprecated_selected_frame_level_changed_hook): Deprecate.
	* defs.h (deprecated_modify_breakpoint_hook)
	(deprecated_command_loop_hook, deprecated_show_load_progress)
	(deprecated_print_frame_info_listing_hook)
	(deprecated_query_hook, deprecated_warning_hook)
	(deprecated_flush_hook, deprecated_create_breakpoint_hook)
	(deprecated_delete_breakpoint_hook)
	(deprecated_interactive_hook, deprecated_registers_changed_hook)
	(deprecated_readline_begin_hook, deprecated_readline_hook)
	(deprecated_readline_end_hook, deprecated_register_changed_hook)
	(deprecated_memory_changed_hook, deprecated_init_ui_hook)
	(deprecated_context_hook, deprecated_target_wait_hook)
	(deprecated_attach_hook, deprecated_detach_hook)
	(deprecated_call_command_hook, deprecated_set_hook)
	(deprecated_error_hook, deprecated_error_begin_hook)
	(deprecated_ui_load_progress_hook): Deprecate.
	* valops.c, uw-thread.c, utils.c, tui/tui-io.c: Update.
	* tui/tui-hooks.c, tracepoint.c, top.c, thread-db.c: Update.
	* target.c, symfile.c, stack.c, sol-thread.c, rs6000-nat.c: Update.
	* remote.c, remote-mips.c, regcache.c, mi/mi-interp.c: Update.
	* main.c, interps.c, infcmd.c, hpux-thread.c, frame.c: Update.
	* exec.c, dsrec.c, d10v-tdep.c, corefile.c, complaints.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, breakpoint.c: Update.
	* annotate.c, aix-thread.c: Update.
@
text
@d1591 1
a1591 1
  print_stack_frame (get_selected_frame (), -1, 1);
@


1.44
log
@2004-01-20  Andrew Cagney  <cagney@@redhat.com>

	* ax-gdb.c (print_axs_value): Delete unused function.
	* jv-lang.c (java_lookup_type): Delete unused function.
	* cli/cli-dump.c (dump_filetype): Delete unused function.
	* remote-mips.c (remote_mips_insert_hw_breakpoint)
	(remote_mips_remove_hw_breakpoint): Delete unused functions.
	(mips_getstring): Delete unused function.
	(pmon_insert_breakpoint): Delete #if0ed function.
	(PMON_MAX_BP): Delete #if0ed MACRO.
	(mips_pmon_bp_info): Delete #if0ed variable.
	(pmon_remove_breakpoint): Delete #if0ed function.
	* monitor.c (monitor_write_even_block): Delete unused function.
	(monitor_write_memory_block): Delete #if0ed code.
	* dink32-rom.c (dink32_load): Delete unused function.
	(_initialize_dink32_rom): Delete #if0ed code.
	* d10v-tdep.c (d10v_daddr_p): Delete unused function.
@
text
@d2665 2
a2666 2
	      if (ui_load_progress_hook)
		ui_load_progress_hook (s->name, i);
d3189 2
a3190 2
			if (ui_load_progress_hook)
			  ui_load_progress_hook (s->name, i);
@


1.44.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d4 1
a4 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d117 2
d1591 1
a1591 1
  print_stack_frame (get_selected_frame (), 0, SRC_AND_LOC);
d1762 2
a1763 2
      store_unsigned_integer (buf, register_size (current_gdbarch, PC_REGNUM), rpc);
      regcache_raw_supply (current_regcache, PC_REGNUM, buf);
d1765 2
a1766 2
      store_unsigned_integer (buf, register_size (current_gdbarch, PC_REGNUM), rfp);
      regcache_raw_supply (current_regcache, 30, buf);	/* This register they are avoiding and so it is unnamed */
d1768 2
a1769 2
      store_unsigned_integer (buf, register_size (current_gdbarch, SP_REGNUM), rsp);
      regcache_raw_supply (current_regcache, SP_REGNUM, buf);
d1771 2
a1772 2
      store_unsigned_integer (buf, register_size (current_gdbarch, DEPRECATED_FP_REGNUM), 0);
      regcache_raw_supply (current_regcache, DEPRECATED_FP_REGNUM, buf);
d1943 2
a1944 2
    store_unsigned_integer (buf, register_size (current_gdbarch, regno), val);
    regcache_raw_supply (current_regcache, regno, buf);
d2181 1
a2181 1
mips_create_inferior (char *execfile, char *args, char **env, int from_tty)
d2653 1
a2653 1
			   (long) (s->vma + bfd_get_section_size (s)));
d2656 1
a2656 1
	  for (i = 0; i < bfd_get_section_size (s); i += numbytes)
d2658 1
a2658 1
	      numbytes = min (srec_frame, bfd_get_section_size (s) - i);
d2665 2
a2666 2
	      if (deprecated_ui_load_progress_hook)
		deprecated_ui_load_progress_hook (s->name, i);
d3140 2
a3141 2
	bintotal += bfd_get_section_size (s);
	final = (s->vma + bfd_get_section_size (s));
d3144 1
a3144 1
			 (unsigned int) (s->vma + bfd_get_section_size (s)));
d3165 1
a3165 3
	    for (i = 0;
		 i < bfd_get_section_size (s) && !finished;
		 i += binamount)
d3169 1
a3169 1
		binamount = min (BINCHUNK, bfd_get_section_size (s) - i);
d3189 2
a3190 2
			if (deprecated_ui_load_progress_hook)
			  deprecated_ui_load_progress_hook (s->name, i);
d3371 11
a3381 11
  deprecated_add_show_from_set
    (add_set_cmd ("timeout", no_class, var_zinteger,
		  (char *) &mips_receive_wait,
		  "Set timeout in seconds for remote MIPS serial I/O.",
		  &setlist),
     &showlist);

  deprecated_add_show_from_set
    (add_set_cmd ("retransmit-timeout", no_class, var_zinteger,
		  (char *) &mips_retransmit_wait, "\
Set retransmit timeout in seconds for remote MIPS serial I/O.\n\
d3384 1
a3384 1
     &showlist);
d3386 4
a3389 4
  deprecated_add_show_from_set
    (add_set_cmd ("syn-garbage-limit", no_class, var_zinteger,
		  (char *) &mips_syn_garbage, "\
Set the maximum number of characters to ignore when scanning for a SYN.\n\
d3391 4
a3394 5
synchronize with the remote system.  A value of -1 means that there is no\n\
limit. (Note that these characters are printed out even though they are\n\
ignored.)",
		  &setlist),
     &showlist);
d3396 1
a3396 1
  deprecated_add_show_from_set
d3403 8
a3410 8
  deprecated_add_show_from_set
    (add_set_cmd ("monitor-warnings", class_obscure, var_zinteger,
		  (char *) &monitor_warnings,
		  "Set printing of monitor warnings.\n"
		  "When enabled, monitor warnings about hardware breakpoints "
		  "will be displayed.",
		  &setlist),
     &showlist);
d3415 3
a3417 4
  deprecated_add_show_from_set
    (add_set_cmd ("mask-address", no_class,
		  var_boolean, &mask_address_p, "\
Set zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets.\n\
d3419 2
a3420 2
		  &setlist),
     &showlist);
@


1.43
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.h (deprecated_mips_set_processor_regs_hack): Declare.
	* remote-mips.c (common_open): Instead of
	"mips_read_register_type" and "mips_set_processor_type_command"
	call "deprecated_mips_set_processor_regs_hack".
	* config/mips/tm-mips.h (mips_read_processor_type): Delete
	declaration.
	(mips_set_processor_type_command): Delete declaration.
	* mips-tdep.c (mips_gdbarch_init): Update comment.
	(mips_dump_tdep): Do not print MIPS_REGISTER_NAMES.
	(mips_set_processor_type): Delete function.
	(NUM_MIPS_PROCESSOR_REGS): Define.
	(mips_show_processor_type_command): Delete function.
	(mips_set_processor_type_command): Delete function.
	(tmp_mips_processor_type): Delete.
	(mips_processor_type): Delete.
	(mips_processor_type_table): Delete.
	(mips_r3051_reg_names): Delete.
	(mips_r3081_reg_names): Delete.
	(mips_lsi33k_reg_names): Delete.
	(mips_processor_reg_names): Delete.
	(mips_read_processor_type): Delete function.
	(deprecated_mips_set_processor_regs_hack): New function.
	(struct gdbarch_tdep): Add member "mips_processor_reg_names".
	(mips_register_name): Get the processor names from the tdep.
	(mips_tx39_reg_names): New array.
	(mips_generic_reg_names): Wire to a standard set of names.
	(mips_gdbarch_init): Set "mips_processor_reg_names".
	* config/mips/tm-irix5.h (MIPS_REGISTER_NAMES): Delete macro.
	* config/mips/tm-mips.h (MIPS_REGISTER_NAMES): Delete macro.
	* config/mips/tm-tx39.h (MIPS_REGISTER_NAMES): Delete macro.
@
text
@a601 29
/* Read the required number of characters into the given buffer (which
   is assumed to be large enough). The only failure is a timeout. */
static int
mips_getstring (char *string, int n)
{
  char *p = string;
  int c;

  immediate_quit++;
  while (n > 0)
    {
      c = serial_readchar (mips_desc, remote_timeout);

      if (c == SERIAL_TIMEOUT)
	{
	  fprintf_unfiltered (gdb_stderr,
		 "Failed to read %d characters from target (TIMEOUT)\n", n);
	  immediate_quit--;
	  return 0;
	}

      *p++ = c;
      n--;
    }

  immediate_quit--;
  return 1;
}

a2243 123
#if 0				/* currently not used */
/* PMON does not currently provide support for the debug mode 'b'
   commands to manipulate breakpoints. However, if we wanted to use
   the monitor breakpoints (rather than the GDB BREAK_INSN version)
   then this code performs the work needed to leave debug mode,
   set/clear the breakpoint, and then return to debug mode. */

#define PMON_MAX_BP (33)	/* 32 SW, 1 HW */
static CORE_ADDR mips_pmon_bp_info[PMON_MAX_BP];
/* NOTE: The code relies on this vector being zero-initialised by the system */

static int
pmon_insert_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  int status;

  if (monitor_supports_breakpoints)
    {
      char tbuff[12];		/* space for breakpoint command */
      int bpnum;
      CORE_ADDR bpaddr;

      /* PMON does not support debug level breakpoint set/remove: */
      if (mips_exit_debug ())
	mips_error ("Failed to exit debug mode");

      sprintf (tbuff, "b %08x\r", addr);
      mips_send_command (tbuff, 0);

      mips_expect ("Bpt ");

      if (!mips_getstring (tbuff, remote_timeout))
	return 1;
      tbuff[2] = '\0';		/* terminate the string */
      if (sscanf (tbuff, "%d", &bpnum) != 1)
	{
	  fprintf_unfiltered (gdb_stderr,
	      "Invalid decimal breakpoint number from target: %s\n", tbuff);
	  return 1;
	}

      mips_expect (" = ");

      /* Lead in the hex number we are expecting: */
      tbuff[0] = '0';
      tbuff[1] = 'x';

      /* FIXME!! only 8 bytes!  need to expand for Bfd64; 
         which targets return 64-bit addresses?  PMON returns only 32! */
      if (!mips_getstring (&tbuff[2], 8))
	return 1;
      tbuff[10] = '\0';		/* terminate the string */

      if (sscanf (tbuff, "0x%08x", &bpaddr) != 1)
	{
	  fprintf_unfiltered (gdb_stderr,
			    "Invalid hex address from target: %s\n", tbuff);
	  return 1;
	}

      if (bpnum >= PMON_MAX_BP)
	{
	  fprintf_unfiltered (gdb_stderr,
			      "Error: Returned breakpoint number %d outside acceptable range (0..%d)\n",
			      bpnum, PMON_MAX_BP - 1);
	  return 1;
	}

      if (bpaddr != addr)
	fprintf_unfiltered (gdb_stderr, "Warning: Breakpoint addresses do not match: 0x%x != 0x%x\n", addr, bpaddr);

      mips_pmon_bp_info[bpnum] = bpaddr;

      mips_expect ("\r\n");
      mips_expect (mips_monitor_prompt);

      mips_enter_debug ();

      return 0;
    }

  return mips_store_word (addr, BREAK_INSN, contents_cache);
}

static int
pmon_remove_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  if (monitor_supports_breakpoints)
    {
      int bpnum;
      char tbuff[7];		/* enough for delete breakpoint command */

      for (bpnum = 0; bpnum < PMON_MAX_BP; bpnum++)
	if (mips_pmon_bp_info[bpnum] == addr)
	  break;

      if (bpnum >= PMON_MAX_BP)
	{
	  fprintf_unfiltered (gdb_stderr,
			      "pmon_remove_breakpoint: Failed to find breakpoint at address 0x%s\n",
			      paddr_nz (addr));
	  return 1;
	}

      if (mips_exit_debug ())
	mips_error ("Failed to exit debug mode");

      sprintf (tbuff, "db %02d\r", bpnum);

      mips_send_command (tbuff, -1);
      /* NOTE: If the breakpoint does not exist then a "Bpt <dd> not
         set" message will be returned. */

      mips_enter_debug ();

      return 0;
    }

  return target_write_memory (addr, contents_cache, BREAK_INSN_SIZE);
}
#endif


a2276 25

/* Insert a hardware breakpoint.  This works only on LSI targets, which
   implement ordinary breakpoints using hardware facilities.  */

static int
remote_mips_insert_hw_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  if (strcmp (target_shortname, "lsi") == 0)
    return mips_insert_breakpoint (addr, contents_cache);
  else
    return -1;
}


/* Remove a hardware breakpoint.  This works only on LSI targets, which
   implement ordinary breakpoints using hardware facilities.  */

static int
remote_mips_remove_hw_breakpoint (CORE_ADDR addr, char *contents_cache)
{
  if (strcmp (target_shortname, "lsi") == 0)
    return mips_remove_breakpoint (addr, contents_cache);
  else
    return -1;
}
@


1.42
log
@2003-11-16  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (struct gdbarch_tdep): Add field "regnum".
	(mips_fpa0_regnum, mips_regnum): New function.
	(mips_gdbarch_init): Fill in the "regnum" fields.
	* mips-tdep.h (struct mips_regnum): Define.
	(mips_regnum): Declare.
	* config/mips/tm-mips.h (BADVADDR_REGNUM): Delete macro.
	(LO_REGNUM, HI_REGNUM, BADVADDR_REGNUM): Ditto.
	(CAUSE_REGNUM, PC_REGNUM, FP0_REGNUM): Ditto.
	(FCRCS_REGNUM, FCRIR_REGNUM, FPA0_REGNUM): Ditto.
	* config/mips/tm-irix6.h (FP0_REGNUM): Delete macro.
	(PC_REGNUM, CAUSE_REGNUM, BADVADDR_REGNUM): Ditto.
	(HI_REGNUM, LO_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): Ditto.
	* config/mips/tm-irix5.h (FP0_REGNUM): Delete macro.
	(PC_REGNUM, CAUSE_REGNUM, BADVADDR_REGNUM): Ditto.
	(HI_REGNUM, LO_REGNUM, FCRCS_REGNUM, FCRIR_REGNUM): Ditto.
	* remote-mips.c: Include "mips-tdep.h".  Update.
	* mipsnbsd-tdep.c: Update.
	* mipsv4-nat.c: Update.
	* mips-tdep.c: Update.
	* mips-nat.c: Update.
	* mips-linux-tdep.c: Update.
	* mips-linux-nat.c: Update.
	* irix5-nat.c: Update.
	* dve3900-rom.c: Include "mips-tdep.h".  Update.
	(ignore_packet): Supress GCC warning.
	* config/mips/nm-riscos.h: Update.
	* Makefile.in (dve3900-rom.o, remote-mips.o): Update dependencies.
@
text
@d1610 1
a1610 3
  ptype = mips_read_processor_type ();
  if (ptype)
    mips_set_processor_type_command (xstrdup (ptype), 0);
@


1.41
log
@	* remote-mips.c (mips_initialize): Remove unneeded call to
	get_selected_frame.  Suggested by Atsushi Nemoto <anemo@@mba.ocn.ne.jp>.
@
text
@d39 1
d1906 18
a1923 20
  if (regno >= FP0_REGNUM && regno < FP0_REGNUM + 32)
    return regno - FP0_REGNUM + 32;
  switch (regno)
    {
    case PC_REGNUM:
      return REGNO_OFFSET + 0;
    case CAUSE_REGNUM:
      return REGNO_OFFSET + 1;
    case HI_REGNUM:
      return REGNO_OFFSET + 2;
    case LO_REGNUM:
      return REGNO_OFFSET + 3;
    case FCRCS_REGNUM:
      return REGNO_OFFSET + 4;
    case FCRIR_REGNUM:
      return REGNO_OFFSET + 5;
    default:
      /* FIXME: Is there a way to get the status register?  */
      return 0;
    }
@


1.40
log
@2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_REGISTER_RAW_SIZE): Rename
	REGISTER_RAW_SIZE.
	* gdbarch.h, gdbarch.c: Re-generate.
	* aix-thread.c, alpha-tdep.h, arm-tdep.c, core-sol2.c: Update.
	* cris-tdep.c, dve3900-rom.c, findvar.c, frame.c: Update.
	* hppa-tdep.c, hppab-nat.c, hppah-nat.c, hppam3-nat.c: Update.
	* hpux-thread.c, i386gnu-nat.c, ia64-aix-nat.c: Update.
	* ia64-linux-nat.c, ia64-tdep.c, infcmd.c, infptrace.c: Update.
	* infrun.c, irix5-nat.c, lynx-nat.c, mips-linux-tdep.c: Update.
	* mips-nat.c, mips-tdep.c, mipsv4-nat.c, mn10300-tdep.c: Update.
	* monitor.c, ns32k-tdep.c, ppc-linux-nat.c, regcache.c: Update.
	* remote-e7000.c, remote-mips.c, remote-sim.c: Update.
	* remote-vxmips.c, remote-vxsparc.c, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, rs6000-tdep.c, s390-tdep.c: Update.
	* sh64-tdep.c, sparc-nat.c, sparc-tdep.c, stack.c: Update.
	* target.c, tracepoint.c, v850-tdep.c, v850ice.c, valops.c: Update.
	* vax-tdep.c, vax-tdep.h, x86-64-tdep.c, xstormy16-tdep.c: Update.
	* config/m68k/tm-delta68.h, config/m68k/tm-vx68.h: Update.
	* config/sparc/tm-sparc.h, config/sparc/tm-sparclynx.h: Update.

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Rename
	REGISTER_RAW_SIZE to DEPRECATED_REGISTER_RAW_SIZE.
	* gdb.texinfo (Packets, Stop Reply Packets): Ditto.
	* gdbint.texinfo (Target Architecture Definition): Rename

2003-10-02  Andrew Cagney  <cagney@@redhat.com>

	* mi-main.c: Rename REGISTER_RAW_SIZE to
	DEPRECATED_REGISTER_RAW_SIZE.
@
text
@a1496 4
  /* FIXME: cagney/2002-11-29: Force the update of selected frame.
     This shouldn't be necessary, only many many places still refer to
     selected_frame directly (instead of using get_selected_frame().  */
  get_selected_frame (); /* Hack!!!  */
@


1.39
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d1796 1
a1796 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (PC_REGNUM), rpc);
d1799 1
a1799 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (PC_REGNUM), rfp);
d1802 1
a1802 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (SP_REGNUM), rsp);
d1805 1
a1805 1
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (DEPRECATED_FP_REGNUM), 0);
d1979 1
a1979 1
    store_unsigned_integer (buf, REGISTER_RAW_SIZE (regno), val);
@


1.38
log
@2003-08-29  Andrew Cagney  <cagney@@redhat.com>

	* config/mips/tm-embed.h (STOPPED_BY_WATCHPOINT): Delete macro.
	(TARGET_CAN_USE_HARDWARE_WATCHPOINT): Delete macro.
	(target_remove_watchpoint): Delete macro.
	(target_insert_watchpoint): Delete macro.
	(remote_mips_can_use_hardware_watchpoint): Delete declaration.
	(remote_mips_stopped_by_watchpoint): Delete declaration.
	(remote_mips_remove_watchpoint): Delete declaration.
	(remote_mips_set_watchpoint): Delete declaration.
	(TARGET_HAS_HARDWARE_WATCHPOINTS): Delete macro.
	* remote-mips.c (_initialize_remote_mips): Set
	"to_insert_watchpoint", "to_stopped_by_watchpoint",
	"to_can_use_hardware_watchpoint", and "to_remove_watchpoint".
	(mips_insert_watchpoint): Rename remote_mips_set_watchpoint.
	(mips_remove_watchpoint): Rename remote_mips_remove_watchpoint.
	(mips_stopped_by_watchpoint): Rename
	remote_mips_stopped_by_watchpoint.
	(mips_can_hardware_watchpoint): Rename
	remote_mips_can_use_hardware_watchpoint, update function
	signature.
@
text
@d819 3
a821 3
  register const unsigned char *p;
  register int c;
  register int cksum;
d846 1
a846 1
  register int cksum;
@


1.37
log
@2003-08-04  Andrew Cagney  <cagney@@redhat.com>

	* monitor.h (monitor_dump_reg_block): Remove ATTR_FORMAT.
	* cli/cli-script.c (define_command): Call query directly, instead
	of passing it a buffer.
	* ocd.c (ocd_error): Pass error a constant format string.
	* remote-mips.c (mips_error): Use fputs_filtered.
@
text
@d2408 1
a2408 1
remote_mips_can_use_hardware_watchpoint (int cnt)
d2467 1
a2467 1
remote_mips_set_watchpoint (CORE_ADDR addr, int len, int type)
d2476 1
a2476 1
remote_mips_remove_watchpoint (CORE_ADDR addr, int len, int type)
d2485 1
a2485 1
remote_mips_stopped_by_watchpoint (void)
d3497 4
@


1.36
log
@2003-06-11  Andrew Cagney  <cagney@@redhat.com>

	* xstormy16-tdep.c (xstormy16_push_return_address): Make static.
	(xstormy16_save_dummy_frame_tos): Make static.
	(_initialize_xstormy16_tdep): Add declaration.
	* vax-tdep.c (_initialize_vax_tdep): Add declaration.
	* v850-tdep.c: Make local functions static.
	(_initialize_v850_tdep): Add declaration.
	* sparc-tdep.c: Make local functions static.
	(_initialize_sparc_tdep): Add declaration.
	* sh-tdep.c: Make local functions static.
	(_initialize_sh_tdep): Add declaration.
	* sh3-rom.c (_initialize_sh3_rom): Add declaration.
	* s390-tdep.c: Make local functions static.
	(_initialize_s390_tdep): Add declaration.
	* dbxread.c (find_stab_function_addr): Make static.
	* ppc-bdm.c (_initialize_bdm_ppc): Add declaration.
	* ocd.c (_initialize_remote_ocd): Add declaration.
	* dink32-rom.c (_initialize_dink32_rom): Add declaration.
	* ppcbug-rom.c (_initialize_ppcbug_rom): Add declaration.
	* ns32k-tdep.c (_initialize_ns32k_tdep): Add declaration.
	* ns32knbsd-tdep.c (_initialize_ns32knbsd_tdep): Add declaration.
	* mips-tdep.c (_initialize_mips_tdep): Add declaration.
	* remote-array.c (_initialize_array): Add declaration.
	(_initialize_remote_monitors): Add declaration.
	* remote-mips.c: Make local functions static.
	(_initialize_remote_mips): Add declaration.
	* mcore-tdep.c: Make all local functions static.
	(_initialize_mcore_tdep): Add declaration.
	* dbug-rom.c (_initialize_dbug_rom): Add declaration.
	* abug-rom.c (_initialize_abug_rom): Add declaration.
	* rom68k-rom.c (_initialize_rom68k): Add declaration.
	* cpu32bug-rom.c (_initialize_cpu32bug_rom): Add declaration.
	* m68k-tdep.c (_initialize_m68k_tdep): Add declaration.
	* remote-est.c (_initialize_est): Add declaration.
	* m68hc11-tdep.c (_initialize_m68hc11_tdep): Add declaration.
	(m68hc11_call_dummy_address): Make static.
	* ia64-tdep.c: Make local functions static.
	(_initialize_ia64_tdep): Add declaration.
	* solib-legacy.c (_initialize_svr4_lm): Add declaration.
	* monitor.c (monitor_wait_filter): Make static.
	(_initialize_remote_monitors): Add declaration.
	* remote-hms.c (_initialize_remote_hms): Add declaration.
	* remote-e7000.c (fetch_regs_from_dump): Make static.
	(expect_n): Make static.
	(_initialize_remote_e7000): Add declaration.
	* ser-e7kpc.c: Always include "defs.h".
	(_initialize_ser_e7000pc): Add declaration.
	* h8300-tdep.c (_initialize_h8300_tdep): Add declaration.
	* cris-tdep.c: Make all but one function static.
	(_initialize_cris_tdep): Add declaration.
	* solib-svr4.c (_initialize_svr4_solib): Add declaration.
	* solib.c (update_solib_list): Make static.
	(_initialize_solib): Add declaration.
	* avr-tdep.c (avr_breakpoint_from_pc): Make static.
	(_initialize_avr_tdep): Add declaration.
	* remote-rdi.c (voiddummy): Make static.
	(_initialize_remote_rdi): Add declaration.
	* arm-tdep.c (_initialize_arm_tdep): Add declaration.
	* remote-rdp.c (send_rdp): Make static.
	(_initialize_remote_rdp): Add declaration.
	* alpha-tdep.c (_initialize_alpha_tdep): Add declaration.
@
text
@d486 1
a486 1
    fprintf_filtered (gdb_stderr, error_pre_print);
@


1.36.4.1
log
@	* remote-mips.c (mips_initialize): Remove unneeded call to
	get_selected_frame.  Suggested by Atsushi Nemoto <anemo@@mba.ocn.ne.jp>.
@
text
@d1497 4
@


1.35
log
@2003-05-15  Andrew Cagney  <cagney@@redhat.com>

	* arch-utils.h (legacy_breakpoint_from_pc): Delete declaration.
	* target.h (memory_breakpoint_from_pc): Delete declaration.
	* mem-break.c (memory_breakpoint_from_pc): Delete function.
	* arch-utils.c (legacy_breakpoint_from_pc): Delete function.
	* monitor.c (monitor_insert_breakpoint): Use
	gdbarch_breakpoint_from_pc instead of memory_breakpoint_from_pc.
	* gdbarch.sh (BREAKPOINT_FROM_PC): Do not provide a default.
	* gdbarch.h, gdbarch.c: Re-generate.
	* sparc-tdep.c (sparc_breakpoint_from_pc): New function.
	(sparc_gdbarch_init): Set breakpoint_from_pc to
	sparc_breakpoint_from_pc.
	* config/sparc/tm-sparc.h (BREAKPOINT): Delete macro.
	(BREAKPOINT_FROM_PC): Define.
	(sparc_breakpoint_from_pc): Declare.
	* hppa-tdep.c (hppa_breakpoint_from_pc): New function.
	* config/pa/tm-hppa.h (hppa_breakpoint_from_pc): Declare.
	(BREAKPOINT_FROM_PC): Define.
	(BREAKPOINT): Delete macro.
	* target.h: Update comment.
	* s390-tdep.c (s390_gdbarch_init): Update comments.
	* remote.c: Update comments.
	* remote-mips.c: Update comments.
	* proc-api.c (write_with_trace): Do not check for a breakpoint.
	* mem-break.c: Update comment.
	* ia64-tdep.c (IA64_BREAKPOINT): Rename BREAKPOINT.
	(ia64_memory_insert_breakpoint): Update.
	* config/sparc/tm-sparc.h: Update comment.
	* config/pa/tm-hppa64.h: Update comment.
	* rs6000-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(rs6000_breakpoint_from_pc): Update.
	* mips-tdep.c (BIG_BREAKPOINT, LITTLE_BREAKPOINT): Delete macro.
	(PMON_BIG_BREAKPOINT, PMON_LITTLE_BREAKPOINT): Delete macro.
	(IDT_LITTLE_BREAKPOINT, IDT_LITTLE_BREAKPOINT): Delete macro.
	(MIPS16_LITTLE_BREAKPOINT, MIPS16_BIG_BREAKPOINT): Delete macro.
	(mips_breakpoint_from_pc): Update.
	(mips_dump_tdep): Update.
@
text
@d539 1
a539 1
int
d595 1
a595 1
int
d603 1
a603 1
int
d1724 1
a1724 1
enum target_signal
d2440 1
a2440 1
int
d2453 1
a2453 1
int
d3480 2
@


1.34
log
@2003-05-08  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (max_register_size): Delete declaration.
	* regcache.c (max_register_size): Delete function.
	(struct regcache_descr): Delete field "max_register_size".
	(init_regcache_descr, init_legacy_regcache_descr): Assert that all
	registers fit in MAX_REGISTER_SIZE.
	(regcache_save): Replace max_register_size with MAX_REGISTER_SIZE.
	(regcache_restore, regcache_xfer_part, regcache_dump): Ditto.
	* thread-db.c: Replace max_register_size with MAX_REGISTER_SIZE.
	* sh-tdep.c, rom68k-rom.c, remote-sim.c, remote-mips.c: Ditto.
	* remote-e7000.c, monitor.c, mipsv4-nat.c, mips-nat.c: Ditto.
	* m68klinux-nat.c, lynx-nat.c, irix4-nat.c: Ditto.
	* hpux-thread.c, hppah-nat.c, hppab-nat.c, hppa-tdep.c: Ditto.
	* dve3900-rom.c, hppa-tdep.c: Ditto.
@
text
@d2254 7
a2260 7
/* Insert a breakpoint.  On targets that don't have built-in breakpoint
   support, we read the contents of the target location and stash it,
   then overwrite it with a breakpoint instruction.  ADDR is the target
   location in the target machine.  CONTENTS_CACHE is a pointer to 
   memory allocated for saving the target contents.  It is guaranteed
   by the caller to be long enough to save sizeof BREAKPOINT bytes (this
   is accomplished via BREAKPOINT_MAX).  */
@


1.33
log
@2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbarch.sh (DEPRECATED_TARGET_READ_FP): Replace TARGET_READ_FP.
	(DEPRECATED_FP_REGNUM): Replace FP_REGNUM.
	* gdbarch.h, gdbarch.c: Re-generate.
	* infcall.c (call_function_by_hand): Use DEPRECATED_FP_REGNUM,
	DEPRECATED_TARGET_READ_FP, or "sp" to create the dummy frame ID.
	* inferior.h (deprecated_read_fp): Rename read_fp.
	(generic_target_read_fp): Delete declaration.
	* regcache.c (generic_target_read_fp): Delete function.
	(deprecated_read_fp): Replace read_fp, use
	DEPRECATED_TARGET_READ_FP or DEPRECATED_FP_REGNUM.
	* d10v-tdep.c (d10v_read_fp): Delete function.
	(d10v_gdbarch_init): Do not set deprecated_read_fp.

	* sparc-tdep.c (sparc_gdbarch_init): Do not set
	deprecated_target_read_fp to generic_target_read_fp.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.

	* xstormy16-tdep.c (xstormy16_gdbarch_init): Set
	deprecated_fp_regnum.
	* x86-64-tdep.c (x86_64_init_abi): Ditto.
	* vax-tdep.c (vax_gdbarch_init): Ditto.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mcore-tdep.c (mcore_gdbarch_init): Ditto.
	* m68k-tdep.c (m68k_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* i386-tdep.c (i386_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* h8300-tdep.c (h8300_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* cris-tdep.c (cris_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.
	* alpha-tdep.c (alpha_gdbarch_init): Ditto.

	* x86-64-tdep.c (x86_64_init_abi): Set deprecated_target_read_fp.
	* v850-tdep.c (v850_gdbarch_init): Ditto.
	* sparc-tdep.c (sparc_gdbarch_init): Ditto.
	* sh-tdep.c (sh_gdbarch_init): Ditto.
	* s390-tdep.c (s390_gdbarch_init): Ditto.
	* rs6000-tdep.c (rs6000_gdbarch_init): Ditto.
	* mn10300-tdep.c (mn10300_gdbarch_init): Ditto.
	* mips-tdep.c (mips_gdbarch_init): Ditto.
	* m68hc11-tdep.c (m68hc11_gdbarch_init): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* hppa-tdep.c (hppa_gdbarch_init): Ditto.
	* frv-tdep.c (frv_gdbarch_init): Ditto.
	* avr-tdep.c (avr_gdbarch_init): Ditto.
	* arm-tdep.c (arm_gdbarch_init): Ditto.

	* vax-tdep.c (vax_frame_init_saved_regs): Replace FP_REGNUM with
	DEPRECATED_FP_REGNUM.
	(vax_push_dummy_frame, vax_pop_frame): Ditto.
	* std-regs.c (value_of_builtin_frame_fp_reg): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Ditto.
	(sparc_push_dummy_frame, sparc64_read_fp): Ditto.
	(sparc32_register_virtual_type): Ditto.
	* sh-tdep.c (sh64_frame_chain): Ditto.
	(sh64_get_saved_register, sh64_pop_frame): Ditto.
	(sh_nofp_frame_init_saved_regs): Ditto.
	(sh64_nofp_frame_init_saved_regs): Ditto.
	(sh_fp_frame_init_saved_regs): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* procfs.c (procfs_fetch_registers): Ditto.
	(procfs_store_registers): Ditto.
	* ns32knbsd-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	(fetch_kcore_registers, clear_regs): Ditto.
	* ns32k-tdep.c (ns32k_frame_init_saved_regs): Ditto.
	(ns32k_push_dummy_frame, ns32k_pop_frame): Ditto.
	* nlm/i386.h (DEPRECATED_FP_REGNUM): Ditto.
	* nlm/i386.c (do_status): Ditto.
	* mipsv4-nat.c (supply_gregset): Ditto.
	* mips-tdep.c: Ditto for comments.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	(store_inferior_registers, fetch_core_registers): Ditto.
	* m68k-tdep.c (m68k_push_dummy_frame): Ditto.
	(m68k_pop_frame, m68k_frame_init_saved_regs): Ditto.
	* i386-tdep.c (i386_frame_init_saved_regs): Ditto.
	(i386_do_pop_frame, i386_register_type): Ditto.
	* hppa-tdep.c (hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, find_dummy_frame_regs): Ditto.
	(hppa_pop_frame, hppa_read_fp): Ditto.
	(skip_prologue_hard_way, hppa_frame_find_saved_regs): Ditto.
	* cris-tdep.c (cris_examine, cris_pop_frame): Ditto.
	* config/vax/nm-vax.h (REGISTER_U_ADDR): Ditto.
	* config/sparc/tm-sparc.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/sparc/tm-sp64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/s390/tm-s390.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/pa/tm-hppa64.h (DEPRECATED_FP_REGNUM): Ditto.
	* config/ia64/tm-ia64.h (DEPRECATED_FP_REGNUM): Ditto.
	* blockframe.c: Ditto for comments.
	* arch-utils.h: Ditto for comments.
	* arch-utils.c (legacy_virtual_frame_pointer): Ditto.
	* alphanbsd-tdep.c (fetch_core_registers): Ditto.
	* alphabsd-nat.c (fetch_inferior_registers): Ditto.
	* alpha-tdep.h: Ditto for comments.
	* alpha-tdep.c (alpha_cannot_fetch_register): Ditto.
	(alpha_cannot_store_register): Ditto.
	(alpha_push_dummy_frame): Ditto.
	* alpha-nat.c (supply_gregset): Ditto.

	* config/sparc/tm-sp64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/pa/tm-hppa64.h (DEPRECATED_TARGET_READ_FP): Update.
	* config/sparc/tm-sparc.h: Update comment.

	* hppa-tdep.c (hppa_init_extra_frame_info): Use
	deprecated_read_fp instead of TARGET_READ_FP.
	(hppa_init_extra_frame_info, hppa_frame_chain): Ditto.
	(hppa_push_dummy_frame, hppa_read_fp): Ditto.
	* sparc-tdep.c (sparc_init_extra_frame_info): Use
	deprecated_read_fp instead of read_fp.
	* s390-tdep.c (s390_push_arguments): Ditto.
	* ia64-tdep.c (ia64_gdbarch_init): Ditto.
	* frame.h: Ditto in comments.
	* frame.c (legacy_get_prev_frame): Ditto.
	* dummy-frame.c (dummy_frame_this_id): Ditto.
	* arm-tdep.c (arm_init_extra_frame_info): Ditto.

2003-04-28  Andrew Cagney  <cagney@@redhat.com>

	* gdbint.texinfo (Target Architecture Definition): Replace
	read_fp, TARGET_READ_FP and FP_REGNUM, with deprecated_read_fp,
	DEPRECATED_TARGET_READ_FP and DEPRECATED_REGNUM.
@
text
@d1794 1
a1794 1
      char *buf = alloca (max_register_size (current_gdbarch));
d1975 1
a1975 1
    char *buf = alloca (max_register_size (current_gdbarch));
@


1.32
log
@2003-02-02  Andrew Cagney  <ac131313@@redhat.com>

	* mips-nat.c (zerobuf): Delete.
	(fetch_inferior_registers): Alloc local zerobuf.
	(fetch_core_registers): Alloc local zerobuf.
	* d10v-tdep.c (show_regs): Don't allocate a dynamic array using
	MAX_REGISTER_RAW_SIZE or MAX_REGISTER_VIRTUAL_SIZE.
	* thread-db.c (thread_db_store_registers): Ditto.
	* sh-tdep.c (sh_do_register): Ditto.
	* rom68k-rom.c (rom68k_supply_one_register): Ditto.
	* remote-sim.c (gdbsim_store_register): Ditto.
	* remote-mips.c (mips_wait, mips_fetch_registers): Ditto.
	* remote-e7000.c (fetch_regs_from_dump): Ditto.
	* monitor.c (monitor_supply_register): Ditto.
	* mipsv4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* mips-nat.c (fetch_inferior_registers): Ditto.
	* m68klinux-nat.c (fetch_register): Ditto.
	* lynx-nat.c (fetch_inferior_registers): Ditto.
	(fetch_inferior_registers): Ditto.
	* irix4-nat.c (supply_gregset, supply_fpregset): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	(hpux_thread_store_registers): Ditto.
	* hppah-nat.c (fetch_register): Ditto.
	* hppab-nat.c (fetch_register): Ditto.
	* hppa-tdep.c (pa_register_look_aside): Ditto.
	(pa_print_fp_reg, pa_strcat_fp_reg): Ditto.
	* dve3900-rom.c (fetch_bitmapped_register): Ditto.
@
text
@d1805 2
a1806 2
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (FP_REGNUM), 0);
      supply_register (FP_REGNUM, buf);
d1946 3
a1948 3
  if (regno == FP_REGNUM || regno == ZERO_REGNUM)
    /* FP_REGNUM on the mips is a hack which is just supposed to read
       zero (see also mips-nat.c).  */
@


1.32.18.1
log
@Merge from mainline.
@
text
@d1805 2
a1806 2
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (DEPRECATED_FP_REGNUM), 0);
      supply_register (DEPRECATED_FP_REGNUM, buf);
d1946 3
a1948 3
  if (regno == DEPRECATED_FP_REGNUM || regno == ZERO_REGNUM)
    /* DEPRECATED_FP_REGNUM on the mips is a hack which is just
       supposed to read zero (see also mips-nat.c).  */
@


1.32.18.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1794 1
a1794 1
      char buf[MAX_REGISTER_SIZE];
d1975 1
a1975 1
    char buf[MAX_REGISTER_SIZE];
d2254 7
a2260 7
/* Insert a breakpoint.  On targets that don't have built-in
   breakpoint support, we read the contents of the target location and
   stash it, then overwrite it with a breakpoint instruction.  ADDR is
   the target location in the target machine.  CONTENTS_CACHE is a
   pointer to memory allocated for saving the target contents.  It is
   guaranteed by the caller to be long enough to save the breakpoint
   length returned by BREAKPOINT_FROM_PC.  */
@


1.31
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d1794 1
a1794 1
      char buf[MAX_REGISTER_RAW_SIZE];
d1975 1
a1975 1
    char buf[MAX_REGISTER_RAW_SIZE];
@


1.30
log
@2002-11-29  Andrew Cagney  <cagney@@redhat.com>

	* remote-mips.c (mips_initialize): Force a selected frame rebuild
	by calling get_selected_frame.
	* ocd.c (ocd_start_remote): Use get_selected frame instead of
	set_current_frame, create_new_frame, select_frame and
	get_current_frame.
	* remote-e7000.c (e7000_start_remote): Ditto.
	* remote-mips.c (common_open): Ditto
	* remote-rdp.c (remote_rdp_open): Ditto.
@
text
@d1286 1
a1286 1
mips_initialize_cleanups (PTR arg)
d1292 1
a1292 1
mips_exit_cleanups (PTR arg)
@


1.29
log
@2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* stack.c (selected_frame, select_frame): Move from here ...
	* frame.c (selected_frame, select_frame): ... to here.  Include
	"language.h".
	* Makefile.in (frame.o): Update dependencies.
	* frame.c (get_selected_frame): New function.
	* frame.h (get_selected_frame): Declare.
	(deprecated_selected_frame): Rename selected_frame.
	* ada-lang.c, ada-tasks.c, breakpoint.c, corelow.c: Update.
	* eval.c, f-valprint.c, findvar.c, frame.c, frame.h: Update.
	* h8300-tdep.c, h8500-tdep.c, hppa-tdep.c, infcmd.c: Update.
	* inflow.c, infrun.c, macroscope.c, mips-tdep.c: Update.
	* mn10300-tdep.c, ocd.c, regcache.h, remote-e7000.c: Update.
	* remote-mips.c, remote-rdp.c, sh-tdep.c, sparc-tdep.c: Update.
	* stack.c, thread.c, tracepoint.c, valops.c, varobj.c: Update.
	* z8k-tdep.c, cli/cli-cmds.c: Update.

Index: mi/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* mi/mi-cmd-stack.c, mi/mi-main.c: Update to use
	deprecated_selected_frame.

Index: tui/ChangeLog
2002-11-29  Andrew Cagney  <ac131313@@redhat.com>

	* tui/tui-hooks.c: Update to use deprecated_selected_frame.
	* tui/tui.c, tui/tuiDisassem.c, tui/tuiRegs.c: Ditto.
	* tui/tuiSource.c, tui/tuiSourceWin.c, tui/tuiWin.c: Ditto.
@
text
@d1497 4
a1500 2
  set_current_frame (create_new_frame (read_fp (), read_pc ()));
  select_frame (get_current_frame ());
d1617 4
a1620 4
/* This is really the job of start_remote however, that makes an assumption
   that the target is about to print out a status message of some sort.  That
   doesn't happen here (in fact, it may not be possible to get the monitor to
   send the appropriate packet).  */
d1625 1
a1625 3
  set_current_frame (create_new_frame (read_fp (), stop_pc));
  select_frame (get_current_frame ());
  print_stack_frame (deprecated_selected_frame, -1, 1);
@


1.28
log
@2002-11-06  Andrew Cagney  <ac131313@@redhat.com>

	* regcache.h (deprecated_register_valid): Rename register_valid.
	* regcache.c: Update.
	* ia64-aix-nat.c: Update.
	* i386gnu-nat.c: Update.
	* alpha-nat.c: Update.
	* sparc-nat.c: Update.
	* lynx-nat.c: Update.
	* remote-mips.c: Update.
@
text
@d1625 1
a1625 1
  print_stack_frame (selected_frame, -1, 1);
@


1.27
log
@* frame.h (select_frame): Delete level parameter.
* stack.c (select_frame): Update.  Use frame_relative_level to
obtain the frame's level.
(select_and_print_frame): Update call.
(select_frame_command): Ditto.
(up_silently_base): Ditto.
(down_silently_base): Ditto.
* ocd.c (ocd_start_remote): Ditto.
* remote-rdp.c (remote_rdp_open): Ditto.
* remote-mips.c (mips_initialize): Ditto.
(common_open): Ditto.
* remote-e7000.c (e7000_start_remote): Ditto.
* m3-nat.c (select_thread): Ditto.
* hppa-tdep.c (child_get_current_exception_event): Ditto.
(child_get_current_exception_event): Ditto.
* varobj.c (varobj_create): Ditto.
(varobj_update): Ditto.
(c_value_of_root): Ditto.
* tracepoint.c (finish_tfind_command): Ditto.
* corelow.c (core_open): Ditto.
* arch-utils.c (generic_prepare_to_proceed): Ditto.
* thread.c (info_threads_command): Ditto.
(switch_to_thread): Ditto.
* infrun.c (normal_stop): Ditto.
(restore_selected_frame): Ditto.
(restore_inferior_status): Ditto.
* breakpoint.c (insert_breakpoints): Ditto.
(watchpoint_check): Ditto.
(bpstat_stop_status): Ditto.
(do_enable_breakpoint): Ditto.
* blockframe.c (flush_cached_frames): Ditto.
(reinit_frame_cache): Ditto.
@
text
@d3446 1
a3446 1
      register_valid[PC_REGNUM] = 0;
@


1.27.16.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a38 1
#include "mips-tdep.h"
d486 1
a486 1
    fputs_filtered (error_pre_print, gdb_stderr);
d539 1
a539 1
static int
d595 1
a595 1
static int
d603 1
a603 1
static int
d819 3
a821 3
  const unsigned char *p;
  int c;
  int cksum;
d846 1
a846 1
  int cksum;
d1286 1
a1286 1
mips_initialize_cleanups (void *arg)
d1292 1
a1292 1
mips_exit_cleanups (void *arg)
d1497 2
d1611 8
a1618 6
  deprecated_mips_set_processor_regs_hack ();

  /* This is really the job of start_remote however, that makes an
     assumption that the target is about to print out a status message
     of some sort.  That doesn't happen here (in fact, it may not be
     possible to get the monitor to send the appropriate packet).  */
d1623 3
a1625 1
  print_stack_frame (get_selected_frame (), -1, 1);
d1724 1
a1724 1
static enum target_signal
d1794 1
a1794 1
      char buf[MAX_REGISTER_SIZE];
d1796 1
a1796 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM), rpc);
d1799 1
a1799 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM), rfp);
d1802 1
a1802 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (SP_REGNUM), rsp);
d1805 2
a1806 2
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (DEPRECATED_FP_REGNUM), 0);
      supply_register (DEPRECATED_FP_REGNUM, buf);
d1909 20
a1928 18
  if (regno >= mips_regnum (current_gdbarch)->fp0
      && regno < mips_regnum (current_gdbarch)->fp0 + 32)
    return regno - mips_regnum (current_gdbarch)->fp0 + 32;
  else if (regno == mips_regnum (current_gdbarch)->pc)
    return REGNO_OFFSET + 0;
  else if (regno == mips_regnum (current_gdbarch)->cause)
    return REGNO_OFFSET + 1;
  else if (regno == mips_regnum (current_gdbarch)->hi)
    return REGNO_OFFSET + 2;
  else if (regno == mips_regnum (current_gdbarch)->lo)
    return REGNO_OFFSET + 3;
  else if (regno == mips_regnum (current_gdbarch)->fp_control_status)
    return REGNO_OFFSET + 4;
  else if (regno == mips_regnum (current_gdbarch)->fp_implementation_revision)
    return REGNO_OFFSET + 5;
  else
    /* FIXME: Is there a way to get the status register?  */
    return 0;
d1946 3
a1948 3
  if (regno == DEPRECATED_FP_REGNUM || regno == ZERO_REGNUM)
    /* DEPRECATED_FP_REGNUM on the mips is a hack which is just
       supposed to read zero (see also mips-nat.c).  */
d1975 1
a1975 1
    char buf[MAX_REGISTER_SIZE];
d1979 1
a1979 1
    store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regno), val);
d2254 7
a2260 7
/* Insert a breakpoint.  On targets that don't have built-in
   breakpoint support, we read the contents of the target location and
   stash it, then overwrite it with a breakpoint instruction.  ADDR is
   the target location in the target machine.  CONTENTS_CACHE is a
   pointer to memory allocated for saving the target contents.  It is
   guaranteed by the caller to be long enough to save the breakpoint
   length returned by BREAKPOINT_FROM_PC.  */
d2408 1
a2408 1
mips_can_use_watchpoint (int type, int cnt, int othertype)
d2440 1
a2440 1
static int
d2453 1
a2453 1
static int
d2467 1
a2467 1
mips_insert_watchpoint (CORE_ADDR addr, int len, int type)
d2476 1
a2476 1
mips_remove_watchpoint (CORE_ADDR addr, int len, int type)
d2485 1
a2485 1
mips_stopped_by_watchpoint (void)
d3446 1
a3446 1
      deprecated_register_valid[PC_REGNUM] = 0;
a3479 2
extern initialize_file_ftype _initialize_remote_mips; /* -Wmissing-prototypes */

a3494 4
  mips_ops.to_insert_watchpoint = mips_insert_watchpoint;
  mips_ops.to_remove_watchpoint = mips_remove_watchpoint;
  mips_ops.to_stopped_by_watchpoint = mips_stopped_by_watchpoint;
  mips_ops.to_can_use_hw_breakpoint = mips_can_use_watchpoint;
@


1.27.16.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d602 29
d2273 123
d2429 25
@


1.27.14.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d3446 1
a3446 1
      deprecated_register_valid[PC_REGNUM] = 0;
@


1.27.14.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d1497 2
a1498 4
  /* FIXME: cagney/2002-11-29: Force the update of selected frame.
     This shouldn't be necessary, only many many places still refer to
     selected_frame directly (instead of using get_selected_frame().  */
  get_selected_frame (); /* Hack!!!  */
d1615 4
a1618 4
  /* This is really the job of start_remote however, that makes an
     assumption that the target is about to print out a status message
     of some sort.  That doesn't happen here (in fact, it may not be
     possible to get the monitor to send the appropriate packet).  */
d1623 3
a1625 1
  print_stack_frame (get_selected_frame (), -1, 1);
@


1.27.14.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1286 1
a1286 1
mips_initialize_cleanups (void *arg)
d1292 1
a1292 1
mips_exit_cleanups (void *arg)
d1794 1
a1794 1
      char *buf = alloca (max_register_size (current_gdbarch));
d1975 1
a1975 1
    char *buf = alloca (max_register_size (current_gdbarch));
@


1.27.14.4
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d1805 2
a1806 2
      store_unsigned_integer (buf, REGISTER_RAW_SIZE (DEPRECATED_FP_REGNUM), 0);
      supply_register (DEPRECATED_FP_REGNUM, buf);
d1946 3
a1948 3
  if (regno == DEPRECATED_FP_REGNUM || regno == ZERO_REGNUM)
    /* DEPRECATED_FP_REGNUM on the mips is a hack which is just
       supposed to read zero (see also mips-nat.c).  */
@


1.27.14.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1794 1
a1794 1
      char buf[MAX_REGISTER_SIZE];
d1975 1
a1975 1
    char buf[MAX_REGISTER_SIZE];
d2254 7
a2260 7
/* Insert a breakpoint.  On targets that don't have built-in
   breakpoint support, we read the contents of the target location and
   stash it, then overwrite it with a breakpoint instruction.  ADDR is
   the target location in the target machine.  CONTENTS_CACHE is a
   pointer to memory allocated for saving the target contents.  It is
   guaranteed by the caller to be long enough to save the breakpoint
   length returned by BREAKPOINT_FROM_PC.  */
@


1.27.14.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d539 1
a539 1
static int
d595 1
a595 1
static int
d603 1
a603 1
static int
d1724 1
a1724 1
static enum target_signal
d2440 1
a2440 1
static int
d2453 1
a2453 1
static int
a3479 2
extern initialize_file_ftype _initialize_remote_mips; /* -Wmissing-prototypes */

@


1.27.14.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d486 1
a486 1
    fputs_filtered (error_pre_print, gdb_stderr);
@


1.27.14.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d819 3
a821 3
  const unsigned char *p;
  int c;
  int cksum;
d846 1
a846 1
  int cksum;
d2408 1
a2408 1
mips_can_use_watchpoint (int type, int cnt, int othertype)
d2467 1
a2467 1
mips_insert_watchpoint (CORE_ADDR addr, int len, int type)
d2476 1
a2476 1
mips_remove_watchpoint (CORE_ADDR addr, int len, int type)
d2485 1
a2485 1
mips_stopped_by_watchpoint (void)
a3496 4
  mips_ops.to_insert_watchpoint = mips_insert_watchpoint;
  mips_ops.to_remove_watchpoint = mips_remove_watchpoint;
  mips_ops.to_stopped_by_watchpoint = mips_stopped_by_watchpoint;
  mips_ops.to_can_use_hw_breakpoint = mips_can_use_watchpoint;
@


1.27.14.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1497 4
d1796 1
a1796 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM), rpc);
d1799 1
a1799 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (PC_REGNUM), rfp);
d1802 1
a1802 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (SP_REGNUM), rsp);
d1805 1
a1805 1
      store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (DEPRECATED_FP_REGNUM), 0);
d1979 1
a1979 1
    store_unsigned_integer (buf, DEPRECATED_REGISTER_RAW_SIZE (regno), val);
@


1.27.14.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a38 1
#include "mips-tdep.h"
d1609 3
a1611 1
  deprecated_mips_set_processor_regs_hack ();
d1905 20
a1924 18
  if (regno >= mips_regnum (current_gdbarch)->fp0
      && regno < mips_regnum (current_gdbarch)->fp0 + 32)
    return regno - mips_regnum (current_gdbarch)->fp0 + 32;
  else if (regno == mips_regnum (current_gdbarch)->pc)
    return REGNO_OFFSET + 0;
  else if (regno == mips_regnum (current_gdbarch)->cause)
    return REGNO_OFFSET + 1;
  else if (regno == mips_regnum (current_gdbarch)->hi)
    return REGNO_OFFSET + 2;
  else if (regno == mips_regnum (current_gdbarch)->lo)
    return REGNO_OFFSET + 3;
  else if (regno == mips_regnum (current_gdbarch)->fp_control_status)
    return REGNO_OFFSET + 4;
  else if (regno == mips_regnum (current_gdbarch)->fp_implementation_revision)
    return REGNO_OFFSET + 5;
  else
    /* FIXME: Is there a way to get the status register?  */
    return 0;
@


1.27.14.11
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d602 29
d2273 123
d2429 25
@


1.26
log
@* defs.h (throw_exception): Rename return_to_top_level.  Update
comments.
* utils.c (error_stream, internal_verror, quit): Ditto.
* top.c (throw_exception, catcher): Ditto.
* sparclet-rom.c (sparclet_load): Ditto.
* remote.c (interrupt_query, minitelnet): Ditto.
* remote-sds.c (interrupt_query): Ditto.
* remote-mips.c (mips_error, mips_kill): Ditto.
* ocd.c (interrupt_query): Ditto.
* monitor.c (monitor_interrupt_query): Ditto.
* m3-nat.c (suspend_all_threads, thread_resume_command): Ditto.
* target.h: Update comment.

* m3-nat.c, ocd.c, sparclet-rom.c: Update copyright.
@
text
@d1498 1
a1498 1
  select_frame (get_current_frame (), 0);
d1624 1
a1624 1
  select_frame (get_current_frame (), 0);
@


1.25
log
@Remove ATTRIBUTE_UNUSED.  Update (C).
@
text
@d500 1
a500 1
  return_to_top_level (RETURN_ERROR);
d2189 1
a2189 1
	  return_to_top_level (RETURN_QUIT);
@


1.24
log
@2001-08-23  Martin M. Hunt  <hunt@@redhat.com>

	* remote-mips.c (pmon_load_fast): Add ui_load_progress_hook
	to download loop.
	(mips_load_srec): Ditto.
@
text
@d2 4
a5 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d2071 1
a2071 2
		  struct mem_attrib *attrib ATTRIBUTE_UNUSED,
		  struct target_ops *target ATTRIBUTE_UNUSED)
@


1.23
log
@* serial.h (SERIAL_ASYNC): Delete.
(DEPRECATED_SERIAL_FD): Delete.
(SERIAL_DEBUG): Delete.
(SERIAL_DEBUG_P): Delete.
(SERIAL_DRAIN_OUTPUT): Delete.
(SERIAL_FLUSH_OUTPUT): Delete.
(SERIAL_FLUSH_INPUT): Delete.
(SERIAL_SEND_BREAK): Delete.
(SERIAL_RAW): Delete.
(SERIAL_GET_TTY_STATE): Delete.
(SERIAL_SET_TTY_STATE): Delete.
(SERIAL_PRINT_TTY_STATE): Delete.
(SERIAL_NOFLUSH_SET_TTY_STATE): Delete.
(SERIAL_SETBAUDRATE): Delete.
(SERIAL_SETSTOPBITS): Delete.
(SERIAL_CAN_ASYNC_P): Delete.
(SERIAL_IS_ASYNC_P): Delete.
(SERIAL_UN_FDOPEN): Delete.
(SERIAL_READCHAR): Delete.
(SERIAL_CLOSE): Delete.
(SERIAL_FDOPEN): Delete.
(SERIAL_OPEN): Delete.
@
text
@d2848 3
d3371 3
@


1.22
log
@s/typedef serial_t/struct serial */
@
text
@d458 1
a458 1
  SERIAL_CLOSE (mips_desc);
d462 1
a462 1
      SERIAL_CLOSE (udp_desc);
d554 2
a555 2
/* Must use SERIAL_READCHAR here cuz mips_readchar would get confused if we
   were waiting for the mips_monitor_prompt... */
d557 1
a557 1
      c = SERIAL_READCHAR (mips_desc, timeout);
d610 1
a610 1
      c = SERIAL_READCHAR (mips_desc, remote_timeout);
d629 7
a635 7
   SERIAL_TIMEOUT on timeout (since that's what SERIAL_READCHAR
   returns).  FIXME: If we see the string mips_monitor_prompt from
   the board, then we are debugging on the main console port, and we
   have somehow dropped out of remote debugging mode.  In this case,
   we automatically go back in to remote debugging mode.  This is a
   hack, put in because I can't find any way for a program running on
   the remote board to terminate without also ending remote debugging
d659 1
a659 1
  ch = SERIAL_READCHAR (mips_desc, timeout);
d885 1
a885 1
      if (SERIAL_WRITE (mips_desc, packet,
d1145 1
a1145 1
      if (SERIAL_WRITE (mips_desc, ack, HDR_LENGTH + TRLR_LENGTH) != 0)
d1185 1
a1185 1
  if (SERIAL_WRITE (mips_desc, ack, HDR_LENGTH + TRLR_LENGTH) != 0)
d1298 1
a1298 1
  SERIAL_WRITE (mips_desc, cmd, strlen (cmd));
d1319 1
a1319 1
  SERIAL_WRITE (mips_desc, "\r", sizeof "\r" - 1);
d1401 2
a1402 2
	  SERIAL_FLUSH_INPUT (mips_desc);
	  SERIAL_WRITE (mips_desc, "\r", 1);
d1405 1
a1405 1
	  SERIAL_SEND_BREAK (mips_desc);
d1408 1
a1408 1
	  SERIAL_WRITE (mips_desc, "\003", 1);
d1422 1
a1422 1
		SERIAL_FLUSH_OUTPUT (mips_desc);
d1424 1
a1424 1
		SERIAL_WRITE (mips_desc, tbuff, 6);
d1444 1
a1444 1
		    SERIAL_WRITE (mips_desc, srec, 8);
d1446 1
a1446 1
		    if (SERIAL_READCHAR (mips_desc, 0) >= 0)
d1542 1
a1542 1
  mips_desc = SERIAL_OPEN (serial_port_name);
d1548 1
a1548 1
      if (SERIAL_SETBAUDRATE (mips_desc, baud_rate))
d1550 1
a1550 1
	  SERIAL_CLOSE (mips_desc);
d1555 1
a1555 1
  SERIAL_RAW (mips_desc);
d1565 1
a1565 1
	  udp_desc = SERIAL_OPEN (remote_name);
d2197 1
a2197 1
  SERIAL_SEND_BREAK (mips_desc);
d2206 1
a2206 1
      SERIAL_WRITE (mips_desc, &cc, 1);
d2776 1
a2776 1
      SERIAL_WRITE (mips_desc, srec, len);
d2869 1
a2869 1
  SERIAL_FLUSH_INPUT (mips_desc);
d3135 1
a3135 1
      c = SERIAL_READCHAR (udp_in_use ? udp_desc : mips_desc,
d3269 1
a3269 1
    SERIAL_WRITE (udp_in_use ? udp_desc : mips_desc, buffer, length);
d3407 1
a3407 1
      SERIAL_FLUSH_INPUT (udp_in_use ? udp_desc : mips_desc);
@


1.21
log
@Phase 1 of the ptid_t changes.
@
text
@d365 1
a365 1
static serial_t mips_desc;
d368 1
a368 1
static serial_t udp_desc;
d1543 1
a1543 1
  if (mips_desc == (serial_t) NULL)
@


1.20
log
@* remote-mips.c (S_IROTH): Moved definition from here.
* gdb_stat.h (S_IROTH): to here.
@
text
@d88 2
a89 1
static void mips_resume (int pid, int step, enum target_signal siggnal);
d91 2
a92 1
static int mips_wait (int pid, struct target_waitstatus *status);
d1709 1
a1709 1
mips_resume (int pid, int step, enum target_signal siggnal)
d1741 2
a1742 2
static int
mips_wait (int pid, struct target_waitstatus *status)
d1762 1
a1762 1
      return 0;
d1893 1
a1893 1
  return 0;
d2235 1
a2235 1
  /* FIXME: Should we set inferior_pid here?  */
d3444 1
a3444 1
  inferior_pid = 0;		/* No process now */
@


1.19
log
@Update/correct copyright notices.
@
text
@d34 1
a35 3

#include <sys/types.h>
#include <sys/stat.h>
a36 6

/* Microsoft C's stat.h doesn't define all the POSIX file modes.  */
#ifndef S_IROTH
#define S_IROTH S_IREAD
#endif

@


1.18
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1995, 2000, 2001 Free Software Foundation, Inc.
@


1.17
log
@Replace calls to abort() with calls to internal_error().
@
text
@d33 1
@


1.16
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d2732 1
a2732 1
	      abort ();
@


1.15
log
@* ppc-bdm.c (#include <signal.h>): Removed.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-mips.c: Likewise.
* remote-os9k.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
@
text
@d1246 2
a1247 1
	internal_error ("mips_request: Trying to send command before reply");
d1257 2
a1258 1
    internal_error ("mips_request: Trying to get reply before command");
@


1.14
log
@* monitor.c (#include "gdb_wait.h"): Removed.
* ocd.c: Likewise.
* ppc-bdm.c: Likewise.
* remote-adapt.c: Likewise.
* remote-array.c: Likewise.
* remote-bug.c: Likewise.
* remote-e7000.c: Likewise.
* remote-eb.c: Likewise.
* remote-es.c: Likewise.
* remote-mips.c: Likewise.
* remote-mm.c: Likewise.
* remote-nindy.c: Likewise.
* remote-os9k.c: Likewise.
* remote-rdi.c: Likewise.
* remote-rdp.c: Likewise.
* remote-sds.c: Likewise.
* remote-sim.c: Likewise.
* remote-st.c: Likewise.
* remote-udi.c: Likewise.
* remote-vx.c: Likewise.
* remote-vx29k.c: Likewise.
* remote-vx68.c: Likewise.
* remote-vx960.c: Likewise.
* remote-vxmips.c: Likewise.
* remote-vxsparc.c: Likewise.
* remote.c: Likewise.
* ser-pipe.c: Likewise.
* ser-unix.c: Likewise.
* Makefile.in: Updated dependencies.
-------------------------------------------------------------------
@
text
@a33 1
#include <signal.h>
a35 1

@


1.13
log
@Replace strsave() with xstrdup().
@
text
@a26 1
#include "gdb_wait.h"
@


1.12
log
@* exec.c (xfer_memory): Add attrib argument.
* infptrace.c (child_xfer_memory): Likewise.
* monitor.c (monitor_xfer_memory): Likewise.
* remote-adapt.c (adapt_xfer_inferior_memory): Likewise.
* remote-array.c (array_xfer_memory): Likewise.
* remote-bug.c (bug_xfer_memory): Likewise.
* remote-e7000.c (e7000_xfer_inferior_memory): Likewise.
* remote-eb.c (eb_xfer_inferior_memory): Likewise.
* remote-es.c (es1800_xfer_inferior_memory): Likewise.
* remote-mips.c (mips_xfer_memory): Likewise.
* remote-mm.c (mm_xfer_inferior_memory): Likewise.
* remote-nindy.c (nindy_xfer_inferior_memory): Likewise.
* remote-os9k.c (rombug_xfer_inferior_memory): Likewise.
* remote-rdi.c (arm_rdi_xfer_memory): Likewise.
* remote-rdp.c (remote_rdp_xfer_inferior_memory): Likewise.
* remote-sds.c (sds_xfer_memory): Likewise.
* remote-sim.c (gdbsim_xfer_inferior_memory): Likewise.
* remote-st.c (st2000_xfer_inferior_memory): Likewise.
* remote-udi.c (udi_xfer_inferior_memory): Likewise.
* remote-vx.c (vx_xfer_memory): Likewise.
* remote.c (remote_xfer_memory): Likewise.
* target.c (debug_to_xfer_memory, do_xfer_memory): Likewise.
* target.h (child_xfer_memory, do_xfer_memory, xfer_memory): Likewise.

* target.h (#include "memattr.h"): Added.
(target_ops.to_xfer_memory): Add attrib argument.

* wince.c (_initialize_inftarg): Removed call to set_dcache_state.
* dcache.h (set_dcache_state): Removed declaration.
* dcache.c (set_dcache_state): Removed definition

* dcache.c: Update module comment, as dcache is now enabled and
disabled with memory region attributes instead of by the global
variable "remotecache".  Add comment describing the interaction
between dcache and memory region attributes.
(dcache_xfer_memory): Add comment describing benefits of moving
cache writeback to a higher level.
(dcache_struct): Removed cache_has_stuff field.  This was used to
record whether the cache had been accessed in order to invalidate
it when it was disabled.  However, this is not needed because the
cache is write through and the code that enables, disables, and
deletes memory regions invalidate the cache.  Add comment which
suggests that we could be more selective and only invalidate those
cache lines containing data from those memory regions.
(dcache_invalidate): Updated.
(dcache_xfer_memory): Updated.

(dcache_alloc): Don't abort() if dcache_enabled_p is clear.
(dcache_xfer_memory): Removed code that called do_xfer_memory() to
perform a uncached transfer if dcache_enabled_p was clear.  This
function is now only called if caching is enabled for the memory
region.
(dcache_info): Always print cache info.

* target.c (do_xfer_memory): Add attrib argument.
(target_xfer_memory, target_xfer_memory_partial): Break transfer
into chunks defined by memory regions, pass region attributes to
do_xfer_memory().
* dcache.c (dcache_read_line, dcache_write_line): Likewise.

* Makefile.in (SFILES): Add memattr.c.
(COMMON_OBS): Add memattr.o.
(dcache.o): Add target.h to dependencies.
* memattr.c: New file.
* memattr.h: Likewise.
@
text
@d1533 1
a1533 1
  serial_port_name = strsave (argv[0]);
d1589 2
a1590 2
	  tftp_name = strsave (remote_name);
	  tftp_localname = strsave (local_name);
d1600 1
a1600 1
    mips_monitor_prompt = strsave (new_monitor_prompt);
d1616 1
a1616 1
    mips_set_processor_type_command (strsave (ptype), 0);
@


1.11
log
@Replace free() with xfree().
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 2000 Free Software Foundation, Inc.
d115 3
a117 1
			     int write, struct target_ops *ignore);
d2074 2
a2075 1
		  struct target_ops *ignore)
@


1.10
log
@Replace hardwired timeouts in remote-mips.c with ``remote_timeout''
variable.
@
text
@d1579 1
a1579 1
	    free (tftp_name);
d1581 1
a1581 1
	    free (tftp_localname);
d1627 1
a1627 1
  free (serial_port_name);
d3233 1
a3233 1
      free (cmd);
@


1.9
log
@* dcache.c (dcache_info): Output a cache line's state vector so it
lines up under the data vector.

* dcache.c (dcache_read_line): New function.
(dcache_peek_byte): Use it.
(dcache_alloc): Return NULL if write of reclaimed cache line fails.
(dcache_peek_byte, dcache_poke_byte): Return failure if
dcache_alloc() returns a NULL data block pointer.
(dcache_xfer_memory): Don't force writeback unless we were writing.

* monitor.c (monitor_expect): Change places where immediate_quit
is set to 1 or 0 to increments and decrements respectively.  This
allows such changes to nest properly.
* ocd.c (ocd_start_remote): Likewise.
* remote-adapt.c (expect): Likewise.
* remote-array.c (expect): Likewise.
* remote-eb.c (expect): Likewise.
* remote-e7000.c (e7000_start_remote): Likewise.
* remote-mips.c (mips_expect_timeout, mips_getstring): Likewise.
* remote-nrom.c (expect): Likewise.
* remote-os9k.c (expect): Likewise.
* remote-sds.c (sds_start_remote): Likewise.
* remote-st.c (expect): Likewise.
* remote-utils.c (sr_expect): Likewise.
* remote.c (remote_start_remote): Likewise.
* tracepoint.c (read_actions): Likewise.

* remote-mips.c (mips_getstring): Balance changes to immediate_quit.
@
text
@d601 1
a601 1
  return mips_expect_timeout (string, 2);
d615 1
a615 1
      c = SERIAL_READCHAR (mips_desc, 2);
d931 1
a931 1
		  rch = mips_readchar (2);
d943 2
a944 1
		(void) mips_receive_trailer (trlr, &garbage, &ch, 2);
d2312 1
a2312 1
      if (!mips_getstring (tbuff, 2))
d2780 1
a2780 1
      ch = mips_readchar (2);
d3137 2
a3138 1
      c = SERIAL_READCHAR (udp_in_use ? udp_desc : mips_desc, 2);
d3186 20
d3245 1
a3245 1
  if (mips_monitor == MON_LSI)
d3247 8
d3256 3
a3258 1
      mips_expect_timeout ("Entry address is ", tftp_in_use ? 15 : 2);
a3259 13
  else
    mips_expect_timeout ("Entry Address  = ", tftp_in_use ? 15 : 2);

  sprintf (hexnumber, "%x", final);
  mips_expect (hexnumber);
  mips_expect ("\r\n");
  if (mips_monitor != MON_LSI)
    pmon_check_ack ("termination");
  mips_expect ("\r\ntotal = 0x");
  sprintf (hexnumber, "%x", bintotal);
  mips_expect (hexnumber);
  if (!mips_expect_download (" bytes\r\n"))
    return;
@


1.8
log
@Thu Aug  3 15:02:23 2000  Andrew Cagney  <cagney@@b1.cygnus.com>

	* remote-mips.c (mips_expect, mips_expect_timeout, common_open,
 	fputs_readable): Make string pointer arguments constant.
@
text
@d554 1
a554 1
  immediate_quit = 1;
d578 1
a578 1
	      immediate_quit = 0;
d612 1
a612 1
  immediate_quit = 1;
d621 1
d629 1
@


1.7
log
@Protoization.
@
text
@d529 1
a529 1
fputs_readable (char *string, struct ui_file *file)
d543 1
a543 1
mips_expect_timeout (char *string, int timeout)
d545 1
a545 1
  char *p = string;
d599 1
a599 1
mips_expect (char *string)
d1502 2
a1503 1
	     enum mips_monitor_type new_monitor, char *new_monitor_prompt)
@


1.6
log
@Move the ``set mask-address'' command to remote-mips.c.  Disable
address masking in mips-tdep.c.
@
text
@d460 1
a460 1
close_ports ()
d510 1
a510 3
fputc_readable (ch, file)
     int ch;
     struct ui_file *file;
d529 1
a529 3
fputs_readable (string, file)
     char *string;
     struct ui_file *file;
d543 1
a543 3
mips_expect_timeout (string, timeout)
     char *string;
     int timeout;
d599 1
a599 2
mips_expect (string)
     char *string;
d607 1
a607 3
mips_getstring (string, n)
     char *string;
     int n;
d646 1
a646 2
mips_readchar (timeout)
     int timeout;
d724 1
a724 5
mips_receive_header (hdr, pgarbage, ch, timeout)
     unsigned char *hdr;
     int *pgarbage;
     int ch;
     int timeout;
d796 1
a796 5
mips_receive_trailer (trlr, pgarbage, pch, timeout)
     unsigned char *trlr;
     int *pgarbage;
     int *pch;
     int timeout;
d818 1
a818 4
mips_cksum (hdr, data, len)
     const unsigned char *hdr;
     const unsigned char *data;
     int len;
d843 1
a843 3
mips_send_packet (s, get_ack)
     const char *s;
     int get_ack;
d1008 1
a1008 4
mips_receive_packet (buff, throw_error, timeout)
     char *buff;
     int throw_error;
     int timeout;
d1284 1
a1284 2
mips_initialize_cleanups (arg)
     PTR arg;
d1290 1
a1290 2
mips_exit_cleanups (arg)
     PTR arg;
d1296 1
a1296 3
mips_send_command (cmd, prompt)
     const char *cmd;
     int prompt;
d1307 1
a1307 1
mips_enter_debug ()
d1337 1
a1337 1
mips_exit_debug ()
d1368 1
a1368 1
mips_initialize ()
d1501 2
a1502 6
common_open (ops, name, from_tty, new_monitor, new_monitor_prompt)
     struct target_ops *ops;
     char *name;
     int from_tty;
     enum mips_monitor_type new_monitor;
     char *new_monitor_prompt;
d1627 1
a1627 3
mips_open (name, from_tty)
     char *name;
     int from_tty;
d1650 1
a1650 3
pmon_open (name, from_tty)
     char *name;
     int from_tty;
d1656 1
a1656 3
ddb_open (name, from_tty)
     char *name;
     int from_tty;
d1662 1
a1662 3
lsi_open (name, from_tty)
     char *name;
     int from_tty;
d1676 1
a1676 2
mips_close (quitting)
     int quitting;
d1690 1
a1690 3
mips_detach (args, from_tty)
     char *args;
     int from_tty;
d1708 1
a1708 3
mips_resume (pid, step, siggnal)
     int pid, step;
     enum target_signal siggnal;
d1722 1
a1722 2
mips_signal_from_protocol (sig)
     int sig;
d1741 1
a1741 3
mips_wait (pid, status)
     int pid;
     struct target_waitstatus *status;
d1902 1
a1902 2
mips_map_regno (regno)
     int regno;
d1931 1
a1931 2
mips_fetch_registers (regno)
     int regno;
d1985 1
a1985 1
mips_prepare_to_store ()
d1992 1
a1992 2
mips_store_registers (regno)
     int regno;
d2013 1
a2013 2
mips_fetch_word (addr)
     CORE_ADDR addr;
d2037 1
a2037 4
mips_store_word (addr, val, old_contents)
     CORE_ADDR addr;
     unsigned int val;
     char *old_contents;
d2067 2
a2068 6
mips_xfer_memory (memaddr, myaddr, len, write, ignore)
     CORE_ADDR memaddr;
     char *myaddr;
     int len;
     int write;
     struct target_ops *ignore;
d2150 1
a2150 2
mips_files_info (ignore)
     struct target_ops *ignore;
d2161 1
a2161 1
mips_kill ()
d2214 1
a2214 4
mips_create_inferior (execfile, args, env)
     char *execfile;
     char *args;
     char **env;
d2241 1
a2241 1
mips_mourn_inferior ()
d2260 1
a2260 3
mips_insert_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d2269 1
a2269 3
mips_remove_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d2289 1
a2289 3
pmon_insert_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d2362 1
a2362 3
pmon_remove_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d2405 1
a2405 2
remote_mips_can_use_hardware_watchpoint (cnt)
     int cnt;
d2415 1
a2415 3
calculate_mask (addr, len)
     CORE_ADDR addr;
     int len;
d2438 1
a2438 3
remote_mips_insert_hw_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d2451 1
a2451 3
remote_mips_remove_hw_breakpoint (addr, contents_cache)
     CORE_ADDR addr;
     char *contents_cache;
d2464 1
a2464 4
remote_mips_set_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
d2473 1
a2473 4
remote_mips_remove_watchpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     int type;
d2491 1
a2491 4
set_breakpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     enum break_type type;
d2500 1
a2500 4
clear_breakpoint (addr, len, type)
     CORE_ADDR addr;
     int len;
     enum break_type type;
d2514 1
a2514 3
check_lsi_error (addr, rerrflg)
     CORE_ADDR addr;
     int rerrflg;
d2582 1
a2582 5
common_breakpoint (set, addr, len, type)
     int set;
     CORE_ADDR addr;
     int len;
     enum break_type type;
d2768 1
a2768 4
send_srec (srec, len, addr)
     char *srec;
     int len;
     CORE_ADDR addr;
d2797 1
a2797 2
mips_load_srec (args)
     char *args;
d2915 2
a2916 6
mips_make_srec (buf, type, memaddr, myaddr, len)
     char *buf;
     int type;
     CORE_ADDR memaddr;
     unsigned char *myaddr;
     int len;
d2983 1
a2983 5
pmon_makeb64 (v, p, n, chksum)
     unsigned long v;
     char *p;
     int n;
     int *chksum;
d3027 1
a3027 5
pmon_zeroset (recsize, buff, amount, chksum)
     int recsize;
     char **buff;
     int *amount;
     unsigned int *chksum;
d3039 1
a3039 4
pmon_checkset (recsize, buff, value)
     int recsize;
     char **buff;
     int *value;
d3069 3
a3071 8
pmon_make_fastrec (outbuf, inbuf, inptr, inamount, recsize, csum, zerofill)
     char **outbuf;
     unsigned char *inbuf;
     int *inptr;
     int inamount;
     int *recsize;
     unsigned int *csum;
     unsigned int *zerofill;
d3126 1
a3126 2
pmon_check_ack (mesg)
     char *mesg;
d3149 1
a3149 1
pmon_start_download ()
d3181 1
a3181 3
pmon_end_download (final, bintotal)
     int final;
     int bintotal;
d3244 1
a3244 3
pmon_download (buffer, length)
     char *buffer;
     int length;
d3253 1
a3253 2
pmon_load_fast (file)
     char *file;
d3400 1
a3400 3
mips_load (file, from_tty)
     char *file;
     int from_tty;
d3439 1
a3439 3
pmon_command (args, from_tty)
     char *args;
     int from_tty;
d3454 1
a3454 1
_initialize_remote_mips ()
@


1.5
log
@Remove arbitrary printf output limit placed on pmon targets
@
text
@d80 2
a81 3
static CORE_ADDR mips_request (int cmd, CORE_ADDR addr,
			       CORE_ADDR data, int *perr, int timeout,
			       char *buff);
d1249 7
a1255 8
static CORE_ADDR
mips_request (cmd, addr, data, perr, timeout, buff)
     int cmd;
     CORE_ADDR addr;
     CORE_ADDR data;
     int *perr;
     int timeout;
     char *buff;
d1378 1
a1378 2
      mips_request ('x', (unsigned int) 0, (unsigned int) 0, NULL,
		    mips_receive_wait, NULL);
d1384 1
a1384 2
    mips_request ('x', (unsigned int) 0, (unsigned int) 0, &err,
		  mips_receive_wait, NULL);
d1524 1
a1524 2
  mips_request ('r', (unsigned int) 0, (unsigned int) 0, &err,
		mips_receive_wait, NULL);
d1761 1
a1761 3
  mips_request (step ? 's' : 'c',
		(unsigned int) 1,
		(unsigned int) siggnal,
d1816 1
a1816 2
  rstatus = mips_request ('\000', (unsigned int) 0, (unsigned int) 0, &err, -1,
			  buff);
d2012 2
a2013 2
	    val = (unsigned) mips_request ('t', (unsigned int) pmon_reg,
			   (unsigned int) 0, &err, mips_receive_wait, NULL);
d2015 2
a2016 2
	    val = mips_request ('r', (unsigned int) pmon_reg,
			   (unsigned int) 0, &err, mips_receive_wait, NULL);
d2056 1
a2056 1
  mips_request ('R', (unsigned int) mips_map_regno (regno),
d2072 1
a2072 3
  /* FIXME! addr was cast to uint! */
  val = mips_request ('d', addr, (unsigned int) 0, &err,
		      mips_receive_wait, NULL);
d2076 1
a2076 2
      /* FIXME! addr was cast to uint! */
      val = mips_request ('i', addr, (unsigned int) 0, &err,
d2099 1
a2099 2
  oldcontents = mips_request ('D', addr, (unsigned int) val,
			      &err,
d2104 1
a2104 2
      oldcontents = mips_request ('I', addr,
				  (unsigned int) val, &err,
d2121 2
d2131 11
a2141 1
  register int i;
d2143 1
a2143 1
  register CORE_ADDR addr = memaddr & ~3;
d2145 1
a2145 1
  register int count = (((memaddr + len) - addr) + 3) / 4;
d2147 1
a2147 3
  register char *buffer = alloca (count * 4);

  int status;
d3697 7
@


1.4
log
@Delete TARGET_MONITOR_PROMPT.
@
text
@d39 2
d361 1
a361 1
static int mips_syn_garbage = 1050;
d758 19
a776 7
	         being done on the console port.  Don't use _filtered;
	         we can't deal with a QUIT out of target_wait.  */
	      if (!mips_initializing || remote_debug > 0)
		{
		  fputc_readable (ch, gdb_stdlog);
		  gdb_flush (gdb_stdlog);
		}
a777 1
	      ++*pgarbage;
@


1.3
log
@PARAMS removal.
@
text
@d2 1
a2 1
   Copyright 1993-1995, 2000 Free Software Foundation, Inc.
d1657 18
a1674 1
  common_open (&mips_ops, name, from_tty, MON_IDT, TARGET_MONITOR_PROMPT);
@


1.2
log
@Replace ../include/wait.h with gdb_wait.h.
@
text
@d61 1
a61 1
static int mips_readchar PARAMS ((int timeout));
d63 2
a64 2
static int mips_receive_header PARAMS ((unsigned char *hdr, int *pgarbage,
					int ch, int timeout));
d66 2
a67 2
static int mips_receive_trailer PARAMS ((unsigned char *trlr, int *pgarbage,
					 int *pch, int timeout));
d69 2
a70 3
static int mips_cksum PARAMS ((const unsigned char *hdr,
			       const unsigned char *data,
			       int len));
d72 1
a72 1
static void mips_send_packet PARAMS ((const char *s, int get_ack));
d74 1
a74 1
static void mips_send_command PARAMS ((const char *cmd, int prompt));
d76 1
a76 2
static int mips_receive_packet PARAMS ((char *buff, int throw_error,
					int timeout));
d78 3
a80 3
static CORE_ADDR mips_request PARAMS ((int cmd, CORE_ADDR addr,
				     CORE_ADDR data, int *perr, int timeout,
				       char *buff));
d82 1
a82 1
static void mips_initialize PARAMS ((void));
d84 1
a84 1
static void mips_open PARAMS ((char *name, int from_tty));
d86 1
a86 1
static void pmon_open PARAMS ((char *name, int from_tty));
d88 1
a88 1
static void ddb_open PARAMS ((char *name, int from_tty));
d90 1
a90 1
static void lsi_open PARAMS ((char *name, int from_tty));
d92 1
a92 1
static void mips_close PARAMS ((int quitting));
d94 1
a94 1
static void mips_detach PARAMS ((char *args, int from_tty));
d96 1
a96 2
static void mips_resume PARAMS ((int pid, int step,
				 enum target_signal siggnal));
d98 1
a98 1
static int mips_wait PARAMS ((int pid, struct target_waitstatus * status));
d100 1
a100 1
static int mips_map_regno PARAMS ((int regno));
d102 1
a102 1
static void mips_fetch_registers PARAMS ((int regno));
d104 1
a104 1
static void mips_prepare_to_store PARAMS ((void));
d106 1
a106 1
static void mips_store_registers PARAMS ((int regno));
d108 1
a108 1
static unsigned int mips_fetch_word PARAMS ((CORE_ADDR addr));
d110 2
a111 2
static int mips_store_word PARAMS ((CORE_ADDR addr, unsigned int value,
				    char *old_contents));
d113 2
a114 2
static int mips_xfer_memory PARAMS ((CORE_ADDR memaddr, char *myaddr, int len,
				     int write, struct target_ops * ignore));
d116 1
a116 1
static void mips_files_info PARAMS ((struct target_ops * ignore));
d118 1
a118 2
static void mips_create_inferior PARAMS ((char *execfile, char *args,
					  char **env));
d120 1
a120 1
static void mips_mourn_inferior PARAMS ((void));
d122 1
a122 1
static int pmon_makeb64 PARAMS ((unsigned long v, char *p, int n, int *chksum));
d124 2
a125 2
static int pmon_zeroset PARAMS ((int recsize, char **buff, int *amount,
				 unsigned int *chksum));
d127 1
a127 1
static int pmon_checkset PARAMS ((int recsize, char **buff, int *value));
d129 3
a131 3
static void pmon_make_fastrec PARAMS ((char **outbuf, unsigned char *inbuf,
				     int *inptr, int inamount, int *recsize,
			       unsigned int *csum, unsigned int *zerofill));
d133 1
a133 1
static int pmon_check_ack PARAMS ((char *mesg));
d135 1
a135 1
static void pmon_start_download PARAMS ((void));
d137 1
a137 1
static void pmon_end_download PARAMS ((int final, int bintotal));
d139 1
a139 1
static void pmon_download PARAMS ((char *buffer, int length));
d141 1
a141 1
static void pmon_load_fast PARAMS ((char *file));
d143 1
a143 1
static void mips_load PARAMS ((char *file, int from_tty));
d145 2
a146 2
static int mips_make_srec PARAMS ((char *buffer, int type, CORE_ADDR memaddr,
				   unsigned char *myaddr, int len));
d148 1
a148 2
static int set_breakpoint PARAMS ((CORE_ADDR addr, int len,
				   enum break_type type));
d150 1
a150 2
static int clear_breakpoint PARAMS ((CORE_ADDR addr, int len,
				     enum break_type type));
d152 2
a153 2
static int common_breakpoint PARAMS ((int set, CORE_ADDR addr, int len,
				      enum break_type type));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995 Free Software Foundation, Inc.
d6 1
a6 1
This file is part of GDB.
d8 14
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 1
a27 1
#include "wait.h"
a37 5
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d44 1
a44 1
extern void mips_set_processor_type_command PARAMS ((char *, int));
a45 1

d50 8
a57 7
enum break_type {
  BREAK_WRITE,	/* 0 */
  BREAK_READ,	/* 1 */
  BREAK_ACCESS,	/* 2 */
  BREAK_FETCH,	/* 3 */
  BREAK_UNUSED	/* 4 */
};
d81 2
a82 2
				 CORE_ADDR data, int *perr, int timeout,
				 char *buff));
d101 1
a101 1
static int mips_wait PARAMS ((int pid, struct target_waitstatus *status));
d117 1
a117 1
				     int write, struct target_ops *ignore));
d119 1
a119 1
static void mips_files_info PARAMS ((struct target_ops *ignore));
d129 1
a129 1
                                 unsigned int *chksum));
d134 2
a135 2
                                       int *inptr, int inamount, int *recsize,
                                       unsigned int *csum, unsigned int *zerofill));
d165 1
a165 1

d169 3
a171 3
   SYN	The first character is always a SYN (ASCII 026, or ^V).  SYN
	may not appear anywhere else in the packet.  Any time a SYN is
	seen, a new packet should be assumed to have begun.
d174 8
a181 8
	This byte contains the upper five bits of the logical length
	of the data section, plus a single bit indicating whether this
	is a data packet or an acknowledgement.  The documentation
	indicates that this bit is 1 for a data packet, but the actual
	board uses 1 for an acknowledgement.  The value of the byte is
		0x40 + (ack ? 0x20 : 0) + (len >> 6)
	(we always have 0 <= len < 1024).  Acknowledgement packets do
	not carry data, and must have a data length of 0.
d184 2
a185 2
	the data section.  The value is
	 	0x40 + (len & 0x3f)
d187 25
a211 25
   SEQ	This byte contains the six bit sequence number of the packet.
	The value is
		0x40 + seq
	An acknowlegment packet contains the sequence number of the
	packet being acknowledged plus 1 modulo 64.  Data packets are
	transmitted in sequence.  There may only be one outstanding
	unacknowledged data packet at a time.  The sequence numbers
	are independent in each direction.  If an acknowledgement for
	the previous packet is received (i.e., an acknowledgement with
	the sequence number of the packet just sent) the packet just
	sent should be retransmitted.  If no acknowledgement is
	received within a timeout period, the packet should be
	retransmitted.  This has an unfortunate failure condition on a
	high-latency line, as a delayed acknowledgement may lead to an
	endless series of duplicate packets.

   DATA	The actual data bytes follow.  The following characters are
	escaped inline with DLE (ASCII 020, or ^P):
		SYN (026)	DLE S
		DLE (020)	DLE D
		^C  (003)	DLE C
		^S  (023)	DLE s
		^Q  (021)	DLE q
	The additional DLE characters are not counted in the logical
	length stored in the TYPE_LEN and LEN1 bytes.
d216 8
a223 8
	These bytes contain an 18 bit checksum of the complete
	contents of the packet excluding the SEQ byte and the
	CSUM[123] bytes.  The checksum is simply the twos complement
	addition of all the bytes treated as unsigned characters.  The
	values of the checksum bytes are:
		CSUM1: 0x40 + ((cksum >> 12) & 0x3f)
		CSUM2: 0x40 + ((cksum >> 6) & 0x3f)
		CSUM3: 0x40 + (cksum & 0x3f)
d229 2
d312 11
a322 10
enum mips_monitor_type {
  /* IDT/SIM monitor being used: */
  MON_IDT,
  /* PMON monitor being used: */
  MON_PMON, /* 3.0.83 [COGENT,EB,FP,NET] Algorithmics Ltd. Nov  9 1995 17:19:50 */
  MON_DDB,  /* 2.7.473 [DDBVR4300,EL,FP,NET] Risq Modular Systems,  Thu Jun 6 09:28:40 PDT 1996 */
  MON_LSI,  /* 4.3.12 [EB,FP], LSI LOGIC Corp. Tue Feb 25 13:22:14 1997 */
  /* Last and unused value, for sizing vectors, etc. */
  MON_LAST
};
d331 6
a336 6
	target		prompt
	-----		-----
	pmon		PMON> 
	ddb		NEC010>
	lsi		PMON>
*/
d396 1
a396 1
static monitor_supports_breakpoints = 0;
d400 1
a400 1
#if 0	/* not used (yet?) */
d410 1
a410 1
*/
d413 7
a419 6
{
  enum break_type type;		/* type of breakpoint */
  CORE_ADDR addr;		/* address of breakpoint */
  int len;			/* length of region being watched */
  unsigned long value;		/* value to watch */
} lsi_breakpoints [MAX_LSI_BREAKPOINTS];
d423 11
a433 11
#define W_WARN	0x100	/* This bit is set if the error code is a warning */
#define W_MSK   0x101	/* warning: Range feature is supported via mask */
#define W_VAL   0x102	/* warning: Value check is not supported in hardware */
#define W_QAL   0x104	/* warning: Requested qualifiers are not supported in hardware */

#define E_ERR	0x200	/* This bit is set if the error code is an error */
#define E_BPT   0x200	/* error: No such breakpoint number */
#define E_RGE   0x201	/* error: Range is not supported */
#define E_QAL   0x202	/* error: The requested qualifiers can not be used */
#define E_OUT   0x203	/* error: Out of hardware resources */
#define E_NON   0x204	/* error: Hardware breakpoint not supported */
d436 4
a439 4
{
  int code;		/* error code */
  char *string;		/* string associated with this code */
};
d443 4
a446 4
  { W_MSK,	"Range feature is supported via mask" },
  { W_VAL,	"Value check is not supported in hardware" },
  { W_QAL,	"Requested qualifiers are not supported in hardware" },
  { 0,		NULL }
d450 7
a456 7
{  
  { E_BPT,	"No such breakpoint number" },
  { E_RGE,	"Range is not supported" },
  { E_QAL,	"The requested qualifiers can not be used" },
  { E_OUT,	"Out of hardware resources" },
  { E_NON,	"Hardware breakpoint not supported" },
  { 0,		NULL }
d465 1
a465 1
close_ports()
d477 1
a477 1
    
d484 1
a484 6
#ifdef ANSI_PROTOTYPES
mips_error (char *string, ...)
#else
mips_error (va_alist)
     va_dcl
#endif
a487 1
#ifdef ANSI_PROTOTYPES
d489 1
a489 6
#else
  char *string;
  va_start (args);
  string = va_arg (args, char *);
#endif
 
d491 1
a491 1
  wrap_here("");			/* Force out any buffered output */
d515 1
a515 1
putc_readable (ch)
d517 1
d520 1
a520 1
    putchar_unfiltered ('\n');
d522 5
a526 5
    printf_unfiltered ("\\r");
  else if (ch < 0x20)	/* ASCII control character */
    printf_unfiltered ("^%c", ch + '@@');
  else if (ch >= 0x7f)	/* non-ASCII characters (rubout or greater) */
    printf_unfiltered ("[%02x]", ch & 0xff);
d528 1
a528 1
    putchar_unfiltered (ch);
d536 1
a536 1
puts_readable (string)
d538 1
d543 1
a543 1
    putc_readable (c);
d549 1
a549 1
*/
d560 3
a562 3
      printf_unfiltered ("Expected \"");
      puts_readable (string);
      printf_unfiltered ("\", got \"");
d578 1
a578 1
	    printf_unfiltered ("\": FAIL\n");
d583 1
a583 1
	putc_readable (c);
d586 1
a586 1
	{	
d591 1
a591 1
	      printf_unfiltered ("\": OK\n");
d607 1
a607 1
*/
d613 1
a613 1
    return mips_expect_timeout (string, 2);
d631 6
a636 5
      if (c == SERIAL_TIMEOUT) {
        fprintf_unfiltered (gdb_stderr,
			    "Failed to read %d characters from target (TIMEOUT)\n", n);
	return 0;
      }
a666 1
#ifdef MAINTENANCE_CMDS
d672 1
a672 1
     i = watchdog;
a673 1
#endif
d678 2
a679 2
#ifdef MAINTENANCE_CMDS
  if (ch == SERIAL_TIMEOUT && timeout == -1) /* Watchdog went off */
d684 1
a684 1
#endif
d692 1
a692 1
	 target_wait, and I think this might be called from there.  */
d694 1
a694 1
	printf_unfiltered ("Read '%c' %d 0x%x\n", ch, ch, ch);
d696 1
a696 1
	printf_unfiltered ("Timed out in read\n");
d706 2
a707 2
      && ! mips_initializing
      && ! mips_exiting)
d712 1
a712 1
	printf_unfiltered ("Reinitializing MIPS debugging mode\n");
d720 1
a720 1
	 in progress and get back to command level as quickly as possible. */
d750 3
a752 3
	 sitting here indefinitely if the board sends us one garbage
	 character per second.  ch may already have a value from the
	 last time through the loop.  */
d757 1
a757 1
           return -1;
d761 4
a764 4
		 what the program is outputting, if the debugging is
		 being done on the console port.  Don't use _filtered;
		 we can't deal with a QUIT out of target_wait.  */
	      if (! mips_initializing || remote_debug > 0)
d766 2
a767 2
		  putc_readable (ch);
		  gdb_flush (gdb_stdout);
d773 1
a773 1
		mips_error ("Debug protocol failure:  more than %d characters before a sync.", 
d783 1
a783 1
            return -1;
d785 1
a785 1
	  if (ch == SYN || ! HDR_CHECK (ch))
d792 1
a792 1
	 loop around and keep looking for SYN.  */
d794 1
a794 1
        return 0;
d819 1
a819 1
      if (! TRLR_CHECK (ch))
d846 1
a846 1
  
d902 1
a902 1
	  printf_unfiltered ("Writing \"%s\"\n", packet + 1);
d909 1
a909 1
      if (! get_ack)
d933 6
a938 2
	  if (HDR_IS_DATA (hdr)) {
            int i;
d940 1
a940 2
            /* Ignore any errors raised whilst attempting to ignore
               packet. */
d942 3
a944 1
            len = HDR_GET_LEN (hdr);
d946 10
a955 14
            for (i = 0; i < len; i++)
              {
                int rch;

                rch = mips_readchar (2);
                if (rch == SYN)
                  {
                    ch = SYN;
                    break;
                  }
                if (rch == SERIAL_TIMEOUT)
                  break;
                /* ignore the character */
              }
d957 2
a958 2
            if (i == len)
              (void) mips_receive_trailer (trlr, &garbage, &ch, 2);
d960 4
a963 4
            /* We don't bother checking the checksum, or providing an
               ACK to the packet. */
	    continue;
          }
d992 3
a994 3
		 target_wait, and I think this might be called from there.  */
	      printf_unfiltered ("Got ack %d \"%s%s\"\n",
			       HDR_GET_SEQ (hdr), hdr + 1, trlr);
d1056 1
a1056 1
      if (! HDR_IS_DATA (hdr))
d1058 9
a1066 9
          len = HDR_GET_LEN (hdr);
          /* Check if the length is valid for an ACK, we may aswell
             try and read the remainder of the packet: */
          if (len == 0)
            {
              /* Ignore the error condition, since we are going to
                 ignore the packet anyway. */
              (void) mips_receive_trailer (trlr, &garbage, &ch, timeout);
            }
d1070 1
a1070 1
	    printf_unfiltered ("Ignoring unexpected ACK\n");
d1100 3
a1102 2
	    printf_unfiltered ("Got new SYN after %d chars (wanted %d)\n",
			     i, len);
d1119 1
a1119 1
	    printf_unfiltered ("Got SYN when wanted trailer\n");
d1129 3
a1131 2
	    printf_unfiltered ("Ignoring sequence number %d (want %d)\n",
			     HDR_GET_SEQ (hdr), mips_receive_seq);
d1136 1
a1136 1
        break;
d1142 2
a1143 2
			 mips_cksum (hdr, buff, len),
			 TRLR_GET_CKSUM (trlr));
d1146 1
a1146 1
	 previous packet to tell the remote to resend the packet.  */
d1164 1
a1164 1
			   ack + 1);
d1180 1
a1180 1
	 target_wait, and I think this might be called from there.  */
d1202 1
a1202 1
	 target_wait, and I think this might be called from there.  */
d1204 1
a1204 1
		       ack + 1);
d1224 9
a1232 9
   \0	don't send a request; just wait for a reply
   i	read word from instruction space at ADDR
   d	read word from data space at ADDR
   I	write DATA to instruction space at ADDR
   D	write DATA to data space at ADDR
   r	read register number ADDR
   R	set register number ADDR to value DATA
   c	continue execution (if ADDR != 1, set pc to ADDR)
   s	single step (if ADDR != 1, set pc to ADDR)
d1243 1
a1243 1
static CORE_ADDR 
d1265 1
a1265 1
	fatal ("mips_request: Trying to send command before reply");
d1274 2
a1275 2
  if (! mips_need_reply)
    fatal ("mips_request: Trying to get reply before command");
d1292 3
a1294 3
	 not be the same as errno values used on other systems.  If
	 they stick to common errno values, they will be the same, but
	 if they don't, they must be translated.  */
d1323 1
a1323 1
  SERIAL_WRITE (mips_desc, cmd, strlen(cmd));
d1340 1
a1340 1
  else /* assume IDT monitor by default */
d1343 1
a1343 1
  sleep(1);
d1352 1
a1352 1
  
d1374 1
a1374 1
		mips_receive_wait, NULL);
d1377 1
a1377 1
        return -1;
d1381 1
a1381 1
                  mips_receive_wait, NULL);
d1420 1
a1420 1
    j = 0; /* start by checking if we are already at the prompt */
d1422 1
a1422 1
    j = 1; /* start by sending a break */
d1427 2
a1428 2
        case 0:                 /* First, try sending a CR */
          SERIAL_FLUSH_INPUT (mips_desc);
d1430 2
a1431 2
          break;
	case 1:			/* First, try sending a break */
d1434 1
a1434 1
	case 2:			/* Then, try a ^C */
d1437 1
a1437 1
	case 3:			/* Then, try escaping from download */
d1439 33
a1471 33
            if (mips_monitor != MON_IDT)
              {
                char tbuff[7];

                /* We shouldn't need to send multiple termination
                   sequences, since the target performs line (or
                   block) reads, and then processes those
                   packets. In-case we were downloading a large packet
                   we flush the output buffer before inserting a
                   termination sequence. */
                SERIAL_FLUSH_OUTPUT (mips_desc);
                sprintf (tbuff, "\r/E/E\r");
                SERIAL_WRITE (mips_desc, tbuff, 6);
              }
            else
              {
                char srec[10];
                int i;

                /* We are possibly in binary download mode, having
                   aborted in the middle of an S-record.  ^C won't
                   work because of binary mode.  The only reliable way
                   out is to send enough termination packets (8 bytes)
                   to fill up and then overflow the largest size
                   S-record (255 bytes in this case).  This amounts to
                   256/8 + 1 packets.
                   */

                mips_make_srec (srec, '7', 0, NULL, 0);

                for (i = 1; i <= 33; i++)
                  {
                    SERIAL_WRITE (mips_desc, srec, 8);
d1473 2
a1474 2
                    if (SERIAL_READCHAR (mips_desc, 0) >= 0)
                      break;	/* Break immediatly if we get something from
d1476 3
a1478 3
                  }
              }
          }
d1492 1
a1492 1
	 around that.  */
d1544 1
a1544 1
"To open a MIPS remote debugging connection, you need to specify what serial\n\
d1546 6
a1551 6
"If you want to use TFTP to download to the board, specify the name of a\n"
"temporary file to be used by GDB for downloads as the second argument.\n"
"This filename must be in the form host:filename, where host is the name\n"
"of the host running the TFTP server, and the file must be readable by the\n"
"world.  If the local name of the temporary file differs from the name as\n"
"seen from the board via TFTP, specify that name as the third parameter.\n");
d1556 2
a1557 2
    nomem(0);
  make_cleanup ((make_cleanup_func) freeargv, argv);
d1560 1
a1560 1
  if (argv[1])				/* remote TFTP name specified? */
d1563 1
a1563 1
      if (argv[2])			/* local TFTP filename specified? */
d1580 4
a1583 4
        {
          SERIAL_CLOSE (mips_desc);
          perror_with_name (serial_port_name);
        }
d1611 2
a1612 2
	      if ((local_name = strchr (remote_name, ':')) != NULL)
		local_name++;		/* skip over the colon */
d1692 1
a1692 1
  
d1790 1
a1790 1
  if (! mips_need_reply)
d1831 1
a1831 1
      supply_register (30, buf); /* This register they are avoiding and so it is unnamed */
d1855 5
a1859 5
	 Right now, PMON doesn't give us enough information to determine which
	 breakpoint we hit.  So we have to look up the PC in our own table
	 of breakpoints, and if found, assume it's just a normal instruction
	 fetch breakpoint, not a data watchpoint.  FIXME when PMON
	 provides some way to tell us what type of breakpoint it is.  */
d1861 1
a1861 1
      CORE_ADDR pc = read_pc();
d1875 3
a1877 3
	     0x1 c 0x0 0x57f 0x1
	 The return packet from an ordinary breakpoint doesn't have the
	 extra 0x01 field tacked onto the end.  */
d1884 7
a1890 7
     	SPP_SIGTRAP     5       breakpoint
        SPP_SIGINT      2
        SPP_SIGSEGV     11
        SPP_SIGBUS      10
        SPP_SIGILL      4
        SPP_SIGFPE      8
        SPP_SIGTERM     15 */
d1907 1
a1907 1
	 is not a normal breakpoint.  */
d1912 1
a1912 1
	  CORE_ADDR pc = read_pc();
d1996 2
a1997 2
	    val = (unsigned)mips_request ('t', (unsigned int) pmon_reg,
				(unsigned int) 0, &err, mips_receive_wait, NULL);
d2000 1
a2000 1
				(unsigned int) 0, &err, mips_receive_wait, NULL);
d2049 1
a2049 1
static unsigned int 
d2066 2
a2067 2
        mips_error ("Can't read address 0x%s: %s",
	      paddr_nz (addr), safe_strerror (errno));
d2120 1
a2120 1
  register CORE_ADDR addr = memaddr &~ 3;
d2154 1
a2154 1
				    extract_unsigned_integer (&buffer[i*4], 4),
d2157 1
a2157 1
	  if (i % 256 == 255) 
d2177 1
a2177 1
	  store_unsigned_integer (&buffer[i*4], 4, mips_fetch_word (addr));
d2222 1
a2222 1
	  close_ports();
d2325 1
a2325 1
#if 0 /* currently not used */
d2332 1
a2332 1
#define PMON_MAX_BP (33) /* 32 SW, 1 HW */
d2345 1
a2345 1
      char tbuff[12]; /* space for breakpoint command */
d2351 1
a2351 1
        mips_error ("Failed to exit debug mode");
d2359 2
a2360 2
        return 1;
      tbuff[2] = '\0'; /* terminate the string */
d2362 5
a2366 5
        {
          fprintf_unfiltered (gdb_stderr,
			      "Invalid decimal breakpoint number from target: %s\n", tbuff);
          return 1;
        }
d2377 2
a2378 2
        return 1;
      tbuff[10] = '\0'; /* terminate the string */
d2381 5
a2385 5
        {
          fprintf_unfiltered (gdb_stderr,
			      "Invalid hex address from target: %s\n", tbuff);
          return 1;
        }
d2388 2
a2389 2
        {
          fprintf_unfiltered (gdb_stderr,
d2391 3
a2393 3
                              bpnum, PMON_MAX_BP - 1);
          return 1;
        }
d2396 1
a2396 1
        fprintf_unfiltered (gdb_stderr, "Warning: Breakpoint addresses do not match: 0x%x != 0x%x\n", addr, bpaddr);
d2419 1
a2419 1
      char tbuff[7]; /* enough for delete breakpoint command */
d2422 2
a2423 2
        if (mips_pmon_bp_info[bpnum] == addr)
          break;
d2426 6
a2431 6
        {
          fprintf_unfiltered (gdb_stderr,
	    "pmon_remove_breakpoint: Failed to find breakpoint at address 0x%s\n",
	    paddr_nz (addr));
          return 1;
        }
d2434 1
a2434 1
        mips_error ("Failed to exit debug mode");
d2460 1
a2460 1
    return cnt < MAX_LSI_BREAKPOINTS && strcmp (target_shortname, "lsi") == 0;
d2547 1
a2547 1
remote_mips_stopped_by_watchpoint ()
d2607 1
a2607 1
				      "common_breakpoint (0x%s): Warning: %s\n",
d2614 1
a2614 1
				"common_breakpoint (0x%s): Unknown warning: 0x%x\n",
d2647 4
a2650 4
     0 = write			(BREAK_WRITE)
     1 = read			(BREAK_READ)
     2 = read/write		(BREAK_ACCESS)
     3 = instruction fetch	(BREAK_FETCH)
d2670 1
a2670 1
      if (set == 0)	/* clear breakpoint */
d2673 3
a2675 3
	       <pid> 'b' <bptn> 0x0
	       reply:
	       <pid> 'b' 0x0 <code>
d2710 2
a2711 1
      else	/* set a breakpoint */
d2714 3
a2716 3
	       <pid> 'B' <addr> 0x0
	       reply:
	       <pid> 'B' <bptn> <code>
d2720 1
a2720 1
	        <pid> 'A' <addr1> <type> [<addr2>  [<value>]]
d2722 3
a2724 3
		where: type= "0x1" = read
	             "0x2" = write
	             "0x3" = access (read or write)
d2727 6
a2732 6
		     bptn - a breakpoint number, which is a small integer with
			    possible values of zero through 255.
		     code - an error return code, a value of zero indicates a
			    succesful completion, other values indicate various
			    errors and warnings.
	      
d2735 1
a2735 1
	  */
d2742 2
a2743 1
	  else				/* watchpoint */
d2747 1
a2747 1
		       type == BREAK_READ ? 1 : (type == BREAK_WRITE ? 2 : 3),
d2768 1
a2768 1
	  lsi_breakpoints[rresponse].len =  len;
d2776 3
a2778 3
	   0x0 <CMD> <ADDR> <MASK> <FLAGS>
	 <MASK> is a don't care mask for addresses.
	 <FLAGS> is any combination of `r', `w', or `f' for read/write/fetch.
d2785 2
a2786 2
      if (set)		/* set a breakpoint */
        {
d2790 1
a2790 1
	    case BREAK_WRITE:		/* write */
d2793 1
a2793 1
	    case BREAK_READ:		/* read */
d2796 1
a2796 1
	    case BREAK_ACCESS:		/* read/write */
d2799 1
a2799 1
	    case BREAK_FETCH:		/* fetch */
d2834 1
a2834 1
	  if (rresponse != 22) /* invalid argument */
d2836 1
a2836 1
				"common_breakpoint (0x%s):  Got error: 0x%x\n",
d2866 1
a2866 1
	  fprintf_unfiltered (gdb_stderr, "Download got a NACK at byte %d!  Retrying.\n", addr);
d2912 4
a2915 3
	  /* FIXME!  vma too small?? */
	  printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, s->vma,
			   s->vma + s->_raw_size);
d2933 2
a2934 2
	    } /* Per-packet (or S-record) loop */
	  
d2936 1
a2936 1
	} /* Loadable sections */
d2938 1
a2938 1
  if (hashmark) 
d2940 1
a2940 1
  
d2953 2
a2954 2
 *	time, each with it's own header and trailer line.
 *	An srecord looks like this:
d2958 6
a2963 6
 *	    | |        |                   |
 *	  S01000006F6B692D746573742E73726563E4
 *	  S315000448600000000000000000FC00005900000000E9
 *	  S31A0004000023C1400037DE00F023604000377B009020825000348D
 *	  S30B0004485A0000000000004E
 *	  S70500040000F6
d2965 1
a2965 1
 *	S<type><length><address><data><checksum>
d2988 1
a2988 1
 *	  is the sum of all the raw byte data in the record, from the length
d3044 7
a3050 7
	'K'     clear checksum
	'C'     compare checksum (12bit value, not included in checksum calculation)
	'S'     define symbol name (for addr) terminated with "," and padded to 4char boundary
	'Z'     zero fill multiple of 3bytes
	'B'     byte (12bit encoded value, of 8bit data)
	'A'     address (36bit encoded value)
	'E'     define entry as original address, and exit load
d3076 12
a3087 10
  if ((n % 12) != 0) {
    fprintf_unfiltered(gdb_stderr,
		       "Fast encoding bitcount must be a multiple of 12bits: %dbit%s\n",n,(n == 1)?"":"s");
    return(0);
  }
  if (n > 36) {
    fprintf_unfiltered(gdb_stderr,
		       "Fast encoding cannot process more than 36bits at the moment: %dbits\n",n);
    return(0);
  }
d3090 11
a3100 5
  if (chksum != NULL) {
    switch (n) {
     case 36: *chksum += ((v >> 24) & 0xFFF);
     case 24: *chksum += ((v >> 12) & 0xFFF);
     case 12: *chksum += ((v >>  0) & 0xFFF);
a3101 1
  }
d3103 6
a3108 4
  do {
    n -= 6;
    *p++ = encoding[(v >> n) & 0x3F];
  } while (n > 0);
d3110 1
a3110 1
  return(count);
d3124 1
a3124 1
  sprintf(*buff,"/Z");
d3128 1
a3128 1
  return(recsize + count + 2);
d3144 1
a3144 1
  *buff += 2; /* include zero terminator */
d3147 1
a3147 1
  return(recsize + count + 3);
d3181 39
a3219 31
  while ((*recsize < (MAXRECSIZE - CHECKSIZE)) && ((inamount - *inptr) > 0)) {
    /* Process the binary data: */
    if ((inamount - *inptr) < 3) {
      if (*zerofill != 0)
       *recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
      sprintf (p, "/B");
      count = pmon_makeb64 (inbuf[*inptr], &p[2], 12, csum);
      p += (2 + count);
      *recsize += (2 + count);
      (*inptr)++;
    } else {
      unsigned int value = ((inbuf[*inptr + 0] << 16) | (inbuf[*inptr + 1] << 8) | inbuf[*inptr + 2]);
      /* Simple check for zero data. TODO: A better check would be
         to check the last, and then the middle byte for being zero
         (if the first byte is not). We could then check for
         following runs of zeros, and if above a certain size it is
         worth the 4 or 8 character hit of the byte insertions used
         to pad to the start of the zeroes. NOTE: This also depends
         on the alignment at the end of the zero run. */
      if (value == 0x00000000) {
        (*zerofill)++;
        if (*zerofill == 0xFFF) /* 12bit counter */
         *recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
      }else {
        if (*zerofill != 0)
         *recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
        count = pmon_makeb64 (value, p, 24, csum);
        p += count;
        *recsize += count;
      }
      *inptr += 3;
a3220 1
  }
d3227 1
a3227 1
pmon_check_ack(mesg)
d3240 1
a3240 1
	  return(-1); /* terminate the download */
d3244 1
a3244 1
  return(0);
d3287 1
a3287 1
  char hexnumber[9]; /* includes '\0' space */
d3332 1
a3332 1
  sprintf (hexnumber,"%x",final);
d3338 1
a3338 1
  sprintf (hexnumber,"%x",bintotal);
d3373 2
a3374 2
  buffer = (char *)xmalloc(MAXRECSIZE + 1);
  binbuf = (unsigned char *)xmalloc(BINCHUNK);
d3376 1
a3376 1
  abfd = bfd_openr(file,0);
d3378 10
a3387 10
   {
     printf_filtered ("Unable to open file %s\n",file);
     return;
   }

  if (bfd_check_format(abfd,bfd_object) == 0)
   {
     printf_filtered("File is not an object file\n");
     return;
   }
d3396 2
a3397 2
  pmon_start_download();
  
d3399 2
a3400 2
  sprintf(buffer,"/Kxx\n");
  reclen = strlen(buffer);
d3402 1
a3402 1
  finished = pmon_check_ack("/Kxx");
d3405 17
a3421 4
   if (s->flags & SEC_LOAD) /* only deal with loadable sections */
    {
      bintotal += s->_raw_size;
      final = (s->vma + s->_raw_size);
d3423 59
a3481 66
      printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, (unsigned int)s->vma,
                       (unsigned int)(s->vma + s->_raw_size));
      gdb_flush (gdb_stdout);

      /* Output the starting address */
      sprintf(buffer,"/A");
      reclen = pmon_makeb64(s->vma,&buffer[2],36,&csum);
      buffer[2 + reclen] = '\n';
      buffer[3 + reclen] = '\0';
      reclen += 3; /* for the initial escape code and carriage return */
      pmon_download (buffer, reclen);
      finished = pmon_check_ack("/A");

      if (!finished)
       {
         unsigned int binamount;
         unsigned int zerofill = 0;
         char *bp = buffer;
         unsigned int i;

         reclen = 0;

         for (i = 0; ((i < s->_raw_size) && !finished); i += binamount) {
           int binptr = 0;

           binamount = min (BINCHUNK, s->_raw_size - i);

           bfd_get_section_contents (abfd, s, binbuf, i, binamount);

           /* This keeps a rolling checksum, until we decide to output
              the line: */
           for (; ((binamount - binptr) > 0);) {
             pmon_make_fastrec (&bp, binbuf, &binptr, binamount, &reclen, &csum, &zerofill);
             if (reclen >= (MAXRECSIZE - CHECKSIZE)) {
               reclen = pmon_checkset (reclen, &bp, &csum);
               pmon_download (buffer, reclen);
               finished = pmon_check_ack("data record");
               if (finished) {
                 zerofill = 0; /* do not transmit pending zerofills */
                 break;
               }

               if (hashmark) {
                 putchar_unfiltered ('#');
                 gdb_flush (gdb_stdout);
               }

               bp = buffer;
               reclen = 0; /* buffer processed */
             }
           }
         }

         /* Ensure no out-standing zerofill requests: */
         if (zerofill != 0)
          reclen = pmon_zeroset (reclen, &bp, &zerofill, &csum);

         /* and then flush the line: */
         if (reclen > 0) {
           reclen = pmon_checkset (reclen, &bp, &csum);
           /* Currently pmon_checkset outputs the line terminator by
              default, so we write out the buffer so far: */
           pmon_download (buffer, reclen);
           finished = pmon_check_ack("record remnant");
         }
       }
d3483 2
a3484 2
      putchar_unfiltered ('\n');
    }
d3488 1
a3488 1
  sprintf (buffer, "/E/E\n"); /* include dummy padding characters */
d3492 8
a3499 5
  if (finished) { /* Ignore the termination message: */
    SERIAL_FLUSH_INPUT (udp_in_use ? udp_desc : mips_desc);
  } else { /* Deal with termination message: */
    pmon_end_download (final, bintotal);
  }
d3508 2
a3509 2
    char *file;
    int  from_tty;
d3516 1
a3516 1
   pmon_load_fast (file);
d3518 1
a3518 1
   mips_load_srec (file);
d3526 2
a3527 2
	 to a different value than GDB thinks it has. The following ensures
	 that the write_pc() WILL update the PC value: */
d3604 1
a3604 1
  pmon_ops.to_doc =   "\
d3634 5
a3638 5
    add_set_cmd ("timeout", no_class, var_zinteger,
		 (char *) &mips_receive_wait,
		 "Set timeout in seconds for remote MIPS serial I/O.",
		 &setlist),
	&showlist);
d3641 3
a3643 3
    add_set_cmd ("retransmit-timeout", no_class, var_zinteger,
		 (char *) &mips_retransmit_wait,
	 "Set retransmit timeout in seconds for remote MIPS serial I/O.\n\
d3646 1
a3646 1
	&showlist);
d3649 3
a3651 3
    add_set_cmd ("syn-garbage-limit", no_class, var_zinteger,
		 (char *) &mips_syn_garbage,
"Set the maximum number of characters to ignore when scanning for a SYN.\n\
d3655 2
a3656 2
		 &setlist),
		     &showlist);
d3666 7
a3672 7
    add_set_cmd ("monitor-warnings", class_obscure, var_zinteger,
		 (char *)&monitor_warnings,
		 "Set printing of monitor warnings.\n"
		 "When enabled, monitor warnings about hardware breakpoints "
		 "will be displayed.",
		 &setlist),
		     &showlist);
d3675 1
a3675 1
	   "Send a packet to PMON (must be in debug mode)."); 
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d675 1
d683 1
d688 1
a688 1

d694 1
a694 1

d1564 1
a1564 1
  make_cleanup_freeargv (argv);
@


1.1.1.3
log
@import gdb-1999-07-07 pre reformat
@
text
@a169 1
/* *INDENT-OFF* */
a232 1
/* *INDENT-ON* */
d526 1
a526 1
fputc_readable (ch, file)
a527 1
     struct gdb_file *file;
d530 1
a530 1
    fputc_unfiltered ('\n', file);
d532 1
a532 1
    fprintf_unfiltered (file, "\\r");
d534 1
a534 1
    fprintf_unfiltered (file, "^%c", ch + '@@');
d536 1
a536 1
    fprintf_unfiltered (file, "[%02x]", ch & 0xff);
d538 1
a538 1
    fputc_unfiltered (ch, file);
d546 1
a546 1
fputs_readable (string, file)
a547 1
     struct gdb_file *file;
d552 1
a552 1
    fputc_readable (c, file);
d569 3
a571 3
      fprintf_unfiltered (gdb_stdlog, "Expected \"");
      fputs_readable (string, gdb_stdlog);
      fprintf_unfiltered (gdb_stdlog, "\", got \"");
d587 1
a587 1
	    fprintf_unfiltered (gdb_stdlog, "\": FAIL\n");
d592 1
a592 1
	fputc_readable (c, gdb_stdlog);
d600 1
a600 1
		fprintf_unfiltered (gdb_stdlog, "\": OK\n");
d702 1
a702 1
	fprintf_unfiltered (gdb_stdlog, "Read '%c' %d 0x%x\n", ch, ch, ch);
d704 1
a704 1
	fprintf_unfiltered (gdb_stdlog, "Timed out in read\n");
d720 1
a720 1
	fprintf_unfiltered (gdb_stdlog, "Reinitializing MIPS debugging mode\n");
d774 2
a775 2
		  fputc_readable (ch, gdb_stdlog);
		  gdb_flush (gdb_stdlog);
d910 1
a910 1
	  fprintf_unfiltered (gdb_stdlog, "Writing \"%s\"\n", packet + 1);
d1000 2
a1001 2
	      fprintf_unfiltered (gdb_stdlog, "Got ack %d \"%s%s\"\n",
				  HDR_GET_SEQ (hdr), hdr + 1, trlr);
d1077 1
a1077 1
	    fprintf_unfiltered (gdb_stdlog, "Ignoring unexpected ACK\n");
d1107 2
a1108 3
	    fprintf_unfiltered (gdb_stdlog,
				"Got new SYN after %d chars (wanted %d)\n",
				i, len);
d1125 1
a1125 1
	    fprintf_unfiltered (gdb_stdlog, "Got SYN when wanted trailer\n");
d1135 2
a1136 3
	    fprintf_unfiltered (gdb_stdlog,
			       "Ignoring sequence number %d (want %d)\n",
			       HDR_GET_SEQ (hdr), mips_receive_seq);
@


1.1.1.4
log
@import gdb-1999-07-07 post reformat
@
text
@d6 1
a6 1
   This file is part of GDB.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d49 1
a50 1

d55 7
a61 8
enum break_type
  {
    BREAK_WRITE,		/* 0 */
    BREAK_READ,			/* 1 */
    BREAK_ACCESS,		/* 2 */
    BREAK_FETCH,		/* 3 */
    BREAK_UNUSED		/* 4 */
  };
d85 2
a86 2
				     CORE_ADDR data, int *perr, int timeout,
				       char *buff));
d105 1
a105 1
static int mips_wait PARAMS ((int pid, struct target_waitstatus * status));
d121 1
a121 1
				     int write, struct target_ops * ignore));
d123 1
a123 1
static void mips_files_info PARAMS ((struct target_ops * ignore));
d133 1
a133 1
				 unsigned int *chksum));
d138 2
a139 2
				     int *inptr, int inamount, int *recsize,
			       unsigned int *csum, unsigned int *zerofill));
d169 2
a170 1
/* *INDENT-OFF* */
d174 3
a176 3
   SYN  The first character is always a SYN (ASCII 026, or ^V).  SYN
   may not appear anywhere else in the packet.  Any time a SYN is
   seen, a new packet should be assumed to have begun.
d179 8
a186 8
   This byte contains the upper five bits of the logical length
   of the data section, plus a single bit indicating whether this
   is a data packet or an acknowledgement.  The documentation
   indicates that this bit is 1 for a data packet, but the actual
   board uses 1 for an acknowledgement.  The value of the byte is
   0x40 + (ack ? 0x20 : 0) + (len >> 6)
   (we always have 0 <= len < 1024).  Acknowledgement packets do
   not carry data, and must have a data length of 0.
d189 2
a190 2
   the data section.  The value is
   0x40 + (len & 0x3f)
d192 25
a216 25
   SEQ  This byte contains the six bit sequence number of the packet.
   The value is
   0x40 + seq
   An acknowlegment packet contains the sequence number of the
   packet being acknowledged plus 1 modulo 64.  Data packets are
   transmitted in sequence.  There may only be one outstanding
   unacknowledged data packet at a time.  The sequence numbers
   are independent in each direction.  If an acknowledgement for
   the previous packet is received (i.e., an acknowledgement with
   the sequence number of the packet just sent) the packet just
   sent should be retransmitted.  If no acknowledgement is
   received within a timeout period, the packet should be
   retransmitted.  This has an unfortunate failure condition on a
   high-latency line, as a delayed acknowledgement may lead to an
   endless series of duplicate packets.

   DATA The actual data bytes follow.  The following characters are
   escaped inline with DLE (ASCII 020, or ^P):
   SYN (026)    DLE S
   DLE (020)    DLE D
   ^C  (003)    DLE C
   ^S  (023)    DLE s
   ^Q  (021)    DLE q
   The additional DLE characters are not counted in the logical
   length stored in the TYPE_LEN and LEN1 bytes.
d221 8
a228 8
   These bytes contain an 18 bit checksum of the complete
   contents of the packet excluding the SEQ byte and the
   CSUM[123] bytes.  The checksum is simply the twos complement
   addition of all the bytes treated as unsigned characters.  The
   values of the checksum bytes are:
   CSUM1: 0x40 + ((cksum >> 12) & 0x3f)
   CSUM2: 0x40 + ((cksum >> 6) & 0x3f)
   CSUM3: 0x40 + (cksum & 0x3f)
a235 1

d316 10
a325 11
enum mips_monitor_type
  {
    /* IDT/SIM monitor being used: */
    MON_IDT,
    /* PMON monitor being used: */
    MON_PMON,			/* 3.0.83 [COGENT,EB,FP,NET] Algorithmics Ltd. Nov  9 1995 17:19:50 */
    MON_DDB,			/* 2.7.473 [DDBVR4300,EL,FP,NET] Risq Modular Systems,  Thu Jun 6 09:28:40 PDT 1996 */
    MON_LSI,			/* 4.3.12 [EB,FP], LSI LOGIC Corp. Tue Feb 25 13:22:14 1997 */
    /* Last and unused value, for sizing vectors, etc. */
    MON_LAST
  };
d334 6
a339 6
   target               prompt
   -----                -----
   pmon         PMON> 
   ddb          NEC010>
   lsi          PMON>
 */
d403 1
a403 1
#if 0				/* not used (yet?) */
d413 1
a413 1
 */
d416 6
a421 7
  {
    enum break_type type;	/* type of breakpoint */
    CORE_ADDR addr;		/* address of breakpoint */
    int len;			/* length of region being watched */
    unsigned long value;	/* value to watch */
  }
lsi_breakpoints[MAX_LSI_BREAKPOINTS];
d425 11
a435 11
#define W_WARN	0x100		/* This bit is set if the error code is a warning */
#define W_MSK   0x101		/* warning: Range feature is supported via mask */
#define W_VAL   0x102		/* warning: Value check is not supported in hardware */
#define W_QAL   0x104		/* warning: Requested qualifiers are not supported in hardware */

#define E_ERR	0x200		/* This bit is set if the error code is an error */
#define E_BPT   0x200		/* error: No such breakpoint number */
#define E_RGE   0x201		/* error: Range is not supported */
#define E_QAL   0x202		/* error: The requested qualifiers can not be used */
#define E_OUT   0x203		/* error: Out of hardware resources */
#define E_NON   0x204		/* error: Hardware breakpoint not supported */
d438 4
a441 4
  {
    int code;			/* error code */
    char *string;		/* string associated with this code */
  };
d445 4
a448 4
  {W_MSK, "Range feature is supported via mask"},
  {W_VAL, "Value check is not supported in hardware"},
  {W_QAL, "Requested qualifiers are not supported in hardware"},
  {0, NULL}
d452 7
a458 7
{
  {E_BPT, "No such breakpoint number"},
  {E_RGE, "Range is not supported"},
  {E_QAL, "The requested qualifiers can not be used"},
  {E_OUT, "Out of hardware resources"},
  {E_NON, "Hardware breakpoint not supported"},
  {0, NULL}
d467 1
a467 1
close_ports ()
d479 1
a479 1

d487 1
a487 1
mips_error (char *string,...)
d502 1
a502 1

d504 1
a504 1
  wrap_here ("");		/* Force out any buffered output */
d536 1
a536 1
  else if (ch < 0x20)		/* ASCII control character */
d538 1
a538 1
  else if (ch >= 0x7f)		/* non-ASCII characters (rubout or greater) */
d562 1
a562 1
 */
d599 1
a599 1
	{
d620 1
a620 1
 */
d626 1
a626 1
  return mips_expect_timeout (string, 2);
d644 5
a648 6
      if (c == SERIAL_TIMEOUT)
	{
	  fprintf_unfiltered (gdb_stderr,
		 "Failed to read %d characters from target (TIMEOUT)\n", n);
	  return 0;
	}
d684 1
a684 1
      i = watchdog;
d691 1
a691 1
  if (ch == SERIAL_TIMEOUT && timeout == -1)	/* Watchdog went off */
d704 1
a704 1
         target_wait, and I think this might be called from there.  */
d718 2
a719 2
      && !mips_initializing
      && !mips_exiting)
d732 1
a732 1
         in progress and get back to command level as quickly as possible. */
d762 3
a764 3
         sitting here indefinitely if the board sends us one garbage
         character per second.  ch may already have a value from the
         last time through the loop.  */
d769 1
a769 1
	    return -1;
d773 4
a776 4
	         what the program is outputting, if the debugging is
	         being done on the console port.  Don't use _filtered;
	         we can't deal with a QUIT out of target_wait.  */
	      if (!mips_initializing || remote_debug > 0)
d785 1
a785 1
		mips_error ("Debug protocol failure:  more than %d characters before a sync.",
d795 1
a795 1
	    return -1;
d797 1
a797 1
	  if (ch == SYN || !HDR_CHECK (ch))
d804 1
a804 1
         loop around and keep looking for SYN.  */
d806 1
a806 1
	return 0;
d831 1
a831 1
      if (!TRLR_CHECK (ch))
d858 1
a858 1

d921 1
a921 1
      if (!get_ack)
d945 2
a946 3
	  if (HDR_IS_DATA (hdr))
	    {
	      int i;
d948 2
a949 2
	      /* Ignore any errors raised whilst attempting to ignore
	         packet. */
d951 1
a951 1
	      len = HDR_GET_LEN (hdr);
d953 14
a966 3
	      for (i = 0; i < len; i++)
		{
		  int rch;
d968 2
a969 10
		  rch = mips_readchar (2);
		  if (rch == SYN)
		    {
		      ch = SYN;
		      break;
		    }
		  if (rch == SERIAL_TIMEOUT)
		    break;
		  /* ignore the character */
		}
d971 4
a974 7
	      if (i == len)
		(void) mips_receive_trailer (trlr, &garbage, &ch, 2);

	      /* We don't bother checking the checksum, or providing an
	         ACK to the packet. */
	      continue;
	    }
d1003 1
a1003 1
	         target_wait, and I think this might be called from there.  */
d1067 1
a1067 1
      if (!HDR_IS_DATA (hdr))
d1069 9
a1077 9
	  len = HDR_GET_LEN (hdr);
	  /* Check if the length is valid for an ACK, we may aswell
	     try and read the remainder of the packet: */
	  if (len == 0)
	    {
	      /* Ignore the error condition, since we are going to
	         ignore the packet anyway. */
	      (void) mips_receive_trailer (trlr, &garbage, &ch, timeout);
	    }
d1141 2
a1142 2
				"Ignoring sequence number %d (want %d)\n",
				HDR_GET_SEQ (hdr), mips_receive_seq);
d1147 1
a1147 1
	break;
d1153 2
a1154 2
			   mips_cksum (hdr, buff, len),
			   TRLR_GET_CKSUM (trlr));
d1157 1
a1157 1
         previous packet to tell the remote to resend the packet.  */
d1175 1
a1175 1
			     ack + 1);
d1191 1
a1191 1
         target_wait, and I think this might be called from there.  */
d1213 1
a1213 1
         target_wait, and I think this might be called from there.  */
d1215 1
a1215 1
			 ack + 1);
d1235 9
a1243 9
   \0   don't send a request; just wait for a reply
   i    read word from instruction space at ADDR
   d    read word from data space at ADDR
   I    write DATA to instruction space at ADDR
   D    write DATA to data space at ADDR
   r    read register number ADDR
   R    set register number ADDR to value DATA
   c    continue execution (if ADDR != 1, set pc to ADDR)
   s    single step (if ADDR != 1, set pc to ADDR)
d1254 1
a1254 1
static CORE_ADDR
d1285 1
a1285 1
  if (!mips_need_reply)
d1303 3
a1305 3
         not be the same as errno values used on other systems.  If
         they stick to common errno values, they will be the same, but
         if they don't, they must be translated.  */
d1334 1
a1334 1
  SERIAL_WRITE (mips_desc, cmd, strlen (cmd));
d1351 1
a1351 1
  else				/* assume IDT monitor by default */
d1354 1
a1354 1
  sleep (1);
d1363 1
a1363 1

d1385 1
a1385 1
		    mips_receive_wait, NULL);
d1388 1
a1388 1
	return -1;
d1392 1
a1392 1
		  mips_receive_wait, NULL);
d1431 1
a1431 1
    j = 0;			/* start by checking if we are already at the prompt */
d1433 1
a1433 1
    j = 1;			/* start by sending a break */
d1438 2
a1439 2
	case 0:		/* First, try sending a CR */
	  SERIAL_FLUSH_INPUT (mips_desc);
d1441 2
a1442 2
	  break;
	case 1:		/* First, try sending a break */
d1445 1
a1445 1
	case 2:		/* Then, try a ^C */
d1448 1
a1448 1
	case 3:		/* Then, try escaping from download */
d1450 33
a1482 33
	    if (mips_monitor != MON_IDT)
	      {
		char tbuff[7];

		/* We shouldn't need to send multiple termination
		   sequences, since the target performs line (or
		   block) reads, and then processes those
		   packets. In-case we were downloading a large packet
		   we flush the output buffer before inserting a
		   termination sequence. */
		SERIAL_FLUSH_OUTPUT (mips_desc);
		sprintf (tbuff, "\r/E/E\r");
		SERIAL_WRITE (mips_desc, tbuff, 6);
	      }
	    else
	      {
		char srec[10];
		int i;

		/* We are possibly in binary download mode, having
		   aborted in the middle of an S-record.  ^C won't
		   work because of binary mode.  The only reliable way
		   out is to send enough termination packets (8 bytes)
		   to fill up and then overflow the largest size
		   S-record (255 bytes in this case).  This amounts to
		   256/8 + 1 packets.
		 */

		mips_make_srec (srec, '7', 0, NULL, 0);

		for (i = 1; i <= 33; i++)
		  {
		    SERIAL_WRITE (mips_desc, srec, 8);
d1484 2
a1485 2
		    if (SERIAL_READCHAR (mips_desc, 0) >= 0)
		      break;	/* Break immediatly if we get something from
d1487 3
a1489 3
		  }
	      }
	  }
d1503 1
a1503 1
         around that.  */
d1555 1
a1555 1
	    "To open a MIPS remote debugging connection, you need to specify what serial\n\
d1557 6
a1562 6
	    "If you want to use TFTP to download to the board, specify the name of a\n"
	    "temporary file to be used by GDB for downloads as the second argument.\n"
	    "This filename must be in the form host:filename, where host is the name\n"
	    "of the host running the TFTP server, and the file must be readable by the\n"
	    "world.  If the local name of the temporary file differs from the name as\n"
	    "seen from the board via TFTP, specify that name as the third parameter.\n");
d1567 1
a1567 1
    nomem (0);
d1571 1
a1571 1
  if (argv[1])			/* remote TFTP name specified? */
d1574 1
a1574 1
      if (argv[2])		/* local TFTP filename specified? */
d1591 4
a1594 4
	{
	  SERIAL_CLOSE (mips_desc);
	  perror_with_name (serial_port_name);
	}
d1622 2
a1623 2
	    if ((local_name = strchr (remote_name, ':')) != NULL)
	      local_name++;	/* skip over the colon */
d1703 1
a1703 1

d1801 1
a1801 1
  if (!mips_need_reply)
d1842 1
a1842 1
      supply_register (30, buf);	/* This register they are avoiding and so it is unnamed */
d1866 5
a1870 5
         Right now, PMON doesn't give us enough information to determine which
         breakpoint we hit.  So we have to look up the PC in our own table
         of breakpoints, and if found, assume it's just a normal instruction
         fetch breakpoint, not a data watchpoint.  FIXME when PMON
         provides some way to tell us what type of breakpoint it is.  */
d1872 1
a1872 1
      CORE_ADDR pc = read_pc ();
d1886 3
a1888 3
         0x1 c 0x0 0x57f 0x1
         The return packet from an ordinary breakpoint doesn't have the
         extra 0x01 field tacked onto the end.  */
d1895 7
a1901 7
     SPP_SIGTRAP     5       breakpoint
     SPP_SIGINT      2
     SPP_SIGSEGV     11
     SPP_SIGBUS      10
     SPP_SIGILL      4
     SPP_SIGFPE      8
     SPP_SIGTERM     15 */
d1918 1
a1918 1
         is not a normal breakpoint.  */
d1923 1
a1923 1
	  CORE_ADDR pc = read_pc ();
d2007 2
a2008 2
	    val = (unsigned) mips_request ('t', (unsigned int) pmon_reg,
			   (unsigned int) 0, &err, mips_receive_wait, NULL);
d2011 1
a2011 1
			   (unsigned int) 0, &err, mips_receive_wait, NULL);
d2060 1
a2060 1
static unsigned int
d2077 2
a2078 2
	mips_error ("Can't read address 0x%s: %s",
		    paddr_nz (addr), safe_strerror (errno));
d2131 1
a2131 1
  register CORE_ADDR addr = memaddr & ~3;
d2165 1
a2165 1
			       extract_unsigned_integer (&buffer[i * 4], 4),
d2168 1
a2168 1
	  if (i % 256 == 255)
d2188 1
a2188 1
	  store_unsigned_integer (&buffer[i * 4], 4, mips_fetch_word (addr));
d2233 1
a2233 1
	  close_ports ();
d2336 1
a2336 1
#if 0				/* currently not used */
d2343 1
a2343 1
#define PMON_MAX_BP (33)	/* 32 SW, 1 HW */
d2356 1
a2356 1
      char tbuff[12];		/* space for breakpoint command */
d2362 1
a2362 1
	mips_error ("Failed to exit debug mode");
d2370 2
a2371 2
	return 1;
      tbuff[2] = '\0';		/* terminate the string */
d2373 5
a2377 5
	{
	  fprintf_unfiltered (gdb_stderr,
	      "Invalid decimal breakpoint number from target: %s\n", tbuff);
	  return 1;
	}
d2388 2
a2389 2
	return 1;
      tbuff[10] = '\0';		/* terminate the string */
d2392 5
a2396 5
	{
	  fprintf_unfiltered (gdb_stderr,
			    "Invalid hex address from target: %s\n", tbuff);
	  return 1;
	}
d2399 2
a2400 2
	{
	  fprintf_unfiltered (gdb_stderr,
d2402 3
a2404 3
			      bpnum, PMON_MAX_BP - 1);
	  return 1;
	}
d2407 1
a2407 1
	fprintf_unfiltered (gdb_stderr, "Warning: Breakpoint addresses do not match: 0x%x != 0x%x\n", addr, bpaddr);
d2430 1
a2430 1
      char tbuff[7];		/* enough for delete breakpoint command */
d2433 2
a2434 2
	if (mips_pmon_bp_info[bpnum] == addr)
	  break;
d2437 6
a2442 6
	{
	  fprintf_unfiltered (gdb_stderr,
			      "pmon_remove_breakpoint: Failed to find breakpoint at address 0x%s\n",
			      paddr_nz (addr));
	  return 1;
	}
d2445 1
a2445 1
	mips_error ("Failed to exit debug mode");
d2471 1
a2471 1
  return cnt < MAX_LSI_BREAKPOINTS && strcmp (target_shortname, "lsi") == 0;
d2618 1
a2618 1
				  "common_breakpoint (0x%s): Warning: %s\n",
d2625 1
a2625 1
			"common_breakpoint (0x%s): Unknown warning: 0x%x\n",
d2658 4
a2661 4
   0 = write                    (BREAK_WRITE)
   1 = read                     (BREAK_READ)
   2 = read/write               (BREAK_ACCESS)
   3 = instruction fetch        (BREAK_FETCH)
d2681 1
a2681 1
      if (set == 0)		/* clear breakpoint */
d2684 3
a2686 3
	     <pid> 'b' <bptn> 0x0
	     reply:
	     <pid> 'b' 0x0 <code>
d2721 1
a2721 2
      else
	/* set a breakpoint */
d2724 3
a2726 3
	     <pid> 'B' <addr> 0x0
	     reply:
	     <pid> 'B' <bptn> <code>
d2730 1
a2730 1
	     <pid> 'A' <addr1> <type> [<addr2>  [<value>]]
d2732 3
a2734 3
	     where: type= "0x1" = read
	     "0x2" = write
	     "0x3" = access (read or write)
d2737 6
a2742 6
	     bptn - a breakpoint number, which is a small integer with
	     possible values of zero through 255.
	     code - an error return code, a value of zero indicates a
	     succesful completion, other values indicate various
	     errors and warnings.

d2745 1
a2745 1
	   */
d2752 1
a2752 2
	  else
	    /* watchpoint */
d2756 1
a2756 1
		     type == BREAK_READ ? 1 : (type == BREAK_WRITE ? 2 : 3),
d2777 1
a2777 1
	  lsi_breakpoints[rresponse].len = len;
d2785 3
a2787 3
         0x0 <CMD> <ADDR> <MASK> <FLAGS>
         <MASK> is a don't care mask for addresses.
         <FLAGS> is any combination of `r', `w', or `f' for read/write/fetch.
d2794 2
a2795 2
      if (set)			/* set a breakpoint */
	{
d2799 1
a2799 1
	    case BREAK_WRITE:	/* write */
d2802 1
a2802 1
	    case BREAK_READ:	/* read */
d2805 1
a2805 1
	    case BREAK_ACCESS:	/* read/write */
d2808 1
a2808 1
	    case BREAK_FETCH:	/* fetch */
d2843 1
a2843 1
	  if (rresponse != 22)	/* invalid argument */
d2845 1
a2845 1
			     "common_breakpoint (0x%s):  Got error: 0x%x\n",
d2941 2
a2942 2
	    }			/* Per-packet (or S-record) loop */

d2944 1
a2944 1
	}			/* Loadable sections */
d2946 1
a2946 1
  if (hashmark)
d2948 1
a2948 1

d2961 2
a2962 2
 *      time, each with it's own header and trailer line.
 *      An srecord looks like this:
d2966 6
a2971 6
 *          | |        |                   |
 *        S01000006F6B692D746573742E73726563E4
 *        S315000448600000000000000000FC00005900000000E9
 *        S31A0004000023C1400037DE00F023604000377B009020825000348D
 *        S30B0004485A0000000000004E
 *        S70500040000F6
d2973 1
a2973 1
 *      S<type><length><address><data><checksum>
d2996 1
a2996 1
 *        is the sum of all the raw byte data in the record, from the length
d3052 7
a3058 7
   'K'     clear checksum
   'C'     compare checksum (12bit value, not included in checksum calculation)
   'S'     define symbol name (for addr) terminated with "," and padded to 4char boundary
   'Z'     zero fill multiple of 3bytes
   'B'     byte (12bit encoded value, of 8bit data)
   'A'     address (36bit encoded value)
   'E'     define entry as original address, and exit load
d3084 10
a3093 12
  if ((n % 12) != 0)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Fast encoding bitcount must be a multiple of 12bits: %dbit%s\n", n, (n == 1) ? "" : "s");
      return (0);
    }
  if (n > 36)
    {
      fprintf_unfiltered (gdb_stderr,
			  "Fast encoding cannot process more than 36bits at the moment: %dbits\n", n);
      return (0);
    }
d3096 5
a3100 11
  if (chksum != NULL)
    {
      switch (n)
	{
	case 36:
	  *chksum += ((v >> 24) & 0xFFF);
	case 24:
	  *chksum += ((v >> 12) & 0xFFF);
	case 12:
	  *chksum += ((v >> 0) & 0xFFF);
	}
d3102 1
d3104 4
a3107 6
  do
    {
      n -= 6;
      *p++ = encoding[(v >> n) & 0x3F];
    }
  while (n > 0);
d3109 1
a3109 1
  return (count);
d3123 1
a3123 1
  sprintf (*buff, "/Z");
d3127 1
a3127 1
  return (recsize + count + 2);
d3143 1
a3143 1
  *buff += 2;			/* include zero terminator */
d3146 1
a3146 1
  return (recsize + count + 3);
d3180 31
a3210 39
  while ((*recsize < (MAXRECSIZE - CHECKSIZE)) && ((inamount - *inptr) > 0))
    {
      /* Process the binary data: */
      if ((inamount - *inptr) < 3)
	{
	  if (*zerofill != 0)
	    *recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
	  sprintf (p, "/B");
	  count = pmon_makeb64 (inbuf[*inptr], &p[2], 12, csum);
	  p += (2 + count);
	  *recsize += (2 + count);
	  (*inptr)++;
	}
      else
	{
	  unsigned int value = ((inbuf[*inptr + 0] << 16) | (inbuf[*inptr + 1] << 8) | inbuf[*inptr + 2]);
	  /* Simple check for zero data. TODO: A better check would be
	     to check the last, and then the middle byte for being zero
	     (if the first byte is not). We could then check for
	     following runs of zeros, and if above a certain size it is
	     worth the 4 or 8 character hit of the byte insertions used
	     to pad to the start of the zeroes. NOTE: This also depends
	     on the alignment at the end of the zero run. */
	  if (value == 0x00000000)
	    {
	      (*zerofill)++;
	      if (*zerofill == 0xFFF)	/* 12bit counter */
		*recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
	    }
	  else
	    {
	      if (*zerofill != 0)
		*recsize = pmon_zeroset (*recsize, &p, zerofill, csum);
	      count = pmon_makeb64 (value, p, 24, csum);
	      p += count;
	      *recsize += count;
	    }
	  *inptr += 3;
	}
d3212 1
d3219 1
a3219 1
pmon_check_ack (mesg)
d3232 1
a3232 1
	  return (-1);		/* terminate the download */
d3236 1
a3236 1
  return (0);
d3279 1
a3279 1
  char hexnumber[9];		/* includes '\0' space */
d3324 1
a3324 1
  sprintf (hexnumber, "%x", final);
d3330 1
a3330 1
  sprintf (hexnumber, "%x", bintotal);
d3365 2
a3366 2
  buffer = (char *) xmalloc (MAXRECSIZE + 1);
  binbuf = (unsigned char *) xmalloc (BINCHUNK);
d3368 1
a3368 1
  abfd = bfd_openr (file, 0);
d3370 10
a3379 10
    {
      printf_filtered ("Unable to open file %s\n", file);
      return;
    }

  if (bfd_check_format (abfd, bfd_object) == 0)
    {
      printf_filtered ("File is not an object file\n");
      return;
    }
d3388 2
a3389 2
  pmon_start_download ();

d3391 2
a3392 2
  sprintf (buffer, "/Kxx\n");
  reclen = strlen (buffer);
d3394 1
a3394 1
  finished = pmon_check_ack ("/Kxx");
d3397 4
a3400 17
    if (s->flags & SEC_LOAD)	/* only deal with loadable sections */
      {
	bintotal += s->_raw_size;
	final = (s->vma + s->_raw_size);

	printf_filtered ("%s\t: 0x%4x .. 0x%4x  ", s->name, (unsigned int) s->vma,
			 (unsigned int) (s->vma + s->_raw_size));
	gdb_flush (gdb_stdout);

	/* Output the starting address */
	sprintf (buffer, "/A");
	reclen = pmon_makeb64 (s->vma, &buffer[2], 36, &csum);
	buffer[2 + reclen] = '\n';
	buffer[3 + reclen] = '\0';
	reclen += 3;		/* for the initial escape code and carriage return */
	pmon_download (buffer, reclen);
	finished = pmon_check_ack ("/A");
d3402 66
a3467 59
	if (!finished)
	  {
	    unsigned int binamount;
	    unsigned int zerofill = 0;
	    char *bp = buffer;
	    unsigned int i;

	    reclen = 0;

	    for (i = 0; ((i < s->_raw_size) && !finished); i += binamount)
	      {
		int binptr = 0;

		binamount = min (BINCHUNK, s->_raw_size - i);

		bfd_get_section_contents (abfd, s, binbuf, i, binamount);

		/* This keeps a rolling checksum, until we decide to output
		   the line: */
		for (; ((binamount - binptr) > 0);)
		  {
		    pmon_make_fastrec (&bp, binbuf, &binptr, binamount, &reclen, &csum, &zerofill);
		    if (reclen >= (MAXRECSIZE - CHECKSIZE))
		      {
			reclen = pmon_checkset (reclen, &bp, &csum);
			pmon_download (buffer, reclen);
			finished = pmon_check_ack ("data record");
			if (finished)
			  {
			    zerofill = 0;	/* do not transmit pending zerofills */
			    break;
			  }

			if (hashmark)
			  {
			    putchar_unfiltered ('#');
			    gdb_flush (gdb_stdout);
			  }

			bp = buffer;
			reclen = 0;	/* buffer processed */
		      }
		  }
	      }

	    /* Ensure no out-standing zerofill requests: */
	    if (zerofill != 0)
	      reclen = pmon_zeroset (reclen, &bp, &zerofill, &csum);

	    /* and then flush the line: */
	    if (reclen > 0)
	      {
		reclen = pmon_checkset (reclen, &bp, &csum);
		/* Currently pmon_checkset outputs the line terminator by
		   default, so we write out the buffer so far: */
		pmon_download (buffer, reclen);
		finished = pmon_check_ack ("record remnant");
	      }
	  }
d3469 2
a3470 2
	putchar_unfiltered ('\n');
      }
d3474 1
a3474 1
  sprintf (buffer, "/E/E\n");	/* include dummy padding characters */
d3478 5
a3482 8
  if (finished)
    {				/* Ignore the termination message: */
      SERIAL_FLUSH_INPUT (udp_in_use ? udp_desc : mips_desc);
    }
  else
    {				/* Deal with termination message: */
      pmon_end_download (final, bintotal);
    }
d3491 2
a3492 2
     char *file;
     int from_tty;
d3499 1
a3499 1
    pmon_load_fast (file);
d3501 1
a3501 1
    mips_load_srec (file);
d3509 2
a3510 2
         to a different value than GDB thinks it has. The following ensures
         that the write_pc() WILL update the PC value: */
d3587 1
a3587 1
  pmon_ops.to_doc = "\
d3617 5
a3621 5
		      add_set_cmd ("timeout", no_class, var_zinteger,
				   (char *) &mips_receive_wait,
		       "Set timeout in seconds for remote MIPS serial I/O.",
				   &setlist),
		      &showlist);
d3624 3
a3626 3
		  add_set_cmd ("retransmit-timeout", no_class, var_zinteger,
			       (char *) &mips_retransmit_wait,
			       "Set retransmit timeout in seconds for remote MIPS serial I/O.\n\
d3629 1
a3629 1
		      &showlist);
d3632 3
a3634 3
		   add_set_cmd ("syn-garbage-limit", no_class, var_zinteger,
				(char *) &mips_syn_garbage,
				"Set the maximum number of characters to ignore when scanning for a SYN.\n\
d3638 2
a3639 2
				&setlist),
		      &showlist);
d3649 7
a3655 7
	       add_set_cmd ("monitor-warnings", class_obscure, var_zinteger,
			    (char *) &monitor_warnings,
			    "Set printing of monitor warnings.\n"
		"When enabled, monitor warnings about hardware breakpoints "
			    "will be displayed.",
			    &setlist),
		      &showlist);
d3658 1
a3658 1
	   "Send a packet to PMON (must be in debug mode).");
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d38 5
d490 1
d492 4
d499 1
d501 5
d1282 1
a1282 1
	internal_error ("mips_request: Trying to send command before reply");
d1292 1
a1292 1
    internal_error ("mips_request: Trying to get reply before command");
@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d44 1
d397 1
a397 1
static int monitor_supports_breakpoints = 0;
d2548 1
a2548 1
remote_mips_stopped_by_watchpoint (void)
d2867 1
a2867 1
	  fprintf_unfiltered (gdb_stderr, "Download got a NACK at byte %s!  Retrying.\n", paddr_u (addr));
d2913 3
a2915 4
	  /* FIXME!  vma too small????? */
	  printf_filtered ("%s\t: 0x%4lx .. 0x%4lx  ", s->name,
			   (long) s->vma,
			   (long) (s->vma + s->_raw_size));
@


1.1.1.7
log
@import gdb-2000-02-01 snapshot
@
text
@d2 1
a2 1
   Copyright 1993-1995, 2000 Free Software Foundation, Inc.
d517 1
a517 1
     struct ui_file *file;
d538 1
a538 1
     struct ui_file *file;
@


