head	1.77;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.76.2.1
	gdb_7_6-2013-04-26-release:1.76.2.1
	gdb_7_6-branch:1.76.0.2
	gdb_7_6-2013-03-12-branchpoint:1.76
	gdb_7_5_1-2012-11-29-release:1.75
	gdb_7_5-2012-08-17-release:1.75
	gdb_7_5-branch:1.75.0.2
	gdb_7_5-2012-07-18-branchpoint:1.75
	gdb_7_4_1-2012-04-26-release:1.70.2.2
	gdb_7_4-2012-01-24-release:1.70.2.1
	gdb_7_4-branch:1.70.0.2
	gdb_7_4-2011-12-13-branchpoint:1.70
	gdb_7_3_1-2011-09-04-release:1.69
	gdb_7_3-2011-07-26-release:1.69
	gdb_7_3-branch:1.69.0.2
	gdb_7_3-2011-04-01-branchpoint:1.69
	gdb_7_2-2010-09-02-release:1.64
	gdb_7_2-branch:1.64.0.2
	gdb_7_2-2010-07-07-branchpoint:1.64
	gdb_7_1-2010-03-18-release:1.60
	gdb_7_1-branch:1.60.0.2
	gdb_7_1-2010-02-18-branchpoint:1.60
	gdb_7_0_1-2009-12-22-release:1.59
	gdb_7_0-2009-10-06-release:1.59
	gdb_7_0-branch:1.59.0.4
	gdb_7_0-2009-09-16-branchpoint:1.59
	arc-sim-20090309:1.55
	msnyder-checkpoint-072509-branch:1.59.0.2
	msnyder-checkpoint-072509-branchpoint:1.59
	arc-insight_6_8-branch:1.55.0.6
	arc-insight_6_8-branchpoint:1.55
	insight_6_8-branch:1.55.0.4
	insight_6_8-branchpoint:1.55
	reverse-20081226-branch:1.56.0.10
	reverse-20081226-branchpoint:1.56
	multiprocess-20081120-branch:1.56.0.8
	multiprocess-20081120-branchpoint:1.56
	reverse-20080930-branch:1.56.0.6
	reverse-20080930-branchpoint:1.56
	reverse-20080717-branch:1.56.0.4
	reverse-20080717-branchpoint:1.56
	msnyder-reverse-20080609-branch:1.56.0.2
	msnyder-reverse-20080609-branchpoint:1.56
	drow-reverse-20070409-branch:1.49.0.2
	drow-reverse-20070409-branchpoint:1.49
	gdb_6_8-2008-03-27-release:1.55
	gdb_6_8-branch:1.55.0.2
	gdb_6_8-2008-02-26-branchpoint:1.55
	gdb_6_7_1-2007-10-29-release:1.51
	gdb_6_7-2007-10-10-release:1.51
	gdb_6_7-branch:1.51.0.2
	gdb_6_7-2007-09-07-branchpoint:1.51
	insight_6_6-20070208-release:1.48
	gdb_6_6-2006-12-18-release:1.48
	gdb_6_6-branch:1.48.0.18
	gdb_6_6-2006-11-15-branchpoint:1.48
	insight_6_5-20061003-release:1.48
	gdb-csl-symbian-6_4_50_20060226-12:1.48
	gdb-csl-sourcerygxx-3_4_4-25:1.47
	nickrob-async-20060828-mergepoint:1.48
	gdb-csl-symbian-6_4_50_20060226-11:1.48
	gdb-csl-sourcerygxx-4_1-17:1.48
	gdb-csl-20060226-branch-local-2:1.48
	gdb-csl-sourcerygxx-4_1-14:1.48
	gdb-csl-sourcerygxx-4_1-13:1.48
	gdb-csl-sourcerygxx-4_1-12:1.48
	gdb-csl-sourcerygxx-3_4_4-21:1.48
	gdb_6_5-20060621-release:1.48
	gdb-csl-sourcerygxx-4_1-9:1.48
	gdb-csl-sourcerygxx-4_1-8:1.48
	gdb-csl-sourcerygxx-4_1-7:1.48
	gdb-csl-arm-2006q1-6:1.48
	gdb-csl-sourcerygxx-4_1-6:1.48
	gdb-csl-symbian-6_4_50_20060226-10:1.48
	gdb-csl-symbian-6_4_50_20060226-9:1.48
	gdb-csl-symbian-6_4_50_20060226-8:1.48
	gdb-csl-coldfire-4_1-11:1.48
	gdb-csl-sourcerygxx-3_4_4-19:1.48
	gdb-csl-coldfire-4_1-10:1.48
	gdb_6_5-branch:1.48.0.16
	gdb_6_5-2006-05-14-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-5:1.48
	nickrob-async-20060513-branch:1.48.0.14
	nickrob-async-20060513-branchpoint:1.48
	gdb-csl-sourcerygxx-4_1-4:1.48
	msnyder-reverse-20060502-branch:1.48.0.12
	msnyder-reverse-20060502-branchpoint:1.48
	gdb-csl-morpho-4_1-4:1.48
	gdb-csl-sourcerygxx-3_4_4-17:1.48
	readline_5_1-import-branch:1.48.0.10
	readline_5_1-import-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.48
	gdb-csl-symbian-20060226-branch:1.48.0.8
	gdb-csl-symbian-20060226-branchpoint:1.48
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.48
	msnyder-reverse-20060331-branch:1.48.0.6
	msnyder-reverse-20060331-branchpoint:1.48
	gdb-csl-available-20060303-branch:1.48.0.4
	gdb-csl-available-20060303-branchpoint:1.48
	gdb-csl-20060226-branch:1.48.0.2
	gdb-csl-20060226-branchpoint:1.48
	gdb_6_4-20051202-release:1.47
	msnyder-fork-checkpoint-branch:1.47.0.8
	msnyder-fork-checkpoint-branchpoint:1.47
	gdb-csl-gxxpro-6_3-branch:1.47.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.47
	gdb_6_4-branch:1.47.0.4
	gdb_6_4-2005-11-01-branchpoint:1.47
	gdb-csl-arm-20051020-branch:1.47.0.2
	gdb-csl-arm-20051020-branchpoint:1.47
	msnyder-tracepoint-checkpoint-branch:1.46.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.46
	gdb-csl-arm-20050325-2005-q1b:1.44
	gdb-csl-arm-20050325-2005-q1a:1.44
	csl-arm-20050325-branch:1.44.0.2
	csl-arm-20050325-branchpoint:1.44
	gdb-post-i18n-errorwarning-20050211:1.44
	gdb-pre-i18n-errorwarning-20050211:1.43
	gdb_6_3-20041109-release:1.43
	gdb_6_3-branch:1.43.0.2
	gdb_6_3-20041019-branchpoint:1.43
	drow_intercu-merge-20040921:1.43
	drow_intercu-merge-20040915:1.43
	jimb-gdb_6_2-e500-branch:1.41.0.6
	jimb-gdb_6_2-e500-branchpoint:1.41
	gdb_6_2-20040730-release:1.41
	gdb_6_2-branch:1.41.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.41
	gdb_6_1_1-20040616-release:1.39
	gdb_6_1-2004-04-05-release:1.39
	drow_intercu-merge-20040402:1.40
	drow_intercu-merge-20040327:1.40
	ezannoni_pie-20040323-branch:1.40.0.2
	ezannoni_pie-20040323-branchpoint:1.40
	cagney_tramp-20040321-mergepoint:1.40
	cagney_tramp-20040309-branch:1.39.0.4
	cagney_tramp-20040309-branchpoint:1.39
	gdb_6_1-branch:1.39.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.39
	drow_intercu-20040221-branch:1.38.0.6
	drow_intercu-20040221-branchpoint:1.38
	cagney_bfdfile-20040213-branch:1.38.0.4
	cagney_bfdfile-20040213-branchpoint:1.38
	drow-cplus-merge-20040208:1.38
	carlton_dictionary-20040126-merge:1.38
	cagney_bigcore-20040122-branch:1.38.0.2
	cagney_bigcore-20040122-branchpoint:1.38
	drow-cplus-merge-20040113:1.38
	drow-cplus-merge-20031224:1.38
	drow-cplus-merge-20031220:1.38
	carlton_dictionary-20031215-merge:1.38
	drow-cplus-merge-20031214:1.38
	carlton-dictionary-20031111-merge:1.37
	gdb_6_0-2003-10-04-release:1.33
	kettenis_sparc-20030918-branch:1.35.0.4
	kettenis_sparc-20030918-branchpoint:1.35
	carlton_dictionary-20030917-merge:1.35
	ezannoni_pie-20030916-branchpoint:1.35
	ezannoni_pie-20030916-branch:1.35.0.2
	cagney_x86i386-20030821-branch:1.34.0.2
	cagney_x86i386-20030821-branchpoint:1.34
	carlton_dictionary-20030805-merge:1.33
	carlton_dictionary-20030627-merge:1.33
	gdb_6_0-branch:1.33.0.2
	gdb_6_0-2003-06-23-branchpoint:1.33
	jimb-ppc64-linux-20030613-branch:1.30.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.30
	cagney_convert-20030606-branch:1.30.0.10
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.30.0.8
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.30.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.30
	carlton_dictionary-20030523-merge:1.30
	cagney_fileio-20030521-branch:1.30.0.4
	cagney_fileio-20030521-branchpoint:1.30
	kettenis_i386newframe-20030517-mergepoint:1.30
	jimb-ppc64-linux-20030509-branch:1.30.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.29
	kettenis_i386newframe-20030419-branch:1.29.0.2
	kettenis_i386newframe-20030419-branchpoint:1.29
	carlton_dictionary-20030416-merge:1.29
	cagney_frameaddr-20030409-mergepoint:1.28
	kettenis_i386newframe-20030406-branch:1.28.0.18
	kettenis_i386newframe-20030406-branchpoint:1.28
	cagney_frameaddr-20030403-branchpoint:1.28
	cagney_frameaddr-20030403-branch:1.28.0.16
	cagney_framebase-20030330-mergepoint:1.28
	cagney_framebase-20030326-branch:1.28.0.14
	cagney_framebase-20030326-branchpoint:1.28
	cagney_lazyid-20030317-branch:1.28.0.12
	cagney_lazyid-20030317-branchpoint:1.28
	kettenis-i386newframe-20030316-mergepoint:1.28
	offbyone-20030313-branch:1.28.0.10
	offbyone-20030313-branchpoint:1.28
	kettenis-i386newframe-20030308-branch:1.28.0.8
	kettenis-i386newframe-20030308-branchpoint:1.28
	carlton_dictionary-20030305-merge:1.28
	cagney_offbyone-20030303-branch:1.28.0.6
	cagney_offbyone-20030303-branchpoint:1.28
	carlton_dictionary-20030207-merge:1.28
	interps-20030203-mergepoint:1.28
	interps-20030202-branch:1.28.0.4
	interps-20030202-branchpoint:1.28
	cagney-unwind-20030108-branch:1.28.0.2
	cagney-unwind-20030108-branchpoint:1.28
	carlton_dictionary-20021223-merge:1.28
	gdb_5_3-2002-12-12-release:1.23
	carlton_dictionary-20021115-merge:1.28
	kseitz_interps-20021105-merge:1.26
	kseitz_interps-20021103-merge:1.26
	drow-cplus-merge-20021020:1.23
	drow-cplus-merge-20021025:1.23
	carlton_dictionary-20021025-merge:1.23
	carlton_dictionary-20021011-merge:1.23
	drow-cplus-branch:1.23.0.6
	drow-cplus-branchpoint:1.23
	kseitz_interps-20020930-merge:1.23
	carlton_dictionary-20020927-merge:1.23
	carlton_dictionary-branch:1.23.0.4
	carlton_dictionary-20020920-branchpoint:1.23
	gdb_5_3-branch:1.23.0.2
	gdb_5_3-2002-09-04-branchpoint:1.23
	kseitz_interps-20020829-merge:1.23
	cagney_sysregs-20020825-branch:1.22.0.4
	cagney_sysregs-20020825-branchpoint:1.22
	readline_4_3-import-branch:1.22.0.2
	readline_4_3-import-branchpoint:1.22
	gdb_5_2_1-2002-07-23-release:1.16
	kseitz_interps-20020528-branch:1.18.0.4
	kseitz_interps-20020528-branchpoint:1.18
	cagney_regbuf-20020515-branch:1.18.0.2
	cagney_regbuf-20020515-branchpoint:1.18
	jimb-macro-020506-branch:1.16.0.4
	jimb-macro-020506-branchpoint:1.16
	gdb_5_2-2002-04-29-release:1.16
	gdb_5_2-branch:1.16.0.2
	gdb_5_2-2002-03-03-branchpoint:1.16
	gdb_5_1_1-2002-01-24-release:1.12
	gdb_5_1_0_1-2002-01-03-release:1.12
	cygnus_cvs_20020108_pre:1.16
	gdb_5_1_0_1-2002-01-03-branchpoint:1.12
	gdb_5_1_0_1-2002-01-03-branch:1.12.0.6
	gdb_5_1-2001-11-21-release:1.12
	gdb_s390-2001-09-26-branch:1.12.0.4
	gdb_s390-2001-09-26-branchpoint:1.12
	gdb_5_1-2001-07-29-branch:1.12.0.2
	gdb_5_1-2001-07-29-branchpoint:1.12
	dberlin-typesystem-branch:1.11.0.2
	dberlin-typesystem-branchpoint:1.11
	gdb-post-ptid_t-2001-05-03:1.9
	gdb-pre-ptid_t-2001-05-03:1.9
	insight-precleanup-2001-01-01:1.6
	gdb-post-protoization-2000-07-29:1.6
	gdb-pre-protoization-2000-07-29:1.5
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb-post-params-removal-2000-06-04:1.5
	gdb-pre-params-removal-2000-06-04:1.5
	gdb-post-params-removal-2000-05-28:1.5
	gdb-pre-params-removal-2000-05-28:1.4
	gdb_5_0-2000-05-19-release:1.2.2.1
	gdb_4_18_2-2000-05-18-release:1.2.2.1
	gdb_4_95_1-2000-05-11-snapshot:1.2.2.1
	gdb_4_95_0-2000-04-27-snapshot:1.2.2.1
	gdb_5_0-2000-04-10-branch:1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.2
	repo-unification-2000-02-06:1.1.1.6
	insight-2000-02-04:1.1.1.6
	gdb-2000-02-04:1.1.1.6
	gdb-2000-02-02:1.1.1.6
	gdb-2000-02-01:1.1.1.6
	gdb-2000-01-31:1.1.1.6
	gdb-2000-01-26:1.1.1.6
	gdb-2000-01-24:1.1.1.6
	gdb-2000-01-17:1.1.1.6
	gdb-2000-01-10:1.1.1.6
	gdb-2000-01-05:1.1.1.6
	gdb-1999-12-21:1.1.1.6
	gdb-1999-12-13:1.1.1.6
	gdb-1999-12-07:1.1.1.6
	gdb-1999-12-06:1.1.1.5
	gdb-1999-11-16:1.1.1.5
	gdb-1999-11-08:1.1.1.5
	gdb-1999-11-01:1.1.1.5
	gdb-1999-10-25:1.1.1.5
	gdb-1999-10-18:1.1.1.5
	gdb-1999-10-11:1.1.1.5
	gdb-1999-10-04:1.1.1.5
	gdb-1999-09-28:1.1.1.5
	gdb-1999-09-21:1.1.1.5
	gdb-1999-09-13:1.1.1.4
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.2
	gdb-1999-08-23:1.1.1.2
	gdb-1999-08-16:1.1.1.2
	gdb-1999-08-09:1.1.1.2
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.77
date	2013.04.19.14.13.30;	author palves;	state Exp;
branches;
next	1.76;

1.76
date	2013.01.01.06.32.45;	author brobecke;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2012.05.18.21.02.48;	author sergiodj;	state Exp;
branches;
next	1.74;

1.74
date	2012.03.05.16.17.52;	author palves;	state Exp;
branches;
next	1.73;

1.73
date	2012.03.05.14.21.46;	author palves;	state Exp;
branches;
next	1.72;

1.72
date	2012.03.01.20.48.56;	author palves;	state Exp;
branches;
next	1.71;

1.71
date	2012.01.04.08.17.04;	author brobecke;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.11.17.19.16;	author tromey;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2011.02.26.23.49.19;	author msnyder;	state Exp;
branches;
next	1.67;

1.67
date	2011.02.26.23.45.01;	author msnyder;	state Exp;
branches;
next	1.66;

1.66
date	2011.01.09.03.08.56;	author msnyder;	state Exp;
branches;
next	1.65;

1.65
date	2011.01.01.15.33.08;	author brobecke;	state Exp;
branches;
next	1.64;

1.64
date	2010.05.05.19.30.36;	author msnyder;	state Exp;
branches;
next	1.63;

1.63
date	2010.04.09.00.18.52;	author hjl;	state Exp;
branches;
next	1.62;

1.62
date	2010.04.08.22.50.34;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2010.04.07.18.44.57;	author hjl;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.01.07.31.36;	author brobecke;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.02.17.25.54;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2009.07.02.12.48.54;	author uweigand;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.03.05.57.52;	author brobecke;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.11.05.21.38;	author deuling;	state Exp;
branches;
next	1.55;

1.55
date	2008.01.01.22.53.11;	author drow;	state Exp;
branches;
next	1.54;

1.54
date	2007.11.09.05.32.19;	author deuling;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.24.20.29.14;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.22.14.04.42;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.23.18.08.34;	author brobecke;	state Exp;
branches;
next	1.50;

1.50
date	2007.05.06.14.28.27;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.09.17.58.51;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2005.12.17.22.34.01;	author eliz;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.04.10.17.40;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.14.11.27.03;	author kettenis;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.09.19.53.44;	author kettenis;	state Exp;
branches;
next	1.44;

1.44
date	2005.02.11.04.05.51;	author cagney;	state Exp;
branches;
next	1.43;

1.43
date	2004.09.11.10.24.47;	author hilfingr;	state Exp;
branches;
next	1.42;

1.42
date	2004.08.04.20.57.29;	author kettenis;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.26.23.20.30;	author kettenis;	state Exp;
branches;
next	1.40;

1.40
date	2004.03.15.22.44.12;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.28.20.43.51;	author kettenis;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2003.11.27.20.35.38;	author kettenis;	state Exp;
branches
	1.38.6.1;
next	1.37;

1.37
date	2003.09.28.13.35.44;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.27.21.57.56;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.23.08.56.45;	author kettenis;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.10.17.01.32;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.15.12.45.23;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.15.11.01.46;	author kettenis;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.15.00.27.54;	author cagney;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.04.10.27.47;	author kettenis;	state Exp;
branches;
next	1.29;

1.29
date	2003.04.11.14.56.40;	author cagney;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2002.11.09.19.34.35;	author kdienes;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.08.23.31.09;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.03.13.04.47;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2002.11.03.12.32.42;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.02.14.59.10;	author cagney;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.27.22.37.06;	author tromey;	state Exp;
branches
	1.23.4.1
	1.23.6.1;
next	1.22;

1.22
date	2002.08.19.11.52.36;	author muller;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.16.00.01.59;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.15.23.06.54;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.15.17.36.57;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.12.21.16.08;	author kettenis;	state Exp;
branches
	1.18.4.1;
next	1.17;

1.17
date	2002.05.11.17.22.26;	author thorpej;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.12.22.27.35;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.28.14.07.35;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.21.12.15.15;	author smid;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.01.18.39.23;	author cagney;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.07.00.14.06;	author chastain;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.04.21.14.05;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.04.19.19.58;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.09.16.14.55;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.06.08.21.08;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.01.01.39.20;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.28.01.12.27;	author kevinb;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.21.21.21.20;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.12.00.22.56;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.26.21.21.50;	author kettenis;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.76.2.1
date	2013.04.19.14.15.50;	author palves;	state Exp;
branches;
next	;

1.70.2.1
date	2012.01.06.04.43.16;	author brobecke;	state Exp;
branches;
next	1.70.2.2;

1.70.2.2
date	2012.03.06.13.17.12;	author palves;	state Exp;
branches;
next	;

1.69.2.1
date	2012.03.06.13.19.13;	author palves;	state Exp;
branches;
next	;

1.39.4.1
date	2004.03.21.23.57.34;	author cagney;	state Exp;
branches;
next	;

1.38.6.1
date	2004.03.27.17.37.49;	author drow;	state Exp;
branches;
next	1.38.6.2;

1.38.6.2
date	2004.09.16.17.01.08;	author drow;	state Exp;
branches;
next	;

1.29.2.1
date	2003.05.04.11.37.42;	author kettenis;	state Exp;
branches;
next	;

1.23.4.1
date	2002.11.15.19.18.49;	author carlton;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2003.04.16.19.56.52;	author carlton;	state Exp;
branches;
next	1.23.4.3;

1.23.4.3
date	2003.05.23.18.40.40;	author carlton;	state Exp;
branches;
next	1.23.4.4;

1.23.4.4
date	2003.06.27.21.49.58;	author carlton;	state Exp;
branches;
next	1.23.4.5;

1.23.4.5
date	2003.09.17.21.28.22;	author carlton;	state Exp;
branches;
next	1.23.4.6;

1.23.4.6
date	2003.11.11.23.50.46;	author carlton;	state Exp;
branches;
next	1.23.4.7;

1.23.4.7
date	2003.12.16.00.00.37;	author carlton;	state Exp;
branches;
next	;

1.23.6.1
date	2003.12.14.20.27.18;	author drow;	state Exp;
branches;
next	;

1.18.4.1
date	2002.08.30.22.52.44;	author kseitz;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2002.11.04.00.17.31;	author ezannoni;	state Exp;
branches;
next	;

1.2.2.1
date	2000.04.12.00.26.58;	author kettenis;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2000.05.21.21.31.10;	author kettenis;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.34.02;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.07.07.20.07.06;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.09.08.23.59.16;	author shebs;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.09.13.21.37.29;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.09.22.03.24.39;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.12.08.02.50.38;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.77
log
@Fix the x87 FP register printout when issuing the “info float” command.

Consider the following simple program:

.globl  _start
.text
_start:
      fldt    val
.data
      val: .byte 0x00,0x00,0x45,0x07,0x11,0x19,0x22,0xe9,0xfe,0xbf

With current GDB on x86-64 GNU/Linux hosts, after the moment the fldt
command has been executed the register st(0) looks like this,
according to the “info regs” output (TOP=7):

  R7: Valid   0xffffffbffffffffeffffffe922191107450000 -0.910676542908976927

which is clearly wrong (just count its length).  The problem is due to
the printf statement (see patch) printing a promoted integer value of
a char argument "raw[i]", and, since char is signed on x86-64
GNU/Linux, the erroneous “ffffff” are printed for the first three
bytes which turn out to be "negative".  The fix is to use gdb_byte
instead which is unsigned (and is the type of value_contents(), the
type to be used for raw target bytes anyway).  After the fix the value
will be printed correctly:

  R7: Valid   0xbffee922191107450000 -0.910676542908976927

gdb/
2013-04-19  Vladimir Kargov <kargov@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* i387-tdep.c (i387_print_float_info): Use gdb_byte for pointer to
	value contents.

gdb/testsuite/
2013-04-19  Vladimir Kargov  <kargov@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.arch/i386-float.S: New file.
	* gdb.arch/i386-float.exp: New file.
@
text
@/* Intel 387 floating point stuff.

   Copyright (C) 1988-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "doublest.h"
#include "floatformat.h"
#include "frame.h"
#include "gdbcore.h"
#include "inferior.h"
#include "language.h"
#include "regcache.h"
#include "value.h"

#include "gdb_assert.h"
#include "gdb_string.h"

#include "i386-tdep.h"
#include "i387-tdep.h"
#include "i386-xstate.h"

/* Print the floating point number specified by RAW.  */

static void
print_i387_value (struct gdbarch *gdbarch,
		  const gdb_byte *raw, struct ui_file *file)
{
  DOUBLEST value;

  /* Using extract_typed_floating here might affect the representation
     of certain numbers such as NaNs, even if GDB is running natively.
     This is fine since our caller already detects such special
     numbers and we print the hexadecimal representation anyway.  */
  value = extract_typed_floating (raw, i387_ext_type (gdbarch));

  /* We try to print 19 digits.  The last digit may or may not contain
     garbage, but we'd better print one too many.  We need enough room
     to print the value, 1 position for the sign, 1 for the decimal
     point, 19 for the digits and 6 for the exponent adds up to 27.  */
#ifdef PRINTF_HAS_LONG_DOUBLE
  fprintf_filtered (file, " %-+27.19Lg", (long double) value);
#else
  fprintf_filtered (file, " %-+27.19g", (double) value);
#endif
}

/* Print the classification for the register contents RAW.  */

static void
print_i387_ext (struct gdbarch *gdbarch,
		const gdb_byte *raw, struct ui_file *file)
{
  int sign;
  int integer;
  unsigned int exponent;
  unsigned long fraction[2];

  sign = raw[9] & 0x80;
  integer = raw[7] & 0x80;
  exponent = (((raw[9] & 0x7f) << 8) | raw[8]);
  fraction[0] = ((raw[3] << 24) | (raw[2] << 16) | (raw[1] << 8) | raw[0]);
  fraction[1] = (((raw[7] & 0x7f) << 24) | (raw[6] << 16)
		 | (raw[5] << 8) | raw[4]);

  if (exponent == 0x7fff && integer)
    {
      if (fraction[0] == 0x00000000 && fraction[1] == 0x00000000)
	/* Infinity.  */
	fprintf_filtered (file, " %cInf", (sign ? '-' : '+'));
      else if (sign && fraction[0] == 0x00000000 && fraction[1] == 0x40000000)
	/* Real Indefinite (QNaN).  */
	fputs_unfiltered (" Real Indefinite (QNaN)", file);
      else if (fraction[1] & 0x40000000)
	/* QNaN.  */
	fputs_filtered (" QNaN", file);
      else
	/* SNaN.  */
	fputs_filtered (" SNaN", file);
    }
  else if (exponent < 0x7fff && exponent > 0x0000 && integer)
    /* Normal.  */
    print_i387_value (gdbarch, raw, file);
  else if (exponent == 0x0000)
    {
      /* Denormal or zero.  */
      print_i387_value (gdbarch, raw, file);
      
      if (integer)
	/* Pseudo-denormal.  */
	fputs_filtered (" Pseudo-denormal", file);
      else if (fraction[0] || fraction[1])
	/* Denormal.  */
	fputs_filtered (" Denormal", file);
    }
  else
    /* Unsupported.  */
    fputs_filtered (" Unsupported", file);
}

/* Print the status word STATUS.  If STATUS_P is false, then STATUS
   was unavailable.  */

static void
print_i387_status_word (int status_p,
			unsigned int status, struct ui_file *file)
{
  fprintf_filtered (file, "Status Word:         ");
  if (!status_p)
    {
      fprintf_filtered (file, "%s\n", _("<unavailable>"));
      return;
    }

  fprintf_filtered (file, "%s", hex_string_custom (status, 4));
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0001) ? "IE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0002) ? "DE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0004) ? "ZE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0008) ? "OE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0010) ? "UE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0020) ? "PE" : "  ");
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0080) ? "ES" : "  ");
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0040) ? "SF" : "  ");
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0100) ? "C0" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0200) ? "C1" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0400) ? "C2" : "  ");
  fprintf_filtered (file, " %s", (status & 0x4000) ? "C3" : "  ");

  fputs_filtered ("\n", file);

  fprintf_filtered (file,
		    "                       TOP: %d\n", ((status >> 11) & 7));
}

/* Print the control word CONTROL.  If CONTROL_P is false, then
   CONTROL was unavailable.  */

static void
print_i387_control_word (int control_p,
			 unsigned int control, struct ui_file *file)
{
  fprintf_filtered (file, "Control Word:        ");
  if (!control_p)
    {
      fprintf_filtered (file, "%s\n", _("<unavailable>"));
      return;
    }

  fprintf_filtered (file, "%s", hex_string_custom (control, 4));
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (control & 0x0001) ? "IM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0002) ? "DM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0004) ? "ZM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0008) ? "OM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0010) ? "UM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0020) ? "PM" : "  ");

  fputs_filtered ("\n", file);

  fputs_filtered ("                       PC: ", file);
  switch ((control >> 8) & 3)
    {
    case 0:
      fputs_filtered ("Single Precision (24-bits)\n", file);
      break;
    case 1:
      fputs_filtered ("Reserved\n", file);
      break;
    case 2:
      fputs_filtered ("Double Precision (53-bits)\n", file);
      break;
    case 3:
      fputs_filtered ("Extended Precision (64-bits)\n", file);
      break;
    }
      
  fputs_filtered ("                       RC: ", file);
  switch ((control >> 10) & 3)
    {
    case 0:
      fputs_filtered ("Round to nearest\n", file);
      break;
    case 1:
      fputs_filtered ("Round down\n", file);
      break;
    case 2:
      fputs_filtered ("Round up\n", file);
      break;
    case 3:
      fputs_filtered ("Round toward zero\n", file);
      break;
    }
}

/* Print out the i387 floating point state.  Note that we ignore FRAME
   in the code below.  That's OK since floating-point registers are
   never saved on the stack.  */

void
i387_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,
		       struct frame_info *frame, const char *args)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
  ULONGEST fctrl;
  int fctrl_p;
  ULONGEST fstat;
  int fstat_p;
  ULONGEST ftag;
  int ftag_p;
  ULONGEST fiseg;
  int fiseg_p;
  ULONGEST fioff;
  int fioff_p;
  ULONGEST foseg;
  int foseg_p;
  ULONGEST fooff;
  int fooff_p;
  ULONGEST fop;
  int fop_p;
  int fpreg;
  int top;

  gdb_assert (gdbarch == get_frame_arch (frame));

  fctrl_p = read_frame_register_unsigned (frame,
					  I387_FCTRL_REGNUM (tdep), &fctrl);
  fstat_p = read_frame_register_unsigned (frame,
					  I387_FSTAT_REGNUM (tdep), &fstat);
  ftag_p = read_frame_register_unsigned (frame,
					 I387_FTAG_REGNUM (tdep), &ftag);
  fiseg_p = read_frame_register_unsigned (frame,
					  I387_FISEG_REGNUM (tdep), &fiseg);
  fioff_p = read_frame_register_unsigned (frame,
					  I387_FIOFF_REGNUM (tdep), &fioff);
  foseg_p = read_frame_register_unsigned (frame,
					  I387_FOSEG_REGNUM (tdep), &foseg);
  fooff_p = read_frame_register_unsigned (frame,
					  I387_FOOFF_REGNUM (tdep), &fooff);
  fop_p = read_frame_register_unsigned (frame,
					I387_FOP_REGNUM (tdep), &fop);

  if (fstat_p)
    {
      top = ((fstat >> 11) & 7);

      for (fpreg = 7; fpreg >= 0; fpreg--)
	{
	  struct value *regval;
	  int regnum;
	  int i;
	  int tag = -1;

	  fprintf_filtered (file, "%sR%d: ", fpreg == top ? "=>" : "  ", fpreg);

	  if (ftag_p)
	    {
	      tag = (ftag >> (fpreg * 2)) & 3;

	      switch (tag)
		{
		case 0:
		  fputs_filtered ("Valid   ", file);
		  break;
		case 1:
		  fputs_filtered ("Zero    ", file);
		  break;
		case 2:
		  fputs_filtered ("Special ", file);
		  break;
		case 3:
		  fputs_filtered ("Empty   ", file);
		  break;
		}
	    }
	  else
	    fputs_filtered ("Unknown ", file);

	  regnum = (fpreg + 8 - top) % 8 + I387_ST0_REGNUM (tdep);
	  regval = get_frame_register_value (frame, regnum);

	  if (value_entirely_available (regval))
	    {
	      const gdb_byte *raw = value_contents (regval);

	      fputs_filtered ("0x", file);
	      for (i = 9; i >= 0; i--)
		fprintf_filtered (file, "%02x", raw[i]);

	      if (tag != -1 && tag != 3)
		print_i387_ext (gdbarch, raw, file);
	    }
	  else
	    fprintf_filtered (file, "%s", _("<unavailable>"));

	  fputs_filtered ("\n", file);
	}
    }

  fputs_filtered ("\n", file);
  print_i387_status_word (fstat_p, fstat, file);
  print_i387_control_word (fctrl_p, fctrl, file);
  fprintf_filtered (file, "Tag Word:            %s\n",
		    ftag_p ? hex_string_custom (ftag, 4) : _("<unavailable>"));
  fprintf_filtered (file, "Instruction Pointer: %s:",
		    fiseg_p ? hex_string_custom (fiseg, 2) : _("<unavailable>"));
  fprintf_filtered (file, "%s\n",
		    fioff_p ? hex_string_custom (fioff, 8) : _("<unavailable>"));
  fprintf_filtered (file, "Operand Pointer:     %s:",
		    foseg_p ? hex_string_custom (foseg, 2) : _("<unavailable>"));
  fprintf_filtered (file, "%s\n",
		    fooff_p ? hex_string_custom (fooff, 8) : _("<unavailable>"));
  fprintf_filtered (file, "Opcode:              %s\n",
		    fop_p
		    ? (hex_string_custom (fop ? (fop | 0xd800) : 0, 4))
		    : _("<unavailable>"));
}


/* Return nonzero if a value of type TYPE stored in register REGNUM
   needs any special handling.  */

int
i387_convert_register_p (struct gdbarch *gdbarch, int regnum,
			 struct type *type)
{
  if (i386_fp_regnum_p (gdbarch, regnum))
    {
      /* Floating point registers must be converted unless we are
	 accessing them in their hardware type.  */
      if (type == i387_ext_type (gdbarch))
	return 0;
      else
	return 1;
    }

  return 0;
}

/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */

int
i387_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, gdb_byte *to,
			int *optimizedp, int *unavailablep)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  gdb_byte from[I386_MAX_REGISTER_SIZE];

  gdb_assert (i386_fp_regnum_p (gdbarch, regnum));

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning (_("Cannot convert floating-point register value "
	       "to non-floating-point type."));
      *optimizedp = *unavailablep = 0;
      return 0;
    }

  /* Convert to TYPE.  */
  if (!get_frame_register_bytes (frame, regnum, 0, TYPE_LENGTH (type),
				 from, optimizedp, unavailablep))
    return 0;

  convert_typed_floating (from, i387_ext_type (gdbarch), to, type);
  *optimizedp = *unavailablep = 0;
  return 1;
}

/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */

void
i387_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const gdb_byte *from)
{
  struct gdbarch *gdbarch = get_frame_arch (frame);
  gdb_byte to[I386_MAX_REGISTER_SIZE];

  gdb_assert (i386_fp_regnum_p (gdbarch, regnum));

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning (_("Cannot convert non-floating-point type "
	       "to floating-point register value."));
      return;
    }

  /* Convert from TYPE.  */
  convert_typed_floating (from, type, to, i387_ext_type (gdbarch));
  put_frame_register (frame, regnum, to);
}


/* Handle FSAVE and FXSAVE formats.  */

/* At fsave_offset[REGNUM] you'll find the offset to the location in
   the data structure used by the "fsave" instruction where GDB
   register REGNUM is stored.  */

static int fsave_offset[] =
{
  28 + 0 * 10,			/* %st(0) ...  */
  28 + 1 * 10,
  28 + 2 * 10,
  28 + 3 * 10,
  28 + 4 * 10,
  28 + 5 * 10,
  28 + 6 * 10,
  28 + 7 * 10,			/* ... %st(7).  */
  0,				/* `fctrl' (16 bits).  */
  4,				/* `fstat' (16 bits).  */
  8,				/* `ftag' (16 bits).  */
  16,				/* `fiseg' (16 bits).  */
  12,				/* `fioff'.  */
  24,				/* `foseg' (16 bits).  */
  20,				/* `fooff'.  */
  18				/* `fop' (bottom 11 bits).  */
};

#define FSAVE_ADDR(tdep, fsave, regnum) \
  (fsave + fsave_offset[regnum - I387_ST0_REGNUM (tdep)])


/* Fill register REGNUM in REGCACHE with the appropriate value from
   *FSAVE.  This function masks off any of the reserved bits in
   *FSAVE.  */

void
i387_supply_fsave (struct regcache *regcache, int regnum, const void *fsave)
{
  struct gdbarch *gdbarch = get_regcache_arch (regcache);
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  const gdb_byte *regs = fsave;
  int i;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);

  for (i = I387_ST0_REGNUM (tdep); i < I387_XMM0_REGNUM (tdep); i++)
    if (regnum == -1 || regnum == i)
      {
	if (fsave == NULL)
	  {
	    regcache_raw_supply (regcache, i, NULL);
	    continue;
	  }

	/* Most of the FPU control registers occupy only 16 bits in the
	   fsave area.  Give those a special treatment.  */
	if (i >= I387_FCTRL_REGNUM (tdep)
	    && i != I387_FIOFF_REGNUM (tdep) && i != I387_FOOFF_REGNUM (tdep))
	  {
	    gdb_byte val[4];

	    memcpy (val, FSAVE_ADDR (tdep, regs, i), 2);
	    val[2] = val[3] = 0;
	    if (i == I387_FOP_REGNUM (tdep))
	      val[1] &= ((1 << 3) - 1);
	    regcache_raw_supply (regcache, i, val);
	  }
	else
	  regcache_raw_supply (regcache, i, FSAVE_ADDR (tdep, regs, i));
      }

  /* Provide dummy values for the SSE registers.  */
  for (i = I387_XMM0_REGNUM (tdep); i < I387_MXCSR_REGNUM (tdep); i++)
    if (regnum == -1 || regnum == i)
      regcache_raw_supply (regcache, i, NULL);
  if (regnum == -1 || regnum == I387_MXCSR_REGNUM (tdep))
    {
      gdb_byte buf[4];

      store_unsigned_integer (buf, 4, byte_order, 0x1f80);
      regcache_raw_supply (regcache, I387_MXCSR_REGNUM (tdep), buf);
    }
}

/* Fill register REGNUM (if it is a floating-point register) in *FSAVE
   with the value from REGCACHE.  If REGNUM is -1, do this for all
   registers.  This function doesn't touch any of the reserved bits in
   *FSAVE.  */

void
i387_collect_fsave (const struct regcache *regcache, int regnum, void *fsave)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  gdb_byte *regs = fsave;
  int i;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);

  for (i = I387_ST0_REGNUM (tdep); i < I387_XMM0_REGNUM (tdep); i++)
    if (regnum == -1 || regnum == i)
      {
	/* Most of the FPU control registers occupy only 16 bits in
           the fsave area.  Give those a special treatment.  */
	if (i >= I387_FCTRL_REGNUM (tdep)
	    && i != I387_FIOFF_REGNUM (tdep) && i != I387_FOOFF_REGNUM (tdep))
	  {
	    gdb_byte buf[4];

	    regcache_raw_collect (regcache, i, buf);

	    if (i == I387_FOP_REGNUM (tdep))
	      {
		/* The opcode occupies only 11 bits.  Make sure we
                   don't touch the other bits.  */
		buf[1] &= ((1 << 3) - 1);
		buf[1] |= ((FSAVE_ADDR (tdep, regs, i))[1] & ~((1 << 3) - 1));
	      }
	    memcpy (FSAVE_ADDR (tdep, regs, i), buf, 2);
	  }
	else
	  regcache_raw_collect (regcache, i, FSAVE_ADDR (tdep, regs, i));
      }
}


/* At fxsave_offset[REGNUM] you'll find the offset to the location in
   the data structure used by the "fxsave" instruction where GDB
   register REGNUM is stored.  */

static int fxsave_offset[] =
{
  32,				/* %st(0) through ...  */
  48,
  64,
  80,
  96,
  112,
  128,
  144,				/* ... %st(7) (80 bits each).  */
  0,				/* `fctrl' (16 bits).  */
  2,				/* `fstat' (16 bits).  */
  4,				/* `ftag' (16 bits).  */
  12,				/* `fiseg' (16 bits).  */
  8,				/* `fioff'.  */
  20,				/* `foseg' (16 bits).  */
  16,				/* `fooff'.  */
  6,				/* `fop' (bottom 11 bits).  */
  160 + 0 * 16,			/* %xmm0 through ...  */
  160 + 1 * 16,
  160 + 2 * 16,
  160 + 3 * 16,
  160 + 4 * 16,
  160 + 5 * 16,
  160 + 6 * 16,
  160 + 7 * 16,
  160 + 8 * 16,
  160 + 9 * 16,
  160 + 10 * 16,
  160 + 11 * 16,
  160 + 12 * 16,
  160 + 13 * 16,
  160 + 14 * 16,
  160 + 15 * 16,		/* ... %xmm15 (128 bits each).  */
};

#define FXSAVE_ADDR(tdep, fxsave, regnum) \
  (fxsave + fxsave_offset[regnum - I387_ST0_REGNUM (tdep)])

/* We made an unfortunate choice in putting %mxcsr after the SSE
   registers %xmm0-%xmm7 instead of before, since it makes supporting
   the registers %xmm8-%xmm15 on AMD64 a bit involved.  Therefore we
   don't include the offset for %mxcsr here above.  */

#define FXSAVE_MXCSR_ADDR(fxsave) (fxsave + 24)

static int i387_tag (const gdb_byte *raw);


/* Fill register REGNUM in REGCACHE with the appropriate
   floating-point or SSE register value from *FXSAVE.  This function
   masks off any of the reserved bits in *FXSAVE.  */

void
i387_supply_fxsave (struct regcache *regcache, int regnum, const void *fxsave)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  const gdb_byte *regs = fxsave;
  int i;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);

  for (i = I387_ST0_REGNUM (tdep); i < I387_MXCSR_REGNUM (tdep); i++)
    if (regnum == -1 || regnum == i)
      {
	if (regs == NULL)
	  {
	    regcache_raw_supply (regcache, i, NULL);
	    continue;
	  }

	/* Most of the FPU control registers occupy only 16 bits in
	   the fxsave area.  Give those a special treatment.  */
	if (i >= I387_FCTRL_REGNUM (tdep) && i < I387_XMM0_REGNUM (tdep)
	    && i != I387_FIOFF_REGNUM (tdep) && i != I387_FOOFF_REGNUM (tdep))
	  {
	    gdb_byte val[4];

	    memcpy (val, FXSAVE_ADDR (tdep, regs, i), 2);
	    val[2] = val[3] = 0;
	    if (i == I387_FOP_REGNUM (tdep))
	      val[1] &= ((1 << 3) - 1);
	    else if (i== I387_FTAG_REGNUM (tdep))
	      {
		/* The fxsave area contains a simplified version of
		   the tag word.  We have to look at the actual 80-bit
		   FP data to recreate the traditional i387 tag word.  */

		unsigned long ftag = 0;
		int fpreg;
		int top;

		top = ((FXSAVE_ADDR (tdep, regs,
				     I387_FSTAT_REGNUM (tdep)))[1] >> 3);
		top &= 0x7;

		for (fpreg = 7; fpreg >= 0; fpreg--)
		  {
		    int tag;

		    if (val[0] & (1 << fpreg))
		      {
			int thisreg = (fpreg + 8 - top) % 8 
			               + I387_ST0_REGNUM (tdep);
			tag = i387_tag (FXSAVE_ADDR (tdep, regs, thisreg));
		      }
		    else
		      tag = 3;		/* Empty */

		    ftag |= tag << (2 * fpreg);
		  }
		val[0] = ftag & 0xff;
		val[1] = (ftag >> 8) & 0xff;
	      }
	    regcache_raw_supply (regcache, i, val);
	  }
	else
	  regcache_raw_supply (regcache, i, FXSAVE_ADDR (tdep, regs, i));
      }

  if (regnum == I387_MXCSR_REGNUM (tdep) || regnum == -1)
    {
      if (regs == NULL)
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM (tdep), NULL);
      else
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM (tdep),
			     FXSAVE_MXCSR_ADDR (regs));
    }
}

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for
   all registers.  This function doesn't touch any of the reserved
   bits in *FXSAVE.  */

void
i387_collect_fxsave (const struct regcache *regcache, int regnum, void *fxsave)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  gdb_byte *regs = fxsave;
  int i;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);

  for (i = I387_ST0_REGNUM (tdep); i < I387_MXCSR_REGNUM (tdep); i++)
    if (regnum == -1 || regnum == i)
      {
	/* Most of the FPU control registers occupy only 16 bits in
           the fxsave area.  Give those a special treatment.  */
	if (i >= I387_FCTRL_REGNUM (tdep) && i < I387_XMM0_REGNUM (tdep)
	    && i != I387_FIOFF_REGNUM (tdep) && i != I387_FOOFF_REGNUM (tdep))
	  {
	    gdb_byte buf[4];

	    regcache_raw_collect (regcache, i, buf);

	    if (i == I387_FOP_REGNUM (tdep))
	      {
		/* The opcode occupies only 11 bits.  Make sure we
                   don't touch the other bits.  */
		buf[1] &= ((1 << 3) - 1);
		buf[1] |= ((FXSAVE_ADDR (tdep, regs, i))[1] & ~((1 << 3) - 1));
	      }
	    else if (i == I387_FTAG_REGNUM (tdep))
	      {
		/* Converting back is much easier.  */

		unsigned short ftag;
		int fpreg;

		ftag = (buf[1] << 8) | buf[0];
		buf[0] = 0;
		buf[1] = 0;

		for (fpreg = 7; fpreg >= 0; fpreg--)
		  {
		    int tag = (ftag >> (fpreg * 2)) & 3;

		    if (tag != 3)
		      buf[0] |= (1 << fpreg);
		  }
	      }
	    memcpy (FXSAVE_ADDR (tdep, regs, i), buf, 2);
	  }
	else
	  regcache_raw_collect (regcache, i, FXSAVE_ADDR (tdep, regs, i));
      }

  if (regnum == I387_MXCSR_REGNUM (tdep) || regnum == -1)
    regcache_raw_collect (regcache, I387_MXCSR_REGNUM (tdep),
			  FXSAVE_MXCSR_ADDR (regs));
}

/* `xstate_bv' is at byte offset 512.  */
#define XSAVE_XSTATE_BV_ADDR(xsave) (xsave + 512)

/* At xsave_avxh_offset[REGNUM] you'll find the offset to the location in
   the upper 128bit of AVX register data structure used by the "xsave"
   instruction where GDB register REGNUM is stored.  */

static int xsave_avxh_offset[] =
{
  576 + 0 * 16,		/* Upper 128bit of %ymm0 through ...  */
  576 + 1 * 16,
  576 + 2 * 16,
  576 + 3 * 16,
  576 + 4 * 16,
  576 + 5 * 16,
  576 + 6 * 16,
  576 + 7 * 16,
  576 + 8 * 16,
  576 + 9 * 16,
  576 + 10 * 16,
  576 + 11 * 16,
  576 + 12 * 16,
  576 + 13 * 16,
  576 + 14 * 16,
  576 + 15 * 16		/* Upper 128bit of ... %ymm15 (128 bits each).  */
};

#define XSAVE_AVXH_ADDR(tdep, xsave, regnum) \
  (xsave + xsave_avxh_offset[regnum - I387_YMM0H_REGNUM (tdep)])

/* Similar to i387_supply_fxsave, but use XSAVE extended state.  */

void
i387_supply_xsave (struct regcache *regcache, int regnum,
		   const void *xsave)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  const gdb_byte *regs = xsave;
  int i;
  unsigned int clear_bv;
  static const gdb_byte zero[MAX_REGISTER_SIZE] = { 0 };
  enum
    {
      none = 0x0,
      x87 = 0x1,
      sse = 0x2,
      avxh = 0x4,
      all = x87 | sse | avxh
    } regclass;

  gdb_assert (regs != NULL);
  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);

  if (regnum == -1)
    regclass = all;
  else if (regnum >= I387_YMM0H_REGNUM (tdep)
	   && regnum < I387_YMMENDH_REGNUM (tdep))
    regclass = avxh;
  else if (regnum >= I387_XMM0_REGNUM(tdep)
	   && regnum < I387_MXCSR_REGNUM (tdep))
    regclass = sse;
  else if (regnum >= I387_ST0_REGNUM (tdep)
	   && regnum < I387_FCTRL_REGNUM (tdep))
    regclass = x87;
  else
    regclass = none;

  if (regclass != none)
    {
      /* Get `xstat_bv'.  */
      const gdb_byte *xstate_bv_p = XSAVE_XSTATE_BV_ADDR (regs);

      /* The supported bits in `xstat_bv' are 1 byte.  Clear part in
	 vector registers if its bit in xstat_bv is zero.  */
      clear_bv = (~(*xstate_bv_p)) & tdep->xcr0;
    }
  else
    clear_bv = I386_XSTATE_AVX_MASK;

  /* With the delayed xsave mechanism, in between the program
     starting, and the program accessing the vector registers for the
     first time, the register's values are invalid.  The kernel
     initializes register states to zero when they are set the first
     time in a program.  This means that from the user-space programs'
     perspective, it's the same as if the registers have always been
     zero from the start of the program.  Therefore, the debugger
     should provide the same illusion to the user.  */

  switch (regclass)
    {
    case none:
      break;

    case avxh:
      if ((clear_bv & I386_XSTATE_AVX))
	regcache_raw_supply (regcache, regnum, zero);
      else
	regcache_raw_supply (regcache, regnum,
			     XSAVE_AVXH_ADDR (tdep, regs, regnum));
      return;

    case sse:
      if ((clear_bv & I386_XSTATE_SSE))
	regcache_raw_supply (regcache, regnum, zero);
      else
	regcache_raw_supply (regcache, regnum,
			     FXSAVE_ADDR (tdep, regs, regnum));
      return;

    case x87:
      if ((clear_bv & I386_XSTATE_X87))
	regcache_raw_supply (regcache, regnum, zero);
      else
	regcache_raw_supply (regcache, regnum,
			     FXSAVE_ADDR (tdep, regs, regnum));
      return;

    case all:
      /* Handle the upper YMM registers.  */
      if ((tdep->xcr0 & I386_XSTATE_AVX))
	{
	  if ((clear_bv & I386_XSTATE_AVX))
	    {
	      for (i = I387_YMM0H_REGNUM (tdep);
		   i < I387_YMMENDH_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, zero);
	    }
	  else
	    {
	      for (i = I387_YMM0H_REGNUM (tdep);
		   i < I387_YMMENDH_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i,
				     XSAVE_AVXH_ADDR (tdep, regs, i));
	    }
	}

      /* Handle the XMM registers.  */
      if ((tdep->xcr0 & I386_XSTATE_SSE))
	{
	  if ((clear_bv & I386_XSTATE_SSE))
	    {
	      for (i = I387_XMM0_REGNUM (tdep);
		   i < I387_MXCSR_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, zero);
	    }
	  else
	    {
	      for (i = I387_XMM0_REGNUM (tdep);
		   i < I387_MXCSR_REGNUM (tdep); i++)
		regcache_raw_supply (regcache, i,
				     FXSAVE_ADDR (tdep, regs, i));
	    }
	}

      /* Handle the x87 registers.  */
      if ((tdep->xcr0 & I386_XSTATE_X87))
	{
	  if ((clear_bv & I386_XSTATE_X87))
	    {
	      for (i = I387_ST0_REGNUM (tdep);
		   i < I387_FCTRL_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, zero);
	    }
	  else
	    {
	      for (i = I387_ST0_REGNUM (tdep);
		   i < I387_FCTRL_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, FXSAVE_ADDR (tdep, regs, i));
	    }
	}
      break;
    }

  /* Only handle x87 control registers.  */
  for (i = I387_FCTRL_REGNUM (tdep); i < I387_XMM0_REGNUM (tdep); i++)
    if (regnum == -1 || regnum == i)
      {
	/* Most of the FPU control registers occupy only 16 bits in
	   the xsave extended state.  Give those a special treatment.  */
	if (i != I387_FIOFF_REGNUM (tdep)
	    && i != I387_FOOFF_REGNUM (tdep))
	  {
	    gdb_byte val[4];

	    memcpy (val, FXSAVE_ADDR (tdep, regs, i), 2);
	    val[2] = val[3] = 0;
	    if (i == I387_FOP_REGNUM (tdep))
	      val[1] &= ((1 << 3) - 1);
	    else if (i== I387_FTAG_REGNUM (tdep))
	      {
		/* The fxsave area contains a simplified version of
		   the tag word.  We have to look at the actual 80-bit
		   FP data to recreate the traditional i387 tag word.  */

		unsigned long ftag = 0;
		int fpreg;
		int top;

		top = ((FXSAVE_ADDR (tdep, regs,
				     I387_FSTAT_REGNUM (tdep)))[1] >> 3);
		top &= 0x7;

		for (fpreg = 7; fpreg >= 0; fpreg--)
		  {
		    int tag;

		    if (val[0] & (1 << fpreg))
		      {
			int thisreg = (fpreg + 8 - top) % 8 
				       + I387_ST0_REGNUM (tdep);
			tag = i387_tag (FXSAVE_ADDR (tdep, regs, thisreg));
		      }
		    else
		      tag = 3;		/* Empty */

		    ftag |= tag << (2 * fpreg);
		  }
		val[0] = ftag & 0xff;
		val[1] = (ftag >> 8) & 0xff;
	      }
	    regcache_raw_supply (regcache, i, val);
	  }
	else 
	  regcache_raw_supply (regcache, i, FXSAVE_ADDR (tdep, regs, i));
      }

  if (regnum == I387_MXCSR_REGNUM (tdep) || regnum == -1)
    regcache_raw_supply (regcache, I387_MXCSR_REGNUM (tdep),
			 FXSAVE_MXCSR_ADDR (regs));
}

/* Similar to i387_collect_fxsave, but use XSAVE extended state.  */

void
i387_collect_xsave (const struct regcache *regcache, int regnum,
		    void *xsave, int gcore)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  gdb_byte *regs = xsave;
  int i;
  enum
    {
      none = 0x0,
      check = 0x1,
      x87 = 0x2 | check,
      sse = 0x4 | check,
      avxh = 0x8 | check,
      all = x87 | sse | avxh
    } regclass;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);

  if (regnum == -1)
    regclass = all;
  else if (regnum >= I387_YMM0H_REGNUM (tdep)
	   && regnum < I387_YMMENDH_REGNUM (tdep))
    regclass = avxh;
  else if (regnum >= I387_XMM0_REGNUM(tdep)
	   && regnum < I387_MXCSR_REGNUM (tdep))
    regclass = sse;
  else if (regnum >= I387_ST0_REGNUM (tdep)
	   && regnum < I387_FCTRL_REGNUM (tdep))
    regclass = x87;
  else
    regclass = none;

  if (gcore)
    {
      /* Clear XSAVE extended state.  */
      memset (regs, 0, I386_XSTATE_SIZE (tdep->xcr0));

      /* Update XCR0 and `xstate_bv' with XCR0 for gcore.  */
      if (tdep->xsave_xcr0_offset != -1)
	memcpy (regs + tdep->xsave_xcr0_offset, &tdep->xcr0, 8);
      memcpy (XSAVE_XSTATE_BV_ADDR (regs), &tdep->xcr0, 8);
    }

  if ((regclass & check))
    {
      gdb_byte raw[I386_MAX_REGISTER_SIZE];
      gdb_byte *xstate_bv_p = XSAVE_XSTATE_BV_ADDR (regs);
      unsigned int xstate_bv = 0;
      /* The supported bits in `xstat_bv' are 1 byte.  */
      unsigned int clear_bv = (~(*xstate_bv_p)) & tdep->xcr0;
      gdb_byte *p;

      /* Clear register set if its bit in xstat_bv is zero.  */
      if (clear_bv)
	{
	  if ((clear_bv & I386_XSTATE_AVX))
	    for (i = I387_YMM0H_REGNUM (tdep);
		 i < I387_YMMENDH_REGNUM (tdep); i++)
	      memset (XSAVE_AVXH_ADDR (tdep, regs, i), 0, 16);

	  if ((clear_bv & I386_XSTATE_SSE))
	    for (i = I387_XMM0_REGNUM (tdep);
		 i < I387_MXCSR_REGNUM (tdep); i++)
	      memset (FXSAVE_ADDR (tdep, regs, i), 0, 16);

	  if ((clear_bv & I386_XSTATE_X87))
	    for (i = I387_ST0_REGNUM (tdep);
		 i < I387_FCTRL_REGNUM (tdep); i++)
	      memset (FXSAVE_ADDR (tdep, regs, i), 0, 10);
	}

      if (regclass == all)
	{
	  /* Check if any upper YMM registers are changed.  */
	  if ((tdep->xcr0 & I386_XSTATE_AVX))
	    for (i = I387_YMM0H_REGNUM (tdep);
		 i < I387_YMMENDH_REGNUM (tdep); i++)
	      {
		regcache_raw_collect (regcache, i, raw);
		p = XSAVE_AVXH_ADDR (tdep, regs, i);
		if (memcmp (raw, p, 16))
		  {
		    xstate_bv |= I386_XSTATE_AVX;
		    memcpy (p, raw, 16);
		  }
	      }

	  /* Check if any SSE registers are changed.  */
	  if ((tdep->xcr0 & I386_XSTATE_SSE))
	    for (i = I387_XMM0_REGNUM (tdep);
		 i < I387_MXCSR_REGNUM (tdep); i++)
	      {
		regcache_raw_collect (regcache, i, raw);
		p = FXSAVE_ADDR (tdep, regs, i);
		if (memcmp (raw, p, 16))
		  {
		    xstate_bv |= I386_XSTATE_SSE;
		    memcpy (p, raw, 16);
		  }
	      }

	  /* Check if any X87 registers are changed.  */
	  if ((tdep->xcr0 & I386_XSTATE_X87))
	    for (i = I387_ST0_REGNUM (tdep);
		 i < I387_FCTRL_REGNUM (tdep); i++)
	      {
		regcache_raw_collect (regcache, i, raw);
		p = FXSAVE_ADDR (tdep, regs, i);
		if (memcmp (raw, p, 10))
		  {
		    xstate_bv |= I386_XSTATE_X87;
		    memcpy (p, raw, 10);
		  }
	      }
	}
      else
	{
	  /* Check if REGNUM is changed.  */
	  regcache_raw_collect (regcache, regnum, raw);

	  switch (regclass)
	    {
	    default:
	      internal_error (__FILE__, __LINE__,
			      _("invalid i387 regclass"));

	    case avxh:
	      /* This is an upper YMM register.  */
	      p = XSAVE_AVXH_ADDR (tdep, regs, regnum);
	      if (memcmp (raw, p, 16))
		{
		  xstate_bv |= I386_XSTATE_AVX;
		  memcpy (p, raw, 16);
		}
	      break;

	    case sse:
	      /* This is an SSE register.  */
	      p = FXSAVE_ADDR (tdep, regs, regnum);
	      if (memcmp (raw, p, 16))
		{
		  xstate_bv |= I386_XSTATE_SSE;
		  memcpy (p, raw, 16);
		}
	      break;

	    case x87:
	      /* This is an x87 register.  */
	      p = FXSAVE_ADDR (tdep, regs, regnum);
	      if (memcmp (raw, p, 10))
		{
		  xstate_bv |= I386_XSTATE_X87;
		  memcpy (p, raw, 10);
		}
	      break;
	    }
	}

      /* Update the corresponding bits in `xstate_bv' if any SSE/AVX
	 registers are changed.  */
      if (xstate_bv)
	{
	  /* The supported bits in `xstat_bv' are 1 byte.  */
	  *xstate_bv_p |= (gdb_byte) xstate_bv;

	  switch (regclass)
	    {
	    default:
	      internal_error (__FILE__, __LINE__,
			      _("invalid i387 regclass"));

	    case all:
	      break;

	    case x87:
	    case sse:
	    case avxh:
	      /* Register REGNUM has been updated.  Return.  */
	      return;
	    }
	}
      else
	{
	  /* Return if REGNUM isn't changed.  */
	  if (regclass != all)
	    return;
	}
    }

  /* Only handle x87 control registers.  */
  for (i = I387_FCTRL_REGNUM (tdep); i < I387_XMM0_REGNUM (tdep); i++)
    if (regnum == -1 || regnum == i)
      {
	/* Most of the FPU control registers occupy only 16 bits in
	   the xsave extended state.  Give those a special treatment.  */
	if (i != I387_FIOFF_REGNUM (tdep)
	    && i != I387_FOOFF_REGNUM (tdep))
	  {
	    gdb_byte buf[4];

	    regcache_raw_collect (regcache, i, buf);

	    if (i == I387_FOP_REGNUM (tdep))
	      {
		/* The opcode occupies only 11 bits.  Make sure we
		   don't touch the other bits.  */
		buf[1] &= ((1 << 3) - 1);
		buf[1] |= ((FXSAVE_ADDR (tdep, regs, i))[1] & ~((1 << 3) - 1));
	      }
	    else if (i == I387_FTAG_REGNUM (tdep))
	      {
		/* Converting back is much easier.  */

		unsigned short ftag;
		int fpreg;

		ftag = (buf[1] << 8) | buf[0];
		buf[0] = 0;
		buf[1] = 0;

		for (fpreg = 7; fpreg >= 0; fpreg--)
		  {
		    int tag = (ftag >> (fpreg * 2)) & 3;

		    if (tag != 3)
		      buf[0] |= (1 << fpreg);
		  }
	      }
	    memcpy (FXSAVE_ADDR (tdep, regs, i), buf, 2);
	  }
	else
	  regcache_raw_collect (regcache, i, FXSAVE_ADDR (tdep, regs, i));
      }

  if (regnum == I387_MXCSR_REGNUM (tdep) || regnum == -1)
    regcache_raw_collect (regcache, I387_MXCSR_REGNUM (tdep),
			  FXSAVE_MXCSR_ADDR (regs));
}

/* Recreate the FTW (tag word) valid bits from the 80-bit FP data in
   *RAW.  */

static int
i387_tag (const gdb_byte *raw)
{
  int integer;
  unsigned int exponent;
  unsigned long fraction[2];

  integer = raw[7] & 0x80;
  exponent = (((raw[9] & 0x7f) << 8) | raw[8]);
  fraction[0] = ((raw[3] << 24) | (raw[2] << 16) | (raw[1] << 8) | raw[0]);
  fraction[1] = (((raw[7] & 0x7f) << 24) | (raw[6] << 16)
		 | (raw[5] << 8) | raw[4]);

  if (exponent == 0x7fff)
    {
      /* Special.  */
      return (2);
    }
  else if (exponent == 0x0000)
    {
      if (fraction[0] == 0x0000 && fraction[1] == 0x0000 && !integer)
	{
	  /* Zero.  */
	  return (1);
	}
      else
	{
	  /* Special.  */
	  return (2);
	}
    }
  else
    {
      if (integer)
	{
	  /* Valid.  */
	  return (0);
	}
      else
	{
	  /* Special.  */
	  return (2);
	}
    }
}

/* Prepare the FPU stack in REGCACHE for a function return.  */

void
i387_return_value (struct gdbarch *gdbarch, struct regcache *regcache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  ULONGEST fstat;

  /* Set the top of the floating-point register stack to 7.  The
     actual value doesn't really matter, but 7 is what a normal
     function return would end up with if the program started out with
     a freshly initialized FPU.  */
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM (tdep), &fstat);
  fstat |= (7 << 11);
  regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM (tdep), fstat);

  /* Mark %st(1) through %st(7) as empty.  Since we set the top of the
     floating-point register stack to 7, the appropriate value for the
     tag word is 0x3fff.  */
  regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM (tdep), 0x3fff);

}
@


1.76
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d301 1
a301 1
	      const char *raw = value_contents (regval);
@


1.76.2.1
log
@Fix the x87 FP register printout when issuing the “info float” command.

Consider the following simple program:

.globl  _start
.text
_start:
      fldt    val
.data
      val: .byte 0x00,0x00,0x45,0x07,0x11,0x19,0x22,0xe9,0xfe,0xbf

With current GDB on x86-64 GNU/Linux hosts, after the moment the fldt
command has been executed the register st(0) looks like this,
according to the “info regs” output (TOP=7):

  R7: Valid   0xffffffbffffffffeffffffe922191107450000 -0.910676542908976927

which is clearly wrong (just count its length).  The problem is due to
the printf statement (see patch) printing a promoted integer value of
a char argument "raw[i]", and, since char is signed on x86-64
GNU/Linux, the erroneous “ffffff” are printed for the first three
bytes which turn out to be "negative".  The fix is to use gdb_byte
instead which is unsigned (and is the type of value_contents(), the
type to be used for raw target bytes anyway).  After the fix the value
will be printed correctly:

  R7: Valid   0xbffee922191107450000 -0.910676542908976927

gdb/
2013-04-19  Vladimir Kargov <kargov@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* i387-tdep.c (i387_print_float_info): Use gdb_byte for pointer to
	value contents.

gdb/testsuite/
2013-04-19  Vladimir Kargov  <kargov@@gmail.com>
	    Pedro Alves  <palves@@redhat.com>

	* gdb.arch/i386-float.S: New file.
	* gdb.arch/i386-float.exp: New file.
@
text
@d301 1
a301 1
	      const gdb_byte *raw = value_contents (regval);
@


1.75
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3 1
a3 2
   Copyright (C) 1988-1989, 1991-1994, 1998-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.74
log
@2012-03-05  Pedro Alves  <palves@@redhat.com>

	* i387-tdep.c (i387_supply_xsave): Assert the xsave section buffer
	is not NULL, and remove resulting dead code.
@
text
@a239 1
  int fpreg_p;
a240 1
  int top_p;
a780 1
  const gdb_byte *p;
@


1.73
log
@2012-03-05  Pedro Alves  <palves@@redhat.com>

	* i387-tdep.c (i387_supply_xsave): If we have an xsave buffer, and
	the register state is clear, supply explicit zero, instead of
	marking the register unavailable.
@
text
@d793 1
d811 1
a811 1
  if (regs != NULL && regclass != none)
d830 1
a830 5
     should provide the same illusion to the user.

     Note however, the case when REGS is NULL is a different case.
     That case means we do not have access to the x87 states, so we
     should mark the registers as unavailable (by supplying NULL).  */
d839 1
a839 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d847 1
a847 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d855 1
a855 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d870 1
a870 1
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
d890 1
a890 1
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
d909 1
a909 1
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
a925 6
	if (regs == NULL)
	  {
	    regcache_raw_supply (regcache, i, NULL);
	    continue;
	  }

d976 2
a977 4
    {
      p = regs == NULL ? NULL : FXSAVE_MXCSR_ADDR (regs);
      regcache_raw_supply (regcache, I387_MXCSR_REGNUM (tdep), p);
    }
@


1.72
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	PR gdb/13767

	gdb/
	* frame.c (read_frame_register_unsigned): New.
	* frame.h (read_frame_register_unsigned): Declare.
	* i387-tdep.c (print_i387_status_word): New parameter `status_p'.
	Handle it.
	(print_i387_control_word): New parameter `control_p'.  Handle it.
	(i387_print_float_info): Handle unavailable float registers.

	gdb/testsuite/
	* gdb.trace/unavailable.exp (gdb_unavailable_floats): New.
	(gdb_collect_globals_test): Call it.
@
text
@d782 1
d822 13
d842 1
a842 1
	p = NULL;
d844 2
a845 2
	p = XSAVE_AVXH_ADDR (tdep, regs, regnum);
      regcache_raw_supply (regcache, regnum, p);
d850 1
a850 1
	p = NULL;
d852 2
a853 2
	p = FXSAVE_ADDR (tdep, regs, regnum);
      regcache_raw_supply (regcache, regnum, p);
d858 1
a858 1
	p = NULL;
d860 2
a861 2
	p = FXSAVE_ADDR (tdep, regs, regnum);
      regcache_raw_supply (regcache, regnum, p);
d869 6
a874 1
	    p = NULL;
a875 4
	    p = regs;

	  for (i = I387_YMM0H_REGNUM (tdep);
	       i < I387_YMMENDH_REGNUM (tdep); i++)
d877 5
a881 3
	      if (p != NULL)
		p = XSAVE_AVXH_ADDR (tdep, regs, i);
	      regcache_raw_supply (regcache, i, p);
d889 6
a894 1
	    p = NULL;
a895 4
	    p = regs;

	  for (i = I387_XMM0_REGNUM (tdep);
	       i < I387_MXCSR_REGNUM (tdep); i++)
d897 4
a900 3
	      if (p != NULL)
		p = FXSAVE_ADDR (tdep, regs, i);
	      regcache_raw_supply (regcache, i, p);
d908 6
a913 1
	    p = NULL;
a914 4
	    p = regs;

	  for (i = I387_ST0_REGNUM (tdep);
	       i < I387_FCTRL_REGNUM (tdep); i++)
d916 4
a919 3
	      if (p != NULL)
		p = FXSAVE_ADDR (tdep, regs, i);
	      regcache_raw_supply (regcache, i, p);
@


1.71
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d116 2
a117 1
/* Print the status word STATUS.  */
d120 2
a121 1
print_i387_status_word (unsigned int status, struct ui_file *file)
d123 8
a130 2
  fprintf_filtered (file, "Status Word:         %s",
		    hex_string_custom (status, 4));
d154 2
a155 1
/* Print the control word CONTROL.  */
d158 2
a159 1
print_i387_control_word (unsigned int control, struct ui_file *file)
d161 8
a168 2
  fprintf_filtered (file, "Control Word:        %s",
		    hex_string_custom (control, 4));
d224 1
d226 1
d228 1
d230 1
d232 1
d234 1
d236 1
d238 1
d240 1
d242 1
d246 20
a265 8
  fctrl = get_frame_register_unsigned (frame, I387_FCTRL_REGNUM (tdep));
  fstat = get_frame_register_unsigned (frame, I387_FSTAT_REGNUM (tdep));
  ftag = get_frame_register_unsigned (frame, I387_FTAG_REGNUM (tdep));
  fiseg = get_frame_register_unsigned (frame, I387_FISEG_REGNUM (tdep));
  fioff = get_frame_register_unsigned (frame, I387_FIOFF_REGNUM (tdep));
  foseg = get_frame_register_unsigned (frame, I387_FOSEG_REGNUM (tdep));
  fooff = get_frame_register_unsigned (frame, I387_FOOFF_REGNUM (tdep));
  fop = get_frame_register_unsigned (frame, I387_FOP_REGNUM (tdep));
d267 12
a278 1
  top = ((fstat >> 11) & 7);
d280 18
a297 5
  for (fpreg = 7; fpreg >= 0; fpreg--)
    {
      gdb_byte raw[I386_MAX_REGISTER_SIZE];
      int tag = (ftag >> (fpreg * 2)) & 3;
      int i;
d299 2
a300 1
      fprintf_filtered (file, "%sR%d: ", fpreg == top ? "=>" : "  ", fpreg);
d302 3
a304 15
      switch (tag)
	{
	case 0:
	  fputs_filtered ("Valid   ", file);
	  break;
	case 1:
	  fputs_filtered ("Zero    ", file);
	  break;
	case 2:
	  fputs_filtered ("Special ", file);
	  break;
	case 3:
	  fputs_filtered ("Empty   ", file);
	  break;
	}
d306 3
a308 7
      get_frame_register (frame,
			  (fpreg + 8 - top) % 8 + I387_ST0_REGNUM (tdep),
			  raw);

      fputs_filtered ("0x", file);
      for (i = 9; i >= 0; i--)
	fprintf_filtered (file, "%02x", raw[i]);
d310 5
a314 2
      if (tag != 3)
	print_i387_ext (gdbarch, raw, file);
d316 2
a317 1
      fputs_filtered ("\n", file);
d321 2
a322 3

  print_i387_status_word (fstat, file);
  print_i387_control_word (fctrl, file);
d324 1
a324 1
		    hex_string_custom (ftag, 4));
d326 3
a328 2
		    hex_string_custom (fiseg, 2));
  fprintf_filtered (file, "%s\n", hex_string_custom (fioff, 8));
d330 3
a332 2
		    hex_string_custom (foseg, 2));
  fprintf_filtered (file, "%s\n", hex_string_custom (fooff, 8));
d334 3
a336 1
		    hex_string_custom (fop ? (fop | 0xd800) : 0, 4));
@


1.70
log
@	* regcache.c (struct regcache_descr): Fix typo.
	* i387-tdep.c (i387_supply_xsave): Fix typo.
@
text
@d3 2
a4 3
   Copyright (C) 1988, 1989, 1991, 1992, 1993, 1994, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.70.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 2
   Copyright (C) 1988-1989, 1991-1994, 1998-2005, 2007-2012 Free
   Software Foundation, Inc.
@


1.70.2.2
log
@2012-03-06  Pedro Alves  <palves@@redhat.com>

	PR gdb/13766

	* i387-tdep.c (i387_supply_xsave): If we have an xsave buffer, and
	the register state is clear, supply explicit zero, instead of
	marking the register unavailable.
@
text
@a727 1
  static const gdb_byte zero[MAX_REGISTER_SIZE] = { 0 };
a766 13
  /* With the delayed xsave mechanism, in between the program
     starting, and the program accessing the vector registers for the
     first time, the register's values are invalid.  The kernel
     initializes register states to zero when they are set the first
     time in a program.  This means that from the user-space programs'
     perspective, it's the same as if the registers have always been
     zero from the start of the program.  Therefore, the debugger
     should provide the same illusion to the user.

     Note however, the case when REGS is NULL is a different case.
     That case means we do not have access to the x87 states, so we
     should mark the registers as unavailable (by supplying NULL).  */

d774 1
a774 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d776 2
a777 2
	regcache_raw_supply (regcache, regnum,
			     XSAVE_AVXH_ADDR (tdep, regs, regnum));
d782 1
a782 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d784 2
a785 2
	regcache_raw_supply (regcache, regnum,
			     FXSAVE_ADDR (tdep, regs, regnum));
d790 1
a790 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d792 2
a793 2
	regcache_raw_supply (regcache, regnum,
			     FXSAVE_ADDR (tdep, regs, regnum));
d801 1
a801 6
	    {
	      for (i = I387_YMM0H_REGNUM (tdep);
		   i < I387_YMMENDH_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
	    }
d803 4
d808 3
a810 5
	      for (i = I387_YMM0H_REGNUM (tdep);
		   i < I387_YMMENDH_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i,
				     XSAVE_AVXH_ADDR (tdep, regs, i));
d818 1
a818 6
	    {
	      for (i = I387_XMM0_REGNUM (tdep);
		   i < I387_MXCSR_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
	    }
d820 4
d825 3
a827 4
	      for (i = I387_XMM0_REGNUM (tdep);
		   i < I387_MXCSR_REGNUM (tdep); i++)
		regcache_raw_supply (regcache, i,
				     FXSAVE_ADDR (tdep, regs, i));
d835 1
a835 6
	    {
	      for (i = I387_ST0_REGNUM (tdep);
		   i < I387_FCTRL_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
	    }
d837 4
d842 3
a844 4
	      for (i = I387_ST0_REGNUM (tdep);
		   i < I387_FCTRL_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, FXSAVE_ADDR (tdep, regs, i));
@


1.69
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d798 1
a798 1
      /* Hanle the upper YMM registers.  */
@


1.69.2.1
log
@2012-03-06  Pedro Alves  <palves@@redhat.com>

	PR gdb/13766

	* i387-tdep.c (i387_supply_xsave): If we have an xsave buffer, and
	the register state is clear, supply explicit zero, instead of
	marking the register unavailable.
@
text
@a728 1
  static const gdb_byte zero[MAX_REGISTER_SIZE] = { 0 };
a767 13
  /* With the delayed xsave mechanism, in between the program
     starting, and the program accessing the vector registers for the
     first time, the register's values are invalid.  The kernel
     initializes register states to zero when they are set the first
     time in a program.  This means that from the user-space programs'
     perspective, it's the same as if the registers have always been
     zero from the start of the program.  Therefore, the debugger
     should provide the same illusion to the user.

     Note however, the case when REGS is NULL is a different case.
     That case means we do not have access to the x87 states, so we
     should mark the registers as unavailable (by supplying NULL).  */

d775 1
a775 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d777 2
a778 2
	regcache_raw_supply (regcache, regnum,
			     XSAVE_AVXH_ADDR (tdep, regs, regnum));
d783 1
a783 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d785 2
a786 2
	regcache_raw_supply (regcache, regnum,
			     FXSAVE_ADDR (tdep, regs, regnum));
d791 1
a791 1
	regcache_raw_supply (regcache, regnum, regs == NULL ? NULL : zero);
d793 2
a794 2
	regcache_raw_supply (regcache, regnum,
			     FXSAVE_ADDR (tdep, regs, regnum));
d802 1
a802 6
	    {
	      for (i = I387_YMM0H_REGNUM (tdep);
		   i < I387_YMMENDH_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
	    }
d804 4
d809 3
a811 5
	      for (i = I387_YMM0H_REGNUM (tdep);
		   i < I387_YMMENDH_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i,
				     XSAVE_AVXH_ADDR (tdep, regs, i));
d819 1
a819 6
	    {
	      for (i = I387_XMM0_REGNUM (tdep);
		   i < I387_MXCSR_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
	    }
d821 4
d826 3
a828 4
	      for (i = I387_XMM0_REGNUM (tdep);
		   i < I387_MXCSR_REGNUM (tdep); i++)
		regcache_raw_supply (regcache, i,
				     FXSAVE_ADDR (tdep, regs, i));
d836 1
a836 6
	    {
	      for (i = I387_ST0_REGNUM (tdep);
		   i < I387_FCTRL_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, regs == NULL ? NULL : zero);
	    }
d838 4
d843 3
a845 4
	      for (i = I387_ST0_REGNUM (tdep);
		   i < I387_FCTRL_REGNUM (tdep);
		   i++)
		regcache_raw_supply (regcache, i, FXSAVE_ADDR (tdep, regs, i));
@


1.68
log
@2011-02-26  Michael Snyder  <msnyder@@vmware.com>

	* i387-tdep.c (i387_supply_fxsave): Avoid shadowing a function
	param with a local variable of the same name.
@
text
@d310 1
a310 1
void
d312 2
a313 1
			struct type *type, gdb_byte *to)
d325 2
a326 1
      return;
d330 4
a333 1
  get_frame_register (frame, regnum, from);
d335 2
@


1.67
log
@2011-02-26  Michael Snyder  <msnyder@@vmware.com>

	* i387-tdep.c (i387_supply_xsave): Avoid shadowing a function
	param with a local variable of the same name.
@
text
@d590 3
a592 3
			int regnum = (fpreg + 8 - top) % 8 
				       + I387_ST0_REGNUM (tdep);
			tag = i387_tag (FXSAVE_ADDR (tdep, regs, regnum));
@


1.66
log
@2011-01-08  Michael Snyder  <msnyder@@vmware.com>

	* h8300-tdep.c: Comment cleanup, mostly periods and spaces.
	* hppa-hpux-tdep.c: Ditto.
	* hppa-linux-nat.c: Ditto.
	* hppa-linux-tdep.c: Ditto.
	* hppanbsd-tdep.c: Ditto.
	* hppa-tdep.c: Ditto.
	* hppa-tdep.h: Ditto.
	* hpux-thread.c: Ditto.
	* i386-cygwin-tdep.c: Ditto.
	* i386-darwin-nat.c: Ditto.
	* i386gnu-nat.c: Ditto.
	* i386-linux-nat.c: Ditto.
	* i386-linux-tdep.c: Ditto.
	* i386-nat.c: Ditto.
	* i386-nat.h: Ditto.
	* i386nbsd-tdep.c: Ditto.
	* i386-sol2-nat.c: Ditto.
	* i386-stub.c: Ditto.
	* i386-tdep.c: Ditto.
	* i386-tdep.h: Ditto.
	* i387-tdep.c: Ditto.
	* ia64-linux-nat.c: Ditto.
	* ia64-linux-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* infcall.c: Ditto.
	* infcall.h: Ditto.
	* infcmd.c: Ditto.
	* inferior.c: Ditto.
	* inferior.h: Ditto.
	* infloop.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* interps.c: Ditto.
	* interps.h: Ditto.
	* iq2000-tdep.c: Ditto.
	* irix5-nat.c: Ditto.
	* jit.c: Ditto.
	* jit.h: Ditto.
	* jv-exp.y: Ditto.
	* jv-lang.c: Ditto.
	* jv-lang.h: Ditto.
	* jv-typeprint.c: Ditto.
	* jv-valprint.c: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* linespec.c: Ditto.
	* linux-fork.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-thread-db.c: Ditto.
	* lm32-tdep.c: Ditto.
@
text
@d885 1
a885 1
			int regnum = (fpreg + 8 - top) % 8 
d887 1
a887 1
			tag = i387_tag (FXSAVE_ADDR (tdep, regs, regnum));
@


1.65
log
@run copyright.sh for 2011.
@
text
@d256 2
a257 1
      get_frame_register (frame, (fpreg + 8 - top) % 8 + I387_ST0_REGNUM (tdep),
d291 2
a292 1
i387_convert_register_p (struct gdbarch *gdbarch, int regnum, struct type *type)
d962 1
a962 1
      /* The supported bits in `xstat_bv' are 1 byte. */
@


1.64
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* i386-tdep.c (i386_supply_xstateregset) Delete unused variable.
	(i386_collect_xstateregset): Delete unused variable.
	* i387-tdep.c (i387_print_float_info): Delete unused variable.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
@


1.63
log
@Replace abort with internal_error.

2010-04-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* i387-tdep.c (i387_collect_xsave): Replace abort with
	internal_error.
@
text
@a207 1
  gdb_byte buf[4];
@


1.62
log
@Re-indent i387_collect_xsave.
@
text
@d1036 2
a1037 1
	      abort ();
d1081 2
a1082 1
	      abort ();
@


1.61
log
@Support i387 AVX.

2010-04-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* i387-tdep.c: Include "i386-xstate.h".
	(XSAVE_XSTATE_BV_ADDR): New.
	(xsave_avxh_offset): Likewise.
	(XSAVE_AVXH_ADDR): Likewise.
	(i387_supply_xsave): Likewise.
	(i387_collect_xsave): Likewise.

	* i387-tdep.h (I387_NUM_YMM_REGS): New.
	(I387_YMM0H_REGNUM): Likewise.
	(I387_YMMENDH_REGNUM): Likewise.
	(i387_supply_xsave): Likewise.
	(i387_collect_xsave): Likewise.
@
text
@d1036 1
a1036 1
		  abort ();
d1038 7
a1044 29
		case avxh:
		  /* This is an upper YMM register.  */
		  p = XSAVE_AVXH_ADDR (tdep, regs, regnum);
		  if (memcmp (raw, p, 16))
		    {
		      xstate_bv |= I386_XSTATE_AVX;
		      memcpy (p, raw, 16);
		    }
		  break;

		case sse:
		  /* This is an SSE register.  */
		  p = FXSAVE_ADDR (tdep, regs, regnum);
		  if (memcmp (raw, p, 16))
		    {
		      xstate_bv |= I386_XSTATE_SSE;
		      memcpy (p, raw, 16);
		    }
		  break;

		case x87:
		  /* This is an x87 register.  */
		  p = FXSAVE_ADDR (tdep, regs, regnum);
		  if (memcmp (raw, p, 10))
		    {
		      xstate_bv |= I386_XSTATE_X87;
		      memcpy (p, raw, 10);
		    }
		  break;
d1046 1
a1046 1
	    }
d1048 9
a1056 6
	  /* Update the corresponding bits in `xstate_bv' if any SSE/AVX
	     registers are changed.  */
	  if (xstate_bv)
	    {
	      /* The supported bits in `xstat_bv' are 1 byte.  */
	      *xstate_bv_p |= (gdb_byte) xstate_bv;
d1058 4
a1061 1
	      switch (regclass)
d1063 6
a1068 2
		default:
		  abort ();
d1070 6
a1075 2
		case all:
		  break;
d1077 1
a1077 8
		case x87:
		case sse:
		case avxh:
		  /* Register REGNUM has been updated.  Return.  */
		  return;
		}
	    }
	  else
d1079 11
a1089 3
	      /* Return if REGNUM isn't changed.  */
	      if (regclass != all)
		return;
d1091 7
d1116 1
a1116 1
                   don't touch the other bits.  */
@


1.60
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d37 1
d681 469
@


1.59
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d4 2
a5 1
   2002, 2003, 2004, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.58
log
@	* gdbtypes.h (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(init_float_type, init_complex_type): Add prototypes.
	* gdbtypes.c (builtin_type_ieee_single, builtin_type_ieee_double,
	builtin_type_i387_ext, builtin_type_m68881_ext, builtin_type_arm_ext,
	builtin_type_ia64_spill, builtin_type_ia64_quad): Remove.
	(_initialize_gdbtypes): Do not initialize them.
	(build_flt): Rename to ...
	(init_float_type): ... this.  Make global.
	(build_complex): Rename to ...
	(init_complex_type): ... this.  Make global.  Remove BIT argument.
	(gdbtypes_post_init): Update calls.

	* ada-lang.c (ada_language_arch_info): Use init_float_type.
	* jv-lang.c (build_java_types): Likewise.
	* m2-lang.c (build_m2_types): Likewise.
	* f-lang.c (build_fortran_types): Use init_float_type and
	init_complex_type.

	* target-descriptions.c (tdesc_gdb_type): Call init_float_type instead
	of using builtin_type_ieee_single, builtin_type_ieee_double, or
	builtin_type_arm_ext.

	* ia64-tdep.h (struct gdbarch_tdep): Add ia64_ext_type member.
	* ia64-tdep.c (builtin_type_ia64_ext): Remove.
	(_initialize_ia64_tdep): Do not initialize it.
	(floatformat_valid, floatformat_ia64_ext, floatformats_ia64_ext):
	Move up.
	(ia64_ext_type): New function.
	(ia64_register_reggroup_p, ia64_convert_register_p,
	ia64_register_to_value, ia64_value_to_register,
	ia64_extract_return_value, ia64_store_return_value): Use ia64_ext_type
	instead of builtin_type_ia64_ext.

	* i386-tdep.h (struct gdbarch_tdep): Add i387_ext_type member.
	(i387_ext_type): Add prototype.
	* i386-tdep.c (i387_ext_type): New function.
	(i386_extract_return_value, i386_store_return_value,
	i386_register_type): Use it instead of builtin_type_i387_ext.
	* amd64-tdep.c (amd64_register_type): Likewise.
	* i387-tdep.c (print_i387_value, i387_register_to_value,
	i387_value_to_register): Likewise.
	(print_i387_value, print_i387_ext): Add GDBARCH argument.
	(print_i387_ext, i387_print_float_info): Pass to subroutines.

	* m68k-tdep.h (struct gdbarch_tdep): Add m68881_ext_type member.
	* m68k-tdep.c (m68881_ext_type): New function.
	(m68k_register_type, m68k_convert_register_p): Use it instead
	of builtin_type_m68881_ext.

	* arm-tdep.h (struct gdbarch_tdep): Add arm_ext_type member.
	* arm-tdep.c (arm_ext_type): New function.
	(arm_register_type): Use it instead of builtin_type_arm_ext.

	* alpha-tdep.c (alpha_register_type): Use builtin types
	instead of builtin_type_ieee_double.

	* mips-tdep.c (mips_float_register_type, mips_double_register_type):
	Remove.
	(mips_register_type): Use builtin types instead of
	builtin_type_ieee_single and builtin_type_ieee_double.
	(mips_print_fp_register): Use builtin types instead of
	mips_float_register_type and mips_double_register_type.

	* hppa-tdep.c (hppa32_register_type, hppa64_register_type):
	Use builtin types instead of builtin_type_ieee_single and
	builtin_type_ieee_double.
@
text
@d392 3
a394 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
d434 1
a434 1
      store_unsigned_integer (buf, 4, 0x1f80);
@


1.57
log
@        Updated copyright notices for most files.
@
text
@d40 2
a41 1
print_i387_value (const gdb_byte *raw, struct ui_file *file)
d49 1
a49 1
  value = extract_typed_floating (raw, builtin_type_i387_ext);
d65 2
a66 1
print_i387_ext (const gdb_byte *raw, struct ui_file *file)
d97 1
a97 1
    print_i387_value (raw, file);
d101 1
a101 1
      print_i387_value (raw, file);
d263 1
a263 1
	print_i387_ext (raw, file);
d295 1
a295 1
      if (type == builtin_type_i387_ext)
d311 1
d314 1
a314 1
  gdb_assert (i386_fp_regnum_p (get_frame_arch (frame), regnum));
d326 1
a326 1
  convert_typed_floating (from, builtin_type_i387_ext, to, type);
d336 1
d339 1
a339 1
  gdb_assert (i386_fp_regnum_p (get_frame_arch (frame), regnum));
d350 1
a350 1
  convert_typed_floating (from, type, to, builtin_type_i387_ext);
@


1.56
log
@
	* win32-nat.c (do_win32_fetch_inferior_registers): Use get_regcache_arch
	to get at the current architecture and at the target specific vector.
	Add target specific vector to I387_FISEG_REGNUM and I387_FOP_REGNUM and
	remove define of I387_ST0_REGNUM.

	* amd64-tdep.c (I387_ST0_REGNUM): Remove define.

	(amd64_supply_fxsave, amd64_collect_fxsave): Use get_regcache_arch to
	get at the current architecture
	(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Add target specific vector as
	parameter.

	* i386-tdep.c: Remove various define's and undef's of I387_ST0_REGNUM,
	I387_NUM_XMM_REGS and I387_MM0_REGNUM.

	(I387_NUM_XMM_REGS, I387_XMM0_REGNUM, I387_MXCSR_REGNUM,
	I387_ST0_REGNUM, I387_FCTRL_REGNUM, I387_MM0_REGNUM,
	(I387_FSTAT_REGNUM): Add target specific vector as parameter.

	(i386_register_name, i386_dbx_reg_to_regnum): Use gdbarch_tdep to get
	at the target specific vector.

	(i386_get_longjmp_target): Use get_frame_arch to get at the current
	architecture. Use gdbarch_tdep to get at the target specific vector.

	(i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as parameter and
	update caller. Use gdbarch_tdep to get at the target specific vector.

	(i386_register_to_value: Use get_frame_arch to get at the current
	architecture.

	* i386-tdep.h (i386_fp_regnum_p, i386_fpc_regnum_p): Add gdbarch as
	parameter.

	* i387-tdep.c (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_ST0_REGNUM, FSAVE_ADDR,
	FXSAVE_ADDR, I387_XMM0_REGNUM): Add target specific vector as parameter.

	(I387_ST0_REGNUM, I387_NUM_XMM_REGS): Remove various define's and
	undef's.

	(i387_convert_register_p, i387_register_to_value,
	i387_value_to_register): Update call for i386_fp_regnum_p.

	* i387-tdep.h: Remove comment.
	(I387_ST0_REGNUM, I387_NUM_XMM_REGS, I387_MM0_REGNUM): Add define.
	(I387_FCTRL_REGNUM, I387_FSTAT_REGNUM, I387_FTAG_REGNUM,
	I387_FISEG_REGNUM, I387_FIOFF_REGNUM, I387_FOSEG_REGNUM,
	I387_FOOFF_REGNUM, I387_FOP_REGNUM, I387_XMM0_REGNUM,
	I387_MXCSR_REGNUM): Add target specific vector as parameter.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.55
log
@	Updated copyright notices for most files.
@
text
@d218 8
a225 12
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for FRAME's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  fctrl = get_frame_register_unsigned (frame, I387_FCTRL_REGNUM);
  fstat = get_frame_register_unsigned (frame, I387_FSTAT_REGNUM);
  ftag = get_frame_register_unsigned (frame, I387_FTAG_REGNUM);
  fiseg = get_frame_register_unsigned (frame, I387_FISEG_REGNUM);
  fioff = get_frame_register_unsigned (frame, I387_FIOFF_REGNUM);
  foseg = get_frame_register_unsigned (frame, I387_FOSEG_REGNUM);
  fooff = get_frame_register_unsigned (frame, I387_FOOFF_REGNUM);
  fop = get_frame_register_unsigned (frame, I387_FOP_REGNUM);
d253 2
a254 1
      get_frame_register (frame, (fpreg + 8 - top) % 8 + I387_ST0_REGNUM, raw);
a279 2

#undef I387_ST0_REGNUM
d289 1
a289 1
  if (i386_fp_regnum_p (regnum))
d311 1
a311 1
  gdb_assert (i386_fp_regnum_p (regnum));
d335 1
a335 1
  gdb_assert (i386_fp_regnum_p (regnum));
d377 2
a378 2
#define FSAVE_ADDR(fsave, regnum) \
  (fsave + fsave_offset[regnum - I387_ST0_REGNUM])
d394 1
a394 7
  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */

#define I387_ST0_REGNUM tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  for (i = I387_ST0_REGNUM; i < I387_XMM0_REGNUM; i++)
d405 2
a406 2
	if (i >= I387_FCTRL_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d410 1
a410 1
	    memcpy (val, FSAVE_ADDR (regs, i), 2);
d412 1
a412 1
	    if (i == I387_FOP_REGNUM)
d417 1
a417 1
	  regcache_raw_supply (regcache, i, FSAVE_ADDR (regs, i));
d421 1
a421 1
  for (i = I387_XMM0_REGNUM; i < I387_MXCSR_REGNUM; i++)
d424 1
a424 1
  if (regnum == -1 || regnum == I387_MXCSR_REGNUM)
d429 1
a429 1
      regcache_raw_supply (regcache, I387_MXCSR_REGNUM, buf);
a430 3

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d447 1
a447 5
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  for (i = I387_ST0_REGNUM; i < I387_XMM0_REGNUM; i++)
d452 2
a453 2
	if (i >= I387_FCTRL_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d459 1
a459 1
	    if (i == I387_FOP_REGNUM)
d464 1
a464 1
		buf[1] |= ((FSAVE_ADDR (regs, i))[1] & ~((1 << 3) - 1));
d466 1
a466 1
	    memcpy (FSAVE_ADDR (regs, i), buf, 2);
d469 1
a469 1
	  regcache_raw_collect (regcache, i, FSAVE_ADDR (regs, i));
a470 1
#undef I387_ST0_REGNUM
d514 2
a515 2
#define FXSAVE_ADDR(fxsave, regnum) \
  (fxsave + fxsave_offset[regnum - I387_ST0_REGNUM])
d541 1
a541 7
  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */

#define I387_ST0_REGNUM	tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  for (i = I387_ST0_REGNUM; i < I387_MXCSR_REGNUM; i++)
d552 2
a553 2
	if (i >= I387_FCTRL_REGNUM && i < I387_XMM0_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d557 1
a557 1
	    memcpy (val, FXSAVE_ADDR (regs, i), 2);
d559 1
a559 1
	    if (i == I387_FOP_REGNUM)
d561 1
a561 1
	    else if (i== I387_FTAG_REGNUM)
d571 2
a572 1
		top = ((FXSAVE_ADDR (regs, I387_FSTAT_REGNUM))[1] >> 3);
d581 3
a583 2
			int regnum = (fpreg + 8 - top) % 8 + I387_ST0_REGNUM;
			tag = i387_tag (FXSAVE_ADDR (regs, regnum));
d596 1
a596 1
	  regcache_raw_supply (regcache, i, FXSAVE_ADDR (regs, i));
d599 1
a599 1
  if (regnum == I387_MXCSR_REGNUM || regnum == -1)
d602 1
a602 1
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM, NULL);
d604 1
a604 1
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM,
a606 3

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d624 1
a624 7
  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */

#define I387_ST0_REGNUM	tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  for (i = I387_ST0_REGNUM; i < I387_MXCSR_REGNUM; i++)
d629 2
a630 2
	if (i >= I387_FCTRL_REGNUM && i < I387_XMM0_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d636 1
a636 1
	    if (i == I387_FOP_REGNUM)
d641 1
a641 1
		buf[1] |= ((FXSAVE_ADDR (regs, i))[1] & ~((1 << 3) - 1));
d643 1
a643 1
	    else if (i == I387_FTAG_REGNUM)
d662 1
a662 1
	    memcpy (FXSAVE_ADDR (regs, i), buf, 2);
d665 1
a665 1
	  regcache_raw_collect (regcache, i, FXSAVE_ADDR (regs, i));
d668 2
a669 2
  if (regnum == I387_MXCSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, I387_MXCSR_REGNUM,
a670 3

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
a729 4
  /* Define I387_ST0_REGNUM such that we use the proper
     definitions for the architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

d734 1
a734 1
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
d736 1
a736 1
  regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM, fstat);
d741 1
a741 1
  regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM, 0x3fff);
a742 1
#undef I387_ST0_REGNUM
@


1.54
log
@	* gdbarch.sh (convert_register_p): Add gdbarch as parameter.
	* ia64-tdep.c (ia64_convert_register_p): Likewise.
	* i387-tdep.c (i387_convert_register_p): Likewise.
	* i387-tdep.h (i387_convert_register_p): Likewise.
	* alpha-tdep.c (alpha_convert_register_p): Likewise.
	* gdbarch.{c,h}: Regenerate.

	* rs6000-tdep.c (rs6000_convert_register_p): Add gdbarch as parameter.
	Replace current_gdbarch by gdbarch.
	* mips-tdep.c (mips_convert_register_p): Likewise.
	* m68k-tdep.c (m68k_convert_register_p): Likewise.
	* i386-tdep.c (i386_convert_register_p): Likewise.
@
text
@d4 1
a4 1
   2002, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.53
log
@	* amd64-tdep.c (amd64_convert_register_p): Delete.
	(amd64_init_abi): Use i387_convert_register_p.
	* alpha-tdep.c (alpha_convert_register_p): Return zero for
	eight byte types.
	(alpha_register_to_value, alpha_value_to_register): Do not handle
	eight byte types.
	* i386-tdep.c (i386_convert_register_p): Use i387_convert_register_p.
	* i387-tdep.c (i387_convert_register_p): New.
	(i387_register_to_value, i387_value_to_register): Update comments.
	* i387-tdep.h (i387_convert_register_p): Declare.
	* ia64-tdep.c (ia64_convert_register_p): Return zero for
	builtin_type_ia64_ext.
	(ia64_gdbarch_init): Do not initialize builtin_type_ia64_ext here.
	(_initialize_ia64_tdep): Initialize builtin_type_ia64_ext here.
	* m68k-tdep.c (m68k_convert_register_p): Return zero for
	builtin_type_m68881_ext.
	(m68k_register_to_value, m68k_value_to_register): Update comments.

	* gdbint.texinfo (Register and Memory Data, Target Conditionals):
	Document that gdbarch_convert_register_p should return zero for no-op
	conversions.
@
text
@d292 1
a292 1
i387_convert_register_p (int regnum, struct type *type)
@


1.52
log
@2007-10-22  Markus Deuling  <deuling@@de.ibm.com>

	* i387-tdep.c (i387_collect_fsave, i387_collect_fxsave): Use
	get_regcache_arch to get at the current architecture by regcache.
@
text
@d288 19
d326 1
a326 2
  /* Convert to TYPE.  This should be a no-op if TYPE is equivalent to
     the extended floating-point format used by the FPU.  */
d350 1
a350 2
  /* Convert from TYPE.  This should be a no-op if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
@


1.51
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d438 1
a438 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d626 1
a626 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.50
log
@	* i387-tdep.c (i387_fill_fsave, i387_fill_fxsave): Remove.
	* i387-tdep.h (i387_fill_fsave, i387_fill_fxsave): Remove prototypes.
	* i368-linux-nat.c (supply_fpregset, supply_fpxregset): Replace
	i387_fill_fsave and i387_fill_fxsave calls by inline copies.
	* i386-nto-tdep.c (i386nto_regset_fill): Likewise.
	* i386gnu-nat.c (store_fpregs): Likewise.
	* i386v4-nat.c (fill_fpregset): Likewise.
	* go32-nat.c (store_register, go32_store_registers): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d19 1
a19 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.49
log
@Copyright updates for 2007.
@
text
@a475 11

/* Fill register REGNUM (if it is a floating-point register) in *FSAVE
   with the value in GDB's register cache.  If REGNUM is -1, do this
   for all registers.  This function doesn't touch any of the reserved
   bits in *FSAVE.  */

void
i387_fill_fsave (void *fsave, int regnum)
{
  i387_collect_fsave (current_regcache, regnum, fsave);
}
a692 11
/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */

void
i387_fill_fxsave (void *fxsave, int regnum)
{
  i387_collect_fxsave (current_regcache, regnum, fxsave);
}

@


1.48
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d3 2
a4 2
   Copyright (C) 1988, 1989, 1991, 1992, 1993, 1994, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
@


1.47
log
@* i387-tdep.c (print_i387_value, print_i387_ext, i387_tag): Change
type of first argument to `const gdb_byte *'.
(i387_print_float_info, i387_register_to_value)
(i387_value_to_register, i387_supply_fsave, i387_collect_fsave)
(i387_supply_fxsave, i387_collect_fxsave): Use gdb_byte for byte
buffers.
@
text
@d3 1
a3 1
   Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1998, 1999, 2000,
d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.46
log
@* amd64-tdep.c (amd64_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.  Remove now redundant casts.
* i386-tdep.c (i386_return_value): Change type of readbuf and
writebuf arguments to `gdb_byte *'.
(i386_pseudo_register_read, i386_pseudo_register_write): Change
type of last argument to `gdb_byte *'.
(i386_register_to_value, i386_value_to_register): Change type of
last argument to `gdb_byte *'.  Simplify function a bit.
* i387-tdep.h (i387_value_to_register, i387_register_to_value):
Change type of last argument to `gdb_byte *'.
* i387-tdep.c: Likewise.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d42 1
a42 1
print_i387_value (char *raw, struct ui_file *file)
d66 1
a66 1
print_i387_ext (unsigned char *raw, struct ui_file *file)
d206 1
a206 1
  char buf[4];
d237 1
a237 1
      unsigned char raw[I386_MAX_REGISTER_SIZE];
d297 1
a297 1
  char from[I386_MAX_REGISTER_SIZE];
d322 1
a322 1
  char to[I386_MAX_REGISTER_SIZE];
d379 1
a379 1
  const char *regs = fsave;
d404 1
a404 1
	    unsigned char val[4];
d422 1
a422 1
      char buf[4];
d441 1
a441 1
  char *regs = fsave;
d458 1
a458 1
	    unsigned char buf[4];
d539 1
a539 1
static int i387_tag (const unsigned char *raw);
d550 1
a550 1
  const char *regs = fxsave;
d576 1
a576 1
	    unsigned char val[4];
d640 1
a640 1
  char *regs = fxsave;
d660 1
a660 1
	    unsigned char buf[4];
d719 1
a719 1
i387_tag (const unsigned char *raw)
@


1.45
log
@* i387-tdep.c: Remove outdated comments.
@
text
@d295 1
a295 1
			struct type *type, void *to)
d320 1
a320 1
			struct type *type, const void *from)
@


1.44
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@a38 3
/* Implement the `info float' layout based on the register definitions
   in `tm-i386.h'.  */

a342 6
/* FIXME: kettenis/20030927: The functions below should accept a
   `regcache' argument, but I don't want to change the function
   signature just yet.  There's some band-aid in the functions below
   in the form of the `regcache' local variables.  This will ease the
   transition later on.  */

@


1.43
log
@* language.c (local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string, use C format, and move to
utils.c
(local_hex_string_custom): Rename to hex_string_custom and change
interface.  Now uses C format.  Move to utils.c
(local_octal_format_custom): Remove.
(local_decimal_format_custom): Remove.
(unknown_language_defn): Remove language-specific number
formatting entries.
(auto_language_defn): Ditto.
(local_language_defn): Ditto.
* language.h (struct language_format_info): Delete declaration.
(struct language_defn): Remove language_format_info fields
la_binary_format, la_octal_format, la_decimal_format, la_hex_format.
(local_binary_format): Remove macro.
(local_binary_format_prefix): Remove macro.
(local_binary_format_specifier): Remove macro.
(local_binary_format_suffix): Remove macro.
(local_octal_format): Remove macro.
(local_octal_format_prefix): Remove macro.
(local_octal_format_specifier): Remove macro.
(local_octal_format_suffix): Remove macro.
(local_decimal_format): Remove macro.
(local_decimal_format_prefix): Remove macro.
(local_decimal_format_specifier): Remove macro.
(local_decimal_format_suffix): Remove macro.
(local_hex_format): Remove macro.
(local_hex_format_prefix): Remove macro.
(local_hex_format_specifier): Remove macro.
(local_hex_format_suffix): Remove macro.
(local_decimal_format_custom): Remove.
(local_octal_format_custom): Remove.
(local_hex_format_custom): Remove.
(local_hex_string): Rename to hex_string and move to defs.h.
(local_hex_string_custom): Rename to hex_string_custom, change
interface, and move to defs.h.
* utils.c: (int_string): New function.
(hex_string): New function (from language.c).
(hex_string_custom): New function (from language.c).
(octal2str): New function.
(decimal2str): Add width parameter.
(paddr_u): Use new decimal2str interface.
(paddr_d): Ditto.
* defs.h (hex_string): Declare.
(hex_string_custom): Declare.
(int_string): Declare.
* printcmd.c (print_scalar_formatted): Remove localized binary
formatting.
* valprint.c (print_longest): Use int_string.
(print_floating): Use C hex format.
(print_hex_chars): Ditto.
(print_binary_chars): Remove language-specific formatting.
(print_octal_chars): Use C octal format.
(print_decimal_chars): Delocalize format.
(print_decimal): Remove.
* ada-lang.c (ada_language_defn): Remove language-specific number
formatting entries.
* p-lang.c (pascal_language_defn): Ditto.
* c-lang.c (c_language_defn): Ditto.
(cplus_language_defn): Ditto.
(asm_language_defn): Ditto.
(minimal_language_defn): Ditto.
* f-lang.c (f_language_defn): Ditto.
* jv-lang.c (java_language_defn): Ditto.
* m2-lang.c (m2_language_defn): Ditto.
* scm-lang.c (scm_language_defn): Ditto.
* objc-lang.c (objc_language_defn): Ditto.
* memattr.c (mem_info_command): Use renamed hex_string_custom with
new interface.
* pa64solib.c (pa64_sharedlibrary_info_command): Ditto.
* ui-out.c (ui_out_field_core_addr): Ditto.
* breakpoint.c (breakpoint_adjustment_warning): Ditto.
* exec.c (print_section_info): Ditto.
* i387-tdep.c (print_i387_status_word): Ditto.
(print_i387_control_word): Ditto.
(i387_print_float_info): Ditto.
* maint.c (maint_print_section_info): Ditto.
* solib.c (info_sharedlibrary_command): Ditto.
* somsolib.c (som_sharedlibrary_info_command): Ditto.
* symtab.c (print_msymbol_info): Ditto.
* tracepoint.c (tracepoints_info): Ditto.
* solib-frv.c (lm_base): Ditto.
(frv_current_sos): Ditto.
(enable_break2): Ditto.
(enable_break): Ditto.
* dbxread.c (read_dbx_symtab): Use renamed hex_string.
(process_one_symbol): Ditto.
* infcmd.c (program_info): Ditto.
* mdebugread.c (parse_partial_symbols): Ditto.
* symfile.c (add_symbol_file_command): Ditto.
* cli/cli-cmds.c (edit_command): Ditto.
(list_command): Ditto.
* infcall.c (call_function_by_hand): Ditto.
* remote-vx.c (vx_run_files_info): Ditto.
(vx_wait): Ditto.
(vx_attach): Ditto.
(vx_detach): Ditto.
(vx_kill): Ditto.
* aix-thread.c (pdc_symbol_addrs): Ditto.
(pdc_read_regs): Ditto.
(pdc_write_regs): Ditto.
(pdc_read_data): Ditto.
(pdc_write_data): Ditto.
* d10v-tdep.c (display_trace): Ditto.
* rs6000-nat.c (find_toc_address): Ditto.
* aix-thread.c: Don't include language.h.
* buildsym.c: Ditto.
* dbxread.c: Ditto.
* mdebugread.c: Ditto.
* rs6000-nat.c: Ditto.
* buildsym.c (make_blockvector): Use renamed hex_string.
@
text
@d307 2
a308 2
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
d332 2
a333 2
      warning ("Cannot convert non-floating-point type "
	       "to floating-point register value.");
@


1.42
log
@* i387-tdep.c (i387_supply_fsave): Provide summy values for the
SSE registers.
@
text
@d124 1
a124 1
		   local_hex_string_custom (status, "04"));
d154 1
a154 1
		   local_hex_string_custom (control, "04"));
d279 1
a279 1
		    local_hex_string_custom (ftag, "04"));
d281 2
a282 2
		    local_hex_string_custom (fiseg, "02"));
  fprintf_filtered (file, "%s\n", local_hex_string_custom (fioff, "08"));
d284 2
a285 2
		    local_hex_string_custom (foseg, "02"));
  fprintf_filtered (file, "%s\n", local_hex_string_custom (fooff, "08"));
d287 1
a287 1
		    local_hex_string_custom (fop ? (fop | 0xd800) : 0, "04"));
@


1.41
log
@* i387-tdep.c: Remove excessive whitespace.
@
text
@d393 3
a395 2
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
d397 1
d424 13
d438 1
@


1.40
log
@* i387-tdep.h (i387_collect_fsave): New prototype.
* i387-tdep.c (i387_collect_fsave): New function containing most
of the code from i387_fill_fsave.
(i387_fill_fsave): Call i387_fill_fsave.
@
text
@a342 1

@


1.39
log
@* i387-tdep.h: Update copyright year.
(i387_collect_fxsave): New prototype.
* i387-tdep.c: Update copyright year.
(i387_collect_fxsave): New function containing most of the code
from i387_fill_fxsave.
(i387_fill_fxsave): Call i387_collect_fxsave.
@
text
@d427 3
a429 3
   with the value in GDB's register cache.  If REGNUM is -1, do this
   for all registers.  This function doesn't touch any of the reserved
   bits in *FSAVE.  */
d432 1
a432 1
i387_fill_fsave (void *fsave, int regnum)
a433 1
  struct regcache *regcache = current_regcache;
d469 11
@


1.39.4.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d427 3
a429 3
   with the value from REGCACHE.  If REGNUM is -1, do this for all
   registers.  This function doesn't touch any of the reserved bits in
   *FSAVE.  */
d432 1
a432 1
i387_collect_fsave (const struct regcache *regcache, int regnum, void *fsave)
d434 1
a469 11
}

/* Fill register REGNUM (if it is a floating-point register) in *FSAVE
   with the value in GDB's register cache.  If REGNUM is -1, do this
   for all registers.  This function doesn't touch any of the reserved
   bits in *FSAVE.  */

void
i387_fill_fsave (void *fsave, int regnum)
{
  i387_collect_fsave (current_regcache, regnum, fsave);
@


1.38
log
@* x86-64-tdep.c (RET_INT_REGS, RET_SSE_REGS): Remove defines.
(x86_64_use_struct_convention, x86_64_extract_return_value,
x86_64_store_return_value): Remove.
(amd64_reg_class): New enum.
(amd64_merge_classes, amd64_classify_aggregate, amd64_classify,
amd64_return_value): New functions.
(x86_64_init_abi): Don't set extract_return_value,
store_return_value and use_struct_convention.  Set return_value to
amd64_return_value.
* i387-tdep.h (i387_return_value): New prototype.
* i387-tdep.c (i387_return_value): New function.
@
text
@d4 1
a4 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d616 3
a618 3
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */
d621 1
a621 1
i387_fill_fxsave (void *fxsave, int regnum)
a622 1
  struct regcache *regcache = current_regcache;
d686 11
@


1.38.6.1
log
@Merge mainline to intercu branch.
@
text
@d4 1
a4 1
   2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d427 3
a429 3
   with the value from REGCACHE.  If REGNUM is -1, do this for all
   registers.  This function doesn't touch any of the reserved bits in
   *FSAVE.  */
d432 1
a432 1
i387_collect_fsave (const struct regcache *regcache, int regnum, void *fsave)
d434 1
a470 11

/* Fill register REGNUM (if it is a floating-point register) in *FSAVE
   with the value in GDB's register cache.  If REGNUM is -1, do this
   for all registers.  This function doesn't touch any of the reserved
   bits in *FSAVE.  */

void
i387_fill_fsave (void *fsave, int regnum)
{
  i387_collect_fsave (current_regcache, regnum, fsave);
}
d616 3
a618 3
   *FXSAVE with the value from REGCACHE.  If REGNUM is -1, do this for
   all registers.  This function doesn't touch any of the reserved
   bits in *FXSAVE.  */
d621 1
a621 1
i387_collect_fxsave (const struct regcache *regcache, int regnum, void *fxsave)
d623 1
a686 11
}

/* Fill register REGNUM (if it is a floating-point or SSE register) in
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
   this for all registers.  This function doesn't touch any of the
   reserved bits in *FXSAVE.  */

void
i387_fill_fxsave (void *fxsave, int regnum)
{
  i387_collect_fxsave (current_regcache, regnum, fxsave);
@


1.38.6.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d124 1
a124 1
		    hex_string_custom (status, 4));
d154 1
a154 1
		    hex_string_custom (control, 4));
d279 1
a279 1
		    hex_string_custom (ftag, 4));
d281 2
a282 2
		    hex_string_custom (fiseg, 2));
  fprintf_filtered (file, "%s\n", hex_string_custom (fioff, 8));
d284 2
a285 2
		    hex_string_custom (foseg, 2));
  fprintf_filtered (file, "%s\n", hex_string_custom (fooff, 8));
d287 1
a287 1
		    hex_string_custom (fop ? (fop | 0xd800) : 0, 4));
d343 1
d394 2
a395 3
  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */

a396 1
#define I387_NUM_XMM_REGS tdep->num_xmm_regs
a422 13

  /* Provide dummy values for the SSE registers.  */
  for (i = I387_XMM0_REGNUM; i < I387_MXCSR_REGNUM; i++)
    if (regnum == -1 || regnum == i)
      regcache_raw_supply (regcache, i, NULL);
  if (regnum == -1 || regnum == I387_MXCSR_REGNUM)
    {
      char buf[4];

      store_unsigned_integer (buf, 4, 0x1f80);
      regcache_raw_supply (regcache, I387_MXCSR_REGNUM, buf);
    }

a423 1
#undef I387_NUM_XMM_REGS
@


1.37
log
@* i387-tdep.c (i387_supply_fsave, i387_supply_fxsave): Add
regcache argument and reverse the order of the other two
arguments.  Remove local regcache variable.  Determine
architecture from REGCACHE.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Add regcache argument and
reverse the order of the other two arguments.  Remove local
regcache variable.  Determine architecture from REGCACHE.  Update
comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fxsave): Adjust
prototypes.  Update comments.
* x86-64-tdep.c (x86_64_supply_fxsave): Adjust prototype.  Adjust
comment.
* amd64fbsd-nat.c (supply_fpregset, fetch_inferior_registers):
Update.
* go32-nat.c (fetch_register, go32_fetch_registers): Update.
* i386-interix-nat.c (supply_fpregset): Update.
* i386-linux-nat.c (supply_fpregset, supply_fpxregset): Update.
* i386-nto-tdep.c (i386nto_supply_fpregset): Update.
* i386gnu-nat.c (fetch_fpregs, supply_fpregset): Update.
* i386bsd-nat.c (supply_fpregset, fetch_inferior_registers): Update.
* i386nbsd-tdep.c (fetch_core_registers, fetch_elfcore_registers):
Update.
* i386obsd-tdep.c (fetch_core_registers): Update.
* i386v4-nat.c (supply_fpregset): Update.
* x86-64-linux-nat.c (supply_fpregset): Update.
* x86-64-linux-tdep.c (fetch_core_registers): Update.
@
text
@d737 28
@


1.36
log
@* i386-tdep.h: Put opaque declarations in alphabetical
order.  Remove spurious whitespace.
(struct gdbarch_tdep): add st0_regnum and mm0_regnum members.
(i386_sse_regnum_p, i386_mxcsr_regnum_p): Remove prototypes.
* i386-tdep.c (MM0_REGNUM): Remove define.
(i386_mmx_regnum_p): Add gdbarch argument.
(i386_sse_regnum_p, i386_mxcsr_regnum_p): Add gdbarch argument.
Rewrite using new macro definitions for FPU/SSE registers.
(i386_fp_regnum_p, i386_fpc_regnum_p): Rewrite using new macro
definitions from i387-tdep.h.
(i386_register_name): Update.
(i386_stab_reg_to_regnum, i386_dwarf_reg_to_regnum): Update to use
new macro definitions for FPU/SSE registers.
(i386_extract_return_value): Determine whether floating-point
registers are present by examining REGCACHE's architecture.
(i386_store_return_value): Likewise.  Use I386_MAX_REGISTER_SIZE
instead of FPU_REG_RAW_SIZE.  Use new macro definitions for
FPU/SSE registers.
(i386_register_type): Update.
(i386_mmx_regnum_to_fp_regnum): Rewrite using new macro
definitions for FPU registers.  Use REGCACHE's architecture to
determine the appropriate register numbers.
(i386_pseudo_register_read, i386_pseudo_register_write,
i386_register_reggroup_p): Update.
(i386_gdbarch_init): Initialize TDEP->st0_regnum and
TDEP->mm0_regnum.
* i387-tdep.h (I387_FCTRL_REGNUM, I387_FSTAT_REGNUM,
I387_FTAG_REGNUM, I387_FISEG_REGNUM, I387_FIOFF_REGNUM,
I387_FOSEG_REGNUM, I387_FOOFF_REGNUM, I387_FOP_REGNUM,
I387_XMM0_REGNUM, I387_MXCSR_REGNUM): New defines.
(i387_supply_fsave, i387_fill_fsave, i387_supply_fxsave,
i387_fill_fxsave): Change type of fsave/fxsave argument from `char
*' to `void *'.
* i387-tdep.c (i387_print_float_info, fsave_offset, FSAVE_ADDR,
i387_supply_fsave, i387_fill_fsave, fxsave_offset, FXSAVE_ADDR,
i387_supply_fxsave, i387_fill_fxsave): Update to use new macro
definitions for FPU/SSE registers.
(FXSAVE_MXCSR_ADDR): New define.
* x86-64-tdep.c (x86_64_init_abi): Override TDEP->st0_regnum and
TDEP->mm0_regnum.
(I387_FISEG_REGNUM, I387_FOSEG_REGNUM): Remove defines.
(I387_ST0_REGNUM): Define.
@
text
@d381 3
a383 3
/* Fill register REGNUM in GDB's register cache with the appropriate
   value from *FSAVE.  This function masks off any of the reserved
   bits in *FSAVE.  */
d386 1
a386 1
i387_supply_fsave (const void *fsave, int regnum)
d388 1
a388 2
  struct regcache *regcache = current_regcache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
d526 1
a526 1
/* Fill register REGNUM in GDB's register cache with the appropriate
d531 1
a531 1
i387_supply_fxsave (const void *fxsave, int regnum)
d533 1
a533 2
  struct regcache *regcache = current_regcache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
@


1.35
log
@* go32-nat.c (fetch_register): Call i387_supply_fsave instead of
i387_supply_register.
(go32_fetch_registers): Adjust call to i387_supply_fsave.
* i386nbsd-tdep.c (fetch_core_registers): Adjust call to
i387_supply_fsave.
(fetch_elfcore_registers): Adjust call to i387_supply_fsave and
i387_supply_fxsave.
* i386obsd-tdep.c (fetch_core_registers): Adjust call to
i387_supply_fsave.
* i386bsd-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
(fetch_inferior_registers): Remove extraneous whitespace.  Adjust
call to i387_supply_fxsave.  Call i387_supply_fsave instead of
supply_fpregset.
(store_inferior_registers): Remove extraneous whitespace.  Call
i387_fill_fsave instead of fill_fpregset.
* i386gnu-nat.c (fetch_fpregs): Adjust call to i387_supply_fsave.
(supply_fpregset): Likewise.
* i386v4-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
* i386-interix-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
* i386-linux-nat.c (supply_fpregset): Adjust call to
i387_supply_fsave.
(supply_fpxregset): Adjust call to i387_adjust_fxsave.
* i386-nto-tdep.c (i386nto_supply_fpregset): Adjust calls to
i387supply_fsave and i387_supply_fxsave.
* i387-tdep.c (i387_supply_fsave): Add `regnum' argument.
Incorporate code from `i387_supply_register.
(i387_supply_register): Remove.
(i387_supply_fxsave): Add `regnum' argument.
Update comments.
* i387-tdep.h (i387_supply_fsave, i387_supply_fsxave): Adjust
prototype.
(i387_supply_register): remove prototype.
Update comments.
@
text
@d208 1
d221 14
a234 8
  fctrl = get_frame_register_unsigned (frame, FCTRL_REGNUM);
  fstat = get_frame_register_unsigned (frame, FSTAT_REGNUM);
  ftag = get_frame_register_unsigned (frame, FTAG_REGNUM);
  fiseg = get_frame_register_unsigned (frame, FISEG_REGNUM);
  fioff = get_frame_register_unsigned (frame, FIOFF_REGNUM);
  foseg = get_frame_register_unsigned (frame, FOSEG_REGNUM);
  fooff = get_frame_register_unsigned (frame, FOOFF_REGNUM);
  fop = get_frame_register_unsigned (frame, FOP_REGNUM);
d240 1
a240 1
      unsigned char raw[FPU_REG_RAW_SIZE];
d262 1
a262 1
      get_frame_register (frame, (fpreg + 8 - top) % 8 + FP0_REGNUM, raw);
d288 2
d343 1
d347 6
d359 16
a374 16
  28 + 0 * FPU_REG_RAW_SIZE,	/* FP0_REGNUM through ...  */
  28 + 1 * FPU_REG_RAW_SIZE,  
  28 + 2 * FPU_REG_RAW_SIZE,  
  28 + 3 * FPU_REG_RAW_SIZE,  
  28 + 4 * FPU_REG_RAW_SIZE,  
  28 + 5 * FPU_REG_RAW_SIZE,  
  28 + 6 * FPU_REG_RAW_SIZE,  
  28 + 7 * FPU_REG_RAW_SIZE,	/* ... FP7_REGNUM.  */
  0,				/* FCTRL_REGNUM (16 bits).  */
  4,				/* FSTAT_REGNUM (16 bits).  */
  8,				/* FTAG_REGNUM (16 bits).  */
  16,				/* FISEG_REGNUM (16 bits).  */
  12,				/* FIOFF_REGNUM.  */
  24,				/* FOSEG_REGNUM.  */
  20,				/* FOOFF_REGNUM.  */
  18				/* FOP_REGNUM (bottom 11 bits).  */
d377 2
a378 1
#define FSAVE_ADDR(fsave, regnum) (fsave + fsave_offset[regnum - FP0_REGNUM])
d386 1
a386 1
i387_supply_fsave (const char *fsave, int regnum)
d388 3
d393 7
a399 1
  for (i = FP0_REGNUM; i < XMM0_REGNUM; i++)
d404 2
a405 2
	    supply_register (i, NULL);
	    return;
d410 2
a411 2
	if (i >= FPC_REGNUM
	    && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
d415 1
a415 1
	    memcpy (val, FSAVE_ADDR (fsave, i), 2);
d417 1
a417 1
	    if (i == FOP_REGNUM)
d419 1
a419 1
	    supply_register (i, val);
d422 1
a422 1
	  supply_register (i, FSAVE_ADDR (fsave, i));
d424 1
d433 1
a433 1
i387_fill_fsave (char *fsave, int regnum)
d435 3
d440 7
a446 1
  for (i = FP0_REGNUM; i < XMM0_REGNUM; i++)
d451 2
a452 2
	if (i >= FPC_REGNUM
	    && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
d456 1
a456 1
	    regcache_collect (i, buf);
d458 1
a458 1
	    if (i == FOP_REGNUM)
d463 1
a463 1
		buf[1] |= ((FSAVE_ADDR (fsave, i))[1] & ~((1 << 3) - 1));
d465 1
a465 1
	    memcpy (FSAVE_ADDR (fsave, i), buf, 2);
d468 1
a468 1
	  regcache_collect (i, FSAVE_ADDR (fsave, i));
d470 1
d480 1
a480 1
  32,				/* FP0_REGNUM through ...  */
d487 10
a496 10
  144,				/* ... FP7_REGNUM (80 bits each).  */
  0,				/* FCTRL_REGNUM (16 bits).  */
  2,				/* FSTAT_REGNUM (16 bits).  */
  4,				/* FTAG_REGNUM (16 bits).  */
  12,				/* FISEG_REGNUM (16 bits).  */
  8,				/* FIOFF_REGNUM.  */
  20,				/* FOSEG_REGNUM (16 bits).  */
  16,				/* FOOFF_REGNUM.  */
  6,				/* FOP_REGNUM (bottom 11 bits).  */
  160 + 0 * 16,			/* XMM0_REGNUM through ...  */
d511 1
a511 2
  160 + 15 * 16,		/* ... XMM15_REGNUM (128 bits each).  */
  24				/* MXCSR_REGNUM.  */
d514 7
a520 5
/* FIXME: kettenis/20030430: We made an unfortunate choice in putting
   %mxcsr after the SSE registers %xmm0-%xmm7 instead of before, since
   it makes supporting the registers %xmm8-%xmm15 on x86-64 a bit
   involved.  Hack around it by explicitly overriding the offset for
   %mxcsr here.  */
d522 1
a522 3
#define FXSAVE_ADDR(fxsave, regnum) \
  ((regnum == MXCSR_REGNUM) ? (fxsave + 24) : \
   (fxsave + fxsave_offset[regnum - FP0_REGNUM]))
d532 1
a532 1
i387_supply_fxsave (const char *fxsave, int regnum)
d534 10
a543 1
  int i, last_regnum = MXCSR_REGNUM;
d545 2
a546 2
  if (gdbarch_tdep (current_gdbarch)->num_xmm_regs == 0)
    last_regnum = FOP_REGNUM;
d548 1
a548 1
  for (i = FP0_REGNUM; i <= last_regnum; i++)
d551 1
a551 1
	if (fxsave == NULL)
d553 1
a553 1
	    supply_register (i, NULL);
d559 2
a560 2
	if (i >= FPC_REGNUM && i < XMM0_REGNUM
	    && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
d564 1
a564 1
	    memcpy (val, FXSAVE_ADDR (fxsave, i), 2);
d566 1
a566 1
	    if (i == FOP_REGNUM)
d568 1
a568 1
	    else if (i== FTAG_REGNUM)
d578 2
a579 1
		top = (((FXSAVE_ADDR (fxsave, FSTAT_REGNUM))[1] >> 3) & 0x7);
d587 2
a588 2
			int regnum = (fpreg + 8 - top) % 8 + FP0_REGNUM;
			tag = i387_tag (FXSAVE_ADDR (fxsave, regnum));
d598 1
a598 1
	    supply_register (i, val);
d601 1
a601 1
	  supply_register (i, FXSAVE_ADDR (fxsave, i));
d603 12
d623 1
a623 1
i387_fill_fxsave (char *fxsave, int regnum)
d625 7
a631 1
  int i, last_regnum = MXCSR_REGNUM;
d633 2
a634 2
  if (gdbarch_tdep (current_gdbarch)->num_xmm_regs == 0)
    last_regnum = FOP_REGNUM;
d636 4
a639 1
  for (i = FP0_REGNUM; i <= last_regnum; i++)
d644 2
a645 2
	if (i >= FPC_REGNUM && i < XMM0_REGNUM
	    && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
d649 1
a649 1
	    regcache_collect (i, buf);
d651 1
a651 1
	    if (i == FOP_REGNUM)
d656 1
a656 1
		buf[1] |= ((FXSAVE_ADDR (fxsave, i))[1] & ~((1 << 3) - 1));
d658 1
a658 1
	    else if (i == FTAG_REGNUM)
d677 1
a677 1
	    memcpy (FXSAVE_ADDR (fxsave, i), buf, 2);
d680 1
a680 1
	  regcache_collect (i, FXSAVE_ADDR (fxsave, i));
d682 7
@


1.34
log
@* i387-tdep.c (i387_register_to_value): Use get_frame_register
instead of frame_read_register.
@
text
@d364 1
a364 1
/* Fill register REGNUM in GDB's register array with the appropriate
d369 1
a369 1
i387_supply_register (int regnum, char *fsave)
d371 1
a371 22
  if (fsave == NULL)
    {
      supply_register (regnum, NULL);
      return;
    }

  /* Most of the FPU control registers occupy only 16 bits in
     the fsave area.  Give those a special treatment.  */
  if (regnum >= FPC_REGNUM
      && regnum != FIOFF_REGNUM && regnum != FOOFF_REGNUM)
    {
      unsigned char val[4];

      memcpy (val, FSAVE_ADDR (fsave, regnum), 2);
      val[2] = val[3] = 0;
      if (regnum == FOP_REGNUM)
	val[1] &= ((1 << 3) - 1);
      supply_register (regnum, val);
    }
  else
    supply_register (regnum, FSAVE_ADDR (fsave, regnum));
}
d373 8
a380 3
/* Fill GDB's register array with the floating-point register values
   in *FSAVE.  This function masks off any of the reserved
   bits in *FSAVE.  */
d382 6
a387 4
void
i387_supply_fsave (char *fsave)
{
  int i;
d389 9
a397 2
  for (i = FP0_REGNUM; i < XMM0_REGNUM; i++)
    i387_supply_register (i, fsave);
d401 1
a401 1
   with the value in GDB's register array.  If REGNUM is -1, do this
d488 1
a488 1
static int i387_tag (unsigned char *raw);
d491 3
a493 3
/* Fill GDB's register array with the floating-point and SSE register
   values in *FXSAVE.  This function masks off any of the reserved
   bits in *FXSAVE.  */
d496 1
a496 1
i387_supply_fxsave (char *fxsave)
d504 53
a556 52
    {
      if (fxsave == NULL)
	{
	  supply_register (i, NULL);
	  continue;
	}

      /* Most of the FPU control registers occupy only 16 bits in
	 the fxsave area.  Give those a special treatment.  */
      if (i >= FPC_REGNUM && i < XMM0_REGNUM
	  && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
	{
	  unsigned char val[4];

	  memcpy (val, FXSAVE_ADDR (fxsave, i), 2);
	  val[2] = val[3] = 0;
	  if (i == FOP_REGNUM)
	    val[1] &= ((1 << 3) - 1);
	  else if (i== FTAG_REGNUM)
	    {
	      /* The fxsave area contains a simplified version of the
                 tag word.  We have to look at the actual 80-bit FP
                 data to recreate the traditional i387 tag word.  */

	      unsigned long ftag = 0;
	      int fpreg;
	      int top;

	      top = (((FXSAVE_ADDR (fxsave, FSTAT_REGNUM))[1] >> 3) & 0x7);

	      for (fpreg = 7; fpreg >= 0; fpreg--)
		{
		  int tag;

		  if (val[0] & (1 << fpreg))
		    {
		      int regnum = (fpreg + 8 - top) % 8 + FP0_REGNUM;
		      tag = i387_tag (FXSAVE_ADDR (fxsave, regnum));
		    }
		  else
		    tag = 3;		/* Empty */

		  ftag |= tag << (2 * fpreg);
		}
	      val[0] = ftag & 0xff;
	      val[1] = (ftag >> 8) & 0xff;
	    }
	  supply_register (i, val);
	}
      else
	supply_register (i, FXSAVE_ADDR (fxsave, i));
    }
d560 1
a560 1
   *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do
d621 1
a621 1
i387_tag (unsigned char *raw)
@


1.33
log
@* i387-tdep.c: Reorder includes, fix some whitespace issues and
replace out-of-date comment.
@
text
@d220 8
a227 16
  frame_register_read (frame, FCTRL_REGNUM, buf);
  fctrl = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FSTAT_REGNUM, buf);
  fstat = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FTAG_REGNUM, buf);
  ftag = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FISEG_REGNUM, buf);
  fiseg = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FIOFF_REGNUM, buf);
  fioff = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOSEG_REGNUM, buf);
  foseg = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOOFF_REGNUM, buf);
  fooff = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOP_REGNUM, buf);
  fop = extract_unsigned_integer (buf, 4);
d255 1
a255 1
      frame_register_read (frame, (fpreg + 8 - top) % 8 + FP0_REGNUM, raw);
d305 1
a305 1
  frame_read_register (frame, regnum, from);
@


1.32
log
@* i386-tdep.c (i386_register_to_value, i386_value_to_register):
Move floating-point code to new function in i387-tdep.c.
* i387-tdep.c (i387_register_to_value, i387_value_to_register):
New functions containing code moved here from i386-tdep.c.
* i387-tdep.h: Add opaque declaration for `struct type'.
(i387_register_to_value, i387_value_to_register): New prototypes.
* x86-64-tdep.c (x86_64_convert_register_p): New function.
(x86_64_init_abi): Set convert_register_p, register_to_value and
value_to_register here.
@
text
@d24 2
d27 1
d30 1
d32 1
a32 3
#include "gdbcore.h"
#include "floatformat.h"
#include "regcache.h"
a34 1
#include "doublest.h"
d43 1
d67 1
d119 1
d149 1
d343 1
a343 5
/* FIXME: kettenis/2000-05-21: Right now more than a few i386 targets
   define their own routines to manage the floating-point registers in
   GDB's register array.  Most (if not all) of these targets use the
   format used by the "fsave" instruction in their communication with
   the OS.  They should all be converted to use the routines below.  */
@


1.31
log
@2003-06-14  Andrew Cagney  <cagney@@redhat.com>

	* mips-tdep.c (mips_register_to_value): Make static.
	(mips_value_to_register): Make static.
	* i386-tdep.c (i386_fetch_pointer_argument): Make static.
	* ia64-tdep.c (ia64_register_raw_size): Make static.
	(ia64_register_virtual_size): Make static.
	(ia64_register_byte): Make static.
	* i387-tdep.c: Include "i387-tdep.h".
	(print_387_control_word): Delete function.
	(print_387_status_word): Delete function.
	(print_387_status_bits): Delete function.
	(print_387_control_bits): Delete function.
	* Makefile.in (i387-tdep.o): Update dependencies.
	* rdi-share/host.h (Fail): Declare.
	* remote-rdi.c (Fail): Update to match declaration.
@
text
@d285 52
@


1.30
log
@* i387-tdep.c (fxsave_offset): Add entries for %xmm8-%xmm15.
(FXSAVE_ADDR, i387_supply_fxsave): Add support for %xmm8-%xmm15.
@
text
@d36 1
a37 105

/* FIXME: The functions on this page are used by the old `info float'
   implementations that a few of the i386 targets provide.  These
   functions should be removed if all of these have been converted to
   use the generic implementation based on the new register file
   layout.  */

static void print_387_control_bits (unsigned int control);
static void print_387_status_bits (unsigned int status);

static void
print_387_control_bits (unsigned int control)
{
  switch ((control >> 8) & 3)
    {
    case 0:
      puts_unfiltered (" 24 bit; ");
      break;
    case 1:
      puts_unfiltered (" (bad); ");
      break;
    case 2:
      puts_unfiltered (" 53 bit; ");
      break;
    case 3:
      puts_unfiltered (" 64 bit; ");
      break;
    }
  switch ((control >> 10) & 3)
    {
    case 0:
      puts_unfiltered ("NEAR; ");
      break;
    case 1:
      puts_unfiltered ("DOWN; ");
      break;
    case 2:
      puts_unfiltered ("UP; ");
      break;
    case 3:
      puts_unfiltered ("CHOP; ");
      break;
    }
  if (control & 0x3f)
    {
      puts_unfiltered ("mask");
      if (control & 0x0001)
	puts_unfiltered (" INVAL");
      if (control & 0x0002)
	puts_unfiltered (" DENOR");
      if (control & 0x0004)
	puts_unfiltered (" DIVZ");
      if (control & 0x0008)
	puts_unfiltered (" OVERF");
      if (control & 0x0010)
	puts_unfiltered (" UNDER");
      if (control & 0x0020)
	puts_unfiltered (" LOS");
      puts_unfiltered (";");
    }

  if (control & 0xe080)
    warning ("\nreserved bits on: %s",
	     local_hex_string (control & 0xe080));
}

void
print_387_control_word (unsigned int control)
{
  printf_filtered ("control %s:", local_hex_string(control & 0xffff));
  print_387_control_bits (control);
  puts_unfiltered ("\n");
}

static void
print_387_status_bits (unsigned int status)
{
  printf_unfiltered (" flags %d%d%d%d; ",
		     (status & 0x4000) != 0,
		     (status & 0x0400) != 0,
		     (status & 0x0200) != 0,
		     (status & 0x0100) != 0);
  printf_unfiltered ("top %d; ", (status >> 11) & 7);
  if (status & 0xff) 
    {
      puts_unfiltered ("excep");
      if (status & 0x0001) puts_unfiltered (" INVAL");
      if (status & 0x0002) puts_unfiltered (" DENOR");
      if (status & 0x0004) puts_unfiltered (" DIVZ");
      if (status & 0x0008) puts_unfiltered (" OVERF");
      if (status & 0x0010) puts_unfiltered (" UNDER");
      if (status & 0x0020) puts_unfiltered (" LOS");
      if (status & 0x0040) puts_unfiltered (" STACK");
    }
}

void
print_387_status_word (unsigned int status)
{
  printf_filtered ("status %s:", local_hex_string (status & 0xffff));
  print_387_status_bits (status);
  puts_unfiltered ("\n");
}


@


1.29
log
@2003-04-11  Andrew Cagney  <cagney@@redhat.com>

	* i387-tdep.c: Update copyright.
	(i387_to_double): Delete function.
	(double_to_i387): Delete function.
@
text
@d525 17
a541 9
  160,				/* XMM0_REGNUM through ...  */
  176,
  192,
  208,
  224,
  240,
  256,
  272,				/* ... XMM7_REGNUM (128 bits each).  */
  24,				/* MXCSR_REGNUM.  */
d544 6
d551 2
a552 1
  (fxsave + fxsave_offset[regnum - FP0_REGNUM])
@


1.29.2.1
log
@Merge from mainline.
@
text
@d525 9
a533 17
  160 + 0 * 16,			/* XMM0_REGNUM through ...  */
  160 + 1 * 16,
  160 + 2 * 16,
  160 + 3 * 16,
  160 + 4 * 16,
  160 + 5 * 16,
  160 + 6 * 16,
  160 + 7 * 16,
  160 + 8 * 16,
  160 + 9 * 16,
  160 + 10 * 16,
  160 + 11 * 16,
  160 + 12 * 16,
  160 + 13 * 16,
  160 + 14 * 16,
  160 + 15 * 16,		/* ... XMM15_REGNUM (128 bits each).  */
  24				/* MXCSR_REGNUM.  */
a535 6
/* FIXME: kettenis/20030430: We made an unfortunate choice in putting
   %mxcsr after the SSE registers %xmm0-%xmm7 instead of before, since
   it makes supporting the registers %xmm8-%xmm15 on x86-64 a bit
   involved.  Hack around it by explicitly overriding the offset for
   %mxcsr here.  */

d537 1
a537 2
  ((regnum == MXCSR_REGNUM) ? (fxsave + 24) : \
   (fxsave + fxsave_offset[regnum - FP0_REGNUM]))
@


1.28
log
@2002-11-09  Klee Dienes  <kdienes@@apple.com>

        * i387-tdep.c (i387_supply_register): When called with NULL as a
        buffer, mark the register as not provided (to mirror the behavior
        of supply_register).
        (i387_supply_fxsave): Ditto.
        (i387_supply_fsave): Ditto (inherits the behavior from
        i387_supply_register).
@
text
@d2 1
d4 1
a4 1
   2001, 2002 Free Software Foundation, Inc.
a35 18

/* FIXME: Eliminate the next two functions when we have the time to
   change all the callers.  */

void i387_to_double (char *from, char *to);
void double_to_i387 (char *from, char *to);

void
i387_to_double (char *from, char *to)
{
  floatformat_to_double (&floatformat_i387_ext, from, (double *) to);
}

void
double_to_i387 (char *from, char *to)
{
  floatformat_from_double (&floatformat_i387_ext, (double *) from, to);
}
@


1.27
log
@* i387-tdep.c (i387_fill_fxsave): Use FOOFF_REGNUM instead of
FDOFF_REGNUM.
@
text
@d447 6
d573 6
@


1.26
log
@* i387-tdep.c (i387_print_float_info): Call fputs_filtered instead
of puts_filtered.
@
text
@d633 1
a633 1
	    && i != FIOFF_REGNUM && i != FDOFF_REGNUM)
@


1.25
log
@* i387-tdep.c (i387_print_float_info): Replace calls to
register_read and deprecated_read_register_gen with calls to
frame_register_read, and make the necessary adjustments to the
surrounding code.
@
text
@d391 1
a391 1
  puts_filtered ("\n");
@


1.24
log
@2002-11-02  Andrew Cagney  <cagney@@redhat.com>

	* regcache.h (deprecated_read_register_gen): Rename
	read_register_gen.
	(deprecated_write_register_gen): Rename write_register_gen.
	* i387-tdep.c: Update.
	* x86-64-linux-nat.c: Update
	* wince.c: Update.
	* thread-db.c: Update.
	* win32-nat.c: Update.
	* mips-tdep.c: Update.
	* d10v-tdep.c: Update.
	* cris-tdep.c: Update.
	* remote-sim.c: Update.
	* remote-rdi.c: Update.
	* remote-rdp.c: Update.
	* frame.c: Update.
	* target.c: Update.
	* blockframe.c: Update.
	* x86-64-tdep.c: Update.
	* xstormy16-tdep.c: Update.
	* sh-tdep.c: Update.
	* s390-tdep.c: Update.
	* rs6000-tdep.c: Update.
	* sparc-tdep.c: Update.
	* i386-tdep.c: Update.
	* dwarf2cfi.c: Update.
	* regcache.c: Update.
@
text
@d324 9
a332 8
  unsigned int fctrl;
  unsigned int fstat;
  unsigned int ftag;
  unsigned int fiseg;
  unsigned int fioff;
  unsigned int foseg;
  unsigned int fooff;
  unsigned int fop;
d336 17
a352 9
  fctrl = read_register (FCTRL_REGNUM);
  fstat = read_register (FSTAT_REGNUM);
  ftag  = read_register (FTAG_REGNUM);
  fiseg = read_register (FCS_REGNUM);
  fioff = read_register (FCOFF_REGNUM);
  foseg = read_register (FDS_REGNUM);
  fooff = read_register (FDOFF_REGNUM);
  fop   = read_register (FOP_REGNUM);
  
d379 1
a379 1
      deprecated_read_register_gen ((fpreg + 8 - top) % 8 + FP0_REGNUM, raw);
@


1.23
log
@	* Makefile.in (osabi.o, i387-tdep.o, i386-linux-nat.o, lin-lwp.o,
	ax-gdb.o, signals.o, jv-valprint.o, c-valprint.o, cp-abi.o):
	Update dependencies.
	* i387-tdep.c: Include gdb_string.h.
	* osabi.c: Likewise.
	* i386-linux-nat.c: Likewise.
	* lin-lwp.c: Likewise.
	* ax-gdb.c: Likewise.
	* signals/signals.c: Likewise.
	* jv-valprint.c: Likewise.
	* p-lang.c: Likewise.
	* c-valprint.c: Likewise.
	* cp-abi.c: Likewise.
@
text
@d370 1
a370 1
      read_register_gen ((fpreg + 8 - top) % 8 + FP0_REGNUM, raw);
@


1.23.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a1 1

d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
a22 2
#include "doublest.h"
#include "floatformat.h"
a23 1
#include "gdbcore.h"
d26 3
a29 2
#include "value.h"

d32 1
a34 1
#include "i387-tdep.h"
d36 123
a162 1

a185 1

a236 1

a265 1

d324 8
a331 10
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
  char buf[4];
  ULONGEST fctrl;
  ULONGEST fstat;
  ULONGEST ftag;
  ULONGEST fiseg;
  ULONGEST fioff;
  ULONGEST foseg;
  ULONGEST fooff;
  ULONGEST fop;
d335 9
a343 15
  gdb_assert (gdbarch == get_frame_arch (frame));

  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for FRAME's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  fctrl = get_frame_register_unsigned (frame, I387_FCTRL_REGNUM);
  fstat = get_frame_register_unsigned (frame, I387_FSTAT_REGNUM);
  ftag = get_frame_register_unsigned (frame, I387_FTAG_REGNUM);
  fiseg = get_frame_register_unsigned (frame, I387_FISEG_REGNUM);
  fioff = get_frame_register_unsigned (frame, I387_FIOFF_REGNUM);
  foseg = get_frame_register_unsigned (frame, I387_FOSEG_REGNUM);
  fooff = get_frame_register_unsigned (frame, I387_FOOFF_REGNUM);
  fop = get_frame_register_unsigned (frame, I387_FOP_REGNUM);

d348 1
a348 1
      unsigned char raw[I386_MAX_REGISTER_SIZE];
d370 1
a370 1
      get_frame_register (frame, (fpreg + 8 - top) % 8 + I387_ST0_REGNUM, raw);
d382 1
a382 1
  fputs_filtered ("\n", file);
a395 2

#undef I387_ST0_REGNUM
a396 10


/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */

void
i387_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
{
  char from[I386_MAX_REGISTER_SIZE];
d398 5
a402 50
  gdb_assert (i386_fp_regnum_p (regnum));

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
      return;
    }

  /* Convert to TYPE.  This should be a no-op if TYPE is equivalent to
     the extended floating-point format used by the FPU.  */
  get_frame_register (frame, regnum, from);
  convert_typed_floating (from, builtin_type_i387_ext, to, type);
}

/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */

void
i387_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
{
  char to[I386_MAX_REGISTER_SIZE];

  gdb_assert (i386_fp_regnum_p (regnum));

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert non-floating-point type "
	       "to floating-point register value.");
      return;
    }

  /* Convert from TYPE.  This should be a no-op if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
  convert_typed_floating (from, type, to, builtin_type_i387_ext);
  put_frame_register (frame, regnum, to);
}



/* Handle FSAVE and FXSAVE formats.  */

/* FIXME: kettenis/20030927: The functions below should accept a
   `regcache' argument, but I don't want to change the function
   signature just yet.  There's some band-aid in the functions below
   in the form of the `regcache' local variables.  This will ease the
   transition later on.  */
d410 16
a425 16
  28 + 0 * 10,			/* %st(0) ...  */
  28 + 1 * 10,
  28 + 2 * 10,
  28 + 3 * 10,
  28 + 4 * 10,
  28 + 5 * 10,
  28 + 6 * 10,
  28 + 7 * 10,			/* ... %st(7).  */
  0,				/* `fctrl' (16 bits).  */
  4,				/* `fstat' (16 bits).  */
  8,				/* `ftag' (16 bits).  */
  16,				/* `fiseg' (16 bits).  */
  12,				/* `fioff'.  */
  24,				/* `foseg' (16 bits).  */
  20,				/* `fooff'.  */
  18				/* `fop' (bottom 11 bits).  */
d428 1
a428 2
#define FSAVE_ADDR(fsave, regnum) \
  (fsave + fsave_offset[regnum - I387_ST0_REGNUM])
d431 3
a433 3
/* Fill register REGNUM in REGCACHE with the appropriate value from
   *FSAVE.  This function masks off any of the reserved bits in
   *FSAVE.  */
d436 1
a436 1
i387_supply_fsave (struct regcache *regcache, int regnum, const void *fsave)
d438 16
a453 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  const char *regs = fsave;
  int i;
d455 3
a457 1
  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
d459 4
a462 19
  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  for (i = I387_ST0_REGNUM; i < I387_XMM0_REGNUM; i++)
    if (regnum == -1 || regnum == i)
      {
	if (fsave == NULL)
	  {
	    regcache_raw_supply (regcache, i, NULL);
	    continue;
	  }

	/* Most of the FPU control registers occupy only 16 bits in the
	   fsave area.  Give those a special treatment.  */
	if (i >= I387_FCTRL_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
	  {
	    unsigned char val[4];
d464 2
a465 10
	    memcpy (val, FSAVE_ADDR (regs, i), 2);
	    val[2] = val[3] = 0;
	    if (i == I387_FOP_REGNUM)
	      val[1] &= ((1 << 3) - 1);
	    regcache_raw_supply (regcache, i, val);
	  }
	else
	  regcache_raw_supply (regcache, i, FSAVE_ADDR (regs, i));
      }
#undef I387_ST0_REGNUM
d469 1
a469 1
   with the value in GDB's register cache.  If REGNUM is -1, do this
d474 1
a474 1
i387_fill_fsave (void *fsave, int regnum)
a475 3
  struct regcache *regcache = current_regcache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  char *regs = fsave;
d478 1
a478 7
  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);

  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  for (i = I387_ST0_REGNUM; i < I387_XMM0_REGNUM; i++)
d483 2
a484 2
	if (i >= I387_FCTRL_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d488 1
a488 1
	    regcache_raw_collect (regcache, i, buf);
d490 1
a490 1
	    if (i == I387_FOP_REGNUM)
d495 1
a495 1
		buf[1] |= ((FSAVE_ADDR (regs, i))[1] & ~((1 << 3) - 1));
d497 1
a497 1
	    memcpy (FSAVE_ADDR (regs, i), buf, 2);
d500 1
a500 1
	  regcache_raw_collect (regcache, i, FSAVE_ADDR (regs, i));
a501 1
#undef I387_ST0_REGNUM
d511 1
a511 1
  32,				/* %st(0) through ...  */
d518 18
a535 25
  144,				/* ... %st(7) (80 bits each).  */
  0,				/* `fctrl' (16 bits).  */
  2,				/* `fstat' (16 bits).  */
  4,				/* `ftag' (16 bits).  */
  12,				/* `fiseg' (16 bits).  */
  8,				/* `fioff'.  */
  20,				/* `foseg' (16 bits).  */
  16,				/* `fooff'.  */
  6,				/* `fop' (bottom 11 bits).  */
  160 + 0 * 16,			/* %xmm0 through ...  */
  160 + 1 * 16,
  160 + 2 * 16,
  160 + 3 * 16,
  160 + 4 * 16,
  160 + 5 * 16,
  160 + 6 * 16,
  160 + 7 * 16,
  160 + 8 * 16,
  160 + 9 * 16,
  160 + 10 * 16,
  160 + 11 * 16,
  160 + 12 * 16,
  160 + 13 * 16,
  160 + 14 * 16,
  160 + 15 * 16,		/* ... %xmm15 (128 bits each).  */
d539 1
a539 8
  (fxsave + fxsave_offset[regnum - I387_ST0_REGNUM])

/* We made an unfortunate choice in putting %mxcsr after the SSE
   registers %xmm0-%xmm7 instead of before, since it makes supporting
   the registers %xmm8-%xmm15 on AMD64 a bit involved.  Therefore we
   don't include the offset for %mxcsr here above.  */

#define FXSAVE_MXCSR_ADDR(fxsave) (fxsave + 24)
d541 1
a541 1
static int i387_tag (const unsigned char *raw);
d544 3
a546 3
/* Fill register REGNUM in REGCACHE with the appropriate
   floating-point or SSE register value from *FXSAVE.  This function
   masks off any of the reserved bits in *FXSAVE.  */
d549 1
a549 1
i387_supply_fxsave (struct regcache *regcache, int regnum, const void *fxsave)
d551 1
a551 3
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  const char *regs = fxsave;
  int i;
d553 2
a554 2
  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);
d556 8
a563 2
  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */
d565 35
a599 63
#define I387_ST0_REGNUM	tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  for (i = I387_ST0_REGNUM; i < I387_MXCSR_REGNUM; i++)
    if (regnum == -1 || regnum == i)
      {
	if (regs == NULL)
	  {
	    regcache_raw_supply (regcache, i, NULL);
	    continue;
	  }

	/* Most of the FPU control registers occupy only 16 bits in
	   the fxsave area.  Give those a special treatment.  */
	if (i >= I387_FCTRL_REGNUM && i < I387_XMM0_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
	  {
	    unsigned char val[4];

	    memcpy (val, FXSAVE_ADDR (regs, i), 2);
	    val[2] = val[3] = 0;
	    if (i == I387_FOP_REGNUM)
	      val[1] &= ((1 << 3) - 1);
	    else if (i== I387_FTAG_REGNUM)
	      {
		/* The fxsave area contains a simplified version of
		   the tag word.  We have to look at the actual 80-bit
		   FP data to recreate the traditional i387 tag word.  */

		unsigned long ftag = 0;
		int fpreg;
		int top;

		top = ((FXSAVE_ADDR (regs, I387_FSTAT_REGNUM))[1] >> 3);
		top &= 0x7;

		for (fpreg = 7; fpreg >= 0; fpreg--)
		  {
		    int tag;

		    if (val[0] & (1 << fpreg))
		      {
			int regnum = (fpreg + 8 - top) % 8 + I387_ST0_REGNUM;
			tag = i387_tag (FXSAVE_ADDR (regs, regnum));
		      }
		    else
		      tag = 3;		/* Empty */

		    ftag |= tag << (2 * fpreg);
		  }
		val[0] = ftag & 0xff;
		val[1] = (ftag >> 8) & 0xff;
	      }
	    regcache_raw_supply (regcache, i, val);
	  }
	else
	  regcache_raw_supply (regcache, i, FXSAVE_ADDR (regs, i));
      }

  if (regnum == I387_MXCSR_REGNUM || regnum == -1)
    {
      if (regs == NULL)
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM, NULL);
d601 1
a601 2
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM,
			     FXSAVE_MXCSR_ADDR (regs));
a602 3

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d606 1
a606 1
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
d611 1
a611 1
i387_fill_fxsave (void *fxsave, int regnum)
d613 1
a613 7
  struct regcache *regcache = current_regcache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  char *regs = fxsave;
  int i;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);
d615 2
a616 2
  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */
d618 1
a618 4
#define I387_ST0_REGNUM	tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  for (i = I387_ST0_REGNUM; i < I387_MXCSR_REGNUM; i++)
d623 2
a624 2
	if (i >= I387_FCTRL_REGNUM && i < I387_XMM0_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d628 1
a628 1
	    regcache_raw_collect (regcache, i, buf);
d630 1
a630 1
	    if (i == I387_FOP_REGNUM)
d635 1
a635 1
		buf[1] |= ((FXSAVE_ADDR (regs, i))[1] & ~((1 << 3) - 1));
d637 1
a637 1
	    else if (i == I387_FTAG_REGNUM)
d656 1
a656 1
	    memcpy (FXSAVE_ADDR (regs, i), buf, 2);
d659 1
a659 1
	  regcache_raw_collect (regcache, i, FXSAVE_ADDR (regs, i));
a660 7

  if (regnum == I387_MXCSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, I387_MXCSR_REGNUM,
			  FXSAVE_MXCSR_ADDR (regs));

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d667 1
a667 1
i387_tag (const unsigned char *raw)
a709 28
}

/* Prepare the FPU stack in REGCACHE for a function return.  */

void
i387_return_value (struct gdbarch *gdbarch, struct regcache *regcache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  ULONGEST fstat;

  /* Define I387_ST0_REGNUM such that we use the proper
     definitions for the architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  /* Set the top of the floating-point register stack to 7.  The
     actual value doesn't really matter, but 7 is what a normal
     function return would end up with if the program started out with
     a freshly initialized FPU.  */
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
  fstat |= (7 << 11);
  regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM, fstat);

  /* Mark %st(1) through %st(7) as empty.  Since we set the top of the
     floating-point register stack to 7, the appropriate value for the
     tag word is 0x3fff.  */
  regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM, 0x3fff);

#undef I387_ST0_REGNUM
@


1.23.4.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d324 8
a331 9
  char buf[4];
  ULONGEST fctrl;
  ULONGEST fstat;
  ULONGEST ftag;
  ULONGEST fiseg;
  ULONGEST fioff;
  ULONGEST foseg;
  ULONGEST fooff;
  ULONGEST fop;
d335 9
a343 17
  frame_register_read (frame, FCTRL_REGNUM, buf);
  fctrl = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FSTAT_REGNUM, buf);
  fstat = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FTAG_REGNUM, buf);
  ftag = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FISEG_REGNUM, buf);
  fiseg = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FIOFF_REGNUM, buf);
  fioff = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOSEG_REGNUM, buf);
  foseg = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOOFF_REGNUM, buf);
  fooff = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOP_REGNUM, buf);
  fop = extract_unsigned_integer (buf, 4);

d370 1
a370 1
      frame_register_read (frame, (fpreg + 8 - top) % 8 + FP0_REGNUM, raw);
d382 1
a382 1
  fputs_filtered ("\n", file);
a437 6
  if (fsave == NULL)
    {
      supply_register (regnum, NULL);
      return;
    }

a557 6
      if (fxsave == NULL)
	{
	  supply_register (i, NULL);
	  continue;
	}

d624 1
a624 1
	    && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
@


1.23.4.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a1 1

d3 1
a3 1
   2001, 2002, 2003 Free Software Foundation, Inc.
d35 18
@


1.23.4.3
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d525 9
a533 17
  160 + 0 * 16,			/* XMM0_REGNUM through ...  */
  160 + 1 * 16,
  160 + 2 * 16,
  160 + 3 * 16,
  160 + 4 * 16,
  160 + 5 * 16,
  160 + 6 * 16,
  160 + 7 * 16,
  160 + 8 * 16,
  160 + 9 * 16,
  160 + 10 * 16,
  160 + 11 * 16,
  160 + 12 * 16,
  160 + 13 * 16,
  160 + 14 * 16,
  160 + 15 * 16,		/* ... XMM15_REGNUM (128 bits each).  */
  24				/* MXCSR_REGNUM.  */
a535 6
/* FIXME: kettenis/20030430: We made an unfortunate choice in putting
   %mxcsr after the SSE registers %xmm0-%xmm7 instead of before, since
   it makes supporting the registers %xmm8-%xmm15 on x86-64 a bit
   involved.  Hack around it by explicitly overriding the offset for
   %mxcsr here.  */

d537 1
a537 2
  ((regnum == MXCSR_REGNUM) ? (fxsave + 24) : \
   (fxsave + fxsave_offset[regnum - FP0_REGNUM]))
@


1.23.4.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@a23 2
#include "doublest.h"
#include "floatformat.h"
a24 1
#include "gdbcore.h"
d27 3
a30 2
#include "value.h"

d33 1
a35 1
#include "i387-tdep.h"
d37 105
a145 1

a168 1

a219 1

a248 1

a388 52


/* Read a value of type TYPE from register REGNUM in frame FRAME, and
   return its contents in TO.  */

void
i387_register_to_value (struct frame_info *frame, int regnum,
			struct type *type, void *to)
{
  char from[I386_MAX_REGISTER_SIZE];

  gdb_assert (i386_fp_regnum_p (regnum));

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert floating-point register value "
	       "to non-floating-point type.");
      return;
    }

  /* Convert to TYPE.  This should be a no-op if TYPE is equivalent to
     the extended floating-point format used by the FPU.  */
  frame_read_register (frame, regnum, from);
  convert_typed_floating (from, builtin_type_i387_ext, to, type);
}

/* Write the contents FROM of a value of type TYPE into register
   REGNUM in frame FRAME.  */

void
i387_value_to_register (struct frame_info *frame, int regnum,
			struct type *type, const void *from)
{
  char to[I386_MAX_REGISTER_SIZE];

  gdb_assert (i386_fp_regnum_p (regnum));

  /* We only support floating-point values.  */
  if (TYPE_CODE (type) != TYPE_CODE_FLT)
    {
      warning ("Cannot convert non-floating-point type "
	       "to floating-point register value.");
      return;
    }

  /* Convert from TYPE.  This should be a no-op if TYPE is equivalent
     to the extended floating-point format used by the FPU.  */
  convert_typed_floating (from, type, to, builtin_type_i387_ext);
  put_frame_register (frame, regnum, to);
}

d390 5
a394 1
/* Handle FSAVE and FXSAVE formats.  */
@


1.23.4.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d220 16
a235 8
  fctrl = get_frame_register_unsigned (frame, FCTRL_REGNUM);
  fstat = get_frame_register_unsigned (frame, FSTAT_REGNUM);
  ftag = get_frame_register_unsigned (frame, FTAG_REGNUM);
  fiseg = get_frame_register_unsigned (frame, FISEG_REGNUM);
  fioff = get_frame_register_unsigned (frame, FIOFF_REGNUM);
  foseg = get_frame_register_unsigned (frame, FOSEG_REGNUM);
  fooff = get_frame_register_unsigned (frame, FOOFF_REGNUM);
  fop = get_frame_register_unsigned (frame, FOP_REGNUM);
d263 1
a263 1
      get_frame_register (frame, (fpreg + 8 - top) % 8 + FP0_REGNUM, raw);
d313 1
a313 1
  get_frame_register (frame, regnum, from);
d372 1
a372 1
/* Fill register REGNUM in GDB's register cache with the appropriate
d377 31
a407 1
i387_supply_fsave (const char *fsave, int regnum)
d412 1
a412 24
    if (regnum == -1 || regnum == i)
      {
	if (fsave == NULL)
	  {
	    supply_register (i, NULL);
	    return;
	  }

	/* Most of the FPU control registers occupy only 16 bits in the
	   fsave area.  Give those a special treatment.  */
	if (i >= FPC_REGNUM
	    && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
	  {
	    unsigned char val[4];

	    memcpy (val, FSAVE_ADDR (fsave, i), 2);
	    val[2] = val[3] = 0;
	    if (i == FOP_REGNUM)
	      val[1] &= ((1 << 3) - 1);
	    supply_register (i, val);
	  }
	else
	  supply_register (i, FSAVE_ADDR (fsave, i));
      }
d416 1
a416 1
   with the value in GDB's register cache.  If REGNUM is -1, do this
d503 1
a503 1
static int i387_tag (const unsigned char *raw);
d506 3
a508 3
/* Fill register REGNUM in GDB's register cache with the appropriate
   floating-point or SSE register value from *FXSAVE.  This function
   masks off any of the reserved bits in *FXSAVE.  */
d511 1
a511 1
i387_supply_fxsave (const char *fxsave, int regnum)
d519 6
a524 7
    if (regnum == -1 || regnum == i)
      {
	if (fxsave == NULL)
	  {
	    supply_register (i, NULL);
	    continue;
	  }
d526 6
a531 6
	/* Most of the FPU control registers occupy only 16 bits in
	   the fxsave area.  Give those a special treatment.  */
	if (i >= FPC_REGNUM && i < XMM0_REGNUM
	    && i != FIOFF_REGNUM && i != FOOFF_REGNUM)
	  {
	    unsigned char val[4];
d533 38
a570 38
	    memcpy (val, FXSAVE_ADDR (fxsave, i), 2);
	    val[2] = val[3] = 0;
	    if (i == FOP_REGNUM)
	      val[1] &= ((1 << 3) - 1);
	    else if (i== FTAG_REGNUM)
	      {
		/* The fxsave area contains a simplified version of
		   the tag word.  We have to look at the actual 80-bit
		   FP data to recreate the traditional i387 tag word.  */

		unsigned long ftag = 0;
		int fpreg;
		int top;

		top = (((FXSAVE_ADDR (fxsave, FSTAT_REGNUM))[1] >> 3) & 0x7);

		for (fpreg = 7; fpreg >= 0; fpreg--)
		  {
		    int tag;

		    if (val[0] & (1 << fpreg))
		      {
			int regnum = (fpreg + 8 - top) % 8 + FP0_REGNUM;
			tag = i387_tag (FXSAVE_ADDR (fxsave, regnum));
		      }
		    else
		      tag = 3;		/* Empty */

		    ftag |= tag << (2 * fpreg);
		  }
		val[0] = ftag & 0xff;
		val[1] = (ftag >> 8) & 0xff;
	      }
	    supply_register (i, val);
	  }
	else
	  supply_register (i, FXSAVE_ADDR (fxsave, i));
      }
d574 1
a574 1
   *FXSAVE with the value in GDB's register cache.  If REGNUM is -1, do
d635 1
a635 1
i387_tag (const unsigned char *raw)
@


1.23.4.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a207 1
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (frame));
d220 8
a227 14
  gdb_assert (gdbarch == get_frame_arch (frame));

  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for FRAME's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  fctrl = get_frame_register_unsigned (frame, I387_FCTRL_REGNUM);
  fstat = get_frame_register_unsigned (frame, I387_FSTAT_REGNUM);
  ftag = get_frame_register_unsigned (frame, I387_FTAG_REGNUM);
  fiseg = get_frame_register_unsigned (frame, I387_FISEG_REGNUM);
  fioff = get_frame_register_unsigned (frame, I387_FIOFF_REGNUM);
  foseg = get_frame_register_unsigned (frame, I387_FOSEG_REGNUM);
  fooff = get_frame_register_unsigned (frame, I387_FOOFF_REGNUM);
  fop = get_frame_register_unsigned (frame, I387_FOP_REGNUM);
d233 1
a233 1
      unsigned char raw[I386_MAX_REGISTER_SIZE];
d255 1
a255 1
      get_frame_register (frame, (fpreg + 8 - top) % 8 + I387_ST0_REGNUM, raw);
a280 2

#undef I387_ST0_REGNUM
a333 1

a336 6
/* FIXME: kettenis/20030927: The functions below should accept a
   `regcache' argument, but I don't want to change the function
   signature just yet.  There's some band-aid in the functions below
   in the form of the `regcache' local variables.  This will ease the
   transition later on.  */

d343 16
a358 16
  28 + 0 * 10,			/* %st(0) ...  */
  28 + 1 * 10,
  28 + 2 * 10,
  28 + 3 * 10,
  28 + 4 * 10,
  28 + 5 * 10,
  28 + 6 * 10,
  28 + 7 * 10,			/* ... %st(7).  */
  0,				/* `fctrl' (16 bits).  */
  4,				/* `fstat' (16 bits).  */
  8,				/* `ftag' (16 bits).  */
  16,				/* `fiseg' (16 bits).  */
  12,				/* `fioff'.  */
  24,				/* `foseg' (16 bits).  */
  20,				/* `fooff'.  */
  18				/* `fop' (bottom 11 bits).  */
d361 1
a361 2
#define FSAVE_ADDR(fsave, regnum) \
  (fsave + fsave_offset[regnum - I387_ST0_REGNUM])
d364 3
a366 3
/* Fill register REGNUM in REGCACHE with the appropriate value from
   *FSAVE.  This function masks off any of the reserved bits in
   *FSAVE.  */
d369 1
a369 1
i387_supply_fsave (struct regcache *regcache, int regnum, const void *fsave)
a370 2
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  const char *regs = fsave;
d373 1
a373 7
  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);

  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  for (i = I387_ST0_REGNUM; i < I387_XMM0_REGNUM; i++)
d378 2
a379 2
	    regcache_raw_supply (regcache, i, NULL);
	    continue;
d384 2
a385 2
	if (i >= I387_FCTRL_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d389 1
a389 1
	    memcpy (val, FSAVE_ADDR (regs, i), 2);
d391 1
a391 1
	    if (i == I387_FOP_REGNUM)
d393 1
a393 1
	    regcache_raw_supply (regcache, i, val);
d396 1
a396 1
	  regcache_raw_supply (regcache, i, FSAVE_ADDR (regs, i));
a397 1
#undef I387_ST0_REGNUM
d406 1
a406 1
i387_fill_fsave (void *fsave, int regnum)
a407 3
  struct regcache *regcache = current_regcache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  char *regs = fsave;
d410 1
a410 7
  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);

  /* Define I387_ST0_REGNUM such that we use the proper definitions
     for REGCACHE's architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  for (i = I387_ST0_REGNUM; i < I387_XMM0_REGNUM; i++)
d415 2
a416 2
	if (i >= I387_FCTRL_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d420 1
a420 1
	    regcache_raw_collect (regcache, i, buf);
d422 1
a422 1
	    if (i == I387_FOP_REGNUM)
d427 1
a427 1
		buf[1] |= ((FSAVE_ADDR (regs, i))[1] & ~((1 << 3) - 1));
d429 1
a429 1
	    memcpy (FSAVE_ADDR (regs, i), buf, 2);
d432 1
a432 1
	  regcache_raw_collect (regcache, i, FSAVE_ADDR (regs, i));
a433 1
#undef I387_ST0_REGNUM
d443 1
a443 1
  32,				/* %st(0) through ...  */
d450 10
a459 10
  144,				/* ... %st(7) (80 bits each).  */
  0,				/* `fctrl' (16 bits).  */
  2,				/* `fstat' (16 bits).  */
  4,				/* `ftag' (16 bits).  */
  12,				/* `fiseg' (16 bits).  */
  8,				/* `fioff'.  */
  20,				/* `foseg' (16 bits).  */
  16,				/* `fooff'.  */
  6,				/* `fop' (bottom 11 bits).  */
  160 + 0 * 16,			/* %xmm0 through ...  */
d474 2
a475 1
  160 + 15 * 16,		/* ... %xmm15 (128 bits each).  */
d478 6
d485 2
a486 8
  (fxsave + fxsave_offset[regnum - I387_ST0_REGNUM])

/* We made an unfortunate choice in putting %mxcsr after the SSE
   registers %xmm0-%xmm7 instead of before, since it makes supporting
   the registers %xmm8-%xmm15 on AMD64 a bit involved.  Therefore we
   don't include the offset for %mxcsr here above.  */

#define FXSAVE_MXCSR_ADDR(fxsave) (fxsave + 24)
d491 1
a491 1
/* Fill register REGNUM in REGCACHE with the appropriate
d496 1
a496 1
i387_supply_fxsave (struct regcache *regcache, int regnum, const void *fxsave)
d498 1
a498 9
  struct gdbarch_tdep *tdep = gdbarch_tdep (get_regcache_arch (regcache));
  const char *regs = fxsave;
  int i;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);

  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */
d500 2
a501 2
#define I387_ST0_REGNUM	tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs
d503 1
a503 1
  for (i = I387_ST0_REGNUM; i < I387_MXCSR_REGNUM; i++)
d506 1
a506 1
	if (regs == NULL)
d508 1
a508 1
	    regcache_raw_supply (regcache, i, NULL);
d514 2
a515 2
	if (i >= I387_FCTRL_REGNUM && i < I387_XMM0_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d519 1
a519 1
	    memcpy (val, FXSAVE_ADDR (regs, i), 2);
d521 1
a521 1
	    if (i == I387_FOP_REGNUM)
d523 1
a523 1
	    else if (i== I387_FTAG_REGNUM)
d533 1
a533 2
		top = ((FXSAVE_ADDR (regs, I387_FSTAT_REGNUM))[1] >> 3);
		top &= 0x7;
d541 2
a542 2
			int regnum = (fpreg + 8 - top) % 8 + I387_ST0_REGNUM;
			tag = i387_tag (FXSAVE_ADDR (regs, regnum));
d552 1
a552 1
	    regcache_raw_supply (regcache, i, val);
d555 1
a555 1
	  regcache_raw_supply (regcache, i, FXSAVE_ADDR (regs, i));
a556 12

  if (regnum == I387_MXCSR_REGNUM || regnum == -1)
    {
      if (regs == NULL)
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM, NULL);
      else
	regcache_raw_supply (regcache, I387_MXCSR_REGNUM,
			     FXSAVE_MXCSR_ADDR (regs));
    }

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
d565 1
a565 1
i387_fill_fxsave (void *fxsave, int regnum)
d567 1
a567 7
  struct regcache *regcache = current_regcache;
  struct gdbarch_tdep *tdep = gdbarch_tdep (current_gdbarch);
  char *regs = fxsave;
  int i;

  gdb_assert (tdep->st0_regnum >= I386_ST0_REGNUM);
  gdb_assert (tdep->num_xmm_regs > 0);
d569 2
a570 2
  /* Define I387_ST0_REGNUM and I387_NUM_XMM_REGS such that we use the
     proper definitions for REGCACHE's architecture.  */
d572 1
a572 4
#define I387_ST0_REGNUM	tdep->st0_regnum
#define I387_NUM_XMM_REGS tdep->num_xmm_regs

  for (i = I387_ST0_REGNUM; i < I387_MXCSR_REGNUM; i++)
d577 2
a578 2
	if (i >= I387_FCTRL_REGNUM && i < I387_XMM0_REGNUM
	    && i != I387_FIOFF_REGNUM && i != I387_FOOFF_REGNUM)
d582 1
a582 1
	    regcache_raw_collect (regcache, i, buf);
d584 1
a584 1
	    if (i == I387_FOP_REGNUM)
d589 1
a589 1
		buf[1] |= ((FXSAVE_ADDR (regs, i))[1] & ~((1 << 3) - 1));
d591 1
a591 1
	    else if (i == I387_FTAG_REGNUM)
d610 1
a610 1
	    memcpy (FXSAVE_ADDR (regs, i), buf, 2);
d613 1
a613 1
	  regcache_raw_collect (regcache, i, FXSAVE_ADDR (regs, i));
a614 7

  if (regnum == I387_MXCSR_REGNUM || regnum == -1)
    regcache_raw_collect (regcache, I387_MXCSR_REGNUM,
			  FXSAVE_MXCSR_ADDR (regs));

#undef I387_ST0_REGNUM
#undef I387_NUM_XMM_REGS
@


1.23.4.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@a736 28

/* Prepare the FPU stack in REGCACHE for a function return.  */

void
i387_return_value (struct gdbarch *gdbarch, struct regcache *regcache)
{
  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);
  ULONGEST fstat;

  /* Define I387_ST0_REGNUM such that we use the proper
     definitions for the architecture.  */
#define I387_ST0_REGNUM tdep->st0_regnum

  /* Set the top of the floating-point register stack to 7.  The
     actual value doesn't really matter, but 7 is what a normal
     function return would end up with if the program started out with
     a freshly initialized FPU.  */
  regcache_raw_read_unsigned (regcache, I387_FSTAT_REGNUM, &fstat);
  fstat |= (7 << 11);
  regcache_raw_write_unsigned (regcache, I387_FSTAT_REGNUM, fstat);

  /* Mark %st(1) through %st(7) as empty.  Since we set the top of the
     floating-point register stack to 7, the appropriate value for the
     tag word is 0x3fff.  */
  regcache_raw_write_unsigned (regcache, I387_FTAG_REGNUM, 0x3fff);

#undef I387_ST0_REGNUM
}
@


1.22
log
@2002-08-19  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* i387-tdep.c (i387_print_float_info): Fix typo in comment.
@
text
@d31 1
@


1.21
log
@2002-08-15  Andrew Cagney  <ac131313@@redhat.com>

* i387-tdep.h (i387_print_float_info): Add `args' parameter.
* i387-tdep.c (i387_print_float_info): Add `args' parameter.
@
text
@d315 1
a315 1
/* Print out the i387 floating poin state.  Note that we ignore FRAME
@


1.20
log
@* i387-tdep.c (i387_print_float_info): Add comment about ignoring
FRAME.
@
text
@d321 1
a321 1
		       struct frame_info *frame)
@


1.19
log
@* i387-tdep.h (i387_print_float_info): New prototype.
* i387-tdep.c (print_i387_value, print_i387_ext,
print_i387_status_word, print_i387_control_word): Add `struct
ui_file *' argument and use it for output.
(i387_print_float_info): Renamed from i387_float_info.  Add
`struct gdbarch *' and `struct ui_file *' arguments and use the
latter for output.
* i386-tdep.c: Include "i387-tdep.h".
(i386_gdbarch_init): Set print_float_info.
* config/i386/tm-i386.h (i387_float_info): Remove prototype.
(FLOAT_INFO): Remove define.
@
text
@d315 4
a318 1
/* Print out the i387 floating poin state.  */
@


1.18
log
@* i387-tdep.c (i387_supply_fxsave): Skip the SSE registers if
the're not supported by the current architecture.
(i387_fill_fxsave): Likewise.
@
text
@d163 1
a163 1
print_i387_value (char *raw)
d178 1
a178 1
  printf_filtered (" %-+27.19Lg", (long double) value);
d180 1
a180 1
  printf_filtered (" %-+27.19g", (double) value);
d186 1
a186 1
print_i387_ext (unsigned char *raw)
d204 1
a204 1
	printf_filtered (" %cInf", (sign ? '-' : '+'));
d207 1
a207 1
	puts_unfiltered (" Real Indefinite (QNaN)");
d210 1
a210 1
	puts_filtered (" QNaN");
d213 1
a213 1
	puts_filtered (" SNaN");
d217 1
a217 1
    print_i387_value (raw);
d221 1
a221 1
      print_i387_value (raw);
d225 1
a225 1
	puts_filtered (" Pseudo-denormal");
d228 1
a228 1
	puts_filtered (" Denormal");
d232 1
a232 1
    puts_filtered (" Unsupported");
d237 1
a237 1
print_i387_status_word (unsigned int status)
d239 1
a239 1
  printf_filtered ("Status Word:         %s",
d241 16
a256 16
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0001) ? "IE" : "  ");
  printf_filtered (" %s", (status & 0x0002) ? "DE" : "  ");
  printf_filtered (" %s", (status & 0x0004) ? "ZE" : "  ");
  printf_filtered (" %s", (status & 0x0008) ? "OE" : "  ");
  printf_filtered (" %s", (status & 0x0010) ? "UE" : "  ");
  printf_filtered (" %s", (status & 0x0020) ? "PE" : "  ");
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0080) ? "ES" : "  ");
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0040) ? "SF" : "  ");
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0100) ? "C0" : "  ");
  printf_filtered (" %s", (status & 0x0200) ? "C1" : "  ");
  printf_filtered (" %s", (status & 0x0400) ? "C2" : "  ");
  printf_filtered (" %s", (status & 0x4000) ? "C3" : "  ");
d258 1
a258 1
  puts_filtered ("\n");
d260 2
a261 1
  printf_filtered ("                       TOP: %d\n", ((status >> 11) & 7));
d266 1
a266 1
print_i387_control_word (unsigned int control)
d268 1
a268 1
  printf_filtered ("Control Word:        %s",
d270 7
a276 7
  puts_filtered ("  ");
  printf_filtered (" %s", (control & 0x0001) ? "IM" : "  ");
  printf_filtered (" %s", (control & 0x0002) ? "DM" : "  ");
  printf_filtered (" %s", (control & 0x0004) ? "ZM" : "  ");
  printf_filtered (" %s", (control & 0x0008) ? "OM" : "  ");
  printf_filtered (" %s", (control & 0x0010) ? "UM" : "  ");
  printf_filtered (" %s", (control & 0x0020) ? "PM" : "  ");
d278 1
a278 1
  puts_filtered ("\n");
d280 1
a280 1
  puts_filtered ("                       PC: ");
d284 1
a284 1
      puts_filtered ("Single Precision (24-bits)\n");
d287 1
a287 1
      puts_filtered ("Reserved\n");
d290 1
a290 1
      puts_filtered ("Double Precision (53-bits)\n");
d293 1
a293 1
      puts_filtered ("Extended Precision (64-bits)\n");
d297 1
a297 1
  puts_filtered ("                       RC: ");
d301 1
a301 1
      puts_filtered ("Round to nearest\n");
d304 1
a304 1
      puts_filtered ("Round down\n");
d307 1
a307 1
      puts_filtered ("Round up\n");
d310 1
a310 1
      puts_filtered ("Round toward zero\n");
d317 2
a318 1
i387_float_info (void)
d348 1
a348 1
      printf_filtered ("%sR%d: ", fpreg == top ? "=>" : "  ", fpreg);
d353 1
a353 1
	  puts_filtered ("Valid   ");
d356 1
a356 1
	  puts_filtered ("Zero    ");
d359 1
a359 1
	  puts_filtered ("Special ");
d362 1
a362 1
	  puts_filtered ("Empty   ");
d368 1
a368 1
      puts_filtered ("0x");
d370 1
a370 1
	printf_filtered ("%02x", raw[i]);
d373 1
a373 1
	print_i387_ext (raw);
d375 1
a375 1
      puts_filtered ("\n");
d380 12
a391 12
  print_i387_status_word (fstat);
  print_i387_control_word (fctrl);
  printf_filtered ("Tag Word:            %s\n",
		   local_hex_string_custom (ftag, "04"));
  printf_filtered ("Instruction Pointer: %s:",
		   local_hex_string_custom (fiseg, "02"));
  printf_filtered ("%s\n", local_hex_string_custom (fioff, "08"));
  printf_filtered ("Operand Pointer:     %s:",
		   local_hex_string_custom (foseg, "02"));
  printf_filtered ("%s\n", local_hex_string_custom (fooff, "08"));
  printf_filtered ("Opcode:              %s\n",
		   local_hex_string_custom (fop ? (fop | 0xd800) : 0, "04"));
@


1.18.4.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@a30 1
#include "gdb_string.h"
d163 1
a163 1
print_i387_value (char *raw, struct ui_file *file)
d178 1
a178 1
  fprintf_filtered (file, " %-+27.19Lg", (long double) value);
d180 1
a180 1
  fprintf_filtered (file, " %-+27.19g", (double) value);
d186 1
a186 1
print_i387_ext (unsigned char *raw, struct ui_file *file)
d204 1
a204 1
	fprintf_filtered (file, " %cInf", (sign ? '-' : '+'));
d207 1
a207 1
	fputs_unfiltered (" Real Indefinite (QNaN)", file);
d210 1
a210 1
	fputs_filtered (" QNaN", file);
d213 1
a213 1
	fputs_filtered (" SNaN", file);
d217 1
a217 1
    print_i387_value (raw, file);
d221 1
a221 1
      print_i387_value (raw, file);
d225 1
a225 1
	fputs_filtered (" Pseudo-denormal", file);
d228 1
a228 1
	fputs_filtered (" Denormal", file);
d232 1
a232 1
    fputs_filtered (" Unsupported", file);
d237 1
a237 1
print_i387_status_word (unsigned int status, struct ui_file *file)
d239 1
a239 1
  fprintf_filtered (file, "Status Word:         %s",
d241 16
a256 16
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0001) ? "IE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0002) ? "DE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0004) ? "ZE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0008) ? "OE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0010) ? "UE" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0020) ? "PE" : "  ");
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0080) ? "ES" : "  ");
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0040) ? "SF" : "  ");
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (status & 0x0100) ? "C0" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0200) ? "C1" : "  ");
  fprintf_filtered (file, " %s", (status & 0x0400) ? "C2" : "  ");
  fprintf_filtered (file, " %s", (status & 0x4000) ? "C3" : "  ");
d258 1
a258 1
  fputs_filtered ("\n", file);
d260 1
a260 2
  fprintf_filtered (file,
		    "                       TOP: %d\n", ((status >> 11) & 7));
d265 1
a265 1
print_i387_control_word (unsigned int control, struct ui_file *file)
d267 1
a267 1
  fprintf_filtered (file, "Control Word:        %s",
d269 7
a275 7
  fputs_filtered ("  ", file);
  fprintf_filtered (file, " %s", (control & 0x0001) ? "IM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0002) ? "DM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0004) ? "ZM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0008) ? "OM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0010) ? "UM" : "  ");
  fprintf_filtered (file, " %s", (control & 0x0020) ? "PM" : "  ");
d277 1
a277 1
  fputs_filtered ("\n", file);
d279 1
a279 1
  fputs_filtered ("                       PC: ", file);
d283 1
a283 1
      fputs_filtered ("Single Precision (24-bits)\n", file);
d286 1
a286 1
      fputs_filtered ("Reserved\n", file);
d289 1
a289 1
      fputs_filtered ("Double Precision (53-bits)\n", file);
d292 1
a292 1
      fputs_filtered ("Extended Precision (64-bits)\n", file);
d296 1
a296 1
  fputs_filtered ("                       RC: ", file);
d300 1
a300 1
      fputs_filtered ("Round to nearest\n", file);
d303 1
a303 1
      fputs_filtered ("Round down\n", file);
d306 1
a306 1
      fputs_filtered ("Round up\n", file);
d309 1
a309 1
      fputs_filtered ("Round toward zero\n", file);
d314 1
a314 4
/* Print out the i387 floating point state.  Note that we ignore FRAME
   in the code below.  That's OK since floating-point registers are
   never saved on the stack.  */

d316 1
a316 2
i387_print_float_info (struct gdbarch *gdbarch, struct ui_file *file,
		       struct frame_info *frame, const char *args)
d346 1
a346 1
      fprintf_filtered (file, "%sR%d: ", fpreg == top ? "=>" : "  ", fpreg);
d351 1
a351 1
	  fputs_filtered ("Valid   ", file);
d354 1
a354 1
	  fputs_filtered ("Zero    ", file);
d357 1
a357 1
	  fputs_filtered ("Special ", file);
d360 1
a360 1
	  fputs_filtered ("Empty   ", file);
d366 1
a366 1
      fputs_filtered ("0x", file);
d368 1
a368 1
	fprintf_filtered (file, "%02x", raw[i]);
d371 1
a371 1
	print_i387_ext (raw, file);
d373 1
a373 1
      fputs_filtered ("\n", file);
d378 12
a389 12
  print_i387_status_word (fstat, file);
  print_i387_control_word (fctrl, file);
  fprintf_filtered (file, "Tag Word:            %s\n",
		    local_hex_string_custom (ftag, "04"));
  fprintf_filtered (file, "Instruction Pointer: %s:",
		    local_hex_string_custom (fiseg, "02"));
  fprintf_filtered (file, "%s\n", local_hex_string_custom (fioff, "08"));
  fprintf_filtered (file, "Operand Pointer:     %s:",
		    local_hex_string_custom (foseg, "02"));
  fprintf_filtered (file, "%s\n", local_hex_string_custom (fooff, "08"));
  fprintf_filtered (file, "Opcode:              %s\n",
		    local_hex_string_custom (fop ? (fop | 0xd800) : 0, "04"));
@


1.18.4.2
log
@merge from mainline
@
text
@d324 8
a331 9
  char buf[4];
  ULONGEST fctrl;
  ULONGEST fstat;
  ULONGEST ftag;
  ULONGEST fiseg;
  ULONGEST fioff;
  ULONGEST foseg;
  ULONGEST fooff;
  ULONGEST fop;
d335 9
a343 17
  frame_register_read (frame, FCTRL_REGNUM, buf);
  fctrl = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FSTAT_REGNUM, buf);
  fstat = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FTAG_REGNUM, buf);
  ftag = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FISEG_REGNUM, buf);
  fiseg = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FIOFF_REGNUM, buf);
  fioff = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOSEG_REGNUM, buf);
  foseg = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOOFF_REGNUM, buf);
  fooff = extract_unsigned_integer (buf, 4);
  frame_register_read (frame, FOP_REGNUM, buf);
  fop = extract_unsigned_integer (buf, 4);

d370 1
a370 1
      frame_register_read (frame, (fpreg + 8 - top) % 8 + FP0_REGNUM, raw);
d382 1
a382 1
  fputs_filtered ("\n", file);
@


1.17
log
@* Makefile.in (ALLDEPFILES): Remove i387-nat.c.
(i387-nat.o): Delete dependency list.
(go32-nat.o): Change i387-nat.h to i387-tdep.h.
(x86-64-linux-nat.o): Likewise.
* i387-nat.c: Delete file, moving contents to...
* i387-tdep.c: ...here.
* i387-nat.h: Rename...
* i387-tdep.h: ...to this.
* go32-nat.c: Include i387-tdep.h instead of i387-nat.h.
* i386-linux-nat.c: Likewise.
* i386bsd-nat.c: Likewise.
* i386gnu-nat.c: Likewise.
* i386nbsd-nat.c: Likewise.
* i386v4-nat.c: Likewise.
* x86-64-linux-nat.c: Likewise.
* config/i386/fbsd.mh (NATDEPFILES): Remove i387-nat.o.
* config/i386/go32.mh (NATDEPFILES): Likewise.
* config/i386/i386gnu.mh (NATDEPFILES): Likewise.
* config/i386/i386sol2.mh (NATDEPFILES): Likewise.
* config/i386/i386v42mp.mh (NATDEPFILES): Likewise.
* config/i386/linux.mh (NATDEPFILES): Likewise.
* config/i386/nbsd.mh (NATDEPFILES): Likewise.
* config/i386/nbsdelf.mh (NATDEPFILES): Likewise.
* config/i386/obsd.mh (NATDEPFILES): Likewise.
* config/i386/x86-64linux.mh (NATDEPFILES): Likewise.
@
text
@d2 2
a3 2
   Copyright 1988, 1989, 1991, 1992, 1993, 1994, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d545 4
a548 1
  int i;
d550 1
a550 1
  for (i = FP0_REGNUM; i <= MXCSR_REGNUM; i++)
d607 4
a610 1
  int i;
d612 1
a612 1
  for (i = FP0_REGNUM; i <= MXCSR_REGNUM; i++)
@


1.16
log
@* i386-tdep.h (FPU_REG_RAW_SIZE): Define unconditionally.
* i387-nat.c, i387-tdep.c: Unconditionally include "i386-tdep.h".
* config/i386/tm-i386.h (FPU_REG_RAW_SIZE): Removed.
(SIZEOF_FPU_REGS): Don't use FPU_REG_RAW_SIZE here.
@
text
@d391 308
@


1.15
log
@* i387-tdep.c (print_i387_value): Use extract_typed_floating to
convert RAW to a DOUBLEST instead of extract_floating.
@
text
@a32 1
#if GDB_MULTI_ARCH >0
a33 1
#endif
@


1.14
log
@* i386-tdep.h: New file.
* i387-nat.c: Include i386-tdep.h when multiarch.
* i387-tdep.c: Ditto.
@
text
@a167 2
  int len = TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT;
  char *tmp = alloca (len);
d169 5
a173 16
  /* This code only works on targets where ... */
  gdb_assert (TARGET_LONG_DOUBLE_FORMAT == &floatformat_i387_ext);

  /* Take care of the padding.  FP reg is 80 bits.  The same value in
     memory is 96 bits.  */
  gdb_assert (FPU_REG_RAW_SIZE < len);
  memcpy (tmp, raw, FPU_REG_RAW_SIZE);
  memset (tmp + FPU_REG_RAW_SIZE, 0, len - FPU_REG_RAW_SIZE);
  
  /* Extract the value as a DOUBLEST.  */
  /* Use extract_floating() rather than floatformat_to_doublest().
     The latter is lossy in nature.  Once GDB gets a host/target
     independent and non-lossy FP it will become possible to bypass
     extract_floating() and call floatformat*() directly.  Note also
     the assumptions about TARGET_LONG_DOUBLE above.  */
  value = extract_floating (tmp, len);
@


1.13
log
@* defs.h (HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_FLOAT_FORMAT, HOST_DOUBLE_FORMAT)
(HOST_LONG_DOUBLE_FORMAT, DOUBLEST)
(floatformat_to_doublest, floatformat_from_doublest)
(floatformat_is_negative, floatformat_is_nan)
(floatformat_mantissa, store_floating)
(extract_floating): Move declaration from here.
* doublest.h: To here.  New file.
* utils.c (get_field, floatformat_to_doublest, put_field)
(ldfrexp, floatformat_from_doublest, floatformat_is_negative)
(floatformat_is_nan, floatformat_mantissa)
(FLOATFORMAT_CHAR_BIT): Move from here.
* doublest.c: To here.  New file.
* findvar.c (store_floating, extract_floating): Move from here.
* doublest.c: To here.
* Makefile.in (SFILES): Add doublest.c.
(COMMON_OBS): Add doublest.o.
(doublest.o): Specify dependencies.
(doublest_h): Define.

* config/m88k/tm-m88k.h: Include "doublest.h".
* config/i960/tm-i960.h: Ditto.
* config/i386/tm-symmetry.h: Ditto.
* rs6000-tdep.c, valarith.c: Ditto.
* valprint.c, stabsread.c, sh-tdep.c: Ditto.
* ia64-tdep.c, i387-tdep.c, i386-tdep.c: Ditto.
* values.c, arm-tdep.c, arm-linux-tdep.c: Ditto.
* alpha-tdep.c, ax.h, expression.h: Ditto.
* sh-tdep.c, parse.c, top.c, value.h: Ditto.

* Makefile.in (arm-tdep.o): Add $(doublest_h).
(i386-tdep.o, i387-tdep.o, ia64-tdep.o): Ditto.
(rs6000-tdep.o, stabsread.o, valarith.o): Ditto.
(values.o, valprint.o, arm-linux-tdep.o): Ditto.
(alpha-tdep.o, ax_h, parse.o, top.o, value_h): Ditto.
(parser_defs_h): Ditto.
(expression_h): Add $(doublest_h) and $(symtab_h).
@
text
@d33 3
@


1.12
log
@I'm using the obvious fix rule to commit this.

Testing: I tested on native Red Hat Linux 7 using gcc 3.0.
The "info float" command exercises print_i387_value.

2001-07-06  Michael Chastain  <chastain@@redhat.com>

	* i387-tdep.c (print_i387_value): Fix pointer glitch.

===

Index: i387-tdep.c
===================================================================
RCS file: /cvs/src/src/gdb/i387-tdep.c,v
retrieving revision 1.11
diff -c -1 -0 -p -r1.11 i387-tdep.c
*** gdb/i387-tdep.c	2001/07/04 21:14:05	1.11
--- gdb/i387-tdep.c	2001/07/06 12:47:00
*************** print_i387_value (char *raw)
*** 163,184 ****
    DOUBLEST value;
    int len = TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT;
    char *tmp = alloca (len);

    /* This code only works on targets where ... */
    gdb_assert (TARGET_LONG_DOUBLE_FORMAT == &floatformat_i387_ext);

    /* Take care of the padding.  FP reg is 80 bits.  The same value in
       memory is 96 bits.  */
    gdb_assert (FPU_REG_RAW_SIZE < len);
!   memcpy (&tmp, raw, FPU_REG_RAW_SIZE);
!   memset (&tmp + FPU_REG_RAW_SIZE, 0, len - FPU_REG_RAW_SIZE);

    /* Extract the value as a DOUBLEST.  */
    /* Use extract_floating() rather than floatformat_to_doublest().
       The latter is lossy in nature.  Once GDB gets a host/target
       independent and non-lossy FP it will become possible to bypass
       extract_floating() and call floatformat*() directly.  Note also
       the assumptions about TARGET_LONG_DOUBLE above.  */
    value = extract_floating (tmp, len);

    /* We try to print 19 digits.  The last digit may or may not contain
--- 163,184 ----
    DOUBLEST value;
    int len = TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT;
    char *tmp = alloca (len);

    /* This code only works on targets where ... */
    gdb_assert (TARGET_LONG_DOUBLE_FORMAT == &floatformat_i387_ext);

    /* Take care of the padding.  FP reg is 80 bits.  The same value in
       memory is 96 bits.  */
    gdb_assert (FPU_REG_RAW_SIZE < len);
!   memcpy (tmp, raw, FPU_REG_RAW_SIZE);
!   memset (tmp + FPU_REG_RAW_SIZE, 0, len - FPU_REG_RAW_SIZE);

    /* Extract the value as a DOUBLEST.  */
    /* Use extract_floating() rather than floatformat_to_doublest().
       The latter is lossy in nature.  Once GDB gets a host/target
       independent and non-lossy FP it will become possible to bypass
       extract_floating() and call floatformat*() directly.  Note also
       the assumptions about TARGET_LONG_DOUBLE above.  */
    value = extract_floating (tmp, len);

    /* We try to print 19 digits.  The last digit may or may not contain
@
text
@d31 1
@


1.11
log
@* i387-tdep.c (print_i387_value): Add extra space after final full
stop in comment.
@
text
@d173 2
a174 2
  memcpy (&tmp, raw, FPU_REG_RAW_SIZE);
  memset (&tmp + FPU_REG_RAW_SIZE, 0, len - FPU_REG_RAW_SIZE);
@


1.10
log
@* i387-tdep.c: Include "gdb_assert.h".
(print_i387_value): Use extract_floating to extract the FP value
from a zero padded local buffer.
@
text
@d171 1
a171 1
     memory is 96 bits. */
@


1.9
log
@* i387-tdep.c (print_i387_status_word): Fix printing of Stack
fault flag.  It is bit 6 of the x87 FPU status word, not bit 7.
@
text
@d30 1
d164 2
d167 2
a168 2
  /* Avoid call to floatformat_to_doublest if possible to preserve as
     much information as possible.  */
d170 13
a182 12
#ifdef HAVE_LONG_DOUBLE
  if (sizeof (value) == sizeof (long double)
      && HOST_LONG_DOUBLE_FORMAT == &floatformat_i387_ext)
    {
      /* Copy straight over, but take care of the padding.  */
      memcpy (&value, raw, FPU_REG_RAW_SIZE);
      memset ((char *) &value + FPU_REG_RAW_SIZE, 0,
	      sizeof (value) - FPU_REG_RAW_SIZE);
    }
  else
#endif
    floatformat_to_doublest (&floatformat_i387_ext, raw, &value);
@


1.8
log
@Update/correct copyright notices.
@
text
@d258 1
a258 1
  printf_filtered (" %s", (status & 0x0080) ? "SF" : "  ");
@


1.7
log
@Create new file regcache.h.  Update all uses.
@
text
@d2 2
a3 2
   Copyright 1988, 89, 91, 98, 99, 2000, 2001 Free Software
   Foundation, Inc.
@


1.6
log
@Protoization.
@
text
@d2 2
a3 1
   Copyright (C) 1988, 89, 91, 98, 99, 2000 Free Software Foundation, Inc.
d29 1
@


1.5
log
@PARAMS removal.
@
text
@d37 1
a37 3
i387_to_double (from, to)
     char *from;
     char *to;
d43 1
a43 3
double_to_i387 (from, to)
     char *from;
     char *to;
d59 1
a59 2
print_387_control_bits (control)
     unsigned int control;
d115 1
a115 2
print_387_control_word (control)
     unsigned int control;
d123 1
a123 2
print_387_status_bits (status)
     unsigned int status;
d145 1
a145 2
print_387_status_word (status)
     unsigned int status;
@


1.4
log
@* i387-tdep.c (print_i387_value): Cast &value to (char *) in
pointer arithmetic.  Fixes a bug which manifested itself on
FreeBSD.
@
text
@d33 2
a34 2
void i387_to_double PARAMS ((char *from, char *to));
void double_to_i387 PARAMS ((char *from, char *to));
d59 2
a60 2
static void print_387_control_bits PARAMS ((unsigned int control));
static void print_387_status_bits PARAMS ((unsigned int status));
@


1.3
log
@2000-04-12  Mark Kettenis  <kettenis@@gnu.org>

	* i387-tdep.c (print_i387_value): Avoid call to
	floatformat_to_doublest if long double type is the same on host
	and target.
@
text
@d179 2
a180 1
      memset (&value + FPU_REG_RAW_SIZE, 0, sizeof (value) - FPU_REG_RAW_SIZE);
@


1.2
log
@2000-03-26  Mark Kettenis  <kettenis@@gnu.org>

	Provide `long double' support for most i386 targets.
	* config/i386/tm-i386.h (TARGET_LONG_DOUBLE_FORMAT): Define as
	&floatformat_i387_ext.
	(TARGET_LONG_DOUBLE_BITS): Define as 96.
	(REGISTER_VIRTUAL_TYPE): Change type for FPU registers to
	`builtin_type_long_double'.
	(REGISTER_CONVERT_TO_VIRTUAL): Call
	i386_register_convert_to_virtual.
	(REGISTER_CONVERT_TO_RAW): Call i386_register_convert_to_raw.
	(i387_to_double, double_to_i387): Remove prototypes.
	(i386_extract_return_value): Change prototype to match definition
	in i386-tdep.c.
	* config/i386/tm-i386mk.h (TARGET_LONG_DOUBLE_FORMAT): #undef.
	(TARGET_LONG_DOUBLE_BITS): #undef.
	* config/i386/tm-linux.h (TARGET_LONG_DOUBLE_BIT): Remove.
	[HAVE_LONG_DOUBLE && HOST_I386] (LD_I387): Remove.
	(i387_extract_floating, i387_store_floating): Remove prototypes.
	(TARGET_EXTRACT_FLOATING, TARGET_STORE_FLOATING): Remove.
	(REGISTER_CONVERT_TO_VIRTUAL, REGOISTER_CONVERT_TO_RAW): Remove.
	(REGISTER_VIRTUAL_TYPE): Remove.
	* i386-tdep.c (i386_register_convert_to_virtual): New function.
	(i386_register_convert_to_raw): New function.
	* i387-tdep.c [LD_I387] (i387_extract_floating): Remove.
	(i387_store_floating): Remove.
@
text
@d169 15
a183 2
  
  floatformat_to_doublest (&floatformat_i387_ext, raw, &value);
@


1.2.2.1
log
@2000-04-12  Mark Kettenis  <kettenis@@gnu.org>

	* i387-tdep.c (print_i387_value): Avoid call to
	floatformat_to_doublest if long double type is the same on host
	and target.
@
text
@d169 2
a170 15

  /* Avoid call to floatformat_to_doublest if possible to preserve as
     much information as possible.  */

#ifdef HAVE_LONG_DOUBLE
  if (sizeof (value) == sizeof (long double)
      && HOST_LONG_DOUBLE_FORMAT == &floatformat_i387_ext)
    {
      /* Copy straight over, but take care of the padding.  */
      memcpy (&value, raw, FPU_REG_RAW_SIZE);
      memset (&value + FPU_REG_RAW_SIZE, 0, sizeof (value) - FPU_REG_RAW_SIZE);
    }
  else
#endif
    floatformat_to_doublest (&floatformat_i387_ext, raw, &value);
@


1.2.2.2
log
@* i387-tdep.c (print_i387_value): Cast &value to (char *) in
pointer arithmetic.  Fixes a bug which manifested itself on
FreeBSD.
@
text
@d179 1
a179 2
      memset ((char *) &value + FPU_REG_RAW_SIZE, 0,
	      sizeof (value) - FPU_REG_RAW_SIZE);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1988, 1989, 1991, 1998 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of GDB.
d6 14
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d25 1
a28 1
void i387_to_double PARAMS ((char *, char *));
d30 2
a31 1
void double_to_i387 PARAMS ((char *, char *));
d33 2
a34 2
/* FIXME:  Eliminate these routines when we have the time to change all
   the callers.  */
d41 1
a41 1
  floatformat_to_double (&floatformat_i387_ext, from, (double *)to);
d49 68
a116 1
  floatformat_from_double (&floatformat_i387_ext, (double *)from, to);
d123 26
a148 31
  printf_unfiltered ("control %s: ", local_hex_string(control));
  printf_unfiltered ("compute to ");
  switch ((control >> 8) & 3) 
    {
    case 0: printf_unfiltered ("24 bits; "); break;
    case 1: printf_unfiltered ("(bad); "); break;
    case 2: printf_unfiltered ("53 bits; "); break;
    case 3: printf_unfiltered ("64 bits; "); break;
    }
  printf_unfiltered ("round ");
  switch ((control >> 10) & 3) 
    {
    case 0: printf_unfiltered ("NEAREST; "); break;
    case 1: printf_unfiltered ("DOWN; "); break;
    case 2: printf_unfiltered ("UP; "); break;
    case 3: printf_unfiltered ("CHOP; "); break;
    }
  if (control & 0x3f) 
    {
      printf_unfiltered ("mask:");
      if (control & 0x0001) printf_unfiltered (" INVALID");
      if (control & 0x0002) printf_unfiltered (" DENORM");
      if (control & 0x0004) printf_unfiltered (" DIVZ");
      if (control & 0x0008) printf_unfiltered (" OVERF");
      if (control & 0x0010) printf_unfiltered (" UNDERF");
      if (control & 0x0020) printf_unfiltered (" LOS");
      printf_unfiltered (";");
    }
  printf_unfiltered ("\n");
  if (control & 0xe080) warning ("reserved bits on: %s\n",
				local_hex_string(control & 0xe080));
d155 185
a339 2
  printf_unfiltered ("status %s: ", local_hex_string (status));
  if (status & 0xff) 
d341 35
a375 15
      printf_unfiltered ("exceptions:");
      if (status & 0x0001) printf_unfiltered (" INVALID");
      if (status & 0x0002) printf_unfiltered (" DENORM");
      if (status & 0x0004) printf_unfiltered (" DIVZ");
      if (status & 0x0008) printf_unfiltered (" OVERF");
      if (status & 0x0010) printf_unfiltered (" UNDERF");
      if (status & 0x0020) printf_unfiltered (" LOS");
      if (status & 0x0040) printf_unfiltered (" FPSTACK");
      printf_unfiltered ("; ");
    }
  printf_unfiltered ("flags: %d%d%d%d; ",
	  (status & 0x4000) != 0,
	  (status & 0x0400) != 0,
	  (status & 0x0200) != 0,
	  (status & 0x0100) != 0);
d377 12
a388 1
  printf_unfiltered ("top %d\n", (status >> 11) & 7);
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-1999-07-07 post reformat
@
text
@d4 1
a4 1
   This file is part of GDB.
d6 13
a18 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d39 1
a39 1
  floatformat_to_double (&floatformat_i387_ext, from, (double *) to);
d47 1
a47 1
  floatformat_from_double (&floatformat_i387_ext, (double *) from, to);
d54 1
a54 1
  printf_unfiltered ("control %s: ", local_hex_string (control));
d56 1
a56 1
  switch ((control >> 8) & 3)
d58 4
a61 12
    case 0:
      printf_unfiltered ("24 bits; ");
      break;
    case 1:
      printf_unfiltered ("(bad); ");
      break;
    case 2:
      printf_unfiltered ("53 bits; ");
      break;
    case 3:
      printf_unfiltered ("64 bits; ");
      break;
d64 1
a64 1
  switch ((control >> 10) & 3)
d66 4
a69 12
    case 0:
      printf_unfiltered ("NEAREST; ");
      break;
    case 1:
      printf_unfiltered ("DOWN; ");
      break;
    case 2:
      printf_unfiltered ("UP; ");
      break;
    case 3:
      printf_unfiltered ("CHOP; ");
      break;
d71 1
a71 1
  if (control & 0x3f)
d74 6
a79 12
      if (control & 0x0001)
	printf_unfiltered (" INVALID");
      if (control & 0x0002)
	printf_unfiltered (" DENORM");
      if (control & 0x0004)
	printf_unfiltered (" DIVZ");
      if (control & 0x0008)
	printf_unfiltered (" OVERF");
      if (control & 0x0010)
	printf_unfiltered (" UNDERF");
      if (control & 0x0020)
	printf_unfiltered (" LOS");
d83 2
a84 3
  if (control & 0xe080)
    warning ("reserved bits on: %s\n",
	     local_hex_string (control & 0xe080));
d92 1
a92 1
  if (status & 0xff)
d95 7
a101 14
      if (status & 0x0001)
	printf_unfiltered (" INVALID");
      if (status & 0x0002)
	printf_unfiltered (" DENORM");
      if (status & 0x0004)
	printf_unfiltered (" DIVZ");
      if (status & 0x0008)
	printf_unfiltered (" OVERF");
      if (status & 0x0010)
	printf_unfiltered (" UNDERF");
      if (status & 0x0020)
	printf_unfiltered (" LOS");
      if (status & 0x0040)
	printf_unfiltered (" FPSTACK");
d105 4
a108 4
		     (status & 0x4000) != 0,
		     (status & 0x0400) != 0,
		     (status & 0x0200) != 0,
		     (status & 0x0100) != 0);
@


1.1.1.3
log
@import gdb-1999-09-08 snapshot
@
text
@a24 1
#include "value.h"
d29 1
a31 3
static void print_387_control_bits PARAMS ((unsigned int control));
static void print_387_status_bits  PARAMS ((unsigned int status));

d51 2
a52 2
static void
print_387_control_bits (control)
d55 2
d60 1
a60 1
      puts_unfiltered (" 24 bit; ");
d63 1
a63 1
      puts_unfiltered (" (bad); ");
d66 1
a66 1
      puts_unfiltered (" 53 bit; ");
d69 1
a69 1
      puts_unfiltered (" 64 bit; ");
d72 1
d76 1
a76 1
      puts_unfiltered ("NEAR; ");
d79 1
a79 1
      puts_unfiltered ("DOWN; ");
d82 1
a82 1
      puts_unfiltered ("UP; ");
d85 1
a85 1
      puts_unfiltered ("CHOP; ");
d90 1
a90 1
      puts_unfiltered ("mask");
d92 1
a92 1
	puts_unfiltered (" INVAL");
d94 1
a94 1
	puts_unfiltered (" DENOR");
d96 1
a96 1
	puts_unfiltered (" DIVZ");
d98 1
a98 1
	puts_unfiltered (" OVERF");
d100 1
a100 1
	puts_unfiltered (" UNDER");
d102 2
a103 2
	puts_unfiltered (" LOS");
      puts_unfiltered (";");
d107 1
a107 1
    warning ("\nreserved bits on: %s",
d112 1
a112 10
print_387_control_word (control)
     unsigned int control;
{
  printf_filtered ("control %s:", local_hex_string(control & 0xffff));
  print_387_control_bits (control);
  puts_unfiltered ("\n");
}

static void
print_387_status_bits (status)
d115 21
a135 1
  printf_unfiltered (" flags %d%d%d%d; ",
a139 50
  printf_unfiltered ("top %d; ", (status >> 11) & 7);
  if (status & 0xff) 
    {
      puts_unfiltered ("excep");
      if (status & 0x0001) puts_unfiltered (" INVAL");
      if (status & 0x0002) puts_unfiltered (" DENOR");
      if (status & 0x0004) puts_unfiltered (" DIVZ");
      if (status & 0x0008) puts_unfiltered (" OVERF");
      if (status & 0x0010) puts_unfiltered (" UNDER");
      if (status & 0x0020) puts_unfiltered (" LOS");
      if (status & 0x0040) puts_unfiltered (" STACK");
    }
}

void
print_387_status_word (status)
     unsigned int status;
{
  printf_filtered ("status %s:", local_hex_string (status & 0xffff));
  print_387_status_bits (status);
  puts_unfiltered ("\n");
}

void
i387_print_register (raw_regs, regnum)
     char *raw_regs;
     int regnum;
{
  unsigned char virtual_buffer[MAX_REGISTER_VIRTUAL_SIZE];
  unsigned long val;
  int j, sign, special;
  unsigned swd, tags, expon, top, norm, ls, ms;
  char string[12];

#if (FPREG_RAW_SIZE != 10)
#error "Bad FPREG_RAW_SIZE"
#endif

  printf_filtered ("%8.8s: ", REGISTER_NAME (regnum));
  if (regnum < FPDATA_REGNUM)
    {
      val = extract_unsigned_integer (raw_regs + REGISTER_BYTE (regnum), 4);
      if ( (regnum < FPSTART_REGNUM + 3) ||
	   (regnum == FPSTART_REGNUM + 6) )
	/* Don't print the un-modifiable bytes. */
	sprintf(string, "0x%04x", val & 0xffff);
      else
	sprintf(string, "0x%08x", val);

      printf_unfiltered ("%10.10s", string);
d141 1
a141 150
      if (regnum == FPCONTROL_REGNUM)
	print_387_control_bits (val);
      else if (regnum == FPSTATUS_REGNUM)
	print_387_status_bits (val);
    }
  else
    {
      /* An FPU stack register. */
      if ( REGISTER_RAW_SIZE (regnum) != FPREG_RAW_SIZE )
	error ("GDB bug: i387-tdep.c (i387_print_register): wrong size for FPU stack register");

      /* Put the data in the buffer.  No conversions are ever necessary. */
      memcpy (virtual_buffer, raw_regs + REGISTER_BYTE (regnum),
	      FPREG_RAW_SIZE);

      swd = extract_signed_integer (raw_regs + REGISTER_BYTE (FPSTATUS_REGNUM),
				    4);
      top = (swd >> 11) & 7;
      tags = extract_signed_integer (raw_regs + REGISTER_BYTE (FPTAG_REGNUM),
				     4);

      puts_unfiltered ("0x");
      for (j = 0; j < FPREG_RAW_SIZE; j++)
	printf_unfiltered ("%02x",
			   (unsigned char)raw_regs[REGISTER_BYTE (regnum)
						  + FPREG_RAW_SIZE - 1 - j]);
      
      puts_unfiltered ("  ");
      special = 0;
      switch ((tags >> (((regnum - FPDATA_REGNUM + top) & 7) * 2)) & 3) 
	{
	case 0: puts_unfiltered ("Valid "); break;
	case 1: puts_unfiltered ("Zero  "); break;
	case 2: puts_unfiltered ("Spec  ");
	  special = 1;
	  break;
	case 3: puts_unfiltered ("Empty "); break;
	}

      expon = extract_unsigned_integer (raw_regs + REGISTER_BYTE (regnum)
					+ FPREG_RAW_SIZE - 2, 2);
      sign = expon & 0x8000;
      expon &= 0x7fff;
      ms = extract_unsigned_integer (raw_regs + REGISTER_BYTE (regnum) + 4, 4);
      ls = extract_signed_integer (raw_regs + REGISTER_BYTE (regnum), 4);
      norm = ms & 0x80000000;

      if ( expon == 0 )
	{
	  if ( ms | ls )
	    {
	      /* Denormal or Pseudodenormal. */
	      if ( norm )
		puts_unfiltered ("Pseudo ");
	      else
		puts_unfiltered ("Denorm ");
	    }
	  else
	    {
	      /* Zero. */
	      puts_unfiltered ("Zero   ");
	    }
	}
      else if ( expon == 0x7fff )
	{
	  /* Infinity, NaN or unsupported. */
	  if ( (ms == 0x80000000) &&
	       (ls == 0) )
	    {
              puts_unfiltered ("Infty  ");
	    }
	  else if ( norm )
	    {
	      if ( ms & 0x40000000 )
		puts_unfiltered ("QNaN   ");
	      else
		puts_unfiltered ("SNaN   ");
	    }
	  else
	    {
              puts_unfiltered ("Unsupp ");
	    }
	}
      else
	{
	  /* Normal or unsupported. */
	  if ( norm )
	    puts_unfiltered ("Normal ");
	  else
	    puts_unfiltered ("Unsupp ");
	}

      val_print (REGISTER_VIRTUAL_TYPE (regnum), virtual_buffer, 0, 0,
		 gdb_stdout, 0,
		 1, 0, Val_pretty_default);
    }
  puts_filtered ("\n");
}

void i387_float_info(void)
{
  char raw_regs [REGISTER_BYTES];
  int i;

  for (i = FPSTART_REGNUM; i <= FPEND_REGNUM; i++)
    read_relative_register_raw_bytes (i, raw_regs + REGISTER_BYTE (i));

  for (i = FPSTART_REGNUM; i <= FPEND_REGNUM; i++)
    i387_print_register (raw_regs, i);
}

#ifdef LD_I387
int
i387_extract_floating (PTR addr, int len, DOUBLEST *dretptr)
{
  if (len == TARGET_LONG_DOUBLE_BIT / 8)
    {
      if (HOST_LONG_DOUBLE_FORMAT == TARGET_LONG_DOUBLE_FORMAT)
	{
	  DOUBLEST retval;

	  memcpy (dretptr, addr, sizeof (retval));
	}
      else
	floatformat_to_doublest (TARGET_LONG_DOUBLE_FORMAT, addr, dretptr);

      return 1;
    }
  else
    return 0;
}

int
i387_store_floating (PTR addr, int len, DOUBLEST val)
{
  if (len == TARGET_LONG_DOUBLE_BIT / 8)
    {
      /* This `if' may be totally stupid.  I just put it in here to be
	 absolutely sure I'm preserving the semantics of the code I'm
	 frobbing, while I try to maintain portability boundaries; I
	 don't actually know exactly what it's doing.  -JimB, May 1999 */
      if (HOST_LONG_DOUBLE_FORMAT == TARGET_LONG_DOUBLE_FORMAT)
	memcpy (addr, &val, sizeof (val));
      else
	floatformat_from_doublest (TARGET_LONG_DOUBLE_FORMAT, &val, addr);

      return 1;
    }
  else
    return 0;
a142 1
#endif /* LD_I387 */
@


1.1.1.4
log
@import gdb-1999-09-13 snapshot
@
text
@d105 1
a105 1

@


1.1.1.5
log
@import gdb-1999-09-21
@
text
@d152 139
@


1.1.1.6
log
@import gdb-1999-12-07 snapshot
@
text
@d2 1
a2 1
   Copyright (C) 1988, 1989, 1991, 1998, 1999 Free Software Foundation, Inc.
d29 2
d32 2
a33 2
/* FIXME: Eliminate the next two functions when we have the time to
   change all the callers.  */
d35 2
a36 2
void i387_to_double PARAMS ((char *from, char *to));
void double_to_i387 PARAMS ((char *from, char *to));
a53 10

/* FIXME: The functions on this page are used by the old `info float'
   implementations that a few of the i386 targets provide.  These
   functions should be removed if all of these have been converted to
   use the generic implementation based on the new register file
   layout.  */

static void print_387_control_bits PARAMS ((unsigned int control));
static void print_387_status_bits PARAMS ((unsigned int status));

a151 237

/* Implement the `info float' layout based on the register definitions
   in `tm-i386.h'.  */

/* Print the floating point number specified by RAW.  */
static void
print_i387_value (char *raw)
{
  DOUBLEST value;
  
  floatformat_to_doublest (&floatformat_i387_ext, raw, &value);

  /* We try to print 19 digits.  The last digit may or may not contain
     garbage, but we'd better print one too many.  We need enough room
     to print the value, 1 position for the sign, 1 for the decimal
     point, 19 for the digits and 6 for the exponent adds up to 27.  */
#ifdef PRINTF_HAS_LONG_DOUBLE
  printf_filtered (" %-+27.19Lg", (long double) value);
#else
  printf_filtered (" %-+27.19g", (double) value);
#endif
}

/* Print the classification for the register contents RAW.  */
static void
print_i387_ext (unsigned char *raw)
{
  int sign;
  int integer;
  unsigned int exponent;
  unsigned long fraction[2];

  sign = raw[9] & 0x80;
  integer = raw[7] & 0x80;
  exponent = (((raw[9] & 0x7f) << 8) | raw[8]);
  fraction[0] = ((raw[3] << 24) | (raw[2] << 16) | (raw[1] << 8) | raw[0]);
  fraction[1] = (((raw[7] & 0x7f) << 24) | (raw[6] << 16)
		 | (raw[5] << 8) | raw[4]);

  if (exponent == 0x7fff && integer)
    {
      if (fraction[0] == 0x00000000 && fraction[1] == 0x00000000)
	/* Infinity.  */
	printf_filtered (" %cInf", (sign ? '-' : '+'));
      else if (sign && fraction[0] == 0x00000000 && fraction[1] == 0x40000000)
	/* Real Indefinite (QNaN).  */
	puts_unfiltered (" Real Indefinite (QNaN)");
      else if (fraction[1] & 0x40000000)
	/* QNaN.  */
	puts_filtered (" QNaN");
      else
	/* SNaN.  */
	puts_filtered (" SNaN");
    }
  else if (exponent < 0x7fff && exponent > 0x0000 && integer)
    /* Normal.  */
    print_i387_value (raw);
  else if (exponent == 0x0000)
    {
      /* Denormal or zero.  */
      print_i387_value (raw);
      
      if (integer)
	/* Pseudo-denormal.  */
	puts_filtered (" Pseudo-denormal");
      else if (fraction[0] || fraction[1])
	/* Denormal.  */
	puts_filtered (" Denormal");
    }
  else
    /* Unsupported.  */
    puts_filtered (" Unsupported");
}

/* Print the status word STATUS.  */
static void
print_i387_status_word (unsigned int status)
{
  printf_filtered ("Status Word:         %s",
		   local_hex_string_custom (status, "04"));
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0001) ? "IE" : "  ");
  printf_filtered (" %s", (status & 0x0002) ? "DE" : "  ");
  printf_filtered (" %s", (status & 0x0004) ? "ZE" : "  ");
  printf_filtered (" %s", (status & 0x0008) ? "OE" : "  ");
  printf_filtered (" %s", (status & 0x0010) ? "UE" : "  ");
  printf_filtered (" %s", (status & 0x0020) ? "PE" : "  ");
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0080) ? "ES" : "  ");
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0080) ? "SF" : "  ");
  puts_filtered ("  ");
  printf_filtered (" %s", (status & 0x0100) ? "C0" : "  ");
  printf_filtered (" %s", (status & 0x0200) ? "C1" : "  ");
  printf_filtered (" %s", (status & 0x0400) ? "C2" : "  ");
  printf_filtered (" %s", (status & 0x4000) ? "C3" : "  ");

  puts_filtered ("\n");

  printf_filtered ("                       TOP: %d\n", ((status >> 11) & 7));
}

/* Print the control word CONTROL.  */
static void
print_i387_control_word (unsigned int control)
{
  printf_filtered ("Control Word:        %s",
		   local_hex_string_custom (control, "04"));
  puts_filtered ("  ");
  printf_filtered (" %s", (control & 0x0001) ? "IM" : "  ");
  printf_filtered (" %s", (control & 0x0002) ? "DM" : "  ");
  printf_filtered (" %s", (control & 0x0004) ? "ZM" : "  ");
  printf_filtered (" %s", (control & 0x0008) ? "OM" : "  ");
  printf_filtered (" %s", (control & 0x0010) ? "UM" : "  ");
  printf_filtered (" %s", (control & 0x0020) ? "PM" : "  ");

  puts_filtered ("\n");

  puts_filtered ("                       PC: ");
  switch ((control >> 8) & 3)
    {
    case 0:
      puts_filtered ("Single Precision (24-bits)\n");
      break;
    case 1:
      puts_filtered ("Reserved\n");
      break;
    case 2:
      puts_filtered ("Double Precision (53-bits)\n");
      break;
    case 3:
      puts_filtered ("Extended Precision (64-bits)\n");
      break;
    }
      
  puts_filtered ("                       RC: ");
  switch ((control >> 10) & 3)
    {
    case 0:
      puts_filtered ("Round to nearest\n");
      break;
    case 1:
      puts_filtered ("Round down\n");
      break;
    case 2:
      puts_filtered ("Round up\n");
      break;
    case 3:
      puts_filtered ("Round toward zero\n");
      break;
    }
}

/* Print out the i387 floating poin state.  */
void
i387_float_info (void)
{
  unsigned int fctrl;
  unsigned int fstat;
  unsigned int ftag;
  unsigned int fiseg;
  unsigned int fioff;
  unsigned int foseg;
  unsigned int fooff;
  unsigned int fop;
  int fpreg;
  int top;

  fctrl = read_register (FCTRL_REGNUM);
  fstat = read_register (FSTAT_REGNUM);
  ftag  = read_register (FTAG_REGNUM);
  fiseg = read_register (FCS_REGNUM);
  fioff = read_register (FCOFF_REGNUM);
  foseg = read_register (FDS_REGNUM);
  fooff = read_register (FDOFF_REGNUM);
  fop   = read_register (FOP_REGNUM);
  
  top = ((fstat >> 11) & 7);

  for (fpreg = 7; fpreg >= 0; fpreg--)
    {
      unsigned char raw[FPU_REG_RAW_SIZE];
      int tag = (ftag >> (fpreg * 2)) & 3;
      int i;

      printf_filtered ("%sR%d: ", fpreg == top ? "=>" : "  ", fpreg);

      switch (tag)
	{
	case 0:
	  puts_filtered ("Valid   ");
	  break;
	case 1:
	  puts_filtered ("Zero    ");
	  break;
	case 2:
	  puts_filtered ("Special ");
	  break;
	case 3:
	  puts_filtered ("Empty   ");
	  break;
	}

      read_register_gen ((fpreg + 8 - top) % 8 + FP0_REGNUM, raw);

      puts_filtered ("0x");
      for (i = 9; i >= 0; i--)
	printf_filtered ("%02x", raw[i]);

      if (tag != 3)
	print_i387_ext (raw);

      puts_filtered ("\n");
    }

  puts_filtered ("\n");

  print_i387_status_word (fstat);
  print_i387_control_word (fctrl);
  printf_filtered ("Tag Word:            %s\n",
		   local_hex_string_custom (ftag, "04"));
  printf_filtered ("Instruction Pointer: %s:",
		   local_hex_string_custom (fiseg, "02"));
  printf_filtered ("%s\n", local_hex_string_custom (fioff, "08"));
  printf_filtered ("Operand Pointer:     %s:",
		   local_hex_string_custom (foseg, "02"));
  printf_filtered ("%s\n", local_hex_string_custom (fooff, "08"));
  printf_filtered ("Opcode:              %s\n",
		   local_hex_string_custom (fop ? (fop | 0xd800) : 0, "04"));
}


/* FIXME: The functions on this page are used to provide `long double'
   support for Linux.  However, the approach does not seem to be the
   right one, and we are planning to solve this in a way that should
   work for all i386 targets.  These functions will disappear in the
   near future, so please don't use them.  */
@


