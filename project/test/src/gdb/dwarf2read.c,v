head	1.844;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.755.2.1
	gdb_7_6-2013-04-26-release:1.755.2.1
	gdb_7_6-branch:1.755.0.2
	gdb_7_6-2013-03-12-branchpoint:1.755
	gdb_7_5_1-2012-11-29-release:1.687.2.2
	gdb_7_5-2012-08-17-release:1.687.2.1
	gdb_7_5-branch:1.687.0.2
	gdb_7_5-2012-07-18-branchpoint:1.687
	gdb_7_4_1-2012-04-26-release:1.586.2.2
	gdb_7_4-2012-01-24-release:1.586.2.2
	gdb_7_4-branch:1.586.0.2
	gdb_7_4-2011-12-13-branchpoint:1.586
	gdb_7_3_1-2011-09-04-release:1.518.2.9
	gdb_7_3-2011-07-26-release:1.518.2.9
	gdb_7_3-branch:1.518.0.2
	gdb_7_3-2011-04-01-branchpoint:1.518
	gdb_7_2-2010-09-02-release:1.409.2.4
	gdb_7_2-branch:1.409.0.2
	gdb_7_2-2010-07-07-branchpoint:1.409
	gdb_7_1-2010-03-18-release:1.356.2.2
	gdb_7_1-branch:1.356.0.2
	gdb_7_1-2010-02-18-branchpoint:1.356
	gdb_7_0_1-2009-12-22-release:1.327.2.1
	gdb_7_0-2009-10-06-release:1.327
	gdb_7_0-branch:1.327.0.2
	gdb_7_0-2009-09-16-branchpoint:1.327
	arc-sim-20090309:1.251.2.1.4.1
	msnyder-checkpoint-072509-branch:1.324.0.2
	msnyder-checkpoint-072509-branchpoint:1.324
	arc-insight_6_8-branch:1.251.2.1.0.4
	arc-insight_6_8-branchpoint:1.251.2.1
	insight_6_8-branch:1.251.2.1.0.2
	insight_6_8-branchpoint:1.251.2.1
	reverse-20081226-branch:1.291.0.4
	reverse-20081226-branchpoint:1.291
	multiprocess-20081120-branch:1.291.0.2
	multiprocess-20081120-branchpoint:1.291
	reverse-20080930-branch:1.285.0.2
	reverse-20080930-branchpoint:1.285
	reverse-20080717-branch:1.267.0.2
	reverse-20080717-branchpoint:1.267
	msnyder-reverse-20080609-branch:1.265.0.2
	msnyder-reverse-20080609-branchpoint:1.265
	drow-reverse-20070409-branch:1.216.0.2
	drow-reverse-20070409-branchpoint:1.216
	gdb_6_8-2008-03-27-release:1.251.2.1
	gdb_6_8-branch:1.251.0.2
	gdb_6_8-2008-02-26-branchpoint:1.251
	gdb_6_7_1-2007-10-29-release:1.231
	gdb_6_7-2007-10-10-release:1.231
	gdb_6_7-branch:1.231.0.2
	gdb_6_7-2007-09-07-branchpoint:1.231
	insight_6_6-20070208-release:1.206
	gdb_6_6-2006-12-18-release:1.206
	gdb_6_6-branch:1.206.0.2
	gdb_6_6-2006-11-15-branchpoint:1.206
	insight_6_5-20061003-release:1.196.2.1
	gdb-csl-symbian-6_4_50_20060226-12:1.193.8.2
	gdb-csl-sourcerygxx-3_4_4-25:1.186
	nickrob-async-20060828-mergepoint:1.203
	gdb-csl-symbian-6_4_50_20060226-11:1.193.8.1
	gdb-csl-sourcerygxx-4_1-17:1.193.2.3
	gdb-csl-20060226-branch-local-2:1.193.2.3
	gdb-csl-sourcerygxx-4_1-14:1.193.2.3
	gdb-csl-sourcerygxx-4_1-13:1.193.2.3
	gdb-csl-sourcerygxx-4_1-12:1.193.2.3
	gdb-csl-sourcerygxx-3_4_4-21:1.193.2.3
	gdb_6_5-20060621-release:1.196
	gdb-csl-sourcerygxx-4_1-9:1.193.2.3
	gdb-csl-sourcerygxx-4_1-8:1.193.2.3
	gdb-csl-sourcerygxx-4_1-7:1.193.2.3
	gdb-csl-arm-2006q1-6:1.193.2.3
	gdb-csl-sourcerygxx-4_1-6:1.193.2.3
	gdb-csl-symbian-6_4_50_20060226-10:1.193.8.1
	gdb-csl-symbian-6_4_50_20060226-9:1.193.8.1
	gdb-csl-symbian-6_4_50_20060226-8:1.193.8.1
	gdb-csl-coldfire-4_1-11:1.193.2.3
	gdb-csl-sourcerygxx-3_4_4-19:1.193.2.3
	gdb-csl-coldfire-4_1-10:1.193.2.3
	gdb_6_5-branch:1.196.0.2
	gdb_6_5-2006-05-14-branchpoint:1.196
	gdb-csl-sourcerygxx-4_1-5:1.193.2.3
	nickrob-async-20060513-branch:1.195.0.2
	nickrob-async-20060513-branchpoint:1.195
	gdb-csl-sourcerygxx-4_1-4:1.193.2.3
	msnyder-reverse-20060502-branch:1.194.0.2
	msnyder-reverse-20060502-branchpoint:1.194
	gdb-csl-morpho-4_1-4:1.193
	gdb-csl-sourcerygxx-3_4_4-17:1.193
	readline_5_1-import-branch:1.193.0.10
	readline_5_1-import-branchpoint:1.193
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.193
	gdb-csl-symbian-20060226-branch:1.193.0.8
	gdb-csl-symbian-20060226-branchpoint:1.193
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.193
	msnyder-reverse-20060331-branch:1.193.0.6
	msnyder-reverse-20060331-branchpoint:1.193
	gdb-csl-available-20060303-branch:1.193.0.4
	gdb-csl-available-20060303-branchpoint:1.193
	gdb-csl-20060226-branch:1.193.0.2
	gdb-csl-20060226-branchpoint:1.193
	gdb_6_4-20051202-release:1.184.2.2
	msnyder-fork-checkpoint-branch:1.186.0.4
	msnyder-fork-checkpoint-branchpoint:1.186
	gdb-csl-gxxpro-6_3-branch:1.186.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.186
	gdb_6_4-branch:1.184.0.2
	gdb_6_4-2005-11-01-branchpoint:1.184
	gdb-csl-arm-20051020-branch:1.183.0.2
	gdb-csl-arm-20051020-branchpoint:1.183
	msnyder-tracepoint-checkpoint-branch:1.181.0.4
	msnyder-tracepoint-checkpoint-branchpoint:1.181
	gdb-csl-arm-20050325-2005-q1b:1.181
	gdb-csl-arm-20050325-2005-q1a:1.181
	csl-arm-20050325-branch:1.181.0.2
	csl-arm-20050325-branchpoint:1.181
	gdb-post-i18n-errorwarning-20050211:1.171
	gdb-pre-i18n-errorwarning-20050211:1.170
	gdb_6_3-20041109-release:1.167
	gdb_6_3-branch:1.167.0.2
	gdb_6_3-20041019-branchpoint:1.167
	drow_intercu-merge-20040921:1.163
	drow_intercu-merge-20040915:1.160
	jimb-gdb_6_2-e500-branch:1.156.0.6
	jimb-gdb_6_2-e500-branchpoint:1.156
	gdb_6_2-20040730-release:1.156
	gdb_6_2-branch:1.156.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.156
	gdb_6_1_1-20040616-release:1.135.4.3
	gdb_6_1-2004-04-05-release:1.135.4.3
	drow_intercu-merge-20040402:1.142
	drow_intercu-merge-20040327:1.141
	ezannoni_pie-20040323-branch:1.141.0.2
	ezannoni_pie-20040323-branchpoint:1.141
	cagney_tramp-20040321-mergepoint:1.141
	cagney_tramp-20040309-branch:1.138.0.2
	cagney_tramp-20040309-branchpoint:1.138
	gdb_6_1-branch:1.135.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.135
	drow_intercu-20040221-branch:1.135.0.2
	drow_intercu-20040221-branchpoint:1.135
	cagney_bfdfile-20040213-branch:1.133.0.2
	cagney_bfdfile-20040213-branchpoint:1.133
	drow-cplus-merge-20040208:1.133
	carlton_dictionary-20040126-merge:1.124
	cagney_bigcore-20040122-branch:1.122.0.2
	cagney_bigcore-20040122-branchpoint:1.122
	drow-cplus-merge-20040113:1.119
	drow-cplus-merge-20031224:1.117
	drow-cplus-merge-20031220:1.117
	carlton_dictionary-20031215-merge:1.117
	drow-cplus-merge-20031214:1.117
	carlton-dictionary-20031111-merge:1.111
	gdb_6_0-2003-10-04-release:1.96.4.2
	kettenis_sparc-20030918-branch:1.106.0.4
	kettenis_sparc-20030918-branchpoint:1.106
	carlton_dictionary-20030917-merge:1.106
	ezannoni_pie-20030916-branchpoint:1.106
	ezannoni_pie-20030916-branch:1.106.0.2
	cagney_x86i386-20030821-branch:1.99.0.2
	cagney_x86i386-20030821-branchpoint:1.99
	carlton_dictionary-20030805-merge:1.99
	carlton_dictionary-20030627-merge:1.97
	gdb_6_0-branch:1.96.0.4
	gdb_6_0-2003-06-23-branchpoint:1.96
	jimb-ppc64-linux-20030613-branch:1.96.0.2
	jimb-ppc64-linux-20030613-branchpoint:1.96
	cagney_convert-20030606-branch:1.95.0.2
	cagney_convert-20030606-branchpoint:1.95
	cagney_writestrings-20030508-branch:1.92.0.4
	cagney_writestrings-20030508-branchpoint:1.92
	jimb-ppc64-linux-20030528-branch:1.94.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.94
	carlton_dictionary-20030523-merge:1.94
	cagney_fileio-20030521-branch:1.94.0.2
	cagney_fileio-20030521-branchpoint:1.94
	kettenis_i386newframe-20030517-mergepoint:1.94
	jimb-ppc64-linux-20030509-branch:1.92.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.92
	kettenis_i386newframe-20030504-mergepoint:1.90
	carlton_dictionary-20030430-merge:1.90
	kettenis_i386newframe-20030419-branch:1.90.0.2
	kettenis_i386newframe-20030419-branchpoint:1.90
	carlton_dictionary-20030416-merge:1.90
	cagney_frameaddr-20030409-mergepoint:1.88
	kettenis_i386newframe-20030406-branch:1.88.0.14
	kettenis_i386newframe-20030406-branchpoint:1.88
	cagney_frameaddr-20030403-branchpoint:1.88
	cagney_frameaddr-20030403-branch:1.88.0.12
	cagney_framebase-20030330-mergepoint:1.88
	cagney_framebase-20030326-branch:1.88.0.10
	cagney_framebase-20030326-branchpoint:1.88
	cagney_lazyid-20030317-branch:1.88.0.8
	cagney_lazyid-20030317-branchpoint:1.88
	kettenis-i386newframe-20030316-mergepoint:1.88
	offbyone-20030313-branch:1.88.0.6
	offbyone-20030313-branchpoint:1.88
	kettenis-i386newframe-20030308-branch:1.88.0.4
	kettenis-i386newframe-20030308-branchpoint:1.88
	carlton_dictionary-20030305-merge:1.88
	cagney_offbyone-20030303-branch:1.88.0.2
	cagney_offbyone-20030303-branchpoint:1.88
	carlton_dictionary-20030207-merge:1.85
	interps-20030203-mergepoint:1.83
	interps-20030202-branch:1.82.0.2
	interps-20030202-branchpoint:1.82
	cagney-unwind-20030108-branch:1.78.0.2
	cagney-unwind-20030108-branchpoint:1.78
	carlton_dictionary-20021223-merge:1.78
	gdb_5_3-2002-12-12-release:1.66.2.2
	carlton_dictionary-20021115-merge:1.75
	kseitz_interps-20021105-merge:1.72
	kseitz_interps-20021103-merge:1.72
	drow-cplus-merge-20021020:1.69
	drow-cplus-merge-20021025:1.71
	carlton_dictionary-20021025-merge:1.71
	jimb-dwarf-compression-021023-branch:1.71.0.2
	jimb-dwarf-compression-021023-branchpoint:1.71
	carlton_dictionary-20021011-merge:1.68
	drow-cplus-branch:1.67.0.2
	drow-cplus-branchpoint:1.67
	kseitz_interps-20020930-merge:1.66
	carlton_dictionary-20020927-merge:1.66
	carlton_dictionary-branch:1.66.0.4
	carlton_dictionary-20020920-branchpoint:1.66
	gdb_5_3-branch:1.66.0.2
	gdb_5_3-2002-09-04-branchpoint:1.66
	kseitz_interps-20020829-merge:1.65
	cagney_sysregs-20020825-branch:1.65.0.4
	cagney_sysregs-20020825-branchpoint:1.65
	readline_4_3-import-branch:1.65.0.2
	readline_4_3-import-branchpoint:1.65
	gdb_5_2_1-2002-07-23-release:1.49
	kseitz_interps-20020528-branch:1.58.0.2
	kseitz_interps-20020528-branchpoint:1.58
	cagney_regbuf-20020515-branch:1.56.0.2
	cagney_regbuf-20020515-branchpoint:1.56
	jimb-macro-020506-branch:1.54.0.2
	jimb-macro-020506-branchpoint:1.54
	gdb_5_2-2002-04-29-release:1.49
	gdb_5_2-branch:1.49.0.2
	gdb_5_2-2002-03-03-branchpoint:1.49
	gdb_5_1_1-2002-01-24-release:1.29.4.1
	gdb_5_1_0_1-2002-01-03-release:1.29
	cygnus_cvs_20020108_pre:1.42
	gdb_5_1_0_1-2002-01-03-branchpoint:1.29
	gdb_5_1_0_1-2002-01-03-branch:1.29.0.8
	gdb_5_1-2001-11-21-release:1.29
	gdb_s390-2001-09-26-branch:1.29.0.6
	gdb_s390-2001-09-26-branchpoint:1.29
	gdb_5_1-2001-07-29-branch:1.29.0.4
	gdb_5_1-2001-07-29-branchpoint:1.29
	dberlin-typesystem-branch:1.29.0.2
	dberlin-typesystem-branchpoint:1.29
	gdb-post-ptid_t-2001-05-03:1.24
	gdb-pre-ptid_t-2001-05-03:1.24
	insight-precleanup-2001-01-01:1.20
	gdb-post-protoization-2000-07-29:1.14
	gdb-pre-protoization-2000-07-29:1.13
	gdb-premipsmulti-2000-06-06-branch:1.9.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.9
	gdb-post-params-removal-2000-06-04:1.8
	gdb-pre-params-removal-2000-06-04:1.8
	gdb-post-params-removal-2000-05-28:1.8
	gdb-pre-params-removal-2000-05-28:1.7
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.2
	gdb_5_0-2000-04-10-branchpoint:1.4
	repo-unification-2000-02-06:1.1.1.10
	insight-2000-02-04:1.1.1.10
	gdb-2000-02-04:1.1.1.10
	gdb-2000-02-02:1.1.1.9
	gdb-2000-02-01:1.1.1.9
	gdb-2000-01-31:1.1.1.9
	gdb-2000-01-26:1.1.1.9
	gdb-2000-01-24:1.1.1.9
	gdb-2000-01-17:1.1.1.9
	gdb-2000-01-10:1.1.1.9
	gdb-2000-01-05:1.1.1.9
	gdb-1999-12-21:1.1.1.9
	gdb-1999-12-13:1.1.1.9
	gdb-1999-12-07:1.1.1.9
	gdb-1999-12-06:1.1.1.9
	gdb-1999-11-16:1.1.1.9
	gdb-1999-11-08:1.1.1.9
	gdb-1999-11-01:1.1.1.9
	gdb-1999-10-25:1.1.1.9
	gdb-1999-10-18:1.1.1.9
	gdb-1999-10-11:1.1.1.9
	gdb-1999-10-04:1.1.1.8
	gdb-1999-09-28:1.1.1.7
	gdb-1999-09-21:1.1.1.7
	gdb-1999-09-13:1.1.1.6
	gdb-1999-09-08:1.1.1.6
	gdb-1999-08-30:1.1.1.5
	gdb-1999-08-23:1.1.1.5
	gdb-1999-08-16:1.1.1.5
	gdb-1999-08-09:1.1.1.5
	gdb-1999-08-02:1.1.1.4
	gdb-1999-07-26:1.1.1.3
	gdb-1999-07-19:1.1.1.3
	gdb-1999-07-12:1.1.1.3
	gdb-post-reformat-19990707:1.1.1.3
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.3
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.844
date	2013.10.16.02.55.27;	author sergiodj;	state Exp;
branches;
next	1.843;

1.843
date	2013.10.09.14.26.26;	author tromey;	state Exp;
branches;
next	1.842;

1.842
date	2013.10.08.19.56.15;	author tromey;	state Exp;
branches;
next	1.841;

1.841
date	2013.10.05.02.10.29;	author devans;	state Exp;
branches;
next	1.840;

1.840
date	2013.10.05.01.44.17;	author devans;	state Exp;
branches;
next	1.839;

1.839
date	2013.09.27.21.34.04;	author devans;	state Exp;
branches;
next	1.838;

1.838
date	2013.09.27.20.33.20;	author devans;	state Exp;
branches;
next	1.837;

1.837
date	2013.09.27.18.48.41;	author devans;	state Exp;
branches;
next	1.836;

1.836
date	2013.09.25.21.44.11;	author devans;	state Exp;
branches;
next	1.835;

1.835
date	2013.09.24.14.03.43;	author jkratoch;	state Exp;
branches;
next	1.834;

1.834
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.833;

1.833
date	2013.09.17.22.12.55;	author devans;	state Exp;
branches;
next	1.832;

1.832
date	2013.09.04.23.05.31;	author devans;	state Exp;
branches;
next	1.831;

1.831
date	2013.09.04.20.09.39;	author jkratoch;	state Exp;
branches;
next	1.830;

1.830
date	2013.08.27.21.38.05;	author devans;	state Exp;
branches;
next	1.829;

1.829
date	2013.08.26.18.43.39;	author devans;	state Exp;
branches;
next	1.828;

1.828
date	2013.08.26.18.38.37;	author devans;	state Exp;
branches;
next	1.827;

1.827
date	2013.08.20.18.57.00;	author devans;	state Exp;
branches;
next	1.826;

1.826
date	2013.08.09.17.39.38;	author devans;	state Exp;
branches;
next	1.825;

1.825
date	2013.08.09.17.26.40;	author devans;	state Exp;
branches;
next	1.824;

1.824
date	2013.08.07.20.10.36;	author tromey;	state Exp;
branches;
next	1.823;

1.823
date	2013.08.07.20.06.37;	author tromey;	state Exp;
branches;
next	1.822;

1.822
date	2013.08.07.19.57.51;	author tromey;	state Exp;
branches;
next	1.821;

1.821
date	2013.08.02.00.33.07;	author devans;	state Exp;
branches;
next	1.820;

1.820
date	2013.08.01.23.35.04;	author devans;	state Exp;
branches;
next	1.819;

1.819
date	2013.07.31.00.30.18;	author devans;	state Exp;
branches;
next	1.818;

1.818
date	2013.07.30.08.36.13;	author sagovic;	state Exp;
branches;
next	1.817;

1.817
date	2013.07.30.08.31.36;	author sagovic;	state Exp;
branches;
next	1.816;

1.816
date	2013.07.30.08.17.05;	author sagovic;	state Exp;
branches;
next	1.815;

1.815
date	2013.07.24.15.45.32;	author devans;	state Exp;
branches;
next	1.814;

1.814
date	2013.07.23.06.56.53;	author tromey;	state Exp;
branches;
next	1.813;

1.813
date	2013.07.22.17.58.51;	author tromey;	state Exp;
branches;
next	1.812;

1.812
date	2013.07.22.17.53.55;	author tromey;	state Exp;
branches;
next	1.811;

1.811
date	2013.07.17.15.22.30;	author tromey;	state Exp;
branches;
next	1.810;

1.810
date	2013.07.01.19.55.17;	author tromey;	state Exp;
branches;
next	1.809;

1.809
date	2013.06.20.22.16.28;	author devans;	state Exp;
branches;
next	1.808;

1.808
date	2013.06.20.21.58.58;	author devans;	state Exp;
branches;
next	1.807;

1.807
date	2013.06.19.04.38.51;	author devans;	state Exp;
branches;
next	1.806;

1.806
date	2013.06.18.23.35.24;	author brobecke;	state Exp;
branches;
next	1.805;

1.805
date	2013.06.18.15.50.33;	author jkratoch;	state Exp;
branches;
next	1.804;

1.804
date	2013.06.13.23.01.37;	author devans;	state Exp;
branches;
next	1.803;

1.803
date	2013.06.06.23.51.09;	author devans;	state Exp;
branches;
next	1.802;

1.802
date	2013.05.23.18.31.29;	author palves;	state Exp;
branches;
next	1.801;

1.801
date	2013.05.20.17.24.21;	author devans;	state Exp;
branches;
next	1.800;

1.800
date	2013.05.20.09.45.13;	author brobecke;	state Exp;
branches;
next	1.799;

1.799
date	2013.05.16.07.39.43;	author brobecke;	state Exp;
branches;
next	1.798;

1.798
date	2013.05.13.16.56.09;	author tromey;	state Exp;
branches;
next	1.797;

1.797
date	2013.05.06.19.44.03;	author tromey;	state Exp;
branches;
next	1.796;

1.796
date	2013.05.06.19.39.09;	author tromey;	state Exp;
branches;
next	1.795;

1.795
date	2013.05.06.19.28.36;	author tromey;	state Exp;
branches;
next	1.794;

1.794
date	2013.05.06.19.15.17;	author devans;	state Exp;
branches;
next	1.793;

1.793
date	2013.04.30.23.19.41;	author devans;	state Exp;
branches;
next	1.792;

1.792
date	2013.04.30.21.11.50;	author devans;	state Exp;
branches;
next	1.791;

1.791
date	2013.04.29.09.52.07;	author muller;	state Exp;
branches;
next	1.790;

1.790
date	2013.04.29.05.05.44;	author brobecke;	state Exp;
branches;
next	1.789;

1.789
date	2013.04.25.16.25.36;	author tromey;	state Exp;
branches;
next	1.788;

1.788
date	2013.04.24.19.12.26;	author devans;	state Exp;
branches;
next	1.787;

1.787
date	2013.04.22.16.46.14;	author tromey;	state Exp;
branches;
next	1.786;

1.786
date	2013.04.19.15.34.46;	author palves;	state Exp;
branches;
next	1.785;

1.785
date	2013.04.19.15.09.45;	author palves;	state Exp;
branches;
next	1.784;

1.784
date	2013.04.17.17.09.30;	author devans;	state Exp;
branches;
next	1.783;

1.783
date	2013.04.15.23.53.38;	author devans;	state Exp;
branches;
next	1.782;

1.782
date	2013.04.15.22.14.40;	author devans;	state Exp;
branches;
next	1.781;

1.781
date	2013.04.15.17.30.36;	author tromey;	state Exp;
branches;
next	1.780;

1.780
date	2013.04.12.14.55.28;	author tromey;	state Exp;
branches;
next	1.779;

1.779
date	2013.04.08.19.56.03;	author tromey;	state Exp;
branches;
next	1.778;

1.778
date	2013.04.08.19.48.30;	author tromey;	state Exp;
branches;
next	1.777;

1.777
date	2013.04.05.21.48.25;	author devans;	state Exp;
branches;
next	1.776;

1.776
date	2013.04.03.19.45.00;	author devans;	state Exp;
branches;
next	1.775;

1.775
date	2013.04.03.19.11.01;	author devans;	state Exp;
branches;
next	1.774;

1.774
date	2013.04.02.21.18.40;	author devans;	state Exp;
branches;
next	1.773;

1.773
date	2013.04.01.23.17.40;	author devans;	state Exp;
branches;
next	1.772;

1.772
date	2013.04.01.22.36.08;	author devans;	state Exp;
branches;
next	1.771;

1.771
date	2013.04.01.16.42.15;	author devans;	state Exp;
branches;
next	1.770;

1.770
date	2013.03.29.21.47.51;	author devans;	state Exp;
branches;
next	1.769;

1.769
date	2013.03.29.21.42.04;	author devans;	state Exp;
branches;
next	1.768;

1.768
date	2013.03.29.18.46.07;	author devans;	state Exp;
branches;
next	1.767;

1.767
date	2013.03.29.17.48.48;	author devans;	state Exp;
branches;
next	1.766;

1.766
date	2013.03.29.16.55.57;	author devans;	state Exp;
branches;
next	1.765;

1.765
date	2013.03.29.16.38.52;	author devans;	state Exp;
branches;
next	1.764;

1.764
date	2013.03.29.00.35.20;	author devans;	state Exp;
branches;
next	1.763;

1.763
date	2013.03.29.00.18.32;	author devans;	state Exp;
branches;
next	1.762;

1.762
date	2013.03.29.00.11.10;	author devans;	state Exp;
branches;
next	1.761;

1.761
date	2013.03.28.22.59.47;	author devans;	state Exp;
branches;
next	1.760;

1.760
date	2013.03.28.17.41.03;	author devans;	state Exp;
branches;
next	1.759;

1.759
date	2013.03.28.17.35.01;	author devans;	state Exp;
branches;
next	1.758;

1.758
date	2013.03.20.18.35.22;	author tromey;	state Exp;
branches;
next	1.757;

1.757
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.756;

1.756
date	2013.03.14.16.36.27;	author jkratoch;	state Exp;
branches;
next	1.755;

1.755
date	2013.03.10.18.03.57;	author jkratoch;	state Exp;
branches
	1.755.2.1;
next	1.754;

1.754
date	2013.02.18.21.04.27;	author tromey;	state Exp;
branches;
next	1.753;

1.753
date	2013.02.03.16.25.55;	author jkratoch;	state Exp;
branches;
next	1.752;

1.752
date	2013.02.03.16.22.29;	author jkratoch;	state Exp;
branches;
next	1.751;

1.751
date	2013.02.03.16.20.18;	author jkratoch;	state Exp;
branches;
next	1.750;

1.750
date	2013.02.03.16.13.29;	author jkratoch;	state Exp;
branches;
next	1.749;

1.749
date	2013.02.03.16.03.07;	author jkratoch;	state Exp;
branches;
next	1.748;

1.748
date	2013.02.03.16.00.35;	author jkratoch;	state Exp;
branches;
next	1.747;

1.747
date	2013.02.03.15.54.16;	author jkratoch;	state Exp;
branches;
next	1.746;

1.746
date	2013.01.31.17.41.08;	author tromey;	state Exp;
branches;
next	1.745;

1.745
date	2013.01.30.18.45.39;	author tromey;	state Exp;
branches;
next	1.744;

1.744
date	2013.01.30.17.19.57;	author tromey;	state Exp;
branches;
next	1.743;

1.743
date	2013.01.29.19.26.20;	author tromey;	state Exp;
branches;
next	1.742;

1.742
date	2013.01.25.17.57.31;	author tromey;	state Exp;
branches;
next	1.741;

1.741
date	2013.01.25.17.55.24;	author tromey;	state Exp;
branches;
next	1.740;

1.740
date	2013.01.25.17.36.01;	author tromey;	state Exp;
branches;
next	1.739;

1.739
date	2013.01.23.18.47.50;	author devans;	state Exp;
branches;
next	1.738;

1.738
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.737;

1.737
date	2013.01.21.18.10.33;	author tromey;	state Exp;
branches;
next	1.736;

1.736
date	2013.01.21.18.08.53;	author tromey;	state Exp;
branches;
next	1.735;

1.735
date	2013.01.21.18.01.33;	author tromey;	state Exp;
branches;
next	1.734;

1.734
date	2013.01.21.16.46.12;	author jkratoch;	state Exp;
branches;
next	1.733;

1.733
date	2013.01.18.03.09.42;	author qiyao;	state Exp;
branches;
next	1.732;

1.732
date	2013.01.17.23.21.41;	author devans;	state Exp;
branches;
next	1.731;

1.731
date	2013.01.15.21.32.36;	author jkratoch;	state Exp;
branches;
next	1.730;

1.730
date	2013.01.14.20.59.26;	author tromey;	state Exp;
branches;
next	1.729;

1.729
date	2013.01.14.20.51.46;	author tromey;	state Exp;
branches;
next	1.728;

1.728
date	2013.01.14.10.39.33;	author qiyao;	state Exp;
branches;
next	1.727;

1.727
date	2013.01.09.20.46.03;	author devans;	state Exp;
branches;
next	1.726;

1.726
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.725;

1.725
date	2012.12.24.19.42.15;	author jkratoch;	state Exp;
branches;
next	1.724;

1.724
date	2012.12.16.18.57.16;	author jkratoch;	state Exp;
branches;
next	1.723;

1.723
date	2012.12.14.20.33.27;	author tromey;	state Exp;
branches;
next	1.722;

1.722
date	2012.12.12.17.03.02;	author tromey;	state Exp;
branches;
next	1.721;

1.721
date	2012.12.11.19.50.53;	author tromey;	state Exp;
branches;
next	1.720;

1.720
date	2012.12.10.22.02.34;	author devans;	state Exp;
branches;
next	1.719;

1.719
date	2012.12.10.21.06.00;	author devans;	state Exp;
branches;
next	1.718;

1.718
date	2012.12.10.17.17.27;	author tromey;	state Exp;
branches;
next	1.717;

1.717
date	2012.12.09.18.39.59;	author jkratoch;	state Exp;
branches;
next	1.716;

1.716
date	2012.12.09.17.35.41;	author jkratoch;	state Exp;
branches;
next	1.715;

1.715
date	2012.12.03.22.31.03;	author devans;	state Exp;
branches;
next	1.714;

1.714
date	2012.11.26.15.54.29;	author tromey;	state Exp;
branches;
next	1.713;

1.713
date	2012.11.20.22.51.04;	author muller;	state Exp;
branches;
next	1.712;

1.712
date	2012.11.15.08.31.23;	author muller;	state Exp;
branches;
next	1.711;

1.711
date	2012.11.12.17.14.54;	author tromey;	state Exp;
branches;
next	1.710;

1.710
date	2012.11.05.15.50.21;	author devans;	state Exp;
branches;
next	1.709;

1.709
date	2012.10.11.02.21.50;	author devans;	state Exp;
branches;
next	1.708;

1.708
date	2012.10.11.02.07.22;	author devans;	state Exp;
branches;
next	1.707;

1.707
date	2012.09.26.19.50.12;	author tromey;	state Exp;
branches;
next	1.706;

1.706
date	2012.09.26.19.38.31;	author tromey;	state Exp;
branches;
next	1.705;

1.705
date	2012.09.19.20.06.47;	author devans;	state Exp;
branches;
next	1.704;

1.704
date	2012.09.12.18.57.40;	author devans;	state Exp;
branches;
next	1.703;

1.703
date	2012.09.11.22.42.22;	author devans;	state Exp;
branches;
next	1.702;

1.702
date	2012.08.27.16.37.45;	author jkratoch;	state Exp;
branches;
next	1.701;

1.701
date	2012.08.22.16.12.48;	author tromey;	state Exp;
branches;
next	1.700;

1.700
date	2012.08.15.14.18.18;	author tromey;	state Exp;
branches;
next	1.699;

1.699
date	2012.08.02.09.36.37;	author qiyao;	state Exp;
branches;
next	1.698;

1.698
date	2012.07.26.02.03.16;	author siddhesh;	state Exp;
branches;
next	1.697;

1.697
date	2012.07.20.17.38.04;	author devans;	state Exp;
branches;
next	1.696;

1.696
date	2012.07.20.16.51.51;	author tromey;	state Exp;
branches;
next	1.695;

1.695
date	2012.07.20.16.12.44;	author tromey;	state Exp;
branches;
next	1.694;

1.694
date	2012.07.19.16.35.48;	author devans;	state Exp;
branches;
next	1.693;

1.693
date	2012.07.18.20.01.27;	author tromey;	state Exp;
branches;
next	1.692;

1.692
date	2012.07.18.19.59.35;	author tromey;	state Exp;
branches;
next	1.691;

1.691
date	2012.07.18.19.57.21;	author tromey;	state Exp;
branches;
next	1.690;

1.690
date	2012.07.18.19.53.05;	author tromey;	state Exp;
branches;
next	1.689;

1.689
date	2012.07.18.19.34.57;	author tromey;	state Exp;
branches;
next	1.688;

1.688
date	2012.07.18.19.33.33;	author tromey;	state Exp;
branches;
next	1.687;

1.687
date	2012.07.16.03.22.40;	author devans;	state Exp;
branches
	1.687.2.1;
next	1.686;

1.686
date	2012.07.13.20.26.10;	author jkratoch;	state Exp;
branches;
next	1.685;

1.685
date	2012.07.13.20.15.03;	author jkratoch;	state Exp;
branches;
next	1.684;

1.684
date	2012.07.10.20.28.32;	author devans;	state Exp;
branches;
next	1.683;

1.683
date	2012.07.10.01.05.06;	author devans;	state Exp;
branches;
next	1.682;

1.682
date	2012.07.09.20.27.53;	author devans;	state Exp;
branches;
next	1.681;

1.681
date	2012.07.09.18.21.31;	author devans;	state Exp;
branches;
next	1.680;

1.680
date	2012.07.06.00.01.11;	author devans;	state Exp;
branches;
next	1.679;

1.679
date	2012.07.02.20.02.39;	author devans;	state Exp;
branches;
next	1.678;

1.678
date	2012.07.02.18.13.41;	author devans;	state Exp;
branches;
next	1.677;

1.677
date	2012.07.01.02.05.12;	author devans;	state Exp;
branches;
next	1.676;

1.676
date	2012.06.29.00.52.41;	author devans;	state Exp;
branches;
next	1.675;

1.675
date	2012.06.29.00.28.23;	author devans;	state Exp;
branches;
next	1.674;

1.674
date	2012.06.29.00.20.37;	author devans;	state Exp;
branches;
next	1.673;

1.673
date	2012.06.29.00.06.18;	author devans;	state Exp;
branches;
next	1.672;

1.672
date	2012.06.28.01.10.37;	author devans;	state Exp;
branches;
next	1.671;

1.671
date	2012.06.27.14.26.09;	author devans;	state Exp;
branches;
next	1.670;

1.670
date	2012.06.27.00.35.33;	author devans;	state Exp;
branches;
next	1.669;

1.669
date	2012.06.26.21.56.46;	author devans;	state Exp;
branches;
next	1.668;

1.668
date	2012.06.26.20.14.01;	author devans;	state Exp;
branches;
next	1.667;

1.667
date	2012.06.26.19.48.13;	author devans;	state Exp;
branches;
next	1.666;

1.666
date	2012.06.23.22.23.46;	author devans;	state Exp;
branches;
next	1.665;

1.665
date	2012.06.19.00.37.18;	author devans;	state Exp;
branches;
next	1.664;

1.664
date	2012.06.17.19.53.52;	author jkratoch;	state Exp;
branches;
next	1.663;

1.663
date	2012.06.17.19.50.52;	author jkratoch;	state Exp;
branches;
next	1.662;

1.662
date	2012.06.15.16.19.01;	author tromey;	state Exp;
branches;
next	1.661;

1.661
date	2012.06.11.20.19.22;	author tromey;	state Exp;
branches;
next	1.660;

1.660
date	2012.06.11.18.45.01;	author tromey;	state Exp;
branches;
next	1.659;

1.659
date	2012.06.07.17.30.12;	author devans;	state Exp;
branches;
next	1.658;

1.658
date	2012.06.04.02.57.28;	author devans;	state Exp;
branches;
next	1.657;

1.657
date	2012.05.29.14.23.39;	author tromey;	state Exp;
branches;
next	1.656;

1.656
date	2012.05.24.22.09.20;	author jkratoch;	state Exp;
branches;
next	1.655;

1.655
date	2012.05.22.18.45.22;	author devans;	state Exp;
branches;
next	1.654;

1.654
date	2012.05.20.17.15.29;	author devans;	state Exp;
branches;
next	1.653;

1.653
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.652;

1.652
date	2012.05.18.14.26.25;	author tromey;	state Exp;
branches;
next	1.651;

1.651
date	2012.05.16.22.10.48;	author sergiodj;	state Exp;
branches;
next	1.650;

1.650
date	2012.05.16.20.31.09;	author tromey;	state Exp;
branches;
next	1.649;

1.649
date	2012.05.10.20.17.51;	author tromey;	state Exp;
branches;
next	1.648;

1.648
date	2012.05.07.15.18.38;	author tromey;	state Exp;
branches;
next	1.647;

1.647
date	2012.05.03.05.27.36;	author devans;	state Exp;
branches;
next	1.646;

1.646
date	2012.05.01.03.00.35;	author devans;	state Exp;
branches;
next	1.645;

1.645
date	2012.04.30.15.50.40;	author devans;	state Exp;
branches;
next	1.644;

1.644
date	2012.04.28.23.22.13;	author devans;	state Exp;
branches;
next	1.643;

1.643
date	2012.04.28.22.46.17;	author devans;	state Exp;
branches;
next	1.642;

1.642
date	2012.04.28.04.38.14;	author devans;	state Exp;
branches;
next	1.641;

1.641
date	2012.04.27.18.55.19;	author mark;	state Exp;
branches;
next	1.640;

1.640
date	2012.04.26.20.32.30;	author jkratoch;	state Exp;
branches;
next	1.639;

1.639
date	2012.04.25.14.07.19;	author devans;	state Exp;
branches;
next	1.638;

1.638
date	2012.04.23.16.46.02;	author devans;	state Exp;
branches;
next	1.637;

1.637
date	2012.04.18.06.52.32;	author jkratoch;	state Exp;
branches;
next	1.636;

1.636
date	2012.04.18.06.46.46;	author jkratoch;	state Exp;
branches;
next	1.635;

1.635
date	2012.04.18.06.24.48;	author devans;	state Exp;
branches;
next	1.634;

1.634
date	2012.04.18.06.21.09;	author devans;	state Exp;
branches;
next	1.633;

1.633
date	2012.04.17.13.55.30;	author palves;	state Exp;
branches;
next	1.632;

1.632
date	2012.04.13.02.03.21;	author devans;	state Exp;
branches;
next	1.631;

1.631
date	2012.04.12.02.09.14;	author devans;	state Exp;
branches;
next	1.630;

1.630
date	2012.04.12.01.39.22;	author devans;	state Exp;
branches;
next	1.629;

1.629
date	2012.04.10.18.56.31;	author devans;	state Exp;
branches;
next	1.628;

1.628
date	2012.04.07.19.35.17;	author devans;	state Exp;
branches;
next	1.627;

1.627
date	2012.03.19.19.59.19;	author jkratoch;	state Exp;
branches;
next	1.626;

1.626
date	2012.03.16.18.26.00;	author jkratoch;	state Exp;
branches;
next	1.625;

1.625
date	2012.03.16.16.47.30;	author gary;	state Exp;
branches;
next	1.624;

1.624
date	2012.03.15.02.34.49;	author devans;	state Exp;
branches;
next	1.623;

1.623
date	2012.03.13.17.16.18;	author devans;	state Exp;
branches;
next	1.622;

1.622
date	2012.03.09.20.17.32;	author tromey;	state Exp;
branches;
next	1.621;

1.621
date	2012.03.09.20.06.18;	author tromey;	state Exp;
branches;
next	1.620;

1.620
date	2012.03.08.19.37.07;	author jkratoch;	state Exp;
branches;
next	1.619;

1.619
date	2012.03.06.23.41.50;	author brobecke;	state Exp;
branches;
next	1.618;

1.618
date	2012.03.02.01.55.15;	author devans;	state Exp;
branches;
next	1.617;

1.617
date	2012.03.01.21.13.58;	author palves;	state Exp;
branches;
next	1.616;

1.616
date	2012.03.01.19.55.35;	author devans;	state Exp;
branches;
next	1.615;

1.615
date	2012.02.22.14.55.25;	author gary;	state Exp;
branches;
next	1.614;

1.614
date	2012.02.20.20.56.12;	author tromey;	state Exp;
branches;
next	1.613;

1.613
date	2012.02.20.19.24.39;	author tromey;	state Exp;
branches;
next	1.612;

1.612
date	2012.02.07.04.48.19;	author devans;	state Exp;
branches;
next	1.611;

1.611
date	2012.01.30.20.10.32;	author tromey;	state Exp;
branches;
next	1.610;

1.610
date	2012.01.26.22.01.36;	author devans;	state Exp;
branches;
next	1.609;

1.609
date	2012.01.26.04.21.39;	author brobecke;	state Exp;
branches;
next	1.608;

1.608
date	2012.01.16.20.40.50;	author tromey;	state Exp;
branches;
next	1.607;

1.607
date	2012.01.16.19.44.13;	author tromey;	state Exp;
branches;
next	1.606;

1.606
date	2012.01.10.21.16.59;	author devans;	state Exp;
branches;
next	1.605;

1.605
date	2012.01.09.17.40.05;	author devans;	state Exp;
branches;
next	1.604;

1.604
date	2012.01.08.22.20.17;	author devans;	state Exp;
branches;
next	1.603;

1.603
date	2012.01.08.21.02.44;	author devans;	state Exp;
branches;
next	1.602;

1.602
date	2012.01.06.18.13.22;	author devans;	state Exp;
branches;
next	1.601;

1.601
date	2012.01.05.21.56.37;	author devans;	state Exp;
branches;
next	1.600;

1.600
date	2012.01.05.21.53.14;	author devans;	state Exp;
branches;
next	1.599;

1.599
date	2012.01.05.20.17.50;	author devans;	state Exp;
branches;
next	1.598;

1.598
date	2012.01.04.19.49.41;	author devans;	state Exp;
branches;
next	1.597;

1.597
date	2012.01.04.19.16.15;	author devans;	state Exp;
branches;
next	1.596;

1.596
date	2012.01.04.19.07.36;	author devans;	state Exp;
branches;
next	1.595;

1.595
date	2012.01.04.08.17.01;	author brobecke;	state Exp;
branches;
next	1.594;

1.594
date	2012.01.02.01.23.41;	author devans;	state Exp;
branches;
next	1.593;

1.593
date	2012.01.02.00.50.07;	author devans;	state Exp;
branches;
next	1.592;

1.592
date	2012.01.02.00.29.19;	author devans;	state Exp;
branches;
next	1.591;

1.591
date	2012.01.02.00.23.50;	author devans;	state Exp;
branches;
next	1.590;

1.590
date	2012.01.02.00.09.58;	author devans;	state Exp;
branches;
next	1.589;

1.589
date	2011.12.31.17.18.13;	author devans;	state Exp;
branches;
next	1.588;

1.588
date	2011.12.27.23.41.59;	author devans;	state Exp;
branches;
next	1.587;

1.587
date	2011.12.21.07.34.09;	author brobecke;	state Exp;
branches;
next	1.586;

1.586
date	2011.12.10.23.57.39;	author devans;	state Exp;
branches
	1.586.2.1;
next	1.585;

1.585
date	2011.12.06.18.54.38;	author tromey;	state Exp;
branches;
next	1.584;

1.584
date	2011.12.02.17.01.19;	author jkratoch;	state Exp;
branches;
next	1.583;

1.583
date	2011.12.02.01.28.54;	author jkratoch;	state Exp;
branches;
next	1.582;

1.582
date	2011.11.23.19.55.42;	author devans;	state Exp;
branches;
next	1.581;

1.581
date	2011.11.15.17.40.00;	author devans;	state Exp;
branches;
next	1.580;

1.580
date	2011.11.11.00.43.03;	author devans;	state Exp;
branches;
next	1.579;

1.579
date	2011.11.10.20.21.27;	author devans;	state Exp;
branches;
next	1.578;

1.578
date	2011.10.20.23.13.01;	author ccoutant;	state Exp;
branches;
next	1.577;

1.577
date	2011.10.20.20.06.13;	author aristovski;	state Exp;
branches;
next	1.576;

1.576
date	2011.10.20.01.11.34;	author ccoutant;	state Exp;
branches;
next	1.575;

1.575
date	2011.10.19.15.26.30;	author ccoutant;	state Exp;
branches;
next	1.574;

1.574
date	2011.10.17.12.57.14;	author jkratoch;	state Exp;
branches;
next	1.573;

1.573
date	2011.10.13.09.36.47;	author jkratoch;	state Exp;
branches;
next	1.572;

1.572
date	2011.10.12.22.04.11;	author jkratoch;	state Exp;
branches;
next	1.571;

1.571
date	2011.10.12.16.28.41;	author devans;	state Exp;
branches;
next	1.570;

1.570
date	2011.10.11.23.30.27;	author sterling;	state Exp;
branches;
next	1.569;

1.569
date	2011.10.11.19.19.07;	author sterling;	state Exp;
branches;
next	1.568;

1.568
date	2011.10.09.19.34.18;	author jkratoch;	state Exp;
branches;
next	1.567;

1.567
date	2011.10.09.19.23.41;	author jkratoch;	state Exp;
branches;
next	1.566;

1.566
date	2011.10.09.19.21.38;	author jkratoch;	state Exp;
branches;
next	1.565;

1.565
date	2011.10.09.18.46.41;	author jkratoch;	state Exp;
branches;
next	1.564;

1.564
date	2011.10.09.18.43.32;	author jkratoch;	state Exp;
branches;
next	1.563;

1.563
date	2011.10.09.18.37.26;	author jkratoch;	state Exp;
branches;
next	1.562;

1.562
date	2011.10.09.18.33.28;	author jkratoch;	state Exp;
branches;
next	1.561;

1.561
date	2011.09.13.21.44.27;	author jkratoch;	state Exp;
branches;
next	1.560;

1.560
date	2011.09.09.19.41.13;	author jkratoch;	state Exp;
branches;
next	1.559;

1.559
date	2011.09.08.15.38.14;	author jkratoch;	state Exp;
branches;
next	1.558;

1.558
date	2011.09.01.07.17.45;	author jkratoch;	state Exp;
branches;
next	1.557;

1.557
date	2011.07.27.17.08.05;	author jkratoch;	state Exp;
branches;
next	1.556;

1.556
date	2011.07.27.14.45.37;	author tromey;	state Exp;
branches;
next	1.555;

1.555
date	2011.07.26.17.04.23;	author tromey;	state Exp;
branches;
next	1.554;

1.554
date	2011.07.20.15.13.49;	author tromey;	state Exp;
branches;
next	1.553;

1.553
date	2011.07.20.15.06.54;	author tromey;	state Exp;
branches;
next	1.552;

1.552
date	2011.07.19.20.28.52;	author jkratoch;	state Exp;
branches;
next	1.551;

1.551
date	2011.07.18.15.17.35;	author tromey;	state Exp;
branches;
next	1.550;

1.550
date	2011.07.12.20.59.03;	author jkratoch;	state Exp;
branches;
next	1.549;

1.549
date	2011.07.11.17.17.26;	author tromey;	state Exp;
branches;
next	1.548;

1.548
date	2011.07.05.13.36.41;	author tromey;	state Exp;
branches;
next	1.547;

1.547
date	2011.07.01.19.12.11;	author jkratoch;	state Exp;
branches;
next	1.546;

1.546
date	2011.06.29.22.19.24;	author jkratoch;	state Exp;
branches;
next	1.545;

1.545
date	2011.06.29.22.17.57;	author jkratoch;	state Exp;
branches;
next	1.544;

1.544
date	2011.06.29.22.05.15;	author jkratoch;	state Exp;
branches;
next	1.543;

1.543
date	2011.06.29.15.32.39;	author tromey;	state Exp;
branches;
next	1.542;

1.542
date	2011.06.27.08.41.39;	author gingold;	state Exp;
branches;
next	1.541;

1.541
date	2011.06.10.21.48.04;	author jkratoch;	state Exp;
branches;
next	1.540;

1.540
date	2011.05.31.21.54.07;	author kseitz;	state Exp;
branches;
next	1.539;

1.539
date	2011.05.26.07.47.10;	author gingold;	state Exp;
branches;
next	1.538;

1.538
date	2011.05.24.12.40.17;	author gingold;	state Exp;
branches;
next	1.537;

1.537
date	2011.05.20.08.55.49;	author jkratoch;	state Exp;
branches;
next	1.536;

1.536
date	2011.05.18.20.19.51;	author tromey;	state Exp;
branches;
next	1.535;

1.535
date	2011.05.18.16.30.34;	author tromey;	state Exp;
branches;
next	1.534;

1.534
date	2011.05.17.17.01.46;	author tromey;	state Exp;
branches;
next	1.533;

1.533
date	2011.05.12.17.40.54;	author tromey;	state Exp;
branches;
next	1.532;

1.532
date	2011.05.12.15.59.46;	author tromey;	state Exp;
branches;
next	1.531;

1.531
date	2011.05.11.17.25.41;	author tromey;	state Exp;
branches;
next	1.530;

1.530
date	2011.05.06.15.06.46;	author jkratoch;	state Exp;
branches;
next	1.529;

1.529
date	2011.05.06.14.12.17;	author jkratoch;	state Exp;
branches;
next	1.528;

1.528
date	2011.04.27.20.03.03;	author jkratoch;	state Exp;
branches;
next	1.527;

1.527
date	2011.04.27.19.52.21;	author jkratoch;	state Exp;
branches;
next	1.526;

1.526
date	2011.04.20.19.42.50;	author jkratoch;	state Exp;
branches;
next	1.525;

1.525
date	2011.04.20.18.05.25;	author tromey;	state Exp;
branches;
next	1.524;

1.524
date	2011.04.15.15.05.04;	author tromey;	state Exp;
branches;
next	1.523;

1.523
date	2011.04.09.15.20.38;	author jkratoch;	state Exp;
branches;
next	1.522;

1.522
date	2011.04.09.11.15.29;	author jkratoch;	state Exp;
branches;
next	1.521;

1.521
date	2011.04.06.19.50.04;	author jkratoch;	state Exp;
branches;
next	1.520;

1.520
date	2011.04.04.14.10.12;	author tromey;	state Exp;
branches;
next	1.519;

1.519
date	2011.04.01.17.46.44;	author jkratoch;	state Exp;
branches;
next	1.518;

1.518
date	2011.03.31.21.01.13;	author jkratoch;	state Exp;
branches
	1.518.2.1;
next	1.517;

1.517
date	2011.03.31.19.37.54;	author jkratoch;	state Exp;
branches;
next	1.516;

1.516
date	2011.03.29.17.04.29;	author tromey;	state Exp;
branches;
next	1.515;

1.515
date	2011.03.28.19.53.14;	author tromey;	state Exp;
branches;
next	1.514;

1.514
date	2011.03.24.20.35.08;	author tromey;	state Exp;
branches;
next	1.513;

1.513
date	2011.03.22.17.35.22;	author jkratoch;	state Exp;
branches;
next	1.512;

1.512
date	2011.03.22.09.50.42;	author jkratoch;	state Exp;
branches;
next	1.511;

1.511
date	2011.03.21.20.07.08;	author jkratoch;	state Exp;
branches;
next	1.510;

1.510
date	2011.03.16.18.15.10;	author ppluzhnikov;	state Exp;
branches;
next	1.509;

1.509
date	2011.03.15.15.57.11;	author jkratoch;	state Exp;
branches;
next	1.508;

1.508
date	2011.03.09.07.07.55;	author jkratoch;	state Exp;
branches;
next	1.507;

1.507
date	2011.03.08.17.54.44;	author jkratoch;	state Exp;
branches;
next	1.506;

1.506
date	2011.03.07.16.17.28;	author tromey;	state Exp;
branches;
next	1.505;

1.505
date	2011.03.03.17.33.40;	author tromey;	state Exp;
branches;
next	1.504;

1.504
date	2011.03.02.00.37.29;	author msnyder;	state Exp;
branches;
next	1.503;

1.503
date	2011.03.01.00.07.20;	author msnyder;	state Exp;
branches;
next	1.502;

1.502
date	2011.02.28.23.12.56;	author msnyder;	state Exp;
branches;
next	1.501;

1.501
date	2011.02.26.02.07.08;	author msnyder;	state Exp;
branches;
next	1.500;

1.500
date	2011.02.16.21.32.05;	author tromey;	state Exp;
branches;
next	1.499;

1.499
date	2011.02.08.13.30.08;	author uweigand;	state Exp;
branches;
next	1.498;

1.498
date	2011.02.04.20.33.09;	author tromey;	state Exp;
branches;
next	1.497;

1.497
date	2011.02.04.18.13.25;	author uweigand;	state Exp;
branches;
next	1.496;

1.496
date	2011.01.25.17.25.12;	author jkratoch;	state Exp;
branches;
next	1.495;

1.495
date	2011.01.12.16.16.20;	author jkratoch;	state Exp;
branches;
next	1.494;

1.494
date	2011.01.10.17.14.12;	author msnyder;	state Exp;
branches;
next	1.493;

1.493
date	2011.01.07.19.36.16;	author msnyder;	state Exp;
branches;
next	1.492;

1.492
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.491;

1.491
date	2011.01.01.15.33.02;	author brobecke;	state Exp;
branches;
next	1.490;

1.490
date	2010.12.16.01.42.40;	author devans;	state Exp;
branches;
next	1.489;

1.489
date	2010.12.12.19.19.27;	author devans;	state Exp;
branches;
next	1.488;

1.488
date	2010.12.10.22.00.00;	author devans;	state Exp;
branches;
next	1.487;

1.487
date	2010.12.08.19.03.35;	author devans;	state Exp;
branches;
next	1.486;

1.486
date	2010.12.08.18.26.40;	author devans;	state Exp;
branches;
next	1.485;

1.485
date	2010.12.08.18.04.08;	author devans;	state Exp;
branches;
next	1.484;

1.484
date	2010.12.08.17.31.52;	author devans;	state Exp;
branches;
next	1.483;

1.483
date	2010.12.07.17.30.52;	author devans;	state Exp;
branches;
next	1.482;

1.482
date	2010.12.01.19.37.36;	author devans;	state Exp;
branches;
next	1.481;

1.481
date	2010.11.29.21.18.16;	author tromey;	state Exp;
branches;
next	1.480;

1.480
date	2010.11.24.19.01.51;	author jkratoch;	state Exp;
branches;
next	1.479;

1.479
date	2010.11.22.20.35.02;	author jkratoch;	state Exp;
branches;
next	1.478;

1.478
date	2010.11.19.16.35.13;	author tromey;	state Exp;
branches;
next	1.477;

1.477
date	2010.11.16.22.04.52;	author jkratoch;	state Exp;
branches;
next	1.476;

1.476
date	2010.11.16.04.36.26;	author jkratoch;	state Exp;
branches;
next	1.475;

1.475
date	2010.11.05.14.31.27;	author kwerner;	state Exp;
branches;
next	1.474;

1.474
date	2010.11.03.14.21.56;	author kwerner;	state Exp;
branches;
next	1.473;

1.473
date	2010.10.26.17.59.50;	author brobecke;	state Exp;
branches;
next	1.472;

1.472
date	2010.10.17.18.49.46;	author jkratoch;	state Exp;
branches;
next	1.471;

1.471
date	2010.10.07.17.23.30;	author devans;	state Exp;
branches;
next	1.470;

1.470
date	2010.10.07.07.13.51;	author hilfingr;	state Exp;
branches;
next	1.469;

1.469
date	2010.10.06.16.13.34;	author kwerner;	state Exp;
branches;
next	1.468;

1.468
date	2010.10.05.03.10.28;	author devans;	state Exp;
branches;
next	1.467;

1.467
date	2010.10.05.02.56.36;	author devans;	state Exp;
branches;
next	1.466;

1.466
date	2010.10.04.06.34.40;	author hilfingr;	state Exp;
branches;
next	1.465;

1.465
date	2010.10.01.20.47.45;	author devans;	state Exp;
branches;
next	1.464;

1.464
date	2010.10.01.20.26.11;	author tromey;	state Exp;
branches;
next	1.463;

1.463
date	2010.09.29.16.41.24;	author devans;	state Exp;
branches;
next	1.462;

1.462
date	2010.09.27.18.42.36;	author tromey;	state Exp;
branches;
next	1.461;

1.461
date	2010.09.24.16.11.46;	author tromey;	state Exp;
branches;
next	1.460;

1.460
date	2010.09.22.19.22.44;	author jkratoch;	state Exp;
branches;
next	1.459;

1.459
date	2010.09.22.16.15.33;	author brobecke;	state Exp;
branches;
next	1.458;

1.458
date	2010.09.15.18.14.47;	author devans;	state Exp;
branches;
next	1.457;

1.457
date	2010.09.14.21.28.53;	author jkratoch;	state Exp;
branches;
next	1.456;

1.456
date	2010.09.09.16.42.39;	author uweigand;	state Exp;
branches;
next	1.455;

1.455
date	2010.09.08.23.34.11;	author drow;	state Exp;
branches;
next	1.454;

1.454
date	2010.09.08.23.14.52;	author drow;	state Exp;
branches;
next	1.453;

1.453
date	2010.09.08.19.49.28;	author jkratoch;	state Exp;
branches;
next	1.452;

1.452
date	2010.09.08.19.09.42;	author drow;	state Exp;
branches;
next	1.451;

1.451
date	2010.09.08.17.17.42;	author tromey;	state Exp;
branches;
next	1.450;

1.450
date	2010.09.01.21.50.24;	author tromey;	state Exp;
branches;
next	1.449;

1.449
date	2010.08.31.20.03.20;	author tromey;	state Exp;
branches;
next	1.448;

1.448
date	2010.08.27.23.09.58;	author devans;	state Exp;
branches;
next	1.447;

1.447
date	2010.08.27.21.03.39;	author tromey;	state Exp;
branches;
next	1.446;

1.446
date	2010.08.27.16.37.03;	author devans;	state Exp;
branches;
next	1.445;

1.445
date	2010.08.26.23.36.53;	author devans;	state Exp;
branches;
next	1.444;

1.444
date	2010.08.26.16.47.55;	author devans;	state Exp;
branches;
next	1.443;

1.443
date	2010.08.25.18.20.07;	author palves;	state Exp;
branches;
next	1.442;

1.442
date	2010.08.25.00.09.13;	author devans;	state Exp;
branches;
next	1.441;

1.441
date	2010.08.23.21.49.26;	author devans;	state Exp;
branches;
next	1.440;

1.440
date	2010.08.23.21.44.39;	author devans;	state Exp;
branches;
next	1.439;

1.439
date	2010.08.20.17.16.44;	author kseitz;	state Exp;
branches;
next	1.438;

1.438
date	2010.08.18.19.13.33;	author devans;	state Exp;
branches;
next	1.437;

1.437
date	2010.08.13.03.14.03;	author teawater;	state Exp;
branches;
next	1.436;

1.436
date	2010.08.12.19.55.38;	author palves;	state Exp;
branches;
next	1.435;

1.435
date	2010.08.09.20.34.06;	author swagiaal;	state Exp;
branches;
next	1.434;

1.434
date	2010.08.09.19.42.46;	author swagiaal;	state Exp;
branches;
next	1.433;

1.433
date	2010.08.03.00.51.29;	author devans;	state Exp;
branches;
next	1.432;

1.432
date	2010.07.28.20.05.03;	author tromey;	state Exp;
branches;
next	1.431;

1.431
date	2010.07.28.19.04.07;	author palves;	state Exp;
branches;
next	1.430;

1.430
date	2010.07.28.16.23.58;	author tromey;	state Exp;
branches;
next	1.429;

1.429
date	2010.07.27.22.26.27;	author palves;	state Exp;
branches;
next	1.428;

1.428
date	2010.07.27.16.16.32;	author brobecke;	state Exp;
branches;
next	1.427;

1.427
date	2010.07.27.07.57.49;	author kwerner;	state Exp;
branches;
next	1.426;

1.426
date	2010.07.26.09.30.00;	author guitton;	state Exp;
branches;
next	1.425;

1.425
date	2010.07.23.22.15.13;	author tromey;	state Exp;
branches;
next	1.424;

1.424
date	2010.07.23.14.43.33;	author kseitz;	state Exp;
branches;
next	1.423;

1.423
date	2010.07.22.16.24.38;	author jkratoch;	state Exp;
branches;
next	1.422;

1.422
date	2010.07.22.15.53.48;	author tromey;	state Exp;
branches;
next	1.421;

1.421
date	2010.07.21.18.08.26;	author palves;	state Exp;
branches;
next	1.420;

1.420
date	2010.07.16.19.23.56;	author swagiaal;	state Exp;
branches;
next	1.419;

1.419
date	2010.07.16.19.00.56;	author swagiaal;	state Exp;
branches;
next	1.418;

1.418
date	2010.07.16.18.39.10;	author swagiaal;	state Exp;
branches;
next	1.417;

1.417
date	2010.07.13.22.02.05;	author tromey;	state Exp;
branches;
next	1.416;

1.416
date	2010.07.13.21.06.48;	author tromey;	state Exp;
branches;
next	1.415;

1.415
date	2010.07.13.20.52.52;	author tromey;	state Exp;
branches;
next	1.414;

1.414
date	2010.07.13.20.51.33;	author tromey;	state Exp;
branches;
next	1.413;

1.413
date	2010.07.13.20.07.44;	author tromey;	state Exp;
branches;
next	1.412;

1.412
date	2010.07.13.15.09.03;	author tromey;	state Exp;
branches;
next	1.411;

1.411
date	2010.07.12.17.07.11;	author jkratoch;	state Exp;
branches;
next	1.410;

1.410
date	2010.07.07.17.26.38;	author tromey;	state Exp;
branches;
next	1.409;

1.409
date	2010.06.30.05.39.23;	author devans;	state Exp;
branches
	1.409.2.1;
next	1.408;

1.408
date	2010.06.29.16.53.09;	author devans;	state Exp;
branches;
next	1.407;

1.407
date	2010.06.29.16.35.28;	author devans;	state Exp;
branches;
next	1.406;

1.406
date	2010.06.28.22.03.31;	author jkratoch;	state Exp;
branches;
next	1.405;

1.405
date	2010.06.28.20.39.28;	author jkratoch;	state Exp;
branches;
next	1.404;

1.404
date	2010.06.28.20.12.52;	author jkratoch;	state Exp;
branches;
next	1.403;

1.403
date	2010.06.28.19.05.42;	author tromey;	state Exp;
branches;
next	1.402;

1.402
date	2010.06.21.19.49.19;	author tromey;	state Exp;
branches;
next	1.401;

1.401
date	2010.06.21.18.01.50;	author tromey;	state Exp;
branches;
next	1.400;

1.400
date	2010.06.17.22.36.41;	author brobecke;	state Exp;
branches;
next	1.399;

1.399
date	2010.06.17.17.36.54;	author tromey;	state Exp;
branches;
next	1.398;

1.398
date	2010.06.11.20.01.06;	author tromey;	state Exp;
branches;
next	1.397;

1.397
date	2010.06.07.19.55.33;	author jkratoch;	state Exp;
branches;
next	1.396;

1.396
date	2010.06.07.19.42.58;	author jkratoch;	state Exp;
branches;
next	1.395;

1.395
date	2010.06.05.14.11.54;	author jkratoch;	state Exp;
branches;
next	1.394;

1.394
date	2010.06.03.15.39.43;	author swagiaal;	state Exp;
branches;
next	1.393;

1.393
date	2010.06.02.22.41.55;	author jkratoch;	state Exp;
branches;
next	1.392;

1.392
date	2010.06.02.20.03.42;	author jkratoch;	state Exp;
branches;
next	1.391;

1.391
date	2010.06.02.19.37.55;	author tromey;	state Exp;
branches;
next	1.390;

1.390
date	2010.06.02.06.24.00;	author muller;	state Exp;
branches;
next	1.389;

1.389
date	2010.06.01.21.34.15;	author muller;	state Exp;
branches;
next	1.388;

1.388
date	2010.05.21.20.45.19;	author muller;	state Exp;
branches;
next	1.387;

1.387
date	2010.05.21.20.34.47;	author muller;	state Exp;
branches;
next	1.386;

1.386
date	2010.05.17.15.55.01;	author muller;	state Exp;
branches;
next	1.385;

1.385
date	2010.05.14.17.53.16;	author msnyder;	state Exp;
branches;
next	1.384;

1.384
date	2010.05.13.09.09.20;	author jkratoch;	state Exp;
branches;
next	1.383;

1.383
date	2010.05.08.04.58.45;	author jkratoch;	state Exp;
branches;
next	1.382;

1.382
date	2010.05.05.23.44.19;	author msnyder;	state Exp;
branches;
next	1.381;

1.381
date	2010.04.29.14.45.38;	author brobecke;	state Exp;
branches;
next	1.380;

1.380
date	2010.04.20.21.19.07;	author tromey;	state Exp;
branches;
next	1.379;

1.379
date	2010.04.20.17.33.14;	author tromey;	state Exp;
branches;
next	1.378;

1.378
date	2010.04.02.15.21.47;	author jkratoch;	state Exp;
branches;
next	1.377;

1.377
date	2010.03.31.18.13.37;	author jkratoch;	state Exp;
branches;
next	1.376;

1.376
date	2010.03.26.18.55.30;	author uweigand;	state Exp;
branches;
next	1.375;

1.375
date	2010.03.26.18.05.45;	author uweigand;	state Exp;
branches;
next	1.374;

1.374
date	2010.03.25.22.13.15;	author kseitz;	state Exp;
branches;
next	1.373;

1.373
date	2010.03.24.21.06.30;	author drow;	state Exp;
branches;
next	1.372;

1.372
date	2010.03.22.13.21.39;	author uweigand;	state Exp;
branches;
next	1.371;

1.371
date	2010.03.18.18.35.54;	author brobecke;	state Exp;
branches;
next	1.370;

1.370
date	2010.03.17.19.16.02;	author tromey;	state Exp;
branches;
next	1.369;

1.369
date	2010.03.16.20.51.23;	author jkratoch;	state Exp;
branches;
next	1.368;

1.368
date	2010.03.15.20.49.53;	author tromey;	state Exp;
branches;
next	1.367;

1.367
date	2010.03.15.17.29.36;	author swagiaal;	state Exp;
branches;
next	1.366;

1.366
date	2010.03.13.00.27.11;	author tromey;	state Exp;
branches;
next	1.365;

1.365
date	2010.03.10.18.41.37;	author tromey;	state Exp;
branches;
next	1.364;

1.364
date	2010.03.10.18.37.23;	author tromey;	state Exp;
branches;
next	1.363;

1.363
date	2010.03.10.18.27.00;	author tromey;	state Exp;
branches;
next	1.362;

1.362
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	1.361;

1.361
date	2010.03.10.16.22.29;	author swagiaal;	state Exp;
branches;
next	1.360;

1.360
date	2010.03.10.08.08.46;	author brobecke;	state Exp;
branches;
next	1.359;

1.359
date	2010.03.09.18.09.07;	author kseitz;	state Exp;
branches;
next	1.358;

1.358
date	2010.03.04.22.01.10;	author tromey;	state Exp;
branches;
next	1.357;

1.357
date	2010.03.02.17.19.58;	author devans;	state Exp;
branches;
next	1.356;

1.356
date	2010.02.15.20.48.57;	author tromey;	state Exp;
branches
	1.356.2.1;
next	1.355;

1.355
date	2010.02.05.19.03.40;	author swagiaal;	state Exp;
branches;
next	1.354;

1.354
date	2010.02.03.14.13.16;	author gingold;	state Exp;
branches;
next	1.353;

1.353
date	2010.02.02.16.47.13;	author tromey;	state Exp;
branches;
next	1.352;

1.352
date	2010.01.26.15.48.25;	author swagiaal;	state Exp;
branches;
next	1.351;

1.351
date	2010.01.22.17.06.48;	author tromey;	state Exp;
branches;
next	1.350;

1.350
date	2010.01.20.02.05.03;	author tromey;	state Exp;
branches;
next	1.349;

1.349
date	2010.01.19.18.11.18;	author tromey;	state Exp;
branches;
next	1.348;

1.348
date	2010.01.19.09.47.47;	author brobecke;	state Exp;
branches;
next	1.347;

1.347
date	2010.01.12.05.48.56;	author brobecke;	state Exp;
branches;
next	1.346;

1.346
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.345;

1.345
date	2009.12.28.21.29.53;	author drow;	state Exp;
branches;
next	1.344;

1.344
date	2009.12.16.15.09.43;	author gaius;	state Exp;
branches;
next	1.343;

1.343
date	2009.12.14.06.19.13;	author hilfingr;	state Exp;
branches;
next	1.342;

1.342
date	2009.12.02.11.44.35;	author gingold;	state Exp;
branches;
next	1.341;

1.341
date	2009.12.02.11.34.37;	author gingold;	state Exp;
branches;
next	1.340;

1.340
date	2009.11.23.22.08.01;	author tromey;	state Exp;
branches;
next	1.339;

1.339
date	2009.11.23.22.06.04;	author tromey;	state Exp;
branches;
next	1.338;

1.338
date	2009.11.16.18.40.21;	author tromey;	state Exp;
branches;
next	1.337;

1.337
date	2009.11.12.19.47.25;	author drow;	state Exp;
branches;
next	1.336;

1.336
date	2009.11.12.19.29.04;	author drow;	state Exp;
branches;
next	1.335;

1.335
date	2009.11.12.19.10.06;	author drow;	state Exp;
branches;
next	1.334;

1.334
date	2009.11.12.19.05.28;	author drow;	state Exp;
branches;
next	1.333;

1.333
date	2009.11.12.18.59.40;	author drow;	state Exp;
branches;
next	1.332;

1.332
date	2009.11.09.21.39.40;	author ccoutant;	state Exp;
branches;
next	1.331;

1.331
date	2009.11.05.23.18.00;	author drow;	state Exp;
branches;
next	1.330;

1.330
date	2009.10.14.23.48.01;	author ccoutant;	state Exp;
branches;
next	1.329;

1.329
date	2009.10.14.22.50.32;	author kseitz;	state Exp;
branches;
next	1.328;

1.328
date	2009.10.06.23.27.04;	author muller;	state Exp;
branches;
next	1.327;

1.327
date	2009.09.15.16.09.32;	author jkratoch;	state Exp;
branches
	1.327.2.1;
next	1.326;

1.326
date	2009.09.11.18.51.31;	author devans;	state Exp;
branches;
next	1.325;

1.325
date	2009.08.28.10.49.05;	author jkratoch;	state Exp;
branches;
next	1.324;

1.324
date	2009.07.20.21.21.17;	author devans;	state Exp;
branches;
next	1.323;

1.323
date	2009.07.15.22.17.10;	author devans;	state Exp;
branches;
next	1.322;

1.322
date	2009.07.10.15.27.02;	author tromey;	state Exp;
branches;
next	1.321;

1.321
date	2009.07.02.17.25.53;	author uweigand;	state Exp;
branches;
next	1.320;

1.320
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.319;

1.319
date	2009.06.30.15.50.24;	author drow;	state Exp;
branches;
next	1.318;

1.318
date	2009.06.29.15.18.07;	author swagiaal;	state Exp;
branches;
next	1.317;

1.317
date	2009.06.29.13.19.19;	author uweigand;	state Exp;
branches;
next	1.316;

1.316
date	2009.06.29.13.18.37;	author uweigand;	state Exp;
branches;
next	1.315;

1.315
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.314;

1.314
date	2009.06.23.19.09.54;	author ccoutant;	state Exp;
branches;
next	1.313;

1.313
date	2009.06.23.17.46.51;	author swagiaal;	state Exp;
branches;
next	1.312;

1.312
date	2009.06.17.20.29.42;	author tromey;	state Exp;
branches;
next	1.311;

1.311
date	2009.06.17.18.47.35;	author uweigand;	state Exp;
branches;
next	1.310;

1.310
date	2009.06.17.18.41.50;	author uweigand;	state Exp;
branches;
next	1.309;

1.309
date	2009.06.16.21.06.40;	author ppluzhnikov;	state Exp;
branches;
next	1.308;

1.308
date	2009.06.13.04.23.34;	author kevinb;	state Exp;
branches;
next	1.307;

1.307
date	2009.06.10.14.55.14;	author ccoutant;	state Exp;
branches;
next	1.306;

1.306
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.305;

1.305
date	2009.05.26.21.24.07;	author devans;	state Exp;
branches;
next	1.304;

1.304
date	2009.05.21.07.57.45;	author jkratoch;	state Exp;
branches;
next	1.303;

1.303
date	2009.05.21.07.15.46;	author jkratoch;	state Exp;
branches;
next	1.302;

1.302
date	2009.05.01.14.43.20;	author jkratoch;	state Exp;
branches;
next	1.301;

1.301
date	2009.04.27.08.36.16;	author jkratoch;	state Exp;
branches;
next	1.300;

1.300
date	2009.04.02.21.01.40;	author jkratoch;	state Exp;
branches;
next	1.299;

1.299
date	2009.03.31.20.21.07;	author tromey;	state Exp;
branches;
next	1.298;

1.298
date	2009.03.26.14.47.18;	author jkratoch;	state Exp;
branches;
next	1.297;

1.297
date	2009.03.20.22.00.10;	author tromey;	state Exp;
branches;
next	1.296;

1.296
date	2009.03.09.18.53.48;	author jkratoch;	state Exp;
branches;
next	1.295;

1.295
date	2009.02.12.09.15.06;	author jkratoch;	state Exp;
branches;
next	1.294;

1.294
date	2009.02.11.22.30.03;	author muller;	state Exp;
branches;
next	1.293;

1.293
date	2009.02.09.00.07.53;	author drow;	state Exp;
branches;
next	1.292;

1.292
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.291;

1.291
date	2008.11.15.18.49.50;	author brobecke;	state Exp;
branches;
next	1.290;

1.290
date	2008.10.24.18.21.00;	author devans;	state Exp;
branches;
next	1.289;

1.289
date	2008.10.10.16.15.42;	author devans;	state Exp;
branches;
next	1.288;

1.288
date	2008.10.08.12.49.12;	author jkratoch;	state Exp;
branches;
next	1.287;

1.287
date	2008.10.06.22.23.17;	author devans;	state Exp;
branches;
next	1.286;

1.286
date	2008.10.06.21.54.23;	author devans;	state Exp;
branches;
next	1.285;

1.285
date	2008.09.30.16.57.37;	author brobecke;	state Exp;
branches;
next	1.284;

1.284
date	2008.09.23.17.36.51;	author devans;	state Exp;
branches;
next	1.283;

1.283
date	2008.09.15.15.32.01;	author devans;	state Exp;
branches;
next	1.282;

1.282
date	2008.09.15.01.22.02;	author devans;	state Exp;
branches;
next	1.281;

1.281
date	2008.09.13.22.19.50;	author brobecke;	state Exp;
branches;
next	1.280;

1.280
date	2008.09.12.20.06.25;	author devans;	state Exp;
branches;
next	1.279;

1.279
date	2008.09.01.22.24.05;	author jkratoch;	state Exp;
branches;
next	1.278;

1.278
date	2008.08.29.17.06.05;	author tromey;	state Exp;
branches;
next	1.277;

1.277
date	2008.08.24.16.39.56;	author tromey;	state Exp;
branches;
next	1.276;

1.276
date	2008.08.21.18.57.34;	author drow;	state Exp;
branches;
next	1.275;

1.275
date	2008.08.21.18.40.34;	author drow;	state Exp;
branches;
next	1.274;

1.274
date	2008.08.21.18.14.38;	author drow;	state Exp;
branches;
next	1.273;

1.273
date	2008.08.20.20.37.57;	author drow;	state Exp;
branches;
next	1.272;

1.272
date	2008.08.20.20.31.49;	author drow;	state Exp;
branches;
next	1.271;

1.271
date	2008.08.20.20.12.24;	author drow;	state Exp;
branches;
next	1.270;

1.270
date	2008.08.20.19.50.54;	author drow;	state Exp;
branches;
next	1.269;

1.269
date	2008.08.20.19.39.11;	author drow;	state Exp;
branches;
next	1.268;

1.268
date	2008.08.20.19.27.58;	author drow;	state Exp;
branches;
next	1.267;

1.267
date	2008.06.27.17.56.47;	author brobecke;	state Exp;
branches;
next	1.266;

1.266
date	2008.06.26.19.08.10;	author brobecke;	state Exp;
branches;
next	1.265;

1.265
date	2008.05.27.19.29.51;	author schwab;	state Exp;
branches;
next	1.264;

1.264
date	2008.05.16.12.58.48;	author uweigand;	state Exp;
branches;
next	1.263;

1.263
date	2008.05.05.14.37.32;	author aristovski;	state Exp;
branches;
next	1.262;

1.262
date	2008.05.04.22.49.47;	author drow;	state Exp;
branches;
next	1.261;

1.261
date	2008.05.04.20.04.48;	author drow;	state Exp;
branches;
next	1.260;

1.260
date	2008.05.04.17.27.01;	author jkratoch;	state Exp;
branches;
next	1.259;

1.259
date	2008.05.04.17.19.06;	author jkratoch;	state Exp;
branches;
next	1.258;

1.258
date	2008.04.25.18.45.23;	author palves;	state Exp;
branches;
next	1.257;

1.257
date	2008.04.22.11.03.41;	author corinna;	state Exp;
branches;
next	1.256;

1.256
date	2008.04.21.22.00.52;	author csilvers;	state Exp;
branches;
next	1.255;

1.255
date	2008.04.19.05.06.54;	author csilvers;	state Exp;
branches;
next	1.254;

1.254
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.253;

1.253
date	2008.03.18.19.40.47;	author uweigand;	state Exp;
branches;
next	1.252;

1.252
date	2008.03.10.14.01.56;	author drow;	state Exp;
branches;
next	1.251;

1.251
date	2008.02.01.22.45.13;	author brobecke;	state Exp;
branches
	1.251.2.1;
next	1.250;

1.250
date	2008.01.18.17.07.39;	author deuling;	state Exp;
branches;
next	1.249;

1.249
date	2008.01.11.13.34.14;	author deuling;	state Exp;
branches;
next	1.248;

1.248
date	2008.01.09.04.28.11;	author brobecke;	state Exp;
branches;
next	1.247;

1.247
date	2008.01.03.17.29.55;	author brobecke;	state Exp;
branches;
next	1.246;

1.246
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.245;

1.245
date	2007.12.26.12.36.18;	author brobecke;	state Exp;
branches;
next	1.244;

1.244
date	2007.12.24.06.29.27;	author brobecke;	state Exp;
branches;
next	1.243;

1.243
date	2007.12.22.20.58.30;	author jkratoch;	state Exp;
branches;
next	1.242;

1.242
date	2007.12.17.18.38.30;	author jimb;	state Exp;
branches;
next	1.241;

1.241
date	2007.12.16.16.06.29;	author jkratoch;	state Exp;
branches;
next	1.240;

1.240
date	2007.12.13.19.02.51;	author jimb;	state Exp;
branches;
next	1.239;

1.239
date	2007.12.04.23.43.57;	author jimb;	state Exp;
branches;
next	1.238;

1.238
date	2007.12.04.23.33.00;	author uweigand;	state Exp;
branches;
next	1.237;

1.237
date	2007.11.25.21.40.39;	author jkratoch;	state Exp;
branches;
next	1.236;

1.236
date	2007.10.25.20.54.27;	author cseo;	state Exp;
branches;
next	1.235;

1.235
date	2007.10.25.17.57.34;	author bauermann;	state Exp;
branches;
next	1.234;

1.234
date	2007.10.22.03.01.00;	author drow;	state Exp;
branches;
next	1.233;

1.233
date	2007.10.22.01.16.34;	author drow;	state Exp;
branches;
next	1.232;

1.232
date	2007.09.26.13.59.54;	author muller;	state Exp;
branches;
next	1.231;

1.231
date	2007.09.05.00.51.48;	author drow;	state Exp;
branches;
next	1.230;

1.230
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.229;

1.229
date	2007.08.08.18.01.35;	author msnyder;	state Exp;
branches;
next	1.228;

1.228
date	2007.07.17.12.46.35;	author drow;	state Exp;
branches;
next	1.227;

1.227
date	2007.06.22.12.26.59;	author uweigand;	state Exp;
branches;
next	1.226;

1.226
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.225;

1.225
date	2007.06.12.16.59.42;	author uweigand;	state Exp;
branches;
next	1.224;

1.224
date	2007.06.12.15.33.03;	author uweigand;	state Exp;
branches;
next	1.223;

1.223
date	2007.06.09.13.51.51;	author uweigand;	state Exp;
branches;
next	1.222;

1.222
date	2007.06.05.15.04.40;	author drow;	state Exp;
branches;
next	1.221;

1.221
date	2007.06.04.12.34.11;	author drow;	state Exp;
branches;
next	1.220;

1.220
date	2007.05.18.19.42.42;	author ctice;	state Exp;
branches;
next	1.219;

1.219
date	2007.05.14.17.15.20;	author drow;	state Exp;
branches;
next	1.218;

1.218
date	2007.04.18.13.25.04;	author denis;	state Exp;
branches;
next	1.217;

1.217
date	2007.04.11.16.04.22;	author jkratoch;	state Exp;
branches;
next	1.216;

1.216
date	2007.03.30.17.21.47;	author drow;	state Exp;
branches;
next	1.215;

1.215
date	2007.02.12.15.19.31;	author muller;	state Exp;
branches;
next	1.214;

1.214
date	2007.01.28.14.42.12;	author kettenis;	state Exp;
branches;
next	1.213;

1.213
date	2007.01.23.23.57.47;	author brobecke;	state Exp;
branches;
next	1.212;

1.212
date	2007.01.21.16.49.40;	author drow;	state Exp;
branches;
next	1.211;

1.211
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.210;

1.210
date	2007.01.05.05.49.56;	author brobecke;	state Exp;
branches;
next	1.209;

1.209
date	2007.01.04.20.26.41;	author drow;	state Exp;
branches;
next	1.208;

1.208
date	2007.01.03.18.05.43;	author drow;	state Exp;
branches;
next	1.207;

1.207
date	2006.12.27.22.38.57;	author gfunck;	state Exp;
branches;
next	1.206;

1.206
date	2006.11.02.21.34.07;	author drow;	state Exp;
branches;
next	1.205;

1.205
date	2006.10.11.15.39.35;	author drow;	state Exp;
branches;
next	1.204;

1.204
date	2006.10.06.20.42.02;	author brobecke;	state Exp;
branches;
next	1.203;

1.203
date	2006.08.18.13.26.31;	author drow;	state Exp;
branches;
next	1.202;

1.202
date	2006.08.18.04.10.30;	author drow;	state Exp;
branches;
next	1.201;

1.201
date	2006.07.24.21.37.04;	author fred;	state Exp;
branches;
next	1.200;

1.200
date	2006.07.12.21.14.57;	author drow;	state Exp;
branches;
next	1.199;

1.199
date	2006.06.14.15.06.35;	author jules;	state Exp;
branches;
next	1.198;

1.198
date	2006.06.09.00.44.28;	author jules;	state Exp;
branches;
next	1.197;

1.197
date	2006.05.19.20.42.47;	author fnf;	state Exp;
branches;
next	1.196;

1.196
date	2006.05.13.15.46.38;	author gaius;	state Exp;
branches
	1.196.2.1;
next	1.195;

1.195
date	2006.05.06.00.14.03;	author nickrob;	state Exp;
branches
	1.195.2.1;
next	1.194;

1.194
date	2006.04.21.20.26.07;	author fred;	state Exp;
branches;
next	1.193;

1.193
date	2006.02.09.18.18.41;	author drow;	state Exp;
branches
	1.193.2.1
	1.193.8.1;
next	1.192;

1.192
date	2006.02.01.23.14.10;	author drow;	state Exp;
branches;
next	1.191;

1.191
date	2006.01.17.22.30.29;	author jimb;	state Exp;
branches;
next	1.190;

1.190
date	2006.01.17.22.01.42;	author jimb;	state Exp;
branches;
next	1.189;

1.189
date	2006.01.17.14.47.31;	author drow;	state Exp;
branches;
next	1.188;

1.188
date	2006.01.17.14.30.20;	author drow;	state Exp;
branches;
next	1.187;

1.187
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.186;

1.186
date	2005.11.04.02.50.30;	author ezannoni;	state Exp;
branches;
next	1.185;

1.185
date	2005.11.04.02.46.45;	author ezannoni;	state Exp;
branches;
next	1.184;

1.184
date	2005.10.21.09.14.48;	author schwab;	state Exp;
branches
	1.184.2.1;
next	1.183;

1.183
date	2005.08.01.04.06.27;	author drow;	state Exp;
branches;
next	1.182;

1.182
date	2005.07.04.13.29.10;	author kettenis;	state Exp;
branches;
next	1.181;

1.181
date	2005.03.09.06.03.14;	author brobecke;	state Exp;
branches;
next	1.180;

1.180
date	2005.02.26.04.32.56;	author ezannoni;	state Exp;
branches;
next	1.179;

1.179
date	2005.02.24.13.51.31;	author cagney;	state Exp;
branches;
next	1.178;

1.178
date	2005.02.17.13.49.50;	author cagney;	state Exp;
branches;
next	1.177;

1.177
date	2005.02.15.17.13.05;	author brobecke;	state Exp;
branches;
next	1.176;

1.176
date	2005.02.15.15.49.08;	author cagney;	state Exp;
branches;
next	1.175;

1.175
date	2005.02.14.16.18.39;	author cagney;	state Exp;
branches;
next	1.174;

1.174
date	2005.02.14.14.37.37;	author cagney;	state Exp;
branches;
next	1.173;

1.173
date	2005.02.12.00.39.18;	author cagney;	state Exp;
branches;
next	1.172;

1.172
date	2005.02.11.18.13.49;	author cagney;	state Exp;
branches;
next	1.171;

1.171
date	2005.02.11.04.05.46;	author cagney;	state Exp;
branches;
next	1.170;

1.170
date	2005.02.10.17.32.47;	author cagney;	state Exp;
branches;
next	1.169;

1.169
date	2004.11.10.20.40.33;	author kettenis;	state Exp;
branches;
next	1.168;

1.168
date	2004.10.19.20.28.56;	author kettenis;	state Exp;
branches;
next	1.167;

1.167
date	2004.10.16.00.41.00;	author brobecke;	state Exp;
branches;
next	1.166;

1.166
date	2004.10.06.08.46.21;	author corinna;	state Exp;
branches;
next	1.165;

1.165
date	2004.10.05.17.53.26;	author drow;	state Exp;
branches;
next	1.164;

1.164
date	2004.10.03.16.16.01;	author drow;	state Exp;
branches;
next	1.163;

1.163
date	2004.09.21.15.04.41;	author drow;	state Exp;
branches;
next	1.162;

1.162
date	2004.09.20.22.26.19;	author drow;	state Exp;
branches;
next	1.161;

1.161
date	2004.09.20.20.18.38;	author jjohnstn;	state Exp;
branches;
next	1.160;

1.160
date	2004.09.01.04.19.21;	author jimb;	state Exp;
branches;
next	1.159;

1.159
date	2004.08.29.10.12.14;	author dsl;	state Exp;
branches;
next	1.158;

1.158
date	2004.08.02.01.25.57;	author brobecke;	state Exp;
branches;
next	1.157;

1.157
date	2004.07.30.12.22.27;	author dsl;	state Exp;
branches;
next	1.156;

1.156
date	2004.07.06.19.29.30;	author jjohnstn;	state Exp;
branches;
next	1.155;

1.155
date	2004.06.24.20.42.42;	author cagney;	state Exp;
branches;
next	1.154;

1.154
date	2004.06.16.17.16.15;	author drow;	state Exp;
branches;
next	1.153;

1.153
date	2004.06.15.01.04.19;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2004.06.10.20.05.43;	author bobbybrasko;	state Exp;
branches;
next	1.151;

1.151
date	2004.05.07.14.29.33;	author cagney;	state Exp;
branches;
next	1.150;

1.150
date	2004.05.04.00.11.25;	author brobecke;	state Exp;
branches;
next	1.149;

1.149
date	2004.05.03.16.21.50;	author brobecke;	state Exp;
branches;
next	1.148;

1.148
date	2004.04.19.18.20.50;	author drow;	state Exp;
branches;
next	1.147;

1.147
date	2004.04.19.18.12.00;	author brobecke;	state Exp;
branches;
next	1.146;

1.146
date	2004.04.16.16.12.52;	author brobecke;	state Exp;
branches;
next	1.145;

1.145
date	2004.04.16.15.18.23;	author drow;	state Exp;
branches;
next	1.144;

1.144
date	2004.04.16.04.31.25;	author brobecke;	state Exp;
branches;
next	1.143;

1.143
date	2004.04.16.03.17.25;	author brobecke;	state Exp;
branches;
next	1.142;

1.142
date	2004.04.02.04.35.46;	author drow;	state Exp;
branches;
next	1.141;

1.141
date	2004.03.16.22.43.15;	author carlton;	state Exp;
branches;
next	1.140;

1.140
date	2004.03.15.22.33.52;	author carlton;	state Exp;
branches;
next	1.139;

1.139
date	2004.03.14.21.08.24;	author drow;	state Exp;
branches;
next	1.138;

1.138
date	2004.03.09.19.38.11;	author drow;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2004.03.09.16.57.44;	author drow;	state Exp;
branches;
next	1.136;

1.136
date	2004.03.05.03.30.36;	author drow;	state Exp;
branches;
next	1.135;

1.135
date	2004.02.21.02.13.35;	author drow;	state Exp;
branches
	1.135.2.1
	1.135.4.1;
next	1.134;

1.134
date	2004.02.14.15.46.32;	author ezannoni;	state Exp;
branches;
next	1.133;

1.133
date	2004.02.07.23.13.47;	author ezannoni;	state Exp;
branches;
next	1.132;

1.132
date	2004.02.07.18.29.53;	author ezannoni;	state Exp;
branches;
next	1.131;

1.131
date	2004.02.07.16.57.54;	author ezannoni;	state Exp;
branches;
next	1.130;

1.130
date	2004.01.28.18.43.06;	author carlton;	state Exp;
branches;
next	1.129;

1.129
date	2004.01.28.04.05.22;	author jimb;	state Exp;
branches;
next	1.128;

1.128
date	2004.01.28.04.02.51;	author jimb;	state Exp;
branches;
next	1.127;

1.127
date	2004.01.27.20.47.20;	author drow;	state Exp;
branches;
next	1.126;

1.126
date	2004.01.26.20.36.31;	author cagney;	state Exp;
branches;
next	1.125;

1.125
date	2004.01.26.19.55.45;	author cagney;	state Exp;
branches;
next	1.124;

1.124
date	2004.01.23.22.41.28;	author carlton;	state Exp;
branches;
next	1.123;

1.123
date	2004.01.22.19.56.54;	author carlton;	state Exp;
branches;
next	1.122;

1.122
date	2004.01.17.05.35.47;	author brobecke;	state Exp;
branches;
next	1.121;

1.121
date	2004.01.17.01.05.06;	author cagney;	state Exp;
branches;
next	1.120;

1.120
date	2004.01.14.16.54.41;	author carlton;	state Exp;
branches;
next	1.119;

1.119
date	2004.01.09.22.22.07;	author ezannoni;	state Exp;
branches;
next	1.118;

1.118
date	2004.01.09.15.33.15;	author ezannoni;	state Exp;
branches;
next	1.117;

1.117
date	2003.12.13.22.29.06;	author jimb;	state Exp;
branches;
next	1.116;

1.116
date	2003.12.02.16.41.39;	author drow;	state Exp;
branches;
next	1.115;

1.115
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches;
next	1.114;

1.114
date	2003.11.19.15.08.01;	author drow;	state Exp;
branches;
next	1.113;

1.113
date	2003.11.18.21.51.38;	author drow;	state Exp;
branches;
next	1.112;

1.112
date	2003.11.12.17.10.55;	author drow;	state Exp;
branches;
next	1.111;

1.111
date	2003.11.08.00.13.02;	author cagney;	state Exp;
branches;
next	1.110;

1.110
date	2003.10.02.17.13.16;	author jimb;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.30.22.29.28;	author carlton;	state Exp;
branches;
next	1.108;

1.108
date	2003.09.23.16.25.13;	author jimb;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.21.01.26.44;	author cagney;	state Exp;
branches;
next	1.106;

1.106
date	2003.09.16.18.56.35;	author cagney;	state Exp;
branches;
next	1.105;

1.105
date	2003.09.15.17.19.23;	author kevinb;	state Exp;
branches;
next	1.104;

1.104
date	2003.09.14.16.32.12;	author cagney;	state Exp;
branches;
next	1.103;

1.103
date	2003.09.12.18.40.16;	author cagney;	state Exp;
branches;
next	1.102;

1.102
date	2003.09.11.19.49.17;	author carlton;	state Exp;
branches;
next	1.101;

1.101
date	2003.09.09.23.23.05;	author carlton;	state Exp;
branches;
next	1.100;

1.100
date	2003.08.26.05.28.38;	author jason;	state Exp;
branches;
next	1.99;

1.99
date	2003.07.31.21.05.38;	author drow;	state Exp;
branches;
next	1.98;

1.98
date	2003.07.22.15.41.59;	author ezannoni;	state Exp;
branches;
next	1.97;

1.97
date	2003.06.26.21.20.39;	author ezannoni;	state Exp;
branches;
next	1.96;

1.96
date	2003.06.11.22.27.11;	author carlton;	state Exp;
branches
	1.96.4.1;
next	1.95;

1.95
date	2003.05.28.20.25.10;	author hjl;	state Exp;
branches;
next	1.94;

1.94
date	2003.05.14.17.43.17;	author ezannoni;	state Exp;
branches;
next	1.93;

1.93
date	2003.05.13.19.27.27;	author cagney;	state Exp;
branches;
next	1.92;

1.92
date	2003.05.08.18.05.37;	author brobecke;	state Exp;
branches
	1.92.4.1;
next	1.91;

1.91
date	2003.05.07.22.57.30;	author jjohnstn;	state Exp;
branches;
next	1.90;

1.90
date	2003.04.15.23.07.11;	author carlton;	state Exp;
branches
	1.90.2.1;
next	1.89;

1.89
date	2003.04.13.15.43.35;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2003.02.25.21.36.17;	author carlton;	state Exp;
branches;
next	1.87;

1.87
date	2003.02.21.15.24.17;	author drow;	state Exp;
branches;
next	1.86;

1.86
date	2003.02.14.19.05.52;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2003.02.04.20.17.02;	author jimb;	state Exp;
branches;
next	1.84;

1.84
date	2003.02.04.18.07.01;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2003.02.03.14.33.20;	author mludvig;	state Exp;
branches;
next	1.82;

1.82
date	2003.02.01.01.11.22;	author carlton;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2003.01.31.19.22.18;	author drow;	state Exp;
branches;
next	1.80;

1.80
date	2003.01.30.01.51.48;	author drow;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.18.15.55.51;	author cagney;	state Exp;
branches;
next	1.78;

1.78
date	2002.12.11.20.55.37;	author kevinb;	state Exp;
branches;
next	1.77;

1.77
date	2002.12.05.23.13.47;	author carlton;	state Exp;
branches;
next	1.76;

1.76
date	2002.11.25.22.01.39;	author carlton;	state Exp;
branches;
next	1.75;

1.75
date	2002.11.11.00.55.34;	author drow;	state Exp;
branches;
next	1.74;

1.74
date	2002.11.08.20.05.10;	author jimb;	state Exp;
branches;
next	1.73;

1.73
date	2002.11.08.19.33.37;	author jimb;	state Exp;
branches;
next	1.72;

1.72
date	2002.10.25.22.25.55;	author cagney;	state Exp;
branches;
next	1.71;

1.71
date	2002.10.23.16.40.55;	author carlton;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2002.10.21.19.11.50;	author ezannoni;	state Exp;
branches;
next	1.69;

1.69
date	2002.10.16.20.50.21;	author kevinb;	state Exp;
branches;
next	1.68;

1.68
date	2002.10.09.04.43.49;	author jimb;	state Exp;
branches;
next	1.67;

1.67
date	2002.10.01.23.51.43;	author ezannoni;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2002.09.03.17.32.11;	author carlton;	state Exp;
branches
	1.66.2.1
	1.66.4.1;
next	1.65;

1.65
date	2002.08.20.18.45.30;	author carlton;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.31.22.35.30;	author brobecke;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.16.21.00.43;	author kevinb;	state Exp;
branches;
next	1.62;

1.62
date	2002.07.12.19.55.10;	author petrs;	state Exp;
branches;
next	1.61;

1.61
date	2002.07.12.15.23.10;	author cagney;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.22.00.05.59;	author jimb;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.14.14.34.25;	author drow;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.24.19.41.45;	author jimb;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2002.05.16.21.00.12;	author jimb;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.14.18.30.50;	author drow;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2002.05.10.17.03.25;	author jimb;	state Exp;
branches;
next	1.54;

1.54
date	2002.05.06.21.00.20;	author jimb;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2002.04.26.20.08.19;	author ezannoni;	state Exp;
branches;
next	1.52;

1.52
date	2002.04.04.22.26.43;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2002.03.21.00.53.44;	author drow;	state Exp;
branches;
next	1.50;

1.50
date	2002.03.14.22.53.35;	author rth;	state Exp;
branches;
next	1.49;

1.49
date	2002.02.28.11.21.16;	author jason;	state Exp;
branches;
next	1.48;

1.48
date	2002.02.15.22.42.33;	author muller;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.20.19.42.04;	author drow;	state Exp;
branches;
next	1.46;

1.46
date	2002.01.20.19.20.15;	author drow;	state Exp;
branches;
next	1.45;

1.45
date	2002.01.20.19.12.23;	author drow;	state Exp;
branches;
next	1.44;

1.44
date	2002.01.11.16.56.04;	author petrs;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.11.09.32.50;	author jason;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.12.02.11.51;	author fnf;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.09.23.17.07;	author fnf;	state Exp;
branches;
next	1.40;

1.40
date	2001.12.09.07.29.46;	author fnf;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.09.07.26.47;	author fnf;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.07.22.11.51;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.07.12.10.15;	author smid;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.29.13.19.05;	author kwalker;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.17.00.08.10;	author jakub;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.12.20.36.55;	author geoffk;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.06.23.38.14;	author fnf;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.20.03.03.39;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.05.02.13.11;	author ezannoni;	state Exp;
branches;
next	1.30;

1.30
date	2001.07.30.23.16.44;	author jimb;	state Exp;
branches;
next	1.29;

1.29
date	2001.07.05.16.45.48;	author jimb;	state Exp;
branches
	1.29.2.1
	1.29.4.1;
next	1.28;

1.28
date	2001.07.04.16.08.20;	author jimb;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.04.16.00.08;	author jimb;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.02.17.43.07;	author jimb;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.08.18.08.03;	author bothner;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.30.10.30.27;	author eliz;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.06.08.21.07;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.08.06.03.52;	author cagney;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.24.00.22.47;	author jimb;	state Exp;
branches;
next	1.20;

1.20
date	2000.12.15.01.01.46;	author kevinb;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.08.20.12.36;	author msnyder;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.08.02.50.51;	author dberlin;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.03.22.38.38;	author kevinb;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.04.16.51.47;	author kevinb;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.04.16.25.30;	author kevinb;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.30.01.48.25;	author kevinb;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.24.17.07.26;	author jimb;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.24.01.26.10;	author cagney;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.18.07.47.02;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.14.23.29.06;	author jimb;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.05.20.49.53;	author dberlin;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.28.01.12.26;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.22.09.02.23;	author cagney;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.13.00.51.35;	author kevinb;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.12.41.48;	author phdm;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.08.22.35.35;	author jimb;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.29.05.10.04;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.14.04.37.06;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.755.2.1
date	2013.04.01.21.11.31;	author devans;	state Exp;
branches;
next	;

1.687.2.1
date	2012.07.20.17.59.04;	author devans;	state Exp;
branches;
next	1.687.2.2;

1.687.2.2
date	2012.08.27.16.42.55;	author jkratoch;	state Exp;
branches;
next	;

1.586.2.1
date	2012.01.06.04.43.11;	author brobecke;	state Exp;
branches;
next	1.586.2.2;

1.586.2.2
date	2012.01.11.19.09.32;	author devans;	state Exp;
branches;
next	;

1.518.2.1
date	2011.04.09.11.18.55;	author jkratoch;	state Exp;
branches;
next	1.518.2.2;

1.518.2.2
date	2011.04.20.20.10.29;	author jkratoch;	state Exp;
branches;
next	1.518.2.3;

1.518.2.3
date	2011.05.06.15.13.37;	author jkratoch;	state Exp;
branches;
next	1.518.2.4;

1.518.2.4
date	2011.05.11.17.25.07;	author tromey;	state Exp;
branches;
next	1.518.2.5;

1.518.2.5
date	2011.05.12.15.59.29;	author tromey;	state Exp;
branches;
next	1.518.2.6;

1.518.2.6
date	2011.05.17.21.26.39;	author brobecke;	state Exp;
branches;
next	1.518.2.7;

1.518.2.7
date	2011.07.02.19.37.21;	author jkratoch;	state Exp;
branches;
next	1.518.2.8;

1.518.2.8
date	2011.07.02.19.59.29;	author jkratoch;	state Exp;
branches;
next	1.518.2.9;

1.518.2.9
date	2011.07.12.21.12.56;	author jkratoch;	state Exp;
branches;
next	1.518.2.10;

1.518.2.10
date	2011.10.25.18.32.25;	author aristovski;	state Exp;
branches;
next	;

1.409.2.1
date	2010.07.07.18.50.57;	author tromey;	state Exp;
branches;
next	1.409.2.2;

1.409.2.2
date	2010.07.13.15.09.46;	author tromey;	state Exp;
branches;
next	1.409.2.3;

1.409.2.3
date	2010.07.21.18.01.20;	author palves;	state Exp;
branches;
next	1.409.2.4;

1.409.2.4
date	2010.08.27.18.37.18;	author devans;	state Exp;
branches;
next	1.409.2.5;

1.409.2.5
date	2010.11.25.19.42.31;	author devans;	state Exp;
branches;
next	;

1.356.2.1
date	2010.03.02.21.10.04;	author devans;	state Exp;
branches;
next	1.356.2.2;

1.356.2.2
date	2010.03.05.15.37.33;	author tromey;	state Exp;
branches;
next	1.356.2.3;

1.356.2.3
date	2010.04.08.17.15.11;	author swagiaal;	state Exp;
branches;
next	;

1.327.2.1
date	2009.11.24.17.23.03;	author tromey;	state Exp;
branches;
next	;

1.251.2.1
date	2008.03.10.14.18.10;	author drow;	state Exp;
branches
	1.251.2.1.4.1;
next	;

1.251.2.1.4.1
date	2009.03.09.20.36.07;	author amylaar;	state Exp;
branches;
next	;

1.196.2.1
date	2006.07.20.16.17.18;	author brobecke;	state Exp;
branches;
next	;

1.195.2.1
date	2006.08.28.07.48.49;	author nickrob;	state Exp;
branches;
next	;

1.193.2.1
date	2006.05.03.01.51.29;	author pbrook;	state Exp;
branches;
next	1.193.2.2;

1.193.2.2
date	2006.05.03.02.07.50;	author pbrook;	state Exp;
branches;
next	1.193.2.3;

1.193.2.3
date	2006.05.03.16.30.56;	author pbrook;	state Exp;
branches;
next	;

1.193.8.1
date	2006.04.17.14.21.14;	author drow;	state Exp;
branches;
next	1.193.8.2;

1.193.8.2
date	2006.09.28.20.18.16;	author drow;	state Exp;
branches;
next	;

1.184.2.1
date	2005.11.04.02.55.45;	author ezannoni;	state Exp;
branches;
next	1.184.2.2;

1.184.2.2
date	2005.11.04.02.58.31;	author ezannoni;	state Exp;
branches;
next	;

1.138.2.1
date	2004.03.21.23.57.33;	author cagney;	state Exp;
branches;
next	;

1.135.2.1
date	2004.02.21.20.17.22;	author drow;	state Exp;
branches;
next	1.135.2.2;

1.135.2.2
date	2004.02.21.20.27.26;	author drow;	state Exp;
branches;
next	1.135.2.3;

1.135.2.3
date	2004.02.21.20.37.00;	author drow;	state Exp;
branches;
next	1.135.2.4;

1.135.2.4
date	2004.02.21.20.39.33;	author drow;	state Exp;
branches;
next	1.135.2.5;

1.135.2.5
date	2004.02.21.20.46.11;	author drow;	state Exp;
branches;
next	1.135.2.6;

1.135.2.6
date	2004.02.21.20.50.11;	author drow;	state Exp;
branches;
next	1.135.2.7;

1.135.2.7
date	2004.02.21.20.55.18;	author drow;	state Exp;
branches;
next	1.135.2.8;

1.135.2.8
date	2004.02.21.21.00.12;	author drow;	state Exp;
branches;
next	1.135.2.9;

1.135.2.9
date	2004.02.21.21.08.33;	author drow;	state Exp;
branches;
next	1.135.2.10;

1.135.2.10
date	2004.02.21.21.14.10;	author drow;	state Exp;
branches;
next	1.135.2.11;

1.135.2.11
date	2004.02.21.21.26.33;	author drow;	state Exp;
branches;
next	1.135.2.12;

1.135.2.12
date	2004.02.21.21.27.48;	author drow;	state Exp;
branches;
next	1.135.2.13;

1.135.2.13
date	2004.02.21.21.32.25;	author drow;	state Exp;
branches;
next	1.135.2.14;

1.135.2.14
date	2004.02.22.00.56.11;	author drow;	state Exp;
branches;
next	1.135.2.15;

1.135.2.15
date	2004.02.22.01.34.13;	author drow;	state Exp;
branches;
next	1.135.2.16;

1.135.2.16
date	2004.02.22.06.11.54;	author drow;	state Exp;
branches;
next	1.135.2.17;

1.135.2.17
date	2004.02.22.06.54.49;	author drow;	state Exp;
branches;
next	1.135.2.18;

1.135.2.18
date	2004.02.22.19.11.56;	author drow;	state Exp;
branches;
next	1.135.2.19;

1.135.2.19
date	2004.02.22.19.26.43;	author drow;	state Exp;
branches;
next	1.135.2.20;

1.135.2.20
date	2004.02.22.20.58.43;	author drow;	state Exp;
branches;
next	1.135.2.21;

1.135.2.21
date	2004.02.22.21.00.47;	author drow;	state Exp;
branches;
next	1.135.2.22;

1.135.2.22
date	2004.02.22.23.04.57;	author drow;	state Exp;
branches;
next	1.135.2.23;

1.135.2.23
date	2004.02.23.16.34.26;	author drow;	state Exp;
branches;
next	1.135.2.24;

1.135.2.24
date	2004.02.23.16.58.03;	author drow;	state Exp;
branches;
next	1.135.2.25;

1.135.2.25
date	2004.02.23.18.13.51;	author drow;	state Exp;
branches;
next	1.135.2.26;

1.135.2.26
date	2004.02.23.19.33.47;	author drow;	state Exp;
branches;
next	1.135.2.27;

1.135.2.27
date	2004.02.23.20.02.37;	author drow;	state Exp;
branches;
next	1.135.2.28;

1.135.2.28
date	2004.02.23.20.09.15;	author drow;	state Exp;
branches;
next	1.135.2.29;

1.135.2.29
date	2004.02.23.21.09.12;	author drow;	state Exp;
branches;
next	1.135.2.30;

1.135.2.30
date	2004.02.24.00.07.37;	author drow;	state Exp;
branches;
next	1.135.2.31;

1.135.2.31
date	2004.02.24.03.27.21;	author drow;	state Exp;
branches;
next	1.135.2.32;

1.135.2.32
date	2004.02.25.00.02.26;	author drow;	state Exp;
branches;
next	1.135.2.33;

1.135.2.33
date	2004.02.25.03.08.20;	author drow;	state Exp;
branches;
next	1.135.2.34;

1.135.2.34
date	2004.02.25.03.45.12;	author drow;	state Exp;
branches;
next	1.135.2.35;

1.135.2.35
date	2004.03.14.21.09.19;	author drow;	state Exp;
branches;
next	1.135.2.36;

1.135.2.36
date	2004.03.27.17.37.45;	author drow;	state Exp;
branches;
next	1.135.2.37;

1.135.2.37
date	2004.04.01.18.05.56;	author drow;	state Exp;
branches;
next	1.135.2.38;

1.135.2.38
date	2004.04.02.02.47.30;	author drow;	state Exp;
branches;
next	1.135.2.39;

1.135.2.39
date	2004.04.02.16.47.45;	author drow;	state Exp;
branches;
next	1.135.2.40;

1.135.2.40
date	2004.04.02.17.38.02;	author drow;	state Exp;
branches;
next	1.135.2.41;

1.135.2.41
date	2004.04.19.03.37.36;	author drow;	state Exp;
branches;
next	1.135.2.42;

1.135.2.42
date	2004.04.19.20.35.19;	author drow;	state Exp;
branches;
next	1.135.2.43;

1.135.2.43
date	2004.04.19.22.36.24;	author drow;	state Exp;
branches;
next	1.135.2.44;

1.135.2.44
date	2004.08.07.18.34.06;	author drow;	state Exp;
branches;
next	1.135.2.45;

1.135.2.45
date	2004.09.16.17.01.02;	author drow;	state Exp;
branches;
next	1.135.2.46;

1.135.2.46
date	2004.09.21.20.44.16;	author drow;	state Exp;
branches;
next	;

1.135.4.1
date	2004.03.14.21.08.37;	author drow;	state Exp;
branches;
next	1.135.4.2;

1.135.4.2
date	2004.03.15.22.53.53;	author carlton;	state Exp;
branches;
next	1.135.4.3;

1.135.4.3
date	2004.03.16.22.46.05;	author carlton;	state Exp;
branches;
next	;

1.96.4.1
date	2003.06.26.21.35.59;	author ezannoni;	state Exp;
branches;
next	1.96.4.2;

1.96.4.2
date	2003.07.22.15.44.10;	author ezannoni;	state Exp;
branches;
next	1.96.4.3;

1.96.4.3
date	2003.10.09.14.26.14;	author drow;	state Exp;
branches;
next	1.96.4.4;

1.96.4.4
date	2003.10.17.21.46.51;	author jimb;	state Exp;
branches;
next	;

1.92.4.1
date	2003.06.03.20.54.34;	author cagney;	state Exp;
branches;
next	;

1.90.2.1
date	2003.05.18.09.44.05;	author kettenis;	state Exp;
branches;
next	;

1.82.2.1
date	2003.02.03.22.00.55;	author cagney;	state Exp;
branches;
next	;

1.71.2.1
date	2002.10.26.05.42.22;	author jimb;	state Exp;
branches;
next	;

1.67.2.1
date	2002.10.22.19.59.36;	author carlton;	state Exp;
branches;
next	1.67.2.2;

1.67.2.2
date	2002.10.26.17.12.06;	author drow;	state Exp;
branches;
next	1.67.2.3;

1.67.2.3
date	2002.11.22.17.15.55;	author carlton;	state Exp;
branches;
next	1.67.2.4;

1.67.2.4
date	2003.12.14.20.27.11;	author drow;	state Exp;
branches;
next	1.67.2.5;

1.67.2.5
date	2003.12.30.21.01.20;	author drow;	state Exp;
branches;
next	1.67.2.6;

1.67.2.6
date	2004.01.04.22.42.41;	author drow;	state Exp;
branches;
next	1.67.2.7;

1.67.2.7
date	2004.01.13.16.11.55;	author drow;	state Exp;
branches;
next	1.67.2.8;

1.67.2.8
date	2004.02.09.19.43.36;	author drow;	state Exp;
branches;
next	;

1.66.2.1
date	2002.10.23.18.20.42;	author carlton;	state Exp;
branches;
next	1.66.2.2;

1.66.2.2
date	2002.11.25.21.46.54;	author carlton;	state Exp;
branches;
next	1.66.2.3;

1.66.2.3
date	2003.02.03.14.40.09;	author mludvig;	state Exp;
branches;
next	;

1.66.4.1
date	2002.09.20.18.52.16;	author carlton;	state Exp;
branches;
next	1.66.4.2;

1.66.4.2
date	2002.10.11.22.22.53;	author carlton;	state Exp;
branches;
next	1.66.4.3;

1.66.4.3
date	2002.10.18.00.00.15;	author carlton;	state Exp;
branches;
next	1.66.4.4;

1.66.4.4
date	2002.10.18.23.42.57;	author carlton;	state Exp;
branches;
next	1.66.4.5;

1.66.4.5
date	2002.10.22.00.17.27;	author carlton;	state Exp;
branches;
next	1.66.4.6;

1.66.4.6
date	2002.10.22.23.22.56;	author carlton;	state Exp;
branches;
next	1.66.4.7;

1.66.4.7
date	2002.10.25.23.49.53;	author carlton;	state Exp;
branches;
next	1.66.4.8;

1.66.4.8
date	2002.11.14.00.07.54;	author carlton;	state Exp;
branches;
next	1.66.4.9;

1.66.4.9
date	2002.11.15.19.18.42;	author carlton;	state Exp;
branches;
next	1.66.4.10;

1.66.4.10
date	2002.11.20.01.09.53;	author carlton;	state Exp;
branches;
next	1.66.4.11;

1.66.4.11
date	2002.11.21.01.04.21;	author carlton;	state Exp;
branches;
next	1.66.4.12;

1.66.4.12
date	2002.11.22.01.16.13;	author carlton;	state Exp;
branches;
next	1.66.4.13;

1.66.4.13
date	2002.11.28.00.53.23;	author carlton;	state Exp;
branches;
next	1.66.4.14;

1.66.4.14
date	2002.12.01.22.07.55;	author carlton;	state Exp;
branches;
next	1.66.4.15;

1.66.4.15
date	2002.12.18.00.45.41;	author carlton;	state Exp;
branches;
next	1.66.4.16;

1.66.4.16
date	2002.12.19.01.03.06;	author carlton;	state Exp;
branches;
next	1.66.4.17;

1.66.4.17
date	2002.12.23.19.38.20;	author carlton;	state Exp;
branches;
next	1.66.4.18;

1.66.4.18
date	2003.01.08.00.32.10;	author carlton;	state Exp;
branches;
next	1.66.4.19;

1.66.4.19
date	2003.01.11.01.11.02;	author carlton;	state Exp;
branches;
next	1.66.4.20;

1.66.4.20
date	2003.01.21.01.02.29;	author carlton;	state Exp;
branches;
next	1.66.4.21;

1.66.4.21
date	2003.02.07.19.17.48;	author carlton;	state Exp;
branches;
next	1.66.4.22;

1.66.4.22
date	2003.02.22.01.33.13;	author carlton;	state Exp;
branches;
next	1.66.4.23;

1.66.4.23
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.66.4.24;

1.66.4.24
date	2003.04.16.19.56.51;	author carlton;	state Exp;
branches;
next	1.66.4.25;

1.66.4.25
date	2003.04.18.18.10.48;	author carlton;	state Exp;
branches;
next	1.66.4.26;

1.66.4.26
date	2003.05.16.23.32.26;	author carlton;	state Exp;
branches;
next	1.66.4.27;

1.66.4.27
date	2003.05.23.18.40.36;	author carlton;	state Exp;
branches;
next	1.66.4.28;

1.66.4.28
date	2003.05.28.22.31.11;	author carlton;	state Exp;
branches;
next	1.66.4.29;

1.66.4.29
date	2003.05.29.00.01.36;	author carlton;	state Exp;
branches;
next	1.66.4.30;

1.66.4.30
date	2003.06.12.18.45.48;	author carlton;	state Exp;
branches;
next	1.66.4.31;

1.66.4.31
date	2003.06.16.20.00.45;	author carlton;	state Exp;
branches;
next	1.66.4.32;

1.66.4.32
date	2003.06.27.21.49.53;	author carlton;	state Exp;
branches;
next	1.66.4.33;

1.66.4.33
date	2003.06.27.22.47.33;	author carlton;	state Exp;
branches;
next	1.66.4.34;

1.66.4.34
date	2003.08.05.17.13.05;	author carlton;	state Exp;
branches;
next	1.66.4.35;

1.66.4.35
date	2003.09.17.21.28.15;	author carlton;	state Exp;
branches;
next	1.66.4.36;

1.66.4.36
date	2003.09.30.18.16.07;	author carlton;	state Exp;
branches;
next	1.66.4.37;

1.66.4.37
date	2003.11.11.23.50.42;	author carlton;	state Exp;
branches;
next	1.66.4.38;

1.66.4.38
date	2003.11.12.00.20.58;	author carlton;	state Exp;
branches;
next	1.66.4.39;

1.66.4.39
date	2003.12.15.21.16.06;	author carlton;	state Exp;
branches;
next	1.66.4.40;

1.66.4.40
date	2003.12.15.21.28.54;	author carlton;	state Exp;
branches;
next	1.66.4.41;

1.66.4.41
date	2003.12.16.00.00.26;	author carlton;	state Exp;
branches;
next	1.66.4.42;

1.66.4.42
date	2004.01.26.19.11.23;	author carlton;	state Exp;
branches;
next	;

1.58.2.1
date	2002.06.20.01.32.22;	author kseitz;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2002.07.22.21.46.58;	author kseitz;	state Exp;
branches;
next	1.58.2.3;

1.58.2.3
date	2002.08.09.18.34.23;	author kseitz;	state Exp;
branches;
next	1.58.2.4;

1.58.2.4
date	2002.08.30.22.52.43;	author kseitz;	state Exp;
branches;
next	1.58.2.5;

1.58.2.5
date	2002.10.01.00.46.07;	author kseitz;	state Exp;
branches;
next	1.58.2.6;

1.58.2.6
date	2002.11.04.00.17.30;	author ezannoni;	state Exp;
branches;
next	;

1.56.2.1
date	2002.06.15.16.42.51;	author cagney;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2002.06.25.20.02.40;	author cagney;	state Exp;
branches;
next	;

1.54.2.1
date	2002.05.09.20.03.36;	author jimb;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2002.05.09.23.32.43;	author jimb;	state Exp;
branches;
next	;

1.29.2.1
date	2001.07.06.19.16.58;	author dberlin;	state Exp;
branches;
next	;

1.29.4.1
date	2001.12.07.14.54.29;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.33.59;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.24.03;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.07.07.20.05.44;	author jsm;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	99.08.02.23.45.24;	author jsm;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	99.08.09.21.33.23;	author jsm;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	99.09.08.23.59.07;	author shebs;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	99.09.22.03.24.25;	author jsm;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	99.10.05.23.08.10;	author jsm;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	99.10.12.04.37.20;	author jsm;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2000.02.05.07.29.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.844
log
@There were two functions who were calling "sizeof" twice.

The first one, dw2_get_real_path from gdb/dwarf2read.c, was actually
making use of OBSTACK_CALLOC which already calls "sizeof" for its third
argument.

The second, download_tracepoint_1 from gdb/gdbserver/tracepoint.c, was
explicitly calling "sizeof" inside another "sizeof".

This patch fixed both functions.

gdb/ChangeLog
2013-10-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR gdb/16014
	* dwarf2read.c (dw2_get_real_path): Remove unnecessary call to
	sizeof.

gdb/gdbserver/ChangeLog
2013-10-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR gdb/16014
	* tracepoint.c (download_tracepoint_1): Remove unnecessary double
	call to sizeof.
@
text
@/* DWARF 2 debugging format support for GDB.

   Copyright (C) 1994-2013 Free Software Foundation, Inc.

   Adapted by Gary Funck (gary@@intrepid.com), Intrepid Technology,
   Inc.  with support from Florida State University (under contract
   with the Ada Joint Program Office), and Silicon Graphics, Inc.
   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,
   based on Fred Fish's (Cygnus Support) implementation of DWARF 1
   support.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/* FIXME: Various die-reading functions need to be more careful with
   reading off the end of the section.
   E.g., load_partial_dies, read_partial_die.  */

#include "defs.h"
#include "bfd.h"
#include "elf-bfd.h"
#include "symtab.h"
#include "gdbtypes.h"
#include "objfiles.h"
#include "dwarf2.h"
#include "buildsym.h"
#include "demangle.h"
#include "gdb-demangle.h"
#include "expression.h"
#include "filenames.h"	/* for DOSish file names */
#include "macrotab.h"
#include "language.h"
#include "complaints.h"
#include "bcache.h"
#include "dwarf2expr.h"
#include "dwarf2loc.h"
#include "cp-support.h"
#include "hashtab.h"
#include "command.h"
#include "gdbcmd.h"
#include "block.h"
#include "addrmap.h"
#include "typeprint.h"
#include "jv-lang.h"
#include "psympriv.h"
#include "exceptions.h"
#include "gdb_stat.h"
#include "completer.h"
#include "vec.h"
#include "c-lang.h"
#include "go-lang.h"
#include "valprint.h"
#include "gdbcore.h" /* for gnutarget */
#include "gdb/gdb-index.h"
#include <ctype.h>
#include "gdb_bfd.h"
#include "f-lang.h"
#include "source.h"
#include "filestuff.h"
#include "build-id.h"

#include <fcntl.h>
#include "gdb_string.h"
#include "gdb_assert.h"
#include <sys/types.h>

typedef struct symbol *symbolp;
DEF_VEC_P (symbolp);

/* When non-zero, print basic high level tracing messages.
   This is in contrast to the low level DIE reading of dwarf2_die_debug.  */
static int dwarf2_read_debug = 0;

/* When non-zero, dump DIEs after they are read in.  */
static unsigned int dwarf2_die_debug = 0;

/* When non-zero, cross-check physname against demangler.  */
static int check_physname = 0;

/* When non-zero, do not reject deprecated .gdb_index sections.  */
static int use_deprecated_index_sections = 0;

static const struct objfile_data *dwarf2_objfile_data_key;

/* The "aclass" indices for various kinds of computed DWARF symbols.  */

static int dwarf2_locexpr_index;
static int dwarf2_loclist_index;
static int dwarf2_locexpr_block_index;
static int dwarf2_loclist_block_index;

/* A descriptor for dwarf sections.

   S.ASECTION, SIZE are typically initialized when the objfile is first
   scanned.  BUFFER, READIN are filled in later when the section is read.
   If the section contained compressed data then SIZE is updated to record
   the uncompressed size of the section.

   DWP file format V2 introduces a wrinkle that is easiest to handle by
   creating the concept of virtual sections contained within a real section.
   In DWP V2 the sections of the input DWO files are concatenated together
   into one section, but section offsets are kept relative to the original
   input section.
   If this is a virtual dwp-v2 section, S.CONTAINING_SECTION is a backlink to
   the real section this "virtual" section is contained in, and BUFFER,SIZE
   describe the virtual section.  */

struct dwarf2_section_info
{
  union
  {
    /* If this is a real section, the bfd section.  */
    asection *asection;
    /* If this is a virtual section, pointer to the containing ("real")
       section.  */
    struct dwarf2_section_info *containing_section;
  } s;
  /* Pointer to section data, only valid if readin.  */
  const gdb_byte *buffer;
  /* The size of the section, real or virtual.  */
  bfd_size_type size;
  /* If this is a virtual section, the offset in the real section.
     Only valid if is_virtual.  */
  bfd_size_type virtual_offset;
  /* True if we have tried to read this section.  */
  char readin;
  /* True if this is a virtual section, False otherwise.
     This specifies which of s.asection and s.containing_section to use.  */
  char is_virtual;
};

typedef struct dwarf2_section_info dwarf2_section_info_def;
DEF_VEC_O (dwarf2_section_info_def);

/* All offsets in the index are of this type.  It must be
   architecture-independent.  */
typedef uint32_t offset_type;

DEF_VEC_I (offset_type);

/* Ensure only legit values are used.  */
#define DW2_GDB_INDEX_SYMBOL_STATIC_SET_VALUE(cu_index, value) \
  do { \
    gdb_assert ((unsigned int) (value) <= 1); \
    GDB_INDEX_SYMBOL_STATIC_SET_VALUE((cu_index), (value)); \
  } while (0)

/* Ensure only legit values are used.  */
#define DW2_GDB_INDEX_SYMBOL_KIND_SET_VALUE(cu_index, value) \
  do { \
    gdb_assert ((value) >= GDB_INDEX_SYMBOL_KIND_TYPE \
                && (value) <= GDB_INDEX_SYMBOL_KIND_OTHER); \
    GDB_INDEX_SYMBOL_KIND_SET_VALUE((cu_index), (value)); \
  } while (0)

/* Ensure we don't use more than the alloted nuber of bits for the CU.  */
#define DW2_GDB_INDEX_CU_SET_VALUE(cu_index, value) \
  do { \
    gdb_assert (((value) & ~GDB_INDEX_CU_MASK) == 0); \
    GDB_INDEX_CU_SET_VALUE((cu_index), (value)); \
  } while (0)

/* A description of the mapped index.  The file format is described in
   a comment by the code that writes the index.  */
struct mapped_index
{
  /* Index data format version.  */
  int version;

  /* The total length of the buffer.  */
  off_t total_size;

  /* A pointer to the address table data.  */
  const gdb_byte *address_table;

  /* Size of the address table data in bytes.  */
  offset_type address_table_size;

  /* The symbol table, implemented as a hash table.  */
  const offset_type *symbol_table;

  /* Size in slots, each slot is 2 offset_types.  */
  offset_type symbol_table_slots;

  /* A pointer to the constant pool.  */
  const char *constant_pool;
};

typedef struct dwarf2_per_cu_data *dwarf2_per_cu_ptr;
DEF_VEC_P (dwarf2_per_cu_ptr);

/* Collection of data recorded per objfile.
   This hangs off of dwarf2_objfile_data_key.  */

struct dwarf2_per_objfile
{
  struct dwarf2_section_info info;
  struct dwarf2_section_info abbrev;
  struct dwarf2_section_info line;
  struct dwarf2_section_info loc;
  struct dwarf2_section_info macinfo;
  struct dwarf2_section_info macro;
  struct dwarf2_section_info str;
  struct dwarf2_section_info ranges;
  struct dwarf2_section_info addr;
  struct dwarf2_section_info frame;
  struct dwarf2_section_info eh_frame;
  struct dwarf2_section_info gdb_index;

  VEC (dwarf2_section_info_def) *types;

  /* Back link.  */
  struct objfile *objfile;

  /* Table of all the compilation units.  This is used to locate
     the target compilation unit of a particular reference.  */
  struct dwarf2_per_cu_data **all_comp_units;

  /* The number of compilation units in ALL_COMP_UNITS.  */
  int n_comp_units;

  /* The number of .debug_types-related CUs.  */
  int n_type_units;

  /* The .debug_types-related CUs (TUs).
     This is stored in malloc space because we may realloc it.  */
  struct signatured_type **all_type_units;

  /* The number of entries in all_type_unit_groups.  */
  int n_type_unit_groups;

  /* Table of type unit groups.
     This exists to make it easy to iterate over all CUs and TU groups.  */
  struct type_unit_group **all_type_unit_groups;

  /* Table of struct type_unit_group objects.
     The hash key is the DW_AT_stmt_list value.  */
  htab_t type_unit_groups;

  /* A table mapping .debug_types signatures to its signatured_type entry.
     This is NULL if the .debug_types section hasn't been read in yet.  */
  htab_t signatured_types;

  /* Type unit statistics, to see how well the scaling improvements
     are doing.  */
  struct tu_stats
  {
    int nr_uniq_abbrev_tables;
    int nr_symtabs;
    int nr_symtab_sharers;
    int nr_stmt_less_type_units;
  } tu_stats;

  /* A chain of compilation units that are currently read in, so that
     they can be freed later.  */
  struct dwarf2_per_cu_data *read_in_chain;

  /* A table mapping DW_AT_dwo_name values to struct dwo_file objects.
     This is NULL if the table hasn't been allocated yet.  */
  htab_t dwo_files;

  /* Non-zero if we've check for whether there is a DWP file.  */
  int dwp_checked;

  /* The DWP file if there is one, or NULL.  */
  struct dwp_file *dwp_file;

  /* The shared '.dwz' file, if one exists.  This is used when the
     original data was compressed using 'dwz -m'.  */
  struct dwz_file *dwz_file;

  /* A flag indicating wether this objfile has a section loaded at a
     VMA of 0.  */
  int has_section_at_zero;

  /* True if we are using the mapped index,
     or we are faking it for OBJF_READNOW's sake.  */
  unsigned char using_index;

  /* The mapped index, or NULL if .gdb_index is missing or not being used.  */
  struct mapped_index *index_table;

  /* When using index_table, this keeps track of all quick_file_names entries.
     TUs typically share line table entries with a CU, so we maintain a
     separate table of all line table entries to support the sharing.
     Note that while there can be way more TUs than CUs, we've already
     sorted all the TUs into "type unit groups", grouped by their
     DW_AT_stmt_list value.  Therefore the only sharing done here is with a
     CU and its associated TU group if there is one.  */
  htab_t quick_file_names_table;

  /* Set during partial symbol reading, to prevent queueing of full
     symbols.  */
  int reading_partial_symbols;

  /* Table mapping type DIEs to their struct type *.
     This is NULL if not allocated yet.
     The mapping is done via (CU/TU + DIE offset) -> type.  */
  htab_t die_type_hash;

  /* The CUs we recently read.  */
  VEC (dwarf2_per_cu_ptr) *just_read_cus;
};

static struct dwarf2_per_objfile *dwarf2_per_objfile;

/* Default names of the debugging sections.  */

/* Note that if the debugging section has been compressed, it might
   have a name like .zdebug_info.  */

static const struct dwarf2_debug_sections dwarf2_elf_names =
{
  { ".debug_info", ".zdebug_info" },
  { ".debug_abbrev", ".zdebug_abbrev" },
  { ".debug_line", ".zdebug_line" },
  { ".debug_loc", ".zdebug_loc" },
  { ".debug_macinfo", ".zdebug_macinfo" },
  { ".debug_macro", ".zdebug_macro" },
  { ".debug_str", ".zdebug_str" },
  { ".debug_ranges", ".zdebug_ranges" },
  { ".debug_types", ".zdebug_types" },
  { ".debug_addr", ".zdebug_addr" },
  { ".debug_frame", ".zdebug_frame" },
  { ".eh_frame", NULL },
  { ".gdb_index", ".zgdb_index" },
  23
};

/* List of DWO/DWP sections.  */

static const struct dwop_section_names
{
  struct dwarf2_section_names abbrev_dwo;
  struct dwarf2_section_names info_dwo;
  struct dwarf2_section_names line_dwo;
  struct dwarf2_section_names loc_dwo;
  struct dwarf2_section_names macinfo_dwo;
  struct dwarf2_section_names macro_dwo;
  struct dwarf2_section_names str_dwo;
  struct dwarf2_section_names str_offsets_dwo;
  struct dwarf2_section_names types_dwo;
  struct dwarf2_section_names cu_index;
  struct dwarf2_section_names tu_index;
}
dwop_section_names =
{
  { ".debug_abbrev.dwo", ".zdebug_abbrev.dwo" },
  { ".debug_info.dwo", ".zdebug_info.dwo" },
  { ".debug_line.dwo", ".zdebug_line.dwo" },
  { ".debug_loc.dwo", ".zdebug_loc.dwo" },
  { ".debug_macinfo.dwo", ".zdebug_macinfo.dwo" },
  { ".debug_macro.dwo", ".zdebug_macro.dwo" },
  { ".debug_str.dwo", ".zdebug_str.dwo" },
  { ".debug_str_offsets.dwo", ".zdebug_str_offsets.dwo" },
  { ".debug_types.dwo", ".zdebug_types.dwo" },
  { ".debug_cu_index", ".zdebug_cu_index" },
  { ".debug_tu_index", ".zdebug_tu_index" },
};

/* local data types */

/* The data in a compilation unit header, after target2host
   translation, looks like this.  */
struct comp_unit_head
{
  unsigned int length;
  short version;
  unsigned char addr_size;
  unsigned char signed_addr_p;
  sect_offset abbrev_offset;

  /* Size of file offsets; either 4 or 8.  */
  unsigned int offset_size;

  /* Size of the length field; either 4 or 12.  */
  unsigned int initial_length_size;

  /* Offset to the first byte of this compilation unit header in the
     .debug_info section, for resolving relative reference dies.  */
  sect_offset offset;

  /* Offset to first die in this cu from the start of the cu.
     This will be the first byte following the compilation unit header.  */
  cu_offset first_die_offset;
};

/* Type used for delaying computation of method physnames.
   See comments for compute_delayed_physnames.  */
struct delayed_method_info
{
  /* The type to which the method is attached, i.e., its parent class.  */
  struct type *type;

  /* The index of the method in the type's function fieldlists.  */
  int fnfield_index;

  /* The index of the method in the fieldlist.  */
  int index;

  /* The name of the DIE.  */
  const char *name;

  /*  The DIE associated with this method.  */
  struct die_info *die;
};

typedef struct delayed_method_info delayed_method_info;
DEF_VEC_O (delayed_method_info);

/* Internal state when decoding a particular compilation unit.  */
struct dwarf2_cu
{
  /* The objfile containing this compilation unit.  */
  struct objfile *objfile;

  /* The header of the compilation unit.  */
  struct comp_unit_head header;

  /* Base address of this compilation unit.  */
  CORE_ADDR base_address;

  /* Non-zero if base_address has been set.  */
  int base_known;

  /* The language we are debugging.  */
  enum language language;
  const struct language_defn *language_defn;

  const char *producer;

  /* The generic symbol table building routines have separate lists for
     file scope symbols and all all other scopes (local scopes).  So
     we need to select the right one to pass to add_symbol_to_list().
     We do it by keeping a pointer to the correct list in list_in_scope.

     FIXME: The original dwarf code just treated the file scope as the
     first local scope, and all other local scopes as nested local
     scopes, and worked fine.  Check to see if we really need to
     distinguish these in buildsym.c.  */
  struct pending **list_in_scope;

  /* The abbrev table for this CU.
     Normally this points to the abbrev table in the objfile.
     But if DWO_UNIT is non-NULL this is the abbrev table in the DWO file.  */
  struct abbrev_table *abbrev_table;

  /* Hash table holding all the loaded partial DIEs
     with partial_die->offset.SECT_OFF as hash.  */
  htab_t partial_dies;

  /* Storage for things with the same lifetime as this read-in compilation
     unit, including partial DIEs.  */
  struct obstack comp_unit_obstack;

  /* When multiple dwarf2_cu structures are living in memory, this field
     chains them all together, so that they can be released efficiently.
     We will probably also want a generation counter so that most-recently-used
     compilation units are cached...  */
  struct dwarf2_per_cu_data *read_in_chain;

  /* Backlink to our per_cu entry.  */
  struct dwarf2_per_cu_data *per_cu;

  /* How many compilation units ago was this CU last referenced?  */
  int last_used;

  /* A hash table of DIE cu_offset for following references with
     die_info->offset.sect_off as hash.  */
  htab_t die_hash;

  /* Full DIEs if read in.  */
  struct die_info *dies;

  /* A set of pointers to dwarf2_per_cu_data objects for compilation
     units referenced by this one.  Only set during full symbol processing;
     partial symbol tables do not have dependencies.  */
  htab_t dependencies;

  /* Header data from the line table, during full symbol processing.  */
  struct line_header *line_header;

  /* A list of methods which need to have physnames computed
     after all type information has been read.  */
  VEC (delayed_method_info) *method_list;

  /* To be copied to symtab->call_site_htab.  */
  htab_t call_site_htab;

  /* Non-NULL if this CU came from a DWO file.
     There is an invariant here that is important to remember:
     Except for attributes copied from the top level DIE in the "main"
     (or "stub") file in preparation for reading the DWO file
     (e.g., DW_AT_GNU_addr_base), we KISS: there is only *one* CU.
     Either there isn't a DWO file (in which case this is NULL and the point
     is moot), or there is and either we're not going to read it (in which
     case this is NULL) or there is and we are reading it (in which case this
     is non-NULL).  */
  struct dwo_unit *dwo_unit;

  /* The DW_AT_addr_base attribute if present, zero otherwise
     (zero is a valid value though).
     Note this value comes from the stub CU/TU's DIE.  */
  ULONGEST addr_base;

  /* The DW_AT_ranges_base attribute if present, zero otherwise
     (zero is a valid value though).
     Note this value comes from the stub CU/TU's DIE.
     Also note that the value is zero in the non-DWO case so this value can
     be used without needing to know whether DWO files are in use or not.
     N.B. This does not apply to DW_AT_ranges appearing in
     DW_TAG_compile_unit dies.  This is a bit of a wart, consider if ever
     DW_AT_ranges appeared in the DW_TAG_compile_unit of DWO DIEs: then
     DW_AT_ranges_base *would* have to be applied, and we'd have to care
     whether the DW_AT_ranges attribute came from the skeleton or DWO.  */
  ULONGEST ranges_base;

  /* Mark used when releasing cached dies.  */
  unsigned int mark : 1;

  /* This CU references .debug_loc.  See the symtab->locations_valid field.
     This test is imperfect as there may exist optimized debug code not using
     any location list and still facing inlining issues if handled as
     unoptimized code.  For a future better test see GCC PR other/32998.  */
  unsigned int has_loclist : 1;

  /* These cache the results for producer_is_* fields.  CHECKED_PRODUCER is set
     if all the producer_is_* fields are valid.  This information is cached
     because profiling CU expansion showed excessive time spent in
     producer_is_gxx_lt_4_6.  */
  unsigned int checked_producer : 1;
  unsigned int producer_is_gxx_lt_4_6 : 1;
  unsigned int producer_is_gcc_lt_4_3 : 1;
  unsigned int producer_is_icc : 1;

  /* When set, the file that we're processing is known to have
     debugging info for C++ namespaces.  GCC 3.3.x did not produce
     this information, but later versions do.  */

  unsigned int processing_has_namespace_info : 1;
};

/* Persistent data held for a compilation unit, even when not
   processing it.  We put a pointer to this structure in the
   read_symtab_private field of the psymtab.  */

struct dwarf2_per_cu_data
{
  /* The start offset and length of this compilation unit.
     NOTE: Unlike comp_unit_head.length, this length includes
     initial_length_size.
     If the DIE refers to a DWO file, this is always of the original die,
     not the DWO file.  */
  sect_offset offset;
  unsigned int length;

  /* Flag indicating this compilation unit will be read in before
     any of the current compilation units are processed.  */
  unsigned int queued : 1;

  /* This flag will be set when reading partial DIEs if we need to load
     absolutely all DIEs for this compilation unit, instead of just the ones
     we think are interesting.  It gets set if we look for a DIE in the
     hash table and don't find it.  */
  unsigned int load_all_dies : 1;

  /* Non-zero if this CU is from .debug_types.
     Struct dwarf2_per_cu_data is contained in struct signatured_type iff
     this is non-zero.  */
  unsigned int is_debug_types : 1;

  /* Non-zero if this CU is from the .dwz file.  */
  unsigned int is_dwz : 1;

  /* Non-zero if reading a TU directly from a DWO file, bypassing the stub.
     This flag is only valid if is_debug_types is true.
     We can't read a CU directly from a DWO file: There are required
     attributes in the stub.  */
  unsigned int reading_dwo_directly : 1;

  /* Non-zero if the TU has been read.
     This is used to assist the "Stay in DWO Optimization" for Fission:
     When reading a DWO, it's faster to read TUs from the DWO instead of
     fetching them from random other DWOs (due to comdat folding).
     If the TU has already been read, the optimization is unnecessary
     (and unwise - we don't want to change where gdb thinks the TU lives
     "midflight").
     This flag is only valid if is_debug_types is true.  */
  unsigned int tu_read : 1;

  /* The section this CU/TU lives in.
     If the DIE refers to a DWO file, this is always the original die,
     not the DWO file.  */
  struct dwarf2_section_info *section;

  /* Set to non-NULL iff this CU is currently loaded.  When it gets freed out
     of the CU cache it gets reset to NULL again.  */
  struct dwarf2_cu *cu;

  /* The corresponding objfile.
     Normally we can get the objfile from dwarf2_per_objfile.
     However we can enter this file with just a "per_cu" handle.  */
  struct objfile *objfile;

  /* When using partial symbol tables, the 'psymtab' field is active.
     Otherwise the 'quick' field is active.  */
  union
  {
    /* The partial symbol table associated with this compilation unit,
       or NULL for unread partial units.  */
    struct partial_symtab *psymtab;

    /* Data needed by the "quick" functions.  */
    struct dwarf2_per_cu_quick_data *quick;
  } v;

  /* The CUs we import using DW_TAG_imported_unit.  This is filled in
     while reading psymtabs, used to compute the psymtab dependencies,
     and then cleared.  Then it is filled in again while reading full
     symbols, and only deleted when the objfile is destroyed.

     This is also used to work around a difference between the way gold
     generates .gdb_index version <=7 and the way gdb does.  Arguably this
     is a gold bug.  For symbols coming from TUs, gold records in the index
     the CU that includes the TU instead of the TU itself.  This breaks
     dw2_lookup_symbol: It assumes that if the index says symbol X lives
     in CU/TU Y, then one need only expand Y and a subsequent lookup in Y
     will find X.  Alas TUs live in their own symtab, so after expanding CU Y
     we need to look in TU Z to find X.  Fortunately, this is akin to
     DW_TAG_imported_unit, so we just use the same mechanism: For
     .gdb_index version <=7 this also records the TUs that the CU referred
     to.  Concurrently with this change gdb was modified to emit version 8
     indices so we only pay a price for gold generated indices.
     http://sourceware.org/bugzilla/show_bug.cgi?id=15021.  */
  VEC (dwarf2_per_cu_ptr) *imported_symtabs;
};

/* Entry in the signatured_types hash table.  */

struct signatured_type
{
  /* The "per_cu" object of this type.
     This struct is used iff per_cu.is_debug_types.
     N.B.: This is the first member so that it's easy to convert pointers
     between them.  */
  struct dwarf2_per_cu_data per_cu;

  /* The type's signature.  */
  ULONGEST signature;

  /* Offset in the TU of the type's DIE, as read from the TU header.
     If this TU is a DWO stub and the definition lives in a DWO file
     (specified by DW_AT_GNU_dwo_name), this value is unusable.  */
  cu_offset type_offset_in_tu;

  /* Offset in the section of the type's DIE.
     If the definition lives in a DWO file, this is the offset in the
     .debug_types.dwo section.
     The value is zero until the actual value is known.
     Zero is otherwise not a valid section offset.  */
  sect_offset type_offset_in_section;

  /* Type units are grouped by their DW_AT_stmt_list entry so that they
     can share them.  This points to the containing symtab.  */
  struct type_unit_group *type_unit_group;

  /* The type.
     The first time we encounter this type we fully read it in and install it
     in the symbol tables.  Subsequent times we only need the type.  */
  struct type *type;

  /* Containing DWO unit.
     This field is valid iff per_cu.reading_dwo_directly.  */
  struct dwo_unit *dwo_unit;
};

typedef struct signatured_type *sig_type_ptr;
DEF_VEC_P (sig_type_ptr);

/* A struct that can be used as a hash key for tables based on DW_AT_stmt_list.
   This includes type_unit_group and quick_file_names.  */

struct stmt_list_hash
{
  /* The DWO unit this table is from or NULL if there is none.  */
  struct dwo_unit *dwo_unit;

  /* Offset in .debug_line or .debug_line.dwo.  */
  sect_offset line_offset;
};

/* Each element of dwarf2_per_objfile->type_unit_groups is a pointer to
   an object of this type.  */

struct type_unit_group
{
  /* dwarf2read.c's main "handle" on a TU symtab.
     To simplify things we create an artificial CU that "includes" all the
     type units using this stmt_list so that the rest of the code still has
     a "per_cu" handle on the symtab.
     This PER_CU is recognized by having no section.  */
#define IS_TYPE_UNIT_GROUP(per_cu) ((per_cu)->section == NULL)
  struct dwarf2_per_cu_data per_cu;

  /* The TUs that share this DW_AT_stmt_list entry.
     This is added to while parsing type units to build partial symtabs,
     and is deleted afterwards and not used again.  */
  VEC (sig_type_ptr) *tus;

  /* The primary symtab.
     Type units in a group needn't all be defined in the same source file,
     so we create an essentially anonymous symtab as the primary symtab.  */
  struct symtab *primary_symtab;

  /* The data used to construct the hash key.  */
  struct stmt_list_hash hash;

  /* The number of symtabs from the line header.
     The value here must match line_header.num_file_names.  */
  unsigned int num_symtabs;

  /* The symbol tables for this TU (obtained from the files listed in
     DW_AT_stmt_list).
     WARNING: The order of entries here must match the order of entries
     in the line header.  After the first TU using this type_unit_group, the
     line header for the subsequent TUs is recreated from this.  This is done
     because we need to use the same symtabs for each TU using the same
     DW_AT_stmt_list value.  Also note that symtabs may be repeated here,
     there's no guarantee the line header doesn't have duplicate entries.  */
  struct symtab **symtabs;
};

/* These sections are what may appear in a (real or virtual) DWO file.  */

struct dwo_sections
{
  struct dwarf2_section_info abbrev;
  struct dwarf2_section_info line;
  struct dwarf2_section_info loc;
  struct dwarf2_section_info macinfo;
  struct dwarf2_section_info macro;
  struct dwarf2_section_info str;
  struct dwarf2_section_info str_offsets;
  /* In the case of a virtual DWO file, these two are unused.  */
  struct dwarf2_section_info info;
  VEC (dwarf2_section_info_def) *types;
};

/* CUs/TUs in DWP/DWO files.  */

struct dwo_unit
{
  /* Backlink to the containing struct dwo_file.  */
  struct dwo_file *dwo_file;

  /* The "id" that distinguishes this CU/TU.
     .debug_info calls this "dwo_id", .debug_types calls this "signature".
     Since signatures came first, we stick with it for consistency.  */
  ULONGEST signature;

  /* The section this CU/TU lives in, in the DWO file.  */
  struct dwarf2_section_info *section;

  /* Same as dwarf2_per_cu_data:{offset,length} but in the DWO section.  */
  sect_offset offset;
  unsigned int length;

  /* For types, offset in the type's DIE of the type defined by this TU.  */
  cu_offset type_offset_in_tu;
};

/* include/dwarf2.h defines the DWP section codes.
   It defines a max value but it doesn't define a min value, which we
   use for error checking, so provide one.  */

enum dwp_v2_section_ids
{
  DW_SECT_MIN = 1
};

/* Data for one DWO file.

   This includes virtual DWO files (a virtual DWO file is a DWO file as it
   appears in a DWP file).  DWP files don't really have DWO files per se -
   comdat folding of types "loses" the DWO file they came from, and from
   a high level view DWP files appear to contain a mass of random types.
   However, to maintain consistency with the non-DWP case we pretend DWP
   files contain virtual DWO files, and we assign each TU with one virtual
   DWO file (generally based on the line and abbrev section offsets -
   a heuristic that seems to work in practice).  */

struct dwo_file
{
  /* The DW_AT_GNU_dwo_name attribute.
     For virtual DWO files the name is constructed from the section offsets
     of abbrev,line,loc,str_offsets so that we combine virtual DWO files
     from related CU+TUs.  */
  const char *dwo_name;

  /* The DW_AT_comp_dir attribute.  */
  const char *comp_dir;

  /* The bfd, when the file is open.  Otherwise this is NULL.
     This is unused(NULL) for virtual DWO files where we use dwp_file.dbfd.  */
  bfd *dbfd;

  /* The sections that make up this DWO file.
     Remember that for virtual DWO files in DWP V2, these are virtual
     sections (for lack of a better name).  */
  struct dwo_sections sections;

  /* The CU in the file.
     We only support one because having more than one requires hacking the
     dwo_name of each to match, which is highly unlikely to happen.
     Doing this means all TUs can share comp_dir: We also assume that
     DW_AT_comp_dir across all TUs in a DWO file will be identical.  */
  struct dwo_unit *cu;

  /* Table of TUs in the file.
     Each element is a struct dwo_unit.  */
  htab_t tus;
};

/* These sections are what may appear in a DWP file.  */

struct dwp_sections
{
  /* These are used by both DWP version 1 and 2.  */
  struct dwarf2_section_info str;
  struct dwarf2_section_info cu_index;
  struct dwarf2_section_info tu_index;

  /* These are only used by DWP version 2 files.
     In DWP version 1 the .debug_info.dwo, .debug_types.dwo, and other
     sections are referenced by section number, and are not recorded here.
     In DWP version 2 there is at most one copy of all these sections, each
     section being (effectively) comprised of the concatenation of all of the
     individual sections that exist in the version 1 format.
     To keep the code simple we treat each of these concatenated pieces as a
     section itself (a virtual section?).  */
  struct dwarf2_section_info abbrev;
  struct dwarf2_section_info info;
  struct dwarf2_section_info line;
  struct dwarf2_section_info loc;
  struct dwarf2_section_info macinfo;
  struct dwarf2_section_info macro;
  struct dwarf2_section_info str_offsets;
  struct dwarf2_section_info types;
};

/* These sections are what may appear in a virtual DWO file in DWP version 1.
   A virtual DWO file is a DWO file as it appears in a DWP file.  */

struct virtual_v1_dwo_sections
{
  struct dwarf2_section_info abbrev;
  struct dwarf2_section_info line;
  struct dwarf2_section_info loc;
  struct dwarf2_section_info macinfo;
  struct dwarf2_section_info macro;
  struct dwarf2_section_info str_offsets;
  /* Each DWP hash table entry records one CU or one TU.
     That is recorded here, and copied to dwo_unit.section.  */
  struct dwarf2_section_info info_or_types;
};

/* Similar to virtual_v1_dwo_sections, but for DWP version 2.
   In version 2, the sections of the DWO files are concatenated together
   and stored in one section of that name.  Thus each ELF section contains
   several "virtual" sections.  */

struct virtual_v2_dwo_sections
{
  bfd_size_type abbrev_offset;
  bfd_size_type abbrev_size;

  bfd_size_type line_offset;
  bfd_size_type line_size;

  bfd_size_type loc_offset;
  bfd_size_type loc_size;

  bfd_size_type macinfo_offset;
  bfd_size_type macinfo_size;

  bfd_size_type macro_offset;
  bfd_size_type macro_size;

  bfd_size_type str_offsets_offset;
  bfd_size_type str_offsets_size;

  /* Each DWP hash table entry records one CU or one TU.
     That is recorded here, and copied to dwo_unit.section.  */
  bfd_size_type info_or_types_offset;
  bfd_size_type info_or_types_size;
};

/* Contents of DWP hash tables.  */

struct dwp_hash_table
{
  uint32_t version, nr_columns;
  uint32_t nr_units, nr_slots;
  const gdb_byte *hash_table, *unit_table;
  union
  {
    struct
    {
      const gdb_byte *indices;
    } v1;
    struct
    {
      /* This is indexed by column number and gives the id of the section
	 in that column.  */
#define MAX_NR_V2_DWO_SECTIONS \
  (1 /* .debug_info or .debug_types */ \
   + 1 /* .debug_abbrev */ \
   + 1 /* .debug_line */ \
   + 1 /* .debug_loc */ \
   + 1 /* .debug_str_offsets */ \
   + 1 /* .debug_macro or .debug_macinfo */)
      int section_ids[MAX_NR_V2_DWO_SECTIONS];
      const gdb_byte *offsets;
      const gdb_byte *sizes;
    } v2;
  } section_pool;
};

/* Data for one DWP file.  */

struct dwp_file
{
  /* Name of the file.  */
  const char *name;

  /* File format version.  */
  int version;

  /* The bfd.  */
  bfd *dbfd;

  /* Section info for this file.  */
  struct dwp_sections sections;

  /* Table of CUs in the file.  */
  const struct dwp_hash_table *cus;

  /* Table of TUs in the file.  */
  const struct dwp_hash_table *tus;

  /* Tables of loaded CUs/TUs.  Each entry is a struct dwo_unit *.  */
  htab_t loaded_cus;
  htab_t loaded_tus;

  /* Table to map ELF section numbers to their sections.
     This is only needed for the DWP V1 file format.  */
  unsigned int num_sections;
  asection **elf_sections;
};

/* This represents a '.dwz' file.  */

struct dwz_file
{
  /* A dwz file can only contain a few sections.  */
  struct dwarf2_section_info abbrev;
  struct dwarf2_section_info info;
  struct dwarf2_section_info str;
  struct dwarf2_section_info line;
  struct dwarf2_section_info macro;
  struct dwarf2_section_info gdb_index;

  /* The dwz's BFD.  */
  bfd *dwz_bfd;
};

/* Struct used to pass misc. parameters to read_die_and_children, et
   al.  which are used for both .debug_info and .debug_types dies.
   All parameters here are unchanging for the life of the call.  This
   struct exists to abstract away the constant parameters of die reading.  */

struct die_reader_specs
{
  /* The bfd of die_section.  */
  bfd* abfd;

  /* The CU of the DIE we are parsing.  */
  struct dwarf2_cu *cu;

  /* Non-NULL if reading a DWO file (including one packaged into a DWP).  */
  struct dwo_file *dwo_file;

  /* The section the die comes from.
     This is either .debug_info or .debug_types, or the .dwo variants.  */
  struct dwarf2_section_info *die_section;

  /* die_section->buffer.  */
  const gdb_byte *buffer;

  /* The end of the buffer.  */
  const gdb_byte *buffer_end;

  /* The value of the DW_AT_comp_dir attribute.  */
  const char *comp_dir;
};

/* Type of function passed to init_cutu_and_read_dies, et.al.  */
typedef void (die_reader_func_ftype) (const struct die_reader_specs *reader,
				      const gdb_byte *info_ptr,
				      struct die_info *comp_unit_die,
				      int has_children,
				      void *data);

/* The line number information for a compilation unit (found in the
   .debug_line section) begins with a "statement program header",
   which contains the following information.  */
struct line_header
{
  unsigned int total_length;
  unsigned short version;
  unsigned int header_length;
  unsigned char minimum_instruction_length;
  unsigned char maximum_ops_per_instruction;
  unsigned char default_is_stmt;
  int line_base;
  unsigned char line_range;
  unsigned char opcode_base;

  /* standard_opcode_lengths[i] is the number of operands for the
     standard opcode whose value is i.  This means that
     standard_opcode_lengths[0] is unused, and the last meaningful
     element is standard_opcode_lengths[opcode_base - 1].  */
  unsigned char *standard_opcode_lengths;

  /* The include_directories table.  NOTE!  These strings are not
     allocated with xmalloc; instead, they are pointers into
     debug_line_buffer.  If you try to free them, `free' will get
     indigestion.  */
  unsigned int num_include_dirs, include_dirs_size;
  const char **include_dirs;

  /* The file_names table.  NOTE!  These strings are not allocated
     with xmalloc; instead, they are pointers into debug_line_buffer.
     Don't try to free them directly.  */
  unsigned int num_file_names, file_names_size;
  struct file_entry
  {
    const char *name;
    unsigned int dir_index;
    unsigned int mod_time;
    unsigned int length;
    int included_p; /* Non-zero if referenced by the Line Number Program.  */
    struct symtab *symtab; /* The associated symbol table, if any.  */
  } *file_names;

  /* The start and end of the statement program following this
     header.  These point into dwarf2_per_objfile->line_buffer.  */
  const gdb_byte *statement_program_start, *statement_program_end;
};

/* When we construct a partial symbol table entry we only
   need this much information.  */
struct partial_die_info
  {
    /* Offset of this DIE.  */
    sect_offset offset;

    /* DWARF-2 tag for this DIE.  */
    ENUM_BITFIELD(dwarf_tag) tag : 16;

    /* Assorted flags describing the data found in this DIE.  */
    unsigned int has_children : 1;
    unsigned int is_external : 1;
    unsigned int is_declaration : 1;
    unsigned int has_type : 1;
    unsigned int has_specification : 1;
    unsigned int has_pc_info : 1;
    unsigned int may_be_inlined : 1;

    /* Flag set if the SCOPE field of this structure has been
       computed.  */
    unsigned int scope_set : 1;

    /* Flag set if the DIE has a byte_size attribute.  */
    unsigned int has_byte_size : 1;

    /* Flag set if any of the DIE's children are template arguments.  */
    unsigned int has_template_arguments : 1;

    /* Flag set if fixup_partial_die has been called on this die.  */
    unsigned int fixup_called : 1;

    /* Flag set if DW_TAG_imported_unit uses DW_FORM_GNU_ref_alt.  */
    unsigned int is_dwz : 1;

    /* Flag set if spec_offset uses DW_FORM_GNU_ref_alt.  */
    unsigned int spec_is_dwz : 1;

    /* The name of this DIE.  Normally the value of DW_AT_name, but
       sometimes a default name for unnamed DIEs.  */
    const char *name;

    /* The linkage name, if present.  */
    const char *linkage_name;

    /* The scope to prepend to our children.  This is generally
       allocated on the comp_unit_obstack, so will disappear
       when this compilation unit leaves the cache.  */
    const char *scope;

    /* Some data associated with the partial DIE.  The tag determines
       which field is live.  */
    union
    {
      /* The location description associated with this DIE, if any.  */
      struct dwarf_block *locdesc;
      /* The offset of an import, for DW_TAG_imported_unit.  */
      sect_offset offset;
    } d;

    /* If HAS_PC_INFO, the PC range associated with this DIE.  */
    CORE_ADDR lowpc;
    CORE_ADDR highpc;

    /* Pointer into the info_buffer (or types_buffer) pointing at the target of
       DW_AT_sibling, if any.  */
    /* NOTE: This member isn't strictly necessary, read_partial_die could
       return DW_AT_sibling values to its caller load_partial_dies.  */
    const gdb_byte *sibling;

    /* If HAS_SPECIFICATION, the offset of the DIE referred to by
       DW_AT_specification (or DW_AT_abstract_origin or
       DW_AT_extension).  */
    sect_offset spec_offset;

    /* Pointers to this DIE's parent, first child, and next sibling,
       if any.  */
    struct partial_die_info *die_parent, *die_child, *die_sibling;
  };

/* This data structure holds the information of an abbrev.  */
struct abbrev_info
  {
    unsigned int number;	/* number identifying abbrev */
    enum dwarf_tag tag;		/* dwarf tag */
    unsigned short has_children;		/* boolean */
    unsigned short num_attrs;	/* number of attributes */
    struct attr_abbrev *attrs;	/* an array of attribute descriptions */
    struct abbrev_info *next;	/* next in chain */
  };

struct attr_abbrev
  {
    ENUM_BITFIELD(dwarf_attribute) name : 16;
    ENUM_BITFIELD(dwarf_form) form : 16;
  };

/* Size of abbrev_table.abbrev_hash_table.  */
#define ABBREV_HASH_SIZE 121

/* Top level data structure to contain an abbreviation table.  */

struct abbrev_table
{
  /* Where the abbrev table came from.
     This is used as a sanity check when the table is used.  */
  sect_offset offset;

  /* Storage for the abbrev table.  */
  struct obstack abbrev_obstack;

  /* Hash table of abbrevs.
     This is an array of size ABBREV_HASH_SIZE allocated in abbrev_obstack.
     It could be statically allocated, but the previous code didn't so we
     don't either.  */
  struct abbrev_info **abbrevs;
};

/* Attributes have a name and a value.  */
struct attribute
  {
    ENUM_BITFIELD(dwarf_attribute) name : 16;
    ENUM_BITFIELD(dwarf_form) form : 15;

    /* Has DW_STRING already been updated by dwarf2_canonicalize_name?  This
       field should be in u.str (existing only for DW_STRING) but it is kept
       here for better struct attribute alignment.  */
    unsigned int string_is_canonical : 1;

    union
      {
	const char *str;
	struct dwarf_block *blk;
	ULONGEST unsnd;
	LONGEST snd;
	CORE_ADDR addr;
	ULONGEST signature;
      }
    u;
  };

/* This data structure holds a complete die structure.  */
struct die_info
  {
    /* DWARF-2 tag for this DIE.  */
    ENUM_BITFIELD(dwarf_tag) tag : 16;

    /* Number of attributes */
    unsigned char num_attrs;

    /* True if we're presently building the full type name for the
       type derived from this DIE.  */
    unsigned char building_fullname : 1;

    /* Abbrev number */
    unsigned int abbrev;

    /* Offset in .debug_info or .debug_types section.  */
    sect_offset offset;

    /* The dies in a compilation unit form an n-ary tree.  PARENT
       points to this die's parent; CHILD points to the first child of
       this node; and all the children of a given node are chained
       together via their SIBLING fields.  */
    struct die_info *child;	/* Its first child, if any.  */
    struct die_info *sibling;	/* Its next sibling, if any.  */
    struct die_info *parent;	/* Its parent, if any.  */

    /* An array of attributes, with NUM_ATTRS elements.  There may be
       zero, but it's not common and zero-sized arrays are not
       sufficiently portable C.  */
    struct attribute attrs[1];
  };

/* Get at parts of an attribute structure.  */

#define DW_STRING(attr)    ((attr)->u.str)
#define DW_STRING_IS_CANONICAL(attr) ((attr)->string_is_canonical)
#define DW_UNSND(attr)     ((attr)->u.unsnd)
#define DW_BLOCK(attr)     ((attr)->u.blk)
#define DW_SND(attr)       ((attr)->u.snd)
#define DW_ADDR(attr)	   ((attr)->u.addr)
#define DW_SIGNATURE(attr) ((attr)->u.signature)

/* Blocks are a bunch of untyped bytes.  */
struct dwarf_block
  {
    size_t size;

    /* Valid only if SIZE is not zero.  */
    const gdb_byte *data;
  };

#ifndef ATTR_ALLOC_CHUNK
#define ATTR_ALLOC_CHUNK 4
#endif

/* Allocate fields for structs, unions and enums in this size.  */
#ifndef DW_FIELD_ALLOC_CHUNK
#define DW_FIELD_ALLOC_CHUNK 4
#endif

/* FIXME: We might want to set this from BFD via bfd_arch_bits_per_byte,
   but this would require a corresponding change in unpack_field_as_long
   and friends.  */
static int bits_per_byte = 8;

/* The routines that read and process dies for a C struct or C++ class
   pass lists of data member fields and lists of member function fields
   in an instance of a field_info structure, as defined below.  */
struct field_info
  {
    /* List of data member and baseclasses fields.  */
    struct nextfield
      {
	struct nextfield *next;
	int accessibility;
	int virtuality;
	struct field field;
      }
     *fields, *baseclasses;

    /* Number of fields (including baseclasses).  */
    int nfields;

    /* Number of baseclasses.  */
    int nbaseclasses;

    /* Set if the accesibility of one of the fields is not public.  */
    int non_public_fields;

    /* Member function fields array, entries are allocated in the order they
       are encountered in the object file.  */
    struct nextfnfield
      {
	struct nextfnfield *next;
	struct fn_field fnfield;
      }
     *fnfields;

    /* Member function fieldlist array, contains name of possibly overloaded
       member function, number of overloaded member functions and a pointer
       to the head of the member function field chain.  */
    struct fnfieldlist
      {
	const char *name;
	int length;
	struct nextfnfield *head;
      }
     *fnfieldlists;

    /* Number of entries in the fnfieldlists array.  */
    int nfnfields;

    /* typedefs defined inside this class.  TYPEDEF_FIELD_LIST contains head of
       a NULL terminated list of TYPEDEF_FIELD_LIST_COUNT elements.  */
    struct typedef_field_list
      {
	struct typedef_field field;
	struct typedef_field_list *next;
      }
    *typedef_field_list;
    unsigned typedef_field_list_count;
  };

/* One item on the queue of compilation units to read in full symbols
   for.  */
struct dwarf2_queue_item
{
  struct dwarf2_per_cu_data *per_cu;
  enum language pretend_language;
  struct dwarf2_queue_item *next;
};

/* The current queue.  */
static struct dwarf2_queue_item *dwarf2_queue, *dwarf2_queue_tail;

/* Loaded secondary compilation units are kept in memory until they
   have not been referenced for the processing of this many
   compilation units.  Set this to zero to disable caching.  Cache
   sizes of up to at least twenty will improve startup time for
   typical inter-CU-reference binaries, at an obvious memory cost.  */
static int dwarf2_max_cache_age = 5;
static void
show_dwarf2_max_cache_age (struct ui_file *file, int from_tty,
			   struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file, _("The upper bound on the age of cached "
			    "dwarf2 compilation units is %s.\n"),
		    value);
}

/* local function prototypes */

static const char *get_section_name (const struct dwarf2_section_info *);

static const char *get_section_file_name (const struct dwarf2_section_info *);

static void dwarf2_locate_sections (bfd *, asection *, void *);

static void dwarf2_find_base_address (struct die_info *die,
				      struct dwarf2_cu *cu);

static struct partial_symtab *create_partial_symtab
  (struct dwarf2_per_cu_data *per_cu, const char *name);

static void dwarf2_build_psymtabs_hard (struct objfile *);

static void scan_partial_symbols (struct partial_die_info *,
				  CORE_ADDR *, CORE_ADDR *,
				  int, struct dwarf2_cu *);

static void add_partial_symbol (struct partial_die_info *,
				struct dwarf2_cu *);

static void add_partial_namespace (struct partial_die_info *pdi,
				   CORE_ADDR *lowpc, CORE_ADDR *highpc,
				   int need_pc, struct dwarf2_cu *cu);

static void add_partial_module (struct partial_die_info *pdi, CORE_ADDR *lowpc,
				CORE_ADDR *highpc, int need_pc,
				struct dwarf2_cu *cu);

static void add_partial_enumeration (struct partial_die_info *enum_pdi,
				     struct dwarf2_cu *cu);

static void add_partial_subprogram (struct partial_die_info *pdi,
				    CORE_ADDR *lowpc, CORE_ADDR *highpc,
				    int need_pc, struct dwarf2_cu *cu);

static void dwarf2_read_symtab (struct partial_symtab *,
				struct objfile *);

static void psymtab_to_symtab_1 (struct partial_symtab *);

static struct abbrev_info *abbrev_table_lookup_abbrev
  (const struct abbrev_table *, unsigned int);

static struct abbrev_table *abbrev_table_read_table
  (struct dwarf2_section_info *, sect_offset);

static void abbrev_table_free (struct abbrev_table *);

static void abbrev_table_free_cleanup (void *);

static void dwarf2_read_abbrevs (struct dwarf2_cu *,
				 struct dwarf2_section_info *);

static void dwarf2_free_abbrev_table (void *);

static unsigned int peek_abbrev_code (bfd *, const gdb_byte *);

static struct partial_die_info *load_partial_dies
  (const struct die_reader_specs *, const gdb_byte *, int);

static const gdb_byte *read_partial_die (const struct die_reader_specs *,
					 struct partial_die_info *,
					 struct abbrev_info *,
					 unsigned int,
					 const gdb_byte *);

static struct partial_die_info *find_partial_die (sect_offset, int,
						  struct dwarf2_cu *);

static void fixup_partial_die (struct partial_die_info *,
			       struct dwarf2_cu *);

static const gdb_byte *read_attribute (const struct die_reader_specs *,
				       struct attribute *, struct attr_abbrev *,
				       const gdb_byte *);

static unsigned int read_1_byte (bfd *, const gdb_byte *);

static int read_1_signed_byte (bfd *, const gdb_byte *);

static unsigned int read_2_bytes (bfd *, const gdb_byte *);

static unsigned int read_4_bytes (bfd *, const gdb_byte *);

static ULONGEST read_8_bytes (bfd *, const gdb_byte *);

static CORE_ADDR read_address (bfd *, const gdb_byte *ptr, struct dwarf2_cu *,
			       unsigned int *);

static LONGEST read_initial_length (bfd *, const gdb_byte *, unsigned int *);

static LONGEST read_checked_initial_length_and_offset
  (bfd *, const gdb_byte *, const struct comp_unit_head *,
   unsigned int *, unsigned int *);

static LONGEST read_offset (bfd *, const gdb_byte *,
			    const struct comp_unit_head *,
			    unsigned int *);

static LONGEST read_offset_1 (bfd *, const gdb_byte *, unsigned int);

static sect_offset read_abbrev_offset (struct dwarf2_section_info *,
				       sect_offset);

static const gdb_byte *read_n_bytes (bfd *, const gdb_byte *, unsigned int);

static const char *read_direct_string (bfd *, const gdb_byte *, unsigned int *);

static const char *read_indirect_string (bfd *, const gdb_byte *,
					 const struct comp_unit_head *,
					 unsigned int *);

static const char *read_indirect_string_from_dwz (struct dwz_file *, LONGEST);

static ULONGEST read_unsigned_leb128 (bfd *, const gdb_byte *, unsigned int *);

static LONGEST read_signed_leb128 (bfd *, const gdb_byte *, unsigned int *);

static CORE_ADDR read_addr_index_from_leb128 (struct dwarf2_cu *,
					      const gdb_byte *,
					      unsigned int *);

static const char *read_str_index (const struct die_reader_specs *reader,
				   struct dwarf2_cu *cu, ULONGEST str_index);

static void set_cu_language (unsigned int, struct dwarf2_cu *);

static struct attribute *dwarf2_attr (struct die_info *, unsigned int,
				      struct dwarf2_cu *);

static struct attribute *dwarf2_attr_no_follow (struct die_info *,
						unsigned int);

static int dwarf2_flag_true_p (struct die_info *die, unsigned name,
                               struct dwarf2_cu *cu);

static int die_is_declaration (struct die_info *, struct dwarf2_cu *cu);

static struct die_info *die_specification (struct die_info *die,
					   struct dwarf2_cu **);

static void free_line_header (struct line_header *lh);

static struct line_header *dwarf_decode_line_header (unsigned int offset,
						     struct dwarf2_cu *cu);

static void dwarf_decode_lines (struct line_header *, const char *,
				struct dwarf2_cu *, struct partial_symtab *,
				int);

static void dwarf2_start_subfile (const char *, const char *, const char *);

static void dwarf2_start_symtab (struct dwarf2_cu *,
				 const char *, const char *, CORE_ADDR);

static struct symbol *new_symbol (struct die_info *, struct type *,
				  struct dwarf2_cu *);

static struct symbol *new_symbol_full (struct die_info *, struct type *,
				       struct dwarf2_cu *, struct symbol *);

static void dwarf2_const_value (const struct attribute *, struct symbol *,
				struct dwarf2_cu *);

static void dwarf2_const_value_attr (const struct attribute *attr,
				     struct type *type,
				     const char *name,
				     struct obstack *obstack,
				     struct dwarf2_cu *cu, LONGEST *value,
				     const gdb_byte **bytes,
				     struct dwarf2_locexpr_baton **baton);

static struct type *die_type (struct die_info *, struct dwarf2_cu *);

static int need_gnat_info (struct dwarf2_cu *);

static struct type *die_descriptive_type (struct die_info *,
					  struct dwarf2_cu *);

static void set_descriptive_type (struct type *, struct die_info *,
				  struct dwarf2_cu *);

static struct type *die_containing_type (struct die_info *,
					 struct dwarf2_cu *);

static struct type *lookup_die_type (struct die_info *, const struct attribute *,
				     struct dwarf2_cu *);

static struct type *read_type_die (struct die_info *, struct dwarf2_cu *);

static struct type *read_type_die_1 (struct die_info *, struct dwarf2_cu *);

static const char *determine_prefix (struct die_info *die, struct dwarf2_cu *);

static char *typename_concat (struct obstack *obs, const char *prefix,
			      const char *suffix, int physname,
			      struct dwarf2_cu *cu);

static void read_file_scope (struct die_info *, struct dwarf2_cu *);

static void read_type_unit_scope (struct die_info *, struct dwarf2_cu *);

static void read_func_scope (struct die_info *, struct dwarf2_cu *);

static void read_lexical_block_scope (struct die_info *, struct dwarf2_cu *);

static void read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu);

static int dwarf2_ranges_read (unsigned, CORE_ADDR *, CORE_ADDR *,
			       struct dwarf2_cu *, struct partial_symtab *);

static int dwarf2_get_pc_bounds (struct die_info *,
				 CORE_ADDR *, CORE_ADDR *, struct dwarf2_cu *,
				 struct partial_symtab *);

static void get_scope_pc_bounds (struct die_info *,
				 CORE_ADDR *, CORE_ADDR *,
				 struct dwarf2_cu *);

static void dwarf2_record_block_ranges (struct die_info *, struct block *,
                                        CORE_ADDR, struct dwarf2_cu *);

static void dwarf2_add_field (struct field_info *, struct die_info *,
			      struct dwarf2_cu *);

static void dwarf2_attach_fields_to_type (struct field_info *,
					  struct type *, struct dwarf2_cu *);

static void dwarf2_add_member_fn (struct field_info *,
				  struct die_info *, struct type *,
				  struct dwarf2_cu *);

static void dwarf2_attach_fn_fields_to_type (struct field_info *,
					     struct type *,
					     struct dwarf2_cu *);

static void process_structure_scope (struct die_info *, struct dwarf2_cu *);

static void read_common_block (struct die_info *, struct dwarf2_cu *);

static void read_namespace (struct die_info *die, struct dwarf2_cu *);

static void read_module (struct die_info *die, struct dwarf2_cu *cu);

static void read_import_statement (struct die_info *die, struct dwarf2_cu *);

static struct type *read_module_type (struct die_info *die,
				      struct dwarf2_cu *cu);

static const char *namespace_name (struct die_info *die,
				   int *is_anonymous, struct dwarf2_cu *);

static void process_enumeration_scope (struct die_info *, struct dwarf2_cu *);

static CORE_ADDR decode_locdesc (struct dwarf_block *, struct dwarf2_cu *);

static enum dwarf_array_dim_ordering read_array_order (struct die_info *,
						       struct dwarf2_cu *);

static struct die_info *read_die_and_siblings_1
  (const struct die_reader_specs *, const gdb_byte *, const gdb_byte **,
   struct die_info *);

static struct die_info *read_die_and_siblings (const struct die_reader_specs *,
					       const gdb_byte *info_ptr,
					       const gdb_byte **new_info_ptr,
					       struct die_info *parent);

static const gdb_byte *read_full_die_1 (const struct die_reader_specs *,
					struct die_info **, const gdb_byte *,
					int *, int);

static const gdb_byte *read_full_die (const struct die_reader_specs *,
				      struct die_info **, const gdb_byte *,
				      int *);

static void process_die (struct die_info *, struct dwarf2_cu *);

static const char *dwarf2_canonicalize_name (const char *, struct dwarf2_cu *,
					     struct obstack *);

static const char *dwarf2_name (struct die_info *die, struct dwarf2_cu *);

static const char *dwarf2_full_name (const char *name,
				     struct die_info *die,
				     struct dwarf2_cu *cu);

static const char *dwarf2_physname (const char *name, struct die_info *die,
				    struct dwarf2_cu *cu);

static struct die_info *dwarf2_extension (struct die_info *die,
					  struct dwarf2_cu **);

static const char *dwarf_tag_name (unsigned int);

static const char *dwarf_attr_name (unsigned int);

static const char *dwarf_form_name (unsigned int);

static char *dwarf_bool_name (unsigned int);

static const char *dwarf_type_encoding_name (unsigned int);

static struct die_info *sibling_die (struct die_info *);

static void dump_die_shallow (struct ui_file *, int indent, struct die_info *);

static void dump_die_for_error (struct die_info *);

static void dump_die_1 (struct ui_file *, int level, int max_level,
			struct die_info *);

/*static*/ void dump_die (struct die_info *, int max_level);

static void store_in_ref_table (struct die_info *,
				struct dwarf2_cu *);

static sect_offset dwarf2_get_ref_die_offset (const struct attribute *);

static LONGEST dwarf2_get_attr_constant_value (const struct attribute *, int);

static struct die_info *follow_die_ref_or_sig (struct die_info *,
					       const struct attribute *,
					       struct dwarf2_cu **);

static struct die_info *follow_die_ref (struct die_info *,
					const struct attribute *,
					struct dwarf2_cu **);

static struct die_info *follow_die_sig (struct die_info *,
					const struct attribute *,
					struct dwarf2_cu **);

static struct type *get_signatured_type (struct die_info *, ULONGEST,
					 struct dwarf2_cu *);

static struct type *get_DW_AT_signature_type (struct die_info *,
					      const struct attribute *,
					      struct dwarf2_cu *);

static void load_full_type_unit (struct dwarf2_per_cu_data *per_cu);

static void read_signatured_type (struct signatured_type *);

static struct type_unit_group *get_type_unit_group
    (struct dwarf2_cu *, const struct attribute *);

static void build_type_unit_groups (die_reader_func_ftype *, void *);

/* memory allocation interface */

static struct dwarf_block *dwarf_alloc_block (struct dwarf2_cu *);

static struct die_info *dwarf_alloc_die (struct dwarf2_cu *, int);

static void dwarf_decode_macros (struct dwarf2_cu *, unsigned int,
				 const char *, int);

static int attr_form_is_block (const struct attribute *);

static int attr_form_is_section_offset (const struct attribute *);

static int attr_form_is_constant (const struct attribute *);

static int attr_form_is_ref (const struct attribute *);

static void fill_in_loclist_baton (struct dwarf2_cu *cu,
				   struct dwarf2_loclist_baton *baton,
				   const struct attribute *attr);

static void dwarf2_symbol_mark_computed (const struct attribute *attr,
					 struct symbol *sym,
					 struct dwarf2_cu *cu,
					 int is_block);

static const gdb_byte *skip_one_die (const struct die_reader_specs *reader,
				     const gdb_byte *info_ptr,
				     struct abbrev_info *abbrev);

static void free_stack_comp_unit (void *);

static hashval_t partial_die_hash (const void *item);

static int partial_die_eq (const void *item_lhs, const void *item_rhs);

static struct dwarf2_per_cu_data *dwarf2_find_containing_comp_unit
  (sect_offset offset, unsigned int offset_in_dwz, struct objfile *objfile);

static void init_one_comp_unit (struct dwarf2_cu *cu,
				struct dwarf2_per_cu_data *per_cu);

static void prepare_one_comp_unit (struct dwarf2_cu *cu,
				   struct die_info *comp_unit_die,
				   enum language pretend_language);

static void free_heap_comp_unit (void *);

static void free_cached_comp_units (void *);

static void age_cached_comp_units (void);

static void free_one_cached_comp_unit (struct dwarf2_per_cu_data *);

static struct type *set_die_type (struct die_info *, struct type *,
				  struct dwarf2_cu *);

static void create_all_comp_units (struct objfile *);

static int create_all_type_units (struct objfile *);

static void load_full_comp_unit (struct dwarf2_per_cu_data *,
				 enum language);

static void process_full_comp_unit (struct dwarf2_per_cu_data *,
				    enum language);

static void process_full_type_unit (struct dwarf2_per_cu_data *,
				    enum language);

static void dwarf2_add_dependence (struct dwarf2_cu *,
				   struct dwarf2_per_cu_data *);

static void dwarf2_mark (struct dwarf2_cu *);

static void dwarf2_clear_marks (struct dwarf2_per_cu_data *);

static struct type *get_die_type_at_offset (sect_offset,
					    struct dwarf2_per_cu_data *);

static struct type *get_die_type (struct die_info *die, struct dwarf2_cu *cu);

static void dwarf2_release_queue (void *dummy);

static void queue_comp_unit (struct dwarf2_per_cu_data *per_cu,
			     enum language pretend_language);

static void process_queue (void);

static void find_file_and_directory (struct die_info *die,
				     struct dwarf2_cu *cu,
				     const char **name, const char **comp_dir);

static char *file_full_name (int file, struct line_header *lh,
			     const char *comp_dir);

static const gdb_byte *read_and_check_comp_unit_head
  (struct comp_unit_head *header,
   struct dwarf2_section_info *section,
   struct dwarf2_section_info *abbrev_section, const gdb_byte *info_ptr,
   int is_debug_types_section);

static void init_cutu_and_read_dies
  (struct dwarf2_per_cu_data *this_cu, struct abbrev_table *abbrev_table,
   int use_existing_cu, int keep,
   die_reader_func_ftype *die_reader_func, void *data);

static void init_cutu_and_read_dies_simple
  (struct dwarf2_per_cu_data *this_cu,
   die_reader_func_ftype *die_reader_func, void *data);

static htab_t allocate_signatured_type_table (struct objfile *objfile);

static htab_t allocate_dwo_unit_table (struct objfile *objfile);

static struct dwo_unit *lookup_dwo_unit_in_dwp
  (struct dwp_file *dwp_file, const char *comp_dir,
   ULONGEST signature, int is_debug_types);

static struct dwp_file *get_dwp_file (void);

static struct dwo_unit *lookup_dwo_comp_unit
  (struct dwarf2_per_cu_data *, const char *, const char *, ULONGEST);

static struct dwo_unit *lookup_dwo_type_unit
  (struct signatured_type *, const char *, const char *);

static void queue_and_load_all_dwo_tus (struct dwarf2_per_cu_data *);

static void free_dwo_file_cleanup (void *);

static void process_cu_includes (void);

static void check_producer (struct dwarf2_cu *cu);

/* Various complaints about symbol reading that don't abort the process.  */

static void
dwarf2_statement_list_fits_in_line_number_section_complaint (void)
{
  complaint (&symfile_complaints,
	     _("statement list doesn't fit in .debug_line section"));
}

static void
dwarf2_debug_line_missing_file_complaint (void)
{
  complaint (&symfile_complaints,
	     _(".debug_line section has line data without a file"));
}

static void
dwarf2_debug_line_missing_end_sequence_complaint (void)
{
  complaint (&symfile_complaints,
	     _(".debug_line section has line "
	       "program sequence without an end"));
}

static void
dwarf2_complex_location_expr_complaint (void)
{
  complaint (&symfile_complaints, _("location expression too complex"));
}

static void
dwarf2_const_value_length_mismatch_complaint (const char *arg1, int arg2,
					      int arg3)
{
  complaint (&symfile_complaints,
	     _("const value length mismatch for '%s', got %d, expected %d"),
	     arg1, arg2, arg3);
}

static void
dwarf2_section_buffer_overflow_complaint (struct dwarf2_section_info *section)
{
  complaint (&symfile_complaints,
	     _("debug info runs off end of %s section"
	       " [in module %s]"),
	     get_section_name (section),
	     get_section_file_name (section));
}

static void
dwarf2_macro_malformed_definition_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     _("macro debug info contains a "
	       "malformed macro definition:\n`%s'"),
	     arg1);
}

static void
dwarf2_invalid_attrib_class_complaint (const char *arg1, const char *arg2)
{
  complaint (&symfile_complaints,
	     _("invalid attribute class or form for '%s' in '%s'"),
	     arg1, arg2);
}

#if WORDS_BIGENDIAN

/* Convert VALUE between big- and little-endian.  */
static offset_type
byte_swap (offset_type value)
{
  offset_type result;

  result = (value & 0xff) << 24;
  result |= (value & 0xff00) << 8;
  result |= (value & 0xff0000) >> 8;
  result |= (value & 0xff000000) >> 24;
  return result;
}

#define MAYBE_SWAP(V)  byte_swap (V)

#else
#define MAYBE_SWAP(V) (V)
#endif /* WORDS_BIGENDIAN */

/* The suffix for an index file.  */
#define INDEX_SUFFIX ".gdb-index"

/* Try to locate the sections we need for DWARF 2 debugging
   information and return true if we have enough to do something.
   NAMES points to the dwarf2 section names, or is NULL if the standard
   ELF names are used.  */

int
dwarf2_has_info (struct objfile *objfile,
                 const struct dwarf2_debug_sections *names)
{
  dwarf2_per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);
  if (!dwarf2_per_objfile)
    {
      /* Initialize per-objfile state.  */
      struct dwarf2_per_objfile *data
	= obstack_alloc (&objfile->objfile_obstack, sizeof (*data));

      memset (data, 0, sizeof (*data));
      set_objfile_data (objfile, dwarf2_objfile_data_key, data);
      dwarf2_per_objfile = data;

      bfd_map_over_sections (objfile->obfd, dwarf2_locate_sections,
                             (void *) names);
      dwarf2_per_objfile->objfile = objfile;
    }
  return (!dwarf2_per_objfile->info.is_virtual
	  && dwarf2_per_objfile->info.s.asection != NULL
	  && !dwarf2_per_objfile->abbrev.is_virtual
	  && dwarf2_per_objfile->abbrev.s.asection != NULL);
}

/* Return the containing section of virtual section SECTION.  */

static struct dwarf2_section_info *
get_containing_section (const struct dwarf2_section_info *section)
{
  gdb_assert (section->is_virtual);
  return section->s.containing_section;
}

/* Return the bfd owner of SECTION.  */

static struct bfd *
get_section_bfd_owner (const struct dwarf2_section_info *section)
{
  if (section->is_virtual)
    {
      section = get_containing_section (section);
      gdb_assert (!section->is_virtual);
    }
  return section->s.asection->owner;
}

/* Return the bfd section of SECTION.
   Returns NULL if the section is not present.  */

static asection *
get_section_bfd_section (const struct dwarf2_section_info *section)
{
  if (section->is_virtual)
    {
      section = get_containing_section (section);
      gdb_assert (!section->is_virtual);
    }
  return section->s.asection;
}

/* Return the name of SECTION.  */

static const char *
get_section_name (const struct dwarf2_section_info *section)
{
  asection *sectp = get_section_bfd_section (section);

  gdb_assert (sectp != NULL);
  return bfd_section_name (get_section_bfd_owner (section), sectp);
}

/* Return the name of the file SECTION is in.  */

static const char *
get_section_file_name (const struct dwarf2_section_info *section)
{
  bfd *abfd = get_section_bfd_owner (section);

  return bfd_get_filename (abfd);
}

/* Return the id of SECTION.
   Returns 0 if SECTION doesn't exist.  */

static int
get_section_id (const struct dwarf2_section_info *section)
{
  asection *sectp = get_section_bfd_section (section);

  if (sectp == NULL)
    return 0;
  return sectp->id;
}

/* Return the flags of SECTION.
   SECTION (or containing section if this is a virtual section) must exist.  */

static int
get_section_flags (const struct dwarf2_section_info *section)
{
  asection *sectp = get_section_bfd_section (section);

  gdb_assert (sectp != NULL);
  return bfd_get_section_flags (sectp->owner, sectp);
}

/* When loading sections, we look either for uncompressed section or for
   compressed section names.  */

static int
section_is_p (const char *section_name,
              const struct dwarf2_section_names *names)
{
  if (names->normal != NULL
      && strcmp (section_name, names->normal) == 0)
    return 1;
  if (names->compressed != NULL
      && strcmp (section_name, names->compressed) == 0)
    return 1;
  return 0;
}

/* This function is mapped across the sections and remembers the
   offset and size of each of the debugging sections we are interested
   in.  */

static void
dwarf2_locate_sections (bfd *abfd, asection *sectp, void *vnames)
{
  const struct dwarf2_debug_sections *names;
  flagword aflag = bfd_get_section_flags (abfd, sectp);

  if (vnames == NULL)
    names = &dwarf2_elf_names;
  else
    names = (const struct dwarf2_debug_sections *) vnames;

  if ((aflag & SEC_HAS_CONTENTS) == 0)
    {
    }
  else if (section_is_p (sectp->name, &names->info))
    {
      dwarf2_per_objfile->info.s.asection = sectp;
      dwarf2_per_objfile->info.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->abbrev))
    {
      dwarf2_per_objfile->abbrev.s.asection = sectp;
      dwarf2_per_objfile->abbrev.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->line))
    {
      dwarf2_per_objfile->line.s.asection = sectp;
      dwarf2_per_objfile->line.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->loc))
    {
      dwarf2_per_objfile->loc.s.asection = sectp;
      dwarf2_per_objfile->loc.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macinfo))
    {
      dwarf2_per_objfile->macinfo.s.asection = sectp;
      dwarf2_per_objfile->macinfo.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macro))
    {
      dwarf2_per_objfile->macro.s.asection = sectp;
      dwarf2_per_objfile->macro.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->str))
    {
      dwarf2_per_objfile->str.s.asection = sectp;
      dwarf2_per_objfile->str.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->addr))
    {
      dwarf2_per_objfile->addr.s.asection = sectp;
      dwarf2_per_objfile->addr.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->frame))
    {
      dwarf2_per_objfile->frame.s.asection = sectp;
      dwarf2_per_objfile->frame.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->eh_frame))
    {
      dwarf2_per_objfile->eh_frame.s.asection = sectp;
      dwarf2_per_objfile->eh_frame.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->ranges))
    {
      dwarf2_per_objfile->ranges.s.asection = sectp;
      dwarf2_per_objfile->ranges.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->types))
    {
      struct dwarf2_section_info type_section;

      memset (&type_section, 0, sizeof (type_section));
      type_section.s.asection = sectp;
      type_section.size = bfd_get_section_size (sectp);

      VEC_safe_push (dwarf2_section_info_def, dwarf2_per_objfile->types,
		     &type_section);
    }
  else if (section_is_p (sectp->name, &names->gdb_index))
    {
      dwarf2_per_objfile->gdb_index.s.asection = sectp;
      dwarf2_per_objfile->gdb_index.size = bfd_get_section_size (sectp);
    }

  if ((bfd_get_section_flags (abfd, sectp) & SEC_LOAD)
      && bfd_section_vma (abfd, sectp) == 0)
    dwarf2_per_objfile->has_section_at_zero = 1;
}

/* A helper function that decides whether a section is empty,
   or not present.  */

static int
dwarf2_section_empty_p (const struct dwarf2_section_info *section)
{
  if (section->is_virtual)
    return section->size == 0;
  return section->s.asection == NULL || section->size == 0;
}

/* Read the contents of the section INFO.
   OBJFILE is the main object file, but not necessarily the file where
   the section comes from.  E.g., for DWO files the bfd of INFO is the bfd
   of the DWO file.
   If the section is compressed, uncompress it before returning.  */

static void
dwarf2_read_section (struct objfile *objfile, struct dwarf2_section_info *info)
{
  asection *sectp;
  bfd *abfd;
  gdb_byte *buf, *retbuf;

  if (info->readin)
    return;
  info->buffer = NULL;
  info->readin = 1;

  if (dwarf2_section_empty_p (info))
    return;

  sectp = get_section_bfd_section (info);

  /* If this is a virtual section we need to read in the real one first.  */
  if (info->is_virtual)
    {
      struct dwarf2_section_info *containing_section =
	get_containing_section (info);

      gdb_assert (sectp != NULL);
      if ((sectp->flags & SEC_RELOC) != 0)
	{
	  error (_("Dwarf Error: DWP format V2 with relocations is not"
		   " supported in section %s [in module %s]"),
		 get_section_name (info), get_section_file_name (info));
	}
      dwarf2_read_section (objfile, containing_section);
      /* Other code should have already caught virtual sections that don't
	 fit.  */
      gdb_assert (info->virtual_offset + info->size
		  <= containing_section->size);
      /* If the real section is empty or there was a problem reading the
	 section we shouldn't get here.  */
      gdb_assert (containing_section->buffer != NULL);
      info->buffer = containing_section->buffer + info->virtual_offset;
      return;
    }

  /* If the section has relocations, we must read it ourselves.
     Otherwise we attach it to the BFD.  */
  if ((sectp->flags & SEC_RELOC) == 0)
    {
      info->buffer = gdb_bfd_map_section (sectp, &info->size);
      return;
    }

  buf = obstack_alloc (&objfile->objfile_obstack, info->size);
  info->buffer = buf;

  /* When debugging .o files, we may need to apply relocations; see
     http://sourceware.org/ml/gdb-patches/2002-04/msg00136.html .
     We never compress sections in .o files, so we only need to
     try this when the section is not compressed.  */
  retbuf = symfile_relocate_debug_section (objfile, sectp, buf);
  if (retbuf != NULL)
    {
      info->buffer = retbuf;
      return;
    }

  abfd = get_section_bfd_owner (info);
  gdb_assert (abfd != NULL);

  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0
      || bfd_bread (buf, info->size, abfd) != info->size)
    {
      error (_("Dwarf Error: Can't read DWARF data"
	       " in section %s [in module %s]"),
	     bfd_section_name (abfd, sectp), bfd_get_filename (abfd));
    }
}

/* A helper function that returns the size of a section in a safe way.
   If you are positive that the section has been read before using the
   size, then it is safe to refer to the dwarf2_section_info object's
   "size" field directly.  In other cases, you must call this
   function, because for compressed sections the size field is not set
   correctly until the section has been read.  */

static bfd_size_type
dwarf2_section_size (struct objfile *objfile,
		     struct dwarf2_section_info *info)
{
  if (!info->readin)
    dwarf2_read_section (objfile, info);
  return info->size;
}

/* Fill in SECTP, BUFP and SIZEP with section info, given OBJFILE and
   SECTION_NAME.  */

void
dwarf2_get_section_info (struct objfile *objfile,
                         enum dwarf2_section_enum sect,
                         asection **sectp, const gdb_byte **bufp,
                         bfd_size_type *sizep)
{
  struct dwarf2_per_objfile *data
    = objfile_data (objfile, dwarf2_objfile_data_key);
  struct dwarf2_section_info *info;

  /* We may see an objfile without any DWARF, in which case we just
     return nothing.  */
  if (data == NULL)
    {
      *sectp = NULL;
      *bufp = NULL;
      *sizep = 0;
      return;
    }
  switch (sect)
    {
    case DWARF2_DEBUG_FRAME:
      info = &data->frame;
      break;
    case DWARF2_EH_FRAME:
      info = &data->eh_frame;
      break;
    default:
      gdb_assert_not_reached ("unexpected section");
    }

  dwarf2_read_section (objfile, info);

  *sectp = get_section_bfd_section (info);
  *bufp = info->buffer;
  *sizep = info->size;
}

/* A helper function to find the sections for a .dwz file.  */

static void
locate_dwz_sections (bfd *abfd, asection *sectp, void *arg)
{
  struct dwz_file *dwz_file = arg;

  /* Note that we only support the standard ELF names, because .dwz
     is ELF-only (at the time of writing).  */
  if (section_is_p (sectp->name, &dwarf2_elf_names.abbrev))
    {
      dwz_file->abbrev.s.asection = sectp;
      dwz_file->abbrev.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &dwarf2_elf_names.info))
    {
      dwz_file->info.s.asection = sectp;
      dwz_file->info.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &dwarf2_elf_names.str))
    {
      dwz_file->str.s.asection = sectp;
      dwz_file->str.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &dwarf2_elf_names.line))
    {
      dwz_file->line.s.asection = sectp;
      dwz_file->line.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &dwarf2_elf_names.macro))
    {
      dwz_file->macro.s.asection = sectp;
      dwz_file->macro.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &dwarf2_elf_names.gdb_index))
    {
      dwz_file->gdb_index.s.asection = sectp;
      dwz_file->gdb_index.size = bfd_get_section_size (sectp);
    }
}

/* Open the separate '.dwz' debug file, if needed.  Return NULL if
   there is no .gnu_debugaltlink section in the file.  Error if there
   is such a section but the file cannot be found.  */

static struct dwz_file *
dwarf2_get_dwz_file (void)
{
  bfd *dwz_bfd;
  char *data;
  struct cleanup *cleanup;
  const char *filename;
  struct dwz_file *result;
  bfd_size_type buildid_len_arg;
  size_t buildid_len;
  bfd_byte *buildid;

  if (dwarf2_per_objfile->dwz_file != NULL)
    return dwarf2_per_objfile->dwz_file;

  bfd_set_error (bfd_error_no_error);
  data = bfd_get_alt_debug_link_info (dwarf2_per_objfile->objfile->obfd,
				      &buildid_len_arg, &buildid);
  if (data == NULL)
    {
      if (bfd_get_error () == bfd_error_no_error)
	return NULL;
      error (_("could not read '.gnu_debugaltlink' section: %s"),
	     bfd_errmsg (bfd_get_error ()));
    }
  cleanup = make_cleanup (xfree, data);
  make_cleanup (xfree, buildid);

  buildid_len = (size_t) buildid_len_arg;

  filename = (const char *) data;
  if (!IS_ABSOLUTE_PATH (filename))
    {
      char *abs = gdb_realpath (objfile_name (dwarf2_per_objfile->objfile));
      char *rel;

      make_cleanup (xfree, abs);
      abs = ldirname (abs);
      make_cleanup (xfree, abs);

      rel = concat (abs, SLASH_STRING, filename, (char *) NULL);
      make_cleanup (xfree, rel);
      filename = rel;
    }

  /* First try the file name given in the section.  If that doesn't
     work, try to use the build-id instead.  */
  dwz_bfd = gdb_bfd_open (filename, gnutarget, -1);
  if (dwz_bfd != NULL)
    {
      if (!build_id_verify (dwz_bfd, buildid_len, buildid))
	{
	  gdb_bfd_unref (dwz_bfd);
	  dwz_bfd = NULL;
	}
    }

  if (dwz_bfd == NULL)
    dwz_bfd = build_id_to_debug_bfd (buildid_len, buildid);

  if (dwz_bfd == NULL)
    error (_("could not find '.gnu_debugaltlink' file for %s"),
	   objfile_name (dwarf2_per_objfile->objfile));

  result = OBSTACK_ZALLOC (&dwarf2_per_objfile->objfile->objfile_obstack,
			   struct dwz_file);
  result->dwz_bfd = dwz_bfd;

  bfd_map_over_sections (dwz_bfd, locate_dwz_sections, result);

  do_cleanups (cleanup);

  dwarf2_per_objfile->dwz_file = result;
  return result;
}

/* DWARF quick_symbols_functions support.  */

/* TUs can share .debug_line entries, and there can be a lot more TUs than
   unique line tables, so we maintain a separate table of all .debug_line
   derived entries to support the sharing.
   All the quick functions need is the list of file names.  We discard the
   line_header when we're done and don't need to record it here.  */
struct quick_file_names
{
  /* The data used to construct the hash key.  */
  struct stmt_list_hash hash;

  /* The number of entries in file_names, real_names.  */
  unsigned int num_file_names;

  /* The file names from the line table, after being run through
     file_full_name.  */
  const char **file_names;

  /* The file names from the line table after being run through
     gdb_realpath.  These are computed lazily.  */
  const char **real_names;
};

/* When using the index (and thus not using psymtabs), each CU has an
   object of this type.  This is used to hold information needed by
   the various "quick" methods.  */
struct dwarf2_per_cu_quick_data
{
  /* The file table.  This can be NULL if there was no file table
     or it's currently not read in.
     NOTE: This points into dwarf2_per_objfile->quick_file_names_table.  */
  struct quick_file_names *file_names;

  /* The corresponding symbol table.  This is NULL if symbols for this
     CU have not yet been read.  */
  struct symtab *symtab;

  /* A temporary mark bit used when iterating over all CUs in
     expand_symtabs_matching.  */
  unsigned int mark : 1;

  /* True if we've tried to read the file table and found there isn't one.
     There will be no point in trying to read it again next time.  */
  unsigned int no_file_data : 1;
};

/* Utility hash function for a stmt_list_hash.  */

static hashval_t
hash_stmt_list_entry (const struct stmt_list_hash *stmt_list_hash)
{
  hashval_t v = 0;

  if (stmt_list_hash->dwo_unit != NULL)
    v += (uintptr_t) stmt_list_hash->dwo_unit->dwo_file;
  v += stmt_list_hash->line_offset.sect_off;
  return v;
}

/* Utility equality function for a stmt_list_hash.  */

static int
eq_stmt_list_entry (const struct stmt_list_hash *lhs,
		    const struct stmt_list_hash *rhs)
{
  if ((lhs->dwo_unit != NULL) != (rhs->dwo_unit != NULL))
    return 0;
  if (lhs->dwo_unit != NULL
      && lhs->dwo_unit->dwo_file != rhs->dwo_unit->dwo_file)
    return 0;

  return lhs->line_offset.sect_off == rhs->line_offset.sect_off;
}

/* Hash function for a quick_file_names.  */

static hashval_t
hash_file_name_entry (const void *e)
{
  const struct quick_file_names *file_data = e;

  return hash_stmt_list_entry (&file_data->hash);
}

/* Equality function for a quick_file_names.  */

static int
eq_file_name_entry (const void *a, const void *b)
{
  const struct quick_file_names *ea = a;
  const struct quick_file_names *eb = b;

  return eq_stmt_list_entry (&ea->hash, &eb->hash);
}

/* Delete function for a quick_file_names.  */

static void
delete_file_name_entry (void *e)
{
  struct quick_file_names *file_data = e;
  int i;

  for (i = 0; i < file_data->num_file_names; ++i)
    {
      xfree ((void*) file_data->file_names[i]);
      if (file_data->real_names)
	xfree ((void*) file_data->real_names[i]);
    }

  /* The space for the struct itself lives on objfile_obstack,
     so we don't free it here.  */
}

/* Create a quick_file_names hash table.  */

static htab_t
create_quick_file_names_table (unsigned int nr_initial_entries)
{
  return htab_create_alloc (nr_initial_entries,
			    hash_file_name_entry, eq_file_name_entry,
			    delete_file_name_entry, xcalloc, xfree);
}

/* Read in PER_CU->CU.  This function is unrelated to symtabs, symtab would
   have to be created afterwards.  You should call age_cached_comp_units after
   processing PER_CU->CU.  dw2_setup must have been already called.  */

static void
load_cu (struct dwarf2_per_cu_data *per_cu)
{
  if (per_cu->is_debug_types)
    load_full_type_unit (per_cu);
  else
    load_full_comp_unit (per_cu, language_minimal);

  gdb_assert (per_cu->cu != NULL);

  dwarf2_find_base_address (per_cu->cu->dies, per_cu->cu);
}

/* Read in the symbols for PER_CU.  */

static void
dw2_do_instantiate_symtab (struct dwarf2_per_cu_data *per_cu)
{
  struct cleanup *back_to;

  /* Skip type_unit_groups, reading the type units they contain
     is handled elsewhere.  */
  if (IS_TYPE_UNIT_GROUP (per_cu))
    return;

  back_to = make_cleanup (dwarf2_release_queue, NULL);

  if (dwarf2_per_objfile->using_index
      ? per_cu->v.quick->symtab == NULL
      : (per_cu->v.psymtab == NULL || !per_cu->v.psymtab->readin))
    {
      queue_comp_unit (per_cu, language_minimal);
      load_cu (per_cu);

      /* If we just loaded a CU from a DWO, and we're working with an index
	 that may badly handle TUs, load all the TUs in that DWO as well.
	 http://sourceware.org/bugzilla/show_bug.cgi?id=15021  */
      if (!per_cu->is_debug_types
	  && per_cu->cu->dwo_unit != NULL
	  && dwarf2_per_objfile->index_table != NULL
	  && dwarf2_per_objfile->index_table->version <= 7
	  /* DWP files aren't supported yet.  */
	  && get_dwp_file () == NULL)
	queue_and_load_all_dwo_tus (per_cu);
    }

  process_queue ();

  /* Age the cache, releasing compilation units that have not
     been used recently.  */
  age_cached_comp_units ();

  do_cleanups (back_to);
}

/* Ensure that the symbols for PER_CU have been read in.  OBJFILE is
   the objfile from which this CU came.  Returns the resulting symbol
   table.  */

static struct symtab *
dw2_instantiate_symtab (struct dwarf2_per_cu_data *per_cu)
{
  gdb_assert (dwarf2_per_objfile->using_index);
  if (!per_cu->v.quick->symtab)
    {
      struct cleanup *back_to = make_cleanup (free_cached_comp_units, NULL);
      increment_reading_symtab ();
      dw2_do_instantiate_symtab (per_cu);
      process_cu_includes ();
      do_cleanups (back_to);
    }
  return per_cu->v.quick->symtab;
}

/* Return the CU given its index.

   This is intended for loops like:

   for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		    + dwarf2_per_objfile->n_type_units); ++i)
     {
       struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);

       ...;
     }
*/

static struct dwarf2_per_cu_data *
dw2_get_cu (int index)
{
  if (index >= dwarf2_per_objfile->n_comp_units)
    {
      index -= dwarf2_per_objfile->n_comp_units;
      gdb_assert (index < dwarf2_per_objfile->n_type_units);
      return &dwarf2_per_objfile->all_type_units[index]->per_cu;
    }

  return dwarf2_per_objfile->all_comp_units[index];
}

/* Return the primary CU given its index.
   The difference between this function and dw2_get_cu is in the handling
   of type units (TUs).  Here we return the type_unit_group object.

   This is intended for loops like:

   for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		    + dwarf2_per_objfile->n_type_unit_groups); ++i)
     {
       struct dwarf2_per_cu_data *per_cu = dw2_get_primary_cu (i);

       ...;
     }
*/

static struct dwarf2_per_cu_data *
dw2_get_primary_cu (int index)
{
  if (index >= dwarf2_per_objfile->n_comp_units)
    {
      index -= dwarf2_per_objfile->n_comp_units;
      gdb_assert (index < dwarf2_per_objfile->n_type_unit_groups);
      return &dwarf2_per_objfile->all_type_unit_groups[index]->per_cu;
    }

  return dwarf2_per_objfile->all_comp_units[index];
}

/* A helper for create_cus_from_index that handles a given list of
   CUs.  */

static void
create_cus_from_index_list (struct objfile *objfile,
			    const gdb_byte *cu_list, offset_type n_elements,
			    struct dwarf2_section_info *section,
			    int is_dwz,
			    int base_offset)
{
  offset_type i;

  for (i = 0; i < n_elements; i += 2)
    {
      struct dwarf2_per_cu_data *the_cu;
      ULONGEST offset, length;

      gdb_static_assert (sizeof (ULONGEST) >= 8);
      offset = extract_unsigned_integer (cu_list, 8, BFD_ENDIAN_LITTLE);
      length = extract_unsigned_integer (cu_list + 8, 8, BFD_ENDIAN_LITTLE);
      cu_list += 2 * 8;

      the_cu = OBSTACK_ZALLOC (&objfile->objfile_obstack,
			       struct dwarf2_per_cu_data);
      the_cu->offset.sect_off = offset;
      the_cu->length = length;
      the_cu->objfile = objfile;
      the_cu->section = section;
      the_cu->v.quick = OBSTACK_ZALLOC (&objfile->objfile_obstack,
					struct dwarf2_per_cu_quick_data);
      the_cu->is_dwz = is_dwz;
      dwarf2_per_objfile->all_comp_units[base_offset + i / 2] = the_cu;
    }
}

/* Read the CU list from the mapped index, and use it to create all
   the CU objects for this objfile.  */

static void
create_cus_from_index (struct objfile *objfile,
		       const gdb_byte *cu_list, offset_type cu_list_elements,
		       const gdb_byte *dwz_list, offset_type dwz_elements)
{
  struct dwz_file *dwz;

  dwarf2_per_objfile->n_comp_units = (cu_list_elements + dwz_elements) / 2;
  dwarf2_per_objfile->all_comp_units
    = obstack_alloc (&objfile->objfile_obstack,
		     dwarf2_per_objfile->n_comp_units
		     * sizeof (struct dwarf2_per_cu_data *));

  create_cus_from_index_list (objfile, cu_list, cu_list_elements,
			      &dwarf2_per_objfile->info, 0, 0);

  if (dwz_elements == 0)
    return;

  dwz = dwarf2_get_dwz_file ();
  create_cus_from_index_list (objfile, dwz_list, dwz_elements, &dwz->info, 1,
			      cu_list_elements / 2);
}

/* Create the signatured type hash table from the index.  */

static void
create_signatured_type_table_from_index (struct objfile *objfile,
					 struct dwarf2_section_info *section,
					 const gdb_byte *bytes,
					 offset_type elements)
{
  offset_type i;
  htab_t sig_types_hash;

  dwarf2_per_objfile->n_type_units = elements / 3;
  dwarf2_per_objfile->all_type_units
    = xmalloc (dwarf2_per_objfile->n_type_units
	       * sizeof (struct signatured_type *));

  sig_types_hash = allocate_signatured_type_table (objfile);

  for (i = 0; i < elements; i += 3)
    {
      struct signatured_type *sig_type;
      ULONGEST offset, type_offset_in_tu, signature;
      void **slot;

      gdb_static_assert (sizeof (ULONGEST) >= 8);
      offset = extract_unsigned_integer (bytes, 8, BFD_ENDIAN_LITTLE);
      type_offset_in_tu = extract_unsigned_integer (bytes + 8, 8,
						    BFD_ENDIAN_LITTLE);
      signature = extract_unsigned_integer (bytes + 16, 8, BFD_ENDIAN_LITTLE);
      bytes += 3 * 8;

      sig_type = OBSTACK_ZALLOC (&objfile->objfile_obstack,
				 struct signatured_type);
      sig_type->signature = signature;
      sig_type->type_offset_in_tu.cu_off = type_offset_in_tu;
      sig_type->per_cu.is_debug_types = 1;
      sig_type->per_cu.section = section;
      sig_type->per_cu.offset.sect_off = offset;
      sig_type->per_cu.objfile = objfile;
      sig_type->per_cu.v.quick
	= OBSTACK_ZALLOC (&objfile->objfile_obstack,
			  struct dwarf2_per_cu_quick_data);

      slot = htab_find_slot (sig_types_hash, sig_type, INSERT);
      *slot = sig_type;

      dwarf2_per_objfile->all_type_units[i / 3] = sig_type;
    }

  dwarf2_per_objfile->signatured_types = sig_types_hash;
}

/* Read the address map data from the mapped index, and use it to
   populate the objfile's psymtabs_addrmap.  */

static void
create_addrmap_from_index (struct objfile *objfile, struct mapped_index *index)
{
  const gdb_byte *iter, *end;
  struct obstack temp_obstack;
  struct addrmap *mutable_map;
  struct cleanup *cleanup;
  CORE_ADDR baseaddr;

  obstack_init (&temp_obstack);
  cleanup = make_cleanup_obstack_free (&temp_obstack);
  mutable_map = addrmap_create_mutable (&temp_obstack);

  iter = index->address_table;
  end = iter + index->address_table_size;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  while (iter < end)
    {
      ULONGEST hi, lo, cu_index;
      lo = extract_unsigned_integer (iter, 8, BFD_ENDIAN_LITTLE);
      iter += 8;
      hi = extract_unsigned_integer (iter, 8, BFD_ENDIAN_LITTLE);
      iter += 8;
      cu_index = extract_unsigned_integer (iter, 4, BFD_ENDIAN_LITTLE);
      iter += 4;

      if (lo > hi)
	{
	  complaint (&symfile_complaints,
		     _(".gdb_index address table has invalid range (%s - %s)"),
		     hex_string (lo), hex_string (hi));
	  continue;
	}

      if (cu_index >= dwarf2_per_objfile->n_comp_units)
	{
	  complaint (&symfile_complaints,
		     _(".gdb_index address table has invalid CU number %u"),
		     (unsigned) cu_index);
	  continue;
	}

      addrmap_set_empty (mutable_map, lo + baseaddr, hi + baseaddr - 1,
			 dw2_get_cu (cu_index));
    }

  objfile->psymtabs_addrmap = addrmap_create_fixed (mutable_map,
						    &objfile->objfile_obstack);
  do_cleanups (cleanup);
}

/* The hash function for strings in the mapped index.  This is the same as
   SYMBOL_HASH_NEXT, but we keep a separate copy to maintain control over the
   implementation.  This is necessary because the hash function is tied to the
   format of the mapped index file.  The hash values do not have to match with
   SYMBOL_HASH_NEXT.
   
   Use INT_MAX for INDEX_VERSION if you generate the current index format.  */

static hashval_t
mapped_index_string_hash (int index_version, const void *p)
{
  const unsigned char *str = (const unsigned char *) p;
  hashval_t r = 0;
  unsigned char c;

  while ((c = *str++) != 0)
    {
      if (index_version >= 5)
	c = tolower (c);
      r = r * 67 + c - 113;
    }

  return r;
}

/* Find a slot in the mapped index INDEX for the object named NAME.
   If NAME is found, set *VEC_OUT to point to the CU vector in the
   constant pool and return 1.  If NAME cannot be found, return 0.  */

static int
find_slot_in_mapped_hash (struct mapped_index *index, const char *name,
			  offset_type **vec_out)
{
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
  offset_type hash;
  offset_type slot, step;
  int (*cmp) (const char *, const char *);

  if (current_language->la_language == language_cplus
      || current_language->la_language == language_java
      || current_language->la_language == language_fortran)
    {
      /* NAME is already canonical.  Drop any qualifiers as .gdb_index does
	 not contain any.  */
      const char *paren = strchr (name, '(');

      if (paren)
	{
	  char *dup;

	  dup = xmalloc (paren - name + 1);
	  memcpy (dup, name, paren - name);
	  dup[paren - name] = 0;

	  make_cleanup (xfree, dup);
	  name = dup;
	}
    }

  /* Index version 4 did not support case insensitive searches.  But the
     indices for case insensitive languages are built in lowercase, therefore
     simulate our NAME being searched is also lowercased.  */
  hash = mapped_index_string_hash ((index->version == 4
                                    && case_sensitivity == case_sensitive_off
				    ? 5 : index->version),
				   name);

  slot = hash & (index->symbol_table_slots - 1);
  step = ((hash * 17) & (index->symbol_table_slots - 1)) | 1;
  cmp = (case_sensitivity == case_sensitive_on ? strcmp : strcasecmp);

  for (;;)
    {
      /* Convert a slot number to an offset into the table.  */
      offset_type i = 2 * slot;
      const char *str;
      if (index->symbol_table[i] == 0 && index->symbol_table[i + 1] == 0)
	{
	  do_cleanups (back_to);
	  return 0;
	}

      str = index->constant_pool + MAYBE_SWAP (index->symbol_table[i]);
      if (!cmp (name, str))
	{
	  *vec_out = (offset_type *) (index->constant_pool
				      + MAYBE_SWAP (index->symbol_table[i + 1]));
	  do_cleanups (back_to);
	  return 1;
	}

      slot = (slot + step) & (index->symbol_table_slots - 1);
    }
}

/* A helper function that reads the .gdb_index from SECTION and fills
   in MAP.  FILENAME is the name of the file containing the section;
   it is used for error reporting.  DEPRECATED_OK is nonzero if it is
   ok to use deprecated sections.

   CU_LIST, CU_LIST_ELEMENTS, TYPES_LIST, and TYPES_LIST_ELEMENTS are
   out parameters that are filled in with information about the CU and
   TU lists in the section.

   Returns 1 if all went well, 0 otherwise.  */

static int
read_index_from_section (struct objfile *objfile,
			 const char *filename,
			 int deprecated_ok,
			 struct dwarf2_section_info *section,
			 struct mapped_index *map,
			 const gdb_byte **cu_list,
			 offset_type *cu_list_elements,
			 const gdb_byte **types_list,
			 offset_type *types_list_elements)
{
  const gdb_byte *addr;
  offset_type version;
  offset_type *metadata;
  int i;

  if (dwarf2_section_empty_p (section))
    return 0;

  /* Older elfutils strip versions could keep the section in the main
     executable while splitting it for the separate debug info file.  */
  if ((get_section_flags (section) & SEC_HAS_CONTENTS) == 0)
    return 0;

  dwarf2_read_section (objfile, section);

  addr = section->buffer;
  /* Version check.  */
  version = MAYBE_SWAP (*(offset_type *) addr);
  /* Versions earlier than 3 emitted every copy of a psymbol.  This
     causes the index to behave very poorly for certain requests.  Version 3
     contained incomplete addrmap.  So, it seems better to just ignore such
     indices.  */
  if (version < 4)
    {
      static int warning_printed = 0;
      if (!warning_printed)
	{
	  warning (_("Skipping obsolete .gdb_index section in %s."),
		   filename);
	  warning_printed = 1;
	}
      return 0;
    }
  /* Index version 4 uses a different hash function than index version
     5 and later.

     Versions earlier than 6 did not emit psymbols for inlined
     functions.  Using these files will cause GDB not to be able to
     set breakpoints on inlined functions by name, so we ignore these
     indices unless the user has done
     "set use-deprecated-index-sections on".  */
  if (version < 6 && !deprecated_ok)
    {
      static int warning_printed = 0;
      if (!warning_printed)
	{
	  warning (_("\
Skipping deprecated .gdb_index section in %s.\n\
Do \"set use-deprecated-index-sections on\" before the file is read\n\
to use the section anyway."),
		   filename);
	  warning_printed = 1;
	}
      return 0;
    }
  /* Version 7 indices generated by gold refer to the CU for a symbol instead
     of the TU (for symbols coming from TUs).  It's just a performance bug, and
     we can't distinguish gdb-generated indices from gold-generated ones, so
     nothing to do here.  */

  /* Indexes with higher version than the one supported by GDB may be no
     longer backward compatible.  */
  if (version > 8)
    return 0;

  map->version = version;
  map->total_size = section->size;

  metadata = (offset_type *) (addr + sizeof (offset_type));

  i = 0;
  *cu_list = addr + MAYBE_SWAP (metadata[i]);
  *cu_list_elements = ((MAYBE_SWAP (metadata[i + 1]) - MAYBE_SWAP (metadata[i]))
		       / 8);
  ++i;

  *types_list = addr + MAYBE_SWAP (metadata[i]);
  *types_list_elements = ((MAYBE_SWAP (metadata[i + 1])
			   - MAYBE_SWAP (metadata[i]))
			  / 8);
  ++i;

  map->address_table = addr + MAYBE_SWAP (metadata[i]);
  map->address_table_size = (MAYBE_SWAP (metadata[i + 1])
			     - MAYBE_SWAP (metadata[i]));
  ++i;

  map->symbol_table = (offset_type *) (addr + MAYBE_SWAP (metadata[i]));
  map->symbol_table_slots = ((MAYBE_SWAP (metadata[i + 1])
			      - MAYBE_SWAP (metadata[i]))
			     / (2 * sizeof (offset_type)));
  ++i;

  map->constant_pool = (char *) (addr + MAYBE_SWAP (metadata[i]));

  return 1;
}


/* Read the index file.  If everything went ok, initialize the "quick"
   elements of all the CUs and return 1.  Otherwise, return 0.  */

static int
dwarf2_read_index (struct objfile *objfile)
{
  struct mapped_index local_map, *map;
  const gdb_byte *cu_list, *types_list, *dwz_list = NULL;
  offset_type cu_list_elements, types_list_elements, dwz_list_elements = 0;
  struct dwz_file *dwz;

  if (!read_index_from_section (objfile, objfile_name (objfile),
				use_deprecated_index_sections,
				&dwarf2_per_objfile->gdb_index, &local_map,
				&cu_list, &cu_list_elements,
				&types_list, &types_list_elements))
    return 0;

  /* Don't use the index if it's empty.  */
  if (local_map.symbol_table_slots == 0)
    return 0;

  /* If there is a .dwz file, read it so we can get its CU list as
     well.  */
  dwz = dwarf2_get_dwz_file ();
  if (dwz != NULL)
    {
      struct mapped_index dwz_map;
      const gdb_byte *dwz_types_ignore;
      offset_type dwz_types_elements_ignore;

      if (!read_index_from_section (objfile, bfd_get_filename (dwz->dwz_bfd),
				    1,
				    &dwz->gdb_index, &dwz_map,
				    &dwz_list, &dwz_list_elements,
				    &dwz_types_ignore,
				    &dwz_types_elements_ignore))
	{
	  warning (_("could not read '.gdb_index' section from %s; skipping"),
		   bfd_get_filename (dwz->dwz_bfd));
	  return 0;
	}
    }

  create_cus_from_index (objfile, cu_list, cu_list_elements, dwz_list,
			 dwz_list_elements);

  if (types_list_elements)
    {
      struct dwarf2_section_info *section;

      /* We can only handle a single .debug_types when we have an
	 index.  */
      if (VEC_length (dwarf2_section_info_def, dwarf2_per_objfile->types) != 1)
	return 0;

      section = VEC_index (dwarf2_section_info_def,
			   dwarf2_per_objfile->types, 0);

      create_signatured_type_table_from_index (objfile, section, types_list,
					       types_list_elements);
    }

  create_addrmap_from_index (objfile, &local_map);

  map = obstack_alloc (&objfile->objfile_obstack, sizeof (struct mapped_index));
  *map = local_map;

  dwarf2_per_objfile->index_table = map;
  dwarf2_per_objfile->using_index = 1;
  dwarf2_per_objfile->quick_file_names_table =
    create_quick_file_names_table (dwarf2_per_objfile->n_comp_units);

  return 1;
}

/* A helper for the "quick" functions which sets the global
   dwarf2_per_objfile according to OBJFILE.  */

static void
dw2_setup (struct objfile *objfile)
{
  dwarf2_per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);
  gdb_assert (dwarf2_per_objfile);
}

/* die_reader_func for dw2_get_file_names.  */

static void
dw2_get_file_names_reader (const struct die_reader_specs *reader,
			   const gdb_byte *info_ptr,
			   struct die_info *comp_unit_die,
			   int has_children,
			   void *data)
{
  struct dwarf2_cu *cu = reader->cu;
  struct dwarf2_per_cu_data *this_cu = cu->per_cu;  
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_per_cu_data *lh_cu;
  struct line_header *lh;
  struct attribute *attr;
  int i;
  const char *name, *comp_dir;
  void **slot;
  struct quick_file_names *qfn;
  unsigned int line_offset;

  gdb_assert (! this_cu->is_debug_types);

  /* Our callers never want to match partial units -- instead they
     will match the enclosing full CU.  */
  if (comp_unit_die->tag == DW_TAG_partial_unit)
    {
      this_cu->v.quick->no_file_data = 1;
      return;
    }

  lh_cu = this_cu;
  lh = NULL;
  slot = NULL;
  line_offset = 0;

  attr = dwarf2_attr (comp_unit_die, DW_AT_stmt_list, cu);
  if (attr)
    {
      struct quick_file_names find_entry;

      line_offset = DW_UNSND (attr);

      /* We may have already read in this line header (TU line header sharing).
	 If we have we're done.  */
      find_entry.hash.dwo_unit = cu->dwo_unit;
      find_entry.hash.line_offset.sect_off = line_offset;
      slot = htab_find_slot (dwarf2_per_objfile->quick_file_names_table,
			     &find_entry, INSERT);
      if (*slot != NULL)
	{
	  lh_cu->v.quick->file_names = *slot;
	  return;
	}

      lh = dwarf_decode_line_header (line_offset, cu);
    }
  if (lh == NULL)
    {
      lh_cu->v.quick->no_file_data = 1;
      return;
    }

  qfn = obstack_alloc (&objfile->objfile_obstack, sizeof (*qfn));
  qfn->hash.dwo_unit = cu->dwo_unit;
  qfn->hash.line_offset.sect_off = line_offset;
  gdb_assert (slot != NULL);
  *slot = qfn;

  find_file_and_directory (comp_unit_die, cu, &name, &comp_dir);

  qfn->num_file_names = lh->num_file_names;
  qfn->file_names = obstack_alloc (&objfile->objfile_obstack,
				   lh->num_file_names * sizeof (char *));
  for (i = 0; i < lh->num_file_names; ++i)
    qfn->file_names[i] = file_full_name (i + 1, lh, comp_dir);
  qfn->real_names = NULL;

  free_line_header (lh);

  lh_cu->v.quick->file_names = qfn;
}

/* A helper for the "quick" functions which attempts to read the line
   table for THIS_CU.  */

static struct quick_file_names *
dw2_get_file_names (struct dwarf2_per_cu_data *this_cu)
{
  /* This should never be called for TUs.  */
  gdb_assert (! this_cu->is_debug_types);
  /* Nor type unit groups.  */
  gdb_assert (! IS_TYPE_UNIT_GROUP (this_cu));

  if (this_cu->v.quick->file_names != NULL)
    return this_cu->v.quick->file_names;
  /* If we know there is no line data, no point in looking again.  */
  if (this_cu->v.quick->no_file_data)
    return NULL;

  init_cutu_and_read_dies_simple (this_cu, dw2_get_file_names_reader, NULL);

  if (this_cu->v.quick->no_file_data)
    return NULL;
  return this_cu->v.quick->file_names;
}

/* A helper for the "quick" functions which computes and caches the
   real path for a given file name from the line table.  */

static const char *
dw2_get_real_path (struct objfile *objfile,
		   struct quick_file_names *qfn, int index)
{
  if (qfn->real_names == NULL)
    qfn->real_names = OBSTACK_CALLOC (&objfile->objfile_obstack,
				      qfn->num_file_names, char *);

  if (qfn->real_names[index] == NULL)
    qfn->real_names[index] = gdb_realpath (qfn->file_names[index]);

  return qfn->real_names[index];
}

static struct symtab *
dw2_find_last_source_symtab (struct objfile *objfile)
{
  int index;

  dw2_setup (objfile);
  index = dwarf2_per_objfile->n_comp_units - 1;
  return dw2_instantiate_symtab (dw2_get_cu (index));
}

/* Traversal function for dw2_forget_cached_source_info.  */

static int
dw2_free_cached_file_names (void **slot, void *info)
{
  struct quick_file_names *file_data = (struct quick_file_names *) *slot;

  if (file_data->real_names)
    {
      int i;

      for (i = 0; i < file_data->num_file_names; ++i)
	{
	  xfree ((void*) file_data->real_names[i]);
	  file_data->real_names[i] = NULL;
	}
    }

  return 1;
}

static void
dw2_forget_cached_source_info (struct objfile *objfile)
{
  dw2_setup (objfile);

  htab_traverse_noresize (dwarf2_per_objfile->quick_file_names_table,
			  dw2_free_cached_file_names, NULL);
}

/* Helper function for dw2_map_symtabs_matching_filename that expands
   the symtabs and calls the iterator.  */

static int
dw2_map_expand_apply (struct objfile *objfile,
		      struct dwarf2_per_cu_data *per_cu,
		      const char *name, const char *real_path,
		      int (*callback) (struct symtab *, void *),
		      void *data)
{
  struct symtab *last_made = objfile->symtabs;

  /* Don't visit already-expanded CUs.  */
  if (per_cu->v.quick->symtab)
    return 0;

  /* This may expand more than one symtab, and we want to iterate over
     all of them.  */
  dw2_instantiate_symtab (per_cu);

  return iterate_over_some_symtabs (name, real_path, callback, data,
				    objfile->symtabs, last_made);
}

/* Implementation of the map_symtabs_matching_filename method.  */

static int
dw2_map_symtabs_matching_filename (struct objfile *objfile, const char *name,
				   const char *real_path,
				   int (*callback) (struct symtab *, void *),
				   void *data)
{
  int i;
  const char *name_basename = lbasename (name);

  dw2_setup (objfile);

  /* The rule is CUs specify all the files, including those used by
     any TU, so there's no need to scan TUs here.  */

  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
    {
      int j;
      struct dwarf2_per_cu_data *per_cu = dw2_get_primary_cu (i);
      struct quick_file_names *file_data;

      /* We only need to look at symtabs not already expanded.  */
      if (per_cu->v.quick->symtab)
	continue;

      file_data = dw2_get_file_names (per_cu);
      if (file_data == NULL)
	continue;

      for (j = 0; j < file_data->num_file_names; ++j)
	{
	  const char *this_name = file_data->file_names[j];
	  const char *this_real_name;

	  if (compare_filenames_for_search (this_name, name))
	    {
	      if (dw2_map_expand_apply (objfile, per_cu, name, real_path,
					callback, data))
		return 1;
	      continue;
	    }

	  /* Before we invoke realpath, which can get expensive when many
	     files are involved, do a quick comparison of the basenames.  */
	  if (! basenames_may_differ
	      && FILENAME_CMP (lbasename (this_name), name_basename) != 0)
	    continue;

	  this_real_name = dw2_get_real_path (objfile, file_data, j);
	  if (compare_filenames_for_search (this_real_name, name))
	    {
	      if (dw2_map_expand_apply (objfile, per_cu, name, real_path,
					callback, data))
		return 1;
	      continue;
	    }

	  if (real_path != NULL)
	    {
	      gdb_assert (IS_ABSOLUTE_PATH (real_path));
	      gdb_assert (IS_ABSOLUTE_PATH (name));
	      if (this_real_name != NULL
		  && FILENAME_CMP (real_path, this_real_name) == 0)
		{
		  if (dw2_map_expand_apply (objfile, per_cu, name, real_path,
					    callback, data))
		    return 1;
		  continue;
		}
	    }
	}
    }

  return 0;
}

/* Struct used to manage iterating over all CUs looking for a symbol.  */

struct dw2_symtab_iterator
{
  /* The internalized form of .gdb_index.  */
  struct mapped_index *index;
  /* If non-zero, only look for symbols that match BLOCK_INDEX.  */
  int want_specific_block;
  /* One of GLOBAL_BLOCK or STATIC_BLOCK.
     Unused if !WANT_SPECIFIC_BLOCK.  */
  int block_index;
  /* The kind of symbol we're looking for.  */
  domain_enum domain;
  /* The list of CUs from the index entry of the symbol,
     or NULL if not found.  */
  offset_type *vec;
  /* The next element in VEC to look at.  */
  int next;
  /* The number of elements in VEC, or zero if there is no match.  */
  int length;
};

/* Initialize the index symtab iterator ITER.
   If WANT_SPECIFIC_BLOCK is non-zero, only look for symbols
   in block BLOCK_INDEX.  Otherwise BLOCK_INDEX is ignored.  */

static void
dw2_symtab_iter_init (struct dw2_symtab_iterator *iter,
		      struct mapped_index *index,
		      int want_specific_block,
		      int block_index,
		      domain_enum domain,
		      const char *name)
{
  iter->index = index;
  iter->want_specific_block = want_specific_block;
  iter->block_index = block_index;
  iter->domain = domain;
  iter->next = 0;

  if (find_slot_in_mapped_hash (index, name, &iter->vec))
    iter->length = MAYBE_SWAP (*iter->vec);
  else
    {
      iter->vec = NULL;
      iter->length = 0;
    }
}

/* Return the next matching CU or NULL if there are no more.  */

static struct dwarf2_per_cu_data *
dw2_symtab_iter_next (struct dw2_symtab_iterator *iter)
{
  for ( ; iter->next < iter->length; ++iter->next)
    {
      offset_type cu_index_and_attrs =
	MAYBE_SWAP (iter->vec[iter->next + 1]);
      offset_type cu_index = GDB_INDEX_CU_VALUE (cu_index_and_attrs);
      struct dwarf2_per_cu_data *per_cu;
      int want_static = iter->block_index != GLOBAL_BLOCK;
      /* This value is only valid for index versions >= 7.  */
      int is_static = GDB_INDEX_SYMBOL_STATIC_VALUE (cu_index_and_attrs);
      gdb_index_symbol_kind symbol_kind =
	GDB_INDEX_SYMBOL_KIND_VALUE (cu_index_and_attrs);
      /* Only check the symbol attributes if they're present.
	 Indices prior to version 7 don't record them,
	 and indices >= 7 may elide them for certain symbols
	 (gold does this).  */
      int attrs_valid =
	(iter->index->version >= 7
	 && symbol_kind != GDB_INDEX_SYMBOL_KIND_NONE);

      /* Don't crash on bad data.  */
      if (cu_index >= (dwarf2_per_objfile->n_comp_units
		       + dwarf2_per_objfile->n_type_units))
	{
	  complaint (&symfile_complaints,
		     _(".gdb_index entry has bad CU index"
		       " [in module %s]"),
		     objfile_name (dwarf2_per_objfile->objfile));
	  continue;
	}

      per_cu = dw2_get_cu (cu_index);

      /* Skip if already read in.  */
      if (per_cu->v.quick->symtab)
	continue;

      if (attrs_valid
	  && iter->want_specific_block
	  && want_static != is_static)
	continue;

      /* Only check the symbol's kind if it has one.  */
      if (attrs_valid)
	{
	  switch (iter->domain)
	    {
	    case VAR_DOMAIN:
	      if (symbol_kind != GDB_INDEX_SYMBOL_KIND_VARIABLE
		  && symbol_kind != GDB_INDEX_SYMBOL_KIND_FUNCTION
		  /* Some types are also in VAR_DOMAIN.  */
		  && symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
		continue;
	      break;
	    case STRUCT_DOMAIN:
	      if (symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
		continue;
	      break;
	    case LABEL_DOMAIN:
	      if (symbol_kind != GDB_INDEX_SYMBOL_KIND_OTHER)
		continue;
	      break;
	    default:
	      break;
	    }
	}

      ++iter->next;
      return per_cu;
    }

  return NULL;
}

static struct symtab *
dw2_lookup_symbol (struct objfile *objfile, int block_index,
		   const char *name, domain_enum domain)
{
  struct symtab *stab_best = NULL;
  struct mapped_index *index;

  dw2_setup (objfile);

  index = dwarf2_per_objfile->index_table;

  /* index is NULL if OBJF_READNOW.  */
  if (index)
    {
      struct dw2_symtab_iterator iter;
      struct dwarf2_per_cu_data *per_cu;

      dw2_symtab_iter_init (&iter, index, 1, block_index, domain, name);

      while ((per_cu = dw2_symtab_iter_next (&iter)) != NULL)
	{
	  struct symbol *sym = NULL;
	  struct symtab *stab = dw2_instantiate_symtab (per_cu);

	  /* Some caution must be observed with overloaded functions
	     and methods, since the index will not contain any overload
	     information (but NAME might contain it).  */
	  if (stab->primary)
	    {
	      struct blockvector *bv = BLOCKVECTOR (stab);
	      struct block *block = BLOCKVECTOR_BLOCK (bv, block_index);

	      sym = lookup_block_symbol (block, name, domain);
	    }

	  if (sym && strcmp_iw (SYMBOL_SEARCH_NAME (sym), name) == 0)
	    {
	      if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
		return stab;

	      stab_best = stab;
	    }

	  /* Keep looking through other CUs.  */
	}
    }

  return stab_best;
}

static void
dw2_print_stats (struct objfile *objfile)
{
  int i, total, count;

  dw2_setup (objfile);
  total = dwarf2_per_objfile->n_comp_units + dwarf2_per_objfile->n_type_units;
  count = 0;
  for (i = 0; i < total; ++i)
    {
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);

      if (!per_cu->v.quick->symtab)
	++count;
    }
  printf_filtered (_("  Number of read CUs: %d\n"), total - count);
  printf_filtered (_("  Number of unread CUs: %d\n"), count);
}

/* This dumps minimal information about the index.
   It is called via "mt print objfiles".
   One use is to verify .gdb_index has been loaded by the
   gdb.dwarf2/gdb-index.exp testcase.  */

static void
dw2_dump (struct objfile *objfile)
{
  dw2_setup (objfile);
  gdb_assert (dwarf2_per_objfile->using_index);
  printf_filtered (".gdb_index:");
  if (dwarf2_per_objfile->index_table != NULL)
    {
      printf_filtered (" version %d\n",
		       dwarf2_per_objfile->index_table->version);
    }
  else
    printf_filtered (" faked for \"readnow\"\n");
  printf_filtered ("\n");
}

static void
dw2_relocate (struct objfile *objfile,
	      const struct section_offsets *new_offsets,
	      const struct section_offsets *delta)
{
  /* There's nothing to relocate here.  */
}

static void
dw2_expand_symtabs_for_function (struct objfile *objfile,
				 const char *func_name)
{
  struct mapped_index *index;

  dw2_setup (objfile);

  index = dwarf2_per_objfile->index_table;

  /* index is NULL if OBJF_READNOW.  */
  if (index)
    {
      struct dw2_symtab_iterator iter;
      struct dwarf2_per_cu_data *per_cu;

      /* Note: It doesn't matter what we pass for block_index here.  */
      dw2_symtab_iter_init (&iter, index, 0, GLOBAL_BLOCK, VAR_DOMAIN,
			    func_name);

      while ((per_cu = dw2_symtab_iter_next (&iter)) != NULL)
	dw2_instantiate_symtab (per_cu);
    }
}

static void
dw2_expand_all_symtabs (struct objfile *objfile)
{
  int i;

  dw2_setup (objfile);

  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_units); ++i)
    {
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);

      dw2_instantiate_symtab (per_cu);
    }
}

static void
dw2_expand_symtabs_with_fullname (struct objfile *objfile,
				  const char *fullname)
{
  int i;

  dw2_setup (objfile);

  /* We don't need to consider type units here.
     This is only called for examining code, e.g. expand_line_sal.
     There can be an order of magnitude (or more) more type units
     than comp units, and we avoid them if we can.  */

  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
    {
      int j;
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
      struct quick_file_names *file_data;

      /* We only need to look at symtabs not already expanded.  */
      if (per_cu->v.quick->symtab)
	continue;

      file_data = dw2_get_file_names (per_cu);
      if (file_data == NULL)
	continue;

      for (j = 0; j < file_data->num_file_names; ++j)
	{
	  const char *this_fullname = file_data->file_names[j];

	  if (filename_cmp (this_fullname, fullname) == 0)
	    {
	      dw2_instantiate_symtab (per_cu);
	      break;
	    }
	}
    }
}

static void
dw2_map_matching_symbols (struct objfile *objfile,
			  const char * name, domain_enum namespace,
			  int global,
			  int (*callback) (struct block *,
					   struct symbol *, void *),
			  void *data, symbol_compare_ftype *match,
			  symbol_compare_ftype *ordered_compare)
{
  /* Currently unimplemented; used for Ada.  The function can be called if the
     current language is Ada for a non-Ada objfile using GNU index.  As Ada
     does not look for non-Ada symbols this function should just return.  */
}

static void
dw2_expand_symtabs_matching
  (struct objfile *objfile,
   int (*file_matcher) (const char *, void *, int basenames),
   int (*name_matcher) (const char *, void *),
   enum search_domain kind,
   void *data)
{
  int i;
  offset_type iter;
  struct mapped_index *index;

  dw2_setup (objfile);

  /* index_table is NULL if OBJF_READNOW.  */
  if (!dwarf2_per_objfile->index_table)
    return;
  index = dwarf2_per_objfile->index_table;

  if (file_matcher != NULL)
    {
      struct cleanup *cleanup;
      htab_t visited_found, visited_not_found;

      visited_found = htab_create_alloc (10,
					 htab_hash_pointer, htab_eq_pointer,
					 NULL, xcalloc, xfree);
      cleanup = make_cleanup_htab_delete (visited_found);
      visited_not_found = htab_create_alloc (10,
					     htab_hash_pointer, htab_eq_pointer,
					     NULL, xcalloc, xfree);
      make_cleanup_htab_delete (visited_not_found);

      /* The rule is CUs specify all the files, including those used by
	 any TU, so there's no need to scan TUs here.  */

      for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
	{
	  int j;
	  struct dwarf2_per_cu_data *per_cu = dw2_get_primary_cu (i);
	  struct quick_file_names *file_data;
	  void **slot;

	  per_cu->v.quick->mark = 0;

	  /* We only need to look at symtabs not already expanded.  */
	  if (per_cu->v.quick->symtab)
	    continue;

	  file_data = dw2_get_file_names (per_cu);
	  if (file_data == NULL)
	    continue;

	  if (htab_find (visited_not_found, file_data) != NULL)
	    continue;
	  else if (htab_find (visited_found, file_data) != NULL)
	    {
	      per_cu->v.quick->mark = 1;
	      continue;
	    }

	  for (j = 0; j < file_data->num_file_names; ++j)
	    {
	      const char *this_real_name;

	      if (file_matcher (file_data->file_names[j], data, 0))
		{
		  per_cu->v.quick->mark = 1;
		  break;
		}

	      /* Before we invoke realpath, which can get expensive when many
		 files are involved, do a quick comparison of the basenames.  */
	      if (!basenames_may_differ
		  && !file_matcher (lbasename (file_data->file_names[j]),
				    data, 1))
		continue;

	      this_real_name = dw2_get_real_path (objfile, file_data, j);
	      if (file_matcher (this_real_name, data, 0))
		{
		  per_cu->v.quick->mark = 1;
		  break;
		}
	    }

	  slot = htab_find_slot (per_cu->v.quick->mark
				 ? visited_found
				 : visited_not_found,
				 file_data, INSERT);
	  *slot = file_data;
	}

      do_cleanups (cleanup);
    }

  for (iter = 0; iter < index->symbol_table_slots; ++iter)
    {
      offset_type idx = 2 * iter;
      const char *name;
      offset_type *vec, vec_len, vec_idx;

      if (index->symbol_table[idx] == 0 && index->symbol_table[idx + 1] == 0)
	continue;

      name = index->constant_pool + MAYBE_SWAP (index->symbol_table[idx]);

      if (! (*name_matcher) (name, data))
	continue;

      /* The name was matched, now expand corresponding CUs that were
	 marked.  */
      vec = (offset_type *) (index->constant_pool
			     + MAYBE_SWAP (index->symbol_table[idx + 1]));
      vec_len = MAYBE_SWAP (vec[0]);
      for (vec_idx = 0; vec_idx < vec_len; ++vec_idx)
	{
	  struct dwarf2_per_cu_data *per_cu;
	  offset_type cu_index_and_attrs = MAYBE_SWAP (vec[vec_idx + 1]);
	  gdb_index_symbol_kind symbol_kind =
	    GDB_INDEX_SYMBOL_KIND_VALUE (cu_index_and_attrs);
	  int cu_index = GDB_INDEX_CU_VALUE (cu_index_and_attrs);
	  /* Only check the symbol attributes if they're present.
	     Indices prior to version 7 don't record them,
	     and indices >= 7 may elide them for certain symbols
	     (gold does this).  */
	  int attrs_valid =
	    (index->version >= 7
	     && symbol_kind != GDB_INDEX_SYMBOL_KIND_NONE);

	  /* Only check the symbol's kind if it has one.  */
	  if (attrs_valid)
	    {
	      switch (kind)
		{
		case VARIABLES_DOMAIN:
		  if (symbol_kind != GDB_INDEX_SYMBOL_KIND_VARIABLE)
		    continue;
		  break;
		case FUNCTIONS_DOMAIN:
		  if (symbol_kind != GDB_INDEX_SYMBOL_KIND_FUNCTION)
		    continue;
		  break;
		case TYPES_DOMAIN:
		  if (symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
		    continue;
		  break;
		default:
		  break;
		}
	    }

	  /* Don't crash on bad data.  */
	  if (cu_index >= (dwarf2_per_objfile->n_comp_units
			   + dwarf2_per_objfile->n_type_units))
	    {
	      complaint (&symfile_complaints,
			 _(".gdb_index entry has bad CU index"
			   " [in module %s]"), objfile_name (objfile));
	      continue;
	    }

	  per_cu = dw2_get_cu (cu_index);
	  if (file_matcher == NULL || per_cu->v.quick->mark)
	    dw2_instantiate_symtab (per_cu);
	}
    }
}

/* A helper for dw2_find_pc_sect_symtab which finds the most specific
   symtab.  */

static struct symtab *
recursively_find_pc_sect_symtab (struct symtab *symtab, CORE_ADDR pc)
{
  int i;

  if (BLOCKVECTOR (symtab) != NULL
      && blockvector_contains_pc (BLOCKVECTOR (symtab), pc))
    return symtab;

  if (symtab->includes == NULL)
    return NULL;

  for (i = 0; symtab->includes[i]; ++i)
    {
      struct symtab *s = symtab->includes[i];

      s = recursively_find_pc_sect_symtab (s, pc);
      if (s != NULL)
	return s;
    }

  return NULL;
}

static struct symtab *
dw2_find_pc_sect_symtab (struct objfile *objfile,
			 struct minimal_symbol *msymbol,
			 CORE_ADDR pc,
			 struct obj_section *section,
			 int warn_if_readin)
{
  struct dwarf2_per_cu_data *data;
  struct symtab *result;

  dw2_setup (objfile);

  if (!objfile->psymtabs_addrmap)
    return NULL;

  data = addrmap_find (objfile->psymtabs_addrmap, pc);
  if (!data)
    return NULL;

  if (warn_if_readin && data->v.quick->symtab)
    warning (_("(Internal error: pc %s in read in CU, but not in symtab.)"),
	     paddress (get_objfile_arch (objfile), pc));

  result = recursively_find_pc_sect_symtab (dw2_instantiate_symtab (data), pc);
  gdb_assert (result != NULL);
  return result;
}

static void
dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,
			  void *data, int need_fullname)
{
  int i;
  struct cleanup *cleanup;
  htab_t visited = htab_create_alloc (10, htab_hash_pointer, htab_eq_pointer,
				      NULL, xcalloc, xfree);

  cleanup = make_cleanup_htab_delete (visited);
  dw2_setup (objfile);

  /* The rule is CUs specify all the files, including those used by
     any TU, so there's no need to scan TUs here.
     We can ignore file names coming from already-expanded CUs.  */

  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
    {
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);

      if (per_cu->v.quick->symtab)
	{
	  void **slot = htab_find_slot (visited, per_cu->v.quick->file_names,
					INSERT);

	  *slot = per_cu->v.quick->file_names;
	}
    }

  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
    {
      int j;
      struct dwarf2_per_cu_data *per_cu = dw2_get_primary_cu (i);
      struct quick_file_names *file_data;
      void **slot;

      /* We only need to look at symtabs not already expanded.  */
      if (per_cu->v.quick->symtab)
	continue;

      file_data = dw2_get_file_names (per_cu);
      if (file_data == NULL)
	continue;

      slot = htab_find_slot (visited, file_data, INSERT);
      if (*slot)
	{
	  /* Already visited.  */
	  continue;
	}
      *slot = file_data;

      for (j = 0; j < file_data->num_file_names; ++j)
	{
	  const char *this_real_name;

	  if (need_fullname)
	    this_real_name = dw2_get_real_path (objfile, file_data, j);
	  else
	    this_real_name = NULL;
	  (*fun) (file_data->file_names[j], this_real_name, data);
	}
    }

  do_cleanups (cleanup);
}

static int
dw2_has_symbols (struct objfile *objfile)
{
  return 1;
}

const struct quick_symbol_functions dwarf2_gdb_index_functions =
{
  dw2_has_symbols,
  dw2_find_last_source_symtab,
  dw2_forget_cached_source_info,
  dw2_map_symtabs_matching_filename,
  dw2_lookup_symbol,
  dw2_print_stats,
  dw2_dump,
  dw2_relocate,
  dw2_expand_symtabs_for_function,
  dw2_expand_all_symtabs,
  dw2_expand_symtabs_with_fullname,
  dw2_map_matching_symbols,
  dw2_expand_symtabs_matching,
  dw2_find_pc_sect_symtab,
  dw2_map_symbol_filenames
};

/* Initialize for reading DWARF for this objfile.  Return 0 if this
   file will use psymtabs, or 1 if using the GNU index.  */

int
dwarf2_initialize_objfile (struct objfile *objfile)
{
  /* If we're about to read full symbols, don't bother with the
     indices.  In this case we also don't care if some other debug
     format is making psymtabs, because they are all about to be
     expanded anyway.  */
  if ((objfile->flags & OBJF_READNOW))
    {
      int i;

      dwarf2_per_objfile->using_index = 1;
      create_all_comp_units (objfile);
      create_all_type_units (objfile);
      dwarf2_per_objfile->quick_file_names_table =
	create_quick_file_names_table (dwarf2_per_objfile->n_comp_units);

      for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		       + dwarf2_per_objfile->n_type_units); ++i)
	{
	  struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);

	  per_cu->v.quick = OBSTACK_ZALLOC (&objfile->objfile_obstack,
					    struct dwarf2_per_cu_quick_data);
	}

      /* Return 1 so that gdb sees the "quick" functions.  However,
	 these functions will be no-ops because we will have expanded
	 all symtabs.  */
      return 1;
    }

  if (dwarf2_read_index (objfile))
    return 1;

  return 0;
}



/* Build a partial symbol table.  */

void
dwarf2_build_psymtabs (struct objfile *objfile)
{
  volatile struct gdb_exception except;

  if (objfile->global_psymbols.size == 0 && objfile->static_psymbols.size == 0)
    {
      init_psymbol_list (objfile, 1024);
    }

  TRY_CATCH (except, RETURN_MASK_ERROR)
    {
      /* This isn't really ideal: all the data we allocate on the
	 objfile's obstack is still uselessly kept around.  However,
	 freeing it seems unsafe.  */
      struct cleanup *cleanups = make_cleanup_discard_psymtabs (objfile);

      dwarf2_build_psymtabs_hard (objfile);
      discard_cleanups (cleanups);
    }
  if (except.reason < 0)
    exception_print (gdb_stderr, except);
}

/* Return the total length of the CU described by HEADER.  */

static unsigned int
get_cu_length (const struct comp_unit_head *header)
{
  return header->initial_length_size + header->length;
}

/* Return TRUE if OFFSET is within CU_HEADER.  */

static inline int
offset_in_cu_p (const struct comp_unit_head *cu_header, sect_offset offset)
{
  sect_offset bottom = { cu_header->offset.sect_off };
  sect_offset top = { cu_header->offset.sect_off + get_cu_length (cu_header) };

  return (offset.sect_off >= bottom.sect_off && offset.sect_off < top.sect_off);
}

/* Find the base address of the compilation unit for range lists and
   location lists.  It will normally be specified by DW_AT_low_pc.
   In DWARF-3 draft 4, the base address could be overridden by
   DW_AT_entry_pc.  It's been removed, but GCC still uses this for
   compilation units with discontinuous ranges.  */

static void
dwarf2_find_base_address (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  cu->base_known = 0;
  cu->base_address = 0;

  attr = dwarf2_attr (die, DW_AT_entry_pc, cu);
  if (attr)
    {
      cu->base_address = DW_ADDR (attr);
      cu->base_known = 1;
    }
  else
    {
      attr = dwarf2_attr (die, DW_AT_low_pc, cu);
      if (attr)
	{
	  cu->base_address = DW_ADDR (attr);
	  cu->base_known = 1;
	}
    }
}

/* Read in the comp unit header information from the debug_info at info_ptr.
   NOTE: This leaves members offset, first_die_offset to be filled in
   by the caller.  */

static const gdb_byte *
read_comp_unit_head (struct comp_unit_head *cu_header,
		     const gdb_byte *info_ptr, bfd *abfd)
{
  int signed_addr;
  unsigned int bytes_read;

  cu_header->length = read_initial_length (abfd, info_ptr, &bytes_read);
  cu_header->initial_length_size = bytes_read;
  cu_header->offset_size = (bytes_read == 4) ? 4 : 8;
  info_ptr += bytes_read;
  cu_header->version = read_2_bytes (abfd, info_ptr);
  info_ptr += 2;
  cu_header->abbrev_offset.sect_off = read_offset (abfd, info_ptr, cu_header,
					     &bytes_read);
  info_ptr += bytes_read;
  cu_header->addr_size = read_1_byte (abfd, info_ptr);
  info_ptr += 1;
  signed_addr = bfd_get_sign_extend_vma (abfd);
  if (signed_addr < 0)
    internal_error (__FILE__, __LINE__,
		    _("read_comp_unit_head: dwarf from non elf file"));
  cu_header->signed_addr_p = signed_addr;

  return info_ptr;
}

/* Helper function that returns the proper abbrev section for
   THIS_CU.  */

static struct dwarf2_section_info *
get_abbrev_section_for_cu (struct dwarf2_per_cu_data *this_cu)
{
  struct dwarf2_section_info *abbrev;

  if (this_cu->is_dwz)
    abbrev = &dwarf2_get_dwz_file ()->abbrev;
  else
    abbrev = &dwarf2_per_objfile->abbrev;

  return abbrev;
}

/* Subroutine of read_and_check_comp_unit_head and
   read_and_check_type_unit_head to simplify them.
   Perform various error checking on the header.  */

static void
error_check_comp_unit_head (struct comp_unit_head *header,
			    struct dwarf2_section_info *section,
			    struct dwarf2_section_info *abbrev_section)
{
  bfd *abfd = get_section_bfd_owner (section);
  const char *filename = get_section_file_name (section);

  if (header->version != 2 && header->version != 3 && header->version != 4)
    error (_("Dwarf Error: wrong version in compilation unit header "
	   "(is %d, should be 2, 3, or 4) [in module %s]"), header->version,
	   filename);

  if (header->abbrev_offset.sect_off
      >= dwarf2_section_size (dwarf2_per_objfile->objfile, abbrev_section))
    error (_("Dwarf Error: bad offset (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 6) [in module %s]"),
	   (long) header->abbrev_offset.sect_off, (long) header->offset.sect_off,
	   filename);

  /* Cast to unsigned long to use 64-bit arithmetic when possible to
     avoid potential 32-bit overflow.  */
  if (((unsigned long) header->offset.sect_off + get_cu_length (header))
      > section->size)
    error (_("Dwarf Error: bad length (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 0) [in module %s]"),
	   (long) header->length, (long) header->offset.sect_off,
	   filename);
}

/* Read in a CU/TU header and perform some basic error checking.
   The contents of the header are stored in HEADER.
   The result is a pointer to the start of the first DIE.  */

static const gdb_byte *
read_and_check_comp_unit_head (struct comp_unit_head *header,
			       struct dwarf2_section_info *section,
			       struct dwarf2_section_info *abbrev_section,
			       const gdb_byte *info_ptr,
			       int is_debug_types_section)
{
  const gdb_byte *beg_of_comp_unit = info_ptr;
  bfd *abfd = get_section_bfd_owner (section);

  header->offset.sect_off = beg_of_comp_unit - section->buffer;

  info_ptr = read_comp_unit_head (header, info_ptr, abfd);

  /* If we're reading a type unit, skip over the signature and
     type_offset fields.  */
  if (is_debug_types_section)
    info_ptr += 8 /*signature*/ + header->offset_size;

  header->first_die_offset.cu_off = info_ptr - beg_of_comp_unit;

  error_check_comp_unit_head (header, section, abbrev_section);

  return info_ptr;
}

/* Read in the types comp unit header information from .debug_types entry at
   types_ptr.  The result is a pointer to one past the end of the header.  */

static const gdb_byte *
read_and_check_type_unit_head (struct comp_unit_head *header,
			       struct dwarf2_section_info *section,
			       struct dwarf2_section_info *abbrev_section,
			       const gdb_byte *info_ptr,
			       ULONGEST *signature,
			       cu_offset *type_offset_in_tu)
{
  const gdb_byte *beg_of_comp_unit = info_ptr;
  bfd *abfd = get_section_bfd_owner (section);

  header->offset.sect_off = beg_of_comp_unit - section->buffer;

  info_ptr = read_comp_unit_head (header, info_ptr, abfd);

  /* If we're reading a type unit, skip over the signature and
     type_offset fields.  */
  if (signature != NULL)
    *signature = read_8_bytes (abfd, info_ptr);
  info_ptr += 8;
  if (type_offset_in_tu != NULL)
    type_offset_in_tu->cu_off = read_offset_1 (abfd, info_ptr,
					       header->offset_size);
  info_ptr += header->offset_size;

  header->first_die_offset.cu_off = info_ptr - beg_of_comp_unit;

  error_check_comp_unit_head (header, section, abbrev_section);

  return info_ptr;
}

/* Fetch the abbreviation table offset from a comp or type unit header.  */

static sect_offset
read_abbrev_offset (struct dwarf2_section_info *section,
		    sect_offset offset)
{
  bfd *abfd = get_section_bfd_owner (section);
  const gdb_byte *info_ptr;
  unsigned int length, initial_length_size, offset_size;
  sect_offset abbrev_offset;

  dwarf2_read_section (dwarf2_per_objfile->objfile, section);
  info_ptr = section->buffer + offset.sect_off;
  length = read_initial_length (abfd, info_ptr, &initial_length_size);
  offset_size = initial_length_size == 4 ? 4 : 8;
  info_ptr += initial_length_size + 2 /*version*/;
  abbrev_offset.sect_off = read_offset_1 (abfd, info_ptr, offset_size);
  return abbrev_offset;
}

/* Allocate a new partial symtab for file named NAME and mark this new
   partial symtab as being an include of PST.  */

static void
dwarf2_create_include_psymtab (const char *name, struct partial_symtab *pst,
                               struct objfile *objfile)
{
  struct partial_symtab *subpst = allocate_psymtab (name, objfile);

  if (!IS_ABSOLUTE_PATH (subpst->filename))
    {
      /* It shares objfile->objfile_obstack.  */
      subpst->dirname = pst->dirname;
    }

  subpst->section_offsets = pst->section_offsets;
  subpst->textlow = 0;
  subpst->texthigh = 0;

  subpst->dependencies = (struct partial_symtab **)
    obstack_alloc (&objfile->objfile_obstack,
                   sizeof (struct partial_symtab *));
  subpst->dependencies[0] = pst;
  subpst->number_of_dependencies = 1;

  subpst->globals_offset = 0;
  subpst->n_global_syms = 0;
  subpst->statics_offset = 0;
  subpst->n_static_syms = 0;
  subpst->symtab = NULL;
  subpst->read_symtab = pst->read_symtab;
  subpst->readin = 0;

  /* No private part is necessary for include psymtabs.  This property
     can be used to differentiate between such include psymtabs and
     the regular ones.  */
  subpst->read_symtab_private = NULL;
}

/* Read the Line Number Program data and extract the list of files
   included by the source file represented by PST.  Build an include
   partial symtab for each of these included files.  */

static void
dwarf2_build_include_psymtabs (struct dwarf2_cu *cu,
			       struct die_info *die,
			       struct partial_symtab *pst)
{
  struct line_header *lh = NULL;
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_stmt_list, cu);
  if (attr)
    lh = dwarf_decode_line_header (DW_UNSND (attr), cu);
  if (lh == NULL)
    return;  /* No linetable, so no includes.  */

  /* NOTE: pst->dirname is DW_AT_comp_dir (if present).  */
  dwarf_decode_lines (lh, pst->dirname, cu, pst, 1);

  free_line_header (lh);
}

static hashval_t
hash_signatured_type (const void *item)
{
  const struct signatured_type *sig_type = item;

  /* This drops the top 32 bits of the signature, but is ok for a hash.  */
  return sig_type->signature;
}

static int
eq_signatured_type (const void *item_lhs, const void *item_rhs)
{
  const struct signatured_type *lhs = item_lhs;
  const struct signatured_type *rhs = item_rhs;

  return lhs->signature == rhs->signature;
}

/* Allocate a hash table for signatured types.  */

static htab_t
allocate_signatured_type_table (struct objfile *objfile)
{
  return htab_create_alloc_ex (41,
			       hash_signatured_type,
			       eq_signatured_type,
			       NULL,
			       &objfile->objfile_obstack,
			       hashtab_obstack_allocate,
			       dummy_obstack_deallocate);
}

/* A helper function to add a signatured type CU to a table.  */

static int
add_signatured_type_cu_to_table (void **slot, void *datum)
{
  struct signatured_type *sigt = *slot;
  struct signatured_type ***datap = datum;

  **datap = sigt;
  ++*datap;

  return 1;
}

/* Create the hash table of all entries in the .debug_types
   (or .debug_types.dwo) section(s).
   If reading a DWO file, then DWO_FILE is a pointer to the DWO file object,
   otherwise it is NULL.

   The result is a pointer to the hash table or NULL if there are no types.

   Note: This function processes DWO files only, not DWP files.  */

static htab_t
create_debug_types_hash_table (struct dwo_file *dwo_file,
			       VEC (dwarf2_section_info_def) *types)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  htab_t types_htab = NULL;
  int ix;
  struct dwarf2_section_info *section;
  struct dwarf2_section_info *abbrev_section;

  if (VEC_empty (dwarf2_section_info_def, types))
    return NULL;

  abbrev_section = (dwo_file != NULL
		    ? &dwo_file->sections.abbrev
		    : &dwarf2_per_objfile->abbrev);

  if (dwarf2_read_debug)
    fprintf_unfiltered (gdb_stdlog, "Reading .debug_types%s for %s:\n",
			dwo_file ? ".dwo" : "",
			get_section_file_name (abbrev_section));

  for (ix = 0;
       VEC_iterate (dwarf2_section_info_def, types, ix, section);
       ++ix)
    {
      bfd *abfd;
      const gdb_byte *info_ptr, *end_ptr;

      dwarf2_read_section (objfile, section);
      info_ptr = section->buffer;

      if (info_ptr == NULL)
	continue;

      /* We can't set abfd until now because the section may be empty or
	 not present, in which case the bfd is unknown.  */
      abfd = get_section_bfd_owner (section);

      /* We don't use init_cutu_and_read_dies_simple, or some such, here
	 because we don't need to read any dies: the signature is in the
	 header.  */

      end_ptr = info_ptr + section->size;
      while (info_ptr < end_ptr)
	{
	  sect_offset offset;
	  cu_offset type_offset_in_tu;
	  ULONGEST signature;
	  struct signatured_type *sig_type;
	  struct dwo_unit *dwo_tu;
	  void **slot;
	  const gdb_byte *ptr = info_ptr;
	  struct comp_unit_head header;
	  unsigned int length;

	  offset.sect_off = ptr - section->buffer;

	  /* We need to read the type's signature in order to build the hash
	     table, but we don't need anything else just yet.  */

	  ptr = read_and_check_type_unit_head (&header, section,
					       abbrev_section, ptr,
					       &signature, &type_offset_in_tu);

	  length = get_cu_length (&header);

	  /* Skip dummy type units.  */
	  if (ptr >= info_ptr + length
	      || peek_abbrev_code (abfd, ptr) == 0)
	    {
	      info_ptr += length;
	      continue;
	    }

	  if (types_htab == NULL)
	    {
	      if (dwo_file)
		types_htab = allocate_dwo_unit_table (objfile);
	      else
		types_htab = allocate_signatured_type_table (objfile);
	    }

	  if (dwo_file)
	    {
	      sig_type = NULL;
	      dwo_tu = OBSTACK_ZALLOC (&objfile->objfile_obstack,
				       struct dwo_unit);
	      dwo_tu->dwo_file = dwo_file;
	      dwo_tu->signature = signature;
	      dwo_tu->type_offset_in_tu = type_offset_in_tu;
	      dwo_tu->section = section;
	      dwo_tu->offset = offset;
	      dwo_tu->length = length;
	    }
	  else
	    {
	      /* N.B.: type_offset is not usable if this type uses a DWO file.
		 The real type_offset is in the DWO file.  */
	      dwo_tu = NULL;
	      sig_type = OBSTACK_ZALLOC (&objfile->objfile_obstack,
					 struct signatured_type);
	      sig_type->signature = signature;
	      sig_type->type_offset_in_tu = type_offset_in_tu;
	      sig_type->per_cu.objfile = objfile;
	      sig_type->per_cu.is_debug_types = 1;
	      sig_type->per_cu.section = section;
	      sig_type->per_cu.offset = offset;
	      sig_type->per_cu.length = length;
	    }

	  slot = htab_find_slot (types_htab,
				 dwo_file ? (void*) dwo_tu : (void *) sig_type,
				 INSERT);
	  gdb_assert (slot != NULL);
	  if (*slot != NULL)
	    {
	      sect_offset dup_offset;

	      if (dwo_file)
		{
		  const struct dwo_unit *dup_tu = *slot;

		  dup_offset = dup_tu->offset;
		}
	      else
		{
		  const struct signatured_type *dup_tu = *slot;

		  dup_offset = dup_tu->per_cu.offset;
		}

	      complaint (&symfile_complaints,
			 _("debug type entry at offset 0x%x is duplicate to"
			   " the entry at offset 0x%x, signature %s"),
			 offset.sect_off, dup_offset.sect_off,
			 hex_string (signature));
	    }
	  *slot = dwo_file ? (void *) dwo_tu : (void *) sig_type;

	  if (dwarf2_read_debug)
	    fprintf_unfiltered (gdb_stdlog, "  offset 0x%x, signature %s\n",
				offset.sect_off,
				hex_string (signature));

	  info_ptr += length;
	}
    }

  return types_htab;
}

/* Create the hash table of all entries in the .debug_types section,
   and initialize all_type_units.
   The result is zero if there is an error (e.g. missing .debug_types section),
   otherwise non-zero.	*/

static int
create_all_type_units (struct objfile *objfile)
{
  htab_t types_htab;
  struct signatured_type **iter;

  types_htab = create_debug_types_hash_table (NULL, dwarf2_per_objfile->types);
  if (types_htab == NULL)
    {
      dwarf2_per_objfile->signatured_types = NULL;
      return 0;
    }

  dwarf2_per_objfile->signatured_types = types_htab;

  dwarf2_per_objfile->n_type_units = htab_elements (types_htab);
  dwarf2_per_objfile->all_type_units
    = xmalloc (dwarf2_per_objfile->n_type_units
	       * sizeof (struct signatured_type *));
  iter = &dwarf2_per_objfile->all_type_units[0];
  htab_traverse_noresize (types_htab, add_signatured_type_cu_to_table, &iter);
  gdb_assert (iter - &dwarf2_per_objfile->all_type_units[0]
	      == dwarf2_per_objfile->n_type_units);

  return 1;
}

/* Subroutine of lookup_dwo_signatured_type and lookup_dwp_signatured_type.
   Fill in SIG_ENTRY with DWO_ENTRY.  */

static void
fill_in_sig_entry_from_dwo_entry (struct objfile *objfile,
				  struct signatured_type *sig_entry,
				  struct dwo_unit *dwo_entry)
{
  /* Make sure we're not clobbering something we don't expect to.  */
  gdb_assert (! sig_entry->per_cu.queued);
  gdb_assert (sig_entry->per_cu.cu == NULL);
  gdb_assert (sig_entry->per_cu.v.quick != NULL);
  gdb_assert (sig_entry->per_cu.v.quick->symtab == NULL);
  gdb_assert (sig_entry->signature == dwo_entry->signature);
  gdb_assert (sig_entry->type_offset_in_section.sect_off == 0);
  gdb_assert (sig_entry->type_unit_group == NULL);
  gdb_assert (sig_entry->dwo_unit == NULL);

  sig_entry->per_cu.section = dwo_entry->section;
  sig_entry->per_cu.offset = dwo_entry->offset;
  sig_entry->per_cu.length = dwo_entry->length;
  sig_entry->per_cu.reading_dwo_directly = 1;
  sig_entry->per_cu.objfile = objfile;
  sig_entry->type_offset_in_tu = dwo_entry->type_offset_in_tu;
  sig_entry->dwo_unit = dwo_entry;
}

/* Subroutine of lookup_signatured_type.
   If we haven't read the TU yet, create the signatured_type data structure
   for a TU to be read in directly from a DWO file, bypassing the stub.
   This is the "Stay in DWO Optimization": When there is no DWP file and we're
   using .gdb_index, then when reading a CU we want to stay in the DWO file
   containing that CU.  Otherwise we could end up reading several other DWO
   files (due to comdat folding) to process the transitive closure of all the
   mentioned TUs, and that can be slow.  The current DWO file will have every
   type signature that it needs.
   We only do this for .gdb_index because in the psymtab case we already have
   to read all the DWOs to build the type unit groups.  */

static struct signatured_type *
lookup_dwo_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwo_file *dwo_file;
  struct dwo_unit find_dwo_entry, *dwo_entry;
  struct signatured_type find_sig_entry, *sig_entry;

  gdb_assert (cu->dwo_unit && dwarf2_per_objfile->using_index);

  /* Note: cu->dwo_unit is the dwo_unit that references this TU, not the
     dwo_unit of the TU itself.  */
  dwo_file = cu->dwo_unit->dwo_file;

  /* We only ever need to read in one copy of a signatured type.
     Just use the global signatured_types array.  If this is the first time
     we're reading this type, replace the recorded data from .gdb_index with
     this TU.  */

  if (dwarf2_per_objfile->signatured_types == NULL)
    return NULL;
  find_sig_entry.signature = sig;
  sig_entry = htab_find (dwarf2_per_objfile->signatured_types, &find_sig_entry);
  if (sig_entry == NULL)
    return NULL;

  /* We can get here with the TU already read, *or* in the process of being
     read.  Don't reassign it if that's the case.  Also note that if the TU is
     already being read, it may not have come from a DWO, the program may be
     a mix of Fission-compiled code and non-Fission-compiled code.  */
  /* Have we already tried to read this TU?  */
  if (sig_entry->per_cu.tu_read)
    return sig_entry;

  /* Ok, this is the first time we're reading this TU.  */
  if (dwo_file->tus == NULL)
    return NULL;
  find_dwo_entry.signature = sig;
  dwo_entry = htab_find (dwo_file->tus, &find_dwo_entry);
  if (dwo_entry == NULL)
    return NULL;

  fill_in_sig_entry_from_dwo_entry (objfile, sig_entry, dwo_entry);
  sig_entry->per_cu.tu_read = 1;
  return sig_entry;
}

/* Subroutine of lookup_dwp_signatured_type.
   Add an entry for signature SIG to dwarf2_per_objfile->signatured_types.  */

static struct signatured_type *
add_type_unit (ULONGEST sig)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  int n_type_units = dwarf2_per_objfile->n_type_units;
  struct signatured_type *sig_type;
  void **slot;

  ++n_type_units;
  dwarf2_per_objfile->all_type_units =
    xrealloc (dwarf2_per_objfile->all_type_units,
	      n_type_units * sizeof (struct signatured_type *));
  dwarf2_per_objfile->n_type_units = n_type_units;
  sig_type = OBSTACK_ZALLOC (&objfile->objfile_obstack,
			     struct signatured_type);
  dwarf2_per_objfile->all_type_units[n_type_units - 1] = sig_type;
  sig_type->signature = sig;
  sig_type->per_cu.is_debug_types = 1;
  sig_type->per_cu.v.quick =
    OBSTACK_ZALLOC (&objfile->objfile_obstack,
		    struct dwarf2_per_cu_quick_data);
  slot = htab_find_slot (dwarf2_per_objfile->signatured_types,
			 sig_type, INSERT);
  gdb_assert (*slot == NULL);
  *slot = sig_type;
  /* The rest of sig_type must be filled in by the caller.  */
  return sig_type;
}

/* Subroutine of lookup_signatured_type.
   Look up the type for signature SIG, and if we can't find SIG in .gdb_index
   then try the DWP file.
   Normally this "can't happen", but if there's a bug in signature
   generation and/or the DWP file is built incorrectly, it can happen.
   Using the type directly from the DWP file means we don't have the stub
   which has some useful attributes (e.g., DW_AT_comp_dir), but they're
   not critical.  [Eventually the stub may go away for type units anyway.]  */

static struct signatured_type *
lookup_dwp_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwp_file *dwp_file = get_dwp_file ();
  struct dwo_unit *dwo_entry;
  struct signatured_type find_sig_entry, *sig_entry;

  gdb_assert (cu->dwo_unit && dwarf2_per_objfile->using_index);
  gdb_assert (dwp_file != NULL);

  if (dwarf2_per_objfile->signatured_types != NULL)
    {
      find_sig_entry.signature = sig;
      sig_entry = htab_find (dwarf2_per_objfile->signatured_types,
			     &find_sig_entry);
      if (sig_entry != NULL)
	return sig_entry;
    }

  /* This is the "shouldn't happen" case.
     Try the DWP file and hope for the best.  */
  if (dwp_file->tus == NULL)
    return NULL;
  dwo_entry = lookup_dwo_unit_in_dwp (dwp_file, NULL,
				      sig, 1 /* is_debug_types */);
  if (dwo_entry == NULL)
    return NULL;

  sig_entry = add_type_unit (sig);
  fill_in_sig_entry_from_dwo_entry (objfile, sig_entry, dwo_entry);

  /* The caller will signal a complaint if we return NULL.
     Here we don't return NULL but we still want to complain.  */
  complaint (&symfile_complaints,
	     _("Bad type signature %s referenced by %s at 0x%x,"
	       " coping by using copy in DWP [in module %s]"),
	     hex_string (sig),
	     cu->per_cu->is_debug_types ? "TU" : "CU",
	     cu->per_cu->offset.sect_off,
	     objfile_name (objfile));

  return sig_entry;
}

/* Lookup a signature based type for DW_FORM_ref_sig8.
   Returns NULL if signature SIG is not present in the table.
   It is up to the caller to complain about this.  */

static struct signatured_type *
lookup_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)
{
  if (cu->dwo_unit
      && dwarf2_per_objfile->using_index)
    {
      /* We're in a DWO/DWP file, and we're using .gdb_index.
	 These cases require special processing.  */
      if (get_dwp_file () == NULL)
	return lookup_dwo_signatured_type (cu, sig);
      else
	return lookup_dwp_signatured_type (cu, sig);
    }
  else
    {
      struct signatured_type find_entry, *entry;

      if (dwarf2_per_objfile->signatured_types == NULL)
	return NULL;
      find_entry.signature = sig;
      entry = htab_find (dwarf2_per_objfile->signatured_types, &find_entry);
      return entry;
    }
}

/* Low level DIE reading support.  */

/* Initialize a die_reader_specs struct from a dwarf2_cu struct.  */

static void
init_cu_die_reader (struct die_reader_specs *reader,
		    struct dwarf2_cu *cu,
		    struct dwarf2_section_info *section,
		    struct dwo_file *dwo_file)
{
  gdb_assert (section->readin && section->buffer != NULL);
  reader->abfd = get_section_bfd_owner (section);
  reader->cu = cu;
  reader->dwo_file = dwo_file;
  reader->die_section = section;
  reader->buffer = section->buffer;
  reader->buffer_end = section->buffer + section->size;
  reader->comp_dir = NULL;
}

/* Subroutine of init_cutu_and_read_dies to simplify it.
   Read in the rest of a CU/TU top level DIE from DWO_UNIT.
   There's just a lot of work to do, and init_cutu_and_read_dies is big enough
   already.

   STUB_COMP_UNIT_DIE is for the stub DIE, we copy over certain attributes
   from it to the DIE in the DWO.  If NULL we are skipping the stub.
   STUB_COMP_DIR is similar to STUB_COMP_UNIT_DIE: When reading a TU directly
   from the DWO file, bypassing the stub, it contains the DW_AT_comp_dir
   attribute of the referencing CU.  Exactly one of STUB_COMP_UNIT_DIE and
   COMP_DIR must be non-NULL.
   *RESULT_READER,*RESULT_INFO_PTR,*RESULT_COMP_UNIT_DIE,*RESULT_HAS_CHILDREN
   are filled in with the info of the DIE from the DWO file.
   ABBREV_TABLE_PROVIDED is non-zero if the caller of init_cutu_and_read_dies
   provided an abbrev table to use.
   The result is non-zero if a valid (non-dummy) DIE was found.  */

static int
read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,
			struct dwo_unit *dwo_unit,
			int abbrev_table_provided,
			struct die_info *stub_comp_unit_die,
			const char *stub_comp_dir,
			struct die_reader_specs *result_reader,
			const gdb_byte **result_info_ptr,
			struct die_info **result_comp_unit_die,
			int *result_has_children)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_cu *cu = this_cu->cu;
  struct dwarf2_section_info *section;
  bfd *abfd;
  const gdb_byte *begin_info_ptr, *info_ptr;
  const char *comp_dir_string;
  ULONGEST signature; /* Or dwo_id.  */
  struct attribute *comp_dir, *stmt_list, *low_pc, *high_pc, *ranges;
  int i,num_extra_attrs;
  struct dwarf2_section_info *dwo_abbrev_section;
  struct attribute *attr;
  struct attribute comp_dir_attr;
  struct die_info *comp_unit_die;

  /* Both can't be provided.  */
  gdb_assert (! (stub_comp_unit_die && stub_comp_dir));

  /* These attributes aren't processed until later:
     DW_AT_stmt_list, DW_AT_low_pc, DW_AT_high_pc, DW_AT_ranges.
     However, the attribute is found in the stub which we won't have later.
     In order to not impose this complication on the rest of the code,
     we read them here and copy them to the DWO CU/TU die.  */

  stmt_list = NULL;
  low_pc = NULL;
  high_pc = NULL;
  ranges = NULL;
  comp_dir = NULL;

  if (stub_comp_unit_die != NULL)
    {
      /* For TUs in DWO files, the DW_AT_stmt_list attribute lives in the
	 DWO file.  */
      if (! this_cu->is_debug_types)
	stmt_list = dwarf2_attr (stub_comp_unit_die, DW_AT_stmt_list, cu);
      low_pc = dwarf2_attr (stub_comp_unit_die, DW_AT_low_pc, cu);
      high_pc = dwarf2_attr (stub_comp_unit_die, DW_AT_high_pc, cu);
      ranges = dwarf2_attr (stub_comp_unit_die, DW_AT_ranges, cu);
      comp_dir = dwarf2_attr (stub_comp_unit_die, DW_AT_comp_dir, cu);

      /* There should be a DW_AT_addr_base attribute here (if needed).
	 We need the value before we can process DW_FORM_GNU_addr_index.  */
      cu->addr_base = 0;
      attr = dwarf2_attr (stub_comp_unit_die, DW_AT_GNU_addr_base, cu);
      if (attr)
	cu->addr_base = DW_UNSND (attr);

      /* There should be a DW_AT_ranges_base attribute here (if needed).
	 We need the value before we can process DW_AT_ranges.  */
      cu->ranges_base = 0;
      attr = dwarf2_attr (stub_comp_unit_die, DW_AT_GNU_ranges_base, cu);
      if (attr)
	cu->ranges_base = DW_UNSND (attr);
    }
  else if (stub_comp_dir != NULL)
    {
      /* Reconstruct the comp_dir attribute to simplify the code below.  */
      comp_dir = (struct attribute *)
	obstack_alloc (&cu->comp_unit_obstack, sizeof (*comp_dir));
      comp_dir->name = DW_AT_comp_dir;
      comp_dir->form = DW_FORM_string;
      DW_STRING_IS_CANONICAL (comp_dir) = 0;
      DW_STRING (comp_dir) = stub_comp_dir;
    }

  /* Set up for reading the DWO CU/TU.  */
  cu->dwo_unit = dwo_unit;
  section = dwo_unit->section;
  dwarf2_read_section (objfile, section);
  abfd = get_section_bfd_owner (section);
  begin_info_ptr = info_ptr = section->buffer + dwo_unit->offset.sect_off;
  dwo_abbrev_section = &dwo_unit->dwo_file->sections.abbrev;
  init_cu_die_reader (result_reader, cu, section, dwo_unit->dwo_file);

  if (this_cu->is_debug_types)
    {
      ULONGEST header_signature;
      cu_offset type_offset_in_tu;
      struct signatured_type *sig_type = (struct signatured_type *) this_cu;

      info_ptr = read_and_check_type_unit_head (&cu->header, section,
						dwo_abbrev_section,
						info_ptr,
						&header_signature,
						&type_offset_in_tu);
      /* This is not an assert because it can be caused by bad debug info.  */
      if (sig_type->signature != header_signature)
	{
	  error (_("Dwarf Error: signature mismatch %s vs %s while reading"
		   " TU at offset 0x%x [in module %s]"),
		 hex_string (sig_type->signature),
		 hex_string (header_signature),
		 dwo_unit->offset.sect_off,
		 bfd_get_filename (abfd));
	}
      gdb_assert (dwo_unit->offset.sect_off == cu->header.offset.sect_off);
      /* For DWOs coming from DWP files, we don't know the CU length
	 nor the type's offset in the TU until now.  */
      dwo_unit->length = get_cu_length (&cu->header);
      dwo_unit->type_offset_in_tu = type_offset_in_tu;

      /* Establish the type offset that can be used to lookup the type.
	 For DWO files, we don't know it until now.  */
      sig_type->type_offset_in_section.sect_off =
	dwo_unit->offset.sect_off + dwo_unit->type_offset_in_tu.cu_off;
    }
  else
    {
      info_ptr = read_and_check_comp_unit_head (&cu->header, section,
						dwo_abbrev_section,
						info_ptr, 0);
      gdb_assert (dwo_unit->offset.sect_off == cu->header.offset.sect_off);
      /* For DWOs coming from DWP files, we don't know the CU length
	 until now.  */
      dwo_unit->length = get_cu_length (&cu->header);
    }

  /* Replace the CU's original abbrev table with the DWO's.
     Reminder: We can't read the abbrev table until we've read the header.  */
  if (abbrev_table_provided)
    {
      /* Don't free the provided abbrev table, the caller of
	 init_cutu_and_read_dies owns it.  */
      dwarf2_read_abbrevs (cu, dwo_abbrev_section);
      /* Ensure the DWO abbrev table gets freed.  */
      make_cleanup (dwarf2_free_abbrev_table, cu);
    }
  else
    {
      dwarf2_free_abbrev_table (cu);
      dwarf2_read_abbrevs (cu, dwo_abbrev_section);
      /* Leave any existing abbrev table cleanup as is.  */
    }

  /* Read in the die, but leave space to copy over the attributes
     from the stub.  This has the benefit of simplifying the rest of
     the code - all the work to maintain the illusion of a single
     DW_TAG_{compile,type}_unit DIE is done here.  */
  num_extra_attrs = ((stmt_list != NULL)
		     + (low_pc != NULL)
		     + (high_pc != NULL)
		     + (ranges != NULL)
		     + (comp_dir != NULL));
  info_ptr = read_full_die_1 (result_reader, result_comp_unit_die, info_ptr,
			      result_has_children, num_extra_attrs);

  /* Copy over the attributes from the stub to the DIE we just read in.  */
  comp_unit_die = *result_comp_unit_die;
  i = comp_unit_die->num_attrs;
  if (stmt_list != NULL)
    comp_unit_die->attrs[i++] = *stmt_list;
  if (low_pc != NULL)
    comp_unit_die->attrs[i++] = *low_pc;
  if (high_pc != NULL)
    comp_unit_die->attrs[i++] = *high_pc;
  if (ranges != NULL)
    comp_unit_die->attrs[i++] = *ranges;
  if (comp_dir != NULL)
    comp_unit_die->attrs[i++] = *comp_dir;
  comp_unit_die->num_attrs += num_extra_attrs;

  if (dwarf2_die_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Read die from %s@@0x%x of %s:\n",
			  get_section_name (section),
			  (unsigned) (begin_info_ptr - section->buffer),
			  bfd_get_filename (abfd));
      dump_die (comp_unit_die, dwarf2_die_debug);
    }

  /* Save the comp_dir attribute.  If there is no DWP file then we'll read
     TUs by skipping the stub and going directly to the entry in the DWO file.
     However, skipping the stub means we won't get DW_AT_comp_dir, so we have
     to get it via circuitous means.  Blech.  */
  if (comp_dir != NULL)
    result_reader->comp_dir = DW_STRING (comp_dir);

  /* Skip dummy compilation units.  */
  if (info_ptr >= begin_info_ptr + dwo_unit->length
      || peek_abbrev_code (abfd, info_ptr) == 0)
    return 0;

  *result_info_ptr = info_ptr;
  return 1;
}

/* Subroutine of init_cutu_and_read_dies to simplify it.
   Look up the DWO unit specified by COMP_UNIT_DIE of THIS_CU.
   Returns NULL if the specified DWO unit cannot be found.  */

static struct dwo_unit *
lookup_dwo_unit (struct dwarf2_per_cu_data *this_cu,
		 struct die_info *comp_unit_die)
{
  struct dwarf2_cu *cu = this_cu->cu;
  struct attribute *attr;
  ULONGEST signature;
  struct dwo_unit *dwo_unit;
  const char *comp_dir, *dwo_name;

  gdb_assert (cu != NULL);

  /* Yeah, we look dwo_name up again, but it simplifies the code.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_dwo_name, cu);
  gdb_assert (attr != NULL);
  dwo_name = DW_STRING (attr);
  comp_dir = NULL;
  attr = dwarf2_attr (comp_unit_die, DW_AT_comp_dir, cu);
  if (attr)
    comp_dir = DW_STRING (attr);

  if (this_cu->is_debug_types)
    {
      struct signatured_type *sig_type;

      /* Since this_cu is the first member of struct signatured_type,
	 we can go from a pointer to one to a pointer to the other.  */
      sig_type = (struct signatured_type *) this_cu;
      signature = sig_type->signature;
      dwo_unit = lookup_dwo_type_unit (sig_type, dwo_name, comp_dir);
    }
  else
    {
      struct attribute *attr;

      attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_dwo_id, cu);
      if (! attr)
	error (_("Dwarf Error: missing dwo_id for dwo_name %s"
		 " [in module %s]"),
	       dwo_name, objfile_name (this_cu->objfile));
      signature = DW_UNSND (attr);
      dwo_unit = lookup_dwo_comp_unit (this_cu, dwo_name, comp_dir,
				       signature);
    }

  return dwo_unit;
}

/* Subroutine of init_cutu_and_read_dies to simplify it.
   Read a TU directly from a DWO file, bypassing the stub.  */

static void
init_tu_and_read_dwo_dies (struct dwarf2_per_cu_data *this_cu, int keep,
			   die_reader_func_ftype *die_reader_func,
			   void *data)
{
  struct dwarf2_cu *cu;
  struct signatured_type *sig_type;
  struct cleanup *cleanups, *free_cu_cleanup;
  struct die_reader_specs reader;
  const gdb_byte *info_ptr;
  struct die_info *comp_unit_die;
  int has_children;

  /* Verify we can do the following downcast, and that we have the
     data we need.  */
  gdb_assert (this_cu->is_debug_types && this_cu->reading_dwo_directly);
  sig_type = (struct signatured_type *) this_cu;
  gdb_assert (sig_type->dwo_unit != NULL);

  cleanups = make_cleanup (null_cleanup, NULL);

  gdb_assert (this_cu->cu == NULL);
  cu = xmalloc (sizeof (*cu));
  init_one_comp_unit (cu, this_cu);
  /* If an error occurs while loading, release our storage.  */
  free_cu_cleanup = make_cleanup (free_heap_comp_unit, cu);

  if (read_cutu_die_from_dwo (this_cu, sig_type->dwo_unit,
			      0 /* abbrev_table_provided */,
			      NULL /* stub_comp_unit_die */,
			      sig_type->dwo_unit->dwo_file->comp_dir,
			      &reader, &info_ptr,
			      &comp_unit_die, &has_children) == 0)
    {
      /* Dummy die.  */
      do_cleanups (cleanups);
      return;
    }

  /* All the "real" work is done here.  */
  die_reader_func (&reader, info_ptr, comp_unit_die, has_children, data);

  /* This duplicates some code in init_cutu_and_read_dies,
     but the alternative is making the latter more complex.
     This function is only for the special case of using DWO files directly:
     no point in overly complicating the general case just to handle this.  */
  if (keep)
    {
      /* We've successfully allocated this compilation unit.  Let our
	 caller clean it up when finished with it.  */
      discard_cleanups (free_cu_cleanup);

      /* We can only discard free_cu_cleanup and all subsequent cleanups.
	 So we have to manually free the abbrev table.  */
      dwarf2_free_abbrev_table (cu);

      /* Link this CU into read_in_chain.  */
      this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = this_cu;
    }
  else
    do_cleanups (free_cu_cleanup);

  do_cleanups (cleanups);
}

/* Initialize a CU (or TU) and read its DIEs.
   If the CU defers to a DWO file, read the DWO file as well.

   ABBREV_TABLE, if non-NULL, is the abbreviation table to use.
   Otherwise the table specified in the comp unit header is read in and used.
   This is an optimization for when we already have the abbrev table.

   If USE_EXISTING_CU is non-zero, and THIS_CU->cu is non-NULL, then use it.
   Otherwise, a new CU is allocated with xmalloc.

   If KEEP is non-zero, then if we allocated a dwarf2_cu we add it to
   read_in_chain.  Otherwise the dwarf2_cu data is freed at the end.

   WARNING: If THIS_CU is a "dummy CU" (used as filler by the incremental
   linker) then DIE_READER_FUNC will not get called.  */

static void
init_cutu_and_read_dies (struct dwarf2_per_cu_data *this_cu,
			 struct abbrev_table *abbrev_table,
			 int use_existing_cu, int keep,
			 die_reader_func_ftype *die_reader_func,
			 void *data)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_section_info *section = this_cu->section;
  bfd *abfd = get_section_bfd_owner (section);
  struct dwarf2_cu *cu;
  const gdb_byte *begin_info_ptr, *info_ptr;
  struct die_reader_specs reader;
  struct die_info *comp_unit_die;
  int has_children;
  struct attribute *attr;
  struct cleanup *cleanups, *free_cu_cleanup = NULL;
  struct signatured_type *sig_type = NULL;
  struct dwarf2_section_info *abbrev_section;
  /* Non-zero if CU currently points to a DWO file and we need to
     reread it.  When this happens we need to reread the skeleton die
     before we can reread the DWO file (this only applies to CUs, not TUs).  */
  int rereading_dwo_cu = 0;

  if (dwarf2_die_debug)
    fprintf_unfiltered (gdb_stdlog, "Reading %s unit at offset 0x%x\n",
			this_cu->is_debug_types ? "type" : "comp",
			this_cu->offset.sect_off);

  if (use_existing_cu)
    gdb_assert (keep);

  /* If we're reading a TU directly from a DWO file, including a virtual DWO
     file (instead of going through the stub), short-circuit all of this.  */
  if (this_cu->reading_dwo_directly)
    {
      /* Narrow down the scope of possibilities to have to understand.  */
      gdb_assert (this_cu->is_debug_types);
      gdb_assert (abbrev_table == NULL);
      gdb_assert (!use_existing_cu);
      init_tu_and_read_dwo_dies (this_cu, keep, die_reader_func, data);
      return;
    }

  cleanups = make_cleanup (null_cleanup, NULL);

  /* This is cheap if the section is already read in.  */
  dwarf2_read_section (objfile, section);

  begin_info_ptr = info_ptr = section->buffer + this_cu->offset.sect_off;

  abbrev_section = get_abbrev_section_for_cu (this_cu);

  if (use_existing_cu && this_cu->cu != NULL)
    {
      cu = this_cu->cu;

      /* If this CU is from a DWO file we need to start over, we need to
	 refetch the attributes from the skeleton CU.
	 This could be optimized by retrieving those attributes from when we
	 were here the first time: the previous comp_unit_die was stored in
	 comp_unit_obstack.  But there's no data yet that we need this
	 optimization.  */
      if (cu->dwo_unit != NULL)
	rereading_dwo_cu = 1;
    }
  else
    {
      /* If !use_existing_cu, this_cu->cu must be NULL.  */
      gdb_assert (this_cu->cu == NULL);

      cu = xmalloc (sizeof (*cu));
      init_one_comp_unit (cu, this_cu);

      /* If an error occurs while loading, release our storage.  */
      free_cu_cleanup = make_cleanup (free_heap_comp_unit, cu);
    }

  /* Get the header.  */
  if (cu->header.first_die_offset.cu_off != 0 && ! rereading_dwo_cu)
    {
      /* We already have the header, there's no need to read it in again.  */
      info_ptr += cu->header.first_die_offset.cu_off;
    }
  else
    {
      if (this_cu->is_debug_types)
	{
	  ULONGEST signature;
	  cu_offset type_offset_in_tu;

	  info_ptr = read_and_check_type_unit_head (&cu->header, section,
						    abbrev_section, info_ptr,
						    &signature,
						    &type_offset_in_tu);

	  /* Since per_cu is the first member of struct signatured_type,
	     we can go from a pointer to one to a pointer to the other.  */
	  sig_type = (struct signatured_type *) this_cu;
	  gdb_assert (sig_type->signature == signature);
	  gdb_assert (sig_type->type_offset_in_tu.cu_off
		      == type_offset_in_tu.cu_off);
	  gdb_assert (this_cu->offset.sect_off == cu->header.offset.sect_off);

	  /* LENGTH has not been set yet for type units if we're
	     using .gdb_index.  */
	  this_cu->length = get_cu_length (&cu->header);

	  /* Establish the type offset that can be used to lookup the type.  */
	  sig_type->type_offset_in_section.sect_off =
	    this_cu->offset.sect_off + sig_type->type_offset_in_tu.cu_off;
	}
      else
	{
	  info_ptr = read_and_check_comp_unit_head (&cu->header, section,
						    abbrev_section,
						    info_ptr, 0);

	  gdb_assert (this_cu->offset.sect_off == cu->header.offset.sect_off);
	  gdb_assert (this_cu->length == get_cu_length (&cu->header));
	}
    }

  /* Skip dummy compilation units.  */
  if (info_ptr >= begin_info_ptr + this_cu->length
      || peek_abbrev_code (abfd, info_ptr) == 0)
    {
      do_cleanups (cleanups);
      return;
    }

  /* If we don't have them yet, read the abbrevs for this compilation unit.
     And if we need to read them now, make sure they're freed when we're
     done.  Note that it's important that if the CU had an abbrev table
     on entry we don't free it when we're done: Somewhere up the call stack
     it may be in use.  */
  if (abbrev_table != NULL)
    {
      gdb_assert (cu->abbrev_table == NULL);
      gdb_assert (cu->header.abbrev_offset.sect_off
		  == abbrev_table->offset.sect_off);
      cu->abbrev_table = abbrev_table;
    }
  else if (cu->abbrev_table == NULL)
    {
      dwarf2_read_abbrevs (cu, abbrev_section);
      make_cleanup (dwarf2_free_abbrev_table, cu);
    }
  else if (rereading_dwo_cu)
    {
      dwarf2_free_abbrev_table (cu);
      dwarf2_read_abbrevs (cu, abbrev_section);
    }

  /* Read the top level CU/TU die.  */
  init_cu_die_reader (&reader, cu, section, NULL);
  info_ptr = read_full_die (&reader, &comp_unit_die, info_ptr, &has_children);

  /* If we are in a DWO stub, process it and then read in the "real" CU/TU
     from the DWO file.
     Note that if USE_EXISTING_OK != 0, and THIS_CU->cu already contains a
     DWO CU, that this test will fail (the attribute will not be present).  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_dwo_name, cu);
  if (attr)
    {
      struct dwo_unit *dwo_unit;
      struct die_info *dwo_comp_unit_die;

      if (has_children)
	{
	  complaint (&symfile_complaints,
		     _("compilation unit with DW_AT_GNU_dwo_name"
		       " has children (offset 0x%x) [in module %s]"),
		     this_cu->offset.sect_off, bfd_get_filename (abfd));
	}
      dwo_unit = lookup_dwo_unit (this_cu, comp_unit_die);
      if (dwo_unit != NULL)
	{
	  if (read_cutu_die_from_dwo (this_cu, dwo_unit,
				      abbrev_table != NULL,
				      comp_unit_die, NULL,
				      &reader, &info_ptr,
				      &dwo_comp_unit_die, &has_children) == 0)
	    {
	      /* Dummy die.  */
	      do_cleanups (cleanups);
	      return;
	    }
	  comp_unit_die = dwo_comp_unit_die;
	}
      else
	{
	  /* Yikes, we couldn't find the rest of the DIE, we only have
	     the stub.  A complaint has already been logged.  There's
	     not much more we can do except pass on the stub DIE to
	     die_reader_func.  We don't want to throw an error on bad
	     debug info.  */
	}
    }

  /* All of the above is setup for this call.  Yikes.  */
  die_reader_func (&reader, info_ptr, comp_unit_die, has_children, data);

  /* Done, clean up.  */
  if (free_cu_cleanup != NULL)
    {
      if (keep)
	{
	  /* We've successfully allocated this compilation unit.  Let our
	     caller clean it up when finished with it.  */
	  discard_cleanups (free_cu_cleanup);

	  /* We can only discard free_cu_cleanup and all subsequent cleanups.
	     So we have to manually free the abbrev table.  */
	  dwarf2_free_abbrev_table (cu);

	  /* Link this CU into read_in_chain.  */
	  this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
	  dwarf2_per_objfile->read_in_chain = this_cu;
	}
      else
	do_cleanups (free_cu_cleanup);
    }

  do_cleanups (cleanups);
}

/* Read CU/TU THIS_CU in section SECTION,
   but do not follow DW_AT_GNU_dwo_name if present.
   DWOP_FILE, if non-NULL, is the DWO/DWP file to read (the caller is assumed
   to have already done the lookup to find the DWO/DWP file).

   The caller is required to fill in THIS_CU->section, THIS_CU->offset, and
   THIS_CU->is_debug_types, but nothing else.

   We fill in THIS_CU->length.

   WARNING: If THIS_CU is a "dummy CU" (used as filler by the incremental
   linker) then DIE_READER_FUNC will not get called.

   THIS_CU->cu is always freed when done.
   This is done in order to not leave THIS_CU->cu in a state where we have
   to care whether it refers to the "main" CU or the DWO CU.  */

static void
init_cutu_and_read_dies_no_follow (struct dwarf2_per_cu_data *this_cu,
				   struct dwarf2_section_info *abbrev_section,
				   struct dwo_file *dwo_file,
				   die_reader_func_ftype *die_reader_func,
				   void *data)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_section_info *section = this_cu->section;
  bfd *abfd = get_section_bfd_owner (section);
  struct dwarf2_cu cu;
  const gdb_byte *begin_info_ptr, *info_ptr;
  struct die_reader_specs reader;
  struct cleanup *cleanups;
  struct die_info *comp_unit_die;
  int has_children;

  if (dwarf2_die_debug)
    fprintf_unfiltered (gdb_stdlog, "Reading %s unit at offset 0x%x\n",
			this_cu->is_debug_types ? "type" : "comp",
			this_cu->offset.sect_off);

  gdb_assert (this_cu->cu == NULL);

  /* This is cheap if the section is already read in.  */
  dwarf2_read_section (objfile, section);

  init_one_comp_unit (&cu, this_cu);

  cleanups = make_cleanup (free_stack_comp_unit, &cu);

  begin_info_ptr = info_ptr = section->buffer + this_cu->offset.sect_off;
  info_ptr = read_and_check_comp_unit_head (&cu.header, section,
					    abbrev_section, info_ptr,
					    this_cu->is_debug_types);

  this_cu->length = get_cu_length (&cu.header);

  /* Skip dummy compilation units.  */
  if (info_ptr >= begin_info_ptr + this_cu->length
      || peek_abbrev_code (abfd, info_ptr) == 0)
    {
      do_cleanups (cleanups);
      return;
    }

  dwarf2_read_abbrevs (&cu, abbrev_section);
  make_cleanup (dwarf2_free_abbrev_table, &cu);

  init_cu_die_reader (&reader, &cu, section, dwo_file);
  info_ptr = read_full_die (&reader, &comp_unit_die, info_ptr, &has_children);

  die_reader_func (&reader, info_ptr, comp_unit_die, has_children, data);

  do_cleanups (cleanups);
}

/* Read a CU/TU, except that this does not look for DW_AT_GNU_dwo_name and
   does not lookup the specified DWO file.
   This cannot be used to read DWO files.

   THIS_CU->cu is always freed when done.
   This is done in order to not leave THIS_CU->cu in a state where we have
   to care whether it refers to the "main" CU or the DWO CU.
   We can revisit this if the data shows there's a performance issue.  */

static void
init_cutu_and_read_dies_simple (struct dwarf2_per_cu_data *this_cu,
				die_reader_func_ftype *die_reader_func,
				void *data)
{
  init_cutu_and_read_dies_no_follow (this_cu,
				     get_abbrev_section_for_cu (this_cu),
				     NULL,
				     die_reader_func, data);
}

/* Type Unit Groups.

   Type Unit Groups are a way to collapse the set of all TUs (type units) into
   a more manageable set.  The grouping is done by DW_AT_stmt_list entry
   so that all types coming from the same compilation (.o file) are grouped
   together.  A future step could be to put the types in the same symtab as
   the CU the types ultimately came from.  */

static hashval_t
hash_type_unit_group (const void *item)
{
  const struct type_unit_group *tu_group = item;

  return hash_stmt_list_entry (&tu_group->hash);
}

static int
eq_type_unit_group (const void *item_lhs, const void *item_rhs)
{
  const struct type_unit_group *lhs = item_lhs;
  const struct type_unit_group *rhs = item_rhs;

  return eq_stmt_list_entry (&lhs->hash, &rhs->hash);
}

/* Allocate a hash table for type unit groups.  */

static htab_t
allocate_type_unit_groups_table (void)
{
  return htab_create_alloc_ex (3,
			       hash_type_unit_group,
			       eq_type_unit_group,
			       NULL,
			       &dwarf2_per_objfile->objfile->objfile_obstack,
			       hashtab_obstack_allocate,
			       dummy_obstack_deallocate);
}

/* Type units that don't have DW_AT_stmt_list are grouped into their own
   partial symtabs.  We combine several TUs per psymtab to not let the size
   of any one psymtab grow too big.  */
#define NO_STMT_LIST_TYPE_UNIT_PSYMTAB (1 << 31)
#define NO_STMT_LIST_TYPE_UNIT_PSYMTAB_SIZE 10

/* Helper routine for get_type_unit_group.
   Create the type_unit_group object used to hold one or more TUs.  */

static struct type_unit_group *
create_type_unit_group (struct dwarf2_cu *cu, sect_offset line_offset_struct)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_per_cu_data *per_cu;
  struct type_unit_group *tu_group;

  tu_group = OBSTACK_ZALLOC (&objfile->objfile_obstack,
			     struct type_unit_group);
  per_cu = &tu_group->per_cu;
  per_cu->objfile = objfile;

  if (dwarf2_per_objfile->using_index)
    {
      per_cu->v.quick = OBSTACK_ZALLOC (&objfile->objfile_obstack,
					struct dwarf2_per_cu_quick_data);
    }
  else
    {
      unsigned int line_offset = line_offset_struct.sect_off;
      struct partial_symtab *pst;
      char *name;

      /* Give the symtab a useful name for debug purposes.  */
      if ((line_offset & NO_STMT_LIST_TYPE_UNIT_PSYMTAB) != 0)
	name = xstrprintf ("<type_units_%d>",
			   (line_offset & ~NO_STMT_LIST_TYPE_UNIT_PSYMTAB));
      else
	name = xstrprintf ("<type_units_at_0x%x>", line_offset);

      pst = create_partial_symtab (per_cu, name);
      pst->anonymous = 1;

      xfree (name);
    }

  tu_group->hash.dwo_unit = cu->dwo_unit;
  tu_group->hash.line_offset = line_offset_struct;

  return tu_group;
}

/* Look up the type_unit_group for type unit CU, and create it if necessary.
   STMT_LIST is a DW_AT_stmt_list attribute.  */

static struct type_unit_group *
get_type_unit_group (struct dwarf2_cu *cu, const struct attribute *stmt_list)
{
  struct tu_stats *tu_stats = &dwarf2_per_objfile->tu_stats;
  struct type_unit_group *tu_group;
  void **slot;
  unsigned int line_offset;
  struct type_unit_group type_unit_group_for_lookup;

  if (dwarf2_per_objfile->type_unit_groups == NULL)
    {
      dwarf2_per_objfile->type_unit_groups =
	allocate_type_unit_groups_table ();
    }

  /* Do we need to create a new group, or can we use an existing one?  */

  if (stmt_list)
    {
      line_offset = DW_UNSND (stmt_list);
      ++tu_stats->nr_symtab_sharers;
    }
  else
    {
      /* Ugh, no stmt_list.  Rare, but we have to handle it.
	 We can do various things here like create one group per TU or
	 spread them over multiple groups to split up the expansion work.
	 To avoid worst case scenarios (too many groups or too large groups)
	 we, umm, group them in bunches.  */
      line_offset = (NO_STMT_LIST_TYPE_UNIT_PSYMTAB
		     | (tu_stats->nr_stmt_less_type_units
			/ NO_STMT_LIST_TYPE_UNIT_PSYMTAB_SIZE));
      ++tu_stats->nr_stmt_less_type_units;
    }

  type_unit_group_for_lookup.hash.dwo_unit = cu->dwo_unit;
  type_unit_group_for_lookup.hash.line_offset.sect_off = line_offset;
  slot = htab_find_slot (dwarf2_per_objfile->type_unit_groups,
			 &type_unit_group_for_lookup, INSERT);
  if (*slot != NULL)
    {
      tu_group = *slot;
      gdb_assert (tu_group != NULL);
    }
  else
    {
      sect_offset line_offset_struct;

      line_offset_struct.sect_off = line_offset;
      tu_group = create_type_unit_group (cu, line_offset_struct);
      *slot = tu_group;
      ++tu_stats->nr_symtabs;
    }

  return tu_group;
}

/* Struct used to sort TUs by their abbreviation table offset.  */

struct tu_abbrev_offset
{
  struct signatured_type *sig_type;
  sect_offset abbrev_offset;
};

/* Helper routine for build_type_unit_groups, passed to qsort.  */

static int
sort_tu_by_abbrev_offset (const void *ap, const void *bp)
{
  const struct tu_abbrev_offset * const *a = ap;
  const struct tu_abbrev_offset * const *b = bp;
  unsigned int aoff = (*a)->abbrev_offset.sect_off;
  unsigned int boff = (*b)->abbrev_offset.sect_off;

  return (aoff > boff) - (aoff < boff);
}

/* A helper function to add a type_unit_group to a table.  */

static int
add_type_unit_group_to_table (void **slot, void *datum)
{
  struct type_unit_group *tu_group = *slot;
  struct type_unit_group ***datap = datum;

  **datap = tu_group;
  ++*datap;

  return 1;
}

/* Efficiently read all the type units, calling init_cutu_and_read_dies on
   each one passing FUNC,DATA.

   The efficiency is because we sort TUs by the abbrev table they use and
   only read each abbrev table once.  In one program there are 200K TUs
   sharing 8K abbrev tables.

   The main purpose of this function is to support building the
   dwarf2_per_objfile->type_unit_groups table.
   TUs typically share the DW_AT_stmt_list of the CU they came from, so we
   can collapse the search space by grouping them by stmt_list.
   The savings can be significant, in the same program from above the 200K TUs
   share 8K stmt_list tables.

   FUNC is expected to call get_type_unit_group, which will create the
   struct type_unit_group if necessary and add it to
   dwarf2_per_objfile->type_unit_groups.  */

static void
build_type_unit_groups (die_reader_func_ftype *func, void *data)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct tu_stats *tu_stats = &dwarf2_per_objfile->tu_stats;
  struct cleanup *cleanups;
  struct abbrev_table *abbrev_table;
  sect_offset abbrev_offset;
  struct tu_abbrev_offset *sorted_by_abbrev;
  struct type_unit_group **iter;
  int i;

  /* It's up to the caller to not call us multiple times.  */
  gdb_assert (dwarf2_per_objfile->type_unit_groups == NULL);

  if (dwarf2_per_objfile->n_type_units == 0)
    return;

  /* TUs typically share abbrev tables, and there can be way more TUs than
     abbrev tables.  Sort by abbrev table to reduce the number of times we
     read each abbrev table in.
     Alternatives are to punt or to maintain a cache of abbrev tables.
     This is simpler and efficient enough for now.

     Later we group TUs by their DW_AT_stmt_list value (as this defines the
     symtab to use).  Typically TUs with the same abbrev offset have the same
     stmt_list value too so in practice this should work well.

     The basic algorithm here is:

      sort TUs by abbrev table
      for each TU with same abbrev table:
	read abbrev table if first user
	read TU top level DIE
	  [IWBN if DWO skeletons had DW_AT_stmt_list]
	call FUNC  */

  if (dwarf2_read_debug)
    fprintf_unfiltered (gdb_stdlog, "Building type unit groups ...\n");

  /* Sort in a separate table to maintain the order of all_type_units
     for .gdb_index: TU indices directly index all_type_units.  */
  sorted_by_abbrev = XNEWVEC (struct tu_abbrev_offset,
			      dwarf2_per_objfile->n_type_units);
  for (i = 0; i < dwarf2_per_objfile->n_type_units; ++i)
    {
      struct signatured_type *sig_type = dwarf2_per_objfile->all_type_units[i];

      sorted_by_abbrev[i].sig_type = sig_type;
      sorted_by_abbrev[i].abbrev_offset =
	read_abbrev_offset (sig_type->per_cu.section,
			    sig_type->per_cu.offset);
    }
  cleanups = make_cleanup (xfree, sorted_by_abbrev);
  qsort (sorted_by_abbrev, dwarf2_per_objfile->n_type_units,
	 sizeof (struct tu_abbrev_offset), sort_tu_by_abbrev_offset);

  /* Note: In the .gdb_index case, get_type_unit_group may have already been
     called any number of times, so we don't reset tu_stats here.  */

  abbrev_offset.sect_off = ~(unsigned) 0;
  abbrev_table = NULL;
  make_cleanup (abbrev_table_free_cleanup, &abbrev_table);

  for (i = 0; i < dwarf2_per_objfile->n_type_units; ++i)
    {
      const struct tu_abbrev_offset *tu = &sorted_by_abbrev[i];

      /* Switch to the next abbrev table if necessary.  */
      if (abbrev_table == NULL
	  || tu->abbrev_offset.sect_off != abbrev_offset.sect_off)
	{
	  if (abbrev_table != NULL)
	    {
	      abbrev_table_free (abbrev_table);
	      /* Reset to NULL in case abbrev_table_read_table throws
		 an error: abbrev_table_free_cleanup will get called.  */
	      abbrev_table = NULL;
	    }
	  abbrev_offset = tu->abbrev_offset;
	  abbrev_table =
	    abbrev_table_read_table (&dwarf2_per_objfile->abbrev,
				     abbrev_offset);
	  ++tu_stats->nr_uniq_abbrev_tables;
	}

      init_cutu_and_read_dies (&tu->sig_type->per_cu, abbrev_table, 0, 0,
			       func, data);
    }

  /* type_unit_groups can be NULL if there is an error in the debug info.
     Just create an empty table so the rest of gdb doesn't have to watch
     for this error case.  */
  if (dwarf2_per_objfile->type_unit_groups == NULL)
    {
      dwarf2_per_objfile->type_unit_groups =
	allocate_type_unit_groups_table ();
      dwarf2_per_objfile->n_type_unit_groups = 0;
    }

  /* Create a vector of pointers to primary type units to make it easy to
     iterate over them and CUs.  See dw2_get_primary_cu.  */
  dwarf2_per_objfile->n_type_unit_groups =
    htab_elements (dwarf2_per_objfile->type_unit_groups);
  dwarf2_per_objfile->all_type_unit_groups =
    obstack_alloc (&objfile->objfile_obstack,
		   dwarf2_per_objfile->n_type_unit_groups
		   * sizeof (struct type_unit_group *));
  iter = &dwarf2_per_objfile->all_type_unit_groups[0];
  htab_traverse_noresize (dwarf2_per_objfile->type_unit_groups,
			  add_type_unit_group_to_table, &iter);
  gdb_assert (iter - &dwarf2_per_objfile->all_type_unit_groups[0]
	      == dwarf2_per_objfile->n_type_unit_groups);

  do_cleanups (cleanups);

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Done building type unit groups:\n");
      fprintf_unfiltered (gdb_stdlog, "  %d TUs\n",
			  dwarf2_per_objfile->n_type_units);
      fprintf_unfiltered (gdb_stdlog, "  %d uniq abbrev tables\n",
			  tu_stats->nr_uniq_abbrev_tables);
      fprintf_unfiltered (gdb_stdlog, "  %d symtabs from stmt_list entries\n",
			  tu_stats->nr_symtabs);
      fprintf_unfiltered (gdb_stdlog, "  %d symtab sharers\n",
			  tu_stats->nr_symtab_sharers);
      fprintf_unfiltered (gdb_stdlog, "  %d type units without a stmt_list\n",
			  tu_stats->nr_stmt_less_type_units);
    }
}

/* Partial symbol tables.  */

/* Create a psymtab named NAME and assign it to PER_CU.

   The caller must fill in the following details:
   dirname, textlow, texthigh.  */

static struct partial_symtab *
create_partial_symtab (struct dwarf2_per_cu_data *per_cu, const char *name)
{
  struct objfile *objfile = per_cu->objfile;
  struct partial_symtab *pst;

  pst = start_psymtab_common (objfile, objfile->section_offsets,
			      name, 0,
			      objfile->global_psymbols.next,
			      objfile->static_psymbols.next);

  pst->psymtabs_addrmap_supported = 1;

  /* This is the glue that links PST into GDB's symbol API.  */
  pst->read_symtab_private = per_cu;
  pst->read_symtab = dwarf2_read_symtab;
  per_cu->v.psymtab = pst;

  return pst;
}

/* The DATA object passed to process_psymtab_comp_unit_reader has this
   type.  */

struct process_psymtab_comp_unit_data
{
  /* True if we are reading a DW_TAG_partial_unit.  */

  int want_partial_unit;

  /* The "pretend" language that is used if the CU doesn't declare a
     language.  */

  enum language pretend_language;
};

/* die_reader_func for process_psymtab_comp_unit.  */

static void
process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,
				  const gdb_byte *info_ptr,
				  struct die_info *comp_unit_die,
				  int has_children,
				  void *data)
{
  struct dwarf2_cu *cu = reader->cu;
  struct objfile *objfile = cu->objfile;
  struct dwarf2_per_cu_data *per_cu = cu->per_cu;
  struct attribute *attr;
  CORE_ADDR baseaddr;
  CORE_ADDR best_lowpc = 0, best_highpc = 0;
  struct partial_symtab *pst;
  int has_pc_info;
  const char *filename;
  struct process_psymtab_comp_unit_data *info = data;

  if (comp_unit_die->tag == DW_TAG_partial_unit && !info->want_partial_unit)
    return;

  gdb_assert (! per_cu->is_debug_types);

  prepare_one_comp_unit (cu, comp_unit_die, info->pretend_language);

  cu->list_in_scope = &file_symbols;

  /* Allocate a new partial symbol table structure.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_name, cu);
  if (attr == NULL || !DW_STRING (attr))
    filename = "";
  else
    filename = DW_STRING (attr);

  pst = create_partial_symtab (per_cu, filename);

  /* This must be done before calling dwarf2_build_include_psymtabs.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_comp_dir, cu);
  if (attr != NULL)
    pst->dirname = DW_STRING (attr);

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  dwarf2_find_base_address (comp_unit_die, cu);

  /* Possibly set the default values of LOWPC and HIGHPC from
     `DW_AT_ranges'.  */
  has_pc_info = dwarf2_get_pc_bounds (comp_unit_die, &best_lowpc,
				      &best_highpc, cu, pst);
  if (has_pc_info == 1 && best_lowpc < best_highpc)
    /* Store the contiguous range if it is not empty; it can be empty for
       CUs with no code.  */
    addrmap_set_empty (objfile->psymtabs_addrmap,
		       best_lowpc + baseaddr,
		       best_highpc + baseaddr - 1, pst);

  /* Check if comp unit has_children.
     If so, read the rest of the partial symbols from this comp unit.
     If not, there's no more debug_info for this comp unit.  */
  if (has_children)
    {
      struct partial_die_info *first_die;
      CORE_ADDR lowpc, highpc;

      lowpc = ((CORE_ADDR) -1);
      highpc = ((CORE_ADDR) 0);

      first_die = load_partial_dies (reader, info_ptr, 1);

      scan_partial_symbols (first_die, &lowpc, &highpc,
			    ! has_pc_info, cu);

      /* If we didn't find a lowpc, set it to highpc to avoid
	 complaints from `maint check'.	 */
      if (lowpc == ((CORE_ADDR) -1))
	lowpc = highpc;

      /* If the compilation unit didn't have an explicit address range,
	 then use the information extracted from its child dies.  */
      if (! has_pc_info)
	{
	  best_lowpc = lowpc;
	  best_highpc = highpc;
	}
    }
  pst->textlow = best_lowpc + baseaddr;
  pst->texthigh = best_highpc + baseaddr;

  pst->n_global_syms = objfile->global_psymbols.next -
    (objfile->global_psymbols.list + pst->globals_offset);
  pst->n_static_syms = objfile->static_psymbols.next -
    (objfile->static_psymbols.list + pst->statics_offset);
  sort_pst_symbols (objfile, pst);

  if (!VEC_empty (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs))
    {
      int i;
      int len = VEC_length (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs);
      struct dwarf2_per_cu_data *iter;

      /* Fill in 'dependencies' here; we fill in 'users' in a
	 post-pass.  */
      pst->number_of_dependencies = len;
      pst->dependencies = obstack_alloc (&objfile->objfile_obstack,
					 len * sizeof (struct symtab *));
      for (i = 0;
	   VEC_iterate (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs,
			i, iter);
	   ++i)
	pst->dependencies[i] = iter->v.psymtab;

      VEC_free (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs);
    }

  /* Get the list of files included in the current compilation unit,
     and build a psymtab for each of them.  */
  dwarf2_build_include_psymtabs (cu, comp_unit_die, pst);

  if (dwarf2_read_debug)
    {
      struct gdbarch *gdbarch = get_objfile_arch (objfile);

      fprintf_unfiltered (gdb_stdlog,
			  "Psymtab for %s unit @@0x%x: %s - %s"
			  ", %d global, %d static syms\n",
			  per_cu->is_debug_types ? "type" : "comp",
			  per_cu->offset.sect_off,
			  paddress (gdbarch, pst->textlow),
			  paddress (gdbarch, pst->texthigh),
			  pst->n_global_syms, pst->n_static_syms);
    }
}

/* Subroutine of dwarf2_build_psymtabs_hard to simplify it.
   Process compilation unit THIS_CU for a psymtab.  */

static void
process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,
			   int want_partial_unit,
			   enum language pretend_language)
{
  struct process_psymtab_comp_unit_data info;

  /* If this compilation unit was already read in, free the
     cached copy in order to read it in again.	This is
     necessary because we skipped some symbols when we first
     read in the compilation unit (see load_partial_dies).
     This problem could be avoided, but the benefit is unclear.  */
  if (this_cu->cu != NULL)
    free_one_cached_comp_unit (this_cu);

  gdb_assert (! this_cu->is_debug_types);
  info.want_partial_unit = want_partial_unit;
  info.pretend_language = pretend_language;
  init_cutu_and_read_dies (this_cu, NULL, 0, 0,
			   process_psymtab_comp_unit_reader,
			   &info);

  /* Age out any secondary CUs.  */
  age_cached_comp_units ();
}

/* Reader function for build_type_psymtabs.  */

static void
build_type_psymtabs_reader (const struct die_reader_specs *reader,
			    const gdb_byte *info_ptr,
			    struct die_info *type_unit_die,
			    int has_children,
			    void *data)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_cu *cu = reader->cu;
  struct dwarf2_per_cu_data *per_cu = cu->per_cu;
  struct signatured_type *sig_type;
  struct type_unit_group *tu_group;
  struct attribute *attr;
  struct partial_die_info *first_die;
  CORE_ADDR lowpc, highpc;
  struct partial_symtab *pst;

  gdb_assert (data == NULL);
  gdb_assert (per_cu->is_debug_types);
  sig_type = (struct signatured_type *) per_cu;

  if (! has_children)
    return;

  attr = dwarf2_attr_no_follow (type_unit_die, DW_AT_stmt_list);
  tu_group = get_type_unit_group (cu, attr);

  VEC_safe_push (sig_type_ptr, tu_group->tus, sig_type);

  prepare_one_comp_unit (cu, type_unit_die, language_minimal);
  cu->list_in_scope = &file_symbols;
  pst = create_partial_symtab (per_cu, "");
  pst->anonymous = 1;

  first_die = load_partial_dies (reader, info_ptr, 1);

  lowpc = (CORE_ADDR) -1;
  highpc = (CORE_ADDR) 0;
  scan_partial_symbols (first_die, &lowpc, &highpc, 0, cu);

  pst->n_global_syms = objfile->global_psymbols.next -
    (objfile->global_psymbols.list + pst->globals_offset);
  pst->n_static_syms = objfile->static_psymbols.next -
    (objfile->static_psymbols.list + pst->statics_offset);
  sort_pst_symbols (objfile, pst);
}

/* Traversal function for build_type_psymtabs.  */

static int
build_type_psymtab_dependencies (void **slot, void *info)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct type_unit_group *tu_group = (struct type_unit_group *) *slot;
  struct dwarf2_per_cu_data *per_cu = &tu_group->per_cu;
  struct partial_symtab *pst = per_cu->v.psymtab;
  int len = VEC_length (sig_type_ptr, tu_group->tus);
  struct signatured_type *iter;
  int i;

  gdb_assert (len > 0);
  gdb_assert (IS_TYPE_UNIT_GROUP (per_cu));

  pst->number_of_dependencies = len;
  pst->dependencies = obstack_alloc (&objfile->objfile_obstack,
				     len * sizeof (struct psymtab *));
  for (i = 0;
       VEC_iterate (sig_type_ptr, tu_group->tus, i, iter);
       ++i)
    {
      gdb_assert (iter->per_cu.is_debug_types);
      pst->dependencies[i] = iter->per_cu.v.psymtab;
      iter->type_unit_group = tu_group;
    }

  VEC_free (sig_type_ptr, tu_group->tus);

  return 1;
}

/* Subroutine of dwarf2_build_psymtabs_hard to simplify it.
   Build partial symbol tables for the .debug_types comp-units.  */

static void
build_type_psymtabs (struct objfile *objfile)
{
  if (! create_all_type_units (objfile))
    return;

  build_type_unit_groups (build_type_psymtabs_reader, NULL);

  /* Now that all TUs have been processed we can fill in the dependencies.  */
  htab_traverse_noresize (dwarf2_per_objfile->type_unit_groups,
			  build_type_psymtab_dependencies, NULL);
}

/* A cleanup function that clears objfile's psymtabs_addrmap field.  */

static void
psymtabs_addrmap_cleanup (void *o)
{
  struct objfile *objfile = o;

  objfile->psymtabs_addrmap = NULL;
}

/* Compute the 'user' field for each psymtab in OBJFILE.  */

static void
set_partial_user (struct objfile *objfile)
{
  int i;

  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
    {
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
      struct partial_symtab *pst = per_cu->v.psymtab;
      int j;

      if (pst == NULL)
	continue;

      for (j = 0; j < pst->number_of_dependencies; ++j)
	{
	  /* Set the 'user' field only if it is not already set.  */
	  if (pst->dependencies[j]->user == NULL)
	    pst->dependencies[j]->user = pst;
	}
    }
}

/* Build the partial symbol table by doing a quick pass through the
   .debug_info and .debug_abbrev sections.  */

static void
dwarf2_build_psymtabs_hard (struct objfile *objfile)
{
  struct cleanup *back_to, *addrmap_cleanup;
  struct obstack temp_obstack;
  int i;

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Building psymtabs of objfile %s ...\n",
			  objfile_name (objfile));
    }

  dwarf2_per_objfile->reading_partial_symbols = 1;

  dwarf2_read_section (objfile, &dwarf2_per_objfile->info);

  /* Any cached compilation units will be linked by the per-objfile
     read_in_chain.  Make sure to free them when we're done.  */
  back_to = make_cleanup (free_cached_comp_units, NULL);

  build_type_psymtabs (objfile);

  create_all_comp_units (objfile);

  /* Create a temporary address map on a temporary obstack.  We later
     copy this to the final obstack.  */
  obstack_init (&temp_obstack);
  make_cleanup_obstack_free (&temp_obstack);
  objfile->psymtabs_addrmap = addrmap_create_mutable (&temp_obstack);
  addrmap_cleanup = make_cleanup (psymtabs_addrmap_cleanup, objfile);

  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
    {
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);

      process_psymtab_comp_unit (per_cu, 0, language_minimal);
    }

  set_partial_user (objfile);

  objfile->psymtabs_addrmap = addrmap_create_fixed (objfile->psymtabs_addrmap,
						    &objfile->objfile_obstack);
  discard_cleanups (addrmap_cleanup);

  do_cleanups (back_to);

  if (dwarf2_read_debug)
    fprintf_unfiltered (gdb_stdlog, "Done building psymtabs of %s\n",
			objfile_name (objfile));
}

/* die_reader_func for load_partial_comp_unit.  */

static void
load_partial_comp_unit_reader (const struct die_reader_specs *reader,
			       const gdb_byte *info_ptr,
			       struct die_info *comp_unit_die,
			       int has_children,
			       void *data)
{
  struct dwarf2_cu *cu = reader->cu;

  prepare_one_comp_unit (cu, comp_unit_die, language_minimal);

  /* Check if comp unit has_children.
     If so, read the rest of the partial symbols from this comp unit.
     If not, there's no more debug_info for this comp unit.  */
  if (has_children)
    load_partial_dies (reader, info_ptr, 0);
}

/* Load the partial DIEs for a secondary CU into memory.
   This is also used when rereading a primary CU with load_all_dies.  */

static void
load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu)
{
  init_cutu_and_read_dies (this_cu, NULL, 1, 1,
			   load_partial_comp_unit_reader, NULL);
}

static void
read_comp_units_from_section (struct objfile *objfile,
			      struct dwarf2_section_info *section,
			      unsigned int is_dwz,
			      int *n_allocated,
			      int *n_comp_units,
			      struct dwarf2_per_cu_data ***all_comp_units)
{
  const gdb_byte *info_ptr;
  bfd *abfd = get_section_bfd_owner (section);

  if (dwarf2_read_debug)
    fprintf_unfiltered (gdb_stdlog, "Reading %s for %s\n",
			get_section_name (section),
			get_section_file_name (section));

  dwarf2_read_section (objfile, section);

  info_ptr = section->buffer;

  while (info_ptr < section->buffer + section->size)
    {
      unsigned int length, initial_length_size;
      struct dwarf2_per_cu_data *this_cu;
      sect_offset offset;

      offset.sect_off = info_ptr - section->buffer;

      /* Read just enough information to find out where the next
	 compilation unit is.  */
      length = read_initial_length (abfd, info_ptr, &initial_length_size);

      /* Save the compilation unit for later lookup.  */
      this_cu = obstack_alloc (&objfile->objfile_obstack,
			       sizeof (struct dwarf2_per_cu_data));
      memset (this_cu, 0, sizeof (*this_cu));
      this_cu->offset = offset;
      this_cu->length = length + initial_length_size;
      this_cu->is_dwz = is_dwz;
      this_cu->objfile = objfile;
      this_cu->section = section;

      if (*n_comp_units == *n_allocated)
	{
	  *n_allocated *= 2;
	  *all_comp_units = xrealloc (*all_comp_units,
				      *n_allocated
				      * sizeof (struct dwarf2_per_cu_data *));
	}
      (*all_comp_units)[*n_comp_units] = this_cu;
      ++*n_comp_units;

      info_ptr = info_ptr + this_cu->length;
    }
}

/* Create a list of all compilation units in OBJFILE.
   This is only done for -readnow and building partial symtabs.  */

static void
create_all_comp_units (struct objfile *objfile)
{
  int n_allocated;
  int n_comp_units;
  struct dwarf2_per_cu_data **all_comp_units;
  struct dwz_file *dwz;

  n_comp_units = 0;
  n_allocated = 10;
  all_comp_units = xmalloc (n_allocated
			    * sizeof (struct dwarf2_per_cu_data *));

  read_comp_units_from_section (objfile, &dwarf2_per_objfile->info, 0,
				&n_allocated, &n_comp_units, &all_comp_units);

  dwz = dwarf2_get_dwz_file ();
  if (dwz != NULL)
    read_comp_units_from_section (objfile, &dwz->info, 1,
				  &n_allocated, &n_comp_units,
				  &all_comp_units);

  dwarf2_per_objfile->all_comp_units
    = obstack_alloc (&objfile->objfile_obstack,
		     n_comp_units * sizeof (struct dwarf2_per_cu_data *));
  memcpy (dwarf2_per_objfile->all_comp_units, all_comp_units,
	  n_comp_units * sizeof (struct dwarf2_per_cu_data *));
  xfree (all_comp_units);
  dwarf2_per_objfile->n_comp_units = n_comp_units;
}

/* Process all loaded DIEs for compilation unit CU, starting at
   FIRST_DIE.  The caller should pass NEED_PC == 1 if the compilation
   unit DIE did not have PC info (DW_AT_low_pc and DW_AT_high_pc, or
   DW_AT_ranges).  If NEED_PC is set, then this function will set
   *LOWPC and *HIGHPC to the lowest and highest PC values found in CU
   and record the covered ranges in the addrmap.  */

static void
scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,
		      CORE_ADDR *highpc, int need_pc, struct dwarf2_cu *cu)
{
  struct partial_die_info *pdi;

  /* Now, march along the PDI's, descending into ones which have
     interesting children but skipping the children of the other ones,
     until we reach the end of the compilation unit.  */

  pdi = first_die;

  while (pdi != NULL)
    {
      fixup_partial_die (pdi, cu);

      /* Anonymous namespaces or modules have no name but have interesting
	 children, so we need to look at them.  Ditto for anonymous
	 enums.  */

      if (pdi->name != NULL || pdi->tag == DW_TAG_namespace
	  || pdi->tag == DW_TAG_module || pdi->tag == DW_TAG_enumeration_type
	  || pdi->tag == DW_TAG_imported_unit)
	{
	  switch (pdi->tag)
	    {
	    case DW_TAG_subprogram:
	      add_partial_subprogram (pdi, lowpc, highpc, need_pc, cu);
	      break;
	    case DW_TAG_constant:
	    case DW_TAG_variable:
	    case DW_TAG_typedef:
	    case DW_TAG_union_type:
	      if (!pdi->is_declaration)
		{
		  add_partial_symbol (pdi, cu);
		}
	      break;
	    case DW_TAG_class_type:
	    case DW_TAG_interface_type:
	    case DW_TAG_structure_type:
	      if (!pdi->is_declaration)
		{
		  add_partial_symbol (pdi, cu);
		}
	      break;
	    case DW_TAG_enumeration_type:
	      if (!pdi->is_declaration)
		add_partial_enumeration (pdi, cu);
	      break;
	    case DW_TAG_base_type:
            case DW_TAG_subrange_type:
	      /* File scope base type definitions are added to the partial
	         symbol table.  */
	      add_partial_symbol (pdi, cu);
	      break;
	    case DW_TAG_namespace:
	      add_partial_namespace (pdi, lowpc, highpc, need_pc, cu);
	      break;
	    case DW_TAG_module:
	      add_partial_module (pdi, lowpc, highpc, need_pc, cu);
	      break;
	    case DW_TAG_imported_unit:
	      {
		struct dwarf2_per_cu_data *per_cu;

		/* For now we don't handle imported units in type units.  */
		if (cu->per_cu->is_debug_types)
		  {
		    error (_("Dwarf Error: DW_TAG_imported_unit is not"
			     " supported in type units [in module %s]"),
			   objfile_name (cu->objfile));
		  }

		per_cu = dwarf2_find_containing_comp_unit (pdi->d.offset,
							   pdi->is_dwz,
							   cu->objfile);

		/* Go read the partial unit, if needed.  */
		if (per_cu->v.psymtab == NULL)
		  process_psymtab_comp_unit (per_cu, 1, cu->language);

		VEC_safe_push (dwarf2_per_cu_ptr,
			       cu->per_cu->imported_symtabs, per_cu);
	      }
	      break;
	    default:
	      break;
	    }
	}

      /* If the die has a sibling, skip to the sibling.  */

      pdi = pdi->die_sibling;
    }
}

/* Functions used to compute the fully scoped name of a partial DIE.

   Normally, this is simple.  For C++, the parent DIE's fully scoped
   name is concatenated with "::" and the partial DIE's name.  For
   Java, the same thing occurs except that "." is used instead of "::".
   Enumerators are an exception; they use the scope of their parent
   enumeration type, i.e. the name of the enumeration type is not
   prepended to the enumerator.

   There are two complexities.  One is DW_AT_specification; in this
   case "parent" means the parent of the target of the specification,
   instead of the direct parent of the DIE.  The other is compilers
   which do not emit DW_TAG_namespace; in this case we try to guess
   the fully qualified name of structure types from their members'
   linkage names.  This must be done using the DIE's children rather
   than the children of any DW_AT_specification target.  We only need
   to do this for structures at the top level, i.e. if the target of
   any DW_AT_specification (if any; otherwise the DIE itself) does not
   have a parent.  */

/* Compute the scope prefix associated with PDI's parent, in
   compilation unit CU.  The result will be allocated on CU's
   comp_unit_obstack, or a copy of the already allocated PDI->NAME
   field.  NULL is returned if no prefix is necessary.  */
static const char *
partial_die_parent_scope (struct partial_die_info *pdi,
			  struct dwarf2_cu *cu)
{
  const char *grandparent_scope;
  struct partial_die_info *parent, *real_pdi;

  /* We need to look at our parent DIE; if we have a DW_AT_specification,
     then this means the parent of the specification DIE.  */

  real_pdi = pdi;
  while (real_pdi->has_specification)
    real_pdi = find_partial_die (real_pdi->spec_offset,
				 real_pdi->spec_is_dwz, cu);

  parent = real_pdi->die_parent;
  if (parent == NULL)
    return NULL;

  if (parent->scope_set)
    return parent->scope;

  fixup_partial_die (parent, cu);

  grandparent_scope = partial_die_parent_scope (parent, cu);

  /* GCC 4.0 and 4.1 had a bug (PR c++/28460) where they generated bogus
     DW_TAG_namespace DIEs with a name of "::" for the global namespace.
     Work around this problem here.  */
  if (cu->language == language_cplus
      && parent->tag == DW_TAG_namespace
      && strcmp (parent->name, "::") == 0
      && grandparent_scope == NULL)
    {
      parent->scope = NULL;
      parent->scope_set = 1;
      return NULL;
    }

  if (pdi->tag == DW_TAG_enumerator)
    /* Enumerators should not get the name of the enumeration as a prefix.  */
    parent->scope = grandparent_scope;
  else if (parent->tag == DW_TAG_namespace
      || parent->tag == DW_TAG_module
      || parent->tag == DW_TAG_structure_type
      || parent->tag == DW_TAG_class_type
      || parent->tag == DW_TAG_interface_type
      || parent->tag == DW_TAG_union_type
      || parent->tag == DW_TAG_enumeration_type)
    {
      if (grandparent_scope == NULL)
	parent->scope = parent->name;
      else
	parent->scope = typename_concat (&cu->comp_unit_obstack,
					 grandparent_scope,
					 parent->name, 0, cu);
    }
  else
    {
      /* FIXME drow/2004-04-01: What should we be doing with
	 function-local names?  For partial symbols, we should probably be
	 ignoring them.  */
      complaint (&symfile_complaints,
		 _("unhandled containing DIE tag %d for DIE at %d"),
		 parent->tag, pdi->offset.sect_off);
      parent->scope = grandparent_scope;
    }

  parent->scope_set = 1;
  return parent->scope;
}

/* Return the fully scoped name associated with PDI, from compilation unit
   CU.  The result will be allocated with malloc.  */

static char *
partial_die_full_name (struct partial_die_info *pdi,
		       struct dwarf2_cu *cu)
{
  const char *parent_scope;

  /* If this is a template instantiation, we can not work out the
     template arguments from partial DIEs.  So, unfortunately, we have
     to go through the full DIEs.  At least any work we do building
     types here will be reused if full symbols are loaded later.  */
  if (pdi->has_template_arguments)
    {
      fixup_partial_die (pdi, cu);

      if (pdi->name != NULL && strchr (pdi->name, '<') == NULL)
	{
	  struct die_info *die;
	  struct attribute attr;
	  struct dwarf2_cu *ref_cu = cu;

	  /* DW_FORM_ref_addr is using section offset.  */
	  attr.name = 0;
	  attr.form = DW_FORM_ref_addr;
	  attr.u.unsnd = pdi->offset.sect_off;
	  die = follow_die_ref (NULL, &attr, &ref_cu);

	  return xstrdup (dwarf2_full_name (NULL, die, ref_cu));
	}
    }

  parent_scope = partial_die_parent_scope (pdi, cu);
  if (parent_scope == NULL)
    return NULL;
  else
    return typename_concat (NULL, parent_scope, pdi->name, 0, cu);
}

static void
add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  CORE_ADDR addr = 0;
  const char *actual_name = NULL;
  CORE_ADDR baseaddr;
  char *built_actual_name;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  built_actual_name = partial_die_full_name (pdi, cu);
  if (built_actual_name != NULL)
    actual_name = built_actual_name;

  if (actual_name == NULL)
    actual_name = pdi->name;

  switch (pdi->tag)
    {
    case DW_TAG_subprogram:
      if (pdi->is_external || cu->language == language_ada)
	{
          /* brobecker/2007-12-26: Normally, only "external" DIEs are part
             of the global scope.  But in Ada, we want to be able to access
             nested procedures globally.  So all Ada subprograms are stored
             in the global scope.  */
	  /* prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
	     mst_text, objfile); */
	  add_psymbol_to_list (actual_name, strlen (actual_name),
			       built_actual_name != NULL,
			       VAR_DOMAIN, LOC_BLOCK,
			       &objfile->global_psymbols,
			       0, pdi->lowpc + baseaddr,
			       cu->language, objfile);
	}
      else
	{
	  /* prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
	     mst_file_text, objfile); */
	  add_psymbol_to_list (actual_name, strlen (actual_name),
			       built_actual_name != NULL,
			       VAR_DOMAIN, LOC_BLOCK,
			       &objfile->static_psymbols,
			       0, pdi->lowpc + baseaddr,
			       cu->language, objfile);
	}
      break;
    case DW_TAG_constant:
      {
        struct psymbol_allocation_list *list;

	if (pdi->is_external)
	  list = &objfile->global_psymbols;
	else
	  list = &objfile->static_psymbols;
	add_psymbol_to_list (actual_name, strlen (actual_name),
			     built_actual_name != NULL, VAR_DOMAIN, LOC_STATIC,
			     list, 0, 0, cu->language, objfile);
      }
      break;
    case DW_TAG_variable:
      if (pdi->d.locdesc)
	addr = decode_locdesc (pdi->d.locdesc, cu);

      if (pdi->d.locdesc
	  && addr == 0
	  && !dwarf2_per_objfile->has_section_at_zero)
	{
	  /* A global or static variable may also have been stripped
	     out by the linker if unused, in which case its address
	     will be nullified; do not add such variables into partial
	     symbol table then.  */
	}
      else if (pdi->is_external)
	{
	  /* Global Variable.
	     Don't enter into the minimal symbol tables as there is
	     a minimal symbol table entry from the ELF symbols already.
	     Enter into partial symbol table if it has a location
	     descriptor or a type.
	     If the location descriptor is missing, new_symbol will create
	     a LOC_UNRESOLVED symbol, the address of the variable will then
	     be determined from the minimal symbol table whenever the variable
	     is referenced.
	     The address for the partial symbol table entry is not
	     used by GDB, but it comes in handy for debugging partial symbol
	     table building.  */

	  if (pdi->d.locdesc || pdi->has_type)
	    add_psymbol_to_list (actual_name, strlen (actual_name),
				 built_actual_name != NULL,
				 VAR_DOMAIN, LOC_STATIC,
				 &objfile->global_psymbols,
				 0, addr + baseaddr,
				 cu->language, objfile);
	}
      else
	{
	  /* Static Variable.  Skip symbols without location descriptors.  */
	  if (pdi->d.locdesc == NULL)
	    {
	      xfree (built_actual_name);
	      return;
	    }
	  /* prim_record_minimal_symbol (actual_name, addr + baseaddr,
	     mst_file_data, objfile); */
	  add_psymbol_to_list (actual_name, strlen (actual_name),
			       built_actual_name != NULL,
			       VAR_DOMAIN, LOC_STATIC,
			       &objfile->static_psymbols,
			       0, addr + baseaddr,
			       cu->language, objfile);
	}
      break;
    case DW_TAG_typedef:
    case DW_TAG_base_type:
    case DW_TAG_subrange_type:
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   built_actual_name != NULL,
			   VAR_DOMAIN, LOC_TYPEDEF,
			   &objfile->static_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
      break;
    case DW_TAG_namespace:
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   built_actual_name != NULL,
			   VAR_DOMAIN, LOC_TYPEDEF,
			   &objfile->global_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
      break;
    case DW_TAG_class_type:
    case DW_TAG_interface_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
    case DW_TAG_enumeration_type:
      /* Skip external references.  The DWARF standard says in the section
         about "Structure, Union, and Class Type Entries": "An incomplete
         structure, union or class type is represented by a structure,
         union or class entry that does not have a byte size attribute
         and that has a DW_AT_declaration attribute."  */
      if (!pdi->has_byte_size && pdi->is_declaration)
	{
	  xfree (built_actual_name);
	  return;
	}

      /* NOTE: carlton/2003-10-07: See comment in new_symbol about
	 static vs. global.  */
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   built_actual_name != NULL,
			   STRUCT_DOMAIN, LOC_TYPEDEF,
			   (cu->language == language_cplus
			    || cu->language == language_java)
			   ? &objfile->global_psymbols
			   : &objfile->static_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);

      break;
    case DW_TAG_enumerator:
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   built_actual_name != NULL,
			   VAR_DOMAIN, LOC_CONST,
			   (cu->language == language_cplus
			    || cu->language == language_java)
			   ? &objfile->global_psymbols
			   : &objfile->static_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
      break;
    default:
      break;
    }

  xfree (built_actual_name);
}

/* Read a partial die corresponding to a namespace; also, add a symbol
   corresponding to that namespace to the symbol table.  NAMESPACE is
   the name of the enclosing namespace.  */

static void
add_partial_namespace (struct partial_die_info *pdi,
		       CORE_ADDR *lowpc, CORE_ADDR *highpc,
		       int need_pc, struct dwarf2_cu *cu)
{
  /* Add a symbol for the namespace.  */

  add_partial_symbol (pdi, cu);

  /* Now scan partial symbols in that namespace.  */

  if (pdi->has_children)
    scan_partial_symbols (pdi->die_child, lowpc, highpc, need_pc, cu);
}

/* Read a partial die corresponding to a Fortran module.  */

static void
add_partial_module (struct partial_die_info *pdi, CORE_ADDR *lowpc,
		    CORE_ADDR *highpc, int need_pc, struct dwarf2_cu *cu)
{
  /* Now scan partial symbols in that module.  */

  if (pdi->has_children)
    scan_partial_symbols (pdi->die_child, lowpc, highpc, need_pc, cu);
}

/* Read a partial die corresponding to a subprogram and create a partial
   symbol for that subprogram.  When the CU language allows it, this
   routine also defines a partial symbol for each nested subprogram
   that this subprogram contains.

   DIE my also be a lexical block, in which case we simply search
   recursively for suprograms defined inside that lexical block.
   Again, this is only performed when the CU language allows this
   type of definitions.  */

static void
add_partial_subprogram (struct partial_die_info *pdi,
			CORE_ADDR *lowpc, CORE_ADDR *highpc,
			int need_pc, struct dwarf2_cu *cu)
{
  if (pdi->tag == DW_TAG_subprogram)
    {
      if (pdi->has_pc_info)
        {
          if (pdi->lowpc < *lowpc)
            *lowpc = pdi->lowpc;
          if (pdi->highpc > *highpc)
            *highpc = pdi->highpc;
	  if (need_pc)
	    {
	      CORE_ADDR baseaddr;
	      struct objfile *objfile = cu->objfile;

	      baseaddr = ANOFFSET (objfile->section_offsets,
				   SECT_OFF_TEXT (objfile));
	      addrmap_set_empty (objfile->psymtabs_addrmap,
				 pdi->lowpc + baseaddr,
				 pdi->highpc - 1 + baseaddr,
				 cu->per_cu->v.psymtab);
	    }
        }

      if (pdi->has_pc_info || (!pdi->is_external && pdi->may_be_inlined))
	{
          if (!pdi->is_declaration)
	    /* Ignore subprogram DIEs that do not have a name, they are
	       illegal.  Do not emit a complaint at this point, we will
	       do so when we convert this psymtab into a symtab.  */
	    if (pdi->name)
	      add_partial_symbol (pdi, cu);
        }
    }

  if (! pdi->has_children)
    return;

  if (cu->language == language_ada)
    {
      pdi = pdi->die_child;
      while (pdi != NULL)
	{
	  fixup_partial_die (pdi, cu);
	  if (pdi->tag == DW_TAG_subprogram
	      || pdi->tag == DW_TAG_lexical_block)
	    add_partial_subprogram (pdi, lowpc, highpc, need_pc, cu);
	  pdi = pdi->die_sibling;
	}
    }
}

/* Read a partial die corresponding to an enumeration type.  */

static void
add_partial_enumeration (struct partial_die_info *enum_pdi,
			 struct dwarf2_cu *cu)
{
  struct partial_die_info *pdi;

  if (enum_pdi->name != NULL)
    add_partial_symbol (enum_pdi, cu);

  pdi = enum_pdi->die_child;
  while (pdi)
    {
      if (pdi->tag != DW_TAG_enumerator || pdi->name == NULL)
	complaint (&symfile_complaints, _("malformed enumerator DIE ignored"));
      else
	add_partial_symbol (pdi, cu);
      pdi = pdi->die_sibling;
    }
}

/* Return the initial uleb128 in the die at INFO_PTR.  */

static unsigned int
peek_abbrev_code (bfd *abfd, const gdb_byte *info_ptr)
{
  unsigned int bytes_read;

  return read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
}

/* Read the initial uleb128 in the die at INFO_PTR in compilation unit CU.
   Return the corresponding abbrev, or NULL if the number is zero (indicating
   an empty DIE).  In either case *BYTES_READ will be set to the length of
   the initial number.  */

static struct abbrev_info *
peek_die_abbrev (const gdb_byte *info_ptr, unsigned int *bytes_read,
		 struct dwarf2_cu *cu)
{
  bfd *abfd = cu->objfile->obfd;
  unsigned int abbrev_number;
  struct abbrev_info *abbrev;

  abbrev_number = read_unsigned_leb128 (abfd, info_ptr, bytes_read);

  if (abbrev_number == 0)
    return NULL;

  abbrev = abbrev_table_lookup_abbrev (cu->abbrev_table, abbrev_number);
  if (!abbrev)
    {
      error (_("Dwarf Error: Could not find abbrev number %d [in module %s]"),
	     abbrev_number, bfd_get_filename (abfd));
    }

  return abbrev;
}

/* Scan the debug information for CU starting at INFO_PTR in buffer BUFFER.
   Returns a pointer to the end of a series of DIEs, terminated by an empty
   DIE.  Any children of the skipped DIEs will also be skipped.  */

static const gdb_byte *
skip_children (const struct die_reader_specs *reader, const gdb_byte *info_ptr)
{
  struct dwarf2_cu *cu = reader->cu;
  struct abbrev_info *abbrev;
  unsigned int bytes_read;

  while (1)
    {
      abbrev = peek_die_abbrev (info_ptr, &bytes_read, cu);
      if (abbrev == NULL)
	return info_ptr + bytes_read;
      else
	info_ptr = skip_one_die (reader, info_ptr + bytes_read, abbrev);
    }
}

/* Scan the debug information for CU starting at INFO_PTR in buffer BUFFER.
   INFO_PTR should point just after the initial uleb128 of a DIE, and the
   abbrev corresponding to that skipped uleb128 should be passed in
   ABBREV.  Returns a pointer to this DIE's sibling, skipping any
   children.  */

static const gdb_byte *
skip_one_die (const struct die_reader_specs *reader, const gdb_byte *info_ptr,
	      struct abbrev_info *abbrev)
{
  unsigned int bytes_read;
  struct attribute attr;
  bfd *abfd = reader->abfd;
  struct dwarf2_cu *cu = reader->cu;
  const gdb_byte *buffer = reader->buffer;
  const gdb_byte *buffer_end = reader->buffer_end;
  const gdb_byte *start_info_ptr = info_ptr;
  unsigned int form, i;

  for (i = 0; i < abbrev->num_attrs; i++)
    {
      /* The only abbrev we care about is DW_AT_sibling.  */
      if (abbrev->attrs[i].name == DW_AT_sibling)
	{
	  read_attribute (reader, &attr, &abbrev->attrs[i], info_ptr);
	  if (attr.form == DW_FORM_ref_addr)
	    complaint (&symfile_complaints,
		       _("ignoring absolute DW_AT_sibling"));
	  else
	    return buffer + dwarf2_get_ref_die_offset (&attr).sect_off;
	}

      /* If it isn't DW_AT_sibling, skip this attribute.  */
      form = abbrev->attrs[i].form;
    skip_attribute:
      switch (form)
	{
	case DW_FORM_ref_addr:
	  /* In DWARF 2, DW_FORM_ref_addr is address sized; in DWARF 3
	     and later it is offset sized.  */
	  if (cu->header.version == 2)
	    info_ptr += cu->header.addr_size;
	  else
	    info_ptr += cu->header.offset_size;
	  break;
	case DW_FORM_GNU_ref_alt:
	  info_ptr += cu->header.offset_size;
	  break;
	case DW_FORM_addr:
	  info_ptr += cu->header.addr_size;
	  break;
	case DW_FORM_data1:
	case DW_FORM_ref1:
	case DW_FORM_flag:
	  info_ptr += 1;
	  break;
	case DW_FORM_flag_present:
	  break;
	case DW_FORM_data2:
	case DW_FORM_ref2:
	  info_ptr += 2;
	  break;
	case DW_FORM_data4:
	case DW_FORM_ref4:
	  info_ptr += 4;
	  break;
	case DW_FORM_data8:
	case DW_FORM_ref8:
	case DW_FORM_ref_sig8:
	  info_ptr += 8;
	  break;
	case DW_FORM_string:
	  read_direct_string (abfd, info_ptr, &bytes_read);
	  info_ptr += bytes_read;
	  break;
	case DW_FORM_sec_offset:
	case DW_FORM_strp:
	case DW_FORM_GNU_strp_alt:
	  info_ptr += cu->header.offset_size;
	  break;
	case DW_FORM_exprloc:
	case DW_FORM_block:
	  info_ptr += read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
	  info_ptr += bytes_read;
	  break;
	case DW_FORM_block1:
	  info_ptr += 1 + read_1_byte (abfd, info_ptr);
	  break;
	case DW_FORM_block2:
	  info_ptr += 2 + read_2_bytes (abfd, info_ptr);
	  break;
	case DW_FORM_block4:
	  info_ptr += 4 + read_4_bytes (abfd, info_ptr);
	  break;
	case DW_FORM_sdata:
	case DW_FORM_udata:
	case DW_FORM_ref_udata:
	case DW_FORM_GNU_addr_index:
	case DW_FORM_GNU_str_index:
	  info_ptr = safe_skip_leb128 (info_ptr, buffer_end);
	  break;
	case DW_FORM_indirect:
	  form = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
	  info_ptr += bytes_read;
	  /* We need to continue parsing from here, so just go back to
	     the top.  */
	  goto skip_attribute;

	default:
	  error (_("Dwarf Error: Cannot handle %s "
		   "in DWARF reader [in module %s]"),
		 dwarf_form_name (form),
		 bfd_get_filename (abfd));
	}
    }

  if (abbrev->has_children)
    return skip_children (reader, info_ptr);
  else
    return info_ptr;
}

/* Locate ORIG_PDI's sibling.
   INFO_PTR should point to the start of the next DIE after ORIG_PDI.  */

static const gdb_byte *
locate_pdi_sibling (const struct die_reader_specs *reader,
		    struct partial_die_info *orig_pdi,
		    const gdb_byte *info_ptr)
{
  /* Do we know the sibling already?  */

  if (orig_pdi->sibling)
    return orig_pdi->sibling;

  /* Are there any children to deal with?  */

  if (!orig_pdi->has_children)
    return info_ptr;

  /* Skip the children the long way.  */

  return skip_children (reader, info_ptr);
}

/* Expand this partial symbol table into a full symbol table.  SELF is
   not NULL.  */

static void
dwarf2_read_symtab (struct partial_symtab *self,
		    struct objfile *objfile)
{
  if (self->readin)
    {
      warning (_("bug: psymtab for %s is already read in."),
	       self->filename);
    }
  else
    {
      if (info_verbose)
	{
	  printf_filtered (_("Reading in symbols for %s..."),
			   self->filename);
	  gdb_flush (gdb_stdout);
	}

      /* Restore our global data.  */
      dwarf2_per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);

      /* If this psymtab is constructed from a debug-only objfile, the
	 has_section_at_zero flag will not necessarily be correct.  We
	 can get the correct value for this flag by looking at the data
	 associated with the (presumably stripped) associated objfile.  */
      if (objfile->separate_debug_objfile_backlink)
	{
	  struct dwarf2_per_objfile *dpo_backlink
	    = objfile_data (objfile->separate_debug_objfile_backlink,
			    dwarf2_objfile_data_key);

	  dwarf2_per_objfile->has_section_at_zero
	    = dpo_backlink->has_section_at_zero;
	}

      dwarf2_per_objfile->reading_partial_symbols = 0;

      psymtab_to_symtab_1 (self);

      /* Finish up the debug error message.  */
      if (info_verbose)
	printf_filtered (_("done.\n"));
    }

  process_cu_includes ();
}

/* Reading in full CUs.  */

/* Add PER_CU to the queue.  */

static void
queue_comp_unit (struct dwarf2_per_cu_data *per_cu,
		 enum language pretend_language)
{
  struct dwarf2_queue_item *item;

  per_cu->queued = 1;
  item = xmalloc (sizeof (*item));
  item->per_cu = per_cu;
  item->pretend_language = pretend_language;
  item->next = NULL;

  if (dwarf2_queue == NULL)
    dwarf2_queue = item;
  else
    dwarf2_queue_tail->next = item;

  dwarf2_queue_tail = item;
}

/* If PER_CU is not yet queued, add it to the queue.
   If DEPENDENT_CU is non-NULL, it has a reference to PER_CU so add a
   dependency.
   The result is non-zero if PER_CU was queued, otherwise the result is zero
   meaning either PER_CU is already queued or it is already loaded.

   N.B. There is an invariant here that if a CU is queued then it is loaded.
   The caller is required to load PER_CU if we return non-zero.  */

static int
maybe_queue_comp_unit (struct dwarf2_cu *dependent_cu,
		       struct dwarf2_per_cu_data *per_cu,
		       enum language pretend_language)
{
  /* We may arrive here during partial symbol reading, if we need full
     DIEs to process an unusual case (e.g. template arguments).  Do
     not queue PER_CU, just tell our caller to load its DIEs.  */
  if (dwarf2_per_objfile->reading_partial_symbols)
    {
      if (per_cu->cu == NULL || per_cu->cu->dies == NULL)
	return 1;
      return 0;
    }

  /* Mark the dependence relation so that we don't flush PER_CU
     too early.  */
  if (dependent_cu != NULL)
    dwarf2_add_dependence (dependent_cu, per_cu);

  /* If it's already on the queue, we have nothing to do.  */
  if (per_cu->queued)
    return 0;

  /* If the compilation unit is already loaded, just mark it as
     used.  */
  if (per_cu->cu != NULL)
    {
      per_cu->cu->last_used = 0;
      return 0;
    }

  /* Add it to the queue.  */
  queue_comp_unit (per_cu, pretend_language);

  return 1;
}

/* Process the queue.  */

static void
process_queue (void)
{
  struct dwarf2_queue_item *item, *next_item;

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Expanding one or more symtabs of objfile %s ...\n",
			  objfile_name (dwarf2_per_objfile->objfile));
    }

  /* The queue starts out with one item, but following a DIE reference
     may load a new CU, adding it to the end of the queue.  */
  for (item = dwarf2_queue; item != NULL; dwarf2_queue = item = next_item)
    {
      if (dwarf2_per_objfile->using_index
	  ? !item->per_cu->v.quick->symtab
	  : (item->per_cu->v.psymtab && !item->per_cu->v.psymtab->readin))
	{
	  struct dwarf2_per_cu_data *per_cu = item->per_cu;
	  char buf[100];

	  if (per_cu->is_debug_types)
	    {
	      struct signatured_type *sig_type =
		(struct signatured_type *) per_cu;

	      sprintf (buf, "TU %s at offset 0x%x",
		       hex_string (sig_type->signature), per_cu->offset.sect_off);
	    }
	  else
	    sprintf (buf, "CU at offset 0x%x", per_cu->offset.sect_off);

	  if (dwarf2_read_debug)
	    fprintf_unfiltered (gdb_stdlog, "Expanding symtab of %s\n", buf);

	  if (per_cu->is_debug_types)
	    process_full_type_unit (per_cu, item->pretend_language);
	  else
	    process_full_comp_unit (per_cu, item->pretend_language);

	  if (dwarf2_read_debug)
	    fprintf_unfiltered (gdb_stdlog, "Done expanding %s\n", buf);
	}

      item->per_cu->queued = 0;
      next_item = item->next;
      xfree (item);
    }

  dwarf2_queue_tail = NULL;

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Done expanding symtabs of %s.\n",
			  objfile_name (dwarf2_per_objfile->objfile));
    }
}

/* Free all allocated queue entries.  This function only releases anything if
   an error was thrown; if the queue was processed then it would have been
   freed as we went along.  */

static void
dwarf2_release_queue (void *dummy)
{
  struct dwarf2_queue_item *item, *last;

  item = dwarf2_queue;
  while (item)
    {
      /* Anything still marked queued is likely to be in an
	 inconsistent state, so discard it.  */
      if (item->per_cu->queued)
	{
	  if (item->per_cu->cu != NULL)
	    free_one_cached_comp_unit (item->per_cu);
	  item->per_cu->queued = 0;
	}

      last = item;
      item = item->next;
      xfree (last);
    }

  dwarf2_queue = dwarf2_queue_tail = NULL;
}

/* Read in full symbols for PST, and anything it depends on.  */

static void
psymtab_to_symtab_1 (struct partial_symtab *pst)
{
  struct dwarf2_per_cu_data *per_cu;
  int i;

  if (pst->readin)
    return;

  for (i = 0; i < pst->number_of_dependencies; i++)
    if (!pst->dependencies[i]->readin
	&& pst->dependencies[i]->user == NULL)
      {
        /* Inform about additional files that need to be read in.  */
        if (info_verbose)
          {
	    /* FIXME: i18n: Need to make this a single string.  */
            fputs_filtered (" ", gdb_stdout);
            wrap_here ("");
            fputs_filtered ("and ", gdb_stdout);
            wrap_here ("");
            printf_filtered ("%s...", pst->dependencies[i]->filename);
            wrap_here ("");     /* Flush output.  */
            gdb_flush (gdb_stdout);
          }
        psymtab_to_symtab_1 (pst->dependencies[i]);
      }

  per_cu = pst->read_symtab_private;

  if (per_cu == NULL)
    {
      /* It's an include file, no symbols to read for it.
         Everything is in the parent symtab.  */
      pst->readin = 1;
      return;
    }

  dw2_do_instantiate_symtab (per_cu);
}

/* Trivial hash function for die_info: the hash value of a DIE
   is its offset in .debug_info for this objfile.  */

static hashval_t
die_hash (const void *item)
{
  const struct die_info *die = item;

  return die->offset.sect_off;
}

/* Trivial comparison function for die_info structures: two DIEs
   are equal if they have the same offset.  */

static int
die_eq (const void *item_lhs, const void *item_rhs)
{
  const struct die_info *die_lhs = item_lhs;
  const struct die_info *die_rhs = item_rhs;

  return die_lhs->offset.sect_off == die_rhs->offset.sect_off;
}

/* die_reader_func for load_full_comp_unit.
   This is identical to read_signatured_type_reader,
   but is kept separate for now.  */

static void
load_full_comp_unit_reader (const struct die_reader_specs *reader,
			    const gdb_byte *info_ptr,
			    struct die_info *comp_unit_die,
			    int has_children,
			    void *data)
{
  struct dwarf2_cu *cu = reader->cu;
  enum language *language_ptr = data;

  gdb_assert (cu->die_hash == NULL);
  cu->die_hash =
    htab_create_alloc_ex (cu->header.length / 12,
			  die_hash,
			  die_eq,
			  NULL,
			  &cu->comp_unit_obstack,
			  hashtab_obstack_allocate,
			  dummy_obstack_deallocate);

  if (has_children)
    comp_unit_die->child = read_die_and_siblings (reader, info_ptr,
						  &info_ptr, comp_unit_die);
  cu->dies = comp_unit_die;
  /* comp_unit_die is not stored in die_hash, no need.  */

  /* We try not to read any attributes in this function, because not
     all CUs needed for references have been loaded yet, and symbol
     table processing isn't initialized.  But we have to set the CU language,
     or we won't be able to build types correctly.
     Similarly, if we do not read the producer, we can not apply
     producer-specific interpretation.  */
  prepare_one_comp_unit (cu, cu->dies, *language_ptr);
}

/* Load the DIEs associated with PER_CU into memory.  */

static void
load_full_comp_unit (struct dwarf2_per_cu_data *this_cu,
		     enum language pretend_language)
{
  gdb_assert (! this_cu->is_debug_types);

  init_cutu_and_read_dies (this_cu, NULL, 1, 1,
			   load_full_comp_unit_reader, &pretend_language);
}

/* Add a DIE to the delayed physname list.  */

static void
add_to_method_list (struct type *type, int fnfield_index, int index,
		    const char *name, struct die_info *die,
		    struct dwarf2_cu *cu)
{
  struct delayed_method_info mi;
  mi.type = type;
  mi.fnfield_index = fnfield_index;
  mi.index = index;
  mi.name = name;
  mi.die = die;
  VEC_safe_push (delayed_method_info, cu->method_list, &mi);
}

/* A cleanup for freeing the delayed method list.  */

static void
free_delayed_list (void *ptr)
{
  struct dwarf2_cu *cu = (struct dwarf2_cu *) ptr;
  if (cu->method_list != NULL)
    {
      VEC_free (delayed_method_info, cu->method_list);
      cu->method_list = NULL;
    }
}

/* Compute the physnames of any methods on the CU's method list.

   The computation of method physnames is delayed in order to avoid the
   (bad) condition that one of the method's formal parameters is of an as yet
   incomplete type.  */

static void
compute_delayed_physnames (struct dwarf2_cu *cu)
{
  int i;
  struct delayed_method_info *mi;
  for (i = 0; VEC_iterate (delayed_method_info, cu->method_list, i, mi) ; ++i)
    {
      const char *physname;
      struct fn_fieldlist *fn_flp
	= &TYPE_FN_FIELDLIST (mi->type, mi->fnfield_index);
      physname = dwarf2_physname (mi->name, mi->die, cu);
      fn_flp->fn_fields[mi->index].physname = physname ? physname : "";
    }
}

/* Go objects should be embedded in a DW_TAG_module DIE,
   and it's not clear if/how imported objects will appear.
   To keep Go support simple until that's worked out,
   go back through what we've read and create something usable.
   We could do this while processing each DIE, and feels kinda cleaner,
   but that way is more invasive.
   This is to, for example, allow the user to type "p var" or "b main"
   without having to specify the package name, and allow lookups
   of module.object to work in contexts that use the expression
   parser.  */

static void
fixup_go_packaging (struct dwarf2_cu *cu)
{
  char *package_name = NULL;
  struct pending *list;
  int i;

  for (list = global_symbols; list != NULL; list = list->next)
    {
      for (i = 0; i < list->nsyms; ++i)
	{
	  struct symbol *sym = list->symbol[i];

	  if (SYMBOL_LANGUAGE (sym) == language_go
	      && SYMBOL_CLASS (sym) == LOC_BLOCK)
	    {
	      char *this_package_name = go_symbol_package_name (sym);

	      if (this_package_name == NULL)
		continue;
	      if (package_name == NULL)
		package_name = this_package_name;
	      else
		{
		  if (strcmp (package_name, this_package_name) != 0)
		    complaint (&symfile_complaints,
			       _("Symtab %s has objects from two different Go packages: %s and %s"),
			       (SYMBOL_SYMTAB (sym)
			  ? symtab_to_filename_for_display (SYMBOL_SYMTAB (sym))
				: objfile_name (cu->objfile)),
			       this_package_name, package_name);
		  xfree (this_package_name);
		}
	    }
	}
    }

  if (package_name != NULL)
    {
      struct objfile *objfile = cu->objfile;
      const char *saved_package_name = obstack_copy0 (&objfile->objfile_obstack,
						      package_name,
						      strlen (package_name));
      struct type *type = init_type (TYPE_CODE_MODULE, 0, 0,
				     saved_package_name, objfile);
      struct symbol *sym;

      TYPE_TAG_NAME (type) = TYPE_NAME (type);

      sym = allocate_symbol (objfile);
      SYMBOL_SET_LANGUAGE (sym, language_go, &objfile->objfile_obstack);
      SYMBOL_SET_NAMES (sym, saved_package_name,
			strlen (saved_package_name), 0, objfile);
      /* This is not VAR_DOMAIN because we want a way to ensure a lookup of,
	 e.g., "main" finds the "main" module and not C's main().  */
      SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
      SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
      SYMBOL_TYPE (sym) = type;

      add_symbol_to_list (sym, &global_symbols);

      xfree (package_name);
    }
}

/* Return the symtab for PER_CU.  This works properly regardless of
   whether we're using the index or psymtabs.  */

static struct symtab *
get_symtab (struct dwarf2_per_cu_data *per_cu)
{
  return (dwarf2_per_objfile->using_index
	  ? per_cu->v.quick->symtab
	  : per_cu->v.psymtab->symtab);
}

/* A helper function for computing the list of all symbol tables
   included by PER_CU.  */

static void
recursively_compute_inclusions (VEC (symtab_ptr) **result,
				htab_t all_children, htab_t all_type_symtabs,
				struct dwarf2_per_cu_data *per_cu,
				struct symtab *immediate_parent)
{
  void **slot;
  int ix;
  struct symtab *symtab;
  struct dwarf2_per_cu_data *iter;

  slot = htab_find_slot (all_children, per_cu, INSERT);
  if (*slot != NULL)
    {
      /* This inclusion and its children have been processed.  */
      return;
    }

  *slot = per_cu;
  /* Only add a CU if it has a symbol table.  */
  symtab = get_symtab (per_cu);
  if (symtab != NULL)
    {
      /* If this is a type unit only add its symbol table if we haven't
	 seen it yet (type unit per_cu's can share symtabs).  */
      if (per_cu->is_debug_types)
	{
	  slot = htab_find_slot (all_type_symtabs, symtab, INSERT);
	  if (*slot == NULL)
	    {
	      *slot = symtab;
	      VEC_safe_push (symtab_ptr, *result, symtab);
	      if (symtab->user == NULL)
		symtab->user = immediate_parent;
	    }
	}
      else
	{
	  VEC_safe_push (symtab_ptr, *result, symtab);
	  if (symtab->user == NULL)
	    symtab->user = immediate_parent;
	}
    }

  for (ix = 0;
       VEC_iterate (dwarf2_per_cu_ptr, per_cu->imported_symtabs, ix, iter);
       ++ix)
    {
      recursively_compute_inclusions (result, all_children,
				      all_type_symtabs, iter, symtab);
    }
}

/* Compute the symtab 'includes' fields for the symtab related to
   PER_CU.  */

static void
compute_symtab_includes (struct dwarf2_per_cu_data *per_cu)
{
  gdb_assert (! per_cu->is_debug_types);

  if (!VEC_empty (dwarf2_per_cu_ptr, per_cu->imported_symtabs))
    {
      int ix, len;
      struct dwarf2_per_cu_data *per_cu_iter;
      struct symtab *symtab_iter;
      VEC (symtab_ptr) *result_symtabs = NULL;
      htab_t all_children, all_type_symtabs;
      struct symtab *symtab = get_symtab (per_cu);

      /* If we don't have a symtab, we can just skip this case.  */
      if (symtab == NULL)
	return;

      all_children = htab_create_alloc (1, htab_hash_pointer, htab_eq_pointer,
					NULL, xcalloc, xfree);
      all_type_symtabs = htab_create_alloc (1, htab_hash_pointer, htab_eq_pointer,
					    NULL, xcalloc, xfree);

      for (ix = 0;
	   VEC_iterate (dwarf2_per_cu_ptr, per_cu->imported_symtabs,
			ix, per_cu_iter);
	   ++ix)
	{
	  recursively_compute_inclusions (&result_symtabs, all_children,
					  all_type_symtabs, per_cu_iter,
					  symtab);
	}

      /* Now we have a transitive closure of all the included symtabs.  */
      len = VEC_length (symtab_ptr, result_symtabs);
      symtab->includes
	= obstack_alloc (&dwarf2_per_objfile->objfile->objfile_obstack,
			 (len + 1) * sizeof (struct symtab *));
      for (ix = 0;
	   VEC_iterate (symtab_ptr, result_symtabs, ix, symtab_iter);
	   ++ix)
	symtab->includes[ix] = symtab_iter;
      symtab->includes[len] = NULL;

      VEC_free (symtab_ptr, result_symtabs);
      htab_delete (all_children);
      htab_delete (all_type_symtabs);
    }
}

/* Compute the 'includes' field for the symtabs of all the CUs we just
   read.  */

static void
process_cu_includes (void)
{
  int ix;
  struct dwarf2_per_cu_data *iter;

  for (ix = 0;
       VEC_iterate (dwarf2_per_cu_ptr, dwarf2_per_objfile->just_read_cus,
		    ix, iter);
       ++ix)
    {
      if (! iter->is_debug_types)
	compute_symtab_includes (iter);
    }

  VEC_free (dwarf2_per_cu_ptr, dwarf2_per_objfile->just_read_cus);
}

/* Generate full symbol information for PER_CU, whose DIEs have
   already been loaded into memory.  */

static void
process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,
			enum language pretend_language)
{
  struct dwarf2_cu *cu = per_cu->cu;
  struct objfile *objfile = per_cu->objfile;
  CORE_ADDR lowpc, highpc;
  struct symtab *symtab;
  struct cleanup *back_to, *delayed_list_cleanup;
  CORE_ADDR baseaddr;
  struct block *static_block;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  buildsym_init ();
  back_to = make_cleanup (really_free_pendings, NULL);
  delayed_list_cleanup = make_cleanup (free_delayed_list, cu);

  cu->list_in_scope = &file_symbols;

  cu->language = pretend_language;
  cu->language_defn = language_def (cu->language);

  /* Do line number decoding in read_file_scope () */
  process_die (cu->dies, cu);

  /* For now fudge the Go package.  */
  if (cu->language == language_go)
    fixup_go_packaging (cu);

  /* Now that we have processed all the DIEs in the CU, all the types 
     should be complete, and it should now be safe to compute all of the
     physnames.  */
  compute_delayed_physnames (cu);
  do_cleanups (delayed_list_cleanup);

  /* Some compilers don't define a DW_AT_high_pc attribute for the
     compilation unit.  If the DW_AT_high_pc is missing, synthesize
     it, by scanning the DIE's below the compilation unit.  */
  get_scope_pc_bounds (cu->dies, &lowpc, &highpc, cu);

  static_block
    = end_symtab_get_static_block (highpc + baseaddr, objfile, 0, 1);

  /* If the comp unit has DW_AT_ranges, it may have discontiguous ranges.
     Also, DW_AT_ranges may record ranges not belonging to any child DIEs
     (such as virtual method tables).  Record the ranges in STATIC_BLOCK's
     addrmap to help ensure it has an accurate map of pc values belonging to
     this comp unit.  */
  dwarf2_record_block_ranges (cu->dies, static_block, baseaddr, cu);

  symtab = end_symtab_from_static_block (static_block, objfile,
					 SECT_OFF_TEXT (objfile), 0);

  if (symtab != NULL)
    {
      int gcc_4_minor = producer_is_gcc_ge_4 (cu->producer);

      /* Set symtab language to language from DW_AT_language.  If the
	 compilation is from a C file generated by language preprocessors, do
	 not set the language if it was already deduced by start_subfile.  */
      if (!(cu->language == language_c && symtab->language != language_c))
	symtab->language = cu->language;

      /* GCC-4.0 has started to support -fvar-tracking.  GCC-3.x still can
	 produce DW_AT_location with location lists but it can be possibly
	 invalid without -fvar-tracking.  Still up to GCC-4.4.x incl. 4.4.0
	 there were bugs in prologue debug info, fixed later in GCC-4.5
	 by "unwind info for epilogues" patch (which is not directly related).

	 For -gdwarf-4 type units LOCATIONS_VALID indication is fortunately not
	 needed, it would be wrong due to missing DW_AT_producer there.

	 Still one can confuse GDB by using non-standard GCC compilation
	 options - this waits on GCC PR other/32998 (-frecord-gcc-switches).
	 */ 
      if (cu->has_loclist && gcc_4_minor >= 5)
	symtab->locations_valid = 1;

      if (gcc_4_minor >= 5)
	symtab->epilogue_unwind_valid = 1;

      symtab->call_site_htab = cu->call_site_htab;
    }

  if (dwarf2_per_objfile->using_index)
    per_cu->v.quick->symtab = symtab;
  else
    {
      struct partial_symtab *pst = per_cu->v.psymtab;
      pst->symtab = symtab;
      pst->readin = 1;
    }

  /* Push it for inclusion processing later.  */
  VEC_safe_push (dwarf2_per_cu_ptr, dwarf2_per_objfile->just_read_cus, per_cu);

  do_cleanups (back_to);
}

/* Generate full symbol information for type unit PER_CU, whose DIEs have
   already been loaded into memory.  */

static void
process_full_type_unit (struct dwarf2_per_cu_data *per_cu,
			enum language pretend_language)
{
  struct dwarf2_cu *cu = per_cu->cu;
  struct objfile *objfile = per_cu->objfile;
  struct symtab *symtab;
  struct cleanup *back_to, *delayed_list_cleanup;
  struct signatured_type *sig_type;

  gdb_assert (per_cu->is_debug_types);
  sig_type = (struct signatured_type *) per_cu;

  buildsym_init ();
  back_to = make_cleanup (really_free_pendings, NULL);
  delayed_list_cleanup = make_cleanup (free_delayed_list, cu);

  cu->list_in_scope = &file_symbols;

  cu->language = pretend_language;
  cu->language_defn = language_def (cu->language);

  /* The symbol tables are set up in read_type_unit_scope.  */
  process_die (cu->dies, cu);

  /* For now fudge the Go package.  */
  if (cu->language == language_go)
    fixup_go_packaging (cu);

  /* Now that we have processed all the DIEs in the CU, all the types 
     should be complete, and it should now be safe to compute all of the
     physnames.  */
  compute_delayed_physnames (cu);
  do_cleanups (delayed_list_cleanup);

  /* TUs share symbol tables.
     If this is the first TU to use this symtab, complete the construction
     of it with end_expandable_symtab.  Otherwise, complete the addition of
     this TU's symbols to the existing symtab.  */
  if (sig_type->type_unit_group->primary_symtab == NULL)
    {
      symtab = end_expandable_symtab (0, objfile, SECT_OFF_TEXT (objfile));
      sig_type->type_unit_group->primary_symtab = symtab;

      if (symtab != NULL)
	{
	  /* Set symtab language to language from DW_AT_language.  If the
	     compilation is from a C file generated by language preprocessors,
	     do not set the language if it was already deduced by
	     start_subfile.  */
	  if (!(cu->language == language_c && symtab->language != language_c))
	    symtab->language = cu->language;
	}
    }
  else
    {
      augment_type_symtab (objfile,
			   sig_type->type_unit_group->primary_symtab);
      symtab = sig_type->type_unit_group->primary_symtab;
    }

  if (dwarf2_per_objfile->using_index)
    per_cu->v.quick->symtab = symtab;
  else
    {
      struct partial_symtab *pst = per_cu->v.psymtab;
      pst->symtab = symtab;
      pst->readin = 1;
    }

  do_cleanups (back_to);
}

/* Process an imported unit DIE.  */

static void
process_imported_unit_die (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  /* For now we don't handle imported units in type units.  */
  if (cu->per_cu->is_debug_types)
    {
      error (_("Dwarf Error: DW_TAG_imported_unit is not"
	       " supported in type units [in module %s]"),
	     objfile_name (cu->objfile));
    }

  attr = dwarf2_attr (die, DW_AT_import, cu);
  if (attr != NULL)
    {
      struct dwarf2_per_cu_data *per_cu;
      struct symtab *imported_symtab;
      sect_offset offset;
      int is_dwz;

      offset = dwarf2_get_ref_die_offset (attr);
      is_dwz = (attr->form == DW_FORM_GNU_ref_alt || cu->per_cu->is_dwz);
      per_cu = dwarf2_find_containing_comp_unit (offset, is_dwz, cu->objfile);

      /* If necessary, add it to the queue and load its DIEs.  */
      if (maybe_queue_comp_unit (cu, per_cu, cu->language))
	load_full_comp_unit (per_cu, cu->language);

      VEC_safe_push (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs,
		     per_cu);
    }
}

/* Process a die and its children.  */

static void
process_die (struct die_info *die, struct dwarf2_cu *cu)
{
  switch (die->tag)
    {
    case DW_TAG_padding:
      break;
    case DW_TAG_compile_unit:
    case DW_TAG_partial_unit:
      read_file_scope (die, cu);
      break;
    case DW_TAG_type_unit:
      read_type_unit_scope (die, cu);
      break;
    case DW_TAG_subprogram:
    case DW_TAG_inlined_subroutine:
      read_func_scope (die, cu);
      break;
    case DW_TAG_lexical_block:
    case DW_TAG_try_block:
    case DW_TAG_catch_block:
      read_lexical_block_scope (die, cu);
      break;
    case DW_TAG_GNU_call_site:
      read_call_site_scope (die, cu);
      break;
    case DW_TAG_class_type:
    case DW_TAG_interface_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
      process_structure_scope (die, cu);
      break;
    case DW_TAG_enumeration_type:
      process_enumeration_scope (die, cu);
      break;

    /* These dies have a type, but processing them does not create
       a symbol or recurse to process the children.  Therefore we can
       read them on-demand through read_type_die.  */
    case DW_TAG_subroutine_type:
    case DW_TAG_set_type:
    case DW_TAG_array_type:
    case DW_TAG_pointer_type:
    case DW_TAG_ptr_to_member_type:
    case DW_TAG_reference_type:
    case DW_TAG_string_type:
      break;

    case DW_TAG_base_type:
    case DW_TAG_subrange_type:
    case DW_TAG_typedef:
      /* Add a typedef symbol for the type definition, if it has a
         DW_AT_name.  */
      new_symbol (die, read_type_die (die, cu), cu);
      break;
    case DW_TAG_common_block:
      read_common_block (die, cu);
      break;
    case DW_TAG_common_inclusion:
      break;
    case DW_TAG_namespace:
      cu->processing_has_namespace_info = 1;
      read_namespace (die, cu);
      break;
    case DW_TAG_module:
      cu->processing_has_namespace_info = 1;
      read_module (die, cu);
      break;
    case DW_TAG_imported_declaration:
    case DW_TAG_imported_module:
      cu->processing_has_namespace_info = 1;
      if (die->child != NULL && (die->tag == DW_TAG_imported_declaration
				 || cu->language != language_fortran))
	complaint (&symfile_complaints, _("Tag '%s' has unexpected children"),
		   dwarf_tag_name (die->tag));
      read_import_statement (die, cu);
      break;

    case DW_TAG_imported_unit:
      process_imported_unit_die (die, cu);
      break;

    default:
      new_symbol (die, NULL, cu);
      break;
    }
}

/* DWARF name computation.  */

/* A helper function for dwarf2_compute_name which determines whether DIE
   needs to have the name of the scope prepended to the name listed in the
   die.  */

static int
die_needs_namespace (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  switch (die->tag)
    {
    case DW_TAG_namespace:
    case DW_TAG_typedef:
    case DW_TAG_class_type:
    case DW_TAG_interface_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
    case DW_TAG_enumeration_type:
    case DW_TAG_enumerator:
    case DW_TAG_subprogram:
    case DW_TAG_member:
      return 1;

    case DW_TAG_variable:
    case DW_TAG_constant:
      /* We only need to prefix "globally" visible variables.  These include
	 any variable marked with DW_AT_external or any variable that
	 lives in a namespace.  [Variables in anonymous namespaces
	 require prefixing, but they are not DW_AT_external.]  */

      if (dwarf2_attr (die, DW_AT_specification, cu))
	{
	  struct dwarf2_cu *spec_cu = cu;

	  return die_needs_namespace (die_specification (die, &spec_cu),
				      spec_cu);
	}

      attr = dwarf2_attr (die, DW_AT_external, cu);
      if (attr == NULL && die->parent->tag != DW_TAG_namespace
	  && die->parent->tag != DW_TAG_module)
	return 0;
      /* A variable in a lexical block of some kind does not need a
	 namespace, even though in C++ such variables may be external
	 and have a mangled name.  */
      if (die->parent->tag ==  DW_TAG_lexical_block
	  || die->parent->tag ==  DW_TAG_try_block
	  || die->parent->tag ==  DW_TAG_catch_block
	  || die->parent->tag == DW_TAG_subprogram)
	return 0;
      return 1;

    default:
      return 0;
    }
}

/* Retrieve the last character from a mem_file.  */

static void
do_ui_file_peek_last (void *object, const char *buffer, long length)
{
  char *last_char_p = (char *) object;

  if (length > 0)
    *last_char_p = buffer[length - 1];
}

/* Compute the fully qualified name of DIE in CU.  If PHYSNAME is nonzero,
   compute the physname for the object, which include a method's:
   - formal parameters (C++/Java),
   - receiver type (Go),
   - return type (Java).

   The term "physname" is a bit confusing.
   For C++, for example, it is the demangled name.
   For Go, for example, it's the mangled name.

   For Ada, return the DIE's linkage name rather than the fully qualified
   name.  PHYSNAME is ignored..

   The result is allocated on the objfile_obstack and canonicalized.  */

static const char *
dwarf2_compute_name (const char *name,
		     struct die_info *die, struct dwarf2_cu *cu,
		     int physname)
{
  struct objfile *objfile = cu->objfile;

  if (name == NULL)
    name = dwarf2_name (die, cu);

  /* For Fortran GDB prefers DW_AT_*linkage_name if present but otherwise
     compute it by typename_concat inside GDB.  */
  if (cu->language == language_ada
      || (cu->language == language_fortran && physname))
    {
      /* For Ada unit, we prefer the linkage name over the name, as
	 the former contains the exported name, which the user expects
	 to be able to reference.  Ideally, we want the user to be able
	 to reference this entity using either natural or linkage name,
	 but we haven't started looking at this enhancement yet.  */
      struct attribute *attr;

      attr = dwarf2_attr (die, DW_AT_linkage_name, cu);
      if (attr == NULL)
	attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);
      if (attr && DW_STRING (attr))
	return DW_STRING (attr);
    }

  /* These are the only languages we know how to qualify names in.  */
  if (name != NULL
      && (cu->language == language_cplus || cu->language == language_java
	  || cu->language == language_fortran))
    {
      if (die_needs_namespace (die, cu))
	{
	  long length;
	  const char *prefix;
	  struct ui_file *buf;

	  prefix = determine_prefix (die, cu);
	  buf = mem_fileopen ();
	  if (*prefix != '\0')
	    {
	      char *prefixed_name = typename_concat (NULL, prefix, name,
						     physname, cu);

	      fputs_unfiltered (prefixed_name, buf);
	      xfree (prefixed_name);
	    }
	  else
	    fputs_unfiltered (name, buf);

	  /* Template parameters may be specified in the DIE's DW_AT_name, or
	     as children with DW_TAG_template_type_param or
	     DW_TAG_value_type_param.  If the latter, add them to the name
	     here.  If the name already has template parameters, then
	     skip this step; some versions of GCC emit both, and
	     it is more efficient to use the pre-computed name.

	     Something to keep in mind about this process: it is very
	     unlikely, or in some cases downright impossible, to produce
	     something that will match the mangled name of a function.
	     If the definition of the function has the same debug info,
	     we should be able to match up with it anyway.  But fallbacks
	     using the minimal symbol, for instance to find a method
	     implemented in a stripped copy of libstdc++, will not work.
	     If we do not have debug info for the definition, we will have to
	     match them up some other way.

	     When we do name matching there is a related problem with function
	     templates; two instantiated function templates are allowed to
	     differ only by their return types, which we do not add here.  */

	  if (cu->language == language_cplus && strchr (name, '<') == NULL)
	    {
	      struct attribute *attr;
	      struct die_info *child;
	      int first = 1;

	      die->building_fullname = 1;

	      for (child = die->child; child != NULL; child = child->sibling)
		{
		  struct type *type;
		  LONGEST value;
		  const gdb_byte *bytes;
		  struct dwarf2_locexpr_baton *baton;
		  struct value *v;

		  if (child->tag != DW_TAG_template_type_param
		      && child->tag != DW_TAG_template_value_param)
		    continue;

		  if (first)
		    {
		      fputs_unfiltered ("<", buf);
		      first = 0;
		    }
		  else
		    fputs_unfiltered (", ", buf);

		  attr = dwarf2_attr (child, DW_AT_type, cu);
		  if (attr == NULL)
		    {
		      complaint (&symfile_complaints,
				 _("template parameter missing DW_AT_type"));
		      fputs_unfiltered ("UNKNOWN_TYPE", buf);
		      continue;
		    }
		  type = die_type (child, cu);

		  if (child->tag == DW_TAG_template_type_param)
		    {
		      c_print_type (type, "", buf, -1, 0, &type_print_raw_options);
		      continue;
		    }

		  attr = dwarf2_attr (child, DW_AT_const_value, cu);
		  if (attr == NULL)
		    {
		      complaint (&symfile_complaints,
				 _("template parameter missing "
				   "DW_AT_const_value"));
		      fputs_unfiltered ("UNKNOWN_VALUE", buf);
		      continue;
		    }

		  dwarf2_const_value_attr (attr, type, name,
					   &cu->comp_unit_obstack, cu,
					   &value, &bytes, &baton);

		  if (TYPE_NOSIGN (type))
		    /* GDB prints characters as NUMBER 'CHAR'.  If that's
		       changed, this can use value_print instead.  */
		    c_printchar (value, type, buf);
		  else
		    {
		      struct value_print_options opts;

		      if (baton != NULL)
			v = dwarf2_evaluate_loc_desc (type, NULL,
						      baton->data,
						      baton->size,
						      baton->per_cu);
		      else if (bytes != NULL)
			{
			  v = allocate_value (type);
			  memcpy (value_contents_writeable (v), bytes,
				  TYPE_LENGTH (type));
			}
		      else
			v = value_from_longest (type, value);

		      /* Specify decimal so that we do not depend on
			 the radix.  */
		      get_formatted_print_options (&opts, 'd');
		      opts.raw = 1;
		      value_print (v, buf, &opts);
		      release_value (v);
		      value_free (v);
		    }
		}

	      die->building_fullname = 0;

	      if (!first)
		{
		  /* Close the argument list, with a space if necessary
		     (nested templates).  */
		  char last_char = '\0';
		  ui_file_put (buf, do_ui_file_peek_last, &last_char);
		  if (last_char == '>')
		    fputs_unfiltered (" >", buf);
		  else
		    fputs_unfiltered (">", buf);
		}
	    }

	  /* For Java and C++ methods, append formal parameter type
	     information, if PHYSNAME.  */

	  if (physname && die->tag == DW_TAG_subprogram
	      && (cu->language == language_cplus
		  || cu->language == language_java))
	    {
	      struct type *type = read_type_die (die, cu);

	      c_type_print_args (type, buf, 1, cu->language,
				 &type_print_raw_options);

	      if (cu->language == language_java)
		{
		  /* For java, we must append the return type to method
		     names.  */
		  if (die->tag == DW_TAG_subprogram)
		    java_print_type (TYPE_TARGET_TYPE (type), "", buf,
				     0, 0, &type_print_raw_options);
		}
	      else if (cu->language == language_cplus)
		{
		  /* Assume that an artificial first parameter is
		     "this", but do not crash if it is not.  RealView
		     marks unnamed (and thus unused) parameters as
		     artificial; there is no way to differentiate
		     the two cases.  */
		  if (TYPE_NFIELDS (type) > 0
		      && TYPE_FIELD_ARTIFICIAL (type, 0)
		      && TYPE_CODE (TYPE_FIELD_TYPE (type, 0)) == TYPE_CODE_PTR
		      && TYPE_CONST (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type,
									0))))
		    fputs_unfiltered (" const", buf);
		}
	    }

	  name = ui_file_obsavestring (buf, &objfile->objfile_obstack,
				       &length);
	  ui_file_delete (buf);

	  if (cu->language == language_cplus)
	    {
	      const char *cname
		= dwarf2_canonicalize_name (name, cu,
					    &objfile->objfile_obstack);

	      if (cname != NULL)
		name = cname;
	    }
	}
    }

  return name;
}

/* Return the fully qualified name of DIE, based on its DW_AT_name.
   If scope qualifiers are appropriate they will be added.  The result
   will be allocated on the objfile_obstack, or NULL if the DIE does
   not have a name.  NAME may either be from a previous call to
   dwarf2_name or NULL.

   The output string will be canonicalized (if C++/Java).  */

static const char *
dwarf2_full_name (const char *name, struct die_info *die, struct dwarf2_cu *cu)
{
  return dwarf2_compute_name (name, die, cu, 0);
}

/* Construct a physname for the given DIE in CU.  NAME may either be
   from a previous call to dwarf2_name or NULL.  The result will be
   allocated on the objfile_objstack or NULL if the DIE does not have a
   name.

   The output string will be canonicalized (if C++/Java).  */

static const char *
dwarf2_physname (const char *name, struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct attribute *attr;
  const char *retval, *mangled = NULL, *canon = NULL;
  struct cleanup *back_to;
  int need_copy = 1;

  /* In this case dwarf2_compute_name is just a shortcut not building anything
     on its own.  */
  if (!die_needs_namespace (die, cu))
    return dwarf2_compute_name (name, die, cu, 1);

  back_to = make_cleanup (null_cleanup, NULL);

  attr = dwarf2_attr (die, DW_AT_linkage_name, cu);
  if (!attr)
    attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);

  /* DW_AT_linkage_name is missing in some cases - depend on what GDB
     has computed.  */
  if (attr && DW_STRING (attr))
    {
      char *demangled;

      mangled = DW_STRING (attr);

      /* Use DMGL_RET_DROP for C++ template functions to suppress their return
	 type.  It is easier for GDB users to search for such functions as
	 `name(params)' than `long name(params)'.  In such case the minimal
	 symbol names do not match the full symbol names but for template
	 functions there is never a need to look up their definition from their
	 declaration so the only disadvantage remains the minimal symbol
	 variant `long name(params)' does not have the proper inferior type.
	 */

      if (cu->language == language_go)
	{
	  /* This is a lie, but we already lie to the caller new_symbol_full.
	     new_symbol_full assumes we return the mangled name.
	     This just undoes that lie until things are cleaned up.  */
	  demangled = NULL;
	}
      else
	{
	  demangled = gdb_demangle (mangled,
				    (DMGL_PARAMS | DMGL_ANSI
				     | (cu->language == language_java
					? DMGL_JAVA | DMGL_RET_POSTFIX
					: DMGL_RET_DROP)));
	}
      if (demangled)
	{
	  make_cleanup (xfree, demangled);
	  canon = demangled;
	}
      else
	{
	  canon = mangled;
	  need_copy = 0;
	}
    }

  if (canon == NULL || check_physname)
    {
      const char *physname = dwarf2_compute_name (name, die, cu, 1);

      if (canon != NULL && strcmp (physname, canon) != 0)
	{
	  /* It may not mean a bug in GDB.  The compiler could also
	     compute DW_AT_linkage_name incorrectly.  But in such case
	     GDB would need to be bug-to-bug compatible.  */

	  complaint (&symfile_complaints,
		     _("Computed physname <%s> does not match demangled <%s> "
		       "(from linkage <%s>) - DIE at 0x%x [in module %s]"),
		     physname, canon, mangled, die->offset.sect_off,
		     objfile_name (objfile));

	  /* Prefer DW_AT_linkage_name (in the CANON form) - when it
	     is available here - over computed PHYSNAME.  It is safer
	     against both buggy GDB and buggy compilers.  */

	  retval = canon;
	}
      else
	{
	  retval = physname;
	  need_copy = 0;
	}
    }
  else
    retval = canon;

  if (need_copy)
    retval = obstack_copy0 (&objfile->objfile_obstack, retval, strlen (retval));

  do_cleanups (back_to);
  return retval;
}

/* Read the import statement specified by the given die and record it.  */

static void
read_import_statement (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct attribute *import_attr;
  struct die_info *imported_die, *child_die;
  struct dwarf2_cu *imported_cu;
  const char *imported_name;
  const char *imported_name_prefix;
  const char *canonical_name;
  const char *import_alias;
  const char *imported_declaration = NULL;
  const char *import_prefix;
  VEC (const_char_ptr) *excludes = NULL;
  struct cleanup *cleanups;

  import_attr = dwarf2_attr (die, DW_AT_import, cu);
  if (import_attr == NULL)
    {
      complaint (&symfile_complaints, _("Tag '%s' has no DW_AT_import"),
		 dwarf_tag_name (die->tag));
      return;
    }

  imported_cu = cu;
  imported_die = follow_die_ref_or_sig (die, import_attr, &imported_cu);
  imported_name = dwarf2_name (imported_die, imported_cu);
  if (imported_name == NULL)
    {
      /* GCC bug: https://bugzilla.redhat.com/show_bug.cgi?id=506524

        The import in the following code:
        namespace A
          {
            typedef int B;
          }

        int main ()
          {
            using A::B;
            B b;
            return b;
          }

        ...
         <2><51>: Abbrev Number: 3 (DW_TAG_imported_declaration)
            <52>   DW_AT_decl_file   : 1
            <53>   DW_AT_decl_line   : 6
            <54>   DW_AT_import      : <0x75>
         <2><58>: Abbrev Number: 4 (DW_TAG_typedef)
            <59>   DW_AT_name        : B
            <5b>   DW_AT_decl_file   : 1
            <5c>   DW_AT_decl_line   : 2
            <5d>   DW_AT_type        : <0x6e>
        ...
         <1><75>: Abbrev Number: 7 (DW_TAG_base_type)
            <76>   DW_AT_byte_size   : 4
            <77>   DW_AT_encoding    : 5        (signed)

        imports the wrong die ( 0x75 instead of 0x58 ).
        This case will be ignored until the gcc bug is fixed.  */
      return;
    }

  /* Figure out the local name after import.  */
  import_alias = dwarf2_name (die, cu);

  /* Figure out where the statement is being imported to.  */
  import_prefix = determine_prefix (die, cu);

  /* Figure out what the scope of the imported die is and prepend it
     to the name of the imported die.  */
  imported_name_prefix = determine_prefix (imported_die, imported_cu);

  if (imported_die->tag != DW_TAG_namespace
      && imported_die->tag != DW_TAG_module)
    {
      imported_declaration = imported_name;
      canonical_name = imported_name_prefix;
    }
  else if (strlen (imported_name_prefix) > 0)
    canonical_name = obconcat (&objfile->objfile_obstack,
			       imported_name_prefix, "::", imported_name,
			       (char *) NULL);
  else
    canonical_name = imported_name;

  cleanups = make_cleanup (VEC_cleanup (const_char_ptr), &excludes);

  if (die->tag == DW_TAG_imported_module && cu->language == language_fortran)
    for (child_die = die->child; child_die && child_die->tag;
	 child_die = sibling_die (child_die))
      {
	/* DWARF-4: A Fortran use statement with a “rename list” may be
	   represented by an imported module entry with an import attribute
	   referring to the module and owned entries corresponding to those
	   entities that are renamed as part of being imported.  */

	if (child_die->tag != DW_TAG_imported_declaration)
	  {
	    complaint (&symfile_complaints,
		       _("child DW_TAG_imported_declaration expected "
			 "- DIE at 0x%x [in module %s]"),
		       child_die->offset.sect_off, objfile_name (objfile));
	    continue;
	  }

	import_attr = dwarf2_attr (child_die, DW_AT_import, cu);
	if (import_attr == NULL)
	  {
	    complaint (&symfile_complaints, _("Tag '%s' has no DW_AT_import"),
		       dwarf_tag_name (child_die->tag));
	    continue;
	  }

	imported_cu = cu;
	imported_die = follow_die_ref_or_sig (child_die, import_attr,
					      &imported_cu);
	imported_name = dwarf2_name (imported_die, imported_cu);
	if (imported_name == NULL)
	  {
	    complaint (&symfile_complaints,
		       _("child DW_TAG_imported_declaration has unknown "
			 "imported name - DIE at 0x%x [in module %s]"),
		       child_die->offset.sect_off, objfile_name (objfile));
	    continue;
	  }

	VEC_safe_push (const_char_ptr, excludes, imported_name);

	process_die (child_die, cu);
      }

  cp_add_using_directive (import_prefix,
                          canonical_name,
                          import_alias,
                          imported_declaration,
			  excludes,
			  0,
                          &objfile->objfile_obstack);

  do_cleanups (cleanups);
}

/* Cleanup function for handle_DW_AT_stmt_list.  */

static void
free_cu_line_header (void *arg)
{
  struct dwarf2_cu *cu = arg;

  free_line_header (cu->line_header);
  cu->line_header = NULL;
}

/* Check for possibly missing DW_AT_comp_dir with relative .debug_line
   directory paths.  GCC SVN r127613 (new option -fdebug-prefix-map) fixed
   this, it was first present in GCC release 4.3.0.  */

static int
producer_is_gcc_lt_4_3 (struct dwarf2_cu *cu)
{
  if (!cu->checked_producer)
    check_producer (cu);

  return cu->producer_is_gcc_lt_4_3;
}

static void
find_file_and_directory (struct die_info *die, struct dwarf2_cu *cu,
			 const char **name, const char **comp_dir)
{
  struct attribute *attr;

  *name = NULL;
  *comp_dir = NULL;

  /* Find the filename.  Do not use dwarf2_name here, since the filename
     is not a source language identifier.  */
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr)
    {
      *name = DW_STRING (attr);
    }

  attr = dwarf2_attr (die, DW_AT_comp_dir, cu);
  if (attr)
    *comp_dir = DW_STRING (attr);
  else if (producer_is_gcc_lt_4_3 (cu) && *name != NULL
	   && IS_ABSOLUTE_PATH (*name))
    {
      char *d = ldirname (*name);

      *comp_dir = d;
      if (d != NULL)
	make_cleanup (xfree, d);
    }
  if (*comp_dir != NULL)
    {
      /* Irix 6.2 native cc prepends <machine>.: to the compilation
	 directory, get rid of it.  */
      char *cp = strchr (*comp_dir, ':');

      if (cp && cp != *comp_dir && cp[-1] == '.' && cp[1] == '/')
	*comp_dir = cp + 1;
    }

  if (*name == NULL)
    *name = "<unknown>";
}

/* Handle DW_AT_stmt_list for a compilation unit.
   DIE is the DW_TAG_compile_unit die for CU.
   COMP_DIR is the compilation directory.
   WANT_LINE_INFO is non-zero if the pc/line-number mapping is needed.  */

static void
handle_DW_AT_stmt_list (struct die_info *die, struct dwarf2_cu *cu,
			const char *comp_dir) /* ARI: editCase function */
{
  struct attribute *attr;

  gdb_assert (! cu->per_cu->is_debug_types);

  attr = dwarf2_attr (die, DW_AT_stmt_list, cu);
  if (attr)
    {
      unsigned int line_offset = DW_UNSND (attr);
      struct line_header *line_header
	= dwarf_decode_line_header (line_offset, cu);

      if (line_header)
	{
	  cu->line_header = line_header;
	  make_cleanup (free_cu_line_header, cu);
	  dwarf_decode_lines (line_header, comp_dir, cu, NULL, 1);
	}
    }
}

/* Process DW_TAG_compile_unit or DW_TAG_partial_unit.  */

static void
read_file_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
  CORE_ADDR lowpc = ((CORE_ADDR) -1);
  CORE_ADDR highpc = ((CORE_ADDR) 0);
  struct attribute *attr;
  const char *name = NULL;
  const char *comp_dir = NULL;
  struct die_info *child_die;
  bfd *abfd = objfile->obfd;
  CORE_ADDR baseaddr;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  get_scope_pc_bounds (die, &lowpc, &highpc, cu);

  /* If we didn't find a lowpc, set it to highpc to avoid complaints
     from finish_block.  */
  if (lowpc == ((CORE_ADDR) -1))
    lowpc = highpc;
  lowpc += baseaddr;
  highpc += baseaddr;

  find_file_and_directory (die, cu, &name, &comp_dir);

  prepare_one_comp_unit (cu, die, cu->language);

  /* The XLCL doesn't generate DW_LANG_OpenCL because this attribute is not
     standardised yet.  As a workaround for the language detection we fall
     back to the DW_AT_producer string.  */
  if (cu->producer && strstr (cu->producer, "IBM XL C for OpenCL") != NULL)
    cu->language = language_opencl;

  /* Similar hack for Go.  */
  if (cu->producer && strstr (cu->producer, "GNU Go ") != NULL)
    set_cu_language (DW_LANG_Go, cu);

  dwarf2_start_symtab (cu, name, comp_dir, lowpc);

  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.  */
  handle_DW_AT_stmt_list (die, cu, comp_dir);

  /* Process all dies in compilation unit.  */
  if (die->child != NULL)
    {
      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  process_die (child_die, cu);
	  child_die = sibling_die (child_die);
	}
    }

  /* Decode macro information, if present.  Dwarf 2 macro information
     refers to information in the line number info statement program
     header, so we can only read it if we've read the header
     successfully.  */
  attr = dwarf2_attr (die, DW_AT_GNU_macros, cu);
  if (attr && cu->line_header)
    {
      if (dwarf2_attr (die, DW_AT_macro_info, cu))
	complaint (&symfile_complaints,
		   _("CU refers to both DW_AT_GNU_macros and DW_AT_macro_info"));

      dwarf_decode_macros (cu, DW_UNSND (attr), comp_dir, 1);
    }
  else
    {
      attr = dwarf2_attr (die, DW_AT_macro_info, cu);
      if (attr && cu->line_header)
	{
	  unsigned int macro_offset = DW_UNSND (attr);

	  dwarf_decode_macros (cu, macro_offset, comp_dir, 0);
	}
    }

  do_cleanups (back_to);
}

/* TU version of handle_DW_AT_stmt_list for read_type_unit_scope.
   Create the set of symtabs used by this TU, or if this TU is sharing
   symtabs with another TU and the symtabs have already been created
   then restore those symtabs in the line header.
   We don't need the pc/line-number mapping for type units.  */

static void
setup_type_unit_groups (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_per_cu_data *per_cu = cu->per_cu;
  struct type_unit_group *tu_group;
  int first_time;
  struct line_header *lh;
  struct attribute *attr;
  unsigned int i, line_offset;
  struct signatured_type *sig_type;

  gdb_assert (per_cu->is_debug_types);
  sig_type = (struct signatured_type *) per_cu;

  attr = dwarf2_attr (die, DW_AT_stmt_list, cu);

  /* If we're using .gdb_index (includes -readnow) then
     per_cu->type_unit_group may not have been set up yet.  */
  if (sig_type->type_unit_group == NULL)
    sig_type->type_unit_group = get_type_unit_group (cu, attr);
  tu_group = sig_type->type_unit_group;

  /* If we've already processed this stmt_list there's no real need to
     do it again, we could fake it and just recreate the part we need
     (file name,index -> symtab mapping).  If data shows this optimization
     is useful we can do it then.  */
  first_time = tu_group->primary_symtab == NULL;

  /* We have to handle the case of both a missing DW_AT_stmt_list or bad
     debug info.  */
  lh = NULL;
  if (attr != NULL)
    {
      line_offset = DW_UNSND (attr);
      lh = dwarf_decode_line_header (line_offset, cu);
    }
  if (lh == NULL)
    {
      if (first_time)
	dwarf2_start_symtab (cu, "", NULL, 0);
      else
	{
	  gdb_assert (tu_group->symtabs == NULL);
	  restart_symtab (0);
	}
      /* Note: The primary symtab will get allocated at the end.  */
      return;
    }

  cu->line_header = lh;
  make_cleanup (free_cu_line_header, cu);

  if (first_time)
    {
      dwarf2_start_symtab (cu, "", NULL, 0);

      tu_group->num_symtabs = lh->num_file_names;
      tu_group->symtabs = XNEWVEC (struct symtab *, lh->num_file_names);

      for (i = 0; i < lh->num_file_names; ++i)
	{
	  const char *dir = NULL;
	  struct file_entry *fe = &lh->file_names[i];

	  if (fe->dir_index)
	    dir = lh->include_dirs[fe->dir_index - 1];
	  dwarf2_start_subfile (fe->name, dir, NULL);

	  /* Note: We don't have to watch for the main subfile here, type units
	     don't have DW_AT_name.  */

	  if (current_subfile->symtab == NULL)
	    {
	      /* NOTE: start_subfile will recognize when it's been passed
		 a file it has already seen.  So we can't assume there's a
		 simple mapping from lh->file_names to subfiles,
		 lh->file_names may contain dups.  */
	      current_subfile->symtab = allocate_symtab (current_subfile->name,
							 objfile);
	    }

	  fe->symtab = current_subfile->symtab;
	  tu_group->symtabs[i] = fe->symtab;
	}
    }
  else
    {
      restart_symtab (0);

      for (i = 0; i < lh->num_file_names; ++i)
	{
	  struct file_entry *fe = &lh->file_names[i];

	  fe->symtab = tu_group->symtabs[i];
	}
    }

  /* The main symtab is allocated last.  Type units don't have DW_AT_name
     so they don't have a "real" (so to speak) symtab anyway.
     There is later code that will assign the main symtab to all symbols
     that don't have one.  We need to handle the case of a symbol with a
     missing symtab (DW_AT_decl_file) anyway.  */
}

/* Process DW_TAG_type_unit.
   For TUs we want to skip the first top level sibling if it's not the
   actual type being defined by this TU.  In this case the first top
   level sibling is there to provide context only.  */

static void
read_type_unit_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *child_die;

  prepare_one_comp_unit (cu, die, language_minimal);

  /* Initialize (or reinitialize) the machinery for building symtabs.
     We do this before processing child DIEs, so that the line header table
     is available for DW_AT_decl_file.  */
  setup_type_unit_groups (die, cu);

  if (die->child != NULL)
    {
      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  process_die (child_die, cu);
	  child_die = sibling_die (child_die);
	}
    }
}

/* DWO/DWP files.

   http://gcc.gnu.org/wiki/DebugFission
   http://gcc.gnu.org/wiki/DebugFissionDWP

   To simplify handling of both DWO files ("object" files with the DWARF info)
   and DWP files (a file with the DWOs packaged up into one file), we treat
   DWP files as having a collection of virtual DWO files.  */

static hashval_t
hash_dwo_file (const void *item)
{
  const struct dwo_file *dwo_file = item;
  hashval_t hash;

  hash = htab_hash_string (dwo_file->dwo_name);
  if (dwo_file->comp_dir != NULL)
    hash += htab_hash_string (dwo_file->comp_dir);
  return hash;
}

static int
eq_dwo_file (const void *item_lhs, const void *item_rhs)
{
  const struct dwo_file *lhs = item_lhs;
  const struct dwo_file *rhs = item_rhs;

  if (strcmp (lhs->dwo_name, rhs->dwo_name) != 0)
    return 0;
  if (lhs->comp_dir == NULL || rhs->comp_dir == NULL)
    return lhs->comp_dir == rhs->comp_dir;
  return strcmp (lhs->comp_dir, rhs->comp_dir) == 0;
}

/* Allocate a hash table for DWO files.  */

static htab_t
allocate_dwo_file_hash_table (void)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;

  return htab_create_alloc_ex (41,
			       hash_dwo_file,
			       eq_dwo_file,
			       NULL,
			       &objfile->objfile_obstack,
			       hashtab_obstack_allocate,
			       dummy_obstack_deallocate);
}

/* Lookup DWO file DWO_NAME.  */

static void **
lookup_dwo_file_slot (const char *dwo_name, const char *comp_dir)
{
  struct dwo_file find_entry;
  void **slot;

  if (dwarf2_per_objfile->dwo_files == NULL)
    dwarf2_per_objfile->dwo_files = allocate_dwo_file_hash_table ();

  memset (&find_entry, 0, sizeof (find_entry));
  find_entry.dwo_name = dwo_name;
  find_entry.comp_dir = comp_dir;
  slot = htab_find_slot (dwarf2_per_objfile->dwo_files, &find_entry, INSERT);

  return slot;
}

static hashval_t
hash_dwo_unit (const void *item)
{
  const struct dwo_unit *dwo_unit = item;

  /* This drops the top 32 bits of the id, but is ok for a hash.  */
  return dwo_unit->signature;
}

static int
eq_dwo_unit (const void *item_lhs, const void *item_rhs)
{
  const struct dwo_unit *lhs = item_lhs;
  const struct dwo_unit *rhs = item_rhs;

  /* The signature is assumed to be unique within the DWO file.
     So while object file CU dwo_id's always have the value zero,
     that's OK, assuming each object file DWO file has only one CU,
     and that's the rule for now.  */
  return lhs->signature == rhs->signature;
}

/* Allocate a hash table for DWO CUs,TUs.
   There is one of these tables for each of CUs,TUs for each DWO file.  */

static htab_t
allocate_dwo_unit_table (struct objfile *objfile)
{
  /* Start out with a pretty small number.
     Generally DWO files contain only one CU and maybe some TUs.  */
  return htab_create_alloc_ex (3,
			       hash_dwo_unit,
			       eq_dwo_unit,
			       NULL,
			       &objfile->objfile_obstack,
			       hashtab_obstack_allocate,
			       dummy_obstack_deallocate);
}

/* Structure used to pass data to create_dwo_debug_info_hash_table_reader.  */

struct create_dwo_cu_data
{
  struct dwo_file *dwo_file;
  struct dwo_unit dwo_unit;
};

/* die_reader_func for create_dwo_cu.  */

static void
create_dwo_cu_reader (const struct die_reader_specs *reader,
		      const gdb_byte *info_ptr,
		      struct die_info *comp_unit_die,
		      int has_children,
		      void *datap)
{
  struct dwarf2_cu *cu = reader->cu;
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  sect_offset offset = cu->per_cu->offset;
  struct dwarf2_section_info *section = cu->per_cu->section;
  struct create_dwo_cu_data *data = datap;
  struct dwo_file *dwo_file = data->dwo_file;
  struct dwo_unit *dwo_unit = &data->dwo_unit;
  struct attribute *attr;

  attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_dwo_id, cu);
  if (attr == NULL)
    {
      complaint (&symfile_complaints,
		 _("Dwarf Error: debug entry at offset 0x%x is missing"
		   " its dwo_id [in module %s]"),
		 offset.sect_off, dwo_file->dwo_name);
      return;
    }

  dwo_unit->dwo_file = dwo_file;
  dwo_unit->signature = DW_UNSND (attr);
  dwo_unit->section = section;
  dwo_unit->offset = offset;
  dwo_unit->length = cu->per_cu->length;

  if (dwarf2_read_debug)
    fprintf_unfiltered (gdb_stdlog, "  offset 0x%x, dwo_id %s\n",
			offset.sect_off, hex_string (dwo_unit->signature));
}

/* Create the dwo_unit for the lone CU in DWO_FILE.
   Note: This function processes DWO files only, not DWP files.  */

static struct dwo_unit *
create_dwo_cu (struct dwo_file *dwo_file)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_section_info *section = &dwo_file->sections.info;
  bfd *abfd;
  htab_t cu_htab;
  const gdb_byte *info_ptr, *end_ptr;
  struct create_dwo_cu_data create_dwo_cu_data;
  struct dwo_unit *dwo_unit;

  dwarf2_read_section (objfile, section);
  info_ptr = section->buffer;

  if (info_ptr == NULL)
    return NULL;

  /* We can't set abfd until now because the section may be empty or
     not present, in which case section->asection will be NULL.  */
  abfd = get_section_bfd_owner (section);

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Reading %s for %s:\n",
			  get_section_name (section),
			  get_section_file_name (section));
    }

  create_dwo_cu_data.dwo_file = dwo_file;
  dwo_unit = NULL;

  end_ptr = info_ptr + section->size;
  while (info_ptr < end_ptr)
    {
      struct dwarf2_per_cu_data per_cu;

      memset (&create_dwo_cu_data.dwo_unit, 0,
	      sizeof (create_dwo_cu_data.dwo_unit));
      memset (&per_cu, 0, sizeof (per_cu));
      per_cu.objfile = objfile;
      per_cu.is_debug_types = 0;
      per_cu.offset.sect_off = info_ptr - section->buffer;
      per_cu.section = section;

      init_cutu_and_read_dies_no_follow (&per_cu,
					 &dwo_file->sections.abbrev,
					 dwo_file,
					 create_dwo_cu_reader,
					 &create_dwo_cu_data);

      if (create_dwo_cu_data.dwo_unit.dwo_file != NULL)
	{
	  /* If we've already found one, complain.  We only support one
	     because having more than one requires hacking the dwo_name of
	     each to match, which is highly unlikely to happen.  */
	  if (dwo_unit != NULL)
	    {
	      complaint (&symfile_complaints,
			 _("Multiple CUs in DWO file %s [in module %s]"),
			 dwo_file->dwo_name, objfile_name (objfile));
	      break;
	    }

	  dwo_unit = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_unit);
	  *dwo_unit = create_dwo_cu_data.dwo_unit;
	}

      info_ptr += per_cu.length;
    }

  return dwo_unit;
}

/* DWP file .debug_{cu,tu}_index section format:
   [ref: http://gcc.gnu.org/wiki/DebugFissionDWP]

   DWP Version 1:

   Both index sections have the same format, and serve to map a 64-bit
   signature to a set of section numbers.  Each section begins with a header,
   followed by a hash table of 64-bit signatures, a parallel table of 32-bit
   indexes, and a pool of 32-bit section numbers.  The index sections will be
   aligned at 8-byte boundaries in the file.

   The index section header consists of:

    V, 32 bit version number
    -, 32 bits unused
    N, 32 bit number of compilation units or type units in the index
    M, 32 bit number of slots in the hash table

   Numbers are recorded using the byte order of the application binary.

   The hash table begins at offset 16 in the section, and consists of an array
   of M 64-bit slots.  Each slot contains a 64-bit signature (using the byte
   order of the application binary).  Unused slots in the hash table are 0.
   (We rely on the extreme unlikeliness of a signature being exactly 0.)

   The parallel table begins immediately after the hash table
   (at offset 16 + 8 * M from the beginning of the section), and consists of an
   array of 32-bit indexes (using the byte order of the application binary),
   corresponding 1-1 with slots in the hash table.  Each entry in the parallel
   table contains a 32-bit index into the pool of section numbers.  For unused
   hash table slots, the corresponding entry in the parallel table will be 0.

   The pool of section numbers begins immediately following the hash table
   (at offset 16 + 12 * M from the beginning of the section).  The pool of
   section numbers consists of an array of 32-bit words (using the byte order
   of the application binary).  Each item in the array is indexed starting
   from 0.  The hash table entry provides the index of the first section
   number in the set.  Additional section numbers in the set follow, and the
   set is terminated by a 0 entry (section number 0 is not used in ELF).

   In each set of section numbers, the .debug_info.dwo or .debug_types.dwo
   section must be the first entry in the set, and the .debug_abbrev.dwo must
   be the second entry. Other members of the set may follow in any order.

   ---

   DWP Version 2:

   DWP Version 2 combines all the .debug_info, etc. sections into one,
   and the entries in the index tables are now offsets into these sections.
   CU offsets begin at 0.  TU offsets begin at the size of the .debug_info
   section.

   Index Section Contents:
    Header
    Hash Table of Signatures   dwp_hash_table.hash_table
    Parallel Table of Indices  dwp_hash_table.unit_table
    Table of Section Offsets   dwp_hash_table.v2.{section_ids,offsets}
    Table of Section Sizes     dwp_hash_table.v2.sizes

   The index section header consists of:

    V, 32 bit version number
    L, 32 bit number of columns in the table of section offsets
    N, 32 bit number of compilation units or type units in the index
    M, 32 bit number of slots in the hash table

   Numbers are recorded using the byte order of the application binary.

   The hash table has the same format as version 1.
   The parallel table of indices has the same format as version 1,
   except that the entries are origin-1 indices into the table of sections
   offsets and the table of section sizes.

   The table of offsets begins immediately following the parallel table
   (at offset 16 + 12 * M from the beginning of the section).  The table is
   a two-dimensional array of 32-bit words (using the byte order of the
   application binary), with L columns and N+1 rows, in row-major order.
   Each row in the array is indexed starting from 0.  The first row provides
   a key to the remaining rows: each column in this row provides an identifier
   for a debug section, and the offsets in the same column of subsequent rows
   refer to that section.  The section identifiers are:

    DW_SECT_INFO         1  .debug_info.dwo
    DW_SECT_TYPES        2  .debug_types.dwo
    DW_SECT_ABBREV       3  .debug_abbrev.dwo
    DW_SECT_LINE         4  .debug_line.dwo
    DW_SECT_LOC          5  .debug_loc.dwo
    DW_SECT_STR_OFFSETS  6  .debug_str_offsets.dwo
    DW_SECT_MACINFO      7  .debug_macinfo.dwo
    DW_SECT_MACRO        8  .debug_macro.dwo

   The offsets provided by the CU and TU index sections are the base offsets
   for the contributions made by each CU or TU to the corresponding section
   in the package file.  Each CU and TU header contains an abbrev_offset
   field, used to find the abbreviations table for that CU or TU within the
   contribution to the .debug_abbrev.dwo section for that CU or TU, and should
   be interpreted as relative to the base offset given in the index section.
   Likewise, offsets into .debug_line.dwo from DW_AT_stmt_list attributes
   should be interpreted as relative to the base offset for .debug_line.dwo,
   and offsets into other debug sections obtained from DWARF attributes should
   also be interpreted as relative to the corresponding base offset.

   The table of sizes begins immediately following the table of offsets.
   Like the table of offsets, it is a two-dimensional array of 32-bit words,
   with L columns and N rows, in row-major order.  Each row in the array is
   indexed starting from 1 (row 0 is shared by the two tables).

   ---

   Hash table lookup is handled the same in version 1 and 2:

   We assume that N and M will not exceed 2^32 - 1.
   The size of the hash table, M, must be 2^k such that 2^k > 3*N/2.

   Given a 64-bit compilation unit signature or a type signature S, an entry
   in the hash table is located as follows:

   1) Calculate a primary hash H = S & MASK(k), where MASK(k) is a mask with
      the low-order k bits all set to 1.

   2) Calculate a secondary hash H' = (((S >> 32) & MASK(k)) | 1).

   3) If the hash table entry at index H matches the signature, use that
      entry.  If the hash table entry at index H is unused (all zeroes),
      terminate the search: the signature is not present in the table.

   4) Let H = (H + H') modulo M. Repeat at Step 3.

   Because M > N and H' and M are relatively prime, the search is guaranteed
   to stop at an unused slot or find the match.  */

/* Create a hash table to map DWO IDs to their CU/TU entry in
   .debug_{info,types}.dwo in DWP_FILE.
   Returns NULL if there isn't one.
   Note: This function processes DWP files only, not DWO files.  */

static struct dwp_hash_table *
create_dwp_hash_table (struct dwp_file *dwp_file, int is_debug_types)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  bfd *dbfd = dwp_file->dbfd;
  const gdb_byte *index_ptr, *index_end;
  struct dwarf2_section_info *index;
  uint32_t version, nr_columns, nr_units, nr_slots;
  struct dwp_hash_table *htab;

  if (is_debug_types)
    index = &dwp_file->sections.tu_index;
  else
    index = &dwp_file->sections.cu_index;

  if (dwarf2_section_empty_p (index))
    return NULL;
  dwarf2_read_section (objfile, index);

  index_ptr = index->buffer;
  index_end = index_ptr + index->size;

  version = read_4_bytes (dbfd, index_ptr);
  index_ptr += 4;
  if (version == 2)
    nr_columns = read_4_bytes (dbfd, index_ptr);
  else
    nr_columns = 0;
  index_ptr += 4;
  nr_units = read_4_bytes (dbfd, index_ptr);
  index_ptr += 4;
  nr_slots = read_4_bytes (dbfd, index_ptr);
  index_ptr += 4;

  if (version != 1 && version != 2)
    {
      error (_("Dwarf Error: unsupported DWP file version (%s)"
	       " [in module %s]"),
	     pulongest (version), dwp_file->name);
    }
  if (nr_slots != (nr_slots & -nr_slots))
    {
      error (_("Dwarf Error: number of slots in DWP hash table (%s)"
	       " is not power of 2 [in module %s]"),
	     pulongest (nr_slots), dwp_file->name);
    }

  htab = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwp_hash_table);
  htab->version = version;
  htab->nr_columns = nr_columns;
  htab->nr_units = nr_units;
  htab->nr_slots = nr_slots;
  htab->hash_table = index_ptr;
  htab->unit_table = htab->hash_table + sizeof (uint64_t) * nr_slots;

  /* Exit early if the table is empty.  */
  if (nr_slots == 0 || nr_units == 0
      || (version == 2 && nr_columns == 0))
    {
      /* All must be zero.  */
      if (nr_slots != 0 || nr_units != 0
	  || (version == 2 && nr_columns != 0))
	{
	  complaint (&symfile_complaints,
		     _("Empty DWP but nr_slots,nr_units,nr_columns not"
		       " all zero [in modules %s]"),
		     dwp_file->name);
	}
      return htab;
    }

  if (version == 1)
    {
      htab->section_pool.v1.indices =
	htab->unit_table + sizeof (uint32_t) * nr_slots;
      /* It's harder to decide whether the section is too small in v1.
	 V1 is deprecated anyway so we punt.  */
    }
  else
    {
      const gdb_byte *ids_ptr = htab->unit_table + sizeof (uint32_t) * nr_slots;
      int *ids = htab->section_pool.v2.section_ids;
      /* Reverse map for error checking.  */
      int ids_seen[DW_SECT_MAX + 1];
      int i;

      if (nr_columns < 2)
	{
	  error (_("Dwarf Error: bad DWP hash table, too few columns"
		   " in section table [in module %s]"),
		 dwp_file->name);
	}
      if (nr_columns > MAX_NR_V2_DWO_SECTIONS)
	{
	  error (_("Dwarf Error: bad DWP hash table, too many columns"
		   " in section table [in module %s]"),
		 dwp_file->name);
	}
      memset (ids, 255, (DW_SECT_MAX + 1) * sizeof (int32_t));
      memset (ids_seen, 255, (DW_SECT_MAX + 1) * sizeof (int32_t));
      for (i = 0; i < nr_columns; ++i)
	{
	  int id = read_4_bytes (dbfd, ids_ptr + i * sizeof (uint32_t));

	  if (id < DW_SECT_MIN || id > DW_SECT_MAX)
	    {
	      error (_("Dwarf Error: bad DWP hash table, bad section id %d"
		       " in section table [in module %s]"),
		     id, dwp_file->name);
	    }
	  if (ids_seen[id] != -1)
	    {
	      error (_("Dwarf Error: bad DWP hash table, duplicate section"
		       " id %d in section table [in module %s]"),
		     id, dwp_file->name);
	    }
	  ids_seen[id] = i;
	  ids[i] = id;
	}
      /* Must have exactly one info or types section.  */
      if (((ids_seen[DW_SECT_INFO] != -1)
	   + (ids_seen[DW_SECT_TYPES] != -1))
	  != 1)
	{
	  error (_("Dwarf Error: bad DWP hash table, missing/duplicate"
		   " DWO info/types section [in module %s]"),
		 dwp_file->name);
	}
      /* Must have an abbrev section.  */
      if (ids_seen[DW_SECT_ABBREV] == -1)
	{
	  error (_("Dwarf Error: bad DWP hash table, missing DWO abbrev"
		   " section [in module %s]"),
		 dwp_file->name);
	}
      htab->section_pool.v2.offsets = ids_ptr + sizeof (uint32_t) * nr_columns;
      htab->section_pool.v2.sizes =
	htab->section_pool.v2.offsets + (sizeof (uint32_t)
					 * nr_units * nr_columns);
      if ((htab->section_pool.v2.sizes + (sizeof (uint32_t)
					  * nr_units * nr_columns))
	  > index_end)
	{
	  error (_("Dwarf Error: DWP index section is corrupt (too small)"
		   " [in module %s]"),
		 dwp_file->name);
	}
    }

  return htab;
}

/* Update SECTIONS with the data from SECTP.

   This function is like the other "locate" section routines that are
   passed to bfd_map_over_sections, but in this context the sections to
   read comes from the DWP V1 hash table, not the full ELF section table.

   The result is non-zero for success, or zero if an error was found.  */

static int
locate_v1_virtual_dwo_sections (asection *sectp,
				struct virtual_v1_dwo_sections *sections)
{
  const struct dwop_section_names *names = &dwop_section_names;

  if (section_is_p (sectp->name, &names->abbrev_dwo))
    {
      /* There can be only one.  */
      if (sections->abbrev.s.asection != NULL)
	return 0;
      sections->abbrev.s.asection = sectp;
      sections->abbrev.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->info_dwo)
	   || section_is_p (sectp->name, &names->types_dwo))
    {
      /* There can be only one.  */
      if (sections->info_or_types.s.asection != NULL)
	return 0;
      sections->info_or_types.s.asection = sectp;
      sections->info_or_types.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->line_dwo))
    {
      /* There can be only one.  */
      if (sections->line.s.asection != NULL)
	return 0;
      sections->line.s.asection = sectp;
      sections->line.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->loc_dwo))
    {
      /* There can be only one.  */
      if (sections->loc.s.asection != NULL)
	return 0;
      sections->loc.s.asection = sectp;
      sections->loc.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macinfo_dwo))
    {
      /* There can be only one.  */
      if (sections->macinfo.s.asection != NULL)
	return 0;
      sections->macinfo.s.asection = sectp;
      sections->macinfo.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macro_dwo))
    {
      /* There can be only one.  */
      if (sections->macro.s.asection != NULL)
	return 0;
      sections->macro.s.asection = sectp;
      sections->macro.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->str_offsets_dwo))
    {
      /* There can be only one.  */
      if (sections->str_offsets.s.asection != NULL)
	return 0;
      sections->str_offsets.s.asection = sectp;
      sections->str_offsets.size = bfd_get_section_size (sectp);
    }
  else
    {
      /* No other kind of section is valid.  */
      return 0;
    }

  return 1;
}

/* Create a dwo_unit object for the DWO unit with signature SIGNATURE.
   UNIT_INDEX is the index of the DWO unit in the DWP hash table.
   COMP_DIR is the DW_AT_comp_dir attribute of the referencing CU.
   This is for DWP version 1 files.  */

static struct dwo_unit *
create_dwo_unit_in_dwp_v1 (struct dwp_file *dwp_file,
			   uint32_t unit_index,
			   const char *comp_dir,
			   ULONGEST signature, int is_debug_types)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  const struct dwp_hash_table *dwp_htab =
    is_debug_types ? dwp_file->tus : dwp_file->cus;
  bfd *dbfd = dwp_file->dbfd;
  const char *kind = is_debug_types ? "TU" : "CU";
  struct dwo_file *dwo_file;
  struct dwo_unit *dwo_unit;
  struct virtual_v1_dwo_sections sections;
  void **dwo_file_slot;
  char *virtual_dwo_name;
  struct dwarf2_section_info *cutu;
  struct cleanup *cleanups;
  int i;

  gdb_assert (dwp_file->version == 1);

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Reading %s %s/%s in DWP V1 file: %s\n",
			  kind,
			  pulongest (unit_index), hex_string (signature),
			  dwp_file->name);
    }

  /* Fetch the sections of this DWO unit.
     Put a limit on the number of sections we look for so that bad data
     doesn't cause us to loop forever.  */

#define MAX_NR_V1_DWO_SECTIONS \
  (1 /* .debug_info or .debug_types */ \
   + 1 /* .debug_abbrev */ \
   + 1 /* .debug_line */ \
   + 1 /* .debug_loc */ \
   + 1 /* .debug_str_offsets */ \
   + 1 /* .debug_macro or .debug_macinfo */ \
   + 1 /* trailing zero */)

  memset (&sections, 0, sizeof (sections));
  cleanups = make_cleanup (null_cleanup, 0);

  for (i = 0; i < MAX_NR_V1_DWO_SECTIONS; ++i)
    {
      asection *sectp;
      uint32_t section_nr =
	read_4_bytes (dbfd,
		      dwp_htab->section_pool.v1.indices
		      + (unit_index + i) * sizeof (uint32_t));

      if (section_nr == 0)
	break;
      if (section_nr >= dwp_file->num_sections)
	{
	  error (_("Dwarf Error: bad DWP hash table, section number too large"
		   " [in module %s]"),
		 dwp_file->name);
	}

      sectp = dwp_file->elf_sections[section_nr];
      if (! locate_v1_virtual_dwo_sections (sectp, &sections))
	{
	  error (_("Dwarf Error: bad DWP hash table, invalid section found"
		   " [in module %s]"),
		 dwp_file->name);
	}
    }

  if (i < 2
      || dwarf2_section_empty_p (&sections.info_or_types)
      || dwarf2_section_empty_p (&sections.abbrev))
    {
      error (_("Dwarf Error: bad DWP hash table, missing DWO sections"
	       " [in module %s]"),
	     dwp_file->name);
    }
  if (i == MAX_NR_V1_DWO_SECTIONS)
    {
      error (_("Dwarf Error: bad DWP hash table, too many DWO sections"
	       " [in module %s]"),
	     dwp_file->name);
    }

  /* It's easier for the rest of the code if we fake a struct dwo_file and
     have dwo_unit "live" in that.  At least for now.

     The DWP file can be made up of a random collection of CUs and TUs.
     However, for each CU + set of TUs that came from the same original DWO
     file, we can combine them back into a virtual DWO file to save space
     (fewer struct dwo_file objects to allocate).  Remember that for really
     large apps there can be on the order of 8K CUs and 200K TUs, or more.  */

  virtual_dwo_name =
    xstrprintf ("virtual-dwo/%d-%d-%d-%d",
		get_section_id (&sections.abbrev),
		get_section_id (&sections.line),
		get_section_id (&sections.loc),
		get_section_id (&sections.str_offsets));
  make_cleanup (xfree, virtual_dwo_name);
  /* Can we use an existing virtual DWO file?  */
  dwo_file_slot = lookup_dwo_file_slot (virtual_dwo_name, comp_dir);
  /* Create one if necessary.  */
  if (*dwo_file_slot == NULL)
    {
      if (dwarf2_read_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "Creating virtual DWO: %s\n",
			      virtual_dwo_name);
	}
      dwo_file = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_file);
      dwo_file->dwo_name = obstack_copy0 (&objfile->objfile_obstack,
					  virtual_dwo_name,
					  strlen (virtual_dwo_name));
      dwo_file->comp_dir = comp_dir;
      dwo_file->sections.abbrev = sections.abbrev;
      dwo_file->sections.line = sections.line;
      dwo_file->sections.loc = sections.loc;
      dwo_file->sections.macinfo = sections.macinfo;
      dwo_file->sections.macro = sections.macro;
      dwo_file->sections.str_offsets = sections.str_offsets;
      /* The "str" section is global to the entire DWP file.  */
      dwo_file->sections.str = dwp_file->sections.str;
      /* The info or types section is assigned below to dwo_unit,
	 there's no need to record it in dwo_file.
	 Also, we can't simply record type sections in dwo_file because
	 we record a pointer into the vector in dwo_unit.  As we collect more
	 types we'll grow the vector and eventually have to reallocate space
	 for it, invalidating all copies of pointers into the previous
	 contents.  */
      *dwo_file_slot = dwo_file;
    }
  else
    {
      if (dwarf2_read_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "Using existing virtual DWO: %s\n",
			      virtual_dwo_name);
	}
      dwo_file = *dwo_file_slot;
    }
  do_cleanups (cleanups);

  dwo_unit = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_unit);
  dwo_unit->dwo_file = dwo_file;
  dwo_unit->signature = signature;
  dwo_unit->section = obstack_alloc (&objfile->objfile_obstack,
				     sizeof (struct dwarf2_section_info));
  *dwo_unit->section = sections.info_or_types;
  /* dwo_unit->{offset,length,type_offset_in_tu} are set later.  */

  return dwo_unit;
}

/* Subroutine of create_dwo_unit_in_dwp_v2 to simplify it.
   Given a pointer to the containing section SECTION, and OFFSET,SIZE of the
   piece within that section used by a TU/CU, return a virtual section
   of just that piece.  */

static struct dwarf2_section_info
create_dwp_v2_section (struct dwarf2_section_info *section,
		       bfd_size_type offset, bfd_size_type size)
{
  struct dwarf2_section_info result;
  asection *sectp;

  gdb_assert (section != NULL);
  gdb_assert (!section->is_virtual);

  memset (&result, 0, sizeof (result));
  result.s.containing_section = section;
  result.is_virtual = 1;

  if (size == 0)
    return result;

  sectp = get_section_bfd_section (section);

  /* Flag an error if the piece denoted by OFFSET,SIZE is outside the
     bounds of the real section.  This is a pretty-rare event, so just
     flag an error (easier) instead of a warning and trying to cope.  */
  if (sectp == NULL
      || offset + size > bfd_get_section_size (sectp))
    {
      bfd *abfd = sectp->owner;

      error (_("Dwarf Error: Bad DWP V2 section info, doesn't fit"
	       " in section %s [in module %s]"),
	     sectp ? bfd_section_name (abfd, sectp) : "<unknown>",
	     objfile_name (dwarf2_per_objfile->objfile));
    }

  result.virtual_offset = offset;
  result.size = size;
  return result;
}

/* Create a dwo_unit object for the DWO unit with signature SIGNATURE.
   UNIT_INDEX is the index of the DWO unit in the DWP hash table.
   COMP_DIR is the DW_AT_comp_dir attribute of the referencing CU.
   This is for DWP version 2 files.  */

static struct dwo_unit *
create_dwo_unit_in_dwp_v2 (struct dwp_file *dwp_file,
			   uint32_t unit_index,
			   const char *comp_dir,
			   ULONGEST signature, int is_debug_types)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  const struct dwp_hash_table *dwp_htab =
    is_debug_types ? dwp_file->tus : dwp_file->cus;
  bfd *dbfd = dwp_file->dbfd;
  const char *kind = is_debug_types ? "TU" : "CU";
  struct dwo_file *dwo_file;
  struct dwo_unit *dwo_unit;
  struct virtual_v2_dwo_sections sections;
  void **dwo_file_slot;
  char *virtual_dwo_name;
  struct dwarf2_section_info *cutu;
  struct cleanup *cleanups;
  int i;

  gdb_assert (dwp_file->version == 2);

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "Reading %s %s/%s in DWP V2 file: %s\n",
			  kind,
			  pulongest (unit_index), hex_string (signature),
			  dwp_file->name);
    }

  /* Fetch the section offsets of this DWO unit.  */

  memset (&sections, 0, sizeof (sections));
  cleanups = make_cleanup (null_cleanup, 0);

  for (i = 0; i < dwp_htab->nr_columns; ++i)
    {
      uint32_t offset = read_4_bytes (dbfd,
				      dwp_htab->section_pool.v2.offsets
				      + (((unit_index - 1) * dwp_htab->nr_columns
					  + i)
					 * sizeof (uint32_t)));
      uint32_t size = read_4_bytes (dbfd,
				    dwp_htab->section_pool.v2.sizes
				    + (((unit_index - 1) * dwp_htab->nr_columns
					+ i)
				       * sizeof (uint32_t)));

      switch (dwp_htab->section_pool.v2.section_ids[i])
	{
	case DW_SECT_INFO:
	case DW_SECT_TYPES:
	  sections.info_or_types_offset = offset;
	  sections.info_or_types_size = size;
	  break;
	case DW_SECT_ABBREV:
	  sections.abbrev_offset = offset;
	  sections.abbrev_size = size;
	  break;
	case DW_SECT_LINE:
	  sections.line_offset = offset;
	  sections.line_size = size;
	  break;
	case DW_SECT_LOC:
	  sections.loc_offset = offset;
	  sections.loc_size = size;
	  break;
	case DW_SECT_STR_OFFSETS:
	  sections.str_offsets_offset = offset;
	  sections.str_offsets_size = size;
	  break;
	case DW_SECT_MACINFO:
	  sections.macinfo_offset = offset;
	  sections.macinfo_size = size;
	  break;
	case DW_SECT_MACRO:
	  sections.macro_offset = offset;
	  sections.macro_size = size;
	  break;
	}
    }

  /* It's easier for the rest of the code if we fake a struct dwo_file and
     have dwo_unit "live" in that.  At least for now.

     The DWP file can be made up of a random collection of CUs and TUs.
     However, for each CU + set of TUs that came from the same original DWO
     file, we can combine them back into a virtual DWO file to save space
     (fewer struct dwo_file objects to allocate).  Remember that for really
     large apps there can be on the order of 8K CUs and 200K TUs, or more.  */

  virtual_dwo_name =
    xstrprintf ("virtual-dwo/%ld-%ld-%ld-%ld",
		(long) (sections.abbrev_size ? sections.abbrev_offset : 0),
		(long) (sections.line_size ? sections.line_offset : 0),
		(long) (sections.loc_size ? sections.loc_offset : 0),
		(long) (sections.str_offsets_size
			? sections.str_offsets_offset : 0));
  make_cleanup (xfree, virtual_dwo_name);
  /* Can we use an existing virtual DWO file?  */
  dwo_file_slot = lookup_dwo_file_slot (virtual_dwo_name, comp_dir);
  /* Create one if necessary.  */
  if (*dwo_file_slot == NULL)
    {
      if (dwarf2_read_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "Creating virtual DWO: %s\n",
			      virtual_dwo_name);
	}
      dwo_file = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_file);
      dwo_file->dwo_name = obstack_copy0 (&objfile->objfile_obstack,
					  virtual_dwo_name,
					  strlen (virtual_dwo_name));
      dwo_file->comp_dir = comp_dir;
      dwo_file->sections.abbrev =
	create_dwp_v2_section (&dwp_file->sections.abbrev,
			       sections.abbrev_offset, sections.abbrev_size);
      dwo_file->sections.line =
	create_dwp_v2_section (&dwp_file->sections.line,
			       sections.line_offset, sections.line_size);
      dwo_file->sections.loc =
	create_dwp_v2_section (&dwp_file->sections.loc,
			       sections.loc_offset, sections.loc_size);
      dwo_file->sections.macinfo =
	create_dwp_v2_section (&dwp_file->sections.macinfo,
			       sections.macinfo_offset, sections.macinfo_size);
      dwo_file->sections.macro =
	create_dwp_v2_section (&dwp_file->sections.macro,
			       sections.macro_offset, sections.macro_size);
      dwo_file->sections.str_offsets =
	create_dwp_v2_section (&dwp_file->sections.str_offsets,
			       sections.str_offsets_offset,
			       sections.str_offsets_size);
      /* The "str" section is global to the entire DWP file.  */
      dwo_file->sections.str = dwp_file->sections.str;
      /* The info or types section is assigned below to dwo_unit,
	 there's no need to record it in dwo_file.
	 Also, we can't simply record type sections in dwo_file because
	 we record a pointer into the vector in dwo_unit.  As we collect more
	 types we'll grow the vector and eventually have to reallocate space
	 for it, invalidating all copies of pointers into the previous
	 contents.  */
      *dwo_file_slot = dwo_file;
    }
  else
    {
      if (dwarf2_read_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "Using existing virtual DWO: %s\n",
			      virtual_dwo_name);
	}
      dwo_file = *dwo_file_slot;
    }
  do_cleanups (cleanups);

  dwo_unit = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_unit);
  dwo_unit->dwo_file = dwo_file;
  dwo_unit->signature = signature;
  dwo_unit->section = obstack_alloc (&objfile->objfile_obstack,
				     sizeof (struct dwarf2_section_info));
  *dwo_unit->section = create_dwp_v2_section (is_debug_types
					      ? &dwp_file->sections.types
					      : &dwp_file->sections.info,
					      sections.info_or_types_offset,
					      sections.info_or_types_size);
  /* dwo_unit->{offset,length,type_offset_in_tu} are set later.  */

  return dwo_unit;
}

/* Lookup the DWO unit with SIGNATURE in DWP_FILE.
   Returns NULL if the signature isn't found.  */

static struct dwo_unit *
lookup_dwo_unit_in_dwp (struct dwp_file *dwp_file, const char *comp_dir,
			ULONGEST signature, int is_debug_types)
{
  const struct dwp_hash_table *dwp_htab =
    is_debug_types ? dwp_file->tus : dwp_file->cus;
  bfd *dbfd = dwp_file->dbfd;
  uint32_t mask = dwp_htab->nr_slots - 1;
  uint32_t hash = signature & mask;
  uint32_t hash2 = ((signature >> 32) & mask) | 1;
  unsigned int i;
  void **slot;
  struct dwo_unit find_dwo_cu, *dwo_cu;

  memset (&find_dwo_cu, 0, sizeof (find_dwo_cu));
  find_dwo_cu.signature = signature;
  slot = htab_find_slot (is_debug_types
			 ? dwp_file->loaded_tus
			 : dwp_file->loaded_cus,
			 &find_dwo_cu, INSERT);

  if (*slot != NULL)
    return *slot;

  /* Use a for loop so that we don't loop forever on bad debug info.  */
  for (i = 0; i < dwp_htab->nr_slots; ++i)
    {
      ULONGEST signature_in_table;

      signature_in_table =
	read_8_bytes (dbfd, dwp_htab->hash_table + hash * sizeof (uint64_t));
      if (signature_in_table == signature)
	{
	  uint32_t unit_index =
	    read_4_bytes (dbfd,
			  dwp_htab->unit_table + hash * sizeof (uint32_t));

	  if (dwp_file->version == 1)
	    {
	      *slot = create_dwo_unit_in_dwp_v1 (dwp_file, unit_index,
						 comp_dir, signature,
						 is_debug_types);
	    }
	  else
	    {
	      *slot = create_dwo_unit_in_dwp_v2 (dwp_file, unit_index,
						 comp_dir, signature,
						 is_debug_types);
	    }
	  return *slot;
	}
      if (signature_in_table == 0)
	return NULL;
      hash = (hash + hash2) & mask;
    }

  error (_("Dwarf Error: bad DWP hash table, lookup didn't terminate"
	   " [in module %s]"),
	 dwp_file->name);
}

/* Subroutine of open_dwo_file,open_dwp_file to simplify them.
   Open the file specified by FILE_NAME and hand it off to BFD for
   preliminary analysis.  Return a newly initialized bfd *, which
   includes a canonicalized copy of FILE_NAME.
   If IS_DWP is TRUE, we're opening a DWP file, otherwise a DWO file.
   SEARCH_CWD is true if the current directory is to be searched.
   It will be searched before debug-file-directory.
   If unable to find/open the file, return NULL.
   NOTE: This function is derived from symfile_bfd_open.  */

static bfd *
try_open_dwop_file (const char *file_name, int is_dwp, int search_cwd)
{
  bfd *sym_bfd;
  int desc, flags;
  char *absolute_name;
  /* Blech.  OPF_TRY_CWD_FIRST also disables searching the path list if
     FILE_NAME contains a '/'.  So we can't use it.  Instead prepend "."
     to debug_file_directory.  */
  char *search_path;
  static const char dirname_separator_string[] = { DIRNAME_SEPARATOR, '\0' };

  if (search_cwd)
    {
      if (*debug_file_directory != '\0')
	search_path = concat (".", dirname_separator_string,
			      debug_file_directory, NULL);
      else
	search_path = xstrdup (".");
    }
  else
    search_path = xstrdup (debug_file_directory);

  flags = OPF_RETURN_REALPATH;
  if (is_dwp)
    flags |= OPF_SEARCH_IN_PATH;
  desc = openp (search_path, flags, file_name,
		O_RDONLY | O_BINARY, &absolute_name);
  xfree (search_path);
  if (desc < 0)
    return NULL;

  sym_bfd = gdb_bfd_open (absolute_name, gnutarget, desc);
  xfree (absolute_name);
  if (sym_bfd == NULL)
    return NULL;
  bfd_set_cacheable (sym_bfd, 1);

  if (!bfd_check_format (sym_bfd, bfd_object))
    {
      gdb_bfd_unref (sym_bfd); /* This also closes desc.  */
      return NULL;
    }

  return sym_bfd;
}

/* Try to open DWO file FILE_NAME.
   COMP_DIR is the DW_AT_comp_dir attribute.
   The result is the bfd handle of the file.
   If there is a problem finding or opening the file, return NULL.
   Upon success, the canonicalized path of the file is stored in the bfd,
   same as symfile_bfd_open.  */

static bfd *
open_dwo_file (const char *file_name, const char *comp_dir)
{
  bfd *abfd;

  if (IS_ABSOLUTE_PATH (file_name))
    return try_open_dwop_file (file_name, 0 /*is_dwp*/, 0 /*search_cwd*/);

  /* Before trying the search path, try DWO_NAME in COMP_DIR.  */

  if (comp_dir != NULL)
    {
      char *path_to_try = concat (comp_dir, SLASH_STRING, file_name, NULL);

      /* NOTE: If comp_dir is a relative path, this will also try the
	 search path, which seems useful.  */
      abfd = try_open_dwop_file (path_to_try, 0 /*is_dwp*/, 1 /*search_cwd*/);
      xfree (path_to_try);
      if (abfd != NULL)
	return abfd;
    }

  /* That didn't work, try debug-file-directory, which, despite its name,
     is a list of paths.  */

  if (*debug_file_directory == '\0')
    return NULL;

  return try_open_dwop_file (file_name, 0 /*is_dwp*/, 1 /*search_cwd*/);
}

/* This function is mapped across the sections and remembers the offset and
   size of each of the DWO debugging sections we are interested in.  */

static void
dwarf2_locate_dwo_sections (bfd *abfd, asection *sectp, void *dwo_sections_ptr)
{
  struct dwo_sections *dwo_sections = dwo_sections_ptr;
  const struct dwop_section_names *names = &dwop_section_names;

  if (section_is_p (sectp->name, &names->abbrev_dwo))
    {
      dwo_sections->abbrev.s.asection = sectp;
      dwo_sections->abbrev.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->info_dwo))
    {
      dwo_sections->info.s.asection = sectp;
      dwo_sections->info.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->line_dwo))
    {
      dwo_sections->line.s.asection = sectp;
      dwo_sections->line.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->loc_dwo))
    {
      dwo_sections->loc.s.asection = sectp;
      dwo_sections->loc.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macinfo_dwo))
    {
      dwo_sections->macinfo.s.asection = sectp;
      dwo_sections->macinfo.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macro_dwo))
    {
      dwo_sections->macro.s.asection = sectp;
      dwo_sections->macro.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->str_dwo))
    {
      dwo_sections->str.s.asection = sectp;
      dwo_sections->str.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->str_offsets_dwo))
    {
      dwo_sections->str_offsets.s.asection = sectp;
      dwo_sections->str_offsets.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->types_dwo))
    {
      struct dwarf2_section_info type_section;

      memset (&type_section, 0, sizeof (type_section));
      type_section.s.asection = sectp;
      type_section.size = bfd_get_section_size (sectp);
      VEC_safe_push (dwarf2_section_info_def, dwo_sections->types,
		     &type_section);
    }
}

/* Initialize the use of the DWO file specified by DWO_NAME and referenced
   by PER_CU.  This is for the non-DWP case.
   The result is NULL if DWO_NAME can't be found.  */

static struct dwo_file *
open_and_init_dwo_file (struct dwarf2_per_cu_data *per_cu,
			const char *dwo_name, const char *comp_dir)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwo_file *dwo_file;
  bfd *dbfd;
  struct cleanup *cleanups;

  dbfd = open_dwo_file (dwo_name, comp_dir);
  if (dbfd == NULL)
    {
      if (dwarf2_read_debug)
	fprintf_unfiltered (gdb_stdlog, "DWO file not found: %s\n", dwo_name);
      return NULL;
    }
  dwo_file = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_file);
  dwo_file->dwo_name = dwo_name;
  dwo_file->comp_dir = comp_dir;
  dwo_file->dbfd = dbfd;

  cleanups = make_cleanup (free_dwo_file_cleanup, dwo_file);

  bfd_map_over_sections (dbfd, dwarf2_locate_dwo_sections, &dwo_file->sections);

  dwo_file->cu = create_dwo_cu (dwo_file);

  dwo_file->tus = create_debug_types_hash_table (dwo_file,
						 dwo_file->sections.types);

  discard_cleanups (cleanups);

  if (dwarf2_read_debug)
    fprintf_unfiltered (gdb_stdlog, "DWO file found: %s\n", dwo_name);

  return dwo_file;
}

/* This function is mapped across the sections and remembers the offset and
   size of each of the DWP debugging sections common to version 1 and 2 that
   we are interested in.  */

static void
dwarf2_locate_common_dwp_sections (bfd *abfd, asection *sectp,
				   void *dwp_file_ptr)
{
  struct dwp_file *dwp_file = dwp_file_ptr;
  const struct dwop_section_names *names = &dwop_section_names;
  unsigned int elf_section_nr = elf_section_data (sectp)->this_idx;

  /* Record the ELF section number for later lookup: this is what the
     .debug_cu_index,.debug_tu_index tables use in DWP V1.  */
  gdb_assert (elf_section_nr < dwp_file->num_sections);
  dwp_file->elf_sections[elf_section_nr] = sectp;

  /* Look for specific sections that we need.  */
  if (section_is_p (sectp->name, &names->str_dwo))
    {
      dwp_file->sections.str.s.asection = sectp;
      dwp_file->sections.str.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->cu_index))
    {
      dwp_file->sections.cu_index.s.asection = sectp;
      dwp_file->sections.cu_index.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->tu_index))
    {
      dwp_file->sections.tu_index.s.asection = sectp;
      dwp_file->sections.tu_index.size = bfd_get_section_size (sectp);
    }
}

/* This function is mapped across the sections and remembers the offset and
   size of each of the DWP version 2 debugging sections that we are interested
   in.  This is split into a separate function because we don't know if we
   have version 1 or 2 until we parse the cu_index/tu_index sections.  */

static void
dwarf2_locate_v2_dwp_sections (bfd *abfd, asection *sectp, void *dwp_file_ptr)
{
  struct dwp_file *dwp_file = dwp_file_ptr;
  const struct dwop_section_names *names = &dwop_section_names;
  unsigned int elf_section_nr = elf_section_data (sectp)->this_idx;

  /* Record the ELF section number for later lookup: this is what the
     .debug_cu_index,.debug_tu_index tables use in DWP V1.  */
  gdb_assert (elf_section_nr < dwp_file->num_sections);
  dwp_file->elf_sections[elf_section_nr] = sectp;

  /* Look for specific sections that we need.  */
  if (section_is_p (sectp->name, &names->abbrev_dwo))
    {
      dwp_file->sections.abbrev.s.asection = sectp;
      dwp_file->sections.abbrev.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->info_dwo))
    {
      dwp_file->sections.info.s.asection = sectp;
      dwp_file->sections.info.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->line_dwo))
    {
      dwp_file->sections.line.s.asection = sectp;
      dwp_file->sections.line.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->loc_dwo))
    {
      dwp_file->sections.loc.s.asection = sectp;
      dwp_file->sections.loc.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macinfo_dwo))
    {
      dwp_file->sections.macinfo.s.asection = sectp;
      dwp_file->sections.macinfo.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macro_dwo))
    {
      dwp_file->sections.macro.s.asection = sectp;
      dwp_file->sections.macro.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->str_offsets_dwo))
    {
      dwp_file->sections.str_offsets.s.asection = sectp;
      dwp_file->sections.str_offsets.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->types_dwo))
    {
      dwp_file->sections.types.s.asection = sectp;
      dwp_file->sections.types.size = bfd_get_section_size (sectp);
    }
}

/* Hash function for dwp_file loaded CUs/TUs.  */

static hashval_t
hash_dwp_loaded_cutus (const void *item)
{
  const struct dwo_unit *dwo_unit = item;

  /* This drops the top 32 bits of the signature, but is ok for a hash.  */
  return dwo_unit->signature;
}

/* Equality function for dwp_file loaded CUs/TUs.  */

static int
eq_dwp_loaded_cutus (const void *a, const void *b)
{
  const struct dwo_unit *dua = a;
  const struct dwo_unit *dub = b;

  return dua->signature == dub->signature;
}

/* Allocate a hash table for dwp_file loaded CUs/TUs.  */

static htab_t
allocate_dwp_loaded_cutus_table (struct objfile *objfile)
{
  return htab_create_alloc_ex (3,
			       hash_dwp_loaded_cutus,
			       eq_dwp_loaded_cutus,
			       NULL,
			       &objfile->objfile_obstack,
			       hashtab_obstack_allocate,
			       dummy_obstack_deallocate);
}

/* Try to open DWP file FILE_NAME.
   The result is the bfd handle of the file.
   If there is a problem finding or opening the file, return NULL.
   Upon success, the canonicalized path of the file is stored in the bfd,
   same as symfile_bfd_open.  */

static bfd *
open_dwp_file (const char *file_name)
{
  bfd *abfd;

  abfd = try_open_dwop_file (file_name, 1 /*is_dwp*/, 1 /*search_cwd*/);
  if (abfd != NULL)
    return abfd;

  /* Work around upstream bug 15652.
     http://sourceware.org/bugzilla/show_bug.cgi?id=15652
     [Whether that's a "bug" is debatable, but it is getting in our way.]
     We have no real idea where the dwp file is, because gdb's realpath-ing
     of the executable's path may have discarded the needed info.
     [IWBN if the dwp file name was recorded in the executable, akin to
     .gnu_debuglink, but that doesn't exist yet.]
     Strip the directory from FILE_NAME and search again.  */
  if (*debug_file_directory != '\0')
    {
      /* Don't implicitly search the current directory here.
	 If the user wants to search "." to handle this case,
	 it must be added to debug-file-directory.  */
      return try_open_dwop_file (lbasename (file_name), 1 /*is_dwp*/,
				 0 /*search_cwd*/);
    }

  return NULL;
}

/* Initialize the use of the DWP file for the current objfile.
   By convention the name of the DWP file is ${objfile}.dwp.
   The result is NULL if it can't be found.  */

static struct dwp_file *
open_and_init_dwp_file (void)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwp_file *dwp_file;
  char *dwp_name;
  bfd *dbfd;
  struct cleanup *cleanups;

  /* Try to find first .dwp for the binary file before any symbolic links
     resolving.  */
  dwp_name = xstrprintf ("%s.dwp", objfile->original_name);
  cleanups = make_cleanup (xfree, dwp_name);

  dbfd = open_dwp_file (dwp_name);
  if (dbfd == NULL
      && strcmp (objfile->original_name, objfile_name (objfile)) != 0)
    {
      /* Try to find .dwp for the binary file after gdb_realpath resolving.  */
      dwp_name = xstrprintf ("%s.dwp", objfile_name (objfile));
      make_cleanup (xfree, dwp_name);
      dbfd = open_dwp_file (dwp_name);
    }

  if (dbfd == NULL)
    {
      if (dwarf2_read_debug)
	fprintf_unfiltered (gdb_stdlog, "DWP file not found: %s\n", dwp_name);
      do_cleanups (cleanups);
      return NULL;
    }
  dwp_file = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwp_file);
  dwp_file->name = bfd_get_filename (dbfd);
  dwp_file->dbfd = dbfd;
  do_cleanups (cleanups);

  /* +1: section 0 is unused */
  dwp_file->num_sections = bfd_count_sections (dbfd) + 1;
  dwp_file->elf_sections =
    OBSTACK_CALLOC (&objfile->objfile_obstack,
		    dwp_file->num_sections, asection *);

  bfd_map_over_sections (dbfd, dwarf2_locate_common_dwp_sections, dwp_file);

  dwp_file->cus = create_dwp_hash_table (dwp_file, 0);

  dwp_file->tus = create_dwp_hash_table (dwp_file, 1);

  /* The DWP file version is stored in the hash table.  Oh well.  */
  if (dwp_file->cus->version != dwp_file->tus->version)
    {
      /* Technically speaking, we should try to limp along, but this is
	 pretty bizarre.  */
      error (_("Dwarf Error: DWP file CU version %d doesn't match"
	       " TU version %d [in DWP file %s]"),
	     dwp_file->cus->version, dwp_file->tus->version, dwp_name);
    }
  dwp_file->version = dwp_file->cus->version;

  if (dwp_file->version == 2)
    bfd_map_over_sections (dbfd, dwarf2_locate_v2_dwp_sections, dwp_file);

  dwp_file->loaded_cus = allocate_dwp_loaded_cutus_table (objfile);
  dwp_file->loaded_tus = allocate_dwp_loaded_cutus_table (objfile);

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "DWP file found: %s\n", dwp_file->name);
      fprintf_unfiltered (gdb_stdlog,
			  "    %s CUs, %s TUs\n",
			  pulongest (dwp_file->cus ? dwp_file->cus->nr_units : 0),
			  pulongest (dwp_file->tus ? dwp_file->tus->nr_units : 0));
    }

  return dwp_file;
}

/* Wrapper around open_and_init_dwp_file, only open it once.  */

static struct dwp_file *
get_dwp_file (void)
{
  if (! dwarf2_per_objfile->dwp_checked)
    {
      dwarf2_per_objfile->dwp_file = open_and_init_dwp_file ();
      dwarf2_per_objfile->dwp_checked = 1;
    }
  return dwarf2_per_objfile->dwp_file;
}

/* Subroutine of lookup_dwo_comp_unit, lookup_dwo_type_unit.
   Look up the CU/TU with signature SIGNATURE, either in DWO file DWO_NAME
   or in the DWP file for the objfile, referenced by THIS_UNIT.
   If non-NULL, comp_dir is the DW_AT_comp_dir attribute.
   IS_DEBUG_TYPES is non-zero if reading a TU, otherwise read a CU.

   This is called, for example, when wanting to read a variable with a
   complex location.  Therefore we don't want to do file i/o for every call.
   Therefore we don't want to look for a DWO file on every call.
   Therefore we first see if we've already seen SIGNATURE in a DWP file,
   then we check if we've already seen DWO_NAME, and only THEN do we check
   for a DWO file.

   The result is a pointer to the dwo_unit object or NULL if we didn't find it
   (dwo_id mismatch or couldn't find the DWO/DWP file).  */

static struct dwo_unit *
lookup_dwo_cutu (struct dwarf2_per_cu_data *this_unit,
		 const char *dwo_name, const char *comp_dir,
		 ULONGEST signature, int is_debug_types)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  const char *kind = is_debug_types ? "TU" : "CU";
  void **dwo_file_slot;
  struct dwo_file *dwo_file;
  struct dwp_file *dwp_file;

  /* First see if there's a DWP file.
     If we have a DWP file but didn't find the DWO inside it, don't
     look for the original DWO file.  It makes gdb behave differently
     depending on whether one is debugging in the build tree.  */

  dwp_file = get_dwp_file ();
  if (dwp_file != NULL)
    {
      const struct dwp_hash_table *dwp_htab =
	is_debug_types ? dwp_file->tus : dwp_file->cus;

      if (dwp_htab != NULL)
	{
	  struct dwo_unit *dwo_cutu =
	    lookup_dwo_unit_in_dwp (dwp_file, comp_dir,
				    signature, is_debug_types);

	  if (dwo_cutu != NULL)
	    {
	      if (dwarf2_read_debug)
		{
		  fprintf_unfiltered (gdb_stdlog,
				      "Virtual DWO %s %s found: @@%s\n",
				      kind, hex_string (signature),
				      host_address_to_string (dwo_cutu));
		}
	      return dwo_cutu;
	    }
	}
    }
  else
    {
      /* No DWP file, look for the DWO file.  */

      dwo_file_slot = lookup_dwo_file_slot (dwo_name, comp_dir);
      if (*dwo_file_slot == NULL)
	{
	  /* Read in the file and build a table of the CUs/TUs it contains.  */
	  *dwo_file_slot = open_and_init_dwo_file (this_unit, dwo_name, comp_dir);
	}
      /* NOTE: This will be NULL if unable to open the file.  */
      dwo_file = *dwo_file_slot;

      if (dwo_file != NULL)
	{
	  struct dwo_unit *dwo_cutu = NULL;

	  if (is_debug_types && dwo_file->tus)
	    {
	      struct dwo_unit find_dwo_cutu;

	      memset (&find_dwo_cutu, 0, sizeof (find_dwo_cutu));
	      find_dwo_cutu.signature = signature;
	      dwo_cutu = htab_find (dwo_file->tus, &find_dwo_cutu);
	    }
	  else if (!is_debug_types && dwo_file->cu)
	    {
	      if (signature == dwo_file->cu->signature)
		dwo_cutu = dwo_file->cu;
	    }

	  if (dwo_cutu != NULL)
	    {
	      if (dwarf2_read_debug)
		{
		  fprintf_unfiltered (gdb_stdlog, "DWO %s %s(%s) found: @@%s\n",
				      kind, dwo_name, hex_string (signature),
				      host_address_to_string (dwo_cutu));
		}
	      return dwo_cutu;
	    }
	}
    }

  /* We didn't find it.  This could mean a dwo_id mismatch, or
     someone deleted the DWO/DWP file, or the search path isn't set up
     correctly to find the file.  */

  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "DWO %s %s(%s) not found\n",
			  kind, dwo_name, hex_string (signature));
    }

  /* This is a warning and not a complaint because it can be caused by
     pilot error (e.g., user accidentally deleting the DWO).  */
  warning (_("Could not find DWO %s %s(%s) referenced by %s at offset 0x%x"
	     " [in module %s]"),
	   kind, dwo_name, hex_string (signature),
	   this_unit->is_debug_types ? "TU" : "CU",
	   this_unit->offset.sect_off, objfile_name (objfile));
  return NULL;
}

/* Lookup the DWO CU DWO_NAME/SIGNATURE referenced from THIS_CU.
   See lookup_dwo_cutu_unit for details.  */

static struct dwo_unit *
lookup_dwo_comp_unit (struct dwarf2_per_cu_data *this_cu,
		      const char *dwo_name, const char *comp_dir,
		      ULONGEST signature)
{
  return lookup_dwo_cutu (this_cu, dwo_name, comp_dir, signature, 0);
}

/* Lookup the DWO TU DWO_NAME/SIGNATURE referenced from THIS_TU.
   See lookup_dwo_cutu_unit for details.  */

static struct dwo_unit *
lookup_dwo_type_unit (struct signatured_type *this_tu,
		      const char *dwo_name, const char *comp_dir)
{
  return lookup_dwo_cutu (&this_tu->per_cu, dwo_name, comp_dir, this_tu->signature, 1);
}

/* Traversal function for queue_and_load_all_dwo_tus.  */

static int
queue_and_load_dwo_tu (void **slot, void *info)
{
  struct dwo_unit *dwo_unit = (struct dwo_unit *) *slot;
  struct dwarf2_per_cu_data *per_cu = (struct dwarf2_per_cu_data *) info;
  ULONGEST signature = dwo_unit->signature;
  struct signatured_type *sig_type =
    lookup_dwo_signatured_type (per_cu->cu, signature);

  if (sig_type != NULL)
    {
      struct dwarf2_per_cu_data *sig_cu = &sig_type->per_cu;

      /* We pass NULL for DEPENDENT_CU because we don't yet know if there's
	 a real dependency of PER_CU on SIG_TYPE.  That is detected later
	 while processing PER_CU.  */
      if (maybe_queue_comp_unit (NULL, sig_cu, per_cu->cu->language))
	load_full_type_unit (sig_cu);
      VEC_safe_push (dwarf2_per_cu_ptr, per_cu->imported_symtabs, sig_cu);
    }

  return 1;
}

/* Queue all TUs contained in the DWO of PER_CU to be read in.
   The DWO may have the only definition of the type, though it may not be
   referenced anywhere in PER_CU.  Thus we have to load *all* its TUs.
   http://sourceware.org/bugzilla/show_bug.cgi?id=15021  */

static void
queue_and_load_all_dwo_tus (struct dwarf2_per_cu_data *per_cu)
{
  struct dwo_unit *dwo_unit;
  struct dwo_file *dwo_file;

  gdb_assert (!per_cu->is_debug_types);
  gdb_assert (get_dwp_file () == NULL);
  gdb_assert (per_cu->cu != NULL);

  dwo_unit = per_cu->cu->dwo_unit;
  gdb_assert (dwo_unit != NULL);

  dwo_file = dwo_unit->dwo_file;
  if (dwo_file->tus != NULL)
    htab_traverse_noresize (dwo_file->tus, queue_and_load_dwo_tu, per_cu);
}

/* Free all resources associated with DWO_FILE.
   Close the DWO file and munmap the sections.
   All memory should be on the objfile obstack.  */

static void
free_dwo_file (struct dwo_file *dwo_file, struct objfile *objfile)
{
  int ix;
  struct dwarf2_section_info *section;

  /* Note: dbfd is NULL for virtual DWO files.  */
  gdb_bfd_unref (dwo_file->dbfd);

  VEC_free (dwarf2_section_info_def, dwo_file->sections.types);
}

/* Wrapper for free_dwo_file for use in cleanups.  */

static void
free_dwo_file_cleanup (void *arg)
{
  struct dwo_file *dwo_file = (struct dwo_file *) arg;
  struct objfile *objfile = dwarf2_per_objfile->objfile;

  free_dwo_file (dwo_file, objfile);
}

/* Traversal function for free_dwo_files.  */

static int
free_dwo_file_from_slot (void **slot, void *info)
{
  struct dwo_file *dwo_file = (struct dwo_file *) *slot;
  struct objfile *objfile = (struct objfile *) info;

  free_dwo_file (dwo_file, objfile);

  return 1;
}

/* Free all resources associated with DWO_FILES.  */

static void
free_dwo_files (htab_t dwo_files, struct objfile *objfile)
{
  htab_traverse_noresize (dwo_files, free_dwo_file_from_slot, objfile);
}

/* Read in various DIEs.  */

/* qsort helper for inherit_abstract_dies.  */

static int
unsigned_int_compar (const void *ap, const void *bp)
{
  unsigned int a = *(unsigned int *) ap;
  unsigned int b = *(unsigned int *) bp;

  return (a > b) - (b > a);
}

/* DW_AT_abstract_origin inherits whole DIEs (not just their attributes).
   Inherit only the children of the DW_AT_abstract_origin DIE not being
   already referenced by DW_AT_abstract_origin from the children of the
   current DIE.  */

static void
inherit_abstract_dies (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *child_die;
  unsigned die_children_count;
  /* CU offsets which were referenced by children of the current DIE.  */
  sect_offset *offsets;
  sect_offset *offsets_end, *offsetp;
  /* Parent of DIE - referenced by DW_AT_abstract_origin.  */
  struct die_info *origin_die;
  /* Iterator of the ORIGIN_DIE children.  */
  struct die_info *origin_child_die;
  struct cleanup *cleanups;
  struct attribute *attr;
  struct dwarf2_cu *origin_cu;
  struct pending **origin_previous_list_in_scope;

  attr = dwarf2_attr (die, DW_AT_abstract_origin, cu);
  if (!attr)
    return;

  /* Note that following die references may follow to a die in a
     different cu.  */

  origin_cu = cu;
  origin_die = follow_die_ref (die, attr, &origin_cu);

  /* We're inheriting ORIGIN's children into the scope we'd put DIE's
     symbols in.  */
  origin_previous_list_in_scope = origin_cu->list_in_scope;
  origin_cu->list_in_scope = cu->list_in_scope;

  if (die->tag != origin_die->tag
      && !(die->tag == DW_TAG_inlined_subroutine
	   && origin_die->tag == DW_TAG_subprogram))
    complaint (&symfile_complaints,
	       _("DIE 0x%x and its abstract origin 0x%x have different tags"),
	       die->offset.sect_off, origin_die->offset.sect_off);

  child_die = die->child;
  die_children_count = 0;
  while (child_die && child_die->tag)
    {
      child_die = sibling_die (child_die);
      die_children_count++;
    }
  offsets = xmalloc (sizeof (*offsets) * die_children_count);
  cleanups = make_cleanup (xfree, offsets);

  offsets_end = offsets;
  child_die = die->child;
  while (child_die && child_die->tag)
    {
      /* For each CHILD_DIE, find the corresponding child of
	 ORIGIN_DIE.  If there is more than one layer of
	 DW_AT_abstract_origin, follow them all; there shouldn't be,
	 but GCC versions at least through 4.4 generate this (GCC PR
	 40573).  */
      struct die_info *child_origin_die = child_die;
      struct dwarf2_cu *child_origin_cu = cu;

      while (1)
	{
	  attr = dwarf2_attr (child_origin_die, DW_AT_abstract_origin,
			      child_origin_cu);
	  if (attr == NULL)
	    break;
	  child_origin_die = follow_die_ref (child_origin_die, attr,
					     &child_origin_cu);
	}

      /* According to DWARF3 3.3.8.2 #3 new entries without their abstract
	 counterpart may exist.  */
      if (child_origin_die != child_die)
	{
	  if (child_die->tag != child_origin_die->tag
	      && !(child_die->tag == DW_TAG_inlined_subroutine
		   && child_origin_die->tag == DW_TAG_subprogram))
	    complaint (&symfile_complaints,
		       _("Child DIE 0x%x and its abstract origin 0x%x have "
			 "different tags"), child_die->offset.sect_off,
		       child_origin_die->offset.sect_off);
	  if (child_origin_die->parent != origin_die)
	    complaint (&symfile_complaints,
		       _("Child DIE 0x%x and its abstract origin 0x%x have "
			 "different parents"), child_die->offset.sect_off,
		       child_origin_die->offset.sect_off);
	  else
	    *offsets_end++ = child_origin_die->offset;
	}
      child_die = sibling_die (child_die);
    }
  qsort (offsets, offsets_end - offsets, sizeof (*offsets),
	 unsigned_int_compar);
  for (offsetp = offsets + 1; offsetp < offsets_end; offsetp++)
    if (offsetp[-1].sect_off == offsetp->sect_off)
      complaint (&symfile_complaints,
		 _("Multiple children of DIE 0x%x refer "
		   "to DIE 0x%x as their abstract origin"),
		 die->offset.sect_off, offsetp->sect_off);

  offsetp = offsets;
  origin_child_die = origin_die->child;
  while (origin_child_die && origin_child_die->tag)
    {
      /* Is ORIGIN_CHILD_DIE referenced by any of the DIE children?  */
      while (offsetp < offsets_end
	     && offsetp->sect_off < origin_child_die->offset.sect_off)
	offsetp++;
      if (offsetp >= offsets_end
	  || offsetp->sect_off > origin_child_die->offset.sect_off)
	{
	  /* Found that ORIGIN_CHILD_DIE is really not referenced.  */
	  process_die (origin_child_die, origin_cu);
	}
      origin_child_die = sibling_die (origin_child_die);
    }
  origin_cu->list_in_scope = origin_previous_list_in_scope;

  do_cleanups (cleanups);
}

static void
read_func_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct context_stack *new;
  CORE_ADDR lowpc;
  CORE_ADDR highpc;
  struct die_info *child_die;
  struct attribute *attr, *call_line, *call_file;
  const char *name;
  CORE_ADDR baseaddr;
  struct block *block;
  int inlined_func = (die->tag == DW_TAG_inlined_subroutine);
  VEC (symbolp) *template_args = NULL;
  struct template_symbol *templ_func = NULL;

  if (inlined_func)
    {
      /* If we do not have call site information, we can't show the
	 caller of this inlined function.  That's too confusing, so
	 only use the scope for local variables.  */
      call_line = dwarf2_attr (die, DW_AT_call_line, cu);
      call_file = dwarf2_attr (die, DW_AT_call_file, cu);
      if (call_line == NULL || call_file == NULL)
	{
	  read_lexical_block_scope (die, cu);
	  return;
	}
    }

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  name = dwarf2_name (die, cu);

  /* Ignore functions with missing or empty names.  These are actually
     illegal according to the DWARF standard.  */
  if (name == NULL)
    {
      complaint (&symfile_complaints,
		 _("missing name for subprogram DIE at %d"),
		 die->offset.sect_off);
      return;
    }

  /* Ignore functions with missing or invalid low and high pc attributes.  */
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu, NULL))
    {
      attr = dwarf2_attr (die, DW_AT_external, cu);
      if (!attr || !DW_UNSND (attr))
	complaint (&symfile_complaints,
		   _("cannot get low and high bounds "
		     "for subprogram DIE at %d"),
		   die->offset.sect_off);
      return;
    }

  lowpc += baseaddr;
  highpc += baseaddr;

  /* If we have any template arguments, then we must allocate a
     different sort of symbol.  */
  for (child_die = die->child; child_die; child_die = sibling_die (child_die))
    {
      if (child_die->tag == DW_TAG_template_type_param
	  || child_die->tag == DW_TAG_template_value_param)
	{
	  templ_func = allocate_template_symbol (objfile);
	  templ_func->base.is_cplus_template_function = 1;
	  break;
	}
    }

  new = push_context (0, lowpc);
  new->name = new_symbol_full (die, read_type_die (die, cu), cu,
			       (struct symbol *) templ_func);

  /* If there is a location expression for DW_AT_frame_base, record
     it.  */
  attr = dwarf2_attr (die, DW_AT_frame_base, cu);
  if (attr)
    dwarf2_symbol_mark_computed (attr, new->name, cu, 1);

  cu->list_in_scope = &local_symbols;

  if (die->child != NULL)
    {
      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  if (child_die->tag == DW_TAG_template_type_param
	      || child_die->tag == DW_TAG_template_value_param)
	    {
	      struct symbol *arg = new_symbol (child_die, NULL, cu);

	      if (arg != NULL)
		VEC_safe_push (symbolp, template_args, arg);
	    }
	  else
	    process_die (child_die, cu);
	  child_die = sibling_die (child_die);
	}
    }

  inherit_abstract_dies (die, cu);

  /* If we have a DW_AT_specification, we might need to import using
     directives from the context of the specification DIE.  See the
     comment in determine_prefix.  */
  if (cu->language == language_cplus
      && dwarf2_attr (die, DW_AT_specification, cu))
    {
      struct dwarf2_cu *spec_cu = cu;
      struct die_info *spec_die = die_specification (die, &spec_cu);

      while (spec_die)
	{
	  child_die = spec_die->child;
	  while (child_die && child_die->tag)
	    {
	      if (child_die->tag == DW_TAG_imported_module)
		process_die (child_die, spec_cu);
	      child_die = sibling_die (child_die);
	    }

	  /* In some cases, GCC generates specification DIEs that
	     themselves contain DW_AT_specification attributes.  */
	  spec_die = die_specification (spec_die, &spec_cu);
	}
    }

  new = pop_context ();
  /* Make a block for the local symbols within.  */
  block = finish_block (new->name, &local_symbols, new->old_blocks,
                        lowpc, highpc, objfile);

  /* For C++, set the block's scope.  */
  if ((cu->language == language_cplus || cu->language == language_fortran)
      && cu->processing_has_namespace_info)
    block_set_scope (block, determine_prefix (die, cu),
		     &objfile->objfile_obstack);

  /* If we have address ranges, record them.  */
  dwarf2_record_block_ranges (die, block, baseaddr, cu);

  /* Attach template arguments to function.  */
  if (! VEC_empty (symbolp, template_args))
    {
      gdb_assert (templ_func != NULL);

      templ_func->n_template_arguments = VEC_length (symbolp, template_args);
      templ_func->template_arguments
	= obstack_alloc (&objfile->objfile_obstack,
			 (templ_func->n_template_arguments
			  * sizeof (struct symbol *)));
      memcpy (templ_func->template_arguments,
	      VEC_address (symbolp, template_args),
	      (templ_func->n_template_arguments * sizeof (struct symbol *)));
      VEC_free (symbolp, template_args);
    }

  /* In C++, we can have functions nested inside functions (e.g., when
     a function declares a class that has methods).  This means that
     when we finish processing a function scope, we may need to go
     back to building a containing block's symbol lists.  */
  local_symbols = new->locals;
  using_directives = new->using_directives;

  /* If we've finished processing a top-level function, subsequent
     symbols go in the file symbol list.  */
  if (outermost_context_p ())
    cu->list_in_scope = &file_symbols;
}

/* Process all the DIES contained within a lexical block scope.  Start
   a new scope, process the dies, and then close the scope.  */

static void
read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct context_stack *new;
  CORE_ADDR lowpc, highpc;
  struct die_info *child_die;
  CORE_ADDR baseaddr;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  /* Ignore blocks with missing or invalid low and high pc attributes.  */
  /* ??? Perhaps consider discontiguous blocks defined by DW_AT_ranges
     as multiple lexical blocks?  Handling children in a sane way would
     be nasty.  Might be easier to properly extend generic blocks to
     describe ranges.  */
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu, NULL))
    return;
  lowpc += baseaddr;
  highpc += baseaddr;

  push_context (0, lowpc);
  if (die->child != NULL)
    {
      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  process_die (child_die, cu);
	  child_die = sibling_die (child_die);
	}
    }
  new = pop_context ();

  if (local_symbols != NULL || using_directives != NULL)
    {
      struct block *block
        = finish_block (0, &local_symbols, new->old_blocks, new->start_addr,
                        highpc, objfile);

      /* Note that recording ranges after traversing children, as we
         do here, means that recording a parent's ranges entails
         walking across all its children's ranges as they appear in
         the address map, which is quadratic behavior.

         It would be nicer to record the parent's ranges before
         traversing its children, simply overriding whatever you find
         there.  But since we don't even decide whether to create a
         block until after we've traversed its children, that's hard
         to do.  */
      dwarf2_record_block_ranges (die, block, baseaddr, cu);
    }
  local_symbols = new->locals;
  using_directives = new->using_directives;
}

/* Read in DW_TAG_GNU_call_site and insert it to CU->call_site_htab.  */

static void
read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  CORE_ADDR pc, baseaddr;
  struct attribute *attr;
  struct call_site *call_site, call_site_local;
  void **slot;
  int nparams;
  struct die_info *child_die;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  attr = dwarf2_attr (die, DW_AT_low_pc, cu);
  if (!attr)
    {
      complaint (&symfile_complaints,
		 _("missing DW_AT_low_pc for DW_TAG_GNU_call_site "
		   "DIE 0x%x [in module %s]"),
		 die->offset.sect_off, objfile_name (objfile));
      return;
    }
  pc = DW_ADDR (attr) + baseaddr;

  if (cu->call_site_htab == NULL)
    cu->call_site_htab = htab_create_alloc_ex (16, core_addr_hash, core_addr_eq,
					       NULL, &objfile->objfile_obstack,
					       hashtab_obstack_allocate, NULL);
  call_site_local.pc = pc;
  slot = htab_find_slot (cu->call_site_htab, &call_site_local, INSERT);
  if (*slot != NULL)
    {
      complaint (&symfile_complaints,
		 _("Duplicate PC %s for DW_TAG_GNU_call_site "
		   "DIE 0x%x [in module %s]"),
		 paddress (gdbarch, pc), die->offset.sect_off,
		 objfile_name (objfile));
      return;
    }

  /* Count parameters at the caller.  */

  nparams = 0;
  for (child_die = die->child; child_die && child_die->tag;
       child_die = sibling_die (child_die))
    {
      if (child_die->tag != DW_TAG_GNU_call_site_parameter)
	{
	  complaint (&symfile_complaints,
		     _("Tag %d is not DW_TAG_GNU_call_site_parameter in "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->tag, child_die->offset.sect_off,
		     objfile_name (objfile));
	  continue;
	}

      nparams++;
    }

  call_site = obstack_alloc (&objfile->objfile_obstack,
			     (sizeof (*call_site)
			      + (sizeof (*call_site->parameter)
				 * (nparams - 1))));
  *slot = call_site;
  memset (call_site, 0, sizeof (*call_site) - sizeof (*call_site->parameter));
  call_site->pc = pc;

  if (dwarf2_flag_true_p (die, DW_AT_GNU_tail_call, cu))
    {
      struct die_info *func_die;

      /* Skip also over DW_TAG_inlined_subroutine.  */
      for (func_die = die->parent;
	   func_die && func_die->tag != DW_TAG_subprogram
	   && func_die->tag != DW_TAG_subroutine_type;
	   func_die = func_die->parent);

      /* DW_AT_GNU_all_call_sites is a superset
	 of DW_AT_GNU_all_tail_call_sites.  */
      if (func_die
          && !dwarf2_flag_true_p (func_die, DW_AT_GNU_all_call_sites, cu)
	  && !dwarf2_flag_true_p (func_die, DW_AT_GNU_all_tail_call_sites, cu))
	{
	  /* TYPE_TAIL_CALL_LIST is not interesting in functions where it is
	     not complete.  But keep CALL_SITE for look ups via call_site_htab,
	     both the initial caller containing the real return address PC and
	     the final callee containing the current PC of a chain of tail
	     calls do not need to have the tail call list complete.  But any
	     function candidate for a virtual tail call frame searched via
	     TYPE_TAIL_CALL_LIST must have the tail call list complete to be
	     determined unambiguously.  */
	}
      else
	{
	  struct type *func_type = NULL;

	  if (func_die)
	    func_type = get_die_type (func_die, cu);
	  if (func_type != NULL)
	    {
	      gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC);

	      /* Enlist this call site to the function.  */
	      call_site->tail_call_next = TYPE_TAIL_CALL_LIST (func_type);
	      TYPE_TAIL_CALL_LIST (func_type) = call_site;
	    }
	  else
	    complaint (&symfile_complaints,
		       _("Cannot find function owning DW_TAG_GNU_call_site "
			 "DIE 0x%x [in module %s]"),
		       die->offset.sect_off, objfile_name (objfile));
	}
    }

  attr = dwarf2_attr (die, DW_AT_GNU_call_site_target, cu);
  if (attr == NULL)
    attr = dwarf2_attr (die, DW_AT_abstract_origin, cu);
  SET_FIELD_DWARF_BLOCK (call_site->target, NULL);
  if (!attr || (attr_form_is_block (attr) && DW_BLOCK (attr)->size == 0))
    /* Keep NULL DWARF_BLOCK.  */;
  else if (attr_form_is_block (attr))
    {
      struct dwarf2_locexpr_baton *dlbaton;

      dlbaton = obstack_alloc (&objfile->objfile_obstack, sizeof (*dlbaton));
      dlbaton->data = DW_BLOCK (attr)->data;
      dlbaton->size = DW_BLOCK (attr)->size;
      dlbaton->per_cu = cu->per_cu;

      SET_FIELD_DWARF_BLOCK (call_site->target, dlbaton);
    }
  else if (attr_form_is_ref (attr))
    {
      struct dwarf2_cu *target_cu = cu;
      struct die_info *target_die;

      target_die = follow_die_ref (die, attr, &target_cu);
      gdb_assert (target_cu->objfile == objfile);
      if (die_is_declaration (target_die, target_cu))
	{
	  const char *target_physname = NULL;
	  struct attribute *target_attr;

	  /* Prefer the mangled name; otherwise compute the demangled one.  */
	  target_attr = dwarf2_attr (target_die, DW_AT_linkage_name, target_cu);
	  if (target_attr == NULL)
	    target_attr = dwarf2_attr (target_die, DW_AT_MIPS_linkage_name,
				       target_cu);
	  if (target_attr != NULL && DW_STRING (target_attr) != NULL)
	    target_physname = DW_STRING (target_attr);
	  else
	    target_physname = dwarf2_physname (NULL, target_die, target_cu);
	  if (target_physname == NULL)
	    complaint (&symfile_complaints,
		       _("DW_AT_GNU_call_site_target target DIE has invalid "
		         "physname, for referencing DIE 0x%x [in module %s]"),
		       die->offset.sect_off, objfile_name (objfile));
	  else
	    SET_FIELD_PHYSNAME (call_site->target, target_physname);
	}
      else
	{
	  CORE_ADDR lowpc;

	  /* DW_AT_entry_pc should be preferred.  */
	  if (!dwarf2_get_pc_bounds (target_die, &lowpc, NULL, target_cu, NULL))
	    complaint (&symfile_complaints,
		       _("DW_AT_GNU_call_site_target target DIE has invalid "
		         "low pc, for referencing DIE 0x%x [in module %s]"),
		       die->offset.sect_off, objfile_name (objfile));
	  else
	    SET_FIELD_PHYSADDR (call_site->target, lowpc + baseaddr);
	}
    }
  else
    complaint (&symfile_complaints,
	       _("DW_TAG_GNU_call_site DW_AT_GNU_call_site_target is neither "
		 "block nor reference, for DIE 0x%x [in module %s]"),
	       die->offset.sect_off, objfile_name (objfile));

  call_site->per_cu = cu->per_cu;

  for (child_die = die->child;
       child_die && child_die->tag;
       child_die = sibling_die (child_die))
    {
      struct call_site_parameter *parameter;
      struct attribute *loc, *origin;

      if (child_die->tag != DW_TAG_GNU_call_site_parameter)
	{
	  /* Already printed the complaint above.  */
	  continue;
	}

      gdb_assert (call_site->parameter_count < nparams);
      parameter = &call_site->parameter[call_site->parameter_count];

      /* DW_AT_location specifies the register number or DW_AT_abstract_origin
	 specifies DW_TAG_formal_parameter.  Value of the data assumed for the
	 register is contained in DW_AT_GNU_call_site_value.  */

      loc = dwarf2_attr (child_die, DW_AT_location, cu);
      origin = dwarf2_attr (child_die, DW_AT_abstract_origin, cu);
      if (loc == NULL && origin != NULL && attr_form_is_ref (origin))
	{
	  sect_offset offset;

	  parameter->kind = CALL_SITE_PARAMETER_PARAM_OFFSET;
	  offset = dwarf2_get_ref_die_offset (origin);
	  if (!offset_in_cu_p (&cu->header, offset))
	    {
	      /* As DW_OP_GNU_parameter_ref uses CU-relative offset this
		 binding can be done only inside one CU.  Such referenced DIE
		 therefore cannot be even moved to DW_TAG_partial_unit.  */
	      complaint (&symfile_complaints,
			 _("DW_AT_abstract_origin offset is not in CU for "
			   "DW_TAG_GNU_call_site child DIE 0x%x "
			   "[in module %s]"),
			 child_die->offset.sect_off, objfile_name (objfile));
	      continue;
	    }
	  parameter->u.param_offset.cu_off = (offset.sect_off
	                                      - cu->header.offset.sect_off);
	}
      else if (loc == NULL || origin != NULL || !attr_form_is_block (loc))
	{
	  complaint (&symfile_complaints,
		     _("No DW_FORM_block* DW_AT_location for "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->offset.sect_off, objfile_name (objfile));
	  continue;
	}
      else
	{
	  parameter->u.dwarf_reg = dwarf_block_to_dwarf_reg
	    (DW_BLOCK (loc)->data, &DW_BLOCK (loc)->data[DW_BLOCK (loc)->size]);
	  if (parameter->u.dwarf_reg != -1)
	    parameter->kind = CALL_SITE_PARAMETER_DWARF_REG;
	  else if (dwarf_block_to_sp_offset (gdbarch, DW_BLOCK (loc)->data,
				    &DW_BLOCK (loc)->data[DW_BLOCK (loc)->size],
					     &parameter->u.fb_offset))
	    parameter->kind = CALL_SITE_PARAMETER_FB_OFFSET;
	  else
	    {
	      complaint (&symfile_complaints,
			 _("Only single DW_OP_reg or DW_OP_fbreg is supported "
			   "for DW_FORM_block* DW_AT_location is supported for "
			   "DW_TAG_GNU_call_site child DIE 0x%x "
			   "[in module %s]"),
			 child_die->offset.sect_off, objfile_name (objfile));
	      continue;
	    }
	}

      attr = dwarf2_attr (child_die, DW_AT_GNU_call_site_value, cu);
      if (!attr_form_is_block (attr))
	{
	  complaint (&symfile_complaints,
		     _("No DW_FORM_block* DW_AT_GNU_call_site_value for "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->offset.sect_off, objfile_name (objfile));
	  continue;
	}
      parameter->value = DW_BLOCK (attr)->data;
      parameter->value_size = DW_BLOCK (attr)->size;

      /* Parameters are not pre-cleared by memset above.  */
      parameter->data_value = NULL;
      parameter->data_value_size = 0;
      call_site->parameter_count++;

      attr = dwarf2_attr (child_die, DW_AT_GNU_call_site_data_value, cu);
      if (attr)
	{
	  if (!attr_form_is_block (attr))
	    complaint (&symfile_complaints,
		       _("No DW_FORM_block* DW_AT_GNU_call_site_data_value for "
			 "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		       child_die->offset.sect_off, objfile_name (objfile));
	  else
	    {
	      parameter->data_value = DW_BLOCK (attr)->data;
	      parameter->data_value_size = DW_BLOCK (attr)->size;
	    }
	}
    }
}

/* Get low and high pc attributes from DW_AT_ranges attribute value OFFSET.
   Return 1 if the attributes are present and valid, otherwise, return 0.
   If RANGES_PST is not NULL we should setup `objfile->psymtabs_addrmap'.  */

static int
dwarf2_ranges_read (unsigned offset, CORE_ADDR *low_return,
		    CORE_ADDR *high_return, struct dwarf2_cu *cu,
		    struct partial_symtab *ranges_pst)
{
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
  bfd *obfd = objfile->obfd;
  unsigned int addr_size = cu_header->addr_size;
  CORE_ADDR mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));
  /* Base address selection entry.  */
  CORE_ADDR base;
  int found_base;
  unsigned int dummy;
  const gdb_byte *buffer;
  CORE_ADDR marker;
  int low_set;
  CORE_ADDR low = 0;
  CORE_ADDR high = 0;
  CORE_ADDR baseaddr;

  found_base = cu->base_known;
  base = cu->base_address;

  dwarf2_read_section (objfile, &dwarf2_per_objfile->ranges);
  if (offset >= dwarf2_per_objfile->ranges.size)
    {
      complaint (&symfile_complaints,
		 _("Offset %d out of bounds for DW_AT_ranges attribute"),
		 offset);
      return 0;
    }
  buffer = dwarf2_per_objfile->ranges.buffer + offset;

  /* Read in the largest possible address.  */
  marker = read_address (obfd, buffer, cu, &dummy);
  if ((marker & mask) == mask)
    {
      /* If we found the largest possible address, then
	 read the base address.  */
      base = read_address (obfd, buffer + addr_size, cu, &dummy);
      buffer += 2 * addr_size;
      offset += 2 * addr_size;
      found_base = 1;
    }

  low_set = 0;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  while (1)
    {
      CORE_ADDR range_beginning, range_end;

      range_beginning = read_address (obfd, buffer, cu, &dummy);
      buffer += addr_size;
      range_end = read_address (obfd, buffer, cu, &dummy);
      buffer += addr_size;
      offset += 2 * addr_size;

      /* An end of list marker is a pair of zero addresses.  */
      if (range_beginning == 0 && range_end == 0)
	/* Found the end of list entry.  */
	break;

      /* Each base address selection entry is a pair of 2 values.
	 The first is the largest possible address, the second is
	 the base address.  Check for a base address here.  */
      if ((range_beginning & mask) == mask)
	{
	  /* If we found the largest possible address, then
	     read the base address.  */
	  base = read_address (obfd, buffer + addr_size, cu, &dummy);
	  found_base = 1;
	  continue;
	}

      if (!found_base)
	{
	  /* We have no valid base address for the ranges
	     data.  */
	  complaint (&symfile_complaints,
		     _("Invalid .debug_ranges data (no base address)"));
	  return 0;
	}

      if (range_beginning > range_end)
	{
	  /* Inverted range entries are invalid.  */
	  complaint (&symfile_complaints,
		     _("Invalid .debug_ranges data (inverted range)"));
	  return 0;
	}

      /* Empty range entries have no effect.  */
      if (range_beginning == range_end)
	continue;

      range_beginning += base;
      range_end += base;

      /* A not-uncommon case of bad debug info.
	 Don't pollute the addrmap with bad data.  */
      if (range_beginning + baseaddr == 0
	  && !dwarf2_per_objfile->has_section_at_zero)
	{
	  complaint (&symfile_complaints,
		     _(".debug_ranges entry has start address of zero"
		       " [in module %s]"), objfile_name (objfile));
	  continue;
	}

      if (ranges_pst != NULL)
	addrmap_set_empty (objfile->psymtabs_addrmap,
			   range_beginning + baseaddr,
			   range_end - 1 + baseaddr,
			   ranges_pst);

      /* FIXME: This is recording everything as a low-high
	 segment of consecutive addresses.  We should have a
	 data structure for discontiguous block ranges
	 instead.  */
      if (! low_set)
	{
	  low = range_beginning;
	  high = range_end;
	  low_set = 1;
	}
      else
	{
	  if (range_beginning < low)
	    low = range_beginning;
	  if (range_end > high)
	    high = range_end;
	}
    }

  if (! low_set)
    /* If the first entry is an end-of-list marker, the range
       describes an empty scope, i.e. no instructions.  */
    return 0;

  if (low_return)
    *low_return = low;
  if (high_return)
    *high_return = high;
  return 1;
}

/* Get low and high pc attributes from a die.  Return 1 if the attributes
   are present and valid, otherwise, return 0.  Return -1 if the range is
   discontinuous, i.e. derived from DW_AT_ranges information.  */

static int
dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,
		      CORE_ADDR *highpc, struct dwarf2_cu *cu,
		      struct partial_symtab *pst)
{
  struct attribute *attr;
  struct attribute *attr_high;
  CORE_ADDR low = 0;
  CORE_ADDR high = 0;
  int ret = 0;

  attr_high = dwarf2_attr (die, DW_AT_high_pc, cu);
  if (attr_high)
    {
      attr = dwarf2_attr (die, DW_AT_low_pc, cu);
      if (attr)
        {
	  low = DW_ADDR (attr);
	  if (attr_high->form == DW_FORM_addr
	      || attr_high->form == DW_FORM_GNU_addr_index)
	    high = DW_ADDR (attr_high);
	  else
	    high = low + DW_UNSND (attr_high);
	}
      else
	/* Found high w/o low attribute.  */
	return 0;

      /* Found consecutive range of addresses.  */
      ret = 1;
    }
  else
    {
      attr = dwarf2_attr (die, DW_AT_ranges, cu);
      if (attr != NULL)
	{
	  /* DW_AT_ranges_base does not apply to DIEs from the DWO skeleton.
	     We take advantage of the fact that DW_AT_ranges does not appear
	     in DW_TAG_compile_unit of DWO files.  */
	  int need_ranges_base = die->tag != DW_TAG_compile_unit;
	  unsigned int ranges_offset = (DW_UNSND (attr)
					+ (need_ranges_base
					   ? cu->ranges_base
					   : 0));

	  /* Value of the DW_AT_ranges attribute is the offset in the
	     .debug_ranges section.  */
	  if (!dwarf2_ranges_read (ranges_offset, &low, &high, cu, pst))
	    return 0;
	  /* Found discontinuous range of addresses.  */
	  ret = -1;
	}
    }

  /* read_partial_die has also the strict LOW < HIGH requirement.  */
  if (high <= low)
    return 0;

  /* When using the GNU linker, .gnu.linkonce. sections are used to
     eliminate duplicate copies of functions and vtables and such.
     The linker will arbitrarily choose one and discard the others.
     The AT_*_pc values for such functions refer to local labels in
     these sections.  If the section from that file was discarded, the
     labels are not in the output, so the relocs get a value of 0.
     If this is a discarded function, mark the pc bounds as invalid,
     so that GDB will ignore it.  */
  if (low == 0 && !dwarf2_per_objfile->has_section_at_zero)
    return 0;

  *lowpc = low;
  if (highpc)
    *highpc = high;
  return ret;
}

/* Assuming that DIE represents a subprogram DIE or a lexical block, get
   its low and high PC addresses.  Do nothing if these addresses could not
   be determined.  Otherwise, set LOWPC to the low address if it is smaller,
   and HIGHPC to the high address if greater than HIGHPC.  */

static void
dwarf2_get_subprogram_pc_bounds (struct die_info *die,
                                 CORE_ADDR *lowpc, CORE_ADDR *highpc,
                                 struct dwarf2_cu *cu)
{
  CORE_ADDR low, high;
  struct die_info *child = die->child;

  if (dwarf2_get_pc_bounds (die, &low, &high, cu, NULL))
    {
      *lowpc = min (*lowpc, low);
      *highpc = max (*highpc, high);
    }

  /* If the language does not allow nested subprograms (either inside
     subprograms or lexical blocks), we're done.  */
  if (cu->language != language_ada)
    return;

  /* Check all the children of the given DIE.  If it contains nested
     subprograms, then check their pc bounds.  Likewise, we need to
     check lexical blocks as well, as they may also contain subprogram
     definitions.  */
  while (child && child->tag)
    {
      if (child->tag == DW_TAG_subprogram
          || child->tag == DW_TAG_lexical_block)
        dwarf2_get_subprogram_pc_bounds (child, lowpc, highpc, cu);
      child = sibling_die (child);
    }
}

/* Get the low and high pc's represented by the scope DIE, and store
   them in *LOWPC and *HIGHPC.  If the correct values can't be
   determined, set *LOWPC to -1 and *HIGHPC to 0.  */

static void
get_scope_pc_bounds (struct die_info *die,
		     CORE_ADDR *lowpc, CORE_ADDR *highpc,
		     struct dwarf2_cu *cu)
{
  CORE_ADDR best_low = (CORE_ADDR) -1;
  CORE_ADDR best_high = (CORE_ADDR) 0;
  CORE_ADDR current_low, current_high;

  if (dwarf2_get_pc_bounds (die, &current_low, &current_high, cu, NULL))
    {
      best_low = current_low;
      best_high = current_high;
    }
  else
    {
      struct die_info *child = die->child;

      while (child && child->tag)
	{
	  switch (child->tag) {
	  case DW_TAG_subprogram:
            dwarf2_get_subprogram_pc_bounds (child, &best_low, &best_high, cu);
	    break;
	  case DW_TAG_namespace:
	  case DW_TAG_module:
	    /* FIXME: carlton/2004-01-16: Should we do this for
	       DW_TAG_class_type/DW_TAG_structure_type, too?  I think
	       that current GCC's always emit the DIEs corresponding
	       to definitions of methods of classes as children of a
	       DW_TAG_compile_unit or DW_TAG_namespace (as opposed to
	       the DIEs giving the declarations, which could be
	       anywhere).  But I don't see any reason why the
	       standards says that they have to be there.  */
	    get_scope_pc_bounds (child, &current_low, &current_high, cu);

	    if (current_low != ((CORE_ADDR) -1))
	      {
		best_low = min (best_low, current_low);
		best_high = max (best_high, current_high);
	      }
	    break;
	  default:
	    /* Ignore.  */
	    break;
	  }

	  child = sibling_die (child);
	}
    }

  *lowpc = best_low;
  *highpc = best_high;
}

/* Record the address ranges for BLOCK, offset by BASEADDR, as given
   in DIE.  */

static void
dwarf2_record_block_ranges (struct die_info *die, struct block *block,
                            CORE_ADDR baseaddr, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct attribute *attr;
  struct attribute *attr_high;

  attr_high = dwarf2_attr (die, DW_AT_high_pc, cu);
  if (attr_high)
    {
      attr = dwarf2_attr (die, DW_AT_low_pc, cu);
      if (attr)
        {
          CORE_ADDR low = DW_ADDR (attr);
	  CORE_ADDR high;
	  if (attr_high->form == DW_FORM_addr
	      || attr_high->form == DW_FORM_GNU_addr_index)
	    high = DW_ADDR (attr_high);
	  else
	    high = low + DW_UNSND (attr_high);

          record_block_range (block, baseaddr + low, baseaddr + high - 1);
        }
    }

  attr = dwarf2_attr (die, DW_AT_ranges, cu);
  if (attr)
    {
      bfd *obfd = objfile->obfd;
      /* DW_AT_ranges_base does not apply to DIEs from the DWO skeleton.
	 We take advantage of the fact that DW_AT_ranges does not appear
	 in DW_TAG_compile_unit of DWO files.  */
      int need_ranges_base = die->tag != DW_TAG_compile_unit;

      /* The value of the DW_AT_ranges attribute is the offset of the
         address range list in the .debug_ranges section.  */
      unsigned long offset = (DW_UNSND (attr)
			      + (need_ranges_base ? cu->ranges_base : 0));
      const gdb_byte *buffer;

      /* For some target architectures, but not others, the
         read_address function sign-extends the addresses it returns.
         To recognize base address selection entries, we need a
         mask.  */
      unsigned int addr_size = cu->header.addr_size;
      CORE_ADDR base_select_mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));

      /* The base address, to which the next pair is relative.  Note
         that this 'base' is a DWARF concept: most entries in a range
         list are relative, to reduce the number of relocs against the
         debugging information.  This is separate from this function's
         'baseaddr' argument, which GDB uses to relocate debugging
         information from a shared library based on the address at
         which the library was loaded.  */
      CORE_ADDR base = cu->base_address;
      int base_known = cu->base_known;

      dwarf2_read_section (objfile, &dwarf2_per_objfile->ranges);
      if (offset >= dwarf2_per_objfile->ranges.size)
        {
          complaint (&symfile_complaints,
                     _("Offset %lu out of bounds for DW_AT_ranges attribute"),
                     offset);
          return;
        }
      buffer = dwarf2_per_objfile->ranges.buffer + offset;

      for (;;)
        {
          unsigned int bytes_read;
          CORE_ADDR start, end;

          start = read_address (obfd, buffer, cu, &bytes_read);
          buffer += bytes_read;
          end = read_address (obfd, buffer, cu, &bytes_read);
          buffer += bytes_read;

          /* Did we find the end of the range list?  */
          if (start == 0 && end == 0)
            break;

          /* Did we find a base address selection entry?  */
          else if ((start & base_select_mask) == base_select_mask)
            {
              base = end;
              base_known = 1;
            }

          /* We found an ordinary address range.  */
          else
            {
              if (!base_known)
                {
                  complaint (&symfile_complaints,
			     _("Invalid .debug_ranges data "
			       "(no base address)"));
                  return;
                }

	      if (start > end)
		{
		  /* Inverted range entries are invalid.  */
		  complaint (&symfile_complaints,
			     _("Invalid .debug_ranges data "
			       "(inverted range)"));
		  return;
		}

	      /* Empty range entries have no effect.  */
	      if (start == end)
		continue;

	      start += base + baseaddr;
	      end += base + baseaddr;

	      /* A not-uncommon case of bad debug info.
		 Don't pollute the addrmap with bad data.  */
	      if (start == 0 && !dwarf2_per_objfile->has_section_at_zero)
		{
		  complaint (&symfile_complaints,
			     _(".debug_ranges entry has start address of zero"
			       " [in module %s]"), objfile_name (objfile));
		  continue;
		}

              record_block_range (block, start, end - 1);
            }
        }
    }
}

/* Check whether the producer field indicates either of GCC < 4.6, or the
   Intel C/C++ compiler, and cache the result in CU.  */

static void
check_producer (struct dwarf2_cu *cu)
{
  const char *cs;
  int major, minor, release;

  if (cu->producer == NULL)
    {
      /* For unknown compilers expect their behavior is DWARF version
	 compliant.

	 GCC started to support .debug_types sections by -gdwarf-4 since
	 gcc-4.5.x.  As the .debug_types sections are missing DW_AT_producer
	 for their space efficiency GDB cannot workaround gcc-4.5.x -gdwarf-4
	 combination.  gcc-4.5.x -gdwarf-4 binaries have DW_AT_accessibility
	 interpreted incorrectly by GDB now - GCC PR debug/48229.  */
    }
  else if (strncmp (cu->producer, "GNU ", strlen ("GNU ")) == 0)
    {
      /* Skip any identifier after "GNU " - such as "C++" or "Java".  */

      cs = &cu->producer[strlen ("GNU ")];
      while (*cs && !isdigit (*cs))
	cs++;
      if (sscanf (cs, "%d.%d.%d", &major, &minor, &release) != 3)
	{
	  /* Not recognized as GCC.  */
	}
      else
	{
	  cu->producer_is_gxx_lt_4_6 = major < 4 || (major == 4 && minor < 6);
	  cu->producer_is_gcc_lt_4_3 = major < 4 || (major == 4 && minor < 3);
	}
    }
  else if (strncmp (cu->producer, "Intel(R) C", strlen ("Intel(R) C")) == 0)
    cu->producer_is_icc = 1;
  else
    {
      /* For other non-GCC compilers, expect their behavior is DWARF version
	 compliant.  */
    }

  cu->checked_producer = 1;
}

/* Check for GCC PR debug/45124 fix which is not present in any G++ version up
   to 4.5.any while it is present already in G++ 4.6.0 - the PR has been fixed
   during 4.6.0 experimental.  */

static int
producer_is_gxx_lt_4_6 (struct dwarf2_cu *cu)
{
  if (!cu->checked_producer)
    check_producer (cu);

  return cu->producer_is_gxx_lt_4_6;
}

/* Return the default accessibility type if it is not overriden by
   DW_AT_accessibility.  */

static enum dwarf_access_attribute
dwarf2_default_access_attribute (struct die_info *die, struct dwarf2_cu *cu)
{
  if (cu->header.version < 3 || producer_is_gxx_lt_4_6 (cu))
    {
      /* The default DWARF 2 accessibility for members is public, the default
	 accessibility for inheritance is private.  */

      if (die->tag != DW_TAG_inheritance)
	return DW_ACCESS_public;
      else
	return DW_ACCESS_private;
    }
  else
    {
      /* DWARF 3+ defines the default accessibility a different way.  The same
	 rules apply now for DW_TAG_inheritance as for the members and it only
	 depends on the container kind.  */

      if (die->parent->tag == DW_TAG_class_type)
	return DW_ACCESS_private;
      else
	return DW_ACCESS_public;
    }
}

/* Look for DW_AT_data_member_location.  Set *OFFSET to the byte
   offset.  If the attribute was not found return 0, otherwise return
   1.  If it was found but could not properly be handled, set *OFFSET
   to 0.  */

static int
handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,
			     LONGEST *offset)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_data_member_location, cu);
  if (attr != NULL)
    {
      *offset = 0;

      /* Note that we do not check for a section offset first here.
	 This is because DW_AT_data_member_location is new in DWARF 4,
	 so if we see it, we can assume that a constant form is really
	 a constant and not a section offset.  */
      if (attr_form_is_constant (attr))
	*offset = dwarf2_get_attr_constant_value (attr, 0);
      else if (attr_form_is_section_offset (attr))
	dwarf2_complex_location_expr_complaint ();
      else if (attr_form_is_block (attr))
	*offset = decode_locdesc (DW_BLOCK (attr), cu);
      else
	dwarf2_complex_location_expr_complaint ();

      return 1;
    }

  return 0;
}

/* Add an aggregate field to the field list.  */

static void
dwarf2_add_field (struct field_info *fip, struct die_info *die,
		  struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct nextfield *new_field;
  struct attribute *attr;
  struct field *fp;
  const char *fieldname = "";

  /* Allocate a new field list entry and link it in.  */
  new_field = (struct nextfield *) xmalloc (sizeof (struct nextfield));
  make_cleanup (xfree, new_field);
  memset (new_field, 0, sizeof (struct nextfield));

  if (die->tag == DW_TAG_inheritance)
    {
      new_field->next = fip->baseclasses;
      fip->baseclasses = new_field;
    }
  else
    {
      new_field->next = fip->fields;
      fip->fields = new_field;
    }
  fip->nfields++;

  attr = dwarf2_attr (die, DW_AT_accessibility, cu);
  if (attr)
    new_field->accessibility = DW_UNSND (attr);
  else
    new_field->accessibility = dwarf2_default_access_attribute (die, cu);
  if (new_field->accessibility != DW_ACCESS_public)
    fip->non_public_fields = 1;

  attr = dwarf2_attr (die, DW_AT_virtuality, cu);
  if (attr)
    new_field->virtuality = DW_UNSND (attr);
  else
    new_field->virtuality = DW_VIRTUALITY_none;

  fp = &new_field->field;

  if (die->tag == DW_TAG_member && ! die_is_declaration (die, cu))
    {
      LONGEST offset;

      /* Data member other than a C++ static data member.  */

      /* Get type of field.  */
      fp->type = die_type (die, cu);

      SET_FIELD_BITPOS (*fp, 0);

      /* Get bit size of field (zero if none).  */
      attr = dwarf2_attr (die, DW_AT_bit_size, cu);
      if (attr)
	{
	  FIELD_BITSIZE (*fp) = DW_UNSND (attr);
	}
      else
	{
	  FIELD_BITSIZE (*fp) = 0;
	}

      /* Get bit offset of field.  */
      if (handle_data_member_location (die, cu, &offset))
	SET_FIELD_BITPOS (*fp, offset * bits_per_byte);
      attr = dwarf2_attr (die, DW_AT_bit_offset, cu);
      if (attr)
	{
	  if (gdbarch_bits_big_endian (gdbarch))
	    {
	      /* For big endian bits, the DW_AT_bit_offset gives the
	         additional bit offset from the MSB of the containing
	         anonymous object to the MSB of the field.  We don't
	         have to do anything special since we don't need to
	         know the size of the anonymous object.  */
	      SET_FIELD_BITPOS (*fp, FIELD_BITPOS (*fp) + DW_UNSND (attr));
	    }
	  else
	    {
	      /* For little endian bits, compute the bit offset to the
	         MSB of the anonymous object, subtract off the number of
	         bits from the MSB of the field to the MSB of the
	         object, and then subtract off the number of bits of
	         the field itself.  The result is the bit offset of
	         the LSB of the field.  */
	      int anonymous_size;
	      int bit_offset = DW_UNSND (attr);

	      attr = dwarf2_attr (die, DW_AT_byte_size, cu);
	      if (attr)
		{
		  /* The size of the anonymous object containing
		     the bit field is explicit, so use the
		     indicated size (in bytes).  */
		  anonymous_size = DW_UNSND (attr);
		}
	      else
		{
		  /* The size of the anonymous object containing
		     the bit field must be inferred from the type
		     attribute of the data member containing the
		     bit field.  */
		  anonymous_size = TYPE_LENGTH (fp->type);
		}
	      SET_FIELD_BITPOS (*fp,
				(FIELD_BITPOS (*fp)
				 + anonymous_size * bits_per_byte
				 - bit_offset - FIELD_BITSIZE (*fp)));
	    }
	}

      /* Get name of field.  */
      fieldname = dwarf2_name (die, cu);
      if (fieldname == NULL)
	fieldname = "";

      /* The name is already allocated along with this objfile, so we don't
	 need to duplicate it for the type.  */
      fp->name = fieldname;

      /* Change accessibility for artificial fields (e.g. virtual table
         pointer or virtual base class pointer) to private.  */
      if (dwarf2_attr (die, DW_AT_artificial, cu))
	{
	  FIELD_ARTIFICIAL (*fp) = 1;
	  new_field->accessibility = DW_ACCESS_private;
	  fip->non_public_fields = 1;
	}
    }
  else if (die->tag == DW_TAG_member || die->tag == DW_TAG_variable)
    {
      /* C++ static member.  */

      /* NOTE: carlton/2002-11-05: It should be a DW_TAG_member that
	 is a declaration, but all versions of G++ as of this writing
	 (so through at least 3.2.1) incorrectly generate
	 DW_TAG_variable tags.  */

      const char *physname;

      /* Get name of field.  */
      fieldname = dwarf2_name (die, cu);
      if (fieldname == NULL)
	return;

      attr = dwarf2_attr (die, DW_AT_const_value, cu);
      if (attr
	  /* Only create a symbol if this is an external value.
	     new_symbol checks this and puts the value in the global symbol
	     table, which we want.  If it is not external, new_symbol
	     will try to put the value in cu->list_in_scope which is wrong.  */
	  && dwarf2_flag_true_p (die, DW_AT_external, cu))
	{
	  /* A static const member, not much different than an enum as far as
	     we're concerned, except that we can support more types.  */
	  new_symbol (die, NULL, cu);
	}

      /* Get physical name.  */
      physname = dwarf2_physname (fieldname, die, cu);

      /* The name is already allocated along with this objfile, so we don't
	 need to duplicate it for the type.  */
      SET_FIELD_PHYSNAME (*fp, physname ? physname : "");
      FIELD_TYPE (*fp) = die_type (die, cu);
      FIELD_NAME (*fp) = fieldname;
    }
  else if (die->tag == DW_TAG_inheritance)
    {
      LONGEST offset;

      /* C++ base class field.  */
      if (handle_data_member_location (die, cu, &offset))
	SET_FIELD_BITPOS (*fp, offset * bits_per_byte);
      FIELD_BITSIZE (*fp) = 0;
      FIELD_TYPE (*fp) = die_type (die, cu);
      FIELD_NAME (*fp) = type_name_no_tag (fp->type);
      fip->nbaseclasses++;
    }
}

/* Add a typedef defined in the scope of the FIP's class.  */

static void
dwarf2_add_typedef (struct field_info *fip, struct die_info *die,
		    struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct typedef_field_list *new_field;
  struct attribute *attr;
  struct typedef_field *fp;
  char *fieldname = "";

  /* Allocate a new field list entry and link it in.  */
  new_field = xzalloc (sizeof (*new_field));
  make_cleanup (xfree, new_field);

  gdb_assert (die->tag == DW_TAG_typedef);

  fp = &new_field->field;

  /* Get name of field.  */
  fp->name = dwarf2_name (die, cu);
  if (fp->name == NULL)
    return;

  fp->type = read_type_die (die, cu);

  new_field->next = fip->typedef_field_list;
  fip->typedef_field_list = new_field;
  fip->typedef_field_list_count++;
}

/* Create the vector of fields, and attach it to the type.  */

static void
dwarf2_attach_fields_to_type (struct field_info *fip, struct type *type,
			      struct dwarf2_cu *cu)
{
  int nfields = fip->nfields;

  /* Record the field count, allocate space for the array of fields,
     and create blank accessibility bitfields if necessary.  */
  TYPE_NFIELDS (type) = nfields;
  TYPE_FIELDS (type) = (struct field *)
    TYPE_ALLOC (type, sizeof (struct field) * nfields);
  memset (TYPE_FIELDS (type), 0, sizeof (struct field) * nfields);

  if (fip->non_public_fields && cu->language != language_ada)
    {
      ALLOCATE_CPLUS_STRUCT_TYPE (type);

      TYPE_FIELD_PRIVATE_BITS (type) =
	(B_TYPE *) TYPE_ALLOC (type, B_BYTES (nfields));
      B_CLRALL (TYPE_FIELD_PRIVATE_BITS (type), nfields);

      TYPE_FIELD_PROTECTED_BITS (type) =
	(B_TYPE *) TYPE_ALLOC (type, B_BYTES (nfields));
      B_CLRALL (TYPE_FIELD_PROTECTED_BITS (type), nfields);

      TYPE_FIELD_IGNORE_BITS (type) =
	(B_TYPE *) TYPE_ALLOC (type, B_BYTES (nfields));
      B_CLRALL (TYPE_FIELD_IGNORE_BITS (type), nfields);
    }

  /* If the type has baseclasses, allocate and clear a bit vector for
     TYPE_FIELD_VIRTUAL_BITS.  */
  if (fip->nbaseclasses && cu->language != language_ada)
    {
      int num_bytes = B_BYTES (fip->nbaseclasses);
      unsigned char *pointer;

      ALLOCATE_CPLUS_STRUCT_TYPE (type);
      pointer = TYPE_ALLOC (type, num_bytes);
      TYPE_FIELD_VIRTUAL_BITS (type) = pointer;
      B_CLRALL (TYPE_FIELD_VIRTUAL_BITS (type), fip->nbaseclasses);
      TYPE_N_BASECLASSES (type) = fip->nbaseclasses;
    }

  /* Copy the saved-up fields into the field vector.  Start from the head of
     the list, adding to the tail of the field array, so that they end up in
     the same order in the array in which they were added to the list.  */
  while (nfields-- > 0)
    {
      struct nextfield *fieldp;

      if (fip->fields)
	{
	  fieldp = fip->fields;
	  fip->fields = fieldp->next;
	}
      else
	{
	  fieldp = fip->baseclasses;
	  fip->baseclasses = fieldp->next;
	}

      TYPE_FIELD (type, nfields) = fieldp->field;
      switch (fieldp->accessibility)
	{
	case DW_ACCESS_private:
	  if (cu->language != language_ada)
	    SET_TYPE_FIELD_PRIVATE (type, nfields);
	  break;

	case DW_ACCESS_protected:
	  if (cu->language != language_ada)
	    SET_TYPE_FIELD_PROTECTED (type, nfields);
	  break;

	case DW_ACCESS_public:
	  break;

	default:
	  /* Unknown accessibility.  Complain and treat it as public.  */
	  {
	    complaint (&symfile_complaints, _("unsupported accessibility %d"),
		       fieldp->accessibility);
	  }
	  break;
	}
      if (nfields < fip->nbaseclasses)
	{
	  switch (fieldp->virtuality)
	    {
	    case DW_VIRTUALITY_virtual:
	    case DW_VIRTUALITY_pure_virtual:
	      if (cu->language == language_ada)
		error (_("unexpected virtuality in component of Ada type"));
	      SET_TYPE_FIELD_VIRTUAL (type, nfields);
	      break;
	    }
	}
    }
}

/* Return true if this member function is a constructor, false
   otherwise.  */

static int
dwarf2_is_constructor (struct die_info *die, struct dwarf2_cu *cu)
{
  const char *fieldname;
  const char *typename;
  int len;

  if (die->parent == NULL)
    return 0;

  if (die->parent->tag != DW_TAG_structure_type
      && die->parent->tag != DW_TAG_union_type
      && die->parent->tag != DW_TAG_class_type)
    return 0;

  fieldname = dwarf2_name (die, cu);
  typename = dwarf2_name (die->parent, cu);
  if (fieldname == NULL || typename == NULL)
    return 0;

  len = strlen (fieldname);
  return (strncmp (fieldname, typename, len) == 0
	  && (typename[len] == '\0' || typename[len] == '<'));
}

/* Add a member function to the proper fieldlist.  */

static void
dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,
		      struct type *type, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct attribute *attr;
  struct fnfieldlist *flp;
  int i;
  struct fn_field *fnp;
  const char *fieldname;
  struct nextfnfield *new_fnfield;
  struct type *this_type;
  enum dwarf_access_attribute accessibility;

  if (cu->language == language_ada)
    error (_("unexpected member function in Ada type"));

  /* Get name of member function.  */
  fieldname = dwarf2_name (die, cu);
  if (fieldname == NULL)
    return;

  /* Look up member function name in fieldlist.  */
  for (i = 0; i < fip->nfnfields; i++)
    {
      if (strcmp (fip->fnfieldlists[i].name, fieldname) == 0)
	break;
    }

  /* Create new list element if necessary.  */
  if (i < fip->nfnfields)
    flp = &fip->fnfieldlists[i];
  else
    {
      if ((fip->nfnfields % DW_FIELD_ALLOC_CHUNK) == 0)
	{
	  fip->fnfieldlists = (struct fnfieldlist *)
	    xrealloc (fip->fnfieldlists,
		      (fip->nfnfields + DW_FIELD_ALLOC_CHUNK)
		      * sizeof (struct fnfieldlist));
	  if (fip->nfnfields == 0)
	    make_cleanup (free_current_contents, &fip->fnfieldlists);
	}
      flp = &fip->fnfieldlists[fip->nfnfields];
      flp->name = fieldname;
      flp->length = 0;
      flp->head = NULL;
      i = fip->nfnfields++;
    }

  /* Create a new member function field and chain it to the field list
     entry.  */
  new_fnfield = (struct nextfnfield *) xmalloc (sizeof (struct nextfnfield));
  make_cleanup (xfree, new_fnfield);
  memset (new_fnfield, 0, sizeof (struct nextfnfield));
  new_fnfield->next = flp->head;
  flp->head = new_fnfield;
  flp->length++;

  /* Fill in the member function field info.  */
  fnp = &new_fnfield->fnfield;

  /* Delay processing of the physname until later.  */
  if (cu->language == language_cplus || cu->language == language_java)
    {
      add_to_method_list (type, i, flp->length - 1, fieldname,
			  die, cu);
    }
  else
    {
      const char *physname = dwarf2_physname (fieldname, die, cu);
      fnp->physname = physname ? physname : "";
    }

  fnp->type = alloc_type (objfile);
  this_type = read_type_die (die, cu);
  if (this_type && TYPE_CODE (this_type) == TYPE_CODE_FUNC)
    {
      int nparams = TYPE_NFIELDS (this_type);

      /* TYPE is the domain of this method, and THIS_TYPE is the type
	   of the method itself (TYPE_CODE_METHOD).  */
      smash_to_method_type (fnp->type, type,
			    TYPE_TARGET_TYPE (this_type),
			    TYPE_FIELDS (this_type),
			    TYPE_NFIELDS (this_type),
			    TYPE_VARARGS (this_type));

      /* Handle static member functions.
         Dwarf2 has no clean way to discern C++ static and non-static
         member functions.  G++ helps GDB by marking the first
         parameter for non-static member functions (which is the this
         pointer) as artificial.  We obtain this information from
         read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
      if (nparams == 0 || TYPE_FIELD_ARTIFICIAL (this_type, 0) == 0)
	fnp->voffset = VOFFSET_STATIC;
    }
  else
    complaint (&symfile_complaints, _("member function type missing for '%s'"),
	       dwarf2_full_name (fieldname, die, cu));

  /* Get fcontext from DW_AT_containing_type if present.  */
  if (dwarf2_attr (die, DW_AT_containing_type, cu) != NULL)
    fnp->fcontext = die_containing_type (die, cu);

  /* dwarf2 doesn't have stubbed physical names, so the setting of is_const and
     is_volatile is irrelevant, as it is needed by gdb_mangle_name only.  */

  /* Get accessibility.  */
  attr = dwarf2_attr (die, DW_AT_accessibility, cu);
  if (attr)
    accessibility = DW_UNSND (attr);
  else
    accessibility = dwarf2_default_access_attribute (die, cu);
  switch (accessibility)
    {
    case DW_ACCESS_private:
      fnp->is_private = 1;
      break;
    case DW_ACCESS_protected:
      fnp->is_protected = 1;
      break;
    }

  /* Check for artificial methods.  */
  attr = dwarf2_attr (die, DW_AT_artificial, cu);
  if (attr && DW_UNSND (attr) != 0)
    fnp->is_artificial = 1;

  fnp->is_constructor = dwarf2_is_constructor (die, cu);

  /* Get index in virtual function table if it is a virtual member
     function.  For older versions of GCC, this is an offset in the
     appropriate virtual table, as specified by DW_AT_containing_type.
     For everyone else, it is an expression to be evaluated relative
     to the object address.  */

  attr = dwarf2_attr (die, DW_AT_vtable_elem_location, cu);
  if (attr)
    {
      if (attr_form_is_block (attr) && DW_BLOCK (attr)->size > 0)
        {
	  if (DW_BLOCK (attr)->data[0] == DW_OP_constu)
	    {
	      /* Old-style GCC.  */
	      fnp->voffset = decode_locdesc (DW_BLOCK (attr), cu) + 2;
	    }
	  else if (DW_BLOCK (attr)->data[0] == DW_OP_deref
		   || (DW_BLOCK (attr)->size > 1
		       && DW_BLOCK (attr)->data[0] == DW_OP_deref_size
		       && DW_BLOCK (attr)->data[1] == cu->header.addr_size))
	    {
	      struct dwarf_block blk;
	      int offset;

	      offset = (DW_BLOCK (attr)->data[0] == DW_OP_deref
			? 1 : 2);
	      blk.size = DW_BLOCK (attr)->size - offset;
	      blk.data = DW_BLOCK (attr)->data + offset;
	      fnp->voffset = decode_locdesc (DW_BLOCK (attr), cu);
	      if ((fnp->voffset % cu->header.addr_size) != 0)
		dwarf2_complex_location_expr_complaint ();
	      else
		fnp->voffset /= cu->header.addr_size;
	      fnp->voffset += 2;
	    }
	  else
	    dwarf2_complex_location_expr_complaint ();

	  if (!fnp->fcontext)
	    fnp->fcontext = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (this_type, 0));
	}
      else if (attr_form_is_section_offset (attr))
        {
	  dwarf2_complex_location_expr_complaint ();
        }
      else
        {
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_vtable_elem_location",
						 fieldname);
        }
    }
  else
    {
      attr = dwarf2_attr (die, DW_AT_virtuality, cu);
      if (attr && DW_UNSND (attr))
	{
	  /* GCC does this, as of 2008-08-25; PR debug/37237.  */
	  complaint (&symfile_complaints,
		     _("Member function \"%s\" (offset %d) is virtual "
		       "but the vtable offset is not specified"),
		     fieldname, die->offset.sect_off);
	  ALLOCATE_CPLUS_STRUCT_TYPE (type);
	  TYPE_CPLUS_DYNAMIC (type) = 1;
	}
    }
}

/* Create the vector of member function fields, and attach it to the type.  */

static void
dwarf2_attach_fn_fields_to_type (struct field_info *fip, struct type *type,
				 struct dwarf2_cu *cu)
{
  struct fnfieldlist *flp;
  int i;

  if (cu->language == language_ada)
    error (_("unexpected member functions in Ada type"));

  ALLOCATE_CPLUS_STRUCT_TYPE (type);
  TYPE_FN_FIELDLISTS (type) = (struct fn_fieldlist *)
    TYPE_ALLOC (type, sizeof (struct fn_fieldlist) * fip->nfnfields);

  for (i = 0, flp = fip->fnfieldlists; i < fip->nfnfields; i++, flp++)
    {
      struct nextfnfield *nfp = flp->head;
      struct fn_fieldlist *fn_flp = &TYPE_FN_FIELDLIST (type, i);
      int k;

      TYPE_FN_FIELDLIST_NAME (type, i) = flp->name;
      TYPE_FN_FIELDLIST_LENGTH (type, i) = flp->length;
      fn_flp->fn_fields = (struct fn_field *)
	TYPE_ALLOC (type, sizeof (struct fn_field) * flp->length);
      for (k = flp->length; (k--, nfp); nfp = nfp->next)
	fn_flp->fn_fields[k] = nfp->fnfield;
    }

  TYPE_NFN_FIELDS (type) = fip->nfnfields;
}

/* Returns non-zero if NAME is the name of a vtable member in CU's
   language, zero otherwise.  */
static int
is_vtable_name (const char *name, struct dwarf2_cu *cu)
{
  static const char vptr[] = "_vptr";
  static const char vtable[] = "vtable";

  /* Look for the C++ and Java forms of the vtable.  */
  if ((cu->language == language_java
       && strncmp (name, vtable, sizeof (vtable) - 1) == 0)
       || (strncmp (name, vptr, sizeof (vptr) - 1) == 0
       && is_cplus_marker (name[sizeof (vptr) - 1])))
    return 1;

  return 0;
}

/* GCC outputs unnamed structures that are really pointers to member
   functions, with the ABI-specified layout.  If TYPE describes
   such a structure, smash it into a member function type.

   GCC shouldn't do this; it should just output pointer to member DIEs.
   This is GCC PR debug/28767.  */

static void
quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)
{
  struct type *pfn_type, *domain_type, *new_type;

  /* Check for a structure with no name and two children.  */
  if (TYPE_CODE (type) != TYPE_CODE_STRUCT || TYPE_NFIELDS (type) != 2)
    return;

  /* Check for __pfn and __delta members.  */
  if (TYPE_FIELD_NAME (type, 0) == NULL
      || strcmp (TYPE_FIELD_NAME (type, 0), "__pfn") != 0
      || TYPE_FIELD_NAME (type, 1) == NULL
      || strcmp (TYPE_FIELD_NAME (type, 1), "__delta") != 0)
    return;

  /* Find the type of the method.  */
  pfn_type = TYPE_FIELD_TYPE (type, 0);
  if (pfn_type == NULL
      || TYPE_CODE (pfn_type) != TYPE_CODE_PTR
      || TYPE_CODE (TYPE_TARGET_TYPE (pfn_type)) != TYPE_CODE_FUNC)
    return;

  /* Look for the "this" argument.  */
  pfn_type = TYPE_TARGET_TYPE (pfn_type);
  if (TYPE_NFIELDS (pfn_type) == 0
      /* || TYPE_FIELD_TYPE (pfn_type, 0) == NULL */
      || TYPE_CODE (TYPE_FIELD_TYPE (pfn_type, 0)) != TYPE_CODE_PTR)
    return;

  domain_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (pfn_type, 0));
  new_type = alloc_type (objfile);
  smash_to_method_type (new_type, domain_type, TYPE_TARGET_TYPE (pfn_type),
			TYPE_FIELDS (pfn_type), TYPE_NFIELDS (pfn_type),
			TYPE_VARARGS (pfn_type));
  smash_to_methodptr_type (type, new_type);
}

/* Return non-zero if the CU's PRODUCER string matches the Intel C/C++ compiler
   (icc).  */

static int
producer_is_icc (struct dwarf2_cu *cu)
{
  if (!cu->checked_producer)
    check_producer (cu);

  return cu->producer_is_icc;
}

/* Called when we find the DIE that starts a structure or union scope
   (definition) to create a type for the structure or union.  Fill in
   the type's name and general properties; the members will not be
   processed until process_structure_scope.

   NOTE: we need to call these functions regardless of whether or not the
   DIE has a DW_AT_name attribute, since it might be an anonymous
   structure or union.  This gets the type entered into our set of
   user defined types.

   However, if the structure is incomplete (an opaque struct/union)
   then suppress creating a symbol table entry for it since gdb only
   wants to find the one with the complete definition.  Note that if
   it is complete, we just call new_symbol, which does it's own
   checking about whether the struct/union is anonymous or not (and
   suppresses creating a symbol table entry itself).  */

static struct type *
read_structure_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct type *type;
  struct attribute *attr;
  const char *name;

  /* If the definition of this type lives in .debug_types, read that type.
     Don't follow DW_AT_specification though, that will take us back up
     the chain and we want to go down.  */
  attr = dwarf2_attr_no_follow (die, DW_AT_signature);
  if (attr)
    {
      type = get_DW_AT_signature_type (die, attr, cu);

      /* The type's CU may not be the same as CU.
	 Ensure TYPE is recorded with CU in die_type_hash.  */
      return set_die_type (die, type, cu);
    }

  type = alloc_type (objfile);
  INIT_CPLUS_SPECIFIC (type);

  name = dwarf2_name (die, cu);
  if (name != NULL)
    {
      if (cu->language == language_cplus
	  || cu->language == language_java)
	{
	  const char *full_name = dwarf2_full_name (name, die, cu);

	  /* dwarf2_full_name might have already finished building the DIE's
	     type.  If so, there is no need to continue.  */
	  if (get_die_type (die, cu) != NULL)
	    return get_die_type (die, cu);

	  TYPE_TAG_NAME (type) = full_name;
	  if (die->tag == DW_TAG_structure_type
	      || die->tag == DW_TAG_class_type)
	    TYPE_NAME (type) = TYPE_TAG_NAME (type);
	}
      else
	{
	  /* The name is already allocated along with this objfile, so
	     we don't need to duplicate it for the type.  */
	  TYPE_TAG_NAME (type) = name;
	  if (die->tag == DW_TAG_class_type)
	    TYPE_NAME (type) = TYPE_TAG_NAME (type);
	}
    }

  if (die->tag == DW_TAG_structure_type)
    {
      TYPE_CODE (type) = TYPE_CODE_STRUCT;
    }
  else if (die->tag == DW_TAG_union_type)
    {
      TYPE_CODE (type) = TYPE_CODE_UNION;
    }
  else
    {
      TYPE_CODE (type) = TYPE_CODE_CLASS;
    }

  if (cu->language == language_cplus && die->tag == DW_TAG_class_type)
    TYPE_DECLARED_CLASS (type) = 1;

  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    {
      TYPE_LENGTH (type) = DW_UNSND (attr);
    }
  else
    {
      TYPE_LENGTH (type) = 0;
    }

  if (producer_is_icc (cu))
    {
      /* ICC does not output the required DW_AT_declaration
	 on incomplete types, but gives them a size of zero.  */
    }
  else
    TYPE_STUB_SUPPORTED (type) = 1;

  if (die_is_declaration (die, cu))
    TYPE_STUB (type) = 1;
  else if (attr == NULL && die->child == NULL
	   && producer_is_realview (cu->producer))
    /* RealView does not output the required DW_AT_declaration
       on incomplete types.  */
    TYPE_STUB (type) = 1;

  /* We need to add the type field to the die immediately so we don't
     infinitely recurse when dealing with pointers to the structure
     type within the structure itself.  */
  set_die_type (die, type, cu);

  /* set_die_type should be already done.  */
  set_descriptive_type (type, die, cu);

  return type;
}

/* Finish creating a structure or union type, including filling in
   its members and creating a symbol for it.  */

static void
process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct die_info *child_die = die->child;
  struct type *type;

  type = get_die_type (die, cu);
  if (type == NULL)
    type = read_structure_type (die, cu);

  if (die->child != NULL && ! die_is_declaration (die, cu))
    {
      struct field_info fi;
      struct die_info *child_die;
      VEC (symbolp) *template_args = NULL;
      struct cleanup *back_to = make_cleanup (null_cleanup, 0);

      memset (&fi, 0, sizeof (struct field_info));

      child_die = die->child;

      while (child_die && child_die->tag)
	{
	  if (child_die->tag == DW_TAG_member
	      || child_die->tag == DW_TAG_variable)
	    {
	      /* NOTE: carlton/2002-11-05: A C++ static data member
		 should be a DW_TAG_member that is a declaration, but
		 all versions of G++ as of this writing (so through at
		 least 3.2.1) incorrectly generate DW_TAG_variable
		 tags for them instead.  */
	      dwarf2_add_field (&fi, child_die, cu);
	    }
	  else if (child_die->tag == DW_TAG_subprogram)
	    {
	      /* C++ member function.  */
	      dwarf2_add_member_fn (&fi, child_die, type, cu);
	    }
	  else if (child_die->tag == DW_TAG_inheritance)
	    {
	      /* C++ base class field.  */
	      dwarf2_add_field (&fi, child_die, cu);
	    }
	  else if (child_die->tag == DW_TAG_typedef)
	    dwarf2_add_typedef (&fi, child_die, cu);
	  else if (child_die->tag == DW_TAG_template_type_param
		   || child_die->tag == DW_TAG_template_value_param)
	    {
	      struct symbol *arg = new_symbol (child_die, NULL, cu);

	      if (arg != NULL)
		VEC_safe_push (symbolp, template_args, arg);
	    }

	  child_die = sibling_die (child_die);
	}

      /* Attach template arguments to type.  */
      if (! VEC_empty (symbolp, template_args))
	{
	  ALLOCATE_CPLUS_STRUCT_TYPE (type);
	  TYPE_N_TEMPLATE_ARGUMENTS (type)
	    = VEC_length (symbolp, template_args);
	  TYPE_TEMPLATE_ARGUMENTS (type)
	    = obstack_alloc (&objfile->objfile_obstack,
			     (TYPE_N_TEMPLATE_ARGUMENTS (type)
			      * sizeof (struct symbol *)));
	  memcpy (TYPE_TEMPLATE_ARGUMENTS (type),
		  VEC_address (symbolp, template_args),
		  (TYPE_N_TEMPLATE_ARGUMENTS (type)
		   * sizeof (struct symbol *)));
	  VEC_free (symbolp, template_args);
	}

      /* Attach fields and member functions to the type.  */
      if (fi.nfields)
	dwarf2_attach_fields_to_type (&fi, type, cu);
      if (fi.nfnfields)
	{
	  dwarf2_attach_fn_fields_to_type (&fi, type, cu);

	  /* Get the type which refers to the base class (possibly this
	     class itself) which contains the vtable pointer for the current
	     class from the DW_AT_containing_type attribute.  This use of
	     DW_AT_containing_type is a GNU extension.  */

	  if (dwarf2_attr (die, DW_AT_containing_type, cu) != NULL)
	    {
	      struct type *t = die_containing_type (die, cu);

	      TYPE_VPTR_BASETYPE (type) = t;
	      if (type == t)
		{
		  int i;

		  /* Our own class provides vtbl ptr.  */
		  for (i = TYPE_NFIELDS (t) - 1;
		       i >= TYPE_N_BASECLASSES (t);
		       --i)
		    {
		      const char *fieldname = TYPE_FIELD_NAME (t, i);

                      if (is_vtable_name (fieldname, cu))
			{
			  TYPE_VPTR_FIELDNO (type) = i;
			  break;
			}
		    }

		  /* Complain if virtual function table field not found.  */
		  if (i < TYPE_N_BASECLASSES (t))
		    complaint (&symfile_complaints,
			       _("virtual function table pointer "
				 "not found when defining class '%s'"),
			       TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) :
			       "");
		}
	      else
		{
		  TYPE_VPTR_FIELDNO (type) = TYPE_VPTR_FIELDNO (t);
		}
	    }
	  else if (cu->producer
		   && strncmp (cu->producer,
			       "IBM(R) XL C/C++ Advanced Edition", 32) == 0)
	    {
	      /* The IBM XLC compiler does not provide direct indication
	         of the containing type, but the vtable pointer is
	         always named __vfp.  */

	      int i;

	      for (i = TYPE_NFIELDS (type) - 1;
		   i >= TYPE_N_BASECLASSES (type);
		   --i)
		{
		  if (strcmp (TYPE_FIELD_NAME (type, i), "__vfp") == 0)
		    {
		      TYPE_VPTR_FIELDNO (type) = i;
		      TYPE_VPTR_BASETYPE (type) = type;
		      break;
		    }
		}
	    }
	}

      /* Copy fi.typedef_field_list linked list elements content into the
	 allocated array TYPE_TYPEDEF_FIELD_ARRAY (type).  */
      if (fi.typedef_field_list)
	{
	  int i = fi.typedef_field_list_count;

	  ALLOCATE_CPLUS_STRUCT_TYPE (type);
	  TYPE_TYPEDEF_FIELD_ARRAY (type)
	    = TYPE_ALLOC (type, sizeof (TYPE_TYPEDEF_FIELD (type, 0)) * i);
	  TYPE_TYPEDEF_FIELD_COUNT (type) = i;

	  /* Reverse the list order to keep the debug info elements order.  */
	  while (--i >= 0)
	    {
	      struct typedef_field *dest, *src;

	      dest = &TYPE_TYPEDEF_FIELD (type, i);
	      src = &fi.typedef_field_list->field;
	      fi.typedef_field_list = fi.typedef_field_list->next;
	      *dest = *src;
	    }
	}

      do_cleanups (back_to);

      if (HAVE_CPLUS_STRUCT (type))
	TYPE_CPLUS_REALLY_JAVA (type) = cu->language == language_java;
    }

  quirk_gcc_member_function_pointer (type, objfile);

  /* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its
     snapshots) has been known to create a die giving a declaration
     for a class that has, as a child, a die giving a definition for a
     nested class.  So we have to process our children even if the
     current die is a declaration.  Normally, of course, a declaration
     won't have any children at all.  */

  while (child_die != NULL && child_die->tag)
    {
      if (child_die->tag == DW_TAG_member
	  || child_die->tag == DW_TAG_variable
	  || child_die->tag == DW_TAG_inheritance
	  || child_die->tag == DW_TAG_template_value_param
	  || child_die->tag == DW_TAG_template_type_param)
	{
	  /* Do nothing.  */
	}
      else
	process_die (child_die, cu);

      child_die = sibling_die (child_die);
    }

  /* Do not consider external references.  According to the DWARF standard,
     these DIEs are identified by the fact that they have no byte_size
     attribute, and a declaration attribute.  */
  if (dwarf2_attr (die, DW_AT_byte_size, cu) != NULL
      || !die_is_declaration (die, cu))
    new_symbol (die, type, cu);
}

/* Given a DW_AT_enumeration_type die, set its type.  We do not
   complete the type's fields yet, or create any symbols.  */

static struct type *
read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct type *type;
  struct attribute *attr;
  const char *name;

  /* If the definition of this type lives in .debug_types, read that type.
     Don't follow DW_AT_specification though, that will take us back up
     the chain and we want to go down.  */
  attr = dwarf2_attr_no_follow (die, DW_AT_signature);
  if (attr)
    {
      type = get_DW_AT_signature_type (die, attr, cu);

      /* The type's CU may not be the same as CU.
	 Ensure TYPE is recorded with CU in die_type_hash.  */
      return set_die_type (die, type, cu);
    }

  type = alloc_type (objfile);

  TYPE_CODE (type) = TYPE_CODE_ENUM;
  name = dwarf2_full_name (NULL, die, cu);
  if (name != NULL)
    TYPE_TAG_NAME (type) = name;

  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    {
      TYPE_LENGTH (type) = DW_UNSND (attr);
    }
  else
    {
      TYPE_LENGTH (type) = 0;
    }

  /* The enumeration DIE can be incomplete.  In Ada, any type can be
     declared as private in the package spec, and then defined only
     inside the package body.  Such types are known as Taft Amendment
     Types.  When another package uses such a type, an incomplete DIE
     may be generated by the compiler.  */
  if (die_is_declaration (die, cu))
    TYPE_STUB (type) = 1;

  return set_die_type (die, type, cu);
}

/* Given a pointer to a die which begins an enumeration, process all
   the dies that define the members of the enumeration, and create the
   symbol for the enumeration type.

   NOTE: We reverse the order of the element list.  */

static void
process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *this_type;

  this_type = get_die_type (die, cu);
  if (this_type == NULL)
    this_type = read_enumeration_type (die, cu);

  if (die->child != NULL)
    {
      struct die_info *child_die;
      struct symbol *sym;
      struct field *fields = NULL;
      int num_fields = 0;
      int unsigned_enum = 1;
      const char *name;
      int flag_enum = 1;
      ULONGEST mask = 0;

      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  if (child_die->tag != DW_TAG_enumerator)
	    {
	      process_die (child_die, cu);
	    }
	  else
	    {
	      name = dwarf2_name (child_die, cu);
	      if (name)
		{
		  sym = new_symbol (child_die, this_type, cu);
		  if (SYMBOL_VALUE (sym) < 0)
		    {
		      unsigned_enum = 0;
		      flag_enum = 0;
		    }
		  else if ((mask & SYMBOL_VALUE (sym)) != 0)
		    flag_enum = 0;
		  else
		    mask |= SYMBOL_VALUE (sym);

		  if ((num_fields % DW_FIELD_ALLOC_CHUNK) == 0)
		    {
		      fields = (struct field *)
			xrealloc (fields,
				  (num_fields + DW_FIELD_ALLOC_CHUNK)
				  * sizeof (struct field));
		    }

		  FIELD_NAME (fields[num_fields]) = SYMBOL_LINKAGE_NAME (sym);
		  FIELD_TYPE (fields[num_fields]) = NULL;
		  SET_FIELD_ENUMVAL (fields[num_fields], SYMBOL_VALUE (sym));
		  FIELD_BITSIZE (fields[num_fields]) = 0;

		  num_fields++;
		}
	    }

	  child_die = sibling_die (child_die);
	}

      if (num_fields)
	{
	  TYPE_NFIELDS (this_type) = num_fields;
	  TYPE_FIELDS (this_type) = (struct field *)
	    TYPE_ALLOC (this_type, sizeof (struct field) * num_fields);
	  memcpy (TYPE_FIELDS (this_type), fields,
		  sizeof (struct field) * num_fields);
	  xfree (fields);
	}
      if (unsigned_enum)
	TYPE_UNSIGNED (this_type) = 1;
      if (flag_enum)
	TYPE_FLAG_ENUM (this_type) = 1;
    }

  /* If we are reading an enum from a .debug_types unit, and the enum
     is a declaration, and the enum is not the signatured type in the
     unit, then we do not want to add a symbol for it.  Adding a
     symbol would in some cases obscure the true definition of the
     enum, giving users an incomplete type when the definition is
     actually available.  Note that we do not want to do this for all
     enums which are just declarations, because C++0x allows forward
     enum declarations.  */
  if (cu->per_cu->is_debug_types
      && die_is_declaration (die, cu))
    {
      struct signatured_type *sig_type;

      sig_type = (struct signatured_type *) cu->per_cu;
      gdb_assert (sig_type->type_offset_in_section.sect_off != 0);
      if (sig_type->type_offset_in_section.sect_off != die->offset.sect_off)
	return;
    }

  new_symbol (die, this_type, cu);
}

/* Extract all information from a DW_TAG_array_type DIE and put it in
   the DIE's type field.  For now, this only handles one dimensional
   arrays.  */

static struct type *
read_array_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct die_info *child_die;
  struct type *type;
  struct type *element_type, *range_type, *index_type;
  struct type **range_types = NULL;
  struct attribute *attr;
  int ndim = 0;
  struct cleanup *back_to;
  const char *name;

  element_type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  type = get_die_type (die, cu);
  if (type)
    return type;

  /* Irix 6.2 native cc creates array types without children for
     arrays with unspecified length.  */
  if (die->child == NULL)
    {
      index_type = objfile_type (objfile)->builtin_int;
      range_type = create_range_type (NULL, index_type, 0, -1);
      type = create_array_type (NULL, element_type, range_type);
      return set_die_type (die, type, cu);
    }

  back_to = make_cleanup (null_cleanup, NULL);
  child_die = die->child;
  while (child_die && child_die->tag)
    {
      if (child_die->tag == DW_TAG_subrange_type)
	{
	  struct type *child_type = read_type_die (child_die, cu);

          if (child_type != NULL)
            {
	      /* The range type was succesfully read.  Save it for the
                 array type creation.  */
              if ((ndim % DW_FIELD_ALLOC_CHUNK) == 0)
                {
                  range_types = (struct type **)
                    xrealloc (range_types, (ndim + DW_FIELD_ALLOC_CHUNK)
                              * sizeof (struct type *));
                  if (ndim == 0)
                    make_cleanup (free_current_contents, &range_types);
	        }
	      range_types[ndim++] = child_type;
            }
	}
      child_die = sibling_die (child_die);
    }

  /* Dwarf2 dimensions are output from left to right, create the
     necessary array types in backwards order.  */

  type = element_type;

  if (read_array_order (die, cu) == DW_ORD_col_major)
    {
      int i = 0;

      while (i < ndim)
	type = create_array_type (NULL, type, range_types[i++]);
    }
  else
    {
      while (ndim-- > 0)
	type = create_array_type (NULL, type, range_types[ndim]);
    }

  /* Understand Dwarf2 support for vector types (like they occur on
     the PowerPC w/ AltiVec).  Gcc just adds another attribute to the
     array type.  This is not part of the Dwarf2/3 standard yet, but a
     custom vendor extension.  The main difference between a regular
     array and the vector variant is that vectors are passed by value
     to functions.  */
  attr = dwarf2_attr (die, DW_AT_GNU_vector, cu);
  if (attr)
    make_vector_type (type);

  /* The DIE may have DW_AT_byte_size set.  For example an OpenCL
     implementation may choose to implement triple vectors using this
     attribute.  */
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    {
      if (DW_UNSND (attr) >= TYPE_LENGTH (type))
	TYPE_LENGTH (type) = DW_UNSND (attr);
      else
	complaint (&symfile_complaints,
		   _("DW_AT_byte_size for array type smaller "
		     "than the total size of elements"));
    }

  name = dwarf2_name (die, cu);
  if (name)
    TYPE_NAME (type) = name;

  /* Install the type in the die.  */
  set_die_type (die, type, cu);

  /* set_die_type should be already done.  */
  set_descriptive_type (type, die, cu);

  do_cleanups (back_to);

  return type;
}

static enum dwarf_array_dim_ordering
read_array_order (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_ordering, cu);

  if (attr) return DW_SND (attr);

  /* GNU F77 is a special case, as at 08/2004 array type info is the
     opposite order to the dwarf2 specification, but data is still
     laid out as per normal fortran.

     FIXME: dsl/2004-8-20: If G77 is ever fixed, this will also need
     version checking.  */

  if (cu->language == language_fortran
      && cu->producer && strstr (cu->producer, "GNU F77"))
    {
      return DW_ORD_row_major;
    }

  switch (cu->language_defn->la_array_ordering)
    {
    case array_column_major:
      return DW_ORD_col_major;
    case array_row_major:
    default:
      return DW_ORD_row_major;
    };
}

/* Extract all information from a DW_TAG_set_type DIE and put it in
   the DIE's type field.  */

static struct type *
read_set_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *domain_type, *set_type;
  struct attribute *attr;

  domain_type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  set_type = get_die_type (die, cu);
  if (set_type)
    return set_type;

  set_type = create_set_type (NULL, domain_type);

  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    TYPE_LENGTH (set_type) = DW_UNSND (attr);

  return set_die_type (die, set_type, cu);
}

/* A helper for read_common_block that creates a locexpr baton.
   SYM is the symbol which we are marking as computed.
   COMMON_DIE is the DIE for the common block.
   COMMON_LOC is the location expression attribute for the common
   block itself.
   MEMBER_LOC is the location expression attribute for the particular
   member of the common block that we are processing.
   CU is the CU from which the above come.  */

static void
mark_common_block_symbol_computed (struct symbol *sym,
				   struct die_info *common_die,
				   struct attribute *common_loc,
				   struct attribute *member_loc,
				   struct dwarf2_cu *cu)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_locexpr_baton *baton;
  gdb_byte *ptr;
  unsigned int cu_off;
  enum bfd_endian byte_order = gdbarch_byte_order (get_objfile_arch (objfile));
  LONGEST offset = 0;

  gdb_assert (common_loc && member_loc);
  gdb_assert (attr_form_is_block (common_loc));
  gdb_assert (attr_form_is_block (member_loc)
	      || attr_form_is_constant (member_loc));

  baton = obstack_alloc (&objfile->objfile_obstack,
			 sizeof (struct dwarf2_locexpr_baton));
  baton->per_cu = cu->per_cu;
  gdb_assert (baton->per_cu);

  baton->size = 5 /* DW_OP_call4 */ + 1 /* DW_OP_plus */;

  if (attr_form_is_constant (member_loc))
    {
      offset = dwarf2_get_attr_constant_value (member_loc, 0);
      baton->size += 1 /* DW_OP_addr */ + cu->header.addr_size;
    }
  else
    baton->size += DW_BLOCK (member_loc)->size;

  ptr = obstack_alloc (&objfile->objfile_obstack, baton->size);
  baton->data = ptr;

  *ptr++ = DW_OP_call4;
  cu_off = common_die->offset.sect_off - cu->per_cu->offset.sect_off;
  store_unsigned_integer (ptr, 4, byte_order, cu_off);
  ptr += 4;

  if (attr_form_is_constant (member_loc))
    {
      *ptr++ = DW_OP_addr;
      store_unsigned_integer (ptr, cu->header.addr_size, byte_order, offset);
      ptr += cu->header.addr_size;
    }
  else
    {
      /* We have to copy the data here, because DW_OP_call4 will only
	 use a DW_AT_location attribute.  */
      memcpy (ptr, DW_BLOCK (member_loc)->data, DW_BLOCK (member_loc)->size);
      ptr += DW_BLOCK (member_loc)->size;
    }

  *ptr++ = DW_OP_plus;
  gdb_assert (ptr - baton->data == baton->size);

  SYMBOL_LOCATION_BATON (sym) = baton;
  SYMBOL_ACLASS_INDEX (sym) = dwarf2_locexpr_index;
}

/* Create appropriate locally-scoped variables for all the
   DW_TAG_common_block entries.  Also create a struct common_block
   listing all such variables for `info common'.  COMMON_BLOCK_DOMAIN
   is used to sepate the common blocks name namespace from regular
   variable names.  */

static void
read_common_block (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_location, cu);
  if (attr)
    {
      /* Support the .debug_loc offsets.  */
      if (attr_form_is_block (attr))
        {
	  /* Ok.  */
        }
      else if (attr_form_is_section_offset (attr))
        {
	  dwarf2_complex_location_expr_complaint ();
	  attr = NULL;
        }
      else
        {
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
						 "common block member");
	  attr = NULL;
        }
    }

  if (die->child != NULL)
    {
      struct objfile *objfile = cu->objfile;
      struct die_info *child_die;
      size_t n_entries = 0, size;
      struct common_block *common_block;
      struct symbol *sym;

      for (child_die = die->child;
	   child_die && child_die->tag;
	   child_die = sibling_die (child_die))
	++n_entries;

      size = (sizeof (struct common_block)
	      + (n_entries - 1) * sizeof (struct symbol *));
      common_block = obstack_alloc (&objfile->objfile_obstack, size);
      memset (common_block->contents, 0, n_entries * sizeof (struct symbol *));
      common_block->n_entries = 0;

      for (child_die = die->child;
	   child_die && child_die->tag;
	   child_die = sibling_die (child_die))
	{
	  /* Create the symbol in the DW_TAG_common_block block in the current
	     symbol scope.  */
	  sym = new_symbol (child_die, NULL, cu);
	  if (sym != NULL)
	    {
	      struct attribute *member_loc;

	      common_block->contents[common_block->n_entries++] = sym;

	      member_loc = dwarf2_attr (child_die, DW_AT_data_member_location,
					cu);
	      if (member_loc)
		{
		  /* GDB has handled this for a long time, but it is
		     not specified by DWARF.  It seems to have been
		     emitted by gfortran at least as recently as:
		     http://gcc.gnu.org/bugzilla/show_bug.cgi?id=23057.  */
		  complaint (&symfile_complaints,
			     _("Variable in common block has "
			       "DW_AT_data_member_location "
			       "- DIE at 0x%x [in module %s]"),
			     child_die->offset.sect_off,
			     objfile_name (cu->objfile));

		  if (attr_form_is_section_offset (member_loc))
		    dwarf2_complex_location_expr_complaint ();
		  else if (attr_form_is_constant (member_loc)
			   || attr_form_is_block (member_loc))
		    {
		      if (attr)
			mark_common_block_symbol_computed (sym, die, attr,
							   member_loc, cu);
		    }
		  else
		    dwarf2_complex_location_expr_complaint ();
		}
	    }
	}

      sym = new_symbol (die, objfile_type (objfile)->builtin_void, cu);
      SYMBOL_VALUE_COMMON_BLOCK (sym) = common_block;
    }
}

/* Create a type for a C++ namespace.  */

static struct type *
read_namespace_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  const char *previous_prefix, *name;
  int is_anonymous;
  struct type *type;

  /* For extensions, reuse the type of the original namespace.  */
  if (dwarf2_attr (die, DW_AT_extension, cu) != NULL)
    {
      struct die_info *ext_die;
      struct dwarf2_cu *ext_cu = cu;

      ext_die = dwarf2_extension (die, &ext_cu);
      type = read_type_die (ext_die, ext_cu);

      /* EXT_CU may not be the same as CU.
	 Ensure TYPE is recorded with CU in die_type_hash.  */
      return set_die_type (die, type, cu);
    }

  name = namespace_name (die, &is_anonymous, cu);

  /* Now build the name of the current namespace.  */

  previous_prefix = determine_prefix (die, cu);
  if (previous_prefix[0] != '\0')
    name = typename_concat (&objfile->objfile_obstack,
			    previous_prefix, name, 0, cu);

  /* Create the type.  */
  type = init_type (TYPE_CODE_NAMESPACE, 0, 0, NULL,
		    objfile);
  TYPE_NAME (type) = name;
  TYPE_TAG_NAME (type) = TYPE_NAME (type);

  return set_die_type (die, type, cu);
}

/* Read a C++ namespace.  */

static void
read_namespace (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  int is_anonymous;

  /* Add a symbol associated to this if we haven't seen the namespace
     before.  Also, add a using directive if it's an anonymous
     namespace.  */

  if (dwarf2_attr (die, DW_AT_extension, cu) == NULL)
    {
      struct type *type;

      type = read_type_die (die, cu);
      new_symbol (die, type, cu);

      namespace_name (die, &is_anonymous, cu);
      if (is_anonymous)
	{
	  const char *previous_prefix = determine_prefix (die, cu);

	  cp_add_using_directive (previous_prefix, TYPE_NAME (type), NULL,
				  NULL, NULL, 0, &objfile->objfile_obstack);
	}
    }

  if (die->child != NULL)
    {
      struct die_info *child_die = die->child;

      while (child_die && child_die->tag)
	{
	  process_die (child_die, cu);
	  child_die = sibling_die (child_die);
	}
    }
}

/* Read a Fortran module as type.  This DIE can be only a declaration used for
   imported module.  Still we need that type as local Fortran "use ... only"
   declaration imports depend on the created type in determine_prefix.  */

static struct type *
read_module_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  const char *module_name;
  struct type *type;

  module_name = dwarf2_name (die, cu);
  if (!module_name)
    complaint (&symfile_complaints,
	       _("DW_TAG_module has no name, offset 0x%x"),
               die->offset.sect_off);
  type = init_type (TYPE_CODE_MODULE, 0, 0, module_name, objfile);

  /* determine_prefix uses TYPE_TAG_NAME.  */
  TYPE_TAG_NAME (type) = TYPE_NAME (type);

  return set_die_type (die, type, cu);
}

/* Read a Fortran module.  */

static void
read_module (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *child_die = die->child;

  while (child_die && child_die->tag)
    {
      process_die (child_die, cu);
      child_die = sibling_die (child_die);
    }
}

/* Return the name of the namespace represented by DIE.  Set
   *IS_ANONYMOUS to tell whether or not the namespace is an anonymous
   namespace.  */

static const char *
namespace_name (struct die_info *die, int *is_anonymous, struct dwarf2_cu *cu)
{
  struct die_info *current_die;
  const char *name = NULL;

  /* Loop through the extensions until we find a name.  */

  for (current_die = die;
       current_die != NULL;
       current_die = dwarf2_extension (die, &cu))
    {
      name = dwarf2_name (current_die, cu);
      if (name != NULL)
	break;
    }

  /* Is it an anonymous namespace?  */

  *is_anonymous = (name == NULL);
  if (*is_anonymous)
    name = CP_ANONYMOUS_NAMESPACE_STR;

  return name;
}

/* Extract all information from a DW_TAG_pointer_type DIE and add to
   the user defined type vector.  */

static struct type *
read_tag_pointer_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct gdbarch *gdbarch = get_objfile_arch (cu->objfile);
  struct comp_unit_head *cu_header = &cu->header;
  struct type *type;
  struct attribute *attr_byte_size;
  struct attribute *attr_address_class;
  int byte_size, addr_class;
  struct type *target_type;

  target_type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  type = get_die_type (die, cu);
  if (type)
    return type;

  type = lookup_pointer_type (target_type);

  attr_byte_size = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr_byte_size)
    byte_size = DW_UNSND (attr_byte_size);
  else
    byte_size = cu_header->addr_size;

  attr_address_class = dwarf2_attr (die, DW_AT_address_class, cu);
  if (attr_address_class)
    addr_class = DW_UNSND (attr_address_class);
  else
    addr_class = DW_ADDR_none;

  /* If the pointer size or address class is different than the
     default, create a type variant marked as such and set the
     length accordingly.  */
  if (TYPE_LENGTH (type) != byte_size || addr_class != DW_ADDR_none)
    {
      if (gdbarch_address_class_type_flags_p (gdbarch))
	{
	  int type_flags;

	  type_flags = gdbarch_address_class_type_flags
			 (gdbarch, byte_size, addr_class);
	  gdb_assert ((type_flags & ~TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL)
		      == 0);
	  type = make_type_with_address_space (type, type_flags);
	}
      else if (TYPE_LENGTH (type) != byte_size)
	{
	  complaint (&symfile_complaints,
		     _("invalid pointer size %d"), byte_size);
	}
      else
	{
	  /* Should we also complain about unhandled address classes?  */
	}
    }

  TYPE_LENGTH (type) = byte_size;
  return set_die_type (die, type, cu);
}

/* Extract all information from a DW_TAG_ptr_to_member_type DIE and add to
   the user defined type vector.  */

static struct type *
read_tag_ptr_to_member_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *type;
  struct type *to_type;
  struct type *domain;

  to_type = die_type (die, cu);
  domain = die_containing_type (die, cu);

  /* The calls above may have already set the type for this DIE.  */
  type = get_die_type (die, cu);
  if (type)
    return type;

  if (TYPE_CODE (check_typedef (to_type)) == TYPE_CODE_METHOD)
    type = lookup_methodptr_type (to_type);
  else if (TYPE_CODE (check_typedef (to_type)) == TYPE_CODE_FUNC)
    {
      struct type *new_type = alloc_type (cu->objfile);

      smash_to_method_type (new_type, domain, TYPE_TARGET_TYPE (to_type),
			    TYPE_FIELDS (to_type), TYPE_NFIELDS (to_type),
			    TYPE_VARARGS (to_type));
      type = lookup_methodptr_type (new_type);
    }
  else
    type = lookup_memberptr_type (to_type, domain);

  return set_die_type (die, type, cu);
}

/* Extract all information from a DW_TAG_reference_type DIE and add to
   the user defined type vector.  */

static struct type *
read_tag_reference_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct comp_unit_head *cu_header = &cu->header;
  struct type *type, *target_type;
  struct attribute *attr;

  target_type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  type = get_die_type (die, cu);
  if (type)
    return type;

  type = lookup_reference_type (target_type);
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    {
      TYPE_LENGTH (type) = DW_UNSND (attr);
    }
  else
    {
      TYPE_LENGTH (type) = cu_header->addr_size;
    }
  return set_die_type (die, type, cu);
}

static struct type *
read_tag_const_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *base_type, *cv_type;

  base_type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  cv_type = get_die_type (die, cu);
  if (cv_type)
    return cv_type;

  /* In case the const qualifier is applied to an array type, the element type
     is so qualified, not the array type (section 6.7.3 of C99).  */
  if (TYPE_CODE (base_type) == TYPE_CODE_ARRAY)
    {
      struct type *el_type, *inner_array;

      base_type = copy_type (base_type);
      inner_array = base_type;

      while (TYPE_CODE (TYPE_TARGET_TYPE (inner_array)) == TYPE_CODE_ARRAY)
	{
	  TYPE_TARGET_TYPE (inner_array) =
	    copy_type (TYPE_TARGET_TYPE (inner_array));
	  inner_array = TYPE_TARGET_TYPE (inner_array);
	}

      el_type = TYPE_TARGET_TYPE (inner_array);
      TYPE_TARGET_TYPE (inner_array) =
	make_cv_type (1, TYPE_VOLATILE (el_type), el_type, NULL);

      return set_die_type (die, base_type, cu);
    }

  cv_type = make_cv_type (1, TYPE_VOLATILE (base_type), base_type, 0);
  return set_die_type (die, cv_type, cu);
}

static struct type *
read_tag_volatile_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *base_type, *cv_type;

  base_type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  cv_type = get_die_type (die, cu);
  if (cv_type)
    return cv_type;

  cv_type = make_cv_type (TYPE_CONST (base_type), 1, base_type, 0);
  return set_die_type (die, cv_type, cu);
}

/* Handle DW_TAG_restrict_type.  */

static struct type *
read_tag_restrict_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *base_type, *cv_type;

  base_type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  cv_type = get_die_type (die, cu);
  if (cv_type)
    return cv_type;

  cv_type = make_restrict_type (base_type);
  return set_die_type (die, cv_type, cu);
}

/* Extract all information from a DW_TAG_string_type DIE and add to
   the user defined type vector.  It isn't really a user defined type,
   but it behaves like one, with other DIE's using an AT_user_def_type
   attribute to reference it.  */

static struct type *
read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  struct type *type, *range_type, *index_type, *char_type;
  struct attribute *attr;
  unsigned int length;

  attr = dwarf2_attr (die, DW_AT_string_length, cu);
  if (attr)
    {
      length = DW_UNSND (attr);
    }
  else
    {
      /* Check for the DW_AT_byte_size attribute.  */
      attr = dwarf2_attr (die, DW_AT_byte_size, cu);
      if (attr)
        {
          length = DW_UNSND (attr);
        }
      else
        {
          length = 1;
        }
    }

  index_type = objfile_type (objfile)->builtin_int;
  range_type = create_range_type (NULL, index_type, 1, length);
  char_type = language_string_char_type (cu->language_defn, gdbarch);
  type = create_string_type (NULL, char_type, range_type);

  return set_die_type (die, type, cu);
}

/* Assuming that DIE corresponds to a function, returns nonzero
   if the function is prototyped.  */

static int
prototyped_function_p (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_prototyped, cu);
  if (attr && (DW_UNSND (attr) != 0))
    return 1;

  /* The DWARF standard implies that the DW_AT_prototyped attribute
     is only meaninful for C, but the concept also extends to other
     languages that allow unprototyped functions (Eg: Objective C).
     For all other languages, assume that functions are always
     prototyped.  */
  if (cu->language != language_c
      && cu->language != language_objc
      && cu->language != language_opencl)
    return 1;

  /* RealView does not emit DW_AT_prototyped.  We can not distinguish
     prototyped and unprototyped functions; default to prototyped,
     since that is more common in modern code (and RealView warns
     about unprototyped functions).  */
  if (producer_is_realview (cu->producer))
    return 1;

  return 0;
}

/* Handle DIES due to C code like:

   struct foo
   {
   int (*funcp)(int a, long l);
   int b;
   };

   ('funcp' generates a DW_TAG_subroutine_type DIE).  */

static struct type *
read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct type *type;		/* Type that this function returns.  */
  struct type *ftype;		/* Function that returns above type.  */
  struct attribute *attr;

  type = die_type (die, cu);

  /* The die_type call above may have already set the type for this DIE.  */
  ftype = get_die_type (die, cu);
  if (ftype)
    return ftype;

  ftype = lookup_function_type (type);

  if (prototyped_function_p (die, cu))
    TYPE_PROTOTYPED (ftype) = 1;

  /* Store the calling convention in the type if it's available in
     the subroutine die.  Otherwise set the calling convention to
     the default value DW_CC_normal.  */
  attr = dwarf2_attr (die, DW_AT_calling_convention, cu);
  if (attr)
    TYPE_CALLING_CONVENTION (ftype) = DW_UNSND (attr);
  else if (cu->producer && strstr (cu->producer, "IBM XL C for OpenCL"))
    TYPE_CALLING_CONVENTION (ftype) = DW_CC_GDB_IBM_OpenCL;
  else
    TYPE_CALLING_CONVENTION (ftype) = DW_CC_normal;

  /* We need to add the subroutine type to the die immediately so
     we don't infinitely recurse when dealing with parameters
     declared as the same subroutine type.  */
  set_die_type (die, ftype, cu);

  if (die->child != NULL)
    {
      struct type *void_type = objfile_type (objfile)->builtin_void;
      struct die_info *child_die;
      int nparams, iparams;

      /* Count the number of parameters.
         FIXME: GDB currently ignores vararg functions, but knows about
         vararg member functions.  */
      nparams = 0;
      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  if (child_die->tag == DW_TAG_formal_parameter)
	    nparams++;
	  else if (child_die->tag == DW_TAG_unspecified_parameters)
	    TYPE_VARARGS (ftype) = 1;
	  child_die = sibling_die (child_die);
	}

      /* Allocate storage for parameters and fill them in.  */
      TYPE_NFIELDS (ftype) = nparams;
      TYPE_FIELDS (ftype) = (struct field *)
	TYPE_ZALLOC (ftype, nparams * sizeof (struct field));

      /* TYPE_FIELD_TYPE must never be NULL.  Pre-fill the array to ensure it
	 even if we error out during the parameters reading below.  */
      for (iparams = 0; iparams < nparams; iparams++)
	TYPE_FIELD_TYPE (ftype, iparams) = void_type;

      iparams = 0;
      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  if (child_die->tag == DW_TAG_formal_parameter)
	    {
	      struct type *arg_type;

	      /* DWARF version 2 has no clean way to discern C++
		 static and non-static member functions.  G++ helps
		 GDB by marking the first parameter for non-static
		 member functions (which is the this pointer) as
		 artificial.  We pass this information to
		 dwarf2_add_member_fn via TYPE_FIELD_ARTIFICIAL.

		 DWARF version 3 added DW_AT_object_pointer, which GCC
		 4.5 does not yet generate.  */
	      attr = dwarf2_attr (child_die, DW_AT_artificial, cu);
	      if (attr)
		TYPE_FIELD_ARTIFICIAL (ftype, iparams) = DW_UNSND (attr);
	      else
		{
		  TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;

		  /* GCC/43521: In java, the formal parameter
		     "this" is sometimes not marked with DW_AT_artificial.  */
		  if (cu->language == language_java)
		    {
		      const char *name = dwarf2_name (child_die, cu);

		      if (name && !strcmp (name, "this"))
			TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 1;
		    }
		}
	      arg_type = die_type (child_die, cu);

	      /* RealView does not mark THIS as const, which the testsuite
		 expects.  GCC marks THIS as const in method definitions,
		 but not in the class specifications (GCC PR 43053).  */
	      if (cu->language == language_cplus && !TYPE_CONST (arg_type)
		  && TYPE_FIELD_ARTIFICIAL (ftype, iparams))
		{
		  int is_this = 0;
		  struct dwarf2_cu *arg_cu = cu;
		  const char *name = dwarf2_name (child_die, cu);

		  attr = dwarf2_attr (die, DW_AT_object_pointer, cu);
		  if (attr)
		    {
		      /* If the compiler emits this, use it.  */
		      if (follow_die_ref (die, attr, &arg_cu) == child_die)
			is_this = 1;
		    }
		  else if (name && strcmp (name, "this") == 0)
		    /* Function definitions will have the argument names.  */
		    is_this = 1;
		  else if (name == NULL && iparams == 0)
		    /* Declarations may not have the names, so like
		       elsewhere in GDB, assume an artificial first
		       argument is "this".  */
		    is_this = 1;

		  if (is_this)
		    arg_type = make_cv_type (1, TYPE_VOLATILE (arg_type),
					     arg_type, 0);
		}

	      TYPE_FIELD_TYPE (ftype, iparams) = arg_type;
	      iparams++;
	    }
	  child_die = sibling_die (child_die);
	}
    }

  return ftype;
}

static struct type *
read_typedef (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  const char *name = NULL;
  struct type *this_type, *target_type;

  name = dwarf2_full_name (NULL, die, cu);
  this_type = init_type (TYPE_CODE_TYPEDEF, 0,
			 TYPE_FLAG_TARGET_STUB, NULL, objfile);
  TYPE_NAME (this_type) = name;
  set_die_type (die, this_type, cu);
  target_type = die_type (die, cu);
  if (target_type != this_type)
    TYPE_TARGET_TYPE (this_type) = target_type;
  else
    {
      /* Self-referential typedefs are, it seems, not allowed by the DWARF
	 spec and cause infinite loops in GDB.  */
      complaint (&symfile_complaints,
		 _("Self-referential DW_TAG_typedef "
		   "- DIE at 0x%x [in module %s]"),
		 die->offset.sect_off, objfile_name (objfile));
      TYPE_TARGET_TYPE (this_type) = NULL;
    }
  return this_type;
}

/* Find a representation of a given base type and install
   it in the TYPE field of the die.  */

static struct type *
read_base_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct type *type;
  struct attribute *attr;
  int encoding = 0, size = 0;
  const char *name;
  enum type_code code = TYPE_CODE_INT;
  int type_flags = 0;
  struct type *target_type = NULL;

  attr = dwarf2_attr (die, DW_AT_encoding, cu);
  if (attr)
    {
      encoding = DW_UNSND (attr);
    }
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    {
      size = DW_UNSND (attr);
    }
  name = dwarf2_name (die, cu);
  if (!name)
    {
      complaint (&symfile_complaints,
		 _("DW_AT_name missing from DW_TAG_base_type"));
    }

  switch (encoding)
    {
      case DW_ATE_address:
	/* Turn DW_ATE_address into a void * pointer.  */
	code = TYPE_CODE_PTR;
	type_flags |= TYPE_FLAG_UNSIGNED;
	target_type = init_type (TYPE_CODE_VOID, 1, 0, NULL, objfile);
	break;
      case DW_ATE_boolean:
	code = TYPE_CODE_BOOL;
	type_flags |= TYPE_FLAG_UNSIGNED;
	break;
      case DW_ATE_complex_float:
	code = TYPE_CODE_COMPLEX;
	target_type = init_type (TYPE_CODE_FLT, size / 2, 0, NULL, objfile);
	break;
      case DW_ATE_decimal_float:
	code = TYPE_CODE_DECFLOAT;
	break;
      case DW_ATE_float:
	code = TYPE_CODE_FLT;
	break;
      case DW_ATE_signed:
	break;
      case DW_ATE_unsigned:
	type_flags |= TYPE_FLAG_UNSIGNED;
	if (cu->language == language_fortran
	    && name
	    && strncmp (name, "character(", sizeof ("character(") - 1) == 0)
	  code = TYPE_CODE_CHAR;
	break;
      case DW_ATE_signed_char:
	if (cu->language == language_ada || cu->language == language_m2
	    || cu->language == language_pascal
	    || cu->language == language_fortran)
	  code = TYPE_CODE_CHAR;
	break;
      case DW_ATE_unsigned_char:
	if (cu->language == language_ada || cu->language == language_m2
	    || cu->language == language_pascal
	    || cu->language == language_fortran)
	  code = TYPE_CODE_CHAR;
	type_flags |= TYPE_FLAG_UNSIGNED;
	break;
      case DW_ATE_UTF:
	/* We just treat this as an integer and then recognize the
	   type by name elsewhere.  */
	break;

      default:
	complaint (&symfile_complaints, _("unsupported DW_AT_encoding: '%s'"),
		   dwarf_type_encoding_name (encoding));
	break;
    }

  type = init_type (code, size, type_flags, NULL, objfile);
  TYPE_NAME (type) = name;
  TYPE_TARGET_TYPE (type) = target_type;

  if (name && strcmp (name, "char") == 0)
    TYPE_NOSIGN (type) = 1;

  return set_die_type (die, type, cu);
}

/* Read the given DW_AT_subrange DIE.  */

static struct type *
read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *base_type, *orig_base_type;
  struct type *range_type;
  struct attribute *attr;
  LONGEST low, high;
  int low_default_is_valid;
  const char *name;
  LONGEST negative_mask;

  orig_base_type = die_type (die, cu);
  /* If ORIG_BASE_TYPE is a typedef, it will not be TYPE_UNSIGNED,
     whereas the real type might be.  So, we use ORIG_BASE_TYPE when
     creating the range type, but we use the result of check_typedef
     when examining properties of the type.  */
  base_type = check_typedef (orig_base_type);

  /* The die_type call above may have already set the type for this DIE.  */
  range_type = get_die_type (die, cu);
  if (range_type)
    return range_type;

  /* Set LOW_DEFAULT_IS_VALID if current language and DWARF version allow
     omitting DW_AT_lower_bound.  */
  switch (cu->language)
    {
    case language_c:
    case language_cplus:
      low = 0;
      low_default_is_valid = 1;
      break;
    case language_fortran:
      low = 1;
      low_default_is_valid = 1;
      break;
    case language_d:
    case language_java:
    case language_objc:
      low = 0;
      low_default_is_valid = (cu->header.version >= 4);
      break;
    case language_ada:
    case language_m2:
    case language_pascal:
      low = 1;
      low_default_is_valid = (cu->header.version >= 4);
      break;
    default:
      low = 0;
      low_default_is_valid = 0;
      break;
    }

  /* FIXME: For variable sized arrays either of these could be
     a variable rather than a constant value.  We'll allow it,
     but we don't know how to handle it.  */
  attr = dwarf2_attr (die, DW_AT_lower_bound, cu);
  if (attr)
    low = dwarf2_get_attr_constant_value (attr, low);
  else if (!low_default_is_valid)
    complaint (&symfile_complaints, _("Missing DW_AT_lower_bound "
				      "- DIE at 0x%x [in module %s]"),
	       die->offset.sect_off, objfile_name (cu->objfile));

  attr = dwarf2_attr (die, DW_AT_upper_bound, cu);
  if (attr)
    {
      if (attr_form_is_block (attr) || attr_form_is_ref (attr))
        {
          /* GCC encodes arrays with unspecified or dynamic length
             with a DW_FORM_block1 attribute or a reference attribute.
             FIXME: GDB does not yet know how to handle dynamic
             arrays properly, treat them as arrays with unspecified
             length for now.

             FIXME: jimb/2003-09-22: GDB does not really know
             how to handle arrays of unspecified length
             either; we just represent them as zero-length
             arrays.  Choose an appropriate upper bound given
             the lower bound we've computed above.  */
          high = low - 1;
        }
      else
        high = dwarf2_get_attr_constant_value (attr, 1);
    }
  else
    {
      attr = dwarf2_attr (die, DW_AT_count, cu);
      if (attr)
	{
	  int count = dwarf2_get_attr_constant_value (attr, 1);
	  high = low + count - 1;
	}
      else
	{
	  /* Unspecified array length.  */
	  high = low - 1;
	}
    }

  /* Dwarf-2 specifications explicitly allows to create subrange types
     without specifying a base type.
     In that case, the base type must be set to the type of
     the lower bound, upper bound or count, in that order, if any of these
     three attributes references an object that has a type.
     If no base type is found, the Dwarf-2 specifications say that
     a signed integer type of size equal to the size of an address should
     be used.
     For the following C code: `extern char gdb_int [];'
     GCC produces an empty range DIE.
     FIXME: muller/2010-05-28: Possible references to object for low bound,
     high bound or count are not yet handled by this code.  */
  if (TYPE_CODE (base_type) == TYPE_CODE_VOID)
    {
      struct objfile *objfile = cu->objfile;
      struct gdbarch *gdbarch = get_objfile_arch (objfile);
      int addr_size = gdbarch_addr_bit (gdbarch) /8;
      struct type *int_type = objfile_type (objfile)->builtin_int;

      /* Test "int", "long int", and "long long int" objfile types,
	 and select the first one having a size above or equal to the
	 architecture address size.  */
      if (int_type && TYPE_LENGTH (int_type) >= addr_size)
	base_type = int_type;
      else
	{
	  int_type = objfile_type (objfile)->builtin_long;
	  if (int_type && TYPE_LENGTH (int_type) >= addr_size)
	    base_type = int_type;
	  else
	    {
	      int_type = objfile_type (objfile)->builtin_long_long;
	      if (int_type && TYPE_LENGTH (int_type) >= addr_size)
		base_type = int_type;
	    }
	}
    }

  negative_mask =
    (LONGEST) -1 << (TYPE_LENGTH (base_type) * TARGET_CHAR_BIT - 1);
  if (!TYPE_UNSIGNED (base_type) && (low & negative_mask))
    low |= negative_mask;
  if (!TYPE_UNSIGNED (base_type) && (high & negative_mask))
    high |= negative_mask;

  range_type = create_range_type (NULL, orig_base_type, low, high);

  /* Mark arrays with dynamic length at least as an array of unspecified
     length.  GDB could check the boundary but before it gets implemented at
     least allow accessing the array elements.  */
  if (attr && attr_form_is_block (attr))
    TYPE_HIGH_BOUND_UNDEFINED (range_type) = 1;

  /* Ada expects an empty array on no boundary attributes.  */
  if (attr == NULL && cu->language != language_ada)
    TYPE_HIGH_BOUND_UNDEFINED (range_type) = 1;

  name = dwarf2_name (die, cu);
  if (name)
    TYPE_NAME (range_type) = name;

  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    TYPE_LENGTH (range_type) = DW_UNSND (attr);

  set_die_type (die, range_type, cu);

  /* set_die_type should be already done.  */
  set_descriptive_type (range_type, die, cu);

  return range_type;
}

static struct type *
read_unspecified_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *type;

  /* For now, we only support the C meaning of an unspecified type: void.  */

  type = init_type (TYPE_CODE_VOID, 0, 0, NULL, cu->objfile);
  TYPE_NAME (type) = dwarf2_name (die, cu);

  return set_die_type (die, type, cu);
}

/* Read a single die and all its descendents.  Set the die's sibling
   field to NULL; set other fields in the die correctly, and set all
   of the descendents' fields correctly.  Set *NEW_INFO_PTR to the
   location of the info_ptr after reading all of those dies.  PARENT
   is the parent of the die in question.  */

static struct die_info *
read_die_and_children (const struct die_reader_specs *reader,
		       const gdb_byte *info_ptr,
		       const gdb_byte **new_info_ptr,
		       struct die_info *parent)
{
  struct die_info *die;
  const gdb_byte *cur_ptr;
  int has_children;

  cur_ptr = read_full_die_1 (reader, &die, info_ptr, &has_children, 0);
  if (die == NULL)
    {
      *new_info_ptr = cur_ptr;
      return NULL;
    }
  store_in_ref_table (die, reader->cu);

  if (has_children)
    die->child = read_die_and_siblings_1 (reader, cur_ptr, new_info_ptr, die);
  else
    {
      die->child = NULL;
      *new_info_ptr = cur_ptr;
    }

  die->sibling = NULL;
  die->parent = parent;
  return die;
}

/* Read a die, all of its descendents, and all of its siblings; set
   all of the fields of all of the dies correctly.  Arguments are as
   in read_die_and_children.  */

static struct die_info *
read_die_and_siblings_1 (const struct die_reader_specs *reader,
			 const gdb_byte *info_ptr,
			 const gdb_byte **new_info_ptr,
			 struct die_info *parent)
{
  struct die_info *first_die, *last_sibling;
  const gdb_byte *cur_ptr;

  cur_ptr = info_ptr;
  first_die = last_sibling = NULL;

  while (1)
    {
      struct die_info *die
	= read_die_and_children (reader, cur_ptr, &cur_ptr, parent);

      if (die == NULL)
	{
	  *new_info_ptr = cur_ptr;
	  return first_die;
	}

      if (!first_die)
	first_die = die;
      else
	last_sibling->sibling = die;

      last_sibling = die;
    }
}

/* Read a die, all of its descendents, and all of its siblings; set
   all of the fields of all of the dies correctly.  Arguments are as
   in read_die_and_children.
   This the main entry point for reading a DIE and all its children.  */

static struct die_info *
read_die_and_siblings (const struct die_reader_specs *reader,
		       const gdb_byte *info_ptr,
		       const gdb_byte **new_info_ptr,
		       struct die_info *parent)
{
  struct die_info *die = read_die_and_siblings_1 (reader, info_ptr,
						  new_info_ptr, parent);

  if (dwarf2_die_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Read die from %s@@0x%x of %s:\n",
			  get_section_name (reader->die_section),
			  (unsigned) (info_ptr - reader->die_section->buffer),
			  bfd_get_filename (reader->abfd));
      dump_die (die, dwarf2_die_debug);
    }

  return die;
}

/* Read a die and all its attributes, leave space for NUM_EXTRA_ATTRS
   attributes.
   The caller is responsible for filling in the extra attributes
   and updating (*DIEP)->num_attrs.
   Set DIEP to point to a newly allocated die with its information,
   except for its child, sibling, and parent fields.
   Set HAS_CHILDREN to tell whether the die has children or not.  */

static const gdb_byte *
read_full_die_1 (const struct die_reader_specs *reader,
		 struct die_info **diep, const gdb_byte *info_ptr,
		 int *has_children, int num_extra_attrs)
{
  unsigned int abbrev_number, bytes_read, i;
  sect_offset offset;
  struct abbrev_info *abbrev;
  struct die_info *die;
  struct dwarf2_cu *cu = reader->cu;
  bfd *abfd = reader->abfd;

  offset.sect_off = info_ptr - reader->buffer;
  abbrev_number = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
  info_ptr += bytes_read;
  if (!abbrev_number)
    {
      *diep = NULL;
      *has_children = 0;
      return info_ptr;
    }

  abbrev = abbrev_table_lookup_abbrev (cu->abbrev_table, abbrev_number);
  if (!abbrev)
    error (_("Dwarf Error: could not find abbrev number %d [in module %s]"),
	   abbrev_number,
	   bfd_get_filename (abfd));

  die = dwarf_alloc_die (cu, abbrev->num_attrs + num_extra_attrs);
  die->offset = offset;
  die->tag = abbrev->tag;
  die->abbrev = abbrev_number;

  /* Make the result usable.
     The caller needs to update num_attrs after adding the extra
     attributes.  */
  die->num_attrs = abbrev->num_attrs;

  for (i = 0; i < abbrev->num_attrs; ++i)
    info_ptr = read_attribute (reader, &die->attrs[i], &abbrev->attrs[i],
			       info_ptr);

  *diep = die;
  *has_children = abbrev->has_children;
  return info_ptr;
}

/* Read a die and all its attributes.
   Set DIEP to point to a newly allocated die with its information,
   except for its child, sibling, and parent fields.
   Set HAS_CHILDREN to tell whether the die has children or not.  */

static const gdb_byte *
read_full_die (const struct die_reader_specs *reader,
	       struct die_info **diep, const gdb_byte *info_ptr,
	       int *has_children)
{
  const gdb_byte *result;

  result = read_full_die_1 (reader, diep, info_ptr, has_children, 0);

  if (dwarf2_die_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Read die from %s@@0x%x of %s:\n",
			  get_section_name (reader->die_section),
			  (unsigned) (info_ptr - reader->die_section->buffer),
			  bfd_get_filename (reader->abfd));
      dump_die (*diep, dwarf2_die_debug);
    }

  return result;
}

/* Abbreviation tables.

   In DWARF version 2, the description of the debugging information is
   stored in a separate .debug_abbrev section.  Before we read any
   dies from a section we read in all abbreviations and install them
   in a hash table.  */

/* Allocate space for a struct abbrev_info object in ABBREV_TABLE.  */

static struct abbrev_info *
abbrev_table_alloc_abbrev (struct abbrev_table *abbrev_table)
{
  struct abbrev_info *abbrev;

  abbrev = (struct abbrev_info *)
    obstack_alloc (&abbrev_table->abbrev_obstack, sizeof (struct abbrev_info));
  memset (abbrev, 0, sizeof (struct abbrev_info));
  return abbrev;
}

/* Add an abbreviation to the table.  */

static void
abbrev_table_add_abbrev (struct abbrev_table *abbrev_table,
			 unsigned int abbrev_number,
			 struct abbrev_info *abbrev)
{
  unsigned int hash_number;

  hash_number = abbrev_number % ABBREV_HASH_SIZE;
  abbrev->next = abbrev_table->abbrevs[hash_number];
  abbrev_table->abbrevs[hash_number] = abbrev;
}

/* Look up an abbrev in the table.
   Returns NULL if the abbrev is not found.  */

static struct abbrev_info *
abbrev_table_lookup_abbrev (const struct abbrev_table *abbrev_table,
			    unsigned int abbrev_number)
{
  unsigned int hash_number;
  struct abbrev_info *abbrev;

  hash_number = abbrev_number % ABBREV_HASH_SIZE;
  abbrev = abbrev_table->abbrevs[hash_number];

  while (abbrev)
    {
      if (abbrev->number == abbrev_number)
	return abbrev;
      abbrev = abbrev->next;
    }
  return NULL;
}

/* Read in an abbrev table.  */

static struct abbrev_table *
abbrev_table_read_table (struct dwarf2_section_info *section,
			 sect_offset offset)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  bfd *abfd = get_section_bfd_owner (section);
  struct abbrev_table *abbrev_table;
  const gdb_byte *abbrev_ptr;
  struct abbrev_info *cur_abbrev;
  unsigned int abbrev_number, bytes_read, abbrev_name;
  unsigned int abbrev_form;
  struct attr_abbrev *cur_attrs;
  unsigned int allocated_attrs;

  abbrev_table = XMALLOC (struct abbrev_table);
  abbrev_table->offset = offset;
  obstack_init (&abbrev_table->abbrev_obstack);
  abbrev_table->abbrevs = obstack_alloc (&abbrev_table->abbrev_obstack,
					 (ABBREV_HASH_SIZE
					  * sizeof (struct abbrev_info *)));
  memset (abbrev_table->abbrevs, 0,
	  ABBREV_HASH_SIZE * sizeof (struct abbrev_info *));

  dwarf2_read_section (objfile, section);
  abbrev_ptr = section->buffer + offset.sect_off;
  abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
  abbrev_ptr += bytes_read;

  allocated_attrs = ATTR_ALLOC_CHUNK;
  cur_attrs = xmalloc (allocated_attrs * sizeof (struct attr_abbrev));

  /* Loop until we reach an abbrev number of 0.  */
  while (abbrev_number)
    {
      cur_abbrev = abbrev_table_alloc_abbrev (abbrev_table);

      /* read in abbrev header */
      cur_abbrev->number = abbrev_number;
      cur_abbrev->tag = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
      cur_abbrev->has_children = read_1_byte (abfd, abbrev_ptr);
      abbrev_ptr += 1;

      /* now read in declarations */
      abbrev_name = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
      abbrev_form = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
      while (abbrev_name)
	{
	  if (cur_abbrev->num_attrs == allocated_attrs)
	    {
	      allocated_attrs += ATTR_ALLOC_CHUNK;
	      cur_attrs
		= xrealloc (cur_attrs, (allocated_attrs
					* sizeof (struct attr_abbrev)));
	    }

	  cur_attrs[cur_abbrev->num_attrs].name = abbrev_name;
	  cur_attrs[cur_abbrev->num_attrs++].form = abbrev_form;
	  abbrev_name = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
	  abbrev_ptr += bytes_read;
	  abbrev_form = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
	  abbrev_ptr += bytes_read;
	}

      cur_abbrev->attrs = obstack_alloc (&abbrev_table->abbrev_obstack,
					 (cur_abbrev->num_attrs
					  * sizeof (struct attr_abbrev)));
      memcpy (cur_abbrev->attrs, cur_attrs,
	      cur_abbrev->num_attrs * sizeof (struct attr_abbrev));

      abbrev_table_add_abbrev (abbrev_table, abbrev_number, cur_abbrev);

      /* Get next abbreviation.
         Under Irix6 the abbreviations for a compilation unit are not
         always properly terminated with an abbrev number of 0.
         Exit loop if we encounter an abbreviation which we have
         already read (which means we are about to read the abbreviations
         for the next compile unit) or if the end of the abbreviation
         table is reached.  */
      if ((unsigned int) (abbrev_ptr - section->buffer) >= section->size)
	break;
      abbrev_number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
      if (abbrev_table_lookup_abbrev (abbrev_table, abbrev_number) != NULL)
	break;
    }

  xfree (cur_attrs);
  return abbrev_table;
}

/* Free the resources held by ABBREV_TABLE.  */

static void
abbrev_table_free (struct abbrev_table *abbrev_table)
{
  obstack_free (&abbrev_table->abbrev_obstack, NULL);
  xfree (abbrev_table);
}

/* Same as abbrev_table_free but as a cleanup.
   We pass in a pointer to the pointer to the table so that we can
   set the pointer to NULL when we're done.  It also simplifies
   build_type_unit_groups.  */

static void
abbrev_table_free_cleanup (void *table_ptr)
{
  struct abbrev_table **abbrev_table_ptr = table_ptr;

  if (*abbrev_table_ptr != NULL)
    abbrev_table_free (*abbrev_table_ptr);
  *abbrev_table_ptr = NULL;
}

/* Read the abbrev table for CU from ABBREV_SECTION.  */

static void
dwarf2_read_abbrevs (struct dwarf2_cu *cu,
		     struct dwarf2_section_info *abbrev_section)
{
  cu->abbrev_table =
    abbrev_table_read_table (abbrev_section, cu->header.abbrev_offset);
}

/* Release the memory used by the abbrev table for a compilation unit.  */

static void
dwarf2_free_abbrev_table (void *ptr_to_cu)
{
  struct dwarf2_cu *cu = ptr_to_cu;

  if (cu->abbrev_table != NULL)
    abbrev_table_free (cu->abbrev_table);
  /* Set this to NULL so that we SEGV if we try to read it later,
     and also because free_comp_unit verifies this is NULL.  */
  cu->abbrev_table = NULL;
}

/* Returns nonzero if TAG represents a type that we might generate a partial
   symbol for.  */

static int
is_type_tag_for_partial (int tag)
{
  switch (tag)
    {
#if 0
    /* Some types that would be reasonable to generate partial symbols for,
       that we don't at present.  */
    case DW_TAG_array_type:
    case DW_TAG_file_type:
    case DW_TAG_ptr_to_member_type:
    case DW_TAG_set_type:
    case DW_TAG_string_type:
    case DW_TAG_subroutine_type:
#endif
    case DW_TAG_base_type:
    case DW_TAG_class_type:
    case DW_TAG_interface_type:
    case DW_TAG_enumeration_type:
    case DW_TAG_structure_type:
    case DW_TAG_subrange_type:
    case DW_TAG_typedef:
    case DW_TAG_union_type:
      return 1;
    default:
      return 0;
    }
}

/* Load all DIEs that are interesting for partial symbols into memory.  */

static struct partial_die_info *
load_partial_dies (const struct die_reader_specs *reader,
		   const gdb_byte *info_ptr, int building_psymtab)
{
  struct dwarf2_cu *cu = reader->cu;
  struct objfile *objfile = cu->objfile;
  struct partial_die_info *part_die;
  struct partial_die_info *parent_die, *last_die, *first_die = NULL;
  struct abbrev_info *abbrev;
  unsigned int bytes_read;
  unsigned int load_all = 0;
  int nesting_level = 1;

  parent_die = NULL;
  last_die = NULL;

  gdb_assert (cu->per_cu != NULL);
  if (cu->per_cu->load_all_dies)
    load_all = 1;

  cu->partial_dies
    = htab_create_alloc_ex (cu->header.length / 12,
			    partial_die_hash,
			    partial_die_eq,
			    NULL,
			    &cu->comp_unit_obstack,
			    hashtab_obstack_allocate,
			    dummy_obstack_deallocate);

  part_die = obstack_alloc (&cu->comp_unit_obstack,
			    sizeof (struct partial_die_info));

  while (1)
    {
      abbrev = peek_die_abbrev (info_ptr, &bytes_read, cu);

      /* A NULL abbrev means the end of a series of children.  */
      if (abbrev == NULL)
	{
	  if (--nesting_level == 0)
	    {
	      /* PART_DIE was probably the last thing allocated on the
		 comp_unit_obstack, so we could call obstack_free
		 here.  We don't do that because the waste is small,
		 and will be cleaned up when we're done with this
		 compilation unit.  This way, we're also more robust
		 against other users of the comp_unit_obstack.  */
	      return first_die;
	    }
	  info_ptr += bytes_read;
	  last_die = parent_die;
	  parent_die = parent_die->die_parent;
	  continue;
	}

      /* Check for template arguments.  We never save these; if
	 they're seen, we just mark the parent, and go on our way.  */
      if (parent_die != NULL
	  && cu->language == language_cplus
	  && (abbrev->tag == DW_TAG_template_type_param
	      || abbrev->tag == DW_TAG_template_value_param))
	{
	  parent_die->has_template_arguments = 1;

	  if (!load_all)
	    {
	      /* We don't need a partial DIE for the template argument.  */
	      info_ptr = skip_one_die (reader, info_ptr + bytes_read, abbrev);
	      continue;
	    }
	}

      /* We only recurse into c++ subprograms looking for template arguments.
	 Skip their other children.  */
      if (!load_all
	  && cu->language == language_cplus
	  && parent_die != NULL
	  && parent_die->tag == DW_TAG_subprogram)
	{
	  info_ptr = skip_one_die (reader, info_ptr + bytes_read, abbrev);
	  continue;
	}

      /* Check whether this DIE is interesting enough to save.  Normally
	 we would not be interested in members here, but there may be
	 later variables referencing them via DW_AT_specification (for
	 static members).  */
      if (!load_all
	  && !is_type_tag_for_partial (abbrev->tag)
	  && abbrev->tag != DW_TAG_constant
	  && abbrev->tag != DW_TAG_enumerator
	  && abbrev->tag != DW_TAG_subprogram
	  && abbrev->tag != DW_TAG_lexical_block
	  && abbrev->tag != DW_TAG_variable
	  && abbrev->tag != DW_TAG_namespace
	  && abbrev->tag != DW_TAG_module
	  && abbrev->tag != DW_TAG_member
	  && abbrev->tag != DW_TAG_imported_unit)
	{
	  /* Otherwise we skip to the next sibling, if any.  */
	  info_ptr = skip_one_die (reader, info_ptr + bytes_read, abbrev);
	  continue;
	}

      info_ptr = read_partial_die (reader, part_die, abbrev, bytes_read,
				   info_ptr);

      /* This two-pass algorithm for processing partial symbols has a
	 high cost in cache pressure.  Thus, handle some simple cases
	 here which cover the majority of C partial symbols.  DIEs
	 which neither have specification tags in them, nor could have
	 specification tags elsewhere pointing at them, can simply be
	 processed and discarded.

	 This segment is also optional; scan_partial_symbols and
	 add_partial_symbol will handle these DIEs if we chain
	 them in normally.  When compilers which do not emit large
	 quantities of duplicate debug information are more common,
	 this code can probably be removed.  */

      /* Any complete simple types at the top level (pretty much all
	 of them, for a language without namespaces), can be processed
	 directly.  */
      if (parent_die == NULL
	  && part_die->has_specification == 0
	  && part_die->is_declaration == 0
	  && ((part_die->tag == DW_TAG_typedef && !part_die->has_children)
	      || part_die->tag == DW_TAG_base_type
	      || part_die->tag == DW_TAG_subrange_type))
	{
	  if (building_psymtab && part_die->name != NULL)
	    add_psymbol_to_list (part_die->name, strlen (part_die->name), 0,
				 VAR_DOMAIN, LOC_TYPEDEF,
				 &objfile->static_psymbols,
				 0, (CORE_ADDR) 0, cu->language, objfile);
	  info_ptr = locate_pdi_sibling (reader, part_die, info_ptr);
	  continue;
	}

      /* The exception for DW_TAG_typedef with has_children above is
	 a workaround of GCC PR debug/47510.  In the case of this complaint
	 type_name_no_tag_or_error will error on such types later.

	 GDB skipped children of DW_TAG_typedef by the shortcut above and then
	 it could not find the child DIEs referenced later, this is checked
	 above.  In correct DWARF DW_TAG_typedef should have no children.  */

      if (part_die->tag == DW_TAG_typedef && part_die->has_children)
	complaint (&symfile_complaints,
		   _("DW_TAG_typedef has childen - GCC PR debug/47510 bug "
		     "- DIE at 0x%x [in module %s]"),
		   part_die->offset.sect_off, objfile_name (objfile));

      /* If we're at the second level, and we're an enumerator, and
	 our parent has no specification (meaning possibly lives in a
	 namespace elsewhere), then we can add the partial symbol now
	 instead of queueing it.  */
      if (part_die->tag == DW_TAG_enumerator
	  && parent_die != NULL
	  && parent_die->die_parent == NULL
	  && parent_die->tag == DW_TAG_enumeration_type
	  && parent_die->has_specification == 0)
	{
	  if (part_die->name == NULL)
	    complaint (&symfile_complaints,
		       _("malformed enumerator DIE ignored"));
	  else if (building_psymtab)
	    add_psymbol_to_list (part_die->name, strlen (part_die->name), 0,
				 VAR_DOMAIN, LOC_CONST,
				 (cu->language == language_cplus
				  || cu->language == language_java)
				 ? &objfile->global_psymbols
				 : &objfile->static_psymbols,
				 0, (CORE_ADDR) 0, cu->language, objfile);

	  info_ptr = locate_pdi_sibling (reader, part_die, info_ptr);
	  continue;
	}

      /* We'll save this DIE so link it in.  */
      part_die->die_parent = parent_die;
      part_die->die_sibling = NULL;
      part_die->die_child = NULL;

      if (last_die && last_die == parent_die)
	last_die->die_child = part_die;
      else if (last_die)
	last_die->die_sibling = part_die;

      last_die = part_die;

      if (first_die == NULL)
	first_die = part_die;

      /* Maybe add the DIE to the hash table.  Not all DIEs that we
	 find interesting need to be in the hash table, because we
	 also have the parent/sibling/child chains; only those that we
	 might refer to by offset later during partial symbol reading.

	 For now this means things that might have be the target of a
	 DW_AT_specification, DW_AT_abstract_origin, or
	 DW_AT_extension.  DW_AT_extension will refer only to
	 namespaces; DW_AT_abstract_origin refers to functions (and
	 many things under the function DIE, but we do not recurse
	 into function DIEs during partial symbol reading) and
	 possibly variables as well; DW_AT_specification refers to
	 declarations.  Declarations ought to have the DW_AT_declaration
	 flag.  It happens that GCC forgets to put it in sometimes, but
	 only for functions, not for types.

	 Adding more things than necessary to the hash table is harmless
	 except for the performance cost.  Adding too few will result in
	 wasted time in find_partial_die, when we reread the compilation
	 unit with load_all_dies set.  */

      if (load_all
	  || abbrev->tag == DW_TAG_constant
	  || abbrev->tag == DW_TAG_subprogram
	  || abbrev->tag == DW_TAG_variable
	  || abbrev->tag == DW_TAG_namespace
	  || part_die->is_declaration)
	{
	  void **slot;

	  slot = htab_find_slot_with_hash (cu->partial_dies, part_die,
					   part_die->offset.sect_off, INSERT);
	  *slot = part_die;
	}

      part_die = obstack_alloc (&cu->comp_unit_obstack,
				sizeof (struct partial_die_info));

      /* For some DIEs we want to follow their children (if any).  For C
	 we have no reason to follow the children of structures; for other
	 languages we have to, so that we can get at method physnames
	 to infer fully qualified class names, for DW_AT_specification,
	 and for C++ template arguments.  For C++, we also look one level
	 inside functions to find template arguments (if the name of the
	 function does not already contain the template arguments).

	 For Ada, we need to scan the children of subprograms and lexical
	 blocks as well because Ada allows the definition of nested
	 entities that could be interesting for the debugger, such as
	 nested subprograms for instance.  */
      if (last_die->has_children
	  && (load_all
	      || last_die->tag == DW_TAG_namespace
	      || last_die->tag == DW_TAG_module
	      || last_die->tag == DW_TAG_enumeration_type
	      || (cu->language == language_cplus
		  && last_die->tag == DW_TAG_subprogram
		  && (last_die->name == NULL
		      || strchr (last_die->name, '<') == NULL))
	      || (cu->language != language_c
		  && (last_die->tag == DW_TAG_class_type
		      || last_die->tag == DW_TAG_interface_type
		      || last_die->tag == DW_TAG_structure_type
		      || last_die->tag == DW_TAG_union_type))
	      || (cu->language == language_ada
		  && (last_die->tag == DW_TAG_subprogram
		      || last_die->tag == DW_TAG_lexical_block))))
	{
	  nesting_level++;
	  parent_die = last_die;
	  continue;
	}

      /* Otherwise we skip to the next sibling, if any.  */
      info_ptr = locate_pdi_sibling (reader, last_die, info_ptr);

      /* Back to the top, do it again.  */
    }
}

/* Read a minimal amount of information into the minimal die structure.  */

static const gdb_byte *
read_partial_die (const struct die_reader_specs *reader,
		  struct partial_die_info *part_die,
		  struct abbrev_info *abbrev, unsigned int abbrev_len,
		  const gdb_byte *info_ptr)
{
  struct dwarf2_cu *cu = reader->cu;
  struct objfile *objfile = cu->objfile;
  const gdb_byte *buffer = reader->buffer;
  unsigned int i;
  struct attribute attr;
  int has_low_pc_attr = 0;
  int has_high_pc_attr = 0;
  int high_pc_relative = 0;

  memset (part_die, 0, sizeof (struct partial_die_info));

  part_die->offset.sect_off = info_ptr - buffer;

  info_ptr += abbrev_len;

  if (abbrev == NULL)
    return info_ptr;

  part_die->tag = abbrev->tag;
  part_die->has_children = abbrev->has_children;

  for (i = 0; i < abbrev->num_attrs; ++i)
    {
      info_ptr = read_attribute (reader, &attr, &abbrev->attrs[i], info_ptr);

      /* Store the data if it is of an attribute we want to keep in a
         partial symbol table.  */
      switch (attr.name)
	{
	case DW_AT_name:
	  switch (part_die->tag)
	    {
	    case DW_TAG_compile_unit:
	    case DW_TAG_partial_unit:
	    case DW_TAG_type_unit:
	      /* Compilation units have a DW_AT_name that is a filename, not
		 a source language identifier.  */
	    case DW_TAG_enumeration_type:
	    case DW_TAG_enumerator:
	      /* These tags always have simple identifiers already; no need
		 to canonicalize them.  */
	      part_die->name = DW_STRING (&attr);
	      break;
	    default:
	      part_die->name
		= dwarf2_canonicalize_name (DW_STRING (&attr), cu,
					    &objfile->objfile_obstack);
	      break;
	    }
	  break;
	case DW_AT_linkage_name:
	case DW_AT_MIPS_linkage_name:
	  /* Note that both forms of linkage name might appear.  We
	     assume they will be the same, and we only store the last
	     one we see.  */
	  if (cu->language == language_ada)
	    part_die->name = DW_STRING (&attr);
	  part_die->linkage_name = DW_STRING (&attr);
	  break;
	case DW_AT_low_pc:
	  has_low_pc_attr = 1;
	  part_die->lowpc = DW_ADDR (&attr);
	  break;
	case DW_AT_high_pc:
	  has_high_pc_attr = 1;
	  if (attr.form == DW_FORM_addr
	      || attr.form == DW_FORM_GNU_addr_index)
	    part_die->highpc = DW_ADDR (&attr);
	  else
	    {
	      high_pc_relative = 1;
	      part_die->highpc = DW_UNSND (&attr);
	    }
	  break;
	case DW_AT_location:
          /* Support the .debug_loc offsets.  */
          if (attr_form_is_block (&attr))
            {
	       part_die->d.locdesc = DW_BLOCK (&attr);
            }
          else if (attr_form_is_section_offset (&attr))
            {
	      dwarf2_complex_location_expr_complaint ();
            }
          else
            {
	      dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
						     "partial symbol information");
            }
	  break;
	case DW_AT_external:
	  part_die->is_external = DW_UNSND (&attr);
	  break;
	case DW_AT_declaration:
	  part_die->is_declaration = DW_UNSND (&attr);
	  break;
	case DW_AT_type:
	  part_die->has_type = 1;
	  break;
	case DW_AT_abstract_origin:
	case DW_AT_specification:
	case DW_AT_extension:
	  part_die->has_specification = 1;
	  part_die->spec_offset = dwarf2_get_ref_die_offset (&attr);
	  part_die->spec_is_dwz = (attr.form == DW_FORM_GNU_ref_alt
				   || cu->per_cu->is_dwz);
	  break;
	case DW_AT_sibling:
	  /* Ignore absolute siblings, they might point outside of
	     the current compile unit.  */
	  if (attr.form == DW_FORM_ref_addr)
	    complaint (&symfile_complaints,
		       _("ignoring absolute DW_AT_sibling"));
	  else
	    part_die->sibling = buffer + dwarf2_get_ref_die_offset (&attr).sect_off;
	  break;
        case DW_AT_byte_size:
          part_die->has_byte_size = 1;
          break;
	case DW_AT_calling_convention:
	  /* DWARF doesn't provide a way to identify a program's source-level
	     entry point.  DW_AT_calling_convention attributes are only meant
	     to describe functions' calling conventions.

	     However, because it's a necessary piece of information in
	     Fortran, and because DW_CC_program is the only piece of debugging
	     information whose definition refers to a 'main program' at all,
	     several compilers have begun marking Fortran main programs with
	     DW_CC_program --- even when those functions use the standard
	     calling conventions.

	     So until DWARF specifies a way to provide this information and
	     compilers pick up the new representation, we'll support this
	     practice.  */
	  if (DW_UNSND (&attr) == DW_CC_program
	      && cu->language == language_fortran)
	    {
	      set_main_name (part_die->name);

	      /* As this DIE has a static linkage the name would be difficult
		 to look up later.  */
	      language_of_main = language_fortran;
	    }
	  break;
	case DW_AT_inline:
	  if (DW_UNSND (&attr) == DW_INL_inlined
	      || DW_UNSND (&attr) == DW_INL_declared_inlined)
	    part_die->may_be_inlined = 1;
	  break;

	case DW_AT_import:
	  if (part_die->tag == DW_TAG_imported_unit)
	    {
	      part_die->d.offset = dwarf2_get_ref_die_offset (&attr);
	      part_die->is_dwz = (attr.form == DW_FORM_GNU_ref_alt
				  || cu->per_cu->is_dwz);
	    }
	  break;

	default:
	  break;
	}
    }

  if (high_pc_relative)
    part_die->highpc += part_die->lowpc;

  if (has_low_pc_attr && has_high_pc_attr)
    {
      /* When using the GNU linker, .gnu.linkonce. sections are used to
	 eliminate duplicate copies of functions and vtables and such.
	 The linker will arbitrarily choose one and discard the others.
	 The AT_*_pc values for such functions refer to local labels in
	 these sections.  If the section from that file was discarded, the
	 labels are not in the output, so the relocs get a value of 0.
	 If this is a discarded function, mark the pc bounds as invalid,
	 so that GDB will ignore it.  */
      if (part_die->lowpc == 0 && !dwarf2_per_objfile->has_section_at_zero)
	{
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);

	  complaint (&symfile_complaints,
		     _("DW_AT_low_pc %s is zero "
		       "for DIE at 0x%x [in module %s]"),
		     paddress (gdbarch, part_die->lowpc),
		     part_die->offset.sect_off, objfile_name (objfile));
	}
      /* dwarf2_get_pc_bounds has also the strict low < high requirement.  */
      else if (part_die->lowpc >= part_die->highpc)
	{
	  struct gdbarch *gdbarch = get_objfile_arch (objfile);

	  complaint (&symfile_complaints,
		     _("DW_AT_low_pc %s is not < DW_AT_high_pc %s "
		       "for DIE at 0x%x [in module %s]"),
		     paddress (gdbarch, part_die->lowpc),
		     paddress (gdbarch, part_die->highpc),
		     part_die->offset.sect_off, objfile_name (objfile));
	}
      else
	part_die->has_pc_info = 1;
    }

  return info_ptr;
}

/* Find a cached partial DIE at OFFSET in CU.  */

static struct partial_die_info *
find_partial_die_in_comp_unit (sect_offset offset, struct dwarf2_cu *cu)
{
  struct partial_die_info *lookup_die = NULL;
  struct partial_die_info part_die;

  part_die.offset = offset;
  lookup_die = htab_find_with_hash (cu->partial_dies, &part_die,
				    offset.sect_off);

  return lookup_die;
}

/* Find a partial DIE at OFFSET, which may or may not be in CU,
   except in the case of .debug_types DIEs which do not reference
   outside their CU (they do however referencing other types via
   DW_FORM_ref_sig8).  */

static struct partial_die_info *
find_partial_die (sect_offset offset, int offset_in_dwz, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct dwarf2_per_cu_data *per_cu = NULL;
  struct partial_die_info *pd = NULL;

  if (offset_in_dwz == cu->per_cu->is_dwz
      && offset_in_cu_p (&cu->header, offset))
    {
      pd = find_partial_die_in_comp_unit (offset, cu);
      if (pd != NULL)
	return pd;
      /* We missed recording what we needed.
	 Load all dies and try again.  */
      per_cu = cu->per_cu;
    }
  else
    {
      /* TUs don't reference other CUs/TUs (except via type signatures).  */
      if (cu->per_cu->is_debug_types)
	{
	  error (_("Dwarf Error: Type Unit at offset 0x%lx contains"
		   " external reference to offset 0x%lx [in module %s].\n"),
		 (long) cu->header.offset.sect_off, (long) offset.sect_off,
		 bfd_get_filename (objfile->obfd));
	}
      per_cu = dwarf2_find_containing_comp_unit (offset, offset_in_dwz,
						 objfile);

      if (per_cu->cu == NULL || per_cu->cu->partial_dies == NULL)
	load_partial_comp_unit (per_cu);

      per_cu->cu->last_used = 0;
      pd = find_partial_die_in_comp_unit (offset, per_cu->cu);
    }

  /* If we didn't find it, and not all dies have been loaded,
     load them all and try again.  */

  if (pd == NULL && per_cu->load_all_dies == 0)
    {
      per_cu->load_all_dies = 1;

      /* This is nasty.  When we reread the DIEs, somewhere up the call chain
	 THIS_CU->cu may already be in use.  So we can't just free it and
	 replace its DIEs with the ones we read in.  Instead, we leave those
	 DIEs alone (which can still be in use, e.g. in scan_partial_symbols),
	 and clobber THIS_CU->cu->partial_dies with the hash table for the new
	 set.  */
      load_partial_comp_unit (per_cu);

      pd = find_partial_die_in_comp_unit (offset, per_cu->cu);
    }

  if (pd == NULL)
    internal_error (__FILE__, __LINE__,
		    _("could not find partial DIE 0x%x "
		      "in cache [from module %s]\n"),
		    offset.sect_off, bfd_get_filename (objfile->obfd));
  return pd;
}

/* See if we can figure out if the class lives in a namespace.  We do
   this by looking for a member function; its demangled name will
   contain namespace info, if there is any.  */

static void
guess_partial_die_structure_name (struct partial_die_info *struct_pdi,
				  struct dwarf2_cu *cu)
{
  /* NOTE: carlton/2003-10-07: Getting the info this way changes
     what template types look like, because the demangler
     frequently doesn't give the same name as the debug info.  We
     could fix this by only using the demangled name to get the
     prefix (but see comment in read_structure_type).  */

  struct partial_die_info *real_pdi;
  struct partial_die_info *child_pdi;

  /* If this DIE (this DIE's specification, if any) has a parent, then
     we should not do this.  We'll prepend the parent's fully qualified
     name when we create the partial symbol.  */

  real_pdi = struct_pdi;
  while (real_pdi->has_specification)
    real_pdi = find_partial_die (real_pdi->spec_offset,
				 real_pdi->spec_is_dwz, cu);

  if (real_pdi->die_parent != NULL)
    return;

  for (child_pdi = struct_pdi->die_child;
       child_pdi != NULL;
       child_pdi = child_pdi->die_sibling)
    {
      if (child_pdi->tag == DW_TAG_subprogram
	  && child_pdi->linkage_name != NULL)
	{
	  char *actual_class_name
	    = language_class_name_from_physname (cu->language_defn,
						 child_pdi->linkage_name);
	  if (actual_class_name != NULL)
	    {
	      struct_pdi->name
		= obstack_copy0 (&cu->objfile->objfile_obstack,
				 actual_class_name,
				 strlen (actual_class_name));
	      xfree (actual_class_name);
	    }
	  break;
	}
    }
}

/* Adjust PART_DIE before generating a symbol for it.  This function
   may set the is_external flag or change the DIE's name.  */

static void
fixup_partial_die (struct partial_die_info *part_die,
		   struct dwarf2_cu *cu)
{
  /* Once we've fixed up a die, there's no point in doing so again.
     This also avoids a memory leak if we were to call
     guess_partial_die_structure_name multiple times.  */
  if (part_die->fixup_called)
    return;

  /* If we found a reference attribute and the DIE has no name, try
     to find a name in the referred to DIE.  */

  if (part_die->name == NULL && part_die->has_specification)
    {
      struct partial_die_info *spec_die;

      spec_die = find_partial_die (part_die->spec_offset,
				   part_die->spec_is_dwz, cu);

      fixup_partial_die (spec_die, cu);

      if (spec_die->name)
	{
	  part_die->name = spec_die->name;

	  /* Copy DW_AT_external attribute if it is set.  */
	  if (spec_die->is_external)
	    part_die->is_external = spec_die->is_external;
	}
    }

  /* Set default names for some unnamed DIEs.  */

  if (part_die->name == NULL && part_die->tag == DW_TAG_namespace)
    part_die->name = CP_ANONYMOUS_NAMESPACE_STR;

  /* If there is no parent die to provide a namespace, and there are
     children, see if we can determine the namespace from their linkage
     name.  */
  if (cu->language == language_cplus
      && !VEC_empty (dwarf2_section_info_def, dwarf2_per_objfile->types)
      && part_die->die_parent == NULL
      && part_die->has_children
      && (part_die->tag == DW_TAG_class_type
	  || part_die->tag == DW_TAG_structure_type
	  || part_die->tag == DW_TAG_union_type))
    guess_partial_die_structure_name (part_die, cu);

  /* GCC might emit a nameless struct or union that has a linkage
     name.  See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */
  if (part_die->name == NULL
      && (part_die->tag == DW_TAG_class_type
	  || part_die->tag == DW_TAG_interface_type
	  || part_die->tag == DW_TAG_structure_type
	  || part_die->tag == DW_TAG_union_type)
      && part_die->linkage_name != NULL)
    {
      char *demangled;

      demangled = gdb_demangle (part_die->linkage_name, DMGL_TYPES);
      if (demangled)
	{
	  const char *base;

	  /* Strip any leading namespaces/classes, keep only the base name.
	     DW_AT_name for named DIEs does not contain the prefixes.  */
	  base = strrchr (demangled, ':');
	  if (base && base > demangled && base[-1] == ':')
	    base++;
	  else
	    base = demangled;

	  part_die->name = obstack_copy0 (&cu->objfile->objfile_obstack,
					  base, strlen (base));
	  xfree (demangled);
	}
    }

  part_die->fixup_called = 1;
}

/* Read an attribute value described by an attribute form.  */

static const gdb_byte *
read_attribute_value (const struct die_reader_specs *reader,
		      struct attribute *attr, unsigned form,
		      const gdb_byte *info_ptr)
{
  struct dwarf2_cu *cu = reader->cu;
  bfd *abfd = reader->abfd;
  struct comp_unit_head *cu_header = &cu->header;
  unsigned int bytes_read;
  struct dwarf_block *blk;

  attr->form = form;
  switch (form)
    {
    case DW_FORM_ref_addr:
      if (cu->header.version == 2)
	DW_UNSND (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
      else
	DW_UNSND (attr) = read_offset (abfd, info_ptr,
				       &cu->header, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_GNU_ref_alt:
      DW_UNSND (attr) = read_offset (abfd, info_ptr, &cu->header, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_addr:
      DW_ADDR (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_block2:
      blk = dwarf_alloc_block (cu);
      blk->size = read_2_bytes (abfd, info_ptr);
      info_ptr += 2;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      DW_BLOCK (attr) = blk;
      break;
    case DW_FORM_block4:
      blk = dwarf_alloc_block (cu);
      blk->size = read_4_bytes (abfd, info_ptr);
      info_ptr += 4;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      DW_BLOCK (attr) = blk;
      break;
    case DW_FORM_data2:
      DW_UNSND (attr) = read_2_bytes (abfd, info_ptr);
      info_ptr += 2;
      break;
    case DW_FORM_data4:
      DW_UNSND (attr) = read_4_bytes (abfd, info_ptr);
      info_ptr += 4;
      break;
    case DW_FORM_data8:
      DW_UNSND (attr) = read_8_bytes (abfd, info_ptr);
      info_ptr += 8;
      break;
    case DW_FORM_sec_offset:
      DW_UNSND (attr) = read_offset (abfd, info_ptr, &cu->header, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_string:
      DW_STRING (attr) = read_direct_string (abfd, info_ptr, &bytes_read);
      DW_STRING_IS_CANONICAL (attr) = 0;
      info_ptr += bytes_read;
      break;
    case DW_FORM_strp:
      if (!cu->per_cu->is_dwz)
	{
	  DW_STRING (attr) = read_indirect_string (abfd, info_ptr, cu_header,
						   &bytes_read);
	  DW_STRING_IS_CANONICAL (attr) = 0;
	  info_ptr += bytes_read;
	  break;
	}
      /* FALLTHROUGH */
    case DW_FORM_GNU_strp_alt:
      {
	struct dwz_file *dwz = dwarf2_get_dwz_file ();
	LONGEST str_offset = read_offset (abfd, info_ptr, cu_header,
					  &bytes_read);

	DW_STRING (attr) = read_indirect_string_from_dwz (dwz, str_offset);
	DW_STRING_IS_CANONICAL (attr) = 0;
	info_ptr += bytes_read;
      }
      break;
    case DW_FORM_exprloc:
    case DW_FORM_block:
      blk = dwarf_alloc_block (cu);
      blk->size = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      DW_BLOCK (attr) = blk;
      break;
    case DW_FORM_block1:
      blk = dwarf_alloc_block (cu);
      blk->size = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      blk->data = read_n_bytes (abfd, info_ptr, blk->size);
      info_ptr += blk->size;
      DW_BLOCK (attr) = blk;
      break;
    case DW_FORM_data1:
      DW_UNSND (attr) = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      break;
    case DW_FORM_flag:
      DW_UNSND (attr) = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      break;
    case DW_FORM_flag_present:
      DW_UNSND (attr) = 1;
      break;
    case DW_FORM_sdata:
      DW_SND (attr) = read_signed_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_udata:
      DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_ref1:
      DW_UNSND (attr) = (cu->header.offset.sect_off
			 + read_1_byte (abfd, info_ptr));
      info_ptr += 1;
      break;
    case DW_FORM_ref2:
      DW_UNSND (attr) = (cu->header.offset.sect_off
			 + read_2_bytes (abfd, info_ptr));
      info_ptr += 2;
      break;
    case DW_FORM_ref4:
      DW_UNSND (attr) = (cu->header.offset.sect_off
			 + read_4_bytes (abfd, info_ptr));
      info_ptr += 4;
      break;
    case DW_FORM_ref8:
      DW_UNSND (attr) = (cu->header.offset.sect_off
			 + read_8_bytes (abfd, info_ptr));
      info_ptr += 8;
      break;
    case DW_FORM_ref_sig8:
      DW_SIGNATURE (attr) = read_8_bytes (abfd, info_ptr);
      info_ptr += 8;
      break;
    case DW_FORM_ref_udata:
      DW_UNSND (attr) = (cu->header.offset.sect_off
			 + read_unsigned_leb128 (abfd, info_ptr, &bytes_read));
      info_ptr += bytes_read;
      break;
    case DW_FORM_indirect:
      form = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      info_ptr = read_attribute_value (reader, attr, form, info_ptr);
      break;
    case DW_FORM_GNU_addr_index:
      if (reader->dwo_file == NULL)
	{
	  /* For now flag a hard error.
	     Later we can turn this into a complaint.  */
	  error (_("Dwarf Error: %s found in non-DWO CU [in module %s]"),
		 dwarf_form_name (form),
		 bfd_get_filename (abfd));
	}
      DW_ADDR (attr) = read_addr_index_from_leb128 (cu, info_ptr, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_GNU_str_index:
      if (reader->dwo_file == NULL)
	{
	  /* For now flag a hard error.
	     Later we can turn this into a complaint if warranted.  */
	  error (_("Dwarf Error: %s found in non-DWO CU [in module %s]"),
		 dwarf_form_name (form),
		 bfd_get_filename (abfd));
	}
      {
	ULONGEST str_index =
	  read_unsigned_leb128 (abfd, info_ptr, &bytes_read);

	DW_STRING (attr) = read_str_index (reader, cu, str_index);
	DW_STRING_IS_CANONICAL (attr) = 0;
	info_ptr += bytes_read;
      }
      break;
    default:
      error (_("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]"),
	     dwarf_form_name (form),
	     bfd_get_filename (abfd));
    }

  /* Super hack.  */
  if (cu->per_cu->is_dwz && attr_form_is_ref (attr))
    attr->form = DW_FORM_GNU_ref_alt;

  /* We have seen instances where the compiler tried to emit a byte
     size attribute of -1 which ended up being encoded as an unsigned
     0xffffffff.  Although 0xffffffff is technically a valid size value,
     an object of this size seems pretty unlikely so we can relatively
     safely treat these cases as if the size attribute was invalid and
     treat them as zero by default.  */
  if (attr->name == DW_AT_byte_size
      && form == DW_FORM_data4
      && DW_UNSND (attr) >= 0xffffffff)
    {
      complaint
        (&symfile_complaints,
         _("Suspicious DW_AT_byte_size value treated as zero instead of %s"),
         hex_string (DW_UNSND (attr)));
      DW_UNSND (attr) = 0;
    }

  return info_ptr;
}

/* Read an attribute described by an abbreviated attribute.  */

static const gdb_byte *
read_attribute (const struct die_reader_specs *reader,
		struct attribute *attr, struct attr_abbrev *abbrev,
		const gdb_byte *info_ptr)
{
  attr->name = abbrev->name;
  return read_attribute_value (reader, attr, abbrev->form, info_ptr);
}

/* Read dwarf information from a buffer.  */

static unsigned int
read_1_byte (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_8 (abfd, buf);
}

static int
read_1_signed_byte (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_signed_8 (abfd, buf);
}

static unsigned int
read_2_bytes (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_16 (abfd, buf);
}

static int
read_2_signed_bytes (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_signed_16 (abfd, buf);
}

static unsigned int
read_4_bytes (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_32 (abfd, buf);
}

static int
read_4_signed_bytes (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_signed_32 (abfd, buf);
}

static ULONGEST
read_8_bytes (bfd *abfd, const gdb_byte *buf)
{
  return bfd_get_64 (abfd, buf);
}

static CORE_ADDR
read_address (bfd *abfd, const gdb_byte *buf, struct dwarf2_cu *cu,
	      unsigned int *bytes_read)
{
  struct comp_unit_head *cu_header = &cu->header;
  CORE_ADDR retval = 0;

  if (cu_header->signed_addr_p)
    {
      switch (cu_header->addr_size)
	{
	case 2:
	  retval = bfd_get_signed_16 (abfd, buf);
	  break;
	case 4:
	  retval = bfd_get_signed_32 (abfd, buf);
	  break;
	case 8:
	  retval = bfd_get_signed_64 (abfd, buf);
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  _("read_address: bad switch, signed [in module %s]"),
			  bfd_get_filename (abfd));
	}
    }
  else
    {
      switch (cu_header->addr_size)
	{
	case 2:
	  retval = bfd_get_16 (abfd, buf);
	  break;
	case 4:
	  retval = bfd_get_32 (abfd, buf);
	  break;
	case 8:
	  retval = bfd_get_64 (abfd, buf);
	  break;
	default:
	  internal_error (__FILE__, __LINE__,
			  _("read_address: bad switch, "
			    "unsigned [in module %s]"),
			  bfd_get_filename (abfd));
	}
    }

  *bytes_read = cu_header->addr_size;
  return retval;
}

/* Read the initial length from a section.  The (draft) DWARF 3
   specification allows the initial length to take up either 4 bytes
   or 12 bytes.  If the first 4 bytes are 0xffffffff, then the next 8
   bytes describe the length and all offsets will be 8 bytes in length
   instead of 4.

   An older, non-standard 64-bit format is also handled by this
   function.  The older format in question stores the initial length
   as an 8-byte quantity without an escape value.  Lengths greater
   than 2^32 aren't very common which means that the initial 4 bytes
   is almost always zero.  Since a length value of zero doesn't make
   sense for the 32-bit format, this initial zero can be considered to
   be an escape value which indicates the presence of the older 64-bit
   format.  As written, the code can't detect (old format) lengths
   greater than 4GB.  If it becomes necessary to handle lengths
   somewhat larger than 4GB, we could allow other small values (such
   as the non-sensical values of 1, 2, and 3) to also be used as
   escape values indicating the presence of the old format.

   The value returned via bytes_read should be used to increment the
   relevant pointer after calling read_initial_length().

   [ Note:  read_initial_length() and read_offset() are based on the
     document entitled "DWARF Debugging Information Format", revision
     3, draft 8, dated November 19, 2001.  This document was obtained
     from:

	http://reality.sgiweb.org/davea/dwarf3-draft8-011125.pdf

     This document is only a draft and is subject to change.  (So beware.)

     Details regarding the older, non-standard 64-bit format were
     determined empirically by examining 64-bit ELF files produced by
     the SGI toolchain on an IRIX 6.5 machine.

     - Kevin, July 16, 2002
   ] */

static LONGEST
read_initial_length (bfd *abfd, const gdb_byte *buf, unsigned int *bytes_read)
{
  LONGEST length = bfd_get_32 (abfd, buf);

  if (length == 0xffffffff)
    {
      length = bfd_get_64 (abfd, buf + 4);
      *bytes_read = 12;
    }
  else if (length == 0)
    {
      /* Handle the (non-standard) 64-bit DWARF2 format used by IRIX.  */
      length = bfd_get_64 (abfd, buf);
      *bytes_read = 8;
    }
  else
    {
      *bytes_read = 4;
    }

  return length;
}

/* Cover function for read_initial_length.
   Returns the length of the object at BUF, and stores the size of the
   initial length in *BYTES_READ and stores the size that offsets will be in
   *OFFSET_SIZE.
   If the initial length size is not equivalent to that specified in
   CU_HEADER then issue a complaint.
   This is useful when reading non-comp-unit headers.  */

static LONGEST
read_checked_initial_length_and_offset (bfd *abfd, const gdb_byte *buf,
					const struct comp_unit_head *cu_header,
					unsigned int *bytes_read,
					unsigned int *offset_size)
{
  LONGEST length = read_initial_length (abfd, buf, bytes_read);

  gdb_assert (cu_header->initial_length_size == 4
	      || cu_header->initial_length_size == 8
	      || cu_header->initial_length_size == 12);

  if (cu_header->initial_length_size != *bytes_read)
    complaint (&symfile_complaints,
	       _("intermixed 32-bit and 64-bit DWARF sections"));

  *offset_size = (*bytes_read == 4) ? 4 : 8;
  return length;
}

/* Read an offset from the data stream.  The size of the offset is
   given by cu_header->offset_size.  */

static LONGEST
read_offset (bfd *abfd, const gdb_byte *buf,
	     const struct comp_unit_head *cu_header,
             unsigned int *bytes_read)
{
  LONGEST offset = read_offset_1 (abfd, buf, cu_header->offset_size);

  *bytes_read = cu_header->offset_size;
  return offset;
}

/* Read an offset from the data stream.  */

static LONGEST
read_offset_1 (bfd *abfd, const gdb_byte *buf, unsigned int offset_size)
{
  LONGEST retval = 0;

  switch (offset_size)
    {
    case 4:
      retval = bfd_get_32 (abfd, buf);
      break;
    case 8:
      retval = bfd_get_64 (abfd, buf);
      break;
    default:
      internal_error (__FILE__, __LINE__,
		      _("read_offset_1: bad switch [in module %s]"),
		      bfd_get_filename (abfd));
    }

  return retval;
}

static const gdb_byte *
read_n_bytes (bfd *abfd, const gdb_byte *buf, unsigned int size)
{
  /* If the size of a host char is 8 bits, we can return a pointer
     to the buffer, otherwise we have to copy the data to a buffer
     allocated on the temporary obstack.  */
  gdb_assert (HOST_CHAR_BIT == 8);
  return buf;
}

static const char *
read_direct_string (bfd *abfd, const gdb_byte *buf,
		    unsigned int *bytes_read_ptr)
{
  /* If the size of a host char is 8 bits, we can return a pointer
     to the string, otherwise we have to copy the string to a buffer
     allocated on the temporary obstack.  */
  gdb_assert (HOST_CHAR_BIT == 8);
  if (*buf == '\0')
    {
      *bytes_read_ptr = 1;
      return NULL;
    }
  *bytes_read_ptr = strlen ((const char *) buf) + 1;
  return (const char *) buf;
}

static const char *
read_indirect_string_at_offset (bfd *abfd, LONGEST str_offset)
{
  dwarf2_read_section (dwarf2_per_objfile->objfile, &dwarf2_per_objfile->str);
  if (dwarf2_per_objfile->str.buffer == NULL)
    error (_("DW_FORM_strp used without .debug_str section [in module %s]"),
	   bfd_get_filename (abfd));
  if (str_offset >= dwarf2_per_objfile->str.size)
    error (_("DW_FORM_strp pointing outside of "
	     ".debug_str section [in module %s]"),
	   bfd_get_filename (abfd));
  gdb_assert (HOST_CHAR_BIT == 8);
  if (dwarf2_per_objfile->str.buffer[str_offset] == '\0')
    return NULL;
  return (const char *) (dwarf2_per_objfile->str.buffer + str_offset);
}

/* Read a string at offset STR_OFFSET in the .debug_str section from
   the .dwz file DWZ.  Throw an error if the offset is too large.  If
   the string consists of a single NUL byte, return NULL; otherwise
   return a pointer to the string.  */

static const char *
read_indirect_string_from_dwz (struct dwz_file *dwz, LONGEST str_offset)
{
  dwarf2_read_section (dwarf2_per_objfile->objfile, &dwz->str);

  if (dwz->str.buffer == NULL)
    error (_("DW_FORM_GNU_strp_alt used without .debug_str "
	     "section [in module %s]"),
	   bfd_get_filename (dwz->dwz_bfd));
  if (str_offset >= dwz->str.size)
    error (_("DW_FORM_GNU_strp_alt pointing outside of "
	     ".debug_str section [in module %s]"),
	   bfd_get_filename (dwz->dwz_bfd));
  gdb_assert (HOST_CHAR_BIT == 8);
  if (dwz->str.buffer[str_offset] == '\0')
    return NULL;
  return (const char *) (dwz->str.buffer + str_offset);
}

static const char *
read_indirect_string (bfd *abfd, const gdb_byte *buf,
		      const struct comp_unit_head *cu_header,
		      unsigned int *bytes_read_ptr)
{
  LONGEST str_offset = read_offset (abfd, buf, cu_header, bytes_read_ptr);

  return read_indirect_string_at_offset (abfd, str_offset);
}

static ULONGEST
read_unsigned_leb128 (bfd *abfd, const gdb_byte *buf,
		      unsigned int *bytes_read_ptr)
{
  ULONGEST result;
  unsigned int num_read;
  int i, shift;
  unsigned char byte;

  result = 0;
  shift = 0;
  num_read = 0;
  i = 0;
  while (1)
    {
      byte = bfd_get_8 (abfd, buf);
      buf++;
      num_read++;
      result |= ((ULONGEST) (byte & 127) << shift);
      if ((byte & 128) == 0)
	{
	  break;
	}
      shift += 7;
    }
  *bytes_read_ptr = num_read;
  return result;
}

static LONGEST
read_signed_leb128 (bfd *abfd, const gdb_byte *buf,
		    unsigned int *bytes_read_ptr)
{
  LONGEST result;
  int i, shift, num_read;
  unsigned char byte;

  result = 0;
  shift = 0;
  num_read = 0;
  i = 0;
  while (1)
    {
      byte = bfd_get_8 (abfd, buf);
      buf++;
      num_read++;
      result |= ((LONGEST) (byte & 127) << shift);
      shift += 7;
      if ((byte & 128) == 0)
	{
	  break;
	}
    }
  if ((shift < 8 * sizeof (result)) && (byte & 0x40))
    result |= -(((LONGEST) 1) << shift);
  *bytes_read_ptr = num_read;
  return result;
}

/* Given index ADDR_INDEX in .debug_addr, fetch the value.
   ADDR_BASE is the DW_AT_GNU_addr_base attribute or zero.
   ADDR_SIZE is the size of addresses from the CU header.  */

static CORE_ADDR
read_addr_index_1 (unsigned int addr_index, ULONGEST addr_base, int addr_size)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  bfd *abfd = objfile->obfd;
  const gdb_byte *info_ptr;

  dwarf2_read_section (objfile, &dwarf2_per_objfile->addr);
  if (dwarf2_per_objfile->addr.buffer == NULL)
    error (_("DW_FORM_addr_index used without .debug_addr section [in module %s]"),
	   objfile_name (objfile));
  if (addr_base + addr_index * addr_size >= dwarf2_per_objfile->addr.size)
    error (_("DW_FORM_addr_index pointing outside of "
	     ".debug_addr section [in module %s]"),
	   objfile_name (objfile));
  info_ptr = (dwarf2_per_objfile->addr.buffer
	      + addr_base + addr_index * addr_size);
  if (addr_size == 4)
    return bfd_get_32 (abfd, info_ptr);
  else
    return bfd_get_64 (abfd, info_ptr);
}

/* Given index ADDR_INDEX in .debug_addr, fetch the value.  */

static CORE_ADDR
read_addr_index (struct dwarf2_cu *cu, unsigned int addr_index)
{
  return read_addr_index_1 (addr_index, cu->addr_base, cu->header.addr_size);
}

/* Given a pointer to an leb128 value, fetch the value from .debug_addr.  */

static CORE_ADDR
read_addr_index_from_leb128 (struct dwarf2_cu *cu, const gdb_byte *info_ptr,
			     unsigned int *bytes_read)
{
  bfd *abfd = cu->objfile->obfd;
  unsigned int addr_index = read_unsigned_leb128 (abfd, info_ptr, bytes_read);

  return read_addr_index (cu, addr_index);
}

/* Data structure to pass results from dwarf2_read_addr_index_reader
   back to dwarf2_read_addr_index.  */

struct dwarf2_read_addr_index_data
{
  ULONGEST addr_base;
  int addr_size;
};

/* die_reader_func for dwarf2_read_addr_index.  */

static void
dwarf2_read_addr_index_reader (const struct die_reader_specs *reader,
			       const gdb_byte *info_ptr,
			       struct die_info *comp_unit_die,
			       int has_children,
			       void *data)
{
  struct dwarf2_cu *cu = reader->cu;
  struct dwarf2_read_addr_index_data *aidata =
    (struct dwarf2_read_addr_index_data *) data;

  aidata->addr_base = cu->addr_base;
  aidata->addr_size = cu->header.addr_size;
}

/* Given an index in .debug_addr, fetch the value.
   NOTE: This can be called during dwarf expression evaluation,
   long after the debug information has been read, and thus per_cu->cu
   may no longer exist.  */

CORE_ADDR
dwarf2_read_addr_index (struct dwarf2_per_cu_data *per_cu,
			unsigned int addr_index)
{
  struct objfile *objfile = per_cu->objfile;
  struct dwarf2_cu *cu = per_cu->cu;
  ULONGEST addr_base;
  int addr_size;

  /* This is intended to be called from outside this file.  */
  dw2_setup (objfile);

  /* We need addr_base and addr_size.
     If we don't have PER_CU->cu, we have to get it.
     Nasty, but the alternative is storing the needed info in PER_CU,
     which at this point doesn't seem justified: it's not clear how frequently
     it would get used and it would increase the size of every PER_CU.
     Entry points like dwarf2_per_cu_addr_size do a similar thing
     so we're not in uncharted territory here.
     Alas we need to be a bit more complicated as addr_base is contained
     in the DIE.

     We don't need to read the entire CU(/TU).
     We just need the header and top level die.

     IWBN to use the aging mechanism to let us lazily later discard the CU.
     For now we skip this optimization.  */

  if (cu != NULL)
    {
      addr_base = cu->addr_base;
      addr_size = cu->header.addr_size;
    }
  else
    {
      struct dwarf2_read_addr_index_data aidata;

      /* Note: We can't use init_cutu_and_read_dies_simple here,
	 we need addr_base.  */
      init_cutu_and_read_dies (per_cu, NULL, 0, 0,
			       dwarf2_read_addr_index_reader, &aidata);
      addr_base = aidata.addr_base;
      addr_size = aidata.addr_size;
    }

  return read_addr_index_1 (addr_index, addr_base, addr_size);
}

/* Given a DW_FORM_GNU_str_index, fetch the string.
   This is only used by the Fission support.  */

static const char *
read_str_index (const struct die_reader_specs *reader,
		struct dwarf2_cu *cu, ULONGEST str_index)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  const char *dwo_name = objfile_name (objfile);
  bfd *abfd = objfile->obfd;
  struct dwarf2_section_info *str_section = &reader->dwo_file->sections.str;
  struct dwarf2_section_info *str_offsets_section =
    &reader->dwo_file->sections.str_offsets;
  const gdb_byte *info_ptr;
  ULONGEST str_offset;
  static const char form_name[] = "DW_FORM_GNU_str_index";

  dwarf2_read_section (objfile, str_section);
  dwarf2_read_section (objfile, str_offsets_section);
  if (str_section->buffer == NULL)
    error (_("%s used without .debug_str.dwo section"
	     " in CU at offset 0x%lx [in module %s]"),
	   form_name, (long) cu->header.offset.sect_off, dwo_name);
  if (str_offsets_section->buffer == NULL)
    error (_("%s used without .debug_str_offsets.dwo section"
	     " in CU at offset 0x%lx [in module %s]"),
	   form_name, (long) cu->header.offset.sect_off, dwo_name);
  if (str_index * cu->header.offset_size >= str_offsets_section->size)
    error (_("%s pointing outside of .debug_str_offsets.dwo"
	     " section in CU at offset 0x%lx [in module %s]"),
	   form_name, (long) cu->header.offset.sect_off, dwo_name);
  info_ptr = (str_offsets_section->buffer
	      + str_index * cu->header.offset_size);
  if (cu->header.offset_size == 4)
    str_offset = bfd_get_32 (abfd, info_ptr);
  else
    str_offset = bfd_get_64 (abfd, info_ptr);
  if (str_offset >= str_section->size)
    error (_("Offset from %s pointing outside of"
	     " .debug_str.dwo section in CU at offset 0x%lx [in module %s]"),
	   form_name, (long) cu->header.offset.sect_off, dwo_name);
  return (const char *) (str_section->buffer + str_offset);
}

/* Return the length of an LEB128 number in BUF.  */

static int
leb128_size (const gdb_byte *buf)
{
  const gdb_byte *begin = buf;
  gdb_byte byte;

  while (1)
    {
      byte = *buf++;
      if ((byte & 128) == 0)
	return buf - begin;
    }
}

static void
set_cu_language (unsigned int lang, struct dwarf2_cu *cu)
{
  switch (lang)
    {
    case DW_LANG_C89:
    case DW_LANG_C99:
    case DW_LANG_C:
    case DW_LANG_UPC:
      cu->language = language_c;
      break;
    case DW_LANG_C_plus_plus:
      cu->language = language_cplus;
      break;
    case DW_LANG_D:
      cu->language = language_d;
      break;
    case DW_LANG_Fortran77:
    case DW_LANG_Fortran90:
    case DW_LANG_Fortran95:
      cu->language = language_fortran;
      break;
    case DW_LANG_Go:
      cu->language = language_go;
      break;
    case DW_LANG_Mips_Assembler:
      cu->language = language_asm;
      break;
    case DW_LANG_Java:
      cu->language = language_java;
      break;
    case DW_LANG_Ada83:
    case DW_LANG_Ada95:
      cu->language = language_ada;
      break;
    case DW_LANG_Modula2:
      cu->language = language_m2;
      break;
    case DW_LANG_Pascal83:
      cu->language = language_pascal;
      break;
    case DW_LANG_ObjC:
      cu->language = language_objc;
      break;
    case DW_LANG_Cobol74:
    case DW_LANG_Cobol85:
    default:
      cu->language = language_minimal;
      break;
    }
  cu->language_defn = language_def (cu->language);
}

/* Return the named attribute or NULL if not there.  */

static struct attribute *
dwarf2_attr (struct die_info *die, unsigned int name, struct dwarf2_cu *cu)
{
  for (;;)
    {
      unsigned int i;
      struct attribute *spec = NULL;

      for (i = 0; i < die->num_attrs; ++i)
	{
	  if (die->attrs[i].name == name)
	    return &die->attrs[i];
	  if (die->attrs[i].name == DW_AT_specification
	      || die->attrs[i].name == DW_AT_abstract_origin)
	    spec = &die->attrs[i];
	}

      if (!spec)
	break;

      die = follow_die_ref (die, spec, &cu);
    }

  return NULL;
}

/* Return the named attribute or NULL if not there,
   but do not follow DW_AT_specification, etc.
   This is for use in contexts where we're reading .debug_types dies.
   Following DW_AT_specification, DW_AT_abstract_origin will take us
   back up the chain, and we want to go down.  */

static struct attribute *
dwarf2_attr_no_follow (struct die_info *die, unsigned int name)
{
  unsigned int i;

  for (i = 0; i < die->num_attrs; ++i)
    if (die->attrs[i].name == name)
      return &die->attrs[i];

  return NULL;
}

/* Return non-zero iff the attribute NAME is defined for the given DIE,
   and holds a non-zero value.  This function should only be used for
   DW_FORM_flag or DW_FORM_flag_present attributes.  */

static int
dwarf2_flag_true_p (struct die_info *die, unsigned name, struct dwarf2_cu *cu)
{
  struct attribute *attr = dwarf2_attr (die, name, cu);

  return (attr && DW_UNSND (attr));
}

static int
die_is_declaration (struct die_info *die, struct dwarf2_cu *cu)
{
  /* A DIE is a declaration if it has a DW_AT_declaration attribute
     which value is non-zero.  However, we have to be careful with
     DIEs having a DW_AT_specification attribute, because dwarf2_attr()
     (via dwarf2_flag_true_p) follows this attribute.  So we may
     end up accidently finding a declaration attribute that belongs
     to a different DIE referenced by the specification attribute,
     even though the given DIE does not have a declaration attribute.  */
  return (dwarf2_flag_true_p (die, DW_AT_declaration, cu)
	  && dwarf2_attr (die, DW_AT_specification, cu) == NULL);
}

/* Return the die giving the specification for DIE, if there is
   one.  *SPEC_CU is the CU containing DIE on input, and the CU
   containing the return value on output.  If there is no
   specification, but there is an abstract origin, that is
   returned.  */

static struct die_info *
die_specification (struct die_info *die, struct dwarf2_cu **spec_cu)
{
  struct attribute *spec_attr = dwarf2_attr (die, DW_AT_specification,
					     *spec_cu);

  if (spec_attr == NULL)
    spec_attr = dwarf2_attr (die, DW_AT_abstract_origin, *spec_cu);

  if (spec_attr == NULL)
    return NULL;
  else
    return follow_die_ref (die, spec_attr, spec_cu);
}

/* Free the line_header structure *LH, and any arrays and strings it
   refers to.
   NOTE: This is also used as a "cleanup" function.  */

static void
free_line_header (struct line_header *lh)
{
  if (lh->standard_opcode_lengths)
    xfree (lh->standard_opcode_lengths);

  /* Remember that all the lh->file_names[i].name pointers are
     pointers into debug_line_buffer, and don't need to be freed.  */
  if (lh->file_names)
    xfree (lh->file_names);

  /* Similarly for the include directory names.  */
  if (lh->include_dirs)
    xfree (lh->include_dirs);

  xfree (lh);
}

/* Add an entry to LH's include directory table.  */

static void
add_include_dir (struct line_header *lh, const char *include_dir)
{
  /* Grow the array if necessary.  */
  if (lh->include_dirs_size == 0)
    {
      lh->include_dirs_size = 1; /* for testing */
      lh->include_dirs = xmalloc (lh->include_dirs_size
                                  * sizeof (*lh->include_dirs));
    }
  else if (lh->num_include_dirs >= lh->include_dirs_size)
    {
      lh->include_dirs_size *= 2;
      lh->include_dirs = xrealloc (lh->include_dirs,
                                   (lh->include_dirs_size
                                    * sizeof (*lh->include_dirs)));
    }

  lh->include_dirs[lh->num_include_dirs++] = include_dir;
}

/* Add an entry to LH's file name table.  */

static void
add_file_name (struct line_header *lh,
               const char *name,
               unsigned int dir_index,
               unsigned int mod_time,
               unsigned int length)
{
  struct file_entry *fe;

  /* Grow the array if necessary.  */
  if (lh->file_names_size == 0)
    {
      lh->file_names_size = 1; /* for testing */
      lh->file_names = xmalloc (lh->file_names_size
                                * sizeof (*lh->file_names));
    }
  else if (lh->num_file_names >= lh->file_names_size)
    {
      lh->file_names_size *= 2;
      lh->file_names = xrealloc (lh->file_names,
                                 (lh->file_names_size
                                  * sizeof (*lh->file_names)));
    }

  fe = &lh->file_names[lh->num_file_names++];
  fe->name = name;
  fe->dir_index = dir_index;
  fe->mod_time = mod_time;
  fe->length = length;
  fe->included_p = 0;
  fe->symtab = NULL;
}

/* A convenience function to find the proper .debug_line section for a
   CU.  */

static struct dwarf2_section_info *
get_debug_line_section (struct dwarf2_cu *cu)
{
  struct dwarf2_section_info *section;

  /* For TUs in DWO files, the DW_AT_stmt_list attribute lives in the
     DWO file.  */
  if (cu->dwo_unit && cu->per_cu->is_debug_types)
    section = &cu->dwo_unit->dwo_file->sections.line;
  else if (cu->per_cu->is_dwz)
    {
      struct dwz_file *dwz = dwarf2_get_dwz_file ();

      section = &dwz->line;
    }
  else
    section = &dwarf2_per_objfile->line;

  return section;
}

/* Read the statement program header starting at OFFSET in
   .debug_line, or .debug_line.dwo.  Return a pointer
   to a struct line_header, allocated using xmalloc.

   NOTE: the strings in the include directory and file name tables of
   the returned object point into the dwarf line section buffer,
   and must not be freed.  */

static struct line_header *
dwarf_decode_line_header (unsigned int offset, struct dwarf2_cu *cu)
{
  struct cleanup *back_to;
  struct line_header *lh;
  const gdb_byte *line_ptr;
  unsigned int bytes_read, offset_size;
  int i;
  const char *cur_dir, *cur_file;
  struct dwarf2_section_info *section;
  bfd *abfd;

  section = get_debug_line_section (cu);
  dwarf2_read_section (dwarf2_per_objfile->objfile, section);
  if (section->buffer == NULL)
    {
      if (cu->dwo_unit && cu->per_cu->is_debug_types)
	complaint (&symfile_complaints, _("missing .debug_line.dwo section"));
      else
	complaint (&symfile_complaints, _("missing .debug_line section"));
      return 0;
    }

  /* We can't do this until we know the section is non-empty.
     Only then do we know we have such a section.  */
  abfd = get_section_bfd_owner (section);

  /* Make sure that at least there's room for the total_length field.
     That could be 12 bytes long, but we're just going to fudge that.  */
  if (offset + 4 >= section->size)
    {
      dwarf2_statement_list_fits_in_line_number_section_complaint ();
      return 0;
    }

  lh = xmalloc (sizeof (*lh));
  memset (lh, 0, sizeof (*lh));
  back_to = make_cleanup ((make_cleanup_ftype *) free_line_header,
                          (void *) lh);

  line_ptr = section->buffer + offset;

  /* Read in the header.  */
  lh->total_length =
    read_checked_initial_length_and_offset (abfd, line_ptr, &cu->header,
					    &bytes_read, &offset_size);
  line_ptr += bytes_read;
  if (line_ptr + lh->total_length > (section->buffer + section->size))
    {
      dwarf2_statement_list_fits_in_line_number_section_complaint ();
      do_cleanups (back_to);
      return 0;
    }
  lh->statement_program_end = line_ptr + lh->total_length;
  lh->version = read_2_bytes (abfd, line_ptr);
  line_ptr += 2;
  lh->header_length = read_offset_1 (abfd, line_ptr, offset_size);
  line_ptr += offset_size;
  lh->minimum_instruction_length = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  if (lh->version >= 4)
    {
      lh->maximum_ops_per_instruction = read_1_byte (abfd, line_ptr);
      line_ptr += 1;
    }
  else
    lh->maximum_ops_per_instruction = 1;

  if (lh->maximum_ops_per_instruction == 0)
    {
      lh->maximum_ops_per_instruction = 1;
      complaint (&symfile_complaints,
		 _("invalid maximum_ops_per_instruction "
		   "in `.debug_line' section"));
    }

  lh->default_is_stmt = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh->line_base = read_1_signed_byte (abfd, line_ptr);
  line_ptr += 1;
  lh->line_range = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh->opcode_base = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh->standard_opcode_lengths
    = xmalloc (lh->opcode_base * sizeof (lh->standard_opcode_lengths[0]));

  lh->standard_opcode_lengths[0] = 1;  /* This should never be used anyway.  */
  for (i = 1; i < lh->opcode_base; ++i)
    {
      lh->standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr);
      line_ptr += 1;
    }

  /* Read directory table.  */
  while ((cur_dir = read_direct_string (abfd, line_ptr, &bytes_read)) != NULL)
    {
      line_ptr += bytes_read;
      add_include_dir (lh, cur_dir);
    }
  line_ptr += bytes_read;

  /* Read file name table.  */
  while ((cur_file = read_direct_string (abfd, line_ptr, &bytes_read)) != NULL)
    {
      unsigned int dir_index, mod_time, length;

      line_ptr += bytes_read;
      dir_index = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      mod_time = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      length = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;

      add_file_name (lh, cur_file, dir_index, mod_time, length);
    }
  line_ptr += bytes_read;
  lh->statement_program_start = line_ptr;

  if (line_ptr > (section->buffer + section->size))
    complaint (&symfile_complaints,
	       _("line number info header doesn't "
		 "fit in `.debug_line' section"));

  discard_cleanups (back_to);
  return lh;
}

/* Subroutine of dwarf_decode_lines to simplify it.
   Return the file name of the psymtab for included file FILE_INDEX
   in line header LH of PST.
   COMP_DIR is the compilation directory (DW_AT_comp_dir) or NULL if unknown.
   If space for the result is malloc'd, it will be freed by a cleanup.
   Returns NULL if FILE_INDEX should be ignored, i.e., it is pst->filename.

   The function creates dangling cleanup registration.  */

static const char *
psymtab_include_file_name (const struct line_header *lh, int file_index,
			   const struct partial_symtab *pst,
			   const char *comp_dir)
{
  const struct file_entry fe = lh->file_names [file_index];
  const char *include_name = fe.name;
  const char *include_name_to_compare = include_name;
  const char *dir_name = NULL;
  const char *pst_filename;
  char *copied_name = NULL;
  int file_is_pst;

  if (fe.dir_index)
    dir_name = lh->include_dirs[fe.dir_index - 1];

  if (!IS_ABSOLUTE_PATH (include_name)
      && (dir_name != NULL || comp_dir != NULL))
    {
      /* Avoid creating a duplicate psymtab for PST.
	 We do this by comparing INCLUDE_NAME and PST_FILENAME.
	 Before we do the comparison, however, we need to account
	 for DIR_NAME and COMP_DIR.
	 First prepend dir_name (if non-NULL).  If we still don't
	 have an absolute path prepend comp_dir (if non-NULL).
	 However, the directory we record in the include-file's
	 psymtab does not contain COMP_DIR (to match the
	 corresponding symtab(s)).

	 Example:

	 bash$ cd /tmp
	 bash$ gcc -g ./hello.c
	 include_name = "hello.c"
	 dir_name = "."
	 DW_AT_comp_dir = comp_dir = "/tmp"
	 DW_AT_name = "./hello.c"  */

      if (dir_name != NULL)
	{
	  char *tem = concat (dir_name, SLASH_STRING,
			      include_name, (char *)NULL);

	  make_cleanup (xfree, tem);
	  include_name = tem;
	  include_name_to_compare = include_name;
	}
      if (!IS_ABSOLUTE_PATH (include_name) && comp_dir != NULL)
	{
	  char *tem = concat (comp_dir, SLASH_STRING,
			      include_name, (char *)NULL);

	  make_cleanup (xfree, tem);
	  include_name_to_compare = tem;
	}
    }

  pst_filename = pst->filename;
  if (!IS_ABSOLUTE_PATH (pst_filename) && pst->dirname != NULL)
    {
      copied_name = concat (pst->dirname, SLASH_STRING,
			    pst_filename, (char *)NULL);
      pst_filename = copied_name;
    }

  file_is_pst = FILENAME_CMP (include_name_to_compare, pst_filename) == 0;

  if (copied_name != NULL)
    xfree (copied_name);

  if (file_is_pst)
    return NULL;
  return include_name;
}

/* Ignore this record_line request.  */

static void
noop_record_line (struct subfile *subfile, int line, CORE_ADDR pc)
{
  return;
}

/* Subroutine of dwarf_decode_lines to simplify it.
   Process the line number information in LH.  */

static void
dwarf_decode_lines_1 (struct line_header *lh, const char *comp_dir,
		      struct dwarf2_cu *cu, struct partial_symtab *pst)
{
  const gdb_byte *line_ptr, *extended_end;
  const gdb_byte *line_end;
  unsigned int bytes_read, extended_len;
  unsigned char op_code, extended_op, adj_opcode;
  CORE_ADDR baseaddr;
  struct objfile *objfile = cu->objfile;
  bfd *abfd = objfile->obfd;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  const int decode_for_pst_p = (pst != NULL);
  struct subfile *last_subfile = NULL;
  void (*p_record_line) (struct subfile *subfile, int line, CORE_ADDR pc)
    = record_line;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  line_ptr = lh->statement_program_start;
  line_end = lh->statement_program_end;

  /* Read the statement sequences until there's nothing left.  */
  while (line_ptr < line_end)
    {
      /* state machine registers  */
      CORE_ADDR address = 0;
      unsigned int file = 1;
      unsigned int line = 1;
      unsigned int column = 0;
      int is_stmt = lh->default_is_stmt;
      int basic_block = 0;
      int end_sequence = 0;
      CORE_ADDR addr;
      unsigned char op_index = 0;

      if (!decode_for_pst_p && lh->num_file_names >= file)
	{
          /* Start a subfile for the current file of the state machine.  */
	  /* lh->include_dirs and lh->file_names are 0-based, but the
	     directory and file name numbers in the statement program
	     are 1-based.  */
          struct file_entry *fe = &lh->file_names[file - 1];
          const char *dir = NULL;

          if (fe->dir_index)
            dir = lh->include_dirs[fe->dir_index - 1];

	  dwarf2_start_subfile (fe->name, dir, comp_dir);
	}

      /* Decode the table.  */
      while (!end_sequence)
	{
	  op_code = read_1_byte (abfd, line_ptr);
	  line_ptr += 1;
          if (line_ptr > line_end)
            {
              dwarf2_debug_line_missing_end_sequence_complaint ();
              break;
            }

	  if (op_code >= lh->opcode_base)
	    {
	      /* Special operand.  */
	      adj_opcode = op_code - lh->opcode_base;
	      address += (((op_index + (adj_opcode / lh->line_range))
			   / lh->maximum_ops_per_instruction)
			  * lh->minimum_instruction_length);
	      op_index = ((op_index + (adj_opcode / lh->line_range))
			  % lh->maximum_ops_per_instruction);
	      line += lh->line_base + (adj_opcode % lh->line_range);
	      if (lh->num_file_names < file || file == 0)
		dwarf2_debug_line_missing_file_complaint ();
	      /* For now we ignore lines not starting on an
		 instruction boundary.  */
	      else if (op_index == 0)
		{
		  lh->file_names[file - 1].included_p = 1;
		  if (!decode_for_pst_p && is_stmt)
		    {
		      if (last_subfile != current_subfile)
			{
			  addr = gdbarch_addr_bits_remove (gdbarch, address);
			  if (last_subfile)
			    (*p_record_line) (last_subfile, 0, addr);
			  last_subfile = current_subfile;
			}
		      /* Append row to matrix using current values.  */
		      addr = gdbarch_addr_bits_remove (gdbarch, address);
		      (*p_record_line) (current_subfile, line, addr);
		    }
		}
	      basic_block = 0;
	    }
	  else switch (op_code)
	    {
	    case DW_LNS_extended_op:
	      extended_len = read_unsigned_leb128 (abfd, line_ptr,
						   &bytes_read);
	      line_ptr += bytes_read;
	      extended_end = line_ptr + extended_len;
	      extended_op = read_1_byte (abfd, line_ptr);
	      line_ptr += 1;
	      switch (extended_op)
		{
		case DW_LNE_end_sequence:
		  p_record_line = record_line;
		  end_sequence = 1;
		  break;
		case DW_LNE_set_address:
		  address = read_address (abfd, line_ptr, cu, &bytes_read);

		  if (address == 0 && !dwarf2_per_objfile->has_section_at_zero)
		    {
		      /* This line table is for a function which has been
			 GCd by the linker.  Ignore it.  PR gdb/12528 */

		      long line_offset
			= line_ptr - get_debug_line_section (cu)->buffer;

		      complaint (&symfile_complaints,
				 _(".debug_line address at offset 0x%lx is 0 "
				   "[in module %s]"),
				 line_offset, objfile_name (objfile));
		      p_record_line = noop_record_line;
		    }

		  op_index = 0;
		  line_ptr += bytes_read;
		  address += baseaddr;
		  break;
		case DW_LNE_define_file:
                  {
                    const char *cur_file;
                    unsigned int dir_index, mod_time, length;

                    cur_file = read_direct_string (abfd, line_ptr,
						   &bytes_read);
                    line_ptr += bytes_read;
                    dir_index =
                      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
                    line_ptr += bytes_read;
                    mod_time =
                      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
                    line_ptr += bytes_read;
                    length =
                      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
                    line_ptr += bytes_read;
                    add_file_name (lh, cur_file, dir_index, mod_time, length);
                  }
		  break;
		case DW_LNE_set_discriminator:
		  /* The discriminator is not interesting to the debugger;
		     just ignore it.  */
		  line_ptr = extended_end;
		  break;
		default:
		  complaint (&symfile_complaints,
			     _("mangled .debug_line section"));
		  return;
		}
	      /* Make sure that we parsed the extended op correctly.  If e.g.
		 we expected a different address size than the producer used,
		 we may have read the wrong number of bytes.  */
	      if (line_ptr != extended_end)
		{
		  complaint (&symfile_complaints,
			     _("mangled .debug_line section"));
		  return;
		}
	      break;
	    case DW_LNS_copy:
	      if (lh->num_file_names < file || file == 0)
		dwarf2_debug_line_missing_file_complaint ();
	      else
		{
		  lh->file_names[file - 1].included_p = 1;
		  if (!decode_for_pst_p && is_stmt)
		    {
		      if (last_subfile != current_subfile)
			{
			  addr = gdbarch_addr_bits_remove (gdbarch, address);
			  if (last_subfile)
			    (*p_record_line) (last_subfile, 0, addr);
			  last_subfile = current_subfile;
			}
		      addr = gdbarch_addr_bits_remove (gdbarch, address);
		      (*p_record_line) (current_subfile, line, addr);
		    }
		}
	      basic_block = 0;
	      break;
	    case DW_LNS_advance_pc:
	      {
		CORE_ADDR adjust
		  = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);

		address += (((op_index + adjust)
			     / lh->maximum_ops_per_instruction)
			    * lh->minimum_instruction_length);
		op_index = ((op_index + adjust)
			    % lh->maximum_ops_per_instruction);
		line_ptr += bytes_read;
	      }
	      break;
	    case DW_LNS_advance_line:
	      line += read_signed_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_set_file:
              {
                /* The arrays lh->include_dirs and lh->file_names are
                   0-based, but the directory and file name numbers in
                   the statement program are 1-based.  */
                struct file_entry *fe;
                const char *dir = NULL;

                file = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
                line_ptr += bytes_read;
                if (lh->num_file_names < file || file == 0)
                  dwarf2_debug_line_missing_file_complaint ();
                else
                  {
                    fe = &lh->file_names[file - 1];
                    if (fe->dir_index)
                      dir = lh->include_dirs[fe->dir_index - 1];
                    if (!decode_for_pst_p)
                      {
                        last_subfile = current_subfile;
                        dwarf2_start_subfile (fe->name, dir, comp_dir);
                      }
                  }
              }
	      break;
	    case DW_LNS_set_column:
	      column = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
	      break;
	    case DW_LNS_negate_stmt:
	      is_stmt = (!is_stmt);
	      break;
	    case DW_LNS_set_basic_block:
	      basic_block = 1;
	      break;
	    /* Add to the address register of the state machine the
	       address increment value corresponding to special opcode
	       255.  I.e., this value is scaled by the minimum
	       instruction length since special opcode 255 would have
	       scaled the increment.  */
	    case DW_LNS_const_add_pc:
	      {
		CORE_ADDR adjust = (255 - lh->opcode_base) / lh->line_range;

		address += (((op_index + adjust)
			     / lh->maximum_ops_per_instruction)
			    * lh->minimum_instruction_length);
		op_index = ((op_index + adjust)
			    % lh->maximum_ops_per_instruction);
	      }
	      break;
	    case DW_LNS_fixed_advance_pc:
	      address += read_2_bytes (abfd, line_ptr);
	      op_index = 0;
	      line_ptr += 2;
	      break;
	    default:
	      {
		/* Unknown standard opcode, ignore it.  */
		int i;

		for (i = 0; i < lh->standard_opcode_lengths[op_code]; i++)
		  {
		    (void) read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		    line_ptr += bytes_read;
		  }
	      }
	    }
	}
      if (lh->num_file_names < file || file == 0)
        dwarf2_debug_line_missing_file_complaint ();
      else
        {
          lh->file_names[file - 1].included_p = 1;
          if (!decode_for_pst_p)
	    {
	      addr = gdbarch_addr_bits_remove (gdbarch, address);
	      (*p_record_line) (current_subfile, 0, addr);
	    }
        }
    }
}

/* Decode the Line Number Program (LNP) for the given line_header
   structure and CU.  The actual information extracted and the type
   of structures created from the LNP depends on the value of PST.

   1. If PST is NULL, then this procedure uses the data from the program
      to create all necessary symbol tables, and their linetables.

   2. If PST is not NULL, this procedure reads the program to determine
      the list of files included by the unit represented by PST, and
      builds all the associated partial symbol tables.

   COMP_DIR is the compilation directory (DW_AT_comp_dir) or NULL if unknown.
   It is used for relative paths in the line table.
   NOTE: When processing partial symtabs (pst != NULL),
   comp_dir == pst->dirname.

   NOTE: It is important that psymtabs have the same file name (via strcmp)
   as the corresponding symtab.  Since COMP_DIR is not used in the name of the
   symtab we don't use it in the name of the psymtabs we create.
   E.g. expand_line_sal requires this when finding psymtabs to expand.
   A good testcase for this is mb-inline.exp.  */

static void
dwarf_decode_lines (struct line_header *lh, const char *comp_dir,
		    struct dwarf2_cu *cu, struct partial_symtab *pst,
		    int want_line_info)
{
  struct objfile *objfile = cu->objfile;
  const int decode_for_pst_p = (pst != NULL);
  struct subfile *first_subfile = current_subfile;

  if (want_line_info)
    dwarf_decode_lines_1 (lh, comp_dir, cu, pst);

  if (decode_for_pst_p)
    {
      int file_index;

      /* Now that we're done scanning the Line Header Program, we can
         create the psymtab of each included file.  */
      for (file_index = 0; file_index < lh->num_file_names; file_index++)
        if (lh->file_names[file_index].included_p == 1)
          {
	    const char *include_name =
	      psymtab_include_file_name (lh, file_index, pst, comp_dir);
	    if (include_name != NULL)
              dwarf2_create_include_psymtab (include_name, pst, objfile);
          }
    }
  else
    {
      /* Make sure a symtab is created for every file, even files
	 which contain only variables (i.e. no code with associated
	 line numbers).  */
      int i;

      for (i = 0; i < lh->num_file_names; i++)
	{
	  const char *dir = NULL;
	  struct file_entry *fe;

	  fe = &lh->file_names[i];
	  if (fe->dir_index)
	    dir = lh->include_dirs[fe->dir_index - 1];
	  dwarf2_start_subfile (fe->name, dir, comp_dir);

	  /* Skip the main file; we don't need it, and it must be
	     allocated last, so that it will show up before the
	     non-primary symtabs in the objfile's symtab list.  */
	  if (current_subfile == first_subfile)
	    continue;

	  if (current_subfile->symtab == NULL)
	    current_subfile->symtab = allocate_symtab (current_subfile->name,
						       objfile);
	  fe->symtab = current_subfile->symtab;
	}
    }
}

/* Start a subfile for DWARF.  FILENAME is the name of the file and
   DIRNAME the name of the source directory which contains FILENAME
   or NULL if not known.  COMP_DIR is the compilation directory for the
   linetable's compilation unit or NULL if not known.
   This routine tries to keep line numbers from identical absolute and
   relative file names in a common subfile.

   Using the `list' example from the GDB testsuite, which resides in
   /srcdir and compiling it with Irix6.2 cc in /compdir using a filename
   of /srcdir/list0.c yields the following debugging information for list0.c:

   DW_AT_name:          /srcdir/list0.c
   DW_AT_comp_dir:              /compdir
   files.files[0].name: list0.h
   files.files[0].dir:  /srcdir
   files.files[1].name: list0.c
   files.files[1].dir:  /srcdir

   The line number information for list0.c has to end up in a single
   subfile, so that `break /srcdir/list0.c:1' works as expected.
   start_subfile will ensure that this happens provided that we pass the
   concatenation of files.files[1].dir and files.files[1].name as the
   subfile's name.  */

static void
dwarf2_start_subfile (const char *filename, const char *dirname,
		      const char *comp_dir)
{
  char *copy = NULL;

  /* While reading the DIEs, we call start_symtab(DW_AT_name, DW_AT_comp_dir).
     `start_symtab' will always pass the contents of DW_AT_comp_dir as
     second argument to start_subfile.  To be consistent, we do the
     same here.  In order not to lose the line information directory,
     we concatenate it to the filename when it makes sense.
     Note that the Dwarf3 standard says (speaking of filenames in line
     information): ``The directory index is ignored for file names
     that represent full path names''.  Thus ignoring dirname in the
     `else' branch below isn't an issue.  */

  if (!IS_ABSOLUTE_PATH (filename) && dirname != NULL)
    {
      copy = concat (dirname, SLASH_STRING, filename, (char *)NULL);
      filename = copy;
    }

  start_subfile (filename, comp_dir);

  if (copy != NULL)
    xfree (copy);
}

/* Start a symtab for DWARF.
   NAME, COMP_DIR, LOW_PC are passed to start_symtab.  */

static void
dwarf2_start_symtab (struct dwarf2_cu *cu,
		     const char *name, const char *comp_dir, CORE_ADDR low_pc)
{
  start_symtab (name, comp_dir, low_pc);
  record_debugformat ("DWARF 2");
  record_producer (cu->producer);

  /* We assume that we're processing GCC output.  */
  processing_gcc_compilation = 2;

  cu->processing_has_namespace_info = 0;
}

static void
var_decode_location (struct attribute *attr, struct symbol *sym,
		     struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;

  /* NOTE drow/2003-01-30: There used to be a comment and some special
     code here to turn a symbol with DW_AT_external and a
     SYMBOL_VALUE_ADDRESS of 0 into a LOC_UNRESOLVED symbol.  This was
     necessary for platforms (maybe Alpha, certainly PowerPC GNU/Linux
     with some versions of binutils) where shared libraries could have
     relocations against symbols in their debug information - the
     minimal symbol would have the right address, but the debug info
     would not.  It's no longer necessary, because we will explicitly
     apply relocations when we read in the debug information now.  */

  /* A DW_AT_location attribute with no contents indicates that a
     variable has been optimized away.  */
  if (attr_form_is_block (attr) && DW_BLOCK (attr)->size == 0)
    {
      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;
      return;
    }

  /* Handle one degenerate form of location expression specially, to
     preserve GDB's previous behavior when section offsets are
     specified.  If this is just a DW_OP_addr or DW_OP_GNU_addr_index
     then mark this symbol as LOC_STATIC.  */

  if (attr_form_is_block (attr)
      && ((DW_BLOCK (attr)->data[0] == DW_OP_addr
	   && DW_BLOCK (attr)->size == 1 + cu_header->addr_size)
	  || (DW_BLOCK (attr)->data[0] == DW_OP_GNU_addr_index
	      && (DW_BLOCK (attr)->size
		  == 1 + leb128_size (&DW_BLOCK (attr)->data[1])))))
    {
      unsigned int dummy;

      if (DW_BLOCK (attr)->data[0] == DW_OP_addr)
	SYMBOL_VALUE_ADDRESS (sym) =
	  read_address (objfile->obfd, DW_BLOCK (attr)->data + 1, cu, &dummy);
      else
	SYMBOL_VALUE_ADDRESS (sym) =
	  read_addr_index_from_leb128 (cu, DW_BLOCK (attr)->data + 1, &dummy);
      SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;
      fixup_symbol_section (sym, objfile);
      SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets,
					      SYMBOL_SECTION (sym));
      return;
    }

  /* NOTE drow/2002-01-30: It might be worthwhile to have a static
     expression evaluator, and use LOC_COMPUTED only when necessary
     (i.e. when the value of a register or memory location is
     referenced, or a thread-local block, etc.).  Then again, it might
     not be worthwhile.  I'm assuming that it isn't unless performance
     or memory numbers show me otherwise.  */

  dwarf2_symbol_mark_computed (attr, sym, cu, 0);

  if (SYMBOL_COMPUTED_OPS (sym)->location_has_loclist)
    cu->has_loclist = 1;
}

/* Given a pointer to a DWARF information entry, figure out if we need
   to make a symbol table entry for it, and if so, create a new entry
   and return a pointer to it.
   If TYPE is NULL, determine symbol type from the die, otherwise
   used the passed type.
   If SPACE is not NULL, use it to hold the new symbol.  If it is
   NULL, allocate a new symbol on the objfile's obstack.  */

static struct symbol *
new_symbol_full (struct die_info *die, struct type *type, struct dwarf2_cu *cu,
		 struct symbol *space)
{
  struct objfile *objfile = cu->objfile;
  struct symbol *sym = NULL;
  const char *name;
  struct attribute *attr = NULL;
  struct attribute *attr2 = NULL;
  CORE_ADDR baseaddr;
  struct pending **list_to_add = NULL;

  int inlined_func = (die->tag == DW_TAG_inlined_subroutine);

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  name = dwarf2_name (die, cu);
  if (name)
    {
      const char *linkagename;
      int suppress_add = 0;

      if (space)
	sym = space;
      else
	sym = allocate_symbol (objfile);
      OBJSTAT (objfile, n_syms++);

      /* Cache this symbol's name and the name's demangled form (if any).  */
      SYMBOL_SET_LANGUAGE (sym, cu->language, &objfile->objfile_obstack);
      linkagename = dwarf2_physname (name, die, cu);
      SYMBOL_SET_NAMES (sym, linkagename, strlen (linkagename), 0, objfile);

      /* Fortran does not have mangling standard and the mangling does differ
	 between gfortran, iFort etc.  */
      if (cu->language == language_fortran
          && symbol_get_demangled_name (&(sym->ginfo)) == NULL)
	symbol_set_demangled_name (&(sym->ginfo),
				   dwarf2_full_name (name, die, cu),
	                           NULL);

      /* Default assumptions.
         Use the passed type or decode it from the die.  */
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
      SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;
      if (type != NULL)
	SYMBOL_TYPE (sym) = type;
      else
	SYMBOL_TYPE (sym) = die_type (die, cu);
      attr = dwarf2_attr (die,
			  inlined_func ? DW_AT_call_line : DW_AT_decl_line,
			  cu);
      if (attr)
	{
	  SYMBOL_LINE (sym) = DW_UNSND (attr);
	}

      attr = dwarf2_attr (die,
			  inlined_func ? DW_AT_call_file : DW_AT_decl_file,
			  cu);
      if (attr)
	{
	  int file_index = DW_UNSND (attr);

	  if (cu->line_header == NULL
	      || file_index > cu->line_header->num_file_names)
	    complaint (&symfile_complaints,
		       _("file index out of range"));
	  else if (file_index > 0)
	    {
	      struct file_entry *fe;

	      fe = &cu->line_header->file_names[file_index - 1];
	      SYMBOL_SYMTAB (sym) = fe->symtab;
	    }
	}

      switch (die->tag)
	{
	case DW_TAG_label:
	  attr = dwarf2_attr (die, DW_AT_low_pc, cu);
	  if (attr)
	    {
	      SYMBOL_VALUE_ADDRESS (sym) = DW_ADDR (attr) + baseaddr;
	    }
	  SYMBOL_TYPE (sym) = objfile_type (objfile)->builtin_core_addr;
	  SYMBOL_DOMAIN (sym) = LABEL_DOMAIN;
	  SYMBOL_ACLASS_INDEX (sym) = LOC_LABEL;
	  add_symbol_to_list (sym, cu->list_in_scope);
	  break;
	case DW_TAG_subprogram:
	  /* SYMBOL_BLOCK_VALUE (sym) will be filled in later by
	     finish_block.  */
	  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;
	  attr2 = dwarf2_attr (die, DW_AT_external, cu);
	  if ((attr2 && (DW_UNSND (attr2) != 0))
              || cu->language == language_ada)
	    {
              /* Subprograms marked external are stored as a global symbol.
                 Ada subprograms, whether marked external or not, are always
                 stored as a global symbol, because we want to be able to
                 access them globally.  For instance, we want to be able
                 to break on a nested subprogram without having to
                 specify the context.  */
	      list_to_add = &global_symbols;
	    }
	  else
	    {
	      list_to_add = cu->list_in_scope;
	    }
	  break;
	case DW_TAG_inlined_subroutine:
	  /* SYMBOL_BLOCK_VALUE (sym) will be filled in later by
	     finish_block.  */
	  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;
	  SYMBOL_INLINED (sym) = 1;
	  list_to_add = cu->list_in_scope;
	  break;
	case DW_TAG_template_value_param:
	  suppress_add = 1;
	  /* Fall through.  */
	case DW_TAG_constant:
	case DW_TAG_variable:
	case DW_TAG_member:
	  /* Compilation with minimal debug info may result in
	     variables with missing type entries.  Change the
	     misleading `void' type to something sensible.  */
	  if (TYPE_CODE (SYMBOL_TYPE (sym)) == TYPE_CODE_VOID)
	    SYMBOL_TYPE (sym)
	      = objfile_type (objfile)->nodebug_data_symbol;

	  attr = dwarf2_attr (die, DW_AT_const_value, cu);
	  /* In the case of DW_TAG_member, we should only be called for
	     static const members.  */
	  if (die->tag == DW_TAG_member)
	    {
	      /* dwarf2_add_field uses die_is_declaration,
		 so we do the same.  */
	      gdb_assert (die_is_declaration (die, cu));
	      gdb_assert (attr);
	    }
	  if (attr)
	    {
	      dwarf2_const_value (attr, sym, cu);
	      attr2 = dwarf2_attr (die, DW_AT_external, cu);
	      if (!suppress_add)
		{
		  if (attr2 && (DW_UNSND (attr2) != 0))
		    list_to_add = &global_symbols;
		  else
		    list_to_add = cu->list_in_scope;
		}
	      break;
	    }
	  attr = dwarf2_attr (die, DW_AT_location, cu);
	  if (attr)
	    {
	      var_decode_location (attr, sym, cu);
	      attr2 = dwarf2_attr (die, DW_AT_external, cu);

	      /* Fortran explicitly imports any global symbols to the local
		 scope by DW_TAG_common_block.  */
	      if (cu->language == language_fortran && die->parent
		  && die->parent->tag == DW_TAG_common_block)
		attr2 = NULL;

	      if (SYMBOL_CLASS (sym) == LOC_STATIC
		  && SYMBOL_VALUE_ADDRESS (sym) == 0
		  && !dwarf2_per_objfile->has_section_at_zero)
		{
		  /* When a static variable is eliminated by the linker,
		     the corresponding debug information is not stripped
		     out, but the variable address is set to null;
		     do not add such variables into symbol table.  */
		}
	      else if (attr2 && (DW_UNSND (attr2) != 0))
		{
		  /* Workaround gfortran PR debug/40040 - it uses
		     DW_AT_location for variables in -fPIC libraries which may
		     get overriden by other libraries/executable and get
		     a different address.  Resolve it by the minimal symbol
		     which may come from inferior's executable using copy
		     relocation.  Make this workaround only for gfortran as for
		     other compilers GDB cannot guess the minimal symbol
		     Fortran mangling kind.  */
		  if (cu->language == language_fortran && die->parent
		      && die->parent->tag == DW_TAG_module
		      && cu->producer
		      && strncmp (cu->producer, "GNU Fortran ", 12) == 0)
		    SYMBOL_ACLASS_INDEX (sym) = LOC_UNRESOLVED;

		  /* A variable with DW_AT_external is never static,
		     but it may be block-scoped.  */
		  list_to_add = (cu->list_in_scope == &file_symbols
				 ? &global_symbols : cu->list_in_scope);
		}
	      else
		list_to_add = cu->list_in_scope;
	    }
	  else
	    {
	      /* We do not know the address of this symbol.
	         If it is an external symbol and we have type information
	         for it, enter the symbol as a LOC_UNRESOLVED symbol.
	         The address of the variable will then be determined from
	         the minimal symbol table whenever the variable is
	         referenced.  */
	      attr2 = dwarf2_attr (die, DW_AT_external, cu);

	      /* Fortran explicitly imports any global symbols to the local
		 scope by DW_TAG_common_block.  */
	      if (cu->language == language_fortran && die->parent
		  && die->parent->tag == DW_TAG_common_block)
		{
		  /* SYMBOL_CLASS doesn't matter here because
		     read_common_block is going to reset it.  */
		  if (!suppress_add)
		    list_to_add = cu->list_in_scope;
		}
	      else if (attr2 && (DW_UNSND (attr2) != 0)
		       && dwarf2_attr (die, DW_AT_type, cu) != NULL)
		{
		  /* A variable with DW_AT_external is never static, but it
		     may be block-scoped.  */
		  list_to_add = (cu->list_in_scope == &file_symbols
				 ? &global_symbols : cu->list_in_scope);

		  SYMBOL_ACLASS_INDEX (sym) = LOC_UNRESOLVED;
		}
	      else if (!die_is_declaration (die, cu))
		{
		  /* Use the default LOC_OPTIMIZED_OUT class.  */
		  gdb_assert (SYMBOL_CLASS (sym) == LOC_OPTIMIZED_OUT);
		  if (!suppress_add)
		    list_to_add = cu->list_in_scope;
		}
	    }
	  break;
	case DW_TAG_formal_parameter:
	  /* If we are inside a function, mark this as an argument.  If
	     not, we might be looking at an argument to an inlined function
	     when we do not have enough information to show inlined frames;
	     pretend it's a local variable in that case so that the user can
	     still see it.  */
	  if (context_stack_depth > 0
	      && context_stack[context_stack_depth - 1].name != NULL)
	    SYMBOL_IS_ARGUMENT (sym) = 1;
	  attr = dwarf2_attr (die, DW_AT_location, cu);
	  if (attr)
	    {
	      var_decode_location (attr, sym, cu);
	    }
	  attr = dwarf2_attr (die, DW_AT_const_value, cu);
	  if (attr)
	    {
	      dwarf2_const_value (attr, sym, cu);
	    }

	  list_to_add = cu->list_in_scope;
	  break;
	case DW_TAG_unspecified_parameters:
	  /* From varargs functions; gdb doesn't seem to have any
	     interest in this information, so just ignore it for now.
	     (FIXME?) */
	  break;
	case DW_TAG_template_type_param:
	  suppress_add = 1;
	  /* Fall through.  */
	case DW_TAG_class_type:
	case DW_TAG_interface_type:
	case DW_TAG_structure_type:
	case DW_TAG_union_type:
	case DW_TAG_set_type:
	case DW_TAG_enumeration_type:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;

	  {
	    /* NOTE: carlton/2003-11-10: C++ and Java class symbols shouldn't
	       really ever be static objects: otherwise, if you try
	       to, say, break of a class's method and you're in a file
	       which doesn't mention that class, it won't work unless
	       the check for all static symbols in lookup_symbol_aux
	       saves you.  See the OtherFileClass tests in
	       gdb.c++/namespace.exp.  */

	    if (!suppress_add)
	      {
		list_to_add = (cu->list_in_scope == &file_symbols
			       && (cu->language == language_cplus
				   || cu->language == language_java)
			       ? &global_symbols : cu->list_in_scope);

		/* The semantics of C++ state that "struct foo {
		   ... }" also defines a typedef for "foo".  A Java
		   class declaration also defines a typedef for the
		   class.  */
		if (cu->language == language_cplus
		    || cu->language == language_java
		    || cu->language == language_ada)
		  {
		    /* The symbol's name is already allocated along
		       with this objfile, so we don't need to
		       duplicate it for the type.  */
		    if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
		      TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_SEARCH_NAME (sym);
		  }
	      }
	  }
	  break;
	case DW_TAG_typedef:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	  list_to_add = cu->list_in_scope;
	  break;
	case DW_TAG_base_type:
        case DW_TAG_subrange_type:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	  list_to_add = cu->list_in_scope;
	  break;
	case DW_TAG_enumerator:
	  attr = dwarf2_attr (die, DW_AT_const_value, cu);
	  if (attr)
	    {
	      dwarf2_const_value (attr, sym, cu);
	    }
	  {
	    /* NOTE: carlton/2003-11-10: See comment above in the
	       DW_TAG_class_type, etc. block.  */

	    list_to_add = (cu->list_in_scope == &file_symbols
			   && (cu->language == language_cplus
			       || cu->language == language_java)
			   ? &global_symbols : cu->list_in_scope);
	  }
	  break;
	case DW_TAG_namespace:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_TYPEDEF;
	  list_to_add = &global_symbols;
	  break;
	case DW_TAG_common_block:
	  SYMBOL_ACLASS_INDEX (sym) = LOC_COMMON_BLOCK;
	  SYMBOL_DOMAIN (sym) = COMMON_BLOCK_DOMAIN;
	  add_symbol_to_list (sym, cu->list_in_scope);
	  break;
	default:
	  /* Not a tag we recognize.  Hopefully we aren't processing
	     trash data, but since we must specifically ignore things
	     we don't recognize, there is nothing else we should do at
	     this point.  */
	  complaint (&symfile_complaints, _("unsupported tag: '%s'"),
		     dwarf_tag_name (die->tag));
	  break;
	}

      if (suppress_add)
	{
	  sym->hash_next = objfile->template_symbols;
	  objfile->template_symbols = sym;
	  list_to_add = NULL;
	}

      if (list_to_add != NULL)
	add_symbol_to_list (sym, list_to_add);

      /* For the benefit of old versions of GCC, check for anonymous
	 namespaces based on the demangled name.  */
      if (!cu->processing_has_namespace_info
	  && cu->language == language_cplus)
	cp_scan_for_anonymous_namespaces (sym, objfile);
    }
  return (sym);
}

/* A wrapper for new_symbol_full that always allocates a new symbol.  */

static struct symbol *
new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu)
{
  return new_symbol_full (die, type, cu, NULL);
}

/* Given an attr with a DW_FORM_dataN value in host byte order,
   zero-extend it as appropriate for the symbol's type.  The DWARF
   standard (v4) is not entirely clear about the meaning of using
   DW_FORM_dataN for a constant with a signed type, where the type is
   wider than the data.  The conclusion of a discussion on the DWARF
   list was that this is unspecified.  We choose to always zero-extend
   because that is the interpretation long in use by GCC.  */

static gdb_byte *
dwarf2_const_value_data (const struct attribute *attr, struct obstack *obstack,
			 struct dwarf2_cu *cu, LONGEST *value, int bits)
{
  struct objfile *objfile = cu->objfile;
  enum bfd_endian byte_order = bfd_big_endian (objfile->obfd) ?
				BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
  LONGEST l = DW_UNSND (attr);

  if (bits < sizeof (*value) * 8)
    {
      l &= ((LONGEST) 1 << bits) - 1;
      *value = l;
    }
  else if (bits == sizeof (*value) * 8)
    *value = l;
  else
    {
      gdb_byte *bytes = obstack_alloc (obstack, bits / 8);
      store_unsigned_integer (bytes, bits / 8, byte_order, l);
      return bytes;
    }

  return NULL;
}

/* Read a constant value from an attribute.  Either set *VALUE, or if
   the value does not fit in *VALUE, set *BYTES - either already
   allocated on the objfile obstack, or newly allocated on OBSTACK,
   or, set *BATON, if we translated the constant to a location
   expression.  */

static void
dwarf2_const_value_attr (const struct attribute *attr, struct type *type,
			 const char *name, struct obstack *obstack,
			 struct dwarf2_cu *cu,
			 LONGEST *value, const gdb_byte **bytes,
			 struct dwarf2_locexpr_baton **baton)
{
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
  struct dwarf_block *blk;
  enum bfd_endian byte_order = (bfd_big_endian (objfile->obfd) ?
				BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE);

  *value = 0;
  *bytes = NULL;
  *baton = NULL;

  switch (attr->form)
    {
    case DW_FORM_addr:
    case DW_FORM_GNU_addr_index:
      {
	gdb_byte *data;

	if (TYPE_LENGTH (type) != cu_header->addr_size)
	  dwarf2_const_value_length_mismatch_complaint (name,
							cu_header->addr_size,
							TYPE_LENGTH (type));
	/* Symbols of this form are reasonably rare, so we just
	   piggyback on the existing location code rather than writing
	   a new implementation of symbol_computed_ops.  */
	*baton = obstack_alloc (obstack, sizeof (struct dwarf2_locexpr_baton));
	(*baton)->per_cu = cu->per_cu;
	gdb_assert ((*baton)->per_cu);

	(*baton)->size = 2 + cu_header->addr_size;
	data = obstack_alloc (obstack, (*baton)->size);
	(*baton)->data = data;

	data[0] = DW_OP_addr;
	store_unsigned_integer (&data[1], cu_header->addr_size,
				byte_order, DW_ADDR (attr));
	data[cu_header->addr_size + 1] = DW_OP_stack_value;
      }
      break;
    case DW_FORM_string:
    case DW_FORM_strp:
    case DW_FORM_GNU_str_index:
    case DW_FORM_GNU_strp_alt:
      /* DW_STRING is already allocated on the objfile obstack, point
	 directly to it.  */
      *bytes = (const gdb_byte *) DW_STRING (attr);
      break;
    case DW_FORM_block1:
    case DW_FORM_block2:
    case DW_FORM_block4:
    case DW_FORM_block:
    case DW_FORM_exprloc:
      blk = DW_BLOCK (attr);
      if (TYPE_LENGTH (type) != blk->size)
	dwarf2_const_value_length_mismatch_complaint (name, blk->size,
						      TYPE_LENGTH (type));
      *bytes = blk->data;
      break;

      /* The DW_AT_const_value attributes are supposed to carry the
	 symbol's value "represented as it would be on the target
	 architecture."  By the time we get here, it's already been
	 converted to host endianness, so we just need to sign- or
	 zero-extend it as appropriate.  */
    case DW_FORM_data1:
      *bytes = dwarf2_const_value_data (attr, obstack, cu, value, 8);
      break;
    case DW_FORM_data2:
      *bytes = dwarf2_const_value_data (attr, obstack, cu, value, 16);
      break;
    case DW_FORM_data4:
      *bytes = dwarf2_const_value_data (attr, obstack, cu, value, 32);
      break;
    case DW_FORM_data8:
      *bytes = dwarf2_const_value_data (attr, obstack, cu, value, 64);
      break;

    case DW_FORM_sdata:
      *value = DW_SND (attr);
      break;

    case DW_FORM_udata:
      *value = DW_UNSND (attr);
      break;

    default:
      complaint (&symfile_complaints,
		 _("unsupported const value attribute form: '%s'"),
		 dwarf_form_name (attr->form));
      *value = 0;
      break;
    }
}


/* Copy constant value from an attribute to a symbol.  */

static void
dwarf2_const_value (const struct attribute *attr, struct symbol *sym,
		    struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
  LONGEST value;
  const gdb_byte *bytes;
  struct dwarf2_locexpr_baton *baton;

  dwarf2_const_value_attr (attr, SYMBOL_TYPE (sym),
			   SYMBOL_PRINT_NAME (sym),
			   &objfile->objfile_obstack, cu,
			   &value, &bytes, &baton);

  if (baton != NULL)
    {
      SYMBOL_LOCATION_BATON (sym) = baton;
      SYMBOL_ACLASS_INDEX (sym) = dwarf2_locexpr_index;
    }
  else if (bytes != NULL)
     {
      SYMBOL_VALUE_BYTES (sym) = bytes;
      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST_BYTES;
    }
  else
    {
      SYMBOL_VALUE (sym) = value;
      SYMBOL_ACLASS_INDEX (sym) = LOC_CONST;
    }
}

/* Return the type of the die in question using its DW_AT_type attribute.  */

static struct type *
die_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *type_attr;

  type_attr = dwarf2_attr (die, DW_AT_type, cu);
  if (!type_attr)
    {
      /* A missing DW_AT_type represents a void type.  */
      return objfile_type (cu->objfile)->builtin_void;
    }

  return lookup_die_type (die, type_attr, cu);
}

/* True iff CU's producer generates GNAT Ada auxiliary information
   that allows to find parallel types through that information instead
   of having to do expensive parallel lookups by type name.  */

static int
need_gnat_info (struct dwarf2_cu *cu)
{
  /* FIXME: brobecker/2010-10-12: As of now, only the AdaCore version
     of GNAT produces this auxiliary information, without any indication
     that it is produced.  Part of enhancing the FSF version of GNAT
     to produce that information will be to put in place an indicator
     that we can use in order to determine whether the descriptive type
     info is available or not.  One suggestion that has been made is
     to use a new attribute, attached to the CU die.  For now, assume
     that the descriptive type info is not available.  */
  return 0;
}

/* Return the auxiliary type of the die in question using its
   DW_AT_GNAT_descriptive_type attribute.  Returns NULL if the
   attribute is not present.  */

static struct type *
die_descriptive_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *type_attr;

  type_attr = dwarf2_attr (die, DW_AT_GNAT_descriptive_type, cu);
  if (!type_attr)
    return NULL;

  return lookup_die_type (die, type_attr, cu);
}

/* If DIE has a descriptive_type attribute, then set the TYPE's
   descriptive type accordingly.  */

static void
set_descriptive_type (struct type *type, struct die_info *die,
		      struct dwarf2_cu *cu)
{
  struct type *descriptive_type = die_descriptive_type (die, cu);

  if (descriptive_type)
    {
      ALLOCATE_GNAT_AUX_TYPE (type);
      TYPE_DESCRIPTIVE_TYPE (type) = descriptive_type;
    }
}

/* Return the containing type of the die in question using its
   DW_AT_containing_type attribute.  */

static struct type *
die_containing_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *type_attr;

  type_attr = dwarf2_attr (die, DW_AT_containing_type, cu);
  if (!type_attr)
    error (_("Dwarf Error: Problem turning containing type into gdb type "
	     "[in module %s]"), objfile_name (cu->objfile));

  return lookup_die_type (die, type_attr, cu);
}

/* Return an error marker type to use for the ill formed type in DIE/CU.  */

static struct type *
build_error_marker_type (struct dwarf2_cu *cu, struct die_info *die)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  char *message, *saved;

  message = xstrprintf (_("<unknown type in %s, CU 0x%x, DIE 0x%x>"),
			objfile_name (objfile),
			cu->header.offset.sect_off,
			die->offset.sect_off);
  saved = obstack_copy0 (&objfile->objfile_obstack,
			 message, strlen (message));
  xfree (message);

  return init_type (TYPE_CODE_ERROR, 0, 0, saved, objfile);
}

/* Look up the type of DIE in CU using its type attribute ATTR.
   ATTR must be one of: DW_AT_type, DW_AT_GNAT_descriptive_type,
   DW_AT_containing_type.
   If there is no type substitute an error marker.  */

static struct type *
lookup_die_type (struct die_info *die, const struct attribute *attr,
		 struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct type *this_type;

  gdb_assert (attr->name == DW_AT_type
	      || attr->name == DW_AT_GNAT_descriptive_type
	      || attr->name == DW_AT_containing_type);

  /* First see if we have it cached.  */

  if (attr->form == DW_FORM_GNU_ref_alt)
    {
      struct dwarf2_per_cu_data *per_cu;
      sect_offset offset = dwarf2_get_ref_die_offset (attr);

      per_cu = dwarf2_find_containing_comp_unit (offset, 1, cu->objfile);
      this_type = get_die_type_at_offset (offset, per_cu);
    }
  else if (attr_form_is_ref (attr))
    {
      sect_offset offset = dwarf2_get_ref_die_offset (attr);

      this_type = get_die_type_at_offset (offset, cu->per_cu);
    }
  else if (attr->form == DW_FORM_ref_sig8)
    {
      ULONGEST signature = DW_SIGNATURE (attr);

      return get_signatured_type (die, signature, cu);
    }
  else
    {
      complaint (&symfile_complaints,
		 _("Dwarf Error: Bad type attribute %s in DIE"
		   " at 0x%x [in module %s]"),
		 dwarf_attr_name (attr->name), die->offset.sect_off,
		 objfile_name (objfile));
      return build_error_marker_type (cu, die);
    }

  /* If not cached we need to read it in.  */

  if (this_type == NULL)
    {
      struct die_info *type_die = NULL;
      struct dwarf2_cu *type_cu = cu;

      if (attr_form_is_ref (attr))
	type_die = follow_die_ref (die, attr, &type_cu);
      if (type_die == NULL)
	return build_error_marker_type (cu, die);
      /* If we find the type now, it's probably because the type came
	 from an inter-CU reference and the type's CU got expanded before
	 ours.  */
      this_type = read_type_die (type_die, type_cu);
    }

  /* If we still don't have a type use an error marker.  */

  if (this_type == NULL)
    return build_error_marker_type (cu, die);

  return this_type;
}

/* Return the type in DIE, CU.
   Returns NULL for invalid types.

   This first does a lookup in die_type_hash,
   and only reads the die in if necessary.

   NOTE: This can be called when reading in partial or full symbols.  */

static struct type *
read_type_die (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *this_type;

  this_type = get_die_type (die, cu);
  if (this_type)
    return this_type;

  return read_type_die_1 (die, cu);
}

/* Read the type in DIE, CU.
   Returns NULL for invalid types.  */

static struct type *
read_type_die_1 (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *this_type = NULL;

  switch (die->tag)
    {
    case DW_TAG_class_type:
    case DW_TAG_interface_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
      this_type = read_structure_type (die, cu);
      break;
    case DW_TAG_enumeration_type:
      this_type = read_enumeration_type (die, cu);
      break;
    case DW_TAG_subprogram:
    case DW_TAG_subroutine_type:
    case DW_TAG_inlined_subroutine:
      this_type = read_subroutine_type (die, cu);
      break;
    case DW_TAG_array_type:
      this_type = read_array_type (die, cu);
      break;
    case DW_TAG_set_type:
      this_type = read_set_type (die, cu);
      break;
    case DW_TAG_pointer_type:
      this_type = read_tag_pointer_type (die, cu);
      break;
    case DW_TAG_ptr_to_member_type:
      this_type = read_tag_ptr_to_member_type (die, cu);
      break;
    case DW_TAG_reference_type:
      this_type = read_tag_reference_type (die, cu);
      break;
    case DW_TAG_const_type:
      this_type = read_tag_const_type (die, cu);
      break;
    case DW_TAG_volatile_type:
      this_type = read_tag_volatile_type (die, cu);
      break;
    case DW_TAG_restrict_type:
      this_type = read_tag_restrict_type (die, cu);
      break;
    case DW_TAG_string_type:
      this_type = read_tag_string_type (die, cu);
      break;
    case DW_TAG_typedef:
      this_type = read_typedef (die, cu);
      break;
    case DW_TAG_subrange_type:
      this_type = read_subrange_type (die, cu);
      break;
    case DW_TAG_base_type:
      this_type = read_base_type (die, cu);
      break;
    case DW_TAG_unspecified_type:
      this_type = read_unspecified_type (die, cu);
      break;
    case DW_TAG_namespace:
      this_type = read_namespace_type (die, cu);
      break;
    case DW_TAG_module:
      this_type = read_module_type (die, cu);
      break;
    default:
      complaint (&symfile_complaints,
		 _("unexpected tag in read_type_die: '%s'"),
		 dwarf_tag_name (die->tag));
      break;
    }

  return this_type;
}

/* See if we can figure out if the class lives in a namespace.  We do
   this by looking for a member function; its demangled name will
   contain namespace info, if there is any.
   Return the computed name or NULL.
   Space for the result is allocated on the objfile's obstack.
   This is the full-die version of guess_partial_die_structure_name.
   In this case we know DIE has no useful parent.  */

static char *
guess_full_die_structure_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *spec_die;
  struct dwarf2_cu *spec_cu;
  struct die_info *child;

  spec_cu = cu;
  spec_die = die_specification (die, &spec_cu);
  if (spec_die != NULL)
    {
      die = spec_die;
      cu = spec_cu;
    }

  for (child = die->child;
       child != NULL;
       child = child->sibling)
    {
      if (child->tag == DW_TAG_subprogram)
	{
	  struct attribute *attr;

	  attr = dwarf2_attr (child, DW_AT_linkage_name, cu);
	  if (attr == NULL)
	    attr = dwarf2_attr (child, DW_AT_MIPS_linkage_name, cu);
	  if (attr != NULL)
	    {
	      char *actual_name
		= language_class_name_from_physname (cu->language_defn,
						     DW_STRING (attr));
	      char *name = NULL;

	      if (actual_name != NULL)
		{
		  const char *die_name = dwarf2_name (die, cu);

		  if (die_name != NULL
		      && strcmp (die_name, actual_name) != 0)
		    {
		      /* Strip off the class name from the full name.
			 We want the prefix.  */
		      int die_name_len = strlen (die_name);
		      int actual_name_len = strlen (actual_name);

		      /* Test for '::' as a sanity check.  */
		      if (actual_name_len > die_name_len + 2
			  && actual_name[actual_name_len
					 - die_name_len - 1] == ':')
			name =
			  obstack_copy0 (&cu->objfile->objfile_obstack,
					 actual_name,
					 actual_name_len - die_name_len - 2);
		    }
		}
	      xfree (actual_name);
	      return name;
	    }
	}
    }

  return NULL;
}

/* GCC might emit a nameless typedef that has a linkage name.  Determine the
   prefix part in such case.  See
   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */

static char *
anonymous_struct_prefix (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;
  char *base;

  if (die->tag != DW_TAG_class_type && die->tag != DW_TAG_interface_type
      && die->tag != DW_TAG_structure_type && die->tag != DW_TAG_union_type)
    return NULL;

  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr != NULL && DW_STRING (attr) != NULL)
    return NULL;

  attr = dwarf2_attr (die, DW_AT_linkage_name, cu);
  if (attr == NULL)
    attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);
  if (attr == NULL || DW_STRING (attr) == NULL)
    return NULL;

  /* dwarf2_name had to be already called.  */
  gdb_assert (DW_STRING_IS_CANONICAL (attr));

  /* Strip the base name, keep any leading namespaces/classes.  */
  base = strrchr (DW_STRING (attr), ':');
  if (base == NULL || base == DW_STRING (attr) || base[-1] != ':')
    return "";

  return obstack_copy0 (&cu->objfile->objfile_obstack,
			DW_STRING (attr), &base[-1] - DW_STRING (attr));
}

/* Return the name of the namespace/class that DIE is defined within,
   or "" if we can't tell.  The caller should not xfree the result.

   For example, if we're within the method foo() in the following
   code:

   namespace N {
     class C {
       void foo () {
       }
     };
   }

   then determine_prefix on foo's die will return "N::C".  */

static const char *
determine_prefix (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *parent, *spec_die;
  struct dwarf2_cu *spec_cu;
  struct type *parent_type;
  char *retval;

  if (cu->language != language_cplus && cu->language != language_java
      && cu->language != language_fortran)
    return "";

  retval = anonymous_struct_prefix (die, cu);
  if (retval)
    return retval;

  /* We have to be careful in the presence of DW_AT_specification.
     For example, with GCC 3.4, given the code

     namespace N {
       void foo() {
	 // Definition of N::foo.
       }
     }

     then we'll have a tree of DIEs like this:

     1: DW_TAG_compile_unit
       2: DW_TAG_namespace        // N
	 3: DW_TAG_subprogram     // declaration of N::foo
       4: DW_TAG_subprogram       // definition of N::foo
	    DW_AT_specification   // refers to die #3

     Thus, when processing die #4, we have to pretend that we're in
     the context of its DW_AT_specification, namely the contex of die
     #3.  */
  spec_cu = cu;
  spec_die = die_specification (die, &spec_cu);
  if (spec_die == NULL)
    parent = die->parent;
  else
    {
      parent = spec_die->parent;
      cu = spec_cu;
    }

  if (parent == NULL)
    return "";
  else if (parent->building_fullname)
    {
      const char *name;
      const char *parent_name;

      /* It has been seen on RealView 2.2 built binaries,
	 DW_TAG_template_type_param types actually _defined_ as
	 children of the parent class:

	 enum E {};
	 template class <class Enum> Class{};
	 Class<enum E> class_e;

         1: DW_TAG_class_type (Class)
           2: DW_TAG_enumeration_type (E)
             3: DW_TAG_enumerator (enum1:0)
             3: DW_TAG_enumerator (enum2:1)
             ...
           2: DW_TAG_template_type_param
              DW_AT_type  DW_FORM_ref_udata (E)

	 Besides being broken debug info, it can put GDB into an
	 infinite loop.  Consider:

	 When we're building the full name for Class<E>, we'll start
	 at Class, and go look over its template type parameters,
	 finding E.  We'll then try to build the full name of E, and
	 reach here.  We're now trying to build the full name of E,
	 and look over the parent DIE for containing scope.  In the
	 broken case, if we followed the parent DIE of E, we'd again
	 find Class, and once again go look at its template type
	 arguments, etc., etc.  Simply don't consider such parent die
	 as source-level parent of this die (it can't be, the language
	 doesn't allow it), and break the loop here.  */
      name = dwarf2_name (die, cu);
      parent_name = dwarf2_name (parent, cu);
      complaint (&symfile_complaints,
		 _("template param type '%s' defined within parent '%s'"),
		 name ? name : "<unknown>",
		 parent_name ? parent_name : "<unknown>");
      return "";
    }
  else
    switch (parent->tag)
      {
      case DW_TAG_namespace:
	parent_type = read_type_die (parent, cu);
	/* GCC 4.0 and 4.1 had a bug (PR c++/28460) where they generated bogus
	   DW_TAG_namespace DIEs with a name of "::" for the global namespace.
	   Work around this problem here.  */
	if (cu->language == language_cplus
	    && strcmp (TYPE_TAG_NAME (parent_type), "::") == 0)
	  return "";
	/* We give a name to even anonymous namespaces.  */
	return TYPE_TAG_NAME (parent_type);
      case DW_TAG_class_type:
      case DW_TAG_interface_type:
      case DW_TAG_structure_type:
      case DW_TAG_union_type:
      case DW_TAG_module:
	parent_type = read_type_die (parent, cu);
	if (TYPE_TAG_NAME (parent_type) != NULL)
	  return TYPE_TAG_NAME (parent_type);
	else
	  /* An anonymous structure is only allowed non-static data
	     members; no typedefs, no member functions, et cetera.
	     So it does not need a prefix.  */
	  return "";
      case DW_TAG_compile_unit:
      case DW_TAG_partial_unit:
	/* gcc-4.5 -gdwarf-4 can drop the enclosing namespace.  Cope.  */
	if (cu->language == language_cplus
	    && !VEC_empty (dwarf2_section_info_def, dwarf2_per_objfile->types)
	    && die->child != NULL
	    && (die->tag == DW_TAG_class_type
		|| die->tag == DW_TAG_structure_type
		|| die->tag == DW_TAG_union_type))
	  {
	    char *name = guess_full_die_structure_name (die, cu);
	    if (name != NULL)
	      return name;
	  }
	return "";
      default:
	return determine_prefix (parent, cu);
      }
}

/* Return a newly-allocated string formed by concatenating PREFIX and SUFFIX
   with appropriate separator.  If PREFIX or SUFFIX is NULL or empty, then
   simply copy the SUFFIX or PREFIX, respectively.  If OBS is non-null, perform
   an obconcat, otherwise allocate storage for the result.  The CU argument is
   used to determine the language and hence, the appropriate separator.  */

#define MAX_SEP_LEN 7  /* strlen ("__") + strlen ("_MOD_")  */

static char *
typename_concat (struct obstack *obs, const char *prefix, const char *suffix,
                 int physname, struct dwarf2_cu *cu)
{
  const char *lead = "";
  const char *sep;

  if (suffix == NULL || suffix[0] == '\0'
      || prefix == NULL || prefix[0] == '\0')
    sep = "";
  else if (cu->language == language_java)
    sep = ".";
  else if (cu->language == language_fortran && physname)
    {
      /* This is gfortran specific mangling.  Normally DW_AT_linkage_name or
	 DW_AT_MIPS_linkage_name is preferred and used instead.  */

      lead = "__";
      sep = "_MOD_";
    }
  else
    sep = "::";

  if (prefix == NULL)
    prefix = "";
  if (suffix == NULL)
    suffix = "";

  if (obs == NULL)
    {
      char *retval
	= xmalloc (strlen (prefix) + MAX_SEP_LEN + strlen (suffix) + 1);

      strcpy (retval, lead);
      strcat (retval, prefix);
      strcat (retval, sep);
      strcat (retval, suffix);
      return retval;
    }
  else
    {
      /* We have an obstack.  */
      return obconcat (obs, lead, prefix, sep, suffix, (char *) NULL);
    }
}

/* Return sibling of die, NULL if no sibling.  */

static struct die_info *
sibling_die (struct die_info *die)
{
  return die->sibling;
}

/* Get name of a die, return NULL if not found.  */

static const char *
dwarf2_canonicalize_name (const char *name, struct dwarf2_cu *cu,
			  struct obstack *obstack)
{
  if (name && cu->language == language_cplus)
    {
      char *canon_name = cp_canonicalize_string (name);

      if (canon_name != NULL)
	{
	  if (strcmp (canon_name, name) != 0)
	    name = obstack_copy0 (obstack, canon_name, strlen (canon_name));
	  xfree (canon_name);
	}
    }

  return name;
}

/* Get name of a die, return NULL if not found.  */

static const char *
dwarf2_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_name, cu);
  if ((!attr || !DW_STRING (attr))
      && die->tag != DW_TAG_class_type
      && die->tag != DW_TAG_interface_type
      && die->tag != DW_TAG_structure_type
      && die->tag != DW_TAG_union_type)
    return NULL;

  switch (die->tag)
    {
    case DW_TAG_compile_unit:
    case DW_TAG_partial_unit:
      /* Compilation units have a DW_AT_name that is a filename, not
	 a source language identifier.  */
    case DW_TAG_enumeration_type:
    case DW_TAG_enumerator:
      /* These tags always have simple identifiers already; no need
	 to canonicalize them.  */
      return DW_STRING (attr);

    case DW_TAG_subprogram:
      /* Java constructors will all be named "<init>", so return
	 the class name when we see this special case.  */
      if (cu->language == language_java
	  && DW_STRING (attr) != NULL
	  && strcmp (DW_STRING (attr), "<init>") == 0)
	{
	  struct dwarf2_cu *spec_cu = cu;
	  struct die_info *spec_die;

	  /* GCJ will output '<init>' for Java constructor names.
	     For this special case, return the name of the parent class.  */

	  /* GCJ may output suprogram DIEs with AT_specification set.
	     If so, use the name of the specified DIE.  */
	  spec_die = die_specification (die, &spec_cu);
	  if (spec_die != NULL)
	    return dwarf2_name (spec_die, spec_cu);

	  do
	    {
	      die = die->parent;
	      if (die->tag == DW_TAG_class_type)
		return dwarf2_name (die, cu);
	    }
	  while (die->tag != DW_TAG_compile_unit
		 && die->tag != DW_TAG_partial_unit);
	}
      break;

    case DW_TAG_class_type:
    case DW_TAG_interface_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
      /* Some GCC versions emit spurious DW_AT_name attributes for unnamed
	 structures or unions.  These were of the form "._%d" in GCC 4.1,
	 or simply "<anonymous struct>" or "<anonymous union>" in GCC 4.3
	 and GCC 4.4.  We work around this problem by ignoring these.  */
      if (attr && DW_STRING (attr)
	  && (strncmp (DW_STRING (attr), "._", 2) == 0
	      || strncmp (DW_STRING (attr), "<anonymous", 10) == 0))
	return NULL;

      /* GCC might emit a nameless typedef that has a linkage name.  See
	 http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */
      if (!attr || DW_STRING (attr) == NULL)
	{
	  char *demangled = NULL;

	  attr = dwarf2_attr (die, DW_AT_linkage_name, cu);
	  if (attr == NULL)
	    attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);

	  if (attr == NULL || DW_STRING (attr) == NULL)
	    return NULL;

	  /* Avoid demangling DW_STRING (attr) the second time on a second
	     call for the same DIE.  */
	  if (!DW_STRING_IS_CANONICAL (attr))
	    demangled = gdb_demangle (DW_STRING (attr), DMGL_TYPES);

	  if (demangled)
	    {
	      char *base;

	      /* FIXME: we already did this for the partial symbol... */
	      DW_STRING (attr) = obstack_copy0 (&cu->objfile->objfile_obstack,
						demangled, strlen (demangled));
	      DW_STRING_IS_CANONICAL (attr) = 1;
	      xfree (demangled);

	      /* Strip any leading namespaces/classes, keep only the base name.
		 DW_AT_name for named DIEs does not contain the prefixes.  */
	      base = strrchr (DW_STRING (attr), ':');
	      if (base && base > DW_STRING (attr) && base[-1] == ':')
		return &base[1];
	      else
		return DW_STRING (attr);
	    }
	}
      break;

    default:
      break;
    }

  if (!DW_STRING_IS_CANONICAL (attr))
    {
      DW_STRING (attr)
	= dwarf2_canonicalize_name (DW_STRING (attr), cu,
				    &cu->objfile->objfile_obstack);
      DW_STRING_IS_CANONICAL (attr) = 1;
    }
  return DW_STRING (attr);
}

/* Return the die that this die in an extension of, or NULL if there
   is none.  *EXT_CU is the CU containing DIE on input, and the CU
   containing the return value on output.  */

static struct die_info *
dwarf2_extension (struct die_info *die, struct dwarf2_cu **ext_cu)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_extension, *ext_cu);
  if (attr == NULL)
    return NULL;

  return follow_die_ref (die, attr, ext_cu);
}

/* Convert a DIE tag into its string name.  */

static const char *
dwarf_tag_name (unsigned tag)
{
  const char *name = get_DW_TAG_name (tag);

  if (name == NULL)
    return "DW_TAG_<unknown>";

  return name;
}

/* Convert a DWARF attribute code into its string name.  */

static const char *
dwarf_attr_name (unsigned attr)
{
  const char *name;

#ifdef MIPS /* collides with DW_AT_HP_block_index */
  if (attr == DW_AT_MIPS_fde)
    return "DW_AT_MIPS_fde";
#else
  if (attr == DW_AT_HP_block_index)
    return "DW_AT_HP_block_index";
#endif

  name = get_DW_AT_name (attr);

  if (name == NULL)
    return "DW_AT_<unknown>";

  return name;
}

/* Convert a DWARF value form code into its string name.  */

static const char *
dwarf_form_name (unsigned form)
{
  const char *name = get_DW_FORM_name (form);

  if (name == NULL)
    return "DW_FORM_<unknown>";

  return name;
}

static char *
dwarf_bool_name (unsigned mybool)
{
  if (mybool)
    return "TRUE";
  else
    return "FALSE";
}

/* Convert a DWARF type code into its string name.  */

static const char *
dwarf_type_encoding_name (unsigned enc)
{
  const char *name = get_DW_ATE_name (enc);

  if (name == NULL)
    return "DW_ATE_<unknown>";

  return name;
}

static void
dump_die_shallow (struct ui_file *f, int indent, struct die_info *die)
{
  unsigned int i;

  print_spaces (indent, f);
  fprintf_unfiltered (f, "Die: %s (abbrev %d, offset 0x%x)\n",
	   dwarf_tag_name (die->tag), die->abbrev, die->offset.sect_off);

  if (die->parent != NULL)
    {
      print_spaces (indent, f);
      fprintf_unfiltered (f, "  parent at offset: 0x%x\n",
			  die->parent->offset.sect_off);
    }

  print_spaces (indent, f);
  fprintf_unfiltered (f, "  has children: %s\n",
	   dwarf_bool_name (die->child != NULL));

  print_spaces (indent, f);
  fprintf_unfiltered (f, "  attributes:\n");

  for (i = 0; i < die->num_attrs; ++i)
    {
      print_spaces (indent, f);
      fprintf_unfiltered (f, "    %s (%s) ",
	       dwarf_attr_name (die->attrs[i].name),
	       dwarf_form_name (die->attrs[i].form));

      switch (die->attrs[i].form)
	{
	case DW_FORM_addr:
	case DW_FORM_GNU_addr_index:
	  fprintf_unfiltered (f, "address: ");
	  fputs_filtered (hex_string (DW_ADDR (&die->attrs[i])), f);
	  break;
	case DW_FORM_block2:
	case DW_FORM_block4:
	case DW_FORM_block:
	case DW_FORM_block1:
	  fprintf_unfiltered (f, "block: size %s",
			      pulongest (DW_BLOCK (&die->attrs[i])->size));
	  break;
	case DW_FORM_exprloc:
	  fprintf_unfiltered (f, "expression: size %s",
			      pulongest (DW_BLOCK (&die->attrs[i])->size));
	  break;
	case DW_FORM_ref_addr:
	  fprintf_unfiltered (f, "ref address: ");
	  fputs_filtered (hex_string (DW_UNSND (&die->attrs[i])), f);
	  break;
	case DW_FORM_GNU_ref_alt:
	  fprintf_unfiltered (f, "alt ref address: ");
	  fputs_filtered (hex_string (DW_UNSND (&die->attrs[i])), f);
	  break;
	case DW_FORM_ref1:
	case DW_FORM_ref2:
	case DW_FORM_ref4:
	case DW_FORM_ref8:
	case DW_FORM_ref_udata:
	  fprintf_unfiltered (f, "constant ref: 0x%lx (adjusted)",
			      (long) (DW_UNSND (&die->attrs[i])));
	  break;
	case DW_FORM_data1:
	case DW_FORM_data2:
	case DW_FORM_data4:
	case DW_FORM_data8:
	case DW_FORM_udata:
	case DW_FORM_sdata:
	  fprintf_unfiltered (f, "constant: %s",
			      pulongest (DW_UNSND (&die->attrs[i])));
	  break;
	case DW_FORM_sec_offset:
	  fprintf_unfiltered (f, "section offset: %s",
			      pulongest (DW_UNSND (&die->attrs[i])));
	  break;
	case DW_FORM_ref_sig8:
	  fprintf_unfiltered (f, "signature: %s",
			      hex_string (DW_SIGNATURE (&die->attrs[i])));
	  break;
	case DW_FORM_string:
	case DW_FORM_strp:
	case DW_FORM_GNU_str_index:
	case DW_FORM_GNU_strp_alt:
	  fprintf_unfiltered (f, "string: \"%s\" (%s canonicalized)",
		   DW_STRING (&die->attrs[i])
		   ? DW_STRING (&die->attrs[i]) : "",
		   DW_STRING_IS_CANONICAL (&die->attrs[i]) ? "is" : "not");
	  break;
	case DW_FORM_flag:
	  if (DW_UNSND (&die->attrs[i]))
	    fprintf_unfiltered (f, "flag: TRUE");
	  else
	    fprintf_unfiltered (f, "flag: FALSE");
	  break;
	case DW_FORM_flag_present:
	  fprintf_unfiltered (f, "flag: TRUE");
	  break;
	case DW_FORM_indirect:
	  /* The reader will have reduced the indirect form to
	     the "base form" so this form should not occur.  */
	  fprintf_unfiltered (f, 
			      "unexpected attribute form: DW_FORM_indirect");
	  break;
	default:
	  fprintf_unfiltered (f, "unsupported attribute form: %d.",
		   die->attrs[i].form);
	  break;
	}
      fprintf_unfiltered (f, "\n");
    }
}

static void
dump_die_for_error (struct die_info *die)
{
  dump_die_shallow (gdb_stderr, 0, die);
}

static void
dump_die_1 (struct ui_file *f, int level, int max_level, struct die_info *die)
{
  int indent = level * 4;

  gdb_assert (die != NULL);

  if (level >= max_level)
    return;

  dump_die_shallow (f, indent, die);

  if (die->child != NULL)
    {
      print_spaces (indent, f);
      fprintf_unfiltered (f, "  Children:");
      if (level + 1 < max_level)
	{
	  fprintf_unfiltered (f, "\n");
	  dump_die_1 (f, level + 1, max_level, die->child);
	}
      else
	{
	  fprintf_unfiltered (f,
			      " [not printed, max nesting level reached]\n");
	}
    }

  if (die->sibling != NULL && level > 0)
    {
      dump_die_1 (f, level, max_level, die->sibling);
    }
}

/* This is called from the pdie macro in gdbinit.in.
   It's not static so gcc will keep a copy callable from gdb.  */

void
dump_die (struct die_info *die, int max_level)
{
  dump_die_1 (gdb_stdlog, 0, max_level, die);
}

static void
store_in_ref_table (struct die_info *die, struct dwarf2_cu *cu)
{
  void **slot;

  slot = htab_find_slot_with_hash (cu->die_hash, die, die->offset.sect_off,
				   INSERT);

  *slot = die;
}

/* Return DIE offset of ATTR.  Return 0 with complaint if ATTR is not of the
   required kind.  */

static sect_offset
dwarf2_get_ref_die_offset (const struct attribute *attr)
{
  sect_offset retval = { DW_UNSND (attr) };

  if (attr_form_is_ref (attr))
    return retval;

  retval.sect_off = 0;
  complaint (&symfile_complaints,
	     _("unsupported die ref attribute form: '%s'"),
	     dwarf_form_name (attr->form));
  return retval;
}

/* Return the constant value held by ATTR.  Return DEFAULT_VALUE if
 * the value held by the attribute is not constant.  */

static LONGEST
dwarf2_get_attr_constant_value (const struct attribute *attr, int default_value)
{
  if (attr->form == DW_FORM_sdata)
    return DW_SND (attr);
  else if (attr->form == DW_FORM_udata
           || attr->form == DW_FORM_data1
           || attr->form == DW_FORM_data2
           || attr->form == DW_FORM_data4
           || attr->form == DW_FORM_data8)
    return DW_UNSND (attr);
  else
    {
      complaint (&symfile_complaints,
		 _("Attribute value is not a constant (%s)"),
                 dwarf_form_name (attr->form));
      return default_value;
    }
}

/* Follow reference or signature attribute ATTR of SRC_DIE.
   On entry *REF_CU is the CU of SRC_DIE.
   On exit *REF_CU is the CU of the result.  */

static struct die_info *
follow_die_ref_or_sig (struct die_info *src_die, const struct attribute *attr,
		       struct dwarf2_cu **ref_cu)
{
  struct die_info *die;

  if (attr_form_is_ref (attr))
    die = follow_die_ref (src_die, attr, ref_cu);
  else if (attr->form == DW_FORM_ref_sig8)
    die = follow_die_sig (src_die, attr, ref_cu);
  else
    {
      dump_die_for_error (src_die);
      error (_("Dwarf Error: Expected reference attribute [in module %s]"),
	     objfile_name ((*ref_cu)->objfile));
    }

  return die;
}

/* Follow reference OFFSET.
   On entry *REF_CU is the CU of the source die referencing OFFSET.
   On exit *REF_CU is the CU of the result.
   Returns NULL if OFFSET is invalid.  */

static struct die_info *
follow_die_offset (sect_offset offset, int offset_in_dwz,
		   struct dwarf2_cu **ref_cu)
{
  struct die_info temp_die;
  struct dwarf2_cu *target_cu, *cu = *ref_cu;

  gdb_assert (cu->per_cu != NULL);

  target_cu = cu;

  if (cu->per_cu->is_debug_types)
    {
      /* .debug_types CUs cannot reference anything outside their CU.
	 If they need to, they have to reference a signatured type via
	 DW_FORM_ref_sig8.  */
      if (! offset_in_cu_p (&cu->header, offset))
	return NULL;
    }
  else if (offset_in_dwz != cu->per_cu->is_dwz
	   || ! offset_in_cu_p (&cu->header, offset))
    {
      struct dwarf2_per_cu_data *per_cu;

      per_cu = dwarf2_find_containing_comp_unit (offset, offset_in_dwz,
						 cu->objfile);

      /* If necessary, add it to the queue and load its DIEs.  */
      if (maybe_queue_comp_unit (cu, per_cu, cu->language))
	load_full_comp_unit (per_cu, cu->language);

      target_cu = per_cu->cu;
    }
  else if (cu->dies == NULL)
    {
      /* We're loading full DIEs during partial symbol reading.  */
      gdb_assert (dwarf2_per_objfile->reading_partial_symbols);
      load_full_comp_unit (cu->per_cu, language_minimal);
    }

  *ref_cu = target_cu;
  temp_die.offset = offset;
  return htab_find_with_hash (target_cu->die_hash, &temp_die, offset.sect_off);
}

/* Follow reference attribute ATTR of SRC_DIE.
   On entry *REF_CU is the CU of SRC_DIE.
   On exit *REF_CU is the CU of the result.  */

static struct die_info *
follow_die_ref (struct die_info *src_die, const struct attribute *attr,
		struct dwarf2_cu **ref_cu)
{
  sect_offset offset = dwarf2_get_ref_die_offset (attr);
  struct dwarf2_cu *cu = *ref_cu;
  struct die_info *die;

  die = follow_die_offset (offset,
			   (attr->form == DW_FORM_GNU_ref_alt
			    || cu->per_cu->is_dwz),
			   ref_cu);
  if (!die)
    error (_("Dwarf Error: Cannot find DIE at 0x%x referenced from DIE "
	   "at 0x%x [in module %s]"),
	   offset.sect_off, src_die->offset.sect_off,
	   objfile_name (cu->objfile));

  return die;
}

/* Return DWARF block referenced by DW_AT_location of DIE at OFFSET at PER_CU.
   Returned value is intended for DW_OP_call*.  Returned
   dwarf2_locexpr_baton->data has lifetime of PER_CU->OBJFILE.  */

struct dwarf2_locexpr_baton
dwarf2_fetch_die_loc_sect_off (sect_offset offset,
			       struct dwarf2_per_cu_data *per_cu,
			       CORE_ADDR (*get_frame_pc) (void *baton),
			       void *baton)
{
  struct dwarf2_cu *cu;
  struct die_info *die;
  struct attribute *attr;
  struct dwarf2_locexpr_baton retval;

  dw2_setup (per_cu->objfile);

  if (per_cu->cu == NULL)
    load_cu (per_cu);
  cu = per_cu->cu;

  die = follow_die_offset (offset, per_cu->is_dwz, &cu);
  if (!die)
    error (_("Dwarf Error: Cannot find DIE at 0x%x referenced in module %s"),
	   offset.sect_off, objfile_name (per_cu->objfile));

  attr = dwarf2_attr (die, DW_AT_location, cu);
  if (!attr)
    {
      /* DWARF: "If there is no such attribute, then there is no effect.".
	 DATA is ignored if SIZE is 0.  */

      retval.data = NULL;
      retval.size = 0;
    }
  else if (attr_form_is_section_offset (attr))
    {
      struct dwarf2_loclist_baton loclist_baton;
      CORE_ADDR pc = (*get_frame_pc) (baton);
      size_t size;

      fill_in_loclist_baton (cu, &loclist_baton, attr);

      retval.data = dwarf2_find_location_expression (&loclist_baton,
						     &size, pc);
      retval.size = size;
    }
  else
    {
      if (!attr_form_is_block (attr))
	error (_("Dwarf Error: DIE at 0x%x referenced in module %s "
		 "is neither DW_FORM_block* nor DW_FORM_exprloc"),
	       offset.sect_off, objfile_name (per_cu->objfile));

      retval.data = DW_BLOCK (attr)->data;
      retval.size = DW_BLOCK (attr)->size;
    }
  retval.per_cu = cu->per_cu;

  age_cached_comp_units ();

  return retval;
}

/* Like dwarf2_fetch_die_loc_sect_off, but take a CU
   offset.  */

struct dwarf2_locexpr_baton
dwarf2_fetch_die_loc_cu_off (cu_offset offset_in_cu,
			     struct dwarf2_per_cu_data *per_cu,
			     CORE_ADDR (*get_frame_pc) (void *baton),
			     void *baton)
{
  sect_offset offset = { per_cu->offset.sect_off + offset_in_cu.cu_off };

  return dwarf2_fetch_die_loc_sect_off (offset, per_cu, get_frame_pc, baton);
}

/* Write a constant of a given type as target-ordered bytes into
   OBSTACK.  */

static const gdb_byte *
write_constant_as_bytes (struct obstack *obstack,
			 enum bfd_endian byte_order,
			 struct type *type,
			 ULONGEST value,
			 LONGEST *len)
{
  gdb_byte *result;

  *len = TYPE_LENGTH (type);
  result = obstack_alloc (obstack, *len);
  store_unsigned_integer (result, *len, byte_order, value);

  return result;
}

/* If the DIE at OFFSET in PER_CU has a DW_AT_const_value, return a
   pointer to the constant bytes and set LEN to the length of the
   data.  If memory is needed, allocate it on OBSTACK.  If the DIE
   does not have a DW_AT_const_value, return NULL.  */

const gdb_byte *
dwarf2_fetch_constant_bytes (sect_offset offset,
			     struct dwarf2_per_cu_data *per_cu,
			     struct obstack *obstack,
			     LONGEST *len)
{
  struct dwarf2_cu *cu;
  struct die_info *die;
  struct attribute *attr;
  const gdb_byte *result = NULL;
  struct type *type;
  LONGEST value;
  enum bfd_endian byte_order;

  dw2_setup (per_cu->objfile);

  if (per_cu->cu == NULL)
    load_cu (per_cu);
  cu = per_cu->cu;

  die = follow_die_offset (offset, per_cu->is_dwz, &cu);
  if (!die)
    error (_("Dwarf Error: Cannot find DIE at 0x%x referenced in module %s"),
	   offset.sect_off, objfile_name (per_cu->objfile));


  attr = dwarf2_attr (die, DW_AT_const_value, cu);
  if (attr == NULL)
    return NULL;

  byte_order = (bfd_big_endian (per_cu->objfile->obfd)
		? BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE);

  switch (attr->form)
    {
    case DW_FORM_addr:
    case DW_FORM_GNU_addr_index:
      {
	gdb_byte *tem;

	*len = cu->header.addr_size;
	tem = obstack_alloc (obstack, *len);
	store_unsigned_integer (tem, *len, byte_order, DW_ADDR (attr));
	result = tem;
      }
      break;
    case DW_FORM_string:
    case DW_FORM_strp:
    case DW_FORM_GNU_str_index:
    case DW_FORM_GNU_strp_alt:
      /* DW_STRING is already allocated on the objfile obstack, point
	 directly to it.  */
      result = (const gdb_byte *) DW_STRING (attr);
      *len = strlen (DW_STRING (attr));
      break;
    case DW_FORM_block1:
    case DW_FORM_block2:
    case DW_FORM_block4:
    case DW_FORM_block:
    case DW_FORM_exprloc:
      result = DW_BLOCK (attr)->data;
      *len = DW_BLOCK (attr)->size;
      break;

      /* The DW_AT_const_value attributes are supposed to carry the
	 symbol's value "represented as it would be on the target
	 architecture."  By the time we get here, it's already been
	 converted to host endianness, so we just need to sign- or
	 zero-extend it as appropriate.  */
    case DW_FORM_data1:
      type = die_type (die, cu);
      result = dwarf2_const_value_data (attr, obstack, cu, &value, 8);
      if (result == NULL)
	result = write_constant_as_bytes (obstack, byte_order,
					  type, value, len);
      break;
    case DW_FORM_data2:
      type = die_type (die, cu);
      result = dwarf2_const_value_data (attr, obstack, cu, &value, 16);
      if (result == NULL)
	result = write_constant_as_bytes (obstack, byte_order,
					  type, value, len);
      break;
    case DW_FORM_data4:
      type = die_type (die, cu);
      result = dwarf2_const_value_data (attr, obstack, cu, &value, 32);
      if (result == NULL)
	result = write_constant_as_bytes (obstack, byte_order,
					  type, value, len);
      break;
    case DW_FORM_data8:
      type = die_type (die, cu);
      result = dwarf2_const_value_data (attr, obstack, cu, &value, 64);
      if (result == NULL)
	result = write_constant_as_bytes (obstack, byte_order,
					  type, value, len);
      break;

    case DW_FORM_sdata:
      type = die_type (die, cu);
      result = write_constant_as_bytes (obstack, byte_order,
					type, DW_SND (attr), len);
      break;

    case DW_FORM_udata:
      type = die_type (die, cu);
      result = write_constant_as_bytes (obstack, byte_order,
					type, DW_UNSND (attr), len);
      break;

    default:
      complaint (&symfile_complaints,
		 _("unsupported const value attribute form: '%s'"),
		 dwarf_form_name (attr->form));
      break;
    }

  return result;
}

/* Return the type of the DIE at DIE_OFFSET in the CU named by
   PER_CU.  */

struct type *
dwarf2_get_die_type (cu_offset die_offset,
		     struct dwarf2_per_cu_data *per_cu)
{
  sect_offset die_offset_sect;

  dw2_setup (per_cu->objfile);

  die_offset_sect.sect_off = per_cu->offset.sect_off + die_offset.cu_off;
  return get_die_type_at_offset (die_offset_sect, per_cu);
}

/* Follow type unit SIG_TYPE referenced by SRC_DIE.
   On entry *REF_CU is the CU of SRC_DIE.
   On exit *REF_CU is the CU of the result.
   Returns NULL if the referenced DIE isn't found.  */

static struct die_info *
follow_die_sig_1 (struct die_info *src_die, struct signatured_type *sig_type,
		  struct dwarf2_cu **ref_cu)
{
  struct objfile *objfile = (*ref_cu)->objfile;
  struct die_info temp_die;
  struct dwarf2_cu *sig_cu;
  struct die_info *die;

  /* While it might be nice to assert sig_type->type == NULL here,
     we can get here for DW_AT_imported_declaration where we need
     the DIE not the type.  */

  /* If necessary, add it to the queue and load its DIEs.  */

  if (maybe_queue_comp_unit (*ref_cu, &sig_type->per_cu, language_minimal))
    read_signatured_type (sig_type);

  sig_cu = sig_type->per_cu.cu;
  gdb_assert (sig_cu != NULL);
  gdb_assert (sig_type->type_offset_in_section.sect_off != 0);
  temp_die.offset = sig_type->type_offset_in_section;
  die = htab_find_with_hash (sig_cu->die_hash, &temp_die,
			     temp_die.offset.sect_off);
  if (die)
    {
      /* For .gdb_index version 7 keep track of included TUs.
	 http://sourceware.org/bugzilla/show_bug.cgi?id=15021.  */
      if (dwarf2_per_objfile->index_table != NULL
	  && dwarf2_per_objfile->index_table->version <= 7)
	{
	  VEC_safe_push (dwarf2_per_cu_ptr,
			 (*ref_cu)->per_cu->imported_symtabs,
			 sig_cu->per_cu);
	}

      *ref_cu = sig_cu;
      return die;
    }

  return NULL;
}

/* Follow signatured type referenced by ATTR in SRC_DIE.
   On entry *REF_CU is the CU of SRC_DIE.
   On exit *REF_CU is the CU of the result.
   The result is the DIE of the type.
   If the referenced type cannot be found an error is thrown.  */

static struct die_info *
follow_die_sig (struct die_info *src_die, const struct attribute *attr,
		struct dwarf2_cu **ref_cu)
{
  ULONGEST signature = DW_SIGNATURE (attr);
  struct signatured_type *sig_type;
  struct die_info *die;

  gdb_assert (attr->form == DW_FORM_ref_sig8);

  sig_type = lookup_signatured_type (*ref_cu, signature);
  /* sig_type will be NULL if the signatured type is missing from
     the debug info.  */
  if (sig_type == NULL)
    {
      error (_("Dwarf Error: Cannot find signatured DIE %s referenced"
               " from DIE at 0x%x [in module %s]"),
             hex_string (signature), src_die->offset.sect_off,
	     objfile_name ((*ref_cu)->objfile));
    }

  die = follow_die_sig_1 (src_die, sig_type, ref_cu);
  if (die == NULL)
    {
      dump_die_for_error (src_die);
      error (_("Dwarf Error: Problem reading signatured DIE %s referenced"
	       " from DIE at 0x%x [in module %s]"),
	     hex_string (signature), src_die->offset.sect_off,
	     objfile_name ((*ref_cu)->objfile));
    }

  return die;
}

/* Get the type specified by SIGNATURE referenced in DIE/CU,
   reading in and processing the type unit if necessary.  */

static struct type *
get_signatured_type (struct die_info *die, ULONGEST signature,
		     struct dwarf2_cu *cu)
{
  struct signatured_type *sig_type;
  struct dwarf2_cu *type_cu;
  struct die_info *type_die;
  struct type *type;

  sig_type = lookup_signatured_type (cu, signature);
  /* sig_type will be NULL if the signatured type is missing from
     the debug info.  */
  if (sig_type == NULL)
    {
      complaint (&symfile_complaints,
		 _("Dwarf Error: Cannot find signatured DIE %s referenced"
		   " from DIE at 0x%x [in module %s]"),
		 hex_string (signature), die->offset.sect_off,
		 objfile_name (dwarf2_per_objfile->objfile));
      return build_error_marker_type (cu, die);
    }

  /* If we already know the type we're done.  */
  if (sig_type->type != NULL)
    return sig_type->type;

  type_cu = cu;
  type_die = follow_die_sig_1 (die, sig_type, &type_cu);
  if (type_die != NULL)
    {
      /* N.B. We need to call get_die_type to ensure only one type for this DIE
	 is created.  This is important, for example, because for c++ classes
	 we need TYPE_NAME set which is only done by new_symbol.  Blech.  */
      type = read_type_die (type_die, type_cu);
      if (type == NULL)
	{
	  complaint (&symfile_complaints,
		     _("Dwarf Error: Cannot build signatured type %s"
		       " referenced from DIE at 0x%x [in module %s]"),
		     hex_string (signature), die->offset.sect_off,
		     objfile_name (dwarf2_per_objfile->objfile));
	  type = build_error_marker_type (cu, die);
	}
    }
  else
    {
      complaint (&symfile_complaints,
		 _("Dwarf Error: Problem reading signatured DIE %s referenced"
		   " from DIE at 0x%x [in module %s]"),
		 hex_string (signature), die->offset.sect_off,
		 objfile_name (dwarf2_per_objfile->objfile));
      type = build_error_marker_type (cu, die);
    }
  sig_type->type = type;

  return type;
}

/* Get the type specified by the DW_AT_signature ATTR in DIE/CU,
   reading in and processing the type unit if necessary.  */

static struct type *
get_DW_AT_signature_type (struct die_info *die, const struct attribute *attr,
			  struct dwarf2_cu *cu) /* ARI: editCase function */
{
  /* Yes, DW_AT_signature can use a non-ref_sig8 reference.  */
  if (attr_form_is_ref (attr))
    {
      struct dwarf2_cu *type_cu = cu;
      struct die_info *type_die = follow_die_ref (die, attr, &type_cu);

      return read_type_die (type_die, type_cu);
    }
  else if (attr->form == DW_FORM_ref_sig8)
    {
      return get_signatured_type (die, DW_SIGNATURE (attr), cu);
    }
  else
    {
      complaint (&symfile_complaints,
		 _("Dwarf Error: DW_AT_signature has bad form %s in DIE"
		   " at 0x%x [in module %s]"),
		 dwarf_form_name (attr->form), die->offset.sect_off,
		 objfile_name (dwarf2_per_objfile->objfile));
      return build_error_marker_type (cu, die);
    }
}

/* Load the DIEs associated with type unit PER_CU into memory.  */

static void
load_full_type_unit (struct dwarf2_per_cu_data *per_cu)
{
  struct signatured_type *sig_type;

  /* Caller is responsible for ensuring type_unit_groups don't get here.  */
  gdb_assert (! IS_TYPE_UNIT_GROUP (per_cu));

  /* We have the per_cu, but we need the signatured_type.
     Fortunately this is an easy translation.  */
  gdb_assert (per_cu->is_debug_types);
  sig_type = (struct signatured_type *) per_cu;

  gdb_assert (per_cu->cu == NULL);

  read_signatured_type (sig_type);

  gdb_assert (per_cu->cu != NULL);
}

/* die_reader_func for read_signatured_type.
   This is identical to load_full_comp_unit_reader,
   but is kept separate for now.  */

static void
read_signatured_type_reader (const struct die_reader_specs *reader,
			     const gdb_byte *info_ptr,
			     struct die_info *comp_unit_die,
			     int has_children,
			     void *data)
{
  struct dwarf2_cu *cu = reader->cu;

  gdb_assert (cu->die_hash == NULL);
  cu->die_hash =
    htab_create_alloc_ex (cu->header.length / 12,
			  die_hash,
			  die_eq,
			  NULL,
			  &cu->comp_unit_obstack,
			  hashtab_obstack_allocate,
			  dummy_obstack_deallocate);

  if (has_children)
    comp_unit_die->child = read_die_and_siblings (reader, info_ptr,
						  &info_ptr, comp_unit_die);
  cu->dies = comp_unit_die;
  /* comp_unit_die is not stored in die_hash, no need.  */

  /* We try not to read any attributes in this function, because not
     all CUs needed for references have been loaded yet, and symbol
     table processing isn't initialized.  But we have to set the CU language,
     or we won't be able to build types correctly.
     Similarly, if we do not read the producer, we can not apply
     producer-specific interpretation.  */
  prepare_one_comp_unit (cu, cu->dies, language_minimal);
}

/* Read in a signatured type and build its CU and DIEs.
   If the type is a stub for the real type in a DWO file,
   read in the real type from the DWO file as well.  */

static void
read_signatured_type (struct signatured_type *sig_type)
{
  struct dwarf2_per_cu_data *per_cu = &sig_type->per_cu;

  gdb_assert (per_cu->is_debug_types);
  gdb_assert (per_cu->cu == NULL);

  init_cutu_and_read_dies (per_cu, NULL, 0, 1,
			   read_signatured_type_reader, NULL);
  sig_type->per_cu.tu_read = 1;
}

/* Decode simple location descriptions.
   Given a pointer to a dwarf block that defines a location, compute
   the location and return the value.

   NOTE drow/2003-11-18: This function is called in two situations
   now: for the address of static or global variables (partial symbols
   only) and for offsets into structures which are expected to be
   (more or less) constant.  The partial symbol case should go away,
   and only the constant case should remain.  That will let this
   function complain more accurately.  A few special modes are allowed
   without complaint for global variables (for instance, global
   register values and thread-local values).

   A location description containing no operations indicates that the
   object is optimized out.  The return value is 0 for that case.
   FIXME drow/2003-11-16: No callers check for this case any more; soon all
   callers will only want a very basic result and this can become a
   complaint.

   Note that stack[0] is unused except as a default error return.  */

static CORE_ADDR
decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  size_t i;
  size_t size = blk->size;
  const gdb_byte *data = blk->data;
  CORE_ADDR stack[64];
  int stacki;
  unsigned int bytes_read, unsnd;
  gdb_byte op;

  i = 0;
  stacki = 0;
  stack[stacki] = 0;
  stack[++stacki] = 0;

  while (i < size)
    {
      op = data[i++];
      switch (op)
	{
	case DW_OP_lit0:
	case DW_OP_lit1:
	case DW_OP_lit2:
	case DW_OP_lit3:
	case DW_OP_lit4:
	case DW_OP_lit5:
	case DW_OP_lit6:
	case DW_OP_lit7:
	case DW_OP_lit8:
	case DW_OP_lit9:
	case DW_OP_lit10:
	case DW_OP_lit11:
	case DW_OP_lit12:
	case DW_OP_lit13:
	case DW_OP_lit14:
	case DW_OP_lit15:
	case DW_OP_lit16:
	case DW_OP_lit17:
	case DW_OP_lit18:
	case DW_OP_lit19:
	case DW_OP_lit20:
	case DW_OP_lit21:
	case DW_OP_lit22:
	case DW_OP_lit23:
	case DW_OP_lit24:
	case DW_OP_lit25:
	case DW_OP_lit26:
	case DW_OP_lit27:
	case DW_OP_lit28:
	case DW_OP_lit29:
	case DW_OP_lit30:
	case DW_OP_lit31:
	  stack[++stacki] = op - DW_OP_lit0;
	  break;

	case DW_OP_reg0:
	case DW_OP_reg1:
	case DW_OP_reg2:
	case DW_OP_reg3:
	case DW_OP_reg4:
	case DW_OP_reg5:
	case DW_OP_reg6:
	case DW_OP_reg7:
	case DW_OP_reg8:
	case DW_OP_reg9:
	case DW_OP_reg10:
	case DW_OP_reg11:
	case DW_OP_reg12:
	case DW_OP_reg13:
	case DW_OP_reg14:
	case DW_OP_reg15:
	case DW_OP_reg16:
	case DW_OP_reg17:
	case DW_OP_reg18:
	case DW_OP_reg19:
	case DW_OP_reg20:
	case DW_OP_reg21:
	case DW_OP_reg22:
	case DW_OP_reg23:
	case DW_OP_reg24:
	case DW_OP_reg25:
	case DW_OP_reg26:
	case DW_OP_reg27:
	case DW_OP_reg28:
	case DW_OP_reg29:
	case DW_OP_reg30:
	case DW_OP_reg31:
	  stack[++stacki] = op - DW_OP_reg0;
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
	  break;

	case DW_OP_regx:
	  unsnd = read_unsigned_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  stack[++stacki] = unsnd;
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
	  break;

	case DW_OP_addr:
	  stack[++stacki] = read_address (objfile->obfd, &data[i],
					  cu, &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_const1u:
	  stack[++stacki] = read_1_byte (objfile->obfd, &data[i]);
	  i += 1;
	  break;

	case DW_OP_const1s:
	  stack[++stacki] = read_1_signed_byte (objfile->obfd, &data[i]);
	  i += 1;
	  break;

	case DW_OP_const2u:
	  stack[++stacki] = read_2_bytes (objfile->obfd, &data[i]);
	  i += 2;
	  break;

	case DW_OP_const2s:
	  stack[++stacki] = read_2_signed_bytes (objfile->obfd, &data[i]);
	  i += 2;
	  break;

	case DW_OP_const4u:
	  stack[++stacki] = read_4_bytes (objfile->obfd, &data[i]);
	  i += 4;
	  break;

	case DW_OP_const4s:
	  stack[++stacki] = read_4_signed_bytes (objfile->obfd, &data[i]);
	  i += 4;
	  break;

	case DW_OP_const8u:
	  stack[++stacki] = read_8_bytes (objfile->obfd, &data[i]);
	  i += 8;
	  break;

	case DW_OP_constu:
	  stack[++stacki] = read_unsigned_leb128 (NULL, (data + i),
						  &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_consts:
	  stack[++stacki] = read_signed_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_dup:
	  stack[stacki + 1] = stack[stacki];
	  stacki++;
	  break;

	case DW_OP_plus:
	  stack[stacki - 1] += stack[stacki];
	  stacki--;
	  break;

	case DW_OP_plus_uconst:
	  stack[stacki] += read_unsigned_leb128 (NULL, (data + i),
						 &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_minus:
	  stack[stacki - 1] -= stack[stacki];
	  stacki--;
	  break;

	case DW_OP_deref:
	  /* If we're not the last op, then we definitely can't encode
	     this using GDB's address_class enum.  This is valid for partial
	     global symbols, although the variable's address will be bogus
	     in the psymtab.  */
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
	  break;

        case DW_OP_GNU_push_tls_address:
	  /* The top of the stack has the offset from the beginning
	     of the thread control block at which the variable is located.  */
	  /* Nothing should follow this operator, so the top of stack would
	     be returned.  */
	  /* This is valid for partial global symbols, but the variable's
	     address will be bogus in the psymtab.  Make it always at least
	     non-zero to not look as a variable garbage collected by linker
	     which have DW_OP_addr 0.  */
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
	  stack[stacki]++;
          break;

	case DW_OP_GNU_uninit:
	  break;

	case DW_OP_GNU_addr_index:
	case DW_OP_GNU_const_index:
	  stack[++stacki] = read_addr_index_from_leb128 (cu, &data[i],
							 &bytes_read);
	  i += bytes_read;
	  break;

	default:
	  {
	    const char *name = get_DW_OP_name (op);

	    if (name)
	      complaint (&symfile_complaints, _("unsupported stack op: '%s'"),
			 name);
	    else
	      complaint (&symfile_complaints, _("unsupported stack op: '%02x'"),
			 op);
	  }

	  return (stack[stacki]);
	}

      /* Enforce maximum stack depth of SIZE-1 to avoid writing
         outside of the allocated space.  Also enforce minimum>0.  */
      if (stacki >= ARRAY_SIZE (stack) - 1)
	{
	  complaint (&symfile_complaints,
		     _("location description stack overflow"));
	  return 0;
	}

      if (stacki <= 0)
	{
	  complaint (&symfile_complaints,
		     _("location description stack underflow"));
	  return 0;
	}
    }
  return (stack[stacki]);
}

/* memory allocation interface */

static struct dwarf_block *
dwarf_alloc_block (struct dwarf2_cu *cu)
{
  struct dwarf_block *blk;

  blk = (struct dwarf_block *)
    obstack_alloc (&cu->comp_unit_obstack, sizeof (struct dwarf_block));
  return (blk);
}

static struct die_info *
dwarf_alloc_die (struct dwarf2_cu *cu, int num_attrs)
{
  struct die_info *die;
  size_t size = sizeof (struct die_info);

  if (num_attrs > 1)
    size += (num_attrs - 1) * sizeof (struct attribute);

  die = (struct die_info *) obstack_alloc (&cu->comp_unit_obstack, size);
  memset (die, 0, sizeof (struct die_info));
  return (die);
}


/* Macro support.  */

/* Return file name relative to the compilation directory of file number I in
   *LH's file name table.  The result is allocated using xmalloc; the caller is
   responsible for freeing it.  */

static char *
file_file_name (int file, struct line_header *lh)
{
  /* Is the file number a valid index into the line header's file name
     table?  Remember that file numbers start with one, not zero.  */
  if (1 <= file && file <= lh->num_file_names)
    {
      struct file_entry *fe = &lh->file_names[file - 1];

      if (IS_ABSOLUTE_PATH (fe->name) || fe->dir_index == 0)
        return xstrdup (fe->name);
      return concat (lh->include_dirs[fe->dir_index - 1], SLASH_STRING,
		     fe->name, NULL);
    }
  else
    {
      /* The compiler produced a bogus file number.  We can at least
         record the macro definitions made in the file, even if we
         won't be able to find the file by name.  */
      char fake_name[80];

      xsnprintf (fake_name, sizeof (fake_name),
		 "<bad macro file number %d>", file);

      complaint (&symfile_complaints,
                 _("bad file number in macro information (%d)"),
                 file);

      return xstrdup (fake_name);
    }
}

/* Return the full name of file number I in *LH's file name table.
   Use COMP_DIR as the name of the current directory of the
   compilation.  The result is allocated using xmalloc; the caller is
   responsible for freeing it.  */
static char *
file_full_name (int file, struct line_header *lh, const char *comp_dir)
{
  /* Is the file number a valid index into the line header's file name
     table?  Remember that file numbers start with one, not zero.  */
  if (1 <= file && file <= lh->num_file_names)
    {
      char *relative = file_file_name (file, lh);

      if (IS_ABSOLUTE_PATH (relative) || comp_dir == NULL)
	return relative;
      return reconcat (relative, comp_dir, SLASH_STRING, relative, NULL);
    }
  else
    return file_file_name (file, lh);
}


static struct macro_source_file *
macro_start_file (int file, int line,
                  struct macro_source_file *current_file,
                  const char *comp_dir,
                  struct line_header *lh, struct objfile *objfile)
{
  /* File name relative to the compilation directory of this source file.  */
  char *file_name = file_file_name (file, lh);

  if (! current_file)
    {
      /* Note: We don't create a macro table for this compilation unit
	 at all until we actually get a filename.  */
      struct macro_table *macro_table = get_macro_table (objfile, comp_dir);

      /* If we have no current file, then this must be the start_file
	 directive for the compilation unit's main source file.  */
      current_file = macro_set_main (macro_table, file_name);
      macro_define_special (macro_table);
    }
  else
    current_file = macro_include (current_file, line, file_name);

  xfree (file_name);

  return current_file;
}


/* Copy the LEN characters at BUF to a xmalloc'ed block of memory,
   followed by a null byte.  */
static char *
copy_string (const char *buf, int len)
{
  char *s = xmalloc (len + 1);

  memcpy (s, buf, len);
  s[len] = '\0';
  return s;
}


static const char *
consume_improper_spaces (const char *p, const char *body)
{
  if (*p == ' ')
    {
      complaint (&symfile_complaints,
		 _("macro definition contains spaces "
		   "in formal argument list:\n`%s'"),
		 body);

      while (*p == ' ')
        p++;
    }

  return p;
}


static void
parse_macro_definition (struct macro_source_file *file, int line,
                        const char *body)
{
  const char *p;

  /* The body string takes one of two forms.  For object-like macro
     definitions, it should be:

        <macro name> " " <definition>

     For function-like macro definitions, it should be:

        <macro name> "() " <definition>
     or
        <macro name> "(" <arg name> ( "," <arg name> ) * ") " <definition>

     Spaces may appear only where explicitly indicated, and in the
     <definition>.

     The Dwarf 2 spec says that an object-like macro's name is always
     followed by a space, but versions of GCC around March 2002 omit
     the space when the macro's definition is the empty string.

     The Dwarf 2 spec says that there should be no spaces between the
     formal arguments in a function-like macro's formal argument list,
     but versions of GCC around March 2002 include spaces after the
     commas.  */


  /* Find the extent of the macro name.  The macro name is terminated
     by either a space or null character (for an object-like macro) or
     an opening paren (for a function-like macro).  */
  for (p = body; *p; p++)
    if (*p == ' ' || *p == '(')
      break;

  if (*p == ' ' || *p == '\0')
    {
      /* It's an object-like macro.  */
      int name_len = p - body;
      char *name = copy_string (body, name_len);
      const char *replacement;

      if (*p == ' ')
        replacement = body + name_len + 1;
      else
        {
	  dwarf2_macro_malformed_definition_complaint (body);
          replacement = body + name_len;
        }

      macro_define_object (file, line, name, replacement);

      xfree (name);
    }
  else if (*p == '(')
    {
      /* It's a function-like macro.  */
      char *name = copy_string (body, p - body);
      int argc = 0;
      int argv_size = 1;
      char **argv = xmalloc (argv_size * sizeof (*argv));

      p++;

      p = consume_improper_spaces (p, body);

      /* Parse the formal argument list.  */
      while (*p && *p != ')')
        {
          /* Find the extent of the current argument name.  */
          const char *arg_start = p;

          while (*p && *p != ',' && *p != ')' && *p != ' ')
            p++;

          if (! *p || p == arg_start)
	    dwarf2_macro_malformed_definition_complaint (body);
          else
            {
              /* Make sure argv has room for the new argument.  */
              if (argc >= argv_size)
                {
                  argv_size *= 2;
                  argv = xrealloc (argv, argv_size * sizeof (*argv));
                }

              argv[argc++] = copy_string (arg_start, p - arg_start);
            }

          p = consume_improper_spaces (p, body);

          /* Consume the comma, if present.  */
          if (*p == ',')
            {
              p++;

              p = consume_improper_spaces (p, body);
            }
        }

      if (*p == ')')
        {
          p++;

          if (*p == ' ')
            /* Perfectly formed definition, no complaints.  */
            macro_define_function (file, line, name,
                                   argc, (const char **) argv,
                                   p + 1);
          else if (*p == '\0')
            {
              /* Complain, but do define it.  */
	      dwarf2_macro_malformed_definition_complaint (body);
              macro_define_function (file, line, name,
                                     argc, (const char **) argv,
                                     p);
            }
          else
            /* Just complain.  */
	    dwarf2_macro_malformed_definition_complaint (body);
        }
      else
        /* Just complain.  */
	dwarf2_macro_malformed_definition_complaint (body);

      xfree (name);
      {
        int i;

        for (i = 0; i < argc; i++)
          xfree (argv[i]);
      }
      xfree (argv);
    }
  else
    dwarf2_macro_malformed_definition_complaint (body);
}

/* Skip some bytes from BYTES according to the form given in FORM.
   Returns the new pointer.  */

static const gdb_byte *
skip_form_bytes (bfd *abfd, const gdb_byte *bytes, const gdb_byte *buffer_end,
		 enum dwarf_form form,
		 unsigned int offset_size,
		 struct dwarf2_section_info *section)
{
  unsigned int bytes_read;

  switch (form)
    {
    case DW_FORM_data1:
    case DW_FORM_flag:
      ++bytes;
      break;

    case DW_FORM_data2:
      bytes += 2;
      break;

    case DW_FORM_data4:
      bytes += 4;
      break;

    case DW_FORM_data8:
      bytes += 8;
      break;

    case DW_FORM_string:
      read_direct_string (abfd, bytes, &bytes_read);
      bytes += bytes_read;
      break;

    case DW_FORM_sec_offset:
    case DW_FORM_strp:
    case DW_FORM_GNU_strp_alt:
      bytes += offset_size;
      break;

    case DW_FORM_block:
      bytes += read_unsigned_leb128 (abfd, bytes, &bytes_read);
      bytes += bytes_read;
      break;

    case DW_FORM_block1:
      bytes += 1 + read_1_byte (abfd, bytes);
      break;
    case DW_FORM_block2:
      bytes += 2 + read_2_bytes (abfd, bytes);
      break;
    case DW_FORM_block4:
      bytes += 4 + read_4_bytes (abfd, bytes);
      break;

    case DW_FORM_sdata:
    case DW_FORM_udata:
    case DW_FORM_GNU_addr_index:
    case DW_FORM_GNU_str_index:
      bytes = gdb_skip_leb128 (bytes, buffer_end);
      if (bytes == NULL)
	{
	  dwarf2_section_buffer_overflow_complaint (section);
	  return NULL;
	}
      break;

    default:
      {
      complain:
	complaint (&symfile_complaints,
		   _("invalid form 0x%x in `%s'"),
		   form, get_section_name (section));
	return NULL;
      }
    }

  return bytes;
}

/* A helper for dwarf_decode_macros that handles skipping an unknown
   opcode.  Returns an updated pointer to the macro data buffer; or,
   on error, issues a complaint and returns NULL.  */

static const gdb_byte *
skip_unknown_opcode (unsigned int opcode,
		     const gdb_byte **opcode_definitions,
		     const gdb_byte *mac_ptr, const gdb_byte *mac_end,
		     bfd *abfd,
		     unsigned int offset_size,
		     struct dwarf2_section_info *section)
{
  unsigned int bytes_read, i;
  unsigned long arg;
  const gdb_byte *defn;

  if (opcode_definitions[opcode] == NULL)
    {
      complaint (&symfile_complaints,
		 _("unrecognized DW_MACFINO opcode 0x%x"),
		 opcode);
      return NULL;
    }

  defn = opcode_definitions[opcode];
  arg = read_unsigned_leb128 (abfd, defn, &bytes_read);
  defn += bytes_read;

  for (i = 0; i < arg; ++i)
    {
      mac_ptr = skip_form_bytes (abfd, mac_ptr, mac_end, defn[i], offset_size,
				 section);
      if (mac_ptr == NULL)
	{
	  /* skip_form_bytes already issued the complaint.  */
	  return NULL;
	}
    }

  return mac_ptr;
}

/* A helper function which parses the header of a macro section.
   If the macro section is the extended (for now called "GNU") type,
   then this updates *OFFSET_SIZE.  Returns a pointer to just after
   the header, or issues a complaint and returns NULL on error.  */

static const gdb_byte *
dwarf_parse_macro_header (const gdb_byte **opcode_definitions,
			  bfd *abfd,
			  const gdb_byte *mac_ptr,
			  unsigned int *offset_size,
			  int section_is_gnu)
{
  memset (opcode_definitions, 0, 256 * sizeof (gdb_byte *));

  if (section_is_gnu)
    {
      unsigned int version, flags;

      version = read_2_bytes (abfd, mac_ptr);
      if (version != 4)
	{
	  complaint (&symfile_complaints,
		     _("unrecognized version `%d' in .debug_macro section"),
		     version);
	  return NULL;
	}
      mac_ptr += 2;

      flags = read_1_byte (abfd, mac_ptr);
      ++mac_ptr;
      *offset_size = (flags & 1) ? 8 : 4;

      if ((flags & 2) != 0)
	/* We don't need the line table offset.  */
	mac_ptr += *offset_size;

      /* Vendor opcode descriptions.  */
      if ((flags & 4) != 0)
	{
	  unsigned int i, count;

	  count = read_1_byte (abfd, mac_ptr);
	  ++mac_ptr;
	  for (i = 0; i < count; ++i)
	    {
	      unsigned int opcode, bytes_read;
	      unsigned long arg;

	      opcode = read_1_byte (abfd, mac_ptr);
	      ++mac_ptr;
	      opcode_definitions[opcode] = mac_ptr;
	      arg = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	      mac_ptr += bytes_read;
	      mac_ptr += arg;
	    }
	}
    }

  return mac_ptr;
}

/* A helper for dwarf_decode_macros that handles the GNU extensions,
   including DW_MACRO_GNU_transparent_include.  */

static void
dwarf_decode_macro_bytes (bfd *abfd,
			  const gdb_byte *mac_ptr, const gdb_byte *mac_end,
			  struct macro_source_file *current_file,
			  struct line_header *lh, const char *comp_dir,
			  struct dwarf2_section_info *section,
			  int section_is_gnu, int section_is_dwz,
			  unsigned int offset_size,
			  struct objfile *objfile,
			  htab_t include_hash)
{
  enum dwarf_macro_record_type macinfo_type;
  int at_commandline;
  const gdb_byte *opcode_definitions[256];

  mac_ptr = dwarf_parse_macro_header (opcode_definitions, abfd, mac_ptr,
				      &offset_size, section_is_gnu);
  if (mac_ptr == NULL)
    {
      /* We already issued a complaint.  */
      return;
    }

  /* Determines if GDB is still before first DW_MACINFO_start_file.  If true
     GDB is still reading the definitions from command line.  First
     DW_MACINFO_start_file will need to be ignored as it was already executed
     to create CURRENT_FILE for the main source holding also the command line
     definitions.  On first met DW_MACINFO_start_file this flag is reset to
     normally execute all the remaining DW_MACINFO_start_file macinfos.  */

  at_commandline = 1;

  do
    {
      /* Do we at least have room for a macinfo type byte?  */
      if (mac_ptr >= mac_end)
	{
	  dwarf2_section_buffer_overflow_complaint (section);
	  break;
	}

      macinfo_type = read_1_byte (abfd, mac_ptr);
      mac_ptr++;

      /* Note that we rely on the fact that the corresponding GNU and
	 DWARF constants are the same.  */
      switch (macinfo_type)
	{
	  /* A zero macinfo type indicates the end of the macro
	     information.  */
	case 0:
	  break;

        case DW_MACRO_GNU_define:
        case DW_MACRO_GNU_undef:
	case DW_MACRO_GNU_define_indirect:
	case DW_MACRO_GNU_undef_indirect:
	case DW_MACRO_GNU_define_indirect_alt:
	case DW_MACRO_GNU_undef_indirect_alt:
          {
            unsigned int bytes_read;
            int line;
            const char *body;
	    int is_define;

	    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;

	    if (macinfo_type == DW_MACRO_GNU_define
		|| macinfo_type == DW_MACRO_GNU_undef)
	      {
		body = read_direct_string (abfd, mac_ptr, &bytes_read);
		mac_ptr += bytes_read;
	      }
	    else
	      {
		LONGEST str_offset;

		str_offset = read_offset_1 (abfd, mac_ptr, offset_size);
		mac_ptr += offset_size;

		if (macinfo_type == DW_MACRO_GNU_define_indirect_alt
		    || macinfo_type == DW_MACRO_GNU_undef_indirect_alt
		    || section_is_dwz)
		  {
		    struct dwz_file *dwz = dwarf2_get_dwz_file ();

		    body = read_indirect_string_from_dwz (dwz, str_offset);
		  }
		else
		  body = read_indirect_string_at_offset (abfd, str_offset);
	      }

	    is_define = (macinfo_type == DW_MACRO_GNU_define
			 || macinfo_type == DW_MACRO_GNU_define_indirect
			 || macinfo_type == DW_MACRO_GNU_define_indirect_alt);
            if (! current_file)
	      {
		/* DWARF violation as no main source is present.  */
		complaint (&symfile_complaints,
			   _("debug info with no main source gives macro %s "
			     "on line %d: %s"),
			   is_define ? _("definition") : _("undefinition"),
			   line, body);
		break;
	      }
	    if ((line == 0 && !at_commandline)
		|| (line != 0 && at_commandline))
	      complaint (&symfile_complaints,
			 _("debug info gives %s macro %s with %s line %d: %s"),
			 at_commandline ? _("command-line") : _("in-file"),
			 is_define ? _("definition") : _("undefinition"),
			 line == 0 ? _("zero") : _("non-zero"), line, body);

	    if (is_define)
	      parse_macro_definition (current_file, line, body);
	    else
	      {
		gdb_assert (macinfo_type == DW_MACRO_GNU_undef
			    || macinfo_type == DW_MACRO_GNU_undef_indirect
			    || macinfo_type == DW_MACRO_GNU_undef_indirect_alt);
		macro_undef (current_file, line, body);
	      }
          }
          break;

        case DW_MACRO_GNU_start_file:
          {
            unsigned int bytes_read;
            int line, file;

            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;

	    if ((line == 0 && !at_commandline)
		|| (line != 0 && at_commandline))
	      complaint (&symfile_complaints,
			 _("debug info gives source %d included "
			   "from %s at %s line %d"),
			 file, at_commandline ? _("command-line") : _("file"),
			 line == 0 ? _("zero") : _("non-zero"), line);

	    if (at_commandline)
	      {
		/* This DW_MACRO_GNU_start_file was executed in the
		   pass one.  */
		at_commandline = 0;
	      }
	    else
	      current_file = macro_start_file (file, line,
					       current_file, comp_dir,
					       lh, objfile);
          }
          break;

        case DW_MACRO_GNU_end_file:
          if (! current_file)
	    complaint (&symfile_complaints,
		       _("macro debug info has an unmatched "
			 "`close_file' directive"));
          else
            {
              current_file = current_file->included_by;
              if (! current_file)
                {
                  enum dwarf_macro_record_type next_type;

                  /* GCC circa March 2002 doesn't produce the zero
                     type byte marking the end of the compilation
                     unit.  Complain if it's not there, but exit no
                     matter what.  */

                  /* Do we at least have room for a macinfo type byte?  */
                  if (mac_ptr >= mac_end)
                    {
		      dwarf2_section_buffer_overflow_complaint (section);
                      return;
                    }

                  /* We don't increment mac_ptr here, so this is just
                     a look-ahead.  */
                  next_type = read_1_byte (abfd, mac_ptr);
                  if (next_type != 0)
		    complaint (&symfile_complaints,
			       _("no terminating 0-type entry for "
				 "macros in `.debug_macinfo' section"));

                  return;
                }
            }
          break;

	case DW_MACRO_GNU_transparent_include:
	case DW_MACRO_GNU_transparent_include_alt:
	  {
	    LONGEST offset;
	    void **slot;
	    bfd *include_bfd = abfd;
	    struct dwarf2_section_info *include_section = section;
	    struct dwarf2_section_info alt_section;
	    const gdb_byte *include_mac_end = mac_end;
	    int is_dwz = section_is_dwz;
	    const gdb_byte *new_mac_ptr;

	    offset = read_offset_1 (abfd, mac_ptr, offset_size);
	    mac_ptr += offset_size;

	    if (macinfo_type == DW_MACRO_GNU_transparent_include_alt)
	      {
		struct dwz_file *dwz = dwarf2_get_dwz_file ();

		dwarf2_read_section (dwarf2_per_objfile->objfile,
				     &dwz->macro);

		include_section = &dwz->macro;
		include_bfd = get_section_bfd_owner (include_section);
		include_mac_end = dwz->macro.buffer + dwz->macro.size;
		is_dwz = 1;
	      }

	    new_mac_ptr = include_section->buffer + offset;
	    slot = htab_find_slot (include_hash, new_mac_ptr, INSERT);

	    if (*slot != NULL)
	      {
		/* This has actually happened; see
		   http://sourceware.org/bugzilla/show_bug.cgi?id=13568.  */
		complaint (&symfile_complaints,
			   _("recursive DW_MACRO_GNU_transparent_include in "
			     ".debug_macro section"));
	      }
	    else
	      {
		*slot = (void *) new_mac_ptr;

		dwarf_decode_macro_bytes (include_bfd, new_mac_ptr,
					  include_mac_end, current_file,
					  lh, comp_dir,
					  section, section_is_gnu, is_dwz,
					  offset_size, objfile, include_hash);

		htab_remove_elt (include_hash, (void *) new_mac_ptr);
	      }
	  }
	  break;

        case DW_MACINFO_vendor_ext:
	  if (!section_is_gnu)
	    {
	      unsigned int bytes_read;
	      int constant;

	      constant = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	      mac_ptr += bytes_read;
	      read_direct_string (abfd, mac_ptr, &bytes_read);
	      mac_ptr += bytes_read;

	      /* We don't recognize any vendor extensions.  */
	      break;
	    }
	  /* FALLTHROUGH */

	default:
	  mac_ptr = skip_unknown_opcode (macinfo_type, opcode_definitions,
					 mac_ptr, mac_end, abfd, offset_size,
					 section);
	  if (mac_ptr == NULL)
	    return;
	  break;
        }
    } while (macinfo_type != 0);
}

static void
dwarf_decode_macros (struct dwarf2_cu *cu, unsigned int offset,
                     const char *comp_dir, int section_is_gnu)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct line_header *lh = cu->line_header;
  bfd *abfd;
  const gdb_byte *mac_ptr, *mac_end;
  struct macro_source_file *current_file = 0;
  enum dwarf_macro_record_type macinfo_type;
  unsigned int offset_size = cu->header.offset_size;
  const gdb_byte *opcode_definitions[256];
  struct cleanup *cleanup;
  htab_t include_hash;
  void **slot;
  struct dwarf2_section_info *section;
  const char *section_name;

  if (cu->dwo_unit != NULL)
    {
      if (section_is_gnu)
	{
	  section = &cu->dwo_unit->dwo_file->sections.macro;
	  section_name = ".debug_macro.dwo";
	}
      else
	{
	  section = &cu->dwo_unit->dwo_file->sections.macinfo;
	  section_name = ".debug_macinfo.dwo";
	}
    }
  else
    {
      if (section_is_gnu)
	{
	  section = &dwarf2_per_objfile->macro;
	  section_name = ".debug_macro";
	}
      else
	{
	  section = &dwarf2_per_objfile->macinfo;
	  section_name = ".debug_macinfo";
	}
    }

  dwarf2_read_section (objfile, section);
  if (section->buffer == NULL)
    {
      complaint (&symfile_complaints, _("missing %s section"), section_name);
      return;
    }
  abfd = get_section_bfd_owner (section);

  /* First pass: Find the name of the base filename.
     This filename is needed in order to process all macros whose definition
     (or undefinition) comes from the command line.  These macros are defined
     before the first DW_MACINFO_start_file entry, and yet still need to be
     associated to the base file.

     To determine the base file name, we scan the macro definitions until we
     reach the first DW_MACINFO_start_file entry.  We then initialize
     CURRENT_FILE accordingly so that any macro definition found before the
     first DW_MACINFO_start_file can still be associated to the base file.  */

  mac_ptr = section->buffer + offset;
  mac_end = section->buffer + section->size;

  mac_ptr = dwarf_parse_macro_header (opcode_definitions, abfd, mac_ptr,
				      &offset_size, section_is_gnu);
  if (mac_ptr == NULL)
    {
      /* We already issued a complaint.  */
      return;
    }

  do
    {
      /* Do we at least have room for a macinfo type byte?  */
      if (mac_ptr >= mac_end)
        {
	  /* Complaint is printed during the second pass as GDB will probably
	     stop the first pass earlier upon finding
	     DW_MACINFO_start_file.  */
	  break;
        }

      macinfo_type = read_1_byte (abfd, mac_ptr);
      mac_ptr++;

      /* Note that we rely on the fact that the corresponding GNU and
	 DWARF constants are the same.  */
      switch (macinfo_type)
        {
          /* A zero macinfo type indicates the end of the macro
             information.  */
        case 0:
	  break;

	case DW_MACRO_GNU_define:
	case DW_MACRO_GNU_undef:
	  /* Only skip the data by MAC_PTR.  */
	  {
	    unsigned int bytes_read;

	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	    read_direct_string (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	  }
	  break;

	case DW_MACRO_GNU_start_file:
	  {
	    unsigned int bytes_read;
	    int line, file;

	    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	    file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;

	    current_file = macro_start_file (file, line, current_file,
					     comp_dir, lh, objfile);
	  }
	  break;

	case DW_MACRO_GNU_end_file:
	  /* No data to skip by MAC_PTR.  */
	  break;

	case DW_MACRO_GNU_define_indirect:
	case DW_MACRO_GNU_undef_indirect:
	case DW_MACRO_GNU_define_indirect_alt:
	case DW_MACRO_GNU_undef_indirect_alt:
	  {
	    unsigned int bytes_read;

	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	    mac_ptr += offset_size;
	  }
	  break;

	case DW_MACRO_GNU_transparent_include:
	case DW_MACRO_GNU_transparent_include_alt:
	  /* Note that, according to the spec, a transparent include
	     chain cannot call DW_MACRO_GNU_start_file.  So, we can just
	     skip this opcode.  */
	  mac_ptr += offset_size;
	  break;

	case DW_MACINFO_vendor_ext:
	  /* Only skip the data by MAC_PTR.  */
	  if (!section_is_gnu)
	    {
	      unsigned int bytes_read;

	      read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	      mac_ptr += bytes_read;
	      read_direct_string (abfd, mac_ptr, &bytes_read);
	      mac_ptr += bytes_read;
	    }
	  /* FALLTHROUGH */

	default:
	  mac_ptr = skip_unknown_opcode (macinfo_type, opcode_definitions,
					 mac_ptr, mac_end, abfd, offset_size,
					 section);
	  if (mac_ptr == NULL)
	    return;
	  break;
	}
    } while (macinfo_type != 0 && current_file == NULL);

  /* Second pass: Process all entries.

     Use the AT_COMMAND_LINE flag to determine whether we are still processing
     command-line macro definitions/undefinitions.  This flag is unset when we
     reach the first DW_MACINFO_start_file entry.  */

  include_hash = htab_create_alloc (1, htab_hash_pointer, htab_eq_pointer,
				    NULL, xcalloc, xfree);
  cleanup = make_cleanup_htab_delete (include_hash);
  mac_ptr = section->buffer + offset;
  slot = htab_find_slot (include_hash, mac_ptr, INSERT);
  *slot = (void *) mac_ptr;
  dwarf_decode_macro_bytes (abfd, mac_ptr, mac_end,
			    current_file, lh, comp_dir, section,
			    section_is_gnu, 0,
			    offset_size, objfile, include_hash);
  do_cleanups (cleanup);
}

/* Check if the attribute's form is a DW_FORM_block*
   if so return true else false.  */

static int
attr_form_is_block (const struct attribute *attr)
{
  return (attr == NULL ? 0 :
      attr->form == DW_FORM_block1
      || attr->form == DW_FORM_block2
      || attr->form == DW_FORM_block4
      || attr->form == DW_FORM_block
      || attr->form == DW_FORM_exprloc);
}

/* Return non-zero if ATTR's value is a section offset --- classes
   lineptr, loclistptr, macptr or rangelistptr --- or zero, otherwise.
   You may use DW_UNSND (attr) to retrieve such offsets.

   Section 7.5.4, "Attribute Encodings", explains that no attribute
   may have a value that belongs to more than one of these classes; it
   would be ambiguous if we did, because we use the same forms for all
   of them.  */

static int
attr_form_is_section_offset (const struct attribute *attr)
{
  return (attr->form == DW_FORM_data4
          || attr->form == DW_FORM_data8
	  || attr->form == DW_FORM_sec_offset);
}

/* Return non-zero if ATTR's value falls in the 'constant' class, or
   zero otherwise.  When this function returns true, you can apply
   dwarf2_get_attr_constant_value to it.

   However, note that for some attributes you must check
   attr_form_is_section_offset before using this test.  DW_FORM_data4
   and DW_FORM_data8 are members of both the constant class, and of
   the classes that contain offsets into other debug sections
   (lineptr, loclistptr, macptr or rangelistptr).  The DWARF spec says
   that, if an attribute's can be either a constant or one of the
   section offset classes, DW_FORM_data4 and DW_FORM_data8 should be
   taken as section offsets, not constants.  */

static int
attr_form_is_constant (const struct attribute *attr)
{
  switch (attr->form)
    {
    case DW_FORM_sdata:
    case DW_FORM_udata:
    case DW_FORM_data1:
    case DW_FORM_data2:
    case DW_FORM_data4:
    case DW_FORM_data8:
      return 1;
    default:
      return 0;
    }
}


/* DW_ADDR is always stored already as sect_offset; despite for the forms
   besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */

static int
attr_form_is_ref (const struct attribute *attr)
{
  switch (attr->form)
    {
    case DW_FORM_ref_addr:
    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref8:
    case DW_FORM_ref_udata:
    case DW_FORM_GNU_ref_alt:
      return 1;
    default:
      return 0;
    }
}

/* Return the .debug_loc section to use for CU.
   For DWO files use .debug_loc.dwo.  */

static struct dwarf2_section_info *
cu_debug_loc_section (struct dwarf2_cu *cu)
{
  if (cu->dwo_unit)
    return &cu->dwo_unit->dwo_file->sections.loc;
  return &dwarf2_per_objfile->loc;
}

/* A helper function that fills in a dwarf2_loclist_baton.  */

static void
fill_in_loclist_baton (struct dwarf2_cu *cu,
		       struct dwarf2_loclist_baton *baton,
		       const struct attribute *attr)
{
  struct dwarf2_section_info *section = cu_debug_loc_section (cu);

  dwarf2_read_section (dwarf2_per_objfile->objfile, section);

  baton->per_cu = cu->per_cu;
  gdb_assert (baton->per_cu);
  /* We don't know how long the location list is, but make sure we
     don't run off the edge of the section.  */
  baton->size = section->size - DW_UNSND (attr);
  baton->data = section->buffer + DW_UNSND (attr);
  baton->base_address = cu->base_address;
  baton->from_dwo = cu->dwo_unit != NULL;
}

static void
dwarf2_symbol_mark_computed (const struct attribute *attr, struct symbol *sym,
			     struct dwarf2_cu *cu, int is_block)
{
  struct objfile *objfile = dwarf2_per_objfile->objfile;
  struct dwarf2_section_info *section = cu_debug_loc_section (cu);

  if (attr_form_is_section_offset (attr)
      /* .debug_loc{,.dwo} may not exist at all, or the offset may be outside
	 the section.  If so, fall through to the complaint in the
	 other branch.  */
      && DW_UNSND (attr) < dwarf2_section_size (objfile, section))
    {
      struct dwarf2_loclist_baton *baton;

      baton = obstack_alloc (&objfile->objfile_obstack,
			     sizeof (struct dwarf2_loclist_baton));

      fill_in_loclist_baton (cu, baton, attr);

      if (cu->base_known == 0)
	complaint (&symfile_complaints,
		   _("Location list used without "
		     "specifying the CU base address."));

      SYMBOL_ACLASS_INDEX (sym) = (is_block
				   ? dwarf2_loclist_block_index
				   : dwarf2_loclist_index);
      SYMBOL_LOCATION_BATON (sym) = baton;
    }
  else
    {
      struct dwarf2_locexpr_baton *baton;

      baton = obstack_alloc (&objfile->objfile_obstack,
			     sizeof (struct dwarf2_locexpr_baton));
      baton->per_cu = cu->per_cu;
      gdb_assert (baton->per_cu);

      if (attr_form_is_block (attr))
	{
	  /* Note that we're just copying the block's data pointer
	     here, not the actual data.  We're still pointing into the
	     info_buffer for SYM's objfile; right now we never release
	     that buffer, but when we do clean up properly this may
	     need to change.  */
	  baton->size = DW_BLOCK (attr)->size;
	  baton->data = DW_BLOCK (attr)->data;
	}
      else
	{
	  dwarf2_invalid_attrib_class_complaint ("location description",
						 SYMBOL_NATURAL_NAME (sym));
	  baton->size = 0;
	}

      SYMBOL_ACLASS_INDEX (sym) = (is_block
				   ? dwarf2_locexpr_block_index
				   : dwarf2_locexpr_index);
      SYMBOL_LOCATION_BATON (sym) = baton;
    }
}

/* Return the OBJFILE associated with the compilation unit CU.  If CU
   came from a separate debuginfo file, then the master objfile is
   returned.  */

struct objfile *
dwarf2_per_cu_objfile (struct dwarf2_per_cu_data *per_cu)
{
  struct objfile *objfile = per_cu->objfile;

  /* Return the master objfile, so that we can report and look up the
     correct file containing this variable.  */
  if (objfile->separate_debug_objfile_backlink)
    objfile = objfile->separate_debug_objfile_backlink;

  return objfile;
}

/* Return comp_unit_head for PER_CU, either already available in PER_CU->CU
   (CU_HEADERP is unused in such case) or prepare a temporary copy at
   CU_HEADERP first.  */

static const struct comp_unit_head *
per_cu_header_read_in (struct comp_unit_head *cu_headerp,
		       struct dwarf2_per_cu_data *per_cu)
{
  const gdb_byte *info_ptr;

  if (per_cu->cu)
    return &per_cu->cu->header;

  info_ptr = per_cu->section->buffer + per_cu->offset.sect_off;

  memset (cu_headerp, 0, sizeof (*cu_headerp));
  read_comp_unit_head (cu_headerp, info_ptr, per_cu->objfile->obfd);

  return cu_headerp;
}

/* Return the address size given in the compilation unit header for CU.  */

int
dwarf2_per_cu_addr_size (struct dwarf2_per_cu_data *per_cu)
{
  struct comp_unit_head cu_header_local;
  const struct comp_unit_head *cu_headerp;

  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);

  return cu_headerp->addr_size;
}

/* Return the offset size given in the compilation unit header for CU.  */

int
dwarf2_per_cu_offset_size (struct dwarf2_per_cu_data *per_cu)
{
  struct comp_unit_head cu_header_local;
  const struct comp_unit_head *cu_headerp;

  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);

  return cu_headerp->offset_size;
}

/* See its dwarf2loc.h declaration.  */

int
dwarf2_per_cu_ref_addr_size (struct dwarf2_per_cu_data *per_cu)
{
  struct comp_unit_head cu_header_local;
  const struct comp_unit_head *cu_headerp;

  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);

  if (cu_headerp->version == 2)
    return cu_headerp->addr_size;
  else
    return cu_headerp->offset_size;
}

/* Return the text offset of the CU.  The returned offset comes from
   this CU's objfile.  If this objfile came from a separate debuginfo
   file, then the offset may be different from the corresponding
   offset in the parent objfile.  */

CORE_ADDR
dwarf2_per_cu_text_offset (struct dwarf2_per_cu_data *per_cu)
{
  struct objfile *objfile = per_cu->objfile;

  return ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
}

/* Locate the .debug_info compilation unit from CU's objfile which contains
   the DIE at OFFSET.  Raises an error on failure.  */

static struct dwarf2_per_cu_data *
dwarf2_find_containing_comp_unit (sect_offset offset,
				  unsigned int offset_in_dwz,
				  struct objfile *objfile)
{
  struct dwarf2_per_cu_data *this_cu;
  int low, high;
  const sect_offset *cu_off;

  low = 0;
  high = dwarf2_per_objfile->n_comp_units - 1;
  while (high > low)
    {
      struct dwarf2_per_cu_data *mid_cu;
      int mid = low + (high - low) / 2;

      mid_cu = dwarf2_per_objfile->all_comp_units[mid];
      cu_off = &mid_cu->offset;
      if (mid_cu->is_dwz > offset_in_dwz
	  || (mid_cu->is_dwz == offset_in_dwz
	      && cu_off->sect_off >= offset.sect_off))
	high = mid;
      else
	low = mid + 1;
    }
  gdb_assert (low == high);
  this_cu = dwarf2_per_objfile->all_comp_units[low];
  cu_off = &this_cu->offset;
  if (this_cu->is_dwz != offset_in_dwz || cu_off->sect_off > offset.sect_off)
    {
      if (low == 0 || this_cu->is_dwz != offset_in_dwz)
	error (_("Dwarf Error: could not find partial DIE containing "
	       "offset 0x%lx [in module %s]"),
	       (long) offset.sect_off, bfd_get_filename (objfile->obfd));

      gdb_assert (dwarf2_per_objfile->all_comp_units[low-1]->offset.sect_off
		  <= offset.sect_off);
      return dwarf2_per_objfile->all_comp_units[low-1];
    }
  else
    {
      this_cu = dwarf2_per_objfile->all_comp_units[low];
      if (low == dwarf2_per_objfile->n_comp_units - 1
	  && offset.sect_off >= this_cu->offset.sect_off + this_cu->length)
	error (_("invalid dwarf2 offset %u"), offset.sect_off);
      gdb_assert (offset.sect_off < this_cu->offset.sect_off + this_cu->length);
      return this_cu;
    }
}

/* Initialize dwarf2_cu CU, owned by PER_CU.  */

static void
init_one_comp_unit (struct dwarf2_cu *cu, struct dwarf2_per_cu_data *per_cu)
{
  memset (cu, 0, sizeof (*cu));
  per_cu->cu = cu;
  cu->per_cu = per_cu;
  cu->objfile = per_cu->objfile;
  obstack_init (&cu->comp_unit_obstack);
}

/* Initialize basic fields of dwarf_cu CU according to DIE COMP_UNIT_DIE.  */

static void
prepare_one_comp_unit (struct dwarf2_cu *cu, struct die_info *comp_unit_die,
		       enum language pretend_language)
{
  struct attribute *attr;

  /* Set the language we're debugging.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_language, cu);
  if (attr)
    set_cu_language (DW_UNSND (attr), cu);
  else
    {
      cu->language = pretend_language;
      cu->language_defn = language_def (cu->language);
    }

  attr = dwarf2_attr (comp_unit_die, DW_AT_producer, cu);
  if (attr)
    cu->producer = DW_STRING (attr);
}

/* Release one cached compilation unit, CU.  We unlink it from the tree
   of compilation units, but we don't remove it from the read_in_chain;
   the caller is responsible for that.
   NOTE: DATA is a void * because this function is also used as a
   cleanup routine.  */

static void
free_heap_comp_unit (void *data)
{
  struct dwarf2_cu *cu = data;

  gdb_assert (cu->per_cu != NULL);
  cu->per_cu->cu = NULL;
  cu->per_cu = NULL;

  obstack_free (&cu->comp_unit_obstack, NULL);

  xfree (cu);
}

/* This cleanup function is passed the address of a dwarf2_cu on the stack
   when we're finished with it.  We can't free the pointer itself, but be
   sure to unlink it from the cache.  Also release any associated storage.  */

static void
free_stack_comp_unit (void *data)
{
  struct dwarf2_cu *cu = data;

  gdb_assert (cu->per_cu != NULL);
  cu->per_cu->cu = NULL;
  cu->per_cu = NULL;

  obstack_free (&cu->comp_unit_obstack, NULL);
  cu->partial_dies = NULL;
}

/* Free all cached compilation units.  */

static void
free_cached_comp_units (void *data)
{
  struct dwarf2_per_cu_data *per_cu, **last_chain;

  per_cu = dwarf2_per_objfile->read_in_chain;
  last_chain = &dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      struct dwarf2_per_cu_data *next_cu;

      next_cu = per_cu->cu->read_in_chain;

      free_heap_comp_unit (per_cu->cu);
      *last_chain = next_cu;

      per_cu = next_cu;
    }
}

/* Increase the age counter on each cached compilation unit, and free
   any that are too old.  */

static void
age_cached_comp_units (void)
{
  struct dwarf2_per_cu_data *per_cu, **last_chain;

  dwarf2_clear_marks (dwarf2_per_objfile->read_in_chain);
  per_cu = dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      per_cu->cu->last_used ++;
      if (per_cu->cu->last_used <= dwarf2_max_cache_age)
	dwarf2_mark (per_cu->cu);
      per_cu = per_cu->cu->read_in_chain;
    }

  per_cu = dwarf2_per_objfile->read_in_chain;
  last_chain = &dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      struct dwarf2_per_cu_data *next_cu;

      next_cu = per_cu->cu->read_in_chain;

      if (!per_cu->cu->mark)
	{
	  free_heap_comp_unit (per_cu->cu);
	  *last_chain = next_cu;
	}
      else
	last_chain = &per_cu->cu->read_in_chain;

      per_cu = next_cu;
    }
}

/* Remove a single compilation unit from the cache.  */

static void
free_one_cached_comp_unit (struct dwarf2_per_cu_data *target_per_cu)
{
  struct dwarf2_per_cu_data *per_cu, **last_chain;

  per_cu = dwarf2_per_objfile->read_in_chain;
  last_chain = &dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      struct dwarf2_per_cu_data *next_cu;

      next_cu = per_cu->cu->read_in_chain;

      if (per_cu == target_per_cu)
	{
	  free_heap_comp_unit (per_cu->cu);
	  per_cu->cu = NULL;
	  *last_chain = next_cu;
	  break;
	}
      else
	last_chain = &per_cu->cu->read_in_chain;

      per_cu = next_cu;
    }
}

/* Release all extra memory associated with OBJFILE.  */

void
dwarf2_free_objfile (struct objfile *objfile)
{
  dwarf2_per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);

  if (dwarf2_per_objfile == NULL)
    return;

  /* Cached DIE trees use xmalloc and the comp_unit_obstack.  */
  free_cached_comp_units (NULL);

  if (dwarf2_per_objfile->quick_file_names_table)
    htab_delete (dwarf2_per_objfile->quick_file_names_table);

  /* Everything else should be on the objfile obstack.  */
}

/* A set of CU "per_cu" pointer, DIE offset, and GDB type pointer.
   We store these in a hash table separate from the DIEs, and preserve them
   when the DIEs are flushed out of cache.

   The CU "per_cu" pointer is needed because offset alone is not enough to
   uniquely identify the type.  A file may have multiple .debug_types sections,
   or the type may come from a DWO file.  Furthermore, while it's more logical
   to use per_cu->section+offset, with Fission the section with the data is in
   the DWO file but we don't know that section at the point we need it.
   We have to use something in dwarf2_per_cu_data (or the pointer to it)
   because we can enter the lookup routine, get_die_type_at_offset, from
   outside this file, and thus won't necessarily have PER_CU->cu.
   Fortunately, PER_CU is stable for the life of the objfile.  */

struct dwarf2_per_cu_offset_and_type
{
  const struct dwarf2_per_cu_data *per_cu;
  sect_offset offset;
  struct type *type;
};

/* Hash function for a dwarf2_per_cu_offset_and_type.  */

static hashval_t
per_cu_offset_and_type_hash (const void *item)
{
  const struct dwarf2_per_cu_offset_and_type *ofs = item;

  return (uintptr_t) ofs->per_cu + ofs->offset.sect_off;
}

/* Equality function for a dwarf2_per_cu_offset_and_type.  */

static int
per_cu_offset_and_type_eq (const void *item_lhs, const void *item_rhs)
{
  const struct dwarf2_per_cu_offset_and_type *ofs_lhs = item_lhs;
  const struct dwarf2_per_cu_offset_and_type *ofs_rhs = item_rhs;

  return (ofs_lhs->per_cu == ofs_rhs->per_cu
	  && ofs_lhs->offset.sect_off == ofs_rhs->offset.sect_off);
}

/* Set the type associated with DIE to TYPE.  Save it in CU's hash
   table if necessary.  For convenience, return TYPE.

   The DIEs reading must have careful ordering to:
    * Not cause infite loops trying to read in DIEs as a prerequisite for
      reading current DIE.
    * Not trying to dereference contents of still incompletely read in types
      while reading in other DIEs.
    * Enable referencing still incompletely read in types just by a pointer to
      the type without accessing its fields.

   Therefore caller should follow these rules:
     * Try to fetch any prerequisite types we may need to build this DIE type
       before building the type and calling set_die_type.
     * After building type call set_die_type for current DIE as soon as
       possible before fetching more types to complete the current type.
     * Make the type as complete as possible before fetching more types.  */

static struct type *
set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)
{
  struct dwarf2_per_cu_offset_and_type **slot, ofs;
  struct objfile *objfile = cu->objfile;

  /* For Ada types, make sure that the gnat-specific data is always
     initialized (if not already set).  There are a few types where
     we should not be doing so, because the type-specific area is
     already used to hold some other piece of info (eg: TYPE_CODE_FLT
     where the type-specific area is used to store the floatformat).
     But this is not a problem, because the gnat-specific information
     is actually not needed for these types.  */
  if (need_gnat_info (cu)
      && TYPE_CODE (type) != TYPE_CODE_FUNC
      && TYPE_CODE (type) != TYPE_CODE_FLT
      && !HAVE_GNAT_AUX_INFO (type))
    INIT_GNAT_SPECIFIC (type);

  if (dwarf2_per_objfile->die_type_hash == NULL)
    {
      dwarf2_per_objfile->die_type_hash =
	htab_create_alloc_ex (127,
			      per_cu_offset_and_type_hash,
			      per_cu_offset_and_type_eq,
			      NULL,
			      &objfile->objfile_obstack,
			      hashtab_obstack_allocate,
			      dummy_obstack_deallocate);
    }

  ofs.per_cu = cu->per_cu;
  ofs.offset = die->offset;
  ofs.type = type;
  slot = (struct dwarf2_per_cu_offset_and_type **)
    htab_find_slot (dwarf2_per_objfile->die_type_hash, &ofs, INSERT);
  if (*slot)
    complaint (&symfile_complaints,
	       _("A problem internal to GDB: DIE 0x%x has type already set"),
	       die->offset.sect_off);
  *slot = obstack_alloc (&objfile->objfile_obstack, sizeof (**slot));
  **slot = ofs;
  return type;
}

/* Look up the type for the die at OFFSET in PER_CU in die_type_hash,
   or return NULL if the die does not have a saved type.  */

static struct type *
get_die_type_at_offset (sect_offset offset,
			struct dwarf2_per_cu_data *per_cu)
{
  struct dwarf2_per_cu_offset_and_type *slot, ofs;

  if (dwarf2_per_objfile->die_type_hash == NULL)
    return NULL;

  ofs.per_cu = per_cu;
  ofs.offset = offset;
  slot = htab_find (dwarf2_per_objfile->die_type_hash, &ofs);
  if (slot)
    return slot->type;
  else
    return NULL;
}

/* Look up the type for DIE in CU in die_type_hash,
   or return NULL if DIE does not have a saved type.  */

static struct type *
get_die_type (struct die_info *die, struct dwarf2_cu *cu)
{
  return get_die_type_at_offset (die->offset, cu->per_cu);
}

/* Add a dependence relationship from CU to REF_PER_CU.  */

static void
dwarf2_add_dependence (struct dwarf2_cu *cu,
		       struct dwarf2_per_cu_data *ref_per_cu)
{
  void **slot;

  if (cu->dependencies == NULL)
    cu->dependencies
      = htab_create_alloc_ex (5, htab_hash_pointer, htab_eq_pointer,
			      NULL, &cu->comp_unit_obstack,
			      hashtab_obstack_allocate,
			      dummy_obstack_deallocate);

  slot = htab_find_slot (cu->dependencies, ref_per_cu, INSERT);
  if (*slot == NULL)
    *slot = ref_per_cu;
}

/* Subroutine of dwarf2_mark to pass to htab_traverse.
   Set the mark field in every compilation unit in the
   cache that we must keep because we are keeping CU.  */

static int
dwarf2_mark_helper (void **slot, void *data)
{
  struct dwarf2_per_cu_data *per_cu;

  per_cu = (struct dwarf2_per_cu_data *) *slot;

  /* cu->dependencies references may not yet have been ever read if QUIT aborts
     reading of the chain.  As such dependencies remain valid it is not much
     useful to track and undo them during QUIT cleanups.  */
  if (per_cu->cu == NULL)
    return 1;

  if (per_cu->cu->mark)
    return 1;
  per_cu->cu->mark = 1;

  if (per_cu->cu->dependencies != NULL)
    htab_traverse (per_cu->cu->dependencies, dwarf2_mark_helper, NULL);

  return 1;
}

/* Set the mark field in CU and in every other compilation unit in the
   cache that we must keep because we are keeping CU.  */

static void
dwarf2_mark (struct dwarf2_cu *cu)
{
  if (cu->mark)
    return;
  cu->mark = 1;
  if (cu->dependencies != NULL)
    htab_traverse (cu->dependencies, dwarf2_mark_helper, NULL);
}

static void
dwarf2_clear_marks (struct dwarf2_per_cu_data *per_cu)
{
  while (per_cu)
    {
      per_cu->cu->mark = 0;
      per_cu = per_cu->cu->read_in_chain;
    }
}

/* Trivial hash function for partial_die_info: the hash value of a DIE
   is its offset in .debug_info for this objfile.  */

static hashval_t
partial_die_hash (const void *item)
{
  const struct partial_die_info *part_die = item;

  return part_die->offset.sect_off;
}

/* Trivial comparison function for partial_die_info structures: two DIEs
   are equal if they have the same offset.  */

static int
partial_die_eq (const void *item_lhs, const void *item_rhs)
{
  const struct partial_die_info *part_die_lhs = item_lhs;
  const struct partial_die_info *part_die_rhs = item_rhs;

  return part_die_lhs->offset.sect_off == part_die_rhs->offset.sect_off;
}

static struct cmd_list_element *set_dwarf2_cmdlist;
static struct cmd_list_element *show_dwarf2_cmdlist;

static void
set_dwarf2_cmd (char *args, int from_tty)
{
  help_list (set_dwarf2_cmdlist, "maintenance set dwarf2 ", -1, gdb_stdout);
}

static void
show_dwarf2_cmd (char *args, int from_tty)
{
  cmd_show_list (show_dwarf2_cmdlist, from_tty, "");
}

/* Free data associated with OBJFILE, if necessary.  */

static void
dwarf2_per_objfile_free (struct objfile *objfile, void *d)
{
  struct dwarf2_per_objfile *data = d;
  int ix;

  /* Make sure we don't accidentally use dwarf2_per_objfile while
     cleaning up.  */
  dwarf2_per_objfile = NULL;

  for (ix = 0; ix < data->n_comp_units; ++ix)
   VEC_free (dwarf2_per_cu_ptr, data->all_comp_units[ix]->imported_symtabs);

  for (ix = 0; ix < data->n_type_units; ++ix)
    VEC_free (dwarf2_per_cu_ptr,
	      data->all_type_units[ix]->per_cu.imported_symtabs);
  xfree (data->all_type_units);

  VEC_free (dwarf2_section_info_def, data->types);

  if (data->dwo_files)
    free_dwo_files (data->dwo_files, objfile);
  if (data->dwp_file)
    gdb_bfd_unref (data->dwp_file->dbfd);

  if (data->dwz_file && data->dwz_file->dwz_bfd)
    gdb_bfd_unref (data->dwz_file->dwz_bfd);
}


/* The "save gdb-index" command.  */

/* The contents of the hash table we create when building the string
   table.  */
struct strtab_entry
{
  offset_type offset;
  const char *str;
};

/* Hash function for a strtab_entry.

   Function is used only during write_hash_table so no index format backward
   compatibility is needed.  */

static hashval_t
hash_strtab_entry (const void *e)
{
  const struct strtab_entry *entry = e;
  return mapped_index_string_hash (INT_MAX, entry->str);
}

/* Equality function for a strtab_entry.  */

static int
eq_strtab_entry (const void *a, const void *b)
{
  const struct strtab_entry *ea = a;
  const struct strtab_entry *eb = b;
  return !strcmp (ea->str, eb->str);
}

/* Create a strtab_entry hash table.  */

static htab_t
create_strtab (void)
{
  return htab_create_alloc (100, hash_strtab_entry, eq_strtab_entry,
			    xfree, xcalloc, xfree);
}

/* Add a string to the constant pool.  Return the string's offset in
   host order.  */

static offset_type
add_string (htab_t table, struct obstack *cpool, const char *str)
{
  void **slot;
  struct strtab_entry entry;
  struct strtab_entry *result;

  entry.str = str;
  slot = htab_find_slot (table, &entry, INSERT);
  if (*slot)
    result = *slot;
  else
    {
      result = XNEW (struct strtab_entry);
      result->offset = obstack_object_size (cpool);
      result->str = str;
      obstack_grow_str0 (cpool, str);
      *slot = result;
    }
  return result->offset;
}

/* An entry in the symbol table.  */
struct symtab_index_entry
{
  /* The name of the symbol.  */
  const char *name;
  /* The offset of the name in the constant pool.  */
  offset_type index_offset;
  /* A sorted vector of the indices of all the CUs that hold an object
     of this name.  */
  VEC (offset_type) *cu_indices;
};

/* The symbol table.  This is a power-of-2-sized hash table.  */
struct mapped_symtab
{
  offset_type n_elements;
  offset_type size;
  struct symtab_index_entry **data;
};

/* Hash function for a symtab_index_entry.  */

static hashval_t
hash_symtab_entry (const void *e)
{
  const struct symtab_index_entry *entry = e;
  return iterative_hash (VEC_address (offset_type, entry->cu_indices),
			 sizeof (offset_type) * VEC_length (offset_type,
							    entry->cu_indices),
			 0);
}

/* Equality function for a symtab_index_entry.  */

static int
eq_symtab_entry (const void *a, const void *b)
{
  const struct symtab_index_entry *ea = a;
  const struct symtab_index_entry *eb = b;
  int len = VEC_length (offset_type, ea->cu_indices);
  if (len != VEC_length (offset_type, eb->cu_indices))
    return 0;
  return !memcmp (VEC_address (offset_type, ea->cu_indices),
		  VEC_address (offset_type, eb->cu_indices),
		  sizeof (offset_type) * len);
}

/* Destroy a symtab_index_entry.  */

static void
delete_symtab_entry (void *p)
{
  struct symtab_index_entry *entry = p;
  VEC_free (offset_type, entry->cu_indices);
  xfree (entry);
}

/* Create a hash table holding symtab_index_entry objects.  */

static htab_t
create_symbol_hash_table (void)
{
  return htab_create_alloc (100, hash_symtab_entry, eq_symtab_entry,
			    delete_symtab_entry, xcalloc, xfree);
}

/* Create a new mapped symtab object.  */

static struct mapped_symtab *
create_mapped_symtab (void)
{
  struct mapped_symtab *symtab = XNEW (struct mapped_symtab);
  symtab->n_elements = 0;
  symtab->size = 1024;
  symtab->data = XCNEWVEC (struct symtab_index_entry *, symtab->size);
  return symtab;
}

/* Destroy a mapped_symtab.  */

static void
cleanup_mapped_symtab (void *p)
{
  struct mapped_symtab *symtab = p;
  /* The contents of the array are freed when the other hash table is
     destroyed.  */
  xfree (symtab->data);
  xfree (symtab);
}

/* Find a slot in SYMTAB for the symbol NAME.  Returns a pointer to
   the slot.
   
   Function is used only during write_hash_table so no index format backward
   compatibility is needed.  */

static struct symtab_index_entry **
find_slot (struct mapped_symtab *symtab, const char *name)
{
  offset_type index, step, hash = mapped_index_string_hash (INT_MAX, name);

  index = hash & (symtab->size - 1);
  step = ((hash * 17) & (symtab->size - 1)) | 1;

  for (;;)
    {
      if (!symtab->data[index] || !strcmp (name, symtab->data[index]->name))
	return &symtab->data[index];
      index = (index + step) & (symtab->size - 1);
    }
}

/* Expand SYMTAB's hash table.  */

static void
hash_expand (struct mapped_symtab *symtab)
{
  offset_type old_size = symtab->size;
  offset_type i;
  struct symtab_index_entry **old_entries = symtab->data;

  symtab->size *= 2;
  symtab->data = XCNEWVEC (struct symtab_index_entry *, symtab->size);

  for (i = 0; i < old_size; ++i)
    {
      if (old_entries[i])
	{
	  struct symtab_index_entry **slot = find_slot (symtab,
							old_entries[i]->name);
	  *slot = old_entries[i];
	}
    }

  xfree (old_entries);
}

/* Add an entry to SYMTAB.  NAME is the name of the symbol.
   CU_INDEX is the index of the CU in which the symbol appears.
   IS_STATIC is one if the symbol is static, otherwise zero (global).  */

static void
add_index_entry (struct mapped_symtab *symtab, const char *name,
		 int is_static, gdb_index_symbol_kind kind,
		 offset_type cu_index)
{
  struct symtab_index_entry **slot;
  offset_type cu_index_and_attrs;

  ++symtab->n_elements;
  if (4 * symtab->n_elements / 3 >= symtab->size)
    hash_expand (symtab);

  slot = find_slot (symtab, name);
  if (!*slot)
    {
      *slot = XNEW (struct symtab_index_entry);
      (*slot)->name = name;
      /* index_offset is set later.  */
      (*slot)->cu_indices = NULL;
    }

  cu_index_and_attrs = 0;
  DW2_GDB_INDEX_CU_SET_VALUE (cu_index_and_attrs, cu_index);
  DW2_GDB_INDEX_SYMBOL_STATIC_SET_VALUE (cu_index_and_attrs, is_static);
  DW2_GDB_INDEX_SYMBOL_KIND_SET_VALUE (cu_index_and_attrs, kind);

  /* We don't want to record an index value twice as we want to avoid the
     duplication.
     We process all global symbols and then all static symbols
     (which would allow us to avoid the duplication by only having to check
     the last entry pushed), but a symbol could have multiple kinds in one CU.
     To keep things simple we don't worry about the duplication here and
     sort and uniqufy the list after we've processed all symbols.  */
  VEC_safe_push (offset_type, (*slot)->cu_indices, cu_index_and_attrs);
}

/* qsort helper routine for uniquify_cu_indices.  */

static int
offset_type_compare (const void *ap, const void *bp)
{
  offset_type a = *(offset_type *) ap;
  offset_type b = *(offset_type *) bp;

  return (a > b) - (b > a);
}

/* Sort and remove duplicates of all symbols' cu_indices lists.  */

static void
uniquify_cu_indices (struct mapped_symtab *symtab)
{
  int i;

  for (i = 0; i < symtab->size; ++i)
    {
      struct symtab_index_entry *entry = symtab->data[i];

      if (entry
	  && entry->cu_indices != NULL)
	{
	  unsigned int next_to_insert, next_to_check;
	  offset_type last_value;

	  qsort (VEC_address (offset_type, entry->cu_indices),
		 VEC_length (offset_type, entry->cu_indices),
		 sizeof (offset_type), offset_type_compare);

	  last_value = VEC_index (offset_type, entry->cu_indices, 0);
	  next_to_insert = 1;
	  for (next_to_check = 1;
	       next_to_check < VEC_length (offset_type, entry->cu_indices);
	       ++next_to_check)
	    {
	      if (VEC_index (offset_type, entry->cu_indices, next_to_check)
		  != last_value)
		{
		  last_value = VEC_index (offset_type, entry->cu_indices,
					  next_to_check);
		  VEC_replace (offset_type, entry->cu_indices, next_to_insert,
			       last_value);
		  ++next_to_insert;
		}
	    }
	  VEC_truncate (offset_type, entry->cu_indices, next_to_insert);
	}
    }
}

/* Add a vector of indices to the constant pool.  */

static offset_type
add_indices_to_cpool (htab_t symbol_hash_table, struct obstack *cpool,
		      struct symtab_index_entry *entry)
{
  void **slot;

  slot = htab_find_slot (symbol_hash_table, entry, INSERT);
  if (!*slot)
    {
      offset_type len = VEC_length (offset_type, entry->cu_indices);
      offset_type val = MAYBE_SWAP (len);
      offset_type iter;
      int i;

      *slot = entry;
      entry->index_offset = obstack_object_size (cpool);

      obstack_grow (cpool, &val, sizeof (val));
      for (i = 0;
	   VEC_iterate (offset_type, entry->cu_indices, i, iter);
	   ++i)
	{
	  val = MAYBE_SWAP (iter);
	  obstack_grow (cpool, &val, sizeof (val));
	}
    }
  else
    {
      struct symtab_index_entry *old_entry = *slot;
      entry->index_offset = old_entry->index_offset;
      entry = old_entry;
    }
  return entry->index_offset;
}

/* Write the mapped hash table SYMTAB to the obstack OUTPUT, with
   constant pool entries going into the obstack CPOOL.  */

static void
write_hash_table (struct mapped_symtab *symtab,
		  struct obstack *output, struct obstack *cpool)
{
  offset_type i;
  htab_t symbol_hash_table;
  htab_t str_table;

  symbol_hash_table = create_symbol_hash_table ();
  str_table = create_strtab ();

  /* We add all the index vectors to the constant pool first, to
     ensure alignment is ok.  */
  for (i = 0; i < symtab->size; ++i)
    {
      if (symtab->data[i])
	add_indices_to_cpool (symbol_hash_table, cpool, symtab->data[i]);
    }

  /* Now write out the hash table.  */
  for (i = 0; i < symtab->size; ++i)
    {
      offset_type str_off, vec_off;

      if (symtab->data[i])
	{
	  str_off = add_string (str_table, cpool, symtab->data[i]->name);
	  vec_off = symtab->data[i]->index_offset;
	}
      else
	{
	  /* While 0 is a valid constant pool index, it is not valid
	     to have 0 for both offsets.  */
	  str_off = 0;
	  vec_off = 0;
	}

      str_off = MAYBE_SWAP (str_off);
      vec_off = MAYBE_SWAP (vec_off);

      obstack_grow (output, &str_off, sizeof (str_off));
      obstack_grow (output, &vec_off, sizeof (vec_off));
    }

  htab_delete (str_table);
  htab_delete (symbol_hash_table);
}

/* Struct to map psymtab to CU index in the index file.  */
struct psymtab_cu_index_map
{
  struct partial_symtab *psymtab;
  unsigned int cu_index;
};

static hashval_t
hash_psymtab_cu_index (const void *item)
{
  const struct psymtab_cu_index_map *map = item;

  return htab_hash_pointer (map->psymtab);
}

static int
eq_psymtab_cu_index (const void *item_lhs, const void *item_rhs)
{
  const struct psymtab_cu_index_map *lhs = item_lhs;
  const struct psymtab_cu_index_map *rhs = item_rhs;

  return lhs->psymtab == rhs->psymtab;
}

/* Helper struct for building the address table.  */
struct addrmap_index_data
{
  struct objfile *objfile;
  struct obstack *addr_obstack;
  htab_t cu_index_htab;

  /* Non-zero if the previous_* fields are valid.
     We can't write an entry until we see the next entry (since it is only then
     that we know the end of the entry).  */
  int previous_valid;
  /* Index of the CU in the table of all CUs in the index file.  */
  unsigned int previous_cu_index;
  /* Start address of the CU.  */
  CORE_ADDR previous_cu_start;
};

/* Write an address entry to OBSTACK.  */

static void
add_address_entry (struct objfile *objfile, struct obstack *obstack,
		   CORE_ADDR start, CORE_ADDR end, unsigned int cu_index)
{
  offset_type cu_index_to_write;
  gdb_byte addr[8];
  CORE_ADDR baseaddr;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  store_unsigned_integer (addr, 8, BFD_ENDIAN_LITTLE, start - baseaddr);
  obstack_grow (obstack, addr, 8);
  store_unsigned_integer (addr, 8, BFD_ENDIAN_LITTLE, end - baseaddr);
  obstack_grow (obstack, addr, 8);
  cu_index_to_write = MAYBE_SWAP (cu_index);
  obstack_grow (obstack, &cu_index_to_write, sizeof (offset_type));
}

/* Worker function for traversing an addrmap to build the address table.  */

static int
add_address_entry_worker (void *datap, CORE_ADDR start_addr, void *obj)
{
  struct addrmap_index_data *data = datap;
  struct partial_symtab *pst = obj;

  if (data->previous_valid)
    add_address_entry (data->objfile, data->addr_obstack,
		       data->previous_cu_start, start_addr,
		       data->previous_cu_index);

  data->previous_cu_start = start_addr;
  if (pst != NULL)
    {
      struct psymtab_cu_index_map find_map, *map;
      find_map.psymtab = pst;
      map = htab_find (data->cu_index_htab, &find_map);
      gdb_assert (map != NULL);
      data->previous_cu_index = map->cu_index;
      data->previous_valid = 1;
    }
  else
      data->previous_valid = 0;

  return 0;
}

/* Write OBJFILE's address map to OBSTACK.
   CU_INDEX_HTAB is used to map addrmap entries to their CU indices
   in the index file.  */

static void
write_address_map (struct objfile *objfile, struct obstack *obstack,
		   htab_t cu_index_htab)
{
  struct addrmap_index_data addrmap_index_data;

  /* When writing the address table, we have to cope with the fact that
     the addrmap iterator only provides the start of a region; we have to
     wait until the next invocation to get the start of the next region.  */

  addrmap_index_data.objfile = objfile;
  addrmap_index_data.addr_obstack = obstack;
  addrmap_index_data.cu_index_htab = cu_index_htab;
  addrmap_index_data.previous_valid = 0;

  addrmap_foreach (objfile->psymtabs_addrmap, add_address_entry_worker,
		   &addrmap_index_data);

  /* It's highly unlikely the last entry (end address = 0xff...ff)
     is valid, but we should still handle it.
     The end address is recorded as the start of the next region, but that
     doesn't work here.  To cope we pass 0xff...ff, this is a rare situation
     anyway.  */
  if (addrmap_index_data.previous_valid)
    add_address_entry (objfile, obstack,
		       addrmap_index_data.previous_cu_start, (CORE_ADDR) -1,
		       addrmap_index_data.previous_cu_index);
}

/* Return the symbol kind of PSYM.  */

static gdb_index_symbol_kind
symbol_kind (struct partial_symbol *psym)
{
  domain_enum domain = PSYMBOL_DOMAIN (psym);
  enum address_class aclass = PSYMBOL_CLASS (psym);

  switch (domain)
    {
    case VAR_DOMAIN:
      switch (aclass)
	{
	case LOC_BLOCK:
	  return GDB_INDEX_SYMBOL_KIND_FUNCTION;
	case LOC_TYPEDEF:
	  return GDB_INDEX_SYMBOL_KIND_TYPE;
	case LOC_COMPUTED:
	case LOC_CONST_BYTES:
	case LOC_OPTIMIZED_OUT:
	case LOC_STATIC:
	  return GDB_INDEX_SYMBOL_KIND_VARIABLE;
	case LOC_CONST:
	  /* Note: It's currently impossible to recognize psyms as enum values
	     short of reading the type info.  For now punt.  */
	  return GDB_INDEX_SYMBOL_KIND_VARIABLE;
	default:
	  /* There are other LOC_FOO values that one might want to classify
	     as variables, but dwarf2read.c doesn't currently use them.  */
	  return GDB_INDEX_SYMBOL_KIND_OTHER;
	}
    case STRUCT_DOMAIN:
      return GDB_INDEX_SYMBOL_KIND_TYPE;
    default:
      return GDB_INDEX_SYMBOL_KIND_OTHER;
    }
}

/* Add a list of partial symbols to SYMTAB.  */

static void
write_psymbols (struct mapped_symtab *symtab,
		htab_t psyms_seen,
		struct partial_symbol **psymp,
		int count,
		offset_type cu_index,
		int is_static)
{
  for (; count-- > 0; ++psymp)
    {
      struct partial_symbol *psym = *psymp;
      void **slot;

      if (SYMBOL_LANGUAGE (psym) == language_ada)
	error (_("Ada is not currently supported by the index"));

      /* Only add a given psymbol once.  */
      slot = htab_find_slot (psyms_seen, psym, INSERT);
      if (!*slot)
	{
	  gdb_index_symbol_kind kind = symbol_kind (psym);

	  *slot = psym;
	  add_index_entry (symtab, SYMBOL_SEARCH_NAME (psym),
			   is_static, kind, cu_index);
	}
    }
}

/* Write the contents of an ("unfinished") obstack to FILE.  Throw an
   exception if there is an error.  */

static void
write_obstack (FILE *file, struct obstack *obstack)
{
  if (fwrite (obstack_base (obstack), 1, obstack_object_size (obstack),
	      file)
      != obstack_object_size (obstack))
    error (_("couldn't data write to file"));
}

/* Unlink a file if the argument is not NULL.  */

static void
unlink_if_set (void *p)
{
  char **filename = p;
  if (*filename)
    unlink (*filename);
}

/* A helper struct used when iterating over debug_types.  */
struct signatured_type_index_data
{
  struct objfile *objfile;
  struct mapped_symtab *symtab;
  struct obstack *types_list;
  htab_t psyms_seen;
  int cu_index;
};

/* A helper function that writes a single signatured_type to an
   obstack.  */

static int
write_one_signatured_type (void **slot, void *d)
{
  struct signatured_type_index_data *info = d;
  struct signatured_type *entry = (struct signatured_type *) *slot;
  struct partial_symtab *psymtab = entry->per_cu.v.psymtab;
  gdb_byte val[8];

  write_psymbols (info->symtab,
		  info->psyms_seen,
		  info->objfile->global_psymbols.list
		  + psymtab->globals_offset,
		  psymtab->n_global_syms, info->cu_index,
		  0);
  write_psymbols (info->symtab,
		  info->psyms_seen,
		  info->objfile->static_psymbols.list
		  + psymtab->statics_offset,
		  psymtab->n_static_syms, info->cu_index,
		  1);

  store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE,
			  entry->per_cu.offset.sect_off);
  obstack_grow (info->types_list, val, 8);
  store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE,
			  entry->type_offset_in_tu.cu_off);
  obstack_grow (info->types_list, val, 8);
  store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, entry->signature);
  obstack_grow (info->types_list, val, 8);

  ++info->cu_index;

  return 1;
}

/* Recurse into all "included" dependencies and write their symbols as
   if they appeared in this psymtab.  */

static void
recursively_write_psymbols (struct objfile *objfile,
			    struct partial_symtab *psymtab,
			    struct mapped_symtab *symtab,
			    htab_t psyms_seen,
			    offset_type cu_index)
{
  int i;

  for (i = 0; i < psymtab->number_of_dependencies; ++i)
    if (psymtab->dependencies[i]->user != NULL)
      recursively_write_psymbols (objfile, psymtab->dependencies[i],
				  symtab, psyms_seen, cu_index);

  write_psymbols (symtab,
		  psyms_seen,
		  objfile->global_psymbols.list + psymtab->globals_offset,
		  psymtab->n_global_syms, cu_index,
		  0);
  write_psymbols (symtab,
		  psyms_seen,
		  objfile->static_psymbols.list + psymtab->statics_offset,
		  psymtab->n_static_syms, cu_index,
		  1);
}

/* Create an index file for OBJFILE in the directory DIR.  */

static void
write_psymtabs_to_index (struct objfile *objfile, const char *dir)
{
  struct cleanup *cleanup;
  char *filename, *cleanup_filename;
  struct obstack contents, addr_obstack, constant_pool, symtab_obstack;
  struct obstack cu_list, types_cu_list;
  int i;
  FILE *out_file;
  struct mapped_symtab *symtab;
  offset_type val, size_of_contents, total_len;
  struct stat st;
  htab_t psyms_seen;
  htab_t cu_index_htab;
  struct psymtab_cu_index_map *psymtab_cu_index_map;

  if (dwarf2_per_objfile->using_index)
    error (_("Cannot use an index to create the index"));

  if (VEC_length (dwarf2_section_info_def, dwarf2_per_objfile->types) > 1)
    error (_("Cannot make an index when the file has multiple .debug_types sections"));

  if (!objfile->psymtabs || !objfile->psymtabs_addrmap)
    return;

  if (stat (objfile_name (objfile), &st) < 0)
    perror_with_name (objfile_name (objfile));

  filename = concat (dir, SLASH_STRING, lbasename (objfile_name (objfile)),
		     INDEX_SUFFIX, (char *) NULL);
  cleanup = make_cleanup (xfree, filename);

  out_file = gdb_fopen_cloexec (filename, "wb");
  if (!out_file)
    error (_("Can't open `%s' for writing"), filename);

  cleanup_filename = filename;
  make_cleanup (unlink_if_set, &cleanup_filename);

  symtab = create_mapped_symtab ();
  make_cleanup (cleanup_mapped_symtab, symtab);

  obstack_init (&addr_obstack);
  make_cleanup_obstack_free (&addr_obstack);

  obstack_init (&cu_list);
  make_cleanup_obstack_free (&cu_list);

  obstack_init (&types_cu_list);
  make_cleanup_obstack_free (&types_cu_list);

  psyms_seen = htab_create_alloc (100, htab_hash_pointer, htab_eq_pointer,
				  NULL, xcalloc, xfree);
  make_cleanup_htab_delete (psyms_seen);

  /* While we're scanning CU's create a table that maps a psymtab pointer
     (which is what addrmap records) to its index (which is what is recorded
     in the index file).  This will later be needed to write the address
     table.  */
  cu_index_htab = htab_create_alloc (100,
				     hash_psymtab_cu_index,
				     eq_psymtab_cu_index,
				     NULL, xcalloc, xfree);
  make_cleanup_htab_delete (cu_index_htab);
  psymtab_cu_index_map = (struct psymtab_cu_index_map *)
    xmalloc (sizeof (struct psymtab_cu_index_map)
	     * dwarf2_per_objfile->n_comp_units);
  make_cleanup (xfree, psymtab_cu_index_map);

  /* The CU list is already sorted, so we don't need to do additional
     work here.  Also, the debug_types entries do not appear in
     all_comp_units, but only in their own hash table.  */
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
    {
      struct dwarf2_per_cu_data *per_cu
	= dwarf2_per_objfile->all_comp_units[i];
      struct partial_symtab *psymtab = per_cu->v.psymtab;
      gdb_byte val[8];
      struct psymtab_cu_index_map *map;
      void **slot;

      /* CU of a shared file from 'dwz -m' may be unused by this main file.
	 It may be referenced from a local scope but in such case it does not
	 need to be present in .gdb_index.  */
      if (psymtab == NULL)
	continue;

      if (psymtab->user == NULL)
	recursively_write_psymbols (objfile, psymtab, symtab, psyms_seen, i);

      map = &psymtab_cu_index_map[i];
      map->psymtab = psymtab;
      map->cu_index = i;
      slot = htab_find_slot (cu_index_htab, map, INSERT);
      gdb_assert (slot != NULL);
      gdb_assert (*slot == NULL);
      *slot = map;

      store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE,
			      per_cu->offset.sect_off);
      obstack_grow (&cu_list, val, 8);
      store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, per_cu->length);
      obstack_grow (&cu_list, val, 8);
    }

  /* Dump the address map.  */
  write_address_map (objfile, &addr_obstack, cu_index_htab);

  /* Write out the .debug_type entries, if any.  */
  if (dwarf2_per_objfile->signatured_types)
    {
      struct signatured_type_index_data sig_data;

      sig_data.objfile = objfile;
      sig_data.symtab = symtab;
      sig_data.types_list = &types_cu_list;
      sig_data.psyms_seen = psyms_seen;
      sig_data.cu_index = dwarf2_per_objfile->n_comp_units;
      htab_traverse_noresize (dwarf2_per_objfile->signatured_types,
			      write_one_signatured_type, &sig_data);
    }

  /* Now that we've processed all symbols we can shrink their cu_indices
     lists.  */
  uniquify_cu_indices (symtab);

  obstack_init (&constant_pool);
  make_cleanup_obstack_free (&constant_pool);
  obstack_init (&symtab_obstack);
  make_cleanup_obstack_free (&symtab_obstack);
  write_hash_table (symtab, &symtab_obstack, &constant_pool);

  obstack_init (&contents);
  make_cleanup_obstack_free (&contents);
  size_of_contents = 6 * sizeof (offset_type);
  total_len = size_of_contents;

  /* The version number.  */
  val = MAYBE_SWAP (8);
  obstack_grow (&contents, &val, sizeof (val));

  /* The offset of the CU list from the start of the file.  */
  val = MAYBE_SWAP (total_len);
  obstack_grow (&contents, &val, sizeof (val));
  total_len += obstack_object_size (&cu_list);

  /* The offset of the types CU list from the start of the file.  */
  val = MAYBE_SWAP (total_len);
  obstack_grow (&contents, &val, sizeof (val));
  total_len += obstack_object_size (&types_cu_list);

  /* The offset of the address table from the start of the file.  */
  val = MAYBE_SWAP (total_len);
  obstack_grow (&contents, &val, sizeof (val));
  total_len += obstack_object_size (&addr_obstack);

  /* The offset of the symbol table from the start of the file.  */
  val = MAYBE_SWAP (total_len);
  obstack_grow (&contents, &val, sizeof (val));
  total_len += obstack_object_size (&symtab_obstack);

  /* The offset of the constant pool from the start of the file.  */
  val = MAYBE_SWAP (total_len);
  obstack_grow (&contents, &val, sizeof (val));
  total_len += obstack_object_size (&constant_pool);

  gdb_assert (obstack_object_size (&contents) == size_of_contents);

  write_obstack (out_file, &contents);
  write_obstack (out_file, &cu_list);
  write_obstack (out_file, &types_cu_list);
  write_obstack (out_file, &addr_obstack);
  write_obstack (out_file, &symtab_obstack);
  write_obstack (out_file, &constant_pool);

  fclose (out_file);

  /* We want to keep the file, so we set cleanup_filename to NULL
     here.  See unlink_if_set.  */
  cleanup_filename = NULL;

  do_cleanups (cleanup);
}

/* Implementation of the `save gdb-index' command.
   
   Note that the file format used by this command is documented in the
   GDB manual.  Any changes here must be documented there.  */

static void
save_gdb_index_command (char *arg, int from_tty)
{
  struct objfile *objfile;

  if (!arg || !*arg)
    error (_("usage: save gdb-index DIRECTORY"));

  ALL_OBJFILES (objfile)
  {
    struct stat st;

    /* If the objfile does not correspond to an actual file, skip it.  */
    if (stat (objfile_name (objfile), &st) < 0)
      continue;

    dwarf2_per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);
    if (dwarf2_per_objfile)
      {
	volatile struct gdb_exception except;

	TRY_CATCH (except, RETURN_MASK_ERROR)
	  {
	    write_psymtabs_to_index (objfile, arg);
	  }
	if (except.reason < 0)
	  exception_fprintf (gdb_stderr, except,
			     _("Error while writing index for `%s': "),
			     objfile_name (objfile));
      }
  }
}



int dwarf2_always_disassemble;

static void
show_dwarf2_always_disassemble (struct ui_file *file, int from_tty,
				struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Whether to always disassemble "
		      "DWARF expressions is %s.\n"),
		    value);
}

static void
show_check_physname (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Whether to check \"physname\" is %s.\n"),
		    value);
}

void _initialize_dwarf2_read (void);

void
_initialize_dwarf2_read (void)
{
  struct cmd_list_element *c;

  dwarf2_objfile_data_key
    = register_objfile_data_with_cleanup (NULL, dwarf2_per_objfile_free);

  add_prefix_cmd ("dwarf2", class_maintenance, set_dwarf2_cmd, _("\
Set DWARF 2 specific variables.\n\
Configure DWARF 2 variables such as the cache size"),
                  &set_dwarf2_cmdlist, "maintenance set dwarf2 ",
                  0/*allow-unknown*/, &maintenance_set_cmdlist);

  add_prefix_cmd ("dwarf2", class_maintenance, show_dwarf2_cmd, _("\
Show DWARF 2 specific variables\n\
Show DWARF 2 variables such as the cache size"),
                  &show_dwarf2_cmdlist, "maintenance show dwarf2 ",
                  0/*allow-unknown*/, &maintenance_show_cmdlist);

  add_setshow_zinteger_cmd ("max-cache-age", class_obscure,
			    &dwarf2_max_cache_age, _("\
Set the upper bound on the age of cached dwarf2 compilation units."), _("\
Show the upper bound on the age of cached dwarf2 compilation units."), _("\
A higher limit means that cached compilation units will be stored\n\
in memory longer, and more total memory will be used.  Zero disables\n\
caching, which can slow down startup."),
			    NULL,
			    show_dwarf2_max_cache_age,
			    &set_dwarf2_cmdlist,
			    &show_dwarf2_cmdlist);

  add_setshow_boolean_cmd ("always-disassemble", class_obscure,
			   &dwarf2_always_disassemble, _("\
Set whether `info address' always disassembles DWARF expressions."), _("\
Show whether `info address' always disassembles DWARF expressions."), _("\
When enabled, DWARF expressions are always printed in an assembly-like\n\
syntax.  When disabled, expressions will be printed in a more\n\
conversational style, when possible."),
			   NULL,
			   show_dwarf2_always_disassemble,
			   &set_dwarf2_cmdlist,
			   &show_dwarf2_cmdlist);

  add_setshow_boolean_cmd ("dwarf2-read", no_class, &dwarf2_read_debug, _("\
Set debugging of the dwarf2 reader."), _("\
Show debugging of the dwarf2 reader."), _("\
When enabled, debugging messages are printed during dwarf2 reading\n\
and symtab expansion."),
			    NULL,
			    NULL,
			    &setdebuglist, &showdebuglist);

  add_setshow_zuinteger_cmd ("dwarf2-die", no_class, &dwarf2_die_debug, _("\
Set debugging of the dwarf2 DIE reader."), _("\
Show debugging of the dwarf2 DIE reader."), _("\
When enabled (non-zero), DIEs are dumped after they are read in.\n\
The value is the maximum depth to print."),
			     NULL,
			     NULL,
			     &setdebuglist, &showdebuglist);

  add_setshow_boolean_cmd ("check-physname", no_class, &check_physname, _("\
Set cross-checking of \"physname\" code against demangler."), _("\
Show cross-checking of \"physname\" code against demangler."), _("\
When enabled, GDB's internal \"physname\" code is checked against\n\
the demangler."),
			   NULL, show_check_physname,
			   &setdebuglist, &showdebuglist);

  add_setshow_boolean_cmd ("use-deprecated-index-sections",
			   no_class, &use_deprecated_index_sections, _("\
Set whether to use deprecated gdb_index sections."), _("\
Show whether to use deprecated gdb_index sections."), _("\
When enabled, deprecated .gdb_index sections are used anyway.\n\
Normally they are ignored either because of a missing feature or\n\
performance issue.\n\
Warning: This option must be enabled before gdb reads the file."),
			   NULL,
			   NULL,
			   &setlist, &showlist);

  c = add_cmd ("gdb-index", class_files, save_gdb_index_command,
	       _("\
Save a gdb-index file.\n\
Usage: save gdb-index DIRECTORY"),
	       &save_cmdlist);
  set_cmd_completer (c, filename_completer);

  dwarf2_locexpr_index = register_symbol_computed_impl (LOC_COMPUTED,
							&dwarf2_locexpr_funcs);
  dwarf2_loclist_index = register_symbol_computed_impl (LOC_COMPUTED,
							&dwarf2_loclist_funcs);

  dwarf2_locexpr_block_index = register_symbol_block_impl (LOC_BLOCK,
					&dwarf2_block_frame_base_locexpr_funcs);
  dwarf2_loclist_block_index = register_symbol_block_impl (LOC_BLOCK,
					&dwarf2_block_frame_base_loclist_funcs);
}
@


1.843
log
@bfd
	* bfd-in2.h: Rebuild.
	* opncls.c (bfd_get_alt_debug_link_info): Change type of
	buildid_len to bfd_size_type.
gdb
	* dwarf2read.c (dwarf2_get_dwz_file): Update for type change in
	bfd_get_alt_debug_link_info.
@
text
@d3281 1
a3281 1
				      qfn->num_file_names, sizeof (char *));
@


1.842
log
@fix PR symtab/15597

This patch fixes gdb PR symtab/15597.

The bug is that the .gnu_debugaltlink section includes the build-id of
the alt file, but gdb does not use it.

This patch fixes the problem by changing gdb to do what it ought to
always have done: verify the build id of the file found using the
filename in .gnu_debugaltlink; and if that does not match, try to find
the correct debug file using the build-id and debug-file-directory.

This patch touches BFD.  Previously, gdb had its own code for parsing
.gnu_debugaltlink; I changed it to use the BFD functions after those
were introduced.  However, the BFD functions are incorrect -- they
assume that .gnu_debugaltlink is formatted like .gnu_debuglink.
However, it it is not.  Instead, it consists of a file name followed
by the build-id -- no alignment, and the build-id is not a CRC.

Fixing this properly is a bit of a pain.  But, because
separate_alt_debug_file_exists just has a FIXME for the build-id case,
I did not fix it properly.  Instead I introduced a hack.  This leaves
BFD working just as well as it did before my patch.

I'm willing to do something better here but I could use some guidance
as to what.  It seems that the build-id code in BFD is largely punted
on.

FWIW gdb is the only user of bfd_get_alt_debug_link_info outside of
BFD itself.

I moved the build-id logic out of elfread.c and into a new file.
This seemed cleanest to me.

Writing a test case was a bit of a pain.  I added a couple new
features to the DWARF assembler to handle this.

Built and regtested on x86-64 Fedora 18.

	* bfd-in2.h: Rebuild.
	* opncls.c (bfd_get_alt_debug_link_info): Add buildid_len
	parameter.  Change type of buildid_out.  Update.
	(get_alt_debug_link_info_shim): New function.
	(bfd_follow_gnu_debuglink): Use it.

	* Makefile.in (SFILES): Add build-id.c.
	(HFILES_NO_SRCDIR): Add build-id.h.
	* build-id.c: New file, largely from elfread.c.  Modified
	most functions.
	* build-id.h: New file.
	* dwarf2read.c (dwarf2_get_dwz_file): Update for change to
	bfd_get_alt_debug_link_info.  Verify dwz file's build-id.
	Search for dwz file using build-id.
	* elfread.c (build_id_bfd_get, build_id_verify)
	(build_id_to_debug_filename, find_separate_debug_file): Remove.

	* gdb.dwarf2/dwzbuildid.exp: New file.
	* lib/dwarf.exp (Dwarf::_section): Add "flags" and "type"
	parameters.
	(Dwarf::_defer_output): Change "section" parameter to
	"section_spec"; update.
	(Dwarf::gnu_debugaltlink, Dwarf::_note, Dwarf::build_id): New
	procs.
@
text
@d2368 1
d2377 1
a2377 1
				      &buildid_len, &buildid);
d2388 2
@


1.841
log
@(dwarf2_section_info): Comment tweaks missed in previous checkin.
@
text
@d72 1
d2368 2
a2369 1
  unsigned long buildid;
d2376 1
a2376 1
				      &buildid);
d2385 1
d2402 2
a2403 2
  /* The format is just a NUL-terminated file name, followed by the
     build-id.  For now, though, we ignore the build-id.  */
d2405 9
d2415 1
a2415 2
    error (_("could not read '%s': %s"), filename,
	   bfd_errmsg (bfd_get_error ()));
d2417 3
a2419 6
  if (!bfd_check_format (dwz_bfd, bfd_object))
    {
      gdb_bfd_unref (dwz_bfd);
      error (_("file '%s' was not usable: %s"), filename,
	     bfd_errmsg (bfd_get_error ()));
    }
@


1.840
log
@	Add support for DWP file format version 2.
	* NEWS: Mention support for DWP file format version 2.
	* dwarf2read.c (dwarf2_section_info): Convert asection field to a
	union of asection, containing_section.  New fields virtual_offset
	and is_virtual.  Change type of readin filed from int to char.
	(dwo_sections, dwo_file): Tweak comments.
	(dwp_v2_section_ids): New enum.
	(dwp_sections): New fields abbrev, info, line, loc, macinfo, macro,
	str_offsets, types.
	(virtual_v1_dwo_sections): Renamed from virtual_dwo_sections.
	All uses updated.
	(virtual_v2_dwo_sections): New struct.
	(dwp_hash_table): New fields version, nr_columns.  Change type of
	section_pool field to a union.
	(dwp_file): New field version.
	(dwarf2_has_info): Check for virtual sections.
	(get_containing_section): New function.
	(get_section_bfd_owner, get_section_bfd_section): Call it.
	(dwarf2_locate_sections): Update.
	(dwarf2_section_empty_p): Update.
	(dwarf2_read_section): Handle virtual sections.
	(locate_dwz_sections): Update.
	(create_dwp_hash_table): Document and handle V2 format.
	(locate_v1_virtual_dwo_sections): Renamed from
	locate_virtual_dwo_sections and update.  All callers updated.
	(create_dwo_unit_in_dwp_v1): Renamed from create_dwo_in_dwp.
	Delete arg htab.  Rename arg section_index to unit_index.
	All callers updated.
	(MAX_NR_V1_DWO_SECTIONS): Renamed from MAX_NR_DWO_SECTIONS.
	All uses updated.
	(create_dwp_v2_section, create_dwo_unit_in_dwp_v2): New functions.
	(lookup_dwo_unit_in_dwp): Add V2 support.
	(dwarf2_locate_dwo_sections): Update.
	(dwarf2_locate_common_dwp_sections): Renamed from
	dwarf2_locate_dwp_sections and update.  All callers updated.
	(dwarf2_locate_v2_dwp_sections): New function.
	(open_and_init_dwp_file): Add V2 support.
	(read_str_index): New locals str_section, str_offsets_section.
@
text
@d123 1
a123 1
    /* If this is a real section, the bfd section.  Otherwise NULL.  */
d126 1
a126 1
       section.  Otherwise NULL.  */
@


1.839
log
@	* dwarf2read.c (dwarf2_section_info): Add comment.
	(dwp_file): Split loaded_cutus into loaded_cus, loaded_tus.
	All uses updated.
	(dwarf2_section_empty_p): Rename arg from "info" to "section".
	(dwarf2_read_section): Delete unused local "header".  Add section
	name to error message.
	(create_dwo_in_dwp): Tweak comment.
	(MAX_NR_DWO_SECTIONS): Combine count of .debug_macro + .debug_macinfo.
@
text
@d103 16
d121 8
a128 1
  asection *asection;
d131 1
d133 3
d137 4
a140 1
  int readin;
d744 1
a744 1
/* These sections are what may appear in a DWO file.  */
d783 9
d818 3
a820 1
  /* Section info for this file.  */
d839 1
d843 17
a859 2
  /* The .debug_info.dwo, .debug_types.dwo, and other sections are referenced
     by section number.  We don't need to record them here.  */
d862 2
a863 1
/* These sections are what may appear in a virtual DWO file.  */
d865 1
a865 1
struct virtual_dwo_sections
d878 31
d913 1
d915 23
a937 1
  const gdb_byte *hash_table, *unit_table, *section_pool;
d947 3
d966 2
a967 1
  /* Table to map ELF section numbers to their sections.  */
d1965 13
a1977 2
  return (dwarf2_per_objfile->info.asection != NULL
	  && dwarf2_per_objfile->abbrev.asection != NULL);
d1985 6
a1990 1
  return section->asection->owner;
d1999 6
a2004 1
  return section->asection;
d2042 1
a2042 1
   SECTION must exist.  */
d2089 1
a2089 1
      dwarf2_per_objfile->info.asection = sectp;
d2094 1
a2094 1
      dwarf2_per_objfile->abbrev.asection = sectp;
d2099 1
a2099 1
      dwarf2_per_objfile->line.asection = sectp;
d2104 1
a2104 1
      dwarf2_per_objfile->loc.asection = sectp;
d2109 1
a2109 1
      dwarf2_per_objfile->macinfo.asection = sectp;
d2114 1
a2114 1
      dwarf2_per_objfile->macro.asection = sectp;
d2119 1
a2119 1
      dwarf2_per_objfile->str.asection = sectp;
d2124 1
a2124 1
      dwarf2_per_objfile->addr.asection = sectp;
d2129 1
a2129 1
      dwarf2_per_objfile->frame.asection = sectp;
d2134 1
a2134 1
      dwarf2_per_objfile->eh_frame.asection = sectp;
d2139 1
a2139 1
      dwarf2_per_objfile->ranges.asection = sectp;
d2147 1
a2147 1
      type_section.asection = sectp;
d2155 1
a2155 1
      dwarf2_per_objfile->gdb_index.asection = sectp;
d2170 3
a2172 1
  return section->asection == NULL || section->size == 0;
d2198 25
d2325 1
a2325 1
      dwz_file->abbrev.asection = sectp;
d2330 1
a2330 1
      dwz_file->info.asection = sectp;
d2335 1
a2335 1
      dwz_file->str.asection = sectp;
d2340 1
a2340 1
      dwz_file->line.asection = sectp;
d2345 1
a2345 1
      dwz_file->macro.asection = sectp;
d2350 1
a2350 1
      dwz_file->gdb_index.asection = sectp;
a9184 4
   We assume that N and M will not exceed 2^32 - 1.

   The size of the hash table, M, must be 2^k such that 2^k > 3*N/2.

d9197 83
d9295 1
a9295 13
   to stop at an unused slot or find the match.

   The pool of section numbers begins immediately following the hash table
   (at offset 16 + 12 * M from the beginning of the section).  The pool of
   section numbers consists of an array of 32-bit words (using the byte order
   of the application binary).  Each item in the array is indexed starting
   from 0.  The hash table entry provides the index of the first section
   number in the set.  Additional section numbers in the set follow, and the
   set is terminated by a 0 entry (section number 0 is not used in ELF).

   In each set of section numbers, the .debug_info.dwo or .debug_types.dwo
   section must be the first entry in the set, and the .debug_abbrev.dwo must
   be the second entry. Other members of the set may follow in any order.  */
d9309 1
a9309 1
  uint32_t version, nr_units, nr_slots;
d9325 6
a9330 1
  index_ptr += 8; /* Skip the unused word.  */
d9336 1
a9336 1
  if (version != 1)
d9350 2
d9356 94
a9449 1
  htab->section_pool = htab->unit_table + sizeof (uint32_t) * nr_slots;
d9458 1
a9458 1
   read comes from the DWP hash table, not the full ELF section table.
d9463 2
a9464 2
locate_virtual_dwo_sections (asection *sectp,
			     struct virtual_dwo_sections *sections)
d9471 1
a9471 1
      if (sections->abbrev.asection != NULL)
d9473 1
a9473 1
      sections->abbrev.asection = sectp;
d9480 1
a9480 1
      if (sections->info_or_types.asection != NULL)
d9482 1
a9482 1
      sections->info_or_types.asection = sectp;
d9488 1
a9488 1
      if (sections->line.asection != NULL)
d9490 1
a9490 1
      sections->line.asection = sectp;
d9496 1
a9496 1
      if (sections->loc.asection != NULL)
d9498 1
a9498 1
      sections->loc.asection = sectp;
d9504 1
a9504 1
      if (sections->macinfo.asection != NULL)
d9506 1
a9506 1
      sections->macinfo.asection = sectp;
d9512 1
a9512 1
      if (sections->macro.asection != NULL)
d9514 1
a9514 1
      sections->macro.asection = sectp;
d9520 1
a9520 1
      if (sections->str_offsets.asection != NULL)
d9522 1
a9522 1
      sections->str_offsets.asection = sectp;
d9534 4
a9537 4
/* Create a dwo_unit object for the DWO with signature SIGNATURE.
   HTAB is the hash table from the DWP file.
   SECTION_INDEX is the index of the DWO in HTAB.
   COMP_DIR is the DW_AT_comp_dir attribute of the referencing CU.  */
d9540 4
a9543 5
create_dwo_in_dwp (struct dwp_file *dwp_file,
		   const struct dwp_hash_table *htab,
		   uint32_t section_index,
		   const char *comp_dir,
		   ULONGEST signature, int is_debug_types)
d9546 2
d9552 1
a9552 1
  struct virtual_dwo_sections sections;
d9559 2
d9563 1
a9563 1
      fprintf_unfiltered (gdb_stdlog, "Reading %s %s/%s in DWP file: %s\n",
d9565 1
a9565 1
			  pulongest (section_index), hex_string (signature),
d9573 1
a9573 1
#define MAX_NR_DWO_SECTIONS \
d9585 1
a9585 1
  for (i = 0; i < MAX_NR_DWO_SECTIONS; ++i)
d9590 2
a9591 2
		      htab->section_pool
		      + (section_index + i) * sizeof (uint32_t));
d9603 1
a9603 1
      if (! locate_virtual_dwo_sections (sectp, &sections))
d9619 1
a9619 1
  if (i == MAX_NR_DWO_SECTIONS)
d9696 218
d9954 12
a9965 2
	  *slot = create_dwo_in_dwp (dwp_file, dwp_htab, unit_index,
				     comp_dir, signature, is_debug_types);
d10084 1
a10084 1
      dwo_sections->abbrev.asection = sectp;
d10089 1
a10089 1
      dwo_sections->info.asection = sectp;
d10094 1
a10094 1
      dwo_sections->line.asection = sectp;
d10099 1
a10099 1
      dwo_sections->loc.asection = sectp;
d10104 1
a10104 1
      dwo_sections->macinfo.asection = sectp;
d10109 1
a10109 1
      dwo_sections->macro.asection = sectp;
d10114 1
a10114 1
      dwo_sections->str.asection = sectp;
d10119 1
a10119 1
      dwo_sections->str_offsets.asection = sectp;
d10127 1
a10127 1
      type_section.asection = sectp;
d10177 2
a10178 1
   size of each of the DWP debugging sections we are interested in.  */
d10181 2
a10182 1
dwarf2_locate_dwp_sections (bfd *abfd, asection *sectp, void *dwp_file_ptr)
d10189 1
a10189 1
     .debug_cu_index,.debug_tu_index tables use.  */
d10196 1
a10196 1
      dwp_file->sections.str.asection = sectp;
d10201 1
a10201 1
      dwp_file->sections.cu_index.asection = sectp;
d10206 1
a10206 1
      dwp_file->sections.tu_index.asection = sectp;
d10211 60
d10388 1
a10388 1
  bfd_map_over_sections (dbfd, dwarf2_locate_dwp_sections, dwp_file);
d10394 14
d16165 3
a16167 1
  struct dwo_sections *sections = &reader->dwo_file->sections;
d16172 3
a16174 3
  dwarf2_read_section (objfile, &sections->str);
  dwarf2_read_section (objfile, &sections->str_offsets);
  if (sections->str.buffer == NULL)
d16178 1
a16178 1
  if (sections->str_offsets.buffer == NULL)
d16182 1
a16182 1
  if (str_index * cu->header.offset_size >= sections->str_offsets.size)
d16186 1
a16186 1
  info_ptr = (sections->str_offsets.buffer
d16192 1
a16192 1
  if (str_offset >= sections->str.size)
d16196 1
a16196 1
  return (const char *) (sections->str.buffer + str_offset);
@


1.838
log
@	* dwarf2read.c (die_reader_specs): Tweak comment.
	(get_section_bfd_owner, get_section_bfd_section): New functions.
	(get_section_name, get_section_file_name): New functions.
	(get_section_id, get_section_flags): New functions.
	(*): Use new functions to access section fields.
@
text
@d106 1
d745 1
a745 1
  /* Same as dwarf2_per_cu_data:{offset,length} but for the DWO section.  */
d847 3
a849 2
  /* Table of loaded CUs/TUs.  Each entry is a struct dwo_unit *.  */
  htab_t loaded_cutus;
d2031 1
a2031 1
dwarf2_section_empty_p (struct dwarf2_section_info *info)
d2033 1
a2033 1
  return info->asection == NULL || info->size == 0;
a2047 1
  unsigned char header[4];
d2086 5
a2090 2
    error (_("Dwarf Error: Can't read DWARF data from '%s'"),
	   bfd_get_filename (abfd));
d9235 1
a9235 1
  /* Fetch the sections of this DWO.
d9245 1
a9245 2
   + 1 /* .debug_macro */ \
   + 1 /* .debug_macinfo */ \
d9381 4
a9384 1
  slot = htab_find_slot (dwp_file->loaded_cutus, &find_dwo_cu, INSERT);
d9770 2
a9771 1
  dwp_file->loaded_cutus = allocate_dwp_loaded_cutus_table (objfile);
@


1.837
log
@	* dwarf2read.c (struct dwo_file): Add/tweak comments.
	(lookup_dwo_unit_in_dwp): Renamed from lookup_dwo_in_dwp.  Remove
	arg "htab".  All callers updated.
	(create_debug_types_hash_table): Remove redundant copy of
	abbrev_section.
	(create_dwo_in_dwp): Tweak comments.
	(read_str_index): Tweak comment.  Record dwarf form name in static
	local.
@
text
@d877 1
a877 1
  /* die_section->asection->owner.  */
d1248 4
d1778 2
a1779 2
	     section->asection->name,
	     bfd_get_filename (section->asection->owner));
d1851 63
d2036 2
a2037 2
   the section comes from.  E.g., for DWO files INFO->asection->owner
   is the bfd of the DWO file.
d2043 1
a2043 1
  asection *sectp = info->asection;
d2056 1
a2056 1
  abfd = sectp->owner;
d2080 3
d2141 1
a2141 1
  *sectp = info->asection;
d2811 1
a2811 1
  if ((bfd_get_file_flags (section->asection) & SEC_HAS_CONTENTS) == 0)
d4062 2
a4063 2
  bfd *abfd = section->asection->owner;
  const char *filename = bfd_get_filename (abfd);
d4099 1
a4099 1
  bfd *abfd = section->asection->owner;
d4129 1
a4129 1
  bfd *abfd = section->asection->owner;
d4158 1
a4158 1
  bfd *abfd = section->asection->owner;
d4310 1
a4310 1
			bfd_get_filename (abbrev_section->asection->owner));
d4326 2
a4327 2
	 not present, in which case section->asection will be NULL.  */
      abfd = section->asection->owner;
d4686 1
a4686 1
  reader->abfd = section->asection->owner;
d4792 1
a4792 1
  abfd = section->asection->owner;
d4888 1
a4888 1
			  bfd_section_name (abfd, section->asection),
d5056 1
a5056 1
  bfd *abfd = section->asection->owner;
d5300 1
a5300 1
  bfd *abfd = section->asection->owner;
d6137 1
a6137 1
  bfd *abfd = section->asection->owner;
d6141 2
a6142 1
			section->asection->name, bfd_get_filename (abfd));
d8943 1
a8943 1
  abfd = section->asection->owner;
d8948 2
a8949 2
			  bfd_section_name (abfd, section->asection),
			  bfd_get_filename (abfd));
d9275 2
a9276 2
      || sections.info_or_types.asection == NULL
      || sections.abbrev.asection == NULL)
d9300 4
a9303 6
		sections.abbrev.asection ? sections.abbrev.asection->id : 0,
		sections.line.asection ? sections.line.asection->id : 0,
		sections.loc.asection ? sections.loc.asection->id : 0,
		(sections.str_offsets.asection
		? sections.str_offsets.asection->id
		: 0));
d13761 1
a13761 2
			  bfd_section_name (reader->abfd,
					    reader->die_section->asection),
d13843 1
a13843 2
			  bfd_section_name (reader->abfd,
					    reader->die_section->asection),
d13915 1
a13915 1
  bfd *abfd = section->asection->owner;
d15851 1
a15851 1
  abfd = section->asection->owner;
d19379 1
a19379 2
		   form,
		   section->asection->name);
a19708 1
		include_bfd = dwz->macro.asection->owner;
d19710 1
d19819 1
a19819 1
  abfd = section->asection->owner;
@


1.836
log
@	* symfile.h (struct quick_symbol_functions): Reorg arg list of
	map_matching_symbols so objfile is first.  All uses updated.
	* dwarf2read.c (dw2_map_matching_symbols): Update signature.
	* psymtab.c (map_matching_symbols_psymtab): Update signature.
@
text
@d753 9
a761 2
   This includes virtual DWO files that have been packaged into a
   DWP file.  */
d840 1
a840 1
  /* Table of CUs in the file. */
d1709 3
a1711 3
static struct dwo_unit *lookup_dwo_in_dwp
  (struct dwp_file *dwp_file, const struct dwp_hash_table *htab,
   const char *comp_dir, ULONGEST signature, int is_debug_types);
a4247 1
      struct dwarf2_section_info *abbrev_section;
a4258 5
      if (dwo_file)
	abbrev_section = &dwo_file->sections.abbrev;
      else
	abbrev_section = &dwarf2_per_objfile->abbrev;

d4555 2
a4556 2
  dwo_entry = lookup_dwo_in_dwp (dwp_file, dwp_file->tus, NULL,
				 sig, 1 /* is_debug_types */);
d9223 2
a9224 2
     file, we want to combine them back into a virtual DWO file to save space
     (fewer struct dwo_file objects to allocated).  Remember that for really
d9259 1
a9259 1
      /* The info or types section is assigned later to dwo_unit,
d9264 2
a9265 1
	 for it, invalidating all the pointers into the current copy.  */
d9285 1
a9285 1
  /* offset, length, type_offset_in_tu are set later.  */
d9290 2
a9291 1
/* Lookup the DWO with SIGNATURE in DWP_FILE.  */
d9294 2
a9295 4
lookup_dwo_in_dwp (struct dwp_file *dwp_file,
		   const struct dwp_hash_table *htab,
		   const char *comp_dir,
		   ULONGEST signature, int is_debug_types)
d9297 2
d9300 1
a9300 1
  uint32_t mask = htab->nr_slots - 1;
d9315 1
a9315 1
  for (i = 0; i < htab->nr_slots; ++i)
d9320 1
a9320 1
	read_8_bytes (dbfd, htab->hash_table + hash * sizeof (uint64_t));
d9323 3
a9325 2
	  uint32_t section_index =
	    read_4_bytes (dbfd, htab->unit_table + hash * sizeof (uint32_t));
d9327 1
a9327 1
	  *slot = create_dwo_in_dwp (dwp_file, htab, section_index,
d9763 2
a9764 2
	    lookup_dwo_in_dwp (dwp_file, dwp_htab, comp_dir,
			       signature, is_debug_types);
d15443 2
a15444 1
/* Given a DW_AT_str_index, fetch the string.  */
d15456 1
d15461 1
a15461 1
    error (_("DW_FORM_str_index used without .debug_str.dwo section"
d15463 1
a15463 1
	   (long) cu->header.offset.sect_off, dwo_name);
d15465 1
a15465 1
    error (_("DW_FORM_str_index used without .debug_str_offsets.dwo section"
d15467 1
a15467 1
	   (long) cu->header.offset.sect_off, dwo_name);
d15469 1
a15469 1
    error (_("DW_FORM_str_index pointing outside of .debug_str_offsets.dwo"
d15471 1
a15471 1
	   (long) cu->header.offset.sect_off, dwo_name);
d15479 1
a15479 1
    error (_("Offset from DW_FORM_str_index pointing outside of"
d15481 1
a15481 1
	   (long) cu->header.offset.sect_off, dwo_name);
@


1.835
log
@Support .dwp with the name of symlinked binary file

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* dwarf2read.c (open_and_init_dwp_file): Try open_dwp_file also with
	objfile->original_name.

gdb/testsuite/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.dwarf2/dwp-symlink.c: New file.
	* gdb.dwarf2/dwp-symlink.exp: New file.
@
text
@d3481 3
a3483 2
dw2_map_matching_symbols (const char * name, domain_enum namespace,
			  struct objfile *objfile, int global,
@


1.834
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d9651 3
a9653 1
  dwp_name = xstrprintf ("%s.dwp", objfile_name (dwarf2_per_objfile->objfile));
d9657 9
@


1.833
log
@	* dwarf2read.c: Move definitions of complaint functions to after
	forward declarations of local functions.
@
text
@d2142 1
a2142 1
      char *abs = gdb_realpath (dwarf2_per_objfile->objfile->name);
d2834 1
a2834 1
  if (!read_index_from_section (objfile, objfile->name,
d3253 2
a3254 1
		       " [in module %s]"), dwarf2_per_objfile->objfile->name);
d3651 1
a3651 1
			   " [in module %s]"), objfile->name);
d4569 1
a4569 1
	     objfile->name);
d4881 1
a4881 1
	       dwo_name, this_cu->objfile->name);
d5984 1
a5984 1
			  objfile->name);
d6023 1
a6023 1
			objfile->name);
d6223 1
a6223 1
			   cu->objfile->name);
d7015 1
a7015 1
			  dwarf2_per_objfile->objfile->name);
d7062 1
a7062 1
			  dwarf2_per_objfile->objfile->name);
d7302 1
a7302 1
				: cu->objfile->name),
d7670 1
a7670 1
	     cu->objfile->name);
d8201 2
a8202 1
		     physname, canon, mangled, die->offset.sect_off, objfile->name);
d8331 1
a8331 1
		       child_die->offset.sect_off, objfile->name);
d8352 1
a8352 1
		       child_die->offset.sect_off, objfile->name);
d8910 1
a8910 1
			 dwo_file->dwo_name, objfile->name);
d9651 1
a9651 1
  dwp_name = xstrprintf ("%s.dwp", dwarf2_per_objfile->objfile->name);
d9823 1
a9823 1
	   this_unit->offset.sect_off, objfile->name);
d10338 1
a10338 1
		 die->offset.sect_off, objfile->name);
d10354 2
a10355 1
		 paddress (gdbarch, pc), die->offset.sect_off, objfile->name);
d10370 2
a10371 1
		     child_die->tag, child_die->offset.sect_off, objfile->name);
d10429 1
a10429 1
		       die->offset.sect_off, objfile->name);
d10475 1
a10475 1
		       die->offset.sect_off, objfile->name);
d10488 1
a10488 1
		       die->offset.sect_off, objfile->name);
d10497 1
a10497 1
	       die->offset.sect_off, objfile->name);
d10538 1
a10538 1
			 child_die->offset.sect_off, objfile->name);
d10549 1
a10549 1
		     child_die->offset.sect_off, objfile->name);
d10569 1
a10569 1
			 child_die->offset.sect_off, objfile->name);
d10580 1
a10580 1
		     child_die->offset.sect_off, objfile->name);
d10598 1
a10598 1
		       child_die->offset.sect_off, objfile->name);
d10720 1
a10720 1
		       " [in module %s]"), objfile->name);
d11061 1
a11061 1
			       " [in module %s]"), objfile->name);
d12668 2
a12669 1
			     child_die->offset.sect_off, cu->objfile->name);
d13293 1
a13293 1
		 die->offset.sect_off, objfile->name);
d13461 1
a13461 1
	       die->offset.sect_off, cu->objfile->name);
d14153 1
a14153 1
		   part_die->offset.sect_off, objfile->name);
d14469 1
a14469 1
		     part_die->offset.sect_off, objfile->name);
d14481 1
a14481 1
		     part_die->offset.sect_off, objfile->name);
d15315 1
a15315 1
	   objfile->name);
d15319 1
a15319 1
	   objfile->name);
d15434 1
a15434 1
  const char *dwo_name = objfile->name;
d16089 1
a16089 1
				 line_offset, objfile->name);
d17116 1
a17116 1
	     "[in module %s]"), cu->objfile->name);
d17130 1
a17130 1
			objfile->name,
d17184 1
a17184 1
		 objfile->name);
d18097 1
a18097 1
	     (*ref_cu)->objfile->name);
d18172 2
a18173 1
	   offset.sect_off, src_die->offset.sect_off, cu->objfile->name);
d18202 1
a18202 1
	   offset.sect_off, per_cu->objfile->name);
d18230 1
a18230 1
	       offset.sect_off, per_cu->objfile->name);
d18303 1
a18303 1
	   offset.sect_off, per_cu->objfile->name);
d18487 1
a18487 1
	     (*ref_cu)->objfile->name);
d18497 1
a18497 1
	     (*ref_cu)->objfile->name);
d18524 1
a18524 1
		 dwarf2_per_objfile->objfile->name);
d18546 1
a18546 1
		     dwarf2_per_objfile->objfile->name);
d18556 1
a18556 1
		 dwarf2_per_objfile->objfile->name);
d18589 1
a18589 1
		 dwarf2_per_objfile->objfile->name);
d21359 2
a21360 2
  if (stat (objfile->name, &st) < 0)
    perror_with_name (objfile->name);
d21362 1
a21362 1
  filename = concat (dir, SLASH_STRING, lbasename (objfile->name),
d21536 1
a21536 1
    if (stat (objfile->name, &st) < 0)
d21551 1
a21551 1
			     objfile->name);
@


1.832
log
@	* dwarf2read.c (queue_and_load_all_dwo_tus): New function.
	(queue_and_load_dwo_tu): New function.
	(lookup_dwo_signatured_type): Set per_cu.tu_read.
	(maybe_queue_comp_unit): Rename this_cu argument to dependent_cu.
	Make dependent_cu optional.
	(dw2_do_instantiate_symtab): If we just loaded a CU from a DWO,
	and an older .gdb_index is in use, queue and load all its TUs too.

	testsuite/
	* gdb.base/enumval.c (ZERO): New enum value.
	(main): Use it
	* gdb.base/enumval.exp: Test ability to print ZERO.
@
text
@d1238 1
a1238 68


/* Various complaints about symbol reading that don't abort the process.  */

static void
dwarf2_statement_list_fits_in_line_number_section_complaint (void)
{
  complaint (&symfile_complaints,
	     _("statement list doesn't fit in .debug_line section"));
}

static void
dwarf2_debug_line_missing_file_complaint (void)
{
  complaint (&symfile_complaints,
	     _(".debug_line section has line data without a file"));
}

static void
dwarf2_debug_line_missing_end_sequence_complaint (void)
{
  complaint (&symfile_complaints,
	     _(".debug_line section has line "
	       "program sequence without an end"));
}

static void
dwarf2_complex_location_expr_complaint (void)
{
  complaint (&symfile_complaints, _("location expression too complex"));
}

static void
dwarf2_const_value_length_mismatch_complaint (const char *arg1, int arg2,
					      int arg3)
{
  complaint (&symfile_complaints,
	     _("const value length mismatch for '%s', got %d, expected %d"),
	     arg1, arg2, arg3);
}

static void
dwarf2_section_buffer_overflow_complaint (struct dwarf2_section_info *section)
{
  complaint (&symfile_complaints,
	     _("debug info runs off end of %s section"
	       " [in module %s]"),
	     section->asection->name,
	     bfd_get_filename (section->asection->owner));
}

static void
dwarf2_macro_malformed_definition_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     _("macro debug info contains a "
	       "malformed macro definition:\n`%s'"),
	     arg1);
}

static void
dwarf2_invalid_attrib_class_complaint (const char *arg1, const char *arg2)
{
  complaint (&symfile_complaints,
	     _("invalid attribute class or form for '%s' in '%s'"),
	     arg1, arg2);
}

d1721 16
d1738 50
@


1.831
log
@Code cleanup: Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH.

gdb/
2013-09-04  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH.
	* cli/cli-cmds.c (find_and_open_script): Add OPF_RETURN_REALPATH to
	variable search_flags.
	* defs.h (OPF_DISABLE_REALPATH): Rename to ...
	(OPF_RETURN_REALPATH): ... here.
	* dwarf2read.c (try_open_dwop_file): Set OPF_RETURN_REALPATH for flags.
	* exec.c (exec_file_attach): Remove OPF_DISABLE_REALPATH from openp
	call.  Twice.
	* nto-tdep.c (nto_find_and_open_solib): Add OPF_RETURN_REALPATH for
	openp call.
	* solib.c (solib_find): Likewise.  Four times.
	* source.c (openp): Change OPF_DISABLE_REALPATH to OPF_RETURN_REALPATH
	in the function comment and for the realpath_fptr variable.
	(source_full_path_of): Add OPF_RETURN_REALPATH for openp call.
	(find_and_open_source): Likewise.  Twice.
	* symfile.c (symfile_bfd_open): Likewise, also twice.
@
text
@d1781 2
d2343 11
d4484 1
d6957 3
a6959 2
/* THIS_CU has a reference to PER_CU.  If necessary, load the new compilation
   unit and add it to our queue.
d6967 1
a6967 1
maybe_queue_comp_unit (struct dwarf2_cu *this_cu,
d6983 2
a6984 1
  dwarf2_add_dependence (this_cu, per_cu);
d9847 49
@


1.830
log
@	* dwarf2read.c (struct dwarf2_cu): Tweak comment.
	(struct dwarf2_per_cu_data): Ditto.
	(maybe_queue_comp_unit): Delete forward decl.  Add comment.
	(process_imported_unit_die): Ditto.
	(follow_die_sig_1): Simplify assert.
@
text
@d9352 1
a9352 1
  flags = 0;
@


1.829
log
@	PR symtab/15885
	* dwarf2read.c (dw2_dump): Print some minimal information indicating
	.gdb_index is in use.
	* symfile.c (reread_symbols): Reset objfile->sf.

	testsuite/
	* gdb.dwarf2/Makefile.in (EXECUTABLES): Add gdb-index.
	(clean): rm -f *.gdb-index *.with-index.
	* gdb.dwarf2/gdb-index.exp: New testcase.
@
text
@d442 1
a442 1
  /* Backchain to our per_cu entry if the tree has been built.  */
d613 2
a614 1
     indices so we only pay a price for gold generated indices.  */
a1740 4
static int maybe_queue_comp_unit (struct dwarf2_cu *this_cu,
				  struct dwarf2_per_cu_data *per_cu,
				  enum language pretend_language);

d6946 4
a6949 1
   meaning either PER_CU is already queued or it is already loaded.  */
d7669 1
a7669 1
      /* Queue the unit, if needed.  */
a18367 2
  gdb_assert (sig_type->per_cu.cu != NULL);

d18369 1
@


1.828
log
@	* dwarf2read.c (write_psymtabs_to_index): Move error checks ahead of
	missing debug info checks.
@
text
@d3360 5
d3368 11
a3378 1
  /* Nothing worth printing.  */
@


1.827
log
@	* buildsym.c (subfile_stack): Move here from buildsym.h.
	(pending_macros): Ditto.
	(get_macro_table): New function.
	(buildsym_init): Initialize subfile_stack.
	* coffread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	(coff_symtab_read): Use it.
	* dbxread.c (read_ofile_symtab): Delete init of subfile_stack.
	* dwarf2read.c (macro_start_file): Replace uses of pending_macros
	with call to get_macro_table.
	* stabsread.c (type_vector,type_vector_length): Moved here from
	buildsym.h.
	(INITIAL_TYPE_VECTOR_LENGTH): Ditto.
	* buildsym.h (get_macro_table): Declare.
@
text
@a21265 3
  if (!objfile->psymtabs || !objfile->psymtabs_addrmap)
    return;

d21272 3
@


1.826
log
@(create_addrmap_from_index): Use hex_string instead of pulongest in previous
patch.
@
text
@a18945 7
  /* We don't create a macro table for this compilation unit
     at all until we actually get a filename.  */
  if (! pending_macros)
    pending_macros = new_macro_table (&objfile->per_bfd->storage_obstack,
				      objfile->per_bfd->macro_cache,
				      comp_dir);

d18948 4
d18954 2
a18955 2
      current_file = macro_set_main (pending_macros, file_name);
      macro_define_special (pending_macros);
@


1.825
log
@	* dwarf2read.c (create_addrmap_from_index): Ignore bad address table
	entries.
@
text
@d2577 1
a2577 1
		     pulongest (lo), pulongest (hi));
@


1.824
log
@fix PR symtab/15028

This fixes some derivation.exp regressions with "dwz -m".

The bug here is that the imported PU is given language_minimal.
However, it ought to be C++.

The "pretend language" machinery exists to solve this problem, but it
wasn't handled in process_psymtab_comp_unit.  So, this patch adds it
there.

Built and regtested, both normally and using "dwz -m", on x86-64
Fedora 18.

	PR symtab/15028:
	* dwarf2read.c (struct process_psymtab_comp_unit_data): New.
	(process_psymtab_comp_unit_reader): Use it.
	(process_psymtab_comp_unit): Update.  Add "pretend_language"
	argument.
	(dwarf2_build_psymtabs_hard): Update.
	(scan_partial_symbols): Pass CU's language to
	process_psymtab_comp_unit.
@
text
@d2573 1
a2573 1
      if (cu_index < dwarf2_per_objfile->n_comp_units)
d2575 4
a2578 2
	  addrmap_set_empty (mutable_map, lo + baseaddr, hi + baseaddr - 1,
			     dw2_get_cu (cu_index));
d2580 2
a2581 1
      else
d2586 1
d2588 3
@


1.823
log
@remove unused qf method

After the previous patch in the series, nothing uses the "quick"
method find_symbol_file.

This patch removes it.

Tested by rebuilding.

	* dwarf2read.c (dw2_get_primary_filename_reader): Remove.
	(dwarf2_gdb_index_functions): Update.
	* psymtab.c (find_symbol_file_from_partial): Remove.
	(psym_functions): Update.
	* symfile.h (struct quick_symbol_functions) <find_symbol_file>:
	Remove.
@
text
@d5626 15
d5659 1
a5659 1
  int *want_partial_unit_ptr = data;
d5661 1
a5661 3
  if (comp_unit_die->tag == DW_TAG_partial_unit
      && (want_partial_unit_ptr == NULL
	  || !*want_partial_unit_ptr))
d5666 1
a5666 1
  prepare_one_comp_unit (cu, comp_unit_die, language_minimal);
d5781 2
a5782 1
			   int want_partial_unit)
d5784 2
d5795 2
d5799 1
a5799 1
			   &want_partial_unit);
d5977 1
a5977 1
      process_psymtab_comp_unit (per_cu, 0);
d6199 1
a6199 1
		  process_psymtab_comp_unit (per_cu, 1);
@


1.822
log
@fix recursively_compute_inclusions and add dwz test case

Doug pointed out a while ago that in the final dwz -m patch, nothing
ever set symtab::user.

This patch fixes this oversight and adds a test case showing why it is
important.

Built and regtested (both ways) on x86-64 Fedora 18.
The new test unconditionally tests the partial unit machinery, which I
think is an added plus.

	* dwarf2read.c (recursively_compute_inclusions): Add
	"immediate_parent" argument.  Set symtab's "user" field
	if not set.
	(compute_symtab_includes): Update.

	* gdb.dwarf2/dwz.exp: New file.
@
text
@a3447 77
/* A helper function for dw2_find_symbol_file that finds the primary
   file name for a given CU.  This is a die_reader_func.  */

static void
dw2_get_primary_filename_reader (const struct die_reader_specs *reader,
				 const gdb_byte *info_ptr,
				 struct die_info *comp_unit_die,
				 int has_children,
				 void *data)
{
  const char **result_ptr = data;
  struct dwarf2_cu *cu = reader->cu;
  struct attribute *attr;

  attr = dwarf2_attr (comp_unit_die, DW_AT_name, cu);
  if (attr == NULL)
    *result_ptr = NULL;
  else
    *result_ptr = DW_STRING (attr);
}

static const char *
dw2_find_symbol_file (struct objfile *objfile, const char *name)
{
  struct dwarf2_per_cu_data *per_cu;
  offset_type *vec;
  const char *filename;

  dw2_setup (objfile);

  /* index_table is NULL if OBJF_READNOW.  */
  if (!dwarf2_per_objfile->index_table)
    {
      struct symtab *s;

      ALL_OBJFILE_PRIMARY_SYMTABS (objfile, s)
	{
	  struct blockvector *bv = BLOCKVECTOR (s);
	  const struct block *block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	  struct symbol *sym = lookup_block_symbol (block, name, VAR_DOMAIN);

	  if (sym)
	    {
	      /* Only file extension of returned filename is recognized.  */
	      return SYMBOL_SYMTAB (sym)->filename;
	    }
	}
      return NULL;
    }

  if (!find_slot_in_mapped_hash (dwarf2_per_objfile->index_table,
				 name, &vec))
    return NULL;

  /* Note that this just looks at the very first one named NAME -- but
     actually we are looking for a function.  find_main_filename
     should be rewritten so that it doesn't require a custom hook.  It
     could just use the ordinary symbol tables.  */
  /* vec[0] is the length, which must always be >0.  */
  per_cu = dw2_get_cu (GDB_INDEX_CU_VALUE (MAYBE_SWAP (vec[1])));

  if (per_cu->v.quick->symtab != NULL)
    {
      /* Only file extension of returned filename is recognized.  */
      return per_cu->v.quick->symtab->filename;
    }

  /* Initialize filename in case there's a problem reading the DWARF,
     dw2_get_primary_filename_reader may not get called.  */
  filename = NULL;
  init_cutu_and_read_dies (per_cu, NULL, 0, 0,
			   dw2_get_primary_filename_reader, &filename);

  /* Only file extension of returned filename is recognized.  */
  return filename;
}

a3770 1
  dw2_find_symbol_file,
@


1.821
log
@	PR symtab/15691
	* dwarf2read.c (struct dwarf2_per_cu_data): New member tu_read.
	(fill_in_sig_entry_from_dwo_entry): Reorganize asserts.
	Add assert of sig_entry->dwo_unit == NULL.
	(lookup_dwo_signatured_type): Don't assign TU to a DWO if the TU
	had already been read.
	(read_signatured_type): Set per_cu.tu_read.

	testsuite/
	* gdb.dwarf2/fission-mix.exp: New file.
	* gdb.dwarf2/fission-mix.h: New file.
	* gdb.dwarf2/fission-mix.c: New file.
	* gdb.dwarf2/fission-mix2.c: New file.
@
text
@d7377 2
a7378 1
				struct dwarf2_per_cu_data *per_cu)
d7406 2
d7411 5
a7415 1
	VEC_safe_push (symtab_ptr, *result, symtab);
d7423 1
a7423 1
				      all_type_symtabs, iter);
d7459 2
a7460 1
					  all_type_symtabs, per_cu_iter);
@


1.820
log
@	Further workarounds for binutils/15021.
	* dwarf2read.c (recursively_compute_inclusions): Change type of result
	parameter to VEC (symtab_ptr) **.  New parameter all_type_symtabs.
	Watch for duplicate symtabs coming from type units.
	(compute_symtab_includes): Update call to
	recursively_compute_inclusions. Build vector of included symtabs
	instead of per_cus.
	* symtab.h (symtab_ptr): New typedef.
	(DEF_VEC_P (symtab_ptr)): New VEC type.
	* linespec.c (symtab_p): Delete.  All uses updated to use symtab_ptr
	instead.
@
text
@d561 10
d4456 1
a4456 5
  sig_entry->per_cu.section = dwo_entry->section;
  sig_entry->per_cu.offset = dwo_entry->offset;
  sig_entry->per_cu.length = dwo_entry->length;
  sig_entry->per_cu.reading_dwo_directly = 1;
  sig_entry->per_cu.objfile = objfile;
d4464 7
d4476 8
a4483 8
   Create the signatured_type data structure for a TU to be read in
   directly from a DWO file, bypassing the stub.
   We do this for the case where there is no DWP file and we're using
   .gdb_index: When reading a CU we want to stay in the DWO file containing
   that CU.  Otherwise we could end up reading several other DWO files (due
   to comdat folding) to process the transitive closure of all the mentioned
   TUs, and that can be slow.  The current DWO file will have every type
   signature that it needs.
d4512 5
d4518 1
a4518 1
  if (sig_entry->dwo_unit != NULL)
d18629 1
@


1.819
log
@	* dwarf2read.c (process_queue): Add type signature to debug output.
@
text
@d7357 2
a7358 2
recursively_compute_inclusions (VEC (dwarf2_per_cu_ptr) **result,
				htab_t all_children,
d7363 1
d7375 17
a7391 2
  if (get_symtab (per_cu) != NULL)
    VEC_safe_push (dwarf2_per_cu_ptr, *result, per_cu);
d7396 4
a7399 1
    recursively_compute_inclusions (result, all_children, iter);
d7413 4
a7416 3
      struct dwarf2_per_cu_data *iter;
      VEC (dwarf2_per_cu_ptr) *result_children = NULL;
      htab_t all_children;
d7425 2
d7430 1
a7430 1
			ix, iter);
d7432 4
a7435 1
	recursively_compute_inclusions (&result_children, all_children, iter);
d7437 2
a7438 4
      /* Now we have a transitive closure of all the included CUs, and
	 for .gdb_index version 7 the included TUs, so we can convert it
	 to a list of symtabs.  */
      len = VEC_length (dwarf2_per_cu_ptr, result_children);
d7443 1
a7443 1
	   VEC_iterate (dwarf2_per_cu_ptr, result_children, ix, iter);
d7445 1
a7445 1
	symtab->includes[ix] = get_symtab (iter);
d7448 1
a7448 1
      VEC_free (dwarf2_per_cu_ptr, result_children);
d7450 1
@


1.818
log
@cleanup: constify "struct attribute" function parameter

gdb/

2013-07-30  Sanimir Agovic  <sanimir.agovic@@intel.com>

	* dwarf2read.c (dwarf2_get_ref_die_offset): Constify struct
	attribute parameter.
	(dwarf2_const_value_data): Constify struct attribute parameter.
	(dwarf2_const_value): Constify struct attribute parameter.
	(dwarf2_const_value_attr): Constify struct attribute parameter.
	(lookup_die_type): Constify struct attribute parameter.
	(dwarf2_get_attr_constant_value): Constify struct attribute parameter.
	(follow_die_ref_or_sig): Constify struct attribute parameter.
	(follow_die_ref): Constify struct attribute parameter.
	(follow_die_sig): Constify struct attribute parameter.
	(get_DW_AT_signature_type): Constify struct attribute parameter.
	(get_type_unit_group): Constify struct attribute parameter.
	(fill_in_loclist_baton): Constify struct attribute parameter.
	(dwarf2_symbol_mark_computed): Constify struct attribute parameter.
	(type_unit_group): Constify struct attribute parameter.
@
text
@d7031 1
d7033 1
a7033 1
	  if (dwarf2_read_debug)
d7035 5
a7039 4
	      fprintf_unfiltered (gdb_stdlog,
				  "Expanding symtab of %s at offset 0x%x\n",
				  per_cu->is_debug_types ? "TU" : "CU",
				  per_cu->offset.sect_off);
d7041 5
d7053 1
a7053 6
	    {
	      fprintf_unfiltered (gdb_stdlog,
				  "Done expanding %s at offset 0x%x\n",
				  per_cu->is_debug_types ? "TU" : "CU",
				  per_cu->offset.sect_off);
	    }
@


1.817
log
@cleanup: constify argument passed to dwarf form predicates

2013-07-30  Sanimir Agovic  <sanimir.agovic@@intel.com>

gdb/
	* dwarf2read.c (attr_form_is_block): Make argument const.
	(attr_form_is_section_offset): Make argument const.
	(attr_form_is_constant): Make argument const.
	(attr_form_is_ref): Make argument const.
@
text
@d1455 1
a1455 1
static void dwarf2_const_value (struct attribute *, struct symbol *,
d1458 1
a1458 1
static void dwarf2_const_value_attr (struct attribute *attr,
d1479 1
a1479 1
static struct type *lookup_die_type (struct die_info *, struct attribute *,
d1611 1
a1611 1
static sect_offset dwarf2_get_ref_die_offset (struct attribute *);
d1613 1
a1613 1
static LONGEST dwarf2_get_attr_constant_value (struct attribute *, int);
d1616 1
a1616 1
					       struct attribute *,
d1620 1
a1620 1
					struct attribute *,
d1624 1
a1624 1
					struct attribute *,
d1631 1
a1631 1
					      struct attribute *,
d1639 1
a1639 1
    (struct dwarf2_cu *, struct attribute *);
d1662 1
a1662 1
				   struct attribute *attr);
d1664 1
a1664 1
static void dwarf2_symbol_mark_computed (struct attribute *attr,
d5417 1
a5417 1
get_type_unit_group (struct dwarf2_cu *cu, struct attribute *stmt_list)
d16789 1
a16789 1
dwarf2_const_value_data (struct attribute *attr, struct obstack *obstack,
d16821 1
a16821 1
dwarf2_const_value_attr (struct attribute *attr, struct type *type,
d16924 1
a16924 1
dwarf2_const_value (struct attribute *attr, struct symbol *sym,
d17063 1
a17063 1
lookup_die_type (struct die_info *die, struct attribute *attr,
d17959 1
a17959 1
dwarf2_get_ref_die_offset (struct attribute *attr)
d17977 1
a17977 1
dwarf2_get_attr_constant_value (struct attribute *attr, int default_value)
d18001 1
a18001 1
follow_die_ref_or_sig (struct die_info *src_die, struct attribute *attr,
d18075 1
a18075 1
follow_die_ref (struct die_info *src_die, struct attribute *attr,
d18387 1
a18387 1
follow_die_sig (struct die_info *src_die, struct attribute *attr,
d18485 1
a18485 1
get_DW_AT_signature_type (struct die_info *die, struct attribute *attr,
d19895 1
a19895 1
		       struct attribute *attr)
d19912 1
a19912 1
dwarf2_symbol_mark_computed (struct attribute *attr, struct symbol *sym,
@


1.816
log
@cleanup: rename is_ref_attr to attr_form_is_ref

2013-07-30  Sanimir Agovic  <sanimir.agovic@@intel.com>

gdb/
	* dwarf2read.c (attr_is_ref): Rename to attr_form_is_ref.
	All uses updated.
	(attr_form_is_ref): Moved below attr_form_is_constant.
@
text
@d1652 1
a1652 1
static int attr_form_is_block (struct attribute *);
d1654 1
a1654 1
static int attr_form_is_section_offset (struct attribute *);
d1656 1
a1656 1
static int attr_form_is_constant (struct attribute *);
d1658 1
a1658 1
static int attr_form_is_ref (struct attribute *);
d19800 1
a19800 1
attr_form_is_block (struct attribute *attr)
d19820 1
a19820 1
attr_form_is_section_offset (struct attribute *attr)
d19841 1
a19841 1
attr_form_is_constant (struct attribute *attr)
d19862 1
a19862 1
attr_form_is_ref (struct attribute *attr)
@


1.815
log
@	* dwarf2read.c (lookup_dwo_cutu): Change missing DWO complaint to
	a warning.
@
text
@a1610 2
static int is_ref_attr (struct attribute *);

d1658 2
d10368 1
a10368 1
  else if (is_ref_attr (attr))
d10441 1
a10441 1
      if (loc == NULL && origin != NULL && is_ref_attr (origin))
d13383 1
a13383 1
      if (attr_form_is_block (attr) || is_ref_attr (attr))
d14824 1
a14824 1
  if (cu->per_cu->is_dwz && is_ref_attr (attr))
d17083 1
a17083 1
  else if (is_ref_attr (attr))
d17112 1
a17112 1
      if (is_ref_attr (attr))
a17954 21
/* DW_ADDR is always stored already as sect_offset; despite for the forms
   besides DW_FORM_ref_addr it is stored as cu_offset in the DWARF file.  */

static int
is_ref_attr (struct attribute *attr)
{
  switch (attr->form)
    {
    case DW_FORM_ref_addr:
    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref8:
    case DW_FORM_ref_udata:
    case DW_FORM_GNU_ref_alt:
      return 1;
    default:
      return 0;
    }
}

d17963 1
a17963 1
  if (is_ref_attr (attr))
d18006 1
a18006 1
  if (is_ref_attr (attr))
d18489 1
a18489 1
  if (is_ref_attr (attr))
d19857 22
@


1.814
log
@	* dwarf2read.c (init_cutu_and_read_dies): Revert patch from
	2013-07-22.
@
text
@d9786 7
a9792 6
  complaint (&symfile_complaints,
	     _("Could not find DWO %s %s(%s) referenced by %s at offset 0x%x"
	       " [in module %s]"),
	     kind, dwo_name, hex_string (signature),
	     this_unit->is_debug_types ? "TU" : "CU",
	     this_unit->offset.sect_off, objfile->name);
@


1.813
log
@fix init_cutu_and_read_dies

init_cutu_and_read_dies creates an outer cleanup and uses its
immediately nested inner cleanup conditionally.  This seems overly
complicated to me; simpler is to just deal with the outer cleanup and
drop the inner one.  That is what this patch implements.

	* dwarf2read.c (init_cutu_and_read_dies): Remove 'free_cu_cleanup'.
	Simplify cleanup handling.
@
text
@d5018 1
a5018 1
  struct cleanup *cleanups;
d5077 1
a5077 1
      make_cleanup (free_heap_comp_unit, cu);
d5206 1
a5206 1
  if (keep)
d5208 5
a5212 3
      /* We've successfully allocated this compilation unit.  Let our
	 caller clean it up when finished with it.  */
      discard_cleanups (cleanups);
d5214 3
a5216 3
      /* We can only discard free_cu_cleanup and all subsequent cleanups.
	 So we have to manually free the abbrev table.  */
      dwarf2_free_abbrev_table (cu);
d5218 6
a5223 3
      /* Link this CU into read_in_chain.  */
      this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = this_cu;
d5225 2
a5226 2
  else
    do_cleanups (cleanups);
@


1.812
log
@fix dwarf_decode_line_header

dwarf_decode_line_header has one return that is missing a call to
do_cleanups.  This patch adds it.

This was found using the cleanup checker.

	* dwarf2read.c (dwarf_decode_line_header): Call do_cleanups
	on all return paths.
@
text
@d5018 1
a5018 1
  struct cleanup *cleanups, *free_cu_cleanup = NULL;
d5077 1
a5077 1
      free_cu_cleanup = make_cleanup (free_heap_comp_unit, cu);
d5206 1
a5206 1
  if (free_cu_cleanup != NULL)
d5208 3
a5210 5
      if (keep)
	{
	  /* We've successfully allocated this compilation unit.  Let our
	     caller clean it up when finished with it.  */
	  discard_cleanups (free_cu_cleanup);
d5212 3
a5214 3
	  /* We can only discard free_cu_cleanup and all subsequent cleanups.
	     So we have to manually free the abbrev table.  */
	  dwarf2_free_abbrev_table (cu);
d5216 3
a5218 6
	  /* Link this CU into read_in_chain.  */
	  this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
	  dwarf2_per_objfile->read_in_chain = this_cu;
	}
      else
	do_cleanups (free_cu_cleanup);
d5220 2
a5221 2

  do_cleanups (cleanups);
@


1.811
log
@	* dwarf2read.c (dwarf2_per_objfile_free): Clear
	dwarf2_per_objfile.
@
text
@d15707 1
@


1.810
log
@change gdb to use BFD's "dwz" functions

BFD recently got a few functions related to "dwz" files.  This patch
changes gdb to use them, just to share a bit more code.

This changes dwarf2_get_dwz_file to possibly return NULL.  This
simplified a bit of code elsewhere.

Built and regtested on x86-64 Fedora 18.  I specifically regtested it
using my pending dwz test case.

	* dwarf2read.c (dwarf2_get_dwz_file): Return NULL if
	.gnu_debugaltlink not found.  Use bfd_get_alt_debug_link_info.
	(dwarf2_read_index, create_all_comp_units): Update.
@
text
@d20549 4
@


1.809
log
@	symtab/15652
	* dwarf2read.c (try_open_dwop_file): New arg search_cwd.
	All callers updated.
	(open_dwp_file): If we can't find the dwp file, search the basename
	in debug-file-directory.
@
text
@d2102 3
a2104 2
/* Open the separate '.dwz' debug file, if needed.  Error if the file
   cannot be found.  */
d2109 2
a2110 3
  bfd *abfd, *dwz_bfd;
  asection *section;
  gdb_byte *data;
d2114 1
d2119 10
a2128 7
  abfd = dwarf2_per_objfile->objfile->obfd;
  section = bfd_get_section_by_name (abfd, ".gnu_debugaltlink");
  if (section == NULL)
    error (_("could not find '.gnu_debugaltlink' section"));
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    error (_("could not read '.gnu_debugaltlink' section: %s"),
	   bfd_errmsg (bfd_get_error ()));
d2806 1
d2821 2
a2822 1
  if (bfd_get_section_by_name (objfile->obfd, ".gnu_debugaltlink") != NULL)
a2823 1
      struct dwz_file *dwz = dwarf2_get_dwz_file ();
d6129 1
d6139 5
a6143 8
  if (bfd_get_section_by_name (objfile->obfd, ".gnu_debugaltlink") != NULL)
    {
      struct dwz_file *dwz = dwarf2_get_dwz_file ();

      read_comp_units_from_section (objfile, &dwz->info, 1,
				    &n_allocated, &n_comp_units,
				    &all_comp_units);
    }
@


1.808
log
@	* dwarf2read.c (struct dwp_file): Fix comment.
	(open_and_init_dwp_file): Set dwp_file->name to bfd's file name.
@
text
@d9307 3
a9309 1
   In case of trouble, return NULL.
d9313 1
a9313 1
try_open_dwop_file (const char *file_name, int is_dwp)
d9324 8
a9331 3
  if (*debug_file_directory != '\0')
    search_path = concat (".", dirname_separator_string, debug_file_directory,
			  NULL);
d9333 1
a9333 1
    search_path = xstrdup (".");
d9372 1
a9372 1
    return try_open_dwop_file (file_name, 0 /*is_dwp*/);
d9382 1
a9382 1
      abfd = try_open_dwop_file (path_to_try, 0 /*is_dwp*/);
d9394 1
a9394 1
  return try_open_dwop_file (file_name, 0 /*is_dwp*/);
d9578 24
a9601 1
  return try_open_dwop_file (file_name, 1 /*is_dwp*/);
@


1.807
log
@	* dwarf2read.c (dw2_symtab_iter_next): Check value of cu_index
	before using it.
	(dw2_expand_symtabs_matching): Fix symbol kind validity check.
	Move test of cu_index closer to use.  Print complaint if cu_index
	is bad.
@
text
@d816 1
a816 1
  /* The bfd, when the file is open.  Otherwise this is NULL.  */
d9599 1
a9599 2
  dwp_file->name = obstack_copy0 (&objfile->objfile_obstack,
				  dwp_name, strlen (dwp_name));
@


1.806
log
@do not use dwarf2_per_objfile in dwarf2_per_objfile_free.

This patch fixes a case of multiple calls freeing the same data
while free-ing objfiles that have child objfiles (separate debug
info, as is the case on Darwin targets).

Following the code, free_objfile_separate_debug iterates over
all child objfiles of the parent objfile, calling free_objfile:

  for (child = objfile->separate_debug_objfile; child;)
    {
      struct objfile *next_child = child->separate_debug_objfile_link;
      free_objfile (child);
      child = next_child;
    }

This causes, among other things, the free'ing of the child objfile's
private data:

  /* Discard any data modules have associated with the objfile.  The function
     still may reference objfile->obfd.  */
  objfile_free_data (objfile);

This indirectly calls(back) dwarf2_per_objfile_free, which tries
to free the dwarf2read-specific data by using the dwarf2_per_objfile
global, eg:

  for (ix = 0; ix < dwarf2_per_objfile->n_comp_units; ++ix)

Even if we were lucky enough the first time around that this global
actually corresponds to the objfile being destroyed, the global
will still have the same value at the second iteration, and thus
become dangling. Indeed, after dwarf2_per_objfile_free returns
eventually back to free_objfile, free_objfile then deallocates
its objfile_obstack, where the dwarf2_per_objfile is allocated.

Ironically, there should be no need to access that global at all,
here, since the data is passed as an argument of the callback.
And it looks like the dwo/dwp/[...]-handling code is in fact already
using that argument, rather than the global.

This patch thus fixes the problem by doing the same, replacing
all references to DWARF2_PER_OBJFILE by uses of DATA instead.

gdb/ChangeLog:

        * dwarf2read.c (dwarf2_per_objfile): Replace uses of
        DWARF2_PER_OBJFILE by uses of DATA instead.
@
text
@d3202 1
a3202 1
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (cu_index);
d3216 12
d3645 7
d3653 2
a3654 8
	  /* Don't crash on bad data.  */
	  if (cu_index >= (dwarf2_per_objfile->n_comp_units
			   + dwarf2_per_objfile->n_type_units))
	    continue;

	  /* Only check the symbol's kind if it has one.
	     Indices prior to version 7 don't record it.  */
	  if (index->version >= 7)
d3675 10
@


1.805
log
@gdb/
	* dwarf2read.c (write_psymtabs_to_index): Ignore NULL PSYMTAB.
@
text
@d20494 2
a20495 3
  for (ix = 0; ix < dwarf2_per_objfile->n_comp_units; ++ix)
    VEC_free (dwarf2_per_cu_ptr,
	      dwarf2_per_objfile->all_comp_units[ix]->imported_symtabs);
d20497 1
a20497 1
  for (ix = 0; ix < dwarf2_per_objfile->n_type_units; ++ix)
d20499 2
a20500 2
	      dwarf2_per_objfile->all_type_units[ix]->per_cu.imported_symtabs);
  xfree (dwarf2_per_objfile->all_type_units);
@


1.804
log
@	* dwarf2read.c (try_open_dwop_file): Work around behaviour of
	OPF_TRY_CWD_FIRST to not search path if the file contains a '/'.
@
text
@d21273 6
@


1.803
log
@	* dwarf2read.c: Whitespace fixes for DWP file format documentation,
	and fix header docs.
@
text
@d9293 11
d9305 1
a9305 1
  flags = OPF_TRY_CWD_FIRST;
d9308 1
a9308 1
  desc = openp (debug_file_directory, flags, file_name,
d9310 1
a9314 5
  if (!sym_bfd)
    {
      xfree (absolute_name);
      return NULL;
    }
d9316 2
@


1.802
log
@dwarf2read.c: Don't assume uint32_t is unsigned int on all hosts.

Building gdb on GNU/Linux, for --host=i586-pc-msdosdjgpp, I get:

 ../../src/gdb/dwarf2read.c: In function 'create_dwp_hash_table':
 ../../src/gdb/dwarf2read.c:8626:7: error: format '%u' expects argument of type 'unsigned int', but argument 2 has type 'uint32_t' [-Werror=format]
 ../../src/gdb/dwarf2read.c:8632:7: error: format '%u' expects argument of type 'unsigned int', but argument 2 has type 'uint32_t' [-Werror=format]
 ../../src/gdb/dwarf2read.c: In function 'create_dwo_in_dwp':
 ../../src/gdb/dwarf2read.c:8754:6: error: format '%u' expects argument of type 'unsigned int', but argument 4 has type 'uint32_t' [-Werror=format]
 ../../src/gdb/dwarf2read.c: In function 'open_and_init_dwp_file':
 ../../src/gdb/dwarf2read.c:9248:6: error: format '%u' expects argument of type 'unsigned int', but argument 3 has type 'long unsigned int' [-Werror=format]
 ../../src/gdb/dwarf2read.c:9248:6: error: format '%u' expects argument of type 'unsigned int', but argument 4 has type 'long unsigned int' [-Werror=format]

And:

 $ grep uint32_t /usr/i586-pc-msdosdjgpp/sys-include/*
 /usr/i586-pc-msdosdjgpp/sys-include/stdint.h:typedef unsigned long uint32_t;

As decided on the discussion at
<http://sourceware.org/ml/gdb-patches/2013-05/msg00788.html>, use
pulongest rather than PRIu32.

Tested on F17.  Also confirmed GDB still builds OK with
--host=i686-w64-mingw32.

gdb/
2013-05-23  Pedro Alves  <palves@@redhat.com>

	* dwarf2read.c (create_dwp_hash_table, create_dwo_in_dwp)
	(open_and_init_dwp_file): Use %s/pulongest instead of %u for
	printing uint32_t variables.
@
text
@d8870 2
d8878 6
a8883 2
   The index section header contains two unsigned 32-bit values (using the
   byte order of the application binary):
d8885 1
a8885 2
    N, the number of compilation units or type units in the index
    M, the number of slots in the hash table
d8887 1
a8887 1
  (We assume that N and M will not exceed 2^32 - 1.)
d8889 1
a8889 1
  The size of the hash table, M, must be 2^k such that 2^k > 3*N/2.
d8891 4
a8894 4
  The hash table begins at offset 8 in the section, and consists of an array
  of M 64-bit slots.  Each slot contains a 64-bit signature (using the byte
  order of the application binary).  Unused slots in the hash table are 0.
  (We rely on the extreme unlikeliness of a signature being exactly 0.)
d8896 6
a8901 6
  The parallel table begins immediately after the hash table
  (at offset 8 + 8 * M from the beginning of the section), and consists of an
  array of 32-bit indexes (using the byte order of the application binary),
  corresponding 1-1 with slots in the hash table.  Each entry in the parallel
  table contains a 32-bit index into the pool of section numbers.  For unused
  hash table slots, the corresponding entry in the parallel table will be 0.
d8903 2
a8904 2
  Given a 64-bit compilation unit signature or a type signature S, an entry
  in the hash table is located as follows:
d8906 2
a8907 2
  1) Calculate a primary hash H = S & MASK(k), where MASK(k) is a mask with
     the low-order k bits all set to 1.
d8909 1
a8909 1
  2) Calculate a secondary hash H' = (((S >> 32) & MASK(k)) | 1).
d8911 3
a8913 3
  3) If the hash table entry at index H matches the signature, use that
     entry.  If the hash table entry at index H is unused (all zeroes),
     terminate the search: the signature is not present in the table.
d8915 1
a8915 1
  4) Let H = (H + H') modulo M. Repeat at Step 3.
d8917 2
a8918 2
  Because M > N and H' and M are relatively prime, the search is guaranteed
  to stop at an unused slot or find the match.
d8920 7
a8926 7
  The pool of section numbers begins immediately following the hash table
  (at offset 8 + 12 * M from the beginning of the section).  The pool of
  section numbers consists of an array of 32-bit words (using the byte order
  of the application binary).  Each item in the array is indexed starting
  from 0.  The hash table entry provides the index of the first section
  number in the set.  Additional section numbers in the set follow, and the
  set is terminated by a 0 entry (section number 0 is not used in ELF).
d8928 3
a8930 3
  In each set of section numbers, the .debug_info.dwo or .debug_types.dwo
  section must be the first entry in the set, and the .debug_abbrev.dwo must
  be the second entry. Other members of the set may follow in any order.  */
@


1.801
log
@	When reading CU, stay in DWO.  Be more tolerent of bad debug info.
	For Fission.
	* dwarf2read.c (struct dwarf2_per_cu_data): New member
	reading_dwo_directly.
	(struct signatured_type): New member dwo_unit.
	(struct die_reader_specs): New member comp_dir.
	(create_signatured_type_table_from_index): Use malloc for
	all_type_units instead of objfile's obstack.
	(create_all_type_units): Ditto.
	(fill_in_sig_entry_from_dwo_entry): New function.
	(add_type_unit): New function.
	(lookup_dwo_signatured_type): New function.
	(lookup_dwp_signatured_type): New function.
	(lookup_signatured_type): New arg cu.  All callers updated.
	(init_cu_die_reader): Initialize comp_dir.
	(read_cutu_die_from_dwo): New arg stub_comp_dir.  All callers updated.
	Change assert of matching type signatures to call error on mismatch.
	(lookup_dwo_unit): Add assert.
	(init_tu_and_read_dwo_dies): New function.
	(init_cutu_and_read_dies): Call it.
	(build_type_unit_groups): Handle case of no type unit groups created.
	(hash_dwo_file, eq_dwo_file): Handle missing comp_dir.
	(lookup_dwo_cutu): Tweak complaint.
	(dwarf2_free_abbrev_table): Check for NULL abbrev_table.
	(dwarf2_per_objfile_free): Free all_type_units.
@
text
@d8963 1
a8963 1
      error (_("Dwarf Error: unsupported DWP file version (%u)"
d8965 1
a8965 1
	     version, dwp_file->name);
d8969 1
a8969 1
      error (_("Dwarf Error: number of slots in DWP hash table (%u)"
d8971 1
a8971 1
	     nr_slots, dwp_file->name);
d9090 1
a9090 1
      fprintf_unfiltered (gdb_stdlog, "Reading %s %u/%s in DWP file: %s\n",
d9092 1
a9092 1
			  section_index, hex_string (signature),
d9585 3
a9587 3
			  "    %u CUs, %u TUs\n",
			  dwp_file->cus ? dwp_file->cus->nr_units : 0,
			  dwp_file->tus ? dwp_file->tus->nr_units : 0);
@


1.800
log
@[dwarf] Mark all functions as prototyped except C functions.

This makes sure that the types of the arguments are taken into account
when performing an inferior function call to a non-C (or C-like)
function.  In particular, this makes sure that the arguments are
appropriatly converted to the correct type.

For instance, on x86_64-linux, with the following Ada code:

   procedure Set_Float (F : Float) is
   begin
      Global_Float := F;
   end Set_Float;

The following sequence shows that Float arguments are incorrectly
passed (Ada's Float type is the equivalent of type "float" in C):

    (gdb) call set_float (2.0)
    (gdb) print global_float
    $1 = 0.0

Putting a breakpoint inside set_float to inspect the value of
register xmm0 gives the first hint of the problem:

    (gdb) p $xmm0
    $2 = (v4_float => (0 => 0.0, 2.0, 0.0, 0.0),
          v2_double => (0 => 2.0, 0.0),
    [...]

It shows that the argument was passed as a double.

The code responsible for doing appropriate type conversions
for the arguments (value_arg_coerce) found that our function
was not prototyped, and thus could not use typing information
for the arguments. Instead, it defaulted to the value of "set
coerce-float-to-double", which by default is true, to determine
the argument type.

This patch fixes the problem by setting the PROTOTYPE flag
for all functions of any language except C and Objective C.

gdb/ChangeLog:

        * dwarf2read.c (prototyped_function_p): New function.
        (read_subroutine_type): Use it.

gdb/testsuite/ChangeLog:

        * gdb.ada/float_param: New testcase.
@
text
@d205 2
a206 1
  /* The .debug_types-related CUs (TUs).  */
d555 6
d640 4
d877 3
d1762 6
d2489 2
a2490 3
    = obstack_alloc (&objfile->objfile_obstack,
		     dwarf2_per_objfile->n_type_units
		     * sizeof (struct signatured_type *));
d4400 2
a4401 3
    = obstack_alloc (&objfile->objfile_obstack,
		     dwarf2_per_objfile->n_type_units
		     * sizeof (struct signatured_type *));
d4410 163
d4578 1
a4578 1
lookup_signatured_type (ULONGEST sig)
d4580 13
a4592 1
  struct signatured_type find_entry, *entry;
d4594 6
a4599 5
  if (dwarf2_per_objfile->signatured_types == NULL)
    return NULL;
  find_entry.signature = sig;
  entry = htab_find (dwarf2_per_objfile->signatured_types, &find_entry);
  return entry;
d4619 1
d4629 4
d4644 1
d4661 1
d4664 3
d4704 10
d4735 10
a4744 1
      gdb_assert (sig_type->signature == header_signature);
d4821 7
d4851 2
d4889 69
d4995 1
a4995 1
     before we can reread the DWO file.  */
d5006 12
d5154 1
a5154 1
				      comp_unit_die,
d5588 10
d8649 1
d8651 4
a8654 2
  return (htab_hash_string (dwo_file->dwo_name)
	  + htab_hash_string (dwo_file->comp_dir));
d8663 5
a8667 2
  return (strcmp (lhs->dwo_name, rhs->dwo_name) == 0
	  && strcmp (lhs->comp_dir, rhs->comp_dir) == 0);
d9718 1
a9718 1
	     _("Could not find DWO %s %s(%s) referenced by CU at offset 0x%x"
d9721 1
d13808 2
a13809 1
  abbrev_table_free (cu->abbrev_table);
d18346 1
a18346 1
  sig_type = lookup_signatured_type (signature);
d18382 1
a18382 1
  sig_type = lookup_signatured_type (signature);
d20487 1
@


1.799
log
@[dwarf]: Add DW_LANG_UPC support in set_cu_language.

gdb/ChangeLog:

        * dwarf2read.c (set_cu_language): Add DW_LANG_UPC handling.
@
text
@d12603 32
d12662 1
a12662 12
  /* All functions in C++, Pascal and Java have prototypes.  */
  attr = dwarf2_attr (die, DW_AT_prototyped, cu);
  if ((attr && (DW_UNSND (attr) != 0))
      || cu->language == language_cplus
      || cu->language == language_java
      || cu->language == language_pascal)
    TYPE_PROTOTYPED (ftype) = 1;
  else if (producer_is_realview (cu->producer))
    /* RealView does not emit DW_AT_prototyped.  We can not
       distinguish prototyped and unprototyped functions; default to
       prototyped, since that is more common in modern code (and
       RealView warns about unprototyped functions).  */
@


1.798
log
@    	PR gdb/15538:
	* dwarf2read.c (dwarf2_record_block_ranges): Ensure that the
	ranges section has been read.
@
text
@d14986 1
@


1.797
log
@	* dwarf2loc.c (invalid_synthetic_pointer): Move earlier.
	(indirect_pieced_value): Call dwarf2_fetch_constant_bytes
	if needed.
	* dwarf2loc.h (dwarf2_fetch_constant_bytes): Declare.
	* dwarf2read.c (write_constant_as_bytes)
	(dwarf2_fetch_constant_bytes): New functions.
gdb/testsuite
	* gdb.dwarf2/implptrconst.c: New file.
	* gdb.dwarf2/implptrconst.exp: New file.
	* lib/dwarf.exp (Dwarf::_nz_quote): New proc.
	(Dwarf::_handle_DW_FORM): Handle DW_FORM_block1.
	(Dwarf::_location): Handle DW_OP_GNU_implicit_pointer.
@
text
@d10496 1
a10496 1
      const gdb_byte *buffer = dwarf2_per_objfile->ranges.buffer + offset;
d10515 1
a10515 1
      gdb_assert (dwarf2_per_objfile->ranges.readin);
d10523 1
@


1.796
log
@	* dwarf2read.c (dwarf2_const_value_data): Remove unused
	parameters.
	(dwarf2_const_value_attr): Update.
@
text
@d17768 144
@


1.795
log
@	* dwarf2read.c (dwarf2_const_value_attr): Use 'obstack', not
	objfile's obstack.
@
text
@d16364 1
a16364 2
dwarf2_const_value_data (struct attribute *attr, struct type *type,
			 const char *name, struct obstack *obstack,
d16466 1
a16466 2
      *bytes = dwarf2_const_value_data (attr, type, name,
					obstack, cu, value, 8);
d16469 1
a16469 2
      *bytes = dwarf2_const_value_data (attr, type, name,
					obstack, cu, value, 16);
d16472 1
a16472 2
      *bytes = dwarf2_const_value_data (attr, type, name,
					obstack, cu, value, 32);
d16475 1
a16475 2
      *bytes = dwarf2_const_value_data (attr, type, name,
					obstack, cu, value, 64);
@


1.794
log
@	* dbxread.c (process_one_symbol): Constify section_offsets parameter.
	* stabsread.h (process_one_symbol): Update declaration.
	* dwarf2read.c (dw2_relocate): Constify new_offsets, delta parameters.
	* elfread.c (elf_symfile_relocate_probe): Ditto.
	* psymtab.c (relocate_psymtabs): Ditto.
	* objfiles.c (objfile_relocate1): Constify new_offsets parameter.
	(objfile_relocate): Ditto.
	* objfiles.h (objfile_relocate): Update declaration.
	* symfile.c (relative_addr_info_to_section_offsets): Constify
	addrs parameter.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Constify offsets parameter.
	(syms_from_objfile): Ditto.
	(symbol_file_add_with_addrs_or_offsets): Ditto.
	(symfile_map_offsets_to_segments): Constify data parameter.
	* symfile.h (struct quick_symbol_functions): Constify new_offsets,
	delta parameters of member relocate.
	(struct sym_probe_fns): Constify new_offsets,
	delta parameters of member sym_relocate_probe.
	(struct sym_fns): Constify section_addr_info parameter of member
	sym_offsets.
	(relative_addr_info_to_section_offsets): Update declaration.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile): Ditto.
	(symfile_map_offsets_to_segments): Ditto.
@
text
@d16427 1
a16427 2
	*baton = obstack_alloc (&objfile->objfile_obstack,
				sizeof (struct dwarf2_locexpr_baton));
d16432 1
a16432 1
	data = obstack_alloc (&objfile->objfile_obstack, (*baton)->size);
@


1.793
log
@	* dwarf2read.c (lookup_dwo_unit): Return NULL if DWO not found.
	(init_cutu_and_read_dies): Flag a complaint, not error, for bad
	DWO stub.  If DWO isn't found, just use stub.
	(lookup_dwo_cutu): Don't try DWO if there's a DWP file.
@
text
@d3314 3
a3316 2
dw2_relocate (struct objfile *objfile, struct section_offsets *new_offsets,
	      struct section_offsets *delta)
@


1.792
log
@	* dwarf2read.c (dw2_find_symbol_file): Initialize filename before
	calling init_cutu_and_read_dies.
@
text
@d4608 1
a4608 1
   If the specified DWO unit cannot be found an error is thrown.  */
a4652 8
  if (dwo_unit == NULL)
    {
      error (_("Dwarf Error: CU at offset 0x%x references unknown DWO"
	       " with ID %s [in module %s]"),
	     this_cu->offset.sect_off, hex_string (signature),
	     this_cu->objfile->name);
    }

d4829 6
a4834 3
	error (_("Dwarf Error: compilation unit with DW_AT_GNU_dwo_name"
		 " has children (offset 0x%x) [in module %s]"),
	       this_cu->offset.sect_off, bfd_get_filename (abfd));
d4836 1
a4836 5
      if (read_cutu_die_from_dwo (this_cu, dwo_unit,
				  abbrev_table != NULL,
				  comp_unit_die,
				  &reader, &info_ptr,
				  &dwo_comp_unit_die, &has_children) == 0)
d4838 19
a4856 3
	  /* Dummy die.  */
	  do_cleanups (cleanups);
	  return;
a4857 1
      comp_unit_die = dwo_comp_unit_die;
d9303 4
a9306 1
  /* Have we already read SIGNATURE from a DWP file?  */
d9333 1
a9333 5

  /* Have we already seen DWO_NAME?  */

  dwo_file_slot = lookup_dwo_file_slot (dwo_name, comp_dir);
  if (*dwo_file_slot == NULL)
d9335 1
a9335 5
      /* Read in the file and build a table of the DWOs it contains.  */
      *dwo_file_slot = open_and_init_dwo_file (this_unit, dwo_name, comp_dir);
    }
  /* NOTE: This will be NULL if unable to open the file.  */
  dwo_file = *dwo_file_slot;
d9337 8
a9344 3
  if (dwo_file != NULL)
    {
      struct dwo_unit *dwo_cutu = NULL;
d9346 1
a9346 1
      if (is_debug_types && dwo_file->tus)
d9348 5
a9352 1
	  struct dwo_unit find_dwo_cutu;
d9354 9
a9362 9
	  memset (&find_dwo_cutu, 0, sizeof (find_dwo_cutu));
	  find_dwo_cutu.signature = signature;
	  dwo_cutu = htab_find (dwo_file->tus, &find_dwo_cutu);
	}
      else if (!is_debug_types && dwo_file->cu)
	{
	  if (signature == dwo_file->cu->signature)
	    dwo_cutu = dwo_file->cu;
	}
d9364 1
a9364 3
      if (dwo_cutu != NULL)
	{
	  if (dwarf2_read_debug)
d9366 7
a9372 3
	      fprintf_unfiltered (gdb_stdlog, "DWO %s %s(%s) found: @@%s\n",
				  kind, dwo_name, hex_string (signature),
				  host_address_to_string (dwo_cutu));
a9373 1
	  return dwo_cutu;
d9388 1
a9388 1
	     _("Could not find DWO %s referenced by CU at offset 0x%x"
d9390 2
a9391 1
	     kind, this_unit->offset.sect_off, objfile->name);
@


1.791
log
@	* dwarf2read.c (handle_DW_AT_stmt_list): Avoid ARI warning for
	editCase function rule.
	(get_DW_AT_signature_type): Likewise.
@
text
@d3468 3
@


1.790
log
@Add ARI marker to get_DW_AT_signature_type.

gdb/ChangeLog:

        * dwarf2read.c (get_DW_AT_signature_type): Add ARI marker.
@
text
@d8056 1
a8056 1
			const char *comp_dir)
d17927 2
a17928 2
get_DW_AT_signature_type /* ARI: editCase */
  (struct die_info *die, struct attribute *attr, struct dwarf2_cu *cu)
@


1.789
log
@	PR corefiles/14983:
	* dwarf2read.c (process_full_comp_unit): Always create a static
	block.
gdb/testsuite
	* gdb.dwarf2/nostaticblock.exp: New file.
@
text
@d17927 2
a17928 2
get_DW_AT_signature_type (struct die_info *die, struct attribute *attr,
			  struct dwarf2_cu *cu)
@


1.788
log
@	* dwarf2read.c (setup_type_unit_groups): Fix comment.
@
text
@d7135 1
a7135 2
    = end_symtab_get_static_block (highpc + baseaddr, objfile, 0,
				   per_cu->imported_symtabs != NULL);
@


1.787
log
@	PR gdb/7912:
	* Makefile.in (SFILES): Add filestuff.c
	(COMMON_OBS): Add filestuff.o.
	(filestuff.o): New target.
	* auto-load.c (auto_load_objfile_script_1): Use
	gdb_fopen_cloexec.
	* auxv.c (procfs_xfer_auxv): Use gdb_open_cloexec.
	* cli/cli-cmds.c (shell_escape): Call close_most_fds.
	* cli/cli-dump.c (fopen_with_cleanup): Use gdb_fopen_cloexec.
	* common/agent.c (gdb_connect_sync_socket): Use
	gdb_socket_cloexec.
	* common/filestuff.c: New file.
	* common/filestuff.h: New file.
	* common/linux-osdata.c (linux_common_core_of_thread)
	(command_from_pid, commandline_from_pid, print_source_lines)
	(linux_xfer_osdata_shm, linux_xfer_osdata_sem)
	(linux_xfer_osdata_msg, linux_xfer_osdata_modules): Use
	gdb_fopen_cloexec.
	* common/linux-procfs.c (linux_proc_get_int)
	(linux_proc_pid_has_state): Use gdb_fopen_cloexec.
	* config.in, configure: Rebuild.
	* configure.ac: Don't check for sys/socket.h.  Check for
	fdwalk, pipe2.
	* corelow.c (core_open): Use gdb_open_cloexec.
	* dwarf2read.c (write_psymtabs_to_index): Use gdb_fopen_cloexec.
	* fork-child.c (fork_inferior): Call close_most_fds.
	* gdb_bfd.c (gdb_bfd_open): Use gdb_open_cloexec.
	* inf-child.c (inf_child_fileio_readlink): Use gdb_open_cloexec.
	* linux-nat.c (linux_nat_thread_name, linux_proc_pending_signals):
	Use gdb_fopen_cloexec.
	(linux_proc_xfer_partial, linux_proc_xfer_spu): Use
	gdb_open_cloexec.
	(linux_async_pipe): Use gdb_pipe_cloexec.
	* remote-fileio.c (remote_fileio_func_open): Use
	gdb_open_cloexec.
	* remote.c (remote_file_put, remote_file_get): Use
	gdb_fopen_cloexec.
	* ser-pipe.c (pipe_open): Use gdb_socketpair_cloexec,
	close_most_fds.
	* ser-tcp.c (net_open): Use gdb_socket_cloexec.
	* ser-unix.c (hardwire_open): Use gdb_open_cloexec.
	* solib.c (solib_find): Use gdb_open_cloexec.
	* source.c (openp, find_and_open_source): Use gdb_open_cloexec.
	* tracepoint.c (tfile_start): Use gdb_fopen_cloexec.
	(tfile_open): Use gdb_open_cloexec.
	* tui/tui-io.c (tui_initialize_io): Use gdb_pipe_cloexec.
	* ui-file.c (gdb_fopen): Use gdb_fopen_cloexec.
	* xml-support.c (xml_fetch_content_from_file): Use
	gdb_fopen_cloexec.
	* main.c (captured_main): Call notice_open_fds.
gdbserver
	* Makefile.in (SFILES): Add filestuff.c.
	(OBS): Add filestuff.o.
	(filestuff.o): New target.
	* config.in, configure: Rebuild.
	* configure.ac: Check for fdwalk, pipe2.
@
text
@d8189 1
a8189 1
     per_cu->s.type_unit_group may not have been set up yet.  */
@


1.786
log
@-Wpointer-sign: dwarf2read.c.

This fixes the remaining issues necessary to make the DWARF reader
-Wpointer-sign clean.  The 'filename' bit should be obvious.
'constant_pool' holds the contents of an obstack, which are 'char *'.
gdb_byte would work too, but it'd need more casts elsewhere, so I just
chose the minimal approach.  Any way would be fine with me.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* dwarf2read.c (dwarf2_get_dwz_file): Add cast to const char *.
	(read_index_from_section): Add cast to 'char *'.
@
text
@d71 1
d20702 1
a20702 1
  out_file = fopen (filename, "wb");
@


1.785
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d2106 1
a2106 1
  filename = data;
d2767 1
a2767 1
  map->constant_pool = addr + MAYBE_SWAP (metadata[i]);
@


1.784
log
@	* dwarf2read.c (struct signatured_type): New member type.
	(struct attribute): Replace member signatured_type with signature.
	(DW_SIGNATURE): Replaces DW_SIGNATURE_TYPE.
	(read_call_site_scope): Call follow_die_ref instead of
	follow_die_ref_or_sig.
	(read_structure_type): Rewrite handling of signatured types.
	(read_enumeration_type): Ditto.
	(read_attribute_value): Update.
	(build_error_marker_type): New function.
	(lookup_die_type): Add assert.  Rewrite handling of signatured types.
	Don't call error for bad types, just build an error marker type.
	(dump_die_shallow): Update.
	(follow_die_sig_1): Renamed from follow_die_sig.
	Don't call error for bad types, instead return NULL.
	(follow_die_sig): New function.
	(get_signatured_type, get_DW_AT_signature_type): New functions.
@
text
@d2674 1
a2674 1
  const char *addr;
d8598 1
a8598 1
  const char *index_ptr, *index_end;
d20424 1
a20424 1
  char addr[8];
@


1.783
log
@	* dwarf2read.c (struct dwo_file): Replace member "cus" with "cu".
	(struct create_dwo_cu_data): Renamed from create_dwo_info_table_data.
	(create_dwo_cu_reader): Renamed from
	create_dwo_debug_info_hash_table_reader.
	(create_dwo_cu): Renamed from create_dwo_debug_info_hash_table.
	Remove support for multiple CUs in a DWO file.
	(open_and_init_dwo_file, lookup_dwo_cutu): Update.
@
text
@d604 1
d627 5
d1057 1
a1057 1
	struct signatured_type *signatured_type;
d1103 1
a1103 1
#define DW_SIGNATURED_TYPE(attr) ((attr)->u.signatured_type)
d1614 7
d1706 1
a1706 1
					    struct dwarf2_per_cu_data *per_cu);
d9957 1
a9957 1
      target_die = follow_die_ref_or_sig (die, attr, &target_cu);
d11386 1
a11386 8
      struct dwarf2_cu *type_cu = cu;
      struct die_info *type_die = follow_die_ref_or_sig (die, attr, &type_cu);

      /* We could just recurse on read_structure_type, but we need to call
	 get_die_type to ensure only one type for this DIE is created.
	 This is important, for example, because for c++ classes we need
	 TYPE_NAME set which is only done by new_symbol.  Blech.  */
      type = read_type_die (type_die, type_cu);
d11388 1
a11388 1
      /* TYPE_CU may not be the same as CU.
d11706 1
a11706 4
      struct dwarf2_cu *type_cu = cu;
      struct die_info *type_die = follow_die_ref_or_sig (die, attr, &type_cu);

      type = read_type_die (type_die, type_cu);
d11708 1
a11708 1
      /* TYPE_CU may not be the same as CU.
d14335 1
a14335 5
      /* Convert the signature to something we can record in DW_UNSND
	 for later lookup.
         NOTE: This is NULL if the type wasn't found.  */
      DW_SIGNATURED_TYPE (attr) =
	lookup_signatured_type (read_8_bytes (abfd, info_ptr));
d16603 19
d16623 2
d16634 4
d16656 1
a16656 8
      struct signatured_type *sig_type = DW_SIGNATURED_TYPE (attr);

      /* sig_type will be NULL if the signatured type is missing from
	 the debug info.  */
      if (sig_type == NULL)
	error (_("Dwarf Error: Cannot find signatured DIE referenced from DIE "
		 "at 0x%x [in module %s]"),
	       die->offset.sect_off, objfile->name);
d16658 1
a16658 10
      gdb_assert (sig_type->per_cu.is_debug_types);
      /* If we haven't filled in type_offset_in_section yet, then we
	 haven't read the type in yet.  */
      this_type = NULL;
      if (sig_type->type_offset_in_section.sect_off != 0)
	{
	  this_type =
	    get_die_type_at_offset (sig_type->type_offset_in_section,
				    &sig_type->per_cu);
	}
d16662 6
a16667 3
      dump_die_for_error (die);
      error (_("Dwarf Error: Bad type attribute %s [in module %s]"),
	     dwarf_attr_name (attr->name), objfile->name);
d16674 1
a16674 1
      struct die_info *type_die;
d16677 5
a16681 2
      type_die = follow_die_ref_or_sig (die, attr, &type_cu);
      /* If we found the type now, it's probably because the type came
d16684 1
a16684 3
      this_type = get_die_type (type_die, type_cu);
      if (this_type == NULL)
	this_type = read_type_die_1 (type_die, type_cu);
d16690 1
a16690 14
    {
      char *message, *saved;

      /* read_type_die already issued a complaint.  */
      message = xstrprintf (_("<unknown type in %s, CU 0x%x, DIE 0x%x>"),
			    objfile->name,
			    cu->header.offset.sect_off,
			    die->offset.sect_off);
      saved = obstack_copy0 (&objfile->objfile_obstack,
			     message, strlen (message));
      xfree (message);

      this_type = init_type (TYPE_CODE_ERROR, 0, 0, saved, objfile);
    }
d17424 2
a17425 11
	  if (DW_SIGNATURED_TYPE (&die->attrs[i]) != NULL)
	    {
	      struct signatured_type *sig_type =
		DW_SIGNATURED_TYPE (&die->attrs[i]);

	      fprintf_unfiltered (f, "signatured type: 0x%s, offset 0x%x",
				  hex_string (sig_type->signature),
				  sig_type->per_cu.offset.sect_off);
	    }
	  else
	    fprintf_unfiltered (f, "signatured type, unknown");
d17773 1
a17773 1
/* Follow the signature attribute ATTR in SRC_DIE.
d17775 2
a17776 1
   On exit *REF_CU is the CU of the result.  */
d17779 2
a17780 2
follow_die_sig (struct die_info *src_die, struct attribute *attr,
		struct dwarf2_cu **ref_cu)
a17783 1
  struct signatured_type *sig_type = DW_SIGNATURED_TYPE (attr);
d17787 3
a17789 6
  /* sig_type will be NULL if the signatured type is missing from
     the debug info.  */
  if (sig_type == NULL)
    error (_("Dwarf Error: Cannot find signatured DIE referenced from DIE "
	     "at 0x%x [in module %s]"),
	   src_die->offset.sect_off, objfile->name);
d17819 132
a17950 3
  error (_("Dwarf Error: Cannot find signatured DIE at 0x%x referenced "
	 "from DIE at 0x%x [in module %s]"),
	 temp_die.offset.sect_off, src_die->offset.sect_off, objfile->name);
@


1.782
log
@	* dwarf2read.c (create_debug_types_hash_table): Use hex_string
	instead of phex.
	(lookup_dwo_unit, create_dwo_debug_info_hash_table_reader): Ditto.
	(create_dwo_in_dwp): Ditto.
@
text
@d745 6
a750 3
  /* Table of CUs in the file.
     Each element is a struct dwo_unit.  */
  htab_t cus;
d8394 1
a8394 1
struct create_dwo_info_table_data
d8397 1
a8397 1
  htab_t cu_htab;
d8400 1
a8400 1
/* die_reader_func for create_dwo_debug_info_hash_table.  */
d8403 5
a8407 5
create_dwo_debug_info_hash_table_reader (const struct die_reader_specs *reader,
					 const gdb_byte *info_ptr,
					 struct die_info *comp_unit_die,
					 int has_children,
					 void *datap)
d8413 1
a8413 1
  struct create_dwo_info_table_data *data = datap;
d8415 1
a8415 2
  htab_t cu_htab = data->cu_htab;
  void **slot;
a8416 1
  struct dwo_unit *dwo_unit;
d8421 4
a8424 3
      error (_("Dwarf Error: debug entry at offset 0x%x is missing"
	       " its dwo_id [in module %s]"),
	     offset.sect_off, dwo_file->dwo_name);
a8427 1
  dwo_unit = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct dwo_unit);
a8433 15
  slot = htab_find_slot (cu_htab, dwo_unit, INSERT);
  gdb_assert (slot != NULL);
  if (*slot != NULL)
    {
      const struct dwo_unit *dup_dwo_unit = *slot;

      complaint (&symfile_complaints,
		 _("debug entry at offset 0x%x is duplicate to the entry at"
		   " offset 0x%x, dwo_id %s [in module %s]"),
		 offset.sect_off, dup_dwo_unit->offset.sect_off,
		 hex_string (dwo_unit->signature), dwo_file->dwo_name);
    }
  else
    *slot = dwo_unit;

d8439 2
a8440 4
/* Create a hash table to map DWO IDs to their CU entry in
   .debug_info.dwo in DWO_FILE.
   Note: This function processes DWO files only, not DWP files.
   Note: A DWO file generally contains one CU, but we don't assume this.  */
d8442 2
a8443 2
static htab_t
create_dwo_debug_info_hash_table (struct dwo_file *dwo_file)
d8450 2
a8451 1
  struct create_dwo_info_table_data create_dwo_info_table_data;
d8464 5
a8468 2
    fprintf_unfiltered (gdb_stdlog, "Reading .debug_info.dwo for %s:\n",
			bfd_get_filename (abfd));
d8470 2
a8471 4
  cu_htab = allocate_dwo_unit_table (objfile);

  create_dwo_info_table_data.dwo_file = dwo_file;
  create_dwo_info_table_data.cu_htab = cu_htab;
d8478 2
d8489 19
a8507 2
					 create_dwo_debug_info_hash_table_reader,
					 &create_dwo_info_table_data);
d8512 1
a8512 1
  return cu_htab;
d9063 1
a9063 1
   by PER_CU.
d9091 1
a9091 1
  dwo_file->cus = create_dwo_debug_info_hash_table (dwo_file);
d9322 1
a9322 1
      htab_t htab = is_debug_types ? dwo_file->tus : dwo_file->cus;
d9324 1
a9324 1
      if (htab != NULL)
d9326 1
a9326 1
	  struct dwo_unit find_dwo_cutu, *dwo_cutu;
d9330 7
a9336 1
	  dwo_cutu = htab_find (htab, &find_dwo_cutu);
d9338 3
a9340 1
	  if (dwo_cutu != NULL)
d9342 3
a9344 7
	      if (dwarf2_read_debug)
		{
		  fprintf_unfiltered (gdb_stdlog, "DWO %s %s(%s) found: @@%s\n",
				      kind, dwo_name, hex_string (signature),
				      host_address_to_string (dwo_cutu));
		}
	      return dwo_cutu;
d9346 1
@


1.781
log
@	PR c++/11990:
	* c-lang.c (cplus_language_defn): Use gdb_demangle.
	* c-typeprint.c (c_type_print_base): Use gdb_demangle.
	* cp-support.c (mangled_name_to_comp): Use gdb_demangle.
	(gdb_demangle): New function.
	* cp-support.h (gdb_demangle): Declare.
	* dwarf2read.c (dwarf2_physname, fixup_partial_die)
	(dwarf2_name): Use gdb_demangle.
	* gdbtypes.c (check_stub_method): Use gdb_demangle.
	* gnu-v3-abi.c (gnuv3_rtti_type): Strip @@plt and version
	suffixes from name.
	(gnuv3_print_method_ptr): Use gdb_demangle.
	* jv-lang.c (java_demangle): Use gdb_demangle.
	* jv-typeprint.c (java_type_print_base): Use gdb_demangle.
	* language.c (unk_lang_demangle): Use gdb_demangle.
	* symtab.c (symbol_find_demangled_name)
	(demangle_for_lookup): Use gdb_demangle.
@
text
@d4320 1
a4320 1
			   " the entry at offset 0x%x, signature 0x%s"),
d4322 1
a4322 1
			 phex (signature, sizeof (signature)));
d4327 1
a4327 1
	    fprintf_unfiltered (gdb_stdlog, "  offset 0x%x, signature 0x%s\n",
d4329 1
a4329 1
				phex (signature, sizeof (signature)));
d4637 1
a4637 2
	     this_cu->offset.sect_off,
	     phex (signature, sizeof (signature)),
d8441 1
a8441 1
		   " offset 0x%x, dwo_id 0x%s [in module %s]"),
d8443 1
a8443 2
		 phex (dwo_unit->signature, sizeof (dwo_unit->signature)),
		 dwo_file->dwo_name);
d8449 2
a8450 4
    fprintf_unfiltered (gdb_stdlog, "  offset 0x%x, dwo_id 0x%s\n",
			offset.sect_off,
			phex (dwo_unit->signature,
			      sizeof (dwo_unit->signature)));
d8733 1
a8733 1
      fprintf_unfiltered (gdb_stdlog, "Reading %s %u/0x%s in DWP file: %s\n",
d8735 1
a8735 1
			  section_index, phex (signature, sizeof (signature)),
@


1.780
log
@	* dwarf2-frame.c (struct comp_unit) <dwarf_frame_buffer>: Now
	const.
	* dwarf2read.c (struct dwarf2_section_info) <buffer>: Now const.
	(struct die_reader_specs) <buffer>: Likewise.
	(die_reader_func_ftype): Make 'info_ptr' const.
	(struct line_header) <include_dirs, statement_program_start,
	statement_program_end>: Now const.
	(struct file_entry) <name>: Likewise.
	(struct partial_die_info) <sibling>: Likewise.
	(struct dwarf_block) <data>: Likewise.
	(dwarf2_read_section): Remove cast.
	(dwarf2_get_section_info): Make 'bufp' const.
	(read_index_from_section): Constify.
	(dw2_get_file_names_reader): Make 'info_ptr' const.
	(dw2_get_primary_filename_reader): Likewise.
	(read_comp_unit_head): Make 'info_ptr' and return type const.
	(read_and_check_comp_unit_head, read_and_check_type_unit_head):
	Likewise.
	(read_abbrev_offset): Constify.
	(dwarf2_create_include_psymtab): Make 'name' const.
	(create_debug_types_hash_table): Update.
	(read_cutu_die_from_dwo): Make 'result_info_ptr' const.
	(init_cutu_and_read_dies, init_cutu_and_read_dies_no_follow):
	Constify.
	(process_psymtab_comp_unit_reader, build_type_psymtabs_reader)
	(load_partial_comp_unit_reader): Make 'info_ptr' const.
	(read_comp_units_from_section): Constify.
	(peek_abbrev_code, peek_die_abbrev, skip_children, skip_one_die)
	(locate_pdi_sibling, load_full_comp_unit_reader): Make 'info_ptr'
	const.
	(dwarf2_compute_name, setup_type_unit_groups): Constify.
	(create_dwo_debug_info_hash_table): Make 'info_ptr' const.
	(create_dwp_hash_table, dwarf2_ranges_read)
	(dwarf2_record_block_ranges): Constify.
	(read_die_and_children, read_die_and_siblings_1)
	(read_die_and_siblings): Make 'info_ptr' and 'new_info_ptr'
	const.
	(read_full_die_1, read_full_die): Make 'info_ptr' const.
	(abbrev_table_read_table): Constify.
	(load_partial_dies): Make 'info_ptr' const.
	(read_partial_die, read_attribute_value, read_attribute): Make
	'info_ptr' and return type const.
	(read_address, read_initial_length)
	(read_checked_initial_length_and_offset, read_offset)
	(read_offset_1, read_n_bytes, read_direct_string): Make 'buf'
	const.
	(read_direct_string): Make 'buf' and return type const.
	(read_indirect_string_at_offset, read_indirect_string_from_dwz)
	(read_indirect_string): Make return type const.
	(read_unsigned_leb128, read_signed_leb128): Make 'buf' const.
	(read_addr_index_from_leb128, dwarf2_read_addr_index_reader): Make
	'info_ptr' const.
	(read_str_index): Make return type const.
	(add_include_dir): Make 'include_dir' const.
	(add_file_name): Make 'name' const.
	(dwarf_decode_line_header): Constify.
	(psymtab_include_file_name): Make return type const.
	(dwarf_decode_lines_1, dwarf_decode_lines): Constify.
	(dwarf2_start_subfile): Make 'filename' const.
	(dwarf2_const_value_attr): Make 'bytes' const.
	(read_signatured_type_reader): Make 'info_ptr' const.
	(decode_locdesc): Constify.
	(skip_form_bytes): Make 'bytes', 'buffer_end', and return type
	const.
	(skip_unknown_opcode): Make 'opcode_definitions', 'mac_ptr',
	'mac_end', and return type const.
	(dwarf_parse_macro_header): Make 'mac_ptr' and return type const.
	(dwarf_decode_macro_bytes): Make 'mac_ptr', 'mac_end', and return
	type const.
	(per_cu_header_read_in): Constify.
	* symfile.h (dwarf2_get_section_info): Update.
@
text
@d7766 5
a7770 5
	  demangled = cplus_demangle (mangled,
				      (DMGL_PARAMS | DMGL_ANSI
				       | (cu->language == language_java
					  ? DMGL_JAVA | DMGL_RET_POSTFIX
					  : DMGL_RET_DROP)));
d14157 1
a14157 1
      demangled = cplus_demangle (part_die->linkage_name, DMGL_TYPES);
d17217 1
a17217 1
	    demangled = cplus_demangle (DW_STRING (attr), DMGL_TYPES);
@


1.779
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@d105 1
a105 1
  gdb_byte *buffer;
d852 1
a852 1
  gdb_byte *buffer;
d860 1
a860 1
				      gdb_byte *info_ptr,
d891 1
a891 1
  char **include_dirs;
d899 1
a899 1
    char *name;
d909 1
a909 1
  gdb_byte *statement_program_start, *statement_program_end;
d980 1
a980 1
    gdb_byte *sibling;
d1102 1
a1102 1
    gdb_byte *data;
a1274 3
static void dwarf2_create_include_psymtab (char *, struct partial_symtab *,
                                           struct objfile *);

d1325 1
a1325 1
static unsigned int peek_abbrev_code (bfd *, gdb_byte *);
d1328 1
a1328 1
  (const struct die_reader_specs *, gdb_byte *, int);
d1330 5
a1334 5
static gdb_byte *read_partial_die (const struct die_reader_specs *,
				   struct partial_die_info *,
				   struct abbrev_info *,
				   unsigned int,
				   gdb_byte *);
d1342 3
a1344 3
static gdb_byte *read_attribute (const struct die_reader_specs *,
				 struct attribute *, struct attr_abbrev *,
				 gdb_byte *);
d1356 1
a1356 1
static CORE_ADDR read_address (bfd *, gdb_byte *ptr, struct dwarf2_cu *,
d1359 1
a1359 1
static LONGEST read_initial_length (bfd *, gdb_byte *, unsigned int *);
d1362 1
a1362 1
  (bfd *, gdb_byte *, const struct comp_unit_head *,
d1365 2
a1366 1
static LONGEST read_offset (bfd *, gdb_byte *, const struct comp_unit_head *,
d1369 1
a1369 1
static LONGEST read_offset_1 (bfd *, gdb_byte *, unsigned int);
d1374 1
a1374 1
static gdb_byte *read_n_bytes (bfd *, gdb_byte *, unsigned int);
d1376 1
a1376 1
static char *read_direct_string (bfd *, gdb_byte *, unsigned int *);
d1378 3
a1380 3
static char *read_indirect_string (bfd *, gdb_byte *,
                                   const struct comp_unit_head *,
                                   unsigned int *);
d1382 1
a1382 1
static char *read_indirect_string_from_dwz (struct dwz_file *, LONGEST);
d1384 1
a1384 1
static ULONGEST read_unsigned_leb128 (bfd *, gdb_byte *, unsigned int *);
d1386 1
a1386 1
static LONGEST read_signed_leb128 (bfd *, gdb_byte *, unsigned int *);
d1388 2
a1389 1
static CORE_ADDR read_addr_index_from_leb128 (struct dwarf2_cu *, gdb_byte *,
d1392 2
a1393 2
static char *read_str_index (const struct die_reader_specs *reader,
			     struct dwarf2_cu *cu, ULONGEST str_index);
a1412 3
static void add_file_name (struct line_header *, char *, unsigned int,
                           unsigned int, unsigned int);

d1420 1
a1420 1
static void dwarf2_start_subfile (char *, const char *, const char *);
d1439 1
a1439 1
				     gdb_byte **bytes,
d1530 1
a1530 1
  (const struct die_reader_specs *, gdb_byte *, gdb_byte **,
d1534 2
a1535 2
					       gdb_byte *info_ptr,
					       gdb_byte **new_info_ptr,
d1538 7
a1544 5
static gdb_byte *read_full_die_1 (const struct die_reader_specs *,
				  struct die_info **, gdb_byte *, int *, int);

static gdb_byte *read_full_die (const struct die_reader_specs *,
				struct die_info **, gdb_byte *, int *);
d1638 3
a1640 3
static gdb_byte *skip_one_die (const struct die_reader_specs *reader,
			       gdb_byte *info_ptr,
			       struct abbrev_info *abbrev);
d1712 1
a1712 1
static gdb_byte *read_and_check_comp_unit_head
d1715 1
a1715 1
   struct dwarf2_section_info *abbrev_section, gdb_byte *info_ptr,
d1943 1
a1943 5
      const gdb_byte *bytes = gdb_bfd_map_section (sectp, &info->size);

      /* We have to cast away const here for historical reasons.
	 Fixing dwarf2read to be const-correct would be quite nice.  */
      info->buffer = (gdb_byte *) bytes;
d1989 1
a1989 1
                         asection **sectp, gdb_byte **bufp,
d2658 1
a2658 1
  char *addr;
d2846 1
a2846 1
			   gdb_byte *info_ptr,
d3389 1
a3389 1
				 gdb_byte *info_ptr,
d3900 1
a3900 1
static gdb_byte *
d3902 1
a3902 1
		     gdb_byte *info_ptr, bfd *abfd)
d3981 1
a3981 1
static gdb_byte *
d3985 1
a3985 1
			       gdb_byte *info_ptr,
d3988 1
a3988 1
  gdb_byte *beg_of_comp_unit = info_ptr;
d4010 1
a4010 1
static gdb_byte *
d4014 1
a4014 1
			       gdb_byte *info_ptr,
d4018 1
a4018 1
  gdb_byte *beg_of_comp_unit = info_ptr;
d4049 1
a4049 1
  gdb_byte *info_ptr;
d4066 1
a4066 1
dwarf2_create_include_psymtab (char *name, struct partial_symtab *pst,
d4207 1
a4207 1
      gdb_byte *info_ptr, *end_ptr;
d4238 1
a4238 1
	  gdb_byte *ptr = info_ptr;
d4425 1
a4425 1
			gdb_byte **result_info_ptr,
d4433 1
a4433 1
  gdb_byte *begin_info_ptr, *info_ptr;
d4672 1
a4672 1
  gdb_byte *begin_info_ptr, *info_ptr;
d4890 1
a4890 1
  gdb_byte *begin_info_ptr, *info_ptr;
d5313 1
a5313 1
				  gdb_byte *info_ptr,
d5474 1
a5474 1
			    gdb_byte *info_ptr,
d5662 1
a5662 1
			       gdb_byte *info_ptr,
d5696 1
a5696 1
  gdb_byte *info_ptr;
d6316 1
a6316 1
peek_abbrev_code (bfd *abfd, gdb_byte *info_ptr)
d6329 1
a6329 1
peek_die_abbrev (gdb_byte *info_ptr, unsigned int *bytes_read,
d6355 2
a6356 2
static gdb_byte *
skip_children (const struct die_reader_specs *reader, gdb_byte *info_ptr)
d6378 2
a6379 2
static gdb_byte *
skip_one_die (const struct die_reader_specs *reader, gdb_byte *info_ptr,
d6386 1
a6386 1
  gdb_byte *buffer = reader->buffer;
d6388 1
a6388 1
  gdb_byte *start_info_ptr = info_ptr;
d6471 1
a6471 1
	  info_ptr = (gdb_byte *) safe_skip_leb128 (info_ptr, buffer_end);
d6497 1
a6497 1
static gdb_byte *
d6500 1
a6500 1
		    gdb_byte *info_ptr)
d6794 1
a6794 1
			    gdb_byte *info_ptr,
d7551 1
a7551 1
		  gdb_byte *bytes;
d8217 1
a8217 1
	  char *dir = NULL;
d8402 1
a8402 1
					 gdb_byte *info_ptr,
d8469 1
a8469 1
  gdb_byte *info_ptr, *end_ptr;
d8584 1
a8584 1
  char *index_ptr, *index_end;
d10109 1
a10109 1
  gdb_byte *buffer;
d10461 1
a10461 1
      gdb_byte *buffer = dwarf2_per_objfile->ranges.buffer + offset;
d13063 2
a13064 2
		       gdb_byte *info_ptr,
		       gdb_byte **new_info_ptr,
d13068 1
a13068 1
  gdb_byte *cur_ptr;
d13098 2
a13099 2
			 gdb_byte *info_ptr,
			 gdb_byte **new_info_ptr,
d13103 1
a13103 1
  gdb_byte *cur_ptr;
d13135 2
a13136 2
		       gdb_byte *info_ptr,
		       gdb_byte **new_info_ptr,
d13164 1
a13164 1
static gdb_byte *
d13166 1
a13166 1
		 struct die_info **diep, gdb_byte *info_ptr,
d13216 1
a13216 1
static gdb_byte *
d13218 1
a13218 1
	       struct die_info **diep, gdb_byte *info_ptr,
d13221 1
a13221 1
  gdb_byte *result;
d13304 1
a13304 1
  gdb_byte *abbrev_ptr;
d13473 1
a13473 1
		   gdb_byte *info_ptr, int building_psymtab)
d13747 1
a13747 1
static gdb_byte *
d13751 1
a13751 1
		  gdb_byte *info_ptr)
d13755 1
a13755 1
  gdb_byte *buffer = reader->buffer;
d14181 1
a14181 1
static gdb_byte *
d14184 1
a14184 1
		      gdb_byte *info_ptr)
d14405 1
a14405 1
static gdb_byte *
d14408 1
a14408 1
		gdb_byte *info_ptr)
d14459 1
a14459 1
read_address (bfd *abfd, gdb_byte *buf, struct dwarf2_cu *cu,
d14548 1
a14548 1
read_initial_length (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read)
d14580 1
a14580 1
read_checked_initial_length_and_offset (bfd *abfd, gdb_byte *buf,
d14603 2
a14604 1
read_offset (bfd *abfd, gdb_byte *buf, const struct comp_unit_head *cu_header,
d14616 1
a14616 1
read_offset_1 (bfd *abfd, gdb_byte *buf, unsigned int offset_size)
d14637 2
a14638 2
static gdb_byte *
read_n_bytes (bfd *abfd, gdb_byte *buf, unsigned int size)
d14647 3
a14649 2
static char *
read_direct_string (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
d14660 2
a14661 2
  *bytes_read_ptr = strlen ((char *) buf) + 1;
  return (char *) buf;
d14664 1
a14664 1
static char *
d14678 1
a14678 1
  return (char *) (dwarf2_per_objfile->str.buffer + str_offset);
d14686 1
a14686 1
static char *
d14702 1
a14702 1
  return (char *) (dwz->str.buffer + str_offset);
d14705 2
a14706 2
static char *
read_indirect_string (bfd *abfd, gdb_byte *buf,
d14716 2
a14717 1
read_unsigned_leb128 (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
d14745 2
a14746 1
read_signed_leb128 (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
d14812 1
a14812 1
read_addr_index_from_leb128 (struct dwarf2_cu *cu, gdb_byte *info_ptr,
d14834 1
a14834 1
			       gdb_byte *info_ptr,
d14902 1
a14902 1
static char *
d14910 1
a14910 1
  gdb_byte *info_ptr;
d14937 1
a14937 1
  return (char *) (sections->str.buffer + str_offset);
d15126 1
a15126 1
add_include_dir (struct line_header *lh, char *include_dir)
d15150 1
a15150 1
               char *name,
d15218 1
a15218 1
  gdb_byte *line_ptr;
d15221 1
a15221 1
  char *cur_dir, *cur_file;
d15350 1
a15350 1
static char *
d15356 3
a15358 3
  char *include_name = fe.name;
  char *include_name_to_compare = include_name;
  char *dir_name = NULL;
d15390 5
a15394 2
	  include_name = concat (dir_name, SLASH_STRING,
				 include_name, (char *)NULL);
a15395 1
	  make_cleanup (xfree, include_name);
d15399 5
a15403 2
	  include_name_to_compare = concat (comp_dir, SLASH_STRING,
					    include_name, (char *)NULL);
a15416 2
  if (include_name_to_compare != include_name)
    xfree (include_name_to_compare);
d15440 2
a15441 2
  gdb_byte *line_ptr, *extended_end;
  gdb_byte *line_end;
d15479 1
a15479 1
          char *dir = NULL;
d15570 1
a15570 1
                    char *cur_file;
d15652 1
a15652 1
                char *dir = NULL;
d15772 1
a15772 1
	    char *include_name =
d15787 1
a15787 1
	  char *dir = NULL;
d15834 1
a15834 1
dwarf2_start_subfile (char *filename, const char *dirname,
d15837 1
a15837 1
  char *fullname;
d15850 4
a15853 3
    fullname = concat (dirname, SLASH_STRING, filename, (char *)NULL);
  else
    fullname = filename;
d15855 1
a15855 1
  start_subfile (fullname, comp_dir);
d15857 2
a15858 2
  if (fullname != filename)
    xfree (fullname);
d16379 1
a16379 1
			 LONGEST *value, gdb_byte **bytes,
d16427 1
a16427 1
      *bytes = (gdb_byte *) DW_STRING (attr);
d16490 1
a16490 1
  gdb_byte *bytes;
d17859 1
a17859 1
			     gdb_byte *info_ptr,
d17934 1
a17934 1
  gdb_byte *data = blk->data;
d18463 2
a18464 2
static gdb_byte *
skip_form_bytes (bfd *abfd, gdb_byte *bytes, gdb_byte *buffer_end,
d18520 1
a18520 1
      bytes = (gdb_byte *) gdb_skip_leb128 (bytes, buffer_end);
d18546 1
a18546 1
static gdb_byte *
d18548 2
a18549 2
		     gdb_byte **opcode_definitions,
		     gdb_byte *mac_ptr, gdb_byte *mac_end,
d18556 1
a18556 1
  gdb_byte *defn;
d18589 2
a18590 2
static gdb_byte *
dwarf_parse_macro_header (gdb_byte **opcode_definitions,
d18592 1
a18592 1
			  gdb_byte *mac_ptr,
d18649 2
a18650 1
dwarf_decode_macro_bytes (bfd *abfd, gdb_byte *mac_ptr, gdb_byte *mac_end,
d18661 1
a18661 1
  gdb_byte *opcode_definitions[256];
d18710 1
a18710 1
            char *body;
d18850 1
a18850 1
	    gdb_byte *include_mac_end = mac_end;
d18852 1
a18852 1
	    gdb_byte *new_mac_ptr;
d18883 1
a18883 1
		*slot = new_mac_ptr;
d18891 1
a18891 1
		htab_remove_elt (include_hash, new_mac_ptr);
d18930 1
a18930 1
  gdb_byte *mac_ptr, *mac_end;
d18934 1
a18934 1
  gdb_byte *opcode_definitions[256];
d19108 1
a19108 1
  *slot = mac_ptr;
d19297 1
a19297 1
  gdb_byte *info_ptr;
@


1.778
log
@	* coffread.c (process_coff_symbol, coff_read_enum_type): Call
	allocate_symbol.
	* dwarf2read.c (fixup_go_packaging): Call allocate_symbol.
	(read_func_scope): Call allocate_template_symbol.
	(new_symbol_full): Call allocate_symbol.
	* jit.c (finalize_symtab): Call allocate_symbol.
	* jv-lang.c (add_class_symbol): Call allocate_symbol.
	* mdebugread.c (parse_symbol, new_block): Call allocate_symbol.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_end): Call allocate_symbol.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): New functions.
	* symtab.c (allocate_symbol, initialize_symbol)
	(allocate_template_symbol): Declare.
	* xcoffread.c (process_xcoff_symbol): Call initialize_symbol.
@
text
@d6956 1
a6956 1
      SYMBOL_SET_LANGUAGE (sym, language_go);
d15978 1
a15978 1
      SYMBOL_SET_LANGUAGE (sym, cu->language);
@


1.777
log
@	* dwarf2read.c (struct dwarf2_per_objfile): Tweak comment.
	(read_cutu_die_from_dwo): Add comments.
	(read_structure_type): Update comment.
	(read_enumeration_type, read_namespace_type): Update comment.
	(read_die_type, get_die_type_at_offset, get_die_type): Update comment.
@
text
@d6955 1
a6955 1
      sym = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct symbol);
d9642 1
a9642 2
	  templ_func = OBSTACK_ZALLOC (&objfile->objfile_obstack,
				       struct template_symbol);
d15974 1
a15974 1
	sym = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct symbol);
@


1.776
log
@	* dwarf2read.c (read_die_and_siblings_1): Renamed from
	read_die_and_siblings.
	(read_die_and_siblings): New function.
	(read_cutu_die_from_dwo): Dump die if requested.
	(read_die_and_children): Call read_full_die_1 and
	read_die_and_siblings_1.
	(read_full_die): Dump die if requested.

	* dwarf2read.c (read_comp_units_from_section): Add debugging printf.
@
text
@d276 1
a276 1
     The mapping is done via (CU/TU signature + DIE offset) -> type.  */
d4529 2
a4530 1
  /* Replace the CU's original abbrev table with the DWO's.  */
d4536 1
d4543 1
d11384 1
a11384 1
	 Ensure TYPE is recorded in CU's type_hash table.  */
d11707 1
a11707 1
	 Ensure TYPE is recorded in CU's type_hash table.  */
d12209 1
a12209 1
	 Ensure TYPE is recorded in CU's type_hash table.  */
d16692 1
a16692 1
   This first does a lookup in the appropriate type_hash table,
d19702 2
a19703 2
/* Look up the type for the die at OFFSET in the appropriate type_hash
   table, or return NULL if the die does not have a saved type.  */
d19723 1
a19723 1
/* Look up the type for DIE in the appropriate type_hash table,
@


1.775
log
@	* dwarf2read.c (struct dwo_file): New member comp_dir.
	Rename member name to dwo_name.  All uses updated.
	(hash_dwo_file): Include comp_dir in computation.
	(eq_dwo_file): Ditto.
	(lookup_dwo_file_slot): New arg comp_dir.  All callers updated.
	(create_dwo_in_dwp, lookup_dwo_in_dwp, open_and_init_dwo_file): Ditto.
@
text
@d1533 3
a1535 4
static struct die_info *read_die_and_children (const struct die_reader_specs *,
					       gdb_byte *info_ptr,
					       gdb_byte **new_info_ptr,
					       struct die_info *parent);
d4570 10
d5702 4
d13075 1
a13075 1
  cur_ptr = read_full_die (reader, &die, info_ptr, &has_children);
d13084 1
a13084 1
    die->child = read_die_and_siblings (reader, cur_ptr, new_info_ptr, die);
d13101 4
a13104 4
read_die_and_siblings (const struct die_reader_specs *reader,
		       gdb_byte *info_ptr,
		       gdb_byte **new_info_ptr,
		       struct die_info *parent)
d13132 28
d13225 16
a13240 1
  return read_full_die_1 (reader, diep, info_ptr, has_children, 0);
@


1.774
log
@	* dwarf2read.c (read_structure_type): Fix typo in comment.
@
text
@d729 1
a729 1
  /* The DW_AT_GNU_dwo_name attribute.  This is the hash key.
d733 4
a736 1
  const char *name;
d8292 2
a8293 1
  return htab_hash_string (dwo_file->name);
d8302 2
a8303 1
  return strcmp (lhs->name, rhs->name) == 0;
d8325 1
a8325 1
lookup_dwo_file_slot (const char *dwo_name)
d8334 2
a8335 1
  find_entry.name = dwo_name;
d8413 1
a8413 1
	     offset.sect_off, dwo_file->name);
d8435 1
a8435 1
		 dwo_file->name);
d8703 2
a8704 1
   SECTION_INDEX is the index of the DWO in HTAB.  */
d8710 1
d8810 1
a8810 1
  dwo_file_slot = lookup_dwo_file_slot (virtual_dwo_name);
d8820 4
a8823 3
      dwo_file->name = obstack_copy0 (&objfile->objfile_obstack,
				      virtual_dwo_name,
				      strlen (virtual_dwo_name));
d8867 1
d8898 1
a8898 1
				     signature, is_debug_types);
d9056 2
a9057 1
open_and_init_dwo_file (const char *dwo_name, const char *comp_dir)
d9072 2
a9073 2
  dwo_file->name = obstack_copy0 (&objfile->objfile_obstack,
				  dwo_name, strlen (dwo_name));
d9281 2
a9282 1
	    lookup_dwo_in_dwp (dwp_file, dwp_htab, signature, is_debug_types);
d9300 1
a9300 1
  dwo_file_slot = lookup_dwo_file_slot (dwo_name);
d9304 1
a9304 1
      *dwo_file_slot = open_and_init_dwo_file (dwo_name, comp_dir);
@


1.773
log
@	* dwarf2read.c (lookup_signatured_type_at_offset): Delete.
	(process_enumeration_scope): Simplify.
@
text
@d11318 1
a11318 1
   processed until process_structure_type.
@


1.772
log
@	* dwarf2read.c (struct dwarf2_per_cu_data): Move member
	type_unit_group ...
	(struct signatured_type): ... to here.
	(sig_type_ptr): New typedef.
	(type_unit_group): Delete member 't.first_cu'.  Move member 'tus'
	out of union 't'.  All uses updated.
	(dw2_get_file_names_reader): Assert not called for a type unit.
	(dw2_get_file_names): Assert not called for a type unit or type
	unit group.
	(build_type_psymtabs_reader): Assert called for a type unit.
	(build_type_psymtab_dependencies): Assert called for a type unit group.
@
text
@a1604 4
static struct signatured_type *lookup_signatured_type_at_offset
    (struct objfile *objfile,
     struct dwarf2_section_info *section, sect_offset offset);

d11808 1
a11808 4
      sig_type
	= lookup_signatured_type_at_offset (dwarf2_per_objfile->objfile,
					    cu->per_cu->section,
					    cu->per_cu->offset);
a17758 28
/* Given an offset of a signatured type, return its signatured_type.  */

static struct signatured_type *
lookup_signatured_type_at_offset (struct objfile *objfile,
				  struct dwarf2_section_info *section,
				  sect_offset offset)
{
  gdb_byte *info_ptr = section->buffer + offset.sect_off;
  unsigned int length, initial_length_size;
  unsigned int sig_offset;
  struct signatured_type find_entry, *sig_type;

  length = read_initial_length (objfile->obfd, info_ptr, &initial_length_size);
  sig_offset = (initial_length_size
		+ 2 /*version*/
		+ (initial_length_size == 4 ? 4 : 8) /*debug_abbrev_offset*/
		+ 1 /*address_size*/);
  find_entry.signature = bfd_get_64 (objfile->obfd, info_ptr + sig_offset);
  sig_type = htab_find (dwarf2_per_objfile->signatured_types, &find_entry);

  /* This is only used to lookup previously recorded types.
     If we didn't find it, it's our bug.  */
  gdb_assert (sig_type != NULL);
  gdb_assert (offset.sect_off == sig_type->per_cu.offset.sect_off);

  return sig_type;
}

@


1.771
log
@	* dwarf2read.c (free_dwo_file): Add comment.
	(dwarf2_per_objfile_free): Unref dwp bfd.
@
text
@d545 3
a547 1
  /* Non-zero if this CU is from .debug_types.  */
a596 5

  /* Type units are grouped by their DW_AT_stmt_list entry so that they
     can share them.  If this is a TU, this points to the containing
     symtab.  */
  struct type_unit_group *type_unit_group;
d622 4
d628 3
d648 1
a648 1
  /* dwarf2read.c's main "handle" on the symtab.
d656 4
a659 12
  union
  {
    /* The TUs that share this DW_AT_stmt_list entry.
       This is added to while parsing type units to build partial symtabs,
       and is deleted afterwards and not used again.  */
    VEC (dwarf2_per_cu_ptr) *tus;

    /* When reading the line table in "quick" functions, we need a real TU.
       Any will do, we know they all share the same DW_AT_stmt_list entry.
       For simplicity's sake, we pick the first one.  */
    struct dwarf2_per_cu_data *first_tu;
  } t;
d2871 2
d2881 1
a2881 12
  /* If we're reading the line header for TUs, store it in the "per_cu"
     for tu_group.  */
  if (this_cu->is_debug_types)
    {
      struct type_unit_group *tu_group = data;

      gdb_assert (tu_group != NULL);
      lh_cu = &tu_group->per_cu;
    }
  else
    lh_cu = this_cu;

d2939 4
a2942 3
  /* For TUs this should only be called on the parent group.  */
  if (this_cu->is_debug_types)
    gdb_assert (IS_TYPE_UNIT_GROUP (this_cu));
d2950 1
a2950 13
  /* If DWO files are in use, we can still find the DW_AT_stmt_list attribute
     in the stub for CUs, there's is no need to lookup the DWO file.
     However, that's not the case for TUs where DW_AT_stmt_list lives in the
     DWO file.  */
  if (this_cu->is_debug_types)
    {
      struct type_unit_group *tu_group = this_cu->type_unit_group;

      init_cutu_and_read_dies (tu_group->t.first_tu, NULL, 0, 0,
			       dw2_get_file_names_reader, tu_group);
    }
  else
    init_cutu_and_read_dies_simple (this_cu, dw2_get_file_names_reader, NULL);
a5009 2
  per_cu->is_debug_types = 1;
  per_cu->type_unit_group = tu_group;
a5014 1
      tu_group->t.first_tu = cu->per_cu;
d5477 1
d5485 2
d5494 1
a5494 1
  VEC_safe_push (dwarf2_per_cu_ptr, tu_group->t.tus, per_cu);
d5523 2
a5524 2
  int len = VEC_length (dwarf2_per_cu_ptr, tu_group->t.tus);
  struct dwarf2_per_cu_data *iter;
d5528 1
d5534 1
a5534 1
       VEC_iterate (dwarf2_per_cu_ptr, tu_group->t.tus, i, iter);
d5537 2
a5538 1
      pst->dependencies[i] = iter->v.psymtab;
d5542 1
a5542 1
  VEC_free (dwarf2_per_cu_ptr, tu_group->t.tus);
d7180 4
d7211 1
a7211 1
  if (per_cu->type_unit_group->primary_symtab == NULL)
d7214 1
a7214 1
      per_cu->type_unit_group->primary_symtab = symtab;
d7229 2
a7230 2
			   per_cu->type_unit_group->primary_symtab);
      symtab = per_cu->type_unit_group->primary_symtab;
d8156 1
d8159 1
d8165 3
a8167 3
  if (per_cu->type_unit_group == NULL)
    per_cu->type_unit_group = get_type_unit_group (cu, attr);
  tu_group = per_cu->type_unit_group;
d20448 1
a20448 2
  struct dwarf2_per_cu_data *per_cu = &entry->per_cu;
  struct partial_symtab *psymtab = per_cu->v.psymtab;
@


1.770
log
@	* dwarf2read.c (open_dwo_file): Renamed from open_dwop_file.
	Delete arg is_dwp.  All callers updated.
	(open_dwp_file): New function.
	(open_and_init_dwp_file): Call it.
	(get_dwp_file): New function.
	(lookup_dwo_cutu): Call it.
@
text
@d9390 1
d19840 2
@


1.769
log
@	* dwarf2read.c (open_and_init_dwp_file): Remove incorrect, and
	unnecessary, cleanup.
@
text
@d8921 1
a8921 1
/* Subroutine of open_dwop_file to simplify it.
d8962 1
a8962 1
/* Try to open DWO/DWP file FILE_NAME.
a8963 1
   If IS_DWP is TRUE, we're opening a DWP file, otherwise a DWO file.
d8970 1
a8970 1
open_dwop_file (const char *file_name, const char *comp_dir, int is_dwp)
d8975 1
a8975 1
    return try_open_dwop_file (file_name, is_dwp);
d8985 1
a8985 1
      abfd = try_open_dwop_file (path_to_try, is_dwp);
d8997 1
a8997 1
  return try_open_dwop_file (file_name, is_dwp);
d9061 2
a9062 1
/* Initialize the use of the DWO file specified by DWO_NAME.
d9073 1
a9073 1
  dbfd = open_dwop_file (dwo_name, comp_dir, 0);
d9171 12
d9188 1
a9188 1
open_and_init_dwp_file (const char *comp_dir)
d9199 1
a9199 1
  dbfd = open_dwop_file (dwp_name, comp_dir, 1);
d9239 13
d9281 1
a9281 7
  if (! dwarf2_per_objfile->dwp_checked)
    {
      dwarf2_per_objfile->dwp_file = open_and_init_dwp_file (comp_dir);
      dwarf2_per_objfile->dwp_checked = 1;
    }
  dwp_file = dwarf2_per_objfile->dwp_file;

@


1.768
log
@	* dwarf2read.c (lookup_dwo_cutu): Improve complaint text.
@
text
@a9200 2
  cleanups = make_cleanup (free_dwo_file_cleanup, dwp_file);

a9214 2
  discard_cleanups (cleanups);

@


1.767
log
@	* dwarf2read.c (read_cutu_die_from_dwo): New function.
	(lookup_dwo_unit): New function.
	(init_cutu_and_read_dies): Move DWO handling to new functions.
@
text
@d9338 1
a9338 1
	     _("Could not find DWO CU referenced by CU at offset 0x%x"
d9340 1
a9340 1
	     this_unit->offset.sect_off, objfile->name);
@


1.766
log
@	* dwarf2read.c (struct signatured_type): Tweak comment.
	(struct dwo_unit): Tweak comment.
	(create_debug_types_hash_table): Tweak comment.  Reformat long line.
	(create_dwo_debug_info_hash_table): Tweak comment.
	(dwarf2_per_cu_offset_and_type): Tweak comment.
@
text
@d4438 226
d4746 1
d4826 4
a4829 3
  /* If we have a DWO stub, process it and then read in the DWO file.
     Note that if USE_EXISTING_OK != 0, and THIS_CU->cu already contains
     a DWO CU, that this test will fail.  */
a4832 2
      const char *dwo_name = DW_STRING (attr);
      const char *comp_dir_string;
d4834 1
a4834 4
      ULONGEST signature; /* Or dwo_id.  */
      struct attribute *comp_dir, *stmt_list, *low_pc, *high_pc, *ranges;
      int i,num_extra_attrs;
      struct dwarf2_section_info *dwo_abbrev_section;
d4840 6
a4845 146

      /* These attributes aren't processed until later:
	 DW_AT_stmt_list, DW_AT_low_pc, DW_AT_high_pc, DW_AT_ranges.
	 However, the attribute is found in the stub which we won't have later.
	 In order to not impose this complication on the rest of the code,
	 we read them here and copy them to the DWO CU/TU die.  */

      /* For TUs in DWO files, the DW_AT_stmt_list attribute lives in the
	 DWO file.  */
      stmt_list = NULL;
      if (! this_cu->is_debug_types)
	stmt_list = dwarf2_attr (comp_unit_die, DW_AT_stmt_list, cu);
      low_pc = dwarf2_attr (comp_unit_die, DW_AT_low_pc, cu);
      high_pc = dwarf2_attr (comp_unit_die, DW_AT_high_pc, cu);
      ranges = dwarf2_attr (comp_unit_die, DW_AT_ranges, cu);
      comp_dir = dwarf2_attr (comp_unit_die, DW_AT_comp_dir, cu);

      /* There should be a DW_AT_addr_base attribute here (if needed).
	 We need the value before we can process DW_FORM_GNU_addr_index.  */
      cu->addr_base = 0;
      attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_addr_base, cu);
      if (attr)
	cu->addr_base = DW_UNSND (attr);

      /* There should be a DW_AT_ranges_base attribute here (if needed).
	 We need the value before we can process DW_AT_ranges.  */
      cu->ranges_base = 0;
      attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_ranges_base, cu);
      if (attr)
	cu->ranges_base = DW_UNSND (attr);

      if (this_cu->is_debug_types)
	{
	  gdb_assert (sig_type != NULL);
	  signature = sig_type->signature;
	}
      else
	{
	  attr = dwarf2_attr (comp_unit_die, DW_AT_GNU_dwo_id, cu);
	  if (! attr)
	    error (_("Dwarf Error: missing dwo_id [in module %s]"),
		   dwo_name);
	  signature = DW_UNSND (attr);
	}

      /* We may need the comp_dir in order to find the DWO file.  */
      comp_dir_string = NULL;
      if (comp_dir)
	comp_dir_string = DW_STRING (comp_dir);

      if (this_cu->is_debug_types)
	dwo_unit = lookup_dwo_type_unit (sig_type, dwo_name, comp_dir_string);
      else
	dwo_unit = lookup_dwo_comp_unit (this_cu, dwo_name, comp_dir_string,
					 signature);

      if (dwo_unit == NULL)
	{
	  error (_("Dwarf Error: CU at offset 0x%x references unknown DWO"
		   " with ID %s [in module %s]"),
		 this_cu->offset.sect_off,
		 phex (signature, sizeof (signature)),
		 objfile->name);
	}

      /* Set up for reading the DWO CU/TU.  */
      cu->dwo_unit = dwo_unit;
      section = dwo_unit->section;
      dwarf2_read_section (objfile, section);
      begin_info_ptr = info_ptr = section->buffer + dwo_unit->offset.sect_off;
      dwo_abbrev_section = &dwo_unit->dwo_file->sections.abbrev;
      init_cu_die_reader (&reader, cu, section, dwo_unit->dwo_file);

      if (this_cu->is_debug_types)
	{
	  ULONGEST signature;
	  cu_offset type_offset_in_tu;

	  info_ptr = read_and_check_type_unit_head (&cu->header, section,
						    dwo_abbrev_section,
						    info_ptr,
						    &signature,
						    &type_offset_in_tu);
	  gdb_assert (sig_type->signature == signature);
	  gdb_assert (dwo_unit->offset.sect_off == cu->header.offset.sect_off);
	  /* For DWOs coming from DWP files, we don't know the CU length
	     nor the type's offset in the TU until now.  */
	  dwo_unit->length = get_cu_length (&cu->header);
	  dwo_unit->type_offset_in_tu = type_offset_in_tu;

	  /* Establish the type offset that can be used to lookup the type.
	     For DWO files, we don't know it until now.  */
	  sig_type->type_offset_in_section.sect_off =
	    dwo_unit->offset.sect_off + dwo_unit->type_offset_in_tu.cu_off;
	}
      else
	{
	  info_ptr = read_and_check_comp_unit_head (&cu->header, section,
						    dwo_abbrev_section,
						    info_ptr, 0);
	  gdb_assert (dwo_unit->offset.sect_off == cu->header.offset.sect_off);
	  /* For DWOs coming from DWP files, we don't know the CU length
	     until now.  */
	  dwo_unit->length = get_cu_length (&cu->header);
	}

      /* Discard the original CU's abbrev table, and read the DWO's.  */
      if (abbrev_table == NULL)
	{
	  dwarf2_free_abbrev_table (cu);
	  dwarf2_read_abbrevs (cu, dwo_abbrev_section);
	}
      else
	{
	  dwarf2_read_abbrevs (cu, dwo_abbrev_section);
	  make_cleanup (dwarf2_free_abbrev_table, cu);
	}

      /* Read in the die, but leave space to copy over the attributes
	 from the stub.  This has the benefit of simplifying the rest of
	 the code - all the real work is done here.  */
      num_extra_attrs = ((stmt_list != NULL)
			 + (low_pc != NULL)
			 + (high_pc != NULL)
			 + (ranges != NULL)
			 + (comp_dir != NULL));
      info_ptr = read_full_die_1 (&reader, &comp_unit_die, info_ptr,
				  &has_children, num_extra_attrs);

      /* Copy over the attributes from the stub to the DWO die.  */
      i = comp_unit_die->num_attrs;
      if (stmt_list != NULL)
	comp_unit_die->attrs[i++] = *stmt_list;
      if (low_pc != NULL)
	comp_unit_die->attrs[i++] = *low_pc;
      if (high_pc != NULL)
	comp_unit_die->attrs[i++] = *high_pc;
      if (ranges != NULL)
	comp_unit_die->attrs[i++] = *ranges;
      if (comp_dir != NULL)
	comp_unit_die->attrs[i++] = *comp_dir;
      comp_unit_die->num_attrs += num_extra_attrs;

      /* Skip dummy compilation units.  */
      if (info_ptr >= begin_info_ptr + dwo_unit->length
	  || peek_abbrev_code (abfd, info_ptr) == 0)
d4847 1
d4851 1
d4854 1
d4857 1
@


1.765
log
@	* dwarf2read.c (lookup_signatured_type): Remove complaint about
	missing .debug_types section.
@
text
@d615 2
a616 1
     If the definition lives in a DWO file, this value is unusable.  */
d704 1
a704 1
/* Common bits of DWO CUs/TUs.  */
d4203 8
a4210 6
/* Create the hash table of all entries in the .debug_types section.
   DWO_FILE is a pointer to the DWO file for .debug_types.dwo,
   NULL otherwise.
   Note: This function processes DWO files only, not DWP files.
   The result is a pointer to the hash table or NULL if there are
   no types.  */
d4351 2
a4352 2
			 _("debug type entry at offset 0x%x is duplicate to the "
			   "entry at offset 0x%x, signature 0x%s"),
d8376 2
a8377 1
   Note: This function processes DWO files only, not DWP files.  */
d19479 7
a19485 5
   or the type may come from a DWO file.  We have to use something in
   dwarf2_per_cu_data (or the pointer to it) because we can enter the lookup
   routine, get_die_type_at_offset, from outside this file, and thus won't
   necessarily have PER_CU->cu.  Fortunately, PER_CU is stable for the life
   of the objfile.  */
@


1.764
log
@	* dwarf2read.c (create_debug_types_hash_table): Don't allocate the
	types hash table until we know we need it.
@
text
@d4401 2
a4402 1
   Returns NULL if signature SIG is not present in the table.  */
d4410 1
a4410 6
    {
      complaint (&symfile_complaints,
		 _("missing `.debug_types' section for DW_FORM_ref_sig8 die"));
      return NULL;
    }

@


1.763
log
@	* dwarf2read.c (create_addrmap_from_index): Complain about bad CU
	index numbers.
@
text
@a4253 8
      if (types_htab == NULL)
	{
	  if (dwo_file)
	    types_htab = allocate_dwo_unit_table (objfile);
	  else
	    types_htab = allocate_signatured_type_table (objfile);
	}

d4290 8
@


1.762
log
@	* dwarf2read.c (dw2_get_file_names): Delete arg "objfile".
	All callers updated.
	(dw2_print_stats): Print #read CUs too.
	(dump_die_shallow): Print signatured types better.

	testsuite/
	* gdb.base/maint.exp (maint print statistics): Update expected output.
@
text
@d2533 12
a2544 3
      
      addrmap_set_empty (mutable_map, lo + baseaddr, hi + baseaddr - 1,
			 dw2_get_cu (cu_index));
@


1.761
log
@	* dwarf2read.c (struct dwarf2_per_cu_data): Rename member
	info_or_types_section to section.  All uses updated.
	(struct dwo_unit): Ditto.
@
text
@d2940 1
a2940 2
dw2_get_file_names (struct objfile *objfile,
		    struct dwarf2_per_cu_data *this_cu)
d3078 1
a3078 1
      file_data = dw2_get_file_names (objfile, per_cu);
d3296 1
a3296 1
  int i, count;
d3299 1
d3301 1
a3301 2
  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_units); ++i)
d3308 1
d3389 1
a3389 1
      file_data = dw2_get_file_names (objfile, per_cu);
d3542 1
a3542 1
	  file_data = dw2_get_file_names (objfile, per_cu);
d3746 1
a3746 1
      file_data = dw2_get_file_names (objfile, per_cu);
d17259 8
a17266 2
	    fprintf_unfiltered (f, "signatured type, offset: 0x%x",
			 DW_SIGNATURED_TYPE (&die->attrs[i])->per_cu.offset.sect_off);
d17268 1
a17268 1
	    fprintf_unfiltered (f, "signatured type, offset: unknown");
@


1.760
log
@	* dwarf2read.c (create_partial_symtab): Add forward decl.
	(create_partial_symtab): Move to be closer to other psymtab functions.
	(process_psymtab_comp_unit_reader, process_psymtab_comp_unit): Ditto.
@
text
@d554 1
a554 1
  struct dwarf2_section_info *info_or_types_section;
d648 1
a648 1
#define IS_TYPE_UNIT_GROUP(per_cu) ((per_cu)->info_or_types_section == NULL)
d716 1
a716 1
  struct dwarf2_section_info *info_or_types_section;
d776 1
a776 1
     That is recorded here, and copied to dwo_unit.info_or_types_section.  */
d2415 1
a2415 1
      the_cu->info_or_types_section = section;
d2487 1
a2487 1
      sig_type->per_cu.info_or_types_section = section;
d4297 1
a4297 1
	      dwo_tu->info_or_types_section = section;
d4312 1
a4312 1
	      sig_type->per_cu.info_or_types_section = section;
d4454 1
a4454 1
  struct dwarf2_section_info *section = this_cu->info_or_types_section;
d4676 1
a4676 1
      section = dwo_unit->info_or_types_section;
d4811 1
a4811 1
  struct dwarf2_section_info *section = this_cu->info_or_types_section;
d5136 1
a5136 1
	read_abbrev_offset (sig_type->per_cu.info_or_types_section,
d5645 1
a5645 1
      this_cu->info_or_types_section = section;
d8319 1
a8319 1
  struct dwarf2_section_info *section = cu->per_cu->info_or_types_section;
d8339 1
a8339 1
  dwo_unit->info_or_types_section = section;
d8408 1
a8408 1
      per_cu.info_or_types_section = section;
d8769 3
a8771 4
  dwo_unit->info_or_types_section =
    obstack_alloc (&objfile->objfile_obstack,
		   sizeof (struct dwarf2_section_info));
  *dwo_unit->info_or_types_section = sections.info_or_types;
d11718 1
a11718 1
					    cu->per_cu->info_or_types_section,
d19162 1
a19162 1
  info_ptr = per_cu->info_or_types_section->buffer + per_cu->offset.sect_off;
@


1.759
log
@	* dwarf2read.c (dwarf2_physname): Move declaration to better spot.
	(compute_symtab_includes): Remove unnecessary forward declaration.
	(die_needs_namespace): Add comment marking group of functions for
	dwarf2 name computation.
@
text
@d1281 3
d4879 2
d4882 5
a4886 186
/* Create a psymtab named NAME and assign it to PER_CU.

   The caller must fill in the following details:
   dirname, textlow, texthigh.  */

static struct partial_symtab *
create_partial_symtab (struct dwarf2_per_cu_data *per_cu, const char *name)
{
  struct objfile *objfile = per_cu->objfile;
  struct partial_symtab *pst;

  pst = start_psymtab_common (objfile, objfile->section_offsets,
			      name, 0,
			      objfile->global_psymbols.next,
			      objfile->static_psymbols.next);

  pst->psymtabs_addrmap_supported = 1;

  /* This is the glue that links PST into GDB's symbol API.  */
  pst->read_symtab_private = per_cu;
  pst->read_symtab = dwarf2_read_symtab;
  per_cu->v.psymtab = pst;

  return pst;
}

/* die_reader_func for process_psymtab_comp_unit.  */

static void
process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,
				  gdb_byte *info_ptr,
				  struct die_info *comp_unit_die,
				  int has_children,
				  void *data)
{
  struct dwarf2_cu *cu = reader->cu;
  struct objfile *objfile = cu->objfile;
  struct dwarf2_per_cu_data *per_cu = cu->per_cu;
  struct attribute *attr;
  CORE_ADDR baseaddr;
  CORE_ADDR best_lowpc = 0, best_highpc = 0;
  struct partial_symtab *pst;
  int has_pc_info;
  const char *filename;
  int *want_partial_unit_ptr = data;

  if (comp_unit_die->tag == DW_TAG_partial_unit
      && (want_partial_unit_ptr == NULL
	  || !*want_partial_unit_ptr))
    return;

  gdb_assert (! per_cu->is_debug_types);

  prepare_one_comp_unit (cu, comp_unit_die, language_minimal);

  cu->list_in_scope = &file_symbols;

  /* Allocate a new partial symbol table structure.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_name, cu);
  if (attr == NULL || !DW_STRING (attr))
    filename = "";
  else
    filename = DW_STRING (attr);

  pst = create_partial_symtab (per_cu, filename);

  /* This must be done before calling dwarf2_build_include_psymtabs.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_comp_dir, cu);
  if (attr != NULL)
    pst->dirname = DW_STRING (attr);

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  dwarf2_find_base_address (comp_unit_die, cu);

  /* Possibly set the default values of LOWPC and HIGHPC from
     `DW_AT_ranges'.  */
  has_pc_info = dwarf2_get_pc_bounds (comp_unit_die, &best_lowpc,
				      &best_highpc, cu, pst);
  if (has_pc_info == 1 && best_lowpc < best_highpc)
    /* Store the contiguous range if it is not empty; it can be empty for
       CUs with no code.  */
    addrmap_set_empty (objfile->psymtabs_addrmap,
		       best_lowpc + baseaddr,
		       best_highpc + baseaddr - 1, pst);

  /* Check if comp unit has_children.
     If so, read the rest of the partial symbols from this comp unit.
     If not, there's no more debug_info for this comp unit.  */
  if (has_children)
    {
      struct partial_die_info *first_die;
      CORE_ADDR lowpc, highpc;

      lowpc = ((CORE_ADDR) -1);
      highpc = ((CORE_ADDR) 0);

      first_die = load_partial_dies (reader, info_ptr, 1);

      scan_partial_symbols (first_die, &lowpc, &highpc,
			    ! has_pc_info, cu);

      /* If we didn't find a lowpc, set it to highpc to avoid
	 complaints from `maint check'.	 */
      if (lowpc == ((CORE_ADDR) -1))
	lowpc = highpc;

      /* If the compilation unit didn't have an explicit address range,
	 then use the information extracted from its child dies.  */
      if (! has_pc_info)
	{
	  best_lowpc = lowpc;
	  best_highpc = highpc;
	}
    }
  pst->textlow = best_lowpc + baseaddr;
  pst->texthigh = best_highpc + baseaddr;

  pst->n_global_syms = objfile->global_psymbols.next -
    (objfile->global_psymbols.list + pst->globals_offset);
  pst->n_static_syms = objfile->static_psymbols.next -
    (objfile->static_psymbols.list + pst->statics_offset);
  sort_pst_symbols (objfile, pst);

  if (!VEC_empty (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs))
    {
      int i;
      int len = VEC_length (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs);
      struct dwarf2_per_cu_data *iter;

      /* Fill in 'dependencies' here; we fill in 'users' in a
	 post-pass.  */
      pst->number_of_dependencies = len;
      pst->dependencies = obstack_alloc (&objfile->objfile_obstack,
					 len * sizeof (struct symtab *));
      for (i = 0;
	   VEC_iterate (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs,
			i, iter);
	   ++i)
	pst->dependencies[i] = iter->v.psymtab;

      VEC_free (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs);
    }

  /* Get the list of files included in the current compilation unit,
     and build a psymtab for each of them.  */
  dwarf2_build_include_psymtabs (cu, comp_unit_die, pst);

  if (dwarf2_read_debug)
    {
      struct gdbarch *gdbarch = get_objfile_arch (objfile);

      fprintf_unfiltered (gdb_stdlog,
			  "Psymtab for %s unit @@0x%x: %s - %s"
			  ", %d global, %d static syms\n",
			  per_cu->is_debug_types ? "type" : "comp",
			  per_cu->offset.sect_off,
			  paddress (gdbarch, pst->textlow),
			  paddress (gdbarch, pst->texthigh),
			  pst->n_global_syms, pst->n_static_syms);
    }
}

/* Subroutine of dwarf2_build_psymtabs_hard to simplify it.
   Process compilation unit THIS_CU for a psymtab.  */

static void
process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,
			   int want_partial_unit)
{
  /* If this compilation unit was already read in, free the
     cached copy in order to read it in again.	This is
     necessary because we skipped some symbols when we first
     read in the compilation unit (see load_partial_dies).
     This problem could be avoided, but the benefit is unclear.  */
  if (this_cu->cu != NULL)
    free_one_cached_comp_unit (this_cu);

  gdb_assert (! this_cu->is_debug_types);
  init_cutu_and_read_dies (this_cu, NULL, 0, 0,
			   process_psymtab_comp_unit_reader,
			   &want_partial_unit);

  /* Age out any secondary CUs.  */
  age_cached_comp_units ();
}
d5207 189
@


1.758
log
@	* ax-gdb.c (gen_var_ref): Unconditionally call via computed ops,
	if possible.
	* dwarf2read.c (read_func_scope): Remove old FIXME.
	* eval.c (evaluate_subexp_standard): Check SYMBOL_COMPUTED_OPS,
	not LOC_COMPUTED.
	* findvar.c (symbol_read_needs_frame, default_read_var_value):
	Unconditionally call via computed ops, if possible.
	* printcmd.c (address_info): Unconditionally call via computed ops,
	if possible.
	* stack.c (read_frame_arg): Unconditionally call via computed ops,
	if possible.
	* symtab.c (register_symbol_computed_impl): Sanity check 'ops'.
	* tracepoint.c (scope_info): Unconditionally call via computed ops,
	if possible.
@
text
@d1557 3
a1770 3
static const char *dwarf2_physname (const char *name, struct die_info *die,
				    struct dwarf2_cu *cu);

a6869 2
static void compute_symtab_includes (struct dwarf2_per_cu_data *per_cu);

d7280 2
@


1.757
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@a9524 9
    /* FIXME: cagney/2004-01-26: The DW_AT_frame_base's location
       expression is being recorded directly in the function's symbol
       and not in a separate frame-base object.  I guess this hack is
       to avoid adding some sort of frame-base adjunct/annex to the
       function's symbol :-(.  The problem with doing this is that it
       results in a function symbol with a location expression that
       has nothing to do with the location of the function, ouch!  The
       relationship should be: a function's symbol has-a frame base; a
       frame-base has-a location expression.  */
@


1.756
log
@gdb/
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Put continue after
	any successful compare_filenames_for_search or FILENAME_CMP.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symtab.c (iterate_over_some_symtabs): Likewise.
@
text
@d95 7
d1636 2
a1637 1
					 struct dwarf2_cu *cu);
d6861 1
a6861 1
      SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d9534 1
a9534 1
    dwarf2_symbol_mark_computed (attr, new->name, cu);
a11966 1
  SYMBOL_COMPUTED_OPS (sym) = &dwarf2_locexpr_funcs;
d11968 1
a11968 1
  SYMBOL_CLASS (sym) = LOC_COMPUTED;
d15735 1
a15735 1
      SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
d15759 1
a15759 1
      SYMBOL_CLASS (sym) = LOC_STATIC;
d15773 1
a15773 2
  dwarf2_symbol_mark_computed (attr, sym, cu);
  SYMBOL_CLASS (sym) = LOC_COMPUTED;
d15775 1
a15775 1
  if (SYMBOL_COMPUTED_OPS (sym) == &dwarf2_loclist_funcs)
d15831 1
a15831 1
      SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
d15874 1
a15874 1
	  SYMBOL_CLASS (sym) = LOC_LABEL;
d15880 1
a15880 1
	  SYMBOL_CLASS (sym) = LOC_BLOCK;
d15901 1
a15901 1
	  SYMBOL_CLASS (sym) = LOC_BLOCK;
d15976 1
a15976 1
		    SYMBOL_CLASS (sym) = LOC_UNRESOLVED;
d16014 1
a16014 1
		  SYMBOL_CLASS (sym) = LOC_UNRESOLVED;
d16061 1
a16061 1
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d16098 1
a16098 1
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d16104 1
a16104 1
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d16125 1
a16125 1
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
d16129 1
a16129 1
	  SYMBOL_CLASS (sym) = LOC_COMMON_BLOCK;
a16335 1
      SYMBOL_COMPUTED_OPS (sym) = &dwarf2_locexpr_funcs;
d16337 1
a16337 1
      SYMBOL_CLASS (sym) = LOC_COMPUTED;
d16342 1
a16342 1
      SYMBOL_CLASS (sym) = LOC_CONST_BYTES;
d16347 1
a16347 1
      SYMBOL_CLASS (sym) = LOC_CONST;
d19068 1
a19068 1
			     struct dwarf2_cu *cu)
d19091 3
a19093 1
      SYMBOL_COMPUTED_OPS (sym) = &dwarf2_loclist_funcs;
d19122 3
a19124 1
      SYMBOL_COMPUTED_OPS (sym) = &dwarf2_locexpr_funcs;
d20730 10
@


1.755
log
@gdb/
	Fix entry-values in C++ across CUs.
	* dwarf2loc.c (call_site_to_target_addr) <FIELD_LOC_KIND_PHYSNAME>: Use
	lookup_minimal_symbol.  Add a comment.
	* dwarf2read.c
	(read_call_site_scope) <is_ref_attr> <die_is_declaration>: Prefer
	DW_AT_linkage_name.

gdb/testsuite/
	Fix entry-values in C++ across CUs.
	* gdb.arch/amd64-tailcall-cxx.exp: New file.
	* gdb.arch/amd64-tailcall-cxx1.S: New file.
	* gdb.arch/amd64-tailcall-cxx1.cc: New file.
	* gdb.arch/amd64-tailcall-cxx2.S: New file.
	* gdb.arch/amd64-tailcall-cxx2.cc: New file.
@
text
@d3082 1
d3097 1
d3110 1
@


1.755.2.1
log
@	* dwarf2read.c (free_dwo_file): Add comment.
	(dwarf2_per_objfile_free): Unref dwp bfd.

	* dwarf2read.c (open_and_init_dwp_file): Remove incorrect, and
	unnecessary, cleanup.
@
text
@d9082 2
d9098 2
a9255 1
  /* Note: dbfd is NULL for virtual DWO files.  */
a19704 2
  if (data->dwp_file)
    gdb_bfd_unref (data->dwp_file->dbfd);
@


1.754
log
@	PR gdb/15102:
	* dwarf2read.c (read_subrange_type): Use result of
	'check_typedef'.
gdb/testsuite
	* gdb.dwarf2/subrange.exp: New file.
@
text
@d9815 2
a9816 1
	  const char *target_physname;
d9818 9
a9826 1
	  target_physname = dwarf2_physname (NULL, target_die, target_cu);
@


1.753
log
@gdb/
	* dwarf2read.c (file_file_name): New function with code from
	file_full_name.
	(file_full_name): Move most of the code to file_file_name.
	(macro_start_file): Rename variable full_name to file_name and use
	file_file_name for it.  Add comp_dir parameter to new_macro_table.
	* macrocmd.c (show_pp_source_pos): New variable fullname.  Replace any
	macro_source_file->filename access by macro_source_fullname call.
	* macroscope.c (_initialize_macroscope): Update the new_macro_table
	caller.
	* macrotab.c (struct macro_table): New field comp_dir.
	(macro_include): New variables link_fullname and source_fullname.
	Replace any macro_source_file->filename access by macro_source_fullname
	call.
	(macro_lookup_inclusion): Remove the partial filenames checking code.
	(check_for_redefinition): New variables source_fullname and
	found_key_fullname.  Replace any macro_source_file->filename access by
	macro_source_fullname call.
	(macro_undef): New variables source_fullname and key_fullname.  Replace
	any macro_source_file->filename access by macro_source_fullname call.
	(macro_lookup_definition): New variables retval and source_fullname.
	Replace any macro_source_file->filename access by macro_source_fullname
	call.
	(foreach_macro): New variable key_fullname.  Replace any
	macro_source_file->filename access by macro_source_fullname call.
	(foreach_macro_in_scope): New variable datum_fullname.  Replace any
	macro_source_file->filename access by macro_source_fullname call.
	(new_macro_table): Add parameter comp_dir.  Initialize T with it.
	(macro_source_fullname): New function.
	* macrotab.h (struct macro_source_file): Extent the filename field
	comment.
	(new_macro_table): New parameter comp_dir, add a comment for it.
	(macro_source_fullname): new declaration.

gdb/testsuite/
	* gdb.linespec/base/one/header.h: New file.
	* gdb.linespec/base/two/header.h: New file.
	* gdb.linespec/macro-relative.c: New file.
	* gdb.linespec/macro-relative.exp: New file.
@
text
@d12739 1
a12739 1
  struct type *base_type;
d12747 6
a12752 3
  base_type = die_type (die, cu);
  /* Preserve BASE_TYPE's original type, just set its LENGTH.  */
  check_typedef (base_type);
d12882 1
a12882 1
  range_type = create_range_type (NULL, base_type, low, high);
@


1.752
log
@gdb/
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Move variable
	this_real_name to outer block.  Use it also for
	compare_filenames_for_search.
	(dw2_expand_symtabs_matching): New variable this_real_name.  Use it
	with dw2_get_real_path for file_matcher, considering also
	BASENAMES_MAY_DIFFER.
	(file_full_name): Prepend COMP_DIR even for relative lh->INCLUDE_DIRS.
@
text
@d18037 2
a18038 3
/* Return the full name of file number I in *LH's file name table.
   Use COMP_DIR as the name of the current directory of the
   compilation.  The result is allocated using xmalloc; the caller is
d18040 1
d18042 1
a18042 1
file_full_name (int file, struct line_header *lh, const char *comp_dir)
d18050 1
a18050 1
      if (IS_ABSOLUTE_PATH (fe->name))
d18052 2
a18053 19
      else
        {
          const char *dir;

          if (fe->dir_index == 0)
            dir = comp_dir;
	  else
	    {
	      dir = lh->include_dirs[fe->dir_index - 1];
	      if (!IS_ABSOLUTE_PATH (dir))
		return concat (comp_dir, SLASH_STRING, dir, SLASH_STRING,
			       fe->name, NULL);
	    }

          if (dir)
	    return concat (dir, SLASH_STRING, fe->name, NULL);
          else
            return xstrdup (fe->name);
        }
d18073 21
d18101 2
a18102 2
  /* The full name of this source file.  */
  char *full_name = file_full_name (file, lh, comp_dir);
d18108 2
a18109 1
                                      objfile->per_bfd->macro_cache);
d18115 1
a18115 1
      current_file = macro_set_main (pending_macros, full_name);
d18119 1
a18119 1
    current_file = macro_include (current_file, line, full_name);
d18121 1
a18121 1
  xfree (full_name);
@


1.751
log
@gdb/
	* dwarf2read.c (dw2_expand_symtabs_matching): Add basenames parameter
	to the file_matcher parameter.  Pass 0 to it.
	(dwarf2_create_include_psymtab): Copy also DIRNAME.
	* psymtab.c (partial_map_symtabs_matching_filename): Drop handling of
	NULL psymtab_to_fullname result.
	(psymtab_to_fullname): Remove variable r.  Never return NULL, assemble
	an expected filename instead.
	(expand_symtabs_matching_via_partial): Add basenames parameter to the
	file_matcher parameter.  Call also psymtab_to_fullname, after newly
	considering BASENAMES_MAY_DIFFER.
	* source.c (rewrite_source_path): Remove static.
	* source.h (rewrite_source_path): New declaration.
	* symfile.h (struct quick_symbol_functions): Add basenames parameter to
	the expand_symtabs_matching field.  Comment it.
	* symtab.c (file_matches): New function comment.  Add parameter
	basenames, implement it.
	(search_symbols_file_matches): Add basenames parameter.  Update the
	file_matches caller.
	(search_symbols): Match FILES also against symtab_to_fullname.
	Optimize it for BASENAMES_MAY_DIFFER.

gdb/testsuite/
	* gdb.base/fullpath-expand-func.c: New file.
	* gdb.base/fullpath-expand.c: New file.
	* gdb.base/fullpath-expand.exp: New file.
	* gdb.base/realname-expand-real.c: New file.
	* gdb.base/realname-expand.c: New file.
	* gdb.base/realname-expand.exp: New file.
@
text
@d3075 1
d3090 8
a3099 3
	      const char *this_real_name = dw2_get_real_path (objfile,
							      file_data, j);

d3542 2
d3549 14
a18054 2
          int dir_len;
          char *full_name;
d18056 1
a18056 3
          if (fe->dir_index)
            dir = lh->include_dirs[fe->dir_index - 1];
          else
d18058 7
d18067 1
a18067 8
            {
              dir_len = strlen (dir);
              full_name = xmalloc (dir_len + 1 + strlen (fe->name) + 1);
              strcpy (full_name, dir);
              full_name[dir_len] = '/';
              strcpy (full_name + dir_len + 1, fe->name);
              return full_name;
            }
@


1.750
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d3476 1
a3476 1
   int (*file_matcher) (const char *, void *),
d3536 1
a3536 1
	      if (file_matcher (file_data->file_names[j], data))
d4057 6
@


1.749
log
@gdb/
	Code cleanup.
	* dwarf2read.c (dw2_expand_symtabs_with_filename): Rename to ...
	(dw2_expand_symtabs_with_fullname): ... here.  Rename parameter
	filename to fullname.  Rename variable this_name to this_fullname.
	Lowercase FILENAME_CMP call.
	(dw2_find_symbol_file): New comment for the returned string.
	(dwarf2_gdb_index_functions): Rename the function to
	dw2_expand_symtabs_with_fullname.
	* psymtab.c (read_psymtabs_with_filename): Rename to ...
	(read_psymtabs_with_fullname): ... here.  Rename parameter filename to
	fullname.
	(psym_functions): Rename the function to read_psymtabs_with_fullname.
	* symfile.h (struct quick_symbol_functions): Rename field
	expand_symtabs_with_filename to expand_symtabs_with_fullname and its
	parameter filename to fullname.  Document returned string meaning for
	find_symbol_file.
	* symtab.c (find_line_symtab): Rename the called function to
	expand_symtabs_with_fullname.
@
text
@d70 1
d6794 1
a6794 1
				? SYMBOL_SYMTAB (sym)->filename
@


1.748
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable is_abs, unify the
	call of filename_cmp with compare_filenames_for_search.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	is_abs, unify the call of FILENAME_CMP with
	compare_filenames_for_search.  New gdb_asserts for real_path and name.
	Unify the call of compare_filenames_for_search with FILENAME_CMP.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symfile.h (struct quick_symbol_functions): Extend the comment for
	map_symtabs_matching_filename.
	* symtab.c (compare_filenames_for_search): Remove the function comment
	relative path requirement.  Handle absolute filenames, with a comment.
	(iterate_over_some_symtabs): Remove variable is_abs, unify the call of
	FILENAME_CMP with compare_filenames_for_search.  New gdb_asserts for
	real_path and name.  Unify the call of compare_filenames_for_search
	with FILENAME_CMP.
	(iterate_over_symtabs): New gdb_assert on REAL_PATH.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: Use double last slash for $srcfileabs.
	(compare_filenames_for_search does not match)
	(compare_filenames_for_search does match): New tests.
@
text
@d3346 2
a3347 2
dw2_expand_symtabs_with_filename (struct objfile *objfile,
				  const char *filename)
d3374 3
a3376 2
	  const char *this_name = file_data->file_names[j];
	  if (FILENAME_CMP (this_name, filename) == 0)
d3427 4
a3430 1
	    return SYMBOL_SYMTAB (sym)->filename;
d3447 4
a3450 1
    return per_cu->v.quick->symtab->filename;
d3455 1
d3754 1
a3754 1
  dw2_expand_symtabs_with_filename,
@


1.747
log
@gdb/
	Replace xfullpath calls by gdb_realpath calls.
	* cli/cli-cmds.c (find_and_open_script): Remove xfullpath from the
	function comment.
	* dwarf2read.c (dw2_map_expand_apply): Remove parameter full_path.
	Remove it from the iterate_over_some_symtabs call.
	(dw2_map_symtabs_matching_filename): Remove parameter full_path.
	Remove it from the dw2_map_expand_apply calls, remove a block handling
	it.
	* psymtab.c (partial_map_expand_apply): Remove parameter full_path.
	Remove it from the iterate_over_some_symtabs call.
	(partial_map_symtabs_matching_filename): Remove parameter full_path.
	Remove it from the partial_map_expand_apply calls, remove a block
	handling it.  Drop gdb_realpath call and cleanups from the real_path
	handling.
	* source.c (openp): Drop the comment part about xfullpath.  Replace
	xfullpath calls by gdb_realpath calls.
	(find_and_open_source): Replace xfullpath call by gdb_realpath call.
	* symfile.h (struct quick_symbol_functions): Remove parameter full_path
	from method map_symtabs_matching_filename and its comment.
	* symmisc.c (maintenance_print_msymbols): Replace xfullpath call by
	gdb_realpath call.
	* symtab.c (iterate_over_some_symtabs): Remove parameter full_path,
	remove it also from the function comment, remove a block handling it.
	Drop gdb_realpath call and cleanups from the real_path handling.
	(iterate_over_symtabs): Drop variable full_path and its use.
	* symtab.h (iterate_over_some_symtabs): Remove parameter full_path.
	* utils.c (xfullpath): Remove.
	* utils.h (xfullpath): Remove.

gdb/testsuite/
	* gdb.gdb/xfullpath.exp: Replace xfullpath calls by gdb_realpath calls.
@
text
@a3050 1
  int is_abs = IS_ABSOLUTE_PATH (name);
d3075 1
a3075 2
	  if (FILENAME_CMP (name, this_name) == 0
	      || (!is_abs && compare_filenames_for_search (this_name, name)))
d3093 2
d3096 1
a3096 4
		  && (FILENAME_CMP (real_path, this_real_name) == 0
		      || (!is_abs
			  && compare_filenames_for_search (this_real_name,
							   name))))
@


1.746
log
@	PR c++/14998:
	* dwarf2read.c (read_tag_ptr_to_member_type): Handle
	TYPE_CODE_FUNC.
gdb/testsuite
	* gdb.dwarf2/method-ptr.cc: New file.
	* gdb.dwarf2/method-ptr.exp: New file.
@
text
@d3023 1
a3023 2
		      const char *name,
		      const char *full_path, const char *real_path,
d3037 1
a3037 1
  return iterate_over_some_symtabs (name, full_path, real_path, callback, data,
d3045 1
a3045 1
				   const char *full_path, const char *real_path,
d3079 1
a3079 2
	      if (dw2_map_expand_apply (objfile, per_cu,
					name, full_path, real_path,
a3089 18
	  if (full_path != NULL)
	    {
	      const char *this_real_name = dw2_get_real_path (objfile,
							      file_data, j);

	      if (this_real_name != NULL
		  && (FILENAME_CMP (full_path, this_real_name) == 0
		      || (!is_abs
			  && compare_filenames_for_search (this_real_name,
							   name))))
		{
		  if (dw2_map_expand_apply (objfile, per_cu,
					    name, full_path, real_path,
					    callback, data))
		    return 1;
		}
	    }

d3101 1
a3101 2
		  if (dw2_map_expand_apply (objfile, per_cu,
					    name, full_path, real_path,
@


1.745
log
@	* dwarf2read.c (compute_delayed_physnames, read_call_site_scope)
	(read_structure_type, read_enumeration_type): Remove cast.
@
text
@d12273 9
@


1.744
log
@	* dwarf2read.c (read_namespace_type): Remove cast.
	(read_typedef): Likewise.
@
text
@d6765 1
a6765 1
      physname = dwarf2_physname ((char *) mi->name, mi->die, cu);
d9811 1
a9811 1
	    SET_FIELD_PHYSNAME (call_site->target, (char *) target_physname);
d11257 1
a11257 1
	  TYPE_TAG_NAME (type) = (char *) name;
d11560 1
a11560 1
    TYPE_TAG_NAME (type) = (char *) name;
@


1.743
log
@	* dwarf2read.c (free_dwo_file): Remove assert.
gdb/testsuite
	* gdb.dwarf2/fission-reread.exp: Add unload test.
@
text
@d12073 1
a12073 1
  TYPE_NAME (type) = (char *) name;
d12597 1
a12597 1
  TYPE_NAME (this_type) = (char *) name;
@


1.742
log
@	* dwarf2read.c (processing_has_namespace_info): Remove.
	(struct dwarf2_cu) <processing_has_namespace_info>: New field.
	(process_die, read_func_scope, dwarf2_start_symtab)
	(new_symbol_full): Update.
@
text
@a9242 1
  gdb_assert (dwo_file->dbfd != objfile->obfd);
@


1.741
log
@	* cp-namespace.c (cp_set_block_scope): Remove.
	* cp-support.h (cp_set_block_scope): Remove.
	* dbxread.c: Include block.h.
	(cp_set_block_scope): New function.
	(process_one_symbol): Update.
	* dwarf2read.c (read_func_scope): Use block_set_scope.
@
text
@a91 6
/* When set, the file that we're processing is known to have debugging
   info for C++ namespaces.  GCC 3.3.x did not produce this information,
   but later versions do.  */

static int processing_has_namespace_info;

d505 6
d7232 1
a7232 1
      processing_has_namespace_info = 1;
d7236 1
a7236 1
      processing_has_namespace_info = 1;
d7241 1
a7241 1
      processing_has_namespace_info = 1;
d9568 1
a9568 1
      && processing_has_namespace_info)
d15668 1
a15668 1
  processing_has_namespace_info = 0;
d16113 1
a16113 1
      if (!processing_has_namespace_info
@


1.740
log
@	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Update.
	(cp_add_using_directive): Add 'copy_names' argument.
	* cp-support.h (cp_add_using_directive): Update.
	(struct using_direct) <import_src, import_dest, alias,
	declaration>: Now const.
	* dwarf2read.c (read_import_statement): Use obconcat.
	Don't copy names passed to cp_add_using_directive.
@
text
@d9567 4
a9570 4
  if (cu->language == language_cplus || cu->language == language_fortran)
    cp_set_block_scope (new->name, block, &objfile->objfile_obstack,
			determine_prefix (die, cu),
			processing_has_namespace_info);
@


1.739
log
@	Work around binutils/15021.
	* dwarf2read.c (dwarf2_per_cu_data): Split imported_symtabs and
	type_unit_group out of union s.  All uses updated.
	(read_index_from_section): Watch for index version 8.
	(follow_die_sig): If using .gdb_index version <= 7, record the TU as
	an imported symtab.
	(write_psymtabs_to_index): Increment version number to 8.

	doc/
	* gdb.texinfo (Index Section Format): Document .gdb_index version 8.
@
text
@a7715 2
  char *temp;

d7781 3
a7783 8
    {
      temp = alloca (strlen (imported_name_prefix)
                     + 2 + strlen (imported_name) + 1);
      strcpy (temp, imported_name_prefix);
      strcat (temp, "::");
      strcat (temp, imported_name);
      canonical_name = temp;
    }
d7838 1
d12105 1
a12105 1
				  NULL, NULL, &objfile->objfile_obstack);
@


1.738
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@d569 23
a591 13
  union
  {
    /* The CUs we import using DW_TAG_imported_unit.  This is filled in
       while reading psymtabs, used to compute the psymtab dependencies,
       and then cleared.  Then it is filled in again while reading full
       symbols, and only deleted when the objfile is destroyed.  */
    VEC (dwarf2_per_cu_ptr) *imported_symtabs;

    /* Type units are grouped by their DW_AT_stmt_list entry so that they
       can share them.  If this is a TU, this points to the containing
       symtab.  */
    struct type_unit_group *type_unit_group;
  } s;
d2703 5
d2710 1
a2710 1
  if (version > 7)
d2947 1
a2947 1
      struct type_unit_group *tu_group = this_cu->s.type_unit_group;
d4977 1
a4977 1
  if (!VEC_empty (dwarf2_per_cu_ptr, cu->per_cu->s.imported_symtabs))
d4980 1
a4980 1
      int len = VEC_length (dwarf2_per_cu_ptr, cu->per_cu->s.imported_symtabs);
d4989 1
a4989 1
	   VEC_iterate (dwarf2_per_cu_ptr, cu->per_cu->s.imported_symtabs,
d4994 1
a4994 1
      VEC_free (dwarf2_per_cu_ptr, cu->per_cu->s.imported_symtabs);
d5092 1
a5092 1
  per_cu->s.type_unit_group = tu_group;
d5429 1
a5429 1
      iter->s.type_unit_group = tu_group;
d5750 1
a5750 1
			       cu->per_cu->s.imported_symtabs, per_cu);
d6884 1
a6884 1
       VEC_iterate (dwarf2_per_cu_ptr, per_cu->s.imported_symtabs, ix, iter);
d6897 1
a6897 1
  if (!VEC_empty (dwarf2_per_cu_ptr, per_cu->s.imported_symtabs))
d6913 1
a6913 1
	   VEC_iterate (dwarf2_per_cu_ptr, per_cu->s.imported_symtabs,
d6918 3
a6920 2
      /* Now we have a transitive closure of all the included CUs, so
	 we can convert it to a list of symtabs.  */
d7003 1
a7003 1
				   per_cu->s.imported_symtabs != NULL);
d7099 1
a7099 1
  if (per_cu->s.type_unit_group->primary_symtab == NULL)
d7102 1
a7102 1
      per_cu->s.type_unit_group->primary_symtab = symtab;
d7117 2
a7118 2
			   per_cu->s.type_unit_group->primary_symtab);
      symtab = per_cu->s.type_unit_group->primary_symtab;
d7164 1
a7164 1
      VEC_safe_push (dwarf2_per_cu_ptr, cu->per_cu->s.imported_symtabs,
d8055 3
a8057 3
  if (per_cu->s.type_unit_group == NULL)
    per_cu->s.type_unit_group = get_type_unit_group (cu, attr);
  tu_group = per_cu->s.type_unit_group;
d17607 10
d19667 5
a19671 1
	      dwarf2_per_objfile->all_comp_units[ix]->s.imported_symtabs);
d20493 1
a20493 1
  val = MAYBE_SWAP (7);
@


1.737
log
@	* dwarf2read.c (fixup_go_packaging): Save package name
	on objfile obstack.
	* gdbtypes.c (init_type): Don't copy name.
@
text
@d6806 3
a6808 3
      const char *saved_package_name = obsavestring (package_name,
						     strlen (package_name),
						     &objfile->objfile_obstack);
d7676 1
a7676 2
    retval = obsavestring (retval, strlen (retval),
			   &objfile->objfile_obstack);
d13875 3
a13877 3
		= obsavestring (actual_class_name,
				strlen (actual_class_name),
				&cu->objfile->objfile_obstack);
d13961 2
a13962 2
	  part_die->name = obsavestring (base, strlen (base),
					 &cu->objfile->objfile_obstack);
d16632 3
a16634 3
			  obsavestring (actual_name,
					actual_name_len - die_name_len - 2,
					&cu->objfile->objfile_obstack);
d16678 2
a16679 2
  return obsavestring (DW_STRING (attr), &base[-1] - DW_STRING (attr),
		       &cu->objfile->objfile_obstack);
d16908 1
a16908 2
	    name = obsavestring (canon_name, strlen (canon_name),
				 obstack);
d17009 2
a17010 2
	      DW_STRING (attr) = obsavestring (demangled, strlen (demangled),
					       &cu->objfile->objfile_obstack);
@


1.736
log
@	* dwarf2read.c (struct partial_die_info) <name, scope>: Now
	const.
	(struct attribute) <u.str>: Now const.
	(struct fnfieldlist) <name>: Now const.
	(dw2_get_file_names_reader, init_cutu_and_read_dies): Update.
	(partial_die_parent_scope): Make return type const.
	(partial_die_full_name, add_partial_symbol): Update.
	(dwarf2_compute_name, dwarf2_full_name, dwarf2_physname): Make
	'name' const.
	(find_file_and_directory): Make 'name' and 'comp_dir' const.
	(read_file_scope, read_func_scope, dwarf2_add_field)
	(dwarf2_add_member_fn, read_structure_type)
	(process_enumeration_scope, read_array_type, read_module_type)
	(read_base_type, read_subrange_type): Update.
	(dwarf2_start_symtab): Make 'name' and 'comp_dir' const.
	(new_symbol_full, guess_full_die_structure_name): Update.
	(dwarf2_canonicalize_name): Return const type.  Make 'name' const.
	(dwarf2_name): Return const type.
	(dwarf_decode_macro_bytes, dwarf_decode_macros): Make 'comp_dir'
	const.
@
text
@d6806 3
d6810 1
a6810 1
				     package_name, objfile);
d6817 2
a6818 1
      SYMBOL_SET_NAMES (sym, package_name, strlen (package_name), 1, objfile);
@


1.735
log
@	* dwarf2read.c (new_symbol_full): Remove cast.
	* symtab.c (symbol_set_demangled_name): Make 'name' const.
	* symtab.h (symbol_set_demangled_name): Update.
@
text
@d934 1
a934 1
    char *name;
d942 1
a942 1
    char *scope;
d1025 1
a1025 1
	char *str;
d1139 1
a1139 1
	char *name;
d1406 1
a1406 1
				 char *, char *, CORE_ADDR);
d1530 2
a1531 2
static char *dwarf2_canonicalize_name (char *, struct dwarf2_cu *,
				       struct obstack *);
d1533 1
a1533 1
static char *dwarf2_name (struct die_info *die, struct dwarf2_cu *);
d1535 1
a1535 1
static const char *dwarf2_full_name (char *name,
d1604 1
a1604 1
				 char *, int);
d1689 1
a1689 1
				     char **name, char **comp_dir);
d1749 1
a1749 1
static const char *dwarf2_physname (char *name, struct die_info *die,
d2833 1
a2833 1
  char *name, *comp_dir;
d4555 1
a4555 1
      char *dwo_name = DW_STRING (attr);
d5773 1
a5773 1
static char *
d5777 1
a5777 1
  char *grandparent_scope;
d5852 1
a5852 1
  char *parent_scope;
d5890 1
a5890 1
  char *actual_name = NULL;
d5892 1
a5892 1
  int built_actual_name = 0;
d5896 3
a5898 3
  actual_name = partial_die_full_name (pdi, cu);
  if (actual_name)
    built_actual_name = 1;
d5915 1
a5915 1
			       built_actual_name,
d5926 1
a5926 1
			       built_actual_name,
d5942 1
a5942 1
			     built_actual_name, VAR_DOMAIN, LOC_STATIC,
d5976 1
a5976 1
				 built_actual_name,
d5987 1
a5987 2
	      if (built_actual_name)
		xfree (actual_name);
d5993 1
a5993 1
			       built_actual_name,
d6004 1
a6004 1
			   built_actual_name,
d6011 1
a6011 1
			   built_actual_name,
d6028 1
a6028 2
	  if (built_actual_name)
	    xfree (actual_name);
d6035 1
a6035 1
			   built_actual_name,
d6046 1
a6046 1
			   built_actual_name,
d6058 1
a6058 2
  if (built_actual_name)
    xfree (actual_name);
d7323 2
a7324 1
dwarf2_compute_name (char *name, struct die_info *die, struct dwarf2_cu *cu,
d7543 1
a7543 1
	      char *cname
d7565 1
a7565 1
dwarf2_full_name (char *name, struct die_info *die, struct dwarf2_cu *cu)
d7578 1
a7578 1
dwarf2_physname (char *name, struct die_info *die, struct dwarf2_cu *cu)
d7857 1
a7857 1
			 char **name, char **comp_dir)
d7878 5
a7882 3
      *comp_dir = ldirname (*name);
      if (*comp_dir != NULL)
	make_cleanup (xfree, *comp_dir);
d7937 2
a7938 2
  char *name = NULL;
  char *comp_dir = NULL;
d9417 1
a9417 1
  char *name;
d10528 1
a10528 1
  char *fieldname = "";
d10878 1
a10878 1
  char *fieldname;
d11198 1
a11198 1
  char *name;
d11229 1
a11229 1
	  char *full_name = (char *) dwarf2_full_name (name, die, cu);
d11593 1
a11593 1
      char *name;
d11695 1
a11695 1
  char *name;
d12116 1
a12116 1
  char *module_name;
d12613 1
a12613 1
  char *name;
d12710 1
a12710 1
  char *name;
d15646 1
a15646 1
		     char *name, char *comp_dir, CORE_ADDR low_pc)
d15738 1
a15738 1
  char *name;
d16614 1
a16614 1
		  char *die_name = dwarf2_name (die, cu);
d16894 2
a16895 2
static char *
dwarf2_canonicalize_name (char *name, struct dwarf2_cu *cu,
d16916 1
a16916 1
static char *
d18445 1
a18445 1
			  struct line_header *lh, char *comp_dir,
d18718 1
a18718 1
                     char *comp_dir, int section_is_gnu)
@


1.734
log
@gdb/
	Fix gdb.fortran/common-block.exp crash in PIE mode.
	* dwarf2read.c (new_symbol_full) <DW_TAG_common_block>: Use
	LOC_COMMON_BLOCK.
	* f-valprint.c (info_common_command_for_block): Expect
	LOC_COMMON_BLOCK in gdb_assert.
	* symtab.h (struct general_symbol_info): Update comment for the
	common_block member.
	(domain_enum): Extend comment for the COMMON_BLOCK_DOMAIN member.
	(enum address_class): New member LOC_COMMON_BLOCK.
@
text
@d15770 1
a15770 1
				   (char *) dwarf2_full_name (name, die, cu),
@


1.733
log
@gdb/
	* dbxread.c (dbx_psymtab_to_symtab): Delete the declaration.
	(dbx_read_symtab): New declaration.
	(dbx_psymtab_to_symtab): Delete.
	(dbx_read_symtab): Rename from dbx_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(start_psymtab): Caller update.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Delete the declaration.
	(dwarf2_read_symtab): New declaration.
	(dwarf2_psymtab_to_symtab): Delete.
	(dwarf2_read_symtab): Rename from dwarf2_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(create_partial_symtab): Caller update.
	* mdebugread.c (mdebug_psymtab_to_symtab): Delete.
	(mdebug_read_symtab): Rename from mdebug_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(parse_partial_symbols, new_psymtab): Caller update.
	* psympriv.h (struct partial_symtab) <read_symtab>: Exchange
	two parameters.
	* psymtab.c (psymtab_to_symtab): Caller update.
	* xcoffread.c (xcoff_psymtab_to_symtab): Delete.
	(xcoff_read_symtab): Rename from xcoff_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(xcoff_start_psymtab): Caller update.
@
text
@d16074 1
a16074 1
	  SYMBOL_CLASS (sym) = LOC_STATIC;
@


1.732
log
@	* dwarf2read.c (dw2_build_type_unit_groups_reader): Delete.
	(dw2_build_type_unit_groups): Delete.  All uses updated.
@
text
@d1287 2
a1288 2
static void dwarf2_psymtab_to_symtab (struct objfile *,
				      struct partial_symtab *);
d4858 1
a4858 1
  pst->read_symtab = dwarf2_psymtab_to_symtab;
d6386 1
a6386 1
/* Expand this partial symbol table into a full symbol table.  PST is
d6390 2
a6391 1
dwarf2_psymtab_to_symtab (struct objfile *objfile, struct partial_symtab *pst)
d6393 1
a6393 1
  if (pst->readin)
d6396 1
a6396 1
	       pst->filename);
d6403 1
a6403 1
			   pst->filename);
d6426 1
a6426 1
      psymtab_to_symtab_1 (pst);
@


1.731
log
@gdb/
	* dwarf2read.c (psymtab_include_file_name): Extend the function comment.
@
text
@a2816 34
/* Reader function for dw2_build_type_unit_groups.  */

static void
dw2_build_type_unit_groups_reader (const struct die_reader_specs *reader,
				   gdb_byte *info_ptr,
				   struct die_info *type_unit_die,
				   int has_children,
				   void *data)
{
  struct dwarf2_cu *cu = reader->cu;
  struct attribute *attr;
  struct type_unit_group *tu_group;

  gdb_assert (data == NULL);

  if (! has_children)
    return;

  attr = dwarf2_attr_no_follow (type_unit_die, DW_AT_stmt_list);
  /* Call this for its side-effect of creating the associated
     struct type_unit_group if it doesn't already exist.  */
  tu_group = get_type_unit_group (cu, attr);
}

/* Build dwarf2_per_objfile->type_unit_groups.
   This function may be called multiple times.  */

static void
dw2_build_type_unit_groups (void)
{
  if (dwarf2_per_objfile->type_unit_groups == NULL)
    build_type_unit_groups (dw2_build_type_unit_groups_reader, NULL);
}

d3041 2
a3042 1
  dw2_build_type_unit_groups ();
d3044 1
a3044 2
  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_unit_groups); ++i)
a3496 2
      dw2_build_type_unit_groups ();

d3506 4
a3509 2
      for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		       + dwarf2_per_objfile->n_type_unit_groups); ++i)
d3682 3
a3684 1
  dw2_build_type_unit_groups ();
d3686 1
a3686 3
  /* We can ignore file names coming from already-expanded CUs.  */
  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_units); ++i)
d3699 1
a3699 2
  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_unit_groups); ++i)
@


1.730
log
@	PR symtab/14442:
	* c-typeprint.c (cp_type_print_method_args): Handle 'restrict'.
	(c_type_print_modifier): Likewise.
	* dwarf2read.c (read_tag_restrict_type): New function.
	(read_type_die_1): Handle DW_TAG_restrict_type.
	* gdbtypes.c (make_restrict_type): New function.
	(recursive_dump_type): Handle TYPE_RESTRICT.
	* gdbtypes.h (enum type_flag_values): Renumber.
	(enum type_instance_flag_value): Add
	TYPE_INSTANCE_FLAG_RESTRICT.
	(TYPE_RESTRICT): New macro.
	(make_restrict_type): Declare.
gdb/testsuite
	* gdb.dwarf2/dw2-restrict.S: New file.
	* gdb.dwarf2/dw2-restrict.c: New file.
	* gdb.dwarf2/dw2-restrict.exp: New file.
@
text
@d15164 3
a15166 1
   Returns NULL if FILE_INDEX should be ignored, i.e., it is pst->filename.  */
@


1.729
log
@	PR symtab/14931:
	* psymtab.c (struct psymtab_state): New.
	(discard_psymtabs_upto, make_cleanup_discard_psymtabs): New
	functions.
	* psympriv.h (make_cleanup_discard_psymtabs): Declare.
	* dwarf2read.c (dwarf2_build_psymtabs): Catch exceptions.
gdb/testsuite
	* gdb.dwarf2/dw2-error.exp: New file.
	* gdb.dwarf2/dw2-error.c: New file.
	* gdb.dwarf2/dw2-error.S: New file.
@
text
@d12386 18
d16569 3
@


1.728
log
@gdb/
2013-01-14  Yao Qi  <yao@@codesourcery.com>

	* dbxread.c (dbx_psymtab_to_symtab_1): Don't check PST is NULL.
	(dbx_psymtab_to_symtab): Likewise.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Likewise.
	* mdebugread.c (mdebug_psymtab_to_symtab): Likewise.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Likewise.
@
text
@d3846 2
d3853 12
a3864 1
  dwarf2_build_psymtabs_hard (objfile);
@


1.727
log
@	* symfile.h (quick_symbol_functions): Delete member
	pre_expand_symtabs_matching.  All uses removed.
	* dwarf2read.c (dw2_lookup_symbol): Implement.
	(dw2_do_expand_symtabs_matching): Delete.
	(dw2_pre_expand_symtabs_matching): Delete.
	(struct dw2_symtab_iterator): New type.
	(dw2_symtab_iter_init, dw2_symtab_iter_next): New functions.
	(dw2_expand_symtabs_for_function): Rewrite.
	(dwarf2_gdb_index_functions): Update.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): Delete.
	(psym_functions): Update.
@
text
@d6408 2
a6409 1
/* Expand this partial symbol table into a full symbol table.  */
d6414 6
a6419 1
  if (pst != NULL)
d6421 1
a6421 1
      if (pst->readin)
d6423 3
a6425 2
	  warning (_("bug: psymtab for %s is already read in."),
		   pst->filename);
a6426 8
      else
	{
	  if (info_verbose)
	    {
	      printf_filtered (_("Reading in symbols for %s..."),
			       pst->filename);
	      gdb_flush (gdb_stdout);
	    }
d6428 2
a6429 2
	  /* Restore our global data.  */
	  dwarf2_per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);
d6431 9
a6439 9
	  /* If this psymtab is constructed from a debug-only objfile, the
	     has_section_at_zero flag will not necessarily be correct.  We
	     can get the correct value for this flag by looking at the data
	     associated with the (presumably stripped) associated objfile.  */
	  if (objfile->separate_debug_objfile_backlink)
	    {
	      struct dwarf2_per_objfile *dpo_backlink
	        = objfile_data (objfile->separate_debug_objfile_backlink,
		                dwarf2_objfile_data_key);
d6441 3
a6443 3
	      dwarf2_per_objfile->has_section_at_zero
		= dpo_backlink->has_section_at_zero;
	    }
d6445 1
a6445 1
	  dwarf2_per_objfile->reading_partial_symbols = 0;
d6447 1
a6447 1
	  psymtab_to_symtab_1 (pst);
d6449 3
a6451 4
	  /* Finish up the debug error message.  */
	  if (info_verbose)
	    printf_filtered (_("done.\n"));
	}
@


1.726
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d3152 53
a3204 3
static struct symtab *
dw2_lookup_symbol (struct objfile *objfile, int block_index,
		   const char *name, domain_enum domain)
d3206 57
a3262 2
  /* We do all the work in the pre_expand_symtabs_matching hook
     instead.  */
d3266 3
a3268 9
/* A helper function that expands all symtabs that hold an object
   named NAME.  If WANT_SPECIFIC_BLOCK is non-zero, only look for
   symbols in block BLOCK_KIND.  */

static void
dw2_do_expand_symtabs_matching (struct objfile *objfile,
				int want_specific_block,
				enum block_enum block_kind,
				const char *name, domain_enum domain)
d3270 1
d3277 1
a3277 1
  /* index_table is NULL if OBJF_READNOW.  */
d3280 4
a3283 1
      offset_type *vec;
d3285 1
a3285 1
      if (find_slot_in_mapped_hash (index, name, &vec))
d3287 7
a3293 2
	  offset_type i, len = MAYBE_SWAP (*vec);
	  for (i = 0; i < len; ++i)
d3295 5
a3299 20
	      offset_type cu_index_and_attrs = MAYBE_SWAP (vec[i + 1]);
	      offset_type cu_index = GDB_INDEX_CU_VALUE (cu_index_and_attrs);
	      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (cu_index);
	      int want_static = block_kind != GLOBAL_BLOCK;
	      /* This value is only valid for index versions >= 7.  */
	      int is_static = GDB_INDEX_SYMBOL_STATIC_VALUE (cu_index_and_attrs);
	      gdb_index_symbol_kind symbol_kind =
		GDB_INDEX_SYMBOL_KIND_VALUE (cu_index_and_attrs);
	      /* Only check the symbol attributes if they're present.
		 Indices prior to version 7 don't record them,
		 and indices >= 7 may elide them for certain symbols
		 (gold does this).  */
	      int attrs_valid =
		(index->version >= 7
		 && symbol_kind != GDB_INDEX_SYMBOL_KIND_NONE);

	      if (attrs_valid
		  && want_specific_block
		  && want_static != is_static)
		continue;
d3301 4
a3304 24
	      /* Only check the symbol's kind if it has one.  */
	      if (attrs_valid)
		{
		  switch (domain)
		    {
		    case VAR_DOMAIN:
		      if (symbol_kind != GDB_INDEX_SYMBOL_KIND_VARIABLE
			  && symbol_kind != GDB_INDEX_SYMBOL_KIND_FUNCTION
			  /* Some types are also in VAR_DOMAIN.  */
			  && symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
			continue;
		      break;
		    case STRUCT_DOMAIN:
		      if (symbol_kind != GDB_INDEX_SYMBOL_KIND_TYPE)
			continue;
		      break;
		    case LABEL_DOMAIN:
		      if (symbol_kind != GDB_INDEX_SYMBOL_KIND_OTHER)
			continue;
		      break;
		    default:
		      break;
		    }
		}
d3306 1
a3306 1
	      dw2_instantiate_symtab (per_cu);
d3308 2
a3311 1
}
d3313 1
a3313 6
static void
dw2_pre_expand_symtabs_matching (struct objfile *objfile,
				 enum block_enum block_kind, const char *name,
				 domain_enum domain)
{
  dw2_do_expand_symtabs_matching (objfile, 1, block_kind, name, domain);
d3351 19
a3369 3
  /* Note: It doesn't matter what we pass for block_kind here.  */
  dw2_do_expand_symtabs_matching (objfile, 0, GLOBAL_BLOCK, func_name,
				  VAR_DOMAIN);
a3784 1
  dw2_pre_expand_symtabs_matching,
@


1.725
log
@gdb/
	Code cleanup.
	* dwarf2read.c (fixup_go_packaging): Do not check symtab->FILENAME for
	NULL.
	* linespec.c (add_sal_to_sals): Likewise.
	* psympriv.h (allocate_psymtab): Add ATTRIBUTE_NONNULL.
	* stack.c (print_frame): Do not check symtab->FILENAME for NULL.
	* symfile.h (allocate_symtab): Add ATTRIBUTE_NONNULL.
	* symtab.h (struct symtab): Add comment it is never NULL for filename.
	* tracepoint.c (set_traceframe_context): Do not check symtab->FILENAME
	for NULL.
	* tui/tui-source.c (tui_set_source_content): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 1994-2012 Free Software Foundation, Inc.
@


1.724
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable sal_name_len and its
	initialization, remove it from the compare_filenames_for_search call.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	name_len and its initialization, remove it from the
	compare_filenames_for_search calls.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symtab.c (compare_filenames_for_search): Remove the search_len
	parameter, update the function comment, new variable search_len
	initialized from SEARCH_NAME.
	(iterate_over_some_symtabs): Remove variable name_len and its
	initialization, remove it from the compare_filenames_for_search calls.
	* symtab.h (compare_filenames_for_search): Remove the search_len
	parameter,
@
text
@a6735 1
				&& SYMBOL_SYMTAB (sym)->filename
@


1.723
log
@	Partial fix for PR c++/14160:
	* c-typeprint.c (c_type_print_base): Use TYPE_FN_FIELD_CONSTRUCTOR.
	* dwarf2read.c (dwarf2_is_constructor): New function.
	(dwarf2_add_member_fn): Use it.
	* gnu-v3-abi.c (gnuv3_pass_by_reference): Use
	TYPE_FN_FIELD_CONSTRUCTOR.
	* jv-typeprint.c (java_type_print_base): Use
	TYPE_FN_FIELD_CONSTRUCTOR.
	* gdbtypes.h (struct fn_field) <is_constructor>: New field.
	<dummy>: Shrink.
	(TYPE_FN_FIELD_CONSTRUCTOR): New macro.
testsuite
	* gdb.cp/templates.exp (test_ptype_of_templates): Update kfails.
@
text
@a3070 1
  int name_len = strlen (name);
d3097 1
a3097 2
	      || (!is_abs && compare_filenames_for_search (this_name,
							   name, name_len)))
d3120 1
a3120 1
							   name, name_len))))
d3138 1
a3138 1
							   name, name_len))))
@


1.722
log
@	* dbxread.c (read_dbx_symtab): Update.
	(end_psymtab, dbx_psymtab_to_symtab_1, dbx_psymtab_to_symtab)
	(read_ofile_symtab): Add 'objfile' argument.
	* dwarf2read.c (process_psymtab_comp_unit_reader)
	(build_type_psymtabs_reader): Update.
	(dwarf2_psymtab_to_symtab): Add 'objfile' argument.
	* mdebugread.c (mdebug_psymtab_to_symtab): Add 'objfile'
	argument.
	(parse_procedure, parse_partial_symbols): Update.
	(psymtab_to_symtab_1): Add 'objfile' argument.
	* psympriv.h (struct partial_symtab) <objfile>: Remove.
	<read_symtab>: Add 'objfile' argument.
	(sort_pst_symbols, discard_psymtab): Update.
	* psymtab.c (partial_map_expand_apply): Update.
	(find_pc_sect_psymtab_closer): Add 'objfile' argument.
	(find_pc_sect_psymtab, find_pc_sect_symtab_from_partial): Update.
	(find_pc_sect_psymbol): Add 'objfile' argument.
	(lookup_symbol_aux_psymtabs): Update.
	(match_partial_symbol, lookup_partial_symbol, psymtab_to_symtab):
	Add 'objfile' argument.
	(find_last_source_symtab_from_partial, dump_psymtab)
	(dump_psymtabs_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial): Update.
	(sort_pst_symbols): Add 'objfile' argument.
	(allocate_psymtab): Update.
	(discard_psymtab): Add 'objfile' argument.
	(maintenance_info_psymtabs, maintenance_check_symtabs): Update.
	* stabsread.h (end_psymtab): Update.
	* xcoffread.c (this_symtab_objfile): New global.
	(process_linenos, enter_line_range, xcoff_next_symbol_text):
	Update.
	(read_xcoff_symtab): Add 'objfile' argument.
	(read_symbol, read_symbol_lineno): Update.
	(xcoff_psymtab_to_symtab_1, xcoff_psymtab_to_symtab)
	(xcoff_end_psymtab): Add 'objfile' argument.
	(scan_xcoff_symtab): Update.
@
text
@d10781 28
d10940 2
@


1.721
log
@	* dwarf2read.c (dwarf2_get_dwz_file): Set 'dwz_file'.
@
text
@d1287 2
a1288 1
static void dwarf2_psymtab_to_symtab (struct partial_symtab *);
d4900 1
a4900 1
  sort_pst_symbols (pst);
d5328 1
a5328 1
  sort_pst_symbols (pst);
d6329 1
a6329 1
dwarf2_psymtab_to_symtab (struct partial_symtab *pst)
d6348 1
a6348 2
	  dwarf2_per_objfile = objfile_data (pst->objfile,
					     dwarf2_objfile_data_key);
d6354 1
a6354 1
	  if (pst->objfile->separate_debug_objfile_backlink)
d6357 1
a6357 1
	        = objfile_data (pst->objfile->separate_debug_objfile_backlink,
@


1.720
log
@	* dwarf2read.c (dwarf2_cu): Enhance comment.
	(dwarf2_get_pc_bounds): Only add ranges_base for DIEs that live in
	the DWO file.
	(dwarf2_record_block_ranges): Ditto.
@
text
@d2115 1
@


1.719
log
@	* dwarf2read.c (create_dwo_in_dwp): Tweak comment.
@
text
@d486 6
a491 1
     be used without needing to know whether DWO files are in use or not.  */
d10064 8
a10071 1
	  unsigned int ranges_offset = DW_UNSND (attr) + cu->ranges_base;
d10232 4
d10239 2
a10240 1
      unsigned long offset = DW_UNSND (attr) + cu->ranges_base;
@


1.718
log
@	* dwarf2read.c (dwarf2_fetch_die_loc_sect_off): New function.
	(dwarf2_fetch_die_loc_cu_off): Rename from
	dwarf2_fetch_die_location_block.  Rewrite to use
	dwarf2_fetch_die_loc_sect_off.
	* dwarf2loc.h (dwarf2_fetch_die_loc_sect_off): Declare.
	(dwarf2_fetch_die_loc_cu_off): Rename.
	* dwarf2loc.c (indirect_pieced_value): Use
	dwarf2_fetch_die_loc_sect_off.
	* dwarf2expr.h (struct dwarf_expr_context) <len, data>: Update
	comment.
	(struct dwarf_expr_piece) <v.ptr.die>: Now a sect_offset.
	* dwarf2expr.c (add_piece): Update.
	(execute_stack_op) <DW_OP_GNU_implicit_pointer>: Update comment.
testsuite
	* gdb.dwarf2/implptr-64bit.exp: Run tests with two CUs as well.
	(test): Add "two_cu" argument.
	* gdb.dwarf2/implptr-64bit.S: Move subprogram later; use ref_addr
	for types; allow two CUs.
@
text
@d8597 2
a8598 2
     However, for each CU + set of TUs that came from the same original
     DWO file, we want combine them back into a virtual DWO file to save space
@


1.717
log
@gdb/
	* configure.ac (CC_HAS_LONG_LONG): Replace by AC_MSG_ERROR.
	* defs.h (LONGEST, ULONGEST): Remove conditionalization for
	CC_HAS_LONG_LONG.
	* dwarf2-frame.c (DW64_CIE_ID): Likewise.
	* dwarf2read.c (extract_cu_value): Remove the function.
	(create_cus_from_index_list): Make the return type void, inline the
	extract_cu_value caller, include new gdb_static_assert.
	(create_cus_from_index): Make the return type void, update the function
	comment, update the create_cus_from_index_list caller.
	(create_signatured_type_table_from_index): Make the return type void,
	inline the extract_cu_value caller, include new gdb_static_assert.
	(dwarf2_read_index): Update the create_cus_from_index and
	create_signatured_type_table_from_index caller.
	* printcmd.c (ui_printf): Remove conditionalizations for
	CC_HAS_LONG_LONG.
	* config.in: Regenerate.
	* configure: Regenerate.

gdb/doc/
	* gdbint.texinfo (Host Definition): Remove CC_HAS_LONG_LONG.
@
text
@d17337 4
a17340 4
dwarf2_fetch_die_location_block (cu_offset offset_in_cu,
				 struct dwarf2_per_cu_data *per_cu,
				 CORE_ADDR (*get_frame_pc) (void *baton),
				 void *baton)
a17341 1
  sect_offset offset = { per_cu->offset.sect_off + offset_in_cu.cu_off };
d17396 14
@


1.716
log
@gdb/
	* dwarf2read.c (struct dwarf2_cu): New field producer_is_gcc_lt_4_3.
	Update the comment for checked_producer.
	(check_producer): New forward declaration.
	(producer_is_gcc_lt_4_3): New function.
	(find_file_and_directory): Simulate *COMP_DIR only for gcc < 4.3.
	(check_producer): Initialize also PRODUCER_IS_GCC_LT_4_3.

gdb/testsuite/
	* gdb.dwarf2/dw2-compdir-oldgcc.S: New file.
	* gdb.dwarf2/dw2-compdir-oldgcc.exp: New file.
@
text
@a2358 23
/* A helper function that knows how to read a 64-bit value in a way
   that doesn't make gdb die.  Returns 1 if the conversion went ok, 0
   otherwise.  */

static int
extract_cu_value (const char *bytes, ULONGEST *result)
{
  if (sizeof (ULONGEST) < 8)
    {
      int i;

      /* Ignore the upper 4 bytes if they are all zero.  */
      for (i = 0; i < 4; ++i)
	if (bytes[i + 4] != 0)
	  return 0;

      *result = extract_unsigned_integer (bytes, 4, BFD_ENDIAN_LITTLE);
    }
  else
    *result = extract_unsigned_integer (bytes, 8, BFD_ENDIAN_LITTLE);
  return 1;
}

d2362 1
a2362 1
static int
d2376 3
a2378 3
      if (!extract_cu_value (cu_list, &offset)
	  || !extract_cu_value (cu_list + 8, &length))
	return 0;
a2391 2

  return 1;
d2395 1
a2395 2
   the CU objects for this objfile.  Return 0 if something went wrong,
   1 if everything went ok.  */
d2397 1
a2397 1
static int
d2410 2
a2411 3
  if (!create_cus_from_index_list (objfile, cu_list, cu_list_elements,
				   &dwarf2_per_objfile->info, 0, 0))
    return 0;
d2414 1
a2414 1
    return 1;
d2417 2
a2418 2
  return create_cus_from_index_list (objfile, dwz_list, dwz_elements,
				     &dwz->info, 1, cu_list_elements / 2);
d2423 1
a2423 1
static int
d2446 4
a2449 3
      if (!extract_cu_value (bytes, &offset)
	  || !extract_cu_value (bytes + 8, &type_offset_in_tu))
	return 0;
a2471 2

  return 1;
d2768 2
a2769 3
  if (!create_cus_from_index (objfile, cu_list, cu_list_elements,
			      dwz_list, dwz_list_elements))
    return 0;
d2783 2
a2784 4
      if (!create_signatured_type_table_from_index (objfile, section,
						    types_list,
						    types_list_elements))
	return 0;
@


1.715
log
@	* dwarf2read.c (struct dwarf2_per_objfile): Clarify comment.
	(dw2_find_symbol_file): Delete unused local file_data.
@
text
@d498 4
a501 4
  /* These cache the results for producer_is_gxx_lt_4_6 and producer_is_icc.
     CHECKED_PRODUCER is set if both PRODUCER_IS_GXX_LT_4_6 and PRODUCER_IS_ICC
     are valid.  This information is cached because profiling CU expansion
     showed excessive time spent in producer_is_gxx_lt_4_6.  */
d504 1
d1717 2
d7811 13
d7844 2
a7845 1
  else if (*name != NULL && IS_ABSOLUTE_PATH (*name))
d10379 4
a10382 1
	cu->producer_is_gxx_lt_4_6 = major < 4 || (major == 4 && minor < 6);
@


1.714
log
@	* ada-lang.c (user_select_syms): Use SYMBOL_SYMTAB.
	* dwarf2read.c (dw2_find_symbol_file, fixup_go_packaging): Use
	SYMBOL_SYMTAB.
	* skip.c (skip_info): Use SYMBOL_SYMTAB.
@
text
@d260 6
a265 3
     TUs can share line table entries with CUs or other TUs, and there can be
     a lot more TUs than unique line tables, so we maintain a separate table
     of all line table entries to support the sharing.  */
a3390 1
  struct quick_file_names *file_data;
@


1.713
log
@	ARI fixes: sprintf rule.
	Replace sprintf function calls for char arrays by
	calls to xsnprintf calls.
	* arm-tdep.c (arm_push_dummy_call): Replace sprintf by xsnprintf.
	(arm_dwarf_reg_to_regnum, arm_return_value): Ditto.
	(arm_neon_quad_read, arm_pseudo_read): Ditto.
	(arm_neon_quad_write, arm_pseudo_write): Ditto.
	* breakpoint.c (condition_completer): Ditto.
	(create_tracepoint_from_upload): Ditto.
	* dwarf2read.c (file_full_name): Ditto.
	* gcore.c (gcore_command): Ditto.
	* gnu-nat.c (proc_string, gnu_pid_to_str): Ditto.
	* go32-nat.c (go32_sysinfo): Ditto.
	* interps.c (interp_set): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	* ppc-linux-nat.c (fetch_register, store_register): Ditto.
	* remote-m32r-sdi.c (m32r_open): Ditto.
	* sol-thread.c (td_err_string): Ditto.
	(td_state_string, solaris_pid_to_str): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	* cli/cli-script.c (execute_control_command): Ditto.
	(define_command, document_command): Ditto.
	* tui/tui-io.c (tui_rl_display_match_list): Ditto.
	* tui/tui-stack.c (tui_make_status_line): Ditto.
	* tui/tui-win.c (tui_update_gdb_sizes): Ditto.
@
text
@d3405 1
a3405 1
	    return sym->symtab->filename;
d6757 3
a6759 2
			       (sym->symtab && sym->symtab->filename
				? sym->symtab->filename
@


1.712
log
@	ARI xasprintf rule fixes.
	* dwarf2read.c (create_dwo_in_dwp): Use xstrprintf function
	instead of xasprintf.
	(open_and_init_dwp_file): Ditto.
@
text
@d17906 2
a17907 1
      sprintf (fake_name, "<bad macro file number %d>", file);
@


1.711
log
@	* ada-lang.c (user_select_syms, ada_print_subexp): Pass flags
	to type-printing functions.
	* ada-lang.h (ada_print_type): Add argument.
	* ada-typeprint.c (print_array_type, print_variant_clauses,
	print_variant_part, print_selected_record_field_types,
	print_record_field_types, print_unchecked_union_type,
	print_func_type, ada_print_type): Add flags argument.
	(ada_print_typedef): Update.
	* c-exp.y (OPERATOR conversion_type_id): Update.
	* c-lang.h (c_print_type, c_type_print_base): Update.
	* c-typeprint.c (c_print_type, c_type_print_varspec_prefix,
	c_type_print_modifier, c_type_print_args,
	c_type_print_varspec_suffix, c_type_print_base): Add flags
	argument.
	* cp-valprint.c (cp_print_class_member): Update.
	* dwarf2read.c (dwarf2_compute_name): Update.
	* f-lang.h (f_print_type): Add argument.
	* f-typeprint.c (f_print_type): Add flags argument.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update.
	* go-lang.h (go_print_type): Add argument.
	* go-typeprint.c (go_print_type): Add flags argument.
	* jv-lang.h (java_print_type): Add argument.
	* jv-typeprint.c (java_type_print_base, java_print_type): Add
	flags argument.
	* language.c (unk_lang_print_type): Add flags argument.
	* language.h (struct language_defn) <la_print_type>: Add flags
	argument.
	(LA_PRINT_TYPE): Likewise.
	* m2-lang.h (m2_print_type): Add argument.
	* m2-typeprint.c (m2_print_type, m2_range, m2_typedef,
	m2_array, m2_pointer, m2_ref, m2_procedure, m2_long_set,
	m2_unbounded_array, m2_record_fields): Add flags argument.
	* p-lang.h (pascal_print_type, pascal_type_print_base,
	pascal_type_print_varspec_prefix): Add argument.
	* p-typeprint.c (pascal_print_type,
	pascal_type_print_varspec_prefix, pascal_print_func_args,
	pascal_type_print_varspec_suffix, pascal_type_print_base): Add
	flags argument.
	* symmisc.c (print_symbol): Update.
	* typeprint.c (type_print_raw_options, default_ptype_flags):
	New globals.
	(type_print): Update.
	* typeprint.h (struct type_print_options): New.
	(type_print_raw_options): Declare.
	(c_type_print_varspec_suffix, c_type_print_args): Add argument.
@
text
@d8613 8
a8620 7
  xasprintf (&virtual_dwo_name, "virtual-dwo/%d-%d-%d-%d",
	     sections.abbrev.asection ? sections.abbrev.asection->id : 0,
	     sections.line.asection ? sections.line.asection->id : 0,
	     sections.loc.asection ? sections.loc.asection->id : 0,
	     (sections.str_offsets.asection
	      ? sections.str_offsets.asection->id
	      : 0));
d8986 1
a8986 1
  xasprintf (&dwp_name, "%s.dwp", dwarf2_per_objfile->objfile->name);
@


1.710
log
@	Add support for DWP files.  http://gcc.gnu.org/wiki/DebugFissionDWP
	* contrib/cc-with-tweaks.sh: Add -p parameter to invoke dwp.
	* dwarf2read.c: #include "elf-bfd.h".
	(struct dwarf2_per_objfile): New members dwp_checked, dwp_file.
	(dwop_section_names): Renamed from dwo_section names.  All uses
	updated.  Add entries for .debug_cu_index, .debug_tu_index.
	(struct dwo_file): Rename dwo_name to name, dwo_bfd to dbfd.
	All uses updated.
	(struct dwp_sections): New type.
	(struct virtual_dwo_sections): New type.
	(struct dwp_hash_table): New type.
	(struct dwp_file): New type.
	(init_cutu_and_read_dies): Ensure DWO info/types section has been
	read in.  Handle DWOs coming from DWP files.
	(lookup_dwo_file_slot): New function.
	(dwarf2_locate_dwo_sections): Move definition closer to use.
	(create_dwo_debug_info_hash_table_reader): Renamed from
	create_debug_info_hash_table_reader.  All callers updated.
	(create_dwo_debug_info_hash_table): Renamed from
	create_debug_info_hash_table.  All callers updated.
	(create_dwp_hash_table): New function.
	(locate_virtual_dwo_sections, create_dwo_in_dwp): New functions.
	(lookup_dwo_in_dwp): New function.
	(try_open_dwop_file): Renamed from try_open_dwo_file.  New parameter
	is_dwp.  All callers updated.
	(open_dwop_file): Renamed from open_dwo_file.  All callers updated.
	(open_and_init_dwo_file): Renamed from init_dwo_file.
	All callers updated.
	(lookup_dwo_file): Delete.
	(dwarf2_locate_dwp_sections): New function.
	(hash_dwp_loaded_cutus, eq_dwp_loaded_cutus): New functions.
	(allocate_dwp_loaded_cutus_table): New function.
	(open_and_init_dwp_file): New function.
	(lookup_dwo_cutu): New function.
	(lookup_dwo_comp_unit, lookup_dwo_type_unit): Call it.
@
text
@d7399 1
a7399 1
		      c_print_type (type, "", buf, -1, 0);
d7473 2
a7474 1
	      c_type_print_args (type, buf, 1, cu->language);
d7482 1
a7482 1
				     0, 0);
@


1.709
log
@	* dwarf2read.c (process_psymtab_comp_unit_reader): Remove duplicate
	"0x" prefix on address in log message.
@
text
@d33 1
d238 6
d303 1
a303 1
/* List of DWO sections.  */
d305 1
a305 1
static const struct dwo_section_names
d316 2
d319 1
a319 1
dwo_section_names =
d330 2
d660 1
a660 1
/* These sections are what may appear in a "dwo" file.  */
a664 1
  struct dwarf2_section_info info;
d671 2
d699 3
a701 1
/* Data for one DWO file.  */
d705 5
a709 3
  /* The DW_AT_GNU_dwo_name attribute.
     We don't manage space for this, it's an attribute.  */
  const char *dwo_name;
d711 3
a713 2
  /* The bfd, when the file is open.  Otherwise this is NULL.  */
  bfd *dwo_bfd;
d727 61
d817 1
a817 1
  /* Non-NULL if reading a DWO file.  */
d4111 3
a4113 1
   DWO_FILE is a pointer to the DWO file for .debug_types.dwo, NULL otherwise.
d4594 1
d4602 1
d4607 2
a4608 1
						    &signature, NULL);
d4611 4
a4614 1
	  gdb_assert (dwo_unit->length == get_cu_length (&cu->header));
d4627 3
a4629 1
	  gdb_assert (dwo_unit->length == get_cu_length (&cu->header));
d4705 2
a4706 2
   DWO_FILE, if non-NULL, is the DWO file to read (the caller is assumed to
   have already done the lookup to find the DWO file).
d8096 8
a8103 1
/* DWO files.  */
d8110 1
a8110 1
  return htab_hash_string (dwo_file->dwo_name);
d8119 1
a8119 1
  return strcmp (lhs->dwo_name, rhs->dwo_name) == 0;
d8138 18
d8195 1
a8195 62
/* This function is mapped across the sections and remembers the offset and
   size of each of the DWO debugging sections we are interested in.  */

static void
dwarf2_locate_dwo_sections (bfd *abfd, asection *sectp, void *dwo_file_ptr)
{
  struct dwo_file *dwo_file = dwo_file_ptr;
  const struct dwo_section_names *names = &dwo_section_names;

  if (section_is_p (sectp->name, &names->abbrev_dwo))
    {
      dwo_file->sections.abbrev.asection = sectp;
      dwo_file->sections.abbrev.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->info_dwo))
    {
      dwo_file->sections.info.asection = sectp;
      dwo_file->sections.info.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->line_dwo))
    {
      dwo_file->sections.line.asection = sectp;
      dwo_file->sections.line.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->loc_dwo))
    {
      dwo_file->sections.loc.asection = sectp;
      dwo_file->sections.loc.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macinfo_dwo))
    {
      dwo_file->sections.macinfo.asection = sectp;
      dwo_file->sections.macinfo.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->macro_dwo))
    {
      dwo_file->sections.macro.asection = sectp;
      dwo_file->sections.macro.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->str_dwo))
    {
      dwo_file->sections.str.asection = sectp;
      dwo_file->sections.str.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->str_offsets_dwo))
    {
      dwo_file->sections.str_offsets.asection = sectp;
      dwo_file->sections.str_offsets.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, &names->types_dwo))
    {
      struct dwarf2_section_info type_section;

      memset (&type_section, 0, sizeof (type_section));
      type_section.asection = sectp;
      type_section.size = bfd_get_section_size (sectp);
      VEC_safe_push (dwarf2_section_info_def, dwo_file->sections.types,
		     &type_section);
    }
}

/* Structure used to pass data to create_debug_info_hash_table_reader.  */
d8203 1
a8203 1
/* die_reader_func for create_debug_info_hash_table.  */
d8206 5
a8210 5
create_debug_info_hash_table_reader (const struct die_reader_specs *reader,
				     gdb_byte *info_ptr,
				     struct die_info *comp_unit_die,
				     int has_children,
				     void *datap)
d8228 1
a8228 1
	     offset.sect_off, dwo_file->dwo_name);
d8250 1
a8250 1
		 dwo_file->dwo_name);
d8262 3
a8264 1
/* Create a hash table to map DWO IDs to their CU entry in .debug_info.dwo.  */
d8267 1
a8267 1
create_debug_info_hash_table (struct dwo_file *dwo_file)
d8309 1
a8309 1
					 create_debug_info_hash_table_reader,
d8318 404
a8721 1
/* Subroutine of open_dwo_file to simplify it.
d8725 1
d8730 1
a8730 1
try_open_dwo_file (const char *file_name)
d8733 1
a8733 1
  int desc;
d8736 4
a8739 1
  desc = openp (debug_file_directory, OPF_TRY_CWD_FIRST, file_name,
d8762 1
a8762 1
/* Try to open DWO file DWO_NAME.
d8764 1
d8771 1
a8771 1
open_dwo_file (const char *dwo_name, const char *comp_dir)
d8775 2
a8776 2
  if (IS_ABSOLUTE_PATH (dwo_name))
    return try_open_dwo_file (dwo_name);
d8782 1
a8782 1
      char *path_to_try = concat (comp_dir, SLASH_STRING, dwo_name, NULL);
d8786 1
a8786 1
      abfd = try_open_dwo_file (path_to_try);
d8798 1
a8798 1
  return try_open_dwo_file (dwo_name);
d8801 63
a8863 1
/* Initialize the use of the DWO file specified by DWO_NAME.  */
d8866 1
a8866 1
init_dwo_file (const char *dwo_name, const char *comp_dir)
d8869 2
a8870 3
  struct dwo_file *dwo_file = OBSTACK_ZALLOC (&objfile->objfile_obstack,
					      struct dwo_file);
  bfd *abfd;
d8873 11
a8883 8
  if (dwarf2_read_debug)
    fprintf_unfiltered (gdb_stdlog, "Reading DWO file %s:\n", dwo_name);

  abfd = open_dwo_file (dwo_name, comp_dir);
  if (abfd == NULL)
    return NULL;
  dwo_file->dwo_name = dwo_name;
  dwo_file->dwo_bfd = abfd;
d8887 1
a8887 1
  bfd_map_over_sections (abfd, dwarf2_locate_dwo_sections, dwo_file);
d8889 1
a8889 1
  dwo_file->cus = create_debug_info_hash_table (dwo_file);
d8896 3
d8902 34
a8935 1
/* Lookup DWO file DWO_NAME.  */
d8937 2
a8938 2
static struct dwo_file *
lookup_dwo_file (const char *dwo_name, const char *comp_dir)
d8940 5
a8944 3
  struct dwo_file *dwo_file;
  struct dwo_file find_entry;
  void **slot;
d8946 1
a8946 2
  if (dwarf2_per_objfile->dwo_files == NULL)
    dwarf2_per_objfile->dwo_files = allocate_dwo_file_hash_table ();
d8948 5
a8952 3
  /* Have we already seen this DWO file?  */
  find_entry.dwo_name = dwo_name;
  slot = htab_find_slot (dwarf2_per_objfile->dwo_files, &find_entry, INSERT);
d8954 2
a8955 3
  /* If not, read it in and build a table of the DWOs it contains.  */
  if (*slot == NULL)
    *slot = init_dwo_file (dwo_name, comp_dir);
d8957 1
a8957 2
  /* NOTE: This will be NULL if unable to open the file.  */
  dwo_file = *slot;
d8959 10
a8968 1
  return dwo_file;
d8971 3
a8973 6
/* Lookup the DWO CU referenced from THIS_CU in DWO file DWO_NAME.
   If non-NULL, comp_dir is the DW_AT_comp_dir attribute.
   SIGNATURE is the "dwo_id" of the CU (for consistency we use the same
   nomenclature as TUs).
   The result is a pointer to the dwo_unit object or NULL if we didn't find it
   (dwo_id mismatch or couldn't find the DWO file).  */
d8975 2
a8976 4
static struct dwo_unit *
lookup_dwo_comp_unit (struct dwarf2_per_cu_data *this_cu,
		      const char *dwo_name, const char *comp_dir,
		      ULONGEST signature)
d8979 31
a9009 1
  struct dwo_file *dwo_file;
d9011 1
a9011 3
  dwo_file = lookup_dwo_file (dwo_name, comp_dir);
  if (dwo_file == NULL)
    return NULL;
d9013 1
a9013 1
  /* Look up the DWO using its signature(dwo_id).  */
d9015 1
a9015 3
  if (dwo_file->cus != NULL)
    {
      struct dwo_unit find_dwo_cu, *dwo_cu;
d9017 1
a9017 2
      find_dwo_cu.signature = signature;
      dwo_cu = htab_find (dwo_file->cus, &find_dwo_cu);
d9019 7
a9025 2
      if (dwo_cu != NULL)
	return dwo_cu;
d9028 1
a9028 7
  /* We didn't find it.  This must mean a dwo_id mismatch.  */

  complaint (&symfile_complaints,
	     _("Could not find DWO CU referenced by CU at offset 0x%x"
	       " [in module %s]"),
	     this_cu->offset.sect_off, objfile->name);
  return NULL;
d9031 3
a9033 1
/* Lookup the DWO TU referenced from THIS_TU in DWO file DWO_NAME.
d9035 9
d9045 1
a9045 1
   (dwo_id mismatch or couldn't find the DWO file).  */
d9048 3
a9050 2
lookup_dwo_type_unit (struct signatured_type *this_tu,
		      const char *dwo_name, const char *comp_dir)
d9053 2
d9056 1
d9058 34
a9091 3
  dwo_file = lookup_dwo_file (dwo_name, comp_dir);
  if (dwo_file == NULL)
    return NULL;
d9093 8
a9100 1
  /* Look up the DWO using its signature(dwo_id).  */
d9102 1
a9102 1
  if (dwo_file->tus != NULL)
d9104 5
a9108 1
      struct dwo_unit find_dwo_tu, *dwo_tu;
d9110 3
a9112 2
      find_dwo_tu.signature = this_tu->signature;
      dwo_tu = htab_find (dwo_file->tus, &find_dwo_tu);
d9114 11
a9124 2
      if (dwo_tu != NULL)
	return dwo_tu;
d9127 9
a9135 1
  /* We didn't find it.  This must mean a dwo_id mismatch.  */
d9138 1
a9138 1
	     _("Could not find DWO TU referenced by TU at offset 0x%x"
d9140 1
a9140 1
	     this_tu->per_cu.offset.sect_off, objfile->name);
d9144 21
d9175 2
a9176 2
  gdb_assert (dwo_file->dwo_bfd != objfile->obfd);
  gdb_bfd_unref (dwo_file->dwo_bfd);
@


1.708
log
@	* dwarf2read.c (read_1_byte): Add const to buf parameter.
	(read_1_signed_byte, read_2_bytes, read_2_signed_bytes): Ditto.
	(read_4_bytes, read_4_signed_bytes, read_8_bytes): Ditto.
	(lookup_dwo_file): Add const to dwo_name parameter.
	(lookup_dwo_comp_unit, lookup_dwo_type_unit): Ditto.
@
text
@d4862 1
a4862 1
			  "Psymtab for %s unit @@0x%x: 0x%s - 0x%s"
@


1.707
log
@	* dwarf2read.c (mark_common_block_symbol_computed): New function.
	(read_common_block): Handle child DIEs with
	DW_AT_data_member_location.
	(new_symbol_full): Add special case for common blocks.
gdb/testsuite
	* gdb.dwarf2/dw2-common-block.S: New file.
	* gdb.dwarf2/dw2-common-block.exp: New file.
@
text
@d1240 1
a1240 1
static unsigned int read_1_byte (bfd *, gdb_byte *);
d1242 1
a1242 1
static int read_1_signed_byte (bfd *, gdb_byte *);
d1244 1
a1244 1
static unsigned int read_2_bytes (bfd *, gdb_byte *);
d1246 1
a1246 1
static unsigned int read_4_bytes (bfd *, gdb_byte *);
d1248 1
a1248 1
static ULONGEST read_8_bytes (bfd *, gdb_byte *);
d1626 1
a1626 1
  (struct dwarf2_per_cu_data *, char *, const char *, ULONGEST);
d1629 1
a1629 1
  (struct signatured_type *, char *, const char *);
d8376 1
a8376 1
lookup_dwo_file (char *dwo_name, const char *comp_dir)
d8408 1
a8408 1
		      char *dwo_name, const char *comp_dir,
d8447 1
a8447 1
		      char *dwo_name, const char *comp_dir)
d13400 1
a13400 1
read_1_byte (bfd *abfd, gdb_byte *buf)
d13406 1
a13406 1
read_1_signed_byte (bfd *abfd, gdb_byte *buf)
d13412 1
a13412 1
read_2_bytes (bfd *abfd, gdb_byte *buf)
d13418 1
a13418 1
read_2_signed_bytes (bfd *abfd, gdb_byte *buf)
d13424 1
a13424 1
read_4_bytes (bfd *abfd, gdb_byte *buf)
d13430 1
a13430 1
read_4_signed_bytes (bfd *abfd, gdb_byte *buf)
d13436 1
a13436 1
read_8_bytes (bfd *abfd, gdb_byte *buf)
@


1.706
log
@2012-09-26  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>
	* dwarf2read.c (read_common_block): Rewrite.
	(new_symbol_full): Handle DW_TAG_common_block.
	* f-lang.c (head_common_list, find_common_for_function):
	Remove.
	* f-lang.h (struct common_entry, struct saved_f77_common,
	SAVED_F77_COMMON, SAVED_F77_COMMON_PTR, COMMON_ENTRY,
	COMMON_ENTRY_PTR, head_common_list, find_common_for_function,
	BLANK_COMMON_NAME_LOCAL): Remove.
	(struct common_block): New.
	* f-valprint.c (list_all_visible_commons): Remove.
	(info_common_command_for_block): New function.
	(info_common_command): Use it.
	* stack.c (iterate_over_block_locals): Special case for
	COMMON_BLOCK_DOMAIN.
	* symtab.h (enum domain_enum_tag) <COMMON_BLOCK_DOMAIN>: New
	constant.
	(struct general_symbol_info) <value.common_block>: New field.
	(SYMBOL_VALUE_COMMON_BLOCK): New define.
gdb/testsuite
2012-09-26  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* gdb.fortran/common-block.exp: New file.
	* gdb.fortran/common-block.f90: New file.
@
text
@d11067 73
d11149 23
d11198 33
a11230 2
	  if (sym)
	    common_block->contents[common_block->n_entries++] = sym;
d15133 13
a15145 2
	      if (attr2 && (DW_UNSND (attr2) != 0)
		  && dwarf2_attr (die, DW_AT_type, cu) != NULL)
@


1.705
log
@	* buildsym.h (param_symbols): Delete, unused.
	(context_stack): Delete member "params", unused.
	* buildsym.c (push_context): Update.
	* dwarf2read.c (read_func_scope): Update.
@
text
@d68 1
d11067 5
a11071 1
/* First cut: install each common block member as a global variable.  */
a11075 23
  struct die_info *child_die;
  struct attribute *attr;
  struct symbol *sym;
  CORE_ADDR base = (CORE_ADDR) 0;

  attr = dwarf2_attr (die, DW_AT_location, cu);
  if (attr)
    {
      /* Support the .debug_loc offsets.  */
      if (attr_form_is_block (attr))
        {
          base = decode_locdesc (DW_BLOCK (attr), cu);
        }
      else if (attr_form_is_section_offset (attr))
        {
	  dwarf2_complex_location_expr_complaint ();
        }
      else
        {
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
						 "common block member");
        }
    }
d11078 20
a11097 2
      child_die = die->child;
      while (child_die && child_die->tag)
d11099 2
a11100 2
	  LONGEST offset;

d11102 2
a11103 7
	  if (sym != NULL
	      && handle_data_member_location (child_die, cu, &offset))
	    {
	      SYMBOL_VALUE_ADDRESS (sym) = base + offset;
	      add_symbol_to_list (sym, &global_symbols);
	    }
	  child_die = sibling_die (child_die);
d11105 3
d14957 7
d15128 5
@


1.704
log
@	* dwarf2read.c (dwarf2_read_addr_index): Fix handling the case where
	cu == NULL.
@
text
@a8839 1
  param_symbols = new->params;
@


1.703
log
@	* dwarf2read.c (dw2_do_expand_symtabs_matching): Don't examine
	.gdb_index symbol attributes if there are none.
@
text
@d13731 1
d13733 1
a13733 1
     See however init_cutu_and_read_dies_simple.  */
d13744 4
a13747 2
      init_cutu_and_read_dies_simple (per_cu, dwarf2_read_addr_index_reader,
				      &aidata);
@


1.702
log
@gdb/
	* dwarf2read.c (dwarf2_locate_sections): Move variable aflag here.
	Move the SEC_HAS_CONTENTS check here - for any NAMES use.
	(dwarf2_locate_sections) <eh_frame>: Move the variable and check from
	here.
@
text
@d3136 7
d3144 2
a3145 2
	      if (want_specific_block
		  && index->version >= 7
d3149 2
a3150 3
	      /* Only check the symbol's kind if it has one.
		 Indices prior to version 7 don't record it.  */
	      if (index->version >= 7)
@


1.701
log
@	* dwarf2read.c (macro_start_file): Update.
	* objfiles.c (get_objfile_bfd_data): Initialize macro_cache.
	(free_objfile_per_bfd_storage): Destroy macro_cache.
	(allocate_objfile, free_objfile): Update.
	* objfiles.h (struct objfile_per_bfd_storage) <macro_cache>:
	New field.
	(struct objfile) <macro_cache>: Remove.
	* symfile.c (reread_symbols): Update.
	* symmisc.c (print_symbol_bcache_statistics): Update.
	(print_objfile_statistics): Update.
@
text
@d1713 1
d1720 4
a1723 1
  if (section_is_p (sectp->name, &names->info))
d1770 2
a1771 7
      flagword aflag = bfd_get_section_flags (abfd, sectp);

      if (aflag & SEC_HAS_CONTENTS)
        {
	  dwarf2_per_objfile->eh_frame.asection = sectp;
          dwarf2_per_objfile->eh_frame.size = bfd_get_section_size (sectp);
        }
@


1.700
log
@	* dwarf2read.c (dwarf_decode_macro_bytes)
	<DW_MACRO_GNU_transparent_include>: Use pointer to included data
	as hash key.
@
text
@d17085 2
a17086 2
    pending_macros = new_macro_table (&objfile->objfile_obstack,
                                      objfile->macro_cache);
@


1.699
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d17661 6
d17671 16
a17686 1
	    slot = htab_find_slot (include_hash, mac_ptr, INSERT);
d17697 1
a17697 20
		bfd *include_bfd = abfd;
		struct dwarf2_section_info *include_section = section;
		struct dwarf2_section_info alt_section;
		gdb_byte *include_mac_end = mac_end;
		int is_dwz = section_is_dwz;

		*slot = mac_ptr;

		if (macinfo_type == DW_MACRO_GNU_transparent_include_alt)
		  {
		    struct dwz_file *dwz = dwarf2_get_dwz_file ();

		    dwarf2_read_section (dwarf2_per_objfile->objfile,
					 &dwz->macro);

		    include_bfd = dwz->macro.asection->owner;
		    include_section = &dwz->macro;
		    include_mac_end = dwz->macro.buffer + dwz->macro.size;
		    is_dwz = 1;
		  }
d17699 1
a17699 2
		dwarf_decode_macro_bytes (include_bfd,
					  include_section->buffer + offset,
d17705 1
a17705 1
		htab_remove_elt (include_hash, mac_ptr);
@


1.698
log
@	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Expand parameter
	SIZE to size_t.
	(dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(locexpr_describe_location_1): Likewise.
	* dwarf2loc.h (struct dwarf2_locexpr_baton): Make SIZE as
	size_t.
	(struct dwarf2_loclist_baton): Likewise.
	* dwarf2read.c (struct dwarf_block): Likewise.
	(dump_die_shallow): Use pulongest to print dwarf_block.size.
	(decode_locdesc): Expand SIZE and I to size_t.
@
text
@d82 1
a82 1
static int dwarf2_die_debug = 0;
d19643 1
a19643 1
  add_setshow_zinteger_cmd ("dwarf2-die", no_class, &dwarf2_die_debug, _("\
d19648 3
a19650 3
			    NULL,
			    NULL,
			    &setdebuglist, &showdebuglist);
@


1.697
log
@	* NEWS: Document new options "set/show use-deprecated-index-sections",
	and delete reference to --use-deprecated-index-sections.
	* symfile.h (use_deprecated_index_sections): Delete.
	* dwarf2read.c (use_deprecated_index_sections): Make static.
	(read_index_from_section): Update wording of how to load
	deprecated index sections.
	(_initialize_dwarf2_read): New options
	"set/show use-deprecated-index-sections".
	* main.c (captured_main): Delete --use-deprecated-index-sections.

	doc/
	* gdb.texinfo (Mode Options): Delete --use-deprecated-index-sections.
	(Index Files): Document how to control the use of deprecated index
	sections.
	(Index Section Format): Replace --use-deprecated-index-sections with
	"set use-deprecated-index-sections on".
@
text
@d993 1
a993 1
    unsigned int size;
d16200 2
a16201 2
	  fprintf_unfiltered (f, "block: size %d",
			      DW_BLOCK (&die->attrs[i])->size);
d16204 2
a16205 2
	  fprintf_unfiltered (f, "expression: size %u",
			      DW_BLOCK (&die->attrs[i])->size);
d16749 2
a16750 2
  int i;
  int size = blk->size;
@


1.696
log
@2012-07-20  Jan Kratochvil <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	* dwarf2read.c (dwarf_decode_macros)
	<DW_MACRO_GNU_define_indirect_alt, DW_MACRO_GNU_undef_indirect_alt,
	DW_MACRO_GNU_transparent_include_alt>: New cases.
	(dwarf_decode_macro_bytes) <DW_MACRO_GNU_define_indirect,
	DW_MACRO_GNU_undef_indirect>: Examine 'section_is_dwz'.
@
text
@d88 1
a88 1
int use_deprecated_index_sections = 0;
d2614 2
a2615 2
     indices unless the --use-deprecated-index-sections command line
     option was supplied.  */
d2621 4
a2624 2
	  warning (_("Skipping deprecated .gdb_index section in %s, pass "
		     "--use-deprecated-index-sections to use them anyway"),
d19660 12
@


1.695
log
@	* dwarf2read.c (try_open_dwo_file): Don't call
	gdb_bfd_stash_filename.
@
text
@d17542 2
a17543 1
		    || macinfo_type == DW_MACRO_GNU_undef_indirect_alt)
d17866 2
d17878 1
@


1.694
log
@	* dwarf2read.c (dwarf2_ranges_read): Ignore ranges starting at zero if
	there's no section at address zero.
	(dwarf2_record_block_ranges): Ditto.
@
text
@a8280 1
  gdb_bfd_stash_filename (sym_bfd);
@


1.693
log
@	* dwarf2read.c (struct dwz_file) <gdb_index>: New field.
	(locate_dwz_sections): Recognize .gdb_index.
	(create_cus_from_index_list): New function.
	(create_cus_from_index): Use it.  Handle .dwz data.
	(read_index_from_section): New function, extracted from
	dwarf2_read_index.
	(dwarf2_read_index): Use it.  Read .gdb_index from dwz file,
	if needed.
@
text
@d9287 11
d9613 14
a9626 3
              record_block_range (block,
                                  baseaddr + base + start,
                                  baseaddr + base + end - 1);
@


1.692
log
@	* dwarf2read.c (struct dwarf2_per_objfile) <dwz_file>: New field.
	(struct dwarf2_per_cu_data) <length>: No longer bitfield.
	<is_dwz>: New field.
	(struct dwz_file): New.
	(struct partial_die_info) <is_dwz, spec_is_dwz>: New fields.
	(locate_dwz_sections, dwarf2_get_dwz_file)
	(get_abbrev_section_for_cu): New functions.
	(error_check_comp_unit_head, read_and_check_comp_unit_head)
	(read_and_check_type_unit_head): Add abbrev_section argument.
	(create_debug_types_hash_table): Update.
	(init_cutu_and_read_dies): Use proper abbrev section.
	(init_cutu_and_read_dies_no_follow): Likewise.
	(set_partial_user): Do nothing if PST==NULL.
	(read_comp_units_from_section): New function.
	(create_all_comp_units): Use it.
	(scan_partial_symbols, partial_die_parent_scope): Update.
	(skip_one_die): Handle DW_FORM_GNU_ref_alt, DW_FORM_GNU_strp_alt.
	(process_imported_unit_die, read_partial_die): Handle .dwz files.
	(find_partial_die): Add offset_in_dwz argument.  Update.
	(guess_partial_die_structure_name, fixup_partial_die): Update.
	(read_attribute_value): Handle DW_FORM_GNU_ref_alt,
	DW_FORM_GNU_strp_alt.
	(read_indirect_string_from_dwz): New function.
	(dwarf2_const_value_attr): Handle DW_FORM_GNU_strp_alt.
	(dump_die_shallow): Handle DW_FORM_GNU_ref_alt, DW_FORM_GNU_strp_alt.
	(is_ref_attr): Handle DW_FORM_GNU_ref_alt.
	(follow_die_offset): Add offset_in_dwz argument.
	(follow_die_ref, dwarf2_fetch_die_location_block): Update.
	(skip_form_bytes): Handle DW_FORM_GNU_strp_alt.
	(dwarf_decode_macro_bytes): Add section_is_dwz argument.
	Handle new macro forms.
	(dwarf_decode_macros): Update.
	(dwarf2_find_containing_comp_unit): Add offset_in_dwz argument.
	(dwarf2_per_objfile_free): Unref dwz_bfd, if it exists
	(lookup_die_type): Handle DW_FORM_GNU_ref_alt.
	(create_debug_types_hash_table): Use correct abbrev section.
	(get_debug_line_section): New function.
	(dwarf_decode_line_header, dwarf_decode_lines_1): Use it.
	(process_full_comp_unit): Pass 'required' argument to
	end_symtab_get_static_block.
	* buildsym.h (end_symtab_get_static_block): Update.
	* buildsym.c (end_symtab_get_static_block): Add 'required'
	argument.
	(end_symtab, end_expandable_symtab): Update.
@
text
@d719 1
d1957 5
d2298 2
a2299 3
/* Read the CU list from the mapped index, and use it to create all
   the CU objects for this objfile.  Return 0 if something went wrong,
   1 if everything went ok.  */
d2302 5
a2306 2
create_cus_from_index (struct objfile *objfile, const gdb_byte *cu_list,
		       offset_type cu_list_elements)
d2310 1
a2310 7
  dwarf2_per_objfile->n_comp_units = cu_list_elements / 2;
  dwarf2_per_objfile->all_comp_units
    = obstack_alloc (&objfile->objfile_obstack,
		     dwarf2_per_objfile->n_comp_units
		     * sizeof (struct dwarf2_per_cu_data *));

  for (i = 0; i < cu_list_elements; i += 2)
d2325 1
a2325 1
      the_cu->info_or_types_section = &dwarf2_per_objfile->info;
d2328 2
a2329 1
      dwarf2_per_objfile->all_comp_units[i / 2] = the_cu;
d2335 29
d2553 10
a2562 2
/* Read the index file.  If everything went ok, initialize the "quick"
   elements of all the CUs and return 1.  Otherwise, return 0.  */
d2565 9
a2573 1
dwarf2_read_index (struct objfile *objfile)
d2576 1
a2576 1
  struct mapped_index *map;
a2577 4
  const gdb_byte *cu_list;
  const gdb_byte *types_list = NULL;
  offset_type version, cu_list_elements;
  offset_type types_list_elements = 0;
d2580 1
a2580 1
  if (dwarf2_section_empty_p (&dwarf2_per_objfile->gdb_index))
d2585 1
a2585 2
  if ((bfd_get_file_flags (dwarf2_per_objfile->gdb_index.asection)
       & SEC_HAS_CONTENTS) == 0)
d2588 1
a2588 1
  dwarf2_read_section (objfile, &dwarf2_per_objfile->gdb_index);
d2590 1
a2590 1
  addr = dwarf2_per_objfile->gdb_index.buffer;
d2603 1
a2603 1
		   objfile->name);
d2616 1
a2616 1
  if (version < 6 && !use_deprecated_index_sections)
d2623 1
a2623 1
		   objfile->name);
a2632 1
  map = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct mapped_index);
d2634 1
a2634 1
  map->total_size = dwarf2_per_objfile->gdb_index.size;
d2639 3
a2641 3
  cu_list = addr + MAYBE_SWAP (metadata[i]);
  cu_list_elements = ((MAYBE_SWAP (metadata[i + 1]) - MAYBE_SWAP (metadata[i]))
		      / 8);
d2644 4
a2647 4
  types_list = addr + MAYBE_SWAP (metadata[i]);
  types_list_elements = ((MAYBE_SWAP (metadata[i + 1])
			  - MAYBE_SWAP (metadata[i]))
			 / 8);
d2663 21
d2685 1
a2685 1
  if (map->symbol_table_slots == 0)
d2688 24
a2711 1
  if (!create_cus_from_index (objfile, cu_list, cu_list_elements))
d2732 4
a2735 1
  create_addrmap_from_index (objfile, map);
@


1.691
log
@	* dwarf2read.c: Don't include zlib.h or sys/mman.h.
	(pagesize): Remove.
	(struct dwarf2_section_info) <map_addr, map_len>: Remove.
	(zlib_decompress_section): Remove.
	(dwarf2_read_section): Use gdb_bfd_map_section.
	(munmap_section_buffer): Remove.
	(free_dwo_file, dwarf2_per_objfile_free): Don't use
	munmap_section_buffer.
	* gdb_bfd.c: Include zlib.h, sys/mman.h.
	(struct gdb_bfd_section_data): New.
	(free_one_bfd_section): New function.
	(gdb_bfd_close_or_warn): Use free_one_bfd_section.
	(get_section_descriptor, zlib_decompress_section)
	(gdb_bfd_map_section): New functions.
	* gdb_bfd.h (gdb_bfd_map_section): Declare.
@
text
@d236 4
d498 1
a498 3
  /* The start offset and length of this compilation unit.  2**29-1
     bytes should suffice to store the length of any compilation unit
     - if it doesn't, GDB will fall over anyway.
d504 1
a504 1
  unsigned int length : 29;
d519 3
d709 15
d837 6
d1228 1
a1228 1
static struct partial_die_info *find_partial_die (sect_offset,
d1273 2
d1541 1
a1541 1
  (sect_offset offset, struct objfile *objfile);
d1604 6
d1922 100
d3697 16
d3731 1
a3731 2
      >= dwarf2_section_size (dwarf2_per_objfile->objfile,
			      &dwarf2_per_objfile->abbrev))
d3968 1
d3980 5
d4224 2
a4225 1
  abbrev_section = &dwarf2_per_objfile->abbrev;
d4607 1
a4607 1
				     &dwarf2_per_objfile->abbrev,
d5235 3
a5331 3
/* Create a list of all compilation units in OBJFILE.
   This is only done for -readnow and building partial symtabs.  */

d5333 6
a5338 1
create_all_comp_units (struct objfile *objfile)
a5339 3
  int n_allocated;
  int n_comp_units;
  struct dwarf2_per_cu_data **all_comp_units;
d5341 1
d5343 1
a5343 2
  dwarf2_read_section (objfile, &dwarf2_per_objfile->info);
  info_ptr = dwarf2_per_objfile->info.buffer;
d5345 1
a5345 4
  n_comp_units = 0;
  n_allocated = 10;
  all_comp_units = xmalloc (n_allocated
			    * sizeof (struct dwarf2_per_cu_data *));
d5347 1
a5347 2
  while (info_ptr < dwarf2_per_objfile->info.buffer
	 + dwarf2_per_objfile->info.size)
d5353 1
a5353 1
      offset.sect_off = info_ptr - dwarf2_per_objfile->info.buffer;
d5357 1
a5357 2
      length = read_initial_length (objfile->obfd, info_ptr,
				    &initial_length_size);
d5365 1
d5367 1
a5367 1
      this_cu->info_or_types_section = &dwarf2_per_objfile->info;
d5369 1
a5369 1
      if (n_comp_units == n_allocated)
d5371 4
a5374 4
	  n_allocated *= 2;
	  all_comp_units = xrealloc (all_comp_units,
				     n_allocated
				     * sizeof (struct dwarf2_per_cu_data *));
d5376 2
a5377 1
      all_comp_units[n_comp_units++] = this_cu;
d5381 28
d5501 1
d5559 2
a5560 1
    real_pdi = find_partial_die (real_pdi->spec_offset, cu);
d6060 3
d6092 1
d6760 3
a6762 1
  static_block = end_symtab_get_static_block (highpc + baseaddr, objfile, 0);
d6913 1
d6916 2
a6917 1
      per_cu = dwarf2_find_containing_comp_unit (offset, cu->objfile);
d12599 2
d12647 5
a12651 1
	    part_die->d.offset = dwarf2_get_ref_die_offset (&attr);
d12722 1
a12722 1
find_partial_die (sect_offset offset, struct dwarf2_cu *cu)
d12728 2
a12729 1
  if (offset_in_cu_p (&cu->header, offset))
d12748 2
a12749 1
      per_cu = dwarf2_find_containing_comp_unit (offset, objfile);
d12807 2
a12808 1
    real_pdi = find_partial_die (real_pdi->spec_offset, cu);
d12856 2
a12857 1
      spec_die = find_partial_die (part_die->spec_offset, cu);
d12945 4
d12991 19
a13009 4
      DW_STRING (attr) = read_indirect_string (abfd, info_ptr, cu_header,
					       &bytes_read);
      DW_STRING_IS_CANONICAL (attr) = 0;
      info_ptr += bytes_read;
d13121 4
d13421 24
d13916 24
d13960 1
a13960 7
  /* For TUs in DWO files, the DW_AT_stmt_list attribute lives in the
     DWO file.  */
  if (cu->dwo_unit && cu->per_cu->is_debug_types)
    section = &cu->dwo_unit->dwo_file->sections.line;
  else
    section = &dwarf2_per_objfile->line;

d14285 1
a14285 1
			= line_ptr - dwarf2_per_objfile->line.buffer;
d15131 1
d15318 9
a15326 1
  if (is_ref_attr (attr))
d16099 4
d16134 1
d16238 1
d16316 2
a16317 1
follow_die_offset (sect_offset offset, struct dwarf2_cu **ref_cu)
d16334 2
a16335 1
  else if (! offset_in_cu_p (&cu->header, offset))
d16339 2
a16340 1
      per_cu = dwarf2_find_containing_comp_unit (offset, cu->objfile);
d16372 4
a16375 1
  die = follow_die_offset (offset, ref_cu);
d16406 1
a16406 1
  die = follow_die_offset (offset, &cu);
d17200 1
d17356 1
a17356 1
			  int section_is_gnu,
d17407 2
d17431 9
a17439 1
		body = read_indirect_string_at_offset (abfd, str_offset);
d17443 2
a17444 1
			 || macinfo_type == DW_MACRO_GNU_define_indirect);
d17468 2
a17469 1
			    || macinfo_type == DW_MACRO_GNU_undef_indirect);
d17544 1
d17563 6
d17571 16
a17586 3
		dwarf_decode_macro_bytes (abfd,
					  section->buffer + offset,
					  mac_end, current_file,
d17588 1
a17588 1
					  section, section_is_gnu,
d17807 2
a17808 1
			    current_file, lh, comp_dir, section, section_is_gnu,
d18063 1
d18068 1
d18074 1
d18077 5
a18081 2
      if (dwarf2_per_objfile->all_comp_units[mid]->offset.sect_off
	  >= offset.sect_off)
d18087 3
a18089 2
  if (dwarf2_per_objfile->all_comp_units[low]->offset.sect_off
      > offset.sect_off)
d18091 1
a18091 1
      if (low == 0)
d18549 3
@


1.690
log
@	* dwarf2read.c (try_open_dwo_file): use gdb_bfd_open.
@
text
@a72 9
#ifdef HAVE_ZLIB_H
#include <zlib.h>
#endif
#ifdef HAVE_MMAP
#include <sys/mman.h>
#ifndef MAP_FAILED
#define MAP_FAILED ((void *) -1)
#endif
#endif
a89 2
static int pagesize;

a102 4
  /* Not NULL if the section was actually mmapped.  */
  void *map_addr;
  /* Page aligned size of mmapped area.  */
  bfd_size_type map_len;
a1596 2
static void munmap_section_buffer (struct dwarf2_section_info *);

a1765 79
/* Decompress a section that was compressed using zlib.  Store the
   decompressed buffer, and its size, in OUTBUF and OUTSIZE.  */

static void
zlib_decompress_section (struct objfile *objfile, asection *sectp,
                         gdb_byte **outbuf, bfd_size_type *outsize)
{
  bfd *abfd = sectp->owner;
#ifndef HAVE_ZLIB_H
  error (_("Support for zlib-compressed DWARF data (from '%s') "
           "is disabled in this copy of GDB"),
         bfd_get_filename (abfd));
#else
  bfd_size_type compressed_size = bfd_get_section_size (sectp);
  gdb_byte *compressed_buffer = xmalloc (compressed_size);
  struct cleanup *cleanup = make_cleanup (xfree, compressed_buffer);
  bfd_size_type uncompressed_size;
  gdb_byte *uncompressed_buffer;
  z_stream strm;
  int rc;
  int header_size = 12;

  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0
      || bfd_bread (compressed_buffer,
		    compressed_size, abfd) != compressed_size)
    error (_("Dwarf Error: Can't read DWARF data from '%s'"),
           bfd_get_filename (abfd));

  /* Read the zlib header.  In this case, it should be "ZLIB" followed
     by the uncompressed section size, 8 bytes in big-endian order.  */
  if (compressed_size < header_size
      || strncmp (compressed_buffer, "ZLIB", 4) != 0)
    error (_("Dwarf Error: Corrupt DWARF ZLIB header from '%s'"),
           bfd_get_filename (abfd));
  uncompressed_size = compressed_buffer[4]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[5]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[6]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[7]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[8]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[9]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[10]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[11];

  /* It is possible the section consists of several compressed
     buffers concatenated together, so we uncompress in a loop.  */
  strm.zalloc = NULL;
  strm.zfree = NULL;
  strm.opaque = NULL;
  strm.avail_in = compressed_size - header_size;
  strm.next_in = (Bytef*) compressed_buffer + header_size;
  strm.avail_out = uncompressed_size;
  uncompressed_buffer = obstack_alloc (&objfile->objfile_obstack,
                                       uncompressed_size);
  rc = inflateInit (&strm);
  while (strm.avail_in > 0)
    {
      if (rc != Z_OK)
        error (_("Dwarf Error: setting up DWARF uncompression in '%s': %d"),
               bfd_get_filename (abfd), rc);
      strm.next_out = ((Bytef*) uncompressed_buffer
                       + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, Z_FINISH);
      if (rc != Z_STREAM_END)
        error (_("Dwarf Error: zlib error uncompressing from '%s': %d"),
               bfd_get_filename (abfd), rc);
      rc = inflateReset (&strm);
    }
  rc = inflateEnd (&strm);
  if (rc != Z_OK
      || strm.avail_out != 0)
    error (_("Dwarf Error: concluding DWARF uncompression in '%s': %d"),
           bfd_get_filename (abfd), rc);

  do_cleanups (cleanup);
  *outbuf = uncompressed_buffer;
  *outsize = uncompressed_size;
#endif
}

a1791 1
  info->map_addr = NULL;
a1796 1
  /* Note that ABFD may not be from OBJFILE, e.g. a DWO section.  */
d1799 10
a1808 12
  /* Check if the file has a 4-byte header indicating compression.  */
  if (info->size > sizeof (header)
      && bfd_seek (abfd, sectp->filepos, SEEK_SET) == 0
      && bfd_bread (header, sizeof (header), abfd) == sizeof (header))
    {
      /* Upon decompression, update the buffer and its size.  */
      if (strncmp (header, "ZLIB", sizeof (header)) == 0)
        {
          zlib_decompress_section (objfile, sectp, &info->buffer,
				   &info->size);
          return;
        }
d1811 2
a1812 27
#ifdef HAVE_MMAP
  if (pagesize == 0)
    pagesize = getpagesize ();

  /* Only try to mmap sections which are large enough: we don't want to
     waste space due to fragmentation.  Also, only try mmap for sections
     without relocations.  */

  if (info->size > 4 * pagesize && (sectp->flags & SEC_RELOC) == 0)
    {
      info->buffer = bfd_mmap (abfd, 0, info->size, PROT_READ,
                         MAP_PRIVATE, sectp->filepos,
                         &info->map_addr, &info->map_len);

      if ((caddr_t)info->buffer != MAP_FAILED)
	{
#if HAVE_POSIX_MADVISE
	  posix_madvise (info->map_addr, info->map_len, POSIX_MADV_WILLNEED);
#endif
	  return;
	}
    }
#endif

  /* If we get here, we are a normal, not-compressed section.  */
  info->buffer = buf
    = obstack_alloc (&objfile->objfile_obstack, info->size);
a8201 13
  munmap_section_buffer (&dwo_file->sections.abbrev);
  munmap_section_buffer (&dwo_file->sections.info);
  munmap_section_buffer (&dwo_file->sections.line);
  munmap_section_buffer (&dwo_file->sections.loc);
  munmap_section_buffer (&dwo_file->sections.str);
  munmap_section_buffer (&dwo_file->sections.str_offsets);

  for (ix = 0;
       VEC_iterate (dwarf2_section_info_def, dwo_file->sections.types,
		    ix, section);
       ++ix)
    munmap_section_buffer (section);

d18203 1
a18203 20
/* If section described by INFO was mmapped, munmap it now.  */

static void
munmap_section_buffer (struct dwarf2_section_info *info)
{
  if (info->map_addr != NULL)
    {
#ifdef HAVE_MMAP
      int res;

      res = munmap (info->map_addr, info->map_len);
      gdb_assert (res == 0);
#else
      /* Without HAVE_MMAP, we should never be here to begin with.  */
      gdb_assert_not_reached ("no mmap support");
#endif
    }
}

/* munmap debug sections for OBJFILE, if necessary.  */
a18209 21
  struct dwarf2_section_info *section;

  /* This is sorted according to the order they're defined in to make it easier
     to keep in sync.  */
  munmap_section_buffer (&data->info);
  munmap_section_buffer (&data->abbrev);
  munmap_section_buffer (&data->line);
  munmap_section_buffer (&data->loc);
  munmap_section_buffer (&data->macinfo);
  munmap_section_buffer (&data->macro);
  munmap_section_buffer (&data->str);
  munmap_section_buffer (&data->ranges);
  munmap_section_buffer (&data->addr);
  munmap_section_buffer (&data->frame);
  munmap_section_buffer (&data->eh_frame);
  munmap_section_buffer (&data->gdb_index);

  for (ix = 0;
       VEC_iterate (dwarf2_section_info_def, data->types, ix, section);
       ++ix)
    munmap_section_buffer (section);
@


1.689
log
@	* symfile.c (symfile_bfd_open): Don't copy name.  Call
	gdb_bfd_stash_filename.
	(load_command): Open the new BFD before freeing the old.
	(bfd_open_maybe_remote): Call gdb_bfd_stash_filename.
	* symfile-mem.c (symbol_file_add_from_memory): Don't copy name.
	Call gdb_bfd_stash_filename.
	* spu-linux-nat.c (spu_bfd_open): Don't copy name.
	* solib-spu.c (spu_bfd_fopen): Don't copy name.  Call
	gdb_bfd_stash_filename.
	* solib-darwin.c (darwin_solib_get_all_image_info_addr_at_init):
	Free found_pathname.
	* rs6000-nat.c (add_vmap): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* remote.c (remote_bfd_open): Call gdb_bfd_stash_filename.
	* machoread.c (macho_add_oso_symfile): Call
	gdb_bfd_stash_filename.
	(macho_symfile_read_all_oso): Arrange to free archive_name.  Call
	gdb_bfd_stash_filename.
	(macho_check_dsym): Don't copy filename.  Call
	gdb_bfd_stash_filename.
	* jit.c (bfd_open_from_target_memory): Don't copy the filename.
	* gdb_bfd.c (gdb_bfd_stash_filename): New function.
	* gdb_bfd.h (gdb_bfd_stash_filename): Declare.
	* gcore.c (create_gcore_bfd): Call gdb_bfd_stash_filename.
	* exec.c (exec_close): Don't free the BFD's filename.
	(exec_file_attach): Don't copy the filename.  Call
	gdb_bfd_stash_filename.
	* corelow.c (core_close): Don't free the BFD's filename.
	(core_open): Call gdb_bfd_stash_filename.
	* corefile.c (reopen_exec_file): Remove #if 0 code.
	* solib.c (solib_bfd_fopen): Call gdb_bfd_stash_filename.  Free
	pathname.
	* dwarf2read.c (try_open_dwo_file): Call gdb_bfd_stash_filename.
@
text
@d8118 1
a8118 1
  sym_bfd = gdb_bfd_ref (bfd_fopen (absolute_name, gnutarget, FOPEN_RB, desc));
@


1.688
log
@	* dwarf2read.c (try_open_dwo_file): Use gdb_bfd_ref and
	gdb_bfd_unref.
	(free_dwo_file): Use gdb_bfd_unref.
	* cli/cli-dump.c: Include gdb_bfd.h.
	(bfd_openw_with_cleanup): Use gdb_bfd_ref.
	(bfd_openr_with_cleanup): Likewise.
	* windows-nat.c (windows_make_so): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* utils.c: Include gdb_bfd.h.
	(do_bfd_close_cleanup): Use gdb_bfd_unref.
	* symfile.c: Include gdb_bfd.h.
	(separate_debug_file_exists): Use gdb_bfd_unref.
	(bfd_open_maybe_remote): Use gdb_bfd_ref.
	(symfile_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	(generic_load): Use gdb_bfd_ref.
	(reread_symbols): Use gdb_bfd_unref.
	* symfile-mem.c: Include gdb_bfd.h.
	(symbol_file_add_from_memory): Use make_cleanup_bfd_close.
	* spu-linux-nat.c (spu_bfd_open): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib.c: Include gdb_bfd.h.
	(solib_bfd_fopen): Use gdb_bfd_ref.
	(solib_bfd_open): Use gdb_bfd_unref.
	(free_so_symbols): Use gdb_bfd_unref.
	(reload_shared_libraries_1): Use gdb_bfd_unref.
	* solib-spu.c: Include gdb_bfd.h.
	(spu_bfd_fopen): Use gdb_bfd_ref, gdb_bfd_unref.
	* solib-pa64.c (pa64_solib_create_inferior_hook): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* solib-frv.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-dsbt.c: Include gdb_bfd.h.
	(enable_break2): Use gdb_bfd_unref.
	* solib-darwin.c: Include gdb_bfd.h.
	(darwin_solib_get_all_image_info_addr_at_init): Use gdb_bfd_ref,
	gdb_bfd_unref.
	(darwin_bfd_open): Use gdb_bfd_unref.
	* rs6000-nat.c (add_vmap): Use gdb_bfd_ref, gdb_bfd_unref.
	* remote-mips.c: Include gdb_bfd.h.
	(mips_load_srec): Use gdb_bfd_ref.
	(pmon_load_fast): Use gdb_bfd_ref.
	* remote-m32r-sdi.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	* record.c: Include gdb_bfd.h.
	(record_save_cleanups): Use gdb_bfd_unref.
	(cmd_record_save): Use gdb_bfd_unref.
	* procfs.c (insert_dbx_link_bpt_in_file): Use gdb_bfd_ref,
	gdb_bfd_unref.
	* objfiles.h (gdb_bfd_close_or_warn): Remove.
	(gdb_bfd_ref, gdb_bfd_unref): Move to gdb_bfd.h.
	* objfiles.c: Include gdb_bfd.h.
	(free_objfile): Use gdb_bfd_unref.
	(gdb_bfd_close_or_warn, gdb_bfd_ref, gdb_bfd_unref): Move to
	gdb_bfd.c.
	* machoread.c (macho_add_oso_symfile): Use gdb_bfd_unref.
	(macho_symfile_read_all_oso): Use gdb_bfd_ref, gdb_bfd_unref.
	(macho_check_dsym): Likewise.
	* m32r-rom.c: Include gdb_bfd.h.
	(m32r_load): Use gdb_bfd_ref.
	(m32r_upload_command): Use gdb_bfd_ref.
	* jit.c: Include gdb_bfd.h.
	(jit_bfd_try_read_symtab): Use gdb_bfd_ref, gdb_bfd_unref.
	* gdb_bfd.h: New file.
	* gdb_bfd.c: New file.
	* gcore.c: Include gdb_bfd.h.
	(create_gcore_bfd): Use gdb_bfd_ref.
	(do_bfd_delete_cleanup): Use gdb_bfd_unref.
	(gcore_command): Use gdb_bfd_unref.
	* exec.c: Include gdb_bfd.h.
	(exec_close): Use gdb_bfd_unref.
	(exec_close_1): Use gdb_bfd_unref.
	(exec_file_attach): Use gdb_bfd_ref.
	* elfread.c: Include gdb_bfd.h.
	(build_id_verify): Use gdb_bfd_unref.
	* dsrec.c: Include gdb_bfd.h.
	(load_srec): Use gdb_bfd_ref.
	* corelow.c: Include gdb_bfd.h.
	(core_close): Use gdb_bfd_unref.
	(core_open): Use gdb_bfd_ref.
	* bfd-target.c: Include gdb_bfd.h.
	(target_bfd_xclose): Use gdb_bfd_unref.
	(target_bfd_reopen): Use gdb_bfd_ref.
	* Makefile.in (SFILES): Add gdb_bfd.c.
	(HFILES_NO_SRCDIR): Add gdb_bfd.h.
	(COMMON_OBS): Add gdb_bfd.o.
@
text
@d8124 2
a8129 1
      xfree (absolute_name);
@


1.687
log
@	* dwarf2read.c (stmt_list_hash): New struct.
	(type_unit_group): Embed "per_cu" member, remove pointer.
	New union member "t", move member "tus" into it, all uses updated.
	New member "hash", replaces member "line_offset, all uses updated.
	(quick_file_names): Replace member "offset" with "hash", all uses
	updated.
	(hash_stmt_list_entry, eq_stmt_list_entry): New functions.
	(hash_file_name_entry, eq_file_name_entry): Call them.
	(hash_type_unit_group, eq_type_unit_group): Ditto.
	(dw2_get_cu, dw2_get_primary_cu): Replace assert with a better one.
	(dw2_get_file_names_reader): Fix file name table calculation for TUs.
	(dw2_get_file_names): Update.
	(create_type_unit_group): Replace "per_cu" arg with "cu".
	All callers updated.  Fix "quick" (.gdb_index) handling.
	(get_type_unit_group): Replace "per_cu" arg with "cu".
	All callers updated.
	(build_type_unit_groups): Don't reset tu_stats.
@
text
@d67 1
d8118 1
a8118 1
  sym_bfd = bfd_fopen (absolute_name, gnutarget, FOPEN_RB, desc);
a8127 1
      bfd_close (sym_bfd); /* This also closes desc.  */
d8129 1
a8132 3
  /* bfd_usrdata exists for applications and libbfd must not touch it.  */
  gdb_assert (bfd_usrdata (sym_bfd) == NULL);

d8324 1
a8324 1
  bfd_close (dwo_file->dwo_bfd);
@


1.687.2.1
log
@	* NEWS: Document new options "set/show use-deprecated-index-sections",
	and delete reference to --use-deprecated-index-sections.
	* symfile.h (use_deprecated_index_sections): Delete.
	* dwarf2read.c (use_deprecated_index_sections): Make static.
	(read_index_from_section): Update wording of how to load
	deprecated index sections.
	(_initialize_dwarf2_read): New options
	"set/show use-deprecated-index-sections".
	* main.c (captured_main): Delete --use-deprecated-index-sections.

	doc/
	* gdb.texinfo (Mode Options): Delete --use-deprecated-index-sections.
	(Index Files): Document how to control the use of deprecated index
	sections.
	(Index Section Format): Replace --use-deprecated-index-sections with
	"set use-deprecated-index-sections on".
@
text
@d96 1
a96 1
static int use_deprecated_index_sections = 0;
d2561 2
a2562 2
     indices unless the user has done
     "set use-deprecated-index-sections on".  */
d2568 2
a2569 4
	  warning (_("\
Skipping deprecated .gdb_index section in %s.\n\
Do \"set use-deprecated-index-sections on\" before the file is read\n\
to use the section anyway."),
a19389 12
  add_setshow_boolean_cmd ("use-deprecated-index-sections",
			   no_class, &use_deprecated_index_sections, _("\
Set whether to use deprecated gdb_index sections."), _("\
Show whether to use deprecated gdb_index sections."), _("\
When enabled, deprecated .gdb_index sections are used anyway.\n\
Normally they are ignored either because of a missing feature or\n\
performance issue.\n\
Warning: This option must be enabled before gdb reads the file."),
			   NULL,
			   NULL,
			   &setlist, &showlist);

@


1.687.2.2
log
@gdb/
	PR gdb/14494.
	* dwarf2read.c (dwarf2_locate_sections): Move variable aflag here.
	Move the SEC_HAS_CONTENTS check here - for any NAMES use.
	(dwarf2_locate_sections) <eh_frame>: Move the variable and check from
	here.
@
text
@a1693 1
  flagword aflag = bfd_get_section_flags (abfd, sectp);
d1700 1
a1700 4
  if ((aflag & SEC_HAS_CONTENTS) == 0)
    {
    }
  else if (section_is_p (sectp->name, &names->info))
d1747 7
a1753 2
      dwarf2_per_objfile->eh_frame.asection = sectp;
      dwarf2_per_objfile->eh_frame.size = bfd_get_section_size (sectp);
@


1.686
log
@gdb/
	* buildsym.c (end_symtab_1): Split it to ...
	(end_symtab_get_static_block): ... this ...
	(end_symtab_from_static_block): ... and this function.
	(end_symtab, end_expandable_symtab): Call them.
	* buildsym.h (end_symtab_get_static_block)
	(end_symtab_from_static_block): New declarations.
	* dwarf2read.c (process_full_comp_unit): New variable static_block.
	Set its valid CU ranges.

gdb/testsuite/
	* gdb.dwarf2/dw2-minsym-in-cu.S: New file.
	* gdb.dwarf2/dw2-minsym-in-cu.exp: New file.
@
text
@d596 12
d619 1
a619 1
  struct dwarf2_per_cu_data *per_cu;
d621 12
a632 4
  /* The TUs that share this DW_AT_stmt_list entry.
     This is added to while parsing type units to build partial symtabs,
     and is deleted afterwards and not used again.  */
  VEC (dwarf2_per_cu_ptr) *tus;
d635 2
a636 2
     Type units don't have DW_AT_name so we create an essentially
     anonymous symtab as the primary symtab.  */
d639 2
a640 2
  /* Offset in .debug_line.  This is the hash key.  */
  sect_offset line_offset;
d1489 1
a1489 1
    (struct dwarf2_per_cu_data *, struct attribute *);
d2022 2
a2023 2
  /* The offset in .debug_line of the line table.  We hash on this.  */
  unsigned int offset;
d2060 28
d2095 1
a2095 1
  return file_data->offset;
d2106 1
a2106 1
  return ea->offset == eb->offset;
a2222 2
      struct dwarf2_per_cu_data *per_cu;

d2224 2
a2225 3
      per_cu = &dwarf2_per_objfile->all_type_units[index]->per_cu;
      gdb_assert (! IS_TYPE_UNIT_GROUP (per_cu));
      return per_cu;
a2250 2
      struct dwarf2_per_cu_data *per_cu;

d2252 2
a2253 3
      per_cu = dwarf2_per_objfile->all_type_unit_groups[index]->per_cu;
      gdb_assert (IS_TYPE_UNIT_GROUP (per_cu));
      return per_cu;
a2665 1
  struct dwarf2_per_cu_data *per_cu = cu->per_cu;
d2677 1
a2677 1
  tu_group = get_type_unit_group (per_cu, attr);
d2702 1
d2719 12
d2744 2
a2745 1
      find_entry.offset = line_offset;
d2750 1
a2750 1
	  this_cu->v.quick->file_names = *slot;
d2758 1
a2758 1
      this_cu->v.quick->no_file_data = 1;
d2763 2
a2764 1
  qfn->offset = line_offset;
d2779 1
a2779 1
  this_cu->v.quick->file_names = qfn;
d2804 6
a2809 2
    init_cutu_and_read_dies (this_cu, NULL, 0, 0,
			     dw2_get_file_names_reader, NULL);
d4770 1
a4770 1
  const struct type_unit_group *symtab = item;
d4772 1
a4772 1
  return symtab->line_offset.sect_off;
d4781 1
a4781 1
  return lhs->line_offset.sect_off == rhs->line_offset.sect_off;
d4804 1
a4804 1
/* Helper routine for build_type_psymtabs_reader.
d4808 1
a4808 2
create_type_unit_group (struct dwarf2_per_cu_data *per_cu,
			sect_offset line_offset_struct)
d4811 1
a4812 12
  struct partial_symtab *pst;
  unsigned int line_offset;
  char *name;

  line_offset = line_offset_struct.sect_off;

  /* Give the symtab a useful name for debug purposes.  */
  if ((line_offset & NO_STMT_LIST_TYPE_UNIT_PSYMTAB) != 0)
    name = xstrprintf ("<type_units_%d>",
		       (line_offset & ~NO_STMT_LIST_TYPE_UNIT_PSYMTAB));
  else
    name = xstrprintf ("<type_units_at_0x%x>", line_offset);
d4816 1
a4816 3

  per_cu = OBSTACK_ZALLOC (&objfile->objfile_obstack,
			   struct dwarf2_per_cu_data);
d4821 21
a4841 2
  pst = create_partial_symtab (per_cu, name);
  pst->anonymous = 1;
d4843 2
a4844 1
  xfree (name);
d4846 2
a4847 2
  tu_group->per_cu = per_cu;
  tu_group->line_offset.sect_off = line_offset;
d4852 2
a4853 2
/* Look up the type_unit_group for PER_CU, and create it if necessary.
   STMT_LIST is an DW_AT_stmt_list attribute.  */
d4856 1
a4856 2
get_type_unit_group (struct dwarf2_per_cu_data *per_cu,
		     struct attribute *stmt_list)
d4890 2
a4891 1
  type_unit_group_for_lookup.line_offset.sect_off = line_offset;
d4904 1
a4904 1
      tu_group = create_type_unit_group (per_cu, line_offset_struct);
d5022 3
a5024 1
  memset (tu_stats, 0, sizeof (*tu_stats));
d5111 1
a5111 1
  tu_group = get_type_unit_group (per_cu, attr);
d5113 1
a5113 1
  VEC_safe_push (dwarf2_per_cu_ptr, tu_group->tus, per_cu);
d5140 1
a5140 1
  struct dwarf2_per_cu_data *per_cu = tu_group->per_cu;
d5142 1
a5142 1
  int len = VEC_length (dwarf2_per_cu_ptr, tu_group->tus);
d5152 1
a5152 1
       VEC_iterate (dwarf2_per_cu_ptr, tu_group->tus, i, iter);
d5159 1
a5159 1
  VEC_free (dwarf2_per_cu_ptr, tu_group->tus);
d6789 2
a6790 2
     of it with end_symtab.  Otherwise, complete the addition of this TU's
     symbols to the existing symtab.  */
d7729 1
a7729 1
    per_cu->s.type_unit_group = get_type_unit_group (per_cu, attr);
@


1.685
log
@gdb/
	* dwarf2read.c (read_call_site_scope): Do not gdb_assert for invalid
	read-in CALL_SITE_PARAMETER_PARAM_OFFSET.
@
text
@d6596 1
d6627 11
a6637 1
  symtab = end_symtab (highpc + baseaddr, objfile, SECT_OFF_TEXT (objfile));
@


1.684
log
@	PR gdb/13498
	* dwarf2read.c (dwarf2_per_objfile): New members n_type_unit_groups,
	all_type_unit_groups, type_unit_groups, tu_stats.
	(dwarf2_per_cu_data): Move "imported_symtabs" into new union "s".
	All uses updated.  Add type_unit_group to union "s".
	(type_unit_group): New struct.
	(IS_TYPE_UNIT_GROUP): New macro.
	(abbrev_table): Delete unused member "section".
	(dw2_do_instantiate_symtab): Early exit if type_unit_group.
	(dw2_get_cu): Assert not used with type_unit_group.
	(dw2_get_primary_cu): New function.
	(dw2_build_type_unit_groups_reader): New function.
	(dw2_build_type_unit_groups): New function.
	(dw2_get_file_names): Assert not called on type units.
	(dw2_map_symtabs_matching_filename): Call dw2_build_type_unit_groups.
	Redo loop to iterate over type unit groups instead of type units.
	(dw2_expand_symtabs_matching, dw2_map_symbol_filenames): Ditto.
	(read_abbrev_offset): New function.
	(init_cutu_and_read_dies): New arg "abbrev_table".  All callers
	updated.
	(create_partial_symtab): New function.
	(process_psymtab_comp_unit_reader): Assert not used with type units.
	Call create_partial_symtab.
	(process_psymtab_type_unit): Delete.
	(hash_type_unit_group, eq_type_unit_group): New functions.
	(allocate_type_unit_groups_table): New function.
	(NO_STMT_LIST_TYPE_UNIT_PSYMTAB): New macro.
	(NO_STMT_LIST_TYPE_UNIT_PSYMTAB_SIZE): New macro.
	(create_type_unit_group, get_type_unit_group): New functions.
	(tu_abbrev_offset): New struct.
	(sort_tu_by_abbrev_offset): New function.
	(add_type_unit_group_to_table): New function.
	(build_type_unit_groups): New function.
	(build_type_psymtabs_reader): New function.
	(build_type_psymtab_dependencies): New function.
	(build_type_psymtabs): Rewrite.
	(scan_partial_symbols): Flag an error if a DW_TAG_imported_unit
	is seen in a type unit.
	(process_queue): Move symtab expansion debugging printfs here.
	Call process_full_type_unit for type units.
	(compute_symtab_includes): Assert not called for type units.
	(process_cu_includes): Don't call compute_symtab_includes for
	type units.
	(process_full_type_unit): New function.
	(process_imported_unit_die): Flag an error if called for type units.
	(handle_DW_AT_stmt_list): Delete arg "want_line_info".  All callers
	updated.  Assert not called for type units.
	(read_file_scope): Call dwarf2_start_symtab.
	(setup_type_unit_groups): New function.
	(read_type_unit_scope): Rewrite.
	(abbrev_table_read_table): Initialize abbrev_table->offset.
	(abbrev_table_free_cleanup): New function.
	(dwarf2_start_symtab): New function.
	(load_full_type_unit): Assert not called for type unit groups.
@
text
@d8881 12
a8892 1
	  gdb_assert (offset.sect_off >= cu->header.offset.sect_off);
@


1.683
log
@	* dwarf2read.c (load_full_type_unit): Simplify.
@
text
@d217 10
a226 3
  /* A chain of compilation units that are currently read in, so that
     they can be freed later.  */
  struct dwarf2_per_cu_data *read_in_chain;
d232 14
d557 13
a569 5
  /* The CUs we import using DW_TAG_imported_unit.  This is filled in
     while reading psymtabs, used to compute the psymtab dependencies,
     and then cleared.  Then it is filled in again while reading full
     symbols, and only deleted when the objfile is destroyed.  */
  VEC (dwarf2_per_cu_ptr) *imported_symtabs;
d596 41
d877 2
a878 2
  /* Where the abbrev table came from.  */
  struct dwarf2_section_info *section;
d1178 2
d1230 3
d1281 3
d1468 5
d1537 3
d1571 2
a1572 1
  (struct dwarf2_per_cu_data *this_cu, int use_existing_cu, int keep,
a1580 2
static void process_psymtab_comp_unit (struct dwarf2_per_cu_data *, int);

d2114 5
d2157 12
a2168 1
/* Return the CU given its index.  */
d2175 2
d2178 3
a2180 1
      return &dwarf2_per_objfile->all_type_units[index]->per_cu;
d2182 32
d2614 35
d2733 4
d2748 2
a2749 1
    init_cutu_and_read_dies (this_cu, 0, 0, dw2_get_file_names_reader, NULL);
d2855 2
d2858 1
a2858 1
		   + dwarf2_per_objfile->n_type_units); ++i)
d2861 1
a2861 1
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
d3179 2
a3180 2
  init_cutu_and_read_dies (per_cu, 0, 0, dw2_get_primary_filename_reader,
			   &filename);
d3222 2
d3234 1
a3234 1
		       + dwarf2_per_objfile->n_type_units); ++i)
d3237 1
a3237 1
	  struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
d3407 2
d3425 1
a3425 1
		   + dwarf2_per_objfile->n_type_units); ++i)
d3428 1
a3428 1
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
d3727 20
d4082 4
d4097 1
d4217 8
a4224 1
  if (cu->abbrev_table == NULL)
d4356 10
a4365 2
      dwarf2_free_abbrev_table (cu);
      dwarf2_read_abbrevs (cu, dwo_abbrev_section);
d4520 26
d4571 2
a4582 7
  pst = start_psymtab_common (objfile, objfile->section_offsets,
			      filename,
			      /* TEXTLOW and TEXTHIGH are set below.  */
			      0,
			      objfile->global_psymbols.next,
			      objfile->static_psymbols.next);
  pst->psymtabs_addrmap_supported = 1;
d4584 3
a4590 2
  pst->read_symtab_private = per_cu;

a4592 5
  /* Store the function that reads in the rest of the symbol table.  */
  pst->read_symtab = dwarf2_psymtab_to_symtab;

  per_cu->v.psymtab = pst;

d4644 1
a4644 1
  if (!VEC_empty (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs))
d4647 1
a4647 1
      int len = VEC_length (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs);
d4656 1
a4656 1
	   VEC_iterate (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs,
d4661 1
a4661 1
      VEC_free (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs);
d4664 3
a4666 11
  if (per_cu->is_debug_types)
    {
      /* It's not clear we want to do anything with stmt lists here.
	 Waiting to see what gcc ultimately does.  */
    }
  else
    {
      /* Get the list of files included in the current compilation unit,
	 and build a psymtab for each of them.  */
      dwarf2_build_include_psymtabs (cu, comp_unit_die, pst);
    }
d4699 2
a4700 1
  init_cutu_and_read_dies (this_cu, 0, 0, process_psymtab_comp_unit_reader,
d4707 148
a4854 2
/* Traversal function for htab_traverse_noresize.
   Process one .debug_types comp-unit.	*/
d4857 44
a4900 1
process_psymtab_type_unit (void **slot, void *info)
d4902 162
a5063 2
  struct signatured_type *sig_type = (struct signatured_type *) *slot;
  struct dwarf2_per_cu_data *per_cu = &sig_type->per_cu;
d5065 1
a5065 2
  gdb_assert (per_cu->is_debug_types);
  gdb_assert (info == NULL);
d5067 10
a5076 7
  /* If this compilation unit was already read in, free the
     cached copy in order to read it in again.	This is
     necessary because we skipped some symbols when we first
     read in the compilation unit (see load_partial_dies).
     This problem could be avoided, but the benefit is unclear.  */
  if (per_cu->cu != NULL)
    free_one_cached_comp_unit (per_cu);
d5078 1
a5078 2
  init_cutu_and_read_dies (per_cu, 0, 0, process_psymtab_comp_unit_reader,
			   NULL);
d5080 12
a5091 2
  /* Age out any secondary CUs.  */
  age_cached_comp_units ();
d5105 5
a5109 2
  htab_traverse_noresize (dwarf2_per_objfile->signatured_types,
			  process_psymtab_type_unit, NULL);
d5225 2
a5226 1
  init_cutu_and_read_dies (this_cu, 1, 1, load_partial_comp_unit_reader, NULL);
d5365 8
d5380 2
a5381 2
		VEC_safe_push (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs,
			       per_cu);
d6166 24
a6189 1
	process_full_comp_unit (item->per_cu, item->pretend_language);
d6347 2
a6348 2
  init_cutu_and_read_dies (this_cu, 1, 1, load_full_comp_unit_reader,
			   &pretend_language);
d6511 1
a6511 1
       VEC_iterate (dwarf2_per_cu_ptr, per_cu->imported_symtabs, ix, iter);
d6522 3
a6524 1
  if (!VEC_empty (dwarf2_per_cu_ptr, per_cu->imported_symtabs))
d6540 1
a6540 1
	   VEC_iterate (dwarf2_per_cu_ptr, per_cu->imported_symtabs,
d6575 4
a6578 1
    compute_symtab_includes (iter);
a6596 8
  if (dwarf2_read_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "Expanding symtab of %s at offset 0x%x\n",
			  per_cu->is_debug_types ? "TU" : "CU",
			  per_cu->offset.sect_off);
    }

d6672 29
d6702 35
a6736 1
  if (dwarf2_read_debug)
d6738 3
a6740 4
      fprintf_unfiltered (gdb_stdlog,
			  "Done expanding symtab of %s at offset 0x%x\n",
			  per_cu->is_debug_types ? "TU" : "CU",
			  per_cu->offset.sect_off);
d6742 2
d6753 8
d6775 1
a6775 1
      VEC_safe_push (dwarf2_per_cu_ptr, cu->per_cu->imported_symtabs,
d7460 1
a7460 1
/* Cleanup function for read_file_scope.  */
d7511 2
a7512 2
/* Handle DW_AT_stmt_list for a compilation unit or type unit.
   DIE is the DW_TAG_compile_unit or DW_TAG_type_unit die for CU.
d7518 1
a7518 1
			const char *comp_dir, int want_line_info)
d7522 2
d7535 1
a7535 1
	  dwarf_decode_lines (line_header, comp_dir, cu, NULL, want_line_info);
d7581 1
a7581 8
  /* We assume that we're processing GCC output.  */
  processing_gcc_compilation = 2;

  processing_has_namespace_info = 0;

  start_symtab (name, comp_dir, lowpc);
  record_debugformat ("DWARF 2");
  record_producer (cu->producer);
d7586 1
a7586 1
  handle_DW_AT_stmt_list (die, cu, comp_dir, 1);
d7626 5
a7630 4
/* Process DW_TAG_type_unit.
   For TUs we want to skip the first top level sibling if it's not the
   actual type being defined by this TU.  In this case the first top
   level sibling is there to provide context only.  */
d7633 1
a7633 1
read_type_unit_scope (struct die_info *die, struct dwarf2_cu *cu)
d7635 5
a7639 3
  struct objfile *objfile = cu->objfile;
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
  CORE_ADDR lowpc;
d7641 3
a7643 4
  char *name = NULL;
  char *comp_dir = NULL;
  struct die_info *child_die;
  bfd *abfd = objfile->obfd;
d7645 1
a7645 3
  /* start_symtab needs a low pc, but we don't really have one.
     Do what read_file_scope would do in the absence of such info.  */
  lowpc = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d7647 11
a7657 5
  /* Find the filename.  Do not use dwarf2_name here, since the filename
     is not a source language identifier.  */
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr)
    name = DW_STRING (attr);
d7659 9
a7667 4
  attr = dwarf2_attr (die, DW_AT_comp_dir, cu);
  if (attr)
    comp_dir = DW_STRING (attr);
  else if (name != NULL && IS_ABSOLUTE_PATH (name))
d7669 9
a7677 3
      comp_dir = ldirname (name);
      if (comp_dir != NULL)
	make_cleanup (xfree, comp_dir);
d7680 6
a7685 2
  if (name == NULL)
    name = "<unknown>";
d7687 2
a7688 1
  prepare_one_comp_unit (cu, die, language_minimal);
d7690 4
a7693 2
  /* We assume that we're processing GCC output.  */
  processing_gcc_compilation = 2;
d7695 3
a7697 1
  processing_has_namespace_info = 0;
d7699 2
a7700 3
  start_symtab (name, comp_dir, lowpc);
  record_debugformat ("DWARF 2");
  record_producer (cu->producer);
d7702 9
a7710 5
  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.
     We don't need the pc/line-number mapping for type units.  */
  handle_DW_AT_stmt_list (die, cu, comp_dir, 0);
d7712 5
a7716 2
  /* Process the dies in the type unit.  */
  if (die->child == NULL)
d7718 8
a7725 3
      dump_die_for_error (die);
      error (_("Dwarf Error: Missing children for type unit [in module %s]"),
	     bfd_get_filename (abfd));
d7728 23
a7750 1
  child_die = die->child;
d7752 1
a7752 1
  while (child_die && child_die->tag)
d7754 6
a7759 3
      process_die (child_die, cu);

      child_die = sibling_die (child_die);
a7760 2

  do_cleanups (back_to);
d11910 1
d11997 15
d14371 17
d16303 3
d16368 2
a16369 1
  init_cutu_and_read_dies (per_cu, 0, 1, read_signatured_type_reader, NULL);
d18302 1
a18302 1
	      dwarf2_per_objfile->all_comp_units[ix]->imported_symtabs);
@


1.682
log
@	* dwarf2read.c (dwarf2_per_objfile): Change type of all_type_units
	to struct signatured_type **.  All uses updated.
@
text
@a15515 3
  struct objfile *objfile = per_cu->objfile;
  struct dwarf2_section_info *sect = per_cu->info_or_types_section;
  sect_offset offset = per_cu->offset;
d15518 4
a15521 1
  dwarf2_read_section (objfile, sect);
d15523 1
a15523 10
  /* We have the section offset, but we need the signature to do the
     hash table lookup.  */
  /* FIXME: This is sorta unnecessary, read_signatured_type only uses
     the signature to assert we found the right one.
     Ok, but it's a lot of work.  We should simplify things so any needed
     assert doesn't require all this clumsiness.  */
  sig_type = lookup_signatured_type_at_offset (objfile, sect, offset);

  gdb_assert (&sig_type->per_cu == per_cu);
  gdb_assert (sig_type->per_cu.cu == NULL);
d15527 1
a15527 1
  gdb_assert (sig_type->per_cu.cu != NULL);
@


1.681
log
@	* dwarf2read.c (dwarf2_attr_no_follow): Delete unused arg "cu".
	All callers updated.
@
text
@d215 1
a215 1
  struct dwarf2_per_cu_data **all_type_units;
d2075 1
a2075 1
      return dwarf2_per_objfile->all_type_units[index];
d2158 1
a2158 1
		     * sizeof (struct dwarf2_per_cu_data *));
d2189 1
a2189 1
      dwarf2_per_objfile->all_type_units[i / 3] = &sig_type->per_cu;
d3639 1
a3639 1
  struct dwarf2_per_cu_data ***datap = datum;
d3641 1
a3641 1
  **datap = &sigt->per_cu;
d3813 1
a3813 1
  struct dwarf2_per_cu_data **iter;
d3828 1
a3828 1
		     * sizeof (struct dwarf2_per_cu_data *));
@


1.680
log
@	* dwarf2read.c (dw2_expand_symtabs_matching): Fix typo.
@
text
@d1182 1
a1182 2
						unsigned int,
						struct dwarf2_cu *);
d9403 1
a9403 1
  attr = dwarf2_attr_no_follow (die, DW_AT_signature, cu);
d9730 1
a9730 1
  attr = dwarf2_attr_no_follow (die, DW_AT_signature, cu);
d12809 1
a12809 2
dwarf2_attr_no_follow (struct die_info *die, unsigned int name,
		       struct dwarf2_cu *cu)
@


1.679
log
@	* dwarf2read.c (maybe_queue_comp_unit): Move definition next to others
	related to queue management.
@
text
@d3127 1
a3127 1
			   + dwarf2_per_objfile->n_comp_units))
@


1.678
log
@	* dwarf2read.c (create_debug_types_hash_table): Use "debug dwarf2-read"
	instead of "debug dwarf2-die" in debugging printfs.
	(create_debug_info_hash_table_reader): Ditto.
	(create_debug_info_hash_table): Ditto.
	(init_dwo_file): Ditto.
	(init_cutu_and_read_dies): Add debugging printf.
	(init_cutu_and_read_dies_no_follow): Ditto.
	(process_psymtab_comp_unit_reader): Ditto.
@
text
@d5499 42
a15268 42
/* THIS_CU has a reference to PER_CU.  If necessary, load the new compilation
   unit and add it to our queue.
   The result is non-zero if PER_CU was queued, otherwise the result is zero
   meaning either PER_CU is already queued or it is already loaded.  */

static int
maybe_queue_comp_unit (struct dwarf2_cu *this_cu,
		       struct dwarf2_per_cu_data *per_cu,
		       enum language pretend_language)
{
  /* We may arrive here during partial symbol reading, if we need full
     DIEs to process an unusual case (e.g. template arguments).  Do
     not queue PER_CU, just tell our caller to load its DIEs.  */
  if (dwarf2_per_objfile->reading_partial_symbols)
    {
      if (per_cu->cu == NULL || per_cu->cu->dies == NULL)
	return 1;
      return 0;
    }

  /* Mark the dependence relation so that we don't flush PER_CU
     too early.  */
  dwarf2_add_dependence (this_cu, per_cu);

  /* If it's already on the queue, we have nothing to do.  */
  if (per_cu->queued)
    return 0;

  /* If the compilation unit is already loaded, just mark it as
     used.  */
  if (per_cu->cu != NULL)
    {
      per_cu->cu->last_used = 0;
      return 0;
    }

  /* Add it to the queue.  */
  queue_comp_unit (per_cu, pretend_language);

  return 1;
}

@


1.677
log
@	* dwarf2read.c (signatured_type): Make "per_cu" member first.
	(init_cutu_and_read_dies): Handle rereading a DWO CU while it's
	currently being read.  Propagate DW_AT_comp_dir to DWO DIE.

	testsuite/
	* gdb.dwarf2/fission-reread.S: New file.
	* gdb.dwarf2/fission-reread.exp: New file.
@
text
@d3670 5
a3699 4
      if (dwarf2_die_debug)
	fprintf_unfiltered (gdb_stdlog, "Reading signatured types for %s:\n",
			    bfd_get_filename (abfd));

d3793 1
a3793 1
	  if (dwarf2_die_debug)
d3912 5
d4238 5
d4436 14
d7165 1
a7165 1
  if (dwarf2_die_debug)
d7194 1
a7194 1
  if (dwarf2_die_debug)
d7315 1
a7315 1
  if (dwarf2_die_debug)
@


1.676
log
@	* dwarf2read.c (get_cu_length): New function.
	(offset_in_cu_p, error_check_comp_unit_head): Call it.
	(create_debug_types_hash_table): Ditto.
	(init_cutu_and_read_dies): Ditto.
	(init_cutu_and_read_dies_no_follow): Ditto.
@
text
@d547 5
a564 3

  /* The CU(/TU) of this type.  */
  struct dwarf2_per_cu_data per_cu;
d3856 2
d3906 4
d3925 9
a3933 1
      info_ptr += cu->header.first_die_offset.cu_off;
d3945 1
d3947 7
d3957 1
d3961 2
a3962 1
						    &signature, NULL);
d3964 6
a3969 8
	  /* There's no way to get from PER_CU to its containing
	     struct signatured_type.
	     But we have the signature so we can use that.  */
	  sig_type = lookup_signatured_type (signature);
	  /* We've already scanned all the signatured types,
	     this must succeed.  */
	  gdb_assert (sig_type != NULL);
	  gdb_assert (&sig_type->per_cu == this_cu);
d3972 2
a3973 1
	  /* LENGTH has not been set yet for type units.  */
d4001 3
a4003 1
     done.  */
d4009 5
d4026 1
a4026 1
      const char *comp_dir;
d4029 1
a4029 1
      struct attribute *stmt_list, *low_pc, *high_pc, *ranges;
a4042 1
      stmt_list = low_pc = high_pc = ranges = NULL;
d4046 1
d4052 1
d4083 3
a4085 4
      comp_dir = NULL;
      attr = dwarf2_attr (comp_unit_die, DW_AT_comp_dir, cu);
      if (attr)
	comp_dir = DW_STRING (attr);
d4088 1
a4088 1
	dwo_unit = lookup_dwo_type_unit (sig_type, dwo_name, comp_dir);
d4090 1
a4090 1
	dwo_unit = lookup_dwo_comp_unit (this_cu, dwo_name, comp_dir,
d4145 2
a4146 1
			 + (ranges != NULL));
d4160 2
@


1.675
log
@	* dwarf2read.c (dwarf2_find_base_address): Move definition.
@
text
@d3362 8
d3376 1
a3376 2
  sect_offset top = { (cu_header->offset.sect_off + cu_header->length
		       + cu_header->initial_length_size) };
d3470 1
a3470 2
  if (((unsigned long) header->offset.sect_off
       + header->length + header->initial_length_size)
d3723 1
a3723 1
	  length = header.initial_length_size + header.length;
d3729 1
a3729 1
	      info_ptr += header.initial_length_size + header.length;
d3949 1
a3949 1
	  this_cu->length = cu->header.length + cu->header.initial_length_size;
d3962 1
a3962 2
	  gdb_assert (this_cu->length
		      == cu->header.length + cu->header.initial_length_size);
d4087 1
a4087 2
	  gdb_assert (dwo_unit->length
		      == cu->header.length + cu->header.initial_length_size);
d4100 1
a4100 2
	  gdb_assert (dwo_unit->length
		      == cu->header.length + cu->header.initial_length_size);
d4211 1
a4211 1
  this_cu->length = cu.header.length + cu.header.initial_length_size;
@


1.674
log
@remove extraneous blank line
@
text
@d3374 31
a3865 31
/* Find the base address of the compilation unit for range lists and
   location lists.  It will normally be specified by DW_AT_low_pc.
   In DWARF-3 draft 4, the base address could be overridden by
   DW_AT_entry_pc.  It's been removed, but GCC still uses this for
   compilation units with discontinuous ranges.  */

static void
dwarf2_find_base_address (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  cu->base_known = 0;
  cu->base_address = 0;

  attr = dwarf2_attr (die, DW_AT_entry_pc, cu);
  if (attr)
    {
      cu->base_address = DW_ADDR (attr);
      cu->base_known = 1;
    }
  else
    {
      attr = dwarf2_attr (die, DW_AT_low_pc, cu);
      if (attr)
	{
	  cu->base_address = DW_ADDR (attr);
	  cu->base_known = 1;
	}
    }
}

@


1.673
log
@	* dwarf2read.c (ABBREV_HASH_SIZE): Remove enclosing #ifndef/#endif.
	(struct abbrev_table): Define.
	(dwarf2_cu): Replace members dwarf2_abbrevs, abbrev_obstack with
	abbrev_table.
	(init_cutu_and_read_dies): Update.
	(abbrev_table_alloc_abbrev): New function.  Replaces
	dwarf_alloc_abbrev.  All callers updated.
	(abbrev_table_add_abbrev): New function.
	(abbrev_table_lookup_abbrev): New function.  Replaces
	dwarf2_lookup_abbrev.  All callers updated.
	(abbrev_table_read_table): New function.  Contents moved here from
	dwarf2_read_abbrevs.
	(dwarf2_read_abbrevs): Call it.
	(abbrev_table_free): New function.
	(dwarf2_free_abbrev_table): Call it.
@
text
@a11144 1

@


1.672
log
@	* dwarf2read.c (dwarf2_cu): Add ranges_base.
	Delete have_addr_base, unused.  All uses updated.
	(init_cutu_and_read_dies): Process DW_AT_GNU_ranges_base.
	(dwarf2_get_pc_bounds): Add ranges_base.
	(dwarf2_record_block_ranges): Ditto.

	testsuite/
	* gdb.dwarf2/fission-base.c: New file.
	* gdb.dwarf2/fission-base.S: New file.
	* gdb.dwarf2/fission-base.exp: New file.
@
text
@a312 5
/* We hold several abbreviation tables in memory at the same time.  */
#ifndef ABBREV_HASH_SIZE
#define ABBREV_HASH_SIZE 121
#endif

d393 4
a396 5
  /* DWARF abbreviation table associated with this compilation unit.  */
  struct abbrev_info **dwarf2_abbrevs;

  /* Storage for the abbrev table.  */
  struct obstack abbrev_obstack;
d798 21
d1098 8
a1112 6
static struct abbrev_info *peek_die_abbrev (gdb_byte *, unsigned int *,
					    struct dwarf2_cu *);

static struct abbrev_info *dwarf2_lookup_abbrev (unsigned int,
						 struct dwarf2_cu *);

a1392 2
static struct abbrev_info *dwarf_alloc_abbrev (struct dwarf2_cu *);

d3969 4
a3972 2
  /* Read the abbrevs for this compilation unit into a table.  */
  if (cu->dwarf2_abbrevs == NULL)
d5188 1
a5188 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
d10943 1
a10943 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
d10980 2
d10983 1
a10983 1
/* In DWARF version 2, the description of the debugging information is
d10986 16
a11001 2
   in a hash table.  This function also sets flags in CU describing
   the data found in the abbrev table.  */
d11004 34
a11037 2
dwarf2_read_abbrevs (struct dwarf2_cu *cu,
		     struct dwarf2_section_info *abbrev_section)
d11039 3
d11043 3
a11045 2
  bfd *abfd = abbrev_section->asection->owner;
  struct comp_unit_head *cu_header = &cu->header;
d11049 1
a11049 1
  unsigned int abbrev_form, hash_number;
d11053 7
a11059 7
  /* Initialize dwarf2 abbrevs.  */
  obstack_init (&cu->abbrev_obstack);
  cu->dwarf2_abbrevs = obstack_alloc (&cu->abbrev_obstack,
				      (ABBREV_HASH_SIZE
				       * sizeof (struct abbrev_info *)));
  memset (cu->dwarf2_abbrevs, 0,
          ABBREV_HASH_SIZE * sizeof (struct abbrev_info *));
d11061 2
a11062 2
  dwarf2_read_section (cu->objfile, abbrev_section);
  abbrev_ptr = abbrev_section->buffer + cu_header->abbrev_offset.sect_off;
d11072 1
a11072 1
      cur_abbrev = dwarf_alloc_abbrev (cu);
d11104 1
a11104 1
      cur_abbrev->attrs = obstack_alloc (&cu->abbrev_obstack,
d11110 1
a11110 3
      hash_number = abbrev_number % ABBREV_HASH_SIZE;
      cur_abbrev->next = cu->dwarf2_abbrevs[hash_number];
      cu->dwarf2_abbrevs[hash_number] = cur_abbrev;
d11119 1
a11119 2
      if ((unsigned int) (abbrev_ptr - abbrev_section->buffer)
	  >= abbrev_section->size)
d11123 1
a11123 1
      if (dwarf2_lookup_abbrev (abbrev_number, cu) != NULL)
d11128 1
d11131 1
a11131 1
/* Release the memory used by the abbrev table for a compilation unit.  */
d11134 1
a11134 1
dwarf2_free_abbrev_table (void *ptr_to_cu)
d11136 9
a11144 1
  struct dwarf2_cu *cu = ptr_to_cu;
d11146 3
a11148 2
  obstack_free (&cu->abbrev_obstack, NULL);
  cu->dwarf2_abbrevs = NULL;
d11151 1
a11151 1
/* Lookup an abbrev_info structure in the abbrev hash table.  */
d11153 2
a11154 2
static struct abbrev_info *
dwarf2_lookup_abbrev (unsigned int number, struct dwarf2_cu *cu)
d11156 1
a11156 2
  unsigned int hash_number;
  struct abbrev_info *abbrev;
d11158 4
a11161 11
  hash_number = number % ABBREV_HASH_SIZE;
  abbrev = cu->dwarf2_abbrevs[hash_number];

  while (abbrev)
    {
      if (abbrev->number == number)
	return abbrev;
      else
	abbrev = abbrev->next;
    }
  return NULL;
d11163 1
a11163 1

a15806 11
static struct abbrev_info *
dwarf_alloc_abbrev (struct dwarf2_cu *cu)
{
  struct abbrev_info *abbrev;

  abbrev = (struct abbrev_info *)
    obstack_alloc (&cu->abbrev_obstack, sizeof (struct abbrev_info));
  memset (abbrev, 0, sizeof (struct abbrev_info));
  return (abbrev);
}

@


1.671
log
@	* dwarf2read.c (per_cu_header_read_in): Simplify, and handle
	type units.
@
text
@d462 7
a484 4

  /* Non-zero if DW_AT_addr_base was found.
     Used when processing DWO files.  */
  unsigned int have_addr_base : 1;
a4001 1
      cu->have_addr_base = 0;
d4004 8
a4011 4
	{
	  cu->addr_base = DW_UNSND (attr);
	  cu->have_addr_base = 1;
	}
d8258 2
d8262 1
a8262 1
	  if (!dwarf2_ranges_read (DW_UNSND (attr), &low, &high, cu, pst))
d8422 1
a8422 1
      unsigned long offset = DW_UNSND (attr);
@


1.670
log
@	* dwarf2read.c (read_and_check_comp_unit_head): Delete unnecessary
	prototype.
	(error_check_comp_unit_head): New arg abbrev_section.  All callers
	updated.
	(read_and_check_comp_unit_head): Ditto.
	(read_and_check_type_unit_head): Ditto.
@
text
@a16810 2
  struct objfile *objfile;
  struct dwarf2_per_objfile *per_objfile;
d16816 1
a16816 3
  objfile = per_cu->objfile;
  per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);
  info_ptr = per_objfile->info.buffer + per_cu->offset.sect_off;
d16819 1
a16819 1
  read_comp_unit_head (cu_headerp, info_ptr, objfile->obfd);
@


1.669
log
@	* dwarf2read.c (dwo_section_names): Add macinfo_dwo, macro_dwo.
	(dwo_sections): Add macinfo, macro.
	(dwarf2_locate_dwo_sections): Watch for macro sections.
	(dwarf_decode_macros): Remove args lh, abfd, section, section_name.
	All callers updated.  Handle DWO files.
@
text
@a1464 5
static gdb_byte *read_and_check_comp_unit_head
  (struct comp_unit_head *header,
   struct dwarf2_section_info *section, gdb_byte *info_ptr,
   int is_debug_types_section);

d3393 2
a3394 1
			    struct dwarf2_section_info *section)
d3430 1
d3448 1
a3448 1
  error_check_comp_unit_head (header, section);
d3459 1
d3483 1
a3483 1
  error_check_comp_unit_head (header, section);
d3604 1
d3609 4
d3664 2
a3665 1
	  ptr = read_and_check_type_unit_head (&header, section, ptr,
d3877 1
d3888 1
d3910 2
a3911 2
	  info_ptr = read_and_check_type_unit_head (&cu->header,
						    section, info_ptr,
d3933 3
a3935 2
	  info_ptr = read_and_check_comp_unit_head (&cu->header,
						    section, info_ptr, 0);
d3954 1
a3954 1
      dwarf2_read_abbrevs (cu, &dwarf2_per_objfile->abbrev);
d3974 1
d4046 1
d4053 3
a4055 2
	  info_ptr = read_and_check_type_unit_head (&cu->header,
						    section, info_ptr,
d4069 3
a4071 2
	  info_ptr = read_and_check_comp_unit_head (&cu->header,
						    section, info_ptr, 0);
d4079 1
a4079 1
      dwarf2_read_abbrevs (cu, &dwo_unit->dwo_file->sections.abbrev);
d4181 2
a4182 1
  info_ptr = read_and_check_comp_unit_head (&cu.header, section, info_ptr,
@


1.668
log
@	* NEWS: Mention new options "set debug dwarf2-read" and
	"set debug symtab-create".
	* dwarf2read.c (dwarf2_read_debug): New static global.
	(dwarf2_build_psymtabs_hard): Add debugging printfs.
	(process_queue): Ditto.
	(process_full_comp_unit): Ditto.
	(_initialize_dwarf2_read): Add new option "set debug dwarf2-read".
	* elfread.c (elf_symfile_read): Add debugging printf.
	* minsyms.c (install_minimal_symbols): Ditto.
	* psymtab.c (allocate_psymtab): Ditto.
	* symfile.c (allocate_symtab): Ditto.
	* symtab.c (symtab_create_debug): New global.
	(_initialize_symtab): Add new option "set debug symtab-create".
	* symtab.h (symtab_create_debug): Declare.

	doc/
	* gdb.texinfo (Debugging Output): Document debug options dwarf2-read
	and symtab-create.
@
text
@d292 2
d304 2
d576 2
d1377 2
a1378 4
static void dwarf_decode_macros (struct line_header *, unsigned int,
                                 char *, bfd *, struct dwarf2_cu *,
				 struct dwarf2_section_info *,
				 int, const char *);
d6779 1
a6779 4
      dwarf_decode_macros (cu->line_header, DW_UNSND (attr),
			   comp_dir, abfd, cu,
			   &dwarf2_per_objfile->macro, 1,
			   ".debug_macro");
d6788 1
a6788 4
	  dwarf_decode_macros (cu->line_header, macro_offset,
			       comp_dir, abfd, cu,
			       &dwarf2_per_objfile->macinfo, 0,
			       ".debug_macinfo");
d6975 10
d16434 2
a16435 5
dwarf_decode_macros (struct line_header *lh, unsigned int offset,
                     char *comp_dir, bfd *abfd,
                     struct dwarf2_cu *cu,
		     struct dwarf2_section_info *section,
		     int section_is_gnu, const char *section_name)
d16438 2
d16448 29
d16484 1
@


1.667
log
@	* dwarf2read.c (lookup_dwo_comp_unit): Enhance comment.
	(lookup_dwo_type_unit): Ditto.
@
text
@d85 4
d4457 6
d4496 4
d5404 7
d5426 6
d5821 8
d5904 8
d18324 9
@


1.666
log
@	PR 14125
	* NEWS: Document additions to .gdb_index.
	* dwarf2read.c: #include "gdb/gdb-index.h".
	(DW2_GDB_INDEX_SYMBOL_STATIC_SET_VALUE): New macro.
	(DW2_GDB_INDEX_SYMBOL_KIND_SET_VALUE): New macro.
	(DW2_GDB_INDEX_CU_SET_VALUE): New macro.
	(dwarf2_read_index): Recognize version 7.
	(dw2_do_expand_symtabs_matching): New args want_specific_block,
	block_kind, domain): All callers updated.
	(dw2_find_symbol_file): Handle new index CU values.
	(dw2_expand_symtabs_matching): Match symbol kind if requested.
	(add_index_entry): New args is_static, kind.  All callers updated.
	(offset_type_compare, uniquify_cu_indices): New functions
	(symbol_kind): New function.
	(write_psymtabs_to_index): Remove duplicate CU values.
	(write_psymtabs_to_index): Write .gdb_index version 7.

	doc/
	* gdb.texinfo (Index Section Format): Document version 7 format.

	include/gdb/
	* gdb-index.h: New file.
@
text
@d7219 1
a7219 1
   The result is the DWO CU or NULL if we didn't find it
d7258 1
a7258 1
   The result is the DWO CU or NULL if we didn't find it
@


1.665
log
@	* dwarf2expr.c (execute_stack_op): Handle DW_OP_GNU_const_index.
	Adjust address for DW_OP_GNU_addr_index.
	* dwarf2expr.h (dwarf_expr_context): Update comment.
	* dwarf2loc.c (locexpr_describe_location_piece): New arg per_cu,
	all callers updated.  Handle TLS vars described with
	DW_OP_GNU_const_index.
	(disassemble_dwarf_expression): Handle DW_OP_GNU_addr_index
	and DW_OP_GNU_const_index.
	* dwarf2read.c (decode_locdesc): Handle DW_OP_GNU_addr_index.
@
text
@d65 1
d126 22
d2376 1
a2376 1
  if (version > 6)
d2742 2
a2743 1
   named NAME.  */
d2746 4
a2749 1
dw2_do_expand_symtabs_matching (struct objfile *objfile, const char *name)
d2751 2
d2755 2
d2758 1
a2758 1
  if (dwarf2_per_objfile->index_table)
d2762 1
a2762 2
      if (find_slot_in_mapped_hash (dwarf2_per_objfile->index_table,
				    name, &vec))
d2767 2
a2768 1
	      offset_type cu_index = MAYBE_SWAP (vec[i + 1]);
d2770 36
d2818 1
a2818 1
  dw2_do_expand_symtabs_matching (objfile, name);
d2856 3
a2858 1
  dw2_do_expand_symtabs_matching (objfile, func_name);
d2973 1
a2973 1
  per_cu = dw2_get_cu (MAYBE_SWAP (vec[1]));
d3097 32
d3130 1
a3130 1
	  per_cu = dw2_get_cu (MAYBE_SWAP (vec[vec_idx + 1]));
d17521 3
a17523 2
/* Add an entry to SYMTAB.  NAME is the name of the symbol.  CU_INDEX
   is the index of the CU in which the symbol appears.  */
d17527 1
d17531 1
d17542 1
d17545 67
a17611 5
  /* Don't push an index twice.  Due to how we add entries we only
     have to check the last one.  */ 
  if (VEC_empty (offset_type, (*slot)->cu_indices)
      || VEC_last (offset_type, (*slot)->cu_indices) != cu_index)
    VEC_safe_push (offset_type, (*slot)->cu_indices, cu_index);
d17825 38
d17875 2
a17876 1
      void **slot, *lookup;
d17878 1
a17878 1
      if (SYMBOL_LANGUAGE (*psymp) == language_ada)
a17880 12
      /* We only want to add a given psymbol once.  However, we also
	 want to account for whether it is global or static.  So, we
	 may add it twice, using slightly different values.  */
      if (is_static)
	{
	  uintptr_t val = 1 | (uintptr_t) *psymp;

	  lookup = (void *) val;
	}
      else
	lookup = *psymp;

d17882 1
a17882 1
      slot = htab_find_slot (psyms_seen, lookup, INSERT);
d17885 5
a17889 2
	  *slot = lookup;
	  add_index_entry (symtab, SYMBOL_SEARCH_NAME (*psymp), cu_index);
d18112 4
d18128 1
a18128 1
  val = MAYBE_SWAP (6);
@


1.664
log
@gdb/
	* dwarf2expr.c (execute_stack_op): Support DW_OP_GNU_parameter_ref.
	* dwarf2loc.c (call_site_parameter_matches): Support
	CALL_SITE_PARAMETER_PARAM_OFFSET.
	(needs_dwarf_reg_entry_value): Push stub value.
	* dwarf2read.c (read_call_site_scope): New variable origin.  Support
	CALL_SITE_PARAMETER_PARAM_OFFSET and its DW_AT_abstract_origin.
	* gdbtypes.h (enum call_site_parameter_kind): New item
	CALL_SITE_PARAMETER_PARAM_OFFSET.
	(struct call_site.parameter.u): New field param_offset.

gdb/testsuite/
	* gdb.arch/amd64-entry-value-param.S: New file.
	* gdb.arch/amd64-entry-value-param.c: New file.
	* gdb.arch/amd64-entry-value-param.exp: New file.
@
text
@d15515 1
@


1.663
log
@gdb/
	Code cleanup: Generalize call_site.parameter key.
	* dwarf2expr.c (execute_stack_op) <DW_OP_GNU_entry_value>: Remove
	variable dwarf_reg.  New variable kind_u.  Update parameters to
	push_dwarf_reg_entry_value.
	(ctx_no_push_dwarf_reg_entry_value): Update parameters.
	* dwarf2expr.h (enum call_site_parameter_kind)
	(union call_site_parameter_u): Forward declarations.
	(struct dwarf_expr_context_funcs): Update parameters and their
	description for push_dwarf_reg_entry_value.
	(ctx_no_push_dwarf_reg_entry_value): Update parameters.
	* dwarf2loc.c (call_site_parameter_matches): New function.
	(dwarf_expr_reg_to_entry_parameter): Update parameters and their
	description.  Use call_site_parameter_matches.
	(dwarf_expr_push_dwarf_reg_entry_value, value_of_dwarf_reg_entry):
	Update parameters and their description.
	(value_of_dwarf_block_entry): Remove variables dwarf_reg and fb_offset.
	New variable kind_u.  Adjust the caller for updated parameters.
	(needs_dwarf_reg_entry_value): Update parameters.
	* dwarf2read.c (read_call_site_scope): New variable loc.  Use it
	instead of attr.  Update for the changed fields of struct
	call_site_parameter.
	* gdbtypes.h: Include dwarf2expr.h.
	(enum call_site_parameter_kind): New.
	(struct call_site.parameter): New field kind.  Wrap dwarf_reg and
	fb_offset into new union u.
@
text
@d7815 1
a7815 1
      struct attribute *loc;
d7826 3
a7828 2
      /* DW_AT_location specifies the register number.  Value of the data
	 assumed for the register is contained in DW_AT_GNU_call_site_value.  */
d7831 12
a7842 1
      if (loc == NULL || !attr_form_is_block (loc))
@


1.662
log
@	* dwarf2read.c (dw2_find_symbol_file): Unconditionally use
	init_cutu_and_read_dies.
testsuite
	* gdb.cp/namespace.exp: Add "show lang" test.
@
text
@d7815 1
d7829 2
a7830 2
      attr = dwarf2_attr (child_die, DW_AT_location, cu);
      if (!attr || !attr_form_is_block (attr))
d7838 1
a7838 6
      parameter->dwarf_reg = dwarf_block_to_dwarf_reg (DW_BLOCK (attr)->data,
				 &DW_BLOCK (attr)->data[DW_BLOCK (attr)->size]);
      if (parameter->dwarf_reg == -1
	  && !dwarf_block_to_sp_offset (gdbarch, DW_BLOCK (attr)->data,
				  &DW_BLOCK (attr)->data[DW_BLOCK (attr)->size],
					&parameter->fb_offset))
d7840 18
a7857 6
	  complaint (&symfile_complaints,
		     _("Only single DW_OP_reg or DW_OP_fbreg is supported "
		       "for DW_FORM_block* DW_AT_location for "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->offset.sect_off, objfile->name);
	  continue;
@


1.661
log
@	* dwarf2read.c (dw2_get_file_names_reader): Ignore partial units.
@
text
@d2909 2
a2910 6
  if (per_cu->is_debug_types)
    init_cutu_and_read_dies (per_cu, 0, 0, dw2_get_primary_filename_reader,
			     &filename);
  else
    init_cutu_and_read_dies_simple (per_cu, dw2_get_primary_filename_reader,
				    &filename);
@


1.660
log
@	* dwarf2read.c (dw2_get_primary_filename_reader): New function.
	(dw2_find_symbol_file): Use it.
@
text
@d2452 8
@


1.659
log
@	* dwarf2read.c (dwarf2_cu): Add comment.
@
text
@d2839 21
d2866 1
d2898 9
a2906 4
  file_data = dw2_get_file_names (objfile, per_cu);
  if (file_data == NULL
      || file_data->num_file_names == 0)
    return NULL;
d2908 1
a2908 1
  return file_data->file_names[file_data->num_file_names - 1];
@


1.658
log
@	* objfiles.h (ALL_OBJFILE_PRIMARY_SYMTABS): New macro.
	(ALL_PRIMARY_SYMTABS): Use it.
	(ALL_PSPACE_PRIMARY_SYMTABS): Ditto.
	* dwarf2read.c (dw2_find_symbol_file): Ditto.
	* linespec.c (iterate_over_all_matching_symtabs): Ditto.
	* symtab.c (lookup_symbol_aux_objfile): Ditto.
	(basic_lookup_transparent_type): Ditto.
@
text
@d415 9
a423 1
  /* Non-NULL if this CU came from a DWO file.  */
@


1.657
log
@bfd/
	* opncls.c (bfd_fopen): Always close fd on failure.
	(bfd_fdopenr): Likewise.
gdb/
	* symfile.c (symfile_bfd_open): Don't close desc if bfd_fopen
	fails.
	* solib.c (solib_bfd_fopen): Don't close fd if bfd_fopen fails.
	* exec.c (exec_file_attach): Don't close scratch_chan if bfd_fopen
	fails.
	* dwarf2read.c (try_open_dwo_file): Don't close fd if bfd_fopen
	fails.
@
text
@d2845 5
a2849 6
      ALL_OBJFILE_SYMTABS (objfile, s)
	if (s->primary)
	  {
	    struct blockvector *bv = BLOCKVECTOR (s);
	    const struct block *block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	    struct symbol *sym = lookup_block_symbol (block, name, VAR_DOMAIN);
d2851 3
a2853 3
	    if (sym)
	      return sym->symtab->filename;
	  }
@


1.656
log
@gdb/
	PR symtab/13277: Resolving opaque structures in ICC generated binaries.
	* dwarf2read.c (struct dwarf2_cu) <producer_is_icc>: New field.
	(producer_is_gxx_lt_4_6): Move the checking and caching to...
	(check_producer): ... this new function, which also checks for ICC
	and caches the result.
	(producer_is_icc): New function.
	(read_structure_type): Don't set TYPE_STUB_SUPPORTED if the
	producer was ICC.

gdb/testsuite/
	PR symtab/13277: Resolving opaque structures in ICC generated binaries.
	* gdb.dwarf2/dw2-icc-opaque.S: New file.
	* gdb.dwarf2/dw2-icc-opaque.exp: New file.
@
text
@a6959 1
      close (desc);
@


1.655
log
@	* dwarf2-frame.c (struct dwarf2_cie): Make initial_instructions, end
	"const gdb_byte *".
	(struct dwarf2_fde): Make instructions, end "const gdb_byte *".
	(execute_cfa_program): Update to match API of leb128 functions.
	(read_1_byte, read_4_bytes, read_8_bytes): Make buf parameter
	"const gdb_byte *".
	(read_unsigned_leb128, read_signed_leb128): Delete.
	(read_initial_length): Change type of buf argument to
	"const gdb_byte *".
	(read_encoded_value): Update to match API of leb128 functions.
	(decode_frame_entry): Change result to "const gdb_byte *", and
	similarly for "start" parameter.
	(decode_frame_entry_1): Ditto.  Use new leb128 reader functions.
	(dwarf2_build_frame_info): Change local frame_ptr to
	"const gdb_byte *".
	* dwarf2expr.c (safe_read_uleb128, safe_read_sleb128): Replaces
	read_uleb128, read_sleb128.  All callers updated.
	(safe_skip_leb128): New function.
	(dwarf_block_to_dwarf_reg): Update to match API of leb128 functions.
	Call gdb_read_uleb128, gdb_skip_leb128 instead of read_uleb128.
	(dwarf_block_to_dwarf_reg_deref): Update to match API of leb128
	functions.  Call gdb_read_uleb128, gdb_read_sleb128 instead of
	read_uleb128, read_sleb128.
	(dwarf_block_to_fb_offset, dwarf_block_to_sp_offset): Ditto.
	(execute_stack_op): Update to match API of leb128 functions.
	* dwarf2expr.h: #include "leb128.h".
	(read_uleb128, read_sleb128): Delete.
	(gdb_read_uleb128, gdb_read_sleb128, gdb_skip_leb128): New functions.
	(safe_read_uleb128, safe_read_sleb128, safe_skip_leb128): Declare.
	* dwarf2loc.c (debug_loc_kind): New enum.
	(decode_debug_loc_addresses): New function.
	(decode_debug_loc_dwo_addresses): New function.
	(dwarf2_find_location_expression): Rewrite.
	(dwarf2_compile_expr_to_ax): Update to match API of leb128 functions.
	(locexpr_describe_location_piece): Ditto.
	(disassemble_dwarf_expression): Ditto.
	(locexpr_describe_location_1): Ditto.
	(loclist_describe_location): Rewrite.
	* dwarf2loc.h (dwarf2_loclist_baton): New member "from_dwo".
	* dwarf2read.c (die_reader_specs): New member "buffer_end".
	(dwarf2_section_buffer_overflow_complaint): Renamed from
	dwarf2_macros_too_long_complaint.  All callers updated.
	(skip_leb128): Delete.
	(init_cu_die_reader): Initialize reader->buffer_end.
	(skip_one_die): Replace call to skip_leb128 with safe_skip_leb128.
	(skip_form_bytes): New arg buffer_end.  All callers updated.
	Replace call to skip_leb128 with gdb_skip_leb128.
	(skip_unknown_opcode): New arg mac_end.  All callers updated.
	(fill_in_loclist_baton): Initialize baton->from_dwo.
@
text
@d432 4
a435 4
  /* These cache the results of producer_is_gxx_lt_4_6.
     CHECKED_PRODUCER is set if PRODUCER_IS_GXX_LT_4_6 is valid.  This
     information is cached because profiling CU expansion showed
     excessive time spent in producer_is_gxx_lt_4_6.  */
d438 1
d8275 2
a8276 3
/* Check for GCC PR debug/45124 fix which is not present in any G++ version up
   to 4.5.any while it is present already in G++ 4.6.0 - the PR has been fixed
   during 4.6.0 experimental.  */
d8278 2
a8279 2
static int
producer_is_gxx_lt_4_6 (struct dwarf2_cu *cu)
a8282 1
  int result = 0;
a8293 2

      return 0;
d8295 3
a8298 12
  if (cu->checked_producer)
    return cu->producer_is_gxx_lt_4_6;

  /* Skip any identifier after "GNU " - such as "C++" or "Java".  */

  if (strncmp (cu->producer, "GNU ", strlen ("GNU ")) != 0)
    {
      /* For non-GCC compilers expect their behavior is DWARF version
	 compliant.  */
    }
  else
    {
d8307 8
a8314 1
	result = major < 4 || (major == 4 && minor < 6);
d8318 5
a8322 1
  cu->producer_is_gxx_lt_4_6 = result;
d8324 7
a8330 1
  return result;
d9013 12
d9127 8
a9134 1
  TYPE_STUB_SUPPORTED (type) = 1;
@


1.654
log
@	* dwarf2read.c (recursively_find_pc_sect_symtab): Initialize "s"
	before use.  Check for symtab->includes == NULL before scanning it.
@
text
@d609 3
d974 1
a974 1
dwarf2_macros_too_long_complaint (struct dwarf2_section_info *section)
d977 4
a980 2
	     _("macro info runs off end of `%s' section"),
	     section->asection->name);
a1111 2
static gdb_byte *skip_leb128 (bfd *, gdb_byte *);

d3662 1
d5041 2
d5121 1
a5121 1
	  info_ptr = skip_leb128 (abfd, info_ptr);
a12281 16
/* Return a pointer to just past the end of an LEB128 number in BUF.  */

static gdb_byte *
skip_leb128 (bfd *abfd, gdb_byte *buf)
{
  int byte;

  while (1)
    {
      byte = bfd_get_8 (abfd, buf);
      buf++;
      if ((byte & 128) == 0)
	return buf;
    }
}

d15776 1
a15776 1
skip_form_bytes (bfd *abfd, gdb_byte *bytes,
d15831 6
a15836 1
      bytes = skip_leb128 (abfd, bytes);
d15860 1
a15860 1
		     gdb_byte *mac_ptr,
d15883 2
a15884 1
      mac_ptr = skip_form_bytes (abfd, mac_ptr, defn[i], offset_size, section);
d15995 1
a15995 1
	  dwarf2_macros_too_long_complaint (section);
d16122 1
a16122 1
		      dwarf2_macros_too_long_complaint (section);
d16190 1
a16190 1
					 mac_ptr, abfd, offset_size,
d16333 1
a16333 1
					 mac_ptr, abfd, offset_size,
d16449 1
@


1.653
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d3006 3
d3011 1
a3011 1
      struct symtab *s;
@


1.652
log
@	* psymtab.c (find_pc_sect_symtab_from_partial): Return the symtab
	directly corresponding to the found psymtab.
	* dwarf2read.c (recursively_find_pc_sect_symtab): New function.
	(dw2_find_pc_sect_symtab): Use it.
	* block.h (blockvector_contains_pc): Declare.
	* block.c (find_block_in_blockvector): New function.
	(blockvector_for_pc_sect): Use it.
	(blockvector_contains_pc): New function.
@
text
@a2434 1
  unsigned int bytes_read;
a4070 1
  bfd *abfd = objfile->obfd;
a5292 1
  struct cleanup *back_to;
a5364 1
  struct attribute *attr;
a6940 1
  char *name;
a6979 1
  char *path_to_try, *debug_dir;
a7118 1
  struct dwo_unit find_dwo_tu, *dwo_tu;
a7766 1
      struct dwarf2_locexpr_baton *dlbaton;
a15176 1
  struct attribute *attr;
a17520 2
  offset_type cu_index;
  void **slot;
a17728 1
  char buf[8];
@


1.651
log
@2012-05-16  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* coffread.c (cs_section_address): Passing proper argument for
	`bfd_get_section_vma'.
	* dwarf2read.c (dwarf2_locate_sections): Likewise, for
	`bfd_get_section_flags'.
	* remote.c (remote_trace_set_readonly_regions): Likewise, for
	`bfd_get_section_vma'.
@
text
@d2995 24
d3027 1
d3042 3
a3044 1
  return dw2_instantiate_symtab (data);
@


1.650
log
@	PR macros/13205:
	* macrotab.h: (macro_define_special): Declare.
	(enum macro_special_kind): New.
	(struct macro_definition) <argc, replacement>: Update comments.
	* macrotab.c (new_macro_definition): Unconditionally set 'argc'.
	(macro_define_object_internal): New function.
	(macro_define_object): Use it.
	(macro_define_special): New function.
	(fixup_definition): New function.
	(macro_lookup_definition, foreach_macro_in_scope)
	(foreach_macro): Use fixup_definition.
	* macroexp.h (macro_stringify): Declare.
	* macroexp.c (free_buffer_return_text): New function.
	(stringify): Constify "arg".
	(macro_stringify): New function.
	* dwarf2read.c (macro_start_file): Call macro_define_special.
testsuite
	* gdb.base/macscp1.c (macscp_expr): Add comment.
	* gdb.base/macscp.exp: Test __FILE__ and __LINE__.
@
text
@d1585 1
a1585 1
      flagword aflag = bfd_get_section_flags (ignore_abfd, sectp);
@


1.649
log
@	* dwarf2read.c (recursively_write_psymbols): New function.
	(write_psymtabs_to_index): Use it.

	* dwarf2read.c (struct dwarf2_queue_item) <pretend_language>: New
	field.
	(load_cu, dw2_do_instantiate_symtab, process_psymtab_comp_unit)
	(load_partial_comp_unit): Update.
	(queue_comp_unit): Add argument 'pretend_language'.
	(process_queue): Update.
	(psymtab_to_symtab_1): Skip dependencies that have a user.
	(load_partial_comp_unit_reader): Give meaning to the 'data'
	argument.
	(load_full_comp_unit): Add 'pretend_language' argument.
	(process_full_comp_unit): Add 'pretend_language' argument.  Set
	language on CU.
	(process_imported_unit_die, read_file_scope, read_type_unit_scope):
	Update.
	(maybe_queue_comp_unit): Add 'pretend_language' argument.
	(follow_die_offset, follow_die_sig, read_signatured_type_reader):
	Update.
	(prepare_one_comp_unit): Add 'pretend_language' argument.

	* dwarf2read.c: (dwarf2_per_cu_ptr): New typedef.
	(struct dwarf2_per_objfile) <just_read_cus>: New field.
	(struct dwarf2_per_cu_data) <imported_symtabs>: New field.
	(dw2_do_instantiate_symtab): Check whether symtab was read in
	before queueing.
	(dw2_instantiate_symtab): Add assertion.  Call
	process_cu_includes.
	(process_psymtab_comp_unit): Compute 'dependencies' for psymtab.
	(partial_symtab_p): New typedef.
	(set_partial_user): New function.
	(dwarf2_build_psymtabs_hard): Use set_partial_user.
	(scan_partial_symbols): Add imported CU to imported_symtabs.
	(dwarf2_psymtab_to_symtab): Call process_cu_includes.
	(psymtab_to_symtab_1): Do nothing if psymtab is readin.
	(get_symtab, recursively_compute_inclusions)
	(compute_symtab_includes, process_cu_includes)
	(process_imported_unit_die): New functions.
	(process_die) <DW_TAG_imported_unit>: New case.
	(dwarf2_per_objfile_free): Free 'imported_symtabs'.

	* dwarf2read.c (struct dwarf2_per_cu_data) <psymtab>: Update
	comment.
	(struct partial_die_info) <locdesc>: Remove.
	<d>: New field.
	(process_psymtab_comp_unit): Add 'read_partial' argument.
	Update.
	(process_type_comp_unit, dwarf2_build_psymtabs_hard): Update.
	(scan_partial_symbols): Handle DW_TAG_imported_unit.
	(add_partial_symbol): Update.
	(process_die): Handle DW_TAG_partial_unit.
	(read_file_scope): Update comment.
	(load_partial_dies): Handle DW_TAG_imported_unit.
	(read_partial_die): Handle DW_TAG_partial_unit, DW_AT_import.
	(determine_prefix, dwarf2_name): Handle DW_TAG_partial_unit.
@
text
@d15575 6
a15580 3
    /* If we have no current file, then this must be the start_file
       directive for the compilation unit's main source file.  */
    current_file = macro_set_main (pending_macros, full_name);
@


1.648
log
@	* dwarf2read.c (dwarf_tag_name): Return const char *.  Use
	get_DW_TAG_name.
	(dwarf_attr_name): Return const char *.  Use get_DW_AT_name.
	(dwarf_form_name): Return const char *.  Use get_DW_FORM_name.
	(dwarf_stack_op_name): Remove.
	(dwarf_cfi_name): Return const char *.  Use get_DW_ATE_name.
	(decode_locdesc): Use get_DW_OP_name.
	* dwarf2loc.c (unimplemented): Use get_DW_OP_name.
	(dwarf2_compile_expr_to_ax): Likewise.
	(disassemble_dwarf_expression): Likewise.
	* dwarf2expr.h: (dwarf_stack_op_name): Remove.
@
text
@d151 3
d227 3
d492 1
a492 2
       or NULL for partial units (which do not have an associated
       symtab).  */
d498 6
d709 9
a717 2
    /* The location description associated with this DIE, if any.  */
    struct dwarf_block *locdesc;
d908 1
d1368 2
a1369 1
				   struct die_info *comp_unit_die);
d1386 2
a1387 1
static void load_full_comp_unit (struct dwarf2_per_cu_data *);
d1389 2
a1390 1
static void process_full_comp_unit (struct dwarf2_per_cu_data *);
d1406 6
a1411 1
static void queue_comp_unit (struct dwarf2_per_cu_data *per_cu);
d1437 1
a1437 1
static void process_psymtab_comp_unit (struct dwarf2_per_cu_data *);
d1451 2
d1958 1
a1958 1
    load_full_comp_unit (per_cu);
d1974 7
a1980 3
  queue_comp_unit (per_cu);

  load_cu (per_cu);
d1998 1
d2004 1
d4052 1
d4054 3
a4056 1
  if (comp_unit_die->tag == DW_TAG_partial_unit)
d4059 1
a4059 1
  prepare_one_comp_unit (cu, comp_unit_die);
d4141 20
d4178 2
a4179 1
process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu)
d4191 1
a4191 1
			   NULL);
d4249 22
d4304 1
a4304 1
      process_psymtab_comp_unit (per_cu);
d4307 2
d4327 1
a4327 1
  prepare_one_comp_unit (cu, comp_unit_die);
d4436 2
a4437 1
	  || pdi->tag == DW_TAG_module || pdi->tag == DW_TAG_enumeration_type)
d4477 15
d4700 2
a4701 2
      if (pdi->locdesc)
	addr = decode_locdesc (pdi->locdesc, cu);
d4703 1
a4703 1
      if (pdi->locdesc
d4727 1
a4727 1
	  if (pdi->locdesc || pdi->has_type)
d4738 1
a4738 1
	  if (pdi->locdesc == NULL)
d5181 2
d5190 2
a5191 1
queue_comp_unit (struct dwarf2_per_cu_data *per_cu)
d5198 1
d5223 1
a5223 1
	process_full_comp_unit (item->per_cu);
d5271 3
d5275 2
a5276 1
    if (!pst->dependencies[i]->readin)
d5342 1
d5366 1
a5366 1
  prepare_one_comp_unit (cu, cu->dies);
d5372 2
a5373 1
load_full_comp_unit (struct dwarf2_per_cu_data *this_cu)
d5377 2
a5378 1
  init_cutu_and_read_dies (this_cu, 1, 1, load_full_comp_unit_reader, NULL);
d5503 105
d5612 2
a5613 1
process_full_comp_unit (struct dwarf2_per_cu_data *per_cu)
d5630 3
d5693 3
d5699 26
d5735 1
d5804 5
d6483 1
a6483 1
/* Process DW_TAG_compile_unit.  */
d6512 1
a6512 1
  prepare_one_comp_unit (cu, die);
d6622 1
a6622 1
  prepare_one_comp_unit (cu, die);
d10945 2
a10946 1
	  && abbrev->tag != DW_TAG_member)
d11164 1
d11209 1
a11209 1
	       part_die->locdesc = DW_BLOCK (&attr);
d11278 6
d14286 1
d14407 1
d14441 2
a14442 1
	  while (die->tag != DW_TAG_compile_unit);
d14839 2
a14840 1
		       struct dwarf2_per_cu_data *per_cu)
d14869 1
a14869 1
  queue_comp_unit (per_cu);
d14928 2
a14929 2
      if (maybe_queue_comp_unit (cu, per_cu))
	load_full_comp_unit (per_cu);
d14937 1
a14937 1
      load_full_comp_unit (cu->per_cu);
d15069 1
a15069 1
  if (maybe_queue_comp_unit (*ref_cu, &sig_type->per_cu))
d15182 1
a15182 1
  prepare_one_comp_unit (cu, cu->dies);
d16648 2
a16649 1
prepare_one_comp_unit (struct dwarf2_cu *cu, struct die_info *comp_unit_die)
d16659 1
a16659 1
      cu->language = language_minimal;
d17103 4
d17667 29
d17780 2
a17781 10
      write_psymbols (symtab,
		      psyms_seen,
		      objfile->global_psymbols.list + psymtab->globals_offset,
		      psymtab->n_global_syms, i,
		      0);
      write_psymbols (symtab,
		      psyms_seen,
		      objfile->static_psymbols.list + psymtab->statics_offset,
		      psymtab->n_static_syms, i,
		      1);
@


1.647
log
@* dwarf2read.c (dw2_find_symbol_file): Don't crash if there are no files.
@
text
@d1255 1
a1255 1
static char *dwarf_tag_name (unsigned int);
d1257 1
a1257 1
static char *dwarf_attr_name (unsigned int);
d1259 1
a1259 1
static char *dwarf_form_name (unsigned int);
d1263 1
a1263 5
static char *dwarf_type_encoding_name (unsigned int);

#if 0
static char *dwarf_cfi_name (unsigned int);
#endif
d14265 1
a14265 1
static char *
d14268 6
a14273 149
  switch (tag)
    {
    case DW_TAG_padding:
      return "DW_TAG_padding";
    case DW_TAG_array_type:
      return "DW_TAG_array_type";
    case DW_TAG_class_type:
      return "DW_TAG_class_type";
    case DW_TAG_entry_point:
      return "DW_TAG_entry_point";
    case DW_TAG_enumeration_type:
      return "DW_TAG_enumeration_type";
    case DW_TAG_formal_parameter:
      return "DW_TAG_formal_parameter";
    case DW_TAG_imported_declaration:
      return "DW_TAG_imported_declaration";
    case DW_TAG_label:
      return "DW_TAG_label";
    case DW_TAG_lexical_block:
      return "DW_TAG_lexical_block";
    case DW_TAG_member:
      return "DW_TAG_member";
    case DW_TAG_pointer_type:
      return "DW_TAG_pointer_type";
    case DW_TAG_reference_type:
      return "DW_TAG_reference_type";
    case DW_TAG_compile_unit:
      return "DW_TAG_compile_unit";
    case DW_TAG_string_type:
      return "DW_TAG_string_type";
    case DW_TAG_structure_type:
      return "DW_TAG_structure_type";
    case DW_TAG_subroutine_type:
      return "DW_TAG_subroutine_type";
    case DW_TAG_typedef:
      return "DW_TAG_typedef";
    case DW_TAG_union_type:
      return "DW_TAG_union_type";
    case DW_TAG_unspecified_parameters:
      return "DW_TAG_unspecified_parameters";
    case DW_TAG_variant:
      return "DW_TAG_variant";
    case DW_TAG_common_block:
      return "DW_TAG_common_block";
    case DW_TAG_common_inclusion:
      return "DW_TAG_common_inclusion";
    case DW_TAG_inheritance:
      return "DW_TAG_inheritance";
    case DW_TAG_inlined_subroutine:
      return "DW_TAG_inlined_subroutine";
    case DW_TAG_module:
      return "DW_TAG_module";
    case DW_TAG_ptr_to_member_type:
      return "DW_TAG_ptr_to_member_type";
    case DW_TAG_set_type:
      return "DW_TAG_set_type";
    case DW_TAG_subrange_type:
      return "DW_TAG_subrange_type";
    case DW_TAG_with_stmt:
      return "DW_TAG_with_stmt";
    case DW_TAG_access_declaration:
      return "DW_TAG_access_declaration";
    case DW_TAG_base_type:
      return "DW_TAG_base_type";
    case DW_TAG_catch_block:
      return "DW_TAG_catch_block";
    case DW_TAG_const_type:
      return "DW_TAG_const_type";
    case DW_TAG_constant:
      return "DW_TAG_constant";
    case DW_TAG_enumerator:
      return "DW_TAG_enumerator";
    case DW_TAG_file_type:
      return "DW_TAG_file_type";
    case DW_TAG_friend:
      return "DW_TAG_friend";
    case DW_TAG_namelist:
      return "DW_TAG_namelist";
    case DW_TAG_namelist_item:
      return "DW_TAG_namelist_item";
    case DW_TAG_packed_type:
      return "DW_TAG_packed_type";
    case DW_TAG_subprogram:
      return "DW_TAG_subprogram";
    case DW_TAG_template_type_param:
      return "DW_TAG_template_type_param";
    case DW_TAG_template_value_param:
      return "DW_TAG_template_value_param";
    case DW_TAG_thrown_type:
      return "DW_TAG_thrown_type";
    case DW_TAG_try_block:
      return "DW_TAG_try_block";
    case DW_TAG_variant_part:
      return "DW_TAG_variant_part";
    case DW_TAG_variable:
      return "DW_TAG_variable";
    case DW_TAG_volatile_type:
      return "DW_TAG_volatile_type";
    case DW_TAG_dwarf_procedure:
      return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:
      return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:
      return "DW_TAG_interface_type";
    case DW_TAG_namespace:
      return "DW_TAG_namespace";
    case DW_TAG_imported_module:
      return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:
      return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:
      return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:
      return "DW_TAG_imported_unit";
    case DW_TAG_condition:
      return "DW_TAG_condition";
    case DW_TAG_shared_type:
      return "DW_TAG_shared_type";
    case DW_TAG_type_unit:
      return "DW_TAG_type_unit";
    case DW_TAG_MIPS_loop:
      return "DW_TAG_MIPS_loop";
    case DW_TAG_HP_array_descriptor:
      return "DW_TAG_HP_array_descriptor";
    case DW_TAG_format_label:
      return "DW_TAG_format_label";
    case DW_TAG_function_template:
      return "DW_TAG_function_template";
    case DW_TAG_class_template:
      return "DW_TAG_class_template";
    case DW_TAG_GNU_BINCL:
      return "DW_TAG_GNU_BINCL";
    case DW_TAG_GNU_EINCL:
      return "DW_TAG_GNU_EINCL";
    case DW_TAG_upc_shared_type:
      return "DW_TAG_upc_shared_type";
    case DW_TAG_upc_strict_type:
      return "DW_TAG_upc_strict_type";
    case DW_TAG_upc_relaxed_type:
      return "DW_TAG_upc_relaxed_type";
    case DW_TAG_PGI_kanji_type:
      return "DW_TAG_PGI_kanji_type";
    case DW_TAG_PGI_interface_block:
      return "DW_TAG_PGI_interface_block";
    case DW_TAG_GNU_call_site:
      return "DW_TAG_GNU_call_site";
    default:
      return "DW_TAG_<unknown>";
    }
d14278 1
a14278 1
static char *
d14281 2
a14282 198
  switch (attr)
    {
    case DW_AT_sibling:
      return "DW_AT_sibling";
    case DW_AT_location:
      return "DW_AT_location";
    case DW_AT_name:
      return "DW_AT_name";
    case DW_AT_ordering:
      return "DW_AT_ordering";
    case DW_AT_subscr_data:
      return "DW_AT_subscr_data";
    case DW_AT_byte_size:
      return "DW_AT_byte_size";
    case DW_AT_bit_offset:
      return "DW_AT_bit_offset";
    case DW_AT_bit_size:
      return "DW_AT_bit_size";
    case DW_AT_element_list:
      return "DW_AT_element_list";
    case DW_AT_stmt_list:
      return "DW_AT_stmt_list";
    case DW_AT_low_pc:
      return "DW_AT_low_pc";
    case DW_AT_high_pc:
      return "DW_AT_high_pc";
    case DW_AT_language:
      return "DW_AT_language";
    case DW_AT_member:
      return "DW_AT_member";
    case DW_AT_discr:
      return "DW_AT_discr";
    case DW_AT_discr_value:
      return "DW_AT_discr_value";
    case DW_AT_visibility:
      return "DW_AT_visibility";
    case DW_AT_import:
      return "DW_AT_import";
    case DW_AT_string_length:
      return "DW_AT_string_length";
    case DW_AT_common_reference:
      return "DW_AT_common_reference";
    case DW_AT_comp_dir:
      return "DW_AT_comp_dir";
    case DW_AT_const_value:
      return "DW_AT_const_value";
    case DW_AT_containing_type:
      return "DW_AT_containing_type";
    case DW_AT_default_value:
      return "DW_AT_default_value";
    case DW_AT_inline:
      return "DW_AT_inline";
    case DW_AT_is_optional:
      return "DW_AT_is_optional";
    case DW_AT_lower_bound:
      return "DW_AT_lower_bound";
    case DW_AT_producer:
      return "DW_AT_producer";
    case DW_AT_prototyped:
      return "DW_AT_prototyped";
    case DW_AT_return_addr:
      return "DW_AT_return_addr";
    case DW_AT_start_scope:
      return "DW_AT_start_scope";
    case DW_AT_bit_stride:
      return "DW_AT_bit_stride";
    case DW_AT_upper_bound:
      return "DW_AT_upper_bound";
    case DW_AT_abstract_origin:
      return "DW_AT_abstract_origin";
    case DW_AT_accessibility:
      return "DW_AT_accessibility";
    case DW_AT_address_class:
      return "DW_AT_address_class";
    case DW_AT_artificial:
      return "DW_AT_artificial";
    case DW_AT_base_types:
      return "DW_AT_base_types";
    case DW_AT_calling_convention:
      return "DW_AT_calling_convention";
    case DW_AT_count:
      return "DW_AT_count";
    case DW_AT_data_member_location:
      return "DW_AT_data_member_location";
    case DW_AT_decl_column:
      return "DW_AT_decl_column";
    case DW_AT_decl_file:
      return "DW_AT_decl_file";
    case DW_AT_decl_line:
      return "DW_AT_decl_line";
    case DW_AT_declaration:
      return "DW_AT_declaration";
    case DW_AT_discr_list:
      return "DW_AT_discr_list";
    case DW_AT_encoding:
      return "DW_AT_encoding";
    case DW_AT_external:
      return "DW_AT_external";
    case DW_AT_frame_base:
      return "DW_AT_frame_base";
    case DW_AT_friend:
      return "DW_AT_friend";
    case DW_AT_identifier_case:
      return "DW_AT_identifier_case";
    case DW_AT_macro_info:
      return "DW_AT_macro_info";
    case DW_AT_namelist_items:
      return "DW_AT_namelist_items";
    case DW_AT_priority:
      return "DW_AT_priority";
    case DW_AT_segment:
      return "DW_AT_segment";
    case DW_AT_specification:
      return "DW_AT_specification";
    case DW_AT_static_link:
      return "DW_AT_static_link";
    case DW_AT_type:
      return "DW_AT_type";
    case DW_AT_use_location:
      return "DW_AT_use_location";
    case DW_AT_variable_parameter:
      return "DW_AT_variable_parameter";
    case DW_AT_virtuality:
      return "DW_AT_virtuality";
    case DW_AT_vtable_elem_location:
      return "DW_AT_vtable_elem_location";
    /* DWARF 3 values.  */
    case DW_AT_allocated:
      return "DW_AT_allocated";
    case DW_AT_associated:
      return "DW_AT_associated";
    case DW_AT_data_location:
      return "DW_AT_data_location";
    case DW_AT_byte_stride:
      return "DW_AT_byte_stride";
    case DW_AT_entry_pc:
      return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:
      return "DW_AT_use_UTF8";
    case DW_AT_extension:
      return "DW_AT_extension";
    case DW_AT_ranges:
      return "DW_AT_ranges";
    case DW_AT_trampoline:
      return "DW_AT_trampoline";
    case DW_AT_call_column:
      return "DW_AT_call_column";
    case DW_AT_call_file:
      return "DW_AT_call_file";
    case DW_AT_call_line:
      return "DW_AT_call_line";
    case DW_AT_description:
      return "DW_AT_description";
    case DW_AT_binary_scale:
      return "DW_AT_binary_scale";
    case DW_AT_decimal_scale:
      return "DW_AT_decimal_scale";
    case DW_AT_small:
      return "DW_AT_small";
    case DW_AT_decimal_sign:
      return "DW_AT_decimal_sign";
    case DW_AT_digit_count:
      return "DW_AT_digit_count";
    case DW_AT_picture_string:
      return "DW_AT_picture_string";
    case DW_AT_mutable:
      return "DW_AT_mutable";
    case DW_AT_threads_scaled:
      return "DW_AT_threads_scaled";
    case DW_AT_explicit:
      return "DW_AT_explicit";
    case DW_AT_object_pointer:
      return "DW_AT_object_pointer";
    case DW_AT_endianity:
      return "DW_AT_endianity";
    case DW_AT_elemental:
      return "DW_AT_elemental";
    case DW_AT_pure:
      return "DW_AT_pure";
    case DW_AT_recursive:
      return "DW_AT_recursive";
    /* DWARF 4 values.  */
    case DW_AT_signature:
      return "DW_AT_signature";
    case DW_AT_linkage_name:
      return "DW_AT_linkage_name";
    /* Tentative Fission values.  */
    case DW_AT_GNU_dwo_name:
      return "DW_AT_GNU_dwo_name";
    case DW_AT_GNU_dwo_id:
      return "DW_AT_GNU_dwo_id";
    case DW_AT_GNU_addr_base:
      return "DW_AT_GNU_addr_base";
    case DW_AT_GNU_pubnames:
      return "DW_AT_GNU_pubnames";
    case DW_AT_GNU_pubtypes:
      return "DW_AT_GNU_pubtypes";
    /* SGI/MIPS extensions.  */
d14284 5
a14288 2
    case DW_AT_MIPS_fde:
      return "DW_AT_MIPS_fde";
d14290 7
a14296 84
    case DW_AT_MIPS_loop_begin:
      return "DW_AT_MIPS_loop_begin";
    case DW_AT_MIPS_tail_loop_begin:
      return "DW_AT_MIPS_tail_loop_begin";
    case DW_AT_MIPS_epilog_begin:
      return "DW_AT_MIPS_epilog_begin";
    case DW_AT_MIPS_loop_unroll_factor:
      return "DW_AT_MIPS_loop_unroll_factor";
    case DW_AT_MIPS_software_pipeline_depth:
      return "DW_AT_MIPS_software_pipeline_depth";
    case DW_AT_MIPS_linkage_name:
      return "DW_AT_MIPS_linkage_name";
    case DW_AT_MIPS_stride:
      return "DW_AT_MIPS_stride";
    case DW_AT_MIPS_abstract_name:
      return "DW_AT_MIPS_abstract_name";
    case DW_AT_MIPS_clone_origin:
      return "DW_AT_MIPS_clone_origin";
    case DW_AT_MIPS_has_inlines:
      return "DW_AT_MIPS_has_inlines";
    /* HP extensions.  */
#ifndef MIPS /* collides with DW_AT_MIPS_fde */
    case DW_AT_HP_block_index:
      return "DW_AT_HP_block_index";
#endif
    case DW_AT_HP_unmodifiable:
      return "DW_AT_HP_unmodifiable";
    case DW_AT_HP_actuals_stmt_list:
      return "DW_AT_HP_actuals_stmt_list";
    case DW_AT_HP_proc_per_section:
      return "DW_AT_HP_proc_per_section";
    case DW_AT_HP_raw_data_ptr:
      return "DW_AT_HP_raw_data_ptr";
    case DW_AT_HP_pass_by_reference:
      return "DW_AT_HP_pass_by_reference";
    case DW_AT_HP_opt_level:
      return "DW_AT_HP_opt_level";
    case DW_AT_HP_prof_version_id:
      return "DW_AT_HP_prof_version_id";
    case DW_AT_HP_opt_flags:
      return "DW_AT_HP_opt_flags";
    case DW_AT_HP_cold_region_low_pc:
      return "DW_AT_HP_cold_region_low_pc";
    case DW_AT_HP_cold_region_high_pc:
      return "DW_AT_HP_cold_region_high_pc";
    case DW_AT_HP_all_variables_modifiable:
      return "DW_AT_HP_all_variables_modifiable";
    case DW_AT_HP_linkage_name:
      return "DW_AT_HP_linkage_name";
    case DW_AT_HP_prof_flags:
      return "DW_AT_HP_prof_flags";
    /* GNU extensions.  */
    case DW_AT_sf_names:
      return "DW_AT_sf_names";
    case DW_AT_src_info:
      return "DW_AT_src_info";
    case DW_AT_mac_info:
      return "DW_AT_mac_info";
    case DW_AT_src_coords:
      return "DW_AT_src_coords";
    case DW_AT_body_begin:
      return "DW_AT_body_begin";
    case DW_AT_body_end:
      return "DW_AT_body_end";
    case DW_AT_GNU_vector:
      return "DW_AT_GNU_vector";
    case DW_AT_GNU_odr_signature:
      return "DW_AT_GNU_odr_signature";
    /* VMS extensions.  */
    case DW_AT_VMS_rtnbeg_pd_address:
      return "DW_AT_VMS_rtnbeg_pd_address";
    /* UPC extension.  */
    case DW_AT_upc_threads_scaled:
      return "DW_AT_upc_threads_scaled";
    /* PGI (STMicroelectronics) extensions.  */
    case DW_AT_PGI_lbase:
      return "DW_AT_PGI_lbase";
    case DW_AT_PGI_soffset:
      return "DW_AT_PGI_soffset";
    case DW_AT_PGI_lstride:
      return "DW_AT_PGI_lstride";
    default:
      return "DW_AT_<unknown>";
    }
d14301 1
a14301 1
static char *
d14304 1
a14304 60
  switch (form)
    {
    case DW_FORM_addr:
      return "DW_FORM_addr";
    case DW_FORM_block2:
      return "DW_FORM_block2";
    case DW_FORM_block4:
      return "DW_FORM_block4";
    case DW_FORM_data2:
      return "DW_FORM_data2";
    case DW_FORM_data4:
      return "DW_FORM_data4";
    case DW_FORM_data8:
      return "DW_FORM_data8";
    case DW_FORM_string:
      return "DW_FORM_string";
    case DW_FORM_block:
      return "DW_FORM_block";
    case DW_FORM_block1:
      return "DW_FORM_block1";
    case DW_FORM_data1:
      return "DW_FORM_data1";
    case DW_FORM_flag:
      return "DW_FORM_flag";
    case DW_FORM_sdata:
      return "DW_FORM_sdata";
    case DW_FORM_strp:
      return "DW_FORM_strp";
    case DW_FORM_udata:
      return "DW_FORM_udata";
    case DW_FORM_ref_addr:
      return "DW_FORM_ref_addr";
    case DW_FORM_ref1:
      return "DW_FORM_ref1";
    case DW_FORM_ref2:
      return "DW_FORM_ref2";
    case DW_FORM_ref4:
      return "DW_FORM_ref4";
    case DW_FORM_ref8:
      return "DW_FORM_ref8";
    case DW_FORM_ref_udata:
      return "DW_FORM_ref_udata";
    case DW_FORM_indirect:
      return "DW_FORM_indirect";
    case DW_FORM_sec_offset:
      return "DW_FORM_sec_offset";
    case DW_FORM_exprloc:
      return "DW_FORM_exprloc";
    case DW_FORM_flag_present:
      return "DW_FORM_flag_present";
    case DW_FORM_ref_sig8:
      return "DW_FORM_ref_sig8";
    case DW_FORM_GNU_addr_index:
      return "DW_FORM_GNU_addr_index";
    case DW_FORM_GNU_str_index:
      return "DW_FORM_GNU_str_index";
    default:
      return "DW_FORM_<unknown>";
    }
}
d14306 2
a14307 1
/* Convert a DWARF stack opcode into its string name.  */
d14309 1
a14309 341
const char *
dwarf_stack_op_name (unsigned op)
{
  switch (op)
    {
    case DW_OP_addr:
      return "DW_OP_addr";
    case DW_OP_deref:
      return "DW_OP_deref";
    case DW_OP_const1u:
      return "DW_OP_const1u";
    case DW_OP_const1s:
      return "DW_OP_const1s";
    case DW_OP_const2u:
      return "DW_OP_const2u";
    case DW_OP_const2s:
      return "DW_OP_const2s";
    case DW_OP_const4u:
      return "DW_OP_const4u";
    case DW_OP_const4s:
      return "DW_OP_const4s";
    case DW_OP_const8u:
      return "DW_OP_const8u";
    case DW_OP_const8s:
      return "DW_OP_const8s";
    case DW_OP_constu:
      return "DW_OP_constu";
    case DW_OP_consts:
      return "DW_OP_consts";
    case DW_OP_dup:
      return "DW_OP_dup";
    case DW_OP_drop:
      return "DW_OP_drop";
    case DW_OP_over:
      return "DW_OP_over";
    case DW_OP_pick:
      return "DW_OP_pick";
    case DW_OP_swap:
      return "DW_OP_swap";
    case DW_OP_rot:
      return "DW_OP_rot";
    case DW_OP_xderef:
      return "DW_OP_xderef";
    case DW_OP_abs:
      return "DW_OP_abs";
    case DW_OP_and:
      return "DW_OP_and";
    case DW_OP_div:
      return "DW_OP_div";
    case DW_OP_minus:
      return "DW_OP_minus";
    case DW_OP_mod:
      return "DW_OP_mod";
    case DW_OP_mul:
      return "DW_OP_mul";
    case DW_OP_neg:
      return "DW_OP_neg";
    case DW_OP_not:
      return "DW_OP_not";
    case DW_OP_or:
      return "DW_OP_or";
    case DW_OP_plus:
      return "DW_OP_plus";
    case DW_OP_plus_uconst:
      return "DW_OP_plus_uconst";
    case DW_OP_shl:
      return "DW_OP_shl";
    case DW_OP_shr:
      return "DW_OP_shr";
    case DW_OP_shra:
      return "DW_OP_shra";
    case DW_OP_xor:
      return "DW_OP_xor";
    case DW_OP_bra:
      return "DW_OP_bra";
    case DW_OP_eq:
      return "DW_OP_eq";
    case DW_OP_ge:
      return "DW_OP_ge";
    case DW_OP_gt:
      return "DW_OP_gt";
    case DW_OP_le:
      return "DW_OP_le";
    case DW_OP_lt:
      return "DW_OP_lt";
    case DW_OP_ne:
      return "DW_OP_ne";
    case DW_OP_skip:
      return "DW_OP_skip";
    case DW_OP_lit0:
      return "DW_OP_lit0";
    case DW_OP_lit1:
      return "DW_OP_lit1";
    case DW_OP_lit2:
      return "DW_OP_lit2";
    case DW_OP_lit3:
      return "DW_OP_lit3";
    case DW_OP_lit4:
      return "DW_OP_lit4";
    case DW_OP_lit5:
      return "DW_OP_lit5";
    case DW_OP_lit6:
      return "DW_OP_lit6";
    case DW_OP_lit7:
      return "DW_OP_lit7";
    case DW_OP_lit8:
      return "DW_OP_lit8";
    case DW_OP_lit9:
      return "DW_OP_lit9";
    case DW_OP_lit10:
      return "DW_OP_lit10";
    case DW_OP_lit11:
      return "DW_OP_lit11";
    case DW_OP_lit12:
      return "DW_OP_lit12";
    case DW_OP_lit13:
      return "DW_OP_lit13";
    case DW_OP_lit14:
      return "DW_OP_lit14";
    case DW_OP_lit15:
      return "DW_OP_lit15";
    case DW_OP_lit16:
      return "DW_OP_lit16";
    case DW_OP_lit17:
      return "DW_OP_lit17";
    case DW_OP_lit18:
      return "DW_OP_lit18";
    case DW_OP_lit19:
      return "DW_OP_lit19";
    case DW_OP_lit20:
      return "DW_OP_lit20";
    case DW_OP_lit21:
      return "DW_OP_lit21";
    case DW_OP_lit22:
      return "DW_OP_lit22";
    case DW_OP_lit23:
      return "DW_OP_lit23";
    case DW_OP_lit24:
      return "DW_OP_lit24";
    case DW_OP_lit25:
      return "DW_OP_lit25";
    case DW_OP_lit26:
      return "DW_OP_lit26";
    case DW_OP_lit27:
      return "DW_OP_lit27";
    case DW_OP_lit28:
      return "DW_OP_lit28";
    case DW_OP_lit29:
      return "DW_OP_lit29";
    case DW_OP_lit30:
      return "DW_OP_lit30";
    case DW_OP_lit31:
      return "DW_OP_lit31";
    case DW_OP_reg0:
      return "DW_OP_reg0";
    case DW_OP_reg1:
      return "DW_OP_reg1";
    case DW_OP_reg2:
      return "DW_OP_reg2";
    case DW_OP_reg3:
      return "DW_OP_reg3";
    case DW_OP_reg4:
      return "DW_OP_reg4";
    case DW_OP_reg5:
      return "DW_OP_reg5";
    case DW_OP_reg6:
      return "DW_OP_reg6";
    case DW_OP_reg7:
      return "DW_OP_reg7";
    case DW_OP_reg8:
      return "DW_OP_reg8";
    case DW_OP_reg9:
      return "DW_OP_reg9";
    case DW_OP_reg10:
      return "DW_OP_reg10";
    case DW_OP_reg11:
      return "DW_OP_reg11";
    case DW_OP_reg12:
      return "DW_OP_reg12";
    case DW_OP_reg13:
      return "DW_OP_reg13";
    case DW_OP_reg14:
      return "DW_OP_reg14";
    case DW_OP_reg15:
      return "DW_OP_reg15";
    case DW_OP_reg16:
      return "DW_OP_reg16";
    case DW_OP_reg17:
      return "DW_OP_reg17";
    case DW_OP_reg18:
      return "DW_OP_reg18";
    case DW_OP_reg19:
      return "DW_OP_reg19";
    case DW_OP_reg20:
      return "DW_OP_reg20";
    case DW_OP_reg21:
      return "DW_OP_reg21";
    case DW_OP_reg22:
      return "DW_OP_reg22";
    case DW_OP_reg23:
      return "DW_OP_reg23";
    case DW_OP_reg24:
      return "DW_OP_reg24";
    case DW_OP_reg25:
      return "DW_OP_reg25";
    case DW_OP_reg26:
      return "DW_OP_reg26";
    case DW_OP_reg27:
      return "DW_OP_reg27";
    case DW_OP_reg28:
      return "DW_OP_reg28";
    case DW_OP_reg29:
      return "DW_OP_reg29";
    case DW_OP_reg30:
      return "DW_OP_reg30";
    case DW_OP_reg31:
      return "DW_OP_reg31";
    case DW_OP_breg0:
      return "DW_OP_breg0";
    case DW_OP_breg1:
      return "DW_OP_breg1";
    case DW_OP_breg2:
      return "DW_OP_breg2";
    case DW_OP_breg3:
      return "DW_OP_breg3";
    case DW_OP_breg4:
      return "DW_OP_breg4";
    case DW_OP_breg5:
      return "DW_OP_breg5";
    case DW_OP_breg6:
      return "DW_OP_breg6";
    case DW_OP_breg7:
      return "DW_OP_breg7";
    case DW_OP_breg8:
      return "DW_OP_breg8";
    case DW_OP_breg9:
      return "DW_OP_breg9";
    case DW_OP_breg10:
      return "DW_OP_breg10";
    case DW_OP_breg11:
      return "DW_OP_breg11";
    case DW_OP_breg12:
      return "DW_OP_breg12";
    case DW_OP_breg13:
      return "DW_OP_breg13";
    case DW_OP_breg14:
      return "DW_OP_breg14";
    case DW_OP_breg15:
      return "DW_OP_breg15";
    case DW_OP_breg16:
      return "DW_OP_breg16";
    case DW_OP_breg17:
      return "DW_OP_breg17";
    case DW_OP_breg18:
      return "DW_OP_breg18";
    case DW_OP_breg19:
      return "DW_OP_breg19";
    case DW_OP_breg20:
      return "DW_OP_breg20";
    case DW_OP_breg21:
      return "DW_OP_breg21";
    case DW_OP_breg22:
      return "DW_OP_breg22";
    case DW_OP_breg23:
      return "DW_OP_breg23";
    case DW_OP_breg24:
      return "DW_OP_breg24";
    case DW_OP_breg25:
      return "DW_OP_breg25";
    case DW_OP_breg26:
      return "DW_OP_breg26";
    case DW_OP_breg27:
      return "DW_OP_breg27";
    case DW_OP_breg28:
      return "DW_OP_breg28";
    case DW_OP_breg29:
      return "DW_OP_breg29";
    case DW_OP_breg30:
      return "DW_OP_breg30";
    case DW_OP_breg31:
      return "DW_OP_breg31";
    case DW_OP_regx:
      return "DW_OP_regx";
    case DW_OP_fbreg:
      return "DW_OP_fbreg";
    case DW_OP_bregx:
      return "DW_OP_bregx";
    case DW_OP_piece:
      return "DW_OP_piece";
    case DW_OP_deref_size:
      return "DW_OP_deref_size";
    case DW_OP_xderef_size:
      return "DW_OP_xderef_size";
    case DW_OP_nop:
      return "DW_OP_nop";
    /* DWARF 3 extensions.  */
    case DW_OP_push_object_address:
      return "DW_OP_push_object_address";
    case DW_OP_call2:
      return "DW_OP_call2";
    case DW_OP_call4:
      return "DW_OP_call4";
    case DW_OP_call_ref:
      return "DW_OP_call_ref";
    case DW_OP_form_tls_address:
      return "DW_OP_form_tls_address";
    case DW_OP_call_frame_cfa:
      return "DW_OP_call_frame_cfa";
    case DW_OP_bit_piece:
      return "DW_OP_bit_piece";
    /* DWARF 4 extensions.  */
    case DW_OP_implicit_value:
      return "DW_OP_implicit_value";
    case DW_OP_stack_value:
      return "DW_OP_stack_value";
    /* GNU extensions.  */
    case DW_OP_GNU_push_tls_address:
      return "DW_OP_GNU_push_tls_address";
    case DW_OP_GNU_uninit:
      return "DW_OP_GNU_uninit";
    case DW_OP_GNU_encoded_addr:
      return "DW_OP_GNU_encoded_addr";
    case DW_OP_GNU_implicit_pointer:
      return "DW_OP_GNU_implicit_pointer";
    case DW_OP_GNU_entry_value:
      return "DW_OP_GNU_entry_value";
    case DW_OP_GNU_const_type:
      return "DW_OP_GNU_const_type";
    case DW_OP_GNU_regval_type:
      return "DW_OP_GNU_regval_type";
    case DW_OP_GNU_deref_type:
      return "DW_OP_GNU_deref_type";
    case DW_OP_GNU_convert:
      return "DW_OP_GNU_convert";
    case DW_OP_GNU_reinterpret:
      return "DW_OP_GNU_reinterpret";
    case DW_OP_GNU_parameter_ref:
      return "DW_OP_GNU_parameter_ref";
    default:
      return NULL;
    }
d14323 1
a14323 1
static char *
d14326 1
a14326 57
  switch (enc)
    {
    case DW_ATE_void:
      return "DW_ATE_void";
    case DW_ATE_address:
      return "DW_ATE_address";
    case DW_ATE_boolean:
      return "DW_ATE_boolean";
    case DW_ATE_complex_float:
      return "DW_ATE_complex_float";
    case DW_ATE_float:
      return "DW_ATE_float";
    case DW_ATE_signed:
      return "DW_ATE_signed";
    case DW_ATE_signed_char:
      return "DW_ATE_signed_char";
    case DW_ATE_unsigned:
      return "DW_ATE_unsigned";
    case DW_ATE_unsigned_char:
      return "DW_ATE_unsigned_char";
    /* DWARF 3.  */
    case DW_ATE_imaginary_float:
      return "DW_ATE_imaginary_float";
    case DW_ATE_packed_decimal:
      return "DW_ATE_packed_decimal";
    case DW_ATE_numeric_string:
      return "DW_ATE_numeric_string";
    case DW_ATE_edited:
      return "DW_ATE_edited";
    case DW_ATE_signed_fixed:
      return "DW_ATE_signed_fixed";
    case DW_ATE_unsigned_fixed:
      return "DW_ATE_unsigned_fixed";
    case DW_ATE_decimal_float:
      return "DW_ATE_decimal_float";
    /* DWARF 4.  */
    case DW_ATE_UTF:
      return "DW_ATE_UTF";
    /* HP extensions.  */
    case DW_ATE_HP_float80:
      return "DW_ATE_HP_float80";
    case DW_ATE_HP_complex_float80:
      return "DW_ATE_HP_complex_float80";
    case DW_ATE_HP_float128:
      return "DW_ATE_HP_float128";
    case DW_ATE_HP_complex_float128:
      return "DW_ATE_HP_complex_float128";
    case DW_ATE_HP_floathpintel:
      return "DW_ATE_HP_floathpintel";
    case DW_ATE_HP_imaginary_float80:
      return "DW_ATE_HP_imaginary_float80";
    case DW_ATE_HP_imaginary_float128:
      return "DW_ATE_HP_imaginary_float128";
    default:
      return "DW_ATE_<unknown>";
    }
}
d14328 2
a14329 1
/* Convert a DWARF call frame info operation to its string name.  */
d14331 1
a14331 72
#if 0
static char *
dwarf_cfi_name (unsigned cfi_opc)
{
  switch (cfi_opc)
    {
    case DW_CFA_advance_loc:
      return "DW_CFA_advance_loc";
    case DW_CFA_offset:
      return "DW_CFA_offset";
    case DW_CFA_restore:
      return "DW_CFA_restore";
    case DW_CFA_nop:
      return "DW_CFA_nop";
    case DW_CFA_set_loc:
      return "DW_CFA_set_loc";
    case DW_CFA_advance_loc1:
      return "DW_CFA_advance_loc1";
    case DW_CFA_advance_loc2:
      return "DW_CFA_advance_loc2";
    case DW_CFA_advance_loc4:
      return "DW_CFA_advance_loc4";
    case DW_CFA_offset_extended:
      return "DW_CFA_offset_extended";
    case DW_CFA_restore_extended:
      return "DW_CFA_restore_extended";
    case DW_CFA_undefined:
      return "DW_CFA_undefined";
    case DW_CFA_same_value:
      return "DW_CFA_same_value";
    case DW_CFA_register:
      return "DW_CFA_register";
    case DW_CFA_remember_state:
      return "DW_CFA_remember_state";
    case DW_CFA_restore_state:
      return "DW_CFA_restore_state";
    case DW_CFA_def_cfa:
      return "DW_CFA_def_cfa";
    case DW_CFA_def_cfa_register:
      return "DW_CFA_def_cfa_register";
    case DW_CFA_def_cfa_offset:
      return "DW_CFA_def_cfa_offset";
    /* DWARF 3.  */
    case DW_CFA_def_cfa_expression:
      return "DW_CFA_def_cfa_expression";
    case DW_CFA_expression:
      return "DW_CFA_expression";
    case DW_CFA_offset_extended_sf:
      return "DW_CFA_offset_extended_sf";
    case DW_CFA_def_cfa_sf:
      return "DW_CFA_def_cfa_sf";
    case DW_CFA_def_cfa_offset_sf:
      return "DW_CFA_def_cfa_offset_sf";
    case DW_CFA_val_offset:
      return "DW_CFA_val_offset";
    case DW_CFA_val_offset_sf:
      return "DW_CFA_val_offset_sf";
    case DW_CFA_val_expression:
      return "DW_CFA_val_expression";
    /* SGI/MIPS specific.  */
    case DW_CFA_MIPS_advance_loc8:
      return "DW_CFA_MIPS_advance_loc8";
    /* GNU extensions.  */
    case DW_CFA_GNU_window_save:
      return "DW_CFA_GNU_window_save";
    case DW_CFA_GNU_args_size:
      return "DW_CFA_GNU_args_size";
    case DW_CFA_GNU_negative_offset_extended:
      return "DW_CFA_GNU_negative_offset_extended";
    default:
      return "DW_CFA_<unknown>";
    }
a14332 1
#endif
d15164 1
a15164 1
	    const char *name = dwarf_stack_op_name (op);
@


1.646
log
@	* dwarf2read.c (init_cutu_and_read_dies): Renamed from
	init_and_read_dies_worker.  All callers updated.
	(init_cu_and_read_dies, init_tu_and_read_dies): Delete.  All calls
	replaced with init_cutu_and_read_dies.
	(load_partial_comp_unit): Pass 1 for use_existing_cu.
	(find_partial_die): Remove FIXME.  Don't free current CU.

	testsuite/
	* gdb.dwarf2/pr13961.S: New file.
	* gdb.dwarf2/pr13961.exp: New file.
@
text
@d2836 2
a2837 1
  if (file_data == NULL)
@


1.645
log
@	* dwarf2read.c (dwarf_decode_macros): New arg section_name.
	All callers updated.
	(init_cu_die_reader): Verify the section is non-empty.
	(dwarf_decode_line_header): Don't dereference section->asection
	until we know the section is present.
@
text
@d600 1
a600 1
/* Type of function passed to init_cu_and_read_dies, et.al.  */
d1404 2
a1405 2
static void init_tu_and_read_dies
  (struct dwarf2_per_cu_data *this_cu, int keep,
d2477 1
a2477 1
    init_tu_and_read_dies (this_cu, 0, dw2_get_file_names_reader, NULL);
d3631 1
a3631 2
/* Subroutine of init_{cu,tu}_and_read_dies.
   Do all the work necessary to initialize THIS_CU->cu and read in its DIE(s).
d3641 1
a3641 6
   linker) then DIE_READER_FUNC will not get called.

   FIXME: As an implementation detail between our callers and us,
   USE_EXISTING_CU and KEEP are OK.  But bubbling them up into their callers
   isn't as clean as I'd like.  Having more callers with good names
   may be the way to go.  */
d3644 4
a3647 4
init_and_read_dies_worker (struct dwarf2_per_cu_data *this_cu,
			   int use_existing_cu, int keep,
			   die_reader_func_ftype *die_reader_func,
			   void *data)
a3662 2
  if (this_cu->is_debug_types)
    gdb_assert (! use_existing_cu);
a3912 37
/* Main entry point for reading a CU.
   Do all the work necessary to initialize THIS_CU->cu and read in its DIE(s).
   If the CU defers to a DWO file, read the DWO file as well.

   If USE_EXISTING_CU is non-zero, and THIS_CU->cu is non-NULL, then use it.
   Otherwise, a new CU is allocated with xmalloc.

   If KEEP is non-zero, then if we allocated a dwarf2_cu we add it to
   read_in_chain.  Otherwise the dwarf2_cu data is freed at the end.  */

static void
init_cu_and_read_dies (struct dwarf2_per_cu_data *this_cu,
		       int use_existing_cu, int keep,
		       die_reader_func_ftype *die_reader_func,
		       void *data)
{
  init_and_read_dies_worker (this_cu, use_existing_cu, keep,
			     die_reader_func, data);
}

/* Main entry point for reading a TU.
   Do all the work necessary to initialize THIS_CU->cu and read in its DIE(s).
   If the TU defers to a DWO file, read the DWO file as well.

   If KEEP is non-zero, then if we allocated a dwarf2_cu we add it to
   read_in_chain.  Otherwise the dwarf2_cu data is freed at the end.  */

static void
init_tu_and_read_dies (struct dwarf2_per_cu_data *this_cu,
		       int keep,
		       die_reader_func_ftype *die_reader_func,
		       void *data)
{
  gdb_assert (this_cu->is_debug_types);
  init_and_read_dies_worker (this_cu, 0, keep, die_reader_func, data);
}

d4134 2
a4135 2
  init_cu_and_read_dies (this_cu, 0, 0, process_psymtab_comp_unit_reader,
			 NULL);
d4150 1
d4161 2
a4162 2
  gdb_assert (per_cu->is_debug_types);
  init_tu_and_read_dies (per_cu, 0, process_psymtab_comp_unit_reader, NULL);
d4262 1
a4262 4
  if (this_cu->is_debug_types)
    init_tu_and_read_dies (this_cu, 1, load_partial_comp_unit_reader, NULL);
  else
    init_cu_and_read_dies (this_cu, 0, 1, load_partial_comp_unit_reader, NULL);
d5271 1
a5271 1
  init_cu_and_read_dies (this_cu, 1, 1, load_full_comp_unit_reader, NULL);
d11132 1
a11132 2
      /* FIXME: The testsuite doesn't trigger this code path.
	 http://sourceware.org/bugzilla/show_bug.cgi?id=13961  */
d11134 6
a11139 2
      free_one_cached_comp_unit (per_cu);
      per_cu->load_all_dies = 1;
d15872 1
a15872 1
  init_tu_and_read_dies (per_cu, 1, read_signatured_type_reader, NULL);
@


1.644
log
@	Initial support for Fission.  http://gcc.gnu.org/wiki/DebugFission
	* symfile.c (default_symfile_relocate): Use sectp->owner instead of
	objfile->obfd.
	* symfile.h (dwarf2_debug_sections): New member addr.
	* dwarf2expr.c (execute_stack_op): New case DW_OP_GNU_addr_index.
	(ctx_no_get_addr_index): New function.
	* dwarf2expr.h (dwarf_expr_context_funcs): New member get_addr_index.
	(ctx_no_get_addr_index): Declare.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Update.
	* dwarf2loc.c (dwarf_expr_get_addr_index): New function.
	(dwarf_expr_ctx_funcs): Update.
	(needs_get_addr_index): New function.
	(needs_frame_ctx_funcs): Update.
	* dwarf2loc.h (dwarf2_read_addr_index): Declare.
	* dwarf2read.c: #include "gdbcore.h".
	(dwarf2_per_objfile): New members addr, dwo_files.
	(dwarf2_elf_names): Add entry for addr.
	(struct dwo_section_names): New type.
	(dwo_section_names): New static global.
	(dwarf2_cu): New members dwo_unit, addr_base, have_addr_base.
	(dwarf2_per_cu_data): New member is_debug_types, all boolean uses of
	old debug_types_section member updated to use this.
	Rename member debug_types_section to info_or_types_section,
	all uses updated.
	(signatured_type): Rename member type_offset to type_offset_in_tu,
	all uses updated.  New member type_offset_in_section.
	(struct dwo_sections): New type.
	(struct dwo_unit): New type.
	(struct dwo_file): New type.
	(die_reader_specs): New member dwo_file.
	(dwarf2_locate_sections): Watch for .debug_addr.
	(zlib_decompress_section): Use sectp->owner instead of objfile->obfd.
	(dwarf2_read_section): Get bfd of section from bfd's asection,
	instead of objfile.
	(create_cus_from_index): Initialize the_cu->info_or_types_section.
	(create_signatured_type_table_from_index): Initialize
	sig_type->info_or_types_section.
	(dw2_get_file_names): Statement lists for type units with DWO files
	live in the DWO file.
	(create_debug_types_hash_table): New function.
	(create_all_type_units): Rewrite.
	(init_cu_die_reader): New arg dwo_file, all callers updated.
	(init_and_read_dies_worker): Get section from
	this_cu->info_or_types_section.  Set sig_type->type_offset_in_section.
	Watch for DW_AT_GNU_dwo_name and if present lookup the file and
	continue reading the CU/TU from there.
	(init_cutu_and_read_dies_no_follow): New arg dwo_file, all callers
	updated.  Get section from this_cu->info_or_types_section.
	(create_all_comp_units): Initialize this_cu->info_or_types_section.
	(skip_one_die): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(hash_dwo_file, eq_dwo_file): New functions.
	(allocate_dwo_file_hash_table): New function.
	(hash_dwo_unit, eq_dwo_unit): New functions.
	(allocate_dwo_unit_table): New function.
	(dwarf2_locate_dwo_sections): New function.
	(struct create_dwo_info_table_data): New type.
	(create_debug_info_hash_table_reader): New function.
	(create_debug_info_hash_table): New function.
	(try_open_dwo_file, open_dwo_file, init_dwo_file): New function.
	(lookup_dwo_file): New function.
	(lookup_dwo_comp_unit, lookup_dwo_type_unit): New functions.
	(free_dwo_file, free_dwo_file_cleanup): New functions.
	(free_dwo_file_from_slot, free_dwo_files): New functions.
	(dwarf2_get_pc_bounds): Handle DW_FORM_GNU_addr_index.
	(dwarf2_record_block_ranges): Ditto.
	(read_partial_die): Ditto.
	(process_enumeration_scope): Update to use type_offset_in_section.
	(read_full_die_1): New function.
	(read_full_die): Rewrite.
	(read_attribute_value): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(read_addr_index_1, read_addr_index): New functions.
	(read_addr_index_from_leb128): New function.
	(struct dwarf2_read_addr_index_data): New type.
	(dwarf2_read_addr_index_reader): New function.
	(dwarf2_read_addr_index): New function.
	(read_str_index): New function.
	(leb128_size): New function.
	(dwarf_decode_line_header): Delete arg abfd, all callers updated.
	If processing a type unit from a DWO file, get the line section
	from the DWO file.
	(var_decode_location): Watch for DW_OP_GNU_addr_index.
	(dwarf2_const_value_attr): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(lookup_die_type): Check whether section offset of type's die is
	known before looking it up.  Remove assert.  Condition can
	legimately happen for inter-cu type references.
	(dwarf_attr_name): Handle Fission attributes.
	(dwarf_form_name): Handle Fission forms.
	(dump_die_shallow): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(follow_die_sig): Update to use type_offset_in_section.
	(decode_locdesc): New case DW_OP_GNU_addr_index.
	(skip_form_bytes): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(cu_debug_loc_section): New function.
	(fill_in_loclist_baton, dwarf2_symbol_mark_computed): Call it.
	(dwarf2_per_objfile_free): Unmap .debug_addr section.
	Free DWO files if present.
	* xcoffread.c (dwarf2_xcoff_names): Add .debug_addr.

	testsuite/
	* gdb.dwarf2/dw2-intercu.S (.Ltype_int2_in_cu2): Renamed from
	.Ltype_int_in_cu2.  Use name "int2" instead of "int".
	All uses updated.
	* gdb.dwarf2/dw2-intercu.exp: Add "ptype int2" ahead of
	"ptype func_cu1" to expand cu2 before cu1.
@
text
@d1320 1
a1320 1
				 int);
d1674 2
a1675 1
/* A helper function that decides whether a section is empty.  */
d3592 1
a3592 1
  gdb_assert (section->readin);
d6358 2
a6359 1
			   &dwarf2_per_objfile->macro, 1);
d6370 2
a6371 1
			       &dwarf2_per_objfile->macinfo, 0);
a12322 1
  abfd = section->asection->owner;
d12334 4
d16903 1
a16903 1
		     int section_is_gnu)
d16918 1
a16918 2
      complaint (&symfile_complaints, _("missing %s section"),
		 section->asection->name);
@


1.643
log
@	Refactor DIE reading.
	* dwarf2read.c (dwarf2_per_objfile): Replace members
	debug_info_type_hash and debug_types_type_hash with die_type_hash.
	(die_reader_specs): New member "die_section".  Temporarily make
	member "buffer" non-const, pending constifying all info_ptr uses.
	(die_reader_func_ftype): New typedef.
	(dw2_get_file_names_reader): New function.
	(dw2_get_file_names): Rewrite.
	(read_and_check_type_unit_head): Rename arg type_offset to
	type_offset_in_tu.
	(create_all_type_units): Improve debugging message.
	Improve dummy type unit check.
	(init_cu_die_reader): New arg "section".  All callers updated.
	(init_and_read_dies_worker): New function.
	(init_cu_and_read_dies, init_tu_and_read_dies): New functions.
	(init_cutu_and_read_dies_no_follow): New function.
	(init_cutu_and_read_dies_simple): New function.
	(process_psymtab_comp_unit_reader): New function.
	(process_psymtab_comp_unit): Delete args section,
	is_debug_types_section.  Rewrite.  All callers updated.
	(process_psymtab_type_unit): Renamed from process_type_comp_unit.
	All callers updated.  Rewrite.
	(load_partial_comp_unit_reader): New function.
	(load_partial_comp_unit): Rewrite.
	(skip_children): New arg reader.  Delete args buffer, cu.
	All callers updated.
	(skip_one_die): New arg reader.  Delete args buffer, cu.
	All callers updated.
	(locate_pdi_sibling): New arg reader.  Delete args buffer, abfd, cu.
	All callers updated.
	(load_full_comp_unit_reader): New function.
	(load_full_comp_unit): Rewrite.
	(read_comp_unit): Delete.
	(read_die_and_children_1): Delete, contents moved ...
	(read_die_and_children): ... here.
	(dwarf2_read_abbrevs): New arg abbrev_section.  All callers updated.
	(load_partial_dies): New arg reader.  Delete args abfd, buffer, cu.
	All callers updated.
	(read_partial_die): New arg reader.  Delete args abfd, buffer, cu.
	All callers updated.
	(find_partial_die): Rewrite load_all_dies support.
	(read_attribute_value): New arg reader.  Delete args abfd, cu.
	All callers updated.
	(read_attribute): New arg reader.  Delete args abfd, cu.
	All callers updated.
	(load_full_type_unit): Add assert.
	(read_signatured_type_reader): New function.
	(read_signatured_type): Rewrite.
	(free_stack_comp_unit): Remove call to age_cached_comp_units.
	(free_one_cached_comp_unit): Change target_cu arg to target_per_cu.
	All callers updated.  Set per_cu->cu = NULL after freeing it.
	(dwarf2_per_cu_offset_and_type): Renamed from dwarf2_offset_and_type.
	(per_cu_offset_and_type_hash): Renamed from offset_and_type_hash.
	(per_cu_offset_and_type_eq): Renamed from offset_and_type_eq.
	(set_die_type): Update.
	(get_die_type_at_offset): Update.
	(read_file_scope): Call prepare_one_comp_unit.
	(read_type_unit_scope): Ditto.
	(prepare_one_comp_unit): Set producer if present.
@
text
@d64 1
d164 1
d195 4
d244 1
d251 23
d409 8
d432 4
d448 3
a450 1
     initial_length_size.  */
d464 7
a470 3
  /* Non-null if this CU is from .debug_types; in which case it points
     to the section.  Otherwise it's from .debug_info.  */
  struct dwarf2_section_info *debug_types_section;
d499 1
d502 10
a511 2
  /* Offset in this TU of the type defined by this TU.  */
  cu_offset type_offset;
d517 59
d589 3
d593 1
a593 1
     This is either .debug_info or .debug_types.  */
d1082 6
d1112 2
a1113 3
static struct line_header *(dwarf_decode_line_header
                            (unsigned int offset,
                             bfd *abfd, struct dwarf2_cu *cu));
d1235 3
d1404 4
d1416 12
d1548 5
d1602 1
a1602 1
  bfd *abfd = objfile->obfd;
d1682 4
a1685 2
/* Read the contents of the section INFO from object file specified by
   OBJFILE, store info about the section into INFO.
a1690 1
  bfd *abfd = objfile->obfd;
d1692 1
d1705 3
d1929 1
a1929 1
  if (per_cu->debug_types_section)
d2045 1
d2088 3
a2090 2
      sig_type->type_offset.cu_off = type_offset_in_tu;
      sig_type->per_cu.debug_types_section = section;
a2399 1
  bfd *abfd = objfile->obfd;
d2431 1
a2431 1
      lh = dwarf_decode_line_header (line_offset, abfd, cu);
d2471 8
a2478 1
  init_cutu_and_read_dies_simple (this_cu, dw2_get_file_names_reader, NULL);
a3318 2
  struct objfile *objfile = cu->objfile;
  bfd *abfd = objfile->obfd;
d3324 1
a3324 5
    {
      unsigned int line_offset = DW_UNSND (attr);

      lh = dwarf_decode_line_header (line_offset, abfd, cu);
    }
d3380 4
a3383 3
/* Create the hash table of all entries in the .debug_types section(s).
   The result is zero if there are no .debug_types sections,
   otherwise non-zero.  */
d3385 3
a3387 2
static int
create_all_type_units (struct objfile *objfile)
d3389 1
a3389 1
  struct bfd *abfd = objfile->obfd;
a3390 1
  struct dwarf2_per_cu_data **iter;
d3394 2
a3395 5
  if (VEC_empty (dwarf2_section_info_def, dwarf2_per_objfile->types))
    {
      dwarf2_per_objfile->signatured_types = NULL;
      return 0;
    }
d3398 1
a3398 2
       VEC_iterate (dwarf2_section_info_def, dwarf2_per_objfile->types,
		    ix, section);
d3401 1
d3410 4
d3415 6
a3420 1
	types_htab = allocate_signatured_type_table (objfile);
d3434 1
a3434 1
	  cu_offset type_offset;
d3437 1
d3449 1
a3449 1
					       &signature, &type_offset);
d3461 27
a3487 7
	  sig_type = obstack_alloc (&objfile->objfile_obstack, sizeof (*sig_type));
	  memset (sig_type, 0, sizeof (*sig_type));
	  sig_type->signature = signature;
	  sig_type->type_offset = type_offset;
	  sig_type->per_cu.objfile = objfile;
	  sig_type->per_cu.debug_types_section = section;
	  sig_type->per_cu.offset = offset;
d3489 3
a3491 1
	  slot = htab_find_slot (types_htab, sig_type, INSERT);
d3495 14
a3508 1
	      const struct signatured_type *dup_sig = *slot;
d3513 1
a3513 1
			 offset.sect_off, dup_sig->per_cu.offset.sect_off,
a3514 1
	      gdb_assert (signature == dup_sig->signature);
d3516 1
a3516 1
	  *slot = sig_type;
d3527 21
d3588 2
a3589 1
		    struct dwarf2_section_info *section)
d3594 1
d3632 1
d3655 2
a3656 2
  struct dwarf2_section_info *section;
  bfd *abfd;
d3668 1
a3668 1
  if (this_cu->debug_types_section)
a3670 6
  if (this_cu->debug_types_section)
    section = this_cu->debug_types_section;
  else
    section = &dwarf2_per_objfile->info;
  abfd = section->asection->owner;

d3694 1
a3694 1
      if (this_cu->debug_types_section)
d3714 4
d3746 1
a3746 1
  init_cu_die_reader (&reader, cu, section);
d3749 146
d3922 1
d3942 1
d3953 1
a3953 1
  gdb_assert (this_cu->debug_types_section);
d3957 4
a3960 1
/* Read the CU/TU at OFFSET in section SECTION.
d3963 1
a3963 1
   THIS_CU->debug_types_section, but nothing else.
d3971 2
a3972 1
   [This is done for Fission reasons, to be specified.]  */
d3977 1
d3982 2
a3983 2
  struct dwarf2_section_info *section;
  bfd *abfd;
a3992 6
  if (this_cu->debug_types_section)
    section = this_cu->debug_types_section;
  else
    section = &dwarf2_per_objfile->info;
  abfd = section->asection->owner;

d4002 1
a4002 1
					    this_cu->debug_types_section != NULL);
d4017 1
a4017 1
  init_cu_die_reader (&reader, &cu, section);
d4025 3
a4027 2
/* Read a CU/TU.
   [This is a separate routine for Fission, to be specified.]
d4030 3
a4032 1
   [This is done for Fission reasons, to be specified.]  */
d4041 1
d4150 1
a4150 1
  if (per_cu->debug_types_section)
d4177 1
a4177 1
  gdb_assert (! this_cu->debug_types_section);
d4204 1
a4204 1
  gdb_assert (per_cu->debug_types_section);
d4279 1
a4279 1
/* Load the partial DIEs for a secondary CU into memory.  */
d4305 1
a4305 1
  if (this_cu->debug_types_section)
d4351 1
d5035 2
d5315 1
a5315 1
  gdb_assert (! this_cu->debug_types_section);
a6260 2
  struct objfile *objfile = cu->objfile;
  bfd *abfd = objfile->obfd;
d6267 1
a6267 1
	= dwarf_decode_line_header (line_offset, abfd, cu);
d6310 560
a6869 4
     standardised yet.  As a workaround for the language detection we fall
     back to the DW_AT_producer string.  */
  if (cu->producer && strstr (cu->producer, "IBM XL C for OpenCL") != NULL)
    cu->language = language_opencl;
d6871 1
a6871 3
  /* Similar hack for Go.  */
  if (cu->producer && strstr (cu->producer, "GNU Go ") != NULL)
    set_cu_language (DW_LANG_Go, cu);
d6873 6
a6878 2
  /* We assume that we're processing GCC output.  */
  processing_gcc_compilation = 2;
d6880 12
a6891 1
  processing_has_namespace_info = 0;
d6893 3
a6895 3
  start_symtab (name, comp_dir, lowpc);
  record_debugformat ("DWARF 2");
  record_producer (cu->producer);
d6897 1
a6897 4
  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.  */
  handle_DW_AT_stmt_list (die, cu, comp_dir, 1);
d6899 1
a6899 2
  /* Process all dies in compilation unit.  */
  if (die->child != NULL)
d6901 1
a6901 7
      child_die = die->child;
      while (child_die && child_die->tag)
	{
	  process_die (child_die, cu);
	  child_die = sibling_die (child_die);
	}
    }
d6903 2
a6904 10
  /* Decode macro information, if present.  Dwarf 2 macro information
     refers to information in the line number info statement program
     header, so we can only read it if we've read the header
     successfully.  */
  attr = dwarf2_attr (die, DW_AT_GNU_macros, cu);
  if (attr && cu->line_header)
    {
      if (dwarf2_attr (die, DW_AT_macro_info, cu))
	complaint (&symfile_complaints,
		   _("CU refers to both DW_AT_GNU_macros and DW_AT_macro_info"));
d6906 2
a6907 3
      dwarf_decode_macros (cu->line_header, DW_UNSND (attr),
			   comp_dir, abfd, cu,
			   &dwarf2_per_objfile->macro, 1);
a6908 6
  else
    {
      attr = dwarf2_attr (die, DW_AT_macro_info, cu);
      if (attr && cu->line_header)
	{
	  unsigned int macro_offset = DW_UNSND (attr);
d6910 1
a6910 5
	  dwarf_decode_macros (cu->line_header, macro_offset,
			       comp_dir, abfd, cu,
			       &dwarf2_per_objfile->macinfo, 0);
	}
    }
d6912 5
a6916 1
  do_cleanups (back_to);
d6919 3
a6921 4
/* Process DW_TAG_type_unit.
   For TUs we want to skip the first top level sibling if it's not the
   actual type being defined by this TU.  In this case the first top
   level sibling is there to provide context only.  */
d6924 1
a6924 1
read_type_unit_scope (struct die_info *die, struct dwarf2_cu *cu)
d6926 2
a6927 8
  struct objfile *objfile = cu->objfile;
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
  CORE_ADDR lowpc;
  struct attribute *attr;
  char *name = NULL;
  char *comp_dir = NULL;
  struct die_info *child_die;
  bfd *abfd = objfile->obfd;
d6929 2
a6930 3
  /* start_symtab needs a low pc, but we don't really have one.
     Do what read_file_scope would do in the absence of such info.  */
  lowpc = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d6932 6
a6937 5
  /* Find the filename.  Do not use dwarf2_name here, since the filename
     is not a source language identifier.  */
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr)
    name = DW_STRING (attr);
d6939 5
a6943 9
  attr = dwarf2_attr (die, DW_AT_comp_dir, cu);
  if (attr)
    comp_dir = DW_STRING (attr);
  else if (name != NULL && IS_ABSOLUTE_PATH (name))
    {
      comp_dir = ldirname (name);
      if (comp_dir != NULL)
	make_cleanup (xfree, comp_dir);
    }
d6945 2
a6946 2
  if (name == NULL)
    name = "<unknown>";
d6948 1
a6948 1
  prepare_one_comp_unit (cu, die);
d6950 5
a6954 2
  /* We assume that we're processing GCC output.  */
  processing_gcc_compilation = 2;
d6956 2
a6957 1
  processing_has_namespace_info = 0;
d6959 1
a6959 3
  start_symtab (name, comp_dir, lowpc);
  record_debugformat ("DWARF 2");
  record_producer (cu->producer);
d6961 5
a6965 13
  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.
     We don't need the pc/line-number mapping for type units.  */
  handle_DW_AT_stmt_list (die, cu, comp_dir, 0);

  /* Process the dies in the type unit.  */
  if (die->child == NULL)
    {
      dump_die_for_error (die);
      error (_("Dwarf Error: Missing children for type unit [in module %s]"),
	     bfd_get_filename (abfd));
    }
d6967 1
a6967 1
  child_die = die->child;
d6969 2
a6970 3
  while (child_die && child_die->tag)
    {
      process_die (child_die, cu);
d6972 1
a6972 2
      child_die = sibling_die (child_die);
    }
d6974 4
a6977 1
  do_cleanups (back_to);
d6979 2
d7777 2
a7778 1
	  if (attr_high->form == DW_FORM_addr)
d7940 2
a7941 1
	  if (attr_high->form == DW_FORM_addr)
d9254 1
a9254 1
  if (cu->per_cu->debug_types_section
d9261 1
a9261 1
					    cu->per_cu->debug_types_section,
d9263 2
a9264 2
      if (sig_type->per_cu.offset.sect_off + sig_type->type_offset.cu_off
	  != die->offset.sect_off)
d10408 7
a10414 4
/* Read the die from the .debug_info section buffer.  Set DIEP to
   point to a newly allocated die with its information, except for its
   child, sibling, and parent fields.  Set HAS_CHILDREN to tell
   whether the die has children or not.  */
d10417 3
a10419 3
read_full_die (const struct die_reader_specs *reader,
	       struct die_info **diep, gdb_byte *info_ptr,
	       int *has_children)
d10444 1
a10444 1
  die = dwarf_alloc_die (cu, abbrev->num_attrs);
d10449 3
d10463 13
d10987 2
a10988 1
	  if (attr.form == DW_FORM_addr)
d11155 1
a11155 1
      if (cu->per_cu->debug_types_section)
d11474 30
d11873 163
d12052 16
d12295 1
a12295 1
   .debug_line, according to the endianness of ABFD.  Return a pointer
d12299 2
a12300 2
   the returned object point into debug_line_buffer, and must not be
   freed.  */
d12303 1
a12303 2
dwarf_decode_line_header (unsigned int offset, bfd *abfd,
			  struct dwarf2_cu *cu)
d12311 10
d12322 2
a12323 2
  dwarf2_read_section (dwarf2_per_objfile->objfile, &dwarf2_per_objfile->line);
  if (dwarf2_per_objfile->line.buffer == NULL)
d12325 4
a12328 1
      complaint (&symfile_complaints, _("missing .debug_line section"));
d12334 1
a12334 1
  if (offset + 4 >= dwarf2_per_objfile->line.size)
d12345 1
a12345 1
  line_ptr = dwarf2_per_objfile->line.buffer + offset;
d12352 1
a12352 2
  if (line_ptr + lh->total_length > (dwarf2_per_objfile->line.buffer
				     + dwarf2_per_objfile->line.size))
d12424 1
a12424 2
  if (line_ptr > (dwarf2_per_objfile->line.buffer
		  + dwarf2_per_objfile->line.size))
d12974 2
a12975 2
     specified.  If this is just a DW_OP_addr then mark this symbol
     as LOC_STATIC.  */
d12978 5
a12982 2
      && DW_BLOCK (attr)->size == 1 + cu_header->addr_size
      && DW_BLOCK (attr)->data[0] == DW_OP_addr)
d12986 6
a12991 2
      SYMBOL_VALUE_ADDRESS (sym) =
	read_address (objfile->obfd, DW_BLOCK (attr)->data + 1, cu, &dummy);
d13442 1
d13470 1
a13665 1
      sect_offset offset;
d13674 10
a13683 4
      gdb_assert (sig_type->per_cu.debug_types_section);
      offset.sect_off = (sig_type->per_cu.offset.sect_off
			 + sig_type->type_offset.cu_off);
      this_type = get_die_type_at_offset (offset, &sig_type->per_cu);
d13700 6
a13705 3
      /* If the type is cached, we should have found it above.  */
      gdb_assert (get_die_type (type_die, type_cu) == NULL);
      this_type = read_type_die_1 (type_die, type_cu);
d14651 11
d14810 4
d15346 1
d15395 1
d15626 1
a15626 1
  if (cu->per_cu->debug_types_section)
d15788 2
a15789 2
  temp_die.offset.sect_off = (sig_type->per_cu.offset.sect_off
			      + sig_type->type_offset.cu_off);
d15837 1
a15837 1
  struct dwarf2_section_info *sect = per_cu->debug_types_section;
d15898 3
a15900 1
/* Read in a signatured type and build its CU and DIEs.  */
d15907 1
a15907 1
  gdb_assert (per_cu->debug_types_section);
d16135 6
d16528 2
d17114 11
d17132 3
a17134 2
  dwarf2_read_section (dwarf2_per_objfile->objfile,
		       &dwarf2_per_objfile->loc);
d17140 2
a17141 2
  baton->size = dwarf2_per_objfile->loc.size - DW_UNSND (attr);
  baton->data = dwarf2_per_objfile->loc.buffer + DW_UNSND (attr);
d17150 1
d17153 1
a17153 1
      /* ".debug_loc" may not exist at all, or the offset may be outside
d17156 1
a17156 2
      && DW_UNSND (attr) < dwarf2_section_size (objfile,
						&dwarf2_per_objfile->loc))
d17531 6
a17536 5
   uniquely identify the type.  A file may have multiple .debug_types sections.
   We have to use something in dwarf2_per_cu_data (or the pointer to it)
   because we can enter the lookup routine, get_die_type_at_offset, from
   outside this file, and thus won't necessarily have PER_CU->cu.
   Fortunately, PER_CU is stable for the life of the objfile.  */
d17806 1
d17817 3
d18365 2
a18366 1
  store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, entry->type_offset.cu_off);
@


1.642
log
@	* dwarf2read.c (dwarf2_read_index): Don't use index if symbol table
	is empty.
@
text
@d214 1
a214 1
  /* Table mapping type .debug_info DIE offsets to types.
d216 2
a217 7
     It (currently) makes sense to allocate debug_types_type_hash lazily.
     To keep things simple we allocate both lazily.  */
  htab_t debug_info_type_hash;

  /* Table mapping type .debug_types DIE sect_offset to types.
     This is NULL if not allocated yet.  */
  htab_t debug_types_type_hash;
d463 1
a463 2
   struct exists to abstract away the constant parameters of die
   reading.  */
d467 1
a467 1
  /* The bfd of this objfile.  */
d473 6
a478 3
  /* Pointer to start of section buffer.
     This is either the start of .debug_info or .debug_types.  */
  const gdb_byte *buffer;
d481 7
a890 4
static gdb_byte *locate_pdi_sibling (struct partial_die_info *orig_pdi,
				     gdb_byte *buffer, gdb_byte *info_ptr,
                                     bfd *abfd, struct dwarf2_cu *cu);

d895 2
a896 1
static void dwarf2_read_abbrevs (struct dwarf2_cu *cu);
d908 8
a915 9
static struct partial_die_info *load_partial_dies (bfd *,
						   gdb_byte *, gdb_byte *,
						   int, struct dwarf2_cu *);

static gdb_byte *read_partial_die (struct partial_die_info *,
                                   struct abbrev_info *abbrev,
				   unsigned int, bfd *,
				   gdb_byte *, gdb_byte *,
				   struct dwarf2_cu *);
d923 3
a925 5
static gdb_byte *read_attribute (struct attribute *, struct attr_abbrev *,
                                 bfd *, gdb_byte *, struct dwarf2_cu *);

static gdb_byte *read_attribute_value (struct attribute *, unsigned,
                                       bfd *, gdb_byte *, struct dwarf2_cu *);
d1101 1
a1101 8
static struct die_info *read_comp_unit (gdb_byte *, struct dwarf2_cu *);

static struct die_info *read_die_and_children_1 (const struct die_reader_specs *reader,
						 gdb_byte *info_ptr,
						 gdb_byte **new_info_ptr,
						 struct die_info *parent);

static struct die_info *read_die_and_children (const struct die_reader_specs *reader,
d1106 1
a1106 1
static struct die_info *read_die_and_siblings (const struct die_reader_specs *reader,
d1111 2
a1112 3
static gdb_byte *read_full_die (const struct die_reader_specs *reader,
				struct die_info **, gdb_byte *,
				int *);
d1209 3
a1211 3
static gdb_byte *skip_one_die (gdb_byte *buffer, gdb_byte *info_ptr,
			       struct abbrev_info *abbrev,
			       struct dwarf2_cu *cu);
d1234 1
a1234 1
static void free_one_cached_comp_unit (void *);
d1277 3
a1279 2
static void init_cu_die_reader (struct die_reader_specs *reader,
				struct dwarf2_cu *cu);
d1283 2
d2233 1
a2233 2
/* A helper for the "quick" functions which attempts to read the line
   table for THIS_CU.  */
d2235 6
a2240 3
static struct quick_file_names *
dw2_get_file_names (struct objfile *objfile,
		    struct dwarf2_per_cu_data *this_cu)
d2242 3
d2248 1
a2248 6
  struct cleanup *cleanups;
  struct die_info *comp_unit_die;
  struct dwarf2_section_info* sec;
  gdb_byte *info_ptr;
  int has_children, i;
  struct dwarf2_cu cu;
a2249 1
  struct die_reader_specs reader_specs;
a2254 34
  if (this_cu->v.quick->file_names != NULL)
    return this_cu->v.quick->file_names;
  /* If we know there is no line data, no point in looking again.  */
  if (this_cu->v.quick->no_file_data)
    return NULL;

  init_one_comp_unit (&cu, this_cu);
  cleanups = make_cleanup (free_stack_comp_unit, &cu);

  if (this_cu->debug_types_section)
    sec = this_cu->debug_types_section;
  else
    sec = &dwarf2_per_objfile->info;
  dwarf2_read_section (objfile, sec);
  info_ptr = sec->buffer + this_cu->offset.sect_off;

  info_ptr = read_and_check_comp_unit_head (&cu.header, sec, info_ptr,
					    this_cu->debug_types_section != NULL);

  /* Skip dummy compilation units.  */
  if (info_ptr >= (sec->buffer + sec->size)
      || peek_abbrev_code (abfd, info_ptr) == 0)
    {
      do_cleanups (cleanups);
      return NULL;
    }

  dwarf2_read_abbrevs (&cu);
  make_cleanup (dwarf2_free_abbrev_table, &cu);

  init_cu_die_reader (&reader_specs, &cu);
  read_full_die (&reader_specs, &comp_unit_die, info_ptr,
		 &has_children);

d2258 2
a2259 1
  attr = dwarf2_attr (comp_unit_die, DW_AT_stmt_list, &cu);
a2272 1
	  do_cleanups (cleanups);
d2274 1
a2274 1
	  return *slot;
d2277 1
a2277 1
      lh = dwarf_decode_line_header (line_offset, abfd, &cu);
a2280 1
      do_cleanups (cleanups);
d2282 1
a2282 1
      return NULL;
d2290 1
a2290 1
  find_file_and_directory (comp_unit_die, &cu, &name, &comp_dir);
a2299 1
  do_cleanups (cleanups);
d2302 20
a2321 1
  return qfn;
d3089 2
a3090 1
			       ULONGEST *signature, cu_offset *type_offset)
d3104 3
a3106 2
  if (type_offset != NULL)
    type_offset->cu_off = read_offset_1 (abfd, info_ptr, header->offset_size);
d3155 2
a3156 2
                               struct die_info *die,
                               struct partial_symtab *pst)
d3232 1
d3261 6
a3266 1
	fprintf_unfiltered (gdb_stdlog, "Signatured types:\n");
d3278 1
d3288 2
d3291 2
a3292 1
	  if (ptr >= end_ptr || peek_abbrev_code (objfile->obfd, ptr) == 0)
d3294 1
a3294 1
	      info_ptr = info_ptr + header.initial_length_size + header.length;
d3326 1
a3326 1
	  info_ptr = info_ptr + header.initial_length_size + header.length;
d3369 2
a3370 1
		    struct dwarf2_cu *cu)
d3372 2
a3373 1
  reader->abfd = cu->objfile->obfd;
d3375 2
a3376 10
  if (cu->per_cu->debug_types_section)
    {
      gdb_assert (cu->per_cu->debug_types_section->readin);
      reader->buffer = cu->per_cu->debug_types_section->buffer;
    }
  else
    {
      gdb_assert (dwarf2_per_objfile->info.readin);
      reader->buffer = dwarf2_per_objfile->info.buffer;
    }
d3410 16
a3425 5
/* Subroutine of process_type_comp_unit and dwarf2_build_psymtabs_hard
   to combine the common parts.
   Process compilation unit THIS_CU for a psymtab.
   SECTION is the section the CU/TU comes from,
   either .debug_info or .debug_types.  */
d3428 4
a3431 3
process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,
			   struct dwarf2_section_info *section,
			   int is_debug_types_section)
d3433 6
a3438 6
  struct objfile *objfile = this_cu->objfile;
  bfd *abfd = objfile->obfd;
  gdb_byte *buffer = section->buffer;
  gdb_byte *info_ptr = buffer + this_cu->offset.sect_off;
  unsigned int buffer_size = section->size;
  gdb_byte *beg_of_comp_unit = info_ptr;
d3440 1
a3440 5
  struct partial_symtab *pst;
  CORE_ADDR baseaddr;
  struct cleanup *back_to_inner;
  struct dwarf2_cu cu;
  int has_children, has_pc_info;
d3442 40
a3481 3
  CORE_ADDR best_lowpc = 0, best_highpc = 0;
  struct die_reader_specs reader_specs;
  const char *filename;
d3483 13
a3495 8
  /* If this compilation unit was already read in, free the
     cached copy in order to read it in again.	This is
     necessary because we skipped some symbols when we first
     read in the compilation unit (see load_partial_dies).
     This problem could be avoided, but the benefit is
     unclear.  */
  if (this_cu->cu != NULL)
    free_one_cached_comp_unit (this_cu->cu);
d3497 7
a3503 6
  /* Note that this is a pointer to our stack frame, being
     added to a global data structure.	It will be cleaned up
     in free_stack_comp_unit when we finish with this
     compilation unit.	*/
  init_one_comp_unit (&cu, this_cu);
  back_to_inner = make_cleanup (free_stack_comp_unit, &cu);
d3505 5
a3509 2
  info_ptr = read_and_check_comp_unit_head (&cu.header, section, info_ptr,
					    is_debug_types_section);
d3512 1
a3512 1
  if (info_ptr >= buffer + buffer_size
d3515 1
a3515 1
      do_cleanups (back_to_inner);
d3519 6
a3524 1
  cu.list_in_scope = &file_symbols;
d3526 3
a3528 3
  /* Read the abbrevs for this compilation unit into a table.  */
  dwarf2_read_abbrevs (&cu);
  make_cleanup (dwarf2_free_abbrev_table, &cu);
d3530 1
a3530 4
  /* Read the compilation unit die.  */
  init_cu_die_reader (&reader_specs, &cu);
  info_ptr = read_full_die (&reader_specs, &comp_unit_die, info_ptr,
			    &has_children);
d3532 1
a3532 1
  if (is_debug_types_section)
d3534 16
a3549 3
      /* LENGTH has not been set yet for type units.  */
      gdb_assert (this_cu->offset.sect_off == cu.header.offset.sect_off);
      this_cu->length = cu.header.length + cu.header.initial_length_size;
d3551 92
a3642 1
  else if (comp_unit_die->tag == DW_TAG_partial_unit)
d3644 1
a3644 1
      do_cleanups (back_to_inner);
d3648 53
a3700 1
  prepare_one_comp_unit (&cu, comp_unit_die);
d3703 1
a3703 1
  attr = dwarf2_attr (comp_unit_die, DW_AT_name, &cu);
d3716 1
a3716 1
  attr = dwarf2_attr (comp_unit_die, DW_AT_comp_dir, &cu);
d3720 1
a3720 1
  pst->read_symtab_private = this_cu;
d3727 1
a3727 1
  this_cu->v.psymtab = pst;
d3729 1
a3729 1
  dwarf2_find_base_address (comp_unit_die, &cu);
d3734 1
a3734 1
				      &best_highpc, &cu, pst);
d3753 1
a3753 1
      first_die = load_partial_dies (abfd, buffer, info_ptr, 1, &cu);
d3756 1
a3756 1
			    ! has_pc_info, &cu);
d3780 1
a3780 1
  if (is_debug_types_section)
d3789 1
a3789 1
      dwarf2_build_include_psymtabs (&cu, comp_unit_die, pst);
d3791 4
d3796 17
a3812 1
  do_cleanups (back_to_inner);
d3819 1
a3819 1
process_type_comp_unit (void **slot, void *info)
d3821 2
a3822 2
  struct signatured_type *entry = (struct signatured_type *) *slot;
  struct dwarf2_per_cu_data *this_cu;
a3824 1
  this_cu = &entry->per_cu;
d3826 13
a3838 2
  gdb_assert (this_cu->debug_types_section->readin);
  process_psymtab_comp_unit (this_cu, this_cu->debug_types_section, 1);
d3853 1
a3853 1
			  process_type_comp_unit, NULL);
d3899 1
a3899 1
      process_psymtab_comp_unit (per_cu, &dwarf2_per_objfile->info, 0);
d3912 5
a3916 1
load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu)
d3918 1
a3918 52
  struct objfile *objfile = this_cu->objfile;
  bfd *abfd = objfile->obfd;
  gdb_byte *info_ptr;
  struct die_info *comp_unit_die;
  struct dwarf2_cu *cu;
  struct cleanup *free_abbrevs_cleanup, *free_cu_cleanup = NULL;
  int has_children;
  struct die_reader_specs reader_specs;
  int read_cu = 0;
  struct dwarf2_section_info *section = &dwarf2_per_objfile->info;

  gdb_assert (! this_cu->debug_types_section);

  gdb_assert (section->readin);
  info_ptr = section->buffer + this_cu->offset.sect_off;

  if (this_cu->cu == NULL)
    {
      cu = xmalloc (sizeof (*cu));
      init_one_comp_unit (cu, this_cu);

      read_cu = 1;

      /* If an error occurs while loading, release our storage.  */
      free_cu_cleanup = make_cleanup (free_heap_comp_unit, cu);

      info_ptr = read_and_check_comp_unit_head (&cu->header, section, info_ptr,
						0);

      /* Skip dummy compilation units.  */
      if (info_ptr >= (section->buffer + section->size)
	  || peek_abbrev_code (abfd, info_ptr) == 0)
	{
	  do_cleanups (free_cu_cleanup);
	  return;
	}
    }
  else
    {
      cu = this_cu->cu;
      info_ptr += cu->header.first_die_offset.cu_off;
    }

  /* Read the abbrevs for this compilation unit into a table.  */
  gdb_assert (cu->dwarf2_abbrevs == NULL);
  dwarf2_read_abbrevs (cu);
  free_abbrevs_cleanup = make_cleanup (dwarf2_free_abbrev_table, cu);

  /* Read the compilation unit die.  */
  init_cu_die_reader (&reader_specs, cu);
  info_ptr = read_full_die (&reader_specs, &comp_unit_die, info_ptr,
			    &has_children);
d3926 2
a3927 1
    load_partial_dies (abfd, section->buffer, info_ptr, 0, cu);
d3929 2
a3930 1
  do_cleanups (free_abbrevs_cleanup);
d3932 7
a3938 10
  if (read_cu)
    {
      /* We've successfully allocated this compilation unit.  Let our
	 caller clean it up when finished with it.  */
      discard_cleanups (free_cu_cleanup);

      /* Link this CU into read_in_chain.  */
      this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = this_cu;
    }
d4557 1
a4557 1
skip_children (gdb_byte *buffer, gdb_byte *info_ptr, struct dwarf2_cu *cu)
d4559 1
d4569 1
a4569 1
	info_ptr = skip_one_die (buffer, info_ptr + bytes_read, abbrev, cu);
d4580 2
a4581 2
skip_one_die (gdb_byte *buffer, gdb_byte *info_ptr,
	      struct abbrev_info *abbrev, struct dwarf2_cu *cu)
d4585 3
a4587 1
  bfd *abfd = cu->objfile->obfd;
d4595 1
a4595 2
	  read_attribute (&attr, &abbrev->attrs[i],
			  abfd, info_ptr, cu);
d4682 1
a4682 1
    return skip_children (buffer, info_ptr, cu);
d4688 1
a4688 2
   INFO_PTR should point to the start of the next DIE after ORIG_PDI
   in BUFFER.  */
d4691 3
a4693 3
locate_pdi_sibling (struct partial_die_info *orig_pdi,
		    gdb_byte *buffer, gdb_byte *info_ptr,
		    bfd *abfd, struct dwarf2_cu *cu)
d4707 1
a4707 1
  return skip_children (buffer, info_ptr, cu);
d4823 1
a4823 1
	    free_one_cached_comp_unit (item->per_cu->cu);
d4875 2
a4876 1
/* Load the DIEs associated with PER_CU into memory.  */
d4878 2
a4879 2
static void
load_full_comp_unit (struct dwarf2_per_cu_data *per_cu)
d4881 1
a4881 8
  struct objfile *objfile = per_cu->objfile;
  bfd *abfd = objfile->obfd;
  struct dwarf2_cu *cu;
  sect_offset offset;
  gdb_byte *info_ptr, *beg_of_comp_unit;
  struct cleanup *free_cu_cleanup = NULL;
  struct attribute *attr;
  int read_cu = 0;
d4883 2
a4884 1
  gdb_assert (! per_cu->debug_types_section);
d4886 2
a4887 2
  /* Set local variables from the partial symbol table info.  */
  offset = per_cu->offset;
d4889 5
a4893 3
  dwarf2_read_section (objfile, &dwarf2_per_objfile->info);
  info_ptr = dwarf2_per_objfile->info.buffer + offset.sect_off;
  beg_of_comp_unit = info_ptr;
d4895 2
a4896 4
  if (per_cu->cu == NULL)
    {
      cu = xmalloc (sizeof (*cu));
      init_one_comp_unit (cu, per_cu);
d4898 3
a4900 1
      read_cu = 1;
d4902 9
a4910 2
      /* If an error occurs while loading, release our storage.  */
      free_cu_cleanup = make_cleanup (free_heap_comp_unit, cu);
d4912 9
a4920 2
      /* Read in the comp_unit header.  */
      info_ptr = read_comp_unit_head (&cu->header, info_ptr, abfd);
d4922 5
a4926 20
      /* Skip dummy compilation units.  */
      if (info_ptr >= (dwarf2_per_objfile->info.buffer
		       + dwarf2_per_objfile->info.size)
	  || peek_abbrev_code (abfd, info_ptr) == 0)
	{
	  do_cleanups (free_cu_cleanup);
	  return;
	}

      /* Complete the cu_header.  */
      cu->header.offset = offset;
      cu->header.first_die_offset.cu_off = info_ptr - beg_of_comp_unit;
    }
  else
    {
      cu = per_cu->cu;
      info_ptr += cu->header.first_die_offset.cu_off;
    }

  cu->dies = read_comp_unit (info_ptr, cu);
d4931 3
a4933 1
     or we won't be able to build types correctly.  */
d4935 3
d4939 4
a4942 5
  /* Similarly, if we do not read the producer, we can not apply
     producer-specific interpretation.  */
  attr = dwarf2_attr (cu->dies, DW_AT_producer, cu);
  if (attr)
    cu->producer = DW_STRING (attr);
d4944 1
a4944 10
  if (read_cu)
    {
      /* We've successfully allocated this compilation unit.  Let our
	 caller clean it up when finished with it.  */
      discard_cleanups (free_cu_cleanup);

      /* Link this CU into read_in_chain.  */
      per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = per_cu;
    }
d5899 3
a5901 3
        {
          cu->line_header = line_header;
          make_cleanup (free_cu_line_header, cu);
d5903 1
a5903 1
        }
d5912 1
a5912 1
  struct objfile *objfile = cu->objfile;
d5936 1
a5936 9
  attr = dwarf2_attr (die, DW_AT_language, cu);
  if (attr)
    {
      set_cu_language (DW_UNSND (attr), cu);
    }

  attr = dwarf2_attr (die, DW_AT_producer, cu);
  if (attr)
    cu->producer = DW_STRING (attr);
d6044 1
a6044 9
  attr = dwarf2_attr (die, DW_AT_language, cu);
  if (attr)
    set_cu_language (DW_UNSND (attr), cu);

  /* This isn't technically needed today.  It is done for symmetry
     with read_file_scope.  */
  attr = dwarf2_attr (die, DW_AT_producer, cu);
  if (attr)
    cu->producer = DW_STRING (attr);
a9431 86
/* Trivial hash function for die_info: the hash value of a DIE
   is its offset in .debug_info for this objfile.  */

static hashval_t
die_hash (const void *item)
{
  const struct die_info *die = item;

  return die->offset.sect_off;
}

/* Trivial comparison function for die_info structures: two DIEs
   are equal if they have the same offset.  */

static int
die_eq (const void *item_lhs, const void *item_rhs)
{
  const struct die_info *die_lhs = item_lhs;
  const struct die_info *die_rhs = item_rhs;

  return die_lhs->offset.sect_off == die_rhs->offset.sect_off;
}

/* Read a whole compilation unit into a linked list of dies.  */

static struct die_info *
read_comp_unit (gdb_byte *info_ptr, struct dwarf2_cu *cu)
{
  struct die_reader_specs reader_specs;
  int read_abbrevs = 0;
  struct cleanup *back_to = NULL;
  struct die_info *die;

  if (cu->dwarf2_abbrevs == NULL)
    {
      dwarf2_read_abbrevs (cu);
      back_to = make_cleanup (dwarf2_free_abbrev_table, cu);
      read_abbrevs = 1;
    }

  gdb_assert (cu->die_hash == NULL);
  cu->die_hash
    = htab_create_alloc_ex (cu->header.length / 12,
			    die_hash,
			    die_eq,
			    NULL,
			    &cu->comp_unit_obstack,
			    hashtab_obstack_allocate,
			    dummy_obstack_deallocate);

  init_cu_die_reader (&reader_specs, cu);

  die = read_die_and_children (&reader_specs, info_ptr, &info_ptr, NULL);

  if (read_abbrevs)
    do_cleanups (back_to);

  return die;
}

/* Main entry point for reading a DIE and all children.
   Read the DIE and dump it if requested.  */

static struct die_info *
read_die_and_children (const struct die_reader_specs *reader,
		       gdb_byte *info_ptr,
		       gdb_byte **new_info_ptr,
		       struct die_info *parent)
{
  struct die_info *result = read_die_and_children_1 (reader, info_ptr,
						     new_info_ptr, parent);

  if (dwarf2_die_debug)
    {
      fprintf_unfiltered (gdb_stdlog,
			  "\nRead die from %s of %s:\n",
			  (reader->cu->per_cu->debug_types_section
			   ? ".debug_types"
			   : ".debug_info"),
			  reader->abfd->filename);
      dump_die (result, dwarf2_die_debug);
    }

  return result;
}

d9439 4
a9442 4
read_die_and_children_1 (const struct die_reader_specs *reader,
			 gdb_byte *info_ptr,
			 gdb_byte **new_info_ptr,
			 struct die_info *parent)
d9488 1
a9488 1
	= read_die_and_children_1 (reader, cur_ptr, &cur_ptr, parent);
d9546 2
a9547 2
    info_ptr = read_attribute (&die->attrs[i], &abbrev->attrs[i],
			       abfd, info_ptr, cu);
d9561 3
a9563 1
dwarf2_read_abbrevs (struct dwarf2_cu *cu)
d9565 1
a9565 1
  bfd *abfd = cu->objfile->obfd;
d9582 2
a9583 4
  dwarf2_read_section (dwarf2_per_objfile->objfile,
		       &dwarf2_per_objfile->abbrev);
  abbrev_ptr = (dwarf2_per_objfile->abbrev.buffer
		+ cu_header->abbrev_offset.sect_off);
d9642 2
a9643 2
      if ((unsigned int) (abbrev_ptr - dwarf2_per_objfile->abbrev.buffer)
	  >= dwarf2_per_objfile->abbrev.size)
d9721 2
a9722 2
load_partial_dies (bfd *abfd, gdb_byte *buffer, gdb_byte *info_ptr,
		   int building_psymtab, struct dwarf2_cu *cu)
d9724 1
d9787 1
a9787 2
	      info_ptr = skip_one_die (buffer, info_ptr + bytes_read, abbrev,
				       cu);
d9799 1
a9799 1
	  info_ptr = skip_one_die (buffer, info_ptr + bytes_read, abbrev, cu);
d9819 1
a9819 1
	  info_ptr = skip_one_die (buffer, info_ptr + bytes_read, abbrev, cu);
d9823 2
a9824 2
      info_ptr = read_partial_die (part_die, abbrev, bytes_read, abfd,
				   buffer, info_ptr, cu);
d9854 1
a9854 1
	  info_ptr = locate_pdi_sibling (part_die, buffer, info_ptr, abfd, cu);
d9894 1
a9894 1
	  info_ptr = locate_pdi_sibling (part_die, buffer, info_ptr, abfd, cu);
d9987 1
a9987 1
      info_ptr = locate_pdi_sibling (last_die, buffer, info_ptr, abfd, cu);
d9996 4
a9999 5
read_partial_die (struct partial_die_info *part_die,
		  struct abbrev_info *abbrev,
		  unsigned int abbrev_len, bfd *abfd,
		  gdb_byte *buffer, gdb_byte *info_ptr,
		  struct dwarf2_cu *cu)
d10001 1
d10003 1
d10024 1
a10024 1
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], abfd, info_ptr, cu);
d10248 3
d10253 2
a10254 6
      struct cleanup *back_to;
      struct partial_die_info comp_unit_die;
      struct abbrev_info *abbrev;
      unsigned int bytes_read;
      char *info_ptr;
      struct dwarf2_section_info *sec;
d10256 1
d10258 1
a10258 26

      if (per_cu->debug_types_section)
	sec = per_cu->debug_types_section;
      else
	sec = &dwarf2_per_objfile->info;

      /* Re-read the DIEs, this time reading all of them.
	 NOTE: We don't discard the previous set of DIEs.
	 This doesn't happen very often so it's (hopefully) not a problem.  */
      back_to = make_cleanup (null_cleanup, 0);
      if (per_cu->cu->dwarf2_abbrevs == NULL)
	{
	  dwarf2_read_abbrevs (per_cu->cu);
	  make_cleanup (dwarf2_free_abbrev_table, per_cu->cu);
	}
      info_ptr = (sec->buffer
		  + per_cu->cu->header.offset.sect_off
		  + per_cu->cu->header.first_die_offset.cu_off);
      abbrev = peek_die_abbrev (info_ptr, &bytes_read, per_cu->cu);
      info_ptr = read_partial_die (&comp_unit_die, abbrev, bytes_read,
				   objfile->obfd, sec->buffer, info_ptr,
				   per_cu->cu);
      if (comp_unit_die.has_children)
	load_partial_dies (objfile->obfd, sec->buffer, info_ptr, 0,
			   per_cu->cu);
      do_cleanups (back_to);
d10409 3
a10411 3
read_attribute_value (struct attribute *attr, unsigned form,
		      bfd *abfd, gdb_byte *info_ptr,
		      struct dwarf2_cu *cu)
d10413 2
d10549 1
a10549 1
      info_ptr = read_attribute_value (attr, form, abfd, info_ptr, cu);
d10580 3
a10582 2
read_attribute (struct attribute *attr, struct attr_abbrev *abbrev,
		bfd *abfd, gdb_byte *info_ptr, struct dwarf2_cu *cu)
d10585 1
a10585 1
  return read_attribute_value (attr, abbrev->form, abfd, info_ptr, cu);
a12514 1
      struct dwarf2_cu *sig_cu;
d14675 1
d14683 3
a14685 1
/* Read in a signatured type and build its CU and DIEs.  */
d14688 5
a14692 1
read_signatured_type (struct signatured_type *sig_type)
d14694 2
a14695 7
  struct objfile *objfile = sig_type->per_cu.objfile;
  gdb_byte *types_ptr;
  struct die_reader_specs reader_specs;
  struct dwarf2_cu *cu;
  ULONGEST signature;
  struct cleanup *back_to, *free_cu_cleanup;
  struct dwarf2_section_info *section = sig_type->per_cu.debug_types_section;
d14697 9
a14705 2
  dwarf2_read_section (objfile, section);
  types_ptr = section->buffer + sig_type->per_cu.offset.sect_off;
d14707 5
a14711 28
  gdb_assert (sig_type->per_cu.cu == NULL);

  cu = xmalloc (sizeof (*cu));
  init_one_comp_unit (cu, &sig_type->per_cu);

  /* If an error occurs while loading, release our storage.  */
  free_cu_cleanup = make_cleanup (free_heap_comp_unit, cu);

  types_ptr = read_and_check_type_unit_head (&cu->header, section, types_ptr,
					     &signature, NULL);
  gdb_assert (signature == sig_type->signature);

  cu->die_hash
    = htab_create_alloc_ex (cu->header.length / 12,
			    die_hash,
			    die_eq,
			    NULL,
			    &cu->comp_unit_obstack,
			    hashtab_obstack_allocate,
			    dummy_obstack_deallocate);

  dwarf2_read_abbrevs (cu);
  back_to = make_cleanup (dwarf2_free_abbrev_table, cu);

  init_cu_die_reader (&reader_specs, cu);

  cu->dies = read_die_and_children (&reader_specs, types_ptr, &types_ptr,
				    NULL /*parent*/);
d14716 3
a14718 1
     or we won't be able to build types correctly.  */
d14720 8
d14729 2
a14730 1
  do_cleanups (back_to);
d14732 1
a14732 7
  /* We've successfully allocated this compilation unit.  Let our caller
     clean it up when finished with it.	 */
  discard_cleanups (free_cu_cleanup);

  /* Link this TU into read_in_chain.  */
  sig_type->per_cu.cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
  dwarf2_per_objfile->read_in_chain = &sig_type->per_cu;
a15897 1

d16177 4
d16205 1
a16205 4
   sure to unlink it from the cache.  Also release any associated storage
   and perform cache maintenance.

   Only used during partial symbol parsing.  */
a16217 6

  /* The previous code only did this if per_cu != NULL.
     But that would always succeed, so now we just unconditionally do
     the aging.  This seems like the wrong place to do such aging,
     but cleaning that up is left for later.  */
  age_cached_comp_units ();
d16283 1
a16283 1
free_one_cached_comp_unit (void *target_cu)
d16295 1
a16295 1
      if (per_cu->cu == target_cu)
d16298 1
d16328 10
a16337 3
/* A pair of DIE offset and GDB type pointer.  We store these
   in a hash table separate from the DIEs, and preserve them
   when the DIEs are flushed out of cache.  */
d16339 1
a16339 1
struct dwarf2_offset_and_type
d16341 1
d16346 1
a16346 1
/* Hash function for a dwarf2_offset_and_type.  */
d16349 1
a16349 1
offset_and_type_hash (const void *item)
d16351 1
a16351 1
  const struct dwarf2_offset_and_type *ofs = item;
d16353 1
a16353 1
  return ofs->offset.sect_off;
d16356 1
a16356 1
/* Equality function for a dwarf2_offset_and_type.  */
d16359 1
a16359 1
offset_and_type_eq (const void *item_lhs, const void *item_rhs)
d16361 2
a16362 2
  const struct dwarf2_offset_and_type *ofs_lhs = item_lhs;
  const struct dwarf2_offset_and_type *ofs_rhs = item_rhs;
d16364 2
a16365 1
  return ofs_lhs->offset.sect_off == ofs_rhs->offset.sect_off;
d16389 1
a16389 1
  struct dwarf2_offset_and_type **slot, ofs;
a16390 1
  htab_t *type_hash_ptr;
d16405 1
a16405 6
  if (cu->per_cu->debug_types_section)
    type_hash_ptr = &dwarf2_per_objfile->debug_types_type_hash;
  else
    type_hash_ptr = &dwarf2_per_objfile->debug_info_type_hash;

  if (*type_hash_ptr == NULL)
d16407 8
a16414 8
      *type_hash_ptr
	= htab_create_alloc_ex (127,
				offset_and_type_hash,
				offset_and_type_eq,
				NULL,
				&objfile->objfile_obstack,
				hashtab_obstack_allocate,
				dummy_obstack_deallocate);
d16417 1
d16420 2
a16421 3
  slot = (struct dwarf2_offset_and_type **)
    htab_find_slot_with_hash (*type_hash_ptr, &ofs, ofs.offset.sect_off,
			      INSERT);
d16438 1
a16438 2
  struct dwarf2_offset_and_type *slot, ofs;
  htab_t type_hash;
d16440 1
a16440 5
  if (per_cu->debug_types_section)
    type_hash = dwarf2_per_objfile->debug_types_type_hash;
  else
    type_hash = dwarf2_per_objfile->debug_info_type_hash;
  if (type_hash == NULL)
d16443 1
d16445 1
a16445 1
  slot = htab_find_with_hash (type_hash, &ofs, ofs.offset.sect_off);
@


1.641
log
@       * dwarf2read.c (dwarf2_get_pc_bounds): Check DW_AT_high_pc form to
       see whether it is an address or a constant offset from DW_AT_low_pc.
       (dwarf2_record_block_ranges): Likewise.
       (read_partial_die): Likewise.
@
text
@d2195 4
@


1.640
log
@gdb/
	Fix DW_AT_lower_bound defaults for DWARF-4+.
	* dwarf2read.c (read_subrange_type): Remove initialization of low and
	high.  New variable low_default_is_valid.  Implement DWARF-4+
	DW_AT_lower_bound defaults.  Print complaint for DW_AT_lower_bound with
	no default by the DWARF standard.
@
text
@d6709 1
d6714 2
a6715 2
  attr = dwarf2_attr (die, DW_AT_high_pc, cu);
  if (attr)
a6716 1
      high = DW_ADDR (attr);
d6719 7
a6725 1
	low = DW_ADDR (attr);
d6873 1
d6875 2
a6876 2
  attr = dwarf2_attr (die, DW_AT_high_pc, cu);
  if (attr)
a6877 2
      CORE_ADDR high = DW_ADDR (attr);

d6882 5
d9938 1
d9995 7
a10001 1
	  part_die->highpc = DW_ADDR (&attr);
d10081 3
@


1.639
log
@	Initial pass at Go language support.
	* NEWS: Mention Go.
	* Makefile.in (SFILES): Add go-exp.y, go-lang.c, go-typeprint.c,
	go-valprint.c.
	(COMMON_OBS): Add go-lang.o, go-val.print.o, go-typeprint.o.
	(YYFILES): Add go-exp.c.
	(YYOBJ): Add go-exp.o.
	(local-maintainer-clean): Delete go-exp.c.
	* defs.h (enum language): Add language_go.
	* dwarf2read.c: #include "go-lang.h".
	(fixup_go_packaging): New function.
	(process_full_comp_unit): Call it when processing Go CUs.
	(dwarf2_physname): Add Go support.
	(read_file_scope): Handle missing language spec for GNU Go.
	(set_cu_language): Handle DW_LANG_Go.
	* go-exp.y: New file.
	* go-lang.h: New file.
	* go-lang.c: New file.
	* go-typeprint.c: New file.
	* go-valprint.c: New file.
	* symtab.c: #include "go-lang.h".
	(symbol_set_language): Handle language_go.
	(symbol_find_demangled_name, symbol_set_names): Ditto.
	(symbol_natural_name, demangle_for_lookup, find_main_name): Ditto.

	testsuite/
	* configure.ac: Create gdb.go/Makefile.
	* configure: Regenerate.
	* gdb.base/default.exp: Add "go" to "set language" testing.
	* gdb.go/Makefile.in: New file.
	* gdb.go/basic-types.exp: New file.
	* gdb.go/chan.exp: New file.
	* gdb.go/chan.go: New file.
	* gdb.go/handcall.exp: New file.
	* gdb.go/handcall.go: New file.
	* gdb.go/hello.exp: New file.
	* gdb.go/hello.go: New file.
	* gdb.go/integers.exp: New file.
	* gdb.go/integers.go: New file.
	* gdb.go/methods.exp: New file.
	* gdb.go/methods.go: New file.
	* gdb.go/package.exp: New file.
	* gdb.go/package1.go: New file.
	* gdb.go/package2.go: New file.
	* gdb.go/print.exp: New file.
	* gdb.go/strings.exp: New file.
	* gdb.go/strings.go: New file.
	* gdb.go/types.exp: New file.
	* gdb.go/types.go: New file.
	* gdb.go/unsafe.exp: New file.
	* gdb.go/unsafe.go: New file.
	* lib/future.exp: Add Go support.
	(gdb_find_go, gdb_find_go_linker): New procs.
	(gdb_default_target_compile): Add Go support.
	* lib/gdb.exp (skip_go_tests): New proc.
	* lib/go.exp: New file.

	doc/
	* gdb.texinfo (Supported Languages): Add Go.
	(Go): New node.
@
text
@d9089 2
a9090 2
  LONGEST low = 0;
  LONGEST high = -1;
d9103 22
a9124 3
  if (cu->language == language_fortran)
    {
      /* FORTRAN implies a lower bound of 1, if not given.  */
d9126 6
d9139 5
a9143 1
    low = dwarf2_get_attr_constant_value (attr, 0);
@


1.638
log
@	* dwarf2read.c (partial_die_full_name): Record DW_FORM_ref_addr in
	attr.u.unsnd instead of attr.u.addr.
	(read_attribute_value) Ditto for cases DW_FORM_ref_addr,
	DW_FORM_ref1, DW_FORM_ref2, DW_FORM_ref4, DW_FORM_reg8,
	DW_FORM_ref_udata.
	(dump_die_shallow): Update cases DW_FORM_ref_addr,
	DW_FORM_ref1, DW_FORM_ref2, DW_FORM_ref4.  Add cases DW_FORM_ref8,
	DW_FORM_ref_udata.
	(dwarf2_get_ref_die_offset): Use DW_UNSND for reference attributes.
@
text
@d62 1
d4826 72
d4922 4
d5135 8
a5142 2
   compute the physname for the object, which include a method's
   formal parameters (C++/Java) and return type (Java).
d5439 15
a5453 4
      demangled = cplus_demangle (mangled, (DMGL_PARAMS | DMGL_ANSI
					    | (cu->language == language_java
					       ? DMGL_JAVA | DMGL_RET_POSTFIX
					       : DMGL_RET_DROP)));
d5781 4
d10860 3
@


1.637
log
@gdb/
	Fix 64-bit constants on 32-bit hosts.
	* dwarf2read.c (read_unsigned_leb128): Change declaration return type
	from unsigned long to ULONGEST.
	(read_signed_leb128): Change declaration return type from long to
	LONGEST.
	(dwarf2_const_value_attr): Change declaration parameter value from long
	to LONGEST.
	(dwarf2_compute_name): Change variable value from long to LONGEST.
	(read_unsigned_leb128): Change return type, variable result and some
	casts from unsigned long to ULONGEST.
	(read_signed_leb128): Change return type, variable result and some
	casts from long to LONGEST.
	(dwarf2_const_value_data, dwarf2_const_value_attr): Change parameter
	value from long to LONGEST.
	(dwarf2_const_value): Change variable value from long to LONGEST.
	* symmisc.c (print_symbol): Change SYMBOL_VALUE format strings to use
	plongest and hex_string.
	* symtab.h (struct general_symbol_info): Change ivalue from long to
	LONGEST, remove the comment.
	* tracepoint.c (validate_actionline, collect_symbol, scope_info):
	Change SYMBOL_VALUE format strings to use plongest and hex_string.
@
text
@d3999 1
d4023 1
a4023 1
	  attr.u.addr = pdi->offset.sect_off;
d10230 1
a10230 1
	DW_ADDR (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
d10232 2
a10233 2
	DW_ADDR (attr) = read_offset (abfd, info_ptr,
				      &cu->header, &bytes_read);
d10320 2
a10321 2
      DW_ADDR (attr) = (cu->header.offset.sect_off
			+ read_1_byte (abfd, info_ptr));
d10325 2
a10326 2
      DW_ADDR (attr) = (cu->header.offset.sect_off
			+ read_2_bytes (abfd, info_ptr));
d10330 2
a10331 2
      DW_ADDR (attr) = (cu->header.offset.sect_off
			+ read_4_bytes (abfd, info_ptr));
d10335 2
a10336 2
      DW_ADDR (attr) = (cu->header.offset.sect_off
			+ read_8_bytes (abfd, info_ptr));
d10348 2
a10349 2
      DW_ADDR (attr) = (cu->header.offset.sect_off
			+ read_unsigned_leb128 (abfd, info_ptr, &bytes_read));
a13973 1
	case DW_FORM_ref_addr:
d13989 4
d13996 2
d13999 1
a13999 1
			      (long) (DW_ADDR (&die->attrs[i])));
d14138 1
a14138 1
  sect_offset retval = { DW_ADDR (attr) };
@


1.636
log
@gdb/
	PR symtab/7259:
	* ada-exp.y (convert_char_literal): Use TYPE_FIELD_ENUMVAL.
	* ada-lang.c (ada_discrete_type_high_bound)
	(ada_discrete_type_low_bound): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(ada_identical_enum_types_p): Use TYPE_FIELD_ENUMVAL.
	(pos_atr, value_val_atr): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* ada-typeprint.c (print_enum_type): Change variable lastval to LONGEST.
	Use TYPE_FIELD_ENUMVAL.
	* ada-valprint.c (print_optional_low_bound, ada_print_scalar)
	(ada_val_print_1): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	* c-typeprint.c (c_type_print_base): Move variable lastval to inner
	block, change it to LONGEST.  Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* coffread.c (coff_read_enum_type): Use SET_FIELD_ENUMVAL.
	* dwarf2read.c (process_enumeration_scope): Likewise.
	* gdb-gdb.py (TypeFlagsPrinter): Use field.enumval instead of
	field.bitpos.
	(class StructMainTypePrettyPrinter): Support also
	FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.c (get_discrete_bounds): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	(recursive_dump_type): Use TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(copy_type_recursive): Support also FIELD_LOC_KIND_ENUMVAL.
	* gdbtypes.h (enum field_loc_kind): New FIELD_LOC_KIND_ENUMVAL.
	(struct main_type.flds_bnds.fields.loc): Adjust bitpos comment.  New
	field enumval.
	(struct main_type.flds_bnds.bields): Adjust loc_kind and bitsize to
	accommodate enumval.
	(struct call_site): Adjust loc_kind to accommodate enumval.
	(FIELD_ENUMVAL, FIELD_ENUMVAL_LVAL, SET_FIELD_ENUMVAL)
	(TYPE_FIELD_ENUMVAL): New macros.
	* m2-typeprint.c (m2_enum): Use TYPE_FIELD_ENUMVAL.
	* mdebugread.c (parse_symbol): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* p-typeprint.c (pascal_type_print_base): Likewise.
	* python/lib/gdb/printing.py (class FlagEnumerationPrinter): Use
	enumval.
	* python/lib/gdb/types.py (make_enum_dict): Likewise.
	* python/py-type.c (convert_field): New variable addrstring.  Use
	TYPE_FIELD_ENUMVAL for TYPE_CODE_ENUM.
	(check_types_equal): Support also FIELD_LOC_KIND_ENUMVAL.
	* stabsread.c (read_enum_type): Use SET_FIELD_ENUMVAL.
	* typepint.c (print_type_scalar): Use TYPE_FIELD_ENUMVAL for
	TYPE_CODE_ENUM.
	* valprint.c (generic_val_print): Likewise.

gdb/testsuite/
	PR symtab/7259:
	* gdb.base/enumval.c: New test case.
	* gdb.base/enumval.exp: New test case.
	* gdb.python/py-type.exp (test_enums): Use field.enumval instead of
	field.bitpos.
@
text
@d960 1
a960 1
static unsigned long read_unsigned_leb128 (bfd *, gdb_byte *, unsigned int *);
d962 1
a962 1
static long read_signed_leb128 (bfd *, gdb_byte *, unsigned int *);
d1011 1
a1011 1
				     struct dwarf2_cu *cu, long *value,
d5149 1
a5149 1
		  long value;
d10667 1
a10667 1
static unsigned long
d10670 1
a10670 1
  unsigned long result;
d10684 1
a10684 1
      result |= ((unsigned long)(byte & 127) << shift);
d10695 1
a10695 1
static long
d10698 1
a10698 1
  long result;
d10711 1
a10711 1
      result |= ((long)(byte & 127) << shift);
d10719 1
a10719 1
    result |= -(((long)1) << shift);
d12044 1
a12044 1
			 struct dwarf2_cu *cu, long *value, int bits)
d12078 1
a12078 1
			 long *value, gdb_byte **bytes,
d12185 1
a12185 1
  long value;
@


1.635
log
@	* dwarf2read.c (lookup_signatured_type): Return NULL instead of 0.
@
text
@d8054 1
a8054 1
		  SET_FIELD_BITPOS (fields[num_fields], SYMBOL_VALUE (sym));
@


1.634
log
@	* dwarf2read.c: Whitespace fixes.
	(lookup_signatured_type): Tweak comment.
	(get_die_type_at_offset): Fix comment.
@
text
@d3365 1
a3365 1
      return 0;
@


1.633
log
@2012-04-17  Pedro Alves  <palves@@redhat.com>

	* gdbtypes.h (FIELD_BITPOS): Rename to ...
	(FIELD_BITPOS_LVAL): ... this.
	(FIELD_BITPOS): New.
	(SET_FIELD_BITPOS): Adjust to use FIELD_BITPOS_LVAL.
	* dwarf2read.c (dwarf2_add_field): Use SET_FIELD_BITPOS.
	* gdbtypes.c (append_composite_type_field_aligned): Adjust to use
	SET_FIELD_BITPOS.
	* gnu-v3-abi.c (build_gdb_vtable_type): Adjust to use
	SET_FIELD_BITPOS.
	* stabsread.c (read_cpp_abbrev, read_one_struct_field)
	(read_baseclasses): Adjust to use SET_FIELD_BITPOS.
	* target-descriptions.c (tdesc_gdb_type): Adjust to use
	SET_FIELD_BITPOS.
@
text
@d3353 1
a3353 1
/* Lookup a signature based type.
d6603 1
d6761 1
d15675 1
d15695 1
d15717 1
d16239 1
a16239 1
/* Look up the type for the die at DIE_OFFSET in the appropriate type_hash
@


1.632
log
@	* dwarf2read.c (lookup_signatured_type): Remove arg "objfile", unused.
	All callers updated.
@
text
@d7069 1
a7069 1
	      FIELD_BITPOS (*fp) += DW_UNSND (attr);
d7098 4
a7101 2
	      FIELD_BITPOS (*fp) += anonymous_size * bits_per_byte
		- bit_offset - FIELD_BITSIZE (*fp);
@


1.631
log
@	* dwarf2read.c (create_all_type_units): Renamed from
	create_debug_types_hash_table.  All callers updated.
@
text
@d3354 1
a3354 1
   Returns NULL if SIG is not present in the table.  */
d3357 1
a3357 1
lookup_signatured_type (struct objfile *objfile, ULONGEST sig)
d10339 1
a10339 1
	lookup_signatured_type (cu->objfile, read_8_bytes (abfd, info_ptr));
@


1.630
log
@	* dwarf2read.c (create_signatured_type_table_from_index): Rename
	local type_sig to sig_type, type_offset to type_offset_in_tu.
	(hash_signatured_type): Renamed from hash_type_signature,
	all callers updated.
	(eq_signatured_type): Renamed from eq_type_signature,
	all callers updated.
	(create_debug_types_hash_table): Rename local type_sig to sig_type.
	(process_enumeration_scope): Ditto.
	(lookup_signatured_type_at_offset): Ditto.
	(load_full_type_unit, read_signatured_type): Ditto.
@
text
@d1250 1
a1250 1
static int create_debug_types_hash_table (struct objfile *objfile);
d2955 1
a2955 1
      create_debug_types_hash_table (objfile);
d3244 2
a3245 2
   The result is zero if there is an error (e.g. missing .debug_types section),
   otherwise non-zero.	*/
d3248 1
a3248 1
create_debug_types_hash_table (struct objfile *objfile)
d3621 1
a3621 1
  if (! create_debug_types_hash_table (objfile))
@


1.629
log
@	* dwarf2read.c (dwarf2_per_cu_data). Clarify comment.
	(load_partial_dies): Clarify comment.
	(find_partial_die): Support rereading type units.
	Clarify CU handling, if we know offset is in CU, don't search for the
	containing CU.  Add comment regarding memory waste.
@
text
@d1189 1
a1189 1
static void read_signatured_type (struct signatured_type *type_sig);
d1927 2
a1928 2
      struct signatured_type *type_sig;
      ULONGEST offset, type_offset, signature;
d1932 1
a1932 1
	  || !extract_cu_value (bytes + 8, &type_offset))
d1937 1
a1937 1
      type_sig = OBSTACK_ZALLOC (&objfile->objfile_obstack,
d1939 6
a1944 6
      type_sig->signature = signature;
      type_sig->type_offset.cu_off = type_offset;
      type_sig->per_cu.debug_types_section = section;
      type_sig->per_cu.offset.sect_off = offset;
      type_sig->per_cu.objfile = objfile;
      type_sig->per_cu.v.quick
d1948 2
a1949 2
      slot = htab_find_slot (sig_types_hash, type_sig, INSERT);
      *slot = type_sig;
d1951 1
a1951 1
      dwarf2_per_objfile->all_type_units[i / 3] = &type_sig->per_cu;
d3198 1
a3198 1
hash_type_signature (const void *item)
d3200 1
a3200 1
  const struct signatured_type *type_sig = item;
d3203 1
a3203 1
  return type_sig->signature;
d3207 1
a3207 1
eq_type_signature (const void *item_lhs, const void *item_rhs)
d3221 2
a3222 2
			       hash_type_signature,
			       eq_type_signature,
d3286 1
a3286 1
	  struct signatured_type *type_sig;
d3306 7
a3312 7
	  type_sig = obstack_alloc (&objfile->objfile_obstack, sizeof (*type_sig));
	  memset (type_sig, 0, sizeof (*type_sig));
	  type_sig->signature = signature;
	  type_sig->type_offset = type_offset;
	  type_sig->per_cu.objfile = objfile;
	  type_sig->per_cu.debug_types_section = section;
	  type_sig->per_cu.offset = offset;
d3314 1
a3314 1
	  slot = htab_find_slot (types_htab, type_sig, INSERT);
d3327 1
a3327 1
	  *slot = type_sig;
d8086 1
a8086 1
      struct signatured_type *type_sig;
d8088 1
a8088 1
      type_sig
d8092 1
a8092 1
      if (type_sig->per_cu.offset.sect_off + type_sig->type_offset.cu_off
d14430 1
a14430 1
  struct signatured_type find_entry, *type_sig;
d14438 1
a14438 1
  type_sig = htab_find (dwarf2_per_objfile->signatured_types, &find_entry);
d14442 2
a14443 2
  gdb_assert (type_sig != NULL);
  gdb_assert (offset.sect_off == type_sig->per_cu.offset.sect_off);
d14445 1
a14445 1
  return type_sig;
d14456 1
a14456 1
  struct signatured_type *type_sig;
d14466 1
a14466 1
  type_sig = lookup_signatured_type_at_offset (objfile, sect, offset);
d14468 1
a14468 1
  gdb_assert (type_sig->per_cu.cu == NULL);
d14470 1
a14470 1
  read_signatured_type (type_sig);
d14472 1
a14472 1
  gdb_assert (type_sig->per_cu.cu != NULL);
d14478 1
a14478 1
read_signatured_type (struct signatured_type *type_sig)
d14480 1
a14480 1
  struct objfile *objfile = type_sig->per_cu.objfile;
d14486 1
a14486 1
  struct dwarf2_section_info *section = type_sig->per_cu.debug_types_section;
d14489 1
a14489 1
  types_ptr = section->buffer + type_sig->per_cu.offset.sect_off;
d14491 1
a14491 1
  gdb_assert (type_sig->per_cu.cu == NULL);
d14494 1
a14494 1
  init_one_comp_unit (cu, &type_sig->per_cu);
d14501 1
a14501 1
  gdb_assert (signature == type_sig->signature);
d14533 2
a14534 2
  type_sig->per_cu.cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
  dwarf2_per_objfile->read_in_chain = &type_sig->per_cu;
@


1.628
log
@	* dwarf2read.c (load_partial_dies): Change condition to assert.
@
text
@d418 3
a420 3
  /* This flag will be set if we need to load absolutely all DIEs
     for this compilation unit, instead of just the ones we think
     are interesting.  It gets set if we look for a DIE in the
a9518 1

d9581 1
a9581 1
      /* We only recurse into subprograms looking for template arguments.
d9998 1
a9998 1
  if (cu->per_cu->debug_types_section)
d10003 3
a10005 1
      goto not_found;
d10007 1
a10007 2

  if (offset_in_cu_p (&cu->header, offset))
d10009 9
a10017 4
      pd = find_partial_die_in_comp_unit (offset, cu);
      if (pd != NULL)
	return pd;
    }
d10019 2
a10020 1
  per_cu = dwarf2_find_containing_comp_unit (offset, objfile);
d10022 3
a10024 5
  if (per_cu->cu == NULL || per_cu->cu->partial_dies == NULL)
    load_partial_comp_unit (per_cu);

  per_cu->cu->last_used = 0;
  pd = find_partial_die_in_comp_unit (offset, per_cu->cu);
d10033 1
d10037 8
a10044 1
      /* Re-read the DIEs.  */
d10051 1
a10051 1
      info_ptr = (dwarf2_per_objfile->info.buffer
d10056 1
a10056 2
				   objfile->obfd,
				   dwarf2_per_objfile->info.buffer, info_ptr,
d10059 2
a10060 3
	load_partial_dies (objfile->obfd,
			   dwarf2_per_objfile->info.buffer, info_ptr,
			   0, per_cu->cu);
a10065 2
 not_found:

@


1.627
log
@gdb/
	Code cleanupp: Use cu_offset and sect_offset compile time type checking.
	* dwarf2expr.c (add_piece, dwarf_get_base_type, execute_stack_op)
	(ctx_no_dwarf_call, ctx_no_get_base_type): Use cu_offset and
	sect_offset.
	* dwarf2expr.h (cu_offset, sect_offset): New types.
	(struct dwarf_expr_context_funcs) <dwarf_call>
	(struct dwarf_expr_context_funcs) <get_base_type>: Use cu_offset and
	sect_offset.
	(struct dwarf_expr_context) <len>: Improve the comment.
	(struct dwarf_expr_piece, ctx_no_dwarf_call, ctx_no_get_base_type): Use
	cu_offset and sect_offset.
	* dwarf2loc.c (per_cu_dwarf_call, dwarf_expr_dwarf_call)
	(dwarf_expr_get_base_type, needs_frame_dwarf_call)
	(dwarf2_compile_expr_to_ax, disassemble_dwarf_expression): Likewise.
	* dwarf2loc.h: Include dwarf2expr.h.
	(dwarf2_fetch_die_location_block, dwarf2_get_die_type): Use cu_offset
	and sect_offset.
	* dwarf2read.c (struct dwarf2_per_objfile) <debug_types_type_hash>:
	Improve the comment.
	(struct comp_unit_head, struct dwarf2_cu, struct dwarf2_per_cu_data)
	(struct signatured_type, struct line_header, struct partial_die_info)
	(struct die_info, find_partial_die, dwarf2_get_ref_die_offset)
	(lookup_signatured_type_at_offset, dwarf2_find_containing_comp_unit)
	(get_die_type_at_offset, create_cus_from_index)
	(create_signatured_type_table_from_index, dw2_get_file_names)
	(offset_in_cu_p, read_comp_unit_head, error_check_comp_unit_head)
	(read_and_check_comp_unit_head, read_and_check_type_unit_head)
	(create_debug_types_hash_table, process_psymtab_comp_unit)
	(load_partial_comp_unit, create_all_comp_units)
	(partial_die_parent_scope, partial_die_full_name, skip_one_die)
	(load_full_comp_unit, dwarf2_physname, read_import_statement)
	(inherit_abstract_dies, read_func_scope, read_call_site_scope)
	(dwarf2_add_member_fn, process_enumeration_scope, read_module_type)
	(read_typedef, die_hash, die_eq, read_full_die, dwarf2_read_abbrevs)
	(load_partial_dies, read_partial_die, find_partial_die_in_comp_unit)
	(find_partial_die, read_attribute_value, lookup_die_type)
	(dump_die_shallow, store_in_ref_table): Use cu_offset and sect_offset.
	(is_ref_attr): New function comment.
	(dwarf2_get_ref_die_offset): New function comment, new variable retval.
	Use cu_offset and sect_offset.
	(follow_die_offset, follow_die_ref, dwarf2_fetch_die_location_block)
	(dwarf2_get_die_type, follow_die_sig, lookup_signatured_type_at_offset)
	(load_full_type_unit, read_signatured_type, per_cu_header_read_in)
	(dwarf2_find_containing_comp_unit, struct dwarf2_offset_and_type)
	(offset_and_type_hash, offset_and_type_eq, set_die_type)
	(get_die_type_at_offset, partial_die_hash, partial_die_eq)
	(write_one_signatured_type, write_psymtabs_to_index): Use cu_offset and
	sect_offset.
@
text
@d9525 2
a9526 1
  if (cu->per_cu && cu->per_cu->load_all_dies)
@


1.626
log
@gdb/
	PR symtab/13777
	* dwarf2read.c (process_full_comp_unit): Set LOCATIONS_VALID only for
	GCC >=4.5.

gdb/testsuite/
	PR symtab/13777
	* gdb.dwarf2/dw2-skip-prologue.S (DW_AT_producer): Set it to 4.5.0.
@
text
@d219 1
a219 1
  /* Table mapping type .debug_types DIE offsets to types.
d263 1
a263 1
  unsigned int abbrev_offset;
d273 1
a273 1
  unsigned int offset;
d277 1
a277 1
  unsigned int first_die_offset;
d341 2
a342 1
  /* Hash table holding all the loaded partial DIEs.  */
d361 2
a362 1
  /* A hash table of die offsets for following references.  */
d411 1
a411 1
  unsigned int offset;
d457 2
a458 2
  /* Offset in .debug_types of the type defined by this TU.  */
  unsigned int type_offset;
d535 1
a535 1
    unsigned int offset;
d590 1
a590 1
    unsigned int spec_offset;
d654 1
a654 1
    unsigned int offset;
d916 1
a916 1
static struct partial_die_info *find_partial_die (unsigned int,
d1167 1
a1167 1
static unsigned int dwarf2_get_ref_die_offset (struct attribute *);
d1185 1
a1185 2
     struct dwarf2_section_info *section,
     unsigned int offset);
d1229 1
a1229 1
  (unsigned int offset, struct objfile *objfile);
d1263 1
a1263 1
static struct type *get_die_type_at_offset (unsigned int,
d1895 1
a1895 1
      the_cu->offset = offset;
d1940 1
a1940 1
      type_sig->type_offset = type_offset;
d1942 1
a1942 1
      type_sig->per_cu.offset = offset;
d2272 1
a2272 1
  info_ptr = sec->buffer + this_cu->offset;
d2998 1
a2998 1
offset_in_cu_p (const struct comp_unit_head *cu_header, unsigned int offset)
d3000 3
a3002 4
  unsigned int bottom = cu_header->offset;
  unsigned int top = (cu_header->offset
		      + cu_header->length
		      + cu_header->initial_length_size);
d3004 1
a3004 1
  return (offset >= bottom && offset < top);
d3024 2
a3025 2
  cu_header->abbrev_offset = read_offset (abfd, info_ptr, cu_header,
					  &bytes_read);
d3054 1
a3054 1
  if (header->abbrev_offset
d3059 1
a3059 1
	   (long) header->abbrev_offset, (long) header->offset,
d3064 1
a3064 1
  if (((unsigned long) header->offset
d3069 1
a3069 1
	   (long) header->length, (long) header->offset,
d3086 1
a3086 1
  header->offset = beg_of_comp_unit - section->buffer;
d3095 1
a3095 1
  header->first_die_offset = info_ptr - beg_of_comp_unit;
d3109 1
a3109 1
			       ULONGEST *signature, unsigned int *type_offset)
d3114 1
a3114 1
  header->offset = beg_of_comp_unit - section->buffer;
d3124 1
a3124 1
    *type_offset = read_offset_1 (abfd, info_ptr, header->offset_size);
d3127 1
a3127 1
  header->first_die_offset = info_ptr - beg_of_comp_unit;
d3283 2
a3284 2
	  unsigned int offset;
	  unsigned int type_offset;
d3291 1
a3291 1
	  offset = ptr - section->buffer;
d3323 1
a3323 1
			 offset, dup_sig->per_cu.offset,
d3331 2
a3332 1
				offset, phex (signature, sizeof (signature)));
d3438 1
a3438 1
  gdb_byte *info_ptr = buffer + this_cu->offset;
d3493 1
a3493 1
      gdb_assert (this_cu->offset == cu.header.offset);
d3700 1
a3700 1
  info_ptr = section->buffer + this_cu->offset;
d3726 1
a3726 1
      info_ptr += cu->header.first_die_offset;
d3785 1
a3785 1
      unsigned int offset;
d3787 1
a3787 1
      offset = info_ptr - dwarf2_per_objfile->info.buffer;
d3989 1
a3989 1
		 parent->tag, pdi->offset);
d4019 1
d4022 1
a4022 1
	  attr.u.addr = pdi->offset;
d4417 1
a4417 1
	    return buffer + dwarf2_get_ref_die_offset (&attr);
d4701 1
a4701 1
  unsigned int offset;
d4713 1
a4713 1
  info_ptr = dwarf2_per_objfile->info.buffer + offset;
d4740 1
a4740 1
      cu->header.first_die_offset = info_ptr - beg_of_comp_unit;
d4745 1
a4745 1
      info_ptr += cu->header.first_die_offset;
d5384 1
a5384 1
		     physname, canon, mangled, die->offset, objfile->name);
d5521 1
a5521 1
		       child_die->offset, objfile->name);
d5542 1
a5542 1
		       child_die->offset, objfile->name);
d5849 2
a5850 2
  unsigned *offsets;
  unsigned *offsets_end, *offsetp;
d5880 1
a5880 1
	       die->offset, origin_die->offset);
d5923 2
a5924 2
			 "different tags"), child_die->offset,
		       child_origin_die->offset);
d5928 2
a5929 2
			 "different parents"), child_die->offset,
		       child_origin_die->offset);
d5938 1
a5938 1
    if (offsetp[-1] == *offsetp)
d5942 1
a5942 1
		 die->offset, *offsetp);
d5949 2
a5950 1
      while (offsetp < offsets_end && *offsetp < origin_child_die->offset)
d5952 2
a5953 1
      if (offsetp >= offsets_end || *offsetp > origin_child_die->offset)
d6004 2
a6005 1
                 _("missing name for subprogram DIE at %d"), die->offset);
d6017 1
a6017 1
		   die->offset);
d6229 1
a6229 1
		 die->offset, objfile->name);
d6245 1
a6245 1
		 paddress (gdbarch, pc), die->offset, objfile->name);
d6260 1
a6260 1
		     child_die->tag, child_die->offset, objfile->name);
d6318 1
a6318 1
		       die->offset, objfile->name);
d6355 1
a6355 1
		       die->offset, objfile->name);
d6368 1
a6368 1
		       die->offset, objfile->name);
d6377 1
a6377 1
	       die->offset, objfile->name);
d6406 1
a6406 1
		     child_die->offset, objfile->name);
d6420 1
a6420 1
		     child_die->offset, objfile->name);
d6430 1
a6430 1
		     child_die->offset, objfile->name);
d6448 1
a6448 1
		       child_die->offset, objfile->name);
d7499 1
a7499 1
		     fieldname, die->offset);
d8092 2
a8093 2
      if (type_sig->per_cu.offset + type_sig->type_offset
	  != die->offset)
d8419 1
a8419 1
               die->offset);
d8875 1
a8875 1
		 die->offset, objfile->name);
d9143 1
a9143 1
  return die->offset;
d9155 1
a9155 1
  return die_lhs->offset == die_rhs->offset;
d9304 2
a9305 1
  unsigned int abbrev_number, bytes_read, i, offset;
d9311 1
a9311 1
  offset = info_ptr - reader->buffer;
d9371 2
a9372 1
  abbrev_ptr = dwarf2_per_objfile->abbrev.buffer + cu_header->abbrev_offset;
d9659 1
a9659 1
		   part_die->offset, objfile->name);
d9733 1
a9733 1
					   part_die->offset, INSERT);
d9799 1
a9799 1
  part_die->offset = info_ptr - buffer;
d9892 1
a9892 1
	    part_die->sibling = buffer + dwarf2_get_ref_die_offset (&attr);
d9950 1
a9950 1
		     part_die->offset, objfile->name);
d9962 1
a9962 1
		     part_die->offset, objfile->name);
d9974 1
a9974 1
find_partial_die_in_comp_unit (unsigned int offset, struct dwarf2_cu *cu)
d9980 2
a9981 1
  lookup_die = htab_find_with_hash (cu->partial_dies, &part_die, offset);
d9992 1
a9992 1
find_partial_die (unsigned int offset, struct dwarf2_cu *cu)
d10039 2
a10040 2
		  + per_cu->cu->header.offset
		  + per_cu->cu->header.first_die_offset);
d10061 1
a10061 1
		    offset, bfd_get_filename (objfile->obfd));
d10306 2
a10307 1
      DW_ADDR (attr) = cu->header.offset + read_1_byte (abfd, info_ptr);
d10311 2
a10312 1
      DW_ADDR (attr) = cu->header.offset + read_2_bytes (abfd, info_ptr);
d10316 2
a10317 1
      DW_ADDR (attr) = cu->header.offset + read_4_bytes (abfd, info_ptr);
d10321 2
a10322 1
      DW_ADDR (attr) = cu->header.offset + read_8_bytes (abfd, info_ptr);
d10334 1
a10334 1
      DW_ADDR (attr) = (cu->header.offset
d12296 1
a12296 1
      unsigned int offset = dwarf2_get_ref_die_offset (attr);
d12304 1
a12304 1
      unsigned int offset;
d12311 1
a12311 1
	       die->offset, objfile->name);
d12314 2
a12315 1
      offset = sig_type->per_cu.offset + sig_type->type_offset;
d12347 2
a12348 2
			    cu->header.offset,
			    die->offset);
d13935 1
a13935 1
	   dwarf_tag_name (die->tag), die->abbrev, die->offset);
d13941 1
a13941 1
			  die->parent->offset);
d13998 1
a13998 1
			  DW_SIGNATURED_TYPE (&die->attrs[i])->per_cu.offset);
d14087 2
a14088 1
  slot = htab_find_slot_with_hash (cu->die_hash, die, die->offset, INSERT);
d14093 3
d14113 4
a14116 1
static unsigned int
d14119 2
d14122 1
a14122 1
    return DW_ADDR (attr);
d14124 1
d14128 1
a14128 1
  return 0;
d14225 1
a14225 1
follow_die_offset (unsigned int offset, struct dwarf2_cu **ref_cu)
d14263 1
a14263 1
  return htab_find_with_hash (target_cu->die_hash, &temp_die, offset);
d14274 1
a14274 1
  unsigned int offset = dwarf2_get_ref_die_offset (attr);
d14282 1
a14282 1
	   offset, src_die->offset, cu->objfile->name);
d14292 1
a14292 1
dwarf2_fetch_die_location_block (unsigned int offset_in_cu,
d14297 1
a14297 1
  unsigned int offset = per_cu->offset + offset_in_cu;
d14312 1
a14312 1
	   offset, per_cu->objfile->name);
d14340 1
a14340 1
	       offset, per_cu->objfile->name);
d14356 1
a14356 1
dwarf2_get_die_type (unsigned int die_offset,
d14359 2
d14362 3
a14364 1
  return get_die_type_at_offset (per_cu->offset + die_offset, per_cu);
d14386 1
a14386 1
	   src_die->offset, objfile->name);
d14396 4
a14399 2
  temp_die.offset = sig_cu->header.offset + sig_type->type_offset;
  die = htab_find_with_hash (sig_cu->die_hash, &temp_die, temp_die.offset);
d14408 1
a14408 1
	 sig_type->type_offset, src_die->offset, objfile->name);
d14416 1
a14416 1
				  unsigned int offset)
d14418 1
a14418 1
  gdb_byte *info_ptr = section->buffer + offset;
d14434 1
a14434 1
  gdb_assert (offset == type_sig->per_cu.offset);
d14446 1
a14446 1
  unsigned int offset = per_cu->offset;
d14480 1
a14480 1
  types_ptr = section->buffer + type_sig->per_cu.offset;
d15831 1
a15831 1
  info_ptr = per_objfile->info.buffer + per_cu->offset;
d15898 1
a15898 1
dwarf2_find_containing_comp_unit (unsigned int offset,
d15910 2
a15911 1
      if (dwarf2_per_objfile->all_comp_units[mid]->offset >= offset)
d15917 2
a15918 1
  if (dwarf2_per_objfile->all_comp_units[low]->offset > offset)
d15923 1
a15923 1
	       (long) offset, bfd_get_filename (objfile->obfd));
d15925 2
a15926 1
      gdb_assert (dwarf2_per_objfile->all_comp_units[low-1]->offset <= offset);
d15933 3
a15935 3
	  && offset >= this_cu->offset + this_cu->length)
	error (_("invalid dwarf2 offset %u"), offset);
      gdb_assert (offset < this_cu->offset + this_cu->length);
d16129 1
a16129 1
  unsigned int offset;
d16140 1
a16140 1
  return ofs->offset;
d16151 1
a16151 1
  return ofs_lhs->offset == ofs_rhs->offset;
d16212 2
a16213 1
    htab_find_slot_with_hash (*type_hash_ptr, &ofs, ofs.offset, INSERT);
d16217 1
a16217 1
	       die->offset);
d16227 1
a16227 1
get_die_type_at_offset (unsigned int offset,
d16241 1
a16241 1
  slot = htab_find_with_hash (type_hash, &ofs, ofs.offset);
d16335 1
a16335 1
  return part_die->offset;
d16347 1
a16347 1
  return part_die_lhs->offset == part_die_rhs->offset;
d16955 2
a16956 1
  store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, entry->per_cu.offset);
d16958 1
a16958 1
  store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, entry->type_offset);
d17071 2
a17072 1
      store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, per_cu->offset);
@


1.625
log
@gdb:
	PR breakpoints/10738
	* dwarf2read.c (use_deprecated_index_sections): New global.
	(struct partial_die_info): New member may_be_inlined.
	(read_partial_die): Set may_be_inlined where appropriate.
	(add_partial_subprogram): Add partial symbols for partial
	DIEs that may be inlined.
	(new_symbol_full): Add inlined subroutines to the current
	scope.
	(write_psymtabs_to_index): Bump version number.
	(dwarf2_read_index): Read only version 6 indices unless
	use_deprecated_index_sections is set.
	* linespec.c (symbol_and_data_callback): New structure.
	(iterate_inline_only): New function.
	(iterate_over_all_matching_symtabs): New argument
	"include_inline".  If nonzero, also call the callback for
	symbols representing inlined subroutines.
	(lookup_prefix_sym): Pass extra argument to the above.
	(find_function_symbols): Likewise.
	(add_matching_symbols_to_info): Likewise.
	* NEWS: Mention that GDB can now set breakpoints on inlined
	functions.

gdb/doc:
	PR breakpoints/10738
	* gdb.texinfo (Inline Functions): Remove the now-unnecessary @@item
	stating that GDB cannot set breakpoints on inlined functions.
	(Mode Options): Document --use-deprecated-index-sections.
	(Index Section Format): Document new index section version format.

gdb/testsuite:
	PR breakpoints/10738
	* gdb.opt/inline-break.exp: New file.
	* gdb.opt/inline-break.c: Likewise.
	* gdb.dwarf2/inline-break.exp: Likewise.
	* gdb.dwarf2/inline-break.S: Likewise.
	* gdb.base/annota1.exp: Cope with old .gdb_index warnings.
	* gdb.base/async-shell.exp: Likewise.
	* lib/mi-support.exp (library_loaded_re): Likewise.
@
text
@d4871 3
a4873 1
	 invalid without -fvar-tracking.
d4881 1
a4881 1
      if (cu->has_loclist && gcc_4_minor >= 0)
@


1.624
log
@	* dwarf2read.c (dwarf_stack_op_name): Add DW_OP_GNU_encoded_addr,
	DW_OP_GNU_parameter_ref.
@
text
@d88 3
d545 1
d2125 1
a2125 2
     indices.  Index version 4 uses a different hash function than index
     version 5 and later.  */
d2127 31
a2157 2
    return 0;
  /* Indices with higher version than the one supported by GDB may be no
d2159 1
a2159 1
  if (version > 5)
d4279 4
d9913 5
d11762 1
a11762 2
	  /* Do not add the symbol to any lists.  It will be found via
	     BLOCK_FUNCTION from the blockvector.  */
d17070 1
a17070 1
  val = MAYBE_SWAP (5);
@


1.623
log
@	* dwarf2read.c (load_partial_comp_unit): Defer adding cu to
	read_in_chain until we have successfully read it in.
	(load_full_comp_unit): Ditto.
	(read_signatured_type): Add comment.
@
text
@d13701 2
d13717 2
@


1.622
log
@	* dwarf2read.c (struct dwarf2_cu) <checked_producer,
	producer_is_gxx_lt_4_6>: New fields.
	(producer_is_gxx_lt_4_6): Use and update producer cache fields.
@
text
@a3688 4

      /* Link this CU into read_in_chain.  */
      this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = this_cu;
d3721 4
a4702 4

      /* Link this CU into read_in_chain.  */
      per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = per_cu;
d4729 4
d14448 1
@


1.621
log
@	* dwarf2read.c (dwarf2_attr): Avoid tail-recursive call.
@
text
@d386 7
d6836 1
d6852 3
a6860 2

      return 0;
d6862 1
a6862 4
  cs = &cu->producer[strlen ("GNU ")];
  while (*cs && !isdigit (*cs))
    cs++;
  if (sscanf (cs, "%d.%d.%d", &major, &minor, &release) != 3)
d6864 10
a6873 1
      /* Not recognized as GCC.  */
d6875 2
a6876 2
      return 0;
    }
d6878 1
a6878 1
  return major < 4 || (major == 4 && minor < 6);
@


1.620
log
@gdb/
	Fix CU relative vs. absolute DIE offsets.
	* dwarf2loc.h (dwarf2_fetch_die_location_block): Rename parameter
	offset to offset_in_cu.
	* dwarf2read.c (process_enumeration_scope): Add CU offset to
	TYPE_OFFSET.
	(dwarf2_fetch_die_location_block): Rename parameter offset to
	offset_in_cu.  New variable offset, add CU offset to OFFSET_IN_CU.

gdb/testsuite/
	Fix CU relative vs. absolute DIE offsets.
	* gdb.dwarf2/dw2-op-call.S: New compilation unit preceding the existing
	one.
@
text
@d10711 13
a10723 2
  unsigned int i;
  struct attribute *spec = NULL;
d10725 2
a10726 8
  for (i = 0; i < die->num_attrs; ++i)
    {
      if (die->attrs[i].name == name)
	return &die->attrs[i];
      if (die->attrs[i].name == DW_AT_specification
	  || die->attrs[i].name == DW_AT_abstract_origin)
	spec = &die->attrs[i];
    }
a10727 2
  if (spec)
    {
a10728 1
      return dwarf2_attr (die, name, cu);
@


1.619
log
@Pass absolute die offset in call to get_die_type_at_offset

gdb/ChangeLog:

        * dwarf2read.c (dwarf2_get_die_type): Pass absolute offset
        in call to get_die_type_at_offset.
@
text
@d8034 2
a8035 1
      if (type_sig->type_offset != die->offset)
d14206 1
a14206 1
dwarf2_fetch_die_location_block (unsigned int offset,
d14211 1
@


1.618
log
@	* dwarf2read.c (load_full_comp_unit): Remove unnecessary reading of
	abbrev table, read_comp_unit will do it.
@
text
@d14272 1
a14272 1
  return get_die_type_at_offset (die_offset, per_cu);
@


1.617
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d4658 1
a4658 1
  struct cleanup *free_abbrevs_cleanup = NULL, *free_cu_cleanup = NULL;
a4696 4
      /* Read the abbrevs for this compilation unit.  */
      dwarf2_read_abbrevs (cu);
      free_abbrevs_cleanup = make_cleanup (dwarf2_free_abbrev_table, cu);

a4722 2
      do_cleanups (free_abbrevs_cleanup);

@


1.616
log
@	* dwarf2read.c (dwarf2_cu): Remove unused members has_form_ref_addr,
	has_namespace_info.
	(dwarf2_read_abbrevs): Remove corresponding initialization.
@
text
@d3390 1
a3390 1
void
@


1.615
log
@2012-02-22  Gary Benson  <gbenson@@redhat.com>

	* dwarf2read.c (dwarf2_read_index): Correct misspelling.
	(find_slot_in_mapped_hash): Likewise.
@
text
@a380 10
  /* This flag will be set if this compilation unit might include
     inter-compilation-unit references.  */
  unsigned int has_form_ref_addr : 1;

  /* This flag will be set if this compilation unit includes any
     DW_TAG_namespace DIEs.  If we know that there are explicit
     DIEs for namespaces, we don't need to try to infer them
     from mangled names.  */
  unsigned int has_namespace_info : 1;

a9335 3
      if (cur_abbrev->tag == DW_TAG_namespace)
	cu->has_namespace_info = 1;

a9350 10
	  /* Record whether this compilation unit might have
	     inter-compilation-unit references.  If we don't know what form
	     this attribute will have, then it might potentially be a
	     DW_FORM_ref_addr, so we conservatively expect inter-CU
	     references.  */

	  if (abbrev_form == DW_FORM_ref_addr
	      || abbrev_form == DW_FORM_indirect)
	    cu->has_form_ref_addr = 1;

d10096 1
a10096 3
     name.
     NOTE: We need to do this even if cu->has_namespace_info != 0.
     gcc-4.5 -gdwarf-4 can drop the enclosing namespace.  */
@


1.614
log
@	PR gdb/13498:
	* dwarf2read.c (dw2_expand_symtabs_matching): Only visit a
	particular set of file names once.
	(dw2_map_symbol_filenames): Likewise.
@
text
@d2057 1
a2057 1
     indexes for case insensitive languages are built in lowercase, therefore
d2128 1
a2128 1
  /* Indexes with higher version than the one supported by GDB may be no
@


1.613
log
@	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove
	extraneous block.
@
text
@d2703 30
a2732 6
    for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		     + dwarf2_per_objfile->n_type_units); ++i)
      {
	int j;
	struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
	struct quick_file_names *file_data;
d2734 7
a2740 1
	per_cu->v.quick->mark = 0;
d2742 8
a2749 3
	/* We only need to look at symtabs not already expanded.  */
	if (per_cu->v.quick->symtab)
	  continue;
d2751 6
a2756 3
	file_data = dw2_get_file_names (objfile, per_cu);
	if (file_data == NULL)
	  continue;
d2758 2
a2759 9
	for (j = 0; j < file_data->num_file_names; ++j)
	  {
	    if (file_matcher (file_data->file_names[j], data))
	      {
		per_cu->v.quick->mark = 1;
		break;
	      }
	  }
      }
d2821 3
d2825 1
d2828 15
d2849 1
d2859 8
d2878 2
@


1.612
log
@	* gdbtypes.h (struct main_type): Change type of name,tag_name,
	and fields.name members from char * to const char *.  All uses updated.
	(struct cplus_struct_type): Change type of fn_fieldlists.name member
	from char * to const char *.  All uses updated.
	(type_name_no_tag): Update.
	(lookup_unsigned_typename, lookup_signed_typename): Update.
	* gdbtypes.c (type_name_no_tag): Change result type
	from char * to const char *.  All callers updated.
	(lookup_unsigned_typename, lookup_signed_typename): Change type of
	name parameter from char * to const char *.
	* symtab.h (struct cplus_specific): Change type of demangled_name
	member from char * to const char *.  All uses updated.
	(struct general_symbol_info): Change type of name and
	mangled_lang.demangled_name members from char * to const char *.
	All uses updated.
	(symbol_get_demangled_name, symbol_natural_name): Update.
	(symbol_demangled_name, symbol_search_name): Update.
	* symtab.c (symbol_get_demangled_name): Change result type
	from char * to const char *.  All callers updated.
	(symbol_natural_name, symbol_demangled_name): Ditto.
	(symbol_search_name): Ditto.
	(completion_list_add_name): Change type of symname,sym_text,
	text,word parameters from char * to const char *.
	(completion_list_objc_symbol): Change type of sym_text,
	text,word parameters from char * to const char *.
	* ada-lang.c (find_struct_field): Change type of name parameter
	from char * to const char *.
	(encoded_ordered_before): Similarly for N0,N1 parameters.
	(old_renaming_is_invisible): Similarly for function_name parameter.
	(ada_type_name): Change result type from char * to const char *.
	All callers updated.
	* ada-lang.h (ada_type_name): Update.
	* buildsym.c (hashname): Change type of name parameter
	from char * to const char *.
	* buildsym.h (hashname): Update.
	* dbxread.c (end_psymtab): Change type of include_list parameter
	from char ** to const char **.
	* dwarf2read.c (determine_prefix): Change result type
	from char * to const char *.  All callers updated.
	* f-lang.c (find_common_for_function): Change type of name, funcname
	parameters from char * to const char *.
	* f-lang.c (find_common_for_function): Update.
	* f-valprint.c (list_all_visible_commons): Change type of funcname
	parameters from char * to const char *.
	* gdbarch.sh (static_transform_name): Change type of name parameter
	and result from char * to const char *.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
	* i386-sol2-tdep.c (i386_sol2_static_transform_name): Change type
	of name parameter from char * to const char *.
	* jv-lang.c (java_primitive_type_from_name): Ditto.
	(java_demangled_signature_length): Similarly for signature parameter.
	(java_demangled_signature_copy): Ditto.
	(java_demangle_type_signature): Ditto.
	* jv-lang.h (java_primitive_type_from_name): Update.
	(java_demangle_type_signature): Update.
	* objc-lang.c (specialcmp): Change type of a,b parameters
	from char * to const char *.
	* p-lang.c (is_pascal_string_type): Change type of arrayname parameter
	from char * to const char *.  All callers updated.
	* p-lang.h (is_pascal_string_type): Update.
	* solib-frv.c (find_canonical_descriptor_in_load_object): Change type
	of name parameter from char * to const char *.
	* sparc-sol2-tdep.c (sparc_sol2_static_transform_name): Ditto.
	* utils.c (fprintf_symbol_filtered): Ditto.
	* defs.h (fprintf_symbol_filtered): Update.
	* sparc-tdep.h (sparc_sol2_static_transform_name): Update.
	* stabsread.h (end_psymtab): Update.
	* stack.c (find_frame_funname): Change type of funname parameter
	from char ** to const char **.
	* stack.h (find_frame_funname): Update.
	* typeprint.c (type_print): Change type of varstring parameter
	from char * to const char *.
	* value.h (type_print): Update.
	* xcoffread.c (xcoff_start_psymtab): Change type of filename parameter
	from char * to const char *.  All callers updated.
	(xcoff_end_psymtab): Change type of include_list parameter
	from char ** to const char **.  All callers updated.
	(swap_sym): Similarly for name parameter.  All callers updated.
	* coffread.c (patch_type): Add (char*) cast to xfree parameter.
	Use xstrdup.
	(process_coff_symbol): Use xstrdup.
	* stabsread.c (stabs_method_name_from_physname): Renamed from
	update_method_name_from_physname.  Change result type from void
	to char *.  All callers updated.
	(read_member_functions): In has_destructor case, store name in objfile
	obstack instead of malloc space.  In !has_stub case, fix mem leak.
@
text
@a2439 7
	    {
	      if (dw2_map_expand_apply (objfile, per_cu,
					name, full_path, real_path,
					callback, data))
		return 1;
	    }

@


1.611
log
@	PR breakpoints/13568:
	* dwarf2read.c (dwarf_decode_macro_bytes): Add 'include_hash'
	argument.  Check for recursive includes.
	(dwarf_decode_macros): Create an include hash.
@
text
@d1032 1
a1032 1
static char *determine_prefix (struct die_info *die, struct dwarf2_cu *);
d5016 1
a5016 1
	  char *prefix;
d7732 1
a7732 1
		      char *fieldname = TYPE_FIELD_NAME (t, i);
d12482 1
a12482 1
static char *
@


1.610
log
@	* dwarf2read.c (add_partial_symbol): Delete local psym, unused.
@
text
@d15139 1
a15139 1
   including DW_GNU_MACINFO_transparent_include.  */
d15148 2
a15149 1
			  struct objfile *objfile)
d15324 1
d15329 22
a15350 6
	    dwarf_decode_macro_bytes (abfd,
				      section->buffer + offset,
				      mac_end, current_file,
				      lh, comp_dir,
				      section, section_is_gnu,
				      offset_size, objfile);
d15394 3
d15530 7
a15536 1
  dwarf_decode_macro_bytes (abfd, section->buffer + offset, mac_end,
d15538 2
a15539 1
			    offset_size, objfile);
@


1.609
log
@Remove language param from name_matcher in struct quick_symbol_functions

The quick_symbol_functions struct contains a field which is pointer
a function which takes another function, called name_matcher, as
its parameter.  This name_matcher currently has 3 arguments, one
of them being the language. This parameter is no longer used, and
thus deleted.

gdb/ChangeLog:

        * symfile.h (struct quick_symbol_functions) [expand_symtabs_matching]:
        Remove language parameter from name_matcher.  Adjust the comment.
        * symtab.c (search_symbols_name_matches, expand_partial_symbol_name):
        Remove language parameter.
        * ada-lang.c (ada_expand_partial_symbol_name): Likewise.
        * linespec.c (iterate_name_matcher): Likewise.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust type of
        name_matcher.  Adjust call accordingly.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (maintenance_check_symtabs): Adjust type of parameter "fun".
        * psymtab.h (maintenance_check_symtabs): Likewise.
@
text
@a3956 1
  const struct partial_symbol *psym = NULL;
@


1.608
log
@gdb
	* NEWS: Add item.
	* symtab.h (compare_filenames_for_search): Declare.
	* symtab.c (compare_filenames_for_search): New function.
	(iterate_over_some_symtabs): Use it.
	* symfile.h (struct quick_symbol_functions)
	<map_symtabs_matching_filename>: Change spec.
	* psymtab.c (partial_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* breakpoint.c (clear_command): Use compare_filenames_for_search.
gdb/doc
	* gdb.texinfo (Specify Location): Document relative file name
	handling.
gdb/testsuite
	* gdb.linespec/linespec.exp: Change some tests to use $decimal.
	Add tests for relative directory.
@
text
@d2694 1
a2694 1
   int (*name_matcher) (const struct language_defn *, const char *, void *),
d2748 1
a2748 1
      if (! (*name_matcher) (current_language, name, data))
@


1.607
log
@gdb
	PR python/13281:
	* gdbtypes.h (TYPE_FLAG_ENUM): New macro.
	(struct main_type) <flag_flag_enum>: New field.
	* dwarf2read.c (process_enumeration_scope): Detect "flag" enums.
	* NEWS: Add entries.
	* c-valprint.c (c_val_print) <TYPE_CODE_ENUM>: Handle "flag"
	enums.
	* python/lib/gdb/printing.py (_EnumInstance): New class.
	(FlagEnumerationPrinter): Likewise.
gdb/doc
	* gdb.texinfo (gdb.printing): Document FlagEnumerationPrinter.
gdb/testsuite
	* gdb.base/printcmds.c (enum flag_enum): New.
	(three): New global.
	* gdb.base/printcmds.exp (test_print_enums): Add test for flag
	enum printing.
	* gdb.python/py-pp-maint.py (build_pretty_printer): Instantiate
	FlagEnumerationPrinter.
	* gdb.python/py-pp-maint.exp: Add tests for FlagEnumerationPrinter.
	* gdb.python/py-pp-maint.c (enum flag_enum): New.
	(fval): New global.
@
text
@d2406 2
a2407 2
  int check_basename = name_basename == name;
  struct dwarf2_per_cu_data *base_cu = NULL;
d2430 3
a2432 1
	  if (FILENAME_CMP (name, this_name) == 0)
d2440 6
a2445 3
	  if (check_basename && ! base_cu
	      && FILENAME_CMP (lbasename (this_name), name) == 0)
	    base_cu = per_cu;
d2459 4
a2462 1
		  && FILENAME_CMP (full_path, this_real_name) == 0)
d2477 4
a2480 1
		  && FILENAME_CMP (real_path, this_real_name) == 0)
a2490 8
  if (base_cu)
    {
      if (dw2_map_expand_apply (objfile, base_cu,
				name, full_path, real_path,
				callback, data))
	return 1;
    }

@


1.606
log
@	* dwarf2read.c (dwarf_decode_lines): Remove arg "abfd".  New arg
	"want_line_info".  All callers updated.
	(dwarf_decode_lines_1): New function.
	(handle_DW_AT_stmt_list): Add function comment.
	New arg "want_line_info".  All callers updated.
	(read_file_scope,read_type_unit_scope): Move comment from
	handle_DW_AT_stmt_list to here.
@
text
@d7916 2
d7933 8
a7940 1
		    unsigned_enum = 0;
d7973 2
@


1.605
log
@	* dwarf2read.c (read_and_check_comp_unit_head): Renamed from
	partial_read_comp_unit_head.  Replace "buffer", "buffer_size" and
	"abfd" args with "section".  All callers updated.
	Error checking code moved ...
	(error_check_comp_unit_head): ... here.  New function.
	(read_and_check_type_unit_head): Renamed from read_type_unit_head.
	Delete arg "abfd".  New arg "type_offset".  All callers updated.
	(create_debug_types_hash_table): Simplify by using
	read_and_check_type_unit_head.
@
text
@d989 3
a991 2
static void dwarf_decode_lines (struct line_header *, const char *, bfd *,
				struct dwarf2_cu *, struct partial_symtab *);
d3106 1
a3106 1
  dwarf_decode_lines (lh, pst->dirname, abfd, cu, pst);
d5525 4
a5528 1
/* Handle DW_AT_stmt_list for a compilation unit.  */
d5532 1
a5532 1
			const char *comp_dir)
a5537 3
  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.  */
d5549 1
a5549 1
          dwarf_decode_lines (line_header, comp_dir, abfd, cu, NULL);
d5608 4
a5611 1
  handle_DW_AT_stmt_list (die, cu, comp_dir);
d5714 5
a5718 1
  handle_DW_AT_stmt_list (die, cu, comp_dir);
d11057 2
a11058 21
/* Decode the Line Number Program (LNP) for the given line_header
   structure and CU.  The actual information extracted and the type
   of structures created from the LNP depends on the value of PST.

   1. If PST is NULL, then this procedure uses the data from the program
      to create all necessary symbol tables, and their linetables.

   2. If PST is not NULL, this procedure reads the program to determine
      the list of files included by the unit represented by PST, and
      builds all the associated partial symbol tables.

   COMP_DIR is the compilation directory (DW_AT_comp_dir) or NULL if unknown.
   It is used for relative paths in the line table.
   NOTE: When processing partial symtabs (pst != NULL),
   comp_dir == pst->dirname.

   NOTE: It is important that psymtabs have the same file name (via strcmp)
   as the corresponding symtab.  Since COMP_DIR is not used in the name of the
   symtab we don't use it in the name of the psymtabs we create.
   E.g. expand_line_sal requires this when finding psymtabs to expand.
   A good testcase for this is mb-inline.exp.  */
d11061 2
a11062 2
dwarf_decode_lines (struct line_header *lh, const char *comp_dir, bfd *abfd,
		    struct dwarf2_cu *cu, struct partial_symtab *pst)
d11070 1
d11073 1
a11073 1
  struct subfile *last_subfile = NULL, *first_subfile = current_subfile;
d11351 35
a11406 1

a11407 1
      struct file_entry *fe;
d11412 1
@


1.604
log
@	* dwarf2read.c (dwarf2_per_objfile): Rename n_type_comp_units to
	n_type_units.  Rename type_comp_units to all_type_units.
	All uses updated.
	(add_signatured_type_cu_to_table): Renamed from
	add_signatured_type_cu_to_list.  All callers updated.
@
text
@d1278 4
a1281 6
static gdb_byte *partial_read_comp_unit_head (struct comp_unit_head *header,
					      gdb_byte *info_ptr,
					      gdb_byte *buffer,
					      unsigned int buffer_size,
					      bfd *abfd,
					      int is_debug_types_section);
d2217 1
a2217 1
  gdb_byte *info_ptr, *buffer;
d2220 1
a2220 1
  unsigned int bytes_read, buffer_size;
d2241 4
a2244 8
  buffer_size = sec->size;
  buffer = sec->buffer;
  info_ptr = buffer + this_cu->offset;

  info_ptr = partial_read_comp_unit_head (&cu.header, info_ptr,
					  buffer, buffer_size,
					  abfd,
					  this_cu->debug_types_section != NULL);
d2247 1
a2247 1
  if (info_ptr >= buffer + buffer_size
d2951 38
a2988 1
/* Read in a CU header and perform some basic error checking.  */
d2991 4
a2994 3
partial_read_comp_unit_head (struct comp_unit_head *header, gdb_byte *info_ptr,
			     gdb_byte *buffer, unsigned int buffer_size,
			     bfd *abfd, int is_debug_types_section)
d2997 1
d2999 1
a2999 1
  header->offset = beg_of_comp_unit - buffer;
d3010 1
a3010 21
  if (header->version != 2 && header->version != 3 && header->version != 4)
    error (_("Dwarf Error: wrong version in compilation unit header "
	   "(is %d, should be 2, 3, or 4) [in module %s]"), header->version,
	   bfd_get_filename (abfd));

  if (header->abbrev_offset
      >= dwarf2_section_size (dwarf2_per_objfile->objfile,
			      &dwarf2_per_objfile->abbrev))
    error (_("Dwarf Error: bad offset (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 6) [in module %s]"),
	   (long) header->abbrev_offset,
	   (long) (beg_of_comp_unit - buffer),
	   bfd_get_filename (abfd));

  if (beg_of_comp_unit + header->length + header->initial_length_size
      > buffer + buffer_size)
    error (_("Dwarf Error: bad length (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 0) [in module %s]"),
	   (long) header->length,
	   (long) (beg_of_comp_unit - buffer),
	   bfd_get_filename (abfd));
d3019 4
a3022 4
read_type_comp_unit_head (struct comp_unit_head *cu_header,
			  struct dwarf2_section_info *section,
			  ULONGEST *signature,
			  gdb_byte *types_ptr, bfd *abfd)
d3024 4
a3027 1
  gdb_byte *initial_types_ptr = types_ptr;
d3029 1
a3029 2
  dwarf2_read_section (dwarf2_per_objfile->objfile, section);
  cu_header->offset = types_ptr - section->buffer;
d3031 8
a3038 1
  types_ptr = read_comp_unit_head (cu_header, types_ptr, abfd);
d3040 1
a3040 4
  *signature = read_8_bytes (abfd, types_ptr);
  types_ptr += 8;
  types_ptr += cu_header->offset_size;
  cu_header->first_die_offset = types_ptr - initial_types_ptr;
d3042 3
a3044 1
  return types_ptr;
a3196 1
	  unsigned int offset_size;
a3197 2
	  unsigned int length, initial_length_size;
	  unsigned short version;
d3202 1
d3207 1
a3207 1
	     table, but we don't need to read anything else just yet.  */
d3209 2
a3210 21
	  /* Sanity check to ensure entire cu is present.  */
	  length = read_initial_length (objfile->obfd, ptr,
					&initial_length_size);
	  if (ptr + length + initial_length_size > end_ptr)
	    {
	      complaint (&symfile_complaints,
			 _("debug type entry runs off end "
			   "of `.debug_types' section, ignored"));
	      break;
	    }

	  offset_size = initial_length_size == 4 ? 4 : 8;
	  ptr += initial_length_size;
	  version = bfd_get_16 (objfile->obfd, ptr);
	  ptr += 2;
	  ptr += offset_size; /* abbrev offset */
	  ptr += 1; /* address size */
	  signature = bfd_get_64 (objfile->obfd, ptr);
	  ptr += 8;
	  type_offset = read_offset_1 (objfile->obfd, ptr, offset_size);
	  ptr += offset_size;
d3215 1
a3215 1
	      info_ptr = info_ptr + initial_length_size + length;
d3246 1
a3246 1
	  info_ptr = info_ptr + initial_length_size + length;
d3380 2
a3381 4
  info_ptr = partial_read_comp_unit_head (&cu.header, info_ptr,
					  buffer, buffer_size,
					  abfd,
					  is_debug_types_section);
d3607 1
d3611 2
a3612 2
  gdb_assert (dwarf2_per_objfile->info.readin);
  info_ptr = dwarf2_per_objfile->info.buffer + this_cu->offset;
d3624 2
a3625 4
      info_ptr = partial_read_comp_unit_head (&cu->header, info_ptr,
					      dwarf2_per_objfile->info.buffer,
					      dwarf2_per_objfile->info.size,
					      abfd, 0);
d3628 1
a3628 2
      if (info_ptr >= (dwarf2_per_objfile->info.buffer
		       + dwarf2_per_objfile->info.size)
d3661 1
a3661 1
    load_partial_dies (abfd, dwarf2_per_objfile->info.buffer, info_ptr, 0, cu);
d14336 2
a14337 2
  types_ptr = read_type_comp_unit_head (&cu->header, section, &signature,
					types_ptr, objfile->obfd);
@


1.603
log
@	* gdbtypes.h (struct cplus_struct_type): Delete member
	nfn_fields_total.  All uses removed.
@
text
@d168 1
a168 1
  /* A list of all the compilation units.  This is used to locate
d176 1
a176 1
  int n_type_comp_units;
d178 2
a179 2
  /* The .debug_types-related CUs.  */
  struct dwarf2_per_cu_data **type_comp_units;
d1838 1
a1838 1
      return dwarf2_per_objfile->type_comp_units[index];
d1916 2
a1917 2
  dwarf2_per_objfile->n_type_comp_units = elements / 3;
  dwarf2_per_objfile->type_comp_units
d1919 1
a1919 1
		     dwarf2_per_objfile->n_type_comp_units
d1950 1
a1950 1
      dwarf2_per_objfile->type_comp_units[i / 3] = &type_sig->per_cu;
d2417 1
a2417 1
		   + dwarf2_per_objfile->n_type_comp_units); ++i)
d2549 1
a2549 1
		   + dwarf2_per_objfile->n_type_comp_units); ++i)
d2587 1
a2587 1
		   + dwarf2_per_objfile->n_type_comp_units); ++i)
d2713 1
a2713 1
		     + dwarf2_per_objfile->n_type_comp_units); ++i)
d2803 1
a2803 1
		   + dwarf2_per_objfile->n_type_comp_units); ++i)
d2878 1
a2878 1
		       + dwarf2_per_objfile->n_type_comp_units); ++i)
d3121 1
a3121 1
/* A helper function to add a signatured type CU to a list.  */
d3124 1
a3124 1
add_signatured_type_cu_to_list (void **slot, void *datum)
d3135 1
a3135 1
/* Create the hash table of all entries in the .debug_types section.
d3252 2
a3253 2
  dwarf2_per_objfile->n_type_comp_units = htab_elements (types_htab);
  dwarf2_per_objfile->type_comp_units
d3255 1
a3255 1
		     dwarf2_per_objfile->n_type_comp_units
d3257 4
a3260 4
  iter = &dwarf2_per_objfile->type_comp_units[0];
  htab_traverse_noresize (types_htab, add_signatured_type_cu_to_list, &iter);
  gdb_assert (iter - &dwarf2_per_objfile->type_comp_units[0]
	      == dwarf2_per_objfile->n_type_comp_units);
@


1.602
log
@	* dwarf2read.c: Move FIXME from dwarf2_build_psymtabs_hard
	to top of file.
	(dwarf2_find_comp_unit): Delete.
	(process_psymtab_comp_unit): Make result "void".
	Delete args buffer, info_ptr, buffer_size, and replace with
	"section".  All callers updated.
	(dwarf2_build_psymtabs_hard): Simplify.
@
text
@a7410 1
  int total_length = 0;
a7431 2

      total_length += flp->length;
a7434 1
  TYPE_NFN_FIELDS_TOTAL (type) = total_length;
@


1.601
log
@	* dwarf2read.c (statement_prologue): Delete, unused.
@
text
@d27 4
a1227 3
static struct dwarf2_per_cu_data *dwarf2_find_comp_unit
  (unsigned int offset, struct objfile *objfile);

d3338 3
a3340 5
   Process a compilation unit for a psymtab.
   BUFFER is a pointer to the beginning of the dwarf section buffer,
   either .debug_info or debug_types.
   INFO_PTR is a pointer to the start of the CU.
   Returns a pointer to the next CU.  */
d3342 1
a3342 1
static gdb_byte *
d3344 2
a3345 2
			   gdb_byte *buffer, gdb_byte *info_ptr,
			   unsigned int buffer_size)
d3349 3
d3383 1
a3383 1
					  this_cu->debug_types_section != NULL);
a3388 2
      info_ptr = (beg_of_comp_unit + cu.header.length
		  + cu.header.initial_length_size);
d3390 1
a3390 1
      return info_ptr;
d3404 1
a3404 1
  if (this_cu->debug_types_section)
a3411 2
      info_ptr = (beg_of_comp_unit + cu.header.length
		  + cu.header.initial_length_size);
d3413 1
a3413 1
      return info_ptr;
d3496 1
a3496 4
  info_ptr = (beg_of_comp_unit + cu.header.length
	      + cu.header.initial_length_size);

  if (this_cu->debug_types_section)
a3508 2

  return info_ptr;
d3524 1
a3524 5
  process_psymtab_comp_unit (this_cu,
			     this_cu->debug_types_section->buffer,
			     (this_cu->debug_types_section->buffer
			      + this_cu->offset),
			     this_cu->debug_types_section->size);
a3557 1
  gdb_byte *info_ptr;
d3560 1
a3564 1
  info_ptr = dwarf2_per_objfile->info.buffer;
d3581 1
a3581 16
  /* Since the objects we're extracting from .debug_info vary in
     length, only the individual functions to extract them (like
     read_comp_unit_head and load_partial_die) can really know whether
     the buffer is large enough to hold another complete object.

     At the moment, they don't actually check that.  If .debug_info
     holds just one extra byte after the last compilation unit's dies,
     then read_comp_unit_head will happily read off the end of the
     buffer.  read_partial_die is similarly casual.  Those functions
     should be fixed.

     For this loop condition, simply checking whether there's any data
     left at all should be sufficient.  */

  while (info_ptr < (dwarf2_per_objfile->info.buffer
		     + dwarf2_per_objfile->info.size))
d3583 1
a3583 1
      struct dwarf2_per_cu_data *this_cu;
d3585 1
a3585 8
      this_cu = dwarf2_find_comp_unit (info_ptr
				       - dwarf2_per_objfile->info.buffer,
				       objfile);

      info_ptr = process_psymtab_comp_unit (this_cu,
					    dwarf2_per_objfile->info.buffer,
					    info_ptr,
					    dwarf2_per_objfile->info.size);
a15761 14
/* Locate the compilation unit from OBJFILE which is located at exactly
   OFFSET.  Raises an error on failure.  */

static struct dwarf2_per_cu_data *
dwarf2_find_comp_unit (unsigned int offset, struct objfile *objfile)
{
  struct dwarf2_per_cu_data *this_cu;

  this_cu = dwarf2_find_containing_comp_unit (offset, objfile);
  if (this_cu->offset != offset)
    error (_("no compilation unit with offset %u."), offset);
  return this_cu;
}

@


1.600
log
@	* dwarf2read.c (dwarf2_per_cu_addr_size): Make result type an int.
	* dwarf2loc.h (dwarf2_per_cu_addr_size): Update.
@
text
@a77 23
/* .debug_line statement program prologue
   Because of alignment constraints, this structure has padding and cannot
   be mapped directly onto the beginning of the .debug_info section.  */
typedef struct statement_prologue
  {
    unsigned int total_length;	/* byte length of the statement
				   information */
    unsigned short version;	/* version number -- 2 for DWARF
				   version 2 */
    unsigned int prologue_length;	/* # bytes between prologue &
					   stmt program */
    unsigned char minimum_instruction_length;	/* byte size of
						   smallest instr */
    unsigned char default_is_stmt;	/* initial value of is_stmt
					   register */
    char line_base;
    unsigned char line_range;
    unsigned char opcode_base;	/* number assigned to first special
				   opcode */
    unsigned char *standard_opcode_lengths;
  }
_STATEMENT_PROLOGUE;

@


1.599
log
@	* dwarf2read.c (comp_unit_header): Delete, unused.
@
text
@d15723 1
a15723 1
CORE_ADDR
@


1.598
log
@	* dwarf2read.c (dwarf2_read_abbrevs): Delete arg "abfd".
	All callers updated.
	(load_full_type_unit): Renamed from read_signatured_type_at_offset.
	Replace all arguments with "per_cu".  All callers updated.
@
text
@a77 17
#if 0
/* .debug_info header for a compilation unit
   Because of alignment constraints, this structure has padding and cannot
   be mapped directly onto the beginning of the .debug_info section.  */
typedef struct comp_unit_header
  {
    unsigned int length;	/* length of the .debug_info
				   contribution */
    unsigned short version;	/* version number -- 2 for DWARF
				   version 2 */
    unsigned int abbrev_offset;	/* offset into .debug_abbrev section */
    unsigned char addr_size;	/* byte size of an address -- 4 */
  }
_COMP_UNIT_HEADER;
#define _ACTUAL_COMP_UNIT_HEADER_SIZE 11
#endif

@


1.597
log
@	* dwarf2read.c (dwarf2_per_cu_data): Remove outdated comment.
@
text
@d927 1
a927 1
static void dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu);
d1220 1
a1220 3
static void read_signatured_type_at_offset (struct objfile *objfile,
					    struct dwarf2_section_info *sect,
					    unsigned int offset);
d1821 1
a1821 3
    read_signatured_type_at_offset (per_cu->objfile,
				    per_cu->debug_types_section,
				    per_cu->offset);
d2299 1
a2299 1
  dwarf2_read_abbrevs (abfd, &cu);
d3436 1
a3436 1
  dwarf2_read_abbrevs (abfd, &cu);
d3725 1
a3725 1
  dwarf2_read_abbrevs (abfd, cu);
d4729 1
a4729 1
      dwarf2_read_abbrevs (abfd, cu);
d9134 1
a9134 1
      dwarf2_read_abbrevs (cu->objfile->obfd, cu);
d9313 1
a9313 1
dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu)
d9315 1
d10004 1
a10004 1
	  dwarf2_read_abbrevs (objfile->obfd, per_cu->cu);
d14367 1
a14367 1
/* Read in signatured type at OFFSET and build its CU and die(s).  */
d14370 1
a14370 3
read_signatured_type_at_offset (struct objfile *objfile,
				struct dwarf2_section_info *sect,
				unsigned int offset)
d14372 3
d14380 5
a14384 1
     hash table lookup.	 */
d14431 1
a14431 1
  dwarf2_read_abbrevs (objfile->obfd, cu);
@


1.596
log
@	* dwarf2read.c (init_one_comp_unit): Delete arg "objfile".
	New arg "per_cu".  All callers updated.
@
text
@d436 1
a436 3
   read_symtab_private field of the psymtab.  If we encounter
   inter-compilation-unit references, we also maintain a sorted
   list of all compilation units.  */
@


1.595
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d1272 1
a1272 1
				struct objfile *objfile);
d2280 1
a2280 1
  init_one_comp_unit (&cu, objfile);
a2304 3
  this_cu->cu = &cu;
  cu.per_cu = this_cu;

d3408 14
a3421 1
  init_one_comp_unit (&cu, objfile);
a3440 16
  /* If this compilation unit was already read in, free the
     cached copy in order to read it in again.	This is
     necessary because we skipped some symbols when we first
     read in the compilation unit (see load_partial_dies).
     This problem could be avoided, but the benefit is
     unclear.  */
  if (this_cu->cu != NULL)
    free_one_cached_comp_unit (this_cu->cu);

  /* Note that this is a pointer to our stack frame, being
     added to a global data structure.	It will be cleaned up
     in free_stack_comp_unit when we finish with this
     compilation unit.	*/
  this_cu->cu = &cu;
  cu.per_cu = this_cu;

d3698 1
a3698 1
      init_one_comp_unit (cu, objfile);
a3718 4
      /* Link this compilation unit into the compilation unit tree.  */
      this_cu->cu = cu;
      cu->per_cu = this_cu;

d4711 1
a4711 1
      init_one_comp_unit (cu, objfile);
a4737 4
      /* Link this compilation unit into the compilation unit tree.  */
      per_cu->cu = cu;
      cu->per_cu = per_cu;

d14413 1
a14413 4
  init_one_comp_unit (cu, objfile);

  type_sig->per_cu.cu = cu;
  cu->per_cu = &type_sig->per_cu;
d15850 1
a15850 1
/* Initialize dwarf2_cu CU for OBJFILE in a pre-allocated space.  */
d15853 1
a15853 1
init_one_comp_unit (struct dwarf2_cu *cu, struct objfile *objfile)
d15856 3
a15858 1
  cu->objfile = objfile;
d15891 2
a15892 2
  if (cu->per_cu != NULL)
    cu->per_cu->cu = NULL;
d15912 4
d15919 5
a15923 11
  if (cu->per_cu != NULL)
    {
      /* This compilation unit is on the stack in our caller, so we
	 should not xfree it.  Just unlink it.  */
      cu->per_cu->cu = NULL;
      cu->per_cu = NULL;

      /* If we had a per-cu pointer, then we may have other compilation
	 units loaded, so age them now.  */
      age_cached_comp_units ();
    }
@


1.594
log
@	* dwarf2read.c (dwarf2_compute_name): Simplify objfile references.
	(dwarf2_physname, read_import_statement): Ditto.
	(read_call_site_scope, dwarf2_record_block_ranges): Ditto.
	(process_structure_scope read_subroutine_type): Ditto.
	(read_typedef, load_partial_dies, read_partial_die): Ditto.
	(find_partial_die, dwarf_decode_lines, lookup_die_type): Ditto.
	(dwarf2_fetch_die_location_block): Ditto.
	(dwarf_decode_macros, dwarf2_symbol_mark_computed): Ditto.
@
text
@d3 1
a3 3
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
                 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
                 Free Software Foundation, Inc.
@


1.593
log
@	* dwarf2read.c (read_signatured_type): Delete `objfile' arg.
	All callers updated.
	(load_full_comp_unit, queue_comp_unit, process_queue): Ditto.
	(dw2_do_instantiate_symtab, dw2_instantiate_symtab): Ditto.
	(process_psymtab_comp_unit, load_partial_comp_unit): Ditto.
@
text
@d5081 2
d5290 1
a5290 1
	  name = ui_file_obsavestring (buf, &cu->objfile->objfile_obstack,
d5298 1
a5298 1
					    &cu->objfile->objfile_obstack);
d5333 1
d5396 1
a5396 1
		     physname, canon, mangled, die->offset, cu->objfile->name);
d5415 1
a5415 1
			   &cu->objfile->objfile_obstack);
d5426 1
d5533 1
a5533 1
		       child_die->offset, cu->objfile->name);
d5554 1
a5554 1
		       child_die->offset, cu->objfile->name);
d5568 1
a5568 1
                          &cu->objfile->objfile_obstack);
d6231 1
a6231 1
		 die->offset, cu->objfile->name);
d6247 1
a6247 1
		 paddress (gdbarch, pc), die->offset, cu->objfile->name);
d6262 1
a6262 1
		     child_die->tag, child_die->offset, cu->objfile->name);
d6320 1
a6320 1
		       die->offset, cu->objfile->name);
a6342 1
      struct objfile *objfile = cu->objfile;
d6357 1
a6357 1
		       die->offset, cu->objfile->name);
d6370 1
a6370 1
		       die->offset, cu->objfile->name);
d6379 1
a6379 1
	       die->offset, cu->objfile->name);
d6408 1
a6408 1
		     child_die->offset, cu->objfile->name);
d6422 1
a6422 1
		     child_die->offset, cu->objfile->name);
d6432 1
a6432 1
		     child_die->offset, cu->objfile->name);
d6450 1
a6450 1
		       child_die->offset, cu->objfile->name);
d6766 1
d6786 1
a6786 1
      bfd *obfd = cu->objfile->obfd;
d7901 1
a7901 1
  quirk_gcc_member_function_pointer (type, cu->objfile);
d8688 1
d8734 1
a8734 1
      struct type *void_type = objfile_type (cu->objfile)->builtin_void;
d8861 1
a8861 1
		 die->offset, cu->objfile->name);
d9509 1
d9637 2
a9638 2
				 &cu->objfile->static_psymbols,
				 0, (CORE_ADDR) 0, cu->language, cu->objfile);
d9655 1
a9655 1
		   part_die->offset, cu->objfile->name);
d9675 3
a9677 3
				 ? &cu->objfile->global_psymbols
				 : &cu->objfile->static_psymbols,
				 0, (CORE_ADDR) 0, cu->language, cu->objfile);
d9787 1
d9829 1
a9829 1
					    &cu->objfile->objfile_obstack);
d9935 1
a9935 1
	  struct gdbarch *gdbarch = get_objfile_arch (cu->objfile);
d9941 1
a9941 1
		     part_die->offset, cu->objfile->name);
d9946 1
a9946 1
	  struct gdbarch *gdbarch = get_objfile_arch (cu->objfile);
d9953 1
a9953 1
		     part_die->offset, cu->objfile->name);
d9984 1
d10003 1
a10003 1
  per_cu = dwarf2_find_containing_comp_unit (offset, cu->objfile);
d10025 1
a10025 1
	  dwarf2_read_abbrevs (per_cu->cu->objfile->obfd, per_cu->cu);
d10033 1
a10033 1
				   per_cu->cu->objfile->obfd,
d10037 1
a10037 1
	load_partial_dies (per_cu->cu->objfile->obfd,
d10051 1
a10051 1
		    offset, bfd_get_filename (cu->objfile->obfd));
d11297 1
a11297 1
				 line_offset, cu->objfile->name);
d11506 1
a11506 1
						       cu->objfile);
d12260 1
d12282 1
a12282 1
	       die->offset, cu->objfile->name);
d12292 1
a12292 1
	     dwarf_attr_name (attr->name), cu->objfile->name);
d12316 1
a12316 1
			    cu->objfile->name,
d12319 1
a12319 1
      saved = obstack_copy0 (&cu->objfile->objfile_obstack,
d12323 1
a12323 1
      this_type = init_type (TYPE_CODE_ERROR, 0, 0, saved, cu->objfile);
d14267 1
a14267 1
	   offset, per_cu->cu->objfile->name);
d14295 1
a14295 1
	       offset, per_cu->cu->objfile->name);
d15434 1
d15441 1
a15441 1
  dwarf2_read_section (dwarf2_per_objfile->objfile, section);
d15518 1
a15518 1
					     comp_dir, lh, cu->objfile);
d15575 1
a15575 1
			    offset_size, cu->objfile);
d15660 2
d15666 1
a15666 1
      && DW_UNSND (attr) < dwarf2_section_size (dwarf2_per_objfile->objfile,
d15671 1
a15671 1
      baton = obstack_alloc (&cu->objfile->objfile_obstack,
d15688 1
a15688 1
      baton = obstack_alloc (&cu->objfile->objfile_obstack,
@


1.592
log
@	* dwarf2read.c (load_cu): Move assert to more useful location.
@
text
@d1228 1
a1228 2
static void read_signatured_type (struct objfile *,
				  struct signatured_type *type_sig);
d1294 1
a1294 2
static void load_full_comp_unit (struct dwarf2_per_cu_data *,
				 struct objfile *);
d1312 1
a1312 2
static void queue_comp_unit (struct dwarf2_per_cu_data *per_cu,
			     struct objfile *objfile);
d1314 1
a1314 1
static void process_queue (struct objfile *objfile);
d1831 1
a1831 1
    load_full_comp_unit (per_cu, per_cu->objfile);
d1838 1
a1838 2
/* Read in the symbols for PER_CU.  OBJFILE is the objfile from which
   this CU came.  */
d1841 1
a1841 2
dw2_do_instantiate_symtab (struct objfile *objfile,
			   struct dwarf2_per_cu_data *per_cu)
d1847 1
a1847 1
  queue_comp_unit (per_cu, objfile);
d1851 1
a1851 1
  process_queue (objfile);
d1865 1
a1865 2
dw2_instantiate_symtab (struct objfile *objfile,
			struct dwarf2_per_cu_data *per_cu)
d1871 1
a1871 1
      dw2_do_instantiate_symtab (objfile, per_cu);
d2393 1
a2393 1
  return dw2_instantiate_symtab (objfile, dw2_get_cu (index));
d2445 1
a2445 1
  dw2_instantiate_symtab (objfile, per_cu);
d2577 1
a2577 1
	      dw2_instantiate_symtab (objfile, per_cu);
d2641 1
a2641 1
      dw2_instantiate_symtab (objfile, per_cu);
d2677 1
a2677 1
	      dw2_instantiate_symtab (objfile, per_cu);
d2814 1
a2814 1
	    dw2_instantiate_symtab (objfile, per_cu);
d2841 1
a2841 1
  return dw2_instantiate_symtab (objfile, data);
d3395 1
a3395 2
process_psymtab_comp_unit (struct objfile *objfile,
			   struct dwarf2_per_cu_data *this_cu,
d3399 1
a3578 1
  struct objfile *objfile = (struct objfile *) info;
d3581 1
d3585 1
a3585 1
  process_psymtab_comp_unit (objfile, this_cu,
d3604 1
a3604 1
			  process_type_comp_unit, objfile);
d3670 1
a3670 1
      info_ptr = process_psymtab_comp_unit (objfile, this_cu,
d3686 1
a3686 2
load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu,
			struct objfile *objfile)
d3688 1
d4587 1
a4587 1
queue_comp_unit (struct dwarf2_per_cu_data *per_cu, struct objfile *objfile)
d4607 1
a4607 1
process_queue (struct objfile *objfile)
d4694 1
a4694 1
  dw2_do_instantiate_symtab (pst->objfile, per_cu);
d4700 1
a4700 2
load_full_comp_unit (struct dwarf2_per_cu_data *per_cu,
		     struct objfile *objfile)
d4702 1
d9998 1
a9998 1
    load_partial_comp_unit (per_cu, cu->objfile);
d14137 1
a14137 1
  queue_comp_unit (per_cu, this_cu->objfile);
d14197 1
a14197 1
	load_full_comp_unit (per_cu, cu->objfile);
d14205 1
a14205 1
      load_full_comp_unit (cu->per_cu, cu->objfile);
d14333 1
a14333 1
    read_signatured_type (objfile, sig_type);
d14396 1
a14396 1
  read_signatured_type (objfile, type_sig);
d14404 1
a14404 2
read_signatured_type (struct objfile *objfile,
		      struct signatured_type *type_sig)
d14406 1
d14441 1
a14441 1
  dwarf2_read_abbrevs (cu->objfile->obfd, cu);
@


1.591
log
@	* dwarf2read.c (free_heap_comp_unit): Renamed from free_one_comp_unit.
	All callers updated.
@
text
@d1836 2
a1838 2

  gdb_assert (per_cu->cu != NULL);
@


1.590
log
@	* dwarf2read.c (dwarf2_per_objfile): Add comment.
	(dwarf2_elf_names): Minor reformat.
	(dwarf2_per_cu_data): Tweak comment.
	(dwarf2_read_section): Fix comment.
	(create_all_comp_units): Fix comment.
	(load_full_comp_unit): Fix comment.
	(process_full_comp_unit): Fix comment.
	(read_signatured_type): Fix comment.
@
text
@d1280 1
a1280 1
static void free_one_comp_unit (void *);
d3717 1
a3717 1
      free_cu_cleanup = make_cleanup (free_one_comp_unit, cu);
d4734 1
a4734 1
      free_cu_cleanup = make_cleanup (free_one_comp_unit, cu);
d14432 1
a14432 1
  free_cu_cleanup = make_cleanup (free_one_comp_unit, cu);
d15898 1
a15898 1
free_one_comp_unit (void *data)
d15954 1
a15954 1
      free_one_comp_unit (per_cu->cu);
d15989 1
a15989 1
	  free_one_comp_unit (per_cu->cu);
d16016 1
a16016 1
	  free_one_comp_unit (per_cu->cu);
@


1.589
log
@	* dwarf2read.c (read_typedef): Guard against self-referential typedefs.
@
text
@d184 3
d266 2
a267 1
static const struct dwarf2_debug_sections dwarf2_elf_names = {
a432 1

d470 3
a472 1
  /* The corresponding objfile.  */
d1587 1
a1587 1
/* Read the contents of the section SECTP from object file specified by
d3775 2
a3776 4
/* Create a list of all compilation units in OBJFILE.  We do this only
   if an inter-comp-unit reference is found; presumably if there is one,
   there will be many, and one will occur early in the .debug_info section.
   So there's no point in building this list incrementally.  */
d4587 2
d4773 1
a4773 1
     all objfiles needed for references have been loaded yet, and symbol
d4844 1
a4844 1
/* Generate full symbol information for PST and CU, whose DIEs have
d5749 1
d14456 1
a14456 1
     all objfiles needed for references have been loaded yet, and symbol
@


1.588
log
@	* dwarf2read.c (struct dwarf2_cu): Delete members first_fn, last_fn,
	cached_fn.
	(struct function_range): Delete.
	(initialize_cu_func_list, add_to_cu_func_list): Delete.  All callers
	updated.
	(check_cu_functions): Ditto.
@
text
@d8839 1
a8839 1
  struct type *this_type;
d8846 13
a8858 1
  TYPE_TARGET_TYPE (this_type) = die_type (die, cu);
@


1.587
log
@Use symbol search name in expand_symtabs_matching_via_partial...

We are iterating over all symbols in a partial symtab that would
match a given name, so we should match the partial symbols
search name against the given name rather than using the natural
name.  In C++, that does not make a difference, but it does in
Ada, because Ada searches using the symbol encoded name...

We also update the generation of the .gdb_index file to match this
change in the search. Although technically an incompatible change,
we do not increment the gdb_index version number, because Ada is
the only language where it would make a difference - except that
this feature is not supported for Ada.

gdb/ChangeLog:

        * psymtab.c (expand_symtabs_matching_via_partial): Match
        the partial symbols using their SYMBOL_SEARCH_NAME.
        * symfile.h (struct quick_symbol_functions): Udate the
        documentation of expand_symtabs_matching.
        * dwarf2read.c (write_psymbols): Use SYMBOL_SEARCH_NAME instead
        of SYMBOL_NATURAL_NAME in index entry.
@
text
@a348 2
  struct function_range *first_fn, *last_fn, *cached_fn;

a701 8
struct function_range
{
  const char *name;
  CORE_ADDR lowpc, highpc;
  int seen_line;
  struct function_range *next;
};

a1233 5
static void initialize_cu_func_list (struct dwarf2_cu *);

static void add_to_cu_func_list (const char *, CORE_ADDR, CORE_ADDR,
				 struct dwarf2_cu *);

a5569 6
static void
initialize_cu_func_list (struct dwarf2_cu *cu)
{
  cu->first_fn = cu->last_fn = cu->cached_fn = NULL;
}

a5703 2
  initialize_cu_func_list (cu);

a5827 22
static void
add_to_cu_func_list (const char *name, CORE_ADDR lowpc, CORE_ADDR highpc,
		     struct dwarf2_cu *cu)
{
  struct function_range *thisfn;

  thisfn = (struct function_range *)
    obstack_alloc (&cu->comp_unit_obstack, sizeof (struct function_range));
  thisfn->name = name;
  thisfn->lowpc = lowpc;
  thisfn->highpc = highpc;
  thisfn->seen_line = 0;
  thisfn->next = NULL;

  if (cu->last_fn == NULL)
      cu->first_fn = thisfn;
  else
      cu->last_fn->next = thisfn;

  cu->last_fn = thisfn;
}

a6021 3
  /* Record the function range for dwarf_decode_lines.  */
  add_to_cu_func_list (name, lowpc, highpc, cu);

a11044 46
/* This function exists to work around a bug in certain compilers
   (particularly GCC 2.95), in which the first line number marker of a
   function does not show up until after the prologue, right before
   the second line number marker.  This function shifts ADDRESS down
   to the beginning of the function if necessary, and is called on
   addresses passed to record_line.  */

static CORE_ADDR
check_cu_functions (CORE_ADDR address, struct dwarf2_cu *cu)
{
  struct function_range *fn;

  /* Find the function_range containing address.  */
  if (!cu->first_fn)
    return address;

  if (!cu->cached_fn)
    cu->cached_fn = cu->first_fn;

  fn = cu->cached_fn;
  while (fn)
    if (fn->lowpc <= address && fn->highpc > address)
      goto found;
    else
      fn = fn->next;

  fn = cu->first_fn;
  while (fn && fn != cu->cached_fn)
    if (fn->lowpc <= address && fn->highpc > address)
      goto found;
    else
      fn = fn->next;

  return address;

 found:
  if (fn->seen_line)
    return address;
  if (address != fn->lowpc)
    complaint (&symfile_complaints,
	       _("misplaced first line number at 0x%lx for '%s'"),
	       (unsigned long) address, fn->name);
  fn->seen_line = 1;
  return fn->lowpc;
}

d11242 1
a11242 2
		      addr = check_cu_functions (address, cu);
		      addr = gdbarch_addr_bits_remove (gdbarch, addr);
d11340 1
a11340 2
		      addr = check_cu_functions (address, cu);
		      addr = gdbarch_addr_bits_remove (gdbarch, addr);
@


1.586
log
@	* dwarf2read.c (dwarf2_per_cu_data): Rename debug_type_section to
	debug_types_section.  All uses updated.
	(partial_read_comp_unit_head): Rename parameter is_debug_type_section
	to is_debug_types_section.
@
text
@d16893 1
a16893 1
	  add_index_entry (symtab, SYMBOL_NATURAL_NAME (*psymp), cu_index);
@


1.586.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 3
a5 1
   Copyright (C) 1994-2012 Free Software Foundation, Inc.
@


1.586.2.2
log
@	* dwarf2read.c (dwarf_decode_lines): Remove arg "abfd".  New arg
	"want_line_info".  All callers updated.
	(dwarf_decode_lines_1): New function.
	(handle_DW_AT_stmt_list): Add function comment.
	New arg "want_line_info".  All callers updated.
	(read_file_scope,read_type_unit_scope): Move comment from
	handle_DW_AT_stmt_list to here.
@
text
@d1032 2
a1033 3
static void dwarf_decode_lines (struct line_header *, const char *,
				struct dwarf2_cu *, struct partial_symtab *,
				int);
d3148 1
a3148 1
  dwarf_decode_lines (lh, pst->dirname, cu, pst, 1);
d5640 1
a5640 4
/* Handle DW_AT_stmt_list for a compilation unit or type unit.
   DIE is the DW_TAG_compile_unit or DW_TAG_type_unit die for CU.
   COMP_DIR is the compilation directory.
   WANT_LINE_INFO is non-zero if the pc/line-number mapping is needed.  */
d5644 1
a5644 1
			const char *comp_dir, int want_line_info)
d5650 3
d5664 1
a5664 1
	  dwarf_decode_lines (line_header, comp_dir, cu, NULL, want_line_info);
d5725 1
a5725 4
  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.  */
  handle_DW_AT_stmt_list (die, cu, comp_dir, 1);
d5827 1
a5827 5
  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.
     We don't need the pc/line-number mapping for type units.  */
  handle_DW_AT_stmt_list (die, cu, comp_dir, 0);
d11224 21
a11244 2
/* Subroutine of dwarf_decode_lines to simplify it.
   Process the line number information in LH.  */
d11247 2
a11248 2
dwarf_decode_lines_1 (struct line_header *lh, const char *comp_dir,
		      struct dwarf2_cu *cu, struct partial_symtab *pst)
a11255 1
  bfd *abfd = objfile->obfd;
d11258 1
a11258 1
  struct subfile *last_subfile = NULL;
a11537 35
}

/* Decode the Line Number Program (LNP) for the given line_header
   structure and CU.  The actual information extracted and the type
   of structures created from the LNP depends on the value of PST.

   1. If PST is NULL, then this procedure uses the data from the program
      to create all necessary symbol tables, and their linetables.

   2. If PST is not NULL, this procedure reads the program to determine
      the list of files included by the unit represented by PST, and
      builds all the associated partial symbol tables.

   COMP_DIR is the compilation directory (DW_AT_comp_dir) or NULL if unknown.
   It is used for relative paths in the line table.
   NOTE: When processing partial symtabs (pst != NULL),
   comp_dir == pst->dirname.

   NOTE: It is important that psymtabs have the same file name (via strcmp)
   as the corresponding symtab.  Since COMP_DIR is not used in the name of the
   symtab we don't use it in the name of the psymtabs we create.
   E.g. expand_line_sal requires this when finding psymtabs to expand.
   A good testcase for this is mb-inline.exp.  */

static void
dwarf_decode_lines (struct line_header *lh, const char *comp_dir,
		    struct dwarf2_cu *cu, struct partial_symtab *pst,
		    int want_line_info)
{
  struct objfile *objfile = cu->objfile;
  const int decode_for_pst_p = (pst != NULL);
  struct subfile *first_subfile = current_subfile;

  if (want_line_info)
    dwarf_decode_lines_1 (lh, comp_dir, cu, pst);
d11559 1
d11561 1
a11565 1
	  struct file_entry *fe;
@


1.585
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d463 1
a463 1
  struct dwarf2_section_info *debug_type_section;
d1341 1
a1341 1
					      int is_debug_type_section);
d1839 1
a1839 1
  if (per_cu->debug_type_section)
d1841 1
a1841 1
				    per_cu->debug_type_section,
d2003 1
a2003 1
      type_sig->per_cu.debug_type_section = section;
d2301 2
a2302 2
  if (this_cu->debug_type_section)
    sec = this_cu->debug_type_section;
d2313 1
a2313 1
					  this_cu->debug_type_section != NULL);
d3028 1
a3028 1
			     bfd *abfd, int is_debug_type_section)
d3038 1
a3038 1
  if (is_debug_type_section)
d3290 1
a3290 1
	  type_sig->per_cu.debug_type_section = section;
d3359 1
a3359 1
  if (cu->per_cu->debug_type_section)
d3361 2
a3362 2
      gdb_assert (cu->per_cu->debug_type_section->readin);
      reader->buffer = cu->per_cu->debug_type_section->buffer;
d3435 1
a3435 1
					  this_cu->debug_type_section != NULL);
d3474 1
a3474 1
  if (this_cu->debug_type_section)
d3571 1
a3571 1
  if (this_cu->debug_type_section)
d3600 1
a3600 1
  gdb_assert (this_cu->debug_type_section->readin);
d3602 2
a3603 2
			     this_cu->debug_type_section->buffer,
			     (this_cu->debug_type_section->buffer
d3605 1
a3605 1
			     this_cu->debug_type_section->size);
d3714 1
a3714 1
  gdb_assert (! this_cu->debug_type_section);
d4727 1
a4727 1
  gdb_assert (! per_cu->debug_type_section);
d8114 1
a8114 1
  if (cu->per_cu->debug_type_section
d8121 1
a8121 1
					    cu->per_cu->debug_type_section,
d9228 1
a9228 1
			  (reader->cu->per_cu->debug_type_section
d10016 1
a10016 1
  if (cu->per_cu->debug_type_section)
d12359 1
a12359 1
      gdb_assert (sig_type->per_cu.debug_type_section);
d14265 1
a14265 1
  if (cu->per_cu->debug_type_section)
d14496 1
a14496 1
  struct dwarf2_section_info *section = type_sig->per_cu.debug_type_section;
d16193 1
a16193 1
  if (cu->per_cu->debug_type_section)
d16233 1
a16233 1
  if (per_cu->debug_type_section)
@


1.584
log
@gdb/
	PR threads/13448
	* dwarf2read.c (decode_locdesc): Handle DW_OP_const8u.
	For DW_OP_GNU_push_tls_address increment the value, new comment for it.

gdb/testsuite/
	PR threads/13448
	* gdb.dwarf2/dw2-var-zero-addr.S: New file.
	* gdb.dwarf2/dw2-var-zero-addr.exp: New file.
	* gdb.threads/tls-var-main.c: New file.
	* gdb.threads/tls-var.c: New file.
	* gdb.threads/tls-var.exp: New file.
@
text
@d2442 27
d2470 4
a2473 3
dw2_lookup_symtab (struct objfile *objfile, const char *name,
		   const char *full_path, const char *real_path,
		   struct symtab **result)
d2503 4
a2506 2
	      *result = dw2_instantiate_symtab (objfile, per_cu);
	      return 1;
d2527 4
a2530 2
		  *result = dw2_instantiate_symtab (objfile, per_cu);
		  return 1;
d2542 4
a2545 2
		  *result = dw2_instantiate_symtab (objfile, per_cu);
		  return 1;
d2553 4
a2556 2
      *result = dw2_instantiate_symtab (objfile, base_cu);
      return 1;
d2759 6
a2764 5
dw2_expand_symtabs_matching (struct objfile *objfile,
			     int (*file_matcher) (const char *, void *),
			     int (*name_matcher) (const char *, void *),
			     enum search_domain kind,
			     void *data)
d2816 1
a2816 1
      if (! (*name_matcher) (name, data))
d2907 1
a2907 1
  dw2_lookup_symtab,
@


1.583
log
@gdb/
	PR breakpoints/13346
	* dwarf2read.c (process_psymtab_comp_unit): Set
	PSYMTABS_ADDRMAP_SUPPORTED.
	* psympriv.h (struct partial_symtab): Comment textlow and texthigh
	validity.  New field psymtabs_addrmap_supported.
	* psymtab.c (find_pc_sect_psymtab_closer): New gdb_assert on
	psymtabs_addrmap_supported.
	(find_pc_sect_psymtab): Do not fallback to TEXTLOW and TEXTHIGH for
	!PSYMTABS_ADDRMAP_SUPPORTED.
	(dump_psymtab, maintenance_info_psymtabs): Print also
	psymtabs_addrmap_supported.

gdb/testsuite/
	PR breakpoints/13346
	* gdb.dwarf2/dw2-objfile-overlap-inner.S: New file.
	* gdb.dwarf2/dw2-objfile-overlap-outer.S: New file.
	* gdb.dwarf2/dw2-objfile-overlap.exp: New file.
@
text
@d14671 5
d14723 3
a14725 1
	     address will be bogus in the psymtab.  */
d14728 1
@


1.582
log
@	* dwarf2read.c (dw2_lookup_symtab): Add comment.
	(dw2_expand_symtabs_with_filename): Ditto.
	(dw2_expand_symtabs_matching): Ditto.
	(dw2_map_symbol_filenames): Ditto.
@
text
@d3465 1
@


1.581
log
@	* NEWS: Mention new parameter basenames-may-differ.
	* dwarf2read.c (dw2_lookup_symtab): Avoid calling gdb_realpath if
	! basenames_may_differ.
	* psymtab.c (lookup_partial_symtab): Ditto.
	* symtab.c (lookup_symtab): Ditto.
	(basenames_may_differ): New global.
	(_initialize_symtab): New parameter basenames-may-differ.
	* symtab.h (basenames_may_differ): Declare.

	doc/
	* gdb.texinfo (Files): Document basenames-may-differ.
@
text
@d2461 1
d2644 1
d2749 2
d2838 1
@


1.580
log
@	* dwarf2read.c (dw2_map_symbol_filenames): New parameter
	`need_fullname'.
	* psymtab.c (map_symbol_filenames_psymtab): Ditto.
	(map_partial_symbol_filenames): Ditto.  All callers updated.
	* psymtab.h (map_partial_symbol_filenames): Update prototype.
	* symfile.h (struct quick_symbol_functions, map_symbol_filenames): New
	parameter need_fullname.
@
text
@d2448 2
a2449 1
  int check_basename = lbasename (name) == name;
d2482 6
@


1.579
log
@	* defs.h (is_cplus_marker, set_demangling_style): Moved to ...
	* gdb-demangle.h: ... here.  New file.
	* demangle.c: #include "gdb-demangle.h".
	(_initialize_demangler): Use initialize_file_ftype for prototype.
	Move "set demangle" and "set asm-demangle" parameters here from utils.c
	(demangle, show_demangle, asm_demangle, show_asm_demangle): Move here
	from utils.c
	* utils.c: Update. #include "gdb-demangle.h".
	* symtab.h (asm_demangle): Delete.
	(demangle): Move declaration next to use.
	* breakpoint.c: #include "gdb-demangle.h" instead of "demangle.h".
	* dwarf2read.c: #include "gdb-demangle.h".
	* gnu-v2-abi.c: Ditto.
	* jv-typeprint.c: Ditto.
	* mdebugread.c: Ditto.
	* p-typeprint.c: Ditto.
	* stabsread.c: Ditto.
	* printcmd.c: Ditto.
	(asm_demangle): Delete declaration.
	* tui/tui-stack.c: #include "gdb-demangle.h".
@
text
@d2814 1
a2814 1
			  void *data)
d2836 6
a2841 2
	  const char *this_real_name = dw2_get_real_path (objfile, file_data,
							  j);
@


1.578
log
@	* dwarf2read.c (dw2_get_file_names): Move adjustment for type
	section to...
	(partial_read_comp_unit_head): ...here.  Add is_debug_type_section
	flag.  Adjust all callers.
	(process_psymtab_comp_unit): Remove adjustment for type section.
@
text
@d37 1
@


1.577
log
@	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.  Instead of getting objfile from
	symbol's symtab, use new argument OBJFILE.
	* cp-support.h (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.
	* gdb/dwarf2read.c (new_symbol_full): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
	* gdb/stabsread.c (define_symbol): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
@
text
@d1339 2
a1340 1
					      bfd *abfd);
d2311 2
a2312 1
					  abfd);
a2327 2
  if (this_cu->debug_type_section)
    info_ptr += 8 /*signature*/ + cu.header.offset_size;
d2974 1
a2974 1
			     bfd *abfd)
d2982 5
d3380 2
a3381 1
					  abfd);
a3415 2
  if (this_cu->debug_type_section)
    info_ptr += 8 /*signature*/ + cu.header.offset_size;
d3677 1
a3677 1
					      abfd);
@


1.576
log
@	* dwarf2read.c (create_debug_types_hash_table): Fix size of
	type_offset field.
@
text
@d11995 1
a11995 1
	cp_scan_for_anonymous_namespaces (sym);
@


1.575
log
@	* dwarf2read.c (peek_abbrev_code): New function.
	(dw2_get_file_names): Check for dummy compilation units.
	(create_debug_types_hash_table): Likewise.
	(process_psymtab_comp_unit): Likewise.
	(load_partial_comp_unit): Likewise.
	(load_full_comp_unit): Likewise.
@
text
@d3217 1
a3217 1
	  ptr += 1;
@


1.574
log
@gdb/
	Revert:
	2011-07-27  Jan Kratochvil  <jan.kratochvil@@redhat.com>
        * dwarf2expr.c (ctx_no_read_reg): New function.
        * dwarf2expr.h (ctx_no_read_reg): New declaration.
        * dwarf2read.c (read_2_signed_bytes, read_4_signed_bytes): Remove.
        (decode_locdesc_read_mem, decode_locdesc_ctx_funcs): New.
        (decode_locdesc): Replace by a caller of dwarf_expr_eval.

gdb/testsuite/
	* gdb.dwarf2/dw2-simple-locdesc.exp (p &s.shl): KFAIL it.
	Revert the part of:
	2011-07-27  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* gdb.dwarf2/dw2-stack-boundary.exp (check partial symtab errors):
	Change the expected string.
@
text
@d939 2
d2312 8
d3217 8
d3377 10
d3675 9
d4296 10
d4690 9
@


1.573
log
@gdb/
	* dwarf2read.c (dwarf2_fetch_die_location_block): Initialize .data even
	if .size is 0.
@
text
@d10300 6
d10312 6
a14433 31
/* Workaround as dwarf_expr_context_funcs.read_mem implementation before
   a proper runtime DWARF expressions evaluator gets implemented.
   Otherwise gnuv3_baseclass_offset would error by:
   Expected a negative vbase offset (old compiler?)  */

static void
decode_locdesc_read_mem (void *baton, gdb_byte *buf, CORE_ADDR addr,
			 size_t length)
{
  struct dwarf_expr_context *ctx = baton;
  struct gdbarch *gdbarch = ctx->gdbarch;
  struct type *ptr_type = builtin_type (gdbarch)->builtin_data_ptr;

  memset (buf, 0, length);

  if (TYPE_LENGTH (ptr_type) == length)
    store_typed_address (buf, ptr_type, addr);
}

static const struct dwarf_expr_context_funcs decode_locdesc_ctx_funcs =
{
  ctx_no_read_reg,
  decode_locdesc_read_mem,
  ctx_no_get_frame_base,
  ctx_no_get_frame_cfa,
  ctx_no_get_frame_pc,
  ctx_no_get_tls_address,
  ctx_no_dwarf_call,
  ctx_no_get_base_type
};

d14451 3
a14453 1
   complaint.  */
d14459 7
a14465 3
  struct dwarf_expr_context *ctx;
  struct cleanup *old_chain;
  volatile struct gdb_exception ex;
d14467 4
a14470 3
  ctx = new_dwarf_expr_context ();
  old_chain = make_cleanup_free_dwarf_expr_context (ctx);
  make_cleanup_value_free_to_mark (value_mark ());
d14472 175
a14646 6
  ctx->gdbarch = get_objfile_arch (objfile);
  ctx->addr_size = cu->header.addr_size;
  ctx->ref_addr_size = dwarf2_per_cu_ref_addr_size (cu->per_cu);
  ctx->offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
  ctx->baton = ctx;
  ctx->funcs = &decode_locdesc_ctx_funcs;
d14648 3
a14650 3
  /* DW_AT_data_member_location expects the structure address to be pushed on
     the stack.  Simulate the offset by address 0.  */
  dwarf_expr_push_address (ctx, 0, 0);
d14652 10
a14661 15
  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      dwarf_expr_eval (ctx, blk->data, blk->size);
    }
  if (ex.reason < 0)
    {
      if (ex.message)
	complaint (&symfile_complaints, "%s", ex.message);
    }
  else if (ctx->num_pieces == 0)
    switch (ctx->location)
      {
      /* The returned number will be bogus, just do not complain for locations
	 in global registers - it is here only a partial symbol address.  */
      case DWARF_VALUE_REGISTER:
d14663 3
a14665 2
      case DWARF_VALUE_MEMORY:
      case DWARF_VALUE_STACK:
d14667 4
a14670 1
	  CORE_ADDR address = dwarf_expr_fetch_address (ctx, 0);
d14672 5
a14676 2
	  do_cleanups (old_chain);
	  return address;
d14678 2
a14679 5
      }

  do_cleanups (old_chain);
  dwarf2_complex_location_expr_complaint ();
  return 0;
@


1.572
log
@gdb/
	Fix empty DWARF expressions DATA vs. SIZE conditionals.
	* dwarf2loc.c (dwarf2_find_location_expression): Clear *LOCEXPR_LENGTH.
	(dwarf_expr_frame_base_1): Indicate unavailability via zero *LENGTH.
	(locexpr_tracepoint_var_ref): Check only zero SIZE, not zero DATA.
	(loclist_read_variable, loclist_tracepoint_var_ref): Do not check for
	zero DATA.
	* dwarf2loc.h (struct dwarf2_locexpr_baton): Comment DATA vs. SIZE
	validity.
	* dwarf2read.c (struct dwarf_block): Comment DATA validity.
	(dwarf2_fetch_die_location_block, dwarf2_symbol_mark_computed): Do not
	clear DATA on zero SIZE.

gdb/testsuite/
	Fix empty DWARF expressions DATA vs. SIZE conditionals.
	* gdb.dwarf2/dw2-op-call.S (arraycallnoloc, arraynoloc): New DIEs.
	(loclist): New.
	(4): New abbrev.
	* gdb.dwarf2/dw2-op-call.exp: Remove variable srcfile and executable.
	Use prepare_for_testing, remove clean_restart.
	(p arraynoloc, p arraycallnoloc): New tests.
@
text
@d14220 2
a14221 1
      /* DWARF: "If there is no such attribute, then there is no effect.".  */
d14223 1
@


1.571
log
@	* dwarf2read.c (partial_read_comp_unit_head): Set header->offset,
	header->first_die_offset here.  All callers updated.
@
text
@d725 2
a14221 1
      retval.data = NULL;
a15498 1
	  baton->data = NULL;
@


1.570
log
@2011-10-11  Sterling Augustine  <saugustine@@google.com>

	* dwarf2read.c: Undo inadvertent changes in previous commit.
@
text
@d2276 1
a2276 1
  gdb_byte *beg_of_comp_unit, *info_ptr, *buffer;
a2302 1
  beg_of_comp_unit = info_ptr;
a2307 4
  /* Complete the cu_header.  */
  cu.header.offset = beg_of_comp_unit - buffer;
  cu.header.first_die_offset = info_ptr - beg_of_comp_unit;

d2957 2
d2966 2
d2970 2
a3356 4
  /* Complete the cu_header.  */
  cu.header.offset = beg_of_comp_unit - buffer;
  cu.header.first_die_offset = info_ptr - beg_of_comp_unit;

d3617 1
a3617 1
  gdb_byte *info_ptr, *beg_of_comp_unit;
a3628 1
  beg_of_comp_unit = info_ptr;
a3644 4
      /* Complete the cu_header.  */
      cu->header.offset = this_cu->offset;
      cu->header.first_die_offset = info_ptr - beg_of_comp_unit;

@


1.569
log
@gdb/ChangeLog
2011-10-11  Sterling Augustine  <saugustine@@google.com>

	* dwarf2read.c (partial_die_parent_scope): Rearrange conditional
	logic.

gdb/testsuite/ChangeLog
2011-10-11  Sterling Augustine  <saugustine@@google.com>

	* gdb.cp/Makefile.in: Add namespace-enum test.
	* gdb.cp/namespace-enum.exp: New file.
	* gdb.cp/namespace-enum.c: New file.
	* gdb.cp/namespace-enum-main.c: New file.
@
text
@d410 3
d1085 2
d2658 15
a2672 1
    return NULL;
d4807 2
d4847 3
d6144 252
d6595 2
a6596 1
  *highpc = high;
d10081 4
a10084 3
      && (part_die->tag == DW_TAG_structure_type
	  || part_die->tag == DW_TAG_union_type
	  || part_die->tag == DW_TAG_class_type)
d10092 11
a10102 1
	  part_die->name = obsavestring (demangled, strlen (demangled),
d12451 36
d12508 1
d12514 4
d12809 2
d12812 2
a12813 3
	      DW_STRING (attr)
		= obsavestring (demangled, strlen (demangled),
				&cu->objfile->objfile_obstack);
d12816 8
d13007 2
d14491 1
d15531 25
d15561 6
a15566 15
  if (per_cu->cu)
    return per_cu->cu->header.addr_size;
  else
    {
      /* If the CU is not currently read in, we re-read its header.  */
      struct objfile *objfile = per_cu->objfile;
      struct dwarf2_per_objfile *per_objfile
	= objfile_data (objfile, dwarf2_objfile_data_key);
      gdb_byte *info_ptr = per_objfile->info.buffer + per_cu->offset;
      struct comp_unit_head cu_header;

      memset (&cu_header, 0, sizeof cu_header);
      read_comp_unit_head (&cu_header, info_ptr, objfile->obfd);
      return cu_header.addr_size;
    }
d15574 20
a15593 2
  if (per_cu->cu)
    return per_cu->cu->header.offset_size;
d15595 1
a15595 12
    {
      /* If the CU is not currently read in, we re-read its header.  */
      struct objfile *objfile = per_cu->objfile;
      struct dwarf2_per_objfile *per_objfile
	= objfile_data (objfile, dwarf2_objfile_data_key);
      gdb_byte *info_ptr = per_objfile->info.buffer + per_cu->offset;
      struct comp_unit_head cu_header;

      memset (&cu_header, 0, sizeof cu_header);
      read_comp_unit_head (&cu_header, info_ptr, objfile->obfd);
      return cu_header.offset_size;
    }
a16693 8
/* A cleanup function for an htab_t.  */

static void
cleanup_htab (void *arg)
{
  htab_delete (arg);
}

d16750 1
a16750 1
  make_cleanup (cleanup_htab, psyms_seen);
d16760 1
a16760 1
  make_cleanup (cleanup_htab, cu_index_htab);
@


1.568
log
@gdb/
	Display @@entry parameter values (without references).
	* dwarf2expr.c (dwarf_block_to_fb_offset, dwarf_block_to_sp_offset):
	New functions.
	* dwarf2expr.h (dwarf_block_to_fb_offset, dwarf_block_to_sp_offset):
	New declarations.
	* dwarf2loc.c (dwarf2_find_location_expression): Support location list
	entry record.
	(dwarf_entry_parameter_to_value, value_of_dwarf_reg_entry)
	(value_of_dwarf_block_entry, locexpr_read_variable_at_entry): New
	functions.
	(dwarf2_locexpr_funcs): Install locexpr_read_variable_at_entry.
	(loclist_read_variable_at_entry): New function.
	(dwarf2_loclist_funcs): Install loclist_read_variable_at_entry.
	* dwarf2read.c (read_call_site_scope): Support also DW_OP_fbreg in
	DW_AT_location, call dwarf_block_to_sp_offset for it.
	* frame.h (print_entry_values_no, print_entry_values_only)
	(print_entry_values_preferred, print_entry_values_if_needed)
	(print_entry_values_both, print_entry_values_compact)
	(print_entry_values_default, print_entry_values): New declarations.
	(struct frame_arg): New field entry_kind.
	(read_frame_arg): New parameter entryargp.
	* mi/mi-cmd-stack.c (list_arg_or_local): New gdb_assert for
	arg->entry_kind.  Optionally print the `@@entry' suffix.
	(list_args_or_locals): New variable entryarg, initialize it.
	Initialize also entry_kind of arg and entryarg.  Conditionalize
	list_arg_or_local for arg, add list_arg_or_local for entryarg.  Call
	xfree for entryarg.error.
	* stack.c (print_entry_values_no, print_entry_values_only)
	(print_entry_values_preferred, print_entry_values_if_needed)
	(print_entry_values_both, print_entry_values_compact)
	(print_entry_values_default, print_entry_values_choices)
	(print_entry_values): New variables.
	(print_frame_arg): New gdb_assert for arg->entry_kind.  Optionally
	print the `@@entry' suffix, possibly in combination for
	print_entry_values_compact.
	(read_frame_arg): New parameter entryargp, new variables entryval,
	entryval_error and val_equal.  Read in also entryargp, respect
	print_entry_values, compare the values using val_equal, fill in also
	argp->entry_kind (together with entryargp->entry_kind).
	(print_frame_args): New variable entryarg, initialize it.
	Conditionalize print_frame_arg for arg, add print_frame_arg for
	entryarg.  Call xfree for entryarg.error.
	(_initialize_stack): Call add_setshow_enum_cmd for `entry-values'.
	* symtab.h (struct symbol_computed_ops): New field
	read_variable_at_entry.

gdb/doc/
	Display @@entry parameter values (without references).
	* gdb.texinfo (Tail Call Frames): Add anchor.  Add self tail call
	example.
	(Print Settings): New description of set print entry-values and show
	print entry-values.

gdb/testsuite/
	Display @@entry parameter values (without references).
	* gdb.arch/amd64-entry-value.cc (locexpr, stacktest, data, data2)
	(different, validity, invalid): New functions.
	(main): Call them.
	* gdb.arch/amd64-entry-value.exp: New breakpoints breakhere_locexpr,
	stacktest, breakhere_stacktest, different, breakhere_different,
	breakhere_validity and breakhere_invalid.
	(entry: bt): Update for @@entry.
	(entry_locexpr: *, entry_stack: *, entry_equal: *, entry_different: *)
	(entry_validity: *, entry_invalid: *): Many new tests.
	* gdb.base/break.exp
	(run until breakpoint set at small function, optimized file): Accept
	also the @@entry suffix.
	* gdb.mi/Makefile.in (PROGS): Add mi2-amd64-entry-value.
	* gdb.mi/mi2-amd64-entry-value.c: New files.
	* gdb.mi/mi2-amd64-entry-value.exp: New files.
@
text
@a409 3
  /* To be copied to symtab->call_site_htab.  */
  htab_t call_site_htab;

a1081 2
static void read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu);

d2653 1
a2653 15
    {
      struct symtab *s;

      ALL_OBJFILE_SYMTABS (objfile, s)
	if (s->primary)
	  {
	    struct blockvector *bv = BLOCKVECTOR (s);
	    const struct block *block = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
	    struct symbol *sym = lookup_block_symbol (block, name, VAR_DOMAIN);

	    if (sym)
	      return sym->symtab->filename;
	  }
      return NULL;
    }
d3881 4
a3884 1
  if (parent->tag == DW_TAG_namespace
a3898 3
  else if (parent->tag == DW_TAG_enumerator)
    /* Enumerators should not get the name of the enumeration as a prefix.  */
    parent->scope = grandparent_scope;
a4787 2

      symtab->call_site_htab = cu->call_site_htab;
a4825 3
    case DW_TAG_GNU_call_site:
      read_call_site_scope (die, cu);
      break;
a6119 252
/* Read in DW_TAG_GNU_call_site and insert it to CU->call_site_htab.  */

static void
read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  CORE_ADDR pc, baseaddr;
  struct attribute *attr;
  struct call_site *call_site, call_site_local;
  void **slot;
  int nparams;
  struct die_info *child_die;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  attr = dwarf2_attr (die, DW_AT_low_pc, cu);
  if (!attr)
    {
      complaint (&symfile_complaints,
		 _("missing DW_AT_low_pc for DW_TAG_GNU_call_site "
		   "DIE 0x%x [in module %s]"),
		 die->offset, cu->objfile->name);
      return;
    }
  pc = DW_ADDR (attr) + baseaddr;

  if (cu->call_site_htab == NULL)
    cu->call_site_htab = htab_create_alloc_ex (16, core_addr_hash, core_addr_eq,
					       NULL, &objfile->objfile_obstack,
					       hashtab_obstack_allocate, NULL);
  call_site_local.pc = pc;
  slot = htab_find_slot (cu->call_site_htab, &call_site_local, INSERT);
  if (*slot != NULL)
    {
      complaint (&symfile_complaints,
		 _("Duplicate PC %s for DW_TAG_GNU_call_site "
		   "DIE 0x%x [in module %s]"),
		 paddress (gdbarch, pc), die->offset, cu->objfile->name);
      return;
    }

  /* Count parameters at the caller.  */

  nparams = 0;
  for (child_die = die->child; child_die && child_die->tag;
       child_die = sibling_die (child_die))
    {
      if (child_die->tag != DW_TAG_GNU_call_site_parameter)
	{
	  complaint (&symfile_complaints,
		     _("Tag %d is not DW_TAG_GNU_call_site_parameter in "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->tag, child_die->offset, cu->objfile->name);
	  continue;
	}

      nparams++;
    }

  call_site = obstack_alloc (&objfile->objfile_obstack,
			     (sizeof (*call_site)
			      + (sizeof (*call_site->parameter)
				 * (nparams - 1))));
  *slot = call_site;
  memset (call_site, 0, sizeof (*call_site) - sizeof (*call_site->parameter));
  call_site->pc = pc;

  if (dwarf2_flag_true_p (die, DW_AT_GNU_tail_call, cu))
    {
      struct die_info *func_die;

      /* Skip also over DW_TAG_inlined_subroutine.  */
      for (func_die = die->parent;
	   func_die && func_die->tag != DW_TAG_subprogram
	   && func_die->tag != DW_TAG_subroutine_type;
	   func_die = func_die->parent);

      /* DW_AT_GNU_all_call_sites is a superset
	 of DW_AT_GNU_all_tail_call_sites.  */
      if (func_die
          && !dwarf2_flag_true_p (func_die, DW_AT_GNU_all_call_sites, cu)
	  && !dwarf2_flag_true_p (func_die, DW_AT_GNU_all_tail_call_sites, cu))
	{
	  /* TYPE_TAIL_CALL_LIST is not interesting in functions where it is
	     not complete.  But keep CALL_SITE for look ups via call_site_htab,
	     both the initial caller containing the real return address PC and
	     the final callee containing the current PC of a chain of tail
	     calls do not need to have the tail call list complete.  But any
	     function candidate for a virtual tail call frame searched via
	     TYPE_TAIL_CALL_LIST must have the tail call list complete to be
	     determined unambiguously.  */
	}
      else
	{
	  struct type *func_type = NULL;

	  if (func_die)
	    func_type = get_die_type (func_die, cu);
	  if (func_type != NULL)
	    {
	      gdb_assert (TYPE_CODE (func_type) == TYPE_CODE_FUNC);

	      /* Enlist this call site to the function.  */
	      call_site->tail_call_next = TYPE_TAIL_CALL_LIST (func_type);
	      TYPE_TAIL_CALL_LIST (func_type) = call_site;
	    }
	  else
	    complaint (&symfile_complaints,
		       _("Cannot find function owning DW_TAG_GNU_call_site "
			 "DIE 0x%x [in module %s]"),
		       die->offset, cu->objfile->name);
	}
    }

  attr = dwarf2_attr (die, DW_AT_GNU_call_site_target, cu);
  if (attr == NULL)
    attr = dwarf2_attr (die, DW_AT_abstract_origin, cu);
  SET_FIELD_DWARF_BLOCK (call_site->target, NULL);
  if (!attr || (attr_form_is_block (attr) && DW_BLOCK (attr)->size == 0))
    /* Keep NULL DWARF_BLOCK.  */;
  else if (attr_form_is_block (attr))
    {
      struct dwarf2_locexpr_baton *dlbaton;

      dlbaton = obstack_alloc (&objfile->objfile_obstack, sizeof (*dlbaton));
      dlbaton->data = DW_BLOCK (attr)->data;
      dlbaton->size = DW_BLOCK (attr)->size;
      dlbaton->per_cu = cu->per_cu;

      SET_FIELD_DWARF_BLOCK (call_site->target, dlbaton);
    }
  else if (is_ref_attr (attr))
    {
      struct objfile *objfile = cu->objfile;
      struct dwarf2_cu *target_cu = cu;
      struct die_info *target_die;

      target_die = follow_die_ref_or_sig (die, attr, &target_cu);
      gdb_assert (target_cu->objfile == objfile);
      if (die_is_declaration (target_die, target_cu))
	{
	  const char *target_physname;

	  target_physname = dwarf2_physname (NULL, target_die, target_cu);
	  if (target_physname == NULL)
	    complaint (&symfile_complaints,
		       _("DW_AT_GNU_call_site_target target DIE has invalid "
		         "physname, for referencing DIE 0x%x [in module %s]"),
		       die->offset, cu->objfile->name);
	  else
	    SET_FIELD_PHYSNAME (call_site->target, (char *) target_physname);
	}
      else
	{
	  CORE_ADDR lowpc;

	  /* DW_AT_entry_pc should be preferred.  */
	  if (!dwarf2_get_pc_bounds (target_die, &lowpc, NULL, target_cu, NULL))
	    complaint (&symfile_complaints,
		       _("DW_AT_GNU_call_site_target target DIE has invalid "
		         "low pc, for referencing DIE 0x%x [in module %s]"),
		       die->offset, cu->objfile->name);
	  else
	    SET_FIELD_PHYSADDR (call_site->target, lowpc + baseaddr);
	}
    }
  else
    complaint (&symfile_complaints,
	       _("DW_TAG_GNU_call_site DW_AT_GNU_call_site_target is neither "
		 "block nor reference, for DIE 0x%x [in module %s]"),
	       die->offset, cu->objfile->name);

  call_site->per_cu = cu->per_cu;

  for (child_die = die->child;
       child_die && child_die->tag;
       child_die = sibling_die (child_die))
    {
      struct dwarf2_locexpr_baton *dlbaton;
      struct call_site_parameter *parameter;

      if (child_die->tag != DW_TAG_GNU_call_site_parameter)
	{
	  /* Already printed the complaint above.  */
	  continue;
	}

      gdb_assert (call_site->parameter_count < nparams);
      parameter = &call_site->parameter[call_site->parameter_count];

      /* DW_AT_location specifies the register number.  Value of the data
	 assumed for the register is contained in DW_AT_GNU_call_site_value.  */

      attr = dwarf2_attr (child_die, DW_AT_location, cu);
      if (!attr || !attr_form_is_block (attr))
	{
	  complaint (&symfile_complaints,
		     _("No DW_FORM_block* DW_AT_location for "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->offset, cu->objfile->name);
	  continue;
	}
      parameter->dwarf_reg = dwarf_block_to_dwarf_reg (DW_BLOCK (attr)->data,
				 &DW_BLOCK (attr)->data[DW_BLOCK (attr)->size]);
      if (parameter->dwarf_reg == -1
	  && !dwarf_block_to_sp_offset (gdbarch, DW_BLOCK (attr)->data,
				  &DW_BLOCK (attr)->data[DW_BLOCK (attr)->size],
					&parameter->fb_offset))
	{
	  complaint (&symfile_complaints,
		     _("Only single DW_OP_reg or DW_OP_fbreg is supported "
		       "for DW_FORM_block* DW_AT_location for "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->offset, cu->objfile->name);
	  continue;
	}

      attr = dwarf2_attr (child_die, DW_AT_GNU_call_site_value, cu);
      if (!attr_form_is_block (attr))
	{
	  complaint (&symfile_complaints,
		     _("No DW_FORM_block* DW_AT_GNU_call_site_value for "
		       "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		     child_die->offset, cu->objfile->name);
	  continue;
	}
      parameter->value = DW_BLOCK (attr)->data;
      parameter->value_size = DW_BLOCK (attr)->size;

      /* Parameters are not pre-cleared by memset above.  */
      parameter->data_value = NULL;
      parameter->data_value_size = 0;
      call_site->parameter_count++;

      attr = dwarf2_attr (child_die, DW_AT_GNU_call_site_data_value, cu);
      if (attr)
	{
	  if (!attr_form_is_block (attr))
	    complaint (&symfile_complaints,
		       _("No DW_FORM_block* DW_AT_GNU_call_site_data_value for "
			 "DW_TAG_GNU_call_site child DIE 0x%x [in module %s]"),
		       child_die->offset, cu->objfile->name);
	  else
	    {
	      parameter->data_value = DW_BLOCK (attr)->data;
	      parameter->data_value_size = DW_BLOCK (attr)->size;
	    }
	}
    }
}

d6319 1
a6319 2
  if (highpc)
    *highpc = high;
d9804 3
a9806 4
      && (part_die->tag == DW_TAG_class_type
	  || part_die->tag == DW_TAG_interface_type
	  || part_die->tag == DW_TAG_structure_type
	  || part_die->tag == DW_TAG_union_type)
d9814 1
a9814 11
	  const char *base;

	  /* Strip any leading namespaces/classes, keep only the base name.
	     DW_AT_name for named DIEs does not contain the prefixes.  */
	  base = strrchr (demangled, ':');
	  if (base && base > demangled && base[-1] == ':')
	    base++;
	  else
	    base = demangled;

	  part_die->name = obsavestring (base, strlen (base),
a12162 36
/* GCC might emit a nameless typedef that has a linkage name.  Determine the
   prefix part in such case.  See
   http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */

static char *
anonymous_struct_prefix (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;
  char *base;

  if (die->tag != DW_TAG_class_type && die->tag != DW_TAG_interface_type
      && die->tag != DW_TAG_structure_type && die->tag != DW_TAG_union_type)
    return NULL;

  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr != NULL && DW_STRING (attr) != NULL)
    return NULL;

  attr = dwarf2_attr (die, DW_AT_linkage_name, cu);
  if (attr == NULL)
    attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);
  if (attr == NULL || DW_STRING (attr) == NULL)
    return NULL;

  /* dwarf2_name had to be already called.  */
  gdb_assert (DW_STRING_IS_CANONICAL (attr));

  /* Strip the base name, keep any leading namespaces/classes.  */
  base = strrchr (DW_STRING (attr), ':');
  if (base == NULL || base == DW_STRING (attr) || base[-1] != ':')
    return "";

  return obsavestring (DW_STRING (attr), &base[-1] - DW_STRING (attr),
		       &cu->objfile->objfile_obstack);
}

a12183 1
  char *retval;
a12188 4
  retval = anonymous_struct_prefix (die, cu);
  if (retval)
    return retval;

a12479 2
	      char *base;

d12481 3
a12483 2
	      DW_STRING (attr) = obsavestring (demangled, strlen (demangled),
					       &cu->objfile->objfile_obstack);
a12485 8

	      /* Strip any leading namespaces/classes, keep only the base name.
		 DW_AT_name for named DIEs does not contain the prefixes.  */
	      base = strrchr (DW_STRING (attr), ':');
	      if (base && base > DW_STRING (attr) && base[-1] == ':')
		return &base[1];
	      else
		return DW_STRING (attr);
a12668 2
    case DW_TAG_GNU_call_site:
      return "DW_TAG_GNU_call_site";
a14150 1
  ctx->ref_addr_size = dwarf2_per_cu_ref_addr_size (cu->per_cu);
a15189 25
/* Return comp_unit_head for PER_CU, either already available in PER_CU->CU
   (CU_HEADERP is unused in such case) or prepare a temporary copy at
   CU_HEADERP first.  */

static const struct comp_unit_head *
per_cu_header_read_in (struct comp_unit_head *cu_headerp,
		       struct dwarf2_per_cu_data *per_cu)
{
  struct objfile *objfile;
  struct dwarf2_per_objfile *per_objfile;
  gdb_byte *info_ptr;

  if (per_cu->cu)
    return &per_cu->cu->header;

  objfile = per_cu->objfile;
  per_objfile = objfile_data (objfile, dwarf2_objfile_data_key);
  info_ptr = per_objfile->info.buffer + per_cu->offset;

  memset (cu_headerp, 0, sizeof (*cu_headerp));
  read_comp_unit_head (cu_headerp, info_ptr, objfile->obfd);

  return cu_headerp;
}

d15195 15
a15209 6
  struct comp_unit_head cu_header_local;
  const struct comp_unit_head *cu_headerp;

  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);

  return cu_headerp->addr_size;
d15217 2
a15218 20
  struct comp_unit_head cu_header_local;
  const struct comp_unit_head *cu_headerp;

  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);

  return cu_headerp->offset_size;
}

/* See its dwarf2loc.h declaration.  */

int
dwarf2_per_cu_ref_addr_size (struct dwarf2_per_cu_data *per_cu)
{
  struct comp_unit_head cu_header_local;
  const struct comp_unit_head *cu_headerp;

  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);

  if (cu_headerp->version == 2)
    return cu_headerp->addr_size;
d15220 12
a15231 1
    return cu_headerp->offset_size;
d16330 8
d16394 1
a16394 1
  make_cleanup_htab_delete (psyms_seen);
d16404 1
a16404 1
  make_cleanup_htab_delete (cu_index_htab);
@


1.567
log
@gdb/
	Tail call sites reader implementation.
	* dwarf2read.c (read_call_site_scope): Recognize DW_AT_GNU_tail_call,
	fill in TYPE_TAIL_CALL_LIST.
	* gdbtypes.h (struct func_type): New field tail_call_list.
	(struct call_site): New field tail_call_next.
	(TYPE_TAIL_CALL_LIST): New definition.
@
text
@d6349 4
a6352 1
      if (parameter->dwarf_reg == -1)
d6355 1
a6355 1
		     _("Only single DW_OP_reg is supported "
@


1.566
log
@gdb/
	Implement basic support for DW_TAG_GNU_call_site.
	* block.c: Include gdbtypes.h and exceptions.h.
	(call_site_for_pc): New function.
	* block.h (call_site_for_pc): New declaration.
	* defs.h: Include hashtab.h.
	(make_cleanup_htab_delete, core_addr_hash, core_addr_eq): New
	declarations.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Install
	ctx_no_push_dwarf_reg_entry_value.
	* dwarf2expr.c (read_uleb128, read_sleb128): Support R as NULL.
	(dwarf_block_to_dwarf_reg): New function.
	(execute_stack_op) <DW_OP_GNU_entry_value>: Implement it.
	(ctx_no_push_dwarf_reg_entry_value): New function.
	* dwarf2expr.h (struct dwarf_expr_context_funcs): New field
	push_dwarf_reg_entry_value.
	(ctx_no_push_dwarf_reg_entry_value, dwarf_block_to_dwarf_reg): New
	declarations.
	* dwarf2loc.c: Include gdbcmd.h.
	(dwarf_expr_ctx_funcs): New forward declaration.
	(entry_values_debug, show_entry_values_debug, call_site_to_target_addr)
	(dwarf_expr_reg_to_entry_parameter)
	(dwarf_expr_push_dwarf_reg_entry_value): New.
	(dwarf_expr_ctx_funcs): Install dwarf_expr_push_dwarf_reg_entry_value.
	(dwarf2_evaluate_loc_desc_full): Handle NO_ENTRY_VALUE_ERROR.
	(needs_dwarf_reg_entry_value): New function.
	(needs_frame_ctx_funcs): Install it.
	(_initialize_dwarf2loc): New function.
	* dwarf2loc.h (entry_values_debug): New declaration.
	* dwarf2read.c (struct dwarf2_cu): New field call_site_htab.
	(read_call_site_scope): New forward declaration.
	(process_full_comp_unit): Copy call_site_htab.
	(process_die): Support DW_TAG_GNU_call_site.
	(read_call_site_scope): New function.
	(dwarf2_get_pc_bounds): Support NULL HIGHPC.
	(dwarf_tag_name): Support DW_TAG_GNU_call_site.
	(cleanup_htab): Delete.
	(write_psymtabs_to_index): Use make_cleanup_htab_delete instead of it.
	* exceptions.h (enum errors): New NO_ENTRY_VALUE_ERROR.
	* gdb-gdb.py (StructMainTypePrettyPrinter): Support
	FIELD_LOC_KIND_DWARF_BLOCK.
	* gdbtypes.h (enum field_loc_kind): New entry
	FIELD_LOC_KIND_DWARF_BLOCK.
	(struct main_type): New loc entry dwarf_block.
	(struct call_site, FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK)
	(TYPE_FIELD_DWARF_BLOCK): New.
	* python/py-type.c: Include dwarf2loc.h.
	(check_types_equal): Support FIELD_LOC_KIND_DWARF_BLOCK.  New
	internal_error call on unknown FIELD_LOC_KIND.
	* symtab.h (struct symtab): New field call_site_htab.
	* utils.c (do_htab_delete_cleanup, make_cleanup_htab_delete)
	(core_addr_hash, core_addr_eq): New functions.

gdb/testsuite/
	Implement basic support for DW_TAG_GNU_call_site.
	* gdb.arch/Makefile.in (EXECUTABLES): Add amd64-entry-value.
	* gdb.arch/amd64-entry-value.cc: New file.
	* gdb.arch/amd64-entry-value.exp: New file.
@
text
@d6212 47
@


1.565
log
@gdb/
	Fix DW_OP_GNU_implicit_pointer for DWARF32 v3+ on 64-bit arches.
	* dwarf2-frame.c (execute_stack_op): Initialize ctx->ref_addr_size.
	* dwarf2expr.c (execute_stack_op) <DW_OP_GNU_implicit_pointer>: Use
	ctx->ref_addr_size.  Handle its invalid value.
	* dwarf2expr.h (struct dwarf_expr_context): New field ref_addr_size.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full)
	(dwarf2_loc_desc_needs_frame): Initialize ctx->ref_addr_size.
	* dwarf2loc.h (dwarf2_per_cu_ref_addr_size): New declaration.
	* dwarf2read.c (decode_locdesc): Initialize ctx->ref_addr_size.
	(dwarf2_per_cu_ref_addr_size): New function.

gdb/testsuite/
	Fix DW_OP_GNU_implicit_pointer for DWARF32 v3+ on 64-bit arches.
	* gdb.dwarf2/implptr-64bit.S: New file.
	* gdb.dwarf2/implptr-64bit.exp: New file.
@
text
@d410 3
d1085 2
d4807 2
d4847 3
d6144 202
d6545 2
a6546 1
  *highpc = high;
d12957 2
a16643 8
/* A cleanup function for an htab_t.  */

static void
cleanup_htab (void *arg)
{
  htab_delete (arg);
}

d16700 1
a16700 1
  make_cleanup (cleanup_htab, psyms_seen);
d16710 1
a16710 1
  make_cleanup (cleanup_htab, cu_index_htab);
@


1.564
log
@gdb/
	Code cleanup.
	* dwarf2read.c (per_cu_header_read_in): New function.
	(dwarf2_per_cu_addr_size, dwarf2_per_cu_offset_size): Use it, with new
	variables cu_header_local and cu_headerp.
@
text
@d14226 1
d15317 16
@


1.563
log
@gdb/
	Fix initial language detection with -readnow.
	* dwarf2read.c (dw2_find_symbol_file): Handle OBJF_READNOW case.
	* symfile.h (struct quick_symbol_functions): State find_symbol_file
	searches only for global symbols.

gdb/testsuite/
	Fix initial language detection with -readnow.
	* gdb.cp/readnow-language.cc: New file.
	* gdb.cp/readnow-language.exp: New file.
@
text
@d15265 25
d15295 6
a15300 15
  if (per_cu->cu)
    return per_cu->cu->header.addr_size;
  else
    {
      /* If the CU is not currently read in, we re-read its header.  */
      struct objfile *objfile = per_cu->objfile;
      struct dwarf2_per_objfile *per_objfile
	= objfile_data (objfile, dwarf2_objfile_data_key);
      gdb_byte *info_ptr = per_objfile->info.buffer + per_cu->offset;
      struct comp_unit_head cu_header;

      memset (&cu_header, 0, sizeof cu_header);
      read_comp_unit_head (&cu_header, info_ptr, objfile->obfd);
      return cu_header.addr_size;
    }
d15308 6
a15313 15
  if (per_cu->cu)
    return per_cu->cu->header.offset_size;
  else
    {
      /* If the CU is not currently read in, we re-read its header.  */
      struct objfile *objfile = per_cu->objfile;
      struct dwarf2_per_objfile *per_objfile
	= objfile_data (objfile, dwarf2_objfile_data_key);
      gdb_byte *info_ptr = per_objfile->info.buffer + per_cu->offset;
      struct comp_unit_head cu_header;

      memset (&cu_header, 0, sizeof cu_header);
      read_comp_unit_head (&cu_header, info_ptr, objfile->obfd);
      return cu_header.offset_size;
    }
@


1.562
log
@gdb/
	Fix printed anonymous struct name.
	* dwarf2read.c (fixup_partial_die): Handle for anonymous structs also
	DW_TAG_interface_type.  Strip for anonymous structs any prefixes.
	(anonymous_struct_prefix): New function.
	(determine_prefix): New variables retval.  Call anonymous_struct_prefix.
	(dwarf2_name): Strip for anonymous structs any prefixes.

gdb/testsuite/
	Fix printed anonymous struct name.
	* gdb.cp/anon-struct.exp (print type of X::t2): New test.
@
text
@d2653 15
a2667 1
    return NULL;
@


1.561
log
@gdb/
	Remove excessive DWARF expressions memory duplication.
	* dwarf2loc.c (per_cu_dwarf_call): Remove variable back_to and its use
	for block.data.
	(indirect_pieced_value): Remove variable result.  Remove variable
	back_to and its use for baton.data.
	(dwarf2_compile_expr_to_ax): Remove variable back_to and its use for
	block.data.
	* dwarf2read.c (dwarf2_fetch_die_location_block): Remove xmemdup.
	Update the function comment.
@
text
@d9804 4
a9807 3
      && (part_die->tag == DW_TAG_structure_type
	  || part_die->tag == DW_TAG_union_type
	  || part_die->tag == DW_TAG_class_type)
d9815 11
a9825 1
	  part_die->name = obsavestring (demangled, strlen (demangled),
d12174 36
d12231 1
d12237 4
d12532 2
d12535 2
a12536 3
	      DW_STRING (attr)
		= obsavestring (demangled, strlen (demangled),
				&cu->objfile->objfile_obstack);
d12539 8
@


1.560
log
@gdb/
	Code cleanup.
	* amd64-tdep.c (amd64_skip_prologue): Move the XMM code to ...
	(amd64_skip_xmm_prologue): ... this new function.  Describe its
	parameters.  No longer use amd64_prologue_line_bug.
	* defs.h (producer_is_gcc_ge_4): New declaration.
	* dwarf2read.c (producer_is_gcc_ge_4): Move to utils.c.
	(process_full_comp_unit): Update its caller.  Remove
	amd64_prologue_line_bug initialization.
	* symtab.h (struct symtab): Remove field amd64_prologue_line_bug.
	* utils.c (producer_is_gcc_ge_4): Moved here from dwarf2read.c.
@
text
@d13857 3
a13859 3
/* Return DWARF block and its CU referenced by OFFSET at PER_CU.  Returned
   value is intended for DW_OP_call*.  You must call xfree on returned
   dwarf2_locexpr_baton->data.  */
a13914 3
  if (retval.data)
    retval.data = xmemdup (retval.data, retval.size, retval.size);

@


1.559
log
@gdb/
	PR breakpoints/12435
	* amd64-tdep.c (amd64_skip_prologue): New variables start_pc_sal,
	next_sal, buf, offset and xmmreg.  Advance PC if it sees the PR.
	* dwarf2read.c (process_full_comp_unit): Initialize
	amd64_prologue_line_bug.
	* symtab.h (struct symtab): New field amd64_prologue_line_bug.

gdb/testsuite/
	PR breakpoints/12435
	* gdb.arch/amd64-prologue-xmm.c: New file.
	* gdb.arch/amd64-prologue-xmm.exp: New file.
	* gdb.arch/amd64-prologue-xmm.s: New file.
@
text
@a4725 44
/* Check for GCC >= 4.x.  Return minor version (x) of 4.x in such case.  If it
   is not GCC or it is GCC older than 4.x return -1.  If it is GCC 5.x or
   higher return INT_MAX.  */

static int
producer_is_gcc_ge_4 (struct dwarf2_cu *cu)
{
  const char *cs;
  int major, minor;

  if (cu->producer == NULL)
    {
      /* For unknown compilers expect their behavior is not compliant.  For GCC
	 this case can also happen for -gdwarf-4 type units supported since
	 gcc-4.5.  */

      return -1;
    }

  /* Skip any identifier after "GNU " - such as "C++" or "Java".  */

  if (strncmp (cu->producer, "GNU ", strlen ("GNU ")) != 0)
    {
      /* For non-GCC compilers expect their behavior is not compliant.  */

      return -1;
    }
  cs = &cu->producer[strlen ("GNU ")];
  while (*cs && !isdigit (*cs))
    cs++;
  if (sscanf (cs, "%d.%d", &major, &minor) != 2)
    {
      /* Not recognized as GCC.  */

      return -1;
    }

  if (major < 4)
    return -1;
  if (major > 4)
    return INT_MAX;
  return minor;
}

d4765 1
a4765 1
      int gcc_4_minor = producer_is_gcc_ge_4 (cu);
a4787 3

      if (gcc_4_minor >= 6)
	symtab->amd64_prologue_line_bug = 1;
@


1.558
log
@gdb/
	Revert:
	2010-05-21  Pierre Muller  <muller@@ics.u-strasbg.fr>
	* dwarf2read.c (new_symbol): Handle DW_AT_variable_parameter
	attribute.

gdb/testsuite/
	* dw2-ifort-parameter-debug.S: New file.
	* dw2-ifort-parameter.c: New file.
	* dw2-ifort-parameter.exp: New file.
@
text
@d4832 3
@


1.557
log
@gdb/
	* dwarf2expr.c (ctx_no_read_reg): New function.
	* dwarf2expr.h (ctx_no_read_reg): New declaration.
	* dwarf2read.c (read_2_signed_bytes, read_4_signed_bytes): Remove.
	(decode_locdesc_read_mem, decode_locdesc_ctx_funcs): New.
	(decode_locdesc): Replace by a caller of dwarf_expr_eval.

gdb/testsuite/
	* gdb.dwarf2/dw2-simple-locdesc.S: New file.
	* gdb.dwarf2/dw2-simple-locdesc.exp: New file.
	* gdb.dwarf2/dw2-stack-boundary.exp (check partial symtab errors):
	Change the expected string.
@
text
@a11580 8
	  attr = dwarf2_attr (die, DW_AT_variable_parameter, cu);
	  if (attr && DW_UNSND (attr))
	    {
	      struct type *ref_type;

	      ref_type = lookup_reference_type (SYMBOL_TYPE (sym));
	      SYMBOL_TYPE (sym) = ref_type;
	    }
@


1.556
log
@	* xcoffread.c (dwarf2_xcoff_names): Add 'macro' and 'sentinel'
	entries.
	* symfile.h (struct dwarf2_debug_sections) <sentinel>: New field.
	* dwarf2read.c (dwarf2_elf_names): Add sentinel entry.
@
text
@a10061 6
static int
read_2_signed_bytes (bfd *abfd, gdb_byte *buf)
{
  return bfd_get_signed_16 (abfd, buf);
}

a10067 6
static int
read_4_signed_bytes (bfd *abfd, gdb_byte *buf)
{
  return bfd_get_signed_32 (abfd, buf);
}

d14142 31
d14190 1
a14190 3
   complaint.

   Note that stack[0] is unused except as a default error return.  */
d14196 3
a14198 7
  int i;
  int size = blk->size;
  gdb_byte *data = blk->data;
  CORE_ADDR stack[64];
  int stacki;
  unsigned int bytes_read, unsnd;
  gdb_byte op;
d14200 3
a14202 4
  i = 0;
  stacki = 0;
  stack[stacki] = 0;
  stack[++stacki] = 0;
d14204 5
a14208 172
  while (i < size)
    {
      op = data[i++];
      switch (op)
	{
	case DW_OP_lit0:
	case DW_OP_lit1:
	case DW_OP_lit2:
	case DW_OP_lit3:
	case DW_OP_lit4:
	case DW_OP_lit5:
	case DW_OP_lit6:
	case DW_OP_lit7:
	case DW_OP_lit8:
	case DW_OP_lit9:
	case DW_OP_lit10:
	case DW_OP_lit11:
	case DW_OP_lit12:
	case DW_OP_lit13:
	case DW_OP_lit14:
	case DW_OP_lit15:
	case DW_OP_lit16:
	case DW_OP_lit17:
	case DW_OP_lit18:
	case DW_OP_lit19:
	case DW_OP_lit20:
	case DW_OP_lit21:
	case DW_OP_lit22:
	case DW_OP_lit23:
	case DW_OP_lit24:
	case DW_OP_lit25:
	case DW_OP_lit26:
	case DW_OP_lit27:
	case DW_OP_lit28:
	case DW_OP_lit29:
	case DW_OP_lit30:
	case DW_OP_lit31:
	  stack[++stacki] = op - DW_OP_lit0;
	  break;

	case DW_OP_reg0:
	case DW_OP_reg1:
	case DW_OP_reg2:
	case DW_OP_reg3:
	case DW_OP_reg4:
	case DW_OP_reg5:
	case DW_OP_reg6:
	case DW_OP_reg7:
	case DW_OP_reg8:
	case DW_OP_reg9:
	case DW_OP_reg10:
	case DW_OP_reg11:
	case DW_OP_reg12:
	case DW_OP_reg13:
	case DW_OP_reg14:
	case DW_OP_reg15:
	case DW_OP_reg16:
	case DW_OP_reg17:
	case DW_OP_reg18:
	case DW_OP_reg19:
	case DW_OP_reg20:
	case DW_OP_reg21:
	case DW_OP_reg22:
	case DW_OP_reg23:
	case DW_OP_reg24:
	case DW_OP_reg25:
	case DW_OP_reg26:
	case DW_OP_reg27:
	case DW_OP_reg28:
	case DW_OP_reg29:
	case DW_OP_reg30:
	case DW_OP_reg31:
	  stack[++stacki] = op - DW_OP_reg0;
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
	  break;

	case DW_OP_regx:
	  unsnd = read_unsigned_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  stack[++stacki] = unsnd;
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
	  break;

	case DW_OP_addr:
	  stack[++stacki] = read_address (objfile->obfd, &data[i],
					  cu, &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_const1u:
	  stack[++stacki] = read_1_byte (objfile->obfd, &data[i]);
	  i += 1;
	  break;

	case DW_OP_const1s:
	  stack[++stacki] = read_1_signed_byte (objfile->obfd, &data[i]);
	  i += 1;
	  break;

	case DW_OP_const2u:
	  stack[++stacki] = read_2_bytes (objfile->obfd, &data[i]);
	  i += 2;
	  break;

	case DW_OP_const2s:
	  stack[++stacki] = read_2_signed_bytes (objfile->obfd, &data[i]);
	  i += 2;
	  break;

	case DW_OP_const4u:
	  stack[++stacki] = read_4_bytes (objfile->obfd, &data[i]);
	  i += 4;
	  break;

	case DW_OP_const4s:
	  stack[++stacki] = read_4_signed_bytes (objfile->obfd, &data[i]);
	  i += 4;
	  break;

	case DW_OP_constu:
	  stack[++stacki] = read_unsigned_leb128 (NULL, (data + i),
						  &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_consts:
	  stack[++stacki] = read_signed_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_dup:
	  stack[stacki + 1] = stack[stacki];
	  stacki++;
	  break;

	case DW_OP_plus:
	  stack[stacki - 1] += stack[stacki];
	  stacki--;
	  break;

	case DW_OP_plus_uconst:
	  stack[stacki] += read_unsigned_leb128 (NULL, (data + i),
						 &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_minus:
	  stack[stacki - 1] -= stack[stacki];
	  stacki--;
	  break;

	case DW_OP_deref:
	  /* If we're not the last op, then we definitely can't encode
	     this using GDB's address_class enum.  This is valid for partial
	     global symbols, although the variable's address will be bogus
	     in the psymtab.  */
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
	  break;

        case DW_OP_GNU_push_tls_address:
	  /* The top of the stack has the offset from the beginning
	     of the thread control block at which the variable is located.  */
	  /* Nothing should follow this operator, so the top of stack would
	     be returned.  */
	  /* This is valid for partial global symbols, but the variable's
	     address will be bogus in the psymtab.  */
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
          break;
d14210 3
a14212 2
	case DW_OP_GNU_uninit:
	  break;
d14214 15
a14228 3
	default:
	  {
	    const char *name = dwarf_stack_op_name (op);
d14230 4
a14233 7
	    if (name)
	      complaint (&symfile_complaints, _("unsupported stack op: '%s'"),
			 name);
	    else
	      complaint (&symfile_complaints, _("unsupported stack op: '%02x'"),
			 op);
	  }
d14235 2
a14236 1
	  return (stack[stacki]);
d14238 1
d14240 3
a14242 17
      /* Enforce maximum stack depth of SIZE-1 to avoid writing
         outside of the allocated space.  Also enforce minimum>0.  */
      if (stacki >= ARRAY_SIZE (stack) - 1)
	{
	  complaint (&symfile_complaints,
		     _("location description stack overflow"));
	  return 0;
	}

      if (stacki <= 0)
	{
	  complaint (&symfile_complaints,
		     _("location description stack underflow"));
	  return 0;
	}
    }
  return (stack[stacki]);
@


1.555
log
@	* symfile.h (struct dwarf2_debug_sections) <macro>: New field.
	* dwarf2read.c (read_indirect_string_at_offset): New function.
	(read_indirect_string): Use it.
	(dwarf_decode_macro_bytes): New function, taken from
	dwarf_decode_macros.  Handle DW_MACRO_GNU_*.
	(dwarf_decode_macros): Use it.  handle DW_MACRO_GNU_*.
	(dwarf_parse_macro_header, skip_form_bytes, skip_unknown_opcode):
	New functions.
	(struct dwarf2_per_objfile) <macro>: New field.
	(dwarf2_elf_names): Add .debug_macro.
	(dwarf2_macros_too_long_complaint): Add 'section' argument.
	(dwarf2_locate_sections): Handle new section.
	(read_file_scope): Handle DW_AT_GNU_macros.
	(dwarf2_per_objfile_free): Unmap the .debug_macro section.
@
text
@d274 2
a275 1
  { ".gdb_index", ".zgdb_index" }
@


1.554
log
@	* dwarf2read.c (process_enumeration_scope): Do not call new_symbol
	in some declaration-only cases.
@
text
@d190 1
d268 1
d863 1
a863 1
dwarf2_macros_too_long_complaint (void)
d866 2
a867 1
	     _("macro info runs off end of `.debug_macinfo' section"));
d1239 3
a1241 1
                                 char *, bfd *, struct dwarf2_cu *);
d1446 5
d5654 1
a5654 1
  attr = dwarf2_attr (die, DW_AT_macro_info, cu);
d5657 14
a5670 1
      unsigned int macro_offset = DW_UNSND (attr);
d5672 4
a5675 2
      dwarf_decode_macros (cu->line_header, macro_offset,
                           comp_dir, abfd, cu);
d10290 1
a10290 3
read_indirect_string (bfd *abfd, gdb_byte *buf,
		      const struct comp_unit_head *cu_header,
		      unsigned int *bytes_read_ptr)
a10291 2
  LONGEST str_offset = read_offset (abfd, buf, cu_header, bytes_read_ptr);

d10294 2
a10295 5
    {
      error (_("DW_FORM_strp used without .debug_str section [in module %s]"),
		      bfd_get_filename (abfd));
      return NULL;
    }
d10297 3
a10299 6
    {
      error (_("DW_FORM_strp pointing outside of "
	       ".debug_str section [in module %s]"),
	     bfd_get_filename (abfd));
      return NULL;
    }
d10306 10
d14697 2
d14700 5
a14704 4
static void
dwarf_decode_macros (struct line_header *lh, unsigned int offset,
                     char *comp_dir, bfd *abfd,
                     struct dwarf2_cu *cu)
d14706 1
a14706 4
  gdb_byte *mac_ptr, *mac_end;
  struct macro_source_file *current_file = 0;
  enum dwarf_macinfo_record_type macinfo_type;
  int at_commandline;
d14708 1
a14708 3
  dwarf2_read_section (dwarf2_per_objfile->objfile,
		       &dwarf2_per_objfile->macinfo);
  if (dwarf2_per_objfile->macinfo.buffer == NULL)
d14710 56
a14765 2
      complaint (&symfile_complaints, _("missing .debug_macinfo section"));
      return;
d14768 2
a14769 5
  /* First pass: Find the name of the base filename.
     This filename is needed in order to process all macros whose definition
     (or undefinition) comes from the command line.  These macros are defined
     before the first DW_MACINFO_start_file entry, and yet still need to be
     associated to the base file.
d14771 3
a14773 4
     To determine the base file name, we scan the macro definitions until we
     reach the first DW_MACINFO_start_file entry.  We then initialize
     CURRENT_FILE accordingly so that any macro definition found before the
     first DW_MACINFO_start_file can still be associated to the base file.  */
d14775 11
a14785 3
  mac_ptr = dwarf2_per_objfile->macinfo.buffer + offset;
  mac_end = dwarf2_per_objfile->macinfo.buffer
    + dwarf2_per_objfile->macinfo.size;
d14787 1
a14787 1
  do
d14789 9
a14797 8
      /* Do we at least have room for a macinfo type byte?  */
      if (mac_ptr >= mac_end)
        {
	  /* Complaint is printed during the second pass as GDB will probably
	     stop the first pass earlier upon finding
	     DW_MACINFO_start_file.  */
	  break;
        }
d14799 9
a14807 2
      macinfo_type = read_1_byte (abfd, mac_ptr);
      mac_ptr++;
d14809 2
a14810 6
      switch (macinfo_type)
        {
          /* A zero macinfo type indicates the end of the macro
             information.  */
        case 0:
	  break;
d14812 4
a14815 5
	case DW_MACINFO_define:
	case DW_MACINFO_undef:
	  /* Only skip the data by MAC_PTR.  */
	  {
	    unsigned int bytes_read;
d14817 8
a14824 6
	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	    read_direct_string (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	  }
	  break;
d14826 3
a14828 4
	case DW_MACINFO_start_file:
	  {
	    unsigned int bytes_read;
	    int line, file;
d14830 9
a14838 4
	    line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	    file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
d14840 3
a14842 4
	    current_file = macro_start_file (file, line, current_file,
					     comp_dir, lh, cu->objfile);
	  }
	  break;
d14844 3
a14846 3
	case DW_MACINFO_end_file:
	  /* No data to skip by MAC_PTR.  */
	  break;
d14848 4
a14851 4
	case DW_MACINFO_vendor_ext:
	  /* Only skip the data by MAC_PTR.  */
	  {
	    unsigned int bytes_read;
d14853 6
a14858 6
	    read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	    read_direct_string (abfd, mac_ptr, &bytes_read);
	    mac_ptr += bytes_read;
	  }
	  break;
d14860 7
a14866 2
	default:
	  break;
d14868 4
a14871 1
    } while (macinfo_type != 0 && current_file == NULL);
d14873 2
a14874 1
  /* Second pass: Process all entries.
d14876 12
a14887 3
     Use the AT_COMMAND_LINE flag to determine whether we are still processing
     command-line macro definitions/undefinitions.  This flag is unset when we
     reach the first DW_MACINFO_start_file entry.  */
d14889 7
a14895 1
  mac_ptr = dwarf2_per_objfile->macinfo.buffer + offset;
d14911 1
a14911 1
	  dwarf2_macros_too_long_complaint ();
d14918 2
d14927 4
a14930 2
        case DW_MACINFO_define:
        case DW_MACINFO_undef:
d14935 17
d14953 2
a14954 4
            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            body = read_direct_string (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
d14956 2
d14964 2
a14965 5
			   macinfo_type == DW_MACINFO_define ?
			     _("definition") :
			       macinfo_type == DW_MACINFO_undef ?
				 _("undefinition") :
				 _("something-or-other"), line, body);
d14973 1
a14973 5
			 macinfo_type == DW_MACINFO_define ?
			   _("definition") :
			     macinfo_type == DW_MACINFO_undef ?
			       _("undefinition") :
			       _("something-or-other"),
d14976 1
a14976 1
	    if (macinfo_type == DW_MACINFO_define)
d14978 6
a14983 2
	    else if (macinfo_type == DW_MACINFO_undef)
	      macro_undef (current_file, line, body);
d14987 1
a14987 1
        case DW_MACINFO_start_file:
d15007 2
a15008 1
		/* This DW_MACINFO_start_file was executed in the pass one.  */
d15014 1
a15014 1
					       lh, cu->objfile);
d15018 1
a15018 1
        case DW_MACINFO_end_file:
d15028 1
a15028 1
                  enum dwarf_macinfo_record_type next_type;
d15038 1
a15038 1
		      dwarf2_macros_too_long_complaint ();
d15055 16
d15072 9
a15080 3
          {
            unsigned int bytes_read;
            int constant;
d15082 4
a15085 4
            constant = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            read_direct_string (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
d15087 7
a15093 3
            /* We don't recognize any vendor extensions.  */
          }
          break;
d15098 150
d15974 1
@


1.553
log
@	PR symtab/12984:
	* dwarf2read.c (dwarf2_section_info_def): New typedef.
	(struct dwarf2_per_objfile) <types>: Change to a VEC.
	(struct dwarf2_per_cu_data) <from_debug_types>: Remove.
	<debug_type_section>: New field.
	(dwarf2_locate_sections): Push .debug_types sections onto VEC.
	(load_cu): Use appropriate section.
	(create_signatured_type_table_from_index): Add 'section'
	argument.
	(dwarf2_read_index): Only allow a single .debug_types section.
	(dw2_get_file_names): Use appropriate section.
	(read_type_comp_unit_head): Add 'section' argument.
	(create_debug_types_hash_table): Loop over all .debug_types
	sections.
	(init_cu_die_reader): Use appropriate section.
	(process_psymtab_comp_unit, load_partial_comp_unit)
	(load_full_comp_unit, read_die_and_children, find_partial_die)
	(lookup_die_type, determine_prefix, follow_die_offset): Update.
	(lookup_signatured_type_at_offset): Add 'section' argument.
	(read_signatured_type_at_offset): Add 'sect' argument.
	(read_signatured_type): Use appropriate section.
	(set_die_type, get_die_type_at_offset): Update.
	(dwarf2_per_objfile_free): Free all .debug_types sections, and
	VEC.
	(write_psymtabs_to_index): Don't allow index with more than one
	.debug_types section.
@
text
@d1210 5
d7738 21
@


1.552
log
@gdb/
	Fix crash if referenced CU is aged out.
	* dwarf2loc.c (per_cu_dwarf_call): New variable back_to, use to for
	xfree of block.data.
	(indirect_pieced_value): New variable back_to, use to for xfree of
	baton.data.
	(dwarf2_compile_expr_to_ax): New variable back_to, use to for xfree of
	block.data.
	* dwarf2read.c (dwarf2_find_base_address): New prototype.
	(load_cu): New function from ...
	(dw2_do_instantiate_symtab): ... the code here ...
	(process_full_comp_unit): ... and here.
	(dwarf2_fetch_die_location_block): Call load_cu first.  Call xmemdup on
	retval.data.

gdb/testsuite/
	Fix crash if referenced CU is aged out.
	* gdb.dwarf2/dw2-op-call.exp (maintenance set dwarf2 max-cache-age 0):
	New.
	* gdb.dwarf2/implptr.exp: Likewise.
@
text
@d148 3
a191 1
  struct dwarf2_section_info types;
d196 2
d454 3
a456 3
  /* Non-zero if this CU is from .debug_types.
     Otherwise it's from .debug_info.  */
  unsigned int from_debug_types : 1;
d1211 1
d1463 8
a1470 2
      dwarf2_per_objfile->types.asection = sectp;
      dwarf2_per_objfile->types.size = bfd_get_section_size (sectp);
d1812 4
a1815 2
  if (per_cu->from_debug_types)
    read_signatured_type_at_offset (per_cu->objfile, per_cu->offset);
d1945 1
d1976 1
a1976 1
      type_sig->per_cu.from_debug_types = 1;
d2204 17
a2220 4
  if (types_list_elements
      && !create_signatured_type_table_from_index (objfile, types_list,
						   types_list_elements))
    return 0;
d2274 2
a2275 2
  if (this_cu->from_debug_types)
    sec = &dwarf2_per_objfile->types;
d2298 1
a2298 1
  if (this_cu->from_debug_types)
d2966 1
d2972 2
a2973 3
  dwarf2_read_section (dwarf2_per_objfile->objfile,
		       &dwarf2_per_objfile->types);
  cu_header->offset = types_ptr - dwarf2_per_objfile->types.buffer;
d3101 1
a3101 2
  gdb_byte *info_ptr;
  htab_t types_htab;
d3103 2
d3106 1
a3106 4
  dwarf2_read_section (objfile, &dwarf2_per_objfile->types);
  info_ptr = dwarf2_per_objfile->types.buffer;

  if (info_ptr == NULL)
d3112 6
a3117 1
  types_htab = allocate_signatured_type_table (objfile);
d3119 2
a3120 2
  if (dwarf2_die_debug)
    fprintf_unfiltered (gdb_stdlog, "Signatured types:\n");
d3122 2
a3123 12
  while (info_ptr < dwarf2_per_objfile->types.buffer
	 + dwarf2_per_objfile->types.size)
    {
      unsigned int offset;
      unsigned int offset_size;
      unsigned int type_offset;
      unsigned int length, initial_length_size;
      unsigned short version;
      ULONGEST signature;
      struct signatured_type *type_sig;
      void **slot;
      gdb_byte *ptr = info_ptr;
d3125 2
a3126 1
      offset = ptr - dwarf2_per_objfile->types.buffer;
d3128 2
a3129 2
      /* We need to read the type's signature in order to build the hash
	 table, but we don't need to read anything else just yet.  */
d3131 2
a3132 4
      /* Sanity check to ensure entire cu is present.  */
      length = read_initial_length (objfile->obfd, ptr, &initial_length_size);
      if (ptr + length + initial_length_size
	  > dwarf2_per_objfile->types.buffer + dwarf2_per_objfile->types.size)
d3134 9
a3142 5
	  complaint (&symfile_complaints,
		     _("debug type entry runs off end "
		       "of `.debug_types' section, ignored"));
	  break;
	}
d3144 1
a3144 9
      offset_size = initial_length_size == 4 ? 4 : 8;
      ptr += initial_length_size;
      version = bfd_get_16 (objfile->obfd, ptr);
      ptr += 2;
      ptr += offset_size; /* abbrev offset */
      ptr += 1; /* address size */
      signature = bfd_get_64 (objfile->obfd, ptr);
      ptr += 8;
      type_offset = read_offset_1 (objfile->obfd, ptr, offset_size);
d3146 2
a3147 7
      type_sig = obstack_alloc (&objfile->objfile_obstack, sizeof (*type_sig));
      memset (type_sig, 0, sizeof (*type_sig));
      type_sig->signature = signature;
      type_sig->type_offset = type_offset;
      type_sig->per_cu.objfile = objfile;
      type_sig->per_cu.from_debug_types = 1;
      type_sig->per_cu.offset = offset;
d3149 10
a3158 5
      slot = htab_find_slot (types_htab, type_sig, INSERT);
      gdb_assert (slot != NULL);
      if (*slot != NULL)
	{
	  const struct signatured_type *dup_sig = *slot;
d3160 23
a3182 8
	  complaint (&symfile_complaints,
		     _("debug type entry at offset 0x%x is duplicate to the "
		       "entry at offset 0x%x, signature 0x%s"),
		     offset, dup_sig->per_cu.offset,
		     phex (signature, sizeof (signature)));
	  gdb_assert (signature == dup_sig->signature);
	}
      *slot = type_sig;
d3184 12
a3195 3
      if (dwarf2_die_debug)
	fprintf_unfiltered (gdb_stdlog, "  offset 0x%x, signature 0x%s\n",
			    offset, phex (signature, sizeof (signature)));
d3197 2
a3198 1
      info_ptr = info_ptr + initial_length_size + length;
d3244 1
a3244 1
  if (cu->per_cu->from_debug_types)
d3246 2
a3247 2
      gdb_assert (dwarf2_per_objfile->types.readin);
      reader->buffer = dwarf2_per_objfile->types.buffer;
d3348 1
a3348 1
  if (this_cu->from_debug_types)
d3354 1
a3354 1
  if (this_cu->from_debug_types)
d3450 1
a3450 1
  if (this_cu->from_debug_types)
d3479 1
a3479 1
  gdb_assert (dwarf2_per_objfile->types.readin);
d3481 4
a3484 3
			     dwarf2_per_objfile->types.buffer,
			     dwarf2_per_objfile->types.buffer + this_cu->offset,
			     dwarf2_per_objfile->types.size);
d3593 1
a3593 1
  gdb_assert (! this_cu->from_debug_types);
d4592 1
a4592 1
  gdb_assert (! per_cu->from_debug_types);
d8834 3
a8836 5
			  reader->buffer == dwarf2_per_objfile->info.buffer
			  ? ".debug_info"
			  : reader->buffer == dwarf2_per_objfile->types.buffer
			  ? ".debug_types"
			  : "unknown section",
d9622 1
a9622 1
  if (cu->per_cu->from_debug_types)
d9785 1
a9785 1
      && dwarf2_per_objfile->types.asection != NULL
d11962 1
a11962 1
      gdb_assert (sig_type->per_cu.from_debug_types);
d12304 1
a12304 1
	    && dwarf2_per_objfile->types.asection != NULL
d13816 1
a13816 1
  if (cu->per_cu->from_debug_types)
d13991 3
a13993 1
lookup_signatured_type_at_offset (struct objfile *objfile, unsigned int offset)
d13995 1
a13995 1
  gdb_byte *info_ptr = dwarf2_per_objfile->types.buffer + offset;
d14020 1
d14025 1
a14025 1
  dwarf2_read_section (objfile, &dwarf2_per_objfile->types);
d14029 1
a14029 1
  type_sig = lookup_signatured_type_at_offset (objfile, offset);
d14049 1
d14051 2
a14052 2
  dwarf2_read_section (objfile, &dwarf2_per_objfile->types);
  types_ptr = dwarf2_per_objfile->types.buffer + type_sig->per_cu.offset;
d14065 1
a14065 1
  types_ptr = read_type_comp_unit_head (&cu->header, &signature,
d15433 1
a15433 1
  if (cu->per_cu->from_debug_types)
d15473 1
a15473 1
  if (per_cu->from_debug_types)
d15630 2
a15641 1
  munmap_section_buffer (&data->types);
d15645 7
d16239 3
@


1.551
log
@	* dwarf2read.c (read_subrange_type): Use attr_form_is_block when
	checking for variable-sized array.
@
text
@d887 3
d1794 17
d1824 1
a1824 4
  if (per_cu->from_debug_types)
    read_signatured_type_at_offset (objfile, per_cu->offset);
  else
    load_full_comp_unit (per_cu, objfile);
a4733 2
  dwarf2_find_base_address (cu->dies, cu);

d13831 2
a13832 1
   value is intended for DW_OP_call*.  */
d13840 1
a13840 1
  struct dwarf2_cu *cu = per_cu->cu;
d13847 4
d13887 6
@


1.550
log
@gdb/
	Fix occasional crash of CTRL-C during DWARF read in.
	* dwarf2read.c (dwarf2_mark_helper): Return on NULL CU.
@
text
@d8583 1
a8583 1
      if (attr->form == DW_FORM_block1 || is_ref_attr (attr))
d8666 1
a8666 1
  if (attr && attr->form == DW_FORM_block1)
@


1.549
log
@	* dwarf2read.c (handle_DW_AT_stmt_list): New function.
	(read_file_scope, read_type_unit_scope): Use it.
@
text
@d15458 7
@


1.548
log
@gdb
	* gnu-v3-abi.c (gnuv3_rtti_type): Check TYPE_CPLUS_REALLY_JAVA.
	* gdbtypes.h (struct cplus_struct_type) <is_java>: New field.
	(TYPE_CPLUS_REALLY_JAVA): New macro.
	* dwarf2read.c (process_structure_scope): Set
	TYPE_CPLUS_REALLY_JAVA.
gdb/testsuite
	* gdb.java/jprint.java (jprint.hi): New field.
	* gdb.java/jprint.exp: Print string.
@
text
@d5481 29
a5523 1
  struct line_header *line_header = 0;
d5566 1
a5566 15
  /* Decode line number information if present.  We do this before
     processing child DIEs, so that the line header table is available
     for DW_AT_decl_file.  */
  attr = dwarf2_attr (die, DW_AT_stmt_list, cu);
  if (attr)
    {
      unsigned int line_offset = DW_UNSND (attr);
      line_header = dwarf_decode_line_header (line_offset, abfd, cu);
      if (line_header)
        {
          cu->line_header = line_header;
          make_cleanup (free_cu_line_header, cu);
          dwarf_decode_lines (line_header, comp_dir, abfd, cu, NULL);
        }
    }
d5584 1
a5584 1
  if (attr && line_header)
d5588 1
a5588 1
      dwarf_decode_macros (line_header, macro_offset,
d5653 2
@


1.547
log
@gdb/
	* dwarf2read.c (check_physname): New variable.
	(dwarf2_physname): Prefer DW_AT_linkage_name over dwarf2_compute_name.
	(show_check_physname): New function.
	(_initialize_dwarf2_read): Add `check-physname' for check_physname.

gdb/doc/
	* gdb.texinfo (Debugging Output): Document set debug
	check-physname.

gdb/testsuite/
	* gdb.base/break-interp.exp (reach_1, test_ld): Allow also the prefix
	__GI_.
	* gdb.cp/psymtab-parameter.cc (func): Make it a template function.
	(f): New function.
	* gdb.cp/psymtab-parameter.exp (complete break 'func(): Rename to ...
	(complete p 'func<short>(): ... here.
	* gdb.dwarf2/dw2-linkage-name-trust-main.cc: New file.
	* gdb.dwarf2/dw2-linkage-name-trust.S: New file.
	* gdb.dwarf2/dw2-linkage-name-trust.exp: New file.
	* gdb.cp/temargs.exp (test type of F in k3_m, test value of F in k3_m):
	Make them KFAIL gcc/49546.
@
text
@d7495 3
@


1.546
log
@gdb/
	Disable epilogue unwinders on recent GCCs.
	* amd64-tdep.c (amd64_in_function_epilogue_p): New variable symtab,
	initialize it, return 0 on EPILOGUE_UNWIND_VALID.
	* dwarf2read.c (process_full_comp_unit): Initialize
	EPILOGUE_UNWIND_VALID.
	* i386-tdep.c (i386_in_function_epilogue_p): New variable symtab,
	initialize it, return 0 on EPILOGUE_UNWIND_VALID.
	* symtab.h (struct symtab): New field epilogue_unwind_valid.
@
text
@d122 3
d5186 85
a5270 1
  return dwarf2_compute_name (name, die, cu, 1);
d16344 9
d16408 8
@


1.545
log
@gdb/
	Code cleanup - reformatting.
	* dwarf2read.c (producer_is_gcc_ge_4_0): Rename to ...
	(producer_is_gcc_ge_4): ... here, change the return value.
	(process_full_comp_unit): New variable gcc_4_minor, adjust the value
	interpretation.
@
text
@d4754 3
@


1.544
log
@gdb/
	Fix non-only rename list for Fortran modules import.
	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Adjust the
	cp_add_using_directive caller.
	(cp_add_using_directive): New parameter excludes, describe it.  New
	variables ix and param.  Compare if also excludes match.  Allocate NEW
	with variable size, initialize EXCLUDES there.
	(cp_lookup_symbol_imports): New variable excludep, test
	current->EXCLUDES with it.
	* cp-support.h: Include vec.h.
	(struct using_direct): New field excludes, describe it.
	(DEF_VEC_P (const_char_ptr)): New.
	(cp_add_using_directive): New parameter excludes.
	* defs.h (const_char_ptr): New typedef.
	* dwarf2read.c (read_import_statement): New variables child_die,
	excludes and cleanups, read in excludes.
	(read_namespace): Adjust the cp_add_using_directive caller.

gdb/testsuite/
	Fix non-only rename list for Fortran modules import.
	* gdb.fortran/module.exp (print var_x, print var_y, print var_z): New
	tests.
	* gdb.fortran/module.f90 (module moduse): New.
	(program module): use moduse, test var_x, var_y and var_z.
@
text
@d4649 3
a4651 1
/* Check for GCC >= 4.0.  */
d4654 1
a4654 1
producer_is_gcc_ge_4_0 (struct dwarf2_cu *cu)
d4665 1
a4665 1
      return 0;
d4674 1
a4674 1
      return 0;
d4683 1
a4683 1
      return 0;
d4686 5
a4690 1
  return major >= 4;
d4734 2
d4752 1
a4752 1
      if (cu->has_loclist && producer_is_gcc_ge_4_0 (cu))
@


1.543
log
@gdb
	PR fortran/10036:
	* valprint.h (generic_emit_char, generic_printstr): Declare.
	* valprint.c (wchar_printable, append_string_as_wide)
	(print_wchar): Move from c-lang.c.
	(generic_emit_char): New function; mostly taken from c_emit_char.
	(generic_printstr): New function; mostly taken from c_printstr.
	* f-valprint.c (f_val_print) <TYPE_CODE_ARRAY>: Handle strings
	represented as arrays.
	<TYPE_CODE_CHAR>: Treat as TYPE_CODE_INT; recognize as character
	type.
	* f-typeprint.c (f_type_print_base) <TYPE_CODE_CHAR>: Treat
	identically to TYPE_CODE_INT.
	* f-lang.c (f_get_encoding): New function.
	(f_emit_char): Use generic_emit_char.
	(f_printchar): Replace comment.
	(f_printstr): Use generic_printstr.
	* dwarf2read.c (read_base_type) <DW_ATE_unsigned>: Handle Fortran
	"character" types specially.
	<DW_ATE_signed_char, DW_ATE_unsigned_char>: Make TYPE_CODE_CHAR
	for Fortran.
	* c-lang.c (wchar_printable, append_string_as_wide, print_wchar):
	Move to valprint.c
	(c_emit_char): Call generic_emit_char.
	(c_printstr): Call generic_printstr.
gdb/testsuite
	* gdb.fortran/charset.exp: New file.
	* gdb.fortran/charset.f90: New file.
@
text
@d5181 1
a5181 1
  struct die_info *imported_die;
d5189 2
d5270 46
d5320 1
d5322 2
d7851 1
a7851 1
	                          NULL, &objfile->objfile_obstack);
@


1.542
log
@2011-06-27  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2read.c (struct dwarf2_section_info): Replace was_mmapped
	field by map_addr and map_len.
	(dwarf2_read_section): Adjust for the new bfd_mmap api.
	(munmap_section_buffer): Likewise.
@
text
@d8338 4
d8345 2
a8346 1
	    || cu->language == language_pascal)
d8351 2
a8352 1
	    || cu->language == language_pascal)
@


1.541
log
@gdb/
	Code cleanup.
	* dwarf2read.c (dw2_map_symbol_filenames): Use symbol_filename_ftype
	for fun.
	* psymtab.c (map_symbol_filenames_psymtab)
	(map_partial_symbol_filenames): Likewise.
	* psymtab.h: Include symfile.h.
	(map_partial_symbol_filenames): Use symbol_filename_ftype for fun.
	* symfile.h (symbol_filename_ftype): New.
	(struct quick_symbol_functions): Use symbol_filename_ftype for fun of
	map_symbol_filenames, clarify more the naming in comment.
@
text
@d137 4
a140 1
  int was_mmapped;
d1568 1
a1568 1
  info->was_mmapped = 0;
d1598 3
a1600 4
      off_t pg_offset = sectp->filepos & ~(pagesize - 1);
      size_t map_length = info->size + sectp->filepos - pg_offset;
      caddr_t retbuf = bfd_mmap (abfd, 0, map_length, PROT_READ,
				 MAP_PRIVATE, pg_offset);
d1602 1
a1602 1
      if (retbuf != MAP_FAILED)
a1603 2
	  info->was_mmapped = 1;
	  info->buffer = retbuf + (sectp->filepos & (pagesize - 1)) ;
d1605 1
a1605 1
	  posix_madvise (retbuf, map_length, POSIX_MADV_WILLNEED);
d15360 1
a15360 1
  if (info->was_mmapped)
d15363 1
a15363 3
      intptr_t begin = (intptr_t) info->buffer;
      intptr_t map_begin = begin & ~(pagesize - 1);
      size_t map_length = info->size + begin - map_begin;
d15365 2
a15366 1
      gdb_assert (munmap ((void *) map_begin, map_length) == 0);
@


1.540
log
@	PR symtab/12704
	* cp-namespace.c (ANONYMOUS_NAMESPACE_LEN): Remove.
	(cp_scan_for_anonymous_namespaces): Use CP_ANONYMOUS_NAMESPACE_STR
	and CP_ANONYMOUS_NAMESPACE_LEN.
	(cp_is_anonymous): Likewise.
	* cp-support.h (CP_ANONYMOUS_NAMESPACE_STR): Define.
	(CP_ANONYMOUS_NAMESPACE_LEN): Define.
	* dwarf2read.c (namespace_name): Likewise.
	(fixup_partial_die): Likewise.
	* linespec.c (decode_compound): If CP_ANONYMOUS_NAMESPACE_STR is
	seen in the input, keep it.
@
text
@d2723 1
a2723 2
dw2_map_symbol_filenames (struct objfile *objfile,
			  void (*fun) (const char *, const char *, void *),
@


1.539
log
@2011-05-26  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct dwarf2_section_names): New type.
	(struct dwarf2_debug_sections): New type.
	(dwarf2_has_info): Add parameter.
	* dwarf2read.c (dwarf2_elf_names): New variable.
	(INFO_SECTION, ABBREV_SECTION, LINE_SECTION, LOC_SECTION)
	(MACINFO_SECTION, STR_SECTION, RANGES_SECTION, TYPES_SECTION)
	(FRAME_SECTION, EH_FRAME_SECTION, GDB_INDEX_SECTION): Remove.
	(dwarf2_has_info): Add names parameter.  Pass names
	to dwarf2_locate_sections.
	(section_is_p): Rewrite using the names parameter.
	(dwarf2_locate_sections): Use section names from the names parameter.
	* coffread.c (coff_symfile_read): Adjust call to dwarf2_has_info.
	* elfread.c (read_psyms): Ditto.
	* machoread.c (macho_symfile_read): Ditto.
@
text
@d7880 1
a7880 1
    name = "(anonymous namespace)";
d9550 1
a9550 1
    part_die->name = "(anonymous namespace)";
@


1.538
log
@2011-05-24  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (enum dwarf2_section_enum): New type.
	(dwarf2_get_section_info): New prototype.
	* dwarf2read.c (dwarf2_get_section_info): Replace parameter
	section_name by sect.  Use a switch to select the info.
	* dwarf2-frame.c (warf2_get_section_info): Remove prototype.
	(dwarf2_build_frame_info): Adjust calls to dwarf2_get_section_info.
@
text
@d246 1
a246 1
/* names of the debugging sections */
d251 13
a263 11
#define INFO_SECTION     "debug_info"
#define ABBREV_SECTION   "debug_abbrev"
#define LINE_SECTION     "debug_line"
#define LOC_SECTION      "debug_loc"
#define MACINFO_SECTION  "debug_macinfo"
#define STR_SECTION      "debug_str"
#define RANGES_SECTION   "debug_ranges"
#define TYPES_SECTION    "debug_types"
#define FRAME_SECTION    "debug_frame"
#define EH_FRAME_SECTION "eh_frame"
#define GDB_INDEX_SECTION "gdb_index"
d1340 3
a1342 1
   information and return true if we have enough to do something.  */
d1345 2
a1346 1
dwarf2_has_info (struct objfile *objfile)
d1359 2
a1360 1
      bfd_map_over_sections (objfile->obfd, dwarf2_locate_sections, NULL);
d1367 2
a1368 2
/* When loading sections, we can either look for ".<name>", or for
 * ".z<name>", which indicates a compressed section.  */
d1371 2
a1372 1
section_is_p (const char *section_name, const char *name)
d1374 7
a1380 4
  return (section_name[0] == '.'
	  && (strcmp (section_name + 1, name) == 0
	      || (section_name[1] == 'z'
		  && strcmp (section_name + 2, name) == 0)));
d1388 1
a1388 1
dwarf2_locate_sections (bfd *abfd, asection *sectp, void *ignore_ptr)
d1390 8
a1397 1
  if (section_is_p (sectp->name, INFO_SECTION))
d1402 1
a1402 1
  else if (section_is_p (sectp->name, ABBREV_SECTION))
d1407 1
a1407 1
  else if (section_is_p (sectp->name, LINE_SECTION))
d1412 1
a1412 1
  else if (section_is_p (sectp->name, LOC_SECTION))
d1417 1
a1417 1
  else if (section_is_p (sectp->name, MACINFO_SECTION))
d1422 1
a1422 1
  else if (section_is_p (sectp->name, STR_SECTION))
d1427 1
a1427 1
  else if (section_is_p (sectp->name, FRAME_SECTION))
d1432 1
a1432 1
  else if (section_is_p (sectp->name, EH_FRAME_SECTION))
d1442 1
a1442 1
  else if (section_is_p (sectp->name, RANGES_SECTION))
d1447 1
a1447 1
  else if (section_is_p (sectp->name, TYPES_SECTION))
d1452 1
a1452 1
  else if (section_is_p (sectp->name, GDB_INDEX_SECTION))
@


1.537
log
@gdb/
	Fix -readnow for -gdwarf-4 unused type units.
	* dwarf2read.c (struct signatured_type): Remove the field offset.
	(create_signatured_type_table_from_index): Remove its initialization.
	(create_debug_types_hash_table): Likewise.  Initialize per_cu.offset
	instead.  Add a complaint call.
	(process_psymtab_comp_unit): Change assignment to gdb_assert.
	(process_type_comp_unit, lookup_die_type, dump_die_shallow)
	(lookup_signatured_type_at_offset, read_signatured_type)
	(write_one_signatured_type): Update the field for per_cu.

gdb/testsuite/
	Fix -readnow for -gdwarf-4 unused type units.
	* gdb.dwarf2/dw4-sig-type-unused.S: New file.
	* gdb.dwarf2/dw4-sig-type-unused.exp: New file.
@
text
@d1636 2
a1637 1
dwarf2_get_section_info (struct objfile *objfile, const char *section_name,
d1654 11
a1664 6
  if (section_is_p (section_name, EH_FRAME_SECTION))
    info = &data->eh_frame;
  else if (section_is_p (section_name, FRAME_SECTION))
    info = &data->frame;
  else
    gdb_assert_not_reached ("unexpected section");
@


1.536
log
@	* dwarf2read.c (dwarf2_add_field): Constify.
	* value.c (value_static_field): Constify.
	* gdbtypes.h (struct main_type) <field.field_location.physname>:
	Now const.
	* ax-gdb.c (gen_static_field): Constify
@
text
@a472 3
  /* Offset in .debug_types of the TU (type_unit) for this type.  */
  unsigned int offset;

a1917 1
      type_sig->offset = offset;
a3091 1
      type_sig->offset = offset;
d3095 1
d3099 11
d3274 2
a3275 2
      /* offset,length haven't been set yet for type units.  */
      this_cu->offset = cu.header.offset;
d3400 1
a3400 1
			     dwarf2_per_objfile->types.buffer + entry->offset,
d11713 1
a11713 1
      offset = sig_type->offset + sig_type->type_offset;
d13340 1
a13340 1
				DW_SIGNATURED_TYPE (&die->attrs[i])->offset);
d13748 1
a13748 1
  gdb_assert (offset == type_sig->offset);
d13787 1
a13787 1
  types_ptr = dwarf2_per_objfile->types.buffer + type_sig->offset;
d15915 1
a15915 1
  store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, entry->offset);
@


1.535
log
@	* value.c (value_fn_field): Constify.
	* symtab.c (gdb_mangle_name): Constify.
	* stabsread.c (update_method_name_from_physname): Make 'physname'
	argument const.
	* p-typeprint.c (pascal_type_print_method_args): Make arguments
	const.  Use explicit fputc_filtered loop.
	(pascal_type_print_base): Constify.
	* p-lang.h (pascal_type_print_method_args): Update.
	* linespec.c (add_matching_methods): Constify.
	(add_constructors): Likewise.
	* jv-typeprint.c (java_type_print_base): Constify.
	* gdbtypes.h (struct cplus_struct_type)
	<fn_fieldlist.fn_field.physname>: Now const.
	* dwarf2read.c (compute_delayed_physnames): Constify.
	(dwarf2_add_member_fn): Likewise.
	* c-typeprint.c (c_type_print_base): Constify.  Use cleanups.
@
text
@d6545 1
a6545 1
      char *physname;
d6566 1
a6566 1
      physname = (char *) dwarf2_physname (fieldname, die, cu);
@


1.534
log
@	* dwarf2read.c (dwarf2_get_die_type): Call
	get_die_type_at_offset.
	* dwarf2expr.c (dwarf_get_base_type): Handle NULL return from
	get_base_type function.
@
text
@d4612 1
a4612 1
      char *physname;
d4615 1
a4615 1
      physname = (char *) dwarf2_physname ((char *) mi->name, mi->die, cu);
d6795 1
a6795 1
      char *physname = (char *) dwarf2_physname (fieldname, die, cu);
@


1.533
log
@gdb
	PR gdb/12617:
	* value.h (value_from_contents): Declare.
	* value.c (value_from_contents): New function.
	* dwarf2read.c (dwarf_stack_op_name): Add new values.
	(dwarf2_get_die_type): New function.
	* dwarf2loc.c (dwarf_expr_get_base_type): New function.
	(allocate_piece_closure): Acquire reference to values.
	(read_pieced_value): Update for value-based expressions.
	(write_pieced_value): Likewise.
	(free_pieced_value_closure): Call value_free as needed.
	(dwarf2_evaluate_loc_desc_full): Set get_base_type field.
	Update for value-based expressions.
	* dwarf2loc.h (dwarf2_get_die_type): Declare.
	* dwarf2expr.h (struct dwarf_stack_value) <value>: Change type.
	<get_base_type>: New field.
	(struct dwarf_expr_piece) <v.value>: Change type.
	<v.regno>: New field.
	(struct dwarf_expr_context) <mark>: New field.
	(dwarf_expr_piece, dwarf_expr_fetch): Update.
	(dwarf_expr_pop, dwarf_expr_push): Remove.
	(dwarf_expr_push_address): Declare.
	* dwarf2expr.c (dwarf_arch_cookie): New global.
	(struct dwarf_gdbarch_types): New.
	(dwarf_gdbarch_types_init, dwarf_expr_address_type): New
	functions.
	(dwarf_expr_push): Change type of 'value' argument.  Update.  Now
	static.
	(dwarf_expr_push_address): New function.
	(dwarf_expr_pop): Now static.
	(dwarf_expr_fetch): Change return type.
	(dwarf_require_integral): New function.
	(dwarf_expr_fetch): Simplify.
	(add_piece): Update.
	(base_types_equal_p, dwarf_get_base_type, get_unsigned_type): New
	functions.
	(execute_stack_op) <sign_ext>: Remove.
	Use values for DWARF stack.
	<DW_OP_GNU_const_type, DW_OP_GNU_deref_type,
	DW_OP_GNU_regval_type, DW_OP_GNU_convert, DW_OP_GNU_reinterpret>:
	New cases.
	(_initialize_dwarf2expr): New function.
	(add_piece): Update.
	(new_dwarf_expr_context): Set new field.
	(free_dwarf_expr_context): Call value_free_to_mark.
	* dwarf2-frame.c (no_base_type): New function.
	(execute_stack_op): Set get_base_type field.  Update.
gdb/testsuite
	* gdb.dwarf2/typeddwarf.S: New file.
	* gdb.dwarf2/typeddwarf.c: New file.
	* gdb.dwarf2/typeddwarf.exp: New file.
@
text
@a13673 4
  struct dwarf2_cu *cu = per_cu->cu;
  struct die_info *die;
  struct type *result;

d13675 1
a13675 11

  die = follow_die_offset (die_offset, &cu);
  if (!die)
    error (_("Dwarf Error: Cannot find DIE at 0x%x referenced in module %s"),
	   die_offset, per_cu->cu->objfile->name);

  result = get_die_type (die, cu);
  if (result == NULL)
    result = read_type_die_1 (die, cu);

  return result;
@


1.532
log
@	* dwarf2read.c (read_common_block): Fix formatting.
@
text
@d13097 12
d13667 25
@


1.531
log
@	* dwarf2read.c (handle_data_member_location): New function.
	(dwarf2_add_field): Use it.
	(read_common_block): Likewise.
@
text
@d7693 2
a7694 2
	  if (sym != NULL &&
	      handle_data_member_location (child_die, cu, &offset))
@


1.530
log
@gdb/
	PR 12573
	* dwarf2read.c (struct dwarf2_cu): New field has_loclist.
	(producer_is_gcc_ge_4_0): New function.
	(process_full_comp_unit): Set also symtab->locations_valid.  Move the
	symtab->language code.
	(var_decode_location): Set cu->has_loclist.
	* symtab.c (skip_prologue_sal): New variables saved_pc, force_skip and
	skip.  Intialize force_skip from locations_valid.  Move the prologue
	skipping code into two passes.
	* symtab.h (struct symtab): Make the primary field a bitfield.  New
	field locations_valid.

gdb/testsuite/
	PR 12573
	* gdb.dwarf2/dw2-skip-prologue.S: New file.
	* gdb.dwarf2/dw2-skip-prologue.c: New file.
	* gdb.dwarf2/dw2-skip-prologue.exp: New file.
@
text
@d6368 35
d6451 2
d6472 2
a6473 16
      attr = dwarf2_attr (die, DW_AT_data_member_location, cu);
      if (attr)
	{
          int byte_offset = 0;

          if (attr_form_is_section_offset (attr))
	    dwarf2_complex_location_expr_complaint ();
          else if (attr_form_is_constant (attr))
            byte_offset = dwarf2_get_attr_constant_value (attr, 0);
          else if (attr_form_is_block (attr))
            byte_offset = decode_locdesc (DW_BLOCK (attr), cu);
	  else
	    dwarf2_complex_location_expr_complaint ();

          SET_FIELD_BITPOS (*fp, byte_offset * bits_per_byte);
	}
d6576 2
d6579 2
a6580 16
      attr = dwarf2_attr (die, DW_AT_data_member_location, cu);
      if (attr)
	{
          int byte_offset = 0;

          if (attr_form_is_section_offset (attr))
	    dwarf2_complex_location_expr_complaint ();
          else if (attr_form_is_constant (attr))
            byte_offset = dwarf2_get_attr_constant_value (attr, 0);
          else if (attr_form_is_block (attr))
            byte_offset = decode_locdesc (DW_BLOCK (attr), cu);
	  else
	    dwarf2_complex_location_expr_complaint ();

          SET_FIELD_BITPOS (*fp, byte_offset * bits_per_byte);
	}
d7690 2
d7693 2
a7694 2
	  attr = dwarf2_attr (child_die, DW_AT_data_member_location, cu);
	  if (sym != NULL && attr != NULL)
d7696 1
a7696 12
	      CORE_ADDR byte_offset = 0;

	      if (attr_form_is_section_offset (attr))
		dwarf2_complex_location_expr_complaint ();
	      else if (attr_form_is_constant (attr))
		byte_offset = dwarf2_get_attr_constant_value (attr, 0);
	      else if (attr_form_is_block (attr))
		byte_offset = decode_locdesc (DW_BLOCK (attr), cu);
	      else
		dwarf2_complex_location_expr_complaint ();

	      SYMBOL_VALUE_ADDRESS (sym) = base + byte_offset;
@


1.529
log
@gdb/
	* c-exp.y (qualified_name): Call destructor_name_p with $1.type.
	(classify_inner_name): Call cp_lookup_nested_type with
	yylval.tsym.type.
	* cp-namespace.c (cp_lookup_nested_type): New variable
	saved_parent_type.  Call CHECK_TYPEDEF for parent_type.  Call
	type_name_no_tag_or_error with saved_parent_type.
	* dwarf2read.c (load_partial_dies): Read in any children of
	DW_TAG_typedef with complaint in such case.
	* gdbtypes.c (type_name_no_tag_or_error): New function.
	* gdbtypes.h (type_name_no_tag_or_error): New prototype.
	* valops.c (destructor_name_p): New comment for parameter type.  Remove
	type const.  Make dname and cp const.  Call type_name_no_tag_or_error.
	* value.h (destructor_name_p): Remove type const.
@
text
@d407 7
d4620 38
d4697 1
a4697 5
  /* Set symtab language to language from DW_AT_language.
     If the compilation is from a C file generated by language preprocessors,
     do not set the language if it was already deduced by start_subfile.  */
  if (symtab != NULL
      && !(cu->language == language_c && symtab->language != language_c))
d4699 18
a4716 1
      symtab->language = cu->language;
d11029 3
@


1.528
log
@gdb/doc/
	* gdb.texinfo (Index Section Format): Change the version to 5.
	Describe the different formula.

gdb/
	Case insensitive lookups implementation.
	* dwarf2read.c: Include ctype.h.
	(struct mapped_index): New field version.
	(mapped_index_string_hash): New parameter index_version.  New comment
	for it.  Call tolower appropriately.
	(find_slot_in_mapped_hash): New variable cmp, initialize it, use it.
	Choose the right index version for mapped_index_string_hash.
	(dwarf2_read_index): Support also the index version 5.  Initialize the
	new struct mapped_index field version.
	(hash_strtab_entry): Pass INT_MAX for the new parameter, explain why.
	(find_slot): Explain the version needs.  Pass INT_MAX for the new
	parameter.
	(write_psymtabs_to_index): Produce version 5.
	* minsyms.c (lookup_minimal_symbol): New variable cmp, initialize it,
	use it.  New comment for SYMBOL_MATCHES_SEARCH_NAME.
	* psymtab.c (lookup_partial_symbol): Find the
	SYMBOL_MATCHES_SEARCH_NAME start of the found block of matching
	entries.
	* symtab.c (lookup_symbol_in_language): Remove the case_sensitive_off
	NAME lowercasing.
	(search_symbols): Pass REG_ICASE to regcomp for case_sensitive_off.
	(completion_list_add_name): New variable ncmp, initialize it, use it.
	* symtab.h (SYMBOL_HASH_NEXT): Always call tolower.
	* utils.c (strcmp_iw): Support case_sensitive_off.
	(strcmp_iw_ordered): Sort in a way compatible with case_sensitive_off.
	New function comment part.  New variables saved_string1,
	saved_string2 and case_pass.  Add a proper second pass.

gdb/testsuite/
	* gdb.base/fortran-sym-case.c: New file.
	* gdb.base/fortran-sym-case.exp: New file.
	* gdb.dwarf2/dw2-case-insensitive-debug.S: New file.
	* gdb.dwarf2/dw2-case-insensitive.c: New file.
	* gdb.dwarf2/dw2-case-insensitive.exp: New file.
@
text
@d8949 1
a8949 1
	  && (part_die->tag == DW_TAG_typedef
d8962 14
@


1.527
log
@gdb/
	Format the code for the next patch.
	* dwarf2read.c (struct mapped_index): Include delimiting newlines.
	* utils.c (strcmp_iw_ordered): Reformat the code for the next patch.
	New variables c1 and c2.
@
text
@d152 3
d1978 3
a1980 1
   SYMBOL_HASH_NEXT.  */
d1983 1
a1983 1
mapped_index_string_hash (const void *p)
d1990 5
a1994 1
    r = r * 67 + c - 113;
d2010 1
d2033 8
a2040 1
  hash = mapped_index_string_hash (name);
d2043 1
d2057 1
a2057 1
      if (!strcmp (name, str))
d2101 2
a2102 1
     indices.  */
d2107 1
a2107 1
  if (version > 4)
d2111 1
d15279 4
a15282 1
/* Hash function for a strtab_entry.  */
d15288 1
a15288 1
  return mapped_index_string_hash (entry->str);
d15426 4
a15429 1
   the slot.  */
d15434 1
a15434 1
  offset_type index, step, hash = mapped_index_string_hash (name);
d15963 1
a15963 1
  val = MAYBE_SWAP (4);
@


1.526
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@d154 1
d157 1
d160 1
d163 1
d166 1
@


1.525
log
@gdb
	* dwarf2read.c (save_gdb_index_command): Replace format
	documentation with a pointer to the manual.
gdb/doc
	* gdb.texinfo (Index Section Format): New node.
	(Top): Add new node to menu.
@
text
@d2590 7
a2596 6
  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_comp_units); ++i)
    {
      int j;
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
      struct quick_file_names *file_data;
d2598 3
a2600 3
      per_cu->v.quick->mark = 0;
      if (per_cu->v.quick->symtab)
	continue;
d2602 3
a2604 3
      file_data = dw2_get_file_names (objfile, per_cu);
      if (file_data == NULL)
	continue;
d2606 9
a2614 9
      for (j = 0; j < file_data->num_file_names; ++j)
	{
	  if (file_matcher (file_data->file_names[j], data))
	    {
	      per_cu->v.quick->mark = 1;
	      break;
	    }
	}
    }
d2640 1
a2640 1
	  if (per_cu->v.quick->mark)
a2671 30
dw2_map_symbol_names (struct objfile *objfile,
		      void (*fun) (const char *, void *),
		      void *data)
{
  offset_type iter;
  struct mapped_index *index;

  dw2_setup (objfile);

  /* index_table is NULL if OBJF_READNOW.  */
  if (!dwarf2_per_objfile->index_table)
    return;
  index = dwarf2_per_objfile->index_table;

  for (iter = 0; iter < index->symbol_table_slots; ++iter)
    {
      offset_type idx = 2 * iter;
      const char *name;
      offset_type *vec, vec_len, vec_idx;

      if (index->symbol_table[idx] == 0 && index->symbol_table[idx + 1] == 0)
	continue;

      name = (index->constant_pool + MAYBE_SWAP (index->symbol_table[idx]));

      (*fun) (name, data);
    }
}

static void
a2726 1
  dw2_map_symbol_names,
@


1.524
log
@	* dwarf2read.c (add_index_entry): Use VEC_last, not VEC_length.
@
text
@d16008 4
a16011 69
/* The mapped index file format is designed to be directly mmap()able
   on any architecture.  In most cases, a datum is represented using a
   little-endian 32-bit integer value, called an offset_type.  Big
   endian machines must byte-swap the values before using them.
   Exceptions to this rule are noted.  The data is laid out such that
   alignment is always respected.

   A mapped index consists of several sections.

   1. The file header.  This is a sequence of values, of offset_type
   unless otherwise noted:

   [0] The version number, currently 4.  Versions 1, 2 and 3 are
   obsolete.
   [1] The offset, from the start of the file, of the CU list.
   [2] The offset, from the start of the file, of the types CU list.
   Note that this section can be empty, in which case this offset will
   be equal to the next offset.
   [3] The offset, from the start of the file, of the address section.
   [4] The offset, from the start of the file, of the symbol table.
   [5] The offset, from the start of the file, of the constant pool.

   2. The CU list.  This is a sequence of pairs of 64-bit
   little-endian values, sorted by the CU offset.  The first element
   in each pair is the offset of a CU in the .debug_info section.  The
   second element in each pair is the length of that CU.  References
   to a CU elsewhere in the map are done using a CU index, which is
   just the 0-based index into this table.  Note that if there are
   type CUs, then conceptually CUs and type CUs form a single list for
   the purposes of CU indices.

   3. The types CU list.  This is a sequence of triplets of 64-bit
   little-endian values.  In a triplet, the first value is the CU
   offset, the second value is the type offset in the CU, and the
   third value is the type signature.  The types CU list is not
   sorted.

   4. The address section.  The address section consists of a sequence
   of address entries.  Each address entry has three elements.
   [0] The low address.  This is a 64-bit little-endian value.
   [1] The high address.  This is a 64-bit little-endian value.
       Like DW_AT_high_pc, the value is one byte beyond the end.
   [2] The CU index.  This is an offset_type value.

   5. The symbol table.  This is a hash table.  The size of the hash
   table is always a power of 2.  The initial hash and the step are
   currently defined by the `find_slot' function.

   Each slot in the hash table consists of a pair of offset_type
   values.  The first value is the offset of the symbol's name in the
   constant pool.  The second value is the offset of the CU vector in
   the constant pool.

   If both values are 0, then this slot in the hash table is empty.
   This is ok because while 0 is a valid constant pool index, it
   cannot be a valid index for both a string and a CU vector.

   A string in the constant pool is stored as a \0-terminated string,
   as you'd expect.

   A CU vector in the constant pool is a sequence of offset_type
   values.  The first value is the number of CU indices in the vector.
   Each subsequent value is the index of a CU in the CU list.  This
   element in the hash table is used to indicate which CUs define the
   symbol.

   6. The constant pool.  This is simply a bunch of bytes.  It is
   organized so that alignment is correct: CU vectors are stored
   first, followed by strings.  */
@


1.523
log
@gdb/
	Fix crash of gdb save-index on a STABS file.
	* dwarf2read.c (write_psymtabs_to_index): Return also on no
	PSYMTABS_ADDRMAP.
@
text
@d15494 1
a15494 1
      || VEC_length (offset_type, (*slot)->cu_indices) != cu_index)
@


1.522
log
@gdb/
	Fix DW_AT_accessibility compatibility with gcc-4.6+.
	* dwarf2read.c: Include ctype.h.
	(producer_is_gxx_lt_4_6, dwarf2_default_access_attribute): New
	functions.
	(dwarf2_add_field): Fix new_field->accessibility by calling
	dwarf2_default_access_attribute.  Restructure setting accessibility
	vs. virtuality.
	(dwarf2_add_member_fn): New variable accessibility.  Fix fnp
	is_private and is_protected by calling
	dwarf2_default_access_attribute.
@
text
@d15846 1
a15846 1
  if (!objfile->psymtabs)
d15848 1
@


1.521
log
@gdb/
	Code cleanup.
	* dictionary.c (dict_hash): Use SYMBOL_HASH_NEXT.
	* dwarf2read.c (mapped_index_string_hash): Refer to SYMBOL_HASH_NEXT
	in the function comment, a new note on values compatibility.
	* minsyms.c (msymbol_hash_iw, msymbol_hash): Use SYMBOL_HASH_NEXT.
	* symtab.h (SYMBOL_HASH_NEXT): New.
@
text
@d60 1
d6240 75
a6344 9
  /* Handle accessibility and virtuality of field.
     The default accessibility for members is public, the default
     accessibility for inheritance is private.  */
  if (die->tag != DW_TAG_inheritance)
    new_field->accessibility = DW_ACCESS_public;
  else
    new_field->accessibility = DW_ACCESS_private;
  new_field->virtuality = DW_VIRTUALITY_none;

d6348 2
d6352 1
d6356 2
d6673 1
d6772 4
d6777 6
a6782 9
      switch (DW_UNSND (attr))
	{
	case DW_ACCESS_private:
	  fnp->is_private = 1;
	  break;
	case DW_ACCESS_protected:
	  fnp->is_protected = 1;
	  break;
	}
@


1.520
log
@	* symtab.h (domain_enum): Split in two...
	(enum search_domain): New.
	(search_symbols): Update.
	* symtab.c (print_symbol_info, symtab_symbol_info): Remove
	redundant declarations.
	(search_symbols): Change 'kind' argument to search_domain.
	Update.
	(print_symbol_info): Likewise.
	(symtab_symbol_info): Likewise.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: Change type of 'kind' argument.
	<expand_symtabs_matching>: Likewise.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): Update.
	(expand_symtabs_matching_via_partial): Update.
	* dwarf2read.c (dw2_pre_expand_symtabs_matching): Update.
	(dw2_expand_symtabs_for_function): Update.
	* block.h: Moved anonymous enum...
	* defs.h (enum block_enum): ... here.  Now named.
@
text
@d1965 5
a1969 5
/* The hash function for strings in the mapped index.  This is the
   same as the hashtab.c hash function, but we keep a separate copy to
   maintain control over the implementation.  This is necessary
   because the hash function is tied to the format of the mapped index
   file.  */
@


1.519
log
@gdb/
	* dwarf2read.c (find_slot_in_mapped_hash): New variable back_to,
	initialize it.  Delay HASH initialization.  Strip the part after open
	parenthesis for languages with qualifiers.  Call do_cleanups.
@
text
@d2429 1
a2429 1
				 int kind, const char *name,
d2575 1
a2575 1
			     domain_enum kind,
@


1.518
log
@gdb/
	* dwarf2read.c (dwarf2_read_index): Fix .gdb_index version number in
	the comment.
@
text
@d1992 2
a1993 1
  offset_type hash = mapped_index_string_hash (name);
d1996 22
d2027 4
a2030 1
	return 0;
d2037 1
@


1.518.2.1
log
@gdb/
	Fix DW_AT_accessibility compatibility with gcc-4.6+.
	* dwarf2read.c: Include ctype.h.
	(producer_is_gxx_lt_4_6, dwarf2_default_access_attribute): New
	functions.
	(dwarf2_add_field): Fix new_field->accessibility by calling
	dwarf2_default_access_attribute.  Restructure setting accessibility
	vs. virtuality.
	(dwarf2_add_member_fn): New variable accessibility.  Fix fnp
	is_private and is_protected by calling
	dwarf2_default_access_attribute.
@
text
@a59 1
#include <ctype.h>
a6211 75
/* Check for GCC PR debug/45124 fix which is not present in any G++ version up
   to 4.5.any while it is present already in G++ 4.6.0 - the PR has been fixed
   during 4.6.0 experimental.  */

static int
producer_is_gxx_lt_4_6 (struct dwarf2_cu *cu)
{
  const char *cs;
  int major, minor, release;

  if (cu->producer == NULL)
    {
      /* For unknown compilers expect their behavior is DWARF version
	 compliant.

	 GCC started to support .debug_types sections by -gdwarf-4 since
	 gcc-4.5.x.  As the .debug_types sections are missing DW_AT_producer
	 for their space efficiency GDB cannot workaround gcc-4.5.x -gdwarf-4
	 combination.  gcc-4.5.x -gdwarf-4 binaries have DW_AT_accessibility
	 interpreted incorrectly by GDB now - GCC PR debug/48229.  */

      return 0;
    }

  /* Skip any identifier after "GNU " - such as "C++" or "Java".  */

  if (strncmp (cu->producer, "GNU ", strlen ("GNU ")) != 0)
    {
      /* For non-GCC compilers expect their behavior is DWARF version
	 compliant.  */

      return 0;
    }
  cs = &cu->producer[strlen ("GNU ")];
  while (*cs && !isdigit (*cs))
    cs++;
  if (sscanf (cs, "%d.%d.%d", &major, &minor, &release) != 3)
    {
      /* Not recognized as GCC.  */

      return 0;
    }

  return major < 4 || (major == 4 && minor < 6);
}

/* Return the default accessibility type if it is not overriden by
   DW_AT_accessibility.  */

static enum dwarf_access_attribute
dwarf2_default_access_attribute (struct die_info *die, struct dwarf2_cu *cu)
{
  if (cu->header.version < 3 || producer_is_gxx_lt_4_6 (cu))
    {
      /* The default DWARF 2 accessibility for members is public, the default
	 accessibility for inheritance is private.  */

      if (die->tag != DW_TAG_inheritance)
	return DW_ACCESS_public;
      else
	return DW_ACCESS_private;
    }
  else
    {
      /* DWARF 3+ defines the default accessibility a different way.  The same
	 rules apply now for DW_TAG_inheritance as for the members and it only
	 depends on the container kind.  */

      if (die->parent->tag == DW_TAG_class_type)
	return DW_ACCESS_private;
      else
	return DW_ACCESS_public;
    }
}

d6242 9
a6253 2
  else
    new_field->accessibility = dwarf2_default_access_attribute (die, cu);
a6255 1

a6258 2
  else
    new_field->virtuality = DW_VIRTUALITY_none;
a6573 1
  enum dwarf_access_attribute accessibility;
a6671 4
    accessibility = DW_UNSND (attr);
  else
    accessibility = dwarf2_default_access_attribute (die, cu);
  switch (accessibility)
d6673 9
a6681 6
    case DW_ACCESS_private:
      fnp->is_private = 1;
      break;
    case DW_ACCESS_protected:
      fnp->is_protected = 1;
      break;
@


1.518.2.2
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@d2563 6
a2568 7
  if (file_matcher != NULL)
    for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		     + dwarf2_per_objfile->n_type_comp_units); ++i)
      {
	int j;
	struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
	struct quick_file_names *file_data;
d2570 3
a2572 3
	per_cu->v.quick->mark = 0;
	if (per_cu->v.quick->symtab)
	  continue;
d2574 3
a2576 3
	file_data = dw2_get_file_names (objfile, per_cu);
	if (file_data == NULL)
	  continue;
d2578 9
a2586 9
	for (j = 0; j < file_data->num_file_names; ++j)
	  {
	    if (file_matcher (file_data->file_names[j], data))
	      {
		per_cu->v.quick->mark = 1;
		break;
	      }
	  }
      }
d2612 1
a2612 1
	  if (file_matcher == NULL || per_cu->v.quick->mark)
d2644 30
d2729 1
@


1.518.2.3
log
@gdb/
	PR 12573
	* dwarf2read.c (struct dwarf2_cu): New field has_loclist.
	(producer_is_gcc_ge_4_0): New function.
	(process_full_comp_unit): Set also symtab->locations_valid.  Move the
	symtab->language code.
	(var_decode_location): Set cu->has_loclist.
	* symtab.c (skip_prologue_sal): New variables saved_pc, force_skip and
	skip.  Intialize force_skip from locations_valid.  Move the prologue
	skipping code into two passes.
	* symtab.h (struct symtab): Make the primary field a bitfield.  New
	field locations_valid.

gdb/testsuite/
	PR 12573
	* gdb.dwarf2/dw2-skip-prologue.S: New file.
	* gdb.dwarf2/dw2-skip-prologue.c: New file.
	* gdb.dwarf2/dw2-skip-prologue.exp: New file.
@
text
@a398 7

  /* This CU references .debug_loc.  See the symtab->locations_valid field.
     This test is imperfect as there may exist optimized debug code not using
     any location list and still facing inlining issues if handled as
     unoptimized code.  For a future better test see GCC PR other/32998.  */

  unsigned int has_loclist : 1;
a4560 38
/* Check for GCC >= 4.0.  */

static int
producer_is_gcc_ge_4_0 (struct dwarf2_cu *cu)
{
  const char *cs;
  int major, minor;

  if (cu->producer == NULL)
    {
      /* For unknown compilers expect their behavior is not compliant.  For GCC
	 this case can also happen for -gdwarf-4 type units supported since
	 gcc-4.5.  */

      return 0;
    }

  /* Skip any identifier after "GNU " - such as "C++" or "Java".  */

  if (strncmp (cu->producer, "GNU ", strlen ("GNU ")) != 0)
    {
      /* For non-GCC compilers expect their behavior is not compliant.  */

      return 0;
    }
  cs = &cu->producer[strlen ("GNU ")];
  while (*cs && !isdigit (*cs))
    cs++;
  if (sscanf (cs, "%d.%d", &major, &minor) != 2)
    {
      /* Not recognized as GCC.  */

      return 0;
    }

  return major >= 4;
}

d4600 5
a4604 1
  if (symtab != NULL)
d4606 1
a4606 18
      /* Set symtab language to language from DW_AT_language.  If the
	 compilation is from a C file generated by language preprocessors, do
	 not set the language if it was already deduced by start_subfile.  */
      if (!(cu->language == language_c && symtab->language != language_c))
	symtab->language = cu->language;

      /* GCC-4.0 has started to support -fvar-tracking.  GCC-3.x still can
	 produce DW_AT_location with location lists but it can be possibly
	 invalid without -fvar-tracking.

	 For -gdwarf-4 type units LOCATIONS_VALID indication is fortunately not
	 needed, it would be wrong due to missing DW_AT_producer there.

	 Still one can confuse GDB by using non-standard GCC compilation
	 options - this waits on GCC PR other/32998 (-frecord-gcc-switches).
	 */ 
      if (cu->has_loclist && producer_is_gcc_ge_4_0 (cu))
	symtab->locations_valid = 1;
a10904 3

  if (SYMBOL_COMPUTED_OPS (sym) == &dwarf2_loclist_funcs)
    cu->has_loclist = 1;
@


1.518.2.4
log
@	* dwarf2read.c (handle_data_member_location): New function.
	(dwarf2_add_field): Use it.
	(read_common_block): Likewise.
@
text
@a6315 35
/* Look for DW_AT_data_member_location.  Set *OFFSET to the byte
   offset.  If the attribute was not found return 0, otherwise return
   1.  If it was found but could not properly be handled, set *OFFSET
   to 0.  */

static int
handle_data_member_location (struct die_info *die, struct dwarf2_cu *cu,
			     LONGEST *offset)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_data_member_location, cu);
  if (attr != NULL)
    {
      *offset = 0;

      /* Note that we do not check for a section offset first here.
	 This is because DW_AT_data_member_location is new in DWARF 4,
	 so if we see it, we can assume that a constant form is really
	 a constant and not a section offset.  */
      if (attr_form_is_constant (attr))
	*offset = dwarf2_get_attr_constant_value (attr, 0);
      else if (attr_form_is_section_offset (attr))
	dwarf2_complex_location_expr_complaint ();
      else if (attr_form_is_block (attr))
	*offset = decode_locdesc (DW_BLOCK (attr), cu);
      else
	dwarf2_complex_location_expr_complaint ();

      return 1;
    }

  return 0;
}

a6363 2
      LONGEST offset;

d6383 16
a6398 2
      if (handle_data_member_location (die, cu, &offset))
	SET_FIELD_BITPOS (*fp, offset * bits_per_byte);
d6501 14
a6514 1
      LONGEST offset;
d6516 2
a6517 3
      /* C++ base class field.  */
      if (handle_data_member_location (die, cu, &offset))
	SET_FIELD_BITPOS (*fp, offset * bits_per_byte);
a7626 2
	  LONGEST offset;

d7628 2
a7629 2
	  if (sym != NULL &&
	      handle_data_member_location (child_die, cu, &offset))
d7631 12
a7642 1
	      SYMBOL_VALUE_ADDRESS (sym) = base + offset;
@


1.518.2.5
log
@	* dwarf2read.c (read_common_block): Fix formatting.
@
text
@d7641 2
a7642 2
	  if (sym != NULL
	      && handle_data_member_location (child_die, cu, &offset))
@


1.518.2.6
log
@gdb/
	* dwarf2read.c (find_slot_in_mapped_hash): New variable back_to,
	initialize it.  Delay HASH initialization.  Strip the part after open
	parenthesis for languages with qualifiers.  Call do_cleanups.
@
text
@d2000 1
a2000 2
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
  offset_type hash;
a2002 22
  if (current_language->la_language == language_cplus
      || current_language->la_language == language_java
      || current_language->la_language == language_fortran)
    {
      /* NAME is already canonical.  Drop any qualifiers as .gdb_index does
	 not contain any.  */
      const char *paren = strchr (name, '(');

      if (paren)
	{
	  char *dup;

	  dup = xmalloc (paren - name + 1);
	  memcpy (dup, name, paren - name);
	  dup[paren - name] = 0;

	  make_cleanup (xfree, dup);
	  name = dup;
	}
    }

  hash = mapped_index_string_hash (name);
d2012 1
a2012 4
	{
	  do_cleanups (back_to);
	  return 0;
	}
a2018 1
	  do_cleanups (back_to);
@


1.518.2.7
log
@commit f658463559c9f03672b0fd226e4941f159e65bc0
Author: Keith Seitz <keiths@@redhat.com>
Date:   Tue May 31 21:54:06 2011 +0000

gdb/
	PR symtab/12704
	* cp-namespace.c (ANONYMOUS_NAMESPACE_LEN): Remove.
	(cp_scan_for_anonymous_namespaces): Use CP_ANONYMOUS_NAMESPACE_STR
	and CP_ANONYMOUS_NAMESPACE_LEN.
	(cp_is_anonymous): Likewise.
	* cp-support.h (CP_ANONYMOUS_NAMESPACE_STR): Define.
	(CP_ANONYMOUS_NAMESPACE_LEN): Define.
	* dwarf2read.c (namespace_name): Likewise.
	(fixup_partial_die): Likewise.
	* linespec.c (decode_compound): If CP_ANONYMOUS_NAMESPACE_STR is
	seen in the input, keep it.
@
text
@d7825 1
a7825 1
    name = CP_ANONYMOUS_NAMESPACE_STR;
d9481 1
a9481 1
    part_die->name = CP_ANONYMOUS_NAMESPACE_STR;
@


1.518.2.8
log
@commit 9e7800188627afaf57ab34bc74615c36baaf68d2
Author: Jan Kratochvil <jan.kratochvil@@redhat.com>
Date:   Fri Jul 1 19:12:09 2011 +0000

gdb/
	* dwarf2read.c (check_physname): New variable.
	(dwarf2_physname): Prefer DW_AT_linkage_name over dwarf2_compute_name.
	(show_check_physname): New function.
	(_initialize_dwarf2_read): Add `check-physname' for check_physname.

gdb/doc/
	* gdb.texinfo (Debugging Output): Document set debug
	check-physname.

gdb/testsuite/
	* gdb.base/break-interp.exp (reach_1, test_ld): Allow also the prefix
	__GI_.
	* gdb.cp/psymtab-parameter.cc (func): Make it a template function.
	(f): New function.
	* gdb.cp/psymtab-parameter.exp (complete break 'func(): Rename to ...
	(complete p 'func<short>(): ... here.
	* gdb.dwarf2/dw2-linkage-name-trust-main.cc: New file.
	* gdb.dwarf2/dw2-linkage-name-trust.S: New file.
	* gdb.dwarf2/dw2-linkage-name-trust.exp: New file.
	* gdb.cp/temargs.exp (test type of F in k3_m, test value of F in k3_m):
	Make them KFAIL gcc/49546.
@
text
@a121 3
/* When non-zero, cross-check physname against demangler.  */
static int check_physname = 0;

d5118 1
a5118 85
  struct attribute *attr;
  const char *retval, *mangled = NULL, *canon = NULL;
  struct cleanup *back_to;
  int need_copy = 1;

  /* In this case dwarf2_compute_name is just a shortcut not building anything
     on its own.  */
  if (!die_needs_namespace (die, cu))
    return dwarf2_compute_name (name, die, cu, 1);

  back_to = make_cleanup (null_cleanup, NULL);

  attr = dwarf2_attr (die, DW_AT_linkage_name, cu);
  if (!attr)
    attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);

  /* DW_AT_linkage_name is missing in some cases - depend on what GDB
     has computed.  */
  if (attr && DW_STRING (attr))
    {
      char *demangled;

      mangled = DW_STRING (attr);

      /* Use DMGL_RET_DROP for C++ template functions to suppress their return
	 type.  It is easier for GDB users to search for such functions as
	 `name(params)' than `long name(params)'.  In such case the minimal
	 symbol names do not match the full symbol names but for template
	 functions there is never a need to look up their definition from their
	 declaration so the only disadvantage remains the minimal symbol
	 variant `long name(params)' does not have the proper inferior type.
	 */

      demangled = cplus_demangle (mangled, (DMGL_PARAMS | DMGL_ANSI
					    | (cu->language == language_java
					       ? DMGL_JAVA | DMGL_RET_POSTFIX
					       : DMGL_RET_DROP)));
      if (demangled)
	{
	  make_cleanup (xfree, demangled);
	  canon = demangled;
	}
      else
	{
	  canon = mangled;
	  need_copy = 0;
	}
    }

  if (canon == NULL || check_physname)
    {
      const char *physname = dwarf2_compute_name (name, die, cu, 1);

      if (canon != NULL && strcmp (physname, canon) != 0)
	{
	  /* It may not mean a bug in GDB.  The compiler could also
	     compute DW_AT_linkage_name incorrectly.  But in such case
	     GDB would need to be bug-to-bug compatible.  */

	  complaint (&symfile_complaints,
		     _("Computed physname <%s> does not match demangled <%s> "
		       "(from linkage <%s>) - DIE at 0x%x [in module %s]"),
		     physname, canon, mangled, die->offset, cu->objfile->name);

	  /* Prefer DW_AT_linkage_name (in the CANON form) - when it
	     is available here - over computed PHYSNAME.  It is safer
	     against both buggy GDB and buggy compilers.  */

	  retval = canon;
	}
      else
	{
	  retval = physname;
	  need_copy = 0;
	}
    }
  else
    retval = canon;

  if (need_copy)
    retval = obsavestring (retval, strlen (retval),
			   &cu->objfile->objfile_obstack);

  do_cleanups (back_to);
  return retval;
a16156 9
static void
show_check_physname (struct ui_file *file, int from_tty,
		     struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Whether to check \"physname\" is %s.\n"),
		    value);
}

a16211 8
  add_setshow_boolean_cmd ("check-physname", no_class, &check_physname, _("\
Set cross-checking of \"physname\" code against demangler."), _("\
Show cross-checking of \"physname\" code against demangler."), _("\
When enabled, GDB's internal \"physname\" code is checked against\n\
the demangler."),
			   NULL, show_check_physname,
			   &setdebuglist, &showdebuglist);

@


1.518.2.9
log
@gdb/
	Fix occasional crash of CTRL-C during DWARF read in.
	* dwarf2read.c (dwarf2_mark_helper): Return on NULL CU.
@
text
@a15279 7

  /* cu->dependencies references may not yet have been ever read if QUIT aborts
     reading of the chain.  As such dependencies remain valid it is not much
     useful to track and undo them during QUIT cleanups.  */
  if (per_cu->cu == NULL)
    return 1;

@


1.518.2.10
log
@Commit patch from HEAD: http://sourceware.org/ml/gdb-patches/2011-10/msg00577.html

	* cp-namespace.c (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.  Instead of getting objfile from
	symbol's symtab, use new argument OBJFILE.
	* cp-support.h (cp_scan_for_anonymous_namespaces): Changed function
	arguments by adding OBJFILE.
	* gdb/dwarf2read.c (new_symbol_full): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
	* gdb/stabsread.c (define_symbol): Change call to
	cp_scan_for_anonymous_namespaces to match new signature.
@
text
@d11448 1
a11448 1
	cp_scan_for_anonymous_namespaces (sym, objfile);
@


1.517
log
@gdb/
	* dwarf2read.c (dwarf2_name): Initialize DEMANGLED.  Avoid demangling
	struct linkage name twice.
@
text
@d2048 1
a2048 1
     causes the index to behave very poorly for certain requests.  Version 4
@


1.516
log
@gdb
	* dwarf2read.c (fixup_partial_die): Handle linkage name on
	otherwise anonymous types.
	(dwarf2_name): Likewise.
	* valops.c (value_struct_elt_for_reference): Refine artificial
	type logic.  Call error if j==-1.
gdb/testsuite
	* gdb.cp/anon-struct.cc: New file.
	* gdb.cp/anon-struct.exp: New file.
@
text
@d12046 1
a12046 1
	  char *demangled;
d12055 4
a12058 1
	  demangled = cplus_demangle (DW_STRING (attr), DMGL_TYPES);
@


1.515
log
@	PR symtab/12441:
	* dwarf2read.c (prepare_one_comp_unit): Don't call set_cu_language
	with `language_minimal'.
@
text
@d9366 19
d11982 5
a11986 1
  if (!attr || !DW_STRING (attr))
d12037 3
a12039 2
      if (strncmp (DW_STRING (attr), "._", 2) == 0
	  || strncmp (DW_STRING (attr), "<anonymous", 10) == 0)
d12041 26
@


1.514
log
@2011-03-24  Mark Wielaard  <mjw@@redhat.com>

        * dwarf2read.c (lookup_signatured_type): Use DW_FORM_ref_sig8 in
        complaint.
        (skip_one_die): Use DW_FORM_ref_sig8, not DW_FORM_sig8.
        (find_partial_die_in_comp_unit): Likewise in comment.
        (read_attribute_value): Likewise.
        (lookup_die_type): Likewise.
        (dwarf_form_name): Likewise.
        (dump_die_shallow): Likewise.
        (follow_die_ref_or_sig): Likewise.
@
text
@d14682 4
a14685 1
    set_cu_language (language_minimal, cu);
@


1.513
log
@gdb/
	Code cleanup.
	* c-typeprint.c (c_type_print_args): Change parameter show_artificial
	to linkage_name.  Invert its value.  Update the function comment.
	(c_type_print_varspec_suffix): Invert it at the caller.
	* dwarf2read.c (dwarf2_compute_name): Invert it at the caller.
@
text
@d3108 1
a3108 1
		 _("missing `.debug_types' section for DW_FORM_sig8 die"));
d4220 1
a4220 1
	case DW_FORM_sig8:
d9187 1
a9187 1
   DW_FORM_sig8).  */
d9490 1
a9490 1
    case DW_FORM_sig8:
d11500 1
a11500 1
  else if (attr->form == DW_FORM_sig8)
d12540 2
a12541 2
    case DW_FORM_sig8:
      return "DW_FORM_sig8";
d13092 1
a13092 1
	case DW_FORM_sig8:
d13294 1
a13294 1
  else if (attr->form == DW_FORM_sig8)
d13325 1
a13325 1
	 DW_FORM_sig8.  */
@


1.512
log
@gdb/
	Revert:
	2011-03-21  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* dwarf2read.c (producer_is_gxx_lt_4_6): New function.
	(dwarf2_add_field): Fix new_field->accessibility for
	cu->header.version >= 3 while verifying also producer_is_gxx_lt_4_6.
@
text
@d4993 1
a4993 1
	      c_type_print_args (type, buf, 0, cu->language);
@


1.511
log
@gdb/
	* dwarf2read.c (producer_is_gxx_lt_4_6): New function.
	(dwarf2_add_field): Fix new_field->accessibility for
	cu->header.version >= 3 while verifying also producer_is_gxx_lt_4_6.
@
text
@a6211 21
/* Check for GCC PR debug/45124 fix which is not present in any G++ version up
   to 4.5.any hwile it is present already in G++ 4.6.0 - the PR has been fixed
   during 4.6.0 experimental.  */

static int
producer_is_gxx_lt_4_6 (const char *producer)
{
  int major, minor;

  /* Whitespaces are ignored in both PRODUCER and the format string.  */
  if (sscanf (producer, "GNU C++ %d.%d", &major, &minor) != 2)
    {
      /* For non-GCC compilers expect their behavior is DWARF version
	 compliant.  */

      return 0;
    }

  return major < 4 || (major == 4 && minor < 6);
}

d6242 5
a6246 10
  if (cu->header.version < 3 || producer_is_gxx_lt_4_6 (cu->producer))
    {
      /* The default DWARF 2 accessibility for members is public, the default
	 accessibility for inheritance is private.  */

      if (die->tag != DW_TAG_inheritance)
	new_field->accessibility = DW_ACCESS_public;
      else
	new_field->accessibility = DW_ACCESS_private;
    }
d6248 1
a6248 11
    {
      /* DWARF 3+ defines the default accessibility a different way - see
	 below - than DWARF 2 has defined.  The same rules apply now for
	 DW_TAG_inheritance as for the members and it only depends on the
	 container kind.  */

      if (die->parent->tag == DW_TAG_class_type)
	new_field->accessibility = DW_ACCESS_private;
      else
	new_field->accessibility = DW_ACCESS_public;
    }
@


1.510
log
@ChangeLog:

2011-03-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/12528
	* dwarf2read.c (noop_record_line): New function.
	(dwarf_decode_lines): Ignore line tables for GCd functions.

testsuite/ChangeLog:

2011-03-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	PR gdb/12528
	* gdb.base/Makefile.in: Adjust EXECUTABLES.
	* gdb.base/break-on-linker-gcd-function.exp: New test.
	* gdb.base/break-on-linker-gcd-function.cc: New file.
@
text
@d6212 21
d6263 10
a6272 5
  /* Handle accessibility and virtuality of field.
     The default accessibility for members is public, the default
     accessibility for inheritance is private.  */
  if (die->tag != DW_TAG_inheritance)
    new_field->accessibility = DW_ACCESS_public;
d6274 11
a6284 1
    new_field->accessibility = DW_ACCESS_private;
@


1.509
log
@gdb/
	* dwarf2read.c (dwarf2_get_pc_bounds): Require HIGH strictly higher
	than LOW.  Comment it.
	(read_partial_die): Call complaint for inappropriate zero LOWPC or
	HIGHPC not strictly higher than LOWPC.

gdb/testsuite/
	* gdb.dwarf2/dw2-empty-pc-range.S: New file.
	* gdb.dwarf2/dw2-empty-pc-range.exp: New file.
	* gdb.dwarf2/pr11465.S: New .text labels text_start and text_end.
	Provide a stub byte there.
	(DW_TAG_compile_unit): Set DW_AT_low_pc, DW_AT_high_pc and
	DW_AT_entry_pc.
	(dieb4, dieda): Set DW_AT_high_pc higher than DW_AT_low_pc.
@
text
@d10367 8
d10410 2
d10481 1
a10481 1
			    record_line (last_subfile, 0, addr);
d10487 1
a10487 1
		      record_line (current_subfile, line, addr);
d10504 1
d10509 16
d10581 1
a10581 1
			    record_line (last_subfile, 0, addr);
d10586 1
a10586 1
		      record_line (current_subfile, line, addr);
d10685 1
a10685 1
	      record_line (current_subfile, 0, addr);
@


1.508
log
@gdb/
	Revert:
	2011-03-08  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	Fix DWARF-3+ DW_AT_accessibility default assumption.
	* dwarf2read.c (dwarf2_add_field): Fix new_field->accessibility for
	cu->header.version >= 3.
@
text
@d5985 2
a5986 1
  if (high < low)
d9131 35
a9165 13
  /* When using the GNU linker, .gnu.linkonce. sections are used to
     eliminate duplicate copies of functions and vtables and such.
     The linker will arbitrarily choose one and discard the others.
     The AT_*_pc values for such functions refer to local labels in
     these sections.  If the section from that file was discarded, the
     labels are not in the output, so the relocs get a value of 0.
     If this is a discarded function, mark the pc bounds as invalid,
     so that GDB will ignore it.  */
  if (has_low_pc_attr && has_high_pc_attr
      && part_die->lowpc < part_die->highpc
      && (part_die->lowpc != 0
	  || dwarf2_per_objfile->has_section_at_zero))
    part_die->has_pc_info = 1;
@


1.507
log
@gdb/
	Fix DWARF-3+ DW_AT_accessibility default assumption.
	* dwarf2read.c (dwarf2_add_field): Fix new_field->accessibility for
	cu->header.version >= 3.
@
text
@d6241 5
a6245 10
  if (cu->header.version < 3)
    {
      /* The default DWARF 2 accessibility for members is public, the default
	 accessibility for inheritance is private.  */

      if (die->tag != DW_TAG_inheritance)
	new_field->accessibility = DW_ACCESS_public;
      else
	new_field->accessibility = DW_ACCESS_private;
    }
d6247 1
a6247 8
    {
      /* DWARF 3 specifies the default accessibility explicitly.  */

      if (die->parent->tag == DW_TAG_class_type)
	new_field->accessibility = DW_ACCESS_private;
      else
	new_field->accessibility = DW_ACCESS_public;
    }
@


1.506
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d6241 10
a6250 5
  /* Handle accessibility and virtuality of field.
     The default accessibility for members is public, the default
     accessibility for inheritance is private.  */
  if (die->tag != DW_TAG_inheritance)
    new_field->accessibility = DW_ACCESS_public;
d6252 8
a6259 1
    new_field->accessibility = DW_ACCESS_private;
@


1.505
log
@	PR gdb/12538:
	* dwarf2read.c (process_psymtab_comp_unit): Handle case where
	DW_STRING is NULL.
@
text
@a2769 1
  dwarf2_build_psymtabs (objfile);
@


1.504
log
@2011-03-01  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2read.c (dwarf2_compute_name): NAME cannot be null here.
@
text
@d3194 1
d3254 4
d3259 1
a3259 1
			      (attr != NULL) ? DW_STRING (attr) : "",
@


1.503
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2read.c (add_partial_symbol): Discard unused values.
	(read_base_type): Delete unused variable.
@
text
@d4852 1
a4852 1
	    fputs_unfiltered (name ? name : "", buf);
@


1.502
log
@2011-02-28  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2read.c (dw2_get_file_names): Discard unused value.
	(dwarf2_add_typedef): Delete unused variable.
	(read_namespace): Ditto.
	(dwarf_decode_macros): Ditto.
@
text
@d3840 1
a3840 1
	  /*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
d3842 6
a3847 6
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
				      built_actual_name,
				      VAR_DOMAIN, LOC_BLOCK,
				      &objfile->global_psymbols,
				      0, pdi->lowpc + baseaddr,
				      cu->language, objfile);
d3851 1
a3851 1
	  /*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
d3853 6
a3858 6
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
				      built_actual_name,
				      VAR_DOMAIN, LOC_BLOCK,
				      &objfile->static_psymbols,
				      0, pdi->lowpc + baseaddr,
				      cu->language, objfile);
d3869 3
a3871 4
	psym = add_psymbol_to_list (actual_name, strlen (actual_name),
				    built_actual_name, VAR_DOMAIN, LOC_STATIC,
				    list, 0, 0, cu->language, objfile);

d3903 6
a3908 6
	    psym = add_psymbol_to_list (actual_name, strlen (actual_name),
					built_actual_name,
					VAR_DOMAIN, LOC_STATIC,
					&objfile->global_psymbols,
					0, addr + baseaddr,
					cu->language, objfile);
d3919 1
a3919 1
	  /*prim_record_minimal_symbol (actual_name, addr + baseaddr,
d3921 6
a3926 6
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
				      built_actual_name,
				      VAR_DOMAIN, LOC_STATIC,
				      &objfile->static_psymbols,
				      0, addr + baseaddr,
				      cu->language, objfile);
a8185 1
  struct gdbarch *gdbarch = get_objfile_arch (cu->objfile);
@


1.501
log
@2011-02-25  Michael Snyder  <msnyder@@vmware.com>

	* arm-tdep.c: Fix typos in comments.
	* bsd-uthread.c: Ditto.
	* completer.c: Ditto.
	* corelow.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* cris-tdep.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* frame.h: Ditto.
	* gdbtypes.h: Ditto.
	* inferior.h: Ditto.
	* mdebugread.c: Ditto.
	* mips-tdep.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* printcmd.c: Ditto.
	* sol-thread.c: Ditto.
	* solib-frv.c: Ditto.
	* solist.h: Ditto.
	* sparc64-tdep.c: Ditto.
	* spu-tdep.c: Ditto.
	* stabsread.c: Ditto.
	* symfile.c: Ditto.
	* valops.c: Ditto.
	* varobj.c: Ditto.
	* vax-nat.c: Ditto.
	* python/py-block.c: Ditto.
	* python/py-symbol.c: Ditto.
	* python/py-symtab.c: Ditto.
	* python/py-value.c: Ditto.
	* tui/tui-win.c: Ditto.
@
text
@d2175 2
a2176 2
  info_ptr = read_full_die (&reader_specs, &comp_unit_die, info_ptr,
			    &has_children);
a6427 1
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
a7591 1
  const char *name;
d7605 1
a7605 1
      name = namespace_name (die, &is_anonymous, cu);
a14327 1
            char *string;
d14331 1
a14331 1
            string = read_direct_string (abfd, mac_ptr, &bytes_read);
@


1.500
log
@	* dwarf2loc.c (unimplemented): Handle unnamed opcodes.
	(compile_dwarf_to_ax) <default>: Use unimplemented.
	<DW_OP_deref>: Update.
	(disassemble_dwarf_expression): Update.
	* dwarf2read.c (dwarf_stack_op_name): Remove 'def' argument.
	(decode_locdesc): Update.
	* dwarf2expr.h (dwarf_stack_op_name): Update.
@
text
@d10597 1
a10597 1
	       scaled the the increment.  */
@


1.499
log
@include/ChangeLog:

	* dwarf2.h (enum dwarf_calling_convention): Add DW_CC_GDB_IBM_OpenCL.

gdb/ChangeLog:

	* dwarf2read.c (read_subroutine_type): Set special calling
	convention flag for functions compiled by IBM XL C for OpenCL.
	* ppc-sysv-tdep.c: Include "dwarf2.h"
	(ppc_sysv_abi_push_dummy_call): Implement IBM OpenCL vector types
	calling convention.
	(do_ppc_sysv_return_value): Add FUNC_TYPE argument.  Implement
	IBM OpenCL vector types calling convention.
	(ppc_sysv_abi_return_value): Pass through FUNC_TYPE.
	(ppc_sysv_abi_broken_return_value): Likewise.
	(ppc64_sysv_abi_push_dummy_call): Implement IBM OpenCL vector
	types calling convention.
	(ppc64_sysv_abi_return_value): Likewise.
	* spu-tdep.c: Include "dwarf2.h"
	(spu_return_value): Implement IBM OpenCL vector types calling
	convention.

gdb/testsuite/ChangeLog:

	* gdb.opencl/callfuncs.cl: New file.
	* gdb.opencl/callfuncs.exp: New test.
	* gdb.opencl/Makefile.in (EXECUTABLES): Add callfuncs.
@
text
@d12500 1
a12500 1
dwarf_stack_op_name (unsigned op, int def)
d12822 1
a12822 1
      return def ? "OP_<unknown>" : NULL;
d13746 11
a13756 2
	  complaint (&symfile_complaints, _("unsupported stack op: '%s'"),
		     dwarf_stack_op_name (op, 1));
@


1.498
log
@	* dwarf2read.c (dwarf2_section_empty_p): New function.
	(dwarf2_read_section): Use dwarf2_section_empty_p.
	(dwarf2_section_size): New function.
	(dwarf2_get_section_info): Unconditionally read section.
	(dwarf2_read_index): Use dwarf2_section_empty_p.
	(partial_read_comp_unit_head): Use dwarf2_section_size.
	(dwarf2_symbol_mark_computed): Likewise.
@
text
@d7958 6
a7963 1
  TYPE_CALLING_CONVENTION (ftype) = attr ? DW_UNSND (attr) : DW_CC_normal;
@


1.497
log
@	* dwarf2read.c (dwarf2_ranges_read): Skip empty range entries.
	Complain about inverted range entries.
	(dwarf2_record_block_ranges): Likewise.
@
text
@d1512 8
d1538 1
a1538 1
  if (info->asection == NULL || info->size == 0)
d1603 16
d1647 1
a1647 3
  if (info->asection != NULL && info->size != 0 && info->buffer == NULL)
    /* We haven't read this section in yet.  Do it now.  */
    dwarf2_read_section (objfile, info);
d2033 1
a2033 2
  if (dwarf2_per_objfile->gdb_index.asection == NULL
      || dwarf2_per_objfile->gdb_index.size == 0)
d2847 3
a2849 1
  if (header->abbrev_offset >= dwarf2_per_objfile->abbrev.size)
d14416 2
a14417 1
      && DW_UNSND (attr) < dwarf2_per_objfile->loc.size)
@


1.496
log
@gdb/
	* dwarf2read.c (dwarf2_read_index, write_psymtabs_to_index)
	(save_gdb_index_command): Switch to .gdb_index version 4.
@
text
@d5866 12
d5881 1
a5881 1
      if (ranges_pst != NULL && range_beginning < range_end)
d6164 13
@


1.495
log
@gdb/
	PR fortran/11104 and DWARF unbound arrays detection.
	* dwarf2read.c (read_subrange_type): Set zero length on unspecified
	upper bound.  Set TYPE_HIGH_BOUND_UNDEFINED if not language_ada on
	unspecified upper bound.
	* eval.c (evaluate_subexp_standard) <multi_f77_subscript>: Remove
	variables array_size_array, tmp_type and offset_item.  New variable
	array.  Remove call to f77_get_upperbound.  New variables array_type
	and index.  Call value_subscripted_rvalue for each dimenasion.  Remove
	the final call to deprecated_set_value_type.

gdb/testsuite/
	PR fortran/11104 and DWARF unbound arrays detection.
	* gdb.fortran/multi-dim.exp: New file.
	* gdb.fortran/multi-dim.f90: New file.
@
text
@d2027 4
a2030 3
     causes the index to behave very poorly for certain requests.  So,
     it seems better to just ignore such indices.  */
  if (version < 3)
d2034 1
a2034 1
  if (version > 3)
d15692 1
a15692 1
  val = MAYBE_SWAP (3);
d15750 1
a15750 1
   [0] The version number, currently 3.  Versions 1 and 2 are
@


1.494
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* charset.c (validate): Internationalization.
	* coffread.c (read_one_sym): Ditto.
	* dwarf2read.c (dwarf2_attach_fields_to_type): Ditto.
	* h8300-tdep.c (H8300_extract_return_value): Ditto.
	* inflow.c (new_tty): Ditto.
	* iq2000-tdep.c (iq2000_breakpoint_from_pc): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* mep-tdep.c (mep_store_return_value): Ditto.
	* score-tdep.c (score7_fetch_insn): Ditto.
	* ser-mingw.c (pipe_windows_open): Ditto.
	* sh64-tdep.c (sh64_extract_return_value): Ditto.
	* spu-tdep.c (spu_register_type): Ditto.
	* tracepoint.c (trace_find_command): Ditto.
	* valarith.c (value_pos): Ditto.
@
text
@d8195 5
d8255 4
@


1.493
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d6500 1
a6500 1
		error ("unexpected virtuality in component of Ada type");
d6524 1
a6524 1
    error ("unexpected member function in Ada type");
d6715 1
a6715 1
    error ("unexpected member functions in Ada type");
d9543 2
a9544 1
			  _("read_address: bad switch, unsigned [in module %s]"),
@


1.492
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d256 1
a256 1
/* We hold several abbreviation tables in memory at the same time. */
d467 5
a471 5
/* Struct used to pass misc. parameters to read_die_and_children, et. al.
   which are used for both .debug_info and .debug_types dies.
   All parameters here are unchanging for the life of the call.
   This struct exists to abstract away the constant parameters of
   die reading.  */
d534 1
a534 1
   need this much information. */
d599 1
a599 1
/* This data structure holds the information of an abbrev. */
d616 1
a616 1
/* Attributes have a name and a value */
d639 1
a639 1
/* This data structure holds a complete die structure. */
d680 1
a680 1
/* Get at parts of an attribute structure */
d690 1
a690 1
/* Blocks are a bunch of untyped bytes. */
d716 1
a716 1
    /* List of data member and baseclasses fields. */
d796 1
a796 1
/* Various complaints about symbol reading that don't abort the process */
d1596 1
a1596 1
   SECTION_NAME. */
d3244 1
a3244 1
  /* Store the function that reads in the rest of the symbol table */
d3264 1
a3264 1
     If not, there's no more debug_info for this comp unit. */
d3498 1
a3498 1
     If not, there's no more debug_info for this comp unit. */
d3889 1
a3889 1
	  /* Static Variable. Skip symbols without location descriptors.  */
d4412 1
a4412 1
            wrap_here ("");     /* Flush output */
d4971 1
a4971 1
		     names. */
d5017 1
a5017 1
   The output string will be canonicalized (if C++/Java). */
d5241 1
a5241 1
  /* We assume that we're processing GCC output. */
d5344 1
a5344 1
  /* We assume that we're processing GCC output. */
d6049 1
a6049 1
	    /* Ignore. */
d6560 1
a6560 1
     entry. */
d6599 4
a6602 4
         member functions. G++ helps GDB by marking the first
         parameter for non-static member functions (which is the
         this pointer) as artificial. We obtain this information
         from read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
d6917 1
a6917 1
     type within the structure itself. */
d6965 1
a6965 1
	      /* C++ member function. */
d7310 2
a7311 2
	      /* The range type was succesfully read. Save it for
                 the array type creation.  */
d7372 1
a7372 1
  /* Install the type in the die. */
d7392 6
a7397 8
  /*
    GNU F77 is a special case, as at 08/2004 array type info is the
    opposite order to the dwarf2 specification, but data is still
    laid out as per normal fortran.

    FIXME: dsl/2004-8-20: If G77 is ever fixed, this will also need
    version checking.
  */
d7416 1
a7416 1
   the DIE's type field. */
d7453 1
a7453 1
      /* Support the .debug_loc offsets */
d7845 1
a7845 1
      /* check for the DW_AT_byte_size attribute */
d7873 1
a7873 2
   ('funcp' generates a DW_TAG_subroutine_type DIE)
 */
d7878 2
a7879 2
  struct type *type;		/* Type that this function returns */
  struct type *ftype;		/* Function that returns above type */
d7913 1
a7913 1
     declared as the same subroutine type. */
d8208 1
a8208 2
     high bound or count are not yet handled by this code.
  */
d8505 1
a8505 1
  /* Initialize dwarf2 abbrevs */
d8522 1
a8522 1
  /* loop until we reach an abbrev number of 0 */
d8995 1
a8995 1
          /* Support the .debug_loc offsets */
d9458 1
a9458 1
/* read dwarf information from a buffer */
d10863 3
a10865 3
	  /* Compilation with minimal debug info may result in variables
	     with missing type entries. Change the misleading `void' type
	     to something sensible.  */
d11074 1
a11074 1
	     this point. */
d12834 1
a12834 1
/* Convert a DWARF call frame info operation to its string name. */
d13002 2
a13003 2
	  /* the reader will have reduced the indirect form to
	     the "base form" so this form should not occur */
d14272 1
a14272 1
   if so return true else false. */
d15343 1
a15343 1
  /* Start address of the CU. */
@


1.491
log
@run copyright.sh for 2011.
@
text
@d790 2
a791 2
  fprintf_filtered (file, _("\
The upper bound on the age of cached dwarf2 compilation units is %s.\n"),
d816 2
a817 1
	     _(".debug_line section has line program sequence without an end"));
d831 2
a832 2
	     _("const value length mismatch for '%s', got %d, expected %d"), arg1,
	     arg2, arg3);
d846 2
a847 1
	     _("macro debug info contains a malformed macro definition:\n`%s'"),
d855 2
a856 1
	     _("invalid attribute class or form for '%s' in '%s'"), arg1, arg2);
d1020 2
a1021 1
static struct type *die_descriptive_type (struct die_info *, struct dwarf2_cu *);
d1075 2
a1076 1
					     struct type *, struct dwarf2_cu *);
d1456 2
a1457 1
      || bfd_bread (compressed_buffer, compressed_size, abfd) != compressed_size)
d3001 2
a3002 1
  while (info_ptr < dwarf2_per_objfile->types.buffer + dwarf2_per_objfile->types.size)
d3025 2
a3026 1
		     _("debug type entry runs off end of `.debug_types' section, ignored"));
d3413 2
a3414 1
      this_cu = dwarf2_find_comp_unit (info_ptr - dwarf2_per_objfile->info.buffer,
d3533 2
a3534 1
  while (info_ptr < dwarf2_per_objfile->info.buffer + dwarf2_per_objfile->info.size)
d3728 2
a3729 1
	parent->scope = typename_concat (&cu->comp_unit_obstack, grandparent_scope,
d4104 2
a4105 2
      error (_("Dwarf Error: Could not find abbrev number %d [in module %s]"), abbrev_number,
		      bfd_get_filename (abfd));
d4154 2
a4155 1
	    complaint (&symfile_complaints, _("ignoring absolute DW_AT_sibling"));
d4231 2
a4232 1
	  error (_("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]"),
d4277 2
a4278 1
	  warning (_("bug: psymtab for %s is already read in."), pst->filename);
d4284 2
a4285 1
	      printf_filtered (_("Reading in symbols for %s..."), pst->filename);
d4434 2
a4435 1
load_full_comp_unit (struct dwarf2_per_cu_data *per_cu, struct objfile *objfile)
d4900 2
a4901 1
				 _("template parameter missing DW_AT_const_value"));
d4932 2
a4933 1
		      /* Specify decimal so that we do not depend on the radix.  */
d4986 2
a4987 1
		      && TYPE_CONST (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0))))
d5407 3
a5409 2
   Inherit only the children of the DW_AT_abstract_origin DIE not being already
   referenced by DW_AT_abstract_origin from the children of the current DIE.  */
d5507 3
a5509 2
      complaint (&symfile_complaints, _("Multiple children of DIE 0x%x refer "
					"to DIE 0x%x as their abstract origin"),
d5580 2
a5581 1
		   _("cannot get low and high bounds for subprogram DIE at %d"),
d5870 2
a5871 1
			   range_beginning + baseaddr, range_end - 1 + baseaddr,
d6146 2
a6147 1
                             _("Invalid .debug_ranges data (no base address)"));
d6451 3
a6453 3
  /* Copy the saved-up fields into the field vector.  Start from the head
     of the list, adding to the tail of the field array, so that they end
     up in the same order in the array in which they were added to the list.  */
d6614 2
a6615 2
  /* dwarf2 doesn't have stubbed physical names, so the setting of is_const
     and is_volatile is irrelevant, as it is needed by gdb_mangle_name only.  */
d6695 2
a6696 1
		     _("Member function \"%s\" (offset %d) is virtual but the vtable offset is not specified"),
d7042 2
a7043 1
			       _("virtual function table pointer not found when defining class '%s'"),
d7363 3
a7365 2
	complaint (&symfile_complaints, _("\
DW_AT_byte_size for array type smaller than the total size of elements"));
d7595 2
a7596 1
    complaint (&symfile_complaints, _("DW_TAG_module has no name, offset 0x%x"),
d7702 2
a7703 1
	  complaint (&symfile_complaints, _("invalid pointer size %d"), byte_size);
d8817 2
a8818 1
	    complaint (&symfile_complaints, _("malformed enumerator DIE ignored"));
d9033 2
a9034 1
	    complaint (&symfile_complaints, _("ignoring absolute DW_AT_sibling"));
d9174 2
a9175 1
		    _("could not find partial DIE 0x%x in cache [from module %s]\n"),
d9305 2
a9306 1
	DW_ADDR (attr) = read_offset (abfd, info_ptr, &cu->header, &bytes_read);
d9725 3
a9727 2
      error (_("DW_FORM_strp pointing outside of .debug_str section [in module %s]"),
		      bfd_get_filename (abfd));
d10101 2
a10102 1
		 _("invalid maximum_ops_per_instruction in `.debug_line' section"));
d10152 2
a10153 1
	       _("line number info header doesn't fit in `.debug_line' section"));
d10402 2
a10403 1
	      extended_len = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
d10424 2
a10425 1
                    cur_file = read_direct_string (abfd, line_ptr, &bytes_read);
d10652 2
a10653 1
dwarf2_start_subfile (char *filename, const char *dirname, const char *comp_dir)
d11221 2
a11222 1
      *bytes = dwarf2_const_value_data (attr, type, name, obstack, cu, value, 8);
d11225 2
a11226 1
      *bytes = dwarf2_const_value_data (attr, type, name, obstack, cu, value, 16);
d11229 2
a11230 1
      *bytes = dwarf2_const_value_data (attr, type, name, obstack, cu, value, 32);
d11233 2
a11234 1
      *bytes = dwarf2_const_value_data (attr, type, name, obstack, cu, value, 64);
d11535 2
a11536 1
      complaint (&symfile_complaints, _("unexpected tag in read_type_die: '%s'"),
d11599 2
a11600 1
			  && actual_name[actual_name_len - die_name_len - 1] == ':')
d11761 5
a11765 5
/* Return a newly-allocated string formed by concatenating PREFIX and
   SUFFIX with appropriate separator.  If PREFIX or SUFFIX is NULL or empty, then
   simply copy the SUFFIX or PREFIX, respectively.  If OBS is non-null,
   perform an obconcat, otherwise allocate storage for the result.  The CU argument
   is used to determine the language and hence, the appropriate separator.  */
d11776 2
a11777 1
  if (suffix == NULL || suffix[0] == '\0' || prefix == NULL || prefix[0] == '\0')
d11799 2
a11800 1
      char *retval = xmalloc (strlen (prefix) + MAX_SEP_LEN + strlen (suffix) + 1);
d12956 2
a12957 1
	  fprintf_unfiltered (f, "block: size %d", DW_BLOCK (&die->attrs[i])->size);
d13008 2
a13009 1
	  fprintf_unfiltered (f, "unexpected attribute form: DW_FORM_indirect");
d13049 2
a13050 1
	  fprintf_unfiltered (f, " [not printed, max nesting level reached]\n");
d13124 2
a13125 1
      complaint (&symfile_complaints, _("Attribute value is not a constant (%s)"),
d13356 2
a13357 2
  error (_("Dwarf Error: Cannot find signatured DIE at 0x%x referenced from DIE "
	 "at 0x%x [in module %s]"),
d13652 2
a13653 1
	  stack[stacki] += read_unsigned_leb128 (NULL, (data + i), &bytes_read);
d13854 2
a13855 1
		 _("macro definition contains spaces in formal argument list:\n`%s'"),
d14046 2
a14047 1
	     stop the first pass earlier upon finding DW_MACINFO_start_file.  */
d14084 2
a14085 2
	    current_file = macro_start_file (file, line, current_file, comp_dir,
					     lh, cu->objfile);
d14171 2
a14172 1
	    if ((line == 0 && !at_commandline) || (line != 0 && at_commandline))
d14200 2
a14201 1
	    if ((line == 0 && !at_commandline) || (line != 0 && at_commandline))
d14223 2
a14224 1
		       _("macro debug info has an unmatched `close_file' directive"));
d14249 2
a14250 1
			       _("no terminating 0-type entry for macros in `.debug_macinfo' section"));
d14372 2
a14373 1
		   _("Location list used without specifying the CU base address."));
d15520 2
a15521 1
		  info->objfile->global_psymbols.list + psymtab->globals_offset,
d15526 2
a15527 1
		  info->objfile->static_psymbols.list + psymtab->statics_offset,
d15624 2
a15625 1
      struct dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->all_comp_units[i];
d15842 3
a15844 2
  fprintf_filtered (file, _("\
Whether to always disassemble DWARF expressions is %s.\n"),
@


1.490
log
@	* dwarf2read.c (_initialize_dwarf2_read): Fix help text of
	"save gdb-index" command.
@
text
@d4 1
a4 1
                 2004, 2005, 2006, 2007, 2008, 2009, 2010
@


1.489
log
@	* dwarf2read.c (dwarf2_per_objfile): New member quick_file_names_table.
	(dwarf2_per_cu_quick_data): Move definition down to "quick functions"
	section.  Delete members lines full_names.  Rename read_lines to
	no_file_data.
	(quick_file_names): New struct.
	(hash_file_name_entry, eq_file_name_entry): New functions.
	(delete_file_name_entry, create_quick_file_names_table): New functions.
	(dwarf2_read_index): Initialize quick_file_names_table.
	(dw2_get_file_names): Renamed from dw2_require_line_header.
	Return pointer to quick_file_names entry.  All callers updated.
	(dw2_get_real_path): Renamed from dw2_require_full_path.
	Replace per_cu arg with pointer to quick_file_names entry.
	All callers updated.
	(dw2_free_cached_file_names): New function.
	(dw2_forget_cached_source_info): Call it (via htab_traverse_noresize).
	(dwarf2_initialize_objfile): Initialize quick_file_names_table in
	the OBJF_READNOW case.
	(dwarf2_free_objfile): Rewrite freeing of quick file names tables.
@
text
@d15842 1
a15842 1
Save a .gdb-index file.\n\
@


1.488
log
@	* dwarf2read.c: Whitespace cleanup, plus comment additions.
	No code changes.
@
text
@d214 6
a399 26
/* When using the index (and thus not using psymtabs), each CU has an
   object of this type.  This is used to hold information needed by
   the various "quick" methods.  */
struct dwarf2_per_cu_quick_data
{
  /* The line table.  This can be NULL if there was no line table.  */
  struct line_header *lines;

  /* The file names from the line table.  */
  const char **file_names;
  /* The file names from the line table after being run through
     gdb_realpath.  */
  const char **full_names;

  /* The corresponding symbol table.  This is NULL if symbols for this
     CU have not yet been read.  */
  struct symtab *symtab;

  /* A temporary mark bit used when iterating over all CUs in
     expand_symtabs_matching.  */
  unsigned int mark : 1;

  /* True if we've tried to read the line table.  */
  unsigned int read_lines : 1;
};

d1627 96
d2072 2
d2091 3
a2093 3
static void
dw2_require_line_header (struct objfile *objfile,
			 struct dwarf2_per_cu_data *this_cu)
d2096 1
a2096 1
  struct line_header *lh = NULL;
d2107 3
d2111 5
a2115 3
  if (this_cu->v.quick->read_lines)
    return;
  this_cu->v.quick->read_lines = 1;
d2150 3
d2156 16
a2171 1
      unsigned int line_offset = DW_UNSND (attr);
d2177 2
a2178 1
      return;
d2181 5
d2188 3
a2190 5
  this_cu->v.quick->lines = lh;

  this_cu->v.quick->file_names
    = obstack_alloc (&objfile->objfile_obstack,
		     lh->num_file_names * sizeof (char *));
d2192 2
a2193 1
    this_cu->v.quick->file_names[i] = file_full_name (i + 1, lh, comp_dir);
d2195 1
d2197 3
d2203 1
a2203 3
   real path for a given file name from the line table.
   dw2_require_line_header must have been called before this is
   invoked.  */
d2206 9
a2214 13
dw2_require_full_path (struct objfile *objfile,
		       struct dwarf2_per_cu_data *per_cu,
		       int index)
{
  if (!per_cu->v.quick->full_names)
    per_cu->v.quick->full_names
      = OBSTACK_CALLOC (&objfile->objfile_obstack,
			per_cu->v.quick->lines->num_file_names,
			sizeof (char *));

  if (!per_cu->v.quick->full_names[index])
    per_cu->v.quick->full_names[index]
      = gdb_realpath (per_cu->v.quick->file_names[index]);
d2216 1
a2216 1
  return per_cu->v.quick->full_names[index];
d2229 4
a2232 2
static void
dw2_forget_cached_source_info (struct objfile *objfile)
d2234 1
a2234 1
  int i;
d2236 1
a2236 3
  dw2_setup (objfile);
  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_comp_units); ++i)
d2238 1
a2238 1
      struct dwarf2_per_cu_data *per_cu = dw2_get_cu (i);
d2240 1
a2240 1
      if (per_cu->v.quick->full_names)
d2242 2
a2243 7
	  int j;

	  for (j = 0; j < per_cu->v.quick->lines->num_file_names; ++j)
	    {
	      xfree ((void *) per_cu->v.quick->full_names[j]);
	      per_cu->v.quick->full_names[j] = NULL;
	    }
d2246 11
d2275 1
d2280 2
a2281 2
      dw2_require_line_header (objfile, per_cu);
      if (!per_cu->v.quick->lines)
d2284 1
a2284 1
      for (j = 0; j < per_cu->v.quick->lines->num_file_names; ++j)
d2286 1
a2286 1
	  const char *this_name = per_cu->v.quick->file_names[j];
d2300 2
a2301 2
	      const char *this_full_name = dw2_require_full_path (objfile,
								  per_cu, j);
d2303 2
a2304 2
	      if (this_full_name
		  && FILENAME_CMP (full_path, this_full_name) == 0)
d2313 2
a2314 2
	      const char *this_full_name = dw2_require_full_path (objfile,
								  per_cu, j);
d2316 2
a2317 2
	      if (this_full_name != NULL
		  && FILENAME_CMP (real_path, this_full_name) == 0)
d2451 1
d2456 2
a2457 2
      dw2_require_line_header (objfile, per_cu);
      if (!per_cu->v.quick->lines)
d2460 1
a2460 1
      for (j = 0; j < per_cu->v.quick->lines->num_file_names; ++j)
d2462 1
a2462 1
	  const char *this_name = per_cu->v.quick->file_names[j];
d2477 1
d2496 2
a2497 2
  dw2_require_line_header (objfile, per_cu);
  if (!per_cu->v.quick->lines)
d2500 1
a2500 1
  return per_cu->v.quick->file_names[per_cu->v.quick->lines->num_file_names - 1];
d2539 1
d2545 2
a2546 2
      dw2_require_line_header (objfile, per_cu);
      if (!per_cu->v.quick->lines)
d2549 1
a2549 1
      for (j = 0; j < per_cu->v.quick->lines->num_file_names; ++j)
d2551 1
a2551 1
	  if (file_matcher (per_cu->v.quick->file_names[j], data))
d2658 1
d2663 2
a2664 2
      dw2_require_line_header (objfile, per_cu);
      if (!per_cu->v.quick->lines)
d2667 1
a2667 1
      for (j = 0; j < per_cu->v.quick->lines->num_file_names; ++j)
d2669 3
a2671 3
	  const char *this_full_name = dw2_require_full_path (objfile, per_cu,
							      j);
	  (*fun) (per_cu->v.quick->file_names[j], this_full_name, data);
d2721 2
d14656 2
a14657 24
  if (dwarf2_per_objfile->using_index)
    {
      int i;

      for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
	{
	  int j;
	  struct dwarf2_per_cu_data *per_cu =
	    dwarf2_per_objfile->all_comp_units[i];

	  if (!per_cu->v.quick->lines)
	    continue;

	  for (j = 0; j < per_cu->v.quick->lines->num_file_names; ++j)
	    {
	      if (per_cu->v.quick->file_names)
		xfree ((void *) per_cu->v.quick->file_names[j]);
	      if (per_cu->v.quick->full_names)
		xfree ((void *) per_cu->v.quick->full_names[j]);
	    }

	  free_line_header (per_cu->v.quick->lines);
	}
    }
@


1.487
log
@	PR symtab/12302
	* dwarf2read.c (struct psymtab_cu_index_map): New struct.
	(hash_psymtab_cu_index, eq_psymtab_cu_index): New functions.
	(struct addrmap_index_data): New struct.
	(add_address_entry): Remove arg `pst', new args `start', `end'.
	(add_address_entry_worker, write_address_map): New functions.
	(write_psymtabs_to_index): Address table generation moved to
	write_address_map.  Build a table mapping psymtab to CU index
	to pass to it.
@
text
@d207 2
a208 1
  /* True if we are using the mapped index.  */
d211 1
a211 1
  /* The mapped index.  */
d2119 1
d2159 1
d2241 1
d2368 1
d2415 2
d2510 1
d2538 1
d5008 2
d5059 2
d5158 2
a5159 1
/* For TUs we want to skip the first top level sibling if it's not the
d9800 3
a9802 1
   refers to.  */
d9821 1
a9822 1
/* Add an entry to LH's include directory table.  */
d9844 1
a9845 1
/* Add an entry to LH's file name table.  */
a9878 1

d9886 1
a13580 1

d14844 1
@


1.486
log
@	* dwarf2read.c (write_psymtabs_to_index): When stat fails, pass file
	name to perror.
@
text
@d15140 42
a15181 3
/* Write an address entry to ADDR_OBSTACK.  The addresses are taken
   from PST; CU_INDEX is the index of the CU in the vector of all
   CUs.  */
d15184 2
a15185 3
add_address_entry (struct objfile *objfile,
		   struct obstack *addr_obstack, struct partial_symtab *pst,
		   unsigned int cu_index)
d15187 1
a15187 1
  offset_type offset;
d15191 44
a15234 3
  /* Don't bother recording empty ranges.  */
  if (pst->textlow == pst->texthigh)
    return;
d15236 5
a15240 1
  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d15242 21
a15262 6
  store_unsigned_integer (addr, 8, BFD_ENDIAN_LITTLE, pst->textlow - baseaddr);
  obstack_grow (addr_obstack, addr, 8);
  store_unsigned_integer (addr, 8, BFD_ENDIAN_LITTLE, pst->texthigh - baseaddr);
  obstack_grow (addr_obstack, addr, 8);
  offset = MAYBE_SWAP (cu_index);
  obstack_grow (addr_obstack, &offset, sizeof (offset_type));
d15395 2
d15433 15
a15447 1
  /* The list is already sorted, so we don't need to do additional
d15455 2
d15469 7
a15475 1
      add_address_entry (objfile, &addr_obstack, psymtab, i);
d15483 3
@


1.485
log
@	* symfile.h (quick_symbol_functions): Clarify usage of
	expand_symtabs_with_filename.
	* dwarf2read.c (dw2_expand_symtabs_with_filename): Only iterate over
	comp units, ignore type units.
@
text
@d15304 1
a15304 1
    perror_with_name (_("Could not stat"));
@


1.484
log
@	* dwarf2read.c (dw2_expand_symtabs_with_filename): Use FILENAME_CMP.
@
text
@d2326 7
a2332 2
  for (i = 0; i < (dwarf2_per_objfile->n_comp_units
		   + dwarf2_per_objfile->n_type_comp_units); ++i)
@


1.483
log
@	* dwarf2read.c (dw2_lookup_symtab): Remove duplicate call to
	gdb_realpath.
@
text
@d2342 1
a2342 1
	  if (strcmp (this_name, filename) == 0)
@


1.482
log
@	* dwarf2read.c (save_gdb_index_command): Add comment.
@
text
@d2202 2
a2203 1
	      if (this_full_name != NULL)
d2205 2
a2206 8
		  char *rp = gdb_realpath (this_full_name);
		  if (rp != NULL && FILENAME_CMP (real_path, rp) == 0)
		    {
		      xfree (rp);
		      *result = dw2_instantiate_symtab (objfile, per_cu);
		      return 1;
		    }
		  xfree (rp);
@


1.481
log
@gdb
	* opencl-lang.c (lval_func_check_synthetic_pointer): New
	function.
	* value.h (struct lval_funcs) <indirect, check_synthetic_pointer>:
	New fields.
	(value_bits_synthetic_pointer): Declare.
	* value.c (value_bits_synthetic_pointer): New function.
	* valprint.c (valprint_check_validity): Handle synthetic
	pointers.
	* valops.c (value_ind): Use new 'indirect' lval_funcs method.
	* valarith.c (value_ptradd): Use set_value_component_location.
	* p-valprint.c (pascal_object_print_value_fields): Handle
	synthetic pointers.
	* jv-valprint.c (java_print_value_fields): Handle synthetic
	pointers.
	* dwarf2read.c (dwarf_stack_op_name): Add
	DW_OP_GNU_implicit_pointer.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.  Handle location lists.
	(fill_in_loclist_baton): New function.
	(dwarf2_symbol_mark_computed): Use it.
	* dwarf2loc.h (dwarf2_find_location_expression): Declare.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.
	* dwarf2loc.c (dwarf2_find_location_expression): Rename from
	find_location_expression.  No longer static.  Update all callers.
	(dwarf_expr_frame_pc): New function.
	(per_cu_dwarf_call): Add get_frame_pc, baton arguments.  Update
	all callers.
	(struct piece_closure) <per_cu>: New field.
	(allocate_piece_closure): Add per_cu argument.
	(read_pieced_value): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_bits): Remove validity argument, add check_for
	argument.  Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_validity, check_pieced_value_invalid):
	Update.
	(check_pieced_synthetic_pointer): New function.
	(get_frame_address_in_block_wrapper): New function.
	(indirect_pieced_value): New function.
	(pieced_value_funcs): Update.
	(invalid_synthetic_pointer): New function.
	(dwarf2_evaluate_loc_desc_full): Rename from
	dwarf2_evaluate_loc_desc.  Add byte_offset argument.
	(dwarf2_evaluate_loc_desc): Rewrite.
	(dwarf2_loc_desc_needs_frame): Set new field on context.
	(get_ax_pc): New function.
	(disassemble_dwarf_expression): Handle
	DW_OP_GNU_implicit_pointer.
	* dwarf2expr.h (enum dwarf_value_location)
	<DWARF_VALUE_IMPLICIT_POINTER>: New constant.
	(struct dwarf_expr_context) <get_frame_pc>: New field.
	(struct dwarf_expr_piece) <v.ptr>: New field.
	* dwarf2expr.c (add_piece): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(execute_stack_op): Handle DW_OP_GNU_implicit_pointer.
	* dwarf2-frame.c (no_get_frame_pc): New function.
	(execute_stack_op): Set new field on context.
	* cp-valprint.c (cp_print_value_fields): Handle synthetic
	pointers.
gdb/testsuite
	* gdb.dwarf2/implptr.exp: New file.
	* gdb.dwarf2/implptr.c: New file.
	* gdb.dwarf2/implptr.S: New file.
@
text
@d15474 1
@


1.480
log
@gdb/
	Code cleanup.
	* dictionary.c
	(struct dict_vector) <iter_match_first, iter_match_next>
	(iter_match_first_hashed, iter_match_next_hashed)
	(iter_match_first_linear, iter_match_next_linear)
	(dict_iter_match_first, dict_iter_match_next, iter_match_first_hashed)
	(iter_match_next_hashed, iter_match_first_linear)
	(iter_match_next_linear): Use symbol_compare_ftype.
	* dictionary.h: Include symfile.h.
	(dict_iter_match_first, dict_iter_match_next): Use
	symbol_compare_ftype.
	* dwarf2read.c (dw2_map_matching_symbols): Likewise.
	* psymtab.c (match_partial_symbol, match_partial_symbol, map_block)
	(map_matching_symbols_psymtab): Likewise.
	* symfile.h (symbol_compare_ftype): New typedef.
	(struct quick_symbol_functions) <map_matching_symbols): Use
	symbol_compare_ftype.
@
text
@d1224 4
d12579 2
d13085 3
a13087 1
				 struct dwarf2_per_cu_data *per_cu)
d13094 2
d13109 12
d14144 19
a14176 2
      baton->per_cu = cu->per_cu;
      gdb_assert (baton->per_cu);
d14178 1
a14178 2
      dwarf2_read_section (dwarf2_per_objfile->objfile,
			   &dwarf2_per_objfile->loc);
a14179 5
      /* We don't know how long the location list is, but make sure we
	 don't run off the edge of the section.  */
      baton->size = dwarf2_per_objfile->loc.size - DW_UNSND (attr);
      baton->data = dwarf2_per_objfile->loc.buffer + DW_UNSND (attr);
      baton->base_address = cu->base_address;
@


1.479
log
@gdb/
	* dwarf2read.c (dwarf2_read_index): Ignore higher .gdb_index versions.
@
text
@d2386 2
a2387 4
			  void *data,
			  int (*match) (const char *, const char *),
			  int (*ordered_compare) (const char *,
						  const char *))
@


1.478
log
@2010-11-19  Will Drewry  <wad@@google.com>
	    Tavis Ormandy  <taviso@@google.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* dwarf2read.c (decode_locdesc): Enforce location description stack
	boundaries.
@
text
@d1944 4
@


1.477
log
@gdb/
	* dwarf2read.c (dw2_forget_cached_source_info): Clear the FULL_NAMES
	elements after xfree.
@
text
@d13282 1
a13282 2
   Note that stack[0] is unused except as a default error return.
   Note that stack overflow is not yet handled.  */
d13299 1
d13481 16
@


1.476
log
@gdb/
	Code cleanup.
	* dwarf2read.c (alloc_one_comp_unit): Rename prototype to ...
	(init_one_comp_unit): ... this one.
	(prepare_one_comp_unit): New prototype.
	(dw2_require_line_header, process_psymtab_comp_unit): Use
	init_one_comp_unit.
	(process_psymtab_comp_unit): Use prepare_one_comp_unit.
	(load_partial_comp_unit): Remove variable attr.  Use
	init_one_comp_unit with xmalloc.  Use prepare_one_comp_unit.
	(load_full_comp_unit): Use init_one_comp_unit with xmalloc.  Use
	prepare_one_comp_unit.
	(read_signatured_type): Remove variable attr.  Use init_one_comp_unit.
	Use prepare_one_comp_unit.
	(alloc_one_comp_unit): Rename to ...
	(init_one_comp_unit): ... here and remove there calloc, new parameter
	cu.
	(prepare_one_comp_unit): New function.
@
text
@d2131 4
a2134 1
	    xfree ((void *) per_cu->v.quick->full_names[j]);
@


1.475
log
@gdb:
	* NEWS: Mention OpenCL C language support.
	* Makefile.in (SFILES): Add opencl-lang.c.
	(COMMON_OBS): Add opencl-lang.o.
	* opencl-lang.c: New File
	* defs.h (enum language): Add language_opencl.
	* dwarf2read.c (read_file_scope): Handle DW_AT_producer for the
	IBM XL C OpenCL compiler.
	* c-lang.h: Include "parser-defs.h".
	(evaluate_subexp_c): Declare.
	* c-lang.c (evaluate_subexp_c): Remove the static qualifier.
	(c_op_print_tab): Add declaration.
	* eval.c (binop_promote): Handle language_opencl.
	* c-exp.y: Lookup the primitive types instead of referring to the
	builtins.

gdb/testsuite:
	* Makefile.in (ALL_SUBDIRS): Add gdb.opencl.
	* configure.ac (AC_OUTPUT): Add gdb.opencl/Makefile.
	* configure: Regenerate.
	* gdb.opencl/Makefile.in: New File.
	* gdb.opencl/datatypes.exp: Likewise.
	* gdb.opencl/datatypes.cl: Likewise.
	* gdb.opencl/operators.exp: Likewise.
	* gdb.opencl/operators.cl: Likewise.
	* gdb.opencl/vec_comps.exp: Likewise.
	* gdb.opencl/vec_comps.cl: Likewise.
	* gdb.opencl/convs_casts.exp: Likewise.
	* gdb.opencl/convs_casts.cl: Likewise.
	* lib/opencl.exp: Likewise.
	* lib/opencl_hostapp.c: Likewise.
	* lib/opencl_kernel.cl: Likewise.
	* lib/cl_util.c: Likewise.
	* lib/cl_util.c: Likewise.
	* gdb.base/default.exp (set language): Add "opencl" to the list of
	languages.

gdb/doc:
	* gdb.texinfo: (Summary) Add mention about OpenCL C language support.
	(OpenCL C): New node.
@
text
@d1244 5
a1248 1
static struct dwarf2_cu *alloc_one_comp_unit (struct objfile *objfile);
d2025 1
a2025 4
  memset (&cu, 0, sizeof (cu));
  cu.objfile = objfile;
  obstack_init (&cu.comp_unit_obstack);

d3028 1
a3028 4
  memset (&cu, 0, sizeof (cu));
  cu.objfile = objfile;
  obstack_init (&cu.comp_unit_obstack);

d3082 1
a3082 6
  /* Set the language we're debugging.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_language, &cu);
  if (attr)
    set_cu_language (DW_UNSND (attr), &cu);
  else
    set_cu_language (language_minimal, &cu);
a3296 1
  struct attribute *attr;
d3309 2
a3310 1
      cu = alloc_one_comp_unit (objfile);
d3350 1
a3350 6
  /* Set the language we're debugging.  */
  attr = dwarf2_attr (comp_unit_die, DW_AT_language, cu);
  if (attr)
    set_cu_language (DW_UNSND (attr), cu);
  else
    set_cu_language (language_minimal, cu);
d4305 2
a4306 1
      cu = alloc_one_comp_unit (objfile);
d4344 1
a4344 5
  attr = dwarf2_attr (cu->dies, DW_AT_language, cu);
  if (attr)
    set_cu_language (DW_UNSND (attr), cu);
  else
    set_cu_language (language_minimal, cu);
a13207 1
  struct attribute *attr;
d13214 3
a13216 4
  cu = xmalloc (sizeof (struct dwarf2_cu));
  memset (cu, 0, sizeof (struct dwarf2_cu));
  obstack_init (&cu->comp_unit_obstack);
  cu->objfile = objfile;
d13248 1
a13248 5
  attr = dwarf2_attr (cu->dies, DW_AT_language, cu);
  if (attr)
    set_cu_language (DW_UNSND (attr), cu);
  else
    set_cu_language (language_minimal, cu);
d14296 1
a14296 1
/* Malloc space for a dwarf2_cu for OBJFILE and initialize it.  */
d14298 2
a14299 2
static struct dwarf2_cu *
alloc_one_comp_unit (struct objfile *objfile)
d14301 1
a14301 1
  struct dwarf2_cu *cu = xcalloc (1, sizeof (struct dwarf2_cu));
d14304 15
a14318 1
  return cu;
@


1.474
log
@gdb:
	* dwarf2read.c (read_array_type): Read the DW_AT_byte_size from the
	DIE and set the length of the type.
	* gdbtypes.h (get_array_bounds): Move here from valprint.h.
	* gdbtypes.c (get_array_bounds): Move here from valprint.c and
	return 0 if the corresponding bounds of the type are undefined.
	* valprint.h (get_array_bounds): Move declaration to gdbtypes.h.
	* valprint.c (get_array_bounds): Move implementation to gdbtypes.c.
	(val_print_array_elements): Use get_array_bounds to compute the number
	of array elements instead of dividing the length of the array by the
	length of the element types.
	* valarith.c (vector_binop): Likewise.
	* valops.c (value_cast): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* c-typeprint.c (c_type_print_varspec_suffix): Likewise.

gdb/testsuite:
	* gdb.base/gnu_vector.exp: Adjust expect messages.
@
text
@d5092 6
@


1.473
log
@replace strcmp by FILENAME_CMP for filename comparison

gdb/ChangeLog:

        * dwarf2read.c (psymtab_include_file_name): Replace call to strcmp
        by call to FILENAME_CMP.
@
text
@d7197 13
@


1.472
log
@gdb/
	Fix the `stopped language detection' testcase for gcc-4.5.
	* dwarf2read.c (read_partial_die): Set also LANGUAGE_OF_MAIN.
	* symfile.c (set_initial_language): Move variable filename to a more
	inner block.  Prefer LANGUAGE_OF_MAIN.
	* symtab.c (language_of_main): New variable.
	(set_main_name): Always reset LANGUAGE_OF_MAIN.
	* symtab.h (language_of_main): New declaration.
@
text
@d10090 1
a10090 1
  file_is_pst = strcmp (include_name_to_compare, pst_filename) == 0;
@


1.471
log
@	* dwarf2read.c (mapped_index): Rename member index_table to
	symbol_table and index_table_slots to symbol_table_slots.
	All uses updated.
	(create_symbol_hash_table): Renamed from create_index_table.
	All callers updated.
	(add_indices_to_cpool): Rename arg index_table to symbol_hash_table.
	(write_hash_table): Rename local index_table to symbol_hash_table.
@
text
@d8883 7
a8889 1
	    set_main_name (part_die->name);
@


1.470
log
@Rework symbol searches to move Ada-specific stuff to ada-lang.c.

This is a clean-up of some of our symbol-lookup machinery to pull some
kludgy Ada-specific definitions out of psymtab.c.  In place of
map_ada_symtabs and ada_lookup_partial_symbol, we have a method
map_matching_symbols, which searches through all symbol tables and
partial symbol tables looking for a symbol that matches according to
a matching function that is passed as a parameter. This requires some
care, because partial symbol tables speed up searches by binary search,
while full symbol tables use hashing. To call map_matching_symbols, therefore,
you may need to supply both a matching function that is compatible with the
dictionary hash function and an ordering relation that is compatible with
strcmp_iw, which is used to order partial symbol tables.

Having added this general routine to psymtab.c, we use it in ada-lang.c
to rework add_non_local_symbols (now renamed add_nonlocal_symbols).

Changelog:

    gdb/

    * ada-lang.c (full_match): Declare.
    (ada_match_name): Rename to match_name (we should avoid prefixing static
    symbols with "ada_").
    (match_name): New name for ada_match_name.
    (struct ada_psym_data): Remove and replace with...
    (struct match_data): User data for map_matching_symbols.
    (ada_add_psyms): Remove.
    (aux_add_nonlocal_symbols): New function, used as callback for
    map_matching_symbols.
    (compare_names): Ordering function adopted from strcmp_iw for Ada-encoded
    symbols.
    (ada_add_non_local_symbols): Rename to add_nonlocal_symbols.
    (add_nonlocal_symbols): Renamed from ada_add_non_local_symbols.
    Rework to use map_matching_symbols instead of map_ada_symtabs.
    (ada_lookup_symbol_list): Use add_nonlocal_symbols.
    * psymtab.c: Include dependency on dictionary.h.
    (match_partial_symbol): New function.
    (ada_lookup_partial_symbol): Remove.
    (map_block): New function, auxiliary to map_matching_symbols_psymtab.
    (map_matching_symbols_psymtab): New function.
    (psym_functions): Replace map_ada_symtabs with map_matching_symbols_psymtab.
    * symfile.h: Replace map_ada_symtabs definition with map_matching_symbols.
@
text
@d157 2
a158 2
  /* The hash table.  */
  const offset_type *index_table;
d160 1
a160 1
  offset_type index_table_slots;
d1882 2
a1883 2
  slot = hash & (index->index_table_slots - 1);
  step = ((hash * 17) & (index->index_table_slots - 1)) | 1;
d1890 1
a1890 1
      if (index->index_table[i] == 0 && index->index_table[i + 1] == 0)
d1893 1
a1893 1
      str = index->constant_pool + MAYBE_SWAP (index->index_table[i]);
d1897 1
a1897 1
				      + MAYBE_SWAP (index->index_table[i + 1]));
d1901 1
a1901 1
      slot = (slot + step) & (index->index_table_slots - 1);
d1963 4
a1966 4
  map->index_table = (offset_type *) (addr + MAYBE_SWAP (metadata[i]));
  map->index_table_slots = ((MAYBE_SWAP (metadata[i + 1])
			     - MAYBE_SWAP (metadata[i]))
			    / (2 * sizeof (offset_type)));
d2428 1
a2428 1
  for (iter = 0; iter < index->index_table_slots; ++iter)
d2434 1
a2434 1
      if (index->index_table[idx] == 0 && index->index_table[idx + 1] == 0)
d2437 1
a2437 1
      name = index->constant_pool + MAYBE_SWAP (index->index_table[idx]);
d2445 1
a2445 1
			     + MAYBE_SWAP (index->index_table[idx + 1]));
d2497 1
a2497 1
  for (iter = 0; iter < index->index_table_slots; ++iter)
d2503 1
a2503 1
      if (index->index_table[idx] == 0 && index->index_table[idx + 1] == 0)
d2506 1
a2506 1
      name = (index->constant_pool + MAYBE_SWAP (index->index_table[idx]));
d14879 1
a14879 1
create_index_table (void)
d14983 1
a14983 1
add_indices_to_cpool (htab_t index_table, struct obstack *cpool,
d14988 1
a14988 1
  slot = htab_find_slot (index_table, entry, INSERT);
d15025 1
a15025 1
  htab_t index_table;
d15028 1
a15028 1
  index_table = create_index_table ();
d15030 1
d15036 1
a15036 1
	add_indices_to_cpool (index_table, cpool, symtab->data[i]);
d15065 1
a15065 1
  htab_delete (index_table);
@


1.469
log
@gdb:
	* dwarf2read.c (read_tag_const_type): Handle const arrays.
gdb/testsuite:
	* gdb.base/constvars.c (logical, lugged, luck, lunar, lumen, lurk,
	lush, lynx) New constant.
	* gdb.base/constvars.exp: Test const array types.
	* gdb.dwarf2/dw2-strp.exp: Add const qualifier for ptype tests.
@
text
@d2374 8
a2381 8
dw2_map_ada_symtabs (struct objfile *objfile,
		     int (*wild_match) (const char *, const char *),
		     int (*is_name_suffix) (const char *),
		     void (*callback) (struct objfile *,
				       struct symtab *, void *),
		     const char *name, int global,
		     domain_enum namespace, int wild,
		     void *data)
d2383 1
a2383 1
  /* For now, we don't support Ada.  Still the function can be called if the
d2563 1
a2563 1
  dw2_map_ada_symtabs,
@


1.468
log
@	* dwarf2read.c (hash_strtab_entry): Insert blank line after
	function comment.
	(eq_strtab_entry, create_strtab, add_string): Ditto.
	(hash_symtab_entry, eq_symtab_entry, delete_symtab_entry): Ditto.
	(create_index_table, create_mapped_symtab, find_slot): Ditto.
	(hash_expand, add_index_entry, add_indices_to_cpool): Ditto.
	(write_hash_table, add_address_entry, write_psymbols): Ditto.
	(write_obstack, unlink_if_set, write_one_signatured_type): Ditto.
	(write_psymtabs_to_index): Ditto.
@
text
@d7610 23
@


1.467
log
@	* dwarf2read.c (dw2_do_instantiate_symtab): Insert blank line after
	function comment.
	(dw2_instantiate_symtab, dw2_get_cu, extract_cu_value): Ditto.
	(create_cus_from_index, create_addrmap_from_index): Ditto.
	(mapped_index_string_hash, find_slot_in_mapped_hash): Ditto.
	(dw2_setup, dw2_require_line_header, dw2_require_full_path): Ditto.
	(dw2_do_expand_symtabs_matching): Ditto.
@
text
@d14744 1
d14753 1
d14763 1
d14773 1
d14817 1
d14829 1
d14844 1
d14854 1
d14863 1
d14875 1
d14888 1
d14906 1
d14932 1
d14958 1
d14996 1
d15047 1
d15072 1
d15112 1
d15123 1
d15144 1
d15186 1
@


1.466
log
@Replace wild_match with faster version and modify its interface.

This new version of wild_match is comparable in speed to strcmp_iw, and has
the same signature and same return value for equal names.

gdb/ChangeLog:
    * ada-lang.c (wild_match): Reimplement.
    Change API to eliminate unused length argument, reverse arguments and
    make 0 the 'true' return value.
    (advance_wild_match): New auxiliary function for wild_match to improve
    readability.
    (ada_match_name, ada_add_block_symbols): Use new API for wild_match.
    * psymtab.c (ada_lookup_partial_symbol, map_ada_symtabs): Use new
    API for wild_match.
    * symfile.h (map_ada_symtabs): Modify declaration to use new API for
    wild_match.
    * dwarf2read.c (dw2_map_ada_symtabs): Ditto.
@
text
@d1641 1
d1669 1
d1685 1
d1700 1
d1723 1
d1814 1
d1857 1
d1874 1
d1907 1
d1989 1
d1999 1
d2086 1
d2225 1
@


1.465
log
@	* dwarf2read.c (_initialize_dwarf2_read): Add usage info to help text
	for `save gdb-index' command.
@
text
@d2362 1
a2362 1
		     int (*wild_match) (const char *, int, const char *),
@


1.464
log
@	* symfile.h (allocate_symtab): Update.
	* symfile.c (allocate_symtab): Make 'filename' const.
	* psymtab.c (add_psymbol_to_bcache): Make 'name' const.
	(add_psymbol_to_list): Likewise.
	* psympriv.h (struct partial_symtab) <filename, dirname>: Now
	const.
	(add_psymbol_to_list): Update.
	* mdebugread.c (new_symtab): Make 'name' const.
	(psymtab_to_symtab_1): Make 'filename' const.
	* elfread.c (elfstab_offset_sections): Update.
	* dwarf2read.c (dwarf_decode_lines): Make 'comp_dir' const.
	(dwarf2_start_subfile): Make 'dirname' and 'comp_dir' const.
	(psymtab_include_file_name): Update.
	* dbxread.c (find_stab_function_addr): Make 'filename' const.
	* buildsym.h (start_subfile): Update.
	* buildsym.c (start_subfile): Make arguments const.
@
text
@d15371 1
d15474 3
a15476 1
	       _("Save a .gdb-index file"),
@


1.463
log
@	Workaround for gcc/45682.
	* dwarf2read.c (partial_die_info): New fields fixup_called,
	linkage_name.
	(guess_partial_die_structure_name): Renamed from guess_structure_name.
	Move definition next to use.  Use linkage_name to determine if class
	is in a namespace.  All callers updated.
	(fixup_partial_die): Return early if already called.
	Set fixup_called when done.
	(guess_full_die_structure_name): New function.
	(determine_prefix): Call it for class/struct/union dies if c++ and
	.debug_types section is present and parent is DW_TAG_compile_unit.
@
text
@d1010 1
a1010 1
static void dwarf_decode_lines (struct line_header *, char *, bfd *,
d1013 1
a1013 1
static void dwarf2_start_subfile (char *, char *, char *);
d9997 2
a9998 1
  char *pst_filename;
d10043 3
a10045 2
      pst_filename = concat (pst->dirname, SLASH_STRING,
			     pst_filename, (char *)NULL);
d10052 2
a10053 2
  if (pst_filename != pst->filename)
    xfree (pst_filename);
d10083 1
a10083 1
dwarf_decode_lines (struct line_header *lh, char *comp_dir, bfd *abfd,
d10426 1
a10426 1
dwarf2_start_subfile (char *filename, char *dirname, char *comp_dir)
@


1.462
log
@	* dwarf2read.c (dwarf2_read_index): Only allow version 3.
	(write_psymbols): Add 'psyms_seen' and 'is_static' arguments.
	Only emit a given psymbol once.
	(struct signatured_type_index_data) <psyms_seen>: New field.
	(write_one_signatured_type): Update.
	(cleanup_htab): New function.
	(write_psymtabs_to_index): Update.  Create psyms_seen hash.  Bump
	version to 3.
	(save_gdb_index_command): Update index documentation.
@
text
@d580 3
d587 3
d604 2
a3913 34
/* See if we can figure out if the class lives in a namespace.  We do
   this by looking for a member function; its demangled name will
   contain namespace info, if there is any.  */

static void
guess_structure_name (struct partial_die_info *struct_pdi,
		      struct dwarf2_cu *cu)
{
  if ((cu->language == language_cplus
       || cu->language == language_java)
      && cu->has_namespace_info == 0
      && struct_pdi->has_children)
    {
      /* NOTE: carlton/2003-10-07: Getting the info this way changes
	 what template types look like, because the demangler
	 frequently doesn't give the same name as the debug info.  We
	 could fix this by only using the demangled name to get the
	 prefix (but see comment in read_structure_type).  */

      struct partial_die_info *real_pdi;

      /* If this DIE (this DIE's specification, if any) has a parent, then
	 we should not do this.  We'll prepend the parent's fully qualified
         name when we create the partial symbol.  */

      real_pdi = struct_pdi;
      while (real_pdi->has_specification)
	real_pdi = find_partial_die (real_pdi->spec_offset, cu);

      if (real_pdi->die_parent != NULL)
	return;
    }
}

d8778 1
d8962 51
d9020 6
d9052 15
a9066 4
  if (part_die->tag == DW_TAG_structure_type
      || part_die->tag == DW_TAG_class_type
      || part_die->tag == DW_TAG_union_type)
    guess_structure_name (part_die, cu);
d11310 71
d11507 14
@


1.461
log
@	* dwarf2read.c (dw2_expand_symtabs_matching): Add missing
	MAYBE_SWAPs.
	(dw2_map_symbol_names): Likewise.
@
text
@d1918 4
a1921 9
  if (version == 1)
    {
      /* Index version 1 neglected to account for .debug_types.  So,
	 if we see .debug_types, we cannot use this index.  */
      if (dwarf2_per_objfile->types.asection != NULL
	  && dwarf2_per_objfile->types.size != 0)
	return 0;
    }
  else if (version != 2)
d1935 5
a1939 8
  if (version == 2)
    {
      types_list = addr + MAYBE_SWAP (metadata[i]);
      types_list_elements = ((MAYBE_SWAP (metadata[i + 1])
			      - MAYBE_SWAP (metadata[i]))
			     / 8);
      ++i;
    }
d1957 1
a1957 2
  if (version == 2
      && types_list_elements
d14915 1
d14918 2
a14919 1
		offset_type cu_index)
d14923 2
d14927 20
a14946 1
      add_index_entry (symtab, SYMBOL_NATURAL_NAME (*psymp), cu_index);
d14976 1
d14992 1
d14994 2
a14995 1
		  psymtab->n_global_syms, info->cu_index);
d14997 1
d14999 2
a15000 1
		  psymtab->n_static_syms, info->cu_index);
d15014 8
d15036 1
d15069 4
d15083 1
d15085 2
a15086 1
		      psymtab->n_global_syms, i);
d15088 1
d15090 2
a15091 1
		      psymtab->n_static_syms, i);
d15109 1
d15127 1
a15127 1
  val = MAYBE_SWAP (2);
d15184 3
a15186 4
   [0] The version number.  Currently 1 or 2.  The differences are
   noted below.  Version 1 did not account for .debug_types sections;
   the presence of a .debug_types section invalidates any version 1
   index that may exist.
d15188 6
a15193 7
   [1.5] In version 2, the offset, from the start of the file, of the
   types CU list.  This offset does not appear in version 1.  Note
   that this can be empty, in which case this offset will be equal to
   the next offset.
   [2] The offset, from the start of the file, of the address section.
   [3] The offset, from the start of the file, of the symbol table.
   [4] The offset, from the start of the file, of the constant pool.
d15204 5
a15208 5
   2.5 The types CU list.  This does not appear in a version 1 index.
   This is a sequence of triplets of 64-bit little-endian values.  In
   a triplet, the first value is the CU offset, the second value is
   the type offset in the CU, and the third value is the type
   signature.  The types CU list is not sorted.
d15210 1
a15210 1
   3. The address section.  The address section consists of a sequence
d15216 1
a15216 1
   4. The symbol table.  This is a hash table.  The size of the hash
d15238 1
a15238 1
   5. The constant pool.  This is simply a bunch of bytes.  It is
@


1.460
log
@gdb/
	* dwarf2read.c (die_needs_namespace) <DW_TAG_variable>: Add also
	DW_TAG_constant.

gdb/testsuite/
	* gdb.fortran/module.exp (fully qualified name of DW_TAG_constant):
	New test.
	* gdb.fortran/module.f90 (mod1) <var_const>: New constant.
@
text
@d2385 1
d2390 1
d2416 1
a2416 3
  for (iter = 0;
       iter < dwarf2_per_objfile->index_table->index_table_slots;
       ++iter)
d2422 1
a2422 2
      if (dwarf2_per_objfile->index_table->index_table[idx] == 0
	  && dwarf2_per_objfile->index_table->index_table[idx + 1] == 0)
d2425 1
a2425 2
      name = (dwarf2_per_objfile->index_table->constant_pool
	      + dwarf2_per_objfile->index_table->index_table[idx]);
d2432 2
a2433 2
      vec = (offset_type *) (dwarf2_per_objfile->index_table->constant_pool
			     + dwarf2_per_objfile->index_table->index_table[idx + 1]);
d2477 2
d2483 1
d2485 1
a2485 3
  for (iter = 0;
       iter < dwarf2_per_objfile->index_table->index_table_slots;
       ++iter)
d2491 1
a2491 2
      if (dwarf2_per_objfile->index_table->index_table[idx] == 0
	  && dwarf2_per_objfile->index_table->index_table[idx + 1] == 0)
d2494 1
a2494 2
      name = (dwarf2_per_objfile->index_table->constant_pool
	      + dwarf2_per_objfile->index_table->index_table[idx]);
@


1.459
log
@DWARF: Add support for DW_TAG_constant DIEs

gdb/ChangeLog:

        * dwarf2read.c (scan_partial_symbols): Add handling of
        DW_TAG_constant DIEs.
        (add_partial_symbol, load_partial_dies, new_symbol): Likewise.

gdb/testsuite/ChangeLog:

        * gdb.dwarf2/dw2-const.S, gdb.dwarf2/dw2-const.exp: New files.
@
text
@d4617 1
@


1.458
log
@	* dwarf2read.c (struct die_info): Fix comment.
@
text
@d3469 1
d3694 14
d8585 1
d8696 1
d10603 1
@


1.457
log
@gdb/
	* dwarf2read.c (dw2_map_ada_symtabs): Remove the internal_error.
	Update the comment.
@
text
@d672 1
a672 2
       together via their SIBLING fields, terminated by a die whose
       tag is zero.  */
@


1.456
log
@	* dwarf2read.c (fixup_partial_die): Do not set dummy name for
	anonymous class partial DIEs.
@
text
@d2372 3
a2374 4
  /* For now, we don't support Ada, so this function can't be
     reached.  */
  internal_error (__FILE__, __LINE__,
		  _("map_ada_symtabs called via index method"));
@


1.455
log
@	* dwarf2read.c (dwarf2_compute_name): Check that the first
	argument is a pointer.
@
text
@a9011 3
  if (part_die->name == NULL && (part_die->tag == DW_TAG_structure_type
				 || part_die->tag == DW_TAG_class_type))
    part_die->name = "(anonymous class)";
@


1.454
log
@	* dwarf2read.c (read_func_scope, read_structure_type)
	(read_common_block): Check for a NULL return from new_symbol.
@
text
@d4851 5
d4858 1
@


1.453
log
@gdb/
	* dwarf2read.c (dwarf2_read_index): Return on no SEC_HAS_CONTENTS.
@
text
@d5489 2
a5490 1
	      VEC_safe_push (symbolp, template_args, arg);
d6829 2
a6830 1
	      VEC_safe_push (symbolp, template_args, arg);
d7311 1
a7311 1
	  if (attr)
@


1.452
log
@	gdb/
	* dwarf2read.c (read_structure_type): Move processing of
	fields and member functions from here...
	(process_structure_scope): ... to here.

	gdb/testsuite/
	* gdb.cp/templates.cc (Empty, FunctionArg): New classes.
	(FunctionArg::method): New function.
	(empty, arg): New variables.
	(main): Call arg.method.
	* gdb.cp/templates.exp (test_template_args): New function.
	(do_tests): Call it.
@
text
@d1907 7
@


1.451
log
@	Revert:
	2010-09-01  Tom Tromey  <tromey@@redhat.com>
	* dwarf2read.c, gdbtypes.c, psymtab.c, symfile.h, symtab.c,
	symtab.h: Revert earlier change.
@
text
@d6646 3
a6648 2
   (definition) to process all dies that define the members of the
   structure or union.
d6650 2
a6651 2
   NOTE: we need to call struct_type regardless of whether or not the
   DIE has an at_name attribute, since it might be an anonymous
a6668 1
  struct cleanup *back_to;
a6689 2
  back_to = make_cleanup (null_cleanup, 0);

d6764 17
d6786 1
d6937 2
a6942 14
  do_cleanups (back_to);
  return type;
}

static void
process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *child_die = die->child;
  struct type *this_type;

  this_type = get_die_type (die, cu);
  if (this_type == NULL)
    this_type = read_structure_type (die, cu);

d6971 1
a6971 1
    new_symbol (die, this_type, cu);
@


1.450
log
@	* symtab.h (lookup_type_symbol): Declare.
	* symtab.c (lookup_symbol_in_language_full): Rename from
	lookup_symbol_in_language.  Add 'for_type' argument.
	(lookup_symbol_in_language): New function.
	(lookup_type_symbol): Likewise.
	(lookup_symbol_aux): Add 'for_type' argument.
	(match_symbol_aux): New function.
	(lookup_symbol_aux_symtabs): Use expand_one_symtab_matching.
	(match_transparent_type): New function.
	(basic_lookup_transparent_type): Use expand_one_symtab_matching.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: Remove.
	<expand_one_symtab_matching>: New field.
	* psymtab.c (expand_one_symtab_matching_psymtabs): New function.
	(pre_expand_symtabs_matching_psymtabs): Remove.
	(psym_functions): Update.
	* gdbtypes.c (lookup_typename): Use lookup_type_symbol.
	* dwarf2read.c (dw2_lookup_symbol): Update comment.
	(dw2_pre_expand_symtabs_matching): Remove.
	(dw2_expand_one_symtab_matching): New function.
	(dwarf2_gdb_index_functions): Update.
@
text
@d2201 1
a2201 1
  /* We do all the work in the expand_one_symtab_matching hook
d2232 4
a2235 10
static struct symbol *
dw2_expand_one_symtab_matching (struct objfile *objfile,
				int kind, const char *name,
				domain_enum domain,
				struct symbol *(*matcher) (struct symtab *,
							   int,
							   const char *,
							   domain_enum,
							   void *),
				void *data)
d2237 1
a2237 29
  dw2_setup (objfile);

  if (dwarf2_per_objfile->index_table)
    {
      offset_type *vec;

      if (find_slot_in_mapped_hash (dwarf2_per_objfile->index_table,
				    name, &vec))
	{
	  offset_type i, len = MAYBE_SWAP (*vec);
	  for (i = 0; i < len; ++i)
	    {
	      offset_type cu_index = MAYBE_SWAP (vec[i + 1]);
	      struct dwarf2_per_cu_data *cu = dw2_get_cu (cu_index);
	      struct symtab *symtab;
	      struct symbol *sym;

	      if (cu->v.quick->symtab)
		continue;

	      symtab = dw2_instantiate_symtab (objfile, cu);
	      sym = matcher (symtab, kind, name, domain, data);
	      if (sym)
		return sym;
	    }
	}
    }

  return NULL;
d2541 1
a2541 1
  dw2_expand_one_symtab_matching,
d6274 3
a6276 3
      /* We don't set TYPE_FIELD_IGNORE_BITS here.  The DWARF reader
	 never sets any bits in that array, so leaving it NULL lets us
	 save a little memory.  */
@


1.449
log
@	PR c++/11961:
	* dwarf2read.c (new_symbol_full) <DW_TAG_template_type_param>:
	Don't set TYPE_NAME on the type.
@
text
@d2201 1
a2201 1
  /* We do all the work in the pre_expand_symtabs_matching hook
d2232 10
a2241 4
static void
dw2_pre_expand_symtabs_matching (struct objfile *objfile,
				 int kind, const char *name,
				 domain_enum domain)
d2243 29
a2271 1
  dw2_do_expand_symtabs_matching (objfile, name);
d2575 1
a2575 1
  dw2_pre_expand_symtabs_matching,
@


1.448
log
@	* dwarf2read.c (dw2_require_line_header): Read from .debug_types
	as appropriate.
@
text
@a10731 1
	      }
d10733 14
a10746 12
	    /* The semantics of C++ state that "struct foo { ... }" also
	       defines a typedef for "foo".  A Java class declaration also
	       defines a typedef for the class.  */
	    if (cu->language == language_cplus
		|| cu->language == language_java
		|| cu->language == language_ada)
	      {
		/* The symbol's name is already allocated along with
		   this objfile, so we don't need to duplicate it for
		   the type.  */
		if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
		  TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_SEARCH_NAME (sym);
@


1.447
log
@	* dwarf2read.c (dwarf2_attach_fields_to_type): Don't set
	TYPE_FIELD_IGNORE_BITS.
@
text
@d1993 1
d2011 7
a2017 3
  dwarf2_read_section (objfile, &dwarf2_per_objfile->info);
  buffer_size = dwarf2_per_objfile->info.size;
  buffer = dwarf2_per_objfile->info.buffer;
@


1.446
log
@	* dwarf2read.c (dwarf2_per_objfile_free): Reorganize buffers to match
	the order they're defined in.  munmap .debug_types buffer.
@
text
@d6269 3
a6271 3
      TYPE_FIELD_IGNORE_BITS (type) =
	(B_TYPE *) TYPE_ALLOC (type, B_BYTES (nfields));
      B_CLRALL (TYPE_FIELD_IGNORE_BITS (type), nfields);
@


1.445
log
@	* dwarf2read.c (dw2_require_full_path): Rename parameter cu to per_cu.
	(dw2_forget_cached_source_info): Rename local cu to per_cu.
	(dw2_lookup_symtab, dw2_do_expand_symtabs_matching): Ditto.
	(dw2_print_stats, dw2_expand_all_symtabs): Ditto.
	(dw2_expand_symtabs_with_filename, dw2_find_symbol_file): Ditto.
	(dw2_find_symbol_file, dw2_expand_symtabs_matching): Ditto.
	(dw2_map_symbol_filenames, dwarf2_initialize_objfile): Ditto.
	(dwarf2_free_objfile, write_one_signatured_type): Ditto.
	(write_psymtabs_to_index): Ditto.
@
text
@d14548 2
d14553 2
a14555 1
  munmap_section_buffer (&data->macinfo);
d14557 1
a14557 1
  munmap_section_buffer (&data->loc);
@


1.444
log
@	* dwarf2read.c (dwarf2_build_include_psymtabs): Remove unnecessary
	forward decl.  Pass pst->dirname to dwarf_decode_lines.
	(psymtab_include_file_name): New function.
	(dwarf_decode_lines): Call it.  Update comments.
@
text
@d2067 1
a2067 1
		       struct dwarf2_per_cu_data *cu,
d2070 2
a2071 2
  if (!cu->v.quick->full_names)
    cu->v.quick->full_names
d2073 1
a2073 1
			cu->v.quick->lines->num_file_names,
d2076 3
a2078 3
  if (!cu->v.quick->full_names[index])
    cu->v.quick->full_names[index]
      = gdb_realpath (cu->v.quick->file_names[index]);
d2080 1
a2080 1
  return cu->v.quick->full_names[index];
d2101 1
a2101 1
      struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2103 1
a2103 1
      if (cu->v.quick->full_names)
d2107 2
a2108 2
	  for (j = 0; j < cu->v.quick->lines->num_file_names; ++j)
	    xfree ((void *) cu->v.quick->full_names[j]);
d2127 1
a2127 1
      struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2129 1
a2129 1
      if (cu->v.quick->symtab)
d2132 2
a2133 2
      dw2_require_line_header (objfile, cu);
      if (!cu->v.quick->lines)
d2136 1
a2136 1
      for (j = 0; j < cu->v.quick->lines->num_file_names; ++j)
d2138 1
a2138 1
	  const char *this_name = cu->v.quick->file_names[j];
d2142 1
a2142 1
	      *result = dw2_instantiate_symtab (objfile, cu);
d2148 1
a2148 1
	    base_cu = cu;
d2153 1
a2153 1
								  cu, j);
d2158 1
a2158 1
		  *result = dw2_instantiate_symtab (objfile, cu);
d2166 1
a2166 1
								  cu, j);
d2174 1
a2174 1
		      *result = dw2_instantiate_symtab (objfile, cu);
d2219 1
a2219 1
	      struct dwarf2_per_cu_data *cu = dw2_get_cu (cu_index);
d2221 1
a2221 1
	      dw2_instantiate_symtab (objfile, cu);
d2245 1
a2245 1
      struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2247 1
a2247 1
      if (!cu->v.quick->symtab)
d2283 1
a2283 1
      struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2285 1
a2285 1
      dw2_instantiate_symtab (objfile, cu);
d2300 1
a2300 1
      struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2302 1
a2302 1
      if (cu->v.quick->symtab)
d2305 2
a2306 2
      dw2_require_line_header (objfile, cu);
      if (!cu->v.quick->lines)
d2309 1
a2309 1
      for (j = 0; j < cu->v.quick->lines->num_file_names; ++j)
d2311 1
a2311 1
	  const char *this_name = cu->v.quick->file_names[j];
d2314 1
a2314 1
	      dw2_instantiate_symtab (objfile, cu);
d2324 1
a2324 1
  struct dwarf2_per_cu_data *cu;
d2341 1
a2341 1
  cu = dw2_get_cu (MAYBE_SWAP (vec[1]));
d2343 2
a2344 2
  dw2_require_line_header (objfile, cu);
  if (!cu->v.quick->lines)
d2347 1
a2347 1
  return cu->v.quick->file_names[cu->v.quick->lines->num_file_names - 1];
d2384 1
a2384 1
      struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2386 2
a2387 2
      cu->v.quick->mark = 0;
      if (cu->v.quick->symtab)
d2390 2
a2391 2
      dw2_require_line_header (objfile, cu);
      if (!cu->v.quick->lines)
d2394 1
a2394 1
      for (j = 0; j < cu->v.quick->lines->num_file_names; ++j)
d2396 1
a2396 1
	  if (file_matcher (cu->v.quick->file_names[j], data))
d2398 1
a2398 1
	      cu->v.quick->mark = 1;
d2429 1
a2429 1
	  struct dwarf2_per_cu_data *cu;
d2431 3
a2433 3
	  cu = dw2_get_cu (MAYBE_SWAP (vec[vec_idx + 1]));
	  if (cu->v.quick->mark)
	    dw2_instantiate_symtab (objfile, cu);
d2505 1
a2505 1
      struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2507 1
a2507 1
      if (cu->v.quick->symtab)
d2510 2
a2511 2
      dw2_require_line_header (objfile, cu);
      if (!cu->v.quick->lines)
d2514 1
a2514 1
      for (j = 0; j < cu->v.quick->lines->num_file_names; ++j)
d2516 3
a2518 2
	  const char *this_full_name = dw2_require_full_path (objfile, cu, j);
	  (*fun) (cu->v.quick->file_names[j], this_full_name, data);
d2572 1
a2572 1
	  struct dwarf2_per_cu_data *cu = dw2_get_cu (i);
d2574 2
a2575 2
	  cu->v.quick = OBSTACK_ZALLOC (&objfile->objfile_obstack,
					struct dwarf2_per_cu_quick_data);
d14266 2
a14267 1
	  struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d14269 1
a14269 1
	  if (!cu->v.quick->lines)
d14272 1
a14272 1
	  for (j = 0; j < cu->v.quick->lines->num_file_names; ++j)
d14274 4
a14277 4
	      if (cu->v.quick->file_names)
		xfree ((void *) cu->v.quick->file_names[j]);
	      if (cu->v.quick->full_names)
		xfree ((void *) cu->v.quick->full_names[j]);
d14280 1
a14280 1
	  free_line_header (cu->v.quick->lines);
d14933 2
a14934 2
  struct dwarf2_per_cu_data *cu = &entry->per_cu;
  struct partial_symtab *psymtab = cu->v.psymtab;
d15007 2
a15008 2
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
      struct partial_symtab *psymtab = cu->v.psymtab;
d15020 1
a15020 1
      store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, cu->offset);
d15022 1
a15022 1
      store_unsigned_integer (val, 8, BFD_ENDIAN_LITTLE, cu->length);
@


1.443
log
@	* dwarf2read.c (inherit_abstract_dies): Handle origin die's
	compilation unit being different from target die's.
@
text
@a874 4
static void dwarf2_build_include_psymtabs (struct dwarf2_cu *,
                                           struct die_info *,
                                           struct partial_symtab *);

d2762 2
a2763 1
  dwarf_decode_lines (lh, NULL, abfd, cu, pst);
d9912 77
a9994 2
      The compilation directory of the file is passed in COMP_DIR,
      and must not be NULL.
d9998 12
a10009 6
      builds all the associated partial symbol tables.  In this case,
      the value of COMP_DIR is ignored, and can thus be NULL (the COMP_DIR
      is not used to compute the full name of the symtab, and therefore
      omitting it when building the partial symtab does not introduce
      the potential for inconsistency - a partial symtab and its associated
      symbtab having a different fullname -).  */
d10292 3
a10294 23
            const struct file_entry fe = lh->file_names [file_index];
            char *include_name = fe.name;
            char *dir_name = NULL;
            char *pst_filename = pst->filename;

            if (fe.dir_index)
              dir_name = lh->include_dirs[fe.dir_index - 1];

            if (!IS_ABSOLUTE_PATH (include_name) && dir_name != NULL)
              {
                include_name = concat (dir_name, SLASH_STRING,
				       include_name, (char *)NULL);
                make_cleanup (xfree, include_name);
              }

            if (!IS_ABSOLUTE_PATH (pst_filename) && pst->dirname != NULL)
              {
                pst_filename = concat (pst->dirname, SLASH_STRING,
				       pst_filename, (char *)NULL);
                make_cleanup (xfree, pst_filename);
              }

            if (strcmp (include_name, pst_filename) != 0)
@


1.442
log
@	PR symtab/11942
	* dwarf2read.c (dwarf2_per_objfile): New members debug_info_type_hash,
	debug_types_type_hash.
	(dwarf2_cu, dwarf2_per_cu_data): Delete member type_hash.
	All uses updated.
	(lookup_die_type): Renamed from tag_type_to_tag.  First look in
	appropriate type_hash table.  All callers updated.
	(allocate_signatured_type_table): Renamed from
	allocate_signatured_type_hash_table.  All callers updated.
	(create_signatured_type_table_from_index): Renamed from
	create_signatured_type_hash_from_index.  All callers updated.
	(read_die_type): Add comment.  Move actual reading to ...
	(read_die_type_1): ... here.  New function.
	(follow_die_ref_or_sig): Tweak comment.
	(set_die_type): Rewrite to use appropriate choice of
	debug_info_type_hash or debug_types_type_hash.
	(get_die_type_at_offset): New function.
	(get_die_type): Call it.

	testsuite/
	PR symtab/11942
	* gdb.dwarf2/dw4-sig-types.cc: New file.
	* gdb.dwarf2/dw4-sig-types.h: New file.
	* gdb.dwarf2/dw4-sig-types-b.cc: New file.
	* gdb.dwarf2/dw4-sig-types.exp: New file.
@
text
@d5269 2
d5276 11
a5286 1
  origin_die = follow_die_ref (die, attr, &cu);
d5314 1
d5318 2
a5319 1
	  attr = dwarf2_attr (child_origin_die, DW_AT_abstract_origin, cu);
d5322 2
a5323 4
	  /* FIXME: cu becomes CU of child_origin_die.
	     What about the next iteration of the outer loop?
	     cu might then be bogus (won't be CU for child_die).  */
	  child_origin_die = follow_die_ref (child_origin_die, attr, &cu);
d5365 1
a5365 1
	  process_die (origin_child_die, cu);
d5369 1
@


1.441
log
@	* dwarf2read.c (set_die_type): Fix typo in comment.
@
text
@d216 10
a357 5
  /* Pointer to the die -> type map.  Although it is stored
     permanently in per_cu, we copy it here to avoid double
     indirection.  */
  htab_t type_hash;

a452 6
  /* If full symbols for this CU have been read in, then this field
     holds a map of DIE offsets to types.  It isn't always possible
     to reconstruct this information later, so we have to preserve
     it.  */
  htab_t type_hash;

d1041 2
a1042 1
static struct type *tag_type_to_type (struct die_info *, struct dwarf2_cu *);
d1046 2
d1270 3
d1298 1
a1298 1
static htab_t allocate_signatured_type_hash_table (struct objfile *objfile);
d1752 1
d1754 3
a1756 3
create_signatured_type_hash_from_index (struct objfile *objfile,
					const gdb_byte *bytes,
					offset_type elements)
d1759 1
a1759 1
  htab_t type_hash;
d1767 1
a1767 1
  type_hash = allocate_signatured_type_hash_table (objfile);
d1793 1
a1793 1
      slot = htab_find_slot (type_hash, type_sig, INSERT);
d1799 1
a1799 1
  dwarf2_per_objfile->signatured_types = type_hash;
d1965 2
a1966 2
      && !create_signatured_type_hash_from_index (objfile, types_list,
						  types_list_elements))
d2792 1
a2792 1
allocate_signatured_type_hash_table (struct objfile *objfile)
d2837 1
a2837 1
  types_htab = allocate_signatured_type_hash_table (objfile);
a3318 1
      cu->type_hash = this_cu->type_hash;
a4339 1
      cu->type_hash = per_cu->type_hash;
d5308 3
a10914 1

a10920 1
  struct die_info *type_die;
d10929 1
a10929 3
  type_die = follow_die_ref_or_sig (die, type_attr, &cu);

  return tag_type_to_type (type_die, cu);
a10949 1

a10957 1
  struct die_info *type_die;
d10963 1
a10963 2
  type_die = follow_die_ref (die, type_attr, &cu);
  return tag_type_to_type (type_die, cu);
a10988 1
  struct die_info *type_die;
d10995 1
a10995 2
  type_die = follow_die_ref_or_sig (die, type_attr, &cu);
  return tag_type_to_type (type_die, cu);
d10998 3
d11002 2
a11003 1
tag_type_to_type (struct die_info *die, struct dwarf2_cu *cu)
d11007 48
a11054 2
  this_type = read_type_die (die, cu);
  if (!this_type)
d11069 1
d11073 8
d11090 11
d12727 3
a12729 2
   On entry *REF_CU is the CU of source DIE referencing OFFSET.
   On exit *REF_CU is the CU of the result.  */
d14267 2
d14283 6
a14288 1
  if (cu->type_hash == NULL)
d14290 2
a14291 3
      gdb_assert (cu->per_cu != NULL);
      cu->per_cu->type_hash
	= htab_create_alloc_ex (cu->header.length / 24,
d14295 1
a14295 1
				&cu->objfile->objfile_obstack,
a14297 1
      cu->type_hash = cu->per_cu->type_hash;
d14303 1
a14303 1
    htab_find_slot_with_hash (cu->type_hash, &ofs, ofs.offset, INSERT);
d14308 1
a14308 1
  *slot = obstack_alloc (&cu->objfile->objfile_obstack, sizeof (**slot));
d14313 2
a14314 2
/* Find the type for DIE in CU's type_hash, or return NULL if DIE does
   not have a saved type.  */
d14317 2
a14318 1
get_die_type (struct die_info *die, struct dwarf2_cu *cu)
d14321 1
a14321 1
  htab_t type_hash = cu->type_hash;
d14323 4
d14330 1
a14330 1
  ofs.offset = die->offset;
d14338 9
@


1.440
log
@	* dwarf2read.c (read_structure_type): Add comment.
	(read_enumeration_type): Add comment.
	(process_enumeration_scope): Move definition of some locals
	closer to their use.
	(read_namespace_type): Add comment.
@
text
@d14190 1
a14190 1
     * After building typer call set_die_type for current DIE as soon as
@


1.439
log
@	PR symtab/11465:
 	* dwarf2read.c (struct delayed_method_info): New struct.
	(struct dwarf2_cu): Add vector method_list.
	(scan_partial_symbols): Count methods for union, class, structure,
	and interface types.
	(add_to_method_list): New function.
	(free_delayed_list): New function.
	(compute_delayed_physnames): New function.
	(process_full_comp_unit): Make a cleanup for the CU's delayed
	physname list, compute the delayed physnames, and free the
	the list.
	(dwarf2_add_member_fn): For C++ and Java, delay the computation
	of the physname until after the CU is read.

	* dwarf2read.c (read_structure_type): Check if the current
	DIE's type was already completed after dwarf2_full_name
	was called.
@
text
@d6661 3
d6968 3
a7010 6
  struct die_info *child_die;
  struct field *fields;
  struct symbol *sym;
  int num_fields;
  int unsigned_enum = 1;
  char *name;
a7012 2
  num_fields = 0;
  fields = NULL;
d7016 1
d7019 7
d7314 3
@


1.438
log
@	* gdb_assert.h (gdb_assert_not_reached): New macro.
	(gdb_assert_fail): Fix typo in comment.
	* avr-tdep.c (avr_return_value): Use gdb_assert_not_reached instead of
	gdb_assert (0).
	* darwin-nat.c (darwin_check_new_threads): Ditto.
	* dwarf2read.c (dwarf2_get_section_info): Ditto.
	(munmap_section_buffer): Ditto.
	* m32c-tdep.c (make_types): Ditto.
	(m32c_decode_srcdest4, m32c_decode_sd23, m32c_frame_base): Ditto.
	* macroexp.c (get_character_constant): Ditto.
	(get_string_literal): Ditto.
	* mep-tdep.c (mep_pseudo_cr_size): Ditto.
	(mep_pseudo_cr_index, mep_register_type): Ditto.
	(mep_pseudo_register_read, mep_pseudo_register_write): Ditto.
	(mep_get_insn, mep_analyze_prologue): Ditto.
	* objfiles.c (qsort_cmp): Ditto.
	* prologue-value.c (pv_is_identical): Ditto.
	* record.c (record_get_loc): Ditto.
	* value.c (value_static_field): Ditto.
	* xtensa-tdep.c (call0_track_op): Ditto.
@
text
@d269 23
d370 4
d1319 3
d4375 50
d4435 1
a4435 1
  struct cleanup *back_to;
d4442 1
d4451 6
a6338 1
  char *physname;
a6349 3
  /* Get the mangled name.  */
  physname = (char *) dwarf2_physname (fieldname, die, cu);

d6375 1
a6375 1
      fip->nfnfields++;
d6389 13
a6401 3
  /* The name is already allocated along with this objfile, so we don't
     need to duplicate it for the type.  */
  fnp->physname = physname ? physname : "";
d6427 1
a6427 1
	       physname);
d6675 8
a6682 1
	  TYPE_TAG_NAME (type) = (char *) dwarf2_full_name (name, die, cu);
@


1.437
log
@2010-08-13  Hui Zhu  <teawater@@gmail.com>

	* dwarf2read.c (load_partial_comp_unit): Initialize free_cu_cleanup.
	(read_comp_unit): Initialize back_to.
@
text
@d1588 1
a1588 1
    gdb_assert (0);
d14266 1
a14266 1
      gdb_assert (0);
@


1.436
log
@2010-08-12  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* dwarf2read.c: Include "c-lang.h" and "valprint.h".
	(struct dwarf2_per_objfile) <reading_partial_symbols>: New field.
	(struct partial_die_info) <has_template_arguments>: New field.
	<num_attrs>: Change type to unsigned char.
	<building_fullname>: New field.
	(dwarf2_build_psymtabs_hard): Set reading_partial_symbols.  Only
	allocate a CU if we don't have one already.  Add a cleanup for the
	CU.
	(partial_die_full_name): Handle template arguments not in
	DW_AT_name.
	(dwarf2_psymtab_to_symtab): Clear reading_partial_symbols.
	(load_full_comp_unit): Only allocate a CU if we don't have one
	already.
	(do_ui_file_peek_last): New.
	(dwarf2_compute_name): Handle template parameters not in
	DW_AT_name.
	(read_comp_unit): Read and free abbrevs if not read yet.
	(load_partial_dies): Handle template arguments not in DW_AT_name.
	(find_partial_die): If we have a CU, but no a partial dies yet,
	also read in the CU.
	(dwarf2_const_value_attr): New, abstracted out from
	dwarf2_const_value.
	(dwarf2_const_value, dwarf2_const_value_data): Adjust to use
	dwarf2_const_value_attr.
	(determine_prefix): Detect and break loops created by RCVT's debug
	info.
	(maybe_queue_comp_unit): Bail out early if reading partial
	symbols.
	(follow_die_offset): Load full CU if we have no dies.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Make public.
	* dwarf2loc.h (dwarf2_evaluate_loc_desc): Declare.
@
text
@d3250 1
a3250 1
  struct cleanup *free_abbrevs_cleanup, *free_cu_cleanup;
d7977 1
a7977 1
  struct cleanup *back_to;
@


1.435
log
@Complete symbol construction before adding to pending list.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* dwarf2read.c (new_symbol): Add symbol to variable list at end of
	function after symbol construction is complete.
	Do the same for template symbol addition to template_symbols list.
@
text
@d58 2
d212 4
d551 3
d631 5
a635 1
    unsigned short num_attrs;
d995 7
a1001 3
static void dwarf2_const_value_data (struct attribute *attr,
				     struct symbol *sym,
				     int bits);
d1111 4
d3185 2
d3250 1
a3250 1
  struct cleanup *back_to;
d3254 1
d3262 5
a3266 1
  cu = alloc_one_comp_unit (objfile);
d3268 2
a3269 1
  /* ??? Missing cleanup for CU?  */
d3271 13
a3283 9
  /* Link this compilation unit into the compilation unit tree.  */
  this_cu->cu = cu;
  cu->per_cu = this_cu;
  cu->type_hash = this_cu->type_hash;

  info_ptr = partial_read_comp_unit_head (&cu->header, info_ptr,
					  dwarf2_per_objfile->info.buffer,
					  dwarf2_per_objfile->info.size,
					  abfd);
d3285 9
a3293 3
  /* Complete the cu_header.  */
  cu->header.offset = this_cu->offset;
  cu->header.first_die_offset = info_ptr - beg_of_comp_unit;
d3296 1
d3298 1
a3298 1
  back_to = make_cleanup (dwarf2_free_abbrev_table, cu);
d3318 8
a3325 1
  do_cleanups (back_to);
d3571 23
d4136 2
d4269 1
a4269 1
  struct cleanup *back_to, *free_cu_cleanup;
d4271 1
d4282 8
a4289 1
  cu = alloc_one_comp_unit (objfile);
d4291 2
a4292 2
  /* If an error occurs while loading, release our storage.  */
  free_cu_cleanup = make_cleanup (free_one_comp_unit, cu);
d4294 3
a4296 2
  /* Read in the comp_unit header.  */
  info_ptr = read_comp_unit_head (&cu->header, info_ptr, abfd);
d4298 3
a4300 3
  /* Complete the cu_header.  */
  cu->header.offset = offset;
  cu->header.first_die_offset = info_ptr - beg_of_comp_unit;
d4302 4
a4305 3
  /* Read the abbrevs for this compilation unit.  */
  dwarf2_read_abbrevs (abfd, cu);
  back_to = make_cleanup (dwarf2_free_abbrev_table, cu);
d4307 9
a4315 4
  /* Link this compilation unit into the compilation unit tree.  */
  per_cu->cu = cu;
  cu->per_cu = per_cu;
  cu->type_hash = per_cu->type_hash;
d4335 3
a4337 3
  /* Link this CU into read_in_chain.  */
  per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
  dwarf2_per_objfile->read_in_chain = per_cu;
d4339 4
a4342 5
  do_cleanups (back_to);

  /* We've successfully allocated this compilation unit.  Let our caller
     clean it up when finished with it.  */
  discard_cleanups (free_cu_cleanup);
d4535 11
d4605 124
d7976 10
d7999 6
a8004 1
  return read_die_and_children (&reader_specs, info_ptr, &info_ptr, NULL);
d8386 29
d8548 5
a8552 2
	 languages we have to, both so that we can get at method physnames
	 to infer fully qualified class names, and for DW_AT_specification.
d8563 4
d8783 2
a8784 6
  if (per_cu->cu == NULL)
    {
      load_partial_comp_unit (per_cu, cu->objfile);
      per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = per_cu;
    }
d10624 40
a10663 1
/* Copy constant value from an attribute to a symbol.  */
d10666 5
a10670 2
dwarf2_const_value (struct attribute *attr, struct symbol *sym,
		    struct dwarf2_cu *cu)
a10673 2
  enum bfd_endian byte_order = bfd_big_endian (objfile->obfd) ?
				BFD_ENDIAN_BIG : BFD_ENDIAN_LITTLE;
d10675 6
a10685 1
	struct dwarf2_locexpr_baton *baton;
d10688 2
a10689 2
	if (TYPE_LENGTH (SYMBOL_TYPE (sym)) != cu_header->addr_size)
	  dwarf2_const_value_length_mismatch_complaint (SYMBOL_PRINT_NAME (sym),
d10691 1
a10691 2
							TYPE_LENGTH (SYMBOL_TYPE
								     (sym)));
d10695 8
a10702 8
	baton = obstack_alloc (&objfile->objfile_obstack,
			       sizeof (struct dwarf2_locexpr_baton));
	baton->per_cu = cu->per_cu;
	gdb_assert (baton->per_cu);

	baton->size = 2 + cu_header->addr_size;
	data = obstack_alloc (&objfile->objfile_obstack, baton->size);
	baton->data = data;
a10707 4

	SYMBOL_COMPUTED_OPS (sym) = &dwarf2_locexpr_funcs;
	SYMBOL_LOCATION_BATON (sym) = baton;
	SYMBOL_CLASS (sym) = LOC_COMPUTED;
d10712 3
a10714 4
      /* DW_STRING is already allocated on the obstack, point directly
	 to it.  */
      SYMBOL_VALUE_BYTES (sym) = (gdb_byte *) DW_STRING (attr);
      SYMBOL_CLASS (sym) = LOC_CONST_BYTES;
d10722 4
a10725 9
      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) != blk->size)
	dwarf2_const_value_length_mismatch_complaint (SYMBOL_PRINT_NAME (sym),
						      blk->size,
						      TYPE_LENGTH (SYMBOL_TYPE
								   (sym)));
      SYMBOL_VALUE_BYTES (sym) =
	obstack_alloc (&objfile->objfile_obstack, blk->size);
      memcpy (SYMBOL_VALUE_BYTES (sym), blk->data, blk->size);
      SYMBOL_CLASS (sym) = LOC_CONST_BYTES;
d10734 1
a10734 1
      dwarf2_const_value_data (attr, sym, 8);
d10737 1
a10737 1
      dwarf2_const_value_data (attr, sym, 16);
d10740 1
a10740 1
      dwarf2_const_value_data (attr, sym, 32);
d10743 1
a10743 1
      dwarf2_const_value_data (attr, sym, 64);
d10747 1
a10747 2
      SYMBOL_VALUE (sym) = DW_SND (attr);
      SYMBOL_CLASS (sym) = LOC_CONST;
d10751 1
a10751 2
      SYMBOL_VALUE (sym) = DW_UNSND (attr);
      SYMBOL_CLASS (sym) = LOC_CONST;
d10758 1
a10758 2
      SYMBOL_VALUE (sym) = 0;
      SYMBOL_CLASS (sym) = LOC_CONST;
d10764 2
a10765 7
/* Given an attr with a DW_FORM_dataN value in host byte order,
   zero-extend it as appropriate for the symbol's type.  The DWARF
   standard (v4) is not entirely clear about the meaning of using
   DW_FORM_dataN for a constant with a signed type, where the type is
   wider than the data.  The conclusion of a discussion on the DWARF
   list was that this is unspecified.  We choose to always zero-extend
   because that is the interpretation long in use by GCC.  */
d10767 2
a10768 3
dwarf2_const_value_data (struct attribute *attr,
			 struct symbol *sym,
			 int bits)
d10770 10
a10779 1
  LONGEST l = DW_UNSND (attr);
d10781 16
a10796 5
  if (bits < sizeof (l) * 8)
    l &= ((LONGEST) 1 << bits) - 1;

  SYMBOL_VALUE (sym) = l;
  SYMBOL_CLASS (sym) = LOC_CONST;
d11049 42
d12493 10
d12561 2
a12569 1
      target_cu = cu;
d12583 6
a12588 2
  else
    target_cu = cu;
@


1.434
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d9999 2
d10093 1
a10093 1
	      add_symbol_to_list (sym, &global_symbols);
d10097 1
a10097 1
	      add_symbol_to_list (sym, cu->list_in_scope);
d10134 1
a10134 6
	      if (suppress_add)
		{
		  sym->hash_next = objfile->template_symbols;
		  objfile->template_symbols = sym;
		}
	      else
d10137 1
a10137 1
		    add_symbol_to_list (sym, &global_symbols);
d10139 1
a10139 1
		    add_symbol_to_list (sym, cu->list_in_scope);
a10158 2
		  struct pending **list_to_add;

a10176 1
		  add_symbol_to_list (sym, list_to_add);
d10179 1
a10179 1
		add_symbol_to_list (sym, cu->list_in_scope);
a10192 2
		  struct pending **list_to_add;

a10198 7
		  if (suppress_add)
		    {
		      sym->hash_next = objfile->template_symbols;
		      objfile->template_symbols = sym;
		    }
		  else
		    add_symbol_to_list (sym, list_to_add);
d10204 2
a10205 7
		  if (suppress_add)
		    {
		      sym->hash_next = objfile->template_symbols;
		      objfile->template_symbols = sym;
		    }
		  else
		    add_symbol_to_list (sym, cu->list_in_scope);
d10237 1
a10237 1
	  add_symbol_to_list (sym, cu->list_in_scope);
d10265 1
a10265 6
	    if (suppress_add)
	      {
		sym->hash_next = objfile->template_symbols;
		objfile->template_symbols = sym;
	      }
	    else
a10266 2
		struct pending **list_to_add;

a10270 2

		add_symbol_to_list (sym, list_to_add);
d10291 1
a10291 1
	  add_symbol_to_list (sym, cu->list_in_scope);
d10297 1
a10297 1
	  add_symbol_to_list (sym, cu->list_in_scope);
a10308 2
	    struct pending **list_to_add;

a10312 2

	    add_symbol_to_list (sym, list_to_add);
d10317 1
a10317 1
	  add_symbol_to_list (sym, &global_symbols);
d10329 10
@


1.433
log
@	* dwarf2read.c (dwarf_attr_name): Add DW_AT_GNU_odr_signature.
@
text
@d10016 1
a10016 1
      SYMBOL_LANGUAGE (sym) = cu->language;
@


1.432
log
@	* dwarf2read.c (dwarf2_const_value_data): Never sign extend.
@
text
@d11382 2
@


1.431
log
@2010-07-28  Daniel Jacobowitz  <dan@@codesourcery.com>

	gdb/
	* dwarf2read.c (read_subroutine_type): Improve THIS detection,
	handling DW_AT_object_pointer, and workaround GCC PR 43053.

	gdb/testsuite/
	* gdb.cp/member-ptr.exp, gdb.cp/printmethod.exp,
	gdb.dwarf2/member-ptr-forwardref.exp: Adjust.
@
text
@d10488 7
a10494 2
/* Given an attr with a DW_FORM_dataN value in host byte order, sign-
   or zero-extend it as appropriate for the symbol's type.  */
d10503 1
a10503 6
    {
      if (TYPE_UNSIGNED (SYMBOL_TYPE (sym)))
	l &= ((LONGEST) 1 << bits) - 1;
      else
	l = (l << (sizeof (l) * 8 - bits)) >> (sizeof (l) * 8 - bits);
    }
@


1.430
log
@gdb
	PR c++/9946:
	* symfile.c (reread_symbols): Clear template_symbols.
	* symtab.h (struct symbol) <is_cplus_template_function>: New
	field.
	(SYMBOL_IS_CPLUS_TEMPLATE_FUNCTION): New macro.
	(struct template_symbol): New.
	* symtab.c (lookup_symbol_aux_local): Use
	cp_lookup_symbol_imports_or_template.
	* objfiles.h (struct objfile) <template_symbols>: New field.
	* objfiles.c (relocate_one_symbol): New function.
	(objfile_relocate1): Use it.  Relocate isolated symbols.
	* gdbtypes.h (struct cplus_struct_type) <n_template_arguments,
	template_arguments>: New fields.
	(TYPE_N_TEMPLATE_ARGUMENTS): New macro.
	(TYPE_TEMPLATE_ARGUMENTS): Likewise.
	(TYPE_TEMPLATE_ARGUMENT): Likewise.
	(lookup_typename): Update.
	* gdbtypes.c (lookup_typename): Constify "block" argument.
	* dwarf2read.c: Include vec.h.
	(symbolp): New typedef.
	(read_func_scope): Read template arguments.  Allocate a
	template_symbol when needed.
	(read_structure_type): Read template arguments.
	(new_symbol_full): New function, from new_symbol.  Handle
	DW_TAG_template_type_param and DW_TAG_template_value_param.
	(new_symbol): Rewrite as wrapper.
	* cp-support.h (cp_lookup_symbol_imports_or_template): Declare.
	* cp-namespace.c: Include language.h.
	(search_symbol_list): New function.
	(cp_lookup_symbol_imports_or_template): Likewise.
gdb/testsuite
	PR c++/9946:
	* gdb.cp/temargs.exp: New file.
	* gdb.cp/temargs.cc: New file.
@
text
@d7398 11
a7408 5
	      /* Dwarf2 has no clean way to discern C++ static and non-static
	         member functions. G++ helps GDB by marking the first
	         parameter for non-static member functions (which is the
	         this pointer) as artificial. We pass this information
	         to dwarf2_add_member_fn via TYPE_FIELD_ARTIFICIAL.  */
d7426 34
a7459 1
	      TYPE_FIELD_TYPE (ftype, iparams) = die_type (child_die, cu);
@


1.429
log
@	* dwarf2read.c (read_string): Rename to ...
	(read_direct_string): ... this.
	(skip_one_die, read_attribute_value, dwarf_decode_line_header)
	(dwarf_decode_lines, dwarf_decode_macros): Adjust.
@
text
@d57 1
d73 3
d976 3
d5059 2
d5106 14
d5121 2
a5122 1
  new->name = new_symbol (die, read_type_die (die, cu), cu);
d5146 9
a5154 1
	  process_die (child_die, cu);
d5200 16
d6423 1
d6453 8
d6464 17
d6603 3
a6605 1
	  || child_die->tag == DW_TAG_inheritance)
d9946 3
a9948 1
   used the passed type.  */
d9951 2
a9952 1
new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu)
d9968 1
d9970 4
a9973 2
      sym = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
					     sizeof (struct symbol));
a9974 1
      memset (sym, 0, sizeof (struct symbol));
d10067 3
d10093 5
a10097 2
	      if (attr2 && (DW_UNSND (attr2) != 0))
		add_symbol_to_list (sym, &global_symbols);
d10099 6
a10104 1
		add_symbol_to_list (sym, cu->list_in_scope);
d10168 7
a10174 1
		  add_symbol_to_list (sym, list_to_add);
d10180 7
a10186 1
		  add_symbol_to_list (sym, cu->list_in_scope);
d10225 3
d10246 8
a10253 1
	    struct pending **list_to_add;
d10255 4
a10258 4
	    list_to_add = (cu->list_in_scope == &file_symbols
			   && (cu->language == language_cplus
			       || cu->language == language_java)
			   ? &global_symbols : cu->list_in_scope);
d10260 2
a10261 1
	    add_symbol_to_list (sym, list_to_add);
d10332 8
@


1.428
log
@ARI fix (trailing newline in warning message).

        * dwarf2read.c (dw2_find_pc_sect_symtab): Remove trailing newline
        in warning message.
@
text
@d926 1
a926 1
static char *read_string (bfd *, gdb_byte *, unsigned int *);
d3952 1
a3952 1
	  read_string (abfd, info_ptr, &bytes_read);
d8549 1
a8549 1
      DW_STRING (attr) = read_string (abfd, info_ptr, &bytes_read);
d8897 1
a8897 1
read_string (bfd *abfd, gdb_byte *buf, unsigned int *bytes_read_ptr)
d9323 1
a9323 1
  while ((cur_dir = read_string (abfd, line_ptr, &bytes_read)) != NULL)
d9331 1
a9331 1
  while ((cur_file = read_string (abfd, line_ptr, &bytes_read)) != NULL)
d9538 1
a9538 1
                    cur_file = read_string (abfd, line_ptr, &bytes_read);
d12882 1
a12882 1
	    read_string (abfd, mac_ptr, &bytes_read);
d12913 1
a12913 1
	    read_string (abfd, mac_ptr, &bytes_read);
d12968 1
a12968 1
            body = read_string (abfd, mac_ptr, &bytes_read);
d13074 1
a13074 1
            string = read_string (abfd, mac_ptr, &bytes_read);
@


1.427
log
@* valops.c (dwarf2_read_index): Initialize the types_list and types_list_elements variables.
@
text
@d2397 1
a2397 1
    warning (_("(Internal error: pc %s in read in CU, but not in symtab.)\n"),
@


1.426
log
@gdb/
	* dwarf2read.c (add_partial_symbol): Do not add a global variable if
	its adress is null. Add comment to explain why.
	(new_symbol): Ditto.
@
text
@d1838 4
a1841 2
  const gdb_byte *cu_list, *types_list;
  offset_type version, cu_list_elements, types_list_elements;
@


1.425
log
@	* dwarf2read.c (struct dwarf2_per_objfile) <n_type_comp_units,
	type_comp_units>: New fields.
	(dw2_get_cu): New function.
	(create_cus_from_index): Remove unused argument.
	(create_signatured_type_hash_from_index): New function.
	(create_addrmap_from_index): Update.
	(dwarf2_read_index): Handle version 2.
	(dw2_find_last_source_symtab, dw2_forget_cached_source_info)
	(dw2_lookup_symtab, dw2_do_expand_symtabs_matching)
	(dw2_print_stats, dw2_expand_all_symtabs)
	(dw2_expand_symtabs_with_filename, dw2_find_symbol_file)
	(dw2_expand_symtabs_matching, dw2_map_symbol_filenames): Update.
	(dwarf2_initialize_objfile): Call create_debug_types_hash_table.
	(allocate_signatured_type_hash_table): New function.
	(add_signatured_type_cu_to_list): Likewise.
	(create_debug_types_hash_table): Use them.  Set type_comp_units.
	(read_signatured_type): Ensure section data is available.
	(add_address_entry): Don't record empty ranges.
	(struct signatured_type_index_data): New.
	(write_one_signatured_type): New function.
	(write_psymtabs_to_index): Write type CUs.
	(save_gdb_index_command): Update comment.
	(process_type_comp_unit): Move inititalization of
	from_debug_types...
	(create_debug_types_hash_table): ... here.
@
text
@d3572 13
a3584 1
      if (pdi->is_external)
a3598 2
	  if (pdi->locdesc)
	    addr = decode_locdesc (pdi->locdesc, cu);
a3615 1
	  addr = decode_locdesc (pdi->locdesc, cu);
d10018 10
a10027 1
	      if (attr2 && (DW_UNSND (attr2) != 0))
@


1.424
log
@	* dwarf2read.c: Remove unused typedef dwarf2_cu_per_cu_data_ptr
	and vector definition.
@
text
@d183 6
d1199 2
d1238 2
d1616 12
d1654 2
a1655 2
create_cus_from_index (struct objfile *objfile, struct mapped_index *index,
		       const gdb_byte *cu_list, offset_type cu_list_elements)
a1657 1
  const char *entry;
d1688 52
d1771 1
a1771 1
			 dwarf2_per_objfile->all_comp_units[cu_index]);
d1838 3
a1840 2
  const gdb_byte *cu_list;
  offset_type cu_list_elements;
d1849 10
a1858 1
  if (MAYBE_SWAP (*(offset_type *) addr) != 1)
d1865 4
a1868 2
  cu_list = addr + MAYBE_SWAP (metadata[0]);
  cu_list_elements = ((MAYBE_SWAP (metadata[1]) - MAYBE_SWAP (metadata[0]))
d1870 19
a1888 6
  map->address_table = addr + MAYBE_SWAP (metadata[1]);
  map->address_table_size = (MAYBE_SWAP (metadata[2])
			     - MAYBE_SWAP (metadata[1]));
  map->index_table = (offset_type *) (addr + MAYBE_SWAP (metadata[2]));
  map->index_table_slots = ((MAYBE_SWAP (metadata[3])
			     - MAYBE_SWAP (metadata[2]))
d1890 1
a1890 1
  map->constant_pool = addr + MAYBE_SWAP (metadata[3]);
d1892 9
a1900 1
  if (!create_cus_from_index (objfile, map, cu_list, cu_list_elements))
d2027 1
a2027 2
  return dw2_instantiate_symtab (objfile,
				 dwarf2_per_objfile->all_comp_units[index]);
d2036 2
a2037 1
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2039 1
a2039 1
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2061 2
a2062 1
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2065 1
a2065 1
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2157 2
a2158 2
	      struct dwarf2_per_cu_data *cu;
	      cu = dwarf2_per_objfile->all_comp_units[cu_index];
d2180 2
a2181 1
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2183 1
a2183 1
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2217 3
a2219 1
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2221 1
a2221 1
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2234 2
a2235 1
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2238 1
a2238 1
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2279 1
a2279 1
  cu = dwarf2_per_objfile->all_comp_units[MAYBE_SWAP (vec[1])];
d2318 2
a2319 1
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2322 1
a2322 1
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2367 3
a2369 2
	  struct dwarf2_per_cu_data *cu
	    = dwarf2_per_objfile->all_comp_units[MAYBE_SWAP (vec[vec_idx + 1])];
d2439 2
a2440 1
  for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2443 1
a2443 1
      struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2504 1
d2506 2
a2507 1
      for (i = 0; i < dwarf2_per_objfile->n_comp_units; ++i)
d2509 1
a2509 1
	  struct dwarf2_per_cu_data *cu = dwarf2_per_objfile->all_comp_units[i];
d2723 28
d2760 1
d2771 1
a2771 7
  types_htab = htab_create_alloc_ex (41,
				     hash_type_signature,
				     eq_type_signature,
				     NULL,
				     &objfile->objfile_obstack,
				     hashtab_obstack_allocate,
				     dummy_obstack_deallocate);
d2819 1
d2834 10
a3111 1
  this_cu->from_debug_types = 1;
d12219 1
a12219 1
  gdb_byte *types_ptr = dwarf2_per_objfile->types.buffer + type_sig->offset;
d12226 3
d14067 4
d14116 39
d14161 2
a14162 1
  struct obstack contents, addr_obstack, constant_pool, symtab_obstack, cu_list;
d14198 6
d14225 13
d14246 1
a14246 1
  size_of_contents = 5 * sizeof (offset_type);
d14250 1
a14250 1
  val = MAYBE_SWAP (1);
d14258 5
d14282 1
d14307 4
a14310 1
   [0] The version number.  Currently 1.
d14312 4
d14321 13
a14333 5
   little-endian values.  The first element in each pair is the offset
   of a CU in the .debug_info section.  The second element in each
   pair is the length of that CU.  References to a CU elsewhere in the
   map are done using a CU index, which is just the 0-based index into
   this table.
@


1.423
log
@gdb/
	* dwarf2read.c: Include completer.h.
	(save_gdb_index_command): Use matching usage command name.
	(_initialize_dwarf2_read): New variable c, initialize it by add_cmd.
	Set filename_completer for it.
@
text
@a158 3
typedef struct dwarf2_per_cu_data *dwarf2_per_cu_data_ptr;
DEF_VEC_P (dwarf2_per_cu_data_ptr);

@


1.422
log
@	* dwarf2read.c (create_debug_types_hash_table): Set objfile on
	type signature's per-CU data.
@
text
@d56 1
d14139 1
a14139 1
    error (_("usage: maintenance save-gdb-index DIRECTORY"));
d14184 2
d14234 4
a14237 3
  add_cmd ("gdb-index", class_files, save_gdb_index_command,
	   _("Save a .gdb-index file"),
	   &save_cmdlist);
@


1.421
log
@gdb/
2010-07-21  Pedro Alves  <pedro@@codesourcery.com>

	PR symtab/11827

	Revert:
	2010-05-21  Pierre Muller  <muller@@ics.u-strasbg.fr>
	* dwarf2read.c (process_die): Also allow DW_TAG_const_type
	and DW_TAG_volatile_type.
	(new_symbol): Likewise.

gdb/testsuite/
2010-07-21  Pedro Alves  <pedro@@codesourcery.com>

	PR symtab/11827

	* gdb.base/printcmds.c (enum some_volatile_enum): New enum.
	(some_volatile_enum): New variable.
	* gdb.base/printcmds.exp (test_print_enums): New.
	<top level>: Call it.
@
text
@d2681 1
@


1.420
log
@Use allocated cplus_specific for cplus symbols.

2010-07-16  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h (symbol_set_demangled_name): Now takes an optional objfile*
	argument.
	(cplus_specific): New struct.
	* symtab.c (symbol_set_demangled_name): Updated.
	Use cplus_specific for cplus symbols.
	(symbol_get_demangled_name): Retrive the name from the cplus_specific
	struct for cplus symbols.
	(symbol_init_language_specific): Set cplus_specific for cplus symbols.
	(symbol_set_names): Pass objfile to symbol_set_demangled_name.
	* symtab.c (symbol_init_cplus_specific): New function.
@
text
@a4194 2
    case DW_TAG_const_type:
    case DW_TAG_volatile_type:
a10001 2
        case DW_TAG_const_type:
        case DW_TAG_volatile_type:
@


1.419
log
@Use setter and getter for demangled_name.

2010-07-16  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h (symbol_set_demangled_name): New function.
	(symbol_get_demangled_name): New function.
	* symtab.c (symbol_set_demangled_name): New function.
	(symbol_get_demangled_name): New function.
	(symbol_init_language_specific): Use demangled_name setter and getter.
	(symbol_set_names): Ditto.
	(symbol_natural_name): Ditto.
	(symbol_demangled_name): Ditto.
	* dwarf2read.c (new_symbol): Ditto.
@
text
@d9747 3
a9749 1
	symbol_set_demangled_name (&(sym->ginfo), (char *) dwarf2_full_name (name, die, cu));
@


1.418
log
@Rename cplus_specific mangled_lang.

2010-07-16  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed cplus_specific to mangled_lang.
	* symtab.c (symbol_init_language_specific): Updated.
	(symbol_set_names): Updated.
	(symbol_natural_name): Updated.
	(symbol_demangled_name): Updated.
	* ada-lang.c (ada_decode_symbol): Updated.
	* dwarf2read.c (new_symbol): Updated.
@
text
@d9746 2
a9747 3
          && sym->ginfo.language_specific.mangled_lang.demangled_name == NULL)
	sym->ginfo.language_specific.mangled_lang.demangled_name
	  = (char *) dwarf2_full_name (name, die, cu);
@


1.417
log
@	* dwarf2read.c (dwarf2_read_index): Correctly set 'total_size'.
@
text
@d9746 2
a9747 2
          && sym->ginfo.language_specific.cplus_specific.demangled_name == NULL)
	sym->ginfo.language_specific.cplus_specific.demangled_name
@


1.416
log
@	* dwarf2read.c (dwarf2_per_cu_text_offset): Fix reference to
	objfile.
@
text
@a1763 2
  struct stat st, obstat;
  int fd;
d1766 1
a1766 2
  offset_type val, *metadata;
  char buf1[8], buf2[8];
d1781 1
a1781 1
  map->total_size = st.st_size;
@


1.415
log
@	* symfile.c (set_initial_language): Update.
	(deduce_language_from_filename): Argument type now const.
	* symtab.h (find_main_filename): Update.
	(deduce_language_from_filename): Update.
	* symtab.c (find_main_filename): Make result const.
	* dwarf2read.c (dw2_find_symbol_file): Change return type.
	* psymtab.c (find_symbol_file_from_partial): Change return type.
	* symfile.h (struct quick_symbol_functions) <find_symbol_file>:
	Make result const.
@
text
@d13111 1
a13111 1
  struct objfile *objfile = per_cu->psymtab->objfile;
@


1.414
log
@gdb
	* breakpoint.c (save_cmdlist): No longer static.
	* gdbcmd.h (save_cmdlist): Declare.
	* symfile.c (symbol_file_add_with_addrs_or_offsets): Set
	OBJF_READNOW on objfile if readnow_symbol_files.
	* elfread.c (elf_symfile_read): Use dwarf2_initialize_objfile.
	(elf_sym_fns_gdb_index): New global.
	* dwarf2read.c: Include exceptions.h.
	(offset_type): New.
	(struct mapped_index): New.
	(dwarf2_per_cu_data_ptr): New typedef.
	(struct dwarf2_per_objfile) <using_index, index_table, gdb_index>:
	New fields.
	(GDB_INDEX_SECTION): New define.
	(struct dwarf2_per_cu_quick_data): New.
	(struct dwarf2_per_cu_data) <objfile>: New field.
	<psymtab>: Removed.
	<v>: New field.
	(byte_swap): New function.
	(MAYBE_SWAP): New macro.
	(INDEX_SUFFIX): New macro.
	(dw2_do_instantiate_symtab): New function.
	(dw2_instantiate_symtab): Likewise.
	(create_cus_from_index): Likewise.
	(create_addrmap_from_index): Likewise.
	(mapped_index_string_hash): Likewise.
	(find_slot_in_mapped_hash): Likewise.
	(dwarf2_read_index): Likewise.
	(dw2_setup): Likewise.
	(dw2_require_line_header): Likewise.
	(dw2_require_full_path): Likewise.
	(dw2_find_last_source_symtab): Likewise.
	(dw2_forget_cached_source_info): Likewise.
	(dw2_lookup_symtab): Likewise.
	(dw2_lookup_symbol): Likewise.
	(dw2_do_expand_symtabs_matching): Likewise.
	(dw2_pre_expand_symtabs_matching): Likewise.
	(dw2_print_stats): Likewise.
	(dw2_dump): Likewise.
	(dw2_relocate): Likewise.
	(dw2_expand_symtabs_for_function): Likewise.
	(dw2_expand_all_symtabs): Likewise.
	(dw2_expand_symtabs_with_filename): Likewise.
	(dw2_find_symbol_file): Likewise.
	(dw2_map_ada_symtabs): Likewise.
	(dw2_expand_symtabs_matching): Likewise.
	(dw2_find_pc_sect_symtab): Likewise.
	(dw2_map_symbol_names): Likewise.
	(dw2_map_symbol_filenames): Likewise.
	(dw2_has_symbols): Likewise.
	(dwarf2_gdb_index_functions): New global.
	(dwarf2_initialize_objfile): New function.
	(process_psymtab_comp_unit): Update.
	(add_partial_subprogram): Likewise.
	(dwarf2_psymtab_to_symtab): Likewise.
	(psymtab_to_symtab_1): Use dw2_do_instantiate_symtab.
	(process_full_comp_unit): Update.
	(find_file_and_directory): New function.
	(read_file_scope): Use find_file_and_directory.
	(dwarf2_per_cu_objfile): Update.
	(dwarf2_per_cu_addr_size): Update.
	(dwarf2_per_cu_offset_size): Update.
	(dwarf2_free_objfile): Free the index, if needed.
	(dwarf2_per_objfile_free): Unmap the index, if needed.
	(struct strtab_entry): New.
	(hash_strtab_entry): New function.
	(eq_strtab_entry): Likewise.
	(create_strtab): Likewise.
	(add_string): Likewise.
	(struct symtab_index_entry): New.
	(struct mapped_symtab): New.
	(hash_symtab_entry): New function.
	(eq_symtab_entry): Likewise.
	(delete_symtab_entry): Likewise.
	(create_index_table): Likewise.
	(create_mapped_symtab): Likewise.
	(cleanup_mapped_symtab): Likewise.
	(find_slot): Likewise.
	(hash_expand): Likewise.
	(add_index_entry): Likewise.
	(add_indices_to_cpool): Likewise.
	(write_hash_table): Likewise.
	(add_address_entry): Likewise.
	(write_psymbols): Likewise.
	(write_obstack): Likewise.
	(unlink_if_set): Likewise.
	(write_psymtabs_to_index): Likewise.
	(save_gdb_index_command): Likewise.
	(_initialize_dwarf2_read): Install "save gdb-index"
	command.
	(create_all_comp_units): Initialize 'objfile' field of CU.
	(dwarf2_locate_sections): Check for .gdb_index.
	* psymtab.h (dwarf2_gdb_index_functions): Declare.
	* symfile.h (dwarf2_initialize_objfile): Declare.
gdb/doc
	* gdb.texinfo (Index Files): New node.
@
text
@d2153 1
a2153 1
static char *
d2179 1
a2179 2
  return (char *) cu->v.quick->file_names[cu->v.quick->lines->num_file_names
					  - 1];
@


1.413
log
@gdb
	PR breakpoints/8357:
	* symtab.h (domain_enum_tag) <LABEL_DOMAIN>: Update comment.
	* linespec.c (decode_line_1): Update comment.  Call decode_label.
	(decode_label): New function.
	(symbol_found): Handle LOC_LABEL.
	* dwarf2read.c (new_symbol) <DW_TAG_label>: Set symbol's type and
	domain.  Call add_symbol_to_list.
gdb/doc
	* gdb.texinfo (Specify Location): Document labels.
gdb/testsuite
	* gdb.base/label.exp: New file.
	* gdb.base/label.c: New file.
@
text
@d54 2
d134 27
d173 1
d196 6
d221 1
d347 26
d413 15
a427 4
  /* The partial symbol table associated with this compilation unit,
     or NULL for partial units (which do not have an associated
     symtab).  */
  struct partial_symtab *psymtab;
d1209 47
d1354 5
d1563 857
d2883 1
a2883 1
  this_cu->psymtab = pst;
d3168 1
d3600 1
a3600 1
				 cu->per_cu->psymtab);
a3871 1
  /* FIXME: This is barely more than a stub.  */
d3944 3
a3946 1
      if (item->per_cu->psymtab && !item->per_cu->psymtab->readin)
d4023 1
a4023 16
  back_to = make_cleanup (dwarf2_release_queue, NULL);

  queue_comp_unit (per_cu, pst->objfile);

  if (per_cu->from_debug_types)
    read_signatured_type_at_offset (pst->objfile, per_cu->offset);
  else
    load_full_comp_unit (per_cu, pst->objfile);

  process_queue (pst->objfile);

  /* Age the cache, releasing compilation units that have not
     been used recently.  */
  age_cached_comp_units ();

  do_cleanups (back_to);
a4102 1
  struct partial_symtab *pst = per_cu->psymtab;
d4104 1
a4104 1
  struct objfile *objfile = pst->objfile;
d4137 9
a4145 2
  pst->symtab = symtab;
  pst->readin = 1;
d4538 40
d4603 1
a4603 29
  /* Find the filename.  Do not use dwarf2_name here, since the filename
     is not a source language identifier.  */
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr)
    {
      name = DW_STRING (attr);
    }

  attr = dwarf2_attr (die, DW_AT_comp_dir, cu);
  if (attr)
    comp_dir = DW_STRING (attr);
  else if (name != NULL && IS_ABSOLUTE_PATH (name))
    {
      comp_dir = ldirname (name);
      if (comp_dir != NULL)
	make_cleanup (xfree, comp_dir);
    }
  if (comp_dir != NULL)
    {
      /* Irix 6.2 native cc prepends <machine>.: to the compilation
	 directory, get rid of it.  */
      char *cp = strchr (comp_dir, ':');

      if (cp && cp != comp_dir && cp[-1] == '.' && cp[1] == '/')
	comp_dir = cp + 1;
    }

  if (name == NULL)
    name = "<unknown>";
d13050 1
a13050 1
  struct objfile *objfile = per_cu->psymtab->objfile;
d13070 1
a13070 1
      struct objfile *objfile = per_cu->psymtab->objfile;
d13092 1
a13092 1
      struct objfile *objfile = per_cu->psymtab->objfile;
d13334 24
d13612 557
d14171 2
d14236 4
@


1.412
log
@	* dwarf2loc.h (dwarf2_per_cu_text_offset): Declare.
	* dwarf2loc.c (find_location_expression): Use
	dwarf2_per_cu_text_offset.
	(dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax): Likewise.
	(loclist_describe_location): Likewise.
	* dwarf2read.c (dwarf2_per_cu_text_offset): New function.
	(dwarf2_per_cu_objfile): Update comment.
@
text
@d8810 2
d8813 1
@


1.411
log
@gdb/
	* dwarf2read.c (read_subrange_type): Call read_subrange_type.
	* p-lang.c (pascal_printstr): Likewise.
@
text
@d12052 3
a12054 1
/* Return the OBJFILE associated with the compilation unit CU.  */
d12113 13
@


1.410
log
@	* dwarf2read.c (dwarf2_const_value) <DW_form_addr>: Create a
	LOC_COMPUTED symbol.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Set new field.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax) <DW_OP_addr>: Use offset.
	* dwarf2expr.h (struct dwarf_expr_context) <offset>: New field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_addr>: Use offset.
	* dwarf2-frame.c (execute_stack_op): Set 'offset' field.  Add
	'offset' argument.
	(struct dwarf2_frame_cache) <text_offset>: New field.
	(dwarf2_frame_cache): Set new field.
	(dwarf2_frame_prev_register): Update.
	(dwarf2_frame_sniffer): Update.
	(dwarf2_frame_base_sniffer): Update.
	(dwarf2_frame_find_fde): Add 'out_offset' argument.
@
text
@d6335 2
@


1.409
log
@	PR gdb/11702
	* dwarf2read.c (dwarf2_add_field): Only create a symbol if
	DW_AT_external is present.
@
text
@d9078 30
a9107 12
      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) != cu_header->addr_size)
	dwarf2_const_value_length_mismatch_complaint (SYMBOL_PRINT_NAME (sym),
						      cu_header->addr_size,
						      TYPE_LENGTH (SYMBOL_TYPE
								   (sym)));
      SYMBOL_VALUE_BYTES (sym) =
	obstack_alloc (&objfile->objfile_obstack, cu_header->addr_size);
      /* NOTE: cagney/2003-05-09: In-lined store_address call with
         it's body - store_unsigned_integer.  */
      store_unsigned_integer (SYMBOL_VALUE_BYTES (sym), cu_header->addr_size,
			      byte_order, DW_ADDR (attr));
      SYMBOL_CLASS (sym) = LOC_CONST_BYTES;
@


1.409.2.1
log
@	* dwarf2read.c (dwarf2_const_value) <DW_form_addr>: Create a
	LOC_COMPUTED symbol.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Set new field.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax) <DW_OP_addr>: Use offset.
	* dwarf2expr.h (struct dwarf_expr_context) <offset>: New field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_addr>: Use offset.
	* dwarf2-frame.c (execute_stack_op): Set 'offset' field.  Add
	'offset' argument.
	(struct dwarf2_frame_cache) <text_offset>: New field.
	(dwarf2_frame_cache): Set new field.
	(dwarf2_frame_prev_register): Update.
	(dwarf2_frame_sniffer): Update.
	(dwarf2_frame_base_sniffer): Update.
	(dwarf2_frame_find_fde): Add 'out_offset' argument.
@
text
@d9078 12
a9089 30
      {
	struct dwarf2_locexpr_baton *baton;
	gdb_byte *data;

	if (TYPE_LENGTH (SYMBOL_TYPE (sym)) != cu_header->addr_size)
	  dwarf2_const_value_length_mismatch_complaint (SYMBOL_PRINT_NAME (sym),
							cu_header->addr_size,
							TYPE_LENGTH (SYMBOL_TYPE
								     (sym)));
	/* Symbols of this form are reasonably rare, so we just
	   piggyback on the existing location code rather than writing
	   a new implementation of symbol_computed_ops.  */
	baton = obstack_alloc (&objfile->objfile_obstack,
			       sizeof (struct dwarf2_locexpr_baton));
	baton->per_cu = cu->per_cu;
	gdb_assert (baton->per_cu);

	baton->size = 2 + cu_header->addr_size;
	data = obstack_alloc (&objfile->objfile_obstack, baton->size);
	baton->data = data;

	data[0] = DW_OP_addr;
	store_unsigned_integer (&data[1], cu_header->addr_size,
				byte_order, DW_ADDR (attr));
	data[cu_header->addr_size + 1] = DW_OP_stack_value;

	SYMBOL_COMPUTED_OPS (sym) = &dwarf2_locexpr_funcs;
	SYMBOL_LOCATION_BATON (sym) = baton;
	SYMBOL_CLASS (sym) = LOC_COMPUTED;
      }
@


1.409.2.2
log
@	* dwarf2loc.h (dwarf2_per_cu_text_offset): Declare.
	* dwarf2loc.c (find_location_expression): Use
	dwarf2_per_cu_text_offset.
	(dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax): Likewise.
	(loclist_describe_location): Likewise.
	* dwarf2read.c (dwarf2_per_cu_text_offset): New function.
	(dwarf2_per_cu_objfile): Update comment.
@
text
@d12050 1
a12050 3
/* Return the OBJFILE associated with the compilation unit CU.  If CU
   came from a separate debuginfo file, then the master objfile is
   returned.  */
a12108 13
/* Return the text offset of the CU.  The returned offset comes from
   this CU's objfile.  If this objfile came from a separate debuginfo
   file, then the offset may be different from the corresponding
   offset in the parent objfile.  */

CORE_ADDR
dwarf2_per_cu_text_offset (struct dwarf2_per_cu_data *per_cu)
{
  struct objfile *objfile = per_cu->psymtab->objfile;

  return ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
}

@


1.409.2.3
log
@gdb/
2010-07-21  Pedro Alves  <pedro@@codesourcery.com>

	PR symtab/11827

	Revert:
	2010-05-21  Pierre Muller  <muller@@ics.u-strasbg.fr>
	* dwarf2read.c (process_die): Also allow DW_TAG_const_type
	and DW_TAG_volatile_type.
	(new_symbol): Likewise.

gdb/testsuite/
2010-07-21  Pedro Alves  <pedro@@codesourcery.com>

	PR symtab/11827

	* gdb.base/printcmds.c (enum some_volatile_enum): New enum.
	(some_volatile_enum): New variable.
	* gdb.base/printcmds.exp (test_print_enums): New.
	<top level>: Call it.
@
text
@d3223 2
d9014 2
@


1.409.2.4
log
@	* dwarf2read.c (dwarf2_per_objfile_free): Reorganize buffers to match
	the order they're defined in.  munmap .debug_types buffer.
@
text
@a12581 2
  /* This is sorted according to the order they're defined in to make it easier
     to keep in sync.  */
d12585 1
a12585 1
  munmap_section_buffer (&data->loc);
a12586 1
  munmap_section_buffer (&data->str);
d12588 1
a12588 1
  munmap_section_buffer (&data->types);
@


1.409.2.5
log
@	* dwarf2read.c (dwarf2_const_value_data): Never sign extend.
@
text
@d9168 2
a9169 7
/* Given an attr with a DW_FORM_dataN value in host byte order,
   zero-extend it as appropriate for the symbol's type.  The DWARF
   standard (v4) is not entirely clear about the meaning of using
   DW_FORM_dataN for a constant with a signed type, where the type is
   wider than the data.  The conclusion of a discussion on the DWARF
   list was that this is unspecified.  We choose to always zero-extend
   because that is the interpretation long in use by GCC.  */
d9178 6
a9183 1
    l &= ((LONGEST) 1 << bits) - 1;
@


1.408
log
@	PR c++/11702
	* NEWS: Add entry.
	* dwarf2read.c (dwarf2_add_field): If DW_AT_const_value is present,
	create a symbol for the field and record the value.
	(new_symbol): Handle DW_TAG_member.
	* gdbtypes.c (field_is_static): Remove FIXME.
	* symtab.c (search_symbols): When searching for VARIABLES_DOMAIN,
	only ignore LOC_CONST symbols that are enums.

	testsuite/
	Test PR c++/11702.
	* gdb.cp/m-static.exp: Add testcase.
	* gdb.cp/m-static.h (gnu_obj_4): Add initialized static const member.
@
text
@a4530 5
  /* NOTE: According to the dwarf standard, static data members are
     indicated by having DW_AT_external.
     The check here for ! die_is_declaration is historical.
     This test is replicated in new_symbol.  */

d4647 6
a4652 1
      if (attr)
d8853 2
a8854 4
	      /* NOTE: This test seems wrong according to the dwarf standard.
		 static data members are represented by DW_AT_external.
		 However, dwarf2_add_field is currently calling
		 die_is_declaration to check, so we do the same.  */
@


1.407
log
@	* dwarf2read.c: Remove trailing whitespace.
@
text
@d4531 5
d4651 8
d8840 1
d8849 11
@


1.406
log
@gdb/
	* dwarf2read.c (read_structure_type) <fi.typedef_field_list>: Call
	ALLOCATE_CPLUS_STRUCT_TYPE.
@
text
@d919 1
a919 1
static char *typename_concat (struct obstack *obs, const char *prefix, 
d978 1
a978 1
static enum dwarf_array_dim_ordering read_array_order (struct die_info *, 
d1536 1
a1536 1
  dwarf2_read_section (dwarf2_per_objfile->objfile, 
d2165 1
a2165 1
  
d2338 1
a2338 1
      && parent->tag == DW_TAG_namespace 
d2587 1
a2587 1
   
d2626 1
a2626 1
  
d3374 1
a3374 1
	  
d3575 1
a3575 1
  
d3624 1
a3624 1
  if (attr) 
d3726 1
a3726 1
  if (attr) 
d4026 1
a4026 1
  
d4058 1
a4058 1
     be nasty.  Might be easier to properly extend generic blocks to 
d4311 1
a4311 1
     
d4473 2
a4474 2
              record_block_range (block, 
                                  baseaddr + base + start, 
d4486 1
a4486 1
{ 
d4534 1
a4534 1
      
d4638 1
a4638 1
      
d4686 1
a4686 1
{ 
d5339 1
a5339 1
	      
d5612 1
a5612 1
  
d5625 1
a5625 1
read_array_order (struct die_info *die, struct dwarf2_cu *cu) 
d5635 1
a5635 1
    opposite order to the dwarf2 specification, but data is still 
d5638 1
a5638 1
    FIXME: dsl/2004-8-20: If G77 is ever fixed, this will also need 
d5648 1
a5648 1
  switch (cu->language_defn->la_array_ordering) 
d5811 1
a5811 1
      
d5941 1
a5941 1
      else 
d6131 1
a6131 1
  
d6276 1
a6276 1
	if (cu->language == language_ada || cu->language == language_m2 
d6329 1
a6329 1
    { 
d6343 1
a6343 1
    {       
d6411 1
a6411 1
  negative_mask = 
d6429 1
a6429 1
  
d6441 1
a6441 1
  
d6682 1
a6682 1
  
d7631 1
a7631 1
     
d8038 1
a8038 1
 
d8073 1
a8073 1
 
d8116 1
a8116 1
  lh->total_length = 
d8190 1
a8190 1
  lh->statement_program_start = line_ptr; 
d8255 1
a8255 1
   
d8325 1
a8325 1
	    {		
d8381 1
a8381 1
                    
d8966 1
a8966 1
	  
d9013 1
a9013 1
	  
d9060 1
a9060 1
      SYMBOL_VALUE_BYTES (sym) = 
d11379 1
a11379 1
  
d11415 1
a11415 1
      complaint (&symfile_complaints, 
d11447 1
a11447 1
              
d11504 1
a11504 1
     the space when the macro's definition is the empty string. 
d11533 1
a11533 1
      
d11591 1
a11591 1
                                   argc, (const char **) argv, 
d11598 1
a11598 1
                                     argc, (const char **) argv, 
d11779 2
a11780 2
			   macinfo_type == DW_MACINFO_define ? 
			     _("definition") : 
d11791 1
a11791 1
			   _("definition") : 
d12003 1
a12003 1
      
d12499 1
a12499 1
{ 
@


1.405
log
@gdb/
	* c-typeprint.c (c_type_print_base): For no fields check include also
	TYPE_TYPEDEF_FIELD_COUNT.  Print new typedefs section.
	* dwarf2read.c (struct typedef_field_list)
	(struct field_info) <typedef_field_list, typedef_field_list_count>: New.
	(dwarf2_add_typedef): New.
	(read_structure_type): Call dwarf2_add_typedef for DW_TAG_typedef.
	Copy also FI.TYPEDEF_FIELD_LIST.
	* gdbtypes.h (struct typedef_field)
	(struct cplus_struct_type) <typedef_field, typedef_field_count>
	(TYPE_TYPEDEF_FIELD_ARRAY, TYPE_TYPEDEF_FIELD, TYPE_TYPEDEF_FIELD_NAME)
	(TYPE_TYPEDEF_FIELD_TYPE, TYPE_TYPEDEF_FIELD_COUNT): New.

gdb/testsuite/
	* gdb.cp/namespace.exp (ptype OtherFileClass typedefs)
	(ptype ::C::OtherFileClass typedefs): New.
	* gdb.cp/namespace1.cc (C::OtherFileClass::cOtherFileClassType2)
	(C::OtherFileClass::cOtherFileClassVar2): New.
	(C::OtherFileClass::cOtherFileClassVar_use): Use also
	cOtherFileClassVar2.
	(C::cOtherFileType2, C::cOtherFileVar2): New.
	(C::cOtherFileVar_use): use also cOtherFileVar2.
	* gdb.cp/userdef.exp (ptype &*c): Permit arbitrary trailing text.
@
text
@d5330 1
@


1.404
log
@gdb/
	Fix modification of cplus_struct_default.
	* dwarf2read.c (dwarf2_add_member_fn) <no DW_AT_vtable_elem_location>:
	Call ALLOCATE_CPLUS_STRUCT_TYPE.
	* gdbtypes.c (cplus_struct_default): New empty initializer, comment it.

gdb/testsuite/
	* gdb.cp/virtbase.cc (class RTTI_base, class RTTI_data)
	(main) <rtti_data>: New.
	* gdb.cp/virtbase.exp (print rtti_data): New.
@
text
@d648 10
d4681 33
d5248 2
d5323 22
@


1.403
log
@	* dwarf2read.c (read_structure_type): Allocate null cleanup later.
@
text
@d4957 1
@


1.402
log
@	* dwarf2read.c (read_base_type): Handle DW_ATE_UTF.
	(dwarf_type_encoding_name): Likewise.
@
text
@d5085 1
a5085 1
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
d5104 2
@


1.401
log
@	* p-valprint.c (pascal_val_print): Use TYPE_ERROR_NAME.
	* p-typeprint.c (pascal_type_print_base): Use TYPE_ERROR_NAME.
	* m2-valprint.c (m2_val_print): Use TYPE_ERROR_NAME.
	* gdbtypes.h (TYPE_ERROR_NAME): New macro.
	* f-valprint.c (f_val_print): Use TYPE_ERROR_NAME.
	* f-typeprint.c (f_type_print_base): Use TYPE_ERROR_NAME.
	* dwarf2read.c (tag_type_to_type): Create a new error type on
	failure.
	* c-valprint.c (c_val_print): Use TYPE_ERROR_NAME.
	* c-typeprint.c (c_type_print_base): Use TYPE_ERROR_NAME.
@
text
@d6215 5
d10410 3
@


1.400
log
@Minor reformatting in dwarf2read.c:psymtabs_addrmap_cleanup.

Really a tiny insignificant detail that just happened to catch my attention.
Fixed thusly.

2010-06-17  Joel Brobecker  <brobecker@@adacore.com>

        * dwarf2read.c (psymtabs_addrmap_cleanup): Add empty line after
        last local variable declaration.  No real code change.
@
text
@d9176 12
a9187 3
      dump_die_for_error (die);
      error (_("Dwarf Error: Cannot find type of die [in module %s]"), 
	     cu->objfile->name);
@


1.399
log
@	* dwarf2read.c (psymtabs_addrmap_cleanup): New function.
	(dwarf2_build_psymtabs_hard): Use it.  Create addrmap on a
	temporary obstack.
@
text
@d2004 1
@


1.398
log
@	* dwarf2read.c (dwarf2_add_member_fn): Handle correct form of
	DW_AT_vtable_elem_location even when GCC extension is seen.
@
text
@d1998 9
d2014 2
a2015 1
  struct cleanup *back_to;
d2028 6
a2033 2
  objfile->psymtabs_addrmap =
    addrmap_create_mutable (&objfile->objfile_obstack);
d2065 1
@


1.397
log
@gdb/
	Fix PR 10640.
	* dwarf2-frame.c (no_dwarf_call): New function.
	(execute_stack_op): Set CTX->DWARF_CALL.
	* dwarf2expr.c (execute_stack_op) <DW_OP_call2, DW_OP_call4>: New.
	* dwarf2expr.h (struct dwarf_expr_context) <dwarf_call>: New.
	(struct dwarf_expr_context) <get_subr>: Remove the #if0-ed field.
	* dwarf2loc.c (per_cu_dwarf_call, dwarf_expr_dwarf_call): New functions.
	(dwarf2_evaluate_loc_desc): Initialize CTX->DWARF_CALL.
	(needs_frame_dwarf_call): New function.
	(dwarf2_loc_desc_needs_frame): Initialize CTX->DWARF_CALL.
	* dwarf2read.c (follow_die_offset): Based on former follow_die_ref.
	Update the comment.  Move variables die, offset and error call to ...
	(follow_die_ref): ... a new function.
	(dwarf2_fetch_die_location_block): New function.
	* dwarf2loc.h (dwarf2_fetch_die_location_block): New prototype.

gdb/testsuite/
	Test PR 10640.
	* gdb.dwarf2/dw2-op-call.exp, gdb.dwarf2/dw2-op-call.S: New.
@
text
@d4882 3
a4884 3
     function.  For GCC, this is an offset in the appropriate
     virtual table, as specified by DW_AT_containing_type.  For
     everyone else, it is an expression to be evaluated relative
d4888 1
a4888 1
  if (attr && fnp->fcontext)
d4890 1
a4890 2
      /* Support the .debug_loc offsets */
      if (attr_form_is_block (attr))
d4892 30
a4921 2
          fnp->voffset = decode_locdesc (DW_BLOCK (attr), cu) + 2;
        }
a4931 22
  else if (attr)
    {
      /* We only support trivial expressions here.  This hack will work
	 for v3 classes, which always start with the vtable pointer.  */
      if (attr_form_is_block (attr) && DW_BLOCK (attr)->size > 0
	  && DW_BLOCK (attr)->data[0] == DW_OP_deref)
	{
	  struct dwarf_block blk;

	  blk.size = DW_BLOCK (attr)->size - 1;
	  blk.data = DW_BLOCK (attr)->data + 1;
	  fnp->voffset = decode_locdesc (&blk, cu);
	  if ((fnp->voffset % cu->header.addr_size) != 0)
	    dwarf2_complex_location_expr_complaint ();
	  else
	    fnp->voffset /= cu->header.addr_size;
	  fnp->voffset += 2;
	  fnp->fcontext = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (this_type, 0));
	}
      else
	dwarf2_complex_location_expr_complaint ();
    }
@


1.396
log
@gdb/
	* dwarf2loc.c (struct dwarf_expr_baton) Replace objfile by per_cu.
	(dwarf_expr_tls_address): Use per_cu instead of objfile.
	(dwarf2_evaluate_loc_desc): Drop initialization of BATON.OBJFILE.
	Initialize new BATON.PER_CU.  Adjust CTX->GDBARCH initialization for
	this change.
	(struct needs_frame_baton): New field per_cu.
	(dwarf2_loc_desc_needs_frame): Initialize new BATON.PER_CU.
	* dwarf2read.c (struct dwarf2_per_cu_data) <cu>: Extend the comment.
@
text
@d10739 2
a10740 2
/* Follow reference attribute ATTR of SRC_DIE.
   On entry *REF_CU is the CU of SRC_DIE.
d10744 1
a10744 2
follow_die_ref (struct die_info *src_die, struct attribute *attr,
		struct dwarf2_cu **ref_cu)
a10745 2
  struct die_info *die;
  unsigned int offset;
a10750 2
  offset = dwarf2_get_ref_die_offset (attr);

d10757 1
a10757 1
	goto not_found;
d10777 45
a10821 3
  die = htab_find_with_hash (target_cu->die_hash, &temp_die, offset);
  if (die)
    return die;
d10823 9
a10831 1
 not_found:
d10833 5
a10837 3
  error (_("Dwarf Error: Cannot find DIE at 0x%x referenced from DIE "
	 "at 0x%x [in module %s]"),
	 offset, src_die->offset, cu->objfile->name);
@


1.395
log
@gdb/
	Fix duplicate types for single DIE.
	* dwarf2read.c (read_structure_type): Move set_descriptive_type after
	set_die_type.
	(read_array_type): Remove type initialization.  Recheck get_die_type
	after initial die_type.  Move set_die_type before set_descriptive_type.
	(read_set_type): New variable domain_type.  Recheck get_die_type after
	initial die_type.  Move attr initialization later.
	(read_tag_pointer_type, read_tag_reference_type): New variable
	target_type.  Recheck get_die_type after initial die_type.
	(read_tag_ptr_to_member_type): Recheck get_die_type after initial
	die_type and die_containing_type.
	(read_tag_const_type, read_tag_volatile_type, read_subroutine_type):
	Recheck get_die_type after initial die_type.
	(read_subrange_type): Recheck get_die_type after initial die_type.
	Move set_die_type before set_descriptive_type.
	(set_die_type): Extend the function comment.  Call complaint if DIE has
	some type already set.
@
text
@d340 2
a341 1
  /* Set iff currently read in.  */
@


1.394
log
@Remove redundant naming of symbol from new_symbol.

2010-06-03  Sami Wagiaalla  <swagiaal@@redhat.com>

	* dwarf2read.c (new_symbol): Remove redundant naming of symbol.
@
text
@a5140 2
  set_descriptive_type (type, die, cu);

d5146 3
d5437 1
a5437 1
  struct type *type = NULL;
d5447 5
d5520 4
d5528 1
a5528 2
  /* Install the type in the die. */
  return set_die_type (die, type, cu);
d5571 2
a5572 2
  struct type *set_type = create_set_type (NULL, die_type (die, cu));
  struct attribute *attr = dwarf2_attr (die, DW_AT_byte_size, cu);
d5574 10
d5586 1
d5806 8
d5815 1
a5815 1
  type = lookup_pointer_type (die_type (die, cu));
d5871 5
d5891 1
a5891 1
  struct type *type;
d5894 8
a5901 1
  type = lookup_reference_type (die_type (die, cu));
d5920 6
d5936 6
d6006 6
d6225 5
d6336 3
d6341 1
a6341 1
  return set_die_type (die, range_type, cu);
d12163 16
a12178 1
   table if necessary.  For convenience, return TYPE.  */
d12216 4
@


1.393
log
@gdb/
	Support DW_TAG_module as separate namespaces.
	* dwarf2read.c (typename_concat): New parameter physname.
	(read_module_type): New function and declaration.
	(scan_partial_symbols): Scan also DW_TAG_module children.
	(partial_die_parent_scope): Accept scope even from DW_TAG_module. Pass
	to typename_concat backward compatible physname value 0.
	(partial_die_full_name, read_namespace_type): Pass to typename_concat
	backward compatible physname value 0.
	(add_partial_module, read_module): Remove FIXME comment.
	(process_die) <DW_TAG_module>: Set PROCESSING_HAS_NAMESPACE_INFO.
	(die_needs_namespace) <DW_TAG_variable>: Allow returning true even for
	DIEs under DW_TAG_module.
	(dwarf2_compute_name): Move the ada block for DW_AT_linkage_name and
	DW_AT_MIPS_linkage_name first, extend it for language_fortran
	&& physname and return there instead of just setting NAME.  Extend
	the main block for language_fortran.  Pass physname parameter to the
	typename_concat call.
	(read_import_statement, read_func_scope, get_scope_pc_bounds)
	(load_partial_dies, determine_prefix): Support also DW_TAG_module.
	(new_symbol): Fill in cplus_specific.demangled_name if it is still
	missing from SYMBOL_SET_NAMES in the language_fortran case.
	(new_symbol) <DW_TAG_variable>: Force LOC_UNRESOLVED for gfortran module
	variables.
	(read_type_die) <DW_TAG_module>: New.
	(MAX_SEP_LEN): Increase to 7.
	(typename_concat): New parameter physname.  New variable lead.  Support
	also language_fortran.
	* f-exp.y (yylex): Consider : also as a symbol name character class.
	* f-lang.c: Include cp-support.h.
	(f_word_break_characters, f_make_symbol_completion_list): New functions.
	(f_language_defn): Use cp_lookup_symbol_nonlocal,
	f_word_break_characters and f_make_symbol_completion_list.
	* f-typeprint.c (f_type_print_base) <TYPE_CODE_MODULE>: New.
	* gdbtypes.h (enum type_code) <TYPE_CODE_MODULE>: New.
	* symtab.c (symbol_init_language_specific): Support language_fortran.
	(symbol_find_demangled_name): New comment on language_fortran.
	(symbol_natural_name, symbol_demangled_name): Use demangled_name even
	for language_fortran.
	(lookup_symbol_aux_local): Check imports also for language_fortran.
	(default_make_symbol_completion_list): Rename to ...
	(default_make_symbol_completion_list_break_on): ... this name.  New
	parameter break_on, use it.
	(default_make_symbol_completion_list): New stub.
	* symtab.h (default_make_symbol_completion_list_break_on): New
	prototype.

gdb/testsuite/
	Support DW_TAG_module as separate namespaces.
	* gdb.fortran/library-module.exp, gdb.fortran/library-module-main.f90,
	gdb.fortran/library-module-lib.f90: New.
	* gdb.fortran/module.exp: Replace startup by a prepare_for_testing call.
	(print i): Remove.
	(continue to breakpoint: i-is-1, print var_i value 1)
	(continue to breakpoint: i-is-2, print var_i value 2)
	(continue to breakpoint: a-b-c-d, print var_a, print var_b, print var_c)
	(print var_d, print var_i value 14, ptype modmany, complete `modm)
	(complete `modmany, complete `modmany`, complete `modmany`var)
	(show language, setting breakpoint at module): New tests.
	* gdb.fortran/module.f90 (module mod): Remove.
	(module mod1, module mod2, module modmany, subroutine sub1)
	(subroutine sub2, program module): New.
@
text
@a8786 22
	  /* Make sure that the symbol includes appropriate enclosing
	     classes/namespaces in its name.  These are calculated in
	     read_structure_type, and the correct name is saved in
	     the type.  */

	  if (cu->language == language_cplus
	      || cu->language == language_java)
	    {
	      struct type *type = SYMBOL_TYPE (sym);
	      
	      if (TYPE_TAG_NAME (type) != NULL)
		{
		  /* FIXME: carlton/2003-11-10: Should this use
		     SYMBOL_SET_NAMES instead?  (The same problem also
		     arises further down in this function.)  */
		  /* The type's name is already allocated along with
		     this objfile, so we don't need to duplicate it
		     for the symbol.  */
		  SYMBOL_LINKAGE_NAME (sym) = TYPE_TAG_NAME (type);
		}
	    }

a8820 2
	  SYMBOL_LINKAGE_NAME (sym)
	    = (char *) dwarf2_full_name (name, die, cu);
a8833 2
	  SYMBOL_LINKAGE_NAME (sym)
	    = (char *) dwarf2_full_name (name, die, cu);
@


1.392
log
@gdb/
	* dwarf2read.c (typename_concat): Add const to the variable sep.
@
text
@d908 3
a910 4
static char *typename_concat (struct obstack *,
                              const char *prefix, 
                              const char *suffix,
			      struct dwarf2_cu *);
d957 3
d2203 1
a2203 1
      /* Anonymous namespaces have no name but have interesting
d2208 1
a2208 1
	  || pdi->tag == DW_TAG_enumeration_type)
d2321 1
d2332 1
a2332 1
					 parent->name, cu);
d2364 1
a2364 1
    return typename_concat (NULL, parent_scope, pdi->name, cu);
d2550 1
a2550 3
  /* Now scan partial symbols in that module.

     FIXME: Support the separate Fortran module namespaces.  */
d3212 1
d3268 2
a3269 1
      if (attr == NULL && die->parent->tag != DW_TAG_namespace)
d3302 19
d3323 2
a3324 1
      && (cu->language == language_cplus || cu->language == language_java))
d3336 2
a3337 1
	      char *prefixed_name = typename_concat (NULL, prefix, name, cu);
a3387 15
  else if (cu->language == language_ada)
    {
      /* For Ada unit, we prefer the linkage name over the name, as
	 the former contains the exported name, which the user expects
	 to be able to reference.  Ideally, we want the user to be able
	 to reference this entity using either natural or linkage name,
	 but we haven't started looking at this enhancement yet.  */
      struct attribute *attr;

      attr = dwarf2_attr (die, DW_AT_linkage_name, cu);
      if (attr == NULL)
	attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);
      if (attr && DW_STRING (attr))
	name = DW_STRING (attr);
    }
d3494 2
a3495 1
  if (imported_die->tag != DW_TAG_namespace)
d3992 1
a3992 1
  if (cu->language == language_cplus)
d4327 1
d5654 1
a5654 1
			    previous_prefix, name, cu);
d5707 23
a5736 2
  /* FIXME: Support the separate Fortran module namespaces.  */

d6726 1
d6858 1
d8580 7
d8690 14
d9185 3
d9219 2
a9220 2
  if (cu->language != language_cplus
      && cu->language != language_java)
d9272 1
d9292 1
a9292 1
#define MAX_SEP_LEN 2  /* sizeof ("::")  */
d9295 2
a9296 2
typename_concat (struct obstack *obs, const char *prefix, const char *suffix, 
		 struct dwarf2_cu *cu)
d9298 1
d9305 8
d9325 2
a9326 1
      strcpy (retval, prefix);
d9334 1
a9334 1
      return obconcat (obs, prefix, sep, suffix, (char *) NULL);
@


1.391
log
@gdb
	* dwarf2loc.h (dwarf2_per_cu_data): Declare.
	* dwarf2read.c (dwarf_stack_op_name): No longer static.  Return
	type is const.  Add 'def' argument.  Add missing operators, remove
	unhandled ones.
	(decode_locdesc): Update.
	(dwarf2_always_disassemble): New global.
	(show_dwarf2_always_disassemble): New function.
	(_initialize_dwarf2_read): Add always-disassemble.
	(dwarf2_per_cu_offset_size): New function.
	* dwarf2loc.c (dwarf2_always_disassemble): Declare.
	(piece_end_p): New function.
	(locexpr_describe_location_piece): Replace 'size' argument with
	'end'.  Use piece_end_p.  Rewrite recognition of TLS.  Recognize
	some constants.  Remove errors.
	(disassemble_dwarf_expression): New function.
	(locexpr_describe_location_1): Use disassemble_dwarf_expression.
	Add 'offset_size' argument.
	(loclist_describe_location): Change output formatting.
	* dwarf2expr.h (dwarf_stack_op_name): Declare.
gdb/doc
	* gdb.texinfo (Maintenance Commands): Document maint set dwarf2
	always-disassemble.
@
text
@d9239 1
a9239 1
  char *sep;
@


1.390
log
@	* dwarf2read.c (read_subrange_type): Handle missing base type
	according to Dwarf-2 specifications.
@
text
@a1004 2
static char *dwarf_stack_op_name (unsigned int);

d9891 2
a9892 2
static char *
dwarf_stack_op_name (unsigned op)
a10194 1
    /* GNU extensions.  */
d10201 6
a10210 13
    /* HP extensions. */ 
    case DW_OP_HP_is_value:
      return "DW_OP_HP_is_value";
    case DW_OP_HP_fltconst4:
      return "DW_OP_HP_fltconst4";
    case DW_OP_HP_fltconst8:
      return "DW_OP_HP_fltconst8";
    case DW_OP_HP_mod_range:
      return "DW_OP_HP_mod_range";
    case DW_OP_HP_unmod_range:
      return "DW_OP_HP_unmod_range";
    case DW_OP_HP_tls:
      return "DW_OP_HP_tls";
d10212 1
a10212 1
      return "OP_<unknown>";
d11053 1
a11053 1
		     dwarf_stack_op_name (op));
d11780 22
d12256 11
d12299 12
@


1.389
log
@	* dwarf2read.c (read_func_scope): Do not complain for
	external function if bounds are not found.
@
text
@d6134 1
a6134 1
  
a6135 8
  if (TYPE_CODE (base_type) == TYPE_CODE_VOID)
    {
      complaint (&symfile_complaints,
                _("DW_AT_type missing from DW_TAG_subrange_type"));
      base_type
	= init_type (TYPE_CODE_INT, gdbarch_addr_bit (gdbarch) / 8,
		     0, NULL, cu->objfile);
    }
d6153 1
a6153 1
      if (attr->form == DW_FORM_block1)
d6156 1
a6156 1
             with a DW_FORM_block1 attribute.
d6171 48
@


1.388
log
@	* dwarf2read.c (new_symbol): Handle DW_AT_variable_parameter
	attribute.
@
text
@d3907 5
a3911 3
      complaint (&symfile_complaints,
                 _("cannot get low and high bounds for subprogram DIE at %d"),
                 die->offset);
@


1.387
log
@	* dwarf2read.c (process_die): Also allow DW_TAG_const_type
	and DW_TAG_volatile_type.
	(new_symbol): Likewise.
@
text
@d8667 9
@


1.386
log
@	* dwarf2read.c (read_set_type): Set type length if
	DW_AT_byte_size attribute is present.
@
text
@d3197 2
d8747 2
@


1.385
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* dbxread.c: White space.
	* dcache.c: White space.
	* disasm.c: White space.
	* doublest.c: White space.
	* dsrec.c: White space.
	* dummy-frame.c: White space.
	* dwarf2expr.c: White space.
	* dwarf2-frame.c: White space.
	* dwarf2loc.c: White space.
	* dwarf2read.c: White space.
@
text
@d5550 1
d5552 2
@


1.384
log
@gdb/
	Code cleanup.
	* dwarf2read.c (die_type, die_descriptive_type): Remove variable type.
	Remove check of NULL returned by tag_type_to_type.
	(die_containing_type): Remove variable type.  Remove type_die variable
	initialization.  Remove check of NULL returned by tag_type_to_type.
@
text
@d1136 1
d1205 1
d1448 1
d1590 1
d1605 1
d1615 1
d2890 1
d3260 1
d3314 1
d3358 1
d3636 1
d3805 1
d4356 1
d4361 1
d4899 1
d5060 1
d5305 1
d5450 1
d5477 1
d5625 1
d5673 1
d5783 4
a5786 3
      else {
	/* Should we also complain about unhandled address classes?  */
      }
d5997 1
d6221 1
d6233 1
d7458 1
d8341 1
d8523 1
d8531 1
d9200 1
d10610 1
d11098 1
d11144 1
a11146 1

d11724 1
a11725 1
      struct comp_unit_head cu_header;
d11747 1
d11782 1
d11968 1
d11979 1
d12117 1
d12129 1
d12159 1
d12174 1
@


1.383
log
@gdb/
	* dwarf2read.c (typename_concat): Use (char *) NULL terminated stdarg
	list for the obconcat call.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol, read_member_functions, read_cpp_abbrev):
	Likewise.
	* symfile.c (obconcat): Replace the s1, s2 and s3 parameters by `...'.
	New variable ap.  Remove variables len and val.
	* symfile.h (obconcat): Likewise for the prototype.
@
text
@a8879 1
  struct type *type;
d8892 1
a8892 8
  type = tag_type_to_type (type_die, cu);
  if (!type)
    {
      dump_die_for_error (type_die);
      error (_("Dwarf Error: Problem turning type die at offset into gdb type [in module %s]"),
		      cu->objfile->name);
    }
  return type;
a8920 1
  struct type *type;
d8929 1
a8929 8
  type = tag_type_to_type (type_die, cu);
  if (!type)
    {
      dump_die_for_error (type_die);
      error (_("Dwarf Error: Problem turning type die at offset into gdb type [in module %s]"),
		      cu->objfile->name);
    }
  return type;
a8953 1
  struct type *type = NULL;
d8955 1
a8955 1
  struct die_info *type_die = NULL;
d8958 6
a8963 13
  if (type_attr)
    {
      type_die = follow_die_ref_or_sig (die, type_attr, &cu);
      type = tag_type_to_type (type_die, cu);
    }
  if (!type)
    {
      if (type_die)
	dump_die_for_error (type_die);
      error (_("Dwarf Error: Problem turning containing type into gdb type [in module %s]"), 
		      cu->objfile->name);
    }
  return type;
@


1.382
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* elfread.c (elf_symtab_read): Delete unused variable.
	(find_separate_debug_file_by_buildid): Delete unused variables.
	(elf_symfile_read): Delete unused variable.

	* coffread.c (coff_symfile_read): Delete unused variables.

	* coff-pe-read.c (add_pe_exported_sym): Delete unused variable.
	(read_pe_exported_syms): Delete unused variable.

	* stabsread.c (define_symbol): Delete unused variable.

	* dwarf2read.c (read_type_comp_unit_head): Delete unused variable.
	(process_psymtab_comp_unit): Delete unused variable.
	(dwarf2_build_psymtabs_hard): Delete unused variable.
	(load_partial_comp_unit): Delete unused variable.
	(create_all_comp_units): Delete unused variable.
	(scan_partial_symbols): Delete unused variable.
	(add_partial_symbol): Delete unused variable.
	(add_partial_namespace): Delete unused variable.
	(add_partial_enumeration): Delete unused variable.
	(load_full_comp_unit): Delete unused variable.
	(process_full_comp_unit): Delete unused variable.
	(read_file_scope): Delete unused variable.
	(read_type_unit_scope): Delete unused variable.
	(process_structure_scope): Delete unused variable.
	(process_enumeration_scope): Delete unused variable.
	(read_tag_ptr_to_member_type): Delete unused variable.
	(read_typedef): Delete unused variable.
	(read_partial_die): Delete unused variable.
	(decode_locdesc): Delete unused variable.
	(zeroed_partial_die): Delete unused global variable.
@
text
@d9203 1
a9203 1
      return obconcat (obs, prefix, sep, suffix);
@


1.381
log
@D language support.

gdb/ChangeLog:

        D language support.
        * Makefile.in (SFILES): Add d-lang.c d-valprint.c.
        (COMMON_OBS): Add d-lang.o d-valprint.o.
        (HFILES_NO_SRCDIR): Add d-lang.h.
        * NEWS: Mention D language support.
        * c-lang.c (c_emit_char, exp_descriptor_c): Make public.
        * c-lang.h (c_emit_char, exp_descriptor_c): Add declaration.
        * d-lang.c: New file.
        * d-lang.h: New file.
        * d-valprint.c: New file.
        * defs.h (enum language): Add language_d.
        * dwarf2read.c (set_cu_language): Add DW_LANG_D.
        * language.c (binop_result_type, integral_type, character_type)
        (string_type, boolean_type, structured_type): Add language_d.
        * symfile.c (init_filename_language_table): Add language_d.
        * symtab.c: Include d-lang.h.
        (symbol_init_language_specific, symbol_find_demangled_name)
        (symbol_natural_name, lookup_symbol_in_language)
        (symbol_demangled_name, symbol_matches_domain): Add language_d.

gdb/doc/ChangeLog:

        * gdb.texinfo: (Summary) Add mention about D language support.
        (Filenames): Add D suffixes.
        (D): New node.

gdb/testsuite/ChangeLog:

        * gdb.base/default.exp: Fix "set language" test.
@
text
@a595 3
/* A zeroed version of a partial die for initialization purposes.  */
static struct partial_die_info zeroed_partial_die;

a1519 1
  unsigned int bytes_read;
d1522 2
a1523 1
  dwarf2_read_section (dwarf2_per_objfile->objfile, &dwarf2_per_objfile->types);
a1793 1
  unsigned int bytes_read;
a1795 1
  const char *name;
a1996 1
  bfd *abfd = objfile->obfd;
a2057 1
  unsigned int bytes_read;
a2135 1
      gdb_byte *beg_of_comp_unit;
a2184 2
  struct objfile *objfile = cu->objfile;
  bfd *abfd = objfile->obfd;
a2365 1
  const char *my_prefix;
a2526 2
  struct objfile *objfile = cu->objfile;

a2651 2
  struct objfile *objfile = cu->objfile;
  bfd *abfd = objfile->obfd;
a3033 1
  CORE_ADDR baseaddr;
a3102 1
  bfd *abfd = objfile->obfd;
a3517 1
  struct comp_unit_head *cu_header = &cu->header;
a3646 1
  struct line_header *line_header = 0;
a5233 1
  struct objfile *objfile = cu->objfile;
a5329 1
  struct objfile *objfile = cu->objfile;
a5776 1
  struct objfile *objfile = cu->objfile;
a5992 1
  struct attribute *attr;
d6786 1
a6786 1
  unsigned int bytes_read, i;
a10808 1
  struct comp_unit_head *cu_header = &cu->header;
@


1.380
log
@	* dwarf2read.c (dwarf2_compute_name): Handle DW_AT_linkage_name.
	(read_partial_die): Likewise.
	(dwarf_attr_name): Likewise.
@
text
@d7622 3
@


1.379
log
@	* dwarf2-frame.c (decode_frame_entry_1): Handle CIE version 4.
	(struct dwarf2_cie) <segment_size>: New field.
	* dwarf2read.c (partial_read_comp_unit_head): Accept DWARF 4.
	(skip_one_die): Handle DW_FORM_flag_present, DW_FORM_sec_offset,
	DW_FORM_exprloc.
	(read_attribute_value): Handle DW_FORM_flag_present,
	DW_FORM_sec_offset, DW_FORM_exprloc.
	(dump_die_shallow): Likewise.
	(attr_form_is_section_offset): Handle DW_FORM_sec_offset.
	(dwarf2_const_value): Handle DW_FORM_exprloc.
	(attr_form_is_block): Likewise.
	(struct line_header) <maximum_ops_per_instruction>: New field.
	(dwarf_decode_line_header): Set new field.
	(dwarf_decode_lines): Handle new field.
@
text
@d3380 3
a3382 1
      attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);
d6854 1
d6856 3
d9694 2
@


1.378
log
@gdb/
	* dwarf2read.c (read_namespace_type): Use common "return set_die_type"
	code form.
@
text
@d399 1
d1492 1
a1492 1
  if (header->version != 2 && header->version != 3)
d1494 2
a1495 2
	   "(is %d, should be %d) [in module %s]"), header->version,
	   2, bfd_get_filename (abfd));
d2780 2
d2799 1
d2803 1
d7137 4
d7152 1
d7177 3
d7696 1
a7696 1
   DW_FORM_flag attributes.  */
d7878 15
d8041 1
d8073 5
a8077 2
	      address += (adj_opcode / lh->line_range)
		* lh->minimum_instruction_length;
d8081 3
a8083 1
	      else
d8118 1
d8184 11
a8194 3
	      address += lh->minimum_instruction_length
		* read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
d8241 9
a8249 2
	      address += (lh->minimum_instruction_length
			  * ((255 - lh->opcode_base) / lh->line_range));
d8253 1
d8815 1
d10363 4
d10382 4
d10406 3
d11586 2
a11587 1
      || attr->form == DW_FORM_block);
d11602 2
a11603 1
          || attr->form == DW_FORM_data8);
@


1.377
log
@gdb/
	Fix crash on reading wrong function declaration DWARF.
	* dwarf2read.c (read_subroutine_type): New variable void_type.
	Pre-fill all TYPE_FIELD_TYPEs.  Move nparams and iparams initialization
	more close to their use.

gdb/testsuite/
	* gdb.dwarf2/dw2-bad-parameter-type.exp,
	gdb.dwarf2/dw2-bad-parameter-type.S: New.
@
text
@d5640 1
a5640 3
  set_die_type (die, type, cu);

  return type;
@


1.376
log
@	* dwarf2read.c (read_func_scope): Also scan specification DIEs
	for DW_TAG_imported_module children.
@
text
@d5941 1
d5943 1
a5943 2
      int nparams = 0;
      int iparams = 0;
d5948 1
d5964 6
@


1.375
log
@ChangeLog:

	* dwarf2read.c (dwarf2_name): Work around GCC bugzilla debug/41828 by
	ignoring spurious DW_AT_name attributes for unnamed structs or unions.
	* completer.c (add_struct_fields): Fix inverted logic.

testsuite/ChangeLog:

	* gdb.cp/inherit.exp (test_ptype_si): XFAIL test for GCC versions
	that do not provide the tagless_struct type name at all.
	(test_print_anon_union): Do not check value of uninitialized
	union member.  Do not use cp_test_ptype_class, so we can accept
	"long" as well as "long int".
@
text
@d3949 25
@


1.374
log
@  * dwarf2read.c (read_subroutine_type): If the compilation unit
  language is Java, mark any formal parameter named "this" as
  artificial (GCC/43521).
  (dwarf2_name): Add special handling for Java constructors.
@
text
@d9190 1
d9218 15
a9232 1
      /* fall through */
d9234 9
a9242 8
      if (!DW_STRING_IS_CANONICAL (attr))
	{
	  DW_STRING (attr)
	    = dwarf2_canonicalize_name (DW_STRING (attr), cu,
					&cu->objfile->objfile_obstack);
	  DW_STRING_IS_CANONICAL (attr) = 1;
	}
      return DW_STRING (attr);
d9244 1
@


1.373
log
@	* dwarf2-frame.c (dwarf2_frame_find_quirks): Use producer_is_realview.
	* dwarf2read.c (load_full_comp_unit): Read DW_AT_producer.
	(read_structure_type): For RealView, set TYPE_STUB on structures with
	no byte size and no children.
	(read_subroutine_type): Mark functions as prototyped by default.
	* symtab.c (producer_is_realview): New function.
	* symtab.h (expand_line_sal): Fix declaration formatting.
	(producer_is_realview): Declare.

	testsuite/
	* gdb.base/callfuncs.exp (do_function_calls): Add XFAILs for RealView.
	* gdb.base/ptype.exp (ptype_maybe_prototyped): Add overprototyped
	argument.  Handle "short" and "long".
	(Top level): Pass overprototyped output for old_fptr and xptr.
@
text
@d5952 12
a5963 1
		TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;
d9190 28
@


1.372
log
@	* dwarf2read.c (partial_die_parent_scope): Work around buggy
	GCC 4.1 debug info generation (GCC PR c++/28460).
	(determine_prefix): Likewise.
@
text
@d3088 6
d5093 5
d5896 6
@


1.371
log
@[dwarf] Anonymous nested function causes SEGV during psymbol read

According to the DWARF3 standard, a function always has a name attribute
(Section 3.3 - Subroutine and Entry Point Entries).  The only exception
is when a DW_AT_abstract_origin attribute is provided, in which case
the name may be inherited from the referenced DIE.

The problem occured because our compiler generated a subprogram DIE
for a nested function where the name attribute was missing (and no
abstract-origin either).  Our code in add_partial_symbol is not
prepared to deal with the situation, and happily just tries  to compute
the length of the (NULL) function name.

This normally cannot happen, because there is already a guard in
scan_partial_symbols, where we (silently!) ignore anonymous dies,
including anonymous subprograms. Unfortunately, there is a flaw that
affects Ada and other languages that allow nested subprograms. For
nested subprograms, we do not go through scan_partial_symbols and
thus we are missing the name check.

This patch adds the name check in the nested subprogram case. It also
adds a complaint which is emitted during the psymtab->symtab conversion
phase.

gdb/ChangeLog:

        * dwarf2read.c (add_partial_subprogram): Make sure the subprogram
        DIE has a name before creating the associated partial symbol.
        (read_func_scope): Emit a complaint if the subprogram does not
        have a name or when we can't extract the subprogram PC bounds.

gdb/testsuite/ChangeLog:

        * gdb.dwarf2/dw2-anonymous-func.S: New file.
        * gdb.dwarf2/dw2-anonymous-func.exp: New testcase.

Tested on x86_64-linux, no regression.  Note that the testcase also
verifies that the psymtab->symtab conversion does not crash (this is
the purpose of the "list file1.txt:1" test.
@
text
@d2310 13
d9045 6
@


1.370
log
@	* dwarf2read.c (dwarf2_get_section_info): Handle case where no
	DWARF data is available.
@
text
@d2586 5
a2590 1
            add_partial_symbol (pdi, cu);
d3874 17
a3890 4
  /* Ignore functions with missing or empty names and functions with
     missing or invalid low and high pc attributes.  */
  if (name == NULL || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu, NULL))
    return;
@


1.369
log
@gdb/
	* dwarf2read.c (read_subrange_type): Set TYPE_HIGH_BOUND_UNDEFINED.
	* valarith.c (value_subscripted_rvalue): Suppress error if
	TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED.
@
text
@d1400 10
@


1.368
log
@	* dwarf2read.c (die_needs_namespace): Also return 0 for
	DW_TAG_subprogram.
@
text
@d6077 6
@


1.367
log
@
    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        PR c++/7936:
        * cp-support.h: Added char *declaration element to using_direct
        data struct.
        (cp_add_using): Added char *declaration argument.
        (cp_add_using_directive): Ditto.
        (cp_lookup_symbol_imports): made extern.
        * cp-namespace.c: Updated with the above changes.
        * dwarf2read.c (read_import_statement): Ditto.
        (read_namespace): Ditto.
        (read_import_statement): Support import declarations.
        * cp-namespace.c (cp_lookup_symbol_imports): Check for imported
        declarations.
        Added support for 'declaration_only' search.
        (cp_lookup_symbol_namespace): Attempt to search for the name as
        is before consideration of imports.
        * symtab.c (lookup_symbol_aux_local): Added a 'declaration_only'
        search at every block level search.
        Now takes language argument.
        (lookup_symbol_aux): Updated.

    2010-03-15  Sami Wagiaalla  <swagiaal@@redhat.com>

        * gdb.cp/shadow.exp: Removed kfail; test has been fix.
        * gdb.cp/nsusing.exp: Ditto.
@
text
@d3244 2
a3245 1
	  || die->parent->tag ==  DW_TAG_catch_block)
@


1.366
log
@gdb
	PR c++/9708:
	* dwarf2read.c (die_needs_namespace) <DW_TAG_variable>: A variable
	in a lexical block does not need a namespace.
	(new_symbol) <DW_TAG_variable>: Put extern variables on
	list_in_scope in all cases.
gdb/testsuite
	PR c++/9708:
	* gdb.cp/m-static.exp: Add regression test.
	* gdb.cp/m-static.cc (method): New method.
	(main): Call it.
@
text
@d3386 4
a3389 1
  char *import_alias;
d3391 1
a3391 2
  const char *import_prefix;
  char *canonical_name;
d3451 1
a3451 1
  if (strlen (imported_name_prefix) > 0)
d3453 2
a3454 5
      canonical_name = alloca (strlen (imported_name_prefix)
                               + 2 + strlen (imported_name) + 1);
      strcpy (canonical_name, imported_name_prefix);
      strcat (canonical_name, "::");
      strcat (canonical_name, imported_name);
d3456 1
a3456 1
  else
d3458 6
a3463 2
      canonical_name = alloca (strlen (imported_name) + 1);
      strcpy (canonical_name, imported_name);
d3465 2
d3471 1
d5593 1
a5593 1
	                          &objfile->objfile_obstack);
@


1.365
log
@	* dwarf2read.c (struct pubnames_header): Remove.
	(_PUBNAMES_HEADER): Remove.
	(_ACTUAL_PUBNAMES_HEADER_SIZE): Remove.
	(struct aranges_header): Remove.
	(_ARANGES_HEADER, _ACTUAL_ARANGES_HEADER_SIZE): Remove.
	(struct dwarf2_per_objfile) <pubnames, aranges>: Remove.
	(PUBNAMES_SECTION): Remove.
	(ARANGES_SECTION): Remove.
	(dwarf2_locate_sections): Don't handle pubnames or aranges.
	(dwarf2_build_psymtabs): Remove dead code.
	(dwarf2_build_psymtabs_easy): Remove.
@
text
@d3207 2
d3236 11
a3246 5
      if (dwarf2_attr (die, DW_AT_external, cu)
	  || die->parent->tag == DW_TAG_namespace)
	return 1;

      return 0;
d8424 9
a8432 1
		add_symbol_to_list (sym, &global_symbols);
@


1.364
log
@	* elfread.c (elf_symfile_read): Don't call
	dwarf2_build_frame_info.
	* dwarf2read.c (struct dwarf2_section_info) <readin>: New field.
	(struct dwarf2_per_objfile) <objfile>: New field.
	(dwarf2_has_info): Now idempotent.  Set objfile field.
	(dwarf2_read_section): Check and set readin field.  Call
	posix_madvise.
	(dwarf2_build_psymtabs): Don't read all sections.
	(read_type_comp_unit_head): Read types section.
	(create_debug_types_hash_table): Likewise.
	(init_cu_die_reader): Add asserts.
	(process_type_comp_unit): Add assert.
	(dwarf2_build_psymtabs_hard): Read info section.
	(load_partial_comp_unit): Add assert.
	(create_all_comp_units): Read info section.
	(load_full_comp_unit): Likewise.
	(dwarf2_ranges_read): Read ranges section.
	(dwarf2_record_block_ranges): Add assert.
	(dwarf2_read_abbrevs): Read abbrev section.
	(read_indirect_string): Read str section.
	(dwarf_decode_line_header): Read line section.
	(read_signatured_type_at_offset): Read types section.
	(dwarf_decode_macros): Read macinfo section.
	(dwarf2_symbol_mark_computed): Read loc section.
	* dwarf2-frame.c (dwarf2_frame_find_fde): Call
	dwarf2_build_frame_info.
	(dwarf2_build_frame_info): Unconditionally set
	dwarf2_frame_objfile_data on the objfile.
	* configure.ac: Check for posix_madvise.
	* config.in, configure: Rebuild.
@
text
@a85 32
/* .debug_pubnames header
   Because of alignment constraints, this structure has padding and cannot
   be mapped directly onto the beginning of the .debug_info section.  */
typedef struct pubnames_header
  {
    unsigned int length;	/* length of the .debug_pubnames
				   contribution  */
    unsigned char version;	/* version number -- 2 for DWARF
				   version 2 */
    unsigned int info_offset;	/* offset into .debug_info section */
    unsigned int info_size;	/* byte size of .debug_info section
				   portion */
  }
_PUBNAMES_HEADER;
#define _ACTUAL_PUBNAMES_HEADER_SIZE 13

/* .debug_pubnames header
   Because of alignment constraints, this structure has padding and cannot
   be mapped directly onto the beginning of the .debug_info section.  */
typedef struct aranges_header
  {
    unsigned int length;	/* byte len of the .debug_aranges
				   contribution */
    unsigned short version;	/* version number -- 2 for DWARF
				   version 2 */
    unsigned int info_offset;	/* offset into .debug_info section */
    unsigned char addr_size;	/* byte size of an address */
    unsigned char seg_size;	/* byte size of segment descriptor */
  }
_ARANGES_HEADER;
#define _ACTUAL_ARANGES_HEADER_SIZE 12

a136 2
  struct dwarf2_section_info pubnames;
  struct dwarf2_section_info aranges;
a177 2
#define PUBNAMES_SECTION "debug_pubnames"
#define ARANGES_SECTION  "debug_aranges"
a741 4
#if 0
static void dwarf2_build_psymtabs_easy (struct objfile *);
#endif

a1182 10
  else if (section_is_p (sectp->name, PUBNAMES_SECTION))
    {
      dwarf2_per_objfile->pubnames.asection = sectp;
      dwarf2_per_objfile->pubnames.size = bfd_get_section_size (sectp);
    }
  else if (section_is_p (sectp->name, ARANGES_SECTION))
    {
      dwarf2_per_objfile->aranges.asection = sectp;
      dwarf2_per_objfile->aranges.size = bfd_get_section_size (sectp);
    }
d1426 1
a1426 49
#if 0
  if (dwarf_aranges_offset && dwarf_pubnames_offset)
    {
      /* Things are significantly easier if we have .debug_aranges and
         .debug_pubnames sections */

      dwarf2_build_psymtabs_easy (objfile);
    }
  else
#endif
    /* only test this case for now */
    {
      /* In this case we have to work a bit harder */
      dwarf2_build_psymtabs_hard (objfile);
    }
}

#if 0
/* Build the partial symbol table from the information in the
   .debug_pubnames and .debug_aranges sections.  */

static void
dwarf2_build_psymtabs_easy (struct objfile *objfile)
{
  bfd *abfd = objfile->obfd;
  char *aranges_buffer, *pubnames_buffer;
  char *aranges_ptr, *pubnames_ptr;
  unsigned int entry_length, version, info_offset, info_size;

  pubnames_buffer = dwarf2_read_section (objfile,
					 dwarf_pubnames_section);
  pubnames_ptr = pubnames_buffer;
  while ((pubnames_ptr - pubnames_buffer) < dwarf2_per_objfile->pubnames.size)
    {
      unsigned int bytes_read;

      entry_length = read_initial_length (abfd, pubnames_ptr, &bytes_read);
      pubnames_ptr += bytes_read;
      version = read_1_byte (abfd, pubnames_ptr);
      pubnames_ptr += 1;
      info_offset = read_4_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 4;
      info_size = read_4_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 4;
    }

  aranges_buffer = dwarf2_read_section (objfile,
					dwarf_aranges_section);

a1427 1
#endif
@


1.363
log
@	* xcoffread.c (xcoff_start_psymtab): Update.
	(xcoff_end_psymtab): Update.
	* psymtab.c (allocate_psymtab): Remove dead code.
	* psympriv.h (struct partial_symtab) <read_symtab_private>: Now
	void*.
	* mdebugread.c (parse_partial_symbols): Update.
	(new_psymtab): Likewise.
	* dwarf2read.c (process_psymtab_comp_unit): Update.
	(psymtab_to_symtab_1): Update.
	* dbxread.c (start_psymtab): Update.
	(end_psymtab): Likewise.
@
text
@d160 2
d179 3
d1172 9
a1180 1
  struct dwarf2_per_objfile *data;
d1182 5
a1186 8
  /* Initialize per-objfile state.  */
  data = obstack_alloc (&objfile->objfile_obstack, sizeof (*data));
  memset (data, 0, sizeof (*data));
  set_objfile_data (objfile, dwarf2_objfile_data_key, data);
  dwarf2_per_objfile = data;

  bfd_map_over_sections (objfile->obfd, dwarf2_locate_sections, NULL);
  return (data->info.asection != NULL && data->abbrev.asection != NULL);
d1368 2
d1372 1
d1410 3
a1470 11
  dwarf2_read_section (objfile, &dwarf2_per_objfile->info);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->abbrev);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->line);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->str);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->macinfo);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->ranges);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->types);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->loc);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->eh_frame);
  dwarf2_read_section (objfile, &dwarf2_per_objfile->frame);

d1614 1
d1711 1
a1711 1
  gdb_byte *info_ptr = dwarf2_per_objfile->types.buffer;
d1714 3
d1822 4
a1825 1
    reader->buffer = dwarf2_per_objfile->types.buffer;
d1827 4
a1830 1
    reader->buffer = dwarf2_per_objfile->info.buffer;
d2062 1
a2089 2
  /* Instead of reading this into a big buffer, we should probably use
     mmap()  on architectures that support it. (FIXME) */
d2094 1
d2160 1
d2218 4
a2221 1
  gdb_byte *info_ptr = dwarf2_per_objfile->info.buffer;
d3123 1
d4101 1
d4404 1
d6404 2
d7478 1
d7805 1
d10574 2
d11182 2
d11509 3
@


1.362
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@d1954 1
a1954 1
  pst->read_symtab_private = (char *) this_cu;
d3058 1
a3058 1
  per_cu = (struct dwarf2_per_cu_data *) pst->read_symtab_private;
@


1.361
log
@
   2010-03-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR C++/11236:
	* cp-namespace.c (cp_add_using): Deleted.
	(cp_add_using_directive): Use obstack allocations.
	Merged the function cp_add_using into this one.
	Added 'struct obstack *' argument.
	(cp_scan_for_anonymous_namespaces): Updated.
	* cp-support.h: Updated.
	* dwarf2read.c (read_import_statement): Updated.
	(read_namespace): Updated.
@
text
@d53 1
@


1.360
log
@Adjust handling of Ada DIEs after dwarf2_physname patch.

        * dwarf2read.c (dwarf2_compute_name): Add handling of Ada DIEs.
@
text
@d3533 4
a3536 4
  using_directives = cp_add_using (import_prefix,
                                   canonical_name,
                                   import_alias,
                                   using_directives);
d5654 2
a5655 1
	  cp_add_using_directive (previous_prefix, TYPE_NAME (type), NULL);
@


1.359
log
@dwarf2_physname patchset:

	Based on work from Daniel Jacobowitz  <dan@@codesourcery.com>
	* c-typeprint.c (cp_type_print_method_args): For non-static methods,
	print out const or volatile qualifiers, too.
	(c_type_print_args): Add parameters show_artificial and language.
	Skip artificial parameters when requested.
	Use the appropriate language printer.
	(c_type_print_varspec): Tell c_type_print_args to skip artificial
	parameters and pass language_c.
	* dwarf2read.c (die_list): New file global.
	(struct partial_die_info): Update comments for name field.
	(pdi_needs_namespace): Renamed to ...
	(die_needs_namespace): ... this. Rewrite.
	(dwarf2_linkage_name): Remove.
	(add_partial_symbol): Do not predicate the call to
	partial_die_full_name based on pdi_needs_namespace.
	Remove call to cp_check_possible_namespace_symbols and associated
	outdated comments.
	(guess_structure_name): Do not inspect child subprogram DIEs.
	(dwarf2_fullname): Update comments.
	Use die_needs_namespace to assist in computing the name.
	(read_func_scope): Use dwarf2_name to get the DIE's name.
	Use dwarf2_physname to get the "linkage name" of the DIE.
	(dwarf2_add_member_field): Use dwarf2_physname instead of
	dwarf2_linkage_name.
	(read_structure_type): For structs and classes, set TYPE_NAME, too.
	(determine_class): Remove.
	(read_partial_die): Ignore DW_AT_MIPS_linkage_name for all languages
	except Ada.
	(new_symbol): Unconditionally call dwarf2_name.
	Compute the "linkage name" using dwarf2_physname.
	Use dwarf2_name instead of dwarf2_full_name for enumerator DIEs.
	When determining to scan for anonymous C++ namespaces, ignore
	the linkage name.
	(dwarf2_physname): New function.
	(dwarf2_full_name): Move content to new function and call
	that.
	(dwarf2_compute_name): "New" function.
	(_initialize_dwarf2_read): Initialize die_list.
	* gnu-v3-eabi.c (gnu_v3_find_method_in): Remove unused variable
	physname.
	(gnu_v3_print_method_ptr): Use the physname for virtual methods
	without a demangled name.
	Print out type information for non-virtual methods.
        * linespec.c (decode_line_1): Force ANY string using "::" (or
	"." for java) to use decode_compound, and clean up any stray quoting.
        If we found a file symtab, re-evaluate whether the remainder is_quoted.
        (decode_compound): Stop consuming at an open parenthesis.
        Keep template parameters.
        Keep any overload information.
        Keep keywords like "const".
        Remove paren_pointer.
        Move is_quoted check from set_flags to here.
        Remove #if 0 code from 2000. Ten years is long enough.
        (find_method): Before comparing symbol names, canonicalize the string
        from the user.
        If a specific overload is requested, find it. Otherwise throw an error.
	(find_method_overload_end): New function.
	(set_flags): Remove.
        (decode_compound): Assume that parentheses are matched.
        It's a lot easier.
	* symtab.c (symbol_find_demangled_name): Add DMGL_VERBOSE flag
	to cplus_demangle.
	* linespec.c (decode_line_1): Keep important keywords like
	"const" and "volatile".
	* symtab.h (SYMBOL_CPLUS_DEMANGLED_NAME): Remove.
	* typeprint.h (c_type_print_args): Add declaration.
	* ui-file.c (do_ui_file_obsavestring): New function.
	(ui_file_obsavestring): New function.
	* ui-file.h (ui_file_obsavestring): Add declaration.
	* valops.c (find_overload_match): Resolve the object to
	a non-pointer type.
	If the object is a data member, search the object for the member
	and return with staticp set.
	Use SYMBOL_NATURAL_NAME instead of SYMBOL_CPLUS_DEMANGLED_NAME.
	Do not attempt to extract a function name from non-function types.
	If the extracted function name and the original name are the same,
	we don't have a C++ method.

	From Jan Kratochvil  <jan.kratochvil@@redhat.com>:
    	* dwarf2read.c (new_symbol <DW_TAG_enumerator>): Call dwarf2_full_name.

	* ada-lang.c (ada_lookup_symbol): Remove linkage_name parameters
	and arguments from symbol lookups.
	* ax-gdb.c (gen_expr): Likewise.
	* cp-namespace.c (cp_lookup_symbol_nonlocal, lookup_namespace_scope,
	cp_lookup_symbol_namespace, lookup_symbol_file, lookup_nested_type,
	lookup_possible_namespace_symbol): Likewise.
	* cp-support.c (read_in_psymtabs): Likewise.
	* cp-support.h (cp_lookup_symbol_nonlocal): Likewise.
	* language.h (la_lookup_symbol_nonlocal): Likewise.
	* scm-valprint.c (scm_inferior_print): Likewise.
	* solib-darwin.c (darwin_relocate_section_addresses): Likewise.
	* solib-svr.c (elf_lookup_lib): Likewise.
	* solib.c (show_auto_solib_add): Likewise.
	* solist.h (lookup_lib_global, solib_global_lookup): Likewise.
	* symmisc.c (maintenance_check_symtabs): Likewise.
	* symtab.c (lookup_symbol_in_language, lookup_symbol_aux,
	lookup_symbol_aux_local, lookup_symbol_aux_block,
	lookup_symbol_from_objfile, lookup_symbol_aux_symtabs,
	lookup_symbol_aux_psymtabs,basic_lookup_symbol_nonlocal,
	lookup_symbol_static, lookup_symbol_global, symbol_matches_domain,
	basic_lookup_transparent_type, find_main_psymtab,
	lookup_block_symbol): Likewise.
	* symtab.h (basic_lookp_symbol_nonlocal, lookup_symbol_static,
	lookup_symbol_global, lookup_symbol_aux_block,
	lookup_symbol_partial_symbol, lookup_block_symbol,
	lookup_global_symbol, value_maybe_namespace_elt): Likewise.
@
text
@d3327 3
d3402 13
@


1.358
log
@	* dwarf2read.c (skip_one_die) <DW_FORM_ref_addr>: Use offset size
	in DWARF 3 and later.
	(read_attribute_value) <DW_FORM_ref_addr>: Likewise.
@
text
@d51 2
d492 1
a492 2
       sometimes DW_TAG_MIPS_linkage_name or a string computed in some
       other fashion.  */
a791 2
static int pdi_needs_namespace (enum dwarf_tag tag);

a985 3
static const char *determine_class_name (struct die_info *die,
					 struct dwarf2_cu *cu);

a1026 2
static char *dwarf2_linkage_name (struct die_info *, struct dwarf2_cu *);

d2438 3
a2440 6
  if (pdi_needs_namespace (pdi->tag))
    {
      actual_name = partial_die_full_name (pdi, cu);
      if (actual_name)
	built_actual_name = 1;
    }
a2579 16
  /* Check to see if we should scan the name for possible namespace
     info.  Only do this if this is C++, if we don't have namespace
     debugging info in the file, if the psym is of an appropriate type
     (otherwise we'll have psym == NULL), and if we actually had a
     mangled name to begin with.  */

  /* FIXME drow/2004-02-22: Why don't we do this for classes, i.e. the
     cases which do not set PSYM above?  */

  if (cu->language == language_cplus
      && cu->has_namespace_info == 0
      && psym != NULL
      && SYMBOL_CPLUS_DEMANGLED_NAME (psym) != NULL)
    cp_check_possible_namespace_symbols (SYMBOL_CPLUS_DEMANGLED_NAME (psym),
					 objfile);

a2583 23
/* Determine whether a die of type TAG living in a C++ class or
   namespace needs to have the name of the scope prepended to the
   name listed in the die.  */

static int
pdi_needs_namespace (enum dwarf_tag tag)
{
  switch (tag)
    {
    case DW_TAG_namespace:
    case DW_TAG_typedef:
    case DW_TAG_class_type:
    case DW_TAG_interface_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
    case DW_TAG_enumeration_type:
    case DW_TAG_enumerator:
      return 1;
    default:
      return 0;
    }
}

a2694 1
      struct partial_die_info *child_pdi = struct_pdi->die_child;
a2706 21

      while (child_pdi != NULL)
	{
	  if (child_pdi->tag == DW_TAG_subprogram)
	    {
	      char *actual_class_name
		= language_class_name_from_physname (cu->language_defn,
						     child_pdi->name);
	      if (actual_class_name != NULL)
		{
		  struct_pdi->name
		    = obsavestring (actual_class_name,
				    strlen (actual_class_name),
				    &cu->objfile->objfile_obstack);
		  xfree (actual_class_name);
		}
	      break;
	    }

	  child_pdi = child_pdi->die_sibling;
	}
d3278 125
d3406 4
a3409 1
   not have a name.  */
d3412 1
a3412 1
dwarf2_full_name (struct die_info *die, struct dwarf2_cu *cu)
d3414 2
a3415 3
  struct attribute *attr;
  char *prefix, *name;
  struct ui_file *buf = NULL;
d3417 4
a3420 8
  name = dwarf2_name (die, cu);
  if (!name)
    return NULL;

  /* These are the only languages we know how to qualify names in.  */
  if (cu->language != language_cplus
      && cu->language != language_java)
    return name;
d3422 1
a3422 13
  /* If no prefix is necessary for this type of DIE, return the
     unqualified name.  The other three tags listed could be handled
     in pdi_needs_namespace, but that requires broader changes.  */
  if (!pdi_needs_namespace (die->tag)
      && die->tag != DW_TAG_subprogram
      && die->tag != DW_TAG_variable
      && die->tag != DW_TAG_member)
    return name;

  prefix = determine_prefix (die, cu);
  if (*prefix != '\0')
    name = typename_concat (&cu->objfile->objfile_obstack, prefix,
			    name, cu);
d3424 4
a3427 1
  return name;
d3905 1
a3905 1
  name = dwarf2_linkage_name (die, cu);
d4579 1
a4579 1
      physname = dwarf2_linkage_name (die, cu);
d4741 1
a4741 1
  physname = dwarf2_linkage_name (die, cu);
d5048 4
a5051 2
	  const char *new_prefix = determine_class_name (die, cu);
	  TYPE_TAG_NAME (type) = (char *) new_prefix;
d5057 3
a5059 1
	  TYPE_TAG_NAME (type) = name;
d5278 1
a5278 1
  name = dwarf2_full_name (die, cu);
a5302 45
/* Determine the name of the type represented by DIE, which should be
   a named C++ or Java compound type.  Return the name in question,
   allocated on the objfile obstack.  */

static const char *
determine_class_name (struct die_info *die, struct dwarf2_cu *cu)
{
  const char *new_prefix = NULL;

  /* If we don't have namespace debug info, guess the name by trying
     to demangle the names of members, just like we did in
     guess_structure_name.  */
  if (!processing_has_namespace_info)
    {
      struct die_info *child;

      for (child = die->child;
	   child != NULL && child->tag != 0;
	   child = sibling_die (child))
	{
	  if (child->tag == DW_TAG_subprogram)
	    {
	      char *phys_prefix
		= language_class_name_from_physname (cu->language_defn,
						     dwarf2_linkage_name
						     (child, cu));

	      if (phys_prefix != NULL)
		{
		  new_prefix
		    = obsavestring (phys_prefix, strlen (phys_prefix),
				    &cu->objfile->objfile_obstack);
		  xfree (phys_prefix);
		  break;
		}
	    }
	}
    }

  if (new_prefix == NULL)
    new_prefix = dwarf2_full_name (die, cu);

  return new_prefix;
}

d5958 1
a5958 1
  name = dwarf2_full_name (die, cu);
d6786 2
a6787 1
	  part_die->name = DW_STRING (&attr);
d8358 1
a8358 5
  if (die->tag != DW_TAG_namespace)
    name = dwarf2_linkage_name (die, cu);
  else
    name = TYPE_NAME (type);

d8361 2
d8370 2
a8371 1
      SYMBOL_SET_NAMES (sym, name, strlen (name), 0, objfile);
d8596 2
a8597 1
	  SYMBOL_LINKAGE_NAME (sym) = (char *) dwarf2_full_name (die, cu);
d8609 2
a8610 1
	  SYMBOL_LINKAGE_NAME (sym) = (char *) dwarf2_full_name (die, cu);
d8647 1
a8647 2
	  && cu->language == language_cplus
	  && dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu) != NULL)
a9098 13
/* Get linkage name of a die, return NULL if not found.  */

static char *
dwarf2_linkage_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);
  if (attr && DW_STRING (attr))
    return DW_STRING (attr);
  return dwarf2_name (die, cu);
}

@


1.357
log
@	* dwarf2read.c (add_partial_subprogram): Add missing baseaddr to
	lowpc,highpc args to addrmap_set_empty.
@
text
@d2885 8
a2893 1
	case DW_FORM_ref_addr:
d7027 7
a7034 1
    case DW_FORM_ref_addr:
@


1.356
log
@	* dwarf2read.c (guess_structure_name): Allocate name on the
	objfile obstack.
@
text
@d2698 2
a2699 1
				 pdi->lowpc, pdi->highpc - 1,
@


1.356.2.1
log
@	* dwarf2read.c (add_partial_subprogram): Add missing baseaddr to
	lowpc,highpc args to addrmap_set_empty.
@
text
@d2698 1
a2698 2
				 pdi->lowpc + baseaddr,
				 pdi->highpc - 1 + baseaddr,
@


1.356.2.2
log
@	* dwarf2read.c (skip_one_die) <DW_FORM_ref_addr>: Use offset size
	in DWARF 3 and later.
	(read_attribute_value) <DW_FORM_ref_addr>: Likewise.
@
text
@d2885 1
a2886 8
	  /* In DWARF 2, DW_FORM_ref_addr is address sized; in DWARF 3
	     and later it is offset sized.  */
	  if (cu->header.version == 2)
	    info_ptr += cu->header.addr_size;
	  else
	    info_ptr += cu->header.offset_size;
	  break;
	case DW_FORM_addr:
d7020 1
a7021 7
      if (cu->header.version == 2)
	DW_ADDR (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
      else
	DW_ADDR (attr) = read_offset (abfd, info_ptr, &cu->header, &bytes_read);
      info_ptr += bytes_read;
      break;
    case DW_FORM_addr:
@


1.356.2.3
log
@PR 11408: Backport using_directives memory leak fix.

2010-04-08  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR Breakpoints/11408:
	* cp-namespace.c (cp_add_using): Deleted.
	(cp_add_using_directive): Use obstack allocations.
	Merged the function cp_add_using into this one.
	Added 'struct obstack *' argument.
	(cp_scan_for_anonymous_namespaces): Updated.
	* cp-support.h: Updated.
	* dwarf2read.c (read_import_statement): Updated.
	(read_namespace): Updated.
	* buildsym.c (finish_block): Reset using_directives pointer
	after block initialization.


2010-03-22  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/gdb2384-base.h: Created 'namespace B'.
	* gdb.cp/gdb2384-base.cc: Use 'namespace B'.
@
text
@d3473 4
a3476 4
  cp_add_using_directive (import_prefix,
                          canonical_name,
                          import_alias,
                          &cu->objfile->objfile_obstack);
d5635 1
a5635 2
	  cp_add_using_directive (previous_prefix, TYPE_NAME (type), NULL,
	                          &objfile->objfile_obstack);
@


1.355
log
@
2010-02-05  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR c++/7935:
	* gdb.cp/namespace-using.exp: Removed kfail; bug has been fixed.

2010-02-05  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR c++/7935:
	* cp-support.h: Added char* alias element to using_direct data
	struct.
	(cp_add_using): Added char* alias argument.
	(cp_add_using_directive): Ditto.
	* cp-namespace.c: Updated with the above changes.
	(cp_lookup_symbol_imports): Check for aliases.
	* dwarf2read.c (read_import_statement): Figure out local alias
	for the import and pass it on to cp_add_using.
	(read_namespace): Pass alias argument to cp_add_using.
@
text
@d2768 1
a2768 1
				    &cu->comp_unit_obstack);
@


1.354
log
@2010-02-03  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (struct sym_fns): Add sym_relocate field.
	(default_symfile_relocate): New prototype.
	(symfile_relocate_debug_section): First argument is now an objfile.
	* symfile.c (default_symfile_relocate): Rename from
	symfile_relocate_debug_section, first argument is now an objfile.
	(symfile_relocate_debug_section): New function.
	* coffread.c (coff_sym_fns): Set sym_relocate field.
	* somread.c (som_sym_fns): Ditto.
	* mipsread.c (ecoff_sym_fns): Ditto.
	* machoread.c (macho_sym_fns): Ditto.
	* elfread.c (elf_sym_fns): Ditto.
	* dwarf2read.c (dwarf2_read_section): Ditto.
	* xcoffread.c (xcoff_sym_fns): Ditto.
	* dbxread.c (aout_sym_fns): Ditto.
	(dbx_psymtab_to_symtab): Adjust call to symfile_relocate_debug_section.
	(elfstab_build_psymtabs): Ditto.
@
text
@d3388 2
d3441 2
a3442 1
  /* FIXME: dwarf2_name (die); for the local name after import.  */
d3453 2
a3454 1
      canonical_name = alloca (strlen (imported_name_prefix) + 2 + strlen (imported_name) + 1);
d3465 4
a3468 1
  using_directives = cp_add_using (import_prefix,canonical_name, using_directives);
d5627 1
a5627 1
	  cp_add_using_directive (previous_prefix, TYPE_NAME (type));
@


1.353
log
@gdb
	* m2-typeprint.c (m2_record_fields): Don't use
	TYPE_DECLARED_TYPE.
	* gdbtypes.h (TYPE_DECLARED_CLASS): New macro.
	(struct main_type) <flag_declared_class>: New field.
	(struct cplus_struct_type) <declared_type>: Remove.
	<ntemplate_args>: Move earlier.
	(DECLARED_TYPE_CLASS, DECLARED_TYPE_UNION, DECLARED_TYPE_STRUCT)
	(DECLARED_TYPE_TEMPLATE): Remove.
	(TYPE_DECLARED_TYPE): Remove.
	* gdbtypes.c (lookup_union): Don't use TYPE_DECLARED_TYPE.
	* dwarf2read.c (read_structure_type): Set TYPE_DECLARED_CLASS.
	* c-typeprint.c (c_type_print_base): Use TYPE_DECLARED_CLASS, not
	TYPE_DECLARED_TYPE.
gdb/testsuite
	* gdb.dwarf2/member-ptr-forwardref.exp: Update expected result for
	type-printing change.
@
text
@d1415 1
a1415 1
  retbuf = symfile_relocate_debug_section (abfd, sectp, buf);
@


1.352
log
@2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/namespace-using.exp: Add test for printing of namespaces
	imported into file scope.
	Marked test as xfail.
	* gdb.cp/namespace-using.cc (marker5): New function.
	* gdb.cp/shadow.exp: New test.
	* gdb.cp/shadow.cc: New test program.
	* gdb.cp/nsimport.exp: New test.
	* gdb.cp/nsimport.cc: New test program.

2010-01-26  Sami Wagiaalla  <swagiaal@@redhat.com>

	PR gdb/10929:
	* dwarf2read.c (read_lexical_block_scope): Create blocks for
	scopes which contain using directives even if they contain no
	declarations.
	* symtab.c (lookup_symbol_aux): Pass lowest level block to
	la_lookup_symbol_nonlocal.
	* cp-namespace.c (cp_lookup_symbol_nonlocal): call
	cp_lookup_symbol_namespace.
	(cp_lookup_symbol_namespace): Perform an import lookup at every
	block level.
	(cp_lookup_symbol_imports): New function.
	(cp_lookup_symbol_in_namespace): New function.
@
text
@a5009 2
      /* FIXME: TYPE_CODE_CLASS is currently defined to TYPE_CODE_STRUCT
         in gdbtypes.h.  */
d5013 3
@


1.351
log
@gdb
	PR symtab/11199:
	* dwarf2read.c (quirk_gcc_member_function_pointer): Change return
	type and arguments.  Use smash_to_methodptr_type.
	(read_structure_type): Call quirk_gcc_member_function_pointer
	later.
	* gdbtypes.h (smash_to_methodptr_type): Declare.
	* gdbtypes.c (smash_to_methodptr_type): New function.
	(lookup_methodptr_type): Use it.
gdb/testsuite
2010-01-22  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR symtab/11199:
	* gdb.dwarf2/member-ptr-forwardref.exp,
	gdb.dwarf2/member-ptr-forwardref.S: New.
@
text
@d3955 1
a3955 1
  if (local_symbols != NULL)
@


1.350
log
@	PR c++/11026:
	* dwarf2read.c (read_partial_die): Allocate partial DIE's name on
	objfile obstack.
@
text
@d4895 2
a4896 3
   functions, with the ABI-specified layout.  If DIE (from CU) describes
   such a structure, set its type, and return nonzero.  Otherwise return
   zero.
d4901 2
a4902 2
static struct type *
quirk_gcc_member_function_pointer (struct die_info *die, struct dwarf2_cu *cu)
d4904 1
a4904 5
  struct objfile *objfile = cu->objfile;
  struct type *type;
  struct die_info *pfn_die, *delta_die;
  struct attribute *pfn_name, *delta_name;
  struct type *pfn_type, *domain_type;
d4907 2
a4908 7
  if (die->tag != DW_TAG_structure_type
      || dwarf2_attr (die, DW_AT_name, cu) != NULL
      || die->child == NULL
      || die->child->sibling == NULL
      || (die->child->sibling->sibling != NULL
	  && die->child->sibling->sibling->tag != DW_TAG_padding))
    return NULL;
d4911 5
a4915 15
  pfn_die = die->child;
  pfn_name = dwarf2_attr (pfn_die, DW_AT_name, cu);
  if (pfn_die->tag != DW_TAG_member
      || pfn_name == NULL
      || DW_STRING (pfn_name) == NULL
      || strcmp ("__pfn", DW_STRING (pfn_name)) != 0)
    return NULL;

  delta_die = pfn_die->sibling;
  delta_name = dwarf2_attr (delta_die, DW_AT_name, cu);
  if (delta_die->tag != DW_TAG_member
      || delta_name == NULL
      || DW_STRING (delta_name) == NULL
      || strcmp ("__delta", DW_STRING (delta_name)) != 0)
    return NULL;
d4918 1
a4918 1
  pfn_type = die_type (pfn_die, cu);
d4922 1
a4922 1
    return NULL;
d4927 1
d4929 1
a4929 1
    return NULL;
d4932 2
a4933 2
  type = alloc_type (objfile);
  smash_to_method_type (type, domain_type, TYPE_TARGET_TYPE (pfn_type),
d4936 1
a4936 2
  type = lookup_methodptr_type (type);
  return set_die_type (die, type, cu);
a4963 4
  type = quirk_gcc_member_function_pointer (die, cu);
  if (type)
    return type;

d5142 2
@


1.349
log
@gdb
	PR c++/8000:
	* dwarf2read.c (partial_die_parent_scope): Put enumeration type
	into parent scope, and enumerator into grandparent scope.
gdb/testsuite
	PR c++/8000:
	* gdb.cp/namespace.exp: Use new enum.  Fix line numbers in
	existing tests.
	* gdb.cp/namespace.cc (AAA::SomeEnum): New enum.
	(main): Use AAA::SomeEnum.
@
text
@d6784 1
a6784 1
					    &cu->comp_unit_obstack);
@


1.348
log
@Delete free_named_symtabs and associated cleanup.

        * symfile.h (free_named_symtabs): Delete declaration.
        * symfile.c: Remove some commented out code (clear_symtab_users_once).
        (cashier_psymtab): Comment function out.
        Delete declaration.
        (free_named_symtabs): Delete.
        * coffread.c (coff_end_symtab): Remove call to free_named_symtabs.
        * dbxread.c (end_psymtab): Likewise.
        * dwarf2read.c (process_psymtab_comp_unit): Ditto.
        * exec.c (exec_close_1): Ditto.
        * xcoffread.c (xcoff_end_psymtab): Likewise.
@
text
@d2389 2
a2390 1
      || parent->tag == DW_TAG_union_type)
d2398 1
a2398 1
  else if (parent->tag == DW_TAG_enumeration_type)
@


1.347
log
@gdb/ChangeLog:

        Add support for DW_AT_GNAT_descriptive_type.
        * gdbtypes.h (enum type_specific_kind): New enum.
        (struct main_type) [type_specific_field]: New component.
        [type_specific]: Add new component "gnat_stuff".
        (struct gnat_aux_type): New type.
        (INIT_CPLUS_SPECIFIC): Also set TYPE_SPECIFIC_FIELD (type).
        (HAVE_CPLUS_STRUCT): Also check TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default, allocate_gnat_aux_type): Add declaration.
        (INIT_GNAT_SPECIFIC, ALLOCATE_GNAT_AUX_TYPE, HAVE_GNAT_AUX_INFO)
        (TYPE_SPECIFIC_FIELD): New macros.
        (TYPE_CPLUS_SPECIFIC): Return cplus_struct_default if the given
        type does not hold any cplus-specific data.
        (TYPE_RAW_CPLUS_SPECIFIC): New macro.
        (TYPE_GNAT_SPECIFIC, TYPE_DESCRIPTIVE_TYPE): New macros.
        (TYPE_IS_OPAQUE): Use HAVE_CPLUS_STRUCT to check if type has
        cplus-specific data.
        * gdbtypes.c (allocate_cplus_struct_type): Minor stylistic rewrite.
        Set new component TYPE_SPECIFIC_FIELD (type).
        (gnat_aux_default): New constant.
        (allocate_gnat_aux_type): New function.
        (init_type): Add initialization the type-specific stuff for
        TYPE_CODE_FLT and TYPE_CODE_FUNC types.
        (print_gnat_stuff): New function.
        (recursive_dump_type): Use HAVE_CPLUS_STRUCT to check for cplus-
        specific data.  Adjust code that prints the contents of the
        type-specific union using the TYPE_SPECIFIC_FIELD value.
        * dwarf2read.c (dwarf2_attach_fields_to_type): Do not allocate
        the type cplus stuff for Ada types.
        (dwarf2_add_member_fn, dwarf2_attach_fn_fields_to_type):
        Error out if these routines are called with an Ada type.
        (read_structure_type, read_array_type, read_subrange_type):
        Add call to set_descriptive_type.
        (set_die_type): Initialize the gnat-specific data if necessary.
        (need_gnat_info, die_descriptive_type, set_descriptive_type):
        New functions.
        * ada-lang.c (decode_constrained_packed_array_type): Use
        decode_constrained_packed_array_type instead of doing a standard
        lookup to locate a parallel type.
        (find_parallel_type_by_descriptive_type): New function.
        (ada_find_parallel_type_with_name): New function.
        (ada_find_parallel_type): Reimplement using
        ada_find_parallel_type_with_name.
        * ada-valprint.c (print_field_values): Use HAVE_CPLUS_STRUCT
        to check if type has a cplus stuff.
        * linespec.c (total_number_of_methods): Likewise.
        * mdebugread.c (new_type): Likewise.

gdb/testsuite/ChangeLog:

        * gdb.base/maint.exp: Adjust the expected output for the
        "maint print type" test. Use gdb_test_multiple instead of
        gdb_sent/gdb_expect.
@
text
@a2018 6
  /* If there is already a psymtab or symtab for a file of this
     name, remove it. (If there is a symtab, more drastic things
     also happen.) This happens in VxWorks.  */
  if (! this_cu->from_debug_types)
    free_named_symtabs (pst->filename);

@


1.346
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d929 7
d4574 1
a4574 1
  if (fip->non_public_fields)
d4593 1
a4593 1
  if (fip->nbaseclasses)
d4627 2
a4628 1
	  SET_TYPE_FIELD_PRIVATE (type, nfields);
d4632 2
a4633 1
	  SET_TYPE_FIELD_PROTECTED (type, nfields);
d4653 2
d4678 3
d4854 3
d5058 2
d5473 2
d6137 2
d8794 61
d11811 13
@


1.345
log
@	* NEWS: Document "info variables" change.
	* dwarf2read.c (new_symbol): Add file-scope external unresolved
	symbols to global_symbols.
	* symtab.c (search_symbols): Skip LOC_UNRESOLVED symbols.

	doc/
	* gdb.texinfo (Symbols): "info variables" prints definitions, not
	declarations.
@
text
@d4 1
a4 1
                 2004, 2005, 2006, 2007, 2008, 2009
@


1.344
log
@* dwarf2read.c (read_subroutine_type): Add the subroutine type to the
die immediately to allow a parameter type to be the same subroutine type.
@
text
@d8466 7
d8474 1
a8474 1
		  add_symbol_to_list (sym, cu->list_in_scope);
@


1.343
log
@* dwarf2read.c (struct attribute): Increase sizes of unsnd and snd
fields to allow larger integer sizes.
(read_subrange_type): Increase size of bound values.
Add logic to determine signedness based on base-type size, signedness.
(read_attribute_value): Change format for bad byte size in message.
(read_8_bytes): Increase size of result type.
(dump_die_shallow): Change format for value.
(dwarf2_get_attr_constant_value): Increase size of return type.
Correct comment.
* gdbtypes.c (create_range_type): Change API to increase size of
bounds. struct field -> union field.
Always take signedness from base type.
(check_typedef): Use new API for TYPE_LOW_BOUND, TYPE_HIGH_BOUND.
(recursive_dump_type, copy_type_recursive): Adjust to new
representation of range types.
* gdbtypes.h (fields_or_bounds): New union containing struct field and
new struct range_bounds, used for range types.
(TYPE_RANGE_DATA): New macro to access range_bounds member.
(TYPE_LOW_BOUND, TYPE_HIGH_BOUND): Represent with new TYPE_RANGE_DATA.
(TYPE_LOW_BOUND_UNDEFINED, TYPE_HIGH_BOUND_UNDEFINED): New macros,
taking over the job of TYPE_FIELD_ARTIFICIAL for range bounds.
(SET_TYPE_LOW_BOUND, SET_TYPE_HIGH_BOUND, SET_TYPE_LOW_BOUND_DEFINED)
(SET_TYPE_HIGH_BOUND_DEFINED): New macros.
(TYPE_FIELDS, TYPE_BASECLASS, TYPE_BASECLASS_NAME, TYPE_FIELD)
(TYPE_ARRAY_UPPER_BOUND_IS_UNDEFINED)
(TYPE_ARRAY_LOWER_BOUND_IS_UNDEFINED, TYPE_ARRAY_UPPER_BOUND_VALUE)
(TYPE_ARRAY_LOWER_BOUND_VALUE):	Adjust to new representation.
(create_range_type): Adjust API.
* ada-lang.c (ada_modulus): Use new extended bound values.
(discrete_type_low_bound): Rename to...
(ada_discrete_type_low_bound): ... and make external.
(discrete_type_high_bound): Rename to...
(ada_discrete_type_high_bound): ... and make external.
(ada_value_slice_from_ptr, ada_array_bound_from_type)
(ada_evaluate_subexp, to_fixed_range_type):
Use ada_discrete_type_low_bound, ada_discrete_type_high_bound.
* ada-typeprint.c (print_range): Use ada_discrete_type_low_bound,
ada_discrete_type_high_bound.  Don't look at field count, which
is no longer meaningful.  Print bounds whenever argument is a range
or enumeration.
* ada-lang.h (ada_discrete_type_low_bound,ada_discrete_type_high_bound):
Declare.
* varobj.c (c_describe_child): Adjust to render larger values.
* mdebugread.c (parse_type): Use proper abstractions for range types:
TYPE_RANGE_DATA, SET_TYPE_LOW_BOUND_DEFINED,
SET_TYPE_HIGH_BOUND_DEFINED.
* p-typeprint.c (pascal_type_print_varspec_prefix): Use larger format
for bounds.
@
text
@d5882 5
d5934 1
a5934 1
  return set_die_type (die, ftype, cu);
@


1.342
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* symfile.h (dwarf2_build_psymtabs): Remove mainline parameter in
	prototype.
	* dwarf2read.c (dwarf2_build_psymtabs): Remove mainline paramter in
	definition, simplify code assuming it is always 0.
	* coffread.c (coff_symfile_read): Adjust call.
	* elfread.c (elf_symfile_read): Ditto.
	* machoread.c (macho_symfile_read): Explicitely calls
	init_psymbol_list if mainline is set.
@
text
@d552 2
a553 2
	unsigned long unsnd;
	long int snd;
d1068 1
a1068 1
static int dwarf2_get_attr_constant_value (struct attribute *, int);
d6044 2
a6045 2
  int low = 0;
  int high = -1;
d6047 1
d6094 7
d7138 2
a7139 2
         _("Suspicious DW_AT_byte_size value treated as zero instead of 0x%lx"),
         DW_UNSND (attr));
d10118 2
a10119 1
	  fprintf_unfiltered (f, "constant: %ld", DW_UNSND (&die->attrs[i]));
d10242 2
a10243 2
/* Return the constant value held by the given attribute.  Return -1
   if the value held by the attribute is not constant.  */
d10245 1
a10245 1
static int
@


1.341
log
@2009-12-02  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2read.c (dwarf2_build_psymtabs_easy): Remove mainline parameter.
	(dwarf2_build_psymtabs_hard): Ditto.
	(dwarf2_build_psymtabs): Ajust calls.
	* stabsread.h (elfstab_build_psymtabs): Remove mainline parameter on
	the prototype.
	(coffstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* dbxread.c (coffstab_build_psymtabs): Remove mainline parameter on
	the definition.
	(elfstab_build_psymtabs): Ditto.
	(stabsect_build_psymtabs): Ditto.
	* coffread.c (coff_symfile_read): Adjust call.
	* elfread.c (elf_symfile_read): Ditto.
	* somread.c (som_symfile_read): Ditto.
@
text
@d1451 1
a1451 1
dwarf2_build_psymtabs (struct objfile *objfile, int mainline)
d1464 1
a1464 3
  if (mainline
      || (objfile->global_psymbols.size == 0
	  && objfile->static_psymbols.size == 0))
@


1.340
log
@2009-11-23  Rainer Orth  <ro@@CeBiTec.Uni-Bielefeld.DE>

	* dwarf2read.c [HAVE_MMAP] (MAP_FAILED): Define if missing.
@
text
@d772 1
a772 1
static void dwarf2_build_psymtabs_easy (struct objfile *, int);
d782 1
a782 1
static void dwarf2_build_psymtabs_hard (struct objfile *, int);
d1477 1
a1477 1
      dwarf2_build_psymtabs_easy (objfile, mainline);
d1484 1
a1484 1
      dwarf2_build_psymtabs_hard (objfile, mainline);
d1493 1
a1493 1
dwarf2_build_psymtabs_easy (struct objfile *objfile, int mainline)
d2078 1
a2078 1
dwarf2_build_psymtabs_hard (struct objfile *objfile, int mainline)
@


1.339
log
@	* dwarf2read.c (find_partial_die): Don't reassign to 'back_to'.
@
text
@d61 3
@


1.338
log
@	* xcoffread.c (scan_xcoff_symtab): Update.
	* symfile.h (add_psymbol_to_list): Update prototype.
	* symfile.c (add_psymbol_to_bcache): Add copy_name argument.
	(add_psymbol_to_list): Likewise.
	* stabsread.c (define_symbol): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	(handle_psymbol_enumerators): Update.
	(new_symbol): Update.
	* dbxread.c (read_dbx_symtab): Update.
	* coffread.c (process_coff_symbol): Update.
	* symtab.h (prim_record_minimal_symbol_full): Declare.
	(SYMBOL_SET_NAMES): Add copy_name argument.
	* symtab.c (struct demangled_name_entry): New struct.
	(hash_demangled_name_entry): New function.
	(eq_demangled_name_entry): Likewise.
	(create_demangled_names_hash): Use new functions.
	(symbol_set_names): Use struct demangled_name_entry.  Add
	copy_name argument.
	* minsyms.c (prim_record_minimal_symbol_full): New function.
	(prim_record_minimal_symbol_and_info): Use it.
	* elfread.c (record_minimal_symbol): Add name_len and copy_name
	arguments.  Call prim_record_minimal_symbol_full.
	(elf_symtab_read): Add copy_names argument.
	(elf_symfile_read): Update calls to elf_symtab_read.
	* dwarf2read.c (add_partial_symbol): Don't copy symbol names.
	(load_partial_dies): Likewise.
	(new_symbol): Likewise.
	* cp-namespace.c (check_one_possible_namespace_symbol): Don't save
	name on the obstack.  Update call to SYMBOL_SET_NAMES.
@
text
@d6917 1
a6917 1
	  back_to = make_cleanup (dwarf2_free_abbrev_table, per_cu->cu);
@


1.337
log
@2009-11-12  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Paul Brook  <paul@@codesourcery.com>

	* c-typeprint.c (c_type_print_base): Skip artificial fields.
	Use get_vptr_fieldno to skip the vtable pointer.
	* dwarf2read.c (dwarf2_add_field): Set FIELD_ARTIFICIAL on artificial
	fields.
	(dwarf2_add_member_fn): Complain about virtual member functions
	without DW_AT_vtable_elem_location and force TYPE_CPLUS_DYNAMIC.
	* gdbtypes.c (get_vptr_fieldno): Update comment.
	* gdbtypes.h (struct cplus_struct_type): Add is_dynamic.
	(TYPE_CPLUS_DYNAMIC): New macro.
	* gnu-v3-abi.c (gnuv3_dynamic_class): New.
	(gnuv3_get_vtable): Rewrite to use gnuv3_dynamic_class.  Move higher.
	(gnuv3_rtti_type, gnuv3_get_virtual_fn, gnuv3_baseclass_offset): Use
	gnuv3_get_vtable.
	* varobj.c (cplus_class_num_children, cplus_describe_child): Skip
	artificial fields.  Use get_vptr_fieldno to skip the vtable pointer.
@
text
@d2463 1
d2474 1
d2501 1
d2520 1
d2531 1
d2538 1
d2563 1
d2574 1
d6583 1
a6583 1
	    add_psymbol_to_list (part_die->name, strlen (part_die->name),
d6604 1
a6604 1
	    add_psymbol_to_list (part_die->name, strlen (part_die->name),
d8336 1
a8336 1
      SYMBOL_SET_NAMES (sym, name, strlen (name), objfile);
@


1.336
log
@Correct whitespace in previous patch.
@
text
@d4487 1
d4807 12
@


1.335
log
@2009-11-12  Paul Brook  <paul@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* dwarf2read.c (dwarf2_add_member_fn): Calculate virtual function
	offset for classes without DW_AT_containing_type.
@
text
@d4788 1
a4788 1
         for v3 classes, which always start with the vtable pointer.  */
d4795 5
a4799 5
          fnp->voffset = decode_locdesc (&blk, cu);
          if ((fnp->voffset % cu->header.addr_size) != 0)
            dwarf2_complex_location_expr_complaint ();
          else
            fnp->voffset /= cu->header.addr_size;
@


1.334
log
@2009-11-12  Paul Brook  <paul@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* dwarf2read.c (struct field_info): Add baseclasses.
	(dwarf2_add_field): Add base classes to a separate list.
	(dwarf2_attach_fields_to_type): Merge base classes and fields.
@
text
@d4761 6
a4766 1
  /* Get index in virtual function table if it is a virtual member function.  */
d4768 1
a4768 1
  if (attr)
d4784 22
a4805 1
   }
d5067 2
a5068 1
	     class from the DW_AT_containing_type attribute.  */
@


1.333
log
@	* dwarf2read.c (process_psymtab_comp_unit): Initialize per_cu backlink
	at the same time as the forward link.
	(load_partial_comp_unit): Initialize per_cu links before calling
	init_cu_die_reader.
@
text
@d642 1
a642 1
     *fields;
d644 1
a644 1
    /* Number of fields.  */
d4360 11
a4370 2
  new_field->next = fip->fields;
  fip->fields = new_field;
d4593 15
a4607 2
      TYPE_FIELD (type, nfields) = fip->fields->field;
      switch (fip->fields->accessibility)
d4624 1
a4624 1
		       fip->fields->accessibility);
d4630 1
a4630 1
	  switch (fip->fields->virtuality)
a4637 1
      fip->fields = fip->fields->next;
@


1.332
log
@	* dwarf2read.c (read_import_statement): Don't clobber original cu.
@
text
@d1890 14
a1957 15
  /* If this compilation unit was already read in, free the
     cached copy in order to read it in again.	This is
     necessary because we skipped some symbols when we first
     read in the compilation unit (see load_partial_dies).
     This problem could be avoided, but the benefit is
     unclear.  */
  if (this_cu->cu != NULL)
    free_one_cached_comp_unit (this_cu->cu);

  /* Note that this is a pointer to our stack frame, being
     added to a global data structure.	It will be cleaned up
     in free_stack_comp_unit when we finish with this
     compilation unit.	*/
  this_cu->cu = &cu;

d2155 5
a2184 5
  /* Link this compilation unit into the compilation unit tree.  */
  this_cu->cu = cu;
  cu->per_cu = this_cu;
  cu->type_hash = this_cu->type_hash;

@


1.331
log
@	* dwarf2read.c (struct dwarf2_cu): Remove ranges_offset and
	has_ranges_offset.
	(struct partial_die_info): Remove language, has_stmt_list, dirname,
	and line_offset.
	(dwarf2_build_include_psymtabs): Take a die_info.  Handle a missing
	line table.
	(dwarf2_get_pc_bounds): Take PST argument.  Pass it
	to dwarf2_ranges_read.  Update all callers.
	(init_cu_die_reader): Move earlier.
	(dwarf2_find_base_address): New function.
	(process_psymtab_comp_unit): Rewrite to use a full DIE for the
	compilation unit.  Use dwarf2_get_pc_bounds and
	dwarf2_find_base_address.
	(load_comp_unit): Rewrite to use a full DIE for the compilation unit.
	(process_full_comp_unit): Use dwarf2_find_base_address.
	(read_partial_die): Remove support for attributes only used
	in the compilation unit DIE.
	* symfile.c (allocate_psymtab): Make FILENAME const.
	(start_psymtab_common): Likewise.
	* symfile.h (allocate_psymtab, start_psymtab_common): Update
	prototypes.
@
text
@d3375 1
d3389 3
a3391 2
  imported_die = follow_die_ref_or_sig (die, import_attr, &cu);
  imported_name = dwarf2_name (imported_die, cu);
d3436 1
a3436 1
  imported_name_prefix = determine_prefix (imported_die, cu);
@


1.330
log
@2009-10-14  Cary Coutant  <ccoutant@@google.com>

	* dwarf2read.c (read_import_statement): Call follow_die_ref_or_sig.
@
text
@a285 3
  /* `.debug_ranges' offset for this `DW_TAG_compile_unit' DIE.  */
  unsigned int ranges_offset;

a332 3

  /* Field `ranges_offset' is filled in; flag as the value may be zero.  */
  unsigned int has_ranges_offset : 1;
a470 4
    /* Language code associated with this DIE.  This is only used
       for the compilation unit DIE.  */
    unsigned int language : 8;

a476 1
    unsigned int has_stmt_list : 1;
a489 1
    char *dirname;
a511 3
    /* If HAS_STMT_LIST, the offset of the Line Number Information data.  */
    unsigned int line_offset;

d776 1
a776 1
                                           struct partial_die_info *,
d952 2
a953 1
				 CORE_ADDR *, CORE_ADDR *, struct dwarf2_cu *);
d1653 1
a1653 5
   partial symtab for each of these included files.
   
   This procedure assumes that there *is* a Line Number Program in
   the given CU.  Callers should check that PDI->HAS_STMT_LIST is set
   before calling this procedure.  */
d1657 1
a1657 1
                               struct partial_die_info *pdi,
d1662 2
a1663 1
  struct line_header *lh;
d1665 6
a1670 1
  lh = dwarf_decode_line_header (pdi->line_offset, abfd, cu);
d1801 45
d1862 1
a1862 1
  struct partial_die_info comp_unit_die;
a1866 1
  struct abbrev_info *abbrev;
d1868 5
d1890 2
d1899 3
a1901 3
  abbrev = peek_die_abbrev (info_ptr, &bytes_read, &cu);
  info_ptr = read_partial_die (&comp_unit_die, abbrev, bytes_read, abfd,
			       buffer, info_ptr, &cu);
d1909 1
a1909 1
  else if (comp_unit_die.tag == DW_TAG_partial_unit)
d1918 5
a1922 1
  set_cu_language (comp_unit_die.language, &cu);
d1925 1
d1927 1
a1927 1
			      comp_unit_die.name ? comp_unit_die.name : "",
d1933 3
a1935 4
  if (comp_unit_die.dirname)
    pst->dirname = obsavestring (comp_unit_die.dirname,
				 strlen (comp_unit_die.dirname),
				 &objfile->objfile_obstack);
a1952 2
  cu.per_cu = this_cu;

d1961 2
d1965 3
a1967 8
  if (cu.has_ranges_offset)
    {
      if (dwarf2_ranges_read (cu.ranges_offset, &comp_unit_die.lowpc,
			      &comp_unit_die.highpc, &cu, pst))
	comp_unit_die.has_pc_info = 1;
    }
  else if (comp_unit_die.has_pc_info
	   && comp_unit_die.lowpc < comp_unit_die.highpc)
d1971 2
a1972 2
		       comp_unit_die.lowpc + baseaddr,
		       comp_unit_die.highpc + baseaddr - 1, pst);
d1977 1
a1977 1
  if (comp_unit_die.has_children)
d1988 1
a1988 1
			    ! comp_unit_die.has_pc_info, &cu);
d1997 1
a1997 1
      if (! comp_unit_die.has_pc_info)
d1999 2
a2000 2
	  comp_unit_die.lowpc = lowpc;
	  comp_unit_die.highpc = highpc;
d2003 2
a2004 2
  pst->textlow = comp_unit_die.lowpc + baseaddr;
  pst->texthigh = comp_unit_die.highpc + baseaddr;
d2026 1
a2026 1
  else if (comp_unit_die.has_stmt_list)
d2030 1
a2030 1
      dwarf2_build_include_psymtabs (&cu, &comp_unit_die, pst);
d2139 1
a2139 1
  struct partial_die_info comp_unit_die;
a2140 1
  struct abbrev_info *abbrev;
d2143 3
d2170 3
a2172 3
  abbrev = peek_die_abbrev (info_ptr, &bytes_read, cu);
  info_ptr = read_partial_die (&comp_unit_die, abbrev, bytes_read, abfd,
			       dwarf2_per_objfile->info.buffer, info_ptr, cu);
d2175 5
a2179 1
  set_cu_language (comp_unit_die.language, cu);
d2189 1
a2189 1
  if (comp_unit_die.has_children)
a3214 1
  struct attribute *attr;
d3224 1
a3224 24
  /* Find the base address of the compilation unit for range lists and
     location lists.  It will normally be specified by DW_AT_low_pc.
     In DWARF-3 draft 4, the base address could be overridden by
     DW_AT_entry_pc.  It's been removed, but GCC still uses this for
     compilation units with discontinuous ranges.  */

  cu->base_known = 0;
  cu->base_address = 0;

  attr = dwarf2_attr (cu->dies, DW_AT_entry_pc, cu);
  if (attr)
    {
      cu->base_address = DW_ADDR (attr);
      cu->base_known = 1;
    }
  else
    {
      attr = dwarf2_attr (cu->dies, DW_AT_low_pc, cu);
      if (attr)
	{
	  cu->base_address = DW_ADDR (attr);
	  cu->base_known = 1;
	}
    }
d3838 1
a3838 1
  if (name == NULL || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
d3926 1
a3926 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
d4098 2
a4099 1
		      CORE_ADDR *highpc, struct dwarf2_cu *cu)
d4127 1
a4127 1
	  if (!dwarf2_ranges_read (DW_UNSND (attr), &low, &high, cu, NULL))
d4166 1
a4166 1
  if (dwarf2_get_pc_bounds (die, &low, &high, cu))
d4203 1
a4203 1
  if (dwarf2_get_pc_bounds (die, &current_low, &current_high, cu))
a6068 14
/* Initialize a die_reader_specs struct from a dwarf2_cu struct.  */

static void
init_cu_die_reader (struct die_reader_specs *reader,
		    struct dwarf2_cu *cu)
{
  reader->abfd = cu->objfile->obfd;
  reader->cu = cu;
  if (cu->per_cu->from_debug_types)
    reader->buffer = dwarf2_per_objfile->types.buffer;
  else
    reader->buffer = dwarf2_per_objfile->info.buffer;
}

a6644 9
  CORE_ADDR base_address = 0;
  enum
    {
      base_address_none,
      base_address_low_pc,
      /* Overrides BASE_ADDRESS_LOW_PC.  */
      base_address_entry_pc
    }
  base_address_type = base_address_none;
a6685 4
	case DW_AT_comp_dir:
	  if (part_die->dirname == NULL)
	    part_die->dirname = DW_STRING (&attr);
	  break;
a6691 6
	  if (part_die->tag == DW_TAG_compile_unit
	      && base_address_type < base_address_low_pc)
	    {
	      base_address = DW_ADDR (&attr);
	      base_address_type = base_address_low_pc;
	    }
a6696 15
	case DW_AT_entry_pc:
	  if (part_die->tag == DW_TAG_compile_unit
	      && base_address_type < base_address_entry_pc)
	    {
	      base_address = DW_ADDR (&attr);
	      base_address_type = base_address_entry_pc;
	    }
	  break;
	case DW_AT_ranges:
	  if (part_die->tag == DW_TAG_compile_unit)
	    {
	      cu->ranges_offset = DW_UNSND (&attr);
	      cu->has_ranges_offset = 1;
	    }
	  break;
a6712 3
	case DW_AT_language:
	  part_die->language = DW_UNSND (&attr);
	  break;
a6735 4
        case DW_AT_stmt_list:
          part_die->has_stmt_list = 1;
          part_die->line_offset = DW_UNSND (&attr);
          break;
a6776 7
  if (base_address_type != base_address_none && !cu->base_known)
    {
      gdb_assert (part_die->tag == DW_TAG_compile_unit);
      cu->base_known = 1;
      cu->base_address = base_address;
    }

@


1.329
log
@	* dwarf2read.c (dwarf2_const_value): Fix order of arguments to
	store_unsigned_integer.
@
text
@d3368 1
a3368 1
  imported_die = follow_die_ref (die, import_attr, &cu);
@


1.328
log
@	ARI fix: OP eol rule.
	* doublest.c (floatformat_from_length): Avoid operator at end of line.
	* dwarf2-frame.c (dwarf2_build_frame_info): Idem.
	* dwarf2read.c (read_array_order, dwarf_decode_macros): Idem.
	* eval.c (evaluate_subexp_standard): Idem.
	* event-loop.c (create_timer, handle_timer_event): Idem.
	* expprint.c (print_subexp_standard): Idem.
	* f-exp.y (variable): Idem.
	* f-typeprint.c (f_print_type): Idem.
@
text
@d8606 1
a8606 1
			      DW_ADDR (attr), byte_order);
@


1.327
log
@gdb/
	Fix gcc-4.5 HEAD warnings for enum ada_operator.
	* Makefile.in (HFILES_NO_SRCDIR): Add ada-operator.inc.
	* ada-lang.h (enum ada_operator): Move it to ...
	* ada-operator.inc: ... a new file.
	* expression.h (enum exp_opcode): Include ada-operator.inc.
	New element OP_UNUSED_LAST.  Update comment for OP_EXTENDED0.

gdb/
	Fix gcc-4.5 HEAD warnings for GDB_FORM_cached_string.
	* dwarf2read.c (GDB_FORM_cached_string)
	(dwarf_form_name <GDB_FORM_cached_string>): Remove.
	(struct attribute <dwarf_form>): Reduce the bit width.
	(struct attribute <string_is_canonical>, DW_STRING_IS_CANONICAL): New.
	(read_attribute_value <DW_FORM_string>)
	(read_attribute_value <DW_FORM_strp>): Initialize
	DW_STRING_IS_CANONICAL.
	(dwarf2_name, dump_die_shallow <DW_FORM_string>)
	(dump_die_shallow <DW_FORM_strp>): Update the code using former
	GDB_FORM_cached_string.
@
text
@d5386 2
a5387 2
  if (cu->language == language_fortran &&
      cu->producer && strstr (cu->producer, "GNU F77"))
d11159 5
a11163 4
			   macinfo_type ==
			   DW_MACINFO_define ? _("definition") : macinfo_type ==
			   DW_MACINFO_undef ? _("undefinition") :
			   "something-or-other", line, body);
d11170 5
a11174 4
			 macinfo_type ==
			 DW_MACINFO_define ? _("definition") : macinfo_type ==
			 DW_MACINFO_undef ? _("undefinition") :
			 "something-or-other",
@


1.327.2.1
log
@2009-11-23  Rainer Orth  <ro@@CeBiTec.Uni-Bielefeld.DE>

	* dwarf2read.c [HAVE_MMAP] (MAP_FAILED): Define if missing.
@
text
@a60 3
#ifndef MAP_FAILED
#define MAP_FAILED ((void *) -1)
#endif
@


1.326
log
@	* objfiles.c (struct objfile_data): Delete member cleanup and replace
	with save, free.
	(register_objfile_data_with_cleanup): Delete arg cleanup and replace
	with save, free.  All callers updated.
	(clear_objfile_data): Replace cleanup loop with separate save and
	free loops.
	* objfiles.h (register_objfile_data_with_cleanup): Update.
	* arm-tdep.c (arm_objfile_data_free): Renamed from
	arm_objfile_data_cleanup, all callers updated.
	* dwarf2read.c (dwarf2_per_objfile_free): Renamed from
	dwarf2_per_objfile_cleanup, all callers updated.
	* python/py-objfile.c (py_free_objfile): Renamed from clean_up_objfile,
	all callers updated.
	* python/py-type.c (save_objfile_types): Renamed from
	clean_up_objfile_types, all callers updated.
@
text
@a548 9
/* Additional GDB-specific attribute forms.  */
enum
  {
    /* A string which has been updated to GDB's internal
       representation (e.g. converted to canonical form) and does not
       need to be updated again.  */
    GDB_FORM_cached_string = 0xff
  };

d553 7
a559 1
    ENUM_BITFIELD(dwarf_form) form : 16;
d613 1
d7007 1
d7013 1
d9023 1
a9023 1
      if (attr->form != GDB_FORM_cached_string)
d9028 1
a9028 1
	  attr->form = GDB_FORM_cached_string;
a9538 2
    case GDB_FORM_cached_string:
      return "GDB_FORM_cached_string";
d10091 1
a10091 2
	case GDB_FORM_cached_string:
	  fprintf_unfiltered (f, "string: \"%s\"",
d10093 2
a10094 1
		   ? DW_STRING (&die->attrs[i]) : "");
@


1.325
log
@gdb/
	Support constant DW_AT_data_member_location by GCC PR debug/40659.
	* dwarf2read.c
	(dwarf2_add_field <DW_TAG_member> <DW_AT_data_member_location>):
	Initialize BYTE_OFFSET to 0 by default.  Explicitly check if
	attr_form_is_block.
	(dwarf2_add_field <DW_TAG_inheritance> <DW_AT_data_member_location>)
	(read_common_block <DW_AT_data_member_location>): New variable
	byte_offset.  Fix crash on non-DW_BLOCK ATTR values.

gdb/testsuite/
	Support constant DW_AT_data_member_location by GCC PR debug/40659.
	* gdb.dwarf2/dw2-inheritance.exp, gdb.dwarf2/dw2-inheritance.S: New.
@
text
@d11840 1
a11840 1
dwarf2_per_objfile_cleanup (struct objfile *objfile, void *d)
d11860 1
a11860 1
    = register_objfile_data_with_cleanup (dwarf2_per_objfile_cleanup);
@


1.324
log
@	Add support for "comdat types" from DWARF4.
	* dwarf2read.c (dwarf2_per_objfile): New member types,
	signatured_types.
	(TYPES_SECTION): New macro.
	(dwarf2_per_cu_data): Change size of length field from 30 bits
	to 29 bits.  New member from_debug_types.
	(signatured_type): New struct.
	(struct attribute): New union member signatured_type.
	(DW_SIGNATURED_TYPE): New macro.
	(dwarf2_attr_no_follow): New function.
	(read_type_unit_scope): New function.
	(follow_die_ref_or_sig, follow_die_sig): New functions.
	(dwarf2_locate_sectoins): Handle .debug_types.
	(dwarf2_build_psymtabs): Read .debug_types.
	(read_type_comp_unit_head): New function.
	(hash_type_signature, eq_type_signature): New functions.
	(create_debug_types_hash_table): New function.
	(lookup_signatured_type): New function.
	(process_psymtab_comp_unit): Handle type units too.
	(process_type_comp_unit, build_type_psymtabs): New functions.
	(dwarf2_build_psymtabs_hard): Call build_type_psymtabs.
	(load_partial_comp_unit): Assert not called for a type unit.
	(skip_one_die): Handle DW_FORM_sig8.
	(queue_comp_unit): Don't call load_full_comp_unit here, or
	update read_in_chain.
	(psymtab_to_symtab_1): Call read_signatured_type_at_offset for
	type units, or load_full_comp_unit for comp units after
	queue_comp_unit returns.
	(load_full_comp_unit): Assert not called for type units.
	(load_full_comp_unit): Update read_in_chain here.
	(process_die): Handle DW_TAG_type_unit.
	(read_structure_type): Look for signatured types.
	(read_enumeration_type): Ditto.
	(init_cu_die_reader): Handle .debug_types.
	(read_comp_unit): Assert hash not computed yet.
	(read_die_and_children): Expand debugging printf to handle .debug_types.
	(read_partial_die): Handle DW_TAG_type_unit:
	(find_patial_die): Handle .debug_types.
	(read_attribute_value): Handle DW_FORM_sig8.
	(die_type): Call follow_die_ref_or_sig instead of follow_die_ref.
	(die_containing_type): Ditto.
	(dwarf_tag_name): Handle DW_TAG_type_unit.
	(dwarf_attr_name): Handle DW_AT_signature.
	(dwarf_form_name): Handle DW_FORM_sec_offset, DW_FORM_exprloc,
	DW_FORM_flag_present, DW_FORM_sig8.
	(dump_die_shallow): Handlel DW_FORM_sig8.
	(maybe_queue_comp_unit): Change return type to int from void.
	All callers updated.
	(follow_die_ref): Handle .debug_types.
	(lookup_signatured_type_at_offset): New function.
	(read_signatured_type_at_offset): New function.
	(read_signatured_type): New function.
@
text
@d4388 1
a4388 1
          int byte_offset;
d4391 1
a4391 4
            {
              dwarf2_complex_location_expr_complaint ();
              byte_offset = 0;
            }
d4394 1
a4394 1
          else
d4396 2
d4492 14
a4505 2
	SET_FIELD_BITPOS (*fp, decode_locdesc (DW_BLOCK (attr), cu)
			       * bits_per_byte);
d5452 12
a5463 2
	      SYMBOL_VALUE_ADDRESS (sym) =
		base + decode_locdesc (DW_BLOCK (attr), cu);
@


1.323
log
@	Code reorg in preparation for adding comdat types support.
	* dwarf2read.c (struct die_reader_specs): New struct.
	(locate_pdi_sibling): New arg buffer.  All callers updated.
	(load_partial_dies, read_partial_die): Ditto.
	(read_8_bytes): Change return type to ULONGEST.
	(read_comp_unit): Delete arg abfd.  All callers updated.
	(read_die_and_children_1): Delete args abfd, cu.  New arg reader.
	All callers updated.
	(read_die_and_children, read_die_and_siblings): Ditto.
	(read_full_die): Ditto.  Move closer to callers.
	(skip_one_die): New arg buffer.  All callers updated.
	(load_full_comp_unit): Change return type to void.  All callers
	updated.
	(partial_read_comp_unit_head): New args buffer, buffer_size.
	All callers updated.
	(process_psymtab_comp_unit): New function, split out from
	dwarf2_build_psymtabs_hard.
	(dwarf2_build_psymtabs_hard): Call it.
	(load_partial_comp_unit): Renamed from load_comp_unit.
	All callers updated.
	(skip_children): New arg buffer.  All callers updated.
	(init_cu_die_reader): New function.
	(is_ref_attr): New function.
	(dwarf2_get_ref_die_offset): Call it.
	(alloc_one_comp_unit): New function.
@
text
@d167 1
d182 4
d207 1
d349 1
a349 1
  /* The start offset and length of this compilation unit.  2**30-1
d355 1
a355 1
  unsigned int length : 30;
d367 4
d386 16
d570 1
d620 1
d905 4
d959 2
d1083 4
d1091 10
d1268 5
d1472 1
d1611 23
d1693 124
a1816 1
/* Subroutine of dwarf2_build_psymtabs_hard to simplify it.
d1818 2
a1819 1
   BUFFER is a pointer to the beginning of the dwarf section buffer.
d1860 2
d1866 7
a1872 1
  if (comp_unit_die.tag == DW_TAG_partial_unit)
d1979 2
a1980 1
  free_named_symtabs (pst->filename);
d1985 6
a1990 1
  if (comp_unit_die.has_stmt_list)
d2002 34
d2054 2
d2109 2
d2851 1
a2986 6

  /* Either PER_CU is the CU we want to process, or we're following a reference
     pointing into PER_CU.  Either way, we need its DIEs now.  */
  load_full_comp_unit (item->per_cu, objfile);
  item->per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
  dwarf2_per_objfile->read_in_chain = item->per_cu;
d3081 5
d3108 2
d3149 4
d3244 3
d3568 79
d4876 16
d5106 12
d6037 4
a6040 1
  reader->buffer = dwarf2_per_objfile->info.buffer;
d6050 1
d6079 8
a6086 1
      fprintf_unfiltered (gdb_stdlog, "Read die from .debug_info:\n");
d6118 1
a6118 3
    {
      die->child = read_die_and_siblings (reader, cur_ptr, new_info_ptr, die);
    }
d6194 4
a6197 5
    {
      error (_("Dwarf Error: could not find abbrev number %d [in module %s]"),
	     abbrev_number,
	     bfd_get_filename (abfd));
    }
d6653 1
d6816 4
a6819 1
/* Find a partial DIE at OFFSET, which may or may not be in CU.  */
d6827 8
d6888 2
d7043 8
d7513 19
d8687 2
a8688 2
  else
    type_die = follow_die_ref (die, type_attr, &cu);
d8713 1
a8713 1
      type_die = follow_die_ref (die, type_attr, &cu);
d9152 2
d9369 3
d9510 8
d10063 7
d10207 3
a10209 1
   unit and add it to our queue.  */
d10211 1
a10211 1
static void
d10221 1
a10221 1
    return;
d10228 1
a10228 1
      return;
d10233 26
d10274 2
d10278 10
a10287 1
  if (! offset_in_cu_p (&cu->header, offset))
d10293 2
a10294 1
      maybe_queue_comp_unit (cu, per_cu);
d10307 158
a10464 3
  error (_("Dwarf Error: Cannot find DIE at 0x%lx referenced from DIE "
	 "at 0x%lx [in module %s]"),
	 (long) offset, (long) src_die->offset, cu->objfile->name);
d11400 2
a11401 2
/* Locate the compilation unit from CU's objfile which contains the
   DIE at OFFSET.  Raises an error on failure.  */
@


1.322
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d376 19
d489 1
a489 1
    /* Pointer into the info_buffer pointing at the target of
d560 1
a560 1
    /* Offset in .debug_info section */
d795 2
a796 3
                                     gdb_byte *info_ptr,
                                     bfd *abfd,
                                     struct dwarf2_cu *cu);
d812 3
a814 2
static struct partial_die_info *load_partial_dies (bfd *, gdb_byte *, int,
						   struct dwarf2_cu *);
d817 4
a820 2
                                   struct abbrev_info *abbrev, unsigned int,
                                   bfd *, gdb_byte *, struct dwarf2_cu *);
a827 3
static gdb_byte *read_full_die (struct die_info **, bfd *, gdb_byte *,
                                struct dwarf2_cu *, int *);

d842 1
a842 1
static unsigned long read_8_bytes (bfd *, gdb_byte *);
d980 1
a980 1
static struct die_info *read_comp_unit (gdb_byte *, bfd *, struct dwarf2_cu *);
d982 2
a983 2
static struct die_info *read_die_and_children_1 (gdb_byte *info_ptr, bfd *abfd,
						 struct dwarf2_cu *,
d987 2
a988 2
static struct die_info *read_die_and_children (gdb_byte *info_ptr, bfd *abfd,
					       struct dwarf2_cu *,
d992 2
a993 2
static struct die_info *read_die_and_siblings (gdb_byte *info_ptr, bfd *abfd,
					       struct dwarf2_cu *,
d997 4
d1043 2
d1079 3
a1081 2
static gdb_byte *skip_one_die (gdb_byte *info_ptr, struct abbrev_info *abbrev,
                               struct dwarf2_cu *cu);
d1095 2
d1110 2
a1111 2
static struct dwarf2_cu *load_full_comp_unit (struct dwarf2_per_cu_data *,
					      struct objfile *);
d1494 3
a1496 2
/* Read in the comp unit header information from the debug_info at
   info_ptr.  */
d1527 1
d1543 1
a1543 1
	   (long) (beg_of_comp_unit - dwarf2_per_objfile->info.buffer),
d1547 1
a1547 1
      > dwarf2_per_objfile->info.buffer + dwarf2_per_objfile->info.size)
d1551 1
a1551 1
	   (long) (beg_of_comp_unit - dwarf2_per_objfile->info.buffer),
d1616 170
a1796 3
  gdb_byte *beg_of_comp_unit;
  struct partial_die_info comp_unit_die;
  struct partial_symtab *pst;
a1797 1
  CORE_ADDR baseaddr;
d1807 2
a1808 2
  objfile->psymtabs_addrmap = addrmap_create_mutable
						    (&objfile->objfile_obstack);
d1823 1
a1826 4
      struct cleanup *back_to_inner;
      struct dwarf2_cu cu;
      struct abbrev_info *abbrev;
      unsigned int bytes_read;
d1829 2
a1830 109
      beg_of_comp_unit = info_ptr;

      memset (&cu, 0, sizeof (cu));

      obstack_init (&cu.comp_unit_obstack);

      back_to_inner = make_cleanup (free_stack_comp_unit, &cu);

      cu.objfile = objfile;
      info_ptr = partial_read_comp_unit_head (&cu.header, info_ptr, abfd);

      /* Complete the cu_header */
      cu.header.offset = beg_of_comp_unit - dwarf2_per_objfile->info.buffer;
      cu.header.first_die_offset = info_ptr - beg_of_comp_unit;

      cu.list_in_scope = &file_symbols;

      /* Read the abbrevs for this compilation unit into a table */
      dwarf2_read_abbrevs (abfd, &cu);
      make_cleanup (dwarf2_free_abbrev_table, &cu);

      this_cu = dwarf2_find_comp_unit (cu.header.offset, objfile);

      /* Read the compilation unit die */
      abbrev = peek_die_abbrev (info_ptr, &bytes_read, &cu);
      info_ptr = read_partial_die (&comp_unit_die, abbrev, bytes_read,
				   abfd, info_ptr, &cu);

      if (comp_unit_die.tag == DW_TAG_partial_unit)
	{
	  info_ptr = (beg_of_comp_unit + cu.header.length
		      + cu.header.initial_length_size);
	  do_cleanups (back_to_inner);
	  continue;
	}

      /* Set the language we're debugging */
      set_cu_language (comp_unit_die.language, &cu);

      /* Allocate a new partial symbol table structure */
      pst = start_psymtab_common (objfile, objfile->section_offsets,
				  comp_unit_die.name ? comp_unit_die.name : "",
				  /* TEXTLOW and TEXTHIGH are set below.  */
				  0,
				  objfile->global_psymbols.next,
				  objfile->static_psymbols.next);

      if (comp_unit_die.dirname)
	pst->dirname = obsavestring (comp_unit_die.dirname,
				     strlen (comp_unit_die.dirname),
				     &objfile->objfile_obstack);

      pst->read_symtab_private = (char *) this_cu;

      baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

      /* Store the function that reads in the rest of the symbol table */
      pst->read_symtab = dwarf2_psymtab_to_symtab;

      /* If this compilation unit was already read in, free the
	 cached copy in order to read it in again.  This is
	 necessary because we skipped some symbols when we first
	 read in the compilation unit (see load_partial_dies).
	 This problem could be avoided, but the benefit is
	 unclear.  */
      if (this_cu->cu != NULL)
	free_one_cached_comp_unit (this_cu->cu);

      cu.per_cu = this_cu;

      /* Note that this is a pointer to our stack frame, being
	 added to a global data structure.  It will be cleaned up
	 in free_stack_comp_unit when we finish with this
	 compilation unit.  */
      this_cu->cu = &cu;

      this_cu->psymtab = pst;

      /* Possibly set the default values of LOWPC and HIGHPC from
         `DW_AT_ranges'.  */
      if (cu.has_ranges_offset)
	{
	  if (dwarf2_ranges_read (cu.ranges_offset, &comp_unit_die.lowpc,
				  &comp_unit_die.highpc, &cu, pst))
	    comp_unit_die.has_pc_info = 1;
	}
      else if (comp_unit_die.has_pc_info
	       && comp_unit_die.lowpc < comp_unit_die.highpc)
	/* Store the contiguous range if it is not empty; it can be empty for
	   CUs with no code.  */
	addrmap_set_empty (objfile->psymtabs_addrmap,
			   comp_unit_die.lowpc + baseaddr,
			   comp_unit_die.highpc + baseaddr - 1, pst);

      /* Check if comp unit has_children.
         If so, read the rest of the partial symbols from this comp unit.
         If not, there's no more debug_info for this comp unit. */
      if (comp_unit_die.has_children)
	{
	  struct partial_die_info *first_die;
	  CORE_ADDR lowpc, highpc;

	  lowpc = ((CORE_ADDR) -1);
	  highpc = ((CORE_ADDR) 0);

	  first_die = load_partial_dies (abfd, info_ptr, 1, &cu);

	  scan_partial_symbols (first_die, &lowpc, &highpc,
				! comp_unit_die.has_pc_info, &cu);
d1832 4
a1835 38
	  /* If we didn't find a lowpc, set it to highpc to avoid
	     complaints from `maint check'.  */
	  if (lowpc == ((CORE_ADDR) -1))
	    lowpc = highpc;

	  /* If the compilation unit didn't have an explicit address range,
	     then use the information extracted from its child dies.  */
	  if (! comp_unit_die.has_pc_info)
	    {
	      comp_unit_die.lowpc = lowpc;
	      comp_unit_die.highpc = highpc;
	    }
	}
      pst->textlow = comp_unit_die.lowpc + baseaddr;
      pst->texthigh = comp_unit_die.highpc + baseaddr;

      pst->n_global_syms = objfile->global_psymbols.next -
	(objfile->global_psymbols.list + pst->globals_offset);
      pst->n_static_syms = objfile->static_psymbols.next -
	(objfile->static_psymbols.list + pst->statics_offset);
      sort_pst_symbols (pst);

      /* If there is already a psymtab or symtab for a file of this
         name, remove it. (If there is a symtab, more drastic things
         also happen.) This happens in VxWorks.  */
      free_named_symtabs (pst->filename);

      info_ptr = beg_of_comp_unit + cu.header.length
                                  + cu.header.initial_length_size;

      if (comp_unit_die.has_stmt_list)
        {
          /* Get the list of files included in the current compilation unit,
             and build a psymtab for each of them.  */
          dwarf2_build_include_psymtabs (&cu, &comp_unit_die, pst);
        }

      do_cleanups (back_to_inner);
d1844 1
a1844 1
/* Load the DIEs for a secondary CU into memory.  */
d1847 2
a1848 1
load_comp_unit (struct dwarf2_per_cu_data *this_cu, struct objfile *objfile)
d1861 1
a1861 2
  cu = xmalloc (sizeof (struct dwarf2_cu));
  memset (cu, 0, sizeof (struct dwarf2_cu));
d1863 1
a1863 1
  obstack_init (&cu->comp_unit_obstack);
d1865 4
a1868 2
  cu->objfile = objfile;
  info_ptr = partial_read_comp_unit_head (&cu->header, info_ptr, abfd);
d1871 1
a1871 1
  cu->header.offset = beg_of_comp_unit - dwarf2_per_objfile->info.buffer;
d1880 2
a1881 2
  info_ptr = read_partial_die (&comp_unit_die, abbrev, bytes_read,
			       abfd, info_ptr, cu);
d1889 1
a1889 1
  cu->type_hash = cu->per_cu->type_hash;
d1895 1
a1895 1
    load_partial_dies (abfd, info_ptr, 0, cu);
d2526 2
a2527 2
/* Scan the debug information for CU starting at INFO_PTR.  Returns a
   pointer to the end of a series of DIEs, terminated by an empty
d2531 1
a2531 1
skip_children (gdb_byte *info_ptr, struct dwarf2_cu *cu)
d2542 1
a2542 1
	info_ptr = skip_one_die (info_ptr + bytes_read, abbrev, cu);
d2546 2
a2547 2
/* Scan the debug information for CU starting at INFO_PTR.  INFO_PTR
   should point just after the initial uleb128 of a DIE, and the
d2553 2
a2554 2
skip_one_die (gdb_byte *info_ptr, struct abbrev_info *abbrev,
	      struct dwarf2_cu *cu)
d2571 1
a2571 2
	    return dwarf2_per_objfile->info.buffer
	      + dwarf2_get_ref_die_offset (&attr);
d2640 1
a2640 1
    return skip_children (info_ptr, cu);
d2645 3
a2647 2
/* Locate ORIG_PDI's sibling; INFO_PTR should point to the start of
   the next DIE after ORIG_PDI.  */
d2650 2
a2651 1
locate_pdi_sibling (struct partial_die_info *orig_pdi, gdb_byte *info_ptr,
d2666 1
a2666 1
  return skip_children (info_ptr, cu);
d2842 1
a2842 1
/* Load the DIEs associated with PST and PER_CU into memory.  */
d2844 1
a2844 1
static struct dwarf2_cu *
d2850 1
a2850 1
  gdb_byte *info_ptr;
d2859 1
d2861 1
a2861 2
  cu = xmalloc (sizeof (struct dwarf2_cu));
  memset (cu, 0, sizeof (struct dwarf2_cu));
d2866 2
a2867 1
  cu->objfile = objfile;
d2869 3
a2871 2
  /* read in the comp_unit header  */
  info_ptr = read_comp_unit_head (&cu->header, info_ptr, abfd);
d2873 1
a2873 1
  /* Read the abbrevs for this compilation unit  */
d2877 2
a2878 2
  cu->header.offset = offset;

a2879 1
  per_cu->cu = cu;
d2882 1
a2882 4
  /* We use this obstack for block values in dwarf_alloc_block.  */
  obstack_init (&cu->comp_unit_obstack);

  cu->dies = read_comp_unit (info_ptr, abfd, cu);
a2898 2

  return cu;
d4537 1
d5660 11
d5674 1
a5674 1
read_comp_unit (gdb_byte *info_ptr, bfd *abfd, struct dwarf2_cu *cu)
d5676 2
d5687 3
a5689 1
  return read_die_and_children (info_ptr, abfd, cu, &info_ptr, NULL);
d5696 2
a5697 2
read_die_and_children (gdb_byte *info_ptr, bfd *abfd,
		       struct dwarf2_cu *cu,
d5701 1
a5701 1
  struct die_info *result = read_die_and_children_1 (info_ptr, abfd, cu,
d5720 2
a5721 2
read_die_and_children_1 (gdb_byte *info_ptr, bfd *abfd,
			 struct dwarf2_cu *cu,
d5729 1
a5729 1
  cur_ptr = read_full_die (&die, abfd, info_ptr, cu, &has_children);
d5735 1
a5735 1
  store_in_ref_table (die, cu);
d5739 1
a5739 2
      die->child = read_die_and_siblings (cur_ptr, abfd, cu,
					  new_info_ptr, die);
d5757 2
a5758 2
read_die_and_siblings (gdb_byte *info_ptr, bfd *abfd,
		       struct dwarf2_cu *cu,
d5771 1
a5771 1
	= read_die_and_children_1 (cur_ptr, abfd, cu, &cur_ptr, parent);
d5788 49
d6013 2
a6014 2
load_partial_dies (bfd *abfd, gdb_byte *info_ptr, int building_psymtab,
		   struct dwarf2_cu *cu)
d6079 1
a6079 1
	  info_ptr = skip_one_die (info_ptr + bytes_read, abbrev, cu);
d6083 2
a6084 2
      info_ptr = read_partial_die (part_die, abbrev, bytes_read,
				   abfd, info_ptr, cu);
d6114 1
a6114 1
	  info_ptr = locate_pdi_sibling (part_die, info_ptr, abfd, cu);
d6139 1
a6139 1
	  info_ptr = locate_pdi_sibling (part_die, info_ptr, abfd, cu);
d6223 1
a6223 1
      info_ptr = locate_pdi_sibling (last_die, info_ptr, abfd, cu);
d6235 2
a6236 1
		  gdb_byte *info_ptr, struct dwarf2_cu *cu)
d6254 1
a6254 1
  part_die->offset = info_ptr - dwarf2_per_objfile->info.buffer;
d6367 1
a6367 2
	    part_die->sibling = dwarf2_per_objfile->info.buffer
	      + dwarf2_get_ref_die_offset (&attr);
d6457 1
a6457 1
      load_comp_unit (per_cu, cu->objfile);
d6487 2
a6488 1
				   per_cu->cu->objfile->obfd, info_ptr,
d6491 3
a6493 1
	load_partial_dies (per_cu->cu->objfile->obfd, info_ptr, 0, per_cu->cu);
a6547 46
/* Read the die from the .debug_info section buffer.  Set DIEP to
   point to a newly allocated die with its information, except for its
   child, sibling, and parent fields.  Set HAS_CHILDREN to tell
   whether the die has children or not.  */

static gdb_byte *
read_full_die (struct die_info **diep, bfd *abfd, gdb_byte *info_ptr,
	       struct dwarf2_cu *cu, int *has_children)
{
  unsigned int abbrev_number, bytes_read, i, offset;
  struct abbrev_info *abbrev;
  struct die_info *die;

  offset = info_ptr - dwarf2_per_objfile->info.buffer;
  abbrev_number = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
  info_ptr += bytes_read;
  if (!abbrev_number)
    {
      *diep = NULL;
      *has_children = 0;
      return info_ptr;
    }

  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
  if (!abbrev)
    {
      error (_("Dwarf Error: could not find abbrev number %d [in module %s]"),
	     abbrev_number,
	     bfd_get_filename (abfd));
    }
  die = dwarf_alloc_die (cu, abbrev->num_attrs);
  die->offset = offset;
  die->tag = abbrev->tag;
  die->abbrev = abbrev_number;

  die->num_attrs = abbrev->num_attrs;

  for (i = 0; i < abbrev->num_attrs; ++i)
    info_ptr = read_attribute (&die->attrs[i], &abbrev->attrs[i],
			       abfd, info_ptr, cu);

  *diep = die;
  *has_children = abbrev->has_children;
  return info_ptr;
}

d6736 1
a6736 1
static unsigned long
d9717 2
a9718 2
static unsigned int
dwarf2_get_ref_die_offset (struct attribute *attr)
a9719 2
  unsigned int result = 0;

d9728 1
a9728 2
      result = DW_ADDR (attr);
      break;
d9730 1
a9730 3
      complaint (&symfile_complaints,
		 _("unsupported die ref attribute form: '%s'"),
		 dwarf_form_name (attr->form));
d9732 12
a9743 1
  return result;
d10822 11
d10835 3
a10837 1
   the caller is responsible for that.  */
@


1.321
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d34 1
a34 1
#include "elf/dwarf2.h"
@


1.320
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d8079 2
d8096 1
a8096 1
			      DW_ADDR (attr));
@


1.319
log
@	* dwarf2read.c (inherit_abstract_dies): Work around GCC PR 40573.

	testsuite/
	* gdb.opt/inline-locals.exp: Remove XFAIL with duplicated arg1.
@
text
@d9537 1
a9537 1
	  fputs_filtered (paddress (DW_ADDR (&die->attrs[i])), f);
@


1.318
log
@2009-06-29  Sami Wagiaalla  <swagiaal@@redhat.com>

	* dwarf2read.c (read_import_statement): Properly set import location
	and destination.
	* cp-support.h (cp_add_using, cp_add_using_directive): Now take char*
	inner, char* outer arguments. Updated callers.

2009-06-29  Sami Wagiaalla  <swagiaal@@redhat.com>

	* gdb.cp/namespace-nested-import.cc: New test.
	* gdb.cp/namespace-nested-import.exp: New test.
@
text
@d3334 14
a3347 1
      attr = dwarf2_attr (child_die, DW_AT_abstract_origin, cu);
d3350 1
a3350 1
      if (attr)
a3351 3
	  struct die_info *child_origin_die;

	  child_origin_die = follow_die_ref (child_die, attr, &cu);
d3359 7
a3365 1
	  *offsets_end++ = child_origin_die->offset;
@


1.317
log
@	* gdbtypes.h (make_function_type): Remove OBJFILE parameter.
	* gdbtypes.c (make_function_type): Remove OBJFILE parameter.
	(lookup_function_type): Update call.
	* stabsread.c (read_type): Likewise.
	* dwarf2read.c (read_subroutine_type): Use lookup_function_type
	instead of make_function_type.
	* jv-lang.c (type_from_class): Likewise.  Do not allocate types
	on the fake "dynamics" obstack.
@
text
@d3046 3
d3099 21
a3119 2
  using_directives = cp_add_using (imported_name, strlen (imported_name), 0,
                                   using_directives);
d5078 1
a5078 3
	  cp_add_using_directive (TYPE_NAME (type),
				  strlen (previous_prefix),
				  strlen (TYPE_NAME (type)));
@


1.316
log
@	* gdbtypes.h (struct builtin_type): Remove builtin_core_addr,
	nodebug_text_symbol, nodebug_data_symbol, nodebug_unknown_symbol,
	and nodebug_tls_symbol members.
	(struct objfile_type): New data structure.
	(objfile_type): Add prototype.
	* gdbtypes.c (gdbtypes_post_init): Remove initialization code
	for types no longer in struct builtin_type.
	(objfile_type_data): New static variable.
	(_initialize_gdbtypes): Initialize it.
	(objfile_type): New function.

	* gdbtypes.h (builtin_type_error): Remove.
	* gdbtypes.c (build_complex): Do not use builtin_type_error.
	* symtab.c (builtin_type_error): Remove.
	(_initialize_symtab): Remove initialization.

	* stabsread.c (dbx_lookup_type, define_symbol, error_type,
	rs6000_builtin_type, read_range_type): Use per-objfile types
	instead of global or per-architecture builtin types.
	* coffread.c (decode_type): Likewise.
	* dwarf2read.c (read_array_type, read_tag_string_type,
	new_symbol, die_type): Likewise.
	* mdebugread.c (parse_symbol, basic_type, upgrade_type,
	parse_procedure, psymtab_to_symtab_1): Likewise.
	* xcoffread.c (process_xcoff_symbol): Likewise.
	* parse.c (write_exp_msymbol): Likewise.

	* stabsread.c (rs6000_builtin_type_data): New static variable.
	(_initialize_stabsread): Initialize it.
	(rs6000_builtin_type): Add OBJFILE argument.  Allocate builtin
	types per-objfile instead of globally.

	* stabsread.c (dbx_lookup_type): Add OBJFILE argument.  Use it
	instead of current_objfile; pass it to rs6000_builtin_type.
	(dbx_alloc_type, read_type, read_range_type): Update calls.
	(cleanup_undefined_types_noname): Add OBJFILE argument and
	pass it to dbx_lookup_type.
	(cleanup_undefined_types): Add OBJFILE argument and pass it
	to cleanup_undefined_types_noname.
	* stabsread.h (cleanup_undefined_types): Add OBJFILE argument.
	* buildsym.c (end_symtab): Update call.
@
text
@d5300 1
a5300 1
  ftype = make_function_type (type, (struct type **) 0, cu->objfile);
@


1.315
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d4833 1
a4833 1
      index_type = builtin_type_int32;
d5273 1
a5273 1
  index_type = builtin_type_int32;
a7737 1
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
d7842 1
a7842 1
	      = builtin_type (gdbarch)->nodebug_data_symbol;
a8149 1
  struct gdbarch *gdbarch = get_objfile_arch (cu->objfile);
d8158 1
a8158 1
      return builtin_type (gdbarch)->builtin_void;
@


1.314
log
@	* dwarf2read.c (dwarf_decode_lines): Ignore rows where is_stmt is 0.
	Set basic_block to 0 after a special opcode.
@
text
@d49 1
d2936 1
a2938 5
    case DW_TAG_inlined_subroutine:
      /* FIXME:  These are ignored for now.
         They could be used to set breakpoints on all inlined instances
         of a function and make GDB `next' properly over inlined functions.  */
      break;
d3291 3
a3293 1
  if (die->tag != origin_die->tag)
d3320 3
a3322 1
	  if (child_die->tag != child_origin_die->tag)
d3365 1
a3365 1
  struct attribute *attr;
d3369 15
d7035 3
a7037 1
   containing the return value on output.  */
d7046 3
d7744 1
d7772 3
a7774 1
      attr = dwarf2_attr (die, DW_AT_decl_line, cu);
d7780 3
a7782 1
      attr = dwarf2_attr (die, DW_AT_decl_file, cu);
d7829 8
d7890 8
a7897 1
	  SYMBOL_IS_ARGUMENT (sym) = 1;
d8238 1
@


1.313
log
@2009-06-23  Sami Wagiaalla  <swagiaal@@redhat.com>

       * dwarf2read.c (process_die): Handle import statements
       (DW_TAG_imported_declaration, case DW_TAG_imported_module)
       (read_import_statement): New.
       (read_func_scope): Update using_directives to point to current context
       (read_lexical_block_scope): Ditto.
       * cp-support.h: Added prototype for cp_add_using.
       * cp-namespace.c: Removed local context_stack.
       (cp_initialize_namespace): Deleted.
       (cp_finalize_namespace): Deleted.
       (cp_add_using_directive): Use using_directives instead of using_list.
       (cp_add_using): No longer static.
       * buildsym.h: Created global using_direct variable.
       Created using_direct variable in context_stack.
       * buildsym.c (finish_block): Set using directives for the block under
       construction.
       (start_symtab): Removed call to cp_initialize_namespace().
       (end_symtab): Removed call to cp_finalize_namespace().
       (push_context): Save and reset using_directives.
       * block.c (block_using): Return using directives for given
       block instead of static block.

2009-06-23  Sami Wagiaalla  <swagiaal@@redhat.com>

       * gdb.cp/namespace-using.exp: New test.
       * gdb.cp/namespace-using.cc: New test.
@
text
@d7356 1
a7356 1
		  if (!decode_for_pst_p)
d7371 1
a7371 1
	      basic_block = 1;
d7436 1
a7436 1
		  if (!decode_for_pst_p)
@


1.312
log
@	* dwarf2read.c (zlib_decompress_section): Use a cleanup.
@
text
@d949 2
a2989 5
      /* FIXME: carlton/2002-10-16: Eventually, we should use the
	 information contained in these.  DW_TAG_imported_declaration
	 dies shouldn't have children; DW_TAG_imported_module dies
	 shouldn't in the C++ case, but conceivably could in the
	 Fortran case.  */
d2991 5
a2995 2
      complaint (&symfile_complaints, _("unsupported tag: '%s'"),
		 dwarf_tag_name (die->tag));
d3041 62
d3436 1
d3499 1
@


1.311
log
@	* gdbtypes.c (create_string_type): Receive character type as argument.
	* gdbtypes.h (create_string_type): Add character type argument.
        * dwarf2read.c (read_tag_string_type): Pass character type to
	create_string_type.

	* value.h (value_string): Add character type argument.
	* valops.c (value_string): Add character type argument.  Pass it to
	create_string_type.  Do not allocate space in inferior.
	* valarith.c (value_concat): Pass character type to value_string.

	* value.h (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* valops.c (value_typed_string): Rename to ...
	(value_cstring): ... this.
	* c-lang.c (evaluate_subexp_c): Update.

	* python/python-value.c (builtin_type_pychar): New define.
	(convert_value_from_python): Call value_cstring instead
	of value_from_string.
	* value.c (value_from_string): Remove.
	* value.h (value_from_string): Remove.

	* eval.c (evaluate_subexp_standard): Pass character type to
	value_string.  Pass expression architecture to value_nsstring
	and lookup_child_selector.
	* objc-lang.h (lookup_objc_class): Add GDBARCH parameter.
	(lookup_child_selector): Likewise.
	(value_nsstring): Likewise.
	* objc-lang.c (lookup_objc_class): Add GDBARCH parameter.
	Pass character type to value_string..
	(lookup_child_selector): Likewise.
	(value_nsstring): Add GDBARCH parameter, use it instead of
	objfile architecture.  Pass architecture to lookup_objc_class
	and lookup_child_selector. Pass character type to value_string.
	(end_msglist): Pass architecture to lookup_objc_class.
	* objc-exp.y: Pass architecture to lookup_objc_class.
@
text
@d1211 1
d1268 1
a1268 1
  xfree (compressed_buffer);
@


1.310
log
@	* buildsym.c (record_line): Remove call to gdbarch_addr_bits_remove.

	* coffread.c (coff_symtab_read): Call gdbarch_addr_bits_remove before
	calling record_line.
	(enter_linenos): Likewise.
	* dbxread.c (process_one_symbol): Likewise.
	* dwarf2read.c (dwarf_decode_lines): Likewise.
	* mdebugread.c (psymtab_to_symtab_1): Likewise.
	* xcoffread.c (enter_line_range): Likewise.
@
text
@d5168 1
d5194 2
a5195 1
  type = create_string_type (NULL, range_type);
@


1.309
log
@2009-06-16  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* dwarf2read.c (dwarf_info_section, dwarf_abbrev_section)
	(dwarf_line_section, dwarf_pubnames_section, dwarf_aranges_section)
	(dwarf_loc_section, dwarf_macinfo_section, dwarf_str_section)
	(dwarf_ranges_section, dwarf_frame_section)
	(dwarf_eh_frame_section): Removed.
	(dwarf2_resize_section): Likewise.
	(dwarf2_read_section): Now static, use bfd_mmap() if possible.
	(dwarf2_get_section_info): New function.
	(munmap_section_buffer): Likewise.
	(dwarf2_per_objfile_cleanup): Likewise.
	(section_is_p): Signature change.
	* dwarf2-frame.c (dwarf2_build_frame_info): Use
	dwarf2_get_section_info instead of dwarf2_read_section.
@
text
@d7229 1
d7249 1
d7290 8
a7297 7
                    {
                      if (last_subfile != current_subfile)
                        {
                          if (last_subfile)
                            record_line (last_subfile, 0, address);
                          last_subfile = current_subfile;
                        }
d7299 3
a7301 2
		      record_line (current_subfile, line, 
				   check_cu_functions (address, cu));
d7370 12
a7381 10
                    {
                      if (last_subfile != current_subfile)
                        {
                          if (last_subfile)
                            record_line (last_subfile, 0, address);
                          last_subfile = current_subfile;
                        }
                      record_line (current_subfile, line, 
                                   check_cu_functions (address, cu));
                    }
d7461 4
a7464 1
            record_line (current_subfile, 0, address);
@


1.308
log
@	* dwarf2read.c (dwarf2_psymtab_to_symtab): Propagate
	`has_section_at_zero' flag from stripped objfile to separate,
	debug info only, objfile.
@
text
@d58 3
a60 14

/* A note on memory usage for this file.
   
   At the present time, this code reads the debug info sections into
   the objfile's objfile_obstack.  A definite improvement for startup
   time, on platforms which do not emit relocations for debug
   sections, would be to use mmap instead.  The object's complete
   debug information is loaded into memory, partly to simplify
   absolute DIE references.

   Whether using obstacks or mmap, the sections should remain loaded
   until the objfile is released, and pointers into the section data
   can be used for any other data associated to the objfile (symbol
   names, type names, location expressions to name a few).  */
d137 2
d147 8
d157 11
a167 21
  /* Sizes of debugging sections.  */
  unsigned int info_size;
  unsigned int abbrev_size;
  unsigned int line_size;
  unsigned int pubnames_size;
  unsigned int aranges_size;
  unsigned int loc_size;
  unsigned int macinfo_size;
  unsigned int str_size;
  unsigned int ranges_size;
  unsigned int frame_size;
  unsigned int eh_frame_size;

  /* Loaded data from the sections.  */
  gdb_byte *info_buffer;
  gdb_byte *abbrev_buffer;
  gdb_byte *line_buffer;
  gdb_byte *str_buffer;
  gdb_byte *macinfo_buffer;
  gdb_byte *ranges_buffer;
  gdb_byte *loc_buffer;
a186 12
static asection *dwarf_info_section;
static asection *dwarf_abbrev_section;
static asection *dwarf_line_section;
static asection *dwarf_pubnames_section;
static asection *dwarf_aranges_section;
static asection *dwarf_loc_section;
static asection *dwarf_macinfo_section;
static asection *dwarf_str_section;
static asection *dwarf_ranges_section;
asection *dwarf_frame_section;
asection *dwarf_eh_frame_section;

a782 2
gdb_byte *dwarf2_read_section (struct objfile *, asection *);

a1107 10
  dwarf_info_section = 0;
  dwarf_abbrev_section = 0;
  dwarf_line_section = 0;
  dwarf_str_section = 0;
  dwarf_macinfo_section = 0;
  dwarf_frame_section = 0;
  dwarf_eh_frame_section = 0;
  dwarf_ranges_section = 0;
  dwarf_loc_section = 0;
  
d1109 1
a1109 1
  return (dwarf_info_section != NULL && dwarf_abbrev_section != NULL);
d1116 1
a1116 1
section_is_p (asection *sectp, const char *name)
d1118 4
a1121 4
  return ((sectp->name[0] == '.'
           && strcmp (sectp->name + 1, name) == 0)
          || (sectp->name[0] == '.' && sectp->name[1] == 'z'
              && strcmp (sectp->name + 2, name) == 0));
d1131 1
a1131 1
  if (section_is_p (sectp, INFO_SECTION))
d1133 2
a1134 2
      dwarf2_per_objfile->info_size = bfd_get_section_size (sectp);
      dwarf_info_section = sectp;
d1136 1
a1136 1
  else if (section_is_p (sectp, ABBREV_SECTION))
d1138 2
a1139 2
      dwarf2_per_objfile->abbrev_size = bfd_get_section_size (sectp);
      dwarf_abbrev_section = sectp;
d1141 1
a1141 1
  else if (section_is_p (sectp, LINE_SECTION))
d1143 2
a1144 2
      dwarf2_per_objfile->line_size = bfd_get_section_size (sectp);
      dwarf_line_section = sectp;
d1146 1
a1146 1
  else if (section_is_p (sectp, PUBNAMES_SECTION))
d1148 2
a1149 2
      dwarf2_per_objfile->pubnames_size = bfd_get_section_size (sectp);
      dwarf_pubnames_section = sectp;
d1151 1
a1151 1
  else if (section_is_p (sectp, ARANGES_SECTION))
d1153 2
a1154 2
      dwarf2_per_objfile->aranges_size = bfd_get_section_size (sectp);
      dwarf_aranges_section = sectp;
d1156 1
a1156 1
  else if (section_is_p (sectp, LOC_SECTION))
d1158 2
a1159 2
      dwarf2_per_objfile->loc_size = bfd_get_section_size (sectp);
      dwarf_loc_section = sectp;
d1161 1
a1161 1
  else if (section_is_p (sectp, MACINFO_SECTION))
d1163 2
a1164 2
      dwarf2_per_objfile->macinfo_size = bfd_get_section_size (sectp);
      dwarf_macinfo_section = sectp;
d1166 1
a1166 1
  else if (section_is_p (sectp, STR_SECTION))
d1168 2
a1169 2
      dwarf2_per_objfile->str_size = bfd_get_section_size (sectp);
      dwarf_str_section = sectp;
d1171 1
a1171 1
  else if (section_is_p (sectp, FRAME_SECTION))
d1173 2
a1174 2
      dwarf2_per_objfile->frame_size = bfd_get_section_size (sectp);
      dwarf_frame_section = sectp;
d1176 1
a1176 1
  else if (section_is_p (sectp, EH_FRAME_SECTION))
d1181 2
a1182 2
          dwarf2_per_objfile->eh_frame_size = bfd_get_section_size (sectp);
          dwarf_eh_frame_section = sectp;
d1185 1
a1185 1
  else if (section_is_p (sectp, RANGES_SECTION))
d1187 2
a1188 2
      dwarf2_per_objfile->ranges_size = bfd_get_section_size (sectp);
      dwarf_ranges_section = sectp;
d1190 1
a1190 1
  
d1196 2
a1197 2
/* This function is called after decompressing a section, so
   dwarf2_per_objfile can record its new, uncompressed size.  */
d1200 2
a1201 1
dwarf2_resize_section (asection *sectp, bfd_size_type new_size)
d1203 68
a1270 26
  if (section_is_p (sectp, INFO_SECTION))
    dwarf2_per_objfile->info_size = new_size;
  else if (section_is_p (sectp, ABBREV_SECTION))
    dwarf2_per_objfile->abbrev_size = new_size;
  else if (section_is_p (sectp, LINE_SECTION))
    dwarf2_per_objfile->line_size = new_size;
  else if (section_is_p (sectp, PUBNAMES_SECTION))
    dwarf2_per_objfile->pubnames_size = new_size;
  else if (section_is_p (sectp, ARANGES_SECTION))
    dwarf2_per_objfile->aranges_size = new_size;
  else if (section_is_p (sectp, LOC_SECTION))
    dwarf2_per_objfile->loc_size = new_size;
  else if (section_is_p (sectp, MACINFO_SECTION))
    dwarf2_per_objfile->macinfo_size = new_size;
  else if (section_is_p (sectp, STR_SECTION))
    dwarf2_per_objfile->str_size = new_size;
  else if (section_is_p (sectp, FRAME_SECTION))
    dwarf2_per_objfile->frame_size = new_size;
  else if (section_is_p (sectp, EH_FRAME_SECTION))
    dwarf2_per_objfile->eh_frame_size = new_size;
  else if (section_is_p (sectp, RANGES_SECTION))
    dwarf2_per_objfile->ranges_size = new_size;
  else
    internal_error (__FILE__, __LINE__,
		    _("dwarf2_resize_section: missing section_is_p check: %s"),
                    sectp->name);
d1273 3
a1275 1
/* Build a partial symbol table.  */
d1277 2
a1278 2
void
dwarf2_build_psymtabs (struct objfile *objfile, int mainline)
d1280 48
a1327 1
  /* We definitely need the .debug_info and .debug_abbrev sections */
d1329 3
a1331 2
  dwarf2_per_objfile->info_buffer = dwarf2_read_section (objfile, dwarf_info_section);
  dwarf2_per_objfile->abbrev_buffer = dwarf2_read_section (objfile, dwarf_abbrev_section);
d1333 16
a1348 4
  if (dwarf_line_section)
    dwarf2_per_objfile->line_buffer = dwarf2_read_section (objfile, dwarf_line_section);
  else
    dwarf2_per_objfile->line_buffer = NULL;
d1350 2
a1351 4
  if (dwarf_str_section)
    dwarf2_per_objfile->str_buffer = dwarf2_read_section (objfile, dwarf_str_section);
  else
    dwarf2_per_objfile->str_buffer = NULL;
d1353 23
a1375 5
  if (dwarf_macinfo_section)
    dwarf2_per_objfile->macinfo_buffer = dwarf2_read_section (objfile,
						dwarf_macinfo_section);
  else
    dwarf2_per_objfile->macinfo_buffer = NULL;
d1377 1
a1377 4
  if (dwarf_ranges_section)
    dwarf2_per_objfile->ranges_buffer = dwarf2_read_section (objfile, dwarf_ranges_section);
  else
    dwarf2_per_objfile->ranges_buffer = NULL;
d1379 12
a1390 4
  if (dwarf_loc_section)
    dwarf2_per_objfile->loc_buffer = dwarf2_read_section (objfile, dwarf_loc_section);
  else
    dwarf2_per_objfile->loc_buffer = NULL;
d1431 1
a1431 1
  while ((pubnames_ptr - pubnames_buffer) < dwarf2_per_objfile->pubnames_size)
d1506 1
a1506 1
  if (header->abbrev_offset >= dwarf2_per_objfile->abbrev_size)
d1510 1
a1510 1
	   (long) (beg_of_comp_unit - dwarf2_per_objfile->info_buffer),
d1514 1
a1514 1
      > dwarf2_per_objfile->info_buffer + dwarf2_per_objfile->info_size)
d1518 1
a1518 1
	   (long) (beg_of_comp_unit - dwarf2_per_objfile->info_buffer),
d1600 1
a1600 1
  info_ptr = dwarf2_per_objfile->info_buffer;
d1624 2
a1625 2
  while (info_ptr < (dwarf2_per_objfile->info_buffer
		     + dwarf2_per_objfile->info_size))
d1645 1
a1645 1
      cu.header.offset = beg_of_comp_unit - dwarf2_per_objfile->info_buffer;
d1802 1
a1802 1
  info_ptr = dwarf2_per_objfile->info_buffer + this_cu->offset;
d1814 1
a1814 1
  cu->header.offset = beg_of_comp_unit - dwarf2_per_objfile->info_buffer;
d1854 1
a1854 1
  gdb_byte *info_ptr = dwarf2_per_objfile->info_buffer;
d1861 1
a1861 1
  while (info_ptr < dwarf2_per_objfile->info_buffer + dwarf2_per_objfile->info_size)
d1868 1
a1868 1
      offset = info_ptr - dwarf2_per_objfile->info_buffer;
d2514 1
a2514 1
	    return dwarf2_per_objfile->info_buffer
d2800 1
a2800 1
  info_ptr = dwarf2_per_objfile->info_buffer + offset;
d3465 1
a3465 1
  if (offset >= dwarf2_per_objfile->ranges_size)
d3472 1
a3472 1
  buffer = dwarf2_per_objfile->ranges_buffer + offset;
d3747 1
a3747 1
      gdb_byte *buffer = dwarf2_per_objfile->ranges_buffer + offset;
d3766 1
a3766 1
      if (offset >= dwarf2_per_objfile->ranges_size)
a5603 125
/* Decompress a section that was compressed using zlib.  Store the
   decompressed buffer, and its size, in OUTBUF and OUTSIZE.  */

static void
zlib_decompress_section (struct objfile *objfile, asection *sectp,
                         gdb_byte **outbuf, bfd_size_type *outsize)
{
  bfd *abfd = objfile->obfd;
#ifndef HAVE_ZLIB_H
  error (_("Support for zlib-compressed DWARF data (from '%s') "
           "is disabled in this copy of GDB"),
         bfd_get_filename (abfd));
#else
  bfd_size_type compressed_size = bfd_get_section_size (sectp);
  gdb_byte *compressed_buffer = xmalloc (compressed_size);
  bfd_size_type uncompressed_size;
  gdb_byte *uncompressed_buffer;
  z_stream strm;
  int rc;
  int header_size = 12;

  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0
      || bfd_bread (compressed_buffer, compressed_size, abfd) != compressed_size)
    error (_("Dwarf Error: Can't read DWARF data from '%s'"),
           bfd_get_filename (abfd));

  /* Read the zlib header.  In this case, it should be "ZLIB" followed
     by the uncompressed section size, 8 bytes in big-endian order.  */
  if (compressed_size < header_size
      || strncmp (compressed_buffer, "ZLIB", 4) != 0)
    error (_("Dwarf Error: Corrupt DWARF ZLIB header from '%s'"),
           bfd_get_filename (abfd));
  uncompressed_size = compressed_buffer[4]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[5]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[6]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[7]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[8]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[9]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[10]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[11];

  /* It is possible the section consists of several compressed
     buffers concatenated together, so we uncompress in a loop.  */
  strm.zalloc = NULL;
  strm.zfree = NULL;
  strm.opaque = NULL;
  strm.avail_in = compressed_size - header_size;
  strm.next_in = (Bytef*) compressed_buffer + header_size;
  strm.avail_out = uncompressed_size;
  uncompressed_buffer = obstack_alloc (&objfile->objfile_obstack,
                                       uncompressed_size);
  rc = inflateInit (&strm);
  while (strm.avail_in > 0)
    {
      if (rc != Z_OK)
        error (_("Dwarf Error: setting up DWARF uncompression in '%s': %d"),
               bfd_get_filename (abfd), rc);
      strm.next_out = ((Bytef*) uncompressed_buffer
                       + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, Z_FINISH);
      if (rc != Z_STREAM_END)
        error (_("Dwarf Error: zlib error uncompressing from '%s': %d"),
               bfd_get_filename (abfd), rc);
      rc = inflateReset (&strm);
    }
  rc = inflateEnd (&strm);
  if (rc != Z_OK
      || strm.avail_out != 0)
    error (_("Dwarf Error: concluding DWARF uncompression in '%s': %d"),
           bfd_get_filename (abfd), rc);

  xfree (compressed_buffer);
  *outbuf = uncompressed_buffer;
  *outsize = uncompressed_size;
#endif
}


/* Read the contents of the section at OFFSET and of size SIZE from the
   object file specified by OBJFILE into the objfile_obstack and return it.
   If the section is compressed, uncompress it before returning.  */

gdb_byte *
dwarf2_read_section (struct objfile *objfile, asection *sectp)
{
  bfd *abfd = objfile->obfd;
  gdb_byte *buf, *retbuf;
  bfd_size_type size = bfd_get_section_size (sectp);
  unsigned char header[4];

  if (size == 0)
    return NULL;

  /* Check if the file has a 4-byte header indicating compression.  */
  if (size > sizeof (header)
      && bfd_seek (abfd, sectp->filepos, SEEK_SET) == 0
      && bfd_bread (header, sizeof (header), abfd) == sizeof (header))
    {
      /* Upon decompression, update the buffer and its size.  */
      if (strncmp (header, "ZLIB", sizeof (header)) == 0)
        {
          zlib_decompress_section (objfile, sectp, &buf, &size);
          dwarf2_resize_section (sectp, size);
          return buf;
        }
    }

  /* If we get here, we are a normal, not-compressed section.  */
  buf = obstack_alloc (&objfile->objfile_obstack, size);
  /* When debugging .o files, we may need to apply relocations; see
     http://sourceware.org/ml/gdb-patches/2002-04/msg00136.html .
     We never compress sections in .o files, so we only need to
     try this when the section is not compressed.  */
  retbuf = symfile_relocate_debug_section (abfd, sectp, buf);
  if (retbuf != NULL)
    return retbuf;

  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0
      || bfd_bread (buf, size, abfd) != size)
    error (_("Dwarf Error: Can't read DWARF data from '%s'"),
	   bfd_get_filename (abfd));

  return buf;
}

d5629 1
a5629 1
  abbrev_ptr = dwarf2_per_objfile->abbrev_buffer + cu_header->abbrev_offset;
d5701 2
a5702 2
      if ((unsigned int) (abbrev_ptr - dwarf2_per_objfile->abbrev_buffer)
	  >= dwarf2_per_objfile->abbrev_size)
d6020 1
a6020 1
  part_die->offset = info_ptr - dwarf2_per_objfile->info_buffer;
d6133 1
a6133 1
	    part_die->sibling = dwarf2_per_objfile->info_buffer
d6249 1
a6249 1
      info_ptr = (dwarf2_per_objfile->info_buffer
d6325 1
a6325 1
  offset = info_ptr - dwarf2_per_objfile->info_buffer;
d6761 1
a6761 1
  if (dwarf2_per_objfile->str_buffer == NULL)
d6767 1
a6767 1
  if (str_offset >= dwarf2_per_objfile->str_size)
d6774 1
a6774 1
  if (dwarf2_per_objfile->str_buffer[str_offset] == '\0')
d6776 1
a6776 1
  return (char *) (dwarf2_per_objfile->str_buffer + str_offset);
d7063 1
a7063 1
  if (dwarf2_per_objfile->line_buffer == NULL)
d7071 1
a7071 1
  if (offset + 4 >= dwarf2_per_objfile->line_size)
d7082 1
a7082 1
  line_ptr = dwarf2_per_objfile->line_buffer + offset;
d7089 2
a7090 2
  if (line_ptr + lh->total_length > (dwarf2_per_objfile->line_buffer
				     + dwarf2_per_objfile->line_size))
d7146 2
a7147 2
  if (line_ptr > (dwarf2_per_objfile->line_buffer
		  + dwarf2_per_objfile->line_size))
d10132 1
a10132 1
  if (dwarf2_per_objfile->macinfo_buffer == NULL)
d10149 3
a10151 3
  mac_ptr = dwarf2_per_objfile->macinfo_buffer + offset;
  mac_end = dwarf2_per_objfile->macinfo_buffer
    + dwarf2_per_objfile->macinfo_size;
d10228 1
a10228 1
  mac_ptr = dwarf2_per_objfile->macinfo_buffer + offset;
d10446 1
a10446 1
      && DW_UNSND (attr) < dwarf2_per_objfile->loc_size)
d10457 2
a10458 2
      baton->size = dwarf2_per_objfile->loc_size - DW_UNSND (attr);
      baton->data = dwarf2_per_objfile->loc_buffer + DW_UNSND (attr);
d10527 1
a10527 1
      gdb_byte *info_ptr = per_objfile->info_buffer + per_cu->offset;
d10920 36
d10961 2
a10962 1
  dwarf2_objfile_data_key = register_objfile_data ();
@


1.307
log
@	* dwarf2read.c (dwarf_decode_lines): Recognize and ignore
	DW_LNE_set_discriminator.
@
text
@d2544 13
@


1.306
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@d7360 5
@


1.305
log
@	* dwarf2read.c (follow_die_ref): Add comment.
	(dwarf2_mark_helper): Tweak comment.
	(dwarf2_mark): Move description to its proper place.
@
text
@d10480 1
a10480 1
      SYMBOL_OPS (sym) = &dwarf2_loclist_funcs;
d10510 1
a10510 1
      SYMBOL_OPS (sym) = &dwarf2_locexpr_funcs;
@


1.304
log
@gdb/
	* dwarf2read.c (set_cu_language): Recognize also DW_LANG_C99.
@
text
@d9580 4
a10836 3
/* Set the mark field in CU and in every other compilation unit in the
   cache that we must keep because we are keeping CU.  */

d10857 2
a10858 1
/* Set the mark field in CU and in every other compilation unit in the
d10877 3
@


1.303
log
@gdb/
	Fix parsing DW_AT_const_value using DW_FORM_string.
	* dwarf2read.c (dwarf2_const_value <DW_FORM_string>): New.

gdb/testsuite/
	* gdb.dwarf2/dw2-strp.exp (p a_string2, ptype a_string2): New.
	* gdb.dwarf2/dw2-strp.S (a_string2): New.
@
text
@d6879 1
@


1.302
log
@gdb/
	Make specifiable the make_function_type type memory ownership.
	* gdbtypes.c (make_function_type): New parameter `objfile', use it
	explicitely instead of TYPE-initialized removed local variable
	`objfile'.  Describe `objfile' it in the function comment.
	(lookup_function_type): Update make_function_type callers.
	* gdbtypes.h (make_function_type): Update the prototype.
	* jv-lang.c (java_link_class_type): Update make_function_type callers.
	* dwarf2read.c (read_subroutine_type): Likewise.
	* stabsread.c (read_type): Likewise.
@
text
@d7960 1
@


1.301
log
@gdb/
	PR gdb/9675:
	* dwarf2read.c (unsigned_int_compar, inherit_abstract_dies): New.
	(read_func_scope): Call inherit_abstract_dies.

gdb/testsuite/
	* gdb.cp/abstract-origin.exp, gdb.cp/abstract-origin.cc: New test.
@
text
@d5113 1
a5113 1
  ftype = make_function_type (type, (struct type **) 0);
@


1.300
log
@gdb/
	* dwarf2read.c
	(new_symbol <DW_TAG_variable> <!DW_AT_location> <DW_AT_external>):
	Create the symbol in local scope.
	* symtab.h (cu->list_in_scope <LOC_UNRESOLVED>): New comment part.

gdb/testsuite/
	* gdb.dwarf2/dw2-unresolved-main.c, gdb.dwarf2/dw2-unresolved.S,
	gdb.dwarf2/dw2-unresolved.exp: New.
@
text
@d3092 97
d3247 2
@


1.299
log
@gdb

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Keith Seitz  <keiths@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/6817
	* Makefile.in (dbxread.o): Update.
	* dbxread.c (read_dbx_symtab): Use cp_canonicalize_string.
	* dwarf2read.c (GDB_FORM_cached_string): New.
	(read_partial_die): Use dwarf2_canonicalize_name.
	(dwarf2_linkage_name): Use dwarf2_name.
	(dwarf2_canonicalize_name): New.
	(dwarf2_name): Use dwarf2_canonicalize_name.
	(dwarf_form_name, dump_die): Handle GDB_FORM_cached_string.
	* stabsread.c (define_symbol, read_type): Use cp_canonicalize_string.
	* symtab.c (lookup_symbol_in_language): Canonicalize input before
	searching.
	* cp-name-parser.y: operator() requires two parameters,
	according to libiberty.
	* minsyms.c (lookup_minimal_symbol): Canonicalize input
	before searching.
	* NEWS: Update.

gdb/testsuite

2009-03-31  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	PR gdb/931
	* gdb.cp/gdb1355.exp (f_li, f_lui, f_si, f_sui): Allow canonical
	output.
	* gdb.cp/templates.exp: Allow canonical output.  Remove KFAILs
	for gdb/931.
	* dw2-strp.S (DW_AT_language): Change to C++.
	(DW_TAG_variable (name ""), Abbrev code 7, .Lemptyname): New.
@
text
@d7685 1
a7685 1
		  add_symbol_to_list (sym, &global_symbols);
@


1.298
log
@gdb/
	Recognize missing DW_AT_location as <value optimized out>.
	* dwarf2read.c
	(new_symbol <DW_TAG_variable> <!DW_AT_location> <!DW_AT_external>):
	Call add_symbol_to_list.

gdb/testsuite/
	* gdb.dwarf2/dw2-noloc-main.c: New file.
	* gdb.dwarf2/dw2-noloc.S: New symbols matrix.
	(.text): Remove.
	(.data): New.
	(DW_AT_stmt_list, .debug_line, DW_AT_frame_base): Remove.
	(DW_AT_low_pc, DW_AT_high_pc): Reference `dw2-noloc-main.c'.
	(DW_TAG_subprogram func_cu1, noloc): Remove.
	(main): New.
	* gdb.dwarf2/dw2-noloc.exp: Use prepare_for_testing, compile also
	`dw2-noloc-main.c'.  Test the new DIEs from `dw2-noloc.S'.
	(file_symbols): New procedure.
@
text
@d526 9
d1005 3
d5961 17
a5977 4

	  /* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
	  if (part_die->name == NULL)
	    part_die->name = DW_STRING (&attr);
d8227 23
a8249 4
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
    return DW_STRING (attr);
  return NULL;
d8260 23
a8282 3
  if (attr && DW_STRING (attr))
    return DW_STRING (attr);
  return NULL;
d8777 2
d9324 1
@


1.297
log
@2009-03-20  Tom Tromey  <tromey@@redhat.com>
	    Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* dwarf2read.c (process_die): Handle DW_TAG_typedef.
	* eval.c (evaluate_subexp_standard) <OP_TYPE>: Strip a single
	typedef.
	* ada-lang.c (decode_packed_array_type): Call CHECK_TYPEDEF on the
	SYMBOL_TYPE result.
	* ada-typeprint.c (print_array_type): Do the NULL check
	unconditionally.
@
text
@d7662 6
@


1.296
log
@	PR gdb/9873:
	* dwarf2read.c (dwarf_decode_macros): New variable `at_commandline'.
	Move the variable `macinfo_type' out of the loop.  Create a new
	processing pass before the current one to pre-create `current_file'.
	New complaint on misplaced zero/non-zero definitions/includes.
	Skip first DW_MACINFO_start_file with `at_commandline' set.
@
text
@d2852 1
@


1.295
log
@gdb/
	PR fortran/9806
	* dwarf2read.c (process_die <DW_TAG_module>, read_module)
	(scan_partial_symbols <DW_TAG_module>, add_partial_module): New.

gdb/testsuite/
	PR fortran/9806
	* gdb.fortran/module.exp, gdb.fortran/module.f90: New.
@
text
@d9966 2
d9975 11
d9990 1
a9990 1
  for (;;)
a9991 2
      enum dwarf_macinfo_record_type macinfo_type;

d9995 3
a9997 2
	  dwarf2_macros_too_long_complaint ();
          return;
d10008 86
a10093 1
          return;
d10108 12
d10121 2
a10122 1
			 _("debug info gives macro %s outside of any file: %s"),
d10124 9
a10132 10
			 DW_MACINFO_define ? "definition" : macinfo_type ==
			 DW_MACINFO_undef ? "undefinition" :
			 "something-or-other", body);
            else
              {
                if (macinfo_type == DW_MACINFO_define)
                  parse_macro_definition (current_file, line, body);
                else if (macinfo_type == DW_MACINFO_undef)
                  macro_undef (current_file, line, body);
              }
d10146 16
a10161 3
            current_file = macro_start_file (file, line,
                                             current_file, comp_dir,
                                             lh, cu->objfile);
d10215 1
a10215 1
    }
@


1.294
log
@2009-02-11  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* dwarf2read.c (read_base_type): Set code to TYPE_CODE_CHAR
	for DW_ATE_signed_char and DW_ATE_unisgned_char
	for pascal language.
@
text
@d777 4
d963 2
d1866 3
d2188 14
d2865 3
d4777 16
@


1.293
log
@	* dwarf2read.c (dwarf2_build_psymtabs_hard): Move lowpc and highpc
	inside the loop.  Only call addrmap_set_empty if the compilation unit
	had DW_AT_high_pc and DW_AT_low_pc.  Update call to
	scan_partial_symbols.
	(scan_partial_symbols): Take NEED_PC argument and pass it along with
	LOWPC and HIGHPC.
	(add_partial_namespace): Take NEED_PC argument and pass it through.
	(add_partial_subprogram): Take NEED_PC argument.  Update the addrmap
	if necessary.
@
text
@d5101 2
a5102 1
	if (cu->language == language_ada || cu->language == language_m2)
d5106 2
a5107 1
	if (cu->language == language_ada || cu->language == language_m2)
@


1.292
log
@        Updated copyright notices for most files.
@
text
@d766 1
a766 1
				  struct dwarf2_cu *);
d775 1
a775 1
				   struct dwarf2_cu *cu);
d782 1
a782 1
				    struct dwarf2_cu *cu);
d1489 1
a1489 1
  CORE_ADDR lowpc, highpc, baseaddr;
d1610 7
d1624 1
d1631 2
a1632 1
	  scan_partial_symbols (first_die, &lowpc, &highpc, &cu);
a1649 6
      /* Store the contiguous range; `DW_AT_ranges' range is stored above.  The
         range can be also empty for CUs with no code.  */
      if (!cu.has_ranges_offset && pst->textlow < pst->texthigh)
	addrmap_set_empty (objfile->psymtabs_addrmap, pst->textlow,
			   pst->texthigh - 1, pst);

d1794 6
a1799 3
/* Process all loaded DIEs for compilation unit CU, starting at FIRST_DIE.
   Also set *LOWPC and *HIGHPC to the lowest and highest PC values found
   in CU.  */
d1803 1
a1803 1
		      CORE_ADDR *highpc, struct dwarf2_cu *cu)
d1829 1
a1829 1
	      add_partial_subprogram (pdi, lowpc, highpc, cu);
d1858 1
a1858 1
	      add_partial_namespace (pdi, lowpc, highpc, cu);
d2165 1
a2165 1
		       struct dwarf2_cu *cu)
d2176 1
a2176 1
    scan_partial_symbols (pdi->die_child, lowpc, highpc, cu);
d2192 1
a2192 1
			struct dwarf2_cu *cu)
d2202 11
d2229 1
a2229 1
	    add_partial_subprogram (pdi, lowpc, highpc, cu);
@


1.291
log
@        From  Jerome Guitton  <guitton@@adacore.com>
        * dwarf2read.c (dwarf2_debug_line_missing_end_sequence_complaint):
        New function.
        (dwarf_decode_lines): Detect null file numbers. Detect the end of
        the line program sequence when no end sequence is emitted.
@
text
@d4 2
a5 1
                 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.290
log
@	* dwarf2read.c (typename_concat): Don't segv if prefix or suffix
	is NULL.  Simplify obs == NULL case.
@
text
@d703 7
d7102 5
d7115 1
a7115 1
	      if (lh->num_file_names < file)
a7146 9

		  if (lh->num_file_names < file)
		    dwarf2_debug_line_missing_file_complaint ();
		  else
		    {
		      lh->file_names[file - 1].included_p = 1;
		      if (!decode_for_pst_p)
			record_line (current_subfile, 0, address);
		    }
d7188 1
a7188 1
	      if (lh->num_file_names < file)
d7226 1
a7226 1
                if (lh->num_file_names < file)
d7277 8
@


1.289
log
@	* dwarf2read.c (comp_unit_head): Use unsigned int consistently
	for dwarf section offsets and sizes.
	(dwarf2_cu): Ditto.
	(dwarf2_per_cu_data): Ditto.
	(create_all_comp_units): Change offset to unsigned int.
	(load_full_comp_unit,find_partial_die_in_comp_unit,find_partial_die,
	dwarf2_find_containing_comp_unit,dwarf2_find_comp_unit): Ditto.

	* dwarf2read.c (read_initial_length): Delete cu_header arg.
	All callers updated.
	(read_checked_initial_length_and_offset): New function.
	(read_offset_1): New function.
	(read_offset): Call it.
	(dwarf_decode_line_header): Call read_checked_initial_length_and_offset
	instead of read_initial_length.  Call read_offset_1 instead of
	read_offset.

	* dwarf2read.c (dwarf2_get_ref_die_offset): Remove unused arg `cu'.
	All callers updated.

	* dwarf2read.c (dwarf_attr_name): Unconditionally support all
	DW_AT_MIPS_* except DW_AT_MIPS_fde which collides with
	DW_AT_HP_block_index.
@
text
@d8084 5
d8092 3
a8094 10
      retval[0] = '\0';
      
      if (prefix)
	{
	  strcpy (retval, prefix);
	  strcat (retval, sep);
	}
      if (suffix)
	strcat (retval, suffix);
      
@


1.288
log
@	Convert static_kind into loc_kind enum.
	* gdbtypes.h (enum field_loc_kind): New.
	(union field_location): New field dwarf_block.
	(struct field): Rename static_kind as loc_kind.
	(FIELD_STATIC_KIND): Rename to ...
	(FIELD_LOC_KIND): ... here.
	(TYPE_FIELD_STATIC_KIND): Rename to ...
	(TYPE_FIELD_LOC_KIND): ... here and use there now new FIELD_LOC_KIND.
	(TYPE_FIELD_STATIC_HAS_ADDR): Remove.
	(TYPE_FIELD_STATIC): Remove.
	(TYPE_FIELD_BITPOS): Reformat.
	(SET_FIELD_BITPOS): New.
	(FIELD_PHYSADDR): Rename to ...
	(FIELD_STATIC_PHYSADDR): ... here.
	(TYPE_FIELD_STATIC_PHYSADDR): Follow the FIELD_PHYSADDR rename.
	(SET_FIELD_PHYSADDR): Use new FIELD_LOC_KIND.
	(FIELD_PHYSNAME): Rename to ...
	(FIELD_STATIC_PHYSNAME): ... here.
	(TYPE_FIELD_STATIC_PHYSNAME): Follow the FIELD_PHYSNAME rename.
	(SET_FIELD_PHYSNAME): Use new FIELD_LOC_KIND.
	(FIELD_DWARF_BLOCK, TYPE_FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK): New.
	(field_is_static): New declaration.
	* gdbtypes.c (field_is_static): New function.
	(copy_type_recursive): Update throughout.
	* amd64-tdep.c, c-typeprint.c, coffread.c, cp-valprint.c, dwarf2read.c,
	eval.c, jv-typeprint.c, jv-valprint.c, mdebugread.c, p-typeprint.c,
	p-valprint.c, valops.c, value.c, varobj.c: Update throughout.
@
text
@d237 1
a237 1
  unsigned long length;
d302 1
a302 1
  unsigned long ranges_offset;
d369 2
a370 2
  unsigned long offset;
  unsigned long length : 30;
d374 1
a374 1
  unsigned long queued : 1;
d804 1
a804 1
static struct partial_die_info *find_partial_die (unsigned long,
d832 5
a836 2
static LONGEST read_initial_length (bfd *, gdb_byte *,
                                    struct comp_unit_head *, unsigned int *);
d839 3
a841 1
                            unsigned int *);
d1017 1
a1017 2
static unsigned int dwarf2_get_ref_die_offset (struct attribute *,
					       struct dwarf2_cu *);
d1061 1
a1061 1
  (unsigned long offset, struct objfile *objfile);
d1064 1
a1064 1
  (unsigned long offset, struct objfile *objfile);
a1315 1
      struct comp_unit_head cu_header;
d1318 1
a1318 2
      entry_length = read_initial_length (abfd, pubnames_ptr, &cu_header,
                                          &bytes_read);
d1355 4
a1358 2
  cu_header->length = read_initial_length (abfd, info_ptr, cu_header,
                                           &bytes_read);
d1363 1
a1363 1
                                          &bytes_read);
d1372 1
d1743 1
a1743 1
      struct comp_unit_head cu_header;
d1746 1
a1746 2
      unsigned long offset;
      unsigned int bytes_read;
d1752 2
a1753 3
      cu_header.initial_length_size = 0;
      cu_header.length = read_initial_length (objfile->obfd, info_ptr,
					      &cu_header, &bytes_read);
d1760 1
a1760 1
      this_cu->length = cu_header.length + cu_header.initial_length_size;
d2364 1
a2364 1
	      + dwarf2_get_ref_die_offset (&attr, cu);
d2627 1
a2627 1
  unsigned long offset;
d5952 1
a5952 1
	  part_die->spec_offset = dwarf2_get_ref_die_offset (&attr, cu);
d5961 1
a5961 1
	      + dwarf2_get_ref_die_offset (&attr, cu);
d6021 1
a6021 1
find_partial_die_in_comp_unit (unsigned long offset, struct dwarf2_cu *cu)
d6035 1
a6035 1
find_partial_die (unsigned long offset, struct dwarf2_cu *cu)
d6092 1
a6092 1
		    _("could not find partial DIE 0x%lx in cache [from module %s]\n"),
d6450 1
a6450 6
   
   As a side effect, this function sets the fields initial_length_size
   and offset_size in cu_header to the values appropriate for the
   length field.  (The format of the initial length field determines
   the width of file offsets to be fetched later with read_offset().)
   
d6468 1
a6468 2
read_initial_length (bfd *abfd, gdb_byte *buf, struct comp_unit_head *cu_header,
                     unsigned int *bytes_read)
d6488 10
a6497 6
  if (cu_header)
    {
      gdb_assert (cu_header->initial_length_size == 0
		  || cu_header->initial_length_size == 4
		  || cu_header->initial_length_size == 8
		  || cu_header->initial_length_size == 12);
d6499 11
a6509 4
      if (cu_header->initial_length_size != 0
	  && cu_header->initial_length_size != *bytes_read)
	complaint (&symfile_complaints,
		   _("intermixed 32-bit and 64-bit DWARF sections"));
d6511 3
a6513 3
      cu_header->initial_length_size = *bytes_read;
      cu_header->offset_size = (*bytes_read == 4) ? 4 : 8;
    }
d6515 1
d6526 10
d6538 1
a6538 1
  switch (cu_header->offset_size)
a6541 1
      *bytes_read = 4;
a6544 1
      *bytes_read = 8;
d6548 1
a6548 1
		      _("read_offset: bad switch [in module %s]"),
d6586 1
a6586 2
  LONGEST str_offset = read_offset (abfd, buf, cu_header,
				    bytes_read_ptr);
d6885 1
a6885 1
  unsigned int bytes_read;
d6912 2
a6913 1
    read_initial_length (abfd, line_ptr, &cu->header, &bytes_read);
d6924 2
a6925 2
  lh->header_length = read_offset (abfd, line_ptr, &cu->header, &bytes_read);
  line_ptr += bytes_read;
a8496 1
#ifdef MIPS
d8498 1
d8501 1
a8521 1
#endif
d8523 1
d8526 1
d9263 1
a9263 1
dwarf2_get_ref_die_offset (struct attribute *attr, struct dwarf2_cu *cu)
d9343 1
a9343 1
  offset = dwarf2_get_ref_die_offset (attr, cu);
d10184 1
a10184 1
dwarf2_find_containing_comp_unit (unsigned long offset,
d10216 1
a10216 1
	error (_("invalid dwarf2 offset %ld"), offset);
d10226 1
a10226 1
dwarf2_find_comp_unit (unsigned long offset, struct objfile *objfile)
d10231 1
a10231 1
    error (_("no compilation unit with offset %ld."), offset);
@


1.287
log
@	* dwarf2read.c (dwarf2_die_debug): New static global.
	(dump_die_shallow): Renamed from dump_die, New args f, indent.
	Print to specified file, indented by the specified amount.
	(dump_die_for_error): New fn.  Point all existing callers of
	dump_die here.
	(dump_die_die_1,dump_die): New fns, replaces ...
	(dump_die_list): ... deleted.
	(read_die_and_children_1): Old contents of read_die_and_children
	moved here.
	(read_die_and_children): Rewrite.
	(read_die_and_siblings): Call read_die_and_children_1 instead of
	read_die_and_children.
	(_initialize_dwarf2_read): New option "debug dwarf2-die".
	* gdbinit.in (pdie): New macro.

	* doc/gdb.texinfo (set debug dwarf2-die): Document it.
@
text
@d3591 1
a3591 1
      FIELD_STATIC_KIND (*fp) = 0;
d3620 1
a3620 1
          FIELD_BITPOS (*fp) = byte_offset * bits_per_byte;
a3621 2
      else
	FIELD_BITPOS (*fp) = 0;
d3713 2
a3714 2
	FIELD_BITPOS (*fp) = (decode_locdesc (DW_BLOCK (attr), cu)
			      * bits_per_byte);
a3715 1
      FIELD_STATIC_KIND (*fp) = 0;
d4433 1
a4433 1
		  FIELD_BITPOS (fields[num_fields]) = SYMBOL_VALUE (sym);
a4434 1
		  FIELD_STATIC_KIND (fields[num_fields]) = 0;
@


1.286
log
@	* dwarf2read.c (offset_in_cu_p): New function.
	(find_partial_die,follow_die_ref): Use it.

	* gdb.dwarf2/dw2-cu-size.exp: New file.
	* gdb.dwarf2/dw2-cu-size.S: New file.

	* gdb.dwarf2/dw2-intercu.S (.Ltype_int_in_cu2): Renamed from
	.Ltype_int for clarity.
@
text
@d144 3
d958 5
d1000 6
a1005 1
static void dump_die (struct die_info *);
d1007 1
a1007 1
static void dump_die_list (struct die_info *);
d5223 21
d5251 4
a5254 4
read_die_and_children (gdb_byte *info_ptr, bfd *abfd,
		       struct dwarf2_cu *cu,
		       gdb_byte **new_info_ptr,
		       struct die_info *parent)
d5303 1
a5303 1
	= read_die_and_children (cur_ptr, abfd, cu, &cur_ptr, parent);
d7848 1
a7848 1
      dump_die (type_die);
d7874 1
a7874 1
	dump_die (type_die);
d7889 1
a7889 1
      dump_die (die);
d9107 1
a9107 1
dump_die (struct die_info *die)
d9111 2
a9112 1
  fprintf_unfiltered (gdb_stderr, "Die: %s (abbrev = %d, offset = %d)\n",
d9114 10
a9123 1
  fprintf_unfiltered (gdb_stderr, "\thas children: %s\n",
d9126 3
a9128 1
  fprintf_unfiltered (gdb_stderr, "\tattributes:\n");
d9131 2
a9132 1
      fprintf_unfiltered (gdb_stderr, "\t\t%s (%s) ",
d9135 1
d9140 2
a9141 2
	  fprintf_unfiltered (gdb_stderr, "address: ");
	  fputs_filtered (paddress (DW_ADDR (&die->attrs[i])), gdb_stderr);
d9147 1
a9147 1
	  fprintf_unfiltered (gdb_stderr, "block: size %d", DW_BLOCK (&die->attrs[i])->size);
d9152 1
a9152 1
	  fprintf_unfiltered (gdb_stderr, "constant ref: %ld (adjusted)",
d9161 1
a9161 1
	  fprintf_unfiltered (gdb_stderr, "constant: %ld", DW_UNSND (&die->attrs[i]));
d9165 1
a9165 1
	  fprintf_unfiltered (gdb_stderr, "string: \"%s\"",
d9171 1
a9171 1
	    fprintf_unfiltered (gdb_stderr, "flag: TRUE");
d9173 1
a9173 1
	    fprintf_unfiltered (gdb_stderr, "flag: FALSE");
d9178 1
a9178 1
	  fprintf_unfiltered (gdb_stderr, "unexpected attribute form: DW_FORM_indirect");
d9181 1
a9181 1
	  fprintf_unfiltered (gdb_stderr, "unsupported attribute form: %d.",
d9183 1
d9185 1
a9185 1
      fprintf_unfiltered (gdb_stderr, "\n");
d9190 1
a9190 1
dump_die_list (struct die_info *die)
d9192 16
a9207 1
  while (die)
d9209 16
a9224 5
      dump_die (die);
      if (die->child != NULL)
	dump_die_list (die->child);
      if (die->sibling != NULL)
	dump_die_list (die->sibling);
d9228 9
d10578 9
@


1.285
log
@        * dwarf2read.c (dwarf2_get_subprogram_pc_bounds): New function.
        (get_scope_pc_bounds): Use it.
@
text
@d363 3
a365 1
     - if it doesn't, GDB will fall over anyway.  */
d1319 12
d6007 1
a6007 2
  if (offset >= cu->header.offset
      && offset < cu->header.offset + cu->header.length)
d9246 1
a9246 2
  if (DW_ADDR (attr) < cu->header.offset
      || DW_ADDR (attr) >= cu->header.offset + cu->header.length)
d9249 1
a9249 2
      per_cu = dwarf2_find_containing_comp_unit (DW_ADDR (attr),
						 cu->objfile);
@


1.284
log
@	* dwarf2read.c (comp_unit_head): Reorganize for better packing.
@
text
@d3327 37
d3390 1
a3390 5
	    if (dwarf2_get_pc_bounds (child, &current_low, &current_high, cu))
	      {
		best_low = min (best_low, current_low);
		best_high = max (best_high, current_high);
	      }
@


1.283
log
@	* dwarf2read.c (struct abbrev_info): Make members name, form 16 bits.
	(struct attribute): Ditto.
@
text
@a235 1
  unsigned int abbrev_offset;
d238 1
@


1.282
log
@	* dwarf2read.c (struct die_info): Make members tag, num_attrs 16 bits.
@
text
@d516 2
a517 2
    enum dwarf_attribute name;
    enum dwarf_form form;
d523 2
a524 2
    enum dwarf_attribute name;
    enum dwarf_form form;
@


1.281
log
@        * dwarf2read.c (add_partial_subprogram): New procedure.
        (scan_partial_symbols): Use it.
        (load_partial_dies): Read in children of subprogram and lexical
        blocks for Ada compilation units.
@
text
@d539 11
a549 4
    enum dwarf_tag tag;		/* Tag indicating type of die */
    unsigned int abbrev;	/* Abbrev number */
    unsigned int offset;	/* Offset in .debug_info section */
    unsigned int num_attrs;	/* Number of attributes */
@


1.280
log
@	* dwarf2read.c (comp_unit_head): Rename first_die_ptr to
	first_die_offset.  All uses updated.
	Delete unused members cu_head_ptr, next.
	Move members base_known, base_address to ...
	(dwarf2_cu) ... here.  All uses updated.
@
text
@d760 4
d1778 1
a1778 15
	      if (pdi->has_pc_info)
		{
		  if (pdi->lowpc < *lowpc)
		    {
		      *lowpc = pdi->lowpc;
		    }
		  if (pdi->highpc > *highpc)
		    {
		      *highpc = pdi->highpc;
		    }
		  if (!pdi->is_declaration)
		    {
		      add_partial_symbol (pdi, cu);
		    }
		}
d2128 45
d5593 1
d5716 1
a5716 1
         we have no reason to follow the children of structures; for other
d5718 6
a5723 1
	 to infer fully qualified class names, and for DW_AT_specification.  */
d5732 4
a5735 1
		      || last_die->tag == DW_TAG_union_type))))
@


1.279
log
@	Stay compatible after the GCC PR fortran/29635 fix.
	* dwarf2read.c (process_die <DW_TAG_imported_module>)
	(process_die <DW_TAG_imported_module>): Do not assert anything about
	these unsupported tags.
@
text
@d250 3
a252 16
  /* Pointer to this compilation unit header in the .debug_info
     section.  */
  gdb_byte *cu_head_ptr;

  /* Pointer to the first die of this compilation unit.  This will be
     the first byte following the compilation unit header.  */
  gdb_byte *first_die_ptr;

  /* Pointer to the next compilation unit header in the program.  */
  struct comp_unit_head *next;

  /* Base address of this compilation unit.  */
  CORE_ADDR base_address;

  /* Non-zero if base_address has been set.  */
  int base_known;
d261 5
a265 1
  /* The header of the compilation unit.
d267 2
a268 3
     FIXME drow/2003-11-10: Some of the things from the comp_unit_head
     should logically be moved to the dwarf2_cu structure.  */
  struct comp_unit_head header;
d1486 1
a1486 2
      cu.header.first_die_ptr = info_ptr;
      cu.header.cu_head_ptr = beg_of_comp_unit;
d1652 1
a1652 2
  cu->header.first_die_ptr = info_ptr;
  cu->header.cu_head_ptr = beg_of_comp_unit;
d2640 2
a2641 2
  cu->header.base_known = 0;
  cu->header.base_address = 0;
d2646 2
a2647 2
      cu->header.base_address = DW_ADDR (attr);
      cu->header.base_known = 1;
d2654 2
a2655 2
	  cu->header.base_address = DW_ADDR (attr);
	  cu->header.base_known = 1;
d3123 2
a3124 2
  found_base = cu_header->base_known;
  base = cu_header->base_address;
d3391 2
a3392 2
      CORE_ADDR base = cu->header.base_address;
      int base_known = cu->header.base_known;
d5877 1
a5877 1
  if (base_address_type != base_address_none && !cu->header.base_known)
d5880 2
a5881 2
      cu->header.base_known = 1;
      cu->header.base_address = base_address;
d5946 3
a5948 1
      info_ptr = per_cu->cu->header.first_die_ptr;
d9909 2
a9910 2
      baton->base_address = cu->header.base_address;
      if (cu->header.base_known == 0)
@


1.278
log
@	* dwarf2read.c (dwarf2_build_psymtabs_hard): Copy dirname on
	obstack.
@
text
@d2763 1
a2763 2
	 Fortran case, so we'll have to replace this gdb_assert if
	 Fortran compilers start generating that info.  */
d2765 2
a2766 1
      gdb_assert (die->child == NULL);
@


1.277
log
@gdb:
	* xml-tdesc.c (tdesc_end_union): Update.
	* stabsread.c (define_symbol): Update.
	(read_type): Update.
	(read_struct_type): Update.
	(read_enum_type): Update.
	* spu-tdep.c (spu_builtin_type_vec128): Update.
	* sh-tdep.c (sh_push_dummy_call_fpu): Update.
	(sh_push_dummy_call_nofpu): Update.
	* mdebugread.c (parse_symbol): Update.
	(parse_symbol): Update.
	(parse_symbol): Update.
	(upgrade_type): Update.
	* jv-lang.c (java_lookup_class): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address): Update.
	* i386-tdep.c (i386_mmx_type): Update.
	(i386_sse_type): Update.
	* gdbtypes.h (enum type_flag_value): New enum.
	(enum type_instance_flag_value): New enum.
	(TYPE_FLAG_UNSIGNED, TYPE_FLAG_NOSIGN, TYPE_FLAG_STUB,
	TYPE_FLAG_TARGET_STUB, TYPE_FLAG_STATIC, TYPE_FLAG_PROTOTYPED,
	TYPE_FLAG_INCOMPLETE, TYPE_FLAG_VARARGS, TYPE_FLAG_VECTOR,
	TYPE_FLAG_FIXED_INSTANCE, TYPE_FLAG_STUB_SUPPORTED,
	TYPE_FLAG_NOTTEXT): Now enum constants.
	(TYPE_FLAG_CONST, TYPE_FLAG_VOLATILE, TYPE_FLAG_CODE_SPACE,
	TYPE_FLAG_DATA_SPACE, TYPE_FLAG_ADDRESS_CLASS_1,
	TYPE_FLAG_ADDRESS_CLASS_2): Remove.
	(TYPE_INSTANCE_FLAG_CONST, TYPE_INSTANCE_FLAG_VOLATILE,
	TYPE_INSTANCE_FLAG_CODE_SPACE, TYPE_INSTANCE_FLAG_DATA_SPACE,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1,
	TYPE_INSTANCE_FLAG_ADDRESS_CLASS_2): New constants.
	(TYPE_UNSIGNED, TYPE_NOSIGN, TYPE_STUB, TYPE_TARGET_STUB,
	TYPE_STATIC, TYPE_PROTOTYPED, TYPE_INCOMPLETE, TYPE_VARARGS,
	TYPE_VECTOR, TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED,
	TYPE_NOTTEXT): Update.
	(TYPE_FLAG_ADDRESS_CLASS_ALL): Remove.
	(TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL): New define.
	(TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE,
	TYPE_ADDRESS_CLASS_1, TYPE_ADDRESS_CLASS_2,
	TYPE_ADDRESS_CLASS_ALL): Update.
	(struct main_type) <flags>: Remove.
	<flag_unsigned, flag_nosign, flag_stub, flag_target_stub,
	flag_static, flag_prototyped, flag_incomplete, flag_varargs,
	flag_vector, flag_stub_supported, flag_nottext,
	flag_fixed_instance>: New fields.
	<nfields, vptr_fieldno>: Move earlier.
	(TYPE_FLAGS): Remove.
	* gdbtypes.c (make_pointer_type): Update.
	(address_space_name_to_int): Update.
	(address_space_int_to_name): Update.
	(make_type_with_address_space): Update.
	(make_cv_type): Update.
	(create_range_type): Update.
	(get_discrete_bounds): Update.
	(create_set_type): Update.
	(make_vector_type): Update.
	(smash_to_method_type): Update.
	(check_typedef): Update.
	(check_stub_method): Update.
	(init_type): Individually assign flag fields.
	(recursive_dump_type): Don't print entire TYPE_FLAGS field.  Do
	print TYPE_FIXED_INSTANCE, TYPE_STUB_SUPPORTED, and TYPE_NOTTEXT.
	(copy_type_recursive): Copy the entire main type.  Don't use
	TYPE_FLAGS.
	* features/rs6000/powerpc-altivec64l.c
	(initialize_tdesc_powerpc_altivec64l): Update.
	* features/rs6000/powerpc-altivec64.c
	(initialize_tdesc_powerpc_altivec64): Update.
	* features/rs6000/powerpc-altivec32l.c
	(initialize_tdesc_powerpc_altivec32l): Update.
	* features/rs6000/powerpc-altivec32.c
	(initialize_tdesc_powerpc_altivec32): Update.
	* features/rs6000/powerpc-7400.c (initialize_tdesc_powerpc_7400):
	Update.
	* features/arm-with-iwmmxt.c (initialize_tdesc_arm_with_iwmmxt):
	Update.
	* dwarf2read.c (read_structure_type): Update.
	(read_enumeration_type): Likewise.
	(process_enumeration_scope): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_subroutine_type): Likewise.
	(read_base_type): Likewise.
	* coffread.c (coff_read_enum_type): Update.
	* ada-valprint.c (adjust_type_signedness): Update.
	* ada-typeprint.c (print_record_field_types): Update.
	* ada-lang.c (packed_array_type): Update.
	(empty_record): Don't reset TYPE_FLAGS.
	(ada_template_to_fixed_record_type_1): Update.
	(ada_template_to_fixed_record_type_1): Likewise.
	(template_to_static_fixed_type): Likewise.
	(to_record_with_fixed_variant_part): Likewise.
	(to_fixed_record_type): Likewise.
	(to_fixed_array_type): Likewise.
	(to_static_fixed_type): Likewise.
gdb/testsuite:
	* gdb.base/maint.exp: Update "maint print type".
@
text
@d1532 3
a1534 1
	pst->dirname = xstrdup (comp_unit_die.dirname);
@


1.276
log
@	* dwarf2read.c (processing_current_prefix): Delete static
	variable.
	(process_full_comp_unit): Do not set processing_current_prefix.
	(dwarf2_full_name): New function.
	(read_func_scope): Do not set processing_current_prefix.  Use
	determine_prefix.
	(read_structure_type): Do not set processing_current_prefix.  Remove
	unused inner cleanup.
	(process_structure_scope): Do not set processing_current_prefix.
	(read_enumeration_type): Use dwarf2_full_name.
	(determine_class_name): Return a const char *.  Put the result
	on the objfile obstack.  Use dwarf2_full_name.
	(read_namespace_type): New function.
	(read_namespace): Do not create the type here.  Use
	determine_prefix.
	(read_typedef): Use dwarf2_full_name.  Do not pass the name
	to init_type.
	(read_base_type): Do not pass the name to init_type.  Handle
	TYPE_FLAG_NOSIGN.
	(read_unspecified_type): Do not pass the name to init_type.
	(new_symbol): Use dwarf2_full_name instead of
	processing_current_prefix.
	(read_type_die): Do not set processing_current_prefix.  Handle
	DW_TAG_namespace.
	(determine_prefix): Handle specifications.  Return the result
	on the objfile obstack.  Handle unions correctly.
@
text
@d4051 1
a4051 1
  TYPE_FLAGS (type) |= TYPE_FLAG_STUB_SUPPORTED;
d4053 1
a4053 1
    TYPE_FLAGS (type) |= TYPE_FLAG_STUB;
d4243 1
a4243 1
    TYPE_FLAGS (type) |= TYPE_FLAG_STUB;
d4365 1
a4365 1
	TYPE_FLAGS (this_type) |= TYPE_FLAG_UNSIGNED;
d4703 2
a4704 1
	  gdb_assert ((type_flags & ~TYPE_FLAG_ADDRESS_CLASS_ALL) == 0);
d4851 1
a4851 1
    TYPE_FLAGS (ftype) |= TYPE_FLAG_PROTOTYPED;
d4874 1
a4874 1
	    TYPE_FLAGS (ftype) |= TYPE_FLAG_VARARGS;
d5004 1
a5004 1
    TYPE_FLAGS (type) |= TYPE_FLAG_NOSIGN;
@


1.275
log
@	* buildsym.c (add_symbol_to_list): Do not call
	cp_scan_for_anonymous_namespaces here.
	(finish_block): Do not call cp_set_block_scope here.
	* cp-namespace.c (processing_has_namespace_info)
	(processing_current_prefix): Delete.
	(cp_initialize_namespace): Do not initialize
	processing_has_namespace_info.
	(cp_scan_for_anonymous_namespaces): Use SYMBOL_DEMANGLED_NAME.  Do
	not check processing_has_namespace_info.
	(cp_set_block_scope): Take prefix and namespace info flag as
	arguments.  Honor namespaces regardless of a demangled name.
	* cp-support.h (processing_has_namespace_info)
	(processing_current_prefix): Delete declarations.
	(cp_set_block_scope): Update prototype.
	* dwarf2read.c (processing_has_namespace_info)
	(processing_current_prefix): New static variables.
	(read_file_scope): Initialize processing_has_namespace_info.
	(read_func_scope): Call cp_set_block_scope for C++.
	(new_symbol): Call cp_scan_for_anonymous_namespaces for C++.
	* symtab.c (symbol_demangled_name): Accept a const argument.
	* symtab.h (symbol_demangled_name): Update prototype.
@
text
@a149 17
/* This contains our best guess as to the name of the current
   enclosing namespace(s)/class(es), if any.  For example, if we're
   within the method foo() in the following code:

    namespace N {
      class C {
	void foo () {
	}
      };
    }

   then processing_current_prefix should be set to "N::C".  If
   processing_has_namespace_info is false, then this variable might
   not be reliable.  */

static const char *processing_current_prefix;

d933 2
a934 1
static char *determine_class_name (struct die_info *die, struct dwarf2_cu *cu);
a2638 3
  /* We're in the global namespace.  */
  processing_current_prefix = "";

d2772 38
a2975 2
  const char *previous_prefix = processing_current_prefix;
  struct cleanup *back_to = NULL;
a2987 36
  if (cu->language == language_cplus
      || cu->language == language_java)
    {
      struct dwarf2_cu *spec_cu = cu;
      struct die_info *spec_die = die_specification (die, &spec_cu);

      /* NOTE: carlton/2004-01-23: We have to be careful in the
         presence of DW_AT_specification.  For example, with GCC 3.4,
         given the code

           namespace N {
             void foo() {
               // Definition of N::foo.
             }
           }

         then we'll have a tree of DIEs like this:

         1: DW_TAG_compile_unit
           2: DW_TAG_namespace        // N
             3: DW_TAG_subprogram     // declaration of N::foo
           4: DW_TAG_subprogram       // definition of N::foo
                DW_AT_specification   // refers to die #3

         Thus, when processing die #4, we have to pretend that we're
         in the context of its DW_AT_specification, namely the contex
         of die #3.  */
	
      if (spec_die != NULL)
	{
	  char *specification_prefix = determine_prefix (spec_die, spec_cu);
	  processing_current_prefix = specification_prefix;
	  back_to = make_cleanup (xfree, specification_prefix);
	}
    }

d3032 1
a3032 1
			processing_current_prefix,
a3048 4

  processing_current_prefix = previous_prefix;
  if (back_to != NULL)
    do_cleanups (back_to);
a3999 2
  const char *previous_prefix = processing_current_prefix;
  struct cleanup *back_to = NULL;
d4001 1
d4015 2
a4016 6
	  char *new_prefix = determine_class_name (die, cu);
	  TYPE_TAG_NAME (type) = obsavestring (new_prefix,
					       strlen (new_prefix),
					       &objfile->objfile_obstack);
	  back_to = make_cleanup (xfree, new_prefix);
	  processing_current_prefix = new_prefix;
a4063 1
      struct cleanup *back_to = make_cleanup (null_cleanup, NULL);
a4162 2

      do_cleanups (back_to);
d4165 1
a4165 4
  processing_current_prefix = previous_prefix;
  if (back_to != NULL)
    do_cleanups (back_to);

a4172 1
  const char *previous_prefix = processing_current_prefix;
a4178 2
  if (TYPE_TAG_NAME (this_type) != NULL)
    processing_current_prefix = TYPE_TAG_NAME (this_type);
a4206 2

  processing_current_prefix = previous_prefix;
d4218 1
a4218 1
  char *name;
d4223 1
a4223 1
  name = dwarf2_name (die, cu);
d4225 1
a4225 14
    {
      if (processing_has_namespace_info)
	{
	  TYPE_TAG_NAME (type) = typename_concat (&objfile->objfile_obstack,
						  processing_current_prefix,
						  name, cu);
	}
      else
	{
	  /* The name is already allocated along with this objfile, so
	     we don't need to duplicate it for the type.  */
	  TYPE_TAG_NAME (type) = name;
	}
    }
d4249 2
a4250 2
   a named C++ or Java compound type.  Return the name in question; the caller
   is responsible for xfree()'ing it.  */
d4252 1
a4252 1
static char *
d4255 1
a4255 14
  struct cleanup *back_to = NULL;
  struct dwarf2_cu *spec_cu = cu;
  struct die_info *spec_die = die_specification (die, &spec_cu);
  char *new_prefix = NULL;

  /* If this is the definition of a class that is declared by another
     die, then processing_current_prefix may not be accurate; see
     read_func_scope for a similar example.  */
  if (spec_die != NULL)
    {
      char *specification_prefix = determine_prefix (spec_die, spec_cu);
      processing_current_prefix = specification_prefix;
      back_to = make_cleanup (xfree, specification_prefix);
    }
d4270 1
a4270 1
	      new_prefix 
d4275 8
a4282 2
	      if (new_prefix != NULL)
		break;
d4288 1
a4288 9
    {
      const char *name = dwarf2_name (die, cu);
      new_prefix = typename_concat (NULL, processing_current_prefix,
				    name ? name : "<<anonymous>>", 
				    cu);
    }

  if (back_to != NULL)
    do_cleanups (back_to);
d4553 1
a4553 1
/* Read a C++ namespace.  */
d4555 2
a4556 2
static void
read_namespace (struct die_info *die, struct dwarf2_cu *cu)
d4559 1
a4559 2
  const char *previous_prefix = processing_current_prefix;
  const char *name;
d4561 11
a4571 2
  struct die_info *current_die;
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
d4577 24
a4600 10
  if (previous_prefix[0] == '\0')
    {
      processing_current_prefix = name;
    }
  else
    {
      char *temp_name = typename_concat (NULL, previous_prefix, name, cu);
      make_cleanup (xfree, temp_name);
      processing_current_prefix = temp_name;
    }
d4610 1
a4610 7
      /* FIXME: carlton/2003-06-27: Once GDB is more const-correct,
	 this cast will hopefully become unnecessary.  */
      type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
			(char *) processing_current_prefix,
			objfile);
      TYPE_TAG_NAME (type) = TYPE_NAME (type);

a4611 1
      set_die_type (die, type, cu);
d4613 1
d4615 6
a4620 3
	cp_add_using_directive (processing_current_prefix,
				strlen (previous_prefix),
				strlen (processing_current_prefix));
a4632 3

  processing_current_prefix = previous_prefix;
  do_cleanups (back_to);
d4912 1
a4912 1
  char *name = NULL;
d4915 1
a4915 1
  name = dwarf2_name (die, cu);
d4917 2
a4918 1
			 TYPE_FLAG_TARGET_STUB, name, objfile);
d4998 2
a4999 1
  type = init_type (code, size, type_flags, name, objfile);
d5002 3
d5086 2
a5087 2
  type = init_type (TYPE_CODE_VOID, 0, 0, dwarf2_name (die, cu),
		    cu->objfile);
d7537 1
a7537 7
	  if (processing_has_namespace_info
	      && processing_current_prefix[0] != '\0')
	    {
	      SYMBOL_LINKAGE_NAME (sym) = typename_concat (&objfile->objfile_obstack,
							   processing_current_prefix,
							   name, cu);
	    }
d7549 1
a7549 7
	  if (processing_has_namespace_info
	      && processing_current_prefix[0] != '\0')
	    {
	      SYMBOL_LINKAGE_NAME (sym) = typename_concat (&objfile->objfile_obstack,
							   processing_current_prefix,
							   name, cu);
	    }
a7774 3
  char *prefix;
  const char *old_prefix;
  struct cleanup *back_to;
a7780 5
  prefix = determine_prefix (die, cu);
  old_prefix = processing_current_prefix;
  back_to = make_cleanup (xfree, prefix);
  processing_current_prefix = prefix;

d7832 3
a7840 2
  processing_current_prefix = old_prefix;
  do_cleanups (back_to);
d7845 1
a7845 1
   or "" if we can't tell.  The caller should xfree the result.  */
d7847 11
a7857 3
/* NOTE: carlton/2004-01-23: See read_func_scope (and the comment
   therein) for an example of how to use this function to deal with
   DW_AT_specification.  */
d7862 3
a7864 1
  struct die_info *parent;
d7868 1
a7868 1
    return NULL;
d7870 2
a7871 1
  parent = die->parent;
d7873 22
a7894 1
  if (parent == NULL)
d7896 2
a7897 1
      return xstrdup ("");
d7899 3
d7903 2
a7904 2
    {
      switch (parent->tag) {
d7906 3
a7908 21
	{
	  /* FIXME: carlton/2004-03-05: Should I follow extension dies
	     before doing this check?  */
	  struct type *parent_type = get_die_type (parent, cu);
	  if (parent_type != NULL && TYPE_TAG_NAME (parent_type) != NULL)
	    {
	      return xstrdup (TYPE_TAG_NAME (parent_type));
	    }
	  else
	    {
	      int dummy;
	      char *parent_prefix = determine_prefix (parent, cu);
	      char *retval = typename_concat (NULL, parent_prefix,
					      namespace_name (parent, &dummy,
							      cu),
					      cu);
	      xfree (parent_prefix);
	      return retval;
	    }
	}
	break;
d7912 9
a7920 20
	{
	  struct type *parent_type = get_die_type (parent, cu);
	  if (parent_type != NULL && TYPE_TAG_NAME (parent_type) != NULL)
	    {
	      return xstrdup (TYPE_TAG_NAME (parent_type));
	    }
	  else
	    {
	      const char *old_prefix = processing_current_prefix;
	      char *new_prefix = determine_prefix (parent, cu);
	      char *retval;

	      processing_current_prefix = new_prefix;
	      retval = determine_class_name (parent, cu);
	      processing_current_prefix = old_prefix;

	      xfree (new_prefix);
	      return retval;
	    }
	}
a7923 1
    }
@


1.274
log
@	* ax-gdb.c (gen_var_ref): Use SYMBOL_LINKAGE_NAME.
	* blockframe.c (find_pc_partial_function): Likewise.
	* buildsym.c (find_symbol_in_list): Likewise.
	* c-valprint.c (c_val_print): Likewise.
	* coffread.c (patch_opaque_types, process_coff_symbol): Likewise.
	(coff_read_enum_type): Likewise.  Use SYMBOL_SET_LINKAGE_NAME.
	* cp-support.c (cp_remove_params): Renamed from remove_params and
	made global.
	(overload_list_add_symbol): Update call to remove_params.
	* cp-support.h (cp_remove_params): Declare.
	* dwarf2read.c (process_enumeration_scope): Use SYMBOL_LINKAGE_NAME.
	(dwarf2_const_value): Use SYMBOL_PRINT_NAME.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* f-valprint.c (info_common_command, there_is_a_visible_common_named):
	Use SYMBOL_LINKAGE_NAME to find symbols and SYMBOL_PRINT_NAME
	for messages.
	* findvar.c (read_var_value): Use SYMBOL_LINKAGE_NAME.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Likewise.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline)
	(hppa_hpux_skip_trampoline_code): Use SYMBOL_LINKAGE_NAME to find
	symbols and SYMBOL_PRINT_NAME for messages.
	* jv-lang.c (add_class_symbol): Use SYMBOL_SET_LINKAGE_NAME.
	* linespec.c (decode_line_2): Use SYMBOL_LINKAGE_NAME.
	* mdebugread.c (parse_symbol): Use SYMBOL_LINKAGE_NAME and
	SYMBOL_SET_LINKAGE_NAME.
	(mylookup_symbol): Use SYMBOL_LINKAGE_NAME.
	* minsyms.c (add_minsym_to_demangled_hash_table): Use
	SYMBOL_SEARCH_NAME.
	(lookup_minimal_symbol): Use SYMBOL_LINKAGE_NAME or
	SYMBOL_MATCHES_SEARCH_NAME, depending on the pass.
	* objfiles.h (ALL_OBJFILE_MSYMBOLS): Use SYMBOL_LINKAGE_NAME.
	* printcmd.c (build_address_symbolic): Use SYMBOL_LINKAGE_NAME.
	(address_info): Use SYMBOL_PRINT_NAME for messages and
	SYMBOL_LINKAGE_NAME for lookups.
	* sol-thread.c (info_cb): Use SYMBOL_PRINT_NAME for messages.
	* stabsread.c (patch_block_stabs, define_symbol)
	(read_type, read_enum_type, common_block_end)
	(cleanup_undefined_types_1, scan_file_globals): Use
	SYMBOL_LINKAGE_NAME, SYMBOL_SET_LINKAGE_NAME, ALL_OBJFILE_MSYMBOLS,
	and SYMBOL_PRINT_NAME.
	* stack.c (print_frame_args): Use SYMBOL_LINKAGE_NAME.
	(print_frame, frame_info): Use SYMBOL_PRINT_NAME for output.  Use
	cp_remove_params instead of cplus_demangle.
	(print_block_frame_labels, print_frame_arg_vars): Use
	SYMBOL_LINKAGE_NAME.
	* symmisc.c (dump_msymbols): Use ALL_OBJFILE_MSYMBOLS and
	SYMBOL_LINKAGE_NAME.
	(dump_symtab_1, print_symbol, print_partial_symbols)
	(maintenance_check_symtabs): Use SYMBOL_LINKAGE_NAME.
	* symtab.h (DEPRECATED_SYMBOL_NAME): Delete.
	(SYMBOL_SET_LINKAGE_NAME): New.
	(SYMBOL_SET_NAMES): Add a comment.
	* tracepoint.c (set_traceframe_context, validate_actionline)
	(collect_symbol, scope_info): Use SYMBOL_LINKAGE_NAME for
	lookups and SYMBOL_PRINT_NAME for output.
	* typeprint.c (typedef_print): Use SYMBOL_LINKAGE_NAME.
	* xcoffread.c (process_xcoff_symbol): Use SYMBOL_SET_LINKAGE_NAME.
@
text
@d144 23
d2876 2
d3048 6
d7640 7
@


1.273
log
@	* dwarf2read.c (die_specification, dwarf2_extension, follow_die_ref):
	Make the dwarf2_cu * parameter output as well as input.  Update it if
	we follow a reference to another CU.
	(read_func_scope, determine_class_name, namespace_name, dwarf2_attr)
	(die_type, die_containing_type): Update calls to changed functions.
	Use the returned CU along with the returned DIE.
	(read_namespace): Use dwarf2_attr instead of dwarf2_extension.
@
text
@d4378 1
a4378 1
		  FIELD_NAME (fields[num_fields]) = DEPRECATED_SYMBOL_NAME (sym);
d7627 1
a7627 1
	dwarf2_const_value_length_mismatch_complaint (DEPRECATED_SYMBOL_NAME (sym),
d7651 1
a7651 1
	dwarf2_const_value_length_mismatch_complaint (DEPRECATED_SYMBOL_NAME (sym),
@


1.272
log
@	* dwarf2read.c (queue_comp_unit): Take an objfile argument.  Read
	in the DIEs here.
	(process_queue): Do not read in the DIEs here.
	(psymtab_to_symtab_1): Update call to queue_comp_unit.
	(read_full_die): Do not call queue_comp_unit from here.
	(maybe_queue_comp_unit): New function.
	(follow_die_ref): Use it.
@
text
@d851 1
a851 1
					   struct dwarf2_cu *);
d962 1
a962 1
					  struct dwarf2_cu *);
d996 1
a996 1
					struct dwarf2_cu *);
d2949 2
a2950 1
      struct die_info *spec_die = die_specification (die, cu);
d2976 1
a2976 1
	  char *specification_prefix = determine_prefix (spec_die, cu);
d4277 2
a4278 1
  struct die_info *spec_die = die_specification (die, cu);
d4286 1
a4286 1
      char *specification_prefix = determine_prefix (spec_die, cu);
d4620 1
a4620 1
  if (dwarf2_extension (die, cu) == NULL)
d4669 1
a4669 1
       current_die = dwarf2_extension (die, cu))
d6621 4
a6624 1
    return dwarf2_attr (follow_die_ref (die, spec, cu), name, cu);
d6656 2
a6657 1
   one.  */
d6660 1
a6660 1
die_specification (struct die_info *die, struct dwarf2_cu *cu)
d6662 2
a6663 1
  struct attribute *spec_attr = dwarf2_attr (die, DW_AT_specification, cu);
d6668 1
a6668 1
    return follow_die_ref (die, spec_attr, cu);
d7739 1
a7739 1
    type_die = follow_die_ref (die, type_attr, cu);
d7764 1
a7764 1
      type_die = follow_die_ref (die, type_attr, cu);
d8028 2
a8029 1
   is none.  */
d8032 1
a8032 1
dwarf2_extension (struct die_info *die, struct dwarf2_cu *cu)
d8036 1
a8036 1
  attr = dwarf2_attr (die, DW_AT_extension, cu);
d8040 1
a8040 1
  return follow_die_ref (die, attr, cu);
d9168 1
a9168 1
		struct dwarf2_cu *cu)
d9173 1
a9173 1
  struct dwarf2_cu *target_cu;
d9192 1
@


1.271
log
@	* dwarf2read.c (struct attribute): Move earlier.
	(struct die_info): Change attrs to a trailing array.
	(dwarf_alloc_die): Take the number of attributes.  Allocate space
	for them.
	(read_full_die): Update call to dwarf_alloc_die.  Do not manually
	allocate attributes.
@
text
@d2427 1
a2427 1
queue_comp_unit (struct dwarf2_per_cu_data *per_cu)
d2442 6
d2457 2
a2458 16
  /* Initially, there is just one item on the queue.  Load its DIEs,
     and the DIEs of any other compilation units it requires,
     transitively.  */

  for (item = dwarf2_queue; item != NULL; item = item->next)
    {
      /* Read in this compilation unit.  This may add new items to
	 the end of the queue.  */
      load_full_comp_unit (item->per_cu, objfile);

      item->per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = item->per_cu;
    }

  /* Now everything left on the queue needs to be read in.  Process
     them, one at a time, removing from the queue as we finish.  */
d2540 1
a2540 1
  queue_comp_unit (per_cu);
d6067 2
a6068 36
    {
      info_ptr = read_attribute (&die->attrs[i], &abbrev->attrs[i],
				 abfd, info_ptr, cu);

      /* If this attribute is an absolute reference to a different
	 compilation unit, make sure that compilation unit is loaded
	 also.  */
      if (die->attrs[i].form == DW_FORM_ref_addr
	  && (DW_ADDR (&die->attrs[i]) < cu->header.offset
	      || (DW_ADDR (&die->attrs[i])
		  >= cu->header.offset + cu->header.length)))
	{
	  struct dwarf2_per_cu_data *per_cu;
	  per_cu = dwarf2_find_containing_comp_unit (DW_ADDR (&die->attrs[i]),
						     cu->objfile);

	  /* Mark the dependence relation so that we don't flush PER_CU
	     too early.  */
	  dwarf2_add_dependence (cu, per_cu);

	  /* If it's already on the queue, we have nothing to do.  */
	  if (per_cu->queued)
	    continue;

	  /* If the compilation unit is already loaded, just mark it as
	     used.  */
	  if (per_cu->cu != NULL)
	    {
	      per_cu->cu->last_used = 0;
	      continue;
	    }

	  /* Add it to the queue.  */
	  queue_comp_unit (per_cu);
       }
    }
d9131 27
d9175 4
@


1.270
log
@	* dwarf2read.c (REF_HASH_SIZE): Delete.
	(struct dwarf2_cu): Replace die_ref_table with die_hash.
	(struct die_info): Remove next_ref.
	(store_in_ref_table): Remove offset argument.  Rewrite to use
	htab_find_slot_with_hash.
	(die_hash, die_eq): New.
	(read_comp_unit): Allocate the die_hash.
	(read_die_and_children): Update call to store_die_ref.
	(follow_die_ref): Rewrite to use htab_find_with_hash.
@
text
@d524 16
a546 1
    struct attribute *attrs;	/* An array of attributes */
a555 1
  };
d557 4
a560 14
/* Attributes have a name and a value */
struct attribute
  {
    enum dwarf_attribute name;
    enum dwarf_form form;
    union
      {
	char *str;
	struct dwarf_block *blk;
	unsigned long unsnd;
	long int snd;
	CORE_ADDR addr;
      }
    u;
d1004 1
a1004 1
static struct die_info *dwarf_alloc_die (struct dwarf2_cu *);
d6067 1
a6067 1
  die = dwarf_alloc_die (cu);
a6072 3
  die->attrs = (struct attribute *)
    obstack_alloc (&cu->comp_unit_obstack,
		   die->num_attrs * sizeof (struct attribute));
d9452 1
a9452 1
dwarf_alloc_die (struct dwarf2_cu *cu)
d9455 4
d9460 1
a9460 2
  die = (struct die_info *)
    obstack_alloc (&cu->comp_unit_obstack, sizeof (struct die_info));
@


1.269
log
@	* dwarf2read.c (free_die_list, copy_die): Delete.
	(dwarf_alloc_die): Take a CU argument.  Allocate the new DIE
	on the obstack.
	(read_full_die): Update call to dwarf_alloc_die.  Allocate
	attributes on the CU obstack.
	(free_one_comp_unit): Do not call free_die_list.
@
text
@a261 5
/* Fixed size for the DIE hash table.  */
#ifndef REF_HASH_SIZE
#define REF_HASH_SIZE 1021
#endif

d327 1
a327 1
  struct die_info *die_ref_table[REF_HASH_SIZE];
a531 1
    struct die_info *next_ref;	/* Next die in ref hash table */
d982 1
a982 1
static void store_in_ref_table (unsigned int, struct die_info *,
d5109 21
d5135 9
d5169 1
a5169 1
  store_in_ref_table (die->offset, die, cu);
d9118 1
a9118 2
store_in_ref_table (unsigned int offset, struct die_info *die,
		    struct dwarf2_cu *cu)
d9120 3
a9122 2
  int h;
  struct die_info *old;
d9124 1
a9124 4
  h = (offset % REF_HASH_SIZE);
  old = cu->die_ref_table[h];
  die->next_ref = old;
  cu->die_ref_table[h] = die;
a9177 1
  int h;
d9194 4
a9197 8
  h = (offset % REF_HASH_SIZE);
  die = target_cu->die_ref_table[h];
  while (die)
    {
      if (die->offset == offset)
	return die;
      die = die->next_ref;
    }
a9201 2

  return NULL;
@


1.268
log
@	* dwarf2read.c (read_die_and_children): Ignore NULL DIEs.
	(read_die_and_siblings): Likewise.  Do not add padding DIEs to the
	sibling list.
	(read_full_die): Do not allocate DIEs for abbrev 0.
	(follow_die_ref): Correct error message.
@
text
@a956 2
static void free_die_list (struct die_info *);

a979 2

struct die_info *copy_die (struct die_info *);
d1006 1
a1006 1
static struct die_info *dwarf_alloc_die (void);
a5198 19
/* Free a linked list of dies.  */

static void
free_die_list (struct die_info *dies)
{
  struct die_info *die, *next;

  die = dies;
  while (die)
    {
      if (die->child != NULL)
	free_die_list (die->child);
      next = die->sibling;
      xfree (die->attrs);
      xfree (die);
      die = next;
    }
}

d6039 1
a6039 1
  die = dwarf_alloc_die ();
d6046 2
a6047 1
    xmalloc (die->num_attrs * sizeof (struct attribute));
a7999 32
#if 0
struct die_info *
copy_die (struct die_info *old_die)
{
  struct die_info *new_die;
  int i, num_attrs;

  new_die = (struct die_info *) xmalloc (sizeof (struct die_info));
  memset (new_die, 0, sizeof (struct die_info));

  new_die->tag = old_die->tag;
  new_die->has_children = old_die->has_children;
  new_die->abbrev = old_die->abbrev;
  new_die->offset = old_die->offset;

  num_attrs = old_die->num_attrs;
  new_die->num_attrs = num_attrs;
  new_die->attrs = (struct attribute *)
    xmalloc (num_attrs * sizeof (struct attribute));

  for (i = 0; i < old_die->num_attrs; ++i)
    {
      new_die->attrs[i].name = old_die->attrs[i].name;
      new_die->attrs[i].form = old_die->attrs[i].form;
      new_die->attrs[i].u.addr = old_die->attrs[i].u.addr;
    }

  new_die->next = NULL;
  return new_die;
}
#endif

d9437 1
a9437 1
dwarf_alloc_die (void)
d9441 2
a9442 1
  die = (struct die_info *) xmalloc (sizeof (struct die_info));
a10066 2
  if (cu->dies)
    free_die_list (cu->dies);
@


1.267
log
@        * dwarf2read.c (read_attribute_value): Issue a complaint when
        adjusting size attribute values of 0xffffffff as zero.
@
text
@d5144 5
d5188 1
a5188 10
      if (!first_die)
	{
	  first_die = die;
	}
      else
	{
	  last_sibling->sibling = die;
	}

      if (die->tag == 0)
d5193 3
d5197 3
a5199 3
	{
	  last_sibling = die;
	}
d6050 1
a6050 4
      die = dwarf_alloc_die ();
      die->tag = 0;
      die->abbrev = abbrev_number;
      *diep = die;
d9239 1
a9239 1
	 (long) src_die->offset, (long) offset, cu->objfile->name);
@


1.266
log
@        * dwarf2read.c (read_attribute_value): Treat size attribute
        values of 0xffffffff as if the attribute value was zero.
@
text
@d6247 7
a6253 1
    DW_UNSND (attr) = 0;
@


1.265
log
@	* symtab.h (enum address_class): Remove LOC_REGPARM and
	LOC_COMPUTED_ARG.
	(struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.

	* ada-lang.c (ada_add_block_symbols): Use SYMBOL_IS_ARGUMENT.
	* buildsym.c (finish_block): Likewise.
	* stack.c (print_frame_args, print_block_frame_locals)
	(print_frame_arg_vars): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
	* tracepoint.c (add_local_symbols): Likewise.
	* mi/mi-cmd-stack.c (list_args_or_locals): Likewise.

	* coffread.c (process_coff_symbol): Set SYMBOL_IS_ARGUMENT.
	* dwarf2read.c (new_symbol): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.

	* ada-exp.y (select_possible_type_sym): Don't handle LOC_REGPARM
	and LOC_COMPUTED_ARG.
	* ada-lang.c (resolve_subexp, symtab_for_sym): Likewise.
	* ax-gdb.c (gen_var_ref): Likewise.
	* eval.c (evaluate_subexp_for_address): Likewise.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* tracepoint.c (collect_symbol, scope_info): Likewise.

testsuite/:
	* gdb.base/frame-args.exp: Handle arguments that are optimized
	out.
@
text
@d6237 12
@


1.264
log
@gdb/

2008-05-15  Pedro Alves  <pedro@@codesourcery.com>
	    Ulrich Weigand  <uweigand@@de.ibm.com>

	* minsyms.c (lookup_minimal_symbol_by_pc_name): New function.
	* symtab.h (lookup_minimal_symbol_by_pc_name): Add prototype.

	* symtab.c (fixup_section): Remove prototype.  Add ADDR parameter;
	use it instead of ginfo->value.address.  Look up minimal symbol by
	address and name.  Assume OBJFILE is non-NULL.
	(fixup_symbol_section): Ensure we always have an objfile to look
	into.  Extract and pass to fixup_section the symbol's address that
	will match the minimal symbol's address.
	(fixup_psymbol_section): Likewise.

	(find_pc_sect_psymtab): Fall back to non-addrmap case when debugging
	overlays and the addrmap returned the wrong section.

	* dwarf2read.c (var_decode_location): Set SYMBOL_CLASS before
	calling fixup_symbol_section.


gdb/testsuite/

2008-05-15  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.base/fixsection.exp: New file.
	* gdb.base/fixsection0.c: New file.
	* gdb.base/fixsection1.c: New file.
@
text
@d7487 1
a7491 3
	      /* FIXME drow/2003-07-31: Is LOC_COMPUTED_ARG necessary?  */
	      if (SYMBOL_CLASS (sym) == LOC_COMPUTED)
		SYMBOL_CLASS (sym) = LOC_COMPUTED_ARG;
@


1.263
log
@	* ada-lang.c: Update throughout to use symbol_matches_domain
	instead of matching the symbol domain explictly.
	* dwarf2read.c (add_partial_symbol): Do not add new psym for
	STRUCT_DOMAIN. Make sure you recognize c++ struct and java and ada
	class as typedefs. See lookup_partial_symbol function.
	(new_symbol): Similar to add_partial_symbol, do not create
	symbol for the typedef. See lookup_block_symbol.
	* symtab.c (symbol_matches_domain): New function, takes care
	of dual meaning of STRUCT_DOMAIN symbol for c++, ada and java.
	(lookup_partial_symbol): Use symbol_matches_domain to see if the
	found psym domain matches the given domain.
	(lookup_block_symbol): Likewise.
@
text
@d7326 1
a7329 1
      SYMBOL_CLASS (sym) = LOC_STATIC;
@


1.262
log
@	* dwarf2read.c (struct dwarf2_cu): Add type_hash.
	(struct die_info): Remove type.
	(read_type_die, read_typedef, read_base_type, read_subrange_type)
	(read_structure_type, read_enumeration_type, read_array_type)
	(read_tag_pointer_type, read_tag_ptr_to_member_type)
	(read_tag_reference_type, read_tag_const_type, read_tag_volatile_type)
	(read_tag_string_type, read_subroutine_type, read_set_type)
	(read_unspecified_type): Delete prototypes.  Remove check for
	already-loaded type.  Return the new type.
	(set_die_type): Return the new type.
	(reset_die_and_siblings_types): Delete.
	(load_comp_unit, load_full_comp_unit): Set type_hash.
	(process_queue): Remove call to reset_die_and_siblings_types.
	(process_die): Do not read most types here.  Use read_type_die
	for others.
	(read_func_scope, dwarf2_add_member_fn): Use read_type_die.
	(quirk_gcc_member_function_pointer): Return the new type.
	(process_structure_scope, process_enumeration_scope): Use
	get_die_type and read the DIE's type.
	(read_full_die): Do not initialize die->type.
	(tag_type_to_type): Use read_type_die.
	(read_type_die): Check for already defined types.  Return the
	type.
	(determine_prefix): Use get_die_type.
	(set_die_type): Return the type.
	(get_die_type): Take a CU argument.  Check for no type_hash.
@
text
@a2068 10
      if (cu->language == language_cplus
          || cu->language == language_java
          || cu->language == language_ada)
	{
	  /* For C++ and Java, these implicitly act as typedefs as well. */
	  add_psymbol_to_list (actual_name, strlen (actual_name),
			       VAR_DOMAIN, LOC_TYPEDEF,
			       &objfile->global_psymbols,
			       0, (CORE_ADDR) 0, cu->language, objfile);
	}
d7558 1
a7558 2
	       defines a typedef for the class.  Synthesize a typedef symbol
	       so that "ptype foo" works as expected.  */
a7562 5
		struct symbol *typedef_sym = (struct symbol *)
		  obstack_alloc (&objfile->objfile_obstack,
				 sizeof (struct symbol));
		*typedef_sym = *sym;
		SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
a7567 1
		add_symbol_to_list (typedef_sym, list_to_add);
@


1.261
log
@	* dwarf2read.c (dwarf2_ranges_read, read_partial_die): Initialize
	locals.
@
text
@d323 5
a546 2

    struct type *type;		/* Cached type information */
d886 1
a886 1
static void read_type_die (struct die_info *, struct dwarf2_cu *);
a894 6
static void read_typedef (struct die_info *, struct dwarf2_cu *);

static void read_base_type (struct die_info *, struct dwarf2_cu *);

static void read_subrange_type (struct die_info *die, struct dwarf2_cu *cu);

a926 2
static void read_structure_type (struct die_info *, struct dwarf2_cu *);

a937 2
static void read_enumeration_type (struct die_info *, struct dwarf2_cu *);

a941 2
static void read_array_type (struct die_info *, struct dwarf2_cu *);

a944 15
static void read_tag_pointer_type (struct die_info *, struct dwarf2_cu *);

static void read_tag_ptr_to_member_type (struct die_info *,
					 struct dwarf2_cu *);

static void read_tag_reference_type (struct die_info *, struct dwarf2_cu *);

static void read_tag_const_type (struct die_info *, struct dwarf2_cu *);

static void read_tag_volatile_type (struct die_info *, struct dwarf2_cu *);

static void read_tag_string_type (struct die_info *, struct dwarf2_cu *);

static void read_subroutine_type (struct die_info *, struct dwarf2_cu *);

d1053 2
a1054 5
static void set_die_type (struct die_info *, struct type *,
			  struct dwarf2_cu *);

static void reset_die_and_siblings_types (struct die_info *,
					  struct dwarf2_cu *);
d1070 1
a1070 2
static void read_set_type (struct die_info *, struct dwarf2_cu *);

d1678 1
a2478 6

      /* If this compilation unit has already had full symbols created,
	 reset the TYPE fields in each DIE.  */
      if (item->per_cu->type_hash)
	reset_die_and_siblings_types (item->per_cu->cu->dies,
				      item->per_cu->cu);
d2612 1
a2725 1
      read_subroutine_type (die, cu);
a2741 1
      read_structure_type (die, cu);
a2744 1
      read_enumeration_type (die, cu);
d2748 3
a2750 3
    /* FIXME drow/2004-03-14: These initialize die->type, but do not create
       a symbol or process any children.  Therefore it doesn't do anything
       that won't be done on-demand by read_type_die.  */
a2751 2
      read_subroutine_type (die, cu);
      break;
a2752 2
      read_set_type (die, cu);
      break;
a2753 2
      read_array_type (die, cu);
      break;
a2754 2
      read_tag_pointer_type (die, cu);
      break;
a2755 2
      read_tag_ptr_to_member_type (die, cu);
      break;
a2756 2
      read_tag_reference_type (die, cu);
      break;
a2757 1
      read_tag_string_type (die, cu);
a2758 1
    /* END FIXME */
a2760 5
      read_base_type (die, cu);
      /* Add a typedef symbol for the type definition, if it has a
	 DW_AT_name.  */
      new_symbol (die, die->type, cu);
      break;
a2761 1
      read_subrange_type (die, cu);
d2764 1
a2764 1
      new_symbol (die, die->type, cu);
d3012 1
a3012 1
  new->name = new_symbol (die, die->type, cu);
d3749 1
d3802 2
a3803 1
  if (die->type && TYPE_CODE (die->type) == TYPE_CODE_FUNC)
d3805 1
a3805 1
      int nparams = TYPE_NFIELDS (die->type);
d3807 1
a3807 1
      /* TYPE is the domain of this method, and DIE->TYPE is the type
d3810 4
a3813 4
			    TYPE_TARGET_TYPE (die->type),
			    TYPE_FIELDS (die->type),
			    TYPE_NFIELDS (die->type),
			    TYPE_VARARGS (die->type));
d3821 1
a3821 1
      if (nparams == 0 || TYPE_FIELD_ARTIFICIAL (die->type, 0) == 0)
d3936 1
a3936 1
static int
d3952 1
a3952 1
    return 0;
d3961 1
a3961 1
    return 0;
d3969 1
a3969 1
    return 0;
d3976 1
a3976 1
    return 0;
d3982 1
a3982 1
    return 0;
d3990 1
a3990 3
  set_die_type (die, type, cu);

  return 1;
d4009 1
a4009 1
static void
d4019 3
a4021 5
  if (die->type)
    return;

  if (quirk_gcc_member_function_pointer (die, cu))
    return;
a4104 1
	      read_type_die (child_die, cu);
d4191 2
d4201 1
d4203 5
a4207 2
  if (TYPE_TAG_NAME (die->type) != NULL)
    processing_current_prefix = TYPE_TAG_NAME (die->type);
d4235 1
a4235 1
    new_symbol (die, die->type, cu);
d4243 1
a4243 1
static void
a4250 3
  if (die->type)
    return;

d4289 1
a4289 1
  set_die_type (die, type, cu);
d4367 1
d4371 3
d4388 1
a4388 1
		  sym = new_symbol (child_die, die->type, cu);
d4415 4
a4418 4
	  TYPE_NFIELDS (die->type) = num_fields;
	  TYPE_FIELDS (die->type) = (struct field *)
	    TYPE_ALLOC (die->type, sizeof (struct field) * num_fields);
	  memcpy (TYPE_FIELDS (die->type), fields,
d4423 1
a4423 1
	TYPE_FLAGS (die->type) |= TYPE_FLAG_UNSIGNED;
d4426 1
a4426 1
  new_symbol (die, die->type, cu);
d4433 1
a4433 1
static void
a4445 6
  /* Return if we've already decoded this type. */
  if (die->type)
    {
      return;
    }

d4454 2
a4455 3
      set_die_type (die, create_array_type (NULL, element_type, range_type),
		    cu);
      return;
d4464 2
a4465 3
          read_subrange_type (child_die, cu);

          if (child_die->type != NULL)
d4477 1
a4477 1
	      range_types[ndim++] = child_die->type;
d4517 1
a4517 1
  set_die_type (die, type, cu);
d4557 1
a4557 1
static void
d4560 3
a4562 2
  if (die->type == NULL)
    die->type = create_set_type ((struct type *) NULL, die_type (die, cu));
d4710 1
a4710 1
static void
a4719 5
  if (die->type)
    {
      return;
    }

d4758 1
a4758 1
  set_die_type (die, type, cu);
d4764 1
a4764 1
static void
a4771 5
  if (die->type)
    {
      return;
    }

d4780 1
a4780 1
  set_die_type (die, type, cu);
d4786 1
a4786 1
static void
a4792 5
  if (die->type)
    {
      return;
    }

d4803 1
a4803 1
  set_die_type (die, type, cu);
d4806 1
a4806 1
static void
d4809 1
a4809 6
  struct type *base_type;

  if (die->type)
    {
      return;
    }
d4812 2
a4813 2
  set_die_type (die, make_cv_type (1, TYPE_VOLATILE (base_type), base_type, 0),
		cu);
d4816 1
a4816 1
static void
d4819 1
a4819 6
  struct type *base_type;

  if (die->type)
    {
      return;
    }
d4822 2
a4823 2
  set_die_type (die, make_cv_type (TYPE_CONST (base_type), 1, base_type, 0),
		cu);
d4831 1
a4831 1
static void
a4838 5
  if (die->type)
    {
      return;
    }

d4862 1
a4862 1
  set_die_type (die, type, cu);
d4876 1
a4876 1
static void
a4882 5
  /* Decode the type that this subroutine returns */
  if (die->type)
    {
      return;
    }
d4946 1
a4946 1
  set_die_type (die, ftype, cu);
d4949 1
a4949 1
static void
d4955 1
d4957 6
a4962 8
  if (!die->type)
    {
      name = dwarf2_name (die, cu);
      set_die_type (die, init_type (TYPE_CODE_TYPEDEF, 0,
				    TYPE_FLAG_TARGET_STUB, name, objfile),
		    cu);
      TYPE_TARGET_TYPE (die->type) = die_type (die, cu);
    }
d4968 1
a4968 1
static void
a4979 6
  /* If we've already decoded this die, this is a no-op. */
  if (die->type)
    {
      return;
    }

d5042 1
a5042 1
  set_die_type (die, type, cu);
d5047 1
a5047 1
static void
a5057 4
  /* If we have already decoded this die, then nothing more to do.  */
  if (die->type)
    return;

d5113 1
a5113 1
  set_die_type (die, range_type, cu);
d5116 1
a5116 1
static void
a5120 3
  if (die->type)
    return;

d5126 1
a5126 1
  set_die_type (die, type, cu);
a6063 1
      die->type = NULL;
a6079 1
  die->type = NULL;
d7817 4
a7820 1
  if (die->type)
d7822 3
a7824 12
      return die->type;
    }
  else
    {
      read_type_die (die, cu);
      if (!die->type)
	{
	  dump_die (die);
	  error (_("Dwarf Error: Cannot find type of die [in module %s]"), 
			  cu->objfile->name);
	}
      return die->type;
d7826 1
d7829 1
a7829 1
static void
d7832 12
a7843 3
  char *prefix = determine_prefix (die, cu);
  const char *old_prefix = processing_current_prefix;
  struct cleanup *back_to = make_cleanup (xfree, prefix);
d7845 1
a7845 1
  
d7852 1
a7852 1
      read_structure_type (die, cu);
d7855 1
a7855 1
      read_enumeration_type (die, cu);
d7859 1
a7859 1
      read_subroutine_type (die, cu);
d7862 1
a7862 1
      read_array_type (die, cu);
d7865 1
a7865 1
      read_set_type (die, cu);
d7868 1
a7868 1
      read_tag_pointer_type (die, cu);
d7871 1
a7871 1
      read_tag_ptr_to_member_type (die, cu);
d7874 1
a7874 1
      read_tag_reference_type (die, cu);
d7877 1
a7877 1
      read_tag_const_type (die, cu);
d7880 1
a7880 1
      read_tag_volatile_type (die, cu);
d7883 1
a7883 1
      read_tag_string_type (die, cu);
d7886 1
a7886 1
      read_typedef (die, cu);
d7889 1
a7889 1
      read_subrange_type (die, cu);
d7892 1
a7892 1
      read_base_type (die, cu);
d7895 1
a7895 1
      read_unspecified_type (die, cu);
d7905 1
d7937 2
a7938 1
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
d7940 1
a7940 1
	      return xstrdup (TYPE_TAG_NAME (parent->type));
d7959 2
a7960 1
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
d7962 1
a7962 1
	      return xstrdup (TYPE_TAG_NAME (parent->type));
a8040 1
  new_die->type = NULL;
d10293 1
a10293 1
   table if necessary.  */
d10295 1
a10295 1
static void
d10300 13
a10312 14
  die->type = type;

  if (cu->per_cu == NULL)
    return;

  if (cu->per_cu->type_hash == NULL)
    cu->per_cu->type_hash
      = htab_create_alloc_ex (cu->header.length / 24,
			      offset_and_type_hash,
			      offset_and_type_eq,
			      NULL,
			      &cu->objfile->objfile_obstack,
			      hashtab_obstack_allocate,
			      dummy_obstack_deallocate);
d10317 1
a10317 1
    htab_find_slot_with_hash (cu->per_cu->type_hash, &ofs, ofs.offset, INSERT);
d10320 1
d10323 2
a10324 2
/* Find the type for DIE in TYPE_HASH, or return NULL if DIE does not
   have a saved type.  */
d10327 1
a10327 1
get_die_type (struct die_info *die, htab_t type_hash)
d10330 4
a10342 19
/* Restore the types of the DIE tree starting at START_DIE from the hash
   table saved in CU.  */

static void
reset_die_and_siblings_types (struct die_info *start_die, struct dwarf2_cu *cu)
{
  struct die_info *die;

  if (cu->per_cu->type_hash == NULL)
    return;

  for (die = start_die; die != NULL; die = die->sibling)
    {
      die->type = get_die_type (die, cu->per_cu->type_hash);
      if (die->child != NULL)
	reset_die_and_siblings_types (die->child, cu);
    }
}

@


1.260
log
@	gdb/
	* Makefile.in: Update dependencies.
	* dwarf2read.c: Include "addrmap.h"
	(struct dwarf2_cu): New fields RANGES_OFFSET and HAS_RANGES_OFFSET.
	(dwarf2_ranges_read): New prototype.
	(dwarf2_build_psymtabs_hard): Initialize and prepare PSYMTABS_ADDRMAP.
	Add discontiguous range to PSYMTABS_ADDRMAP by DWARF2_RANGES_READ on
	HAS_RANGES_OFFSET, otherwise add there the contiguous range.
	(dwarf2_ranges_read): New parameter RANGES_PST, update the function
	comment for it.  Add the found ranges to RANGES_PST.  New variable
	BASEADDR, initialize it the common way.
	(dwarf2_get_pc_bounds): Update the caller for the new parameter.
	(read_partial_die): `DW_AT_ranges' now only sets RANGES_OFFSET and
	HAS_RANGES_OFFSET for the later processing.
	* objfiles.h (struct objfile): New field PSYMTABS_ADDRMAP.
	* symtab.c: Include "addrmap.h"
	(find_pc_sect_psymtab): Support reading the field PSYMTABS_ADDRMAP.
	Move the psymtab locator into ...
	(find_pc_sect_psymtab_closer): ... a new function.

	gdb/testsuite/
	* gdb.dwarf2/dw2-ranges.S: Merge the secondary section with `.fini'.
	* gdb.dwarf2/dw2-ranges.exp: Compile also `dw2-ranges2.S' and
	`dw2-ranges3.S' and test also their MAIN2, FUNC2 and MAIN3 symbols.
	* gdb.dwarf2/dw2-ranges2.S, gdb.dwarf2/dw2-ranges3.S: New files.
@
text
@d3229 1
a3229 2
  if (ranges_pst != NULL)
    baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d5860 1
a5860 1
  CORE_ADDR base_address;
@


1.259
log
@	Set CU BASE_ADDRESS already from partial DIEs.
	* dwarf2read.c (read_partial_die): New variables BASE_ADDRESS and
	BASE_ADDRESS_TYPE.  Set these variables from DW_AT_LOW_PC and
	DW_AT_ENTRY_PC.  Set CU->HEADER.BASE_KNOWN and CU->HEADER.BASE_ADDRESS
	from these variables if it was still unset.
@
text
@d48 1
d307 3
d352 3
d904 3
d1485 3
d1553 2
a1554 1
				  comp_unit_die.lowpc,
d1587 9
d1626 6
d1655 4
d3179 2
a3180 1
   Return 1 if the attributes are present and valid, otherwise, return 0.  */
d3184 2
a3185 1
		    CORE_ADDR *high_return, struct dwarf2_cu *cu)
d3201 1
d3229 3
d3271 5
d3340 1
a3340 1
	  if (!dwarf2_ranges_read (DW_UNSND (attr), &low, &high, cu))
d5927 5
a5931 3
	  if (dwarf2_ranges_read (DW_UNSND (&attr), &part_die->lowpc,
				  &part_die->highpc, cu))
	    has_low_pc_attr = has_high_pc_attr = 1;
@


1.258
log
@gdb/
	* dwarf2read.c (dwarf2_const_value): Handle DW_FORM_strp.

gdb/testsuite/
	* gdb.dwarf2/dw2-strp.S, gdb.dwarf2/dw2-strp.exp: New files.
@
text
@d5817 9
d5863 6
d5874 8
d5974 8
@


1.257
log
@doc/ChangeLog:
--------------

	* gdb.texinfo (Set SH Calling convention): New @@item.
	(Show SH Calling convention): Ditto.

ChangeLog:
----------

	* NEWS: Add information on calling convention and new SH CLI options.

	* sh-tdep.c (sh_cc_gcc): New static string.
	(sh_cc_renesas): Ditto.
	(sh_cc_enum): New static string array.
	(sh_active_calling_convention): New static string pointer denoting
	active user chosen ABI.
	(sh_is_renesas_calling_convention): New function to return function
	specific ABI, or user choice if necessary.
	(sh_use_struct_convention): Rename first argument and turn around its
	meaning.  Check for renesas ABI and return accordingly.
	(sh_use_struct_convention_nofpu): New function.
	(sh_next_flt_argreg): Get function type as third parameter.  Check
	for renesas ABI and choose floating registers accordingly.
	(sh_push_dummy_call_fpu): Check for ABI and choose argument slot and
	struct return slot accordingly.
	(sh_push_dummy_call_nofpu): Ditto.
	(sh_return_value_nofpu): Call sh_use_struct_convention_nofpu from here.
	Evaluate ABI and give to sh_use_struct_convention_nofpu.
	(sh_return_value_fpu):  Evaluate ABI and give to
	sh_use_struct_convention.
	(show_sh_command): New function.
	(set_sh_command): Ditto.
	(_initialize_sh_tdep): Initialize `set/show sh calling-convention
	CLI command.

	* gdbarch.sh (return_value): Add func_type argument.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Ditto.
	* eval.c (evaluate_subexp_standard): Rename local variable value_type to
	val_type so as not to collide with value_type function.  Call
	using_struct_return with additional function type argument.
	* infcall.c (call_function_by_hand): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* infcmd.c (print_return_value): Take addition func_type argument.
	Call gdbarch_return_value with additional function type argument.
	(finish_command_continuation): Call print_return_value with additional
	function type argument.
	(finish_command): Ditto.
	* sparc-tdep.c (sparc32_push_dummy_code): Call using_struct_return with
	additional function type argument.
	* stack.c (return_command): Call using_struct_return and
	gdbarch_return_value with additional function type argument.
	* value.c (using_struct_return): Take additional function type argument.
	* value.h (using_struct_return): Accommodate declaration.
	* alpha-tdep.c (alpha_return_value): Add func_type argument.
	* amd64-tdep.c (amd64_return_value): Ditto.
	* arm-tdep.c (arm_return_value): Ditto.
	* avr-tdep.c (avr_return_value): Ditto.
	* cris-tdep.c (cris_return_value): Ditto.
	* frv-tdep.c (frv_return_value): Ditto.
	* h8300-tdep.c (h8300_return_value): Ditto.
	(h8300h_return_value): Ditto.
	* hppa-tdep.c (hppa32_return_value): Ditto.
	(hppa64_return_value): Ditto.
	* i386-tdep.c (i386_return_value): Ditto.
	* ia64-tdep.c (ia64_return_value): Ditto.
	* iq2000-tdep.c (iq2000_return_value): Ditto.
	* m32c-tdep.c (m32c_return_value): Ditto.
	* m32r-tdep.c (m32r_return_value): Ditto.
	* m68hc11-tdep.c (m68hc11_return_value): Ditto.
	* m68k-tdep.c (m68k_return_value): Ditto.
	(m68k_svr4_return_value): Ditto.
	* m88k-tdep.c  (m88k_return_value): Ditto.
	* mep-tdep.c (mep_return_value): Ditto.
	* mips-tdep.c (mips_eabi_return_value): Ditto.
	(mips_n32n64_return_value): Ditto.
	(mips_o32_return_value): Ditto.
	(mips_o64_return_value): Ditto.
	* mn10300-tdep.c (mn10300_return_value): Ditto.
	* mt-tdep.c (mt_return_value): Ditto.
	* ppc-linux-tdep.c (ppc_linux_return_value): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppc-tdep.h (ppc_sysv_abi_return_value): Ditto.
	(ppc_sysv_abi_broken_return_value): Ditto.
	(ppc64_sysv_abi_return_value): Ditto.
	* ppcnbsd-tdep.c (ppcnbsd_return_value): Ditto.
	* rs6000-tdep.c (rs6000_return_value): Ditto.
	* s390-tdep.c (s390_return_value): Ditto.
	* score-tdep.c (score_return_value): Ditto.
	* sh-tdep.c (sh_return_value_nofpu): Ditto.
	(sh_return_value_fpu): Ditto.
	* sh64-tdep.c (sh64_return_value): Ditto.
	* sparc-tdep.c (sparc32_return_value): Ditto.
	* sparc64-tdep.c (sparc64_return_value): Ditto.
	* spu-tdep.c (spu_return_value): Ditto.
	* v850-tdep.c (v850_return_value): Ditto.
	* vax-tdep.c (vax_return_value): Ditto.
	* xstormy16-tdep.c (xstormy16_return_value): Ditto.
	* xtensa-tdep.c (xtensa_return_value): Ditto.

	* gdbtypes.h (struct type): Add calling_convention member.
	* dwarf2read.c (read_subroutine_type): Add calling convention read
	from DW_AT_calling_convention attribute to function type.
@
text
@d7709 6
@


1.256
log
@	* dwarf2read.c (zlib_decompress_section): Define abfd in the
	!HAVE_ZLIB_H case.
@
text
@d4944 6
@


1.255
log
@	* configure.ac (AC_SEARCH_LIBS): Add check for zlib.
	* config.in, configure: Regenerate.
	* dwarf2read.c: Include zlib.h if present.
	Modified *_SECTION macros.
	(section_is_p): New.
	(dwarf2_locate_sections): Use section_is_p instead of strcmp
	(dwarf2_resize_section): New.
	to determine whether a given section has a given name.
	(zlib_decompress_section): New.
	(dwarf2_read_section): Read the compressed section if present
	in the binary.
	* testsuite/gdb.dwarf2/dw2-compressed.S: New file.
	* testsuite/gdb.dwarf2/dw2-compressed.exp: New file.
	* MAINTAINERS: Added myself to section Write After Approval.
@
text
@d5298 1
a5303 1
  bfd *abfd = objfile->obfd;
@


1.254
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d53 3
d201 14
a214 11
#define INFO_SECTION     ".debug_info"
#define ABBREV_SECTION   ".debug_abbrev"
#define LINE_SECTION     ".debug_line"
#define PUBNAMES_SECTION ".debug_pubnames"
#define ARANGES_SECTION  ".debug_aranges"
#define LOC_SECTION      ".debug_loc"
#define MACINFO_SECTION  ".debug_macinfo"
#define STR_SECTION      ".debug_str"
#define RANGES_SECTION   ".debug_ranges"
#define FRAME_SECTION    ".debug_frame"
#define EH_FRAME_SECTION ".eh_frame"
d1118 12
d1137 1
a1137 1
  if (strcmp (sectp->name, INFO_SECTION) == 0)
d1142 1
a1142 1
  else if (strcmp (sectp->name, ABBREV_SECTION) == 0)
d1147 1
a1147 1
  else if (strcmp (sectp->name, LINE_SECTION) == 0)
d1152 1
a1152 1
  else if (strcmp (sectp->name, PUBNAMES_SECTION) == 0)
d1157 1
a1157 1
  else if (strcmp (sectp->name, ARANGES_SECTION) == 0)
d1162 1
a1162 1
  else if (strcmp (sectp->name, LOC_SECTION) == 0)
d1167 1
a1167 1
  else if (strcmp (sectp->name, MACINFO_SECTION) == 0)
d1172 1
a1172 1
  else if (strcmp (sectp->name, STR_SECTION) == 0)
d1177 1
a1177 1
  else if (strcmp (sectp->name, FRAME_SECTION) == 0)
d1182 1
a1182 1
  else if (strcmp (sectp->name, EH_FRAME_SECTION) == 0)
d1191 1
a1191 1
  else if (strcmp (sectp->name, RANGES_SECTION) == 0)
d1202 34
d5291 78
d5370 2
a5371 1
   object file specified by OBJFILE into the objfile_obstack and return it.  */
d5379 1
d5384 15
d5400 4
@


1.253
log
@2008-03-18  Ulrich Weigand  <uweigand@@de.ibm.com>
	    Jim Blandy  <jimb@@codesourcery.com>
	    Daniel Jacobowitz  <drow@@false.org>

	* dwarf2expr.h (struct dwarf_expr_context): Add ADDR_SIZE member.
	(dwarf2_read_address): Update prototype.

	* dwarf2expr.c (unsigned_address_type): Add ADDR_SIZE parameter.
	(signed_address_type): Likewise.
	(dwarf2_read_address): Replace BYTES_READ parameter with ADDR_SIZE.
	(execute_stack_op): Update calls to unsigned_address_type,
	signed_address_type and dwarf2_read_address.  Fix implementation
	of DW_OP_deref_size.

	* dwarf2loc.h (dwarf2_per_cu_objfile): Add prototype.
	(dwarf2_per_cu_addr_size): Likewise.
	(struct dwarf2_locexpr_baton): Replace OBJFILE with PER_CU.
	(struct dwarf2_loclist_baton): Likewise.

	* dwarf2loc.c (find_location_expression): Update calls to
	dwarf2_read_address.  Use dwarf2_per_cu_objfile and
	dwarf2_per_cu_addr_size to retrieve PER_CU parameters.
	(locexpr_describe_location): Likewise.
	(dwarf2_evaluate_loc_desc): Replace OBJFILE with PER_CU parameter.
	Set ctx->addr_size to dwarf2_per_cu_addr_size (per_cu).
	(dwarf2_loc_desc_needs_frame): Add PER_CU parameter.  Set ctx->addr_size
	to dwarf2_per_cu_addr_size (per_cu).
	(locexpr_read_variable): Update dwarf2_evaluate_loc_desc call.
	(loclist_read_variable): Likewise.
	(locexpr_read_needs_frame): Update dwarf2_loc_desc_needs_frame call.

	* dwarf2read.c (dwarf2_symbol_mark_computed): Set baton->per_cu
	instead of baton->objfile.
	(dwarf2_per_cu_obfile): New function.
	(dwarf2_per_cu_addr_size): Likewise.

	* dwarf2-frame.c (struct comp_unit): Move higher.
	(struct dwarf2_cie): Add UNIT and ADDR_SIZE members.
	(execute_stack_op): Add ADDR_SIZE parameter; set ctx->addr_size.
	(execute_cfa_program): Add FDE parameter.  Replace EH_FRAME_P
	parameter by using fde->eh_frame_p.  Use read_encoded_value
	to implement DW_CFA_set_loc.
	(struct dwarf2_frame_cache): Add ADDR_SIZE member.
	(dwarf2_frame_cache): Set cache->addr_size.  Update calls to
	execute_stack_op and execute_cfa_program.
	(dwarf2_frame_prev_register): Update calls to execute_stack_op.
	(size_of_encoded_value): Remove.
	(read_encoded_value): Add PTR_LEN and FUNC_BASE parameters.
	Remove call to size_of_encoded_value.  Implement DW_EH_PE_funcrel.
	(add_cie): Set cie->unit backlink.
	(decode_frame_entry_1): Set cie->addr_size.  Update calls to
	read_encoded_value.
	(dwarf2_build_frame_info): Allocate UNIT on objfile obstack.
@
text
@d3433 1
d3510 1
a3510 1
	  if (gdbarch_bits_big_endian (current_gdbarch))
d4676 1
d4707 1
a4707 1
      if (gdbarch_address_class_type_flags_p (current_gdbarch))
d4712 1
a4712 1
			 (current_gdbarch, byte_size, addr_class);
d5049 1
d5067 1
a5067 1
	= init_type (TYPE_CODE_INT, gdbarch_addr_bit (current_gdbarch) / 8,
d7240 1
d7332 1
a7332 1
	      = builtin_type (current_gdbarch)->nodebug_data_symbol;
d7634 1
d7643 1
a7643 1
      return builtin_type (current_gdbarch)->builtin_void;
@


1.252
log
@2008-03-10  Matt Rice  <ratmice@@gmail.com>

	* dwarf2read.c (set_cu_language): Add DW_LANG_ObjC.
@
text
@a9820 7
  struct objfile *objfile = cu->objfile;

  /* Save the master objfile, so that we can report and look up the
     correct file containing this variable.  */
  if (objfile->separate_debug_objfile_backlink)
    objfile = objfile->separate_debug_objfile_backlink;

d9831 2
a9832 1
      baton->objfile = objfile;
d9852 2
a9853 1
      baton->objfile = objfile;
d9878 37
@


1.251
log
@        * dwarf2read.c (add_partial_symbol): Always store all Ada subprograms
        in the global scope.
        (new_symbol): Likewise.
@
text
@d6497 3
@


1.251.2.1
log
@2008-03-10  Matt Rice  <ratmice@@gmail.com>

	* dwarf2read.c (set_cu_language): Add DW_LANG_ObjC.
@
text
@a6496 3
    case DW_LANG_ObjC:
      cu->language = language_objc;
      break;
@


1.251.2.1.4.1
log
@Check in ARCompact simulator.  A valid configuration is arc-elf.
This is not quite finished and has most likely a few files that are
obsolete & not used, but it's good enough to run gcc regression tests.
@
text
@d785 1
a785 1
                                struct dwarf2_cu *, int *, unsigned int);
d958 1
a958 2
					       struct die_info *parent,
					       unsigned int dwarf2_sibling_offset);
d963 1
a963 2
					       struct die_info *parent,
					       unsigned int dwarf2_sibling_offset);
d5137 1
a5137 1
  return read_die_and_children (info_ptr, abfd, cu, &info_ptr, NULL, 0);
d5150 1
a5150 2
		       struct die_info *parent,
		       unsigned int dwarf2_last_sibling_offset)
d5156 1
a5156 2
  cur_ptr = read_full_die (&die, abfd, info_ptr, cu, &has_children,
			   dwarf2_last_sibling_offset);
d5161 2
a5162 2
      die->child = read_die_and_siblings (cur_ptr, abfd, cu, new_info_ptr,
					  die, dwarf2_last_sibling_offset);
d5183 1
a5183 2
		       struct die_info *parent,
		       unsigned int dwarf2_last_sibling_offset)
a5185 1
  struct attribute *attr = NULL;
d5194 1
a5194 8
	= read_die_and_children (cur_ptr, abfd, cu, &cur_ptr, parent,
				 dwarf2_last_sibling_offset);
      int ctr;

      /* Ramana. Workaround for Metaware compiler bug. We don't
	 use dwarf2_attr here because that follows DW_AT_specification
	 and creates issues for us here.We just need to find 
         the offset of the sibling for this DIE.  */
a5195 8
      for (ctr=0; ctr < die->num_attrs ;ctr ++)
	{
	  if (die->attrs[ctr].name == DW_AT_sibling)
	    {
	      dwarf2_last_sibling_offset = die->attrs[ctr].u.addr;
	      break;
	    }
	}
d5921 1
a5921 2
	       struct dwarf2_cu *cu, int *has_children,
	       unsigned int dwarf2_last_sibling_offset)
a5927 8

  /* The Metaware Compiler inserts a padding die in the middle
     of the debug info.  Ignore this till it is corrected. */
  if (dwarf2_last_sibling_offset && (offset < dwarf2_last_sibling_offset))
    {
      info_ptr += (dwarf2_last_sibling_offset - offset);
      offset = dwarf2_last_sibling_offset;
    }
@


1.250
log
@	* gdbarch.sh (function_list): Add new property bits_big_endian to
	gdbarch structure.
	* gdbarch.{c,h}: Regenerate.

	* value.c (struct value): Replace BITS_BIG_ENDIAN by
	gdbarch_bits_big_endian (comment).
	(unpack_field_as_long, modify_field): Likewise.
	* value.h: Likewise (comment).
	* valops.c (value_slice): Likewise.
	* valarith.c (value_subscript, value_bit_index): Likewise.
	* gdbtypes.h (field): Likewise (comment).
	* eval.c (evaluate_subexp_standard): Likewise.
	* dwarf2read.c (dwarf2_add_field): Likewise.
	* ada-lang.c (decode_packed_array, ada_value_primitive_packed_val)
	(move_bits, ada_value_assign, value_assign_to_component): Likewise.

	* defs.h (BITS_BIG_ENDIAN): Remove.



	* gdbint.texinfo (Target Conditionals): Replace the description of
	BITS_BIG_ENDIAN with a description of gdbarch_bits_big_endian.
@
text
@d1901 1
a1901 1
      if (pdi->is_external)
d1903 4
d7303 2
a7304 1
	  if (attr2 && (DW_UNSND (attr2) != 0))
d7306 6
@


1.249
log
@	* exec.c: #include "arch-utils.h"
	 (print_section_info): Use gdbarch_from_bfd to get at the
	current architecture. Replace current_gdbarch. Fix indention.
	Replace deprecated_print_address_numeric by paddress.
	* Makefile.in (exec.o) Add dependency to arch-utils.h.

	* valprint.c (val_print_string): Replace
	deprecated_print_address_numeric.
	* tracepoint.c (trace_mention, scope_info): Likewise.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1, print_symbol)
	(print_symbol, print_partial_symbols, maintenance_info_psymtabs)
	(maintenance_check_symtabs): Likewise.
	* symfile.c (list_overlays_command): Likewise.
	* stack.c (frame_info, print_block_frame_labels): Likewise.
	* printcmd.c (print_address, print_address_demangle)
	(address_info): Likewise.
	* corefile.c (memory_error): Likewise.
	* infcmd.c (jump_command): Likewise.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints)
	(mention, delete_breakpoint): Likewise.
	* c-valprint.c (print_function_pointer_address, c_val_print): Likewise.
	* dwarf2read.c (dump_die): Likewise.
	* ada-valprint.c (ada_val_print_1): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* linux-fork.c (info_forks_command): Likewise.
	* m32r-com.c (m32r_load_section, m32r_load)
	(m32r_upload_command): Likewise.

	* ui-out.c (ui_out_field_core_addr): Remove unnecessary comment.
@
text
@d3505 1
a3505 1
	  if (BITS_BIG_ENDIAN)
@


1.248
log
@        * dwarf2read.c (read_enumeration_type): Add comment.
@
text
@d8937 1
a8937 1
	  deprecated_print_address_numeric (DW_ADDR (&die->attrs[i]), 1, gdb_stderr);
@


1.247
log
@        * dwarf2read.c (read_enumeration_type): Flag type as stub if
        the given die is a declaration.
@
text
@d4236 5
@


1.246
log
@	Updated copyright notices for most files.
@
text
@d4236 3
@


1.245
log
@        * dwarf2read.c (read_base_type): Fix obvious &&/|| confusion.
@
text
@d4 1
a4 1
                 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.244
log
@        * dwarf2read.c (read_base_type): Set code to TYPE_CODE_CHAR
        for char and unsigned char types of Ada compilation units.
        * ada-lang.c (ada_is_character_type): Always return true if
        the type code is TYPE_CODE_CHAR.
@
text
@d5010 1
a5010 1
	if (cu->language == language_ada && cu->language == language_m2)
d5014 1
a5014 1
	if (cu->language == language_ada && cu->language == language_m2)
@


1.243
log
@	* dwarf2read.c (scan_partial_symbols partial_die_parent_scope)
	(add_partial_symbol, pdi_needs_namespace, process_die)
	(is_type_tag_for_partial, load_partial_dies, new_symbol)
	(read_type_die, determine_prefix): Extend the current code of
	`DW_TAG_class_type' also for `DW_TAG_interface_type'.
@
text
@d5010 1
a5010 1
	if (cu->language == language_m2)
d5014 1
a5014 1
	if (cu->language == language_m2)
@


1.242
log
@* dwarf2read.c (dwarf2_add_field): Correctly scale all byte
offsets obtained from DW_AT_data_member_location before recording
them in FIELD_BITPOS (*fp).

* dwarf2read.c (attr_form_is_section_offset): Doc fixes.
@
text
@d1750 1
d1833 1
d1981 1
d2063 1
d2683 1
d5411 1
d5617 1
d7368 1
d7688 1
d7793 1
@


1.241
log
@	* dwarf2read.c (dwarf_attr_name): Rename `DW_AT_stride_size' to its
	DWARF3 equivalent `DW_AT_bit_stride'.
	Rename `DW_AT_stride' to its DWARF3 equivalent `DW_AT_byte_stride'.
@
text
@d3481 2
d3486 1
a3486 1
              FIELD_BITPOS (*fp) = 0;
d3489 1
a3489 1
            FIELD_BITPOS (*fp) = dwarf2_get_attr_constant_value (attr, 0);
d3491 3
a3493 2
            FIELD_BITPOS (*fp) =
              decode_locdesc (DW_BLOCK (attr), cu) * bits_per_byte;
d9740 8
a9747 3
/* Return non-zero if ATTR's value is a section offset (classes
   lineptr, loclistptr, macptr or rangelistptr).  In this case,
   you may use DW_UNSND (attr) to retrieve the offset.  */
@


1.240
log
@* dwarf2read.c (attr_form_is_constant): New function.
(dwarf2_add_field): Use it and attr_form_is_section_offset to
recognize DW_AT_data_member_location attributes.  Use
dwarf2_get_attr_constant_value when the attribute is a constant.

* dwarf2read.c (attr_form_is_section_offset): New function.
(dwarf_add_member_fn, read_common_block, read_partial_die)
(dwarf2_symbol_mark_computed): Use it, instead of writing it out.
@
text
@d8156 2
a8157 2
    case DW_AT_stride_size:
      return "DW_AT_stride_size";
d8225 2
a8226 2
    case DW_AT_stride:
      return "DW_AT_stride";
@


1.239
log
@Support lexical blocks and function bodies that occupy
non-contiguous address ranges.
* addrmap.c, addrmap.h: New files.
* block.h (struct addrmap): New forward declaration.
(struct blockvector): New member, 'map'.
(BLOCKVECTOR_MAP): New accessor macro.
* block.c: #include "addrmap.h"
(blockvector_for_pc_sect): If the blockvector we've found has
an address map, use it instead of searching the blocks.
* buildsym.c: #include "addrmap.h"
(pending_addrmap_obstack, pending_addrmap_interesting): New static
variables.
(really_free_pendings): If we have a pending addrmap, free it too.
(record_block_range): New function.
(make_blockvector): If we have an interesting pending addrmap,
record it in the new blockvector.
(start_symtab, buildsym_init): Assert that there is no pending
addrmap now; we should have cleaned up any addrmaps we'd built
previously.
(end_symtab): If there is a pending addrmap left over that didn't
get included in the blockvector, free it.
* buildsym.h (struct addrmap): New forward declaration.
(record_block_range): New prototype.
* objfiles.c: #include "addrmap.h".
(objfile_relocate): Relocate the blockvector's address map, if
present.
* dwarf2read.c (dwarf2_record_block_ranges): New function.
(read_func_scope, read_lexical_block_scope): Call it.
* Makefile.in (SFILES): Add addrmap.c.
(addrmap_h): New header dependency variable.
(COMMON_OBS): Add addrmap.o.
(addrmap.o): New rule.l
(block.o, objfiles.o, buildsym.o): Depend on $(addrmap_h).

* block.c (blockvector_for_pc, blockvector_for_pc_sect): Return a
pointer to the block, not its index in the blockvector.
(block_for_pc_sect): Use the returned block, instead of looking it
up ourselves.
* block.h (blockvector_for_pc, blockvector_for_pc_sect): Update
declarations.
* breakpoint.c (resolve_sal_pc): Use returned block, instead of
looking it up ourselves.
* stack.c (print_frame_label_vars): Disable function, which
depends on the block's index.

* buildsym.c (finish_block): Return the block we've built.
* buildsym.h (finish_block): Update prototype.

* defs.h (CORE_ADDR_MAX): New constant.
@
text
@d1030 4
d3481 10
a3490 2
	  FIELD_BITPOS (*fp) =
	    decode_locdesc (DW_BLOCK (attr), cu) * bits_per_byte;
d3809 1
a3809 1
      else if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
d4525 1
a4525 1
      else if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
d5688 1
a5688 1
          else if (attr.form == DW_FORM_data4 || attr.form == DW_FORM_data8)
d9737 40
d9788 1
a9788 1
  if ((attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
@


1.238
log
@	* coffread.c (decode_type): Use builtin_type_int32 instead
	of FT_INTEGER fundamental type for array range index type.
	(decode_base_type): Use builtin types of current_gdbarch
	instead of fundamental types.

	* dwarf2read.c (struct dwarf2_cu): Remove ftypes member.
	(read_file_scope): Do not initialize ftypes member.
	(dwarf_base_type, dwarf2_fundamental_types): Remove functions.
	(read_array_type): Use builtin_type_int32 instead of FT_INTEGER
	fundamental type for array range index type.
	(read_tag_string_type): Likewise for string range index type.
	Also, do not overwrite FT_CHAR type with new string type.
	(read_base_type): If DW_AT_name is missing, create unnamed type
	with given properties instead of looking for a fundamental type.
	Create new types as TYPE_TARGET_TYPE for DW_ATE_address and
	DW_ATE_complex_float types.
	(read_subrange_type): Create new type to represent missing
	DW_AT_type instead of looking for a fundamental type.
	(die_type): Use builtin type to represent "void" instead of
	looking for a fundamental type.

	* stabsread.c (define_symbol): Use builtin types to represent
	'r' and 'i' floating-point and integer constants.

	* gdbtypes.c (lookup_fundamental_type): Remove.
	* gdbtypes.h (lookup_fundamental_type): Remove prototype.
	(FT_VOID, FT_BOOLEAN, FT_CHAR, FT_SIGNED_CHAR, FT_UNSIGNED_CHAR,
	FT_SHORT, FT_SIGNED_SHORT, FT_UNSIGNED_SHORT, FT_INTEGER,
	FT_SIGNED_INTEGER, FT_UNSIGNED_INTEGER, FT_LONG, FT_SIGNED_LONG,
	FT_UNSIGNED_LONG, FT_LONG_LONG, FT_SIGNED_LONG_LONG,
	FT_UNSIGNED_LONG_LONG, FT_FLOAT, FT_DBL_PREC_FLOAT, FT_EXT_PREC_FLOAT,
	FT_COMPLEX, FT_DBL_PREC_COMPLEX, FT_EXT_PREC_COMPLEX, FT_STRING,
	FT_FIXED_DECIMAL, FT_FLOAT_DECIMAL, FT_BYTE, FT_UNSIGNED_BYTE,
	FT_TEMPLATE_ARG, FT_DECFLOAT, FT_DBL_PREC_DECFLOAT,
	FT_EXT_PREC_DECFLOAT, FT_NUM_MEMBERS): Remove macros.
	* objfiles.c (struct objfile): Remove fundamental_types member.
	* symfile.c (reread_symbols): Do not clear fundamental_types.

	* language.h (struct language_defn): Remove la_fund_type member.
	(create_fundamental_type): Remove.
	* language.c (unk_lang_create_fundamental_type): Remove.
	(unknown_language_defn, auto_language_defn,
	local_language_defn): Adapt initializer.
	* ada-lang.c (ada_create_fundamental_type): Remove.
	(ada_language_defn): Adapt initializer.
	* c-lang.h (c_create_fundamental_type): Remove prototype.
	* c-lang.c (c_create_fundamental_type): Remove.
	(c_language_defn, cplus_language_defn, asm_language_defn,
	minimal_language_defn): Adapt initializer.
	* f-lang.c (f_create_fundamental_type): Remove.
	(f_language_defn): Adapt initializer.
	* jv-lang.c (java_create_fundamental_type): Remove.
	(java_language_defn): Adapt initializer.
	* m2-lang.c (m2_create_fundamental_type): Remove.
	(m2_language_defn): Adapt initializer.
	* objc-lang.c (objc_create_fundamental_type): Remove.
	(objc_language_defn): Adapt initializer.
	* p-lang.h (pascal_create_fundamental_type): Remove prototype.
	* p-lang.c (pascal_create_fundamental_type): Remove.
	(pascal_language_defn): Adapt initializer.
	* scm-lang.c (scm_language_defn): Adapt initializer.
@
text
@d898 3
d2916 1
d3000 5
a3004 2
  finish_block (new->name, &local_symbols, new->old_blocks,
		lowpc, highpc, objfile);
d3061 15
a3075 2
      finish_block (0, &local_symbols, new->old_blocks, new->start_addr,
		    highpc, objfile);
d3319 94
@


1.237
log
@gdb/
	* dwarf2read.c (dwarf2_get_pc_bounds): Moved the `DW_AT_ranges' parsing
	code with its variables OBJFILE, CU_HEADER and OBFD into ...
	(dwarf2_ranges_read): ... a new function.
	(read_partial_die): Implemented the parsing of `DW_AT_ranges'.

gdb/testsuite/
	* gdb.dwarf2/dw2-ranges.S, gdb.dwarf2/dw2-ranges.exp: New files.
@
text
@a290 11
  /* Maintain an array of referenced fundamental types for the current
     compilation unit being read.  For DWARF version 1, we have to construct
     the fundamental types on the fly, since no information about the
     fundamental types is supplied.  Each such fundamental type is created by
     calling a language dependent routine to create the type, and then a
     pointer to that type is then placed in the array at the index specified
     by it's FT_<TYPENAME> value.  The array has a fixed size set by the
     FT_NUM_MEMBERS compile time constant, which is the number of predefined
     fundamental types gdb knows how to construct.  */
  struct type *ftypes[FT_NUM_MEMBERS];	/* Fundamental types */

a927 2
static struct type *dwarf_base_type (int, int, struct dwarf2_cu *);

a1008 3
static struct type *dwarf2_fundamental_type (struct objfile *, int,
					     struct dwarf2_cu *);

a2830 4
  /* The compilation unit may be in a different language or objfile,
     zero out all remembered fundamental types.  */
  memset (cu->ftypes, 0, FT_NUM_MEMBERS * sizeof (struct type *));

d4267 1
a4267 1
      index_type = dwarf2_fundamental_type (objfile, FT_INTEGER, cu);
d4702 2
a4703 1
  index_type = dwarf2_fundamental_type (objfile, FT_INTEGER, cu);
d4705 2
a4706 11
  if (cu->language == language_fortran)
    {
      /* Need to create a unique string type for bounds
         information */
      type = create_string_type (0, range_type);
    }
  else
    {
      char_type = dwarf2_fundamental_type (objfile, FT_CHAR, cu);
      type = create_string_type (char_type, range_type);
    }
d4821 3
d4842 1
a4842 1
  if (name)
d4844 3
a4846 2
      enum type_code code = TYPE_CODE_INT;
      int type_flags = 0;
d4848 1
a4848 57
      switch (encoding)
	{
	case DW_ATE_address:
	  /* Turn DW_ATE_address into a void * pointer.  */
	  code = TYPE_CODE_PTR;
	  type_flags |= TYPE_FLAG_UNSIGNED;
	  break;
	case DW_ATE_boolean:
	  code = TYPE_CODE_BOOL;
	  type_flags |= TYPE_FLAG_UNSIGNED;
	  break;
	case DW_ATE_complex_float:
	  code = TYPE_CODE_COMPLEX;
	  break;
	case DW_ATE_decimal_float:
	  code = TYPE_CODE_DECFLOAT;
	  break;
	case DW_ATE_float:
	  code = TYPE_CODE_FLT;
	  break;
	case DW_ATE_signed:
	  break;
	case DW_ATE_unsigned:
	  type_flags |= TYPE_FLAG_UNSIGNED;
	  break;
	case DW_ATE_signed_char:
	  if (cu->language == language_m2)
	    code = TYPE_CODE_CHAR;
	  break;
 	case DW_ATE_unsigned_char:
	  if (cu->language == language_m2)
	    code = TYPE_CODE_CHAR;
	  type_flags |= TYPE_FLAG_UNSIGNED;
	  break;
	default:
	  complaint (&symfile_complaints, _("unsupported DW_AT_encoding: '%s'"),
		     dwarf_type_encoding_name (encoding));
	  break;
	}
      type = init_type (code, size, type_flags, name, objfile);
      if (encoding == DW_ATE_address)
	TYPE_TARGET_TYPE (type) = dwarf2_fundamental_type (objfile, FT_VOID,
							   cu);
      else if (encoding == DW_ATE_complex_float)
	{
	  if (size == 32)
	    TYPE_TARGET_TYPE (type)
	      = dwarf2_fundamental_type (objfile, FT_EXT_PREC_FLOAT, cu);
	  else if (size == 16)
	    TYPE_TARGET_TYPE (type)
	      = dwarf2_fundamental_type (objfile, FT_DBL_PREC_FLOAT, cu);
	  else if (size == 8)
	    TYPE_TARGET_TYPE (type)
	      = dwarf2_fundamental_type (objfile, FT_FLOAT, cu);
	}
    }
  else
d4850 38
a4887 1
      type = dwarf_base_type (encoding, size, cu);
d4889 4
d4918 2
a4919 2
	= dwarf_base_type (DW_ATE_signed,
			   gdbarch_addr_bit (current_gdbarch) / 8, cu);
d7479 1
a7479 1
      return dwarf2_fundamental_type (cu->objfile, FT_VOID, cu);
a7723 86
static struct type *
dwarf_base_type (int encoding, int size, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;

  /* FIXME - this should not produce a new (struct type *)
     every time.  It should cache base types.  */
  struct type *type;
  switch (encoding)
    {
    case DW_ATE_address:
      type = dwarf2_fundamental_type (objfile, FT_VOID, cu);
      return type;
    case DW_ATE_boolean:
      type = dwarf2_fundamental_type (objfile, FT_BOOLEAN, cu);
      return type;
    case DW_ATE_complex_float:
      if (size == 16)
	{
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_COMPLEX, cu);
	}
      else
	{
	  type = dwarf2_fundamental_type (objfile, FT_COMPLEX, cu);
	}
      return type;
    case DW_ATE_float:
      if (size == 8)
	{
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_FLOAT, cu);
	}
      else
	{
	  type = dwarf2_fundamental_type (objfile, FT_FLOAT, cu);
	}
      return type;
    case DW_ATE_decimal_float:
      if (size == 16)
	type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_DECFLOAT, cu);
      else if (size == 8)
	type = dwarf2_fundamental_type (objfile, FT_EXT_PREC_DECFLOAT, cu);
      else
	type = dwarf2_fundamental_type (objfile, FT_DECFLOAT, cu);
      return type;
    case DW_ATE_signed:
      switch (size)
	{
	case 1:
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR, cu);
	  break;
	case 2:
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_SHORT, cu);
	  break;
	default:
	case 4:
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER, cu);
	  break;
	}
      return type;
    case DW_ATE_signed_char:
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR, cu);
      return type;
    case DW_ATE_unsigned:
      switch (size)
	{
	case 1:
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR, cu);
	  break;
	case 2:
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_SHORT, cu);
	  break;
	default:
	case 4:
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_INTEGER, cu);
	  break;
	}
      return type;
    case DW_ATE_unsigned_char:
      type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR, cu);
      return type;
    default:
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER, cu);
      return type;
    }
}

a8946 22
static struct type *
dwarf2_fundamental_type (struct objfile *objfile, int typeid,
			 struct dwarf2_cu *cu)
{
  if (typeid < 0 || typeid >= FT_NUM_MEMBERS)
    {
      error (_("Dwarf Error: internal error - invalid fundamental type id %d [in module %s]"),
	     typeid, objfile->name);
    }

  /* Look for this particular type in the fundamental type vector.  If
     one is not found, create and install one appropriate for the
     current language and the current target machine. */

  if (cu->ftypes[typeid] == NULL)
    {
      cu->ftypes[typeid] = cu->language_defn->la_fund_type (objfile, typeid);
    }

  return (cu->ftypes[typeid]);
}

@


1.236
log
@	* dwarf2read.c (read_partial_die): check the value
	of DW_AT_calling_convention in Fortran programs.
@
text
@d3080 118
a3204 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
a3205 1
  bfd *obfd = objfile->obfd;
a3228 2
	  unsigned int addr_size = cu_header->addr_size;
	  CORE_ADDR mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));
d3231 1
a3231 96
	  unsigned int offset = DW_UNSND (attr);
	  /* Base address selection entry.  */
	  CORE_ADDR base;
	  int found_base;
	  unsigned int dummy;
	  gdb_byte *buffer;
	  CORE_ADDR marker;
	  int low_set;
 
	  found_base = cu_header->base_known;
	  base = cu_header->base_address;

	  if (offset >= dwarf2_per_objfile->ranges_size)
	    {
	      complaint (&symfile_complaints,
	                 _("Offset %d out of bounds for DW_AT_ranges attribute"),
			 offset);
	      return 0;
	    }
	  buffer = dwarf2_per_objfile->ranges_buffer + offset;

	  /* Read in the largest possible address.  */
	  marker = read_address (obfd, buffer, cu, &dummy);
	  if ((marker & mask) == mask)
	    {
	      /* If we found the largest possible address, then
		 read the base address.  */
	      base = read_address (obfd, buffer + addr_size, cu, &dummy);
	      buffer += 2 * addr_size;
	      offset += 2 * addr_size;
	      found_base = 1;
	    }

	  low_set = 0;

	  while (1)
	    {
	      CORE_ADDR range_beginning, range_end;

	      range_beginning = read_address (obfd, buffer, cu, &dummy);
	      buffer += addr_size;
	      range_end = read_address (obfd, buffer, cu, &dummy);
	      buffer += addr_size;
	      offset += 2 * addr_size;

	      /* An end of list marker is a pair of zero addresses.  */
	      if (range_beginning == 0 && range_end == 0)
		/* Found the end of list entry.  */
		break;

	      /* Each base address selection entry is a pair of 2 values.
		 The first is the largest possible address, the second is
		 the base address.  Check for a base address here.  */
	      if ((range_beginning & mask) == mask)
		{
		  /* If we found the largest possible address, then
		     read the base address.  */
		  base = read_address (obfd, buffer + addr_size, cu, &dummy);
		  found_base = 1;
		  continue;
		}

	      if (!found_base)
		{
		  /* We have no valid base address for the ranges
		     data.  */
		  complaint (&symfile_complaints,
			     _("Invalid .debug_ranges data (no base address)"));
		  return 0;
		}

	      range_beginning += base;
	      range_end += base;

	      /* FIXME: This is recording everything as a low-high
		 segment of consecutive addresses.  We should have a
		 data structure for discontiguous block ranges
		 instead.  */
	      if (! low_set)
		{
		  low = range_beginning;
		  high = range_end;
		  low_set = 1;
		}
	      else
		{
		  if (range_beginning < low)
		    low = range_beginning;
		  if (range_end > high)
		    high = range_end;
		}
	    }

	  if (! low_set)
	    /* If the first entry is an end-of-list marker, the range
	       describes an empty scope, i.e. no instructions.  */
d3233 1
a3233 1

d5590 5
@


1.235
log
@2007-10-25  Wu Zhou  <woodzltc@@cn.ibm.com>
	    Thiago Jung Bauermann  <bauerman@@br.ibm.com>

	* c-lang.c (c_create_fundamental_type): Create fundamental
	types for DFP.
	* c-typeprint.c (c_type_print_varspec_prefix): Add
	TYPE_CODE_DECFLOAT to no prefix needed case.
	(c_type_print_varspec_suffix): Add TYPE_CODE_DECFLOAT to no
	suffix needed case.
	* c-valprint.c (c_val_print): Call print_decimal_floating to
	print DFP values.
	* dwarf2read.c (read_base_type): Read DW_ATE_decimal_float
	attribute code and return TYPE_CODE_DECFLOAT.
	(dwarf_base_type): Set dwarf2_fundamental_type for DFP values.
	* gdbtypes.c (gdbtypes_post_init): Initialize builtin_decfloat,
	builtin_decdouble and builtin_declong.
	* gdbtypes.h (enum type_code): Add TYPE_CODE_DECFLOAT as a
	type code for DFP.
	(FT_DECFLOAT, FT_DBL_PREC_DECFLOAT, FT_EXT_PREC_DECFLOAT): New
	types, for decimal floating point.
	(FT_NUM_MEMBERS):  Increment, new types added.
	(struct builtin_type): Add builtin_decfloat, builtin_decdouble
	and builtin_declong.
	* valprint.c (print_decimal_floating): New function to print DFP
	values.
	* value.h (print_decimal_floating): Prototype.
@
text
@d5622 19
@


1.234
log
@	* dwarf2read.c (read_file_scope): Add a comment.
	(dwarf2_add_field, dwarf2_add_member_fn, read_structure_type)
	(read_enumeration_type, process_enumeration_scope, read_array_type)
	(read_typedef, read_base_type, read_subrange_type)
	(read_unspecified_type): Use dwarf2_name.
@
text
@d4868 3
d7757 8
@


1.233
log
@	* coffread.c (coff_symfile_finish): Call dwarf2_free_objfile.
	* dwarf2read.c (dwarf2_free_objfile): New.
	* elfread.c (elf_symfile_finish): Call dwarf2_free_objfile.
	* symfile.h (dwarf2_free_objfile): Declare.
@
text
@d2804 2
d3415 3
a3417 3
      attr = dwarf2_attr (die, DW_AT_name, cu);
      if (attr && DW_STRING (attr))
	fieldname = DW_STRING (attr);
d3443 2
a3444 4
      attr = dwarf2_attr (die, DW_AT_name, cu);
      if (attr && DW_STRING (attr))
	fieldname = DW_STRING (attr);
      else
d3574 2
a3575 4
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
    fieldname = DW_STRING (attr);
  else
d3840 1
d3850 2
a3851 2
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
d3867 1
a3867 1
	  TYPE_TAG_NAME (type) = DW_STRING (attr);
d4069 1
d4077 2
a4078 2
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
a4079 2
      char *name = DW_STRING (attr);

a4177 1
  struct attribute *attr;
d4181 1
d4196 2
a4197 2
	      attr = dwarf2_attr (child_die, DW_AT_name, cu);
	      if (attr)
d4255 1
d4329 3
a4331 3
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
    TYPE_NAME (type) = DW_STRING (attr);
d4812 1
a4812 5
      attr = dwarf2_attr (die, DW_AT_name, cu);
      if (attr && DW_STRING (attr))
	{
	  name = DW_STRING (attr);
	}
d4830 1
d4848 2
a4849 2
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
d4890 1
a4890 1
      type = init_type (code, size, type_flags, DW_STRING (attr), objfile);
d4924 1
d4977 3
a4979 3
  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
    TYPE_NAME (range_type) = DW_STRING (attr);
a4991 1
  struct attribute *attr;
d4998 1
a4998 2
  attr = dwarf2_attr (die, DW_AT_name, cu);
  type = init_type (TYPE_CODE_VOID, 0, 0, attr ? DW_STRING (attr) : "",
@


1.232
log
@2007-09-26  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* Fix PR pascal/2231
	dwarf2read.c (read_subroutine_type):
	All pascal functions are prototyped.
@
text
@d9967 16
@


1.231
log
@	* NEWS: Update description of string changes.  Mention print/s.
	* c-valprint.c (textual_element_type): New.
	(c_val_print): Use it.  Do not skip address printing for pointers
	with a string format.
	(c_value_print): Doc update.
	* dwarf2read.c (read_array_type): Use make_vector_type.
	* gdbtypes.c (make_vector_type): New.
	(init_vector_type): Use it.
	(gdbtypes_post_init): Initialize builtin_true_unsigned_char.
	(_initialize_gdbtypes): Mark int8_t and uint8_t as TYPE_FLAG_NOTTEXT.
	* gdbtypes.h (struct builtin_type): Add builtin_true_unsigned_char.
	(TYPE_FLAG_NOTTEXT, TYPE_NOTTEXT): New.
	(make_vector_type): New.
	* printcmd.c (print_formatted): Only handle 's' and 'i' for examine.
	Call the language print routine for string format.
	(print_scalar_formatted): Call val_print for string format.  Handle
	unsigned original types for char format.
	(validate_format): Do not reject string format.
	* stabsread.c (read_type): Use make_vector_type.
	* xml-tdesc.c (tdesc_start_vector): Use init_vector_type.

	* gdb.texinfo (Output Formats): Update 'c' description.  Describe 's'.
	(Examining Memory): Update mentions of the 's' format.
	(Automatic Display): Likewise.

	* gdb.arch/i386-sse.exp: Do not expect character constants.
	* gdb.base/charsign.c, gdb.base/charsign.exp: Delete.
	* gdb.base/display.exp: Allow print/s.
	* gdb.base/printcmds.exp, gdb.base/setvar.exp: Revert signed
	and unsigned char array changes.
@
text
@d4747 1
a4747 1
  /* All functions in C++ and Java have prototypes.  */
d4751 2
a4752 1
      || cu->language == language_java)
@


1.230
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d4328 1
a4328 1
    TYPE_FLAGS (type) |= TYPE_FLAG_VECTOR;
@


1.229
log
@2007-08-08  Michael Snyder  <msnyder@@access-company.com>

	* dwarf2read.c (add_partial_symbol): Memory leak.
@
text
@d17 2
a18 2
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.
d20 4
a23 4
   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
d26 1
a26 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.228
log
@	* dwarf2read.c (dwarf_decode_lines): Detect address size mismatches.
@
text
@d1889 1
a1889 1
  char *actual_name;
a1896 2
  actual_name = NULL;

d1960 5
a1964 1
	    return;
d1999 5
a2003 1
        return;
@


1.227
log
@	* gdbtypes.h (struct builtin_type): New members nodebug_text_symbol,
	nodebug_data_symbol, nodebug_unknown_symbol, and nodebug_tls_symbol.
	* gdbtypes.c (gdbtypes_post_init): Initialize nodebug_ default types.

	* parse.c (msym_text_symbol_type, msym_data_symbol_type): Remove.
	(msym_unknown_symbol_type, msym_tls_symbol_type): Remove.
	(write_exp_msymbol): Use builtin nodebug_ types instead of them.
	(build_parse): Remove.
	(_initialize_parse): Do not call build_parse.  Do not register
	msym_ types for gdbarch-swapping.

	* dwarf2read.c (new_symbol): Use default nodebug_data_symbol type
	instead of creating private type.

	* xcoffread.c (func_symbol_type, var_symbol_type): Remove.
	(_initialize_xcoffread): Do not initialized them.
	(process_xcoff_symbol): Use builtin nodebug_ types instead of them.

	* mdebugread.c (nodebug_func_symbol_type): Remove.
	(nodebug_var_symbol_type): Remove.
	(_initialize_mdebugread): Do not initialize them.
	(parse_symbol): Use builtin nodebug_ type instead of them.
	(parse_procedure): Likewise.
@
text
@d6671 1
a6671 1
  gdb_byte *line_ptr;
d6673 1
a6673 1
  unsigned int bytes_read;
d6748 1
a6748 1
	      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
d6750 1
d6796 9
@


1.226
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d7153 3
a7155 5
	    SYMBOL_TYPE (sym) = init_type (TYPE_CODE_INT,
					   gdbarch_int_bit (current_gdbarch)
					     / HOST_CHAR_BIT,
					   0, "<variable, no debug info>",
					   objfile);
@


1.225
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (STAB_REG_TO_REGNUM): Replace by
	gdbarch_stab_reg_to_regnum.
	* stabsread.c (define_symbol): Likewise.
	* gdbarch.sh (ECOFF_REG_TO_REGNUM): Replace by
	gdbarch_ecoff_reg_to_regnum.
	* mdebugread.c (parse_symbol): Likewise.
	* i386-tdep.c (i386_gdbarch_init): Likewise (comment).
	* gdbarch.sh (DWARF_REG_TO_REGNUM): Replace by
	gdbarch_dwarf_reg_to_regnum.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Replace by gdbarch_sdb_reg_to_regnum.
	* coffread.c (process_coff_symbol): Likewise.
	* gdbarch.sh (DWARF2_REG_TO_REGNUM): Replace by
	gdbarch_dwarf2_reg_to_regnum.
	* dwarf2loc.c (dwarf_expr_read_reg,dwarf2_evaluate_loc_desc)
	(locexpr_describe_location): Likewise.
	* dwarf2-frame.c (read_reg,execute_cfa_program,dwarf2_frame_cache)
	(dwarf2_frame_prev_register,dwarf2_signal_frame_this_id): Likewise.
	* dwarf2loc.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* dwarf2read.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d4933 3
a4935 1
      base_type = dwarf_base_type (DW_ATE_signed, TARGET_ADDR_BIT / 8, cu);
@


1.224
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a69 4
#ifndef DWARF2_REG_TO_REGNUM
#define DWARF2_REG_TO_REGNUM(REG) (REG)
#endif

@


1.223
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (ADDRESS_CLASS_TYPE_FLAGS): Replace by
	gdbarch_address_class_type_flags.
	* dwarf2read.c (read_tag_pointer_type): Likewise.
	* gdbarch.sh (ADDRESS_CLASS_TYPE_FLAGS_P): Replace by
	gdbarch_address_class_type_flags_p.
	* dwarf2read.c (read_tag_pointer_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d7156 3
a7158 2
					   TARGET_INT_BIT / HOST_CHAR_BIT, 0,
					   "<variable, no debug info>",
@


1.222
log
@	* dwarf2read.c (dwarf2_symbol_mark_computed): Fix formatting.
	Use the original objfile if necessary.
@
text
@d4562 1
a4562 1
      if (ADDRESS_CLASS_TYPE_FLAGS_P ())
d4566 2
a4567 1
	  type_flags = ADDRESS_CLASS_TYPE_FLAGS (byte_size, addr_class);
@


1.221
log
@	* defs.h (ldirname): New prototype.
	* dwarf2read.c (read_file_scope): Use DW_AT_name if DW_AT_comp_dir is
	missing.
	* utils.c (ldirname): New function.
	* xml-tdesc.c (file_read_description_xml): Use ldirname.
@
text
@d1049 3
a1051 3
static void
dwarf2_symbol_mark_computed (struct attribute *attr, struct symbol *sym,
			     struct dwarf2_cu *cu);
d9701 7
d9718 1
a9718 1
      baton->objfile = cu->objfile;
d9738 1
a9738 1
      baton->objfile = cu->objfile;
@


1.220
log
@Add ability to report when a variable's value is uninitialized,
based on information provided by the compiler.  Also add new
DWARF OP, DW_OP_GNU_uninit, for this purpose.
@
text
@d2786 1
a2786 1
  char *name = "<unknown>";
d2809 1
d2812 8
d2821 3
a2823 6
      comp_dir = DW_STRING (attr);
      if (comp_dir)
	{
	  /* Irix 6.2 native cc prepends <machine>.: to the compilation
	     directory, get rid of it.  */
	  char *cp = strchr (comp_dir, ':');
d2825 2
a2826 3
	  if (cp && cp != comp_dir && cp[-1] == '.' && cp[1] == '/')
	    comp_dir = cp + 1;
	}
d2829 3
@


1.219
log
@	* dwarf2read.c (dwarf2_debug_line_missing_file_complaint): New
	function.
	(dwarf_decode_lines): Check for line info without a file.
@
text
@d8659 2
d9236 3
@


1.218
log
@2007-04-18  Denis Pilat  <denis.pilat@@st.com>

	* dwarf2read.c (read_subrange_type): Use DW_ATE_signed default type
	when missing from DW_TAG_subrange_type.  Remove the handling of null
	return from die_type.
@
text
@d691 7
d6718 16
a6733 8
              lh->file_names[file - 1].included_p = 1;
              if (!decode_for_pst_p)
                {
		  if (last_subfile != current_subfile)
		    {
		      if (last_subfile)
			record_line (last_subfile, 0, address);
		      last_subfile = current_subfile;
d6735 1
a6735 4
	          /* Append row to matrix using current values.  */
	          record_line (current_subfile, line, 
	                       check_cu_functions (address, cu));
                }
d6749 9
a6757 3
                  lh->file_names[file - 1].included_p = 1;
                  if (!decode_for_pst_p)
		    record_line (current_subfile, 0, address);
d6790 3
a6792 2
              lh->file_names[file - 1].included_p = 1;
              if (!decode_for_pst_p)
d6794 12
a6805 8
		  if (last_subfile != current_subfile)
		    {
		      if (last_subfile)
			record_line (last_subfile, 0, address);
		      last_subfile = current_subfile;
		    }
		  record_line (current_subfile, line, 
			       check_cu_functions (address, cu));
d6828 13
a6840 9
                fe = &lh->file_names[file - 1];
                if (fe->dir_index)
                  dir = lh->include_dirs[fe->dir_index - 1];

                if (!decode_for_pst_p)
		  {
		    last_subfile = current_subfile;
		    dwarf2_start_subfile (fe->name, dir, comp_dir);
		  }
@


1.217
log
@* gdbtypes.h (TYPE_FLAG_STUB_SUPPORTED, TYPE_STUB_SUPPORTED): New
macros.
(TYPE_IS_OPAQUE): Empty vs. opaque structures are now
distinct on the TYPE_STUB_SUPPORTED debug targets.
* dwarf2read.c (read_structure_type): Set TYPE_FLAG_STUB_SUPPORTED.
@
text
@d4917 1
a4917 1
  if (base_type == NULL)
d4921 1
a4921 1
      return;
a4923 3
  if (TYPE_CODE (base_type) == TYPE_CODE_VOID)
    base_type = alloc_type (NULL);

@


1.216
log
@	* MAINTAINERS: Remove d10v entry.
	* Makefile.in (SFILES): Remove dwarfread.c.
	(COMMON_OBS): Remove dwarfread.o.
	(gdb_sim_d10v_h, abug-rom.o, cpu32bug-rom.o, d10v-tdep.o, dwarfread.o)
	(remote-est.o, rom68k-rom.o): Delete.
	* NEWS: Mention removal of d10v, target abug, target cpu32bug,
	target est, target rom68k, and DWARF 1.
	* configure.tgt: Mark d10v as removed.
	* dwarf2read.c: Doc update.
	* elfread.c (struct elfinfo): Remove dboffset, dbsize, lnoffset,
	and lnsize.
	(elf_locate_sections): Do not set them.
	(elf_symfile_read): Do not call dwarf_build_psymtabs.
	* symfile.h (dwarf_build_psymtabs): Delete prototype.
	* config/m68k/monitor.mt (TDEPFILES): Prune.
	* abug-rom.c, cpu32bug-rom.c, d10v-tdep.c, dwarfread.c,
	remote-est.c, rom68k-rom.c, config/d10v/d10v.mt: Delete.

	* gdb.texinfo (M68K): Remove obsolete ROM monitors.
	* gdbint.texinfo (DWARF 1): Delete section and other dwarfread.c
	references.

	* gdb.asm/asm-source.exp: Remove d10v case.
	* lib/gdb.exp (skip_cplus_tests): Likewise.
	* gdb.asm/d10v.inc: Deleted.
@
text
@d3882 1
@


1.215
log
@ * Fix PR 2223. Recognize Pascal language marker in dwarf readers
@
text
@d11 1
a11 1
   support in dwarfread.c
@


1.214
log
@        * dwarf2read.c (new_symbol): Handle DW_AT_decl_file being zero.
@
text
@d6328 3
a6332 1
    case DW_LANG_Pascal83:
@


1.213
log
@        * dwarf2read.c (add_partial_symbol): Create an extra partial
        symbol in the VAR_DOMAIN for Ada structures, unions or enums.
        (new_symbol): Likewise for symbols.
@
text
@d7082 1
a7082 1
	  else
@


1.212
log
@2007-01-21  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* buildsym.c (end_symtab): Use preallocated symtab if available.
	Fill in SYMBOL_SYMTAB.
	* buildsym.h (struct subfile): Add symtab member.
	* dwarf2read.c (struct dwarf2_cu): Add line_header.
	(struct file_entry): Add symtab.
	(free_cu_line_header): New function.
	(read_file_scope): Use it.  Save line_header in the cu.  Process
	lines before DIEs.
	(add_file_name): Initialize new symtab member.
	(dwarf_decode_lines): Create symtabs for included files.
	(new_symbol): Set SYMBOL_SYMTAB.
	* symtab.c (lookup_symbol): Use SYMBOL_SYMTAB.
	(search_symbols): Likewise.
	* symtab.h (struct symbol): Add symtab member.
	(SYMBOL_SYMTAB): Define.

	* gdb.base/included.c, gdb.base/included.exp,
	gdb.base/included.h: New files.
@
text
@d2007 2
a2008 1
          || cu->language == language_java)
d7235 2
a7236 1
		|| cu->language == language_java)
@


1.211
log
@Copyright updates for 2007.
@
text
@d344 3
d438 1
d2761 9
d2839 16
a2865 14
  /* Decode line number information if present.  */
  attr = dwarf2_attr (die, DW_AT_stmt_list, cu);
  if (attr)
    {
      unsigned int line_offset = DW_UNSND (attr);
      line_header = dwarf_decode_line_header (line_offset, abfd, cu);
      if (line_header)
        {
          make_cleanup ((make_cleanup_ftype *) free_line_header,
                        (void *) line_header);
          dwarf_decode_lines (line_header, comp_dir, abfd, cu, NULL);
        }
    }

d6475 1
d6663 1
a6663 1
  struct subfile *last_subfile = NULL;
d6888 29
d7072 17
@


1.210
log
@        * dwarf2read.c (partial_die_info): Add field has_byte_size.
        (add_partial_symbol): Correct identification of external references.
        (process_structure_scope): Likewise.
        (read_partial_die): Handle DW_AT_byte_size attribute.
@
text
@d3 2
a4 3
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
                 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
@


1.209
log
@	* buildsym.c (start_subfile): Handle producer.
	(record_producer): New function.
	* buildsym.h (struct subfile): Include producer.
	(record_producer): New prototype.
	* dwarf2-frame.c (struct dwarf2_cie): Add version and augmentation.
	(struct dwarf2_frame_state): Add armcc_cfa_offsets_sf and
	armcc_cfa_offsets_reversed.
	(execute_cfa_program): Handle armcc_cfa_offsets_sf.
	(dwarf2_frame_find_quirks): New function.
	(dwarf2_frame_cache): Call it.  Handle armcc_cfa_offsets_reversed.
	(decode_frame_entry_1): Record the CIE version.  Record the
	augmentation.  Skip armcc augmentations.
	* dwarf2read.c (read_file_scope): Save the producer.
	* symtab.h (struct symtab): Rename unused version member to
	producer.
@
text
@d4 1
a4 1
                 2002, 2003, 2004, 2005, 2006
d470 3
d1985 8
a1992 2
      /* Skip aggregate types without children, these are external
         references.  */
a1994 2
      if (pdi->has_children == 0)
	return;
d4020 5
a4024 1
  if (die->child != NULL && ! die_is_declaration (die, cu))
d5589 3
@


1.208
log
@	* NEWS: Mention pointer to member improvements.
	* Makefile.in (gnu-v3-abi.o): Delete special rule.
	(eval.o, gnu-v3-abi.o, ia64-tdep.o): Update.
	* ada-valprint.c (ada_print_scalar): Update for new type codes.
	* c-typeprint.c (c_print_type): Update for new type codes.
	(c_type_print_varspec_prefix, c_type_print_varspec_suffix)
	(c_type_print_base): Likewise.
	(c_type_print_args): Rewrite.
	* c-valprint.c (c_val_print): Update for new type codes.  Remove
	support for references to members.  Treat methods like functions.
	* cp-abi.c (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New.
	* cp-abi.h (cplus_print_method_ptr, cplus_method_ptr_size)
	(cplus_make_method_ptr, cplus_method_ptr_to_value): New prototypes.
	(struct cp_abi_ops): Add corresponding members.
	* cp-valprint.c (cp_print_class_method): Delete.
	(cp_find_class_member): New function.
	(cp_print_class_member): Use it.  Simplify support for bogus
	member pointers.
	* dwarf2read.c (quirk_gcc_member_function_pointer): Use
	lookup_methodptr_type.
	(read_tag_ptr_to_member_type): Likewise, and lookup_memberptr_type.
	* eval.c (evaluate_subexp_standard): Implement EVAL_SKIP for
	OP_SCOPE.  Update call to value_aggregate_elt.  Rewrite member
	pointer support.
	(evaluate_subexp_for_address): Handle OP_SCOPE explicitly.  Handle
	references returned by user defined operators.
	* f-typeprint.c (f_print_type, f_type_print_varspec_prefix)
	(f_type_print_varspec_suffix): Remove support for member pointers.
	* gdbtypes.c (lookup_memberptr_type): Renamed from lookup_member_type
	and adjusted.
	(smash_to_memberptr_type): Likewise, from smash_to_member_type.
	(lookup_methodptr_type): New.
	(rank_one_type): Adjust for TYPE_CODE_MEMBERPTR.
	(recursive_dump_type): Update for new types.
	* gdbtypes.h (enum type_code): Replace TYPE_CODE_MEMBER with
	TYPE_CODE_MEMBERPTR and TYPE_CODE_METHODPTR.
	(lookup_memberptr_type, lookup_methodptr_type)
	(smash_to_memberptr_type): New prototypes.
	(smash_to_method_type): Formatting fix.
	(lookup_member_type, smash_to_member_type): Delete prototypes.
	* gnu-v3-abi.c (gnuv3_get_vtable, gnuv3_get_virtual_fn): New.
	Do not rely on debug information for the vptr or the method's
	enclosing type.  Handle function descriptors for IA64.
	(gnuv3_virtual_fn_field): Rewrite using the new functions.
	(gnuv3_find_method_in, gnuv3_print_method_ptr)
	(gnuv3_method_ptr_size, gnuv3_make_method_ptr)
	(gnuv3_method_ptr_to_value): New.
	(init_gnuv3_ops): Set new members of gnu_v3_abi_ops.
	* hpread.c (hpread_type_lookup): Update for new types.
	* infcall.c (value_arg_coerce): Likewise.
	* m2-typeprint.c (m2_print_type): Remove explicit support
	for member pointers.
	* m2-valprint.c (m2_val_print): Likewise.
	* p-typeprint.c (pascal_type_print_varspec_prefix)
	(pascal_type_print_varspec_suffix, pascal_type_print_base): Likewise.
	* p-valprint.c (pascal_val_print): Likewise.
	(pascal_object_print_class_method, pascal_object_print_class_member):
	Delete.
	* p-lang.h (pascal_object_print_class_method)
	(pascal_object_print_class_member): Delete prototypes.
	* stabsread.c (read_type): Update for new types.
	* typeprint.c (print_type_scalar): Likewise.
	* valops.c (value_struct_elt_for_reference, value_namespace_elt)
	(value_maybe_namespace_elt, value_aggregate_elt): Add want_address
	argument.  Construct a pointer to member if the address of a
	function or data member is requested.
	(value_cast_pointers): Don't modify the input value.
	(value_cast): Adjust pointer to member handling for new types.
	Allow null pointer to member constants.  Don't modify the input
	value.
	(value_ind): Remove pointer to member check.  Handle function
	descriptors for function pointers.
	(value_struct_elt, value_find_oload_method_list, check_field):
	Remove pointer to member checks.
	* value.c (unpack_long): Allow pointers to data members.
	(value_from_longest): Allow member pointers.
	* value.h (value_aggregate_elt): Add want_address.
	* varobj.c (c_variable_editable): Remove check for members.
	* gdbarch.sh: Add vtable_function_descriptors and vbit_in_delta.
	* ia64-tdep.c (ia64_convert_from_func_ptr_addr): Handle descriptors
	in virtual tables.
	(ia64_gdbarch_init): Call set_gdbarch_vtable_function_descriptors.
	* c-lang.h (cp_print_class_method): Delete prototype.
	* arm-tdep.c (arm_gdbarch_init): Call set_gdbarch_vbit_in_delta.
	* mips-tdep.c (mips_gdbarch_init): Likewise.
	* gdbarch.c, gdbarch.h: Regenerated.

	* gdb.cp/classes.exp (test_pointers_to_class_members): Update expected
	output.  Test the types of members and member pointers.
	* gdb.cp/inherit.exp (test_print_mi_member_types): Remove KFAILs for
	gdb/2092.
	* gdb.cp/member-ptr.exp: Search for a comment instead of a
	statement.  Enable for GCC.  Update expected output for some tests
	and add new tests.  Remove obsolete GCC KFAILs.  Allow GCC's class
	layout.
	* gdb.cp/member-ptr.cc (Padding, Padding::vspacer, Base, Base::get_x)
	(Base::vget_base, Left, Left::vget, Right, Right::vget, Diamond)
	(Diamond::vget_base): New.
	(main): Add new tests.
	* gdb.cp/printmethod.exp: Update expected output for member functions.
	* gdb.cp/virtfunc.exp (test_virtual_calls): Add a KFAIL for
	print pEe->D::vg().
@
text
@d2806 1
a2806 1
  
a2808 7
#if 0
  /* FIXME:Do something here.  */
  if (dip->at_producer != NULL)
    {
      handle_producer (dip->at_producer);
    }
#endif
d2816 1
@


1.207
log
@2006-12-27  Gary Funck  <gary@@intrepid.com>

	* dwarf2read.c (dwarf_attr_name, dwarf_cfi_name)
	(dwarf_stack_op_name, dwarf_tag_name)
	(dwarf_type_encoding_name): Decode additional DWARF 2
	and DWARF 3 codes into their corresponding string names.
@
text
@a3701 1

d3781 1
a3781 1
  type = lookup_pointer_type (type);
a4562 1
  type = alloc_type (objfile);
d4565 5
a4569 1
  smash_to_member_type (type, domain, to_type);
@


1.206
log
@	* dwarf2read.c (struct dwarf2_per_cu_data): Update comment.
	(load_full_comp_unit): Take OBJFILE argument and use it.
	(dwarf2_build_psymtabs_hard): Skip partial units.
	(process_queue): Pass OBJFILE to load_full_comp_unit.  Check
	type_hash for read in CUs.  Test psymtab for NULL.
@
text
@d7884 4
d7890 2
d7898 14
d8048 1
d8073 30
d8104 1
a8116 1
#endif
d8119 39
a8157 1

d8172 13
d8541 1
a8541 1
      /* DWARF 3 extensions.  */
d8550 7
a8556 1
      /* GNU extensions.  */
d8559 13
d8593 2
d8611 1
d8614 27
d8690 1
a8690 2

    /* DWARF 3 */
d8701 7
a8707 2

      /* SGI/MIPS specific */
d8710 1
a8710 2

    /* GNU extensions */
a8716 1

@


1.205
log
@	* dwarf2read.c (dwarf_decode_lines): Call record_line upon
	encountering a different subfile.
@
text
@d392 3
a394 1
  /* The partial symbol table associated with this compilation unit.  */
d1071 2
a1072 1
static struct dwarf2_cu *load_full_comp_unit (struct dwarf2_per_cu_data *);
d1476 8
d2400 1
a2400 1
      load_full_comp_unit (item->per_cu);
d2407 1
a2407 1
      if (item->per_cu->psymtab->readin)
d2416 1
a2416 1
      if (!item->per_cu->psymtab->readin)
d2509 1
a2509 1
load_full_comp_unit (struct dwarf2_per_cu_data *per_cu)
d2511 1
a2511 2
  struct partial_symtab *pst = per_cu->psymtab;
  bfd *abfd = pst->objfile->obfd;
d2530 1
a2530 1
  cu->objfile = pst->objfile;
@


1.204
log
@        * dwarf2read.c (read_array_type): Set the type name if the name
        attribute is present.
@
text
@d6628 1
d6678 6
d6738 10
a6747 2
	        record_line (current_subfile, line, 
	                     check_cu_functions (address, cu));
d6774 4
a6777 1
                  dwarf2_start_subfile (fe->name, dir, comp_dir);
@


1.203
log
@	* dwarf2read.c (quirk_gcc_member_function_pointer): Add GCC PR
	number in a comment.
@
text
@d4285 4
@


1.202
log
@	* dwarf2read.c (quirk_gcc_member_function_pointer): New.
	(read_structure_type): Call it.
@
text
@d3714 4
a3717 1
   zero.  */
@


1.201
log
@2006-07-24  Frederic Riss  <frederic.riss@@st.com>

	* dwarf2read.c (struct dwarf2_per_objfile): Add
has_section_at_zero
	field.
	(dwarf2_locate_sections): Initialize
	dwarf2_per_objfile->has_section_at_zero.
	(dwarf2_get_pc_bounds): Use
dwarf2_per_objfile->has_section_at_zero
	instead of HAS_RELOC test.
	(read_partial_die): Ditto.
@
text
@d3711 63
d3803 3
a3806 1

@


1.200
log
@	* dwarf2read.c (dwarf2_symbol_mark_computed): Handle corrupted
	or missing location list information.  Suggested by Jan
	Kratochvil <lace@@jankratochvil.net>.
@
text
@d183 4
d1116 1
a1116 1
dwarf2_locate_sections (bfd *ignore_abfd, asection *sectp, void *ignore_ptr)
d1177 4
d3188 1
a3188 1
  if (low == 0 && (bfd_get_file_flags (obfd) & HAS_RELOC) == 0)
d5516 1
a5516 1
	  || (bfd_get_file_flags (abfd) & HAS_RELOC)))
@


1.199
log
@	* dwarf2read.c (read_unspecified_type): New function.
	(read_type_die): Handle DW_TAG_unspecified_type.
	(Committed by Julian Brown.)
@
text
@d9327 5
a9331 1
  if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
@


1.198
log
@	* gdb/dwarf2read.c (partial_read_comp_unit_head): Accept version 3.
@
text
@d4862 17
d7365 3
@


1.197
log
@Checked in under the 'obvious fix rule'

	2006-05-19  Fred Fish  <fnf@@specifix.com>
	* Makefile.in: Fix spelling of 'explicitly' and 'explicit'.
	* dwarfread.c: Fix spelling of 'unexpected'.
	* mips-tdep.c: Fix spelling of 'possible' and 'Determine'.
	* stack.c: Fix spelling of 'RETURN_VALUE'.
@
text
@d1307 1
a1307 1
  if (header->version != 2)
@


1.196
log
@2006-05-13  Gaius Mulley <gaius@@glam.ac.uk>

	* gdb/m2-lang.h: added function extern prototypes for m2_is_long_set
	and get_long_set_bounds.
	* gm2/m2-typeprint.c: This file has been completely
	replaced to reflect the Modula-2 syntax rather than call the
	c_print_type function.
	(m2_print_type): walk the Modula-2 type tree.
	(m2_type_name): added.
	(m2_range): added.
	(m2_typedef): added.
	(m2_array): added.
	(m2_pointer): added.
	(m2_ref): added.
	(m2_unknown): added.
	(m2_union): added.
	(m2_procedure): added.
	(m2_print_bounds): added.
	(m2_short_set): added.
	(m2_is_long_set): added.
	(m2_get_discrete_bounds): added.
	(m2_is_long_set_of_type): added.
	(m2_long_set): added.
	(m2_record_fields): added.
	(m2_enum): added.
	* gdb/dwarf2read.c: added ability to detect the language Modula-2
	and handle SET and CHAR types.
	(read_set_type): added.
	(process_die): call read_set_type.
	(read_base_type): modifed signed/unsigned char handling for Modula-2.
	(set_cu_language): added Modula-2 case clause.
	* gdb/m2-valprint.c: complete replacement so that Modula-2 values are
	printed rather than call the C language routines.
	(print_function_pointer_address): added.
	(get_long_set_bounds): added.
	(m2_print_long_set): added.
	(print_unpacked_pointer): added.
	(print_variable_at_address): added.
	(m2_val_print): replaced.
@
text
@d7349 1
a7349 1
      complaint (&symfile_complaints, _("unexepected tag in read_type_die: '%s'"),
@


1.196.2.1
log
@        * dwarf2read.c (dwarf2_symbol_mark_computed): Handle corrupted
        or missing location list information.  Suggested by Jan
        Kratochvil <lace@@jankratochvil.net>.
@
text
@d9307 1
a9307 5
  if ((attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
      /* ".debug_loc" may not exist at all, or the offset may be outside
	 the section.  If so, fall through to the complaint in the
	 other branch.  */
      && DW_UNSND (attr) < dwarf2_per_objfile->loc_size)
@


1.195
log
@Make LOC_OPTIMIZED_OUT the default value for a symbol.
@
text
@d3 2
a4 2
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006
d1076 3
d2668 3
d4249 9
d4746 4
d4751 2
d4754 3
a4756 2
	case DW_ATE_unsigned:
	case DW_ATE_unsigned_char:
d6193 3
a6198 1
    case DW_LANG_Modula2:
d6988 1
d7318 3
@


1.195.2.1
log
@Changes from nickrob-async-20060828-mergepoint.
@
text
@d3 2
a4 2
   Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
                 2002, 2003, 2004, 2005, 2006
a182 4

  /* A flag indicating wether this objfile has a section loaded at a
     VMA of 0.  */
  int has_section_at_zero;
a1075 3
static void read_set_type (struct die_info *, struct dwarf2_cu *);


d1109 1
a1109 1
dwarf2_locate_sections (bfd *abfd, asection *sectp, void *ignore_ptr)
a1169 4
  
  if ((bfd_get_section_flags (abfd, sectp) & SEC_LOAD)
      && bfd_section_vma (abfd, sectp) == 0)
    dwarf2_per_objfile->has_section_at_zero = 1;
d1304 1
a1304 1
  if (header->version != 2 && header->version != 3)
a2664 3
    case DW_TAG_set_type:
      read_set_type (die, cu);
      break;
d3174 1
a3174 1
  if (low == 0 && !dwarf2_per_objfile->has_section_at_zero)
a3696 66
/* GCC outputs unnamed structures that are really pointers to member
   functions, with the ABI-specified layout.  If DIE (from CU) describes
   such a structure, set its type, and return nonzero.  Otherwise return
   zero.

   GCC shouldn't do this; it should just output pointer to member DIEs.
   This is GCC PR debug/28767.  */

static int
quirk_gcc_member_function_pointer (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct type *type;
  struct die_info *pfn_die, *delta_die;
  struct attribute *pfn_name, *delta_name;
  struct type *pfn_type, *domain_type;

  /* Check for a structure with no name and two children.  */
  if (die->tag != DW_TAG_structure_type
      || dwarf2_attr (die, DW_AT_name, cu) != NULL
      || die->child == NULL
      || die->child->sibling == NULL
      || (die->child->sibling->sibling != NULL
	  && die->child->sibling->sibling->tag != DW_TAG_padding))
    return 0;

  /* Check for __pfn and __delta members.  */
  pfn_die = die->child;
  pfn_name = dwarf2_attr (pfn_die, DW_AT_name, cu);
  if (pfn_die->tag != DW_TAG_member
      || pfn_name == NULL
      || DW_STRING (pfn_name) == NULL
      || strcmp ("__pfn", DW_STRING (pfn_name)) != 0)
    return 0;

  delta_die = pfn_die->sibling;
  delta_name = dwarf2_attr (delta_die, DW_AT_name, cu);
  if (delta_die->tag != DW_TAG_member
      || delta_name == NULL
      || DW_STRING (delta_name) == NULL
      || strcmp ("__delta", DW_STRING (delta_name)) != 0)
    return 0;

  /* Find the type of the method.  */
  pfn_type = die_type (pfn_die, cu);
  if (pfn_type == NULL
      || TYPE_CODE (pfn_type) != TYPE_CODE_PTR
      || TYPE_CODE (TYPE_TARGET_TYPE (pfn_type)) != TYPE_CODE_FUNC)
    return 0;

  /* Look for the "this" argument.  */
  pfn_type = TYPE_TARGET_TYPE (pfn_type);
  if (TYPE_NFIELDS (pfn_type) == 0
      || TYPE_CODE (TYPE_FIELD_TYPE (pfn_type, 0)) != TYPE_CODE_PTR)
    return 0;

  domain_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (pfn_type, 0));
  type = alloc_type (objfile);
  smash_to_method_type (type, domain_type, TYPE_TARGET_TYPE (pfn_type),
			TYPE_FIELDS (pfn_type), TYPE_NFIELDS (pfn_type),
			TYPE_VARARGS (pfn_type));
  type = lookup_pointer_type (type);
  set_die_type (die, type, cu);

  return 1;
}
d3726 1
a3726 2
  if (quirk_gcc_member_function_pointer (die, cu))
    return;
a3727 1
  type = alloc_type (objfile);
a4242 9
/* Extract all information from a DW_TAG_set_type DIE and put it in
   the DIE's type field. */

static void
read_set_type (struct die_info *die, struct dwarf2_cu *cu)
{
  if (die->type == NULL)
    die->type = create_set_type ((struct type *) NULL, die_type (die, cu));
}
d4731 1
d4734 1
a4734 9
	  type_flags |= TYPE_FLAG_UNSIGNED;
	  break;
	case DW_ATE_signed_char:
	  if (cu->language == language_m2)
	    code = TYPE_CODE_CHAR;
	  break;
 	case DW_ATE_unsigned_char:
	  if (cu->language == language_m2)
	    code = TYPE_CODE_CHAR;
a4839 17
static void
read_unspecified_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *type;
  struct attribute *attr;

  if (die->type)
    return;

  /* For now, we only support the C meaning of an unspecified type: void.  */

  attr = dwarf2_attr (die, DW_AT_name, cu);
  type = init_type (TYPE_CODE_VOID, 0, 0, attr ? DW_STRING (attr) : "",
		    cu->objfile);

  set_die_type (die, type, cu);
}
d5469 1
a5469 1
	  || dwarf2_per_objfile->has_section_at_zero))
a6170 3
    case DW_LANG_Modula2:
      cu->language = language_m2;
      break;
d6174 1
a6963 1
	case DW_TAG_set_type:
a7292 3
    case DW_TAG_set_type:
      read_set_type (die, cu);
      break;
a7319 3
    case DW_TAG_unspecified_type:
      read_unspecified_type (die, cu);
      break;
d7321 1
a7321 1
      complaint (&symfile_complaints, _("unexpected tag in read_type_die: '%s'"),
d9279 1
a9279 5
  if ((attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
      /* ".debug_loc" may not exist at all, or the offset may be outside
	 the section.  If so, fall through to the complaint in the
	 other branch.  */
      && DW_UNSND (attr) < dwarf2_per_objfile->loc_size)
@


1.194
log
@2006-04-21  Frederic Riss  <frederic.riss@@st.com>

	* dwarf2read.c (dwarf2_start_subfile): Change prototype to accept
	compilation directory as last argument.
	Always pass comp_dir as second argument to start_subfile and prepend
	dirname to the filename when necessary.
	Remove now superfluous search for pre-existing subfile.
	(dwarf_decode_lines): Pass the compilation directory to
	dwarf2_start_subfile.
@
text
@d6859 1
a6859 1
      SYMBOL_CLASS (sym) = LOC_STATIC;
@


1.193
log
@	* dwarf2read.c (struct dwarf2_per_cu_data): Reduce length to
	30 bits.  Add load_all_dies flag.
	(load_partial_dies): Load all DIEs if per_cu->load_all_dies is set.
	Load DW_TAG_member by default.  Remove internal_error call.
	(find_partial_die): Reload the compilation unit if we can not find
	a DIE in the cache.  Call internal_error here if we still can not
	find the DIE.
@
text
@d849 1
a849 1
static void dwarf2_start_subfile (char *, char *);
d6532 1
a6532 1
          char *dir;
d6536 2
a6537 3
          else
            dir = comp_dir;
	  dwarf2_start_subfile (fe->name, dir);
d6629 1
a6629 1
                char *dir;
d6636 1
a6636 2
                else
                  dir = comp_dir;
d6638 1
a6638 1
                  dwarf2_start_subfile (fe->name, dir);
d6718 2
a6719 1
   or NULL if not known.
d6735 19
a6753 1
   subfile, so that `break /srcdir/list0.c:1' works as expected.  */
d6755 4
a6758 5
static void
dwarf2_start_subfile (char *filename, char *dirname)
{
  /* If the filename isn't absolute, try to match an existing subfile
     with the full pathname.  */
d6760 1
a6760 4
  if (!IS_ABSOLUTE_PATH (filename) && dirname != NULL)
    {
      struct subfile *subfile;
      char *fullname = concat (dirname, "/", filename, (char *)NULL);
d6762 2
a6763 12
      for (subfile = subfiles; subfile; subfile = subfile->next)
	{
	  if (FILENAME_CMP (subfile->name, fullname) == 0)
	    {
	      current_subfile = subfile;
	      xfree (fullname);
	      return;
	    }
	}
      xfree (fullname);
    }
  start_subfile (filename, dirname);
@


1.193.2.1
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>

	* gdb/dwarf2read.c (field_info): Add baseclasses.
	(dwarf2_add_field): Check base classes.
	(dwarf2_attach_fields_to_type): Ditto.

	* gdb/gnu-v3-abi.c (gnuv3_rtti_type): Check for NULL base_type.
	(gnuv3_virtual_fn_field): Handle missing base.
	(gnuv3_baseclass_offset): Handle missing vptr.
	* gdb/varobj.c (cplus_class_num_children): Call fill_in_vptr_fieldno.
	(cplus_name_of_child): Ditto.
	* gdb/eval.c (evaluate_subexp_standard): Ditto.
	* gdb/dwarf2read.c (read_structure_type): Search for vtable pointer
	by name in objects built by ARM compiler.

	* gdb/dwarf2read.c (dwarf2_add_member_fn): Calculate virtual function
	offset for classes without DW_AT_containing_type.
@
text
@d607 1
a607 1
     *fields, *baseclasses;
d609 1
a609 1
    /* Number of fields (including baseclasses).  */
d3260 2
a3261 11

  if (die->tag == DW_TAG_inheritance)
    {
      new_field->next = fip->baseclasses;
      fip->baseclasses = new_field;
    }
  else
    {
      new_field->next = fip->fields;
      fip->fields = new_field;
    }
d3467 2
a3468 15
      struct nextfield *fieldp;

      if (fip->fields)
	{
	  fieldp = fip->fields;
	  fip->fields = fieldp->next;
	}
      else
	{
	  fieldp = fip->baseclasses;
	  fip->baseclasses = fieldp->next;
	}

      TYPE_FIELD (type, nfields) = fieldp->field;
      switch (fieldp->accessibility)
d3485 1
a3485 1
		       fieldp->accessibility);
d3491 1
a3491 1
	  switch (fieldp->virtuality)
d3499 1
d3623 1
a3623 6
  /* Get index in virtual function table if it is a virtual member
     function.  For GCC, this is an offset in the appropriate
     virtual table, as specified by DW_AT_containing_type.  For
     everyone else, it is an expression to be evaluated relative
     to the object address.  */

d3625 1
a3625 1
  if (attr && fnp->fcontext)
d3641 1
a3641 22
    }
  else if (attr)
    {
      /* We only support trivial expressions here.  This hack will work
         for v3 classes, which always start with the vtable pointer.  */
      if (attr_form_is_block (attr) && DW_BLOCK (attr)->size > 0
	  && DW_BLOCK (attr)->data[0] == DW_OP_deref)
	{
	  struct dwarf_block blk;
	  blk.size = DW_BLOCK (attr)->size - 1;
	  blk.data = DW_BLOCK (attr)->data + 1;
          fnp->voffset = decode_locdesc (&blk, cu);
          if ((fnp->voffset % cu->header.addr_size) != 0)
            dwarf2_complex_location_expr_complaint ();
          else
            fnp->voffset /= cu->header.addr_size;
	  fnp->voffset += 2;
	  fnp->fcontext = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (die->type, 0));
	}
      else
	dwarf2_complex_location_expr_complaint ();
    }
d3828 1
a3828 2
	     class from the DW_AT_containing_type attribute.  This use of
	     DW_AT_containing_type is a GNU extension.  */
a3886 22
	  else if (cu->producer
		   && strncmp (cu->producer,
			       "ARM/Thumb C/C++ Compiler, RVCT", 30) == 0)
	    {
	      /* The ARM compiler does not provide direct indication
		 of the containing type, but the vtable pointer is
		 always named __vptr.  */

	      int i;

	      for (i = TYPE_NFIELDS (type) - 1;
		   i >= TYPE_N_BASECLASSES (type);
		   --i)
		{
		  if (strcmp (TYPE_FIELD_NAME (type, i), "__vptr") == 0)
		    {
		      TYPE_VPTR_FIELDNO (type) = i;
		      TYPE_VPTR_BASETYPE (type) = type;
		      break;
		    }
		}
	    }
@


1.193.2.2
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/dwarf2read.c (read_subroutine_type): Add armcc workaround.

	* gdb/dwarf2read.c (read_structure_type): Look for ADS vtable
	pointers.

	* gdb/dwarf2read.c (dwarf_decode_lines): Don't set dir for absolute
	paths.
	(dwarf_decode_lines): Ditto.
	(dwarf2_start_subfile): Split absolute filenames into path+file.

	* gdb/symtab.h (struct symbol): Add is_argument.
	(SYMBOL_IS_ARGUMENT): Define.
	* gdb/stack.c (print_frame_args): Use SYMBOL_IS_ARGUMENT.
	(print_frame_arg_vars): Ditto.
	* gdb/dwarf2read.c (new_symbol): Set SYMBOL_IS_ARGUMENT.
	(new_symbol): Mark optimized out arguments.

	* gdb/dwarf2read.c (partial_read_comp_unit_head): Accept version 3.

	* gdb/dwarf2read.c (read_unspecified_type): New function.
	(read_type_die): Handle DW_TAG_unspecified_type.
@
text
@d1304 1
a1304 1
  if (header->version != 2 && header->version != 3)
a3956 23
	  else if (cu->producer
		   && strncmp (cu->producer,
			       "ARM C++ Compiler, ADS", 21) == 0)
	    {
	      /* The ARM compiler does not provide direct indication
		 of the containing type, but the vtable pointer is
		 always named __VPTR.  Of course, we don't support this
		 C++ ABI, so this isn't too useful.  */

	      int i;

	      for (i = TYPE_NFIELDS (type) - 1;
		   i >= TYPE_N_BASECLASSES (type);
		   --i)
		{
		  if (strcmp (TYPE_FIELD_NAME (type, i), "__VPTR") == 0)
		    {
		      TYPE_VPTR_FIELDNO (type) = i;
		      TYPE_VPTR_BASETYPE (type) = type;
		      break;
		    }
		}
	    }
a4663 1
  struct die_info *spec_die;
a4669 14

  /* This works around a bug in armcc.  It marks "this" as artificial
     in the declaration but not in the definition.  It's also more
     efficient.  Should we be doing this for all types?  */
  spec_die = die_specification (die, cu);
  if (spec_die)
    {
      if (spec_die->type == NULL)
	read_type_die (spec_die, cu);
      die->type = spec_die->type;
      set_die_type (die, die->type, cu);
      return;
    }

a4909 17
static void
read_unspecified_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *type;
  struct attribute *attr;

  if (die->type)
    return;

  /* For now, we only support the C meaning of an unspecified type: void.  */

  attr = dwarf2_attr (die, DW_AT_name, cu);
  type = init_type (TYPE_CODE_VOID, 0, 0, attr ? DW_STRING (attr) : "",
		    cu->objfile);

  set_die_type (die, type, cu);
}
d6606 1
a6606 1
          else if (!IS_ABSOLUTE_PATH (fe->name))
a6607 3
	  else
	    dir = NULL;

d6707 1
a6707 1
		else if (!IS_ABSOLUTE_PATH (fe->name))
a6708 2
                else
		  dir = NULL;
a6810 11
  /* If the filename is absolute and no directory is known then
     split into a directory and relative path.   */
  if (dirname == NULL && IS_ABSOLUTE_PATH (filename))
    {
      char *new_name = (char *) lbasename (filename);
      dirname = alloca (new_name - filename);
      memcpy (dirname, filename, new_name - filename - 1);
      dirname[new_name - filename - 1] = '\0';
      filename = new_name;
    }

d6817 1
a6817 6
      char *fullname;

      if (dirname[strlen (dirname) - 1] == '/')
	fullname = concat (dirname, filename, (char *)NULL);
      else
	fullname = concat (dirname, "/", filename, (char *)NULL);
a6829 1

a7007 1
	  SYMBOL_IS_ARGUMENT (sym) = 1;
a7015 2
	  else
	    SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
a7386 3
    case DW_TAG_unspecified_type:
      read_unspecified_type (die, cu);
      break;
@


1.193.2.3
log
@2006-05-03  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	* gdb/c-valprint.c: Handle class member typedefs.

	* gdb/symtab.c (skip_prologue_using_sal): Treat two consecutive lines
	at the same address as a prolouge marker.
	* gdb/arm-tdep.c (arm_skip_prologue): Use skip_prologue_using_sal.

	* gdb/dwarf2expr.c (execute_stack_op): Check for bogus DW_OP_reg.

	* gdb/dwarf2read.c (read_structure_type): Use tag name for C++/Java
	classes.

	* Makefile.in (eval.o): Update dependencies.
	* eval.c: Include "ui-out.h" and "exceptions.h".
	(evaluate_subexp_standard): Use TRY_CATCH around value_of_variable.
	Use value_zero if an error occurs when avoiding side effects.
	* varobj.c (varobj_create): Call release_value after evaluate_type.
	(c_value_of_root): Initialize new_val.  Don't release_value a NULL
	value.

	* gdb/c-typeprint.c (cp_type_print_method_args): Don't print type
	details.

	* gdb/dwarf2read.c (dwarf2_debug_line_missing_file_complaint): New
	function.
	(dwarf_decode_lines): Check for line info without a file.
@
text
@a678 7
dwarf2_debug_line_missing_file_complaint (void)
{
  complaint (&symfile_complaints,
	     _(".debug_line section has line data without a file"));
}

static void
a3787 3

	  /* Suppress printing of "class ".  */
	  TYPE_NAME (type) = TYPE_TAG_NAME (type);
d6682 7
a6688 12
	      if (lh->num_file_names < file)
		dwarf2_debug_line_missing_file_complaint ();
	      else
		{
		  lh->file_names[file - 1].included_p = 1;
		  if (!decode_for_pst_p)
		    {
		      /* Append row to matrix using current values.  */
		      record_line (current_subfile, line, 
				   check_cu_functions (address, cu));
		    }
		}
d6702 3
a6704 9

		  if (lh->num_file_names < file)
		    dwarf2_debug_line_missing_file_complaint ();
		  else
		    {
		      lh->file_names[file - 1].included_p = 1;
		      if (!decode_for_pst_p)
			record_line (current_subfile, 0, address);
		    }
d6737 4
a6740 9
	      if (lh->num_file_names < file)
		dwarf2_debug_line_missing_file_complaint ();
	      else
		{
		  lh->file_names[file - 1].included_p = 1;
		  if (!decode_for_pst_p)
		    record_line (current_subfile, line, 
				 check_cu_functions (address, cu));
		}
d6762 9
a6770 14
		if (lh->num_file_names < file)
		  dwarf2_debug_line_missing_file_complaint ();
		else
		  {
		    fe = &lh->file_names[file - 1];
		    if (fe->dir_index)
		      dir = lh->include_dirs[fe->dir_index - 1];
		    else if (!IS_ABSOLUTE_PATH (fe->name))
		      dir = comp_dir;
		    else
		      dir = NULL;
		    if (!decode_for_pst_p)
		      dwarf2_start_subfile (fe->name, dir);
		  }
@


1.193.8.1
log
@	* buildsym.c (start_subfile): Handle producer.
	(record_producer): New function.
	* buildsym.h (struct subfile): Include producer.
	(record_producer): New prototype.
	* dwarf2-frame.c (struct dwarf2_cie): Add version.
	(struct dwarf2_frame_state): Add armcc_cfa_offsets_sf and
	armcc_cfa_offsets_reversed.
	(execute_cfa_program): Handle armcc_cfa_offsets_sf.
	(dwarf2_frame_find_quirks): New function.
	(dwarf2_frame_cache): Call it.  Handle armcc_cfa_offsets_reversed.
	(decode_frame_entry_1): Record the CIE version.
	* dwarf2read.c (read_file_scope): Save the producer.
	* symtab.h (struct symtab): Rename unused version member to
	producer.
@
text
@d2782 1
a2782 1

d2785 7
a2798 1
  record_producer (cu->producer);
@


1.193.8.2
log
@        gdb/
        * buildsym.c, symtab.c: Add local hack for FILENAME_CMP testing.
        * utils.c (cygwin_filename_cmp): New.

        Backport:
        2006-04-21  Frederic Riss  <frederic.riss@@st.com>
        * dwarf2read.c (dwarf2_start_subfile): Change prototype to accept
        compilation directory as last argument.
        Always pass comp_dir as second argument to start_subfile and prepend
        dirname to the filename when necessary.
        Remove now superfluous search for pre-existing subfile.
        (dwarf_decode_lines): Pass the compilation directory to
        dwarf2_start_subfile.

        gdb/testsuite/
        * config/symbian.exp (gdb_target_symbian): Handle a running target.
        (gdb_load): Add return value.

        * gdb.base/completion.exp: Test arg rather than a.  Handle
        very small lists of symbols.

        * gdb.base/list.exp: Differentiate run behavior based on
        use_gdb_stub.

        * gdb.base/maint.exp: Accept local symbols.  Accept missing .data.

        * gdb.base/remote.exp: Update packet limits.

        * gdb.base/varargs.exp: Don't pass an empty list item.

        * lib/gdb.exp (fullname_syntax): Recognize forward slashes in DOS
        paths.

        Backport:
        2006-06-22  Daniel Jacobowitz  <dan@@codesourcery.com>
        * gdb.base/gdb1555.exp: Use gdb_compile_shlib.  Skip if not
        native.

        2006-06-22  Daniel Jacobowitz  <dan@@codesourcery.com>
        * gdb.stabs/exclfwd.exp: Skip the test if configure did not
        enable stabs testing.

        2006-05-06  Ulrich Weigand  <Ulrich.Weigand@@de.ibm.com>
        * gdb.mi/mi-basics.exp: Add missing serial number to
        expected output in some mi_gdb_test statements.
        * gdb.mi/mi2-basics.exp: Likewise.
@
text
@d849 1
a849 1
static void dwarf2_start_subfile (char *, char *, char *);
d6526 1
a6526 1
          char *dir = NULL;
d6530 3
a6532 2

	  dwarf2_start_subfile (fe->name, dir, comp_dir);
d6624 1
a6624 1
                char *dir = NULL;
d6631 2
a6632 1

d6634 1
a6634 1
                  dwarf2_start_subfile (fe->name, dir, comp_dir);
d6714 1
a6714 2
   or NULL if not known.  COMP_DIR is the compilation directory for the
   linetable's compilation unit or NULL if not known.
d6730 7
a6736 19
   subfile, so that `break /srcdir/list0.c:1' works as expected.
   start_subfile will ensure that this happens provided that we pass the
   concatenation of files.files[1].dir and files.files[1].name as the
   subfile's name.  */

static void
dwarf2_start_subfile (char *filename, char *dirname, char *comp_dir)
{
  char *fullname;

  /* While reading the DIEs, we call start_symtab(DW_AT_name, DW_AT_comp_dir).
     `start_symtab' will always pass the contents of DW_AT_comp_dir as
     second argument to start_subfile.  To be consistent, we do the
     same here.  In order not to lose the line information directory,
     we concatenate it to the filename when it makes sense.
     Note that the Dwarf3 standard says (speaking of filenames in line
     information): ``The directory index is ignored for file names
     that represent full path names''.  Thus ignoring dirname in the
     `else' branch below isn't an issue.  */
d6739 3
a6741 3
    fullname = concat (dirname, SLASH_STRING, filename, (char *)NULL);
  else
    fullname = filename;
d6743 12
a6754 4
  start_subfile (fullname, comp_dir);

  if (fullname != filename)
    xfree (fullname);
@


1.192
log
@gdb/
	* Makefile.in (gdbtypes_h, gdbtypes.o, utils.o): Update.
	* defs.h (hashtab_obstack_allocate, dummy_obstack_deallocate): Add
	prototypes.
	* dwarf2read.c (read_subroutine_type): Use TYPE_ZALLOC.
	(hashtab_obstack_allocate, dummy_obstack_deallocate): Moved to...
	* utils.c (hashtab_obstack_allocate, dummy_obstack_deallocate):
	...here.
	* gdbtypes.c: Include "hashtab.h".
	(build_gdbtypes): Remove extra prototype.
	(struct type_pair, type_pair_hash, type_pair_eq)
	(create_copied_types_hash, copy_type_recursive): New.
	* gdbtypes.h: Include "hashtab.h".
	(TYPE_ZALLOC): New.
	(create_copied_types_hash, copy_type_recursive): New prototypes.
	* objfiles.c (free_objfile): Call preserve_values.
	* symfile.c (reread_symbols): Likewise.
	(clear_symtab_users): Remove calls to clear_value_history and
	clear_internalvars.
	* value.c (clear_value_history, clear_internalvars): Removed.
	(preserve_one_value, preserve_values): New functions.
	* value.h (clear_value_history, clear_internalvars): Removed.
	(preserve_values): New prototype.

	* tracepoint.c (_initialize_tracepoint): Do not initialize convenience
	variables here.
gdb/doc/
	* gdb.texinfo (Files): Remove obsolete bits from the description
	of "symbol-file".
@
text
@d363 1
a363 1
  /* The start offset and length of this compilation unit.  2**31-1
d367 1
a367 1
  unsigned long length : 31;
d373 6
d5153 1
d5160 3
d5198 6
a5203 2
      /* Check whether this DIE is interesting enough to save.  */
      if (!is_type_tag_for_partial (abbrev->tag)
d5207 2
a5208 1
	  && abbrev->tag != DW_TAG_namespace)
d5308 2
a5309 1
	 internal errors in find_partial_die.  */
d5311 2
a5312 1
      if (abbrev->tag == DW_TAG_subprogram
d5332 2
a5333 1
	  && (last_die->tag == DW_TAG_namespace
a5484 4
  if (lookup_die == NULL)
    internal_error (__FILE__, __LINE__,
		    _("could not find partial DIE in cache\n"));

d5493 2
a5494 1
  struct dwarf2_per_cu_data *per_cu;
d5498 5
a5502 1
    return find_partial_die_in_comp_unit (offset, cu);
d5514 36
a5549 1
  return find_partial_die_in_comp_unit (offset, per_cu->cu);
@


1.191
log
@gdb/ChangeLog:
2006-01-17  Jim Blandy  <jimb@@redhat.com>

	* symtab.h (struct general_symbol_info): Use gdb_byte for
	value.bytes.
	* stabsread.c (define_symbol): Use gdb_byte for the buffer holding
	a floating-point constant's value.
	* dwarf2read.c (dwarf2_const_value): Remove casts of value buffer
	to char *.
	* findvar.c (read_var_value): Eliminate needless temporary.
@
text
@a1032 4
static void *hashtab_obstack_allocate (void *data, size_t size, size_t count);

static void dummy_obstack_deallocate (void *object, void *data);

d4626 1
a4626 1
	TYPE_ALLOC (ftype, nparams * sizeof (struct field));
a9620 22
/* Allocation function for the libiberty hash table which uses an
   obstack.  */

static void *
hashtab_obstack_allocate (void *data, size_t size, size_t count)
{
  unsigned int total = size * count;
  void *ptr = obstack_alloc ((struct obstack *) data, total);
  memset (ptr, 0, total);
  return ptr;
}

/* Trivial deallocation function for the libiberty splay tree and hash
   table - don't deallocate anything.  Rely on later deletion of the
   obstack.  */

static void
dummy_obstack_deallocate (void *object, void *data)
{
  return;
}

@


1.190
log
@2006-01-17  Jim Blandy  <jimb@@redhat.com>

	* dwarf2read.c (struct dwarf2_per_objfile, struct comp_unit_head)
	(struct line_header, struct partial_die_info, struct dwarf_block):
	Use gdb_byte for members that refer to Dwarf section contents.
	(dwarf2_read_abbrevs, dwarf2_read_section, dwarf_decode_lines,
	dwarf_decode_macros, load_comp_unit, load_partial_dies,
	locate_pdi_sibling, partial_read_comp_unit_head, peek_die_abbrev,
	read_1_byte, read_1_signed_byte, read_2_bytes, read_4_bytes,
	read_8_bytes, read_address, read_attribute, read_attribute_value,
	read_comp_unit, read_comp_unit_head, read_die_and_children,
	read_die_and_siblings, read_full_die, read_indirect_string,
	read_initial_length, read_n_bytes, read_offset, read_partial_die,
	read_signed_leb128, read_string, read_unsigned_leb128,
	skip_children, skip_leb128, skip_one_die): Same.
@
text
@d7056 1
a7056 1
      SYMBOL_VALUE_BYTES (sym) = (char *)
d7074 1
a7074 1
      SYMBOL_VALUE_BYTES (sym) = (char *)
@


1.189
log
@	* dwarf2read.c, remote-fileio.c, remote.h: Update copyright
	notices.
@
text
@d165 7
a171 7
  char *info_buffer;
  char *abbrev_buffer;
  char *line_buffer;
  char *str_buffer;
  char *macinfo_buffer;
  char *ranges_buffer;
  char *loc_buffer;
d242 1
a242 1
  char *cu_head_ptr;
d246 1
a246 1
  char *first_die_ptr;
d428 1
a428 1
  char *statement_program_start, *statement_program_end;
d478 1
a478 1
    char *sibling;
d568 1
a568 1
    char *data;
d742 4
a745 4
static char *locate_pdi_sibling (struct partial_die_info *orig_pdi,
				 char *info_ptr,
				 bfd *abfd,
				 struct dwarf2_cu *cu);
d751 1
a751 1
char *dwarf2_read_section (struct objfile *, asection *);
d757 1
a757 1
static struct abbrev_info *peek_die_abbrev (char *, unsigned int *,
d763 1
a763 1
static struct partial_die_info *load_partial_dies (bfd *, char *, int,
d766 3
a768 3
static char *read_partial_die (struct partial_die_info *,
			       struct abbrev_info *abbrev, unsigned int,
			       bfd *, char *, struct dwarf2_cu *);
d776 2
a777 2
static char *read_full_die (struct die_info **, bfd *, char *,
			    struct dwarf2_cu *, int *);
d779 2
a780 2
static char *read_attribute (struct attribute *, struct attr_abbrev *,
			     bfd *, char *, struct dwarf2_cu *);
d782 2
a783 2
static char *read_attribute_value (struct attribute *, unsigned,
			     bfd *, char *, struct dwarf2_cu *);
d785 1
a785 1
static unsigned int read_1_byte (bfd *, char *);
d787 1
a787 1
static int read_1_signed_byte (bfd *, char *);
d789 1
a789 1
static unsigned int read_2_bytes (bfd *, char *);
d791 1
a791 1
static unsigned int read_4_bytes (bfd *, char *);
d793 1
a793 1
static unsigned long read_8_bytes (bfd *, char *);
d795 1
a795 1
static CORE_ADDR read_address (bfd *, char *ptr, struct dwarf2_cu *,
d798 1
a798 1
static LONGEST read_initial_length (bfd *, char *,
d801 1
a801 1
static LONGEST read_offset (bfd *, char *, const struct comp_unit_head *,
d804 1
a804 1
static char *read_n_bytes (bfd *, char *, unsigned int);
d806 1
a806 1
static char *read_string (bfd *, char *, unsigned int *);
d808 3
a810 2
static char *read_indirect_string (bfd *, char *, const struct comp_unit_head *,
				   unsigned int *);
d812 1
a812 1
static unsigned long read_unsigned_leb128 (bfd *, char *, unsigned int *);
d814 1
a814 1
static long read_signed_leb128 (bfd *, char *, unsigned int *);
d816 1
a816 1
static char *skip_leb128 (bfd *, char *);
d866 3
a868 1
static char *typename_concat (struct obstack *, const char *prefix, const char *suffix,
d944 1
a944 1
static struct die_info *read_comp_unit (char *, bfd *, struct dwarf2_cu *);
d946 1
a946 1
static struct die_info *read_die_and_children (char *info_ptr, bfd *abfd,
d948 1
a948 1
					       char **new_info_ptr,
d951 1
a951 1
static struct die_info *read_die_and_siblings (char *info_ptr, bfd *abfd,
d953 1
a953 1
					       char **new_info_ptr,
d1028 2
a1029 2
static char *skip_one_die (char *info_ptr, struct abbrev_info *abbrev,
			   struct dwarf2_cu *cu);
d1270 1
a1270 1
static char *
d1272 1
a1272 1
		     char *info_ptr, bfd *abfd)
d1294 2
a1295 2
static char *
partial_read_comp_unit_head (struct comp_unit_head *header, char *info_ptr,
d1298 1
a1298 1
  char *beg_of_comp_unit = info_ptr;
d1394 2
a1395 2
  char *info_ptr;
  char *beg_of_comp_unit;
d1561 1
a1561 1
  char *info_ptr, *beg_of_comp_unit;
d1620 1
a1620 1
  char *info_ptr = dwarf2_per_objfile->info_buffer;
d1630 1
a1630 1
      char *beg_of_comp_unit;
d2144 1
a2144 1
peek_die_abbrev (char *info_ptr, unsigned int *bytes_read,
d2170 2
a2171 2
static char *
skip_children (char *info_ptr, struct dwarf2_cu *cu)
d2192 2
a2193 2
static char *
skip_one_die (char *info_ptr, struct abbrev_info *abbrev,
d2289 2
a2290 2
static char *
locate_pdi_sibling (struct partial_die_info *orig_pdi, char *info_ptr,
d2491 1
a2491 1
  char *info_ptr;
d3064 1
a3064 1
	  char *buffer;
d3451 1
a3451 1
      char *pointer;
d3454 2
a3455 2
      pointer = (char *) TYPE_ALLOC (type, num_bytes);
      TYPE_FIELD_VIRTUAL_BITS (type) = (B_TYPE *) pointer;
d4842 1
a4842 1
read_comp_unit (char *info_ptr, bfd *abfd, struct dwarf2_cu *cu)
d4854 1
a4854 1
read_die_and_children (char *info_ptr, bfd *abfd,
d4856 1
a4856 1
		       char **new_info_ptr,
d4860 1
a4860 1
  char *cur_ptr;
d4887 1
a4887 1
read_die_and_siblings (char *info_ptr, bfd *abfd,
d4889 1
a4889 1
		       char **new_info_ptr,
d4893 1
a4893 1
  char *cur_ptr;
d4946 1
a4946 1
char *
d4950 1
a4950 1
  char *buf, *retbuf;
d4956 2
a4957 3
  buf = (char *) obstack_alloc (&objfile->objfile_obstack, size);
  retbuf
    = (char *) symfile_relocate_debug_section (abfd, sectp, (bfd_byte *) buf);
d4979 1
a4979 1
  char *abbrev_ptr;
d5144 1
a5144 1
load_partial_dies (bfd *abfd, char *info_ptr, int building_psymtab,
d5340 1
a5340 1
static char *
d5344 1
a5344 1
		  char *info_ptr, struct dwarf2_cu *cu)
d5549 2
a5550 2
static char *
read_full_die (struct die_info **diep, bfd *abfd, char *info_ptr,
d5633 1
a5633 1
static char *
d5635 1
a5635 1
		      bfd *abfd, char *info_ptr,
d5755 1
a5755 1
static char *
d5757 1
a5757 1
		bfd *abfd, char *info_ptr, struct dwarf2_cu *cu)
d5766 1
a5766 1
read_1_byte (bfd *abfd, char *buf)
d5768 1
a5768 1
  return bfd_get_8 (abfd, (bfd_byte *) buf);
d5772 1
a5772 1
read_1_signed_byte (bfd *abfd, char *buf)
d5774 1
a5774 1
  return bfd_get_signed_8 (abfd, (bfd_byte *) buf);
d5778 1
a5778 1
read_2_bytes (bfd *abfd, char *buf)
d5780 1
a5780 1
  return bfd_get_16 (abfd, (bfd_byte *) buf);
d5784 1
a5784 1
read_2_signed_bytes (bfd *abfd, char *buf)
d5786 1
a5786 1
  return bfd_get_signed_16 (abfd, (bfd_byte *) buf);
d5790 1
a5790 1
read_4_bytes (bfd *abfd, char *buf)
d5792 1
a5792 1
  return bfd_get_32 (abfd, (bfd_byte *) buf);
d5796 1
a5796 1
read_4_signed_bytes (bfd *abfd, char *buf)
d5798 1
a5798 1
  return bfd_get_signed_32 (abfd, (bfd_byte *) buf);
d5802 1
a5802 1
read_8_bytes (bfd *abfd, char *buf)
d5804 1
a5804 1
  return bfd_get_64 (abfd, (bfd_byte *) buf);
d5808 1
a5808 1
read_address (bfd *abfd, char *buf, struct dwarf2_cu *cu,
d5819 1
a5819 1
	  retval = bfd_get_signed_16 (abfd, (bfd_byte *) buf);
d5822 1
a5822 1
	  retval = bfd_get_signed_32 (abfd, (bfd_byte *) buf);
d5825 1
a5825 1
	  retval = bfd_get_signed_64 (abfd, (bfd_byte *) buf);
d5838 1
a5838 1
	  retval = bfd_get_16 (abfd, (bfd_byte *) buf);
d5841 1
a5841 1
	  retval = bfd_get_32 (abfd, (bfd_byte *) buf);
d5844 1
a5844 1
	  retval = bfd_get_64 (abfd, (bfd_byte *) buf);
d5901 1
a5901 1
read_initial_length (bfd *abfd, char *buf, struct comp_unit_head *cu_header,
d5904 1
a5904 1
  LONGEST length = bfd_get_32 (abfd, (bfd_byte *) buf);
d5908 1
a5908 1
      length = bfd_get_64 (abfd, (bfd_byte *) buf + 4);
d5914 1
a5914 1
      length = bfd_get_64 (abfd, (bfd_byte *) buf);
d5945 1
a5945 1
read_offset (bfd *abfd, char *buf, const struct comp_unit_head *cu_header,
d5953 1
a5953 1
      retval = bfd_get_32 (abfd, (bfd_byte *) buf);
d5957 1
a5957 1
      retval = bfd_get_64 (abfd, (bfd_byte *) buf);
d5969 2
a5970 2
static char *
read_n_bytes (bfd *abfd, char *buf, unsigned int size)
d5980 1
a5980 1
read_string (bfd *abfd, char *buf, unsigned int *bytes_read_ptr)
d5991 2
a5992 2
  *bytes_read_ptr = strlen (buf) + 1;
  return buf;
d5996 1
a5996 1
read_indirect_string (bfd *abfd, char *buf,
d6018 1
a6018 1
  return dwarf2_per_objfile->str_buffer + str_offset;
d6022 1
a6022 1
read_unsigned_leb128 (bfd *abfd, char *buf, unsigned int *bytes_read_ptr)
d6035 1
a6035 1
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
d6050 1
a6050 1
read_signed_leb128 (bfd *abfd, char *buf, unsigned int *bytes_read_ptr)
d6062 1
a6062 1
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
d6080 2
a6081 2
static char *
skip_leb128 (bfd *abfd, char *buf)
d6087 1
a6087 1
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
d6286 1
a6286 1
  char *line_ptr;
d6338 1
a6338 1
    = (unsigned char *) xmalloc (lh->opcode_base * sizeof (unsigned char));
d6450 2
a6451 2
  char *line_ptr;
  char *line_end;
d8590 1
a8590 1
  char *data = blk->data;
d8594 1
a8594 1
  unsigned char op;
d9078 1
a9078 1
  char *mac_ptr, *mac_end;
@


1.188
log
@	* dwarf2read.c (peek_die_abbrev, read_address, read_initial_length)
	(read_offset): Change BYTES_READ argument to unsigned int.
	(dwarf2_build_psymtabs_easy, read_comp_unit_head)
	(create_all_comp_units, dwarf2_get_pc_bounds)
	(dwarf_decode_line_header, var_decode_location)
	(dwarf_decode_macros): Change local BYTES_READ variables to
	unsigned int.
	(read_indirect_string): Remove obsolete cast.
@
text
@d4 1
a4 1
   2004, 2005
@


1.187
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d757 2
a758 1
static struct abbrev_info *peek_die_abbrev (char *, int *, struct dwarf2_cu *);
d796 1
a796 1
			       int *bytes_read);
d799 1
a799 1
                                    struct comp_unit_head *, int *bytes_read);
d802 1
a802 1
                            int *bytes_read);
d1245 1
a1245 1
      int bytes_read;
d1248 1
a1248 1
                                         &bytes_read);
d1272 1
a1272 1
  int bytes_read;
d1630 1
a1630 1
      int bytes_read;
d2141 2
a2142 1
peek_die_abbrev (char *info_ptr, int *bytes_read, struct dwarf2_cu *cu)
d3060 1
a3060 1
	  int dummy;
d5806 2
a5807 1
read_address (bfd *abfd, char *buf, struct dwarf2_cu *cu, int *bytes_read)
d5900 1
a5900 1
                     int *bytes_read)
d5944 1
a5944 1
             int *bytes_read)
d5999 1
a5999 1
				    (int *) bytes_read_ptr);
d6285 1
a6285 1
  int bytes_read;
d6745 1
a6745 1
      int dummy;
d9113 1
a9113 1
            int bytes_read;
d9141 1
a9141 1
            int bytes_read;
d9192 1
a9192 1
            int bytes_read;
@


1.186
log
@2005-11-03  Wu Zhou  <woodzltc@@cn.ibm.com>

        Checked in by Elena Zannoni  <ezannoni@@redhat.com>

       * dwarf2read.c (read_structure_type): Add IBM XL C++
       specific code to set TYPE_VPTR_FIELDNO and TYPE_VPTR_BASETYPE
       of a virtual class if a field named "__vfp" is found.
@
text
@d3 1
a3 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
d28 2
a29 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.185
log
@2005-11-03  Jim Blandy  <jimb@@redhat.com>

        Checked in by Elena Zannoni  <ezannoni@@redhat.com>

       * dwarf2read.c (file_full_name): Cope with file numbers that are
       out of range for the given line header.
@
text
@d3858 22
@


1.184
log
@	* dwarf2read.c (isreg): Removed.
	(decode_locdesc): Don't set it.
@
text
@d8798 5
a8802 1
  struct file_entry *fe = &lh->file_names[file - 1];
d8804 26
a8829 2
  if (IS_ABSOLUTE_PATH (fe->name))
    return xstrdup (fe->name);
d8832 9
a8840 8
      const char *dir;
      int dir_len;
      char *full_name;

      if (fe->dir_index)
        dir = lh->include_dirs[fe->dir_index - 1];
      else
        dir = comp_dir;
d8842 1
a8842 11
      if (dir)
        {
          dir_len = strlen (dir);
          full_name = xmalloc (dir_len + 1 + strlen (fe->name) + 1);
          strcpy (full_name, dir);
          full_name[dir_len] = '/';
          strcpy (full_name + dir_len + 1, fe->name);
          return full_name;
        }
      else
        return xstrdup (fe->name);
@


1.184.2.1
log
@2005-11-03  Jim Blandy  <jimb@@redhat.com>

        Checked in by Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2read.c (file_full_name): Cope with file numbers that are
	out of range for the given line header.
@
text
@d8798 5
a8802 3
  /* Is the file number a valid index into the line header's file name
     table?  Remember that file numbers start with one, not zero.  */
  if (1 <= file && file <= lh->num_file_names)
d8804 6
a8809 4
      struct file_entry *fe = &lh->file_names[file - 1];
  
      if (IS_ABSOLUTE_PATH (fe->name))
        return xstrdup (fe->name);
d8811 3
d8815 6
a8820 20
          const char *dir;
          int dir_len;
          char *full_name;

          if (fe->dir_index)
            dir = lh->include_dirs[fe->dir_index - 1];
          else
            dir = comp_dir;

          if (dir)
            {
              dir_len = strlen (dir);
              full_name = xmalloc (dir_len + 1 + strlen (fe->name) + 1);
              strcpy (full_name, dir);
              full_name[dir_len] = '/';
              strcpy (full_name + dir_len + 1, fe->name);
              return full_name;
            }
          else
            return xstrdup (fe->name);
d8822 2
a8823 14
    }
  else
    {
      /* The compiler produced a bogus file number.  We can at least
         record the macro definitions made in the file, even if we
         won't be able to find the file by name.  */
      char fake_name[80];
      sprintf (fake_name, "<bad macro file number %d>", file);

      complaint (&symfile_complaints, 
                 _("bad file number in macro information (%d)"),
                 file);

      return xstrdup (fake_name);
@


1.184.2.2
log
@2005-11-03  Wu Zhou  <woodzltc@@cn.ibm.com>

        Checked in by Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2read.c (read_structure_type): Add IBM XL C++
	specific code to set TYPE_VPTR_FIELDNO and TYPE_VPTR_BASETYPE
	of a virtual class if a field named "__vfp" is found.
@
text
@a3857 22
	  else if (cu->producer
		   && strncmp (cu->producer,
			       "IBM(R) XL C/C++ Advanced Edition", 32) == 0)
	    {
	      /* The IBM XLC compiler does not provide direct indication
	         of the containing type, but the vtable pointer is
	         always named __vfp.  */

	      int i;

	      for (i = TYPE_NFIELDS (type) - 1;
		   i >= TYPE_N_BASECLASSES (type);
		   --i)
		{
		  if (strcmp (TYPE_FIELD_NAME (type, i), "__vfp") == 0)
		    {
		      TYPE_VPTR_FIELDNO (type) = i;
		      TYPE_VPTR_BASETYPE (type) = type;
		      break;
		    }
		}
	    }
@


1.183
log
@	* dwarf2-frame.c (read_signed_leb128): Handle values that do not
	fit in 32 bits.
	* dwarf2read.c (read_signed_leb128): Likewise.
@
text
@a582 9
/* FIXME: decode_locdesc sets these variables to describe the location
   to the caller.  These ought to be a structure or something.   If
   none of the flags are set, the object lives at the address returned
   by decode_locdesc.  */

static int isreg;		/* Object lives in register.
				   decode_locdesc's return value is
				   the register number.  */

a8552 3
   When the result is a register number, the global isreg flag is set,
   otherwise it is cleared.

a8571 1
  isreg = 0;
a8644 1
	  isreg = 1;
a8650 1
	  isreg = 1;
@


1.182
log
@* bsd-kvm.c (bsd_kvm_open): Properly cast sentinel in concat call.
* coffread.c (patch_type, process_coff_symbol): Likewise.
* corelow.c (core_open): Likewise.
* dwarf2read.c (dwarf_decode_lines, dwarf2_start_subfile):
* language.c (set_lang_str, set_type_str, set_range_str)
(set_case_str): Likewise.
* source.c (add_path, openp): Likewise.
* stabsread.c: Likewise.
* top.c (init_history): Likewise.
* utils.c (xfullpath): Likewise.
* value.c (lookup_internalvar): Likewise.
* cli/cli-cmds.c (cd_command): Likewise.
* cli/cli-dump.c (add_dump_command): Likewise.
@
text
@d6035 1
a6035 1
  int i, shift, size, num_read;
a6039 1
  size = 32;
d6054 2
a6055 4
  if ((shift < size) && (byte & 0x40))
    {
      result |= -(1 << shift);
    }
@


1.181
log
@        * dwarf2read.c (dwarf_decode_lines): Use the complete filename
        when creating include psymtabs.
@
text
@d4 1
a4 1
   2004
d6635 2
a6636 2
                include_name =
                  concat (dir_name, SLASH_STRING, include_name, NULL);
d6642 2
a6643 2
                pst_filename =
                  concat (pst->dirname, SLASH_STRING, pst_filename, NULL);
d6682 1
a6682 1
      char *fullname = concat (dirname, "/", filename, NULL);
@


1.180
log
@2005-02-25 Mark Kettenis  <kettenis@@gnu.org>

	Committed by Elena Zannoni <ezannoni@@redhat.com>

	* dwarf2read.c (dwarf2_build_psymtabs_hard): Adjust
	info_ptr before building psymtabs for included files.
	(create_all_comp_units): Initailize initial length size of
	compilation header to zero.
	(read_initial_length): Complain if both 32-bit and 64-bit DWARF
	sections are encountered within the same compilation header.
	(dwarf_decode_line_header): Pass compilation header in call to
	read_initial_length.
@
text
@d6625 23
a6647 3
            char *include_name = lh->file_names [file_index].name;
    
            if (strcmp (include_name, pst->filename) != 0)
@


1.179
log
@2005-02-24  Andrew Cagney  <cagney@@gnu.org>

	Add show_VARIABLE functions, update add_setshow call.
	* varobj.c (_initialize_varobj, show_varobjdebug): Add and update.
	* valprint.c (_initialize_valprint, show_print_max)
	(show_stop_print_at_null, show_repeat_count_threshold)
	(show_prettyprint_structs, show_unionprint)
	(show_prettyprint_arrays, show_addressprint, show_input_radix)
	(show_output_radix): Ditto.
	* valops.c (_initialize_valops, show_overload_resolution): Ditto.
	* utils.c (initialize_utils, show_chars_per_line)
	(show_lines_per_page, show_demangle, show_pagination_enabled)
	(show_sevenbit_strings, show_asm_demangle): Ditto
	* tui/tui-win.c (_initialize_tui_win, show_tui_border_kind)
	(show_tui_border_mode, show_tui_active_border_mode): Ditto.
	* top.c (init_main, show_new_async_prompt)
	(show_async_command_editing_p, show_write_history_p)
	(show_history_size, show_history_filename, show_caution)
	(show_annotation_level, init_main): Ditto.
	* target.c (initialize_targets, show_targetdebug)
	(show_trust_readonly): Ditto.
	* symfile.c (_initialize_symfile, show_symbol_reloading)
	(show_ext_args, show_download_write_size)
	(show_debug_file_directory): Ditto.
	* source.c (_initialize_source, show_lines_to_list): Ditto.
	* solib.c (_initialize_solib, show_auto_solib_add)
	(show_solib_search_path): Ditto.
	* p-valprint.c (_initialize_pascal_valprint)
	(show_pascal_static_field_print): Ditto.
	* printcmd.c (_initialize_printcmd, show_max_symbolic_offset)
	(show_print_symbol_filename): Add and update.
	* parse.c (_initialize_parse, show_expressiondebug): Dito.
	* observer.c (_initialize_observer, show_observer_debug): Dito.
	* maint.c (_initialize_maint_cmds, show_watchdog)
	(show_maintenance_profile_p): Dito.
	* linux-nat.c (_initialize_linux_nat, show_debug_linux_nat): Dito.
	* infrun.c (_initialize_infrun, show_debug_infrun)
	(show_stop_on_solib_events, show_follow_fork_mode_string)
	(show_scheduler_mode, show_step_stop_if_no_debug): Ditto.
	* infcall.c (_initialize_infcall, show_coerce_float_to_double_p)
	(show_unwind_on_signal_p): Ditto.
	* gdbtypes.c (build_gdbtypes, show_opaque_type_resolution)
	(_initialize_gdbtypes, show_overload_debug): Ditto.
	* gdb-events.c, gdb-events.sh (_initialize_gdb_events)
	(show_gdb_events_debug): Ditto.
	* gdbarch.c, gdbarch.sh (show_gdbarch_debug)
	(_initialize_gdbarch): Ditto.
	* frame.c (_initialize_frame, show_backtrace_past_main)
	(show_backtrace_past_entry, show_backtrace_limit)
	(show_frame_debug): Ditto.
	* exec.c (_initialize_exec, show_write_files): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read)
	(show_dwarf2_max_cache_age): Ditto.
	* demangle.c (_initialize_demangler)
	(show_demangling_style_names): Ditto.
	* dcache.c (_initialize_dcache, show_dcache_enabled_p): Ditto.
	* cp-valprint.c (show_static_field_print)
	(_initialize_cp_valprint, show_vtblprint, show_objectprint): Ditto.
	* corefile.c (_initialize_core, show_gnutarget_string): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging)
	(show_logging_overwrite, show_logging_redirect)
	(show_logging_filename): Ditto.
	* cli/cli-cmds.c (show_info_verbose, show_history_expansion_p)
	(init_cli_cmds, show_baud_rate, show_remote_debug)
	(show_remote_timeout, show_max_user_call_depth): Ditto.
	* charset.c (show_host_charset_name, show_target_charset_name)
	(initialize_charset): Ditto.
	* breakpoint.c (show_can_use_hw_watchpoints)
	(show_pending_break_support, _initialize_breakpoint): Ditto.
@
text
@d1545 3
a1554 3
      info_ptr = beg_of_comp_unit + cu.header.length
                                  + cu.header.initial_length_size;

d1644 1
d5864 1
a5864 1
   the width of file offsets to be fetched later with fetch_offset().)
d5886 1
a5886 3
  LONGEST retval = 0;

  retval = bfd_get_32 (abfd, (bfd_byte *) buf);
d5888 1
a5888 1
  if (retval == 0xffffffff)
d5890 1
a5890 1
      retval = bfd_get_64 (abfd, (bfd_byte *) buf + 4);
a5891 5
      if (cu_header != NULL)
	{
	  cu_header->initial_length_size = 12;
	  cu_header->offset_size = 8;
	}
d5893 1
a5893 1
  else if (retval == 0)
d5895 2
a5896 3
      /* Handle (non-standard) 64-bit DWARF2 formats such as that used
         by IRIX.  */
      retval = bfd_get_64 (abfd, (bfd_byte *) buf);
a5897 5
      if (cu_header != NULL)
	{
	  cu_header->initial_length_size = 8;
	  cu_header->offset_size = 8;
	}
a5901 5
      if (cu_header != NULL)
	{
	  cu_header->initial_length_size = 4;
	  cu_header->offset_size = 4;
	}
d5904 17
a5920 1
  return retval;
d6298 2
a6299 1
  lh->total_length = read_initial_length (abfd, line_ptr, NULL, &bytes_read);
@


1.178
log
@2005-02-17  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* command.h (fprint_setshow_ftype): Delete.
	(add_setshow_cmd_full, add_setshow_enum_cmd)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Delete
	fprint_setshow parameter.
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* complaints.c, cris-tdep.c, dwarf2read.c, frame.c: Update.
	* hppa-tdep.c, infcall.c, m32r-rom.c, maint.c: Update.
	* mips-tdep.c, nto-tdep.c, observer.c, remote-rdi.c: Update
	* remote.c, target.c, cli/cli-logging.c: Update.
@
text
@d662 9
d9662 1
a9662 1
			    NULL, /* FIXME: i18n: The upper bound on the age of cached dwarf2 compilation units is %d.  */
@


1.177
log
@        * dwarf2read.c (new_symbol): Use SYMBOL_SEARCH_NAME rather than
        SYMBOL_NATURAL_NAME to set type names.
@
text
@d9652 1
d9654 1
a9654 1
			    NULL, NULL, &set_dwarf2_cmdlist,
@


1.176
log
@2005-02-15  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_com, add_info and add_prefix_cmd.
	* breakpoint.c, cp-support.c, dcache.c, dwarf2read.c: Update.
	* exec.c, f-valprint.c, frame.c, gcore.c, gnu-nat.c: Update.
	* go32-nat.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* kod.c, language.c, linux-nat.c, m32r-rom.c, macrocmd.c: Update.
	* maint.c, memattr.c, mips-tdep.c, nto-procfs.c, objc-lang.c: Update.
	* ocd.c, pa64solib.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote-e7000.c, remote-m32r-sdi.c, remote-mips.c: Update.
	* remote-sds.c, remote-sim.c, remote-st.c, remote-utils.c: Update.
	* remote.c, rs6000-tdep.c, ser-go32.c, serial.c: Update.
	* sh-tdep.c, solib.c, somsolib.c, source.c, stack.c: Update.
	* symfile.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, typeprint.c, utils.c, valprint.c: Update.
	* win32-nat.c, xcoffsolib.c, cli/cli-cmds.c, cli/cli-dump.c: Update.
	* cli/cli-logging.c, tui/tui-layout.c, tui/tui-regs.c: Update.
	* tui/tui-stack.c, tui/tui-win.c: Update.
@
text
@d6927 1
a6927 1
		  TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_NATURAL_NAME (sym);
@


1.175
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	Mark up add_setshow functions, replace "PRINT:" comment prefix
	with "FIXME: i18n:".
	* aix-thread.c, alpha-tdep.c, arm-tdep.c, breakpoint.c: Update.
	* cris-tdep.c, dwarf2read.c, frame.c, hppa-tdep.c: Update.
	* infcall.c, m32r-rom.c, maint.c, mips-tdep.c: Update.
	* nto-tdep.c, observer.c, remote-rdi.c, remote.c: Update.
	* target.c, cli/cli-logging.c: Update.
@
text
@d9633 3
a9635 3
  add_prefix_cmd ("dwarf2", class_maintenance, set_dwarf2_cmd,
		  "Set DWARF 2 specific variables.\n"
		  "Configure DWARF 2 variables such as the cache size",
d9639 3
a9641 3
  add_prefix_cmd ("dwarf2", class_maintenance, show_dwarf2_cmd,
		  "Show DWARF 2 specific variables\n"
		  "Show DWARF 2 variables such as the cache size",
@


1.174
log
@2005-02-14  Andrew Cagney  <cagney@@gnu.org>

	* utils.c (paddress): New function.
	* defs.h (paddress): Declare.
	* printcmd.c (deprecated_print_address_numeric): Rename
	print_address_numeric, call paddress.
	* valprint.c, ui-out.c, tui/tui-stack.c, tracepoint.c: Update.
	* symmisc.c, symfile.c stack.c, p-valprint.c, printcmd.c: Update.
	* maint.c, m32r-rom.c, infcmd.c, f-valprint.c, exec.c: Update.
	* dwarf2read.c, dve3900-rom.c, defs.h, c-valprint.c: Update.
	* corefile.c, cli/cli-cmds.c, breakpoint.c, annotate.c: Update.
	* ada-valprint.c: Update.
@
text
@d9646 7
a9652 11
			    &dwarf2_max_cache_age,
			    "Set the upper bound on the age of cached "
			    "dwarf2 compilation units.",
			    "Show the upper bound on the age of cached "
			    "dwarf2 compilation units.",
			    "A higher limit means that cached "
			    "compilation units will be stored\n"
			    "in memory longer, and more total memory will "
			    "be used.  Zero disables\n"
			    "caching, which can slow down startup.",
			    NULL, /* PRINT: The upper bound on the age of cached dwarf2 compilation units is %d.  */
@


1.173
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up some of printf_filtered and printf_unfiltered.
	* ada-lang.c, annotate.c, arch-utils.c, breakpoint.c: Update.
	* corelow.c, cp-namespace.c, cp-support.c, dcache.c: Update.
	* demangle.c, dsrec.c, dwarf2read.c, dwarfread.c: Update.
	* event-loop.c, event-top.c, exec.c, f-valprint.c: Update.
	* gdbtypes.c, inf-loop.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcmd.c, inflow.c, infrun.c, inftarg.c, language.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, maint.c: Update.
	* mdebugread.c, memattr.c, monitor.c, objc-lang.c: Update.
	* ocd.c, osabi.c, printcmd.c, procfs.c, regcache.c: Update.
	* remote.c, solib-som.c, solib.c, somsolib.c, source.c: Update.
	* stack.c, symfile.c, symmisc.c, target.c, thread.c: Update.
	* top.c, utils.c, valprint.c, value.c, cli/cli-cmds.c: Update.
	* cli/cli-dump.c, cli/cli-logging.c, tui/tui-hooks.c: Update.
	* tui/tui-regs.c, tui/tui-win.c: Update.
@
text
@d8338 1
a8338 1
	  print_address_numeric (DW_ADDR (&die->attrs[i]), 1, gdb_stderr);
@


1.172
log
@2005-02-11  Andrew Cagney  <cagney@@gnu.org>

	Mark up error_no_arg, query, perror_with_name, complaint, and
	internal_error.
	* breakpoint.c, cp-abi.c, cp-namespace.c, cp-support.c: Update.
	* cris-tdep.c, dbxread.c, dictionary.c, dsrec.c: Update.
	* dummy-frame.c, dve3900-rom.c, dwarf2-frame.c, dwarf2expr.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, event-loop.c: Update.
	* exceptions.c, exec.c, f-lang.c, findvar.c, fork-child.c: Update.
	* frame-unwind.c, frame.c, frv-linux-tdep.c, frv-tdep.c: Update.
	* gdb_assert.h, gdbarch.c, gdbtypes.c, gnu-nat.c: Update.
	* go32-nat.c, hppa-tdep.c, hppabsd-nat.c, hpread.c: Update.
	* i386-linux-nat.c, i386-nat.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386fbsd-nat.c, inf-ptrace.c, inf-ttrace.c, infcall.c: Update.
	* infcmd.c, inflow.c, infptrace.c, infrun.c, inftarg.c: Update.
	* interps.c, language.c, linespec.c, linux-nat.c: Update.
	* m32r-linux-nat.c, m68k-tdep.c, m68kbsd-nat.c: Update.
	* m68klinux-nat.c, m88kbsd-nat.c, macroexp.c, macroscope.c: Update.
	* macrotab.c, maint.c, mdebugread.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mips64obsd-nat.c: Update.
	* mipsnbsd-nat.c, mn10300-tdep.c, monitor.c, nto-procfs.c: Update.
	* objc-lang.c, objfiles.c, objfiles.h, ocd.c, osabi.c: Update.
	* parse.c, ppc-bdm.c, ppc-linux-nat.c, ppc-sysv-tdep.c: Update.
	* ppcnbsd-nat.c, ppcobsd-nat.c, printcmd.c, procfs.c: Update.
	* regcache.c, reggroups.c, remote-e7000.c, remote-mips.c: Update.
	* remote-rdp.c, remote-sds.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote.c, rs6000-nat.c, rs6000-tdep.c: Update.
	* s390-nat.c, s390-tdep.c, sentinel-frame.c, serial.c: Update.
	* sh-tdep.c, sh3-rom.c, sh64-tdep.c, shnbsd-nat.c: Update.
	* solib-aix5.c, solib-svr4.c, solib.c, source.c: Update.
	* sparc-nat.c, stabsread.c, stack.c, symfile.c, symtab.c: Update.
	* symtab.h, target.c, tracepoint.c, ui-file.c, ui-out.c: Update.
	* utils.c, valops.c, valprint.c, vax-nat.c, vaxbsd-nat.c: Update.
	* win32-nat.c, xcoffread.c, xstormy16-tdep.c: Update.
	* cli/cli-cmds.c, cli/cli-logging.c, cli/cli-script.c: Update.
	* cli/cli-setshow.c, mi/mi-cmd-break.c, mi/mi-cmds.c: Update.
	* mi/mi-console.c, mi/mi-getopt.c, mi/mi-out.c: Update.
	* tui/tui-file.c, tui/tui-interp.c: Update.
@
text
@d2318 1
a2318 1
	      printf_filtered ("Reading in symbols for %s...", pst->filename);
d2330 1
a2330 1
	    printf_filtered ("done.\n");
d2441 1
@


1.171
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d669 1
a669 1
	     "statement list doesn't fit in .debug_line section");
d675 1
a675 1
  complaint (&symfile_complaints, "location expression too complex");
d683 1
a683 1
	     "const value length mismatch for '%s', got %d, expected %d", arg1,
d691 1
a691 1
	     "macro info runs off end of `.debug_macinfo' section");
d698 1
a698 1
	     "macro debug info contains a malformed macro definition:\n`%s'",
d706 1
a706 1
	     "invalid attribute class or form for '%s' in '%s'", arg1, arg2);
d1285 1
a1285 1
		    "read_comp_unit_head: dwarf from non elf file");
d1822 1
a1822 1
		 "unhandled containing DIE tag %d for DIE at %d",
d2126 1
a2126 1
	complaint (&symfile_complaints, "malformed enumerator DIE ignored");
d2203 1
a2203 1
	    complaint (&symfile_complaints, "ignoring absolute DW_AT_sibling");
d3067 1
a3067 1
	                 "Offset %d out of bounds for DW_AT_ranges attribute",
d3119 1
a3119 1
			     "Invalid .debug_ranges data (no base address)");
d3475 1
a3475 1
	    complaint (&symfile_complaints, "unsupported accessibility %d",
d3584 1
a3584 1
    complaint (&symfile_complaints, "member function type missing for '%s'",
d3847 1
a3847 1
			       "virtual function table pointer not found when defining class '%s'",
d4401 1
a4401 1
	  complaint (&symfile_complaints, "invalid pointer size %d", byte_size);
d4707 1
a4707 1
	  complaint (&symfile_complaints, "unsupported DW_AT_encoding: '%s'",
d4754 1
a4754 1
                "DW_AT_type missing from DW_TAG_subrange_type");
d5222 1
a5222 1
	    complaint (&symfile_complaints, "malformed enumerator DIE ignored");
d5402 1
a5402 1
	    complaint (&symfile_complaints, "ignoring absolute DW_AT_sibling");
d5445 1
a5445 1
		    "could not find partial DIE in cache\n");
d5800 1
a5800 1
			  "read_address: bad switch, signed [in module %s]",
d5819 1
a5819 1
			  "read_address: bad switch, unsigned [in module %s]",
d5935 1
a5935 1
		      "read_offset: bad switch [in module %s]",
d6269 1
a6269 1
      complaint (&symfile_complaints, "missing .debug_line section");
d6351 1
a6351 1
	       "line number info header doesn't fit in `.debug_line' section");
d6397 1
a6397 1
	       "misplaced first line number at 0x%lx for '%s'",
d6529 1
a6529 1
			     "mangled .debug_line section");
d6985 1
a6985 1
	  complaint (&symfile_complaints, "unsupported tag: '%s'",
d7065 1
a7065 1
		 "unsupported const value attribute form: '%s'",
d7223 1
a7223 1
      complaint (&symfile_complaints, "unexepected tag in read_type_die: '%s'",
d8427 1
a8427 1
		 "unsupported die ref attribute form: '%s'",
d8449 1
a8449 1
      complaint (&symfile_complaints, "Attribute value is not a constant (%s)",
d8734 1
a8734 1
	  complaint (&symfile_complaints, "unsupported stack op: '%s'",
d8863 1
a8863 1
		 "macro definition contains spaces in formal argument list:\n`%s'",
d9025 1
a9025 1
      complaint (&symfile_complaints, "missing .debug_macinfo section");
d9068 1
a9068 1
			 "debug info gives macro %s outside of any file: %s",
d9102 1
a9102 1
		       "macro debug info has an unmatched `close_file' directive");
d9127 1
a9127 1
			       "no terminating 0-type entry for macros in `.debug_macinfo' section");
d9183 1
a9183 1
		   "Location list used without specifying the CU base address.");
@


1.170
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	* cli/cli-decode.c (add_setshow_enum_cmd, add_setshow_cmd_full)
	(add_setshow_auto_boolean_cmd, add_setshow_boolean_cmd)
	(add_setshow_filename_cmd, add_setshow_string_cmd)
	(add_setshow_uinteger_cmd, add_setshow_zinteger_cmd): Replace
	print string parameter with fprint_setshow function.
	* command.h (fprint_setshow_ftype): Define.  Update declarations.
	* cli/cli-setshow.c (do_setshow_command): When fprint_setshow is
	available, use that.
	* cli/cli-decode.h (struct cmd_list_element): Add field
	fprint_setshow.
	* complaints.c (fprint_setshow_complaints): New function.
	(_initialize_complaints): Pass to add_setshow_zinteger_cmd.
	* hppa-tdep.c (_initialize_hppa_tdep): Replace "print" parameter
	with NULL.
	* mips-tdep.c (_initialize_mips_tdep): Ditto.
	* m32r-rom.c (_initialize_m32r_rom): Ditto.
	* cris-tdep.c (_initialize_cris_tdep): Ditto.
	* arm-tdep.c (_initialize_arm_tdep): Ditto.
	* remote-rdi.c (_initialize_remote_rdi): Ditto.
	* alpha-tdep.c (_initialize_alpha_tdep): Ditto.
	* dwarf2read.c (_initialize_dwarf2_read): Ditto.
	* frame.c (_initialize_frame): Ditto.
	* target.c (initialize_targets): Ditto.
	* maint.c (_initialize_maint_cmds): Ditto.
	* observer.c (_initialize_observer): Ditto.
	* infcall.c (_initialize_infcall): Ditto.
	* breakpoint.c (_initialize_breakpoint): Ditto.
	* cli/cli-logging.c (_initialize_cli_logging): Ditto.
	* remote.c (add_packet_config_cmd, _initialize_remote): Ditto.
@
text
@d1299 2
a1300 2
    error ("Dwarf Error: wrong version in compilation unit header "
	   "(is %d, should be %d) [in module %s]", header->version,
d1304 2
a1305 2
    error ("Dwarf Error: bad offset (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 6) [in module %s]",
d1312 2
a1313 2
    error ("Dwarf Error: bad length (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 0) [in module %s]",
d2153 1
a2153 1
      error ("Dwarf Error: Could not find abbrev number %d [in module %s]", abbrev_number,
d2268 1
a2268 1
	  error ("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]",
d2312 1
a2312 1
	  warning ("bug: psymtab for %s is already read in.", pst->filename);
d4935 1
a4935 1
    error ("Dwarf Error: Can't read DWARF data from '%s'",
d5546 1
a5546 1
      error ("Dwarf Error: could not find abbrev number %d [in module %s]",
d5718 1
a5718 1
      error ("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]",
d5978 1
a5978 1
      error ("DW_FORM_strp used without .debug_str section [in module %s]",
d5984 1
a5984 1
      error ("DW_FORM_strp pointing outside of .debug_str section [in module %s]",
d7118 1
a7118 1
      error ("Dwarf Error: Problem turning type die at offset into gdb type [in module %s]",
d7144 1
a7144 1
      error ("Dwarf Error: Problem turning containing type into gdb type [in module %s]", 
d7163 1
a7163 1
	  error ("Dwarf Error: Cannot find type of die [in module %s]", 
d8487 2
a8488 2
  error ("Dwarf Error: Cannot find DIE at 0x%lx referenced from DIE "
	 "at 0x%lx [in module %s]",
d8500 1
a8500 1
      error ("Dwarf Error: internal error - invalid fundamental type id %d [in module %s]",
d9243 2
a9244 2
	error ("Dwarf Error: could not find partial DIE containing "
	       "offset 0x%lx [in module %s]",
d9255 1
a9255 1
	error ("invalid dwarf2 offset %ld", offset);
d9270 1
a9270 1
    error ("no compilation unit with offset %ld\n", offset);
@


1.169
log
@* dwarf2read.c: Fix formatting.
@
text
@d9655 1
a9655 2
			    "The upper bound on the age of cached "
			    "dwarf2 compilation units is %d.",
@


1.168
log
@* dwarf2read.c (struct comp_unit_head): Fix coding style.
(dwarf_decode_line_header): Likewise.
@
text
@d2 1
d1264 1
a1264 1
   info_ptr. */
d5842 4
a5845 4
   greater than 4GB.  If it becomes necessary to handle lengths somewhat
   larger than 4GB, we could allow other small values (such as the
   non-sensical values of 1, 2, and 3) to also be used as escape values
   indicating the presence of the old format.
d5847 2
a5848 2
   The value returned via bytes_read should be used to increment
   the relevant pointer after calling read_initial_length().
d5865 2
a5866 2
     determined empirically by examining 64-bit ELF files produced
     by the SGI toolchain on an IRIX 6.5 machine.
d5911 1
a5911 1
 return retval;
d5915 1
a5915 1
   given by cu_header->offset_size. */
d5939 1
a5939 1
 return retval;
@


1.167
log
@        * dwarf2read.c (set_cu_language): Set language to Ada for
        DW_LANG_Ada83 and DW_LANG_Ada95.
@
text
@d222 6
a227 9
  {
    unsigned long length;
    short version;
    unsigned int abbrev_offset;
    unsigned char addr_size;
    unsigned char signed_addr_p;
    unsigned int offset_size;	/* size of file offsets; either 4 or 8 */
    unsigned int initial_length_size; /* size of the length field; either
                                         4 or 12 */
d229 2
a230 2
    /* Offset to the first byte of this compilation unit header in the 
     * .debug_info section, for resolving relative reference dies. */
d232 2
a233 1
    unsigned int offset;
d235 3
a237 2
    /* Pointer to this compilation unit header in the .debug_info
     * section */
d239 7
a245 1
    char *cu_head_ptr;
d247 2
a248 2
    /* Pointer to the first die of this compilatio unit.  This will
     * be the first byte following the compilation unit header. */
d250 2
a251 1
    char *first_die_ptr;
d253 3
a255 12
    /* Pointer to the next compilation unit header in the program. */

    struct comp_unit_head *next;

    /* Base address of this compilation unit.  */

    CORE_ADDR base_address;

    /* Non-zero if base_address has been set.  */

    int base_known;
  };
d6272 2
a6273 2
  /* Make sure that at least there's room for the total_length field.  That
     could be 12 bytes long, but we're just going to fudge that.  */
d6287 1
a6287 1
  /* read in the header */
d6321 1
a6321 1
  /* Read directory table  */
d6329 1
a6329 1
  /* Read file name table */
d6457 1
d6465 1
a6465 1
      /* Decode the table. */
d6472 2
a6473 1
	    {		/* Special operand.  */
d6481 1
a6481 1
	          /* append row to matrix using current values */
d6550 3
a6552 3
                /* lh->include_dirs and lh->file_names are 0-based,
                   but the directory and file name numbers in the
                   statement program are 1-based.  */
d6555 1
d6579 3
a6581 3
	       255.  Ie, this value is scaled by the minimum instruction
	       length since special opcode 255 would have scaled the
	       the increment.  */
d6591 2
a6592 1
	      {  /* Unknown standard opcode, ignore it.  */
d6594 1
@


1.166
log
@	* dwarf2read.c (read_subroutine_type): Call make_function_type
	instead of lookup_function_type.
@
text
@d6097 2
@


1.165
log
@	* dwarf2read.c (REF_HASH_SIZE): Move earlier.
	(die_ref_table): Remove.
	(struct dwarf2_cu): Add DIES, DEPENDENCIES, and DIE_REF_TABLE.
	(struct dwarf2_per_cu_data): Add PSYMTAB.  Add a comment describing
	the usage of this type.
	(struct dwarf2_per_objfile): Update comment for ALL_COMP_UNITS.
	(struct dwarf2_pinfo, PST_PRIVATE, DWARF_INFO_OFFSET): Remove.
	(struct dwarf2_queue_item, dwarf2_queue, dwarf2_queue_tail): New.
	(dwarf2_create_include_psymtab): Update comment.
	(find_partial_die): Remove third argument.  Remove unreachable call
	to error ().
	(dwarf2_find_containing_comp_unit): Update comments.  Change one
	assertion to an error.  Remove an unreachable error.
	(dwarf2_find_comp_unit): Update comments.
	(type_at_offset): Remove dead code.
	(make_cleanup_free_die_list, dwarf2_empty_hash_tables): Remove.
	(store_in_ref_table): Add CU argument.
	(follow_die_ref): Take DIE, attribute, and CU arguments.  Handle
	inter-compilation-unit references.
	(load_full_comp_unit, process_full_comp_unit): New functions, based
	on psymtab_to_symtab_1.
	(psymtab_to_symtab_1): Use them.
	(dwarf2_add_dependence): New function.
	(dwarf2_build_psymtabs_hard): Set the psymtab in per_cu.  Always create
	a per_cu structure, and save it in READ_PSYMTAB_PRIVATE.
	(partial_die_parent_scope, guess_structure_name): Update for changes
	to find_partial_die.
	(dwarf2_psymtab_to_symtab): Initialize dwarf2_per_objfile here.
	(queue_comp_unit, process_queue, dwarf2_release_queue): New.
	(read_comp_unit): Don't call dwarf2_empty_hash_tables.
	(read_die_and_children): Update call to store_in_ref_table.
	(do_free_die_list_cleanup): Remove.
	(fixup_partial_die): Update for changes to find_partial_die.
	(read_full_die): Handle queueing absolute references.
	(read_attribute_value): Use DW_ADDR for all DW_FORM_ref* forms.
	(dwarf2_attr, die_specification, die_type)
	(die_containing_type, dwarf2_extension): Update calls to
	follow_die_ref.
	(dump_die): Update DW_FORM_ref* handling.
	(dwarf2_get_ref_die_offset): Likewise.
	(free_one_comp_unit): Release the dies list.
	(dwarf2_mark_helper): New function.
	(dwarf2_mark): Use it.
@
text
@d4572 1
a4572 1
  ftype = lookup_function_type (type);
@


1.164
log
@	* dwarf2read.c (read_subrange_type): Add comment for variable
	sized arrays.
@
text
@d172 2
a173 3
  /* A list of all the compilation units.  This will be set if and
     only if we have encountered a compilation unit with inter-CU
     references.  */
d260 5
d332 11
d357 6
d382 1
d384 2
a385 1
  htab_t type_hash;
a576 7
/* A hash table of die offsets for following references.  */
#ifndef REF_HASH_SIZE
#define REF_HASH_SIZE 1021
#endif

static struct die_info *die_ref_table[REF_HASH_SIZE];

a593 13
/* We put a pointer to this structure in the read_symtab_private field
   of the psymtab.  */

struct dwarf2_pinfo
  {
    /* Offset in .debug_info for this compilation unit. */

    unsigned long dwarf_info_offset;
  };

#define PST_PRIVATE(p) ((struct dwarf2_pinfo *)(p)->read_symtab_private)
#define DWARF_INFO_OFFSET(p) (PST_PRIVATE(p)->dwarf_info_offset)

d647 11
d772 1
a772 2
						  struct dwarf2_cu *,
						  struct dwarf2_cu **);
a859 4
#if 0
static struct type *type_at_offset (unsigned int, struct objfile *);
#endif

a955 2
static struct cleanup *make_cleanup_free_die_list (struct die_info *);

d989 2
a990 3
static void store_in_ref_table (unsigned int, struct die_info *);

static void dwarf2_empty_hash_tables (void);
d997 3
a999 1
static struct die_info *follow_die_ref (unsigned int);
a1055 1
#if 0
a1057 1
#endif
d1061 7
d1352 1
a1352 3
     the regular ones.  If it ever happens that a regular psymtab can
     legitimally have a NULL private part, then we'll have to add a
     dedicated field for that in the dwarf2_pinfo structure.  */
d1405 2
d1451 1
a1451 2
      if (cu.has_form_ref_addr && dwarf2_per_objfile->all_comp_units == NULL)
	create_all_comp_units (objfile);
d1471 2
a1472 3
      pst->read_symtab_private = (char *)
	obstack_alloc (&objfile->objfile_obstack, sizeof (struct dwarf2_pinfo));
      DWARF_INFO_OFFSET (pst) = beg_of_comp_unit - dwarf2_per_objfile->info_buffer;
d1478 16
a1493 16
      if (dwarf2_per_objfile->all_comp_units != NULL)
	{
	  struct dwarf2_per_cu_data *per_cu;

	  per_cu = dwarf2_find_comp_unit (cu.header.offset, objfile);

	  /* If this compilation unit was already read in, free the
	     cached copy in order to read it in again.  This is
	     necessary because we skipped some symbols when we first
	     read in the compilation unit (see load_partial_dies).
	     This problem could be avoided, but the benefit is
	     unclear.  */
	  if (per_cu->cu != NULL)
	    free_one_cached_comp_unit (per_cu->cu);

	  cu.per_cu = per_cu;
d1495 1
a1495 8
	  /* Note that this is a pointer to our stack frame, being
	     added to a global data structure.  It will be cleaned up
	     in free_stack_comp_unit when we finish with this
	     compilation unit.  */
	  per_cu->cu = &cu;
	}
      else
	cu.per_cu = NULL;
a1784 1
  struct dwarf2_cu *spec_cu;
a1789 1
  spec_cu = cu;
d1791 1
a1791 1
    real_pdi = find_partial_die (real_pdi->spec_offset, spec_cu, &spec_cu);
d1802 1
a1802 1
  grandparent_scope = partial_die_parent_scope (parent, spec_cu);
a2075 1
      struct dwarf2_cu *spec_cu;
a2081 1
      spec_cu = cu;
d2083 1
a2083 1
	real_pdi = find_partial_die (real_pdi->spec_offset, spec_cu, &spec_cu);
d2324 4
d2337 93
d2433 1
a2433 9
  struct objfile *objfile = pst->objfile;
  bfd *abfd = objfile->obfd;
  struct dwarf2_cu cu;
  struct die_info *dies;
  unsigned long offset;
  CORE_ADDR lowpc, highpc;
  struct die_info *child_die;
  char *info_ptr;
  struct symtab *symtab;
a2434 2
  struct attribute *attr;
  CORE_ADDR baseaddr;
d2454 3
a2456 1
  if (pst->read_symtab_private == NULL)
d2464 26
a2489 1
  dwarf2_per_objfile = objfile_data (pst->objfile, dwarf2_objfile_data_key);
d2492 1
a2492 1
  offset = DWARF_INFO_OFFSET (pst);
a2494 1
  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2496 2
a2497 6
  /* We're in the global namespace.  */
  processing_current_prefix = "";

  memset (&cu, 0, sizeof (struct dwarf2_cu));
  obstack_init (&cu.comp_unit_obstack);
  back_to = make_cleanup (free_stack_comp_unit, &cu);
d2499 2
a2500 2
  buildsym_init ();
  make_cleanup (really_free_pendings, NULL);
d2502 1
a2502 1
  cu.objfile = objfile;
d2505 1
a2505 1
  info_ptr = read_comp_unit_head (&cu.header, info_ptr, abfd);
d2508 10
a2517 2
  dwarf2_read_abbrevs (abfd, &cu);
  make_cleanup (dwarf2_free_abbrev_table, &cu);
d2519 1
a2519 1
  cu.header.offset = offset;
d2521 9
a2529 1
  cu.list_in_scope = &file_symbols;
d2531 1
a2531 1
  dies = read_comp_unit (info_ptr, abfd, &cu);
d2533 32
a2564 1
  make_cleanup_free_die_list (dies);
d2572 2
a2573 2
  cu.header.base_known = 0;
  cu.header.base_address = 0;
d2575 1
a2575 1
  attr = dwarf2_attr (dies, DW_AT_entry_pc, &cu);
d2578 2
a2579 2
      cu.header.base_address = DW_ADDR (attr);
      cu.header.base_known = 1;
d2583 1
a2583 1
      attr = dwarf2_attr (dies, DW_AT_low_pc, &cu);
d2586 2
a2587 2
	  cu.header.base_address = DW_ADDR (attr);
	  cu.header.base_known = 1;
d2592 1
a2592 1
  process_die (dies, &cu);
d2597 1
a2597 1
  get_scope_pc_bounds (dies, &lowpc, &highpc, &cu);
d2605 1
a2605 1
      && !(cu.language == language_c && symtab->language != language_c))
d2607 1
a2607 1
      symtab->language = cu.language;
a4816 4
  /* Reset die reference table; we are
     building new ones now.  */
  dwarf2_empty_hash_tables ();

d4837 1
a4837 1
  store_in_ref_table (die->offset, die);
a4915 13
static void
do_free_die_list_cleanup (void *dies)
{
  free_die_list (dies);
}

static struct cleanup *
make_cleanup_free_die_list (struct die_info *dies)
{
  return make_cleanup (do_free_die_list_cleanup, dies);
}


d5455 1
a5455 2
find_partial_die (unsigned long offset, struct dwarf2_cu *cu,
		  struct dwarf2_cu **target_cu)
d5461 1
a5461 4
    {
      *target_cu = cu;
      return find_partial_die_in_comp_unit (offset, cu);
    }
a5464 7
  /* If this offset isn't pointing into a known compilation unit,
     the debug information is probably corrupted.  */
  if (per_cu == NULL)
    error ("Dwarf Error: could not find partial DIE containing "
	   "offset 0x%lx [in module %s]",
	   (long) offset, bfd_get_filename (cu->objfile->obfd));

a5472 1
  *target_cu = per_cu->cu;
a5488 1
      struct dwarf2_cu *spec_cu;
d5490 1
a5490 1
      spec_die = find_partial_die (part_die->spec_offset, cu, &spec_cu);
d5492 1
a5492 1
      fixup_partial_die (spec_die, spec_cu);
d5566 32
d5694 1
a5694 1
      DW_UNSND (attr) = read_1_byte (abfd, info_ptr);
d5698 1
a5698 1
      DW_UNSND (attr) = read_2_bytes (abfd, info_ptr);
d5702 1
a5702 1
      DW_UNSND (attr) = read_4_bytes (abfd, info_ptr);
d5706 1
a5706 1
      DW_UNSND (attr) = read_8_bytes (abfd, info_ptr);
d5710 2
a5711 1
      DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
d6119 1
a6119 3
	{
	  return &die->attrs[i];
	}
d6124 1
d6126 1
a6126 7
    {
      struct die_info *ref_die =
      follow_die_ref (dwarf2_get_ref_die_offset (spec, cu));

      if (ref_die)
	return dwarf2_attr (ref_die, name, cu);
    }
d6168 1
a6168 1
    return follow_die_ref (dwarf2_get_ref_die_offset (spec_attr, cu));
a7098 1
  unsigned int ref;
d7107 2
a7108 10
    {
      ref = dwarf2_get_ref_die_offset (type_attr, cu);
      type_die = follow_die_ref (ref);
      if (!type_die)
	{
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", 
			  ref, cu->objfile->name);
	  return NULL;
	}
    }
a7127 1
  unsigned int ref;
d7132 1
a7132 8
      ref = dwarf2_get_ref_die_offset (type_attr, cu);
      type_die = follow_die_ref (ref);
      if (!type_die)
	{
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", ref, 
			  cu->objfile->name);
	  return NULL;
	}
a7144 18
#if 0
static struct type *
type_at_offset (unsigned int offset, struct dwarf2_cu *cu)
{
  struct die_info *die;
  struct type *type;

  die = follow_die_ref (offset);
  if (!die)
    {
      error ("Dwarf Error: Cannot find type referent at offset %d.", offset);
      return NULL;
    }
  type = tag_type_to_type (die, cu);
  return type;
}
#endif

a7497 2
  struct die_info *extension_die;
  unsigned int ref;
d7503 1
a7503 8
  ref = dwarf2_get_ref_die_offset (attr, cu);
  extension_die = follow_die_ref (ref);
  if (!extension_die)
    {
      error ("Dwarf Error: Cannot find referent at offset %d.", ref);
    }

  return extension_die;
d8340 6
a8349 3
	case DW_FORM_ref1:
	case DW_FORM_ref2:
	case DW_FORM_ref4:
d8393 2
a8394 1
store_in_ref_table (unsigned int offset, struct die_info *die)
d8400 1
a8400 1
  old = die_ref_table[h];
d8402 1
a8402 8
  die_ref_table[h] = die;
}


static void
dwarf2_empty_hash_tables (void)
{
  memset (die_ref_table, 0, sizeof (die_ref_table));
a8412 2
      result = DW_ADDR (attr);
      break;
d8418 1
a8418 1
      result = cu->header.offset + DW_UNSND (attr);
d8451 2
a8452 1
follow_die_ref (unsigned int offset)
d8455 1
d8457 15
d8474 1
a8474 1
  die = die_ref_table[h];
d8478 1
a8478 3
	{
	  return die;
	}
d8481 5
d9215 1
a9215 1
   DIE at OFFSET.  Returns NULL on failure.  */
a9223 5
  if (dwarf2_per_objfile->all_comp_units == NULL)
    error ("Dwarf Error: offset 0x%lx points outside this "
	   "compilation unit [in module %s]",
	   offset, bfd_get_filename (objfile->obfd));

d9237 5
a9241 1
      gdb_assert (low > 0);
d9256 3
d9283 2
a9464 2
#if 0

d9500 22
a9521 1
#endif
d9526 16
d9548 2
@


1.163
log
@	* dwarf2read.c (struct dwarf2_per_cu_data): New field type_hash.
	(struct dwarf2_offset_and_type): New.
	(set_die_type, reset_die_and_siblings_types, get_die_type)
	(offset_and_type_hash, offset_and_type_eq): New functions.
	(read_structure_type, read_enumeration_type, read_array_type)
	(read_namespace, read_tag_pointer_type, read_tag_ptr_to_member_type)
	(read_tag_reference_type, read_tag_const_type)
	(read_tag_volatile_type, read_tag_string_type, read_subroutine_type)
	(read_typedef, read_base_type, read_subrange_type): Use
	set_die_type.
@
text
@d4613 3
@


1.162
log
@gdb/doc/
	* gdb.texinfo (Maintenance Commands): Document "maint set dwarf2
	max-cache-age" and "maint show dwarf2 max-cache-age".
gdb/
	* Makefile.in (dwarf2read.o): Update dependencies.
	* dwarf2read.c: Include "command.h" and "gdbcmd.h".
	(struct dwarf2_per_objfile): Add all_comp_units, n_comp_units,
	and read_in_chain.
	(struct dwarf2_cu): Add read_in_chain, per_cu, last_used,
	mark, and has_form_ref_addr.
	(struct dwarf2_per_cu_data): New.
	(dwarf2_max_cache_age): New.
	(dwarf2_build_psymtabs_hard): Free cached compilation units
	after loading.  Create and manage the list of compilation units.
	Remove unnecessary NULL initialization.  Fix indentation.
	(psymtab_to_symtab_1): Initialize all of CU.
	(dwarf2_read_abbrevs): Set has_form_ref_addr.
	(find_partial_die): Use dwarf2_find_containing_comp_unit
	and load_comp_unit.
	(free_stack_comp_unit): Update comments.  Clear the per-cu
	pointer.  Handle aging.
	(dwarf2_find_containing_comp_unit, free_cached_comp_units)
	(age_cached_comp_units, free_one_cached_comp_unit)
	(dwarf2_mark, dwarf2_clear_marks, create_all_comp_units)
	(load_comp_unit, dwarf2_find_comp_unit, free_one_comp_unit)
	(set_dwarf2_cmdlist, show_dwarf2_cmdlist, set_dwarf2_cmd)
	(show_dwarf2_cmd): New.
	(_initialize_dwarf2_read): Provide "maint set dwarf2 max-cache-age"
	and "maint show dwarf2 max-cache-age".
	* gdbcmd.h (maintenance_set_cmdlist, maintenance_show_cmdlist): New
	externs.
	* maint.c (maintenance_set_cmdlist, maintenance_show_cmdlist): Make
	global.
@
text
@d356 7
d1045 8
d3618 1
a3618 1
  die->type = type;
d3794 1
a3794 1
  die->type = type;
d3960 2
a3961 1
      die->type = create_array_type (NULL, element_type, range_type);
d4021 1
a4021 1
  die->type = type;
d4148 1
a4148 1
      die->type = type;
d4255 1
a4255 1
  die->type = type;
d4279 1
a4279 1
  die->type = type;
d4307 1
a4307 1
  die->type = type;
d4321 2
a4322 1
  die->type = make_cv_type (1, TYPE_VOLATILE (base_type), base_type, 0);
d4336 2
a4337 1
  die->type = make_cv_type (TYPE_CONST (base_type), 1, base_type, 0);
d4389 1
a4389 1
  die->type = type;
d4471 1
a4471 1
  die->type = ftype;
d4488 3
a4490 1
      die->type = init_type (TYPE_CODE_TYPEDEF, 0, TYPE_FLAG_TARGET_STUB, name, objfile);
d4578 1
a4578 1
  die->type = type;
d4649 1
a4649 1
  die->type = range_type;
d9275 99
@


1.161
log
@
2004-09-20  Jeff Johnston  <jjohnstn@@redhat.com>

        * dwarf2read.c (typename_concat): Change prototype to accept obstack
        and dwarf2_cu struct pointer as arguments.  Change function to use
        obstack if provided and use dwarf2_cu to determine language-specific
        separator.
        (partial_die_parent_scope): Change comment to include java.  Use
        new version of typename_concat instead of obconcat.
        (partial_die_full_name): Use typename_concat.
        (read_namespace): Ditto.
        (read_enumeration_type): Use typename_concat instead of obconcat.
        (new_symbol): Ditto.
        (add_partial_symbol): Enhance tests for C++ to also test for Java.
        (guess_structure_name): Ditto.
        (read_subroutine_type): Ditto.
        (read_structure_type): Ditto.
        (is_vtable_name): Add Java support.
        (determine_class_name): Switch to new typename_concat call.
        (determine_prefix): Switch to new typename_concat call.
        * jv-exp.y (FuncStart): New pattern.
        (MethodInvocation): Add support for simple function calls.  Change
        warning message for other forms of inferior call currently not
        supported.
        * valarith.c (value_subscript): Treat an array with upper-bound
        of -1 as unknown size.
@
text
@d48 2
d171 12
d316 19
d342 16
d637 7
d1024 20
d1370 1
d1375 4
a1418 2
      cu.partial_dies = NULL;

d1423 3
d1441 2
a1442 2
	  if (comp_unit_die.dirname)
        pst->dirname = xstrdup (comp_unit_die.dirname);
d1452 26
d1531 116
d2371 1
d4842 11
d5305 19
a5323 2
  internal_error (__FILE__, __LINE__,
		  "unsupported inter-compilation-unit reference");
d9068 71
d9140 3
a9142 2
   when we're finished with it.  We can't free the pointer itself, but
   release any associated storage.
d9153 121
d9319 15
d9340 28
@


1.160
log
@* dwarf2read.c (is_vtable_name): New function, based on logic from
read_structure_type, but passing the correct length to strncmp,
and using 'sizeof' instead of 'strlen'.
(read_structure_type): Call it.
@
text
@d794 2
a795 1
static char *typename_concat (const char *prefix, const char *suffix);
d1515 2
a1516 1
   name is concatenated with "::" and the partial DIE's name.
d1571 2
a1572 2
	parent->scope = obconcat (&cu->comp_unit_obstack, grandparent_scope,
				  "::", parent->name);
d1604 1
a1604 1
    return concat (parent_scope, "::", pdi->name, NULL);
d1722 2
a1723 1
			   cu->language == language_cplus
d1728 2
a1729 1
      if (cu->language == language_cplus)
d1731 1
a1731 1
	  /* For C++, these implicitly act as typedefs as well. */
d1741 2
a1742 1
			   cu->language == language_cplus
d1822 2
a1823 1
  if (cu->language == language_cplus
d2483 2
a2484 1
  if (cu->language == language_cplus)
d3282 1
d3284 5
a3288 3
  /* C++ and some implementations of Java use this name.  */
  if (strncmp (name, vptr, sizeof (vptr) - 1) == 0
      && is_cplus_marker (name[sizeof (vptr) - 1]))
d3329 2
a3330 1
      if (cu->language == language_cplus)
d3532 3
a3534 5
	  TYPE_TAG_NAME (type) = obconcat (&objfile->objfile_obstack,
					   processing_current_prefix,
					   processing_current_prefix[0] == '\0'
					   ? "" : "::",
					   name);
d3558 1
a3558 1
   a named C++ compound type.  Return the name in question; the caller
d3605 3
a3607 2
      new_prefix = typename_concat (processing_current_prefix,
				    name ? name : "<<anonymous>>");
d3874 1
d3886 2
a3887 8
      /* We need temp_name around because processing_current_prefix
	 is a const char *.  */
      char *temp_name = alloca (strlen (previous_prefix)
				+ 2 + strlen(name) + 1);
      strcpy (temp_name, previous_prefix);
      strcat (temp_name, "::");
      strcat (temp_name, name);

d3927 1
d4175 1
a4175 1
  /* All functions in C++ have prototypes.  */
d4178 2
a4179 1
      || cu->language == language_cplus)
d4830 2
a4831 1
				 cu->language == language_cplus
d6442 2
a6443 1
	  if (cu->language == language_cplus)
d6460 1
a6460 1
	    /* NOTE: carlton/2003-11-10: C++ class symbols shouldn't
d6471 2
a6472 1
			   && cu->language == language_cplus
d6478 5
a6482 3
	       defines a typedef for "foo". Synthesize a typedef symbol so
	       that "ptype foo" works as expected.  */
	    if (cu->language == language_cplus)
d6502 3
a6504 4
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->objfile_obstack,
						    processing_current_prefix,
						    "::",
						    name);
d6520 3
a6522 4
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->objfile_obstack,
						    processing_current_prefix,
						    "::",
						    name);
d6536 2
a6537 1
			   && cu->language == language_cplus
d6846 2
a6847 1
  if (cu->language != language_cplus)
d6871 1
a6871 1
	      char *retval = typename_concat (parent_prefix,
d6873 2
a6874 1
							      cu));
d6907 7
a6913 3
/* Return a newly-allocated string formed by concatenating PREFIX,
   "::", and SUFFIX, except that if PREFIX is NULL or the empty
   string, just return a copy of SUFFIX.  */
d6916 2
a6917 1
typename_concat (const char *prefix, const char *suffix)
d6919 6
a6924 2
  if (prefix == NULL || prefix[0] == '\0')
    return xstrdup (suffix);
d6926 3
d6930 11
a6940 6
      char *retval = xmalloc (strlen (prefix) + 2 + strlen (suffix) + 1);

      strcpy (retval, prefix);
      strcat (retval, "::");
      strcat (retval, suffix);

d6943 5
@


1.159
log
@2004-08-29  David Lecomber  <david@@streamline-computing.com>

	Fix PR gdb/648
	* language.h (enum array_ordering): New enum.
	* language.h (struct language_defn): New la_array_ordering
	attribute.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Ditto.
	* ada-lang.c (ada_language_defn): Ditto.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Ditto.
	* f-lang.c (f_language_defn): Ditto.
	* jv-lang.c (java_language_defn): Ditto.
	* m2-lang.c (f_language_defn): Ditto.
	* objc-lang.c (objc_language_defn): Ditto.
	* p-lang.c (pascal_language_defn): Ditto.
	* scm-lang.c (scm_language_defn): Ditto.
	* eval.c (evaluate_subexp_standard): Assume Fortran arrays are
	oriented large to small in type structure.
	* dwarf2read.c (read_array_order): New function.
	(read_array_type): Use read_array_order to check row/column
	major ordering.
@
text
@d3268 17
a3422 2
		  static const char vptr_name[] =
		  {'_', 'v', 'p', 't', 'r', '\0'};
d3432 1
a3432 4
		      if ((strncmp (fieldname, vptr_name,
                                    strlen (vptr_name) - 1)
                           == 0)
			  && is_cplus_marker (fieldname[strlen (vptr_name)]))
@


1.158
log
@        * dwarf2read.c (dwarf_decode_lines): Do not consider the current
        file as included until we record the first line in the linetable.
@
text
@d851 3
d3730 1
d3732 12
a3743 2
  while (ndim-- > 0)
    type = create_array_type (NULL, type, range_types[ndim]);
d3761 35
@


1.157
log
@2004-07-30  David Lecomber  <dsl@@sources.redhat.com>

	* dwarf2read.c (read_file_scope): Set producer if attribute
	present.
	(struct dwarf2_cu): Added new member producer.
@
text
@d5980 1
d6000 1
d6035 1
a6059 1
                fe->included_p = 1;
@


1.156
log
@
2004-07-06  Jeff Johnston <jjohnstn@@redhat.com>

        * language.h (struct_language_defn): Add new function pointer:
        la_class_name_from_physname.  Also add new prototype for
        language_class_name_from_physname.
        * language.c (language_class_name_from_physname): New function.
        (unk_lang_class_name): Ditto.
        (unknown_language_defn, auto_language_defn): Change
        to add unk_lang_class_name function pointer for
        la_class_name_from_physname.
        (local_language_defn): Ditto.
        * dwarf2read.c (guess_structure_name): Change to call
        language_class_name_from_physname.
        (determine_class_name): Ditto.
        * cp-support.c (class_name_from_physname): Renamed.
        (cp_class_name_from_physname): New name of function.
        * cp-support.h: Ditto.
        * c-lang.c (c_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        (cplus_language_defn): Change to add cp_class_name_from_physname.
        * jv-lang.c (java_class_name_physname): New function.
        (java_find_last_component): New static routine.
        (java_language_defn): Add java_class_name_from_physname pointer.
        * ada-lang.c (ada_language_defn): Change to add NULL
        for class_name_from_physname function pointer.
        * f-lang.c (f_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * scm-lang.c (scm_language_defn): Ditto.
@
text
@d265 2
d2367 4
@


1.155
log
@2004-06-24  Andrew Cagney  <cagney@@gnu.org>

	* objfiles.h (struct entry_info): Delete entry_func_lowpc and
	entry_func_highpc fields.
	* objfiles.c (init_entry_point_info): Do not clear
	entry_func_lowpc and entry_func_highpc.
	(objfile_relocate): Do not relocate entry_func_lowpc and
	entry_func_highpc.
	* dwarfread.c (read_func_scope): Do not set entry_func_lowpc and
	entry_func_highpc.
	* dwarf2read.c (read_func_scope): Do not set entry_func_lowpc and
	entry_func_highpc.
	* blockframe.c (legacy_frame_chain_valid): Replace tests against
	entry_func_lowpc and entry_func_highpc with call to
	inside_entry_func.
@
text
@d1843 2
a1844 1
		= class_name_from_physname (child_pdi->name);
d3561 3
a3563 1
	      new_prefix = class_name_from_physname (dwarf2_linkage_name
@


1.154
log
@	PR gdb/1658
	* dwarf2read.c (dwarf_decode_lines): Read the length of the extended
	operation as a uleb128.  Found by Michael Coulter.
@
text
@a2506 7
  if (objfile->ei.entry_point >= lowpc &&
      objfile->ei.entry_point < highpc)
    {
      objfile->ei.entry_func_lowpc = lowpc;
      objfile->ei.entry_func_highpc = highpc;
    }

@


1.153
log
@	* dsrec.c (load_srec, make_srec): Use bfd_get_section_size instead of
	bfd_get_section_size_before_reloc or _raw_size.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2read.c (dwarf2_locate_sections): Likewise.
	(dwarf2_read_section): Likewise.
	* elfread.c (elf_locate_sections): Likewise.
	* gcore.c (derive_heap_segment): Likewise.
	* mipsread.c (read_alphacoff_dynamic_symtab): Likewise.
	* remote-e7000.c (e7000_load): Likewise.
	* remote-m32r-sdi.c (m32r_load): Likewise.
	* remote-mips.c (mips_load_srec): Likewise.
	(pmon_load_fast): Likewise.
	* remote.c (compare_sections_command): Likewise.
	* symfile.c (add_section_size_callback): Likewise.
	(load_section_callback): Likewise.
	(pc_in_unmapped_range): Likewise.
	(pc_in_mapped_range): Likewise.
	(sections_overlap): Likewise.
	(list_overlays_command): Likewise.
	(simple_overlay_update_1): Likewise.
	(simple_overlay_update): Likewise.
	* tracepoint.c (remote_set_transparent_ranges): Likewise.
	* win32-nat.c (core_section_load_dll_symbols): Likewise.
@
text
@d5989 2
a5990 1
	      line_ptr += 1;	/* ignore length */
@


1.152
log
@Add the -file-list-exec-source-files command to MI.
@
text
@d999 1
a999 1
      dwarf2_per_objfile->info_size = bfd_get_section_size_before_reloc (sectp);
d1004 1
a1004 1
      dwarf2_per_objfile->abbrev_size = bfd_get_section_size_before_reloc (sectp);
d1009 1
a1009 1
      dwarf2_per_objfile->line_size = bfd_get_section_size_before_reloc (sectp);
d1014 1
a1014 1
      dwarf2_per_objfile->pubnames_size = bfd_get_section_size_before_reloc (sectp);
d1019 1
a1019 1
      dwarf2_per_objfile->aranges_size = bfd_get_section_size_before_reloc (sectp);
d1024 1
a1024 1
      dwarf2_per_objfile->loc_size = bfd_get_section_size_before_reloc (sectp);
d1029 1
a1029 1
      dwarf2_per_objfile->macinfo_size = bfd_get_section_size_before_reloc (sectp);
d1034 1
a1034 1
      dwarf2_per_objfile->str_size = bfd_get_section_size_before_reloc (sectp);
d1039 1
a1039 1
      dwarf2_per_objfile->frame_size = bfd_get_section_size_before_reloc (sectp);
d1047 1
a1047 1
          dwarf2_per_objfile->eh_frame_size = bfd_get_section_size_before_reloc (sectp);
d1053 1
a1053 1
      dwarf2_per_objfile->ranges_size = bfd_get_section_size_before_reloc (sectp);
d4467 1
a4467 1
  bfd_size_type size = bfd_get_section_size_before_reloc (sectp);
@


1.151
log
@2004-05-07  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Delete unused fields
	deprecated_entry_file_lowpc and deprecated_entry_file_highpc.
	* objfiles.c (init_entry_point_info, objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab, read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d383 1
d1353 3
d4882 4
@


1.150
log
@        * dwarf2read.c (dwarf2_create_include_psymtab): Fix build
        failure detected by recent versions of GCC.
        (psymtab_to_symtab_1): No longer use the PST_PRIVATE macro
        to be consistent with the usage in dwarf2_create_include_psymtab.
@
text
@a2353 7
  if (objfile->ei.entry_point >= lowpc &&
      objfile->ei.entry_point < highpc)
    {
      objfile->ei.deprecated_entry_file_lowpc = lowpc;
      objfile->ei.deprecated_entry_file_highpc = highpc;
    }

@


1.149
log
@        * dwarf2read.c (line_header): Add new included_p field in
        field file_names.
        (partial_die_info): New field has_stmt_list. New field line_offset.
        (dwarf2_create_include_psymtab): New function.
        (dwarf2_build_include_psymtabs): New function.
        (add_file_name): Add forward declaration. Initialize new field.
        (dwarf_decode_lines): Add new parameter. Enhance this procedure
        to be able to determine the list of files included by the
        given unit, and build their associated psymtabs.
        (dwarf2_build_psymtabs_hard): Build the psymtabs for the included
        files as well.
        (psymtab_to_symtab_1): Build the symtabs of all dependencies as well.
        (read_file_scope): Update call to dwarf_decode_lines.
        (read_partial_die): Handle DW_AT_stmt_list attributes.
@
text
@d1242 1
a1242 1
     legitimally have a NULL PST_PRIVATE part, then we'll have to add a
d1244 1
a1244 1
  PST_PRIVATE (subpst) = NULL;
d2112 1
a2112 1
  if (PST_PRIVATE (pst) == NULL)
@


1.148
log
@	* dwarf2read.c (dwarf2_tmp_obstack, dwarf2_free_tmp_obstack):
	Delete.
	(dwarf_alloc_block): Take a CU argument.  Use the comp_unit_obstack.
	(read_attribute_value): Update calls to dwarf_alloc_block.
	(dwarf2_build_psymtabs_hard): Don't initialize or clean up
	dwarf2_tmp_obstack.
	(psymtab_to_symtab_1): Likewise.  Clean up using
	free_stack_comp_unit.
	(add_to_cu_func_list): Use the comp_unit_obstack.
@
text
@d344 1
d372 1
d405 3
d639 7
d754 3
d762 1
a762 1
				struct dwarf2_cu *);
d1212 62
d1401 7
d2093 26
d2407 1
a2407 1
          dwarf_decode_lines (line_header, comp_dir, abfd, cu);
d4939 4
d5745 1
d5903 17
a5919 3
/* Decode the line number information for the compilation unit whose
   line number info is at OFFSET in the .debug_line section.
   The compilation directory of the file is passed in COMP_DIR.  */
d5923 1
a5923 1
		    struct dwarf2_cu *cu)
d5931 1
d5950 1
a5950 2
      /* Start a subfile for the current file of the state machine.  */
      if (lh->num_file_names >= file)
d5952 1
d5977 6
a5982 3
	      /* append row to matrix using current values */
	      record_line (current_subfile, line, 
	                   check_cu_functions (address, cu));
d5995 2
a5996 1
		  record_line (current_subfile, 0, address);
d6029 3
a6031 2
	      record_line (current_subfile, line, 
	                   check_cu_functions (address, cu));
d6053 1
d6058 2
a6059 1
                dwarf2_start_subfile (fe->name, dir);
d6096 16
@


1.147
log
@        * dwarf2read.c (dwarf2_flag_true_p): New function.
        (die_is_declaration): Use the function above. Add some comments.
@
text
@a496 3
/* Obstack for allocating temporary storage used during symbol reading.  */
static struct obstack dwarf2_tmp_obstack;

d913 1
a913 3
static void dwarf2_free_tmp_obstack (void *);

static struct dwarf_block *dwarf_alloc_block (void);
a1209 1
  struct cleanup *back_to;
a1213 31
  /* We use dwarf2_tmp_obstack for objects that don't need to survive
     the partial symbol scan, like attribute values.

     We could reduce our peak memory consumption during partial symbol
     table construction by freeing stuff from this obstack more often
     --- say, after processing each compilation unit, or each die ---
     but it turns out that this saves almost nothing.  For an
     executable with 11Mb of Dwarf 2 data, I found about 64k allocated
     on dwarf2_tmp_obstack.  Some investigation showed:

     1) 69% of the attributes used forms DW_FORM_addr, DW_FORM_data*,
        DW_FORM_flag, DW_FORM_[su]data, and DW_FORM_ref*.  These are
        all fixed-length values not requiring dynamic allocation.

     2) 30% of the attributes used the form DW_FORM_string.  For
        DW_FORM_string, read_attribute simply hands back a pointer to
        the null-terminated string in info_buffer, so no dynamic
        allocation is needed there either.

     3) The remaining 1% of the attributes all used DW_FORM_block1.
        75% of those were DW_AT_frame_base location lists for
        functions; the rest were DW_AT_location attributes, probably
        for the global variables.

     Anyway, what this all means is that the memory the dwarf2
     reader uses as temporary space reading partial symbols is about
     0.5% as much as we use for dwarf_*_buffer.  That's noise.  */

  obstack_init (&dwarf2_tmp_obstack);
  back_to = make_cleanup (dwarf2_free_tmp_obstack, NULL);

a1328 1
  do_cleanups (back_to);
d2021 2
a2022 2
  obstack_init (&dwarf2_tmp_obstack);
  back_to = make_cleanup (dwarf2_free_tmp_obstack, NULL);
d2322 1
a2322 1
    obstack_alloc (&dwarf2_tmp_obstack, sizeof (struct function_range));
d5005 1
a5005 1
      blk = dwarf_alloc_block ();
d5013 1
a5013 1
      blk = dwarf_alloc_block ();
d5042 1
a5042 1
      blk = dwarf_alloc_block ();
d5050 1
a5050 1
      blk = dwarf_alloc_block ();
a8084 6
static void
dwarf2_free_tmp_obstack (void *ignore)
{
  obstack_free (&dwarf2_tmp_obstack, NULL);
}

d8086 1
a8086 1
dwarf_alloc_block (void)
d8091 1
a8091 1
    obstack_alloc (&dwarf2_tmp_obstack, sizeof (struct dwarf_block));
@


1.146
log
@        * dwarf2read.c: Back out my previous change, it was incorrect.
@
text
@d735 3
d5555 12
d5570 9
a5578 2
  return (dwarf2_attr (die, DW_AT_declaration, cu)
	  && ! dwarf2_attr (die, DW_AT_specification, cu));
@


1.145
log
@	* dwarf2read.c: Include "hashtab.h".
	(struct dwarf2_cu): Add partial_dies, comp_unit_obstack,
	has_namespace_info.
	(struct partial_die_info): Add comments.  Use bitfields to reduce
	memory footprint.  Add scope, scope_set, has_specification,
	spec_offset, die_parent, die_child, and die_sibling.
	(peek_die_abbrev): Add prototype.
	(partial_read_comp_unit_head): New function, broken out from
	dwarf2_build_psymtabs_hard.
	(dwarf2_build_psymtabs_hard): Remove unused variable abbrev_ptr.
	Use partial_read_comp_unit_head.  Initialize the CU and
	comp_unit_obstack.  Update calls to read_partial_die and
	scan_partial_symbols.  Use free_stack_comp_unit and
	load_partial_dies.
	(scan_partial_symbols): Change PDI to a pointer.  Use the child and
	sibling pointers to walk partial DIEs.  Call fixup_partial_die.
	Update calls to helper functions.  Remove NAMESPACE argument.
	Update comments.
	(partial_die_parent_scope, partial_die_full_name): New functions.
	(add_partial_symbol): Remove namespace argument.  Update call to
	pdi_needs_namespace.  Use partial_die_full_name.  Handle
	DW_TAG_namespace.  Check has_namespace_info flag.
	(pdi_needs_namespace): Remove NAMESPACE argument.  Just check the
	tag.  Handle namespaces.
	(add_partial_namespace, add_partial_enumeration): Simplify.
	(guess_structure_name): New function, derived from
	add_partial_structure.
	(add_partial_structure): Remove.
	(determine_class_name): Update comment.
	(dwarf2_read_abbrevs): Set has_namespace_info flag.
	(is_type_tag_for_partial, load_partial_dies): New functions.
	(read_partial_die): Pass abbrev and abbrev_len as arguments.
	Record specifications instead of following them immediately.
	(find_partial_die_in_comp_unit, find_partial_die)
	(fixup_partial_die, free_stack_comp_unit)
	(hashtab_obstack_allocate, dummy_obstack_deallocate)
	(partial_die_hash, partial_die_eq): New functions.
	* Makefile.in (hashtab_h): Define.
	(dwarf2read.o): Update dependencies.
	(observer_inc, observer_h): Move to the correct section.
@
text
@a734 3
static int dwarf2_attribute_true_p (struct die_info *die, unsigned name,
                                    struct dwarf2_cu *cu);

a5551 12
/* Return non-zero iff the attribute NAME is defined for the given DIE,
   and holds a non-zero value.  */

static int
dwarf2_attribute_true_p (struct die_info *die, unsigned name,
                         struct dwarf2_cu *cu)
{
  struct attribute *attr = dwarf2_attr (die, name, cu);

  return (attr && DW_UNSND (attr));
}

d5555 2
a5556 7
  /* A DIE is a declaration if it has a DW_AT_declaration attribute
     which value is non-zero.  However, we have to be careful of DIEs
     with a DW_AT_specification attribute, because dwarf2_attribute_p()
     follows this attribute, and therefore might cause us to find a
     DW_AT_declaration attribute, but that belongs to a different DIE.  */
  return (dwarf2_attribute_true_p (die, DW_AT_declaration, cu)
	  && ! dwarf2_attribute_true_p (die, DW_AT_specification, cu));
@


1.144
log
@        * dwarf2read.c (dwarf2_attribute_true_p): New function.
        (die_is_declaration): Use the function above.
@
text
@d47 1
d292 13
d355 1
a355 5
    enum dwarf_tag tag;
    unsigned char has_children;
    unsigned char is_external;
    unsigned char is_declaration;
    unsigned char has_type;
d357 23
a379 1
    unsigned int abbrev;
d381 10
a390 1
    int has_pc_info;
d393 3
a395 2
    struct dwarf_block *locdesc;
    unsigned int language;
d397 9
d639 15
a653 24
static char *scan_partial_symbols (char *, CORE_ADDR *, CORE_ADDR *,
				   struct dwarf2_cu *,
				   const char *namespace);

static void add_partial_symbol (struct partial_die_info *, struct dwarf2_cu *,
				const char *namespace);

static int pdi_needs_namespace (enum dwarf_tag tag, const char *namespace);

static char *add_partial_namespace (struct partial_die_info *pdi,
				    char *info_ptr,
				    CORE_ADDR *lowpc, CORE_ADDR *highpc,
				    struct dwarf2_cu *cu,
				    const char *namespace);

static char *add_partial_structure (struct partial_die_info *struct_pdi,
				    char *info_ptr,
				    struct dwarf2_cu *cu,
				    const char *namespace);

static char *add_partial_enumeration (struct partial_die_info *enum_pdi,
				      char *info_ptr,
				      struct dwarf2_cu *cu,
				      const char *namespace);
d670 2
d675 3
d679 1
d682 7
d941 10
d1171 31
d1211 1
a1211 1
  char *info_ptr, *abbrev_ptr;
a1218 1
  abbrev_ptr = dwarf2_per_objfile->abbrev_buffer;
d1253 1
a1253 1
     read_comp_unit_head and read_partial_die) can really know whether
d1269 4
d1275 6
d1282 1
a1282 1
      info_ptr = read_comp_unit_head (&cu.header, info_ptr, abfd);
a1283 22
      if (cu.header.version != 2)
	{
	  error ("Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]", cu.header.version, 2, bfd_get_filename (abfd));
	  return;
	}
      if (cu.header.abbrev_offset >= dwarf2_per_objfile->abbrev_size)
	{
	  error ("Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6) [in module %s]",
		 (long) cu.header.abbrev_offset,
		 (long) (beg_of_comp_unit - dwarf2_per_objfile->info_buffer),
		 bfd_get_filename (abfd));
	  return;
	}
      if (beg_of_comp_unit + cu.header.length + cu.header.initial_length_size
	  > dwarf2_per_objfile->info_buffer + dwarf2_per_objfile->info_size)
	{
	  error ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0) [in module %s]",
		 (long) cu.header.length,
		 (long) (beg_of_comp_unit - dwarf2_per_objfile->info_buffer),
		 bfd_get_filename (abfd));
	  return;
	}
d1291 2
d1295 1
a1295 1
      back_to_inner = make_cleanup (dwarf2_free_abbrev_table, &cu);
d1298 3
a1300 2
      info_ptr = read_partial_die (&comp_unit_die, abfd, info_ptr,
				   &cu);
d1325 2
d1330 3
a1332 2
	  info_ptr = scan_partial_symbols (info_ptr, &lowpc, &highpc,
					   &cu, NULL);
d1338 1
a1338 1
	  
d1361 1
a1361 1
      info_ptr = beg_of_comp_unit + cu.header.length 
d1369 3
a1371 6
/* Read in all interesting dies to the end of the compilation unit or
   to the end of the current namespace.  NAMESPACE is NULL if we
   haven't yet encountered any DW_TAG_namespace entries; otherwise,
   it's the name of the current namespace.  In particular, it's the
   empty string if we're currently in the global namespace but have
   previously encountered a DW_TAG_namespace.  */
d1373 3
a1375 4
static char *
scan_partial_symbols (char *info_ptr, CORE_ADDR *lowpc,
		      CORE_ADDR *highpc, struct dwarf2_cu *cu,
		      const char *namespace)
d1379 1
a1379 1
  struct partial_die_info pdi;
d1385 3
a1387 1
  while (1)
d1389 1
a1389 5
      /* This flag tells whether or not info_ptr has gotten updated
	 inside the loop.  */
      int info_ptr_updated = 0;

      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);
d1395 2
a1396 2
      if (pdi.name != NULL || pdi.tag == DW_TAG_namespace
	  || pdi.tag == DW_TAG_enumeration_type)
d1398 1
a1398 1
	  switch (pdi.tag)
d1401 1
a1401 1
	      if (pdi.has_pc_info)
d1403 1
a1403 1
		  if (pdi.lowpc < *lowpc)
d1405 1
a1405 1
		      *lowpc = pdi.lowpc;
d1407 1
a1407 1
		  if (pdi.highpc > *highpc)
d1409 1
a1409 1
		      *highpc = pdi.highpc;
d1411 1
a1411 1
		  if (!pdi.is_declaration)
d1413 1
a1413 1
		      add_partial_symbol (&pdi, cu, namespace);
d1420 1
a1420 1
	      if (!pdi.is_declaration)
d1422 1
a1422 1
		  add_partial_symbol (&pdi, cu, namespace);
d1427 1
a1427 1
	      if (!pdi.is_declaration)
d1429 1
a1429 3
		  info_ptr = add_partial_structure (&pdi, info_ptr, cu,
						    namespace);
		  info_ptr_updated = 1;
d1433 2
a1434 6
	      if (!pdi.is_declaration)
		{
		  info_ptr = add_partial_enumeration (&pdi, info_ptr, cu,
						      namespace);
		  info_ptr_updated = 1;
		}
d1440 1
a1440 1
	      add_partial_symbol (&pdi, cu, namespace);
d1443 1
a1443 8
	      /* We've hit a DW_TAG_namespace entry, so we know this
		 file has been compiled using a compiler that
		 generates them; update NAMESPACE to reflect that.  */
	      if (namespace == NULL)
		namespace = "";
	      info_ptr = add_partial_namespace (&pdi, info_ptr, lowpc, highpc,
						cu, namespace);
	      info_ptr_updated = 1;
d1450 51
a1500 2
      if (pdi.tag == 0)
	break;
d1502 1
a1502 2
      /* If the die has a sibling, skip to the sibling, unless another
	 function has already updated info_ptr for us.  */
d1504 1
a1504 4
      /* NOTE: carlton/2003-06-16: This is a bit hackish, but whether
	 or not we want to update this depends on enough stuff (not
	 only pdi.tag but also whether or not pdi.name is NULL) that
	 this seems like the easiest way to handle the issue.  */
d1506 10
a1515 2
      if (!info_ptr_updated)
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu);
d1517 25
d1543 5
a1547 1
  return info_ptr;
d1551 1
a1551 2
add_partial_symbol (struct partial_die_info *pdi,
		    struct dwarf2_cu *cu, const char *namespace)
d1555 2
a1556 1
  char *actual_name = pdi->name;
d1559 1
d1563 3
a1565 4
  /* If we're not in the global namespace and if the namespace name
     isn't encoded in a mangled actual_name, add it.  */
  
  if (pdi_needs_namespace (pdi->tag, namespace))
d1567 3
a1569 4
      actual_name = alloca (strlen (pdi->name) + 2 + strlen (namespace) + 1);
      strcpy (actual_name, namespace);
      strcat (actual_name, "::");
      strcat (actual_name, pdi->name);
d1572 3
d1647 6
d1697 3
d1701 1
a1701 1
      && namespace == NULL
d1706 3
d1711 2
a1712 2
/* Determine whether a die of type TAG living in the C++ namespace
   NAMESPACE needs to have the name of the namespace prepended to the
d1716 1
a1716 1
pdi_needs_namespace (enum dwarf_tag tag, const char *namespace)
a1717 3
  if (namespace == NULL || namespace[0] == '\0')
    return 0;

d1720 1
d1737 2
a1738 2
static char *
add_partial_namespace (struct partial_die_info *pdi, char *info_ptr,
d1740 1
a1740 1
		       struct dwarf2_cu *cu, const char *namespace)
a1742 2
  const char *new_name = pdi->name;
  char *full_name;
d1744 1
a1744 1
  /* Calculate the full name of the namespace that we just entered.  */
d1746 1
a1746 17
  if (new_name == NULL)
    new_name = "(anonymous namespace)";
  full_name = alloca (strlen (namespace) + 2 + strlen (new_name) + 1);
  strcpy (full_name, namespace);
  if (*namespace != '\0')
    strcat (full_name, "::");
  strcat (full_name, new_name);

  /* FIXME: carlton/2003-10-07: We can't just replace this by a call
     to add_partial_symbol, because we don't have a way to pass in the
     full name to that function; that might be a flaw in
     add_partial_symbol's interface.  */

  add_psymbol_to_list (full_name, strlen (full_name),
		       VAR_DOMAIN, LOC_TYPEDEF,
		       &objfile->global_psymbols,
		       0, 0, cu->language, objfile);
d1751 1
a1751 3
    info_ptr = scan_partial_symbols (info_ptr, lowpc, highpc, cu, full_name);

  return info_ptr;
d1754 3
a1756 1
/* Read a partial die corresponding to a class or structure.  */
d1758 3
a1760 4
static char *
add_partial_structure (struct partial_die_info *struct_pdi, char *info_ptr,
		       struct dwarf2_cu *cu,
		       const char *namespace)
a1761 3
  bfd *abfd = cu->objfile->obfd;
  char *actual_class_name = NULL;

d1763 1
a1763 2
      && (namespace == NULL || namespace[0] == '\0')
      && struct_pdi->name != NULL
a1765 5
      /* See if we can figure out if the class lives in a namespace
	 (or is nested within another class.)  We do this by looking
	 for a member function; its demangled name will contain
	 namespace info, if there is any.  */

d1772 19
a1790 26
      /* FIXME: carlton/2004-01-23: If NAMESPACE equals "", we have
	 the appropriate debug information, so it would be nice to be
	 able to avoid this hack.  But NAMESPACE may not be the
	 namespace where this class was defined: NAMESPACE reflects
	 where STRUCT_PDI occurs in the tree of dies, but because of
	 DW_AT_specification, that may not actually tell us where the
	 class is defined.  (See the comment in read_func_scope for an
	 example of how this could occur.)

         Unfortunately, our current partial symtab data structures are
         completely unable to deal with DW_AT_specification.  So, for
         now, the best thing to do is to get nesting information from
         places other than the tree structure of dies if there's any
         chance that a DW_AT_specification is involved. :-( */

      char *next_child = info_ptr;

      while (1)
	{
	  struct partial_die_info child_pdi;

	  next_child = read_partial_die (&child_pdi, abfd, next_child,
					 cu);
	  if (!child_pdi.tag)
	    break;
	  if (child_pdi.tag == DW_TAG_subprogram)
d1792 2
a1793 1
	      actual_class_name = class_name_from_physname (child_pdi.name);
d1795 7
a1801 1
		struct_pdi->name = actual_class_name;
d1804 2
a1805 5
	  else
	    {
	      next_child = locate_pdi_sibling (&child_pdi, next_child,
					       abfd, cu);
	    }
a1807 5

  add_partial_symbol (struct_pdi, cu, namespace);
  xfree (actual_class_name);

  return locate_pdi_sibling (struct_pdi, info_ptr, abfd, cu);
d1812 3
a1814 3
static char *
add_partial_enumeration (struct partial_die_info *enum_pdi, char *info_ptr,
			 struct dwarf2_cu *cu, const char *namespace)
d1818 1
a1818 1
  struct partial_die_info pdi;
d1821 4
a1824 3
    add_partial_symbol (enum_pdi, cu, namespace);
  
  while (1)
d1826 1
a1826 4
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);
      if (pdi.tag == 0)
	break;
      if (pdi.tag != DW_TAG_enumerator || pdi.name == NULL)
d1829 2
a1830 1
	add_partial_symbol (&pdi, cu, namespace);
a1831 2

  return info_ptr;
d1989 1
a1989 1
  
d3487 1
a3487 1
     add_partial_structure.  */
d4420 2
a4421 1
   in a hash table.  */
d4461 3
d4547 227
d4777 3
a4779 1
read_partial_die (struct partial_die_info *part_die, bfd *abfd,
d4782 1
a4782 2
  unsigned int abbrev_number, bytes_read, i;
  struct abbrev_info *abbrev;
a4783 2
  struct attribute spec_attr;
  int found_spec_attr = 0;
d4787 7
a4793 4
  *part_die = zeroed_partial_die;
  abbrev_number = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
  info_ptr += bytes_read;
  if (!abbrev_number)
a4795 7
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
  if (!abbrev)
    {
      error ("Dwarf Error: Could not find abbrev number %d [in module %s]", abbrev_number,
		      bfd_get_filename (abfd));
    }
  part_die->offset = info_ptr - dwarf2_per_objfile->info_buffer;
a4797 1
  part_die->abbrev = abbrev_number;
d4854 3
a4856 2
	  found_spec_attr = 1;
	  spec_attr = attr;
a4871 21
  /* If we found a reference attribute and the die has no name, try
     to find a name in the referred to die.  */

  if (found_spec_attr && part_die->name == NULL)
    {
      struct partial_die_info spec_die;
      char *spec_ptr;

      spec_ptr = dwarf2_per_objfile->info_buffer
	+ dwarf2_get_ref_die_offset (&spec_attr, cu);
      read_partial_die (&spec_die, abfd, spec_ptr, cu);
      if (spec_die.name)
	{
	  part_die->name = spec_die.name;

	  /* Copy DW_AT_external attribute if it is set.  */
	  if (spec_die.is_external)
	    part_die->is_external = spec_die.is_external;
	}
    }

d4888 80
d4999 1
a4999 1
	     abbrev_number, 
d8600 58
@


1.143
log
@        * dwarf2read.c (read_structure_scope): Identify stub types
        using die_is_declaration() only.
@
text
@d680 3
d5145 12
d5160 7
a5166 2
  return (dwarf2_attr (die, DW_AT_declaration, cu)
	  && ! dwarf2_attr (die, DW_AT_specification, cu));
@


1.142
log
@	* dwarf2read.c (dwarf2_objfile_data_key): New.
	(struct dwarf2_per_objfile, dwarf2_per_objfile): New.
	(dwarf_info_size, dwarf_abbrev_size, dwarf_line_size)
	(dwarf_pubnames_size, dwarf_aranges_size, dwarf_loc_size)
	(dwarf_macinfo_size, dwarf_str_size, dwarf_ranges_size)
	(dwarf_frame_size, dwarf_eh_frame_size, dwarf_info_buffer)
	(dwarf_abbrev_buffer, dwarf_line_buffer, dwarf_str_buffer)
	(dwarf_macinfo_buffer, dwarf_ranges_buffer, dwarf_loc_buffer):
	Remove variables.
	(struct dwarf2_pinfo): Remove per-objfile members.  Update comments.
	(DWARF_ABBREV_SIZE, DWARF_LINE_SIZE)
	(DWARF_LOC_SIZE, DWARF_MACINFO_SIZE, DWARF_STR_SIZE)
	(DWARF_RANGES_SIZE, DWARF_INFO_BUFFER)
	(DWARF_ABBREV_BUFFER, DWARF_LINE_BUFFER, DWARF_STR_BUFFER)
	(DWARF_MACINFO_BUFFER, DWARF_RANGES_BUFFER, DWARF_LOC_BUFFER):
	Remove macros.
	(dwarf2_has_info): Take an objfile argument.  Allocate per-objfile
	data.
	(dwarf2_locate_sections, dwarf2_build_psymtabs)
	(dwarf2_build_psymtabs_easy, dwarf2_build_psymtabs_hard)
	(skip_one_die, dwarf2_get_pc_bounds, dwarf2_read_abbrevs)
	(read_partial_die, read_full_die, read_indirect_string)
	(dwarf_decode_line_header, dwarf_decode_macros)
	(dwarf2_symbol_mark_computed): Remove use of removed macros.
	Update uses of removed variables.
	(psymtab_to_symtab_1): Restore per-objfile data pointer.  Remove use
	of removed macros.
	(_initialize_dwarf2_read): New function.
	* symfile.h (dwarf2_has_info): Update prototype.
	* coffread.c (coff_symfile_read): Update call to dwarf2_has_info.
	* elfread.c (elf_symfile_read): Likewise.
@
text
@d3144 3
a3241 5
    }
  else
    {
      /* No children, must be stub. */
      TYPE_FLAGS (type) |= TYPE_FLAG_STUB;
@


1.141
log
@2004-03-16  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (process_structure_scope): Process children even
	when we're a declaration.
@
text
@d143 1
a143 1
/* offsets and sizes of debugging sections */
d145 26
a170 11
static unsigned int dwarf_info_size;
static unsigned int dwarf_abbrev_size;
static unsigned int dwarf_line_size;
static unsigned int dwarf_pubnames_size;
static unsigned int dwarf_aranges_size;
static unsigned int dwarf_loc_size;
static unsigned int dwarf_macinfo_size;
static unsigned int dwarf_str_size;
static unsigned int dwarf_ranges_size;
unsigned int dwarf_frame_size;
unsigned int dwarf_eh_frame_size;
d333 1
a333 1
     header.  These point into dwarf_line_buffer.  */
a453 9
/* Actually data from the sections.  */
static char *dwarf_info_buffer;
static char *dwarf_abbrev_buffer;
static char *dwarf_line_buffer;
static char *dwarf_str_buffer;
static char *dwarf_macinfo_buffer;
static char *dwarf_ranges_buffer;
static char *dwarf_loc_buffer;

d467 1
a467 6
   of the psymtab.

   Most of the information in this structure is related to an entire
   object file and could be passed via the sym_private field of the
   objfile.  It is possible to have both dwarf2 and some other form
   of debug symbols in one object file.  */
d471 1
a471 5
    /* Pointer to start of dwarf info buffer for the objfile.  */

    char *dwarf_info_buffer;

    /* Offset in dwarf_info_buffer for this compilation unit. */
a473 48

    /* Pointer to start of dwarf abbreviation buffer for the objfile.  */

    char *dwarf_abbrev_buffer;

    /* Size of dwarf abbreviation section for the objfile.  */

    unsigned int dwarf_abbrev_size;

    /* Pointer to start of dwarf line buffer for the objfile.  */

    char *dwarf_line_buffer;

    /* Size of dwarf_line_buffer, in bytes.  */
    
    unsigned int dwarf_line_size;

    /* Pointer to start of dwarf string buffer for the objfile.  */

    char *dwarf_str_buffer;

    /* Size of dwarf string section for the objfile.  */

    unsigned int dwarf_str_size;

    /* Pointer to start of dwarf macro buffer for the objfile.  */

    char *dwarf_macinfo_buffer;

    /* Size of dwarf macinfo section for the objfile.  */
    
    unsigned int dwarf_macinfo_size;

    /* Pointer to start of dwarf ranges buffer for the objfile.  */

    char *dwarf_ranges_buffer;

    /* Size of dwarf ranges buffer for the objfile.  */

    unsigned int dwarf_ranges_size;

    /* Pointer to start of dwarf locations buffer for the objfile.  */

    char *dwarf_loc_buffer;

    /* Size of dwarf locations buffer for the objfile.  */

    unsigned int dwarf_loc_size;
a476 1
#define DWARF_INFO_BUFFER(p) (PST_PRIVATE(p)->dwarf_info_buffer)
a477 12
#define DWARF_ABBREV_BUFFER(p) (PST_PRIVATE(p)->dwarf_abbrev_buffer)
#define DWARF_ABBREV_SIZE(p) (PST_PRIVATE(p)->dwarf_abbrev_size)
#define DWARF_LINE_BUFFER(p) (PST_PRIVATE(p)->dwarf_line_buffer)
#define DWARF_LINE_SIZE(p)   (PST_PRIVATE(p)->dwarf_line_size)
#define DWARF_STR_BUFFER(p)  (PST_PRIVATE(p)->dwarf_str_buffer)
#define DWARF_STR_SIZE(p)    (PST_PRIVATE(p)->dwarf_str_size)
#define DWARF_MACINFO_BUFFER(p) (PST_PRIVATE(p)->dwarf_macinfo_buffer)
#define DWARF_MACINFO_SIZE(p)   (PST_PRIVATE(p)->dwarf_macinfo_size)
#define DWARF_RANGES_BUFFER(p)  (PST_PRIVATE(p)->dwarf_ranges_buffer)
#define DWARF_RANGES_SIZE(p)    (PST_PRIVATE(p)->dwarf_ranges_size)
#define DWARF_LOC_BUFFER(p)     (PST_PRIVATE(p)->dwarf_loc_buffer)
#define DWARF_LOC_SIZE(p)       (PST_PRIVATE(p)->dwarf_loc_size)
d887 1
a887 1
dwarf2_has_info (bfd *abfd)
d889 8
d907 1
a907 1
  bfd_map_over_sections (abfd, dwarf2_locate_sections, NULL);
d920 1
a920 1
      dwarf_info_size = bfd_get_section_size_before_reloc (sectp);
d925 1
a925 1
      dwarf_abbrev_size = bfd_get_section_size_before_reloc (sectp);
d930 1
a930 1
      dwarf_line_size = bfd_get_section_size_before_reloc (sectp);
d935 1
a935 1
      dwarf_pubnames_size = bfd_get_section_size_before_reloc (sectp);
d940 1
a940 1
      dwarf_aranges_size = bfd_get_section_size_before_reloc (sectp);
d945 1
a945 1
      dwarf_loc_size = bfd_get_section_size_before_reloc (sectp);
d950 1
a950 1
      dwarf_macinfo_size = bfd_get_section_size_before_reloc (sectp);
d955 1
a955 1
      dwarf_str_size = bfd_get_section_size_before_reloc (sectp);
d960 1
a960 1
      dwarf_frame_size = bfd_get_section_size_before_reloc (sectp);
d968 1
a968 1
          dwarf_eh_frame_size = bfd_get_section_size_before_reloc (sectp);
d974 1
a974 1
      dwarf_ranges_size = bfd_get_section_size_before_reloc (sectp);
a983 1

d986 2
a987 2
  dwarf_info_buffer = dwarf2_read_section (objfile, dwarf_info_section);
  dwarf_abbrev_buffer = dwarf2_read_section (objfile, dwarf_abbrev_section);
d990 1
a990 1
    dwarf_line_buffer = dwarf2_read_section (objfile, dwarf_line_section);
d992 1
a992 1
    dwarf_line_buffer = NULL;
d995 1
a995 1
    dwarf_str_buffer = dwarf2_read_section (objfile, dwarf_str_section);
d997 1
a997 1
    dwarf_str_buffer = NULL;
d1000 1
a1000 1
    dwarf_macinfo_buffer = dwarf2_read_section (objfile,
d1003 1
a1003 1
    dwarf_macinfo_buffer = NULL;
d1006 1
a1006 1
    dwarf_ranges_buffer = dwarf2_read_section (objfile, dwarf_ranges_section);
d1008 1
a1008 1
    dwarf_ranges_buffer = NULL;
d1011 1
a1011 1
    dwarf_loc_buffer = dwarf2_read_section (objfile, dwarf_loc_section);
d1013 1
a1013 1
    dwarf_loc_buffer = NULL;
d1054 1
a1054 1
  while ((pubnames_ptr - pubnames_buffer) < dwarf_pubnames_size)
d1119 2
a1120 2
  info_ptr = dwarf_info_buffer;
  abbrev_ptr = dwarf_abbrev_buffer;
d1138 1
a1138 1
        the null-terminated string in dwarf_info_buffer, so no dynamic
d1153 1
a1153 1
  /* Since the objects we're extracting from dwarf_info_buffer vary in
d1158 5
a1162 5
     At the moment, they don't actually check that.  If
     dwarf_info_buffer holds just one extra byte after the last
     compilation unit's dies, then read_comp_unit_head will happily
     read off the end of the buffer.  read_partial_die is similarly
     casual.  Those functions should be fixed.
d1166 2
a1167 1
  while (info_ptr < dwarf_info_buffer + dwarf_info_size)
d1181 1
a1181 1
      if (cu.header.abbrev_offset >= dwarf_abbrev_size)
d1185 1
a1185 1
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
d1190 1
a1190 1
	  > dwarf_info_buffer + dwarf_info_size)
d1194 1
a1194 1
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
d1199 1
a1199 1
      cu.header.offset = beg_of_comp_unit - dwarf_info_buffer;
d1225 1
a1225 14
      DWARF_INFO_BUFFER (pst) = dwarf_info_buffer;
      DWARF_INFO_OFFSET (pst) = beg_of_comp_unit - dwarf_info_buffer;
      DWARF_ABBREV_BUFFER (pst) = dwarf_abbrev_buffer;
      DWARF_ABBREV_SIZE (pst) = dwarf_abbrev_size;
      DWARF_LINE_BUFFER (pst) = dwarf_line_buffer;
      DWARF_LINE_SIZE (pst) = dwarf_line_size;
      DWARF_STR_BUFFER (pst) = dwarf_str_buffer;
      DWARF_STR_SIZE (pst) = dwarf_str_size;
      DWARF_MACINFO_BUFFER (pst) = dwarf_macinfo_buffer;
      DWARF_MACINFO_SIZE (pst) = dwarf_macinfo_size;
      DWARF_RANGES_BUFFER (pst) = dwarf_ranges_buffer;
      DWARF_RANGES_SIZE (pst) = dwarf_ranges_size;
      DWARF_LOC_BUFFER (pst) = dwarf_loc_buffer;
      DWARF_LOC_SIZE (pst) = dwarf_loc_size;
d1778 2
a1779 1
	    return dwarf_info_buffer + dwarf2_get_ref_die_offset (&attr, cu);
d1920 2
d1924 2
a1925 14
  dwarf_info_buffer = DWARF_INFO_BUFFER (pst);
  dwarf_abbrev_buffer = DWARF_ABBREV_BUFFER (pst);
  dwarf_abbrev_size = DWARF_ABBREV_SIZE (pst);
  dwarf_line_buffer = DWARF_LINE_BUFFER (pst);
  dwarf_line_size = DWARF_LINE_SIZE (pst);
  dwarf_str_buffer = DWARF_STR_BUFFER (pst);
  dwarf_str_size = DWARF_STR_SIZE (pst);
  dwarf_macinfo_buffer = DWARF_MACINFO_BUFFER (pst);
  dwarf_macinfo_size = DWARF_MACINFO_SIZE (pst);
  dwarf_ranges_buffer = DWARF_RANGES_BUFFER (pst);
  dwarf_ranges_size = DWARF_RANGES_SIZE (pst);
  dwarf_loc_buffer = DWARF_LOC_BUFFER (pst);
  dwarf_loc_size = DWARF_LOC_SIZE (pst);
  info_ptr = dwarf_info_buffer + offset;
d2463 1
a2463 1
	  if (offset >= dwarf_ranges_size)
d2470 1
a2470 1
	  buffer = dwarf_ranges_buffer + offset;
d4315 1
a4315 1
  abbrev_ptr = dwarf_abbrev_buffer + cu_header->abbrev_offset;
d4373 2
a4374 2
      if ((unsigned int) (abbrev_ptr - dwarf_abbrev_buffer)
	  >= dwarf_abbrev_size)
d4443 1
a4443 1
  part_die->offset = info_ptr - dwarf_info_buffer;
d4512 2
a4513 2
	    part_die->sibling =
	      dwarf_info_buffer + dwarf2_get_ref_die_offset (&attr, cu);
d4528 1
a4528 1
      spec_ptr = dwarf_info_buffer
d4570 1
a4570 1
  offset = info_ptr - dwarf_info_buffer;
d4984 1
a4984 1
  if (dwarf_str_buffer == NULL)
d4990 1
a4990 1
  if (str_offset >= dwarf_str_size)
d4997 1
a4997 1
  if (dwarf_str_buffer[str_offset] == '\0')
d4999 1
a4999 1
  return dwarf_str_buffer + str_offset;
d5243 2
a5244 2
   dwarf_line_buffer, according to the endianness of ABFD.  Return a
   pointer to a struct line_header, allocated using xmalloc.
d5260 1
a5260 1
  if (dwarf_line_buffer == NULL)
d5268 1
a5268 1
  if (offset + 4 >= dwarf_line_size)
d5279 1
a5279 1
  line_ptr = dwarf_line_buffer + offset;
d5284 2
a5285 1
  if (line_ptr + lh->total_length > dwarf_line_buffer + dwarf_line_size)
d5341 2
a5342 1
  if (line_ptr > dwarf_line_buffer + dwarf_line_size)
d7978 1
a7978 1
  if (dwarf_macinfo_buffer == NULL)
d7984 3
a7986 2
  mac_ptr = dwarf_macinfo_buffer + offset;
  mac_end = dwarf_macinfo_buffer + dwarf_macinfo_size;
d8133 2
a8134 2
      baton->size = dwarf_loc_size - DW_UNSND (attr);
      baton->data = dwarf_loc_buffer + DW_UNSND (attr);
d8155 3
a8157 3
	     dwarf_info_buffer for SYM's objfile; right now we never
	     release that buffer, but when we do clean up properly
	     this may need to change.  */
d8172 8
@


1.140
log
@2004-03-15  David Carlton  <carlton@@kealia.com>

	Fix for PR c++/1553:
	* dwarf2read.c (read_structure_type): Determine type name by
	calling determine_class_name.
	(determine_class_name): New.
	(determine_prefix): Look at TYPE_TAG_NAME and call
	determine_class_name when appropriate.
	(determine_prefix_aux, class_name): Delete.
@
text
@d3334 1
d3339 8
a3346 1
  if (die->child != NULL && ! die_is_declaration (die, cu))
d3348 3
a3350 5
      struct die_info *child_die;

      child_die = die->child;

      while (child_die && child_die->tag)
d3352 1
a3352 10
	  if (child_die->tag == DW_TAG_member
	      || child_die->tag == DW_TAG_variable
	      || child_die->tag == DW_TAG_inheritance)
	    {
	      /* Do nothing.  */
	    }
	  else
	    process_die (child_die, cu);

	  child_die = sibling_die (child_die);
d3354 2
d3357 1
a3357 1
      new_symbol (die, die->type, cu);
d3359 3
@


1.139
log
@	* dwarf2read.c (read_structure_type): Rename from
	read_structure_scope.  Don't create a symbol or call process_die.
	Return immediately if die->type is set.  Call read_type_die before
	dwarf2_add_member_fn.
	(process_structure_scope): New function.
	(read_enumeration_type, process_enumeration_scope): New functions,
	broken out from read_enumeration.  Don't create the enumeration
	type if it has already been created.
	(read_enumeration): Removed.
	(process_die): Call read_structure_type, process_structure_scope,
	read_enumeration_type, and process_enumeration_scope.  Just call
	new_symbol for base and subrange types.  Add a comment about other
	type dies.
	(read_type_die): Call read_enumeration_type.
	(add_partial_structure, new_symbol): Update comments.
@
text
@a784 2
static char *determine_prefix_aux (struct die_info *die, struct dwarf2_cu *);

a786 2
static char *class_name (struct die_info *die, struct dwarf2_cu *);

d823 2
a3167 1
  char *name = NULL;
a3169 4
  /* This says whether or not we want to try to update the structure's
     name to include enclosing namespace/class information, if
     any.  */
  int need_to_update_name = 0;
a3179 2
      name = DW_STRING (attr);

d3182 5
a3186 23
	  struct die_info *spec_die = die_specification (die, cu);

	  if (spec_die != NULL)
	    {
	      char *specification_prefix = determine_prefix (spec_die, cu);
	      processing_current_prefix = specification_prefix;
	      back_to = make_cleanup (xfree, specification_prefix);
	    }
	}

      if (processing_has_namespace_info)
	{
	  /* FIXME: carlton/2003-11-10: This variable exists only for
	     const-correctness reasons.  When I tried to change
	     TYPE_TAG_NAME to be a const char *, I ran into a cascade
	     of changes which would have forced decode_line_1 to take
	     a const char **.  */
	  char *new_prefix = obconcat (&objfile->objfile_obstack,
				       processing_current_prefix,
				       processing_current_prefix[0] == '\0'
				       ? "" : "::",
				       name);
	  TYPE_TAG_NAME (type) = new_prefix;
d3193 1
a3193 2
	  TYPE_TAG_NAME (type) = name;
	  need_to_update_name = (cu->language == language_cplus);
a3253 35
	      if (need_to_update_name)
		{
		  /* The demangled names of member functions contain
		     information about enclosing namespaces/classes,
		     if any.  */

		  /* FIXME: carlton/2003-11-10: The excessive
		     demangling here is a bit wasteful, as is the
		     memory usage for names.  */

		  /* NOTE: carlton/2003-11-10: As commented in
		     add_partial_structure, the demangler sometimes
		     prints the type info in a different form from the
		     debug info.  We could solve this by using the
		     demangled name to get the prefix; if doing so,
		     however, we'd need to be careful when reading a
		     class that's nested inside a template class.
		     That would also cause problems when trying to
		     determine RTTI information, since we use the
		     demangler to determine the appropriate class
		     name.  */
		  char *actual_class_name
		    = class_name_from_physname (dwarf2_linkage_name
						(child_die, cu));
		  if (actual_class_name != NULL
		      && strcmp (actual_class_name, name) != 0)
		    {
		      TYPE_TAG_NAME (type)
			= obsavestring (actual_class_name,
					strlen (actual_class_name),
					&objfile->objfile_obstack);
		    }
		  xfree (actual_class_name);
		  need_to_update_name = 0;
		}
d3414 56
d3720 1
a6294 12
  char *prefix = determine_prefix_aux (die, cu);

  return prefix ? prefix : xstrdup ("");
}

/* Return the name of the namespace/class that DIE is defined
   within, or NULL if we can't tell.  The caller should xfree the
   result.  */

static char *
determine_prefix_aux (struct die_info *die, struct dwarf2_cu *cu)
{
d6304 1
a6304 1
      return (processing_has_namespace_info ? xstrdup ("") : NULL);
a6307 3
      char *parent_prefix = determine_prefix_aux (parent, cu);
      char *retval;

d6311 16
a6326 4
	  int dummy;

	  retval = typename_concat (parent_prefix,
				    namespace_name (parent, &dummy, cu));
d6332 1
a6332 1
	  if (parent_prefix != NULL)
d6334 11
a6344 1
	      const char *parent_name = dwarf2_name (parent, cu);
d6346 2
a6347 7
	      if (parent_name != NULL)
		retval = typename_concat (parent_prefix, dwarf2_name (parent, cu));
	      else
		/* FIXME: carlton/2003-11-10: I'm not sure what the
		   best thing to do here is.  */
		retval = typename_concat (parent_prefix,
					  "<<anonymous class>>");
a6348 2
	  else
	    retval = class_name (parent, cu);
a6349 1
	break;
d6351 1
a6351 2
	retval = parent_prefix;
	break;
a6352 4

      if (retval != parent_prefix)
	xfree (parent_prefix);
      return retval;
a6374 22
}

/* Return a newly-allocated string giving the name of the class given
   by DIE.  */

static char *
class_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *child;
  const char *name;

  for (child = die->child; child != NULL; child = sibling_die (child))
    {
      if (child->tag == DW_TAG_subprogram)
	return class_name_from_physname (dwarf2_linkage_name (child, cu));
    }

  name = dwarf2_name (die, cu);
  if (name != NULL)
    return xstrdup (name);
  else
    return xstrdup ("");
@


1.138
log
@	* dwarf2read.c (skip_leb128, peek_die_abbrev, skip_one_die)
	(skip_children): New functions.
	(locate_pdi_sibling): Call skip_children.
@
text
@d823 3
a825 1
static void read_structure_scope (struct die_info *, struct dwarf2_cu *);
d834 3
a836 1
static void read_enumeration (struct die_info *, struct dwarf2_cu *);
d1702 1
a1702 1
	 prefix (but see comment in read_structure_scope).  */
d2112 2
a2113 1
      read_structure_scope (die, cu);
d2116 2
a2117 1
      read_enumeration (die, cu);
d2119 4
d2141 2
d2145 3
a2147 5
      if (dwarf2_attr (die, DW_AT_name, cu))
	{
	  /* Add a typedef symbol for the base type definition.  */
	  new_symbol (die, die->type, cu);
	}
d2151 3
a2153 5
      if (dwarf2_attr (die, DW_AT_name, cu))
       {
         /* Add a typedef symbol for the base type definition.  */
         new_symbol (die, die->type, cu);
       }
d3165 1
a3165 1
read_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
d3178 3
d3280 1
a3280 1
	      process_die (child_die, cu);
a3322 4
	  else
	    {
	      process_die (child_die, cu);
	    }
a3378 2
      new_symbol (die, type, cu);

d3392 28
a3419 2
/* Given a pointer to a die which begins an enumeration, process all
   the dies that define the members of the enumeration.
d3421 2
a3422 3
   This will be much nicer in draft 6 of the DWARF spec when our
   members will be dies instead squished into the DW_AT_element_list
   attribute.
d3424 5
a3428 1
   NOTE: We reverse the order of the element list.  */
d3431 1
a3431 1
read_enumeration (struct die_info *die, struct dwarf2_cu *cu)
a3433 1
  struct die_info *child_die;
a3434 1
  struct field *fields;
d3436 3
a3438 3
  struct symbol *sym;
  int num_fields;
  int unsigned_enum = 1;
d3474 20
d3510 1
a3510 1
		  sym = new_symbol (child_die, type, cu);
d3537 4
a3540 4
	  TYPE_NFIELDS (type) = num_fields;
	  TYPE_FIELDS (type) = (struct field *)
	    TYPE_ALLOC (type, sizeof (struct field) * num_fields);
	  memcpy (TYPE_FIELDS (type), fields,
d3545 1
a3545 1
	TYPE_FLAGS (type) |= TYPE_FLAG_UNSIGNED;
d3547 2
a3548 2
  die->type = type;
  new_symbol (die, type, cu);
d5899 1
a5899 1
	     read_structure_scope, and the correct name is saved in
d6242 1
a6242 1
      read_structure_scope (die, cu);
d6245 1
a6245 1
      read_enumeration (die, cu);
@


1.138.2.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d785 2
d789 2
d823 1
a823 5
static void read_structure_type (struct die_info *, struct dwarf2_cu *);

static void process_structure_scope (struct die_info *, struct dwarf2_cu *);

static char *determine_class_name (struct die_info *die, struct dwarf2_cu *cu);
d832 1
a832 3
static void read_enumeration_type (struct die_info *, struct dwarf2_cu *);

static void process_enumeration_scope (struct die_info *, struct dwarf2_cu *);
d1698 1
a1698 1
	 prefix (but see comment in read_structure_type).  */
d2108 1
a2108 2
      read_structure_type (die, cu);
      process_structure_scope (die, cu);
d2111 1
a2111 2
      read_enumeration_type (die, cu);
      process_enumeration_scope (die, cu);
a2112 4

    /* FIXME drow/2004-03-14: These initialize die->type, but do not create
       a symbol or process any children.  Therefore it doesn't do anything
       that won't be done on-demand by read_type_die.  */
a2130 2
    /* END FIXME */

d2133 5
a2137 3
      /* Add a typedef symbol for the type definition, if it has a
	 DW_AT_name.  */
      new_symbol (die, die->type, cu);
d2141 5
a2145 3
      /* Add a typedef symbol for the type definition, if it has a
         DW_AT_name.  */
      new_symbol (die, die->type, cu);
d3157 1
a3157 1
read_structure_type (struct die_info *die, struct dwarf2_cu *cu)
d3162 1
d3165 4
a3168 3

  if (die->type)
    return;
d3176 2
d3180 23
a3202 5
	  char *new_prefix = determine_class_name (die, cu);
	  TYPE_TAG_NAME (type) = obsavestring (new_prefix,
					       strlen (new_prefix),
					       &objfile->objfile_obstack);
	  back_to = make_cleanup (xfree, new_prefix);
d3209 2
a3210 1
	  TYPE_TAG_NAME (type) = DW_STRING (attr);
d3269 1
a3269 1
	      read_type_die (child_die, cu);
d3271 35
d3312 4
d3372 2
d3387 2
a3388 6
static void
process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  const char *previous_prefix = processing_current_prefix;
  struct die_info *child_die = die->child;
d3390 3
a3392 2
  if (TYPE_TAG_NAME (die->type) != NULL)
    processing_current_prefix = TYPE_TAG_NAME (die->type);
d3394 1
a3394 29
  /* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its
     snapshots) has been known to create a die giving a declaration
     for a class that has, as a child, a die giving a definition for a
     nested class.  So we have to process our children even if the
     current die is a declaration.  Normally, of course, a declaration
     won't have any children at all.  */

  while (child_die != NULL && child_die->tag)
    {
      if (child_die->tag == DW_TAG_member
	  || child_die->tag == DW_TAG_variable
	  || child_die->tag == DW_TAG_inheritance)
	{
	  /* Do nothing.  */
	}
      else
	process_die (child_die, cu);

      child_die = sibling_die (child_die);
    }

  if (die->child != NULL && ! die_is_declaration (die, cu))
    new_symbol (die, die->type, cu);

  processing_current_prefix = previous_prefix;
}

/* Given a DW_AT_enumeration_type die, set its type.  We do not
   complete the type's fields yet, or create any symbols.  */
d3397 1
a3397 1
read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)
d3400 1
d3402 1
d3404 3
a3406 3

  if (die->type)
    return;
a3441 76
  die->type = type;
}

/* Determine the name of the type represented by DIE, which should be
   a named C++ compound type.  Return the name in question; the caller
   is responsible for xfree()'ing it.  */

static char *
determine_class_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct cleanup *back_to = NULL;
  struct die_info *spec_die = die_specification (die, cu);
  char *new_prefix = NULL;

  /* If this is the definition of a class that is declared by another
     die, then processing_current_prefix may not be accurate; see
     read_func_scope for a similar example.  */
  if (spec_die != NULL)
    {
      char *specification_prefix = determine_prefix (spec_die, cu);
      processing_current_prefix = specification_prefix;
      back_to = make_cleanup (xfree, specification_prefix);
    }

  /* If we don't have namespace debug info, guess the name by trying
     to demangle the names of members, just like we did in
     add_partial_structure.  */
  if (!processing_has_namespace_info)
    {
      struct die_info *child;

      for (child = die->child;
	   child != NULL && child->tag != 0;
	   child = sibling_die (child))
	{
	  if (child->tag == DW_TAG_subprogram)
	    {
	      new_prefix = class_name_from_physname (dwarf2_linkage_name
						     (child, cu));

	      if (new_prefix != NULL)
		break;
	    }
	}
    }

  if (new_prefix == NULL)
    {
      const char *name = dwarf2_name (die, cu);
      new_prefix = typename_concat (processing_current_prefix,
				    name ? name : "<<anonymous>>");
    }

  if (back_to != NULL)
    do_cleanups (back_to);

  return new_prefix;
}

/* Given a pointer to a die which begins an enumeration, process all
   the dies that define the members of the enumeration, and create the
   symbol for the enumeration type.

   NOTE: We reverse the order of the element list.  */

static void
process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct die_info *child_die;
  struct field *fields;
  struct attribute *attr;
  struct symbol *sym;
  int num_fields;
  int unsigned_enum = 1;

d3458 1
a3458 1
		  sym = new_symbol (child_die, die->type, cu);
d3485 4
a3488 4
	  TYPE_NFIELDS (die->type) = num_fields;
	  TYPE_FIELDS (die->type) = (struct field *)
	    TYPE_ALLOC (die->type, sizeof (struct field) * num_fields);
	  memcpy (TYPE_FIELDS (die->type), fields,
d3493 1
a3493 1
	TYPE_FLAGS (die->type) |= TYPE_FLAG_UNSIGNED;
d3495 2
a3496 2

  new_symbol (die, die->type, cu);
a3674 1
      die->type = type;
d5847 1
a5847 1
	     read_structure_type, and the correct name is saved in
d6190 1
a6190 1
      read_structure_type (die, cu);
d6193 1
a6193 1
      read_enumeration_type (die, cu);
d6249 12
d6270 1
a6270 1
      return xstrdup ("");
d6274 3
d6280 4
a6283 16
	  /* FIXME: carlton/2004-03-05: Should I follow extension dies
	     before doing this check?  */
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
	    {
	      return xstrdup (TYPE_TAG_NAME (parent->type));
	    }
	  else
	    {
	      int dummy;
	      char *parent_prefix = determine_prefix (parent, cu);
	      char *retval = typename_concat (parent_prefix,
					      namespace_name (parent, &dummy,
							      cu));
	      xfree (parent_prefix);
	      return retval;
	    }
d6289 1
a6289 1
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
d6291 9
a6299 1
	      return xstrdup (TYPE_TAG_NAME (parent->type));
d6302 1
a6302 12
	    {
	      const char *old_prefix = processing_current_prefix;
	      char *new_prefix = determine_prefix (parent, cu);
	      char *retval;

	      processing_current_prefix = new_prefix;
	      retval = determine_class_name (parent, cu);
	      processing_current_prefix = old_prefix;

	      xfree (new_prefix);
	      return retval;
	    }
d6304 1
d6306 2
a6307 1
	return determine_prefix (parent, cu);
d6309 4
d6335 22
@


1.137
log
@	* dwarf2read.c (struct comp_unit_head): Remove dwarf2_abbrevs array.
	(struct dwarf2_cu): Add abbrev_obstack and dwarf2_abbrevs
	pointer.  Update comment about comp_unit_head.
	(struct abbrev_info): Shorten two int flags.
	(dwarf_alloc_abbrev): Take a CU argument.
	(dwarf2_build_psymtabs_hard): Call dwarf2_free_abbrev_table
	each time through the loop.  Update cleanup argument.
	(psymtab_to_symtab_1): Update cleanup call.
	(dwarf2_read_abbrevs, dwarf2_alloc_abbrev): Allocate on the
	abbrev_obstack.
	(dwarf2_free_abbrev_table): Renamed from dwarf2_empty_abbrev_table.
	Just call obstack_free and clear the pointer.
@
text
@d737 2
d942 3
d1773 148
a1920 2
/* Locate ORIG_PDI's sibling; INFO_PTR should point to the next DIE
   after ORIG_PDI.  */
d1936 1
a1936 9
  /* Okay, we don't know the sibling, but we have children that we
     want to skip.  So read children until we run into one without a
     tag; return whatever follows it.  */

  while (1)
    {
      struct partial_die_info pdi;
      
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);
d1938 1
a1938 5
      if (pdi.tag == 0)
	return info_ptr;
      else
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu);
    }
d5090 16
@


1.136
log
@	* dwarf2read.c: Add comment describing memory lifetimes.
	(struct dwarf2_pinfo): Update comment.
	(dwarf2_add_field, dwarf2_add_member_fn, read_structure_scope)
	(read_enumeration, new_symbol): Don't use obsavestring.
@
text
@a221 4
    /* DWARF abbreviation table associated with this compilation unit */

    struct abbrev_info *dwarf2_abbrevs[ABBREV_HASH_SIZE];

d240 1
a240 2
     should be moved to the dwarf2_cu structure; for instance the abbrevs
     hash table.  */
d270 6
d347 2
a348 2
    int has_children;		/* boolean */
    unsigned int num_attrs;	/* number of attributes */
d690 1
a690 1
static void dwarf2_empty_abbrev_table (void *);
d922 1
a922 1
static struct abbrev_info *dwarf_alloc_abbrev (void);
d1218 1
d1256 1
a1256 1
      make_cleanup (dwarf2_empty_abbrev_table, cu.header.dwarf2_abbrevs);
d1333 2
d1881 1
a1881 1
  make_cleanup (dwarf2_empty_abbrev_table, cu.header.dwarf2_abbrevs);
d4195 2
d4199 6
a4204 2
  memset (cu_header->dwarf2_abbrevs, 0,
          ABBREV_HASH_SIZE*sizeof (struct abbrev_info *));
d4210 3
d4216 1
a4216 1
      cur_abbrev = dwarf_alloc_abbrev ();
d4232 1
a4232 1
	  if ((cur_abbrev->num_attrs % ATTR_ALLOC_CHUNK) == 0)
d4234 4
a4237 4
	      cur_abbrev->attrs = (struct attr_abbrev *)
		xrealloc (cur_abbrev->attrs,
			  (cur_abbrev->num_attrs + ATTR_ALLOC_CHUNK)
			  * sizeof (struct attr_abbrev));
d4239 2
a4240 2
	  cur_abbrev->attrs[cur_abbrev->num_attrs].name = abbrev_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs++].form = abbrev_form;
d4247 6
d4254 2
a4255 2
      cur_abbrev->next = cu_header->dwarf2_abbrevs[hash_number];
      cu_header->dwarf2_abbrevs[hash_number] = cur_abbrev;
d4272 2
d4276 1
a4276 1
/* Empty the abbrev table for a new compilation unit.  */
d4279 1
a4279 1
dwarf2_empty_abbrev_table (void *ptr_to_abbrevs_table)
d4281 1
a4281 5
  int i;
  struct abbrev_info *abbrev, *next;
  struct abbrev_info **abbrevs;

  abbrevs = (struct abbrev_info **)ptr_to_abbrevs_table;
d4283 2
a4284 13
  for (i = 0; i < ABBREV_HASH_SIZE; ++i)
    {
      next = NULL;
      abbrev = abbrevs[i];
      while (abbrev)
	{
	  next = abbrev->next;
	  xfree (abbrev->attrs);
	  xfree (abbrev);
	  abbrev = next;
	}
      abbrevs[i] = NULL;
    }
a4291 1
  struct comp_unit_head *cu_header = &cu->header;
d4296 1
a4296 1
  abbrev = cu_header->dwarf2_abbrevs[hash_number];
d7611 1
a7611 1
dwarf_alloc_abbrev (void)
d7615 2
a7616 1
  abbrev = (struct abbrev_info *) xmalloc (sizeof (struct abbrev_info));
@


1.135
log
@	* dwarf2read.c (add_partial_symbol): Fix typo in adding enumerators
	to the partial symbol table.
@
text
@d53 14
d461 1
a461 2
   The complete dwarf information for an objfile is kept in the
   objfile_obstack, so that absolute die references can be handled.
d463 3
a465 3
   object file and could be passed via the sym_private field of the objfile.
   It is however conceivable that dwarf2 might not be the only type
   of symbols read from an object file.  */
d2680 4
a2683 2
      fp->name = obsavestring (fieldname, strlen (fieldname),
			       &objfile->objfile_obstack);
d2714 3
a2716 2
      SET_FIELD_PHYSNAME (*fp, obsavestring (physname, strlen (physname),
					     &objfile->objfile_obstack));
d2718 1
a2718 2
      FIELD_NAME (*fp) = obsavestring (fieldname, strlen (fieldname),
				       &objfile->objfile_obstack);
d2886 3
a2888 2
  fnp->physname = obsavestring (physname, strlen (physname),
				&objfile->objfile_obstack);
d3019 1
a3019 1
  const char *name = NULL;
d3064 3
a3066 2
	  TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
					       &objfile->objfile_obstack);
d3271 1
a3271 1
      const char *name = DW_STRING (attr);
d3283 3
a3285 2
	  TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
					       &objfile->objfile_obstack);
d5698 5
a5702 5
		     arises a further down in the function.)  */
		  SYMBOL_LINKAGE_NAME (sym)
		    = obsavestring (TYPE_TAG_NAME (type),
				    strlen (TYPE_TAG_NAME (type)),
				    &objfile->objfile_obstack);
d5733 3
d5737 1
a5737 4
		  TYPE_NAME (SYMBOL_TYPE (sym)) =
		    obsavestring (SYMBOL_NATURAL_NAME (sym),
				  strlen (SYMBOL_NATURAL_NAME (sym)),
				  &objfile->objfile_obstack);
@


1.135.4.1
log
@	* dwarf2read.c (read_structure_type): Rename from
	read_structure_scope.  Don't create a symbol or call process_die.
	Return immediately if die->type is set.  Call read_type_die before
	dwarf2_add_member_fn.
	(process_structure_scope): New function.
	(read_enumeration_type, process_enumeration_scope): New functions,
	broken out from read_enumeration.  Don't create the enumeration
	type if it has already been created.
	(read_enumeration): Removed.
	(process_die): Call read_structure_type, process_structure_scope,
	read_enumeration_type, and process_enumeration_scope.  Just call
	new_symbol for base and subrange types.  Add a comment about other
	type dies.
	(read_type_die): Call read_enumeration_type.
	(add_partial_structure, new_symbol): Update comments.
@
text
@d807 1
a807 3
static void read_structure_type (struct die_info *, struct dwarf2_cu *);

static void process_structure_scope (struct die_info *, struct dwarf2_cu *);
d816 1
a816 3
static void read_enumeration_type (struct die_info *, struct dwarf2_cu *);

static void process_enumeration_scope (struct die_info *, struct dwarf2_cu *);
d1676 1
a1676 1
	 prefix (but see comment in read_structure_type).  */
d1952 1
a1952 2
      read_structure_type (die, cu);
      process_structure_scope (die, cu);
d1955 1
a1955 2
      read_enumeration_type (die, cu);
      process_enumeration_scope (die, cu);
a1956 4

    /* FIXME drow/2004-03-14: These initialize die->type, but do not create
       a symbol or process any children.  Therefore it doesn't do anything
       that won't be done on-demand by read_type_die.  */
a1974 2
    /* END FIXME */

d1977 5
a1981 3
      /* Add a typedef symbol for the type definition, if it has a
	 DW_AT_name.  */
      new_symbol (die, die->type, cu);
d1985 5
a1989 3
      /* Add a typedef symbol for the type definition, if it has a
         DW_AT_name.  */
      new_symbol (die, die->type, cu);
d2998 1
a2998 1
read_structure_type (struct die_info *die, struct dwarf2_cu *cu)
a3010 3
  if (die->type)
    return;

d3109 1
a3109 1
	      read_type_die (child_die, cu);
d3152 4
d3212 2
d3227 2
a3228 5
static void
process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  const char *previous_prefix = processing_current_prefix;
d3230 3
a3232 2
  if (TYPE_TAG_NAME (die->type) != NULL)
    processing_current_prefix = TYPE_TAG_NAME (die->type);
d3234 1
a3234 28
  if (die->child != NULL && ! die_is_declaration (die, cu))
    {
      struct die_info *child_die;

      child_die = die->child;

      while (child_die && child_die->tag)
	{
	  if (child_die->tag == DW_TAG_member
	      || child_die->tag == DW_TAG_variable
	      || child_die->tag == DW_TAG_inheritance)
	    {
	      /* Do nothing.  */
	    }
	  else
	    process_die (child_die, cu);

	  child_die = sibling_die (child_die);
	}

      new_symbol (die, die->type, cu);
    }

  processing_current_prefix = previous_prefix;
}

/* Given a DW_AT_enumeration_type die, set its type.  We do not
   complete the type's fields yet, or create any symbols.  */
d3237 1
a3237 1
read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)
d3240 1
d3242 1
d3244 3
a3246 3

  if (die->type)
    return;
a3280 20
  die->type = type;
}

/* Given a pointer to a die which begins an enumeration, process all
   the dies that define the members of the enumeration, and create the
   symbol for the enumeration type.

   NOTE: We reverse the order of the element list.  */

static void
process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct die_info *child_die;
  struct field *fields;
  struct attribute *attr;
  struct symbol *sym;
  int num_fields;
  int unsigned_enum = 1;

d3297 1
a3297 1
		  sym = new_symbol (child_die, die->type, cu);
d3324 4
a3327 4
	  TYPE_NFIELDS (die->type) = num_fields;
	  TYPE_FIELDS (die->type) = (struct field *)
	    TYPE_ALLOC (die->type, sizeof (struct field) * num_fields);
	  memcpy (TYPE_FIELDS (die->type), fields,
d3332 1
a3332 1
	TYPE_FLAGS (die->type) |= TYPE_FLAG_UNSIGNED;
d3334 2
a3335 2

  new_symbol (die, die->type, cu);
d5669 1
a5669 1
	     read_structure_type, and the correct name is saved in
d6012 1
a6012 1
      read_structure_type (die, cu);
d6015 1
a6015 1
      read_enumeration_type (die, cu);
@


1.135.4.2
log
@2004-03-15  David Carlton  <carlton@@kealia.com>

	Fix for PR c++/1553:
	* dwarf2read.c (read_structure_type): Determine type name by
	calling determine_class_name.
	(determine_class_name): New.
	(determine_prefix): Look at TYPE_TAG_NAME and call
	determine_class_name when appropriate.
	(determine_prefix_aux, class_name): Delete.
@
text
@d769 2
d773 2
a810 2
static char *determine_class_name (struct die_info *die, struct dwarf2_cu *cu);

d3011 1
d3014 4
d3028 2
d3032 23
a3054 5
 	  char *new_prefix = determine_class_name (die, cu);
 	  TYPE_TAG_NAME (type) = obsavestring (new_prefix,
 					       strlen (new_prefix),
 					       &objfile->objfile_obstack);
 	  back_to = make_cleanup (xfree, new_prefix);
d3059 3
a3061 1
	  TYPE_TAG_NAME (type) = DW_STRING (attr);
d3122 35
a3315 56
/* Determine the name of the type represented by DIE, which should be
   a named C++ compound type.  Return the name in question; the caller
   is responsible for xfree()'ing it.  */

static char *
determine_class_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct cleanup *back_to = NULL;
  struct die_info *spec_die = die_specification (die, cu);
  char *new_prefix = NULL;

  /* If this is the definition of a class that is declared by another
     die, then processing_current_prefix may not be accurate; see
     read_func_scope for a similar example.  */
  if (spec_die != NULL)
    {
      char *specification_prefix = determine_prefix (spec_die, cu);
      processing_current_prefix = specification_prefix;
      back_to = make_cleanup (xfree, specification_prefix);
    }

  /* If we don't have namespace debug info, guess the name by trying
     to demangle the names of members, just like we did in
     add_partial_structure.  */
  if (!processing_has_namespace_info)
    {
      struct die_info *child;

      for (child = die->child;
	   child != NULL && child->tag != 0;
	   child = sibling_die (child))
	{
	  if (child->tag == DW_TAG_subprogram)
	    {
	      new_prefix = class_name_from_physname (dwarf2_linkage_name
						     (child, cu));

	      if (new_prefix != NULL)
		break;
	    }
	}
    }

  if (new_prefix == NULL)
    {
      const char *name = dwarf2_name (die, cu);
      new_prefix = typename_concat (processing_current_prefix,
				    name ? name : "<<anonymous>>");
    }

  if (back_to != NULL)
    do_cleanups (back_to);

  return new_prefix;
}

a3565 1
      die->type = type;
d6123 12
d6144 1
a6144 1
      return xstrdup ("");
d6148 3
d6154 4
a6157 16
	  /* FIXME: carlton/2004-03-05: Should I follow extension dies
	     before doing this check?  */
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
	    {
	      return xstrdup (TYPE_TAG_NAME (parent->type));
	    }
	  else
	    {
	      int dummy;
	      char *parent_prefix = determine_prefix (parent, cu);
	      char *retval = typename_concat (parent_prefix,
					      namespace_name (parent, &dummy,
							      cu));
	      xfree (parent_prefix);
	      return retval;
	    }
d6163 1
a6163 1
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
d6165 9
a6173 1
	      return xstrdup (TYPE_TAG_NAME (parent->type));
d6176 1
a6176 12
	    {
	      const char *old_prefix = processing_current_prefix;
	      char *new_prefix = determine_prefix (parent, cu);
	      char *retval;

	      processing_current_prefix = new_prefix;
	      retval = determine_class_name (parent, cu);
	      processing_current_prefix = old_prefix;

	      xfree (new_prefix);
	      return retval;
	    }
d6178 1
d6180 2
a6181 1
	return determine_prefix (parent, cu);
d6183 4
d6209 22
@


1.135.4.3
log
@2004-03-16  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (process_structure_scope): Process children even
	when we're a declaration.
@
text
@a3172 1
  struct die_info *child_die = die->child;
d3177 3
a3179 6
  /* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its
     snapshots) has been known to create a die giving a declaration
     for a class that has, as a child, a die giving a definition for a
     nested class.  So we have to process our children even if the
     current die is a declaration.  Normally, of course, a declaration
     won't have any children at all.  */
d3181 3
a3183 5
  while (child_die != NULL && child_die->tag)
    {
      if (child_die->tag == DW_TAG_member
	  || child_die->tag == DW_TAG_variable
	  || child_die->tag == DW_TAG_inheritance)
d3185 10
a3194 1
	  /* Do nothing.  */
a3195 2
      else
	process_die (child_die, cu);
d3197 1
a3197 1
      child_die = sibling_die (child_die);
a3198 3

  if (die->child != NULL && ! die_is_declaration (die, cu))
    new_symbol (die, die->type, cu);
@


1.135.2.1
log
@	* dwarf2read.c: Include "splay-tree.h".
	(struct dwarf2_cu): Add splay tree for partial DIEs.
	(struct partial_die_info): Move after struct attribute.
	Add has_specification, spec_attr, die_parent, die_child,
	and die_sibling fields.
	(load_partial_dies): New function.
	(load_partial_die): New function, broken out from read_partial_die.
	Correct setting of part_die->offset.  Save any specification
	attributes for later.
	(read_partial_die): Look up DIEs in the splay tree.
	(dwarf2_build_psymtabs_hard): Initialize partial_dies.  Call
	load_partial_die to read in the compilation unit DIE.  Call
	load_partial_dies.  Free the splay tree after use.
	(scan_partial_symbols): Follow the die_sibling chain.
	(add_partial_structure): Use die_child and die_sibling instead of
	read_partial_die and locate_pdi_sibling.
	(add_partial_enumeration): Likewise.
	(locate_pdi_sibling): Use load_partial_die instead of
	read_partial_die.
	(is_type_tag): New function.

	* Makefile.in (dwarf2read.o): Update dependencies.
@
text
@a46 1
#include "splay-tree.h"
a260 2

  splay_tree partial_dies;
d307 20
a404 23
/* When we construct a partial symbol table entry we only
   need this much information. */
struct partial_die_info
  {
    enum dwarf_tag tag;
    unsigned char has_children;
    unsigned char is_external;
    unsigned char is_declaration;
    unsigned char has_type;
    unsigned char has_specification;
    unsigned int offset;
    unsigned int abbrev;
    char *name;
    int has_pc_info;
    CORE_ADDR lowpc;
    CORE_ADDR highpc;
    struct dwarf_block *locdesc;
    unsigned int language;
    char *sibling;
    struct attribute spec_attr;
    struct partial_die_info *die_parent, *die_child, *die_sibling;
  };

d681 1
a681 3
static void load_partial_dies (bfd *, char *, struct dwarf2_cu *);

static char *load_partial_die (struct partial_die_info *,
a683 3
static void read_partial_die (struct partial_die_info *,
			      bfd *, char *, struct dwarf2_cu *);

a1238 2
      cu.partial_dies = NULL;

d1244 1
a1244 1
      info_ptr = load_partial_die (&comp_unit_die, abfd, info_ptr,
a1285 2
	  load_partial_dies (abfd, info_ptr, &cu);

a1288 2
	  splay_tree_delete (cu.partial_dies);

d1336 1
a1336 1
  struct partial_die_info pdi, *pdi_p;
d1342 5
a1346 2
  read_partial_die (&pdi, abfd, info_ptr, cu);
  pdi_p = &pdi;
d1348 1
a1348 4
  while (pdi_p != NULL)
    {
      /* FIXME */
      read_partial_die (&pdi, abfd, pdi_p->offset + dwarf_info_buffer, cu);
d1390 1
d1398 1
d1415 1
a1421 1
      /* FIXME unnecessary now */
a1432 1
      /*
a1434 4
      */
      pdi_p = pdi_p->die_sibling;
      // if (pdi_p)
      // fprintf_unfiltered (gdb_stderr, "scan: Advancing to DIE %x\n", pdi_p->offset);
d1693 1
a1693 1
      struct partial_die_info *child_pdi = struct_pdi->die_child;
d1695 1
a1695 1
      while (child_pdi != NULL)
d1697 7
a1703 1
	  if (child_pdi->tag == DW_TAG_subprogram)
d1705 1
a1705 1
	      actual_class_name = class_name_from_physname (child_pdi->name);
d1710 5
a1714 2

	  child_pdi = child_pdi->die_sibling;
d1721 1
a1721 2
  return (struct_pdi->offset + dwarf_info_buffer);
  /* return locate_pdi_sibling (struct_pdi, info_ptr, abfd, cu); */
d1732 1
a1732 1
  struct partial_die_info *pdi_p;
d1737 1
a1737 2
  pdi_p = enum_pdi->die_child;
  while (pdi_p)
d1739 4
a1742 1
      if (pdi_p->tag != DW_TAG_enumerator || pdi_p->name == NULL)
d1745 1
a1745 2
	add_partial_symbol (pdi_p, cu, namespace);
      pdi_p = pdi_p->die_sibling;
d1775 2
a1776 2

      info_ptr = load_partial_die (&pdi, abfd, info_ptr, cu);
a4284 144
/* Returns nonzero if TAG represents a type.  */

static int
is_type_tag (int tag)
{ 
  switch (tag)
    {
    case DW_TAG_array_type:
    case DW_TAG_class_type:
    case DW_TAG_enumeration_type:
    case DW_TAG_pointer_type:
    case DW_TAG_reference_type:
    case DW_TAG_string_type:
    case DW_TAG_structure_type:
    case DW_TAG_subroutine_type:
    case DW_TAG_union_type:
    case DW_TAG_ptr_to_member_type:
    case DW_TAG_set_type:
    case DW_TAG_subrange_type:
    case DW_TAG_base_type:
    case DW_TAG_const_type:
    case DW_TAG_file_type:
    case DW_TAG_packed_type:
    case DW_TAG_volatile_type:
    case DW_TAG_typedef:
      return 1;
    default:
      return 0;
    }
}

#if 0
/* Returns non-zero if PART_DIE might be referenced via DW_AT_specification
   or DW_AT_abstract_origin.  */

static int
maybe_specification_partial_die (struct partial_die_info *part_die)
{
  if (is_type_tag (part_die->tag))
    return 1;

  /* FIXME: How does DW_AT_abstract_origin play into this?  Is it
     possible to reference abstract origin in another CU (probably);
     will they all be declarations (probably not?).

     Understand this issue before posting patch.  */
  if (part_die->is_declaration && !part_die->has_specification)
    return 1;

  /* FIXME: That's all GCC checks (is_symbol_die); but GCC can emit
     DW_AT_specification for non-declarations.  I think they ought to
     be tagged as declarations... */

  return 0;
}
#endif

/* Load all DIEs that are interesting for partial symbols into memory.  */

static void
load_partial_dies (bfd *abfd, char *info_ptr, struct dwarf2_cu *cu)
{
  struct partial_die_info *part_die;
  struct partial_die_info *parent_die, *last_die;

  /* FIXME: Obviously we need a nesting level passed in for incremental use.  */
  int nesting_level = 1;

  /* But if we do incremental what do we do with this??? */
  parent_die = NULL;
  last_die = NULL;

  /* FIXME: All sorts of memory management issues.  */
  cu->partial_dies = splay_tree_new (splay_tree_compare_ints, NULL,
				     (splay_tree_delete_value_fn) xfree);
  part_die = xmalloc (sizeof (struct partial_die_info));

  while (1)
    {
      //      fprintf_unfiltered (gdb_stderr, "Loading DIE %x\n", info_ptr - dwarf_info_buffer);
      info_ptr = load_partial_die (part_die, abfd, info_ptr, cu);

      if (part_die->tag == 0)
	{
	  if (--nesting_level == 0)
	    {
	      xfree (part_die);
	      return;
	    }
	  last_die = parent_die;
	  parent_die = parent_die->die_parent;
	  continue;
	}

      /* Check whether this DIE is interesting enough to save.  */
      if (!is_type_tag (part_die->tag)
	  && part_die->tag != DW_TAG_enumerator
	  && part_die->tag != DW_TAG_subprogram
	  && part_die->tag != DW_TAG_variable
	  && part_die->tag != DW_TAG_namespace)
	{
	  /* Otherwise we skip to the next sibling, if any.  */
	  info_ptr = locate_pdi_sibling (part_die, info_ptr, abfd, cu);
	  continue;
	}

      /* We'll save this DIE so link it in.  */
      part_die->die_parent = parent_die;
      part_die->die_sibling = NULL;
      part_die->die_child = NULL;

      if (last_die && last_die == parent_die)
	last_die->die_child = part_die;
      else if (last_die)
	last_die->die_sibling = part_die;

      last_die = part_die;

      //      fprintf_unfiltered (gdb_stderr, "Inserting DIE %x\n", part_die->offset);
      splay_tree_insert (cu->partial_dies, part_die->offset,
			 (splay_tree_value) part_die);
      part_die = xmalloc (sizeof (struct partial_die_info));

      /* For some DIEs we want to follow their children (if any).  */
      if (last_die->tag == DW_TAG_namespace
	  || last_die->tag == DW_TAG_enumeration_type
	  || last_die->tag == DW_TAG_class_type
	  || last_die->tag == DW_TAG_structure_type)
	{
	  if (last_die->has_children)
	    {
	      nesting_level++;
	      parent_die = last_die;
	      continue;
	    }
	}

      /* Otherwise we skip to the next sibling, if any.  */
      info_ptr = locate_pdi_sibling (last_die, info_ptr, abfd, cu);

      /* Back to the top, do it again.  */
    }
}

d4288 1
a4288 1
load_partial_die (struct partial_die_info *part_die, bfd *abfd,
d4294 2
a4299 3

  part_die->offset = info_ptr - dwarf_info_buffer;

d4311 1
a4311 1

d4371 2
a4372 2
	  part_die->has_specification = 1;
	  part_die->spec_attr = attr;
a4387 42
  /* When using the GNU linker, .gnu.linkonce. sections are used to
     eliminate duplicate copies of functions and vtables and such.
     The linker will arbitrarily choose one and discard the others.
     The AT_*_pc values for such functions refer to local labels in
     these sections.  If the section from that file was discarded, the
     labels are not in the output, so the relocs get a value of 0.
     If this is a discarded function, mark the pc bounds as invalid,
     so that GDB will ignore it.  */
  if (has_low_pc_attr && has_high_pc_attr
      && part_die->lowpc < part_die->highpc
      && (part_die->lowpc != 0
	  || (bfd_get_file_flags (abfd) & HAS_RELOC)))
    part_die->has_pc_info = 1;
  return info_ptr;
}

/* Like load_partial_die, but also patch up the partial DIE's name
   according to its specification if necessary.  */
/* FIXME: I've over-eagerly removed calls to this.  The fixup has to happen
   sometime.  */
static void
read_partial_die (struct partial_die_info *part_die, bfd *abfd,
		  char *info_ptr, struct dwarf2_cu *cu)
{
  struct partial_die_info *lookup_die = NULL;

  if (cu->partial_dies)
    {
      splay_tree_node node;
      node = splay_tree_lookup (cu->partial_dies,
				info_ptr - dwarf_info_buffer);
      if (node == NULL)
	internal_error (__FILE__, __LINE__,
			"could not find partial DIE in cache\n");

      lookup_die = (struct partial_die_info *) node->value;

      *part_die = *lookup_die;
    }
  else
    info_ptr = load_partial_die (part_die, abfd, info_ptr, cu);

d4391 1
a4391 1
  if (part_die->has_specification && part_die->name == NULL)
d4397 1
a4397 1
	+ dwarf2_get_ref_die_offset (&part_die->spec_attr, cu);
d4408 15
@


1.135.2.2
log
@	* dwarf2read.c (find_partial_die, fixup_partial_die): New functions,
	broken out from read_partial_die.
	(read_partial_die): Remove function.
	(dwarf2_build_psymtabs_hard): Update comments.
	(scan_partial_symbols): Use the new functions.  Reduce copying of
	partial DIEs.
@
text
@d692 2
a693 5
static struct partial_die_info *find_partial_die (unsigned long,
						  struct dwarf2_cu *);

static void fixup_partial_die (struct partial_die_info *,
			       struct dwarf2_cu *);
d1202 1
a1202 1
     read_comp_unit_head and load_partial_die) can really know whether
d1208 1
a1208 1
     read off the end of the buffer.  load_partial_die is similarly
d1353 1
a1353 1
  struct partial_die_info *pdi_p;
d1359 2
a1360 1
  pdi_p = find_partial_die (info_ptr - dwarf_info_buffer, cu);
d1364 2
a1365 1
      fixup_partial_die (pdi_p, cu);
d1371 2
a1372 2
      if (pdi_p->name != NULL || pdi_p->tag == DW_TAG_namespace
	  || pdi_p->tag == DW_TAG_enumeration_type)
d1374 1
a1374 1
	  switch (pdi_p->tag)
d1377 1
a1377 1
	      if (pdi_p->has_pc_info)
d1379 1
a1379 1
		  if (pdi_p->lowpc < *lowpc)
d1381 1
a1381 1
		      *lowpc = pdi_p->lowpc;
d1383 1
a1383 1
		  if (pdi_p->highpc > *highpc)
d1385 1
a1385 1
		      *highpc = pdi_p->highpc;
d1387 1
a1387 1
		  if (!pdi_p->is_declaration)
d1389 1
a1389 1
		      add_partial_symbol (pdi_p, cu, namespace);
d1396 1
a1396 1
	      if (!pdi_p->is_declaration)
d1398 1
a1398 1
		  add_partial_symbol (pdi_p, cu, namespace);
d1403 1
a1403 1
	      if (!pdi_p->is_declaration)
d1405 1
a1405 1
		  info_ptr = add_partial_structure (pdi_p, info_ptr, cu,
d1410 1
a1410 1
	      if (!pdi_p->is_declaration)
d1412 1
a1412 1
		  info_ptr = add_partial_enumeration (pdi_p, info_ptr, cu,
d1420 1
a1420 1
	      add_partial_symbol (pdi_p, cu, namespace);
d1428 1
a1428 1
	      info_ptr = add_partial_namespace (pdi_p, info_ptr, lowpc, highpc,
d1437 1
a1437 1
      if (pdi_p->tag == 0)
d1445 1
a1445 1
	 only pdi_p->tag but also whether or not pdi_p->name is NULL) that
d1448 4
d1733 1
d4562 5
a4566 2
static struct partial_die_info *
find_partial_die (unsigned long offset, struct dwarf2_cu *cu)
a4568 1
  splay_tree_node node;
d4570 10
a4579 4
  node = splay_tree_lookup (cu->partial_dies, offset);
  if (node == NULL)
    internal_error (__FILE__, __LINE__,
		    "could not find partial DIE in cache\n");
d4581 4
a4584 2
  return (struct partial_die_info *) node->value;
}
a4585 4
static void
fixup_partial_die (struct partial_die_info *part_die,
		   struct dwarf2_cu *cu)
{
d4591 2
a4592 5
      struct partial_die_info *spec_die;
      unsigned long spec_offset;

      spec_offset = dwarf2_get_ref_die_offset (&part_die->spec_attr, cu);
      spec_die = find_partial_die (spec_offset, cu);
d4594 4
a4597 1
      if (spec_die->name)
d4599 1
a4599 1
	  part_die->name = spec_die->name;
d4602 2
a4603 2
	  if (spec_die->is_external)
	    part_die->is_external = spec_die->is_external;
@


1.135.2.3
log
@	* dwarf2read.c (skip_leb128, peek_die_abbrev, skip_one_die)
	(skip_children): New functions.
	(locate_pdi_sibling): Call skip_children.
	(load_partial_dies): Use peek_die_abbrev and skip_one_die.
@
text
@a736 2
static char *skip_leb128 (bfd *, char *);

a1757 133
static struct abbrev_info *
peek_die_abbrev (char *info_ptr, int *bytes_read, struct dwarf2_cu *cu)
{
  bfd *abfd = cu->objfile->obfd;
  unsigned int abbrev_number;
  struct abbrev_info *abbrev;

  abbrev_number = read_unsigned_leb128 (abfd, info_ptr, bytes_read);

  if (abbrev_number == 0)
    return NULL;

  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
  if (!abbrev)
    {
      error ("Dwarf Error: Could not find abbrev number %d [in module %s]", abbrev_number,
		      bfd_get_filename (abfd));
    }

  return abbrev;
}

static char *skip_one_die (char *info_ptr, struct abbrev_info *abbrev,
			   struct dwarf2_cu *cu);

static char *
skip_children (char *info_ptr, struct dwarf2_cu *cu)
{
  struct abbrev_info *abbrev;
  unsigned int bytes_read;

  /* Skip a series of DIEs (and their children) starting at INFO_PTR.
     Continue until we run into one without a tag; return whatever
     follows it.  */

  while (1)
    {
      abbrev = peek_die_abbrev (info_ptr, &bytes_read, cu);
      if (abbrev == NULL)
	return info_ptr + bytes_read;
      else
	info_ptr = skip_one_die (info_ptr + bytes_read, abbrev, cu);
    }
}


static char *
skip_one_die (char *info_ptr, struct abbrev_info *abbrev,
	      struct dwarf2_cu *cu)
{
  unsigned int bytes_read;
  struct attribute attr;
  bfd *abfd = cu->objfile->obfd;
  unsigned int form, i;

  for (i = 0; i < abbrev->num_attrs; i++)
    {
      if (abbrev->attrs[i].name == DW_AT_sibling)
	{
	  read_attribute (&attr, &abbrev->attrs[i],
			  abfd, info_ptr, cu);
	  if (attr.form == DW_FORM_ref_addr)
	    complaint (&symfile_complaints, "ignoring absolute DW_AT_sibling");
	  else
	    return dwarf_info_buffer + dwarf2_get_ref_die_offset (&attr, cu);
	}
      form = abbrev->attrs[i].form;
    top:
      switch (form)
	{
	case DW_FORM_addr:
	case DW_FORM_ref_addr:
	  info_ptr += cu->header.addr_size;
	  break;
	case DW_FORM_block2:
	  info_ptr += 2 + read_2_bytes (abfd, info_ptr);
	  break;
	case DW_FORM_block4:
	  info_ptr += 4 + read_4_bytes (abfd, info_ptr);
	  break;
	case DW_FORM_data2:
	case DW_FORM_ref2:
	  info_ptr += 2;
	  break;
	case DW_FORM_data4:
	case DW_FORM_ref4:
	  info_ptr += 4;
	  break;
	case DW_FORM_data8:
	case DW_FORM_ref8:
	  info_ptr += 8;
	  break;
	case DW_FORM_string:
	  read_string (abfd, info_ptr, &bytes_read);
	  info_ptr += bytes_read;
	  break;
	case DW_FORM_strp:
	  info_ptr += cu->header.offset_size;
	  break;
	case DW_FORM_block:
	  info_ptr += read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
	  info_ptr += bytes_read;
	  break;
	case DW_FORM_block1:
	  info_ptr += 1 + read_1_byte (abfd, info_ptr);
	  break;
	case DW_FORM_data1:
	case DW_FORM_ref1:
	case DW_FORM_flag:
	  info_ptr += 1;
	  break;
	case DW_FORM_sdata:
	case DW_FORM_udata:
	case DW_FORM_ref_udata:
	  info_ptr = skip_leb128 (abfd, info_ptr);
	  break;
	case DW_FORM_indirect:
	  form = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);
	  info_ptr += bytes_read;
	  goto top;
	default:
	  error ("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]",
		 dwarf_form_name (form),
		 bfd_get_filename (abfd));
	}
    }

  if (abbrev->has_children)
    return skip_children (info_ptr, cu);
  else
    return info_ptr;
}

d1765 5
d1775 7
a1781 4
  /* Do we know the sibling already?  */
  
  if (orig_pdi->sibling)
    return orig_pdi->sibling;
d1783 1
a1783 1
  /* Skip the children the long way.  */
d1785 5
a1789 1
  return skip_children (info_ptr, cu);
a4355 2
  struct abbrev_info *abbrev;
  unsigned int bytes_read;
d4371 2
a4372 1
      abbrev = peek_die_abbrev (info_ptr, &bytes_read, cu);
d4374 1
a4374 1
      if (abbrev == NULL)
a4380 1
	  info_ptr += bytes_read;
d4387 5
a4391 5
      if (!is_type_tag (abbrev->tag)
	  && abbrev->tag != DW_TAG_enumerator
	  && abbrev->tag != DW_TAG_subprogram
	  && abbrev->tag != DW_TAG_variable
	  && abbrev->tag != DW_TAG_namespace)
a4392 1
	  // printf ("Wasted DIE\n");
d4394 1
a4394 1
	  info_ptr = skip_one_die (info_ptr + bytes_read, abbrev, cu);
a4397 3
      //      fprintf_unfiltered (gdb_stderr, "Loading DIE %x\n", info_ptr - dwarf_info_buffer);
      info_ptr = load_partial_die (part_die, abfd, info_ptr, cu);

a5100 14
}

static char *
skip_leb128 (bfd *abfd, char *buf)
{
  int byte;

  while (1)
    {
      byte = bfd_get_8 (abfd, (bfd_byte *) buf);
      buf++;
      if ((byte & 128) == 0)
	return buf;
    }
@


1.135.2.4
log
@	* dwarf2read.c (struct dwarf2_cu): Add partial_die_obstack.
	(splay_tree_obstack_allocate, splay_tree_obstack_deallocate): New
	functions.
	(dwarf2_build_psymtabs_hard): Use splay_tree_new_with_allocator
	and obstack_free to manage partial_dies.
	(load_partial_dies): Allocate partial DIEs on the obstack.  Don't
	initialize the splay tree here.
@
text
@a263 1
  struct obstack partial_die_obstack;
a941 14
/* Allocation function for the libiberty splay tree which uses an obstack.  */
static void *
splay_tree_obstack_allocate (int size, void *data)
{
  return obstack_alloc ((struct obstack *) data, size);
}

/* Trivial deallocation function for the libiberty splay tree.  */
static void
splay_tree_obstack_deallocate (void *object, void *data)
{
  return;
}

a1303 7
	  obstack_init (&cu.partial_die_obstack);
	  cu.partial_dies
	    = splay_tree_new_with_allocator (splay_tree_compare_ints, NULL,
					     NULL, splay_tree_obstack_allocate,
					     splay_tree_obstack_deallocate,
					     &cu.partial_die_obstack);

d1309 1
a1309 2
	  cu.partial_dies = NULL;
	  obstack_free (&cu.partial_die_obstack, NULL);
d4489 4
a4492 2
  part_die = obstack_alloc (&cu->partial_die_obstack,
			    sizeof (struct partial_die_info));
d4502 1
a4502 2
	      /* This was the last thing allocated.  */
	      obstack_free (&cu->partial_die_obstack, part_die);
d4542 1
a4542 3

      part_die = obstack_alloc (&cu->partial_die_obstack,
				sizeof (struct partial_die_info));
@


1.135.2.5
log
@	* dwarf2read.c (struct partial_die_info): Use bitfields and
	rearrange members for packing.  Replace spec_attr with spec_offset.
	(load_partial_dies): Only follow structures for C++.
	(load_partial_die): Use memset.  Save specification attributes
	only as offsets.
	(fixup_partial_die): Adjust to use spec_offset.
@
text
@d394 5
d400 1
a400 8
    unsigned int abbrev : 16;
    unsigned int language : 8;
    unsigned int has_children : 1;
    unsigned int is_external : 1;
    unsigned int is_declaration : 1;
    unsigned int has_type : 1;
    unsigned int has_specification : 1;
    unsigned int has_pc_info : 1;
d402 1
a402 1
    struct dwarf_block *locdesc;
d405 2
d408 1
a408 1
    unsigned int spec_offset;
d4568 5
a4572 10
      /* For some DIEs we want to follow their children (if any).  We do
         not normally follow the children of structures; do so for C++
         so that we can use method physnames to infer fully qualified
         type names.  */
      if (last_die->has_children
	  && (last_die->tag == DW_TAG_namespace
	      || last_die->tag == DW_TAG_enumeration_type
	      || (cu->language == language_cplus
		  && (last_die->tag == DW_TAG_class_type
		      || last_die->tag == DW_TAG_structure_type))))
d4574 6
a4579 3
	  nesting_level++;
	  parent_die = last_die;
	  continue;
d4601 1
a4601 1
  memset (part_die, 0, sizeof (struct partial_die_info));
d4677 1
a4677 1
	  part_die->spec_offset = dwarf2_get_ref_die_offset (&attr, cu);
d4732 1
a4732 1
  if (part_die->name == NULL && part_die->has_specification)
d4735 1
d4737 2
a4738 1
      spec_die = find_partial_die (part_die->spec_offset, cu);
@


1.135.2.6
log
@	* Makefile.in (hashtab_h): Add.
	(dwarf2read.o): Update dependencies.
	* dwarf2read.c: Include "hashtab.h".
	(struct dwarf2_cu): Change partial_dies to an htab_t.
	(hash_obstack_allocate, partial_die_hash, partial_die_eq): New
	functions.
	(dwarf2_build_psymtabs_hard): Call htab_create_alloc_ex.
	(load_partial_dies): Call htab_find_slot_with_hash.
	(find_partial_die): Call htab_find_with_hash.
@
text
@a47 1
#include "hashtab.h"
d263 1
a263 1
  htab_t partial_dies;
a956 24
static void *
hash_obstack_allocate (void *data, size_t size, size_t count)
{
  unsigned int total = size * count;
  void *ptr = obstack_alloc ((struct obstack *) data, total);
  memset (ptr, 0, total);
  return ptr;
}

static hashval_t
partial_die_hash (const void *item)
{
  const struct partial_die_info *part_die = item;
  return part_die->offset;
}

static int
partial_die_eq (const void *item_lhs, const void *item_rhs)
{
  const struct partial_die_info *part_die_lhs = item_lhs;
  const struct partial_die_info *part_die_rhs = item_rhs;
  return part_die_lhs->offset == part_die_rhs->offset;
}

d1321 4
a1324 6
	    = htab_create_alloc_ex (29, partial_die_hash,
				    partial_die_eq,
				    NULL,
				    &cu.partial_die_obstack,
				    hash_obstack_allocate,
				    splay_tree_obstack_deallocate);
a4503 1
  void **slot;
d4562 2
a4563 4
      slot = htab_find_slot_with_hash (cu->partial_dies, part_die,
				       part_die->offset, INSERT);
      // gdb_assert (*slot == NULL);
      *slot = part_die;
d4717 1
a4717 1
  struct partial_die_info part_die;
d4719 2
a4720 4
  part_die.offset = offset;
  lookup_die = htab_find_with_hash (cu->partial_dies, &part_die, offset);
  
  if (lookup_die == NULL)
d4724 1
a4724 1
  return lookup_die;
@


1.135.2.7
log
@	* dwarf2read.c (struct dwarf2_cu): Add abbrev_obstack.
	(struct abbrev_info): Shorten two int flags.
	(dwarf_alloc_abbrev): Take a CU argument.
	(dwarf2_build_psymtabs_hard): Call dwarf2_empty_abbrev_table
	each time through the loop.  Update cleanup argument.
	(psymtab_to_symtab_1): Update cleanup argument.
	(dwarf2_read_abbrevs, dwarf2_alloc_abbrev): Allocate on the
	abbrev_obstack.
	(dwarf2_empty_abbrev_table): Just call obstack_free.
@
text
@a265 2

  struct obstack abbrev_obstack;
d317 2
a318 2
    unsigned short has_children;		/* boolean */
    unsigned short num_attrs;	/* number of attributes */
d926 1
a926 1
static struct abbrev_info *dwarf_alloc_abbrev (struct dwarf2_cu *);
a1259 1
      struct cleanup *back_to_inner;
d1299 1
a1299 1
      back_to_inner = make_cleanup (dwarf2_empty_abbrev_table, &cu);
a1389 2

      do_cleanups (back_to_inner);
d2044 1
a2044 1
  make_cleanup (dwarf2_empty_abbrev_table, &cu);
a4352 2
  struct attr_abbrev *cur_attrs;
  unsigned int allocated_attrs;
a4354 1
  obstack_init (&cu->abbrev_obstack);
a4361 3
  allocated_attrs = ATTR_ALLOC_CHUNK;
  cur_attrs = xmalloc (allocated_attrs * sizeof (struct attr_abbrev));
  
d4365 1
a4365 1
      cur_abbrev = dwarf_alloc_abbrev (cu);
d4381 1
a4381 1
	  if (cur_abbrev->num_attrs == allocated_attrs)
d4383 4
a4386 4
	      allocated_attrs += ATTR_ALLOC_CHUNK;
	      cur_attrs
		= xrealloc (cur_attrs, (allocated_attrs
					* sizeof (struct attr_abbrev)));
d4388 2
a4389 2
	  cur_attrs[cur_abbrev->num_attrs].name = abbrev_name;
	  cur_attrs[cur_abbrev->num_attrs++].form = abbrev_form;
a4395 6
      cur_abbrev->attrs = obstack_alloc (&cu->abbrev_obstack,
					 (cur_abbrev->num_attrs
					  * sizeof (struct attr_abbrev)));
      memcpy (cur_abbrev->attrs, cur_attrs,
	      cur_abbrev->num_attrs * sizeof (struct attr_abbrev));

a4414 2

  xfree (cur_attrs);
d4420 1
a4420 1
dwarf2_empty_abbrev_table (void *ptr_to_cu)
d4422 3
a4424 1
  struct dwarf2_cu *cu = ptr_to_cu;
d4426 15
a4440 1
  obstack_free (&cu->abbrev_obstack, NULL);
d7960 1
a7960 1
dwarf_alloc_abbrev (struct dwarf2_cu *cu)
d7964 1
a7964 2
  abbrev = (struct abbrev_info *)
    obstack_alloc (&cu->abbrev_obstack, sizeof (struct abbrev_info));
@


1.135.2.8
log
@	* dwarf2read.c (dwarf2_build_psymtabs_hard): Estimate the initial
	size of the hash table.
@
text
@d1349 1
a1349 2
	    = htab_create_alloc_ex (cu.header.length / 12,
				    partial_die_hash,
@


1.135.2.9
log
@	* dwarf2read.c (load_partial_dies): Follow unions.  Follow
	aggregates for all non-C languages.
@
text
@d4602 4
a4605 4
      /* For some DIEs we want to follow their children (if any).  For C
         we have no reason to follow the children of structures; for other
	 languages we have to, both so that we can get at method physnames
	 to infer fully qualified class names, and for DW_AT_specification.  */
d4609 1
a4609 1
	      || (cu->language != language_c
d4611 1
a4611 2
		      || last_die->tag == DW_TAG_structure_type
		      || last_die->tag == DW_TAG_union_type))))
@


1.135.2.10
log
@	* dwarf2read.c (partial_determine_prefix)
	(partial_determine_prefix_aux): New functions.
	(add_partial_symbol): Call partial_determine_prefix.
	(add_partial_structure): Remove workaround for DW_AT_specification.
	(load_partial_die): Save DW_AT_extension.
	(determine_prefix_aux): Reuse the return value of dwarf2_name.
@
text
@a790 4
static char *partial_determine_prefix (struct partial_die_info *die, struct dwarf2_cu *);

static char *partial_determine_prefix_aux (struct partial_die_info *die, struct dwarf2_cu *);

a1521 1
  const char *my_prefix;
d1529 2
a1530 8

  if (pdi->spec_offset
      && pdi_needs_namespace (pdi->tag, "foo"))
    my_prefix = partial_determine_prefix (pdi, cu);
  else
    my_prefix = namespace;

  if (pdi_needs_namespace (pdi->tag, my_prefix))
d1532 2
a1533 2
      actual_name = alloca (strlen (pdi->name) + 2 + strlen (my_prefix) + 1);
      strcpy (actual_name, my_prefix);
a1537 3
  if (my_prefix)
    free (my_prefix);

d1722 1
a1722 2
    info_ptr = scan_partial_symbols (pdi->die_child->offset + dwarf_info_buffer,
				     lowpc, highpc, cu, full_name);
d1738 1
a1738 1
      && namespace == NULL
d1753 15
a4712 1
	case DW_AT_extension:
d6493 1
a6493 1
		retval = typename_concat (parent_prefix, parent_name);
a6502 64
	break;
      default:
	retval = parent_prefix;
	break;
      }

      if (retval != parent_prefix)
	xfree (parent_prefix);
      return retval;
    }
}

/* Likewise for partial DIEs.  */

static char *
partial_determine_prefix (struct partial_die_info *die, struct dwarf2_cu *cu)
{
  char *prefix = partial_determine_prefix_aux (die, cu);

  return prefix ? prefix : xstrdup ("");
}

/* Return the name of the namespace/class that DIE is defined
   within, or NULL if we can't tell.  The caller should xfree the
   result.  */

static char *
partial_determine_prefix_aux (struct partial_die_info *die, struct dwarf2_cu *cu)
{
  struct partial_die_info *parent;

  if (cu->language != language_cplus)
    return NULL;

  if (die->spec_offset)
    die = find_partial_die (die->spec_offset, cu);

  parent = die->die_parent;

  if (parent == NULL)
    {
      return (processing_has_namespace_info ? xstrdup ("") : NULL);
    }
  else
    {
      char *parent_prefix = partial_determine_prefix_aux (parent, cu);
      char *retval;

      fixup_partial_die (parent, cu);

      switch (parent->tag) {
      case DW_TAG_namespace:
	if (parent->name != NULL)
	  retval = typename_concat (parent_prefix, parent->name);
	else
	  retval = typename_concat (parent_prefix, "(anonymous namespace)");
	break;
      case DW_TAG_class_type:
      case DW_TAG_structure_type:
	if (parent->name != NULL)
	  retval = typename_concat (parent_prefix, parent->name);
	else
	  retval = typename_concat (parent_prefix,
				    "<<anonymous class>>");
@


1.135.2.11
log
@	* dwarf2read.c (splay_tree_obstack_allocate): Disable.
	(add_partial_symbol): Fix a warning.
	(fixup_partial_die): Recurse if necessary.
@
text
@a949 1
#if 0
a955 1
#endif
d1550 1
a1550 1
    free ((char *) my_prefix);
a4776 2

      fixup_partial_die (spec_die, cu);
@


1.135.2.12
log
@	* dwarf2read.c (peek_die_abbrev): Add prototype.
	(load_partial_die): Take an abbrev and its uleb128 length as
	arguments.
	(dwarf2_build_psymtabs_hard): Adjust call to load_partial_die.
	(load_partial_dies): Likewise.
@
text
@a687 2
static struct abbrev_info *peek_die_abbrev (char *, int *, struct dwarf2_cu *);

a693 1
			       struct abbrev_info *abbrev, unsigned int,
a1269 3
      struct abbrev_info *abbrev;
      unsigned int bytes_read;

d1311 2
a1312 3
      abbrev = peek_die_abbrev (info_ptr, &bytes_read, &cu);
      info_ptr = load_partial_die (&comp_unit_die, abbrev, bytes_read,
				   abfd, info_ptr, &cu);
d4581 1
a4581 2
      info_ptr = load_partial_die (part_die, abbrev, bytes_read,
				   abfd, info_ptr, cu);
d4631 1
a4631 3
load_partial_die (struct partial_die_info *part_die,
		  struct abbrev_info *abbrev,
		  unsigned int abbrev_len, bfd *abfd,
d4634 2
a4635 1
  unsigned int bytes_read, i;
d4644 4
a4647 1
  info_ptr += abbrev_len;
d4649 6
a4654 2
  if (abbrev == NULL)
    return info_ptr;
d4658 1
a4658 1
  part_die->abbrev = abbrev->number;
@


1.135.2.13
log
@	* dwarf2read.c (scan_partial_symbols): Don't return anything.  Take
	a DIE argument instead of an info_ptr.
	(add_partial_namespace, add_partial_structure)
	add_partial_enumeration): Likewise.
	(load_partial_dies): Return the first interesting DIE.
	Do not add DIEs to the hash table if we aren't going to look them
	up.
	(dwarf2_build_psymtabs_hard): Adjust call to scan_partial_symbols.
@
text
@d648 3
a650 4
static void scan_partial_symbols (struct partial_die_info *,
				  CORE_ADDR *, CORE_ADDR *,
				  struct dwarf2_cu *,
				  const char *namespace);
d657 15
a671 12
static void add_partial_namespace (struct partial_die_info *pdi,
				   CORE_ADDR *lowpc, CORE_ADDR *highpc,
				   struct dwarf2_cu *cu,
				   const char *namespace);

static void add_partial_structure (struct partial_die_info *struct_pdi,
				   struct dwarf2_cu *cu,
				   const char *namespace);

static void add_partial_enumeration (struct partial_die_info *enum_pdi,
				     struct dwarf2_cu *cu,
				     const char *namespace);
d693 1
a693 2
static struct partial_die_info *load_partial_dies (bfd *, char *,
						   struct dwarf2_cu *);
a1356 2
	  struct partial_die_info *first_die;

d1370 1
a1370 1
	  first_die = load_partial_dies (abfd, info_ptr, &cu);
d1372 2
a1373 1
	  scan_partial_symbols (first_die, &lowpc, &highpc, &cu, NULL);
d1420 2
a1421 2
static void
scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,
d1433 1
a1433 1
  pdi_p = first_die;
d1477 2
a1478 1
		  add_partial_structure (pdi_p, cu, namespace);
d1483 4
a1486 1
		add_partial_enumeration (pdi_p, cu, namespace);
d1500 2
a1501 1
	      add_partial_namespace (pdi_p, lowpc, highpc, cu, namespace);
d1524 2
d1713 2
a1714 2
static void
add_partial_namespace (struct partial_die_info *pdi,
d1745 4
a1748 2
    scan_partial_symbols (pdi->die_child,
			  lowpc, highpc, cu, full_name);
d1753 2
a1754 2
static void
add_partial_structure (struct partial_die_info *struct_pdi,
d1795 2
d1801 2
a1802 2
static void
add_partial_enumeration (struct partial_die_info *enum_pdi,
d1821 2
d4537 1
a4537 1
static struct partial_die_info *
d4541 1
a4541 1
  struct partial_die_info *parent_die, *last_die, *first_die = NULL;
d4544 1
d4566 1
a4566 1
	      return first_die;
d4603 5
a4607 37
      if (first_die == NULL)
	first_die = part_die;

      /* Maybe add the DIE to the hash table.  Not all DIEs need that
	 we find interesting need to be in the hash table, because we
	 also have the parent/sibling/child chains; only those that we
	 might refer to by offset later during partial symbol
	 reading.

	 For now this means things that might have be the target of a
	 DW_AT_specification, DW_AT_abstract_origin, or
	 DW_AT_extension.  DW_AT_extension will refer only to
	 namespaces; DW_AT_abstract_origin refers to functions (and
	 many things under the function DIE, but we do not recurse
	 into function DIEs during partial symbol reading) and
	 possibly variables as well; DW_AT_specification refers to
	 declarations.  Declarations ought to have the DW_AT_declaration
	 flag.  It happens that GCC forgets to put it in sometimes, but
	 only for functions, not for types.

	 Adding more things than necessary to the hash table is harmless
	 except for the performance cost.  Adding too few will result in
	 explicit internal errors in find_partial_die.  */

      if (abbrev->tag == DW_TAG_subprogram
	  || abbrev->tag == DW_TAG_variable
	  || abbrev->tag == DW_TAG_namespace
	  || part_die->is_declaration)
	{
	  void **slot;

	  //      fprintf_unfiltered (gdb_stderr, "Inserting DIE %x\n", part_die->offset);
	  slot = htab_find_slot_with_hash (cu->partial_dies, part_die,
					   part_die->offset, INSERT);
	  // gdb_assert (*slot == NULL);
	  *slot = part_die;
	}
@


1.135.2.14
log
@	* dwarf2read.c (maybe_specification_partial_die): Removed.
	(is_type_tag_for_partial): Renamed from is_type_tag.  Remove
	some tags.
	(load_partial_dies): Call is_type_tag_for_partial.  Handle simple
	DIEs early.
@
text
@d4465 1
a4465 2
/* Returns nonzero if TAG represents a type that we might generate a partial
   symbol for.  */
d4468 1
a4468 1
is_type_tag_for_partial (int tag)
a4471 3
#if 0
    /* Some types that would be reasonable to generate partial symbols for,
       that we don't at present.  */
a4472 7
    case DW_TAG_file_type:
    case DW_TAG_ptr_to_member_type:
    case DW_TAG_set_type:
    case DW_TAG_string_type:
    case DW_TAG_subroutine_type:
#endif
    case DW_TAG_base_type:
d4475 3
d4479 4
d4484 5
a4489 1
    case DW_TAG_union_type:
d4496 26
d4561 1
a4561 1
      if (!is_type_tag_for_partial (abbrev->tag)
a4575 56

      /* This two-pass algorithm for processing partial symbols has a high
	 cost in cache pressure.  Thus, handle some trivial cases here
	 which cover the majority of C partial symbols.  DIEs which
         neither have specification tags in them, nor could have specification
         tags elsewhere pointing at them, can simply be processed and
	 discarded.

	 This segment is also optional; scan_partial_symbols and
	 add_partial_symbol will handle these DIEs if we simply chain
	 them in normally.  When compilers which do not emit large
         quantities of duplicate debug information are more common,
         this code can probably be removed.  */

      /* Any complete simple types at the top level (pretty much all
	 of them, for a language without namespaces), can be processed
	 directly.  */
      if (parent_die == NULL
	  && part_die->has_specification == 0
	  && part_die->is_declaration == 0
	  && (part_die->tag == DW_TAG_typedef
	      || part_die->tag == DW_TAG_base_type
	      || part_die->tag == DW_TAG_subrange_type
	      || part_die->tag == DW_TAG_enumeration_type))
	{
	  add_psymbol_to_list (part_die->name, strlen (part_die->name),
			       VAR_DOMAIN, LOC_TYPEDEF,
			       &cu->objfile->static_psymbols,
			       0, (CORE_ADDR) 0, cu->language, cu->objfile);
	  info_ptr = locate_pdi_sibling (part_die, info_ptr, abfd, cu);
	  continue;
	}

      /* If we're at the second level, and we're an enumerator, and
	 our parent has no specification (meaning possibly lives in a
	 namespace elsewhere), then we can add the partial symbol now
	 instead of queueing it.  */
      if (part_die->tag == DW_TAG_enumerator
	  && parent_die != NULL
	  && parent_die->die_parent == NULL
	  && parent_die->tag == DW_TAG_enumeration_type
	  && parent_die->has_specification == 0)
	{
	  if (part_die->name == NULL)
	    complaint (&symfile_complaints, "malformed enumerator DIE ignored");
	  else
	    add_psymbol_to_list (part_die->name, strlen (part_die->name),
				 VAR_DOMAIN, LOC_CONST,
				 cu->language == language_cplus
				 ? &cu->objfile->global_psymbols
				 : &cu->objfile->static_psymbols,
				 0, (CORE_ADDR) 0, cu->language, cu->objfile);

	  info_ptr = locate_pdi_sibling (part_die, info_ptr, abfd, cu);
	  continue;
	}
@


1.135.2.15
log
@	* dwarf2read.c (load_partial_dies): Check for NULL name before
	adding types.
@
text
@d4575 4
a4578 5
	  if (part_die->name != NULL)
	    add_psymbol_to_list (part_die->name, strlen (part_die->name),
				 VAR_DOMAIN, LOC_TYPEDEF,
				 &cu->objfile->static_psymbols,
				 0, (CORE_ADDR) 0, cu->language, cu->objfile);
@


1.135.2.16
log
@	* dwarf2read.c (struct partial_die_info): Add full_name.
	(scan_partial_symbols, add_partial_symbol, add_partial_structure)
	(add_partial_enumeration): Change namespace argument to
	have_namespace_info flag.  Move DW_TAG_namespace handling to
	add_partial_symbol.  Update comments.
	(pdi_needs_namespace): Remove namespace argument.  Handle
	DW_TAG_namespace.
	(partial_determine_prefix, partial_determine_prefix_aux): Remove.
	(dwarf2_build_psymtabs_hard): Update call to scan_partial_symbols.
	(partial_die_full_name): New function.
	(load_partial_die): Correct comment formatting.  Don't handle
	DW_TAG_enumeration_type.
	(load_partial_dies): Correct comment formatting.
@
text
@a406 1
    char *full_name;
d650 2
a651 1
				  struct dwarf2_cu *, int);
d654 1
a654 1
				int have_namespace_info);
d656 1
a656 1
static int pdi_needs_namespace (enum dwarf_tag tag);
d660 2
a661 1
				   struct dwarf2_cu *cu);
d665 1
a665 1
				   int have_namespace_info);
d669 1
a669 1
				     int have_namespace_info);
d793 4
d1373 1
a1373 1
	  scan_partial_symbols (first_die, &lowpc, &highpc, &cu, 0);
d1423 1
a1423 1
		      int have_namespace_info)
d1461 1
a1461 1
		      add_partial_symbol (pdi_p, cu, have_namespace_info);
d1470 1
a1470 1
		  add_partial_symbol (pdi_p, cu, have_namespace_info);
d1477 1
a1477 1
		  add_partial_structure (pdi_p, cu, have_namespace_info);
d1482 1
a1482 1
		add_partial_enumeration (pdi_p, cu, have_namespace_info);
d1488 1
a1488 1
	      add_partial_symbol (pdi_p, cu, have_namespace_info);
d1494 3
a1496 2
	      have_namespace_info = 1;
	      add_partial_namespace (pdi_p, lowpc, highpc, cu);
d1503 11
a1513 1
      /* If the die has a sibling, skip to the sibling.  */
d1516 2
a1520 33
static char *
partial_die_full_name (struct partial_die_info *pdi, int allocate,
		       struct dwarf2_cu *cu)
{
  char *full_name, *parent_name;
  struct partial_die_info *real_parent;

  /* Note: this code could be micro-optimized.  We could avoid redoing
     the hash table lookup, which we've probably already done once,
     and we might be able to use real_pdi->full_name if there is a
     specification.  */

  if (pdi->has_specification)
    real_parent = find_partial_die (pdi->spec_offset, cu)->die_parent;
  else
    real_parent = pdi->die_parent;

  if (real_parent == NULL)
    return NULL;

  parent_name = real_parent->full_name;
  if (parent_name == NULL)
    parent_name = real_parent->name;

  if (allocate)
    full_name = obconcat (&cu->partial_die_obstack,
			  parent_name, "::", pdi->name);
  else
    full_name = concat (parent_name, "::", pdi->name, NULL);

  return full_name;
}

d1523 1
a1523 1
		    struct dwarf2_cu *cu, int have_namespace_info)
d1527 1
a1527 1
  char *actual_name;
a1530 1
  int free_actual_name = 0;
d1534 10
a1543 1
  if (pdi_needs_namespace (pdi->tag) && pdi->full_name == NULL)
d1545 4
a1548 16
      if (pdi->tag == DW_TAG_namespace
	  || pdi->tag == DW_TAG_class_type
	  || pdi->tag == DW_TAG_structure_type
	  || pdi->tag == DW_TAG_union_type)
	{
	  pdi->full_name = partial_die_full_name (pdi, 1, cu);
	  actual_name = pdi->full_name;
	}
      else
	{
	  actual_name = partial_die_full_name (pdi, 0, cu);
	  if (actual_name)
	    free_actual_name = 1;
	}
      if (actual_name == NULL)
	actual_name = pdi->name;
d1550 3
a1552 2
  else
    actual_name = pdi->name;
a1625 6
    case DW_TAG_namespace:
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   VAR_DOMAIN, LOC_TYPEDEF,
			   &objfile->global_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
      break;
d1671 1
a1671 1
      && have_namespace_info == 0
a1675 3

  if (free_actual_name)
    xfree (actual_name);
d1678 2
a1679 2
/* Determine whether a die of type TAG living in a C++ class or
   namespace needs to have the name of the scope prepended to the
d1683 1
a1683 1
pdi_needs_namespace (enum dwarf_tag tag)
d1685 3
a1689 1
    case DW_TAG_namespace:
d1709 1
a1709 1
		       struct dwarf2_cu *cu)
d1712 1
d1717 17
a1733 4
  if (pdi->name == NULL)
    pdi->name = "(anonymous namespace)";

  add_partial_symbol (pdi, cu, 1);
d1739 1
a1739 1
			  lowpc, highpc, cu, 1);
d1747 1
a1747 1
		       int have_namespace_info)
d1750 1
a1750 4
  char *full_name;

  if (struct_pdi->name == NULL)
    struct_pdi->name = "(anonymous class)";
d1753 2
a1754 1
      && have_namespace_info == 0
d1774 1
a1774 2
	      char *actual_class_name
		= class_name_from_physname (child_pdi->name);
d1776 1
a1776 7
		{
		  struct_pdi->full_name
		    = obsavestring (actual_class_name,
				    strlen (actual_class_name),
				    &cu->partial_die_obstack);
		  xfree (actual_class_name);
		}
d1784 2
a1785 1
  add_partial_symbol (struct_pdi, cu, have_namespace_info);
d1792 1
a1792 1
			 struct dwarf2_cu *cu, int have_namespace_info)
d1799 1
a1799 1
    add_partial_symbol (enum_pdi, cu, have_namespace_info);
d1807 1
a1807 1
	add_partial_symbol (pdi_p, cu, have_namespace_info);
d4551 6
a4556 6
      /* This two-pass algorithm for processing partial symbols has a
	 high cost in cache pressure.  Thus, handle some simple cases
	 here which cover the majority of C partial symbols.  DIEs
	 which neither have specification tags in them, nor could have
	 specification tags elsewhere pointing at them, can simply be
	 processed and discarded.
d4561 2
a4562 2
	 quantities of duplicate debug information are more common,
	 this code can probably be removed.  */
d4572 2
a4573 1
	      || part_die->tag == DW_TAG_subrange_type))
d4623 2
a4624 2
      /* Maybe add the DIE to the hash table.  Not all DIEs that we
	 find interesting need to be in the hash table, because we
d4626 2
a4627 1
	 might refer to by offset later during partial symbol reading.
d6559 64
@


1.135.2.17
log
@	* dwarf2read.c (partial_die_full_name): Remove allocate argument,
	always use concat.
	(add_partial_symbol): Copy the name from the psymbol.
@
text
@d1504 1
a1504 1
partial_die_full_name (struct partial_die_info *pdi,
d1507 1
a1507 1
  char *parent_name;
d1527 7
a1533 1
  return concat (parent_name, "::", pdi->name, NULL);
d1544 1
a1544 1
  const struct partial_symbol *psym = NULL, *psym2 = NULL;
d1546 1
a1546 1
  int built_actual_name = 0;
a1549 1
  actual_name = NULL;
d1552 8
a1559 9
      actual_name = partial_die_full_name (pdi, cu);
      if (actual_name)
	built_actual_name = 1;
    }

  if (actual_name == NULL)
    {
      if (pdi->full_name != NULL)
	actual_name = pdi->full_name;
d1561 6
d1569 2
d1639 4
a1642 4
      psym2 = add_psymbol_to_list (actual_name, strlen (actual_name),
				   VAR_DOMAIN, LOC_TYPEDEF,
				   &objfile->static_psymbols,
				   0, (CORE_ADDR) 0, cu->language, objfile);
d1645 4
a1648 4
      psym2 = add_psymbol_to_list (actual_name, strlen (actual_name),
				   VAR_DOMAIN, LOC_TYPEDEF,
				   &objfile->global_psymbols,
				   0, (CORE_ADDR) 0, cu->language, objfile);
d1660 6
a1665 6
      psym2 = add_psymbol_to_list (actual_name, strlen (actual_name),
				   STRUCT_DOMAIN, LOC_TYPEDEF,
				   cu->language == language_cplus
				   ? &objfile->global_psymbols
				   : &objfile->static_psymbols,
				   0, (CORE_ADDR) 0, cu->language, objfile);
d1677 6
a1682 6
      psym2 = add_psymbol_to_list (actual_name, strlen (actual_name),
				   VAR_DOMAIN, LOC_CONST,
				   cu->language == language_cplus
				   ? &objfile->global_psymbols
				   : &objfile->static_psymbols,
				   0, (CORE_ADDR) 0, cu->language, objfile);
a1693 2
  /* FIXME drow/2004-02-22: Why don't we do this for classes?  */

d1701 2
a1702 8
  if (built_actual_name)
    {
      /* psym2 should always be set in the built_actual_name case,
	 because the same set are used in pdi_needs_namespace.  See
	 FIXME above.  */
      pdi->full_name = SYMBOL_LINKAGE_NAME (psym2);
      xfree (actual_name);
    }
@


1.135.2.18
log
@	* dwarf2read.c (struct dwarf2_cu): Add read_in_chain and per_cu.
	(dwarf2_cu_tree): New variable.
	(struct dwarf2_per_cu_data): New type.
	(struct partial_die_info): Remove abbrev.  Make tag a bitfield.  Add
	full_name_set.
	(load_partial_dies): Take a flag indicating whether we are building
	a psymtab.
	(find_partial_die_in_comp_unit): Rename frome find_partial_die.
	(find_partial_die): New function to support inter-CU references.
	Return the CU of the found DIE.
	(splay_tree_obstack_allocate): Remove #if 0.
	(partial_read_comp_unit_head): New function, broken out from
	dwarf2_build_psymtabs_hard.
	(dwarf2_build_psymtabs_hard): Remove unused variable abbrev_ptr.
	Add the current CU to the splay tree if the tree already exists.
	Update call to load_partial_dies.
	(partial_die_full_name): Rewrite to support inter-CU references.
	(add_partial_symbol): Check and set pdi->full_name_set.
	(fixup_partial_die): Support inter-CU references.
	(dwarf2_find_containing_comp_unit, clear_per_cu_pointer)
	(load_comp_unit, create_comp_unit_tree, _initialize_dwarf2_read): New
	functions.
@
text
@a267 22

  /* When multiple dwarf2_cu structures are living in memory, this field
     chains them all together, so that they can be released efficiently.
     We will probably also want a generation counter so that most-recently-used
     compilation units are cached...  */
  struct dwarf2_per_cu_data *read_in_chain;

  /* Backchain to our per_cu entry if the tree has been built.  */
  struct dwarf2_per_cu_data *per_cu;
};

static const struct objfile_data *dwarf2_cu_tree;

struct dwarf2_per_cu_data
{
  unsigned long offset, length;
#if 0
  struct partial_symtab *psymtab;
#endif

  /* Set iff currently read in.  */
  struct dwarf2_cu *cu;
d396 1
d398 1
a398 1
    unsigned int tag : 16;
a405 1
    unsigned int full_name_set : 1;
d690 1
a690 1
static struct partial_die_info *load_partial_dies (bfd *, char *, int,
d698 1
a698 2
						  struct dwarf2_cu *,
						  struct dwarf2_cu **);
d947 1
a947 5
static struct dwarf2_per_cu_data *dwarf2_find_containing_comp_unit
  (unsigned long offset, struct dwarf2_cu *cu);

static void clear_per_cu_pointer (void *data);

d954 1
a1199 31
static char *
partial_read_comp_unit_head (struct comp_unit_head *header, char *info_ptr,
			     bfd *abfd)
{
  char *beg_of_comp_unit = info_ptr;

  info_ptr = read_comp_unit_head (header, info_ptr, abfd);

  if (header->version != 2)
    error ("Dwarf Error: wrong version in compilation unit header "
	   "(is %d, should be %d) [in module %s]", header->version,
	   2, bfd_get_filename (abfd));

  if (header->abbrev_offset >= dwarf_abbrev_size)
    error ("Dwarf Error: bad offset (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 6) [in module %s]",
	   (long) header->abbrev_offset,
	   (long) (beg_of_comp_unit - dwarf_info_buffer),
	   bfd_get_filename (abfd));

  if (beg_of_comp_unit + header->length + header->initial_length_size
      > dwarf_info_buffer + dwarf_info_size)
    error ("Dwarf Error: bad length (0x%lx) in compilation unit header "
	   "(offset 0x%lx + 0) [in module %s]",
	   (long) header->length,
	   (long) (beg_of_comp_unit - dwarf_info_buffer),
	   bfd_get_filename (abfd));

  return info_ptr;
}

d1209 1
a1209 1
  char *info_ptr;
a1214 1
  splay_tree cu_tree = NULL;
d1217 1
a1268 1
      struct dwarf2_per_cu_data *this_cu;
d1273 1
a1273 1
      info_ptr = partial_read_comp_unit_head (&cu.header, info_ptr, abfd);
d1275 22
a1345 24
      if (cu_tree == NULL)
	cu_tree = objfile_data (objfile, dwarf2_cu_tree);

      if (cu_tree != NULL)
	{
	  splay_tree_node node;
	  struct dwarf2_per_cu_data *per_cu;

	  node = splay_tree_lookup (cu_tree, cu.header.offset);
	  gdb_assert (node != NULL);
	  per_cu = (struct dwarf2_per_cu_data *) node->value;
	  cu.per_cu = per_cu;

	  /* Note that this is a pointer to our stack frame.  It will
	     be cleaned up in clear_per_cu_pointer when we finish with
	     this compilation unit.  */
	  per_cu->cu = &cu;
	}
      else
	cu.per_cu = NULL;

      make_cleanup (clear_per_cu_pointer, &cu);
      cu.read_in_chain = NULL;

d1366 1
a1366 1
	  first_die = load_partial_dies (abfd, info_ptr, 1, &cu);
a1407 121
/* Load the DIEs for a secondary CU into memory.  */

static void
load_comp_unit (struct dwarf2_per_cu_data *this_cu, struct objfile *objfile)
{
  bfd *abfd = objfile->obfd;
  char *info_ptr, *beg_of_comp_unit;
  struct partial_die_info comp_unit_die;
  struct dwarf2_cu *cu;
  struct abbrev_info *abbrev;
  unsigned int bytes_read;
  struct cleanup *back_to;

  info_ptr = dwarf_info_buffer + this_cu->offset;
  beg_of_comp_unit = info_ptr;

  cu = xmalloc (sizeof (struct dwarf2_cu));
  cu->objfile = objfile;
  info_ptr = partial_read_comp_unit_head (&cu->header, info_ptr, abfd);

  /* Complete the cu_header */
  cu->header.offset = beg_of_comp_unit - dwarf_info_buffer;
  cu->header.first_die_ptr = info_ptr;
  cu->header.cu_head_ptr = beg_of_comp_unit;

  cu->partial_dies = NULL;

  /* Read the abbrevs for this compilation unit into a table */
  dwarf2_read_abbrevs (abfd, cu);
  back_to = make_cleanup (dwarf2_empty_abbrev_table, cu);

  /* Read the compilation unit die */
  abbrev = peek_die_abbrev (info_ptr, &bytes_read, cu);
  info_ptr = load_partial_die (&comp_unit_die, abbrev, bytes_read,
			       abfd, info_ptr, cu);

  /* Set the language we're debugging */
  set_cu_language (comp_unit_die.language, cu);

  this_cu->cu = cu;
  cu->per_cu = this_cu;

  /* Check if comp unit has_children.
     If so, read the rest of the partial symbols from this comp unit.
     If not, there's no more debug_info for this comp unit. */
  if (comp_unit_die.has_children)
    {
      struct partial_die_info *first_die;

      obstack_init (&cu->partial_die_obstack);
      cu->partial_dies
	= htab_create_alloc_ex (cu->header.length / 12,
				partial_die_hash,
				partial_die_eq,
				NULL,
				&cu->partial_die_obstack,
				hash_obstack_allocate,
				splay_tree_obstack_deallocate);

      first_die = load_partial_dies (abfd, info_ptr, 0, cu);
    }

  do_cleanups (back_to);
}

/* Create a tree of all compilation units in OBJFILE.  We do this only
   if an inter-comp-unit reference is found; presumably if there is one,
   there will be many, and one will occur early in the .debug_info section.
   So there's no point in building this tree incrementally.  */

static splay_tree
create_comp_unit_tree (struct dwarf2_cu *cu)
{
  splay_tree cu_tree;
  struct objfile *objfile = cu->objfile;
  char *info_ptr = dwarf_info_buffer;

  /* Initialize the compilation unit tree.  */
  cu_tree = splay_tree_new_with_allocator (splay_tree_compare_ints,
					   NULL, NULL,
					   splay_tree_obstack_allocate,
					   splay_tree_obstack_deallocate,
					   &objfile->objfile_obstack);
  set_objfile_data (objfile, dwarf2_cu_tree, cu_tree);

  while (info_ptr < dwarf_info_buffer + dwarf_info_size)
    {
      struct comp_unit_head cu_header;
      char *beg_of_comp_unit;
      struct dwarf2_per_cu_data *this_cu;
      unsigned long offset;

      beg_of_comp_unit = info_ptr;
      offset = beg_of_comp_unit - dwarf_info_buffer;

      /* FIXME: Can I read less data here?  All we really need is the length
         and the initial length size.  */
      info_ptr = partial_read_comp_unit_head (&cu_header, info_ptr,
					      objfile->obfd);

      /* Save the compilation unit for later lookup.  */
      this_cu = obstack_alloc (&objfile->objfile_obstack,
			       sizeof (struct dwarf2_per_cu_data));
      memset (this_cu, 0, sizeof (*this_cu));
      this_cu->offset = offset;
      this_cu->length = cu_header.length;
      splay_tree_insert (cu_tree, this_cu->offset, (splay_tree_value) this_cu);

      if (this_cu->offset == cu->header.offset)
	{
	  this_cu->cu = cu;
	  cu->per_cu = this_cu;
	}

      info_ptr = beg_of_comp_unit + cu_header.length 
                                  + cu_header.initial_length_size;
    }

  return cu_tree;
}

a1502 3
/* Return the fully scoped name associated with PDI, from compilation unit
   CU.  The result will be allocated with malloc, or NULL if PDI->NAME should
   be used.  */
d1507 7
a1513 20
  char *parent_name, *full_name;
  struct partial_die_info *real_pdi, *real_parent;
  struct dwarf2_cu *spec_cu;
  int free_parent_name = 0;

  if (pdi->full_name_set)
    return pdi->full_name;

  /* Note: this code could probably be micro-optimized.  We may be
     able to avoid redoing the hash table lookup, and we might be able
     to use real_pdi->full_name if there is a specification.  */

  real_pdi = pdi;
  spec_cu = cu;
  while (real_pdi->has_specification)
    real_pdi = find_partial_die (real_pdi->spec_offset, spec_cu, &spec_cu);

  /* NOTE drow/2004-02-22: The following code is a hack.  It's only used when
     visiting the DIEs out of order, i.e. due to DW_AT_specification in another
     CU or later in this CU.  It's correct, but somewhat inefficient.  */
d1515 4
a1518 2
  if (real_pdi->full_name_set)
    return real_pdi->full_name;
a1519 1
  real_parent = real_pdi->die_parent;
d1521 1
a1521 14
    {
      real_pdi->full_name_set = 1;
      return NULL;
    }

  if (!real_parent->full_name_set)
    {
      fixup_partial_die (real_parent, spec_cu);
      parent_name = partial_die_full_name (real_parent, spec_cu);
      /* Could cache the full name, too.  */
      free_parent_name = 1;
    }

  /* End hack zone.  */
d1527 1
a1527 4
  full_name = concat (parent_name, "::", real_pdi->name, NULL);
  if (free_parent_name)
    free (parent_name);
  return full_name;
d1545 1
a1545 3
  if (!pdi->full_name_set
      && pdi_needs_namespace (pdi->tag)
      && pdi->full_name == NULL)
a1559 2
  pdi->full_name_set = 1;

d4514 1
a4514 2
load_partial_dies (bfd *abfd, char *info_ptr, int building_psymtab,
		   struct dwarf2_cu *cu)
d4521 1
d4524 1
d4589 1
a4589 1
	  if (building_psymtab && part_die->name != NULL)
d4610 1
a4610 1
	  else if (building_psymtab)
d4722 1
d4813 2
a4814 1
/* Find a cached partial DIE at OFFSET in CU.  */
d4816 1
a4816 1
find_partial_die_in_comp_unit (unsigned long offset, struct dwarf2_cu *cu)
d4823 1
a4823 1

a4830 25
/* Find a partial DIE at OFFSET, which may or may not be in CU.  */
static struct partial_die_info *
find_partial_die (unsigned long offset, struct dwarf2_cu *cu,
		  struct dwarf2_cu **target_cu)
{
  struct dwarf2_per_cu_data *per_cu;

  if (offset >= cu->header.offset
      && offset < cu->header.offset + cu->header.length)
    return find_partial_die_in_comp_unit (offset, cu);

  per_cu = dwarf2_find_containing_comp_unit (offset, cu);
  gdb_assert (per_cu != NULL);

  if (per_cu->cu == NULL)
    {
      load_comp_unit (per_cu, cu->objfile);
      per_cu->cu->read_in_chain = cu->read_in_chain;
      cu->read_in_chain = per_cu;
    }

  *target_cu = per_cu->cu;
  return find_partial_die_in_comp_unit (offset, per_cu->cu);
}

a4840 1
      struct dwarf2_cu *spec_cu;
d4842 1
a4842 1
      spec_die = find_partial_die (part_die->spec_offset, cu, &spec_cu);
d4844 1
a4844 1
      fixup_partial_die (spec_die, spec_cu);
a8494 65
}

/* Locate the compilation unit from CU's objfile which contains the
   DIE at OFFSET.  Returns NULL on failure.

   We assume that OFFSET is not the start of the compilation unit header
   (it can be the compilation unit DIE, though, which comes after the
   header).  */

static struct dwarf2_per_cu_data *
dwarf2_find_containing_comp_unit (unsigned long offset,
				  struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct dwarf2_per_cu_data *this_cu;
  splay_tree cu_tree;
  splay_tree_node node;

  cu_tree = objfile_data (objfile, dwarf2_cu_tree);
  if (cu_tree == NULL)
    cu_tree = create_comp_unit_tree (cu);
  
  node = splay_tree_predecessor (cu_tree, offset);
  gdb_assert (node != NULL);

  this_cu = (struct dwarf2_per_cu_data *) node->value;
  gdb_assert (offset >= this_cu->offset);
  gdb_assert (offset < this_cu->offset + this_cu->length);
  return this_cu;
}

static void
clear_per_cu_pointer (void *data)
{
  struct dwarf2_per_cu_data *this_cu, *per_cu;
  struct dwarf2_cu *cu = data;

  this_cu = cu->per_cu;
  if (this_cu == NULL)
    return;

  per_cu = this_cu->cu->read_in_chain;
  while (per_cu != NULL)
    {
      struct dwarf2_per_cu_data *next_cu;

      obstack_free (&per_cu->cu->partial_die_obstack, NULL);

      next_cu = per_cu->cu->read_in_chain;
      xfree (per_cu->cu);
      per_cu->cu = NULL;
      per_cu = next_cu;
    }

  /* This compilation unit is on the stack in dwarf2_build_psymtabs_hard,
     so we should not xfree it.  */
  this_cu->cu = NULL;
}

void _initialize_dwarf2_read (void);

void
_initialize_dwarf2_read (void)
{
  dwarf2_cu_tree = register_objfile_data ();
@


1.135.2.19
log
@	* dwarf2read.c (partial_die_full_name): Always return NULL or
	malloc'd memory.  Don't try to free real_parent->full_name.
@
text
@d1691 1
a1691 1
  char *parent_name = NULL, *full_name;
d1696 2
a1697 2
  /* We shouldn't even have been called in this case.  */
  gdb_assert (!pdi->full_name_set);
d1713 1
a1713 1
    return xstrdup (real_pdi->full_name);
d1727 1
a1727 2
      if (parent_name != NULL)
	free_parent_name = 1;
d1732 1
a1732 2
  if (parent_name == NULL)
    parent_name = real_parent->full_name;
@


1.135.2.20
log
@	* dwarf2read.c (MAX_CACHE_AGE): Define.
	(struct dwarf2_cu): Add last_used counter.
	(free_comp_units_worker): New function, based on
	clear_per_cu_pointer.  Support aging.
	(clear_per_cu_pointer): Use it.
	(free_cached_comp_units, free_one_cached_comp_unit): New functions.
	(dwarf2_build_psymtabs_hard): Keep read_in_chain across iterations.
	Free all cached comp units after building psymtabs.  Free any cached
	copy of a comp unit before building a psymtab for it.
	(find_partial_die): Clear the last_used counter.
@
text
@a54 4
/* Loaded secondary compilation units are kept in memory until they have not
   been referenced for the processing of this many compilation units.  */
#define MAX_CACHE_AGE 20

a276 3

  /* How many compilation units ago was this CU last referenced?  */
  int last_used;
d973 1
a973 5
static void clear_per_cu_pointer (void *);

static void free_cached_comp_units (void *);

static void free_one_cached_comp_unit (struct dwarf2_cu *, struct dwarf2_cu *);
a1272 1
  struct dwarf2_cu cu;
a1306 7
  /* read_in_chain, unlike every other field in the dwarf2_cu object,
     is live across the loop.  The function clear_per_cu_pointer will
     free any allocated compilation units that have not been used in
     several psymtabs.  Others will remain on the list.  */
  cu.read_in_chain = NULL;
  make_cleanup (free_cached_comp_units, &cu);

d1323 1
a1392 8

	  /* If we were already read in, free ourselves to read in again.
	     Yes, this is pointless duplication.  Fixing this will provide
	     a nice speed boost but require a lot of editing in this
	     function.  */
	  if (per_cu->cu != NULL)
	    free_one_cached_comp_unit (&cu, per_cu->cu);

d1404 1
a5066 1
  per_cu->cu->last_used = 0;
d8768 1
a8768 2
free_comp_units_worker (struct dwarf2_cu *cu, int aging,
			struct dwarf2_cu *target_cu)
d8770 2
a8771 1
  struct dwarf2_per_cu_data *this_cu, *per_cu, **last_chain;
d8774 1
a8774 1
  if (this_cu == NULL && target_cu == NULL)
d8777 1
a8777 2
  per_cu = cu->read_in_chain;
  last_chain = &cu->read_in_chain;
d8782 2
d8785 2
a8786 16

      if ((aging && per_cu->cu->last_used < MAX_CACHE_AGE)
	  || (target_cu && per_cu->cu == target_cu)
	  || (!aging && target_cu == NULL))
	{
	  obstack_free (&per_cu->cu->partial_die_obstack, NULL);
	  xfree (per_cu->cu);
	  per_cu->cu = NULL;
	  *last_chain = next_cu;
	}
      else
	{
	  per_cu->cu->last_used++;
	  last_chain = &per_cu->cu->read_in_chain;
	}

d8791 2
a8792 24
     so we should not xfree it.  Just unlink it.  */
  if (target_cu == NULL)
    {
      cu->per_cu = NULL;
      this_cu->cu = NULL;
    }
}

static void
clear_per_cu_pointer (void *data)
{
  free_comp_units_worker (data, 1, NULL);
}

static void
free_cached_comp_units (void *data)
{
  free_comp_units_worker (data, 0, NULL);
}

static void
free_one_cached_comp_unit (struct dwarf2_cu *cu, struct dwarf2_cu *target_cu)
{
  free_comp_units_worker (cu, 0, target_cu);
@


1.135.2.21
log
@Fix botched commit.
@
text
@d8811 1
a8811 1
      if ((aging && per_cu->cu->last_used > MAX_CACHE_AGE)
@


1.135.2.22
log
@	* dwarf2read.c (dwarf2_attr_with_cu): New function, renamed
	from dwarf2_attr.  Also return the compilation unit associated
	with the attribute if we have followed a reference.  Complain
	if we return a reference attribute and the caller does not want
	the target compilation unit.
	(dwarf2_attr): Call dwarf2_attr_with_cu.
	(die_specification, dwarf2_extension): Also return a compilation
	unit.
	(follow_die_ref): Take attribute and compilation unit arguments.
	Call dwarf2_get_ref_die_offset.  Also return the target
	compilation unit.
	(read_func_scope, read_structure_scope): Update calls to
	die_specification.  Use the result.
	(read_namespace): Update call to dwarf2_extension.
	(namespace_name): Likewise.  Use the result.
	(new_symbol): Call dwarf2_attr_with_cu to check for DIE type.
	(die_type): Likewise.  Update call to follow_die_ref.  Use the
	results.
	(dwarf2_add_member_fn, read_structure_scope): Likewise for
	DW_AT_containing_type.
	(die_containing_type): Likewise.
	(die_is_declaration): Likewise for DW_AT_specification.
@
text
@a778 5
static struct attribute *dwarf2_attr_with_cu (struct die_info *,
					      unsigned int,
					      struct dwarf2_cu *,
					      struct dwarf2_cu **);

d782 1
a782 2
					   struct dwarf2_cu *,
					   struct dwarf2_cu **);
d913 1
a913 2
					  struct dwarf2_cu *,
					  struct dwarf2_cu **);
d948 1
a948 3
static struct die_info *follow_die_ref (struct attribute *,
					struct dwarf2_cu *,
					struct dwarf2_cu **);
d2628 1
a2628 2
      struct dwarf2_cu *spec_cu;
      struct die_info *spec_die = die_specification (die, cu, &spec_cu);
d2654 1
a2654 1
	  char *specification_prefix = determine_prefix (spec_die, spec_cu);
a3260 1
  struct dwarf2_cu *spec_cu;
d3340 1
a3340 1
  if (dwarf2_attr_with_cu (die, DW_AT_containing_type, cu, &spec_cu) != NULL)
d3461 1
a3461 2
	  struct dwarf2_cu *spec_cu;
	  struct die_info *spec_die = die_specification (die, cu, &spec_cu);
d3465 1
a3465 2
	      char *specification_prefix = determine_prefix (spec_die,
							     spec_cu);
a3603 2
	  struct dwarf2_cu *spec_cu;

d3610 1
a3610 2
	  if (dwarf2_attr_with_cu (die, DW_AT_containing_type,
				   cu, &spec_cu) != NULL)
a3915 1
  struct dwarf2_cu *spec_cu;
d3942 1
a3942 1
  if (dwarf2_extension (die, cu, &spec_cu) == NULL)
a3983 1
  struct dwarf2_cu *spec_cu;
d3987 1
a3987 1
  for (current_die = die, spec_cu = cu;
d3989 1
a3989 1
       current_die = dwarf2_extension (die, spec_cu, &spec_cu))
d3991 1
a3991 1
      name = dwarf2_name (current_die, spec_cu);
d5682 1
a5682 2
dwarf2_attr_with_cu (struct die_info *die, unsigned int name,
		     struct dwarf2_cu *cu, struct dwarf2_cu **spec_cu)
a5690 14
	  if (spec_cu == NULL
	      && (die->attrs[i].form == DW_FORM_ref_addr
		  || die->attrs[i].form == DW_FORM_ref1
		  || die->attrs[i].form == DW_FORM_ref2
		  || die->attrs[i].form == DW_FORM_ref4
		  || die->attrs[i].form == DW_FORM_ref8
		  || die->attrs[i].form == DW_FORM_ref_udata))
	    internal_error (__FILE__, __LINE__,
			    "attempt to follow a dwarf2 DIE reference "
			    "discards compilation unit");

	  if (spec_cu != NULL)
	    *spec_cu = cu;

d5699 2
a5700 2
      struct dwarf2_cu *ref_cu;
      struct die_info *ref_die = follow_die_ref (spec, cu, &ref_cu);
d5702 2
a5703 1
      return dwarf2_attr_with_cu (ref_die, name, ref_cu, spec_cu);
a5708 8
/* Return the named attribute or NULL if not there.  */

static struct attribute *
dwarf2_attr (struct die_info *die, unsigned int name, struct dwarf2_cu *cu)
{
  return dwarf2_attr_with_cu (die, name, cu, NULL);
}

a5711 1
  struct dwarf2_cu *spec_cu;
d5713 1
a5713 1
	  && ! dwarf2_attr_with_cu (die, DW_AT_specification, cu, &spec_cu));
d5720 1
a5720 2
die_specification (struct die_info *die, struct dwarf2_cu *cu,
		   struct dwarf2_cu **spec_cu)
d5722 1
a5722 2
  struct attribute *spec_attr
    = dwarf2_attr_with_cu (die, DW_AT_specification, cu, spec_cu);
d5727 1
a5727 1
    return follow_die_ref (spec_attr, *spec_cu, spec_cu);
a6336 2
	      struct dwarf2_cu *spec_cu;

d6345 1
a6345 2
		  && dwarf2_attr_with_cu (die, DW_AT_type,
					  cu, &spec_cu) != NULL)
d6611 1
a6611 1
  struct dwarf2_cu *spec_cu;
d6613 1
a6613 1
  type_attr = dwarf2_attr_with_cu (die, DW_AT_type, cu, &spec_cu);
d6621 2
a6622 1
      type_die = follow_die_ref (type_attr, spec_cu, &spec_cu);
d6625 2
a6626 3
	  error ("Dwarf Error: Cannot find referent from DIE "
		 "at offset %d [in module %s]",
		 die->offset, cu->objfile->name);
d6630 1
a6630 1
  type = tag_type_to_type (type_die, spec_cu);
d6649 1
a6649 1
  struct dwarf2_cu *spec_cu;
d6651 1
a6651 1
  type_attr = dwarf2_attr_with_cu (die, DW_AT_containing_type, cu, &spec_cu);
d6654 2
a6655 1
      type_die = follow_die_ref (type_attr, spec_cu, &spec_cu);
d6658 2
a6659 2
	  error ("Dwarf Error: Cannot find referent from DIE at offset %d "
		 "[in module %s]", die->offset, cu->objfile->name);
d6662 1
a6662 1
      type = tag_type_to_type (type_die, spec_cu);
d7046 1
a7046 2
dwarf2_extension (struct die_info *die, struct dwarf2_cu *cu,
		  struct dwarf2_cu **spec_cu)
d7050 1
d7052 1
a7052 1
  attr = dwarf2_attr_with_cu (die, DW_AT_extension, cu, spec_cu);
d7056 2
a7057 1
  extension_die = follow_die_ref (attr, *spec_cu, spec_cu);
d7060 1
a7060 2
      error ("Dwarf Error: Cannot find referent from DIE at offset %d.",
	     die->offset);
d8016 1
a8016 2
follow_die_ref (struct attribute *attr, struct dwarf2_cu *cu,
		struct dwarf2_cu **spec_cu)
a8018 1
  unsigned int offset;
a8020 2
  offset = dwarf2_get_ref_die_offset (attr, cu);

a8026 1
	  *spec_cu = cu;
@


1.135.2.23
log
@	* dwarf2read.c (read_structure_scope): Don't create a symbol
	or call process_die.  Return immediately if die->type is set.
	Call read_type_die before dwarf2_add_member_fn.
	(process_structure_scope): New function.
	(read_enumeration_type, read_enumeration_scope): New functions,
	broken out from read_enumeration.  Don't create the enumeration
	type if it has already been created.
	(read_enumeration): Removed.
	(process_die): Call process_structure_scope, read_enumeration_type,
	and read_enumeration_scope.  Just call new_symbol for base and
	subrange types.  Add a comment about other type dies.
	(read_type_die): Call read_enumeration_type.
@
text
@a865 2
static void process_structure_scope (struct die_info *, struct dwarf2_cu *);

d873 1
a873 3
static void read_enumeration_type (struct die_info *, struct dwarf2_cu *);

static void read_enumeration_scope (struct die_info *, struct dwarf2_cu *);
a2401 1
      process_structure_scope (die, cu);
d2404 1
a2404 2
      read_enumeration_type (die, cu);
      read_enumeration_scope (die, cu);
a2405 4

    /* FIXME: These initialize die->type, but do not create a symbol
       or process any children.  Therefore it doesn't do anything that
       won't be done on-demand by read_type_die.  */
a2423 2
    /* END FIXME */

d2426 5
a2430 3
      /* Add a typedef symbol for the type definition, if it has a
	 DW_AT_name.  */
      new_symbol (die, die->type, cu);
d2434 5
a2438 3
      /* Add a typedef symbol for the type definition, if it has a
         DW_AT_name.  */
      new_symbol (die, die->type, cu);
a3461 3
  if (die->type)
    return;

d3562 1
a3562 1
	      read_type_die (child_die, cu);
d3605 4
d3668 2
d3683 2
a3684 5
static void
process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  const char *previous_prefix = processing_current_prefix;
d3686 3
a3688 2
  if (TYPE_TAG_NAME (die->type) != NULL)
    processing_current_prefix = TYPE_TAG_NAME (die->type);
d3690 1
a3690 28
  if (die->child != NULL && ! die_is_declaration (die, cu))
    {
      struct die_info *child_die;

      child_die = die->child;

      while (child_die && child_die->tag)
	{
	  if (child_die->tag == DW_TAG_member
	      || child_die->tag == DW_TAG_variable
	      || child_die->tag == DW_TAG_inheritance)
	    {
	      /* Do nothing.  */
	    }
	  else
	    process_die (child_die, cu);

	  child_die = sibling_die (child_die);
	}

      new_symbol (die, die->type, cu);
    }

  processing_current_prefix = previous_prefix;
}

/* Given a DW_AT_enumeration_type die, set its type.  We do not
   complete the type's fields yet, or create any symbols.  */
d3693 1
a3693 1
read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)
d3696 1
d3698 1
d3700 3
a3702 3

  if (die->type)
    return;
a3736 20
  die->type = type;
}

/* Given a pointer to a die which begins an enumeration, process all
   the dies that define the members of the enumeration, and create the
   symbol for the enumeration type.

   NOTE: We reverse the order of the element list.  */

static void
read_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct die_info *child_die;
  struct field *fields;
  struct attribute *attr;
  struct symbol *sym;
  int num_fields;
  int unsigned_enum = 1;

d3753 1
a3753 1
		  sym = new_symbol (child_die, die->type, cu);
d3780 4
a3783 4
	  TYPE_NFIELDS (die->type) = num_fields;
	  TYPE_FIELDS (die->type) = (struct field *)
	    TYPE_ALLOC (die->type, sizeof (struct field) * num_fields);
	  memcpy (TYPE_FIELDS (die->type), fields,
d3788 1
a3788 1
	TYPE_FLAGS (die->type) |= TYPE_FLAG_UNSIGNED;
d3790 2
a3791 2

  new_symbol (die, die->type, cu);
d6773 1
a6773 1
      read_enumeration_type (die, cu);
@


1.135.2.24
log
@	* dwarf2read.c (REF_HASH_SIZE): Move above struct dwarf2_cu.
	(struct dwarf2_cu): Add die_ref_table.
	(die_ref_table): Delete static variable.
	(store_in_ref_table): Take a comp unit argument and use its
	die_ref_table.
	(dwarf2_empty_hash_tables): Likewise.
	(read_comp_unit): Update call to dwarf2_empty_hash_tables.
	(read_die_and_children): Update call to store_in_ref_table.
	(follow_die_ref): Use the comp unit's die_ref_table.
@
text
@a226 5
/* Fixed size for the DIE hash table.  */
#ifndef REF_HASH_SIZE
#define REF_HASH_SIZE 1021
#endif

a283 3

  /* A hash table of die offsets for following references.  */
  struct die_info *die_ref_table[REF_HASH_SIZE];
d449 7
d950 1
a950 2
static void store_in_ref_table (unsigned int, struct die_info *,
				struct dwarf2_cu *);
d952 1
a952 1
static void dwarf2_empty_hash_tables (struct dwarf2_cu *);
d4529 1
a4529 1
  dwarf2_empty_hash_tables (cu);
d4551 1
a4551 1
  store_in_ref_table (die->offset, die, cu);
d8047 1
a8047 2
store_in_ref_table (unsigned int offset, struct die_info *die,
		    struct dwarf2_cu *cu)
d8053 1
a8053 1
  old = cu->die_ref_table[h];
d8055 1
a8055 1
  cu->die_ref_table[h] = die;
d8060 1
a8060 1
dwarf2_empty_hash_tables (struct dwarf2_cu *cu)
d8062 1
a8062 1
  memset (cu->die_ref_table, 0, sizeof (cu->die_ref_table));
a8120 1
  *spec_cu = cu;
d8123 1
a8123 1
  die = (*spec_cu)->die_ref_table[h];
d8127 4
a8130 1
	return die;
@


1.135.2.25
log
@	* dwarf2read.c (struct dwarf2_per_cu_data): Add psymtab member.
	(struct dwarf2_pinfo): Add dwarf_info_size and type_hash.
	Rearrange and update comments.
	(DWARF_INFO_SIZE): Define.
	(set_die_type, get_die_type, reset_die_and_siblings_types): New
	fucntions.
	(dwarf2_build_psymtabs_hard): Save dwarf_info_size.  Initialize
	type_hash.
	(psymtab_to_symtab_1): Restore dwarf_info_size.  Create per_cu
	data for the current compilation unit.
	(read_structure_scope, read_enumeration_type, read_array_type)
	(read_tag_pointer_type, read_tag_ptr_to_member_type)
	(read_tag_reference_type, read_tag_const_type)
	(read_tag_volatile_type, read_tag_string_type)
	(read_subroutine_type, read_typedef, read_base_type): Call
	set_die_type.
	(read_subrange_type): Likewise.  Use dwarf2_attr_with_cu, since
	array bounds may be DIE references.
	(struct dwarf2_offset_and_type, offset_and_type_hash)
	(offset_and_type_eq): New.
@
text
@d299 1
a299 2

  /* Only set during full symbol reading.  */
d301 1
a496 10
    /* If this partial symbol table has been read in, a map of DIE
       offsets to types.  */
    htab_t type_hash;

    /* Offset in dwarf_info_buffer for this compilation unit. */

    unsigned long dwarf_info_offset;

    /* FIXME: All the rest is actually per-objfile.  */

d501 1
a501 1
    /* Size of dwarf info section for the objfile.  */
d503 1
a503 1
    unsigned int dwarf_info_size;
a555 1
#define DWARF_INFO_SIZE(p)   (PST_PRIVATE(p)->dwarf_info_size)
a1000 6
static void set_die_type (struct die_info *, struct type *,
			  struct dwarf2_cu *);

static void reset_die_and_siblings_types (struct die_info *,
					  struct dwarf2_cu *);

d1396 1
a1397 2
      DWARF_INFO_BUFFER (pst) = dwarf_info_buffer;
      DWARF_INFO_SIZE (pst) = dwarf_info_size;
a1409 1
      PST_PRIVATE (pst)->type_hash = NULL;
a2287 1
  dwarf_info_size = DWARF_INFO_SIZE (pst);
a2322 14
  /* NOTE drow/2004-02-23: this reads in the comp_unit_tree that we went to
     so much trouble to keep lazy during partial symbol reading.  If this
     proves to be unavoidable then we may want to strip out the lazy code
     during partial symbol reading also.  */
  cu.per_cu = dwarf2_find_containing_comp_unit (offset + 1, &cu);
  /* As in partial symbol table building, this leaks a pointer to our stack
     frame into a global data structure.  Be sure to clear it before we
     return.  */
  cu.per_cu->cu = &cu;
  make_cleanup (clear_per_cu_pointer, &cu);
  cu.read_in_chain = NULL;

  cu.per_cu->psymtab = pst;

d3548 1
a3548 1
  set_die_type (die, type, cu);
d3771 1
a3771 1
  set_die_type (die, type, cu);
d3878 1
a3878 2
      set_die_type (die, create_array_type (NULL, element_type, range_type),
		    cu);
d3927 1
a3927 1
  set_die_type (die, type, cu);
d4131 1
a4131 1
  set_die_type (die, type, cu);
d4155 1
a4155 1
  set_die_type (die, type, cu);
d4183 1
a4183 1
  set_die_type (die, type, cu);
d4197 1
a4197 2
  set_die_type (die, make_cv_type (1, TYPE_VOLATILE (base_type), base_type, 0),
		cu);
d4211 1
a4211 2
  set_die_type (die, make_cv_type (TYPE_CONST (base_type), 1, base_type, 0),
		cu);
d4263 1
a4263 1
  set_die_type (die, type, cu);
d4344 1
a4344 1
  set_die_type (die, ftype, cu);
d4361 1
a4361 2
      set_die_type (die, init_type (TYPE_CODE_TYPEDEF, 0,
				    TYPE_FLAG_TARGET_STUB, name, objfile), cu);
d4449 1
a4449 1
  set_die_type (die, type, cu);
a4461 1
  struct dwarf2_cu *spec_cu;
d4484 1
a4484 4
  /* FIXME: For variable sized arrays either of these could be
     a variable rather than a constant value.  We'll allow it,
     but we don't know how to handle it.  */
  attr = dwarf2_attr_with_cu (die, DW_AT_lower_bound, cu, &spec_cu);
d4488 1
a4488 1
  attr = dwarf2_attr_with_cu (die, DW_AT_upper_bound, cu, &spec_cu);
d4520 1
a4520 1
  set_die_type (die, range_type, cu);
a8956 80
}

struct dwarf2_offset_and_type
{
  unsigned int offset;
  struct type *type;
};

static hashval_t
offset_and_type_hash (const void *item)
{
  const struct dwarf2_offset_and_type *ofs = item;
  return ofs->offset;
}

static int
offset_and_type_eq (const void *item_lhs, const void *item_rhs)
{
  const struct dwarf2_offset_and_type *ofs_lhs = item_lhs;
  const struct dwarf2_offset_and_type *ofs_rhs = item_rhs;
  return ofs_lhs->offset == ofs_rhs->offset;
}

/* Functions used to regenerate die->type, given a tree of DIEs and an
   already completed symtab.  Types without names can't necessarily be
   reconstituted, so we save them.  */
static void
set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)
{
  htab_t type_hash;
  struct dwarf2_offset_and_type **slot, ofs;

  die->type = type;

  type_hash = PST_PRIVATE (cu->per_cu->psymtab)->type_hash;
  if (type_hash == NULL)
    {
      type_hash = htab_create_alloc_ex (cu->header.length / 24,
					offset_and_type_hash,
					offset_and_type_eq,
					NULL,
					&cu->objfile->objfile_obstack,
					hash_obstack_allocate,
					splay_tree_obstack_deallocate);
      PST_PRIVATE (cu->per_cu->psymtab)->type_hash = type_hash;
    }
  ofs.offset = die->offset;
  ofs.type = type;
  slot = (struct dwarf2_offset_and_type **)
    htab_find_slot_with_hash (type_hash, &ofs, ofs.offset, INSERT);
  *slot = obstack_alloc (&cu->objfile->objfile_obstack, sizeof (**slot));
  **slot = ofs;
}

static struct type *
get_die_type (struct die_info *die, struct dwarf2_cu *cu)
{
  htab_t type_hash;
  struct dwarf2_offset_and_type *slot, ofs;

  type_hash = PST_PRIVATE (cu->per_cu->psymtab)->type_hash;
  ofs.offset = die->offset;
  slot = htab_find_with_hash (type_hash, &ofs, ofs.offset);
  if (slot)
    return slot->type;
  else
    return NULL;
}

static void
reset_die_and_siblings_types (struct die_info *start_die, struct dwarf2_cu *cu)
{
  struct die_info *die;

  for (die = start_die; die != NULL; die = die->sibling)
    {
      die->type = get_die_type (die, cu);
      if (die->child != NULL)
	reset_die_and_siblings_types (die->child, cu);
    }
@


1.135.2.26
log
@	* dwarf2read.c (dwarf2_per_objfile_data): New.
	(struct dwarf2_per_objfile_data): New.
	(dwarf2_per_objfile): New.
	(dwarf_info_size, dwarf_abbrev_size, dwarf_line_size)
	(dwarf_pubnames_size, dwarf_aranges_size, dwarf_loc_size)
	(dwarf_macinfo_size, dwarf_str_size, dwarf_ranges_size)
	(dwarf_frame_size, dwarf_eh_frame_size, dwarf_info_buffer)
	(dwarf_abbrev_buffer, dwarf_line_buffer, dwarf_str_buffer)
	(dwarf_macinfo_buffer, dwarf_ranges_buffer, dwarf_loc_buffer):
	Replace with macros.
	(dwarf2_cu_tree): Remove.
	(struct dwarf2_pinfo): Remove per-objfile members.
	(DWARF_INFO_SIZE, DWARF_ABBREV_SIZE, DWARF_LINE_SIZE)
	(DWARF_LOC_SIZE, DWARF_MACINFO_SIZE, DWARF_STR_SIZE)
	(DWARF_RANGES_SIZE, DWARF_INFO_BUFFER)
	(DWARF_ABBREV_BUFFER, DWARF_LINE_BUFFER, DWARF_STR_BUFFER)
	(DWARF_MACINFO_BUFFER, DWARF_RANGES_BUFFER, DWARF_LOC_BUFFER):
	Remove macros.
	(dwarf2_has_info): Take an objfile argument.  Allocate per-objfile
	data.
	(dwarf2_build_psymtabs_hard): Remove use of removed macros.  Fetch
	cu_tree from dwarf2_per_objfile.
	(create_comp_unit_tree): Save cu_tree in dwarf2_per_objfile.
	(psymtab_to_symtab_1): Restore per-objfile data pointer.  Remove use
	of removed macros.
	(dwarf2_find_containing_comp_unit): Fetch cu_tree from
	dwarf2_per_objfile.
	(_initialize_dwarf2_read): Register dwarf2_per_objfile_data instead
	of dwarf2_cu_tree.
	* symfile.h (dwarf2_has_info): Update prototype.
	* coffread.c (coff_symfile_read): Update call to dwarf2_has_info.
	* elfread.c (elf_symfile_read): Likewise.
@
text
@d135 1
a135 1
static const struct objfile_data *dwarf2_per_objfile_data;
d137 11
a147 48
struct dwarf2_per_objfile_data
{
  /* Sizes of debugging sections.  */
  unsigned int dwarf_info_size;
  unsigned int dwarf_abbrev_size;
  unsigned int dwarf_line_size;
  unsigned int dwarf_pubnames_size;
  unsigned int dwarf_aranges_size;
  unsigned int dwarf_loc_size;
  unsigned int dwarf_macinfo_size;
  unsigned int dwarf_str_size;
  unsigned int dwarf_ranges_size;
  unsigned int dwarf_frame_size;
  unsigned int dwarf_eh_frame_size;

  /* Loaded data from the sections.  */
  char *dwarf_info_buffer;
  char *dwarf_abbrev_buffer;
  char *dwarf_line_buffer;
  char *dwarf_str_buffer;
  char *dwarf_macinfo_buffer;
  char *dwarf_ranges_buffer;
  char *dwarf_loc_buffer;

  splay_tree cu_tree;
};

#define dwarf_info_size		dwarf2_per_objfile->dwarf_info_size
#define dwarf_abbrev_size	dwarf2_per_objfile->dwarf_abbrev_size
#define dwarf_line_size		dwarf2_per_objfile->dwarf_line_size
#define dwarf_pubnames_size	dwarf2_per_objfile->dwarf_pubnames_size
#define dwarf_aranges_size	dwarf2_per_objfile->dwarf_aranges_size
#define dwarf_loc_size		dwarf2_per_objfile->dwarf_loc_size
#define dwarf_macinfo_size	dwarf2_per_objfile->dwarf_macinfo_size
#define dwarf_str_size		dwarf2_per_objfile->dwarf_str_size
#define dwarf_ranges_size	dwarf2_per_objfile->dwarf_ranges_size
#define dwarf_frame_size	dwarf2_per_objfile->dwarf_frame_size
#define dwarf_eh_frame_size	dwarf2_per_objfile->dwarf_eh_frame_size

#define dwarf_info_buffer	dwarf2_per_objfile->dwarf_info_buffer
#define dwarf_abbrev_buffer	dwarf2_per_objfile->dwarf_abbrev_buffer
#define dwarf_line_buffer	dwarf2_per_objfile->dwarf_line_buffer
#define dwarf_loc_buffer	dwarf2_per_objfile->dwarf_loc_buffer
#define dwarf_macinfo_buffer	dwarf2_per_objfile->dwarf_macinfo_buffer
#define dwarf_str_buffer	dwarf2_per_objfile->dwarf_str_buffer
#define dwarf_ranges_buffer	dwarf2_per_objfile->dwarf_ranges_buffer

static struct dwarf2_per_objfile_data *dwarf2_per_objfile;
d294 2
d465 9
d504 58
d565 2
d568 12
d1060 1
a1060 1
dwarf2_has_info (struct objfile *objfile)
a1061 8
  struct dwarf2_per_objfile_data *data;

  /* Initialize per-objfile state.  */
  data = obstack_alloc (&objfile->objfile_obstack, sizeof (*data));
  memset (data, 0, sizeof (*data));
  set_objfile_data (objfile, dwarf2_per_objfile_data, data);
  dwarf2_per_objfile = data;

d1072 1
a1072 1
  bfd_map_over_sections (objfile->obfd, dwarf2_locate_sections, NULL);
d1149 1
d1414 14
d1435 1
a1435 1
	cu_tree = dwarf2_per_objfile->cu_tree;
d1610 1
a1610 1
  dwarf2_per_objfile->cu_tree = cu_tree;
a2303 2
  dwarf2_per_objfile = objfile_data (pst->objfile, dwarf2_per_objfile_data);

d2306 14
a2319 1

d8925 1
a8925 1
  cu_tree = dwarf2_per_objfile->cu_tree;
d9086 1
a9086 1
  dwarf2_per_objfile_data = register_objfile_data ();
@


1.135.2.27
log
@	* dwarf2read.c (dwarf2_read_abbrevs): Return 1 iff we saw any
	DW_FORM_ref_addr tags.
	(create_comp_unit_tree): Add prototype.  Take an objfile instead
	of a compilation unit.
	(dwarf2_build_psymtabs_hard): Build the compilation unit tree
	as soon as we find an inter-CU reference.  Update call to
	create_comp_unit_tree.
	(dwarf2_find_containing_comp_unit): Don't create the tree here.
	(psymtab_to_symtab_1): Update to support no tree having been built.
	(set_die_type): Likewise.
@
text
@d676 1
a676 1
static int dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu);
a971 2
static splay_tree create_comp_unit_tree (struct objfile *);

a1337 1
      int saw_ref_addr;
d1354 1
a1354 1
      saw_ref_addr = dwarf2_read_abbrevs (abfd, &cu);
a1356 3
      if (saw_ref_addr && cu_tree == NULL)
	cu_tree = create_comp_unit_tree (objfile);

d1381 3
d1545 1
a1545 1
create_comp_unit_tree (struct objfile *objfile)
d1548 1
d1582 6
d2283 7
a2289 10
  if (dwarf2_per_objfile->cu_tree == NULL)
    cu.per_cu = NULL;
  else
    {
      splay_tree_node node;
      struct dwarf2_per_cu_data *per_cu;

      node = splay_tree_lookup (dwarf2_per_objfile->cu_tree, cu.header.offset);
      gdb_assert (node != NULL);
      cu.per_cu = (struct dwarf2_per_cu_data *) node->value;
d2291 1
a2291 10
      /* As in partial symbol table building, this leaks a pointer to
	 our stack frame into a global data structure.  Be sure to
	 clear it before we return.  */
      cu.per_cu->cu = &cu;
      make_cleanup (clear_per_cu_pointer, &cu);

      cu.per_cu->psymtab = pst;
    }

  cu.read_in_chain = NULL;
d4655 1
a4655 1
static int
a4664 1
  int saw_ref_addr = 0;
a4703 4

	  if (abbrev_form == DW_FORM_ref_addr)
	    saw_ref_addr = 1;

a4738 2

  return saw_ref_addr;
d8862 2
a8863 1
  gdb_assert (cu_tree != NULL);
a8967 3

  if (cu->per_cu == NULL)
    return;
@


1.135.2.28
log
@	* dwarf2read.c (dwarf2_read_abbrevs): Return 1 for DW_FORM_indirect
	also.
@
text
@a4716 5
	  /* If we don't know what form this attribute will have, then it
	     might potentially be a DW_FORM_ref_addr.  */
	  if (abbrev_form == DW_FORM_indirect)
	    saw_ref_addr = 1;

@


1.135.2.29
log
@	* dwarf2read.c (struct dwarf2_per_objfile_data): Add comment
	for cu_tree.  Add read_in_chain.
	(age_cached_comp_units): New function.
	(clear_per_cu_pointer): Clear the pointer ourself.  Call
	age_cached_comp_units.
	(free_cached_comp_units, free_one_cached_comp_unit): Update call to
	free_comp_units_worker.
	(dwarf2_build_psymtabs_hard): Use the per-objfile read_in_chain.
	(find_partial_die): Likewise.
	(free_comp_units_worker): Don't try to clear the per_cu pointer
	for the list head.  Remove now-unused argument.  Use the per-objfile
	read_in_chain.
@
text
@a160 3
  /* A tree of all the compilation units.  Each member is a pointer
     to a struct dwarf2_cu.  This will be set if and only if we have
     encountered a compilation unit with inter-CU references.  */
a161 4

  /* A chain of compilation units that are currently read in, so that
     they can be freed later.  */
  struct dwarf2_per_cu_data *read_in_chain;
a963 2
static void age_cached_comp_units (void *);

d1314 6
a1319 3
  /* Any cached compilation units will be linked by the per-objfile
     read_in_chain.  Make sure to free them when we're done.  */
  make_cleanup (free_cached_comp_units, NULL);
a1355 2
      cu.read_in_chain = NULL;

d5158 2
a5159 2
      per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
      dwarf2_per_objfile->read_in_chain = per_cu;
a8892 6
/* Helper function for cleaning up the compilation unit cache.  Walk
   this objfile's read_in_chain.  If AGING, increase the age counter
   on each compilation unit, and free any that are too old.  Otherwise,
   if TARGET_CU, free only that compilation unit, removing it from the
   chain.  Otherwise free all compilation units.  */

d8894 2
a8895 1
free_comp_units_worker (struct dwarf2_cu *target_cu, int aging)
d8897 5
a8901 1
  struct dwarf2_per_cu_data *per_cu, **last_chain;
d8903 2
a8904 2
  per_cu = dwarf2_per_objfile->read_in_chain;
  last_chain = &dwarf2_per_objfile->read_in_chain;
a8927 1
}
d8929 3
a8931 6
static void
clear_per_cu_pointer (void *data)
{
  struct dwarf2_cu *cu = data;

  if (cu->per_cu != NULL)
a8932 5
      age_cached_comp_units (NULL);

      /* This compilation unit is on the stack in our caller, so we
	 should not xfree it.  Just unlink it.  */
      cu->per_cu->cu = NULL;
d8934 1
d8939 1
a8939 1
free_cached_comp_units (void *data)
d8941 1
a8941 1
  free_comp_units_worker (NULL, 0);
d8945 1
a8945 1
age_cached_comp_units (void *data)
d8947 1
a8947 1
  free_comp_units_worker (NULL, 1);
d8953 1
a8953 1
  free_comp_units_worker (target_cu, 0);
@


1.135.2.30
log
@	* dwarf2read.c (struct dwarf2_cu): Add dies.
	(struct dwarf2_per_cu_data): Shrink length field to add new
	queued flag.
	(make_cleanup_free_die_list, do_free_die_list_cleanup): Remove.
	(dwarf_alloc_block): Take a dwarf2_cu argument.  Allocate
	blocks on the partial_die_obstack.
	(dwarf2_find_comp_unit_psymtab, struct dwarf2_queue_item)
	(dwarf2_queue, queue_comp_unit, process_queue): New.
	(load_full_comp_unit, process_full_comp_unit): New functions,
	split from psymtab_to_symtab_1.
	(psymtab_to_symtab_1): Remove.
	(dwarf2_build_psymtabs_hard): Initialize the whole dwarf2_cu
	structure.  Cache the psymtab if we have a per_cu structure.
	(load_comp_unit): Initialize the whole dwarf2_cu structure.
	(dwarf2_psymtab_to_symtab): Restore dwarf2_per_objfile here.
	(read_full_die): Queue compilation units for references.
	(read_attribute_value): Update calls to dwarf_alloc_block.
	(follow_die_ref): Follow inter-complation-unit references.
	(free_comp_units_worker): Free the die list.
	(get_die_type): Take the hash table as an argument.
	(reset_die_and_siblings_types): Don't try to restore types
	if none were saved.
@
text
@a335 3

  /* Full DIEs if read in.  */
  struct die_info *dies;
d340 1
a340 9
  /* The start offset and length of this compilation unit.  2**31-1
     bytes should suffice to store the length of any compilation unit
     - if it doesn't, GDB will fall over anyway.  */
  unsigned long offset;
  unsigned long length : 31;

  /* Flag indicating this compilation unit will be read in before
     any of the current compilation units are processed.  */
  unsigned long queued : 1;
d887 2
d944 1
a944 1
static struct dwarf_block *dwarf_alloc_block (struct dwarf2_cu *);
a966 3
static struct partial_symtab *dwarf2_find_comp_unit_psymtab
  (unsigned int offset, struct objfile *objfile);

a982 6
static struct dwarf2_cu *load_full_comp_unit (struct partial_symtab *,
					      struct dwarf2_per_cu_data *);

static void process_full_comp_unit (struct partial_symtab *,
				    struct dwarf2_cu *);

a1349 2
      memset (&cu, 0, sizeof (cu));

a1416 2

	  per_cu->psymtab = pst;
a1501 2
  memset (cu, 0, sizeof (struct dwarf2_cu));

a2229 2
	  dwarf2_per_objfile = objfile_data (pst->objfile,
					     dwarf2_per_objfile_data);
a2238 71
struct dwarf2_queue_item
{
  struct dwarf2_per_cu_data *per_cu;
  struct dwarf2_queue_item *next;
};

static struct dwarf2_queue_item *dwarf2_queue;

static void
queue_comp_unit (struct dwarf2_per_cu_data *per_cu)
{
  struct dwarf2_queue_item *item;

  per_cu->queued = 1;
  item = xmalloc (sizeof (*item));
  item->per_cu = per_cu;
  item->next = dwarf2_queue;
  dwarf2_queue = item;
}

static void
process_queue (struct objfile *objfile)
{
  struct dwarf2_queue_item *item, *last;

  while (dwarf2_queue->per_cu->cu == NULL)
    {
      item = dwarf2_queue;
      while (item && item->per_cu->cu == NULL)
	{
	  if (item->per_cu->psymtab == NULL)
	    item->per_cu->psymtab
	      = dwarf2_find_comp_unit_psymtab (item->per_cu->offset, objfile);
	  load_full_comp_unit (item->per_cu->psymtab, item->per_cu);

	  item->per_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;
	  dwarf2_per_objfile->read_in_chain = item->per_cu;

	  item = item->next;
	}
    }

  item = dwarf2_queue;
  while (item)
    {
      if (item->per_cu->psymtab->readin)
	{
	  reset_die_and_siblings_types (item->per_cu->cu->dies,
					item->per_cu->cu);
	  item->per_cu->queued = 0;
	}
      item = item->next;
    }

  item = dwarf2_queue;
  while (item)
    {
      if (!item->per_cu->psymtab->readin)
	{
	  process_full_comp_unit (item->per_cu->psymtab,
				  item->per_cu->cu);
	  item->per_cu->queued = 0;
	}
      last = item;
      item = item->next;
      xfree (last);
    }

  dwarf2_queue = NULL;
}

d2242 4
a2245 57
  struct cleanup *back_to;

  obstack_init (&dwarf2_tmp_obstack);
  back_to = make_cleanup (dwarf2_free_tmp_obstack, NULL);

  /* FIXME: More cleanup issues.  */
  if (dwarf2_per_objfile->cu_tree == NULL)
    {
      struct dwarf2_cu *cu;
      cu = load_full_comp_unit (pst, NULL);
      process_full_comp_unit (pst, cu);
      /* FIXME: This is in two places now.  That's one too many.  */
      obstack_free (&cu->partial_die_obstack, NULL);
      if (cu->dies)
	free_die_list (cu->dies);
      xfree (cu);
    }
  else
    {
      splay_tree_node node;
      struct dwarf2_per_cu_data *per_cu;
      unsigned long offset;

      offset = DWARF_INFO_OFFSET (pst);
      node = splay_tree_lookup (dwarf2_per_objfile->cu_tree, offset);
      gdb_assert (node != NULL);
      per_cu = (struct dwarf2_per_cu_data *) node->value;

      per_cu->psymtab = pst;
      queue_comp_unit (per_cu);

      process_queue (pst->objfile);

      /* FIXME drow/2004-02-23: Obviously, this is bad.  We want to
	 keep compilation units in memory.  The problem is that we do
	 not currently store the dependence information, so CUs used
	 by a cached CU may drop out of the cache before it does.
	 Then we don't know to reload them, but we never should have
	 let them go at all.  When some dependence graph is
	 implemented, we can re-enable aging.  Be careful of cycles!

         This is a very important performance improvement.  My testing
         shows a factor of six loss from disabling the caching.  */
#if 0
      age_cached_comp_units (NULL);
#endif
      free_cached_comp_units (NULL);
    }
}

/* FIXME: Cleanup issues.  */
static struct dwarf2_cu *
load_full_comp_unit (struct partial_symtab *pst,
		     struct dwarf2_per_cu_data *per_cu)
{
  bfd *abfd = pst->objfile->obfd;
  struct dwarf2_cu *cu;
d2247 2
d2250 1
d2253 3
d2261 4
d2266 5
a2270 2
  cu = xmalloc (sizeof (struct dwarf2_cu));
  memset (cu, 0, sizeof (struct dwarf2_cu));
d2272 1
a2272 1
  cu->objfile = pst->objfile;
d2275 1
a2275 1
  info_ptr = read_comp_unit_head (&cu->header, info_ptr, abfd);
d2278 2
a2279 2
  dwarf2_read_abbrevs (abfd, cu);
  back_to = make_cleanup (dwarf2_empty_abbrev_table, cu);
d2281 1
a2281 1
  cu->header.offset = offset;
d2283 6
a2288 16
  cu->per_cu = per_cu;
  if (cu->per_cu)
    per_cu->cu = cu;

  /* We use this obstack for block values in dwarf_alloc_block.  */
  obstack_init (&cu->partial_die_obstack);

  cu->dies = read_comp_unit (info_ptr, abfd, cu);

  /* We try not to read any attributes in this function, because not
     all objfiles needed for references have been loaded yet, and symbol
     table processing isn't initialized.  But we have to set the CU language,
     or we won't be able to build types correctly.  */
  attr = dwarf2_attr (cu->dies, DW_AT_language, cu);
  if (attr)
    set_cu_language (DW_UNSND (attr), cu);
d2290 3
a2292 1
    set_cu_language (language_minimal, cu);
d2294 3
a2296 1
  do_cleanups (back_to);
d2298 5
a2302 2
  return cu;
}
d2304 2
a2305 10
static void
process_full_comp_unit (struct partial_symtab *pst, struct dwarf2_cu *cu)
{
  struct objfile *objfile = pst->objfile;
  bfd *abfd = objfile->obfd;
  CORE_ADDR lowpc, highpc;
  struct symtab *symtab;
  struct cleanup *back_to;
  struct attribute *attr;
  CORE_ADDR baseaddr;
d2307 1
a2307 1
  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2309 1
a2309 2
  /* We're in the global namespace.  */
  processing_current_prefix = "";
d2311 1
a2311 2
  buildsym_init ();
  back_to = make_cleanup (really_free_pendings, NULL);
d2313 1
a2313 1
  cu->list_in_scope = &file_symbols;
d2321 2
a2322 2
  cu->header.base_known = 0;
  cu->header.base_address = 0;
d2324 1
a2324 1
  attr = dwarf2_attr (cu->dies, DW_AT_entry_pc, cu);
d2327 2
a2328 2
      cu->header.base_address = DW_ADDR (attr);
      cu->header.base_known = 1;
d2332 1
a2332 1
      attr = dwarf2_attr (cu->dies, DW_AT_low_pc, cu);
d2335 2
a2336 2
	  cu->header.base_address = DW_ADDR (attr);
	  cu->header.base_known = 1;
d2341 1
a2341 1
  process_die (cu->dies, cu);
d2346 1
a2346 1
  get_scope_pc_bounds (cu->dies, &lowpc, &highpc, cu);
d2354 1
a2354 1
      && !(cu->language == language_c && symtab->language != language_c))
d2356 1
a2356 1
      symtab->language = cu->language;
d2522 6
d4626 13
a5249 28

      /* If this attribute is an absolute reference to a different
	 compilation unit, make sure that compilation unit is loaded
	 also.  */
      if (die->attrs[i].form == DW_FORM_ref_addr
	  && (DW_ADDR (&die->attrs[i]) < cu->header.offset
	      || (DW_ADDR (&die->attrs[i])
		  >= cu->header.offset + cu->header.length)))
	{
	  struct dwarf2_per_cu_data *per_cu;
	  per_cu = dwarf2_find_containing_comp_unit (DW_ADDR (&die->attrs[i]),
						     cu);

	  /* If it's already on the queue, we have nothing to do.  */
	  if (per_cu->queued)
	    continue;

	  /* If the compilation unit is already loaded, just mark it as
	     used.  */
	  if (per_cu->cu != NULL)
	    {
	      per_cu->cu->last_used = 0;
	      continue;
	    }

	  /* Add it to the queue.  */
	  queue_comp_unit (per_cu);
       }
d5277 1
a5277 1
      blk = dwarf_alloc_block (cu);
d5285 1
a5285 1
      blk = dwarf_alloc_block (cu);
d5314 1
a5314 1
      blk = dwarf_alloc_block (cu);
d5322 1
a5322 1
      blk = dwarf_alloc_block (cu);
d8130 1
a8130 12

  if (attr->form == DW_FORM_ref_addr
      && (DW_ADDR (attr) < cu->header.offset
	  || DW_ADDR (attr) >= cu->header.offset + cu->header.length))
    {
      struct dwarf2_per_cu_data *per_cu;
      per_cu = dwarf2_find_containing_comp_unit (DW_ADDR (attr),
						 cu);
      *spec_cu = per_cu->cu;
    }
  else
    *spec_cu = cu;
d8400 1
a8400 1
dwarf_alloc_block (struct dwarf2_cu *cu)
d8405 1
a8405 1
    obstack_alloc (&cu->partial_die_obstack, sizeof (struct dwarf_block));
a8900 19
/* Return the partial_symtab associated with the compilation unit at OFFSET
   in OBJFILE.  Any compilation units read in before we decided to create
   the tree will not have the psymtab cached in their per_cu data.  */
static struct partial_symtab *
dwarf2_find_comp_unit_psymtab (unsigned int offset, struct objfile *objfile)
{
  struct partial_symtab *pst;

  ALL_PSYMTABS (objfile, pst)
    {
      if (DWARF_INFO_OFFSET (pst) == offset)
	return pst;
    }

  internal_error (__FILE__, __LINE__,
		  "could not find partial symtab for offset %d",
		  offset);
}

a8924 2
	  if (per_cu->cu->dies)
	    free_die_list (per_cu->cu->dies);
d9029 1
a9029 1
get_die_type (struct die_info *die, htab_t type_hash, struct dwarf2_cu *cu)
d9031 1
d9034 1
a9046 5
  htab_t type_hash;

  type_hash = PST_PRIVATE (cu->per_cu->psymtab)->type_hash;
  if (type_hash == NULL)
    return;
d9050 1
a9050 1
      die->type = get_die_type (die, type_hash, cu);
@


1.135.2.31
log
@	* dwarf2read.c (MAX_CACHE_AGE): Lower to 5.
	(struct dwarf2_cu): Add dependencies and mark fields.
	(free_one_comp_unit): New function, broken out from
	free_comp_units_worker.
	(dwarf2_add_dependence, dwarf2_clear_marks, dwarf2_mark)
	(dwarf2_mark_helper): New functions.
	(psymtab_to_symtab_1): Call free_one_comp_unit.  Re-enable
	aging.
	(read_full_die): Call dwarf2_add_dependence.
	(free_comp_units_worker): Call free_one_comp_unit.  Use
	marking to free old comp units.
@
text
@d55 3
a57 6
/* Loaded secondary compilation units are kept in memory until they
   have not been referenced for the processing of this many
   compilation units.  Set this to zero to disable caching.  Cache
   sizes of up to at least twenty will improve startup time for
   typical inter-CU-reference binaries, at an obvious memory cost.  */
#define MAX_CACHE_AGE 5
a338 8

  /* A tree of pointers to dwarf2_per_cu_data objects for compilation
     units referenced by this one.  Only set during full symbol processing;
     partial symbol tables do not have dependencies.  */
  splay_tree dependencies;

  /* Mark used when releasing cached dies.  */
  unsigned int mark : 1;
a978 2
static void free_one_comp_unit (struct dwarf2_cu *);

a1000 7
static void dwarf2_add_dependence (struct dwarf2_cu *,
				   struct dwarf2_per_cu_data *);

static void dwarf2_mark (struct dwarf2_cu *);

static void dwarf2_clear_marks (struct dwarf2_per_cu_data *);

d2350 5
a2354 1
      free_one_comp_unit (cu);
d2372 11
a2382 3
      /* Aging is a very important performance improvement.  My
         testing shows a factor of six loss from disabling the
         caching.  */
d2384 2
a5393 2
	  dwarf2_add_dependence (cu, per_cu);

a9089 11
/* Release one cached compilation unit, CU.  */

static void
free_one_comp_unit (struct dwarf2_cu *cu)
{
  obstack_free (&cu->partial_die_obstack, NULL);
  if (cu->dies)
    free_die_list (cu->dies);
  xfree (cu);
}

a9100 13
  if (aging)
    {
      dwarf2_clear_marks (dwarf2_per_objfile->read_in_chain);
      per_cu = dwarf2_per_objfile->read_in_chain;
      while (per_cu != NULL)
	{
	  per_cu->cu->last_used ++;
	  if (per_cu->cu->last_used <= MAX_CACHE_AGE)
	    dwarf2_mark (per_cu->cu);
	  per_cu = per_cu->cu->read_in_chain;
	}
    }

d9109 1
a9109 1
      if ((aging && !per_cu->cu->mark)
d9113 4
a9116 1
	  free_one_comp_unit (per_cu->cu);
a9246 58
    }
}

/* Add a dependence relationship from CU to REF_PER_CU.  */

static void
dwarf2_add_dependence (struct dwarf2_cu *cu,
		       struct dwarf2_per_cu_data *ref_per_cu)
{
  if (cu->dependencies == NULL)
    cu->dependencies
      = splay_tree_new_with_allocator (splay_tree_compare_ints,
				       NULL, NULL,
				       splay_tree_obstack_allocate,
				       splay_tree_obstack_deallocate,
				       &cu->partial_die_obstack);

  if (splay_tree_lookup (cu->dependencies, ref_per_cu->offset) == NULL)
    splay_tree_insert (cu->dependencies, ref_per_cu->offset, 
		       (splay_tree_value) ref_per_cu);
}

/* Set the mark field in CU and in every other compilation unit in the
   cache that we must keep because we are keeping CU.  */

static int
dwarf2_mark_helper (splay_tree_node node, void *data)
{
  struct dwarf2_per_cu_data *per_cu;

  per_cu = (struct dwarf2_per_cu_data *) node->value;
  if (per_cu->cu->mark)
    return 0;
  per_cu->cu->mark = 1;

  if (per_cu->cu->dependencies != NULL)
    splay_tree_foreach (per_cu->cu->dependencies, dwarf2_mark_helper, NULL);

  return 0;
}

static void
dwarf2_mark (struct dwarf2_cu *cu)
{
  if (cu->mark)
    return;
  cu->mark = 1;
  if (cu->dependencies != NULL)
    splay_tree_foreach (cu->dependencies, dwarf2_mark_helper, NULL);
}

static void
dwarf2_clear_marks (struct dwarf2_per_cu_data *per_cu)
{
  while (per_cu)
    {
      per_cu->cu->mark = 0;
      per_cu = per_cu->cu->read_in_chain;
@


1.135.2.32
log
@	* dwarf2read.c (free_one_comp_unit): Update signature so it can be
	used as a cleanup.  Clear the per_cu pointer.  Add some comments.
	(free_one_cached_comp_unit): Update signature so it can be used
	as a cleanup.  Remove unused argument.
	(dwarf2_build_psymtabs_hard): Update call to
	free_one_cached_comp_unit.  Don't free the obstack here.
	(process_queue): Keep dwarf2_queue up to date as we remove items
	from the queue.
	(dwarf2_release_queue): New function.
	(psymtab_to_symtab_1): Use cleanups.
	(load_full_comp_unit): Likewise.
	(free_comp_units_worker): Remove clearing of the cu pointer.
	(clear_per_cu_pointer): Also free the partial_die_obstack.  Update
	comments.
@
text
@d990 1
a990 1
static void free_one_comp_unit (void *);
d998 1
a998 1
static void free_one_cached_comp_unit (void *);
d1449 1
a1449 1
	    free_one_cached_comp_unit (per_cu->cu);
d1489 3
a2348 27
      dwarf2_queue = item = last->next;
      xfree (last);
    }
}

/* Free all allocated queue entries.  This function only releases anything if
   an error was thrown; if the queue was processed then it would have been
   freed as we went along.  */

static void
dwarf2_release_queue (void *dummy)
{
  struct dwarf2_queue_item *item, *last;

  item = dwarf2_queue;
  while (item)
    {
      /* Anything still marked queued is likely to be in an
	 inconsistent state, so discard it.  */
      if (item->per_cu->queued)
	{
	  if (item->per_cu->cu != NULL)
	    free_one_cached_comp_unit (item->per_cu->cu);
	  item->per_cu->queued = 0;
	}

      last = item;
d2364 1
a2368 1
      make_cleanup (free_one_comp_unit, cu);
d2370 1
a2383 3

      make_cleanup (dwarf2_release_queue, NULL);

a2392 2

  do_cleanups (back_to);
d2395 1
d2404 1
a2404 1
  struct cleanup *back_to, *free_cu_cleanup;
a2414 3
  /* If an error occurs while loading, release our storage.  */
  free_cu_cleanup = make_cleanup (free_one_comp_unit, cu);

a2446 4
  /* We've successfully allocated this compilation unit.  Let our caller
     clean it up when finished with it.  */
  discard_cleanups (free_cu_cleanup);

d9098 1
a9098 3
/* Release one cached compilation unit, CU.  We unlink it from the tree
   of compilation units, but we don't remove it from the read_in_chain
   (so it should not be on that chain to begin with).  */
d9101 1
a9101 1
free_one_comp_unit (void *data)
a9102 6
  struct dwarf2_cu *cu = data;

  if (cu->per_cu != NULL)
    cu->per_cu->cu = NULL;
  cu->per_cu = NULL;

a9105 1

d9146 1
a9158 7
/* This cleanup function is passed the address of a dwarf2_cu on the stack
   when we're finished with it.  We can't free the pointer itself, but be
   sure to unlink it from the cache.  Also release any associated storage
   and perform cache maintenance.

   Only used during partial symbol parsing.  */

d9166 1
a9166 2
      obstack_free (&cu->partial_die_obstack, NULL);
      cu->partial_dies = NULL;
a9171 2

      age_cached_comp_units (NULL);
d9188 1
a9188 1
free_one_cached_comp_unit (void *target_cu)
@


1.135.2.33
log
@	* dwarf2read.c (skip_leb128, peek_die_abbrev, skip_one_die)
	(skip_children, locate_pdi_sibling): Update comments and
	clean up.
@
text
@a1058 3
static char *skip_one_die (char *info_ptr, struct abbrev_info *abbrev,
			   struct dwarf2_cu *cu);

a2095 5
/* Read the initial uleb128 in the die at INFO_PTR in compilation unit CU.
   Return the corresponding abbrev, or NULL if the number is zero (indicating
   an empty DIE).  In either case *BYTES_READ will be set to the length of
   the initial number.  */

d2118 2
a2119 3
/* Scan the debug information for CU starting at INFO_PTR.  Returns a
   pointer to the end of a series of DIEs, terminated by an empty
   DIE.  Any children of the skipped DIEs will also be skipped.  */
d2127 4
a2140 5
/* Scan the debug information for CU starting at INFO_PTR.  INFO_PTR
   should point just after the initial uleb128 of a DIE, and the
   abbrev corresponding to that skipped uleb128 should be passed in
   ABBREV.  Returns a pointer to this DIE's sibling, skipping any
   children.  */
a2152 1
      /* The only abbrev we care about is DW_AT_sibling.  */
a2161 2

      /* If it isn't DW_AT_sibling, skip this attribute.  */
d2163 1
a2163 1
    skip_attribute:
d2170 5
a2174 4
	case DW_FORM_data1:
	case DW_FORM_ref1:
	case DW_FORM_flag:
	  info_ptr += 1;
d2202 4
a2205 5
	case DW_FORM_block2:
	  info_ptr += 2 + read_2_bytes (abfd, info_ptr);
	  break;
	case DW_FORM_block4:
	  info_ptr += 4 + read_4_bytes (abfd, info_ptr);
d2215 1
a2215 4
	  /* We need to continue parsing from here, so just go back to
	     the top.  */
	  goto skip_attribute;

d2229 2
a2230 2
/* Locate ORIG_PDI's sibling; INFO_PTR should point to the start of
   the next DIE after ORIG_PDI.  */
a5906 2

/* Return a pointer to just past the end of an LEB128 number in BUF.  */
@


1.135.2.34
log
@	* dwarf2read.c (struct comp_unit_head): Remove dwarf2_abbrevs array.
	(struct dwarf2_cu): Add dwarf2_abbrevs pointer.  Update comment about
	comp_unit_head.
	(dwarf2_free_abbrev_table): Renamed from dwarf2_empty_abbrev_table.
	Clear the pointer abbrev table pointer.
	(dwarf2_build_psymtabs_hard, load_comp_unit, load_full_comp_unit):
	Update calls.
	(dwarf2_read_abbrevs): Update for moved dwarf2_abbrevs pointer.
	Allocate the hash table from the obstack.
	(dwarf2_lookup_abbrev): Update for moved dwarf2_abbrevs pointer.
@
text
@d261 4
d288 2
a289 1
     should logically be moved to the dwarf2_cu structure.  */
a322 4
  /* DWARF abbreviation table associated with this compilation unit.  */
  struct abbrev_info **dwarf2_abbrevs;

  /* Storage for the abbrev table.  */
d707 1
a707 1
static void dwarf2_free_abbrev_table (void *);
d1409 1
a1409 1
      back_to_inner = make_cleanup (dwarf2_free_abbrev_table, &cu);
d1558 1
a1558 1
  back_to = make_cleanup (dwarf2_free_abbrev_table, cu);
d2468 1
a2468 1
  back_to = make_cleanup (dwarf2_free_abbrev_table, cu);
d4872 2
a4873 5
  cu->dwarf2_abbrevs = obstack_alloc (&cu->abbrev_obstack,
				      (ABBREV_HASH_SIZE
				       * sizeof (struct abbrev_info *)));
  memset (cu->dwarf2_abbrevs, 0,
          ABBREV_HASH_SIZE * sizeof (struct abbrev_info *));
d4932 2
a4933 2
      cur_abbrev->next = cu->dwarf2_abbrevs[hash_number];
      cu->dwarf2_abbrevs[hash_number] = cur_abbrev;
d4956 1
a4956 1
/* Release the memory used by the abbrev table for a compilation unit.  */
d4959 1
a4959 1
dwarf2_free_abbrev_table (void *ptr_to_cu)
a4963 1
  cu->dwarf2_abbrevs = NULL;
d4971 1
d4976 1
a4976 1
  abbrev = cu->dwarf2_abbrevs[hash_number];
@


1.135.2.35
log
@	* dwarf2read.c (read_structure_type): Renamed from
	read_structure_scope.
	(process_enumeration_scope): Renamed from read_enumeration_scope.
	(add_partial_structure, process_die, new_symbol)
	(read_type_die): Update calls and comments.
@
text
@d858 1
a858 1
static void read_structure_type (struct die_info *, struct dwarf2_cu *);
d871 1
a871 1
static void process_enumeration_scope (struct die_info *, struct dwarf2_cu *);
d2046 1
a2046 1
	 prefix (but see comment in read_structure_type).  */
d2598 1
a2598 1
      read_structure_type (die, cu);
d2603 1
a2603 1
      process_enumeration_scope (die, cu);
d2606 3
a2608 3
    /* FIXME drow/2004-03-14: These initialize die->type, but do not create
       a symbol or process any children.  Therefore it doesn't do anything
       that won't be done on-demand by read_type_die.  */
d3644 1
a3644 1
read_structure_type (struct die_info *die, struct dwarf2_cu *cu)
d3966 1
a3966 1
process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)
d6709 1
a6709 1
	     read_structure_type, and the correct name is saved in
d7051 1
a7051 1
      read_structure_type (die, cu);
@


1.135.2.36
log
@Merge mainline to intercu branch.
@
text
@a54 14
/* A note on memory usage for this file.
   
   At the present time, this code reads the debug info sections into
   the objfile's objfile_obstack.  A definite improvement for startup
   time, on platforms which do not emit relocations for debug
   sections, would be to use mmap instead.  The object's complete
   debug information is loaded into memory, partly to simplify
   absolute DIE references.

   Whether using obstacks or mmap, the sections should remain loaded
   until the objfile is released, and pointers into the section data
   can be used for any other data associated to the objfile (symbol
   names, type names, location expressions to name a few).  */

d315 3
a323 3
  htab_t partial_dies;
  struct obstack partial_die_obstack;

d542 2
a543 1

d545 3
a547 3
   object file and could be passed via the sym_private field of the
   objfile.  It is possible to have both dwarf2 and some other form
   of debug symbols in one object file.  */
d820 2
d824 2
a861 2
static char *determine_class_name (struct die_info *die, struct dwarf2_cu *cu);

a1019 3
static char *skip_one_die (char *info_ptr, struct abbrev_info *abbrev,
			   struct dwarf2_cu *cu);

d1058 3
d1328 1
a1382 1
      struct dwarf2_cu cu;
d2257 1
a2257 1

d3312 2
a3313 4

      /* The name is already allocated along with this objfile, so we don't
	 need to duplicate it for the type.  */
      fp->name = fieldname;
d3344 2
a3345 3
      /* The name is already allocated along with this objfile, so we don't
	 need to duplicate it for the type.  */
      SET_FIELD_PHYSNAME (*fp, physname ? physname : "");
d3347 2
a3348 1
      FIELD_NAME (*fp) = fieldname;
d3517 2
a3518 3
  /* The name is already allocated along with this objfile, so we don't
     need to duplicate it for the type.  */
  fnp->physname = physname ? physname : "";
d3649 1
d3652 4
a3655 3

  if (die->type)
    return;
d3666 2
d3670 25
a3694 5
	  char *new_prefix = determine_class_name (die, cu);
	  TYPE_TAG_NAME (type) = obsavestring (new_prefix,
					       strlen (new_prefix),
					       &objfile->objfile_obstack);
	  back_to = make_cleanup (xfree, new_prefix);
d3699 3
a3701 3
	  /* The name is already allocated along with this objfile, so
	     we don't need to duplicate it for the type.  */
	  TYPE_TAG_NAME (type) = DW_STRING (attr);
d3762 35
a3879 1
  struct die_info *child_die = die->child;
d3884 7
a3890 12
  /* NOTE: carlton/2004-03-16: GCC 3.4 (or at least one of its
     snapshots) has been known to create a die giving a declaration
     for a class that has, as a child, a die giving a definition for a
     nested class.  So we have to process our children even if the
     current die is a declaration.  Normally, of course, a declaration
     won't have any children at all.  */

  while (child_die != NULL && child_die->tag)
    {
      if (child_die->tag == DW_TAG_member
	  || child_die->tag == DW_TAG_variable
	  || child_die->tag == DW_TAG_inheritance)
d3892 10
a3901 1
	  /* Do nothing.  */
a3902 2
      else
	process_die (child_die, cu);
d3904 1
a3904 1
      child_die = sibling_die (child_die);
a3906 3
  if (die->child != NULL && ! die_is_declaration (die, cu))
    new_symbol (die, die->type, cu);

d3929 1
a3929 1
      char *name = DW_STRING (attr);
d3941 2
a3942 3
	  /* The name is already allocated along with this objfile, so
	     we don't need to duplicate it for the type.  */
	  TYPE_TAG_NAME (type) = name;
a3958 57
/* Determine the name of the type represented by DIE, which should be
   a named C++ compound type.  Return the name in question; the caller
   is responsible for xfree()'ing it.  */

static char *
determine_class_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct cleanup *back_to = NULL;
  struct dwarf2_cu *spec_cu;
  struct die_info *spec_die = die_specification (die, cu, &spec_cu);
  char *new_prefix = NULL;

  /* If this is the definition of a class that is declared by another
     die, then processing_current_prefix may not be accurate; see
     read_func_scope for a similar example.  */
  if (spec_die != NULL)
    {
      char *specification_prefix = determine_prefix (spec_die, spec_cu);
      processing_current_prefix = specification_prefix;
      back_to = make_cleanup (xfree, specification_prefix);
    }

  /* If we don't have namespace debug info, guess the name by trying
     to demangle the names of members, just like we did in
     add_partial_structure.  */
  if (!processing_has_namespace_info)
    {
      struct die_info *child;

      for (child = die->child;
	   child != NULL && child->tag != 0;
	   child = sibling_die (child))
	{
	  if (child->tag == DW_TAG_subprogram)
	    {
	      new_prefix = class_name_from_physname (dwarf2_linkage_name
						     (child, cu));

	      if (new_prefix != NULL)
		break;
	    }
	}
    }

  if (new_prefix == NULL)
    {
      const char *name = dwarf2_name (die, cu);
      new_prefix = typename_concat (processing_current_prefix,
				    name ? name : "<<anonymous>>");
    }

  if (back_to != NULL)
    do_cleanups (back_to);

  return new_prefix;
}

a4210 1
      set_die_type (die, type, cu);
d6720 5
a6724 5
		     arises further down in this function.)  */
		  /* The type's name is already allocated along with
		     this objfile, so we don't need to duplicate it
		     for the symbol.  */
		  SYMBOL_LINKAGE_NAME (sym) = TYPE_TAG_NAME (type);
a6754 3
		/* The symbol's name is already allocated along with
		   this objfile, so we don't need to duplicate it for
		   the type.  */
d6756 4
a6759 1
		  TYPE_NAME (SYMBOL_TYPE (sym)) = SYMBOL_NATURAL_NAME (sym);
d7110 12
d7131 1
a7131 1
      return xstrdup ("");
d7135 3
d7141 4
a7144 16
	  /* FIXME: carlton/2004-03-05: Should I follow extension dies
	     before doing this check?  */
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
	    {
	      return xstrdup (TYPE_TAG_NAME (parent->type));
	    }
	  else
	    {
	      int dummy;
	      char *parent_prefix = determine_prefix (parent, cu);
	      char *retval = typename_concat (parent_prefix,
					      namespace_name (parent, &dummy,
							      cu));
	      xfree (parent_prefix);
	      return retval;
	    }
d7150 1
a7150 1
	  if (parent->type != NULL && TYPE_TAG_NAME (parent->type) != NULL)
d7152 9
a7160 1
	      return xstrdup (TYPE_TAG_NAME (parent->type));
d7163 1
a7163 12
	    {
	      const char *old_prefix = processing_current_prefix;
	      char *new_prefix = determine_prefix (parent, cu);
	      char *retval;

	      processing_current_prefix = new_prefix;
	      retval = determine_class_name (parent, cu);
	      processing_current_prefix = old_prefix;

	      xfree (new_prefix);
	      return retval;
	    }
d7165 1
d7167 2
a7168 1
	return determine_prefix (parent, cu);
d7170 4
d7196 22
@


1.135.2.37
log
@	* dwarf2read.c (struct dwarf2_cu): Add has_form_ref_addr and
	has_namespace_info.
	(dwarf2_read_abbrevs): Set the new flags.  Change return type back
	to void.  Update comments.
	(dwarf2_build_psymtabs_hard): Update call to dwarf2_read_abbrevs.
	Use new has_form_ref_addr flag.  Update call to
	scan_partial_symbols.
	(scan_partial_symbols, add_partial_symbol, add_partial_structure)
	(add_partial_enumeration, add_partial_namespace): Remove
	have_namespace_info argument.  Use new has_namespace_info CU flag.
	Update calls to changed functions.
@
text
@a362 10

  /* This flag will be set if this compilation unit might include
     inter-compilation-unit references.  */
  unsigned int has_form_ref_addr : 1;

  /* This flag will be set if this compilation unit includes any
     DW_TAG_namespace DIEs.  If we know that there are explicit
     DIEs for namespaces, we don't need to try to infer them
     from mangled names.  */
  unsigned int has_namespace_info : 1;
d687 1
a687 1
				  struct dwarf2_cu *);
d689 2
a690 2
static void add_partial_symbol (struct partial_die_info *,
				struct dwarf2_cu *);
d699 2
a700 1
				   struct dwarf2_cu *cu);
d703 2
a704 1
				     struct dwarf2_cu *cu);
d717 1
a717 1
static void dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu);
d1397 1
d1418 1
a1418 1
      dwarf2_read_abbrevs (abfd, &cu);
d1421 1
a1421 1
      if (cu.has_form_ref_addr && cu_tree == NULL)
d1500 1
a1500 1
	  scan_partial_symbols (first_die, &lowpc, &highpc, &cu);
d1662 2
a1663 1
		      CORE_ADDR *highpc, struct dwarf2_cu *cu)
d1701 1
a1701 1
		      add_partial_symbol (pdi_p, cu);
d1710 1
a1710 1
		  add_partial_symbol (pdi_p, cu);
d1717 1
a1717 1
		  add_partial_structure (pdi_p, cu);
d1722 1
a1722 1
		add_partial_enumeration (pdi_p, cu);
d1728 1
a1728 1
	      add_partial_symbol (pdi_p, cu);
d1731 4
d1809 2
a1810 1
add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)
d1967 1
a1967 1
      && cu->has_namespace_info == 0
d2022 1
a2022 1
  add_partial_symbol (pdi, cu);
d2027 2
a2028 1
    scan_partial_symbols (pdi->die_child, lowpc, highpc, cu);
d2035 2
a2036 1
		       struct dwarf2_cu *cu)
d2045 1
a2045 1
      && cu->has_namespace_info == 0
d2082 1
a2082 1
  add_partial_symbol (struct_pdi, cu);
d2089 1
a2089 1
			 struct dwarf2_cu *cu)
d2096 1
a2096 1
    add_partial_symbol (enum_pdi, cu);
d2104 1
a2104 1
	add_partial_symbol (pdi_p, cu);
d4871 1
a4871 2
   in a hash table.  This function also sets flags in CU describing
   the data found in the abbrev table.  */
d4873 1
a4873 1
static void
d4883 1
a4911 3
      if (cur_abbrev->tag == DW_TAG_namespace)
	cu->has_namespace_info = 1;

d4927 7
a4933 9
	  /* Record whether this compilation unit might have
	     inter-compilation-unit references.  If we don't know what form
	     this attribute will have, then it might potentially be a
	     DW_FORM_ref_addr, so we conservatively expect inter-CU
	     references.  */

	  if (abbrev_form == DW_FORM_ref_addr
	      || abbrev_form == DW_FORM_indirect)
	    cu->has_form_ref_addr = 1;
d4970 2
@


1.135.2.38
log
@	* dwarf2read.c (struct partial_die_info): Replace full_name and
	full_name_set with scope and scope_set.
	(partial_die_parent_scope): New function.
	(partial_die_full_name): Use it.
	(add_partial_symbol): Don't check full_name_set or set full_name.
	(add_partial_namespace): Remove unused variable.
	(guess_partial_structure): New function, broken out from
	add_partial_structure.  Set the name field of the partial DIE.
	(add_partial_structure): Simplify.
	(find_partial_die): Always set *TARGET_CU.
	(fixup_partial_die): Call guess_structure_scope.  Set the names
	of anonymous classes and namespaces.
@
text
@d529 1
a529 1
    unsigned int scope_set : 1;
d531 1
a531 6

    /* The scope to prepend to our children.  This is generally
       allocated on the partial_die_obstack, so will disappear
       when this compilation unit leaves the cache.  */
    char *scope;

d1750 3
a1752 23
/* Functions used to compute the fully scoped name of a partial DIE.

   Normally, this is simple.  For C++, the parent DIE's fully scoped
   name is concatenated with "::" and the partial DIE's name.
   Enumerators are an exception; they use the scope of their parent
   enumeration type, i.e. the name of the enumeration type is not
   prepended to the enumerator.

   There are two complexities.  One is DW_AT_specification; in this
   case "parent" means the parent of the target of the specification,
   instead of the direct parent of the DIE.  The other is compilers
   which do not emit DW_TAG_namespace; in this case we try to guess
   the fully qualified name of structure types from their members'
   linkage names.  This must be done using the DIE's children rather
   than the children of any DW_AT_specification target.  We only need
   to do this for structures at the top level, i.e. if the target of
   any DW_AT_specification (if any; otherwise the DIE itself) does not
   have a parent.  */

/* Compute the scope prefix associated with PDI's parent, in
   compilation unit CU.  The result will be allocated on CU's
   partial_die_obstack, or a copy of the already allocated PDI->NAME
   field.  NULL is returned if no prefix is necessary.  */
d1754 2
a1755 2
partial_die_parent_scope (struct partial_die_info *pdi,
			  struct dwarf2_cu *cu)
d1757 2
a1758 2
  char *grandparent_scope;
  struct partial_die_info *parent, *real_pdi;
d1760 1
d1762 6
a1767 2
  /* We need to look at our parent DIE; if we have a DW_AT_specification,
     then this means the parent of the specification DIE.  */
d1774 3
a1776 3
  parent = real_pdi->die_parent;
  if (parent == NULL)
    return NULL;
d1778 2
a1779 2
  if (parent->scope_set)
    return parent->scope;
d1781 2
a1782 8
  fixup_partial_die (parent, cu);

  grandparent_scope = partial_die_parent_scope (parent, spec_cu);

  if (parent->tag == DW_TAG_namespace
      || parent->tag == DW_TAG_structure_type
      || parent->tag == DW_TAG_class_type
      || parent->tag == DW_TAG_union_type)
d1784 2
a1785 5
      if (grandparent_scope == NULL)
	parent->scope = parent->name;
      else
	parent->scope = obconcat (&cu->partial_die_obstack, grandparent_scope,
				  "::", parent->name);
d1787 2
a1788 4
  else if (parent->tag == DW_TAG_enumeration_type)
    /* Enumerators should not get the name of the enumeration as a prefix.  */
    parent->scope = grandparent_scope;
  else
d1790 5
a1794 7
      /* FIXME drow/2004-04-01: What should we be doing with
	 function-local names?  For partial symbols, we should probably be
	 ignoring them.  */
      complaint (&symfile_complaints,
		 "unhandled containing DIE tag %d for DIE at %d",
		 parent->tag, pdi->offset);
      parent->scope = grandparent_scope;
a1795 4
  
  parent->scope_set = 1;
  return parent->scope;
}
d1797 6
a1802 7
/* Return the fully scoped name associated with PDI, from compilation unit
   CU.  The result will be allocated with malloc.  */
static char *
partial_die_full_name (struct partial_die_info *pdi,
		       struct dwarf2_cu *cu)
{
  char *parent_scope;
d1804 4
a1807 5
  parent_scope = partial_die_parent_scope (pdi, cu);
  if (parent_scope == NULL)
    return NULL;
  else
    return concat (parent_scope, "::", pdi->name, NULL);
d1824 3
a1826 2

  if (pdi_needs_namespace (pdi->tag))
d1834 8
a1841 1
    actual_name = pdi->name;
d1979 1
d2016 1
d2031 1
a2031 3
/* See if we can figure out if the class lives in a namespace.  We do
   this by looking for a member function; its demangled name will
   contain namespace info, if there is any.  */
d2033 3
a2035 3
void
guess_structure_name (struct partial_die_info *struct_pdi,
		      struct dwarf2_cu *cu)
d2037 6
d2047 5
a2058 14
      struct partial_die_info *real_pdi;
      struct dwarf2_cu *spec_cu;

      /* If this DIE (this DIE's specification, if any) has a parent, then
	 we should not do this.  We'll prepend the parent's fully qualified
         name when we create the partial symbol.  */

      real_pdi = struct_pdi;
      spec_cu = cu;
      while (real_pdi->has_specification)
	real_pdi = find_partial_die (real_pdi->spec_offset, spec_cu, &spec_cu);

      if (real_pdi->die_parent != NULL)
	return;
d2068 1
a2068 1
		  struct_pdi->name
a2079 12
}

/* Read a partial die corresponding to a class or structure.  */

static void
add_partial_structure (struct partial_die_info *struct_pdi,
		       struct dwarf2_cu *cu)
{
  bfd *abfd = cu->objfile->obfd;

  if (struct_pdi->name == NULL)
    struct_pdi->name = "(anonymous class)";
d5365 1
a5365 4
    {
      *target_cu = cu;
      return find_partial_die_in_comp_unit (offset, cu);
    }
d5386 2
a5387 2
  /* If we found a reference attribute and the DIE has no name, try
     to find a name in the referred to DIE.  */
a5406 13

  /* Set default names for some unnamed DIEs.  */
  if (part_die->name == NULL && (part_die->tag == DW_TAG_structure_type
				 || part_die->tag == DW_TAG_class_type))
    part_die->name = "(anonymous class)";

  if (part_die->name == NULL && part_die->tag == DW_TAG_namespace)
    part_die->name = "(anonymous namespace)";

  if (part_die->tag == DW_TAG_structure_type
      || part_die->tag == DW_TAG_structure_type
      || part_die->tag == DW_TAG_union_type)
    guess_structure_name (part_die, cu);
@


1.135.2.39
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d152 1
a152 1
static const struct objfile_data *dwarf2_objfile_data_key;
d154 1
a154 1
struct dwarf2_per_objfile
d157 11
a167 11
  unsigned int info_size;
  unsigned int abbrev_size;
  unsigned int line_size;
  unsigned int pubnames_size;
  unsigned int aranges_size;
  unsigned int loc_size;
  unsigned int macinfo_size;
  unsigned int str_size;
  unsigned int ranges_size;
  unsigned int frame_size;
  unsigned int eh_frame_size;
d170 7
a176 7
  char *info_buffer;
  char *abbrev_buffer;
  char *line_buffer;
  char *str_buffer;
  char *macinfo_buffer;
  char *ranges_buffer;
  char *loc_buffer;
d188 21
a208 1
static struct dwarf2_per_objfile *dwarf2_per_objfile;
d434 1
a434 1
     header.  These point into dwarf2_per_objfile->line_buffer.  */
d570 6
a575 1
   of the psymtab.  */
a578 4
    /* Offset in .debug_info for this compilation unit. */

    unsigned long dwarf_info_offset;

d581 3
d585 1
a585 1
    htab_t type_hash;
d1091 1
a1091 1
  struct dwarf2_per_objfile *data;
d1096 1
a1096 1
  set_objfile_data (objfile, dwarf2_objfile_data_key, data);
d1122 1
a1122 1
      dwarf2_per_objfile->info_size = bfd_get_section_size_before_reloc (sectp);
d1127 1
a1127 1
      dwarf2_per_objfile->abbrev_size = bfd_get_section_size_before_reloc (sectp);
d1132 1
a1132 1
      dwarf2_per_objfile->line_size = bfd_get_section_size_before_reloc (sectp);
d1137 1
a1137 1
      dwarf2_per_objfile->pubnames_size = bfd_get_section_size_before_reloc (sectp);
d1142 1
a1142 1
      dwarf2_per_objfile->aranges_size = bfd_get_section_size_before_reloc (sectp);
d1147 1
a1147 1
      dwarf2_per_objfile->loc_size = bfd_get_section_size_before_reloc (sectp);
d1152 1
a1152 1
      dwarf2_per_objfile->macinfo_size = bfd_get_section_size_before_reloc (sectp);
d1157 1
a1157 1
      dwarf2_per_objfile->str_size = bfd_get_section_size_before_reloc (sectp);
d1162 1
a1162 1
      dwarf2_per_objfile->frame_size = bfd_get_section_size_before_reloc (sectp);
d1170 1
a1170 1
          dwarf2_per_objfile->eh_frame_size = bfd_get_section_size_before_reloc (sectp);
d1176 1
a1176 1
      dwarf2_per_objfile->ranges_size = bfd_get_section_size_before_reloc (sectp);
d1188 2
a1189 2
  dwarf2_per_objfile->info_buffer = dwarf2_read_section (objfile, dwarf_info_section);
  dwarf2_per_objfile->abbrev_buffer = dwarf2_read_section (objfile, dwarf_abbrev_section);
d1192 1
a1192 1
    dwarf2_per_objfile->line_buffer = dwarf2_read_section (objfile, dwarf_line_section);
d1194 1
a1194 1
    dwarf2_per_objfile->line_buffer = NULL;
d1197 1
a1197 1
    dwarf2_per_objfile->str_buffer = dwarf2_read_section (objfile, dwarf_str_section);
d1199 1
a1199 1
    dwarf2_per_objfile->str_buffer = NULL;
d1202 1
a1202 1
    dwarf2_per_objfile->macinfo_buffer = dwarf2_read_section (objfile,
d1205 1
a1205 1
    dwarf2_per_objfile->macinfo_buffer = NULL;
d1208 1
a1208 1
    dwarf2_per_objfile->ranges_buffer = dwarf2_read_section (objfile, dwarf_ranges_section);
d1210 1
a1210 1
    dwarf2_per_objfile->ranges_buffer = NULL;
d1213 1
a1213 1
    dwarf2_per_objfile->loc_buffer = dwarf2_read_section (objfile, dwarf_loc_section);
d1215 1
a1215 1
    dwarf2_per_objfile->loc_buffer = NULL;
d1256 1
a1256 1
  while ((pubnames_ptr - pubnames_buffer) < dwarf2_per_objfile->pubnames_size)
d1318 1
a1318 1
  if (header->abbrev_offset >= dwarf2_per_objfile->abbrev_size)
d1322 1
a1322 1
	   (long) (beg_of_comp_unit - dwarf2_per_objfile->info_buffer),
d1326 1
a1326 1
      > dwarf2_per_objfile->info_buffer + dwarf2_per_objfile->info_size)
d1330 1
a1330 1
	   (long) (beg_of_comp_unit - dwarf2_per_objfile->info_buffer),
d1353 1
a1353 1
  info_ptr = dwarf2_per_objfile->info_buffer;
d1371 1
a1371 1
        the null-terminated string in info_buffer, so no dynamic
d1390 1
a1390 1
  /* Since the objects we're extracting from .debug_info vary in
d1395 5
a1399 5
     At the moment, they don't actually check that.  If .debug_info
     holds just one extra byte after the last compilation unit's dies,
     then read_comp_unit_head will happily read off the end of the
     buffer.  read_partial_die is similarly casual.  Those functions
     should be fixed.
d1403 1
a1403 2
  while (info_ptr < (dwarf2_per_objfile->info_buffer
		     + dwarf2_per_objfile->info_size))
d1419 1
a1419 1
      cu.header.offset = beg_of_comp_unit - dwarf2_per_objfile->info_buffer;
d1453 1
a1453 1
      DWARF_INFO_OFFSET (pst) = beg_of_comp_unit - dwarf2_per_objfile->info_buffer;
d1562 1
a1562 1
  info_ptr = dwarf2_per_objfile->info_buffer + this_cu->offset;
d1572 1
a1572 1
  cu->header.offset = beg_of_comp_unit - dwarf2_per_objfile->info_buffer;
d1625 1
a1625 1
  char *info_ptr = dwarf2_per_objfile->info_buffer;
d1635 1
a1635 1
  while (info_ptr < dwarf2_per_objfile->info_buffer + dwarf2_per_objfile->info_size)
d1643 1
a1643 1
      offset = beg_of_comp_unit - dwarf2_per_objfile->info_buffer;
d2226 1
a2226 2
	    return dwarf2_per_objfile->info_buffer
	      + dwarf2_get_ref_die_offset (&attr, cu);
d2343 1
a2343 1
					     dwarf2_objfile_data_key);
a2504 2
  dwarf2_per_objfile = objfile_data (pst->objfile, dwarf2_objfile_data_key);

d2508 1
a2508 1
  info_ptr = dwarf2_per_objfile->info_buffer + offset;
d3080 1
a3080 1
	  if (offset >= dwarf2_per_objfile->ranges_size)
d3087 1
a3087 1
	  buffer = dwarf2_per_objfile->ranges_buffer + offset;
d4938 1
a4938 1
  abbrev_ptr = dwarf2_per_objfile->abbrev_buffer + cu_header->abbrev_offset;
d5010 2
a5011 2
      if ((unsigned int) (abbrev_ptr - dwarf2_per_objfile->abbrev_buffer)
	  >= dwarf2_per_objfile->abbrev_size)
d5135 1
a5135 1
      //      fprintf_unfiltered (gdb_stderr, "Loading DIE %x\n", info_ptr - dwarf2_per_objfile->info_buffer);
d5286 1
a5286 1
  part_die->offset = info_ptr - dwarf2_per_objfile->info_buffer;
d5361 2
a5362 2
	    part_die->sibling = dwarf2_per_objfile->info_buffer
	      + dwarf2_get_ref_die_offset (&attr, cu);
d5484 1
a5484 1
  offset = info_ptr - dwarf2_per_objfile->info_buffer;
d5928 1
a5928 1
  if (dwarf2_per_objfile->str_buffer == NULL)
d5934 1
a5934 1
  if (str_offset >= dwarf2_per_objfile->str_size)
d5941 1
a5941 1
  if (dwarf2_per_objfile->str_buffer[str_offset] == '\0')
d5943 1
a5943 1
  return dwarf2_per_objfile->str_buffer + str_offset;
d6212 2
a6213 2
   .debug_line, according to the endianness of ABFD.  Return a pointer
   to a struct line_header, allocated using xmalloc.
d6229 1
a6229 1
  if (dwarf2_per_objfile->line_buffer == NULL)
d6237 1
a6237 1
  if (offset + 4 >= dwarf2_per_objfile->line_size)
d6248 1
a6248 1
  line_ptr = dwarf2_per_objfile->line_buffer + offset;
d6253 1
a6253 2
  if (line_ptr + lh->total_length > (dwarf2_per_objfile->line_buffer
				     + dwarf2_per_objfile->line_size))
d6309 1
a6309 2
  if (line_ptr > (dwarf2_per_objfile->line_buffer
		  + dwarf2_per_objfile->line_size))
d8962 1
a8962 1
  if (dwarf2_per_objfile->macinfo_buffer == NULL)
d8968 2
a8969 3
  mac_ptr = dwarf2_per_objfile->macinfo_buffer + offset;
  mac_end = dwarf2_per_objfile->macinfo_buffer
    + dwarf2_per_objfile->macinfo_size;
d9116 2
a9117 2
      baton->size = dwarf2_per_objfile->loc_size - DW_UNSND (attr);
      baton->data = dwarf2_per_objfile->loc_buffer + DW_UNSND (attr);
d9138 3
a9140 3
	     info_buffer for SYM's objfile; right now we never release
	     that buffer, but when we do clean up properly this may
	     need to change.  */
d9466 1
a9466 1
  dwarf2_objfile_data_key = register_objfile_data ();
@


1.135.2.40
log
@	* dwarf2read.c (struct dwarf2_cu): Add comments.  Rename
	partial_die_obstack to comp_unit_obstack.
	(struct partial_die_info): Move higher in file.  Add comments.
	Use ENUM_BITFIELD.
	(dwarf2_tmp_obstack, dwarf2_free_tmp_obstack): Remove.
	(partial_die_hash, partial_die_eq): Move lower in file.
	(hashtab_obstack_allocate): Likewise.  Renamed from
	hash_obstack_allocate.
	(dummy_obstack_deallocate): Likewise.  Renamed from
	splay_tree_obstack_deallocate.
	(dwarf2_build_psymtabs_hard): Remove references to
	dwarf2_tmp_obstack.  Update names of changed variables/functions.
	(load_comp_unit, create_comp_unit_tree, partial_die_parent_scope)
	(guess_structure_name, psymtab_to_symtab_1, load_full_comp_unit)
	(add_to_cu_func_list, load_partial_dies, dwarf_alloc_block)
	(free_one_comp_unit, clear_per_cu_pointer, set_die_type)
	(dwarf2_add_dependence): Likewise.
@
text
@a314 1
  /* Hash table holding all the loaded partial DIEs.  */
d316 1
a316 4

  /* Storage for things with the same lifetime as this read-in compilation
     unit, including partial DIEs.  */
  struct obstack comp_unit_obstack;
a417 57
/* When we construct a partial symbol table entry we only
   need this much information. */
struct partial_die_info
  {
    /* Offset of this DIE.  */
    unsigned int offset;

    /* DWARF-2 tag for this DIE.  */
    ENUM_BITFIELD(dwarf_tag) tag : 16;

    /* Language code associated with this DIE.  This is only used
       for the compilation unit DIE.  */
    unsigned int language : 8;

    /* Assorted flags describing the data found in this DIE.  */
    unsigned int has_children : 1;
    unsigned int is_external : 1;
    unsigned int is_declaration : 1;
    unsigned int has_type : 1;
    unsigned int has_specification : 1;
    unsigned int has_pc_info : 1;

    /* Flag set if the SCOPE field of this structure has been
       computed.  */
    unsigned int scope_set : 1;

    /* The name of this DIE.  Normally the value of DW_AT_name, but
       sometimes DW_TAG_MIPS_linkage_name or a string computed in some
       other fashion.  */
    char *name;

    /* The scope to prepend to our children.  This is generally
       allocated on the comp_unit_obstack, so will disappear
       when this compilation unit leaves the cache.  */
    char *scope;

    /* The location description associated with this DIE, if any.  */
    struct dwarf_block *locdesc;

    /* If HAS_PC_INFO, the PC range associated with this DIE.  */
    CORE_ADDR lowpc;
    CORE_ADDR highpc;

    /* Pointer into the info_buffer pointing at the target of
       DW_AT_sibling, if any.  */
    char *sibling;

    /* If HAS_SPECIFICATION, the offset of the DIE referred to by
       DW_AT_specification (or DW_AT_abstract_origin or
       DW_AT_extension).  */
    unsigned int spec_offset;

    /* Pointers to this DIE's parent, first child, and next sibling,
       if any.  */
    struct partial_die_info *die_parent, *die_child, *die_sibling;
  };

d496 29
d529 3
d961 2
d1023 6
a1028 1
static void *hashtab_obstack_allocate (void *data, size_t size, size_t count);
d1030 6
a1035 1
static void dummy_obstack_deallocate (void *object, void *data);
d1037 8
a1044 1
static hashval_t partial_die_hash (const void *item);
d1046 6
a1051 1
static int partial_die_eq (const void *item_lhs, const void *item_rhs);
d1053 2
a1054 3
/* Allocation function for the libiberty splay tree which uses an obstack.  */
static void *
splay_tree_obstack_allocate (int size, void *data)
d1056 3
a1058 1
  return obstack_alloc ((struct obstack *) data, size);
d1331 31
d1364 1
a1364 1
  back_to = make_cleanup (free_cached_comp_units, NULL);
d1477 1
a1477 1
	  obstack_init (&cu.comp_unit_obstack);
d1483 3
a1485 3
				    &cu.comp_unit_obstack,
				    hashtab_obstack_allocate,
				    dummy_obstack_deallocate);
d1577 1
a1577 1
      obstack_init (&cu->comp_unit_obstack);
d1583 3
a1585 3
				&cu->comp_unit_obstack,
				hashtab_obstack_allocate,
				dummy_obstack_deallocate);
d1608 1
a1608 1
					   dummy_obstack_deallocate,
d1753 1
a1753 1
   comp_unit_obstack, or a copy of the already allocated PDI->NAME
d1790 1
a1790 1
	parent->scope = obconcat (&cu->comp_unit_obstack, grandparent_scope,
d2082 1
a2082 1
				    &cu->comp_unit_obstack);
d2432 4
a2435 1
  struct cleanup *back_to = make_cleanup (null_cleanup, NULL);
d2512 1
a2512 1
  obstack_init (&cu->comp_unit_obstack);
d2828 1
a2828 1
    obstack_alloc (&cu->comp_unit_obstack, sizeof (struct function_range));
d5081 1
a5081 1
  part_die = obstack_alloc (&cu->comp_unit_obstack,
d5093 1
a5093 1
	      obstack_free (&cu->comp_unit_obstack, part_die);
d5224 1
a5224 1
      part_die = obstack_alloc (&cu->comp_unit_obstack,
d8657 8
d8671 1
a8671 1
    obstack_alloc (&cu->comp_unit_obstack, sizeof (struct dwarf_block));
d9200 1
a9200 1
  obstack_free (&cu->comp_unit_obstack, NULL);
d9270 1
a9270 1
      obstack_free (&cu->comp_unit_obstack, NULL);
d9343 2
a9344 2
					hashtab_obstack_allocate,
					dummy_obstack_deallocate);
d9397 2
a9398 2
				       dummy_obstack_deallocate,
				       &cu->comp_unit_obstack);
a9441 43
}

/* Allocation function for the libiberty hash table which uses an
   obstack.  */

static void *
hashtab_obstack_allocate (void *data, size_t size, size_t count)
{
  unsigned int total = size * count;
  void *ptr = obstack_alloc ((struct obstack *) data, total);
  memset (ptr, 0, total);
  return ptr;
}

/* Trivial deallocation function for the libiberty splay tree and hash
   table - don't deallocate anything.  Rely on later deletion of the
   obstack.  */

static void
dummy_obstack_deallocate (void *object, void *data)
{
  return;
}

/* Trivial hash function for partial_die_info: the hash value of a DIE
   is its offset in .debug_info for this objfile.  */

static hashval_t
partial_die_hash (const void *item)
{
  const struct partial_die_info *part_die = item;
  return part_die->offset;
}

/* Trivial comparison function for partial_die_info structures: two DIEs
   are equal if they have the same offset.  */

static int
partial_die_eq (const void *item_lhs, const void *item_rhs)
{
  const struct partial_die_info *part_die_lhs = item_lhs;
  const struct partial_die_info *part_die_rhs = item_rhs;
  return part_die_lhs->offset == part_die_rhs->offset;
@


1.135.2.41
log
@	* dwarf2read.c (add_partial_structure): Remove.
	(load_partial_die): Rename to read_partial_die.
	(skip_one_die): Move prototype.
	(clear_per_cu_pointer): Rename to free_stack_comp_unit.  Always
	free the obstack.
	(dwarf2_build_psymtabs_hard): Update comments.  Move
	cleanup.  Initialize the comp_unit_obstack.  Remove hash table
	creation.
	(load_comp_unit): Initialize the comp_unit_obstack.  Remove
	hash table creation.
	(create_comp_unit_tree): Update comments.  Read less data.
	(scan_partial_symbols): Update comment.  Rename pdi_p to pdi.
	(add_partial_enumeration): Likewise.
	(add_partial_symbol): Remove psym2.
	(add_partial_namespace): Don't set the name here.
	(guess_structure_name): Make static.
	(locate_pdi_sibling): Rearrange.
	(determine_class_name): Update comment.
	(load_partial_dies): Create the hash table here.  Update comments.
	Don't use obstack_free.
	(fixup_partial_die): Add comment.  Fix typo.
	(dwarf_alloc_block): Readd comment.
@
text
@d718 3
d747 1
a747 1
static char *read_partial_die (struct partial_die_info *,
a1009 3
static char *skip_one_die (char *info_ptr, struct abbrev_info *abbrev,
			   struct dwarf2_cu *cu);

d1018 1
a1018 1
static void free_stack_comp_unit (void *);
d1047 3
d1341 1
a1341 1
     read_comp_unit_head and read_partial_die) can really know whether
a1364 4
      obstack_init (&cu.comp_unit_obstack);

      back_to_inner = make_cleanup (free_stack_comp_unit, &cu);

d1381 1
a1381 1
      make_cleanup (dwarf2_free_abbrev_table, &cu);
d1388 1
a1388 1
      info_ptr = read_partial_die (&comp_unit_die, abbrev, bytes_read,
d1429 1
a1429 1
	     be cleaned up in free_stack_comp_unit when we finish with
d1438 2
d1450 10
d1468 1
a1468 1

d1491 1
a1491 1
      info_ptr = beg_of_comp_unit + cu.header.length
a1517 2
  obstack_init (&cu->comp_unit_obstack);

d1534 1
a1534 1
  info_ptr = read_partial_die (&comp_unit_die, abbrev, bytes_read,
d1547 15
a1561 1
    load_partial_dies (abfd, info_ptr, 0, cu);
a1590 1
      int bytes_read;
d1592 2
a1593 1
      offset = info_ptr - dwarf2_per_objfile->info_buffer;
d1595 4
a1598 4
      /* Read just enough information to find out where the next
	 compilation unit is.  */
      cu_header.length = read_initial_length (objfile->obfd, info_ptr,
					      &cu_header, &bytes_read);
d1605 1
a1605 1
      this_cu->length = cu_header.length + cu_header.initial_length_size;
d1608 2
a1609 1
      info_ptr = info_ptr + this_cu->length;
d1615 6
a1620 3
/* Process all loaded DIEs for compilation unit CU, starting at FIRST_DIE.
   Also set *LOWPC and *HIGHPC to the lowest and highest PC values found
   in CU.  */
d1628 1
a1628 1
  struct partial_die_info *pdi;
d1634 1
a1634 1
  pdi = first_die;
d1636 1
a1636 1
  while (pdi != NULL)
d1638 1
a1638 1
      fixup_partial_die (pdi, cu);
d1644 2
a1645 2
      if (pdi->name != NULL || pdi->tag == DW_TAG_namespace
	  || pdi->tag == DW_TAG_enumeration_type)
d1647 1
a1647 1
	  switch (pdi->tag)
d1650 1
a1650 1
	      if (pdi->has_pc_info)
d1652 1
a1652 1
		  if (pdi->lowpc < *lowpc)
d1654 1
a1654 1
		      *lowpc = pdi->lowpc;
d1656 1
a1656 1
		  if (pdi->highpc > *highpc)
d1658 1
a1658 1
		      *highpc = pdi->highpc;
d1660 1
a1660 1
		  if (!pdi->is_declaration)
d1662 1
a1662 1
		      add_partial_symbol (pdi, cu);
d1669 1
a1669 1
	      if (!pdi->is_declaration)
d1671 1
a1671 1
		  add_partial_symbol (pdi, cu);
d1676 1
a1676 1
	      if (!pdi->is_declaration)
d1678 1
a1678 1
		  add_partial_symbol (pdi, cu);
d1682 2
a1683 2
	      if (!pdi->is_declaration)
		add_partial_enumeration (pdi, cu);
d1689 1
a1689 1
	      add_partial_symbol (pdi, cu);
d1692 1
a1692 1
	      add_partial_namespace (pdi, lowpc, highpc, cu);
d1701 1
a1701 1
      pdi = pdi->die_sibling;
d1779 1
a1779 1

d1806 1
a1806 1
  const struct partial_symbol *psym = NULL;
d1891 4
a1894 4
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   VAR_DOMAIN, LOC_TYPEDEF,
			   &objfile->static_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
d1897 4
a1900 4
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   VAR_DOMAIN, LOC_TYPEDEF,
			   &objfile->global_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
d1912 6
a1917 6
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   STRUCT_DOMAIN, LOC_TYPEDEF,
			   cu->language == language_cplus
			   ? &objfile->global_psymbols
			   : &objfile->static_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
d1929 6
a1934 6
      add_psymbol_to_list (actual_name, strlen (actual_name),
			   VAR_DOMAIN, LOC_CONST,
			   cu->language == language_cplus
			   ? &objfile->global_psymbols
			   : &objfile->static_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
d1946 1
a1946 2
  /* FIXME drow/2004-02-22: Why don't we do this for classes, i.e. the
     cases which do not set PSYM above?  */
d1956 6
a1961 1
    xfree (actual_name);
d1997 4
a2000 1
  /* Add a symbol for the namespace.  */
d2014 1
a2014 1
static void
d2066 14
d2088 1
a2088 1
  struct partial_die_info *pdi;
d2092 3
a2094 3

  pdi = enum_pdi->die_child;
  while (pdi)
d2096 1
a2096 1
      if (pdi->tag != DW_TAG_enumerator || pdi->name == NULL)
d2099 2
a2100 2
	add_partial_symbol (pdi, cu);
      pdi = pdi->die_sibling;
d2258 5
a2267 5
  /* Are there any children to deal with?  */

  if (!orig_pdi->has_children)
    return info_ptr;

d3936 1
a3936 1
     guess_structure_name.  */
d5009 1
a5009 1
{
a5050 9
  cu->partial_dies
    = htab_create_alloc_ex (cu->header.length / 12,
			    partial_die_hash,
			    partial_die_eq,
			    NULL,
			    &cu->comp_unit_obstack,
			    hashtab_obstack_allocate,
			    dummy_obstack_deallocate);

a5057 1
      /* A NULL abbrev means the end of a series of children.  */
d5062 2
a5063 6
	      /* PART_DIE was probably the last thing allocated on the
		 comp_unit_obstack, so we could call obstack_free
		 here.  We don't do that because the waste is small,
		 and will be cleaned up when we're done with this
		 compilation unit.  This way, we're also more robust
		 against other users of the comp_unit_obstack.  */
d5079 1
d5085 2
a5086 1
      info_ptr = read_partial_die (part_die, abbrev, bytes_read,
d5097 1
a5097 1
	 add_partial_symbol will handle these DIEs if we chain
d5178 1
a5178 1
	 internal errors in find_partial_die.  */
d5187 1
d5190 1
d5224 1
a5224 1
read_partial_die (struct partial_die_info *part_die,
a5335 1

a5352 1

a5380 3
/* Adjust PART_DIE before generating a symbol for it.  This function
   may set the is_external flag or change the DIE's name.  */

d5416 1
a5416 1
      || part_die->tag == DW_TAG_class_type
d5452 1
a5452 1
	     abbrev_number,
a8626 2
/* memory allocation interface */

d9226 1
a9226 1
free_stack_comp_unit (void *data)
a9229 3
  obstack_free (&cu->comp_unit_obstack, NULL);
  cu->partial_dies = NULL;

d9232 3
a9239 2
      /* If we had a per-cu pointer, then we may have other compilation
	 units loaded, so age them now.  */
@


1.135.2.42
log
@./
	* Makefile.in (dwarf2read.o): Update dependencies.
	* dwarf2read.c: Include "command.h" and "gdbcmd.h".
	(MAX_CACHE_AGE): Remove.
	(dwarf2_max_cache_age): New variable.
	(free_comp_units_worker): Update.
	(set_dwarf2_cmdlist, show_dwarf2_cmdlist, set_dwarf2_cmd)
	(show_dwarf2_cmd): New.
	(_initialize_dwarf2_read): Provide "maint set dwarf2 max-cache-age"
	and "maint show dwarf2 max-cache-age".
	* gdbcmd.h (maintenance_set_cmdlist, maintenance_show_cmdlist): New
	externs.
	* maint.c (maintenance_set_cmdlist, maintenance_show_cmdlist): Make
	global.
doc/
	* gdb.texinfo (Maintenance Commands): Document "maint set dwarf2
	max-cache-age" and "maint show dwarf2 max-cache-age".
@
text
@a48 2
#include "command.h"
#include "gdbcmd.h"
d69 7
a648 7
/* Loaded secondary compilation units are kept in memory until they
   have not been referenced for the processing of this many
   compilation units.  Set this to zero to disable caching.  Cache
   sizes of up to at least twenty will improve startup time for
   typical inter-CU-reference binaries, at an obvious memory cost.  */
static unsigned int dwarf2_max_cache_age = 5;

d9156 1
a9156 1
	  if (per_cu->cu->last_used <= dwarf2_max_cache_age)
a9419 15
static struct cmd_list_element *set_dwarf2_cmdlist;
static struct cmd_list_element *show_dwarf2_cmdlist;

static void
set_dwarf2_cmd (char *args, int from_tty)
{
  help_list (set_dwarf2_cmdlist, "maintenance set dwarf2 ", -1, gdb_stdout);
}

static void
show_dwarf2_cmd (char *args, int from_tty)
{ 
  cmd_show_list (show_dwarf2_cmdlist, from_tty, "");
}

a9425 26

  add_prefix_cmd ("dwarf2", class_maintenance, set_dwarf2_cmd,
		  "Set DWARF 2 specific variables.\n"
		  "Configure DWARF 2 variables such as the cache size",
                  &set_dwarf2_cmdlist, "maintenance set dwarf2 ",
                  0/*allow-unknown*/, &maintenance_set_cmdlist);

  add_prefix_cmd ("dwarf2", class_maintenance, show_dwarf2_cmd,
		  "Show DWARF 2 specific variables\n"
		  "Show DWARF 2 variables such as the cache size",
                  &show_dwarf2_cmdlist, "maintenance show dwarf2 ",
                  0/*allow-unknown*/, &maintenance_show_cmdlist);

  add_setshow_uinteger_cmd ("max-cache-age", class_obscure,
                            &dwarf2_max_cache_age,
			    "Set an upper bound on the age of cached "
			    "compilation units.\n"
			    "A higher limit means that cached "
			    "compilation units will be stored\n"
			    "in memory longer, and more total memory will "
			    "be used.  Zero disables\n"
			    "caching, which can slow down startup.",
			    "Show the upper bound on the age of cached "
			    "dwarf2 compilation units.",
                            NULL, NULL, &set_dwarf2_cmdlist,
                            &show_dwarf2_cmdlist);
@


1.135.2.43
log
@	* dwarf2read.c (free_comp_units_worker): Remove incorrect aging.
	(_initialize_dwarf2_read): Use var_zinteger.
@
text
@d9180 4
a9183 1
	last_chain = &per_cu->cu->read_in_chain;
d9456 13
a9468 13
  add_setshow_cmd ("max-cache-age", class_obscure, var_zinteger,
		   &dwarf2_max_cache_age,
		   "Set an upper bound on the age of cached "
		   "compilation units.\n"
		   "A higher limit means that cached "
		   "compilation units will be stored\n"
		   "in memory longer, and more total memory will "
		   "be used.  Zero disables\n"
		   "caching, which can slow down startup.",
		   "Show the upper bound on the age of cached "
		   "dwarf2 compilation units.",
		   NULL, NULL, &set_dwarf2_cmdlist,
		   &show_dwarf2_cmdlist);
@


1.135.2.44
log
@	* dwarf2read.c (struct dwarf2_per_objfile): Replace cu_tree
	with all_comp_units and n_comp_units.
	(dwarf2_find_containing_comp_unit): Take an objfile argument
	instead of a dwarf2_cu.  Search all_comp_units.
	(dwarf2_find_comp_unit): New function.
	(create_all_comp_units): Renamed from create_comp_unit_tree.
	Create a list instead of a splay tree.
	(dwarf2_build_psymtabs_hard): Call create_comp_unit_tree
	and dwarf2_find_comp_unit.
	(psymtab_to_symtab_1): Check all_comp_units.  Use
	dwarf2_find_comp_unit.
	(find_partial_die, read_full_die, follow_die_ref): Update calls
	to dwarf2_find_containing_comp_unit.
@
text
@d173 4
a176 7
  /* A list of all the compilation units.  This will be set if and
     only if we have encountered a compilation unit with inter-CU
     references.  */
  struct dwarf2_per_cu_data **all_comp_units;

  /* The number of compilation units in ALL_COMP_UNITS.  */
  int n_comp_units;
d1013 1
a1013 4
  (unsigned long offset, struct objfile *objfile);

static struct dwarf2_per_cu_data *dwarf2_find_comp_unit
  (unsigned long offset, struct objfile *objfile);
d1034 1
a1034 1
static void create_all_comp_units (struct objfile *);
d1330 1
d1386 2
a1387 2
      if (cu.has_form_ref_addr && dwarf2_per_objfile->all_comp_units == NULL)
	create_all_comp_units (objfile);
d1413 1
a1413 1
      if (dwarf2_per_objfile->all_comp_units != NULL)
d1415 1
d1418 3
a1420 1
	  per_cu = dwarf2_find_comp_unit (cu.header.offset, objfile);
d1545 1
a1545 1
/* Create a list of all compilation units in OBJFILE.  We do this only
d1548 1
a1548 1
   So there's no point in building this list incrementally.  */
d1550 2
a1551 2
static void
create_all_comp_units (struct objfile *objfile)
d1553 1
a1553 3
  int n_allocated;
  int n_comp_units;
  struct dwarf2_per_cu_data **all_comp_units;
d1556 8
a1563 5
  n_comp_units = 0;
  n_allocated = 10;
  all_comp_units = xmalloc (n_allocated
			    * sizeof (struct dwarf2_per_cu_data *));
  
d1585 1
a1585 9

      if (n_comp_units == n_allocated)
	{
	  n_allocated *= 2;
	  all_comp_units = xrealloc (all_comp_units,
				     n_allocated
				     * sizeof (struct dwarf2_per_cu_data *));
	}
      all_comp_units[n_comp_units++] = this_cu;
d1590 1
a1590 7
  dwarf2_per_objfile->all_comp_units
    = obstack_alloc (&objfile->objfile_obstack,
		     n_comp_units * sizeof (struct dwarf2_per_cu_data *));
  memcpy (dwarf2_per_objfile->all_comp_units, all_comp_units,
	  n_comp_units * sizeof (struct dwarf2_per_cu_data *));
  xfree (all_comp_units);
  dwarf2_per_objfile->n_comp_units = n_comp_units;
d2361 1
a2361 1
  if (dwarf2_per_objfile->all_comp_units == NULL)
d2370 1
d2375 3
a2377 1
      per_cu = dwarf2_find_comp_unit (offset, pst->objfile);
d5332 1
a5332 1
  per_cu = dwarf2_find_containing_comp_unit (offset, cu->objfile);
d5449 1
a5449 1
						     cu->objfile);
d8331 1
a8331 1
						 cu->objfile);
d9074 5
a9078 1
   DIE at OFFSET.  Returns NULL on failure.  */
d9082 1
a9082 1
				  struct objfile *objfile)
d9084 1
d9086 2
a9087 1
  int low, high;
d9089 5
a9093 29
  gdb_assert (dwarf2_per_objfile->all_comp_units != NULL);

  low = 0;
  high = dwarf2_per_objfile->n_comp_units - 1;
  while (high > low)
    {
      int mid = low + (high - low) / 2;
      if (dwarf2_per_objfile->all_comp_units[mid]->offset >= offset)
	high = mid;
      else
	low = mid + 1;
    }
  gdb_assert (low == high);
  if (dwarf2_per_objfile->all_comp_units[low]->offset > offset)
    {
      gdb_assert (low > 0);
      gdb_assert (dwarf2_per_objfile->all_comp_units[low-1]->offset <= offset);
      return dwarf2_per_objfile->all_comp_units[low-1];
    }
  else
    {
      this_cu = dwarf2_per_objfile->all_comp_units[low];
      if (low == dwarf2_per_objfile->n_comp_units - 1
	  && offset >= this_cu->offset + this_cu->length)
	error ("invalid dwarf2 offset %ld", offset);
      gdb_assert (offset < this_cu->offset + this_cu->length);
      return this_cu;
    }
}
d9095 3
a9097 7
static struct dwarf2_per_cu_data *
dwarf2_find_comp_unit (unsigned long offset, struct objfile *objfile)
{
  struct dwarf2_per_cu_data *this_cu;
  this_cu = dwarf2_find_containing_comp_unit (offset, objfile);
  if (this_cu->offset != offset)
    error ("no compilation unit with offset %ld\n", offset);
@


1.135.2.45
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d47 1
a50 1
#include "splay-tree.h"
a284 2
  const char *producer;

a412 1
    int included_p; /* Non-zero if referenced by the Line Number Program.  */
a439 1
    unsigned int has_stmt_list : 1;
a449 1
    char *dirname;
a471 3
    /* If HAS_STMT_LIST, the offset of the Line Number Information data.  */
    unsigned int line_offset;

a707 7
static void dwarf2_create_include_psymtab (char *, struct partial_symtab *,
                                           struct objfile *);

static void dwarf2_build_include_psymtabs (struct dwarf2_cu *,
                                           struct partial_die_info *,
                                           struct partial_symtab *);

a810 3
static int dwarf2_flag_true_p (struct die_info *die, unsigned name,
                               struct dwarf2_cu *cu);

a818 3
static void add_file_name (struct line_header *, char *, unsigned int,
                           unsigned int, unsigned int);

d824 1
a824 1
				struct dwarf2_cu *, struct partial_symtab *);
a909 3
static enum dwarf_array_dim_ordering read_array_order (struct die_info *, 
						       struct dwarf2_cu *);

a1014 10
static void free_stack_comp_unit (void *);

static void *hashtab_obstack_allocate (void *data, size_t size, size_t count);

static void dummy_obstack_deallocate (void *object, void *data);

static hashval_t partial_die_hash (const void *item);

static int partial_die_eq (const void *item_lhs, const void *item_rhs);

d1026 2
d1055 8
d1107 1
a1107 1
      dwarf2_per_objfile->info_size = bfd_get_section_size (sectp);
d1112 1
a1112 1
      dwarf2_per_objfile->abbrev_size = bfd_get_section_size (sectp);
d1117 1
a1117 1
      dwarf2_per_objfile->line_size = bfd_get_section_size (sectp);
d1122 1
a1122 1
      dwarf2_per_objfile->pubnames_size = bfd_get_section_size (sectp);
d1127 1
a1127 1
      dwarf2_per_objfile->aranges_size = bfd_get_section_size (sectp);
d1132 1
a1132 1
      dwarf2_per_objfile->loc_size = bfd_get_section_size (sectp);
d1137 1
a1137 1
      dwarf2_per_objfile->macinfo_size = bfd_get_section_size (sectp);
d1142 1
a1142 1
      dwarf2_per_objfile->str_size = bfd_get_section_size (sectp);
d1147 1
a1147 1
      dwarf2_per_objfile->frame_size = bfd_get_section_size (sectp);
d1155 1
a1155 1
          dwarf2_per_objfile->eh_frame_size = bfd_get_section_size (sectp);
d1161 1
a1161 1
      dwarf2_per_objfile->ranges_size = bfd_get_section_size (sectp);
a1320 62
/* Allocate a new partial symtab for file named NAME and mark this new
   partial symtab as being an include of PST.  */

static void
dwarf2_create_include_psymtab (char *name, struct partial_symtab *pst,
                               struct objfile *objfile)
{
  struct partial_symtab *subpst = allocate_psymtab (name, objfile);

  subpst->section_offsets = pst->section_offsets;
  subpst->textlow = 0;
  subpst->texthigh = 0;

  subpst->dependencies = (struct partial_symtab **)
    obstack_alloc (&objfile->objfile_obstack,
                   sizeof (struct partial_symtab *));
  subpst->dependencies[0] = pst;
  subpst->number_of_dependencies = 1;

  subpst->globals_offset = 0;
  subpst->n_global_syms = 0;
  subpst->statics_offset = 0;
  subpst->n_static_syms = 0;
  subpst->symtab = NULL;
  subpst->read_symtab = pst->read_symtab;
  subpst->readin = 0;

  /* No private part is necessary for include psymtabs.  This property
     can be used to differentiate between such include psymtabs and
     the regular ones.  If it ever happens that a regular psymtab can
     legitimally have a NULL private part, then we'll have to add a
     dedicated field for that in the dwarf2_pinfo structure.  */
  subpst->read_symtab_private = NULL;
}

/* Read the Line Number Program data and extract the list of files
   included by the source file represented by PST.  Build an include
   partial symtab for each of these included files.
   
   This procedure assumes that there *is* a Line Number Program in
   the given CU.  Callers should check that PDI->HAS_STMT_LIST is set
   before calling this procedure.  */

static void
dwarf2_build_include_psymtabs (struct dwarf2_cu *cu,
                               struct partial_die_info *pdi,
                               struct partial_symtab *pst)
{
  struct objfile *objfile = cu->objfile;
  bfd *abfd = objfile->obfd;
  struct line_header *lh;

  lh = dwarf_decode_line_header (pdi->line_offset, abfd, cu);
  if (lh == NULL)
    return;  /* No linetable, so no includes.  */

  dwarf_decode_lines (lh, NULL, abfd, cu, pst);

  free_line_header (lh);
}


d1345 1
a1345 1
     read_comp_unit_head and load_partial_die) can really know whether
a1408 3
	  if (comp_unit_die.dirname)
        pst->dirname = xstrdup (comp_unit_die.dirname);

a1483 7
      if (comp_unit_die.has_stmt_list)
        {
          /* Get the list of files included in the current compilation unit,
             and build a psymtab for each of them.  */
          dwarf2_build_include_psymtabs (&cu, &comp_unit_die, pst);
        }

d2032 1
a2032 2
		= language_class_name_from_physname (cu->language_defn,
						     child_pdi->name);
d2374 1
a2374 29
  struct cleanup *back_to;
  int i;

  for (i = 0; i < pst->number_of_dependencies; i++)
    if (!pst->dependencies[i]->readin)
      {
        /* Inform about additional files that need to be read in.  */
        if (info_verbose)
          {
            fputs_filtered (" ", gdb_stdout);
            wrap_here ("");
            fputs_filtered ("and ", gdb_stdout);
            wrap_here ("");
            printf_filtered ("%s...", pst->dependencies[i]->filename);
            wrap_here ("");     /* Flush output */
            gdb_flush (gdb_stdout);
          }
        psymtab_to_symtab_1 (pst->dependencies[i]);
      }

  if (pst->read_symtab_private == NULL)
    {
      /* It's an include file, no symbols to read for it.
         Everything is in the parent symtab.  */
      pst->readin = 1;
      return;
    }

  back_to = make_cleanup (null_cleanup, NULL);
a2417 1
  CORE_ADDR baseaddr;
d2692 2
a2693 2
  attr = dwarf2_attr (die, DW_AT_language, cu);
  if (attr)
d2695 2
a2696 1
      set_cu_language (DW_UNSND (attr), cu);
a2698 4
  attr = dwarf2_attr (die, DW_AT_producer, cu);
  if (attr) 
    cu->producer = DW_STRING (attr);
  
d2739 1
a2739 1
          dwarf_decode_lines (line_header, comp_dir, abfd, cu, NULL);
d2843 7
a3601 17

/* Returns non-zero if NAME is the name of a vtable member in CU's
   language, zero otherwise.  */
static int
is_vtable_name (const char *name, struct dwarf2_cu *cu)
{
  static const char vptr[] = "_vptr";

  /* C++ and some implementations of Java use this name.  */
  if (strncmp (name, vptr, sizeof (vptr) - 1) == 0
      && is_cplus_marker (name[sizeof (vptr) - 1]))
    return 1;

  return 0;
}


a3680 3
  if (die_is_declaration (die, cu))
    TYPE_FLAGS (type) |= TYPE_FLAG_STUB;

d3743 2
d3754 4
a3757 1
                      if (is_vtable_name (fieldname, cu))
d3780 5
d3913 1
a3913 3
	      new_prefix 
		= language_class_name_from_physname (cu->language_defn,
						     dwarf2_linkage_name
a4071 1

d4073 2
a4074 12

  if (read_array_order (die, cu) == DW_ORD_col_major)
    {
      int i = 0;
      while (i < ndim)
	type = create_array_type (NULL, type, range_types[i++]);
    }
  else
    {
      while (ndim-- > 0)
	type = create_array_type (NULL, type, range_types[ndim]);
    }
a4091 35
static enum dwarf_array_dim_ordering
read_array_order (struct die_info *die, struct dwarf2_cu *cu) 
{
  struct attribute *attr;

  attr = dwarf2_attr (die, DW_AT_ordering, cu);

  if (attr) return DW_SND (attr);

  /*
    GNU F77 is a special case, as at 08/2004 array type info is the
    opposite order to the dwarf2 specification, but data is still 
    laid out as per normal fortran.

    FIXME: dsl/2004-8-20: If G77 is ever fixed, this will also need 
    version checking.
  */

  if (cu->language == language_fortran &&
      cu->producer && strstr (cu->producer, "GNU F77"))
    {
      return DW_ORD_row_major;
    }

  switch (cu->language_defn->la_array_ordering) 
    {
    case array_column_major:
      return DW_ORD_col_major;
    case array_row_major:
    default:
      return DW_ORD_row_major;
    };
}


d4810 1
a4810 1
  bfd_size_type size = bfd_get_section_size (sectp);
a5235 4
	case DW_AT_comp_dir:
	  if (part_die->dirname == NULL)
	    part_die->dirname = DW_STRING (&attr);
	  break;
a5289 4
        case DW_AT_stmt_list:
          part_die->has_stmt_list = 1;
          part_die->line_offset = DW_UNSND (&attr);
          break;
a6040 12
/* Return non-zero iff the attribute NAME is defined for the given DIE,
   and holds a non-zero value.  This function should only be used for
   DW_FORM_flag attributes.  */

static int
dwarf2_flag_true_p (struct die_info *die, unsigned name, struct dwarf2_cu *cu)
{
  struct attribute *attr = dwarf2_attr (die, name, cu);

  return (attr && DW_UNSND (attr));
}

d6045 1
a6045 9

  /* A DIE is a declaration if it has a DW_AT_declaration attribute
     which value is non-zero.  However, we have to be careful with
     DIEs having a DW_AT_specification attribute, because dwarf2_attr()
     (via dwarf2_flag_true_p) follows this attribute.  So we may
     end up accidently finding a declaration attribute that belongs
     to a different DIE referenced by the specification attribute,
     even though the given DIE does not have a declaration attribute.  */
  return (dwarf2_flag_true_p (die, DW_AT_declaration, cu)
a6138 1
  fe->included_p = 0;
d6296 3
a6298 17
/* Decode the Line Number Program (LNP) for the given line_header
   structure and CU.  The actual information extracted and the type
   of structures created from the LNP depends on the value of PST.

   1. If PST is NULL, then this procedure uses the data from the program
      to create all necessary symbol tables, and their linetables.
      The compilation directory of the file is passed in COMP_DIR,
      and must not be NULL.
   
   2. If PST is not NULL, this procedure reads the program to determine
      the list of files included by the unit represented by PST, and
      builds all the associated partial symbol tables.  In this case,
      the value of COMP_DIR is ignored, and can thus be NULL (the COMP_DIR
      is not used to compute the full name of the symtab, and therefore
      omitting it when building the partial symtab does not introduce
      the potential for inconsistency - a partial symtab and its associated
      symbtab having a different fullname -).  */
d6302 1
a6302 1
		    struct dwarf2_cu *cu, struct partial_symtab *pst)
a6309 1
  const int decode_for_pst_p = (pst != NULL);
d6328 2
a6329 1
      if (!decode_for_pst_p && lh->num_file_names >= file)
a6330 1
          /* Start a subfile for the current file of the state machine.  */
d6355 3
a6357 7
              lh->file_names[file - 1].included_p = 1;
              if (!decode_for_pst_p)
                {
	          /* append row to matrix using current values */
	          record_line (current_subfile, line, 
	                       check_cu_functions (address, cu));
                }
d6363 1
a6363 2
	      read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
d6370 1
a6370 3
                  lh->file_names[file - 1].included_p = 1;
                  if (!decode_for_pst_p)
		    record_line (current_subfile, 0, address);
d6403 2
a6404 4
              lh->file_names[file - 1].included_p = 1;
              if (!decode_for_pst_p)
	        record_line (current_subfile, line, 
	                     check_cu_functions (address, cu));
d6430 1
a6430 2
                if (!decode_for_pst_p)
                  dwarf2_start_subfile (fe->name, dir);
a6467 16

  if (decode_for_pst_p)
    {
      int file_index;

      /* Now that we're done scanning the Line Header Program, we can
         create the psymtab of each included file.  */
      for (file_index = 0; file_index < lh->num_file_names; file_index++)
        if (lh->file_names[file_index].included_p == 1)
          {
            char *include_name = lh->file_names [file_index].name;
    
            if (strcmp (include_name, pst->filename) != 0)
              dwarf2_create_include_psymtab (include_name, pst, objfile);
          }
    }
d9487 13
a9499 15
  add_setshow_zinteger_cmd ("max-cache-age", class_obscure,
			    &dwarf2_max_cache_age,
			    "Set the upper bound on the age of cached "
			    "dwarf2 compilation units.",
			    "Show the upper bound on the age of cached "
			    "dwarf2 compilation units.",
			    "A higher limit means that cached "
			    "compilation units will be stored\n"
			    "in memory longer, and more total memory will "
			    "be used.  Zero disables\n"
			    "caching, which can slow down startup.",
			    "The upper bound on the age of cached "
			    "dwarf2 compilation units is %d.",
			    NULL, NULL, &set_dwarf2_cmdlist,
			    &show_dwarf2_cmdlist);
@


1.135.2.46
log
@Merge from mainline.
@
text
@a370 3
  /* Set iff currently read in.  */
  struct dwarf2_cu *cu;

d374 2
a375 6
  /* If full symbols for this CU have been read in, then this field
     holds a map of DIE offsets to types.  It isn't always possible
     to reconstruct this information later, so we have to preserve
     it.  */

  htab_t type_hash;
d660 1
a660 1
static int dwarf2_max_cache_age = 5;
d874 1
a874 2
static char *typename_concat (struct obstack *, const char *prefix, const char *suffix,
			      struct dwarf2_cu *);
d1062 1
a1062 1
static void age_cached_comp_units (void);
d1469 4
d1495 2
a1496 2
      if (comp_unit_die.dirname)
	pst->dirname = xstrdup (comp_unit_die.dirname);
d1501 1
d1513 4
a1516 6
	  /* If this compilation unit was already read in, free the
	     cached copy in order to read it in again.  This is
	     necessary because we skipped some symbols when we first
	     read in the compilation unit (see load_partial_dies).
	     This problem could be avoided, but the benefit is
	     unclear.  */
d1522 3
a1524 4
	  /* Note that this is a pointer to our stack frame, being
	     added to a global data structure.  It will be cleaned up
	     in free_stack_comp_unit when we finish with this
	     compilation unit.  */
d1612 1
a1612 1
  /* Complete the cu_header.  */
d1617 3
a1619 1
  /* Read the abbrevs for this compilation unit into a table.  */
d1623 1
a1623 1
  /* Read the compilation unit die.  */
d1628 1
a1628 1
  /* Set the language we're debugging.  */
a1630 1
  /* Link this compilation unit into the compilation unit tree.  */
d1794 1
a1794 2
   name is concatenated with "::" and the partial DIE's name.  For
   Java, the same thing occurs except that "." is used instead of "::".
d1849 2
a1850 2
	parent->scope = typename_concat (&cu->comp_unit_obstack, grandparent_scope,
					 parent->name, cu);
d1882 1
a1882 1
    return typename_concat (NULL, parent_scope, pdi->name, cu);
d2000 1
a2000 2
			   (cu->language == language_cplus
			    || cu->language == language_java)
d2005 1
a2005 2
      if (cu->language == language_cplus
          || cu->language == language_java)
d2007 1
a2007 1
	  /* For C++ and Java, these implicitly act as typedefs as well. */
d2017 1
a2017 2
			   (cu->language == language_cplus
			    || cu->language == language_java)
d2097 1
a2097 2
  if ((cu->language == language_cplus
       || cu->language == language_java)
d2527 1
a2527 1
      age_cached_comp_units ();
d2931 1
a2931 2
  if (cu->language == language_cplus
      || cu->language == language_java)
a3730 1
  static const char vtable[] = "vtable";
d3732 3
a3734 5
  /* Look for the C++ and Java forms of the vtable.  */
  if ((cu->language == language_java
       && strncmp (name, vtable, sizeof (vtable) - 1) == 0)
       || (strncmp (name, vptr, sizeof (vptr) - 1) == 0
       && is_cplus_marker (name[sizeof (vptr) - 1])))
d3778 1
a3778 2
      if (cu->language == language_cplus
	  || cu->language == language_java)
d3983 5
a3987 3
	  TYPE_TAG_NAME (type) = typename_concat (&objfile->objfile_obstack,
						  processing_current_prefix,
						  name, cu);
d4011 1
a4011 1
   a named C++ or Java compound type.  Return the name in question; the caller
d4059 2
a4060 3
      new_prefix = typename_concat (NULL, processing_current_prefix,
				    name ? name : "<<anonymous>>", 
				    cu);
a4327 1
  struct cleanup *back_to = make_cleanup (null_cleanup, 0);
d4340 8
a4347 2
      char *temp_name = typename_concat (NULL, previous_prefix, name, cu);
      make_cleanup (xfree, temp_name);
a4386 1
  do_cleanups (back_to);
d4637 1
a4637 1
  /* All functions in C++ and Java have prototypes.  */
d4640 1
a4640 2
      || cu->language == language_cplus
      || cu->language == language_java)
d4707 1
a4707 2
				    TYPE_FLAG_TARGET_STUB, name, objfile),
		    cu);
d5294 1
a5294 2
				 (cu->language == language_cplus
				  || cu->language == language_java)
d5533 1
a5533 7

  /* If this offset isn't pointing into a known compilation unit,
     the debug information is probably corrupted.  */
  if (per_cu == NULL)
    error ("Dwarf Error: could not find partial DIE containing "
	   "offset 0x%lx [in module %s]",
	   (long) offset, bfd_get_filename (cu->objfile->obfd));
d6975 1
a6975 2
	  if (cu->language == language_cplus
	      || cu->language == language_java)
d6992 1
a6992 1
	    /* NOTE: carlton/2003-11-10: C++ and Java class symbols shouldn't
d7003 1
a7003 2
			   && (cu->language == language_cplus
			       || cu->language == language_java)
d7009 3
a7011 5
	       defines a typedef for "foo".  A Java class declaration also
	       defines a typedef for the class.  Synthesize a typedef symbol
	       so that "ptype foo" works as expected.  */
	    if (cu->language == language_cplus
		|| cu->language == language_java)
d7031 4
a7034 3
	      SYMBOL_LINKAGE_NAME (sym) = typename_concat (&objfile->objfile_obstack,
							   processing_current_prefix,
							   name, cu);
d7050 4
a7053 3
	      SYMBOL_LINKAGE_NAME (sym) = typename_concat (&objfile->objfile_obstack,
							   processing_current_prefix,
							   name, cu);
d7067 1
a7067 2
			   && (cu->language == language_cplus
			       || cu->language == language_java)
d7375 1
a7375 2
  if (cu->language != language_cplus
      && cu->language != language_java)
d7399 1
a7399 1
	      char *retval = typename_concat (NULL, parent_prefix,
d7401 1
a7401 2
							      cu),
					      cu);
d7434 3
a7436 7
/* Return a newly-allocated string formed by concatenating PREFIX and
   SUFFIX with appropriate separator.  If PREFIX or SUFFIX is NULL or empty, then
   simply copy the SUFFIX or PREFIX, respectively.  If OBS is non-null,
   perform an obconcat, otherwise allocate storage for the result.  The CU argument
   is used to determine the language and hence, the appropriate separator.  */

#define MAX_SEP_LEN 2  /* sizeof ("::")  */
d7439 1
a7439 2
typename_concat (struct obstack *obs, const char *prefix, const char *suffix, 
		 struct dwarf2_cu *cu)
d7441 5
a7445 1
  char *sep;
d7447 3
a7449 6
  if (suffix == NULL || suffix[0] == '\0' || prefix == NULL || prefix[0] == '\0')
    sep = "";
  else if (cu->language == language_java)
    sep = ".";
  else
    sep = "::";
a7450 13
  if (obs == NULL)
    {
      char *retval = xmalloc (strlen (prefix) + MAX_SEP_LEN + strlen (suffix) + 1);
      retval[0] = '\0';
      
      if (prefix)
	{
	  strcpy (retval, prefix);
	  strcat (retval, sep);
	}
      if (suffix)
	strcat (retval, suffix);
      
a7452 5
  else
    {
      /* We have an obstack.  */
      return obconcat (obs, prefix, sep, suffix);
    }
d9345 1
a9345 4
  if (dwarf2_per_objfile->all_comp_units == NULL)
    error ("Dwarf Error: offset 0x%lx points outside this "
	   "compilation unit [in module %s]",
	   offset, bfd_get_filename (objfile->obfd));
d9405 2
a9406 2
   of compilation units, but we don't remove it from the read_in_chain;
   the caller is responsible for that.  */
d9424 46
d9494 1
a9494 1
      age_cached_comp_units ();
a9497 2
/* Free all cached compilation units.  */

d9501 1
a9501 15
  struct dwarf2_per_cu_data *per_cu, **last_chain;

  per_cu = dwarf2_per_objfile->read_in_chain;
  last_chain = &dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      struct dwarf2_per_cu_data *next_cu;

      next_cu = per_cu->cu->read_in_chain;

      free_one_comp_unit (per_cu->cu);
      *last_chain = next_cu;

      per_cu = next_cu;
    }
a9503 3
/* Increase the age counter on each cached compilation unit, and free
   any that are too old.  */

d9505 1
a9505 1
age_cached_comp_units (void)
d9507 1
a9507 30
  struct dwarf2_per_cu_data *per_cu, **last_chain;

  dwarf2_clear_marks (dwarf2_per_objfile->read_in_chain);
  per_cu = dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      per_cu->cu->last_used ++;
      if (per_cu->cu->last_used <= dwarf2_max_cache_age)
	dwarf2_mark (per_cu->cu);
      per_cu = per_cu->cu->read_in_chain;
    }

  per_cu = dwarf2_per_objfile->read_in_chain;
  last_chain = &dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      struct dwarf2_per_cu_data *next_cu;

      next_cu = per_cu->cu->read_in_chain;

      if (!per_cu->cu->mark)
	{
	  free_one_comp_unit (per_cu->cu);
	  *last_chain = next_cu;
	}
      else
	last_chain = &per_cu->cu->read_in_chain;

      per_cu = next_cu;
    }
a9509 2
/* Remove a single compilation unit from the cache.  */

d9513 1
a9513 21
  struct dwarf2_per_cu_data *per_cu, **last_chain;

  per_cu = dwarf2_per_objfile->read_in_chain;
  last_chain = &dwarf2_per_objfile->read_in_chain;
  while (per_cu != NULL)
    {
      struct dwarf2_per_cu_data *next_cu;

      next_cu = per_cu->cu->read_in_chain;

      if (per_cu->cu == target_cu)
	{
	  free_one_comp_unit (per_cu->cu);
	  *last_chain = next_cu;
	  break;
	}
      else
	last_chain = &per_cu->cu->read_in_chain;

      per_cu = next_cu;
    }
a9515 4
/* A pair of DIE offset and GDB type pointer.  We store these
   in a hash table separate from the DIEs, and preserve them
   when the DIEs are flushed out of cache.  */

a9521 2
/* Hash function for a dwarf2_offset_and_type.  */

a9528 2
/* Equality function for a dwarf2_offset_and_type.  */

d9537 3
a9539 3
/* Set the type associated with DIE to TYPE.  Save it in CU's hash
   table if necessary.  */

d9543 1
d9551 12
a9562 10
  if (cu->per_cu->type_hash == NULL)
    cu->per_cu->type_hash
      = htab_create_alloc_ex (cu->header.length / 24,
			      offset_and_type_hash,
			      offset_and_type_eq,
			      NULL,
			      &cu->objfile->objfile_obstack,
			      hashtab_obstack_allocate,
			      dummy_obstack_deallocate);

d9566 1
a9566 1
    htab_find_slot_with_hash (cu->per_cu->type_hash, &ofs, ofs.offset, INSERT);
a9570 3
/* Find the type for DIE in TYPE_HASH, or return NULL if DIE does not
   have a saved type.  */

d9572 1
a9572 1
get_die_type (struct die_info *die, htab_t type_hash)
a9583 3
/* Restore the types of the DIE tree starting at START_DIE from the hash
   table saved in CU.  */

d9588 1
d9590 2
a9591 1
  if (cu->per_cu->type_hash == NULL)
d9596 1
a9596 1
      die->type = get_die_type (die, cu->per_cu->type_hash);
a9601 3
/* Set the mark field in CU and in every other compilation unit in the
   cache that we must keep because we are keeping CU.  */

@


1.134
log
@2004-02-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symfile.c (init_entry_point_info, entry_point_address): Move
	from here...
	* objfiles.c (init_entry_point_info, entry_point_address):..to
	here.
	* symfile.h (init_entry_point_info, entry_point_address): Remove
	prototypes.
	* objfiles.h (init_entry_point_info, entry_point_address):Add
	prototypes.
	* cris-tdep.c: Remove include of symfile.h. Add include of
	objfiles.h.
	* infcall.c: Ditto.
	* mcore-tdep.c: Ditto.
	* mn10300-tdep.c: Ditto.
	* sh64-tdep.c: Ditto.
 	* v850-tdep.c: Ditto.
	* arm-tdep.c: Remove include of symfile.h.
	* blockframe.c: Ditto.
	* coffread.c: Ditto.
	* dbxread.c: Ditto.
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* frv-tdep.c: Ditto.
	* ia64-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* mipsread.c: Ditto.
	* rs6000-tdep.c: Ditto.
	* s390-tdep.c: Ditto.
	* sh-tdep.c: Ditto.
	* xstormy16-tdep.c: Ditto.
	* gdbarch.sh: Remove include of symfile.h.
	* gdbarch.c: Regenerate.
	* solib-irix.c (enable_break): Use entry_point_address().
	Add comment about include file.
	* xcoffread.c: Add comment about include file.
	* Makefile.in (arm-tdep.o, blockframe.o, coffread.o, cris-tdep.o)
	(dbxread.o, dwarf2read.o, dwarfread.o, frv-tdep.o, gdbarch.o)
	(ia64-tdep.o, infcall.o, mcore-tdep.o, mdebugread.o, mipsread.o)
	(mn10300-tdep.o, rs6000-nat.o, s390-tdep.o, sh64-tdep.o)
	(sh-tdep.o, v850-tdep.o, xstormy16-tdep.o): Update dependencies.
@
text
@d1565 2
a1566 2
			   ? &objfile->static_psymbols
			   : &objfile->global_psymbols,
@


1.133
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* buildsym.c (free_pending_blocks, finish_block)
	(record_pending_block, make_blockvector, end_symtab): Replace
	symbol_obstack with objfile_obstack.
	* coffread.c (process_coff_symbol, coff_read_struct_type)
	(coff_read_enum_type): Ditto.
	* cp-namespace.c (initialize_namespace_symtab)
	(check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol, dwarf2_const_value, macro_start_file)
	(dwarf2_symbol_mark_computed): Ditto.
	* dwarfread.c (enum_type, new_symbol, synthesize_typedef): Ditto.
	* elfread.c (elf_symtab_read): Ditto.
	* hpread.c (hpread_symfile_init, hpread_symfile_init)
	(hpread_read_enum_type, hpread_read_function_type)
	(hpread_read_doc_function_type, hpread_process_one_debug_symbol):
	Ditto.
	* jv-lang.c (get_java_class_symtab, add_class_symbol)
	(java_link_class_type): Ditto.
	* mdebugread.c (parse_symbol, psymtab_to_symtab_1, new_symtab)
	(new_symbol): Ditto.
	* minsyms.c (install_minimal_symbols): Ditto.
	* objfiles.c (allocate_objfile): Remove init of symbol_obstack.
	(terminate_minimal_symbol_table): Replace symbol_obstack with
	objfile_obstack.
	(free_objfile): Remove freeing of symbol_obstack.
	* objfiles.h: Remove symbol_obstack field.
	* pa64solib.c (add_to_solist): Replace symbol_obstack with
	objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
	symbol_obstack.
	(solib_add_common_symbols): Replace symbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add): Ditto.
	* stabsread.c (patch_block_stabs, define_symbol, read_enum_type)
	(common_block_start, common_block_end): Ditto.
	* symfile.c (reread_symbols): Remove freeing and init of
	symbol_obstack.
	(allocate_symtab): Rename symbol_obstack to objfile_obstack.
	* symfile.h: Update comment.
	* symmisc.c (print_objfile_statistics): Remove symbol_obstack
	stats printing.
	* symtab.c (symbol_set_names): Replace symbol_obstack with
	objfile_obstack.
	* symtab.h (struct general_symbol_info, struct minimal_symbol):
	Update comments.
	* xcoffread.c (read_xcoff_symtab, SYMBOL_DUP, SYMNAME_ALLOC)
	(init_stringtab, xcoff_initial_scan): Replace symbol_obstack with
	objfile_obstack.
@
text
@a33 1
#include "symfile.h"
@


1.132
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

	* dbxread.c (dbx_symfile_init, start_psymtab, end_psymtab,
	coffstab_build_psymtabs, elfstab_build_psymtabs)
	(stabsect_build_psymtabs): Replace psymbol_obstack with
	objfile_obstack.
	* dwarf2-frame.c (decode_frame_entry_1): Ditto.
	* dwarf2read.c (dwarf2_build_psymtabs_hard, dwarf2_read_section):
	Ditto.
	* dwarfread.c (scan_compilation_units): Ditto.
	* elfread.c (elfstab_offset_sections): Ditto.
	* hppa-tdep.c (read_unwind_info): Ditto.
	* hpread.c (hpread_build_psymtabs, hpread_start_psymtab)
	(hpread_end_psymtab): Ditto.
	* mdebugread.c (mdebug_build_psymtabs, add_pending)
	(parse_partial_symbols, new_psymtab, elfmdebug_build_psymtabs):
	Ditto.
	* mips-tdep.c (non_heuristic_proc_desc): Ditto.
	* objfiles.c (add_to_objfile_sections)
	(build_objfile_section_table): Ditto.
	(allocate_objfile): Remove init of psymbol_obstack.
	(free_objfile): Remove freeing of psymbol_obstack.
	* objfiles.h (struct objfile): Remove field
	psymbol_obstack. Update comments.
	* pa64solib.c (pa64_solib_add_solib_objfile): Replace
	psymbol_obstack with objfile_obstack.
	* solib-sunos.c (allocate_rt_common_objfile): Remove init of
        psymbol_obstack.
	* somread.c (som_symfile_offsets, init_import_symbols)
	(init_export_symbols): Replace psymbol_obstack with
	objfile_obstack.
	* somsolib.c (som_solib_add_solib_objfile): Ditto.
	* symfile.c (default_symfile_offsets, syms_from_objfile)
	(reread_symbols): Remove freeing and init of psymbol_obstack.
	(cashier_psymtab): Update comment.
	* symmisc.c (print_objfile_statistics): Don't report stats for
	psymbol obstack.
	* symtab.h (struct general_symbol_info, struct partial_symtab):
	Update comments.
	* xcoffread.c (xcoff_start_psymtab, xcoff_end_psymtab, swap_sym)
	(xcoff_symfile_offsets): Replace psymbol_obstack with
	objfile_obstack.
@
text
@d5547 1
a5547 1
      sym = (struct symbol *) obstack_alloc (&objfile->symbol_obstack,
d5685 1
a5685 1
				    &objfile->symbol_obstack);
d5712 1
a5712 1
		  obstack_alloc (&objfile->symbol_obstack,
d5729 1
a5729 1
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->symbol_obstack,
d5748 1
a5748 1
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->symbol_obstack,
d5807 1
a5807 1
	obstack_alloc (&objfile->symbol_obstack, cu_header->addr_size);
d5825 1
a5825 1
	obstack_alloc (&objfile->symbol_obstack, blk->size);
d7661 1
a7661 1
    pending_macros = new_macro_table (&objfile->symbol_obstack,
d8004 1
a8004 1
      baton = obstack_alloc (&cu->objfile->symbol_obstack,
d8024 1
a8024 1
      baton = obstack_alloc (&cu->objfile->symbol_obstack,
@


1.131
log
@2004-02-07  Elena Zannoni  <ezannoni@@redhat.com>

        * objfiles.h (struct objfile): Add objfile_obstack field.
        Remove type_obstack field.

        * dwarf2read.c (dwarf2_add_field,dwarf2_add_member_fn,
        read_structure_scope read_enumeration, new_symbol): Replace
        type_obstack with objfile_obstack.
        * dwarfread.c (struct_type, enum_type): Ditto.
        * gdbtypes.c (alloc_type, alloc_type_instance, init_type)
        (lookup_fundamental_type): Ditto.
        * gdbtypes.h (TYPE_ALLOC): Ditto.
        * hpread.c (hpread_read_enum_type, hpread_read_function_type)
        (hpread_read_doc_function_type, hpread_read_struct_type)
        (fix_static_member_physnames, hpread_read_array_type)
        (hpread_read_subrange_type, hpread_type_lookup): Ditto.
        * jv-lang.c (java_lookup_class, type_from_class, type_from_class)
        (java_link_class_type): Ditto.
        * mdebugread.c (parse_type): Ditto.
        * objfiles.c (allocate_objfile, free_objfile): Ditto.
        * solib-sunos.c (solib_add_common_symbols): Ditto.
        * stabsread.c (define_symbol, read_type, read_member_functions,
        read_cpp_abbrev, read_one_struct_field): Ditto.
        * symfile.c (reread_symbols): Ditto.
        * symmisc.c (print_objfile_statistics): Ditto.
@
text
@d449 1
a449 1
   psymbol_obstack, so that absolute die references can be handled.
d1259 1
a1259 1
	obstack_alloc (&objfile->psymbol_obstack, sizeof (struct dwarf2_pinfo));
d4135 1
a4135 1
   object file specified by OBJFILE into the psymbol_obstack and return it.  */
d4147 1
a4147 1
  buf = (char *) obstack_alloc (&objfile->psymbol_obstack, size);
@


1.130
log
@2004-01-28  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (add_partial_structure): Use demangled name if
	namespace equals "".
@
text
@d2669 1
a2669 1
			       &objfile->type_obstack);
d2701 1
a2701 1
					     &objfile->type_obstack));
d2704 1
a2704 1
				       &objfile->type_obstack);
d2873 1
a2873 1
				&objfile->type_obstack);
d3039 1
a3039 1
	  char *new_prefix = obconcat (&objfile->type_obstack,
d3050 1
a3050 1
					       &objfile->type_obstack);
d3142 1
a3142 1
					&objfile->type_obstack);
d3259 1
a3259 1
	  TYPE_TAG_NAME (type) = obconcat (&objfile->type_obstack,
d3268 1
a3268 1
					       &objfile->type_obstack);
d5720 1
a5720 1
				  &objfile->type_obstack);
@


1.129
log
@* dwarf2read.c (read_func_scope): Re-indent comment.
@
text
@d1664 1
a1664 1
      && namespace == NULL
d1668 2
a1669 2
      /* We don't have namespace debugging information, so see if we
	 can figure out if this structure lives in a namespace.  Look
d1678 15
@


1.128
log
@Clean up misapplied patch:
* dwarf2read.c (determine_prefix): Change one of the two forward
declarations for 'determine_prefix_aux' to a declaration for this.
(read_func_scope): Use cu->language, not cu_language.  Pass 'cu'
argument to 'die_specification'.
@
text
@d2176 3
a2178 3
	  /* NOTE: carlton/2004-01-23: We have to be careful in the
	     presence of DW_AT_specification.  For example, with GCC
	     3.4, given the code
d2180 5
a2184 5
               namespace N {
	         void foo() {
		   // Definition of N::foo.
	         }
	       }
d2186 1
a2186 1
	     then we'll have a tree of DIEs like this:
d2188 5
a2192 5
	     1: DW_TAG_compile_unit
               2: DW_TAG_namespace        // N
                 3: DW_TAG_subprogram     // declaration of N::foo
               4: DW_TAG_subprogram       // definition of N::foo
                    DW_AT_specification   // refers to die #3
d2194 3
a2196 3
             Thus, when processing die #4, we have to pretend that
             we're in the context of its DW_AT_specification, namely
             the contex of die #3.  */
@


1.127
log
@	* dwarf2read.c: Update calls to changed and renamed functions, and
	references to moved variables.

	(struct dwarf2_cu): Add first_fn, last_fn, cached_fn,
	language, language_defn, list_in_scope, and ftypes members.
	(cu_first_fn, cu_last_fn, cu_cached_fn, cu_language)
	(cu_language_defn, list_in_scope, ftypes, cu_header_offset)
	(baseaddr): Remove globals.

	(dwarf_attr): Renamed to dwarf2_attr.  Add CU argument.
	(set_cu_language, die_is_declaration, die_specification)
	(determine_prefix, determin_prefix_aux, class_name, namespace_name)
	(dwarf2_linkage_name, dwarf2_name, dwarf2_extension)
	(dwarf2_get_ref_die_offset, dwarf2_fundamental_type)
	(initialize_cu_func_list, add_to_cu_func_list): Add CU argument.

	(dwarf2_build_psymtabs_hard): Add local baseaddr.  Initialize
	cu.list_in_scope.  Don't initialize cu_header_offset.
	(add_partial_symbol): Add local baseaddr.
	(psymtab_to_symtab_1): Add local baseaddr.  Use
	objfile->section_offsets for consistency.  Don't initialize
	cu_header_offset; do initialize cu.header.offset and
	cu.list_in_scope.
	(read_file_scope, read_func_scope, read_lexical_block_scope)
	(dwarf_decode_lines, new_symbol): Add local baseaddr.
@
text
@d768 1
a768 1
static char *determine_prefix_aux (struct die_info *die, struct dwarf2_cu *);
d2172 1
a2172 1
  if (cu_language == language_cplus)
d2174 1
a2174 1
      struct die_info *spec_die = die_specification (die);
@


1.126
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2loc.c (dwarf_expr_frame_base): Use SYMBOL_OPS instead of
	SYMBOL_LOCATION_FUNCS
	(dwarf2_loclist_funcs, dwarf2_locexpr_funcs): Change type to
	"struct symbol_ops".
	* dwarf2loc.h (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Change
	type to "struct symbol_ops".
	* symtab.h (struct symbol_ops): Rename "struct location_funcs".
	(struct symbol): Replace ".aux_value.loc.funcs" and
	".aux_value.loc.baton" with ".ops" and ".aux_value.ptr".
	(SYMBOL_OBJFILE): Delete macro.
	(SYMBOL_LOCATION_FUNCS): Delete macro.
	(SYMBOL_LOCATION_BATON): Update.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Set SYMBOL_OPS
	intead of SYMBOL_LOCATION_FUNCS.
	* ax-gdb.c (gen_var_ref): Ditto.
	* printcmd.c (address_info): Ditto.
	* findvar.c (read_var_value): Ditto.
	(symbol_read_needs_frame): Ditto.
@
text
@d234 28
a390 2
static struct function_range *cu_first_fn, *cu_last_fn, *cu_cached_fn;

a419 4
/* Offset to the first byte of the current compilation unit header,
   for resolving relative reference dies. */
static unsigned int cu_header_offset;

a424 4
/* The language we are debugging.  */
static enum language cu_language;
static const struct language_defn *cu_language_defn;

a436 11
/* The generic symbol table building routines have separate lists for
   file scope symbols and all all other scopes (local scopes).  So
   we need to select the right one to pass to add_symbol_to_list().
   We do it by keeping a pointer to the correct list in list_in_scope.

   FIXME:  The original dwarf code just treated the file scope as the first
   local scope, and all other local scopes as nested local scopes, and worked
   fine.  Check to see if we really need to distinguish these
   in buildsym.c.  */
static struct pending **list_in_scope = &file_symbols;

a445 5
/* This value is added to each symbol value.  FIXME:  Generalize to
   the section_offsets structure used by dbxread (once this is done,
   pass the appropriate section number to end_symtab).  */
static CORE_ADDR baseaddr;	/* Add to each symbol value */

a529 11
/* Maintain an array of referenced fundamental types for the current
   compilation unit being read.  For DWARF version 1, we have to construct
   the fundamental types on the fly, since no information about the
   fundamental types is supplied.  Each such fundamental type is created by
   calling a language dependent routine to create the type, and then a
   pointer to that type is then placed in the array at the index specified
   by it's FT_<TYPENAME> value.  The array has a fixed size set by the
   FT_NUM_MEMBERS compile time constant, which is the number of predefined
   fundamental types gdb knows how to construct.  */
static struct type *ftypes[FT_NUM_MEMBERS];	/* Fundamental types */

d724 1
a724 1
static void set_cu_language (unsigned int);
d726 2
a727 1
static struct attribute *dwarf_attr (struct die_info *, unsigned int);
d729 1
a729 1
static int die_is_declaration (struct die_info *);
d731 2
a732 1
static struct die_info *die_specification (struct die_info *die);
d768 1
a768 1
static char *determine_prefix (struct die_info *die);
d770 1
a770 1
static char *determine_prefix_aux (struct die_info *die);
d774 1
a774 1
static char *class_name (struct die_info *die);
d815 1
a815 1
				   int *is_anonymous);
d858 1
a858 1
static char *dwarf2_linkage_name (struct die_info *);
d860 1
a860 1
static char *dwarf2_name (struct die_info *die);
d862 2
a863 1
static struct die_info *dwarf2_extension (struct die_info *die);
d893 2
a894 1
static unsigned int dwarf2_get_ref_die_offset (struct attribute *);
d900 2
a901 1
static struct type *dwarf2_fundamental_type (struct objfile *, int);
d913 1
a913 1
static void initialize_cu_func_list (void);
d915 2
a916 1
static void add_to_cu_func_list (const char *, CORE_ADDR, CORE_ADDR);
d1154 1
a1154 1
  CORE_ADDR lowpc, highpc;
d1238 2
d1249 1
a1249 1
      set_cu_language (comp_unit_die.language);
a1259 1
      cu_header_offset = beg_of_comp_unit - dwarf_info_buffer;
d1449 3
d1475 1
a1475 1
				      cu_language, objfile);
d1485 1
a1485 1
				      cu_language, objfile);
d1511 1
a1511 1
					cu_language, objfile);
d1525 1
a1525 1
				      cu_language, objfile);
d1534 1
a1534 1
			   0, (CORE_ADDR) 0, cu_language, objfile);
d1548 1
a1548 1
			   cu_language == language_cplus
d1551 1
a1551 1
			   0, (CORE_ADDR) 0, cu_language, objfile);
d1553 1
a1553 1
      if (cu_language == language_cplus)
d1559 1
a1559 1
			       0, (CORE_ADDR) 0, cu_language, objfile);
d1565 1
a1565 1
			   cu_language == language_cplus
d1568 1
a1568 1
			   0, (CORE_ADDR) 0, cu_language, objfile);
d1580 1
a1580 1
  if (cu_language == language_cplus
d1643 1
a1643 1
		       0, 0, cu_language, objfile);
d1663 1
a1663 1
  if (cu_language == language_cplus
d1705 1
a1705 1
  xfree(actual_class_name);
d1814 1
a1830 2
  baseaddr = ANOFFSET (pst->section_offsets, SECT_OFF_TEXT (objfile));
  cu_header_offset = offset;
d1832 1
d1852 4
d1869 1
a1869 1
  attr = dwarf_attr (dies, DW_AT_entry_pc);
d1877 1
a1877 1
      attr = dwarf_attr (dies, DW_AT_low_pc);
d1899 1
a1899 1
      && !(cu_language == language_c && symtab->language != language_c))
d1901 1
a1901 1
      symtab->language = cu_language;
d1963 1
a1963 1
      if (dwarf_attr (die, DW_AT_name))
d1971 1
a1971 1
      if (dwarf_attr (die, DW_AT_name))
d2004 1
a2004 1
initialize_cu_func_list (void)
d2006 1
a2006 1
  cu_first_fn = cu_last_fn = cu_cached_fn = NULL;
d2023 3
d2036 1
a2036 1
  attr = dwarf_attr (die, DW_AT_name);
d2041 1
a2041 1
  attr = dwarf_attr (die, DW_AT_comp_dir);
d2063 1
a2063 1
  attr = dwarf_attr (die, DW_AT_language);
d2066 1
a2066 1
      set_cu_language (DW_UNSND (attr));
d2081 1
a2081 1
  memset (ftypes, 0, FT_NUM_MEMBERS * sizeof (struct type *));
d2086 1
a2086 1
  initialize_cu_func_list ();
d2100 1
a2100 1
  attr = dwarf_attr (die, DW_AT_stmt_list);
d2117 1
a2117 1
  attr = dwarf_attr (die, DW_AT_macro_info);
d2128 2
a2129 1
add_to_cu_func_list (const char *name, CORE_ADDR lowpc, CORE_ADDR highpc)
d2141 2
a2142 2
  if (cu_last_fn == NULL)
      cu_first_fn = thisfn;
d2144 1
a2144 1
      cu_last_fn->next = thisfn;
d2146 1
a2146 1
  cu_last_fn = thisfn;
d2161 1
d2163 3
a2165 1
  name = dwarf2_linkage_name (die);
d2200 1
a2200 1
	  char *specification_prefix = determine_prefix (spec_die);
d2210 1
a2210 1
  add_to_cu_func_list (name, lowpc, highpc);
d2224 1
a2224 1
  attr = dwarf_attr (die, DW_AT_frame_base);
d2237 1
a2237 1
  list_in_scope = &local_symbols;
d2264 1
a2264 1
    list_in_scope = &file_symbols;
d2281 3
d2330 1
a2330 1
  attr = dwarf_attr (die, DW_AT_high_pc);
d2334 1
a2334 1
      attr = dwarf_attr (die, DW_AT_low_pc);
d2346 1
a2346 1
      attr = dwarf_attr (die, DW_AT_ranges);
d2565 1
a2565 1
  attr = dwarf_attr (die, DW_AT_accessibility);
d2570 1
a2570 1
  attr = dwarf_attr (die, DW_AT_virtuality);
d2576 1
a2576 1
  if (die->tag == DW_TAG_member && ! die_is_declaration (die))
d2586 1
a2586 1
      attr = dwarf_attr (die, DW_AT_bit_size);
d2597 1
a2597 1
      attr = dwarf_attr (die, DW_AT_data_member_location);
d2605 1
a2605 1
      attr = dwarf_attr (die, DW_AT_bit_offset);
d2628 1
a2628 1
	      attr = dwarf_attr (die, DW_AT_byte_size);
d2650 1
a2650 1
      attr = dwarf_attr (die, DW_AT_name);
d2658 1
a2658 1
      if (dwarf_attr (die, DW_AT_artificial))
d2676 1
a2676 1
      attr = dwarf_attr (die, DW_AT_name);
d2683 1
a2683 1
      physname = dwarf2_linkage_name (die);
d2694 1
a2694 1
      attr = dwarf_attr (die, DW_AT_data_member_location);
d2809 1
a2809 1
  attr = dwarf_attr (die, DW_AT_name);
d2816 1
a2816 1
  physname = dwarf2_linkage_name (die);
d2886 1
a2886 1
  if (dwarf_attr (die, DW_AT_containing_type) != NULL)
d2893 1
a2893 1
  attr = dwarf_attr (die, DW_AT_accessibility);
d2908 1
a2908 1
  attr = dwarf_attr (die, DW_AT_artificial);
d2913 1
a2913 1
  attr = dwarf_attr (die, DW_AT_vtable_elem_location);
d3000 1
a3000 1
  attr = dwarf_attr (die, DW_AT_name);
d3005 1
a3005 1
      if (cu_language == language_cplus)
d3007 1
a3007 1
	  struct die_info *spec_die = die_specification (die);
d3011 1
a3011 1
	      char *specification_prefix = determine_prefix (spec_die);
d3036 1
a3036 1
	  need_to_update_name = (cu_language == language_cplus);
d3055 1
a3055 1
  attr = dwarf_attr (die, DW_AT_byte_size);
d3070 1
a3070 1
  if (die->child != NULL && ! die_is_declaration (die))
d3120 1
a3120 1
						(child_die));
d3156 1
a3156 1
	  if (dwarf_attr (die, DW_AT_containing_type) != NULL)
d3237 1
a3237 1
  attr = dwarf_attr (die, DW_AT_name);
d3257 1
a3257 1
  attr = dwarf_attr (die, DW_AT_byte_size);
d3280 1
a3280 1
	      attr = dwarf_attr (child_die, DW_AT_name);
d3352 1
a3352 1
      index_type = dwarf2_fundamental_type (objfile, FT_INTEGER);
d3396 1
a3396 1
  attr = dwarf_attr (die, DW_AT_GNU_vector);
d3416 1
a3416 1
  attr = dwarf_attr (die, DW_AT_location);
d3440 1
a3440 1
	  attr = dwarf_attr (child_die, DW_AT_data_member_location);
d3463 1
a3463 1
  name = namespace_name (die, &is_anonymous);
d3488 1
a3488 1
  if (dwarf2_extension (die) == NULL)
d3526 1
a3526 1
namespace_name (struct die_info *die, int *is_anonymous)
d3535 1
a3535 1
       current_die = dwarf2_extension (die))
d3537 1
a3537 1
      name = dwarf2_name (current_die);
d3570 1
a3570 1
  attr_byte_size = dwarf_attr (die, DW_AT_byte_size);
d3576 1
a3576 1
  attr_address_class = dwarf_attr (die, DW_AT_address_class);
d3648 1
a3648 1
  attr = dwarf_attr (die, DW_AT_byte_size);
d3706 1
a3706 1
  attr = dwarf_attr (die, DW_AT_string_length);
d3714 1
a3714 1
      attr = dwarf_attr (die, DW_AT_byte_size);
d3724 1
a3724 1
  index_type = dwarf2_fundamental_type (objfile, FT_INTEGER);
d3726 1
a3726 1
  if (cu_language == language_fortran)
d3734 1
a3734 1
      char_type = dwarf2_fundamental_type (objfile, FT_CHAR);
d3767 1
a3767 1
  attr = dwarf_attr (die, DW_AT_prototyped);
d3769 1
a3769 1
      || cu_language == language_cplus)
d3806 1
a3806 1
	      attr = dwarf_attr (child_die, DW_AT_artificial);
d3830 1
a3830 1
      attr = dwarf_attr (die, DW_AT_name);
d3857 1
a3857 1
  attr = dwarf_attr (die, DW_AT_encoding);
d3862 1
a3862 1
  attr = dwarf_attr (die, DW_AT_byte_size);
d3867 1
a3867 1
  attr = dwarf_attr (die, DW_AT_name);
d3904 2
a3905 1
	TYPE_TARGET_TYPE (type) = dwarf2_fundamental_type (objfile, FT_VOID);
d3910 1
a3910 1
	      = dwarf2_fundamental_type (objfile, FT_EXT_PREC_FLOAT);
d3913 1
a3913 1
	      = dwarf2_fundamental_type (objfile, FT_DBL_PREC_FLOAT);
d3916 1
a3916 1
	      = dwarf2_fundamental_type (objfile, FT_FLOAT);
d3952 1
a3952 1
  if (cu_language == language_fortran)
d3958 1
a3958 1
  attr = dwarf_attr (die, DW_AT_lower_bound);
d3962 1
a3962 1
  attr = dwarf_attr (die, DW_AT_upper_bound);
d3986 1
a3986 1
  attr = dwarf_attr (die, DW_AT_name);
d3990 1
a3990 1
  attr = dwarf_attr (die, DW_AT_byte_size);
d4367 1
a4367 1
	      dwarf_info_buffer + dwarf2_get_ref_die_offset (&attr);
d4382 2
a4383 1
      spec_ptr = dwarf_info_buffer + dwarf2_get_ref_die_offset (&spec_attr);
d4917 1
a4917 1
set_cu_language (unsigned int lang)
d4923 1
a4923 1
      cu_language = language_c;
d4926 1
a4926 1
      cu_language = language_cplus;
d4931 1
a4931 1
      cu_language = language_fortran;
d4934 1
a4934 1
      cu_language = language_asm;
d4937 1
a4937 1
      cu_language = language_java;
d4946 1
a4946 1
      cu_language = language_minimal;
d4949 1
a4949 1
  cu_language_defn = language_def (cu_language);
d4955 1
a4955 1
dwarf_attr (struct die_info *die, unsigned int name)
d4973 1
a4973 1
      follow_die_ref (dwarf2_get_ref_die_offset (spec));
d4976 1
a4976 1
	return dwarf_attr (ref_die, name);
d4983 1
a4983 1
die_is_declaration (struct die_info *die)
d4985 2
a4986 2
  return (dwarf_attr (die, DW_AT_declaration)
	  && ! dwarf_attr (die, DW_AT_specification));
d4993 1
a4993 1
die_specification (struct die_info *die)
d4995 1
a4995 1
  struct attribute *spec_attr = dwarf_attr (die, DW_AT_specification);
d5000 1
a5000 1
    return follow_die_ref (dwarf2_get_ref_die_offset (spec_attr));
d5194 1
a5194 1
check_cu_functions (CORE_ADDR address)
d5199 1
a5199 1
  if (!cu_first_fn)
d5202 2
a5203 2
  if (!cu_cached_fn)
    cu_cached_fn = cu_first_fn;
d5205 1
a5205 1
  fn = cu_cached_fn;
d5212 2
a5213 2
  fn = cu_first_fn;
  while (fn && fn != cu_cached_fn)
d5244 4
d5293 1
a5293 1
	                   check_cu_functions (address));
d5340 1
a5340 1
	                   check_cu_functions (address));
d5521 3
d5526 1
a5526 1
    name = dwarf2_linkage_name (die);
d5538 1
a5538 1
      SYMBOL_LANGUAGE (sym) = cu_language;
d5549 1
a5549 1
      attr = dwarf_attr (die, DW_AT_decl_line);
d5557 1
a5557 1
	  attr = dwarf_attr (die, DW_AT_low_pc);
d5568 1
a5568 1
	  attr2 = dwarf_attr (die, DW_AT_external);
d5575 1
a5575 1
	      add_symbol_to_list (sym, list_in_scope);
d5587 1
a5587 1
	  attr = dwarf_attr (die, DW_AT_const_value);
d5591 1
a5591 1
	      attr2 = dwarf_attr (die, DW_AT_external);
d5595 1
a5595 1
		add_symbol_to_list (sym, list_in_scope);
d5598 1
a5598 1
	  attr = dwarf_attr (die, DW_AT_location);
d5602 1
a5602 1
	      attr2 = dwarf_attr (die, DW_AT_external);
d5606 1
a5606 1
		add_symbol_to_list (sym, list_in_scope);
d5616 1
a5616 1
	      attr2 = dwarf_attr (die, DW_AT_external);
d5618 1
a5618 1
		  && dwarf_attr (die, DW_AT_type) != NULL)
d5626 1
a5626 1
	  attr = dwarf_attr (die, DW_AT_location);
d5634 1
a5634 1
	  attr = dwarf_attr (die, DW_AT_const_value);
d5639 1
a5639 1
	  add_symbol_to_list (sym, list_in_scope);
d5658 1
a5658 1
	  if (cu_language == language_cplus)
d5685 3
a5687 3
	    list_to_add = (list_in_scope == &file_symbols
			   && cu_language == language_cplus
			   ? &global_symbols : list_in_scope);
d5694 1
a5694 1
	    if (cu_language == language_cplus)
d5721 1
a5721 1
	  add_symbol_to_list (sym, list_in_scope);
d5727 1
a5727 1
	  add_symbol_to_list (sym, list_in_scope);
d5738 1
a5738 1
	  attr = dwarf_attr (die, DW_AT_const_value);
d5749 3
a5751 3
	    list_to_add = (list_in_scope == &file_symbols
			   && cu_language == language_cplus
			   ? &global_symbols : list_in_scope);
d5886 1
a5886 1
  type_attr = dwarf_attr (die, DW_AT_type);
d5890 1
a5890 1
      return dwarf2_fundamental_type (cu->objfile, FT_VOID);
d5894 1
a5894 1
      ref = dwarf2_get_ref_die_offset (type_attr);
d5924 1
a5924 1
  type_attr = dwarf_attr (die, DW_AT_containing_type);
d5927 1
a5927 1
      ref = dwarf2_get_ref_die_offset (type_attr);
d5988 1
a5988 1
  char *prefix = determine_prefix (die);
d6055 1
a6055 1
determine_prefix (struct die_info *die)
d6057 1
a6057 1
  char *prefix = determine_prefix_aux (die);
d6067 1
a6067 1
determine_prefix_aux (struct die_info *die)
d6071 1
a6071 1
  if (cu_language != language_cplus)
d6082 1
a6082 1
      char *parent_prefix = determine_prefix_aux (parent);
d6091 1
a6091 1
				    namespace_name (parent, &dummy));
d6099 1
a6099 1
	      const char *parent_name = dwarf2_name (parent);
d6102 1
a6102 1
		retval = typename_concat (parent_prefix, dwarf2_name (parent));
d6110 1
a6110 1
	    retval = class_name (parent);
d6149 1
a6149 1
class_name (struct die_info *die)
d6157 1
a6157 1
	return class_name_from_physname (dwarf2_linkage_name (child));
d6160 1
a6160 1
  name = dwarf2_name (die);
d6178 1
a6178 1
      type = dwarf2_fundamental_type (objfile, FT_VOID);
d6181 1
a6181 1
      type = dwarf2_fundamental_type (objfile, FT_BOOLEAN);
d6186 1
a6186 1
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_COMPLEX);
d6190 1
a6190 1
	  type = dwarf2_fundamental_type (objfile, FT_COMPLEX);
d6196 1
a6196 1
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_FLOAT);
d6200 1
a6200 1
	  type = dwarf2_fundamental_type (objfile, FT_FLOAT);
d6207 1
a6207 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR);
d6210 1
a6210 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_SHORT);
d6214 1
a6214 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER);
d6219 1
a6219 1
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR);
d6225 1
a6225 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR);
d6228 1
a6228 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_SHORT);
d6232 1
a6232 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_INTEGER);
d6237 1
a6237 1
      type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR);
d6240 1
a6240 1
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER);
d6289 1
a6289 1
dwarf2_linkage_name (struct die_info *die)
d6293 1
a6293 1
  attr = dwarf_attr (die, DW_AT_MIPS_linkage_name);
d6296 1
a6296 1
  attr = dwarf_attr (die, DW_AT_name);
d6305 1
a6305 1
dwarf2_name (struct die_info *die)
d6309 1
a6309 1
  attr = dwarf_attr (die, DW_AT_name);
d6319 1
a6319 1
dwarf2_extension (struct die_info *die)
d6325 1
a6325 1
  attr = dwarf_attr (die, DW_AT_extension);
d6329 1
a6329 1
  ref = dwarf2_get_ref_die_offset (attr);
d7242 1
a7242 1
dwarf2_get_ref_die_offset (struct attribute *attr)
d7256 1
a7256 1
      result = cu_header_offset + DW_UNSND (attr);
d7308 2
a7309 1
dwarf2_fundamental_type (struct objfile *objfile, int typeid)
d7321 1
a7321 1
  if (ftypes[typeid] == NULL)
d7323 1
a7323 1
      ftypes[typeid] = cu_language_defn->la_fund_type (objfile, typeid);
d7326 1
a7326 1
  return (ftypes[typeid]);
@


1.125
log
@Index: ChangeLog
2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2read.c (read_func_scope): Document frame-base hack.
@
text
@d7977 1
a7977 1
      SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_loclist_funcs;
d8006 1
a8006 1
      SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_locexpr_funcs;
@


1.124
log
@2004-01-23  David Carlton  <carlton@@kealia.com>

	Patch for PR c++/1520:
	* dwarf2read.c (read_func_scope): Set processing_current_prefix
	properly if we have a specification die.
	(determine_prefix_aux): Rename from determine_prefix.
	(determine_prefix): Like the old determine_prefix, but never
	returns NULL.
@
text
@d2214 9
@


1.123
log
@2004-01-22  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (psymtab_to_symtab_1): Calculate lowpc, highpc via
	get_scope_pc_bounds.
	(read_file_scope): Ditto.
	(get_scope_pc_bounds): New function, produced by extracting code
	from the above two functions, consolidating it, and adding support
	for DW_TAG_namespace.
@
text
@d777 2
d2150 2
d2160 34
d2244 4
d6014 15
d6034 1
a6034 1
determine_prefix (struct die_info *die)
d6049 1
a6049 1
      char *parent_prefix = determine_prefix (parent);
@


1.122
log
@        * dwarf2read.c (dwarf2_non_const_array_bound_ignored_complaint):
        Delete, no longer used.
        (read_subrange_type): New function, mostly extracted from
        read_array_type().
        (read_array_type): Replace extracted code by call to
        read_subrange_type().
        (dwarf2_get_attr_constant_value): New function.
        (scan_partial_symbols): Add handling for DW_TAG_subrange_type.
        (add_partial_symbol): Likewise.
        (process_die): Likewise.
        (new_symbol): Likewise.
        (read_type_die): Likewise.
@
text
@d796 4
d1881 4
a1884 14
  if (!dwarf2_get_pc_bounds (dies, &lowpc, &highpc, &cu))
    {
      /* Some compilers don't define a DW_AT_high_pc attribute for
         the compilation unit.   If the DW_AT_high_pc is missing,
         synthesize it, by scanning the DIE's below the compilation unit.  */
      highpc = 0;
      if (dies->child != NULL)
	{
	  child_die = dies->child;
	  while (child_die && child_die->tag)
	    {
	      if (child_die->tag == DW_TAG_subprogram)
		{
		  CORE_ADDR low, high;
a1885 9
		  if (dwarf2_get_pc_bounds (child_die, &low, &high, &cu))
		    {
		      highpc = max (highpc, high);
		    }
		}
	      child_die = sibling_die (child_die);
	    }
	}
    }
d2017 1
a2017 21
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
    {
      if (die->child != NULL)
	{
	  child_die = die->child;
	  while (child_die && child_die->tag)
	    {
	      if (child_die->tag == DW_TAG_subprogram)
		{
		  CORE_ADDR low, high;

		  if (dwarf2_get_pc_bounds (child_die, &low, &high, cu))
		    {
		      lowpc = min (lowpc, low);
		      highpc = max (highpc, high);
		    }
		}
	      child_die = sibling_die (child_die);
	    }
	}
    }
d2406 62
@


1.121
log
@2004-01-16  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c: Update copyright year.
	(compare_symbols): Delete unused function.
	* stabsread.c: Update copyright year.
	(lrs_general_complaint): Delete unused function.
	(ref_search_value): Ditto.
	(get_substring): Delete declaration.
	* sh64-tdep.c: Update copyright year.
	(sh64_get_gdb_regnum): Delete unused function.
	* dwarf2read.c (dwarf2_unsupported_at_frame_base_complaint):
	Delete unused function.
@
text
@a594 7
dwarf2_non_const_array_bound_ignored_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "non-constant array bounds form '%s' ignored",
	     arg1);
}

static void
d785 2
d895 2
d1399 1
d1523 1
d1977 8
d3271 1
a3271 1
	  unsigned int low, high;
d3273 14
a3286 80
	  /* Default bounds to an array with unspecified length.  */
	  low = 0;
	  high = -1;
	  if (cu_language == language_fortran)
	    {
	      /* FORTRAN implies a lower bound of 1, if not given.  */
	      low = 1;
	    }

	  index_type = die_type (child_die, cu);
	  attr = dwarf_attr (child_die, DW_AT_lower_bound);
	  if (attr)
	    {
	      if (attr->form == DW_FORM_sdata)
		{
		  low = DW_SND (attr);
		}
	      else if (attr->form == DW_FORM_udata
		       || attr->form == DW_FORM_data1
		       || attr->form == DW_FORM_data2
		       || attr->form == DW_FORM_data4
		       || attr->form == DW_FORM_data8)
		{
		  low = DW_UNSND (attr);
		}
	      else
		{
		  dwarf2_non_const_array_bound_ignored_complaint
		    (dwarf_form_name (attr->form));
		  low = 0;
		}
	    }
	  attr = dwarf_attr (child_die, DW_AT_upper_bound);
	  if (attr)
	    {
	      if (attr->form == DW_FORM_sdata)
		{
		  high = DW_SND (attr);
		}
	      else if (attr->form == DW_FORM_udata
		       || attr->form == DW_FORM_data1
		       || attr->form == DW_FORM_data2
		       || attr->form == DW_FORM_data4
		       || attr->form == DW_FORM_data8)
		{
		  high = DW_UNSND (attr);
		}
	      else if (attr->form == DW_FORM_block1)
		{
		  /* GCC encodes arrays with unspecified or dynamic length
		     with a DW_FORM_block1 attribute.
		     FIXME: GDB does not yet know how to handle dynamic
		     arrays properly, treat them as arrays with unspecified
		     length for now.

                     FIXME: jimb/2003-09-22: GDB does not really know
                     how to handle arrays of unspecified length
                     either; we just represent them as zero-length
                     arrays.  Choose an appropriate upper bound given
                     the lower bound we've computed above.  */
		  high = low - 1;
		}
	      else
		{
		  dwarf2_non_const_array_bound_ignored_complaint
		    (dwarf_form_name (attr->form));
		  high = 1;
		}
	    }

	  /* Create a range type and save it for array type creation.  */
	  if ((ndim % DW_FIELD_ALLOC_CHUNK) == 0)
	    {
	      range_types = (struct type **)
		xrealloc (range_types, (ndim + DW_FIELD_ALLOC_CHUNK)
			  * sizeof (struct type *));
	      if (ndim == 0)
		make_cleanup (free_current_contents, &range_types);
	    }
	  range_types[ndim++] = create_range_type (NULL, index_type, low, high);
d3832 72
d5622 1
d5929 3
d7147 22
@


1.120
log
@2004-01-14  David Carlton  <carlton@@kealia.com>

	Change symbols for C++ nested types to contain the fully qualified
	name, if possible.  (At least in the DWARF-2 case.)  Partial fix
	for PR's c++/57, c++/488, c++/539, c++/573, c++/609, c++/832,
	c++/895.
	* c-exp.y: Update copyright:
	(qualified_type): Handle types nested within classes.
	* cp-namespace.c: Update comments.
	(cp_set_block_scope): Delete #if 0.
	(cp_lookup_nested_type): Handle types nested within classes.
	* dwarf2read.c: (scan_partial_symbols): Call add_partial_structure
	when appropriate.
	(add_partial_symbol): Add the name of the enclosing namespace to
	types.
	(pdi_needs_namespace): New.
	(add_partial_namespace): Tweak comment.
	(add_partial_structure): New.
	(psymtab_to_symtab_1): Initialize processing_current_prefix
	here...
	(process_die): instead of here.
	(read_structure_scope): Try to figure out the name of the class or
	namespace that the structure might be defined within.
	(read_enumeration): Generate fully-qualified names, if possible.
	(read_namespace): Don't set name to NULL.
	(die_specification): New.
	(new_symbol): Generate fully-qualified names for types.
	(read_type_die): Determine appropriate prefix.
	(determine_prefix): New.
	(typename_concat): New.
	(class_name): New.
	* valops.c: Update copyright.
	(value_aggregate_elt): Pass NOSIDE to
	value_struct_elt_for_reference.
	(value_struct_elt_for_reference): Make static, add NOSIDE
	parameter, call value_maybe_namespace_elt as a last resort.
	(value_namespace_elt): Break out code into
	value_maybe_namespace_elt.
	(value_maybe_namespace_elt): New.

2004-01-14  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Add tests involving classes defined within
	namespaces.
	* gdb.cp/namespace.cc (C::CClass): New.
	* gdb.cp/namespace1.cc: Update copyright.
	(C::OtherFileClass): New.
@
text
@a614 7
dwarf2_unsupported_at_frame_base_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "unsupported DW_AT_frame_base for function '%s'", arg1);
}

static void
@


1.119
log
@2004-01-09  David Carlton  <carlton@@kealia.com>

        Checked in by Elena Zannoni  <ezannoni@@redhat.com>.
        * dwarf2read.c (read_namespace): Pull out name-generating code
        into namespace_name. Rename previous_namespace to previous_prefix
        and processing_current_namespace to processing_current_prefix..
        (namespace_name): New function.
        (add_partial_symbol): Substitute uses of pdi->name with
        actual_name.
        * cp-support.h: Rename processing_current_namespace to
        processing_current_prefix.
        Update copyright year.
        * cp-namespace.c: Rename processing_current_namespace to
        processing_current_prefix.
        Update copyright year.
@
text
@d669 2
d677 5
d753 2
d789 6
d1386 5
d1395 3
a1397 1
		  add_partial_symbol (&pdi, cu, namespace);
d1455 11
d1543 2
d1549 3
a1551 1
			   &objfile->static_psymbols,
d1559 1
a1559 1
			       &objfile->static_psymbols,
d1566 3
a1568 1
			   &objfile->static_psymbols,
d1589 24
d1636 4
a1639 3
  /* FIXME: carlton/2003-06-27: Once we build qualified names for more
     symbols than just namespaces, we should replace this by a call to
     add_partial_symbol.  */
d1654 57
d1835 3
d1991 1
a1991 5
      if (!processing_has_namespace_info)
	{
	  processing_has_namespace_info = 1;
	  processing_current_prefix = "";
	}
d2002 1
a2002 5
      if (!processing_has_namespace_info)
	{
	  processing_has_namespace_info = 1;
	  processing_current_prefix = "";
	}
d2896 7
d2910 35
a2944 3
      TYPE_TAG_NAME (type) = obsavestring (DW_STRING (attr),
					   strlen (DW_STRING (attr)),
					   &objfile->type_obstack);
d3004 35
d3114 4
d3147 15
a3161 3
      TYPE_TAG_NAME (type) = obsavestring (DW_STRING (attr),
					   strlen (DW_STRING (attr)),
					   &objfile->type_obstack);
d3432 1
a3432 1
  const char *name = NULL;
d4888 13
a5543 1
	  add_symbol_to_list (sym, list_in_scope);
d5545 5
a5549 3
	  /* The semantics of C++ state that "struct foo { ... }" also
	     defines a typedef for "foo". Synthesize a typedef symbol so
	     that "ptype foo" works as expected.  */
d5552 12
a5563 11
	      struct symbol *typedef_sym = (struct symbol *)
	      obstack_alloc (&objfile->symbol_obstack,
			     sizeof (struct symbol));
	      *typedef_sym = *sym;
	      SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
	      if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
		TYPE_NAME (SYMBOL_TYPE (sym)) =
		  obsavestring (DEPRECATED_SYMBOL_NAME (sym),
				strlen (DEPRECATED_SYMBOL_NAME (sym)),
				&objfile->type_obstack);
	      add_symbol_to_list (typedef_sym, list_in_scope);
d5565 36
d5603 12
d5621 8
d5634 12
a5645 1
	  add_symbol_to_list (sym, list_in_scope);
d5879 5
d5930 108
@


1.118
log
@2004-01-09  Elena Zannoni  <ezannoni@@redhat.com>

       * dwarf2read.c (read_array_type): Discard FORTRAN_HACK macro and
       ifdeffed code.
       Update copyright year.
@
text
@d812 3
d1430 1
d1438 1
a1438 1
	  /*prim_record_minimal_symbol (pdi->name, pdi->lowpc + baseaddr,
d1440 1
a1440 1
	  psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1448 1
a1448 1
	  /*prim_record_minimal_symbol (pdi->name, pdi->lowpc + baseaddr,
d1450 1
a1450 1
	  psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1476 1
a1476 1
	    psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1488 1
a1488 1
	  /*prim_record_minimal_symbol (pdi->name, addr + baseaddr,
d1490 1
a1490 1
	  psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1499 1
a1499 1
      add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1512 1
a1512 1
      add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1520 1
a1520 1
	  add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1527 1
a1527 1
      add_psymbol_to_list (pdi->name, strlen (pdi->name),
d1870 1
a1870 1
	  processing_current_namespace = "";
d1885 1
a1885 1
	  processing_current_namespace = "";
d3225 1
a3225 1
  const char *previous_namespace = processing_current_namespace;
d3230 1
a3230 16
  /* Loop through the extensions until we find a name.  */

  for (current_die = die;
       current_die != NULL;
       current_die = dwarf2_extension (die))
    {
      name = dwarf2_name (current_die);
      if (name != NULL)
	break;
    }

  /* Is it an anonymous namespace?  */

  is_anonymous = (name == NULL);
  if (is_anonymous)
    name = "(anonymous namespace)";
d3234 1
a3234 1
  if (previous_namespace[0] == '\0')
d3236 1
a3236 1
      processing_current_namespace = name;
d3240 1
a3240 1
      /* We need temp_name around because processing_current_namespace
d3242 1
a3242 1
      char *temp_name = alloca (strlen (previous_namespace)
d3244 1
a3244 1
      strcpy (temp_name, previous_namespace);
d3248 1
a3248 1
      processing_current_namespace = temp_name;
d3262 1
a3262 1
			(char *) processing_current_namespace,
d3269 3
a3271 3
	cp_add_using_directive (processing_current_namespace,
				strlen (previous_namespace),
				strlen (processing_current_namespace));
d3285 31
a3315 1
  processing_current_namespace = previous_namespace;
@


1.117
log
@* dwarf2read.c (dwarf2_add_member_fn, read_structure_scope):
Replace uses of DEPRECATED_STREQ and DEPRECATED_STREQN with calls
to strcmp and strncmp.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a3091 4
#ifdef FORTRAN_HACK
		  die->type = lookup_pointer_type (element_type);
		  return;
#else
a3092 1
#endif
a3128 4
#ifdef FORTRAN_HACK
		  die->type = lookup_pointer_type (element_type);
		  return;
#else
a3129 1
#endif
@


1.116
log
@	* dwarf2read.c (dwarf_info_offset, dwarf_abbrev_offset)
	(dwarf_line_offset, dwarf_pubnames_offset, dwarf_aranges_offset)
	(dwarf_loc_offset, dwarf_macinfo_offset, dwarf_str_offset)
	(dwarf_ranges_offset, dwarf_frame_offset, dwarf_eh_frame_offset):
	Delete.
	(dwarf2_read_section): Remove offset and size arguments.  Use
	bfd_get_section_size_before_reloc and sectp->filepos.
	(dwarf2_has_info): Clear section variables instead of offsets.
	(dwarf2_locate_sections): Don't initialize the deleted variables.
	(dwarf2_build_psymtabs): Update calls to dwarf2_read_section.
	(dwarf2_build_psymtabs_easy): Likewise.
	* dwarf2-frame.c (dwarf_frame_offset, dwarf_frame_size)
	(dwarf_eh_frame_offset, dwarf_eh_frame_size): Remove extern
	declarations.
	(dwarf2_read_section): Update prototype.
	(dwarf2_build_frame_info): Update calls to dwarf2_read_section.
	Use bfd_get_section_size_before_reloc instead of global size
	variables.
@
text
@d2607 1
a2607 1
      if (DEPRECATED_STREQ (fip->fnfieldlists[i].name, fieldname))
d2886 3
a2888 1
		      if (DEPRECATED_STREQN (fieldname, vptr_name, strlen (vptr_name) - 1)
@


1.115
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@a130 12
static file_ptr dwarf_info_offset;
static file_ptr dwarf_abbrev_offset;
static file_ptr dwarf_line_offset;
static file_ptr dwarf_pubnames_offset;
static file_ptr dwarf_aranges_offset;
static file_ptr dwarf_loc_offset;
static file_ptr dwarf_macinfo_offset;
static file_ptr dwarf_str_offset;
static file_ptr dwarf_ranges_offset;
file_ptr dwarf_frame_offset;
file_ptr dwarf_eh_frame_offset;

d688 1
a688 2
char *dwarf2_read_section (struct objfile *, file_ptr, unsigned int,
			   asection *);
d921 9
a929 9
  dwarf_info_offset = 0;
  dwarf_abbrev_offset = 0;
  dwarf_line_offset = 0;
  dwarf_str_offset = 0;
  dwarf_macinfo_offset = 0;
  dwarf_frame_offset = 0;
  dwarf_eh_frame_offset = 0;
  dwarf_ranges_offset = 0;
  dwarf_loc_offset = 0;
d932 1
a932 8
  if (dwarf_info_offset && dwarf_abbrev_offset)
    {
      return 1;
    }
  else
    {
      return 0;
    }
a943 1
      dwarf_info_offset = sectp->filepos;
a948 1
      dwarf_abbrev_offset = sectp->filepos;
a953 1
      dwarf_line_offset = sectp->filepos;
a958 1
      dwarf_pubnames_offset = sectp->filepos;
a963 1
      dwarf_aranges_offset = sectp->filepos;
a968 1
      dwarf_loc_offset = sectp->filepos;
a973 1
      dwarf_macinfo_offset = sectp->filepos;
a978 1
      dwarf_str_offset = sectp->filepos;
a983 1
      dwarf_frame_offset = sectp->filepos;
a991 1
          dwarf_eh_frame_offset = sectp->filepos;
a997 1
      dwarf_ranges_offset = sectp->filepos;
d1011 5
a1015 14
  dwarf_info_buffer = dwarf2_read_section (objfile,
					   dwarf_info_offset,
					   dwarf_info_size,
					   dwarf_info_section);
  dwarf_abbrev_buffer = dwarf2_read_section (objfile,
					     dwarf_abbrev_offset,
					     dwarf_abbrev_size,
					     dwarf_abbrev_section);

  if (dwarf_line_offset)
    dwarf_line_buffer = dwarf2_read_section (objfile,
					     dwarf_line_offset,
					     dwarf_line_size,
					     dwarf_line_section);
d1019 2
a1020 5
  if (dwarf_str_offset)
    dwarf_str_buffer = dwarf2_read_section (objfile,
					    dwarf_str_offset,
					    dwarf_str_size,
					    dwarf_str_section);
d1024 1
a1024 1
  if (dwarf_macinfo_offset)
a1025 2
                                                dwarf_macinfo_offset,
                                                dwarf_macinfo_size,
d1030 2
a1031 5
  if (dwarf_ranges_offset)
    dwarf_ranges_buffer = dwarf2_read_section (objfile,
					       dwarf_ranges_offset,
					       dwarf_ranges_size,
					       dwarf_ranges_section);
d1035 2
a1036 5
  if (dwarf_loc_offset)
    dwarf_loc_buffer = dwarf2_read_section (objfile,
					    dwarf_loc_offset,
					    dwarf_loc_size,
					    dwarf_loc_section);
a1076 2
					 dwarf_pubnames_offset,
					 dwarf_pubnames_size,
a1095 2
					dwarf_aranges_offset,
					dwarf_aranges_size,
d3805 1
a3805 2
dwarf2_read_section (struct objfile *objfile, file_ptr offset,
		     unsigned int size, asection *sectp)
d3809 1
d3820 5
a3824 7
  if ((bfd_seek (abfd, offset, SEEK_SET) != 0) ||
      (bfd_bread (buf, size, abfd) != size))
    {
      buf = NULL;
      error ("Dwarf Error: Can't read DWARF data from '%s'",
	     bfd_get_filename (abfd));
    }
@


1.114
log
@	* dwarf2read.c (offreg, basereg, isderef, frame_base_reg)
	(frame_base_offset): Delete.
	(read_func_scope): Delete call to decode_locdesc.
	(decode_locdesc): Update comments.  Don't set the removed variables.
	Complain for DW_OP_reg* not at the end.  Remove DW_OP_breg* and
	DW_OP_fbreg support.
@
text
@d2662 1
a2662 1
      if (STREQ (fip->fnfieldlists[i].name, fieldname))
d2941 1
a2941 1
		      if (STREQN (fieldname, vptr_name, strlen (vptr_name) - 1)
@


1.113
log
@	* dwarf2read.c (optimized_out, islocal): Remove.
	(decode_locdesc): Update comments.  Don't set optimized_out
	or islocal.
@
text
@a448 14
static int offreg;		/* Object's address is the sum of the
				   register specified by basereg, plus
				   the offset returned.  */
static int basereg;		/* See `offreg'.  */
static int isderef;		/* Value described by flags above is
				   the address of a pointer to the object.  */

/* DW_AT_frame_base values for the current function.
   frame_base_reg is -1 if DW_AT_frame_base is missing, otherwise it
   contains the register number for the frame register.
   frame_base_offset is the offset from the frame register to the
   virtual stack frame. */
static int frame_base_reg;
static CORE_ADDR frame_base_offset;
a2137 38
  /* Decode DW_AT_frame_base location descriptor if present, keep result
     for DW_OP_fbreg operands in decode_locdesc.  */
  frame_base_reg = -1;
  frame_base_offset = 0;
  attr = dwarf_attr (die, DW_AT_frame_base);
  if (attr)
    {
      CORE_ADDR addr;

      /* Support the .debug_loc offsets */
      if (attr_form_is_block (attr))
        {
          addr = decode_locdesc (DW_BLOCK (attr), cu);
        }
      else if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
        {
	  dwarf2_complex_location_expr_complaint ();
          addr = 0;
        }
      else
        {
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_frame_base", name);
          addr = 0;
        }
    
      if (isderef)
	dwarf2_unsupported_at_frame_base_complaint (name);
      else if (isreg)
	frame_base_reg = addr;
      else if (offreg)
	{
	  frame_base_reg = basereg;
	  frame_base_offset = addr;
	}
      else
	dwarf2_unsupported_at_frame_base_complaint (name);
    }

d2141 3
a2143 3
  /* If there was a location expression for DW_AT_frame_base above,
     record it.  We still need to decode it above because not all
     symbols use location expressions exclusively.  */
d6827 8
a6834 5
   FIXME: This is a kludge until we figure out a better
   way to handle the location descriptions.
   Gdb's design does not mesh well with the DWARF2 notion of a location
   computing interpreter, which is a shame because the flexibility goes unused.
   FIXME: Implement more operations as necessary.
d6837 1
a6837 1
   object is optimized out.  The return value is meaningless for that case.
a6844 6
   When the result is a base register offset, the global offreg flag is set
   and the register number is returned in basereg, otherwise it is cleared.

   When the DW_OP_fbreg operation is encountered without a corresponding
   DW_AT_frame_base attribute, we complain.

a6864 2
  offreg = 0;
  isderef = 0;
d6940 2
d6949 2
a6950 62
	  break;

	case DW_OP_breg0:
	case DW_OP_breg1:
	case DW_OP_breg2:
	case DW_OP_breg3:
	case DW_OP_breg4:
	case DW_OP_breg5:
	case DW_OP_breg6:
	case DW_OP_breg7:
	case DW_OP_breg8:
	case DW_OP_breg9:
	case DW_OP_breg10:
	case DW_OP_breg11:
	case DW_OP_breg12:
	case DW_OP_breg13:
	case DW_OP_breg14:
	case DW_OP_breg15:
	case DW_OP_breg16:
	case DW_OP_breg17:
	case DW_OP_breg18:
	case DW_OP_breg19:
	case DW_OP_breg20:
	case DW_OP_breg21:
	case DW_OP_breg22:
	case DW_OP_breg23:
	case DW_OP_breg24:
	case DW_OP_breg25:
	case DW_OP_breg26:
	case DW_OP_breg27:
	case DW_OP_breg28:
	case DW_OP_breg29:
	case DW_OP_breg30:
	case DW_OP_breg31:
	  offreg = 1;
	  basereg = op - DW_OP_breg0;
	  stack[++stacki] = read_signed_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_bregx:
	  offreg = 1;
	  basereg = read_unsigned_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  stack[++stacki] = read_signed_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  break;

	case DW_OP_fbreg:
	  stack[++stacki] = read_signed_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  if (frame_base_reg >= 0)
	    {
	      offreg = 1;
	      basereg = frame_base_reg;
	      stack[stacki] += frame_base_offset;
	    }
	  else
	    {
	      complaint (&symfile_complaints,
			 "DW_AT_frame_base missing for DW_OP_fbreg");
	    }
a7020 1
	  isderef = 1;
d7022 3
a7024 1
	     this using GDB's address_class enum.  */
d7034 2
@


1.112
log
@	* dwarf2read.c (struct dwarf2_cu): New type.

	(dwarf2_build_psymtabs_hard, psymtab_to_symtab_1): Create a
	dwarf2_cu structure to pass down.

	(scan_partial_symbols, add_partial_symbol, add_partial_namespace)
	(add_partial_enumeration, locate_pdi_sibling, process_die)
	(read_file_scope, read_func_scope)
	(read_lexical_block_scope, dwarf2_get_pc_bounds)
	(dwarf2_add_field, dwarf2_attach_fields_to_type)
	(dwarf2_add_member_fn, dwarf2_attach_fn_fields_to_type)
	(read_structure_scope, read_enumeration, read_array_type)
	(read_common_block, read_namespace, read_tag_pointer_type)
	(read_tag_ptr_to_member_type, read_tag_reference_type)
	(read_tag_const_type, read_tag_volatile_type, read_tag_string_type)
	(read_subroutine_type, read_typedef, read_base_type, read_comp_unit)
	(read_die_and_children, read_die_and_siblings, dwarf2_read_section)
	(dwarf2_read_abbrevs, dwarf2_lookup_abbrev, read_partial_die)
	(read_full_die. read_attribute_value, read_attribute)
	(read_address, dwarf_decode_line_header, dwarf_decode_lines)
	(var_decode_location, new_symbol, dwarf2_const_value, die_type)
	(die_containing_type, type_at_offset, tag_type_to_type)
	(read_type_die, dwarf_base_type, decode_locdesc, dwarf_decode_macros)
	(dwarf2_symbol_mark_computed): Accept and use a dwarf2_cu object.
@
text
@a445 2
static int optimized_out;	/* No ops in location in expression,
				   so object was optimized out.  */
a454 6
static int islocal;		/* Variable is at the returned offset
				   from the frame start, but there's
				   no identified frame pointer for
				   this function, so we can't say
				   which register it's relative to;
				   use LOC_LOCAL.  */
d6886 4
a6889 2
   object is optimized out. The global optimized_out flag is set for
   those, the return value is meaningless.
d6898 1
a6898 3
   DW_AT_frame_base attribute, the global islocal flag is set.
   Hopefully the machine dependent code knows how to set up a virtual
   frame pointer for the local references.
a6921 2
  islocal = 0;
  optimized_out = 1;
a6924 1
      optimized_out = 0;
a7064 1
	      islocal = 1;
@


1.111
log
@2003-11-07  Andrew Cagney  <cagney@@redhat.com>

	* top.c (print_gdb_version): Replace STREQ with strcmp.
	* valops.c (value_struct_elt_for_reference): Ditto.
	(value_struct_elt_for_reference): Ditto.
	* symtab.c (gdb_mangle_name): Ditto.
	(find_line_symtab): Ditto.
	* symmisc.c (maintenance_print_symbols): Ditto.
	* symfile.c (symbol_file_command): Ditto.
	* stabsread.c (define_symbol, read_type): Ditto.
	(cleanup_undefined_types, scan_file_globals): Ditto.
	* solib.c (solib_map_sections): Ditto.
	* solib-svr4.c (bfd_lookup_symbol): Ditto.
	* rs6000-tdep.c (skip_prologue): Ditto.
	* p-valprint.c (pascal_value_print): Ditto.
	(pascal_object_is_vtbl_ptr_type): Ditto.
	* objfiles.c (in_plt_section): Ditto.
	* minsyms.c (lookup_minimal_symbol): Ditto.
	(compact_minimal_symbols): Ditto.
	(find_solib_trampoline_target): Ditto.
	* mdebugread.c (parse_type): Ditto.
	* language.c (set_language_command): Ditto.
	(set_type_command, set_range_command): Ditto.
	* f-lang.c (add_common_block): Ditto.
	(add_common_block): Ditto.
	(find_first_common_named): Ditto.
	(patch_all_commons_by_name): Ditto.
	* elfread.c (elf_locate_sections): Ditto.
	(elf_locate_sections): Ditto.
	(elfstab_offset_sections): Ditto.
	* dwarf2read.c (dwarf2_locate_sections): Ditto.
	* dbxread.c (add_old_header_file): Ditto.
	(find_corresponding_bincl_psymtab): Ditto.
	(read_dbx_symtab, process_one_symbol): Ditto.
	* coffread.c (patch_opaque_types): Ditto.
	* cli/cli-decode.c (delete_cmd): Ditto.
	* cli/cli-cmds.c (pwd_command, list_command): Ditto.
	* c-typeprint.c (c_type_print_base): Ditto.
	* breakpoint.c (bpstat_stop_status): Ditto.
	(clear_command, breakpoint_re_set_one): Ditto.
@
text
@d233 14
d695 2
a696 3
static char *scan_partial_symbols (char *, struct objfile *,
				   CORE_ADDR *, CORE_ADDR *,
				   const struct comp_unit_head *,
d699 1
a699 2
static void add_partial_symbol (struct partial_die_info *, struct objfile *,
				const struct comp_unit_head *,
a703 1
				    struct objfile *objfile,
d705 1
a705 1
				    const struct comp_unit_head *cu_header,
d710 1
a710 2
				      struct objfile *objfile,
				      const struct comp_unit_head *cu_header,
d716 1
a716 1
				 const struct comp_unit_head *cu_header);
d725 1
a725 1
static void dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header);
d730 1
a730 1
                                         const struct comp_unit_head *cu_header);
d733 1
a733 2
			       bfd *, char *,
			       const struct comp_unit_head *);
d736 1
a736 1
			    const struct comp_unit_head *, int *);
d739 1
a739 1
			     bfd *, char *, const struct comp_unit_head *);
d742 1
a742 1
			     bfd *, char *, const struct comp_unit_head *);
d754 1
a754 1
static CORE_ADDR read_address (bfd *, char *ptr, const struct comp_unit_head *,
d784 1
a784 2
                             bfd *abfd,
                             const struct comp_unit_head *cu_header));
d787 1
a787 1
				const struct comp_unit_head *);
d792 1
a792 1
				  struct objfile *, const struct comp_unit_head *);
d795 1
a795 1
				struct objfile *, const struct comp_unit_head *);
d801 1
a801 2
static struct type *die_type (struct die_info *, struct objfile *,
			      const struct comp_unit_head *);
d803 2
a804 2
static struct type *die_containing_type (struct die_info *, struct objfile *,
					 const struct comp_unit_head *);
d810 1
a810 2
static struct type *tag_type_to_type (struct die_info *, struct objfile *,
				      const struct comp_unit_head *);
d812 1
a812 2
static void read_type_die (struct die_info *, struct objfile *,
			   const struct comp_unit_head *);
d814 1
a814 2
static void read_typedef (struct die_info *, struct objfile *,
			  const struct comp_unit_head *);
d816 1
a816 1
static void read_base_type (struct die_info *, struct objfile *);
d818 1
a818 2
static void read_file_scope (struct die_info *, struct objfile *,
			     const struct comp_unit_head *);
d820 1
a820 2
static void read_func_scope (struct die_info *, struct objfile *,
			     const struct comp_unit_head *);
d822 1
a822 2
static void read_lexical_block_scope (struct die_info *, struct objfile *,
				      const struct comp_unit_head *);
d825 1
a825 2
				 CORE_ADDR *, CORE_ADDR *, struct objfile *,
				 const struct comp_unit_head *);
d828 1
a828 1
			      struct objfile *, const struct comp_unit_head *);
d831 1
a831 1
					  struct type *, struct objfile *);
d835 1
a835 2
				  struct objfile *objfile,
				  const struct comp_unit_head *);
d838 1
a838 1
					     struct type *, struct objfile *);
d840 1
a840 2
static void read_structure_scope (struct die_info *, struct objfile *,
				  const struct comp_unit_head *);
d842 1
a842 2
static void read_common_block (struct die_info *, struct objfile *,
			       const struct comp_unit_head *);
d844 1
a844 2
static void read_namespace (struct die_info *die, struct objfile *objfile,
			    const struct comp_unit_head *cu_header);
d846 1
a846 2
static void read_enumeration (struct die_info *, struct objfile *,
			      const struct comp_unit_head *);
d848 1
a848 1
static struct type *dwarf_base_type (int, int, struct objfile *);
d850 1
a850 2
static CORE_ADDR decode_locdesc (struct dwarf_block *, struct objfile *,
				 const struct comp_unit_head *);
d852 1
a852 2
static void read_array_type (struct die_info *, struct objfile *,
			     const struct comp_unit_head *);
d854 1
a854 2
static void read_tag_pointer_type (struct die_info *, struct objfile *,
				   const struct comp_unit_head *);
d856 2
a857 2
static void read_tag_ptr_to_member_type (struct die_info *, struct objfile *,
					 const struct comp_unit_head *);
d859 1
a859 2
static void read_tag_reference_type (struct die_info *, struct objfile *,
				     const struct comp_unit_head *);
d861 1
a861 2
static void read_tag_const_type (struct die_info *, struct objfile *,
				 const struct comp_unit_head *);
d863 1
a863 2
static void read_tag_volatile_type (struct die_info *, struct objfile *,
				    const struct comp_unit_head *);
d865 1
a865 1
static void read_tag_string_type (struct die_info *, struct objfile *);
d867 1
a867 2
static void read_subroutine_type (struct die_info *, struct objfile *,
				  const struct comp_unit_head *);
d869 1
a869 2
static struct die_info *read_comp_unit (char *, bfd *,
                                        const struct comp_unit_head *);
d872 1
a872 1
					       const struct comp_unit_head *,
d877 1
a877 1
					       const struct comp_unit_head *,
d885 1
a885 2
static void process_die (struct die_info *, struct objfile *,
			 const struct comp_unit_head *);
d942 1
a942 2
                                 char *, bfd *, const struct comp_unit_head *,
                                 struct objfile *);
d948 1
a948 2
			     const struct comp_unit_head *,
			     struct objfile *objfile);
d1270 1
a1270 1
      struct comp_unit_head cu_header;
a1271 1
      info_ptr = read_comp_unit_head (&cu_header, info_ptr, abfd);
d1273 4
a1276 1
      if (cu_header.version != 2)
d1278 1
a1278 1
	  error ("Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]", cu_header.version, 2, bfd_get_filename (abfd));
d1281 1
a1281 1
      if (cu_header.abbrev_offset >= dwarf_abbrev_size)
d1284 1
a1284 1
		 (long) cu_header.abbrev_offset,
d1289 1
a1289 1
      if (beg_of_comp_unit + cu_header.length + cu_header.initial_length_size
d1293 1
a1293 1
		 (long) cu_header.length,
d1299 3
a1301 3
      cu_header.offset = beg_of_comp_unit - dwarf_info_buffer;
      cu_header.first_die_ptr = info_ptr;
      cu_header.cu_head_ptr = beg_of_comp_unit;
d1304 2
a1305 2
      dwarf2_read_abbrevs (abfd, &cu_header);
      make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
d1309 1
a1309 1
				   &cu_header);
d1351 2
a1352 2
	  info_ptr = scan_partial_symbols (info_ptr, objfile, &lowpc, &highpc,
					   &cu_header, NULL);
d1381 2
a1382 2
      info_ptr = beg_of_comp_unit + cu_header.length 
                                  + cu_header.initial_length_size;
d1395 2
a1396 3
scan_partial_symbols (char *info_ptr, struct objfile *objfile,
		      CORE_ADDR *lowpc, CORE_ADDR *highpc,
		      const struct comp_unit_head *cu_header,
d1399 1
d1413 1
a1413 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu_header);
d1437 1
a1437 1
		      add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1448 1
a1448 1
		  add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1454 1
a1454 2
		  info_ptr = add_partial_enumeration (&pdi, info_ptr,
						      objfile, cu_header,
d1462 1
a1462 1
	      add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1470 2
a1471 3
	      info_ptr = add_partial_namespace (&pdi, info_ptr, objfile,
						lowpc, highpc, cu_header,
						namespace);
d1491 1
a1491 1
	  info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu_header);
d1498 2
a1499 3
add_partial_symbol (struct partial_die_info *pdi, struct objfile *objfile,
		    const struct comp_unit_head *cu_header,
		    const char *namespace)
d1501 1
d1546 1
a1546 1
	    addr = decode_locdesc (pdi->locdesc, objfile, cu_header);
d1559 1
a1559 1
	  addr = decode_locdesc (pdi->locdesc, objfile, cu_header);
a1627 1
		       struct objfile *objfile,
d1629 1
a1629 2
		       const struct comp_unit_head *cu_header,
		       const char *namespace)
d1631 1
a1631 2
  /* Calculate the full name of the namespace that we just entered.  */

d1635 2
d1657 1
a1657 3
    info_ptr = scan_partial_symbols (info_ptr, objfile,
				     lowpc, highpc,
				     cu_header, full_name);
d1666 1
a1666 3
			 struct objfile *objfile,
			 const struct comp_unit_head *cu_header,
			 const char *namespace)
d1668 1
d1673 1
a1673 1
    add_partial_symbol (enum_pdi, objfile, cu_header, namespace);
d1677 1
a1677 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu_header);
d1683 1
a1683 1
	add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1694 1
a1694 1
		    bfd *abfd, const struct comp_unit_head *cu_header)
d1714 1
a1714 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu_header);
d1719 1
a1719 1
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu_header);
d1757 1
a1757 1
  struct comp_unit_head cu_header;
d1792 2
d1795 1
a1795 1
  info_ptr = read_comp_unit_head (&cu_header, info_ptr, abfd);
d1798 2
a1799 2
  dwarf2_read_abbrevs (abfd, &cu_header);
  make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
d1801 1
a1801 1
  dies = read_comp_unit (info_ptr, abfd, &cu_header);
d1811 2
a1812 2
  cu_header.base_known = 0;
  cu_header.base_address = 0;
d1817 2
a1818 2
      cu_header.base_address = DW_ADDR (attr);
      cu_header.base_known = 1;
d1825 2
a1826 2
	  cu_header.base_address = DW_ADDR (attr);
	  cu_header.base_known = 1;
d1831 1
a1831 1
  process_die (dies, objfile, &cu_header);
d1833 1
a1833 1
  if (!dwarf2_get_pc_bounds (dies, &lowpc, &highpc, objfile, &cu_header))
d1848 1
a1848 2
		  if (dwarf2_get_pc_bounds (child_die, &low, &high,
					    objfile, &cu_header))
d1876 1
a1876 2
process_die (struct die_info *die, struct objfile *objfile,
	     const struct comp_unit_head *cu_header)
d1883 1
a1883 1
      read_file_scope (die, objfile, cu_header);
d1886 2
a1887 2
      read_subroutine_type (die, objfile, cu_header);
      read_func_scope (die, objfile, cu_header);
d1897 1
a1897 1
      read_lexical_block_scope (die, objfile, cu_header);
d1902 1
a1902 1
      read_structure_scope (die, objfile, cu_header);
d1905 1
a1905 1
      read_enumeration (die, objfile, cu_header);
d1908 1
a1908 1
      read_subroutine_type (die, objfile, cu_header);
d1911 1
a1911 1
      read_array_type (die, objfile, cu_header);
d1914 1
a1914 1
      read_tag_pointer_type (die, objfile, cu_header);
d1917 1
a1917 1
      read_tag_ptr_to_member_type (die, objfile, cu_header);
d1920 1
a1920 1
      read_tag_reference_type (die, objfile, cu_header);
d1923 1
a1923 1
      read_tag_string_type (die, objfile);
d1926 1
a1926 1
      read_base_type (die, objfile);
d1930 1
a1930 1
	  new_symbol (die, die->type, objfile, cu_header);
d1934 1
a1934 1
      read_common_block (die, objfile, cu_header);
d1944 1
a1944 1
      read_namespace (die, objfile, cu_header);
d1962 1
a1962 1
      new_symbol (die, NULL, objfile, cu_header);
d1974 1
a1974 2
read_file_scope (struct die_info *die, struct objfile *objfile,
		 const struct comp_unit_head *cu_header)
d1976 2
d1988 1
a1988 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cu_header))
d1999 1
a1999 2
		  if (dwarf2_get_pc_bounds (child_die, &low, &high,
					    objfile, cu_header))
d2075 1
a2075 1
	  process_die (child_die, objfile, cu_header);
d2085 1
a2085 2
      line_header = dwarf_decode_line_header (line_offset,
                                              abfd, cu_header);
d2090 1
a2090 1
          dwarf_decode_lines (line_header, comp_dir, abfd, cu_header);
d2103 1
a2103 1
                           comp_dir, abfd, cu_header, objfile);
d2130 1
a2130 2
read_func_scope (struct die_info *die, struct objfile *objfile,
		 const struct comp_unit_head *cu_header)
d2132 1
d2144 1
a2144 1
  if (name == NULL || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cu_header))
d2172 1
a2172 1
          addr = decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
d2199 1
a2199 1
  new->name = new_symbol (die, die->type, objfile, cu_header);
d2205 1
a2205 1
    dwarf2_symbol_mark_computed (attr, new->name, cu_header, objfile);
d2214 1
a2214 1
	  process_die (child_die, objfile, cu_header);
d2241 1
a2241 2
read_lexical_block_scope (struct die_info *die, struct objfile *objfile,
			  const struct comp_unit_head *cu_header)
d2243 1
d2253 1
a2253 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cu_header))
d2264 1
a2264 1
	  process_die (child_die, objfile, cu_header);
d2283 1
a2283 2
		      CORE_ADDR *highpc, struct objfile *objfile,
		      const struct comp_unit_head *cu_header)
d2285 2
a2320 1
	  unsigned int i;
d2338 1
a2338 1
	  marker = read_address (obfd, buffer, cu_header, &dummy);
d2343 1
a2343 2
	      base = read_address (obfd, buffer + addr_size,
				   cu_header, &dummy);
d2355 1
a2355 2
	      range_beginning = read_address (obfd, buffer,
					      cu_header, &dummy);
d2357 1
a2357 1
	      range_end = read_address (obfd, buffer, cu_header, &dummy);
d2373 1
a2373 2
		  base = read_address (obfd, buffer + addr_size,
				       cu_header, &dummy);
d2441 3
a2443 3
		  struct objfile *objfile,
		  const struct comp_unit_head *cu_header)
{
d2482 1
a2482 1
      fp->type = die_type (die, objfile, cu_header);
d2502 1
a2502 1
	    decode_locdesc (DW_BLOCK (attr), objfile, cu_header) * bits_per_byte;
d2588 1
a2588 1
      FIELD_TYPE (*fp) = die_type (die, objfile, cu_header);
d2597 1
a2597 1
	FIELD_BITPOS (*fp) = (decode_locdesc (DW_BLOCK (attr), objfile, cu_header)
d2601 1
a2601 1
      FIELD_TYPE (*fp) = die_type (die, objfile, cu_header);
d2611 1
a2611 1
			      struct objfile *objfile)
d2698 1
a2698 2
		      struct type *type, struct objfile *objfile,
		      const struct comp_unit_head *cu_header)
d2700 1
a2762 1
      struct type *return_type = TYPE_TARGET_TYPE (die->type);
d2788 1
a2788 1
    fnp->fcontext = die_containing_type (die, objfile, cu_header);
d2820 1
a2820 1
          fnp->voffset = decode_locdesc (DW_BLOCK (attr), objfile, cu_header) + 2;
d2838 1
a2838 1
				 struct objfile *objfile)
d2885 1
a2885 2
read_structure_scope (struct die_info *die, struct objfile *objfile,
		      const struct comp_unit_head *cu_header)
d2887 1
d2952 1
a2952 1
	      dwarf2_add_field (&fi, child_die, objfile, cu_header);
d2957 2
a2958 2
	      process_die (child_die, objfile, cu_header);
	      dwarf2_add_member_fn (&fi, child_die, type, objfile, cu_header);
d2963 1
a2963 1
	      dwarf2_add_field (&fi, child_die, objfile, cu_header);
d2967 1
a2967 1
	      process_die (child_die, objfile, cu_header);
d2974 1
a2974 1
	dwarf2_attach_fields_to_type (&fi, type, objfile);
d2977 1
a2977 1
	  dwarf2_attach_fn_fields_to_type (&fi, type, objfile);
d2985 1
a2985 1
	      struct type *t = die_containing_type (die, objfile, cu_header);
d3023 1
a3023 1
      new_symbol (die, type, objfile, cu_header);
d3044 1
a3044 2
read_enumeration (struct die_info *die, struct objfile *objfile,
		  const struct comp_unit_head *cu_header)
d3046 1
d3085 1
a3085 1
	      process_die (child_die, objfile, cu_header);
d3092 1
a3092 1
		  sym = new_symbol (child_die, type, objfile, cu_header);
d3130 1
a3130 1
  new_symbol (die, type, objfile, cu_header);
d3138 1
a3138 2
read_array_type (struct die_info *die, struct objfile *objfile,
		 const struct comp_unit_head *cu_header)
d3140 1
d3155 1
a3155 1
  element_type = die_type (die, objfile, cu_header);
d3184 1
a3184 1
	  index_type = die_type (child_die, objfile, cu_header);
d3294 1
a3294 2
read_common_block (struct die_info *die, struct objfile *objfile,
		   const struct comp_unit_head *cu_header)
d3307 1
a3307 1
          base = decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
d3324 1
a3324 1
	  sym = new_symbol (child_die, NULL, objfile, cu_header);
d3329 1
a3329 1
		base + decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
d3340 1
a3340 2
read_namespace (struct die_info *die, struct objfile *objfile,
		const struct comp_unit_head *cu_header)
d3342 1
d3399 1
a3399 1
      new_symbol (die, type, objfile, cu_header);
d3413 1
a3413 1
	  process_die (child_die, objfile, cu_header);
d3425 1
a3425 2
read_tag_pointer_type (struct die_info *die, struct objfile *objfile,
		       const struct comp_unit_head *cu_header)
d3427 1
d3438 1
a3438 1
  type = lookup_pointer_type (die_type (die, objfile, cu_header));
d3482 1
a3482 2
read_tag_ptr_to_member_type (struct die_info *die, struct objfile *objfile,
			     const struct comp_unit_head *cu_header)
d3484 1
d3495 2
a3496 2
  to_type = die_type (die, objfile, cu_header);
  domain = die_containing_type (die, objfile, cu_header);
d3506 1
a3506 2
read_tag_reference_type (struct die_info *die, struct objfile *objfile,
			 const struct comp_unit_head *cu_header)
d3508 1
d3517 1
a3517 1
  type = lookup_reference_type (die_type (die, objfile, cu_header));
d3531 1
a3531 2
read_tag_const_type (struct die_info *die, struct objfile *objfile,
		     const struct comp_unit_head *cu_header)
d3540 1
a3540 1
  base_type = die_type (die, objfile, cu_header);
d3545 1
a3545 2
read_tag_volatile_type (struct die_info *die, struct objfile *objfile,
			const struct comp_unit_head *cu_header)
d3554 1
a3554 1
  base_type = die_type (die, objfile, cu_header);
d3564 1
a3564 1
read_tag_string_type (struct die_info *die, struct objfile *objfile)
d3566 1
d3622 1
a3622 2
read_subroutine_type (struct die_info *die, struct objfile *objfile,
		      const struct comp_unit_head *cu_header)
d3633 1
a3633 1
  type = die_type (die, objfile, cu_header);
d3681 1
a3681 2
	      TYPE_FIELD_TYPE (ftype, iparams) = die_type (child_die, objfile,
							   cu_header);
d3692 1
a3692 2
read_typedef (struct die_info *die, struct objfile *objfile,
	      const struct comp_unit_head *cu_header)
d3694 1
d3706 1
a3706 1
      TYPE_TARGET_TYPE (die->type) = die_type (die, objfile, cu_header);
d3714 1
a3714 1
read_base_type (struct die_info *die, struct objfile *objfile)
d3716 1
d3790 1
a3790 1
      type = dwarf_base_type (encoding, size, objfile);
d3798 1
a3798 2
read_comp_unit (char *info_ptr, bfd *abfd,
		const struct comp_unit_head *cu_header)
d3804 1
a3804 1
  return read_die_and_children (info_ptr, abfd, cu_header, &info_ptr, NULL);
d3815 1
a3815 1
		       const struct comp_unit_head *cu_header,
d3823 1
a3823 1
  cur_ptr = read_full_die (&die, abfd, info_ptr, cu_header, &has_children);
d3828 1
a3828 1
      die->child = read_die_and_siblings (cur_ptr, abfd, cu_header,
d3848 1
a3848 1
		       const struct comp_unit_head *cu_header,
d3861 1
a3861 2
	= read_die_and_children (cur_ptr, abfd, cu_header,
				 &cur_ptr, parent);
d3951 1
a3951 1
dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header)
d3953 1
d4017 1
a4017 1
      if (dwarf2_lookup_abbrev (abbrev_number, cu_header) != NULL)
d4051 1
a4051 1
dwarf2_lookup_abbrev (unsigned int number, const struct comp_unit_head *cu_header)
d4053 1
d4074 1
a4074 1
		  char *info_ptr, const struct comp_unit_head *cu_header)
d4090 1
a4090 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
d4103 1
a4103 2
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], abfd,
				 info_ptr, cu_header);
a4179 1
      int dummy;
d4182 1
a4182 1
      read_partial_die (&spec_die, abfd, spec_ptr, cu_header);
d4216 1
a4216 1
	       const struct comp_unit_head *cu_header, int *has_children)
d4236 1
a4236 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
d4256 1
a4256 1
				 abfd, info_ptr, cu_header);
d4268 2
a4269 2
		bfd *abfd, char *info_ptr,
		const struct comp_unit_head *cu_header)
d4271 1
d4280 1
a4280 1
      DW_ADDR (attr) = read_address (abfd, info_ptr, cu_header, &bytes_read);
d4375 1
a4375 1
      info_ptr = read_attribute_value (attr, form, abfd, info_ptr, cu_header);
d4389 1
a4389 2
		bfd *abfd, char *info_ptr,
		const struct comp_unit_head *cu_header)
d4392 1
a4392 1
  return read_attribute_value (attr, abbrev->form, abfd, info_ptr, cu_header);
d4440 1
a4440 2
read_address (bfd *abfd, char *buf, const struct comp_unit_head *cu_header,
	      int *bytes_read)
d4442 1
d4874 1
a4874 1
                          const struct comp_unit_head *cu_header)
d4915 1
a4915 1
  lh->header_length = read_offset (abfd, line_ptr, cu_header, &bytes_read);
d5023 1
a5023 1
		    const struct comp_unit_head *cu_header)
d5027 1
a5027 2
  unsigned int i, bytes_read;
  char *cur_dir;
d5090 1
a5090 1
		  address = read_address (abfd, line_ptr, cu_header, &bytes_read);
d5234 1
a5234 2
		     struct objfile *objfile,
		     const struct comp_unit_head *cu_header)
d5236 3
d5269 1
a5269 2
	read_address (objfile->obfd, DW_BLOCK (attr)->data + 1, cu_header,
		      &dummy);
d5284 1
a5284 1
  dwarf2_symbol_mark_computed (attr, sym, cu_header, objfile);
d5295 1
a5295 2
new_symbol (struct die_info *die, struct type *type, struct objfile *objfile,
	    const struct comp_unit_head *cu_header)
d5297 1
a5301 1
  CORE_ADDR addr = 0;
d5326 1
a5326 1
	SYMBOL_TYPE (sym) = die_type (die, objfile, cu_header);
d5368 1
a5368 1
	      dwarf2_const_value (attr, sym, objfile, cu_header);
d5379 1
a5379 1
	      var_decode_location (attr, sym, objfile, cu_header);
d5407 1
a5407 1
	      var_decode_location (attr, sym, objfile, cu_header);
d5415 1
a5415 1
	      dwarf2_const_value (attr, sym, objfile, cu_header);
d5460 1
a5460 1
	      dwarf2_const_value (attr, sym, objfile, cu_header);
d5485 1
a5485 2
		    struct objfile *objfile,
		    const struct comp_unit_head *cu_header)
d5487 2
d5587 1
a5587 2
die_type (struct die_info *die, struct objfile *objfile,
	  const struct comp_unit_head *cu_header)
d5598 1
a5598 1
      return dwarf2_fundamental_type (objfile, FT_VOID);
d5607 1
a5607 1
			  ref, objfile->name);
d5611 1
a5611 1
  type = tag_type_to_type (type_die, objfile, cu_header);
d5616 1
a5616 1
		      objfile->name);
d5625 1
a5625 2
die_containing_type (struct die_info *die, struct objfile *objfile,
		     const struct comp_unit_head *cu_header)
d5640 1
a5640 1
			  objfile->name);
d5643 1
a5643 1
      type = tag_type_to_type (type_die, objfile, cu_header);
d5650 1
a5650 1
		      objfile->name);
d5657 1
a5657 1
type_at_offset (unsigned int offset, struct objfile *objfile)
d5668 1
a5668 1
  type = tag_type_to_type (die, objfile);
d5674 1
a5674 2
tag_type_to_type (struct die_info *die, struct objfile *objfile,
		  const struct comp_unit_head *cu_header)
d5682 1
a5682 1
      read_type_die (die, objfile, cu_header);
d5687 1
a5687 1
			  objfile->name);
d5694 1
a5694 2
read_type_die (struct die_info *die, struct objfile *objfile,
	       const struct comp_unit_head *cu_header)
d5701 1
a5701 1
      read_structure_scope (die, objfile, cu_header);
d5704 1
a5704 1
      read_enumeration (die, objfile, cu_header);
d5708 1
a5708 1
      read_subroutine_type (die, objfile, cu_header);
d5711 1
a5711 1
      read_array_type (die, objfile, cu_header);
d5714 1
a5714 1
      read_tag_pointer_type (die, objfile, cu_header);
d5717 1
a5717 1
      read_tag_ptr_to_member_type (die, objfile, cu_header);
d5720 1
a5720 1
      read_tag_reference_type (die, objfile, cu_header);
d5723 1
a5723 1
      read_tag_const_type (die, objfile, cu_header);
d5726 1
a5726 1
      read_tag_volatile_type (die, objfile, cu_header);
d5729 1
a5729 1
      read_tag_string_type (die, objfile);
d5732 1
a5732 1
      read_typedef (die, objfile, cu_header);
d5735 1
a5735 1
      read_base_type (die, objfile);
d5745 1
a5745 1
dwarf_base_type (int encoding, int size, struct objfile *objfile)
d5747 2
d6912 1
a6912 2
decode_locdesc (struct dwarf_block *blk, struct objfile *objfile,
		const struct comp_unit_head *cu_header)
d6914 2
d7082 1
a7082 1
					  cu_header, &bytes_read);
d7454 1
a7454 2
                     const struct comp_unit_head *cu_header,
                     struct objfile *objfile)
d7530 1
a7530 1
                                             lh, objfile);
d7601 1
a7601 2
			     const struct comp_unit_head *cu_header,
			     struct objfile *objfile)
d7607 1
a7607 1
      baton = obstack_alloc (&objfile->symbol_obstack,
d7609 1
a7609 1
      baton->objfile = objfile;
d7615 2
a7616 2
      baton->base_address = cu_header->base_address;
      if (cu_header->base_known == 0)
d7627 1
a7627 1
      baton = obstack_alloc (&objfile->symbol_obstack,
d7629 1
a7629 1
      baton->objfile = objfile;
@


1.110
log
@* dwarf2read.c (struct die_info): Doc fix.
@
text
@d1000 1
a1000 1
  if (STREQ (sectp->name, INFO_SECTION))
d1006 1
a1006 1
  else if (STREQ (sectp->name, ABBREV_SECTION))
d1012 1
a1012 1
  else if (STREQ (sectp->name, LINE_SECTION))
d1018 1
a1018 1
  else if (STREQ (sectp->name, PUBNAMES_SECTION))
d1024 1
a1024 1
  else if (STREQ (sectp->name, ARANGES_SECTION))
d1030 1
a1030 1
  else if (STREQ (sectp->name, LOC_SECTION))
d1036 1
a1036 1
  else if (STREQ (sectp->name, MACINFO_SECTION))
d1042 1
a1042 1
  else if (STREQ (sectp->name, STR_SECTION))
d1048 1
a1048 1
  else if (STREQ (sectp->name, FRAME_SECTION))
d1054 1
a1054 1
  else if (STREQ (sectp->name, EH_FRAME_SECTION))
d1064 1
a1064 1
  else if (STREQ (sectp->name, RANGES_SECTION))
@


1.109
log
@2003-09-30  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (struct die_info): Add 'parent' field; replace
	'has_children' and 'next' by 'child' and 'sibling'.
	(read_comp_unit): Rework algorithm, breaking body into
	read_die_and_children and read_die_and_siblings.
	(read_die_and_children, read_die_and_siblings): New.
	(read_full_die): Add 'has_children' argument; set it instead of
	the die's 'has_children' field.  Minor formatting cleanup.
	(free_die_list): Use die->child and die->sibling instead of
	die->next.
	(dump_die_list): Ditto.
	(sibling_die): Use die->sibling.
	(psymtab_to_symtab_1): Use die's 'child' field in place of its
	'has_children' and 'next' fields.
	(process_die, read_file_scope, read_func_scope)
	(read_lexical_block_scope, read_structure_scope)
	(read_enumeration, read_array_type, read_common_block)
	(read_namespace, read_subroutine_type, dump_die): Ditto.
@
text
@d323 6
d332 1
@


1.108
log
@* dwarf2read.c (read_array_type): When building the type for an
array of unspecified length, make sure to choose the upper bound
so that the array's total length comes out to be zero --- that's
how we represent such arrays.
@
text
@a317 1
    unsigned short has_children;	/* Does the die have children */
d323 3
a325 1
    struct die_info *next;	/* Next die in linked list */
d720 1
a720 1
			    const struct comp_unit_head *);
d877 10
d1850 1
a1850 1
      if (dies->has_children)
d1852 1
a1852 1
	  child_die = dies->next;
d1972 1
a1972 1
      gdb_assert (!die->has_children);
d2002 1
a2002 1
      if (die->has_children)
d2004 1
a2004 1
	  child_die = die->next;
d2083 1
a2083 1
  if (die->has_children)
d2085 1
a2085 1
      child_die = die->next;
d2223 1
a2223 1
  if (die->has_children)
d2225 1
a2225 1
      child_die = die->next;
d2273 1
a2273 1
  if (die->has_children)
d2275 1
a2275 1
      child_die = die->next;
d2950 1
a2950 1
  if (die->has_children && ! die_is_declaration (die))
d2958 1
a2958 1
      child_die = die->next;
d3096 1
a3096 1
  if (die->has_children)
d3098 1
a3098 1
      child_die = die->next;
d3177 1
a3177 1
  if (die->has_children == 0)
d3186 1
a3186 1
  child_die = die->next;
d3338 1
a3338 1
  if (die->has_children)
d3340 1
a3340 1
      child_die = die->next;
d3426 1
a3426 1
  if (die->has_children)
d3428 1
a3428 1
      struct die_info *child_die = die->next;
d3663 1
a3663 1
  if (die->has_children)
d3672 1
a3672 1
      child_die = die->next;
d3687 1
a3687 1
      child_die = die->next;
a3821 4
  struct die_info *first_die, *last_die, *die;
  char *cur_ptr;
  int nesting_level;

d3826 51
d3878 3
a3880 3
  nesting_level = 0;
  first_die = last_die = NULL;
  do
d3882 5
a3886 2
      cur_ptr = read_full_die (&die, abfd, cur_ptr, cu_header);
      if (die->has_children)
d3888 1
a3888 1
	  nesting_level++;
d3890 1
a3890 1
      if (die->tag == 0)
d3892 1
a3892 1
	  nesting_level--;
d3895 1
a3895 6
      die->next = NULL;

      /* Enter die in reference hash table */
      store_in_ref_table (die->offset, die);

      if (!first_die)
d3897 2
a3898 1
	  first_die = last_die = die;
d3902 1
a3902 2
	  last_die->next = die;
	  last_die = die;
a3904 2
  while (nesting_level > 0);
  return first_die;
d3917 3
a3919 1
      next = die->next;
d4232 4
a4235 2
/* Read the die from the .debug_info section buffer.  And set diep to
   point to a newly allocated die with its information.  */
d4239 1
a4239 1
	       const struct comp_unit_head *cu_header)
d4255 1
d4262 3
a4264 2
      error ("Dwarf Error: could not find abbrev number %d [in module %s]", abbrev_number, 
		      bfd_get_filename (abfd));
a4268 1
  die->has_children = abbrev->has_children;
d4283 1
d5885 1
a5885 37
  int nesting_level = 0;

  if (!die->has_children)
    {
      if (die->next && (die->next->tag == 0))
	{
	  return NULL;
	}
      else
	{
	  return die->next;
	}
    }
  else
    {
      do
	{
	  if (die->has_children)
	    {
	      nesting_level++;
	    }
	  if (die->tag == 0)
	    {
	      nesting_level--;
	    }
	  die = die->next;
	}
      while (nesting_level);
      if (die && (die->tag == 0))
	{
	  return NULL;
	}
      else
	{
	  return die;
	}
    }
d6754 1
a6754 1
	   dwarf_bool_name (die->has_children));
d6817 4
a6820 1
      die = die->next;
@


1.107
log
@2003-09-20  Andrew Cagney  <cagney@@redhat.com>

	* breakpoint.c: Eliminate ARGSUSED.
	* buildsym.c, cli/cli-cmds.c, cli/cli-script.c: Ditto.
	* coffread.c, corelow.c, dwarf2read.c, event-top.c: Ditto.
	* exec.c, gcore.c, hpux-thread.c, infcmd.c, inflow.c: Ditto.
	* infrun.c, inftarg.c, maint.c, ocd.c, printcmd.c: Ditto.
	* procfs.c, regcache.c, remote-rdi.c, remote-sds.c: Ditto.
	* remote.c, sol-thread.c, source.c, stabsread.c: Ditto.
	* stack.c, symfile.c, target.c, top.c, typeprint.c: Ditto.
	* utils.c, v850ice.c, valprint.c, values.c, win32-nat.c: Ditto.
	* wince.c, remote-vx.c: Ditto.
@
text
@d3240 8
a3247 2
		     length for now.  */
		  high = -1;
@


1.106
log
@2003-09-16  Andrew Cagney  <cagney@@redhat.com>

	* buildsym.c: Remove more occurances of "register".
	* coffread.c, dbxread.c, dcache.c, dwarf2read.c: Ditto.
	* environ.c, eval.c, f-valprint.c, findvar.c: Ditto.
	* gdbtypes.c, gnu-v2-abi.c, h8300-tdep.c, hppa-tdep.c: Ditto.
	* infcmd.c, mdebugread.c, minsyms.c, mips-tdep.c: Ditto.
	* printcmd.c, remote-vx.c, sh-stub.c, sh-tdep.c: Ditto.
	* sh64-tdep.c, source.c, stabsread.c, stack.c: Ditto.
	* standalone.c, symfile.c, symmisc.c, symtab.c: Ditto.
	* utils.c, valops.c, values.c, xcoffread.c: Ditto.
@
text
@a3983 1
/* ARGSUSED */
a7165 1
/* ARGSUSED */
@


1.105
log
@	* dwarf2read.c (dwarf2_get_pc_bounds): Complain if offset
	associated with DW_AT_ranges attribute is out of bounds.
@
text
@d5915 1
a5915 1
dwarf_tag_name (register unsigned tag)
d6047 1
a6047 1
dwarf_attr_name (register unsigned attr)
d6238 1
a6238 1
dwarf_form_name (register unsigned form)
d6292 1
a6292 1
dwarf_stack_op_name (register unsigned op)
d6615 1
a6615 1
dwarf_type_encoding_name (register unsigned enc)
d6646 1
a6646 1
dwarf_cfi_name (register unsigned cfi_opc)
@


1.104
log
@2003-09-14  Andrew Cagney  <cagney@@redhat.com>

	* alpha-nat.c: Remove some occurances of "register".
	* alpha-tdep.c, arm-tdep.c, blockframe.c, breakpoint.c: Ditto.
	* buildsym.c, c-typeprint.c, c-valprint.c, coffread.c: Ditto.
	* corefile.c, cp-support.c, cp-valprint.c, cris-tdep.c: Ditto.
	* dbxread.c, dcache.c, dwarf2read.c, elfread.c: Ditto.
	* environ.c, eval.c, event-top.c, f-typeprint.c: Ditto.
	* f-valprint.c, findvar.c, frame.c, gdbtypes.c: Ditto.
	* h8300-tdep.c, hppa-tdep.c, hppab-nat.c, hppah-nat.c: Ditto.
	* hppam3-nat.c, hpread.c, ia64-aix-nat.c, ia64-linux-nat.c: Ditto.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Ditto.
	* infttrace.c, irix5-nat.c, jv-typeprint.c: Ditto.
	* jv-valprint.c, m68k-tdep.c, m68klinux-nat.c, main.c: Ditto.
	* mdebugread.c, minsyms.c, mips-linux-tdep.c: Ditto.
	* mips-nat.c, mips-tdep.c, mipsread.c, mipsv4-nat.c: Ditto.
	* ns32k-tdep.c, objfiles.c, p-typeprint.c: Ditto.
	* p-valprint.c, ppc-linux-nat.c, printcmd.c: Ditto.
	* remote-mips.c, remote-vx.c, rs6000-nat.c: Ditto.
	* rs6000-tdep.c, scm-exp.c, sh-tdep.c, sh64-tdep.c: Ditto.
	* solib.c, somread.c, source.c, sparc-tdep.c: Ditto.
	* stabsread.c, stack.c, standalone.c, symfile.c: Ditto.
	* symmisc.c, symtab.c, top.c, tracepoint.c: Ditto.
	* typeprint.c, utils.c, valarith.c, valops.c: Ditto.
	* values.c, vax-tdep.c, xcoffread.c: Ditto.
@
text
@d2317 1
a2317 1
	     .debug_renges section.  */
d2330 8
@


1.103
log
@2003-09-12  Andrew Cagney  <cagney@@redhat.com>

	* objfiles.h (struct entry_info): Deprecate "entry_file_lowpc" and
	"entry_file_highpc".  Update comments.
	* defs.h (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* blockframe.c (deprecated_inside_entry_file): Rename
	"inside_entry_file".
	* frame.c (get_prev_frame): Update.  Use if 0 instead of #if 0.
	* vax-tdep.c (vax_frame_chain): Update.
	* sh64-tdep.c (sh64_frame_chain): Update.
	* sh-tdep.c (sh_frame_chain): Update.
	* rs6000-tdep.c (rs6000_frame_chain): Update.
	* ns32k-tdep.c (ns32k_frame_chain): Update.
	* mips-tdep.c (mips_frame_chain): Update.
	* m68hc11-tdep.c (m68hc11_frame_this_id): Update.
	* m32r-tdep.c (m32r_frame_this_id): Update.
	* i386-interix-tdep.c (i386_interix_frame_chain_valid): Update.
	* frv-tdep.c (frv_frame_this_id): Update.
	* d10v-tdep.c (d10v_frame_this_id): Update.
	* cris-tdep.c (cris_frame_chain): Update.
	* blockframe.c (legacy_frame_chain_valid): Update.
	* avr-tdep.c (avr_frame_this_id): Update.
	* arm-tdep.c (arm_prologue_this_id): Update.
	* alpha-tdep.c (alpha_heuristic_frame_this_id): Update.
	* objfiles.c (objfile_relocate): Update.
	* mipsread.c (mipscoff_symfile_read): Update.
	(mipscoff_symfile_read): Update.
	* mdebugread.c (parse_partial_symbols): Update.
	* dwarfread.c (read_file_scope): Update.
	* dwarf2read.c (read_file_scope): Update.
	* dbxread.c (read_dbx_symtab): Update.
	(read_dbx_symtab): Update.
	* coffread.c (complete_symtab): Update.
@
text
@d2136 1
a2136 1
  register struct context_stack *new;
d2247 1
a2247 1
  register struct context_stack *new;
@


1.102
log
@2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdbtypes.h: Add TYPE_CODE_NAMESPACE.
	* gdbtypes.c (init_type): Handle TYPE_CODE_NAMESPACE.
	(recursive_dump_type): Ditto.
	* printcmd.c (print_formatted): Ditto.
	* typeprint.c (print_type_scalar): Ditto.
	* c-typeprint.c (c_type_print_varspec_prefix): Ditto.
	(c_type_print_varspec_suffix, c_type_print_base): Ditto.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	maint_cplus_cmd_list.
	* cp-support.c: Make maint_cplus_cmd_list extern.
	* cp-namespace.c: Include objfiles.h, gdbtypes.h, dictionary.h,
	command.h.
	(lookup_symbol_file): Look in possible namespace blocks when
	appropriate.
	(initialize_namespace_symtab): New.
	(get_possible_namespace_block, free_namespace_block)
	(check_possible_namespace_symbols)
	(check_possible_namespace_symbols_loop)
	(check_one_possible_namespace_symbol)
	(lookup_possible_namespace_symbol, maintenance_cplus_namespace)
	(_initialize_cp_namespace): Ditto.
	* block.h: Declare allocate_block.
	* block.c (allocate_block): New.
	* jv-lang.c (get_java_class_symtab): Allocate blocks via
	allocate_block.
	* symfile.h: Update declaration of add_psymbol_to_list.
	* symfile.c (add_psymbol_to_list): Return the partial symbol in
	question.
	* dwarf2read.c (dwarf2_build_psymtabs_hard): Add argument to
	scan_partial_symbols_call.
	(scan_partial_symbols): Add NAMESPACE argument; update calls to
	helper functions.
	(add_partial_symbol): If necessary, scan mangled names for names
	of namespaces.
	(add_partial_namespace): Add NAMESPACE argument; generate partial
	symbols associated  to namespaces.
	(add_partial_enumeration): Add NAMESPACE argument.
	(new_symbol): Allow namespace syms.
	(read_namespace): Generate namespace syms.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.
	* Makefile.in (cp-namespace.o): Depend on objfiles_h, gdbtypes_h,
	dictionary_h, command_h.

2003-09-11  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add tests for namespace types.
	* gdb.c++/maint.exp (test_help): Test 'help maint cp namespace'.
	(test_namespace): New.
@
text
@d2042 2
a2043 2
      objfile->ei.entry_file_lowpc = lowpc;
      objfile->ei.entry_file_highpc = highpc;
@


1.101
log
@2003-09-09  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (dwarf2_build_psymtabs_hard): Move lowpc and
	highpc initialization here out of scan_partial_symbols.
	(scan_partial_symbols): Restructure into a recursive version,
	calling add_partial_namespace and add_partial_enumeration when
	appropriate.
	(add_partial_namespace): New.
	(add_partial_enumeration, locate_pdi_sibling): Ditto.
@
text
@d675 2
a676 1
				   const struct comp_unit_head *);
d679 2
a680 1
				const struct comp_unit_head *);
d686 2
a687 1
				    const struct comp_unit_head *cu_header);
d692 2
a693 1
				      const struct comp_unit_head *cu_header);
d1348 1
a1348 1
					   &cu_header);
d1384 5
a1388 1
   to the end of the current namespace.  */
d1393 2
a1394 1
		      const struct comp_unit_head *cu_header)
d1433 1
a1433 1
		      add_partial_symbol (&pdi, objfile, cu_header);
d1444 1
a1444 1
		  add_partial_symbol (&pdi, objfile, cu_header);
d1451 2
a1452 1
						      objfile, cu_header);
d1459 1
a1459 1
	      add_partial_symbol (&pdi, objfile, cu_header);
d1462 5
d1468 2
a1469 1
						lowpc, highpc, cu_header);
d1497 2
a1498 1
		    const struct comp_unit_head *cu_header)
d1501 1
d1510 5
a1514 4
	  add_psymbol_to_list (pdi->name, strlen (pdi->name),
			       VAR_DOMAIN, LOC_BLOCK,
			       &objfile->global_psymbols,
			    0, pdi->lowpc + baseaddr, cu_language, objfile);
d1520 5
a1524 4
	  add_psymbol_to_list (pdi->name, strlen (pdi->name),
			       VAR_DOMAIN, LOC_BLOCK,
			       &objfile->static_psymbols,
			    0, pdi->lowpc + baseaddr, cu_language, objfile);
d1546 5
a1550 4
	    add_psymbol_to_list (pdi->name, strlen (pdi->name),
				 VAR_DOMAIN, LOC_STATIC,
				 &objfile->global_psymbols,
				 0, addr + baseaddr, cu_language, objfile);
d1560 5
a1564 4
	  add_psymbol_to_list (pdi->name, strlen (pdi->name),
			       VAR_DOMAIN, LOC_STATIC,
			       &objfile->static_psymbols,
			       0, addr + baseaddr, cu_language, objfile);
a1604 1
}
d1606 17
a1622 3
/* Read a partial die corresponding to a namespace.  For now, we don't
   do anything with the fact that we're in a namespace; we just read
   the symbols inside of it.  */
d1628 2
a1629 1
		       const struct comp_unit_head *cu_header)
d1631 24
d1658 1
a1658 1
				     cu_header);
d1668 2
a1669 1
			 const struct comp_unit_head *cu_header)
d1675 1
a1675 1
    add_partial_symbol (enum_pdi, objfile, cu_header);
d1685 1
a1685 1
	add_partial_symbol (&pdi, objfile, cu_header);
d3378 16
a3393 2
  /* If it's an anonymous namespace that we're seeing for the first
     time, add a using directive.  */
d3395 5
a3399 4
  if (is_anonymous && dwarf_attr (die, DW_AT_extension) == NULL)
    cp_add_using_directive (processing_current_namespace,
			    strlen (previous_namespace),
			    strlen (processing_current_namespace));
d5254 5
a5258 1
  name = dwarf2_linkage_name (die);
d5414 4
@


1.100
log
@        * dwarf2read.c (dwarf_attr_name): Move DW_AT_MIPS_linkage_name
        case out of #ifdef MIPS block.
@
text
@d680 16
d1340 3
d1346 5
d1379 2
a1380 1
/* Read in all interesting dies to the end of the compilation unit.  */
d1390 9
a1398 21
  /* This function is called after we've read in the comp_unit_die in
     order to read its children.  We start the nesting level at 1 since
     we have pushed 1 level down in order to read the comp unit's children.
     The comp unit itself is at level 0, so we stop reading when we pop
     back to that level. */

  int nesting_level = 1;

  /* We only want to read in symbols corresponding to variables or
     other similar objects that are global or static.  Normally, these
     are all children of the DW_TAG_compile_unit die, so are all at
     level 1.  But C++ namespaces give ries to DW_TAG_namespace dies
     whose children are global objects.  So we keep track of what
     level we currently think of as referring to file scope; this
     should always equal 1 plus the number of namespaces that we are
     currently nested within.  */
  
  int file_scope_level = 1;

  *lowpc = ((CORE_ADDR) -1);
  *highpc = ((CORE_ADDR) 0);
a1399 2
  while (nesting_level)
    {
d1402 3
a1404 1
      /* Anonymous namespaces have no name but are interesting.  */
d1406 2
a1407 1
      if (pdi.name != NULL || pdi.tag == DW_TAG_namespace)
d1422 1
a1422 2
		  if ((pdi.is_external || nesting_level == file_scope_level)
		      && !pdi.is_declaration)
d1430 1
d1433 1
a1433 4
	    case DW_TAG_union_type:
	    case DW_TAG_enumeration_type:
	      if ((pdi.is_external || nesting_level == file_scope_level)
		  && !pdi.is_declaration)
d1438 7
a1444 7
	    case DW_TAG_enumerator:
	      /* File scope enumerators are added to the partial
	         symbol table.  They're children of the enumeration
	         type die, so they occur at a level one higher than we
	         normally look for.  */
	      if (nesting_level == file_scope_level + 1)
		add_partial_symbol (&pdi, objfile, cu_header);
d1449 1
a1449 2
	      if (nesting_level == file_scope_level)
		add_partial_symbol (&pdi, objfile, cu_header);
d1452 4
a1455 6
	      /* FIXME: carlton/2002-10-16: we're not yet doing
		 anything useful with this, but for now make sure that
		 these tags at least don't cause us to miss any
		 important symbols.  */
	      if (pdi.has_children)
		file_scope_level++;
d1461 10
a1470 16
      /* If the die has a sibling, skip to the sibling.  Do not skip
         enumeration types, we want to record their enumerators.  Do
         not skip namespaces, we want to record symbols inside
         them.  */
      if (pdi.sibling
	  && pdi.tag != DW_TAG_enumeration_type
	  && pdi.tag != DW_TAG_namespace)
	{
	  info_ptr = pdi.sibling;
	}
      else if (pdi.has_children)
	{
	  /* Die has children, but either the optional DW_AT_sibling
	     attribute is missing or we want to look at them.  */
	  nesting_level++;
	}
d1472 2
a1473 11
      if (pdi.tag == 0)
	{
	  nesting_level--;
	  /* If this is the end of a DW_TAG_namespace entry, then
	     decrease the file_scope_level, too.  */
	  if (nesting_level < file_scope_level)
	    {
	      file_scope_level--;
	      gdb_assert (nesting_level == file_scope_level);
	    }
	}
a1475 4
  /* If we didn't find a lowpc, set it to highpc to avoid complaints
     from `maint check'.  */
  if (*lowpc == ((CORE_ADDR) -1))
    *lowpc = *highpc;
d1582 79
@


1.99
log
@	* dwarf2read.c (new_symbol): Use var_decode_location for parameters.
@
text
@d6052 1
a6054 1
#endif
@


1.98
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* findvar.c (read_var_value): Remove case for thread local storage
	variables.  It is now entirely handled by the dwarf2 location
	expression code.
	* printcmd.c (address_info): Ditto.
	* symtab.h (address_class): Remove LOC_THREAD_LOCAL_STATIC
	enumeration value.
	(struct symbol): Remove objfile field, which was used by
	LOC_THREAD_LOCAL_STATIC only.
	* dwarf2read.c (decode_locdesc): Remove is_thread_local variable.
	* dwarf2loc.h (struct dwarf2_loclist_baton): Add comment about
	usage of objfile pointer.
	* dwarf2loc.c (locexpr_describe_location): Add case to handle
	thread local variables.
	Add include of objfiles.h.
	* dwarf2expr.c (execute_stack_op): Add comments about thread local
	storage variables.
	* Makefile.in (dwarf2loc.o): Update dependencies.
@
text
@d5210 4
a5213 26
	      SYMBOL_VALUE (sym) =
		decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
	      if (isreg)
		{
		  SYMBOL_CLASS (sym) = LOC_REGPARM;
		  SYMBOL_VALUE (sym) = 
		    DWARF2_REG_TO_REGNUM (SYMBOL_VALUE (sym));
		}
	      else if (offreg)
		{
		  if (isderef)
		    {
		      if (basereg != frame_base_reg)
			dwarf2_complex_location_expr_complaint ();
		      SYMBOL_CLASS (sym) = LOC_REF_ARG;
		    }
		  else
		    {
		      SYMBOL_CLASS (sym) = LOC_BASEREG_ARG;
		      SYMBOL_BASEREG (sym) = DWARF2_REG_TO_REGNUM (basereg);
		    }
		}
	      else
		{
		  SYMBOL_CLASS (sym) = LOC_ARG;
		}
@


1.97
log
@2003-06-26  Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2read.c (dwarf2_locate_sections): Ignore empty .eh_frame
	sections.
@
text
@a440 6
static int is_thread_local;     /* Variable is at a constant offset in the
                                   thread-local storage block for the
                                   current thread and the dynamic linker
                                   module containing this expression.
                                   decode_locdesc returns the offset from
                                   that base.  */
a6784 1
  is_thread_local = 0;
a7009 1
          is_thread_local = 1;
@


1.96
log
@2003-06-11  David Carlton  <carlton@@bactrian.org>

	* block.h (BLOCK_SHOULD_SORT): Delete.
	* symtab.c (lookup_block_symbol): Don't worry about sorted linear
	blocks.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.c (sort_block_syms): Delete.
	(sort_symtab_syms): Ditto.
	* symfile.h: Delete sort_symtabs_syms and sort_block_syms
	declarations.
	* coffread.c (coff_symfile_read): Don't call sort_symtab_syms.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
@
text
@d1024 7
a1030 3
      dwarf_eh_frame_offset = sectp->filepos;
      dwarf_eh_frame_size = bfd_get_section_size_before_reloc (sectp);
      dwarf_eh_frame_section = sectp;
@


1.96.4.1
log
@2003-06-26  Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2read.c (dwarf2_locate_sections): Ignore empty .eh_frame
	sections.
@
text
@d1024 3
a1026 7
      flagword aflag = bfd_get_section_flags (ignore_abfd, sectp);
      if (aflag & SEC_HAS_CONTENTS)
        {
          dwarf_eh_frame_offset = sectp->filepos;
          dwarf_eh_frame_size = bfd_get_section_size_before_reloc (sectp);
          dwarf_eh_frame_section = sectp;
        }
@


1.96.4.2
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* findvar.c (read_var_value): Remove case for thread local storage
	variables.  It is now entirely handled by the dwarf2 location
	expression code.
	* printcmd.c (address_info): Ditto.
	* symtab.h (address_class): Remove LOC_THREAD_LOCAL_STATIC
	enumeration value.
	(struct symbol): Remove objfile field, which was used by
	LOC_THREAD_LOCAL_STATIC only.
	* dwarf2read.c (decode_locdesc): Remove is_thread_local variable.
	* dwarf2loc.h (struct dwarf2_loclist_baton): Add comment about
	usage of objfile pointer.
	* dwarf2loc.c (locexpr_describe_location): Add case to handle
	thread local variables.
	Add include of objfiles.h.
	* dwarf2expr.c (execute_stack_op): Add comments about thread local
	storage variables.
	* Makefile.in (dwarf2loc.o): Update dependencies.
@
text
@d441 6
d6791 1
d7017 1
@


1.96.4.3
log
@	Merge from mainline:
	2003-07-31  Daniel Jacobowitz  <drow@@mvista.com>

	* dwarf2read.c (new_symbol): Use var_decode_location for parameters.
@
text
@d5210 26
a5235 4
	      var_decode_location (attr, sym, objfile, cu_header);
	      /* FIXME drow/2003-07-31: Is LOC_COMPUTED_ARG necessary?  */
	      if (SYMBOL_CLASS (sym) == LOC_COMPUTED)
		SYMBOL_CLASS (sym) = LOC_COMPUTED_ARG;
@


1.96.4.4
log
@Merged from mainline:

2003-09-22  Jim Blandy  <jimb@@redhat.com>

* dwarf2read.c (read_array_type): When building the type for an
array of unspecified length, make sure to choose the upper bound
so that the array's total length comes out to be zero --- that's
how we represent such arrays.
@
text
@d3103 2
a3104 8
		     length for now.

                     FIXME: jimb/2003-09-22: GDB does not really know
                     how to handle arrays of unspecified length
                     either; we just represent them as zero-length
                     arrays.  Choose an appropriate upper bound given
                     the lower bound we've computed above.  */
		  high = low - 1;
@


1.95
log
@2003-05-28  H.J. Lu <hongjiu.lu@@intel.com>

	* dwarf2read.c (process_die): Handle DW_TAG_try_block and
	DW_TAG_catch_block.
@
text
@a1742 1
  sort_symtab_syms (pst->symtab);
@


1.94
log
@2003-05-14  Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (enum domain_enum): Rename from namespace_enum.
	(UNDEF_DOMAIN, VAR_DOMAIN, STRUCT_DOMAIN, LABEL_DOMAIN,
	VARIABLES_DOMAIN, FUNCTIONS_DOMAIN, TYPES_DOMAIN, METHODS_DOMAIN):
	Rename from UNDEF_NAMESPACE, VAR_NAMESPACE, STRUCT_NAMESPACE,
	LABEL_NAMESPACE, VARIABLES_NAMESPACE, FUNCTIONS_NAMESPACE,
	TYPES_NAMESPACE, METHODS_NAMESPACE.
	(SYMBOL_NAMESPACE): Rename to SYMBOL_DOMAIN.
	(struct symbol, struct partial_symbol): Rename field
	'namespace_enum namespace' to 'domain_enum domain'.
	(PSYMBOL_NAMESPACE): Rename to PSYMBOL_DOMAIN.
	Delete old define kludge for namespace.

	* ada-exp.y, ada-lang.c, ada-lang.h, alpha-tdep.c, arm-tdep.c,
	blockframe.c, c-exp.y, c-valprint.c, coffread.c, dbxread.c,
	dwarf2read.c, dwarfread.c, f-exp.y, gdbtypes.c, gdbtypes.h,
	gnu-v3-abi.c, hppa-tdep.c, hpread.c, jv-exp.y, jv-lang.c,
	language.c, linespec.c, m2-exp.y, m3-nat.c, mdebugread.c,
	mips-tdep.c, nlmread.c, objc-exp.y, objc-lang.c, objfiles.c,
	p-exp.y, p-valprint.c, parse.c, printcmd.c, scm-lang.c, source.c,
	stabsread.c, stack.c, symfile.c, symfile.h, symmisc.c, symtab.c,
	valops.c, values.c, xcoffread.c, xstormy16-tdep.c: Replace all
	occurrences of the above.

2003-05-12  Elena Zannoni  <ezannoni@@redhat.com>

	* mi-mi-cmd-stack.c (list_args_or_locals): Rename VAR_NAMESPACE to
	VAR_DOMAIN.
@
text
@d1771 2
@


1.93
log
@2003-05-13  Andrew Cagney  <cagney@@redhat.com>

	* defs.h (store_address): Delete declaration.
	findvar.c (store_address): Delete function.
	* arm-tdep.c (arm_push_dummy_call): Replace store_address with
	store_unsigned_integer.
	* xstormy16-tdep.c (xstormy16_address_to_pointer): Ditto.
	* v850-tdep.c (v850_push_arguments): Ditto.
	* sparc-tdep.c (sparc_get_saved_register): Ditto.
	* sh-tdep.c (sh64_get_saved_register): Ditto.
	* rs6000-tdep.c (rs6000_push_arguments): Ditto.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_arguments): Ditto.
	* mips-tdep.c (mips_eabi_push_arguments): Ditto.
	(mips_get_saved_register): Ditto.
	* ia64-tdep.c (ia64_get_saved_register): Ditto.
	(find_func_descr, ia64_push_arguments): Ditto.
	* i386-tdep.c (i386_push_arguments): Ditto.
	* hpux-thread.c (hpux_thread_fetch_registers): Ditto.
	* frv-tdep.c (frv_push_arguments): Ditto.
	* frame.c (legacy_saved_regs_prev_register): Ditto.
	(deprecated_generic_get_saved_register): Ditto.
	* findvar.c (unsigned_address_to_pointer): Ditto.
	* dwarf2read.c (dwarf2_const_value): Ditto.
	* arm-linux-tdep.c (arm_linux_push_arguments): Ditto.
	* alpha-tdep.c (alpha_push_arguments): Ditto.
@
text
@d1506 1
a1506 1
			       VAR_NAMESPACE, LOC_BLOCK,
d1515 1
a1515 1
			       VAR_NAMESPACE, LOC_BLOCK,
d1540 1
a1540 1
				 VAR_NAMESPACE, LOC_STATIC,
d1553 1
a1553 1
			       VAR_NAMESPACE, LOC_STATIC,
d1561 1
a1561 1
			   VAR_NAMESPACE, LOC_TYPEDEF,
d1574 1
a1574 1
			   STRUCT_NAMESPACE, LOC_TYPEDEF,
d1582 1
a1582 1
			       VAR_NAMESPACE, LOC_TYPEDEF,
d1589 1
a1589 1
			   VAR_NAMESPACE, LOC_CONST,
d5125 1
a5125 1
      SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
d5255 1
a5255 1
	  SYMBOL_NAMESPACE (sym) = STRUCT_NAMESPACE;
d5267 1
a5267 1
	      SYMBOL_NAMESPACE (typedef_sym) = VAR_NAMESPACE;
d5279 1
a5279 1
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
@


1.92
log
@       * dwarf2read.c (set_cu_language): Set the language to "minimal" if
       the language of the CU is not currently supported by GDB.
@
text
@d5322 4
a5325 2
      store_address (SYMBOL_VALUE_BYTES (sym), cu_header->addr_size,
		     DW_ADDR (attr));
@


1.92.4.1
log
@Snap const char * mess.
@
text
@d5322 2
a5323 4
      /* NOTE: cagney/2003-05-09: In-lined store_address call with
         it's body - store_unsigned_integer.  */
      store_unsigned_integer (SYMBOL_VALUE_BYTES (sym), cu_header->addr_size,
			      DW_ADDR (attr));
@


1.91
log
@
2003-05-07  Jeff Johnston  <jjohnstn@@redhat.com>

        * dwarf2read.c (dwarf_decode_lines): Only use output of
        check_cu_functions() when calling record_line().  Do not update
        the current address.
@
text
@d4551 1
a4551 1
      cu_language = language_unknown;
@


1.90
log
@2003-04-15  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (SFILES): Add cp-namespace.c.
	(COMMON_OBS): Add cp-namespace.o.
	(block.o): Depend on gdb_obstack_h and cp_support_h.
	(buildsym.o): Depend on cp_support_h.
	(cp-namespace.o): New.
	(cp-support.o): Depend on gdb_string_h, demangle_h, gdb_assert_h,
	gdb_obstack_h, symtab_h, symfile_h, and gdbcmd_h.
	(dwarf2read.o): Depend on cp_support_h.
	* jv-lang.c (get_java_class_symtab): Set BLOCK_NAMESPACE.
	* dwarf2read.c (process_die): Set processing_has_namespace_info,
	processing_current_namespace.
	(read_namespace): Update processing_current_namespace; check for
	anonymous namespaces.
	(dwarf2_name): New function.
	(dwarf2_extension): Ditto.
	* cp-support.h: Update copyright, contributors.
	Add inclusion guards.
	Add opaque declaration for structs obstack, block, symbol.
	(struct using_direct): New struct.
	Add declarations for cp_find_first_component,
	cp_entire_prefix_len, processing_has_namespace_info,
	processing_current_namespace, cp_is_anonymous,
	cp_add_using_directive, cp_initialize_namespace,
	cp_finalize_namespace, cp_set_block_scope,
	cp_scan_for_anonymous_namespaces.
	* cp-namespace.c: New file.
	* cp-support.c: Update copyright.
	Include ctype.h, gdb_assert.h, gdbcmd.h.
	New variable maint_cplus_cmd_list.
	(cp_find_first_component): New function.
	(cp_entire_prefix_len, maint_cplus_command)
	(first_component_command, _initialize_cp_support): Ditto.
	* buildsym.c: Include cp-support.h.
	New variable using_list.
	(add_symbol_to_list): Check for anonymous namespaces.
	(finish_block): Set block's scope.
	(start_symtab): Initialize C++ namespace support.
	(end_symtab): Finalize C++ namespace support.
	* block.h: Add opaque declarations for structs
	block_namespace_info, using_direct, and obstack.
	Add declarations for block_set_scope and block_set_using.
	(struct block): Add 'language_specific' member.
	(BLOCK_NAMESPACE): New macro.
	* block.c: Include gdb_obstack.h and cp-support.h.
	(struct block_namespace_info): New struct.
	(block_set_scope): New function.
	(block_set_using, block_initialize_namespace): Ditto.

2003-04-15  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/maint.exp: New file.
@
text
@d4881 2
a4882 2
	      address = check_cu_functions (address);
	      record_line (current_subfile, line, address);
d4928 2
a4929 2
	      address = check_cu_functions (address);
	      record_line (current_subfile, line, address);
@


1.90.2.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1506 1
a1506 1
			       VAR_DOMAIN, LOC_BLOCK,
d1515 1
a1515 1
			       VAR_DOMAIN, LOC_BLOCK,
d1540 1
a1540 1
				 VAR_DOMAIN, LOC_STATIC,
d1553 1
a1553 1
			       VAR_DOMAIN, LOC_STATIC,
d1561 1
a1561 1
			   VAR_DOMAIN, LOC_TYPEDEF,
d1574 1
a1574 1
			   STRUCT_DOMAIN, LOC_TYPEDEF,
d1582 1
a1582 1
			       VAR_DOMAIN, LOC_TYPEDEF,
d1589 1
a1589 1
			   VAR_DOMAIN, LOC_CONST,
d4551 1
a4551 1
      cu_language = language_minimal;
d4881 2
a4882 2
	      record_line (current_subfile, line, 
	                   check_cu_functions (address));
d4928 2
a4929 2
	      record_line (current_subfile, line, 
	                   check_cu_functions (address));
d5125 1
a5125 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5255 1
a5255 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d5267 1
a5267 1
	      SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
d5279 1
a5279 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5322 2
a5323 4
      /* NOTE: cagney/2003-05-09: In-lined store_address call with
         it's body - store_unsigned_integer.  */
      store_unsigned_integer (SYMBOL_VALUE_BYTES (sym), cu_header->addr_size,
			      DW_ADDR (attr));
@


1.89
log
@2003-04-13  Daniel Jacobowitz  <drow@@mvista.com>

	* dwarf2expr.c (dwarf2_read_address): Renamed from read_address;
	made non-static.
	(execute_stack_op): All callers updated.
	* dwarf2expr.h: Add prototype for dwarf2_read_address.
	* dwarf2loc.c (find_location_expression): New function.
	(dwarf_expr_frame_base): Call it.
	(dwarf2_evaluate_loc_desc): Handle 0-length location expressions.
	(dwarf2_tracepoint_var_ref): New function, broken out from
	locexpr_tracepoint_var_ref.
	(locexpr_tracepoint_var_ref): Call dwarf2_tracepoint_var_ref.
	Make static.
	(loclist_read_variable, loclist_read_needs_frame): New functions.
	(loclist_describe_location, loclist_tracepoint_var_ref): New
	functions.
	(dwarf2_loclist_funcs): New struct location_funcs.
	* dwarf2loc.h (struct dwarf2_loclist_baton): New type.
	(struct dwarf2_locexpr_baton): Add comments.
	(dwarf2_loclist_funcs): New extern.
	* dwarf2read.c (struct comp_unit_head): Remove DIE member, add
	base_address and base_known.
	(dwarf_loc_buffer): New variable.
	(struct dwarf2_pinfo): Add dwarf_loc_buffer and dwarf_loc_size.
	(DWARF_LOC_BUFFER, DWARF_LOC_SIZE): New macros.
	(dwarf2_has_info): Initialize dwarf_loc_offset.
	(dwarf2_build_psymtabs): Read in .debug_loc.
	(dwarf2_build_psymtabs_hard): Use DWARF_LOC_BUFFER and
	DWARF_LOC_SIZE.
	(psymtab_to_symtab_1): Likewise.  Move base address calculation
	here, from...
	(dwarf2_get_pc_bounds): ... here.  Use the base address from
	cu_header.
	(dwarf2_symbol_mark_computed): Handle location lists.
@
text
@d46 1
d871 4
d1813 5
d1828 5
a3204 3
/* FIXME: carlton/2002-10-16: For now, we don't actually do anything
   useful with the namespace data: we just process its children.  */

d3209 49
d3268 2
d5734 37
@


1.88
log
@2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h (SYMBOL_NATURAL_NAME): New macro.
	(SYMBOL_LINKAGE_NAME): Ditto.
	(SYMBOL_PRINT_NAME): Use SYMBOL_NATURAL_NAME and
	SYMBOL_LINKAGE_NAME.
	(struct general_symbol_info): Expand comment.
	(DEPRECATED_SYMBOL_NAME): Rename from SYMBOL_NAME.
	(SYMBOL_MATCHES_NAME): Use DEPRECATED_SYMBOL_NAME.
	(SYMBOL_MATCHES_REGEXP): Ditto.
	* symtab.c (symbol_natural_name): New function.
	* objfiles.h: Replace all uses of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* xcoffread.c, valops.c, typeprint.c, tracepoint.c: Ditto.
	* symtab.c, symmisc.c, symfile.c, stack.c, stabsread.c: Ditto.
	* somsolib.c, sol-thread.c, rs6000-tdep.c, p-valprint.c: Ditto.
	* printcmd.c, objfiles.c, objc-lang.c, mipsread.c: Ditto.
	* minsyms.c, mdebugread.c, linespec.c, jv-lang.c: Ditto.
	* i386-tdep.c, i386-linux-tdep.c, hpread.c, hppa-tdep.c: Ditto.
	* gnu-v2-abi.c, f-valprint.c, findvar.c, expprint.c: Ditto.
	* dwarfread.c, dwarf2read.c, dbxread.c, c-valprint.c: Ditto.
	* cp-valprint.c, coffread.c, buildsym.c, breakpoint.c: Ditto.
	* blockframe.c, ax-gdb.c, arm-linux-tdep.c, ada-lang.c: Ditto.
	* ada-exp.y: Ditto.
	* ada-exp.y: Update copyright.
	* sol-thread.c, mipsread.c, jv-lang.c, f-valprint.c: Ditto.
	* cp-valprint.c: Ditto.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* generic/gdbtk.h: Replace all instances of SYMBOL_NAME by
	DEPRECATED_SYMBOL_NAME.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Ditto.
	* generic/gdbtk-stack.c, generic/gdbtk-cmds.c: Update copyright.

2003-02-25  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: Replace all instances of SYMBOL_NAME with
	DEPRECATED_SYMBOL_NAME.  Update copyright.
@
text
@d223 1
a223 1
    /* Pointer to the DIE associated with the compilation unit.  */
d225 5
a229 1
    struct die_info *die;
d402 1
d519 7
d541 2
d943 1
d1080 8
d1309 2
d1635 1
d1650 2
d1673 25
a1698 1
  cu_header.die = dies;
d2177 2
a2178 2
	  CORE_ADDR base = 0;
	  int found_base = 0;
d2185 2
a2186 23
	  /* The applicable base address is determined by (1) the closest
	     preceding base address selection entry in the range list or
	     (2) the DW_AT_low_pc of the compilation unit.  */

	  /* ??? Was in dwarf3 draft4, and has since been removed.
	     GCC still uses it though.  */
	  attr = dwarf_attr (cu_header->die, DW_AT_entry_pc);
	  if (attr)
	    {
	      base = DW_ADDR (attr);
	      found_base = 1;
	    }

	  if (!found_base)
	    {
	      attr = dwarf_attr (cu_header->die, DW_AT_low_pc);
	      if (attr)
		{
		  base = DW_ADDR (attr);
		  found_base = 1;
		}
	    }

a2188 1

d7361 16
a7376 1
  struct dwarf2_locexpr_baton *baton;
d7378 4
a7381 2
  /* When support for location lists is added, this will go away.  */
  if (!attr_form_is_block (attr))
d7383 1
a7383 3
      dwarf2_complex_location_expr_complaint ();
      return;
    }
d7385 3
a7387 10
  baton = obstack_alloc (&objfile->symbol_obstack,
			 sizeof (struct dwarf2_locexpr_baton));
  baton->objfile = objfile;

  /* Note that we're just copying the block's data pointer here, not
     the actual data.  We're still pointing into the dwarf_info_buffer
     for SYM's objfile; right now we never release that buffer, but
     when we do clean up properly this may need to change.  */
  baton->size = DW_BLOCK (attr)->size;
  baton->data = DW_BLOCK (attr)->data;
d7389 21
a7409 2
  SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_locexpr_funcs;
  SYMBOL_LOCATION_BATON (sym) = baton;
@


1.87
log
@	Based on a patch from Daniel Berlin (dberlin@@dberlin.org).
	* symtab.h: Add opaque declarations of struct axs_value and
	struct agent_expr.
	(enum address_class): Add LOC_COMPUTED and LOC_COMPUTED_ARG.
	(struct location_funcs): New type.
	(struct symbol): Add "loc" to aux_value.
	(SYMBOL_LOCATION_BATON, SYMBOL_LOCATION_FUNCS): New macros.
	* dwarf2read.c: Include "dwarf2expr.h".
	(dwarf2_symbol_mark_computed): New function.
	(read_func_scope): Use it.
	(var_decode_location): New function.
	(new_symbol): Use it.
	* dwarf2expr.c, dwarf2expr.h, dwarf2loc.c, dwarf2loc.h: New files.

	* Makefile.in (SFILES): Add dwarf2loc.c and dwarf2expr.c.
	(dwarf2expr_h, dwarf2loc_h): New variables.
	(COMMON_OBS): Add dwarf2expr.o and dwarf2loc.o.
	(dwarf2expr.o, dwarf2loc.o): New rules.
	(dwarf2read.o): Add $(dwarf2expr_h) and $(dwarf2loc_h).
	* buildsym.c (finish_block): Handle LOC_COMPUTED and
	LOC_COMPUTED_ARG.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info, print_frame_args): Likewise.
	* stack.c (print_block_frame_locals, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* ada-lang.c (ada_resolve_subexp, symtab_for_sym)
	(ada_add_block_symbols, fill_in_ada_prototype): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
@
text
@d2930 1
a2930 1
		  FIELD_NAME (fields[num_fields]) = SYMBOL_NAME (sym);
d5177 2
a5178 2
		  obsavestring (SYMBOL_NAME (sym),
				strlen (SYMBOL_NAME (sym)),
d5223 1
a5223 1
	dwarf2_const_value_length_mismatch_complaint (SYMBOL_NAME (sym),
d5239 1
a5239 1
	dwarf2_const_value_length_mismatch_complaint (SYMBOL_NAME (sym),
@


1.86
log
@	* dwarf2read.c (dwarf2_get_pc_bounds): Offset addresses by base.
@
text
@a40 1

d44 3
d910 5
d2008 7
d4947 55
d5090 1
d5093 1
a5093 45
		{
                  /* Support the .debug_loc offsets */
                  if (attr_form_is_block (attr))
                    {
		      SYMBOL_VALUE_ADDRESS (sym) =
		        decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
                    }
                  else if (attr->form == DW_FORM_data4
                           || attr->form == DW_FORM_data8)
                    {
		      dwarf2_complex_location_expr_complaint ();
                    }
                  else
                    {
		      dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
							     "external variable");
                    }
		  add_symbol_to_list (sym, &global_symbols);
                  if (is_thread_local)
                    {
                      /* SYMBOL_VALUE_ADDRESS contains at this point the
		         offset of the variable within the thread local
			 storage.  */
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }

		  /* In shared libraries the address of the variable
		     in the location descriptor might still be relocatable,
		     so its value could be zero.
		     Enter the symbol as a LOC_UNRESOLVED symbol, if its
		     value is zero, the address of the variable will then
		     be determined from the minimal symbol table whenever
		     the variable is referenced.  */
		  else if (SYMBOL_VALUE_ADDRESS (sym))
		    {
		      fixup_symbol_section (sym, objfile);
		      SYMBOL_VALUE_ADDRESS (sym) +=
			ANOFFSET (objfile->section_offsets,
			          SYMBOL_SECTION (sym));
		      SYMBOL_CLASS (sym) = LOC_STATIC;
		    }
		  else
		    SYMBOL_CLASS (sym) = LOC_UNRESOLVED;
		}
d5095 1
a5095 52
		{
                  /* Support the .debug_loc offsets */
                  if (attr_form_is_block (attr))
                    {
		      SYMBOL_VALUE (sym) = addr =
		        decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
                    }
                  else if (attr->form == DW_FORM_data4
                           || attr->form == DW_FORM_data8)
                    {
		      dwarf2_complex_location_expr_complaint ();
                    }
                  else
                    {
		      dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
							     "external variable");
                      addr = 0;
                    }
		  add_symbol_to_list (sym, list_in_scope);
		  if (optimized_out)
		    {
		      SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
		    }
		  else if (isreg)
		    {
		      SYMBOL_CLASS (sym) = LOC_REGISTER;
		      SYMBOL_VALUE (sym) = 
			DWARF2_REG_TO_REGNUM (SYMBOL_VALUE (sym));
		    }
		  else if (offreg)
		    {
		      SYMBOL_CLASS (sym) = LOC_BASEREG;
		      SYMBOL_BASEREG (sym) = DWARF2_REG_TO_REGNUM (basereg);
		    }
		  else if (islocal)
		    {
		      SYMBOL_CLASS (sym) = LOC_LOCAL;
		    }
                  else if (is_thread_local)
                    {
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }
		  else
		    {
		      fixup_symbol_section (sym, objfile);
		      SYMBOL_VALUE_ADDRESS (sym) =
		        addr + ANOFFSET (objfile->section_offsets,
			                 SYMBOL_SECTION (sym));
		      SYMBOL_CLASS (sym) = LOC_STATIC;
		    }
		}
d7324 29
@


1.85
log
@* dwarf2read.c (dwarf2_locate_sections): When we find a macro info
section, let dwarf_macinfo_section point to it, not
dwarf_loc_section.
@
text
@d2198 3
@


1.84
log
@	* defs.h (streq): Add prototype.
	* utils.c (streq): New function.

	* dwarf2read.c (new_symbol): Use SYMBOL_SET_NAMES instead of
	SYMBOL_NAME and SYMBOL_INIT_DEMANGLED_NAME.
	* mdebugread.c (new_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* coffread.c (process_coff_symbol): Likewise.
	* dwarfread.c (new_symbol): Likewise.

	* minsyms.c (prim_record_minimal_symbol_and_info): Use
	SYMBOL_SET_NAMES instead of setting SYMBOL_NAME.  Set the language
	here.
	(install_minimal_symbols): Don't set SYMBOL_LANGUAGE or call
	SYMBOL_INIT_DEMANGLED_NAME.
	* objfiles.c: Include "hashtab.h".
	(allocate_objfile): Call htab_set_functions_ex for the
	demangled_names_hash.
	(free_objfile): Call htab_delete for the demangled_names_hash.
	* objfiles.h (struct htab): Add declaration.
	(struct objfile): Add demangled_names_hash.
	* symfile.c: Include "hashtab.h".
	(reread_symbols): Call htab_delete for the demangled_names_hash.
	(add_psymbol_to_list): Use SYMBOL_SET_NAMES instead of putting
	SYMBOL_NAME in the bcache.
	* symtab.c: Include "hashtab.h".  Update comments.
	(create_demangled_names_hash, symbol_set_names): New functions.
	(symbol_find_demangled_name): New function, broken out from
	symbol_init_demangled_names.
	(symbol_init_demangled_names): Use it.
	* symtab.h (SYMBOL_INIT_DEMANGLED_NAME): Add missing parentheses.
	(SYMBOL_SET_NAMES): New macro.
	(symbol_set_names): Add prototype.
@
text
@d981 1
a981 1
      dwarf_loc_section = sectp;
@


1.83
log
@2003-02-03  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (pointer_encoding): Added new parameter.
	* dwarf2cfi.c, dwarf2read.c: Changed all warnings and
	error messages to contain BFD filename.
@
text
@d4953 4
a4956 2
      SYMBOL_NAME (sym) = obsavestring (name, strlen (name),
					&objfile->symbol_obstack);
a4970 9

      /* If this symbol is from a C++ compilation, then attempt to
         cache the demangled form for future reference.  This is a
         typical time versus space tradeoff, that was decided in favor
         of time because it sped up C++ symbol lookups by a factor of
         about 20. */

      SYMBOL_LANGUAGE (sym) = cu_language;
      SYMBOL_INIT_DEMANGLED_NAME (sym, &objfile->symbol_obstack);
@


1.82
log
@2003-01-31  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (dwarf2_locate_sections): Set
	dwarf_ranges_section.
@
text
@d1221 1
a1221 1
	  error ("Dwarf Error: wrong version in compilation unit header.");
d1226 1
a1226 1
	  error ("Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6).",
d1228 2
a1229 1
		 (long) (beg_of_comp_unit - dwarf_info_buffer));
d1235 1
a1235 1
	  error ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0).",
d1237 2
a1238 1
		 (long) (beg_of_comp_unit - dwarf_info_buffer));
d3792 2
a3793 1
      error ("Dwarf Error: Could not find abbrev number %d.", abbrev_number);
d3937 2
a3938 1
      error ("Dwarf Error: could not find abbrev number %d.", abbrev_number);
d4074 3
a4076 2
      error ("Dwarf Error: Cannot handle %s in DWARF reader.",
	     dwarf_form_name (form));
d4157 2
a4158 1
			  "read_address: bad switch, signed");
d4176 2
a4177 1
			  "read_address: bad switch, unsigned");
d4292 2
a4293 1
		      "read_offset: bad switch");
d4335 2
a4336 1
      error ("DW_FORM_strp used without .debug_str section");
d4341 2
a4342 1
      error ("DW_FORM_strp pointing outside of .debug_str section");
d5362 2
a5363 1
	  error ("Dwarf Error: Cannot find referent at offset %d.", ref);
d5371 2
a5372 1
      error ("Dwarf Error: Problem turning type die at offset into gdb type.");
d5396 2
a5397 1
	  error ("Dwarf Error: Cannot find referent at offset %d.", ref);
d5406 2
a5407 1
      error ("Dwarf Error: Problem turning containing type into gdb type.");
d5444 2
a5445 1
	  error ("Dwarf Error: Cannot find type of die.");
d6620 2
a6621 2
      error ("Dwarf Error: internal error - invalid fundamental type id %d.",
	     typeid);
@


1.82.2.1
log
@Merge with interps-20030203-mergepoint.
@
text
@d1221 1
a1221 1
	  error ("Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]", cu_header.version, 2, bfd_get_filename (abfd));
d1226 1
a1226 1
	  error ("Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6) [in module %s]",
d1228 1
a1228 2
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
d1234 1
a1234 1
	  error ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0) [in module %s]",
d1236 1
a1236 2
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
d3790 1
a3790 2
      error ("Dwarf Error: Could not find abbrev number %d [in module %s]", abbrev_number,
		      bfd_get_filename (abfd));
d3934 1
a3934 2
      error ("Dwarf Error: could not find abbrev number %d [in module %s]", abbrev_number, 
		      bfd_get_filename (abfd));
d4070 2
a4071 3
      error ("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]",
	     dwarf_form_name (form),
	     bfd_get_filename (abfd));
d4152 1
a4152 2
			  "read_address: bad switch, signed [in module %s]",
			  bfd_get_filename (abfd));
d4170 1
a4170 2
			  "read_address: bad switch, unsigned [in module %s]",
			  bfd_get_filename (abfd));
d4285 1
a4285 2
		      "read_offset: bad switch [in module %s]",
		      bfd_get_filename (abfd));
d4327 1
a4327 2
      error ("DW_FORM_strp used without .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d4332 1
a4332 2
      error ("DW_FORM_strp pointing outside of .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d5352 1
a5352 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", 
			  ref, objfile->name);
d5360 1
a5360 2
      error ("Dwarf Error: Problem turning type die at offset into gdb type [in module %s]",
		      objfile->name);
d5384 1
a5384 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", ref, 
			  objfile->name);
d5393 1
a5393 2
      error ("Dwarf Error: Problem turning containing type into gdb type [in module %s]", 
		      objfile->name);
d5430 1
a5430 2
	  error ("Dwarf Error: Cannot find type of die [in module %s]", 
			  objfile->name);
d6605 2
a6606 2
      error ("Dwarf Error: internal error - invalid fundamental type id %d [in module %s]",
	     typeid, objfile->name);
@


1.81
log
@	* dbxread.c (stabs_data): New static variable.
	(fill_symbuf): Support an in-memory buffer for stabs data.
	(stabs_seek): New function.
	(dbx_psymtab_to_symtab): Relocate the stabs data if necessary.
	(read_ofile_symtab): Use stabs_seek.
	(elfstab_build_psymtabs): Take an asection* instead of
	an offset and size.  Relocate the stabs data if necessary.
	Save the section* for dbx_psymtab_to_symtab.
	* dwarf2read.c: Add section variables for each debug section.
	(dwarf2_locate_sections): Fill them in.
	(dwarf2_read_section): Take an asection* argument.
	Relocate the section contents if necessary.
	(dwarf2_build_psymtabs, dwarf2_build_psymtabs_easy): Update callers.
	* dwarf2cfi.c (parse_frame_info): Take a section argument and pass
	it to dwarf2_read_section.
	(dwarf2_build_frame_info): Update callers.
	* elfread.c (elf_symfile_read): Update call to
	elfstab_build_psymtabs.
	* gdb-stabs.h (struct dbx_symfile_info): Add stab_section.
	(DBX_STAB_SECTION): New macro.
	* stabsread.h (elfstab_build_psymtabs): Update prototype.
	* symfile.c (symfile_dummy_outputs): New function.
	(symfile_relocate_debug_section): New function.
	* symfile.h (symfile_relocate_debug_section): Add prototype.
@
text
@d1005 1
@


1.80
log
@	Fix PR gdb/961.
	* dwarf2read.c 	(dwarf_ranges_offset, dwarf_ranges_size): New
	variables.
	(RANGES_SECTION): New.
	(dwarf_ranges_buffer): New variable.
	(struct comp_unit_head): Add member "die".
	(struct dwarf2_pinfo): Add dwarf_ranges_buffer, dwarf_ranges_size.
	(DWARF_RANGES_BUFFER, DWARF_RANGES_SIZE): New.
	(dwarf2_has_info): Init dwarf_ranges_offset and dwarf_ranges_size.
	(dwarf2_locate_sections): Likewise.
	(dwarf2_build_psymtabs): Read .debug_ranges.
	(dwarf2_build_psymtabs_hard): Swap dwarf_ranges out.
	(psymtab_to_symtab_1): Swap dwarf_ranges in.  Set cu_header.die.
	(dwarf2_get_pc_bounds): New cu_header argument; adjust all callers.
	Look for DW_AT_ranges and return the bounding box.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d152 12
d673 2
a674 1
char *dwarf2_read_section (struct objfile *, file_ptr, unsigned int);
d945 1
d951 1
d957 1
d963 1
d969 1
d975 1
d981 1
d987 1
d993 1
d999 1
d1018 2
a1019 1
					   dwarf_info_size);
d1022 2
a1023 1
					     dwarf_abbrev_size);
d1028 2
a1029 1
					     dwarf_line_size);
d1036 2
a1037 1
					    dwarf_str_size);
d1044 2
a1045 1
                                                dwarf_macinfo_size);
d1052 2
a1053 1
					       dwarf_ranges_size);
d1095 2
a1096 1
					 dwarf_pubnames_size);
d1116 2
a1117 1
					dwarf_aranges_size);
d3618 1
a3618 1
		     unsigned int size)
d3621 1
a3621 1
  char *buf;
d3627 5
@


1.79
log
@2003-01-18  Andrew Cagney  <ac131313@@redhat.com>

	* ada-valprint.c: Eliminate PTR.
	* breakpoint.c, corelow.c, cris-tdep.c, dbxread.c: Ditto.
	* defs.h, dve3900-rom.c, dwarf2read.c, dwarfread.c: Ditto.
	* exec.c, hppa-tdep.c, hpread.c, infcmd.c, mdebugread.c: Ditto.
	* objfiles.c, objfiles.h, ocd.c, remote-es.c: Ditto.
	* remote-mips.c, remote-sds.c, remote-vx.c: Ditto.
	* solib-svr4.c, solib.c, stack.c, symfile.c, symfile.h: Ditto.
	* symmisc.c, v850ice.c, xcoffread.c, cli/cli-script.c: Ditto.
@
text
@d136 1
d148 1
d162 1
d208 4
d383 1
d492 8
d513 2
d772 2
a773 1
				 CORE_ADDR *, CORE_ADDR *, struct objfile *);
d908 2
d978 5
d1021 7
d1243 2
d1581 2
d1605 1
d1608 1
a1608 1
  if (!dwarf2_get_pc_bounds (dies, &lowpc, &highpc, objfile))
d1623 2
a1624 1
		  if (dwarf2_get_pc_bounds (child_die, &low, &high, objfile))
d1753 1
a1753 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile))
d1764 2
a1765 1
		  if (dwarf2_get_pc_bounds (child_die, &low, &high, objfile))
d1911 1
a1911 1
  if (name == NULL || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile))
d2009 5
a2013 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile))
d2038 3
a2040 3
/* Get low and high pc attributes from a die.
   Return 1 if the attributes are present and valid, otherwise, return 0.  */

d2042 3
a2044 2
dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc, CORE_ADDR *highpc,
		      struct objfile *objfile)
d2047 4
a2050 2
  CORE_ADDR low;
  CORE_ADDR high;
a2051 5
  attr = dwarf_attr (die, DW_AT_low_pc);
  if (attr)
    low = DW_ADDR (attr);
  else
    return 0;
d2054 12
a2065 1
    high = DW_ADDR (attr);
d2067 124
a2190 1
    return 0;
d2203 1
a2203 1
  if (low == 0 && (bfd_get_file_flags (objfile->obfd) & HAS_RELOC) == 0)
d2208 1
a2208 1
  return 1;
@


1.78
log
@Convert complain() to complaint().
@
text
@d624 1
a624 1
static void dwarf2_locate_sections (bfd *, asection *, PTR);
d647 1
a647 1
static void dwarf2_empty_abbrev_table (PTR);
d858 1
a858 1
static void dwarf2_free_tmp_obstack (PTR);
d905 1
a905 1
dwarf2_locate_sections (bfd *ignore_abfd, asection *sectp, PTR ignore_ptr)
d3510 1
a3510 1
dwarf2_empty_abbrev_table (PTR ptr_to_abbrevs_table)
d6703 1
a6703 1
dwarf2_free_tmp_obstack (PTR ignore)
@


1.77
log
@2002-12-05  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (dwarf2_add_field): Treat a field that is a
	DW_TAG_member as well as a declaration as being a C++ static data
	member.
	(read_structure_scope): Combine tests for DW_TAG_member and
	DW_TAG_variable.
@
text
@d564 9
a572 1
static struct deprecated_complaint dwarf2_const_ignored =
d574 6
a579 127
  "type qualifier 'const' ignored", 0, 0
};
static struct deprecated_complaint dwarf2_volatile_ignored =
{
  "type qualifier 'volatile' ignored", 0, 0
};
static struct deprecated_complaint dwarf2_non_const_array_bound_ignored =
{
  "non-constant array bounds form '%s' ignored", 0, 0
};
static struct deprecated_complaint dwarf2_missing_line_number_section =
{
  "missing .debug_line section", 0, 0
};
static struct deprecated_complaint dwarf2_statement_list_fits_in_line_number_section =
{
  "statement list doesn't fit in .debug_line section", 0, 0
};
static struct deprecated_complaint dwarf2_mangled_line_number_section =
{
  "mangled .debug_line section", 0, 0
};
static struct deprecated_complaint dwarf2_unsupported_die_ref_attr =
{
  "unsupported die ref attribute form: '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_unsupported_stack_op =
{
  "unsupported stack op: '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_complex_location_expr =
{
  "location expression too complex", 0, 0
};
static struct deprecated_complaint dwarf2_unsupported_tag =
{
  "unsupported tag: '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_unsupported_at_encoding =
{
  "unsupported DW_AT_encoding: '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_unsupported_at_frame_base =
{
  "unsupported DW_AT_frame_base for function '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_unexpected_tag =
{
  "unexepected tag in read_type_die: '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_missing_at_frame_base =
{
  "DW_AT_frame_base missing for DW_OP_fbreg", 0, 0
};
static struct deprecated_complaint dwarf2_bad_static_member_name =
{
  "unrecognized static data member name '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_unsupported_accessibility =
{
  "unsupported accessibility %d", 0, 0
};
static struct deprecated_complaint dwarf2_bad_member_name_complaint =
{
  "cannot extract member name from '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_missing_member_fn_type_complaint =
{
  "member function type missing for '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_vtbl_not_found_complaint =
{
  "virtual function table pointer not found when defining class '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_absolute_sibling_complaint =
{
  "ignoring absolute DW_AT_sibling", 0, 0
};
static struct deprecated_complaint dwarf2_const_value_length_mismatch =
{
  "const value length mismatch for '%s', got %d, expected %d", 0, 0
};
static struct deprecated_complaint dwarf2_unsupported_const_value_attr =
{
  "unsupported const value attribute form: '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_misplaced_line_number =
{
  "misplaced first line number at 0x%lx for '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_line_header_too_long =
{
  "line number info header doesn't fit in `.debug_line' section", 0, 0
};
static struct deprecated_complaint dwarf2_missing_macinfo_section =
{
  "missing .debug_macinfo section", 0, 0
};
static struct deprecated_complaint dwarf2_macros_too_long =
{
  "macro info runs off end of `.debug_macinfo' section", 0, 0
};
static struct deprecated_complaint dwarf2_macros_not_terminated =
{
  "no terminating 0-type entry for macros in `.debug_macinfo' section", 0, 0
};
static struct deprecated_complaint dwarf2_macro_outside_file =
{
  "debug info gives macro %s outside of any file: %s", 0, 0
};
static struct deprecated_complaint dwarf2_macro_unmatched_end_file =
{
  "macro debug info has an unmatched `close_file' directive", 0, 0
};
static struct deprecated_complaint dwarf2_macro_malformed_definition =
{
  "macro debug info contains a malformed macro definition:\n`%s'", 0, 0
};
static struct deprecated_complaint dwarf2_macro_spaces_in_definition =
{
  "macro definition contains spaces in formal argument list:\n`%s'", 0, 0
};
static struct deprecated_complaint dwarf2_invalid_attrib_class =
{
  "invalid attribute class or form for '%s' in '%s'", 0, 0
};
static struct deprecated_complaint dwarf2_invalid_pointer_size = 
d581 40
a620 2
  "invalid pointer size %d", 0, 0
};
d1903 1
a1903 1
          complain (&dwarf2_complex_location_expr);
d1908 1
a1908 1
          complain (&dwarf2_invalid_attrib_class, "DW_AT_frame_base", name);
d1913 1
a1913 1
	complain (&dwarf2_unsupported_at_frame_base, name);
d1922 1
a1922 1
	complain (&dwarf2_unsupported_at_frame_base, name);
d2273 2
a2274 2
	    complain (&dwarf2_unsupported_accessibility,
		      fip->fields->accessibility);
d2382 2
a2383 1
    complain (&dwarf2_missing_member_fn_type_complaint, physname);
d2423 1
a2423 1
          complain (&dwarf2_complex_location_expr);
d2427 2
a2428 2
          complain (&dwarf2_invalid_attrib_class, "DW_AT_vtable_elem_location",
                    fieldname);
d2610 4
a2613 2
		    complain (&dwarf2_vtbl_not_found_complaint,
			  TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) : "");
d2801 2
a2802 2
		  complain (&dwarf2_non_const_array_bound_ignored,
			    dwarf_form_name (attr->form));
d2837 2
a2838 2
		  complain (&dwarf2_non_const_array_bound_ignored,
			    dwarf_form_name (attr->form));
d2905 1
a2905 1
          complain (&dwarf2_complex_location_expr);
d2909 2
a2910 2
          complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                    "common block member");
d2998 1
a2998 1
	  complain (&dwarf2_invalid_pointer_size, byte_size);
d3301 2
a3302 2
	  complain (&dwarf2_unsupported_at_encoding,
		    dwarf_type_encoding_name (encoding));
d3618 1
a3618 1
              complain (&dwarf2_complex_location_expr);
d3622 2
a3623 2
              complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                        "partial symbol information");
d3647 1
a3647 1
	    complain (&dwarf2_absolute_sibling_complaint);
d4359 1
a4359 1
      complain (&dwarf2_missing_line_number_section);
d4367 1
a4367 1
      complain (&dwarf2_statement_list_fits_in_line_number_section);
d4383 1
a4383 1
      complain (&dwarf2_statement_list_fits_in_line_number_section);
d4438 2
a4439 1
    complain (&dwarf2_line_header_too_long);
d4484 3
a4486 2
    complain (&dwarf2_misplaced_line_number,
	      (unsigned long) address, fn->name);
d4589 2
a4590 1
		  complain (&dwarf2_mangled_line_number_section);
d4814 1
a4814 1
                      complain (&dwarf2_complex_location_expr);
d4818 2
a4819 2
                      complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                                "external variable");
d4860 1
a4860 1
                      complain (&dwarf2_complex_location_expr);
d4864 2
a4865 2
                      complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                                "external variable");
d4937 1
a4937 1
			complain (&dwarf2_complex_location_expr);
d5008 2
a5009 1
	  complain (&dwarf2_unsupported_tag, dwarf_tag_name (die->tag));
d5029 4
a5032 2
	complain (&dwarf2_const_value_length_mismatch, SYMBOL_NAME (sym),
		  cu_header->addr_size, TYPE_LENGTH (SYMBOL_TYPE (sym)));
d5045 4
a5048 2
	complain (&dwarf2_const_value_length_mismatch, SYMBOL_NAME (sym),
		  blk->size, TYPE_LENGTH (SYMBOL_TYPE (sym)));
d5084 3
a5086 2
      complain (&dwarf2_unsupported_const_value_attr,
		dwarf_form_name (attr->form));
d5269 2
a5270 1
      complain (&dwarf2_unexpected_tag, dwarf_tag_name (die->tag));
d6361 3
a6363 1
      complain (&dwarf2_unsupported_die_ref_attr, dwarf_form_name (attr->form));
d6599 2
a6600 1
	      complain (&dwarf2_missing_at_frame_base);
d6677 1
a6677 1
	    complain (&dwarf2_complex_location_expr);
d6687 1
a6687 1
	    complain (&dwarf2_complex_location_expr);
d6691 2
a6692 1
	  complain (&dwarf2_unsupported_stack_op, dwarf_stack_op_name (op));
d6825 3
a6827 1
      complain (&dwarf2_macro_spaces_in_definition, body);
d6885 1
a6885 1
          complain (&dwarf2_macro_malformed_definition, body);
d6915 1
a6915 2
            complain (&dwarf2_macro_malformed_definition,
                      body);
d6951 1
a6951 1
              complain (&dwarf2_macro_malformed_definition, body);
d6958 1
a6958 1
            complain (&dwarf2_macro_malformed_definition, body);
d6962 1
a6962 1
        complain (&dwarf2_macro_malformed_definition, body);
d6974 1
a6974 1
    complain (&dwarf2_macro_malformed_definition, body);
d6989 1
a6989 1
      complain (&dwarf2_missing_macinfo_section);
d7003 1
a7003 1
          complain (&dwarf2_macros_too_long);
d7030 6
a7035 5
              complain (&dwarf2_macro_outside_file,
                        macinfo_type == DW_MACINFO_define ? "definition" :
                        macinfo_type == DW_MACINFO_undef ? "undefinition" :
                        "something-or-other",
                        body);
d7064 2
a7065 1
            complain (&dwarf2_macro_unmatched_end_file);
d7081 1
a7081 1
                      complain (&dwarf2_macros_too_long);
d7089 2
a7090 1
                    complain (&dwarf2_macros_not_terminated);
@


1.76
log
@2002-11-25  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (scan_partial_symbols): Descend into namespace
	pdi's with no name.
@
text
@d2149 2
a2150 1
  if (die->tag == DW_TAG_member)
d2152 2
d2238 1
a2238 1
  else if (die->tag == DW_TAG_variable)
d2240 7
d2249 1
a2249 2
      /* C++ static member.
	 Get name of field.  */
d2617 2
a2618 5
	  if (child_die->tag == DW_TAG_member)
	    {
	      dwarf2_add_field (&fi, child_die, objfile, cu_header);
	    }
	  else if (child_die->tag == DW_TAG_variable)
d2620 5
a2624 1
	      /* C++ static member.  */
@


1.75
log
@	* gdbtypes.h (struct main_type): Move artificial flag out of
	loc.  New member of ``struct field'' named static_kind.  Reduce
	overloaded meaning of bitsize.
	(FIELD_ARTIFICIAL, SET_FIELD_PHYSNAME, SET_FIELD_PHYSADDR)
	(TYPE_FIELD_STATIC, TYPE_FIELD_STATIC_HAS_ADDR): Likewise.
	(FIELD_STATIC_KIND, TYPE_FIELD_STATIC_KIND): New macros.

	* ada-lang.c (fill_in_ada_prototype): Initialize static_kind for
	new fields.
	(template_to_fixed_record_type, template_to_static_fixed_type)
	(to_record_with_fixed_variant_part): Likewise.
	* coffread.c (coff_read_struct_type, coff_read_enum_type): Likewise.
	* dwarf2read.c (dwarf2_add_field, read_enumeration): Likewise.
	* dwarfread.c (struct_type, enum_type): Likewise.
	* hpread.c (hpread_read_enum_type)
	(hpread_read_function_type, hpread_read_doc_function_type)
	(hpread_read_struct_type): Likewise.
	* mdebugread.c (parse_symbol): Likewise.
@
text
@d1362 3
a1364 1
      if (pdi.name)
@


1.74
log
@* dwarf2read.c (read_func_scope): Restore list_in_scope properly
when we finish a function a context.
* buildsym.h (outermost_context_p): New macro.
(Bug analyzed by David Edelsohn.)
@
text
@d2152 2
d2262 1
d2767 1
@


1.73
log
@* dwarf2read.c (read_func_scope): Restore local_symbols and
param_symbols after we finish the function context.  (Based on a
patch from David Edelsohn.)
@
text
@d2024 4
a2027 1
  list_in_scope = &file_symbols;
@


1.72
log
@2002-10-25  Andrew Cagney  <cagney@@redhat.com>

	* complaints.h (struct deprecated_complaint): Rename `struct
	complaint'.
	* complaints.c (complain): Update.
	* remote-vx68.c, remote-vxmips.c, remote-vxsparc.c: Delete
	incorrect comment indicating that "symfile.h" was being included
	for the `struct complaint' definition.
	* remote-vx.c: Update.
	* objc-lang.c: Update.
	* xcoffread.c: Update.
	* hpread.c: Update.
	* mdebugread.c: Update.
	* stabsread.c: Update.
	* dwarf2read.c: Update.
	* dwarfread.c: Update.
	* elfread.c: Update.
	* coffread.c: Update.
	* stabsread.h: Update.
	* dbxread.c: Update.
	* buildsym.c: Update.
	* gdbtypes.c: Update.
	* macrotab.c: Update.
@
text
@d2016 8
@


1.71
log
@2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (dwarf_tag_name): Add DWARF 3 names.
	(dwarf_attr_name): Ditto.
	(dwarf_type_encoding_name): Ditto.
	(scan_partial_symbols): Descend into DW_TAG_namespace entries.
	(process_die): Handle DW_TAG_namespace,
	DW_TAG_imported_declaration, DW_TAG_imported_module.
	(read_namespace): New function.
@
text
@d564 1
a564 1
static struct complaint dwarf2_const_ignored =
d568 1
a568 1
static struct complaint dwarf2_volatile_ignored =
d572 1
a572 1
static struct complaint dwarf2_non_const_array_bound_ignored =
d576 1
a576 1
static struct complaint dwarf2_missing_line_number_section =
d580 1
a580 1
static struct complaint dwarf2_statement_list_fits_in_line_number_section =
d584 1
a584 1
static struct complaint dwarf2_mangled_line_number_section =
d588 1
a588 1
static struct complaint dwarf2_unsupported_die_ref_attr =
d592 1
a592 1
static struct complaint dwarf2_unsupported_stack_op =
d596 1
a596 1
static struct complaint dwarf2_complex_location_expr =
d600 1
a600 1
static struct complaint dwarf2_unsupported_tag =
d604 1
a604 1
static struct complaint dwarf2_unsupported_at_encoding =
d608 1
a608 1
static struct complaint dwarf2_unsupported_at_frame_base =
d612 1
a612 1
static struct complaint dwarf2_unexpected_tag =
d616 1
a616 1
static struct complaint dwarf2_missing_at_frame_base =
d620 1
a620 1
static struct complaint dwarf2_bad_static_member_name =
d624 1
a624 1
static struct complaint dwarf2_unsupported_accessibility =
d628 1
a628 1
static struct complaint dwarf2_bad_member_name_complaint =
d632 1
a632 1
static struct complaint dwarf2_missing_member_fn_type_complaint =
d636 1
a636 1
static struct complaint dwarf2_vtbl_not_found_complaint =
d640 1
a640 1
static struct complaint dwarf2_absolute_sibling_complaint =
d644 1
a644 1
static struct complaint dwarf2_const_value_length_mismatch =
d648 1
a648 1
static struct complaint dwarf2_unsupported_const_value_attr =
d652 1
a652 1
static struct complaint dwarf2_misplaced_line_number =
d656 1
a656 1
static struct complaint dwarf2_line_header_too_long =
d660 1
a660 1
static struct complaint dwarf2_missing_macinfo_section =
d664 1
a664 1
static struct complaint dwarf2_macros_too_long =
d668 1
a668 1
static struct complaint dwarf2_macros_not_terminated =
d672 1
a672 1
static struct complaint dwarf2_macro_outside_file =
d676 1
a676 1
static struct complaint dwarf2_macro_unmatched_end_file =
d680 1
a680 1
static struct complaint dwarf2_macro_malformed_definition =
d684 1
a684 1
static struct complaint dwarf2_macro_spaces_in_definition =
d688 1
a688 1
static struct complaint dwarf2_invalid_attrib_class =
d692 1
a692 1
static struct complaint dwarf2_invalid_pointer_size = 
@


1.71.2.1
log
@WIP.  If you can figure it out, more power to you.
@
text
@a40 1
#include "dwarf2.h"
d54 17
d126 24
d167 1
a167 1
#define ABBREV_HASH_SIZE 10 /* low for testing */
d173 33
a205 31
{
  /* The total length of the data in the .debug_info section for this
     compilation unit, not including the initial length field itself.  */
  unsigned long length;

  /* The size, in bytes, of the initial length.  This, plus `length',
     is the entire size of the CU's info in the .debug_info section.  */
  unsigned int initial_length_size;

  /* Whether this CU is in the 32-bit Dwarf format or the 64-bit Dwarf
     format.  This is derived from the form of the initial length; see
     the description of the `initial length values' in the Dwarf
     spec.  */
  unsigned int offset_size;

  /* The version number of the information in this CU.  */
  short version;

  /* The offset in the .debug_abbrev section of the abbreviations for
     this compilation unit.  */
  unsigned int abbrev_offset;

  /* The size of an `address' in this compilation unit, in bytes.
     This gets used in various places; for example, this is the size
     of a DW_FORM_addr operand, and it's the size of the stack
     elements for dwarf expressions.  We also use it as the size of a
     pointer type, if the die doesn't have a DW_AT_byte_size
     attribute; this seems reasonable, but I don't see this suggested
     anywhere in the Dwarf spec.  *shrug*  */
  unsigned char addr_size;
};
d229 1
a229 1
     symfile_info->line.buffer.  If you try to free them, `free' will get
d235 1
a235 1
     with xmalloc; instead, they are pointers into symfile_info->line.buffer.
d247 1
a247 1
     header.  These point into symfile_info->line.buffer.  */
d357 4
d366 14
d428 33
a460 34
/* Information about the Dwarf 2 info in a particular executable or
   shared library.  Each objfile's `sym_dwarf2_info' field points to
   one of these structures, if the object file it represents contains
   any Dwarf 2 information.

   This is allocated on the symtab obstack.  */
struct dwarf2_symfile_info 
{
  /* Sections of Dwarf info in the object file.  */
  struct dwarf2_section info;     /* .debug_info */
  struct dwarf2_section abbrev;   /* .debug_abbrev */
  struct dwarf2_section line;     /* .debug_line */
  struct dwarf2_section pubnames; /* .debug_pubnames */
  struct dwarf2_section aranges;  /* .debug_aranges */
  struct dwarf2_section loc;      /* .debug_loc */
  struct dwarf2_section str;      /* .debug_str */
  struct dwarf2_section macinfo;  /* .debug_macinfo */
  struct dwarf2_section frame;    /* .debug_frame */
  struct dwarf2_section eh_frame; /* .eh_frame */

  /* Whether addresses are sign-extended on this architecture.  (We
     get this information from the BFD, which needs to know, too.)  */
  unsigned char signed_addr_p;

  /* This value is added to each symbol value.  FIXME:  Generalize to
     the section_offsets structure used by dbxread (once this is done,
     pass the appropriate section number to end_symtab).  */
  CORE_ADDR baseaddr;

  /* A table of the dwarf2_cu structures for this objfile, sorted by
     increasing header_offset.  When we find an inter-CU die
     reference, we search this table to find which CU the referenced
     die belongs to.  */
  struct dwarf2_cu **cu_table;
d462 9
a470 3
  /* The number of compilation units in cu_table.  */
  int cu_table_len;
};
d472 1
d474 1
a474 8
/* An abbreviation table --- a hash table indexed by abbrev number.
   The entry for a particular abbrev number describes the form of dies
   with that abbrev number: whether it has siblings, and the names and
   forms of its attributes.  These are allocated on the objfile's
   symtab obstack.  */
struct abbrev_table {
  /* The number of hash buckets in `buckets'.  */
  int num_buckets;
d476 1
a476 3
  /* An array of `num_buckets' hash buckets.  */
  struct abbrev_info **buckets;
};
d478 1
d480 3
a482 1
/* Info about a particular Dwarf 2 compilation unit.
d484 1
a484 28
   In our first scan over the Dwarf 2 debugging info, we create a
   psymtab for each compilation unit in the Dwarf 2 info; each
   psymtab's `sym_private' field points to one of these structures,
   giving Dwarf 2-specific info about that CU. 

   These are allocated on the objfile's symbol_obstack.  */
struct dwarf2_cu
{
  /* The objfile containing this compilation unit.  We use this to get
     to the dwarf2_symfile_info structure that goes with this CU.  */
  struct objfile *objfile;

  /* The offset in objfile->info.buffer of the compilation unit header
     for this CU, preceding the CU's dies.  Relative die references
     (e.g., DW_FORM_ref1, DW_FORM_ref_udata, ...) are relative to this
     offset.  */
  unsigned long header_offset;

  /* Information read from this CU's compilation unit header.  */
  struct comp_unit_head header;

  /* The abbrev table for this compilation unit.  */
  struct abbrev_table *abbrevs;

  /* The language of this compilation unit.  */
  enum language language;
  const struct language_defn *language_defn;
};
d486 11
d701 4
d718 1
a718 1
static void dwarf2_read_section (struct objfile *, struct dwarf2_section *);
d720 1
a720 1
static void dwarf2_read_abbrevs (struct dwarf2_cu *cu);
d722 1
a722 1
static void dwarf2_cleanup_abbrev_table (PTR);
d735 1
a735 1
                             struct dwarf2_cu *, char *);
d738 1
a738 1
                                   struct dwarf2_cu *, char *);
d754 1
a754 2
                                    unsigned int *, unsigned int *,
                                    int *bytes_read);
d804 4
d909 6
d951 5
a955 3
static void
locate_section (asection *section, const char *section_name,
                struct dwarf2_section *dwarf2_section)
d957 9
a965 1
  if (STREQ (section->name, section_name))
a966 2
      dwarf2_section->offset = section->filepos;
      dwarf2_section->size = bfd_get_section_size_before_reloc (section);
d970 3
a972 1
    return 0;
a974 1

d980 1
a980 2
dwarf2_locate_sections (bfd *ignore_abfd, asection *sectp,
                        PTR untyped_symfile_info)
d982 46
a1027 30
  struct dwarf2_symfile_info *symfile_info = untyped_symfile_info;

  (locate_section (sectp, INFO_SECTION,     &symfile_info->info)
   || locate_section (sectp, ABBREV_SECTION,   &symfile_info->abbrev)
   || locate_section (sectp, LINE_SECTION,     &symfile_info->line)
   || locate_section (sectp, PUBNAMES_SECTION, &symfile_info->pubnames)
   || locate_section (sectp, ARANGES_SECTION,  &symfile_info->aranges)
   || locate_section (sectp, LOC_SECTION,      &symfile_info->loc)
   || locate_section (sectp, STR_SECTION,      &symfile_info->str)
   || locate_section (sectp, MACINFO_SECTION,  &symfile_info->macinfo)
   || locate_section (sectp, FRAME_SECTION,    &symfile_info->frame)
   || locate_section (sectp, EH_FRAME_SECTION, &symfile_info->eh_frame));
}


/* Try to locate the sections we need for DWARF 2 debugging
   information and return true if we have enough to do something.  */

int
dwarf2_has_info (bfd *abfd, struct objfile *objfile)
{
  struct dwarf2_symfile_info symfile_info;

  memset (&symfile_info, 0, sizeof (symfile_info));
  bfd_map_over_sections (abfd, dwarf2_locate_sections, &symfile_info);

  /* If we have a .debug_info section and a .debug_abbrev section, we
     consider ourselves in business.  */
  if (symfile_info.info.offset
      && symfile_info.abbrev.offset)
d1029 2
a1030 16
      /* Allocate a real symfile info structure for this objfile, and
         record the data we found there.  */
      objfile->sym_dwarf2_info
        = obstack_alloc (&objfile->symbol_obstack, sizeof (*real_info));
      memcpy (&objfile->sym_dwarf2_info, &symfile_info, sizeof (symfile_info));

      /* Record whether addresses are signed or not.  */
      {
        int signed_addr = bfd_get_sign_extend_vma (abfd);
        if (signed_addr < 0)
          internal_error (__FILE__, __LINE__,
                          "read_comp_unit_head: dwarf from non elf file");
        objfile->sym_dwarf2_info->signed_addr_p = signed_addr;
      }

      return 1;
a1031 2

  return 0;
d1034 1
a1035 1
/* Build a partial symbol table.  */
a1038 1
  struct dwarf2_symfile_info *info = objile->sym_dwarf2_info;
a1040 2
  dwarf2_read_section (objfile, &info->info);
  dwarf2_read_section (objfile, &info->abbrev);
d1042 27
a1068 4
  /* Read these sections if they're present.  */
  if (info->line.offset)     dwarf2_read_section (objfile, &info->line);
  if (info->str.offset)      dwarf2_read_section (objfile, &info->str);
  if (info->macinfo.offset)  dwarf2_read_section (objfile, &info->macinfo);
d1077 15
a1091 1
  dwarf2_build_psymtabs_hard (objfile, mainline);
d1094 38
d1140 1
d1142 1
a1142 3
  cu_header->length = read_initial_length (abfd, info_ptr,
                                           &cu_header->initial_length_size,
                                           &cu_header->offset_size,
d1152 5
a1159 1

d1169 2
a1170 3
  struct dwarf2_symfile_info *sf_info = objfile->sym_dwarf2_info;
  char *info_ptr, *info_end;
  char *abbrev_ptr, *abbrev_end;
d1176 2
a1177 17
  /* The number of entries allocated to cu_table.  */
  int cu_table_allocated = 1;   /* small for testing */

  /* A table of all the compilation units in this objfile, sorted by
     their header_offset.  */
  struct dwarf2_cu **cu_table
    = (struct dwarf2_cu **) xmalloc (cu_table_allocated * sizeof (*cu_table));

  /* The number of entries in cu_table.  */
  int cu_table_len = 0;

  make_cleanup (xfree, cu_table);

  info_ptr = sf_info->info.buffer;
  info_end = info_ptr + sf_info->info.size;
  abbrev_ptr = sf_info->abbrev.buffer;
  abbrev_end = abbrev_ptr + sf_info->abbrev.size;
d1223 1
a1223 1
  while (info_ptr < info_end)
d1225 28
a1252 25
      char *beg_of_comp_unit = info_ptr;
      struct dwarf2_cu *cu
        = (struct dwarf2_cu *) obstack_alloc (&objfile->psymbol_obstack,
                                              sizeof (*cu));
      struct comp_unit_header *header = &cu->header;

      memset (cu, 0, sizeof (*cu));

      cu->objfile = objfile;
      cu->header_offset = beg_of_comp_unit - sf_info->info.buffer;
      info_ptr = read_comp_unit_head (header, info_ptr, abfd);

      if (cu->header_offset + header->initial_length_size + header->length
          > sf_info->info.size)
        error ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0).",
               (long) header->length,
               (long) cu->header_offset);
      if (header->version != 2)
        error ("Dwarf Error: wrong version in compilation unit header.");
      if (header->abbrev_offset >= sf_info->abbrev.size)
        error ("Dwarf Error: bad .debug_abbrev offset (0x%lx)\n"
               "in compilation unit header (.debug_info offset 0x%lx + %d).",
               (long) header->abbrev_offset,
               (long) cu->header_offset,
               cu->initial_length_size + 2);
d1255 2
a1256 2
      dwarf2_read_abbrevs (cu);
      make_cleanup (dwarf2_cleanup_abbrev_table, (void *) cu);
d1259 2
a1260 1
      info_ptr = read_partial_die (&comp_unit_die, cu, info_ptr);
d1263 1
a1263 1
      set_cu_language (cu, comp_unit_die.language);
d1272 14
a1285 3
      pst->read_symtab_private = (char *) cu;
      cu->baseaddr = ANOFFSET (objfile->section_offsets,
                               SECT_OFF_TEXT (objfile));
d1295 2
a1296 1
	  info_ptr = scan_partial_symbols (cu, info_ptr, &lowpc, &highpc);
d1306 2
a1307 2
      pst->textlow = comp_unit_die.lowpc + cu->baseaddr;
      pst->texthigh = comp_unit_die.highpc + cu->baseaddr;
d1320 3
a1322 24
      /* Add this CU to cu_table, growing it if necessary.  */
      if (cu_table_len >= cu_table_allocated)
        {
          cu_table_allocated *= 2;
          cu_table = (struct dwarf2_cu **) xrealloc (cu_table_allocated
                                                     * sizeof (*cu_table));
        }
      cu_table[cu_table_len++] = cu;

      /* Advance to the start of the next CU, according to the length
         in the header.  */
      info_ptr = (beg_of_comp_unit
                  + cu->header.initial_length_size
                  + cu->header.length);
    }

  /* Initialize the Dwarf 2 symfile info's table of compilation units
     from cu_table and cu_table_len.  */
  sf_info->cu_table
    = (struct dwarf2_cu **) obstack_alloc (&objfile->psymbol_obstack,
                                           cu_table_len * sizeof (*cu_table));
  memcpy (sf_info->cu_table, cu_table, cu_table_len * sizeof (*cu_table));
  sf_info->cu_table_len = cu_table_len;

a1325 1

d1329 3
a1331 2
scan_partial_symbols (struct dwarf2_cu *cu, char *info_ptr,
		      CORE_ADDR *lowpc, CORE_ADDR *highpc)
d1333 1
d1360 1
a1360 1
      info_ptr = read_partial_die (&pdi, cu, info_ptr);
d1380 1
a1380 1
		      add_partial_symbol (&pdi, cu);
d1393 1
a1393 1
		  add_partial_symbol (&pdi, cu);
d1402 1
a1402 1
		add_partial_symbol (&pdi, cu);
d1408 1
a1408 1
		add_partial_symbol (&pdi, cu);
d1460 2
a1461 1
add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)
a1462 1
  struct objfile *objfile = cu->objfile;
d1609 1
a1609 1
  offset = DWARF_CU_HEADER_OFFSET (pst);
d3454 3
a3456 3
static void
dwarf2_read_section (struct objfile *objfile,
                     struct dwarf2_section *section)
d3461 2
a3462 9
  if (section->offset == 0)
    return;

  if (section->size == 0)
    {
      /* Consider it "read".  */
      section->buffer = "";
      return;
    }
a3468 1
      obstack_free (&objfile->psymbol_obstack, buf);
d3472 1
a3472 2

  section->buffer = buf;
d3475 4
d3480 7
a3486 44
/* In DWARF version 2, each die in the .debug_info section starts with
   an "abbreviation number", which is an index into a table of
   abbreviations; each abbreviation entry gives the die's tag, its
   attributes and their forms, and whether it has children.  Dies with
   the same layout can share abbrev entries; since the compiler
   doesn't generate dies with that many different layouts, the sharing
   saves a lot of space.

   The abbrev info in the executable doesn't take up much space; all
   the abbrevs for all the compilation units in GDB are 200k.
   However, the in-core form (struct abbrev_info and a chain of struct
   attr_abbrev entries) generally takes up four times as much space.
   That's a little too much to just keep around.  So we generally free
   each CU's abbrev table as soon as we're done with it.  */

static
dwarf2_read_abbrevs (struct dwarf2_cu *cu)
{
  bfd *abfd = cu->objfile->obfd;
  struct abbrev_table *table;
  struct dwarf2_section abbrev_section = &cu->objfile->sym_dwarf2_info->abbrev;
  char *abbrev_ptr = abbrev_section->buffer + cu->header.abbrev_offset;
  char *abbrev_end = abbrev_section->buffer + abbrev_section->size;
  int num_abbrevs = 0;

  table = (struct abbrev_table *) xmalloc (sizeof (*table));
  table->num_buckets = ABBREV_HASH_SIZE;
  table->buckets =
    ((struct abbrev_info **) xmalloc (table->num_buckets
                                      * sizeof (table->buckets[0])));
  memset (table->buckets, 0, table->num_buckets * sizeof (table->buckets[0]));
  cu->abbrevs = table;

  for (;;)
    {
      unsigned int number, bytes_read;
      struct abbrev_info *cur_abbrev;

      /* Under Irix6 the abbreviations for a compilation unit are not
         always properly terminated with an abbrev number of 0, so
         exit the loop if we've reached the end of the .debug_abbrev
         section.  */
      if (abbrev_ptr >= abbrev_end)
        break;
d3488 3
a3490 3
      /* Read the abbreviation number.  */
      number = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
      abbrev_ptr += bytes_read;
d3492 3
a3494 10
      /* An abbrev number of zero marks the end of the abbreviation table.  */
      if (! number)
        break;

      /* Again, for Irix 6, exit the loop if we encounter an
         abbreviation which we have already read (which means we are
         about to read the abbreviations for the next compile
         unit).  */
      if (dwarf2_lookup_abbrev (cu, number) != NULL)
	break;
d3496 3
a3498 1
      /* Allocate a fresh abbrev structure.  */
d3502 1
a3502 1
      cur_abbrev->number = number;
d3508 7
a3514 15
      for (;;)
        {
          unsigned int attr_name, attr_form;

          /* First, read in the attribute name and form.  */
          attr_name = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
          abbrev_ptr += bytes_read;
          attr_form = read_unsigned_leb128 (abfd, abbrev_ptr, &bytes_read);
          abbrev_ptr += bytes_read;

          /* An entry whose name and form are both zero marks the end
             of the list.  */
          if (! attr_name)
            break;

d3522 26
a3547 45

	  cur_abbrev->attrs[cur_abbrev->num_attrs].name = attr_name;
	  cur_abbrev->attrs[cur_abbrev->num_attrs].form = attr_form;
          cur_abbrev->num_attrs++;
	}

      num_abbrevs++;

      /* Add this abbrev to the hash table.  */
      {
        int hash = number % table->num_buckets;
        cur_abbrev->next = table->buckets[hash];
        table->buckets[hash] = cur_abbrev;
      }
    }

  /* Resize the bucket array if needed.  Normally you'd want a
     utilization lower than this, but most Dwarf 2 producers number
     their abbrevs sequentially, so as long as the table has more
     buckets than there are abbrevs, there are never any hash
     collisions.  */
  if (num_abbrevs >= table->num_buckets)
    {
      /* Resize the bucket array, and rehash the abbrevs.  */
      int new_num_buckets = num_abbrevs;
      struct abbrev_info **new_buckets
        ((struct abbrev_info **) xmalloc (new_num_buckets
                                          * sizeof (table->buckets[0])));
      int i;
      struct abbrev_info *a, *next;

      memset (new_buckets, 0, new_num_buckets * sizeof (new_buckets[0]));
            
      for (i = 0; i < table->num_buckets; i++)
        for (a = table->buckets[i]; a; a = next)
          {
            int hash = a->number % new_num_buckets;
            next = a->next;
            a->next = new_buckets[hash];
            new_buckets[hash] = a;
          }

      xfree (table->buckets);
      table->num_buckets = new_num_buckets;
      table->buckets = new_buckets;
d3551 1
d3553 1
a3553 1
/* Free the abbrev table TABLE, and the abbrevs it refers to.  */
d3555 1
a3555 1
dwarf2_free_abbrev_table (struct abbrev_table *table);
d3558 2
a3559 1
  struct abbrev_info *a, *next;
d3561 1
a3561 7
  for (i = 0; i < table->num_abbrevs; i++)
    for (a = table->buckets[i]; a; a = next)
      {
        next = a->next;
        xfree (a->attrs);
        xfree (a);
      }
d3563 13
a3575 12
  xfree (table->buckets);
  xfree (table);
}


static void
dwarf2_cleanup_abbrev_table (void *untyped_cu)
{
  struct dwarf2_cu *cu = untyped_cu;

  dwarf2_free_abbrev_table (cu->abbrevs);
  cu->abbrevs = 0;
d3578 1
a3579 2

/* Lookup abbrev NUMBER in CU's abbreviation table.  */
d3581 1
a3581 1
dwarf2_lookup_abbrev (unsigned int number, const struct dwarf2_cu *cu)
d3583 2
a3584 2
  struct abbrev_table *t = cu->abbrevs;
  struct abbrev_info *a;
d3586 2
a3587 3
  for (a = t->buckets[number % t->num_buckets]; a; a = a->next)
    if (a->number == number)
      return a;
d3589 7
a3598 1

d3602 2
a3603 2
read_partial_die (struct partial_die_info *part_die,
                  struct dwarf2_cu *cu, char *info_ptr)
a3604 1
  bfd *abfd = cu->objfile->obfd;
a3605 1
  char *info_buffer = cu->objfile->sym_dwarf2_info->info.buffer;
d3613 1
a3613 2
  memset (part_die, 0, sizeof (*part_die));

d3619 1
a3619 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
d3624 1
a3624 1
  part_die->offset = info_ptr - info_buffer;
d3631 2
a3632 1
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], cu, info_ptr);
d3694 2
a3695 2
	    part_die->sibling
              = info_buffer + dwarf2_get_ref_die_offset (&attr);
d3702 3
a3704 3
  /* If we found a specification or abstract origin attribute and the
     die has no name, try to find a name in the die the attribute
     refers to.  */
d3711 2
a3712 2
      spec_ptr = info_buffer + dwarf2_get_ref_die_offset (&spec_attr);
      read_partial_die (&spec_die, cu, spec_ptr);
d3793 2
a3794 1
                      struct dwarf2_cu *cu, char *info_ptr)
a3795 1
  bfd *abfd = cu->objfile->obfd;
d3804 1
a3804 1
      DW_ADDR (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
d3840 2
a3841 1
      DW_STRING (attr) = read_indirect_string (cu, info_ptr, &bytes_read);
d3877 1
a3877 1
      DW_UNSND (attr) = cu->header_offset + read_1_byte (abfd, info_ptr);
d3881 1
a3881 1
      DW_UNSND (attr) = cu->header_offset + read_2_bytes (abfd, info_ptr);
d3885 1
a3885 1
      DW_UNSND (attr) = cu->header_offset + read_4_bytes (abfd, info_ptr);
d3889 1
a3889 1
      DW_UNSND (attr) = cu->header_offset + read_8_bytes (abfd, info_ptr);
d3893 1
a3893 2
      DW_UNSND (attr) = (cu->header_offset
                         + read_unsigned_leb128 (abfd, info_ptr, &bytes_read));
d3899 1
a3899 1
      info_ptr = read_attribute_value (attr, form, cu, info_ptr);
d3912 2
a3913 1
                struct dwarf2_cu *cu, char *info_ptr)
d4054 1
a4054 3
read_initial_length (bfd *abfd, char *buf,
                     unsigned int *initial_length_size_p,
                     unsigned int *offset_size_p,
d4057 3
a4059 1
  LONGEST retval = bfd_get_32 (abfd, (bfd_byte *) buf);
d4065 5
a4069 4
      if (initial_length_size_p)
        *initial_length_size_p = 12;
      if (offset_size_p)
        *offset_size_p = 8;
d4077 5
a4081 4
      if (initial_length_size_p)
        *initial_length_size_p = 8;
      if (offset_size_p)
        *offset_size_p = 8;
d4086 5
a4090 4
      if (initial_length_size_p)
        *initial_length_size_p = 4;
      if (offset_size_p)
        *offset_size_p = 4;
d4093 1
a4093 1
  return retval;
d4100 2
a4101 1
read_offset (struct dwarf2_cu *cu, char *buf, int *bytes_read)
a4102 1
  bfd *abfd = cu->objfile->obfd;
d4105 1
a4105 1
  switch (cu->header.offset_size)
d4150 2
a4151 1
read_indirect_string (struct dwarf2_cu *cu, char *buf,
d4154 2
a4155 1
  struct dwarf2_section *str = &cu->objfile->sym_dwarf2_info->str;
d4157 1
a4157 3
  LONGEST str_offset = read_offset (cu, buf, (int *) bytes_read_ptr);

  if (! str->buffer)
d4162 1
a4162 1
  if (str_offset >= str->size)
d4168 1
a4168 1
  if (str->buffer[str_offset] == '\0')
d4170 1
a4170 1
  return str->buffer + str_offset;
d4234 1
a4234 1
set_cu_language (struct dwarf2_cu *cu, unsigned int lang)
d4240 1
a4240 1
      cu->language = language_c;
d4243 1
a4243 1
      cu->language = language_cplus;
d4248 1
a4248 1
      cu->language = language_fortran;
d4251 1
a4251 1
      cu->language = language_asm;
d4254 1
a4254 1
      cu->language = language_java;
d4263 1
a4263 1
      cu->language = language_unknown;
d4266 1
a4266 1
  cu->language_defn = language_def (cu->language);
d4424 1
a4424 2
  lh->total_length = read_initial_length (abfd, line_ptr, NULL, NULL,
                                          &bytes_read);
d4795 1
a4795 1
      SYMBOL_LANGUAGE (sym) = cu->language;
d5016 1
a5016 1
	  if (cu->language == language_cplus)
d5221 18
d5386 33
d6209 75
d6386 2
d6393 1
a6393 1
      result = DW_ADDR (attr);
d6396 1
a6396 3
      complain (&dwarf2_unsupported_die_ref_attr,
                dwarf_form_name (attr->form));
      break;
d6435 1
a6435 1
      ftypes[typeid] = cu->language_defn->la_fund_type (objfile, typeid);
@


1.70
log
@2002-10-21  Jim Blandy  <jimb@@redhat.com>
	    Elena Zannoni  <ezannoni@@redhat.com>

	* symtab.h (address_class): Re-add LOC_THREAD_LOCAL_STATIC
	for thread local storage locations.
	(struct symbol): Add objfile field.
	(SYMBOL_OBJFILE): Define.
	* dwarf2read.c (is_thread_local): New static variable.
	(new_symbol): If variable is in thread local fill in address class
	and objfile appropriately.
	(decode_locdesc): Recognize and handle DW_OP_GNU_push_tls_address
	stack operation.
	* printcmd.c (address_info): Print the information for thread
	local storage variable.
	* findvar.c (read_var_value): In case of thread local variable,
	defer to the target vector code to compute address.
@
text
@d851 3
d1344 11
d1377 1
a1377 1
		  if ((pdi.is_external || nesting_level == 1)
d1390 1
a1390 1
	      if ((pdi.is_external || nesting_level == 1)
d1397 5
a1401 3
	      /* File scope enumerators are added to the partial symbol
	         table.  */
	      if (nesting_level == 2)
d1407 1
a1407 1
	      if (nesting_level == 1)
d1410 7
d1422 7
a1428 4
      /* If the die has a sibling, skip to the sibling.
         Do not skip enumeration types, we want to record their
         enumerators.  */
      if (pdi.sibling && pdi.tag != DW_TAG_enumeration_type)
d1434 2
a1435 2
	  /* Die has children, but the optional DW_AT_sibling attribute
	     is missing.  */
d1442 7
d1748 13
d2976 21
d5582 16
d5742 24
a5765 1

d6202 2
@


1.69
log
@Address class support.
@
text
@d413 6
d4797 8
d4813 1
a4813 1
		  if (SYMBOL_VALUE_ADDRESS (sym))
d4863 5
d6380 1
d6603 10
@


1.68
log
@2002-10-08  Petr Sorfa <petrs@@caldera.com>

Revised and re-submitted by John Wolfe <jlw@@caldera.com>

Move the Dwarf 2 abbrev table to a per-compilation-unit structure,
so we can work on more than one compilation unit at a time.  This
helps prepare GDB to handle inter-CU die references.
* dwarf2read.c (ABBREV_HASH_SIZE): moved definition forward in
the code to be defined before struct comp_unit_head.
(comp_unit_head): Added new members - offset, cu_head,
begin_die, next and dwarf2_abbrevs.
(dwarf2_abbrevs): Removed single static var; now member of
struct comp_unit_head.
dwarf2_build_psymtabs_hard): Complete new struct comp_unit_head
members.
(psymtab_to_symtab_1): Changed to work with the new
struct comp_unit_head.
(dwarf2_read_abbrevs): Now accepts a cu_header parameter and
constructs the dwarf2_abbrevs[] inside the cu_header.
(dwarf2_empty_abbrev_table): Now expects a ptr to a
dwarf2_abbrev table to clean up.
(dwarf2_lookup_abbrev): Now accepts a cu_header parameter and
handling of dwarf2_abbrevs inside the cu_header.
(read_partial_die): Now supports the call to the new
dwarf2_lookup_abbrev.
(read_full_die): Now supports the call to the new
dwarf2_lookup_abbrev.
@
text
@d686 4
d2932 3
a2934 1
  struct attribute *attr;
d2942 10
a2951 5
  attr = dwarf_attr (die, DW_AT_byte_size);
  if (attr)
    {
      TYPE_LENGTH (type) = DW_UNSND (attr);
    }
d2953 6
d2960 15
a2974 1
      TYPE_LENGTH (type) = cu_header->addr_size;
d2976 2
@


1.67
log
@2002-10-01  Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2read.c (dwarf_stack_op_name): Recognize more dwarf3 and
	GNU operators.
@
text
@d165 5
d182 23
a342 5
/* We only hold one compilation unit's abbrevs in
   memory at any one time.  */
#ifndef ABBREV_HASH_SIZE
#define ABBREV_HASH_SIZE 121
#endif
a346 2
static struct abbrev_info *dwarf2_abbrevs[ABBREV_HASH_SIZE];

d710 1
a710 1
static void dwarf2_read_abbrevs (bfd *, unsigned int);
d714 2
a715 1
static struct abbrev_info *dwarf2_lookup_abbrev (unsigned int);
d1236 5
d1242 2
a1243 2
      dwarf2_read_abbrevs (abfd, cu_header.abbrev_offset);
      make_cleanup (dwarf2_empty_abbrev_table, NULL);
d1590 2
a1591 2
  dwarf2_read_abbrevs (abfd, cu_header.abbrev_offset);
  make_cleanup (dwarf2_empty_abbrev_table, NULL);
d3375 1
a3375 1
dwarf2_read_abbrevs (bfd *abfd, unsigned int offset)
d3382 3
a3384 2
  /* empty the table */
  dwarf2_empty_abbrev_table (NULL);
d3386 1
a3386 1
  abbrev_ptr = dwarf_abbrev_buffer + offset;
d3425 2
a3426 2
      cur_abbrev->next = dwarf2_abbrevs[hash_number];
      dwarf2_abbrevs[hash_number] = cur_abbrev;
d3440 1
a3440 1
      if (dwarf2_lookup_abbrev (abbrev_number) != NULL)
d3449 1
a3449 1
dwarf2_empty_abbrev_table (PTR ignore)
d3453 3
d3460 1
a3460 1
      abbrev = dwarf2_abbrevs[i];
d3468 1
a3468 1
      dwarf2_abbrevs[i] = NULL;
d3475 1
a3475 1
dwarf2_lookup_abbrev (unsigned int number)
d3481 1
a3481 1
  abbrev = dwarf2_abbrevs[hash_number];
d3513 1
a3513 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number);
d3657 1
a3657 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number);
@


1.67.2.1
log
@2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (buildsym.o): Depend on $(gdb_assert_h) and
	$(cp_support_h).
	(cp-support.o): Fix dependencies and add $(gdb_obstack_h) and
	$(gdb_assert_h).
	(symtab.o): Depend on $(cp_support_h).
	* symtab.h: Add opaque declaration for struct using_direct_node.
	(struct block): Add member 'language_specific'.
	(BLOCK_USING): New macro.
	* symtab.c: #include "cp-support.h"
	(lookup_symbol_aux): Call lookup_symbol_aux_nonlocal and
	lookup_symbol_aux_using when appropriate.
	(lookup_symbol_aux_nonlocal): New function.
	(lookup_symbol_aux_using): New function.
	(lookup_symbol_aux_using_loop): New function.
	* symfile.h: Add opaque declaration for struct obstack.
	Declare obsavestring to take a const char *.
	* symfile.c (obsavestring): Make first argument a const char *.
	* jv-lang.c (get_java_class_symtab): Initialize BLOCK_USING.
	* dwarf2read.c: New variable current_namespace.
	(scan_partial_symbols): Handle DW_TAG_namespace.
	(psymtab_to_symtab_1): Initialize current_namespace.
	(process_die): Handle DW_TAG_namespace,
	DW_TAG_imported_declaration, DW_TAG_imported_module.
	(read_namespace): New function.
	(dwarf2_name): New function.
	(dwarf2_extension): New function.
	(dwarf_tag_name): Add DWARF 3 names.
	(dwarf_attr_name): Ditto.
	(dwarf_type_encoding_name): Ditto.
	* cp-support.h: Opaque declaration for struct obstack.
	(struct using_direct): New struct.
	(struct using_direct_node): New struct.
	Add declarations for cp_add_using_obstack, cp_add_using_xmalloc,
	cp_copy_usings, cp_free_usings,	cp_find_first_component.
	* cp-support.c: #include "gdb_obstack.h", "gdb_assert.h".
	Comment on demangled name pitfalls.
	(cp_add_using_obstack): New function.
	(cp_add_using_xmalloc): New function.
	(cp_copy_usings): New function.
	(cp_free_usings): New function.
	(cp_find_first_component): New function.
	* buildsym.h: Declare processing_has_namespace_info.
	Declare add_using_directive.
	* buildsym.c: #include "gdb_assert.h", "cp-support.h".
	Change comment after #include "symfile.h".
	New variable using_list.
	(add_symbol_to_list): Scan for anonymous namespaces when
	appropriate.
	(scan_for_anonymous_namespaces): New function.
	(add_using_directive): New function.
	(start_symtab): Initialize processing_has_namespace_info,
	using_list.
	(end_symtab): Copy using_list into block.
	(copy_usings_to_obstack): New function.
	(finish_block): Set BLOCK_USING in general case and in C++
	function case.

2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Add tests involving namespaces
	  starting from C.
	* gdb.c++/namespace.cc: Add namespaces with names starting
	  from C and their contents.
@
text
@a369 7
/* If we're debugging C++ code, this string should contain the name of
   the current namespace.  Other people shouldn't have to copy it when
   referring to it, so don't free its previous contents when setting
   this to a new value.  */

static const char *current_namespace;

a818 3
static void read_namespace (struct die_info *die, struct objfile *objfile,
			    const struct comp_unit_head *cu_header);

a861 4
static char *dwarf2_name (struct die_info *);

static struct die_info *dwarf2_extension (struct die_info *die);

a1303 5
  /* What level do we consider to be file scope?  This is normally 1,
     but can get pushed up by DW_TAG_namespace entries.  */
  
  int file_scope_level = 1;

d1326 1
a1326 1
		  if ((pdi.is_external || nesting_level == file_scope_level)
d1339 1
a1339 1
	      if ((pdi.is_external || nesting_level == file_scope_level)
d1348 1
a1348 1
	      if (nesting_level == file_scope_level + 1)
d1354 1
a1354 1
	      if (nesting_level == file_scope_level)
a1356 7
	    case DW_TAG_namespace:
	      /* FIXME: carlton/2002-10-16: we're not yet doing
		 anything useful with this, but for now make sure that
		 these tags at least don't cause us to miss any
		 important symbols.  */
	      if (pdi.has_children)
		file_scope_level++;
d1362 4
a1365 7
      /* If the die has a sibling, skip to the sibling.  Do not skip
         enumeration types, we want to record their enumerators.  Do
         not skip namespaces, we want to record symbols inside
         them.  */
      if (pdi.sibling
	  && pdi.tag != DW_TAG_enumeration_type
	  && pdi.tag != DW_TAG_namespace)
d1371 2
a1372 2
	  /* Die has children, but either the optional DW_AT_sibling
	     attribute is missing or we want to look at them.  */
a1378 4
	  /* If this is the end of a DW_TAG_namespace entry, then
	     decrease the file_scope_level, too.  */
	  if (nesting_level < file_scope_level)
	    file_scope_level--;
a1552 3
  /* We're in the global namespace.  */
  current_namespace = "";

a1677 15
    case DW_TAG_namespace:
      processing_has_namespace_info = 1;
      read_namespace (die, objfile, cu_header);
      break;
    case DW_TAG_imported_declaration:
    case DW_TAG_imported_module:
      /* FIXME: carlton/2002-10-16: Eventually, we should use the
	 information contained in these.  DW_TAG_imported_declaration
	 dies shouldn't have children; DW_TAG_imported_module dies
	 shouldn't in the C++ case, but conceivably could in the
	 Fortran case, so we'll have to replace this gdb_assert if
	 Fortran compilers start generating that info.  */
      processing_has_namespace_info = 1;
      gdb_assert (!die->has_children);
      break;
a2892 60
/* Read a C++ namespace.  */

/* FIXME: carlton/2002-10-16: For now, we don't actually do anything
   useful with the namespace data: we just process its children.  */

static void
read_namespace (struct die_info *die, struct objfile *objfile,
		const struct comp_unit_head *cu_header)
{
  const char *previous_namespace = current_namespace;
  const char *name = NULL;
  int is_anonymous;
  struct die_info *current_die;

  /* Loop through the extensions until we find a name.  */

  for (current_die = die; current_die != NULL;
       current_die = dwarf2_extension (die))
    {
      name = dwarf2_name (die);
      if (name != NULL)
	break;
    }

  /* Is it an anonymous namespace?  */

  is_anonymous = (name == NULL);
  if (is_anonymous)
    name = "(anonymous namespace)";

  /* Now build the name of the current namespace.  */

  current_namespace = obconcat (&objfile->symbol_obstack,
				previous_namespace,
				previous_namespace[0] == '\0' ? "" : "::",
				name);

  /* If it's an anonymous namespace that we're seeing for the first
     time, add a using directive.  */

  if (is_anonymous && dwarf_attr (die, DW_AT_extension) == NULL)
    add_using_directive (current_namespace,
			 strlen (previous_namespace),
			 strlen (current_namespace));
  
  
  if (die->has_children)
    {
      struct die_info *child_die = die->next;
      
      while (child_die && child_die->tag)
	{
	  process_die (child_die, objfile, cu_header);
	  child_die = sibling_die (child_die);
	}
    }

  current_namespace = previous_namespace;
}

a5328 37
/* Get name of a die, return NULL if not found.  */

static char *
dwarf2_name (struct die_info *die)
{
  struct attribute *attr;

  attr = dwarf_attr (die, DW_AT_name);
  if (attr && DW_STRING (attr))
    return DW_STRING (attr);
  return NULL;
}

/* Return the die that this die in an extension of, or NULL if there
   is none.  */

static struct die_info *
dwarf2_extension (struct die_info *die)
{
  struct attribute *attr;
  struct die_info *extension_die;
  unsigned int ref;

  attr = dwarf_attr (die, DW_AT_extension);
  if (attr == NULL)
    return NULL;

  ref = dwarf2_get_ref_die_offset (attr);
  extension_die = follow_die_ref (ref);
  if (!extension_die)
    {
      error ("Dwarf Error: Cannot find referent at offset %d.", ref);
    }

  return extension_die;
}

a5431 16
    case DW_TAG_dwarf_procedure:
      return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:
      return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:
      return "DW_TAG_interface_type";
    case DW_TAG_namespace:
      return "DW_TAG_namespace";
    case DW_TAG_imported_module:
      return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:
      return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:
      return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:
      return "DW_TAG_imported_unit";
d5576 1
a5576 24
    case DW_AT_allocated:
      return "DW_AT_allocated";
    case DW_AT_associated:
      return "DW_AT_associated";
    case DW_AT_data_location:
      return "DW_AT_data_location";
    case DW_AT_stride:
      return "DW_AT_stride";
    case DW_AT_entry_pc:
      return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:
      return "DW_AT_use_UTF8";
    case DW_AT_extension:
      return "DW_AT_extension";
    case DW_AT_ranges:
      return "DW_AT_ranges";
    case DW_AT_trampoline:
      return "DW_AT_trampoline";
    case DW_AT_call_column:
      return "DW_AT_call_column";
    case DW_AT_call_file:
      return "DW_AT_call_file";
    case DW_AT_call_line:
      return "DW_AT_call_line";
a6012 2
    case DW_ATE_imaginary_float:
      return "DW_ATE_imaginary_float";
@


1.67.2.2
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a164 5
/* We hold several abbreviation tables in memory at the same time. */
#ifndef ABBREV_HASH_SIZE
#define ABBREV_HASH_SIZE 121
#endif

a176 23

    /* Offset to the first byte of this compilation unit header in the 
     * .debug_info section, for resolving relative reference dies. */

    unsigned int offset;

    /* Pointer to this compilation unit header in the .debug_info
     * section */

    char *cu_head_ptr;

    /* Pointer to the first die of this compilatio unit.  This will
     * be the first byte following the compilation unit header. */

    char *first_die_ptr;

    /* Pointer to the next compilation unit header in the program. */

    struct comp_unit_head *next;

    /* DWARF abbreviation table associated with this compilation unit */

    struct abbrev_info *dwarf2_abbrevs[ABBREV_HASH_SIZE];
d315 5
d324 2
a398 6
static int is_thread_local;     /* Variable is at a constant offset in the
                                   thread-local storage block for the
                                   current thread and the dynamic linker
                                   module containing this expression.
                                   decode_locdesc returns the offset from
                                   that base.  */
a671 4
static struct complaint dwarf2_invalid_pointer_size = 
{
  "invalid pointer size %d", 0, 0
};
d696 1
a696 1
static void dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header);
d700 1
a700 2
static struct abbrev_info *dwarf2_lookup_abbrev (unsigned int,
                                         const struct comp_unit_head *cu_header);
a1227 5
      /* Complete the cu_header */
      cu_header.offset = beg_of_comp_unit - dwarf_info_buffer;
      cu_header.first_die_ptr = info_ptr;
      cu_header.cu_head_ptr = beg_of_comp_unit;

d1229 2
a1230 2
      dwarf2_read_abbrevs (abfd, &cu_header);
      make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
d1318 2
a1319 8
  /* We only want to read in symbols corresponding to variables or
     other similar objects that are global or static.  Normally, these
     are all children of the DW_TAG_compile_unit die, so are all at
     level 1.  But C++ namespaces give rise to DW_TAG_namespace dies
     whose children are global objects.  So we keep track of what
     level we currently think of as referring to file scope; this
     should always equal 1 plus the number of namespaces that we are
     currently nested within.  */
d1365 2
a1366 4
	      /* File scope enumerators are added to the partial
	         symbol table.  They're children of the enumeration
	         type die, so they occur at a level one higher than we
	         normally look for.  */
d1411 1
a1411 4
	    {
	      file_scope_level--;
	      gdb_assert (nesting_level == file_scope_level);
	    }
d1599 2
a1600 2
  dwarf2_read_abbrevs (abfd, &cu_header);
  make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
d3012 1
a3012 3
  struct attribute *attr_byte_size;
  struct attribute *attr_address_class;
  int byte_size, addr_class;
d3020 5
a3024 4

  attr_byte_size = dwarf_attr (die, DW_AT_byte_size);
  if (attr_byte_size)
    byte_size = DW_UNSND (attr_byte_size);
a3025 12
    byte_size = cu_header->addr_size;

  attr_address_class = dwarf_attr (die, DW_AT_address_class);
  if (attr_address_class)
    addr_class = DW_UNSND (attr_address_class);
  else
    addr_class = DW_ADDR_none;

  /* If the pointer size or address class is different than the
     default, create a type variant marked as such and set the
     length accordingly.  */
  if (TYPE_LENGTH (type) != byte_size || addr_class != DW_ADDR_none)
d3027 1
a3027 15
      if (ADDRESS_CLASS_TYPE_FLAGS_P ())
	{
	  int type_flags;

	  type_flags = ADDRESS_CLASS_TYPE_FLAGS (byte_size, addr_class);
	  gdb_assert ((type_flags & ~TYPE_FLAG_ADDRESS_CLASS_ALL) == 0);
	  type = make_type_with_address_space (type, type_flags);
	}
      else if (TYPE_LENGTH (type) != byte_size)
	{
	  complain (&dwarf2_invalid_pointer_size, byte_size);
	}
      else {
	/* Should we also complain about unhandled address classes?  */
      }
a3028 2

  TYPE_LENGTH (type) = byte_size;
d3459 1
a3459 1
dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header)
d3466 2
a3467 3
  /* Initialize dwarf2 abbrevs */
  memset (cu_header->dwarf2_abbrevs, 0,
          ABBREV_HASH_SIZE*sizeof (struct abbrev_info *));
d3469 1
a3469 1
  abbrev_ptr = dwarf_abbrev_buffer + cu_header->abbrev_offset;
d3508 2
a3509 2
      cur_abbrev->next = cu_header->dwarf2_abbrevs[hash_number];
      cu_header->dwarf2_abbrevs[hash_number] = cur_abbrev;
d3523 1
a3523 1
      if (dwarf2_lookup_abbrev (abbrev_number, cu_header) != NULL)
d3532 1
a3532 1
dwarf2_empty_abbrev_table (PTR ptr_to_abbrevs_table)
a3535 3
  struct abbrev_info **abbrevs;

  abbrevs = (struct abbrev_info **)ptr_to_abbrevs_table;
d3540 1
a3540 1
      abbrev = abbrevs[i];
d3548 1
a3548 1
      abbrevs[i] = NULL;
d3555 1
a3555 1
dwarf2_lookup_abbrev (unsigned int number, const struct comp_unit_head *cu_header)
d3561 1
a3561 1
  abbrev = cu_header->dwarf2_abbrevs[hash_number];
d3593 1
a3593 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
d3737 1
a3737 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
a4837 8
                  if (is_thread_local)
                    {
                      /* SYMBOL_VALUE_ADDRESS contains at this point the
		         offset of the variable within the thread local
			 storage.  */
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }
d4846 1
a4846 1
		  else if (SYMBOL_VALUE_ADDRESS (sym))
a4895 5
                  else if (is_thread_local)
                    {
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }
a6485 1
  is_thread_local = 0;
a6707 10

        case DW_OP_GNU_push_tls_address:
          is_thread_local = 1;
	  /* The top of the stack has the offset from the beginning
	     of the thread control block at which the variable is located.  */
	  /* Nothing should follow this operator, so the top of stack would
	     be returned.  */
	  if (i < size)
	    complain (&dwarf2_complex_location_expr);
          break;
@


1.67.2.3
log
@2002-11-22  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Add opaque declarations for struct namespace_info and
	struct obstack.
	(struct block): The language_specific stuff is now a struct
	namespace_info rather than a struct using_direct_node.
	(BLOCK_NAMESPACE): New macro.
	Delete macro BLOCK_USING.
	Add declarations for block_using, block_all_usings,
	block_set_using, block_scope, block_set_scope.
	* symtab.c: #include "gdb_assert.h"
	(lookup_symbol_aux): Move minsym stuff inside
	lookup_symbol_aux_nonlocal, and always do global search via
	lookup_symbol_aux_using.
	(lookup_symbol_aux_nonlocal): Do minsym search.
	(lookup_symbol_aux_using): Calculate usings via block_all_usings;
	handle namespace scope.
	(lookup_symbol_aux_using_loop): New function, not to be confused
	with the previous function of the same name.  (Sorry about that.)
	(lookup_symbol_namespace): Renamed from
	lookup_symbol_aux_using_loop.
	(lookup_symbol_aux_minsyms): Add block_index argument, delete
	is_a_field_of_this argument, and only check either global or
	static symbols rather than both of them.
	(block_using): New function.
	(block_all_usings): New function.
	(block_set_using): New function.
	(block_scope): New function.
	(block_set_scope): New function.
	(block_initialize_namespace): New function.
	* jv-lang.c (get_java_class_symtab): BLOCK_NAMESPACE instead of
	BLOCK_USING.
	* dwarf2read.c: Delete variable current_namespace, and replace its
	uses by processing_current_namespace (from buildsym.h).
	(scan_partial_symbols): Allow empty pdi.name if we're
	reading a namespace.
	* cp-support.h (struct namespace_info): New struct.
	* cp-support.c: Add comment.
	* buildsym.h: New variable processing_current_namespace.
	* buildsym.c (add_symbol_to_list): Do fast search for
	"(anonymous namespace)".
	(scan_for_anonymous_namespaces): Delete FIXME.  Convert for loop
	into a clearer while loop.
	(finish_block): Replace BLOCK_USING by BLOCK_NAMESPACE.
	(finish_block): Set block_scope of function blocks rather than
	generating using directives that would have a similar effect.
	(end_symtab): Set using via block_set_using rather than
	BLOCK_USING.
	* Makefile.in (symtab.o): Depend on gdb_assert_h.
@
text
@d391 7
d1373 1
a1373 3
      /* Anonymous namespaces have no name but are interesting.  */

      if (pdi.name != NULL || pdi.tag == DW_TAG_namespace)
d1635 1
a1635 1
  processing_current_namespace = "";
d3001 1
a3001 1
  const char *previous_namespace = processing_current_namespace;
d3024 4
a3027 5
  processing_current_namespace = obconcat (&objfile->symbol_obstack,
					   previous_namespace,
					   previous_namespace[0] == '\0'
					   ? "" : "::",
					   name);
d3033 1
a3033 1
    add_using_directive (processing_current_namespace,
d3035 1
a3035 1
			 strlen (processing_current_namespace));
d3049 1
a3049 1
  processing_current_namespace = previous_namespace;
@


1.67.2.4
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d41 1
a44 4
#include "dwarf2expr.h"
#include "dwarf2loc.h"
#include "cp-support.h"

d128 11
a146 1
static unsigned int dwarf_ranges_size;
a149 12
static asection *dwarf_info_section;
static asection *dwarf_abbrev_section;
static asection *dwarf_line_section;
static asection *dwarf_pubnames_section;
static asection *dwarf_aranges_section;
static asection *dwarf_loc_section;
static asection *dwarf_macinfo_section;
static asection *dwarf_str_section;
static asection *dwarf_ranges_section;
asection *dwarf_frame_section;
asection *dwarf_eh_frame_section;

a159 1
#define RANGES_SECTION   ".debug_ranges"
a204 8

    /* Base address of this compilation unit.  */

    CORE_ADDR base_address;

    /* Non-zero if base_address has been set.  */

    int base_known;
a206 14
/* Internal state when decoding a particular compilation unit.  */
struct dwarf2_cu
{
  /* The objfile containing this compilation unit.  */
  struct objfile *objfile;

  /* The header of the compilation unit.

     FIXME drow/2003-11-10: Some of the things from the comp_unit_head
     should be moved to the dwarf2_cu structure; for instance the abbrevs
     hash table.  */
  struct comp_unit_head header;
};

d292 1
d298 1
a298 10

    /* The dies in a compilation unit form an n-ary tree.  PARENT
       points to this die's parent; CHILD points to the first child of
       this node; and all the children of a given node are chained
       together via their SIBLING fields, terminated by a die whose
       tag is zero.  */
    struct die_info *child;	/* Its first child, if any.  */
    struct die_info *sibling;	/* Its next sibling, if any.  */
    struct die_info *parent;	/* Its parent, if any.  */

a375 2
static char *dwarf_ranges_buffer;
static char *dwarf_loc_buffer;
d396 2
d401 26
a483 15
    /* Pointer to start of dwarf ranges buffer for the objfile.  */

    char *dwarf_ranges_buffer;

    /* Size of dwarf ranges buffer for the objfile.  */

    unsigned int dwarf_ranges_size;

    /* Pointer to start of dwarf locations buffer for the objfile.  */

    char *dwarf_loc_buffer;

    /* Size of dwarf locations buffer for the objfile.  */

    unsigned int dwarf_loc_size;
a496 4
#define DWARF_RANGES_BUFFER(p)  (PST_PRIVATE(p)->dwarf_ranges_buffer)
#define DWARF_RANGES_SIZE(p)    (PST_PRIVATE(p)->dwarf_ranges_size)
#define DWARF_LOC_BUFFER(p)     (PST_PRIVATE(p)->dwarf_loc_buffer)
#define DWARF_LOC_SIZE(p)       (PST_PRIVATE(p)->dwarf_loc_size)
d564 101
a664 2
static void
dwarf2_non_const_array_bound_ignored_complaint (const char *arg1)
d666 3
a668 6
  complaint (&symfile_complaints, "non-constant array bounds form '%s' ignored",
	     arg1);
}

static void
dwarf2_statement_list_fits_in_line_number_section_complaint (void)
d670 3
a672 6
  complaint (&symfile_complaints,
	     "statement list doesn't fit in .debug_line section");
}

static void
dwarf2_complex_location_expr_complaint (void)
d674 3
a676 5
  complaint (&symfile_complaints, "location expression too complex");
}

static void
dwarf2_unsupported_at_frame_base_complaint (const char *arg1)
d678 3
a680 7
  complaint (&symfile_complaints,
	     "unsupported DW_AT_frame_base for function '%s'", arg1);
}

static void
dwarf2_const_value_length_mismatch_complaint (const char *arg1, int arg2,
					      int arg3)
d682 3
a684 7
  complaint (&symfile_complaints,
	     "const value length mismatch for '%s', got %d, expected %d", arg1,
	     arg2, arg3);
}

static void
dwarf2_macros_too_long_complaint (void)
d686 3
a688 6
  complaint (&symfile_complaints,
	     "macro info runs off end of `.debug_macinfo' section");
}

static void
dwarf2_macro_malformed_definition_complaint (const char *arg1)
d690 3
a692 7
  complaint (&symfile_complaints,
	     "macro debug info contains a malformed macro definition:\n`%s'",
	     arg1);
}

static void
dwarf2_invalid_attrib_class_complaint (const char *arg1, const char *arg2)
d694 2
a695 3
  complaint (&symfile_complaints,
	     "invalid attribute class or form for '%s' in '%s'", arg1, arg2);
}
d699 1
a699 1
static void dwarf2_locate_sections (bfd *, asection *, void *);
d707 6
a712 22
static char *scan_partial_symbols (char *, CORE_ADDR *, CORE_ADDR *,
				   struct dwarf2_cu *,
				   const char *namespace);

static void add_partial_symbol (struct partial_die_info *, struct dwarf2_cu *,
				const char *namespace);

static char *add_partial_namespace (struct partial_die_info *pdi,
				    char *info_ptr,
				    CORE_ADDR *lowpc, CORE_ADDR *highpc,
				    struct dwarf2_cu *cu,
				    const char *namespace);

static char *add_partial_enumeration (struct partial_die_info *enum_pdi,
				      char *info_ptr,
				      struct dwarf2_cu *cu,
				      const char *namespace);

static char *locate_pdi_sibling (struct partial_die_info *orig_pdi,
				 char *info_ptr,
				 bfd *abfd,
				 struct dwarf2_cu *cu);
d718 1
a718 1
char *dwarf2_read_section (struct objfile *, asection *);
d720 1
a720 1
static void dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu);
d722 1
a722 1
static void dwarf2_empty_abbrev_table (void *);
d725 1
a725 1
						 struct dwarf2_cu *);
d728 2
a729 1
			       bfd *, char *, struct dwarf2_cu *);
d732 1
a732 1
			    struct dwarf2_cu *, int *);
d735 1
a735 1
			     bfd *, char *, struct dwarf2_cu *);
d738 1
a738 1
			     bfd *, char *, struct dwarf2_cu *);
d750 1
a750 1
static CORE_ADDR read_address (bfd *, char *ptr, struct dwarf2_cu *,
d780 2
a781 1
                             bfd *abfd, struct dwarf2_cu *cu));
d784 1
a784 1
				struct dwarf2_cu *);
d789 1
a789 1
				  struct dwarf2_cu *);
d792 1
a792 1
				struct dwarf2_cu *);
d798 2
a799 1
static struct type *die_type (struct die_info *, struct dwarf2_cu *);
d801 2
a802 2
static struct type *die_containing_type (struct die_info *,
					 struct dwarf2_cu *);
d808 2
a809 1
static struct type *tag_type_to_type (struct die_info *, struct dwarf2_cu *);
d811 2
a812 1
static void read_type_die (struct die_info *, struct dwarf2_cu *);
d814 2
a815 1
static void read_typedef (struct die_info *, struct dwarf2_cu *);
d817 1
a817 1
static void read_base_type (struct die_info *, struct dwarf2_cu *);
d819 2
a820 1
static void read_file_scope (struct die_info *, struct dwarf2_cu *);
d822 2
a823 1
static void read_func_scope (struct die_info *, struct dwarf2_cu *);
d825 2
a826 1
static void read_lexical_block_scope (struct die_info *, struct dwarf2_cu *);
d829 1
a829 1
				 CORE_ADDR *, CORE_ADDR *, struct dwarf2_cu *);
d832 1
a832 1
			      struct dwarf2_cu *);
d835 1
a835 1
					  struct type *, struct dwarf2_cu *);
d839 2
a840 1
				  struct dwarf2_cu *);
d843 1
a843 3
					     struct type *, struct dwarf2_cu *);

static void read_structure_scope (struct die_info *, struct dwarf2_cu *);
d845 2
a846 1
static void read_common_block (struct die_info *, struct dwarf2_cu *);
d848 2
a849 1
static void read_namespace (struct die_info *die, struct dwarf2_cu *);
d851 2
a852 1
static void read_enumeration (struct die_info *, struct dwarf2_cu *);
d854 2
a855 1
static struct type *dwarf_base_type (int, int, struct dwarf2_cu *);
d857 1
a857 1
static CORE_ADDR decode_locdesc (struct dwarf_block *, struct dwarf2_cu *);
d859 2
a860 1
static void read_array_type (struct die_info *, struct dwarf2_cu *);
d862 2
a863 1
static void read_tag_pointer_type (struct die_info *, struct dwarf2_cu *);
d865 2
a866 2
static void read_tag_ptr_to_member_type (struct die_info *,
					 struct dwarf2_cu *);
d868 2
a869 1
static void read_tag_reference_type (struct die_info *, struct dwarf2_cu *);
d871 2
a872 1
static void read_tag_const_type (struct die_info *, struct dwarf2_cu *);
d874 2
a875 1
static void read_tag_volatile_type (struct die_info *, struct dwarf2_cu *);
d877 2
a878 1
static void read_tag_string_type (struct die_info *, struct dwarf2_cu *);
d880 1
a880 1
static void read_subroutine_type (struct die_info *, struct dwarf2_cu *);
d882 2
a883 1
static struct die_info *read_comp_unit (char *, bfd *, struct dwarf2_cu *);
d885 2
a886 9
static struct die_info *read_die_and_children (char *info_ptr, bfd *abfd,
					       struct dwarf2_cu *,
					       char **new_info_ptr,
					       struct die_info *parent);

static struct die_info *read_die_and_siblings (char *info_ptr, bfd *abfd,
					       struct dwarf2_cu *,
					       char **new_info_ptr,
					       struct die_info *parent);
d892 2
a893 1
static void process_die (struct die_info *, struct dwarf2_cu *);
d897 1
a897 1
static char *dwarf2_name (struct die_info *die);
d937 1
a937 1
static void dwarf2_free_tmp_obstack (void *);
d950 2
a951 1
                                 char *, bfd *, struct dwarf2_cu *);
a954 4
static void
dwarf2_symbol_mark_computed (struct attribute *attr, struct symbol *sym,
			     struct dwarf2_cu *cu);

d961 7
a967 10
  dwarf_info_section = 0;
  dwarf_abbrev_section = 0;
  dwarf_line_section = 0;
  dwarf_str_section = 0;
  dwarf_macinfo_section = 0;
  dwarf_frame_section = 0;
  dwarf_eh_frame_section = 0;
  dwarf_ranges_section = 0;
  dwarf_loc_section = 0;
  
d969 8
a976 1
  return (dwarf_info_section != NULL && dwarf_abbrev_section != NULL);
d984 1
a984 1
dwarf2_locate_sections (bfd *ignore_abfd, asection *sectp, void *ignore_ptr)
d986 1
a986 1
  if (strcmp (sectp->name, INFO_SECTION) == 0)
d988 1
a989 1
      dwarf_info_section = sectp;
d991 1
a991 1
  else if (strcmp (sectp->name, ABBREV_SECTION) == 0)
d993 1
a994 1
      dwarf_abbrev_section = sectp;
d996 1
a996 1
  else if (strcmp (sectp->name, LINE_SECTION) == 0)
d998 1
a999 1
      dwarf_line_section = sectp;
d1001 1
a1001 1
  else if (strcmp (sectp->name, PUBNAMES_SECTION) == 0)
d1003 1
a1004 1
      dwarf_pubnames_section = sectp;
d1006 1
a1006 1
  else if (strcmp (sectp->name, ARANGES_SECTION) == 0)
d1008 1
a1009 1
      dwarf_aranges_section = sectp;
d1011 1
a1011 1
  else if (strcmp (sectp->name, LOC_SECTION) == 0)
d1013 1
a1014 1
      dwarf_loc_section = sectp;
d1016 1
a1016 1
  else if (strcmp (sectp->name, MACINFO_SECTION) == 0)
d1018 1
a1019 1
      dwarf_macinfo_section = sectp;
d1021 1
a1021 1
  else if (strcmp (sectp->name, STR_SECTION) == 0)
d1023 1
a1024 1
      dwarf_str_section = sectp;
d1026 1
a1026 1
  else if (strcmp (sectp->name, FRAME_SECTION) == 0)
d1028 1
a1029 1
      dwarf_frame_section = sectp;
d1031 1
a1031 1
  else if (strcmp (sectp->name, EH_FRAME_SECTION) == 0)
d1033 2
a1034 11
      flagword aflag = bfd_get_section_flags (ignore_abfd, sectp);
      if (aflag & SEC_HAS_CONTENTS)
        {
          dwarf_eh_frame_size = bfd_get_section_size_before_reloc (sectp);
          dwarf_eh_frame_section = sectp;
        }
    }
  else if (strcmp (sectp->name, RANGES_SECTION) == 0)
    {
      dwarf_ranges_size = bfd_get_section_size_before_reloc (sectp);
      dwarf_ranges_section = sectp;
d1046 11
a1056 5
  dwarf_info_buffer = dwarf2_read_section (objfile, dwarf_info_section);
  dwarf_abbrev_buffer = dwarf2_read_section (objfile, dwarf_abbrev_section);

  if (dwarf_line_section)
    dwarf_line_buffer = dwarf2_read_section (objfile, dwarf_line_section);
d1060 4
a1063 2
  if (dwarf_str_section)
    dwarf_str_buffer = dwarf2_read_section (objfile, dwarf_str_section);
d1067 1
a1067 1
  if (dwarf_macinfo_section)
d1069 2
a1070 1
						dwarf_macinfo_section);
a1073 10
  if (dwarf_ranges_section)
    dwarf_ranges_buffer = dwarf2_read_section (objfile, dwarf_ranges_section);
  else
    dwarf_ranges_buffer = NULL;

  if (dwarf_loc_section)
    dwarf_loc_buffer = dwarf2_read_section (objfile, dwarf_loc_section);
  else
    dwarf_loc_buffer = NULL;

d1111 2
a1112 1
					 dwarf_pubnames_section);
d1131 2
a1132 1
					dwarf_aranges_section);
d1229 1
a1229 1
      struct dwarf2_cu cu;
d1231 1
d1233 1
a1233 4
      cu.objfile = objfile;
      info_ptr = read_comp_unit_head (&cu.header, info_ptr, abfd);

      if (cu.header.version != 2)
d1235 1
a1235 1
	  error ("Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]", cu.header.version, 2, bfd_get_filename (abfd));
d1238 1
a1238 1
      if (cu.header.abbrev_offset >= dwarf_abbrev_size)
d1240 3
a1242 4
	  error ("Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6) [in module %s]",
		 (long) cu.header.abbrev_offset,
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
d1245 1
a1245 1
      if (beg_of_comp_unit + cu.header.length + cu.header.initial_length_size
d1248 3
a1250 4
	  error ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0) [in module %s]",
		 (long) cu.header.length,
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
d1254 3
a1256 3
      cu.header.offset = beg_of_comp_unit - dwarf_info_buffer;
      cu.header.first_die_ptr = info_ptr;
      cu.header.cu_head_ptr = beg_of_comp_unit;
d1259 2
a1260 2
      dwarf2_read_abbrevs (abfd, &cu);
      make_cleanup (dwarf2_empty_abbrev_table, cu.header.dwarf2_abbrevs);
d1264 1
a1264 1
				   &cu);
a1288 4
      DWARF_RANGES_BUFFER (pst) = dwarf_ranges_buffer;
      DWARF_RANGES_SIZE (pst) = dwarf_ranges_size;
      DWARF_LOC_BUFFER (pst) = dwarf_loc_buffer;
      DWARF_LOC_SIZE (pst) = dwarf_loc_size;
d1299 2
a1300 5
	  lowpc = ((CORE_ADDR) -1);
	  highpc = ((CORE_ADDR) 0);

	  info_ptr = scan_partial_symbols (info_ptr, &lowpc, &highpc,
					   &cu, NULL);
a1301 5
	  /* If we didn't find a lowpc, set it to highpc to avoid
	     complaints from `maint check'.  */
	  if (lowpc == ((CORE_ADDR) -1))
	    lowpc = highpc;
	  
d1324 2
a1325 2
      info_ptr = beg_of_comp_unit + cu.header.length 
                                  + cu.header.initial_length_size;
d1330 1
a1330 6
/* Read in all interesting dies to the end of the compilation unit or
   to the end of the current namespace.  NAMESPACE is NULL if we
   haven't yet encountered any DW_TAG_namespace entries; otherwise,
   it's the name of the current namespace.  In particular, it's the
   empty string if we're currently in the global namespace but have
   previously encountered a DW_TAG_namespace.  */
d1333 3
a1335 3
scan_partial_symbols (char *info_ptr, CORE_ADDR *lowpc,
		      CORE_ADDR *highpc, struct dwarf2_cu *cu,
		      const char *namespace)
a1336 1
  struct objfile *objfile = cu->objfile;
d1340 21
a1360 3
  /* Now, march along the PDI's, descending into ones which have
     interesting children but skipping the children of the other ones,
     until we reach the end of the compilation unit.  */
d1362 1
a1362 1
  while (1)
d1364 3
a1366 9
      /* This flag tells whether or not info_ptr has gotten updated
	 inside the loop.  */
      int info_ptr_updated = 0;

      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);

      /* Anonymous namespaces have no name but have interesting
	 children, so we need to look at them.  Ditto for anonymous
	 enums.  */
d1368 1
a1368 2
      if (pdi.name != NULL || pdi.tag == DW_TAG_namespace
	  || pdi.tag == DW_TAG_enumeration_type)
d1383 2
a1384 1
		  if (!pdi.is_declaration)
d1386 1
a1386 1
		      add_partial_symbol (&pdi, cu, namespace);
a1391 1
	    case DW_TAG_union_type:
d1394 4
a1397 1
	      if (!pdi.is_declaration)
d1399 1
a1399 1
		  add_partial_symbol (&pdi, cu, namespace);
d1402 7
a1408 7
	    case DW_TAG_enumeration_type:
	      if (!pdi.is_declaration)
		{
		  info_ptr = add_partial_enumeration (&pdi, info_ptr, cu,
						      namespace);
		  info_ptr_updated = 1;
		}
d1413 2
a1414 1
	      add_partial_symbol (&pdi, cu, namespace);
d1417 6
a1422 9
	      /* We've hit a DW_TAG_namespace entry, so we know this
		 file has been compiled using a compiler that
		 generates them; update NAMESPACE to reflect that.  */
	      if (namespace == NULL)
		namespace = "";
	      info_ptr = add_partial_namespace (&pdi, info_ptr, lowpc, highpc,
						cu, namespace);
	      info_ptr_updated = 1;
	      break;
d1428 17
d1446 10
a1455 12
	break;

      /* If the die has a sibling, skip to the sibling, unless another
	 function has already updated info_ptr for us.  */

      /* NOTE: carlton/2003-06-16: This is a bit hackish, but whether
	 or not we want to update this depends on enough stuff (not
	 only pdi.tag but also whether or not pdi.name is NULL) that
	 this seems like the easiest way to handle the issue.  */

      if (!info_ptr_updated)
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu);
d1458 4
d1466 2
a1467 2
add_partial_symbol (struct partial_die_info *pdi,
		    struct dwarf2_cu *cu, const char *namespace)
a1468 1
  struct objfile *objfile = cu->objfile;
a1469 1
  const struct partial_symbol *psym = NULL;
d1478 4
a1481 5
	  psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
				      VAR_DOMAIN, LOC_BLOCK,
				      &objfile->global_psymbols,
				      0, pdi->lowpc + baseaddr,
				      cu_language, objfile);
d1487 4
a1490 5
	  psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
				      VAR_DOMAIN, LOC_BLOCK,
				      &objfile->static_psymbols,
				      0, pdi->lowpc + baseaddr,
				      cu_language, objfile);
d1510 1
a1510 1
	    addr = decode_locdesc (pdi->locdesc, cu);
d1512 4
a1515 5
	    psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
					VAR_DOMAIN, LOC_STATIC,
					&objfile->global_psymbols,
					0, addr + baseaddr,
					cu_language, objfile);
d1522 1
a1522 1
	  addr = decode_locdesc (pdi->locdesc, cu);
d1525 4
a1528 5
	  psym = add_psymbol_to_list (pdi->name, strlen (pdi->name),
				      VAR_DOMAIN, LOC_STATIC,
				      &objfile->static_psymbols,
				      0, addr + baseaddr,
				      cu_language, objfile);
d1534 1
a1534 1
			   VAR_DOMAIN, LOC_TYPEDEF,
d1547 1
a1547 1
			   STRUCT_DOMAIN, LOC_TYPEDEF,
d1555 1
a1555 1
			       VAR_DOMAIN, LOC_TYPEDEF,
d1562 1
a1562 1
			   VAR_DOMAIN, LOC_CONST,
a1568 114

  /* Check to see if we should scan the name for possible namespace
     info.  Only do this if this is C++, if we don't have namespace
     debugging info in the file, if the psym is of an appropriate type
     (otherwise we'll have psym == NULL), and if we actually had a
     mangled name to begin with.  */

  if (cu_language == language_cplus
      && namespace == NULL
      && psym != NULL
      && SYMBOL_CPLUS_DEMANGLED_NAME (psym) != NULL)
    cp_check_possible_namespace_symbols (SYMBOL_CPLUS_DEMANGLED_NAME (psym),
					 objfile);
}

/* Read a partial die corresponding to a namespace; also, add a symbol
   corresponding to that namespace to the symbol table.  NAMESPACE is
   the name of the enclosing namespace.  */

static char *
add_partial_namespace (struct partial_die_info *pdi, char *info_ptr,
		       CORE_ADDR *lowpc, CORE_ADDR *highpc,
		       struct dwarf2_cu *cu, const char *namespace)
{
  struct objfile *objfile = cu->objfile;
  const char *new_name = pdi->name;
  char *full_name;

  /* Calculate the full name of the namespace that we just entered.  */

  if (new_name == NULL)
    new_name = "(anonymous namespace)";
  full_name = alloca (strlen (namespace) + 2 + strlen (new_name) + 1);
  strcpy (full_name, namespace);
  if (*namespace != '\0')
    strcat (full_name, "::");
  strcat (full_name, new_name);

  /* FIXME: carlton/2003-06-27: Once we build qualified names for more
     symbols than just namespaces, we should replace this by a call to
     add_partial_symbol.  */

  add_psymbol_to_list (full_name, strlen (full_name),
		       VAR_DOMAIN, LOC_TYPEDEF,
		       &objfile->global_psymbols,
		       0, 0, cu_language, objfile);

  /* Now scan partial symbols in that namespace.  */

  if (pdi->has_children)
    info_ptr = scan_partial_symbols (info_ptr, lowpc, highpc, cu, full_name);

  return info_ptr;
}

/* Read a partial die corresponding to an enumeration type.  */

static char *
add_partial_enumeration (struct partial_die_info *enum_pdi, char *info_ptr,
			 struct dwarf2_cu *cu, const char *namespace)
{
  struct objfile *objfile = cu->objfile;
  bfd *abfd = objfile->obfd;
  struct partial_die_info pdi;

  if (enum_pdi->name != NULL)
    add_partial_symbol (enum_pdi, cu, namespace);
  
  while (1)
    {
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);
      if (pdi.tag == 0)
	break;
      if (pdi.tag != DW_TAG_enumerator || pdi.name == NULL)
	complaint (&symfile_complaints, "malformed enumerator DIE ignored");
      else
	add_partial_symbol (&pdi, cu, namespace);
    }

  return info_ptr;
}

/* Locate ORIG_PDI's sibling; INFO_PTR should point to the next DIE
   after ORIG_PDI.  */

static char *
locate_pdi_sibling (struct partial_die_info *orig_pdi, char *info_ptr,
		    bfd *abfd, struct dwarf2_cu *cu)
{
  /* Do we know the sibling already?  */
  
  if (orig_pdi->sibling)
    return orig_pdi->sibling;

  /* Are there any children to deal with?  */

  if (!orig_pdi->has_children)
    return info_ptr;

  /* Okay, we don't know the sibling, but we have children that we
     want to skip.  So read children until we run into one without a
     tag; return whatever follows it.  */

  while (1)
    {
      struct partial_die_info pdi;
      
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);

      if (pdi.tag == 0)
	return info_ptr;
      else
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu);
    }
d1605 1
a1605 1
  struct dwarf2_cu cu;
a1612 1
  struct attribute *attr;
a1624 4
  dwarf_ranges_buffer = DWARF_RANGES_BUFFER (pst);
  dwarf_ranges_size = DWARF_RANGES_SIZE (pst);
  dwarf_loc_buffer = DWARF_LOC_BUFFER (pst);
  dwarf_loc_size = DWARF_LOC_SIZE (pst);
d1629 3
a1637 2
  cu.objfile = objfile;

d1639 1
a1639 1
  info_ptr = read_comp_unit_head (&cu.header, info_ptr, abfd);
d1642 2
a1643 2
  dwarf2_read_abbrevs (abfd, &cu);
  make_cleanup (dwarf2_empty_abbrev_table, cu.header.dwarf2_abbrevs);
d1645 1
a1645 1
  dies = read_comp_unit (info_ptr, abfd, &cu);
a1648 25
  /* Find the base address of the compilation unit for range lists and
     location lists.  It will normally be specified by DW_AT_low_pc.
     In DWARF-3 draft 4, the base address could be overridden by
     DW_AT_entry_pc.  It's been removed, but GCC still uses this for
     compilation units with discontinuous ranges.  */

  cu.header.base_known = 0;
  cu.header.base_address = 0;

  attr = dwarf_attr (dies, DW_AT_entry_pc);
  if (attr)
    {
      cu.header.base_address = DW_ADDR (attr);
      cu.header.base_known = 1;
    }
  else
    {
      attr = dwarf_attr (dies, DW_AT_low_pc);
      if (attr)
	{
	  cu.header.base_address = DW_ADDR (attr);
	  cu.header.base_known = 1;
	}
    }

d1650 1
a1650 1
  process_die (dies, &cu);
d1652 1
a1652 1
  if (!dwarf2_get_pc_bounds (dies, &lowpc, &highpc, &cu))
d1658 1
a1658 1
      if (dies->child != NULL)
d1660 1
a1660 1
	  child_die = dies->child;
d1667 1
a1667 1
		  if (dwarf2_get_pc_bounds (child_die, &low, &high, &cu))
d1688 1
d1696 2
a1697 1
process_die (struct die_info *die, struct dwarf2_cu *cu)
d1704 1
a1704 1
      read_file_scope (die, cu);
d1707 2
a1708 2
      read_subroutine_type (die, cu);
      read_func_scope (die, cu);
d1716 1
a1716 3
    case DW_TAG_try_block:
    case DW_TAG_catch_block:
      read_lexical_block_scope (die, cu);
d1721 1
a1721 1
      read_structure_scope (die, cu);
d1724 1
a1724 1
      read_enumeration (die, cu);
d1727 1
a1727 1
      read_subroutine_type (die, cu);
d1730 1
a1730 1
      read_array_type (die, cu);
d1733 1
a1733 1
      read_tag_pointer_type (die, cu);
d1736 1
a1736 1
      read_tag_ptr_to_member_type (die, cu);
d1739 1
a1739 1
      read_tag_reference_type (die, cu);
d1742 1
a1742 1
      read_tag_string_type (die, cu);
d1745 1
a1745 1
      read_base_type (die, cu);
d1749 1
a1749 1
	  new_symbol (die, die->type, cu);
d1753 1
a1753 1
      read_common_block (die, cu);
d1758 2
a1759 6
      if (!processing_has_namespace_info)
	{
	  processing_has_namespace_info = 1;
	  processing_current_namespace = "";
	}
      read_namespace (die, cu);
d1769 2
a1770 6
      if (!processing_has_namespace_info)
	{
	  processing_has_namespace_info = 1;
	  processing_current_namespace = "";
	}
      gdb_assert (die->child == NULL);
d1773 1
a1773 1
      new_symbol (die, NULL, cu);
d1785 2
a1786 1
read_file_scope (struct die_info *die, struct dwarf2_cu *cu)
a1787 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d1798 1
a1798 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
d1800 1
a1800 1
      if (die->child != NULL)
d1802 1
a1802 1
	  child_die = die->child;
d1809 1
a1809 1
		  if (dwarf2_get_pc_bounds (child_die, &low, &high, cu))
d1850 2
a1851 2
      objfile->ei.deprecated_entry_file_lowpc = lowpc;
      objfile->ei.deprecated_entry_file_highpc = highpc;
d1880 1
a1880 1
  if (die->child != NULL)
d1882 1
a1882 1
      child_die = die->child;
d1885 1
a1885 1
	  process_die (child_die, cu);
d1895 2
a1896 1
      line_header = dwarf_decode_line_header (line_offset, abfd, cu);
d1901 1
a1901 1
          dwarf_decode_lines (line_header, comp_dir, abfd, cu);
d1914 1
a1914 1
                           comp_dir, abfd, cu);
d1941 2
a1942 1
read_func_scope (struct die_info *die, struct dwarf2_cu *cu)
d1944 1
a1944 2
  struct objfile *objfile = cu->objfile;
  struct context_stack *new;
d1955 1
a1955 1
  if (name == NULL || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
d1971 4
a1974 5
  new = push_context (0, lowpc);
  new->name = new_symbol (die, die->type, cu);

  /* If there is a location expression for DW_AT_frame_base, record
     it.  */
d1977 31
a2007 1
    dwarf2_symbol_mark_computed (attr, new->name, cu);
d2009 2
d2013 1
a2013 1
  if (die->child != NULL)
d2015 1
a2015 1
      child_die = die->child;
d2018 1
a2018 1
	  process_die (child_die, cu);
d2027 1
a2027 12
  
  /* In C++, we can have functions nested inside functions (e.g., when
     a function declares a class that has methods).  This means that
     when we finish processing a function scope, we may need to go
     back to building a containing block's symbol lists.  */
  local_symbols = new->locals;
  param_symbols = new->params;

  /* If we've finished processing a top-level function, subsequent
     symbols go in the file symbol list.  */
  if (outermost_context_p ())
    list_in_scope = &file_symbols;
d2034 2
a2035 1
read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)
d2037 1
a2037 2
  struct objfile *objfile = cu->objfile;
  struct context_stack *new;
d2042 1
a2042 5
  /* ??? Perhaps consider discontiguous blocks defined by DW_AT_ranges
     as multiple lexical blocks?  Handling children in a sane way would
     be nasty.  Might be easier to properly extend generic blocks to 
     describe ranges.  */
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
d2048 1
a2048 1
  if (die->child != NULL)
d2050 1
a2050 1
      child_die = die->child;
d2053 1
a2053 1
	  process_die (child_die, cu);
d2067 3
a2069 3
/* Get low and high pc attributes from a die.  Return 1 if the attributes
   are present and valid, otherwise, return 0.  Return -1 if the range is
   discontinuous, i.e. derived from DW_AT_ranges information.  */
d2071 2
a2072 2
dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,
		      CORE_ADDR *highpc, struct dwarf2_cu *cu)
a2073 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d2075 2
a2076 4
  bfd *obfd = objfile->obfd;
  CORE_ADDR low = 0;
  CORE_ADDR high = 0;
  int ret = 0;
d2078 5
d2085 1
a2085 12
    {
      high = DW_ADDR (attr);
      attr = dwarf_attr (die, DW_AT_low_pc);
      if (attr)
	low = DW_ADDR (attr);
      else
	/* Found high w/o low attribute.  */
	return 0;

      /* Found consecutive range of addresses.  */
      ret = 1;
    }
d2087 1
a2087 109
    {
      attr = dwarf_attr (die, DW_AT_ranges);
      if (attr != NULL)
	{
	  unsigned int addr_size = cu_header->addr_size;
	  CORE_ADDR mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));
	  /* Value of the DW_AT_ranges attribute is the offset in the
	     .debug_ranges section.  */
	  unsigned int offset = DW_UNSND (attr);
	  /* Base address selection entry.  */
	  CORE_ADDR base;
	  int found_base;
	  int dummy;
	  char *buffer;
	  CORE_ADDR marker;
	  int low_set;
 
	  found_base = cu_header->base_known;
	  base = cu_header->base_address;

	  if (offset >= dwarf_ranges_size)
	    {
	      complaint (&symfile_complaints,
	                 "Offset %d out of bounds for DW_AT_ranges attribute",
			 offset);
	      return 0;
	    }
	  buffer = dwarf_ranges_buffer + offset;

	  /* Read in the largest possible address.  */
	  marker = read_address (obfd, buffer, cu, &dummy);
	  if ((marker & mask) == mask)
	    {
	      /* If we found the largest possible address, then
		 read the base address.  */
	      base = read_address (obfd, buffer + addr_size, cu, &dummy);
	      buffer += 2 * addr_size;
	      offset += 2 * addr_size;
	      found_base = 1;
	    }

	  low_set = 0;

	  while (1)
	    {
	      CORE_ADDR range_beginning, range_end;

	      range_beginning = read_address (obfd, buffer, cu, &dummy);
	      buffer += addr_size;
	      range_end = read_address (obfd, buffer, cu, &dummy);
	      buffer += addr_size;
	      offset += 2 * addr_size;

	      /* An end of list marker is a pair of zero addresses.  */
	      if (range_beginning == 0 && range_end == 0)
		/* Found the end of list entry.  */
		break;

	      /* Each base address selection entry is a pair of 2 values.
		 The first is the largest possible address, the second is
		 the base address.  Check for a base address here.  */
	      if ((range_beginning & mask) == mask)
		{
		  /* If we found the largest possible address, then
		     read the base address.  */
		  base = read_address (obfd, buffer + addr_size, cu, &dummy);
		  found_base = 1;
		  continue;
		}

	      if (!found_base)
		{
		  /* We have no valid base address for the ranges
		     data.  */
		  complaint (&symfile_complaints,
			     "Invalid .debug_ranges data (no base address)");
		  return 0;
		}

	      range_beginning += base;
	      range_end += base;

	      /* FIXME: This is recording everything as a low-high
		 segment of consecutive addresses.  We should have a
		 data structure for discontiguous block ranges
		 instead.  */
	      if (! low_set)
		{
		  low = range_beginning;
		  high = range_end;
		  low_set = 1;
		}
	      else
		{
		  if (range_beginning < low)
		    low = range_beginning;
		  if (range_end > high)
		    high = range_end;
		}
	    }

	  if (! low_set)
	    /* If the first entry is an end-of-list marker, the range
	       describes an empty scope, i.e. no instructions.  */
	    return 0;

	  ret = -1;
	}
    }
d2100 1
a2100 1
  if (low == 0 && (bfd_get_file_flags (obfd) & HAS_RELOC) == 0)
d2105 1
a2105 1
  return ret;
d2112 3
a2114 3
		  struct dwarf2_cu *cu)
{ 
  struct objfile *objfile = cu->objfile;
d2147 1
a2147 2

  if (die->tag == DW_TAG_member && ! die_is_declaration (die))
a2148 2
      /* Data member other than a C++ static data member.  */
      
d2150 1
a2150 3
      fp->type = die_type (die, cu);

      FIELD_STATIC_KIND (*fp) = 0;
d2168 1
a2168 1
	    decode_locdesc (DW_BLOCK (attr), cu) * bits_per_byte;
d2231 1
a2231 1
  else if (die->tag == DW_TAG_member || die->tag == DW_TAG_variable)
a2232 7
      /* C++ static member.  */

      /* NOTE: carlton/2002-11-05: It should be a DW_TAG_member that
	 is a declaration, but all versions of G++ as of this writing
	 (so through at least 3.2.1) incorrectly generate
	 DW_TAG_variable tags.  */
      
d2235 2
a2236 1
      /* Get name of field.  */
d2248 1
a2248 1
      FIELD_TYPE (*fp) = die_type (die, cu);
d2257 1
a2257 1
	FIELD_BITPOS (*fp) = (decode_locdesc (DW_BLOCK (attr), cu)
d2260 1
a2260 2
      FIELD_STATIC_KIND (*fp) = 0;
      FIELD_TYPE (*fp) = die_type (die, cu);
d2270 1
a2270 1
			      struct dwarf2_cu *cu)
d2334 2
a2335 2
	    complaint (&symfile_complaints, "unsupported accessibility %d",
		       fip->fields->accessibility);
d2357 2
a2358 1
		      struct type *type, struct dwarf2_cu *cu)
a2359 1
  struct objfile *objfile = cu->objfile;
d2381 1
a2381 1
      if (strcmp (fip->fnfieldlists[i].name, fieldname) == 0)
d2422 1
d2443 1
a2443 2
    complaint (&symfile_complaints, "member function type missing for '%s'",
	       physname);
d2447 1
a2447 1
    fnp->fcontext = die_containing_type (die, cu);
d2479 1
a2479 1
          fnp->voffset = decode_locdesc (DW_BLOCK (attr), cu) + 2;
d2483 1
a2483 1
	  dwarf2_complex_location_expr_complaint ();
d2487 2
a2488 2
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_vtable_elem_location",
						 fieldname);
d2497 1
a2497 1
				 struct dwarf2_cu *cu)
d2544 2
a2545 1
read_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
a2546 1
  struct objfile *objfile = cu->objfile;
d2591 1
a2591 1
  if (die->child != NULL && ! die_is_declaration (die))
d2599 1
a2599 1
      child_die = die->child;
d2603 1
a2603 2
	  if (child_die->tag == DW_TAG_member
	      || child_die->tag == DW_TAG_variable)
d2605 6
a2610 6
	      /* NOTE: carlton/2002-11-05: A C++ static data member
		 should be a DW_TAG_member that is a declaration, but
		 all versions of G++ as of this writing (so through at
		 least 3.2.1) incorrectly generate DW_TAG_variable
		 tags for them instead.  */
	      dwarf2_add_field (&fi, child_die, cu);
d2615 2
a2616 2
	      process_die (child_die, cu);
	      dwarf2_add_member_fn (&fi, child_die, type, cu);
d2621 1
a2621 1
	      dwarf2_add_field (&fi, child_die, cu);
d2625 1
a2625 1
	      process_die (child_die, cu);
d2632 1
a2632 1
	dwarf2_attach_fields_to_type (&fi, type, cu);
d2635 1
a2635 1
	  dwarf2_attach_fn_fields_to_type (&fi, type, cu);
d2643 1
a2643 1
	      struct type *t = die_containing_type (die, cu);
d2659 1
a2659 3
		      if ((strncmp (fieldname, vptr_name,
                                    strlen (vptr_name) - 1)
                           == 0)
d2669 2
a2670 4
		    complaint (&symfile_complaints,
			       "virtual function table pointer not found when defining class '%s'",
			       TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) :
			       "");
d2679 1
a2679 1
      new_symbol (die, type, cu);
d2700 2
a2701 1
read_enumeration (struct die_info *die, struct dwarf2_cu *cu)
a2702 1
  struct objfile *objfile = cu->objfile;
d2734 1
a2734 1
  if (die->child != NULL)
d2736 1
a2736 1
      child_die = die->child;
d2741 1
a2741 1
	      process_die (child_die, cu);
d2748 1
a2748 1
		  sym = new_symbol (child_die, type, cu);
d2760 1
a2760 1
		  FIELD_NAME (fields[num_fields]) = DEPRECATED_SYMBOL_NAME (sym);
a2763 1
		  FIELD_STATIC_KIND (fields[num_fields]) = 0;
d2785 1
a2785 1
  new_symbol (die, type, cu);
d2793 2
a2794 1
read_array_type (struct die_info *die, struct dwarf2_cu *cu)
a2795 1
  struct objfile *objfile = cu->objfile;
d2810 1
a2810 1
  element_type = die_type (die, cu);
d2814 1
a2814 1
  if (die->child == NULL)
d2823 1
a2823 1
  child_die = die->child;
d2839 1
a2839 1
	  index_type = die_type (child_die, cu);
d2857 2
a2858 2
		  dwarf2_non_const_array_bound_ignored_complaint
		    (dwarf_form_name (attr->form));
d2888 2
a2889 8
		     length for now.

                     FIXME: jimb/2003-09-22: GDB does not really know
                     how to handle arrays of unspecified length
                     either; we just represent them as zero-length
                     arrays.  Choose an appropriate upper bound given
                     the lower bound we've computed above.  */
		  high = low - 1;
d2893 2
a2894 2
		  dwarf2_non_const_array_bound_ignored_complaint
		    (dwarf_form_name (attr->form));
d2943 2
a2944 1
read_common_block (struct die_info *die, struct dwarf2_cu *cu)
d2957 1
a2957 1
          base = decode_locdesc (DW_BLOCK (attr), cu);
d2961 1
a2961 1
	  dwarf2_complex_location_expr_complaint ();
d2965 2
a2966 2
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
						 "common block member");
d2969 1
a2969 1
  if (die->child != NULL)
d2971 1
a2971 1
      child_die = die->child;
d2974 1
a2974 1
	  sym = new_symbol (child_die, NULL, cu);
d2979 1
a2979 1
		base + decode_locdesc (DW_BLOCK (attr), cu);
d2989 3
d2993 2
a2994 1
read_namespace (struct die_info *die, struct dwarf2_cu *cu)
a2995 1
  struct objfile *objfile = cu->objfile;
d3003 1
a3003 2
  for (current_die = die;
       current_die != NULL;
d3006 1
a3006 1
      name = dwarf2_name (current_die);
d3019 16
a3034 1
  if (previous_namespace[0] == '\0')
d3036 1
a3036 41
      processing_current_namespace = name;
    }
  else
    {
      /* We need temp_name around because processing_current_namespace
	 is a const char *.  */
      char *temp_name = alloca (strlen (previous_namespace)
				+ 2 + strlen(name) + 1);
      strcpy (temp_name, previous_namespace);
      strcat (temp_name, "::");
      strcat (temp_name, name);

      processing_current_namespace = temp_name;
    }

  /* Add a symbol associated to this if we haven't seen the namespace
     before.  Also, add a using directive if it's an anonymous
     namespace.  */

  if (dwarf2_extension (die) == NULL)
    {
      struct type *type;

      /* FIXME: carlton/2003-06-27: Once GDB is more const-correct,
	 this cast will hopefully become unnecessary.  */
      type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
			(char *) processing_current_namespace,
			objfile);
      TYPE_TAG_NAME (type) = TYPE_NAME (type);

      new_symbol (die, type, cu);

      if (is_anonymous)
	cp_add_using_directive (processing_current_namespace,
				strlen (previous_namespace),
				strlen (processing_current_namespace));
    }

  if (die->child != NULL)
    {
      struct die_info *child_die = die->child;
d3040 1
a3040 1
	  process_die (child_die, cu);
d3052 2
a3053 1
read_tag_pointer_type (struct die_info *die, struct dwarf2_cu *cu)
a3054 1
  struct comp_unit_head *cu_header = &cu->header;
d3065 1
a3065 1
  type = lookup_pointer_type (die_type (die, cu));
d3094 1
a3094 1
	  complaint (&symfile_complaints, "invalid pointer size %d", byte_size);
d3109 2
a3110 1
read_tag_ptr_to_member_type (struct die_info *die, struct dwarf2_cu *cu)
a3111 1
  struct objfile *objfile = cu->objfile;
d3122 2
a3123 2
  to_type = die_type (die, cu);
  domain = die_containing_type (die, cu);
d3133 2
a3134 1
read_tag_reference_type (struct die_info *die, struct dwarf2_cu *cu)
a3135 1
  struct comp_unit_head *cu_header = &cu->header;
d3144 1
a3144 1
  type = lookup_reference_type (die_type (die, cu));
d3158 2
a3159 1
read_tag_const_type (struct die_info *die, struct dwarf2_cu *cu)
d3168 1
a3168 1
  base_type = die_type (die, cu);
d3173 2
a3174 1
read_tag_volatile_type (struct die_info *die, struct dwarf2_cu *cu)
d3183 1
a3183 1
  base_type = die_type (die, cu);
d3193 1
a3193 1
read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)
a3194 1
  struct objfile *objfile = cu->objfile;
d3250 2
a3251 1
read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)
d3262 1
a3262 1
  type = die_type (die, cu);
d3271 1
a3271 1
  if (die->child != NULL)
d3280 1
a3280 1
      child_die = die->child;
d3295 1
a3295 1
      child_die = die->child;
d3310 2
a3311 1
	      TYPE_FIELD_TYPE (ftype, iparams) = die_type (child_die, cu);
d3322 2
a3323 1
read_typedef (struct die_info *die, struct dwarf2_cu *cu)
a3324 1
  struct objfile *objfile = cu->objfile;
d3336 1
a3336 1
      TYPE_TARGET_TYPE (die->type) = die_type (die, cu);
d3344 1
a3344 1
read_base_type (struct die_info *die, struct dwarf2_cu *cu)
a3345 1
  struct objfile *objfile = cu->objfile;
d3397 2
a3398 2
	  complaint (&symfile_complaints, "unsupported DW_AT_encoding: '%s'",
		     dwarf_type_encoding_name (encoding));
d3419 1
a3419 1
      type = dwarf_base_type (encoding, size, cu);
d3427 2
a3428 1
read_comp_unit (char *info_ptr, bfd *abfd, struct dwarf2_cu *cu)
d3430 4
a3437 51
  return read_die_and_children (info_ptr, abfd, cu, &info_ptr, NULL);
}

/* Read a single die and all its descendents.  Set the die's sibling
   field to NULL; set other fields in the die correctly, and set all
   of the descendents' fields correctly.  Set *NEW_INFO_PTR to the
   location of the info_ptr after reading all of those dies.  PARENT
   is the parent of the die in question.  */

static struct die_info *
read_die_and_children (char *info_ptr, bfd *abfd,
		       struct dwarf2_cu *cu,
		       char **new_info_ptr,
		       struct die_info *parent)
{
  struct die_info *die;
  char *cur_ptr;
  int has_children;

  cur_ptr = read_full_die (&die, abfd, info_ptr, cu, &has_children);
  store_in_ref_table (die->offset, die);

  if (has_children)
    {
      die->child = read_die_and_siblings (cur_ptr, abfd, cu,
					  new_info_ptr, die);
    }
  else
    {
      die->child = NULL;
      *new_info_ptr = cur_ptr;
    }

  die->sibling = NULL;
  die->parent = parent;
  return die;
}

/* Read a die, all of its descendents, and all of its siblings; set
   all of the fields of all of the dies correctly.  Arguments are as
   in read_die_and_children.  */

static struct die_info *
read_die_and_siblings (char *info_ptr, bfd *abfd,
		       struct dwarf2_cu *cu,
		       char **new_info_ptr,
		       struct die_info *parent)
{
  struct die_info *first_die, *last_sibling;
  char *cur_ptr;

d3439 3
a3441 3
  first_die = last_sibling = NULL;

  while (1)
d3443 2
a3444 4
      struct die_info *die
	= read_die_and_children (cur_ptr, abfd, cu, &cur_ptr, parent);

      if (!first_die)
d3446 1
a3446 1
	  first_die = die;
d3448 1
a3448 1
      else
d3450 1
a3450 1
	  last_sibling->sibling = die;
d3453 6
a3458 1
      if (die->tag == 0)
d3460 1
a3460 2
	  *new_info_ptr = cur_ptr;
	  return first_die;
d3464 2
a3465 1
	  last_sibling = die;
d3468 2
d3482 1
a3482 3
      if (die->child != NULL)
	free_die_list (die->child);
      next = die->sibling;
d3506 2
a3507 1
dwarf2_read_section (struct objfile *objfile, asection *sectp)
d3510 1
a3510 2
  char *buf, *retbuf;
  bfd_size_type size = bfd_get_section_size_before_reloc (sectp);
d3516 7
a3522 10
  retbuf
    = (char *) symfile_relocate_debug_section (abfd, sectp, (bfd_byte *) buf);
  if (retbuf != NULL)
    return retbuf;

  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0
      || bfd_bread (buf, size, abfd) != size)
    error ("Dwarf Error: Can't read DWARF data from '%s'",
	   bfd_get_filename (abfd));

d3532 1
a3532 1
dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu)
a3533 1
  struct comp_unit_head *cu_header = &cu->header;
d3597 1
a3597 1
      if (dwarf2_lookup_abbrev (abbrev_number, cu) != NULL)
d3604 1
d3606 1
a3606 1
dwarf2_empty_abbrev_table (void *ptr_to_abbrevs_table)
d3632 1
a3632 1
dwarf2_lookup_abbrev (unsigned int number, struct dwarf2_cu *cu)
a3633 1
  struct comp_unit_head *cu_header = &cu->header;
d3654 1
a3654 1
		  char *info_ptr, struct dwarf2_cu *cu)
d3670 1
a3670 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
d3673 1
a3673 2
      error ("Dwarf Error: Could not find abbrev number %d [in module %s]", abbrev_number,
		      bfd_get_filename (abfd));
d3682 2
a3683 1
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], abfd, info_ptr, cu);
d3714 1
a3714 1
	      dwarf2_complex_location_expr_complaint ();
d3718 2
a3719 2
	      dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
						     "partial symbol information");
d3743 1
a3743 1
	    complaint (&symfile_complaints, "ignoring absolute DW_AT_sibling");
d3760 1
d3763 1
a3763 1
      read_partial_die (&spec_die, abfd, spec_ptr, cu);
d3790 2
a3791 4
/* Read the die from the .debug_info section buffer.  Set DIEP to
   point to a newly allocated die with its information, except for its
   child, sibling, and parent fields.  Set HAS_CHILDREN to tell
   whether the die has children or not.  */
d3795 1
a3795 1
	       struct dwarf2_cu *cu, int *has_children)
a3810 1
      *has_children = 0;
d3814 1
a3814 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
d3817 1
a3817 3
      error ("Dwarf Error: could not find abbrev number %d [in module %s]",
	     abbrev_number, 
	     bfd_get_filename (abfd));
d3822 1
d3833 1
a3833 1
				 abfd, info_ptr, cu);
a3836 1
  *has_children = abbrev->has_children;
d3844 2
a3845 2
		      bfd *abfd, char *info_ptr,
		      struct dwarf2_cu *cu)
a3846 1
  struct comp_unit_head *cu_header = &cu->header;
d3855 1
a3855 1
      DW_ADDR (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
d3950 1
a3950 1
      info_ptr = read_attribute_value (attr, form, abfd, info_ptr, cu);
d3953 2
a3954 3
      error ("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]",
	     dwarf_form_name (form),
	     bfd_get_filename (abfd));
d3963 2
a3964 1
		bfd *abfd, char *info_ptr, struct dwarf2_cu *cu)
d3967 1
a3967 1
  return read_attribute_value (attr, abbrev->form, abfd, info_ptr, cu);
d4015 2
a4016 1
read_address (bfd *abfd, char *buf, struct dwarf2_cu *cu, int *bytes_read)
a4017 1
  struct comp_unit_head *cu_header = &cu->header;
d4035 1
a4035 2
			  "read_address: bad switch, signed [in module %s]",
			  bfd_get_filename (abfd));
d4053 1
a4053 2
			  "read_address: bad switch, unsigned [in module %s]",
			  bfd_get_filename (abfd));
d4168 1
a4168 2
		      "read_offset: bad switch [in module %s]",
		      bfd_get_filename (abfd));
d4210 1
a4210 2
      error ("DW_FORM_strp used without .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d4215 1
a4215 2
      error ("DW_FORM_strp pointing outside of .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d4314 1
a4314 1
      cu_language = language_minimal;
d4444 1
a4444 1
			  struct dwarf2_cu *cu)
d4455 1
a4455 1
      complaint (&symfile_complaints, "missing .debug_line section");
d4463 1
a4463 1
      dwarf2_statement_list_fits_in_line_number_section_complaint ();
d4479 1
a4479 1
      dwarf2_statement_list_fits_in_line_number_section_complaint ();
d4485 1
a4485 1
  lh->header_length = read_offset (abfd, line_ptr, &cu->header, &bytes_read);
d4534 1
a4534 2
    complaint (&symfile_complaints,
	       "line number info header doesn't fit in `.debug_line' section");
d4579 2
a4580 3
    complaint (&symfile_complaints,
	       "misplaced first line number at 0x%lx for '%s'",
	       (unsigned long) address, fn->name);
d4591 1
a4591 1
		    struct dwarf2_cu *cu)
d4595 2
a4596 1
  unsigned int bytes_read;
d4642 2
a4643 2
	      record_line (current_subfile, line, 
	                   check_cu_functions (address));
d4659 1
a4659 1
		  address = read_address (abfd, line_ptr, cu, &bytes_read);
d4683 1
a4683 2
		  complaint (&symfile_complaints,
			     "mangled .debug_line section");
d4688 2
a4689 2
	      record_line (current_subfile, line, 
	                   check_cu_functions (address));
a4799 56
static void
var_decode_location (struct attribute *attr, struct symbol *sym,
		     struct dwarf2_cu *cu)
{
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;

  /* NOTE drow/2003-01-30: There used to be a comment and some special
     code here to turn a symbol with DW_AT_external and a
     SYMBOL_VALUE_ADDRESS of 0 into a LOC_UNRESOLVED symbol.  This was
     necessary for platforms (maybe Alpha, certainly PowerPC GNU/Linux
     with some versions of binutils) where shared libraries could have
     relocations against symbols in their debug information - the
     minimal symbol would have the right address, but the debug info
     would not.  It's no longer necessary, because we will explicitly
     apply relocations when we read in the debug information now.  */

  /* A DW_AT_location attribute with no contents indicates that a
     variable has been optimized away.  */
  if (attr_form_is_block (attr) && DW_BLOCK (attr)->size == 0)
    {
      SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
      return;
    }

  /* Handle one degenerate form of location expression specially, to
     preserve GDB's previous behavior when section offsets are
     specified.  If this is just a DW_OP_addr then mark this symbol
     as LOC_STATIC.  */

  if (attr_form_is_block (attr)
      && DW_BLOCK (attr)->size == 1 + cu_header->addr_size
      && DW_BLOCK (attr)->data[0] == DW_OP_addr)
    {
      int dummy;

      SYMBOL_VALUE_ADDRESS (sym) =
	read_address (objfile->obfd, DW_BLOCK (attr)->data + 1, cu, &dummy);
      fixup_symbol_section (sym, objfile);
      SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets,
					      SYMBOL_SECTION (sym));
      SYMBOL_CLASS (sym) = LOC_STATIC;
      return;
    }

  /* NOTE drow/2002-01-30: It might be worthwhile to have a static
     expression evaluator, and use LOC_COMPUTED only when necessary
     (i.e. when the value of a register or memory location is
     referenced, or a thread-local block, etc.).  Then again, it might
     not be worthwhile.  I'm assuming that it isn't unless performance
     or memory numbers show me otherwise.  */

  dwarf2_symbol_mark_computed (attr, sym, cu);
  SYMBOL_CLASS (sym) = LOC_COMPUTED;
}

d4807 2
a4808 1
new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu)
a4809 1
  struct objfile *objfile = cu->objfile;
d4814 1
d4816 1
a4816 5
  if (die->tag != DW_TAG_namespace)
    name = dwarf2_linkage_name (die);
  else
    name = TYPE_NAME (type);

d4823 2
a4824 4

      /* Cache this symbol's name and the name's demangled form (if any).  */
      SYMBOL_LANGUAGE (sym) = cu_language;
      SYMBOL_SET_NAMES (sym, name, strlen (name), objfile);
d4828 1
a4828 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d4833 1
a4833 1
	SYMBOL_TYPE (sym) = die_type (die, cu);
d4839 9
d4884 1
a4884 1
	      dwarf2_const_value (attr, sym, cu);
a4894 1
	      var_decode_location (attr, sym, cu);
d4897 45
a4941 1
		add_symbol_to_list (sym, &global_symbols);
d4943 52
a4994 1
		add_symbol_to_list (sym, list_in_scope);
d5017 26
a5042 4
	      var_decode_location (attr, sym, cu);
	      /* FIXME drow/2003-07-31: Is LOC_COMPUTED_ARG necessary?  */
	      if (SYMBOL_CLASS (sym) == LOC_COMPUTED)
		SYMBOL_CLASS (sym) = LOC_COMPUTED_ARG;
d5047 1
a5047 1
	      dwarf2_const_value (attr, sym, cu);
d5061 1
a5061 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d5073 1
a5073 1
	      SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
d5076 2
a5077 2
		  obsavestring (DEPRECATED_SYMBOL_NAME (sym),
				strlen (DEPRECATED_SYMBOL_NAME (sym)),
d5085 1
a5085 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5092 1
a5092 1
	      dwarf2_const_value (attr, sym, cu);
a5095 4
	case DW_TAG_namespace:
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  add_symbol_to_list (sym, &global_symbols);
	  break;
d5101 1
a5101 2
	  complaint (&symfile_complaints, "unsupported tag: '%s'",
		     dwarf_tag_name (die->tag));
d5112 2
a5113 1
		    struct dwarf2_cu *cu)
a5114 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d5121 2
a5122 4
	dwarf2_const_value_length_mismatch_complaint (DEPRECATED_SYMBOL_NAME (sym),
						      cu_header->addr_size,
						      TYPE_LENGTH (SYMBOL_TYPE
								   (sym)));
d5125 2
a5126 4
      /* NOTE: cagney/2003-05-09: In-lined store_address call with
         it's body - store_unsigned_integer.  */
      store_unsigned_integer (SYMBOL_VALUE_BYTES (sym), cu_header->addr_size,
			      DW_ADDR (attr));
d5135 2
a5136 4
	dwarf2_const_value_length_mismatch_complaint (DEPRECATED_SYMBOL_NAME (sym),
						      blk->size,
						      TYPE_LENGTH (SYMBOL_TYPE
								   (sym)));
d5172 2
a5173 3
      complaint (&symfile_complaints,
		 "unsupported const value attribute form: '%s'",
		 dwarf_form_name (attr->form));
d5206 2
a5207 1
die_type (struct die_info *die, struct dwarf2_cu *cu)
d5218 1
a5218 1
      return dwarf2_fundamental_type (cu->objfile, FT_VOID);
d5226 1
a5226 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", 
			  ref, cu->objfile->name);
d5230 1
a5230 1
  type = tag_type_to_type (type_die, cu);
d5234 1
a5234 2
      error ("Dwarf Error: Problem turning type die at offset into gdb type [in module %s]",
		      cu->objfile->name);
d5243 2
a5244 1
die_containing_type (struct die_info *die, struct dwarf2_cu *cu)
d5258 1
a5258 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", ref, 
			  cu->objfile->name);
d5261 1
a5261 1
      type = tag_type_to_type (type_die, cu);
d5267 1
a5267 2
      error ("Dwarf Error: Problem turning containing type into gdb type [in module %s]", 
		      cu->objfile->name);
d5274 1
a5274 1
type_at_offset (unsigned int offset, struct dwarf2_cu *cu)
d5285 1
a5285 1
  type = tag_type_to_type (die, cu);
d5291 2
a5292 1
tag_type_to_type (struct die_info *die, struct dwarf2_cu *cu)
d5300 1
a5300 1
      read_type_die (die, cu);
d5304 1
a5304 2
	  error ("Dwarf Error: Cannot find type of die [in module %s]", 
			  cu->objfile->name);
d5311 2
a5312 1
read_type_die (struct die_info *die, struct dwarf2_cu *cu)
d5319 1
a5319 1
      read_structure_scope (die, cu);
d5322 1
a5322 1
      read_enumeration (die, cu);
d5326 1
a5326 1
      read_subroutine_type (die, cu);
d5329 1
a5329 1
      read_array_type (die, cu);
d5332 1
a5332 1
      read_tag_pointer_type (die, cu);
d5335 1
a5335 1
      read_tag_ptr_to_member_type (die, cu);
d5338 1
a5338 1
      read_tag_reference_type (die, cu);
d5341 1
a5341 1
      read_tag_const_type (die, cu);
d5344 1
a5344 1
      read_tag_volatile_type (die, cu);
d5347 1
a5347 1
      read_tag_string_type (die, cu);
d5350 1
a5350 1
      read_typedef (die, cu);
d5353 1
a5353 1
      read_base_type (die, cu);
d5356 1
a5356 2
      complaint (&symfile_complaints, "unexepected tag in read_type_die: '%s'",
		 dwarf_tag_name (die->tag));
d5362 1
a5362 1
dwarf_base_type (int encoding, int size, struct dwarf2_cu *cu)
a5363 2
  struct objfile *objfile = cu->objfile;

d5475 37
a5511 1
  return die->sibling;
d5570 1
a5570 1
dwarf_tag_name (unsigned tag)
d5702 1
a5702 1
dwarf_attr_name (unsigned attr)
a5866 1
#endif
d5869 1
d5893 1
a5893 1
dwarf_form_name (unsigned form)
d5947 1
a5947 1
dwarf_stack_op_name (unsigned op)
d6270 1
a6270 1
dwarf_type_encoding_name (unsigned enc)
d6301 1
a6301 1
dwarf_cfi_name (unsigned cfi_opc)
d6380 1
a6380 1
	   dwarf_bool_name (die->child != NULL));
d6443 1
a6443 4
      if (die->child != NULL)
	dump_die_list (die->child);
      if (die->sibling != NULL)
	dump_die_list (die->sibling);
d6484 1
a6484 3
      complaint (&symfile_complaints,
		 "unsupported die ref attribute form: '%s'",
		 dwarf_form_name (attr->form));
d6513 2
a6514 2
      error ("Dwarf Error: internal error - invalid fundamental type id %d [in module %s]",
	     typeid, objfile->name);
d6533 5
a6537 8
   NOTE drow/2003-11-18: This function is called in two situations
   now: for the address of static or global variables (partial symbols
   only) and for offsets into structures which are expected to be
   (more or less) constant.  The partial symbol case should go away,
   and only the constant case should remain.  That will let this
   function complain more accurately.  A few special modes are allowed
   without complaint for global variables (for instance, global
   register values and thread-local values).
d6540 2
a6541 4
   object is optimized out.  The return value is 0 for that case.
   FIXME drow/2003-11-16: No callers check for this case any more; soon all
   callers will only want a very basic result and this can become a
   complaint.
d6546 8
d6558 2
a6559 1
decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)
a6560 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d6573 5
d6581 1
a6653 2
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
d6661 62
a6722 2
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
d6727 1
a6727 1
					  cu, &bytes_read);
d6793 1
d6795 1
a6795 3
	     this using GDB's address_class enum.  This is valid for partial
	     global symbols, although the variable's address will be bogus
	     in the psymtab.  */
d6797 1
a6797 1
	    dwarf2_complex_location_expr_complaint ();
d6801 1
a6805 2
	  /* This is valid for partial global symbols, but the variable's
	     address will be bogus in the psymtab.  */
d6807 1
a6807 1
	    dwarf2_complex_location_expr_complaint ();
d6811 1
a6811 2
	  complaint (&symfile_complaints, "unsupported stack op: '%s'",
		     dwarf_stack_op_name (op));
d6820 1
d6822 1
a6822 1
dwarf2_free_tmp_obstack (void *ignore)
d6944 1
a6944 3
      complaint (&symfile_complaints,
		 "macro definition contains spaces in formal argument list:\n`%s'",
		 body);
d7002 1
a7002 1
	  dwarf2_macro_malformed_definition_complaint (body);
d7032 2
a7033 1
	    dwarf2_macro_malformed_definition_complaint (body);
d7069 1
a7069 1
	      dwarf2_macro_malformed_definition_complaint (body);
d7076 1
a7076 1
	    dwarf2_macro_malformed_definition_complaint (body);
d7080 1
a7080 1
	dwarf2_macro_malformed_definition_complaint (body);
d7092 1
a7092 1
    dwarf2_macro_malformed_definition_complaint (body);
d7099 2
a7100 1
                     struct dwarf2_cu *cu)
d7107 1
a7107 1
      complaint (&symfile_complaints, "missing .debug_macinfo section");
d7121 1
a7121 1
	  dwarf2_macros_too_long_complaint ();
d7148 5
a7152 6
	      complaint (&symfile_complaints,
			 "debug info gives macro %s outside of any file: %s",
			 macinfo_type ==
			 DW_MACINFO_define ? "definition" : macinfo_type ==
			 DW_MACINFO_undef ? "undefinition" :
			 "something-or-other", body);
d7175 1
a7175 1
                                             lh, cu->objfile);
d7181 1
a7181 2
	    complaint (&symfile_complaints,
		       "macro debug info has an unmatched `close_file' directive");
d7197 1
a7197 1
		      dwarf2_macros_too_long_complaint ();
d7205 1
a7205 2
		    complaint (&symfile_complaints,
			       "no terminating 0-type entry for macros in `.debug_macinfo' section");
a7239 55
}

static void
dwarf2_symbol_mark_computed (struct attribute *attr, struct symbol *sym,
			     struct dwarf2_cu *cu)
{
  if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
    {
      struct dwarf2_loclist_baton *baton;

      baton = obstack_alloc (&cu->objfile->symbol_obstack,
			     sizeof (struct dwarf2_loclist_baton));
      baton->objfile = cu->objfile;

      /* We don't know how long the location list is, but make sure we
	 don't run off the edge of the section.  */
      baton->size = dwarf_loc_size - DW_UNSND (attr);
      baton->data = dwarf_loc_buffer + DW_UNSND (attr);
      baton->base_address = cu->header.base_address;
      if (cu->header.base_known == 0)
	complaint (&symfile_complaints,
		   "Location list used without specifying the CU base address.");

      SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_loclist_funcs;
      SYMBOL_LOCATION_BATON (sym) = baton;
    }
  else
    {
      struct dwarf2_locexpr_baton *baton;

      baton = obstack_alloc (&cu->objfile->symbol_obstack,
			     sizeof (struct dwarf2_locexpr_baton));
      baton->objfile = cu->objfile;

      if (attr_form_is_block (attr))
	{
	  /* Note that we're just copying the block's data pointer
	     here, not the actual data.  We're still pointing into the
	     dwarf_info_buffer for SYM's objfile; right now we never
	     release that buffer, but when we do clean up properly
	     this may need to change.  */
	  baton->size = DW_BLOCK (attr)->size;
	  baton->data = DW_BLOCK (attr)->data;
	}
      else
	{
	  dwarf2_invalid_attrib_class_complaint ("location description",
						 SYMBOL_NATURAL_NAME (sym));
	  baton->size = 0;
	  baton->data = NULL;
	}
      
      SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_locexpr_funcs;
      SYMBOL_LOCATION_BATON (sym) = baton;
    }
@


1.67.2.5
log
@	* cp-names.y (yylex): Fix thinko for character constants.
	* dwarf2read.c: Include "cp-names.h".
	(read_structure_scope): Canonicalize class names.
@
text
@a46 1
#include "cp-names.h"
d2782 2
a2783 6
      /* FIXME: This should be in a more general location.  */
      char *name;
      name = cp_canonicalize_string (DW_STRING (attr));
      if (name == NULL)
	name = DW_STRING (attr);
      TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
a2784 2
      if (name != DW_STRING (attr))
	free (name);
@


1.67.2.6
log
@	* Makefile.in (cp_names_h): Remove.
	(cp_demangle_h): New.
	(cp-names.tab.o, cp-names-main.tab.o): Use $(cp_demangle_h) and
	remove $(cp_names_h).
	(cp-support.o): Use $(cp_demangle_h).
	* cp-names.y: Don't include cp-names.h.
	(cp_comp_to_string): Export.
	(cp_canonicalize_string): Move to cp-support.c.
	(demangled_name_to_comp, mangled_name_to_comp): New functions.
	* cp-support.c: Include "cp-demangle.h".
	(cp_canonicalize_string): New function, moved from cp-names.y and
	updated.
	(class_name_from_physname, method_name_from_physname): Rewritten.
	(find_last_component): Removed.
	* cp-support.h: Add new opaque types and prototypes.
	* dwarf2read.c: Don't include cp-names.h.
	* cp-names.h: Remove file.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d47 1
@


1.67.2.7
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004
a810 3
static const char *namespace_name (struct die_info *die,
				   int *is_anonymous);

a1425 1
  char *actual_name = pdi->name;
d1433 1
a1433 1
	  /*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
d1435 1
a1435 1
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
d1443 1
a1443 1
	  /*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
d1445 1
a1445 1
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
d1471 1
a1471 1
	    psym = add_psymbol_to_list (actual_name, strlen (actual_name),
d1483 1
a1483 1
	  /*prim_record_minimal_symbol (actual_name, addr + baseaddr,
d1485 1
a1485 1
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
d1494 1
a1494 1
      add_psymbol_to_list (actual_name, strlen (actual_name),
d1507 1
a1507 1
      add_psymbol_to_list (actual_name, strlen (actual_name),
d1515 1
a1515 1
	  add_psymbol_to_list (actual_name, strlen (actual_name),
d1522 1
a1522 1
      add_psymbol_to_list (actual_name, strlen (actual_name),
d1865 1
a1865 1
	  processing_current_prefix = "";
d1880 1
a1880 1
	  processing_current_prefix = "";
d3097 4
d3102 1
d3139 4
d3144 1
d3236 1
a3236 1
  const char *previous_prefix = processing_current_prefix;
d3241 16
a3256 1
  name = namespace_name (die, &is_anonymous);
d3260 1
a3260 1
  if (previous_prefix[0] == '\0')
d3262 1
a3262 1
      processing_current_prefix = name;
d3266 1
a3266 1
      /* We need temp_name around because processing_current_prefix
d3268 1
a3268 1
      char *temp_name = alloca (strlen (previous_prefix)
d3270 1
a3270 1
      strcpy (temp_name, previous_prefix);
d3274 1
a3274 1
      processing_current_prefix = temp_name;
d3288 1
a3288 1
			(char *) processing_current_prefix,
d3295 3
a3297 3
	cp_add_using_directive (processing_current_prefix,
				strlen (previous_prefix),
				strlen (processing_current_prefix));
d3311 1
a3311 31
  processing_current_prefix = previous_prefix;
}

/* Return the name of the namespace represented by DIE.  Set
   *IS_ANONYMOUS to tell whether or not the namespace is an anonymous
   namespace.  */

static const char *
namespace_name (struct die_info *die, int *is_anonymous)
{
  struct die_info *current_die;
  const char *name = NULL;

  /* Loop through the extensions until we find a name.  */

  for (current_die = die;
       current_die != NULL;
       current_die = dwarf2_extension (die))
    {
      name = dwarf2_name (current_die);
      if (name != NULL)
	break;
    }

  /* Is it an anonymous namespace?  */

  *is_anonymous = (name == NULL);
  if (*is_anonymous)
    name = "(anonymous namespace)";

  return name;
@


1.67.2.8
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@a233 28

  struct function_range *first_fn, *last_fn, *cached_fn;

  /* The language we are debugging.  */
  enum language language;
  const struct language_defn *language_defn;

  /* The generic symbol table building routines have separate lists for
     file scope symbols and all all other scopes (local scopes).  So
     we need to select the right one to pass to add_symbol_to_list().
     We do it by keeping a pointer to the correct list in list_in_scope.

     FIXME: The original dwarf code just treated the file scope as the
     first local scope, and all other local scopes as nested local
     scopes, and worked fine.  Check to see if we really need to
     distinguish these in buildsym.c.  */
  struct pending **list_in_scope;

  /* Maintain an array of referenced fundamental types for the current
     compilation unit being read.  For DWARF version 1, we have to construct
     the fundamental types on the fly, since no information about the
     fundamental types is supplied.  Each such fundamental type is created by
     calling a language dependent routine to create the type, and then a
     pointer to that type is then placed in the array at the index specified
     by it's FT_<TYPENAME> value.  The array has a fixed size set by the
     FT_NUM_MEMBERS compile time constant, which is the number of predefined
     fundamental types gdb knows how to construct.  */
  struct type *ftypes[FT_NUM_MEMBERS];	/* Fundamental types */
d363 2
d394 4
d403 4
d419 11
d439 5
d447 1
a447 1
   objfile_obstack, so that absolute die references can be handled.
d528 11
d595 7
d615 7
a668 2
static int pdi_needs_namespace (enum dwarf_tag tag, const char *namespace);

a674 5
static char *add_partial_structure (struct partial_die_info *struct_pdi,
				    char *info_ptr,
				    struct dwarf2_cu *cu,
				    const char *namespace);

d740 1
a740 4
static void set_cu_language (unsigned int, struct dwarf2_cu *);

static struct attribute *dwarf2_attr (struct die_info *, unsigned int,
				      struct dwarf2_cu *);
d742 1
a742 1
static int die_is_declaration (struct die_info *, struct dwarf2_cu *cu);
d744 1
a744 2
static struct die_info *die_specification (struct die_info *die,
					   struct dwarf2_cu *);
a779 8
static char *determine_prefix (struct die_info *die, struct dwarf2_cu *);

static char *determine_prefix_aux (struct die_info *die, struct dwarf2_cu *);

static char *typename_concat (const char *prefix, const char *suffix);

static char *class_name (struct die_info *die, struct dwarf2_cu *);

a783 2
static void read_subrange_type (struct die_info *die, struct dwarf2_cu *cu);

a792 4
static void get_scope_pc_bounds (struct die_info *,
				 CORE_ADDR *, CORE_ADDR *,
				 struct dwarf2_cu *);

d813 1
a813 1
				   int *is_anonymous, struct dwarf2_cu *);
d856 1
a856 1
static char *dwarf2_linkage_name (struct die_info *, struct dwarf2_cu *);
d858 1
a858 1
static char *dwarf2_name (struct die_info *die, struct dwarf2_cu *);
d860 1
a860 2
static struct die_info *dwarf2_extension (struct die_info *die,
					  struct dwarf2_cu *);
d890 1
a890 4
static unsigned int dwarf2_get_ref_die_offset (struct attribute *,
					       struct dwarf2_cu *);

static int dwarf2_get_attr_constant_value (struct attribute *, int);
d894 1
a894 2
static struct type *dwarf2_fundamental_type (struct objfile *, int,
					     struct dwarf2_cu *);
d906 1
a906 1
static void initialize_cu_func_list (struct dwarf2_cu *);
d908 1
a908 2
static void add_to_cu_func_list (const char *, CORE_ADDR, CORE_ADDR,
				 struct dwarf2_cu *);
d1146 1
a1146 1
  CORE_ADDR lowpc, highpc, baseaddr;
a1229 2
      cu.list_in_scope = &file_symbols;

d1239 1
a1239 1
      set_cu_language (comp_unit_die.language, &cu);
d1249 2
a1250 1
	obstack_alloc (&objfile->objfile_obstack, sizeof (struct dwarf2_pinfo));
a1370 5
	      if (!pdi.is_declaration)
		{
		  add_partial_symbol (&pdi, cu, namespace);
		}
	      break;
d1375 1
a1375 3
		  info_ptr = add_partial_structure (&pdi, info_ptr, cu,
						    namespace);
		  info_ptr_updated = 1;
a1386 1
            case DW_TAG_subrange_type:
a1431 14
  CORE_ADDR baseaddr;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  /* If we're not in the global namespace and if the namespace name
     isn't encoded in a mangled actual_name, add it.  */
  
  if (pdi_needs_namespace (pdi->tag, namespace))
    {
      actual_name = alloca (strlen (pdi->name) + 2 + strlen (namespace) + 1);
      strcpy (actual_name, namespace);
      strcat (actual_name, "::");
      strcat (actual_name, pdi->name);
    }
d1444 1
a1444 1
				      cu->language, objfile);
d1454 1
a1454 1
				      cu->language, objfile);
d1480 1
a1480 1
					cu->language, objfile);
d1494 1
a1494 1
				      cu->language, objfile);
a1498 1
    case DW_TAG_subrange_type:
d1502 1
a1502 1
			   0, (CORE_ADDR) 0, cu->language, objfile);
a1509 2
      /* NOTE: carlton/2003-10-07: See comment in new_symbol about
	 static vs. global.  */
d1514 2
a1515 4
			   cu->language == language_cplus
			   ? &objfile->global_psymbols
			   : &objfile->static_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
d1517 1
a1517 1
      if (cu->language == language_cplus)
d1522 2
a1523 2
			       &objfile->global_psymbols,
			       0, (CORE_ADDR) 0, cu->language, objfile);
d1529 2
a1530 4
			   cu->language == language_cplus
			   ? &objfile->static_psymbols
			   : &objfile->global_psymbols,
			   0, (CORE_ADDR) 0, cu->language, objfile);
d1542 1
a1542 1
  if (cu->language == language_cplus
a1549 24
/* Determine whether a die of type TAG living in the C++ namespace
   NAMESPACE needs to have the name of the namespace prepended to the
   name listed in the die.  */

static int
pdi_needs_namespace (enum dwarf_tag tag, const char *namespace)
{
  if (namespace == NULL || namespace[0] == '\0')
    return 0;

  switch (tag)
    {
    case DW_TAG_typedef:
    case DW_TAG_class_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
    case DW_TAG_enumeration_type:
    case DW_TAG_enumerator:
      return 1;
    default:
      return 0;
    }
}

d1573 3
a1575 4
  /* FIXME: carlton/2003-10-07: We can't just replace this by a call
     to add_partial_symbol, because we don't have a way to pass in the
     full name to that function; that might be a flaw in
     add_partial_symbol's interface.  */
d1580 1
a1580 1
		       0, 0, cu->language, objfile);
a1589 72
/* Read a partial die corresponding to a class or structure.  */

static char *
add_partial_structure (struct partial_die_info *struct_pdi, char *info_ptr,
		       struct dwarf2_cu *cu,
		       const char *namespace)
{
  bfd *abfd = cu->objfile->obfd;
  char *actual_class_name = NULL;

  if (cu->language == language_cplus
      && (namespace == NULL || namespace[0] == '\0')
      && struct_pdi->name != NULL
      && struct_pdi->has_children)
    {
      /* See if we can figure out if the class lives in a namespace
	 (or is nested within another class.)  We do this by looking
	 for a member function; its demangled name will contain
	 namespace info, if there is any.  */

      /* NOTE: carlton/2003-10-07: Getting the info this way changes
	 what template types look like, because the demangler
	 frequently doesn't give the same name as the debug info.  We
	 could fix this by only using the demangled name to get the
	 prefix (but see comment in read_structure_scope).  */

      /* FIXME: carlton/2004-01-23: If NAMESPACE equals "", we have
	 the appropriate debug information, so it would be nice to be
	 able to avoid this hack.  But NAMESPACE may not be the
	 namespace where this class was defined: NAMESPACE reflects
	 where STRUCT_PDI occurs in the tree of dies, but because of
	 DW_AT_specification, that may not actually tell us where the
	 class is defined.  (See the comment in read_func_scope for an
	 example of how this could occur.)

         Unfortunately, our current partial symtab data structures are
         completely unable to deal with DW_AT_specification.  So, for
         now, the best thing to do is to get nesting information from
         places other than the tree structure of dies if there's any
         chance that a DW_AT_specification is involved. :-( */

      char *next_child = info_ptr;

      while (1)
	{
	  struct partial_die_info child_pdi;

	  next_child = read_partial_die (&child_pdi, abfd, next_child,
					 cu);
	  if (!child_pdi.tag)
	    break;
	  if (child_pdi.tag == DW_TAG_subprogram)
	    {
	      actual_class_name = class_name_from_physname (child_pdi.name);
	      if (actual_class_name != NULL)
		struct_pdi->name = actual_class_name;
	      break;
	    }
	  else
	    {
	      next_child = locate_pdi_sibling (&child_pdi, next_child,
					       abfd, cu);
	    }
	}
    }

  add_partial_symbol (struct_pdi, cu, namespace);
  xfree (actual_class_name);

  return locate_pdi_sibling (struct_pdi, info_ptr, abfd, cu);
}

a1693 1
  CORE_ADDR baseaddr;
d1710 2
a1712 4
  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  /* We're in the global namespace.  */
  processing_current_prefix = "";
a1728 4
  cu.header.offset = offset;

  cu.list_in_scope = &file_symbols;

d1742 1
a1742 1
  attr = dwarf2_attr (dies, DW_AT_entry_pc, &cu);
d1750 1
a1750 1
      attr = dwarf2_attr (dies, DW_AT_low_pc, &cu);
d1761 14
a1774 4
  /* Some compilers don't define a DW_AT_high_pc attribute for the
     compilation unit.  If the DW_AT_high_pc is missing, synthesize
     it, by scanning the DIE's below the compilation unit.  */
  get_scope_pc_bounds (dies, &lowpc, &highpc, &cu);
d1776 9
d1791 1
a1791 1
      && !(cu.language == language_c && symtab->language != language_c))
d1793 1
a1793 1
      symtab->language = cu.language;
d1855 1
a1855 1
      if (dwarf2_attr (die, DW_AT_name, cu))
a1860 8
    case DW_TAG_subrange_type:
      read_subrange_type (die, cu);
      if (dwarf2_attr (die, DW_AT_name, cu))
       {
         /* Add a typedef symbol for the base type definition.  */
         new_symbol (die, die->type, cu);
       }
      break;
d1867 5
a1871 1
      processing_has_namespace_info = 1;
d1882 5
a1886 1
      processing_has_namespace_info = 1;
d1896 1
a1896 1
initialize_cu_func_list (struct dwarf2_cu *cu)
d1898 1
a1898 1
  cu->first_fn = cu->last_fn = cu->cached_fn = NULL;
a1914 3
  CORE_ADDR baseaddr;
  
  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1916 21
a1936 1
  get_scope_pc_bounds (die, &lowpc, &highpc, cu);
d1945 1
a1945 1
  attr = dwarf2_attr (die, DW_AT_name, cu);
d1950 1
a1950 1
  attr = dwarf2_attr (die, DW_AT_comp_dir, cu);
d1972 1
a1972 1
  attr = dwarf2_attr (die, DW_AT_language, cu);
d1975 1
a1975 1
      set_cu_language (DW_UNSND (attr), cu);
d1990 1
a1990 1
  memset (cu->ftypes, 0, FT_NUM_MEMBERS * sizeof (struct type *));
d1995 1
a1995 1
  initialize_cu_func_list (cu);
d2009 1
a2009 1
  attr = dwarf2_attr (die, DW_AT_stmt_list, cu);
d2026 1
a2026 1
  attr = dwarf2_attr (die, DW_AT_macro_info, cu);
d2037 1
a2037 2
add_to_cu_func_list (const char *name, CORE_ADDR lowpc, CORE_ADDR highpc,
		     struct dwarf2_cu *cu)
d2049 2
a2050 2
  if (cu->last_fn == NULL)
      cu->first_fn = thisfn;
d2052 1
a2052 1
      cu->last_fn->next = thisfn;
d2054 1
a2054 1
  cu->last_fn = thisfn;
a2066 3
  const char *previous_prefix = processing_current_prefix;
  struct cleanup *back_to = NULL;
  CORE_ADDR baseaddr;
d2068 1
a2068 3
  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));

  name = dwarf2_linkage_name (die, cu);
a2074 34
  if (cu->language == language_cplus)
    {
      struct die_info *spec_die = die_specification (die, cu);

      /* NOTE: carlton/2004-01-23: We have to be careful in the
         presence of DW_AT_specification.  For example, with GCC 3.4,
         given the code

           namespace N {
             void foo() {
               // Definition of N::foo.
             }
           }

         then we'll have a tree of DIEs like this:

         1: DW_TAG_compile_unit
           2: DW_TAG_namespace        // N
             3: DW_TAG_subprogram     // declaration of N::foo
           4: DW_TAG_subprogram       // definition of N::foo
                DW_AT_specification   // refers to die #3

         Thus, when processing die #4, we have to pretend that we're
         in the context of its DW_AT_specification, namely the contex
         of die #3.  */
	
      if (spec_die != NULL)
	{
	  char *specification_prefix = determine_prefix (spec_die, cu);
	  processing_current_prefix = specification_prefix;
	  back_to = make_cleanup (xfree, specification_prefix);
	}
    }

d2079 1
a2079 1
  add_to_cu_func_list (name, lowpc, highpc, cu);
d2093 1
a2093 1
  attr = dwarf2_attr (die, DW_AT_frame_base, cu);
a2094 9
    /* FIXME: cagney/2004-01-26: The DW_AT_frame_base's location
       expression is being recorded directly in the function's symbol
       and not in a separate frame-base object.  I guess this hack is
       to avoid adding some sort of frame-base adjunct/annex to the
       function's symbol :-(.  The problem with doing this is that it
       results in a function symbol with a location expression that
       has nothing to do with the location of the function, ouch!  The
       relationship should be: a function's symbol has-a frame base; a
       frame-base has-a location expression.  */
d2097 1
a2097 1
  cu->list_in_scope = &local_symbols;
d2124 1
a2124 5
    cu->list_in_scope = &file_symbols;

  processing_current_prefix = previous_prefix;
  if (back_to != NULL)
    do_cleanups (back_to);
a2136 3
  CORE_ADDR baseaddr;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d2183 1
a2183 1
  attr = dwarf2_attr (die, DW_AT_high_pc, cu);
d2187 1
a2187 1
      attr = dwarf2_attr (die, DW_AT_low_pc, cu);
d2199 1
a2199 1
      attr = dwarf2_attr (die, DW_AT_ranges, cu);
a2326 62
/* Get the low and high pc's represented by the scope DIE, and store
   them in *LOWPC and *HIGHPC.  If the correct values can't be
   determined, set *LOWPC to -1 and *HIGHPC to 0.  */

static void
get_scope_pc_bounds (struct die_info *die,
		     CORE_ADDR *lowpc, CORE_ADDR *highpc,
		     struct dwarf2_cu *cu)
{
  CORE_ADDR best_low = (CORE_ADDR) -1;
  CORE_ADDR best_high = (CORE_ADDR) 0;
  CORE_ADDR current_low, current_high;

  if (dwarf2_get_pc_bounds (die, &current_low, &current_high, cu))
    {
      best_low = current_low;
      best_high = current_high;
    }
  else
    {
      struct die_info *child = die->child;

      while (child && child->tag)
	{
	  switch (child->tag) {
	  case DW_TAG_subprogram:
	    if (dwarf2_get_pc_bounds (child, &current_low, &current_high, cu))
	      {
		best_low = min (best_low, current_low);
		best_high = max (best_high, current_high);
	      }
	    break;
	  case DW_TAG_namespace:
	    /* FIXME: carlton/2004-01-16: Should we do this for
	       DW_TAG_class_type/DW_TAG_structure_type, too?  I think
	       that current GCC's always emit the DIEs corresponding
	       to definitions of methods of classes as children of a
	       DW_TAG_compile_unit or DW_TAG_namespace (as opposed to
	       the DIEs giving the declarations, which could be
	       anywhere).  But I don't see any reason why the
	       standards says that they have to be there.  */
	    get_scope_pc_bounds (child, &current_low, &current_high, cu);

	    if (current_low != ((CORE_ADDR) -1))
	      {
		best_low = min (best_low, current_low);
		best_high = max (best_high, current_high);
	      }
	    break;
	  default:
	    /* Ignore. */
	    break;
	  }

	  child = sibling_die (child);
	}
    }

  *lowpc = best_low;
  *highpc = best_high;
}

d2356 1
a2356 1
  attr = dwarf2_attr (die, DW_AT_accessibility, cu);
d2361 1
a2361 1
  attr = dwarf2_attr (die, DW_AT_virtuality, cu);
d2367 1
a2367 1
  if (die->tag == DW_TAG_member && ! die_is_declaration (die, cu))
d2377 1
a2377 1
      attr = dwarf2_attr (die, DW_AT_bit_size, cu);
d2388 1
a2388 1
      attr = dwarf2_attr (die, DW_AT_data_member_location, cu);
d2396 1
a2396 1
      attr = dwarf2_attr (die, DW_AT_bit_offset, cu);
d2419 1
a2419 1
	      attr = dwarf2_attr (die, DW_AT_byte_size, cu);
d2441 1
a2441 1
      attr = dwarf2_attr (die, DW_AT_name, cu);
d2445 1
a2445 1
			       &objfile->objfile_obstack);
d2449 1
a2449 1
      if (dwarf2_attr (die, DW_AT_artificial, cu))
d2467 1
a2467 1
      attr = dwarf2_attr (die, DW_AT_name, cu);
d2474 1
a2474 1
      physname = dwarf2_linkage_name (die, cu);
d2477 1
a2477 1
					     &objfile->objfile_obstack));
d2480 1
a2480 1
				       &objfile->objfile_obstack);
d2485 1
a2485 1
      attr = dwarf2_attr (die, DW_AT_data_member_location, cu);
d2600 1
a2600 1
  attr = dwarf2_attr (die, DW_AT_name, cu);
d2607 1
a2607 1
  physname = dwarf2_linkage_name (die, cu);
d2649 1
a2649 1
				&objfile->objfile_obstack);
d2677 1
a2677 1
  if (dwarf2_attr (die, DW_AT_containing_type, cu) != NULL)
d2684 1
a2684 1
  attr = dwarf2_attr (die, DW_AT_accessibility, cu);
d2699 1
a2699 1
  attr = dwarf2_attr (die, DW_AT_artificial, cu);
d2704 1
a2704 1
  attr = dwarf2_attr (die, DW_AT_vtable_elem_location, cu);
a2779 7
  const char *name = NULL;
  const char *previous_prefix = processing_current_prefix;
  struct cleanup *back_to = NULL;
  /* This says whether or not we want to try to update the structure's
     name to include enclosing namespace/class information, if
     any.  */
  int need_to_update_name = 0;
d2784 1
a2784 1
  attr = dwarf2_attr (die, DW_AT_name, cu);
d2788 1
d2792 4
a2795 39
      else
        back_to = make_cleanup (xfree, name);

      if (cu->language == language_cplus)
	{
	  struct die_info *spec_die = die_specification (die, cu);

	  if (spec_die != NULL)
	    {
	      char *specification_prefix = determine_prefix (spec_die, cu);
	      processing_current_prefix = specification_prefix;
	      if (back_to == NULL)
		back_to = make_cleanup (xfree, specification_prefix);
	      else
		make_cleanup (xfree, specification_prefix);
	    }
	}

      if (processing_has_namespace_info)
	{
	  /* FIXME: carlton/2003-11-10: This variable exists only for
	     const-correctness reasons.  When I tried to change
	     TYPE_TAG_NAME to be a const char *, I ran into a cascade
	     of changes which would have forced decode_line_1 to take
	     a const char **.  */
	  char *new_prefix = obconcat (&objfile->objfile_obstack,
				       processing_current_prefix,
				       processing_current_prefix[0] == '\0'
				       ? "" : "::",
				       name);
	  TYPE_TAG_NAME (type) = new_prefix;
	  processing_current_prefix = new_prefix;
	}
      else
	{
	  TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
					       &objfile->objfile_obstack);
	  need_to_update_name = (cu->language == language_cplus);
	}
d2813 1
a2813 1
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
d2828 1
a2828 1
  if (die->child != NULL && ! die_is_declaration (die, cu))
a2854 35
	      if (need_to_update_name)
		{
		  /* The demangled names of member functions contain
		     information about enclosing namespaces/classes,
		     if any.  */

		  /* FIXME: carlton/2003-11-10: The excessive
		     demangling here is a bit wasteful, as is the
		     memory usage for names.  */

		  /* NOTE: carlton/2003-11-10: As commented in
		     add_partial_structure, the demangler sometimes
		     prints the type info in a different form from the
		     debug info.  We could solve this by using the
		     demangled name to get the prefix; if doing so,
		     however, we'd need to be careful when reading a
		     class that's nested inside a template class.
		     That would also cause problems when trying to
		     determine RTTI information, since we use the
		     demangler to determine the appropriate class
		     name.  */
		  char *actual_class_name
		    = class_name_from_physname (dwarf2_linkage_name
						(child_die, cu));
		  if (actual_class_name != NULL
		      && strcmp (actual_class_name, name) != 0)
		    {
		      TYPE_TAG_NAME (type)
			= obsavestring (actual_class_name,
					strlen (actual_class_name),
					&objfile->objfile_obstack);
		    }
		  xfree (actual_class_name);
		  need_to_update_name = 0;
		}
d2879 1
a2879 1
	  if (dwarf2_attr (die, DW_AT_containing_type, cu) != NULL)
a2929 4

  processing_current_prefix = previous_prefix;
  if (back_to != NULL)
    do_cleanups (back_to);
d2956 1
a2956 1
  attr = dwarf2_attr (die, DW_AT_name, cu);
d2959 3
a2961 15
      const char *name = DW_STRING (attr);

      if (processing_has_namespace_info)
	{
	  TYPE_TAG_NAME (type) = obconcat (&objfile->objfile_obstack,
					   processing_current_prefix,
					   processing_current_prefix[0] == '\0'
					   ? "" : "::",
					   name);
	}
      else
	{
	  TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
					       &objfile->objfile_obstack);
	}
d2964 1
a2964 1
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
d2987 1
a2987 1
	      attr = dwarf2_attr (child_die, DW_AT_name, cu);
d3059 1
a3059 1
      index_type = dwarf2_fundamental_type (objfile, FT_INTEGER, cu);
d3071 10
a3080 1
          read_subrange_type (child_die, cu);
d3082 71
a3152 14
          if (child_die->type != NULL)
            {
	      /* The range type was succesfully read. Save it for
                 the array type creation.  */
              if ((ndim % DW_FIELD_ALLOC_CHUNK) == 0)
                {
                  range_types = (struct type **)
                    xrealloc (range_types, (ndim + DW_FIELD_ALLOC_CHUNK)
                              * sizeof (struct type *));
                  if (ndim == 0)
                    make_cleanup (free_current_contents, &range_types);
	        }
	      range_types[ndim++] = child_die->type;
            }
d3169 1
a3169 1
  attr = dwarf2_attr (die, DW_AT_GNU_vector, cu);
d3189 1
a3189 1
  attr = dwarf2_attr (die, DW_AT_location, cu);
d3213 1
a3213 1
	  attr = dwarf2_attr (child_die, DW_AT_data_member_location, cu);
d3232 1
a3232 1
  const char *name;
d3236 1
a3236 1
  name = namespace_name (die, &is_anonymous, cu);
d3261 1
a3261 1
  if (dwarf2_extension (die, cu) == NULL)
d3299 1
a3299 1
namespace_name (struct die_info *die, int *is_anonymous, struct dwarf2_cu *cu)
d3308 1
a3308 1
       current_die = dwarf2_extension (die, cu))
d3310 1
a3310 1
      name = dwarf2_name (current_die, cu);
d3343 1
a3343 1
  attr_byte_size = dwarf2_attr (die, DW_AT_byte_size, cu);
d3349 1
a3349 1
  attr_address_class = dwarf2_attr (die, DW_AT_address_class, cu);
d3421 1
a3421 1
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
d3479 1
a3479 1
  attr = dwarf2_attr (die, DW_AT_string_length, cu);
d3487 1
a3487 1
      attr = dwarf2_attr (die, DW_AT_byte_size, cu);
d3497 1
a3497 1
  index_type = dwarf2_fundamental_type (objfile, FT_INTEGER, cu);
d3499 1
a3499 1
  if (cu->language == language_fortran)
d3507 1
a3507 1
      char_type = dwarf2_fundamental_type (objfile, FT_CHAR, cu);
d3540 1
a3540 1
  attr = dwarf2_attr (die, DW_AT_prototyped, cu);
d3542 1
a3542 1
      || cu->language == language_cplus)
d3579 1
a3579 1
	      attr = dwarf2_attr (child_die, DW_AT_artificial, cu);
d3603 1
a3603 1
      attr = dwarf2_attr (die, DW_AT_name, cu);
d3630 1
a3630 1
  attr = dwarf2_attr (die, DW_AT_encoding, cu);
d3635 1
a3635 1
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
d3640 1
a3640 1
  attr = dwarf2_attr (die, DW_AT_name, cu);
d3677 1
a3677 2
	TYPE_TARGET_TYPE (type) = dwarf2_fundamental_type (objfile, FT_VOID,
							   cu);
d3682 1
a3682 1
	      = dwarf2_fundamental_type (objfile, FT_EXT_PREC_FLOAT, cu);
d3685 1
a3685 1
	      = dwarf2_fundamental_type (objfile, FT_DBL_PREC_FLOAT, cu);
d3688 1
a3688 1
	      = dwarf2_fundamental_type (objfile, FT_FLOAT, cu);
a3697 72
/* Read the given DW_AT_subrange DIE.  */

static void
read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *base_type;
  struct type *range_type;
  struct attribute *attr;
  int low = 0;
  int high = -1;
  
  /* If we have already decoded this die, then nothing more to do.  */
  if (die->type)
    return;

  base_type = die_type (die, cu);
  if (base_type == NULL)
    {
      complaint (&symfile_complaints,
                "DW_AT_type missing from DW_TAG_subrange_type");
      return;
    }

  if (TYPE_CODE (base_type) == TYPE_CODE_VOID)
    base_type = alloc_type (NULL);

  if (cu->language == language_fortran)
    { 
      /* FORTRAN implies a lower bound of 1, if not given.  */
      low = 1;
    }

  attr = dwarf2_attr (die, DW_AT_lower_bound, cu);
  if (attr)
    low = dwarf2_get_attr_constant_value (attr, 0);

  attr = dwarf2_attr (die, DW_AT_upper_bound, cu);
  if (attr)
    {       
      if (attr->form == DW_FORM_block1)
        {
          /* GCC encodes arrays with unspecified or dynamic length
             with a DW_FORM_block1 attribute.
             FIXME: GDB does not yet know how to handle dynamic
             arrays properly, treat them as arrays with unspecified
             length for now.

             FIXME: jimb/2003-09-22: GDB does not really know
             how to handle arrays of unspecified length
             either; we just represent them as zero-length
             arrays.  Choose an appropriate upper bound given
             the lower bound we've computed above.  */
          high = low - 1;
        }
      else
        high = dwarf2_get_attr_constant_value (attr, 1);
    }

  range_type = create_range_type (NULL, base_type, low, high);

  attr = dwarf2_attr (die, DW_AT_name, cu);
  if (attr && DW_STRING (attr))
    TYPE_NAME (range_type) = DW_STRING (attr);
  
  attr = dwarf2_attr (die, DW_AT_byte_size, cu);
  if (attr)
    TYPE_LENGTH (range_type) = DW_UNSND (attr);

  die->type = range_type;
}
  

d3820 1
a3820 1
   object file specified by OBJFILE into the objfile_obstack and return it.  */
d3832 1
a3832 1
  buf = (char *) obstack_alloc (&objfile->objfile_obstack, size);
d4067 1
a4067 1
	      dwarf_info_buffer + dwarf2_get_ref_die_offset (&attr, cu);
d4082 1
a4082 2
      spec_ptr = dwarf_info_buffer
	+ dwarf2_get_ref_die_offset (&spec_attr, cu);
d4616 1
a4616 1
set_cu_language (unsigned int lang, struct dwarf2_cu *cu)
d4622 1
a4622 1
      cu->language = language_c;
d4625 1
a4625 1
      cu->language = language_cplus;
d4630 1
a4630 1
      cu->language = language_fortran;
d4633 1
a4633 1
      cu->language = language_asm;
d4636 1
a4636 1
      cu->language = language_java;
d4645 1
a4645 1
      cu->language = language_minimal;
d4648 1
a4648 1
  cu->language_defn = language_def (cu->language);
d4654 1
a4654 1
dwarf2_attr (struct die_info *die, unsigned int name, struct dwarf2_cu *cu)
d4672 1
a4672 1
      follow_die_ref (dwarf2_get_ref_die_offset (spec, cu));
d4675 1
a4675 1
	return dwarf2_attr (ref_die, name, cu);
d4682 1
a4682 1
die_is_declaration (struct die_info *die, struct dwarf2_cu *cu)
d4684 2
a4685 2
  return (dwarf2_attr (die, DW_AT_declaration, cu)
	  && ! dwarf2_attr (die, DW_AT_specification, cu));
a4687 13
/* Return the die giving the specification for DIE, if there is
   one.  */

static struct die_info *
die_specification (struct die_info *die, struct dwarf2_cu *cu)
{
  struct attribute *spec_attr = dwarf2_attr (die, DW_AT_specification, cu);

  if (spec_attr == NULL)
    return NULL;
  else
    return follow_die_ref (dwarf2_get_ref_die_offset (spec_attr, cu));
}
d4880 1
a4880 1
check_cu_functions (CORE_ADDR address, struct dwarf2_cu *cu)
d4885 1
a4885 1
  if (!cu->first_fn)
d4888 2
a4889 2
  if (!cu->cached_fn)
    cu->cached_fn = cu->first_fn;
d4891 1
a4891 1
  fn = cu->cached_fn;
d4898 2
a4899 2
  fn = cu->first_fn;
  while (fn && fn != cu->cached_fn)
a4929 4
  CORE_ADDR baseaddr;
  struct objfile *objfile = cu->objfile;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d4975 1
a4975 1
	                   check_cu_functions (address, cu));
d5022 1
a5022 1
	                   check_cu_functions (address, cu));
a5202 3
  CORE_ADDR baseaddr;

  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d5205 1
a5205 1
    name = dwarf2_linkage_name (die, cu);
d5211 1
a5211 1
      sym = (struct symbol *) obstack_alloc (&objfile->objfile_obstack,
d5217 1
a5217 1
      SYMBOL_LANGUAGE (sym) = cu->language;
d5228 1
a5228 1
      attr = dwarf2_attr (die, DW_AT_decl_line, cu);
d5236 1
a5236 1
	  attr = dwarf2_attr (die, DW_AT_low_pc, cu);
d5247 1
a5247 1
	  attr2 = dwarf2_attr (die, DW_AT_external, cu);
d5254 1
a5254 1
	      add_symbol_to_list (sym, cu->list_in_scope);
d5266 1
a5266 1
	  attr = dwarf2_attr (die, DW_AT_const_value, cu);
d5270 1
a5270 1
	      attr2 = dwarf2_attr (die, DW_AT_external, cu);
d5274 1
a5274 1
		add_symbol_to_list (sym, cu->list_in_scope);
d5277 1
a5277 1
	  attr = dwarf2_attr (die, DW_AT_location, cu);
d5281 1
a5281 1
	      attr2 = dwarf2_attr (die, DW_AT_external, cu);
d5285 1
a5285 1
		add_symbol_to_list (sym, cu->list_in_scope);
d5295 1
a5295 1
	      attr2 = dwarf2_attr (die, DW_AT_external, cu);
d5297 1
a5297 1
		  && dwarf2_attr (die, DW_AT_type, cu) != NULL)
d5305 1
a5305 1
	  attr = dwarf2_attr (die, DW_AT_location, cu);
d5313 1
a5313 1
	  attr = dwarf2_attr (die, DW_AT_const_value, cu);
d5318 1
a5318 1
	  add_symbol_to_list (sym, cu->list_in_scope);
d5331 1
d5333 4
a5336 6
	  /* Make sure that the symbol includes appropriate enclosing
	     classes/namespaces in its name.  These are calculated in
	     read_structure_scope, and the correct name is saved in
	     the type.  */

	  if (cu->language == language_cplus)
d5338 11
a5348 12
	      struct type *type = SYMBOL_TYPE (sym);
	      
	      if (TYPE_TAG_NAME (type) != NULL)
		{
		  /* FIXME: carlton/2003-11-10: Should this use
		     SYMBOL_SET_NAMES instead?  (The same problem also
		     arises a further down in the function.)  */
		  SYMBOL_LINKAGE_NAME (sym)
		    = obsavestring (TYPE_TAG_NAME (type),
				    strlen (TYPE_TAG_NAME (type)),
				    &objfile->objfile_obstack);
		}
a5349 36

	  {
	    /* NOTE: carlton/2003-11-10: C++ class symbols shouldn't
	       really ever be static objects: otherwise, if you try
	       to, say, break of a class's method and you're in a file
	       which doesn't mention that class, it won't work unless
	       the check for all static symbols in lookup_symbol_aux
	       saves you.  See the OtherFileClass tests in
	       gdb.c++/namespace.exp.  */

	    struct pending **list_to_add;

	    list_to_add = (cu->list_in_scope == &file_symbols
			   && cu->language == language_cplus
			   ? &global_symbols : cu->list_in_scope);
	  
	    add_symbol_to_list (sym, list_to_add);

	    /* The semantics of C++ state that "struct foo { ... }" also
	       defines a typedef for "foo". Synthesize a typedef symbol so
	       that "ptype foo" works as expected.  */
	    if (cu->language == language_cplus)
	      {
		struct symbol *typedef_sym = (struct symbol *)
		  obstack_alloc (&objfile->objfile_obstack,
				 sizeof (struct symbol));
		*typedef_sym = *sym;
		SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
		if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
		  TYPE_NAME (SYMBOL_TYPE (sym)) =
		    obsavestring (SYMBOL_NATURAL_NAME (sym),
				  strlen (SYMBOL_NATURAL_NAME (sym)),
				  &objfile->objfile_obstack);
		add_symbol_to_list (typedef_sym, list_to_add);
	      }
	  }
a5351 12
	  if (processing_has_namespace_info
	      && processing_current_prefix[0] != '\0')
	    {
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->objfile_obstack,
						    processing_current_prefix,
						    "::",
						    name);
	    }
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
	  add_symbol_to_list (sym, cu->list_in_scope);
	  break;
a5352 1
        case DW_TAG_subrange_type:
d5355 1
a5355 1
	  add_symbol_to_list (sym, cu->list_in_scope);
d5358 1
a5358 9
	  if (processing_has_namespace_info
	      && processing_current_prefix[0] != '\0')
	    {
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->objfile_obstack,
						    processing_current_prefix,
						    "::",
						    name);
	    }
	  attr = dwarf2_attr (die, DW_AT_const_value, cu);
d5363 1
a5363 12
	  {
	    /* NOTE: carlton/2003-11-10: See comment above in the
	       DW_TAG_class_type, etc. block.  */

	    struct pending **list_to_add;

	    list_to_add = (cu->list_in_scope == &file_symbols
			   && cu->language == language_cplus
			   ? &global_symbols : cu->list_in_scope);
	  
	    add_symbol_to_list (sym, list_to_add);
	  }
d5401 1
a5401 1
	obstack_alloc (&objfile->objfile_obstack, cu_header->addr_size);
d5419 1
a5419 1
	obstack_alloc (&objfile->objfile_obstack, blk->size);
d5495 1
a5495 1
  type_attr = dwarf2_attr (die, DW_AT_type, cu);
d5499 1
a5499 1
      return dwarf2_fundamental_type (cu->objfile, FT_VOID, cu);
d5503 1
a5503 1
      ref = dwarf2_get_ref_die_offset (type_attr, cu);
d5533 1
a5533 1
  type_attr = dwarf2_attr (die, DW_AT_containing_type, cu);
d5536 1
a5536 1
      ref = dwarf2_get_ref_die_offset (type_attr, cu);
a5596 5
  char *prefix = determine_prefix (die, cu);
  const char *old_prefix = processing_current_prefix;
  struct cleanup *back_to = make_cleanup (xfree, prefix);
  processing_current_prefix = prefix;
  
a5634 3
    case DW_TAG_subrange_type:
      read_subrange_type (die, cu);
      break;
a5642 123

  processing_current_prefix = old_prefix;
  do_cleanups (back_to);
}

/* Return the name of the namespace/class that DIE is defined within,
   or "" if we can't tell.  The caller should xfree the result.  */

/* NOTE: carlton/2004-01-23: See read_func_scope (and the comment
   therein) for an example of how to use this function to deal with
   DW_AT_specification.  */

static char *
determine_prefix (struct die_info *die, struct dwarf2_cu *cu)
{
  char *prefix = determine_prefix_aux (die, cu);

  return prefix ? prefix : xstrdup ("");
}

/* Return the name of the namespace/class that DIE is defined
   within, or NULL if we can't tell.  The caller should xfree the
   result.  */

static char *
determine_prefix_aux (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *parent;

  if (cu->language != language_cplus)
    return NULL;

  parent = die->parent;

  if (parent == NULL)
    {
      return (processing_has_namespace_info ? xstrdup ("") : NULL);
    }
  else
    {
      char *parent_prefix = determine_prefix_aux (parent, cu);
      char *retval;

      switch (parent->tag) {
      case DW_TAG_namespace:
	{
	  int dummy;

	  retval = typename_concat (parent_prefix,
				    namespace_name (parent, &dummy, cu));
	}
	break;
      case DW_TAG_class_type:
      case DW_TAG_structure_type:
	{
	  if (parent_prefix != NULL)
	    {
	      const char *parent_name = dwarf2_name (parent, cu);

	      if (parent_name != NULL)
		retval = typename_concat (parent_prefix, dwarf2_name (parent, cu));
	      else
		/* FIXME: carlton/2003-11-10: I'm not sure what the
		   best thing to do here is.  */
		retval = typename_concat (parent_prefix,
					  "<<anonymous class>>");
	    }
	  else
	    retval = class_name (parent, cu);
	}
	break;
      default:
	retval = parent_prefix;
	break;
      }

      if (retval != parent_prefix)
	xfree (parent_prefix);
      return retval;
    }
}

/* Return a newly-allocated string formed by concatenating PREFIX,
   "::", and SUFFIX, except that if PREFIX is NULL or the empty
   string, just return a copy of SUFFIX.  */

static char *
typename_concat (const char *prefix, const char *suffix)
{
  if (prefix == NULL || prefix[0] == '\0')
    return xstrdup (suffix);
  else
    {
      char *retval = xmalloc (strlen (prefix) + 2 + strlen (suffix) + 1);

      strcpy (retval, prefix);
      strcat (retval, "::");
      strcat (retval, suffix);

      return retval;
    }
}

/* Return a newly-allocated string giving the name of the class given
   by DIE.  */

static char *
class_name (struct die_info *die, struct dwarf2_cu *cu)
{
  struct die_info *child;
  const char *name;

  for (child = die->child; child != NULL; child = sibling_die (child))
    {
      if (child->tag == DW_TAG_subprogram)
	return class_name_from_physname (dwarf2_linkage_name (child, cu));
    }

  name = dwarf2_name (die, cu);
  if (name != NULL)
    return xstrdup (name);
  else
    return xstrdup ("");
d5656 1
a5656 1
      type = dwarf2_fundamental_type (objfile, FT_VOID, cu);
d5659 1
a5659 1
      type = dwarf2_fundamental_type (objfile, FT_BOOLEAN, cu);
d5664 1
a5664 1
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_COMPLEX, cu);
d5668 1
a5668 1
	  type = dwarf2_fundamental_type (objfile, FT_COMPLEX, cu);
d5674 1
a5674 1
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_FLOAT, cu);
d5678 1
a5678 1
	  type = dwarf2_fundamental_type (objfile, FT_FLOAT, cu);
d5685 1
a5685 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR, cu);
d5688 1
a5688 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_SHORT, cu);
d5692 1
a5692 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER, cu);
d5697 1
a5697 1
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR, cu);
d5703 1
a5703 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR, cu);
d5706 1
a5706 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_SHORT, cu);
d5710 1
a5710 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_INTEGER, cu);
d5715 1
a5715 1
      type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR, cu);
d5718 1
a5718 1
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER, cu);
d5767 1
a5767 1
dwarf2_linkage_name (struct die_info *die, struct dwarf2_cu *cu)
d5771 1
a5771 1
  attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cu);
d5774 1
a5774 1
  attr = dwarf2_attr (die, DW_AT_name, cu);
d5783 1
a5783 1
dwarf2_name (struct die_info *die, struct dwarf2_cu *cu)
d5787 1
a5787 1
  attr = dwarf2_attr (die, DW_AT_name, cu);
d5797 1
a5797 1
dwarf2_extension (struct die_info *die, struct dwarf2_cu *cu)
d5803 1
a5803 1
  attr = dwarf2_attr (die, DW_AT_extension, cu);
d5807 1
a5807 1
  ref = dwarf2_get_ref_die_offset (attr, cu);
d6720 1
a6720 1
dwarf2_get_ref_die_offset (struct attribute *attr, struct dwarf2_cu *cu)
d6734 1
a6734 1
      result = cu->header.offset + DW_UNSND (attr);
a6743 22
/* Return the constant value held by the given attribute.  Return -1
   if the value held by the attribute is not constant.  */

static int
dwarf2_get_attr_constant_value (struct attribute *attr, int default_value)
{
  if (attr->form == DW_FORM_sdata)
    return DW_SND (attr);
  else if (attr->form == DW_FORM_udata
           || attr->form == DW_FORM_data1
           || attr->form == DW_FORM_data2
           || attr->form == DW_FORM_data4
           || attr->form == DW_FORM_data8)
    return DW_UNSND (attr);
  else
    {
      complaint (&symfile_complaints, "Attribute value is not a constant (%s)",
                 dwarf_form_name (attr->form));
      return default_value;
    }
}

d6764 1
a6764 2
dwarf2_fundamental_type (struct objfile *objfile, int typeid,
			 struct dwarf2_cu *cu)
d6776 1
a6776 1
  if (cu->ftypes[typeid] == NULL)
d6778 1
a6778 1
      cu->ftypes[typeid] = cu->language_defn->la_fund_type (objfile, typeid);
d6781 1
a6781 1
  return (cu->ftypes[typeid]);
d7101 1
a7101 1
    pending_macros = new_macro_table (&objfile->objfile_obstack,
d7444 1
a7444 1
      baton = obstack_alloc (&cu->objfile->objfile_obstack,
d7457 1
a7457 1
      SYMBOL_OPS (sym) = &dwarf2_loclist_funcs;
d7464 1
a7464 1
      baton = obstack_alloc (&cu->objfile->objfile_obstack,
d7486 1
a7486 1
      SYMBOL_OPS (sym) = &dwarf2_locexpr_funcs;
@


1.66
log
@2002-09-03  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (dwarf2_add_member_fn): Add the 'type'
	argument (PR gdb/653).  Update call to smash_to_method_type.
	(read_structure_scope): Update call to dwarf2_add_member_fn.
@
text
@d5964 12
@


1.66.2.1
log
@2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (dwarf_tag_name): Add DWARF 3 names.
	(dwarf_attr_name): Ditto.
	(dwarf_type_encoding_name): Ditto.
	(scan_partial_symbols): Descend into DW_TAG_namespace entries.
	(process_die): Handle DW_TAG_namespace,
	DW_TAG_imported_declaration, DW_TAG_imported_module.
	(read_namespace): New function.
@
text
@a818 3
static void read_namespace (struct die_info *die, struct objfile *objfile,
			    const struct comp_unit_head *cu_header);

a1303 11
  /* We only want to read in symbols corresponding to variables or
     other similar objects that are global or static.  Normally, these
     are all children of the DW_TAG_compile_unit die, so are all at
     level 1.  But C++ namespaces give ries to DW_TAG_namespace dies
     whose children are global objects.  So we keep track of what
     level we currently think of as referring to file scope; this
     should always equal 1 plus the number of namespaces that we are
     currently nested within.  */
  
  int file_scope_level = 1;

d1326 1
a1326 1
		  if ((pdi.is_external || nesting_level == file_scope_level)
d1339 1
a1339 1
	      if ((pdi.is_external || nesting_level == file_scope_level)
d1346 3
a1348 5
	      /* File scope enumerators are added to the partial
	         symbol table.  They're children of the enumeration
	         type die, so they occur at a level one higher than we
	         normally look for.  */
	      if (nesting_level == file_scope_level + 1)
d1354 1
a1354 1
	      if (nesting_level == file_scope_level)
a1356 7
	    case DW_TAG_namespace:
	      /* FIXME: carlton/2002-10-16: we're not yet doing
		 anything useful with this, but for now make sure that
		 these tags at least don't cause us to miss any
		 important symbols.  */
	      if (pdi.has_children)
		file_scope_level++;
d1362 4
a1365 7
      /* If the die has a sibling, skip to the sibling.  Do not skip
         enumeration types, we want to record their enumerators.  Do
         not skip namespaces, we want to record symbols inside
         them.  */
      if (pdi.sibling
	  && pdi.tag != DW_TAG_enumeration_type
	  && pdi.tag != DW_TAG_namespace)
d1371 2
a1372 2
	  /* Die has children, but either the optional DW_AT_sibling
	     attribute is missing or we want to look at them.  */
a1378 7
	  /* If this is the end of a DW_TAG_namespace entry, then
	     decrease the file_scope_level, too.  */
	  if (nesting_level < file_scope_level)
	    {
	      file_scope_level--;
	      gdb_assert (nesting_level == file_scope_level);
	    }
a1677 13
    case DW_TAG_namespace:
      read_namespace (die, objfile, cu_header);
      break;
    case DW_TAG_imported_declaration:
    case DW_TAG_imported_module:
      /* FIXME: carlton/2002-10-16: Eventually, we should use the
	 information contained in these.  DW_TAG_imported_declaration
	 dies shouldn't have children; DW_TAG_imported_module dies
	 shouldn't in the C++ case, but conceivably could in the
	 Fortran case, so we'll have to replace this gdb_assert if
	 Fortran compilers start generating that info.  */
      gdb_assert (!die->has_children);
      break;
a2892 21
/* Read a C++ namespace.  */

/* FIXME: carlton/2002-10-16: For now, we don't actually do anything
   useful with the namespace data: we just process its children.  */

static void
read_namespace (struct die_info *die, struct objfile *objfile,
		const struct comp_unit_head *cu_header)
{
  if (die->has_children)
    {
      struct die_info *child_die = die->next;
      
      while (child_die && child_die->tag)
	{
	  process_die (child_die, objfile, cu_header);
	  child_die = sibling_die (child_die);
	}
    }
}

a5431 16
    case DW_TAG_dwarf_procedure:
      return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:
      return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:
      return "DW_TAG_interface_type";
    case DW_TAG_namespace:
      return "DW_TAG_namespace";
    case DW_TAG_imported_module:
      return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:
      return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:
      return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:
      return "DW_TAG_imported_unit";
d5576 1
a5576 24
    case DW_AT_allocated:
      return "DW_AT_allocated";
    case DW_AT_associated:
      return "DW_AT_associated";
    case DW_AT_data_location:
      return "DW_AT_data_location";
    case DW_AT_stride:
      return "DW_AT_stride";
    case DW_AT_entry_pc:
      return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:
      return "DW_AT_use_UTF8";
    case DW_AT_extension:
      return "DW_AT_extension";
    case DW_AT_ranges:
      return "DW_AT_ranges";
    case DW_AT_trampoline:
      return "DW_AT_trampoline";
    case DW_AT_call_column:
      return "DW_AT_call_column";
    case DW_AT_call_file:
      return "DW_AT_call_file";
    case DW_AT_call_line:
      return "DW_AT_call_line";
a6000 2
    case DW_ATE_imaginary_float:
      return "DW_ATE_imaginary_float";
@


1.66.2.2
log
@2002-11-25  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (scan_partial_symbols): Descend into namespace
	pdi's with no name.
@
text
@d1325 1
a1325 3
      /* Anonymous namespaces have no name but are interesting.  */

      if (pdi.name != NULL || pdi.tag == DW_TAG_namespace)
@


1.66.2.3
log
@2003-02-03  Michal Ludvig  <mludvig@@suse.cz>

	* dwarf2cfi.c (pointer_encoding): Added new parameter.
	* dwarf2cfi.c, dwarf2read.c: Changed all warnings and
	error messages to contain BFD filename.
@
text
@d1199 1
a1199 1
	  error ("Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]", cu_header.version, 2, bfd_get_filename (abfd));
d1204 1
a1204 1
	  error ("Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6) [in module %s]",
d1206 1
a1206 2
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
d1212 1
a1212 1
	  error ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0) [in module %s]",
d1214 1
a1214 2
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
d3554 1
a3554 2
      error ("Dwarf Error: Could not find abbrev number %d [in module %s]", abbrev_number,
		      bfd_get_filename (abfd));
d3698 1
a3698 2
      error ("Dwarf Error: could not find abbrev number %d [in module %s]", abbrev_number, 
		      bfd_get_filename (abfd));
d3834 2
a3835 3
      error ("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]",
	     dwarf_form_name (form),
	     bfd_get_filename (abfd));
d3916 1
a3916 2
			  "read_address: bad switch, signed [in module %s]",
			  bfd_get_filename (abfd));
d3934 1
a3934 2
			  "read_address: bad switch, unsigned [in module %s]",
			  bfd_get_filename (abfd));
d4049 1
a4049 2
		      "read_offset: bad switch [in module %s]",
		      bfd_get_filename (abfd));
d4091 1
a4091 2
      error ("DW_FORM_strp used without .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d4096 1
a4096 2
      error ("DW_FORM_strp pointing outside of .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d5094 1
a5094 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", 
			  ref, objfile->name);
d5102 1
a5102 2
      error ("Dwarf Error: Problem turning type die at offset into gdb type [in module %s]",
		      objfile->name);
d5126 1
a5126 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", ref, 
			  objfile->name);
d5135 1
a5135 2
      error ("Dwarf Error: Problem turning containing type into gdb type [in module %s]", 
		      objfile->name);
d5172 1
a5172 2
	  error ("Dwarf Error: Cannot find type of die [in module %s]", 
			  objfile->name);
d6332 2
a6333 2
      error ("Dwarf Error: internal error - invalid fundamental type id %d [in module %s]",
	     typeid, objfile->name);
@


1.66.4.1
log
@2002-09-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.h: Delete BLOCK_SHOULD_SORT.
	* symtab.c (lookup_block_symbol): Assume non-hashed blocks aren't
	sorted.
	* ada-lang.c (ada_add_block_symbols): Ditto.
	* symfile.h: Delete prototypes for sort_block_syms and
	sort_symtab_syms.
	* symfile.c: Delete functions sort_block_syms and
	sort_symtab_syms.
	* coffread.c (coff_symfile_read): Remove call to
	sort_symtab_syms.
	* xcoffread.c (xcoff_psymtab_to_symtab_1): Ditto.
	* mdebugread.c (psymtab_to_symtab_1): Ditto.
	* hpread.c (hpread_psymtab_to_symtab_1): Ditto.
	* dwarfread.c (psymtab_to_symtab_1): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	* dbxread.c (dbx_psymtab_to_symtab_1): Ditto.

2002-09-20  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (c-lang.o): Correct dependencies.
	(utils.o): Gather dependencies.
	(charset.o): Move.
@
text
@d1609 1
@


1.66.4.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a164 5
/* We hold several abbreviation tables in memory at the same time. */
#ifndef ABBREV_HASH_SIZE
#define ABBREV_HASH_SIZE 121
#endif

a176 23

    /* Offset to the first byte of this compilation unit header in the 
     * .debug_info section, for resolving relative reference dies. */

    unsigned int offset;

    /* Pointer to this compilation unit header in the .debug_info
     * section */

    char *cu_head_ptr;

    /* Pointer to the first die of this compilatio unit.  This will
     * be the first byte following the compilation unit header. */

    char *first_die_ptr;

    /* Pointer to the next compilation unit header in the program. */

    struct comp_unit_head *next;

    /* DWARF abbreviation table associated with this compilation unit */

    struct abbrev_info *dwarf2_abbrevs[ABBREV_HASH_SIZE];
d315 5
d324 2
d689 1
a689 1
static void dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header);
d693 1
a693 2
static struct abbrev_info *dwarf2_lookup_abbrev (unsigned int,
                                         const struct comp_unit_head *cu_header);
a1213 5
      /* Complete the cu_header */
      cu_header.offset = beg_of_comp_unit - dwarf_info_buffer;
      cu_header.first_die_ptr = info_ptr;
      cu_header.cu_head_ptr = beg_of_comp_unit;

d1215 2
a1216 2
      dwarf2_read_abbrevs (abfd, &cu_header);
      make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
d1563 2
a1564 2
  dwarf2_read_abbrevs (abfd, &cu_header);
  make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
d3347 1
a3347 1
dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header)
d3354 2
a3355 3
  /* Initialize dwarf2 abbrevs */
  memset (cu_header->dwarf2_abbrevs, 0,
          ABBREV_HASH_SIZE*sizeof (struct abbrev_info *));
d3357 1
a3357 1
  abbrev_ptr = dwarf_abbrev_buffer + cu_header->abbrev_offset;
d3396 2
a3397 2
      cur_abbrev->next = cu_header->dwarf2_abbrevs[hash_number];
      cu_header->dwarf2_abbrevs[hash_number] = cur_abbrev;
d3411 1
a3411 1
      if (dwarf2_lookup_abbrev (abbrev_number, cu_header) != NULL)
d3420 1
a3420 1
dwarf2_empty_abbrev_table (PTR ptr_to_abbrevs_table)
a3423 3
  struct abbrev_info **abbrevs;

  abbrevs = (struct abbrev_info **)ptr_to_abbrevs_table;
d3428 1
a3428 1
      abbrev = abbrevs[i];
d3436 1
a3436 1
      abbrevs[i] = NULL;
d3443 1
a3443 1
dwarf2_lookup_abbrev (unsigned int number, const struct comp_unit_head *cu_header)
d3449 1
a3449 1
  abbrev = cu_header->dwarf2_abbrevs[hash_number];
d3481 1
a3481 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
d3625 1
a3625 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
a5962 12
      /* DWARF 3 extensions.  */
    case DW_OP_push_object_address:
      return "DW_OP_push_object_address";
    case DW_OP_call2:
      return "DW_OP_call2";
    case DW_OP_call4:
      return "DW_OP_call4";
    case DW_OP_call_ref:
      return "DW_OP_call_ref";
      /* GNU extensions.  */
    case DW_OP_GNU_push_tls_address:
      return "DW_OP_GNU_push_tls_address";
@


1.66.4.3
log
@2002-10-16  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (dwarf_tag_name): Add DWARF 3 names.
	(dwarf_attr_name): Ditto.
	(dwarf_type_encoding_name): Ditto.
	(scan_partial_symbols): Descend into DW_TAG_namespace entries.
	(process_die): Handle DW_TAG_namespace,
	DW_TAG_imported_declaration, DW_TAG_imported_module.
	(read_namespace): New function.

2002-10-17  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.cc: Add namespace renaming, using directives,
	and using declarations.
	* gdb.c++/namespace.exp: Add some xfails, including namespace
	renaming, using directives, and using declarations.
@
text
@a840 3
static void read_namespace (struct die_info *die, struct objfile *objfile,
			    const struct comp_unit_head *cu_header);

a1330 5
  /* What level do we consider to be file scope?  This is normally 1,
     but can get pushed up by DW_TAG_namespace entries.  */
  
  int file_scope_level = 1;

d1353 1
a1353 1
		  if ((pdi.is_external || nesting_level == file_scope_level)
d1366 1
a1366 1
	      if ((pdi.is_external || nesting_level == file_scope_level)
d1375 1
a1375 1
	      if (nesting_level == file_scope_level + 1)
d1381 1
a1381 1
	      if (nesting_level == file_scope_level)
a1383 7
	    case DW_TAG_namespace:
	      /* FIXME: carlton/2002-10-16: we're not yet doing
		 anything useful with this, but for now make sure that
		 these tags at least don't cause us to miss any
		 important symbols.  */
	      if (pdi.has_children)
		file_scope_level++;
d1389 4
a1392 7
      /* If the die has a sibling, skip to the sibling.  Do not skip
         enumeration types, we want to record their enumerators.  Do
         not skip namespaces, we want to record symbols inside
         them.  */
      if (pdi.sibling
	  && pdi.tag != DW_TAG_enumeration_type
	  && pdi.tag != DW_TAG_namespace)
d1398 2
a1399 2
	  /* Die has children, but either the optional DW_AT_sibling
	     attribute is missing or we want to look at them.  */
a1405 4
	  /* If this is the end of a DW_TAG_namespace entry, then
	     decrease the file_scope_level, too.  */
	  if (nesting_level < file_scope_level)
	    file_scope_level--;
a1703 13
    case DW_TAG_namespace:
      read_namespace (die, objfile, cu_header);
      break;
    case DW_TAG_imported_declaration:
    case DW_TAG_imported_module:
      /* FIXME: carlton/2002-10-16: Eventually, we should use the
	 information contained in these.  DW_TAG_imported_declaration
	 dies shouldn't have children; DW_TAG_imported_module dies
	 shouldn't in the C++ case, but conceivably could in the
	 Fortran case, so we'll have to replace this gdb_assert if
	 Fortran compilers start generating that info.  */
      gdb_assert (!die->has_children);
      break;
a2918 21
/* Read a C++ namespace.  */

/* FIXME: carlton/2002-10-16: For now, we don't actually do anything
   useful with the namespace data: we just process its children.  */

static void
read_namespace (struct die_info *die, struct objfile *objfile,
		const struct comp_unit_head *cu_header)
{
  if (die->has_children)
    {
      struct die_info *child_die = die->next;
      
      while (child_die && child_die->tag)
	{
	  process_die (child_die, objfile, cu_header);
	  child_die = sibling_die (child_die);
	}
    }
}

a5461 16
    case DW_TAG_dwarf_procedure:
      return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:
      return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:
      return "DW_TAG_interface_type";
    case DW_TAG_namespace:
      return "DW_TAG_namespace";
    case DW_TAG_imported_module:
      return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:
      return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:
      return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:
      return "DW_TAG_imported_unit";
d5606 1
a5606 24
    case DW_AT_allocated:
      return "DW_AT_allocated";
    case DW_AT_associated:
      return "DW_AT_associated";
    case DW_AT_data_location:
      return "DW_AT_data_location";
    case DW_AT_stride:
      return "DW_AT_stride";
    case DW_AT_entry_pc:
      return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:
      return "DW_AT_use_UTF8";
    case DW_AT_extension:
      return "DW_AT_extension";
    case DW_AT_ranges:
      return "DW_AT_ranges";
    case DW_AT_trampoline:
      return "DW_AT_trampoline";
    case DW_AT_call_column:
      return "DW_AT_call_column";
    case DW_AT_call_file:
      return "DW_AT_call_file";
    case DW_AT_call_line:
      return "DW_AT_call_line";
a6042 2
    case DW_ATE_imaginary_float:
      return "DW_ATE_imaginary_float";
@


1.66.4.4
log
@2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* Makefile.in (block_h): New variable.
	Updated dependencies to reflect it.
	* parse.c (parse_exp_1): Use BLOCK_START.
	#include "block.h"
	* p-exp.tab.c: Regenerated.
	* m2-exp.tab.c: Ditto.
	* jv-exp.tab.c: Ditto.
	* f-exp.tab.c: Ditto.
	* c-exp.tab.c: Ditto.
	* ada-exp.tab.c: Ditto.
	* ada-lang.c: #include "block.h"
	* p-exp.y: Ditto.
	* objc-exp.y: Ditto.
	* m2-exp.y: Ditto.
	* jv-exp.y: Ditto.
	* f-exp.y: Ditto.
	* c-exp.y: Ditto.
	* ada-exp.y: Ditto.
	* values.c: Ditto.
	* valops.c: Ditto.
	* tracepoint.c: Ditto.
	* symtab.c: Ditto.
	* symmisc.c: Ditto.
	* symfile.c: Ditto.
	* stack.c: Ditto.
	* printcmd.c: Ditto.
	* objfiles.c: Ditto.
	* objc-lang.c: Ditto.
	* nlmread.c: Ditto.
	* mips-tdep.c: Ditto.
	* mdebugread.c: Ditto.
	* linespec.c: Ditto.
	* jv-lang.c: Ditto.
	* infcmd.c: Ditto.
	* f-valprint.c: Ditto.
	* findvar.c: Ditto.
	* expprint.c: Ditto.
	* coffread.c: Ditto.
	* buildsym.c: Ditto.
	* breakpoint.c: Ditto.
	* blockframe.c: Ditto.
	* ax-gdb.c: Ditto.
	* alpha-tdep.c: Ditto.
	* block.h: New file.
	* symtab.h: Moved struct block, struct blockvector, and related
	macros and function declarations to block.h.
	* dwarf2read.c (process_die): Set processing_has_namespace_info if
	we run into DW_TAG_namespace, DW_TAG_imported_declaration, or
	DW_TAG_imported_module.
	New variable current_namespace.
	(psymtab_to_symtab_1): Set current_namespace to "".
	(dwarf2_name): New function.
	(dwarf2_add_member_fn): Get name via dwarf2_name.
	(read_typedef): Ditto.
	(read_file_scope): Ditto.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(dwarf2_extension): New function.
	(read_namespace): Set current_namespace correctly; also, if we're
	entering an anonymous namespace, add an appropriate using
	directive.
	* buildsym.c (start_symtab): Reset processing_has_namespace_info
	to 0.
	(add_symbol_to_list): Only scan for anonymous namespaces if
	!processing_has_namespace_info.
	* buildsym.h: Add new flag processing_has_namespace_info.

2002-10-18  David Carlton  <carlton@@math.stanford.edu>

	* mi-cmd-stack.c: #include "block.h"
@
text
@a390 7
/* If we're debugging C++ code, this string should contain the name of
   the current namespace.  Other people shouldn't have to copy it when
   referring to it, so don't free its previous contents when setting
   this to a new value.  */

static const char *current_namespace;

a886 4
static char *dwarf2_name (struct die_info *);

static struct die_info * dwarf2_extension (struct die_info *die);

a1601 3
  /* We're in the global namespace.  */
  current_namespace = "";

a1726 1
      processing_has_namespace_info = 1;
a1736 1
      processing_has_namespace_info = 1;
d1759 1
a1759 1
  char *name;
d1794 5
a1798 3
  name = dwarf2_name (die);
  if (name == NULL)
    name = "<unknown>";
d2085 1
a2085 1
  char *fieldname;
d2184 3
a2186 3
      fieldname = dwarf2_name (die);
      if (fieldname == NULL)
	fieldname = "";
d2204 4
a2207 2
      fieldname = dwarf2_name (die);
      if (fieldname == NULL)
d2336 4
a2339 3

  fieldname = dwarf2_name (die);
  if (fieldname == NULL)
a2515 1
  char *name;
d2520 2
a2521 2
  name = dwarf2_name (die);
  if (name != NULL)
d2523 2
a2524 1
      TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
a2674 1
  char *name;
d2681 2
a2682 2
  name = dwarf2_name (die);
  if (name != NULL)
d2684 2
a2685 1
      TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
a2962 37
  const char *previous_namespace = current_namespace;
  const char *name = NULL;
  int is_anonymous;
  struct die_info *current_die;

  /* Loop through the extensions until we find a name.  */

  for (current_die = die; current_die != NULL;
       current_die = dwarf2_extension (die))
    {
      name = dwarf2_name (die);
      if (name != NULL)
	break;
    }

  /* Is it an anonymous namespace?  */

  is_anonymous = (name == NULL);
  if (is_anonymous)
    name = "(anonymous namespace)";

  /* Now build the name of the current namespace.  */

  current_namespace = obconcat (&objfile->symbol_obstack,
				previous_namespace,
				previous_namespace[0] == '\0' ? "" : "::",
				name);

  /* If it's an anonymous namespace that we're seeing for the first
     time, add a using directive.  */

  if (is_anonymous && dwarf_attr (die, DW_AT_extension) == NULL)
    add_using_directive (current_namespace,
			 strlen (previous_namespace),
			 strlen (current_namespace));
  
  
a2972 2

  current_namespace = previous_namespace;
d3228 5
a3232 1
      name = dwarf2_name (die);
a5412 37
}

/* Get name of a die, return NULL if not found.  */

static char *
dwarf2_name (struct die_info *die)
{
  struct attribute *attr;

  attr = dwarf_attr (die, DW_AT_name);
  if (attr && DW_STRING (attr))
    return DW_STRING (attr);
  return NULL;
}

/* Return the die that this die in an extension of, or NULL if there
   is none.  */

static struct die_info *
dwarf2_extension (struct die_info *die)
{
  struct attribute *attr;
  struct die_info *extension_die;
  unsigned int ref;

  attr = dwarf_attr (die, DW_AT_extension);
  if (attr == NULL)
    return NULL;

  ref = dwarf2_get_ref_die_offset (attr);
  extension_die = follow_die_ref (ref);
  if (!extension_die)
    {
      error ("Dwarf Error: Cannot find referent at offset %d.", ref);
    }

  return extension_die;
@


1.66.4.5
log
@2002-10-21  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (add_symbol_to_list): Expand comment.
	* objc-lang.c (find_methods): Use BLOCK_START, BLOCK_END.
	* Makefile.in (x86-64-tdep.o): Depend on block_h.
	* x86-64-tdep.c (x86_64_skip_prologue): Use BLOCK_END and
	SYMBOL_BLOCK_VALUE.
@
text
@d896 1
a896 1
static struct die_info *dwarf2_extension (struct die_info *die);
@


1.66.4.6
log
@2002-10-22  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (scan_partial_symbols): Clarify some comments.
	* symtab.c (lookup_symbol_aux): Always call
	lookup_symbol_aux_using to search global symtabs/psymtabs.
	(lookup_symbol_aux_local): Add static_block argument.
	* buildsym.c (add_symbol_to_list): Do a quick scan for "(anonymous
	namespace)" before calling scan_for_anonymous_namespaces.
	(scan_for_anonymous_namespaces): Delete FIXME comment.
@
text
@d1345 2
a1346 8
  /* We only want to read in symbols corresponding to variables or
     other similar objects that are global or static.  Normally, these
     are all children of the DW_TAG_compile_unit die, so are all at
     level 1.  But C++ namespaces give ries to DW_TAG_namespace dies
     whose children are global objects.  So we keep track of what
     level we currently think of as referring to file scope; this
     should always equal 1 plus the number of namespaces that we are
     currently nested within.  */
d1392 2
a1393 4
	      /* File scope enumerators are added to the partial
	         symbol table.  They're children of the enumeration
	         type die, so they occur at a level one higher than we
	         normally look for.  */
@


1.66.4.7
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a419 6
static int is_thread_local;     /* Variable is at a constant offset in the
                                   thread-local storage block for the
                                   current thread and the dynamic linker
                                   module containing this expression.
                                   decode_locdesc returns the offset from
                                   that base.  */
a692 4
static struct complaint dwarf2_invalid_pointer_size = 
{
  "invalid pointer size %d", 0, 0
};
d1446 1
a1446 4
	    {
	      file_scope_level--;
	      gdb_assert (nesting_level == file_scope_level);
	    }
d3041 1
a3041 3
  struct attribute *attr_byte_size;
  struct attribute *attr_address_class;
  int byte_size, addr_class;
d3049 5
a3053 4

  attr_byte_size = dwarf_attr (die, DW_AT_byte_size);
  if (attr_byte_size)
    byte_size = DW_UNSND (attr_byte_size);
a3054 12
    byte_size = cu_header->addr_size;

  attr_address_class = dwarf_attr (die, DW_AT_address_class);
  if (attr_address_class)
    addr_class = DW_UNSND (attr_address_class);
  else
    addr_class = DW_ADDR_none;

  /* If the pointer size or address class is different than the
     default, create a type variant marked as such and set the
     length accordingly.  */
  if (TYPE_LENGTH (type) != byte_size || addr_class != DW_ADDR_none)
d3056 1
a3056 15
      if (ADDRESS_CLASS_TYPE_FLAGS_P ())
	{
	  int type_flags;

	  type_flags = ADDRESS_CLASS_TYPE_FLAGS (byte_size, addr_class);
	  gdb_assert ((type_flags & ~TYPE_FLAG_ADDRESS_CLASS_ALL) == 0);
	  type = make_type_with_address_space (type, type_flags);
	}
      else if (TYPE_LENGTH (type) != byte_size)
	{
	  complain (&dwarf2_invalid_pointer_size, byte_size);
	}
      else {
	/* Should we also complain about unhandled address classes?  */
      }
a3057 2

  TYPE_LENGTH (type) = byte_size;
a4866 8
                  if (is_thread_local)
                    {
                      /* SYMBOL_VALUE_ADDRESS contains at this point the
		         offset of the variable within the thread local
			 storage.  */
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }
d4875 1
a4875 1
		  else if (SYMBOL_VALUE_ADDRESS (sym))
a4924 5
                  else if (is_thread_local)
                    {
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }
a6514 1
  is_thread_local = 0;
a6736 10

        case DW_OP_GNU_push_tls_address:
          is_thread_local = 1;
	  /* The top of the stack has the offset from the beginning
	     of the thread control block at which the variable is located.  */
	  /* Nothing should follow this operator, so the top of stack would
	     be returned.  */
	  if (i < size)
	    complain (&dwarf2_complex_location_expr);
          break;
@


1.66.4.8
log
@2002-11-13  David Carlton  <carlton@@math.stanford.edu>

	* buildsym.c (finish_block): Initialize block_scope (block) in
	C++ function blocks.
	* dwarf2read.c: Delete variable current_namespace.
	(psymtab_to_symtab_1): Rename current_namespace to
	processing_current_namespace.
	(read_namespace): Ditto.
	* buildsym.h: New variable processing_current_namespace.
	* block.h: Declarations for block_scope and block_set_scope.
	* block.c (block_scope): New function.
	(block_set_scope): New function.
	* cp-support.h (struct namespace_info): Add 'scope' member.
	* buildsym.c (finish_block): Replace BLOCK_USING by
	block_set_using.
	(end_symtab): Ditto.
	* block.h: Declaration for block_set_using.
	* block.c (block_set_using): New function.
	(block_initialize_namespace): New function.
	* symtab.c (lookup_symbol_aux_using): Replace BLOCK_USING by
	block_using.
	* buildsym.c (finish_block): Set BLOCK_NAMESPACE to NULL, not
	BLOCK_USING.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* block.h: Declaration for block_using.
	* block.c (block_using): New function.
	* Makefile.in (block.o): New rule; also add block.c to SFILES and
	block.o to COMMON_OBS.
	* block.c: New file.
	* symtab.c (contained_in): Move to block.c.
	(block_function): Ditto.
	* block.h (struct block): Have the language-specific stuff contain
	a struct namespace_info.
	(BLOCK_NAMESPACE): New macro.
	(BLOCK_USING): Delete.
	* linespec.c (decode_variable): Add comment before
	decode_variable.
	* cp-support.h (struct namespace_info): New struct.
@
text
@d391 7
d1635 1
a1635 1
  processing_current_namespace = "";
d2995 1
a2995 1
  const char *previous_namespace = processing_current_namespace;
d3018 4
a3021 5
  processing_current_namespace = obconcat (&objfile->symbol_obstack,
					   previous_namespace,
					   previous_namespace[0] == '\0'
					   ? "" : "::",
					   name);
d3027 1
a3027 1
    add_using_directive (processing_current_namespace,
d3029 1
a3029 1
			 strlen (processing_current_namespace));
d3043 1
a3043 1
  processing_current_namespace = previous_namespace;
@


1.66.4.9
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d564 1
a564 1
static struct deprecated_complaint dwarf2_const_ignored =
d568 1
a568 1
static struct deprecated_complaint dwarf2_volatile_ignored =
d572 1
a572 1
static struct deprecated_complaint dwarf2_non_const_array_bound_ignored =
d576 1
a576 1
static struct deprecated_complaint dwarf2_missing_line_number_section =
d580 1
a580 1
static struct deprecated_complaint dwarf2_statement_list_fits_in_line_number_section =
d584 1
a584 1
static struct deprecated_complaint dwarf2_mangled_line_number_section =
d588 1
a588 1
static struct deprecated_complaint dwarf2_unsupported_die_ref_attr =
d592 1
a592 1
static struct deprecated_complaint dwarf2_unsupported_stack_op =
d596 1
a596 1
static struct deprecated_complaint dwarf2_complex_location_expr =
d600 1
a600 1
static struct deprecated_complaint dwarf2_unsupported_tag =
d604 1
a604 1
static struct deprecated_complaint dwarf2_unsupported_at_encoding =
d608 1
a608 1
static struct deprecated_complaint dwarf2_unsupported_at_frame_base =
d612 1
a612 1
static struct deprecated_complaint dwarf2_unexpected_tag =
d616 1
a616 1
static struct deprecated_complaint dwarf2_missing_at_frame_base =
d620 1
a620 1
static struct deprecated_complaint dwarf2_bad_static_member_name =
d624 1
a624 1
static struct deprecated_complaint dwarf2_unsupported_accessibility =
d628 1
a628 1
static struct deprecated_complaint dwarf2_bad_member_name_complaint =
d632 1
a632 1
static struct deprecated_complaint dwarf2_missing_member_fn_type_complaint =
d636 1
a636 1
static struct deprecated_complaint dwarf2_vtbl_not_found_complaint =
d640 1
a640 1
static struct deprecated_complaint dwarf2_absolute_sibling_complaint =
d644 1
a644 1
static struct deprecated_complaint dwarf2_const_value_length_mismatch =
d648 1
a648 1
static struct deprecated_complaint dwarf2_unsupported_const_value_attr =
d652 1
a652 1
static struct deprecated_complaint dwarf2_misplaced_line_number =
d656 1
a656 1
static struct deprecated_complaint dwarf2_line_header_too_long =
d660 1
a660 1
static struct deprecated_complaint dwarf2_missing_macinfo_section =
d664 1
a664 1
static struct deprecated_complaint dwarf2_macros_too_long =
d668 1
a668 1
static struct deprecated_complaint dwarf2_macros_not_terminated =
d672 1
a672 1
static struct deprecated_complaint dwarf2_macro_outside_file =
d676 1
a676 1
static struct deprecated_complaint dwarf2_macro_unmatched_end_file =
d680 1
a680 1
static struct deprecated_complaint dwarf2_macro_malformed_definition =
d684 1
a684 1
static struct deprecated_complaint dwarf2_macro_spaces_in_definition =
d688 1
a688 1
static struct deprecated_complaint dwarf2_invalid_attrib_class =
d692 1
a692 1
static struct deprecated_complaint dwarf2_invalid_pointer_size = 
d2022 1
a2022 12
  
  /* In C++, we can have functions nested inside functions (e.g., when
     a function declares a class that has methods).  This means that
     when we finish processing a function scope, we may need to go
     back to building a containing block's symbol lists.  */
  local_symbols = new->locals;
  param_symbols = new->params;

  /* If we've finished processing a top-level function, subsequent
     symbols go in the file symbol list.  */
  if (outermost_context_p ())
    list_in_scope = &file_symbols;
a2146 2
      FIELD_STATIC_KIND (*fp) = 0;

a2252 1
      FIELD_STATIC_KIND (*fp) = 0;
a2755 1
		  FIELD_STATIC_KIND (fields[num_fields]) = 0;
@


1.66.4.10
log
@2002-11-19  David Carlton  <carlton@@math.stanford.edu>

	* block.c: Whitespace cleanup.
	* buildsym.c (finish_block): Delete #if'd out code.
	* symtab.c (lookup_symbol_namespace): Add comment.
	* dwarf2read.c (scan_partial_symbols): Fix typo.

2002-11-19  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Delete FIXME comment.
	Fill in PR's for setup_kfail's.
	Fiddle with comments at top of file.
@
text
@d1351 1
a1351 1
     level 1.  But C++ namespaces give rise to DW_TAG_namespace dies
@


1.66.4.11
log
@2002-11-20  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (scan_partial_symbols): Move lowpc, highpc initial
	and final setting to dwarf2_build_psymtabs_hard.
	(dwarf2_build_psymtabs_hard): Set lowpc, highpc outside of
	scan_partial_symbols.
	(scan_partial_symbols): Handle namespaces by calling ourself
	recursively.
	* Makefile.in (cp-support.o): Depend on gdbcmd_h.
	* cp-support.c (_initialize_cp_support): New function.
	(maintenance_print_namespace): New function.
	#include "gdbcmd.h"
	* cp-support.h: Add opaque declaration for 'struct symbol'.
	* symfile.h: Add comment saying that you must first include
	symtab.h.
	* Makefile.in (cp-support.o): Depend on dictionary_h.
	* cp-support.c: #include "dictionary.h"
	* gdbtypes.h: Add TYPE_CODE_NAMESPACE to enum type_code.
	* cp-support.h: Add declaration for cp_check_namespace_symbol.
	* Makefile.in (cp-support.o): Depend on gdbtypes_h.
	* cp-support.c: New variable namespace_objfile.
	(get_namespace_objfile): New function.
	(cp_check_namespace_symbol): New function.
	#include "gdbtypes.h"
	* Makefile.in (cp-support.o): Depend on symfile_h, symtab_h,
	block_h, objfiles_h.
	* cp-support.c: Add declaration for find_last_component.
	#include "symfile.h", "symtab.h", "block.h", "objfiles.h".
	New variable namespace_block.
	(get_namespace_block): New function.
	(free_namespace_block): New function.
@
text
@a1298 3
	  lowpc = ((CORE_ADDR) -1);
	  highpc = ((CORE_ADDR) 0);

a1301 5
	  /* If we didn't find a lowpc, set it to highpc to avoid
	     complaints from `maint check'.  */
	  if (lowpc == ((CORE_ADDR) -1))
	    lowpc = highpc;
	  
d1330 1
a1330 2
/* Read in all interesting dies to the end of the compilation unit or
   to the end of the current namespace.  */
d1348 14
d1381 1
a1381 1
		  if ((pdi.is_external || nesting_level == 1)
d1394 1
a1394 1
	      if ((pdi.is_external || nesting_level == 1)
d1405 1
a1405 1
	      if (nesting_level == 2)
d1411 1
a1411 1
	      if (nesting_level == 1)
d1415 4
d1420 1
a1420 3
		info_ptr = scan_partial_symbols (info_ptr, objfile,
						 lowpc, highpc,
						 cu_header);
d1428 2
a1429 2
         not skip namespaces, the scan_partial_symbols call has
         already updated info_ptr for us.  */
d1446 7
d1456 4
d2995 3
@


1.66.4.12
log
@2002-11-21  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c (get_namespace_objfile): Set
	namespace_objfile->name.
	* dwarf2read.c (scan_partial_symbols): Allow empty pdi.name if
	we're reading a namespace.
	* Makefile.in (dwarf2read.o): Depend on cp_support_h.
	* dwarf2read.c (scan_partial_symbols): Add 'namespace' arg.
	(dwarf2_build_psymtabs_hard): Update call to
	scan_partial_symbols.
	(add_partial_namespace): New function.
	(scan_partial_symbols): Call add_partial_namespace.
	#include "cp-support.h"
	* cp-support.c: Add me to contributors.
	* cp-support.h: Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Convert for loop
	into a clearer while loop.
	(finish_block): Ditto.
@
text
@a48 1
#include "cp-support.h"
d709 1
a709 2
				   const struct comp_unit_head *,
				   const char *namespace);
a713 7
static char *add_partial_namespace (struct partial_die_info *pdi,
				    char *info_ptr,
				    struct objfile *objfile,
				    CORE_ADDR *lowpc, CORE_ADDR *highpc,
				    const struct comp_unit_head *cu_header,
				    const char *namespace);

d1303 1
a1303 1
					   &cu_header, NULL);
d1339 1
a1339 5
   to the end of the current namespace.  NAMESPACE is NULL if we
   haven't yet encountered any DW_TAG_namespace entries; otherwise,
   it's the name of the current namespace.  (In particular, it's the
   empty string if we're currently in the global namespace but have
   previously encountered a DW_TAG_namespace.)  */
d1344 1
a1344 2
		      const struct comp_unit_head *cu_header,
		      const char *namespace)
d1361 1
a1361 3
      /* Anonymous namespaces have no name but are interesting.  */

      if (pdi.name != NULL || pdi.tag == DW_TAG_namespace)
d1410 4
a1413 8
	      /* We've hit a DW_TAG_namespace entry, so we know this
		 file has been compiled using a compiler that
		 generates them; update NAMESPACE to reflect that.  */
	      if (namespace == NULL)
		namespace = "";
	      info_ptr = add_partial_namespace (&pdi, info_ptr, objfile,
						lowpc, highpc, cu_header,
						namespace);
d1421 1
a1421 1
         not skip namespaces, the add_partial_namespace call has
d1429 1
a1429 1
      else if (pdi.has_children && pdi.tag != DW_TAG_namespace)
a1549 37

/* Read a partial die corresponding to a namespace; also, add a symbol
   corresponding to that namespace to the symbol table.  NAMESPACE is
   the name of the enclosing namespace.  */

static char *
add_partial_namespace (struct partial_die_info *pdi, char *info_ptr,
		       struct objfile *objfile,
		       CORE_ADDR *lowpc, CORE_ADDR *highpc,
		       const struct comp_unit_head *cu_header,
		       const char *namespace)
{
  /* Calculate the full name of the namespace that we just entered.  */

  const char *new_name = pdi->name;
  if (new_name == NULL)
    new_name = "(anonymous namespace)";
  char *full_name = alloca (strlen (namespace) + 2 + strlen (new_name) + 1);
  strcpy (full_name, namespace);
  if (*namespace != '\0')
    strcat (full_name, "::");
  strcat (full_name, new_name);

  /* Make sure that there's a symbol associated to that namespace.  */

  cp_check_namespace_symbol (full_name, strlen (full_name));

  /* Now scan partial symbols in that namespace.  */

  if (pdi->has_children)
    info_ptr = scan_partial_symbols (info_ptr, objfile,
				     lowpc, highpc,
				     cu_header, full_name);

  return info_ptr;
}

@


1.66.4.13
log
@2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_enumeration): New function.
	(scan_partial_symbols): Call add_partial_enumeration.
	(locate_pdi_sibling): New function.
	(scan_partial_symbols): Call locate_pdi_sibling.  Get rid of
	nesting_level.
	(pdi_needs_namespace): New function.
	(add_partial_symbol): Add 'namespace' arg; calculate full name
	when appropriate.
	(scan_partial_symbols): Update calls to add_partial_symbol.
	(add_partial_enumeration): Ditto.
	(read_enumeration): Add processing_current_prefix to name when
	appropriate.
	(new_symbol): Set names of enumerators and typedefs appropriately
	if processing_has_namespace_info.
	* symtab.c (lookup_symbol_namespace): Rename 'namespace' argument
	to 'namespace_name'.
	* symtab.h: Ditto.
	* symtab.c (lookup_symbol_namespace): Delete FIXME comments; add a
	new one.
	(lookup_symbol_aux_file): New function.
	(lookup_symbol_aux): Delete FIXME comment.
	(lookup_symbol_aux): Don't search static block explicitly; delete
	FIXME comments.
	* valops.c (value_namespace_elt): Update call to
	lookup_symbol_namespace.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* symtab.c (lookup_symbol_namespace): Delete 'using' argument and
	add 'block' argument; get using directives via iterators.
	(lookup_symbol_aux_using_loop): Delete 'using' argument and add
	'block' argument.
	(lookup_symbol_aux_using): Don't calculate using directives.
	* block.c (block_using_iterator_first): New function.
	(block_using_iterator_next): Ditto.
	* block.h: Add comment.
	(struct block_using_iterator): New struct.
	Declare block_using_iterator_first, block_using_iterator_next.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Set type name and
	processing_current_prefix appropriately.
	(new_symbol): Make sure that, in symbols associated to class
	types, the name includes appropriate namespaces.
	* buildsym.h: Rename processing_current_namespace to
	processing_current_prefix.
	* buildsym.c (finish_block): Ditto.
	* dwarf2read.c (psymtab_to_symtab_1): Ditto.
	(read_namespace): Ditto.  Also rename previous_namespace to
	previous_prefix.

	Now come a thousand and one const correctness fixes:
	* p-typeprint.c (pascal_print_type): Const.
	(pascal_type_print_method_args): Const.
	* p-lang.h: Const.
	* m2-typeprint.c (m2_print_type): Const.
	* valops.c (hand_function_call): Const.
	* jv-lang.c (java_primitive_type_from_name): Const.
	* jv-lang.h: Const.
	* jv-typeprint.c (java_print_type): Const.
	* language.c: (unk_lang_print_type): Const.
	* stack.c (frame_info): Const.
	* linespec.c (find_methods): Const.
	(find_method_name): Const
	* f-lang.h: Const.
	* f-typeprint.c (f_print_type): Const.
	* c-typeprint.c (c_print_type): Const.
	* c-lang.h: Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (lookup_primitive_typename): Const.
	* stack.c (print_frame): Const.
	(func_command): Delete pointless cast.
	* linespec.c (find_method_name): Const.
	* language.h: Const.
	* symfile.c (compare_psymbols): Const.
	* symtab.c (completion_list_add_name): Const.
	* breakpoint.c (break_at_finish_at_depth_command_1): Remove
	useless cast.
	(break_at_finish_command_1): Ditto.
	* typeprint.c (type_print): Const.
	* symtab.h: Const.
	* symtab.c (gdb_mangle_name): Const.
	(symbol_init_demangled_name): Const.
	(symbol_demangled_name): Const.
	* defs.h: Const.
	* printcmd.c (build_address_symbolic): Const.
	* valops.c (search_struct_method): Const.
	* cp-valprint.c (cp_is_vtbl_ptr_type): Const.
	(cp_print_value): Const.
	(cp_print_class_member): Const.
	* c-typeprint.c (cp_type_print_derivation_info): Const.
	(c_type_print_varspec_prefix): Const.
	(c_type_print_base): Const.
	* p-valprint.c (pascal_object_is_vtbl_ptr_type): Const.
	(pascal_object_print_value): Const.
	(pascal_object_print_class_member): Const.
	* p-typeprint.c (pascal_type_print_derivation_info): Const.
	(pascal_type_print_varspec_prefix): Const.
	(pascal_type_print_base): Const.
	* jv-typeprint.c (java_type_print_base): Const.
	* jv-lang.h (java_demangle_type_signature): Const.
	* jv-lang.c (java_demangle_type_signature): Const.
	(java_demangled_signature_length): Const.
	(java_demangled_signature_copy): Const.
	* jv-typeprint.c (java_type_print_derivation_info): Const.
	* jv-valprint.c (java_value_print): Const.
	(java_print_value_fields): Const.
	* jv-lang.c (is_object_type): Const.
	(evaluate_subexp_java): Const.
	* stabsread.c (read_cpp_abbrev): Const.
	(complain_about_struct_wipeout): Const.
	(cleanup_undefined_types): Const.
	* gdbtypes.h: Const.
	* gdbtypes.c (add_name): Second arg const.
	(lookup_typename): Const.
	(lookup_unsigned_typename): Const.
	(lookup_signed_typename): Const.
	* linespec.c (find_methods): const char *class_name.
	* symtab.c (gdb_mangle_name): const char *newname.
	* valops.c (destructor_name_p): const char *dname.
	(search_struct_field): First arg const.
	* gdbtypes.c (check_typedef): const char *name (multiple places).
	(cfront_mangle_name): const char *newname.
	* gdbtypes.c (add_mangled_type): const char *tname.
	* valops.c (find_overload_match): const char *obj_type_name.
	* utils.c (gdb_print_host_address): Make first arg const.
	* defs.h: Declare first arg of gdb_print_host_address to be
	const.
	* valarith.c (find_size_for_pointer_math): const char *name.

2002-11-27  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc (main): Add marker comment.
	* gdb.c++/m-data.exp: Use marker comment instead of line numbers.
	* gdb.c++/m-data.cc: Delete superfluous namespace.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/m-static1.cc: Ditto.
	* carlton_runtest: Compare based on gdb.sum, not based on output.
	* carlton_runnamespace: Ditto.

2002-11-26  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Put tests for CClass.
	* gdb.c++/namespace.cc (C): Add CClass.
@
text
@d714 1
a714 4
				const struct comp_unit_head *,
				const char *namespace);

static int pdi_needs_namespace (enum dwarf_tag tag, const char *namespace);
a722 11
static char *add_partial_enumeration (struct partial_die_info *enum_pdi,
				      char *info_ptr,
				      struct objfile *objfile,
				      const struct comp_unit_head *cu_header,
				      const char *namespace);

static char *locate_pdi_sibling (struct partial_die_info *orig_pdi,
				 char *info_ptr,
				 bfd *abfd,
				 const struct comp_unit_head *cu_header);

d1350 1
a1350 1
   it's the name of the current namespace.  In particular, it's the
d1352 1
a1352 1
   previously encountered a DW_TAG_namespace.  */
d1363 7
a1369 3
  /* Now, march along the PDI's, descending into ones which have
     interesting children but skipping the children of the other ones,
     until we reach the end of the compilation unit.  */
d1371 1
a1371 1
  while (1)
d1375 1
a1375 3
      /* Anonymous namespaces have no name but have interesting
	 children, so we need to look at them.  Ditto for anonymous
	 enums.  */
d1377 1
a1377 2
      if (pdi.name != NULL || pdi.tag == DW_TAG_namespace
	  || pdi.tag == DW_TAG_enumeration_type)
d1392 2
a1393 1
		  if (!pdi.is_declaration)
d1395 1
a1395 1
		      add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1404 3
a1406 1
	      if (!pdi.is_declaration)
d1408 1
a1408 1
		  add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1411 7
a1417 7
	    case DW_TAG_enumeration_type:
	      if (!pdi.is_declaration)
		{
		  info_ptr = add_partial_enumeration (&pdi, info_ptr,
						      objfile, cu_header,
						      namespace);
		}
d1422 2
a1423 1
	      add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1439 17
a1456 7
	break;

      /* If the die has a sibling, skip to the sibling, unless another
	 function has already updated info_ptr for us.  */

      if (pdi.tag != DW_TAG_enumeration_type
	  && pdi.tag != DW_TAG_namespace)
d1458 1
a1458 1
	  info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu_header);
d1467 1
a1467 2
		    const struct comp_unit_head *cu_header,
		    const char *namespace)
a1469 12
  char *actual_name = pdi->name;

  /* If we're not in the global namespace and if the namespace name
     isn't encoded in a mangled actual_name, add it.  */
  
  if (pdi_needs_namespace (pdi->tag, namespace))
    {
      actual_name = alloca (strlen (pdi->name) + 2 + strlen (namespace) + 1);
      strcpy (actual_name, namespace);
      strcat (actual_name, "::");
      strcat (actual_name, pdi->name);
    }
d1476 1
a1476 1
	  /*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
d1478 1
a1478 1
	  add_psymbol_to_list (actual_name, strlen (actual_name),
d1485 1
a1485 1
	  /*prim_record_minimal_symbol (actual_name, pdi->lowpc + baseaddr,
d1487 1
a1487 1
	  add_psymbol_to_list (actual_name, strlen (actual_name),
d1512 1
a1512 1
	    add_psymbol_to_list (actual_name, strlen (actual_name),
d1523 1
a1523 1
	  /*prim_record_minimal_symbol (actual_name, addr + baseaddr,
d1525 1
a1525 1
	  add_psymbol_to_list (actual_name, strlen (actual_name),
d1533 1
a1533 1
      add_psymbol_to_list (actual_name, strlen (actual_name),
d1546 1
a1546 1
      add_psymbol_to_list (actual_name, strlen (actual_name),
d1554 1
a1554 1
	  add_psymbol_to_list (actual_name, strlen (actual_name),
d1561 1
a1561 1
      add_psymbol_to_list (actual_name, strlen (actual_name),
a1570 20
static int
pdi_needs_namespace (enum dwarf_tag tag, const char *namespace)
{
  if (namespace == NULL || namespace[0] == '\0')
    return 0;

  switch (tag)
    {
    case DW_TAG_typedef:
    case DW_TAG_class_type:
    case DW_TAG_structure_type:
    case DW_TAG_union_type:
    case DW_TAG_enumeration_type:
    case DW_TAG_enumerator:
      return 1;
    default:
      return 0;
    }
}

a1606 60
/* Read a partial die corresponding to an enumeration type.  */

static char *
add_partial_enumeration (struct partial_die_info *enum_pdi, char *info_ptr,
			 struct objfile *objfile,
			 const struct comp_unit_head *cu_header,
			 const char *namespace)
{
  bfd *abfd = objfile->obfd;
  struct partial_die_info pdi;

  if (enum_pdi->name != NULL)
    add_partial_symbol (enum_pdi, objfile, cu_header, namespace);
  
  while (1)
    {
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu_header);
      if (pdi.tag == 0)
	break;
      gdb_assert (pdi.tag == DW_TAG_enumerator);
      gdb_assert (pdi.name != NULL);
      add_partial_symbol (&pdi, objfile, cu_header, namespace);
    }

  return info_ptr;
}

/* Locate ORIG_PDI's sibling; INFO_PTR points to the next PDI after
   ORIG_PDI.  */

static char *
locate_pdi_sibling (struct partial_die_info *orig_pdi, char *info_ptr,
		    bfd *abfd, const struct comp_unit_head *cu_header)
{
  /* Do we know the sibling already?  */
  
  if (orig_pdi->sibling)
    return orig_pdi->sibling;

  /* Are there any children to deal with?  */

  if (!orig_pdi->has_children)
    return info_ptr;

  /* Okay, we don't know the sibling, but we have children that we
     want to skip.  So read children until we run into one without a
     tag; return whatever follows it.  */

  while (1)
    {
      struct partial_die_info pdi;
      
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu_header);

      if (pdi.tag == 0)
	return info_ptr;
      else
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu_header);
    }
}
d1667 1
a1667 1
  processing_current_prefix = "";
a2594 1
  const char *previous_prefix = processing_current_prefix;
d2602 2
a2603 20
      if (processing_has_namespace_info)
	{
	  /* FIXME: carlton/2002-11-26: This variable exists only for
	     const-correctness reasons.  When I tried to change
	     TYPE_TAG_NAME to be a const char *, I ran into a cascade
	     of changes which would have forced decode_line_1 to take
	     a const char **.  */
	  char *new_prefix = obconcat (&objfile->type_obstack,
				       previous_prefix,
				       previous_prefix[0] == '\0'
				       ? "" : "::",
				       name);
	  TYPE_TAG_NAME (type) = new_prefix;
	  processing_current_prefix = new_prefix;
	}
      else
	{
	  TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
					       &objfile->type_obstack);
	}
a2732 2

  processing_current_prefix = previous_prefix;
d2763 2
a2764 13
      if (processing_has_namespace_info)
	{
	  TYPE_TAG_NAME (type) = obconcat (&objfile->type_obstack,
					   processing_current_prefix,
					   processing_current_prefix[0] == '\0'
					   ? "" : "::",
					   name);
	}
      else
	{
	  TYPE_TAG_NAME (type) = obsavestring (name, strlen (name),
					       &objfile->type_obstack);
	}
d3039 1
a3039 1
  const char *previous_prefix = processing_current_prefix;
d3062 5
a3066 5
  processing_current_prefix = obconcat (&objfile->symbol_obstack,
					previous_prefix,
					previous_prefix[0] == '\0'
					? "" : "::",
					name);
d3072 3
a3074 3
    add_using_directive (processing_current_prefix,
			 strlen (previous_prefix),
			 strlen (processing_current_prefix));
d3088 1
a3088 1
  processing_current_prefix = previous_prefix;
a5100 18

	  /* Make sure that the symbol includes appropriate
	     namespaces in its name.  */

	  if (processing_has_namespace_info)
	    {
	      struct type *type = SYMBOL_TYPE (sym);
	      
	      if (TYPE_TAG_NAME (type) != NULL)
		{
		  SYMBOL_NAME (sym)
		    = obsavestring (TYPE_TAG_NAME (type),
				    strlen (TYPE_TAG_NAME (type)),
				    &objfile->symbol_obstack);
		  gdb_assert (SYMBOL_DEMANGLED_NAME (sym) == NULL);
		}
	    }
	  
a5121 12
	  if (processing_has_namespace_info
	      && processing_current_prefix[0] != '\0')
	    {
	      SYMBOL_NAME (sym) = obconcat (&objfile->symbol_obstack,
					    processing_current_prefix,
					    "::",
					    name);
	    }
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  SYMBOL_NAMESPACE (sym) = VAR_NAMESPACE;
	  add_symbol_to_list (sym, list_in_scope);
	  break;
a5127 8
	  if (processing_has_namespace_info
	      && processing_current_prefix[0] != '\0')
	    {
	      SYMBOL_NAME (sym) = obconcat (&objfile->symbol_obstack,
					    processing_current_prefix,
					    "::",
					    name);
	    }
@


1.66.4.14
log
@2002-11-29  David Carlton  <carlton@@bactrian.org>

	* dwarf2read.c (add_partial_symbol): Add partial symbols
	corresponding to classes, etc. to global list.
	(new_symbol): Ditto, mutatis mutandem.

2002-11-29  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/namespace.exp: Add OtherFileClass tests.
	* gdb.c++/namespace1.cc (C): New file.
@
text
@a1555 2
      /* NOTE: carlton/2002-11-29: See comment in new_symbol about
	 static vs. global.  */
d1560 1
a1560 1
			   &objfile->global_psymbols,
d1568 1
a1568 1
			       &objfile->global_psymbols,
d1575 1
a1575 1
			   &objfile->global_psymbols,
a5241 16

	  {
	    /* NOTE: carlton/2002-11-29: Class symbols shouldn't
	       really ever be static objects: otherwise, if you try
	       to, say, break of a class's method and you're in a file
	       which doesn't mention that class, it won't work unless
	       the check for all static symbols in lookup_symbol_aux
	       saves you.  Though perhaps C allows different files to
	       define different structs with the same name; if so,
	       this should be conditional on C++.  See the
	       OtherFileClass tests in gdb.c++/namespace.exp.  */

	    struct pending **list_to_add;

	    list_to_add = (list_in_scope == &file_symbols
			   ? &global_symbols : list_in_scope);
d5243 1
a5243 1
	    add_symbol_to_list (sym, list_to_add);
d5245 17
a5261 18
	    /* The semantics of C++ state that "struct foo { ... }" also
	       defines a typedef for "foo". Synthesize a typedef symbol so
	       that "ptype foo" works as expected.  */
	    if (cu_language == language_cplus)
	      {
		struct symbol *typedef_sym = (struct symbol *)
		  obstack_alloc (&objfile->symbol_obstack,
				 sizeof (struct symbol));
		*typedef_sym = *sym;
		SYMBOL_NAMESPACE (typedef_sym) = VAR_NAMESPACE;
		if (TYPE_NAME (SYMBOL_TYPE (sym)) == 0)
		  TYPE_NAME (SYMBOL_TYPE (sym)) =
		    obsavestring (SYMBOL_NAME (sym),
				  strlen (SYMBOL_NAME (sym)),
				  &objfile->type_obstack);
		add_symbol_to_list (typedef_sym, list_to_add);
	      }
	  }
d5295 1
a5295 11
	  {
	    /* NOTE: carlton/2002-11-29: See comment above in the
	       DW_TAG_class_type, etc. block.  */

	    struct pending **list_to_add;

	    list_to_add = (list_in_scope == &file_symbols
			   ? &global_symbols : list_in_scope);
	  
	    add_symbol_to_list (sym, list_to_add);
	  }
@


1.66.4.15
log
@2002-12-17  David Carlton  <carlton@@math.stanford.edu>

	* c-exp.y (yylex): Modify the #if 1 block to handle nested types
	in a more honest manner.
	* symtab.c (lookup_nested_type): New function.
	* symtab.h: Declare lookup_nested_type.

2002-12-16  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_partial_symbol): Don't search past the end of
	the partial symbols.
	* Makefile.in (f-exp.tab.c): Don't depend on c-exp.tab.c.
	* dwarf2read.c (new_symbol): Only make global symbols associated
	to structures, etc. if the current language is C++.
	(add_partial_symbol): Ditto (for partial symbols).

2002-12-17  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/m-data.cc: Whitespace cleanup, to match mainline patch.
	* gdb.c++/m-static.cc: Ditto.
	* gdb.c++/namespace.exp: Fix comment.  Delete third argument to
	all the gdb_tests.

2002-12-16  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change KFAIL messages to point to c++/XXX
	instead of gdb/XXX.
@
text
@d1562 1
a1562 3
			   cu_language == language_cplus
			   ? &objfile->global_psymbols
			   : &objfile->static_psymbols,
d1577 1
a1577 3
			   cu_language == language_cplus
			   ? &objfile->static_psymbols
			   : &objfile->global_psymbols,
d5246 1
a5246 1
	    /* NOTE: carlton/2002-11-29: C++ class symbols shouldn't
d5251 4
a5254 2
	       saves you.  See the OtherFileClass tests in
	       gdb.c++/namespace.exp.  */
a5258 1
			   && cu_language == language_cplus
a5320 1
			   && cu_language == language_cplus
@


1.66.4.16
log
@2002-12-18  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_file): Call
	cp_lookup_possible_namespace_symbol.
	* dwarf2read.c (add_partial_symbol): Sometimes check for possible
	namespace symbols.
	* cp-support.c (maintenance_print_namespace): Handle
	possible_namespace_block, too.
	(cp_lookup_possible_namespace_symbol): New function.
	* cp-support.h: Declare cp_check_possible_namespace_symbols,
	cp_lookup_possible_namespace_symbol.
	* cp-support.c (check_one_possible_namespace_symbol): New
	function.
	(cp_check_possible_namespace_symbols): New function.
	(check_possible_namespace_symbols_loop): New function.
	* symfile.h: Update declaration for add_psymbol_to_list.
	* symfile.c (psymbol_init_demangled_name): New function.
	(add_psymbol_to_list): Change SYMBOL_INIT_LANGUAGE_SPECIFIC to
	psymbol_init_demangled_name.
	(add_psymbol_to_list): Return a const struct psymbol *.
	* Makefile.in (dwarf2read.o): Don't depend on bcache_h.
	* dwarf2read.c: Don't #include "bcache.h"
	* cp-support.c (get_namespace_block): Allocate blocks via
	allocate_block.
	(initialize_namespace_blocks): New function.
	New variable possible_namespace_block.
	(get_namespace_block): Call initialize_namespace_blocks.
	(free_namespace_blocks): Rename from free_namespace_block; handle
	possible_namespace_block, too.
	(get_possible_namespace_block): New function.
	* jv-lang.c (get_java_class_symtab): Ditto.
	* block.c (allocate_block): New function.
	* block.h: Declare allocate_block.
@
text
@d44 1
a1470 1
  const struct partial_symbol *psym = NULL;
d1490 4
a1493 5
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
				      VAR_NAMESPACE, LOC_BLOCK,
				      &objfile->global_psymbols,
				      0, pdi->lowpc + baseaddr,
				      cu_language, objfile);
d1499 4
a1502 5
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
				      VAR_NAMESPACE, LOC_BLOCK,
				      &objfile->static_psymbols,
				      0, pdi->lowpc + baseaddr,
				      cu_language, objfile);
d1524 4
a1527 5
	    psym = add_psymbol_to_list (actual_name, strlen (actual_name),
					VAR_NAMESPACE, LOC_STATIC,
					&objfile->global_psymbols,
					0, addr + baseaddr,
					cu_language, objfile);
a1586 12

  /* Check to see if we should scan the name for possible namespace
     info.  Only do this if this is C++, if we don't have namespace
     debugging info in the file, if the psym is of an appropriate type
     (otherwise we'll have psym == NULL), and if we actually had a
     mangled name to begin with.  */

  if (cu_language == language_cplus
      && namespace == NULL
      && psym != NULL
      && SYMBOL_CPLUS_DEMANGLED_NAME (psym) != NULL)
    cp_check_possible_namespace_symbols (SYMBOL_CPLUS_DEMANGLED_NAME (psym));
@


1.66.4.17
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d564 1
a564 38
static void
dwarf2_non_const_array_bound_ignored_complaint (const char *arg1)
{
  complaint (&symfile_complaints, "non-constant array bounds form '%s' ignored",
	     arg1);
}

static void
dwarf2_statement_list_fits_in_line_number_section_complaint (void)
{
  complaint (&symfile_complaints,
	     "statement list doesn't fit in .debug_line section");
}

static void
dwarf2_complex_location_expr_complaint (void)
{
  complaint (&symfile_complaints, "location expression too complex");
}

static void
dwarf2_unsupported_at_frame_base_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "unsupported DW_AT_frame_base for function '%s'", arg1);
}

static void
dwarf2_const_value_length_mismatch_complaint (const char *arg1, int arg2,
					      int arg3)
{
  complaint (&symfile_complaints,
	     "const value length mismatch for '%s', got %d, expected %d", arg1,
	     arg2, arg3);
}

static void
dwarf2_macros_too_long_complaint (void)
d566 127
a692 14
  complaint (&symfile_complaints,
	     "macro info runs off end of `.debug_macinfo' section");
}

static void
dwarf2_macro_malformed_definition_complaint (const char *arg1)
{
  complaint (&symfile_complaints,
	     "macro debug info contains a malformed macro definition:\n`%s'",
	     arg1);
}

static void
dwarf2_invalid_attrib_class_complaint (const char *arg1, const char *arg2)
d694 2
a695 3
  complaint (&symfile_complaints,
	     "invalid attribute class or form for '%s' in '%s'", arg1, arg2);
}
d2134 1
a2134 1
	  dwarf2_complex_location_expr_complaint ();
d2139 1
a2139 1
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_frame_base", name);
d2144 1
a2144 1
	dwarf2_unsupported_at_frame_base_complaint (name);
d2153 1
a2153 1
	dwarf2_unsupported_at_frame_base_complaint (name);
d2305 1
a2305 2

  if (die->tag == DW_TAG_member && ! die_is_declaration (die))
a2306 2
      /* Data member other than a C++ static data member.  */
      
d2391 1
a2391 1
  else if (die->tag == DW_TAG_member || die->tag == DW_TAG_variable)
a2392 7
      /* C++ static member.  */

      /* NOTE: carlton/2002-11-05: It should be a DW_TAG_member that
	 is a declaration, but all versions of G++ as of this writing
	 (so through at least 3.2.1) incorrectly generate
	 DW_TAG_variable tags.  */
      
d2493 2
a2494 2
	    complaint (&symfile_complaints, "unsupported accessibility %d",
		       fip->fields->accessibility);
d2601 1
a2601 2
    complaint (&symfile_complaints, "member function type missing for '%s'",
	       physname);
d2641 1
a2641 1
	  dwarf2_complex_location_expr_complaint ();
d2645 2
a2646 2
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_vtable_elem_location",
						 fieldname);
d2780 5
a2784 2
	  if (child_die->tag == DW_TAG_member
	      || child_die->tag == DW_TAG_variable)
d2786 1
a2786 5
	      /* NOTE: carlton/2002-11-05: A C++ static data member
		 should be a DW_TAG_member that is a declaration, but
		 all versions of G++ as of this writing (so through at
		 least 3.2.1) incorrectly generate DW_TAG_variable
		 tags for them instead.  */
d2846 2
a2847 4
		    complaint (&symfile_complaints,
			       "virtual function table pointer not found when defining class '%s'",
			       TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) :
			       "");
d3048 2
a3049 2
		  dwarf2_non_const_array_bound_ignored_complaint
		    (dwarf_form_name (attr->form));
d3084 2
a3085 2
		  dwarf2_non_const_array_bound_ignored_complaint
		    (dwarf_form_name (attr->form));
d3152 1
a3152 1
	  dwarf2_complex_location_expr_complaint ();
d3156 2
a3157 2
	  dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
						 "common block member");
d3282 1
a3282 1
	  complaint (&symfile_complaints, "invalid pointer size %d", byte_size);
d3581 2
a3582 2
	  complaint (&symfile_complaints, "unsupported DW_AT_encoding: '%s'",
		     dwarf_type_encoding_name (encoding));
d3898 1
a3898 1
	      dwarf2_complex_location_expr_complaint ();
d3902 2
a3903 2
	      dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
						     "partial symbol information");
d3927 1
a3927 1
	    complaint (&symfile_complaints, "ignoring absolute DW_AT_sibling");
d4639 1
a4639 1
      complaint (&symfile_complaints, "missing .debug_line section");
d4647 1
a4647 1
      dwarf2_statement_list_fits_in_line_number_section_complaint ();
d4663 1
a4663 1
      dwarf2_statement_list_fits_in_line_number_section_complaint ();
d4718 1
a4718 2
    complaint (&symfile_complaints,
	       "line number info header doesn't fit in `.debug_line' section");
d4763 2
a4764 3
    complaint (&symfile_complaints,
	       "misplaced first line number at 0x%lx for '%s'",
	       (unsigned long) address, fn->name);
d4867 1
a4867 2
		  complaint (&symfile_complaints,
			     "mangled .debug_line section");
d5091 1
a5091 1
		      dwarf2_complex_location_expr_complaint ();
d5095 2
a5096 2
		      dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
							     "external variable");
d5137 1
a5137 1
		      dwarf2_complex_location_expr_complaint ();
d5141 2
a5142 2
		      dwarf2_invalid_attrib_class_complaint ("DW_AT_location",
							     "external variable");
d5214 1
a5214 1
			dwarf2_complex_location_expr_complaint ();
d5350 1
a5350 2
	  complaint (&symfile_complaints, "unsupported tag: '%s'",
		     dwarf_tag_name (die->tag));
d5370 2
a5371 4
	dwarf2_const_value_length_mismatch_complaint (SYMBOL_NAME (sym),
						      cu_header->addr_size,
						      TYPE_LENGTH (SYMBOL_TYPE
								   (sym)));
d5384 2
a5385 4
	dwarf2_const_value_length_mismatch_complaint (SYMBOL_NAME (sym),
						      blk->size,
						      TYPE_LENGTH (SYMBOL_TYPE
								   (sym)));
d5421 2
a5422 3
      complaint (&symfile_complaints,
		 "unsupported const value attribute form: '%s'",
		 dwarf_form_name (attr->form));
d5605 1
a5605 2
      complaint (&symfile_complaints, "unexepected tag in read_type_die: '%s'",
		 dwarf_tag_name (die->tag));
d6733 1
a6733 3
      complaint (&symfile_complaints,
		 "unsupported die ref attribute form: '%s'",
		 dwarf_form_name (attr->form));
d6969 1
a6969 2
	      complaint (&symfile_complaints,
			 "DW_AT_frame_base missing for DW_OP_fbreg");
d7046 1
a7046 1
	    dwarf2_complex_location_expr_complaint ();
d7056 1
a7056 1
	    dwarf2_complex_location_expr_complaint ();
d7060 1
a7060 2
	  complaint (&symfile_complaints, "unsupported stack op: '%s'",
		     dwarf_stack_op_name (op));
d7193 1
a7193 3
      complaint (&symfile_complaints,
		 "macro definition contains spaces in formal argument list:\n`%s'",
		 body);
d7251 1
a7251 1
	  dwarf2_macro_malformed_definition_complaint (body);
d7281 2
a7282 1
	    dwarf2_macro_malformed_definition_complaint (body);
d7318 1
a7318 1
	      dwarf2_macro_malformed_definition_complaint (body);
d7325 1
a7325 1
	    dwarf2_macro_malformed_definition_complaint (body);
d7329 1
a7329 1
	dwarf2_macro_malformed_definition_complaint (body);
d7341 1
a7341 1
    dwarf2_macro_malformed_definition_complaint (body);
d7356 1
a7356 1
      complaint (&symfile_complaints, "missing .debug_macinfo section");
d7370 1
a7370 1
	  dwarf2_macros_too_long_complaint ();
d7397 5
a7401 6
	      complaint (&symfile_complaints,
			 "debug info gives macro %s outside of any file: %s",
			 macinfo_type ==
			 DW_MACINFO_define ? "definition" : macinfo_type ==
			 DW_MACINFO_undef ? "undefinition" :
			 "something-or-other", body);
d7430 1
a7430 2
	    complaint (&symfile_complaints,
		       "macro debug info has an unmatched `close_file' directive");
d7446 1
a7446 1
		      dwarf2_macros_too_long_complaint ();
d7454 1
a7454 2
		    complaint (&symfile_complaints,
			       "no terminating 0-type entry for macros in `.debug_macinfo' section");
@


1.66.4.18
log
@2003-01-07  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (add_partial_structure): New function.
	(scan_partial_symbols): Call add_partial_structure.  New variable
	info_ptr_updated.
	* symtab.h (struct general_symbol_info): Make demangled_names
	const char *.
@
text
@a649 6
static char *add_partial_structure (struct partial_die_info *struct_pdi,
				    char *info_ptr,
				    struct objfile *objfile,
				    const struct comp_unit_head *cu_header,
				    const char *namespace);

a1306 4
      /* This flag tells whether or not info_ptr has gotten updated
	 inside the loop.  */
      int info_ptr_updated = 0;

a1336 5
	      if (!pdi.is_declaration)
		{
		  add_partial_symbol (&pdi, objfile, cu_header, namespace);
		}
	      break;
d1342 1
a1342 4
		  info_ptr = add_partial_structure (&pdi, info_ptr,
						    objfile, cu_header,
						    namespace);
		  info_ptr_updated = 1;
a1350 1
		  info_ptr_updated = 1;
a1366 2
	      info_ptr_updated = 1;
	      break;
d1378 3
a1380 6
      /* NOTE: carlton/2003-01-07: This is a bit hackish, but whether
	 or not we want to update this depends on enough stuff (not
	 only pdi.tag but also whether or not pdi.name is NULL) that
	 this seems like the easiest way to handle the issue.  */

      if (!info_ptr_updated)
d1382 1
a1582 16
}

/* Read a partial die corresponding to a non-enumeration compound data
   structure type.  */

static char *
add_partial_structure (struct partial_die_info *struct_pdi, char *info_ptr,
		       struct objfile *objfile,
		       const struct comp_unit_head *cu_header,
		       const char *namespace)
{
  bfd *abfd = objfile->obfd;

  add_partial_symbol (struct_pdi, objfile, cu_header, namespace);

  return locate_pdi_sibling (struct_pdi, info_ptr, abfd, cu_header);
@


1.66.4.19
log
@2003-01-10  David Carlton  <carlton@@math.stanford.edu>

	* objfiles.c (allocate_objfile): Always set name.
	* dwarf2read.c (scan_partial_symbols): Don't call
	add_partial_structure on unions.
	(add_partial_structure): Look for enclosing namespace names.
	(read_structure_scope): Look enclosing namespace/class names.
	(new_symbol): For C++ structures, always grab the name from the
	type's name.

2003-01-10  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/templates.exp (do_tests): Update some of the regexps to
	be a bit more generous.
@
text
@a1346 1
	    case DW_TAG_union_type:
d1354 1
d1608 2
a1609 1
/* Read a partial die corresponding to a class or structure.  */
a1617 30
  char *actual_class_name = NULL;

  if (cu_language == language_cplus
      && namespace == NULL
      && struct_pdi->name != NULL
      && struct_pdi->has_children)
    {
      /* We don't have namespace debugging information, so see if we
	 can figure out if this structure lives in a namespace.  Look
	 for a member function; its demangled name will contain
	 namespace info, if there is any.  */
      char *next_child = info_ptr;

      while (1)
	{
	  struct partial_die_info child_pdi;

	  next_child = read_partial_die (&child_pdi, abfd, next_child,
					 cu_header);
	  if (!child_pdi.tag)
	    break;
	  if (child_pdi.tag == DW_TAG_subprogram)
	    {
	      actual_class_name = class_name_from_physname (child_pdi.name);
	      if (actual_class_name != NULL)
		struct_pdi->name = actual_class_name;
	      break;
	    }
	}
    }
a1619 1
  xfree(actual_class_name);
a2683 4
  /* This says whether or not we want to try to update the structure's
     name to include enclosing namespace/class information, if
     any.  */
  int need_to_update_name = 0;
a2709 1
	  need_to_update_name = (cu_language == language_cplus);
a2769 23
	      if (need_to_update_name)
		{
		  /* The demangled names of member functions contain
		     information about enclosing namespaces/classes,
		     if any.  */

		  /* FIXME: carlton/2003-01-10: The excessive
		     demangling here is a bit wasteful, as is the
		     memory usage for names.  */
		  char *actual_class_name
		    = class_name_from_physname (dwarf2_linkage_name
						(child_die));
		  if (actual_class_name != NULL
		      && strcmp (actual_class_name, name) != 0)
		    {
		      TYPE_TAG_NAME (type)
			= obsavestring (actual_class_name,
					strlen (actual_class_name),
					&objfile->type_obstack);
		    }
		  xfree (actual_class_name);
		  need_to_update_name = 0;
		}
d5228 2
a5229 4
	  /* Make sure that the symbol includes appropriate enclosing
	     classes/namespaces in its name.  These are calculated in
	     read_structure_scope, and the correct name is saved in
	     the type.  */
d5231 1
a5231 1
	  if (cu_language == language_cplus)
a5236 2
		  /* FIXME: carlton/2003-01-10: We're being a bit
		     profligate with memory names here.  */
@


1.66.4.20
log
@2003-01-20  David Carlton  <carlton@@math.stanford.edu>

	* p-exp.y: Add block to OP_FUNCALL.
	* objc-exp.y: Add block to OP_FUNCALL.
	* m2-exp.y: Add block to OP_FUNCALL.
	* c-exp.y: Add block to OP_FUNCALL.
	* ada-exp.y: Add block to OP_FUNCALL.
	(write_object_renaming): Ditto.
	* parse.c (length_of_subexp): Split off OP_FUNCALL.
	(prefixify_subexp): Ditto.
	* expprint.c (print_subexp): Change offset for OP_FUNCALL.
	(dump_subexp): Ditto.
	* eval.c (evaluate_subexp_standard): Change offset for
	OP_FUNCALL.
	* ada-lang.c (ada_resolve_subexp): Add comment on OP_FUNCALL.
	(replace_operator_with_call): Add block to OP_FUNCALL.
	(ada_evaluate_subexp): Change offset for OP_FUNCALL.
	* expression.h (exp_opcode): Change comments before OP_FUNCALL and
	OP_F77_UNDETERMINED_ARGLIST.

2003-01-14  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (search_symbols): Add comment.
	(lookup_symbol_aux_using): Function name should start line.
	(lookup_symbol_aux_using_loop): Ditto.
	(lookup_block_symbol): Add comment.

2003-01-13  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (read_structure_scope): Add comment.
	(add_partial_structure): Ditto.
	* symtab.c (lookup_transparent_type): Add comment.
@
text
@a1627 7

      /* NOTE: carlton/2003-01-13: Getting the info this way changes
	 what template types look like, because the demangler
	 frequently doesn't give the same name as the debug info.  We
	 could fix this by only using the demangled name to get the
	 prefix (but see comment in read_structure_scope).  */

a2813 8

		  /* NOTE: carlton/2003-01-13: As commented in
		     add_partial_structure, the demangler sometimes
		     prints the type info in a different form from the
		     debug info.  We could solve this by using the
		     demangled name to get the prefix; if doing so,
		     however, we'd need to be careful when reading a
		     class that's nested inside a template class.  */
@


1.66.4.21
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a135 1
static file_ptr dwarf_ranges_offset;
a146 1
static unsigned int dwarf_ranges_size;
a149 12
static asection *dwarf_info_section;
static asection *dwarf_abbrev_section;
static asection *dwarf_line_section;
static asection *dwarf_pubnames_section;
static asection *dwarf_aranges_section;
static asection *dwarf_loc_section;
static asection *dwarf_macinfo_section;
static asection *dwarf_str_section;
static asection *dwarf_ranges_section;
asection *dwarf_frame_section;
asection *dwarf_eh_frame_section;

a159 1
#define RANGES_SECTION   ".debug_ranges"
a204 4

    /* Pointer to the DIE associated with the compilation unit.  */

    struct die_info *die;
a375 1
static char *dwarf_ranges_buffer;
a483 8
    /* Pointer to start of dwarf ranges buffer for the objfile.  */

    char *dwarf_ranges_buffer;

    /* Size of dwarf ranges buffer for the objfile.  */

    unsigned int dwarf_ranges_size;

a496 2
#define DWARF_RANGES_BUFFER(p)  (PST_PRIVATE(p)->dwarf_ranges_buffer)
#define DWARF_RANGES_SIZE(p)    (PST_PRIVATE(p)->dwarf_ranges_size)
d624 1
a624 1
static void dwarf2_locate_sections (bfd *, asection *, void *);
d671 1
a671 2
char *dwarf2_read_section (struct objfile *, file_ptr, unsigned int,
			   asection *);
d675 1
a675 1
static void dwarf2_empty_abbrev_table (void *);
d782 1
a782 2
				 CORE_ADDR *, CORE_ADDR *, struct objfile *,
				 const struct comp_unit_head *);
d890 1
a890 1
static void dwarf2_free_tmp_obstack (void *);
a920 2
  dwarf_ranges_offset = 0;
  
d937 1
a937 1
dwarf2_locate_sections (bfd *ignore_abfd, asection *sectp, void *ignore_ptr)
a942 1
      dwarf_info_section = sectp;
a947 1
      dwarf_abbrev_section = sectp;
a952 1
      dwarf_line_section = sectp;
a957 1
      dwarf_pubnames_section = sectp;
a962 1
      dwarf_aranges_section = sectp;
a967 1
      dwarf_loc_section = sectp;
a972 1
      dwarf_macinfo_section = sectp;
a977 1
      dwarf_str_section = sectp;
a982 1
      dwarf_frame_section = sectp;
a987 7
      dwarf_eh_frame_section = sectp;
    }
  else if (STREQ (sectp->name, RANGES_SECTION))
    {
      dwarf_ranges_offset = sectp->filepos;
      dwarf_ranges_size = bfd_get_section_size_before_reloc (sectp);
      dwarf_ranges_section = sectp;
d1001 1
a1001 2
					   dwarf_info_size,
					   dwarf_info_section);
d1004 1
a1004 2
					     dwarf_abbrev_size,
					     dwarf_abbrev_section);
d1009 1
a1009 2
					     dwarf_line_size,
					     dwarf_line_section);
d1016 1
a1016 2
					    dwarf_str_size,
					    dwarf_str_section);
d1023 1
a1023 2
                                                dwarf_macinfo_size,
						dwarf_macinfo_section);
a1026 8
  if (dwarf_ranges_offset)
    dwarf_ranges_buffer = dwarf2_read_section (objfile,
					       dwarf_ranges_offset,
					       dwarf_ranges_size,
					       dwarf_ranges_section);
  else
    dwarf_ranges_buffer = NULL;

d1065 1
a1065 2
					 dwarf_pubnames_size,
					 dwarf_pubnames_section);
d1085 1
a1085 2
					dwarf_aranges_size,
					dwarf_aranges_section);
d1188 1
a1188 1
	  error ("Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]", cu_header.version, 2, bfd_get_filename (abfd));
d1193 1
a1193 1
	  error ("Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6) [in module %s]",
d1195 1
a1195 2
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
d1201 1
a1201 1
	  error ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0) [in module %s]",
d1203 1
a1203 2
		 (long) (beg_of_comp_unit - dwarf_info_buffer),
		 bfd_get_filename (abfd));
a1241 2
      DWARF_RANGES_BUFFER (pst) = dwarf_ranges_buffer;
      DWARF_RANGES_SIZE (pst) = dwarf_ranges_size;
a1775 2
  dwarf_ranges_buffer = DWARF_RANGES_BUFFER (pst);
  dwarf_ranges_size = DWARF_RANGES_SIZE (pst);
a1800 1
  cu_header.die = dies;
d1803 1
a1803 1
  if (!dwarf2_get_pc_bounds (dies, &lowpc, &highpc, objfile, &cu_header))
d1818 1
a1818 2
		  if (dwarf2_get_pc_bounds (child_die, &low, &high,
					    objfile, &cu_header))
d1948 1
a1948 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cu_header))
d1959 1
a1959 2
		  if (dwarf2_get_pc_bounds (child_die, &low, &high,
					    objfile, cu_header))
d2103 1
a2103 1
  if (name == NULL || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cu_header))
d2201 1
a2201 5
  /* ??? Perhaps consider discontiguous blocks defined by DW_AT_ranges
     as multiple lexical blocks?  Handling children in a sane way would
     be nasty.  Might be easier to properly extend generic blocks to 
     describe ranges.  */
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cu_header))
d2226 3
a2228 3
/* Get low and high pc attributes from a die.  Return 1 if the attributes
   are present and valid, otherwise, return 0.  Return -1 if the range is
   discontinuous, i.e. derived from DW_AT_ranges information.  */
d2230 2
a2231 3
dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,
		      CORE_ADDR *highpc, struct objfile *objfile,
		      const struct comp_unit_head *cu_header)
d2234 2
a2235 4
  bfd *obfd = objfile->obfd;
  CORE_ADDR low = 0;
  CORE_ADDR high = 0;
  int ret = 0;
d2237 5
d2244 1
a2244 12
    {
      high = DW_ADDR (attr);
      attr = dwarf_attr (die, DW_AT_low_pc);
      if (attr)
	low = DW_ADDR (attr);
      else
	/* Found high w/o low attribute.  */
	return 0;

      /* Found consecutive range of addresses.  */
      ret = 1;
    }
d2246 1
a2246 124
    {
      attr = dwarf_attr (die, DW_AT_ranges);
      if (attr != NULL)
	{
	  unsigned int addr_size = cu_header->addr_size;
	  CORE_ADDR mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));
	  /* Value of the DW_AT_ranges attribute is the offset in the
	     .debug_renges section.  */
	  unsigned int offset = DW_UNSND (attr);
	  /* Base address selection entry.  */
	  CORE_ADDR base = 0;
	  int found_base = 0;
	  int dummy;
	  unsigned int i;
	  char *buffer;
	  CORE_ADDR marker;
	  int low_set;
 
	  /* The applicable base address is determined by (1) the closest
	     preceding base address selection entry in the range list or
	     (2) the DW_AT_low_pc of the compilation unit.  */

	  /* ??? Was in dwarf3 draft4, and has since been removed.
	     GCC still uses it though.  */
	  attr = dwarf_attr (cu_header->die, DW_AT_entry_pc);
	  if (attr)
	    {
	      base = DW_ADDR (attr);
	      found_base = 1;
	    }

	  if (!found_base)
	    {
	      attr = dwarf_attr (cu_header->die, DW_AT_low_pc);
	      if (attr)
		{
		  base = DW_ADDR (attr);
		  found_base = 1;
		}
	    }

	  buffer = dwarf_ranges_buffer + offset;


	  /* Read in the largest possible address.  */
	  marker = read_address (obfd, buffer, cu_header, &dummy);
	  if ((marker & mask) == mask)
	    {
	      /* If we found the largest possible address, then
		 read the base address.  */
	      base = read_address (obfd, buffer + addr_size,
				   cu_header, &dummy);
	      buffer += 2 * addr_size;
	      offset += 2 * addr_size;
	      found_base = 1;
	    }

	  low_set = 0;

	  while (1)
	    {
	      CORE_ADDR range_beginning, range_end;

	      range_beginning = read_address (obfd, buffer,
					      cu_header, &dummy);
	      buffer += addr_size;
	      range_end = read_address (obfd, buffer, cu_header, &dummy);
	      buffer += addr_size;
	      offset += 2 * addr_size;

	      /* An end of list marker is a pair of zero addresses.  */
	      if (range_beginning == 0 && range_end == 0)
		/* Found the end of list entry.  */
		break;

	      /* Each base address selection entry is a pair of 2 values.
		 The first is the largest possible address, the second is
		 the base address.  Check for a base address here.  */
	      if ((range_beginning & mask) == mask)
		{
		  /* If we found the largest possible address, then
		     read the base address.  */
		  base = read_address (obfd, buffer + addr_size,
				       cu_header, &dummy);
		  found_base = 1;
		  continue;
		}

	      if (!found_base)
		{
		  /* We have no valid base address for the ranges
		     data.  */
		  complaint (&symfile_complaints,
			     "Invalid .debug_ranges data (no base address)");
		  return 0;
		}

	      /* FIXME: This is recording everything as a low-high
		 segment of consecutive addresses.  We should have a
		 data structure for discontiguous block ranges
		 instead.  */
	      if (! low_set)
		{
		  low = range_beginning;
		  high = range_end;
		  low_set = 1;
		}
	      else
		{
		  if (range_beginning < low)
		    low = range_beginning;
		  if (range_end > high)
		    high = range_end;
		}
	    }

	  if (! low_set)
	    /* If the first entry is an end-of-list marker, the range
	       describes an empty scope, i.e. no instructions.  */
	    return 0;

	  ret = -1;
	}
    }
d2259 1
a2259 1
  if (low == 0 && (bfd_get_file_flags (obfd) & HAS_RELOC) == 0)
d2264 1
a2264 1
  return ret;
d3742 1
a3742 1
		     unsigned int size, asection *sectp)
d3745 1
a3745 1
  char *buf, *retbuf;
a3750 5
  retbuf
    = (char *) symfile_relocate_debug_section (abfd, sectp, (bfd_byte *) buf);
  if (retbuf != NULL)
    return retbuf;

d3841 1
a3841 1
dwarf2_empty_abbrev_table (void *ptr_to_abbrevs_table)
d3908 1
a3908 2
      error ("Dwarf Error: Could not find abbrev number %d [in module %s]", abbrev_number,
		      bfd_get_filename (abfd));
d4052 1
a4052 2
      error ("Dwarf Error: could not find abbrev number %d [in module %s]", abbrev_number, 
		      bfd_get_filename (abfd));
d4188 2
a4189 3
      error ("Dwarf Error: Cannot handle %s in DWARF reader [in module %s]",
	     dwarf_form_name (form),
	     bfd_get_filename (abfd));
d4270 1
a4270 2
			  "read_address: bad switch, signed [in module %s]",
			  bfd_get_filename (abfd));
d4288 1
a4288 2
			  "read_address: bad switch, unsigned [in module %s]",
			  bfd_get_filename (abfd));
d4403 1
a4403 2
		      "read_offset: bad switch [in module %s]",
		      bfd_get_filename (abfd));
d4445 1
a4445 2
      error ("DW_FORM_strp used without .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d4450 1
a4450 2
      error ("DW_FORM_strp pointing outside of .debug_str section [in module %s]",
		      bfd_get_filename (abfd));
d5061 2
a5062 4

      /* Cache this symbol's name and the name's demangled form (if any).  */
      SYMBOL_LANGUAGE (sym) = cu_language;
      SYMBOL_SET_NAMES (sym, name, strlen (name), objfile);
d5077 9
d5539 1
a5539 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", 
			  ref, objfile->name);
d5547 1
a5547 2
      error ("Dwarf Error: Problem turning type die at offset into gdb type [in module %s]",
		      objfile->name);
d5571 1
a5571 2
	  error ("Dwarf Error: Cannot find referent at offset %d [in module %s]", ref, 
			  objfile->name);
d5580 1
a5580 2
      error ("Dwarf Error: Problem turning containing type into gdb type [in module %s]", 
		      objfile->name);
d5617 1
a5617 2
	  error ("Dwarf Error: Cannot find type of die [in module %s]", 
			  objfile->name);
d6829 2
a6830 2
      error ("Dwarf Error: internal error - invalid fundamental type id %d [in module %s]",
	     typeid, objfile->name);
d7140 1
a7140 1
dwarf2_free_tmp_obstack (void *ignore)
@


1.66.4.22
log
@2003-02-21  David Carlton  <carlton@@math.stanford.edu>

	* linespec.c (locate_compound_sym): Update call to
	lookup_symbol_namespace.
	* symtab.c (make_symbol_overload_list): Delete namespace_len
	argument.
	* symtab.h: Update declaration for make_symbol_overload_list.
	* valops.c (find_oload_champ_namespace_loop): New format for
	make_symbol_overload_list.
	* symtab.c (lookup_symbol_namespace): Delete namespace_len
	argument.
	(lookup_symbol_aux_using_loop): Update call to
	lookup_symbol_namespace.
	(make_symbol_overload_list_using): Delete namespace_len argument.
	* linespec.c (decode_namespace): Update call to
	lookup_symbol_namespace.
	* valops.c (value_namespace_elt): Ditto.
	* symtab.c (lookup_nested_type): Ditto.
	* symtab.h: Update declaration for lookup_symbol_namespace.
	* block.c (block_all_usings): Delete.
	(block_using): Make static.
	(block_using_iterator_next): New using_direct format.
	(block_using_iterator_first): Ditto.
	* buildsym.c (scan_for_anonymous_namespaces): Rename variables.
	(add_using_directive): New using functions.
	(end_symtab): Use cp_copy_usings.
	(copy_usings_to_obstack): Delete.
	* block.c: Tweak initial comment.
	(struct namespace_info): Move here.
	(block_initialize_namespace): Set scope to NULL!
	* block.h: Add compilation guards.
	Reorder and update declarations.
	* cp-support.c (cp_find_first_component): Return unsigned int.
	(cp_entire_prefix_len): New.
	(cp_add_using_obstack): Delete.
	(cp_add_using_xmalloc): Delete.
	(cp_copy_usings): Rewrite.
	(cp_free_usings): Delete.
	(cp_add_using): New.
	(cp_is_anonymous): Delete second argument.
	(xstrndup): New.
	* cp-support.h: Add compilation guards.
	Update declarations.
	* coffread.c: New variable coff_source_file.
	(coff_start_symtab): Use coff_source_file.
	(complete_symtab): Ditto.
	(coff_end_symtab): Ditto.
	(coff_symtab_read): Ditto.
	* dbxread.c (find_stab_function_addr): Const fix.
	* buildsym.h: Const fix.
	* buildsym.c (start_symtab): Const fix.
	(start_subfile): Ditto.
	* cp-support.c (cp_add_using_xmalloc): Copy name.
	* dwarf2read.c (read_namespace): Loop through extensions
	correctly.
	(read_file_scope): Const fix.
	(dwarf2_add_field): Ditto.
	(read_structure_scope): Ditto.
	(read_enumeration): Ditto.
	(read_typedef): Ditto.
	* buildsym.c (finish_block): Update comments and simplify code
	when setting scope.
	* buildsym.h: Add opaque declaration of 'struct block'.
	Change comment before processing_current_prefix.
	* arm-tdep.c (arm_gdbarch_init): Add break; after default:.
@
text
@d882 1
a882 1
static char *dwarf2_name (struct die_info *die);
d932 1
a932 1
static void add_to_cu_func_list (char *, CORE_ADDR, CORE_ADDR);
d2015 1
a2015 1
  const char *name;
d2142 1
a2142 1
add_to_cu_func_list (char *name, CORE_ADDR lowpc, CORE_ADDR highpc)
a2429 3
	      range_beginning += base;
	      range_end += base;

d2487 1
a2487 1
  const char *fieldname;
d2929 1
a2929 1
  const char *name;
d3148 1
a3148 1
  const char *name;
d3452 1
a3452 2
  for (current_die = die;
       current_die != NULL;
d3455 1
a3455 1
      name = dwarf2_name (current_die);
d3468 5
a3472 16
  if (previous_prefix[0] == '\0')
    {
      processing_current_prefix = name;
    }
  else
    {
      /* We need temp_name around because processing_current_namespace
	 is a const char *.  */
      char *temp_name = alloca (strlen (previous_prefix)
				+ 2 + strlen(name) + 1);
      strcpy (temp_name, previous_prefix);
      strcat (temp_name, "::");
      strcat (temp_name, name);

      processing_current_prefix = temp_name;
    }
d3482 1
d3780 1
a3780 2
      die->type = init_type (TYPE_CODE_TYPEDEF, 0, TYPE_FLAG_TARGET_STUB,
			     name, objfile);
@


1.66.4.23
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d41 1
a43 4
#include "bcache.h"
#include "dwarf2expr.h"
#include "dwarf2loc.h"

a939 5
static void
dwarf2_symbol_mark_computed (struct attribute *attr, struct symbol *sym,
			     const struct comp_unit_head *,
			     struct objfile *objfile);

a2232 7

  /* If there was a location expression for DW_AT_frame_base above,
     record it.  We still need to decode it above because not all
     symbols use location expressions exclusively.  */
  if (attr)
    dwarf2_symbol_mark_computed (attr, new->name, cu_header, objfile);

d3214 1
a3214 1
		  FIELD_NAME (fields[num_fields]) = DEPRECATED_SYMBOL_NAME (sym);
a5275 55
static void
var_decode_location (struct attribute *attr, struct symbol *sym,
		     struct objfile *objfile,
		     const struct comp_unit_head *cu_header)
{
  /* NOTE drow/2003-01-30: There used to be a comment and some special
     code here to turn a symbol with DW_AT_external and a
     SYMBOL_VALUE_ADDRESS of 0 into a LOC_UNRESOLVED symbol.  This was
     necessary for platforms (maybe Alpha, certainly PowerPC GNU/Linux
     with some versions of binutils) where shared libraries could have
     relocations against symbols in their debug information - the
     minimal symbol would have the right address, but the debug info
     would not.  It's no longer necessary, because we will explicitly
     apply relocations when we read in the debug information now.  */

  /* A DW_AT_location attribute with no contents indicates that a
     variable has been optimized away.  */
  if (attr_form_is_block (attr) && DW_BLOCK (attr)->size == 0)
    {
      SYMBOL_CLASS (sym) = LOC_OPTIMIZED_OUT;
      return;
    }

  /* Handle one degenerate form of location expression specially, to
     preserve GDB's previous behavior when section offsets are
     specified.  If this is just a DW_OP_addr then mark this symbol
     as LOC_STATIC.  */

  if (attr_form_is_block (attr)
      && DW_BLOCK (attr)->size == 1 + cu_header->addr_size
      && DW_BLOCK (attr)->data[0] == DW_OP_addr)
    {
      int dummy;

      SYMBOL_VALUE_ADDRESS (sym) =
	read_address (objfile->obfd, DW_BLOCK (attr)->data + 1, cu_header,
		      &dummy);
      fixup_symbol_section (sym, objfile);
      SYMBOL_VALUE_ADDRESS (sym) += ANOFFSET (objfile->section_offsets,
					      SYMBOL_SECTION (sym));
      SYMBOL_CLASS (sym) = LOC_STATIC;
      return;
    }

  /* NOTE drow/2002-01-30: It might be worthwhile to have a static
     expression evaluator, and use LOC_COMPUTED only when necessary
     (i.e. when the value of a register or memory location is
     referenced, or a thread-local block, etc.).  Then again, it might
     not be worthwhile.  I'm assuming that it isn't unless performance
     or memory numbers show me otherwise.  */

  dwarf2_symbol_mark_computed (attr, sym, cu_header, objfile);
  SYMBOL_CLASS (sym) = LOC_COMPUTED;
}

a5363 1
	      var_decode_location (attr, sym, objfile, cu_header);
d5366 45
a5410 1
		add_symbol_to_list (sym, &global_symbols);
d5412 52
a5463 1
		add_symbol_to_list (sym, list_in_scope);
d5545 1
a5545 1
		  DEPRECATED_SYMBOL_NAME (sym)
d5582 2
a5583 2
		    obsavestring (DEPRECATED_SYMBOL_NAME (sym),
				  strlen (DEPRECATED_SYMBOL_NAME (sym)),
d5593 4
a5596 4
	      DEPRECATED_SYMBOL_NAME (sym) = obconcat (&objfile->symbol_obstack,
						       processing_current_prefix,
						       "::",
						       name);
d5611 4
a5614 4
	      DEPRECATED_SYMBOL_NAME (sym) = obconcat (&objfile->symbol_obstack,
						       processing_current_prefix,
						       "::",
						       name);
d5660 1
a5660 1
	dwarf2_const_value_length_mismatch_complaint (DEPRECATED_SYMBOL_NAME (sym),
d5676 1
a5676 1
	dwarf2_const_value_length_mismatch_complaint (DEPRECATED_SYMBOL_NAME (sym),
a7797 29
}

static void
dwarf2_symbol_mark_computed (struct attribute *attr, struct symbol *sym,
			     const struct comp_unit_head *cu_header,
			     struct objfile *objfile)
{
  struct dwarf2_locexpr_baton *baton;

  /* When support for location lists is added, this will go away.  */
  if (!attr_form_is_block (attr))
    {
      dwarf2_complex_location_expr_complaint ();
      return;
    }

  baton = obstack_alloc (&objfile->symbol_obstack,
			 sizeof (struct dwarf2_locexpr_baton));
  baton->objfile = objfile;

  /* Note that we're just copying the block's data pointer here, not
     the actual data.  We're still pointing into the dwarf_info_buffer
     for SYM's objfile; right now we never release that buffer, but
     when we do clean up properly this may need to change.  */
  baton->size = DW_BLOCK (attr)->size;
  baton->data = DW_BLOCK (attr)->data;

  SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_locexpr_funcs;
  SYMBOL_LOCATION_BATON (sym) = baton;
@


1.66.4.24
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a45 1
#include "cp-support.h"
d224 1
a224 5
    /* Base address of this compilation unit.  */

    CORE_ADDR base_address;

    /* Non-zero if base_address has been set.  */
d226 1
a226 1
    int base_known;
a398 1
static char *dwarf_loc_buffer;
a514 7
    /* Pointer to start of dwarf locations buffer for the objfile.  */

    char *dwarf_loc_buffer;

    /* Size of dwarf locations buffer for the objfile.  */

    unsigned int dwarf_loc_size;
a529 2
#define DWARF_LOC_BUFFER(p)     (PST_PRIVATE(p)->dwarf_loc_buffer)
#define DWARF_LOC_SIZE(p)       (PST_PRIVATE(p)->dwarf_loc_size)
a961 1
  dwarf_loc_offset = 0;
a1097 8
  if (dwarf_loc_offset)
    dwarf_loc_buffer = dwarf2_read_section (objfile,
					    dwarf_loc_offset,
					    dwarf_loc_size,
					    dwarf_loc_section);
  else
    dwarf_loc_buffer = NULL;

a1318 2
      DWARF_LOC_BUFFER (pst) = dwarf_loc_buffer;
      DWARF_LOC_SIZE (pst) = dwarf_loc_size;
a1840 1
  struct attribute *attr;
a1854 2
  dwarf_loc_buffer = DWARF_LOC_BUFFER (pst);
  dwarf_loc_size = DWARF_LOC_SIZE (pst);
a1878 25
  /* Find the base address of the compilation unit for range lists and
     location lists.  It will normally be specified by DW_AT_low_pc.
     In DWARF-3 draft 4, the base address could be overridden by
     DW_AT_entry_pc.  It's been removed, but GCC still uses this for
     compilation units with discontinuous ranges.  */

  cu_header.base_known = 0;
  cu_header.base_address = 0;

  attr = dwarf_attr (dies, DW_AT_entry_pc);
  if (attr)
    {
      cu_header.base_address = DW_ADDR (attr);
      cu_header.base_known = 1;
    }
  else
    {
      attr = dwarf_attr (dies, DW_AT_low_pc);
      if (attr)
	{
	  cu_header.base_address = DW_ADDR (attr);
	  cu_header.base_known = 1;
	}
    }

d1880 1
d2358 2
a2359 2
	  CORE_ADDR base;
	  int found_base;
d2366 23
a2388 2
	  found_base = cu_header->base_known;
	  base = cu_header->base_address;
d2391 1
d3493 1
a3493 1
      /* We need temp_name around because processing_current_prefix
d3508 3
a3510 3
    cp_add_using_directive (processing_current_prefix,
			    strlen (previous_prefix),
			    strlen (processing_current_prefix));
d7781 4
a7784 1
  if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
d7786 2
a7787 17
      struct dwarf2_loclist_baton *baton;

      baton = obstack_alloc (&objfile->symbol_obstack,
			     sizeof (struct dwarf2_loclist_baton));
      baton->objfile = objfile;

      /* We don't know how long the location list is, but make sure we
	 don't run off the edge of the section.  */
      baton->size = dwarf_loc_size - DW_UNSND (attr);
      baton->data = dwarf_loc_buffer + DW_UNSND (attr);
      baton->base_address = cu_header->base_address;
      if (cu_header->base_known == 0)
	complaint (&symfile_complaints,
		   "Location list used without specifying the CU base address.");

      SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_loclist_funcs;
      SYMBOL_LOCATION_BATON (sym) = baton;
a7788 3
  else
    {
      struct dwarf2_locexpr_baton *baton;
d7790 10
a7799 3
      baton = obstack_alloc (&objfile->symbol_obstack,
			     sizeof (struct dwarf2_locexpr_baton));
      baton->objfile = objfile;
d7801 2
a7802 21
      if (attr_form_is_block (attr))
	{
	  /* Note that we're just copying the block's data pointer
	     here, not the actual data.  We're still pointing into the
	     dwarf_info_buffer for SYM's objfile; right now we never
	     release that buffer, but when we do clean up properly
	     this may need to change.  */
	  baton->size = DW_BLOCK (attr)->size;
	  baton->data = DW_BLOCK (attr)->data;
	}
      else
	{
	  dwarf2_invalid_attrib_class_complaint ("location description",
						 SYMBOL_NATURAL_NAME (sym));
	  baton->size = 0;
	  baton->data = NULL;
	}
      
      SYMBOL_LOCATION_FUNCS (sym) = &dwarf2_locexpr_funcs;
      SYMBOL_LOCATION_BATON (sym) = baton;
    }
@


1.66.4.25
log
@2003-04-18  David Carlton  <carlton@@bactrian.org>

	* mdebugread.c (parse_symbol): Move up declaration of 'iter'.
	* dwarf2read.c (add_partial_namespace): Move up declaration of
	'full_name'.
	* cp-support.c (cp_find_first_component): Accept 'operator' in
	more locations.

2003-04-18  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/maint.exp (test_first_component): Add tests for
	'operator' in more locations.
@
text
@a1688 2
  char *full_name;

d1691 1
a1691 1
  full_name = alloca (strlen (namespace) + 2 + strlen (new_name) + 1);
@


1.66.4.26
log
@2003-05-16  David Carlton  <carlton@@bactrian.org>

	* dwarf2read.c (read_comp_unit): Separate code out into
	read_die_and_children and read_die_and_siblings.
	(read_die_and_children): New.
	(read_die_and_siblings): New.
	(read_full_die): Add HAS_CHILDREN argument.
	struct die_info: Delete HAS_CHILDREN, NEXT members; add CHILD,
	SIBLING, PARENT members.
	(psymtab_to_symtab_1): Use new members of struct die_info.
	(process_die, read_file_scope, read_func_scope)
	(read_lexical_block_scope, read_structure_scope, read_enumeration)
	(read_array_type, read_common_block, read_namespace)
	(read_subroutine_type, read_die_and_children, free_die_list)
	(dump_die, dump_die_list): Ditto.
	(read_namespace): Separate code out into namespace_name.
	(namespace_name): New.
	(typename_concat): New.
	(determine_prefix): New.
	(read_type_die): Set prefix appropriately.
	(class_name): New.

2003-05-16  David Carlton  <carlton@@bactrian.org>

	* gdb.c++/rtti.exp: Convert the gdb/488 kfail into a fail, and
	delete the <.*BaseN> branches.
@
text
@d319 1
d325 1
a325 3
    struct die_info *child;	/* Its first child, if any.  */
    struct die_info *sibling;	/* Its next sibling, if any.  */
    struct die_info *parent;	/* Its parent, if any.  */
d734 1
a734 1
			    const struct comp_unit_head *, int *);
a815 6
static char *determine_prefix (struct die_info *die);

static char *typename_concat (const char *prefix, const char *suffix);

static char *class_name (struct die_info *die);

a856 3
static const char *namespace_name (struct die_info *die,
				   int *is_anonymous);

a890 10
static struct die_info *read_die_and_children (char *info_ptr, bfd *abfd,
					       const struct comp_unit_head *,
					       char **new_info_ptr,
					       struct die_info *parent);

static struct die_info *read_die_and_siblings (char *info_ptr, bfd *abfd,
					       const struct comp_unit_head *,
					       char **new_info_ptr,
					       struct die_info *parent);

d1944 1
a1944 1
      if (dies->child != NULL)
d1946 1
a1946 1
	  child_die = dies->child;
d2056 1
a2056 1
      gdb_assert (die->child == NULL);
d2086 1
a2086 1
      if (die->child != NULL)
d2088 1
a2088 1
	  child_die = die->child;
d2165 1
a2165 1
  if (die->child != NULL)
d2167 1
a2167 1
      child_die = die->child;
d2305 1
a2305 1
  if (die->child != NULL)
d2307 1
a2307 1
      child_die = die->child;
d2355 1
a2355 1
  if (die->child != NULL)
d2357 1
a2357 1
      child_die = die->child;
d3046 1
a3046 1
  if (die->child != NULL && ! die_is_declaration (die))
d3054 1
a3054 1
      child_die = die->child;
d3236 1
a3236 1
  if (die->child != NULL)
d3238 1
a3238 1
      child_die = die->child;
d3317 1
a3317 1
  if (die->child == NULL)
d3326 1
a3326 1
  child_die = die->child;
d3472 1
a3472 1
  if (die->child != NULL)
d3474 1
a3474 1
      child_die = die->child;
d3497 1
a3497 1
  const char *name;
d3501 16
a3516 1
  name = namespace_name (die, &is_anonymous);
d3545 1
a3545 1
  if (die->child != NULL)
d3547 1
a3547 1
      struct die_info *child_die = die->child;
a3558 26
static const char *
namespace_name (struct die_info *die, int *is_anonymous)
{
  struct die_info *current_die;
  const char *name = NULL;

  /* Loop through the extensions until we find a name.  */

  for (current_die = die;
       current_die != NULL;
       current_die = dwarf2_extension (die))
    {
      name = dwarf2_name (current_die);
      if (name != NULL)
	break;
    }

  /* Is it an anonymous namespace?  */

  *is_anonymous = (name == NULL);
  if (*is_anonymous)
    name = "(anonymous namespace)";

  return name;
}

d3782 1
a3782 1
  if (die->child != NULL)
d3791 1
a3791 1
      child_die = die->child;
d3806 1
a3806 1
      child_die = die->child;
d3938 4
a3945 46
  return read_die_and_children (info_ptr, abfd, cu_header, &info_ptr, NULL);
}

/* Read a single die and all its descendents.  */

static struct die_info *
read_die_and_children (char *info_ptr, bfd *abfd,
		       const struct comp_unit_head *cu_header,
		       char **new_info_ptr,
		       struct die_info *parent)
{
  struct die_info *die;
  char *cur_ptr;
  int has_children;

  cur_ptr = read_full_die (&die, abfd, info_ptr, cu_header, &has_children);
  store_in_ref_table (die->offset, die);

  if (has_children)
    {
      die->child = read_die_and_siblings (cur_ptr, abfd, cu_header,
					  new_info_ptr, die);
    }
  else
    {
      die->child = NULL;
      *new_info_ptr = cur_ptr;
    }

  die->sibling = NULL;
  die->parent = parent;
  return die;
}

/* Helper function for read_comp_unit; it reads in a die, all of its
   descendents, and all of its siblings.  */

static struct die_info *
read_die_and_siblings (char *info_ptr, bfd *abfd,
		       const struct comp_unit_head *cu_header,
		       char **new_info_ptr,
		       struct die_info *parent)
{
  struct die_info *first_die, *last_sibling, *die;
  char *cur_ptr;

d3947 3
a3949 3
  first_die = last_sibling = NULL;

  while (1)
d3951 2
a3952 3
      die = read_die_and_children (cur_ptr, abfd, cu_header, &cur_ptr, parent);

      if (!first_die)
d3954 1
a3954 1
	  first_die = die;
d3956 1
a3956 1
      else
d3958 1
a3958 1
	  last_sibling->sibling = die;
d3961 6
a3966 1
      if (die->tag == 0)
d3968 1
a3968 2
	  *new_info_ptr = cur_ptr;
	  return first_die;
d3972 2
a3973 1
	  last_sibling = die;
d3976 2
d3990 1
a3990 3
      if (die->child != NULL)
	free_die_list (die->child);
      next = die->sibling;
d4304 2
a4305 3
/* Read the die from the .debug_info section buffer.  Set DIEP to
   point to a newly allocated die with its information, and set
   HAS_CHILDREN to tell whether the die has children or not.  */
d4309 1
a4309 1
	       const struct comp_unit_head *cu_header, int *has_children)
a4324 1
      *has_children = 0;
d4337 1
a4351 1
  *has_children = abbrev->has_children;
a5871 5
  char *prefix = determine_prefix (die);
  const char *old_prefix = processing_current_prefix;
  struct cleanup *back_to = make_cleanup (xfree, prefix);
  processing_current_prefix = prefix;
  
a5917 69

  processing_current_prefix = old_prefix;
  do_cleanups (back_to);
}

/* Determine the name of the namespace/class that DIE is defined
   within, or NULL if we can't tell.  The caller should xfree the
   result.  */

static char *
determine_prefix (struct die_info *die)
{
  struct die_info *parent;

  if (cu_language != language_cplus)
    return NULL;

  parent = die->parent;

  if (parent == NULL)
    {
      return (processing_has_namespace_info ? xstrdup ("") : NULL);
    }
  else
    {
      char *parent_prefix = determine_prefix (parent);

      switch (parent->tag) {
      case DW_TAG_namespace:
	{
	  int dummy;

	  return typename_concat (parent_prefix,
				  namespace_name (parent, &dummy));
	}
      case DW_TAG_class_type:
      case DW_TAG_structure_type:
	{

	  if (parent_prefix != NULL)
	    return typename_concat (parent_prefix, dwarf2_name (parent));
	  else
	    return class_name (parent);
	}
      default:
	return parent_prefix;
      }
    }
}

/* Return a newly-allocated string formed by concatenating PREFIX,
   "::", and SUFFIX, except that if PREFIX is NULL or the empty
   string, just return a copy of SUFFIX.  */

static char *
typename_concat (const char *prefix, const char *suffix)
{
  if (prefix == NULL || prefix[0] == '\0')
    return xstrdup (suffix);
  else
    {
      char *retval = xmalloc (strlen (prefix) + 2 + strlen (suffix) + 1);

      strcpy (retval, prefix);
      strcat (retval, "::");
      strcat (retval, suffix);

      return retval;
    }
a5919 23
/* Return a newly-allocated string giving the name of the class given
   by DIE.  */

static char *
class_name (struct die_info *die)
{
  struct die_info *child;
  const char *name;

  for (child = die->child; child != NULL; child = sibling_die (child))
    {
      if (child->tag == DW_TAG_subprogram)
	return class_name_from_physname (dwarf2_linkage_name (child));
    }

  name = dwarf2_name (die);
  if (name != NULL)
    return xstrdup (name);
  else
    return xstrdup ("");
}


d6034 37
a6070 1
  return die->sibling;
d6939 1
a6939 1
	   dwarf_bool_name (die->child != NULL));
d7002 1
a7002 4
      if (die->child != NULL)
	dump_die_list (die->child);
      if (die->sibling != NULL)
	dump_die_list (die->sibling);
@


1.66.4.27
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d1562 1
a1562 1
				      VAR_DOMAIN, LOC_BLOCK,
d1572 1
a1572 1
				      VAR_DOMAIN, LOC_BLOCK,
d1598 1
a1598 1
					VAR_DOMAIN, LOC_STATIC,
d1612 1
a1612 1
			       VAR_DOMAIN, LOC_STATIC,
d1620 1
a1620 1
			   VAR_DOMAIN, LOC_TYPEDEF,
d1635 1
a1635 1
			   STRUCT_DOMAIN, LOC_TYPEDEF,
d1645 1
a1645 1
			       VAR_DOMAIN, LOC_TYPEDEF,
d1652 1
a1652 1
			   VAR_DOMAIN, LOC_CONST,
d2687 2
a2688 1
      /* Get name of field.  */
d3549 1
a3549 1

d4906 1
a4906 1
      cu_language = language_minimal;
d5236 2
a5237 2
	      record_line (current_subfile, line, 
	                   check_cu_functions (address));
d5283 2
a5284 2
	      record_line (current_subfile, line, 
	                   check_cu_functions (address));
d5480 1
a5480 1
      SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5610 1
a5610 1
	  SYMBOL_DOMAIN (sym) = STRUCT_DOMAIN;
d5659 1
a5659 1
		SYMBOL_DOMAIN (typedef_sym) = VAR_DOMAIN;
d5679 1
a5679 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5684 1
a5684 1
	  SYMBOL_DOMAIN (sym) = VAR_DOMAIN;
d5746 2
a5747 4
      /* NOTE: cagney/2003-05-09: In-lined store_address call with
         it's body - store_unsigned_integer.  */
      store_unsigned_integer (SYMBOL_VALUE_BYTES (sym), cu_header->addr_size,
			      DW_ADDR (attr));
@


1.66.4.28
log
@2003-05-28  David Carlton  <carlton@@bactrian.org>

	* dwarf2read.c (determine_prefix): Handle anonymous
	classes/structures.
@
text
@d6033 1
d6035 1
a6035 11
	    {
	      const char *parent_name = dwarf2_name (parent);

	      if (parent_name != NULL)
		return typename_concat (parent_prefix, dwarf2_name (parent));
	      else
		/* FIXME: carlton/2003-05-28: I'm not sure what the
		   best thing to do here is.  */
		return typename_concat (parent_prefix,
					"<<anonymous class>>");
	    }
@


1.66.4.29
log
@2003-05-28  David Carlton  <carlton@@bactrian.org>

	* dwarf2read.c (add_partial_structure): When looking for a
	subprogram child, go sibling by sibling.
@
text
@a1776 5
	  else
	    {
	      next_child = locate_pdi_sibling (&child_pdi, next_child,
					       abfd, cu_header);
	    }
@


1.66.4.30
log
@2003-06-12  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (die_specification): New.
	(determine_prefix): Fix memory management.
	(read_structure_scope): Set prefix correctly if getting type via
	specification.
@
text
@a778 2
static struct die_info *die_specification (struct die_info *die);

a3005 1
  struct cleanup *back_to = NULL;
a3016 12
      if (cu_language == language_cplus)
	{
	  struct die_info *spec_die = die_specification (die);

	  if (spec_die != NULL)
	    {
	      char *specification_prefix = determine_prefix (spec_die);
	      processing_current_prefix = specification_prefix;
	      back_to = make_cleanup (xfree, specification_prefix);
	    }
	}

d3025 2
a3026 2
				       processing_current_prefix,
				       processing_current_prefix[0] == '\0'
a3202 2
  if (back_to != NULL)
    do_cleanups (back_to);
a4952 13
/* Returns the die giving the specification for this one, or NULL if
   none.  */

static struct die_info *
die_specification (struct die_info *die)
{
  struct attribute *spec_attr = dwarf_attr (die, DW_AT_specification);

  if (spec_attr == NULL)
    return NULL;
  else
    return follow_die_ref (dwarf2_get_ref_die_offset (spec_attr));
}
a6025 1
      char *retval;
d6032 2
a6033 2
	  retval = typename_concat (parent_prefix,
				    namespace_name (parent, &dummy));
a6034 1
	break;
d6043 1
a6043 1
		retval = typename_concat (parent_prefix, dwarf2_name (parent));
d6047 2
a6048 2
		retval = typename_concat (parent_prefix,
					  "<<anonymous class>>");
d6051 1
a6051 1
	    retval = class_name (parent);
a6052 1
	break;
d6054 1
a6054 2
	retval = parent_prefix;
	break;
a6055 4

      if (retval != parent_prefix)
	xfree (parent_prefix);
      return retval;
@


1.66.4.31
log
@2003-06-16  David Carlton  <carlton@@kealia.com>

	* symfile.h: Change formatting.
	* block.c (allocate_block): Rephrase comment.
	* block.h (BLOCK_GCC_COMPILED): Move definition.
	* cp-namespace.c: Include command.h instead of gdbcmd.h.  Update
	comments, reorder functions.
	(lookup_symbol_file): Set symtab when looking for namespace
	symbols.  Update call to lookup_possible_namespace_symbol.
	(initialize_namespace_blocks): Change comment.
	(get_namespace_objfile): Change objfile name.
	(cp_check_namespace_symbol): Extract body into
	check_namespace_symbol_block.
	(check_namespace_symbol_block): New.
	(lookup_namespace_symbol): Make static, rename from
	cp_lookup_symbol.
	(check_possible_namespace_symbols_loop): Update comment.
	(check_one_possible_namespace_symbol): Call
	check_namespace_symbol_block.
	(lookup_possible_namespace_symbol): Make static; rename from
	cp_lookup_possible_namespace_symbol.
	* cp-support.h: Update declarations.
	* Makefile.in (c-typeprint.o): Don't depend on gdb_assert_h.
	(cp-namespace.o): Depend on command_h, not gdbcmd_h.
	* c-typeprint.c: Don't include gdb_assert.h.
	(c_type_print_base): Delete assertion.  Use TYPE_TAG_NAME.
	* dwarf2read.c: Delete double include of cp-support.h.
	(add_partial_symbol): Look at psym for static variables.
	(add_partial_namespace): Update call to
	cp_check_namespace_symbol.
	(locate_pdi_sibling): Update comment.

2003-06-16  David Carlton  <carlton@@kealia.com>

	* gdb.c++/namespace.exp: Add 'maint cp namespace' test.
	* gdb.c++/maint.exp (test_namespace): Change comment.
@
text
@d52 1
d1613 4
a1616 5
	  psym = add_psymbol_to_list (actual_name, strlen (actual_name),
				      VAR_DOMAIN, LOC_STATIC,
				      &objfile->static_psymbols,
				      0, addr + baseaddr,
				      cu_language, objfile);
d1723 1
a1723 1
  cp_check_namespace_symbol (full_name);
d1820 2
a1821 2
/* Locate ORIG_PDI's sibling; INFO_PTR should point to the next PDI
   after ORIG_PDI.  */
@


1.66.4.32
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1074 3
a1076 7
      flagword aflag = bfd_get_section_flags (ignore_abfd, sectp);
      if (aflag & SEC_HAS_CONTENTS)
        {
          dwarf_eh_frame_offset = sectp->filepos;
          dwarf_eh_frame_size = bfd_get_section_size_before_reloc (sectp);
          dwarf_eh_frame_section = sectp;
        }
a2028 2
    case DW_TAG_try_block:
    case DW_TAG_catch_block:
@


1.66.4.33
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (add_partial_symbol): Add 'objfile' argument to
	call to cp_check_possible_namespace_symbols.
	(add_partial_namespace): Add partial symbol instead of calling
	cp_check_namespace_symbol.
	(read_namespace): Add symbol associated to namespace.
	(new_symbol): Handle DW_TAG_namespace.
	* cp-support.h: Delete declaration of cp_check_namespace_symbol;
	add 'objfile' argument to declaration of
	cp_check_possible_namespace_symbols.
	* cp-namespace.c: Delete variables namespace_block,
	possible_namespace_block, namespace_objfile.
	Delete functions get_namespace_block, get_namespace_objfile,
	cp_check_namespace_symbol, check_namespace_symbol_block,
	lookup_namespace_symbol.
	(lookup_symbol_file): Delete call to lookup_namespace_symbol;
	tweak call to lookup_possible_namespace_symbol.
	(initialize_namespace_symtab): Rename from
	initialize_namespace_blocks; add 'objfile' argument, don't do
	anything special with global block.
	(get_possible_namespace_block): Add 'objfile' argument.
	(check_possible_namespace_symbols_loop)
	(cp_check_possible_namespace_symbols): Ditto.
	(free_namespace_block): Rename from free_namespace_blocks; don't
	do anything special with global block.
	(check_one_possible_namespace_symbol): Add 'objfile' argument, and
	inline call to check_namespace_symbol_block.
	(lookup_possible_namespace_symbol): Add 'symtab' argument, loop
	over all objfiles.
	(maintenance_cplus_namespace): Only have possible symbols; add
	loop over objfiles.
	(_initialize_cp_namespace): Tweak doc string.
	* objfiles.h: Add opaque declaration of struct symtab.
	(struct objfile): Add cp_namespace_symtab member.
	* objfiles.c (allocate_objfile): Set
	objfile->cp_namespace_symtab.

2003-06-27  David Carlton  <carlton@@kealia.com>

	* carlton_runtest (FASTTESTS): Add gdb.c++/pr-1210.exp.
	* gdb.c++/namespace.exp: Delete test for maint cp namespace.
	* gdb.c++/maint.exp (test_help): Tweak output for 'help maint cp
	namespace'.
	(test_namespace): Tweak comment.
@
text
@d1678 1
a1678 2
    cp_check_possible_namespace_symbols (SYMBOL_CPLUS_DEMANGLED_NAME (psym),
					 objfile);
d1725 1
a1725 2
  /* FIXME: carlton/2003-06-27: Should we replace this by a call to
     add_partial_symbol?  */
d1727 1
a1727 4
  add_psymbol_to_list (full_name, strlen (full_name),
		       VAR_DOMAIN, LOC_TYPEDEF,
		       &objfile->global_psymbols,
		       0, 0, cu_language, objfile);
a3576 17
  /* Add a symbol associated to this if we haven't seen the namespace
     before.  */

  if (dwarf2_extension (die) == NULL)
    {
      struct type *type;

      /* FIXME: carlton/2003-06-27: Once GDB is more const-correct,
	 this cast will hopefully become unnecessary.  */
      type = init_type (TYPE_CODE_NAMESPACE, 0, 0,
			(char *) processing_current_prefix,
			objfile);
      TYPE_TAG_NAME (type) = TYPE_NAME (type);

      new_symbol (die, type, objfile, cu_header);
    }

d5506 1
a5506 5
  if (die->tag != DW_TAG_namespace)
    name = dwarf2_linkage_name (die);
  else
    name = TYPE_NAME (type);

a5752 4
	  break;
	case DW_TAG_namespace:
	  SYMBOL_CLASS (sym) = LOC_TYPEDEF;
	  add_symbol_to_list (sym, &global_symbols);
@


1.66.4.34
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d442 6
d5632 26
a5657 4
	      var_decode_location (attr, sym, objfile, cu_header);
	      /* FIXME drow/2003-07-31: Is LOC_COMPUTED_ARG necessary?  */
	      if (SYMBOL_CLASS (sym) == LOC_COMPUTED)
		SYMBOL_CLASS (sym) = LOC_COMPUTED_ARG;
d7361 1
d7587 1
@


1.66.4.35
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1521 1
a1521 1
      /* NOTE: carlton/2003-06-16: This is a bit hackish, but whether
d1815 3
a1817 4
      if (pdi.tag != DW_TAG_enumerator || pdi.name == NULL)
	complaint (&symfile_complaints, "malformed enumerator DIE ignored");
      else
	add_partial_symbol (&pdi, objfile, cu_header, namespace);
d1823 1
a1823 1
/* Locate ORIG_PDI's sibling; INFO_PTR should point to the next DIE
d2167 2
a2168 2
      objfile->ei.deprecated_entry_file_lowpc = lowpc;
      objfile->ei.deprecated_entry_file_highpc = highpc;
d2261 1
a2261 1
  struct context_stack *new;
d2372 1
a2372 1
  struct context_stack *new;
d2442 1
a2442 1
	     .debug_ranges section.  */
a2454 8

	  if (offset >= dwarf_ranges_size)
	    {
	      complaint (&symfile_complaints,
	                 "Offset %d out of bounds for DW_AT_ranges attribute",
			 offset);
	      return 0;
	    }
d3568 8
d3577 1
a3577 2
     before.  Also, add a using directive if it's an anonymous
     namespace.  */
a3590 5

      if (is_anonymous)
	cp_add_using_directive (processing_current_prefix,
				strlen (previous_prefix),
				strlen (processing_current_prefix));
d6322 1
a6322 1
dwarf_tag_name (unsigned tag)
d6454 1
a6454 1
dwarf_attr_name (unsigned attr)
a6618 1
#endif
d6621 1
d6645 1
a6645 1
dwarf_form_name (unsigned form)
d6699 1
a6699 1
dwarf_stack_op_name (unsigned op)
d7022 1
a7022 1
dwarf_type_encoding_name (unsigned enc)
d7053 1
a7053 1
dwarf_cfi_name (unsigned cfi_opc)
@


1.66.4.36
log
@2003-09-30  David Carlton  <carlton@@kealia.com>

	* Makefile.in (c-exp.tab.o): Depend on cp_support_h.
	* c-exp.y: Include c-exp.y.  Update comments, replace
	lookup_nested_type by cp_lookup_nested_type.
	(yylex): Update comments, remove #if 0 block.
	* cp-namespace.c (cp_lookup_nested_type): Move here from symtab.c;
	rename from lookup_nested_type.
	* cp-support.h: Add cp_lookup_nested_type declaration.
	* dwarf2read.c (read_die_and_children): Update comment.
	(read_die_and_siblings): Update comment, move declaration of
	'die'.
	(read_full_die): Update comment, tweak formatting.
	* symtab.c (lookup_nested_type): Move to cp-namespace.c, rename to
	cp_lookup_nested_type.
	* symtab.h: Delete declaration of lookup_nested_type.
@
text
@d4026 1
a4026 5
/* Read a single die and all its descendents.  Set the die's sibling
   field to NULL; set other fields in the die correctly, and set all
   of the descendents' fields correctly.  Set *NEW_INFO_PTR to the
   location of the info_ptr after reading all of those dies.  PARENT
   is the parent of the die in question.  */
d4057 2
a4058 3
/* Read a die, all of its descendents, and all of its siblings; set
   all of the fields of all of the dies correctly.  Arguments are as
   in read_die_and_children.  */
d4066 1
a4066 1
  struct die_info *first_die, *last_sibling;
d4074 1
a4074 3
      struct die_info *die
	= read_die_and_children (cur_ptr, abfd, cu_header,
				 &cur_ptr, parent);
d4424 2
a4425 3
   point to a newly allocated die with its information, except for its
   child, sibling, and parent fields.  Set HAS_CHILDREN to tell
   whether the die has children or not.  */
d4452 2
a4453 3
      error ("Dwarf Error: could not find abbrev number %d [in module %s]",
	     abbrev_number, 
	     bfd_get_filename (abfd));
@


1.66.4.37
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a322 6

    /* The dies in a compilation unit form an n-ary tree.  PARENT
       points to this die's parent; CHILD points to the first child of
       this node; and all the children of a given node are chained
       together via their SIBLING fields, terminated by a die whose
       tag is zero.  */
a325 1

d1012 1
a1012 1
  if (strcmp (sectp->name, INFO_SECTION) == 0)
d1018 1
a1018 1
  else if (strcmp (sectp->name, ABBREV_SECTION) == 0)
d1024 1
a1024 1
  else if (strcmp (sectp->name, LINE_SECTION) == 0)
d1030 1
a1030 1
  else if (strcmp (sectp->name, PUBNAMES_SECTION) == 0)
d1036 1
a1036 1
  else if (strcmp (sectp->name, ARANGES_SECTION) == 0)
d1042 1
a1042 1
  else if (strcmp (sectp->name, LOC_SECTION) == 0)
d1048 1
a1048 1
  else if (strcmp (sectp->name, MACINFO_SECTION) == 0)
d1054 1
a1054 1
  else if (strcmp (sectp->name, STR_SECTION) == 0)
d1060 1
a1060 1
  else if (strcmp (sectp->name, FRAME_SECTION) == 0)
d1066 1
a1066 1
  else if (strcmp (sectp->name, EH_FRAME_SECTION) == 0)
d1076 1
a1076 1
  else if (strcmp (sectp->name, RANGES_SECTION) == 0)
d3446 2
a3447 8
		     length for now.

                     FIXME: jimb/2003-09-22: GDB does not really know
                     how to handle arrays of unspecified length
                     either; we just represent them as zero-length
                     arrays.  Choose an appropriate upper bound given
                     the lower bound we've computed above.  */
		  high = low - 1;
d4243 1
d7593 1
@


1.66.4.38
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* valops.c: Tweak comments to match proposed patch.
	(value_aggregate_elt): Use internal_error instead of error.
	* dwarf2read.c: Tweak comments to match proposed patch.
	(new_symbol): Use SYMBOL_LINKAGE_NAME or SYMBOL_NATURAL_NAME
	instead of DEPRECATED_SYMBOL_NAME.
	* cp-namespace.c: Tweak comments to match proposed patch.
	(cp_set_block_scope): Remove #if 0.
	(cp_lookup_nested_type): Use internal_error instead of error.

2003-11-11  David Carlton  <carlton@@kealia.com>

	* gdb.cp/namespace.exp: Remove doubled comment.
@
text
@a1682 4
/* Determine whether a die of type TAG living in the C++ namespace
   NAMESPACE needs to have the name of the namespace prepended to the
   name listed in the die.  */

d3149 1
a3149 5
		     class that's nested inside a template class.
		     That would also cause problems when trying to
		     determine RTTI information, since we use the
		     demangler to determine the appropriate class
		     name.  */
d5020 2
a5021 2
/* Return the die giving the specification for DIE, if there is
   one.  */
d5689 3
a5691 4
		  /* FIXME: carlton/2003-11-10: Should this use
		     SYMBOL_SET_NAMES instead?  (The same problem also
		     arises a further down in the function.)  */
		  SYMBOL_LINKAGE_NAME (sym)
d5695 1
d5728 2
a5729 2
		    obsavestring (SYMBOL_NATURAL_NAME (sym),
				  strlen (SYMBOL_NATURAL_NAME (sym)),
d5739 4
a5742 4
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->symbol_obstack,
						    processing_current_prefix,
						    "::",
						    name);
d5757 4
a5760 4
	      SYMBOL_LINKAGE_NAME (sym) = obconcat (&objfile->symbol_obstack,
						    processing_current_prefix,
						    "::",
						    name);
d6071 1
a6071 1
/* Return the name of the namespace/class that DIE is defined
d6175 1
@


1.66.4.39
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* dwarf2read.c (get_scope_pc_bounds): New.
	(psymtab_to_symtab_1): Use get_scope_pc_bounds.
	(read_file_scope): Ditto.
@
text
@a842 4
static void get_scope_pc_bounds (struct die_info *,
				 CORE_ADDR *, CORE_ADDR *, struct objfile *,
				 const struct comp_unit_head *);

d1980 25
a2004 1
  get_scope_pc_bounds (dies, &lowpc, &highpc, objfile, &cu_header);
d2128 22
a2149 1
  get_scope_pc_bounds (die, &lowpc, &highpc, objfile, cu_header);
a2577 63
}

/* Get the low and high pc's represented by the scope DIE, and store
   them in *LOWPC and *HIGHPC.  If the correct values can't be
   determined, set *LOWPC to -1 and *HIGHPC to 0.  */
static void
get_scope_pc_bounds (struct die_info *die,
		     CORE_ADDR *lowpc, CORE_ADDR *highpc,
		     struct objfile *objfile,
		     const struct comp_unit_head *cu_header)
{
  CORE_ADDR best_low = (CORE_ADDR) -1;
  CORE_ADDR best_high = (CORE_ADDR) 0;
  CORE_ADDR current_low, current_high;

  if (dwarf2_get_pc_bounds (die, &current_low, &current_high,
			    objfile, cu_header))
    {
      best_low = current_low;
      best_high = current_high;
    }
  else
    {
      struct die_info *child = die->child;

      while (child && child->tag)
	{
	  switch (child->tag) {
	  case DW_TAG_subprogram:
	    if (dwarf2_get_pc_bounds (child, &current_low, &current_high,
				      objfile, cu_header));
	      {
		best_low = min (best_low, current_low);
		best_high = max (best_high, current_high);
	      }
	    break;
	  case DW_TAG_namespace:
	    /* FIXME: carlton/2003-12-15: Should we do this for
	       DW_TAG_class_type/DW_TAG_structure_type, too?  I think
	       that current GCC's always generate the DIEs
	       corresponding to definitions methods of classes at
	       namespace scope, but I don't see any reason why they
	       have to.  */
	    get_scope_pc_bounds (child, &current_low, &current_high,
				 objfile, cu_header);

	    if (current_low != ((CORE_ADDR) -1))
	      {
		best_low = min (best_low, current_low);
		best_high = max (best_high, current_high);
	      }
	    break;
	  default:
	    /* Ignore. */
	    break;
	  }

	  child = sibling_die (child);
	}
    }

  *lowpc = best_low;
  *highpc = best_high;
@


1.66.4.40
log
@Fix comment in last commit.
@
text
@d2576 4
a2579 6
	       that current GCC's always emit the DIEs corresponding
	       to definitions of methods of classes as children of a
	       DW_TAG_compile_unit or DW_TAG_namespace (as opposed to
	       the DIEs giving the declarations, which could be
	       anywhere).  But I don't see any reason why they have to
	       be there.  */
@


1.66.4.41
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d131 12
a232 14
/* Internal state when decoding a particular compilation unit.  */
struct dwarf2_cu
{
  /* The objfile containing this compilation unit.  */
  struct objfile *objfile;

  /* The header of the compilation unit.

     FIXME drow/2003-11-10: Some of the things from the comp_unit_head
     should be moved to the dwarf2_cu structure; for instance the abbrevs
     hash table.  */
  struct comp_unit_head header;
};

d432 2
d437 20
d681 3
a683 2
static char *scan_partial_symbols (char *, CORE_ADDR *, CORE_ADDR *,
				   struct dwarf2_cu *,
d686 2
a687 1
static void add_partial_symbol (struct partial_die_info *, struct dwarf2_cu *,
d694 1
d696 1
a696 1
				    struct dwarf2_cu *cu,
d701 2
a702 1
				    struct dwarf2_cu *cu,
d707 2
a708 1
				      struct dwarf2_cu *cu,
d714 1
a714 1
				 struct dwarf2_cu *cu);
d720 2
a721 1
char *dwarf2_read_section (struct objfile *, asection *);
d723 1
a723 1
static void dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu);
d728 1
a728 1
						 struct dwarf2_cu *);
d731 2
a732 1
			       bfd *, char *, struct dwarf2_cu *);
d735 1
a735 1
			    struct dwarf2_cu *, int *);
d738 1
a738 1
			     bfd *, char *, struct dwarf2_cu *);
d741 1
a741 1
			     bfd *, char *, struct dwarf2_cu *);
d753 1
a753 1
static CORE_ADDR read_address (bfd *, char *ptr, struct dwarf2_cu *,
d785 2
a786 1
                             bfd *abfd, struct dwarf2_cu *cu));
d789 1
a789 1
				struct dwarf2_cu *);
d794 1
a794 1
				  struct dwarf2_cu *);
d797 1
a797 1
				struct dwarf2_cu *);
d803 2
a804 1
static struct type *die_type (struct die_info *, struct dwarf2_cu *);
d806 2
a807 2
static struct type *die_containing_type (struct die_info *,
					 struct dwarf2_cu *);
d813 2
a814 1
static struct type *tag_type_to_type (struct die_info *, struct dwarf2_cu *);
d816 2
a817 1
static void read_type_die (struct die_info *, struct dwarf2_cu *);
d825 2
a826 1
static void read_typedef (struct die_info *, struct dwarf2_cu *);
d828 1
a828 1
static void read_base_type (struct die_info *, struct dwarf2_cu *);
d830 2
a831 1
static void read_file_scope (struct die_info *, struct dwarf2_cu *);
d833 2
a834 1
static void read_func_scope (struct die_info *, struct dwarf2_cu *);
d836 2
a837 1
static void read_lexical_block_scope (struct die_info *, struct dwarf2_cu *);
d840 2
a841 1
				 CORE_ADDR *, CORE_ADDR *, struct dwarf2_cu *);
d844 2
a845 2
				 CORE_ADDR *, CORE_ADDR *,
				 struct dwarf2_cu *);
d848 1
a848 1
			      struct dwarf2_cu *);
d851 1
a851 1
					  struct type *, struct dwarf2_cu *);
d855 2
a856 1
				  struct dwarf2_cu *);
d859 1
a859 1
					     struct type *, struct dwarf2_cu *);
d861 2
a862 1
static void read_structure_scope (struct die_info *, struct dwarf2_cu *);
d864 2
a865 1
static void read_common_block (struct die_info *, struct dwarf2_cu *);
d867 2
a868 1
static void read_namespace (struct die_info *die, struct dwarf2_cu *);
d873 2
a874 1
static void read_enumeration (struct die_info *, struct dwarf2_cu *);
d876 1
a876 1
static struct type *dwarf_base_type (int, int, struct dwarf2_cu *);
d878 2
a879 1
static CORE_ADDR decode_locdesc (struct dwarf_block *, struct dwarf2_cu *);
d881 2
a882 1
static void read_array_type (struct die_info *, struct dwarf2_cu *);
d884 2
a885 1
static void read_tag_pointer_type (struct die_info *, struct dwarf2_cu *);
d887 2
a888 2
static void read_tag_ptr_to_member_type (struct die_info *,
					 struct dwarf2_cu *);
d890 2
a891 1
static void read_tag_reference_type (struct die_info *, struct dwarf2_cu *);
d893 2
a894 1
static void read_tag_const_type (struct die_info *, struct dwarf2_cu *);
d896 2
a897 1
static void read_tag_volatile_type (struct die_info *, struct dwarf2_cu *);
d899 1
a899 1
static void read_tag_string_type (struct die_info *, struct dwarf2_cu *);
d901 2
a902 1
static void read_subroutine_type (struct die_info *, struct dwarf2_cu *);
d904 2
a905 1
static struct die_info *read_comp_unit (char *, bfd *, struct dwarf2_cu *);
d908 1
a908 1
					       struct dwarf2_cu *,
d913 1
a913 1
					       struct dwarf2_cu *,
d921 2
a922 1
static void process_die (struct die_info *, struct dwarf2_cu *);
d979 2
a980 1
                                 char *, bfd *, struct dwarf2_cu *);
d986 2
a987 1
			     struct dwarf2_cu *cu);
d995 9
a1003 9
  dwarf_info_section = 0;
  dwarf_abbrev_section = 0;
  dwarf_line_section = 0;
  dwarf_str_section = 0;
  dwarf_macinfo_section = 0;
  dwarf_frame_section = 0;
  dwarf_eh_frame_section = 0;
  dwarf_ranges_section = 0;
  dwarf_loc_section = 0;
d1006 8
a1013 1
  return (dwarf_info_section != NULL && dwarf_abbrev_section != NULL);
d1025 1
d1031 1
d1037 1
d1043 1
d1049 1
d1055 1
d1061 1
d1067 1
d1073 1
d1082 1
d1089 1
d1103 14
a1116 5
  dwarf_info_buffer = dwarf2_read_section (objfile, dwarf_info_section);
  dwarf_abbrev_buffer = dwarf2_read_section (objfile, dwarf_abbrev_section);

  if (dwarf_line_section)
    dwarf_line_buffer = dwarf2_read_section (objfile, dwarf_line_section);
d1120 5
a1124 2
  if (dwarf_str_section)
    dwarf_str_buffer = dwarf2_read_section (objfile, dwarf_str_section);
d1128 1
a1128 1
  if (dwarf_macinfo_section)
d1130 2
d1136 5
a1140 2
  if (dwarf_ranges_section)
    dwarf_ranges_buffer = dwarf2_read_section (objfile, dwarf_ranges_section);
d1144 5
a1148 2
  if (dwarf_loc_section)
    dwarf_loc_buffer = dwarf2_read_section (objfile, dwarf_loc_section);
d1189 2
d1210 2
d1309 1
a1309 1
      struct dwarf2_cu cu;
d1311 1
d1313 1
a1313 4
      cu.objfile = objfile;
      info_ptr = read_comp_unit_head (&cu.header, info_ptr, abfd);

      if (cu.header.version != 2)
d1315 1
a1315 1
	  error ("Dwarf Error: wrong version in compilation unit header (is %d, should be %d) [in module %s]", cu.header.version, 2, bfd_get_filename (abfd));
d1318 1
a1318 1
      if (cu.header.abbrev_offset >= dwarf_abbrev_size)
d1321 1
a1321 1
		 (long) cu.header.abbrev_offset,
d1326 1
a1326 1
      if (beg_of_comp_unit + cu.header.length + cu.header.initial_length_size
d1330 1
a1330 1
		 (long) cu.header.length,
d1336 3
a1338 3
      cu.header.offset = beg_of_comp_unit - dwarf_info_buffer;
      cu.header.first_die_ptr = info_ptr;
      cu.header.cu_head_ptr = beg_of_comp_unit;
d1341 2
a1342 2
      dwarf2_read_abbrevs (abfd, &cu);
      make_cleanup (dwarf2_empty_abbrev_table, cu.header.dwarf2_abbrevs);
d1346 1
a1346 1
				   &cu);
d1388 2
a1389 2
	  info_ptr = scan_partial_symbols (info_ptr, &lowpc, &highpc,
					   &cu, NULL);
d1418 2
a1419 2
      info_ptr = beg_of_comp_unit + cu.header.length 
                                  + cu.header.initial_length_size;
d1432 3
a1434 2
scan_partial_symbols (char *info_ptr, CORE_ADDR *lowpc,
		      CORE_ADDR *highpc, struct dwarf2_cu *cu,
a1436 1
  struct objfile *objfile = cu->objfile;
d1450 1
a1450 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);
d1474 1
a1474 1
		      add_partial_symbol (&pdi, cu, namespace);
d1483 1
a1483 1
		  add_partial_symbol (&pdi, cu, namespace);
d1490 2
a1491 1
		  info_ptr = add_partial_structure (&pdi, info_ptr, cu,
d1499 2
a1500 1
		  info_ptr = add_partial_enumeration (&pdi, info_ptr, cu,
d1508 1
a1508 1
	      add_partial_symbol (&pdi, cu, namespace);
d1516 3
a1518 2
	      info_ptr = add_partial_namespace (&pdi, info_ptr, lowpc, highpc,
						cu, namespace);
d1538 1
a1538 1
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu);
d1545 3
a1547 2
add_partial_symbol (struct partial_die_info *pdi,
		    struct dwarf2_cu *cu, const char *namespace)
a1548 1
  struct objfile *objfile = cu->objfile;
d1605 1
a1605 1
	    addr = decode_locdesc (pdi->locdesc, cu);
d1618 1
a1618 1
	  addr = decode_locdesc (pdi->locdesc, cu);
d1717 1
d1719 2
a1720 1
		       struct dwarf2_cu *cu, const char *namespace)
d1722 2
a1723 1
  struct objfile *objfile = cu->objfile;
a1726 2
  /* Calculate the full name of the namespace that we just entered.  */

d1746 3
a1748 1
    info_ptr = scan_partial_symbols (info_ptr, lowpc, highpc, cu, full_name);
d1757 2
a1758 1
		       struct dwarf2_cu *cu,
a1760 1
  struct objfile *objfile = cu->objfile;
d1786 2
a1787 1
	  next_child = read_partial_die (&child_pdi, abfd, next_child, cu);
d1800 1
a1800 1
					       abfd, cu);
d1805 1
a1805 1
  add_partial_symbol (struct_pdi, cu, namespace);
d1808 1
a1808 1
  return locate_pdi_sibling (struct_pdi, info_ptr, abfd, cu);
d1815 3
a1817 1
			 struct dwarf2_cu *cu, const char *namespace)
a1818 1
  struct objfile *objfile = cu->objfile;
d1823 1
a1823 1
    add_partial_symbol (enum_pdi, cu, namespace);
d1827 1
a1827 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);
d1833 1
a1833 1
	add_partial_symbol (&pdi, cu, namespace);
d1844 1
a1844 1
		    bfd *abfd, struct dwarf2_cu *cu)
d1864 1
a1864 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, cu);
d1869 1
a1869 1
	info_ptr = locate_pdi_sibling (&pdi, info_ptr, abfd, cu);
d1907 1
a1907 1
  struct dwarf2_cu cu;
a1944 2
  cu.objfile = objfile;

d1946 1
a1946 1
  info_ptr = read_comp_unit_head (&cu.header, info_ptr, abfd);
d1949 2
a1950 2
  dwarf2_read_abbrevs (abfd, &cu);
  make_cleanup (dwarf2_empty_abbrev_table, cu.header.dwarf2_abbrevs);
d1952 1
a1952 1
  dies = read_comp_unit (info_ptr, abfd, &cu);
d1962 2
a1963 2
  cu.header.base_known = 0;
  cu.header.base_address = 0;
d1968 2
a1969 2
      cu.header.base_address = DW_ADDR (attr);
      cu.header.base_known = 1;
d1976 2
a1977 2
	  cu.header.base_address = DW_ADDR (attr);
	  cu.header.base_known = 1;
d1982 1
a1982 1
  process_die (dies, &cu);
d1984 1
a1984 1
  get_scope_pc_bounds (dies, &lowpc, &highpc, &cu);
d2004 2
a2005 1
process_die (struct die_info *die, struct dwarf2_cu *cu)
d2012 1
a2012 1
      read_file_scope (die, cu);
d2015 2
a2016 2
      read_subroutine_type (die, cu);
      read_func_scope (die, cu);
d2026 1
a2026 1
      read_lexical_block_scope (die, cu);
d2031 1
a2031 1
      read_structure_scope (die, cu);
d2034 1
a2034 1
      read_enumeration (die, cu);
d2037 1
a2037 1
      read_subroutine_type (die, cu);
d2040 1
a2040 1
      read_array_type (die, cu);
d2043 1
a2043 1
      read_tag_pointer_type (die, cu);
d2046 1
a2046 1
      read_tag_ptr_to_member_type (die, cu);
d2049 1
a2049 1
      read_tag_reference_type (die, cu);
d2052 1
a2052 1
      read_tag_string_type (die, cu);
d2055 1
a2055 1
      read_base_type (die, cu);
d2059 1
a2059 1
	  new_symbol (die, die->type, cu);
d2063 1
a2063 1
      read_common_block (die, cu);
d2069 1
a2069 1
      read_namespace (die, cu);
d2083 1
a2083 1
      new_symbol (die, NULL, cu);
d2095 2
a2096 1
read_file_scope (struct die_info *die, struct dwarf2_cu *cu)
a2097 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d2108 1
a2108 1
  get_scope_pc_bounds (die, &lowpc, &highpc, cu);
d2173 1
a2173 1
	  process_die (child_die, cu);
d2183 2
a2184 1
      line_header = dwarf_decode_line_header (line_offset, abfd, cu);
d2189 1
a2189 1
          dwarf_decode_lines (line_header, comp_dir, abfd, cu);
d2202 1
a2202 1
                           comp_dir, abfd, cu);
d2229 2
a2230 1
read_func_scope (struct die_info *die, struct dwarf2_cu *cu)
a2231 1
  struct objfile *objfile = cu->objfile;
d2243 1
a2243 1
  if (name == NULL || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
d2259 38
d2298 1
a2298 1
  new->name = new_symbol (die, die->type, cu);
d2300 3
a2302 3
  /* If there is a location expression for DW_AT_frame_base, record
     it.  */
  attr = dwarf_attr (die, DW_AT_frame_base);
d2304 1
a2304 1
    dwarf2_symbol_mark_computed (attr, new->name, cu);
d2313 1
a2313 1
	  process_die (child_die, cu);
d2340 2
a2341 1
read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)
a2342 1
  struct objfile *objfile = cu->objfile;
d2352 1
a2352 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, cu))
d2363 1
a2363 1
	  process_die (child_die, cu);
d2382 2
a2383 1
		      CORE_ADDR *highpc, struct dwarf2_cu *cu)
a2384 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d2419 1
d2437 1
a2437 1
	  marker = read_address (obfd, buffer, cu, &dummy);
d2442 2
a2443 1
	      base = read_address (obfd, buffer + addr_size, cu, &dummy);
d2455 2
a2456 1
	      range_beginning = read_address (obfd, buffer, cu, &dummy);
d2458 1
a2458 1
	      range_end = read_address (obfd, buffer, cu, &dummy);
d2474 2
a2475 1
		  base = read_address (obfd, buffer + addr_size, cu, &dummy);
d2545 2
a2546 1
		     struct dwarf2_cu *cu)
d2552 2
a2553 1
  if (dwarf2_get_pc_bounds (die, &current_low, &current_high, cu))
d2566 2
a2567 1
	    if (dwarf2_get_pc_bounds (child, &current_low, &current_high, cu))
d2582 2
a2583 1
	    get_scope_pc_bounds (child, &current_low, &current_high, cu);
d2608 3
a2610 3
		  struct dwarf2_cu *cu)
{ 
  struct objfile *objfile = cu->objfile;
d2649 1
a2649 1
      fp->type = die_type (die, cu);
d2669 1
a2669 1
	    decode_locdesc (DW_BLOCK (attr), cu) * bits_per_byte;
d2753 1
a2753 1
      FIELD_TYPE (*fp) = die_type (die, cu);
d2762 1
a2762 1
	FIELD_BITPOS (*fp) = (decode_locdesc (DW_BLOCK (attr), cu)
d2766 1
a2766 1
      FIELD_TYPE (*fp) = die_type (die, cu);
d2776 1
a2776 1
			      struct dwarf2_cu *cu)
d2863 2
a2864 1
		      struct type *type, struct dwarf2_cu *cu)
a2865 1
  struct objfile *objfile = cu->objfile;
d2886 1
a2886 1
      if (strcmp (fip->fnfieldlists[i].name, fieldname) == 0)
d2927 1
d2953 1
a2953 1
    fnp->fcontext = die_containing_type (die, cu);
d2985 1
a2985 1
          fnp->voffset = decode_locdesc (DW_BLOCK (attr), cu) + 2;
d3003 1
a3003 1
				 struct dwarf2_cu *cu)
d3050 2
a3051 1
read_structure_scope (struct die_info *die, struct dwarf2_cu *cu)
a3052 1
  struct objfile *objfile = cu->objfile;
d3154 1
a3154 1
	      dwarf2_add_field (&fi, child_die, cu);
d3159 2
a3160 2
	      process_die (child_die, cu);
	      dwarf2_add_member_fn (&fi, child_die, type, cu);
d3200 1
a3200 1
	      dwarf2_add_field (&fi, child_die, cu);
d3204 1
a3204 1
	      process_die (child_die, cu);
d3211 1
a3211 1
	dwarf2_attach_fields_to_type (&fi, type, cu);
d3214 1
a3214 1
	  dwarf2_attach_fn_fields_to_type (&fi, type, cu);
d3222 1
a3222 1
	      struct type *t = die_containing_type (die, cu);
d3238 1
a3238 3
		      if ((strncmp (fieldname, vptr_name,
                                    strlen (vptr_name) - 1)
                           == 0)
d3260 1
a3260 1
      new_symbol (die, type, cu);
d3285 2
a3286 1
read_enumeration (struct die_info *die, struct dwarf2_cu *cu)
a3287 1
  struct objfile *objfile = cu->objfile;
d3337 1
a3337 1
	      process_die (child_die, cu);
d3344 1
a3344 1
		  sym = new_symbol (child_die, type, cu);
d3382 1
a3382 1
  new_symbol (die, type, cu);
d3390 2
a3391 1
read_array_type (struct die_info *die, struct dwarf2_cu *cu)
a3392 1
  struct objfile *objfile = cu->objfile;
d3407 1
a3407 1
  element_type = die_type (die, cu);
d3436 1
a3436 1
	  index_type = die_type (child_die, cu);
d3546 2
a3547 1
read_common_block (struct die_info *die, struct dwarf2_cu *cu)
d3560 1
a3560 1
          base = decode_locdesc (DW_BLOCK (attr), cu);
d3577 1
a3577 1
	  sym = new_symbol (child_die, NULL, cu);
d3582 1
a3582 1
		base + decode_locdesc (DW_BLOCK (attr), cu);
d3593 2
a3594 1
read_namespace (struct die_info *die, struct dwarf2_cu *cu)
a3595 1
  struct objfile *objfile = cu->objfile;
d3637 1
a3637 1
      new_symbol (die, type, cu);
d3651 1
a3651 1
	  process_die (child_die, cu);
d3689 2
a3690 1
read_tag_pointer_type (struct die_info *die, struct dwarf2_cu *cu)
a3691 1
  struct comp_unit_head *cu_header = &cu->header;
d3702 1
a3702 1
  type = lookup_pointer_type (die_type (die, cu));
d3746 2
a3747 1
read_tag_ptr_to_member_type (struct die_info *die, struct dwarf2_cu *cu)
a3748 1
  struct objfile *objfile = cu->objfile;
d3759 2
a3760 2
  to_type = die_type (die, cu);
  domain = die_containing_type (die, cu);
d3770 2
a3771 1
read_tag_reference_type (struct die_info *die, struct dwarf2_cu *cu)
a3772 1
  struct comp_unit_head *cu_header = &cu->header;
d3781 1
a3781 1
  type = lookup_reference_type (die_type (die, cu));
d3795 2
a3796 1
read_tag_const_type (struct die_info *die, struct dwarf2_cu *cu)
d3805 1
a3805 1
  base_type = die_type (die, cu);
d3810 2
a3811 1
read_tag_volatile_type (struct die_info *die, struct dwarf2_cu *cu)
d3820 1
a3820 1
  base_type = die_type (die, cu);
d3830 1
a3830 1
read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)
a3831 1
  struct objfile *objfile = cu->objfile;
d3887 2
a3888 1
read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)
d3899 1
a3899 1
  type = die_type (die, cu);
d3947 2
a3948 1
	      TYPE_FIELD_TYPE (ftype, iparams) = die_type (child_die, cu);
d3959 2
a3960 1
read_typedef (struct die_info *die, struct dwarf2_cu *cu)
a3961 1
  struct objfile *objfile = cu->objfile;
d3970 1
a3970 1
      TYPE_TARGET_TYPE (die->type) = die_type (die, cu);
d3978 1
a3978 1
read_base_type (struct die_info *die, struct dwarf2_cu *cu)
a3979 1
  struct objfile *objfile = cu->objfile;
d4053 1
a4053 1
      type = dwarf_base_type (encoding, size, cu);
d4061 2
a4062 1
read_comp_unit (char *info_ptr, bfd *abfd, struct dwarf2_cu *cu)
d4068 1
a4068 1
  return read_die_and_children (info_ptr, abfd, cu, &info_ptr, NULL);
d4079 1
a4079 1
		       struct dwarf2_cu *cu,
d4087 1
a4087 1
  cur_ptr = read_full_die (&die, abfd, info_ptr, cu, &has_children);
d4092 1
a4092 1
      die->child = read_die_and_siblings (cur_ptr, abfd, cu,
d4112 1
a4112 1
		       struct dwarf2_cu *cu,
d4125 2
a4126 1
	= read_die_and_children (cur_ptr, abfd, cu, &cur_ptr, parent);
d4185 2
a4186 1
dwarf2_read_section (struct objfile *objfile, asection *sectp)
a4189 1
  bfd_size_type size = bfd_get_section_size_before_reloc (sectp);
d4200 7
a4206 5
  if (bfd_seek (abfd, sectp->filepos, SEEK_SET) != 0
      || bfd_bread (buf, size, abfd) != size)
    error ("Dwarf Error: Can't read DWARF data from '%s'",
	   bfd_get_filename (abfd));

d4216 1
a4216 1
dwarf2_read_abbrevs (bfd *abfd, struct dwarf2_cu *cu)
a4217 1
  struct comp_unit_head *cu_header = &cu->header;
d4281 1
a4281 1
      if (dwarf2_lookup_abbrev (abbrev_number, cu) != NULL)
d4315 1
a4315 1
dwarf2_lookup_abbrev (unsigned int number, struct dwarf2_cu *cu)
a4316 1
  struct comp_unit_head *cu_header = &cu->header;
d4337 1
a4337 1
		  char *info_ptr, struct dwarf2_cu *cu)
d4353 1
a4353 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
d4366 2
a4367 1
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], abfd, info_ptr, cu);
d4444 1
d4447 1
a4447 1
      read_partial_die (&spec_die, abfd, spec_ptr, cu);
d4481 1
a4481 1
	       struct dwarf2_cu *cu, int *has_children)
d4501 1
a4501 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu);
d4521 1
a4521 1
				 abfd, info_ptr, cu);
d4533 2
a4534 2
		      bfd *abfd, char *info_ptr,
		      struct dwarf2_cu *cu)
a4535 1
  struct comp_unit_head *cu_header = &cu->header;
d4544 1
a4544 1
      DW_ADDR (attr) = read_address (abfd, info_ptr, cu, &bytes_read);
d4639 1
a4639 1
      info_ptr = read_attribute_value (attr, form, abfd, info_ptr, cu);
d4653 2
a4654 1
		bfd *abfd, char *info_ptr, struct dwarf2_cu *cu)
d4657 1
a4657 1
  return read_attribute_value (attr, abbrev->form, abfd, info_ptr, cu);
d4705 2
a4706 1
read_address (bfd *abfd, char *buf, struct dwarf2_cu *cu, int *bytes_read)
a4707 1
  struct comp_unit_head *cu_header = &cu->header;
d5152 1
a5152 1
			  struct dwarf2_cu *cu)
d5193 1
a5193 1
  lh->header_length = read_offset (abfd, line_ptr, &cu->header, &bytes_read);
d5301 1
a5301 1
		    struct dwarf2_cu *cu)
d5305 2
a5306 1
  unsigned int bytes_read;
d5369 1
a5369 1
		  address = read_address (abfd, line_ptr, cu, &bytes_read);
d5513 2
a5514 1
		     struct dwarf2_cu *cu)
a5515 3
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;

d5546 2
a5547 1
	read_address (objfile->obfd, DW_BLOCK (attr)->data + 1, cu, &dummy);
d5562 1
a5562 1
  dwarf2_symbol_mark_computed (attr, sym, cu);
d5573 2
a5574 1
new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu)
a5575 1
  struct objfile *objfile = cu->objfile;
d5580 1
d5605 1
a5605 1
	SYMBOL_TYPE (sym) = die_type (die, cu);
d5647 1
a5647 1
	      dwarf2_const_value (attr, sym, cu);
d5658 1
a5658 1
	      var_decode_location (attr, sym, cu);
d5686 1
a5686 1
	      var_decode_location (attr, sym, cu);
d5694 1
a5694 1
	      dwarf2_const_value (attr, sym, cu);
d5797 1
a5797 1
	      dwarf2_const_value (attr, sym, cu);
d5833 2
a5834 1
		    struct dwarf2_cu *cu)
a5835 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d5934 2
a5935 1
die_type (struct die_info *die, struct dwarf2_cu *cu)
d5946 1
a5946 1
      return dwarf2_fundamental_type (cu->objfile, FT_VOID);
d5955 1
a5955 1
			  ref, cu->objfile->name);
d5959 1
a5959 1
  type = tag_type_to_type (type_die, cu);
d5964 1
a5964 1
		      cu->objfile->name);
d5973 2
a5974 1
die_containing_type (struct die_info *die, struct dwarf2_cu *cu)
d5989 1
a5989 1
			  cu->objfile->name);
d5992 1
a5992 1
      type = tag_type_to_type (type_die, cu);
d5999 1
a5999 1
		      cu->objfile->name);
d6006 1
a6006 1
type_at_offset (unsigned int offset, struct dwarf2_cu *cu)
d6017 1
a6017 1
  type = tag_type_to_type (die, cu);
d6023 2
a6024 1
tag_type_to_type (struct die_info *die, struct dwarf2_cu *cu)
d6032 1
a6032 1
      read_type_die (die, cu);
d6037 1
a6037 1
			  cu->objfile->name);
d6044 2
a6045 1
read_type_die (struct die_info *die, struct dwarf2_cu *cu)
d6057 1
a6057 1
      read_structure_scope (die, cu);
d6060 1
a6060 1
      read_enumeration (die, cu);
d6064 1
a6064 1
      read_subroutine_type (die, cu);
d6067 1
a6067 1
      read_array_type (die, cu);
d6070 1
a6070 1
      read_tag_pointer_type (die, cu);
d6073 1
a6073 1
      read_tag_ptr_to_member_type (die, cu);
d6076 1
a6076 1
      read_tag_reference_type (die, cu);
d6079 1
a6079 1
      read_tag_const_type (die, cu);
d6082 1
a6082 1
      read_tag_volatile_type (die, cu);
d6085 1
a6085 1
      read_tag_string_type (die, cu);
d6088 1
a6088 1
      read_typedef (die, cu);
d6091 1
a6091 1
      read_base_type (die, cu);
d6209 1
a6209 1
dwarf_base_type (int encoding, int size, struct dwarf2_cu *cu)
a6210 2
  struct objfile *objfile = cu->objfile;

d7349 5
a7353 8
   NOTE drow/2003-11-18: This function is called in two situations
   now: for the address of static or global variables (partial symbols
   only) and for offsets into structures which are expected to be
   (more or less) constant.  The partial symbol case should go away,
   and only the constant case should remain.  That will let this
   function complain more accurately.  A few special modes are allowed
   without complaint for global variables (for instance, global
   register values and thread-local values).
d7356 2
a7357 4
   object is optimized out.  The return value is 0 for that case.
   FIXME drow/2003-11-16: No callers check for this case any more; soon all
   callers will only want a very basic result and this can become a
   complaint.
d7362 8
d7374 2
a7375 1
decode_locdesc (struct dwarf_block *blk, struct dwarf2_cu *cu)
a7376 2
  struct objfile *objfile = cu->objfile;
  struct comp_unit_head *cu_header = &cu->header;
d7389 4
d7396 1
a7468 2
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
d7476 63
a7538 2
	  if (i < size)
	    dwarf2_complex_location_expr_complaint ();
d7543 1
a7543 1
					  cu, &bytes_read);
d7609 1
d7611 1
a7611 3
	     this using GDB's address_class enum.  This is valid for partial
	     global symbols, although the variable's address will be bogus
	     in the psymtab.  */
a7620 2
	  /* This is valid for partial global symbols, but the variable's
	     address will be bogus in the psymtab.  */
d7915 2
a7916 1
                     struct dwarf2_cu *cu)
d7992 1
a7992 1
                                             lh, cu->objfile);
d8063 2
a8064 1
			     struct dwarf2_cu *cu)
d8070 1
a8070 1
      baton = obstack_alloc (&cu->objfile->symbol_obstack,
d8072 1
a8072 1
      baton->objfile = cu->objfile;
d8078 2
a8079 2
      baton->base_address = cu->header.base_address;
      if (cu->header.base_known == 0)
d8090 1
a8090 1
      baton = obstack_alloc (&cu->objfile->symbol_obstack,
d8092 1
a8092 1
      baton->objfile = cu->objfile;
@


1.66.4.42
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004
d594 7
d614 7
a789 2
static char *determine_prefix_aux (struct die_info *die);

a797 2
static void read_subrange_type (struct die_info *die, struct dwarf2_cu *cu);

a909 2
static int dwarf2_get_attr_constant_value (struct attribute *, int);

a1411 1
            case DW_TAG_subrange_type:
a1534 1
    case DW_TAG_subrange_type:
d1546 1
a1546 1
      /* NOTE: carlton/2003-10-07: See comment in new_symbol about
d1639 2
a1640 4
  /* FIXME: carlton/2003-10-07: We can't just replace this by a call
     to add_partial_symbol, because we don't have a way to pass in the
     full name to that function; that might be a flaw in
     add_partial_symbol's interface.  */
d1662 2
a1663 1
  bfd *abfd = cu->objfile->obfd;
d1676 1
a1676 1
      /* NOTE: carlton/2003-10-07: Getting the info this way changes
d1688 1
a1688 2
	  next_child = read_partial_die (&child_pdi, abfd, next_child,
					 cu);
a1885 3
  /* Some compilers don't define a DW_AT_high_pc attribute for the
     compilation unit.  If the DW_AT_high_pc is missing, synthesize
     it, by scanning the DIE's below the compilation unit.  */
a1886 1

a1962 8
    case DW_TAG_subrange_type:
      read_subrange_type (die, cu);
      if (dwarf_attr (die, DW_AT_name))
       {
         /* Add a typedef symbol for the base type definition.  */
         new_symbol (die, die->type, cu);
       }
      break;
a2138 2
  const char *previous_prefix = processing_current_prefix;
  struct cleanup *back_to = NULL;
a2146 34
  if (cu_language == language_cplus)
    {
      struct die_info *spec_die = die_specification (die);

	  /* NOTE: carlton/2004-01-23: We have to be careful in the
	     presence of DW_AT_specification.  For example, with GCC
	     3.4, given the code

               namespace N {
	         void foo() {
		   // Definition of N::foo.
	         }
	       }

	     then we'll have a tree of DIEs like this:

	     1: DW_TAG_compile_unit
               2: DW_TAG_namespace        // N
                 3: DW_TAG_subprogram     // declaration of N::foo
               4: DW_TAG_subprogram       // definition of N::foo
                    DW_AT_specification   // refers to die #3

             Thus, when processing die #4, we have to pretend that
             we're in the context of its DW_AT_specification, namely
             the contex of die #3.  */
	
      if (spec_die != NULL)
	{
	  char *specification_prefix = determine_prefix (spec_die);
	  processing_current_prefix = specification_prefix;
	  back_to = make_cleanup (xfree, specification_prefix);
	}
    }

a2196 4

  processing_current_prefix = previous_prefix;
  if (back_to != NULL)
    do_cleanups (back_to);
a2401 1

d2431 1
a2431 1
	    /* FIXME: carlton/2004-01-16: Should we do this for
d2437 2
a2438 2
	       anywhere).  But I don't see any reason why the
	       standards says that they have to be there.  */
d2938 1
a2938 1
	  /* FIXME: carlton/2003-11-10: This variable exists only for
d3022 1
a3022 1
		  /* FIXME: carlton/2003-11-10: The excessive
d3026 1
a3026 1
		  /* NOTE: carlton/2003-11-10: As commented in
d3282 81
a3362 1
          read_subrange_type (child_die, cu);
d3364 10
a3373 14
          if (child_die->type != NULL)
            {
	      /* The range type was succesfully read. Save it for
                 the array type creation.  */
              if ((ndim % DW_FIELD_ALLOC_CHUNK) == 0)
                {
                  range_types = (struct type **)
                    xrealloc (range_types, (ndim + DW_FIELD_ALLOC_CHUNK)
                              * sizeof (struct type *));
                  if (ndim == 0)
                    make_cleanup (free_current_contents, &range_types);
	        }
	      range_types[ndim++] = child_die->type;
            }
a3514 4
/* Return the name of the namespace represented by DIE.  Set
   *IS_ANONYMOUS to tell whether or not the namespace is an anonymous
   namespace.  */

a3911 72
/* Read the given DW_AT_subrange DIE.  */

static void
read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)
{
  struct type *base_type;
  struct type *range_type;
  struct attribute *attr;
  int low = 0;
  int high = -1;
  
  /* If we have already decoded this die, then nothing more to do.  */
  if (die->type)
    return;

  base_type = die_type (die, cu);
  if (base_type == NULL)
    {
      complaint (&symfile_complaints,
                "DW_AT_type missing from DW_TAG_subrange_type");
      return;
    }

  if (TYPE_CODE (base_type) == TYPE_CODE_VOID)
    base_type = alloc_type (NULL);

  if (cu_language == language_fortran)
    { 
      /* FORTRAN implies a lower bound of 1, if not given.  */
      low = 1;
    }

  attr = dwarf_attr (die, DW_AT_lower_bound);
  if (attr)
    low = dwarf2_get_attr_constant_value (attr, 0);

  attr = dwarf_attr (die, DW_AT_upper_bound);
  if (attr)
    {       
      if (attr->form == DW_FORM_block1)
        {
          /* GCC encodes arrays with unspecified or dynamic length
             with a DW_FORM_block1 attribute.
             FIXME: GDB does not yet know how to handle dynamic
             arrays properly, treat them as arrays with unspecified
             length for now.

             FIXME: jimb/2003-09-22: GDB does not really know
             how to handle arrays of unspecified length
             either; we just represent them as zero-length
             arrays.  Choose an appropriate upper bound given
             the lower bound we've computed above.  */
          high = low - 1;
        }
      else
        high = dwarf2_get_attr_constant_value (attr, 1);
    }

  range_type = create_range_type (NULL, base_type, low, high);

  attr = dwarf_attr (die, DW_AT_name);
  if (attr && DW_STRING (attr))
    TYPE_NAME (range_type) = DW_STRING (attr);
  
  attr = dwarf_attr (die, DW_AT_byte_size);
  if (attr)
    TYPE_LENGTH (range_type) = DW_UNSND (attr);

  die->type = range_type;
}
  

d5581 1
a5581 1
	    /* NOTE: carlton/2003-11-10: C++ class symbols shouldn't
a5629 1
        case DW_TAG_subrange_type:
d5649 1
a5649 1
	    /* NOTE: carlton/2003-11-10: See comment above in the
a5935 3
    case DW_TAG_subrange_type:
      read_subrange_type (die, cu);
      break;
a5948 15
/* Return the name of the namespace/class that DIE is defined within,
   or "" if we can't tell.  The caller should xfree the result.  */

/* NOTE: carlton/2004-01-23: See read_func_scope (and the comment
   therein) for an example of how to use this function to deal with
   DW_AT_specification.  */

static char *
determine_prefix (struct die_info *die)
{
  char *prefix = determine_prefix_aux (die);

  return prefix ? prefix : xstrdup ("");
}

d5954 1
a5954 1
determine_prefix_aux (struct die_info *die)
d5969 1
a5969 1
      char *parent_prefix = determine_prefix_aux (parent);
d5991 1
a5991 1
		/* FIXME: carlton/2003-11-10: I'm not sure what the
a7150 22
}

/* Return the constant value held by the given attribute.  Return -1
   if the value held by the attribute is not constant.  */

static int
dwarf2_get_attr_constant_value (struct attribute *attr, int default_value)
{
  if (attr->form == DW_FORM_sdata)
    return DW_SND (attr);
  else if (attr->form == DW_FORM_udata
           || attr->form == DW_FORM_data1
           || attr->form == DW_FORM_data2
           || attr->form == DW_FORM_data4
           || attr->form == DW_FORM_data8)
    return DW_UNSND (attr);
  else
    {
      complaint (&symfile_complaints, "Attribute value is not a constant (%s)",
                 dwarf_form_name (attr->form));
      return default_value;
    }
@


1.65
log
@2002-08-13  David Carlton  <carlton@@math.stanford.edu>

	* dwarf2read.c (dwarf2_build_psymtabs): Check that
	dwarf_line_offset is nonzero before creating dwarf_line_buffer.
	(read_file_scope): Check that line_header is nonzero before
	decoding macro information.
@
text
@d806 2
a807 1
				  struct die_info *, struct objfile *objfile,
d2263 1
a2263 1
		      struct objfile *objfile,
d2331 3
a2333 1
      smash_to_method_type (fnp->type, die->type,
d2522 1
a2522 1
	      dwarf2_add_member_fn (&fi, child_die, objfile, cu_header);
@


1.64
log
@       * dwarf2read.c (set_cu_language): Add handler for LANG_Ada95.
       This does not change anything at the moment, but will be helpful
       later when full Ada support is integrated.
@
text
@d1012 7
a1018 3
  dwarf_line_buffer = dwarf2_read_section (objfile,
					   dwarf_line_offset,
					   dwarf_line_size);
d1815 1
a1815 1
  if (attr)
@


1.63
log
@	* dwarf2read.c (read_initial_length): Handle older, non-standard,
	64-bit DWARF2 format.
@
text
@d4113 1
@


1.62
log
@2002-07-12  Petr Sorfa <petrs@@caldera.com>

        *  dwarf2read.c (dwarf2_invalid_attrib_class): New
        complaint for invalid attribute class or form.
        (read_func_scope): DW_AT_frame_base
        better handling of DW_AT_block*.
        (dwarf2_add_member_fn): DW_AT_vtable_elem_location
        better handling of DW_AT_block*.
        (read_common_block): DW_AT_location
        better handling of DW_AT_block*.
        (read_partial_die): DW_AT_location better handling
        of DW_AT_block*.
        (new_symbol): DW_AT_external better handling of
        DW_AT_block*. Proper initialization of variable
        "addr".
        (attr_form_is_block): New function that returns true
        if the attribute's form is of DW_FORM_block*.
@
text
@d3866 1
a3866 1
/* Reads the initial length from a section.  The (draft) DWARF 2.1
d3872 13
d3895 1
a3895 1
     2.1, draft 4, dated July 20, 2000.  This document was obtained
d3898 1
a3898 1
	http://reality.sgi.com/dehnert_engr/dwarf/dwarf2p1-draft4-000720.pdf
d3902 5
a3906 1
     - Kevin, Aug 4, 2000
d3924 12
@


1.61
log
@* bcache.h: Update copyright.
(struct bstring, struct bcache): Move definition to "bcache.c".
Replaced by opaque declaration.
(bcache_xfree): Replace free_bcache.
(bcache_xmalloc, bcache_memory_used): Declare.

* bcache.c: Update copyright.
(struct bstring, struct bcache): Moved to here from "bcache.h".
Update comments.
(bcache_xmalloc, bcache_memory_used): New functions.
(bcache_xfree): Replace function free_bcache.

* Makefile.in (objfiles.o): Add $(bcache_h).
(objfiles_h): Remove $(bcache_h).
(symfile.o): Add $(bcache_h).

* symmisc.c: Update copyright.
(print_symbol_bcache_statistics): Pass psymbol_cache by value.
(print_objfile_statistics): Use bcache_memory_used.

* symfile.c: Include "bcache.h".
(reread_symbols): Use bcache_xfree.
(reread_symbols): Use bcache_xmalloc and bcache_xfree.
(add_psymbol_to_list): Pass psymbol_cache by value.
(add_psymbol_with_dem_name_to_list): Ditto.

* objfiles.h: Update copyright.
(struct bcache): Declare opaque.  Do not include "bcache.h".
(struct objfile): Change psymbol_cache and macro_cache to ``struct
bcache'' pointers.
* dwarf2read.c (macro_start_file): Pass macro_cache by value.

* objfiles.c: Include "bcache.h".  Update copyright.
(allocate_objfile): Use bcache_xmalloc to create psymbol_cache and
macro_cache.
(free_objfile): Use bcache_xfree.
@
text
@d661 4
d913 2
d1879 18
a1896 1
      CORE_ADDR addr = decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
d2374 16
a2389 1
    fnp->voffset = decode_locdesc (DW_BLOCK (attr), objfile, cu_header) + 2;
d2853 14
a2866 1
      base = decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
d3512 14
a3525 1
	  part_die->locdesc = DW_BLOCK (&attr);
d4589 1
a4589 1
  CORE_ADDR addr;
d4673 16
a4688 2
		  SYMBOL_VALUE_ADDRESS (sym) =
		    decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
d4711 17
a4727 2
		  SYMBOL_VALUE (sym) = addr =
		    decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
d6889 12
@


1.60
log
@Remove some vestiges of Harris 88k support.
* dwarf2read.c (decode_locdesc): Remove `#if' block for Harris 88k
register numbering quirk.
* elfread.c (elf_symtab_read): Remove `#if' block for skipping
odd symbols occurring in Harris 88k ELF targets.
@
text
@d6479 1
a6479 1
                                      &objfile->macro_cache);
@


1.59
log
@2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbtypes.h (TYPE_FLAG_VARARGS): Update comment.
        (struct main_type): Remove arg_types member.  Update comments for
        struct field.
        (TYPE_ARG_TYPES): Remove.
        (TYPE_FN_FIELD_ARGS): Update.
        (smash_to_method_type): Update prototype.

        * c-typeprint.c (cp_type_print_method_args): Take method type
        instead of argument list.  Use new argument layout.  Simplify.
        (c_type_print_args): Use new argument layout.  Simplify.
        (c_type_print_base): Update call to cp_type_print_method_args.
        * dwarf2read.c (dwarf2_add_member_fn): Remove unneeded type
        argument; use die->type instead.  Update call to
        smash_to_method_type.
        (read_structure_scope): Update call to dwarf2_add_member_fn.
        * gdbtypes.c (allocate_stub_method): Update comment.
        (smash_to_method_type): Take new NARGS and VARARGS arguments.
        Use new argument layout.
        (check_stub_method): Use new argument layout.  Don't count
        void as an argument.
        (print_arg_types): Update comments.  Use new argument layout.
        (recursive_dump_type): Don't print arg_types member.
        * hpread.c (hpread_read_struct_type): Use new argument layout.
        (fixup_class_method_type): Likewise.
        (hpread_type_lookup): Likewise.
        * stabsread.c (read_type): Update calls to read_args and
        smash_to_method_type.
        (read_args): Use new argument layout.  Simplify.
        * valops.c (typecmp): Use new argument layout.  Update parameters
        and comments.  Simplify.
        (hand_function_call): Use new argument layout.
        (search_struct_method): Update call to typecmp.
        (find_overload_match): Use new argument layout.
@
text
@a6237 6
#if defined(HARRIS_TARGET) && defined(_M88K)
	  /* The Harris 88110 gdb ports have long kept their special reg
	     numbers between their gp-regs and their x-regs.  This is
	     not how our dwarf is generated.  Punt. */
	  unsnd += 6;
#endif
@


1.58
log
@* dwarf2read.c (free_line_header): Use xfree, not free.
@
text
@d802 1
a802 2
				  struct die_info *, struct type *,
				  struct objfile *objfile,
d2235 1
a2235 1
		      struct type *type, struct objfile *objfile,
a2300 1
      struct type **arg_types;
a2301 1
      int iparams;
d2303 5
a2307 13
      /* Copy argument types from the subroutine type.  */
      arg_types = (struct type **)
	TYPE_ALLOC (fnp->type, (nparams + 1) * sizeof (struct type *));
      for (iparams = 0; iparams < nparams; iparams++)
	arg_types[iparams] = TYPE_FIELD_TYPE (die->type, iparams);

      /* Set last entry in argument type vector.  */
      if (TYPE_VARARGS (die->type))
	arg_types[nparams] = NULL;
      else
	arg_types[nparams] = dwarf2_fundamental_type (objfile, FT_VOID);

      smash_to_method_type (fnp->type, type, return_type, arg_types);
d2477 1
a2477 1
	      dwarf2_add_member_fn (&fi, child_die, type, objfile, cu_header);
@


1.58.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d802 2
a803 1
				  struct die_info *, struct objfile *objfile,
d2236 1
a2236 1
		      struct objfile *objfile,
d2302 1
d2304 1
d2306 13
a2318 5
      smash_to_method_type (fnp->type, die->type,
			    TYPE_TARGET_TYPE (die->type),
			    TYPE_FIELDS (die->type),
			    TYPE_NFIELDS (die->type),
			    TYPE_VARARGS (die->type));
d2488 1
a2488 1
	      dwarf2_add_member_fn (&fi, child_die, objfile, cu_header);
@


1.58.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a660 4
static struct complaint dwarf2_invalid_attrib_class =
{
  "invalid attribute class or form for '%s' in '%s'", 0, 0
};
a908 2
static int attr_form_is_block (struct attribute *);

d1873 1
a1873 18
      CORE_ADDR addr;

      /* Support the .debug_loc offsets */
      if (attr_form_is_block (attr))
        {
          addr = decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
        }
      else if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
        {
          complain (&dwarf2_complex_location_expr);
          addr = 0;
        }
      else
        {
          complain (&dwarf2_invalid_attrib_class, "DW_AT_frame_base", name);
          addr = 0;
        }
    
d2351 1
a2351 16
    {
      /* Support the .debug_loc offsets */
      if (attr_form_is_block (attr))
        {
          fnp->voffset = decode_locdesc (DW_BLOCK (attr), objfile, cu_header) + 2;
        }
      else if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
        {
          complain (&dwarf2_complex_location_expr);
        }
      else
        {
          complain (&dwarf2_invalid_attrib_class, "DW_AT_vtable_elem_location",
                    fieldname);
        }
   }
d2815 1
a2815 14
      /* Support the .debug_loc offsets */
      if (attr_form_is_block (attr))
        {
          base = decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
        }
      else if (attr->form == DW_FORM_data4 || attr->form == DW_FORM_data8)
        {
          complain (&dwarf2_complex_location_expr);
        }
      else
        {
          complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                    "common block member");
        }
d3461 1
a3461 14
          /* Support the .debug_loc offsets */
          if (attr_form_is_block (&attr))
            {
	       part_die->locdesc = DW_BLOCK (&attr);
            }
          else if (attr.form == DW_FORM_data4 || attr.form == DW_FORM_data8)
            {
              complain (&dwarf2_complex_location_expr);
            }
          else
            {
              complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                        "partial symbol information");
            }
d3802 1
a3802 1
/* Read the initial length from a section.  The (draft) DWARF 3
a3807 13
   An older, non-standard 64-bit format is also handled by this
   function.  The older format in question stores the initial length
   as an 8-byte quantity without an escape value.  Lengths greater
   than 2^32 aren't very common which means that the initial 4 bytes
   is almost always zero.  Since a length value of zero doesn't make
   sense for the 32-bit format, this initial zero can be considered to
   be an escape value which indicates the presence of the older 64-bit
   format.  As written, the code can't detect (old format) lengths
   greater than 4GB.  If it becomes necessary to handle lengths somewhat
   larger than 4GB, we could allow other small values (such as the
   non-sensical values of 1, 2, and 3) to also be used as escape values
   indicating the presence of the old format.

d3818 1
a3818 1
     3, draft 8, dated November 19, 2001.  This document was obtained
d3821 1
a3821 1
	http://reality.sgiweb.org/davea/dwarf3-draft8-011125.pdf
d3825 1
a3825 5
     Details regarding the older, non-standard 64-bit format were
     determined empirically by examining 64-bit ELF files produced
     by the SGI toolchain on an IRIX 6.5 machine.

     - Kevin, July 16, 2002
a3845 12
  else if (retval == 0)
    {
      /* Handle (non-standard) 64-bit DWARF2 formats such as that used
         by IRIX.  */
      retval = bfd_get_64 (abfd, (bfd_byte *) buf);
      *bytes_read = 8;
      if (cu_header != NULL)
	{
	  cu_header->initial_length_size = 8;
	  cu_header->offset_size = 8;
	}
    }
d4525 1
a4525 1
  CORE_ADDR addr = 0;
d4609 2
a4610 16
                  /* Support the .debug_loc offsets */
                  if (attr_form_is_block (attr))
                    {
		      SYMBOL_VALUE_ADDRESS (sym) =
		        decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
                    }
                  else if (attr->form == DW_FORM_data4
                           || attr->form == DW_FORM_data8)
                    {
                      complain (&dwarf2_complex_location_expr);
                    }
                  else
                    {
                      complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                                "external variable");
                    }
d4633 2
a4634 17
                  /* Support the .debug_loc offsets */
                  if (attr_form_is_block (attr))
                    {
		      SYMBOL_VALUE (sym) = addr =
		        decode_locdesc (DW_BLOCK (attr), objfile, cu_header);
                    }
                  else if (attr->form == DW_FORM_data4
                           || attr->form == DW_FORM_data8)
                    {
                      complain (&dwarf2_complex_location_expr);
                    }
                  else
                    {
                      complain (&dwarf2_invalid_attrib_class, "DW_AT_location",
                                "external variable");
                      addr = 0;
                    }
d6238 6
d6485 1
a6485 1
                                      objfile->macro_cache);
a6801 12
}

/* Check if the attribute's form is a DW_FORM_block*
   if so return true else false. */
static int
attr_form_is_block (struct attribute *attr)
{
  return (attr == NULL ? 0 :
      attr->form == DW_FORM_block1
      || attr->form == DW_FORM_block2
      || attr->form == DW_FORM_block4
      || attr->form == DW_FORM_block);
@


1.58.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a4112 1
    case DW_LANG_Ada95:
@


1.58.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d1012 3
a1014 7

  if (dwarf_line_offset)
    dwarf_line_buffer = dwarf2_read_section (objfile,
					     dwarf_line_offset,
					     dwarf_line_size);
  else
    dwarf_line_buffer = NULL;
d1811 1
a1811 1
  if (attr && line_header)
@


1.58.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d806 1
a806 2
				  struct die_info *, struct type *,
				  struct objfile *objfile,
d2262 1
a2262 1
		      struct type *type, struct objfile *objfile,
d2330 1
a2330 3
      /* TYPE is the domain of this method, and DIE->TYPE is the type
	   of the method itself (TYPE_CODE_METHOD).  */
      smash_to_method_type (fnp->type, type,
d2519 1
a2519 1
	      dwarf2_add_member_fn (&fi, child_die, type, objfile, cu_header);
@


1.58.2.6
log
@merge from mainline
@
text
@a164 5
/* We hold several abbreviation tables in memory at the same time. */
#ifndef ABBREV_HASH_SIZE
#define ABBREV_HASH_SIZE 121
#endif

a176 23

    /* Offset to the first byte of this compilation unit header in the 
     * .debug_info section, for resolving relative reference dies. */

    unsigned int offset;

    /* Pointer to this compilation unit header in the .debug_info
     * section */

    char *cu_head_ptr;

    /* Pointer to the first die of this compilatio unit.  This will
     * be the first byte following the compilation unit header. */

    char *first_die_ptr;

    /* Pointer to the next compilation unit header in the program. */

    struct comp_unit_head *next;

    /* DWARF abbreviation table associated with this compilation unit */

    struct abbrev_info *dwarf2_abbrevs[ABBREV_HASH_SIZE];
d315 5
d324 2
a391 6
static int is_thread_local;     /* Variable is at a constant offset in the
                                   thread-local storage block for the
                                   current thread and the dynamic linker
                                   module containing this expression.
                                   decode_locdesc returns the offset from
                                   that base.  */
d537 1
a537 1
static struct deprecated_complaint dwarf2_const_ignored =
d541 1
a541 1
static struct deprecated_complaint dwarf2_volatile_ignored =
d545 1
a545 1
static struct deprecated_complaint dwarf2_non_const_array_bound_ignored =
d549 1
a549 1
static struct deprecated_complaint dwarf2_missing_line_number_section =
d553 1
a553 1
static struct deprecated_complaint dwarf2_statement_list_fits_in_line_number_section =
d557 1
a557 1
static struct deprecated_complaint dwarf2_mangled_line_number_section =
d561 1
a561 1
static struct deprecated_complaint dwarf2_unsupported_die_ref_attr =
d565 1
a565 1
static struct deprecated_complaint dwarf2_unsupported_stack_op =
d569 1
a569 1
static struct deprecated_complaint dwarf2_complex_location_expr =
d573 1
a573 1
static struct deprecated_complaint dwarf2_unsupported_tag =
d577 1
a577 1
static struct deprecated_complaint dwarf2_unsupported_at_encoding =
d581 1
a581 1
static struct deprecated_complaint dwarf2_unsupported_at_frame_base =
d585 1
a585 1
static struct deprecated_complaint dwarf2_unexpected_tag =
d589 1
a589 1
static struct deprecated_complaint dwarf2_missing_at_frame_base =
d593 1
a593 1
static struct deprecated_complaint dwarf2_bad_static_member_name =
d597 1
a597 1
static struct deprecated_complaint dwarf2_unsupported_accessibility =
d601 1
a601 1
static struct deprecated_complaint dwarf2_bad_member_name_complaint =
d605 1
a605 1
static struct deprecated_complaint dwarf2_missing_member_fn_type_complaint =
d609 1
a609 1
static struct deprecated_complaint dwarf2_vtbl_not_found_complaint =
d613 1
a613 1
static struct deprecated_complaint dwarf2_absolute_sibling_complaint =
d617 1
a617 1
static struct deprecated_complaint dwarf2_const_value_length_mismatch =
d621 1
a621 1
static struct deprecated_complaint dwarf2_unsupported_const_value_attr =
d625 1
a625 1
static struct deprecated_complaint dwarf2_misplaced_line_number =
d629 1
a629 1
static struct deprecated_complaint dwarf2_line_header_too_long =
d633 1
a633 1
static struct deprecated_complaint dwarf2_missing_macinfo_section =
d637 1
a637 1
static struct deprecated_complaint dwarf2_macros_too_long =
d641 1
a641 1
static struct deprecated_complaint dwarf2_macros_not_terminated =
d645 1
a645 1
static struct deprecated_complaint dwarf2_macro_outside_file =
d649 1
a649 1
static struct deprecated_complaint dwarf2_macro_unmatched_end_file =
d653 1
a653 1
static struct deprecated_complaint dwarf2_macro_malformed_definition =
d657 1
a657 1
static struct deprecated_complaint dwarf2_macro_spaces_in_definition =
d661 1
a661 1
static struct deprecated_complaint dwarf2_invalid_attrib_class =
a664 4
static struct deprecated_complaint dwarf2_invalid_pointer_size = 
{
  "invalid pointer size %d", 0, 0
};
d689 1
a689 1
static void dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header);
d693 1
a693 2
static struct abbrev_info *dwarf2_lookup_abbrev (unsigned int,
                                         const struct comp_unit_head *cu_header);
a818 3
static void read_namespace (struct die_info *die, struct objfile *objfile,
			    const struct comp_unit_head *cu_header);

a1213 5
      /* Complete the cu_header */
      cu_header.offset = beg_of_comp_unit - dwarf_info_buffer;
      cu_header.first_die_ptr = info_ptr;
      cu_header.cu_head_ptr = beg_of_comp_unit;

d1215 2
a1216 2
      dwarf2_read_abbrevs (abfd, &cu_header);
      make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
a1303 11
  /* We only want to read in symbols corresponding to variables or
     other similar objects that are global or static.  Normally, these
     are all children of the DW_TAG_compile_unit die, so are all at
     level 1.  But C++ namespaces give ries to DW_TAG_namespace dies
     whose children are global objects.  So we keep track of what
     level we currently think of as referring to file scope; this
     should always equal 1 plus the number of namespaces that we are
     currently nested within.  */
  
  int file_scope_level = 1;

d1326 1
a1326 1
		  if ((pdi.is_external || nesting_level == file_scope_level)
d1339 1
a1339 1
	      if ((pdi.is_external || nesting_level == file_scope_level)
d1346 3
a1348 5
	      /* File scope enumerators are added to the partial
	         symbol table.  They're children of the enumeration
	         type die, so they occur at a level one higher than we
	         normally look for.  */
	      if (nesting_level == file_scope_level + 1)
d1354 1
a1354 1
	      if (nesting_level == file_scope_level)
a1356 7
	    case DW_TAG_namespace:
	      /* FIXME: carlton/2002-10-16: we're not yet doing
		 anything useful with this, but for now make sure that
		 these tags at least don't cause us to miss any
		 important symbols.  */
	      if (pdi.has_children)
		file_scope_level++;
d1362 4
a1365 7
      /* If the die has a sibling, skip to the sibling.  Do not skip
         enumeration types, we want to record their enumerators.  Do
         not skip namespaces, we want to record symbols inside
         them.  */
      if (pdi.sibling
	  && pdi.tag != DW_TAG_enumeration_type
	  && pdi.tag != DW_TAG_namespace)
d1371 2
a1372 2
	  /* Die has children, but either the optional DW_AT_sibling
	     attribute is missing or we want to look at them.  */
a1378 7
	  /* If this is the end of a DW_TAG_namespace entry, then
	     decrease the file_scope_level, too.  */
	  if (nesting_level < file_scope_level)
	    {
	      file_scope_level--;
	      gdb_assert (nesting_level == file_scope_level);
	    }
d1563 2
a1564 2
  dwarf2_read_abbrevs (abfd, &cu_header);
  make_cleanup (dwarf2_empty_abbrev_table, cu_header.dwarf2_abbrevs);
a1677 13
    case DW_TAG_namespace:
      read_namespace (die, objfile, cu_header);
      break;
    case DW_TAG_imported_declaration:
    case DW_TAG_imported_module:
      /* FIXME: carlton/2002-10-16: Eventually, we should use the
	 information contained in these.  DW_TAG_imported_declaration
	 dies shouldn't have children; DW_TAG_imported_module dies
	 shouldn't in the C++ case, but conceivably could in the
	 Fortran case, so we'll have to replace this gdb_assert if
	 Fortran compilers start generating that info.  */
      gdb_assert (!die->has_children);
      break;
a2892 21
/* Read a C++ namespace.  */

/* FIXME: carlton/2002-10-16: For now, we don't actually do anything
   useful with the namespace data: we just process its children.  */

static void
read_namespace (struct die_info *die, struct objfile *objfile,
		const struct comp_unit_head *cu_header)
{
  if (die->has_children)
    {
      struct die_info *child_die = die->next;
      
      while (child_die && child_die->tag)
	{
	  process_die (child_die, objfile, cu_header);
	  child_die = sibling_die (child_die);
	}
    }
}

d2901 1
a2901 3
  struct attribute *attr_byte_size;
  struct attribute *attr_address_class;
  int byte_size, addr_class;
d2909 5
a2913 10

  attr_byte_size = dwarf_attr (die, DW_AT_byte_size);
  if (attr_byte_size)
    byte_size = DW_UNSND (attr_byte_size);
  else
    byte_size = cu_header->addr_size;

  attr_address_class = dwarf_attr (die, DW_AT_address_class);
  if (attr_address_class)
    addr_class = DW_UNSND (attr_address_class);
a2914 6
    addr_class = DW_ADDR_none;

  /* If the pointer size or address class is different than the
     default, create a type variant marked as such and set the
     length accordingly.  */
  if (TYPE_LENGTH (type) != byte_size || addr_class != DW_ADDR_none)
d2916 1
a2916 15
      if (ADDRESS_CLASS_TYPE_FLAGS_P ())
	{
	  int type_flags;

	  type_flags = ADDRESS_CLASS_TYPE_FLAGS (byte_size, addr_class);
	  gdb_assert ((type_flags & ~TYPE_FLAG_ADDRESS_CLASS_ALL) == 0);
	  type = make_type_with_address_space (type, type_flags);
	}
      else if (TYPE_LENGTH (type) != byte_size)
	{
	  complain (&dwarf2_invalid_pointer_size, byte_size);
	}
      else {
	/* Should we also complain about unhandled address classes?  */
      }
a2917 2

  TYPE_LENGTH (type) = byte_size;
d3348 1
a3348 1
dwarf2_read_abbrevs (bfd *abfd, struct comp_unit_head *cu_header)
d3355 2
a3356 3
  /* Initialize dwarf2 abbrevs */
  memset (cu_header->dwarf2_abbrevs, 0,
          ABBREV_HASH_SIZE*sizeof (struct abbrev_info *));
d3358 1
a3358 1
  abbrev_ptr = dwarf_abbrev_buffer + cu_header->abbrev_offset;
d3397 2
a3398 2
      cur_abbrev->next = cu_header->dwarf2_abbrevs[hash_number];
      cu_header->dwarf2_abbrevs[hash_number] = cur_abbrev;
d3412 1
a3412 1
      if (dwarf2_lookup_abbrev (abbrev_number, cu_header) != NULL)
d3421 1
a3421 1
dwarf2_empty_abbrev_table (PTR ptr_to_abbrevs_table)
a3424 3
  struct abbrev_info **abbrevs;

  abbrevs = (struct abbrev_info **)ptr_to_abbrevs_table;
d3429 1
a3429 1
      abbrev = abbrevs[i];
d3437 1
a3437 1
      abbrevs[i] = NULL;
d3444 1
a3444 1
dwarf2_lookup_abbrev (unsigned int number, const struct comp_unit_head *cu_header)
d3450 1
a3450 1
  abbrev = cu_header->dwarf2_abbrevs[hash_number];
d3482 1
a3482 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
d3626 1
a3626 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cu_header);
a4726 8
                  if (is_thread_local)
                    {
                      /* SYMBOL_VALUE_ADDRESS contains at this point the
		         offset of the variable within the thread local
			 storage.  */
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }
d4735 1
a4735 1
		  else if (SYMBOL_VALUE_ADDRESS (sym))
a4784 5
                  else if (is_thread_local)
                    {
                      SYMBOL_CLASS (sym) = LOC_THREAD_LOCAL_STATIC;
                      SYMBOL_OBJFILE (sym) = objfile;
                    }
a5431 16
    case DW_TAG_dwarf_procedure:
      return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:
      return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:
      return "DW_TAG_interface_type";
    case DW_TAG_namespace:
      return "DW_TAG_namespace";
    case DW_TAG_imported_module:
      return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:
      return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:
      return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:
      return "DW_TAG_imported_unit";
d5576 1
a5576 24
    case DW_AT_allocated:
      return "DW_AT_allocated";
    case DW_AT_associated:
      return "DW_AT_associated";
    case DW_AT_data_location:
      return "DW_AT_data_location";
    case DW_AT_stride:
      return "DW_AT_stride";
    case DW_AT_entry_pc:
      return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:
      return "DW_AT_use_UTF8";
    case DW_AT_extension:
      return "DW_AT_extension";
    case DW_AT_ranges:
      return "DW_AT_ranges";
    case DW_AT_trampoline:
      return "DW_AT_trampoline";
    case DW_AT_call_column:
      return "DW_AT_call_column";
    case DW_AT_call_file:
      return "DW_AT_call_file";
    case DW_AT_call_line:
      return "DW_AT_call_line";
a5963 12
      /* DWARF 3 extensions.  */
    case DW_OP_push_object_address:
      return "DW_OP_push_object_address";
    case DW_OP_call2:
      return "DW_OP_call2";
    case DW_OP_call4:
      return "DW_OP_call4";
    case DW_OP_call_ref:
      return "DW_OP_call_ref";
      /* GNU extensions.  */
    case DW_OP_GNU_push_tls_address:
      return "DW_OP_GNU_push_tls_address";
a6000 2
    case DW_ATE_imaginary_float:
      return "DW_ATE_imaginary_float";
a6284 1
  is_thread_local = 0;
a6506 10

        case DW_OP_GNU_push_tls_address:
          is_thread_local = 1;
	  /* The top of the stack has the offset from the beginning
	     of the thread control block at which the variable is located.  */
	  /* Nothing should follow this operator, so the top of stack would
	     be returned.  */
	  if (i < size)
	    complain (&dwarf2_complex_location_expr);
          break;
@


1.57
log
@Teach the Dwarf 2 reader to read macro information.
* dwarf2read.c: #include "macrotab.h".
(dwarf_macinfo_buffer): New variable.
(struct dwarf2_pinfo): New members: dwarf_macinfo_buffer, and
dwarf_macinfo_size.
(DWARF_MACINFO_BUFFER, DWARF_MACINFO_SIZE): New macros.
(dwarf2_missing_macinfo_section, dwarf2_macros_too_long,
dwarf2_macros_not_terminated, dwarf2_macro_outside_file,
dwarf2_macro_unmatched_end_file, dwarf2_macro_malformed_definition,
dwarf2_macro_spaces_in_definition): New complaints.
(dwarf2_has_info): Initialize dwarf_macinfo_offset.
(dwarf2_build_psymtabs): Read the .dwarf_macinfo section.
(dwarf2_build_psymtabs_hard): Record the buffer and its size in
the partial symbol table.
(psymtab_to_symtab_1): Set the macinfo buffer and size globals
from what's recorded in the partial symbol table.
(read_file_scope): If the compilation unit has a
`DW_AT_macro_info' attribute, read its macro information.
* Makefile.in (dwarf2read.o): Depend on macrotab.h.
@
text
@d4086 1
a4086 1
    free (lh->standard_opcode_lengths);
d4091 1
a4091 1
    free (lh->file_names);
d4095 1
a4095 1
    free (lh->include_dirs);
d4097 1
a4097 1
  free (lh);
@


1.56
log
@2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdbtypes.h: Update accessor macros to use TYPE_MAIN_TYPE.
        (TYPE_CONST, TYPE_VOLATILE, TYPE_CODE_SPACE, TYPE_DATA_SPACE): Use
        TYPE_INSTANCE_FLAGS.
        (struct main_type): New.
        (struct type): Move most members to struct main_type.  Change
        cv_type and as_type to new type_chain member.  Add instance_flags.
        (TYPE_MAIN_TYPE, TYPE_CHAIN, TYPE_INSTANCE_FLAGS): New macros.
        (TYPE_CV_TYPE, TYPE_AS_TYPE): Remove.
        (finish_cv_type): Remove prototype.
        * gdbtypes.c (alloc_type): Update comment.  Allocate TYPE_MAIN_TYPE.
        Set TYPE_CHAIN.
        (alloc_type_instance): New function.
        (smash_type): New function.
        (make_pointer_type, make_reference_type, make_function_type)
        (smash_to_member_type, smash_to_method_type): Call smash_type.
        (make_qualified_type): New function.
        (make_type_with_address_space): Call make_qualified_type.
        (make_cv_type): Likewise.
        (finish_cv_type): Remove unnecessary function.
        (replace_type): Update comment.  Copy TYPE_MAIN_TYPE.
        (recursive_dump_type): Dump TYPE_CHAIN and TYPE_INSTANCE_FLAGS;
        remove TYPE_CV_TYPE and TYPE_AS_TYPE.
        * c-typeprint.c (c_type_print_modifier): Use TYPE_INSTANCE_FLAGS.
        * dwarf2read.c (read_structure_scope): Don't call finish_cv_type.
        * hpread.c (hpread_read_struct_type): Likewise.
        * stabsread.c (read_struct_type): Likewise.

2002-05-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gdb.base/maint.exp (maint print type): Update for new type
        structure.
@
text
@d40 1
d354 1
d448 9
d468 2
d633 28
d906 4
d916 3
a918 1
  dwarf_info_offset = dwarf_abbrev_offset = dwarf_line_offset = 0;
d920 3
a922 1
  dwarf_frame_offset = dwarf_eh_frame_offset = 0;
d1018 7
d1233 2
d1537 2
d1801 11
d6440 373
@


1.56.2.1
log
@merge from trunk
@
text
@a39 1
#include "macrotab.h"
a352 1
static char *dwarf_macinfo_buffer;
a445 9

    /* Pointer to start of dwarf macro buffer for the objfile.  */

    char *dwarf_macinfo_buffer;

    /* Size of dwarf macinfo section for the objfile.  */
    
    unsigned int dwarf_macinfo_size;

a456 2
#define DWARF_MACINFO_BUFFER(p) (PST_PRIVATE(p)->dwarf_macinfo_buffer)
#define DWARF_MACINFO_SIZE(p)   (PST_PRIVATE(p)->dwarf_macinfo_size)
a619 28
static struct complaint dwarf2_missing_macinfo_section =
{
  "missing .debug_macinfo section", 0, 0
};
static struct complaint dwarf2_macros_too_long =
{
  "macro info runs off end of `.debug_macinfo' section", 0, 0
};
static struct complaint dwarf2_macros_not_terminated =
{
  "no terminating 0-type entry for macros in `.debug_macinfo' section", 0, 0
};
static struct complaint dwarf2_macro_outside_file =
{
  "debug info gives macro %s outside of any file: %s", 0, 0
};
static struct complaint dwarf2_macro_unmatched_end_file =
{
  "macro debug info has an unmatched `close_file' directive", 0, 0
};
static struct complaint dwarf2_macro_malformed_definition =
{
  "macro debug info contains a malformed macro definition:\n`%s'", 0, 0
};
static struct complaint dwarf2_macro_spaces_in_definition =
{
  "macro definition contains spaces in formal argument list:\n`%s'", 0, 0
};
d761 2
a762 1
				  struct die_info *, struct objfile *objfile,
a864 4
static void dwarf_decode_macros (struct line_header *, unsigned int,
                                 char *, bfd *, const struct comp_unit_head *,
                                 struct objfile *);

d871 1
a871 3
  dwarf_info_offset = 0;
  dwarf_abbrev_offset = 0;
  dwarf_line_offset = 0;
d873 1
a873 3
  dwarf_macinfo_offset = 0;
  dwarf_frame_offset = 0;
  dwarf_eh_frame_offset = 0;
a968 7
  if (dwarf_macinfo_offset)
    dwarf_macinfo_buffer = dwarf2_read_section (objfile,
                                                dwarf_macinfo_offset,
                                                dwarf_macinfo_size);
  else
    dwarf_macinfo_buffer = NULL;

a1176 2
      DWARF_MACINFO_BUFFER (pst) = dwarf_macinfo_buffer;
      DWARF_MACINFO_SIZE (pst) = dwarf_macinfo_size;
a1478 2
  dwarf_macinfo_buffer = DWARF_MACINFO_BUFFER (pst);
  dwarf_macinfo_size = DWARF_MACINFO_SIZE (pst);
a1740 11
  /* Decode macro information, if present.  Dwarf 2 macro information
     refers to information in the line number info statement program
     header, so we can only read it if we've read the header
     successfully.  */
  attr = dwarf_attr (die, DW_AT_macro_info);
  if (attr)
    {
      unsigned int macro_offset = DW_UNSND (attr);
      dwarf_decode_macros (line_header, macro_offset,
                           comp_dir, abfd, cu_header, objfile);
    }
d2165 1
a2165 1
		      struct objfile *objfile,
d2231 1
d2233 1
d2235 13
a2247 5
      smash_to_method_type (fnp->type, die->type,
			    TYPE_TARGET_TYPE (die->type),
			    TYPE_FIELDS (die->type),
			    TYPE_NFIELDS (die->type),
			    TYPE_VARARGS (die->type));
d2417 1
a2417 1
	      dwarf2_add_member_fn (&fi, child_die, objfile, cu_header);
d4015 1
a4015 1
    xfree (lh->standard_opcode_lengths);
d4020 1
a4020 1
    xfree (lh->file_names);
d4024 1
a4024 1
    xfree (lh->include_dirs);
d4026 1
a4026 1
  xfree (lh);
a6368 373
}


/* Macro support.  */


/* Return the full name of file number I in *LH's file name table.
   Use COMP_DIR as the name of the current directory of the
   compilation.  The result is allocated using xmalloc; the caller is
   responsible for freeing it.  */
static char *
file_full_name (int file, struct line_header *lh, const char *comp_dir)
{
  struct file_entry *fe = &lh->file_names[file - 1];
  
  if (IS_ABSOLUTE_PATH (fe->name))
    return xstrdup (fe->name);
  else
    {
      const char *dir;
      int dir_len;
      char *full_name;

      if (fe->dir_index)
        dir = lh->include_dirs[fe->dir_index - 1];
      else
        dir = comp_dir;

      if (dir)
        {
          dir_len = strlen (dir);
          full_name = xmalloc (dir_len + 1 + strlen (fe->name) + 1);
          strcpy (full_name, dir);
          full_name[dir_len] = '/';
          strcpy (full_name + dir_len + 1, fe->name);
          return full_name;
        }
      else
        return xstrdup (fe->name);
    }
}


static struct macro_source_file *
macro_start_file (int file, int line,
                  struct macro_source_file *current_file,
                  const char *comp_dir,
                  struct line_header *lh, struct objfile *objfile)
{
  /* The full name of this source file.  */
  char *full_name = file_full_name (file, lh, comp_dir);

  /* We don't create a macro table for this compilation unit
     at all until we actually get a filename.  */
  if (! pending_macros)
    pending_macros = new_macro_table (&objfile->symbol_obstack,
                                      &objfile->macro_cache);

  if (! current_file)
    /* If we have no current file, then this must be the start_file
       directive for the compilation unit's main source file.  */
    current_file = macro_set_main (pending_macros, full_name);
  else
    current_file = macro_include (current_file, line, full_name);

  xfree (full_name);
              
  return current_file;
}


/* Copy the LEN characters at BUF to a xmalloc'ed block of memory,
   followed by a null byte.  */
static char *
copy_string (const char *buf, int len)
{
  char *s = xmalloc (len + 1);
  memcpy (s, buf, len);
  s[len] = '\0';

  return s;
}


static const char *
consume_improper_spaces (const char *p, const char *body)
{
  if (*p == ' ')
    {
      complain (&dwarf2_macro_spaces_in_definition, body);

      while (*p == ' ')
        p++;
    }

  return p;
}


static void
parse_macro_definition (struct macro_source_file *file, int line,
                        const char *body)
{
  const char *p;

  /* The body string takes one of two forms.  For object-like macro
     definitions, it should be:

        <macro name> " " <definition>

     For function-like macro definitions, it should be:

        <macro name> "() " <definition>
     or
        <macro name> "(" <arg name> ( "," <arg name> ) * ") " <definition>

     Spaces may appear only where explicitly indicated, and in the
     <definition>.

     The Dwarf 2 spec says that an object-like macro's name is always
     followed by a space, but versions of GCC around March 2002 omit
     the space when the macro's definition is the empty string. 

     The Dwarf 2 spec says that there should be no spaces between the
     formal arguments in a function-like macro's formal argument list,
     but versions of GCC around March 2002 include spaces after the
     commas.  */


  /* Find the extent of the macro name.  The macro name is terminated
     by either a space or null character (for an object-like macro) or
     an opening paren (for a function-like macro).  */
  for (p = body; *p; p++)
    if (*p == ' ' || *p == '(')
      break;

  if (*p == ' ' || *p == '\0')
    {
      /* It's an object-like macro.  */
      int name_len = p - body;
      char *name = copy_string (body, name_len);
      const char *replacement;

      if (*p == ' ')
        replacement = body + name_len + 1;
      else
        {
          complain (&dwarf2_macro_malformed_definition, body);
          replacement = body + name_len;
        }
      
      macro_define_object (file, line, name, replacement);

      xfree (name);
    }
  else if (*p == '(')
    {
      /* It's a function-like macro.  */
      char *name = copy_string (body, p - body);
      int argc = 0;
      int argv_size = 1;
      char **argv = xmalloc (argv_size * sizeof (*argv));

      p++;

      p = consume_improper_spaces (p, body);

      /* Parse the formal argument list.  */
      while (*p && *p != ')')
        {
          /* Find the extent of the current argument name.  */
          const char *arg_start = p;

          while (*p && *p != ',' && *p != ')' && *p != ' ')
            p++;

          if (! *p || p == arg_start)
            complain (&dwarf2_macro_malformed_definition,
                      body);
          else
            {
              /* Make sure argv has room for the new argument.  */
              if (argc >= argv_size)
                {
                  argv_size *= 2;
                  argv = xrealloc (argv, argv_size * sizeof (*argv));
                }

              argv[argc++] = copy_string (arg_start, p - arg_start);
            }

          p = consume_improper_spaces (p, body);

          /* Consume the comma, if present.  */
          if (*p == ',')
            {
              p++;

              p = consume_improper_spaces (p, body);
            }
        }

      if (*p == ')')
        {
          p++;

          if (*p == ' ')
            /* Perfectly formed definition, no complaints.  */
            macro_define_function (file, line, name,
                                   argc, (const char **) argv, 
                                   p + 1);
          else if (*p == '\0')
            {
              /* Complain, but do define it.  */
              complain (&dwarf2_macro_malformed_definition, body);
              macro_define_function (file, line, name,
                                     argc, (const char **) argv, 
                                     p);
            }
          else
            /* Just complain.  */
            complain (&dwarf2_macro_malformed_definition, body);
        }
      else
        /* Just complain.  */
        complain (&dwarf2_macro_malformed_definition, body);

      xfree (name);
      {
        int i;

        for (i = 0; i < argc; i++)
          xfree (argv[i]);
      }
      xfree (argv);
    }
  else
    complain (&dwarf2_macro_malformed_definition, body);
}


static void
dwarf_decode_macros (struct line_header *lh, unsigned int offset,
                     char *comp_dir, bfd *abfd,
                     const struct comp_unit_head *cu_header,
                     struct objfile *objfile)
{
  char *mac_ptr, *mac_end;
  struct macro_source_file *current_file = 0;

  if (dwarf_macinfo_buffer == NULL)
    {
      complain (&dwarf2_missing_macinfo_section);
      return;
    }

  mac_ptr = dwarf_macinfo_buffer + offset;
  mac_end = dwarf_macinfo_buffer + dwarf_macinfo_size;

  for (;;)
    {
      enum dwarf_macinfo_record_type macinfo_type;

      /* Do we at least have room for a macinfo type byte?  */
      if (mac_ptr >= mac_end)
        {
          complain (&dwarf2_macros_too_long);
          return;
        }

      macinfo_type = read_1_byte (abfd, mac_ptr);
      mac_ptr++;

      switch (macinfo_type)
        {
          /* A zero macinfo type indicates the end of the macro
             information.  */
        case 0:
          return;

        case DW_MACINFO_define:
        case DW_MACINFO_undef:
          {
            int bytes_read;
            int line;
            char *body;

            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            body = read_string (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;

            if (! current_file)
              complain (&dwarf2_macro_outside_file,
                        macinfo_type == DW_MACINFO_define ? "definition" :
                        macinfo_type == DW_MACINFO_undef ? "undefinition" :
                        "something-or-other",
                        body);
            else
              {
                if (macinfo_type == DW_MACINFO_define)
                  parse_macro_definition (current_file, line, body);
                else if (macinfo_type == DW_MACINFO_undef)
                  macro_undef (current_file, line, body);
              }
          }
          break;

        case DW_MACINFO_start_file:
          {
            int bytes_read;
            int line, file;

            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;

            current_file = macro_start_file (file, line,
                                             current_file, comp_dir,
                                             lh, objfile);
          }
          break;

        case DW_MACINFO_end_file:
          if (! current_file)
            complain (&dwarf2_macro_unmatched_end_file);
          else
            {
              current_file = current_file->included_by;
              if (! current_file)
                {
                  enum dwarf_macinfo_record_type next_type;

                  /* GCC circa March 2002 doesn't produce the zero
                     type byte marking the end of the compilation
                     unit.  Complain if it's not there, but exit no
                     matter what.  */

                  /* Do we at least have room for a macinfo type byte?  */
                  if (mac_ptr >= mac_end)
                    {
                      complain (&dwarf2_macros_too_long);
                      return;
                    }

                  /* We don't increment mac_ptr here, so this is just
                     a look-ahead.  */
                  next_type = read_1_byte (abfd, mac_ptr);
                  if (next_type != 0)
                    complain (&dwarf2_macros_not_terminated);

                  return;
                }
            }
          break;

        case DW_MACINFO_vendor_ext:
          {
            int bytes_read;
            int constant;
            char *string;

            constant = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            string = read_string (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;

            /* We don't recognize any vendor extensions.  */
          }
          break;
        }
    }
@


1.56.2.2
log
@merge with trunk
@
text
@d6238 6
@


1.55
log
@Properly track the size of the current objfile's .debug_line section.
* dwarf2read.c (struct dwarf2_pinfo): New member: dwarf_line_size.
(DWARF_LINE_SIZE): New macro.
(dwarf2_build_psymtabs_hard): Record the line section's size in
the partial symbol table.
(psymtab_to_symtab_1): Restore dwarf_line_size from the partial
symbol table.
@
text
@a2488 2

  finish_cv_type (die->type);
@


1.54
log
@Separate the job of reading the line number info statement program
header (...expialidocious) out into its own function.
* dwarf2read.c (struct line_head, struct filenames, struct
directories): Replace with...
(struct line_header): New structure, containing the full
contents of the statement program header, including the
include directory and file name tables.
(read_file_scope): If we have line number info, instead of just
calling dwarf_decode_lines to do all the work, call
dwarf_decode_line_header first to get a `struct line_header'
containing the data in the statement program header, and then
pass that to dwarf_decode_lines, which will pick up where that
left off.  Be sure to clean up the `struct line_header' object.
(dwarf_decode_line_header, free_line_header, add_include_dir,
add_file_name): New functions.
(dwarf_decode_lines): Move all the code to read the statement
program header into dwarf_decode_line_header.  Take the line
header it built as the first argument, instead of the offset to
the compilation unit's line number info.  Use the new `struct
line_header' type instead of the old structures.  No need to do
cleanups here now, since we don't allocate anything.
(dwarf2_statement_list_fits_in_line_number_section,
dwarf2_line_header_too_long): New complaints.
@
text
@d435 4
d454 1
d1174 1
d1476 1
@


1.54.2.1
log
@Teach the Dwarf 2 reader to read macro information.
* dwarf2read.c: #include "macrotab.h".
(dwarf_macinfo_buffer): New variable.
(struct dwarf2_pinfo): New members: dwarf_macinfo_buffer, and
dwarf_macinfo_size.
(DWARF_MACINFO_BUFFER, DWARF_MACINFO_SIZE): New macros.
(dwarf2_missing_macinfo_section, dwarf2_macros_too_long,
dwarf2_macros_not_terminated, dwarf2_macro_outside_file,
dwarf2_macro_unmatched_end_file, dwarf2_macro_malformed_definition,
dwarf2_macro_spaces_in_definition): New complaints.
(dwarf2_has_info): Initialize dwarf_macinfo_offset.
(dwarf2_build_psymtabs): Read the .dwarf_macinfo section.
(dwarf2_build_psymtabs_hard): Record the buffer and its size in
the partial symbol table.
(psymtab_to_symtab_1): Set the macinfo buffer and size globals
from what's recorded in the partial symbol table.
(read_file_scope): If the compilation unit has a
`DW_AT_macro_info' attribute, read its macro information.
* Makefile.in (dwarf2read.o): Depend on macrotab.h.
@
text
@a39 1
#include "macrotab.h"
a352 1
static char *dwarf_macinfo_buffer;
a441 9

    /* Pointer to start of dwarf macro buffer for the objfile.  */

    char *dwarf_macinfo_buffer;

    /* Size of dwarf macinfo section for the objfile.  */
    
    unsigned int dwarf_macinfo_size;

a451 2
#define DWARF_MACINFO_BUFFER(p) (PST_PRIVATE(p)->dwarf_macinfo_buffer)
#define DWARF_MACINFO_SIZE(p)   (PST_PRIVATE(p)->dwarf_macinfo_size)
a614 28
static struct complaint dwarf2_missing_macinfo_section =
{
  "missing .debug_macinfo section", 0, 0
};
static struct complaint dwarf2_macros_too_long =
{
  "macro info runs off end of `.debug_macinfo' section", 0, 0
};
static struct complaint dwarf2_macros_not_terminated =
{
  "no terminating 0-type entry for macros in `.debug_macinfo' section", 0, 0
};
static struct complaint dwarf2_macro_outside_file =
{
  "debug info gives macro %s outside of any file: %s", 0, 0
};
static struct complaint dwarf2_macro_unmatched_end_file =
{
  "macro debug info has an unmatched `close_file' directive", 0, 0
};
static struct complaint dwarf2_macro_malformed_definition =
{
  "macro debug info contains a malformed macro definition:\n`%s'", 0, 0
};
static struct complaint dwarf2_macro_spaces_in_definition =
{
  "macro definition contains spaces in formal argument list:\n`%s'", 0, 0
};
a859 4
static void dwarf_decode_macros (struct line_header *, unsigned int,
                                 char *, bfd *, const struct comp_unit_head *,
                                 struct objfile *);

d866 1
a866 3
  dwarf_info_offset = 0;
  dwarf_abbrev_offset = 0;
  dwarf_line_offset = 0;
d868 1
a868 3
  dwarf_macinfo_offset = 0;
  dwarf_frame_offset = 0;
  dwarf_eh_frame_offset = 0;
a963 7
  if (dwarf_macinfo_offset)
    dwarf_macinfo_buffer = dwarf2_read_section (objfile,
                                                dwarf_macinfo_offset,
                                                dwarf_macinfo_size);
  else
    dwarf_macinfo_buffer = NULL;

a1170 2
      DWARF_MACINFO_BUFFER (pst) = dwarf_macinfo_buffer;
      DWARF_MACINFO_SIZE (pst) = dwarf_macinfo_size;
a1471 2
  dwarf_macinfo_buffer = DWARF_MACINFO_BUFFER (pst);
  dwarf_macinfo_size = DWARF_MACINFO_SIZE (pst);
a1733 11
  /* Decode macro information, if present.  Dwarf 2 macro information
     refers to information in the line number info statement program
     header, so we can only read it if we've read the header
     successfully.  */
  attr = dwarf_attr (die, DW_AT_macro_info);
  if (attr)
    {
      unsigned int macro_offset = DW_UNSND (attr);
      dwarf_decode_macros (line_header, macro_offset,
                           comp_dir, abfd, cu_header, objfile);
    }
a6363 373
}


/* Macro support.  */


/* Return the full name of file number I in *LH's file name table.
   Use COMP_DIR as the name of the current directory of the
   compilation.  The result is allocated using xmalloc; the caller is
   responsible for freeing it.  */
static char *
file_full_name (int file, struct line_header *lh, const char *comp_dir)
{
  struct file_entry *fe = &lh->file_names[file - 1];
  
  if (IS_ABSOLUTE_PATH (fe->name))
    return xstrdup (fe->name);
  else
    {
      const char *dir;
      int dir_len;
      char *full_name;

      if (fe->dir_index)
        dir = lh->include_dirs[fe->dir_index - 1];
      else
        dir = comp_dir;

      if (dir)
        {
          dir_len = strlen (dir);
          full_name = xmalloc (dir_len + 1 + strlen (fe->name) + 1);
          strcpy (full_name, dir);
          full_name[dir_len] = '/';
          strcpy (full_name + dir_len + 1, fe->name);
          return full_name;
        }
      else
        return xstrdup (fe->name);
    }
}


static struct macro_source_file *
macro_start_file (int file, int line,
                  struct macro_source_file *current_file,
                  const char *comp_dir,
                  struct line_header *lh, struct objfile *objfile)
{
  /* The full name of this source file.  */
  char *full_name = file_full_name (file, lh, comp_dir);

  /* We don't create a macro table for this compilation unit
     at all until we actually get a filename.  */
  if (! pending_macros)
    pending_macros = new_macro_table (&objfile->symbol_obstack,
                                      &objfile->macro_cache);

  if (! current_file)
    /* If we have no current file, then this must be the start_file
       directive for the compilation unit's main source file.  */
    current_file = macro_set_main (pending_macros, full_name);
  else
    current_file = macro_include (current_file, line, full_name);

  xfree (full_name);
              
  return current_file;
}


/* Copy the LEN characters at BUF to a xmalloc'ed block of memory,
   followed by a null byte.  */
static char *
copy_string (const char *buf, int len)
{
  char *s = xmalloc (len + 1);
  memcpy (s, buf, len);
  s[len] = '\0';

  return s;
}


static const char *
consume_improper_spaces (const char *p, const char *body)
{
  if (*p == ' ')
    {
      complain (&dwarf2_macro_spaces_in_definition, body);

      while (*p == ' ')
        p++;
    }

  return p;
}


static void
parse_macro_definition (struct macro_source_file *file, int line,
                        const char *body)
{
  const char *p;

  /* The body string takes one of two forms.  For object-like macro
     definitions, it should be:

        <macro name> " " <definition>

     For function-like macro definitions, it should be:

        <macro name> "() " <definition>
     or
        <macro name> "(" <arg name> ( "," <arg name> ) * ") " <definition>

     Spaces may appear only where explicitly indicated, and in the
     <definition>.

     The Dwarf 2 spec says that an object-like macro's name is always
     followed by a space, but versions of GCC around March 2002 omit
     the space when the macro's definition is the empty string. 

     The Dwarf 2 spec says that there should be no spaces between the
     formal arguments in a function-like macro's formal argument list,
     but versions of GCC around March 2002 include spaces after the
     commas.  */


  /* Find the extent of the macro name.  The macro name is terminated
     by either a space or null character (for an object-like macro) or
     an opening paren (for a function-like macro).  */
  for (p = body; *p; p++)
    if (*p == ' ' || *p == '(')
      break;

  if (*p == ' ' || *p == '\0')
    {
      /* It's an object-like macro.  */
      int name_len = p - body;
      char *name = copy_string (body, name_len);
      const char *replacement;

      if (*p == ' ')
        replacement = body + name_len + 1;
      else
        {
          complain (&dwarf2_macro_malformed_definition, body);
          replacement = body + name_len;
        }
      
      macro_define_object (file, line, name, replacement);

      xfree (name);
    }
  else if (*p == '(')
    {
      /* It's a function-like macro.  */
      char *name = copy_string (body, p - body);
      int argc = 0;
      int argv_size = 1;
      char **argv = xmalloc (argv_size * sizeof (*argv));

      p++;

      p = consume_improper_spaces (p, body);

      /* Parse the formal argument list.  */
      while (*p && *p != ')')
        {
          /* Find the extent of the current argument name.  */
          const char *arg_start = p;

          while (*p && *p != ',' && *p != ')' && *p != ' ')
            p++;

          if (! *p || p == arg_start)
            complain (&dwarf2_macro_malformed_definition,
                      body);
          else
            {
              /* Make sure argv has room for the new argument.  */
              if (argc >= argv_size)
                {
                  argv_size *= 2;
                  argv = xrealloc (argv, argv_size * sizeof (*argv));
                }

              argv[argc++] = copy_string (arg_start, p - arg_start);
            }

          p = consume_improper_spaces (p, body);

          /* Consume the comma, if present.  */
          if (*p == ',')
            {
              p++;

              p = consume_improper_spaces (p, body);
            }
        }

      if (*p == ')')
        {
          p++;

          if (*p == ' ')
            /* Perfectly formed definition, no complaints.  */
            macro_define_function (file, line, name,
                                   argc, (const char **) argv, 
                                   p + 1);
          else if (*p == '\0')
            {
              /* Complain, but do define it.  */
              complain (&dwarf2_macro_malformed_definition, body);
              macro_define_function (file, line, name,
                                     argc, (const char **) argv, 
                                     p);
            }
          else
            /* Just complain.  */
            complain (&dwarf2_macro_malformed_definition, body);
        }
      else
        /* Just complain.  */
        complain (&dwarf2_macro_malformed_definition, body);

      xfree (name);
      {
        int i;

        for (i = 0; i < argc; i++)
          xfree (argv[i]);
      }
      xfree (argv);
    }
  else
    complain (&dwarf2_macro_malformed_definition, body);
}


static void
dwarf_decode_macros (struct line_header *lh, unsigned int offset,
                     char *comp_dir, bfd *abfd,
                     const struct comp_unit_head *cu_header,
                     struct objfile *objfile)
{
  char *mac_ptr, *mac_end;
  struct macro_source_file *current_file = 0;

  if (dwarf_macinfo_buffer == NULL)
    {
      complain (&dwarf2_missing_macinfo_section);
      return;
    }

  mac_ptr = dwarf_macinfo_buffer + offset;
  mac_end = dwarf_macinfo_buffer + dwarf_macinfo_size;

  for (;;)
    {
      enum dwarf_macinfo_record_type macinfo_type;

      /* Do we at least have room for a macinfo type byte?  */
      if (mac_ptr >= mac_end)
        {
          complain (&dwarf2_macros_too_long);
          return;
        }

      macinfo_type = read_1_byte (abfd, mac_ptr);
      mac_ptr++;

      switch (macinfo_type)
        {
          /* A zero macinfo type indicates the end of the macro
             information.  */
        case 0:
          return;

        case DW_MACINFO_define:
        case DW_MACINFO_undef:
          {
            int bytes_read;
            int line;
            char *body;

            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            body = read_string (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;

            if (! current_file)
              complain (&dwarf2_macro_outside_file,
                        macinfo_type == DW_MACINFO_define ? "definition" :
                        macinfo_type == DW_MACINFO_undef ? "undefinition" :
                        "something-or-other",
                        body);
            else
              {
                if (macinfo_type == DW_MACINFO_define)
                  parse_macro_definition (current_file, line, body);
                else if (macinfo_type == DW_MACINFO_undef)
                  macro_undef (current_file, line, body);
              }
          }
          break;

        case DW_MACINFO_start_file:
          {
            int bytes_read;
            int line, file;

            line = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            file = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;

            current_file = macro_start_file (file, line,
                                             current_file, comp_dir,
                                             lh, objfile);
          }
          break;

        case DW_MACINFO_end_file:
          if (! current_file)
            complain (&dwarf2_macro_unmatched_end_file);
          else
            {
              current_file = current_file->included_by;
              if (! current_file)
                {
                  enum dwarf_macinfo_record_type next_type;

                  /* GCC circa March 2002 doesn't produce the zero
                     type byte marking the end of the compilation
                     unit.  Complain if it's not there, but exit no
                     matter what.  */

                  /* Do we at least have room for a macinfo type byte?  */
                  if (mac_ptr >= mac_end)
                    {
                      complain (&dwarf2_macros_too_long);
                      return;
                    }

                  /* We don't increment mac_ptr here, so this is just
                     a look-ahead.  */
                  next_type = read_1_byte (abfd, mac_ptr);
                  if (next_type != 0)
                    complain (&dwarf2_macros_not_terminated);

                  return;
                }
            }
          break;

        case DW_MACINFO_vendor_ext:
          {
            int bytes_read;
            int constant;
            char *string;

            constant = read_unsigned_leb128 (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;
            string = read_string (abfd, mac_ptr, &bytes_read);
            mac_ptr += bytes_read;

            /* We don't recognize any vendor extensions.  */
          }
          break;
        }
    }
@


1.54.2.2
log
@Properly track the size of the current objfile's .debug_line section.
* dwarf2read.c (struct dwarf2_pinfo): New member: dwarf_line_size.
(DWARF_LINE_SIZE): New macro.
(dwarf2_build_psymtabs_hard): Record the line section's size in
the partial symbol table.
(psymtab_to_symtab_1): Restore dwarf_line_size from the partial
symbol table.
@
text
@a436 4
    /* Size of dwarf_line_buffer, in bytes.  */
    
    unsigned int dwarf_line_size;

a460 1
#define DWARF_LINE_SIZE(p)   (PST_PRIVATE(p)->dwarf_line_size)
a1224 1
      DWARF_LINE_SIZE (pst) = dwarf_line_size;
a1527 1
  dwarf_line_size = DWARF_LINE_SIZE (pst);
@


1.53
log
@2002-04-24  Elena Zannoni  <ezannoni@@redhat.com>

         * gdbtypes.h (TYPE_FLAG_VECTOR, TYPE_VECTOR): Define.
         * gdbtypes.c (recursive_dump_type): Output the vector flag.
         * dwarf2read.c (dwarf_attr_name): Handle new attribute for
         vectors.
         (read_array_type): Record the fact that this array type is really a
         vector (i.e. are passed in by value).
@
text
@d178 32
a209 2
/* The data in the .debug_line statement prologue looks like this.  */
struct line_head
d211 10
a220 10
    unsigned int total_length;
    unsigned short version;
    unsigned int prologue_length;
    unsigned char minimum_instruction_length;
    unsigned char default_is_stmt;
    int line_base;
    unsigned char line_range;
    unsigned char opcode_base;
    unsigned char *standard_opcode_lengths;
  };
d535 4
d611 4
d694 8
a701 1
static void dwarf_decode_lines (unsigned int, char *, bfd *,
d1617 1
a1617 1
  unsigned int line_offset = 0;
d1625 1
d1723 9
a1731 2
      line_offset = DW_UNSND (attr);
      dwarf_decode_lines (line_offset, comp_dir, abfd, cu_header);
d1733 2
a4002 3
/* Decode the line number information for the compilation unit whose
   line number info is at OFFSET in the .debug_line section.
   The compilation directory of the file is passed in COMP_DIR.  */
d4004 87
a4090 1
struct filenames
d4092 16
a4107 2
  unsigned int num_files;
  struct fileinfo
d4109 2
a4110 4
      char *name;
      unsigned int dir;
      unsigned int time;
      unsigned int size;
a4111 2
   *files;
};
d4113 72
a4184 5
struct directories
  {
    unsigned int num_dirs;
    char **dirs;
  };
d4231 4
d4236 1
a4236 1
dwarf_decode_lines (unsigned int offset, char *comp_dir, bfd *abfd,
a4240 2
  struct line_head lh;
  struct cleanup *back_to;
d4242 1
a4242 1
  char *cur_file, *cur_dir;
d4245 2
a4246 91
#define FILE_ALLOC_CHUNK 5
#define DIR_ALLOC_CHUNK 5

  struct filenames files;
  struct directories dirs;

  if (dwarf_line_buffer == NULL)
    {
      complain (&dwarf2_missing_line_number_section);
      return;
    }

  files.num_files = 0;
  files.files = NULL;

  dirs.num_dirs = 0;
  dirs.dirs = NULL;

  line_ptr = dwarf_line_buffer + offset;

  /* read in the prologue */
  lh.total_length = read_initial_length (abfd, line_ptr, NULL, &bytes_read);
  line_ptr += bytes_read;
  line_end = line_ptr + lh.total_length;
  lh.version = read_2_bytes (abfd, line_ptr);
  line_ptr += 2;
  lh.prologue_length = read_offset (abfd, line_ptr, cu_header, &bytes_read);
  line_ptr += bytes_read;
  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.default_is_stmt = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.line_base = read_1_signed_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.line_range = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.opcode_base = read_1_byte (abfd, line_ptr);
  line_ptr += 1;
  lh.standard_opcode_lengths = (unsigned char *)
    xmalloc (lh.opcode_base * sizeof (unsigned char));
  back_to = make_cleanup (free_current_contents, &lh.standard_opcode_lengths);

  lh.standard_opcode_lengths[0] = 1;
  for (i = 1; i < lh.opcode_base; ++i)
    {
      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr);
      line_ptr += 1;
    }

  /* Read directory table  */
  while ((cur_dir = read_string (abfd, line_ptr, &bytes_read)) != NULL)
    {
      line_ptr += bytes_read;
      if ((dirs.num_dirs % DIR_ALLOC_CHUNK) == 0)
	{
	  dirs.dirs = (char **)
	    xrealloc (dirs.dirs,
		      (dirs.num_dirs + DIR_ALLOC_CHUNK) * sizeof (char *));
	  if (dirs.num_dirs == 0)
	    make_cleanup (free_current_contents, &dirs.dirs);
	}
      dirs.dirs[dirs.num_dirs++] = cur_dir;
    }
  line_ptr += bytes_read;

  /* Read file name table */
  while ((cur_file = read_string (abfd, line_ptr, &bytes_read)) != NULL)
    {
      line_ptr += bytes_read;
      if ((files.num_files % FILE_ALLOC_CHUNK) == 0)
	{
	  files.files = (struct fileinfo *)
	    xrealloc (files.files,
		      (files.num_files + FILE_ALLOC_CHUNK)
		      * sizeof (struct fileinfo));
	  if (files.num_files == 0)
	    make_cleanup (free_current_contents, &files.files);
	}
      files.files[files.num_files].name = cur_file;
      files.files[files.num_files].dir =
	read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      files.files[files.num_files].time =
	read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      files.files[files.num_files].size =
	read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
      line_ptr += bytes_read;
      files.num_files++;
    }
  line_ptr += bytes_read;
d4256 1
a4256 1
      int is_stmt = lh.default_is_stmt;
d4261 1
a4261 1
      if (files.num_files >= file)
d4263 10
a4272 6
	  /* The file and directory tables are 0 based, the references
	     are 1 based.  */
	  dwarf2_start_subfile (files.files[file - 1].name,
				(files.files[file - 1].dir
				 ? dirs.dirs[files.files[file - 1].dir - 1]
				 : comp_dir));
d4281 1
a4281 1
	  if (op_code >= lh.opcode_base)
d4283 4
a4286 4
	      adj_opcode = op_code - lh.opcode_base;
	      address += (adj_opcode / lh.line_range)
		* lh.minimum_instruction_length;
	      line += lh.line_base + (adj_opcode % lh.line_range);
d4310 17
a4326 22
		  cur_file = read_string (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  if ((files.num_files % FILE_ALLOC_CHUNK) == 0)
		    {
		      files.files = (struct fileinfo *)
			xrealloc (files.files,
				  (files.num_files + FILE_ALLOC_CHUNK)
				  * sizeof (struct fileinfo));
		      if (files.num_files == 0)
			make_cleanup (free_current_contents, &files.files);
		    }
		  files.files[files.num_files].name = cur_file;
		  files.files[files.num_files].dir =
		    read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  files.files[files.num_files].time =
		    read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  files.files[files.num_files].size =
		    read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
		  line_ptr += bytes_read;
		  files.num_files++;
d4330 1
a4330 1
		  goto done;
d4339 1
a4339 1
	      address += lh.minimum_instruction_length
d4348 15
a4362 9
	      /* The file and directory tables are 0 based, the references
	         are 1 based.  */
	      file = read_unsigned_leb128 (abfd, line_ptr, &bytes_read);
	      line_ptr += bytes_read;
	      dwarf2_start_subfile
		(files.files[file - 1].name,
		 (files.files[file - 1].dir
		  ? dirs.dirs[files.files[file - 1].dir - 1]
		  : comp_dir));
d4380 2
a4381 2
	      address += (lh.minimum_instruction_length
			  * ((255 - lh.opcode_base) / lh.line_range));
d4390 1
a4390 1
		for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)
a4398 2
done:
  do_cleanups (back_to);
@


1.52
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2read.c (struct function_range): New.
        (cu_first_fn, cu_last_fn, cu_cached_fn): New.
        (check_cu_functions): New.
        (read_file_scope): Initialize global function lists.
        Call dwarf_decode_line after processing children.
        (read_func_scope): Add to global function list.
        (dwarf_decode_lines): Call check_cu_functions everywhere
        record_line is called.  Call record_line with a linenumber
        of 0 to mark sequence ends.
@
text
@d2665 10
d5280 2
@


1.51
log
@2002-03-20  Daniel Jacobowitz  <drow@@mvista.com>

        Fix PR gdb/422.
        * c-lang.c (c_create_fundamental_type): Handle FT_COMPLEX,
        FT_DBL_PREC_COMPLEX, and FT_EXT_PREC_COMPLEX.
        * dwarf2read.c (read_base_type): Set TYPE_TARGET_TYPE for
        complex types.
        * stabsread.c (rs6000_builtin_type): Likewise.
        (read_sun_floating_type): Likewise.
@
text
@d259 10
d573 4
d811 4
d1563 6
d1660 1
a1660 7
  /* Decode line number information if present.  */
  attr = dwarf_attr (die, DW_AT_stmt_list);
  if (attr)
    {
      line_offset = DW_UNSND (attr);
      dwarf_decode_lines (line_offset, comp_dir, abfd, cu_header);
    }
d1672 29
d1724 3
d3961 45
d4146 1
d4160 1
a4160 6
		  /* Don't call record_line here.  The end_sequence
		     instruction provides the address of the first byte
		     *after* the last line in the sequence; it's not the
		     address of any real source line.  However, the GDB
		     linetable structure only records the starts of lines,
		     not the ends.  This is a weakness of GDB.  */
d4197 1
@


1.50
log
@        * dwarf2read.c (read_array_type): Accept DW_FORM_data8 as
        a constant array bound.
@
text
@d2982 12
@


1.49
log
@        * dwarf2read.c (dwarf_cfi_name): Add new codes.
@
text
@d2541 2
a2542 1
		       || attr->form == DW_FORM_data4)
d2568 2
a2569 1
		       || attr->form == DW_FORM_data4)
@


1.48
log
@2002-02-14  Pierre Muller  <muller@@ics.u-strasbg.fr>

	* dwarf2read.c: Replace fprintf (stderr, ...) by
	fprintf_unfiltered (gdb_stderr, ...).
@
text
@d5606 13
d5622 9
@


1.47
log
@2002-01-20  Daniel Jacobowitz  <drow@@mvista.com>

	* buildsym.c: Update copyright years.
	* c-typeprint.c: Likewise.
	* dwarf2read.c: Likewise.
	* f-typeprint.c: Likewise.
	* gdbtypes.c: Likewise.
	* gdbtypes.h: Likewise.
	* hp-symtab-read.c: Likewise.
	* hpread.c: Likewise.
	* mdebugread.c: Likewise.
	* p-typeprint.c: Likewise.
@
text
@d5620 1
a5620 1
  fprintf (stderr, "Die: %s (abbrev = %d, offset = %d)\n",
d5622 1
a5622 1
  fprintf (stderr, "\thas children: %s\n",
d5625 1
a5625 1
  fprintf (stderr, "\tattributes:\n");
d5628 1
a5628 1
      fprintf (stderr, "\t\t%s (%s) ",
d5635 1
a5635 1
	  fprintf (stderr, "address: ");
d5642 1
a5642 1
	  fprintf (stderr, "block: size %d", DW_BLOCK (&die->attrs[i])->size);
d5653 1
a5653 1
	  fprintf (stderr, "constant: %ld", DW_UNSND (&die->attrs[i]));
d5657 1
a5657 1
	  fprintf (stderr, "string: \"%s\"",
d5663 1
a5663 1
	    fprintf (stderr, "flag: TRUE");
d5665 1
a5665 1
	    fprintf (stderr, "flag: FALSE");
d5670 1
a5670 1
	  fprintf (stderr, "unexpected attribute form: DW_FORM_indirect");
d5673 1
a5673 1
	  fprintf (stderr, "unsupported attribute form: %d.",
d5676 1
a5676 1
      fprintf (stderr, "\n");
@


1.46
log
@2002-01-20  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbtypes.h (struct cplus_struct_type): Add is_artificial to
	member function fields.  Add accessor macro
	TYPE_FN_FIELD_ARTIFICIAL.
	* dwarf2read.c (dwarf2_add_member_fn): Check for artificial methods.
	* c-typeprint.c (c_type_print_base): Skip artificial member
	functions.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
@


1.45
log
@2002-01-15  Daniel Jacobowitz  <drow@@mvista.com>

	* gdbtypes.h (struct type): Fix whitespace.  Remove obsolete
	comment.  Add ``artificial'' to ``union field_location''.

	* dwarf2read.c: Remove ad-hoc TYPE_FIELD_ARTIFICIAL.

	* buildsym.c (finish_block): Initialize TYPE_FIELD_ARTIFICIAL to 0.
	* mdebugread.c (parse_symbol): Likewise.
	* stabsread.c (define_symbol): Likewise.
	* hp-symtab-read.c (hpread_function_type): Likewise, instead of
	initializing TYPE_FIELD_BITPOS to n (obsolete).
	(hpread_doc_function_type): Likewise.
	* hpread.c (hpread_function_type): Likewise.
@
text
@d2171 5
@


1.44
log
@1) Handling of the DW_AT_byte_size attribute when processing a
DW_TAG_string_type (this is acceptable under the current DWARF 2.1/3.0
standard.)
2) In read_tag_string_type(), a fix for FORTRAN that propagates the
first string length to all string types. This is important as FORTRAN
strings are not delimited as in C/C++.
3) Handling of the DW_LANG_Fortran95.
@
text
@a476 7
/* Dwarf2 has no clean way to discern C++ static and non-static member
   functions. G++ helps GDB by marking the first parameter for non-static
   member functions (which is the this pointer) as artificial.
   We pass this information between dwarf2_add_member_fn and
   read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
#define TYPE_FIELD_ARTIFICIAL	TYPE_FIELD_BITPOS

@


1.43
log
@        * dwarf2read.c (decode_locdesc): Implement DW_OP_litn, DW_OP_dup.
        Fix DW_OP_minus.
@
text
@d2789 10
a2798 1
      length = 1;
d2802 11
a2812 2
  char_type = dwarf2_fundamental_type (objfile, FT_CHAR);
  type = create_string_type (char_type, range_type);
d3818 1
@


1.42
log
@Approved by Jim Blandy:

	2001-12-11  Fred Fish  <fnf@@redhat.com>
	* c-typeprint.c (c_type_print_base): Use type flags access macros
	to test bits.
	* ch-typeprint.c (chill_type_print_base): Ditto.
	* ch-valprint.c (chill_val_print): Ditto.
	* d10v-tdep.c (d10v_pointer_to_address): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn): Ditto.
	* dwarfread.c (read_structure_scope): Ditto.
	* gdbtypes.c (create_range_type): Dittol
	(create_set_type): Ditto.
	(check_typedef): Ditto.
	* jv-typeprint.c (java_type_print_base): Ditto.
	* p-typeprint.c (pascal_type_print_base): Ditto
	* p-valprint.c (pascal_val_print): Ditto.
	* stabsread.c (read_cfront_member_functions): Ditto.
	(read_member_functions): Ditto.
	(cleanup_undefined_types): Ditto.
	* valprint.c (val_print): Ditto.
	* valops.c (hand_function_call): Remove is_prototyped
	variable and just use type flag test macro directly.
@
text
@d5810 35
d6003 5
d6019 1
a6019 1
	  stack[stacki - 1] = stack[stacki] - stack[stacki - 1];
@


1.41
log
@Approved by Elena Zannoni:

	2001-12-08  Fred Fish  <fnf@@redhat.com>
	* dwarf2read.c (read_typedef):  Replace hand crafted type
	initialization with a call to the init_type() function, which
	is how the rest of gdb creates types.
@
text
@d2137 1
a2137 1
      if (TYPE_FLAGS (die->type) & TYPE_FLAG_VARARGS)
@


1.40
log
@Approved by Jim Blandy:

	2001-12-08  Fred Fish  <fnf@@redhat.com>
	* dwarf2read.c (TYPE_FLAG_VARARGS): Remove from here.
	* gdbtypes.h (TYPE_FLAG_VARARGS): Add here and change value to
	not collide with other flag bits.
@
text
@d2885 2
a2886 1
  struct type *type;
a2889 9
      struct attribute *attr;
      struct type *xtype;

      xtype = die_type (die, objfile, cu_header);

      type = alloc_type (objfile);
      TYPE_CODE (type) = TYPE_CODE_TYPEDEF;
      TYPE_FLAGS (type) |= TYPE_FLAG_TARGET_STUB;
      TYPE_TARGET_TYPE (type) = xtype;
d2892 5
a2896 5
	TYPE_NAME (type) = obsavestring (DW_STRING (attr),
					 strlen (DW_STRING (attr)),
					 &objfile->type_obstack);

      die->type = type;
@


1.39
log
@Approved by Jim Blandy:

	2001-12-08  Fred Fish  <fnf@@redhat.com>
	* dwarf2read.c (read_base_type): Rename is_unsigned to type_flags.
	For unsigned types set TYPE_FLAG_UNSIGNED and pass it to
	init_type().
@
text
@a476 4
/* FIXME: Kludge to mark a varargs function type for C++ member function
   argument processing.  */
#define TYPE_FLAG_VARARGS	(1 << 10)

@


1.38
log
@        * gdbtypes.c (finish_cv_type): New function.
        (check_typedef): Remove ``register'' keyword from argument.
        Preserve const and volatile attributes across filling in
        opaque types.
        * gdbtypes.h (finish_cv_type): Add prototype.

        * hp-symtab-read.c (hpread_read_struct_type): Call finish_cv_type.
        * stabsread.c (read_struct_type): Likewise.
        * dwarf2read.c (read_structure_scope): Likewise.  Remove redundant
        assignment to die->type.
@
text
@d2942 1
a2942 1
      int is_unsigned = 0;
d2949 1
a2949 1
	  is_unsigned = 1;
d2953 1
a2953 1
	  is_unsigned = 1;
d2966 1
a2966 1
	  is_unsigned = 1;
d2973 1
a2973 1
      type = init_type (code, size, is_unsigned, DW_STRING (attr), objfile);
@


1.37
log
@* dwarf2cfi.c: New file.
* dwarf2cfi.h: New file.
* dwarf2read.c (dwarf_frame_offset, dwarf_frame_size): New variables.
(dwarf_eh_frame_offset, dwarf_eh_frame_size): New variables.
(dwarf2_read_section): Change to non static.
(dwarf2_locate_sections): Add .debug_frame and .eh_frame section
recognition.
(FRAME_SECTION, EH_FRAME_SECTION): New define.
* elfread.c (elf_symfile_read): Add call of frame informations build.
* frame.h (frame_info): Add pointer to unwind_context.
* symfile.h (dwarf2_build_frame_info): Add declaration.
* gdbarch.sh (DWARF2_BUILD_FRAME_INFO): Add.
* gdbarch.h, gdbarch.c: Regenerate.
* Makefile.in: Add dwarf2cfi_h, dwarf2cfi.o
* x86-64-tdep.c (i386_gdbarch_init): Initialize target vector to
use debug frame info.
@
text
@d2384 1
a2384 1
  die->type = type;
@


1.36
log
@* dwarf2read.c (read_attribute_value): New function to handle DW_FORM_indirect
(read_attribute): uses read_attribute_value
@
text
@d135 2
d146 2
d159 2
d596 1
a596 1
static char *dwarf2_read_section (struct objfile *, file_ptr, unsigned int);
d816 1
d875 10
d3065 1
a3065 1
static char *
@


1.35
log
@	* dwarf2read.c (dwarf_str_buffer): New.
	(struct dwarf2_pinfo): Add dwarf_str_buffer and dwarf_str_size.
	(DWARF_STR_BUFFER, DWARF_STR_SIZE): Define.
	(dwarf2_has_info): Clear dwarf_str_offset.
	(dwarf2_build_psymtabs): Read .debug_str section if present.
	(dwarf2_build_psymtabs_hard): Save DWARF_STR_BUFFER and
	DWARF_STR_SIZE.
	(psymtab_to_symtab_1): Restore DWARF_STR_BUFFER and DWARF_STR_SIZE.
	(read_attribute): Handle DW_FORM_strp.
	(read_n_bytes, read_string): Remove HOST_CHAR_BIT != 8
	handling code.
	(read_indirect_string): New.
	(dump_die): Handle DW_FORM_strp.
@
text
@d608 3
d3366 1
a3366 1
/* Read an attribute described by an abbreviated attribute.  */
d3369 1
a3369 1
read_attribute (struct attribute *attr, struct attr_abbrev *abbrev,
d3376 2
a3377 3
  attr->name = abbrev->name;
  attr->form = abbrev->form;
  switch (abbrev->form)
d3474 4
d3480 1
a3480 1
	     dwarf_form_name (abbrev->form));
d3485 11
d5645 5
a5649 1
	case DW_FORM_indirect:	/* we do not handle indirect yet */
@


1.34
log
@	* dwarf2read.c (dwarf_decode_lines): Properly deal with
	unknown standard opcodes.
@
text
@d46 1
d306 1
d388 8
d404 2
d631 3
d806 1
d885 7
d1097 2
d1398 2
d3414 5
a3470 1
    case DW_FORM_strp:
d3660 1
a3660 1
#if HOST_CHAR_BIT == 8
a3661 12
#else
  char *ret;
  unsigned int i;

  ret = obstack_alloc (&dwarf2_tmp_obstack, size);
  for (i = 0; i < size; ++i)
    {
      ret[i] = bfd_get_8 (abfd, (bfd_byte *) buf);
      buf++;
    }
  return ret;
#endif
d3670 1
a3670 1
#if HOST_CHAR_BIT == 8
d3678 9
a3686 3
#else
  int byte;
  unsigned int i = 0;
d3688 1
a3688 1
  while ((byte = bfd_get_8 (abfd, (bfd_byte *) buf)) != 0)
d3690 2
a3691 3
      obstack_1grow (&dwarf2_tmp_obstack, byte);
      i++;
      buf++;
d3693 1
a3693 1
  if (i == 0)
d3695 1
a3695 1
      *bytes_read_ptr = 1;
d3698 4
a3701 4
  obstack_1grow (&dwarf2_tmp_obstack, '\0');
  *bytes_read_ptr = i + 1;
  return obstack_finish (&dwarf2_tmp_obstack);
#endif
d5617 1
a5627 2
	case DW_FORM_strp:	/* we do not support separate string
				   section yet */
@


1.33
log
@	2001-11-06  Fred Fish  <fnf@@redhat.com>
	* complaints.c (info_verbose): Remove unneeded decl, is in defs.h.
	* dbxread.c: Ditto
	* dwarf2read.c: Ditto.
	* dwarfread.c: Ditto.
	* exec.c: Ditto.
	* hpread.c: Ditto.
	* hpread.h: Ditto.
	* mdebugread.c: Ditto.
	* os9kread.c: Ditto.
	* stack.c: Ditto.
	* symfile.c: Ditto.
	* tracepoint.c: Ditto.
@
text
@d3966 12
a3977 1
	  switch (op_code)
d4075 9
a4083 8
	    default:		/* special operand */
	      adj_opcode = op_code - lh.opcode_base;
	      address += (adj_opcode / lh.line_range)
		* lh.minimum_instruction_length;
	      line += lh.line_base + (adj_opcode % lh.line_range);
	      /* append row to matrix using current values */
	      record_line (current_subfile, line, address);
	      basic_block = 1;
@


1.32
log
@	* coffread.c: Replace all occurrences of bfd_read with bfd_bread.
	* dbxread.c: Likewise.
	* dwarf2read.c: Likewise.
	* dwarfread.c: Likewise.
	* somread.c: Likewise.
	* ultra3-nat.c: Likewise.
	* xcoffread.c: Likewise.
@
text
@a556 3
/* Externals references.  */
extern int info_verbose;	/* From main.c; nonzero => verbose */

@


1.31
log
@2001-09-04  Elena Zannoni  <ezannoni@@redhat.com>

	From Daniel Jacobowitz  <drow@@mvista.com>
	* dbxread.c (dbx_symfile_read): Only reinitialize
	the psymbol list if mainline or if both static
	and global lists are empty.
	* dwarf2read.c (dwarf2_build_psymtabs): Likewise.
	* dwarfread.c (dwarf_build_psymtabs): Likewise.
	* xcoffread.c (xcoff_initial_scan): Likewise.
	* os9kread.c (os9k_symfile_read): Likewise.
@
text
@d3033 1
a3033 1
      (bfd_read (buf, size, 1, abfd) != size))
@


1.30
log
@* dwarf2read.c (dwarf2_build_psymtabs_hard): Doc fix.
@
text
@d872 3
a874 2
  if (mainline || objfile->global_psymbols.size == 0 ||
      objfile->static_psymbols.size == 0)
@


1.29
log
@* dwarf2read (dwarf2_build_psymtabs_hard): Doc fix.
@
text
@d980 28
@


1.29.4.1
log
@2001-12-06  Elena Zannoni  <ezannoni@@redhat.com>

        From Jakub Jelinek  <jakub@@redhat.com>:

        * dwarf2read.c (dwarf_str_buffer): New.
        (struct dwarf2_pinfo): Add dwarf_str_buffer and dwarf_str_size.
        (DWARF_STR_BUFFER, DWARF_STR_SIZE): Define.
        (dwarf2_has_info): Clear dwarf_str_offset.
        (dwarf2_build_psymtabs): Read .debug_str section if present.
        (dwarf2_build_psymtabs_hard): Save DWARF_STR_BUFFER and
        DWARF_STR_SIZE.
        (psymtab_to_symtab_1): Restore DWARF_STR_BUFFER and DWARF_STR_SIZE.
        (read_attribute): Handle DW_FORM_strp.
        (read_n_bytes, read_string): Remove HOST_CHAR_BIT != 8
        handling code.
        (read_indirect_string): New.
        (dump_die): Handle DW_FORM_strp.
@
text
@a45 1
#include "gdb_assert.h"
a304 1
static char *dwarf_str_buffer;
a385 8

    /* Pointer to start of dwarf string buffer for the objfile.  */

    char *dwarf_str_buffer;

    /* Size of dwarf string section for the objfile.  */

    unsigned int dwarf_str_size;
a393 2
#define DWARF_STR_BUFFER(p)  (PST_PRIVATE(p)->dwarf_str_buffer)
#define DWARF_STR_SIZE(p)    (PST_PRIVATE(p)->dwarf_str_size)
a621 3
static char *read_indirect_string (bfd *, char *, const struct comp_unit_head *,
				   unsigned int *);

a793 1
  dwarf_str_offset = 0;
a870 6
  if (dwarf_str_offset)
    dwarf_str_buffer = dwarf2_read_section (objfile,
 					    dwarf_str_offset,
 					    dwarf_str_size);
  else
    dwarf_str_buffer = NULL;
a1047 2
      DWARF_STR_BUFFER (pst) = dwarf_str_buffer;
      DWARF_STR_SIZE (pst) = dwarf_str_size;
a1346 2
  dwarf_str_buffer = DWARF_STR_BUFFER (pst);
  dwarf_str_size = DWARF_STR_SIZE (pst);
a3360 5
    case DW_FORM_strp:
      DW_STRING (attr) = read_indirect_string (abfd, info_ptr, cu_header,
					       &bytes_read);
      info_ptr += bytes_read;
      break;
d3413 1
d3603 1
a3603 1
  gdb_assert (HOST_CHAR_BIT == 8);
d3605 12
d3625 1
a3625 1
  gdb_assert (HOST_CHAR_BIT == 8);
d3633 3
a3635 1
}
d3637 1
a3637 9
static char *
read_indirect_string (bfd *abfd, char *buf,
		      const struct comp_unit_head *cu_header,
		      unsigned int *bytes_read_ptr)
{
  LONGEST str_offset = read_offset (abfd, buf, cu_header,
				    (int *) bytes_read_ptr);

  if (dwarf_str_buffer == NULL)
d3639 3
a3641 2
      error ("DW_FORM_strp used without .debug_str section");
      return NULL;
d3643 1
a3643 1
  if (str_offset >= dwarf_str_size)
d3645 1
a3645 1
      error ("DW_FORM_strp pointing outside of .debug_str section");
d3648 4
a3651 4
  gdb_assert (HOST_CHAR_BIT == 8);
  if (dwarf_str_buffer[str_offset] == '\0')
    return NULL;
  return dwarf_str_buffer + str_offset;
a5554 1
	case DW_FORM_strp:
d5565 2
@


1.29.2.1
log
@Typesystem work initial import.
Note that this currently isn't building, i'm in the middle of converting make_function_type/lookup_function_type
@
text
@a10 1
   Largely rewritten by Daniel Berlin (dan@@cgsoftware.com)
a43 1
#include "frame.h"
d47 1
a47 1
#include <search.h>
d52 17
d73 2
a74 2
{
  unsigned int length;		/* length of the .debug_pubnames
d76 1
a76 1
  unsigned char version;	/* version number -- 2 for DWARF
d78 2
a79 2
  unsigned int info_offset;	/* offset into .debug_info section */
  unsigned int info_size;	/* byte size of .debug_info section
d81 1
a81 1
}
d89 2
a90 2
{
  unsigned int length;		/* byte len of the .debug_aranges
d92 1
a92 1
  unsigned short version;	/* version number -- 2 for DWARF
d94 4
a97 4
  unsigned int info_offset;	/* offset into .debug_info section */
  unsigned char addr_size;	/* byte size of an address */
  unsigned char seg_size;	/* byte size of segment descriptor */
}
d105 2
a106 2
{
  unsigned int total_length;	/* byte length of the statement
d108 1
a108 1
  unsigned short version;	/* version number -- 2 for DWARF
d110 3
a112 3
  unsigned int prologue_length;	/* # bytes between prologue &
				   stmt program */
  unsigned char minimum_instruction_length;	/* byte size of
d114 1
a114 1
  unsigned char default_is_stmt;	/* initial value of is_stmt
d116 3
a118 3
  char line_base;
  unsigned char line_range;
  unsigned char opcode_base;	/* number assigned to first special
d120 2
a121 2
  unsigned char *standard_opcode_lengths;
}
d126 17
a142 19
static file_ptr dwarf2_info_offset;
static file_ptr dwarf2_abbrev_offset;
static file_ptr dwarf2_line_offset;
static file_ptr dwarf2_pubnames_offset;
static file_ptr dwarf2_aranges_offset;
static file_ptr dwarf2_loc_offset;
static file_ptr dwarf2_macinfo_offset;
static file_ptr dwarf2_str_offset;
static file_ptr dwarf2_frame_offset;

static unsigned int dwarf2_info_size;
static unsigned int dwarf2_abbrev_size;
static unsigned int dwarf2_line_size;
static unsigned int dwarf2_pubnames_size;
static unsigned int dwarf2_aranges_size;
static unsigned int dwarf2_loc_size;
static unsigned int dwarf2_macinfo_size;
static unsigned int dwarf2_str_size;
static unsigned int dwarf2_frame_size;
a153 1
#define FRAME_SECTION    ".debug_frame"
d160 10
a169 10
{
  unsigned long length;
  short version;
  unsigned int abbrev_offset;
  unsigned char addr_size;
  unsigned char signed_addr_p;
  unsigned int offset_size;	/* size of file offsets; either 4 or 8 */
  unsigned int initial_length_size;	/* size of the length field; either
					   4 or 12 */
};
d173 11
a183 11
{
  unsigned int total_length;
  unsigned short version;
  unsigned int prologue_length;
  unsigned char minimum_instruction_length;
  unsigned char default_is_stmt;
  int line_base;
  unsigned char line_range;
  unsigned char opcode_base;
  unsigned char *standard_opcode_lengths;
};
d188 16
a203 15
{
  enum dwarf_tag tag;
  unsigned char has_children;
  unsigned char is_external;
  unsigned char is_declaration;
  unsigned char has_type;
  unsigned int offset;
  unsigned int abbrev;
  char *name;
  CORE_ADDR lowpc;
  CORE_ADDR highpc;
  struct dwarf2_block *locdesc;
  unsigned int language;
  char *sibling;
};
d207 8
a214 8
{
  unsigned int number;		/* number identifying abbrev */
  enum dwarf_tag tag;		/* dwarf tag */
  int has_children;		/* boolean */
  unsigned int num_attrs;	/* number of attributes */
  struct attr_abbrev *attrs;	/* an array of attribute descriptions */
  struct abbrev_info *next;	/* next in chain */
};
d217 4
a220 4
{
  enum dwarf_attribute name;
  enum dwarf_form form;
};
d224 11
a234 11
{
  enum dwarf_tag tag;		/* Tag indicating type of die */
  unsigned short has_children;	/* Does the die have children */
  unsigned int abbrev;		/* Abbrev number */
  unsigned int offset;		/* Offset in .debug_info section */
  unsigned int num_attrs;	/* Number of attributes */
  struct attribute *attrs;	/* An array of attributes */
  struct die_info *next_ref;	/* Next die in ref hash table */
  struct die_info *next;	/* Next die in linked list */
  struct type *type;		/* Cached type information */
};
a237 4
{
  enum dwarf_attribute name;
  enum dwarf_form form;
  union
d239 12
a250 8
    char *str;
    struct dwarf2_block *blk;
    unsigned long unsnd;
    long int snd;
    CORE_ADDR addr;
  }
  u;
};
d261 5
a265 11
struct dwarf2_block
{
  unsigned int size;
  char *data;
};
struct comp_unit_instance
{
  bfd *abfd;
  int offset;
  struct comp_unit_head cu_header;
  int cu_header_offset;
d267 2
a268 2
  /* We only hold one compilation unit's abbrevs in
     memory at any one time.  */
d276 1
a276 1
  struct abbrev_info *dwarf2_abbrevs[ABBREV_HASH_SIZE];
d278 1
a278 1
  /* A hash table of die offsets for following references.  */
d283 1
a283 1
  struct die_info *die_ref_table[REF_HASH_SIZE];
d285 2
d288 3
d292 1
a292 1
  /* Allocate fields for structs, unions and enums in this size.  */
d297 3
a299 3
  /* The language we are debugging.  */
  enum language cu_language;
  const struct language_defn *cu_language_defn;
d301 4
a304 6
  struct comp_unit_instance *next;
};

#ifndef COMP_UNIT_HASH_SIZE
#define COMP_UNIT_HASH_SIZE  121
#endif
d306 2
a307 8
static struct comp_unit_instance *compilation_units[COMP_UNIT_HASH_SIZE];

static struct obstack dwarf2_tmp_obstack;
/* Actually data from the sections.  */
static char *dwarf2_info_buffer;
static char *dwarf2_abbrev_buffer;
static char *dwarf2_line_buffer;
static char *dwarf2_frame_buffer;
d366 2
a367 2
{
  /* Pointer to start of dwarf info buffer for the objfile.  */
d369 1
a369 1
  char *dwarf2_info_buffer;
d371 1
a371 1
  /* Offset in dwarf2_info_buffer for this compilation unit. */
d373 1
a373 1
  unsigned long dwarf2_info_offset;
d375 1
a375 1
  /* Pointer to start of dwarf abbreviation buffer for the objfile.  */
d377 1
a377 1
  char *dwarf2_abbrev_buffer;
d379 1
a379 1
  /* Size of dwarf abbreviation section for the objfile.  */
d381 1
a381 1
  unsigned int dwarf2_abbrev_size;
d383 1
a383 1
  /* Pointer to start of dwarf line buffer for the objfile.  */
d385 2
a386 1
  char *dwarf2_line_buffer;
d388 6
a393 3
  char *dwarf2_frame_buffer;
 
};
a394 7
#define PST_PRIVATE(p) ((struct dwarf2_pinfo *)(p)->read_symtab_private)
#define DWARF2_INFO_BUFFER(p) (PST_PRIVATE(p)->dwarf2_info_buffer)
#define DWARF2_INFO_OFFSET(p) (PST_PRIVATE(p)->dwarf2_info_offset)
#define DWARF2_ABBREV_BUFFER(p) (PST_PRIVATE(p)->dwarf2_abbrev_buffer)
#define DWARF2_ABBREV_SIZE(p) (PST_PRIVATE(p)->dwarf2_abbrev_size)
#define DWARF2_FRAME_BUFFER(p) (PST_PRIVATE(p)->dwarf2_frame_buffer)
#define DWARF2_LINE_BUFFER(p) (PST_PRIVATE(p)->dwarf2_line_buffer)
a414 3
{
  /* List of data member and baseclasses fields. */
  struct nextfield
d416 9
a424 6
    struct nextfield *next;
    int accessibility;
    int virtuality;
    struct field field;
  }
   *fields;
d426 2
a427 2
  /* Number of fields.  */
  int nfields;
d429 2
a430 2
  /* Number of baseclasses.  */
  int nbaseclasses;
d432 2
a433 2
  /* Set if the accesibility of one of the fields is not public.  */
  int non_public_fields;
d435 8
a442 8
  /* Member function fields array, entries are allocated in the order they
     are encountered in the object file.  */
  struct nextfnfield
  {
    struct nextfnfield *next;
    struct fn_field fnfield;
  }
   *fnfields;
d444 10
a453 10
  /* Member function fieldlist array, contains name of possibly overloaded
     member function, number of overloaded member functions and a pointer
     to the head of the member function field chain.  */
  struct fnfieldlist
  {
    char *name;
    int length;
    struct nextfnfield *head;
  }
   *fnfieldlists;
d455 3
a457 3
  /* Number of entries in the fnfieldlists array.  */
  int nfnfields;
};
d472 2
a473 1
static struct complaint dwarf2_const_ignored = {
d476 2
a477 1
static struct complaint dwarf2_volatile_ignored = {
d480 2
a481 1
static struct complaint dwarf2_non_const_array_bound_ignored = {
d484 2
a485 1
static struct complaint dwarf2_missing_line_number_section = {
d488 2
a489 1
static struct complaint dwarf2_mangled_line_number_section = {
d492 2
a493 1
static struct complaint dwarf2_unsupported_die_ref_attr = {
d496 2
a497 1
static struct complaint dwarf2_unsupported_stack_op = {
d500 2
a501 1
static struct complaint dwarf2_complex_location_expr = {
d504 2
a505 1
static struct complaint dwarf2_unsupported_tag = {
d508 2
a509 1
static struct complaint dwarf2_unsupported_at_encoding = {
d512 2
a513 1
static struct complaint dwarf2_unsupported_at_frame_base = {
d516 2
a517 1
static struct complaint dwarf2_unexpected_tag = {
d520 2
a521 1
static struct complaint dwarf2_missing_at_frame_base = {
d524 2
a525 1
static struct complaint dwarf2_bad_static_member_name = {
d528 2
a529 1
static struct complaint dwarf2_unsupported_accessibility = {
d532 2
a533 1
static struct complaint dwarf2_bad_member_name_complaint = {
d536 2
a537 1
static struct complaint dwarf2_missing_member_fn_type_complaint = {
d540 2
a541 1
static struct complaint dwarf2_vtbl_not_found_complaint = {
d544 2
a545 1
static struct complaint dwarf2_absolute_sibling_complaint = {
d548 2
a549 1
static struct complaint dwarf2_const_value_length_mismatch = {
d552 2
a553 1
static struct complaint dwarf2_unsupported_const_value_attr = {
d564 1
d566 1
d572 1
a572 1
				   const struct comp_unit_instance *);
d575 1
a575 1
				const struct comp_unit_instance *);
d583 1
a583 2
static void dwarf2_read_abbrevs (bfd *, struct comp_unit_instance *,
				 unsigned int);
d587 1
a587 3
static struct abbrev_info *dwarf2_lookup_abbrev (unsigned int,
						 const struct
						 comp_unit_instance *);
d590 2
a591 2
			       bfd *, char *, int *,
			       const struct comp_unit_instance *);
d594 1
a594 1
			    const struct comp_unit_instance *);
d597 1
a597 2
			     bfd *, char *,
			     const struct comp_unit_instance *);
d609 1
a609 2
static CORE_ADDR read_address (bfd *, char *ptr,
			       const struct comp_unit_instance *,
d613 1
a613 1
				    struct comp_unit_head *, int *bytes_read);
d616 1
a616 1
			    int *bytes_read);
d626 1
a626 1
static void set_cu_language (struct comp_unit_instance *, unsigned int);
d628 1
a628 2
static struct attribute *dwarf2_attr (struct die_info *, unsigned int,
				     const struct comp_unit_instance *);
d630 1
a630 2
static int die_is_declaration (struct die_info *,
			       const struct comp_unit_instance *);
d632 2
a633 2
static void dwarf2_decode_lines (unsigned int, char *, bfd *,
				const struct comp_unit_instance *);
d638 1
a638 2
				  struct objfile *,
				  const struct comp_unit_instance *);
d641 1
a641 2
				struct objfile *,
				const struct comp_unit_instance *);
d644 2
a645 1
				     struct symbol *sym, int bits);
d648 1
a648 1
			      const struct comp_unit_instance *);
d651 5
a655 1
					 const struct comp_unit_instance *);
d658 1
a658 1
				      const struct comp_unit_instance *);
d661 1
a661 1
			   const struct comp_unit_instance *);
d664 1
a664 1
			  const struct comp_unit_instance *);
d666 1
a666 2
static void read_base_type (struct die_info *, struct objfile *,
			    const struct comp_unit_instance *);
d669 1
a669 1
			     const struct comp_unit_instance *);
d672 1
a672 1
			     const struct comp_unit_instance *);
d675 1
a675 1
				      const struct comp_unit_instance *);
d678 1
a678 2
				 CORE_ADDR *, CORE_ADDR *, struct objfile *,
				 const struct comp_unit_instance *);
d681 1
a681 2
			      struct objfile *,
			      const struct comp_unit_instance *);
d689 1
a689 1
				  const struct comp_unit_instance *);
d695 1
a695 1
				  const struct comp_unit_instance *, const char *);
d698 1
a698 1
			       const struct comp_unit_instance *);
d701 1
a701 1
			      const struct comp_unit_instance *);
d703 1
a703 2
static struct type *dwarf2_base_type (int, int, struct objfile *,
				     const struct comp_unit_instance *);
d705 2
a706 2
static CORE_ADDR decode_locdesc (struct dwarf2_block *, struct objfile *,
				 const struct comp_unit_instance *);
d709 1
a709 1
			     const struct comp_unit_instance *);
d712 1
a712 1
				   const struct comp_unit_instance *);
d715 1
a715 1
					 const struct comp_unit_instance *);
d718 1
a718 1
				     const struct comp_unit_instance *);
d721 1
a721 1
				 const struct comp_unit_instance *);
d724 1
a724 1
				    const struct comp_unit_instance *);
d726 1
a726 2
static void read_tag_string_type (struct die_info *, struct objfile *,
				  const struct comp_unit_instance *);
d729 1
a729 1
				  const struct comp_unit_instance *);
d731 2
a732 2
struct die_info *read_comp_unit_dies (char *, bfd *,
				      const struct comp_unit_instance *);
d738 2
a739 1
static struct comp_unit_instance *dwarf2_get_cu_by_offset (bfd *, int);
d741 1
a741 1
static struct comp_unit_instance *dwarf2_get_comp_unit (bfd *, int);
d743 1
a743 1
static struct comp_unit_instance *dwarf2_get_or_read_comp_unit (bfd *, int);
d745 1
a745 1
static struct comp_unit_instance *dwarf2_read_comp_unit (bfd *, int);
d747 1
a747 2
static void process_die (struct die_info *, struct objfile *,
			 const struct comp_unit_instance *);
d749 1
a749 2
static char *dwarf2_linkage_name (struct die_info *,
				  const struct comp_unit_instance *);
d751 1
a751 1
static char *dwarf2_tag_name (unsigned int);
d753 1
a753 1
static char *dwarf2_attr_name (unsigned int);
d755 2
a756 1
static char *dwarf2_form_name (unsigned int);
d758 2
a759 1
static char *dwarf2_stack_op_name (unsigned int);
d761 1
a761 1
static char *dwarf2_bool_name (unsigned int);
d763 1
a763 1
static char *dwarf2_type_encoding_name (unsigned int);
d765 1
a765 1
struct die_info *sibling_die (struct die_info *);
d767 1
a767 1
void dump_die (struct die_info *, const struct comp_unit_instance *);
d769 1
a769 2
void store_in_ref_table (unsigned int, struct die_info *,
			 struct comp_unit_instance *);
d771 1
a771 1
static void dwarf2_empty_hash_tables (struct comp_unit_instance *);
d773 1
a773 2
static unsigned int dwarf2_get_ref_die_offset (const struct comp_unit_instance
					       *, struct attribute *);
d775 1
a775 6
struct die_info *follow_die_ref (unsigned int,
				 const struct comp_unit_instance *);

static struct type *dwarf2_fundamental_type (struct objfile *, int,
					     const struct comp_unit_instance
					     *);
d781 1
a781 3
static struct dwarf2_block *dwarf2_alloc_block (void);

static struct abbrev_info *dwarf2_alloc_abbrev (void);
d783 1
a783 1
static struct die_info *dwarf2_alloc_die (void);
d785 1
a785 3
static struct comp_unit_instance *dwarf2_alloc_comp_unit_instance (void);

static void dwarf2_read_frame_info (struct objfile *);
d791 1
a791 1
dwarf2_has_info (bfd * abfd)
d793 1
a793 1
  dwarf2_info_offset = dwarf2_abbrev_offset = dwarf2_line_offset = 0;
d795 1
a795 1
  if (dwarf2_info_offset && dwarf2_abbrev_offset)
d810 1
a810 1
dwarf2_locate_sections (bfd * ignore_abfd, asection * sectp, PTR ignore_ptr)
d814 2
a815 2
      dwarf2_info_offset = sectp->filepos;
      dwarf2_info_size = bfd_get_section_size_before_reloc (sectp);
d819 2
a820 2
      dwarf2_abbrev_offset = sectp->filepos;
      dwarf2_abbrev_size = bfd_get_section_size_before_reloc (sectp);
d824 2
a825 2
      dwarf2_line_offset = sectp->filepos;
      dwarf2_line_size = bfd_get_section_size_before_reloc (sectp);
d829 2
a830 2
      dwarf2_pubnames_offset = sectp->filepos;
      dwarf2_pubnames_size = bfd_get_section_size_before_reloc (sectp);
d834 2
a835 2
      dwarf2_aranges_offset = sectp->filepos;
      dwarf2_aranges_size = bfd_get_section_size_before_reloc (sectp);
d839 2
a840 2
      dwarf2_loc_offset = sectp->filepos;
      dwarf2_loc_size = bfd_get_section_size_before_reloc (sectp);
d844 2
a845 2
      dwarf2_macinfo_offset = sectp->filepos;
      dwarf2_macinfo_size = bfd_get_section_size_before_reloc (sectp);
d849 2
a850 7
      dwarf2_str_offset = sectp->filepos;
      dwarf2_str_size = bfd_get_section_size_before_reloc (sectp);
    }
  else if (STREQ (sectp->name, FRAME_SECTION))
    {
      dwarf2_frame_offset = sectp->filepos;
      dwarf2_frame_size = bfd_get_section_size_before_reloc (sectp);
d859 1
d862 10
a871 13
  dwarf2_info_buffer = dwarf2_read_section (objfile,
					   dwarf2_info_offset,
					   dwarf2_info_size);
  dwarf2_abbrev_buffer = dwarf2_read_section (objfile,
					     dwarf2_abbrev_offset,
					     dwarf2_abbrev_size);
  dwarf2_line_buffer = dwarf2_read_section (objfile,
					   dwarf2_line_offset,
					   dwarf2_line_size);
  dwarf2_frame_buffer = dwarf2_read_section (objfile,
					    dwarf2_frame_offset,
					    dwarf2_frame_size);
  dwarf2_read_frame_info (objfile);
d878 2
a879 1
  if (dwarf2_aranges_offset && dwarf2_pubnames_offset)
a885 1
#if 0
d887 1
a889 1
#endif
a891 1
#if 0
a892 1
#endif
d895 1
a895 2
char *aranges_buffer, *pubnames_buffer;

a898 42
static char * 
get_pubname_for_offset (bfd *abfd, int looking_for_offset, const struct comp_unit_instance *cui)
{
  char  *pubnames_ptr;
  unsigned int entry_length, version, info_offset, info_size;
  pubnames_ptr = pubnames_buffer;
  while ((pubnames_ptr - pubnames_buffer) < dwarf2_pubnames_size)
    {
      struct comp_unit_head cu_header;
      int bytes_read;
      unsigned char *data;
      unsigned long offset;

      entry_length = read_4_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 4;
      version = read_2_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 2;
      info_offset = read_4_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 4;
      info_size = read_4_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 4;
      data = pubnames_ptr;

      do
	{
	  offset = read_4_bytes (abfd, pubnames_ptr);
	  if (offset != 0)
	    {
	      pubnames_ptr += 4;
	      data = pubnames_ptr;
	      pubnames_ptr += strlen ((char *) data) + 1;
	      if (cui->offset == info_offset && offset == looking_for_offset-1)
	      {
		      return data;
	      }
	    }
	}
      while (offset != 0);
    }
  return NULL;
}

d903 1
d908 2
a909 2
					 dwarf2_pubnames_offset,
					 dwarf2_pubnames_size);
d911 1
a911 1
  while ((pubnames_ptr - pubnames_buffer) < dwarf2_pubnames_size)
a914 2
      unsigned char *data;
      unsigned long offset;
d916 5
a920 4
      entry_length = read_4_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 4;
      version = read_2_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 2;
a924 15
      data = pubnames_ptr;

      do
	{
	  offset = read_4_bytes (abfd, pubnames_ptr);
	  if (offset != 0)
	    {
	      pubnames_ptr += 4;
	      data = pubnames_ptr;
	      pubnames_ptr += strlen ((char *) data) + 1;
	    }
	}
      while (offset != 0);


d928 3
a930 2
					dwarf2_aranges_offset,
					dwarf2_aranges_size);
d932 1
d939 1
a939 1
		     char *info_ptr, bfd * abfd)
d944 1
a944 1
					   &bytes_read);
d949 1
a949 1
					  &bytes_read);
a959 75
static struct comp_unit_instance *
dwarf2_get_cu_by_offset (bfd * abfd, int offset)
{
  int i;
  struct comp_unit_instance *cui;

  for (i = 0; i < COMP_UNIT_HASH_SIZE; i++)
    {
      cui = compilation_units[i];
      while (cui)
	{
	  if (offset >= cui->offset
	      && offset <= (cui->offset + cui->cu_header.length))
	    {
	      if (cui->abfd == abfd)
		return cui;
	    }
	  cui = cui->next;
	}
    }
  return NULL;
}
static struct comp_unit_instance *
dwarf2_get_comp_unit (bfd * abfd, int offset)
{
  struct comp_unit_instance *cui;
  int h;

  h = (offset % COMP_UNIT_HASH_SIZE);
  cui = compilation_units[h];
  while (cui)
    {
      if (cui->offset == offset && cui->abfd == abfd)
	{
	  return cui;
	}
      cui = cui->next;
    }
  return NULL;
}
static struct comp_unit_instance *
dwarf2_get_or_read_comp_unit (bfd * abfd, int offset)
{
  struct comp_unit_instance *cui;
  cui = dwarf2_get_comp_unit (abfd, offset);
  if (cui != NULL)
    return cui;
  cui = dwarf2_read_comp_unit (abfd, offset);
  return cui;
}

static struct comp_unit_instance *
dwarf2_read_comp_unit (bfd * abfd, int offset)
{
  int h;
  char *info_ptr;
  struct comp_unit_instance *cui = dwarf2_alloc_comp_unit_instance ();
  h = (offset % COMP_UNIT_HASH_SIZE);
  cui->next = compilation_units[h];
  compilation_units[h] = cui;

  info_ptr = dwarf2_info_buffer + offset;
  cui->offset = offset;
  cui->abfd = abfd;

  /* read in the comp_unit header  */
  info_ptr = read_comp_unit_head (&cui->cu_header, info_ptr, abfd);

  /* Read the abbrevs for this compilation unit  */
  dwarf2_read_abbrevs (abfd, cui, cui->cu_header.abbrev_offset);
//  make_cleanup (dwarf2_empty_abbrev_table, cui);

  return cui;

}
a974 1
  int comp_unit_has_pc_info;
d976 4
a979 4
  struct comp_unit_instance *cui;
  int i;
  info_ptr = dwarf2_info_buffer;
  abbrev_ptr = dwarf2_abbrev_buffer;
d983 14
a996 16
#if 0
  while ((unsigned int) (info_ptr - dwarf2_info_buffer)
	 + ((info_ptr - dwarf2_info_buffer) % 4) < dwarf2_info_size)
    {
      beg_of_comp_unit = info_ptr;
      cui =
	dwarf2_get_or_read_comp_unit (abfd,
				      beg_of_comp_unit - dwarf2_info_buffer);
      info_ptr =
	beg_of_comp_unit + cui->cu_header.length +
	cui->cu_header.initial_length_size;
    }
  info_ptr = dwarf2_info_buffer;
#endif
  while ((unsigned int) (info_ptr - dwarf2_info_buffer)
	 + ((info_ptr - dwarf2_info_buffer) % 4) < dwarf2_info_size)
a999 3
      cui =
	dwarf2_get_or_read_comp_unit (abfd,
				      beg_of_comp_unit - dwarf2_info_buffer);
d1002 1
a1002 1
      if (cui->cu_header.version != 2)
d1007 1
a1007 1
      if (cui->cu_header.abbrev_offset >= dwarf2_abbrev_size)
d1009 3
a1011 4
	  error
	    ("Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6).",
	     (long) cui->cu_header.abbrev_offset,
	     (long) (beg_of_comp_unit - dwarf2_info_buffer));
d1014 2
a1015 2
      if (beg_of_comp_unit + cui->cu_header.length + cui->cu_header.initial_length_size
	  > dwarf2_info_buffer + dwarf2_info_size)
d1017 3
a1019 4
	  error
	    ("Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0).",
	     (long) cui->cu_header.length,
	     (long) (beg_of_comp_unit - dwarf2_info_buffer));
d1022 4
d1028 1
a1028 1
				   &comp_unit_has_pc_info, cui);
d1031 1
a1031 1
      set_cu_language (cui, comp_unit_die.language);
d1035 2
a1036 2
				  comp_unit_die.name ? comp_unit_die.
				  name : "", comp_unit_die.lowpc,
d1041 7
a1047 9
	obstack_alloc (&objfile->psymbol_obstack,
		       sizeof (struct dwarf2_pinfo));
      cui->cu_header_offset = beg_of_comp_unit - dwarf2_info_buffer;
      DWARF2_INFO_BUFFER (pst) = dwarf2_info_buffer;
      DWARF2_INFO_OFFSET (pst) = beg_of_comp_unit - dwarf2_info_buffer;
      DWARF2_ABBREV_BUFFER (pst) = dwarf2_abbrev_buffer;
      DWARF2_ABBREV_SIZE (pst) = dwarf2_abbrev_size;
      DWARF2_LINE_BUFFER (pst) = dwarf2_line_buffer;
      DWARF2_FRAME_BUFFER (pst) = dwarf2_frame_buffer;
d1059 2
a1060 1
					   cui);
d1063 1
a1063 1
	  if (!comp_unit_has_pc_info)
d1083 2
a1084 2
      info_ptr = beg_of_comp_unit + cui->cu_header.length
	+ cui->cu_header.initial_length_size;
d1093 2
a1094 2
		      CORE_ADDR * lowpc, CORE_ADDR * highpc,
		      const struct comp_unit_instance *cui)
a1105 1
  int has_pc_info;
d1107 1
a1107 1
  *lowpc = ((CORE_ADDR) - 1);
d1112 1
a1112 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, &has_pc_info, cui);
d1119 1
a1119 1
	      if (has_pc_info)
d1132 1
a1132 1
		      add_partial_symbol (&pdi, objfile, cui);
d1145 1
a1145 1
		  add_partial_symbol (&pdi, objfile, cui);
d1152 1
a1152 1
		add_partial_symbol (&pdi, objfile, cui);
d1158 1
a1158 1
		add_partial_symbol (&pdi, objfile, cui);
d1187 1
a1187 1
  if (*lowpc == ((CORE_ADDR) - 1))
d1194 1
a1194 1
		    const struct comp_unit_instance *cui)
d1208 1
a1208 2
			       0, pdi->lowpc + baseaddr, cui->cu_language,
			       objfile);
d1217 1
a1217 2
			       0, pdi->lowpc + baseaddr, cui->cu_language,
			       objfile);
d1237 1
a1237 1
	    addr = decode_locdesc (pdi->locdesc, objfile, cui);
d1242 1
a1242 2
				 0, addr + baseaddr, cui->cu_language,
				 objfile);
d1249 1
a1249 1
	  addr = decode_locdesc (pdi->locdesc, objfile, cui);
d1255 1
a1255 1
			       0, addr + baseaddr, cui->cu_language, objfile);
d1263 1
a1263 1
			   0, (CORE_ADDR) 0, cui->cu_language, objfile);
d1276 1
a1276 1
			   0, (CORE_ADDR) 0, cui->cu_language, objfile);
d1278 1
a1278 1
      if (cui->cu_language == language_cplus)
d1284 1
a1284 1
			       0, (CORE_ADDR) 0, cui->cu_language, objfile);
d1291 1
a1291 1
			   0, (CORE_ADDR) 0, cui->cu_language, objfile);
d1332 1
a1332 1
  struct comp_unit_instance *cui;
d1340 1
a1340 1
  int i = 0;
d1342 5
a1346 6
  offset = DWARF2_INFO_OFFSET (pst);
  dwarf2_info_buffer = DWARF2_INFO_BUFFER (pst);
  dwarf2_abbrev_buffer = DWARF2_ABBREV_BUFFER (pst);
  dwarf2_abbrev_size = DWARF2_ABBREV_SIZE (pst);
  dwarf2_line_buffer = DWARF2_LINE_BUFFER (pst);
  dwarf2_frame_buffer = DWARF2_FRAME_BUFFER (pst);
d1348 2
a1349 3
  cui = dwarf2_get_or_read_comp_unit (abfd, offset);
  cui->cu_header_offset = offset;
  info_ptr = dwarf2_info_buffer + offset;
d1357 8
a1364 3
  /* read in the comp_unit header, again, because we don't know it's size */
  info_ptr = read_comp_unit_head (&cui->cu_header, info_ptr, abfd);
  dies = read_comp_unit_dies (info_ptr, abfd, cui);
d1369 1
a1369 1
  process_die (dies, objfile, cui);
d1371 1
a1371 1
  if (!dwarf2_get_pc_bounds (dies, &lowpc, &highpc, objfile, cui))
d1386 1
a1386 2
		  if (dwarf2_get_pc_bounds
		      (child_die, &low, &high, objfile, cui))
d1401 1
a1401 1
      && !(cui->cu_language == language_c && symtab->language != language_c))
d1403 1
a1403 1
      symtab->language = cui->cu_language;
d1407 2
a1408 5
  sort_symtab_syms (symtab);
  xfree (dwarf2_info_buffer);
  xfree (dwarf2_abbrev_buffer);
  xfree (dwarf2_line_buffer);
  xfree (dwarf2_frame_buffer);
d1416 1
a1416 1
	     const struct comp_unit_instance *cui)
d1423 1
a1423 1
      read_file_scope (die, objfile, cui);
d1426 2
a1427 2
      read_subroutine_type (die, objfile, cui);
      read_func_scope (die, objfile, cui);
d1430 3
a1432 3
   /*   DJB - handled now  */
      read_subroutine_type (die, objfile, cui);
      read_func_scope (die, objfile, cui);
d1435 1
a1435 1
      read_lexical_block_scope (die, objfile, cui);
d1440 1
a1440 1
      read_structure_scope (die, objfile, cui, NULL);
d1443 1
a1443 1
      read_enumeration (die, objfile, cui);
d1446 1
a1446 1
      read_subroutine_type (die, objfile, cui);
d1449 1
a1449 1
      read_array_type (die, objfile, cui);
d1452 1
a1452 1
      read_tag_pointer_type (die, objfile, cui);
d1455 1
a1455 1
      read_tag_ptr_to_member_type (die, objfile, cui);
d1458 1
a1458 1
      read_tag_reference_type (die, objfile, cui);
d1461 1
a1461 1
      read_tag_string_type (die, objfile, cui);
d1464 2
a1465 2
      read_base_type (die, objfile, cui);
      if (dwarf2_attr (die, DW_AT_name, cui))
d1468 1
a1468 1
	  new_symbol (die, die->type, objfile, cui);
d1472 1
a1472 1
      read_common_block (die, objfile, cui);
d1477 1
a1477 1
      new_symbol (die, NULL, objfile, cui);
d1484 1
a1484 1
		 const struct comp_unit_instance *cui)
d1487 1
a1487 1
  CORE_ADDR lowpc = ((CORE_ADDR) - 1);
d1495 1
a1495 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cui))
d1506 1
a1506 2
		  if (dwarf2_get_pc_bounds
		      (child_die, &low, &high, objfile, cui))
d1519 1
a1519 1
  if (lowpc == ((CORE_ADDR) - 1))
d1524 1
a1524 1
  attr = dwarf2_attr (die, DW_AT_name, cui);
d1529 1
a1529 1
  attr = dwarf2_attr (die, DW_AT_comp_dir, cui);
d1544 2
a1545 1
  if (objfile->ei.entry_point >= lowpc && objfile->ei.entry_point < highpc)
d1551 1
a1551 1
  attr = dwarf2_attr (die, DW_AT_language, cui);
d1554 1
a1554 1
      set_cu_language ((struct comp_unit_instance *) cui, DW_UNSND (attr));
d1575 1
a1575 1
  attr = dwarf2_attr (die, DW_AT_stmt_list, cui);
d1579 1
a1579 1
      dwarf2_decode_lines (line_offset, comp_dir, abfd, cui);
d1588 1
a1588 1
	  process_die (child_die, objfile, cui);
d1596 1
a1596 1
		 const struct comp_unit_instance *cui)
d1604 2
a1605 3
  struct dwarf2_block *d2loc;
  void *data;
  name = dwarf2_linkage_name (die, cui);
d1609 1
a1609 2
  if (name == NULL
      || !dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cui))
d1615 2
a1616 1
  if (objfile->ei.entry_point >= lowpc && objfile->ei.entry_point < highpc)
d1626 1
a1626 1
  attr = dwarf2_attr (die, DW_AT_frame_base, cui);
d1629 1
a1629 1
      CORE_ADDR addr = decode_locdesc (DW_BLOCK (attr), objfile, cui);
d1644 1
a1644 16
  new->name = new_symbol (die, die->type, objfile, cui);
  if (attr)
    {
#if 0
	    SYMBOL_FRAME_LOC_EXPR (new->name) = obstack_alloc (&objfile->symbol_obstack, sizeof (struct dwarf2_block));
      d2loc = SYMBOL_FRAME_LOC_EXPR (new->name);
      memset (d2loc, 0, DW_BLOCK (attr)->size);
      d2loc->size = DW_BLOCK (attr)->size;
      d2loc->data = xmalloc (DW_BLOCK (attr)->size);
      memset (d2loc->data, 0, DW_BLOCK (attr)->size);
      memcpy (d2loc->data, DW_BLOCK (attr)->data, DW_BLOCK (attr)->size);
      data = d2loc->data;
      d2loc->data = bcache (data, DW_BLOCK (attr)->size, &objfile->psymbol_cache);
      xfree (data);
#endif
    }
d1652 1
a1652 1
	  process_die (child_die, objfile, cui);
d1669 1
a1669 1
			  const struct comp_unit_instance *cui)
d1676 1
a1676 1
  if (!dwarf2_get_pc_bounds (die, &lowpc, &highpc, objfile, cui))
d1687 1
a1687 1
	  process_die (child_die, objfile, cui);
d1705 2
a1706 3
dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR * lowpc,
		      CORE_ADDR * highpc, struct objfile *objfile,
		      const struct comp_unit_instance *cui)
d1712 1
a1712 1
  attr = dwarf2_attr (die, DW_AT_low_pc, cui);
d1717 1
a1717 1
  attr = dwarf2_attr (die, DW_AT_high_pc, cui);
d1747 1
a1747 1
		  const struct comp_unit_instance *cui)
d1771 1
a1771 1
  attr = dwarf2_attr (die, DW_AT_accessibility, cui);
d1776 1
a1776 1
  attr = dwarf2_attr (die, DW_AT_virtuality, cui);
d1784 1
a1784 1
      fp->type = die_type (die, objfile, cui);
d1787 1
a1787 1
      attr = dwarf2_attr (die, DW_AT_bit_size, cui);
d1798 1
a1798 1
      attr = dwarf2_attr (die, DW_AT_data_member_location, cui);
d1802 1
a1802 1
	    decode_locdesc (DW_BLOCK (attr), objfile, cui) * bits_per_byte;
d1806 1
a1806 1
      attr = dwarf2_attr (die, DW_AT_bit_offset, cui);
d1829 1
a1829 1
	      attr = dwarf2_attr (die, DW_AT_byte_size, cui);
d1851 1
a1851 1
      attr = dwarf2_attr (die, DW_AT_name, cui);
d1854 2
a1855 5
      fp->name =		/*obsavestring (fieldname, strlen (fieldname),
				   &objfile->type_obstack); */ bcache (fieldname,
					       strlen (fieldname) + 1, &objfile->
					       psymbol_cache);

d1859 1
a1859 1
      if (dwarf2_attr (die, DW_AT_artificial, cui))
d1870 2
a1871 2
         Get name of field.  */
      attr = dwarf2_attr (die, DW_AT_name, cui);
d1878 1
a1878 1
      physname = dwarf2_linkage_name (die, cui);
d1880 5
a1884 7
      SET_FIELD_PHYSNAME (*fp, bcache (physname, strlen (physname) + 1, &objfile->psymbol_cache)	/*obsavestring (physname, strlen (physname),
													   &objfile->type_obstack) */ );
      FIELD_TYPE (*fp) = die_type (die, objfile, cui);
      FIELD_NAME (*fp) =	/*obsavestring (fieldname, strlen (fieldname),
				   &objfile->type_obstack); */ bcache (physname,
					       strlen (physname) + 1, &objfile->
					       psymbol_cache);
d1889 1
a1889 1
      attr = dwarf2_attr (die, DW_AT_data_member_location, cui);
d1891 1
a1891 1
	FIELD_BITPOS (*fp) = (decode_locdesc (DW_BLOCK (attr), objfile, cui)
d1894 2
a1895 2
      FIELD_TYPE (*fp) = die_type (die, objfile, cui);
      FIELD_NAME (*fp) = xstrdup(type_name_no_tag (fp->type));
d1992 1
a1992 1
		      const struct comp_unit_instance *cui)
d2003 1
a2003 1
  attr = dwarf2_attr (die, DW_AT_name, cui);
d2010 1
a2010 1
  physname = dwarf2_linkage_name (die, cui);
d2034 1
a2034 1
      flp->name = bcache (fieldname, strlen(fieldname)+1, &objfile->psymbol_cache);
d2051 2
a2052 3
  fnp->physname =		/*obsavestring (physname, strlen (physname),
				   &objfile->type_obstack); */ bcache (physname, strlen (physname) + 1,
					   &objfile->psymbol_cache);
d2056 1
a2056 1
      struct type *return_type = FUNCTION_RETURN_VALUE (die->type);
d2058 1
a2058 1
      int nparams = FUNCTION_NUM_ARGUMENTS (die->type);
d2065 1
a2065 1
	arg_types[iparams] = FUNCTION_ARGUMENT_TYPE (die->type, iparams);
d2071 1
a2071 1
	arg_types[nparams] = dwarf2_fundamental_type (objfile, FT_VOID, cui);
d2088 2
a2089 2
  if (dwarf2_attr (die, DW_AT_containing_type, cui) != NULL)
    fnp->fcontext = die_containing_type (die, objfile, cui);
d2095 1
a2095 1
  attr = dwarf2_attr (die, DW_AT_accessibility, cui);
d2110 1
a2110 1
  attr = dwarf2_attr (die, DW_AT_vtable_elem_location, cui);
d2112 1
a2112 1
    fnp->voffset = decode_locdesc (DW_BLOCK (attr), objfile, cui) + 2;
d2163 1
a2163 4
   suppresses creating a symbol table entry itself).  
 
   To handle naming of nested structure scopes, we prepend prefix to the name.
 */
d2167 1
a2167 1
		      const struct comp_unit_instance *cui, const char *prefix)
d2175 1
a2175 1
  attr = dwarf2_attr (die, DW_AT_name, cui);
d2178 3
a2180 18
      if (prefix != NULL)
      {
	      char *structname;
	      structname = xcalloc (strlen (DW_STRING (attr)) + strlen (prefix) + strlen("::") + 1, sizeof (char));
	      strcat (structname, prefix);
	      strcat (structname, "::");
	      strcat (structname, DW_STRING (attr));
	      TYPE_TAG_NAME (type) = bcache (structname, strlen (structname) + 1, &objfile->psymbol_cache);
	      xfree (structname);
      }
      else
      {
	      TYPE_TAG_NAME (type) =	/*obsavestring (DW_STRING (attr),
				   strlen (DW_STRING (attr)),
				   &objfile->type_obstack); */ bcache (DW_STRING (attr),
					       strlen (DW_STRING (attr)) + 1,
					       &objfile->psymbol_cache);
      }
d2198 1
a2198 1
  attr = dwarf2_attr (die, DW_AT_byte_size, cui);
d2213 1
a2213 3
  /* We cannot assume that a declaration is a stub. You can define and
     declare something in the same place. */ 
  if (die->has_children)
d2227 1
a2227 5
	      dwarf2_add_field (&fi, child_die, objfile, cui);
	    }
	  else if (child_die->tag == DW_TAG_structure_type)
	    {
	      read_structure_scope (child_die, objfile, cui, TYPE_TAG_NAME (type));
d2232 1
a2232 1
	      dwarf2_add_field (&fi, child_die, objfile, cui);
d2237 2
a2238 2
	      process_die (child_die, objfile, cui);
	      dwarf2_add_member_fn (&fi, child_die, type, objfile, cui);
d2243 1
a2243 1
	      dwarf2_add_field (&fi, child_die, objfile, cui);
d2247 1
a2247 1
	      process_die (child_die, objfile, cui);
d2263 1
a2263 1
	  if (dwarf2_attr (die, DW_AT_containing_type, cui) != NULL)
d2265 2
a2266 1
	      struct type *t = die_containing_type (die, objfile, cui);
d2271 1
a2271 1
		    { '_', 'v', 'p', 't', 'r', '\0' };
d2276 2
a2277 1
		       i >= TYPE_N_BASECLASSES (t); --i)
d2281 1
a2281 2
		      if (STREQN
			  (fieldname, vptr_name, strlen (vptr_name) - 1)
d2292 1
a2292 2
			      TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) :
			      "");
d2301 1
a2301 1
      new_symbol (die, type, objfile, cui);
d2325 1
a2325 1
		  const struct comp_unit_instance *cui)
d2338 1
a2338 1
  attr = dwarf2_attr (die, DW_AT_name, cui);
d2341 3
a2343 4
      TYPE_TAG_NAME (type) =	/*obsavestring (DW_STRING (attr), strlen (DW_STRING (attr))
				   &objfile->type_obstack); */
	bcache (DW_STRING (attr), strlen (DW_STRING (attr)) + 1,
		&objfile->psymbol_cache);
d2346 1
a2346 1
  attr = dwarf2_attr (die, DW_AT_byte_size, cui);
d2365 1
a2365 1
	      process_die (child_die, objfile, cui);
d2369 1
a2369 1
	      attr = dwarf2_attr (child_die, DW_AT_name, cui);
d2372 1
a2372 1
		  sym = new_symbol (child_die, type, objfile, cui);
a2404 1
#if TYPEFIX
a2406 1
#endif
d2409 1
a2409 1
  new_symbol (die, type, objfile, cui);
d2418 1
a2418 1
		 const struct comp_unit_instance *cui)
d2422 2
a2423 3
  struct type *element_type, *index_type;
  struct range_type *range_type;
  struct range_type **range_types = NULL;
d2434 1
a2434 1
  element_type = die_type (die, objfile, cui);
d2440 3
a2442 3
      index_type = dwarf2_fundamental_type (objfile, FT_INTEGER, cui);
      range_type = make_range_type (objfile, index_type, 0, -1);
      die->type = (struct type *)make_array_type (objfile, element_type, range_type);
d2457 1
a2457 1
	  if (cui->cu_language == language_fortran)
d2463 2
a2464 2
	  index_type = die_type (child_die, objfile, cui);
	  attr = dwarf2_attr (child_die, DW_AT_lower_bound, cui);
d2481 1
a2481 1
			    dwarf2_form_name (attr->form));
d2490 1
a2490 1
	  attr = dwarf2_attr (child_die, DW_AT_upper_bound, cui);
d2516 1
a2516 1
			    dwarf2_form_name (attr->form));
d2529 1
a2529 1
	      range_types = (struct range_type **)
d2531 1
a2531 1
			  * sizeof (struct range_type *));
d2535 1
a2535 2
	  range_types[ndim++] =
	    make_range_type (objfile, index_type, low, high);
d2544 1
a2544 1
    type = (struct type *)make_array_type (objfile, type, range_types[ndim]);
d2556 1
a2556 1
		   const struct comp_unit_instance *cui)
d2563 1
a2563 1
  attr = dwarf2_attr (die, DW_AT_location, cui);
d2566 1
a2566 1
      base = decode_locdesc (DW_BLOCK (attr), objfile, cui);
d2573 2
a2574 2
	  sym = new_symbol (child_die, NULL, objfile, cui);
	  attr = dwarf2_attr (child_die, DW_AT_data_member_location, cui);
d2578 1
a2578 1
		base + decode_locdesc (DW_BLOCK (attr), objfile, cui);
d2591 1
a2591 1
		       const struct comp_unit_instance *cui)
d2601 2
a2602 2
  type = lookup_pointer_type (die_type (die, objfile, cui));
  attr = dwarf2_attr (die, DW_AT_byte_size, cui);
d2609 1
a2609 1
      TYPE_LENGTH (type) = cui->cu_header.addr_size;
d2619 1
a2619 1
			     const struct comp_unit_instance *cui)
d2631 2
a2632 2
  to_type = die_type (die, objfile, cui);
  domain = die_containing_type (die, objfile, cui);
d2643 1
a2643 1
			 const struct comp_unit_instance *cui)
d2653 2
a2654 2
  type = lookup_reference_type (die_type (die, objfile, cui));
  attr = dwarf2_attr (die, DW_AT_byte_size, cui);
d2661 1
a2661 1
      TYPE_LENGTH (type) = cui->cu_header.addr_size;
d2668 1
a2668 1
		     const struct comp_unit_instance *cui)
d2677 1
a2677 1
  base_type = die_type (die, objfile, cui);
d2683 1
a2683 1
			const struct comp_unit_instance *cui)
d2692 1
a2692 1
  base_type = die_type (die, objfile, cui);
d2702 1
a2702 2
read_tag_string_type (struct die_info *die, struct objfile *objfile,
		      const struct comp_unit_instance *cui)
d2704 1
a2704 2
  struct type *type, *index_type, *char_type;
  struct range_type *range_type;
d2713 1
a2713 1
  attr = dwarf2_attr (die, DW_AT_string_length, cui);
d2722 4
a2725 5
  index_type = dwarf2_fundamental_type (objfile, FT_INTEGER, cui);
  range_type = make_range_type (objfile, index_type, 1, length);
/*  TYPEFIX : Is this still necessary?
    char_type = dwarf2_fundamental_type (objfile, FT_CHAR, cui);*/
  type = (struct type *)make_string_type (objfile, range_type);
d2742 1
a2742 1
		      const struct comp_unit_instance *cui)
a2743 1
#if TYPEFIX
d2750 1
d2752 2
a2753 2

  type = die_type (die, objfile, cui);
d2757 3
a2759 2
  attr = dwarf2_attr (die, DW_AT_prototyped, cui);
  if ((attr && (DW_UNSND (attr) != 0)) || cui->cu_language == language_cplus)
d2796 1
a2796 1
	      attr = dwarf2_attr (child_die, DW_AT_artificial, cui);
d2802 1
a2802 1
							   cui);
a2809 1
#endif
d2814 1
a2814 1
	      const struct comp_unit_instance *cui)
d2823 1
a2823 1
      xtype = die_type (die, objfile, cui);
d2829 1
a2829 1
      attr = dwarf2_attr (die, DW_AT_name, cui);
d2831 3
a2833 5
	TYPE_NAME (type) = /*obsavestring (DW_STRING (attr),
				   strlen (DW_STRING (attr)),
				   &objfile->type_obstack); */ bcache (DW_STRING (attr),
						 strlen (DW_STRING (attr)) + 1,
						 &objfile->psymbol_cache);
d2843 1
a2843 2
read_base_type (struct die_info *die, struct objfile *objfile,
		const struct comp_unit_instance *cui)
d2855 1
a2855 1
  attr = dwarf2_attr (die, DW_AT_encoding, cui);
d2860 1
a2860 1
  attr = dwarf2_attr (die, DW_AT_byte_size, cui);
d2865 1
a2865 1
  attr = dwarf2_attr (die, DW_AT_name, cui);
d2897 1
a2897 1
		    dwarf2_type_encoding_name (encoding));
d2900 1
d2902 1
a2902 4
	type = (struct type *)make_pointer_type (objfile, dwarf2_fundamental_type (objfile, FT_VOID, cui));
      else
	type = init_type (code, size, is_unsigned, DW_STRING (attr), objfile);

d2906 1
a2906 1
      type = dwarf2_base_type (encoding, size, objfile, cui);
d2913 3
a2915 3
struct die_info *
read_comp_unit_dies (char *info_ptr, bfd * abfd,
		     const struct comp_unit_instance *cui)
d2923 1
a2923 1
  dwarf2_empty_hash_tables ((struct comp_unit_instance *) cui);
d2930 1
a2930 1
      cur_ptr = read_full_die (&die, abfd, cur_ptr, cui);
d2943 1
a2943 2
      store_in_ref_table (die->offset, die,
			  (struct comp_unit_instance *) cui);
d2990 1
a2990 1
   object file specified by OBJFILE and return it.  */
d3001 2
a3002 1
  buf = (char *) xmalloc (size);
d3019 1
a3019 2
dwarf2_read_abbrevs (bfd * abfd, struct comp_unit_instance *cui,
		     unsigned int offset)
d3027 1
a3027 1
  dwarf2_empty_abbrev_table (cui);
d3029 1
a3029 1
  abbrev_ptr = dwarf2_abbrev_buffer + offset;
d3036 1
a3036 1
      cur_abbrev = dwarf2_alloc_abbrev ();
d3068 2
a3069 2
      cur_abbrev->next = cui->dwarf2_abbrevs[hash_number];
      cui->dwarf2_abbrevs[hash_number] = cur_abbrev;
d3078 2
a3079 2
      if ((unsigned int) (abbrev_ptr - dwarf2_abbrev_buffer)
	  >= dwarf2_abbrev_size)
d3083 1
a3083 1
      if (dwarf2_lookup_abbrev (abbrev_number, cui) != NULL)
d3092 1
a3092 1
dwarf2_empty_abbrev_table (PTR cu)
d3096 1
a3096 1
  struct comp_unit_instance *cui = (struct comp_unit_instance *) cu;
d3100 1
a3100 1
      abbrev = cui->dwarf2_abbrevs[i];
d3108 1
a3108 1
      cui->dwarf2_abbrevs[i] = NULL;
d3115 1
a3115 2
dwarf2_lookup_abbrev (unsigned int number,
		      const struct comp_unit_instance *cui)
a3118 2
  struct comp_unit_instance *cui_for_die;

d3121 1
a3121 1
  abbrev = cui->dwarf2_abbrevs[hash_number];
d3136 2
a3137 3
read_partial_die (struct partial_die_info *part_die, bfd * abfd,
		  char *info_ptr, int *has_pc_info,
		  const struct comp_unit_instance *cui)
d3147 1
a3147 3

  memset(part_die, 0, sizeof(struct partial_die_info));
  *has_pc_info = 0;
d3153 1
a3153 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cui);
d3158 1
a3158 1
  part_die->offset = info_ptr - dwarf2_info_buffer;
d3166 1
a3166 1
				 info_ptr, cui);
d3173 1
d3216 1
a3216 1
	      dwarf2_info_buffer + dwarf2_get_ref_die_offset (cui, &attr);
d3231 3
a3233 4
      part_die->name = get_pubname_for_offset (abfd, part_die->offset,  cui);
      spec_ptr =
	dwarf2_info_buffer + dwarf2_get_ref_die_offset (cui, &spec_attr);
      read_partial_die (&spec_die, abfd, spec_ptr, &dummy, cui);
d3236 1
a3236 2
	  if (part_die->name == NULL)
		  part_die->name = spec_die.name;
d3254 3
a3256 2
      && (part_die->lowpc != 0 || (bfd_get_file_flags (abfd) & HAS_RELOC)))
    *has_pc_info = 1;
d3264 2
a3265 2
read_full_die (struct die_info **diep, bfd * abfd, char *info_ptr,
	       const struct comp_unit_instance *cui)
d3271 1
a3271 1
  offset = info_ptr - dwarf2_info_buffer;
d3276 1
a3276 1
      die = dwarf2_alloc_die ();
d3284 1
a3284 1
  abbrev = dwarf2_lookup_abbrev (abbrev_number, cui);
d3289 1
a3289 1
  die = dwarf2_alloc_die ();
d3303 1
a3303 1
				 abfd, info_ptr, cui);
d3314 2
a3315 2
		bfd * abfd, char *info_ptr,
		const struct comp_unit_instance *cui)
d3318 1
a3318 1
  struct dwarf2_block *blk;
d3326 1
a3326 1
      DW_ADDR (attr) = read_address (abfd, info_ptr, cui, &bytes_read);
d3330 1
a3330 1
      blk = dwarf2_alloc_block ();
d3338 1
a3338 1
      blk = dwarf2_alloc_block ();
d3362 1
a3362 1
      blk = dwarf2_alloc_block ();
d3370 1
a3370 1
      blk = dwarf2_alloc_block ();
d3417 1
a3417 1
	     dwarf2_form_name (abbrev->form));
d3425 1
a3425 1
read_1_byte (bfd * abfd, char *buf)
d3431 1
a3431 1
read_1_signed_byte (bfd * abfd, char *buf)
d3437 1
a3437 1
read_2_bytes (bfd * abfd, char *buf)
d3443 1
a3443 1
read_2_signed_bytes (bfd * abfd, char *buf)
d3449 1
a3449 1
read_4_bytes (bfd * abfd, char *buf)
d3455 1
a3455 1
read_4_signed_bytes (bfd * abfd, char *buf)
d3461 1
a3461 1
read_8_bytes (bfd * abfd, char *buf)
d3467 1
a3467 1
read_address (bfd * abfd, char *buf, const struct comp_unit_instance *cui,
d3472 1
a3472 1
  if (cui->cu_header.signed_addr_p)
d3474 1
a3474 1
      switch (cui->cu_header.addr_size)
d3492 1
a3492 1
      switch (cui->cu_header.addr_size)
d3509 1
a3509 1
  *bytes_read = cui->cu_header.addr_size;
d3540 2
a3541 2
read_initial_length (bfd * abfd, char *buf, struct comp_unit_head *cu_header,
		     int *bytes_read)
d3567 1
a3567 1
  return retval;
d3574 2
a3575 2
read_offset (bfd * abfd, char *buf, const struct comp_unit_head *cu_header,
	     int *bytes_read)
d3590 2
a3591 1
      internal_error (__FILE__, __LINE__, "read_offset: bad switch");
d3594 1
a3594 1
  return retval;
d3598 1
a3598 1
read_n_bytes (bfd * abfd, char *buf, unsigned int size)
d3620 1
a3620 1
read_string (bfd * abfd, char *buf, unsigned int *bytes_read_ptr)
d3655 1
a3655 1
read_unsigned_leb128 (bfd * abfd, char *buf, unsigned int *bytes_read_ptr)
d3671 1
a3671 1
      result |= ((unsigned long) (byte & 127) << shift);
d3683 1
a3683 1
read_signed_leb128 (bfd * abfd, char *buf, unsigned int *bytes_read_ptr)
d3699 1
a3699 1
      result |= ((long) (byte & 127) << shift);
d3715 1
a3715 1
set_cu_language (struct comp_unit_instance *cui, unsigned int lang)
d3721 1
a3721 1
      cui->cu_language = language_c;
d3724 1
a3724 1
      cui->cu_language = language_cplus;
d3728 1
a3728 1
      cui->cu_language = language_fortran;
d3731 1
a3731 1
      cui->cu_language = language_asm;
d3734 1
a3734 1
      cui->cu_language = language_java;
d3742 1
a3742 1
      cui->cu_language = language_unknown;
d3745 1
a3745 1
  cui->cu_language_defn = language_def (cui->cu_language);
d3751 1
a3751 2
dwarf2_attr (struct die_info *die, unsigned int name,
	    const struct comp_unit_instance *cui)
d3759 1
d3761 1
a3761 1

d3769 2
a3770 1
	follow_die_ref (dwarf2_get_ref_die_offset (cui, spec), cui);
d3772 1
a3772 1
	return dwarf2_attr (ref_die, name, cui);
d3774 1
d3778 7
d3793 6
a3798 6
  {
    char *name;
    unsigned int dir;
    unsigned int time;
    unsigned int size;
  }
d3803 4
a3806 4
{
  unsigned int num_dirs;
  char **dirs;
};
d3809 2
a3810 2
dwarf2_decode_lines (unsigned int offset, char *comp_dir, bfd * abfd,
		    const struct comp_unit_instance *cui)
d3826 1
a3826 1
  if (dwarf2_line_buffer == NULL)
d3838 1
a3838 1
  line_ptr = dwarf2_line_buffer + offset;
d3846 1
a3846 2
  lh.prologue_length =
    read_offset (abfd, line_ptr, &cui->cu_header, &bytes_read);
d3958 1
a3958 1
		  address = read_address (abfd, line_ptr, cui, &bytes_read);
d4012 2
a4013 1
		  ? dirs.dirs[files.files[file - 1].dir - 1] : comp_dir));
d4025 5
a4029 5
	      /* Add to the address register of the state machine the
	         address increment value corresponding to special opcode
	         255.  Ie, this value is scaled by the minimum instruction
	         length since special opcode 255 would have scaled the
	         the increment.  */
d4106 1
a4106 1
	    const struct comp_unit_instance *cui)
d4114 1
a4114 1
  name = dwarf2_linkage_name (die, cui);
d4121 2
a4122 3
      SYMBOL_NAME (sym) =	/* obsavestring (name, strlen (name),
				   &objfile->symbol_obstack); */ bcache (name, strlen (name) + 1,
						 &objfile->psymbol_cache);
d4131 2
a4132 2
	SYMBOL_TYPE (sym) = die_type (die, objfile, cui);
      attr = dwarf2_attr (die, DW_AT_decl_line, cui);
d4144 1
a4144 1
      SYMBOL_LANGUAGE (sym) = cui->cu_language;
d4149 1
a4149 1
	  attr = dwarf2_attr (die, DW_AT_low_pc, cui);
a4155 1
	case DW_TAG_inlined_subroutine:
d4160 1
a4160 1
	  attr2 = dwarf2_attr (die, DW_AT_external, cui);
d4162 3
a4164 1
	    add_symbol_to_list (sym, &global_symbols);
d4166 3
a4168 1
	    add_symbol_to_list (sym, list_in_scope);
d4179 1
a4179 1
	  attr = dwarf2_attr (die, DW_AT_const_value, cui);
d4182 2
a4183 2
	      dwarf2_const_value (attr, sym, objfile, cui);
	      attr2 = dwarf2_attr (die, DW_AT_external, cui);
d4190 1
a4190 1
	  attr = dwarf2_attr (die, DW_AT_location, cui);
d4193 1
a4193 1
	      attr2 = dwarf2_attr (die, DW_AT_external, cui);
d4197 1
a4197 1
		    decode_locdesc (DW_BLOCK (attr), objfile, cui);
d4212 1
a4212 1
				  SYMBOL_SECTION (sym));
a4219 18
		  struct dwarf2_block *d2loc;
		  void *data;
#if 0
		  SYMBOL_LOC_EXPR (sym) =
		    obstack_alloc (&objfile->symbol_obstack, sizeof (struct dwarf2_block));
		  d2loc = SYMBOL_LOC_EXPR (sym);
		  memset (d2loc, 0, sizeof (struct dwarf2_block));
		  d2loc->size = DW_BLOCK (attr)->size;
		  d2loc->data = xmalloc (DW_BLOCK (attr)->size);
		  memset (d2loc->data, 0, DW_BLOCK (attr)->size);
		  memcpy (d2loc->data, DW_BLOCK (attr)->data,
			  DW_BLOCK (attr)->size);
		  data = d2loc->data;
		  d2loc->data =
		    bcache (data, DW_BLOCK (attr)->size,
			    &objfile->psymbol_cache);
		  xfree (data);
#endif
d4221 1
a4221 1
		    decode_locdesc (DW_BLOCK (attr), objfile, cui);
d4230 1
a4230 1
		      SYMBOL_VALUE (sym) =
d4246 2
a4247 2
			addr + ANOFFSET (objfile->section_offsets,
					 SYMBOL_SECTION (sym));
d4260 1
a4260 1
	      attr2 = dwarf2_attr (die, DW_AT_external, cui);
d4262 1
a4262 1
		  && dwarf2_attr (die, DW_AT_type, cui) != NULL)
d4270 1
a4270 1
	  attr = dwarf2_attr (die, DW_AT_location, cui);
a4272 16
	      struct dwarf2_block *d2loc;
	      void *data;
#if 0
	      SYMBOL_LOC_EXPR (sym) = obstack_alloc (&objfile->symbol_obstack, sizeof (struct dwarf2_block));
	      d2loc = SYMBOL_LOC_EXPR (sym);
	      memset (d2loc, 0, sizeof (struct dwarf2_block));
	      d2loc->size = DW_BLOCK (attr)->size;
	      d2loc->data = xmalloc (DW_BLOCK (attr)->size);
	      memset (d2loc->data, 0, DW_BLOCK (attr)->size);
	      memcpy (d2loc->data, DW_BLOCK (attr)->data,
		      DW_BLOCK (attr)->size);
	      data = d2loc->data;
	      d2loc->data =
		bcache (data, DW_BLOCK (attr)->size, &objfile->psymbol_cache);
	      xfree (data);
#endif
d4274 1
a4274 1
		decode_locdesc (DW_BLOCK (attr), objfile, cui);
d4278 1
a4278 1
		  SYMBOL_VALUE (sym) =
d4300 1
a4300 1
	  attr = dwarf2_attr (die, DW_AT_const_value, cui);
d4303 1
a4303 1
	      dwarf2_const_value (attr, sym, objfile, cui);
a4317 7
	  /* For nested structures, the tag name is the correct symbol name, and, if we don't already have a type name, the symbol name is the correct type name. */
	  if (TYPE_TAG_NAME (type) != NULL)
	    {
	      if (TYPE_NAME (type) == NULL && SYMBOL_NAME (sym) != NULL)
		      TYPE_NAME (type) = SYMBOL_NAME (sym);
	      SYMBOL_NAME (sym) = TYPE_TAG_NAME (type);
	    }
d4319 1
a4319 1
          
d4323 1
a4323 1
	  if (cui->cu_language == language_cplus)
d4326 2
a4327 2
		obstack_alloc (&objfile->symbol_obstack,
			       sizeof (struct symbol));
d4332 1
a4332 1
/*		  obsavestring (SYMBOL_NAME (sym),
d4334 1
a4334 3
				&objfile->type_obstack);*/
		  bcache (SYMBOL_NAME (sym), strlen (SYMBOL_NAME (sym)) + 1,
			  &objfile->psymbol_cache);
d4345 1
a4345 1
	  attr = dwarf2_attr (die, DW_AT_const_value, cui);
d4348 1
a4348 1
	      dwarf2_const_value (attr, sym, objfile, cui);
d4357 1
a4357 1
	  complain (&dwarf2_unsupported_tag, dwarf2_tag_name (die->tag));
d4369 1
a4369 1
		    const struct comp_unit_instance *cui)
d4371 1
a4371 1
  struct dwarf2_block *blk;
d4376 1
a4376 1
      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) != cui->cu_header.addr_size)
d4378 1
a4378 1
		  cui->cu_header.addr_size, TYPE_LENGTH (SYMBOL_TYPE (sym)));
d4380 2
a4381 2
	obstack_alloc (&objfile->symbol_obstack, cui->cu_header.addr_size);
      store_address (SYMBOL_VALUE_BYTES (sym), cui->cu_header.addr_size,
d4400 4
a4403 4
         symbol's value "represented as it would be on the target
         architecture."  By the time we get here, it's already been
         converted to host endianness, so we just need to sign- or
         zero-extend it as appropriate.  */
d4429 1
a4429 1
		dwarf2_form_name (attr->form));
d4440 3
a4442 1
dwarf2_const_value_data (struct attribute *attr, struct symbol *sym, int bits)
d4463 1
a4463 1
	  const struct comp_unit_instance *cui)
d4470 1
a4470 1
  type_attr = dwarf2_attr (die, DW_AT_type, cui);
d4474 1
a4474 1
      return dwarf2_fundamental_type (objfile, FT_VOID, cui);
d4478 2
a4479 2
      ref = dwarf2_get_ref_die_offset (cui, type_attr);
      type_die = follow_die_ref (ref, cui);
d4486 1
a4486 1
  type = tag_type_to_type (type_die, objfile, cui);
d4489 2
a4490 3
      dump_die (type_die, cui);
      error
	("Dwarf Error: Problem turning type die at offset into gdb type.");
d4500 1
a4500 1
		     const struct comp_unit_instance *cui)
d4507 1
a4507 1
  type_attr = dwarf2_attr (die, DW_AT_containing_type, cui);
d4510 2
a4511 2
      ref = dwarf2_get_ref_die_offset (cui, type_attr);
      type_die = follow_die_ref (ref, cui);
d4517 1
a4517 1
      type = tag_type_to_type (type_die, objfile, cui);
d4522 1
a4522 1
	dump_die (type_die, cui);
d4528 18
d4548 1
a4548 1
		  const struct comp_unit_instance *cui)
d4556 1
a4556 1
      read_type_die (die, objfile, cui);
d4559 1
a4559 1
	  dump_die (die, cui);
d4568 1
a4568 1
	       const struct comp_unit_instance *cui)
d4575 1
a4575 1
      read_structure_scope (die, objfile, cui, NULL);
d4578 1
a4578 1
      read_enumeration (die, objfile, cui);
d4582 1
a4582 1
      read_subroutine_type (die, objfile, cui);
d4585 1
a4585 1
      read_array_type (die, objfile, cui);
d4588 1
a4588 1
      read_tag_pointer_type (die, objfile, cui);
d4591 1
a4591 1
      read_tag_ptr_to_member_type (die, objfile, cui);
d4594 1
a4594 1
      read_tag_reference_type (die, objfile, cui);
d4597 1
a4597 1
      read_tag_const_type (die, objfile, cui);
d4600 1
a4600 1
      read_tag_volatile_type (die, objfile, cui);
d4603 1
a4603 1
      read_tag_string_type (die, objfile, cui);
d4606 1
a4606 1
      read_typedef (die, objfile, cui);
d4609 1
a4609 1
      read_base_type (die, objfile, cui);
d4612 1
a4612 1
      complain (&dwarf2_unexpected_tag, dwarf2_tag_name (die->tag));
d4618 1
a4618 2
dwarf2_base_type (int encoding, int size, struct objfile *objfile,
		 const struct comp_unit_instance *cui)
d4626 1
a4626 1
      type = dwarf2_fundamental_type (objfile, FT_VOID, cui);
d4629 1
a4629 1
      type = dwarf2_fundamental_type (objfile, FT_BOOLEAN, cui);
d4633 3
a4635 1
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_COMPLEX, cui);
d4637 3
a4639 1
	  type = dwarf2_fundamental_type (objfile, FT_COMPLEX, cui);
d4643 3
a4645 1
	  type = dwarf2_fundamental_type (objfile, FT_DBL_PREC_FLOAT, cui);
d4647 3
a4649 1
	  type = dwarf2_fundamental_type (objfile, FT_FLOAT, cui);
d4655 1
a4655 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR, cui);
d4658 1
a4658 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_SHORT, cui);
d4662 1
a4662 1
	  type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER, cui);
d4667 1
a4667 1
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_CHAR, cui);
d4673 1
a4673 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR, cui);
d4676 1
a4676 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_SHORT, cui);
d4680 1
a4680 1
	  type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_INTEGER, cui);
d4685 1
a4685 1
      type = dwarf2_fundamental_type (objfile, FT_UNSIGNED_CHAR, cui);
d4688 1
a4688 1
      type = dwarf2_fundamental_type (objfile, FT_SIGNED_INTEGER, cui);
d4693 33
d4728 1
a4728 1
struct die_info *
d4732 1
a4732 1
  
d4736 3
a4738 1
	return NULL;
d4740 3
a4742 1
	return die->next;
d4749 3
a4751 1
	    nesting_level++;
d4753 3
a4755 1
	    nesting_level--;
d4760 3
a4762 1
	return NULL;
d4764 3
a4766 1
	return die;
d4773 1
a4773 2
dwarf2_linkage_name (struct die_info *die,
		     const struct comp_unit_instance *cui)
d4777 1
a4777 1
  attr = dwarf2_attr (die, DW_AT_MIPS_linkage_name, cui);
d4780 1
a4780 1
  attr = dwarf2_attr (die, DW_AT_name, cui);
d4789 1
a4789 1
dwarf2_tag_name (register unsigned tag)
d4905 1
a4905 1
dwarf2_attr_name (register unsigned attr)
d5071 1
a5071 1
dwarf2_form_name (register unsigned form)
d5125 1
a5125 1
dwarf2_stack_op_name (register unsigned op)
d5425 1
a5425 1
dwarf2_bool_name (unsigned mybool)
d5436 1
a5436 1
dwarf2_type_encoding_name (register unsigned enc)
d5461 55
a5515 2
void
dump_die (struct die_info *die, const struct comp_unit_instance *cui)
d5520 1
a5520 1
	   dwarf2_tag_name (die->tag), die->abbrev, die->offset);
d5522 1
a5522 1
	   dwarf2_bool_name (die->has_children));
d5528 2
a5529 2
	       dwarf2_attr_name (die->attrs[i].name),
	       dwarf2_form_name (die->attrs[i].form));
d5576 12
a5587 3
void
store_in_ref_table (unsigned int offset, struct die_info *die,
		    struct comp_unit_instance *cui)
d5593 1
a5593 1
  old = cui->die_ref_table[h];
d5595 1
a5595 1
  cui->die_ref_table[h] = die;
d5600 1
a5600 1
dwarf2_empty_hash_tables (struct comp_unit_instance *cui)
d5602 1
a5602 1
  memset (cui->die_ref_table, 0, sizeof (cui->die_ref_table));
d5606 1
a5606 2
dwarf2_get_ref_die_offset (const struct comp_unit_instance *cui,
			   struct attribute *attr)
a5608 1
  struct comp_unit_instance *cui_for_die;
d5620 1
a5620 1
      result = cui->cu_header_offset + DW_UNSND (attr);
d5623 1
a5623 2
      complain (&dwarf2_unsupported_die_ref_attr,
		dwarf2_form_name (attr->form));
d5628 2
a5629 2
struct die_info *
follow_die_ref (unsigned int offset, const struct comp_unit_instance *cui)
d5631 1
a5631 1
  struct die_info *die = NULL;
d5633 1
a5633 10
  struct comp_unit_instance *cui_for_die;
  cui_for_die = dwarf2_get_cu_by_offset (cui->abfd, offset);
  if (cui_for_die == 0)
    error ("Can't find CU for die");
  if (cui_for_die != cui)
    {
      read_full_die (&die, cui_for_die->abfd, dwarf2_info_buffer + offset,
		     cui_for_die);
      return die;
    }
d5635 1
a5635 1
  die = cui->die_ref_table[h];
d5644 1
a5644 3
  die = NULL;
  read_full_die (&die, cui->abfd, dwarf2_info_buffer + offset, cui);
  return die;
d5648 1
a5648 2
dwarf2_fundamental_type (struct objfile *objfile, int typeid,
			 const struct comp_unit_instance *cui)
d5662 1
a5662 1
      ftypes[typeid] = cui->cu_language_defn->la_fund_type (objfile, typeid);
d5697 2
a5698 2
decode_locdesc (struct dwarf2_block *blk, struct objfile *objfile,
		const struct comp_unit_instance *cui)
d5806 1
a5806 2
	  stack[++stacki] =
	    read_signed_leb128 (NULL, (data + i), &bytes_read);
d5814 1
a5814 2
	  stack[++stacki] =
	    read_signed_leb128 (NULL, (data + i), &bytes_read);
d5819 1
a5819 2
	  stack[++stacki] =
	    read_signed_leb128 (NULL, (data + i), &bytes_read);
d5836 1
a5836 1
					  cui, &bytes_read);
d5877 1
a5877 2
	  stack[++stacki] =
	    read_signed_leb128 (NULL, (data + i), &bytes_read);
d5887 1
a5887 2
	  stack[stacki] +=
	    read_unsigned_leb128 (NULL, (data + i), &bytes_read);
d5905 1
a5905 1
	  complain (&dwarf2_unsupported_stack_op, dwarf2_stack_op_name (op));
d5921 2
a5922 2
static struct dwarf2_block *
dwarf2_alloc_block (void)
d5924 1
a5924 1
  struct dwarf2_block *blk;
d5926 2
a5927 2
  blk = (struct dwarf2_block *)
    obstack_alloc (&dwarf2_tmp_obstack, sizeof (struct dwarf2_block));
d5932 1
a5932 1
dwarf2_alloc_abbrev (void)
a5940 11
static struct comp_unit_instance *
dwarf2_alloc_comp_unit_instance (void)
{
  struct comp_unit_instance *cui;

  cui =
    (struct comp_unit_instance *)
    xmalloc (sizeof (struct comp_unit_instance));
  memset (cui, 0, sizeof (struct comp_unit_instance));
  return cui;
}
d5942 1
a5942 1
dwarf2_alloc_die (void)
a5948 1029
}
typedef struct Frame_Chunk
{
  struct Frame_Chunk *next;
  unsigned int fde_offset;
  unsigned char *chunk_start;
  int ncols;
  /* DW_CFA_{undefined,same_value,offset,register,unreferenced}  */
  short int *col_type;
  int *col_offset;
  char *augmentation;
  unsigned int code_factor;
  signed int data_factor;
  unsigned long pc_begin;
  unsigned long pc_range;
  int cfa_reg;
  int cfa_offset;
  int ra;
}
Frame_Chunk;

/* A marker for a col_type that means this column was never referenced
   in the frame info.  */
#define DW_CFA_unreferenced (-1)

static void
frame_need_space (fc, reg)
     Frame_Chunk *fc;
     int reg;
{
  int prev = fc->ncols;

  if (reg < fc->ncols)
    return;

  fc->ncols = reg + 1;
  fc->col_type = (short int *) xrealloc (fc->col_type,
					 fc->ncols * sizeof (short int));
  fc->col_offset = (int *) xrealloc (fc->col_offset,
				     fc->ncols * sizeof (int));

  while (prev < fc->ncols)
    {
      fc->col_type[prev] = DW_CFA_unreferenced;
      fc->col_offset[prev] = 0;
      prev++;
    }
}

static void
frame_display_row (fc, need_col_headers, max_regs)
     Frame_Chunk *fc;
     int *need_col_headers;
     int *max_regs;
{
  int r;
  char tmp[100];

  if (*max_regs < fc->ncols)
    *max_regs = fc->ncols;

  if (*need_col_headers)
    {
      *need_col_headers = 0;

      printf ("   LOC   CFA      ");

      for (r = 0; r < *max_regs; r++)
	if (fc->col_type[r] != DW_CFA_unreferenced)
	  {
	    if (r == fc->ra)
	      printf ("ra   ");
	    else
	      printf ("r%-4d", r);
	  }

      printf ("\n");
    }

  printf ("%08x ", (unsigned int) fc->pc_begin);
  sprintf (tmp, "r%d%+d", fc->cfa_reg, fc->cfa_offset);
  printf ("%-8s ", tmp);

  for (r = 0; r < fc->ncols; r++)
    {
      if (fc->col_type[r] != DW_CFA_unreferenced)
	{
	  switch (fc->col_type[r])
	    {
	    case DW_CFA_undefined:
	      strcpy (tmp, "u");
	      break;
	    case DW_CFA_same_value:
	      strcpy (tmp, "s");
	      break;
	    case DW_CFA_offset:
	      sprintf (tmp, "c%+d", fc->col_offset[r]);
	      break;
	    case DW_CFA_register:
	      sprintf (tmp, "r%d", fc->col_offset[r]);
	      break;
	    default:
	      strcpy (tmp, "n/a");
	      break;
	    }
	  printf ("%-5s", tmp);
	}
    }
  printf ("\n");
}

#define GET(N)	read_n_bytes (abfd, start, N); start += N
#define LEB()	read_unsigned_leb128 (abfd, start, & length_return); start += length_return
#define SLEB()	read_signed_leb128 (abfd, start, & length_return); start += length_return
static Frame_Chunk **fde_array;
static unsigned int fde_array_size=0;
static unsigned int fde_array_elems=0;
static int
compare_fde (const void *a, const void *b)
{
  Frame_Chunk **first, **second;
  first = (Frame_Chunk **) a;
  second = (Frame_Chunk **) b;
  return (*first)->pc_begin - (*second)->pc_begin;
}
static int
dwarf2_read_frame_info_1 (struct objfile *obj, unsigned char *start, unsigned char *end)
{
  bfd *abfd = obj->obfd;
  unsigned char *section_start = start;
  Frame_Chunk *chunks = 0;
  Frame_Chunk *remembered_state = 0;
  Frame_Chunk *rs;
  int is_eh = 0;
  int length_return;
  int max_regs = 0;


  while (start < end)
    {
      unsigned char *saved_start;
      unsigned char *block_end;
      unsigned long length;
      unsigned long cie_id;
      Frame_Chunk *fc;
      Frame_Chunk *cie;
      int need_col_headers = 1;

      saved_start = start;
      length = read_4_bytes (abfd, start);
      start += 4;

      if (length == 0)
	return 1;

      block_end = saved_start + length + 4;
      cie_id = read_4_bytes (abfd, start);
      start += 4;

      printf ("\n%08x %08lx %08lx ", saved_start - section_start, length, cie_id);

      if (is_eh ? (cie_id == 0) : (cie_id == DW_CIE_ID))
	{
	  fc = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
	  memset (fc, 0, sizeof (Frame_Chunk));

	  fc->next = chunks;
	  chunks = fc;
	  fc->chunk_start = saved_start;
	  fc->ncols = 0;
	  fc->col_type = (short int *) xmalloc (sizeof (short int));
	  fc->col_offset = (int *) xmalloc (sizeof (int));
	  frame_need_space (fc, max_regs - 1);

	  start++;		/* version */
	  fc->augmentation = start;

	  while (*start)
	    start++;

	  start++;		/* skip past NUL */

	  if (fc->augmentation[0] == 'z')
	    {
	      int xtra;
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      fc->ra = read_1_byte (abfd, start);
	      start += 1;
	      xtra = LEB ();
	      printf ("skipping %d extra bytes\n", xtra);
	      start += xtra;
	    }
	  else if (strcmp (fc->augmentation, "eh") == 0)
	    {
	      start += 4;
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      fc->ra = read_1_byte (abfd, start);
	      start += 1;
	    }
	  else
	    {
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      fc->ra = read_1_byte (abfd, start);
	      start += 1;
	    }
	  cie = fc;
        printf ("CIE \"%s\" cf=%d df=%d ra=%d\n",
                fc->augmentation, fc->code_factor, fc->data_factor, fc->ra);

	  frame_need_space (fc, fc->ra);
	}
      else
	{
	  unsigned char *look_for;

	  fc = (struct Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
	  memset (fc, 0, sizeof (Frame_Chunk));

	  look_for = is_eh ? start - 4 - cie_id : (unsigned char *) cie_id;
	  fc->fde_offset = saved_start - section_start;
	  fc->pc_begin = read_4_bytes (abfd, start) + ANOFFSET (obj->section_offsets, SECT_OFF_TEXT (obj));
	  start += 4;
	  fc->pc_range = read_4_bytes (abfd, start);
	  start += 4;
	  if (fde_array_elems+1 > fde_array_size)
	    {
	      fde_array = xrealloc(fde_array, ((fde_array_size+1) * 2) * sizeof (Frame_Chunk *));
	      fde_array_size += 1;
	      fde_array_size *= 2;
	    }
	  fde_array_elems += 1;
	  fde_array[fde_array_elems-1]=fc;
	  for (cie = chunks;
	       cie && (cie->chunk_start != section_start + (int) look_for);
	       cie = cie->next);
	  if (!cie)
	    {
	      warning ("Invalid CIE pointer %08lx in FDE at %08lx\n", cie_id,
		       (long unsigned int)saved_start);
	      start = block_end;
	      fc->ncols = 0;
	      fc->col_type = (short int *) xmalloc (sizeof (short int));
	      fc->col_offset = (int *) xmalloc (sizeof (int));
	      frame_need_space (fc, max_regs - 1);
	      cie = fc;
	      fc->augmentation = "";
	    }
	  else
	    {
	      fc->ncols = cie->ncols;
	      fc->col_type =
		(short int *) xmalloc (fc->ncols * sizeof (short int));
	      fc->col_offset = (int *) xmalloc (fc->ncols * sizeof (int));
	      memcpy (fc->col_type, cie->col_type,
		      fc->ncols * sizeof (short int));
	      memcpy (fc->col_offset, cie->col_offset,
		      fc->ncols * sizeof (int));
	      fc->augmentation = cie->augmentation;
	      fc->code_factor = cie->code_factor;
	      fc->data_factor = cie->data_factor;
	      fc->cfa_reg = cie->cfa_reg;
	      fc->cfa_offset = cie->cfa_offset;
	      fc->ra = cie->ra;
	      frame_need_space (fc, max_regs - 1);
	    }

	  if (cie->augmentation[0] == 'z')
	    {
	      unsigned long l = LEB ();
	      start += l;
	    }

	  printf ("FDE cie=%08x pc=%08lx..%08lx\n",
		  cie->chunk_start-section_start, fc->pc_begin,
		  fc->pc_begin + fc->pc_range);
	}
#if 0
      /* At this point, fc is the current chunk, cie (if any) is set, and we're
         about to interpret instructions for the chunk.  */

      /* This exists for readelf maintainers.  */
//#define FDEBUG 1

      {
	/* Start by making a pass over the chunk, allocating storage
	   and taking note of what registers are used.  */
	unsigned char *tmp = start;

	while (start < block_end)
	  {
	    unsigned op, opa;
	    unsigned long reg;
	    bfd_vma vma;

	    op = *start++;
	    opa = op & 0x3f;
	    if (op & 0xc0)
	      op &= 0xc0;

	    /* Warning: if you add any more cases to this switch, be
	       sure to add them to the corresponding switch below.  */
	    switch (op)
	      {
	      case DW_CFA_advance_loc:
		break;
	      case DW_CFA_offset:
		LEB ();
		frame_need_space (fc, opa);
		fc->col_type[opa] = DW_CFA_undefined;
		break;
	      case DW_CFA_restore:
		frame_need_space (fc, opa);
		fc->col_type[opa] = DW_CFA_undefined;
		break;
	      case DW_CFA_set_loc:
		start += sizeof (vma);
		break;
	      case DW_CFA_advance_loc1:
		start += 1;
		break;
	      case DW_CFA_advance_loc2:
		start += 2;
		break;
	      case DW_CFA_advance_loc4:
		start += 4;
		break;
	      case DW_CFA_offset_extended:
		reg = LEB ();
		LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_restore_extended:
		reg = LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_undefined:
		reg = LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_same_value:
		reg = LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_register:
		reg = LEB ();
		LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_def_cfa:
		LEB ();
		LEB ();
		break;
	      case DW_CFA_def_cfa_register:
		LEB ();
		break;
	      case DW_CFA_def_cfa_offset:
		LEB ();
		break;
#ifndef DW_CFA_GNU_args_size
#define DW_CFA_GNU_args_size 0x2e
#endif
	      case DW_CFA_GNU_args_size:
		LEB ();
		break;
#ifndef DW_CFA_GNU_negative_offset_extended
#define DW_CFA_GNU_negative_offset_extended 0x2f
#endif
	      case DW_CFA_GNU_negative_offset_extended:
		reg = LEB ();
		LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;

	      default:
		break;
	      }
	  }
	start = tmp;
      }
      /* Now we know what registers are used, make a second pass over
         the chunk, this time actually printing out the info.  */

      while (start < block_end)
	{
	  unsigned op, opa;
	  unsigned long ul, reg, roffs;
	  long l, ofs;
	  bfd_vma vma;

	  op = *start++;
	  opa = op & 0x3f;
	  if (op & 0xc0)
	    op &= 0xc0;

	  /* Warning: if you add any more cases to this switch, be
	     sure to add them to the corresponding switch above.  */
	  switch (op)
	    {
	    case DW_CFA_advance_loc:
	      frame_display_row (fc, &need_col_headers, &max_regs);
#if FDEBUG
	      printf ("  DW_CFA_advance_loc: %08x = %08x + %d*%d\n",
		      fc->pc_begin + opa * fc->code_factor, fc->pc_begin, opa,
		      fc->code_factor);
#endif
	      fc->pc_begin += opa * fc->code_factor;
	      break;

	    case DW_CFA_offset:
	      roffs = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_offset: r%d = cfa[%d*%d]\n", opa, roffs,
		      fc->data_factor);
#endif
	      fc->col_type[opa] = DW_CFA_offset;
	      fc->col_offset[opa] = roffs * fc->data_factor;
	      break;

	    case DW_CFA_restore:
#if FDEBUG
	      printf ("  DW_CFA_restore: r%d\n", opa);
#endif
	      fc->col_type[opa] = cie->col_type[opa];
	      fc->col_offset[opa] = cie->col_offset[opa];
	      break;

	    case DW_CFA_set_loc:
	      frame_display_row (fc, &need_col_headers, &max_regs);
	      vma = read_n_bytes (abfd, start, sizeof (vma));
	      start += sizeof (vma);
#if FDEBUG
	      printf ("  DW_CFA_set_loc: %08x\n", vma);
#endif
	      fc->pc_begin = vma;
	      break;

	    case DW_CFA_advance_loc1:
	      frame_display_row (fc, &need_col_headers, &max_regs);
	      ofs = read_1_byte (abfd, start);
	      start += 1;
#if FDEBUG
	      printf ("  DW_CFA_advance_loc1: %08x = %08x + %d*%d\n",
		      fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs,
		      fc->code_factor);
#endif
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_advance_loc2:
	      frame_display_row (fc, &need_col_headers, &max_regs);
	      ofs = read_2_bytes (abfd, start);
	      start += 2;
#if FDEBUG
	      printf ("  DW_CFA_advance_loc2: %08x = %08x + %d*%d\n",
		      fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs,
		      fc->code_factor);
#endif
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_advance_loc4:
	      frame_display_row (fc, &need_col_headers, &max_regs);
	      ofs = read_4_bytes (abfd, start);
	      start += 4;
#if FDEBUG
	      printf ("  DW_CFA_advance_loc4: %08x = %08x + %d*%d\n",
		      fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs,
		      fc->code_factor);
#endif
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_offset_extended:
	      reg = LEB ();
	      roffs = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_offset_extended: r%d = cfa[%d*%d]\n", reg,
		      roffs, fc->data_factor);
#endif
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = roffs * fc->data_factor;
	      break;

	    case DW_CFA_restore_extended:
	      reg = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_restore_extended: r%d\n", reg);
#endif
	      fc->col_type[reg] = cie->col_type[reg];
	      fc->col_offset[reg] = cie->col_offset[reg];
	      break;

	    case DW_CFA_undefined:
	      reg = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_undefined: r%d\n", reg);
#endif
	      fc->col_type[reg] = DW_CFA_undefined;
	      fc->col_offset[reg] = 0;
	      break;

	    case DW_CFA_same_value:
	      reg = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_same_value: r%d\n", reg);
#endif
	      fc->col_type[reg] = DW_CFA_same_value;
	      fc->col_offset[reg] = 0;
	      break;

	    case DW_CFA_register:
	      reg = LEB ();
	      roffs = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_register: r%d\n", reg);
#endif
	      fc->col_type[reg] = DW_CFA_register;
	      fc->col_offset[reg] = roffs;
	      break;

	    case DW_CFA_remember_state:
#if FDEBUG
	      printf ("  DW_CFA_remember_state\n");
#endif
	      rs = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
	      rs->ncols = fc->ncols;
	      rs->col_type =
		(short int *) xmalloc (rs->ncols * sizeof (short int));
	      rs->col_offset = (int *) xmalloc (rs->ncols * sizeof (int));
	      memcpy (rs->col_type, fc->col_type, rs->ncols);
	      memcpy (rs->col_offset, fc->col_offset,
		      rs->ncols * sizeof (int));
	      rs->next = remembered_state;
	      remembered_state = rs;
	      break;

	    case DW_CFA_restore_state:
#if FDEBUG
	      printf ("  DW_CFA_restore_state\n");
#endif
	      rs = remembered_state;
	      remembered_state = rs->next;
	      frame_need_space (fc, rs->ncols - 1);
	      memcpy (fc->col_type, rs->col_type, rs->ncols);
	      memcpy (fc->col_offset, rs->col_offset,
		      rs->ncols * sizeof (int));
	      xfree (rs->col_type);
	      xfree (rs->col_offset);
	      xfree (rs);
	      break;

	    case DW_CFA_def_cfa:
	      fc->cfa_reg = LEB ();
	      fc->cfa_offset = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_def_cfa: reg %d ofs %d\n", fc->cfa_reg,
		      fc->cfa_offset);
#endif
	      break;

	    case DW_CFA_def_cfa_register:
	      fc->cfa_reg = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_def_cfa_reg: %d\n", fc->cfa_reg);
#endif
	      break;

	    case DW_CFA_def_cfa_offset:
	      fc->cfa_offset = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
#endif
	      break;

	    case DW_CFA_nop:
#if FDEBUG
	      printf ("  DW_CFA_nop\n");
#endif
	      break;

#ifndef DW_CFA_GNU_window_save
#define DW_CFA_GNU_window_save 0x2d
#endif
	    case DW_CFA_GNU_window_save:
#if FDEBUG
	      printf ("  DW_CFA_GNU_window_save\n");
#endif
	      break;

#ifndef DW_CFA_GNU_args_size
#define DW_CFA_GNU_args_size 0x2e
#endif
	    case DW_CFA_GNU_args_size:
	      ul = LEB ();
#if FDEBUG
	      printf ("  DW_CFA_GNU_args_size: %d\n", ul);
#endif
	      break;

#ifndef DW_CFA_GNU_negative_offset_extended
#define DW_CFA_GNU_negative_offset_extended 0x2f
#endif
	    case DW_CFA_GNU_negative_offset_extended:
	      reg = LEB ();
	      l = -LEB ();
	      frame_need_space (fc, reg);
#if FDEBUG
	      printf
		("  DW_CFA_GNU_negative_offset_extended: r%d = cfa[%d*%d]\n",
		 reg, l, fc->data_factor);
#endif
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = l * fc->data_factor;
	      break;

	    default:
	      fprintf (stderr, "unsupported or unknown DW_CFA_%d\n", op);
	      start = block_end;
	    }
	}

      frame_display_row (fc, &need_col_headers, &max_regs);
#endif
      start = block_end;
    }

  printf ("\n");

  return 1;
}

#undef GET
#undef LEB
#undef SLEB
#if 0
      /* At this point, fc is the current chunk, cie (if any) is set, and we're
         about to interpret instructions for the chunk.  */

      /* This exists for readelf maintainers.  */
//#define FDEBUG 1

{
  /* Start by making a pass over the chunk, allocating storage
     and taking note of what registers are used.  */
  unsigned char *tmp = start;

  while (start < block_end)
    {
      unsigned op, opa;
      unsigned long reg;
      bfd_vma vma;

      op = *start++;
      opa = op & 0x3f;
      if (op & 0xc0)
	op &= 0xc0;

      /* Warning: if you add any more cases to this switch, be
         sure to add them to the corresponding switch below.  */
      switch (op)
	{
	case DW_CFA_advance_loc:
	  break;
	case DW_CFA_offset:
	  LEB ();
	  frame_need_space (fc, opa);
	  fc->col_type[opa] = DW_CFA_undefined;
	  break;
	case DW_CFA_restore:
	  frame_need_space (fc, opa);
	  fc->col_type[opa] = DW_CFA_undefined;
	  break;
	case DW_CFA_set_loc:
	  start += sizeof (vma);
	  break;
	case DW_CFA_advance_loc1:
	  start += 1;
	  break;
	case DW_CFA_advance_loc2:
	  start += 2;
	  break;
	case DW_CFA_advance_loc4:
	  start += 4;
	  break;
	case DW_CFA_offset_extended:
	  reg = LEB ();
	  LEB ();
	  frame_need_space (fc, reg);
	  fc->col_type[reg] = DW_CFA_undefined;
	  break;
	case DW_CFA_restore_extended:
	  reg = LEB ();
	  frame_need_space (fc, reg);
	  fc->col_type[reg] = DW_CFA_undefined;
	  break;
	case DW_CFA_undefined:
	  reg = LEB ();
	  frame_need_space (fc, reg);
	  fc->col_type[reg] = DW_CFA_undefined;
	  break;
	case DW_CFA_same_value:
	  reg = LEB ();
	  frame_need_space (fc, reg);
	  fc->col_type[reg] = DW_CFA_undefined;
	  break;
	case DW_CFA_register:
	  reg = LEB ();
	  LEB ();
	  frame_need_space (fc, reg);
	  fc->col_type[reg] = DW_CFA_undefined;
	  break;
	case DW_CFA_def_cfa:
	  LEB ();
	  LEB ();
	  break;
	case DW_CFA_def_cfa_register:
	  LEB ();
	  break;
	case DW_CFA_def_cfa_offset:
	  LEB ();
	  break;
#ifndef DW_CFA_GNU_args_size
#define DW_CFA_GNU_args_size 0x2e
#endif
	case DW_CFA_GNU_args_size:
	  LEB ();
	  break;
#ifndef DW_CFA_GNU_negative_offset_extended
#define DW_CFA_GNU_negative_offset_extended 0x2f
#endif
	case DW_CFA_GNU_negative_offset_extended:
	  reg = LEB ();
	  LEB ();
	  frame_need_space (fc, reg);
	  fc->col_type[reg] = DW_CFA_undefined;

	default:
	  break;
	}
    }
  start = tmp;
}

      /* Now we know what registers are used, make a second pass over
         the chunk, this time actually printing out the info.  */

while (start < block_end)
  {
    unsigned op, opa;
    unsigned long ul, reg, roffs;
    long l, ofs;
    bfd_vma vma;

    op = *start++;
    opa = op & 0x3f;
    if (op & 0xc0)
      op &= 0xc0;

    /* Warning: if you add any more cases to this switch, be
       sure to add them to the corresponding switch above.  */
    switch (op)
      {
      case DW_CFA_advance_loc:
	frame_display_row (fc, &need_col_headers, &max_regs);
#if FDEBUG
	printf ("  DW_CFA_advance_loc: %08x = %08x + %d*%d\n",
		fc->pc_begin + opa * fc->code_factor, fc->pc_begin, opa,
		fc->code_factor);
#endif
	fc->pc_begin += opa * fc->code_factor;
	break;

      case DW_CFA_offset:
	roffs = LEB ();
#if FDEBUG
	printf ("  DW_CFA_offset: r%d = cfa[%d*%d]\n", opa, roffs,
		fc->data_factor);
#endif
	fc->col_type[opa] = DW_CFA_offset;
	fc->col_offset[opa] = roffs * fc->data_factor;
	break;

      case DW_CFA_restore:
#if FDEBUG
	printf ("  DW_CFA_restore: r%d\n", opa);
#endif
	fc->col_type[opa] = cie->col_type[opa];
	fc->col_offset[opa] = cie->col_offset[opa];
	break;

      case DW_CFA_set_loc:
	frame_display_row (fc, &need_col_headers, &max_regs);
	vma = read_n_bytes (abfd, start, sizeof (vma));
	start += sizeof (vma);
#if FDEBUG
	printf ("  DW_CFA_set_loc: %08x\n", vma);
#endif
	fc->pc_begin = vma;
	break;

      case DW_CFA_advance_loc1:
	frame_display_row (fc, &need_col_headers, &max_regs);
	ofs = read_1_byte (abfd, start);
	start += 1;
#if FDEBUG
	printf ("  DW_CFA_advance_loc1: %08x = %08x + %d*%d\n",
		fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs,
		fc->code_factor);
#endif
	fc->pc_begin += ofs * fc->code_factor;
	break;

      case DW_CFA_advance_loc2:
	frame_display_row (fc, &need_col_headers, &max_regs);
	ofs = read_2_bytes (abfd, start);
	start += 2;
#if FDEBUG
	printf ("  DW_CFA_advance_loc2: %08x = %08x + %d*%d\n",
		fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs,
		fc->code_factor);
#endif
	fc->pc_begin += ofs * fc->code_factor;
	break;

      case DW_CFA_advance_loc4:
	frame_display_row (fc, &need_col_headers, &max_regs);
	ofs = read_4_bytes (abfd, start);
	start += 4;
#if FDEBUG
	printf ("  DW_CFA_advance_loc4: %08x = %08x + %d*%d\n",
		fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs,
		fc->code_factor);
#endif
	fc->pc_begin += ofs * fc->code_factor;
	break;

      case DW_CFA_offset_extended:
	reg = LEB ();
	roffs = LEB ();
#if FDEBUG
	printf ("  DW_CFA_offset_extended: r%d = cfa[%d*%d]\n", reg, roffs,
		fc->data_factor);
#endif
	fc->col_type[reg] = DW_CFA_offset;
	fc->col_offset[reg] = roffs * fc->data_factor;
	break;

      case DW_CFA_restore_extended:
	reg = LEB ();
#if FDEBUG
	printf ("  DW_CFA_restore_extended: r%d\n", reg);
#endif
	fc->col_type[reg] = cie->col_type[reg];
	fc->col_offset[reg] = cie->col_offset[reg];
	break;

      case DW_CFA_undefined:
	reg = LEB ();
#if FDEBUG
	printf ("  DW_CFA_undefined: r%d\n", reg);
#endif
	fc->col_type[reg] = DW_CFA_undefined;
	fc->col_offset[reg] = 0;
	break;

      case DW_CFA_same_value:
	reg = LEB ();
#if FDEBUG
	printf ("  DW_CFA_same_value: r%d\n", reg);
#endif
	fc->col_type[reg] = DW_CFA_same_value;
	fc->col_offset[reg] = 0;
	break;

      case DW_CFA_register:
	reg = LEB ();
	roffs = LEB ();
#if FDEBUG
	printf ("  DW_CFA_register: r%d\n", reg);
#endif
	fc->col_type[reg] = DW_CFA_register;
	fc->col_offset[reg] = roffs;
	break;

      case DW_CFA_remember_state:
#if FDEBUG
	printf ("  DW_CFA_remember_state\n");
#endif
	rs = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
	rs->ncols = fc->ncols;
	rs->col_type = (short int *) xmalloc (rs->ncols * sizeof (short int));
	rs->col_offset = (int *) xmalloc (rs->ncols * sizeof (int));
	memcpy (rs->col_type, fc->col_type, rs->ncols);
	memcpy (rs->col_offset, fc->col_offset, rs->ncols * sizeof (int));
	rs->next = remembered_state;
	remembered_state = rs;
	break;

      case DW_CFA_restore_state:
#if FDEBUG
	printf ("  DW_CFA_restore_state\n");
#endif
	rs = remembered_state;
	remembered_state = rs->next;
	frame_need_space (fc, rs->ncols - 1);
	memcpy (fc->col_type, rs->col_type, rs->ncols);
	memcpy (fc->col_offset, rs->col_offset, rs->ncols * sizeof (int));
 xfree (rs->col_type);
 xfree (rs->col_offset);
 xfree (rs);
	break;

      case DW_CFA_def_cfa:
	fc->cfa_reg = LEB ();
	fc->cfa_offset = LEB ();
#if FDEBUG
	printf ("  DW_CFA_def_cfa: reg %d ofs %d\n", fc->cfa_reg,
		fc->cfa_offset);
#endif
	break;

      case DW_CFA_def_cfa_register:
	fc->cfa_reg = LEB ();
#if FDEBUG
	printf ("  DW_CFA_def_cfa_reg: %d\n", fc->cfa_reg);
#endif
	break;

      case DW_CFA_def_cfa_offset:
	fc->cfa_offset = LEB ();
#if FDEBUG
	printf ("  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
#endif
	break;

      case DW_CFA_nop:
#if FDEBUG
	printf ("  DW_CFA_nop\n");
#endif
	break;

#ifndef DW_CFA_GNU_window_save
#define DW_CFA_GNU_window_save 0x2d
#endif
      case DW_CFA_GNU_window_save:
#if FDEBUG
	printf ("  DW_CFA_GNU_window_save\n");
#endif
	break;

#ifndef DW_CFA_GNU_args_size
#define DW_CFA_GNU_args_size 0x2e
#endif
      case DW_CFA_GNU_args_size:
	ul = LEB ();
#if FDEBUG
	printf ("  DW_CFA_GNU_args_size: %d\n", ul);
#endif
	break;

#ifndef DW_CFA_GNU_negative_offset_extended
#define DW_CFA_GNU_negative_offset_extended 0x2f
#endif
      case DW_CFA_GNU_negative_offset_extended:
	reg = LEB ();
	l = -LEB ();
	frame_need_space (fc, reg);
#if FDEBUG
	printf ("  DW_CFA_GNU_negative_offset_extended: r%d = cfa[%d*%d]\n",
		reg, l, fc->data_factor);
#endif
	fc->col_type[reg] = DW_CFA_offset;
	fc->col_offset[reg] = l * fc->data_factor;
	break;

      default:
	fprintf (stderr, "unsupported or unknown DW_CFA_%d\n", op);
	start = block_end;
      }
  }

frame_display_row (fc, &need_col_headers, &max_regs);
#endif
/* Read in the .debug_frame/.eh_frame section, and process it */
static void
dwarf2_read_frame_info (struct objfile *obj)
{
  dwarf2_read_frame_info_1 (obj, dwarf2_frame_buffer,
			   dwarf2_frame_buffer + dwarf2_frame_size);
  qsort(fde_array, fde_array_elems, sizeof(Frame_Chunk *), compare_fde);
}

/* Get the Call Frame Annotation info for a given PC. Uses a binary
   search through the fde_array. */
Frame_Chunk *
dwarf2_get_cfa_for_addr (CORE_ADDR pc)
{
  size_t lo, hi;
  Frame_Chunk *chunk=NULL;
  lo=0;
  hi=fde_array_elems;
  do
    {
      size_t i = (lo + hi) / 2;
      chunk = fde_array[i];
      if (pc < chunk->pc_begin)
	hi = i;
      else if (pc >= chunk->pc_begin + chunk->pc_range)
	lo = i + 1;
      else 
	return chunk;
    } while (lo < hi);
  
  return chunk;
}
/* We can search the fde array ourselves very inexpensively, so there
   is no need to pass along the actual frame program data. */
void 
dwarf2_execute_cfa_program (struct frame_info *frame)
{
  
@


1.28
log
@* dwarf2read.c (struct partial_die_info): New member: has_pc_info.
(read_partial_die): Delete fourth argument; we return this info in
the struct partial_die_info object itself now.
(dwarf2_build_psymtabs_hard, scan_partial_symbols): Use the
has_pc_info field of the partial die struct, rather than passing a
variable by reference to read_partial_die.
@
text
@d983 13
@


1.27
log
@* dwarf2read.c (dwarf2_build_psymtabs_hard): Remove extraneous
code in loop condition.  This seemed to be trying to round
info_ptr up to the next four-byte boundary, but that's not what it
actually did.  If we discover the problem the old code was really
trying to address, we can fix it properly.
@
text
@d197 1
d590 1
a590 1
			       bfd *, char *, int *,
a974 1
  int comp_unit_has_pc_info;
d1015 1
a1015 1
				   &comp_unit_has_pc_info, &cu_header);
d1050 1
a1050 1
	  if (!comp_unit_has_pc_info)
a1092 1
  int has_pc_info;
d1099 1
a1099 2
      info_ptr = read_partial_die (&pdi, abfd, info_ptr,
				   &has_pc_info, cu_header);
d1106 1
a1106 1
	      if (has_pc_info)
d3124 1
a3124 2
		  char *info_ptr, int *has_pc_info,
		  const struct comp_unit_head *cu_header)
a3134 1
  *has_pc_info = 0;
d3220 1
a3220 1
      read_partial_die (&spec_die, abfd, spec_ptr, &dummy, cu_header);
d3243 1
a3243 1
    *has_pc_info = 1;
@


1.26
log
@* dwarf2read.c (read_comp_unit, sibling_die, dump_die,
dump_die_list, store_in_ref_table, follow_die_ref): Make these
static; they're private functions.
@
text
@d983 1
a983 2
  while ((unsigned int) (info_ptr - dwarf_info_buffer)
	 + ((info_ptr - dwarf_info_buffer) % 4) < dwarf_info_size)
@


1.25
log
@
	* dwarf2read.c (set_cu_language):  Handle DW_LANG_Java.
@
text
@d730 2
a731 1
struct die_info *read_comp_unit (char *, bfd *, const struct comp_unit_head *);
d760 1
a760 1
struct die_info *sibling_die (struct die_info *);
d762 1
a762 1
void dump_die (struct die_info *);
d764 1
a764 1
void dump_die_list (struct die_info *);
d766 1
a766 1
void store_in_ref_table (unsigned int, struct die_info *);
d772 1
a772 1
struct die_info *follow_die_ref (unsigned int);
d2903 1
a2903 1
struct die_info *
d4720 1
a4720 1
struct die_info *
d5506 1
a5506 1
void
d5568 1
a5568 1
void
d5578 1
a5578 1
void
d5620 1
a5620 1
struct die_info *
@


1.24
log
@	* buildsym.c (start_subfile): Use FILENAME_CMP instead of STREQ.
	(top-level): #include filenames.h.

	* dwarf2read.c (dwarf2_start_subfile): Use IS_ABSOLUTE_PATH and
	FILENAME_CMP, to DTRT on non-Posix platforms.
	(top-level): #include filenames.h.
@
text
@d3724 3
@


1.23
log
@Update/correct copyright notices.
@
text
@d39 1
d4067 1
a4067 1
  if (*filename != '/' && dirname != NULL)
d4074 1
a4074 1
	  if (STREQ (subfile->name, fullname))
@


1.22
log
@Add __FILE__ and __LINE__ parameter to internal_error() /
internal_verror().
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 2001
@


1.21
log
@* dwarf2read.c (read_tag_const_type, read_tag_volatile_type):
Implement these correctly, using make_cv_type.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
d952 2
a953 1
    internal_error ("read_comp_unit_head: dwarf from non elf file");
d3476 2
a3477 1
	  internal_error ("read_address: bad switch, signed");
d3494 2
a3495 1
	  internal_error ("read_address: bad switch, unsigned");
d3580 2
a3581 1
      internal_error ("read_offset: bad switch");
@


1.20
log
@Replace free() with xfree().
@
text
@d2656 2
d2663 2
a2664 2
  complain (&dwarf2_const_ignored);
  die->type = die_type (die, objfile, cu_header);
d2671 2
d2678 2
a2679 2
  complain (&dwarf2_volatile_ignored);
  die->type = die_type (die, objfile, cu_header);
@


1.19
log
@2000-12-08  Michael Snyder  <msnyder@@mvstp600e.cygnus.com>

        * dwarf2read.c (DWARF2_REG_TO_REGNUM): New macro.  Provide default
        definition.  Will be used to translate between the compiler's
        register numbering and GDB's (for register variables etc).
        (new_symbol): Use DWARF2_REG_TO_REGNUM to translate register ids.
@
text
@d1742 1
a1742 1
  make_cleanup (free, new_field);
d2029 1
a2029 1
  make_cleanup (free, new_fnfield);
d2389 1
a2389 1
	  free (fields);
d2952 2
a2953 2
      free (die->attrs);
      free (die);
d3086 2
a3087 2
	  free (abbrev->attrs);
	  free (abbrev);
d4067 1
a4067 1
	      free (fullname);
d4071 1
a4071 1
      free (fullname);
@


1.18
log
@2000-11-07  Daniel Berlin  <dberlin@@redhat.com>

        * dwarf2read.c: Revert June 5th change for caching of types,
        as per Jim Blandy's request.
@
text
@d46 4
d4208 2
d4214 1
a4214 1
		      SYMBOL_BASEREG (sym) = basereg;
d4256 2
d4270 1
a4270 1
		      SYMBOL_BASEREG (sym) = basereg;
@


1.17
log
@In new_symbol(), relocate symbol address by base address of the section
it is in instead of using the base address of the .text section.
@
text
@a277 5
#ifndef TYPE_HASH_SIZE
#define TYPE_HASH_SIZE 4096
#endif
static struct type *dwarf2_cached_types[TYPE_HASH_SIZE];

d2899 1
a2899 1
  /* Reset die reference table and cached types table; we are
d4526 1
a4526 32
      struct attribute *attr;
      attr = dwarf_attr (die, DW_AT_name);
      if (attr && DW_STRING (attr))
	{
	  char *attrname=DW_STRING (attr);
	  unsigned long hashval=hash(attrname, strlen(attrname)) % TYPE_HASH_SIZE;

	  if (dwarf2_cached_types[hashval] != NULL)
	    {
	      const char *nameoftype;
	      nameoftype = TYPE_NAME(dwarf2_cached_types[hashval]) == NULL ? TYPE_TAG_NAME(dwarf2_cached_types[hashval]) : TYPE_NAME(dwarf2_cached_types[hashval]);
	      if (strcmp(attrname, nameoftype) == 0)
		{
		  die->type=dwarf2_cached_types[hashval];
		}
	      else
		{
		  read_type_die (die, objfile, cu_header);
		  dwarf2_cached_types[hashval] = die->type;
		}
	    }
	  else
	    {
	      read_type_die (die, objfile, cu_header);
	      dwarf2_cached_types[hashval] = die->type;
	    }
	}
      else
	{
	  read_type_die (die, objfile, cu_header);
	}

a5572 1
  memset (dwarf2_cached_types, 0, sizeof(dwarf2_cached_types));
@


1.16
log
@Fix date in comment.
@
text
@d4188 4
a4191 1
		      SYMBOL_VALUE_ADDRESS (sym) += baseaddr;
d4221 4
a4225 1
		      SYMBOL_VALUE_ADDRESS (sym) = addr + baseaddr;
@


1.15
log
@DWARF2.1 64-bit support.
@
text
@d3519 1
a3519 1
     - Kevin, Sept 4, 2000
@


1.14
log
@Protoization.
@
text
@d155 1
a155 1
    unsigned int length;
d160 3
d610 6
d910 6
a915 2
      entry_length = read_4_bytes (abfd, pubnames_ptr);
      pubnames_ptr += 4;
d939 4
a942 2
  cu_header->length = read_4_bytes (abfd, info_ptr);
  info_ptr += 4;
d945 3
a947 2
  cu_header->abbrev_offset = read_4_bytes (abfd, info_ptr);
  info_ptr += 4;
d952 1
a952 1
    internal_error ("dwarf2_build_psymtabs_hard: dwarf from non elf file");
d999 1
a999 1
      if (beg_of_comp_unit + cu_header.length + 4
d1033 1
a1033 1
      baseaddr = ANOFFSET (objfile->section_offsets, 0);
d1068 2
a1069 1
      info_ptr = beg_of_comp_unit + cu_header.length + 4;
d1334 1
a1334 1
  baseaddr = ANOFFSET (pst->section_offsets, 0);
d1382 1
a1382 1
  symtab = end_symtab (highpc + baseaddr, objfile, 0);
d3390 4
d3496 83
d3820 2
a3821 2
  lh.total_length = read_4_bytes (abfd, line_ptr);
  line_ptr += 4;
d3825 2
a3826 2
  lh.prologue_length = read_4_bytes (abfd, line_ptr);
  line_ptr += 4;
d5619 1
@


1.13
log
@* dwarf2read.c (read_structure_scope): Correct overzealous
addition of cu_header argument.
@
text
@d779 1
a779 2
dwarf2_has_info (abfd)
     bfd *abfd;
d798 1
a798 4
dwarf2_locate_sections (ignore_abfd, sectp, ignore_ptr)
     bfd *ignore_abfd;
     asection *sectp;
     PTR ignore_ptr;
d845 1
a845 3
dwarf2_build_psymtabs (objfile, mainline)
     struct objfile *objfile;
     int mainline;
d888 1
a888 3
dwarf2_build_psymtabs_easy (objfile, mainline)
     struct objfile *objfile;
     int mainline;
d945 1
a945 3
dwarf2_build_psymtabs_hard (objfile, mainline)
     struct objfile *objfile;
     int mainline;
d1271 1
a1271 2
dwarf2_psymtab_to_symtab (pst)
     struct partial_symtab *pst;
d1298 1
a1298 2
psymtab_to_symtab_1 (pst)
     struct partial_symtab *pst;
d1675 2
a1676 5
dwarf2_get_pc_bounds (die, lowpc, highpc, objfile)
     struct die_info *die;
     CORE_ADDR *lowpc;
     CORE_ADDR *highpc;
     struct objfile *objfile;
d1873 2
a1874 4
dwarf2_attach_fields_to_type (fip, type, objfile)
     struct field_info *fip;
     struct type *type;
     struct objfile *objfile;
d2088 2
a2089 4
dwarf2_attach_fn_fields_to_type (fip, type, objfile)
     struct field_info *fip;
     struct type *type;
     struct objfile *objfile;
d2668 1
a2668 3
read_tag_string_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2809 1
a2809 3
read_base_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2928 1
a2928 2
free_die_list (dies)
     struct die_info *dies;
d2959 2
a2960 4
dwarf2_read_section (objfile, offset, size)
     struct objfile *objfile;
     file_ptr offset;
     unsigned int size;
d2985 1
a2985 3
dwarf2_read_abbrevs (abfd, offset)
     bfd *abfd;
     unsigned int offset;
d3058 1
a3058 2
dwarf2_empty_abbrev_table (ignore)
     PTR ignore;
d3081 1
a3081 2
dwarf2_lookup_abbrev (number)
     unsigned int number;
d3389 1
a3389 3
read_1_byte (abfd, buf)
     bfd *abfd;
     char *buf;
d3395 1
a3395 3
read_1_signed_byte (abfd, buf)
     bfd *abfd;
     char *buf;
d3401 1
a3401 3
read_2_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d3407 1
a3407 3
read_2_signed_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d3413 1
a3413 3
read_4_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d3419 1
a3419 3
read_4_signed_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d3425 1
a3425 3
read_8_bytes (abfd, buf)
     bfd *abfd;
     char *buf;
d3476 1
a3476 4
read_n_bytes (abfd, buf, size)
     bfd *abfd;
     char *buf;
     unsigned int size;
d3498 1
a3498 4
read_string (abfd, buf, bytes_read_ptr)
     bfd *abfd;
     char *buf;
     unsigned int *bytes_read_ptr;
d3533 1
a3533 4
read_unsigned_leb128 (abfd, buf, bytes_read_ptr)
     bfd *abfd;
     char *buf;
     unsigned int *bytes_read_ptr;
d3561 1
a3561 4
read_signed_leb128 (abfd, buf, bytes_read_ptr)
     bfd *abfd;
     char *buf;
     unsigned int *bytes_read_ptr;
d3593 1
a3593 2
set_cu_language (lang)
     unsigned int lang;
d3626 1
a3626 3
dwarf_attr (die, name)
     struct die_info *die;
     unsigned int name;
d3949 1
a3949 3
dwarf2_start_subfile (filename, dirname)
     char *filename;
     char *dirname;
d4395 1
a4395 3
type_at_offset (offset, objfile)
     unsigned int offset;
     struct objfile *objfile;
d4514 1
a4514 4
dwarf_base_type (encoding, size, objfile)
     int encoding;
     int size;
     struct objfile *objfile;
d4591 1
a4591 2
copy_die (old_die)
     struct die_info *old_die;
d4625 1
a4625 2
sibling_die (die)
     struct die_info *die;
d4669 1
a4669 2
dwarf2_linkage_name (die)
     struct die_info *die;
d4685 1
a4685 2
dwarf_tag_name (tag)
     register unsigned tag;
d4801 1
a4801 2
dwarf_attr_name (attr)
     register unsigned attr;
d4967 1
a4967 2
dwarf_form_name (form)
     register unsigned form;
d5021 1
a5021 2
dwarf_stack_op_name (op)
     register unsigned op;
d5321 1
a5321 2
dwarf_bool_name (mybool)
     unsigned mybool;
d5332 1
a5332 2
dwarf_type_encoding_name (enc)
     register unsigned enc;
d5361 1
a5361 2
dwarf_cfi_name (cfi_opc)
     register unsigned cfi_opc;
d5411 1
a5411 2
dump_die (die)
     struct die_info *die;
d5473 1
a5473 2
dump_die_list (die)
     struct die_info *die;
d5483 1
a5483 3
store_in_ref_table (offset, die)
     unsigned int offset;
     struct die_info *die;
d5496 1
a5496 1
dwarf2_empty_hash_tables ()
d5503 1
a5503 2
dwarf2_get_ref_die_offset (attr)
     struct attribute *attr;
d5525 1
a5525 2
follow_die_ref (offset)
     unsigned int offset;
d5544 1
a5544 3
dwarf2_fundamental_type (objfile, typeid)
     struct objfile *objfile;
     int typeid;
d5812 1
a5812 2
dwarf2_free_tmp_obstack (ignore)
     PTR ignore;
d5818 1
a5818 1
dwarf_alloc_block ()
d5828 1
a5828 1
dwarf_alloc_abbrev ()
d5838 1
a5838 1
dwarf_alloc_die ()
@


1.12
log
@Eliminate global address_size.  Replace with function
read_comp_unit_head() and ``struct compu_unit_head'' parameter.
Include support for signed address case.
Fixes problem of global address size / sign being out-of-sync with
with current section.
@
text
@d2223 1
a2223 1
	  else if (child_die->tag == DW_TAG_subprogram, cu_header)
@


1.11
log
@From Richard Henderson <rth@@cygnus.com>:
* dwarf2read.c (dwarf2_empty_hash_tables): Renamed from
dwarf2_empty_die_ref_table; zero dwarf2_cached_types as well.
Update all callers.
@
text
@d46 1
d61 1
d151 2
a152 1
/* The data in a compilation unit header looks like this.  */
d159 1
a551 6
/* Remember the addr_size read from the dwarf.
   If a target expects to link compilation units with differing address
   sizes, gdb needs to be sure that the appropriate size is here for
   whatever scope is currently getting read. */
static int address_size;

d566 2
a567 1
				   CORE_ADDR *, CORE_ADDR *);
d569 2
a570 1
static void add_partial_symbol (struct partial_die_info *, struct objfile *);
d585 2
a586 1
			       bfd *, char *, int *);
d588 2
a589 1
static char *read_full_die (struct die_info **, bfd *, char *);
d592 1
a592 1
			     bfd *, char *);
d604 2
a605 1
static CORE_ADDR read_address (bfd *, char *);
d621 2
a622 1
static void dwarf_decode_lines (unsigned int, char *, bfd *);
d627 1
a627 1
				  struct objfile *);
d630 1
a630 1
				struct objfile *);
d636 2
a637 1
static struct type *die_type (struct die_info *, struct objfile *);
d639 2
a640 1
static struct type *die_containing_type (struct die_info *, struct objfile *);
d646 2
a647 1
static struct type *tag_type_to_type (struct die_info *, struct objfile *);
d649 2
a650 1
static void read_type_die (struct die_info *, struct objfile *);
d652 2
a653 1
static void read_typedef (struct die_info *, struct objfile *);
d657 2
a658 1
static void read_file_scope (struct die_info *, struct objfile *);
d660 2
a661 1
static void read_func_scope (struct die_info *, struct objfile *);
d663 2
a664 1
static void read_lexical_block_scope (struct die_info *, struct objfile *);
d670 1
a670 1
			      struct objfile *);
d677 2
a678 1
				  struct objfile *objfile);
d683 2
a684 1
static void read_structure_scope (struct die_info *, struct objfile *);
d686 2
a687 1
static void read_common_block (struct die_info *, struct objfile *);
d689 2
a690 1
static void read_enumeration (struct die_info *, struct objfile *);
d694 2
a695 1
static CORE_ADDR decode_locdesc (struct dwarf_block *, struct objfile *);
d697 2
a698 1
static void read_array_type (struct die_info *, struct objfile *);
d700 2
a701 1
static void read_tag_pointer_type (struct die_info *, struct objfile *);
d703 2
a704 1
static void read_tag_ptr_to_member_type (struct die_info *, struct objfile *);
d706 2
a707 1
static void read_tag_reference_type (struct die_info *, struct objfile *);
d709 2
a710 1
static void read_tag_const_type (struct die_info *, struct objfile *);
d712 2
a713 1
static void read_tag_volatile_type (struct die_info *, struct objfile *);
d717 2
a718 1
static void read_subroutine_type (struct die_info *, struct objfile *);
d720 1
a720 1
struct die_info *read_comp_unit (char *, bfd *);
d726 2
a727 1
static void process_die (struct die_info *, struct objfile *);
d926 23
a961 1
  struct comp_unit_head cu_header;
d977 1
d979 1
a979 9
      cu_header.length = read_4_bytes (abfd, info_ptr);
      info_ptr += 4;
      cu_header.version = read_2_bytes (abfd, info_ptr);
      info_ptr += 2;
      cu_header.abbrev_offset = read_4_bytes (abfd, info_ptr);
      info_ptr += 4;
      cu_header.addr_size = read_1_byte (abfd, info_ptr);
      info_ptr += 1;
      address_size = cu_header.addr_size;
d1006 2
a1007 2
      info_ptr = read_partial_die (&comp_unit_die, abfd,
				   info_ptr, &comp_unit_has_pc_info);
d1037 2
a1038 1
	  info_ptr = scan_partial_symbols (info_ptr, objfile, &lowpc, &highpc);
d1070 3
a1072 5
scan_partial_symbols (info_ptr, objfile, lowpc, highpc)
     char *info_ptr;
     struct objfile *objfile;
     CORE_ADDR *lowpc;
     CORE_ADDR *highpc;
d1091 2
a1092 1
      info_ptr = read_partial_die (&pdi, abfd, info_ptr, &has_pc_info);
d1112 1
a1112 1
		      add_partial_symbol (&pdi, objfile);
d1125 1
a1125 1
		  add_partial_symbol (&pdi, objfile);
d1132 1
a1132 1
		add_partial_symbol (&pdi, objfile);
d1138 1
a1138 1
		add_partial_symbol (&pdi, objfile);
d1173 2
a1174 3
add_partial_symbol (pdi, objfile)
     struct partial_die_info *pdi;
     struct objfile *objfile;
d1217 1
a1217 1
	    addr = decode_locdesc (pdi->locdesc, objfile);
d1229 1
a1229 1
	  addr = decode_locdesc (pdi->locdesc, objfile);
d1340 1
a1340 8
  cu_header.length = read_4_bytes (abfd, info_ptr);
  info_ptr += 4;
  cu_header.version = read_2_bytes (abfd, info_ptr);
  info_ptr += 2;
  cu_header.abbrev_offset = read_4_bytes (abfd, info_ptr);
  info_ptr += 4;
  cu_header.addr_size = read_1_byte (abfd, info_ptr);
  info_ptr += 1;
d1346 1
a1346 1
  dies = read_comp_unit (info_ptr, abfd);
d1351 1
a1351 1
  process_die (dies, objfile);
d1397 2
a1398 3
process_die (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d1405 1
a1405 1
      read_file_scope (die, objfile);
d1408 2
a1409 2
      read_subroutine_type (die, objfile);
      read_func_scope (die, objfile);
d1417 1
a1417 1
      read_lexical_block_scope (die, objfile);
d1422 1
a1422 1
      read_structure_scope (die, objfile);
d1425 1
a1425 1
      read_enumeration (die, objfile);
d1428 1
a1428 1
      read_subroutine_type (die, objfile);
d1431 1
a1431 1
      read_array_type (die, objfile);
d1434 1
a1434 1
      read_tag_pointer_type (die, objfile);
d1437 1
a1437 1
      read_tag_ptr_to_member_type (die, objfile);
d1440 1
a1440 1
      read_tag_reference_type (die, objfile);
d1450 1
a1450 1
	  new_symbol (die, die->type, objfile);
d1454 1
a1454 1
      read_common_block (die, objfile);
d1459 1
a1459 1
      new_symbol (die, NULL, objfile);
d1465 2
a1466 3
read_file_scope (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d1561 1
a1561 1
      dwarf_decode_lines (line_offset, comp_dir, abfd);
d1570 1
a1570 1
	  process_die (child_die, objfile);
d1577 2
a1578 3
read_func_scope (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d1611 1
a1611 1
      CORE_ADDR addr = decode_locdesc (DW_BLOCK (attr), objfile);
d1626 1
a1626 1
  new->name = new_symbol (die, die->type, objfile);
d1634 1
a1634 1
	  process_die (child_die, objfile);
d1650 2
a1651 3
read_lexical_block_scope (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d1669 1
a1669 1
	  process_die (child_die, objfile);
d1730 3
a1732 4
dwarf2_add_field (fip, die, objfile)
     struct field_info *fip;
     struct die_info *die;
     struct objfile *objfile;
d1769 1
a1769 1
      fp->type = die_type (die, objfile);
d1787 1
a1787 1
	    decode_locdesc (DW_BLOCK (attr), objfile) * bits_per_byte;
d1867 1
a1867 1
      FIELD_TYPE (*fp) = die_type (die, objfile);
d1876 2
a1877 1
	FIELD_BITPOS (*fp) = decode_locdesc (DW_BLOCK (attr), objfile) * bits_per_byte;
d1879 1
a1879 1
      FIELD_TYPE (*fp) = die_type (die, objfile);
d1977 3
a1979 5
dwarf2_add_member_fn (fip, die, type, objfile)
     struct field_info *fip;
     struct die_info *die;
     struct type *type;
     struct objfile *objfile;
d2076 1
a2076 1
    fnp->fcontext = die_containing_type (die, objfile);
d2099 1
a2099 1
    fnp->voffset = decode_locdesc (DW_BLOCK (attr), objfile) + 2;
d2155 2
a2156 3
read_structure_scope (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2216 1
a2216 1
	      dwarf2_add_field (&fi, child_die, objfile);
d2221 1
a2221 1
	      dwarf2_add_field (&fi, child_die, objfile);
d2223 1
a2223 1
	  else if (child_die->tag == DW_TAG_subprogram)
d2226 2
a2227 2
	      process_die (child_die, objfile);
	      dwarf2_add_member_fn (&fi, child_die, type, objfile);
d2232 1
a2232 1
	      dwarf2_add_field (&fi, child_die, objfile);
d2236 1
a2236 1
	      process_die (child_die, objfile);
d2254 1
a2254 1
	      struct type *t = die_containing_type (die, objfile);
d2290 1
a2290 1
      new_symbol (die, type, objfile);
d2313 2
a2314 3
read_enumeration (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2354 1
a2354 1
	      process_die (child_die, objfile);
d2361 1
a2361 1
		  sym = new_symbol (child_die, type, objfile);
d2398 1
a2398 1
  new_symbol (die, type, objfile);
d2406 2
a2407 3
read_array_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2423 1
a2423 1
  element_type = die_type (die, objfile);
d2452 1
a2452 1
	  index_type = die_type (child_die, objfile);
d2544 2
a2545 3
read_common_block (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2555 1
a2555 1
      base = decode_locdesc (DW_BLOCK (attr), objfile);
d2562 1
a2562 1
	  sym = new_symbol (child_die, NULL, objfile);
d2567 1
a2567 1
		base + decode_locdesc (DW_BLOCK (attr), objfile);
d2579 2
a2580 3
read_tag_pointer_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2590 1
a2590 1
  type = lookup_pointer_type (die_type (die, objfile));
d2598 1
a2598 1
      TYPE_LENGTH (type) = address_size;
d2607 2
a2608 3
read_tag_ptr_to_member_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2620 2
a2621 2
  to_type = die_type (die, objfile);
  domain = die_containing_type (die, objfile);
d2631 2
a2632 3
read_tag_reference_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2642 1
a2642 1
  type = lookup_reference_type (die_type (die, objfile));
d2650 1
a2650 1
      TYPE_LENGTH (type) = address_size;
d2656 2
a2657 3
read_tag_const_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2665 1
a2665 1
  die->type = die_type (die, objfile);
d2669 2
a2670 3
read_tag_volatile_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2678 1
a2678 1
  die->type = die_type (die, objfile);
d2728 2
a2729 3
read_subroutine_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2740 1
a2740 1
  type = die_type (die, objfile);
d2788 2
a2789 1
	      TYPE_FIELD_TYPE (ftype, iparams) = die_type (child_die, objfile);
d2800 2
a2801 3
read_typedef (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d2810 1
a2810 1
      xtype = die_type (die, objfile);
d2903 2
a2904 3
read_comp_unit (info_ptr, abfd)
     char *info_ptr;
     bfd *abfd;
d2919 1
a2919 1
      cur_ptr = read_full_die (&die, abfd, cur_ptr);
d3132 3
a3134 5
read_partial_die (part_die, abfd, info_ptr, has_pc_info)
     struct partial_die_info *part_die;
     bfd *abfd;
     char *info_ptr;
     int *has_pc_info;
d3163 2
a3164 1
      info_ptr = read_attribute (&attr, &abbrev->attrs[i], abfd, info_ptr);
d3231 1
a3231 1
      read_partial_die (&spec_die, abfd, spec_ptr, &dummy);
d3262 2
a3263 4
read_full_die (diep, abfd, info_ptr)
     struct die_info **diep;
     bfd *abfd;
     char *info_ptr;
d3301 1
a3301 1
				 abfd, info_ptr);
d3311 3
a3313 5
read_attribute (attr, abbrev, abfd, info_ptr)
     struct attribute *attr;
     struct attr_abbrev *abbrev;
     bfd *abfd;
     char *info_ptr;
d3324 2
a3325 2
      DW_ADDR (attr) = read_address (abfd, info_ptr);
      info_ptr += address_size;
d3475 2
a3476 3
read_address (abfd, buf)
     bfd *abfd;
     char *buf;
d3480 18
a3497 1
  switch (address_size)
d3499 14
a3512 12
    case 2:
      retval = bfd_get_16 (abfd, (bfd_byte *) buf);
      break;
    case 4:
      retval = bfd_get_32 (abfd, (bfd_byte *) buf);
      break;
    case 8:
      retval = bfd_get_64 (abfd, (bfd_byte *) buf);
      break;
    default:
      /* *THE* alternative is 8, right? */
      abort ();
d3515 2
a3516 1
 return retval;
d3743 2
a3744 4
dwarf_decode_lines (offset, comp_dir, abfd)
     unsigned int offset;
     char *comp_dir;
     bfd *abfd;
d3892 3
a3894 2
		  address = read_address (abfd, line_ptr) + baseaddr;
		  line_ptr += address_size;
d4041 2
a4042 4
new_symbol (die, type, objfile)
     struct die_info *die;
     struct type *type;
     struct objfile *objfile;
d4067 1
a4067 1
	SYMBOL_TYPE (sym) = die_type (die, objfile);
d4118 1
a4118 1
	      dwarf2_const_value (attr, sym, objfile);
d4133 1
a4133 1
		    decode_locdesc (DW_BLOCK (attr), objfile);
d4154 1
a4154 1
		    decode_locdesc (DW_BLOCK (attr), objfile);
d4201 2
a4202 1
	      SYMBOL_VALUE (sym) = decode_locdesc (DW_BLOCK (attr), objfile);
d4229 1
a4229 1
	      dwarf2_const_value (attr, sym, objfile);
d4274 1
a4274 1
	      dwarf2_const_value (attr, sym, objfile);
d4293 3
a4295 4
dwarf2_const_value (attr, sym, objfile)
     struct attribute *attr;
     struct symbol *sym;
     struct objfile *objfile;
d4302 1
a4302 1
      if (TYPE_LENGTH (SYMBOL_TYPE (sym)) != (unsigned int) address_size)
d4304 1
a4304 1
		  address_size, TYPE_LENGTH (SYMBOL_TYPE (sym)));
d4306 3
a4308 2
	obstack_alloc (&objfile->symbol_obstack, address_size);
      store_address (SYMBOL_VALUE_BYTES (sym), address_size, DW_ADDR (attr));
d4388 2
a4389 3
die_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d4412 1
a4412 1
  type = tag_type_to_type (type_die, objfile);
d4425 2
a4426 3
die_containing_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d4443 1
a4443 1
      type = tag_type_to_type (type_die, objfile);
d4475 2
a4476 3
tag_type_to_type (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d4501 1
a4501 1
		  read_type_die (die, objfile);
d4507 1
a4507 1
	      read_type_die (die, objfile);
d4513 1
a4513 1
	  read_type_die (die, objfile);
d4526 2
a4527 3
read_type_die (die, objfile)
     struct die_info *die;
     struct objfile *objfile;
d4534 1
a4534 1
      read_structure_scope (die, objfile);
d4537 1
a4537 1
      read_enumeration (die, objfile);
d4541 1
a4541 1
      read_subroutine_type (die, objfile);
d4544 1
a4544 1
      read_array_type (die, objfile);
d4547 1
a4547 1
      read_tag_pointer_type (die, objfile);
d4550 1
a4550 1
      read_tag_ptr_to_member_type (die, objfile);
d4553 1
a4553 1
      read_tag_reference_type (die, objfile);
d4556 1
a4556 1
      read_tag_const_type (die, objfile);
d4559 1
a4559 1
      read_tag_volatile_type (die, objfile);
d4565 1
a4565 1
      read_typedef (die, objfile);
d5677 2
a5678 3
decode_locdesc (blk, objfile)
     struct dwarf_block *blk;
     struct objfile *objfile;
d5815 3
a5817 2
	  stack[++stacki] = read_address (objfile->obfd, &data[i]);
	  i += address_size;
@


1.10
log
@2000-06-14  Jim Blandy  <jimb@@redhat.com>

	* dwarf2read.c (dump_die): Use the proper printf format for
	printing DW_UNSND values; they're longs now.

	* dwarf2read.c (dump_die): We can read DW_FORM_data8 now, on
	at least some platforms, so print it out too.

2000-06-14  James E. Wilson  <wilson@@bletchleypark.cygnus.com>

	* dwarf2read.c (struct attribute): Change unsnd and snd field types
	to long.
	(read_8_bytes): Change return type to long.
	(read_unsigned_leb128): Change return type to long.  Change type of
	local result to long.  Cast argument of left shift to long.
	(read_signed_leb128): Likewise.
@
text
@d732 1
a732 1
static void dwarf2_empty_die_ref_table (void);
d2895 3
a2897 2
  /* Reset die reference table, we are building a new one now. */
  dwarf2_empty_die_ref_table ();
d5553 1
a5553 1
dwarf2_empty_die_ref_table ()
d5556 1
@


1.9
log
@C++ improvements
@
text
@d231 2
a232 2
	unsigned int unsnd;
	int snd;
d600 1
a600 1
static unsigned int read_8_bytes (bfd *, char *);
d608 1
a608 1
static unsigned int read_unsigned_leb128 (bfd *, char *, unsigned int *);
d610 1
a610 1
static int read_signed_leb128 (bfd *, char *, unsigned int *);
d3455 1
a3455 1
static unsigned int
d3552 1
a3552 1
static unsigned int
d3558 2
a3559 1
  unsigned int result, num_read;
d3572 1
a3572 1
      result |= ((byte & 127) << shift);
d3583 1
a3583 1
static int
d3589 1
a3589 1
  int result;
d3603 1
a3603 1
      result |= ((byte & 127) << shift);
d5495 1
d5501 1
a5501 1
	  fprintf (stderr, "constant: %d", DW_UNSND (&die->attrs[i]));
a5516 1
	case DW_FORM_data8:	/* we do not have 64 bit quantities */
@


1.8
log
@PARAMS removal.
@
text
@d38 1
d41 1
a41 1

d46 1
a46 1
/* .debug_info header for a compilation unit 
d271 5
d342 1
a342 1
/* This value is added to each symbol value.  FIXME:  Generalize to 
d3969 1
a3969 1
   files.files[0].name: list0.h         
d3971 1
a3971 1
   files.files[1].name: list0.c         
d4458 32
a4489 1
      read_type_die (die, objfile);
@


1.7
log
@Purge (almost) make_cleanup_func.
@
text
@d553 1
a553 1
static void dwarf2_locate_sections PARAMS ((bfd *, asection *, PTR));
d556 1
a556 1
static void dwarf2_build_psymtabs_easy PARAMS ((struct objfile *, int));
d559 1
a559 1
static void dwarf2_build_psymtabs_hard PARAMS ((struct objfile *, int));
d561 2
a562 2
static char *scan_partial_symbols PARAMS ((char *, struct objfile *,
					   CORE_ADDR *, CORE_ADDR *));
d564 1
a564 2
static void add_partial_symbol PARAMS ((struct partial_die_info *,
					struct objfile *));
d566 1
a566 1
static void dwarf2_psymtab_to_symtab PARAMS ((struct partial_symtab *));
d568 1
a568 1
static void psymtab_to_symtab_1 PARAMS ((struct partial_symtab *));
d570 1
a570 2
static char *dwarf2_read_section PARAMS ((struct objfile *, file_ptr,
					  unsigned int));
d572 1
a572 1
static void dwarf2_read_abbrevs PARAMS ((bfd *, unsigned int));
d574 1
a574 1
static void dwarf2_empty_abbrev_table PARAMS ((PTR));
d576 1
a576 1
static struct abbrev_info *dwarf2_lookup_abbrev PARAMS ((unsigned int));
d578 2
a579 2
static char *read_partial_die PARAMS ((struct partial_die_info *,
				       bfd *, char *, int *));
d581 1
a581 1
static char *read_full_die PARAMS ((struct die_info **, bfd *, char *));
d583 2
a584 2
static char *read_attribute PARAMS ((struct attribute *, struct attr_abbrev *,
				     bfd *, char *));
d586 1
a586 1
static unsigned int read_1_byte PARAMS ((bfd *, char *));
d588 1
a588 1
static int read_1_signed_byte PARAMS ((bfd *, char *));
d590 1
a590 1
static unsigned int read_2_bytes PARAMS ((bfd *, char *));
d592 1
a592 1
static unsigned int read_4_bytes PARAMS ((bfd *, char *));
d594 1
a594 1
static unsigned int read_8_bytes PARAMS ((bfd *, char *));
d596 1
a596 1
static CORE_ADDR read_address PARAMS ((bfd *, char *));
d598 1
a598 1
static char *read_n_bytes PARAMS ((bfd *, char *, unsigned int));
d600 1
a600 1
static char *read_string PARAMS ((bfd *, char *, unsigned int *));
d602 1
a602 2
static unsigned int read_unsigned_leb128 PARAMS ((bfd *, char *,
						  unsigned int *));
d604 1
a604 1
static int read_signed_leb128 PARAMS ((bfd *, char *, unsigned int *));
d606 1
a606 1
static void set_cu_language PARAMS ((unsigned int));
d608 1
a608 2
static struct attribute *dwarf_attr PARAMS ((struct die_info *,
					     unsigned int));
d612 1
a612 1
static void dwarf_decode_lines PARAMS ((unsigned int, char *, bfd *));
d614 1
a614 1
static void dwarf2_start_subfile PARAMS ((char *, char *));
d616 2
a617 2
static struct symbol *new_symbol PARAMS ((struct die_info *, struct type *,
					  struct objfile *));
d619 2
a620 2
static void dwarf2_const_value PARAMS ((struct attribute *, struct symbol *,
					struct objfile *));
d626 1
a626 1
static struct type *die_type PARAMS ((struct die_info *, struct objfile *));
d628 1
a628 2
static struct type *die_containing_type PARAMS ((struct die_info *,
						 struct objfile *));
d631 1
a631 1
static struct type *type_at_offset PARAMS ((unsigned int, struct objfile *));
d634 1
a634 2
static struct type *tag_type_to_type PARAMS ((struct die_info *,
					      struct objfile *));
d636 1
a636 1
static void read_type_die PARAMS ((struct die_info *, struct objfile *));
d638 1
a638 1
static void read_typedef PARAMS ((struct die_info *, struct objfile *));
d640 1
a640 1
static void read_base_type PARAMS ((struct die_info *, struct objfile *));
d642 1
a642 1
static void read_file_scope PARAMS ((struct die_info *, struct objfile *));
d644 1
a644 1
static void read_func_scope PARAMS ((struct die_info *, struct objfile *));
d646 1
a646 2
static void read_lexical_block_scope PARAMS ((struct die_info *,
					      struct objfile *));
d648 2
a649 3
static int dwarf2_get_pc_bounds PARAMS ((struct die_info *,
					 CORE_ADDR *, CORE_ADDR *,
					 struct objfile *));
d651 2
a652 2
static void dwarf2_add_field PARAMS ((struct field_info *, struct die_info *,
				      struct objfile *));
d654 2
a655 3
static void dwarf2_attach_fields_to_type PARAMS ((struct field_info *,
						  struct type *,
						  struct objfile *));
d657 3
a659 3
static void dwarf2_add_member_fn PARAMS ((struct field_info *,
					  struct die_info *, struct type *,
					  struct objfile * objfile));
d661 2
a662 3
static void dwarf2_attach_fn_fields_to_type PARAMS ((struct field_info *,
						     struct type *,
						     struct objfile *));
d664 1
a664 1
static void read_structure_scope PARAMS ((struct die_info *, struct objfile *));
d666 1
a666 1
static void read_common_block PARAMS ((struct die_info *, struct objfile *));
d668 1
a668 1
static void read_enumeration PARAMS ((struct die_info *, struct objfile *));
d670 1
a670 1
static struct type *dwarf_base_type PARAMS ((int, int, struct objfile *));
d672 1
a672 2
static CORE_ADDR decode_locdesc PARAMS ((struct dwarf_block *,
					 struct objfile *));
d674 1
a674 1
static void read_array_type PARAMS ((struct die_info *, struct objfile *));
d676 1
a676 2
static void read_tag_pointer_type PARAMS ((struct die_info *,
					   struct objfile *));
d678 1
a678 2
static void read_tag_ptr_to_member_type PARAMS ((struct die_info *,
						 struct objfile *));
d680 1
a680 2
static void read_tag_reference_type PARAMS ((struct die_info *,
					     struct objfile *));
d682 1
a682 1
static void read_tag_const_type PARAMS ((struct die_info *, struct objfile *));
d684 1
a684 2
static void read_tag_volatile_type PARAMS ((struct die_info *,
					    struct objfile *));
d686 1
a686 2
static void read_tag_string_type PARAMS ((struct die_info *,
					  struct objfile *));
d688 1
a688 2
static void read_subroutine_type PARAMS ((struct die_info *,
					  struct objfile *));
d690 1
a690 1
struct die_info *read_comp_unit PARAMS ((char *, bfd *));
d692 1
a692 1
static void free_die_list PARAMS ((struct die_info *));
d696 1
a696 1
static void process_die PARAMS ((struct die_info *, struct objfile *));
d698 1
a698 1
static char *dwarf2_linkage_name PARAMS ((struct die_info *));
d700 1
a700 1
static char *dwarf_tag_name PARAMS ((unsigned int));
d702 1
a702 1
static char *dwarf_attr_name PARAMS ((unsigned int));
d704 1
a704 1
static char *dwarf_form_name PARAMS ((unsigned int));
d706 1
a706 1
static char *dwarf_stack_op_name PARAMS ((unsigned int));
d708 1
a708 1
static char *dwarf_bool_name PARAMS ((unsigned int));
d710 1
a710 1
static char *dwarf_type_encoding_name PARAMS ((unsigned int));
d713 1
a713 1
static char *dwarf_cfi_name PARAMS ((unsigned int));
d715 1
a715 1
struct die_info *copy_die PARAMS ((struct die_info *));
d718 1
a718 1
struct die_info *sibling_die PARAMS ((struct die_info *));
d720 1
a720 1
void dump_die PARAMS ((struct die_info *));
d722 1
a722 1
void dump_die_list PARAMS ((struct die_info *));
d724 1
a724 1
void store_in_ref_table PARAMS ((unsigned int, struct die_info *));
d726 1
a726 1
static void dwarf2_empty_die_ref_table PARAMS ((void));
d728 1
a728 1
static unsigned int dwarf2_get_ref_die_offset PARAMS ((struct attribute *));
d730 1
a730 1
struct die_info *follow_die_ref PARAMS ((unsigned int));
d732 1
a732 1
static struct type *dwarf2_fundamental_type PARAMS ((struct objfile *, int));
d736 1
a736 1
static void dwarf2_free_tmp_obstack PARAMS ((PTR));
d738 1
a738 1
static struct dwarf_block *dwarf_alloc_block PARAMS ((void));
d740 1
a740 1
static struct abbrev_info *dwarf_alloc_abbrev PARAMS ((void));
d742 1
a742 1
static struct die_info *dwarf_alloc_die PARAMS ((void));
@


1.6
log
@Fix typo in sign extension code in dwarf2_const_value_data().
@
text
@d711 2
d1327 1
a1327 1
  make_cleanup ((make_cleanup_func) free_die_list, dies);
d2960 13
@


1.5
log
@	* ax-gdb.c (agent_command): Remove now useless cast of
	`free_current_contents' when passed to `make_cleanup'.
	* coffread.c (coff_symfile_read): Ditto.
	* dwarf2read.c (dwarf2_add_member_fn, read_array_type): Ditto.
	(dwarf_decode_lines): Ditto.
	* eval.c (parse_and_eval_address, parse_and_eval_address_1): Ditto.
	(parse_and_eval, parse_to_comma_and_eval): Ditto.
	* parse.c (parse_exp_1): Ditto.
	* printcmd.c (print_command_1, output_command, set_command): Ditto.
	(x_command, print_frame_args, printf_command): Ditto.
	* top.c (execute_control_command): Ditto.
	* tracepoint.c (validate_actionline): Ditto.
	* typeprint.c (whatis_exp, ptype_command): Ditto.
	(maintenance_print_type): Ditto.
@
text
@d4344 1
a4344 1
	l = (l << (sizeof (l) - bits)) >> (sizeof (l) - bits);
@


1.4
log
@* dwarf2read.c: Revert Andrew Cagney's change of Dec 15, 1997.
Don't include "bfd-elf.h".
(address_significant_size): Delete variable.
(dwarf2_build_psymtabs_hard): Don't set it, or check for
consistency between it and the Dwarf 2 compilation unit header
address size.
(read_address): Don't mask off bits above
address_significant_size.
* Makefile.in (dwarf2read.o): Don't depend on $(elf_bfd_h).
(elf_bfd_h): Remove variable; it's no longer used.
@
text
@d2001 1
a2001 2
	    make_cleanup ((make_cleanup_func) free_current_contents,
			  &fip->fnfieldlists);
d2508 1
a2508 2
		make_cleanup ((make_cleanup_func) free_current_contents,
			      &range_types);
d3761 1
a3761 2
  back_to = make_cleanup ((make_cleanup_func) free_current_contents,
			  &lh.standard_opcode_lengths);
d3780 1
a3780 1
	    make_cleanup ((make_cleanup_func) free_current_contents, &dirs.dirs);
d3797 1
a3797 2
	    make_cleanup ((make_cleanup_func) free_current_contents,
			  &files.files);
d3872 1
a3872 2
			make_cleanup ((make_cleanup_func) free_current_contents,
				      &files.files);
@


1.3
log
@Read 2 byte (16 bit addresses) when needed.
@
text
@a29 1
#include "elf-bfd.h"
a547 9
/* Some elf32 object file formats while linked for a 32 bit address
   space contain debug information that has assumed 64 bit
   addresses. Eg 64 bit MIPS target produced by GCC/GAS/LD where the
   symbol table contains 32bit address values while its .debug_info
   section contains 64 bit address values.
   ADDRESS_SIGNIFICANT_SIZE specifies the number significant bits in
   the ADDRESS_SIZE bytes read from the file */
static int address_significant_size;

a929 3
  /* Number of bytes of any addresses that are signficant */
  address_significant_size = get_elf_backend_data (abfd)->s->arch_size / 8;

a969 7
      if (address_size < address_significant_size)
	{
	  error ("Dwarf Error: bad address size (%ld) in compilation unit header (offset 0x%lx + 11).",
		 (long) cu_header.addr_size,
		 (long) (beg_of_comp_unit - dwarf_info_buffer));
	}

d3483 2
a3484 11
  /* If the address being read is larger than the address that is
     applicable for the object file format then mask it down to the
     correct size.  Take care to avoid unnecessary shift or shift
     overflow */
  if (address_size > address_significant_size
      && address_significant_size < sizeof (CORE_ADDR))
    {
      CORE_ADDR mask = ((CORE_ADDR) 0) - 1;
      retval &= ~(mask << (address_significant_size * 8));
    }
  return retval;
@


1.2
log
@From Jason Merrill: (die_is_declaration): New fn..
@
text
@d3490 3
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
This file is part of GDB.
d13 14
a26 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d211 9
a219 9
    enum dwarf_tag tag;		 /* Tag indicating type of die */
    unsigned short has_children; /* Does the die have children */
    unsigned int abbrev;	 /* Abbrev number */
    unsigned int offset;	 /* Offset in .debug_info section */
    unsigned int num_attrs;	 /* Number of attributes */
    struct attribute *attrs;	 /* An array of attributes */
    struct die_info *next_ref;	 /* Next die in ref hash table */
    struct die_info *next;	 /* Next die in linked list */
    struct type *type;		 /* Cached type information */
d306 22
a327 7
/* FIXME: The following variables pass additional information from
   decode_locdesc to the caller.  */
static int optimized_out;	/* Kludge to identify optimized out variables */
static int isreg;		/* Kludge to identify register variables */
static int offreg;		/* Kludge to identify basereg references */
static int basereg;		/* Which base register is it relative to?  */
static int islocal;		/* Kludge to identify local variables */
d352 2
a353 2
{
  /* Pointer to start of dwarf info buffer for the objfile.  */
d355 1
a355 1
  char *dwarf_info_buffer;
d357 1
a357 1
  /* Offset in dwarf_info_buffer for this compilation unit. */
d359 1
a359 1
  unsigned long dwarf_info_offset;
d361 1
a361 1
  /* Pointer to start of dwarf abbreviation buffer for the objfile.  */
d363 1
a363 1
  char *dwarf_abbrev_buffer;
d365 1
a365 1
  /* Size of dwarf abbreviation section for the objfile.  */
d367 1
a367 1
  unsigned int dwarf_abbrev_size;
d369 1
a369 1
  /* Pointer to start of dwarf line buffer for the objfile.  */
d371 2
a372 2
  char *dwarf_line_buffer;
};
d401 39
a439 36
{
  /* List of data member and baseclasses fields. */
  struct nextfield
    {
      struct nextfield *next;
      int accessibility;
      int virtuality;
      struct field field;
    } *fields;

  /* Number of fields.  */
  int nfields;

  /* Number of baseclasses.  */
  int nbaseclasses;

  /* Set if the accesibility of one of the fields is not public.  */
  int non_public_fields;

  /* Member function fields array, entries are allocated in the order they
     are encountered in the object file.  */
  struct nextfnfield
    {
      struct nextfnfield *next;
      struct fn_field fnfield;
    } *fnfields;

  /* Member function fieldlist array, contains name of possibly overloaded
     member function, number of overloaded member functions and a pointer
     to the head of the member function field chain.  */
  struct fnfieldlist
    {
      char *name;
      int length;
      struct nextfnfield *head;
    } *fnfieldlists;
d441 3
a443 3
  /* Number of entries in the fnfieldlists array.  */
  int nfnfields;
};
d486 4
d566 1
a566 3
static void dwarf2_build_psymtabs_easy PARAMS ((struct objfile *,
						struct section_offsets *,
						int));
d569 1
a569 3
static void dwarf2_build_psymtabs_hard PARAMS ((struct objfile *,
						struct section_offsets *,
						int));
d624 2
d636 4
d673 1
a673 1
						  struct type *, 
a675 2
static char *skip_member_fn_name PARAMS ((char *));

d678 1
a678 1
					  struct objfile *objfile));
d843 3
a845 4
dwarf2_build_psymtabs (objfile, section_offsets, mainline)
    struct objfile *objfile;
    struct section_offsets *section_offsets;
    int mainline;
d869 1
a869 1
      /* Things are significanlty easier if we have .debug_aranges and
d872 1
a872 1
      dwarf2_build_psymtabs_easy (objfile, section_offsets, mainline);
d877 1
a877 1
    {		
d879 1
a879 1
      dwarf2_build_psymtabs_hard (objfile, section_offsets, mainline);
d888 1
a888 1
dwarf2_build_psymtabs_easy (objfile, section_offsets, mainline)
a889 1
     struct section_offsets *section_offsets;
d924 1
a924 1
dwarf2_build_psymtabs_hard (objfile, section_offsets, mainline)
a925 1
     struct section_offsets *section_offsets;
d950 1
a950 1
	  + ((info_ptr - dwarf_info_buffer) % 4) < dwarf_info_size)
d1002 2
a1003 2
      pst = start_psymtab_common (objfile, section_offsets,
			          comp_unit_die.name ? comp_unit_die.name : "",
d1011 6
a1016 6
      DWARF_INFO_BUFFER(pst) = dwarf_info_buffer;
      DWARF_INFO_OFFSET(pst) = beg_of_comp_unit - dwarf_info_buffer;
      DWARF_ABBREV_BUFFER(pst) = dwarf_abbrev_buffer;
      DWARF_ABBREV_SIZE(pst) = dwarf_abbrev_size;
      DWARF_LINE_BUFFER(pst) = dwarf_line_buffer;
      baseaddr = ANOFFSET (section_offsets, 0);
d1032 1
a1032 1
	      comp_unit_die.lowpc  = lowpc;
d1036 1
a1036 1
      pst->textlow  = comp_unit_die.lowpc + baseaddr;
d1075 2
a1076 2
  
  *lowpc  = ((CORE_ADDR) -1);
d1119 1
a1119 1
		 table.  */
d1125 1
a1125 1
		 symbol table.  */
d1135 2
a1136 2
	 Do not skip enumeration types, we want to record their
	 enumerators.  */
d1174 1
a1174 1
				      mst_text, objfile);*/
d1178 1
a1178 1
			       0, pdi->lowpc + baseaddr, cu_language, objfile);
d1183 1
a1183 1
				      mst_file_text, objfile);*/
d1187 1
a1187 1
			       0, pdi->lowpc + baseaddr, cu_language, objfile);
d1221 1
a1221 1
				      mst_file_data, objfile);*/
d1240 1
a1240 1
	 references.  */
d1314 5
a1318 5
  offset = DWARF_INFO_OFFSET(pst);
  dwarf_info_buffer = DWARF_INFO_BUFFER(pst);
  dwarf_abbrev_buffer = DWARF_ABBREV_BUFFER(pst);
  dwarf_abbrev_size = DWARF_ABBREV_SIZE(pst);
  dwarf_line_buffer = DWARF_LINE_BUFFER(pst);
d1327 1
a1327 1
  make_cleanup ((make_cleanup_func) really_free_pendings, NULL);
d1353 2
a1354 2
	 the compilation unit.   If the DW_AT_high_pc is missing,
	 synthesize it, by scanning the DIE's below the compilation unit.  */
d1411 2
a1412 2
	 They could be used to set breakpoints on all inlined instances
	 of a function and make GDB `next' properly over inlined functions.  */
d1468 1
a1468 1
  CORE_ADDR lowpc  = ((CORE_ADDR) -1);
d1541 2
a1542 2
    /* FIXME:Do something here.  */
    if (dip->at_producer != NULL)
a1603 6
  if (STREQ (name, "main"))	/* FIXME: hardwired name */
    {
      objfile->ei.main_func_lowpc = lowpc;
      objfile->ei.main_func_highpc = highpc;
    }

d1612 3
a1614 1
      if (isreg)
d1799 4
a1802 4
		 additional bit offset from the MSB of the containing
		 anonymous object to the MSB of the field.  We don't
		 have to do anything special since we don't need to
		 know the size of the anonymous object.  */
d1808 5
a1812 5
		 MSB of the anonymous object, subtract off the number of
		 bits from the MSB of the field to the MSB of the
		 object, and then subtract off the number of bits of
		 the field itself.  The result is the bit offset of
		 the LSB of the field.  */
d1845 1
a1845 1
	 pointer or virtual base class pointer) to private.  */
a1854 1
      char *cp;
d1857 5
a1861 3
	 Get physical name, extract field name from physical name.  */
      physname = dwarf2_linkage_name (die);
      if (physname == NULL)
d1864 2
a1865 9
      cp = physname;
      while (*cp && !is_cplus_marker (*cp))
	cp++;
      if (*cp)
	fieldname = cp + 1;
      if (*fieldname == '\0')
	{
	  complain (&dwarf2_bad_static_member_name, physname);
	}
d1868 1
a1868 1
					    &objfile->type_obstack));
d1871 1
a1871 1
			       &objfile->type_obstack);
d1942 3
a1944 7
	  case DW_ACCESS_private:
	    SET_TYPE_FIELD_PRIVATE (type, nfields);
	    break;

	  case DW_ACCESS_protected:
	    SET_TYPE_FIELD_PROTECTED (type, nfields);
	    break;
d1946 3
a1948 2
	  case DW_ACCESS_public:
	    break;
d1950 10
a1959 7
	  default:
	    /* Unknown accessibility.  Complain and treat it as public.  */
	    {
	      complain (&dwarf2_unsupported_accessibility,
			fip->fields->accessibility);
	    }
	    break;
d1965 4
a1968 4
	      case DW_VIRTUALITY_virtual:
	      case DW_VIRTUALITY_pure_virtual:
		SET_TYPE_FIELD_VIRTUAL (type, nfields);
		break;
a1974 31
/* Skip to the end of a member function name in a mangled name.  */

static char *
skip_member_fn_name (physname)
     char *physname;
{
  char *endname = physname;

  /* Skip over leading underscores.  */
  while (*endname == '_')
    endname++;

  /* Find two succesive underscores.  */
  do
    endname = strchr (endname, '_');
  while (endname != NULL && *++endname != '_');

  if (endname == NULL)
    {
      complain (&dwarf2_bad_member_name_complaint, physname);
      endname = physname;
    }
  else
    {
      /* Take care of trailing underscores.  */
      if (endname[1] != '_')
        endname--;
    }
  return endname;
}

d1992 5
a1996 3
  /* Extract member function name from mangled name.  */
  physname = dwarf2_linkage_name (die);
  if (physname == NULL)
a1997 10
  if ((physname[0] == '_' && physname[1] == '_'
        && strchr ("0123456789Qt", physname[2]))
      || DESTRUCTOR_PREFIX_P (physname))
    {
      /* Constructor and destructor field names are set to the name
	 of the class, but without template parameter lists.
	 The name might be missing for anonymous aggregates.  */
      if (TYPE_TAG_NAME (type))
	{
	  char *p = strchr (TYPE_TAG_NAME (type), '<');
d1999 2
a2000 25
	  if (p == NULL)
	    fieldname = TYPE_TAG_NAME (type);
	  else
	    fieldname = obsavestring (TYPE_TAG_NAME (type),
				      p - TYPE_TAG_NAME (type),
				      &objfile->type_obstack);
	}
      else
	{
	  char *anon_name = "";
	  fieldname = obsavestring (anon_name, strlen (anon_name),
				    &objfile->type_obstack);
	}
    }
  else
    {
      char *endname = skip_member_fn_name (physname);

      /* Ignore member function if we were unable not extract the member
	 function name.  */
      if (endname == physname)
	return;
      fieldname = obsavestring (physname, endname - physname,
				&objfile->type_obstack);
    }
d2019 1
a2019 1
		        * sizeof (struct fnfieldlist));
d2021 2
a2022 2
	    make_cleanup ((make_cleanup_func) free_current_contents, 
                          &fip->fnfieldlists);
d2067 5
a2071 5
	 Dwarf2 has no clean way to discern C++ static and non-static
	 member functions. G++ helps GDB by marking the first
	 parameter for non-static member functions (which is the
	 this pointer) as artificial. We obtain this information
	 from read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
d2091 6
a2096 6
	  case DW_ACCESS_private:
	    fnp->is_private = 1;
	    break;
	  case DW_ACCESS_protected:
	    fnp->is_protected = 1;
	    break;
d2133 1
a2133 1
        fn_flp->fn_fields[k] = nfp->fnfield;
d2188 1
a2188 1
	 in gdbtypes.h.  */
d2207 1
a2207 1
  if (die->has_children)
d2253 1
a2253 1
          /* Get the type which refers to the base class (possibly this
d2264 2
a2265 1
		  static const char vptr_name[] = { '_','v','p','t','r','\0' };
d2286 1
a2286 1
			      TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) : "");
d2376 1
a2376 1
				    * sizeof (struct field));
d2468 3
a2470 3
	               || attr->form == DW_FORM_data1
	               || attr->form == DW_FORM_data2
	               || attr->form == DW_FORM_data4)
d2494 3
a2496 3
	               || attr->form == DW_FORM_data1
	               || attr->form == DW_FORM_data2
	               || attr->form == DW_FORM_data4)
d2527 1
a2527 1
				         * sizeof (struct type *));
d2529 2
a2530 2
		make_cleanup ((make_cleanup_func) free_current_contents, 
                              &range_types);
d2733 4
a2736 4
     {
       int (*funcp)(int a, long l);
       int b;
     };
d2739 1
a2739 1
*/
d2794 4
a2797 4
		 member functions. G++ helps GDB by marking the first
		 parameter for non-static member functions (which is the
		 this pointer) as artificial. We pass this information
		 to dwarf2_add_member_fn via TYPE_FIELD_ARTIFICIAL.  */
d2919 2
a2920 2
    char *info_ptr;
    bfd *abfd;
d3002 1
a3002 1
        bfd_get_filename (abfd));
d3014 1
a3014 1
     bfd * abfd;
d3053 1
a3053 1
			    * sizeof (struct attr_abbrev));
d3069 5
a3073 5
	 always properly terminated with an abbrev number of 0.
	 Exit loop if we encounter an abbreviation which we have
	 already read (which means we are about to read the abbreviations
	 for the next compile unit) or if the end of the abbreviation
	 table is reached.  */
d3075 1
a3075 1
	    >= dwarf_abbrev_size)
d3136 1
a3136 1
     bfd * abfd;
d3145 1
a3145 1
  int has_low_pc_attr  = 0;
d3170 1
a3170 1
	 partial symbol table.  */
d3214 1
a3214 1
	    complain(&dwarf2_absolute_sibling_complaint);
d3515 1
a3515 1
     bfd * abfd;
d3696 1
a3696 1
	follow_die_ref (dwarf2_get_ref_die_offset (spec));
d3701 1
a3701 1
    
d3705 7
d3720 7
a3726 7
  {
    char *name;
    unsigned int dir;
    unsigned int time;
    unsigned int size;
  }
  *files;
d3730 4
a3733 4
{
  unsigned int num_dirs;
  char **dirs;
};
d3789 2
a3790 2
  back_to = make_cleanup ((make_cleanup_func) free_current_contents, 
                          &lh.standard_opcode_lengths);
d3824 1
a3824 1
			* sizeof (struct fileinfo));
d3826 2
a3827 2
	    make_cleanup ((make_cleanup_func) free_current_contents, 
                          &files.files);
d3867 1
a3867 1
      while (! end_sequence)
d3881 6
a3886 1
		  record_line (current_subfile, line, address);
d3900 1
a3900 1
				    * sizeof (struct fileinfo));
d3902 2
a3903 2
			make_cleanup ((make_cleanup_func) free_current_contents, 
                                      &files.files);
d3937 1
a3937 1
		 are 1 based.  */
d3956 5
d3962 2
a3963 1
	      address += (255 - lh.opcode_base) / lh.line_range;
d3994 6
a3999 6
	DW_AT_name:		/srcdir/list0.c
	DW_AT_comp_dir:		/compdir
	files.files[0].name:	list0.h		
	files.files[0].dir:	/srcdir
	files.files[1].name:	list0.c		
	files.files[1].dir:	/srcdir
d4035 1
a4035 2
   used the passed type.
  */
d4060 1
a4060 1
	 Use the passed type or decode it from the die.  */
d4135 1
a4135 1
	 	  /* In shared libraries the address of the variable
d4182 5
a4186 5
		 If it is an external symbol and we have type information
		 for it, enter the symbol as a LOC_UNRESOLVED symbol.
		 The address of the variable will then be determined from
		 the minimal symbol table whenever the variable is
		 referenced.  */
d4207 11
a4217 2
		  SYMBOL_CLASS (sym) = LOC_BASEREG_ARG;
		  SYMBOL_BASEREG (sym) = basereg;
d4250 2
a4251 2
		obstack_alloc (&objfile->symbol_obstack,
			       sizeof (struct symbol));
d4322 9
d4332 2
d4335 2
d4338 3
a4340 1
    case DW_FORM_data1:
d4342 4
d4350 1
d4360 23
d5500 1
a5500 1
		     ? DW_STRING (&die->attrs[i]) : "");
d5514 1
a5514 1
			   die->attrs[i].form);
d5642 1
a5642 1
 
d5664 1
d5761 8
d5822 1
a5822 1
							 &bytes_read);
d5846 8
d5855 1
a5855 1
	  complain (&dwarf2_unsupported_stack_op, dwarf_stack_op_name(op));
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@d305 7
a311 22
/* FIXME: decode_locdesc sets these variables to describe the location
   to the caller.  These ought to be a structure or something.   If
   none of the flags are set, the object lives at the address returned
   by decode_locdesc.  */

static int optimized_out;	/* No ops in location in expression,
				   so object was optimized out.  */
static int isreg;		/* Object lives in register.
				   decode_locdesc's return value is
				   the register number.  */
static int offreg;		/* Object's address is the sum of the
				   register specified by basereg, plus
				   the offset returned.  */
static int basereg;	        /* See `offreg'.  */
static int isderef;		/* Value described by flags above is
				   the address of a pointer to the object.  */
static int islocal;		/* Variable is at the returned offset
				   from the frame start, but there's
				   no identified frame pointer for
				   this function, so we can't say
				   which register it's relative to;
				   use LOC_LOCAL.  */
a466 4
static struct complaint dwarf2_complex_location_expr =
{
  "location expression too complex", 0, 0
};
d1598 1
a1598 3
      if (isderef)
	complain (&dwarf2_unsupported_at_frame_base, name);
      else if (isreg)
d3925 1
a3925 6
		  /* Don't call record_line here.  The end_sequence
		     instruction provides the address of the first byte
		     *after* the last line in the sequence; it's not the
		     address of any real source line.  However, the GDB
		     linetable structure only records the starts of lines,
		     not the ends.  This is a weakness of GDB.  */
d4241 2
a4242 11
		  if (isderef)
		    {
		      if (basereg != frame_base_reg)
			complain (&dwarf2_complex_location_expr);
		      SYMBOL_CLASS (sym) = LOC_REF_ARG;
		    }
		  else
		    {
		      SYMBOL_CLASS (sym) = LOC_BASEREG_ARG;
		      SYMBOL_BASEREG (sym) = basereg;
		    }
a5645 1
  isderef = 0;
a5816 8
	  break;

	case DW_OP_deref:
	  isderef = 1;
	  /* If we're not the last op, then we definitely can't encode
             this using GDB's address_class enum.  */
	  if (i < size)
	    complain (&dwarf2_complex_location_expr);
@


1.1.1.3
log
@import gdb-1999-07-07 post reformat
@
text
@d11 1
a11 1
   This file is part of GDB.
d13 13
a25 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d210 9
a218 9
    enum dwarf_tag tag;		/* Tag indicating type of die */
    unsigned short has_children;	/* Does the die have children */
    unsigned int abbrev;	/* Abbrev number */
    unsigned int offset;	/* Offset in .debug_info section */
    unsigned int num_attrs;	/* Number of attributes */
    struct attribute *attrs;	/* An array of attributes */
    struct die_info *next_ref;	/* Next die in ref hash table */
    struct die_info *next;	/* Next die in linked list */
    struct type *type;		/* Cached type information */
d318 1
a318 1
static int basereg;		/* See `offreg'.  */
d351 2
a352 2
  {
    /* Pointer to start of dwarf info buffer for the objfile.  */
d354 1
a354 1
    char *dwarf_info_buffer;
d356 1
a356 1
    /* Offset in dwarf_info_buffer for this compilation unit. */
d358 1
a358 1
    unsigned long dwarf_info_offset;
d360 1
a360 1
    /* Pointer to start of dwarf abbreviation buffer for the objfile.  */
d362 1
a362 1
    char *dwarf_abbrev_buffer;
d364 1
a364 1
    /* Size of dwarf abbreviation section for the objfile.  */
d366 1
a366 1
    unsigned int dwarf_abbrev_size;
d368 1
a368 1
    /* Pointer to start of dwarf line buffer for the objfile.  */
d370 2
a371 2
    char *dwarf_line_buffer;
  };
d400 36
a435 10
  {
    /* List of data member and baseclasses fields. */
    struct nextfield
      {
	struct nextfield *next;
	int accessibility;
	int virtuality;
	struct field field;
      }
     *fields;
d437 3
a439 32
    /* Number of fields.  */
    int nfields;

    /* Number of baseclasses.  */
    int nbaseclasses;

    /* Set if the accesibility of one of the fields is not public.  */
    int non_public_fields;

    /* Member function fields array, entries are allocated in the order they
       are encountered in the object file.  */
    struct nextfnfield
      {
	struct nextfnfield *next;
	struct fn_field fnfield;
      }
     *fnfields;

    /* Member function fieldlist array, contains name of possibly overloaded
       member function, number of overloaded member functions and a pointer
       to the head of the member function field chain.  */
    struct fnfieldlist
      {
	char *name;
	int length;
	struct nextfnfield *head;
      }
     *fnfieldlists;

    /* Number of entries in the fnfieldlists array.  */
    int nfnfields;
  };
d667 1
a667 1
						  struct type *,
d674 1
a674 1
					  struct objfile * objfile));
d840 3
a842 3
     struct objfile *objfile;
     struct section_offsets *section_offsets;
     int mainline;
d874 1
a874 1
    {
d949 1
a949 1
	 + ((info_ptr - dwarf_info_buffer) % 4) < dwarf_info_size)
d1002 1
a1002 1
			       comp_unit_die.name ? comp_unit_die.name : "",
d1010 5
a1014 5
      DWARF_INFO_BUFFER (pst) = dwarf_info_buffer;
      DWARF_INFO_OFFSET (pst) = beg_of_comp_unit - dwarf_info_buffer;
      DWARF_ABBREV_BUFFER (pst) = dwarf_abbrev_buffer;
      DWARF_ABBREV_SIZE (pst) = dwarf_abbrev_size;
      DWARF_LINE_BUFFER (pst) = dwarf_line_buffer;
d1031 1
a1031 1
	      comp_unit_die.lowpc = lowpc;
d1035 1
a1035 1
      pst->textlow = comp_unit_die.lowpc + baseaddr;
d1074 2
a1075 2

  *lowpc = ((CORE_ADDR) - 1);
d1118 1
a1118 1
	         table.  */
d1124 1
a1124 1
	         symbol table.  */
d1134 2
a1135 2
         Do not skip enumeration types, we want to record their
         enumerators.  */
d1155 1
a1155 1
  if (*lowpc == ((CORE_ADDR) - 1))
d1173 1
a1173 1
	     mst_text, objfile); */
d1177 1
a1177 1
			    0, pdi->lowpc + baseaddr, cu_language, objfile);
d1182 1
a1182 1
	     mst_file_text, objfile); */
d1186 1
a1186 1
			    0, pdi->lowpc + baseaddr, cu_language, objfile);
d1220 1
a1220 1
	     mst_file_data, objfile); */
d1239 1
a1239 1
         references.  */
d1313 5
a1317 5
  offset = DWARF_INFO_OFFSET (pst);
  dwarf_info_buffer = DWARF_INFO_BUFFER (pst);
  dwarf_abbrev_buffer = DWARF_ABBREV_BUFFER (pst);
  dwarf_abbrev_size = DWARF_ABBREV_SIZE (pst);
  dwarf_line_buffer = DWARF_LINE_BUFFER (pst);
d1352 2
a1353 2
         the compilation unit.   If the DW_AT_high_pc is missing,
         synthesize it, by scanning the DIE's below the compilation unit.  */
d1410 2
a1411 2
         They could be used to set breakpoints on all inlined instances
         of a function and make GDB `next' properly over inlined functions.  */
d1467 1
a1467 1
  CORE_ADDR lowpc = ((CORE_ADDR) - 1);
d1499 1
a1499 1
  if (lowpc == ((CORE_ADDR) - 1))
d1540 2
a1541 2
  /* FIXME:Do something here.  */
  if (dip->at_producer != NULL)
d1804 4
a1807 4
	         additional bit offset from the MSB of the containing
	         anonymous object to the MSB of the field.  We don't
	         have to do anything special since we don't need to
	         know the size of the anonymous object.  */
d1813 5
a1817 5
	         MSB of the anonymous object, subtract off the number of
	         bits from the MSB of the field to the MSB of the
	         object, and then subtract off the number of bits of
	         the field itself.  The result is the bit offset of
	         the LSB of the field.  */
d1850 1
a1850 1
         pointer or virtual base class pointer) to private.  */
d1863 1
a1863 1
         Get physical name, extract field name from physical name.  */
d1879 1
a1879 1
					     &objfile->type_obstack));
d1882 1
a1882 1
				       &objfile->type_obstack);
d1953 7
a1959 3
	case DW_ACCESS_private:
	  SET_TYPE_FIELD_PRIVATE (type, nfields);
	  break;
d1961 2
a1962 3
	case DW_ACCESS_protected:
	  SET_TYPE_FIELD_PROTECTED (type, nfields);
	  break;
d1964 7
a1970 10
	case DW_ACCESS_public:
	  break;

	default:
	  /* Unknown accessibility.  Complain and treat it as public.  */
	  {
	    complain (&dwarf2_unsupported_accessibility,
		      fip->fields->accessibility);
	  }
	  break;
d1976 4
a1979 4
	    case DW_VIRTUALITY_virtual:
	    case DW_VIRTUALITY_pure_virtual:
	      SET_TYPE_FIELD_VIRTUAL (type, nfields);
	      break;
d2012 1
a2012 1
	endname--;
d2039 1
a2039 1
       && strchr ("0123456789Qt", physname[2]))
d2043 2
a2044 2
         of the class, but without template parameter lists.
         The name might be missing for anonymous aggregates.  */
d2068 1
a2068 1
         function name.  */
d2092 1
a2092 1
		      * sizeof (struct fnfieldlist));
d2094 2
a2095 2
	    make_cleanup ((make_cleanup_func) free_current_contents,
			  &fip->fnfieldlists);
d2140 5
a2144 5
         Dwarf2 has no clean way to discern C++ static and non-static
         member functions. G++ helps GDB by marking the first
         parameter for non-static member functions (which is the
         this pointer) as artificial. We obtain this information
         from read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
d2164 6
a2169 6
	case DW_ACCESS_private:
	  fnp->is_private = 1;
	  break;
	case DW_ACCESS_protected:
	  fnp->is_protected = 1;
	  break;
d2206 1
a2206 1
	fn_flp->fn_fields[k] = nfp->fnfield;
d2261 1
a2261 1
         in gdbtypes.h.  */
d2326 1
a2326 1
	  /* Get the type which refers to the base class (possibly this
d2337 1
a2337 2
		  static const char vptr_name[] =
		  {'_', 'v', 'p', 't', 'r', '\0'};
d2358 1
a2358 1
			  TYPE_TAG_NAME (type) ? TYPE_TAG_NAME (type) : "");
d2448 1
a2448 1
				  * sizeof (struct field));
d2540 3
a2542 3
		       || attr->form == DW_FORM_data1
		       || attr->form == DW_FORM_data2
		       || attr->form == DW_FORM_data4)
d2566 3
a2568 3
		       || attr->form == DW_FORM_data1
		       || attr->form == DW_FORM_data2
		       || attr->form == DW_FORM_data4)
d2599 1
a2599 1
			  * sizeof (struct type *));
d2601 2
a2602 2
		make_cleanup ((make_cleanup_func) free_current_contents,
			      &range_types);
d2805 4
a2808 4
   {
   int (*funcp)(int a, long l);
   int b;
   };
d2811 1
a2811 1
 */
d2866 4
a2869 4
	         member functions. G++ helps GDB by marking the first
	         parameter for non-static member functions (which is the
	         this pointer) as artificial. We pass this information
	         to dwarf2_add_member_fn via TYPE_FIELD_ARTIFICIAL.  */
d2991 2
a2992 2
     char *info_ptr;
     bfd *abfd;
d3074 1
a3074 1
	     bfd_get_filename (abfd));
d3086 1
a3086 1
     bfd *abfd;
d3125 1
a3125 1
			  * sizeof (struct attr_abbrev));
d3141 5
a3145 5
         always properly terminated with an abbrev number of 0.
         Exit loop if we encounter an abbreviation which we have
         already read (which means we are about to read the abbreviations
         for the next compile unit) or if the end of the abbreviation
         table is reached.  */
d3147 1
a3147 1
	  >= dwarf_abbrev_size)
d3208 1
a3208 1
     bfd *abfd;
d3217 1
a3217 1
  int has_low_pc_attr = 0;
d3242 1
a3242 1
         partial symbol table.  */
d3286 1
a3286 1
	    complain (&dwarf2_absolute_sibling_complaint);
d3587 1
a3587 1
     bfd *abfd;
d3768 1
a3768 1
      follow_die_ref (dwarf2_get_ref_die_offset (spec));
d3773 1
a3773 1

d3785 7
a3791 7
    {
      char *name;
      unsigned int dir;
      unsigned int time;
      unsigned int size;
    }
   *files;
d3795 4
a3798 4
  {
    unsigned int num_dirs;
    char **dirs;
  };
d3854 2
a3855 2
  back_to = make_cleanup ((make_cleanup_func) free_current_contents,
			  &lh.standard_opcode_lengths);
d3889 1
a3889 1
		      * sizeof (struct fileinfo));
d3891 2
a3892 2
	    make_cleanup ((make_cleanup_func) free_current_contents,
			  &files.files);
d3932 1
a3932 1
      while (!end_sequence)
d3965 1
a3965 1
				  * sizeof (struct fileinfo));
d3967 2
a3968 2
			make_cleanup ((make_cleanup_func) free_current_contents,
				      &files.files);
d4002 1
a4002 1
	         are 1 based.  */
d4053 6
a4058 6
   DW_AT_name:          /srcdir/list0.c
   DW_AT_comp_dir:              /compdir
   files.files[0].name: list0.h         
   files.files[0].dir:  /srcdir
   files.files[1].name: list0.c         
   files.files[1].dir:  /srcdir
d4095 1
a4095 1
 */
d4120 1
a4120 1
         Use the passed type or decode it from the die.  */
d4195 1
a4195 1
		  /* In shared libraries the address of the variable
d4242 5
a4246 5
	         If it is an external symbol and we have type information
	         for it, enter the symbol as a LOC_UNRESOLVED symbol.
	         The address of the variable will then be determined from
	         the minimal symbol table whenever the variable is
	         referenced.  */
d4310 2
a4311 2
	      obstack_alloc (&objfile->symbol_obstack,
			     sizeof (struct symbol));
d5517 1
a5517 1
		   ? DW_STRING (&die->attrs[i]) : "");
d5531 1
a5531 1
		   die->attrs[i].form);
d5659 1
a5659 1

d5831 1
a5831 1
						  &bytes_read);
d5858 1
a5858 1
	     this using GDB's address_class enum.  */
d5864 1
a5864 1
	  complain (&dwarf2_unsupported_stack_op, dwarf_stack_op_name (op));
@


1.1.1.4
log
@import gdb-1999-08-02 snapshot
@
text
@d1330 1
a1330 1
  make_cleanup (really_free_pendings, NULL);
@


1.1.1.5
log
@import gdb-1999-08-09 snapshot
@
text
@d1006 1
a1006 1
				  comp_unit_die.name ? comp_unit_die.name : "",
@


1.1.1.6
log
@import gdb-1999-09-08 snapshot
@
text
@d566 3
a568 1
static void dwarf2_build_psymtabs_easy PARAMS ((struct objfile *, int));
d571 3
a573 1
static void dwarf2_build_psymtabs_hard PARAMS ((struct objfile *, int));
d843 1
a843 1
dwarf2_build_psymtabs (objfile, mainline)
d845 1
d870 1
a870 1
      /* Things are significantly easier if we have .debug_aranges and
d873 1
a873 1
      dwarf2_build_psymtabs_easy (objfile, mainline);
d880 1
a880 1
      dwarf2_build_psymtabs_hard (objfile, mainline);
d889 1
a889 1
dwarf2_build_psymtabs_easy (objfile, mainline)
d891 1
d926 1
a926 1
dwarf2_build_psymtabs_hard (objfile, mainline)
d928 1
d1005 1
a1005 1
      pst = start_psymtab_common (objfile, objfile->section_offsets,
d1019 1
a1019 1
      baseaddr = ANOFFSET (objfile->section_offsets, 0);
@


1.1.1.7
log
@import gdb-1999-09-21
@
text
@a4018 5
	    /* Add to the address register of the state machine the
	       address increment value corresponding to special opcode
	       255.  Ie, this value is scaled by the minimum instruction
	       length since special opcode 255 would have scaled the
	       the increment.  */
d4020 1
a4020 2
	      address += (lh.minimum_instruction_length
			  * ((255 - lh.opcode_base) / lh.line_range));
@


1.1.1.8
log
@import gdb-1999-10-04 snapshot
@
text
@d1072 1
a1072 1
  *lowpc = ((CORE_ADDR) -1);
d1152 1
a1152 1
  if (*lowpc == ((CORE_ADDR) -1))
d1464 1
a1464 1
  CORE_ADDR lowpc = ((CORE_ADDR) -1);
d1496 1
a1496 1
  if (lowpc == ((CORE_ADDR) -1))
@


1.1.1.9
log
@import gdb-1999-10-11 snapshot
@
text
@a633 4
static void dwarf2_const_value_data (struct attribute *attr,
				     struct symbol *sym,
				     int bits);

d670 2
d1600 6
d1857 1
d1860 3
a1862 5
	 Get name of field.  */
      attr = dwarf_attr (die, DW_AT_name);
      if (attr && DW_STRING (attr))
	fieldname = DW_STRING (attr);
      else
d1865 9
a1873 2
      /* Get physical name.  */
      physname = dwarf2_linkage_name (die);
d1983 31
d2031 29
a2059 4
  /* Get name of member function.  */
  attr = dwarf_attr (die, DW_AT_name);
  if (attr && DW_STRING (attr))
    fieldname = DW_STRING (attr);
d2061 2
a2062 1
    return;
d2064 7
a2070 2
  /* Get the mangled name.  */
  physname = dwarf2_linkage_name (die);
d4098 2
a4099 1
   used the passed type.  */
a4385 9

      /* The DW_AT_const_value attributes are supposed to carry the
	 symbol's value "represented as it would be on the target
	 architecture."  By the time we get here, it's already been
	 converted to host endianness, so we just need to sign- or
	 zero-extend it as appropriate.  */
    case DW_FORM_data1:
      dwarf2_const_value_data (attr, sym, 8);
      break;
a4386 2
      dwarf2_const_value_data (attr, sym, 16);
      break;
a4387 2
      dwarf2_const_value_data (attr, sym, 32);
      break;
d4389 1
a4389 3
      dwarf2_const_value_data (attr, sym, 64);
      break;

a4390 4
      SYMBOL_VALUE (sym) = DW_SND (attr);
      SYMBOL_CLASS (sym) = LOC_CONST;
      break;

a4394 1

a4402 23


/* Given an attr with a DW_FORM_dataN value in host byte order, sign-
   or zero-extend it as appropriate for the symbol's type.  */
static void
dwarf2_const_value_data (struct attribute *attr,
			 struct symbol *sym,
			 int bits)
{
  LONGEST l = DW_UNSND (attr);

  if (bits < sizeof (l) * 8)
    {
      if (TYPE_UNSIGNED (SYMBOL_TYPE (sym)))
	l &= ((LONGEST) 1 << bits) - 1;
      else
	l = (l << (sizeof (l) - bits)) >> (sizeof (l) - bits);
    }

  SYMBOL_VALUE (sym) = l;
  SYMBOL_CLASS (sym) = LOC_CONST;
}

@


1.1.1.10
log
@import gdb-2000-02-04 snapshot
@
text
@a5751 8
	case DW_OP_bregx:
	  offreg = 1;
	  basereg = read_unsigned_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  stack[++stacki] = read_signed_leb128 (NULL, (data + i), &bytes_read);
	  i += bytes_read;
	  break;

@


