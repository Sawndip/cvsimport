head	1.79;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.68.2.1
	gdb_7_6-2013-04-26-release:1.68.2.1
	gdb_7_6-branch:1.68.0.2
	gdb_7_6-2013-03-12-branchpoint:1.68
	gdb_7_5_1-2012-11-29-release:1.51
	gdb_7_5-2012-08-17-release:1.51
	gdb_7_5-branch:1.51.0.2
	gdb_7_5-2012-07-18-branchpoint:1.51
	gdb_7_4_1-2012-04-26-release:1.36.2.1
	gdb_7_4-2012-01-24-release:1.36.2.1
	gdb_7_4-branch:1.36.0.2
	gdb_7_4-2011-12-13-branchpoint:1.36
	gdb_7_3_1-2011-09-04-release:1.26.2.1
	gdb_7_3-2011-07-26-release:1.26.2.1
	gdb_7_3-branch:1.26.0.2
	gdb_7_3-2011-04-01-branchpoint:1.26
	gdb_7_2-2010-09-02-release:1.5.2.1
	gdb_7_2-branch:1.5.0.2
	gdb_7_2-2010-07-07-branchpoint:1.5;
locks; strict;
comment	@ * @;


1.79
date	2013.09.25.21.44.11;	author devans;	state Exp;
branches;
next	1.78;

1.78
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.77;

1.77
date	2013.08.07.20.06.37;	author tromey;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.17.18.09.05;	author devans;	state Exp;
branches;
next	1.75;

1.75
date	2013.05.08.22.38.19;	author devans;	state Exp;
branches;
next	1.74;

1.74
date	2013.05.06.19.15.17;	author devans;	state Exp;
branches;
next	1.73;

1.73
date	2013.04.08.20.18.11;	author tromey;	state Exp;
branches;
next	1.72;

1.72
date	2013.04.08.19.56.03;	author tromey;	state Exp;
branches;
next	1.71;

1.71
date	2013.04.03.18.48.54;	author devans;	state Exp;
branches;
next	1.70;

1.70
date	2013.03.20.18.28.48;	author tromey;	state Exp;
branches;
next	1.69;

1.69
date	2013.03.14.16.36.27;	author jkratoch;	state Exp;
branches;
next	1.68;

1.68
date	2013.02.03.16.20.18;	author jkratoch;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2013.02.03.16.13.29;	author jkratoch;	state Exp;
branches;
next	1.66;

1.66
date	2013.02.03.16.03.07;	author jkratoch;	state Exp;
branches;
next	1.65;

1.65
date	2013.02.03.16.00.35;	author jkratoch;	state Exp;
branches;
next	1.64;

1.64
date	2013.02.03.15.54.16;	author jkratoch;	state Exp;
branches;
next	1.63;

1.63
date	2013.01.21.18.13.13;	author tromey;	state Exp;
branches;
next	1.62;

1.62
date	2013.01.18.03.09.42;	author qiyao;	state Exp;
branches;
next	1.61;

1.61
date	2013.01.14.20.51.46;	author tromey;	state Exp;
branches;
next	1.60;

1.60
date	2013.01.11.00.56.05;	author qiyao;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.10.21.15.51;	author jkratoch;	state Exp;
branches;
next	1.58;

1.58
date	2013.01.09.20.46.03;	author devans;	state Exp;
branches;
next	1.57;

1.57
date	2013.01.03.07.17.52;	author qiyao;	state Exp;
branches;
next	1.56;

1.56
date	2013.01.01.06.32.49;	author brobecke;	state Exp;
branches;
next	1.55;

1.55
date	2012.12.20.00.58.14;	author qiyao;	state Exp;
branches;
next	1.54;

1.54
date	2012.12.16.18.57.16;	author jkratoch;	state Exp;
branches;
next	1.53;

1.53
date	2012.12.12.17.03.03;	author tromey;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.26.16.57.21;	author tromey;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.12.21.16.09;	author devans;	state Exp;
branches;
next	1.50;

1.50
date	2012.07.10.20.17.30;	author devans;	state Exp;
branches;
next	1.49;

1.49
date	2012.07.10.01.10.25;	author devans;	state Exp;
branches;
next	1.48;

1.48
date	2012.06.26.20.14.02;	author devans;	state Exp;
branches;
next	1.47;

1.47
date	2012.05.24.22.14.35;	author jkratoch;	state Exp;
branches;
next	1.46;

1.46
date	2012.05.18.14.26.26;	author tromey;	state Exp;
branches;
next	1.45;

1.45
date	2012.05.10.19.54.45;	author tromey;	state Exp;
branches;
next	1.44;

1.44
date	2012.05.10.19.50.08;	author tromey;	state Exp;
branches;
next	1.43;

1.43
date	2012.05.10.19.44.52;	author tromey;	state Exp;
branches;
next	1.42;

1.42
date	2012.03.01.21.09.16;	author palves;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.26.22.19.59;	author devans;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.26.04.21.40;	author brobecke;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.16.20.40.50;	author tromey;	state Exp;
branches;
next	1.38;

1.38
date	2012.01.04.08.17.09;	author brobecke;	state Exp;
branches;
next	1.37;

1.37
date	2011.12.21.07.34.09;	author brobecke;	state Exp;
branches;
next	1.36;

1.36
date	2011.12.06.18.54.39;	author tromey;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2011.12.02.01.28.54;	author jkratoch;	state Exp;
branches;
next	1.34;

1.34
date	2011.11.15.17.40.01;	author devans;	state Exp;
branches;
next	1.33;

1.33
date	2011.11.11.00.43.04;	author devans;	state Exp;
branches;
next	1.32;

1.32
date	2011.11.10.22.14.16;	author devans;	state Exp;
branches;
next	1.31;

1.31
date	2011.10.28.17.29.37;	author sterling;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.10.21.48.04;	author jkratoch;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.27.20.03.03;	author jkratoch;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.20.19.42.50;	author jkratoch;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.04.14.10.12;	author tromey;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.23.18.23.55;	author ktietz;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2011.03.16.21.12.12;	author kseitz;	state Exp;
branches;
next	1.24;

1.24
date	2011.03.07.16.17.29;	author tromey;	state Exp;
branches;
next	1.23;

1.23
date	2011.02.28.18.16.59;	author tromey;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.10.20.38.50;	author msnyder;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.05.22.22.50;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.01.15.33.13;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2010.11.24.19.01.51;	author jkratoch;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.07.07.13.51;	author hilfingr;	state Exp;
branches;
next	1.17;

1.17
date	2010.10.04.06.34.40;	author hilfingr;	state Exp;
branches;
next	1.16;

1.16
date	2010.10.01.20.26.11;	author tromey;	state Exp;
branches;
next	1.15;

1.15
date	2010.09.14.22.50.30;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.08.17.17.42;	author tromey;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.07.15.00.00;	author swagiaal;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.01.21.50.26;	author tromey;	state Exp;
branches;
next	1.11;

1.11
date	2010.08.31.20.10.42;	author swagiaal;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.31.17.26.08;	author swagiaal;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.19.09.04.13;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.09.19.42.48;	author swagiaal;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.13.20.52.52;	author tromey;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.13.20.49.25;	author tromey;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.24.20.17.52;	author tromey;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2010.05.16.01.27.02;	author msnyder;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.06.01.16.15;	author msnyder;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.10.18.27.00;	author tromey;	state Exp;
branches;
next	1.1;

1.1
date	2010.03.10.18.20.06;	author tromey;	state Exp;
branches;
next	;

1.68.2.1
date	2013.04.04.22.07.42;	author devans;	state Exp;
branches;
next	;

1.36.2.1
date	2012.01.06.04.43.26;	author brobecke;	state Exp;
branches;
next	;

1.26.2.1
date	2011.04.20.20.10.29;	author jkratoch;	state Exp;
branches;
next	;

1.5.2.1
date	2010.08.19.09.12.33;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.79
log
@	* symfile.h (struct quick_symbol_functions): Reorg arg list of
	map_matching_symbols so objfile is first.  All uses updated.
	* dwarf2read.c (dw2_map_matching_symbols): Update signature.
	* psymtab.c (map_matching_symbols_psymtab): Update signature.
@
text
@/* Partial symbol tables.
   
   Copyright (C) 2009-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "symtab.h"
#include "psympriv.h"
#include "objfiles.h"
#include "gdb_assert.h"
#include "block.h"
#include "filenames.h"
#include "source.h"
#include "addrmap.h"
#include "gdbtypes.h"
#include "bcache.h"
#include "ui-out.h"
#include "command.h"
#include "readline/readline.h"
#include "gdb_regex.h"
#include "dictionary.h"
#include "language.h"
#include "cp-support.h"
#include "gdbcmd.h"

#ifndef DEV_TTY
#define DEV_TTY "/dev/tty"
#endif

struct psymbol_bcache
{
  struct bcache *bcache;
};

static struct partial_symbol *match_partial_symbol (struct objfile *,
						    struct partial_symtab *,
						    int,
						    const char *, domain_enum,
						    symbol_compare_ftype *,
						    symbol_compare_ftype *);

static struct partial_symbol *lookup_partial_symbol (struct objfile *,
						     struct partial_symtab *,
						     const char *, int,
						     domain_enum);

static const char *psymtab_to_fullname (struct partial_symtab *ps);

static struct partial_symbol *find_pc_sect_psymbol (struct objfile *,
						    struct partial_symtab *,
						    CORE_ADDR,
						    struct obj_section *);

static void fixup_psymbol_section (struct partial_symbol *psym,
				   struct objfile *objfile);

static struct symtab *psymtab_to_symtab (struct objfile *objfile,
					 struct partial_symtab *pst);

/* Ensure that the partial symbols for OBJFILE have been loaded.  This
   function always returns its argument, as a convenience.  */

struct objfile *
require_partial_symbols (struct objfile *objfile, int verbose)
{
  if ((objfile->flags & OBJF_PSYMTABS_READ) == 0)
    {
      objfile->flags |= OBJF_PSYMTABS_READ;

      if (objfile->sf->sym_read_psymbols)
	{
	  if (verbose)
	    {
	      printf_unfiltered (_("Reading symbols from %s..."),
				 objfile_name (objfile));
	      gdb_flush (gdb_stdout);
	    }
	  (*objfile->sf->sym_read_psymbols) (objfile);
	  if (verbose)
	    {
	      if (!objfile_has_symbols (objfile))
		{
		  wrap_here ("");
		  printf_unfiltered (_("(no debugging symbols found)..."));
		  wrap_here ("");
		}

	      printf_unfiltered (_("done.\n"));
	    }
	}
    }

  return objfile;
}

/* Traverse all psymtabs in one objfile, requiring that the psymtabs
   be read in.  */

#define ALL_OBJFILE_PSYMTABS_REQUIRED(objfile, p)		\
    for ((p) = require_partial_symbols (objfile, 1)->psymtabs;	\
	 (p) != NULL;						\
	 (p) = (p)->next)

/* We want to make sure this file always requires psymtabs.  */

#undef ALL_OBJFILE_PSYMTABS

/* Traverse all psymtabs in all objfiles.  */

#define ALL_PSYMTABS(objfile, p) \
  ALL_OBJFILES (objfile)	 \
    ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, p)

/* Helper function for partial_map_symtabs_matching_filename that
   expands the symtabs and calls the iterator.  */

static int
partial_map_expand_apply (struct objfile *objfile,
			  const char *name,
			  const char *real_path,
			  struct partial_symtab *pst,
			  int (*callback) (struct symtab *, void *),
			  void *data)
{
  struct symtab *last_made = objfile->symtabs;

  /* Shared psymtabs should never be seen here.  Instead they should
     be handled properly by the caller.  */
  gdb_assert (pst->user == NULL);

  /* Don't visit already-expanded psymtabs.  */
  if (pst->readin)
    return 0;

  /* This may expand more than one symtab, and we want to iterate over
     all of them.  */
  psymtab_to_symtab (objfile, pst);

  return iterate_over_some_symtabs (name, real_path, callback, data,
				    objfile->symtabs, last_made);
}

/* Implementation of the map_symtabs_matching_filename method.  */

static int
partial_map_symtabs_matching_filename (struct objfile *objfile,
				       const char *name,
				       const char *real_path,
				       int (*callback) (struct symtab *,
							void *),
				       void *data)
{
  struct partial_symtab *pst;
  const char *name_basename = lbasename (name);

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)
  {
    /* We can skip shared psymtabs here, because any file name will be
       attached to the unshared psymtab.  */
    if (pst->user != NULL)
      continue;

    /* Anonymous psymtabs don't have a file name.  */
    if (pst->anonymous)
      continue;

    if (compare_filenames_for_search (pst->filename, name))
      {
	if (partial_map_expand_apply (objfile, name, real_path,
				      pst, callback, data))
	  return 1;
	continue;
      }

    /* Before we invoke realpath, which can get expensive when many
       files are involved, do a quick comparison of the basenames.  */
    if (! basenames_may_differ
	&& FILENAME_CMP (name_basename, lbasename (pst->filename)) != 0)
      continue;

    if (compare_filenames_for_search (psymtab_to_fullname (pst), name))
      {
	if (partial_map_expand_apply (objfile, name, real_path,
				      pst, callback, data))
	  return 1;
	continue;
      }

    /* If the user gave us an absolute path, try to find the file in
       this symtab and use its absolute path.  */
    if (real_path != NULL)
      {
	gdb_assert (IS_ABSOLUTE_PATH (real_path));
	gdb_assert (IS_ABSOLUTE_PATH (name));
	if (filename_cmp (psymtab_to_fullname (pst), real_path) == 0)
	  {
	    if (partial_map_expand_apply (objfile, name, real_path,
					  pst, callback, data))
	      return 1;
	    continue;
	  }
      }
  }

  return 0;
}

/* Find which partial symtab contains PC and SECTION starting at psymtab PST.
   We may find a different psymtab than PST.  See FIND_PC_SECT_PSYMTAB.  */

static struct partial_symtab *
find_pc_sect_psymtab_closer (struct objfile *objfile,
			     CORE_ADDR pc, struct obj_section *section,
			     struct partial_symtab *pst,
			     struct minimal_symbol *msymbol)
{
  struct partial_symtab *tpst;
  struct partial_symtab *best_pst = pst;
  CORE_ADDR best_addr = pst->textlow;

  gdb_assert (!pst->psymtabs_addrmap_supported);

  /* An objfile that has its functions reordered might have
     many partial symbol tables containing the PC, but
     we want the partial symbol table that contains the
     function containing the PC.  */
  if (!(objfile->flags & OBJF_REORDERED) &&
      section == 0)	/* Can't validate section this way.  */
    return pst;

  if (msymbol == NULL)
    return (pst);

  /* The code range of partial symtabs sometimes overlap, so, in
     the loop below, we need to check all partial symtabs and
     find the one that fits better for the given PC address.  We
     select the partial symtab that contains a symbol whose
     address is closest to the PC address.  By closest we mean
     that find_pc_sect_symbol returns the symbol with address
     that is closest and still less than the given PC.  */
  for (tpst = pst; tpst != NULL; tpst = tpst->next)
    {
      if (pc >= tpst->textlow && pc < tpst->texthigh)
	{
	  struct partial_symbol *p;
	  CORE_ADDR this_addr;

	  /* NOTE: This assumes that every psymbol has a
	     corresponding msymbol, which is not necessarily
	     true; the debug info might be much richer than the
	     object's symbol table.  */
	  p = find_pc_sect_psymbol (objfile, tpst, pc, section);
	  if (p != NULL
	      && SYMBOL_VALUE_ADDRESS (p)
	      == SYMBOL_VALUE_ADDRESS (msymbol))
	    return tpst;

	  /* Also accept the textlow value of a psymtab as a
	     "symbol", to provide some support for partial
	     symbol tables with line information but no debug
	     symbols (e.g. those produced by an assembler).  */
	  if (p != NULL)
	    this_addr = SYMBOL_VALUE_ADDRESS (p);
	  else
	    this_addr = tpst->textlow;

	  /* Check whether it is closer than our current
	     BEST_ADDR.  Since this symbol address is
	     necessarily lower or equal to PC, the symbol closer
	     to PC is the symbol which address is the highest.
	     This way we return the psymtab which contains such
	     best match symbol.  This can help in cases where the
	     symbol information/debuginfo is not complete, like
	     for instance on IRIX6 with gcc, where no debug info
	     is emitted for statics.  (See also the nodebug.exp
	     testcase.)  */
	  if (this_addr > best_addr)
	    {
	      best_addr = this_addr;
	      best_pst = tpst;
	    }
	}
    }
  return best_pst;
}

/* Find which partial symtab contains PC and SECTION.  Return 0 if
   none.  We return the psymtab that contains a symbol whose address
   exactly matches PC, or, if we cannot find an exact match, the
   psymtab that contains a symbol whose address is closest to PC.  */
static struct partial_symtab *
find_pc_sect_psymtab (struct objfile *objfile, CORE_ADDR pc,
		      struct obj_section *section,
		      struct minimal_symbol *msymbol)
{
  struct partial_symtab *pst;

  /* Try just the PSYMTABS_ADDRMAP mapping first as it has better granularity
     than the later used TEXTLOW/TEXTHIGH one.  */

  if (objfile->psymtabs_addrmap != NULL)
    {
      pst = addrmap_find (objfile->psymtabs_addrmap, pc);
      if (pst != NULL)
	{
	  /* FIXME: addrmaps currently do not handle overlayed sections,
	     so fall back to the non-addrmap case if we're debugging
	     overlays and the addrmap returned the wrong section.  */
	  if (overlay_debugging && msymbol && section)
	    {
	      struct partial_symbol *p;

	      /* NOTE: This assumes that every psymbol has a
		 corresponding msymbol, which is not necessarily
		 true; the debug info might be much richer than the
		 object's symbol table.  */
	      p = find_pc_sect_psymbol (objfile, pst, pc, section);
	      if (!p
		  || SYMBOL_VALUE_ADDRESS (p)
		  != SYMBOL_VALUE_ADDRESS (msymbol))
		goto next;
	    }

	  /* We do not try to call FIND_PC_SECT_PSYMTAB_CLOSER as
	     PSYMTABS_ADDRMAP we used has already the best 1-byte
	     granularity and FIND_PC_SECT_PSYMTAB_CLOSER may mislead us into
	     a worse chosen section due to the TEXTLOW/TEXTHIGH ranges
	     overlap.  */

	  return pst;
	}
    }

 next:

  /* Existing PSYMTABS_ADDRMAP mapping is present even for PARTIAL_SYMTABs
     which still have no corresponding full SYMTABs read.  But it is not
     present for non-DWARF2 debug infos not supporting PSYMTABS_ADDRMAP in GDB
     so far.  */

  /* Check even OBJFILE with non-zero PSYMTABS_ADDRMAP as only several of
     its CUs may be missing in PSYMTABS_ADDRMAP as they may be varying
     debug info type in single OBJFILE.  */

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)
    if (!pst->psymtabs_addrmap_supported
	&& pc >= pst->textlow && pc < pst->texthigh)
      {
	struct partial_symtab *best_pst;

	best_pst = find_pc_sect_psymtab_closer (objfile, pc, section, pst,
						msymbol);
	if (best_pst != NULL)
	  return best_pst;
      }

  return NULL;
}

static struct symtab *
find_pc_sect_symtab_from_partial (struct objfile *objfile,
				  struct minimal_symbol *msymbol,
				  CORE_ADDR pc, struct obj_section *section,
				  int warn_if_readin)
{
  struct partial_symtab *ps = find_pc_sect_psymtab (objfile, pc, section,
						    msymbol);
  if (ps)
    {
      if (warn_if_readin && ps->readin)
	/* Might want to error() here (in case symtab is corrupt and
	   will cause a core dump), but maybe we can successfully
	   continue, so let's not.  */
	warning (_("\
(Internal error: pc %s in read in psymtab, but not in symtab.)\n"),
		 paddress (get_objfile_arch (objfile), pc));
      psymtab_to_symtab (objfile, ps);
      return ps->symtab;
    }
  return NULL;
}

/* Find which partial symbol within a psymtab matches PC and SECTION.
   Return 0 if none.  */

static struct partial_symbol *
find_pc_sect_psymbol (struct objfile *objfile,
		      struct partial_symtab *psymtab, CORE_ADDR pc,
		      struct obj_section *section)
{
  struct partial_symbol *best = NULL, *p, **pp;
  CORE_ADDR best_pc;

  gdb_assert (psymtab != NULL);

  /* Cope with programs that start at address 0.  */
  best_pc = (psymtab->textlow != 0) ? psymtab->textlow - 1 : 0;

  /* Search the global symbols as well as the static symbols, so that
     find_pc_partial_function doesn't use a minimal symbol and thus
     cache a bad endaddr.  */
  for (pp = objfile->global_psymbols.list + psymtab->globals_offset;
    (pp - (objfile->global_psymbols.list + psymtab->globals_offset)
     < psymtab->n_global_syms);
       pp++)
    {
      p = *pp;
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
	  && PSYMBOL_CLASS (p) == LOC_BLOCK
	  && pc >= SYMBOL_VALUE_ADDRESS (p)
	  && (SYMBOL_VALUE_ADDRESS (p) > best_pc
	      || (psymtab->textlow == 0
		  && best_pc == 0 && SYMBOL_VALUE_ADDRESS (p) == 0)))
	{
	  if (section)		/* Match on a specific section.  */
	    {
	      fixup_psymbol_section (p, objfile);
	      if (!matching_obj_sections (SYMBOL_OBJ_SECTION (objfile, p),
					  section))
		continue;
	    }
	  best_pc = SYMBOL_VALUE_ADDRESS (p);
	  best = p;
	}
    }

  for (pp = objfile->static_psymbols.list + psymtab->statics_offset;
    (pp - (objfile->static_psymbols.list + psymtab->statics_offset)
     < psymtab->n_static_syms);
       pp++)
    {
      p = *pp;
      if (SYMBOL_DOMAIN (p) == VAR_DOMAIN
	  && PSYMBOL_CLASS (p) == LOC_BLOCK
	  && pc >= SYMBOL_VALUE_ADDRESS (p)
	  && (SYMBOL_VALUE_ADDRESS (p) > best_pc
	      || (psymtab->textlow == 0
		  && best_pc == 0 && SYMBOL_VALUE_ADDRESS (p) == 0)))
	{
	  if (section)		/* Match on a specific section.  */
	    {
	      fixup_psymbol_section (p, objfile);
	      if (!matching_obj_sections (SYMBOL_OBJ_SECTION (objfile, p),
					  section))
		continue;
	    }
	  best_pc = SYMBOL_VALUE_ADDRESS (p);
	  best = p;
	}
    }

  return best;
}

static void
fixup_psymbol_section (struct partial_symbol *psym, struct objfile *objfile)
{
  CORE_ADDR addr;

  if (!psym)
    return;

  if (SYMBOL_SECTION (psym) >= 0)
    return;

  gdb_assert (objfile);

  switch (PSYMBOL_CLASS (psym))
    {
    case LOC_STATIC:
    case LOC_LABEL:
    case LOC_BLOCK:
      addr = SYMBOL_VALUE_ADDRESS (psym);
      break;
    default:
      /* Nothing else will be listed in the minsyms -- no use looking
	 it up.  */
      return;
    }

  fixup_section (&psym->ginfo, addr, objfile);
}

static struct symtab *
lookup_symbol_aux_psymtabs (struct objfile *objfile,
			    int block_index, const char *name,
			    const domain_enum domain)
{
  struct partial_symtab *ps;
  const int psymtab_index = (block_index == GLOBAL_BLOCK ? 1 : 0);
  struct symtab *stab_best = NULL;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
  {
    if (!ps->readin && lookup_partial_symbol (objfile, ps, name,
					      psymtab_index, domain))
      {
	struct symbol *sym = NULL;
	struct symtab *stab = psymtab_to_symtab (objfile, ps);

	/* Some caution must be observed with overloaded functions
	   and methods, since the psymtab will not contain any overload
	   information (but NAME might contain it).  */
	if (stab->primary)
	  {
	    struct blockvector *bv = BLOCKVECTOR (stab);
	    struct block *block = BLOCKVECTOR_BLOCK (bv, block_index);

	    sym = lookup_block_symbol (block, name, domain);
	  }

	if (sym && strcmp_iw (SYMBOL_SEARCH_NAME (sym), name) == 0)
	  {
	    if (!TYPE_IS_OPAQUE (SYMBOL_TYPE (sym)))
	      return stab;

	    stab_best = stab;
	  }

	/* Keep looking through other psymtabs.  */
      }
  }

  return stab_best;
}

/* Look in PST for a symbol in DOMAIN whose name matches NAME.  Search
   the global block of PST if GLOBAL, and otherwise the static block.
   MATCH is the comparison operation that returns true iff MATCH (s,
   NAME), where s is a SYMBOL_SEARCH_NAME.  If ORDERED_COMPARE is
   non-null, the symbols in the block are assumed to be ordered
   according to it (allowing binary search).  It must be compatible
   with MATCH.  Returns the symbol, if found, and otherwise NULL.  */

static struct partial_symbol *
match_partial_symbol (struct objfile *objfile,
		      struct partial_symtab *pst, int global,
		      const char *name, domain_enum domain,
		      symbol_compare_ftype *match,
		      symbol_compare_ftype *ordered_compare)
{
  struct partial_symbol **start, **psym;
  struct partial_symbol **top, **real_top, **bottom, **center;
  int length = (global ? pst->n_global_syms : pst->n_static_syms);
  int do_linear_search = 1;

  if (length == 0)
      return NULL;
  start = (global ?
	   objfile->global_psymbols.list + pst->globals_offset :
	   objfile->static_psymbols.list + pst->statics_offset);

  if (global && ordered_compare)  /* Can use a binary search.  */
    {
      do_linear_search = 0;

      /* Binary search.  This search is guaranteed to end with center
         pointing at the earliest partial symbol whose name might be
         correct.  At that point *all* partial symbols with an
         appropriate name will be checked against the correct
         domain.  */

      bottom = start;
      top = start + length - 1;
      real_top = top;
      while (top > bottom)
	{
	  center = bottom + (top - bottom) / 2;
	  gdb_assert (center < top);
	  if (!do_linear_search
	      && (SYMBOL_LANGUAGE (*center) == language_java))
	    do_linear_search = 1;
	  if (ordered_compare (SYMBOL_SEARCH_NAME (*center), name) >= 0)
	    top = center;
	  else
	    bottom = center + 1;
	}
      gdb_assert (top == bottom);

      while (top <= real_top
	     && match (SYMBOL_SEARCH_NAME (*top), name) == 0)
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (*top),
				     SYMBOL_DOMAIN (*top), domain))
	    return *top;
	  top++;
	}
    }

  /* Can't use a binary search or else we found during the binary search that
     we should also do a linear search.  */

  if (do_linear_search)
    {
      for (psym = start; psym < start + length; psym++)
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (*psym),
				     SYMBOL_DOMAIN (*psym), domain)
	      && match (SYMBOL_SEARCH_NAME (*psym), name) == 0)
	    return *psym;
	}
    }

  return NULL;
}

/* Returns the name used to search psymtabs.  Unlike symtabs, psymtabs do
   not contain any method/function instance information (since this would
   force reading type information while reading psymtabs).  Therefore,
   if NAME contains overload information, it must be stripped before searching
   psymtabs.

   The caller is responsible for freeing the return result.  */

static char *
psymtab_search_name (const char *name)
{
  switch (current_language->la_language)
    {
    case language_cplus:
    case language_java:
      {
       if (strchr (name, '('))
         {
           char *ret = cp_remove_params (name);

           if (ret)
             return ret;
         }
      }
      break;

    default:
      break;
    }

  return xstrdup (name);
}

/* Look, in partial_symtab PST, for symbol whose natural name is NAME.
   Check the global symbols if GLOBAL, the static symbols if not.  */

static struct partial_symbol *
lookup_partial_symbol (struct objfile *objfile,
		       struct partial_symtab *pst, const char *name,
		       int global, domain_enum domain)
{
  struct partial_symbol **start, **psym;
  struct partial_symbol **top, **real_top, **bottom, **center;
  int length = (global ? pst->n_global_syms : pst->n_static_syms);
  int do_linear_search = 1;
  char *search_name;
  struct cleanup *cleanup;

  if (length == 0)
    {
      return (NULL);
    }

  search_name = psymtab_search_name (name);
  cleanup = make_cleanup (xfree, search_name);
  start = (global ?
	   objfile->global_psymbols.list + pst->globals_offset :
	   objfile->static_psymbols.list + pst->statics_offset);

  if (global)			/* This means we can use a binary search.  */
    {
      do_linear_search = 0;

      /* Binary search.  This search is guaranteed to end with center
         pointing at the earliest partial symbol whose name might be
         correct.  At that point *all* partial symbols with an
         appropriate name will be checked against the correct
         domain.  */

      bottom = start;
      top = start + length - 1;
      real_top = top;
      while (top > bottom)
	{
	  center = bottom + (top - bottom) / 2;
	  if (!(center < top))
	    internal_error (__FILE__, __LINE__,
			    _("failed internal consistency check"));
	  if (!do_linear_search
	      && SYMBOL_LANGUAGE (*center) == language_java)
	    {
	      do_linear_search = 1;
	    }
	  if (strcmp_iw_ordered (SYMBOL_SEARCH_NAME (*center),
				 search_name) >= 0)
	    {
	      top = center;
	    }
	  else
	    {
	      bottom = center + 1;
	    }
	}
      if (!(top == bottom))
	internal_error (__FILE__, __LINE__,
			_("failed internal consistency check"));

      /* For `case_sensitivity == case_sensitive_off' strcmp_iw_ordered will
	 search more exactly than what matches SYMBOL_MATCHES_SEARCH_NAME.  */
      while (top >= start && SYMBOL_MATCHES_SEARCH_NAME (*top, search_name))
	top--;

      /* Fixup to have a symbol which matches SYMBOL_MATCHES_SEARCH_NAME.  */
      top++;

      while (top <= real_top && SYMBOL_MATCHES_SEARCH_NAME (*top, search_name))
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (*top),
				     SYMBOL_DOMAIN (*top), domain))
	    {
	      do_cleanups (cleanup);
	      return (*top);
	    }
	  top++;
	}
    }

  /* Can't use a binary search or else we found during the binary search that
     we should also do a linear search.  */

  if (do_linear_search)
    {
      for (psym = start; psym < start + length; psym++)
	{
	  if (symbol_matches_domain (SYMBOL_LANGUAGE (*psym),
				     SYMBOL_DOMAIN (*psym), domain)
	      && SYMBOL_MATCHES_SEARCH_NAME (*psym, search_name))
	    {
	      do_cleanups (cleanup);
	      return (*psym);
	    }
	}
    }

  do_cleanups (cleanup);
  return (NULL);
}

/* Get the symbol table that corresponds to a partial_symtab.
   This is fast after the first time you do it.  */

static struct symtab *
psymtab_to_symtab (struct objfile *objfile, struct partial_symtab *pst)
{
  /* If it is a shared psymtab, find an unshared psymtab that includes
     it.  Any such psymtab will do.  */
  while (pst->user != NULL)
    pst = pst->user;

  /* If it's been looked up before, return it.  */
  if (pst->symtab)
    return pst->symtab;

  /* If it has not yet been read in, read it.  */
  if (!pst->readin)
    {
      struct cleanup *back_to = increment_reading_symtab ();

      (*pst->read_symtab) (pst, objfile);
      do_cleanups (back_to);
    }

  return pst->symtab;
}

static void
relocate_psymtabs (struct objfile *objfile,
		   const struct section_offsets *new_offsets,
		   const struct section_offsets *delta)
{
  struct partial_symbol **psym;
  struct partial_symtab *p;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, p)
    {
      p->textlow += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
      p->texthigh += ANOFFSET (delta, SECT_OFF_TEXT (objfile));
    }

  for (psym = objfile->global_psymbols.list;
       psym < objfile->global_psymbols.next;
       psym++)
    {
      fixup_psymbol_section (*psym, objfile);
      if (SYMBOL_SECTION (*psym) >= 0)
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
						  SYMBOL_SECTION (*psym));
    }
  for (psym = objfile->static_psymbols.list;
       psym < objfile->static_psymbols.next;
       psym++)
    {
      fixup_psymbol_section (*psym, objfile);
      if (SYMBOL_SECTION (*psym) >= 0)
	SYMBOL_VALUE_ADDRESS (*psym) += ANOFFSET (delta,
						  SYMBOL_SECTION (*psym));
    }
}

static struct symtab *
find_last_source_symtab_from_partial (struct objfile *ofp)
{
  struct partial_symtab *ps;
  struct partial_symtab *cs_pst = 0;

  ALL_OBJFILE_PSYMTABS_REQUIRED (ofp, ps)
    {
      const char *name = ps->filename;
      int len = strlen (name);

      if (!(len > 2 && (strcmp (&name[len - 2], ".h") == 0
			|| strcmp (name, "<<C++-namespaces>>") == 0)))
	cs_pst = ps;
    }

  if (cs_pst)
    {
      if (cs_pst->readin)
	{
	  internal_error (__FILE__, __LINE__,
			  _("select_source_symtab: "
			  "readin pst found and no symtabs."));
	}
      else
	return psymtab_to_symtab (ofp, cs_pst);
    }
  return NULL;
}

static void
forget_cached_source_info_partial (struct objfile *objfile)
{
  struct partial_symtab *pst;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)
    {
      if (pst->fullname != NULL)
	{
	  xfree (pst->fullname);
	  pst->fullname = NULL;
	}
    }
}

static void
print_partial_symbols (struct gdbarch *gdbarch,
		       struct partial_symbol **p, int count, char *what,
		       struct ui_file *outfile)
{
  fprintf_filtered (outfile, "  %s partial symbols:\n", what);
  while (count-- > 0)
    {
      QUIT;
      fprintf_filtered (outfile, "    `%s'", SYMBOL_LINKAGE_NAME (*p));
      if (SYMBOL_DEMANGLED_NAME (*p) != NULL)
	{
	  fprintf_filtered (outfile, "  `%s'", SYMBOL_DEMANGLED_NAME (*p));
	}
      fputs_filtered (", ", outfile);
      switch (SYMBOL_DOMAIN (*p))
	{
	case UNDEF_DOMAIN:
	  fputs_filtered ("undefined domain, ", outfile);
	  break;
	case VAR_DOMAIN:
	  /* This is the usual thing -- don't print it.  */
	  break;
	case STRUCT_DOMAIN:
	  fputs_filtered ("struct domain, ", outfile);
	  break;
	case LABEL_DOMAIN:
	  fputs_filtered ("label domain, ", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid domain>, ", outfile);
	  break;
	}
      switch (PSYMBOL_CLASS (*p))
	{
	case LOC_UNDEF:
	  fputs_filtered ("undefined", outfile);
	  break;
	case LOC_CONST:
	  fputs_filtered ("constant int", outfile);
	  break;
	case LOC_STATIC:
	  fputs_filtered ("static", outfile);
	  break;
	case LOC_REGISTER:
	  fputs_filtered ("register", outfile);
	  break;
	case LOC_ARG:
	  fputs_filtered ("pass by value", outfile);
	  break;
	case LOC_REF_ARG:
	  fputs_filtered ("pass by reference", outfile);
	  break;
	case LOC_REGPARM_ADDR:
	  fputs_filtered ("register address parameter", outfile);
	  break;
	case LOC_LOCAL:
	  fputs_filtered ("stack parameter", outfile);
	  break;
	case LOC_TYPEDEF:
	  fputs_filtered ("type", outfile);
	  break;
	case LOC_LABEL:
	  fputs_filtered ("label", outfile);
	  break;
	case LOC_BLOCK:
	  fputs_filtered ("function", outfile);
	  break;
	case LOC_CONST_BYTES:
	  fputs_filtered ("constant bytes", outfile);
	  break;
	case LOC_UNRESOLVED:
	  fputs_filtered ("unresolved", outfile);
	  break;
	case LOC_OPTIMIZED_OUT:
	  fputs_filtered ("optimized out", outfile);
	  break;
	case LOC_COMPUTED:
	  fputs_filtered ("computed at runtime", outfile);
	  break;
	default:
	  fputs_filtered ("<invalid location>", outfile);
	  break;
	}
      fputs_filtered (", ", outfile);
      fputs_filtered (paddress (gdbarch, SYMBOL_VALUE_ADDRESS (*p)), outfile);
      fprintf_filtered (outfile, "\n");
      p++;
    }
}

static void
dump_psymtab (struct objfile *objfile, struct partial_symtab *psymtab,
	      struct ui_file *outfile)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  int i;

  if (psymtab->anonymous)
    {
      fprintf_filtered (outfile, "\nAnonymous partial symtab (%s) ",
			psymtab->filename);
    }
  else
    {
      fprintf_filtered (outfile, "\nPartial symtab for source file %s ",
			psymtab->filename);
    }
  fprintf_filtered (outfile, "(object ");
  gdb_print_host_address (psymtab, outfile);
  fprintf_filtered (outfile, ")\n\n");
  fprintf_unfiltered (outfile, "  Read from object file %s (",
		      objfile_name (objfile));
  gdb_print_host_address (objfile, outfile);
  fprintf_unfiltered (outfile, ")\n");

  if (psymtab->readin)
    {
      fprintf_filtered (outfile,
			"  Full symtab was read (at ");
      gdb_print_host_address (psymtab->symtab, outfile);
      fprintf_filtered (outfile, " by function at ");
      gdb_print_host_address (psymtab->read_symtab, outfile);
      fprintf_filtered (outfile, ")\n");
    }

  fprintf_filtered (outfile, "  Relocate symbols by ");
  for (i = 0; i < objfile->num_sections; ++i)
    {
      if (i != 0)
	fprintf_filtered (outfile, ", ");
      wrap_here ("    ");
      fputs_filtered (paddress (gdbarch,
				ANOFFSET (psymtab->section_offsets, i)),
		      outfile);
    }
  fprintf_filtered (outfile, "\n");

  fprintf_filtered (outfile, "  Symbols cover text addresses ");
  fputs_filtered (paddress (gdbarch, psymtab->textlow), outfile);
  fprintf_filtered (outfile, "-");
  fputs_filtered (paddress (gdbarch, psymtab->texthigh), outfile);
  fprintf_filtered (outfile, "\n");
  fprintf_filtered (outfile, "  Address map supported - %s.\n",
		    psymtab->psymtabs_addrmap_supported ? "yes" : "no");
  fprintf_filtered (outfile, "  Depends on %d other partial symtabs.\n",
		    psymtab->number_of_dependencies);
  for (i = 0; i < psymtab->number_of_dependencies; i++)
    {
      fprintf_filtered (outfile, "    %d ", i);
      gdb_print_host_address (psymtab->dependencies[i], outfile);
      fprintf_filtered (outfile, " %s\n",
			psymtab->dependencies[i]->filename);
    }
  if (psymtab->user != NULL)
    {
      fprintf_filtered (outfile, "  Shared partial symtab with user ");
      gdb_print_host_address (psymtab->user, outfile);
      fprintf_filtered (outfile, "\n");
    }
  if (psymtab->n_global_syms > 0)
    {
      print_partial_symbols (gdbarch,
			     objfile->global_psymbols.list
			     + psymtab->globals_offset,
			     psymtab->n_global_syms, "Global", outfile);
    }
  if (psymtab->n_static_syms > 0)
    {
      print_partial_symbols (gdbarch,
			     objfile->static_psymbols.list
			     + psymtab->statics_offset,
			     psymtab->n_static_syms, "Static", outfile);
    }
  fprintf_filtered (outfile, "\n");
}

static void
print_psymtab_stats_for_objfile (struct objfile *objfile)
{
  int i;
  struct partial_symtab *ps;

  i = 0;
  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
    {
      if (ps->readin == 0)
	i++;
    }
  printf_filtered (_("  Number of psym tables (not yet expanded): %d\n"), i);
}

static void
dump_psymtabs_for_objfile (struct objfile *objfile)
{
  struct partial_symtab *psymtab;

  if (objfile->psymtabs)
    {
      printf_filtered ("Psymtabs:\n");
      for (psymtab = objfile->psymtabs;
	   psymtab != NULL;
	   psymtab = psymtab->next)
	{
	  printf_filtered ("%s at ",
			   psymtab->filename);
	  gdb_print_host_address (psymtab, gdb_stdout);
	  printf_filtered (", ");
	  wrap_here ("  ");
	}
      printf_filtered ("\n\n");
    }
}

/* Look through the partial symtabs for all symbols which begin
   by matching FUNC_NAME.  Make sure we read that symbol table in.  */

static void
read_symtabs_for_function (struct objfile *objfile, const char *func_name)
{
  struct partial_symtab *ps;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
  {
    if (ps->readin)
      continue;

    if ((lookup_partial_symbol (objfile, ps, func_name, 1, VAR_DOMAIN)
	 != NULL)
	|| (lookup_partial_symbol (objfile, ps, func_name, 0, VAR_DOMAIN)
	    != NULL))
      psymtab_to_symtab (objfile, ps);
  }
}

static void
expand_partial_symbol_tables (struct objfile *objfile)
{
  struct partial_symtab *psymtab;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, psymtab)
    {
      psymtab_to_symtab (objfile, psymtab);
    }
}

static void
read_psymtabs_with_fullname (struct objfile *objfile, const char *fullname)
{
  struct partial_symtab *p;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, p)
    {
      /* Anonymous psymtabs don't have a name of a source file.  */
      if (p->anonymous)
	continue;

      /* psymtab_to_fullname tries to open the file which is slow.
	 Don't call it if we know the basenames don't match.  */
      if ((basenames_may_differ
	   || filename_cmp (lbasename (fullname), lbasename (p->filename)) == 0)
	  && filename_cmp (fullname, psymtab_to_fullname (p)) == 0)
	psymtab_to_symtab (objfile, p);
    }
}

static void
map_symbol_filenames_psymtab (struct objfile *objfile,
			      symbol_filename_ftype *fun, void *data,
			      int need_fullname)
{
  struct partial_symtab *ps;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
    {
      const char *fullname;

      if (ps->readin)
	continue;

      /* We can skip shared psymtabs here, because any file name will be
	 attached to the unshared psymtab.  */
      if (ps->user != NULL)
	continue;

      /* Anonymous psymtabs don't have a file name.  */
      if (ps->anonymous)
	continue;

      QUIT;
      if (need_fullname)
	fullname = psymtab_to_fullname (ps);
      else
	fullname = NULL;
      (*fun) (ps->filename, fullname, data);
    }
}

/* Finds the fullname that a partial_symtab represents.

   If this functions finds the fullname, it will save it in ps->fullname
   and it will also return the value.

   If this function fails to find the file that this partial_symtab represents,
   NULL will be returned and ps->fullname will be set to NULL.  */

static const char *
psymtab_to_fullname (struct partial_symtab *ps)
{
  gdb_assert (!ps->anonymous);

  /* Use cached copy if we have it.
     We rely on forget_cached_source_info being called appropriately
     to handle cases like the file being moved.  */
  if (ps->fullname == NULL)
    {
      int fd = find_and_open_source (ps->filename, ps->dirname, &ps->fullname);

      if (fd >= 0)
	close (fd);
      else
	{
	  char *fullname;
	  struct cleanup *back_to;

	  /* rewrite_source_path would be applied by find_and_open_source, we
	     should report the pathname where GDB tried to find the file.  */

	  if (ps->dirname == NULL || IS_ABSOLUTE_PATH (ps->filename))
	    fullname = xstrdup (ps->filename);
	  else
	    fullname = concat (ps->dirname, SLASH_STRING, ps->filename, NULL);

	  back_to = make_cleanup (xfree, fullname);
	  ps->fullname = rewrite_source_path (fullname);
	  if (ps->fullname == NULL)
	    ps->fullname = xstrdup (fullname);
	  do_cleanups (back_to);
	}
    } 

  return ps->fullname;
}

/*  For all symbols, s, in BLOCK that are in NAMESPACE and match NAME
    according to the function MATCH, call CALLBACK(BLOCK, s, DATA).
    BLOCK is assumed to come from OBJFILE.  Returns 1 iff CALLBACK
    ever returns non-zero, and otherwise returns 0.  */

static int
map_block (const char *name, domain_enum namespace, struct objfile *objfile,
	   struct block *block,
	   int (*callback) (struct block *, struct symbol *, void *),
	   void *data, symbol_compare_ftype *match)
{
  struct block_iterator iter;
  struct symbol *sym;

  for (sym = block_iter_match_first (block, name, match, &iter);
       sym != NULL; sym = block_iter_match_next (name, match, &iter))
    {
      if (symbol_matches_domain (SYMBOL_LANGUAGE (sym), 
				 SYMBOL_DOMAIN (sym), namespace))
	{
	  if (callback (block, sym, data))
	    return 1;
	}
    }

  return 0;
}

/*  Psymtab version of map_matching_symbols.  See its definition in
    the definition of quick_symbol_functions in symfile.h.  */

static void
map_matching_symbols_psymtab (struct objfile *objfile,
			      const char *name, domain_enum namespace,
			      int global,
			      int (*callback) (struct block *,
					       struct symbol *, void *),
			      void *data,
			      symbol_compare_ftype *match,
			      symbol_compare_ftype *ordered_compare)
{
  const int block_kind = global ? GLOBAL_BLOCK : STATIC_BLOCK;
  struct partial_symtab *ps;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
    {
      QUIT;
      if (ps->readin
	  || match_partial_symbol (objfile, ps, global, name, namespace, match,
				   ordered_compare))
	{
	  struct symtab *s = psymtab_to_symtab (objfile, ps);
	  struct block *block;

	  if (s == NULL || !s->primary)
	    continue;
	  block = BLOCKVECTOR_BLOCK (BLOCKVECTOR (s), block_kind);
	  if (map_block (name, namespace, objfile, block,
			 callback, data, match))
	    return;
	  if (callback (block, NULL, data))
	    return;
	}
    }
}	    

/* A helper for expand_symtabs_matching_via_partial that handles
   searching included psymtabs.  This returns 1 if a symbol is found,
   and zero otherwise.  It also updates the 'searched_flag' on the
   various psymtabs that it searches.  */

static int
recursively_search_psymtabs (struct partial_symtab *ps,
			     struct objfile *objfile,
			     enum search_domain kind,
			     int (*name_matcher) (const char *, void *),
			     void *data)
{
  struct partial_symbol **psym;
  struct partial_symbol **bound, **gbound, **sbound;
  int keep_going = 1;
  int result = PST_SEARCHED_AND_NOT_FOUND;
  int i;

  if (ps->searched_flag != PST_NOT_SEARCHED)
    return ps->searched_flag == PST_SEARCHED_AND_FOUND;

  /* Recurse into shared psymtabs first, because they may have already
     been searched, and this could save some time.  */
  for (i = 0; i < ps->number_of_dependencies; ++i)
    {
      int r;

      /* Skip non-shared dependencies, these are handled elsewhere.  */
      if (ps->dependencies[i]->user == NULL)
	continue;

      r = recursively_search_psymtabs (ps->dependencies[i],
				       objfile, kind, name_matcher, data);
      if (r != 0)
	{
	  ps->searched_flag = PST_SEARCHED_AND_FOUND;
	  return 1;
	}
    }

  gbound = (objfile->global_psymbols.list
	    + ps->globals_offset + ps->n_global_syms);
  sbound = (objfile->static_psymbols.list
	    + ps->statics_offset + ps->n_static_syms);
  bound = gbound;

  /* Go through all of the symbols stored in a partial
     symtab in one loop.  */
  psym = objfile->global_psymbols.list + ps->globals_offset;
  while (keep_going)
    {
      if (psym >= bound)
	{
	  if (bound == gbound && ps->n_static_syms != 0)
	    {
	      psym = objfile->static_psymbols.list + ps->statics_offset;
	      bound = sbound;
	    }
	  else
	    keep_going = 0;
	  continue;
	}
      else
	{
	  QUIT;

	  if ((kind == ALL_DOMAIN
	       || (kind == VARIABLES_DOMAIN
		   && PSYMBOL_CLASS (*psym) != LOC_TYPEDEF
		   && PSYMBOL_CLASS (*psym) != LOC_BLOCK)
	       || (kind == FUNCTIONS_DOMAIN
		   && PSYMBOL_CLASS (*psym) == LOC_BLOCK)
	       || (kind == TYPES_DOMAIN
		   && PSYMBOL_CLASS (*psym) == LOC_TYPEDEF))
	      && (*name_matcher) (SYMBOL_SEARCH_NAME (*psym), data))
	    {
	      /* Found a match, so notify our caller.  */
	      result = PST_SEARCHED_AND_FOUND;
	      keep_going = 0;
	    }
	}
      psym++;
    }

  ps->searched_flag = result;
  return result == PST_SEARCHED_AND_FOUND;
}

static void
expand_symtabs_matching_via_partial
  (struct objfile *objfile,
   int (*file_matcher) (const char *, void *, int basenames),
   int (*name_matcher) (const char *, void *),
   enum search_domain kind,
   void *data)
{
  struct partial_symtab *ps;

  /* Clear the search flags.  */
  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
    {
      ps->searched_flag = PST_NOT_SEARCHED;
    }

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
    {
      if (ps->readin)
	continue;

      /* We skip shared psymtabs because file-matching doesn't apply
	 to them; but we search them later in the loop.  */
      if (ps->user != NULL)
	continue;

      if (file_matcher)
	{
	  int match;

	  if (ps->anonymous)
	    continue;

	  match = (*file_matcher) (ps->filename, data, 0);
	  if (!match)
	    {
	      /* Before we invoke realpath, which can get expensive when many
		 files are involved, do a quick comparison of the basenames.  */
	      if (basenames_may_differ
		  || (*file_matcher) (lbasename (ps->filename), data, 1))
		match = (*file_matcher) (psymtab_to_fullname (ps), data, 0);
	    }
	  if (!match)
	    continue;
	}

      if (recursively_search_psymtabs (ps, objfile, kind, name_matcher, data))
	psymtab_to_symtab (objfile, ps);
    }
}

static int
objfile_has_psyms (struct objfile *objfile)
{
  return objfile->psymtabs != NULL;
}

const struct quick_symbol_functions psym_functions =
{
  objfile_has_psyms,
  find_last_source_symtab_from_partial,
  forget_cached_source_info_partial,
  partial_map_symtabs_matching_filename,
  lookup_symbol_aux_psymtabs,
  print_psymtab_stats_for_objfile,
  dump_psymtabs_for_objfile,
  relocate_psymtabs,
  read_symtabs_for_function,
  expand_partial_symbol_tables,
  read_psymtabs_with_fullname,
  map_matching_symbols_psymtab,
  expand_symtabs_matching_via_partial,
  find_pc_sect_symtab_from_partial,
  map_symbol_filenames_psymtab
};



/* This compares two partial symbols by names, using strcmp_iw_ordered
   for the comparison.  */

static int
compare_psymbols (const void *s1p, const void *s2p)
{
  struct partial_symbol *const *s1 = s1p;
  struct partial_symbol *const *s2 = s2p;

  return strcmp_iw_ordered (SYMBOL_SEARCH_NAME (*s1),
			    SYMBOL_SEARCH_NAME (*s2));
}

void
sort_pst_symbols (struct objfile *objfile, struct partial_symtab *pst)
{
  /* Sort the global list; don't sort the static list.  */

  qsort (objfile->global_psymbols.list + pst->globals_offset,
	 pst->n_global_syms, sizeof (struct partial_symbol *),
	 compare_psymbols);
}

/* Allocate and partially fill a partial symtab.  It will be
   completely filled at the end of the symbol list.

   FILENAME is the name of the symbol-file we are reading from.  */

struct partial_symtab *
start_psymtab_common (struct objfile *objfile,
		      struct section_offsets *section_offsets,
		      const char *filename,
		      CORE_ADDR textlow, struct partial_symbol **global_syms,
		      struct partial_symbol **static_syms)
{
  struct partial_symtab *psymtab;

  psymtab = allocate_psymtab (filename, objfile);
  psymtab->section_offsets = section_offsets;
  psymtab->textlow = textlow;
  psymtab->texthigh = psymtab->textlow;		/* default */
  psymtab->globals_offset = global_syms - objfile->global_psymbols.list;
  psymtab->statics_offset = static_syms - objfile->static_psymbols.list;
  return (psymtab);
}

/* Calculate a hash code for the given partial symbol.  The hash is
   calculated using the symbol's value, language, domain, class
   and name.  These are the values which are set by
   add_psymbol_to_bcache.  */

static unsigned long
psymbol_hash (const void *addr, int length)
{
  unsigned long h = 0;
  struct partial_symbol *psymbol = (struct partial_symbol *) addr;
  unsigned int lang = psymbol->ginfo.language;
  unsigned int domain = PSYMBOL_DOMAIN (psymbol);
  unsigned int class = PSYMBOL_CLASS (psymbol);

  h = hash_continue (&psymbol->ginfo.value, sizeof (psymbol->ginfo.value), h);
  h = hash_continue (&lang, sizeof (unsigned int), h);
  h = hash_continue (&domain, sizeof (unsigned int), h);
  h = hash_continue (&class, sizeof (unsigned int), h);
  h = hash_continue (psymbol->ginfo.name, strlen (psymbol->ginfo.name), h);

  return h;
}

/* Returns true if the symbol at addr1 equals the symbol at addr2.
   For the comparison this function uses a symbols value,
   language, domain, class and name.  */

static int
psymbol_compare (const void *addr1, const void *addr2, int length)
{
  struct partial_symbol *sym1 = (struct partial_symbol *) addr1;
  struct partial_symbol *sym2 = (struct partial_symbol *) addr2;

  return (memcmp (&sym1->ginfo.value, &sym1->ginfo.value,
                  sizeof (sym1->ginfo.value)) == 0
	  && sym1->ginfo.language == sym2->ginfo.language
          && PSYMBOL_DOMAIN (sym1) == PSYMBOL_DOMAIN (sym2)
          && PSYMBOL_CLASS (sym1) == PSYMBOL_CLASS (sym2)
          && sym1->ginfo.name == sym2->ginfo.name);
}

/* Initialize a partial symbol bcache.  */

struct psymbol_bcache *
psymbol_bcache_init (void)
{
  struct psymbol_bcache *bcache = XCALLOC (1, struct psymbol_bcache);
  bcache->bcache = bcache_xmalloc (psymbol_hash, psymbol_compare);
  return bcache;
}

/* Free a partial symbol bcache.  */
void
psymbol_bcache_free (struct psymbol_bcache *bcache)
{
  if (bcache == NULL)
    return;

  bcache_xfree (bcache->bcache);
  xfree (bcache);
}

/* Return the internal bcache of the psymbol_bcache BCACHE.  */

struct bcache *
psymbol_bcache_get_bcache (struct psymbol_bcache *bcache)
{
  return bcache->bcache;
}

/* Find a copy of the SYM in BCACHE.  If BCACHE has never seen this
   symbol before, add a copy to BCACHE.  In either case, return a pointer
   to BCACHE's copy of the symbol.  If optional ADDED is not NULL, return
   1 in case of new entry or 0 if returning an old entry.  */

static const struct partial_symbol *
psymbol_bcache_full (struct partial_symbol *sym,
                     struct psymbol_bcache *bcache,
                     int *added)
{
  return bcache_full (sym,
                      sizeof (struct partial_symbol),
                      bcache->bcache,
                      added);
}

/* Helper function, initialises partial symbol structure and stashes 
   it into objfile's bcache.  Note that our caching mechanism will
   use all fields of struct partial_symbol to determine hash value of the
   structure.  In other words, having two symbols with the same name but
   different domain (or address) is possible and correct.  */

static const struct partial_symbol *
add_psymbol_to_bcache (const char *name, int namelength, int copy_name,
		       domain_enum domain,
		       enum address_class class,
		       long val,	/* Value as a long */
		       CORE_ADDR coreaddr,	/* Value as a CORE_ADDR */
		       enum language language, struct objfile *objfile,
		       int *added)
{
  struct partial_symbol psymbol;

  /* We must ensure that the entire struct has been zeroed before
     assigning to it, because an assignment may not touch some of the
     holes.  */
  memset (&psymbol, 0, sizeof (psymbol));

  /* val and coreaddr are mutually exclusive, one of them *will* be zero.  */
  if (val != 0)
    {
      SYMBOL_VALUE (&psymbol) = val;
    }
  else
    {
      SYMBOL_VALUE_ADDRESS (&psymbol) = coreaddr;
    }
  SYMBOL_SECTION (&psymbol) = -1;
  SYMBOL_SET_LANGUAGE (&psymbol, language, &objfile->objfile_obstack);
  PSYMBOL_DOMAIN (&psymbol) = domain;
  PSYMBOL_CLASS (&psymbol) = class;

  SYMBOL_SET_NAMES (&psymbol, name, namelength, copy_name, objfile);

  /* Stash the partial symbol away in the cache.  */
  return psymbol_bcache_full (&psymbol,
                              objfile->psymbol_cache,
                              added);
}

/* Increase the space allocated for LISTP, which is probably
   global_psymbols or static_psymbols.  This space will eventually
   be freed in free_objfile().  */

static void
extend_psymbol_list (struct psymbol_allocation_list *listp,
		     struct objfile *objfile)
{
  int new_size;

  if (listp->size == 0)
    {
      new_size = 255;
      listp->list = (struct partial_symbol **)
	xmalloc (new_size * sizeof (struct partial_symbol *));
    }
  else
    {
      new_size = listp->size * 2;
      listp->list = (struct partial_symbol **)
	xrealloc ((char *) listp->list,
		  new_size * sizeof (struct partial_symbol *));
    }
  /* Next assumes we only went one over.  Should be good if
     program works correctly.  */
  listp->next = listp->list + listp->size;
  listp->size = new_size;
}

/* Helper function, adds partial symbol to the given partial symbol
   list.  */

static void
append_psymbol_to_list (struct psymbol_allocation_list *list,
			const struct partial_symbol *psym,
			struct objfile *objfile)
{
  if (list->next >= list->list + list->size)
    extend_psymbol_list (list, objfile);
  *list->next++ = (struct partial_symbol *) psym;
  OBJSTAT (objfile, n_psyms++);
}

/* Add a symbol with a long value to a psymtab.
   Since one arg is a struct, we pass in a ptr and deref it (sigh).
   Return the partial symbol that has been added.  */

void
add_psymbol_to_list (const char *name, int namelength, int copy_name,
		     domain_enum domain,
		     enum address_class class,
		     struct psymbol_allocation_list *list, 
		     long val,	/* Value as a long */
		     CORE_ADDR coreaddr,	/* Value as a CORE_ADDR */
		     enum language language, struct objfile *objfile)
{
  const struct partial_symbol *psym;

  int added;

  /* Stash the partial symbol away in the cache.  */
  psym = add_psymbol_to_bcache (name, namelength, copy_name, domain, class,
				val, coreaddr, language, objfile, &added);

  /* Do not duplicate global partial symbols.  */
  if (list == &objfile->global_psymbols
      && !added)
    return;

  /* Save pointer to partial symbol in psymtab, growing symtab if needed.  */
  append_psymbol_to_list (list, psym, objfile);
}

/* Initialize storage for partial symbols.  */

void
init_psymbol_list (struct objfile *objfile, int total_symbols)
{
  /* Free any previously allocated psymbol lists.  */

  if (objfile->global_psymbols.list)
    {
      xfree (objfile->global_psymbols.list);
    }
  if (objfile->static_psymbols.list)
    {
      xfree (objfile->static_psymbols.list);
    }

  /* Current best guess is that approximately a twentieth
     of the total symbols (in a debugging file) are global or static
     oriented symbols, then multiply that by slop factor of two.  */

  objfile->global_psymbols.size = total_symbols / 10;
  objfile->static_psymbols.size = total_symbols / 10;

  if (objfile->global_psymbols.size > 0)
    {
      objfile->global_psymbols.next =
	objfile->global_psymbols.list = (struct partial_symbol **)
	xmalloc ((objfile->global_psymbols.size
		  * sizeof (struct partial_symbol *)));
    }
  if (objfile->static_psymbols.size > 0)
    {
      objfile->static_psymbols.next =
	objfile->static_psymbols.list = (struct partial_symbol **)
	xmalloc ((objfile->static_psymbols.size
		  * sizeof (struct partial_symbol *)));
    }
}

struct partial_symtab *
allocate_psymtab (const char *filename, struct objfile *objfile)
{
  struct partial_symtab *psymtab;

  if (objfile->free_psymtabs)
    {
      psymtab = objfile->free_psymtabs;
      objfile->free_psymtabs = psymtab->next;
    }
  else
    psymtab = (struct partial_symtab *)
      obstack_alloc (&objfile->objfile_obstack,
		     sizeof (struct partial_symtab));

  memset (psymtab, 0, sizeof (struct partial_symtab));
  psymtab->filename = obstack_copy0 (&objfile->objfile_obstack,
				     filename, strlen (filename));
  psymtab->symtab = NULL;

  /* Prepend it to the psymtab list for the objfile it belongs to.
     Psymtabs are searched in most recent inserted -> least recent
     inserted order.  */

  psymtab->next = objfile->psymtabs;
  objfile->psymtabs = psymtab;

  if (symtab_create_debug)
    {
      /* Be a bit clever with debugging messages, and don't print objfile
	 every time, only when it changes.  */
      static char *last_objfile_name = NULL;

      if (last_objfile_name == NULL
	  || strcmp (last_objfile_name, objfile_name (objfile)) != 0)
	{
	  xfree (last_objfile_name);
	  last_objfile_name = xstrdup (objfile_name (objfile));
	  fprintf_unfiltered (gdb_stdlog,
			      "Creating one or more psymtabs for objfile %s ...\n",
			      last_objfile_name);
	}
      fprintf_unfiltered (gdb_stdlog,
			  "Created psymtab %s for module %s.\n",
			  host_address_to_string (psymtab), filename);
    }

  return (psymtab);
}

void
discard_psymtab (struct objfile *objfile, struct partial_symtab *pst)
{
  struct partial_symtab **prev_pst;

  /* From dbxread.c:
     Empty psymtabs happen as a result of header files which don't
     have any symbols in them.  There can be a lot of them.  But this
     check is wrong, in that a psymtab with N_SLINE entries but
     nothing else is not empty, but we don't realize that.  Fixing
     that without slowing things down might be tricky.  */

  /* First, snip it out of the psymtab chain.  */

  prev_pst = &(objfile->psymtabs);
  while ((*prev_pst) != pst)
    prev_pst = &((*prev_pst)->next);
  (*prev_pst) = pst->next;

  /* Next, put it on a free list for recycling.  */

  pst->next = objfile->free_psymtabs;
  objfile->free_psymtabs = pst;
}

/* An object of this type is passed to discard_psymtabs_upto.  */

struct psymtab_state
{
  /* The objfile where psymtabs are discarded.  */

  struct objfile *objfile;

  /* The first psymtab to save.  */

  struct partial_symtab *save;
};

/* A cleanup function used by make_cleanup_discard_psymtabs.  */

static void
discard_psymtabs_upto (void *arg)
{
  struct psymtab_state *state = arg;

  while (state->objfile->psymtabs != state->save)
    discard_psymtab (state->objfile, state->objfile->psymtabs);
}

/* Return a new cleanup that discards all psymtabs created in OBJFILE
   after this function is called.  */

struct cleanup *
make_cleanup_discard_psymtabs (struct objfile *objfile)
{
  struct psymtab_state *state = XNEW (struct psymtab_state);

  state->objfile = objfile;
  state->save = objfile->psymtabs;

  return make_cleanup_dtor (discard_psymtabs_upto, state, xfree);
}



static void
maintenance_print_psymbols (char *args, int from_tty)
{
  char **argv;
  struct ui_file *outfile;
  struct cleanup *cleanups;
  char *symname = NULL;
  char *filename = DEV_TTY;
  struct objfile *objfile;
  struct partial_symtab *ps;

  dont_repeat ();

  if (args == NULL)
    {
      error (_("\
print-psymbols takes an output file name and optional symbol file name"));
    }
  argv = gdb_buildargv (args);
  cleanups = make_cleanup_freeargv (argv);

  if (argv[0] != NULL)
    {
      filename = argv[0];
      /* If a second arg is supplied, it is a source file name to match on.  */
      if (argv[1] != NULL)
	{
	  symname = argv[1];
	}
    }

  filename = tilde_expand (filename);
  make_cleanup (xfree, filename);

  outfile = gdb_fopen (filename, FOPEN_WT);
  if (outfile == 0)
    perror_with_name (filename);
  make_cleanup_ui_file_delete (outfile);

  ALL_PSYMTABS (objfile, ps)
    {
      QUIT;
      if (symname == NULL || filename_cmp (symname, ps->filename) == 0)
	dump_psymtab (objfile, ps, outfile);
    }
  do_cleanups (cleanups);
}

/* List all the partial symbol tables whose names match REGEXP (optional).  */
static void
maintenance_info_psymtabs (char *regexp, int from_tty)
{
  struct program_space *pspace;
  struct objfile *objfile;

  if (regexp)
    re_comp (regexp);

  ALL_PSPACES (pspace)
    ALL_PSPACE_OBJFILES (pspace, objfile)
    {
      struct gdbarch *gdbarch = get_objfile_arch (objfile);
      struct partial_symtab *psymtab;

      /* We don't want to print anything for this objfile until we
         actually find a symtab whose name matches.  */
      int printed_objfile_start = 0;

      ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, psymtab)
	{
	  QUIT;

	  if (! regexp
	      || re_exec (psymtab->filename))
	    {
	      if (! printed_objfile_start)
		{
		  printf_filtered ("{ objfile %s ", objfile_name (objfile));
		  wrap_here ("  ");
		  printf_filtered ("((struct objfile *) %s)\n", 
				   host_address_to_string (objfile));
		  printed_objfile_start = 1;
		}

	      printf_filtered ("  { psymtab %s ", psymtab->filename);
	      wrap_here ("    ");
	      printf_filtered ("((struct partial_symtab *) %s)\n", 
			       host_address_to_string (psymtab));

	      printf_filtered ("    readin %s\n",
			       psymtab->readin ? "yes" : "no");
	      printf_filtered ("    fullname %s\n",
			       psymtab->fullname
			       ? psymtab->fullname : "(null)");
	      printf_filtered ("    text addresses ");
	      fputs_filtered (paddress (gdbarch, psymtab->textlow),
			      gdb_stdout);
	      printf_filtered (" -- ");
	      fputs_filtered (paddress (gdbarch, psymtab->texthigh),
			      gdb_stdout);
	      printf_filtered ("\n");
	      printf_filtered ("    psymtabs_addrmap_supported %s\n",
			       (psymtab->psymtabs_addrmap_supported
				? "yes" : "no"));
	      printf_filtered ("    globals ");
	      if (psymtab->n_global_syms)
		{
		  printf_filtered ("(* (struct partial_symbol **) %s @@ %d)\n",
				   host_address_to_string (objfile->global_psymbols.list
				    + psymtab->globals_offset),
				   psymtab->n_global_syms);
		}
	      else
		printf_filtered ("(none)\n");
	      printf_filtered ("    statics ");
	      if (psymtab->n_static_syms)
		{
		  printf_filtered ("(* (struct partial_symbol **) %s @@ %d)\n",
				   host_address_to_string (objfile->static_psymbols.list
				    + psymtab->statics_offset),
				   psymtab->n_static_syms);
		}
	      else
		printf_filtered ("(none)\n");
	      printf_filtered ("    dependencies ");
	      if (psymtab->number_of_dependencies)
		{
		  int i;

		  printf_filtered ("{\n");
		  for (i = 0; i < psymtab->number_of_dependencies; i++)
		    {
		      struct partial_symtab *dep = psymtab->dependencies[i];

		      /* Note the string concatenation there --- no comma.  */
		      printf_filtered ("      psymtab %s "
				       "((struct partial_symtab *) %s)\n",
				       dep->filename, 
				       host_address_to_string (dep));
		    }
		  printf_filtered ("    }\n");
		}
	      else
		printf_filtered ("(none)\n");
	      printf_filtered ("  }\n");
	    }
	}

      if (printed_objfile_start)
        printf_filtered ("}\n");
    }
}

/* Check consistency of currently expanded psymtabs vs symtabs.  */

static void
maintenance_check_psymtabs (char *ignore, int from_tty)
{
  struct symbol *sym;
  struct partial_symbol **psym;
  struct symtab *s = NULL;
  struct partial_symtab *ps;
  struct blockvector *bv;
  struct objfile *objfile;
  struct block *b;
  int length;

  ALL_PSYMTABS (objfile, ps)
  {
    struct gdbarch *gdbarch = get_objfile_arch (objfile);

    /* We don't call psymtab_to_symtab here because that may cause symtab
       expansion.  When debugging a problem it helps if checkers leave
       things unchanged.  */
    s = ps->symtab;

    /* First do some checks that don't require the associated symtab.  */
    if (ps->texthigh < ps->textlow)
      {
	printf_filtered ("Psymtab ");
	puts_filtered (ps->filename);
	printf_filtered (" covers bad range ");
	fputs_filtered (paddress (gdbarch, ps->textlow), gdb_stdout);
	printf_filtered (" - ");
	fputs_filtered (paddress (gdbarch, ps->texthigh), gdb_stdout);
	printf_filtered ("\n");
	continue;
      }

    /* Now do checks requiring the associated symtab.  */
    if (s == NULL)
      continue;
    bv = BLOCKVECTOR (s);
    b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);
    psym = objfile->static_psymbols.list + ps->statics_offset;
    length = ps->n_static_syms;
    while (length--)
      {
	sym = lookup_block_symbol (b, SYMBOL_LINKAGE_NAME (*psym),
				   SYMBOL_DOMAIN (*psym));
	if (!sym)
	  {
	    printf_filtered ("Static symbol `");
	    puts_filtered (SYMBOL_LINKAGE_NAME (*psym));
	    printf_filtered ("' only found in ");
	    puts_filtered (ps->filename);
	    printf_filtered (" psymtab\n");
	  }
	psym++;
      }
    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);
    psym = objfile->global_psymbols.list + ps->globals_offset;
    length = ps->n_global_syms;
    while (length--)
      {
	sym = lookup_block_symbol (b, SYMBOL_LINKAGE_NAME (*psym),
				   SYMBOL_DOMAIN (*psym));
	if (!sym)
	  {
	    printf_filtered ("Global symbol `");
	    puts_filtered (SYMBOL_LINKAGE_NAME (*psym));
	    printf_filtered ("' only found in ");
	    puts_filtered (ps->filename);
	    printf_filtered (" psymtab\n");
	  }
	psym++;
      }
    if (ps->texthigh != 0
	&& (ps->textlow < BLOCK_START (b) || ps->texthigh > BLOCK_END (b)))
      {
	printf_filtered ("Psymtab ");
	puts_filtered (ps->filename);
	printf_filtered (" covers ");
	fputs_filtered (paddress (gdbarch, ps->textlow), gdb_stdout);
	printf_filtered (" - ");
	fputs_filtered (paddress (gdbarch, ps->texthigh), gdb_stdout);
	printf_filtered (" but symtab covers only ");
	fputs_filtered (paddress (gdbarch, BLOCK_START (b)), gdb_stdout);
	printf_filtered (" - ");
	fputs_filtered (paddress (gdbarch, BLOCK_END (b)), gdb_stdout);
	printf_filtered ("\n");
      }
  }
}



void
expand_partial_symbol_names (int (*fun) (const char *, void *),
			     void *data)
{
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
  {
    if (objfile->sf)
      objfile->sf->qf->expand_symtabs_matching (objfile, NULL, fun,
						ALL_DOMAIN, data);
  }
}

void
map_partial_symbol_filenames (symbol_filename_ftype *fun, void *data,
			      int need_fullname)
{
  struct objfile *objfile;

  ALL_OBJFILES (objfile)
  {
    if (objfile->sf)
      objfile->sf->qf->map_symbol_filenames (objfile, fun, data,
					     need_fullname);
  }
}

extern initialize_file_ftype _initialize_psymtab;

void
_initialize_psymtab (void)
{
  add_cmd ("psymbols", class_maintenance, maintenance_print_psymbols, _("\
Print dump of current partial symbol definitions.\n\
Entries in the partial symbol table are dumped to file OUTFILE.\n\
If a SOURCE file is specified, dump only that file's partial symbols."),
	   &maintenanceprintlist);

  add_cmd ("psymtabs", class_maintenance, maintenance_info_psymtabs, _("\
List the partial symbol tables for all object files.\n\
This does not include information about individual partial symbols,\n\
just the symbol table structures themselves."),
	   &maintenanceinfolist);

  add_cmd ("check-psymtabs", class_maintenance, maintenance_check_psymtabs,
	   _("\
Check consistency of currently expanded psymtabs versus symtabs."),
	   &maintenancelist);
}
@


1.78
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d1241 3
a1243 2
map_matching_symbols_psymtab (const char *name, domain_enum namespace,
			      struct objfile *objfile, int global,
@


1.77
log
@remove unused qf method

After the previous patch in the series, nothing uses the "quick"
method find_symbol_file.

This patch removes it.

Tested by rebuilding.

	* dwarf2read.c (dw2_get_primary_filename_reader): Remove.
	(dwarf2_gdb_index_functions): Update.
	* psymtab.c (find_symbol_file_from_partial): Remove.
	(psym_functions): Update.
	* symfile.h (struct quick_symbol_functions) <find_symbol_file>:
	Remove.
@
text
@d89 1
a89 1
				 objfile->name);
d977 1
a977 1
		      objfile->name);
d1762 1
a1762 1
	  || strcmp (last_objfile_name, objfile->name) != 0)
d1765 1
a1765 1
	  last_objfile_name = xstrdup (objfile->name);
d1920 1
a1920 1
		  printf_filtered ("{ objfile %s ", objfile->name);
@


1.76
log
@	* NEWS: Mention new maintenance commands check-symtabs, and
	expand-symtabs, and renamed check-psymtabs.
	* psymtab.c (maintenance_check_psymtabs): Renamed from
	maintenance_check_symtabs.  Only process already-expanded symbol
	tables.
	(_initialize_psymtab): Update.
	* symmisc.c (maintenance_check_symtabs): New function.
	(maintenance_expand_name_matcher): New function
	(maintenance_expand_file_matcher): New function
	(maintenance_expand_symtabs): New function.
	(_initialize_symmisc): Add "mt check-symtabs" and "mt expand-symtabs"
	commands.

	doc/
	* gdb.texinfo (Maintenance Commands): Update doc for
	"maint check-psymtabs".  Add doc for "maint check-symtabs",
	"maint expand-symtabs".

	testsuite/
	* gdb.base/maint.exp: Update test for "maint check-psymtabs".
	Add tests for "maint check-symtabs", "maint expand-symtabs".
@
text
@a1208 13
static const char *
find_symbol_file_from_partial (struct objfile *objfile, const char *name)
{
  struct partial_symtab *pst;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)
    {
      if (lookup_partial_symbol (objfile, pst, name, 1, VAR_DOMAIN))
	return pst->filename;
    }
  return NULL;
}

a1431 1
  find_symbol_file_from_partial,
@


1.75
log
@	* psymtab.c (expand_symtabs_matching_via_partial): Fix file name
	matching test.
@
text
@d2010 1
a2010 1
/* Check consistency of psymtabs and symtabs.  */
d2013 1
a2013 1
maintenance_check_symtabs (char *ignore, int from_tty)
d2028 19
a2046 1
    s = psymtab_to_symtab (objfile, ps);
d2084 2
a2085 14
    if (ps->texthigh < ps->textlow)
      {
	printf_filtered ("Psymtab ");
	puts_filtered (ps->filename);
	printf_filtered (" covers bad range ");
	fputs_filtered (paddress (gdbarch, ps->textlow), gdb_stdout);
	printf_filtered (" - ");
	fputs_filtered (paddress (gdbarch, ps->texthigh), gdb_stdout);
	printf_filtered ("\n");
	continue;
      }
    if (ps->texthigh == 0)
      continue;
    if (ps->textlow < BLOCK_START (b) || ps->texthigh > BLOCK_END (b))
d2149 3
a2151 2
  add_cmd ("check-symtabs", class_maintenance, maintenance_check_symtabs,
	   _("Check consistency of psymtabs and symtabs."),
@


1.74
log
@	* dbxread.c (process_one_symbol): Constify section_offsets parameter.
	* stabsread.h (process_one_symbol): Update declaration.
	* dwarf2read.c (dw2_relocate): Constify new_offsets, delta parameters.
	* elfread.c (elf_symfile_relocate_probe): Ditto.
	* psymtab.c (relocate_psymtabs): Ditto.
	* objfiles.c (objfile_relocate1): Constify new_offsets parameter.
	(objfile_relocate): Ditto.
	* objfiles.h (objfile_relocate): Update declaration.
	* symfile.c (relative_addr_info_to_section_offsets): Constify
	addrs parameter.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile_1): Constify offsets parameter.
	(syms_from_objfile): Ditto.
	(symbol_file_add_with_addrs_or_offsets): Ditto.
	(symfile_map_offsets_to_segments): Constify data parameter.
	* symfile.h (struct quick_symbol_functions): Constify new_offsets,
	delta parameters of member relocate.
	(struct sym_probe_fns): Constify new_offsets,
	delta parameters of member sym_relocate_probe.
	(struct sym_fns): Constify section_addr_info parameter of member
	sym_offsets.
	(relative_addr_info_to_section_offsets): Update declaration.
	(default_symfile_offsets): Ditto.
	(syms_from_objfile): Ditto.
	(symfile_map_offsets_to_segments): Ditto.
@
text
@d1403 2
d1408 6
a1413 4
	  /* Before we invoke realpath, which can get expensive when many
	     files are involved, do a quick comparison of the basenames.  */
	  if (!(*file_matcher) (ps->filename, data, 0)
	      && (basenames_may_differ
d1415 3
a1417 1
	      && !(*file_matcher) (psymtab_to_fullname (ps), data, 0))
@


1.73
log
@	PR symtab/8424:
	* blockframe.c (find_pc_partial_function_gnu_ifunc): Check
	SYMBOL_SECTION, not SYMBOL_OBJ_SECTION.
	* breakpoint.c (resolve_sal_pc): Update.
	* elfread.c (elf_gnu_ifunc_record_cache): Update.
	* findvar.c (struct minsym_lookup_data) <objfile>: New field.
	(minsym_lookup_iterator_cb): Use it.
	(default_read_var_value): Update.
	* hppa-hpux-tdep.c (hppa64_hpux_in_solib_call_trampoline):
	Update.
	* infcmd.c (jump_command): Update.
	* linespec.c (minsym_found): Update.
	* maint.c (maintenance_translate_address): Update.
	* minsyms.c (lookup_minimal_symbol_by_pc_section_1): Update.
	(prim_record_minimal_symbol_full): Don't set SYMBOL_OBJ_SECTION.
	* parse.c (write_exp_msymbol): Update.
	* printcmd.c (address_info): Update.
	* psymtab.c (find_pc_sect_psymbol): Update.
	(fixup_psymbol_section): Check SYMBOL_SECTION, not
	SYMBOL_OBJ_SECTION.
	(add_psymbol_to_bcache): Correctly initialize SYMBOL_SECTION.
	Don't initialize SYMBOL_OBJ_SECTION.
	* spu-tdep.c (spu_catch_start): Update.
	* stabsread.c (define_symbol): Don't set SYMBOL_SECTION.
	* symmisc.c (dump_msymbols, print_symbol): Update.
	* symtab.c (fixup_section): Don't set 'obj_section'.  Change
	how fallback section is computed.
	(fixup_symbol_section): Update.
	(find_pc_sect_symtab, find_function_start_sal, skip_prologue_sal):
	Update.
	(allocate_symbol, initialize_symbol, allocate_template_symbol):
	Initialize SYMBOL_SECTION.
	* symtab.h (struct general_symbol_info) <section>: Update comment.
	<obj_section>: Remove.
	(SYMBOL_OBJ_SECTION): Add 'objfile' argument.  Rewrite.
	(SYMBOL_OBJFILE): New macro.
@
text
@d788 2
a789 2
		   struct section_offsets *new_offsets,
		   struct section_offsets *delta)
@


1.72
log
@	* ada-lang.c (ada_decode_symbol): Check and set 'ada_mangled'.
	Use symbol's obstack, not an objfile.
	* coffread.c (process_coff_symbol): Update.
	* dwarf2read.c (fixup_go_packaging, new_symbol_full): Update.
	* jv-lang.c (add_class_symbol): Update.
	* mdebugread.c (new_symbol): Update.
	* minsyms.c (prim_record_minimal_symbol_full)
	(terminate_minimal_symbol_table): Update.
	* psymtab.c (add_psymbol_to_bcache): Clear entire symbol.  Update.
	* stabsread.c (define_symbol, read_enum_type): Update.
	* symtab.c (symbol_set_demangled_name, symbol_get_demangled_name):
	Handle Ada specially.
	(symbol_set_language): Add 'obstack' argument.
	(symbol_set_names): Update.
	(symbol_natural_name, symbol_demangled_name): Always use
	ada_decode_symbol.
	* symtab.h (struct general_symbol_info)
	<language_specific::obstack>: New field.
	<ada_mangled>: New field.
	(SYMBOL_SET_LANGUAGE): Add 'obstack' argument.
	(symbol_set_language): Update.
@
text
@d432 2
a433 1
	      if (!matching_obj_sections (SYMBOL_OBJ_SECTION (p), section))
d457 2
a458 1
	      if (!matching_obj_sections (SYMBOL_OBJ_SECTION (p), section))
d474 4
a477 1
  if (psym == NULL || SYMBOL_OBJ_SECTION (psym) != NULL)
d1611 1
a1611 2
  SYMBOL_SECTION (&psymbol) = 0;
  SYMBOL_OBJ_SECTION (&psymbol) = NULL;
@


1.71
log
@	* psymtab.c (read_psymtabs_with_fullname): Don't call
	psymtab_to_fullname if the basenames are different.
@
text
@d1592 4
a1595 4
  /* We must ensure that the entire 'value' field has been zeroed
     before assigning to it, because an assignment may not write the
     entire field.  */
  memset (&psymbol.ginfo.value, 0, sizeof (psymbol.ginfo.value));
d1608 1
a1608 1
  SYMBOL_SET_LANGUAGE (&psymbol, language);
@


1.70
log
@	* psymtab.c (find_pc_sect_psymbol, fixup_psymbol_section)
	(print_partial_symbols, recursively_search_psymtabs): Use
	PSYMBOL_CLASS.
@
text
@d1117 5
a1121 1
      if (filename_cmp (fullname, psymtab_to_fullname (p)) == 0)
@


1.69
log
@gdb/
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Put continue after
	any successful compare_filenames_for_search or FILENAME_CMP.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symtab.c (iterate_over_some_symtabs): Likewise.
@
text
@d423 1
a423 1
	  && SYMBOL_CLASS (p) == LOC_BLOCK
d447 1
a447 1
	  && SYMBOL_CLASS (p) == LOC_BLOCK
d477 1
a477 1
  switch (SYMBOL_CLASS (psym))
d893 1
a893 1
      switch (SYMBOL_CLASS (*p))
d1346 2
a1347 2
		   && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
		   && SYMBOL_CLASS (*psym) != LOC_BLOCK)
d1349 1
a1349 1
		   && SYMBOL_CLASS (*psym) == LOC_BLOCK)
d1351 1
a1351 1
		   && SYMBOL_CLASS (*psym) == LOC_TYPEDEF))
@


1.68
log
@gdb/
	* dwarf2read.c (dw2_expand_symtabs_matching): Add basenames parameter
	to the file_matcher parameter.  Pass 0 to it.
	(dwarf2_create_include_psymtab): Copy also DIRNAME.
	* psymtab.c (partial_map_symtabs_matching_filename): Drop handling of
	NULL psymtab_to_fullname result.
	(psymtab_to_fullname): Remove variable r.  Never return NULL, assemble
	an expected filename instead.
	(expand_symtabs_matching_via_partial): Add basenames parameter to the
	file_matcher parameter.  Call also psymtab_to_fullname, after newly
	considering BASENAMES_MAY_DIFFER.
	* source.c (rewrite_source_path): Remove static.
	* source.h (rewrite_source_path): New declaration.
	* symfile.h (struct quick_symbol_functions): Add basenames parameter to
	the expand_symtabs_matching field.  Comment it.
	* symtab.c (file_matches): New function comment.  Add parameter
	basenames, implement it.
	(search_symbols_file_matches): Add basenames parameter.  Update the
	file_matches caller.
	(search_symbols): Match FILES also against symtab_to_fullname.
	Optimize it for BASENAMES_MAY_DIFFER.

gdb/testsuite/
	* gdb.base/fullpath-expand-func.c: New file.
	* gdb.base/fullpath-expand.c: New file.
	* gdb.base/fullpath-expand.exp: New file.
	* gdb.base/realname-expand-real.c: New file.
	* gdb.base/realname-expand.c: New file.
	* gdb.base/realname-expand.exp: New file.
@
text
@d186 1
d200 1
d214 1
@


1.68.2.1
log
@	* psymtab.c (read_psymtabs_with_fullname): Don't call
	psymtab_to_fullname if the basenames are different.
@
text
@d1114 1
a1114 5
      /* psymtab_to_fullname tries to open the file which is slow.
	 Don't call it if we know the basenames don't match.  */
      if ((basenames_may_differ
	   || filename_cmp (lbasename (fullname), lbasename (p->filename)) == 0)
	  && filename_cmp (fullname, psymtab_to_fullname (p)) == 0)
@


1.67
log
@gdb/
	* ada-lang.c (user_select_syms): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* breakpoint.c (print_breakpoint_location, resolve_sal_pc): Likewise.
	(clear_command): New variable sal_fullname, initialize it.  Replace
	compare_filenames_for_search by filename_cmp with sal_fullname.
	(say_where, update_static_tracepoint): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* cli/cli-cmds.c (edit_command, list_command, ambiguous_line_spec):
	Likewise.
	* dwarf2read.c: Include source.h.
	(fixup_go_packaging): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* linespec.c (add_sal_to_sals): Rename variable filename to fullname.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(create_sals_line_offset, convert_linespec_to_sals): New variable
	fullname, initialize it, replace symtab->filename reference by the
	variable.
	* linux-fork.c: Include source.h.
	(info_checkpoints_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* macroscope.c (sal_macro_scope): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	* mdebugread.c: Include source.h.
	(psymtab_to_symtab_1): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* mi/mi-cmd-file.c (mi_cmd_file_list_exec_source_file)
	(mi_cmd_file_list_exec_source_files): Likewise.
	* printcmd.c: Include source.h.
	(build_address_symbolic): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* psymtab.c (partial_map_symtabs_matching_filename)
	(read_psymtabs_with_fullname): Call compare_filenames_for_search also
	with psymtab_to_fullname.
	* python/py-symtab.c (stpy_str): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(stpy_get_filename): New variable filename, initialize it, use instead
	of symtab->filename refererences.
	(salpy_str): Make variable filename const char *.  Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	* skip.c: Include source.h and filenames.h.
	(skip_file_command): Remove const from the symtab variable.  Replace
	symtab->filename refererences by symtab_to_fullname call.
	(function_name_is_marked_for_skip): New variables searched_for_fullname
	and fullname.  Use them to search also with symtab's fullname.
	* source.c (find_source_lines): Replace symtab->filename refererences
	by symtab_to_filename_for_display calls.
	(print_source_lines_base): New variable filename, use it instead of
	symtab->filename.  Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(line_info, forward_search_command): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	(reverse_search_command): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.  New variable filename for it.
	* stack.c (frame_info): Likewise.
	* symmisc.c: Include source.h.
	(dump_objfile, dump_symtab_1, maintenance_print_symbols)
	(maintenance_info_symtabs): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	* symtab.c (iterate_over_some_symtabs): Call
	compare_filenames_for_search also with symtab_to_fullname.
	(lookup_symbol_aux_quick, basic_lookup_transparent_type_quick): Replace
	symtab->filename refererences by symtab_to_filename_for_display calls.
	(find_line_symtab): Replace symtab->filename refererences by
	symtab_to_filename_for_display calls.
	(file_matches): Replace filename_cmp by compare_filenames_for_search.
	(print_symbol_info): Make the last parameter const char *.  New
	variable s_filename.  Use it in the function.
	(symtab_symbol_info): Make the last_filename variable const char *.
	Replace symtab->filename refererences by symtab_to_filename_for_display
	calls.
	(rbreak_command): New variable fullname.  Use it.  Replace
	symtab->filename refererence by symtab_to_filename_for_display call.
	* tracepoint.c (set_traceframe_context, trace_find_line_command)
	(print_one_static_tracepoint_marker): Replace symtab->filename
	refererences by symtab_to_filename_for_display calls.
	* tui/tui-source.c (tui_set_source_content): New variables filename and
	s_filename.  Replace symtab->filename refererences by this variable.
	Replace other symtab->filename refererences by
	symtab_to_filename_for_display calls.
@
text
@d207 1
a207 3
	psymtab_to_fullname (pst);
	if (pst->fullname != NULL
	    && FILENAME_CMP (real_path, pst->fullname) == 0)
d1162 1
a1162 6
  int r;

  if (!ps)
    return NULL;
  if (ps->anonymous)
    return NULL;
d1167 13
a1179 2
  if (ps->fullname)
    return ps->fullname;
d1181 4
a1184 1
  r = find_and_open_source (ps->filename, ps->dirname, &ps->fullname);
d1186 7
a1192 5
  if (r >= 0)
    {
      close (r);
      return ps->fullname;
    }
d1194 1
a1194 1
  return NULL;
d1366 1
a1366 1
   int (*file_matcher) (const char *, void *),
d1393 7
a1399 1
	  if (! (*file_matcher) (ps->filename, data))
@


1.66
log
@gdb/
	Code cleanup.
	* dwarf2read.c (dw2_expand_symtabs_with_filename): Rename to ...
	(dw2_expand_symtabs_with_fullname): ... here.  Rename parameter
	filename to fullname.  Rename variable this_name to this_fullname.
	Lowercase FILENAME_CMP call.
	(dw2_find_symbol_file): New comment for the returned string.
	(dwarf2_gdb_index_functions): Rename the function to
	dw2_expand_symtabs_with_fullname.
	* psymtab.c (read_psymtabs_with_filename): Rename to ...
	(read_psymtabs_with_fullname): ... here.  Rename parameter filename to
	fullname.
	(psym_functions): Rename the function to read_psymtabs_with_fullname.
	* symfile.h (struct quick_symbol_functions): Rename field
	expand_symtabs_with_filename to expand_symtabs_with_fullname and its
	parameter filename to fullname.  Document returned string meaning for
	find_symbol_file.
	* symtab.c (find_line_symtab): Rename the called function to
	expand_symtabs_with_fullname.
@
text
@d194 7
d1116 1
a1116 1
      if (filename_cmp (fullname, p->filename) == 0)
@


1.65
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable is_abs, unify the
	call of filename_cmp with compare_filenames_for_search.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	is_abs, unify the call of FILENAME_CMP with
	compare_filenames_for_search.  New gdb_asserts for real_path and name.
	Unify the call of compare_filenames_for_search with FILENAME_CMP.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symfile.h (struct quick_symbol_functions): Extend the comment for
	map_symtabs_matching_filename.
	* symtab.c (compare_filenames_for_search): Remove the function comment
	relative path requirement.  Handle absolute filenames, with a comment.
	(iterate_over_some_symtabs): Remove variable is_abs, unify the call of
	FILENAME_CMP with compare_filenames_for_search.  New gdb_asserts for
	real_path and name.  Unify the call of compare_filenames_for_search
	with FILENAME_CMP.
	(iterate_over_symtabs): New gdb_assert on REAL_PATH.

gdb/testsuite/
	* gdb.mi/mi-fullname-deleted.exp: Use double last slash for $srcfileabs.
	(compare_filenames_for_search does not match)
	(compare_filenames_for_search does match): New tests.
@
text
@d1099 1
a1099 1
read_psymtabs_with_filename (struct objfile *objfile, const char *filename)
d1109 1
a1109 1
      if (filename_cmp (filename, p->filename) == 0)
d1404 1
a1404 1
  read_psymtabs_with_filename,
@


1.64
log
@gdb/
	Replace xfullpath calls by gdb_realpath calls.
	* cli/cli-cmds.c (find_and_open_script): Remove xfullpath from the
	function comment.
	* dwarf2read.c (dw2_map_expand_apply): Remove parameter full_path.
	Remove it from the iterate_over_some_symtabs call.
	(dw2_map_symtabs_matching_filename): Remove parameter full_path.
	Remove it from the dw2_map_expand_apply calls, remove a block handling
	it.
	* psymtab.c (partial_map_expand_apply): Remove parameter full_path.
	Remove it from the iterate_over_some_symtabs call.
	(partial_map_symtabs_matching_filename): Remove parameter full_path.
	Remove it from the partial_map_expand_apply calls, remove a block
	handling it.  Drop gdb_realpath call and cleanups from the real_path
	handling.
	* source.c (openp): Drop the comment part about xfullpath.  Replace
	xfullpath calls by gdb_realpath calls.
	(find_and_open_source): Replace xfullpath call by gdb_realpath call.
	* symfile.h (struct quick_symbol_functions): Remove parameter full_path
	from method map_symtabs_matching_filename and its comment.
	* symmisc.c (maintenance_print_msymbols): Replace xfullpath call by
	gdb_realpath call.
	* symtab.c (iterate_over_some_symtabs): Remove parameter full_path,
	remove it also from the function comment, remove a block handling it.
	Drop gdb_realpath call and cleanups from the real_path handling.
	(iterate_over_symtabs): Drop variable full_path and its use.
	* symtab.h (iterate_over_some_symtabs): Remove parameter full_path.
	* utils.c (xfullpath): Remove.
	* utils.h (xfullpath): Remove.

gdb/testsuite/
	* gdb.gdb/xfullpath.exp: Replace xfullpath calls by gdb_realpath calls.
@
text
@a168 1
  int is_abs = IS_ABSOLUTE_PATH (name);
d181 1
a181 2
    if (FILENAME_CMP (name, pst->filename) == 0
	|| (!is_abs && compare_filenames_for_search (pst->filename, name)))
d198 2
d202 1
a202 2
	    && (FILENAME_CMP (real_path, pst->fullname) == 0
		|| (!is_abs && compare_filenames_for_search (real_path, name))))
@


1.63
log
@	* symfile.h (obsavestring): Don't declare.
	* symfile.c (obsavestring): Remove.
	* ada-exp.y: Use obstack_copy0, not obsavestring.
	* ada-lang.c: Use obstack_copy0, not obsavestring.
	* coffread.c: Use obstack_copy0, not obsavestring.
	* cp-namespace.c: Use obstack_copy0, not obsavestring.
	* dbxread.c: Use obstack_copy0, not obsavestring.
	* dwarf2read.c: Use obstack_copy0, not obsavestring.
	* jit.c: Use obstack_copy0, not obsavestring.
	* mdebugread.c: Use obstack_copy0, not obsavestring.
	* psymtab.c: Use obstack_copy0, not obsavestring.
	* stabsread.c: Use obstack_copy0, not obsavestring.
	* xcoffread.c: Use obstack_copy0, not obsavestring.
@
text
@a133 1
			  const char *full_path,
d153 1
a153 1
  return iterate_over_some_symtabs (name, full_path, real_path, callback, data,
a161 1
				       const char *full_path,
d185 1
a185 1
	if (partial_map_expand_apply (objfile, name, full_path, real_path,
d198 1
a198 1
    if (full_path != NULL)
d202 1
a202 21
	    && (FILENAME_CMP (full_path, pst->fullname) == 0
		|| (!is_abs && compare_filenames_for_search (pst->fullname,
							     name))))
	  {
	    if (partial_map_expand_apply (objfile, name, full_path, real_path,
					  pst, callback, data))
	      return 1;
	  }
      }

    if (real_path != NULL)
      {
        char *rp = NULL;
	psymtab_to_fullname (pst);
        if (pst->fullname != NULL)
          {
            rp = gdb_realpath (pst->fullname);
            make_cleanup (xfree, rp);
          }
	if (rp != NULL
	    && (FILENAME_CMP (real_path, rp) == 0
d205 1
a205 1
	    if (partial_map_expand_apply (objfile, name, full_path, real_path,
@


1.62
log
@gdb/
	* dbxread.c (dbx_psymtab_to_symtab): Delete the declaration.
	(dbx_read_symtab): New declaration.
	(dbx_psymtab_to_symtab): Delete.
	(dbx_read_symtab): Rename from dbx_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(start_psymtab): Caller update.
	* dwarf2read.c (dwarf2_psymtab_to_symtab): Delete the declaration.
	(dwarf2_read_symtab): New declaration.
	(dwarf2_psymtab_to_symtab): Delete.
	(dwarf2_read_symtab): Rename from dwarf2_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(create_partial_symtab): Caller update.
	* mdebugread.c (mdebug_psymtab_to_symtab): Delete.
	(mdebug_read_symtab): Rename from mdebug_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(parse_partial_symbols, new_psymtab): Caller update.
	* psympriv.h (struct partial_symtab) <read_symtab>: Exchange
	two parameters.
	* psymtab.c (psymtab_to_symtab): Caller update.
	* xcoffread.c (xcoff_psymtab_to_symtab): Delete.
	(xcoff_read_symtab): Rename from xcoff_psymtab_to_symtab.
	Rename parameter PST to SELF.  Exchanged two parameters.
	(xcoff_start_psymtab): Caller update.
@
text
@d1742 2
a1743 2
  psymtab->filename = obsavestring (filename, strlen (filename),
				    &objfile->objfile_obstack);
@


1.61
log
@	PR symtab/14931:
	* psymtab.c (struct psymtab_state): New.
	(discard_psymtabs_upto, make_cleanup_discard_psymtabs): New
	functions.
	* psympriv.h (make_cleanup_discard_psymtabs): Declare.
	* dwarf2read.c (dwarf2_build_psymtabs): Catch exceptions.
gdb/testsuite
	* gdb.dwarf2/dw2-error.exp: New file.
	* gdb.dwarf2/dw2-error.c: New file.
	* gdb.dwarf2/dw2-error.S: New file.
@
text
@d789 1
a789 1
      (*pst->read_symtab) (objfile, pst);
@


1.60
log
@gdb/
2013-01-11  Yao Qi  <yao@@codesourcery.com>
	    Stan Shebs  <stan@@codesourcery.com>

	* psymtab.c (init_psymbol_list): Clarify the comment.
@
text
@d1801 38
@


1.59
log
@gdb/
	Code cleanup.
	* psymtab.c (psymtab_to_fullname, psymtab_to_fullname): Make the return
	type const char *.
	* tui/tui-source.c (tui_source_is_displayed): Make the parameter fname
	const char *.
	* tui/tui-source.h (tui_source_is_displayed): Likewise.
@
text
@d1705 1
a1705 1
     oriented symbols.  */
@


1.58
log
@	* symfile.h (quick_symbol_functions): Delete member
	pre_expand_symtabs_matching.  All uses removed.
	* dwarf2read.c (dw2_lookup_symbol): Implement.
	(dw2_do_expand_symtabs_matching): Delete.
	(dw2_pre_expand_symtabs_matching): Delete.
	(struct dw2_symtab_iterator): New type.
	(dw2_symtab_iter_init, dw2_symtab_iter_next): New functions.
	(dw2_expand_symtabs_for_function): Rewrite.
	(dwarf2_gdb_index_functions): Update.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): Delete.
	(psym_functions): Update.
@
text
@d61 1
a61 1
static char *psymtab_to_fullname (struct partial_symtab *ps);
d1177 1
a1177 1
static char *
@


1.57
log
@gdb/
	* psymtab.c (fixup_psymbol_section): Update declaration.
	(fixup_psymbol_section): Remove code returning value.
@
text
@a630 9
static void
pre_expand_symtabs_matching_psymtabs (struct objfile *objfile,
				      enum block_enum block_kind,
				      const char *name,
				      domain_enum domain)
{
  /* Nothing.  */
}

a1421 1
  pre_expand_symtabs_matching_psymtabs,
@


1.56
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d68 2
a69 3
static struct partial_symbol *fixup_psymbol_section (struct partial_symbol
						     *psym,
						     struct objfile *objfile);
d482 1
a482 1
static struct partial_symbol *
d487 2
a488 5
  if (!psym)
    return NULL;

  if (SYMBOL_OBJ_SECTION (psym))
    return psym;
d502 1
a502 1
      return psym;
a505 2

  return psym;
@


1.55
log
@gdb/
2012-12-20  Yao Qi  <yao@@codesourcery.com>

	* maint.c (_initialize_maint_cmds): Move code to ...
	* psymtab.c (_initialize_psymtab): ... here.  New.
	Include "gdbcmd.h".
	(maintenance_print_psymbols): Make it static.
	(maintenance_info_psymtabs, maintenance_check_symtabs): Likewise.
	* symtab.h (maintenance_print_psymbols): Remove declaration.
	(maintenance_check_symtabs, maintenance_info_psymtabs): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.54
log
@gdb/
	Code cleanup.
	* breakpoint.c (clear_command): Remove variable sal_name_len and its
	initialization, remove it from the compare_filenames_for_search call.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Remove variable
	name_len and its initialization, remove it from the
	compare_filenames_for_search calls.
	* psymtab.c (partial_map_symtabs_matching_filename): Likewise.
	* symtab.c (compare_filenames_for_search): Remove the search_len
	parameter, update the function comment, new variable search_len
	initialized from SEARCH_NAME.
	(iterate_over_some_symtabs): Remove variable name_len and its
	initialization, remove it from the compare_filenames_for_search calls.
	* symtab.h (compare_filenames_for_search): Remove the search_len
	parameter,
@
text
@d38 1
d1819 1
a1819 1
void
d1868 1
a1868 1
void
d1974 1
a1974 1
void
d2087 22
@


1.53
log
@	* dbxread.c (read_dbx_symtab): Update.
	(end_psymtab, dbx_psymtab_to_symtab_1, dbx_psymtab_to_symtab)
	(read_ofile_symtab): Add 'objfile' argument.
	* dwarf2read.c (process_psymtab_comp_unit_reader)
	(build_type_psymtabs_reader): Update.
	(dwarf2_psymtab_to_symtab): Add 'objfile' argument.
	* mdebugread.c (mdebug_psymtab_to_symtab): Add 'objfile'
	argument.
	(parse_procedure, parse_partial_symbols): Update.
	(psymtab_to_symtab_1): Add 'objfile' argument.
	* psympriv.h (struct partial_symtab) <objfile>: Remove.
	<read_symtab>: Add 'objfile' argument.
	(sort_pst_symbols, discard_psymtab): Update.
	* psymtab.c (partial_map_expand_apply): Update.
	(find_pc_sect_psymtab_closer): Add 'objfile' argument.
	(find_pc_sect_psymtab, find_pc_sect_symtab_from_partial): Update.
	(find_pc_sect_psymbol): Add 'objfile' argument.
	(lookup_symbol_aux_psymtabs): Update.
	(match_partial_symbol, lookup_partial_symbol, psymtab_to_symtab):
	Add 'objfile' argument.
	(find_last_source_symtab_from_partial, dump_psymtab)
	(dump_psymtabs_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial): Update.
	(sort_pst_symbols): Add 'objfile' argument.
	(allocate_psymtab): Update.
	(discard_psymtab): Add 'objfile' argument.
	(maintenance_info_psymtabs, maintenance_check_symtabs): Update.
	* stabsread.h (end_psymtab): Update.
	* xcoffread.c (this_symtab_objfile): New global.
	(process_linenos, enter_line_range, xcoff_next_symbol_text):
	Update.
	(read_xcoff_symtab): Add 'objfile' argument.
	(read_symbol, read_symbol_lineno): Update.
	(xcoff_psymtab_to_symtab_1, xcoff_psymtab_to_symtab)
	(xcoff_end_psymtab): Add 'objfile' argument.
	(scan_xcoff_symtab): Update.
@
text
@a170 1
  int name_len = strlen (name);
d185 1
a185 2
	|| (!is_abs && compare_filenames_for_search (pst->filename,
						     name, name_len)))
d206 1
a206 1
							     name, name_len))))
d225 1
a225 2
		|| (!is_abs && compare_filenames_for_search (real_path,
							     name, name_len))))
@


1.52
log
@	* symmisc.c (print_symbol_bcache_statistics): Use QUIT, not
	immediate_quit.
	(print_objfile_statistics): Likewise.
	(maintenance_print_symbols): Likewise.
	(maintenance_print_msymbols): Likewise.
	(maintenance_print_objfiles): Likewise.
	* psymtab.c (print_partial_symbols): Call QUIT.
	(maintenance_print_psymbols): Likewise.  Don't modify
	immediate_quit.
	* copying.c (show_copying_command): Don't modify immediate_quit.
	(show_warranty_command): Likewise.
	* cli/cli-cmds.c (show_version): Don't modify immediate_quit.
@
text
@d48 2
a49 1
static struct partial_symbol *match_partial_symbol (struct partial_symtab *,
d55 2
a56 1
static struct partial_symbol *lookup_partial_symbol (struct partial_symtab *,
d62 2
a63 1
static struct partial_symbol *find_pc_sect_psymbol (struct partial_symtab *,
d71 2
a72 1
static struct symtab *psymtab_to_symtab (struct partial_symtab *pst);
d152 1
a152 1
  psymtab_to_symtab (pst);
d244 2
a245 1
find_pc_sect_psymtab_closer (CORE_ADDR pc, struct obj_section *section,
a248 1
  struct objfile *objfile = pst->objfile;
d284 1
a284 1
	  p = find_pc_sect_psymbol (tpst, pc, section);
d349 1
a349 1
	      p = find_pc_sect_psymbol (pst, pc, section);
d383 2
a384 1
	best_pst = find_pc_sect_psymtab_closer (pc, section, pst, msymbol);
d408 2
a409 2
		 paddress (get_objfile_arch (ps->objfile), pc));
      psymtab_to_symtab (ps);
d419 2
a420 1
find_pc_sect_psymbol (struct partial_symtab *psymtab, CORE_ADDR pc,
d434 2
a435 2
  for (pp = psymtab->objfile->global_psymbols.list + psymtab->globals_offset;
    (pp - (psymtab->objfile->global_psymbols.list + psymtab->globals_offset)
d449 1
a449 1
	      fixup_psymbol_section (p, psymtab->objfile);
d458 2
a459 2
  for (pp = psymtab->objfile->static_psymbols.list + psymtab->statics_offset;
    (pp - (psymtab->objfile->static_psymbols.list + psymtab->statics_offset)
d473 1
a473 1
	      fixup_psymbol_section (p, psymtab->objfile);
d527 2
a528 1
    if (!ps->readin && lookup_partial_symbol (ps, name, psymtab_index, domain))
d531 1
a531 1
	struct symtab *stab = psymtab_to_symtab (ps);
d568 2
a569 1
match_partial_symbol (struct partial_symtab *pst, int global,
d582 2
a583 2
	   pst->objfile->global_psymbols.list + pst->globals_offset :
	   pst->objfile->static_psymbols.list + pst->statics_offset);
d685 2
a686 1
lookup_partial_symbol (struct partial_symtab *pst, const char *name,
d704 2
a705 2
	   pst->objfile->global_psymbols.list + pst->globals_offset :
	   pst->objfile->static_psymbols.list + pst->statics_offset);
d790 1
a790 1
psymtab_to_symtab (struct partial_symtab *pst)
d806 1
a806 1
      (*pst->read_symtab) (pst);
d872 1
a872 1
	return psymtab_to_symtab (cs_pst);
d1019 1
a1019 1
  for (i = 0; i < psymtab->objfile->num_sections; ++i)
a1099 4
	  if (psymtab->objfile != objfile)
	    {
	      printf_filtered ("NOT ON CHAIN!  ");
	    }
d1119 1
a1119 1
    if ((lookup_partial_symbol (ps, func_name, 1, VAR_DOMAIN)
d1121 1
a1121 1
	|| (lookup_partial_symbol (ps, func_name, 0, VAR_DOMAIN)
d1123 1
a1123 1
      psymtab_to_symtab (ps);
d1134 1
a1134 1
      psymtab_to_symtab (psymtab);
d1150 1
a1150 1
	psymtab_to_symtab (p);
d1228 1
a1228 1
      if (lookup_partial_symbol (pst, name, 1, VAR_DOMAIN))
d1281 1
a1281 1
	  || match_partial_symbol (ps, global, name, namespace, match,
d1284 1
a1284 1
	  struct symtab *s = psymtab_to_symtab (ps);
d1422 1
a1422 1
	psymtab_to_symtab (ps);
d1469 1
a1469 1
sort_pst_symbols (struct partial_symtab *pst)
d1473 1
a1473 1
  qsort (pst->objfile->global_psymbols.list + pst->globals_offset,
a1767 1
  psymtab->objfile = objfile;
d1795 1
a1795 1
discard_psymtab (struct partial_symtab *pst)
d1808 1
a1808 1
  prev_pst = &(pst->objfile->psymtabs);
d1815 2
a1816 2
  pst->next = pst->objfile->free_psymtabs;
  pst->objfile->free_psymtabs = pst;
d1929 1
a1929 1
				   host_address_to_string (psymtab->objfile->global_psymbols.list
d1939 1
a1939 1
				   host_address_to_string (psymtab->objfile->static_psymbols.list
d1992 1
a1992 1
    s = psymtab_to_symtab (ps);
d1997 1
a1997 1
    psym = ps->objfile->static_psymbols.list + ps->statics_offset;
d2014 1
a2014 1
    psym = ps->objfile->global_psymbols.list + ps->globals_offset;
@


1.51
log
@	* psymtab.c (map_symbol_filenames_psymtab): Skip shared psymtabs.
@
text
@d891 1
a1855 1
  immediate_quit++;
d1857 5
a1861 3
    if (symname == NULL || filename_cmp (symname, ps->filename) == 0)
    dump_psymtab (objfile, ps, outfile);
  immediate_quit--;
@


1.50
log
@	* psympriv.h (struct partial_symtab): New member "anonymous".
	* psymtab.c (partial_map_symtabs_matching_filename): Ignore
	anonymous psymtabs.
	(read_psymtabs_with_filename): Ditto.
	(map_symbol_filenames_psymtab, psymtab_to_fullname): Ditto.
	(expand_symtabs_matching_via_partial): Ditto.
	(dump_psymtab): Update.
@
text
@d1162 5
@


1.49
log
@	* psymtab.c (allocate_psymtab): Use host_address_to_string.
@
text
@d177 4
d980 10
a989 2
  fprintf_filtered (outfile, "\nPartial symtab for source file %s ",
		    psymtab->filename);
d1139 4
d1162 4
d1190 2
d1402 7
a1408 2
      if (file_matcher && ! (*file_matcher) (ps->filename, data))
	continue;
@


1.48
log
@	* NEWS: Mention new options "set debug dwarf2-read" and
	"set debug symtab-create".
	* dwarf2read.c (dwarf2_read_debug): New static global.
	(dwarf2_build_psymtabs_hard): Add debugging printfs.
	(process_queue): Ditto.
	(process_full_comp_unit): Ditto.
	(_initialize_dwarf2_read): Add new option "set debug dwarf2-read".
	* elfread.c (elf_symfile_read): Add debugging printf.
	* minsyms.c (install_minimal_symbols): Ditto.
	* psymtab.c (allocate_psymtab): Ditto.
	* symfile.c (allocate_symtab): Ditto.
	* symtab.c (symtab_create_debug): New global.
	(_initialize_symtab): Add new option "set debug symtab-create".
	* symtab.h (symtab_create_debug): Declare.

	doc/
	* gdb.texinfo (Debugging Output): Document debug options dwarf2-read
	and symtab-create.
@
text
@d1750 2
a1751 2
			  "Created psymtab 0x%lx for module %s.\n",
			  (long) psymtab, filename);
@


1.47
log
@gdb/
	* psymtab.c (lookup_symbol_aux_psymtabs): New variable stab_best.  Use
	it as a fallback for TYPE_IS_OPAQUE.
	* symfile.h (struct quick_symbol_functions): Mention TYPE_OPAQUE
	symbols for lookup_symbol.

gdb/testsuite/
	* gdb.dwarf2/dw2-icc-opaque.S: Add debug_info_seg3 and
	.debug_abbrev_seg3.
@
text
@d1734 20
@


1.46
log
@	* psymtab.c (find_pc_sect_symtab_from_partial): Return the symtab
	directly corresponding to the found psymtab.
	* dwarf2read.c (recursively_find_pc_sect_symtab): New function.
	(dw2_find_pc_sect_symtab): Use it.
	* block.h (blockvector_contains_pc): Declare.
	* block.c (find_block_in_blockvector): New function.
	(blockvector_for_pc_sect): Use it.
	(blockvector_contains_pc): New function.
@
text
@d513 1
d534 6
a539 1
	  return stab;
d545 1
a545 1
  return NULL;
@


1.45
log
@	* psymtab.c (partial_map_expand_apply): Add assertion.
	(partial_map_symtabs_matching_filename): Skip included psymtabs.
	(psymtab_to_symtab): Find unshared psymtab.
	(dump_psymtab): Print including psymtabs.
	(recursively_search_psymtabs): New function.
	(expand_symtabs_matching_via_partial): Use it.
	* psympriv.h (struct partial_symtab) <user, searched_flag>: New
	fields.
	(enum psymtab_search_status): New.
@
text
@d400 2
a401 1
      return psymtab_to_symtab (ps);
@


1.44
log
@	* tracepoint.c (scope_info): Update.
	* symtab.c (lookup_block_symbol, iterate_over_symbols)
	(find_pc_sect_symtab, search_symbols)
	(default_make_symbol_completion_list_break_on)
	(make_file_symbol_completion_list): Update.
	* symmisc.c (dump_symtab_1): Update.
	* stack.c (print_frame_args, iterate_over_block_locals)
	(print_frame_labels, iterate_over_block_arg_vars): Update.
	* python/py-block.c (block_object) <dict>: Remove.
	<block>: New field.
	<iter>: Change type.
	(blpy_iter): Update.
	(blpy_block_syms_iternext): Update.
	* psymtab.c (map_block): Use block iterators.
	* objfiles.c (objfile_relocate1): Use ALL_DICT_SYMBOLS.
	* mi/mi-cmd-stack.c (list_args_or_locals): Update.
	* mdebugread.c (parse_symbol, mylookup_symbol): Update.
	* infrun.c (check_exception_resume): Update.
	* cp-support.c (make_symbol_overload_list_block): Update.
	* coffread.c (patch_opaque_types): Update.
	* buildsym.c (finish_block, end_symtab): Use ALL_DICT_SYMBOLS.
	* block.h (struct block_iterator): New.
	(block_iterator_first, block_iterator_next, block_iter_name_first)
	(block_iter_name_next, block_iter_match_first)
	(block_iter_match_next): Declare.
	(ALL_BLOCK_SYMBOLS): Redefine.
	* block.c (block_iterator_first, block_iterator_next)
	(block_iter_name_first, block_iter_name_next)
	(block_iter_match_first, block_iter_match_next): New functions.
	* ada-lang.c (ada_add_block_symbols)
	(ada_make_symbol_completion_list): Use block iterator.
@
text
@d138 4
d172 5
d772 5
d1017 6
d1259 88
d1357 1
d1360 2
a1361 3
      struct partial_symbol **psym;
      struct partial_symbol **bound, **gbound, **sbound;
      int keep_going = 1;
d1363 2
d1368 5
d1376 2
a1377 42
      gbound = objfile->global_psymbols.list
	+ ps->globals_offset + ps->n_global_syms;
      sbound = objfile->static_psymbols.list
	+ ps->statics_offset + ps->n_static_syms;
      bound = gbound;

      /* Go through all of the symbols stored in a partial
	 symtab in one loop.  */
      psym = objfile->global_psymbols.list + ps->globals_offset;
      while (keep_going)
	{
	  if (psym >= bound)
	    {
	      if (bound == gbound && ps->n_static_syms != 0)
		{
		  psym = objfile->static_psymbols.list + ps->statics_offset;
		  bound = sbound;
		}
	      else
		keep_going = 0;
	      continue;
	    }
	  else
	    {
	      QUIT;

	      if ((kind == ALL_DOMAIN
		   || (kind == VARIABLES_DOMAIN
		       && SYMBOL_CLASS (*psym) != LOC_TYPEDEF
		       && SYMBOL_CLASS (*psym) != LOC_BLOCK)
		   || (kind == FUNCTIONS_DOMAIN
		       && SYMBOL_CLASS (*psym) == LOC_BLOCK)
		   || (kind == TYPES_DOMAIN
		       && SYMBOL_CLASS (*psym) == LOC_TYPEDEF))
		  && (*name_matcher) (SYMBOL_SEARCH_NAME (*psym), data))
		{
		  psymtab_to_symtab (ps);
		  keep_going = 0;
		}
	    }
	  psym++;
	}
@


1.43
log
@	* psymtab.c (PSYMTAB_TO_SYMTAB): Remove.
	(find_pc_sect_symtab_from_partial, lookup_symbol_aux_psymtabs)
	(lookup_partial_symbol, find_last_source_symtab_from_partial)
	(read_psymtabs_with_filename, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_check_symtabs):
	Update.
@
text
@d1185 1
a1185 1
  struct dict_iterator iter;
d1188 2
a1189 2
  for (sym = dict_iter_match_first (BLOCK_DICT (block), name, match, &iter);
       sym != NULL; sym = dict_iter_match_next (name, match, &iter))
@


1.42
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* psymtab.c (find_and_open_source): Delete declaration.
	* source.c (find_and_open_source): Move comment ...
	* source.h (find_and_open_source): ... to this new declaration.
@
text
@a47 4
/* A fast way to get from a psymtab to its symtab (after the first time).  */
#define PSYMTAB_TO_SYMTAB(pst)  \
    ((pst) -> symtab != NULL ? (pst) -> symtab : psymtab_to_symtab (pst))

d391 1
a391 1
      return PSYMTAB_TO_SYMTAB (ps);
d509 1
a509 1
	struct symtab *stab = PSYMTAB_TO_SYMTAB (ps);
d758 1
a758 3
   This is fast after the first time you do it.  In fact, there
   is an even faster macro PSYMTAB_TO_SYMTAB that does the fast
   case inline.  */
d838 1
a838 1
	return PSYMTAB_TO_SYMTAB (cs_pst);
d1101 1
a1101 1
	PSYMTAB_TO_SYMTAB (p);
d1224 1
a1224 1
	  struct symtab *s = PSYMTAB_TO_SYMTAB (ps);
d1297 1
a1297 1
		  PSYMTAB_TO_SYMTAB (ps);
d1852 1
a1852 1
    s = PSYMTAB_TO_SYMTAB (ps);
@


1.41
log
@	* psymtab.c (add_psymbol_to_list): Result is now "void".
	* psympriv.h (add_psymbol_to_list): Update.
@
text
@a1133 4
int find_and_open_source (const char *filename,
			  const char *dirname,
			  char **fullname);

@


1.40
log
@Remove language param from name_matcher in struct quick_symbol_functions

The quick_symbol_functions struct contains a field which is pointer
a function which takes another function, called name_matcher, as
its parameter.  This name_matcher currently has 3 arguments, one
of them being the language. This parameter is no longer used, and
thus deleted.

gdb/ChangeLog:

        * symfile.h (struct quick_symbol_functions) [expand_symtabs_matching]:
        Remove language parameter from name_matcher.  Adjust the comment.
        * symtab.c (search_symbols_name_matches, expand_partial_symbol_name):
        Remove language parameter.
        * ada-lang.c (ada_expand_partial_symbol_name): Likewise.
        * linespec.c (iterate_name_matcher): Likewise.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust type of
        name_matcher.  Adjust call accordingly.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (maintenance_check_symtabs): Adjust type of parameter "fun".
        * psymtab.h (maintenance_check_symtabs): Likewise.
@
text
@d1569 1
a1569 12
/* NOTE: carlton/2003-09-11: The reason why we return the partial
   symbol is so that callers can get access to the symbol's demangled
   name, which they don't have any cheap way to determine otherwise.
   (Currenly, dwarf2read.c is the only file who uses that information,
   though it's possible that other readers might in the future.)
   Elena wasn't thrilled about that, and I don't blame her, but we
   couldn't come up with a better way to get that information.  If
   it's needed in other situations, we could consider breaking up
   SYMBOL_SET_NAMES to provide access to the demangled name lookup
   cache.  */

const struct partial_symbol *
d1589 1
a1589 1
    return psym;
a1592 1
  return psym;
@


1.39
log
@gdb
	* NEWS: Add item.
	* symtab.h (compare_filenames_for_search): Declare.
	* symtab.c (compare_filenames_for_search): New function.
	(iterate_over_some_symtabs): Use it.
	* symfile.h (struct quick_symbol_functions)
	<map_symtabs_matching_filename>: Change spec.
	* psymtab.c (partial_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* dwarf2read.c (dw2_map_symtabs_matching_filename): Use
	compare_filenames_for_search.  Update for new spec.
	* breakpoint.c (clear_command): Use compare_filenames_for_search.
gdb/doc
	* gdb.texinfo (Specify Location): Document relative file name
	handling.
gdb/testsuite
	* gdb.linespec/linespec.exp: Change some tests to use $decimal.
	Add tests for relative directory.
@
text
@d1253 1
a1253 1
   int (*name_matcher) (const struct language_defn *, const char *, void *),
d1305 1
a1305 2
		  && (*name_matcher) (current_language,
				      SYMBOL_SEARCH_NAME (*psym), data))
d1945 1
a1945 2
expand_partial_symbol_names (int (*fun) (const struct language_defn *,
					 const char *, void *),
@


1.38
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d167 2
d172 3
a174 1
    if (FILENAME_CMP (name, pst->filename) == 0)
d193 3
a195 1
	    && FILENAME_CMP (full_path, pst->fullname) == 0)
d212 4
a215 1
	if (rp != NULL && FILENAME_CMP (real_path, rp) == 0)
a223 11
  /* Now, search for a matching tail (only if name doesn't have any dirs).  */

  if (name_basename == name)
    ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, pst)
    {
      if (FILENAME_CMP (lbasename (pst->filename), name) == 0)
	if (partial_map_expand_apply (objfile, name, full_path, real_path, pst,
				      callback, data))
	  return 1;
    }

@


1.37
log
@Use symbol search name in expand_symtabs_matching_via_partial...

We are iterating over all symbols in a partial symtab that would
match a given name, so we should match the partial symbols
search name against the given name rather than using the natural
name.  In C++, that does not make a difference, but it does in
Ada, because Ada searches using the symbol encoded name...

We also update the generation of the .gdb_index file to match this
change in the search. Although technically an incompatible change,
we do not increment the gdb_index version number, because Ada is
the only language where it would make a difference - except that
this feature is not supported for Ada.

gdb/ChangeLog:

        * psymtab.c (expand_symtabs_matching_via_partial): Match
        the partial symbols using their SYMBOL_SEARCH_NAME.
        * symfile.h (struct quick_symbol_functions): Udate the
        documentation of expand_symtabs_matching.
        * dwarf2read.c (write_psymbols): Use SYMBOL_SEARCH_NAME instead
        of SYMBOL_NATURAL_NAME in index entry.
@
text
@d3 1
a3 1
   Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.
@


1.36
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d1308 1
a1308 1
				      SYMBOL_NATURAL_NAME (*psym), data))
@


1.36.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
   Copyright (C) 2009-2012 Free Software Foundation, Inc.
@


1.35
log
@gdb/
	PR breakpoints/13346
	* dwarf2read.c (process_psymtab_comp_unit): Set
	PSYMTABS_ADDRMAP_SUPPORTED.
	* psympriv.h (struct partial_symtab): Comment textlow and texthigh
	validity.  New field psymtabs_addrmap_supported.
	* psymtab.c (find_pc_sect_psymtab_closer): New gdb_assert on
	psymtabs_addrmap_supported.
	(find_pc_sect_psymtab): Do not fallback to TEXTLOW and TEXTHIGH for
	!PSYMTABS_ADDRMAP_SUPPORTED.
	(dump_psymtab, maintenance_info_psymtabs): Print also
	psymtabs_addrmap_supported.

gdb/testsuite/
	PR breakpoints/13346
	* gdb.dwarf2/dw2-objfile-overlap-inner.S: New file.
	* gdb.dwarf2/dw2-objfile-overlap-outer.S: New file.
	* gdb.dwarf2/dw2-objfile-overlap.exp: New file.
@
text
@d128 2
a129 3
/* Lookup the partial symbol table of a source file named NAME.
   *If* there is no '/' in the name, a match after a '/'
   in the psymtab filename will also work.  */
d131 33
a163 3
static struct partial_symtab *
lookup_partial_symtab (struct objfile *objfile, const char *name,
		       const char *full_path, const char *real_path)
d172 3
a174 1
	return (pst);
d191 3
a193 1
	    return pst;
d208 3
a210 1
	    return pst;
d221 3
a223 1
	return (pst);
d226 1
a226 20
  return (NULL);
}

static int
lookup_symtab_via_partial_symtab (struct objfile *objfile, const char *name,
				  const char *full_path, const char *real_path,
				  struct symtab **result)
{
  struct partial_symtab *ps;

  ps = lookup_partial_symtab (objfile, name, full_path, real_path);
  if (!ps)
    return 0;

  if (ps->readin)
    error (_("Internal: readin %s pst for `%s' found when no symtab found."),
	   ps->filename, name);

  *result = PSYMTAB_TO_SYMTAB (ps);
  return 1;
d1252 6
a1257 7
expand_symtabs_matching_via_partial (struct objfile *objfile,
				     int (*file_matcher) (const char *,
							  void *),
				     int (*name_matcher) (const char *,
							  void *),
				     enum search_domain kind,
				     void *data)
d1307 2
a1308 1
		  && (*name_matcher) (SYMBOL_NATURAL_NAME (*psym), data))
d1330 1
a1330 1
  lookup_symtab_via_partial_symtab,
d1948 3
a1950 1
expand_partial_symbol_names (int (*fun) (const char *, void *), void *data)
@


1.34
log
@	* NEWS: Mention new parameter basenames-may-differ.
	* dwarf2read.c (dw2_lookup_symtab): Avoid calling gdb_realpath if
	! basenames_may_differ.
	* psymtab.c (lookup_partial_symtab): Ditto.
	* symtab.c (lookup_symtab): Ditto.
	(basenames_may_differ): New global.
	(_initialize_symtab): New parameter basenames-may-differ.
	* symtab.h (basenames_may_differ): Declare.

	doc/
	* gdb.texinfo (Files): Document basenames-may-differ.
@
text
@d224 2
d349 2
a350 1
    if (pc >= pst->textlow && pc < pst->texthigh)
d982 2
d1789 3
@


1.33
log
@	* dwarf2read.c (dw2_map_symbol_filenames): New parameter
	`need_fullname'.
	* psymtab.c (map_symbol_filenames_psymtab): Ditto.
	(map_partial_symbol_filenames): Ditto.  All callers updated.
	* psymtab.h (map_partial_symbol_filenames): Update prototype.
	* symfile.h (struct quick_symbol_functions, map_symbol_filenames): New
	parameter need_fullname.
@
text
@d137 1
d146 6
d182 1
a182 1
  if (lbasename (name) == name)
@


1.32
log
@	* psymtab.c (psymtab_to_fullname): Use cached copy if it exists.
	* source.c (symtab_to_fullname): Ditto.
@
text
@d1085 2
a1086 1
			      symbol_filename_ftype *fun, void *data)
d1098 4
a1101 1
      fullname = psymtab_to_fullname (ps);
d1928 2
a1929 1
map_partial_symbol_filenames (symbol_filename_ftype *fun, void *data)
d1936 2
a1937 1
      objfile->sf->qf->map_symbol_filenames (objfile, fun, data);
@


1.31
log
@11-10-28  Sterling Augustine  <saugustine@@google.com>

	* psymtab.c (map_symbol_filenames_psymtab): Call QUIT.
	* symtab.c (free_completion_list): New function.
	(do_free_completion_list): Likewise.
	(default_make_symbol_completion_list_break_on): New variable
	back_to. Call make_cleanup and discard_cleanups.
	(make_source_files_completion_list): Likewise.
@
text
@d1113 1
d1122 6
a1127 2
  /* Don't check ps->fullname here, the file could have been
     deleted/moved/..., look for it again.  */
@


1.30
log
@gdb/
	Code cleanup.
	* dwarf2read.c (dw2_map_symbol_filenames): Use symbol_filename_ftype
	for fun.
	* psymtab.c (map_symbol_filenames_psymtab)
	(map_partial_symbol_filenames): Likewise.
	* psymtab.h: Include symfile.h.
	(map_partial_symbol_filenames): Use symbol_filename_ftype for fun.
	* symfile.h (symbol_filename_ftype): New.
	(struct quick_symbol_functions): Use symbol_filename_ftype for fun of
	map_symbol_filenames, clarify more the naming in comment.
@
text
@d1096 1
@


1.29
log
@gdb/doc/
	* gdb.texinfo (Index Section Format): Change the version to 5.
	Describe the different formula.

gdb/
	Case insensitive lookups implementation.
	* dwarf2read.c: Include ctype.h.
	(struct mapped_index): New field version.
	(mapped_index_string_hash): New parameter index_version.  New comment
	for it.  Call tolower appropriately.
	(find_slot_in_mapped_hash): New variable cmp, initialize it, use it.
	Choose the right index version for mapped_index_string_hash.
	(dwarf2_read_index): Support also the index version 5.  Initialize the
	new struct mapped_index field version.
	(hash_strtab_entry): Pass INT_MAX for the new parameter, explain why.
	(find_slot): Explain the version needs.  Pass INT_MAX for the new
	parameter.
	(write_psymtabs_to_index): Produce version 5.
	* minsyms.c (lookup_minimal_symbol): New variable cmp, initialize it,
	use it.  New comment for SYMBOL_MATCHES_SEARCH_NAME.
	* psymtab.c (lookup_partial_symbol): Find the
	SYMBOL_MATCHES_SEARCH_NAME start of the found block of matching
	entries.
	* symtab.c (lookup_symbol_in_language): Remove the case_sensitive_off
	NAME lowercasing.
	(search_symbols): Pass REG_ICASE to regcomp for case_sensitive_off.
	(completion_list_add_name): New variable ncmp, initialize it, use it.
	* symtab.h (SYMBOL_HASH_NEXT): Always call tolower.
	* utils.c (strcmp_iw): Support case_sensitive_off.
	(strcmp_iw_ordered): Sort in a way compatible with case_sensitive_off.
	New function comment part.  New variables saved_string1,
	saved_string2 and case_pass.  Add a proper second pass.

gdb/testsuite/
	* gdb.base/fortran-sym-case.c: New file.
	* gdb.base/fortran-sym-case.exp: New file.
	* gdb.dwarf2/dw2-case-insensitive-debug.S: New file.
	* gdb.dwarf2/dw2-case-insensitive.c: New file.
	* gdb.dwarf2/dw2-case-insensitive.exp: New file.
@
text
@d1085 1
a1085 3
			      void (*fun) (const char *, const char *,
					   void *),
			      void *data)
d1918 1
a1918 3
map_partial_symbol_filenames (void (*fun) (const char *, const char *,
					   void *),
			      void *data)
@


1.28
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@d694 9
a702 2
      while (top <= real_top
	     && SYMBOL_MATCHES_SEARCH_NAME (*top, search_name))
@


1.27
log
@	* symtab.h (domain_enum): Split in two...
	(enum search_domain): New.
	(search_symbols): Update.
	* symtab.c (print_symbol_info, symtab_symbol_info): Remove
	redundant declarations.
	(search_symbols): Change 'kind' argument to search_domain.
	Update.
	(print_symbol_info): Likewise.
	(symtab_symbol_info): Likewise.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: Change type of 'kind' argument.
	<expand_symtabs_matching>: Likewise.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): Update.
	(expand_symtabs_matching_via_partial): Update.
	* dwarf2read.c (dw2_pre_expand_symtabs_matching): Update.
	(dw2_expand_symtabs_for_function): Update.
	* block.h: Moved anonymous enum...
	* defs.h (enum block_enum): ... here.  Now named.
@
text
@a1076 36
map_symbol_names_psymtab (struct objfile *objfile,
			  void (*fun) (const char *, void *), void *data)
{
  struct partial_symtab *ps;

  ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)
    {
      struct partial_symbol **psym;

      /* If the psymtab's been read in we'll get it when we search
	 through the blockvector.  */
      if (ps->readin)
	continue;

      for (psym = objfile->global_psymbols.list + ps->globals_offset;
	   psym < (objfile->global_psymbols.list + ps->globals_offset
		   + ps->n_global_syms);
	   psym++)
	{
	  /* If interrupted, then quit.  */
	  QUIT;
	  (*fun) (SYMBOL_NATURAL_NAME (*psym), data);
	}

      for (psym = objfile->static_psymbols.list + ps->statics_offset;
	   psym < (objfile->static_psymbols.list + ps->statics_offset
		   + ps->n_static_syms);
	   psym++)
	{
	  QUIT;
	  (*fun) (SYMBOL_NATURAL_NAME (*psym), data);
	}
    }
}

static void
d1226 1
a1226 1
      if (! (*file_matcher) (ps->filename, data))
d1255 2
a1256 2
	      if ((*name_matcher) (SYMBOL_NATURAL_NAME (*psym), data)
		  && ((kind == VARIABLES_DOMAIN
d1259 5
a1263 4
		      || (kind == FUNCTIONS_DOMAIN
			  && SYMBOL_CLASS (*psym) == LOC_BLOCK)
		      || (kind == TYPES_DOMAIN
			  && SYMBOL_CLASS (*psym) == LOC_TYPEDEF)))
a1297 1
  map_symbol_names_psymtab,
d1900 1
a1900 1
map_partial_symbol_names (void (*fun) (const char *, void *), void *data)
d1907 2
a1908 1
      objfile->sf->qf->map_symbol_names (objfile, fun, data);
@


1.26
log
@2011-03-23  Kai Tietz  <ktietz@@redhat.com>

	* breakpoint.c (clear_command): Use filename_cmp
	instead of strcmp for comparison.
	* buildsym.c (watch_main_source_file_lossage): Likewise.
	(patch_subfile_names): Use IS_DIR_SEPARATOR instead of
	checking just for slash.
	* dbxread.c (read_dbx_symtab): Use lbasename instead of
	strrchr and filename_cmp instead of strcmp for filenames.
	(add_old_header_file): Use filename_cmp
	instead of strcmp for comparison.
	* exec.c (exec_set_section_address): Likewise.
	* macrotab.c (macro_lookup_inclusion): Likewise.
	(macro_lookup_inclusion): Likewise.
	* elfread.c (_initialize_elfread): Likewise.
	(elfstab_offset_sections): Likewise.
	(elfstab_offset_sections): Use lbasename instead of
	strrchr.
	* mdebugread.c (parse_partial_symbols): Likewise.
	(arse_partial_symbols): Use filename_(n)cmp instead of
	str(n)cmp for comparison.
	* minsyms.c (lookup_minimal_symbol): Likewise.
	* psymtab.c (read_psymtabs_with_filename): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	(reload_shared_libraries_1): Likewise.
	* symmisc.c (maintenance_print_symbols): Likewise.
	* symfile.c (separate_debug_file_exists): Likewise.
	(reread_symbols): Likewise.
	(find_separate_debug_file_by_debuglink): Likewise.
	* remote-fileio.c (remote_fileio_func_rename): Likewise.
	* source.c (add_path): Likewise.
	* symtab.c (filename_seen): Likewise.
	(file_matches): Likewise.
	(print_symbol_info): Likewise.
	(maybe_add_partial_symtab_filename): Likewise.
	(make_source_files_completion_list): Likewise.
	* xml-syscall.c (init_sysinfo): Likewise.
	* windows-nat.c (_initialize_check_for_gdb_ini): Use
	IS_DIR_SEPARATOR for checking for trailing path separator.
@
text
@d591 2
a592 1
				      int kind, const char *name,
d1248 1
a1248 1
				     domain_enum kind,
@


1.26.2.1
log
@gdb/
	* ada-lang.c (struct add_partial_datum): Update the comment for
	expand_partial_symbol_name.
	(ada_add_partial_symbol_completions): Rename to ...
	(ada_expand_partial_symbol_name): ... here, change return type, update
	function comment, call symbol_completion_match instead of
	symbol_completion_add.
	(ada_make_symbol_completion_list): Use now expand_partial_symbol_names
	and ada_expand_partial_symbol_name.
	* dwarf2read.c (dw2_expand_symtabs_matching): Support NULL
	FILE_MATCHER.
	(dw2_map_symbol_names): Remove.
	(dwarf2_gdb_index_functions): Unlist dw2_map_symbol_names.
	* psymtab.c (map_symbol_names_psymtab): Remove.
	(expand_symtabs_matching_via_partial): Support NULL FILE_MATCHER.
	Support KIND == ALL_DOMAIN.  Exchange the NAME_MATCHER and KIND check
	order.
	(psym_functions): Unlist map_symbol_names_psymtab.
	(map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type, call
	expand_symtabs_matching with ALL_DOMAIN and NULL FILE_MATCHER now.
	* psymtab.h (map_partial_symbol_names): Rename to ...
	(expand_partial_symbol_names): ... here, change the FUN type.
	* symfile.h (struct quick_symbol_functions): Update the description of
	expand_symtabs_matching.  Remove map_symbol_names.
	* symtab.c (search_symbols): Add ALL_DOMAIN to the function comment.
	(struct add_name_data): Update the comment for
	expand_partial_symbol_name.
	(add_partial_symbol_name): Rename to ...
	(expand_partial_symbol_name): ... here.  Replace
	completion_list_add_name call by strncmp.
	(default_make_symbol_completion_list_break_on): Use now
	expand_partial_symbol_names and expand_partial_symbol_name.
	* symtab.h (enum search_domain): New element ALL_DOMAIN.

gdb/testsuite/
	* gdb.cp/cpcompletion.exp (complete class methods)
	(complete class methods beginning with F): Move them above runto.  New
	comment about the runto delimiter.
@
text
@d1076 36
d1261 1
a1261 1
      if (file_matcher && ! (*file_matcher) (ps->filename, data))
d1290 2
a1291 2
	      if ((kind == ALL_DOMAIN
		   || (kind == VARIABLES_DOMAIN
d1294 4
a1297 5
		   || (kind == FUNCTIONS_DOMAIN
		       && SYMBOL_CLASS (*psym) == LOC_BLOCK)
		   || (kind == TYPES_DOMAIN
		       && SYMBOL_CLASS (*psym) == LOC_TYPEDEF))
		  && (*name_matcher) (SYMBOL_NATURAL_NAME (*psym), data))
d1332 1
d1935 1
a1935 1
expand_partial_symbol_names (int (*fun) (const char *, void *), void *data)
d1942 1
a1942 2
      objfile->sf->qf->expand_symtabs_matching (objfile, NULL, fun,
						ALL_DOMAIN, data);
@


1.25
log
@	* linespec.c (find_methods): Canonicalize NAME before looking
	up the symbol.
	(name_end): New function.
	(keep_name_info): New function.
	(decode_line_1): Use keep_name_info.
	(decode_compound): Likewise.
	* cli/cli-utils.h (remove_trailing_whitespace): New function.
	* cli/cli-utils.c (remove_trailing_whitespace): Likewise.

	PR c++/12273
	* linespec.c (locate_first_half): Keep overload information, too.
	(decode_compound): Use a string to represent break characters
	to escape the loop.
	If P points to a break character, do not increment it.
	For C++ and Java, keep overload information and relevant keywords.
	If we cannot find a symbol, search the minimal symbols.

	PR c++/11734
	* linespec.c (decode_compound): Rename SAVED_ARG to
	THE_REAL_SAVED_ARG.
	Make a copy of THE_REAL_SAVED_ARG in SAVED_ARG and strip
	single-quotes.
	Pass a valid block to lookup_symbol.
	(lookup_prefix_sym): Likewise.
	(find_method): Construct search name based on SYM_CLASS instead
	of SAVED_ARG.
	* psymtab.c (lookup_partial_symbol): Add language parameter.
	(lookup_symbol_aux_psymtabs): Likewise.
	Don't assume that the psymtab we found was the right one. Search
	for the desired symbol in the symtab to be certain.
	(psymtab_search_name): New function.
	(lookup_partial_symbol): Use psymtab_search_name.
	Add language parameter.
	(read_symtabs_for_function): Add language parameter and pass to
	lookup_partial_symbol.
	(find_symbol_file_from_partial): Likewise.
@
text
@d1070 1
a1070 1
      if (strcmp (filename, p->filename) == 0)
d1738 1
a1738 1
    if (symname == NULL || strcmp (symname, ps->filename) == 0)
@


1.24
log
@	* xcoffread.c (xcoff_sym_fns): Update.
	* symfile.h (struct sym_fns) <sym_read_psymbols>: New field.
	(enum symfile_add_flags) <SYMFILE_NO_READ>: New constant.
	* symfile.c (syms_from_objfile): Handle SYMFILE_NO_READ.
	(symbol_file_add_with_addrs_or_offsets): Likewise.
	(reread_symbols): Handle OBJF_PSYMTABS_READ.
	* somread.c (som_sym_fns): Update.
	* psymtab.h (require_partial_symbols): Declare.
	* psymtab.c (require_partial_symbols): New function.
	(ALL_OBJFILE_PSYMTABS_REQUIRED): New macro.
	(ALL_OBJFILE_PSYMTABS): Undef.
	(ALL_PSYMTABS): Move from psympriv.h.
	(lookup_partial_symtab, find_pc_sect_psymtab)
	(lookup_symbol_aux_psymtabs, relocate_psymtabs)
	(find_last_source_symtab_from_partial)
	(forget_cached_source_info_partial)
	(print_psymtab_stats_for_objfile, read_symtabs_for_function)
	(expand_partial_symbol_tables, read_psymtabs_with_filename)
	(map_symbol_names_psymtab, map_symbol_filenames_psymtab)
	(find_symbol_file_from_partial, map_matching_symbols_psymtab)
	(expand_symtabs_matching_via_partial, maintenance_info_psymtabs):
	Use ALL_OBJFILE_PSYMTABS_REQUIRED.
	* psympriv.h (ALL_PSYMTABS): Move to psymtab.c.
	* objfiles.h (OBJF_PSYMTABS_READ): New macro.
	* objfiles.c (objfile_has_partial_symbols): Handle lazily-read
	psymtabs.
	* mipsread.c (ecoff_sym_fns): Update.
	* machoread.c (macho_sym_fns): Update.
	* elfread.c (elf_symfile_read): Set up for lazy psymtab reading.
	(read_psyms): New function.
	(elf_sym_fns, elf_sym_fns_gdb_index): Update.
	(elf_sym_fns_lazy_psyms): New global.
	* dwarf2read.c (dwarf2_initialize_objfile): Don't call
	dwarf2_build_psymtabs.
	* dbxread.c (aout_sym_fns): Update.
	* coffread.c (coff_sym_fns): Update.
@
text
@d36 2
d485 20
a504 1
      return PSYMTAB_TO_SYMTAB (ps);
d597 33
d641 2
d648 3
d679 2
a680 1
	  if (strcmp_iw_ordered (SYMBOL_SEARCH_NAME (*center), name) >= 0)
d694 1
a694 1
	     && SYMBOL_MATCHES_SEARCH_NAME (*top, name))
d698 4
a701 1
	    return (*top);
d715 5
a719 2
	      && SYMBOL_MATCHES_SEARCH_NAME (*psym, name))
	    return (*psym);
d723 1
@


1.23
log
@	* psymtab.c (expand_partial_symbol_tables): Use
	ALL_OBJFILE_PSYMTABS.
@
text
@d72 54
d136 1
a136 1
  ALL_OBJFILE_PSYMTABS (objfile, pst)
d174 1
a174 1
    ALL_OBJFILE_PSYMTABS (objfile, pst)
d337 1
a337 1
  ALL_OBJFILE_PSYMTABS (objfile, pst)
d480 1
a480 1
  ALL_OBJFILE_PSYMTABS (objfile, ps)
d692 1
a692 1
  ALL_OBJFILE_PSYMTABS (objfile, p)
d724 1
a724 1
  ALL_OBJFILE_PSYMTABS (ofp, ps)
d753 1
a753 1
  ALL_OBJFILE_PSYMTABS (objfile, pst)
d930 1
a930 1
  ALL_OBJFILE_PSYMTABS (objfile, ps)
d972 1
a972 1
  ALL_OBJFILE_PSYMTABS (objfile, ps)
d990 1
a990 1
  ALL_OBJFILE_PSYMTABS (objfile, psymtab)
d1001 1
a1001 1
  ALL_OBJFILE_PSYMTABS (objfile, p)
d1014 1
a1014 1
  ALL_OBJFILE_PSYMTABS (objfile, ps)
d1052 1
a1052 1
  ALL_OBJFILE_PSYMTABS (objfile, ps)
d1101 1
a1101 1
  ALL_OBJFILE_PSYMTABS (objfile, pst)
d1152 1
a1152 1
  ALL_OBJFILE_PSYMTABS (objfile, ps)
d1185 1
a1185 1
  ALL_OBJFILE_PSYMTABS (objfile, ps)
d1697 1
a1697 1
      ALL_OBJFILE_PSYMTABS (objfile, psymtab)
@


1.22
log
@2011-01-10  Michael Snyder  <msnyder@@vmware.com>

	* nto-procfs.c: Comment cleanup, mostly periods and spaces.
	* nto-tdep.c: Ditto.
	* nto-tdep.h: Ditto.
	* objc-exp.y: Ditto.
	* objc-lang.c: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* observer.c: Ditto.
	* opencl-lang.c: Ditto.
	* osabi.c: Ditto.
	* parse.c: Ditto.
	* parser-defs.h: Ditto.
	* p-exp.y: Ditto.
	* p-lang.c: Ditto.
	* posix-hdep.c: Ditto.
	* ppcbug-rom.c: Ditto.
	* ppc-linux-nat.c: Ditto.
	* ppc-linux-tdep.c: Ditto.
	* ppc-linux-tdep.h: Ditto.
	* ppcnbsd-tdep.c: Ditto.
	* ppcobsd-tdep.c: Ditto.
	* ppcobsd-tdep.h: Ditto.
	* ppc-sysv-tdep.c: Ditto.
	* ppc-tdep.h: Ditto.
	* printcmd.c: Ditto.
	* proc-abi.c: Ditto.
	* proc-flags.c: Ditto.
	* procfs.c: Ditto.
	* proc-utils.h: Ditto.
	* progspace.h: Ditto.
	* prologue-value.c: Ditto.
	* prologue-value.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* ravenscar-sparc-thread.c: Ditto.
	* ravenscar-thread.c: Ditto.
	* ravenscar-thread.h: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote.c: Ditto.
	* remote-fileio.c: Ditto.
	* remote-fileio.h: Ditto.
	* remote.h: Ditto.
	* remote-m32r-sdi.c: Ditto.
	* remote-mips.c: Ditto.
	* remote-sim.c: Ditto.
	* rs6000-aix-tdep.c: Ditto.
	* rs6000-nat.c: Ditto.
	* rs6000-tdep.c: Ditto.
@
text
@d936 1
a936 3
  for (psymtab = objfile->psymtabs;
       psymtab != NULL;
       psymtab = psymtab->next)
@


1.21
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d117 1
a117 1
  /* Now, search for a matching tail (only if name doesn't have any dirs) */
d166 1
a166 1
      section == 0)	/* can't validate section this way */
d174 1
a174 1
     find the one that fits better for the given PC address. We
d210 1
a210 1
	     best match symbol. This can help in cases where the
d213 2
a214 2
	     is emitted for statics. (See also the nodebug.exp
	     testcase.) */
d330 1
a330 1
  /* Cope with programs that start at address 0 */
d349 1
a349 1
	  if (section)		/* match on a specific section */
d373 1
a373 1
	  if (section)		/* match on a specific section */
d542 1
a542 1
  if (global)			/* This means we can use a binary search. */
d614 1
a614 1
  /* If it's been looked up before, return it. */
d729 1
a729 1
	  /* This is the usual thing -- don't print it */
d911 1
a911 1
   by matching FUNC_NAME.  Make sure we read that symbol table in. */
d976 1
a976 1
	  /* If interrupted, then quit. */
d1032 1
a1032 1
     deleted/moved/..., look for it again */
d1152 1
a1152 1
	 symtab in one loop. */
d1235 1
a1235 1
  /* Sort the global list; don't sort the static list */
d1245 1
a1245 1
   FILENAME is the name of the symbol-file we are reading from. */
d1267 1
a1267 1
   and name. These are the values which are set by
d1327 1
a1327 1
/* Return the internal bcache of the psymbol_bcache BCACHE*/
d1373 1
a1373 1
  /* val and coreaddr are mutually exclusive, one of them *will* be zero */
d1390 1
a1390 1
  /* Stash the partial symbol away in the cache */
d1397 1
a1397 1
   global_psymbols or static_psymbols. This space will eventually
d1420 1
a1420 1
     program works correctly */
d1467 1
a1467 1
  /* Stash the partial symbol away in the cache */
d1476 1
a1476 1
  /* Save pointer to partial symbol in psymtab, growing symtab if needed. */
d1499 1
a1499 1
     oriented symbols */
d1542 1
a1542 1
     inserted order. */
d1563 1
a1563 1
  /* First, snip it out of the psymtab chain */
d1570 1
a1570 1
  /* Next, put it on a free list for recycling */
d1602 1
a1602 1
      /* If a second arg is supplied, it is a source file name to match on */
@


1.20
log
@run copyright.sh for 2011.
@
text
@d559 2
a560 1
	    internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d576 2
a577 1
	internal_error (__FILE__, __LINE__, _("failed internal consistency check"));
d1124 4
a1127 2
				     int (*file_matcher) (const char *, void *),
				     int (*name_matcher) (const char *, void *),
d1145 4
a1148 2
      gbound = objfile->global_psymbols.list + ps->globals_offset + ps->n_global_syms;
      sbound = objfile->static_psymbols.list + ps->statics_offset + ps->n_static_syms;
d1593 2
a1594 1
      error (_("print-psymbols takes an output file name and optional symbol file name"));
d1669 2
a1670 1
			       psymtab->fullname ? psymtab->fullname : "(null)");
@


1.19
log
@gdb/
	Code cleanup.
	* dictionary.c
	(struct dict_vector) <iter_match_first, iter_match_next>
	(iter_match_first_hashed, iter_match_next_hashed)
	(iter_match_first_linear, iter_match_next_linear)
	(dict_iter_match_first, dict_iter_match_next, iter_match_first_hashed)
	(iter_match_next_hashed, iter_match_first_linear)
	(iter_match_next_linear): Use symbol_compare_ftype.
	* dictionary.h: Include symfile.h.
	(dict_iter_match_first, dict_iter_match_next): Use
	symbol_compare_ftype.
	* dwarf2read.c (dw2_map_matching_symbols): Likewise.
	* psymtab.c (match_partial_symbol, match_partial_symbol, map_block)
	(map_matching_symbols_psymtab): Likewise.
	* symfile.h (symbol_compare_ftype): New typedef.
	(struct quick_symbol_functions) <map_matching_symbols): Use
	symbol_compare_ftype.
@
text
@d3 1
a3 1
   Copyright (C) 2009, 2010 Free Software Foundation, Inc.
@


1.18
log
@Rework symbol searches to move Ada-specific stuff to ada-lang.c.

This is a clean-up of some of our symbol-lookup machinery to pull some
kludgy Ada-specific definitions out of psymtab.c.  In place of
map_ada_symtabs and ada_lookup_partial_symbol, we have a method
map_matching_symbols, which searches through all symbol tables and
partial symbol tables looking for a symbol that matches according to
a matching function that is passed as a parameter. This requires some
care, because partial symbol tables speed up searches by binary search,
while full symbol tables use hashing. To call map_matching_symbols, therefore,
you may need to supply both a matching function that is compatible with the
dictionary hash function and an ordering relation that is compatible with
strcmp_iw, which is used to order partial symbol tables.

Having added this general routine to psymtab.c, we use it in ada-lang.c
to rework add_non_local_symbols (now renamed add_nonlocal_symbols).

Changelog:

    gdb/

    * ada-lang.c (full_match): Declare.
    (ada_match_name): Rename to match_name (we should avoid prefixing static
    symbols with "ada_").
    (match_name): New name for ada_match_name.
    (struct ada_psym_data): Remove and replace with...
    (struct match_data): User data for map_matching_symbols.
    (ada_add_psyms): Remove.
    (aux_add_nonlocal_symbols): New function, used as callback for
    map_matching_symbols.
    (compare_names): Ordering function adopted from strcmp_iw for Ada-encoded
    symbols.
    (ada_add_non_local_symbols): Rename to add_nonlocal_symbols.
    (add_nonlocal_symbols): Renamed from ada_add_non_local_symbols.
    Rework to use map_matching_symbols instead of map_ada_symtabs.
    (ada_lookup_symbol_list): Use add_nonlocal_symbols.
    * psymtab.c: Include dependency on dictionary.h.
    (match_partial_symbol): New function.
    (ada_lookup_partial_symbol): Remove.
    (map_block): New function, auxiliary to map_matching_symbols_psymtab.
    (map_matching_symbols_psymtab): New function.
    (psym_functions): Replace map_ada_symtabs with map_matching_symbols_psymtab.
    * symfile.h: Replace map_ada_symtabs definition with map_matching_symbols.
@
text
@d53 2
a54 5
						    int (*) (const char *,
							     const char *),
						    int (*) (const char *,
							     const char *));

d446 2
a447 2
		      int (*match) (const char *, const char *),
		      int (*ordered_compare) (const char *, const char *))
d1064 1
a1064 2
	   void *data,
	   int (*match) (const char *, const char *))
d1092 2
a1093 3
			      int (*match) (const char *, const char *),
			      int (*ordered_compare) (const char *,
						      const char *))
@


1.17
log
@Replace wild_match with faster version and modify its interface.

This new version of wild_match is comparable in speed to strcmp_iw, and has
the same signature and same return value for equal names.

gdb/ChangeLog:
    * ada-lang.c (wild_match): Reimplement.
    Change API to eliminate unused length argument, reverse arguments and
    make 0 the 'true' return value.
    (advance_wild_match): New auxiliary function for wild_match to improve
    readability.
    (ada_match_name, ada_add_block_symbols): Use new API for wild_match.
    * psymtab.c (ada_lookup_partial_symbol, map_ada_symtabs): Use new
    API for wild_match.
    * symfile.h (map_ada_symtabs): Modify declaration to use new API for
    wild_match.
    * dwarf2read.c (dw2_map_ada_symtabs): Ditto.
@
text
@d35 1
d50 9
a58 1
/* Lookup a partial symbol.  */
d438 79
d526 1
a526 1
   Check the global symbols if GLOBAL, the static symbols if not. */
d564 1
a564 1
	      && (SYMBOL_LANGUAGE (*center) == language_java))
d591 1
a591 1
     we should also do a linear search. */
d1058 4
a1061 3
/* Look, in partial_symtab PST, for symbol NAME in given namespace.
   Check the global symbols if GLOBAL, the static symbols if not.
   Do wild-card match if WILD.  */
d1063 6
a1068 5
static struct partial_symbol *
ada_lookup_partial_symbol (struct partial_symtab *pst, const char *name,
                           int global, domain_enum namespace, int wild,
			   int (*wild_match) (const char *, const char *),
			   int (*is_name_suffix) (const char *))
d1070 2
a1071 4
  struct partial_symbol **start;
  int name_len = strlen (name);
  int length = (global ? pst->n_global_syms : pst->n_static_syms);
  int i;
d1073 2
a1074 1
  if (length == 0)
d1076 6
a1081 1
      return (NULL);
d1084 2
a1085 88
  start = (global ?
           pst->objfile->global_psymbols.list + pst->globals_offset :
           pst->objfile->static_psymbols.list + pst->statics_offset);

  if (wild)
    {
      for (i = 0; i < length; i += 1)
        {
          struct partial_symbol *psym = start[i];

          if (symbol_matches_domain (SYMBOL_LANGUAGE (psym),
                                     SYMBOL_DOMAIN (psym), namespace)
              && (*wild_match) (SYMBOL_LINKAGE_NAME (psym), name) == 0)
            return psym;
        }
      return NULL;
    }
  else
    {
      if (global)
        {
          int U;

          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];

              if (SYMBOL_LINKAGE_NAME (psym)[0] < name[0])
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > name[0])
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), name) < 0)
                i = M + 1;
              else
                U = M;
            }
        }
      else
        i = 0;

      while (i < length)
        {
          struct partial_symbol *psym = start[i];

          if (symbol_matches_domain (SYMBOL_LANGUAGE (psym),
                                     SYMBOL_DOMAIN (psym), namespace))
            {
              int cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym), name_len);

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && (*is_name_suffix) (SYMBOL_LINKAGE_NAME (psym)
					     + name_len))
                return psym;
            }
          i += 1;
        }

      if (global)
        {
          int U;

          i = 0;
          U = length - 1;
          while (U - i > 4)
            {
              int M = (U + i) >> 1;
              struct partial_symbol *psym = start[M];

              if (SYMBOL_LINKAGE_NAME (psym)[0] < '_')
                i = M + 1;
              else if (SYMBOL_LINKAGE_NAME (psym)[0] > '_')
                U = M - 1;
              else if (strcmp (SYMBOL_LINKAGE_NAME (psym), "_ada_") < 0)
                i = M + 1;
              else
                U = M;
            }
        }
      else
        i = 0;
d1087 2
a1088 33
      while (i < length)
        {
          struct partial_symbol *psym = start[i];

          if (symbol_matches_domain (SYMBOL_LANGUAGE (psym),
                                     SYMBOL_DOMAIN (psym), namespace))
            {
              int cmp;

              cmp = (int) '_' - (int) SYMBOL_LINKAGE_NAME (psym)[0];
              if (cmp == 0)
                {
                  cmp = strncmp ("_ada_", SYMBOL_LINKAGE_NAME (psym), 5);
                  if (cmp == 0)
                    cmp = strncmp (name, SYMBOL_LINKAGE_NAME (psym) + 5,
                                   name_len);
                }

              if (cmp < 0)
                {
                  if (global)
                    break;
                }
              else if (cmp == 0
                       && (*is_name_suffix) (SYMBOL_LINKAGE_NAME (psym)
					     + name_len + 5))
                return psym;
            }
          i += 1;
        }
    }
  return NULL;
}
d1091 8
a1098 6
map_ada_symtabs (struct objfile *objfile,
		 int (*wild_match) (const char *, const char *),
		 int (*is_name_suffix) (const char *),
		 void (*callback) (struct objfile *, struct symtab *, void *),
		 const char *name, int global, domain_enum namespace, int wild,
		 void *data)
d1100 1
d1107 2
a1108 2
	  || ada_lookup_partial_symbol (ps, name, global, namespace, wild,
					wild_match, is_name_suffix))
d1111 1
d1115 6
a1120 1
	  (*callback) (objfile, s, data);
d1123 1
a1123 1
}
d1209 1
a1209 1
  map_ada_symtabs,
@


1.16
log
@	* symfile.h (allocate_symtab): Update.
	* symfile.c (allocate_symtab): Make 'filename' const.
	* psymtab.c (add_psymbol_to_bcache): Make 'name' const.
	(add_psymbol_to_list): Likewise.
	* psympriv.h (struct partial_symtab) <filename, dirname>: Now
	const.
	(add_psymbol_to_list): Update.
	* mdebugread.c (new_symtab): Make 'name' const.
	(psymtab_to_symtab_1): Make 'filename' const.
	* elfread.c (elfstab_offset_sections): Update.
	* dwarf2read.c (dwarf_decode_lines): Make 'comp_dir' const.
	(dwarf2_start_subfile): Make 'dirname' and 'comp_dir' const.
	(psymtab_include_file_name): Update.
	* dbxread.c (find_stab_function_addr): Make 'filename' const.
	* buildsym.h (start_subfile): Update.
	* buildsym.c (start_subfile): Make arguments const.
@
text
@d977 1
a977 1
			   int (*wild_match) (const char *, int, const char *),
d1002 1
a1002 1
              && (*wild_match) (name, name_len, SYMBOL_LINKAGE_NAME (psym)))
d1115 1
a1115 1
		 int (*wild_match) (const char *, int, const char *),
@


1.15
log
@	* psympriv.h (add_psymbol_to_list, init_psymbol_list)
	(start_psymtab_common, allocate_psymtab, discard_psymtab):
	Declare.
	* symfile.h (extend_psymbol_list): Remove.
	(add_psymbol_to_list, init_psymbol_list, start_psymtab_common)
	(allocate_psymtab, discard_psymtab): Move to psympriv.h.
	* psymtab.c (extend_psymbol_list): Move earlier.  Now static.
@
text
@d1371 1
a1371 1
add_psymbol_to_bcache (char *name, int namelength, int copy_name,
d1468 1
a1468 1
add_psymbol_to_list (char *name, int namelength, int copy_name,
@


1.14
log
@	Revert:
	2010-09-01  Tom Tromey  <tromey@@redhat.com>
	* dwarf2read.c, gdbtypes.c, psymtab.c, symfile.h, symtab.c,
	symtab.h: Revert earlier change.
@
text
@d1409 29
a1588 29
/* Increase the space allocated for LISTP, which is probably
   global_psymbols or static_psymbols. This space will eventually
   be freed in free_objfile().  */

void
extend_psymbol_list (struct psymbol_allocation_list *listp,
		     struct objfile *objfile)
{
  int new_size;

  if (listp->size == 0)
    {
      new_size = 255;
      listp->list = (struct partial_symbol **)
	xmalloc (new_size * sizeof (struct partial_symbol *));
    }
  else
    {
      new_size = listp->size * 2;
      listp->list = (struct partial_symbol **)
	xrealloc ((char *) listp->list,
		  new_size * sizeof (struct partial_symbol *));
    }
  /* Next assumes we only went one over.  Should be good if
     program works correctly */
  listp->next = listp->list + listp->size;
  listp->size = new_size;
}

@


1.13
log
@Fix custom bcache hash regression.

2010-09-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* psymtab.c (add_psymbol_to_bcache): Initialize
	obj_section.
	memset psymbol.ginfo.value to 0.
@
text
@d429 4
a432 10
static struct symbol *
expand_one_symtab_matching_psymtabs (struct objfile *objfile,
				     int kind, const char *name,
				     domain_enum domain,
				     struct symbol *(*matcher) (struct symtab *,
								int,
								const char *,
								domain_enum,
								void *),
				     void *data)
d434 1
a434 1
  return NULL;
d1215 1
a1215 1
  expand_one_symtab_matching_psymtabs,
@


1.12
log
@	* symtab.h (lookup_type_symbol): Declare.
	* symtab.c (lookup_symbol_in_language_full): Rename from
	lookup_symbol_in_language.  Add 'for_type' argument.
	(lookup_symbol_in_language): New function.
	(lookup_type_symbol): Likewise.
	(lookup_symbol_aux): Add 'for_type' argument.
	(match_symbol_aux): New function.
	(lookup_symbol_aux_symtabs): Use expand_one_symtab_matching.
	(match_transparent_type): New function.
	(basic_lookup_transparent_type): Use expand_one_symtab_matching.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: Remove.
	<expand_one_symtab_matching>: New field.
	* psymtab.c (expand_one_symtab_matching_psymtabs): New function.
	(pre_expand_symtabs_matching_psymtabs): Remove.
	(psym_functions): Update.
	* gdbtypes.c (lookup_typename): Use lookup_type_symbol.
	* dwarf2read.c (dw2_lookup_symbol): Update comment.
	(dw2_pre_expand_symtabs_matching): Remove.
	(dw2_expand_one_symtab_matching): New function.
	(dwarf2_gdb_index_functions): Update.
@
text
@d1387 5
d1402 1
@


1.11
log
@Create and use a specialized bcache type for psymbols

2010-08-31  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symfile.c (reread_symbols): Use psymbol_bcache_free, and
	psymbol_bcache_init.
	* psymtab.h (psymbol_bcache_init): New function prototype.
	(psymbol_bcache_free): New function prototype.
	(psymbol_bcache_get_bcache): New function prototype.
	* psymtab.c (psymbol_bcache_init): New function.
	(psymbol_bcache_free): New function.
	(psymbol_bcache_full): New function.
	(psymbol_bcache_get_bcache): New function.
	(add_psymbol_to_bcache): use psymbol_bcache_full.
	* objfiles.h (psymbol_cache): Change type of psymbol_cache to
	psymbol_bcache.
	* symmisc.c (print_symbol_bcache_statistics): Updated.
	(print_objfile_statistics): Updated.
	* objfiles.c (allocate_objfile): Use psymbol_bcache_init to initialize
	psymbol_cache.
	(free_objfile): Use psymbol_bcache_free.
@
text
@d429 10
a438 4
static void
pre_expand_symtabs_matching_psymtabs (struct objfile *objfile,
				      int kind, const char *name,
				      domain_enum domain)
d440 1
a440 1
  /* Nothing.  */
d1221 1
a1221 1
  pre_expand_symtabs_matching_psymtabs,
@


1.10
log
@Enable custom bcache hash function.

2010-08-25  Sami Wagiaalla  <swagiaal@@redhat.com>

	* psymtab.c (add_psymbol_to_bcache): Remove 'static' from
	'static partial_symbol psymbol'.
	(psymbol_hash): New function.
	(psymbol_compare): New function.
	* bcache.c (hash_continue): New.
	(hash): Use hash_continue.
	* bcache.c: Add hash_function and compare_function
	pointers to bcache struct.
	(bcache_full): Use bcache->hash_function, and
	bcache->compare_function.
	(bcache_compare): New function.
	(bcache_xmalloc): Take hash_function and
	compare_function arguments and initialize the
	bcach's pointers.
	Updated comment.
	* objfiles.c (allocate_objfile): Updated.
	* symfile.c (reread_symbols): Updated.
	* python/py-type.c (typy_richcompare): Updated.
@
text
@d40 5
d1283 1
a1283 1
unsigned long
d1305 1
a1305 1
int
d1319 45
d1398 3
a1400 2
  return bcache_full (&psymbol, sizeof (struct partial_symbol),
		      objfile->psymbol_cache, added);
@


1.9
log
@Fix regression in -file-list-exec-source-files command.

See http://sourceware.org/ml/gdb/2010-07/msg00118.html for
a description of the problem. Namely, the file and fullname
fields are inverted in the output of the -file-list-exec-source-files
GDB/MI command:

    (gdb) interpreter-exec mi -file-list-exec-source-files
    ^done,files=[{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="",fullname="init.c"},{file="",fullname="../sysdeps/x86_64/elf/start.S"},{file="",fullname="../sysdeps/x86_64/elf/start.S"}]

It turns out to be a silly thinko: The map_symbol_filenames function
calls the psymtab version of map_symbol_filenames routine, and this
version called the callback function with filename and fullname
in the wrong order (fullname/filename instead of filename/fullname).

The routine description in symfile.h confirst that expected order for
the FUN callback parameters:

    /* Call a callback for every file defined in OBJFILE.  FUN is the
       callback.  It is passed the file's name, the file's full name,
       and the DATA passed to this function.  */
    void (*map_symbol_filenames) (struct objfile *objfile,
                                  void (*fun) (const char *, const char *,
                                               void *),
                                  void *data);

Fixing this error uncovered another location where the arguments
were reversed: maybe_add_partial_symtab_filename.  Once the first
error was fixed, the debugger would crash while attempting to do
completion, because it was given a NULL fullname instead of the
non-NULL filename.

gdb/ChangeLog:

        * psymtab.c (map_symbol_filenames_psymtab): Call FUN with
        the arguments in the correct order.
        * symtab.c (maybe_add_partial_symtab_filename): Declare
        the arguments in the correct order.
@
text
@d1273 41
d1329 2
a1330 9
  /* psymbol is static so that there will be no uninitialized gaps in the
     structure which might contain random data, causing cache misses in
     bcache. */
  static struct partial_symbol psymbol;

  /* However, we must ensure that the entire 'value' field has been
     zeroed before assigning to it, because an assignment may not
     write the entire field.  */
  memset (&psymbol.ginfo.value, 0, sizeof (psymbol.ginfo.value));
@


1.8
log
@create and use symbol_set_language.

2010-08-09  Sami Wagiaalla  <swagiaal@@redhat.com>

	* symtab.h: Renamed SYMBOL_INIT_LANGUAGE_SPECIFIC to
	SYMBOL_SET_LANGUAGE.
	(symbol_init_language_specific): Renamed to symbol_set_language.
	* symtab.c (symbol_init_language_specific): Removed redundant check
	for language_cplus.
	Renamed to symbol_set_language.
	* stabsread.c (define_symbol): Updated.
	(read_enum_type): Updated
	* psymtab.c (add_psymbol_to_bcache): Updated.
	* minsyms.c (install_minimal_symbols): Updated.
	* coffread.c (process_coff_symbol): SYMBOL_SET_LANGUAGE instead of
	SYMBOL_LANGUAGE to set the language.
	* minsyms.c (prim_record_minimal_symbol_full): Ditto.
	* mdebugread.c (new_symbol): Ditto.
	* cp-namespace.c (check_one_possible_namespace_symbol): Ditto.
	* dwarf2read.c (new_symbol_full): Ditto.
	* jv-lang.c (add_class_symbol): Ditto.
@
text
@d916 1
a916 1
      (*fun) (fullname, ps->filename, data);
@


1.7
log
@	* symfile.c (set_initial_language): Update.
	(deduce_language_from_filename): Argument type now const.
	* symtab.h (find_main_filename): Update.
	(deduce_language_from_filename): Update.
	* symtab.c (find_main_filename): Make result const.
	* dwarf2read.c (dw2_find_symbol_file): Change return type.
	* psymtab.c (find_symbol_file_from_partial): Change return type.
	* symfile.h (struct quick_symbol_functions) <find_symbol_file>:
	Make result const.
@
text
@d1307 1
a1307 1
  SYMBOL_LANGUAGE (&psymbol) = language;
@


1.6
log
@	* symtab.c (lookup_symbol_aux_symtabs): Call pre-expand hook.
	(basic_lookup_transparent_type): Likewise.
	* symfile.h (struct quick_symbol_functions)
	<pre_expand_symtabs_matching>: New field.
	* psymtab.c (pre_expand_symtabs_matching_psymtabs): New function.
	(psym_functions): Update.
@
text
@d952 1
a952 1
static char *
@


1.5
log
@	* psymtab.c (lookup_partial_symbol): Mark definition as static.
@
text
@d424 8
d1210 1
@


1.5.2.1
log
@Fix regression in -file-list-exec-source-files command.

See http://sourceware.org/ml/gdb/2010-07/msg00118.html for
a description of the problem. Namely, the file and fullname
fields are inverted in the output of the -file-list-exec-source-files
GDB/MI command:

    (gdb) interpreter-exec mi -file-list-exec-source-files
    ^done,files=[{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="/takamaka.a/brobecke/ex/list-exec-source-files/foo.c",fullname="foo.c"},{file="",fullname="init.c"},{file="",fullname="../sysdeps/x86_64/elf/start.S"},{file="",fullname="../sysdeps/x86_64/elf/start.S"}]

It turns out to be a silly thinko: The map_symbol_filenames function
calls the psymtab version of map_symbol_filenames routine, and this
version called the callback function with filename and fullname
in the wrong order (fullname/filename instead of filename/fullname).

The routine description in symfile.h confirst that expected order for
the FUN callback parameters:

    /* Call a callback for every file defined in OBJFILE.  FUN is the
       callback.  It is passed the file's name, the file's full name,
       and the DATA passed to this function.  */
    void (*map_symbol_filenames) (struct objfile *objfile,
                                  void (*fun) (const char *, const char *,
                                               void *),
                                  void *data);

Fixing this error uncovered another location where the arguments
were reversed: maybe_add_partial_symtab_filename.  Once the first
error was fixed, the debugger would crash while attempting to do
completion, because it was given a NULL fullname instead of the
non-NULL filename.

gdb/ChangeLog:

        * psymtab.c (map_symbol_filenames_psymtab): Call FUN with
        the arguments in the correct order.
        * symtab.c (maybe_add_partial_symtab_filename): Declare
        the arguments in the correct order.
@
text
@d908 1
a908 1
      (*fun) (ps->filename, fullname, data);
@


1.4
log
@2010-05-15  Michael Snyder  <msnyder@@vmware.com>

	* parse.c: White space.
	* p-lang.c: White space.
	* posix-hdep.c: White space.
	* printcmd.c: White space.
	* progspace.c: White space.
	* prologue-value.c: White space.
	* psymtab.c: White space.
	* p-typeprint.c: White space.
	* p-valprint.c: White space.
@
text
@d427 1
a427 1
struct partial_symbol *
@


1.3
log
@2010-05-05  Michael Snyder  <msnyder@@vmware.com>

	* psymtab.c (lookup_partial_symbol): Delete unused variable.
	(find_last_source_symtab_from_partial): Delete unused variable.
	* symfile.c (place_section): Delete unused variable.
	(default_symfile_offsets): Delete unused variable.
	(get_debug_link_info): Delete unused variable.
	(find_separate_debug_file_by_debuglink): Delete unused variable.
	(add_symbol_file_command): Delete unused variable.
	(symfile_find_segment_sections): Delete unused variable.
	* symmisc.c (free_symtab): Delete unused variable.
	(dump_symtab_1): Delete unused variable.
	* symtab.c (lookup_symbil_aux_quick): Delete unused variable.
	(find_pc_sect_symtab): Delete unused variable.
	(skip_prologue_using_lineinfo): Delete unused variable.
	(sources_info): Delete unused variable.
	(completion_list_add_name): Delete unused variable.
	(expand_line_sal): Delete unused variable.
@
text
@d239 1
d522 1
d574 1
d774 1
d861 1
d999 1
d1006 1
d1045 1
d1052 1
d1118 1
d1469 1
d1655 1
@


1.2
log
@	* xcoffread.c (xcoff_start_psymtab): Update.
	(xcoff_end_psymtab): Update.
	* psymtab.c (allocate_psymtab): Remove dead code.
	* psympriv.h (struct partial_symtab) <read_symtab_private>: Now
	void*.
	* mdebugread.c (parse_partial_symbols): Update.
	(new_psymtab): Likewise.
	* dwarf2read.c (process_psymtab_comp_unit): Update.
	(psymtab_to_symtab_1): Update.
	* dbxread.c (start_psymtab): Update.
	(end_psymtab): Likewise.
@
text
@a429 1
  struct partial_symbol *temp;
a564 1
  struct symtab *result;
@


1.1
log
@gdb
	* xcoffread.c: Include psymtab.h.
	(xcoff_sym_fns): Update.
	* symtab.h (struct partial_symbol): Remove.
	(PSYMBOL_DOMAIN, PSYMBOL_CLASS): Remove.
	(struct partial_symtab): Remove.
	(PSYMTAB_TO_SYMTAB): Remove.
	(lookup_partial_symbol, lookup_partial_symtab, find_pc_psymtab)
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): Declare.
	(find_pc_psymtab, find_pc_sect_psymbol, psymtab_to_symtab)
	(find_main_psymtab): Remove.
	(find_main_filename): Declare.
	(fixup_psymbol_section): Remove.
	(fixup_section): Declare.
	* symtab.c: Include psymtab.h.
	(lookup_symtab): Use lookup_symtab method.
	(lookup_partial_symtab): Remove.
	(find_pc_sect_psymtab_closer): Remove.
	(find_pc_sect_psymtab): Remove.
	(find_pc_sect_symtab_via_partial): New function.
	(find_pc_psymtab, find_pc_sect_psymbol, find_pc_psymbol): Remove.
	(fixup_section): No longer static.
	(fixup_psymbol_section): Remove.
	(lookup_symbol_aux): Use lookup_symbol_aux_quick.
	(lookup_global_symbol_from_objfile): Likewise.
	(lookup_symbol_aux_psymtabs): Remove.
	(lookup_symbol_aux_quick): New function.
	(lookup_symbol_global): Use lookup_symbol_aux_quick.
	(lookup_partial_symbol): Remove.
	(basic_lookup_transparent_type_quick): New function.
	(basic_lookup_transparent_type): Use it.
	(find_main_psymtab): Remove.
	(find_main_filename): New function.
	(find_pc_sect_symtab): Use find_pc_sect_symtab method.
	(find_line_symtab): Use expand_symtabs_with_filename method.
	(output_partial_symbol_filename): New function.
	(sources_info): Use map_partial_symbol_filenames.
	(struct search_symbols_data): New type.
	(search_symbols_file_matches): New function.
	(search_symbols_name_matches): Likewise.
	(search_symbols): Use expand_symtabs_matching method.
	(struct add_name_data): Rename from add_macro_name_data.
	(add_macro_name): Update.
	(add_partial_symbol_name): New function.
	(default_make_symbol_completion_list): Use
	map_partial_symbol_names.
	(struct add_partial_symbol_name): New type.
	(maybe_add_partial_symtab_filename): New function.
	(make_source_files_completion_list): Use
	map_partial_symbol_filenames.
	(expand_line_sal): Use expand_symtabs_with_filename method.
	* symmisc.c: Include psymtab.h.
	(print_objfile_statistics): Use print_stats method.
	(dump_objfile): Use dump method.
	(dump_psymtab, maintenance_print_psymbols)
	(maintenance_info_psymtabs, maintenance_check_symtabs)
	(extend_psymbol_list): Remove.
	* symfile.h (struct quick_symbol_functions): New struct.
	(struct sym_fns) <qf>: New field.
	(sort_pst_symbols): Remove.
	(increment_reading_symtab): Declare.
	* symfile.c: Include psymtab.h.
	(compare_psymbols, sort_pst_symbols): Remove.
	(psymtab_to_symtab): Remove.
	(increment_reading_symtab): New function.
	(symbol_file_add_with_addrs_or_offsets): Use expand_all_symtabs
	method.
	(set_initial_language): Use find_main_filename.
	(allocate_psymtab, discard_psymtab, cashier_psymtab): Remove.
	(free_named_symtabs): Remove unused code.
	(start_psymtab_common, add_psymbol_to_bcache)
	(append_psymbol_to_list, add_psymbol_to_list, init_psymbol_list):
	Remove.
	* stack.c: Include psymtab.h, symfile.h.
	(backtrace_command_1): Use find_pc_sect_symtab_via_partial.
	* source.h (psymtab_to_fullname): Don't declare.
	* source.c: Include psymtab.h.
	(select_source_symtab): Use find_last_source_symtab method.
	(forget_cached_source_info): Use forget_cached_source_info
	method.
	(find_and_open_source): No longer static.
	(psymtab_to_fullname): Remove.
	* somread.c: Include psymtab.h.
	(som_sym_fns): Update.
	* psympriv.h: New file.
	* psymtab.h: New file.
	* psymtab.c: New file.
	* objfiles.h: (ALL_OBJFILE_PSYMTABS): Remove.
	(ALL_PSYMTABS, ALL_PSPACE_PSYMTABS): Likewise.
	* objfiles.c: Include psymtab.h.
	(objfile_relocate1): Use relocate method.
	(objfile_has_partial_symbols): Use has_symbols method.
	* mipsread.c: Include psymtab.h.
	(ecoff_sym_fns): Update.
	* mi/mi-cmd-file.c: Include psymtab.h.
	(print_partial_file_name): New function.
	(mi_cmd_file_list_exec_source_files): Use
	map_partial_symbol_filenames.
	* mdebugread.c: Include psympriv.h.
	* machoread.c: Include psympriv.h.
	(macho_sym_fns): Update.
	* m2-exp.y (yylex): Use lookup_symtab.
	* elfread.c: Include psympriv.h.
	(elf_sym_fns): Update.
	* dwarf2read.c: Include psympriv.h.
	* dbxread.c: Include psympriv.h.
	(aout_sym_fns): Update.
	* cp-support.c: Include psymtab.h.
	(read_in_psymtabs): Remove.
	(make_symbol_overload_list_qualified): Use
	expand_symtabs_for_function method.
	* coffread.c: Include psympriv.h.
	(coff_sym_fns): Update.
	* blockframe.c: Include psymtab.h.
	(find_pc_partial_function): Use find_pc_sect_symtab method.
	* ada-lang.h (ada_update_initial_language): Update.
	* ada-lang.c: Include psymtab.h.
	(ada_update_initial_language): Remove 'main_pst' argument.
	(ada_lookup_partial_symbol): Remove.
	(struct ada_psym_data): New type.
	(ada_add_psyms): New function.
	(ada_add_non_local_symbols): Use map_ada_symtabs method.
	(struct add_partial_datum): New type.
	(ada_add_partial_symbol_completions): New function.
	(ada_make_symbol_completion_list): Use map_partial_symbol_names.
	(ada_exception_support_info_sniffer): Update.
	* Makefile.in (SFILES): Add psymtab.c.
	(COMMON_OBS): Add psymtab.o.
	(HFILES_NO_SRCDIR): Add psymtab.h, psympriv.h.
gdb/doc
	* gdbint.texinfo (Symbol Handling): Update.
@
text
@a1422 11
#if 0
  {
    struct partial_symtab **prev_pst;
    psymtab->objfile = objfile;
    psymtab->next = NULL;
    prev_pst = &(objfile->psymtabs);
    while ((*prev_pst) != NULL)
      prev_pst = &((*prev_pst)->next);
    (*prev_pst) = psymtab;
  }
#endif
@

