head	1.37;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.35
	gdb_7_6-2013-04-26-release:1.35
	gdb_7_6-branch:1.35.0.2
	gdb_7_6-2013-03-12-branchpoint:1.35
	gdb_7_5_1-2012-11-29-release:1.33
	gdb_7_5-2012-08-17-release:1.33
	gdb_7_5-branch:1.33.0.2
	gdb_7_5-2012-07-18-branchpoint:1.33
	gdb_7_4_1-2012-04-26-release:1.30.4.1
	gdb_7_4-2012-01-24-release:1.30.4.1
	gdb_7_4-branch:1.30.0.4
	gdb_7_4-2011-12-13-branchpoint:1.30
	gdb_7_3_1-2011-09-04-release:1.30
	gdb_7_3-2011-07-26-release:1.30
	gdb_7_3-branch:1.30.0.2
	gdb_7_3-2011-04-01-branchpoint:1.30
	gdb_7_2-2010-09-02-release:1.29
	gdb_7_2-branch:1.29.0.4
	gdb_7_2-2010-07-07-branchpoint:1.29
	gdb_7_1-2010-03-18-release:1.29
	gdb_7_1-branch:1.29.0.2
	gdb_7_1-2010-02-18-branchpoint:1.29
	gdb_7_0_1-2009-12-22-release:1.25
	gdb_7_0-2009-10-06-release:1.25
	gdb_7_0-branch:1.25.0.4
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.21
	msnyder-checkpoint-072509-branch:1.25.0.2
	msnyder-checkpoint-072509-branchpoint:1.25
	arc-insight_6_8-branch:1.21.0.10
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.8
	insight_6_8-branchpoint:1.21
	reverse-20081226-branch:1.23.0.6
	reverse-20081226-branchpoint:1.23
	multiprocess-20081120-branch:1.23.0.4
	multiprocess-20081120-branchpoint:1.23
	reverse-20080930-branch:1.23.0.2
	reverse-20080930-branchpoint:1.23
	reverse-20080717-branch:1.21.0.6
	reverse-20080717-branchpoint:1.21
	msnyder-reverse-20080609-branch:1.21.0.4
	msnyder-reverse-20080609-branchpoint:1.21
	drow-reverse-20070409-branch:1.17.0.2
	drow-reverse-20070409-branchpoint:1.17
	gdb_6_8-2008-03-27-release:1.21
	gdb_6_8-branch:1.21.0.2
	gdb_6_8-2008-02-26-branchpoint:1.21
	gdb_6_7_1-2007-10-29-release:1.19
	gdb_6_7-2007-10-10-release:1.19
	gdb_6_7-branch:1.19.0.2
	gdb_6_7-2007-09-07-branchpoint:1.19
	insight_6_6-20070208-release:1.16
	gdb_6_6-2006-12-18-release:1.16
	gdb_6_6-branch:1.16.0.2
	gdb_6_6-2006-11-15-branchpoint:1.16
	insight_6_5-20061003-release:1.15
	gdb-csl-symbian-6_4_50_20060226-12:1.15
	gdb-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.15
	gdb-csl-symbian-6_4_50_20060226-11:1.15
	gdb-csl-sourcerygxx-4_1-17:1.15
	gdb-csl-20060226-branch-local-2:1.15
	gdb-csl-sourcerygxx-4_1-14:1.15
	gdb-csl-sourcerygxx-4_1-13:1.15
	gdb-csl-sourcerygxx-4_1-12:1.15
	gdb-csl-sourcerygxx-3_4_4-21:1.15
	gdb_6_5-20060621-release:1.15
	gdb-csl-sourcerygxx-4_1-9:1.15
	gdb-csl-sourcerygxx-4_1-8:1.15
	gdb-csl-sourcerygxx-4_1-7:1.15
	gdb-csl-arm-2006q1-6:1.15
	gdb-csl-sourcerygxx-4_1-6:1.15
	gdb-csl-symbian-6_4_50_20060226-10:1.15
	gdb-csl-symbian-6_4_50_20060226-9:1.15
	gdb-csl-symbian-6_4_50_20060226-8:1.15
	gdb-csl-coldfire-4_1-11:1.15
	gdb-csl-sourcerygxx-3_4_4-19:1.15
	gdb-csl-coldfire-4_1-10:1.15
	gdb_6_5-branch:1.15.0.16
	gdb_6_5-2006-05-14-branchpoint:1.15
	gdb-csl-sourcerygxx-4_1-5:1.15
	nickrob-async-20060513-branch:1.15.0.14
	nickrob-async-20060513-branchpoint:1.15
	gdb-csl-sourcerygxx-4_1-4:1.15
	msnyder-reverse-20060502-branch:1.15.0.12
	msnyder-reverse-20060502-branchpoint:1.15
	gdb-csl-morpho-4_1-4:1.15
	gdb-csl-sourcerygxx-3_4_4-17:1.15
	readline_5_1-import-branch:1.15.0.10
	readline_5_1-import-branchpoint:1.15
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.15
	gdb-csl-symbian-20060226-branch:1.15.0.8
	gdb-csl-symbian-20060226-branchpoint:1.15
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.15
	msnyder-reverse-20060331-branch:1.15.0.6
	msnyder-reverse-20060331-branchpoint:1.15
	gdb-csl-available-20060303-branch:1.15.0.4
	gdb-csl-available-20060303-branchpoint:1.15
	gdb-csl-20060226-branch:1.15.0.2
	gdb-csl-20060226-branchpoint:1.15
	gdb_6_4-20051202-release:1.11
	msnyder-fork-checkpoint-branch:1.11.0.14
	msnyder-fork-checkpoint-branchpoint:1.11
	gdb-csl-gxxpro-6_3-branch:1.11.0.12
	gdb-csl-gxxpro-6_3-branchpoint:1.11
	gdb_6_4-branch:1.11.0.10
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.8
	gdb-csl-arm-20051020-branchpoint:1.11
	msnyder-tracepoint-checkpoint-branch:1.11.0.6
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	csl-arm-20050325-branch:1.11.0.4
	csl-arm-20050325-branchpoint:1.11
	gdb-post-i18n-errorwarning-20050211:1.11
	gdb-pre-i18n-errorwarning-20050211:1.11
	gdb_6_3-20041109-release:1.11
	gdb_6_3-branch:1.11.0.2
	gdb_6_3-20041019-branchpoint:1.11
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.5.0.6
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.12
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.10
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.6
	drow_intercu-20040221-branchpoint:1.3
	cagney_bfdfile-20040213-branch:1.3.0.4
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.2
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.2.0.8
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.6
	cagney_x86i386-20030821-branch:1.2.0.4
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.2
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.1.0.46
	jimb-ppc64-linux-20030613-branchpoint:1.1
	cagney_convert-20030606-branch:1.1.0.44
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.42
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.40
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.38
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.36
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.34
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.32
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.30
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.28
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.26
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.24
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.22
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.20
	cagney_offbyone-20030303-branchpoint:1.1
	carlton_dictionary-20030207-merge:1.1
	interps-20030203-mergepoint:1.1
	interps-20030202-branch:1.1.0.18
	interps-20030202-branchpoint:1.1
	cagney-unwind-20030108-branch:1.1.0.16
	cagney-unwind-20030108-branchpoint:1.1
	carlton_dictionary-20021223-merge:1.1
	gdb_5_3-2002-12-12-release:1.1
	carlton_dictionary-20021115-merge:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.14
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-20020927-merge:1.1
	carlton_dictionary-branch:1.1.0.12
	carlton_dictionary-20020920-branchpoint:1.1
	gdb_5_3-branch:1.1.0.10
	gdb_5_3-2002-09-04-branchpoint:1.1
	kseitz_interps-20020829-merge:1.1
	cagney_sysregs-20020825-branch:1.1.0.8
	cagney_sysregs-20020825-branchpoint:1.1
	readline_4_3-import-branch:1.1.0.6
	readline_4_3-import-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.4
	cagney_regbuf-20020515-branch:1.1.0.2;
locks; strict;
comment	@ * @;


1.37
date	2013.10.02.00.46.06;	author kseitz;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.13.16.45.10;	author palves;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.12.09.03.09;	author hilfingr;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.01.06.32.36;	author brobecke;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.01.21.03.15;	author palves;	state Exp;
branches;
next	1.32;

1.32
date	2012.02.29.19.53.16;	author brobecke;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.04.08.16.55;	author brobecke;	state Exp;
branches;
next	1.30;

1.30
date	2011.01.01.15.32.56;	author brobecke;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2010.01.19.09.50.48;	author brobecke;	state Exp;
branches;
next	1.28;

1.28
date	2010.01.01.07.31.29;	author brobecke;	state Exp;
branches;
next	1.27;

1.27
date	2010.01.01.06.29.10;	author brobecke;	state Exp;
branches;
next	1.26;

1.26
date	2010.01.01.06.06.48;	author brobecke;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.18.08.51.10;	author nathan;	state Exp;
branches;
next	1.24;

1.24
date	2009.01.03.05.57.50;	author brobecke;	state Exp;
branches;
next	1.23;

1.23
date	2008.09.11.14.09.37;	author uweigand;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.19.10.10.39;	author hilfingr;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.09.19.27.15;	author bauermann;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.12.16.33.20;	author uweigand;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.12.15.33.03;	author uweigand;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.09.17.58.49;	author drow;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.21.13.50.51;	author drow;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.23.18.43.41;	author drow;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.08.07.19.40;	author hilfingr;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.02.09.46.34;	author hilfingr;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.15.13.29.33;	author cagney;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.09.04.56.48;	author hilfingr;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.06.09.28.55;	author hilfingr;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.03.08.35.56;	author hilfingr;	state Exp;
branches;
next	1.7;

1.7
date	2004.09.18.22.23.23;	author hilfingr;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.28.15.49.03;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.01.10.11.11;	author hilfingr;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.02.09.55.36;	author hilfingr;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.23.20.41.16;	author cagney;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	2003.06.17.20.58.32;	author ciceron;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.04.15.28.48;	author aidan;	state Exp;
branches
	1.1.2.1
	1.1.4.1
	1.1.12.1
	1.1.14.1;
next	;

1.30.4.1
date	2012.01.06.04.43.03;	author brobecke;	state Exp;
branches;
next	;

1.3.6.1
date	2004.09.16.17.00.52;	author drow;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2004.09.21.20.44.13;	author drow;	state Exp;
branches;
next	;

1.1.2.1
date	2002.06.15.16.42.50;	author cagney;	state Exp;
branches;
next	;

1.1.4.1
date	2002.06.20.01.32.07;	author kseitz;	state Exp;
branches;
next	;

1.1.12.1
date	2003.06.27.21.49.44;	author carlton;	state Exp;
branches;
next	1.1.12.2;

1.1.12.2
date	2003.12.16.00.00.12;	author carlton;	state Exp;
branches;
next	;

1.1.14.1
date	2003.12.14.20.27.04;	author drow;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Constification of parse_linespec and fallout:
https://sourceware.org/ml/gdb-patches/2013-09/msg01017.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01018.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01019.html
https://sourceware.org/ml/gdb-patches/2013-09/msg01020.html
@
text
@/* FLEX lexer for Ada expressions, for GDB.
   Copyright (C) 1994-2013 Free Software Foundation, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

/*----------------------------------------------------------------------*/

/* The converted version of this file is to be included in ada-exp.y, */
/* the Ada parser for gdb.  The function yylex obtains characters from */
/* the global pointer lexptr.  It returns a syntactic category for */
/* each successive token and places a semantic value into yylval */
/* (ada-lval), defined by the parser.   */

DIG	[0-9]
NUM10	({DIG}({DIG}|_)*)
HEXDIG	[0-9a-f]
NUM16	({HEXDIG}({HEXDIG}|_)*)
OCTDIG	[0-7]
LETTER	[a-z_]
ID	({LETTER}({LETTER}|{DIG})*|"<"{LETTER}({LETTER}|{DIG})*">")
WHITE	[ \t\n]
TICK	("'"{WHITE}*)
GRAPHIC [a-z0-9 #&'()*+,-./:;<>=_|!$%?@@\[\]\\^`{}~]
OPER    ([-+*/=<>&]|"<="|">="|"**"|"/="|"and"|"or"|"xor"|"not"|"mod"|"rem"|"abs")

EXP	(e[+-]{NUM10})
POSEXP  (e"+"?{NUM10})

%{

#define NUMERAL_WIDTH 256
#define LONGEST_SIGN ((ULONGEST) 1 << (sizeof(LONGEST) * HOST_CHAR_BIT - 1))

/* Temporary staging for numeric literals.  */
static char numbuf[NUMERAL_WIDTH];
 static void canonicalizeNumeral (char *s1, const char *);
static struct stoken processString (const char*, int);
static int processInt (const char *, const char *, const char *);
static int processReal (const char *);
static struct stoken processId (const char *, int);
static int processAttribute (const char *);
static int find_dot_all (const char *);
static void rewind_to_char (int);

#undef YY_DECL
#define YY_DECL static int yylex ( void )

/* Flex generates a static function "input" which is not used.
   Defining YY_NO_INPUT comments it out.  */
#define YY_NO_INPUT

#undef YY_INPUT
#define YY_INPUT(BUF, RESULT, MAX_SIZE) \
    if ( *lexptr == '\000' ) \
      (RESULT) = YY_NULL; \
    else \
      { \
        *(BUF) = *lexptr; \
        (RESULT) = 1; \
	lexptr += 1; \
      }

static int find_dot_all (const char *);

%}

%option case-insensitive interactive nodefault

%s BEFORE_QUAL_QUOTE

%%

{WHITE}		 { }

"--".*		 { yyterminate(); }

{NUM10}{POSEXP}  {
		   canonicalizeNumeral (numbuf, yytext);
		   return processInt (NULL, numbuf, strrchr(numbuf, 'e')+1);
		 }

{NUM10}          {
		   canonicalizeNumeral (numbuf, yytext);
		   return processInt (NULL, numbuf, NULL);
		 }

{NUM10}"#"{HEXDIG}({HEXDIG}|_)*"#"{POSEXP} {
		   canonicalizeNumeral (numbuf, yytext);
    		   return processInt (numbuf,
				      strchr (numbuf, '#') + 1,
				      strrchr(numbuf, '#') + 1);
		 }

{NUM10}"#"{HEXDIG}({HEXDIG}|_)*"#" {
		   canonicalizeNumeral (numbuf, yytext);
    		   return processInt (numbuf, strchr (numbuf, '#') + 1, NULL);
		 }

"0x"{HEXDIG}+	{
		  canonicalizeNumeral (numbuf, yytext+2);
		  return processInt ("16#", numbuf, NULL);
		}


{NUM10}"."{NUM10}{EXP} {
		   canonicalizeNumeral (numbuf, yytext);
		   return processReal (numbuf);
		}

{NUM10}"."{NUM10} {
		   canonicalizeNumeral (numbuf, yytext);
		   return processReal (numbuf);
		}

{NUM10}"#"{NUM16}"."{NUM16}"#"{EXP} {
                   error (_("Based real literals not implemented yet."));
		}

{NUM10}"#"{NUM16}"."{NUM16}"#" {
                   error (_("Based real literals not implemented yet."));
		}

<INITIAL>"'"({GRAPHIC}|\")"'" {
		   yylval.typed_val.type = type_char ();
		   yylval.typed_val.val = yytext[1];
		   return CHARLIT;
		}

<INITIAL>"'[\""{HEXDIG}{2}"\"]'"   {
                   int v;
                   yylval.typed_val.type = type_char ();
		   sscanf (yytext+3, "%2x", &v);
		   yylval.typed_val.val = v;
		   return CHARLIT;
		}

\"({GRAPHIC}|"[\""({HEXDIG}{2}|\")"\"]")*\"   {
	           yylval.sval = processString (yytext+1, yyleng-2);
		   return STRING;
		}

\"              {
                   error (_("ill-formed or non-terminated string literal"));
		}


if		{
                  rewind_to_char ('i');
		  return 0;
		}

task            {
                  rewind_to_char ('t');
		  return 0;
		}

thread{WHITE}+{DIG} {
                  /* This keyword signals the end of the expression and
                     will be processed separately.  */
                  rewind_to_char ('t');
		  return 0;
		}

	/* ADA KEYWORDS */

abs		{ return ABS; }
and		{ return _AND_; }
else		{ return ELSE; }
in		{ return IN; }
mod		{ return MOD; }
new		{ return NEW; }
not		{ return NOT; }
null		{ return NULL_PTR; }
or		{ return OR; }
others          { return OTHERS; }
rem		{ return REM; }
then		{ return THEN; }
xor		{ return XOR; }

	/* BOOLEAN "KEYWORDS" */

 /* True and False are not keywords in Ada, but rather enumeration constants.
    However, the boolean type is no longer represented as an enum, so True
    and False are no longer defined in symbol tables.  We compromise by
    making them keywords (when bare). */

true		{ return TRUEKEYWORD; }
false		{ return FALSEKEYWORD; }

        /* ATTRIBUTES */

{TICK}[a-zA-Z][a-zA-Z]+ { return processAttribute (yytext+1); }

	/* PUNCTUATION */

"=>"		{ return ARROW; }
".."		{ return DOTDOT; }
"**"		{ return STARSTAR; }
":="		{ return ASSIGN; }
"/="		{ return NOTEQUAL; }
"<="		{ return LEQ; }
">="		{ return GEQ; }

<BEFORE_QUAL_QUOTE>"'" { BEGIN INITIAL; return '\''; }

[-&*+./:<>=|;\[\]] { return yytext[0]; }

","		{ if (paren_depth == 0 && comma_terminates)
		    {
		      rewind_to_char (',');
		      return 0;
		    }
		  else
		    return ',';
		}

"("		{ paren_depth += 1; return '('; }
")"		{ if (paren_depth == 0)
		    {
		      rewind_to_char (')');
		      return 0;
		    }
		  else
 		    {
		      paren_depth -= 1;
		      return ')';
		    }
		}

"."{WHITE}*all  { return DOT_ALL; }

"."{WHITE}*{ID} {
	 	  yylval.sval = processId (yytext+1, yyleng-1);
	          return DOT_ID;
		}

{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*(" "*"'")?  {
                  int all_posn = find_dot_all (yytext);

                  if (all_posn == -1 && yytext[yyleng-1] == '\'')
		    {
		      BEGIN BEFORE_QUAL_QUOTE;
		      yyless (yyleng-1);
		    }
                  else if (all_posn >= 0)
		    yyless (all_posn);
                  yylval.sval = processId (yytext, yyleng);
                  return NAME;
               }


	/* GDB EXPRESSION CONSTRUCTS  */

"'"[^']+"'"{WHITE}*:: {
                  yyless (yyleng - 2);
		  yylval.sval = processId (yytext, yyleng);
		  return NAME;
		}

"::"            { return COLONCOLON; }

[{}@@]		{ return yytext[0]; }

	/* REGISTERS AND GDB CONVENIENCE VARIABLES */

"$"({LETTER}|{DIG}|"$")*  {
		  yylval.sval.ptr = yytext;
		  yylval.sval.length = yyleng;
		  return SPECIAL_VARIABLE;
		}

	/* CATCH-ALL ERROR CASE */

.		{ error (_("Invalid character '%s' in expression."), yytext); }
%%

#include <ctype.h>
#include "gdb_string.h"

/* Initialize the lexer for processing new expression. */

static void
lexer_init (FILE *inp)
{
  BEGIN INITIAL;
  yyrestart (inp);
}


/* Copy S2 to S1, removing all underscores, and downcasing all letters.  */

static void
canonicalizeNumeral (char *s1, const char *s2)
{
  for (; *s2 != '\000'; s2 += 1)
    {
      if (*s2 != '_')
	{
	  *s1 = tolower(*s2);
	  s1 += 1;
	}
    }
  s1[0] = '\000';
}

/* Interprets the prefix of NUM that consists of digits of the given BASE
   as an integer of that BASE, with the string EXP as an exponent.
   Puts value in yylval, and returns INT, if the string is valid.  Causes
   an error if the number is improperly formated.   BASE, if NULL, defaults
   to "10", and EXP to "1".  The EXP does not contain a leading 'e' or 'E'.
 */

static int
processInt (const char *base0, const char *num0, const char *exp0)
{
  ULONGEST result;
  long exp;
  int base;
  const char *trailer;

  if (base0 == NULL)
    base = 10;
  else
    {
      base = strtol (base0, (char **) NULL, 10);
      if (base < 2 || base > 16)
	error (_("Invalid base: %d."), base);
    }

  if (exp0 == NULL)
    exp = 0;
  else
    exp = strtol(exp0, (char **) NULL, 10);

  errno = 0;
  result = strtoulst (num0, &trailer, base);
  if (errno == ERANGE)
    error (_("Integer literal out of range"));
  if (isxdigit(*trailer))
    error (_("Invalid digit `%c' in based literal"), *trailer);

  while (exp > 0)
    {
      if (result > (ULONG_MAX / base))
	error (_("Integer literal out of range"));
      result *= base;
      exp -= 1;
    }

  if ((result >> (gdbarch_int_bit (parse_gdbarch)-1)) == 0)
    yylval.typed_val.type = type_int ();
  else if ((result >> (gdbarch_long_bit (parse_gdbarch)-1)) == 0)
    yylval.typed_val.type = type_long ();
  else if (((result >> (gdbarch_long_bit (parse_gdbarch)-1)) >> 1) == 0)
    {
      /* We have a number representable as an unsigned integer quantity.
         For consistency with the C treatment, we will treat it as an
	 anonymous modular (unsigned) quantity.  Alas, the types are such
	 that we need to store .val as a signed quantity.  Sorry
         for the mess, but C doesn't officially guarantee that a simple
         assignment does the trick (no, it doesn't; read the reference manual).
       */
      yylval.typed_val.type
	= builtin_type (parse_gdbarch)->builtin_unsigned_long;
      if (result & LONGEST_SIGN)
	yylval.typed_val.val =
	  (LONGEST) (result & ~LONGEST_SIGN)
	  - (LONGEST_SIGN>>1) - (LONGEST_SIGN>>1);
      else
	yylval.typed_val.val = (LONGEST) result;
      return INT;
    }
  else
    yylval.typed_val.type = type_long_long ();

  yylval.typed_val.val = (LONGEST) result;
  return INT;
}

static int
processReal (const char *num0)
{
  sscanf (num0, "%" DOUBLEST_SCAN_FORMAT, &yylval.typed_val_float.dval);

  yylval.typed_val_float.type = type_float ();
  if (sizeof(DOUBLEST) >= gdbarch_double_bit (parse_gdbarch)
			    / TARGET_CHAR_BIT)
    yylval.typed_val_float.type = type_double ();
  if (sizeof(DOUBLEST) >= gdbarch_long_double_bit (parse_gdbarch)
			    / TARGET_CHAR_BIT)
    yylval.typed_val_float.type = type_long_double ();

  return FLOAT;
}


/* Store a canonicalized version of NAME0[0..LEN-1] in yylval.ssym.  The
   resulting string is valid until the next call to ada_parse.  If
   NAME0 contains the substring "___", it is assumed to be already
   encoded and the resulting name is equal to it.  Otherwise, it differs
   from NAME0 in that:
    + Characters between '...' or <...> are transfered verbatim to 
      yylval.ssym.
    + <, >, and trailing "'" characters in quoted sequences are removed
      (a leading quote is preserved to indicate that the name is not to be
      GNAT-encoded).
    + Unquoted whitespace is removed.
    + Unquoted alphabetic characters are mapped to lower case.
   Result is returned as a struct stoken, but for convenience, the string
   is also null-terminated.  Result string valid until the next call of
   ada_parse.
 */
static struct stoken
processId (const char *name0, int len)
{
  char *name = obstack_alloc (&temp_parse_space, len + 11);
  int i0, i;
  struct stoken result;

  result.ptr = name;
  while (len > 0 && isspace (name0[len-1]))
    len -= 1;

  if (strstr (name0, "___") != NULL)
    {
      strncpy (name, name0, len);
      name[len] = '\000';
      result.length = len;
      return result;
    }

  i = i0 = 0;
  while (i0 < len)
    {
      if (isalnum (name0[i0]))
	{
	  name[i] = tolower (name0[i0]);
	  i += 1; i0 += 1;
	}
      else switch (name0[i0])
	{
	default:
	  name[i] = name0[i0];
	  i += 1; i0 += 1;
	  break;
	case ' ': case '\t':
	  i0 += 1;
	  break;
	case '\'':
	  do
	    {
	      name[i] = name0[i0];
	      i += 1; i0 += 1;
	    }
	  while (i0 < len && name0[i0] != '\'');
	  i0 += 1;
	  break;
	case '<':
	  i0 += 1;
	  while (i0 < len && name0[i0] != '>')
	    {
	      name[i] = name0[i0];
	      i += 1; i0 += 1;
	    }
	  i0 += 1;
	  break;
	}
    }
  name[i] = '\000';

  result.length = i;
  return result;
}

/* Return TEXT[0..LEN-1], a string literal without surrounding quotes,
   with special hex character notations replaced with characters. 
   Result valid until the next call to ada_parse.  */

static struct stoken
processString (const char *text, int len)
{
  const char *p;
  char *q;
  const char *lim = text + len;
  struct stoken result;

  q = obstack_alloc (&temp_parse_space, len);
  result.ptr = q;
  p = text;
  while (p < lim)
    {
      if (p[0] == '[' && p[1] == '"' && p+2 < lim)
         {
           if (p[2] == '"')  /* "...["""]... */
             {
               *q = '"';
	       p += 4;
	     }
           else
	     {
               int chr;
	       sscanf (p+2, "%2x", &chr);
	       *q = (char) chr;
	       p += 5;
	     }
         }
       else
         *q = *p;
       q += 1;
       p += 1;
     }
  result.length = q - result.ptr;
  return result;
}

/* Returns the position within STR of the '.' in a
   '.{WHITE}*all' component of a dotted name, or -1 if there is none.
   Note: we actually don't need this routine, since 'all' can never be an
   Ada identifier.  Thus, looking up foo.all or foo.all.x as a name
   must fail, and will eventually be interpreted as (foo).all or
   (foo).all.x.  However, this does avoid an extraneous lookup. */

static int
find_dot_all (const char *str)
{
  int i;
  for (i = 0; str[i] != '\000'; i += 1)
    {
      if (str[i] == '.')
	{
	  int i0 = i;
	  do
	    i += 1;
	  while (isspace (str[i]));
	  if (strncmp (str+i, "all", 3) == 0
	      && ! isalnum (str[i+3]) && str[i+3] != '_')
	    return i0;
	}
    }
  return -1;
}

/* Returns non-zero iff string SUBSEQ matches a subsequence of STR, ignoring
   case.  */

static int
subseqMatch (const char *subseq, const char *str)
{
  if (subseq[0] == '\0')
    return 1;
  else if (str[0] == '\0')
    return 0;
  else if (tolower (subseq[0]) == tolower (str[0]))
    return subseqMatch (subseq+1, str+1) || subseqMatch (subseq, str+1);
  else
    return subseqMatch (subseq, str+1);
}


static struct { const char *name; int code; }
attributes[] = {
  { "address", TICK_ADDRESS },
  { "unchecked_access", TICK_ACCESS },
  { "unrestricted_access", TICK_ACCESS },
  { "access", TICK_ACCESS },
  { "first", TICK_FIRST },
  { "last", TICK_LAST },
  { "length", TICK_LENGTH },
  { "max", TICK_MAX },
  { "min", TICK_MIN },
  { "modulus", TICK_MODULUS },
  { "pos", TICK_POS },
  { "range", TICK_RANGE },
  { "size", TICK_SIZE },
  { "tag", TICK_TAG },
  { "val", TICK_VAL },
  { NULL, -1 }
};

/* Return the syntactic code corresponding to the attribute name or
   abbreviation STR.  */

static int
processAttribute (const char *str)
{
  int i, k;

  for (i = 0; attributes[i].code != -1; i += 1)
    if (strcasecmp (str, attributes[i].name) == 0)
      return attributes[i].code;

  for (i = 0, k = -1; attributes[i].code != -1; i += 1)
    if (subseqMatch (str, attributes[i].name))
      {
	if (k == -1)
	  k = i;
	else
	  error (_("ambiguous attribute name: `%s'"), str);
      }
  if (k == -1)
    error (_("unrecognized attribute: `%s'"), str);

  return attributes[k].code;
}

/* Back up lexptr by yyleng and then to the rightmost occurrence of
   character CH, case-folded (there must be one).  WARNING: since
   lexptr points to the next input character that Flex has not yet
   transferred to its internal buffer, the use of this function
   depends on the assumption that Flex calls YY_INPUT only when it is
   logically necessary to do so (thus, there is no reading ahead
   farther than needed to identify the next token.)  */

static void
rewind_to_char (int ch)
{
  lexptr -= yyleng;
  while (toupper (*lexptr) != toupper (ch))
    lexptr -= 1;
  yyrestart (NULL);
}

int
yywrap(void)
{
  return 1;
}

/* Dummy definition to suppress warnings about unused static definitions. */
typedef void (*dummy_function) ();
dummy_function ada_flex_use[] = 
{ 
  (dummy_function) yyunput
};
@


1.36
log
@More invalid pointer to pointer conversions.

As a follow up to:

  http://sourceware.org/ml/gdb-patches/2013-03/msg00449.html

In a nutshell, casts between 'char **' <-> 'unsigned char **' and
'char **' <-> 'const char **' are invalid.

I grepped for "\*\*) &" and found these.  There's another one in
demangle.c, but I've split fixing that one to a separate patch.

I think the ada_decode_symbol change is perhaps the one that could be
surprising.  The function's description has this comment, which makes
things much clearer:

   The GSYMBOL parameter is "mutable" in the C++ sense: logically
   const, but nevertheless modified to a semantically equivalent form
   when a decoded name is cached in it.  */

 const char *
 ada_decode_symbol (const struct general_symbol_info *gsymbol)

With that out of the way, I think the patch ends up being pretty
obvious.

Tested on x86_64 Fedora 17.

gdb/
2013-03-13  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (ada_decode_symbol): Cast away constness of GSYMBOL
	rather than casting 'const char * const *' to 'const char **'.
	* ada-lex.l (processInt): Make "trailer" local const.  Remove
	'const char **' cast.
	* arm-linux-tdep.c (arm_stap_parse_special_token): Add 'char *'
	locals, and use those as strtol output pointer, instead than doing
	invalid casts to from 'const char **' to 'char **'.
	(_initialize_demangle): Remove cast.
	* i386-tdep.c (i386_stap_parse_special_token): : Add 'char *'
	locals, and use those as strtol output pointer, instead than doing
	invalid casts to from 'const char **' to 'char **'.
	* solib-dsbt.c (dsbt_get_initial_loadmaps): Remove 'gdb_byte**'
	casts.
	* stap-probe.c (stap_parse_register_operand)
	(stap_parse_single_operand): Likewise.
@
text
@d500 2
a501 1
  q = result.ptr = obstack_alloc (&temp_parse_space, len);
@


1.35
log
@Allow 'thread' to be used as a variable name in expressions.

GDB treats the identifiers 'if', 'thread', and 'task' unconditionally
as expression delimiters in Ada mode, which is correct for 'if' and 'task',
but wrong for 'thread' in cases such as

      print thread

Borrowing from c-exp.y, we observe that 'thread' must be followed by
numerals, whereas identifiers never are and treat them as delimiters
only in that case.

In the process, the current also refactors and incidentally fixes the
code for rewinding the input to before the delimiting tokens.  For
example, the code

      watch expr if i > 2

fails because the input is only rewound to just before the 'i',
leaving the 'if' as part of the expression (and thus making the
rest look like trailing junk rather than a conditional clause).

gdb/ChangeLog:

    * ada-lex.l (rules): Only recognize 'thread' as a
    delimiter when followed by numerals, as for c-exp.y.
    Use new rewind_to_char function to rewind the input for
    expression-delimiting tokens.
    (rewind_to_char): New function.

gdb/testsuite/ChangeLog:

    * gdb.ada/expr_delims.exp: New file.
    * gdb.ada/expr_delims/foo.adb: New file.
    * gdb.ada/expr_delims/pck.ads: New file.
    * gdb.ada/expr_delims/pck.adb: New file.
@
text
@d332 1
a332 2

  char *trailer;
d349 1
a349 1
  result = strtoulst (num0, (const char **) &trailer, base);
@


1.34
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d56 1
d161 1
a161 3
		  while (*lexptr != 'i' && *lexptr != 'I')
		    lexptr -= 1;
		  yyrestart(NULL);
d165 6
a170 1
(task|thread)	{
d173 1
a173 3
		  while (*lexptr != 't' && *lexptr != 'T')
		    lexptr--;
		  yyrestart(NULL);
d223 1
a223 2
		      lexptr -= 1;
		      yyrestart(NULL);
d233 1
a233 2
		      lexptr -= 1;
		      yyrestart(NULL);
d619 17
@


1.33
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* ada-lang.c (ada_modulus_from_name): Delete.
	* ada-lex.l (lexer_init): Make static.
@
text
@d2 1
a2 2
   Copyright (C) 1994, 1997-1998, 2000-2003, 2007-2012 Free Software
   Foundation, Inc.
@


1.32
log
@[Ada] processId: Do not modify already encoded IDs

The processID function is supposed to take a symbol name, and process it
in a way that allows us to look that symbol up.  This patch is adding
a guard to make sure that we do not apply any transformation if we detect
that we are given an already-encoded symbol name.  For instance:

    gv___XR_pck__global_variable___XE

This happens in the case where we are trying to print the value of
a renaming. To do this, we simply parse and evaluate the XR symbol
name as an expression. Without this change, the expression parser
transforms gv___XR_pck__global_variable___XE into somethink like
gv___xr_pck__global_variable___xe, which then screws up the rest
of the renaming evaluation.

gdb/ChangeLog:

        * ada-lex.p (processId): Do not modify already encoded IDs.
        Update function documentation.
@
text
@d296 1
a296 1
void
@


1.31
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d413 3
a415 1
   resulting string is valid until the next call to ada_parse.  It differs
d435 1
d438 9
a485 1
  result.ptr = name;
@


1.30
log
@run copyright.sh for 2011.
@
text
@d2 2
a3 2
   Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003, 2007, 2008, 2009,
   2010, 2011 Free Software Foundation, Inc.
@


1.30.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d2 2
a3 2
   Copyright (C) 1994, 1997-1998, 2000-2003, 2007-2012 Free Software
   Foundation, Inc.
@


1.29
log
@"delete" ada-lex.c:input function, not used.

        * ada-lex.l: #define YY_NO_INPUT.
@
text
@d3 1
a3 1
   2010 Free Software Foundation, Inc.
@


1.28
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@d61 4
@


1.27
log
@Fix break *FUN'address thread NUM.

        * ada-lex.l (task): Expand rule to also match the thread keyword.
@
text
@d2 2
a3 2
   Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003, 2007, 2008, 2009
   Free Software Foundation, Inc.
@


1.26
log
@Fix break *FUN'address task NUM.

        * ada-lex.l (task): New rule.
        * ada-lang.c (valid_task_id): Make sure the Ada task list has
        been built before using it.
@
text
@d163 3
a165 1
task		{
@


1.25
log
@	* Makefile.in: Update license to GPLv3.
	* ada-exp.y: Update license to GPLv3.
	* ada-lex.l: Update license to GPLv3.
	* c-exp.y: Update license to GPLv3.
	* cp-name-parser.y: Update license to GPLv3.
	* darwin-nat-info.c: Update license to GPLv3.
	* f-exp.y: Update license to GPLv3.
	* gdb_thread_db.h: Update license to GPLv3.
	* hppanbsd-nat.c: Update license to GPLv3.
	* hppanbsd-tdep.c: Update license to GPLv3.
	* hppaobsd-tdep.c: Update license to GPLv3.
	* jv-exp.y: Update license to GPLv3.
	* m2-exp.y: Update license to GPLv3.
	* objc-exp.y: Update license to GPLv3.
	* p-exp.y: Update license to GPLv3.
	* reply_mig_hack.awk: Update license to GPLv3.
	* reverse.c: Update license to GPLv3.
	* xtensa-xtregs.c: Update license to GPLv3.
@
text
@d163 7
@


1.24
log
@        Updated copyright notices for most files.
@
text
@d5 1
a5 1
This file is part of GDB.
d7 12
a18 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor,
Boston, MA 02110-1301, USA.  */
@


1.23
log
@	* expression.h (struct expression): New member GDBARCH.
	* parse.c (parse_exp_in_context): Initialize it.
	* parser-def.h (parse_gdbarch, parse_language): New macros.

	* ada-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	Replace current_language by parse_language.
	* ada-lex.l (processInt): Replace current_gdbarch by parse_gdbarch.
	Replace builtin_type_ macros.

	* c-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* f-exp.y (parse_type, parse_f_type): New macros.
	Replace builtin_type_ macros by using parse_{f_,}type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* jv-exp.y (parse_type): New macro.
	(parse_number): Replace builtin_type_ macros by using parse_type.

	* m2-exp.y (parse_type, parse_m2_type): New macros.
	Replace builtin_type_ macros by using parse_{m2_,}type.

	* objc-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.

	* p-exp.y (parse_type): New macro.
	Replace builtin_type_ macros by using parse_type.
	(parse_number): Replace current_gdbarch by parse_gdbarch.
	(yylex): Replace current_language by parse_language.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003, 2007, 2008
@


1.22
log
@* ada-lang.c (discrete_type_high_bound,discrete_type_low_bound): Change
API to return LONGEST values rather than struct values.
(ada_evaluate_subexp): Change to use new API of discrete_type_low_bound
and discrete_type_high_bound.
(to_fixed_range_type): Create a range type in cases where
argument is base type and its limits are representable as ints.
(ada_is_modular_type): Correct so that base type must be integral.
* ada-lex.l (TRUEKEYWORD,FALSEKEYWORD): Make 'true' and 'false'
keywords when they appear alone, since we are phasing out
direct representation of these identifiers in ebugging data.
* ada-exp.y: Define 'true' and 'false' as primaries.
(type_boolean): New function.
(type_int,type_long,type_long_long,type_floattype_double)
(type_long_double): Remove uses of current_gdbarch for consistency
with type_boolean.
(write_int): Change comment to indicate that it might write boolean
constant as well.
* ada-typeprint.c (ada_print_type): Print '(false, true)' for boolean
type, since will no longer be represented as enumerated type in
debugging data.
* ada-valprint.c (print_optional_low_bound): Handle boolean case
as well.
@
text
@d354 1
a354 1
  if ((result >> (gdbarch_int_bit (current_gdbarch)-1)) == 0)
d356 1
a356 1
  else if ((result >> (gdbarch_long_bit (current_gdbarch)-1)) == 0)
d358 1
a358 1
  else if (((result >> (gdbarch_long_bit (current_gdbarch)-1)) >> 1) == 0)
d367 2
a368 1
      yylval.typed_val.type = builtin_type_unsigned_long;
d390 1
a390 1
  if (sizeof(DOUBLEST) >= gdbarch_double_bit (current_gdbarch)
d393 1
a393 1
  if (sizeof(DOUBLEST) >= gdbarch_long_double_bit (current_gdbarch)
@


1.21
log
@	* doublest.h (DOUBLEST_PRINT_FORMAT): Remove % from string.
	(DOUBLEST_SCAN_FORMAT): Likewise.
	* dfp.c (decimal_from_floating): Use DOUBLEST_PRINT_FORMAT.
	* ada-lex.l (processReal): Prepend "%" to use of DOUBLEST_SCAN_FORMAT.
	* c-exp.y (parse_number): Likewise.
	* jv-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
@
text
@d181 10
@


1.20
log
@	Updated copyright notices for most files.
@
text
@d376 1
a376 1
  sscanf (num0, DOUBLEST_SCAN_FORMAT, &yylval.typed_val_float.dval);
@


1.19
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_FLOAT_BIT): Replace by gdbarch_float_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type)
	(_initialize_m2_language): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_FLOAT_FORMAT): Replace by gdbarch_float_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_BIT): Replace by gdbarch_double_bit.
	* valarith.c (value_binop): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* mdebugread.c (_initialize_mdebugread): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* cris-tdep.c (cris_gdbarch_init): Likewise (comment).
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_DOUBLE_FORMAT): Replace by gdbarch_double_format.
	* value.c (unpack_double): Likewise (comment).
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_BIT): Replace by
	gdbarch_long_double_bit.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* ada-lex.l (processReal): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbarch.sh (TARGET_LONG_DOUBLE_FORMAT): Replace by
	gdbarch_long_double_format.
	* gdbtypes.c (build_gdbtypes): Likewise.
	* doublest.c (floatformat_from_length): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003, 2007
@


1.18
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_SHORT_BIT): Replace by gdbarch_int_bit.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type, build_fortran_types): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* gdbarch.sh (TARGET_INT_BIT): Replace by gdbarch_int_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type, ada_language_arch_info)
	(gdbtypes_post_init, build_gdbtypes): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* parse.c (build_parse): Likewise.
	* xcoffread.c (_initialize_xcoffread): Likewise.
	* stabsread.c (define_symbol, read_one_struct_field, read_enum_type)
	(read_range_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* f-lang.c (build_fortran_types, f_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type, _initialize_m2_language)
	(m2_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (coff_read_enum_type): Likewise.
	* mdebugread.c (parse_symbol, _initialize_mdebugread): Likewise.
	* dwarf2read.c (new_symbol): Likewise.
	* gdbarch.sh (TARGET_LONG_BIT): Replace by gdbarch_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* ada-lex.l (processInt): Likewise.
	* f-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* valarith.c (value_binop): Likewise.
	* symfile.c (read_target_long_array, simple_overlay_update_1): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (build_gdbtypes, gdbtypes_post_init): Likewise.
	* symfile.c (TARGET_LONG_BYTES): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* coffread.c (decode_base_type): Likewise.
	* gdbarch.sh (TARGET_LONG_LONG_BIT): Replace by gdbarch_long_long_bit.
	* c-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
	* ada-lang.c (ada_create_fundamental_type)
	(ada_language_arch_info): Likewise.
	* gdbtypes.c (gdbtypes_post_init, build_gdbtypes): Likewise.
	* stabsread.c (read_range_type): Likewise.
	* p-lang.c (pascal_create_fundamental_type): Likewise.
	* objc-lang.c (objc_create_fundamental_type): Likewise.
	* m2-lang.c (m2_create_fundamental_type): Likewise.
	* f-lang.c (f_create_fundamental_type): Likewise.
	* c-lang.c (c_create_fundamental_type): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d379 2
a380 1
  if (sizeof(DOUBLEST) >= TARGET_DOUBLE_BIT / TARGET_CHAR_BIT)
d382 2
a383 1
  if (sizeof(DOUBLEST) >= TARGET_LONG_DOUBLE_BIT / TARGET_CHAR_BIT)
@


1.17
log
@Copyright updates for 2007.
@
text
@d344 1
a344 1
  if ((result >> (TARGET_INT_BIT-1)) == 0)
d346 1
a346 1
  else if ((result >> (TARGET_LONG_BIT-1)) == 0)
d348 1
a348 1
  else if (((result >> (TARGET_LONG_BIT-1)) >> 1) == 0)
@


1.16
log
@	* ada-lex.l (HIGH_BYTE_POSN, is_digit_in_base, digit_to_int)
	(strtoulst): Moved to ...
	* utils.c (HIGH_BYTE_POSN, is_digit_in_base, digit_to_int)
	(strtoulst): ... here.  Enhanced to behave more similarly
	to strtoul.
	* defs.h (strtoulst): New prototype.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003
@


1.15
log
@	* doublest.h: Conditionalize DOUBLEST on PRINTF_HAS_LONG_DOUBLE
	also.
	(DOUBLEST_FORMAT): Rename to DOUBLEST_PRINT_FORMAT.
	(DOUBLEST_SCAN_FORMAT): New.
	* ada-lex.l (PRINTF_HAS_LONG_DOUBLE): Remove redefinitions.
	(processReal): Use DOUBLEST_SCAN_FORMAT.
	* c-exp.y (parse_number): Likewise.
	* jv-exp.y (parse_number): Likewise.
	* objc-exp.y (parse_number): Likewise.
	* p-exp.y (parse_number): Likewise.
@
text
@a298 62
#define HIGH_BYTE_POSN ((sizeof (ULONGEST) - 1) * HOST_CHAR_BIT)

/* True (non-zero) iff DIGIT is a valid digit in radix BASE,
   where 2 <= BASE <= 16.  */

static int
is_digit_in_base (unsigned char digit, int base)
{
  if (!isxdigit (digit))
    return 0;
  if (base <= 10)
    return (isdigit (digit) && digit < base + '0');
  else
    return (isdigit (digit) || tolower (digit) < base - 10 + 'a');
}

static int
digit_to_int (unsigned char c)
{
  if (isdigit (c))
    return c - '0';
  else
    return tolower (c) - 'a' + 10;
}

/* As for strtoul, but for ULONGEST results.  */

ULONGEST
strtoulst (const char *num, const char **trailer, int base)
{
  unsigned int high_part;
  ULONGEST result;
  int i;
  unsigned char lim;

  if (base < 2 || base > 16)
    {
      errno = EINVAL;
      return 0;
    }
  lim = base - 1 + '0';

  result = high_part = 0;
  for (i = 0; is_digit_in_base (num[i], base); i += 1)
    {
      result = result*base + digit_to_int (num[i]);
      high_part = high_part*base + (unsigned int) (result >> HIGH_BYTE_POSN);
      result &= ((ULONGEST) 1 << HIGH_BYTE_POSN) - 1;
      if (high_part > 0xff)
	{
	  errno = ERANGE;
	  result = high_part = 0;
	  break;
	}
    }

  if (trailer != NULL)
    *trailer = &num[i];

  return result + ((ULONGEST) high_part << HIGH_BYTE_POSN);
}

@


1.14
log
@* ada-exp.y, ada-lex.l, ada-typeprint.c: I18n markup.
* ada-tasks.c, ada-lang.c: I18n markup.
Editorial: change "can not" => "cannot" throughout.
@
text
@a434 7
#if defined (PRINTF_HAS_LONG_DOUBLE)
#  undef PRINTF_HAS_LONG_DOUBLE
#  define PRINTF_HAS_LONG_DOUBLE 1
#else
#  define PRINTF_HAS_LONG_DOUBLE 0
#endif

d438 1
a438 10
#if defined (PRINTF_HAS_LONG_DOUBLE)
  if (sizeof (DOUBLEST) > sizeof (double))
    sscanf (num0, "%Lg", &yylval.typed_val_float.dval);
  else
#endif
    {
      double temp;
      sscanf (num0, "%lg", &temp);
      yylval.typed_val_float.dval = temp;
    }
@


1.13
log
@	* ada-exp.y: Considerable reorganization to move functionality
	from ada-lex.l to here, where it is logically more appropriate.
	The original reason, however, was to prevent premature name
	lookups for selector names in record aggregates.
	(BLOCKNAME, TYPENAME, OBJECT_RENAMING): Remove; lexer now returns
	NAME for all of these.
	(VAR): New artificial token to clarify precedence rules.
	(OTHERS): New lexeme.
	(empty_stoken): New symbol.
	(%union): Remove ssym, voidval.
	(%type): Remove <voidval> type declarations.
	(syntax definitions): Add aggregates.
	Remove distinction between NAME, TYPENAME, BLOCKNAME, OBJECT_RENAMING.
	Rename some non-terminals to be closer to reference manual usage.
	Tighten up expression syntax to disallow certain non-Ada
	constructions such as X and then Y or else Z.
	(ada_parse): Remove initialization of left_block_context.
	(write_var_from_name): Remove.
	(write_var_or_type): New function, containing previous code from
	defunct write_var_from_name and name_lookup.
	(block_lookup): New function, moved from ada-lex.l
	(select_possible_type_sym): New function, factored out of
	name_lookup, which used to be in ada-lex.l.
	(find_primitive_type): Ditto.
	(chop_selector): Ditto.
	(write_ambiguous_var): New function, factored out of defunct
	write_var_from_name.
	(write_selectors): New function.
	(write_name_assoc): New function.
	(write_exp_op_with_string): New function.

	* ada-lex.l (processId): Change interface to return stoken.
	(tempbuf, resize_tempbuf, tempbuf_size, tempbuf_len): Remove.
	(block_lookup, name_lookup): Remove.  Functionality moved to
	ada-exp.y.
	(state IN_STRING): Remove.
	(rules): Handle string escapes in processString.
	Add 'others' token.
	Return all NAMEs, BLOCKNAMEs, OBJECT_RENAMINGs, TYPENAMEs in
	yylval.sval (as simple strings).
	All name look-ups now handled in ada-exp.y.
	Introduce "::" (COLONCOLON) token and return as separate token.
	(processId): Change return convention.  Comment.
	Leave leading "'" in place.
	(processString): New function.
	(find_dot_all): Add note to comment.
	Fix problem that allowed match only at the end.

	* ada-lang.c: Introduce aggregates.
	(find_struct_field): Add new parameter to count fields skipped, and
	allow other output parameters to be NULL.
	(value_tag_from_contents_and_address, ada_value_struct_elt): Use
	new find_struct_field.
	(ada_index_struct_field, assign_aggregate, ada_is_array_type)
	(num_visible_fields, ada_index_struct_field_1, ada_index_struct_field)
	(num_component_specs, assign_component, assign_aggregate):
	(aggregate_assign_from_choices,aggregate_assign_positional)
	(aggregate_assign_others,add_component_interval):
	New functions.
	(ada_evaluate_subexp): Declare.
	Add aggregate-related operators.
	(ada_forward_operator_length): Declare.
	(resolve_subexp): Add cases for new aggregate operators and OP_NAME.
	Consolidate Ada operators, using ada_forward_operator_length.
	(ada_search_struct_field): Search in forward order.
	(ADA_OPERATORS): Add new aggregate operators.
	(ada_operator_length, ada_op_name, ada_forward_operator_length)
	(ada_dump_subexp_body, ada_print_subexp): Handle new aggregate
	operators and OP_NAME.
	(ada_type_of_array): Use longest_to_int.
	(value_assign_to_component): New function.
	(ada_forward_operator_length, ada_op_name, ada_dump_subexp_body):
	Add OP_NAME case.
	(ada_forward_operator_length, ada_dump_subexp_body):
	Add OP_STRING case.

	* ada-lang.h (enum ada_operator): Add OP_AGGREGATE, OP_OTHERS,
	OP_CHOICES, OP_DISCRETE_RANGE, OP_POSITIONAL.
@
text
@d127 1
a127 1
                   error ("Based real literals not implemented yet.");
d131 1
a131 1
                   error ("Based real literals not implemented yet.");
d154 1
a154 1
                   error ("ill-formed or non-terminated string literal");
d267 1
a267 1
.		{ error ("Invalid character '%s' in expression.", yytext); }
d383 1
a383 1
	error ("Invalid base: %d.", base);
d394 1
a394 1
    error ("Integer literal out of range");
d396 1
a396 1
    error ("Invalid digit `%c' in based literal", *trailer);
d401 1
a401 1
	error ("Integer literal out of range");
d655 1
a655 1
	  error ("ambiguous attribute name: `%s'", str);
d658 1
a658 1
    error ("unrecognized attribute: `%s'", str);
@


1.12
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@d53 1
d56 1
a56 1
static int processId (const char *, int);
a73 11
static char *tempbuf = NULL;
static int tempbufsize = 0;
static int tempbuf_len;
static struct block *left_block_context;

static void resize_tempbuf (unsigned int);

static void block_lookup (char *, char *);

static int name_lookup (char *, char *, int *, int);

d80 1
a80 1
%s IN_STRING BEFORE_QUAL_QUOTE
d148 2
a149 12
<INITIAL>\"	{
		   tempbuf_len = 0;
		   BEGIN IN_STRING;
		}

<IN_STRING>{GRAPHIC}*\"  {
		   resize_tempbuf (yyleng+tempbuf_len);
		   strncpy (tempbuf+tempbuf_len, yytext, yyleng-1);
		   tempbuf_len += yyleng-1;
		   yylval.sval.ptr = tempbuf;
		   yylval.sval.length = tempbuf_len;
		   BEGIN INITIAL;
d153 2
a154 7
<IN_STRING>{GRAPHIC}*"[\""{HEXDIG}{2}"\"]" {
		   int n;
		   resize_tempbuf (yyleng-5+tempbuf_len+1);
		   strncpy (tempbuf+tempbuf_len, yytext, yyleng-6);
		   sscanf(yytext+yyleng-4, "%2x", &n);
		   tempbuf[yyleng-6+tempbuf_len] = (char) n;
		   tempbuf_len += yyleng-5;
a156 7
<IN_STRING>{GRAPHIC}*"[\"\"\"]" {
		   int n;
		   resize_tempbuf (yyleng-4+tempbuf_len+1);
		   strncpy (tempbuf+tempbuf_len, yytext, yyleng-6);
		   tempbuf[yyleng-5+tempbuf_len] = '"';
		   tempbuf_len += yyleng-4;
		}
d176 1
d226 1
a226 1
	 	  processId (yytext+1, yyleng-1);
a231 2
		  int token_type, segments, k;
		  int quote_follows;
d235 2
a236 4
		      quote_follows = 1;
		      do {
			yyless (yyleng-1);
		      } while (yytext[yyleng-1] == ' ');
d238 5
a242 2
		  else
		    quote_follows = 0;
a243 21
                  if (all_posn >= 0)
		    yyless (all_posn);
                  processId(yytext, yyleng);
                  segments = name_lookup (ada_encode (yylval.ssym.stoken.ptr),
		                          yylval.ssym.stoken.ptr, 
                                          &token_type,
					  MAX_RENAMING_CHAIN_LENGTH);
		  left_block_context = NULL;
		  for (k = yyleng; segments > 0 && k > 0; k -= 1)
                    {
		      if (yytext[k-1] == '.')
			segments -= 1;
		      quote_follows = 0;
		    }
		  if (k <= 0)
		    error ("confused by name %s", yytext);
		  yyless (k);
		  if (quote_follows)
		    BEGIN BEFORE_QUAL_QUOTE;
		  return token_type;
                }
a246 1

d248 3
a250 3
                  processId(yytext, yyleng-2);
                  block_lookup (yylval.ssym.stoken.ptr, yylval.ssym.stoken.ptr);
                  return BLOCKNAME;
d253 1
a253 6
{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*{WHITE}*::  {
                  processId(yytext, yyleng-2);
                  block_lookup (ada_encode (yylval.ssym.stoken.ptr),
                                yylval.ssym.stoken.ptr);
                  return BLOCKNAME;
		}
d273 2
a274 1
/* Initialize the lexer for processing new expression */
a282 12
/* Make sure that tempbuf points at an array at least N characters long.  */

static void
resize_tempbuf (unsigned int n)
{
  if (tempbufsize < n)
    {
      tempbufsize = (n+63) & ~63;
      tempbuf = xrealloc (tempbuf, tempbufsize);
    }
}

d325 1
a360 2


d365 2
a366 1
   to "10", and EXP to "1".  The EXP does not contain a leading 'e' or 'E'.  */
d465 16
a480 1
static int
d485 1
d507 1
a507 2
	  i0 += 1;
	  while (i0 < len && name0[i0] != '\'')
d512 1
d528 43
a570 4
  yylval.ssym.sym = NULL;
  yylval.ssym.stoken.ptr = name;
  yylval.ssym.stoken.length = i;
  return NAME;
d573 6
a578 13
static void
block_lookup (char *name, char *err_name)
{
  struct ada_symbol_info *syms;
  int nsyms;
  struct symtab *symtab;
  nsyms = ada_lookup_symbol_list (name, left_block_context,
				  VAR_DOMAIN, &syms);
  if (left_block_context == NULL &&
      (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK))
    symtab = lookup_symtab (name);
  else
    symtab = NULL;
a579 233
  if (symtab != NULL)
    left_block_context = yylval.bval =
      BLOCKVECTOR_BLOCK (BLOCKVECTOR (symtab), STATIC_BLOCK);
  else if (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK)
    {
      if (left_block_context == NULL)
	error ("No file or function \"%s\".", err_name);
      else
	error ("No function \"%s\" in specified context.", err_name);
    }
  else
    {
      left_block_context = yylval.bval = SYMBOL_BLOCK_VALUE (syms[0].sym);
      if (nsyms > 1)
	warning ("Function name \"%s\" ambiguous here", err_name);
    }
}

/* Look up NAME0 (assumed to be encoded) as a name in VAR_DOMAIN,
   setting *TOKEN_TYPE to NAME or TYPENAME, depending on what is
   found.  Try first the entire name, then the name without the last
   segment (i.e., after the last .id), etc., and return the number of
   segments that had to be removed to get a match.  Try only the full
   name if it starts with "standard__".  Calls error if no
   matches are found, using ERR_NAME in any error message.  When
   exactly one symbol match is found, it is placed in yylval.  When
   the symbol is a renaming, follow at most DEPTH steps to find the  
   ultimate definition; cause error if depth exceeded.  */

static int
name_lookup (char *name0, char *err_name, int *token_type, int depth)
{
  struct ada_symbol_info *syms;
  struct type *type;
  int len0 = strlen (name0);
  char *name = obsavestring (name0, len0, &temp_parse_space);
  int nsyms;
  int segments;

  if (depth <= 0)
    error ("Could not find renamed symbol \"%s\"", err_name);

  yylval.ssym.stoken.ptr = name;
  yylval.ssym.stoken.length = strlen (name);
  for (segments = 0; ; segments += 1)
    {
      struct type *preferred_type;
      int i, preferred_index;

      if (left_block_context == NULL)
	nsyms = ada_lookup_symbol_list (name, expression_context_block,
					VAR_DOMAIN, &syms);
      else
	nsyms = ada_lookup_symbol_list (name, left_block_context,
					VAR_DOMAIN, &syms);


      /* Check for a type renaming.  */

      if (nsyms == 1 && !ada_is_object_renaming (syms[0].sym))
        {
          struct symbol *renaming_sym =
            ada_find_renaming_symbol (SYMBOL_LINKAGE_NAME (syms[0].sym), 
				      syms[0].block);

          if (renaming_sym != NULL)
            syms[0].sym = renaming_sym;
        }

      /* Check for a type definition.  */

      /* Look for a symbol that doesn't denote void.  This is (I think) a */
      /* temporary kludge to get around problems in GNAT output.  */
      preferred_index = -1; preferred_type = NULL;
      for (i = 0; i < nsyms; i += 1)
	switch (SYMBOL_CLASS (syms[i].sym))
	  {
	  case LOC_TYPEDEF:
	    if (ada_prefer_type (SYMBOL_TYPE (syms[i].sym), preferred_type))
	      {
		preferred_index = i;
		preferred_type = SYMBOL_TYPE (syms[i].sym);
	      }
	    break;
	  case LOC_REGISTER:
	  case LOC_ARG:
	  case LOC_REF_ARG:
	  case LOC_REGPARM:
	  case LOC_REGPARM_ADDR:
	  case LOC_LOCAL:
	  case LOC_LOCAL_ARG:
	  case LOC_BASEREG:
	  case LOC_BASEREG_ARG:
          case LOC_COMPUTED:
          case LOC_COMPUTED_ARG:
	    goto NotType;
	  default:
	    break;
	  }
      if (preferred_type != NULL)
	{
	  if (TYPE_CODE (preferred_type) == TYPE_CODE_VOID)
	    error ("`%s' matches only void type name(s)",
		   ada_decode (name));
	  else if (ada_is_object_renaming (syms[preferred_index].sym))
	    {
	      yylval.ssym.sym = syms[preferred_index].sym;
	      *token_type = OBJECT_RENAMING;
	      return segments;
	    }
	  else if (ada_renaming_type (SYMBOL_TYPE (syms[preferred_index].sym))
                   != NULL)
	    {
	      int result;
	      char *renaming
		= ada_simple_renamed_entity (syms[preferred_index].sym);
	      char *new_name
                = (char *) obstack_alloc (&temp_parse_space,
                                          strlen (renaming) + len0
				          - yylval.ssym.stoken.length + 1);
	      strcpy (new_name, renaming);
              xfree (renaming);
	      strcat (new_name, name0 + yylval.ssym.stoken.length);
	      result = name_lookup (new_name, err_name, token_type, depth - 1);
	      if (result > segments)
		error ("Confused by renamed symbol.");
	      return result;
	    }
	  else if (segments == 0)
	    {
	      yylval.tval = preferred_type;
	      *token_type = TYPENAME;
	      return 0;
	    }
	}

      if (segments == 0)
	{
	  type = language_lookup_primitive_type_by_name (current_language,
                                                         current_gdbarch,
                                                         name);
	  if (type == NULL && strcmp ("system__address", name) == 0)
	    type = type_system_address ();
	  if (type != NULL)
	    {
	      /* First check to see if we have a regular definition of this
		 type that just didn't happen to have been read yet.  */
	      int ntypes;
	      struct symbol *sym;
	      char *expanded_name = 
		(char *) alloca (strlen (name) + sizeof ("standard__"));
	      strcpy (expanded_name, "standard__");
	      strcat (expanded_name, name);
	      sym = ada_lookup_symbol (expanded_name, NULL,
				       VAR_DOMAIN, NULL, NULL);
	      if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
		type = SYMBOL_TYPE (sym);
					  
	      yylval.tval = type;
	      *token_type = TYPENAME;
	      return 0;
	    }
	}

    NotType:
      if (nsyms == 1)
	{
	  *token_type = NAME;
	  yylval.ssym.sym = syms[0].sym;
	  yylval.ssym.msym = NULL;
	  yylval.ssym.block = syms[0].block;
	  return segments;
	}
      else if (nsyms == 0) {
	int i;
	yylval.ssym.msym = ada_lookup_simple_minsym (name);
	if (yylval.ssym.msym != NULL)
	  {
	    yylval.ssym.sym = NULL;
	    yylval.ssym.block = NULL;
            *token_type = NAME;
	    return segments;
	  }

	if (segments == 0 
	    && strncmp (name, "standard__", sizeof ("standard__") - 1) == 0)
	  error ("No definition of \"%s\" found.", err_name);

	for (i = yylval.ssym.stoken.length - 1; i > 0; i -= 1)
	  {
            if (name[i] == '.')
	      {
		name[i] = '\0';
		yylval.ssym.stoken.length = i;
		break;
	      }
	    else if (name[i] == '_' && name[i-1] == '_')
	      {
		i -= 1;
		name[i] = '\0';
		yylval.ssym.stoken.length = i;
		break;
	      }
	  }
	if (i <= 0)
	  {
	    if (!have_full_symbols () && !have_partial_symbols ()
		&& left_block_context == NULL)
	      error ("No symbol table is loaded.  Use the \"file\" command.");
	    if (left_block_context == NULL)
	      error ("No definition of \"%s\" in current context.",
		     err_name);
	    else
	      error ("No definition of \"%s\" in specified context.",
		     err_name);
	  }
      }
      else
	{
	  *token_type = NAME;
	  yylval.ssym.sym = NULL;
	  yylval.ssym.msym = NULL;
	  if (left_block_context == NULL)
	    yylval.ssym.block = expression_context_block;
	  else
	    yylval.ssym.block = left_block_context;
	  return segments;
	}
    }
}

/* Returns the position within STR of the '.' in a
   '.{WHITE}*all' component of a dotted name, or -1 if there is none.  */
d592 1
a592 1
	  if (strcmp (str+i, "all") == 0
@


1.11
log
@2004-10-15  Andrew Cagney  <cagney@@gnu.org>

	* ada-exp.y, ada-lex.l: Use xmalloc and xrealloc through out.
	* inf-ptrace.c: Include "gdb_wait.h" instead of <wait.h>.
	* Makefile.in (.y.c, .l.c): Don't replace xmalloc with xxmalloc.
	Update dependencies.
@
text
@d19 2
a20 1
Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
@


1.10
log
@ada-lex.l: Remove useless rule whose right-context clause
causes unreferenced static function warning for yyrealloc.
(ada_flex_use): Remove the artificial reference to yyrealloc.
@
text
@d348 1
a348 1
      tempbuf = (char *) realloc (tempbuf, tempbufsize);
@


1.9
log
@2004-10-06  Paul N. Hilfinger  <Hilfinger@@gnat.com>

* Makefile.in (.l.c): Do conversions of names of alloc and free
functions that are done for .y.c files, plus special one
for yy_flex_realloc.  Also, correct missing-file tests here.
* ada-lex.l (malloc, free): Remove macros.
(resize_tempbuf): Use "realloc"; rely on sed changes to convert to
xrealloc.
(ada_flex_use): Dummy definition to remove warnings about unused
functions.
* ada-exp.y (dummy_string_to_ada_operator): Temporary definition
to suppress warning.
@
text
@a156 2
\"{OPER}\"/{WHITE}*"(" { return processId (yytext, yyleng); }

d927 1
a927 1
  (dummy_function) yyrealloc, (dummy_function) yyunput
@


1.8
log
@* Makefile.in (.l.c): Modify rule for compatibility with recent
versions of flex, and remove most command-line options.
* ada-lex.l: Add %options line in place of -I -i and -s command-line
options.
@
text
@a44 2
#define malloc xmalloc
#define free xfree
d350 1
a350 1
      tempbuf = (char *) xrealloc (tempbuf, tempbufsize);
d924 7
@


1.7
log
@* ada-exp.y (type_int): New function to add layer of abstraction
around references to expression types.
(type_long): Ditto.
(type_long_long): Ditto.
(type_float): Ditto.
(type_double): Ditto.
(type_long_double): Ditto.
(type_char): Ditto.
(type_system_address): Ditto.
(simple_exp): Use type_* functions in place of builtin_*
variables.
(exp): Ditto.
(write_var_from_name): Ditto.
(write_object_renaming): Ditto.
* ada-lang.c (ada_create_fundamental_type): Remove redundant
declaration.
(build_ada_types): Remove, replacing with...
(ada_language_arch_info): New function to initialize primitive
type vector in language_arch_info.
(ada_array_length): Remove use of builtin_type_ada_int.
(value_pos_atr): Ditto.
(ada_evaluate_subexp): Ditto.
(builtin_type_ada_int, builtin_type_ada_short, builtin_type_ada_long,
builtin_type_ada_long_long, builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
(ada_builtin_types): Remove.
(ada_language_defn): Remove entries for la_builtin_type_vector and
string_char_type and use ada_language_arch_info.
(_initialize_ada_language): Do type-vector initialization along
the lines of c-lang.c.
(ada_create_fundamental_type): Break up line.
(ada_dump_symtab): Remove unused function.
(enum ada_primitive_types): Define.
* ada-lang.h (builtin_type_ada_int, builtin_type_ada_short,
builtin_type_ada_long,builtin_type_ada_long_long,builtin_type_ada_char,
builtin_type_ada_float, builtin_type_ada_double,
builtin_type_ada_long_double, builtin_type_ada_natural,
builtin_type_ada_positive, builtin_type_ada_system_address): Remove.
* ada-lex.l: Use type_* functions in place of builtin_* variables.
(processInt): Ditto.
(processReal): Ditto.
(name_lookup): Ditto.
* ada-typeprint.c (print_range): Use builtin_type_int, not
builtin_type_ada_int.
@
text
@a28 3
/* Run flex with (at least) the -i option (case-insensitive), and the -I */
/* option (interactive---no unnecessary lookahead).  */

d89 2
@


1.6
log
@2004-07-28  Andrew Cagney  <cagney@@gnu.org>

	* gdbtypes.c (lookup_primitive_typename): Delete function.
	* gdbtypes.h (lookup_primitive_typename): Delete declaration.
	* ada-lex.l: Use language_lookup_primitive_type_by_name.
	* gdbtypes.c (lookup_typename): Ditto.
	* f-exp.y (yylex): Ditto.
	* c-exp.y (yylex): Ditto, eliminate assignment in "if".
@
text
@d147 1
a147 1
		   yylval.typed_val.type = builtin_type_ada_char;
d154 1
a154 1
                   yylval.typed_val.type = builtin_type_ada_char;
d481 1
a481 1
    yylval.typed_val.type = builtin_type_ada_int;
d483 1
a483 1
    yylval.typed_val.type = builtin_type_ada_long;
d503 1
a503 1
    yylval.typed_val.type = builtin_type_ada_long_long;
d530 1
a530 1
  yylval.typed_val_float.type = builtin_type_ada_float;
d532 1
a532 1
    yylval.typed_val_float.type = builtin_type_ada_double;
d534 1
a534 1
    yylval.typed_val_float.type = builtin_type_ada_long_double;
d748 1
a748 1
	    type = builtin_type_ada_system_address;
@


1.5
log
@Address complaints from gdb_ari.sh:

* ada-exp.y: Include gdb_string.h rather than string.h.
(convert_char_literal): Reformat declaration.
* ada-lang.h: Include opaque struct declaration for struct frame_info.
* ada-lex.l: Change use of free to xfree (the macro would do so
anyway, but this is harmless).
Include gdb_string.h rather than string.h.
* ada-valprint.c (ada_val_print_stub): Change PTR => void*.

* ada-lang.c (parse): Remove K&Rism in parameter list.
(is_name_suffix): Correct Linux => GNU/Linux in comment.
@
text
@d744 3
a746 1
	  type = lookup_primitive_typename (name);
@


1.4
log
@ada-exp.y: Synchronize with current ACT sources.
ada-lang.c: Ditto.
ada-lang.h: Ditto.
ada-lex.l: Ditto.
ada-tasks.c: Ditto.
ada-typeprint.c: Ditto.
ada-valprint.c: Ditto.
@
text
@d334 1
a334 1
#include <string.h>
d727 1
a727 1
              free (renaming);
@


1.3
log
@2003-11-23  Andrew Cagney  <cagney@@redhat.com>

	* symfile.c (symbol_file_command): Replace STREQ with strcmp.
	* defs.h (DEPRECATED_STREQN): Rename STREQN.
	(DEPRECATED_STREQ): Rename STREQ.
	* ada-exp.y, ada-lang.c, ada-lex.l, coffread.c: Update.
	* config/mips/tm-irix5.h, config/mips/tm-irix6.h: Update.
	* config/mips/tm-mipsv4.h, config/sparc/tm-sun4sol2.h: Update.
	* dbxread.c, dwarf2read.c, dwarfread.c, environ.c: Update.
	* eval.c, exec.c, f-lang.c, hppa-tdep.c, hpread.c: Update.
	* jv-exp.y, language.c, m2-exp.y, mcore-rom.c: Update.
	* mdebugread.c, mipsread.c, objc-exp.y, objfiles.c: Update.
	* p-exp.y, p-typeprint.c, p-valprint.c, rs6000-nat.c: Update.
	* source.c, sparc-tdep.c, stack.c, target.c: Update.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1997, 2000
d48 3
d54 8
a61 8
/* Temporary staging for numeric literals. */
static char numbuf[NUMERAL_WIDTH]; 
 static void canonicalizeNumeral (char* s1, const char*);
static int processInt (const char*, const char*, const char*);
static int processReal (const char*);
static int processId (const char*, int);
static int processAttribute (const char*);
static int find_dot_all (const char*);
d64 1
a64 1
#define YY_DECL static int yylex ( void ) 
d80 1
a80 1
static struct block* left_block_context;
d84 1
a84 1
static void block_lookup (char*, char*);
d86 1
a86 1
static int name_lookup (char*, char*, int*);
d88 1
a88 1
static int find_dot_all (const char*);
d100 2
a101 2
{NUM10}{POSEXP}  { 
		   canonicalizeNumeral (numbuf, yytext); 
d105 2
a106 2
{NUM10}          { 
		   canonicalizeNumeral (numbuf, yytext); 
d113 1
a113 1
				      strchr (numbuf, '#') + 1, 
d129 1
a129 1
		   canonicalizeNumeral (numbuf, yytext); 
d134 1
a134 1
		   canonicalizeNumeral (numbuf, yytext); 
d162 1
a162 1
<INITIAL>\"	{ 
d194 4
a197 4
if		{ 
		  while (*lexptr != 'i' && *lexptr != 'I') 
		    lexptr -= 1; 
		  yyrestart(NULL); 
d240 1
a240 1
		  else 
d245 1
a245 1
")"		{ if (paren_depth == 0) 
d251 1
a251 1
		  else 
d253 1
a253 1
		      paren_depth -= 1; 
d260 1
a260 1
"."{WHITE}*{ID} { 
d262 1
a262 1
	          return DOT_ID; 
d265 1
a265 1
{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*(" "*"'")?  { 
d270 1
a270 1
                  if (all_posn == -1 && yytext[yyleng-1] == '\'') 
d273 2
a274 2
		      do { 
			yyless (yyleng-1); 
d278 2
a279 2
		    quote_follows = 0;			
		    
d283 4
a286 2
                  segments = name_lookup (ada_mangle (yylval.ssym.stoken.ptr),
		                          yylval.ssym.stoken.ptr, &token_type);
d297 1
a297 1
		  if (quote_follows) 
d311 1
a311 1
{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*{WHITE}*::  { 
d313 1
a313 1
                  block_lookup (ada_mangle (yylval.ssym.stoken.ptr),
a319 6
"$$"		{ yylval.lval = -1; return LAST; }
"$$"{DIG}+	{ yylval.lval = -atoi(yytext+2); return LAST; }
"$"		{ yylval.lval = 0; return LAST; }
"$"{DIG}+	{ yylval.lval = atoi(yytext+1); return LAST; }


d322 1
a322 9
"$"({LETTER}|{DIG}|"$")+  {
    		  int c;
		  for (c = 0; c < NUM_REGS; c++)
		    if (REGISTER_NAME (c) &&
                        strcmp (yytext + 1, REGISTER_NAME (c)) == 0)
		      {
			yylval.lval = c;
			return REGNAME;
		      }
d325 1
a325 3
		  yylval.ivar = 
		    lookup_internalvar (copy_name (yylval.sval) + 1);
		  return INTERNAL_VARIABLE;
d338 1
a338 1
lexer_init (FILE* inp)
d345 1
a345 1
/* Make sure that tempbuf points at an array at least N characters long. */
d348 1
a348 2
resize_tempbuf (n)
     unsigned int n;
d353 1
a353 1
      tempbuf = (char*) xrealloc (tempbuf, tempbufsize);
d356 2
a357 2
 
/* Copy S2 to S1, removing all underscores, and downcasing all letters. */
d360 1
a360 3
canonicalizeNumeral (s1,s2)
     char* s1;
     const char* s2;
d362 1
a362 1
  for (; *s2 != '\000'; s2 += 1) 
d375 1
a375 1
/* True (non-zero) iff DIGIT is a valid digit in radix BASE, 
d379 1
a379 3
is_digit_in_base (digit, base)
     unsigned char digit;
     int base;
d385 1
a385 1
  else 
d390 1
a390 2
digit_to_int (c)
     unsigned char c;
d398 1
a398 1
/* As for strtoul, but for ULONGEST results. */
d400 1
a400 4
strtoulst (num, trailer, base)
     const char *num;
     const char **trailer;
     int base;
d420 1
a420 1
      if (high_part > 0xff) 
d439 2
a440 2
   an error if the number is improperly formated.   BASE, if NULL, defaults 
   to "10", and EXP to "1". The EXP does not contain a leading 'e' or 'E'. */
d443 1
a443 4
processInt (base0, num0, exp0)
     const char* num0;
     const char* base0;
     const char* exp0;
d449 1
a449 1
  char* trailer;
d454 2
a455 2
    {	
      base = strtol (base0, (char**) NULL, 10);
d463 1
a463 1
    exp = strtol(exp0, (char**) NULL, 10);
d466 1
a466 1
  result = strtoulst (num0, &trailer, base);
d472 1
a472 1
  while (exp > 0) 
d479 1
a479 1
    
d487 1
a487 1
         For consistency with the C treatment, we will treat it as an 
d489 1
a489 1
	 that we need to store .val as a signed quantity.  Sorry 
d495 2
a496 2
	yylval.typed_val.val = 
	  (LONGEST) (result & ~LONGEST_SIGN) 
d502 1
a502 1
  else 
d509 7
d517 1
a517 2
processReal (num0)
     const char* num0;
d519 3
a521 4
  if (sizeof (DOUBLEST) <= sizeof (float))
    sscanf (num0, "%g", &yylval.typed_val_float.dval);
  else if (sizeof (DOUBLEST) <= sizeof (double))
    sscanf (num0, "%lg", &yylval.typed_val_float.dval);
d523 1
a524 6
#ifdef PRINTF_HAS_LONG_DOUBLE
      sscanf (num0, "%Lg", &yylval.typed_val_float.dval);
#else
      /* Scan it into a double, then convert and assign it to the 
	 long double.  This at least wins with values representable 
	 in the range of doubles. */
a527 1
#endif
d540 1
a540 3
processId (name0, len)
     const char *name0;
     int len;
d542 1
a542 1
  char* name = xmalloc (len + 11);
d544 1
a544 3
  
/*  add_name_string_cleanup (name); */
/* FIXME: add_name_string_cleanup should be defined in parse.c */
d548 1
a548 1
  while (i0 < len) 
d555 1
a555 1
      else switch (name0[i0]) 
d592 2
a593 4
static void 
block_lookup (name, err_name)
     char* name;
     char* err_name;
d595 1
a595 2
  struct symbol** syms;
  struct block** blocks;
d599 1
a599 1
				  VAR_DOMAIN, &syms, &blocks);
d601 1
a601 1
      (nsyms == 0 || SYMBOL_CLASS (syms[0]) != LOC_BLOCK))
d609 1
a609 1
  else if (nsyms == 0 || SYMBOL_CLASS (syms[0]) != LOC_BLOCK)
d616 1
a616 1
  else 
d618 1
a618 1
      left_block_context = yylval.bval = SYMBOL_BLOCK_VALUE (syms[0]); 
d624 1
a624 1
/* Look up NAME0 (assumed to be mangled) as a name in VAR_DOMAIN,
d626 1
a626 1
   found.  Try first the entire name, then the name without the last 
d628 2
a629 1
   segments that had to be removed to get a match.  Calls error if no
d631 4
a634 2
   exactly one symbol match is found, it is placed in yylval. */
 
d636 4
a639 8
name_lookup (name0, err_name, token_type)
     char* name0;
     char* err_name;
     int* token_type;
{
  struct symbol** syms;
  struct block** blocks;
  struct type* type;
d641 1
a641 1
  char* name = savestring (name0, len0);
d644 4
a647 3
 
/*  add_name_string_cleanup (name);*/
/* FIXME: add_name_string_cleanup should be defined in parse.c */
d652 1
a652 1
      struct type* preferred_type;
d655 3
a657 3
      if (left_block_context == NULL) 
	nsyms = ada_lookup_symbol_list (name, expression_context_block, 
					VAR_DOMAIN, &syms, &blocks);
d659 3
a661 2
	nsyms = ada_lookup_symbol_list (name, left_block_context, 
					VAR_DOMAIN, &syms, &blocks);
d663 13
a675 1
      /* Check for a type definition. */
d678 1
a678 1
      /* temporary kludge to get around problems in GNAT output. */
d681 1
a681 1
	switch (SYMBOL_CLASS (syms[i])) 
d684 1
a684 1
	    if (ada_prefer_type (SYMBOL_TYPE (syms[i]), preferred_type))
d687 1
a687 1
		preferred_type = SYMBOL_TYPE (syms[i]);
d699 2
d707 4
a710 6
/*	  if (TYPE_CODE (preferred_type) == TYPE_CODE_VOID)
	    error ("`%s' matches only void type name(s)", 
		   ada_demangle (name));
*/
/* FIXME: ada_demangle should be defined in defs.h, and is located in ada-lang.c */
/*	  else*/ if (ada_is_object_renaming (syms[preferred_index]))
d712 1
a712 1
	      yylval.ssym.sym = syms[preferred_index];
d715 2
a716 2
	    } 
	  else if (ada_renaming_type (SYMBOL_TYPE (syms[preferred_index])) 
d720 6
a725 6
	      const char* renaming = 
		ada_simple_renamed_entity (syms[preferred_index]);
	      char* new_name = xmalloc (strlen (renaming) + len0 
					- yylval.ssym.stoken.length + 1);
/*	      add_name_string_cleanup (new_name);*/
/* FIXME: add_name_string_cleanup should be defined in parse.c */
d727 1
d729 2
a730 2
	      result = name_lookup (new_name, err_name, token_type);
	      if (result > segments) 
d739 1
a739 1
	    } 
d745 1
a745 1
	  if (type == NULL && DEPRECATED_STREQ ("system__address", name))
d749 13
d769 1
a769 1
      if (nsyms == 1) 
d772 1
a772 1
	  yylval.ssym.sym = syms[0];
d774 1
a774 1
	  yylval.ssym.block = blocks[0];
d779 1
a779 1
	yylval.ssym.msym = ada_lookup_minimal_symbol (name);
d788 4
d795 1
a795 1
	      { 
d808 1
a808 1
	if (i <= 0) 
d814 1
a814 1
	      error ("No definition of \"%s\" in current context.", 
d817 1
a817 1
	      error ("No definition of \"%s\" in specified context.", 
d821 1
a821 1
      else 
d836 1
a836 1
   '.{WHITE}*all' component of a dotted name, or -1 if there is none. */
d838 1
a838 2
find_dot_all (str)
     const char* str;
d846 1
a846 1
	  do 
d855 1
a855 1
}    
d858 1
a858 1
   case. */
d861 1
a861 3
subseqMatch (subseq, str)
     const char* subseq;
     const char* str;
a871 1
  
d873 2
a874 1
static struct { const char* name; int code; } 
d898 1
a898 2
processAttribute (str)
     const char* str;
d907 1
a907 1
    if (subseqMatch (str, attributes[i].name)) 
d911 1
a911 1
	else 
d921 1
a921 1
yywrap()
@


1.3.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright (C) 1994, 1997, 1998, 2000, 2001, 2002, 2003
a47 3
#define malloc xmalloc
#define free xfree

d51 8
a58 8
/* Temporary staging for numeric literals.  */
static char numbuf[NUMERAL_WIDTH];
 static void canonicalizeNumeral (char *s1, const char *);
static int processInt (const char *, const char *, const char *);
static int processReal (const char *);
static int processId (const char *, int);
static int processAttribute (const char *);
static int find_dot_all (const char *);
d61 1
a61 1
#define YY_DECL static int yylex ( void )
d77 1
a77 1
static struct block *left_block_context;
d81 1
a81 1
static void block_lookup (char *, char *);
d83 1
a83 1
static int name_lookup (char *, char *, int *, int);
d85 1
a85 1
static int find_dot_all (const char *);
d97 2
a98 2
{NUM10}{POSEXP}  {
		   canonicalizeNumeral (numbuf, yytext);
d102 2
a103 2
{NUM10}          {
		   canonicalizeNumeral (numbuf, yytext);
d110 1
a110 1
				      strchr (numbuf, '#') + 1,
d126 1
a126 1
		   canonicalizeNumeral (numbuf, yytext);
d131 1
a131 1
		   canonicalizeNumeral (numbuf, yytext);
d159 1
a159 1
<INITIAL>\"	{
d191 4
a194 4
if		{
		  while (*lexptr != 'i' && *lexptr != 'I')
		    lexptr -= 1;
		  yyrestart(NULL);
d237 1
a237 1
		  else
d242 1
a242 1
")"		{ if (paren_depth == 0)
d248 1
a248 1
		  else
d250 1
a250 1
		      paren_depth -= 1;
d257 1
a257 1
"."{WHITE}*{ID} {
d259 1
a259 1
	          return DOT_ID;
d262 1
a262 1
{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*(" "*"'")?  {
d267 1
a267 1
                  if (all_posn == -1 && yytext[yyleng-1] == '\'')
d270 2
a271 2
		      do {
			yyless (yyleng-1);
d275 2
a276 2
		    quote_follows = 0;

d280 2
a281 4
                  segments = name_lookup (ada_encode (yylval.ssym.stoken.ptr),
		                          yylval.ssym.stoken.ptr, 
                                          &token_type,
					  MAX_RENAMING_CHAIN_LENGTH);
d292 1
a292 1
		  if (quote_follows)
d306 1
a306 1
{ID}({WHITE}*"."{WHITE}*({ID}|\"{OPER}\"))*{WHITE}*::  {
d308 1
a308 1
                  block_lookup (ada_encode (yylval.ssym.stoken.ptr),
d315 6
d323 9
a331 1
"$"({LETTER}|{DIG}|"$")*  {
d334 3
a336 1
		  return SPECIAL_VARIABLE;
d345 1
a345 1
#include "gdb_string.h"
d349 1
a349 1
lexer_init (FILE *inp)
d356 1
a356 1
/* Make sure that tempbuf points at an array at least N characters long.  */
d359 2
a360 1
resize_tempbuf (unsigned int n)
d365 1
a365 1
      tempbuf = (char *) xrealloc (tempbuf, tempbufsize);
d368 2
a369 2

/* Copy S2 to S1, removing all underscores, and downcasing all letters.  */
d372 3
a374 1
canonicalizeNumeral (char *s1, const char *s2)
d376 1
a376 1
  for (; *s2 != '\000'; s2 += 1)
d389 1
a389 1
/* True (non-zero) iff DIGIT is a valid digit in radix BASE,
d393 3
a395 1
is_digit_in_base (unsigned char digit, int base)
d401 1
a401 1
  else
d406 2
a407 1
digit_to_int (unsigned char c)
d415 1
a415 1
/* As for strtoul, but for ULONGEST results.  */
d417 4
a420 1
strtoulst (const char *num, const char **trailer, int base)
d440 1
a440 1
      if (high_part > 0xff)
d459 2
a460 2
   an error if the number is improperly formated.   BASE, if NULL, defaults
   to "10", and EXP to "1".  The EXP does not contain a leading 'e' or 'E'.  */
d463 4
a466 1
processInt (const char *base0, const char *num0, const char *exp0)
d472 1
a472 1
  char *trailer;
d477 2
a478 2
    {
      base = strtol (base0, (char **) NULL, 10);
d486 1
a486 1
    exp = strtol(exp0, (char **) NULL, 10);
d489 1
a489 1
  result = strtoulst (num0, (const char **) &trailer, base);
d495 1
a495 1
  while (exp > 0)
d502 1
a502 1

d510 1
a510 1
         For consistency with the C treatment, we will treat it as an
d512 1
a512 1
	 that we need to store .val as a signed quantity.  Sorry
d518 2
a519 2
	yylval.typed_val.val =
	  (LONGEST) (result & ~LONGEST_SIGN)
d525 1
a525 1
  else
a531 7
#if defined (PRINTF_HAS_LONG_DOUBLE)
#  undef PRINTF_HAS_LONG_DOUBLE
#  define PRINTF_HAS_LONG_DOUBLE 1
#else
#  define PRINTF_HAS_LONG_DOUBLE 0
#endif

d533 2
a534 1
processReal (const char *num0)
d536 4
a539 3
#if defined (PRINTF_HAS_LONG_DOUBLE)
  if (sizeof (DOUBLEST) > sizeof (double))
    sscanf (num0, "%Lg", &yylval.typed_val_float.dval);
a540 1
#endif
d542 6
d551 1
d564 3
a566 1
processId (const char *name0, int len)
d568 1
a568 1
  char *name = obstack_alloc (&temp_parse_space, len + 11);
d570 3
a572 1

d576 1
a576 1
  while (i0 < len)
d583 1
a583 1
      else switch (name0[i0])
d620 4
a623 2
static void
block_lookup (char *name, char *err_name)
d625 2
a626 1
  struct ada_symbol_info *syms;
d630 1
a630 1
				  VAR_DOMAIN, &syms);
d632 1
a632 1
      (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK))
d640 1
a640 1
  else if (nsyms == 0 || SYMBOL_CLASS (syms[0].sym) != LOC_BLOCK)
d647 1
a647 1
  else
d649 1
a649 1
      left_block_context = yylval.bval = SYMBOL_BLOCK_VALUE (syms[0].sym);
d655 1
a655 1
/* Look up NAME0 (assumed to be encoded) as a name in VAR_DOMAIN,
d657 1
a657 1
   found.  Try first the entire name, then the name without the last
d659 1
a659 2
   segments that had to be removed to get a match.  Try only the full
   name if it starts with "standard__".  Calls error if no
d661 2
a662 4
   exactly one symbol match is found, it is placed in yylval.  When
   the symbol is a renaming, follow at most DEPTH steps to find the  
   ultimate definition; cause error if depth exceeded.  */

d664 8
a671 4
name_lookup (char *name0, char *err_name, int *token_type, int depth)
{
  struct ada_symbol_info *syms;
  struct type *type;
d673 1
a673 1
  char *name = obsavestring (name0, len0, &temp_parse_space);
d676 3
a678 4

  if (depth <= 0)
    error ("Could not find renamed symbol \"%s\"", err_name);

d683 1
a683 1
      struct type *preferred_type;
d686 3
a688 3
      if (left_block_context == NULL)
	nsyms = ada_lookup_symbol_list (name, expression_context_block,
					VAR_DOMAIN, &syms);
d690 2
a691 3
	nsyms = ada_lookup_symbol_list (name, left_block_context,
					VAR_DOMAIN, &syms);

d693 1
a693 13
      /* Check for a type renaming.  */

      if (nsyms == 1 && !ada_is_object_renaming (syms[0].sym))
        {
          struct symbol *renaming_sym =
            ada_find_renaming_symbol (SYMBOL_LINKAGE_NAME (syms[0].sym), 
				      syms[0].block);

          if (renaming_sym != NULL)
            syms[0].sym = renaming_sym;
        }

      /* Check for a type definition.  */
d696 1
a696 1
      /* temporary kludge to get around problems in GNAT output.  */
d699 1
a699 1
	switch (SYMBOL_CLASS (syms[i].sym))
d702 1
a702 1
	    if (ada_prefer_type (SYMBOL_TYPE (syms[i].sym), preferred_type))
d705 1
a705 1
		preferred_type = SYMBOL_TYPE (syms[i].sym);
a716 2
          case LOC_COMPUTED:
          case LOC_COMPUTED_ARG:
d723 6
a728 4
	  if (TYPE_CODE (preferred_type) == TYPE_CODE_VOID)
	    error ("`%s' matches only void type name(s)",
		   ada_decode (name));
	  else if (ada_is_object_renaming (syms[preferred_index].sym))
d730 1
a730 1
	      yylval.ssym.sym = syms[preferred_index].sym;
d733 2
a734 2
	    }
	  else if (ada_renaming_type (SYMBOL_TYPE (syms[preferred_index].sym))
d738 6
a743 6
	      char *renaming
		= ada_simple_renamed_entity (syms[preferred_index].sym);
	      char *new_name
                = (char *) obstack_alloc (&temp_parse_space,
                                          strlen (renaming) + len0
				          - yylval.ssym.stoken.length + 1);
a744 1
              xfree (renaming);
d746 2
a747 2
	      result = name_lookup (new_name, err_name, token_type, depth - 1);
	      if (result > segments)
d756 1
a756 1
	    }
d761 2
a762 4
	  type = language_lookup_primitive_type_by_name (current_language,
                                                         current_gdbarch,
                                                         name);
	  if (type == NULL && strcmp ("system__address", name) == 0)
a765 13
	      /* First check to see if we have a regular definition of this
		 type that just didn't happen to have been read yet.  */
	      int ntypes;
	      struct symbol *sym;
	      char *expanded_name = 
		(char *) alloca (strlen (name) + sizeof ("standard__"));
	      strcpy (expanded_name, "standard__");
	      strcat (expanded_name, name);
	      sym = ada_lookup_symbol (expanded_name, NULL,
				       VAR_DOMAIN, NULL, NULL);
	      if (sym != NULL && SYMBOL_CLASS (sym) == LOC_TYPEDEF)
		type = SYMBOL_TYPE (sym);
					  
d773 1
a773 1
      if (nsyms == 1)
d776 1
a776 1
	  yylval.ssym.sym = syms[0].sym;
d778 1
a778 1
	  yylval.ssym.block = syms[0].block;
d783 1
a783 1
	yylval.ssym.msym = ada_lookup_simple_minsym (name);
a791 4
	if (segments == 0 
	    && strncmp (name, "standard__", sizeof ("standard__") - 1) == 0)
	  error ("No definition of \"%s\" found.", err_name);

d795 1
a795 1
	      {
d808 1
a808 1
	if (i <= 0)
d814 1
a814 1
	      error ("No definition of \"%s\" in current context.",
d817 1
a817 1
	      error ("No definition of \"%s\" in specified context.",
d821 1
a821 1
      else
d836 1
a836 1
   '.{WHITE}*all' component of a dotted name, or -1 if there is none.  */
d838 2
a839 1
find_dot_all (const char *str)
d847 1
a847 1
	  do
d856 1
a856 1
}
d859 1
a859 1
   case.  */
d862 3
a864 1
subseqMatch (const char *subseq, const char *str)
d875 1
d877 1
a877 2

static struct { const char *name; int code; }
d901 2
a902 1
processAttribute (const char *str)
d911 1
a911 1
    if (subseqMatch (str, attributes[i].name))
d915 1
a915 1
	else
d925 1
a925 1
yywrap(void)
@


1.3.6.2
log
@Merge from mainline.
@
text
@d147 1
a147 1
		   yylval.typed_val.type = type_char ();
d154 1
a154 1
                   yylval.typed_val.type = type_char ();
d481 1
a481 1
    yylval.typed_val.type = type_int ();
d483 1
a483 1
    yylval.typed_val.type = type_long ();
d503 1
a503 1
    yylval.typed_val.type = type_long_long ();
d530 1
a530 1
  yylval.typed_val_float.type = type_float ();
d532 1
a532 1
    yylval.typed_val_float.type = type_double ();
d534 1
a534 1
    yylval.typed_val_float.type = type_long_double ();
d748 1
a748 1
	    type = type_system_address ();
@


1.2
log
@	* ada-tasks.c (find_function_in_inferior): Don't declare it.
	("regcache.h"): Include it.
	* ada-lex.l (block_lookup): Replace VAR_NAMESPACE with VAR_DOMAIN.
@
text
@d762 1
a762 1
	  if (type == NULL && STREQ ("system__address", name))
@


1.1
log
@Add base ada language files
@
text
@d630 1
a630 1
				  VAR_NAMESPACE, &syms, &blocks);
d655 1
a655 1
/* Look up NAME0 (assumed to be mangled) as a name in VAR_NAMESPACE,
d688 1
a688 1
					VAR_NAMESPACE, &syms, &blocks);
d691 1
a691 1
					VAR_NAMESPACE, &syms, &blocks);
@


1.1.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d630 1
a630 1
				  VAR_DOMAIN, &syms, &blocks);
d655 1
a655 1
/* Look up NAME0 (assumed to be mangled) as a name in VAR_DOMAIN,
d688 1
a688 1
					VAR_DOMAIN, &syms, &blocks);
d691 1
a691 1
					VAR_DOMAIN, &syms, &blocks);
d762 1
a762 1
	  if (type == NULL && DEPRECATED_STREQ ("system__address", name))
@


1.1.12.1
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d630 1
a630 1
				  VAR_DOMAIN, &syms, &blocks);
d655 1
a655 1
/* Look up NAME0 (assumed to be mangled) as a name in VAR_DOMAIN,
d688 1
a688 1
					VAR_DOMAIN, &syms, &blocks);
d691 1
a691 1
					VAR_DOMAIN, &syms, &blocks);
@


1.1.12.2
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d762 1
a762 1
	  if (type == NULL && DEPRECATED_STREQ ("system__address", name))
@


1.1.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.1.2.1
log
@merge from trunk
@
text
@@

