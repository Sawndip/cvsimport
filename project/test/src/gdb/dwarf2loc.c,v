head	1.179;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.168
	gdb_7_6-2013-04-26-release:1.168
	gdb_7_6-branch:1.168.0.2
	gdb_7_6-2013-03-12-branchpoint:1.168
	gdb_7_5_1-2012-11-29-release:1.152
	gdb_7_5-2012-08-17-release:1.152
	gdb_7_5-branch:1.152.0.2
	gdb_7_5-2012-07-18-branchpoint:1.152
	gdb_7_4_1-2012-04-26-release:1.138.2.1
	gdb_7_4-2012-01-24-release:1.138.2.1
	gdb_7_4-branch:1.138.0.2
	gdb_7_4-2011-12-13-branchpoint:1.138
	gdb_7_3_1-2011-09-04-release:1.115
	gdb_7_3-2011-07-26-release:1.115
	gdb_7_3-branch:1.115.0.2
	gdb_7_3-2011-04-01-branchpoint:1.115
	gdb_7_2-2010-09-02-release:1.93.2.3
	gdb_7_2-branch:1.93.0.2
	gdb_7_2-2010-07-07-branchpoint:1.93
	gdb_7_1-2010-03-18-release:1.71.2.1
	gdb_7_1-branch:1.71.0.2
	gdb_7_1-2010-02-18-branchpoint:1.71
	gdb_7_0_1-2009-12-22-release:1.68
	gdb_7_0-2009-10-06-release:1.68
	gdb_7_0-branch:1.68.0.2
	gdb_7_0-2009-09-16-branchpoint:1.68
	arc-sim-20090309:1.48
	msnyder-checkpoint-072509-branch:1.62.0.2
	msnyder-checkpoint-072509-branchpoint:1.62
	arc-insight_6_8-branch:1.48.0.6
	arc-insight_6_8-branchpoint:1.48
	insight_6_8-branch:1.48.0.4
	insight_6_8-branchpoint:1.48
	reverse-20081226-branch:1.52.0.6
	reverse-20081226-branchpoint:1.52
	multiprocess-20081120-branch:1.52.0.4
	multiprocess-20081120-branchpoint:1.52
	reverse-20080930-branch:1.52.0.2
	reverse-20080930-branchpoint:1.52
	reverse-20080717-branch:1.51.0.4
	reverse-20080717-branchpoint:1.51
	msnyder-reverse-20080609-branch:1.51.0.2
	msnyder-reverse-20080609-branchpoint:1.51
	drow-reverse-20070409-branch:1.39.0.2
	drow-reverse-20070409-branchpoint:1.39
	gdb_6_8-2008-03-27-release:1.48
	gdb_6_8-branch:1.48.0.2
	gdb_6_8-2008-02-26-branchpoint:1.48
	gdb_6_7_1-2007-10-29-release:1.45
	gdb_6_7-2007-10-10-release:1.45
	gdb_6_7-branch:1.45.0.2
	gdb_6_7-2007-09-07-branchpoint:1.45
	insight_6_6-20070208-release:1.36.2.1
	gdb_6_6-2006-12-18-release:1.36.2.1
	gdb_6_6-branch:1.36.0.2
	gdb_6_6-2006-11-15-branchpoint:1.36
	insight_6_5-20061003-release:1.33
	gdb-csl-symbian-6_4_50_20060226-12:1.33
	gdb-csl-sourcerygxx-3_4_4-25:1.31
	nickrob-async-20060828-mergepoint:1.33
	gdb-csl-symbian-6_4_50_20060226-11:1.33
	gdb-csl-sourcerygxx-4_1-17:1.33
	gdb-csl-20060226-branch-local-2:1.33
	gdb-csl-sourcerygxx-4_1-14:1.33
	gdb-csl-sourcerygxx-4_1-13:1.33
	gdb-csl-sourcerygxx-4_1-12:1.33
	gdb-csl-sourcerygxx-3_4_4-21:1.33
	gdb_6_5-20060621-release:1.33
	gdb-csl-sourcerygxx-4_1-9:1.33
	gdb-csl-sourcerygxx-4_1-8:1.33
	gdb-csl-sourcerygxx-4_1-7:1.33
	gdb-csl-arm-2006q1-6:1.33
	gdb-csl-sourcerygxx-4_1-6:1.33
	gdb-csl-symbian-6_4_50_20060226-10:1.33
	gdb-csl-symbian-6_4_50_20060226-9:1.33
	gdb-csl-symbian-6_4_50_20060226-8:1.33
	gdb-csl-coldfire-4_1-11:1.33
	gdb-csl-sourcerygxx-3_4_4-19:1.33
	gdb-csl-coldfire-4_1-10:1.33
	gdb_6_5-branch:1.33.0.16
	gdb_6_5-2006-05-14-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-5:1.33
	nickrob-async-20060513-branch:1.33.0.14
	nickrob-async-20060513-branchpoint:1.33
	gdb-csl-sourcerygxx-4_1-4:1.33
	msnyder-reverse-20060502-branch:1.33.0.12
	msnyder-reverse-20060502-branchpoint:1.33
	gdb-csl-morpho-4_1-4:1.33
	gdb-csl-sourcerygxx-3_4_4-17:1.33
	readline_5_1-import-branch:1.33.0.10
	readline_5_1-import-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.33
	gdb-csl-symbian-20060226-branch:1.33.0.8
	gdb-csl-symbian-20060226-branchpoint:1.33
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.33
	msnyder-reverse-20060331-branch:1.33.0.6
	msnyder-reverse-20060331-branchpoint:1.33
	gdb-csl-available-20060303-branch:1.33.0.4
	gdb-csl-available-20060303-branchpoint:1.33
	gdb-csl-20060226-branch:1.33.0.2
	gdb-csl-20060226-branchpoint:1.33
	gdb_6_4-20051202-release:1.29.4.2
	msnyder-fork-checkpoint-branch:1.32.0.2
	msnyder-fork-checkpoint-branchpoint:1.32
	gdb-csl-gxxpro-6_3-branch:1.31.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.31
	gdb_6_4-branch:1.29.0.4
	gdb_6_4-2005-11-01-branchpoint:1.29
	gdb-csl-arm-20051020-branch:1.29.0.2
	gdb-csl-arm-20051020-branchpoint:1.29
	msnyder-tracepoint-checkpoint-branch:1.28.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.28
	gdb-csl-arm-20050325-2005-q1b:1.25
	gdb-csl-arm-20050325-2005-q1a:1.25
	csl-arm-20050325-branch:1.25.0.2
	csl-arm-20050325-branchpoint:1.25
	gdb-post-i18n-errorwarning-20050211:1.21
	gdb-pre-i18n-errorwarning-20050211:1.20
	gdb_6_3-20041109-release:1.17
	gdb_6_3-branch:1.17.0.2
	gdb_6_3-20041019-branchpoint:1.17
	drow_intercu-merge-20040921:1.17
	drow_intercu-merge-20040915:1.17
	jimb-gdb_6_2-e500-branch:1.15.4.2.0.2
	jimb-gdb_6_2-e500-branchpoint:1.15
	gdb_6_2-20040730-release:1.15
	gdb_6_2-branch:1.15.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.15
	gdb_6_1_1-20040616-release:1.14.6.1
	gdb_6_1-2004-04-05-release:1.14
	drow_intercu-merge-20040402:1.14
	drow_intercu-merge-20040327:1.14
	ezannoni_pie-20040323-branch:1.14.0.10
	ezannoni_pie-20040323-branchpoint:1.14
	cagney_tramp-20040321-mergepoint:1.14
	cagney_tramp-20040309-branch:1.14.0.8
	cagney_tramp-20040309-branchpoint:1.14
	gdb_6_1-branch:1.14.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.14
	drow_intercu-20040221-branch:1.14.0.4
	drow_intercu-20040221-branchpoint:1.14
	cagney_bfdfile-20040213-branch:1.14.0.2
	cagney_bfdfile-20040213-branchpoint:1.14
	drow-cplus-merge-20040208:1.14
	carlton_dictionary-20040126-merge:1.13
	cagney_bigcore-20040122-branch:1.13.0.8
	cagney_bigcore-20040122-branchpoint:1.13
	drow-cplus-merge-20040113:1.13
	drow-cplus-merge-20031224:1.13
	drow-cplus-merge-20031220:1.13
	carlton_dictionary-20031215-merge:1.13
	drow-cplus-branch:1.13.0.6
	drow-cplus-merge-20031214:1.13
	carlton-dictionary-20031111-merge:1.13
	gdb_6_0-2003-10-04-release:1.9.8.4
	kettenis_sparc-20030918-branch:1.13.0.4
	kettenis_sparc-20030918-branchpoint:1.13
	carlton_dictionary-20030917-merge:1.13
	ezannoni_pie-20030916-branchpoint:1.13
	ezannoni_pie-20030916-branch:1.13.0.2
	cagney_x86i386-20030821-branch:1.12.0.2
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.8
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.6
	jimb-ppc64-linux-20030613-branchpoint:1.9
	cagney_convert-20030606-branch:1.9.0.4
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.7.0.4
	cagney_writestrings-20030508-branchpoint:1.7
	jimb-ppc64-linux-20030528-branch:1.9.0.2
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.8.0.2
	cagney_fileio-20030521-branchpoint:1.8
	kettenis_i386newframe-20030517-mergepoint:1.7
	jimb-ppc64-linux-20030509-branch:1.7.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.7
	kettenis_i386newframe-20030504-mergepoint:1.7
	carlton_dictionary-20030430-merge:1.7
	kettenis_i386newframe-20030419-branch:1.6.0.2
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.4
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.2
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.10
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.8
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.6
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.4
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-branch:1.3.0.2
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.2.0.2
	cagney_offbyone-20030303-branchpoint:1.2;
locks; strict;
comment	@ * @;


1.179
date	2013.10.02.16.15.44;	author palves;	state Exp;
branches;
next	1.178;

1.178
date	2013.09.24.13.57.37;	author jkratoch;	state Exp;
branches;
next	1.177;

1.177
date	2013.09.05.14.49.13;	author palves;	state Exp;
branches;
next	1.176;

1.176
date	2013.08.29.12.25.03;	author sagovic;	state Exp;
branches;
next	1.175;

1.175
date	2013.06.26.08.01.55;	author qiyao;	state Exp;
branches;
next	1.174;

1.174
date	2013.06.18.18.11.19;	author tromey;	state Exp;
branches;
next	1.173;

1.173
date	2013.05.06.19.44.03;	author tromey;	state Exp;
branches;
next	1.172;

1.172
date	2013.04.19.15.09.45;	author palves;	state Exp;
branches;
next	1.171;

1.171
date	2013.04.08.19.59.08;	author tromey;	state Exp;
branches;
next	1.170;

1.170
date	2013.03.21.16.09.27;	author tromey;	state Exp;
branches;
next	1.169;

1.169
date	2013.03.20.18.33.05;	author tromey;	state Exp;
branches;
next	1.168;

1.168
date	2013.03.12.15.44.06;	author teawater;	state Exp;
branches;
next	1.167;

1.167
date	2013.03.12.14.44.56;	author teawater;	state Exp;
branches;
next	1.166;

1.166
date	2013.03.10.18.03.57;	author jkratoch;	state Exp;
branches;
next	1.165;

1.165
date	2013.03.01.21.18.21;	author jkratoch;	state Exp;
branches;
next	1.164;

1.164
date	2013.01.31.18.37.37;	author aristovski;	state Exp;
branches;
next	1.163;

1.163
date	2013.01.28.18.02.47;	author devans;	state Exp;
branches;
next	1.162;

1.162
date	2013.01.22.15.57.28;	author tromey;	state Exp;
branches;
next	1.161;

1.161
date	2013.01.18.18.32.34;	author tromey;	state Exp;
branches;
next	1.160;

1.160
date	2013.01.01.06.32.41;	author brobecke;	state Exp;
branches;
next	1.159;

1.159
date	2012.12.10.17.17.27;	author tromey;	state Exp;
branches;
next	1.158;

1.158
date	2012.12.06.01.11.31;	author teawater;	state Exp;
branches;
next	1.157;

1.157
date	2012.10.16.08.46.58;	author jkratoch;	state Exp;
branches;
next	1.156;

1.156
date	2012.10.15.19.15.55;	author jkratoch;	state Exp;
branches;
next	1.155;

1.155
date	2012.08.02.09.36.37;	author qiyao;	state Exp;
branches;
next	1.154;

1.154
date	2012.07.26.08.47.14;	author gingold;	state Exp;
branches;
next	1.153;

1.153
date	2012.07.26.02.03.16;	author siddhesh;	state Exp;
branches;
next	1.152;

1.152
date	2012.07.13.20.15.50;	author jkratoch;	state Exp;
branches;
next	1.151;

1.151
date	2012.06.19.00.37.18;	author devans;	state Exp;
branches;
next	1.150;

1.150
date	2012.06.17.19.53.52;	author jkratoch;	state Exp;
branches;
next	1.149;

1.149
date	2012.06.17.19.50.52;	author jkratoch;	state Exp;
branches;
next	1.148;

1.148
date	2012.06.14.22.56.47;	author devans;	state Exp;
branches;
next	1.147;

1.147
date	2012.05.24.01.26.15;	author devans;	state Exp;
branches;
next	1.146;

1.146
date	2012.05.22.18.45.22;	author devans;	state Exp;
branches;
next	1.145;

1.145
date	2012.05.18.21.02.47;	author sergiodj;	state Exp;
branches;
next	1.144;

1.144
date	2012.05.07.15.18.38;	author tromey;	state Exp;
branches;
next	1.143;

1.143
date	2012.04.28.23.22.13;	author devans;	state Exp;
branches;
next	1.142;

1.142
date	2012.03.19.19.59.19;	author jkratoch;	state Exp;
branches;
next	1.141;

1.141
date	2012.03.13.01.16.07;	author qiyao;	state Exp;
branches;
next	1.140;

1.140
date	2012.03.01.21.13.58;	author palves;	state Exp;
branches;
next	1.139;

1.139
date	2012.01.04.08.17.00;	author brobecke;	state Exp;
branches;
next	1.138;

1.138
date	2011.12.06.18.54.38;	author tromey;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2011.10.12.22.04.11;	author jkratoch;	state Exp;
branches;
next	1.136;

1.136
date	2011.10.09.20.57.03;	author jkratoch;	state Exp;
branches;
next	1.135;

1.135
date	2011.10.09.19.46.04;	author jkratoch;	state Exp;
branches;
next	1.134;

1.134
date	2011.10.09.19.43.40;	author jkratoch;	state Exp;
branches;
next	1.133;

1.133
date	2011.10.09.19.34.18;	author jkratoch;	state Exp;
branches;
next	1.132;

1.132
date	2011.10.09.19.29.10;	author jkratoch;	state Exp;
branches;
next	1.131;

1.131
date	2011.10.09.19.26.42;	author jkratoch;	state Exp;
branches;
next	1.130;

1.130
date	2011.10.09.19.21.38;	author jkratoch;	state Exp;
branches;
next	1.129;

1.129
date	2011.10.09.18.46.40;	author jkratoch;	state Exp;
branches;
next	1.128;

1.128
date	2011.09.13.21.44.27;	author jkratoch;	state Exp;
branches;
next	1.127;

1.127
date	2011.08.08.21.41.13;	author jkratoch;	state Exp;
branches;
next	1.126;

1.126
date	2011.07.25.16.04.52;	author jkratoch;	state Exp;
branches;
next	1.125;

1.125
date	2011.07.19.20.28.52;	author jkratoch;	state Exp;
branches;
next	1.124;

1.124
date	2011.07.19.20.25.13;	author jkratoch;	state Exp;
branches;
next	1.123;

1.123
date	2011.07.15.20.54.32;	author jkratoch;	state Exp;
branches;
next	1.122;

1.122
date	2011.07.14.15.00.19;	author jkratoch;	state Exp;
branches;
next	1.121;

1.121
date	2011.07.13.15.15.42;	author jkratoch;	state Exp;
branches;
next	1.120;

1.120
date	2011.07.12.21.16.47;	author jkratoch;	state Exp;
branches;
next	1.119;

1.119
date	2011.07.08.19.54.55;	author tromey;	state Exp;
branches;
next	1.118;

1.118
date	2011.05.13.18.42.48;	author tromey;	state Exp;
branches;
next	1.117;

1.117
date	2011.05.13.15.44.49;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2011.05.12.17.40.54;	author tromey;	state Exp;
branches;
next	1.115;

1.115
date	2011.03.22.21.06.33;	author jkratoch;	state Exp;
branches;
next	1.114;

1.114
date	2011.03.18.18.43.32;	author palves;	state Exp;
branches;
next	1.113;

1.113
date	2011.03.18.18.42.41;	author palves;	state Exp;
branches;
next	1.112;

1.112
date	2011.03.14.15.58.56;	author tromey;	state Exp;
branches;
next	1.111;

1.111
date	2011.03.07.20.06.12;	author msnyder;	state Exp;
branches;
next	1.110;

1.110
date	2011.02.27.00.01.12;	author msnyder;	state Exp;
branches;
next	1.109;

1.109
date	2011.02.25.08.35.36;	author jkratoch;	state Exp;
branches;
next	1.108;

1.108
date	2011.02.18.20.55.43;	author tromey;	state Exp;
branches;
next	1.107;

1.107
date	2011.02.17.16.20.44;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2011.02.16.21.45.38;	author tromey;	state Exp;
branches;
next	1.105;

1.105
date	2011.02.16.21.32.05;	author tromey;	state Exp;
branches;
next	1.104;

1.104
date	2011.02.14.11.21.25;	author palves;	state Exp;
branches;
next	1.103;

1.103
date	2011.01.12.16.10.04;	author jkratoch;	state Exp;
branches;
next	1.102;

1.102
date	2011.01.07.19.36.16;	author msnyder;	state Exp;
branches;
next	1.101;

1.101
date	2011.01.05.22.22.48;	author msnyder;	state Exp;
branches;
next	1.100;

1.100
date	2011.01.01.15.33.02;	author brobecke;	state Exp;
branches;
next	1.99;

1.99
date	2010.11.29.21.18.16;	author tromey;	state Exp;
branches;
next	1.98;

1.98
date	2010.09.14.19.39.58;	author tromey;	state Exp;
branches;
next	1.97;

1.97
date	2010.08.12.19.55.38;	author palves;	state Exp;
branches;
next	1.96;

1.96
date	2010.07.26.20.25.00;	author tromey;	state Exp;
branches;
next	1.95;

1.95
date	2010.07.13.15.09.03;	author tromey;	state Exp;
branches;
next	1.94;

1.94
date	2010.07.07.17.26.38;	author tromey;	state Exp;
branches;
next	1.93;

1.93
date	2010.07.01.15.45.31;	author palves;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2010.06.25.13.00.32;	author uweigand;	state Exp;
branches;
next	1.91;

1.91
date	2010.06.21.16.50.18;	author uweigand;	state Exp;
branches;
next	1.90;

1.90
date	2010.06.11.15.36.04;	author tromey;	state Exp;
branches;
next	1.89;

1.89
date	2010.06.11.15.21.11;	author tromey;	state Exp;
branches;
next	1.88;

1.88
date	2010.06.07.19.55.33;	author jkratoch;	state Exp;
branches;
next	1.87;

1.87
date	2010.06.07.19.42.58;	author jkratoch;	state Exp;
branches;
next	1.86;

1.86
date	2010.06.04.02.39.16;	author teawater;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.02.19.37.55;	author tromey;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.27.19.14.35;	author tromey;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.26.15.21.13;	author tromey;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.25.16.41.46;	author tromey;	state Exp;
branches;
next	1.81;

1.81
date	2010.05.21.21.13.11;	author tromey;	state Exp;
branches;
next	1.80;

1.80
date	2010.05.21.21.01.46;	author tromey;	state Exp;
branches;
next	1.79;

1.79
date	2010.05.21.20.39.50;	author tromey;	state Exp;
branches;
next	1.78;

1.78
date	2010.05.14.17.53.16;	author msnyder;	state Exp;
branches;
next	1.77;

1.77
date	2010.05.13.15.44.35;	author jkratoch;	state Exp;
branches;
next	1.76;

1.76
date	2010.05.04.09.54.18;	author mgretton;	state Exp;
branches;
next	1.75;

1.75
date	2010.04.20.18.52.59;	author shebs;	state Exp;
branches;
next	1.74;

1.74
date	2010.03.17.22.04.43;	author shebs;	state Exp;
branches;
next	1.73;

1.73
date	2010.02.26.12.48.18;	author uweigand;	state Exp;
branches;
next	1.72;

1.72
date	2010.02.23.16.14.36;	author tromey;	state Exp;
branches;
next	1.71;

1.71
date	2010.01.04.14.56.16;	author uweigand;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2010.01.01.07.31.30;	author brobecke;	state Exp;
branches;
next	1.69;

1.69
date	2009.12.24.00.40.49;	author shebs;	state Exp;
branches;
next	1.68;

1.68
date	2009.09.15.16.20.53;	author devans;	state Exp;
branches;
next	1.67;

1.67
date	2009.09.11.18.38.39;	author tromey;	state Exp;
branches;
next	1.66;

1.66
date	2009.09.04.20.05.25;	author froydnj;	state Exp;
branches;
next	1.65;

1.65
date	2009.09.02.14.53.55;	author tromey;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.31.20.18.45;	author devans;	state Exp;
branches;
next	1.63;

1.63
date	2009.08.11.20.36.49;	author tromey;	state Exp;
branches;
next	1.62;

1.62
date	2009.07.20.15.06.13;	author uweigand;	state Exp;
branches;
next	1.61;

1.61
date	2009.07.10.15.27.02;	author tromey;	state Exp;
branches;
next	1.60;

1.60
date	2009.07.02.17.25.53;	author uweigand;	state Exp;
branches;
next	1.59;

1.59
date	2009.07.02.17.21.05;	author uweigand;	state Exp;
branches;
next	1.58;

1.58
date	2009.06.28.00.20.22;	author drow;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.17.18.40.53;	author uweigand;	state Exp;
branches;
next	1.56;

1.56
date	2009.06.04.12.28.39;	author uweigand;	state Exp;
branches;
next	1.55;

1.55
date	2009.05.28.00.53.51;	author tromey;	state Exp;
branches;
next	1.54;

1.54
date	2009.01.13.18.01.49;	author uweigand;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.03.05.57.51;	author brobecke;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.05.11.40.53;	author uweigand;	state Exp;
branches;
next	1.51;

1.51
date	2008.05.04.12.44.16;	author jkratoch;	state Exp;
branches;
next	1.50;

1.50
date	2008.03.26.14.53.28;	author uweigand;	state Exp;
branches;
next	1.49;

1.49
date	2008.03.18.19.40.47;	author uweigand;	state Exp;
branches;
next	1.48;

1.48
date	2008.01.01.22.53.09;	author drow;	state Exp;
branches
	1.48.6.1;
next	1.47;

1.47
date	2007.10.08.12.46.09;	author uweigand;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.17.14.53.05;	author guitton;	state Exp;
branches;
next	1.45;

1.45
date	2007.08.23.18.08.28;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.13.17.59.50;	author uweigand;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.12.16.59.42;	author uweigand;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.12.16.43.39;	author uweigand;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.09.13.42.15;	author uweigand;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.18.19.42.42;	author ctice;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.24.22.04.48;	author jimb;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.09.17.58.50;	author drow;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.22.13.44.45;	author uweigand;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.06.23.20.12;	author jimb;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2006.11.03.22.09.28;	author jimb;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.10.03.17.53;	author drow;	state Exp;
branches;
next	1.33;

1.33
date	2005.12.17.22.33.59;	author eliz;	state Exp;
branches;
next	1.32;

1.32
date	2005.11.19.13.43.35;	author tausq;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.14.22.25.16;	author wilson;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.04.02.42.34;	author ezannoni;	state Exp;
branches;
next	1.29;

1.29
date	2005.07.12.13.06.54;	author kettenis;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	2005.04.26.14.57.20;	author cagney;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.26.05.03.36;	author cagney;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.31.19.58.24;	author kevinb;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.20.20.30.35;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.19.19.44.10;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.18.21.03.39;	author kevinb;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.28.17.00.48;	author drow;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.11.04.05.46;	author cagney;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.07.15.04.42;	author cagney;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.07.04.50.27;	author cagney;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.09.14.43.25;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.24.21.01.49;	author jimb;	state Exp;
branches;
next	1.16;

1.16
date	2004.08.24.17.31.49;	author jimb;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.13.17.30.41;	author bryce;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2004.01.26.20.36.31;	author cagney;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;

1.13
date	2003.09.11.15.02.51;	author drow;	state Exp;
branches
	1.13.6.1;
next	1.12;

1.12
date	2003.07.22.18.24.42;	author ezannoni;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.22.18.16.05;	author ezannoni;	state Exp;
branches;
next	1.10;

1.10
date	2003.07.22.15.41.59;	author ezannoni;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.22.18.37.05;	author cagney;	state Exp;
branches
	1.9.8.1;
next	1.8;

1.8
date	2003.05.18.15.49.51;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.22.23.18.26;	author kevinb;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.13.15.53.44;	author drow;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.04.13.15.43.35;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.01.19.11.01;	author cagney;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.05.18.00.02;	author drow;	state Exp;
branches
	1.3.2.1
	1.3.10.1;
next	1.2;

1.2
date	2003.02.28.20.03.18;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.21.15.24.17;	author drow;	state Exp;
branches;
next	;

1.138.2.1
date	2012.01.06.04.43.07;	author brobecke;	state Exp;
branches;
next	;

1.93.2.1
date	2010.07.07.18.50.57;	author tromey;	state Exp;
branches;
next	1.93.2.2;

1.93.2.2
date	2010.07.13.15.09.46;	author tromey;	state Exp;
branches;
next	1.93.2.3;

1.93.2.3
date	2010.07.27.16.11.03;	author tromey;	state Exp;
branches;
next	1.93.2.4;

1.93.2.4
date	2011.03.14.15.54.15;	author tromey;	state Exp;
branches;
next	;

1.71.2.1
date	2010.02.23.16.11.13;	author tromey;	state Exp;
branches;
next	;

1.48.6.1
date	2009.09.11.04.45.46;	author amylaar;	state Exp;
branches;
next	;

1.36.2.1
date	2006.11.24.19.59.57;	author uweigand;	state Exp;
branches;
next	;

1.29.4.1
date	2005.11.04.02.53.26;	author ezannoni;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2005.11.14.22.23.32;	author wilson;	state Exp;
branches;
next	;

1.15.4.1
date	2004.09.07.16.00.27;	author jimb;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2004.09.07.16.15.56;	author jimb;	state Exp;
branches
	1.15.4.2.2.1;
next	;

1.15.4.2.2.1
date	2004.09.22.18.49.07;	author jimb;	state Exp;
branches;
next	;

1.14.4.1
date	2004.09.16.17.01.02;	author drow;	state Exp;
branches;
next	;

1.14.6.1
date	2004.05.14.01.39.52;	author bryce;	state Exp;
branches;
next	;

1.13.6.1
date	2003.12.14.20.27.11;	author drow;	state Exp;
branches;
next	1.13.6.2;

1.13.6.2
date	2004.02.09.19.43.36;	author drow;	state Exp;
branches;
next	;

1.9.8.1
date	2003.07.22.15.44.10;	author ezannoni;	state Exp;
branches;
next	1.9.8.2;

1.9.8.2
date	2003.07.22.18.14.21;	author ezannoni;	state Exp;
branches;
next	1.9.8.3;

1.9.8.3
date	2003.07.22.18.23.22;	author ezannoni;	state Exp;
branches;
next	1.9.8.4;

1.9.8.4
date	2003.09.11.15.03.43;	author drow;	state Exp;
branches;
next	;

1.6.2.1
date	2003.05.04.11.37.40;	author kettenis;	state Exp;
branches;
next	;

1.3.2.1
date	2003.03.06.00.56.27;	author carlton;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.04.16.19.56.51;	author carlton;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.05.01.00.46.47;	author carlton;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2003.05.23.18.40.36;	author carlton;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.08.05.17.13.05;	author carlton;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2003.09.17.21.28.15;	author carlton;	state Exp;
branches;
next	;

1.3.10.1
date	2003.03.26.20.33.47;	author cagney;	state Exp;
branches;
next	;


desc
@@


1.179
log
@Print registers not saved in the frame as "<not saved>" instead of "<optimized out>".

Currently, in some scenarios, GDB prints <optimized out> when printing
outer frame registers.  An <optimized out> register is a confusing
concept.  What this really means is that the register is
call-clobbered, or IOW, not saved by the callee.  This patch makes GDB
say that instead.

Before patch:

 (gdb) p/x $rax $1 = <optimized out>
 (gdb) info registers rax
 rax            <optimized out>

After patch:

 (gdb) p/x $rax
 $1 = <not saved>
 (gdb) info registers rax
 rax            <not saved>

However, if for some reason the debug info describes a variable as
being in such a register (**), we still want to print <optimized out>
when printing the variable.  IOW, <not saved> is reserved for
inspecting registers at the machine level.  The patch uses
lval_register+optimized_out to encode the not saved registers, and
makes it so that optimized out variables always end up in
!lval_register values.

** See <https://sourceware.org/ml/gdb-patches/2012-08/msg00787.html>.
Current/recent enough GCC doesn't mark variables/arguments as being in
call-clobbered registers in the ranges corresponding to function
calls, while older GCCs did.  Newer GCCs will just not say where the
variable is, so GDB will end up realizing the variable is optimized
out.

frame_unwind_got_optimized creates not_lval optimized out registers,
so by default, in most cases, we'll see <optimized out>.

value_of_register is the function eval.c uses for evaluating
OP_REGISTER (again, $pc, etc.), and related bits.  It isn't used for
anything else.  This function makes sure to return lval_register
values.  The patch makes "info registers" and the MI equivalent use it
too.  I think it just makes a lot of sense, as this makes it so that
when printing machine registers ($pc, etc.), we go through a central
function.

We're likely to need a different encoding at some point, if/when we
support partially saved registers.  Even then, I think
value_of_register will still be the spot to tag the intention to print
machine register values differently.

value_from_register however may also return optimized out
lval_register values, so at a couple places where we're computing a
variable's location from a dwarf expression, we convert the resulting
value away from lval_register to a regular optimized out value.

Tested on x86_64 Fedora 17

gdb/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* cp-valprint.c (cp_print_value_fields): Adjust calls to
	val_print_optimized_out.
	* jv-valprint.c (java_print_value_fields): Likewise.
	* p-valprint.c (pascal_object_print_value_fields): Likewise.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full)
	<DWARF_VALUE_REGISTER>: If the register was not saved, return a
	new optimized out value.
	* findvar.c (address_from_register): Likewise.
	* frame.c (put_frame_register): Tweak error string to say the
	register was not saved, rather than optimized out.
	* infcmd.c (default_print_one_register_info): Adjust call to
	val_print_optimized_out.  Use value_of_register instead of
	get_frame_register_value.
	* mi/mi-main.c (output_register): Use value_of_register instead of
	get_frame_register_value.
	* valprint.c (valprint_check_validity): Likewise.
	(val_print_optimized_out): New value parameter.  If the value is
	lval_register, print <not saved> instead.
	(value_check_printable, val_print_scalar_formatted): Adjust calls
	to val_print_optimized_out.
	* valprint.h (val_print_optimized_out): New value parameter.
	* value.c (struct value) <optimized_out>: Extend comment.
	(error_value_optimized_out): New function.
	(require_not_optimized_out): Use it.  Use a different string for
	lval_register values.
	* value.h (error_value_optimized_out): New declaration.
	* NEWS: Mention <not saved>.

gdb/testsuite/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* gdb.dwarf2/dw2-reg-undefined.exp <pattern_rax_rbx_rcx_print,
	pattern_rax_rbx_rcx_info>: Set to "<not saved>".
	* gdb.mi/mi-reg-undefined.exp (opt_out_pattern): Delete.
	(not_saved_pattern): New.
	Replace use of the former with the latter.

gdb/doc/
2013-10-02  Pedro Alves  <palves@@redhat.com>

	* gdb.texinfo (Registers): Expand description of saved registers
	in frames.  Explain <not saved>.
@
text
@/* DWARF 2 location expression support for GDB.

   Copyright (C) 2003-2013 Free Software Foundation, Inc.

   Contributed by Daniel Jacobowitz, MontaVista Software, Inc.

   This file is part of GDB.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "defs.h"
#include "ui-out.h"
#include "value.h"
#include "frame.h"
#include "gdbcore.h"
#include "target.h"
#include "inferior.h"
#include "ax.h"
#include "ax-gdb.h"
#include "regcache.h"
#include "objfiles.h"
#include "exceptions.h"
#include "block.h"
#include "gdbcmd.h"

#include "dwarf2.h"
#include "dwarf2expr.h"
#include "dwarf2loc.h"
#include "dwarf2-frame.h"

#include "gdb_string.h"
#include "gdb_assert.h"

extern int dwarf2_always_disassemble;

static void dwarf_expr_frame_base_1 (struct symbol *framefunc, CORE_ADDR pc,
				     const gdb_byte **start, size_t *length);

static const struct dwarf_expr_context_funcs dwarf_expr_ctx_funcs;

static struct value *dwarf2_evaluate_loc_desc_full (struct type *type,
						    struct frame_info *frame,
						    const gdb_byte *data,
						    size_t size,
						    struct dwarf2_per_cu_data *per_cu,
						    LONGEST byte_offset);

/* Until these have formal names, we define these here.
   ref: http://gcc.gnu.org/wiki/DebugFission
   Each entry in .debug_loc.dwo begins with a byte that describes the entry,
   and is then followed by data specific to that entry.  */

enum debug_loc_kind
{
  /* Indicates the end of the list of entries.  */
  DEBUG_LOC_END_OF_LIST = 0,

  /* This is followed by an unsigned LEB128 number that is an index into
     .debug_addr and specifies the base address for all following entries.  */
  DEBUG_LOC_BASE_ADDRESS = 1,

  /* This is followed by two unsigned LEB128 numbers that are indices into
     .debug_addr and specify the beginning and ending addresses, and then
     a normal location expression as in .debug_loc.  */
  DEBUG_LOC_START_END = 2,

  /* This is followed by an unsigned LEB128 number that is an index into
     .debug_addr and specifies the beginning address, and a 4 byte unsigned
     number that specifies the length, and then a normal location expression
     as in .debug_loc.  */
  DEBUG_LOC_START_LENGTH = 3,

  /* An internal value indicating there is insufficient data.  */
  DEBUG_LOC_BUFFER_OVERFLOW = -1,

  /* An internal value indicating an invalid kind of entry was found.  */
  DEBUG_LOC_INVALID_ENTRY = -2
};

/* Helper function which throws an error if a synthetic pointer is
   invalid.  */

static void
invalid_synthetic_pointer (void)
{
  error (_("access outside bounds of object "
	   "referenced via synthetic pointer"));
}

/* Decode the addresses in a non-dwo .debug_loc entry.
   A pointer to the next byte to examine is returned in *NEW_PTR.
   The encoded low,high addresses are return in *LOW,*HIGH.
   The result indicates the kind of entry found.  */

static enum debug_loc_kind
decode_debug_loc_addresses (const gdb_byte *loc_ptr, const gdb_byte *buf_end,
			    const gdb_byte **new_ptr,
			    CORE_ADDR *low, CORE_ADDR *high,
			    enum bfd_endian byte_order,
			    unsigned int addr_size,
			    int signed_addr_p)
{
  CORE_ADDR base_mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));

  if (buf_end - loc_ptr < 2 * addr_size)
    return DEBUG_LOC_BUFFER_OVERFLOW;

  if (signed_addr_p)
    *low = extract_signed_integer (loc_ptr, addr_size, byte_order);
  else
    *low = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
  loc_ptr += addr_size;

  if (signed_addr_p)
    *high = extract_signed_integer (loc_ptr, addr_size, byte_order);
  else
    *high = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
  loc_ptr += addr_size;

  *new_ptr = loc_ptr;

  /* A base-address-selection entry.  */
  if ((*low & base_mask) == base_mask)
    return DEBUG_LOC_BASE_ADDRESS;

  /* An end-of-list entry.  */
  if (*low == 0 && *high == 0)
    return DEBUG_LOC_END_OF_LIST;

  return DEBUG_LOC_START_END;
}

/* Decode the addresses in .debug_loc.dwo entry.
   A pointer to the next byte to examine is returned in *NEW_PTR.
   The encoded low,high addresses are return in *LOW,*HIGH.
   The result indicates the kind of entry found.  */

static enum debug_loc_kind
decode_debug_loc_dwo_addresses (struct dwarf2_per_cu_data *per_cu,
				const gdb_byte *loc_ptr,
				const gdb_byte *buf_end,
				const gdb_byte **new_ptr,
				CORE_ADDR *low, CORE_ADDR *high,
				enum bfd_endian byte_order)
{
  uint64_t low_index, high_index;

  if (loc_ptr == buf_end)
    return DEBUG_LOC_BUFFER_OVERFLOW;

  switch (*loc_ptr++)
    {
    case DEBUG_LOC_END_OF_LIST:
      *new_ptr = loc_ptr;
      return DEBUG_LOC_END_OF_LIST;
    case DEBUG_LOC_BASE_ADDRESS:
      *low = 0;
      loc_ptr = gdb_read_uleb128 (loc_ptr, buf_end, &high_index);
      if (loc_ptr == NULL)
	return DEBUG_LOC_BUFFER_OVERFLOW;
      *high = dwarf2_read_addr_index (per_cu, high_index);
      *new_ptr = loc_ptr;
      return DEBUG_LOC_BASE_ADDRESS;
    case DEBUG_LOC_START_END:
      loc_ptr = gdb_read_uleb128 (loc_ptr, buf_end, &low_index);
      if (loc_ptr == NULL)
	return DEBUG_LOC_BUFFER_OVERFLOW;
      *low = dwarf2_read_addr_index (per_cu, low_index);
      loc_ptr = gdb_read_uleb128 (loc_ptr, buf_end, &high_index);
      if (loc_ptr == NULL)
	return DEBUG_LOC_BUFFER_OVERFLOW;
      *high = dwarf2_read_addr_index (per_cu, high_index);
      *new_ptr = loc_ptr;
      return DEBUG_LOC_START_END;
    case DEBUG_LOC_START_LENGTH:
      loc_ptr = gdb_read_uleb128 (loc_ptr, buf_end, &low_index);
      if (loc_ptr == NULL)
	return DEBUG_LOC_BUFFER_OVERFLOW;
      *low = dwarf2_read_addr_index (per_cu, low_index);
      if (loc_ptr + 4 > buf_end)
	return DEBUG_LOC_BUFFER_OVERFLOW;
      *high = *low;
      *high += extract_unsigned_integer (loc_ptr, 4, byte_order);
      *new_ptr = loc_ptr + 4;
      return DEBUG_LOC_START_LENGTH;
    default:
      return DEBUG_LOC_INVALID_ENTRY;
    }
}

/* A function for dealing with location lists.  Given a
   symbol baton (BATON) and a pc value (PC), find the appropriate
   location expression, set *LOCEXPR_LENGTH, and return a pointer
   to the beginning of the expression.  Returns NULL on failure.

   For now, only return the first matching location expression; there
   can be more than one in the list.  */

const gdb_byte *
dwarf2_find_location_expression (struct dwarf2_loclist_baton *baton,
				 size_t *locexpr_length, CORE_ADDR pc)
{
  struct objfile *objfile = dwarf2_per_cu_objfile (baton->per_cu);
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned int addr_size = dwarf2_per_cu_addr_size (baton->per_cu);
  int signed_addr_p = bfd_get_sign_extend_vma (objfile->obfd);
  /* Adjust base_address for relocatable objects.  */
  CORE_ADDR base_offset = dwarf2_per_cu_text_offset (baton->per_cu);
  CORE_ADDR base_address = baton->base_address + base_offset;
  const gdb_byte *loc_ptr, *buf_end;

  loc_ptr = baton->data;
  buf_end = baton->data + baton->size;

  while (1)
    {
      CORE_ADDR low = 0, high = 0; /* init for gcc -Wall */
      int length;
      enum debug_loc_kind kind;
      const gdb_byte *new_ptr = NULL; /* init for gcc -Wall */

      if (baton->from_dwo)
	kind = decode_debug_loc_dwo_addresses (baton->per_cu,
					       loc_ptr, buf_end, &new_ptr,
					       &low, &high, byte_order);
      else
	kind = decode_debug_loc_addresses (loc_ptr, buf_end, &new_ptr,
					   &low, &high,
					   byte_order, addr_size,
					   signed_addr_p);
      loc_ptr = new_ptr;
      switch (kind)
	{
	case DEBUG_LOC_END_OF_LIST:
	  *locexpr_length = 0;
	  return NULL;
	case DEBUG_LOC_BASE_ADDRESS:
	  base_address = high + base_offset;
	  continue;
	case DEBUG_LOC_START_END:
	case DEBUG_LOC_START_LENGTH:
	  break;
	case DEBUG_LOC_BUFFER_OVERFLOW:
	case DEBUG_LOC_INVALID_ENTRY:
	  error (_("dwarf2_find_location_expression: "
		   "Corrupted DWARF expression."));
	default:
	  gdb_assert_not_reached ("bad debug_loc_kind");
	}

      /* Otherwise, a location expression entry.
	 If the entry is from a DWO, don't add base address: the entry is
	 from .debug_addr which has absolute addresses.  */
      if (! baton->from_dwo)
	{
	  low += base_address;
	  high += base_address;
	}

      length = extract_unsigned_integer (loc_ptr, 2, byte_order);
      loc_ptr += 2;

      if (low == high && pc == low)
	{
	  /* This is entry PC record present only at entry point
	     of a function.  Verify it is really the function entry point.  */

	  struct block *pc_block = block_for_pc (pc);
	  struct symbol *pc_func = NULL;

	  if (pc_block)
	    pc_func = block_linkage_function (pc_block);

	  if (pc_func && pc == BLOCK_START (SYMBOL_BLOCK_VALUE (pc_func)))
	    {
	      *locexpr_length = length;
	      return loc_ptr;
	    }
	}

      if (pc >= low && pc < high)
	{
	  *locexpr_length = length;
	  return loc_ptr;
	}

      loc_ptr += length;
    }
}

/* This is the baton used when performing dwarf2 expression
   evaluation.  */
struct dwarf_expr_baton
{
  struct frame_info *frame;
  struct dwarf2_per_cu_data *per_cu;
};

/* Helper functions for dwarf2_evaluate_loc_desc.  */

/* Using the frame specified in BATON, return the value of register
   REGNUM, treated as a pointer.  */
static CORE_ADDR
dwarf_expr_read_reg (void *baton, int dwarf_regnum)
{
  struct dwarf_expr_baton *debaton = (struct dwarf_expr_baton *) baton;
  struct gdbarch *gdbarch = get_frame_arch (debaton->frame);
  CORE_ADDR result;
  int regnum;

  regnum = gdbarch_dwarf2_reg_to_regnum (gdbarch, dwarf_regnum);
  result = address_from_register (builtin_type (gdbarch)->builtin_data_ptr,
				  regnum, debaton->frame);
  return result;
}

/* Read memory at ADDR (length LEN) into BUF.  */

static void
dwarf_expr_read_mem (void *baton, gdb_byte *buf, CORE_ADDR addr, size_t len)
{
  read_memory (addr, buf, len);
}

/* Using the frame specified in BATON, find the location expression
   describing the frame base.  Return a pointer to it in START and
   its length in LENGTH.  */
static void
dwarf_expr_frame_base (void *baton, const gdb_byte **start, size_t * length)
{
  /* FIXME: cagney/2003-03-26: This code should be using
     get_frame_base_address(), and then implement a dwarf2 specific
     this_base method.  */
  struct symbol *framefunc;
  struct dwarf_expr_baton *debaton = (struct dwarf_expr_baton *) baton;
  struct block *bl = get_frame_block (debaton->frame, NULL);

  if (bl == NULL)
    error (_("frame address is not available."));

  /* Use block_linkage_function, which returns a real (not inlined)
     function, instead of get_frame_function, which may return an
     inlined function.  */
  framefunc = block_linkage_function (bl);

  /* If we found a frame-relative symbol then it was certainly within
     some function associated with a frame. If we can't find the frame,
     something has gone wrong.  */
  gdb_assert (framefunc != NULL);

  dwarf_expr_frame_base_1 (framefunc,
			   get_frame_address_in_block (debaton->frame),
			   start, length);
}

/* Implement find_frame_base_location method for LOC_BLOCK functions using
   DWARF expression for its DW_AT_frame_base.  */

static void
locexpr_find_frame_base_location (struct symbol *framefunc, CORE_ADDR pc,
				  const gdb_byte **start, size_t *length)
{
  struct dwarf2_locexpr_baton *symbaton = SYMBOL_LOCATION_BATON (framefunc);

  *length = symbaton->size;
  *start = symbaton->data;
}

/* Vector for inferior functions as represented by LOC_BLOCK, if the inferior
   function uses DWARF expression for its DW_AT_frame_base.  */

const struct symbol_block_ops dwarf2_block_frame_base_locexpr_funcs =
{
  locexpr_find_frame_base_location
};

/* Implement find_frame_base_location method for LOC_BLOCK functions using
   DWARF location list for its DW_AT_frame_base.  */

static void
loclist_find_frame_base_location (struct symbol *framefunc, CORE_ADDR pc,
				  const gdb_byte **start, size_t *length)
{
  struct dwarf2_loclist_baton *symbaton = SYMBOL_LOCATION_BATON (framefunc);

  *start = dwarf2_find_location_expression (symbaton, length, pc);
}

/* Vector for inferior functions as represented by LOC_BLOCK, if the inferior
   function uses DWARF location list for its DW_AT_frame_base.  */

const struct symbol_block_ops dwarf2_block_frame_base_loclist_funcs =
{
  loclist_find_frame_base_location
};

static void
dwarf_expr_frame_base_1 (struct symbol *framefunc, CORE_ADDR pc,
			 const gdb_byte **start, size_t *length)
{
  if (SYMBOL_BLOCK_OPS (framefunc) != NULL)
    {
      const struct symbol_block_ops *ops_block = SYMBOL_BLOCK_OPS (framefunc);

      ops_block->find_frame_base_location (framefunc, pc, start, length);
    }
  else
    *length = 0;

  if (*length == 0)
    error (_("Could not find the frame base for \"%s\"."),
	   SYMBOL_NATURAL_NAME (framefunc));
}

/* Helper function for dwarf2_evaluate_loc_desc.  Computes the CFA for
   the frame in BATON.  */

static CORE_ADDR
dwarf_expr_frame_cfa (void *baton)
{
  struct dwarf_expr_baton *debaton = (struct dwarf_expr_baton *) baton;

  return dwarf2_frame_cfa (debaton->frame);
}

/* Helper function for dwarf2_evaluate_loc_desc.  Computes the PC for
   the frame in BATON.  */

static CORE_ADDR
dwarf_expr_frame_pc (void *baton)
{
  struct dwarf_expr_baton *debaton = (struct dwarf_expr_baton *) baton;

  return get_frame_address_in_block (debaton->frame);
}

/* Using the objfile specified in BATON, find the address for the
   current thread's thread-local storage with offset OFFSET.  */
static CORE_ADDR
dwarf_expr_tls_address (void *baton, CORE_ADDR offset)
{
  struct dwarf_expr_baton *debaton = (struct dwarf_expr_baton *) baton;
  struct objfile *objfile = dwarf2_per_cu_objfile (debaton->per_cu);

  return target_translate_tls_address (objfile, offset);
}

/* Call DWARF subroutine from DW_AT_location of DIE at DIE_OFFSET in
   current CU (as is PER_CU).  State of the CTX is not affected by the
   call and return.  */

static void
per_cu_dwarf_call (struct dwarf_expr_context *ctx, cu_offset die_offset,
		   struct dwarf2_per_cu_data *per_cu,
		   CORE_ADDR (*get_frame_pc) (void *baton),
		   void *baton)
{
  struct dwarf2_locexpr_baton block;

  block = dwarf2_fetch_die_loc_cu_off (die_offset, per_cu, get_frame_pc, baton);

  /* DW_OP_call_ref is currently not supported.  */
  gdb_assert (block.per_cu == per_cu);

  dwarf_expr_eval (ctx, block.data, block.size);
}

/* Helper interface of per_cu_dwarf_call for dwarf2_evaluate_loc_desc.  */

static void
dwarf_expr_dwarf_call (struct dwarf_expr_context *ctx, cu_offset die_offset)
{
  struct dwarf_expr_baton *debaton = ctx->baton;

  per_cu_dwarf_call (ctx, die_offset, debaton->per_cu,
		     ctx->funcs->get_frame_pc, ctx->baton);
}

/* Callback function for dwarf2_evaluate_loc_desc.  */

static struct type *
dwarf_expr_get_base_type (struct dwarf_expr_context *ctx,
			  cu_offset die_offset)
{
  struct dwarf_expr_baton *debaton = ctx->baton;

  return dwarf2_get_die_type (die_offset, debaton->per_cu);
}

/* See dwarf2loc.h.  */

unsigned int entry_values_debug = 0;

/* Helper to set entry_values_debug.  */

static void
show_entry_values_debug (struct ui_file *file, int from_tty,
			 struct cmd_list_element *c, const char *value)
{
  fprintf_filtered (file,
		    _("Entry values and tail call frames debugging is %s.\n"),
		    value);
}

/* Find DW_TAG_GNU_call_site's DW_AT_GNU_call_site_target address.
   CALLER_FRAME (for registers) can be NULL if it is not known.  This function
   always returns valid address or it throws NO_ENTRY_VALUE_ERROR.  */

static CORE_ADDR
call_site_to_target_addr (struct gdbarch *call_site_gdbarch,
			  struct call_site *call_site,
			  struct frame_info *caller_frame)
{
  switch (FIELD_LOC_KIND (call_site->target))
    {
    case FIELD_LOC_KIND_DWARF_BLOCK:
      {
	struct dwarf2_locexpr_baton *dwarf_block;
	struct value *val;
	struct type *caller_core_addr_type;
	struct gdbarch *caller_arch;

	dwarf_block = FIELD_DWARF_BLOCK (call_site->target);
	if (dwarf_block == NULL)
	  {
	    struct bound_minimal_symbol msym;
	    
	    msym = lookup_minimal_symbol_by_pc (call_site->pc - 1);
	    throw_error (NO_ENTRY_VALUE_ERROR,
			 _("DW_AT_GNU_call_site_target is not specified "
			   "at %s in %s"),
			 paddress (call_site_gdbarch, call_site->pc),
			 (msym.minsym == NULL ? "???"
			  : SYMBOL_PRINT_NAME (msym.minsym)));
			
	  }
	if (caller_frame == NULL)
	  {
	    struct bound_minimal_symbol msym;
	    
	    msym = lookup_minimal_symbol_by_pc (call_site->pc - 1);
	    throw_error (NO_ENTRY_VALUE_ERROR,
			 _("DW_AT_GNU_call_site_target DWARF block resolving "
			   "requires known frame which is currently not "
			   "available at %s in %s"),
			 paddress (call_site_gdbarch, call_site->pc),
			 (msym.minsym == NULL ? "???"
			  : SYMBOL_PRINT_NAME (msym.minsym)));
			
	  }
	caller_arch = get_frame_arch (caller_frame);
	caller_core_addr_type = builtin_type (caller_arch)->builtin_func_ptr;
	val = dwarf2_evaluate_loc_desc (caller_core_addr_type, caller_frame,
					dwarf_block->data, dwarf_block->size,
					dwarf_block->per_cu);
	/* DW_AT_GNU_call_site_target is a DWARF expression, not a DWARF
	   location.  */
	if (VALUE_LVAL (val) == lval_memory)
	  return value_address (val);
	else
	  return value_as_address (val);
      }

    case FIELD_LOC_KIND_PHYSNAME:
      {
	const char *physname;
	struct minimal_symbol *msym;

	physname = FIELD_STATIC_PHYSNAME (call_site->target);

	/* Handle both the mangled and demangled PHYSNAME.  */
	msym = lookup_minimal_symbol (physname, NULL, NULL);
	if (msym == NULL)
	  {
	    msym = lookup_minimal_symbol_by_pc (call_site->pc - 1).minsym;
	    throw_error (NO_ENTRY_VALUE_ERROR,
			 _("Cannot find function \"%s\" for a call site target "
			   "at %s in %s"),
			 physname, paddress (call_site_gdbarch, call_site->pc),
			 msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym));
			
	  }
	return SYMBOL_VALUE_ADDRESS (msym);
      }

    case FIELD_LOC_KIND_PHYSADDR:
      return FIELD_STATIC_PHYSADDR (call_site->target);

    default:
      internal_error (__FILE__, __LINE__, _("invalid call site target kind"));
    }
}

/* Convert function entry point exact address ADDR to the function which is
   compliant with TAIL_CALL_LIST_COMPLETE condition.  Throw
   NO_ENTRY_VALUE_ERROR otherwise.  */

static struct symbol *
func_addr_to_tail_call_list (struct gdbarch *gdbarch, CORE_ADDR addr)
{
  struct symbol *sym = find_pc_function (addr);
  struct type *type;

  if (sym == NULL || BLOCK_START (SYMBOL_BLOCK_VALUE (sym)) != addr)
    throw_error (NO_ENTRY_VALUE_ERROR,
		 _("DW_TAG_GNU_call_site resolving failed to find function "
		   "name for address %s"),
		 paddress (gdbarch, addr));

  type = SYMBOL_TYPE (sym);
  gdb_assert (TYPE_CODE (type) == TYPE_CODE_FUNC);
  gdb_assert (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_FUNC);

  return sym;
}

/* Verify function with entry point exact address ADDR can never call itself
   via its tail calls (incl. transitively).  Throw NO_ENTRY_VALUE_ERROR if it
   can call itself via tail calls.

   If a funtion can tail call itself its entry value based parameters are
   unreliable.  There is no verification whether the value of some/all
   parameters is unchanged through the self tail call, we expect if there is
   a self tail call all the parameters can be modified.  */

static void
func_verify_no_selftailcall (struct gdbarch *gdbarch, CORE_ADDR verify_addr)
{
  struct obstack addr_obstack;
  struct cleanup *old_chain;
  CORE_ADDR addr;

  /* Track here CORE_ADDRs which were already visited.  */
  htab_t addr_hash;

  /* The verification is completely unordered.  Track here function addresses
     which still need to be iterated.  */
  VEC (CORE_ADDR) *todo = NULL;

  obstack_init (&addr_obstack);
  old_chain = make_cleanup_obstack_free (&addr_obstack);   
  addr_hash = htab_create_alloc_ex (64, core_addr_hash, core_addr_eq, NULL,
				    &addr_obstack, hashtab_obstack_allocate,
				    NULL);
  make_cleanup_htab_delete (addr_hash);

  make_cleanup (VEC_cleanup (CORE_ADDR), &todo);

  VEC_safe_push (CORE_ADDR, todo, verify_addr);
  while (!VEC_empty (CORE_ADDR, todo))
    {
      struct symbol *func_sym;
      struct call_site *call_site;

      addr = VEC_pop (CORE_ADDR, todo);

      func_sym = func_addr_to_tail_call_list (gdbarch, addr);

      for (call_site = TYPE_TAIL_CALL_LIST (SYMBOL_TYPE (func_sym));
	   call_site; call_site = call_site->tail_call_next)
	{
	  CORE_ADDR target_addr;
	  void **slot;

	  /* CALLER_FRAME with registers is not available for tail-call jumped
	     frames.  */
	  target_addr = call_site_to_target_addr (gdbarch, call_site, NULL);

	  if (target_addr == verify_addr)
	    {
	      struct bound_minimal_symbol msym;
	      
	      msym = lookup_minimal_symbol_by_pc (verify_addr);
	      throw_error (NO_ENTRY_VALUE_ERROR,
			   _("DW_OP_GNU_entry_value resolving has found "
			     "function \"%s\" at %s can call itself via tail "
			     "calls"),
			   (msym.minsym == NULL ? "???"
			    : SYMBOL_PRINT_NAME (msym.minsym)),
			   paddress (gdbarch, verify_addr));
	    }

	  slot = htab_find_slot (addr_hash, &target_addr, INSERT);
	  if (*slot == NULL)
	    {
	      *slot = obstack_copy (&addr_obstack, &target_addr,
				    sizeof (target_addr));
	      VEC_safe_push (CORE_ADDR, todo, target_addr);
	    }
	}
    }

  do_cleanups (old_chain);
}

/* Print user readable form of CALL_SITE->PC to gdb_stdlog.  Used only for
   ENTRY_VALUES_DEBUG.  */

static void
tailcall_dump (struct gdbarch *gdbarch, const struct call_site *call_site)
{
  CORE_ADDR addr = call_site->pc;
  struct bound_minimal_symbol msym = lookup_minimal_symbol_by_pc (addr - 1);

  fprintf_unfiltered (gdb_stdlog, " %s(%s)", paddress (gdbarch, addr),
		      (msym.minsym == NULL ? "???"
		       : SYMBOL_PRINT_NAME (msym.minsym)));

}

/* vec.h needs single word type name, typedef it.  */
typedef struct call_site *call_sitep;

/* Define VEC (call_sitep) functions.  */
DEF_VEC_P (call_sitep);

/* Intersect RESULTP with CHAIN to keep RESULTP unambiguous, keep in RESULTP
   only top callers and bottom callees which are present in both.  GDBARCH is
   used only for ENTRY_VALUES_DEBUG.  RESULTP is NULL after return if there are
   no remaining possibilities to provide unambiguous non-trivial result.
   RESULTP should point to NULL on the first (initialization) call.  Caller is
   responsible for xfree of any RESULTP data.  */

static void
chain_candidate (struct gdbarch *gdbarch, struct call_site_chain **resultp,
		 VEC (call_sitep) *chain)
{
  struct call_site_chain *result = *resultp;
  long length = VEC_length (call_sitep, chain);
  int callers, callees, idx;

  if (result == NULL)
    {
      /* Create the initial chain containing all the passed PCs.  */

      result = xmalloc (sizeof (*result) + sizeof (*result->call_site)
					   * (length - 1));
      result->length = length;
      result->callers = result->callees = length;
      memcpy (result->call_site, VEC_address (call_sitep, chain),
	      sizeof (*result->call_site) * length);
      *resultp = result;

      if (entry_values_debug)
	{
	  fprintf_unfiltered (gdb_stdlog, "tailcall: initial:");
	  for (idx = 0; idx < length; idx++)
	    tailcall_dump (gdbarch, result->call_site[idx]);
	  fputc_unfiltered ('\n', gdb_stdlog);
	}

      return;
    }

  if (entry_values_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "tailcall: compare:");
      for (idx = 0; idx < length; idx++)
	tailcall_dump (gdbarch, VEC_index (call_sitep, chain, idx));
      fputc_unfiltered ('\n', gdb_stdlog);
    }

  /* Intersect callers.  */

  callers = min (result->callers, length);
  for (idx = 0; idx < callers; idx++)
    if (result->call_site[idx] != VEC_index (call_sitep, chain, idx))
      {
	result->callers = idx;
	break;
      }

  /* Intersect callees.  */

  callees = min (result->callees, length);
  for (idx = 0; idx < callees; idx++)
    if (result->call_site[result->length - 1 - idx]
	!= VEC_index (call_sitep, chain, length - 1 - idx))
      {
	result->callees = idx;
	break;
      }

  if (entry_values_debug)
    {
      fprintf_unfiltered (gdb_stdlog, "tailcall: reduced:");
      for (idx = 0; idx < result->callers; idx++)
	tailcall_dump (gdbarch, result->call_site[idx]);
      fputs_unfiltered (" |", gdb_stdlog);
      for (idx = 0; idx < result->callees; idx++)
	tailcall_dump (gdbarch, result->call_site[result->length
						  - result->callees + idx]);
      fputc_unfiltered ('\n', gdb_stdlog);
    }

  if (result->callers == 0 && result->callees == 0)
    {
      /* There are no common callers or callees.  It could be also a direct
	 call (which has length 0) with ambiguous possibility of an indirect
	 call - CALLERS == CALLEES == 0 is valid during the first allocation
	 but any subsequence processing of such entry means ambiguity.  */
      xfree (result);
      *resultp = NULL;
      return;
    }

  /* See call_site_find_chain_1 why there is no way to reach the bottom callee
     PC again.  In such case there must be two different code paths to reach
     it, therefore some of the former determined intermediate PCs must differ
     and the unambiguous chain gets shortened.  */
  gdb_assert (result->callers + result->callees < result->length);
}

/* Create and return call_site_chain for CALLER_PC and CALLEE_PC.  All the
   assumed frames between them use GDBARCH.  Use depth first search so we can
   keep single CHAIN of call_site's back to CALLER_PC.  Function recursion
   would have needless GDB stack overhead.  Caller is responsible for xfree of
   the returned result.  Any unreliability results in thrown
   NO_ENTRY_VALUE_ERROR.  */

static struct call_site_chain *
call_site_find_chain_1 (struct gdbarch *gdbarch, CORE_ADDR caller_pc,
			CORE_ADDR callee_pc)
{
  CORE_ADDR save_callee_pc = callee_pc;
  struct obstack addr_obstack;
  struct cleanup *back_to_retval, *back_to_workdata;
  struct call_site_chain *retval = NULL;
  struct call_site *call_site;

  /* Mark CALL_SITEs so we do not visit the same ones twice.  */
  htab_t addr_hash;

  /* CHAIN contains only the intermediate CALL_SITEs.  Neither CALLER_PC's
     call_site nor any possible call_site at CALLEE_PC's function is there.
     Any CALL_SITE in CHAIN will be iterated to its siblings - via
     TAIL_CALL_NEXT.  This is inappropriate for CALLER_PC's call_site.  */
  VEC (call_sitep) *chain = NULL;

  /* We are not interested in the specific PC inside the callee function.  */
  callee_pc = get_pc_function_start (callee_pc);
  if (callee_pc == 0)
    throw_error (NO_ENTRY_VALUE_ERROR, _("Unable to find function for PC %s"),
		 paddress (gdbarch, save_callee_pc));

  back_to_retval = make_cleanup (free_current_contents, &retval);

  obstack_init (&addr_obstack);
  back_to_workdata = make_cleanup_obstack_free (&addr_obstack);   
  addr_hash = htab_create_alloc_ex (64, core_addr_hash, core_addr_eq, NULL,
				    &addr_obstack, hashtab_obstack_allocate,
				    NULL);
  make_cleanup_htab_delete (addr_hash);

  make_cleanup (VEC_cleanup (call_sitep), &chain);

  /* Do not push CALL_SITE to CHAIN.  Push there only the first tail call site
     at the target's function.  All the possible tail call sites in the
     target's function will get iterated as already pushed into CHAIN via their
     TAIL_CALL_NEXT.  */
  call_site = call_site_for_pc (gdbarch, caller_pc);

  while (call_site)
    {
      CORE_ADDR target_func_addr;
      struct call_site *target_call_site;

      /* CALLER_FRAME with registers is not available for tail-call jumped
	 frames.  */
      target_func_addr = call_site_to_target_addr (gdbarch, call_site, NULL);

      if (target_func_addr == callee_pc)
	{
	  chain_candidate (gdbarch, &retval, chain);
	  if (retval == NULL)
	    break;

	  /* There is no way to reach CALLEE_PC again as we would prevent
	     entering it twice as being already marked in ADDR_HASH.  */
	  target_call_site = NULL;
	}
      else
	{
	  struct symbol *target_func;

	  target_func = func_addr_to_tail_call_list (gdbarch, target_func_addr);
	  target_call_site = TYPE_TAIL_CALL_LIST (SYMBOL_TYPE (target_func));
	}

      do
	{
	  /* Attempt to visit TARGET_CALL_SITE.  */

	  if (target_call_site)
	    {
	      void **slot;

	      slot = htab_find_slot (addr_hash, &target_call_site->pc, INSERT);
	      if (*slot == NULL)
		{
		  /* Successfully entered TARGET_CALL_SITE.  */

		  *slot = &target_call_site->pc;
		  VEC_safe_push (call_sitep, chain, target_call_site);
		  break;
		}
	    }

	  /* Backtrack (without revisiting the originating call_site).  Try the
	     callers's sibling; if there isn't any try the callers's callers's
	     sibling etc.  */

	  target_call_site = NULL;
	  while (!VEC_empty (call_sitep, chain))
	    {
	      call_site = VEC_pop (call_sitep, chain);

	      gdb_assert (htab_find_slot (addr_hash, &call_site->pc,
					  NO_INSERT) != NULL);
	      htab_remove_elt (addr_hash, &call_site->pc);

	      target_call_site = call_site->tail_call_next;
	      if (target_call_site)
		break;
	    }
	}
      while (target_call_site);

      if (VEC_empty (call_sitep, chain))
	call_site = NULL;
      else
	call_site = VEC_last (call_sitep, chain);
    }

  if (retval == NULL)
    {
      struct bound_minimal_symbol msym_caller, msym_callee;
      
      msym_caller = lookup_minimal_symbol_by_pc (caller_pc);
      msym_callee = lookup_minimal_symbol_by_pc (callee_pc);
      throw_error (NO_ENTRY_VALUE_ERROR,
		   _("There are no unambiguously determinable intermediate "
		     "callers or callees between caller function \"%s\" at %s "
		     "and callee function \"%s\" at %s"),
		   (msym_caller.minsym == NULL
		    ? "???" : SYMBOL_PRINT_NAME (msym_caller.minsym)),
		   paddress (gdbarch, caller_pc),
		   (msym_callee.minsym == NULL
		    ? "???" : SYMBOL_PRINT_NAME (msym_callee.minsym)),
		   paddress (gdbarch, callee_pc));
    }

  do_cleanups (back_to_workdata);
  discard_cleanups (back_to_retval);
  return retval;
}

/* Create and return call_site_chain for CALLER_PC and CALLEE_PC.  All the
   assumed frames between them use GDBARCH.  If valid call_site_chain cannot be
   constructed return NULL.  Caller is responsible for xfree of the returned
   result.  */

struct call_site_chain *
call_site_find_chain (struct gdbarch *gdbarch, CORE_ADDR caller_pc,
		      CORE_ADDR callee_pc)
{
  volatile struct gdb_exception e;
  struct call_site_chain *retval = NULL;

  TRY_CATCH (e, RETURN_MASK_ERROR)
    {
      retval = call_site_find_chain_1 (gdbarch, caller_pc, callee_pc);
    }
  if (e.reason < 0)
    {
      if (e.error == NO_ENTRY_VALUE_ERROR)
	{
	  if (entry_values_debug)
	    exception_print (gdb_stdout, e);

	  return NULL;
	}
      else
	throw_exception (e);
    }
  return retval;
}

/* Return 1 if KIND and KIND_U match PARAMETER.  Return 0 otherwise.  */

static int
call_site_parameter_matches (struct call_site_parameter *parameter,
			     enum call_site_parameter_kind kind,
			     union call_site_parameter_u kind_u)
{
  if (kind == parameter->kind)
    switch (kind)
      {
      case CALL_SITE_PARAMETER_DWARF_REG:
	return kind_u.dwarf_reg == parameter->u.dwarf_reg;
      case CALL_SITE_PARAMETER_FB_OFFSET:
	return kind_u.fb_offset == parameter->u.fb_offset;
      case CALL_SITE_PARAMETER_PARAM_OFFSET:
	return kind_u.param_offset.cu_off == parameter->u.param_offset.cu_off;
      }
  return 0;
}

/* Fetch call_site_parameter from caller matching KIND and KIND_U.
   FRAME is for callee.

   Function always returns non-NULL, it throws NO_ENTRY_VALUE_ERROR
   otherwise.  */

static struct call_site_parameter *
dwarf_expr_reg_to_entry_parameter (struct frame_info *frame,
				   enum call_site_parameter_kind kind,
				   union call_site_parameter_u kind_u,
				   struct dwarf2_per_cu_data **per_cu_return)
{
  CORE_ADDR func_addr, caller_pc;
  struct gdbarch *gdbarch;
  struct frame_info *caller_frame;
  struct call_site *call_site;
  int iparams;
  /* Initialize it just to avoid a GCC false warning.  */
  struct call_site_parameter *parameter = NULL;
  CORE_ADDR target_addr;

  while (get_frame_type (frame) == INLINE_FRAME)
    {
      frame = get_prev_frame (frame);
      gdb_assert (frame != NULL);
    }

  func_addr = get_frame_func (frame);
  gdbarch = get_frame_arch (frame);
  caller_frame = get_prev_frame (frame);
  if (gdbarch != frame_unwind_arch (frame))
    {
      struct bound_minimal_symbol msym
	= lookup_minimal_symbol_by_pc (func_addr);
      struct gdbarch *caller_gdbarch = frame_unwind_arch (frame);

      throw_error (NO_ENTRY_VALUE_ERROR,
		   _("DW_OP_GNU_entry_value resolving callee gdbarch %s "
		     "(of %s (%s)) does not match caller gdbarch %s"),
		   gdbarch_bfd_arch_info (gdbarch)->printable_name,
		   paddress (gdbarch, func_addr),
		   (msym.minsym == NULL ? "???"
		    : SYMBOL_PRINT_NAME (msym.minsym)),
		   gdbarch_bfd_arch_info (caller_gdbarch)->printable_name);
    }

  if (caller_frame == NULL)
    {
      struct bound_minimal_symbol msym
	= lookup_minimal_symbol_by_pc (func_addr);

      throw_error (NO_ENTRY_VALUE_ERROR, _("DW_OP_GNU_entry_value resolving "
					   "requires caller of %s (%s)"),
		   paddress (gdbarch, func_addr),
		   (msym.minsym == NULL ? "???"
		    : SYMBOL_PRINT_NAME (msym.minsym)));
    }
  caller_pc = get_frame_pc (caller_frame);
  call_site = call_site_for_pc (gdbarch, caller_pc);

  target_addr = call_site_to_target_addr (gdbarch, call_site, caller_frame);
  if (target_addr != func_addr)
    {
      struct minimal_symbol *target_msym, *func_msym;

      target_msym = lookup_minimal_symbol_by_pc (target_addr).minsym;
      func_msym = lookup_minimal_symbol_by_pc (func_addr).minsym;
      throw_error (NO_ENTRY_VALUE_ERROR,
		   _("DW_OP_GNU_entry_value resolving expects callee %s at %s "
		     "but the called frame is for %s at %s"),
		   (target_msym == NULL ? "???"
					: SYMBOL_PRINT_NAME (target_msym)),
		   paddress (gdbarch, target_addr),
		   func_msym == NULL ? "???" : SYMBOL_PRINT_NAME (func_msym),
		   paddress (gdbarch, func_addr));
    }

  /* No entry value based parameters would be reliable if this function can
     call itself via tail calls.  */
  func_verify_no_selftailcall (gdbarch, func_addr);

  for (iparams = 0; iparams < call_site->parameter_count; iparams++)
    {
      parameter = &call_site->parameter[iparams];
      if (call_site_parameter_matches (parameter, kind, kind_u))
	break;
    }
  if (iparams == call_site->parameter_count)
    {
      struct minimal_symbol *msym
	= lookup_minimal_symbol_by_pc (caller_pc).minsym;

      /* DW_TAG_GNU_call_site_parameter will be missing just if GCC could not
	 determine its value.  */
      throw_error (NO_ENTRY_VALUE_ERROR, _("Cannot find matching parameter "
					   "at DW_TAG_GNU_call_site %s at %s"),
		   paddress (gdbarch, caller_pc),
		   msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym)); 
    }

  *per_cu_return = call_site->per_cu;
  return parameter;
}

/* Return value for PARAMETER matching DEREF_SIZE.  If DEREF_SIZE is -1, return
   the normal DW_AT_GNU_call_site_value block.  Otherwise return the
   DW_AT_GNU_call_site_data_value (dereferenced) block.

   TYPE and CALLER_FRAME specify how to evaluate the DWARF block into returned
   struct value.

   Function always returns non-NULL, non-optimized out value.  It throws
   NO_ENTRY_VALUE_ERROR if it cannot resolve the value for any reason.  */

static struct value *
dwarf_entry_parameter_to_value (struct call_site_parameter *parameter,
				CORE_ADDR deref_size, struct type *type,
				struct frame_info *caller_frame,
				struct dwarf2_per_cu_data *per_cu)
{
  const gdb_byte *data_src;
  gdb_byte *data;
  size_t size;

  data_src = deref_size == -1 ? parameter->value : parameter->data_value;
  size = deref_size == -1 ? parameter->value_size : parameter->data_value_size;

  /* DEREF_SIZE size is not verified here.  */
  if (data_src == NULL)
    throw_error (NO_ENTRY_VALUE_ERROR,
		 _("Cannot resolve DW_AT_GNU_call_site_data_value"));

  /* DW_AT_GNU_call_site_value is a DWARF expression, not a DWARF
     location.  Postprocessing of DWARF_VALUE_MEMORY would lose the type from
     DWARF block.  */
  data = alloca (size + 1);
  memcpy (data, data_src, size);
  data[size] = DW_OP_stack_value;

  return dwarf2_evaluate_loc_desc (type, caller_frame, data, size + 1, per_cu);
}

/* Execute DWARF block of call_site_parameter which matches KIND and KIND_U.
   Choose DEREF_SIZE value of that parameter.  Search caller of the CTX's
   frame.  CTX must be of dwarf_expr_ctx_funcs kind.

   The CTX caller can be from a different CU - per_cu_dwarf_call implementation
   can be more simple as it does not support cross-CU DWARF executions.  */

static void
dwarf_expr_push_dwarf_reg_entry_value (struct dwarf_expr_context *ctx,
				       enum call_site_parameter_kind kind,
				       union call_site_parameter_u kind_u,
				       int deref_size)
{
  struct dwarf_expr_baton *debaton;
  struct frame_info *frame, *caller_frame;
  struct dwarf2_per_cu_data *caller_per_cu;
  struct dwarf_expr_baton baton_local;
  struct dwarf_expr_context saved_ctx;
  struct call_site_parameter *parameter;
  const gdb_byte *data_src;
  size_t size;

  gdb_assert (ctx->funcs == &dwarf_expr_ctx_funcs);
  debaton = ctx->baton;
  frame = debaton->frame;
  caller_frame = get_prev_frame (frame);

  parameter = dwarf_expr_reg_to_entry_parameter (frame, kind, kind_u,
						 &caller_per_cu);
  data_src = deref_size == -1 ? parameter->value : parameter->data_value;
  size = deref_size == -1 ? parameter->value_size : parameter->data_value_size;

  /* DEREF_SIZE size is not verified here.  */
  if (data_src == NULL)
    throw_error (NO_ENTRY_VALUE_ERROR,
		 _("Cannot resolve DW_AT_GNU_call_site_data_value"));

  baton_local.frame = caller_frame;
  baton_local.per_cu = caller_per_cu;

  saved_ctx.gdbarch = ctx->gdbarch;
  saved_ctx.addr_size = ctx->addr_size;
  saved_ctx.offset = ctx->offset;
  saved_ctx.baton = ctx->baton;
  ctx->gdbarch = get_objfile_arch (dwarf2_per_cu_objfile (baton_local.per_cu));
  ctx->addr_size = dwarf2_per_cu_addr_size (baton_local.per_cu);
  ctx->offset = dwarf2_per_cu_text_offset (baton_local.per_cu);
  ctx->baton = &baton_local;

  dwarf_expr_eval (ctx, data_src, size);

  ctx->gdbarch = saved_ctx.gdbarch;
  ctx->addr_size = saved_ctx.addr_size;
  ctx->offset = saved_ctx.offset;
  ctx->baton = saved_ctx.baton;
}

/* Callback function for dwarf2_evaluate_loc_desc.
   Fetch the address indexed by DW_OP_GNU_addr_index.  */

static CORE_ADDR
dwarf_expr_get_addr_index (void *baton, unsigned int index)
{
  struct dwarf_expr_baton *debaton = (struct dwarf_expr_baton *) baton;

  return dwarf2_read_addr_index (debaton->per_cu, index);
}

/* VALUE must be of type lval_computed with entry_data_value_funcs.  Perform
   the indirect method on it, that is use its stored target value, the sole
   purpose of entry_data_value_funcs..  */

static struct value *
entry_data_value_coerce_ref (const struct value *value)
{
  struct type *checked_type = check_typedef (value_type (value));
  struct value *target_val;

  if (TYPE_CODE (checked_type) != TYPE_CODE_REF)
    return NULL;

  target_val = value_computed_closure (value);
  value_incref (target_val);
  return target_val;
}

/* Implement copy_closure.  */

static void *
entry_data_value_copy_closure (const struct value *v)
{
  struct value *target_val = value_computed_closure (v);

  value_incref (target_val);
  return target_val;
}

/* Implement free_closure.  */

static void
entry_data_value_free_closure (struct value *v)
{
  struct value *target_val = value_computed_closure (v);

  value_free (target_val);
}

/* Vector for methods for an entry value reference where the referenced value
   is stored in the caller.  On the first dereference use
   DW_AT_GNU_call_site_data_value in the caller.  */

static const struct lval_funcs entry_data_value_funcs =
{
  NULL,	/* read */
  NULL,	/* write */
  NULL,	/* check_validity */
  NULL,	/* check_any_valid */
  NULL,	/* indirect */
  entry_data_value_coerce_ref,
  NULL,	/* check_synthetic_pointer */
  entry_data_value_copy_closure,
  entry_data_value_free_closure
};

/* Read parameter of TYPE at (callee) FRAME's function entry.  KIND and KIND_U
   are used to match DW_AT_location at the caller's
   DW_TAG_GNU_call_site_parameter.

   Function always returns non-NULL value.  It throws NO_ENTRY_VALUE_ERROR if it
   cannot resolve the parameter for any reason.  */

static struct value *
value_of_dwarf_reg_entry (struct type *type, struct frame_info *frame,
			  enum call_site_parameter_kind kind,
			  union call_site_parameter_u kind_u)
{
  struct type *checked_type = check_typedef (type);
  struct type *target_type = TYPE_TARGET_TYPE (checked_type);
  struct frame_info *caller_frame = get_prev_frame (frame);
  struct value *outer_val, *target_val, *val;
  struct call_site_parameter *parameter;
  struct dwarf2_per_cu_data *caller_per_cu;
  CORE_ADDR addr;

  parameter = dwarf_expr_reg_to_entry_parameter (frame, kind, kind_u,
						 &caller_per_cu);

  outer_val = dwarf_entry_parameter_to_value (parameter, -1 /* deref_size */,
					      type, caller_frame,
					      caller_per_cu);

  /* Check if DW_AT_GNU_call_site_data_value cannot be used.  If it should be
     used and it is not available do not fall back to OUTER_VAL - dereferencing
     TYPE_CODE_REF with non-entry data value would give current value - not the
     entry value.  */

  if (TYPE_CODE (checked_type) != TYPE_CODE_REF
      || TYPE_TARGET_TYPE (checked_type) == NULL)
    return outer_val;

  target_val = dwarf_entry_parameter_to_value (parameter,
					       TYPE_LENGTH (target_type),
					       target_type, caller_frame,
					       caller_per_cu);

  /* value_as_address dereferences TYPE_CODE_REF.  */
  addr = extract_typed_address (value_contents (outer_val), checked_type);

  /* The target entry value has artificial address of the entry value
     reference.  */
  VALUE_LVAL (target_val) = lval_memory;
  set_value_address (target_val, addr);

  release_value (target_val);
  val = allocate_computed_value (type, &entry_data_value_funcs,
				 target_val /* closure */);

  /* Copy the referencing pointer to the new computed value.  */
  memcpy (value_contents_raw (val), value_contents_raw (outer_val),
	  TYPE_LENGTH (checked_type));
  set_value_lazy (val, 0);

  return val;
}

/* Read parameter of TYPE at (callee) FRAME's function entry.  DATA and
   SIZE are DWARF block used to match DW_AT_location at the caller's
   DW_TAG_GNU_call_site_parameter.

   Function always returns non-NULL value.  It throws NO_ENTRY_VALUE_ERROR if it
   cannot resolve the parameter for any reason.  */

static struct value *
value_of_dwarf_block_entry (struct type *type, struct frame_info *frame,
			    const gdb_byte *block, size_t block_len)
{
  union call_site_parameter_u kind_u;

  kind_u.dwarf_reg = dwarf_block_to_dwarf_reg (block, block + block_len);
  if (kind_u.dwarf_reg != -1)
    return value_of_dwarf_reg_entry (type, frame, CALL_SITE_PARAMETER_DWARF_REG,
				     kind_u);

  if (dwarf_block_to_fb_offset (block, block + block_len, &kind_u.fb_offset))
    return value_of_dwarf_reg_entry (type, frame, CALL_SITE_PARAMETER_FB_OFFSET,
                                     kind_u);

  /* This can normally happen - throw NO_ENTRY_VALUE_ERROR to get the message
     suppressed during normal operation.  The expression can be arbitrary if
     there is no caller-callee entry value binding expected.  */
  throw_error (NO_ENTRY_VALUE_ERROR,
	       _("DWARF-2 expression error: DW_OP_GNU_entry_value is supported "
		 "only for single DW_OP_reg* or for DW_OP_fbreg(*)"));
}

struct piece_closure
{
  /* Reference count.  */
  int refc;

  /* The CU from which this closure's expression came.  */
  struct dwarf2_per_cu_data *per_cu;

  /* The number of pieces used to describe this variable.  */
  int n_pieces;

  /* The target address size, used only for DWARF_VALUE_STACK.  */
  int addr_size;

  /* The pieces themselves.  */
  struct dwarf_expr_piece *pieces;
};

/* Allocate a closure for a value formed from separately-described
   PIECES.  */

static struct piece_closure *
allocate_piece_closure (struct dwarf2_per_cu_data *per_cu,
			int n_pieces, struct dwarf_expr_piece *pieces,
			int addr_size)
{
  struct piece_closure *c = XZALLOC (struct piece_closure);
  int i;

  c->refc = 1;
  c->per_cu = per_cu;
  c->n_pieces = n_pieces;
  c->addr_size = addr_size;
  c->pieces = XCALLOC (n_pieces, struct dwarf_expr_piece);

  memcpy (c->pieces, pieces, n_pieces * sizeof (struct dwarf_expr_piece));
  for (i = 0; i < n_pieces; ++i)
    if (c->pieces[i].location == DWARF_VALUE_STACK)
      value_incref (c->pieces[i].v.value);

  return c;
}

/* The lowest-level function to extract bits from a byte buffer.
   SOURCE is the buffer.  It is updated if we read to the end of a
   byte.
   SOURCE_OFFSET_BITS is the offset of the first bit to read.  It is
   updated to reflect the number of bits actually read.
   NBITS is the number of bits we want to read.  It is updated to
   reflect the number of bits actually read.  This function may read
   fewer bits.
   BITS_BIG_ENDIAN is taken directly from gdbarch.
   This function returns the extracted bits.  */

static unsigned int
extract_bits_primitive (const gdb_byte **source,
			unsigned int *source_offset_bits,
			int *nbits, int bits_big_endian)
{
  unsigned int avail, mask, datum;

  gdb_assert (*source_offset_bits < 8);

  avail = 8 - *source_offset_bits;
  if (avail > *nbits)
    avail = *nbits;

  mask = (1 << avail) - 1;
  datum = **source;
  if (bits_big_endian)
    datum >>= 8 - (*source_offset_bits + *nbits);
  else
    datum >>= *source_offset_bits;
  datum &= mask;

  *nbits -= avail;
  *source_offset_bits += avail;
  if (*source_offset_bits >= 8)
    {
      *source_offset_bits -= 8;
      ++*source;
    }

  return datum;
}

/* Extract some bits from a source buffer and move forward in the
   buffer.
   
   SOURCE is the source buffer.  It is updated as bytes are read.
   SOURCE_OFFSET_BITS is the offset into SOURCE.  It is updated as
   bits are read.
   NBITS is the number of bits to read.
   BITS_BIG_ENDIAN is taken directly from gdbarch.
   
   This function returns the bits that were read.  */

static unsigned int
extract_bits (const gdb_byte **source, unsigned int *source_offset_bits,
	      int nbits, int bits_big_endian)
{
  unsigned int datum;

  gdb_assert (nbits > 0 && nbits <= 8);

  datum = extract_bits_primitive (source, source_offset_bits, &nbits,
				  bits_big_endian);
  if (nbits > 0)
    {
      unsigned int more;

      more = extract_bits_primitive (source, source_offset_bits, &nbits,
				     bits_big_endian);
      if (bits_big_endian)
	datum <<= nbits;
      else
	more <<= nbits;
      datum |= more;
    }

  return datum;
}

/* Write some bits into a buffer and move forward in the buffer.
   
   DATUM is the bits to write.  The low-order bits of DATUM are used.
   DEST is the destination buffer.  It is updated as bytes are
   written.
   DEST_OFFSET_BITS is the bit offset in DEST at which writing is
   done.
   NBITS is the number of valid bits in DATUM.
   BITS_BIG_ENDIAN is taken directly from gdbarch.  */

static void
insert_bits (unsigned int datum,
	     gdb_byte *dest, unsigned int dest_offset_bits,
	     int nbits, int bits_big_endian)
{
  unsigned int mask;

  gdb_assert (dest_offset_bits + nbits <= 8);

  mask = (1 << nbits) - 1;
  if (bits_big_endian)
    {
      datum <<= 8 - (dest_offset_bits + nbits);
      mask <<= 8 - (dest_offset_bits + nbits);
    }
  else
    {
      datum <<= dest_offset_bits;
      mask <<= dest_offset_bits;
    }

  gdb_assert ((datum & ~mask) == 0);

  *dest = (*dest & ~mask) | datum;
}

/* Copy bits from a source to a destination.
   
   DEST is where the bits should be written.
   DEST_OFFSET_BITS is the bit offset into DEST.
   SOURCE is the source of bits.
   SOURCE_OFFSET_BITS is the bit offset into SOURCE.
   BIT_COUNT is the number of bits to copy.
   BITS_BIG_ENDIAN is taken directly from gdbarch.  */

static void
copy_bitwise (gdb_byte *dest, unsigned int dest_offset_bits,
	      const gdb_byte *source, unsigned int source_offset_bits,
	      unsigned int bit_count,
	      int bits_big_endian)
{
  unsigned int dest_avail;
  int datum;

  /* Reduce everything to byte-size pieces.  */
  dest += dest_offset_bits / 8;
  dest_offset_bits %= 8;
  source += source_offset_bits / 8;
  source_offset_bits %= 8;

  dest_avail = 8 - dest_offset_bits % 8;

  /* See if we can fill the first destination byte.  */
  if (dest_avail < bit_count)
    {
      datum = extract_bits (&source, &source_offset_bits, dest_avail,
			    bits_big_endian);
      insert_bits (datum, dest, dest_offset_bits, dest_avail, bits_big_endian);
      ++dest;
      dest_offset_bits = 0;
      bit_count -= dest_avail;
    }

  /* Now, either DEST_OFFSET_BITS is byte-aligned, or we have fewer
     than 8 bits remaining.  */
  gdb_assert (dest_offset_bits % 8 == 0 || bit_count < 8);
  for (; bit_count >= 8; bit_count -= 8)
    {
      datum = extract_bits (&source, &source_offset_bits, 8, bits_big_endian);
      *dest++ = (gdb_byte) datum;
    }

  /* Finally, we may have a few leftover bits.  */
  gdb_assert (bit_count <= 8 - dest_offset_bits % 8);
  if (bit_count > 0)
    {
      datum = extract_bits (&source, &source_offset_bits, bit_count,
			    bits_big_endian);
      insert_bits (datum, dest, dest_offset_bits, bit_count, bits_big_endian);
    }
}

static void
read_pieced_value (struct value *v)
{
  int i;
  long offset = 0;
  ULONGEST bits_to_skip;
  gdb_byte *contents;
  struct piece_closure *c
    = (struct piece_closure *) value_computed_closure (v);
  struct frame_info *frame = frame_find_by_id (VALUE_FRAME_ID (v));
  size_t type_len;
  size_t buffer_size = 0;
  gdb_byte *buffer = NULL;
  struct cleanup *cleanup;
  int bits_big_endian
    = gdbarch_bits_big_endian (get_type_arch (value_type (v)));

  if (value_type (v) != value_enclosing_type (v))
    internal_error (__FILE__, __LINE__,
		    _("Should not be able to create a lazy value with "
		      "an enclosing type"));

  cleanup = make_cleanup (free_current_contents, &buffer);

  contents = value_contents_raw (v);
  bits_to_skip = 8 * value_offset (v);
  if (value_bitsize (v))
    {
      bits_to_skip += value_bitpos (v);
      type_len = value_bitsize (v);
    }
  else
    type_len = 8 * TYPE_LENGTH (value_type (v));

  for (i = 0; i < c->n_pieces && offset < type_len; i++)
    {
      struct dwarf_expr_piece *p = &c->pieces[i];
      size_t this_size, this_size_bits;
      long dest_offset_bits, source_offset_bits, source_offset;
      const gdb_byte *intermediate_buffer;

      /* Compute size, source, and destination offsets for copying, in
	 bits.  */
      this_size_bits = p->size;
      if (bits_to_skip > 0 && bits_to_skip >= this_size_bits)
	{
	  bits_to_skip -= this_size_bits;
	  continue;
	}
      if (bits_to_skip > 0)
	{
	  dest_offset_bits = 0;
	  source_offset_bits = bits_to_skip;
	  this_size_bits -= bits_to_skip;
	  bits_to_skip = 0;
	}
      else
	{
	  dest_offset_bits = offset;
	  source_offset_bits = 0;
	}
      if (this_size_bits > type_len - offset)
	this_size_bits = type_len - offset;

      this_size = (this_size_bits + source_offset_bits % 8 + 7) / 8;
      source_offset = source_offset_bits / 8;
      if (buffer_size < this_size)
	{
	  buffer_size = this_size;
	  buffer = xrealloc (buffer, buffer_size);
	}
      intermediate_buffer = buffer;

      /* Copy from the source to DEST_BUFFER.  */
      switch (p->location)
	{
	case DWARF_VALUE_REGISTER:
	  {
	    struct gdbarch *arch = get_frame_arch (frame);
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->v.regno);
	    int reg_offset = source_offset;

	    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG
		&& this_size < register_size (arch, gdb_regnum))
	      {
		/* Big-endian, and we want less than full size.  */
		reg_offset = register_size (arch, gdb_regnum) - this_size;
		/* We want the lower-order THIS_SIZE_BITS of the bytes
		   we extract from the register.  */
		source_offset_bits += 8 * this_size - this_size_bits;
	      }

	    if (gdb_regnum != -1)
	      {
		int optim, unavail;

		if (!get_frame_register_bytes (frame, gdb_regnum, reg_offset,
					       this_size, buffer,
					       &optim, &unavail))
		  {
		    /* Just so garbage doesn't ever shine through.  */
		    memset (buffer, 0, this_size);

		    if (optim)
		      set_value_optimized_out (v, 1);
		    if (unavail)
		      mark_value_bytes_unavailable (v, offset, this_size);
		  }
	      }
	    else
	      {
		error (_("Unable to access DWARF register number %s"),
		       paddress (arch, p->v.regno));
	      }
	  }
	  break;

	case DWARF_VALUE_MEMORY:
	  read_value_memory (v, offset,
			     p->v.mem.in_stack_memory,
			     p->v.mem.addr + source_offset,
			     buffer, this_size);
	  break;

	case DWARF_VALUE_STACK:
	  {
	    size_t n = this_size;

	    if (n > c->addr_size - source_offset)
	      n = (c->addr_size >= source_offset
		   ? c->addr_size - source_offset
		   : 0);
	    if (n == 0)
	      {
		/* Nothing.  */
	      }
	    else
	      {
		const gdb_byte *val_bytes = value_contents_all (p->v.value);

		intermediate_buffer = val_bytes + source_offset;
	      }
	  }
	  break;

	case DWARF_VALUE_LITERAL:
	  {
	    size_t n = this_size;

	    if (n > p->v.literal.length - source_offset)
	      n = (p->v.literal.length >= source_offset
		   ? p->v.literal.length - source_offset
		   : 0);
	    if (n != 0)
	      intermediate_buffer = p->v.literal.data + source_offset;
	  }
	  break;

	  /* These bits show up as zeros -- but do not cause the value
	     to be considered optimized-out.  */
	case DWARF_VALUE_IMPLICIT_POINTER:
	  break;

	case DWARF_VALUE_OPTIMIZED_OUT:
	  set_value_optimized_out (v, 1);
	  break;

	default:
	  internal_error (__FILE__, __LINE__, _("invalid location type"));
	}

      if (p->location != DWARF_VALUE_OPTIMIZED_OUT
	  && p->location != DWARF_VALUE_IMPLICIT_POINTER)
	copy_bitwise (contents, dest_offset_bits,
		      intermediate_buffer, source_offset_bits % 8,
		      this_size_bits, bits_big_endian);

      offset += this_size_bits;
    }

  do_cleanups (cleanup);
}

static void
write_pieced_value (struct value *to, struct value *from)
{
  int i;
  long offset = 0;
  ULONGEST bits_to_skip;
  const gdb_byte *contents;
  struct piece_closure *c
    = (struct piece_closure *) value_computed_closure (to);
  struct frame_info *frame = frame_find_by_id (VALUE_FRAME_ID (to));
  size_t type_len;
  size_t buffer_size = 0;
  gdb_byte *buffer = NULL;
  struct cleanup *cleanup;
  int bits_big_endian
    = gdbarch_bits_big_endian (get_type_arch (value_type (to)));

  if (frame == NULL)
    {
      set_value_optimized_out (to, 1);
      return;
    }

  cleanup = make_cleanup (free_current_contents, &buffer);

  contents = value_contents (from);
  bits_to_skip = 8 * value_offset (to);
  if (value_bitsize (to))
    {
      bits_to_skip += value_bitpos (to);
      type_len = value_bitsize (to);
    }
  else
    type_len = 8 * TYPE_LENGTH (value_type (to));

  for (i = 0; i < c->n_pieces && offset < type_len; i++)
    {
      struct dwarf_expr_piece *p = &c->pieces[i];
      size_t this_size_bits, this_size;
      long dest_offset_bits, source_offset_bits, dest_offset, source_offset;
      int need_bitwise;
      const gdb_byte *source_buffer;

      this_size_bits = p->size;
      if (bits_to_skip > 0 && bits_to_skip >= this_size_bits)
	{
	  bits_to_skip -= this_size_bits;
	  continue;
	}
      if (this_size_bits > type_len - offset)
	this_size_bits = type_len - offset;
      if (bits_to_skip > 0)
	{
	  dest_offset_bits = bits_to_skip;
	  source_offset_bits = 0;
	  this_size_bits -= bits_to_skip;
	  bits_to_skip = 0;
	}
      else
	{
	  dest_offset_bits = 0;
	  source_offset_bits = offset;
	}

      this_size = (this_size_bits + source_offset_bits % 8 + 7) / 8;
      source_offset = source_offset_bits / 8;
      dest_offset = dest_offset_bits / 8;
      if (dest_offset_bits % 8 == 0 && source_offset_bits % 8 == 0)
	{
	  source_buffer = contents + source_offset;
	  need_bitwise = 0;
	}
      else
	{
	  if (buffer_size < this_size)
	    {
	      buffer_size = this_size;
	      buffer = xrealloc (buffer, buffer_size);
	    }
	  source_buffer = buffer;
	  need_bitwise = 1;
	}

      switch (p->location)
	{
	case DWARF_VALUE_REGISTER:
	  {
	    struct gdbarch *arch = get_frame_arch (frame);
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->v.regno);
	    int reg_offset = dest_offset;

	    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG
		&& this_size <= register_size (arch, gdb_regnum))
	      /* Big-endian, and we want less than full size.  */
	      reg_offset = register_size (arch, gdb_regnum) - this_size;

	    if (gdb_regnum != -1)
	      {
		if (need_bitwise)
		  {
		    int optim, unavail;

		    if (!get_frame_register_bytes (frame, gdb_regnum, reg_offset,
						   this_size, buffer,
						   &optim, &unavail))
		      {
			if (optim)
			  error (_("Can't do read-modify-write to "
				   "update bitfield; containing word has been "
				   "optimized out"));
			if (unavail)
			  throw_error (NOT_AVAILABLE_ERROR,
				       _("Can't do read-modify-write to update "
					 "bitfield; containing word "
					 "is unavailable"));
		      }
		    copy_bitwise (buffer, dest_offset_bits,
				  contents, source_offset_bits,
				  this_size_bits,
				  bits_big_endian);
		  }

		put_frame_register_bytes (frame, gdb_regnum, reg_offset, 
					  this_size, source_buffer);
	      }
	    else
	      {
		error (_("Unable to write to DWARF register number %s"),
		       paddress (arch, p->v.regno));
	      }
	  }
	  break;
	case DWARF_VALUE_MEMORY:
	  if (need_bitwise)
	    {
	      /* Only the first and last bytes can possibly have any
		 bits reused.  */
	      read_memory (p->v.mem.addr + dest_offset, buffer, 1);
	      read_memory (p->v.mem.addr + dest_offset + this_size - 1,
			   buffer + this_size - 1, 1);
	      copy_bitwise (buffer, dest_offset_bits,
			    contents, source_offset_bits,
			    this_size_bits,
			    bits_big_endian);
	    }

	  write_memory (p->v.mem.addr + dest_offset,
			source_buffer, this_size);
	  break;
	default:
	  set_value_optimized_out (to, 1);
	  break;
	}
      offset += this_size_bits;
    }

  do_cleanups (cleanup);
}

/* A helper function that checks bit validity in a pieced value.
   CHECK_FOR indicates the kind of validity checking.
   DWARF_VALUE_MEMORY means to check whether any bit is valid.
   DWARF_VALUE_OPTIMIZED_OUT means to check whether any bit is
   optimized out.
   DWARF_VALUE_IMPLICIT_POINTER means to check whether the bits are an
   implicit pointer.  */

static int
check_pieced_value_bits (const struct value *value, int bit_offset,
			 int bit_length,
			 enum dwarf_value_location check_for)
{
  struct piece_closure *c
    = (struct piece_closure *) value_computed_closure (value);
  int i;
  int validity = (check_for == DWARF_VALUE_MEMORY
		  || check_for == DWARF_VALUE_IMPLICIT_POINTER);

  bit_offset += 8 * value_offset (value);
  if (value_bitsize (value))
    bit_offset += value_bitpos (value);

  for (i = 0; i < c->n_pieces && bit_length > 0; i++)
    {
      struct dwarf_expr_piece *p = &c->pieces[i];
      size_t this_size_bits = p->size;

      if (bit_offset > 0)
	{
	  if (bit_offset >= this_size_bits)
	    {
	      bit_offset -= this_size_bits;
	      continue;
	    }

	  bit_length -= this_size_bits - bit_offset;
	  bit_offset = 0;
	}
      else
	bit_length -= this_size_bits;

      if (check_for == DWARF_VALUE_IMPLICIT_POINTER)
	{
	  if (p->location != DWARF_VALUE_IMPLICIT_POINTER)
	    return 0;
	}
      else if (p->location == DWARF_VALUE_OPTIMIZED_OUT
	       || p->location == DWARF_VALUE_IMPLICIT_POINTER)
	{
	  if (validity)
	    return 0;
	}
      else
	{
	  if (!validity)
	    return 1;
	}
    }

  return validity;
}

static int
check_pieced_value_validity (const struct value *value, int bit_offset,
			     int bit_length)
{
  return check_pieced_value_bits (value, bit_offset, bit_length,
				  DWARF_VALUE_MEMORY);
}

static int
check_pieced_value_invalid (const struct value *value)
{
  return check_pieced_value_bits (value, 0,
				  8 * TYPE_LENGTH (value_type (value)),
				  DWARF_VALUE_OPTIMIZED_OUT);
}

/* An implementation of an lval_funcs method to see whether a value is
   a synthetic pointer.  */

static int
check_pieced_synthetic_pointer (const struct value *value, int bit_offset,
				int bit_length)
{
  return check_pieced_value_bits (value, bit_offset, bit_length,
				  DWARF_VALUE_IMPLICIT_POINTER);
}

/* A wrapper function for get_frame_address_in_block.  */

static CORE_ADDR
get_frame_address_in_block_wrapper (void *baton)
{
  return get_frame_address_in_block (baton);
}

/* An implementation of an lval_funcs method to indirect through a
   pointer.  This handles the synthetic pointer case when needed.  */

static struct value *
indirect_pieced_value (struct value *value)
{
  struct piece_closure *c
    = (struct piece_closure *) value_computed_closure (value);
  struct type *type;
  struct frame_info *frame;
  struct dwarf2_locexpr_baton baton;
  int i, bit_offset, bit_length;
  struct dwarf_expr_piece *piece = NULL;
  LONGEST byte_offset;

  type = check_typedef (value_type (value));
  if (TYPE_CODE (type) != TYPE_CODE_PTR)
    return NULL;

  bit_length = 8 * TYPE_LENGTH (type);
  bit_offset = 8 * value_offset (value);
  if (value_bitsize (value))
    bit_offset += value_bitpos (value);

  for (i = 0; i < c->n_pieces && bit_length > 0; i++)
    {
      struct dwarf_expr_piece *p = &c->pieces[i];
      size_t this_size_bits = p->size;

      if (bit_offset > 0)
	{
	  if (bit_offset >= this_size_bits)
	    {
	      bit_offset -= this_size_bits;
	      continue;
	    }

	  bit_length -= this_size_bits - bit_offset;
	  bit_offset = 0;
	}
      else
	bit_length -= this_size_bits;

      if (p->location != DWARF_VALUE_IMPLICIT_POINTER)
	return NULL;

      if (bit_length != 0)
	error (_("Invalid use of DW_OP_GNU_implicit_pointer"));

      piece = p;
      break;
    }

  frame = get_selected_frame (_("No frame selected."));

  /* This is an offset requested by GDB, such as value subscripts.
     However, due to how synthetic pointers are implemented, this is
     always presented to us as a pointer type.  This means we have to
     sign-extend it manually as appropriate.  */
  byte_offset = value_as_address (value);
  if (TYPE_LENGTH (value_type (value)) < sizeof (LONGEST))
    byte_offset = gdb_sign_extend (byte_offset,
				   8 * TYPE_LENGTH (value_type (value)));
  byte_offset += piece->v.ptr.offset;

  gdb_assert (piece);
  baton
    = dwarf2_fetch_die_loc_sect_off (piece->v.ptr.die, c->per_cu,
				     get_frame_address_in_block_wrapper,
				     frame);

  if (baton.data != NULL)
    return dwarf2_evaluate_loc_desc_full (TYPE_TARGET_TYPE (type), frame,
					  baton.data, baton.size, baton.per_cu,
					  byte_offset);

  {
    struct obstack temp_obstack;
    struct cleanup *cleanup;
    const gdb_byte *bytes;
    LONGEST len;
    struct value *result;

    obstack_init (&temp_obstack);
    cleanup = make_cleanup_obstack_free (&temp_obstack);

    bytes = dwarf2_fetch_constant_bytes (piece->v.ptr.die, c->per_cu,
					 &temp_obstack, &len);
    if (bytes == NULL)
      result = allocate_optimized_out_value (TYPE_TARGET_TYPE (type));
    else
      {
	if (byte_offset < 0
	    || byte_offset + TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > len)
	  invalid_synthetic_pointer ();
	bytes += byte_offset;
	result = value_from_contents (TYPE_TARGET_TYPE (type), bytes);
      }

    do_cleanups (cleanup);
    return result;
  }
}

static void *
copy_pieced_value_closure (const struct value *v)
{
  struct piece_closure *c
    = (struct piece_closure *) value_computed_closure (v);
  
  ++c->refc;
  return c;
}

static void
free_pieced_value_closure (struct value *v)
{
  struct piece_closure *c
    = (struct piece_closure *) value_computed_closure (v);

  --c->refc;
  if (c->refc == 0)
    {
      int i;

      for (i = 0; i < c->n_pieces; ++i)
	if (c->pieces[i].location == DWARF_VALUE_STACK)
	  value_free (c->pieces[i].v.value);

      xfree (c->pieces);
      xfree (c);
    }
}

/* Functions for accessing a variable described by DW_OP_piece.  */
static const struct lval_funcs pieced_value_funcs = {
  read_pieced_value,
  write_pieced_value,
  check_pieced_value_validity,
  check_pieced_value_invalid,
  indirect_pieced_value,
  NULL,	/* coerce_ref */
  check_pieced_synthetic_pointer,
  copy_pieced_value_closure,
  free_pieced_value_closure
};

/* Virtual method table for dwarf2_evaluate_loc_desc_full below.  */

static const struct dwarf_expr_context_funcs dwarf_expr_ctx_funcs =
{
  dwarf_expr_read_reg,
  dwarf_expr_read_mem,
  dwarf_expr_frame_base,
  dwarf_expr_frame_cfa,
  dwarf_expr_frame_pc,
  dwarf_expr_tls_address,
  dwarf_expr_dwarf_call,
  dwarf_expr_get_base_type,
  dwarf_expr_push_dwarf_reg_entry_value,
  dwarf_expr_get_addr_index
};

/* Evaluate a location description, starting at DATA and with length
   SIZE, to find the current location of variable of TYPE in the
   context of FRAME.  BYTE_OFFSET is applied after the contents are
   computed.  */

static struct value *
dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,
			       const gdb_byte *data, size_t size,
			       struct dwarf2_per_cu_data *per_cu,
			       LONGEST byte_offset)
{
  struct value *retval;
  struct dwarf_expr_baton baton;
  struct dwarf_expr_context *ctx;
  struct cleanup *old_chain, *value_chain;
  struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);
  volatile struct gdb_exception ex;

  if (byte_offset < 0)
    invalid_synthetic_pointer ();

  if (size == 0)
    return allocate_optimized_out_value (type);

  baton.frame = frame;
  baton.per_cu = per_cu;

  ctx = new_dwarf_expr_context ();
  old_chain = make_cleanup_free_dwarf_expr_context (ctx);
  value_chain = make_cleanup_value_free_to_mark (value_mark ());

  ctx->gdbarch = get_objfile_arch (objfile);
  ctx->addr_size = dwarf2_per_cu_addr_size (per_cu);
  ctx->ref_addr_size = dwarf2_per_cu_ref_addr_size (per_cu);
  ctx->offset = dwarf2_per_cu_text_offset (per_cu);
  ctx->baton = &baton;
  ctx->funcs = &dwarf_expr_ctx_funcs;

  TRY_CATCH (ex, RETURN_MASK_ERROR)
    {
      dwarf_expr_eval (ctx, data, size);
    }
  if (ex.reason < 0)
    {
      if (ex.error == NOT_AVAILABLE_ERROR)
	{
	  do_cleanups (old_chain);
	  retval = allocate_value (type);
	  mark_value_bytes_unavailable (retval, 0, TYPE_LENGTH (type));
	  return retval;
	}
      else if (ex.error == NO_ENTRY_VALUE_ERROR)
	{
	  if (entry_values_debug)
	    exception_print (gdb_stdout, ex);
	  do_cleanups (old_chain);
	  return allocate_optimized_out_value (type);
	}
      else
	throw_exception (ex);
    }

  if (ctx->num_pieces > 0)
    {
      struct piece_closure *c;
      struct frame_id frame_id = get_frame_id (frame);
      ULONGEST bit_size = 0;
      int i;

      for (i = 0; i < ctx->num_pieces; ++i)
	bit_size += ctx->pieces[i].size;
      if (8 * (byte_offset + TYPE_LENGTH (type)) > bit_size)
	invalid_synthetic_pointer ();

      c = allocate_piece_closure (per_cu, ctx->num_pieces, ctx->pieces,
				  ctx->addr_size);
      /* We must clean up the value chain after creating the piece
	 closure but before allocating the result.  */
      do_cleanups (value_chain);
      retval = allocate_computed_value (type, &pieced_value_funcs, c);
      VALUE_FRAME_ID (retval) = frame_id;
      set_value_offset (retval, byte_offset);
    }
  else
    {
      switch (ctx->location)
	{
	case DWARF_VALUE_REGISTER:
	  {
	    struct gdbarch *arch = get_frame_arch (frame);
	    int dwarf_regnum
	      = longest_to_int (value_as_long (dwarf_expr_fetch (ctx, 0)));
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, dwarf_regnum);

	    if (byte_offset != 0)
	      error (_("cannot use offset on synthetic pointer to register"));
	    do_cleanups (value_chain);
	   if (gdb_regnum == -1)
	      error (_("Unable to access DWARF register number %d"),
		     dwarf_regnum);
	   retval = value_from_register (type, gdb_regnum, frame);
	   if (value_optimized_out (retval))
	     {
	       /* This means the register has undefined value / was
		  not saved.  As we're computing the location of some
		  variable etc. in the program, not a value for
		  inspecting a register ($pc, $sp, etc.), return a
		  generic optimized out value instead, so that we show
		  <optimized out> instead of <not saved>.  */
	       do_cleanups (value_chain);
	       retval = allocate_optimized_out_value (type);
	     }
	  }
	  break;

	case DWARF_VALUE_MEMORY:
	  {
	    CORE_ADDR address = dwarf_expr_fetch_address (ctx, 0);
	    int in_stack_memory = dwarf_expr_fetch_in_stack_memory (ctx, 0);

	    do_cleanups (value_chain);
	    retval = value_at_lazy (type, address + byte_offset);
	    if (in_stack_memory)
	      set_value_stack (retval, 1);
	  }
	  break;

	case DWARF_VALUE_STACK:
	  {
	    struct value *value = dwarf_expr_fetch (ctx, 0);
	    gdb_byte *contents;
	    const gdb_byte *val_bytes;
	    size_t n = TYPE_LENGTH (value_type (value));

	    if (byte_offset + TYPE_LENGTH (type) > n)
	      invalid_synthetic_pointer ();

	    val_bytes = value_contents_all (value);
	    val_bytes += byte_offset;
	    n -= byte_offset;

	    /* Preserve VALUE because we are going to free values back
	       to the mark, but we still need the value contents
	       below.  */
	    value_incref (value);
	    do_cleanups (value_chain);
	    make_cleanup_value_free (value);

	    retval = allocate_value (type);
	    contents = value_contents_raw (retval);
	    if (n > TYPE_LENGTH (type))
	      {
		struct gdbarch *objfile_gdbarch = get_objfile_arch (objfile);

		if (gdbarch_byte_order (objfile_gdbarch) == BFD_ENDIAN_BIG)
		  val_bytes += n - TYPE_LENGTH (type);
		n = TYPE_LENGTH (type);
	      }
	    memcpy (contents, val_bytes, n);
	  }
	  break;

	case DWARF_VALUE_LITERAL:
	  {
	    bfd_byte *contents;
	    const bfd_byte *ldata;
	    size_t n = ctx->len;

	    if (byte_offset + TYPE_LENGTH (type) > n)
	      invalid_synthetic_pointer ();

	    do_cleanups (value_chain);
	    retval = allocate_value (type);
	    contents = value_contents_raw (retval);

	    ldata = ctx->data + byte_offset;
	    n -= byte_offset;

	    if (n > TYPE_LENGTH (type))
	      {
		struct gdbarch *objfile_gdbarch = get_objfile_arch (objfile);

		if (gdbarch_byte_order (objfile_gdbarch) == BFD_ENDIAN_BIG)
		  ldata += n - TYPE_LENGTH (type);
		n = TYPE_LENGTH (type);
	      }
	    memcpy (contents, ldata, n);
	  }
	  break;

	case DWARF_VALUE_OPTIMIZED_OUT:
	  do_cleanups (value_chain);
	  retval = allocate_optimized_out_value (type);
	  break;

	  /* DWARF_VALUE_IMPLICIT_POINTER was converted to a pieced
	     operation by execute_stack_op.  */
	case DWARF_VALUE_IMPLICIT_POINTER:
	  /* DWARF_VALUE_OPTIMIZED_OUT can't occur in this context --
	     it can only be encountered when making a piece.  */
	default:
	  internal_error (__FILE__, __LINE__, _("invalid location type"));
	}
    }

  set_value_initialized (retval, ctx->initialized);

  do_cleanups (old_chain);

  return retval;
}

/* The exported interface to dwarf2_evaluate_loc_desc_full; it always
   passes 0 as the byte_offset.  */

struct value *
dwarf2_evaluate_loc_desc (struct type *type, struct frame_info *frame,
			  const gdb_byte *data, size_t size,
			  struct dwarf2_per_cu_data *per_cu)
{
  return dwarf2_evaluate_loc_desc_full (type, frame, data, size, per_cu, 0);
}


/* Helper functions and baton for dwarf2_loc_desc_needs_frame.  */

struct needs_frame_baton
{
  int needs_frame;
  struct dwarf2_per_cu_data *per_cu;
};

/* Reads from registers do require a frame.  */
static CORE_ADDR
needs_frame_read_reg (void *baton, int regnum)
{
  struct needs_frame_baton *nf_baton = baton;

  nf_baton->needs_frame = 1;
  return 1;
}

/* Reads from memory do not require a frame.  */
static void
needs_frame_read_mem (void *baton, gdb_byte *buf, CORE_ADDR addr, size_t len)
{
  memset (buf, 0, len);
}

/* Frame-relative accesses do require a frame.  */
static void
needs_frame_frame_base (void *baton, const gdb_byte **start, size_t * length)
{
  static gdb_byte lit0 = DW_OP_lit0;
  struct needs_frame_baton *nf_baton = baton;

  *start = &lit0;
  *length = 1;

  nf_baton->needs_frame = 1;
}

/* CFA accesses require a frame.  */

static CORE_ADDR
needs_frame_frame_cfa (void *baton)
{
  struct needs_frame_baton *nf_baton = baton;

  nf_baton->needs_frame = 1;
  return 1;
}

/* Thread-local accesses do require a frame.  */
static CORE_ADDR
needs_frame_tls_address (void *baton, CORE_ADDR offset)
{
  struct needs_frame_baton *nf_baton = baton;

  nf_baton->needs_frame = 1;
  return 1;
}

/* Helper interface of per_cu_dwarf_call for dwarf2_loc_desc_needs_frame.  */

static void
needs_frame_dwarf_call (struct dwarf_expr_context *ctx, cu_offset die_offset)
{
  struct needs_frame_baton *nf_baton = ctx->baton;

  per_cu_dwarf_call (ctx, die_offset, nf_baton->per_cu,
		     ctx->funcs->get_frame_pc, ctx->baton);
}

/* DW_OP_GNU_entry_value accesses require a caller, therefore a frame.  */

static void
needs_dwarf_reg_entry_value (struct dwarf_expr_context *ctx,
			     enum call_site_parameter_kind kind,
			     union call_site_parameter_u kind_u, int deref_size)
{
  struct needs_frame_baton *nf_baton = ctx->baton;

  nf_baton->needs_frame = 1;

  /* The expression may require some stub values on DWARF stack.  */
  dwarf_expr_push_address (ctx, 0, 0);
}

/* DW_OP_GNU_addr_index doesn't require a frame.  */

static CORE_ADDR
needs_get_addr_index (void *baton, unsigned int index)
{
  /* Nothing to do.  */
  return 1;
}

/* Virtual method table for dwarf2_loc_desc_needs_frame below.  */

static const struct dwarf_expr_context_funcs needs_frame_ctx_funcs =
{
  needs_frame_read_reg,
  needs_frame_read_mem,
  needs_frame_frame_base,
  needs_frame_frame_cfa,
  needs_frame_frame_cfa,	/* get_frame_pc */
  needs_frame_tls_address,
  needs_frame_dwarf_call,
  NULL,				/* get_base_type */
  needs_dwarf_reg_entry_value,
  needs_get_addr_index
};

/* Return non-zero iff the location expression at DATA (length SIZE)
   requires a frame to evaluate.  */

static int
dwarf2_loc_desc_needs_frame (const gdb_byte *data, size_t size,
			     struct dwarf2_per_cu_data *per_cu)
{
  struct needs_frame_baton baton;
  struct dwarf_expr_context *ctx;
  int in_reg;
  struct cleanup *old_chain;
  struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);

  baton.needs_frame = 0;
  baton.per_cu = per_cu;

  ctx = new_dwarf_expr_context ();
  old_chain = make_cleanup_free_dwarf_expr_context (ctx);
  make_cleanup_value_free_to_mark (value_mark ());

  ctx->gdbarch = get_objfile_arch (objfile);
  ctx->addr_size = dwarf2_per_cu_addr_size (per_cu);
  ctx->ref_addr_size = dwarf2_per_cu_ref_addr_size (per_cu);
  ctx->offset = dwarf2_per_cu_text_offset (per_cu);
  ctx->baton = &baton;
  ctx->funcs = &needs_frame_ctx_funcs;

  dwarf_expr_eval (ctx, data, size);

  in_reg = ctx->location == DWARF_VALUE_REGISTER;

  if (ctx->num_pieces > 0)
    {
      int i;

      /* If the location has several pieces, and any of them are in
         registers, then we will need a frame to fetch them from.  */
      for (i = 0; i < ctx->num_pieces; i++)
        if (ctx->pieces[i].location == DWARF_VALUE_REGISTER)
          in_reg = 1;
    }

  do_cleanups (old_chain);

  return baton.needs_frame || in_reg;
}

/* A helper function that throws an unimplemented error mentioning a
   given DWARF operator.  */

static void
unimplemented (unsigned int op)
{
  const char *name = get_DW_OP_name (op);

  if (name)
    error (_("DWARF operator %s cannot be translated to an agent expression"),
	   name);
  else
    error (_("Unknown DWARF operator 0x%02x cannot be translated "
	     "to an agent expression"),
	   op);
}

/* A helper function to convert a DWARF register to an arch register.
   ARCH is the architecture.
   DWARF_REG is the register.
   This will throw an exception if the DWARF register cannot be
   translated to an architecture register.  */

static int
translate_register (struct gdbarch *arch, int dwarf_reg)
{
  int reg = gdbarch_dwarf2_reg_to_regnum (arch, dwarf_reg);
  if (reg == -1)
    error (_("Unable to access DWARF register number %d"), dwarf_reg);
  return reg;
}

/* A helper function that emits an access to memory.  ARCH is the
   target architecture.  EXPR is the expression which we are building.
   NBITS is the number of bits we want to read.  This emits the
   opcodes needed to read the memory and then extract the desired
   bits.  */

static void
access_memory (struct gdbarch *arch, struct agent_expr *expr, ULONGEST nbits)
{
  ULONGEST nbytes = (nbits + 7) / 8;

  gdb_assert (nbytes > 0 && nbytes <= sizeof (LONGEST));

  if (expr->tracing)
    ax_trace_quick (expr, nbytes);

  if (nbits <= 8)
    ax_simple (expr, aop_ref8);
  else if (nbits <= 16)
    ax_simple (expr, aop_ref16);
  else if (nbits <= 32)
    ax_simple (expr, aop_ref32);
  else
    ax_simple (expr, aop_ref64);

  /* If we read exactly the number of bytes we wanted, we're done.  */
  if (8 * nbytes == nbits)
    return;

  if (gdbarch_bits_big_endian (arch))
    {
      /* On a bits-big-endian machine, we want the high-order
	 NBITS.  */
      ax_const_l (expr, 8 * nbytes - nbits);
      ax_simple (expr, aop_rsh_unsigned);
    }
  else
    {
      /* On a bits-little-endian box, we want the low-order NBITS.  */
      ax_zero_ext (expr, nbits);
    }
}

/* A helper function to return the frame's PC.  */

static CORE_ADDR
get_ax_pc (void *baton)
{
  struct agent_expr *expr = baton;

  return expr->scope;
}

/* Compile a DWARF location expression to an agent expression.
   
   EXPR is the agent expression we are building.
   LOC is the agent value we modify.
   ARCH is the architecture.
   ADDR_SIZE is the size of addresses, in bytes.
   OP_PTR is the start of the location expression.
   OP_END is one past the last byte of the location expression.
   
   This will throw an exception for various kinds of errors -- for
   example, if the expression cannot be compiled, or if the expression
   is invalid.  */

void
dwarf2_compile_expr_to_ax (struct agent_expr *expr, struct axs_value *loc,
			   struct gdbarch *arch, unsigned int addr_size,
			   const gdb_byte *op_ptr, const gdb_byte *op_end,
			   struct dwarf2_per_cu_data *per_cu)
{
  struct cleanup *cleanups;
  int i, *offsets;
  VEC(int) *dw_labels = NULL, *patches = NULL;
  const gdb_byte * const base = op_ptr;
  const gdb_byte *previous_piece = op_ptr;
  enum bfd_endian byte_order = gdbarch_byte_order (arch);
  ULONGEST bits_collected = 0;
  unsigned int addr_size_bits = 8 * addr_size;
  int bits_big_endian = gdbarch_bits_big_endian (arch);

  offsets = xmalloc ((op_end - op_ptr) * sizeof (int));
  cleanups = make_cleanup (xfree, offsets);

  for (i = 0; i < op_end - op_ptr; ++i)
    offsets[i] = -1;

  make_cleanup (VEC_cleanup (int), &dw_labels);
  make_cleanup (VEC_cleanup (int), &patches);

  /* By default we are making an address.  */
  loc->kind = axs_lvalue_memory;

  while (op_ptr < op_end)
    {
      enum dwarf_location_atom op = *op_ptr;
      uint64_t uoffset, reg;
      int64_t offset;
      int i;

      offsets[op_ptr - base] = expr->len;
      ++op_ptr;

      /* Our basic approach to code generation is to map DWARF
	 operations directly to AX operations.  However, there are
	 some differences.

	 First, DWARF works on address-sized units, but AX always uses
	 LONGEST.  For most operations we simply ignore this
	 difference; instead we generate sign extensions as needed
	 before division and comparison operations.  It would be nice
	 to omit the sign extensions, but there is no way to determine
	 the size of the target's LONGEST.  (This code uses the size
	 of the host LONGEST in some cases -- that is a bug but it is
	 difficult to fix.)

	 Second, some DWARF operations cannot be translated to AX.
	 For these we simply fail.  See
	 http://sourceware.org/bugzilla/show_bug.cgi?id=11662.  */
      switch (op)
	{
	case DW_OP_lit0:
	case DW_OP_lit1:
	case DW_OP_lit2:
	case DW_OP_lit3:
	case DW_OP_lit4:
	case DW_OP_lit5:
	case DW_OP_lit6:
	case DW_OP_lit7:
	case DW_OP_lit8:
	case DW_OP_lit9:
	case DW_OP_lit10:
	case DW_OP_lit11:
	case DW_OP_lit12:
	case DW_OP_lit13:
	case DW_OP_lit14:
	case DW_OP_lit15:
	case DW_OP_lit16:
	case DW_OP_lit17:
	case DW_OP_lit18:
	case DW_OP_lit19:
	case DW_OP_lit20:
	case DW_OP_lit21:
	case DW_OP_lit22:
	case DW_OP_lit23:
	case DW_OP_lit24:
	case DW_OP_lit25:
	case DW_OP_lit26:
	case DW_OP_lit27:
	case DW_OP_lit28:
	case DW_OP_lit29:
	case DW_OP_lit30:
	case DW_OP_lit31:
	  ax_const_l (expr, op - DW_OP_lit0);
	  break;

	case DW_OP_addr:
	  uoffset = extract_unsigned_integer (op_ptr, addr_size, byte_order);
	  op_ptr += addr_size;
	  /* Some versions of GCC emit DW_OP_addr before
	     DW_OP_GNU_push_tls_address.  In this case the value is an
	     index, not an address.  We don't support things like
	     branching between the address and the TLS op.  */
	  if (op_ptr >= op_end || *op_ptr != DW_OP_GNU_push_tls_address)
	    uoffset += dwarf2_per_cu_text_offset (per_cu);
	  ax_const_l (expr, uoffset);
	  break;

	case DW_OP_const1u:
	  ax_const_l (expr, extract_unsigned_integer (op_ptr, 1, byte_order));
	  op_ptr += 1;
	  break;
	case DW_OP_const1s:
	  ax_const_l (expr, extract_signed_integer (op_ptr, 1, byte_order));
	  op_ptr += 1;
	  break;
	case DW_OP_const2u:
	  ax_const_l (expr, extract_unsigned_integer (op_ptr, 2, byte_order));
	  op_ptr += 2;
	  break;
	case DW_OP_const2s:
	  ax_const_l (expr, extract_signed_integer (op_ptr, 2, byte_order));
	  op_ptr += 2;
	  break;
	case DW_OP_const4u:
	  ax_const_l (expr, extract_unsigned_integer (op_ptr, 4, byte_order));
	  op_ptr += 4;
	  break;
	case DW_OP_const4s:
	  ax_const_l (expr, extract_signed_integer (op_ptr, 4, byte_order));
	  op_ptr += 4;
	  break;
	case DW_OP_const8u:
	  ax_const_l (expr, extract_unsigned_integer (op_ptr, 8, byte_order));
	  op_ptr += 8;
	  break;
	case DW_OP_const8s:
	  ax_const_l (expr, extract_signed_integer (op_ptr, 8, byte_order));
	  op_ptr += 8;
	  break;
	case DW_OP_constu:
	  op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);
	  ax_const_l (expr, uoffset);
	  break;
	case DW_OP_consts:
	  op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);
	  ax_const_l (expr, offset);
	  break;

	case DW_OP_reg0:
	case DW_OP_reg1:
	case DW_OP_reg2:
	case DW_OP_reg3:
	case DW_OP_reg4:
	case DW_OP_reg5:
	case DW_OP_reg6:
	case DW_OP_reg7:
	case DW_OP_reg8:
	case DW_OP_reg9:
	case DW_OP_reg10:
	case DW_OP_reg11:
	case DW_OP_reg12:
	case DW_OP_reg13:
	case DW_OP_reg14:
	case DW_OP_reg15:
	case DW_OP_reg16:
	case DW_OP_reg17:
	case DW_OP_reg18:
	case DW_OP_reg19:
	case DW_OP_reg20:
	case DW_OP_reg21:
	case DW_OP_reg22:
	case DW_OP_reg23:
	case DW_OP_reg24:
	case DW_OP_reg25:
	case DW_OP_reg26:
	case DW_OP_reg27:
	case DW_OP_reg28:
	case DW_OP_reg29:
	case DW_OP_reg30:
	case DW_OP_reg31:
	  dwarf_expr_require_composition (op_ptr, op_end, "DW_OP_regx");
	  loc->u.reg = translate_register (arch, op - DW_OP_reg0);
	  loc->kind = axs_lvalue_register;
	  break;

	case DW_OP_regx:
	  op_ptr = safe_read_uleb128 (op_ptr, op_end, &reg);
	  dwarf_expr_require_composition (op_ptr, op_end, "DW_OP_regx");
	  loc->u.reg = translate_register (arch, reg);
	  loc->kind = axs_lvalue_register;
	  break;

	case DW_OP_implicit_value:
	  {
	    uint64_t len;

	    op_ptr = safe_read_uleb128 (op_ptr, op_end, &len);
	    if (op_ptr + len > op_end)
	      error (_("DW_OP_implicit_value: too few bytes available."));
	    if (len > sizeof (ULONGEST))
	      error (_("Cannot translate DW_OP_implicit_value of %d bytes"),
		     (int) len);

	    ax_const_l (expr, extract_unsigned_integer (op_ptr, len,
							byte_order));
	    op_ptr += len;
	    dwarf_expr_require_composition (op_ptr, op_end,
					    "DW_OP_implicit_value");

	    loc->kind = axs_rvalue;
	  }
	  break;

	case DW_OP_stack_value:
	  dwarf_expr_require_composition (op_ptr, op_end, "DW_OP_stack_value");
	  loc->kind = axs_rvalue;
	  break;

	case DW_OP_breg0:
	case DW_OP_breg1:
	case DW_OP_breg2:
	case DW_OP_breg3:
	case DW_OP_breg4:
	case DW_OP_breg5:
	case DW_OP_breg6:
	case DW_OP_breg7:
	case DW_OP_breg8:
	case DW_OP_breg9:
	case DW_OP_breg10:
	case DW_OP_breg11:
	case DW_OP_breg12:
	case DW_OP_breg13:
	case DW_OP_breg14:
	case DW_OP_breg15:
	case DW_OP_breg16:
	case DW_OP_breg17:
	case DW_OP_breg18:
	case DW_OP_breg19:
	case DW_OP_breg20:
	case DW_OP_breg21:
	case DW_OP_breg22:
	case DW_OP_breg23:
	case DW_OP_breg24:
	case DW_OP_breg25:
	case DW_OP_breg26:
	case DW_OP_breg27:
	case DW_OP_breg28:
	case DW_OP_breg29:
	case DW_OP_breg30:
	case DW_OP_breg31:
	  op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);
	  i = translate_register (arch, op - DW_OP_breg0);
	  ax_reg (expr, i);
	  if (offset != 0)
	    {
	      ax_const_l (expr, offset);
	      ax_simple (expr, aop_add);
	    }
	  break;
	case DW_OP_bregx:
	  {
	    op_ptr = safe_read_uleb128 (op_ptr, op_end, &reg);
	    op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);
	    i = translate_register (arch, reg);
	    ax_reg (expr, i);
	    if (offset != 0)
	      {
		ax_const_l (expr, offset);
		ax_simple (expr, aop_add);
	      }
	  }
	  break;
	case DW_OP_fbreg:
	  {
	    const gdb_byte *datastart;
	    size_t datalen;
	    struct block *b;
	    struct symbol *framefunc;

	    b = block_for_pc (expr->scope);

	    if (!b)
	      error (_("No block found for address"));

	    framefunc = block_linkage_function (b);

	    if (!framefunc)
	      error (_("No function found for block"));

	    dwarf_expr_frame_base_1 (framefunc, expr->scope,
				     &datastart, &datalen);

	    op_ptr = safe_read_sleb128 (op_ptr, op_end, &offset);
	    dwarf2_compile_expr_to_ax (expr, loc, arch, addr_size, datastart,
				       datastart + datalen, per_cu);
	    if (loc->kind == axs_lvalue_register)
	      require_rvalue (expr, loc);

	    if (offset != 0)
	      {
		ax_const_l (expr, offset);
		ax_simple (expr, aop_add);
	      }

	    loc->kind = axs_lvalue_memory;
	  }
	  break;

	case DW_OP_dup:
	  ax_simple (expr, aop_dup);
	  break;

	case DW_OP_drop:
	  ax_simple (expr, aop_pop);
	  break;

	case DW_OP_pick:
	  offset = *op_ptr++;
	  ax_pick (expr, offset);
	  break;
	  
	case DW_OP_swap:
	  ax_simple (expr, aop_swap);
	  break;

	case DW_OP_over:
	  ax_pick (expr, 1);
	  break;

	case DW_OP_rot:
	  ax_simple (expr, aop_rot);
	  break;

	case DW_OP_deref:
	case DW_OP_deref_size:
	  {
	    int size;

	    if (op == DW_OP_deref_size)
	      size = *op_ptr++;
	    else
	      size = addr_size;

	    if (size != 1 && size != 2 && size != 4 && size != 8)
	      error (_("Unsupported size %d in %s"),
		     size, get_DW_OP_name (op));
	    access_memory (arch, expr, size * TARGET_CHAR_BIT);
	  }
	  break;

	case DW_OP_abs:
	  /* Sign extend the operand.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_dup);
	  ax_const_l (expr, 0);
	  ax_simple (expr, aop_less_signed);
	  ax_simple (expr, aop_log_not);
	  i = ax_goto (expr, aop_if_goto);
	  /* We have to emit 0 - X.  */
	  ax_const_l (expr, 0);
	  ax_simple (expr, aop_swap);
	  ax_simple (expr, aop_sub);
	  ax_label (expr, i, expr->len);
	  break;

	case DW_OP_neg:
	  /* No need to sign extend here.  */
	  ax_const_l (expr, 0);
	  ax_simple (expr, aop_swap);
	  ax_simple (expr, aop_sub);
	  break;

	case DW_OP_not:
	  /* Sign extend the operand.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_bit_not);
	  break;

	case DW_OP_plus_uconst:
	  op_ptr = safe_read_uleb128 (op_ptr, op_end, &reg);
	  /* It would be really weird to emit `DW_OP_plus_uconst 0',
	     but we micro-optimize anyhow.  */
	  if (reg != 0)
	    {
	      ax_const_l (expr, reg);
	      ax_simple (expr, aop_add);
	    }
	  break;

	case DW_OP_and:
	  ax_simple (expr, aop_bit_and);
	  break;

	case DW_OP_div:
	  /* Sign extend the operands.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_simple (expr, aop_div_signed);
	  break;

	case DW_OP_minus:
	  ax_simple (expr, aop_sub);
	  break;

	case DW_OP_mod:
	  ax_simple (expr, aop_rem_unsigned);
	  break;

	case DW_OP_mul:
	  ax_simple (expr, aop_mul);
	  break;

	case DW_OP_or:
	  ax_simple (expr, aop_bit_or);
	  break;

	case DW_OP_plus:
	  ax_simple (expr, aop_add);
	  break;

	case DW_OP_shl:
	  ax_simple (expr, aop_lsh);
	  break;

	case DW_OP_shr:
	  ax_simple (expr, aop_rsh_unsigned);
	  break;

	case DW_OP_shra:
	  ax_simple (expr, aop_rsh_signed);
	  break;

	case DW_OP_xor:
	  ax_simple (expr, aop_bit_xor);
	  break;

	case DW_OP_le:
	  /* Sign extend the operands.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_ext (expr, addr_size_bits);
	  /* Note no swap here: A <= B is !(B < A).  */
	  ax_simple (expr, aop_less_signed);
	  ax_simple (expr, aop_log_not);
	  break;

	case DW_OP_ge:
	  /* Sign extend the operands.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  /* A >= B is !(A < B).  */
	  ax_simple (expr, aop_less_signed);
	  ax_simple (expr, aop_log_not);
	  break;

	case DW_OP_eq:
	  /* Sign extend the operands.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_ext (expr, addr_size_bits);
	  /* No need for a second swap here.  */
	  ax_simple (expr, aop_equal);
	  break;

	case DW_OP_lt:
	  /* Sign extend the operands.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_simple (expr, aop_less_signed);
	  break;

	case DW_OP_gt:
	  /* Sign extend the operands.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_ext (expr, addr_size_bits);
	  /* Note no swap here: A > B is B < A.  */
	  ax_simple (expr, aop_less_signed);
	  break;

	case DW_OP_ne:
	  /* Sign extend the operands.  */
	  ax_ext (expr, addr_size_bits);
	  ax_simple (expr, aop_swap);
	  ax_ext (expr, addr_size_bits);
	  /* No need for a swap here.  */
	  ax_simple (expr, aop_equal);
	  ax_simple (expr, aop_log_not);
	  break;

	case DW_OP_call_frame_cfa:
	  dwarf2_compile_cfa_to_ax (expr, loc, arch, expr->scope, per_cu);
	  loc->kind = axs_lvalue_memory;
	  break;

	case DW_OP_GNU_push_tls_address:
	  unimplemented (op);
	  break;

	case DW_OP_skip:
	  offset = extract_signed_integer (op_ptr, 2, byte_order);
	  op_ptr += 2;
	  i = ax_goto (expr, aop_goto);
	  VEC_safe_push (int, dw_labels, op_ptr + offset - base);
	  VEC_safe_push (int, patches, i);
	  break;

	case DW_OP_bra:
	  offset = extract_signed_integer (op_ptr, 2, byte_order);
	  op_ptr += 2;
	  /* Zero extend the operand.  */
	  ax_zero_ext (expr, addr_size_bits);
	  i = ax_goto (expr, aop_if_goto);
	  VEC_safe_push (int, dw_labels, op_ptr + offset - base);
	  VEC_safe_push (int, patches, i);
	  break;

	case DW_OP_nop:
	  break;

        case DW_OP_piece:
	case DW_OP_bit_piece:
	  {
	    uint64_t size, offset;

	    if (op_ptr - 1 == previous_piece)
	      error (_("Cannot translate empty pieces to agent expressions"));
	    previous_piece = op_ptr - 1;

            op_ptr = safe_read_uleb128 (op_ptr, op_end, &size);
	    if (op == DW_OP_piece)
	      {
		size *= 8;
		offset = 0;
	      }
	    else
	      op_ptr = safe_read_uleb128 (op_ptr, op_end, &offset);

	    if (bits_collected + size > 8 * sizeof (LONGEST))
	      error (_("Expression pieces exceed word size"));

	    /* Access the bits.  */
	    switch (loc->kind)
	      {
	      case axs_lvalue_register:
		ax_reg (expr, loc->u.reg);
		break;

	      case axs_lvalue_memory:
		/* Offset the pointer, if needed.  */
		if (offset > 8)
		  {
		    ax_const_l (expr, offset / 8);
		    ax_simple (expr, aop_add);
		    offset %= 8;
		  }
		access_memory (arch, expr, size);
		break;
	      }

	    /* For a bits-big-endian target, shift up what we already
	       have.  For a bits-little-endian target, shift up the
	       new data.  Note that there is a potential bug here if
	       the DWARF expression leaves multiple values on the
	       stack.  */
	    if (bits_collected > 0)
	      {
		if (bits_big_endian)
		  {
		    ax_simple (expr, aop_swap);
		    ax_const_l (expr, size);
		    ax_simple (expr, aop_lsh);
		    /* We don't need a second swap here, because
		       aop_bit_or is symmetric.  */
		  }
		else
		  {
		    ax_const_l (expr, size);
		    ax_simple (expr, aop_lsh);
		  }
		ax_simple (expr, aop_bit_or);
	      }

	    bits_collected += size;
	    loc->kind = axs_rvalue;
	  }
	  break;

	case DW_OP_GNU_uninit:
	  unimplemented (op);

	case DW_OP_call2:
	case DW_OP_call4:
	  {
	    struct dwarf2_locexpr_baton block;
	    int size = (op == DW_OP_call2 ? 2 : 4);
	    cu_offset offset;

	    uoffset = extract_unsigned_integer (op_ptr, size, byte_order);
	    op_ptr += size;

	    offset.cu_off = uoffset;
	    block = dwarf2_fetch_die_loc_cu_off (offset, per_cu,
						 get_ax_pc, expr);

	    /* DW_OP_call_ref is currently not supported.  */
	    gdb_assert (block.per_cu == per_cu);

	    dwarf2_compile_expr_to_ax (expr, loc, arch, addr_size,
				       block.data, block.data + block.size,
				       per_cu);
	  }
	  break;

	case DW_OP_call_ref:
	  unimplemented (op);

	default:
	  unimplemented (op);
	}
    }

  /* Patch all the branches we emitted.  */
  for (i = 0; i < VEC_length (int, patches); ++i)
    {
      int targ = offsets[VEC_index (int, dw_labels, i)];
      if (targ == -1)
	internal_error (__FILE__, __LINE__, _("invalid label"));
      ax_label (expr, VEC_index (int, patches, i), targ);
    }

  do_cleanups (cleanups);
}


/* Return the value of SYMBOL in FRAME using the DWARF-2 expression
   evaluator to calculate the location.  */
static struct value *
locexpr_read_variable (struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  struct value *val;

  val = dwarf2_evaluate_loc_desc (SYMBOL_TYPE (symbol), frame, dlbaton->data,
				  dlbaton->size, dlbaton->per_cu);

  return val;
}

/* Return the value of SYMBOL in FRAME at (callee) FRAME's function
   entry.  SYMBOL should be a function parameter, otherwise NO_ENTRY_VALUE_ERROR
   will be thrown.  */

static struct value *
locexpr_read_variable_at_entry (struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);

  return value_of_dwarf_block_entry (SYMBOL_TYPE (symbol), frame, dlbaton->data,
				     dlbaton->size);
}

/* Return non-zero iff we need a frame to evaluate SYMBOL.  */
static int
locexpr_read_needs_frame (struct symbol *symbol)
{
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);

  return dwarf2_loc_desc_needs_frame (dlbaton->data, dlbaton->size,
				      dlbaton->per_cu);
}

/* Return true if DATA points to the end of a piece.  END is one past
   the last byte in the expression.  */

static int
piece_end_p (const gdb_byte *data, const gdb_byte *end)
{
  return data == end || data[0] == DW_OP_piece || data[0] == DW_OP_bit_piece;
}

/* Helper for locexpr_describe_location_piece that finds the name of a
   DWARF register.  */

static const char *
locexpr_regname (struct gdbarch *gdbarch, int dwarf_regnum)
{
  int regnum;

  regnum = gdbarch_dwarf2_reg_to_regnum (gdbarch, dwarf_regnum);
  return gdbarch_register_name (gdbarch, regnum);
}

/* Nicely describe a single piece of a location, returning an updated
   position in the bytecode sequence.  This function cannot recognize
   all locations; if a location is not recognized, it simply returns
   DATA.  If there is an error during reading, e.g. we run off the end
   of the buffer, an error is thrown.  */

static const gdb_byte *
locexpr_describe_location_piece (struct symbol *symbol, struct ui_file *stream,
				 CORE_ADDR addr, struct objfile *objfile,
				 struct dwarf2_per_cu_data *per_cu,
				 const gdb_byte *data, const gdb_byte *end,
				 unsigned int addr_size)
{
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  size_t leb128_size;

  if (data[0] >= DW_OP_reg0 && data[0] <= DW_OP_reg31)
    {
      fprintf_filtered (stream, _("a variable in $%s"),
			locexpr_regname (gdbarch, data[0] - DW_OP_reg0));
      data += 1;
    }
  else if (data[0] == DW_OP_regx)
    {
      uint64_t reg;

      data = safe_read_uleb128 (data + 1, end, &reg);
      fprintf_filtered (stream, _("a variable in $%s"),
			locexpr_regname (gdbarch, reg));
    }
  else if (data[0] == DW_OP_fbreg)
    {
      struct block *b;
      struct symbol *framefunc;
      int frame_reg = 0;
      int64_t frame_offset;
      const gdb_byte *base_data, *new_data, *save_data = data;
      size_t base_size;
      int64_t base_offset = 0;

      new_data = safe_read_sleb128 (data + 1, end, &frame_offset);
      if (!piece_end_p (new_data, end))
	return data;
      data = new_data;

      b = block_for_pc (addr);

      if (!b)
	error (_("No block found for address for symbol \"%s\"."),
	       SYMBOL_PRINT_NAME (symbol));

      framefunc = block_linkage_function (b);

      if (!framefunc)
	error (_("No function found for block for symbol \"%s\"."),
	       SYMBOL_PRINT_NAME (symbol));

      dwarf_expr_frame_base_1 (framefunc, addr, &base_data, &base_size);

      if (base_data[0] >= DW_OP_breg0 && base_data[0] <= DW_OP_breg31)
	{
	  const gdb_byte *buf_end;
	  
	  frame_reg = base_data[0] - DW_OP_breg0;
	  buf_end = safe_read_sleb128 (base_data + 1, base_data + base_size,
				       &base_offset);
	  if (buf_end != base_data + base_size)
	    error (_("Unexpected opcode after "
		     "DW_OP_breg%u for symbol \"%s\"."),
		   frame_reg, SYMBOL_PRINT_NAME (symbol));
	}
      else if (base_data[0] >= DW_OP_reg0 && base_data[0] <= DW_OP_reg31)
	{
	  /* The frame base is just the register, with no offset.  */
	  frame_reg = base_data[0] - DW_OP_reg0;
	  base_offset = 0;
	}
      else
	{
	  /* We don't know what to do with the frame base expression,
	     so we can't trace this variable; give up.  */
	  return save_data;
	}

      fprintf_filtered (stream,
			_("a variable at frame base reg $%s offset %s+%s"),
			locexpr_regname (gdbarch, frame_reg),
			plongest (base_offset), plongest (frame_offset));
    }
  else if (data[0] >= DW_OP_breg0 && data[0] <= DW_OP_breg31
	   && piece_end_p (data, end))
    {
      int64_t offset;

      data = safe_read_sleb128 (data + 1, end, &offset);

      fprintf_filtered (stream,
			_("a variable at offset %s from base reg $%s"),
			plongest (offset),
			locexpr_regname (gdbarch, data[0] - DW_OP_breg0));
    }

  /* The location expression for a TLS variable looks like this (on a
     64-bit LE machine):

     DW_AT_location    : 10 byte block: 3 4 0 0 0 0 0 0 0 e0
                        (DW_OP_addr: 4; DW_OP_GNU_push_tls_address)

     0x3 is the encoding for DW_OP_addr, which has an operand as long
     as the size of an address on the target machine (here is 8
     bytes).  Note that more recent version of GCC emit DW_OP_const4u
     or DW_OP_const8u, depending on address size, rather than
     DW_OP_addr.  0xe0 is the encoding for DW_OP_GNU_push_tls_address.
     The operand represents the offset at which the variable is within
     the thread local storage.  */

  else if (data + 1 + addr_size < end
	   && (data[0] == DW_OP_addr
	       || (addr_size == 4 && data[0] == DW_OP_const4u)
	       || (addr_size == 8 && data[0] == DW_OP_const8u))
	   && data[1 + addr_size] == DW_OP_GNU_push_tls_address
	   && piece_end_p (data + 2 + addr_size, end))
    {
      ULONGEST offset;
      offset = extract_unsigned_integer (data + 1, addr_size,
					 gdbarch_byte_order (gdbarch));

      fprintf_filtered (stream, 
			_("a thread-local variable at offset 0x%s "
			  "in the thread-local storage for `%s'"),
			phex_nz (offset, addr_size), objfile_name (objfile));

      data += 1 + addr_size + 1;
    }

  /* With -gsplit-dwarf a TLS variable can also look like this:
     DW_AT_location    : 3 byte block: fc 4 e0
                        (DW_OP_GNU_const_index: 4;
			 DW_OP_GNU_push_tls_address)  */
  else if (data + 3 <= end
	   && data + 1 + (leb128_size = skip_leb128 (data + 1, end)) < end
	   && data[0] == DW_OP_GNU_const_index
	   && leb128_size > 0
	   && data[1 + leb128_size] == DW_OP_GNU_push_tls_address
	   && piece_end_p (data + 2 + leb128_size, end))
    {
      uint64_t offset;

      data = safe_read_uleb128 (data + 1, end, &offset);
      offset = dwarf2_read_addr_index (per_cu, offset);
      fprintf_filtered (stream, 
			_("a thread-local variable at offset 0x%s "
			  "in the thread-local storage for `%s'"),
			phex_nz (offset, addr_size), objfile_name (objfile));
      ++data;
    }

  else if (data[0] >= DW_OP_lit0
	   && data[0] <= DW_OP_lit31
	   && data + 1 < end
	   && data[1] == DW_OP_stack_value)
    {
      fprintf_filtered (stream, _("the constant %d"), data[0] - DW_OP_lit0);
      data += 2;
    }

  return data;
}

/* Disassemble an expression, stopping at the end of a piece or at the
   end of the expression.  Returns a pointer to the next unread byte
   in the input expression.  If ALL is nonzero, then this function
   will keep going until it reaches the end of the expression.
   If there is an error during reading, e.g. we run off the end
   of the buffer, an error is thrown.  */

static const gdb_byte *
disassemble_dwarf_expression (struct ui_file *stream,
			      struct gdbarch *arch, unsigned int addr_size,
			      int offset_size, const gdb_byte *start,
			      const gdb_byte *data, const gdb_byte *end,
			      int indent, int all,
			      struct dwarf2_per_cu_data *per_cu)
{
  while (data < end
	 && (all
	     || (data[0] != DW_OP_piece && data[0] != DW_OP_bit_piece)))
    {
      enum dwarf_location_atom op = *data++;
      uint64_t ul;
      int64_t l;
      const char *name;

      name = get_DW_OP_name (op);

      if (!name)
	error (_("Unrecognized DWARF opcode 0x%02x at %ld"),
	       op, (long) (data - 1 - start));
      fprintf_filtered (stream, "  %*ld: %s", indent + 4,
			(long) (data - 1 - start), name);

      switch (op)
	{
	case DW_OP_addr:
	  ul = extract_unsigned_integer (data, addr_size,
					 gdbarch_byte_order (arch));
	  data += addr_size;
	  fprintf_filtered (stream, " 0x%s", phex_nz (ul, addr_size));
	  break;

	case DW_OP_const1u:
	  ul = extract_unsigned_integer (data, 1, gdbarch_byte_order (arch));
	  data += 1;
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;
	case DW_OP_const1s:
	  l = extract_signed_integer (data, 1, gdbarch_byte_order (arch));
	  data += 1;
	  fprintf_filtered (stream, " %s", plongest (l));
	  break;
	case DW_OP_const2u:
	  ul = extract_unsigned_integer (data, 2, gdbarch_byte_order (arch));
	  data += 2;
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;
	case DW_OP_const2s:
	  l = extract_signed_integer (data, 2, gdbarch_byte_order (arch));
	  data += 2;
	  fprintf_filtered (stream, " %s", plongest (l));
	  break;
	case DW_OP_const4u:
	  ul = extract_unsigned_integer (data, 4, gdbarch_byte_order (arch));
	  data += 4;
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;
	case DW_OP_const4s:
	  l = extract_signed_integer (data, 4, gdbarch_byte_order (arch));
	  data += 4;
	  fprintf_filtered (stream, " %s", plongest (l));
	  break;
	case DW_OP_const8u:
	  ul = extract_unsigned_integer (data, 8, gdbarch_byte_order (arch));
	  data += 8;
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;
	case DW_OP_const8s:
	  l = extract_signed_integer (data, 8, gdbarch_byte_order (arch));
	  data += 8;
	  fprintf_filtered (stream, " %s", plongest (l));
	  break;
	case DW_OP_constu:
	  data = safe_read_uleb128 (data, end, &ul);
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;
	case DW_OP_consts:
	  data = safe_read_sleb128 (data, end, &l);
	  fprintf_filtered (stream, " %s", plongest (l));
	  break;

	case DW_OP_reg0:
	case DW_OP_reg1:
	case DW_OP_reg2:
	case DW_OP_reg3:
	case DW_OP_reg4:
	case DW_OP_reg5:
	case DW_OP_reg6:
	case DW_OP_reg7:
	case DW_OP_reg8:
	case DW_OP_reg9:
	case DW_OP_reg10:
	case DW_OP_reg11:
	case DW_OP_reg12:
	case DW_OP_reg13:
	case DW_OP_reg14:
	case DW_OP_reg15:
	case DW_OP_reg16:
	case DW_OP_reg17:
	case DW_OP_reg18:
	case DW_OP_reg19:
	case DW_OP_reg20:
	case DW_OP_reg21:
	case DW_OP_reg22:
	case DW_OP_reg23:
	case DW_OP_reg24:
	case DW_OP_reg25:
	case DW_OP_reg26:
	case DW_OP_reg27:
	case DW_OP_reg28:
	case DW_OP_reg29:
	case DW_OP_reg30:
	case DW_OP_reg31:
	  fprintf_filtered (stream, " [$%s]",
			    locexpr_regname (arch, op - DW_OP_reg0));
	  break;

	case DW_OP_regx:
	  data = safe_read_uleb128 (data, end, &ul);
	  fprintf_filtered (stream, " %s [$%s]", pulongest (ul),
			    locexpr_regname (arch, (int) ul));
	  break;

	case DW_OP_implicit_value:
	  data = safe_read_uleb128 (data, end, &ul);
	  data += ul;
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;

	case DW_OP_breg0:
	case DW_OP_breg1:
	case DW_OP_breg2:
	case DW_OP_breg3:
	case DW_OP_breg4:
	case DW_OP_breg5:
	case DW_OP_breg6:
	case DW_OP_breg7:
	case DW_OP_breg8:
	case DW_OP_breg9:
	case DW_OP_breg10:
	case DW_OP_breg11:
	case DW_OP_breg12:
	case DW_OP_breg13:
	case DW_OP_breg14:
	case DW_OP_breg15:
	case DW_OP_breg16:
	case DW_OP_breg17:
	case DW_OP_breg18:
	case DW_OP_breg19:
	case DW_OP_breg20:
	case DW_OP_breg21:
	case DW_OP_breg22:
	case DW_OP_breg23:
	case DW_OP_breg24:
	case DW_OP_breg25:
	case DW_OP_breg26:
	case DW_OP_breg27:
	case DW_OP_breg28:
	case DW_OP_breg29:
	case DW_OP_breg30:
	case DW_OP_breg31:
	  data = safe_read_sleb128 (data, end, &l);
	  fprintf_filtered (stream, " %s [$%s]", plongest (l),
			    locexpr_regname (arch, op - DW_OP_breg0));
	  break;

	case DW_OP_bregx:
	  data = safe_read_uleb128 (data, end, &ul);
	  data = safe_read_sleb128 (data, end, &l);
	  fprintf_filtered (stream, " register %s [$%s] offset %s",
			    pulongest (ul),
			    locexpr_regname (arch, (int) ul),
			    plongest (l));
	  break;

	case DW_OP_fbreg:
	  data = safe_read_sleb128 (data, end, &l);
	  fprintf_filtered (stream, " %s", plongest (l));
	  break;

	case DW_OP_xderef_size:
	case DW_OP_deref_size:
	case DW_OP_pick:
	  fprintf_filtered (stream, " %d", *data);
	  ++data;
	  break;

	case DW_OP_plus_uconst:
	  data = safe_read_uleb128 (data, end, &ul);
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;

	case DW_OP_skip:
	  l = extract_signed_integer (data, 2, gdbarch_byte_order (arch));
	  data += 2;
	  fprintf_filtered (stream, " to %ld",
			    (long) (data + l - start));
	  break;

	case DW_OP_bra:
	  l = extract_signed_integer (data, 2, gdbarch_byte_order (arch));
	  data += 2;
	  fprintf_filtered (stream, " %ld",
			    (long) (data + l - start));
	  break;

	case DW_OP_call2:
	  ul = extract_unsigned_integer (data, 2, gdbarch_byte_order (arch));
	  data += 2;
	  fprintf_filtered (stream, " offset %s", phex_nz (ul, 2));
	  break;

	case DW_OP_call4:
	  ul = extract_unsigned_integer (data, 4, gdbarch_byte_order (arch));
	  data += 4;
	  fprintf_filtered (stream, " offset %s", phex_nz (ul, 4));
	  break;

	case DW_OP_call_ref:
	  ul = extract_unsigned_integer (data, offset_size,
					 gdbarch_byte_order (arch));
	  data += offset_size;
	  fprintf_filtered (stream, " offset %s", phex_nz (ul, offset_size));
	  break;

        case DW_OP_piece:
	  data = safe_read_uleb128 (data, end, &ul);
	  fprintf_filtered (stream, " %s (bytes)", pulongest (ul));
	  break;

	case DW_OP_bit_piece:
	  {
	    uint64_t offset;

	    data = safe_read_uleb128 (data, end, &ul);
	    data = safe_read_uleb128 (data, end, &offset);
	    fprintf_filtered (stream, " size %s offset %s (bits)",
			      pulongest (ul), pulongest (offset));
	  }
	  break;

	case DW_OP_GNU_implicit_pointer:
	  {
	    ul = extract_unsigned_integer (data, offset_size,
					   gdbarch_byte_order (arch));
	    data += offset_size;

	    data = safe_read_sleb128 (data, end, &l);

	    fprintf_filtered (stream, " DIE %s offset %s",
			      phex_nz (ul, offset_size),
			      plongest (l));
	  }
	  break;

	case DW_OP_GNU_deref_type:
	  {
	    int addr_size = *data++;
	    cu_offset offset;
	    struct type *type;

	    data = safe_read_uleb128 (data, end, &ul);
	    offset.cu_off = ul;
	    type = dwarf2_get_die_type (offset, per_cu);
	    fprintf_filtered (stream, "<");
	    type_print (type, "", stream, -1);
	    fprintf_filtered (stream, " [0x%s]> %d", phex_nz (offset.cu_off, 0),
			      addr_size);
	  }
	  break;

	case DW_OP_GNU_const_type:
	  {
	    cu_offset type_die;
	    struct type *type;

	    data = safe_read_uleb128 (data, end, &ul);
	    type_die.cu_off = ul;
	    type = dwarf2_get_die_type (type_die, per_cu);
	    fprintf_filtered (stream, "<");
	    type_print (type, "", stream, -1);
	    fprintf_filtered (stream, " [0x%s]>", phex_nz (type_die.cu_off, 0));
	  }
	  break;

	case DW_OP_GNU_regval_type:
	  {
	    uint64_t reg;
	    cu_offset type_die;
	    struct type *type;

	    data = safe_read_uleb128 (data, end, &reg);
	    data = safe_read_uleb128 (data, end, &ul);
	    type_die.cu_off = ul;

	    type = dwarf2_get_die_type (type_die, per_cu);
	    fprintf_filtered (stream, "<");
	    type_print (type, "", stream, -1);
	    fprintf_filtered (stream, " [0x%s]> [$%s]",
			      phex_nz (type_die.cu_off, 0),
			      locexpr_regname (arch, reg));
	  }
	  break;

	case DW_OP_GNU_convert:
	case DW_OP_GNU_reinterpret:
	  {
	    cu_offset type_die;

	    data = safe_read_uleb128 (data, end, &ul);
	    type_die.cu_off = ul;

	    if (type_die.cu_off == 0)
	      fprintf_filtered (stream, "<0>");
	    else
	      {
		struct type *type;

		type = dwarf2_get_die_type (type_die, per_cu);
		fprintf_filtered (stream, "<");
		type_print (type, "", stream, -1);
		fprintf_filtered (stream, " [0x%s]>", phex_nz (type_die.cu_off, 0));
	      }
	  }
	  break;

	case DW_OP_GNU_entry_value:
	  data = safe_read_uleb128 (data, end, &ul);
	  fputc_filtered ('\n', stream);
	  disassemble_dwarf_expression (stream, arch, addr_size, offset_size,
					start, data, data + ul, indent + 2,
					all, per_cu);
	  data += ul;
	  continue;

	case DW_OP_GNU_parameter_ref:
	  ul = extract_unsigned_integer (data, 4, gdbarch_byte_order (arch));
	  data += 4;
	  fprintf_filtered (stream, " offset %s", phex_nz (ul, 4));
	  break;

	case DW_OP_GNU_addr_index:
	  data = safe_read_uleb128 (data, end, &ul);
	  ul = dwarf2_read_addr_index (per_cu, ul);
	  fprintf_filtered (stream, " 0x%s", phex_nz (ul, addr_size));
	  break;
	case DW_OP_GNU_const_index:
	  data = safe_read_uleb128 (data, end, &ul);
	  ul = dwarf2_read_addr_index (per_cu, ul);
	  fprintf_filtered (stream, " %s", pulongest (ul));
	  break;
	}

      fprintf_filtered (stream, "\n");
    }

  return data;
}

/* Describe a single location, which may in turn consist of multiple
   pieces.  */

static void
locexpr_describe_location_1 (struct symbol *symbol, CORE_ADDR addr,
			     struct ui_file *stream,
			     const gdb_byte *data, size_t size,
			     struct objfile *objfile, unsigned int addr_size,
			     int offset_size, struct dwarf2_per_cu_data *per_cu)
{
  const gdb_byte *end = data + size;
  int first_piece = 1, bad = 0;

  while (data < end)
    {
      const gdb_byte *here = data;
      int disassemble = 1;

      if (first_piece)
	first_piece = 0;
      else
	fprintf_filtered (stream, _(", and "));

      if (!dwarf2_always_disassemble)
	{
	  data = locexpr_describe_location_piece (symbol, stream,
						  addr, objfile, per_cu,
						  data, end, addr_size);
	  /* If we printed anything, or if we have an empty piece,
	     then don't disassemble.  */
	  if (data != here
	      || data[0] == DW_OP_piece
	      || data[0] == DW_OP_bit_piece)
	    disassemble = 0;
	}
      if (disassemble)
	{
	  fprintf_filtered (stream, _("a complex DWARF expression:\n"));
	  data = disassemble_dwarf_expression (stream,
					       get_objfile_arch (objfile),
					       addr_size, offset_size, data,
					       data, end, 0,
					       dwarf2_always_disassemble,
					       per_cu);
	}

      if (data < end)
	{
	  int empty = data == here;
	      
	  if (disassemble)
	    fprintf_filtered (stream, "   ");
	  if (data[0] == DW_OP_piece)
	    {
	      uint64_t bytes;

	      data = safe_read_uleb128 (data + 1, end, &bytes);

	      if (empty)
		fprintf_filtered (stream, _("an empty %s-byte piece"),
				  pulongest (bytes));
	      else
		fprintf_filtered (stream, _(" [%s-byte piece]"),
				  pulongest (bytes));
	    }
	  else if (data[0] == DW_OP_bit_piece)
	    {
	      uint64_t bits, offset;

	      data = safe_read_uleb128 (data + 1, end, &bits);
	      data = safe_read_uleb128 (data, end, &offset);

	      if (empty)
		fprintf_filtered (stream,
				  _("an empty %s-bit piece"),
				  pulongest (bits));
	      else
		fprintf_filtered (stream,
				  _(" [%s-bit piece, offset %s bits]"),
				  pulongest (bits), pulongest (offset));
	    }
	  else
	    {
	      bad = 1;
	      break;
	    }
	}
    }

  if (bad || data > end)
    error (_("Corrupted DWARF2 expression for \"%s\"."),
	   SYMBOL_PRINT_NAME (symbol));
}

/* Print a natural-language description of SYMBOL to STREAM.  This
   version is for a symbol with a single location.  */

static void
locexpr_describe_location (struct symbol *symbol, CORE_ADDR addr,
			   struct ui_file *stream)
{
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  struct objfile *objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);
  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);
  int offset_size = dwarf2_per_cu_offset_size (dlbaton->per_cu);

  locexpr_describe_location_1 (symbol, addr, stream,
			       dlbaton->data, dlbaton->size,
			       objfile, addr_size, offset_size,
			       dlbaton->per_cu);
}

/* Describe the location of SYMBOL as an agent value in VALUE, generating
   any necessary bytecode in AX.  */

static void
locexpr_tracepoint_var_ref (struct symbol *symbol, struct gdbarch *gdbarch,
			    struct agent_expr *ax, struct axs_value *value)
{
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);

  if (dlbaton->size == 0)
    value->optimized_out = 1;
  else
    dwarf2_compile_expr_to_ax (ax, value, gdbarch, addr_size,
			       dlbaton->data, dlbaton->data + dlbaton->size,
			       dlbaton->per_cu);
}

/* The set of location functions used with the DWARF-2 expression
   evaluator.  */
const struct symbol_computed_ops dwarf2_locexpr_funcs = {
  locexpr_read_variable,
  locexpr_read_variable_at_entry,
  locexpr_read_needs_frame,
  locexpr_describe_location,
  0,	/* location_has_loclist */
  locexpr_tracepoint_var_ref
};


/* Wrapper functions for location lists.  These generally find
   the appropriate location expression and call something above.  */

/* Return the value of SYMBOL in FRAME using the DWARF-2 expression
   evaluator to calculate the location.  */
static struct value *
loclist_read_variable (struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  struct value *val;
  const gdb_byte *data;
  size_t size;
  CORE_ADDR pc = frame ? get_frame_address_in_block (frame) : 0;

  data = dwarf2_find_location_expression (dlbaton, &size, pc);
  val = dwarf2_evaluate_loc_desc (SYMBOL_TYPE (symbol), frame, data, size,
				  dlbaton->per_cu);

  return val;
}

/* Read variable SYMBOL like loclist_read_variable at (callee) FRAME's function
   entry.  SYMBOL should be a function parameter, otherwise NO_ENTRY_VALUE_ERROR
   will be thrown.

   Function always returns non-NULL value, it may be marked optimized out if
   inferior frame information is not available.  It throws NO_ENTRY_VALUE_ERROR
   if it cannot resolve the parameter for any reason.  */

static struct value *
loclist_read_variable_at_entry (struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  const gdb_byte *data;
  size_t size;
  CORE_ADDR pc;

  if (frame == NULL || !get_frame_func_if_available (frame, &pc))
    return allocate_optimized_out_value (SYMBOL_TYPE (symbol));

  data = dwarf2_find_location_expression (dlbaton, &size, pc);
  if (data == NULL)
    return allocate_optimized_out_value (SYMBOL_TYPE (symbol));

  return value_of_dwarf_block_entry (SYMBOL_TYPE (symbol), frame, data, size);
}

/* Return non-zero iff we need a frame to evaluate SYMBOL.  */
static int
loclist_read_needs_frame (struct symbol *symbol)
{
  /* If there's a location list, then assume we need to have a frame
     to choose the appropriate location expression.  With tracking of
     global variables this is not necessarily true, but such tracking
     is disabled in GCC at the moment until we figure out how to
     represent it.  */

  return 1;
}

/* Print a natural-language description of SYMBOL to STREAM.  This
   version applies when there is a list of different locations, each
   with a specified address range.  */

static void
loclist_describe_location (struct symbol *symbol, CORE_ADDR addr,
			   struct ui_file *stream)
{
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  const gdb_byte *loc_ptr, *buf_end;
  struct objfile *objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);
  struct gdbarch *gdbarch = get_objfile_arch (objfile);
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);
  int offset_size = dwarf2_per_cu_offset_size (dlbaton->per_cu);
  int signed_addr_p = bfd_get_sign_extend_vma (objfile->obfd);
  /* Adjust base_address for relocatable objects.  */
  CORE_ADDR base_offset = dwarf2_per_cu_text_offset (dlbaton->per_cu);
  CORE_ADDR base_address = dlbaton->base_address + base_offset;
  int done = 0;

  loc_ptr = dlbaton->data;
  buf_end = dlbaton->data + dlbaton->size;

  fprintf_filtered (stream, _("multi-location:\n"));

  /* Iterate through locations until we run out.  */
  while (!done)
    {
      CORE_ADDR low = 0, high = 0; /* init for gcc -Wall */
      int length;
      enum debug_loc_kind kind;
      const gdb_byte *new_ptr = NULL; /* init for gcc -Wall */

      if (dlbaton->from_dwo)
	kind = decode_debug_loc_dwo_addresses (dlbaton->per_cu,
					       loc_ptr, buf_end, &new_ptr,
					       &low, &high, byte_order);
      else
	kind = decode_debug_loc_addresses (loc_ptr, buf_end, &new_ptr,
					   &low, &high,
					   byte_order, addr_size,
					   signed_addr_p);
      loc_ptr = new_ptr;
      switch (kind)
	{
	case DEBUG_LOC_END_OF_LIST:
	  done = 1;
	  continue;
	case DEBUG_LOC_BASE_ADDRESS:
	  base_address = high + base_offset;
	  fprintf_filtered (stream, _("  Base address %s"),
			    paddress (gdbarch, base_address));
	  continue;
	case DEBUG_LOC_START_END:
	case DEBUG_LOC_START_LENGTH:
	  break;
	case DEBUG_LOC_BUFFER_OVERFLOW:
	case DEBUG_LOC_INVALID_ENTRY:
	  error (_("Corrupted DWARF expression for symbol \"%s\"."),
		 SYMBOL_PRINT_NAME (symbol));
	default:
	  gdb_assert_not_reached ("bad debug_loc_kind");
	}

      /* Otherwise, a location expression entry.  */
      low += base_address;
      high += base_address;

      length = extract_unsigned_integer (loc_ptr, 2, byte_order);
      loc_ptr += 2;

      /* (It would improve readability to print only the minimum
	 necessary digits of the second number of the range.)  */
      fprintf_filtered (stream, _("  Range %s-%s: "),
			paddress (gdbarch, low), paddress (gdbarch, high));

      /* Now describe this particular location.  */
      locexpr_describe_location_1 (symbol, low, stream, loc_ptr, length,
				   objfile, addr_size, offset_size,
				   dlbaton->per_cu);

      fprintf_filtered (stream, "\n");

      loc_ptr += length;
    }
}

/* Describe the location of SYMBOL as an agent value in VALUE, generating
   any necessary bytecode in AX.  */
static void
loclist_tracepoint_var_ref (struct symbol *symbol, struct gdbarch *gdbarch,
			    struct agent_expr *ax, struct axs_value *value)
{
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  const gdb_byte *data;
  size_t size;
  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);

  data = dwarf2_find_location_expression (dlbaton, &size, ax->scope);
  if (size == 0)
    value->optimized_out = 1;
  else
    dwarf2_compile_expr_to_ax (ax, value, gdbarch, addr_size, data, data + size,
			       dlbaton->per_cu);
}

/* The set of location functions used with the DWARF-2 expression
   evaluator and location lists.  */
const struct symbol_computed_ops dwarf2_loclist_funcs = {
  loclist_read_variable,
  loclist_read_variable_at_entry,
  loclist_read_needs_frame,
  loclist_describe_location,
  1,	/* location_has_loclist */
  loclist_tracepoint_var_ref
};

/* Provide a prototype to silence -Wmissing-prototypes.  */
extern initialize_file_ftype _initialize_dwarf2loc;

void
_initialize_dwarf2loc (void)
{
  add_setshow_zuinteger_cmd ("entry-values", class_maintenance,
			     &entry_values_debug,
			     _("Set entry values and tail call frames "
			       "debugging."),
			     _("Show entry values and tail call frames "
			       "debugging."),
			     _("When non-zero, the process of determining "
			       "parameter values from function entry point "
			       "and tail call frames will be printed."),
			     NULL,
			     show_entry_values_debug,
			     &setdebuglist, &showdebuglist);
}
@


1.178
log
@Code cleanup: Add objfile_name accessor

gdb/
2013-09-24  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	Code cleanup: Add objfile_name accessor function.
	* ada-lang.c (is_known_support_routine): Use objfile_name.
	* auto-load.c (source_gdb_script_for_objfile)
	(auto_load_objfile_script): Likewise.
	* coffread.c (coff_symtab_read, read_one_sym): Likewise.
	* dbxread.c (dbx_symfile_read): Likewise.
	* dwarf2-frame.c (dwarf2_build_frame_info): Likewise.
	* dwarf2loc.c (locexpr_describe_location_piece): Likewise.
	* dwarf2read.c (dwarf2_get_dwz_file, dwarf2_read_index)
	(dw2_symtab_iter_next, dw2_expand_symtabs_matching)
	(lookup_dwp_signatured_type, lookup_dwo_unit)
	(dwarf2_build_psymtabs_hard, scan_partial_symbols, process_queue)
	(fixup_go_packaging, process_imported_unit_die, dwarf2_physname)
	(read_import_statement, create_dwo_cu, open_and_init_dwp_file)
	(lookup_dwo_cutu, read_call_site_scope, dwarf2_ranges_read)
	(dwarf2_record_block_ranges, read_common_block, read_typedef)
	(read_subrange_type, load_partial_dies, read_partial_die)
	(read_addr_index_1, read_str_index, dwarf_decode_lines_1)
	(die_containing_type, build_error_marker_type, lookup_die_type)
	(follow_die_ref_or_sig, follow_die_ref, dwarf2_fetch_die_loc_sect_off)
	(dwarf2_fetch_constant_bytes, follow_die_sig, get_signatured_type)
	(get_DW_AT_signature_type, write_psymtabs_to_index)
	(save_gdb_index_command): Likewise.
	* elfread.c (find_separate_debug_file_by_buildid, elf_symfile_read):
	Likewise.
	* expprint.c (dump_subexp_body_standard): Likewise.
	* gdbtypes.c (type_name_no_tag_or_error): Likewise.
	* jit.c (jit_object_close_impl): Use the objfile field name renamed to
	original_name.
	* linux-thread-db.c (try_thread_db_load_from_pdir_1): New variable
	obj_name, use objfile_name for it, use the variable.
	(try_thread_db_load_from_pdir, has_libpthread, thread_db_new_objfile):
	Use objfile_name.
	* machoread.c (macho_symtab_read, macho_check_dsym)
	(macho_symfile_relocate): Likewise.
	* maint.c (maintenance_translate_address): Likewise.
	* minidebug.c (find_separate_debug_file_in_section): Likewise.
	* minsyms.c (install_minimal_symbols): Likewise.
	* objfiles.c (allocate_objfile): Use the objfile field name renamed to
	original_name.
	(filter_overlapping_sections): Use objfile_name.
	(objfile_name): New function.
	* objfiles.h (struct objfile): Rename field name to original_name.
	(objfile_name): New prototype.
	* printcmd.c (sym_info, address_info): Use objfile_name.
	* probe.c (parse_probes, collect_probes, compare_probes)
	(info_probes_for_ops): Likewise.
	* progspace.c (clone_program_space): Likewise.
	* psymtab.c (require_partial_symbols, dump_psymtab, allocate_psymtab)
	(maintenance_info_psymtabs): Likewise.
	* python/py-auto-load.c (gdbpy_load_auto_script_for_objfile)
	(source_section_scripts): Likewise.
	* python/py-objfile.c (objfpy_get_filename): Likewise.
	* python/py-progspace.c (pspy_get_filename): Likewise.
	* solib-aix.c (solib_aix_get_toc_value): Likewise.
	* solib-som.c (match_main, som_solib_section_offsets): Likewise.
	* solib.c (solib_read_symbols): Likewise.
	* stabsread.c (scan_file_globals): Likewise.
	* stap-probe.c (handle_stap_probe): Likewise.
	* symfile.c (symbol_file_clear, separate_debug_file_exists)
	(find_separate_debug_file_by_debuglink): Likewise.
	(reread_symbols): Likewise.  Use the objfile field name renamed to
	original_name.
	(allocate_symtab): Use objfile_name.
	* symmisc.c (print_symbol_bcache_statistics, print_objfile_statistics)
	(dump_objfile, dump_msymbols, dump_symtab_1)
	(maintenance_print_msymbols, maintenance_print_objfiles)
	(maintenance_info_symtabs, maintenance_check_symtabs): Likewise.
	* target.c (target_translate_tls_address, target_info): Likewise.
	* xcoffread.c (xcoff_initial_scan): Make variable name const.  Use
	objfile_name.
@
text
@d2293 1
a2293 3
	    if (gdb_regnum != -1)
	      retval = value_from_register (type, gdb_regnum, frame);
	    else
d2296 12
@


1.177
log
@dwarf2loc.c: minor cleanup. don't print integer with paddress.

A couple years ago, dwarf_expr_fetch used to return a CORE_ADDR.  It
was made to return a ULONGEST since, and the 'dwarf_regnum' local
adjusted accordingly, but, we kept printing it with paddress.
gdbarch_dwarf2_reg_to_regnum takes the register number as 'int', so
there's really no point in using ULONGEST/pulongest either.

gdb/
2013-09-05  Pedro Alves  <palves@@redhat.com>

	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): 'dwarf_regnum'
	local is now int instead of ULONGEST.  Print it with %d
	instead of paddress.
@
text
@d3490 1
a3490 1
			phex_nz (offset, addr_size), objfile->name);
d3513 1
a3513 1
			phex_nz (offset, addr_size), objfile->name);
@


1.176
log
@cleanup: use value_lazy_at instead of allocate_value_lazy/attribute setter

I came across a pattern used to construct a value in the following way:

  struct value *val = allocate_value_lazy (type);
  VALUE_LVAL (val) = lval_memory;
  set_value_address (val, address);

Instead we fold the above call into:

  value_at_lazy (type, addr);

2013-08-27  Sanimir Agovic  <sanimir.agovic@@intel.com>

	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use value_at_lazy instead
	of assembling value via allocate_value_lazy and attribute setter.
	* findvar.c (default_read_var_value): Use value_at_lazy instead of
	assembling value via allocate_value_lazy and attribute setter.
	* valops.c (do_search_struct_field): Use value_at_lazy instead of
	assembling value via allocate_value_lazy and attribute setter.
@
text
@d2286 2
a2287 1
	    ULONGEST dwarf_regnum = value_as_long (dwarf_expr_fetch (ctx, 0));
d2296 2
a2297 2
	      error (_("Unable to access DWARF register number %s"),
		     paddress (arch, dwarf_regnum));
@


1.175
log
@gdb/

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>
	    Yao Qi  <yao@@codesourcery.com>

	* ctf.c (ctf_traceframe_info): Push trace state variables
	present in the trace data into the traceframe info object.
	* breakpoint.c (DEF_VEC_I): Remove.
	* common/filestuff.c (DEF_VEC_I): Likewise.
	* dwarf2loc.c (DEF_VEC_I): Likewise.
	* mi/mi-main.c (DEF_VEC_I): Likewise.
	* common/gdb_vecs.h (DEF_VEC_I): Define vector for int.
	* features/traceframe-info.dtd: Add tvar element and its
	attributes.
	* tracepoint.c (free_traceframe_info): Free vector 'tvars'.
	(build_traceframe_info): Push trace state variables present in the
	trace data into the traceframe info object.
	(traceframe_info_start_tvar): New function.
	(tvar_attributes): New.
	(traceframe_info_children): Add "tvar" element.
	* tracepoint.h (struct traceframe_info) <tvars>: New field.

	* NEWS: Mention the change in GDB and GDBserver.

gdb/doc:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* gdb.texinfo (Traceframe Info Format): Document tvar element and
	its attributes.

gdb/gdbserver:

2013-06-26  Pedro Alves  <pedro@@codesourcery.com>

	* tracepoint.c (build_traceframe_info_xml): Output trace state
	variables present in the trace buffer.
@
text
@d2306 1
a2306 2
	    retval = allocate_value_lazy (type);
	    VALUE_LVAL (retval) = lval_memory;
a2308 1
	    set_value_address (retval, address + byte_offset);
@


1.174
log
@Fix PR symtab/15391

PR symtab/15391 is a failure with the DW_OP_GNU_implicit_pointer
feature.

I tracked it down to a logic error in read_pieced_value.  The code
truncates this_size_bits according to the type size and offset too
early -- it should do it after taking bits_to_skip into account.

This patch fixes the bug.

While testing this, I also tripped across a latent bug because
indirect_pieced_value does not sign-extend where needed.  This patch
fixes this bug as well.

Finally, Pedro pointed out that a previous version implemented sign
extension incorrectly.  This version introduces a new gdb_sign_extend
function for this.  A couple of notes on this function:

* It has the gdb_ prefix to avoid clashes with various libraries that
  felt free to avoid proper namespacing.  There is a "sign_extend"
  function in a Tile GX header, in an SOM-related BFD header (and in
  sh64-tdep.c and as a macro in arm-wince-tdep.c, but those are
  ours...)

* I looked at all the sign extensions in gdb and didn't see ones that
  I felt comfortable converting to use this function; in large part
  because I don't have a good way to test the conversion.

Built and regtested on x86-64 Fedora 18.  New test cases included;
this required a minor addition to the DWARF assembler.  Note that the
DWARF CU made by implptrpiece.exp uses a funny pointer size in order
to show the sign-extension bug on all platforms.

	* dwarf2loc.c (read_pieced_value): Truncate this_size_bits
	after taking bits_to_skip into account.  Sign extend byte_offset.
	* utils.h (gdb_sign_extend): Declare.
	* utils.c (gdb_sign_extend): New function.

	* gdb.dwarf2/implptrpiece.exp: New file.
	* gdb.dwarf2/implptrconst.exp (d): New variable.
	Print d.
	* lib/dwarf2.exp (Dwarf::_location): Handle DW_OP_piece.
@
text
@a44 2
DEF_VEC_I(int);

@


1.173
log
@	* dwarf2loc.c (invalid_synthetic_pointer): Move earlier.
	(indirect_pieced_value): Call dwarf2_fetch_constant_bytes
	if needed.
	* dwarf2loc.h (dwarf2_fetch_constant_bytes): Declare.
	* dwarf2read.c (write_constant_as_bytes)
	(dwarf2_fetch_constant_bytes): New functions.
gdb/testsuite
	* gdb.dwarf2/implptrconst.c: New file.
	* gdb.dwarf2/implptrconst.exp: New file.
	* lib/dwarf.exp (Dwarf::_nz_quote): New proc.
	(Dwarf::_handle_DW_FORM): Handle DW_FORM_block1.
	(Dwarf::_location): Handle DW_OP_GNU_implicit_pointer.
@
text
@a1643 2
      if (this_size_bits > type_len - offset)
	this_size_bits = type_len - offset;
d1656 2
d2090 4
a2093 1
  /* This is an offset requested by GDB, such as value subcripts.  */
d2095 4
d2109 1
a2109 1
					  piece->v.ptr.offset + byte_offset);
@


1.172
log
@-Wpointer-sign: char -> gdb_byte.

-Wpointer-sign catches all these cases across the codebase that should
be using gdb_byte for raw target bytes.  I think these are all
obvious, hence I've collapsed into a single patch.

gdb/
2013-04-19  Pedro Alves  <palves@@redhat.com>

	* aarch64-tdep.c (aarch64_default_breakpoint): Change type to
	gdb_byte[].
	(aarch64_breakpoint_from_pc): Change return type to gdb_byte *.
	* ada-lang.c (ada_value_assign): Use gdb_byte.
	* alphanbsd-tdep.c (sigtramp_retcode): Change type to gdb_byte[].
	(alphanbsd_sigtramp_offset): Use gdb_byte.
	* arm-linux-tdep.c (arm_linux_arm_le_breakpoint)
	(arm_linux_arm_be_breakpoint, eabi_linux_arm_le_breakpoint)
	(eabi_linux_arm_be_breakpoint, arm_linux_thumb_be_breakpoint)
	(arm_linux_thumb_le_breakpoint, arm_linux_thumb2_be_breakpoint)
	(arm_linux_thumb2_le_breakpoint): Change type to gdb_byte[].
	* arm-tdep.c (arm_stub_unwind_sniffer)
	(arm_displaced_init_closure): Use gdb_byte.
	(arm_default_arm_le_breakpoint, arm_default_arm_be_breakpoint)
	(arm_default_thumb_le_breakpoint)
	(arm_default_thumb_be_breakpoint): Change type to gdb_byte[].
	* arm-tdep.h (struct gdbarch_tdep) <arm_breakpoint,
	thumb_breakpoint, thumb2_breakpoint>: Change type to gdb_byte *.
	* arm-wince-tdep.c (arm_wince_le_breakpoint)
	(arm_wince_thumb_le_breakpoint): Change type to gdb_byte[].
	* armnbsd-tdep.c (arm_nbsd_arm_le_breakpoint)
	(arm_nbsd_arm_be_breakpoint, arm_nbsd_thumb_le_breakpoint)
	(arm_nbsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* armobsd-tdep.c (arm_obsd_thumb_le_breakpoint)
	(arm_obsd_thumb_be_breakpoint): Change type to gdb_byte[].
	* cris-tdep.c (push_stack_item, cris_push_dummy_call)
	(cris_store_return_value, cris_extract_return_value): Use
	gdb_byte.
	(constraint): Change type of parameter to char * from signed
	char*.  Use gdb_byte.
	* dwarf2loc.c (read_pieced_value, write_pieced_value): Change type
	of local buffer to gdb_byte *.
	* dwarf2read.c (read_index_from_section): Use gdb_byte.
	(create_dwp_hash_table): Change type of locals to gdb_byte *.
	(add_address_entry): Change type of local buffer to gdb_byte[].
	* frv-tdep.c (frv_adjust_breakpoint_address, find_func_descr)
	(frv_push_dummy_call): Use gdb_byte.
	* hppa-hpux-tdep.c (hppa_hpux_push_dummy_code)
	(hppa_hpux_supply_ss_fpblock, hppa_hpux_supply_ss_wide)
	(hppa_hpux_supply_save_state): Use gdb_byte.
	* hppa-tdep.c (hppa32_push_dummy_call)
	(hppa64_convert_code_addr_to_fptr): Use gdb_byte.
	* ia64-tdep.c (extract_bit_field, replace_bit_field)
	(slotN_contents, replace_slotN_contents): Change type of parameter
	to gdb_byte *.
	(fetch_instruction, ia64_pseudo_register_write)
	(ia64_register_to_value, ia64_value_to_register)
	(ia64_extract_return_value, ia64_store_return_value)
	(ia64_push_dummy_call): Use gdb_byte.
	* m32c-tdep.c (m32c_return_value): Remove cast.
	* m68hc11-tdep.c (m68hc11_pseudo_register_write)
	(m68hc11_push_dummy_call, m68hc11_store_return_value): Use
	gdb_byte.
	* mipsnbsd-tdep.c (mipsnbsd_get_longjmp_target): Use gdb_byte.
	* mn10300-tdep.c (mn10300_store_return_value)
	(mn10300_breakpoint_from_pc, mn10300_push_dummy_call): Use
	gdb_byte.
	* moxie-tdep.c (moxie_process_readu): Use gdb_byte.
	(moxie_process_record): Remove casts.
	* ppc-ravenscar-thread.c (supply_register_at_address)
	(ppc_ravenscar_generic_store_registers): Use gdb_byte.
	* ravenscar-thread.c (get_running_thread_id): Use gdb_byte.
	* remote-m32r-sdi.c (m32r_fetch_register): Use gdb_byte.
	* remote-mips.c (mips_xfer_memory): Use gdb_byte.
	* remote.c (compare_sections_command): Use gdb_byte.
	* score-tdep.c (score7_free_memblock): Change type of parameter to
	gdb_byte *.
	* sh-tdep.c (sh_justify_value_in_reg): Change return type to
	gdb_byte *.  Use gdb_byte.
	(sh_push_dummy_call_fpu): Use gdb_byte.
	(sh_extract_return_value_nofpu, sh_extract_return_value_fpu)
	(sh_store_return_value_nofpu, sh_store_return_value_fpu)
	(sh_register_convert_to_virtual, sh_register_convert_to_raw):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh_pseudo_register_read, sh_pseudo_register_write): Use gdb_byte.
	* sh64-tdep.c (sh64_push_dummy_call): Use gdb_byte.
	(sh64_store_return_value, sh64_register_convert_to_virtual):
	Change parameter type to 'gdb_byte *'.  Use gdb_byte.
	(sh64_pseudo_register_write): Use gdb_byte.
	* solib-darwin.c (darwin_current_sos): Add casts to 'gdb_byte *'.
	* solib-irix.c (fetch_lm_info): Likewise.  Use gdb_byte for byte
	buffer.
	(irix_current_sos): Use gdb_byte.
	* solib-som.c (som_current_sos): Use gdb_byte.
	* sparc-ravenscar-thread.c (supply_register_at_address)
	(sparc_ravenscar_generic_store_registers): Use gdb_byte.
	* spu-multiarch.c (spu_xfer_partial): Add cast to 'char *'.
	* spu-tdep.c (spu_get_overlay_table): Use gdb_byte.
	* tic6x-tdep.c (tic6x_breakpoint_from_pc): Change return type to
	'gdb_byte *'.
	* tic6x-tdep.h (struct gdbarch_tdep) <breakpoint>: Change type to
	'gdb_byte *'.
	* tracepoint.c (tfile_fetch_registers): Use gdb_byte.
	* xstormy16-tdep.c (xstormy16_extract_return_value)
	(xstormy16_store_return_value): Change parameter type to
	'gdb_byte *'.  Adjust.
	(xstormy16_push_dummy_call): Use gdb_byte.
	* xtensa-tdep.c (xtensa_scan_prologue, call0_ret)
	(call0_analyze_prologue, execute_code): Use gdb_byte.
@
text
@d93 10
d2099 31
a2129 3
  return dwarf2_evaluate_loc_desc_full (TYPE_TARGET_TYPE (type), frame,
					baton.data, baton.size, baton.per_cu,
					piece->v.ptr.offset + byte_offset);
a2174 10
/* Helper function which throws an error if a synthetic pointer is
   invalid.  */

static void
invalid_synthetic_pointer (void)
{
  error (_("access outside bounds of object "
	   "referenced via synthetic pointer"));
}

@


1.171
log
@	* minsyms.h (struct bound_minimal_symbol): New.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove objfile argument.
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	* minsyms.c (lookup_minimal_symbol_by_pc_1)
	(lookup_minimal_symbol_by_pc_section, lookup_minimal_symbol_by_pc):
	Return bound_minimal_symbol.
	(in_gnu_ifunc_stub): Update.
	(lookup_minimal_symbol_and_objfile): Return bound_minimal_symbol.
	Remove 'objfile_p' argument.
	(lookup_solib_trampoline_symbol_by_pc): Update.
	* ada-tasks.c, amd64-windows-tdep.c, arm-tdep.c,
	arm-wince-tdep.c, block.c, blockframe.c, breakpoint.c, btrace.c,
	c-valprint.c, dwarf2loc.c, elfread.c, frame.c, frv-tdep.c,
	glibc-tdep.c, gnu-v2-abi.c, gnu-v3-abi.c, hppa-hpux-tdep.c,
	i386-tdep.c, ia64-tdep.c, infcall.c, infcmd.c, jit.c,
	linux-fork.c, m32c-tdep.c, m68hc11-tdep.c, maint.c,
	mips-tdep.c, p-valprint.c, parse.c, ppc-linux-tdep.c,
	ppc-sysv-tdep.c, printcmd.c, rs6000-tdep.c, sh64-tdep.c,
	stack.c, symtab.c, tui/tui-disasm.c: Update.
@
text
@d1597 1
a1597 1
  char *buffer = NULL;
d1780 1
a1780 1
  char *buffer = NULL;
@


1.170
log
@	* tracepoint.h (decode_agent_options): Add 'trace_string'
	argument.
	* tracepoint.c (decode_agent_options): Add 'trace_string'
	argument.
	(validate_actionline): Update.
	(collect_symbol): Add 'trace_string' argument.
	(struct add_local_symbols_data) <trace_string>: New field.
	(do_collect_symbol): Update.
	(add_local_symbols): Add 'trace_string' argument.
	(encode_actions_1): Update.
	(trace_dump_actions): Update.
	* dwarf2loc.c (access_memory): Update.
	* ax.h (struct agent_expr) <tracing, trace_string>: New fields.
	* ax-general.c (new_agent_expr): Update.
	* ax-gdb.h (gen_trace_for_expr, gen_trace_for_var)
	(gen_trace_for_return_address): Add argument.
	(trace_kludge, trace_string_kludge): Remove.
	* ax-gdb.c (trace_kludge, trace_string_kludge): Remove.
	(gen_traced_pop, gen_fetch, gen_bitfield_ref, gen_expr): Update.
	(gen_trace_for_var): Add 'trace_string' argument.
	(gen_trace_for_expr, gen_trace_for_return_address): Likewise.
	(gen_printf, agent_eval_command_one): Update.
@
text
@d530 1
a530 1
	    struct minimal_symbol *msym;
d537 2
a538 1
			 msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym));
d543 1
a543 1
	    struct minimal_symbol *msym;
d551 2
a552 1
			 msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym));
d579 1
a579 1
	    msym = lookup_minimal_symbol_by_pc (call_site->pc - 1);
d675 1
a675 1
	      struct minimal_symbol *msym;
d682 2
a683 1
			   msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym),
d707 1
a707 1
  struct minimal_symbol *msym = lookup_minimal_symbol_by_pc (addr - 1);
d710 2
a711 1
		      msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym));
d941 1
a941 1
      struct minimal_symbol *msym_caller, *msym_callee;
d949 2
a950 2
		   (msym_caller == NULL
		    ? "???" : SYMBOL_PRINT_NAME (msym_caller)),
d952 2
a953 2
		   (msym_callee == NULL
		    ? "???" : SYMBOL_PRINT_NAME (msym_callee)),
d1045 2
a1046 1
      struct minimal_symbol *msym = lookup_minimal_symbol_by_pc (func_addr);
d1054 2
a1055 1
		   msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym),
d1061 2
a1062 1
      struct minimal_symbol *msym = lookup_minimal_symbol_by_pc (func_addr);
d1067 2
a1068 1
		   msym == NULL ? "???" : SYMBOL_PRINT_NAME (msym));
d1078 2
a1079 2
      target_msym = lookup_minimal_symbol_by_pc (target_addr);
      func_msym = lookup_minimal_symbol_by_pc (func_addr);
d1102 2
a1103 1
      struct minimal_symbol *msym = lookup_minimal_symbol_by_pc (caller_pc);
@


1.169
log
@2013-03-20  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Tom Tromey  <tromey@@redhat.com>

	PR symtab/8421:
	* coffread.c (coff_register_index): New global.
	(process_coff_symbol, coff_read_enum_type): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_coffread): Initialize new global.
	* dwarf2loc.c (locexpr_find_frame_base_location)
	(dwarf2_block_frame_base_locexpr_funcs)
	(loclist_find_frame_base_location)
	(dwarf2_block_frame_base_loclist_funcs): New.
	(dwarf_expr_frame_base_1): Call SYMBOL_BLOCK_OPS, remove internal_error.
	(dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Add location_has_loclist.
	* dwarf2loc.h (dwarf2_block_frame_base_locexpr_funcs)
	(dwarf2_block_frame_base_loclist_funcs): New.
	* dwarf2read.c (dwarf2_locexpr_index, dwarf2_loclist_index)
	(dwarf2_locexpr_block_index, dwarf2_loclist_block_index): New
	globals.
	(read_func_scope): Update.
	(fixup_go_packaging, mark_common_block_symbol_computed)
	(var_decode_location, new_symbol_full, dwarf2_const_value):
	Set SYMBOL_ACLASS_INDEX.
	(dwarf2_symbol_mark_computed): Likewise.  Add 'is_block' argument.
	(_initialize_dwarf2_read): Initialize new globals.
	* jit.c (finalize_symtab): Set SYMBOL_ACLASS_INDEX.
	* jv-lang.c (add_class_symbol): Set SYMBOL_ACLASS_INDEX.
	* mdebugread.c (mdebug_register_index, mdebug_regparm_index): New
	globals.
	(parse_symbol, psymtab_to_symtab_1): Set SYMBOL_ACLASS_INDEX.
	(_initialize_mdebugread): Initialize new globals.
	* psympriv.h (struct partial_symbol) <aclass>: Update comment.
	* stabsread.c (patch_block_stabs): Set SYMBOL_ACLASS_INDEX.
	(stab_register_index, stab_regparm_index): New globals.
	(define_symbol, read_enum_type, common_block_end): Set
	SYMBOL_ACLASS_INDEX.
	(_initialize_stabsread): Initialize new globals.
	* symtab.c (next_aclass_value, symbol_impl, symbol_impls): New
	globals.
	(MAX_SYMBOL_IMPLS): New define.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl)
	(initialize_ordinary_address_classes): New functions.
	(_initialize_symtab): Call initialize_ordinary_address_classes.
	* symtab.h (enum address_class) <LOC_FINAL_VALUE>: New constant.
	(struct symbol_impl): New.
	(SYMBOL_ACLASS_BITS): New define.
	(struct symbol) <aclass, ops>: Remove fields.
	<aclass_index>: New field.
	(symbol_impls): Declare.
	(SYMBOL_CLASS, SYMBOL_COMPUTED_OPS, SYMBOL_REGISTER_OPS): Redefine.
	(SYMBOL_IMPL, SYMBOL_ACLASS_INDEX): New defines.
	(register_symbol_computed_impl, register_symbol_block_impl)
	(register_symbol_register_impl): Declare.
	(struct symbol_computed_ops): Add location_has_loclist.
	(struct symbol_block_ops): New.
	(SYMBOL_BLOCK_OPS): New.
	* xcoffread.c (process_xcoff_symbol): Set SYMBOL_ACLASS_INDEX.
@
text
@d2571 1
a2571 1
  if (trace_kludge)
@


1.168
log
@2013-03-12  Hui Zhu  <hui@@codesourcery.com>

	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Update error message.
@
text
@d360 41
d405 1
a405 3
  if (SYMBOL_LOCATION_BATON (framefunc) == NULL)
    *length = 0;
  else if (SYMBOL_COMPUTED_OPS (framefunc) == &dwarf2_loclist_funcs)
d407 1
a407 1
      struct dwarf2_loclist_baton *symbaton;
d409 1
a409 2
      symbaton = SYMBOL_LOCATION_BATON (framefunc);
      *start = dwarf2_find_location_expression (symbaton, length, pc);
d412 1
a412 12
    {
      struct dwarf2_locexpr_baton *symbaton;

      symbaton = SYMBOL_LOCATION_BATON (framefunc);
      if (symbaton != NULL)
	{
	  *length = symbaton->size;
	  *start = symbaton->data;
	}
      else
	*length = 0;
    }
d3993 1
d4172 1
@


1.167
log
@2013-03-12  Yao Qi  <yao@@codesourcery.com>
	    Hui Zhu  <hui@@codesourcery.com>

	* dwarf2loc.c (access_memory): Change nbits to nbytes in gdb_assert.
	(dwarf2_compile_expr_to_ax): Call access_memory in DW_OP_deref and
	DW_OP_deref_size.
@
text
@d2937 2
a2938 2
	      error (_("Refn doesn't support size %d"),
		     size * TARGET_CHAR_BIT);
@


1.166
log
@gdb/
	Fix entry-values in C++ across CUs.
	* dwarf2loc.c (call_site_to_target_addr) <FIELD_LOC_KIND_PHYSNAME>: Use
	lookup_minimal_symbol.  Add a comment.
	* dwarf2read.c
	(read_call_site_scope) <is_ref_attr> <die_is_declaration>: Prefer
	DW_AT_linkage_name.

gdb/testsuite/
	Fix entry-values in C++ across CUs.
	* gdb.arch/amd64-tailcall-cxx.exp: New file.
	* gdb.arch/amd64-tailcall-cxx1.S: New file.
	* gdb.arch/amd64-tailcall-cxx1.cc: New file.
	* gdb.arch/amd64-tailcall-cxx2.S: New file.
	* gdb.arch/amd64-tailcall-cxx2.cc: New file.
@
text
@d2542 1
a2542 1
  gdb_assert (nbits > 0 && nbits <= sizeof (LONGEST));
d2936 4
a2939 20
	    switch (size)
	      {
	      case 8:
		ax_simple (expr, aop_ref8);
		break;
	      case 16:
		ax_simple (expr, aop_ref16);
		break;
	      case 32:
		ax_simple (expr, aop_ref32);
		break;
	      case 64:
		ax_simple (expr, aop_ref64);
		break;
	      default:
		/* Note that get_DW_OP_name will never return
		   NULL here.  */
		error (_("Unsupported size %d in %s"),
		       size, get_DW_OP_name (op));
	      }
@


1.165
log
@gdb/
	* dwarf2loc.c (call_site_find_chain_1): New variable save_callee_pc,
	use it.
@
text
@d545 3
a547 1
	msym = lookup_minimal_symbol_text (physname, NULL);
@


1.164
log
@2013-01-31  Aleksandar Ristovski  <aristovski@@qnx.com>

	* charset.c (intermediate_encoding): Remove unused i.
	* completer.c (signal_completer): Remove unused i.
	* continuations.c (discard_my_continuations_1): Remove unused
	continuation_ptr.
	* corelow.c (core_close): Remove unuseD name.
	(get_core_siginfo): Remove unused pid.
	* cp-namespace.c (cp_lookup_symbol_imports_or_template): Remove unused
	i, cps.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Remove unused base_offset.
	(loclist_describe_location): Remove unused first.
	* event-top.c (command_line_handler): Remove unused got_eof.
	* exec.c (exec_close_1): Remove unused need_symtab_cleanup.
	(resize_section_table): Remove unused old_value.
	* gdb_bfd.c (gdb_bfd_map_section): Remove unused header.
	* gnu-v3-abi.c (compute_vtable_size): Remove unused addr.
	* i386-tdep.c (i386_process_record): Remove unused rex.
	* infcmd.c (get_return_value): Remove unused uiout.
	* jv-lang.c (type_from_class): Remove unused is_array.
	* jv-valprint.c (java_val_print): Remove unused i.
	* linux-nat.c (linux_nat_stop_lwp): Remove unused ptid.
	* linux-thread-db.c (thread_db_find_new_threads_2): Remove unuseD pid.
	* m2-typeprint.c (m2_print_type): Remove unused code.
	* macroexp.c (get_character_constant): Remove unused body_start.
	(macro_stringify): Remove unused result.
	* objc-lang.c (find_methods): Remove unused gdbarch.
	* objfiles.c (filter_overlapping_sections): Remove unused abfd1, abfd2.
	* regcache.c (regcache_cooked_read): Remove unused gdbarch.
	* stack.c (print_frame_args): Remove unused summary.
	* thread.c (thread_apply_command): Remove unused p.
	* valarith.c (value_x_unop): Remove unused mangle_ptr.
	* valops.c (search_struct_method): Remove unused skip.
	* valprint.c (generic_val_print): Remove unused byte_order.
	* varobj.c (varobj_update): Remove unused changed.
	* cli/cli-cmds.c (complete_command): Remove unused next_item.
	(alias_command): Remove unused c.
	* mi/mi-cmd-catch.c (mi_catch_load_unload): Remove unused c.
	* mi/mi-main.c (mi_cmd_data_write_register_values): Remove unused
	format.
	(mi_cmd_data_write_memory): Remove unused word_format.
	(mi_cmd_data_write_memory_bytes): Remove unused r.
	* python/py-gdb-readline.c (gdbpy_readline_wrapper): Remove unused
	p_start, p_end.
	* python/python.c (_initialize_python): Remove unused cmd_name, cmd.
	* tui/tui-disasm.c (tui_set_disassem_content): Remove unused
	line_width.

Reference: http://sourceware.org/ml/gdb-patches/2013-01/msg00766.html
@
text
@d796 1
d815 1
a815 1
		 paddress (gdbarch, callee_pc));
@


1.163
log
@	* dwarf2loc.c (dwarf2_find_location_expression): Don't add base address
	to addresses from dwo files.

	testsuite/
	* gdb.dwarf2/fission-loclists.exp: New file.
	* gdb.dwarf2/fission-loclists.S: New file.
@
text
@a2867 1
	    LONGEST base_offset = 0;
a4052 1
  int first = 1;
@


1.162
log
@	* dwarf2loc.c (dwarf2_compile_expr_to_ax) <DW_OP_fbreg>: Only
	require_rvalue for a register location.
@
text
@d255 8
a262 3
      /* Otherwise, a location expression entry.  */
      low += base_address;
      high += base_address;
@


1.161
log
@	PR c++/14999:
	* dwarf2loc.c (dwarf2_compile_expr_to_ax) <DW_OP_fbreg>:
	Call require_rvalue.
gdb/testsuite
	* gdb.dwarf2/trace-crash.s: New file.
	* gdb.dwarf2/trace-crash.exp: New file.
@
text
@d2881 2
a2882 1
	    require_rvalue (expr, loc);
@


1.160
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d2881 1
@


1.159
log
@	* dwarf2read.c (dwarf2_fetch_die_loc_sect_off): New function.
	(dwarf2_fetch_die_loc_cu_off): Rename from
	dwarf2_fetch_die_location_block.  Rewrite to use
	dwarf2_fetch_die_loc_sect_off.
	* dwarf2loc.h (dwarf2_fetch_die_loc_sect_off): Declare.
	(dwarf2_fetch_die_loc_cu_off): Rename.
	* dwarf2loc.c (indirect_pieced_value): Use
	dwarf2_fetch_die_loc_sect_off.
	* dwarf2expr.h (struct dwarf_expr_context) <len, data>: Update
	comment.
	(struct dwarf_expr_piece) <v.ptr.die>: Now a sect_offset.
	* dwarf2expr.c (add_piece): Update.
	(execute_stack_op) <DW_OP_GNU_implicit_pointer>: Update comment.
testsuite
	* gdb.dwarf2/implptr-64bit.exp: Run tests with two CUs as well.
	(test): Add "two_cu" argument.
	* gdb.dwarf2/implptr-64bit.S: Move subprogram later; use ref_addr
	for types; allow two CUs.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2007-2012 Free Software Foundation, Inc.
@


1.158
log
@* dwarf2loc.c (dwarf_expr_frame_base): Add check for the return value of get_frame_block.
@
text
@d432 1
a432 2
  block = dwarf2_fetch_die_location_block (die_offset, per_cu,
					   get_frame_pc, baton);
d2040 4
a2043 3
  baton = dwarf2_fetch_die_location_block (piece->v.ptr.die, c->per_cu,
					   get_frame_address_in_block_wrapper,
					   frame);
d3208 2
a3209 2
	    block = dwarf2_fetch_die_location_block (offset, per_cu,
						     get_ax_pc, expr);
@


1.157
log
@gdb/
	* dwarf2loc.c (dwarf_expr_reg_to_entry_parameter): Remove comment.
@
text
@d335 4
d343 1
a343 1
  framefunc = block_linkage_function (get_frame_block (debaton->frame, NULL));
@


1.156
log
@gdb/
	Fix entry values resolving in inlined frames.
	* dwarf2loc.c (dwarf_expr_reg_to_entry_parameter): Move func_addr,
	gdbarch and caller_frame initialization later.  Skip INLINE_FRAME
	entries of FRAME.

gdb/testsuite/
	Fix entry values resolving in inlined frames.
	* gdb.arch/amd64-entry-value-inline.S: New file.
	* gdb.arch/amd64-entry-value-inline.c: New file.
	* gdb.arch/amd64-entry-value-inline.exp: New file.
@
text
@a991 3
  /* Skip any inlined frames, entry value call sites work between real
     functions.  They do not make sense between inline functions as even PC
     does not change there.  */
@


1.155
log
@gdb/
	* dwarf2loc.c (entry_values_debug): Add 'unsigned'.
	(_initialize_dwarf2loc): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* dwarf2loc.h: Update the declaration of 'entry_values_debug'.
	* dwarf2read.c (dwarf2_die_debug): Add 'unsigned'.
	(_initialize_dwarf2_read): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* darwin-nat.c (dwarwin_debug_flag): Add 'unsigned'.
	(_initialize_darwin_inferior): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* frame.c (frame_debug): Add 'unsigned'.
	(_intialize_frame): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* frame.h: Update the declaration of 'frame_debug'.
	* gdbtypes.c (overload_debug): Add 'unsigned'.
	(_initialize_gdbtypes): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* inferior.h: Update declaration of 'debug_infrun'.
	* infrun.c (debug_infrun): Add 'unsigned'.
	(_initialize_infrun): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* jit.c (jit_debug): Add 'unsigned'.
	(_initialize_jit): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* linux-nat.c (debug_linux_nat): Add 'unsigned'.
	(_initialize_linux_nat): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* linux-thread-db.c (libthread_db_debug): Add 'unsigned'.
	(_initialize_thread_db): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* machoread.c (mach_o_debug_level): Add 'unsigned'.
	(_initialize_machoread): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* mi/mi-cmd-var.c: Update the declaration of 'varobjdebug'.
	* microblaze-tdep.c (microblaze_debug_flag): Add 'unsigned'.
	(_initialize_microblaze_tdep): Call add_setshow_zuinteger_cmd
	intead of add_setshow_zinteger_cmd.
	* mips-tdep.c (mips_debug): Add 'unsigned'.
	(_initialize_mips_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* monitor.c (monitor_debug): Add 'unsigned'.
	(_initialize_remote_monitors): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* observer.c (observer_debug): Add 'unsigned'.
	(_initialize_observer): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* parse.c (expressiondebug): Add 'unsigned'.
	(_initialize_parse): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.c (record_debug): Add 'unsigned'.
	(_initialize_record): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* record.h: Update the declaration of 'record_debug'.
	* stap-probe.c (stap_expression_debug): Add 'unsigned'.
	(_initialize_stap_probe): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* serial.c (global_serial_debug_p): Add 'unsigned'.
	(_initialize_serial): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-dsbt.c (solib_dsbt_debug): Add 'unsigned'.
	(_initialize_dsbt_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* solib-frv.c (solib_frv_debug): Add 'unsigned'.
	(_initialize_frv_solib): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* target.c (targetdebug): Add 'unsigned'.
	(initialize_targets): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* valops.c (overload_debug): Add 'unsigned'.
	* varobj.c (varobjdebug): Add 'unsigned'.
	(_initialize_varobj): Call add_setshow_zuinteger_cmd instead of
	add_setshow_zinteger_cmd.
	* xtensa-tdep.c (xtensa_debug_level): Add 'unsigned'.
	(_initialize_xtensa_tdep): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.

	* arch-utils.h: Remove the declaration of 'gdbarch_debug'.
	* gdbarch.sh (gdbarch_debug): Add 'unsigned'.
	(extern void _initialize_gdbarch): Call add_setshow_zuinteger_cmd
	instead of add_setshow_zinteger_cmd.
	* gdbarch.c, gdbarch.h: Re-generated.
@
text
@d983 3
a985 4
  CORE_ADDR func_addr = get_frame_func (frame);
  CORE_ADDR caller_pc;
  struct gdbarch *gdbarch = get_frame_arch (frame);
  struct frame_info *caller_frame = get_prev_frame (frame);
d992 12
@


1.154
log
@2012-07-26  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2loc.c (locexpr_describe_location_piece): Use uint64_t for
	offset.
@
text
@d461 1
a461 1
int entry_values_debug = 0;
d4149 12
a4160 12
  add_setshow_zinteger_cmd ("entry-values", class_maintenance,
			    &entry_values_debug,
			    _("Set entry values and tail call frames "
			      "debugging."),
			    _("Show entry values and tail call frames "
			      "debugging."),
			    _("When non-zero, the process of determining "
			      "parameter values from function entry point "
			      "and tail call frames will be printed."),
			    NULL,
			    show_entry_values_debug,
			    &setdebuglist, &showdebuglist);
@


1.153
log
@	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Expand parameter
	SIZE to size_t.
	(dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(locexpr_describe_location_1): Likewise.
	* dwarf2loc.h (struct dwarf2_locexpr_baton): Make SIZE as
	size_t.
	(struct dwarf2_loclist_baton): Likewise.
	* dwarf2read.c (struct dwarf_block): Likewise.
	(dump_die_shallow): Use pulongest to print dwarf_block.size.
	(decode_locdesc): Expand SIZE and I to size_t.
@
text
@d3433 1
a3433 1
      ULONGEST offset;
@


1.152
log
@gdb/
	* dwarf2loc.c (disassemble_dwarf_expression): Handle
	DW_OP_GNU_parameter_ref.
@
text
@d57 2
a58 2
						    unsigned short size,
					      struct dwarf2_per_cu_data *per_cu,
d2114 1
a2114 1
			       const gdb_byte *data, unsigned short size,
d2315 1
a2315 1
			  const gdb_byte *data, unsigned short size,
d2436 1
a2436 1
dwarf2_loc_desc_needs_frame (const gdb_byte *data, unsigned short size,
d3830 1
a3830 1
			     const gdb_byte *data, int size,
@


1.151
log
@	* dwarf2expr.c (execute_stack_op): Handle DW_OP_GNU_const_index.
	Adjust address for DW_OP_GNU_addr_index.
	* dwarf2expr.h (dwarf_expr_context): Update comment.
	* dwarf2loc.c (locexpr_describe_location_piece): New arg per_cu,
	all callers updated.  Handle TLS vars described with
	DW_OP_GNU_const_index.
	(disassemble_dwarf_expression): Handle DW_OP_GNU_addr_index
	and DW_OP_GNU_const_index.
	* dwarf2read.c (decode_locdesc): Handle DW_OP_GNU_addr_index.
@
text
@d3800 6
@


1.150
log
@gdb/
	* dwarf2expr.c (execute_stack_op): Support DW_OP_GNU_parameter_ref.
	* dwarf2loc.c (call_site_parameter_matches): Support
	CALL_SITE_PARAMETER_PARAM_OFFSET.
	(needs_dwarf_reg_entry_value): Push stub value.
	* dwarf2read.c (read_call_site_scope): New variable origin.  Support
	CALL_SITE_PARAMETER_PARAM_OFFSET and its DW_AT_abstract_origin.
	* gdbtypes.h (enum call_site_parameter_kind): New item
	CALL_SITE_PARAMETER_PARAM_OFFSET.
	(struct call_site.parameter.u): New field param_offset.

gdb/testsuite/
	* gdb.arch/amd64-entry-value-param.S: New file.
	* gdb.arch/amd64-entry-value-param.c: New file.
	* gdb.arch/amd64-entry-value-param.exp: New file.
@
text
@d3296 1
d3301 1
d3421 23
d3799 11
d3844 1
a3844 1
						  addr, objfile,
@


1.149
log
@gdb/
	Code cleanup: Generalize call_site.parameter key.
	* dwarf2expr.c (execute_stack_op) <DW_OP_GNU_entry_value>: Remove
	variable dwarf_reg.  New variable kind_u.  Update parameters to
	push_dwarf_reg_entry_value.
	(ctx_no_push_dwarf_reg_entry_value): Update parameters.
	* dwarf2expr.h (enum call_site_parameter_kind)
	(union call_site_parameter_u): Forward declarations.
	(struct dwarf_expr_context_funcs): Update parameters and their
	description for push_dwarf_reg_entry_value.
	(ctx_no_push_dwarf_reg_entry_value): Update parameters.
	* dwarf2loc.c (call_site_parameter_matches): New function.
	(dwarf_expr_reg_to_entry_parameter): Update parameters and their
	description.  Use call_site_parameter_matches.
	(dwarf_expr_push_dwarf_reg_entry_value, value_of_dwarf_reg_entry):
	Update parameters and their description.
	(value_of_dwarf_block_entry): Remove variables dwarf_reg and fb_offset.
	New variable kind_u.  Adjust the caller for updated parameters.
	(needs_dwarf_reg_entry_value): Update parameters.
	* dwarf2read.c (read_call_site_scope): New variable loc.  Use it
	instead of attr.  Update for the changed fields of struct
	call_site_parameter.
	* gdbtypes.h: Include dwarf2expr.h.
	(enum call_site_parameter_kind): New.
	(struct call_site.parameter): New field kind.  Wrap dwarf_reg and
	fb_offset into new union u.
@
text
@d965 2
d2402 3
@


1.148
log
@	* dwarf2loc.c (debug_loc_kind): Add DEBUG_LOC_START_LENGTH.
	(DEBUG_LOC_START_END): Renamed from DEBUG_LOC_NORMAL.
	All uses updated.
	(decode_debug_loc_dwo_addresses): New arg "byte_order".  All callers
	updated.  Handle DEBUG_LOC_START_LENGTH.
	(dwarf2_find_location_expression): Handle DEBUG_LOC_START_LENGTH.
	(loclist_describe_location): Ditto.
@
text
@d951 20
a970 3
/* Fetch call_site_parameter from caller matching the parameters.  FRAME is for
   callee.  See DWARF_REG and FB_OFFSET description at struct
   dwarf_expr_context_funcs->push_dwarf_reg_entry_value.
d976 3
a978 2
dwarf_expr_reg_to_entry_parameter (struct frame_info *frame, int dwarf_reg,
				   CORE_ADDR fb_offset,
d1041 1
a1041 6
      if (parameter->dwarf_reg == -1 && dwarf_reg == -1)
	{
	  if (parameter->fb_offset == fb_offset)
	    break;
	}
      else if (parameter->dwarf_reg == dwarf_reg)
d1098 3
a1100 4
/* Execute call_site_parameter's DWARF block matching DEREF_SIZE for caller of
   the CTX's frame.  CTX must be of dwarf_expr_ctx_funcs kind.  See DWARF_REG
   and FB_OFFSET description at struct
   dwarf_expr_context_funcs->push_dwarf_reg_entry_value.
d1107 2
a1108 1
				       int dwarf_reg, CORE_ADDR fb_offset,
d1125 1
a1125 1
  parameter = dwarf_expr_reg_to_entry_parameter (frame, dwarf_reg, fb_offset,
d1222 3
a1224 4
/* Read parameter of TYPE at (callee) FRAME's function entry.  DWARF_REG and
   FB_OFFSET are used to match DW_AT_location at the caller's
   DW_TAG_GNU_call_site_parameter.  See DWARF_REG and FB_OFFSET description at
   struct dwarf_expr_context_funcs->push_dwarf_reg_entry_value.
d1231 2
a1232 1
			  int dwarf_reg, CORE_ADDR fb_offset)
d1242 1
a1242 1
  parameter = dwarf_expr_reg_to_entry_parameter (frame, dwarf_reg, fb_offset,
d1294 1
a1294 6
  int dwarf_reg;
  CORE_ADDR fb_offset;

  dwarf_reg = dwarf_block_to_dwarf_reg (block, block + block_len);
  if (dwarf_reg != -1)
    return value_of_dwarf_reg_entry (type, frame, dwarf_reg, 0 /* unused */);
d1296 8
a1303 2
  if (dwarf_block_to_fb_offset (block, block + block_len, &fb_offset))
    return value_of_dwarf_reg_entry (type, frame, -1, fb_offset);
d2394 2
a2395 1
			     int dwarf_reg, CORE_ADDR fb_offset, int deref_size)
@


1.147
log
@	* dwarf2-frame.c (execute_cfa_program): Update to handle long long ->
	int64_t change to leb128 API.
	(read_encoded_value, decode_frame_entry_1): Ditto.
	* dwarf2expr.c (safe_read_uleb128, safe_read_sleb128): Ditto.
	(dwarf_block_to_dwarf_reg, dwarf_block_to_dwarf_reg_deref): Ditto.
	(dwarf_block_to_fb_offset, dwarf_block_to_sp_offset): Ditto.
	(execute_stack_op): Ditto.
	* dwarf2expr.h (gdb_read_uleb128, gdb_read_sleb128): Ditto.
	(safe_read_uleb128, safe_read_sleb128): Ditto.
	* dwarf2loc.c (decode_debug_loc_dwo_addresses): Ditto.
	(dwarf2_compile_expr_to_ax): Ditto.
	(locexpr_describe_location_piece): Ditto.
	(disassemble_dwarf_expression): Ditto.
	(locexpr_describe_location_1): Ditto.
@
text
@d78 7
a84 1
  DEBUG_LOC_NORMAL = 2,
d133 1
a133 1
  return DEBUG_LOC_NORMAL;
d146 2
a147 1
				CORE_ADDR *low, CORE_ADDR *high)
d167 1
a167 1
    case DEBUG_LOC_NORMAL:
d177 12
a188 1
      return DEBUG_LOC_NORMAL;
d229 1
a229 1
					       &low, &high);
d244 2
a245 1
	case DEBUG_LOC_NORMAL:
d4001 1
a4001 1
					       &low, &high);
d4018 2
a4019 1
	case DEBUG_LOC_NORMAL:
@


1.146
log
@	* dwarf2-frame.c (struct dwarf2_cie): Make initial_instructions, end
	"const gdb_byte *".
	(struct dwarf2_fde): Make instructions, end "const gdb_byte *".
	(execute_cfa_program): Update to match API of leb128 functions.
	(read_1_byte, read_4_bytes, read_8_bytes): Make buf parameter
	"const gdb_byte *".
	(read_unsigned_leb128, read_signed_leb128): Delete.
	(read_initial_length): Change type of buf argument to
	"const gdb_byte *".
	(read_encoded_value): Update to match API of leb128 functions.
	(decode_frame_entry): Change result to "const gdb_byte *", and
	similarly for "start" parameter.
	(decode_frame_entry_1): Ditto.  Use new leb128 reader functions.
	(dwarf2_build_frame_info): Change local frame_ptr to
	"const gdb_byte *".
	* dwarf2expr.c (safe_read_uleb128, safe_read_sleb128): Replaces
	read_uleb128, read_sleb128.  All callers updated.
	(safe_skip_leb128): New function.
	(dwarf_block_to_dwarf_reg): Update to match API of leb128 functions.
	Call gdb_read_uleb128, gdb_skip_leb128 instead of read_uleb128.
	(dwarf_block_to_dwarf_reg_deref): Update to match API of leb128
	functions.  Call gdb_read_uleb128, gdb_read_sleb128 instead of
	read_uleb128, read_sleb128.
	(dwarf_block_to_fb_offset, dwarf_block_to_sp_offset): Ditto.
	(execute_stack_op): Update to match API of leb128 functions.
	* dwarf2expr.h: #include "leb128.h".
	(read_uleb128, read_sleb128): Delete.
	(gdb_read_uleb128, gdb_read_sleb128, gdb_skip_leb128): New functions.
	(safe_read_uleb128, safe_read_sleb128, safe_skip_leb128): Declare.
	* dwarf2loc.c (debug_loc_kind): New enum.
	(decode_debug_loc_addresses): New function.
	(decode_debug_loc_dwo_addresses): New function.
	(dwarf2_find_location_expression): Rewrite.
	(dwarf2_compile_expr_to_ax): Update to match API of leb128 functions.
	(locexpr_describe_location_piece): Ditto.
	(disassemble_dwarf_expression): Ditto.
	(locexpr_describe_location_1): Ditto.
	(loclist_describe_location): Rewrite.
	* dwarf2loc.h (dwarf2_loclist_baton): New member "from_dwo".
	* dwarf2read.c (die_reader_specs): New member "buffer_end".
	(dwarf2_section_buffer_overflow_complaint): Renamed from
	dwarf2_macros_too_long_complaint.  All callers updated.
	(skip_leb128): Delete.
	(init_cu_die_reader): Initialize reader->buffer_end.
	(skip_one_die): Replace call to skip_leb128 with safe_skip_leb128.
	(skip_form_bytes): New arg buffer_end.  All callers updated.
	Replace call to skip_leb128 with gdb_skip_leb128.
	(skip_unknown_opcode): New arg mac_end.  All callers updated.
	(fill_in_loclist_baton): Initialize baton->from_dwo.
@
text
@d142 1
a142 1
  unsigned long long low_index, high_index;
d2569 2
a2570 2
      unsigned long long uoffset, reg;
      long long offset;
d2728 1
a2728 1
	    unsigned long long len;
d3078 1
a3078 1
	    unsigned long long size, offset;
d3270 1
a3270 1
      unsigned long long reg;
d3281 1
a3281 1
      long long frame_offset;
d3284 1
a3284 1
      long long base_offset = 0;
d3338 1
a3338 1
      long long offset;
d3412 2
a3413 2
      unsigned long long ul;
      long long l;
d3633 1
a3633 1
	    unsigned long long offset;
d3688 1
a3688 1
	    unsigned long long reg;
d3797 1
a3797 1
	      unsigned long long bytes;
d3810 1
a3810 1
	      unsigned long long bits, offset;
@


1.145
log
@2012-05-18  Sergio Durigan Junior  <sergiodj@@redhat.com>

	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c:
	* avr-tdep.c:
	* ax-gdb.c:
	* bfin-linux-tdep.c:
	* breakpoint.c:
	* c-valprint.c:
	* cli/cli-cmds.c:
	* coffread.c:
	* cp-support.c:
	* cris-tdep.c:
	* dwarf2-frame-tailcall.c:
	* dwarf2-frame.c:
	* dwarf2expr.c:
	* dwarf2loc.c:
	* dwarf2read.c:
	* elfread.c:
	* eval.c:
	* expprint.c:
	* f-valprint.c:
	* frv-tdep.c:
	* h8300-tdep.c:
	* hppa-hpux-tdep.c:
	* hppa-tdep.c:
	* hppanbsd-tdep.c:
	* i386-nto-tdep.c:
	* i386-tdep.c:
	* i387-tdep.c:
	* ia64-tdep.c:
	* jit.c:
	* linespec.c:
	* linux-tdep.c:
	* lm32-tdep.c:
	* m2-valprint.c:
	* m32c-tdep.c:
	* m32r-rom.c:
	* m32r-tdep.c:
	* m68k-tdep.c:
	* m68klinux-tdep.c:
	* mi/mi-main.c:
	* microblaze-tdep.c:
	* mips-linux-tdep.c:
	* mips-tdep.c:
	* mn10300-tdep.c:
	* p-valprint.c:
	* parse.c:
	* ppc-linux-tdep.c:
	* ppc-sysv-tdep.c:
	* printcmd.c:
	* python/py-finishbreakpoint.c:
	* python/py-inferior.c:
	* python/py-infthread.c:
	* python/py-type.c:
	* python/python.c:
	* remote-fileio.c:
	* remote-m32r-sdi.c:
	* remote-mips.c:
	* reverse.c:
	* rl78-tdep.c:
	* rs6000-aix-tdep.c:
	* rs6000-tdep.c:
	* s390-tdep.c:
	* score-tdep.c:
	* sh64-tdep.c:
	* skip.c:
	* solib-darwin.c:
	* solib-dsbt.c:
	* solib-frv.c:
	* sparc-tdep.c:
	* spu-multiarch.c:
	* spu-tdep.c:
	* stack.c:
	* symfile.c:
	* symtab.c:
	* tic6x-tdep.c:
	* tracepoint.c:
	* v850-tdep.c:
	* valarith.c:
	* valprint.c:
	* value.c:
	* xcoffread.c:
	* xtensa-tdep.c:
	* ada-lang.c:
	* ada-tasks.c:
	* ada-varobj.c:
	* amd64-darwin-tdep.c:
	* arm-symbian-tdep.c:
	* arm-tdep.c: Delete unused variables.
@
text
@d61 115
a187 3
  CORE_ADDR low, high;
  const gdb_byte *loc_ptr, *buf_end;
  int length;
a192 1
  CORE_ADDR base_mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));
d196 1
d203 9
a211 12
      if (buf_end - loc_ptr < 2 * addr_size)
	error (_("dwarf2_find_location_expression: "
		 "Corrupted DWARF expression."));

      if (signed_addr_p)
	low = extract_signed_integer (loc_ptr, addr_size, byte_order);
      else
	low = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
      loc_ptr += addr_size;

      if (signed_addr_p)
	high = extract_signed_integer (loc_ptr, addr_size, byte_order);
d213 6
a218 5
	high = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
      loc_ptr += addr_size;

      /* A base-address-selection entry.  */
      if ((low & base_mask) == base_mask)
d220 4
d226 8
a233 7
	}

      /* An end-of-list entry.  */
      if (low == 0 && high == 0)
	{
	  *locexpr_length = 0;
	  return NULL;
d2569 2
a2570 2
      ULONGEST uoffset, reg;
      LONGEST offset;
d2674 1
a2674 1
	  op_ptr = read_uleb128 (op_ptr, op_end, &uoffset);
d2678 1
a2678 1
	  op_ptr = read_sleb128 (op_ptr, op_end, &offset);
d2720 1
a2720 1
	  op_ptr = read_uleb128 (op_ptr, op_end, &reg);
d2728 1
a2728 1
	    ULONGEST len;
d2730 1
a2730 1
	    op_ptr = read_uleb128 (op_ptr, op_end, &len);
d2784 1
a2784 1
	  op_ptr = read_sleb128 (op_ptr, op_end, &offset);
d2795 2
a2796 2
	    op_ptr = read_uleb128 (op_ptr, op_end, &reg);
	    op_ptr = read_sleb128 (op_ptr, op_end, &offset);
d2827 1
a2827 1
	    op_ptr = read_sleb128 (op_ptr, op_end, &offset);
d2928 1
a2928 1
	  op_ptr = read_uleb128 (op_ptr, op_end, &reg);
d3078 1
a3078 1
	    ULONGEST size, offset;
d3084 1
a3084 1
            op_ptr = read_uleb128 (op_ptr, op_end, &size);
d3091 1
a3091 1
	      op_ptr = read_uleb128 (op_ptr, op_end, &offset);
d3251 2
a3252 1
   DATA.  */
d3270 1
a3270 1
      ULONGEST reg;
d3272 1
a3272 1
      data = read_uleb128 (data + 1, end, &reg);
d3281 1
a3281 1
      LONGEST frame_offset;
d3284 1
a3284 1
      LONGEST base_offset = 0;
d3286 1
a3286 1
      new_data = read_sleb128 (data + 1, end, &frame_offset);
d3310 2
a3311 2
	  buf_end = read_sleb128 (base_data + 1,
				  base_data + base_size, &base_offset);
d3338 1
a3338 1
      LONGEST offset;
d3340 1
a3340 1
      data = read_sleb128 (data + 1, end, &offset);
d3395 3
a3397 1
   will keep going until it reaches the end of the expression.  */
d3412 2
a3413 2
      ULONGEST ul;
      LONGEST l;
d3474 1
a3474 1
	  data = read_uleb128 (data, end, &ul);
d3478 1
a3478 1
	  data = read_sleb128 (data, end, &l);
d3519 1
a3519 1
	  data = read_uleb128 (data, end, &ul);
d3525 1
a3525 1
	  data = read_uleb128 (data, end, &ul);
d3562 1
a3562 1
	  data = read_sleb128 (data, end, &l);
d3568 2
a3569 2
	  data = read_uleb128 (data, end, &ul);
	  data = read_sleb128 (data, end, &l);
d3577 1
a3577 1
	  data = read_sleb128 (data, end, &l);
d3589 1
a3589 1
	  data = read_uleb128 (data, end, &ul);
d3627 1
a3627 1
	  data = read_uleb128 (data, end, &ul);
d3633 1
a3633 1
	    ULONGEST offset;
d3635 2
a3636 2
	    data = read_uleb128 (data, end, &ul);
	    data = read_uleb128 (data, end, &offset);
d3648 1
a3648 1
	    data = read_sleb128 (data, end, &l);
d3662 1
a3662 1
	    data = read_uleb128 (data, end, &ul);
d3677 1
a3677 1
	    data = read_uleb128 (data, end, &ul);
d3688 1
a3688 1
	    ULONGEST reg;
d3692 2
a3693 2
	    data = read_uleb128 (data, end, &reg);
	    data = read_uleb128 (data, end, &ul);
d3710 1
a3710 1
	    data = read_uleb128 (data, end, &ul);
d3728 1
a3728 1
	  data = read_uleb128 (data, end, &ul);
d3797 1
a3797 1
	      ULONGEST bytes;
d3799 1
a3799 1
	      data = read_uleb128 (data + 1, end, &bytes);
d3810 1
a3810 1
	      ULONGEST bits, offset;
d3812 2
a3813 2
	      data = read_uleb128 (data + 1, end, &bits);
	      data = read_uleb128 (data, end, &offset);
a3952 1
  CORE_ADDR low, high;
d3954 1
a3954 1
  int length, first = 1;
a3960 1
  CORE_ADDR base_mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));
d3964 1
d3972 1
a3972 1
  while (1)
d3974 9
a3982 6
      if (buf_end - loc_ptr < 2 * addr_size)
	error (_("Corrupted DWARF expression for symbol \"%s\"."),
	       SYMBOL_PRINT_NAME (symbol));

      if (signed_addr_p)
	low = extract_signed_integer (loc_ptr, addr_size, byte_order);
d3984 6
a3989 11
	low = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
      loc_ptr += addr_size;

      if (signed_addr_p)
	high = extract_signed_integer (loc_ptr, addr_size, byte_order);
      else
	high = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
      loc_ptr += addr_size;

      /* A base-address-selection entry.  */
      if ((low & base_mask) == base_mask)
d3991 4
d3999 8
a4008 4
      /* An end-of-list entry.  */
      if (low == 0 && high == 0)
	break;

@


1.144
log
@	* dwarf2read.c (dwarf_tag_name): Return const char *.  Use
	get_DW_TAG_name.
	(dwarf_attr_name): Return const char *.  Use get_DW_AT_name.
	(dwarf_form_name): Return const char *.  Use get_DW_FORM_name.
	(dwarf_stack_op_name): Remove.
	(dwarf_cfi_name): Return const char *.  Use get_DW_ATE_name.
	(decode_locdesc): Use get_DW_OP_name.
	* dwarf2loc.c (unimplemented): Use get_DW_OP_name.
	(dwarf2_compile_expr_to_ax): Likewise.
	(disassemble_dwarf_expression): Likewise.
	* dwarf2expr.h: (dwarf_stack_op_name): Remove.
@
text
@a653 1
  struct func_type *func_specific;
a834 2
  struct value *val;
  struct dwarf2_locexpr_baton *dwarf_block;
a2694 1
	    unsigned int before_stack_len;
@


1.143
log
@	Initial support for Fission.  http://gcc.gnu.org/wiki/DebugFission
	* symfile.c (default_symfile_relocate): Use sectp->owner instead of
	objfile->obfd.
	* symfile.h (dwarf2_debug_sections): New member addr.
	* dwarf2expr.c (execute_stack_op): New case DW_OP_GNU_addr_index.
	(ctx_no_get_addr_index): New function.
	* dwarf2expr.h (dwarf_expr_context_funcs): New member get_addr_index.
	(ctx_no_get_addr_index): Declare.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Update.
	* dwarf2loc.c (dwarf_expr_get_addr_index): New function.
	(dwarf_expr_ctx_funcs): Update.
	(needs_get_addr_index): New function.
	(needs_frame_ctx_funcs): Update.
	* dwarf2loc.h (dwarf2_read_addr_index): Declare.
	* dwarf2read.c: #include "gdbcore.h".
	(dwarf2_per_objfile): New members addr, dwo_files.
	(dwarf2_elf_names): Add entry for addr.
	(struct dwo_section_names): New type.
	(dwo_section_names): New static global.
	(dwarf2_cu): New members dwo_unit, addr_base, have_addr_base.
	(dwarf2_per_cu_data): New member is_debug_types, all boolean uses of
	old debug_types_section member updated to use this.
	Rename member debug_types_section to info_or_types_section,
	all uses updated.
	(signatured_type): Rename member type_offset to type_offset_in_tu,
	all uses updated.  New member type_offset_in_section.
	(struct dwo_sections): New type.
	(struct dwo_unit): New type.
	(struct dwo_file): New type.
	(die_reader_specs): New member dwo_file.
	(dwarf2_locate_sections): Watch for .debug_addr.
	(zlib_decompress_section): Use sectp->owner instead of objfile->obfd.
	(dwarf2_read_section): Get bfd of section from bfd's asection,
	instead of objfile.
	(create_cus_from_index): Initialize the_cu->info_or_types_section.
	(create_signatured_type_table_from_index): Initialize
	sig_type->info_or_types_section.
	(dw2_get_file_names): Statement lists for type units with DWO files
	live in the DWO file.
	(create_debug_types_hash_table): New function.
	(create_all_type_units): Rewrite.
	(init_cu_die_reader): New arg dwo_file, all callers updated.
	(init_and_read_dies_worker): Get section from
	this_cu->info_or_types_section.  Set sig_type->type_offset_in_section.
	Watch for DW_AT_GNU_dwo_name and if present lookup the file and
	continue reading the CU/TU from there.
	(init_cutu_and_read_dies_no_follow): New arg dwo_file, all callers
	updated.  Get section from this_cu->info_or_types_section.
	(create_all_comp_units): Initialize this_cu->info_or_types_section.
	(skip_one_die): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(hash_dwo_file, eq_dwo_file): New functions.
	(allocate_dwo_file_hash_table): New function.
	(hash_dwo_unit, eq_dwo_unit): New functions.
	(allocate_dwo_unit_table): New function.
	(dwarf2_locate_dwo_sections): New function.
	(struct create_dwo_info_table_data): New type.
	(create_debug_info_hash_table_reader): New function.
	(create_debug_info_hash_table): New function.
	(try_open_dwo_file, open_dwo_file, init_dwo_file): New function.
	(lookup_dwo_file): New function.
	(lookup_dwo_comp_unit, lookup_dwo_type_unit): New functions.
	(free_dwo_file, free_dwo_file_cleanup): New functions.
	(free_dwo_file_from_slot, free_dwo_files): New functions.
	(dwarf2_get_pc_bounds): Handle DW_FORM_GNU_addr_index.
	(dwarf2_record_block_ranges): Ditto.
	(read_partial_die): Ditto.
	(process_enumeration_scope): Update to use type_offset_in_section.
	(read_full_die_1): New function.
	(read_full_die): Rewrite.
	(read_attribute_value): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(read_addr_index_1, read_addr_index): New functions.
	(read_addr_index_from_leb128): New function.
	(struct dwarf2_read_addr_index_data): New type.
	(dwarf2_read_addr_index_reader): New function.
	(dwarf2_read_addr_index): New function.
	(read_str_index): New function.
	(leb128_size): New function.
	(dwarf_decode_line_header): Delete arg abfd, all callers updated.
	If processing a type unit from a DWO file, get the line section
	from the DWO file.
	(var_decode_location): Watch for DW_OP_GNU_addr_index.
	(dwarf2_const_value_attr): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(lookup_die_type): Check whether section offset of type's die is
	known before looking it up.  Remove assert.  Condition can
	legimately happen for inter-cu type references.
	(dwarf_attr_name): Handle Fission attributes.
	(dwarf_form_name): Handle Fission forms.
	(dump_die_shallow): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(follow_die_sig): Update to use type_offset_in_section.
	(decode_locdesc): New case DW_OP_GNU_addr_index.
	(skip_form_bytes): New cases DW_FORM_GNU_addr_index,
	DW_FORM_GNU_str_index.
	(cu_debug_loc_section): New function.
	(fill_in_loclist_baton, dwarf2_symbol_mark_computed): Call it.
	(dwarf2_per_objfile_free): Unmap .debug_addr section.
	Free DWO files if present.
	* xcoffread.c (dwarf2_xcoff_names): Add .debug_addr.

	testsuite/
	* gdb.dwarf2/dw2-intercu.S (.Ltype_int2_in_cu2): Renamed from
	.Ltype_int_in_cu2.  Use name "int2" instead of "int".
	All uses updated.
	* gdb.dwarf2/dw2-intercu.exp: Add "ptype int2" ahead of
	"ptype func_cu1" to expand cu2 before cu1.
@
text
@d2334 1
a2334 1
  const char *name = dwarf_stack_op_name (op);
d2780 1
a2780 1
		/* Note that dwarf_stack_op_name will never return
d2783 1
a2783 1
		       size, dwarf_stack_op_name (op));
d3302 1
a3302 1
      name = dwarf_stack_op_name (op);
@


1.142
log
@gdb/
	Code cleanupp: Use cu_offset and sect_offset compile time type checking.
	* dwarf2expr.c (add_piece, dwarf_get_base_type, execute_stack_op)
	(ctx_no_dwarf_call, ctx_no_get_base_type): Use cu_offset and
	sect_offset.
	* dwarf2expr.h (cu_offset, sect_offset): New types.
	(struct dwarf_expr_context_funcs) <dwarf_call>
	(struct dwarf_expr_context_funcs) <get_base_type>: Use cu_offset and
	sect_offset.
	(struct dwarf_expr_context) <len>: Improve the comment.
	(struct dwarf_expr_piece, ctx_no_dwarf_call, ctx_no_get_base_type): Use
	cu_offset and sect_offset.
	* dwarf2loc.c (per_cu_dwarf_call, dwarf_expr_dwarf_call)
	(dwarf_expr_get_base_type, needs_frame_dwarf_call)
	(dwarf2_compile_expr_to_ax, disassemble_dwarf_expression): Likewise.
	* dwarf2loc.h: Include dwarf2expr.h.
	(dwarf2_fetch_die_location_block, dwarf2_get_die_type): Use cu_offset
	and sect_offset.
	* dwarf2read.c (struct dwarf2_per_objfile) <debug_types_type_hash>:
	Improve the comment.
	(struct comp_unit_head, struct dwarf2_cu, struct dwarf2_per_cu_data)
	(struct signatured_type, struct line_header, struct partial_die_info)
	(struct die_info, find_partial_die, dwarf2_get_ref_die_offset)
	(lookup_signatured_type_at_offset, dwarf2_find_containing_comp_unit)
	(get_die_type_at_offset, create_cus_from_index)
	(create_signatured_type_table_from_index, dw2_get_file_names)
	(offset_in_cu_p, read_comp_unit_head, error_check_comp_unit_head)
	(read_and_check_comp_unit_head, read_and_check_type_unit_head)
	(create_debug_types_hash_table, process_psymtab_comp_unit)
	(load_partial_comp_unit, create_all_comp_units)
	(partial_die_parent_scope, partial_die_full_name, skip_one_die)
	(load_full_comp_unit, dwarf2_physname, read_import_statement)
	(inherit_abstract_dies, read_func_scope, read_call_site_scope)
	(dwarf2_add_member_fn, process_enumeration_scope, read_module_type)
	(read_typedef, die_hash, die_eq, read_full_die, dwarf2_read_abbrevs)
	(load_partial_dies, read_partial_die, find_partial_die_in_comp_unit)
	(find_partial_die, read_attribute_value, lookup_die_type)
	(dump_die_shallow, store_in_ref_table): Use cu_offset and sect_offset.
	(is_ref_attr): New function comment.
	(dwarf2_get_ref_die_offset): New function comment, new variable retval.
	Use cu_offset and sect_offset.
	(follow_die_offset, follow_die_ref, dwarf2_fetch_die_location_block)
	(dwarf2_get_die_type, follow_die_sig, lookup_signatured_type_at_offset)
	(load_full_type_unit, read_signatured_type, per_cu_header_read_in)
	(dwarf2_find_containing_comp_unit, struct dwarf2_offset_and_type)
	(offset_and_type_hash, offset_and_type_eq, set_die_type)
	(get_die_type_at_offset, partial_die_hash, partial_die_eq)
	(write_one_signatured_type, write_psymtabs_to_index): Use cu_offset and
	sect_offset.
@
text
@d1011 11
d1956 2
a1957 1
  dwarf_expr_push_dwarf_reg_entry_value
d2256 9
d2277 2
a2278 1
  needs_dwarf_reg_entry_value
@


1.141
log
@gdb:

	* inferior.h (struct inferior): Remove fields any_syscall_count,
	syscalls_counts and total_syscalls_count.  Move them to new
	struct catch_syscall_inferior_data in breakpoint.c.
	* breakpoint.c: Call DEF_VEC_I(int).
	(struct catch_syscall_inferior_data): New.
	(get_catch_syscall_inferior_data): New.
	(catch_syscall_inferior_data_cleanup): New.
	(insert_catch_syscall): Update to access data in
	struct catch_syscall_inferior_data.
	(insert_catch_syscall): Likewise.
	(remove_catch_syscall): Likewise.
	(remove_catch_syscall): Likewise.
	(is_syscall_catchpoint_enabled): Likewise.
	(add_catch_command): Likewise.
	(_initialize_breakpoint): Register cleanup.
	* breakpoint.h: Removed DEF_VEC_I(int).
	* dwarf2loc.c: Call DEF_VEC_I(int).
	* mi/mi-main.c: Likewise.
@
text
@d287 1
a287 1
per_cu_dwarf_call (struct dwarf_expr_context *ctx, size_t die_offset,
d306 1
a306 1
dwarf_expr_dwarf_call (struct dwarf_expr_context *ctx, size_t die_offset)
d317 2
a318 1
dwarf_expr_get_base_type (struct dwarf_expr_context *ctx, size_t die_offset)
d2225 1
a2225 1
needs_frame_dwarf_call (struct dwarf_expr_context *ctx, size_t die_offset)
d3018 1
d3023 2
a3024 1
	    block = dwarf2_fetch_die_location_block (uoffset, per_cu,
d3523 1
a3523 1
	    ULONGEST offset;
d3526 2
a3527 1
	    data = read_uleb128 (data, end, &offset);
d3531 1
a3531 1
	    fprintf_filtered (stream, " [0x%s]> %d", phex_nz (offset, 0),
d3538 1
a3538 1
	    ULONGEST type_die;
d3541 2
a3542 1
	    data = read_uleb128 (data, end, &type_die);
d3546 1
a3546 1
	    fprintf_filtered (stream, " [0x%s]>", phex_nz (type_die, 0));
d3552 2
a3553 1
	    ULONGEST type_die, reg;
d3557 2
a3558 1
	    data = read_uleb128 (data, end, &type_die);
d3563 2
a3564 1
	    fprintf_filtered (stream, " [0x%s]> [$%s]", phex_nz (type_die, 0),
d3572 1
a3572 1
	    ULONGEST type_die;
d3574 2
a3575 1
	    data = read_uleb128 (data, end, &type_die);
d3577 1
a3577 1
	    if (type_die == 0)
d3586 1
a3586 1
		fprintf_filtered (stream, " [0x%s]>", phex_nz (type_die, 0));
@


1.140
log
@2012-03-01  Pedro Alves  <palves@@redhat.com>

	* amd64-linux-tdep.c (amd64_linux_record_signal): Make static.
	* breakpoint.c (create_exception_master_breakpoint, trace_command)
	(ftrace_command, strace_command): Make static.
	* d-lang.c (_initialize_d_language): Declare.
	* dwarf2expr.c (_initialize_dwarf2expr): Declare.
	* dwarf2loc.c (_initialize_dwarf2loc):
	* dwarf2read.c (process_psymtab_comp_unit): Make static.
	* exec.c (exec_get_section_table): Make static.
	* i386-linux-tdep.c (i386_linux_record_signal): Make static.
	* infcmd.c (ensure_valid_thread, ensure_not_tfind_mode): Make static.
	* inferior.c (remove_inferior_command, add_inferior_command)
	(clone_inferior_command): Make static.
	* linux-nat.c (linux_nat_thread_address_space)
	(linux_nat_core_of_thread): Make static.
	* linux-tdep.c (_initialize_linux_tdep): Declare.
	* objc-lang.c (_initialize_objc_lang): Declare.
	* opencl-lang.c (builtin_opencl_type, opencl_language_arch_info):
	Make static.
	(_initialize_opencl_language): Declare.
	* record.c (_initialize_record): Declare.
	* remote.c (demand_private_info, remote_get_tib_address)
	(remote_supports_cond_tracepoints)
	(remote_supports_fast_tracepoints, remote_get_tracepoint_status):
	Make static.
	* skip.c (_initialize_step_skip): Declare.
	* symtab.c (skip_prologue_using_lineinfo): Make static.
	* tracepoint.c (delete_trace_state_variable)
	(trace_variable_command, delete_trace_variable_command)
	(get_uploaded_tsv, find_matching_tracepoint_location)
	(find_matching_tsv, create_tsv_from_upload, get_traceframe_info):
	Make static.
	* value.c (pack_unsigned_long): Make static.
	* varobj.c (varobj_ensure_python_env): Make static.
	* windows-tdep.c (_initialize_windows_tdep): Declare.
	* xml-syscall.c (make_cleanup_free_syscalls_info): Make static.
@
text
@d45 2
@


1.139
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3909 3
@


1.138
log
@the "ambiguous linespec" series
gdb
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * language.h (struct language_defn): Add new component
        la_symbol_name_compare.
        * symfile.h (struct quick_symbol_functions): Update the profile
        of parameter "name_matcher" for the expand_symtabs_matching
        method.  Update the documentation accordingly.
        * ada-lang.h (ada_name_for_lookup): Add declaration.
        * ada-lang.c (ada_name_for_lookup): New function, extracted out
        from ada_iterate_over_symbols.
        (ada_iterate_over_symbols): Do not encode symbol name anymore.
        (ada_expand_partial_symbol_name): Adjust profile.
        (ada_language_defn): Add value for la_symbol_name_compare field.
        * linespec.c: #include "ada-lang.h".
        (iterate_name_matcher): Add language parameter. Replace call
        to strcmp_iw by call to language->la_symbol_name_compare.
        (decode_variable): Encode COPY if current language is Ada.
        * dwarf2read.c (dw2_expand_symtabs_matching): Adjust profile
        of name_matcher parameter.  Adjust call to name_matcher.
        * psymtab.c (expand_symtabs_matching_via_partial): Likewise.
        (expand_partial_symbol_names): Update profile of parameter "fun".
        * psymtab.h (expand_partial_symbol_names): Update profile of
        parameter "fun".
        * symtab.c (demangle_for_lookup): Update function documentation.
        (search_symbols_name_matches): Add language parameter.
        (expand_partial_symbol_name): Likewise.
        * c-lang.c (c_language_defn, cplus_language_defn)
        (asm_language_defn, minimal_language_defn): Add value for
        la_symbol_name_compare field.
        * d-lang.c (d_language_defn): Likewise.
        * f-lang.c (f_language_defn): Ditto.
        * jv-lang.c (java_language_defn): Ditto.
        * m2-lang.c (m2_language_defn): Ditto.
        * objc-lang.c (objc_language_defn): Ditto.
        * opencl-lang.c (opencl_language_defn): Ditto.
        * p-lang.c (pascal_language_defn): Ditto.
        * language.c (unknown_language_defn, auto_language_defn)
        (local_language_defn): Ditto.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* linespec.c (iterate_over_all_matching_symtabs): Use
	LA_ITERATE_OVER_SYMBOLS.
	(lookup_prefix_sym, add_matching_symbols_to_info): Likewise.
	(find_function_symbols, decode_variable): Remove Ada special
	case.
	* language.h (struct language_defn) <la_iterate_over_symbols>: New
	field.
	(LA_ITERATE_OVER_SYMBOLS): New macro.
	* language.c (unknown_language_defn, auto_language_defn)
	(local_language_defn): Update.
	* c-lang.c (c_language_defn, cplus_language_defn)
	(asm_language_defn, minimal_language_defn): Update.
	* d-lang.c (d_language_defn): Update.
	* f-lang.c (f_language_defn): Update.
	* jv-lang.c (java_language_defn): Update.
	* m2-lang.c (m2_language_defn): Update.
	* objc-lang.c (objc_language_defn): Update.
	* opencl-lang.c (opencl_language_defn): Update.
	* p-lang.c (pascal_language_defn): Update.
	* ada-lang.c (ada_iterate_over_symbols): New function.
	(ada_language_defn): Update.

2011-12-06  Tom Tromey  <tromey@@redhat.com>
	    Joel Brobecker  <brobecker@@acacore.com>

	PR breakpoints/13105, PR objc/8341, PR objc/8343, PR objc/8366,
	PR objc/8535, PR breakpoints/11657, PR breakpoints/11970,
	PR breakpoints/12023, PR breakpoints/12334, PR breakpoints/12856,
	PR shlibs/8929, PR shlibs/7393:
	* python/py-type.c (compare_maybe_null_strings): Rename from
	compare_strings.
	(check_types_equal): Update.
	* utils.c (compare_strings): New function.
	* tui/tui-winsource.c (tui_update_breakpoint_info): Update for
	location changes.
	* tracepoint.c (scope_info): Update.
	(trace_find_line_command): Use DECODE_LINE_FUNFIRSTLINE.
	* symtab.h (iterate_over_minimal_symbols)
	(iterate_over_some_symtabs, iterate_over_symtabs)
	(find_pcs_for_symtab_line, iterate_over_symbols)
	(demangle_for_lookup): Declare.
	(expand_line_sal): Remove.
	* symtab.c (iterate_over_some_symtabs, iterate_over_symtabs)
	(lookup_symtab_callback): New functions.
	(lookup_symtab): Rewrite.
	(demangle_for_lookup): New function, extract from
	lookup_symbol_in_language.
	(lookup_symbol_in_language): Use it.
	(iterate_over_symbols): New function.
	(find_line_symtab): Update.
	(find_pcs_for_symtab_line): New functions.
	(find_line_common): Add 'start' argument.
	(decode_line_spec): Update.  Change argument to 'flags', change
	interpretation.
	(append_expanded_sal): Remove.
	(append_exact_match_to_sals): Remove.
	(expand_line_sal): Remove.
	* symfile.h (struct quick_symbol_functions) <lookup_symtab>:
	Remove.
	<map_symtabs_matching_filename>: New field.
	* stack.c (func_command): Only look in the current program space.
	Use DECODE_LINE_FUNFIRSTLINE.
	* source.c (line_info): Set pspace on sal.  Check program space in
	the loop.  Use DECODE_LINE_LIST_MODE.
	(select_source_symtab): Use DECODE_LINE_FUNFIRSTLINE.
	* solib-target.c: Remove DEF_VEC_I(CORE_ADDR).
	* python/python.c (gdbpy_decode_line): Update.
	* psymtab.c (partial_map_expand_apply): New function.
	(partial_map_symtabs_matching_filename): Rename from
	lookup_partial_symbol.  Update arguments.
	(lookup_symtab_via_partial_symtab): Remove.
	(psym_functions): Update.
	* objc-lang.h (parse_selector, parse_method): Don't declare.
	(find_imps): Update.
	* objc-lang.c (parse_selector, parse_method): Now static.
	(find_methods): Change arguments.  Fill in a vector of symbol
	names.
	(uniquify_strings): New function.
	(find_imps): Change arguments.
	* minsyms.c (iterate_over_minimal_symbols): New function.
	* linespec.h (enum decode_line_flags): New.
	(struct linespec_sals): New.
	(struct linespec_result) <canonical>: Remove.
	<pre_expanded, addr_string, sals>: New fields.
	(destroy_linespec_result, make_cleanup_destroy_linespec_result)
	(decode_line_full): Declare.
	(decode_line_1): Update.
	* linespec.c (struct address_entry, struct linespec_state, struct
	collect_info): New types.
	(add_sal_to_sals_basic, add_sal_to_sals, hash_address_entry)
	(eq_address_entry, maybe_add_address): New functions.
	(total_number_of_methods): Remove.
	(iterate_name_matcher, iterate_over_all_matching_symtabs): New
	functions.
	(find_methods): Change arguments.  Don't canonicalize input.
	Simplify logic.
	(add_matching_methods, add_constructors)
	(build_canonical_line_spec): Remove.
	(filter_results, convert_results_to_lsals): New functions.
	(decode_line_2): Change arguments.  Rewrite for new data
	structures.
	(decode_line_internal): Rename from decode_line_1.  Change
	arguments.  Add cleanups.  Update for new data structures.
	(linespec_state_constructor, linespec_state_destructor)
	(decode_line_full, decode_line_1): New functions.
	(decode_indirect): Change arguments.  Update.
	(locate_first_half): Use skip_spaces.
	(decode_objc): Change arguments.  Update for new data structures.
	Simplify logic.
	(decode_compound): Change arguments.  Add cleanups.  Remove
	fallback code, replace with error.
	(struct decode_compound_collector): New type.
	(collect_one_symbol): New function.
	(lookup_prefix_sym): Change arguments.  Update.
	(compare_symbol_name, add_all_symbol_names_from_pspace)
	(find_superclass_methods ): New functions.
	(find_method): Rewrite.
	(struct symtab_collector): New type.
	(add_symtabs_to_list, collect_symtabs_from_filename): New
	functions.
	(symtabs_from_filename): Change API.  Rename from
	symtab_from_filename.
	(collect_function_symbols): New function.
	(find_function_symbols): Change API.  Rename from
	find_function_symbol.  Rewrite.
	(decode_all_digits): Change arguments.  Rewrite.
	(decode_dollar): Change arguments.  Use decode_variable.
	(decode_label): Change arguments.  Rewrite.
	(collect_symbols): New function.
	(minsym_found): Change arguments.  Rewrite.
	(check_minsym, search_minsyms_for_name)
	(add_matching_symbols_to_info): New function.
	(decode_variable): Change arguments.  Iterate over all symbols.
	(symbol_found): Remove.
	(symbol_to_sal): New function.
	(init_linespec_result, destroy_linespec_result)
	(cleanup_linespec_result, make_cleanup_destroy_linespec_result):
	New functions.
	(decode_digits_list_mode, decode_digits_ordinary): New functions.
	* dwarf2read.c (dw2_map_expand_apply): New function.
	(dw2_map_symtabs_matching_filename): Rename from
	dw2_lookup_symtab.  Change arguments.
	(dwarf2_gdb_index_functions): Update.
	* dwarf2loc.c: Remove DEF_VEC_I(CORE_ADDR).
	* defs.h (compare_strings): Declare.
	* cli/cli-cmds.c (compare_strings): Move to utils.c.
	(edit_command, list_command): Use DECODE_LINE_LIST_MODE.  Call
	filter_sals.
	(compare_symtabs, filter_sals): New functions.
	* breakpoint.h (struct bp_location) <line_number, source_file>:
	New fields.
	(struct breakpoint) <line_number, source_file>: Remove.
	<filter>: New field.
	* breakpoint.c (print_breakpoint_location, init_raw_breakpoint)
	(momentary_breakpoint_from_master, add_location_to_breakpoint):
	Update for changes to locations.
	(init_breakpoint_sal): Add 'filter' argument.  Set 'filter' on
	breakpoint.
	(create_breakpoint_sal): Add 'filter' argument.
	(remove_sal, expand_line_sal_maybe): Remove.
	(create_breakpoints_sal): Remove 'sals' argument.  Handle
	pre-expanded sals and the filter.
	(parse_breakpoint_sals): Use decode_line_full.
	(check_fast_tracepoint_sals): Use get_sal_arch.
	(create_breakpoint): Create a linespec_sals.  Update.
	(break_range_command): Use decode_line_full.  Update.
	(until_break_command): Update.
	(clear_command): Update match conditions for linespec.c changes.
	Use DECODE_LINE_LIST_MODE.
	(say_where): Update for changes to locations.
	(bp_location_dtor): Free 'source_file'.
	(base_breakpoint_dtor): Free 'filter'.  Don't free 'source_file'.
	(update_static_tracepoint): Update for changes to locations.
	(update_breakpoint_locations): Disable ranged breakpoint if too
	many locations match.  Update.
	(addr_string_to_sals): Use decode_line_full.  Resolve all sal
	PCs.
	(breakpoint_re_set_default): Don't call expand_line_sal_maybe.
	(decode_line_spec_1): Update.  Change argument name to 'flags',
	change interpretation.
	* block.h (block_containing_function): Declare.
	* block.c (block_containing_function): New function.
	* skip.c (skip_function_command): Update.
	(skip_re_set): Update.
	* infcmd.c (jump_command): Use DECODE_LINE_FUNFIRSTLINE.
	* mi/mi-main.c (mi_cmd_trace_find): Use DECODE_LINE_FUNFIRSTLINE.
	* NEWS: Add entry.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* elfread.c (elf_gnu_ifunc_resolver_return_stop): Allow
	breakpoint's pspace to be NULL.
	* breakpoint.h (struct breakpoint) <pspace>: Update comment.
	* breakpoint.c (init_raw_breakpoint): Conditionally set
	breakpoint's pspace.
	(init_breakpoint_sal): Don't set breakpoint's pspace.
	(prepare_re_set_context): Conditionally switch program space.
	(addr_string_to_sals): Check executing_startup on location's
	program space.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* breakpoint.h (enum enable_state) <bp_startup_disabled>: Remove.
	* breakpoint.c (should_be_inserted): Explicitly check if program
	space is executing startup.
	(describe_other_breakpoints): Update.
	(disable_breakpoints_before_startup): Change executing_startup
	earlier.  Remove loop.
	(enable_breakpoints_after_startup): Likewise.
	(init_breakpoint_sal): Don't use bp_startup_disabled.
	(create_breakpoint): Don't use bp_startup_disabled.
	(update_global_location_list): Use should_be_inserted.
	(bkpt_re_set): Update.
gdb/testsuite
2011-12-06  Joel Brobecker  <brobecker@@acacore.com>

        * gdb.ada/fullname_bp.exp: Add tests for other valid linespecs
        involving a fully qualified function name.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.ada/homonym.exp: Add three breakpoint tests.

2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.base/solib-weak.exp (do_test): Remove kfail.
	* gdb.trace/tracecmd.exp: Disable pending breakpoints earlier.
	* gdb.objc/objcdecode.exp: Update for output changes.
	* gdb.linespec/linespec.exp: New file.
	* gdb.linespec/lspec.cc: New file.
	* gdb.linespec/lspec.h: New file.
	* gdb.linespec/body.h: New file.
	* gdb.linespec/base/two/thefile.cc: New file.
	* gdb.linespec/base/one/thefile.cc: New file.
	* gdb.linespec/Makefile.in: New file.
	* gdb.cp/templates.exp (test_template_breakpoints): Update for
	output changes.
	* gdb.cp/re-set-overloaded.exp: Remove kfail.
	* gdb.cp/ovldbreak.exp: Update for output changes.  "all" test now
	makes one breakpoint.
	* gdb.cp/method2.exp (test_break): Update for output changes.
	* gdb.cp/mb-templates.exp: Update for output changes.
	* gdb.cp/mb-inline.exp: Update for output changes.
	* gdb.cp/mb-ctor.exp: Update for output changes.
	* gdb.cp/ovsrch.exp: Use fully-qualified names.
	* gdb.base/solib-symbol.exp: Run to main later.  Breakpoint now
	has multiple matches.
	* gdb.base/sepdebug.exp: Disable pending breakpoints.  Update for
	error message change.
	* gdb.base/list.exp (test_list_filename_and_number): Update for
	error message change.
	* gdb.base/break.exp: Disable pending breakpoints.  Update for
	output changes.
	* configure.ac: Add gdb.linespec.
	* configure: Rebuild.
	* Makefile.in (ALL_SUBDIRS): Add gdb.linespec.
gdb/doc
2011-12-06  Tom Tromey  <tromey@@redhat.com>

	* gdb.texinfo (Set Breaks): Update for new behavior.
@
text
@d3 1
a3 2
   Copyright (C) 2003, 2005, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
@


1.138.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2005, 2007-2012 Free Software Foundation, Inc.
@


1.137
log
@gdb/
	Fix empty DWARF expressions DATA vs. SIZE conditionals.
	* dwarf2loc.c (dwarf2_find_location_expression): Clear *LOCEXPR_LENGTH.
	(dwarf_expr_frame_base_1): Indicate unavailability via zero *LENGTH.
	(locexpr_tracepoint_var_ref): Check only zero SIZE, not zero DATA.
	(loclist_read_variable, loclist_tracepoint_var_ref): Do not check for
	zero DATA.
	* dwarf2loc.h (struct dwarf2_locexpr_baton): Comment DATA vs. SIZE
	validity.
	* dwarf2read.c (struct dwarf_block): Comment DATA validity.
	(dwarf2_fetch_die_location_block, dwarf2_symbol_mark_computed): Do not
	clear DATA on zero SIZE.

gdb/testsuite/
	Fix empty DWARF expressions DATA vs. SIZE conditionals.
	* gdb.dwarf2/dw2-op-call.S (arraycallnoloc, arraynoloc): New DIEs.
	(loclist): New.
	(4): New abbrev.
	* gdb.dwarf2/dw2-op-call.exp: Remove variable srcfile and executable.
	Use prepare_for_testing, remove clean_restart.
	(p arraynoloc, p arraycallnoloc): New tests.
@
text
@a445 3
/* Define VEC (CORE_ADDR) functions.  */
DEF_VEC_I (CORE_ADDR);

@


1.136
log
@gdb/
	Fix compatibility with older GCCs.
	* dwarf2loc.c (dwarf_expr_reg_to_entry_parameter): Initialize parameter.
	* stack.c (read_frame_arg): Initialize val_deref.
@
text
@d115 4
a118 1
	return NULL;
d221 1
a221 1
    *start = NULL;
d240 1
a240 1
	*start = NULL;
d243 1
a243 1
  if (*start == NULL)
d3722 1
a3722 1
  if (dlbaton->data == NULL || dlbaton->size == 0)
d3756 2
a3757 5
  if (data == NULL)
    val = allocate_optimized_out_value (SYMBOL_TYPE (symbol));
  else
    val = dwarf2_evaluate_loc_desc (SYMBOL_TYPE (symbol), frame, data, size,
				    dlbaton->per_cu);
d3896 1
a3896 1
  if (data == NULL || size == 0)
@


1.135
log
@gdb/
	Entry values NEWS entries, DWARF disassembly support.
	* NEWS: New entry values entry.
	(set print entry-values, show print entry-values)
	(set debug entry-values, show debug entry-values): New entries.
	* dwarf2loc.c (disassemble_dwarf_expression): New parameters start and
	indent.  Remove variable start.  Move header printing out.  Respect
	INDENT.  Support DW_OP_GNU_entry_value.
	(locexpr_describe_location_1): Move the header printing here, extend
	the disassemble_dwarf_expression passed parameters.

gdb/testsuite/
	* gdb.arch/amd64-entry-value.s: New file.
	* gdb.mi/mi2-amd64-entry-value.s: New file.
@
text
@d836 2
a837 1
  struct call_site_parameter *parameter;
@


1.134
log
@gdb/
	Display @@entry parameter values even for references.
	* ada-valprint.c (ada_val_print_1) <TYPE_CODE_REF>: Try also
	coerce_ref_if_computed.
	* c-valprint.c (c_val_print) <TYPE_CODE_REF>: Likewise.
	* dwarf2expr.c (dwarf_block_to_dwarf_reg_deref): New function.
	(execute_stack_op) <DW_OP_GNU_entry_value>: Add -1 deref_size to the
	existing push_dwarf_reg_entry_value call.  Add new detection calling
	dwarf_block_to_dwarf_reg_deref.  Update the error message.
	(ctx_no_push_dwarf_reg_entry_value): New parameter deref_size.
	* dwarf2expr.h
	(struct dwarf_expr_context_funcs) <push_dwarf_reg_entry_value>: Add new
	parameter deref_size, describe it in the comment.
	(ctx_no_push_dwarf_reg_entry_value): Add new parameter deref_size.
	(dwarf_block_to_dwarf_reg_deref): New declaration.
	* dwarf2loc.c (dwarf_entry_parameter_to_value): Add new parameter
	deref_size, describe it in the function comment.  New variables
	data_src and size, fetch the alternative block accoring to DEREF_SIZE.
	(dwarf_expr_push_dwarf_reg_entry_value): Add new parameter deref_size,
	describe it in the function comment.  Fetch the alternative block
	accoring to DEREF_SIZE.
	(entry_data_value_coerce_ref, entry_data_value_copy_closure)
	(entry_data_value_free_closure, entry_data_value_funcs): New.
	(value_of_dwarf_reg_entry): New variables checked_type, target_type,
	outer_val, target_val, val and addr.  Try to fetch and create also
	referenced value content.
	(pieced_value_funcs): NULL value for coerce_ref.
	(needs_dwarf_reg_entry_value): Add new parameter deref_size.
	* f-valprint.c (f_val_print) <TYPE_CODE_REF>: Try also
	coerce_ref_if_computed.
	* opencl-lang.c (opencl_value_funcs): NULL value for coerce_ref.
	* p-valprint.c (pascal_val_print) <TYPE_CODE_REF>: Likewise.
	* stack.c (read_frame_arg): Compare also dereferenced values.
	* value.c (value_computed_funcs): Make the parameter v const, use
	value_lval_const for it.
	(value_lval_const, coerce_ref_if_computed): New function.
	(coerce_ref): New variable retval.  Call also coerce_ref_if_computed.
	* value.h (struct lval_funcs): New field coerce_ref.
	(value_computed_funcs): Make the parameter v const.
	(value_lval_const, coerce_ref_if_computed): New declarations.

gdb/testsuite/
	Display @@entry parameter values even for references.
	* gdb.arch/amd64-entry-value.cc (reference, datap, datap_input): New
	functions.
	(main): New variables regvar, nodatavarp, stackvar1, stackvar2.  Call
	reference and datap_input.
	* gdb.arch/amd64-entry-value.exp (reference, breakhere_reference): New
	breakpoints.
	(continue to breakpoint: entry_reference: reference)
	(entry_reference: bt at entry)
	(continue to breakpoint: entry_reference: breakhere_reference)
	(entry_reference: bt, entry_reference: ptype regparam)
	(entry_reference: p regparam, entry_reference: ptype regparam@@entry)
	(entry_reference: p regparam@@entry, entry_reference: p &regparam@@entry)
	(entry_reference: p regcopy, entry_reference: p nodataparam)
	(entry_reference: p nodataparam@@entry): New tests.
@
text
@d3261 1
a3261 1
			      int offset_size,
d3263 1
a3263 1
			      int all,
a3265 4
  const gdb_byte *start = data;

  fprintf_filtered (stream, _("a complex DWARF expression:\n"));

d3280 2
a3281 1
      fprintf_filtered (stream, "  % 4ld: %s", (long) (data - 1 - start), name);
d3579 9
d3632 9
a3640 5
	data = disassemble_dwarf_expression (stream,
					     get_objfile_arch (objfile),
					     addr_size, offset_size, data, end,
					     dwarf2_always_disassemble,
					     per_cu);
@


1.133
log
@gdb/
	Display @@entry parameter values (without references).
	* dwarf2expr.c (dwarf_block_to_fb_offset, dwarf_block_to_sp_offset):
	New functions.
	* dwarf2expr.h (dwarf_block_to_fb_offset, dwarf_block_to_sp_offset):
	New declarations.
	* dwarf2loc.c (dwarf2_find_location_expression): Support location list
	entry record.
	(dwarf_entry_parameter_to_value, value_of_dwarf_reg_entry)
	(value_of_dwarf_block_entry, locexpr_read_variable_at_entry): New
	functions.
	(dwarf2_locexpr_funcs): Install locexpr_read_variable_at_entry.
	(loclist_read_variable_at_entry): New function.
	(dwarf2_loclist_funcs): Install loclist_read_variable_at_entry.
	* dwarf2read.c (read_call_site_scope): Support also DW_OP_fbreg in
	DW_AT_location, call dwarf_block_to_sp_offset for it.
	* frame.h (print_entry_values_no, print_entry_values_only)
	(print_entry_values_preferred, print_entry_values_if_needed)
	(print_entry_values_both, print_entry_values_compact)
	(print_entry_values_default, print_entry_values): New declarations.
	(struct frame_arg): New field entry_kind.
	(read_frame_arg): New parameter entryargp.
	* mi/mi-cmd-stack.c (list_arg_or_local): New gdb_assert for
	arg->entry_kind.  Optionally print the `@@entry' suffix.
	(list_args_or_locals): New variable entryarg, initialize it.
	Initialize also entry_kind of arg and entryarg.  Conditionalize
	list_arg_or_local for arg, add list_arg_or_local for entryarg.  Call
	xfree for entryarg.error.
	* stack.c (print_entry_values_no, print_entry_values_only)
	(print_entry_values_preferred, print_entry_values_if_needed)
	(print_entry_values_both, print_entry_values_compact)
	(print_entry_values_default, print_entry_values_choices)
	(print_entry_values): New variables.
	(print_frame_arg): New gdb_assert for arg->entry_kind.  Optionally
	print the `@@entry' suffix, possibly in combination for
	print_entry_values_compact.
	(read_frame_arg): New parameter entryargp, new variables entryval,
	entryval_error and val_equal.  Read in also entryargp, respect
	print_entry_values, compare the values using val_equal, fill in also
	argp->entry_kind (together with entryargp->entry_kind).
	(print_frame_args): New variable entryarg, initialize it.
	Conditionalize print_frame_arg for arg, add print_frame_arg for
	entryarg.  Call xfree for entryarg.error.
	(_initialize_stack): Call add_setshow_enum_cmd for `entry-values'.
	* symtab.h (struct symbol_computed_ops): New field
	read_variable_at_entry.

gdb/doc/
	Display @@entry parameter values (without references).
	* gdb.texinfo (Tail Call Frames): Add anchor.  Add self tail call
	example.
	(Print Settings): New description of set print entry-values and show
	print entry-values.

gdb/testsuite/
	Display @@entry parameter values (without references).
	* gdb.arch/amd64-entry-value.cc (locexpr, stacktest, data, data2)
	(different, validity, invalid): New functions.
	(main): Call them.
	* gdb.arch/amd64-entry-value.exp: New breakpoints breakhere_locexpr,
	stacktest, breakhere_stacktest, different, breakhere_different,
	breakhere_validity and breakhere_invalid.
	(entry: bt): Update for @@entry.
	(entry_locexpr: *, entry_stack: *, entry_equal: *, entry_different: *)
	(entry_validity: *, entry_invalid: *): Many new tests.
	* gdb.base/break.exp
	(run until breakpoint set at small function, optimized file): Accept
	also the @@entry suffix.
	* gdb.mi/Makefile.in (PROGS): Add mi2-amd64-entry-value.
	* gdb.mi/mi2-amd64-entry-value.c: New files.
	* gdb.mi/mi2-amd64-entry-value.exp: New files.
@
text
@d913 3
a915 1
/* Return value for PARAMETER for DW_AT_GNU_call_site_value.
d925 1
a925 1
				struct type *type,
d929 1
d931 9
d944 3
a946 3
  data = alloca (parameter->value_size + 1);
  memcpy (data, parameter->value, parameter->value_size);
  data[parameter->value_size] = DW_OP_stack_value;
d948 1
a948 2
  return dwarf2_evaluate_loc_desc (type, caller_frame, data,
				   parameter->value_size + 1, per_cu);
d951 4
a954 3
/* Execute call_site_parameter's DWARF block for caller of the CTX's frame.
   CTX must be of dwarf_expr_ctx_funcs kind.  See DWARF_REG and FB_OFFSET
   description at struct dwarf_expr_context_funcs->push_dwarf_reg_entry_value.
d961 2
a962 1
				       int dwarf_reg, CORE_ADDR fb_offset)
d980 7
a986 2
  data_src = parameter->value;
  size = parameter->value_size;
d1008 56
d1076 2
d1079 1
d1082 1
d1087 36
a1122 2
  return dwarf_entry_parameter_to_value (parameter, type, caller_frame,
					 caller_per_cu);
d1914 1
d2234 1
a2234 1
			     int dwarf_reg, CORE_ADDR fb_offset)
@


1.132
log
@gdb/
	Protect entry values against self tail calls.
	* dwarf2loc.c (VEC (CORE_ADDR), func_verify_no_selftailcall): New.
	(dwarf_expr_dwarf_reg_entry_value): Call func_verify_no_selftailcall.

gdb/testsuite/
	Protect entry values against self tail calls.
	* gdb.arch/amd64-entry-value.cc (self2, self): New.
	(main): Call self.
	* gdb.arch/amd64-entry-value.exp (self: breakhere, self: bt)
	(set debug entry-values 1, self: bt debug entry-values): New tests.
@
text
@d124 18
d913 27
d990 52
d2953 13
d3607 1
d3638 26
d3783 1
@


1.131
log
@gdb/
	Recognize virtual tail call frames.
	* Makefile.in (SFILES): Add dwarf2-frame-tailcall.c.
	(HFILES_NO_SRCDIR): Add dwarf2-frame-tailcall.h.
	(COMMON_OBS): Add dwarf2-frame-tailcall.o.
	* dwarf2-frame-tailcall.c: New file.
	* dwarf2-frame-tailcall.h: New file.
	* dwarf2-frame.c: Include dwarf2-frame-tailcall.h.
	(execute_cfa_program): New function comment.  Return INSN_PTR.  Reset
	REGS.PREV only after CIE execution.
	(struct dwarf2_frame_cache): New field tailcall_cache.
	(dwarf2_frame_cache): New variables entry_pc, entry_cfa_sp_offset,
	entry_cfa_sp_offset_p and instr.  Execute FDE instructions in two
	parts, try to find entry_cfa_sp_offset.  Call
	dwarf2_tailcall_sniffer_first.
	(dwarf2_frame_prev_register): Call dwarf2_tailcall_prev_register_first
	when appropriate.
	(dwarf2_frame_dealloc_cache): New function.
	(dwarf2_frame_sniffer): Preinitialize cache by dwarf2_frame_cache.
	(dwarf2_frame_unwind): Install dwarf2_frame_dealloc_cache.
	(dwarf2_signal_frame_unwind): Do not install dwarf2_frame_dealloc_cache.
	(dwarf2_append_unwinders): Add dwarf2_tailcall_frame_unwind.
	(dwarf2_frame_cfa): Support also dwarf2_tailcall_frame_unwind.
	* dwarf2loc.c (func_addr_to_tail_call_list)
	(tailcall_dump, call_sitep, VEC (call_sitep), chain_candidate)
	(call_site_find_chain_1, call_site_find_chain): New.
	* dwarf2loc.h (struct call_site_chain): New.
	(call_site_find_chain): New declaration.
	* frame.c (get_frame_address_in_block): Support also TAILCALL_FRAME.
	* frame.h (enum frame_type): New entry TAILCALL_FRAME.
	* python/py-frame.c (gdbpy_initialize_frames): Add TAILCALL_FRAME.
	* stack.c (frame_info): Support also TAILCALL_FRAME.

gdb/doc/
	Recognize virtual tail call frames.
	* gdb.texinfo (Optimized Code): Add reference to Tail Call Frames.
	(Tail Call Frames): New node.
	(Frames In Python): Add gdb.TAILCALL_FRAME.

gdb/testsuite/
	Recognize virtual tail call frames.
	* gdb.arch/amd64-entry-value.cc (c, a, b, amb_z, amb_y, amb_x, amb)
	(amb_b, amb_a): New.
	(main): Call a and b.
	* gdb.arch/amd64-entry-value.exp (tailcall: breakhere, tailcall: bt)
	(tailcall: p i, tailcall: p j, set $sp0=$sp, up, p $sp0 == $sp, frame 3)
	(p $sp0 + sizeof (void *) == $sp, ambiguous: breakhere, ambiguous: bt):
	New tests.
@
text
@d425 81
d864 4
@


1.130
log
@gdb/
	Implement basic support for DW_TAG_GNU_call_site.
	* block.c: Include gdbtypes.h and exceptions.h.
	(call_site_for_pc): New function.
	* block.h (call_site_for_pc): New declaration.
	* defs.h: Include hashtab.h.
	(make_cleanup_htab_delete, core_addr_hash, core_addr_eq): New
	declarations.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): Install
	ctx_no_push_dwarf_reg_entry_value.
	* dwarf2expr.c (read_uleb128, read_sleb128): Support R as NULL.
	(dwarf_block_to_dwarf_reg): New function.
	(execute_stack_op) <DW_OP_GNU_entry_value>: Implement it.
	(ctx_no_push_dwarf_reg_entry_value): New function.
	* dwarf2expr.h (struct dwarf_expr_context_funcs): New field
	push_dwarf_reg_entry_value.
	(ctx_no_push_dwarf_reg_entry_value, dwarf_block_to_dwarf_reg): New
	declarations.
	* dwarf2loc.c: Include gdbcmd.h.
	(dwarf_expr_ctx_funcs): New forward declaration.
	(entry_values_debug, show_entry_values_debug, call_site_to_target_addr)
	(dwarf_expr_reg_to_entry_parameter)
	(dwarf_expr_push_dwarf_reg_entry_value): New.
	(dwarf_expr_ctx_funcs): Install dwarf_expr_push_dwarf_reg_entry_value.
	(dwarf2_evaluate_loc_desc_full): Handle NO_ENTRY_VALUE_ERROR.
	(needs_dwarf_reg_entry_value): New function.
	(needs_frame_ctx_funcs): Install it.
	(_initialize_dwarf2loc): New function.
	* dwarf2loc.h (entry_values_debug): New declaration.
	* dwarf2read.c (struct dwarf2_cu): New field call_site_htab.
	(read_call_site_scope): New forward declaration.
	(process_full_comp_unit): Copy call_site_htab.
	(process_die): Support DW_TAG_GNU_call_site.
	(read_call_site_scope): New function.
	(dwarf2_get_pc_bounds): Support NULL HIGHPC.
	(dwarf_tag_name): Support DW_TAG_GNU_call_site.
	(cleanup_htab): Delete.
	(write_psymtabs_to_index): Use make_cleanup_htab_delete instead of it.
	* exceptions.h (enum errors): New NO_ENTRY_VALUE_ERROR.
	* gdb-gdb.py (StructMainTypePrettyPrinter): Support
	FIELD_LOC_KIND_DWARF_BLOCK.
	* gdbtypes.h (enum field_loc_kind): New entry
	FIELD_LOC_KIND_DWARF_BLOCK.
	(struct main_type): New loc entry dwarf_block.
	(struct call_site, FIELD_DWARF_BLOCK, SET_FIELD_DWARF_BLOCK)
	(TYPE_FIELD_DWARF_BLOCK): New.
	* python/py-type.c: Include dwarf2loc.h.
	(check_types_equal): Support FIELD_LOC_KIND_DWARF_BLOCK.  New
	internal_error call on unknown FIELD_LOC_KIND.
	* symtab.h (struct symtab): New field call_site_htab.
	* utils.c (do_htab_delete_cleanup, make_cleanup_htab_delete)
	(core_addr_hash, core_addr_eq): New functions.

gdb/testsuite/
	Implement basic support for DW_TAG_GNU_call_site.
	* gdb.arch/Makefile.in (EXECUTABLES): Add amd64-entry-value.
	* gdb.arch/amd64-entry-value.cc: New file.
	* gdb.arch/amd64-entry-value.exp: New file.
@
text
@d402 315
@


1.129
log
@gdb/
	Fix DW_OP_GNU_implicit_pointer for DWARF32 v3+ on 64-bit arches.
	* dwarf2-frame.c (execute_stack_op): Initialize ctx->ref_addr_size.
	* dwarf2expr.c (execute_stack_op) <DW_OP_GNU_implicit_pointer>: Use
	ctx->ref_addr_size.  Handle its invalid value.
	* dwarf2expr.h (struct dwarf_expr_context): New field ref_addr_size.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full)
	(dwarf2_loc_desc_needs_frame): Initialize ctx->ref_addr_size.
	* dwarf2loc.h (dwarf2_per_cu_ref_addr_size): New declaration.
	* dwarf2read.c (decode_locdesc): Initialize ctx->ref_addr_size.
	(dwarf2_per_cu_ref_addr_size): New function.

gdb/testsuite/
	Fix DW_OP_GNU_implicit_pointer for DWARF32 v3+ on 64-bit arches.
	* gdb.dwarf2/implptr-64bit.S: New file.
	* gdb.dwarf2/implptr-64bit.exp: New file.
@
text
@d36 1
d51 2
d302 243
d1331 2
a1332 1
  dwarf_expr_get_base_type
d1386 7
d1620 11
d1642 2
a1643 1
  NULL				/* get_base_type */
d3250 17
@


1.128
log
@gdb/
	Remove excessive DWARF expressions memory duplication.
	* dwarf2loc.c (per_cu_dwarf_call): Remove variable back_to and its use
	for block.data.
	(indirect_pieced_value): Remove variable result.  Remove variable
	back_to and its use for baton.data.
	(dwarf2_compile_expr_to_ax): Remove variable back_to and its use for
	block.data.
	* dwarf2read.c (dwarf2_fetch_die_location_block): Remove xmemdup.
	Update the function comment.
@
text
@d1121 1
d1402 1
@


1.127
log
@gdb/
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full) <DWARF_VALUE_STACK>
	(dwarf2_evaluate_loc_desc_full) <DWARF_VALUE_LITERAL>: New variable
	objfile_gdbarch.  Fix BFD_ENDIAN_BIG case.

gdb/testsuite/
	* gdb.dwarf2/dw2-op-stack-value.S: New file.
	* gdb.dwarf2/dw2-op-stack-value.exp: New file.
@
text
@a267 1
  struct cleanup *back_to;
a271 2
  back_to = make_cleanup (xfree, (void *) block.data);

a275 2

  do_cleanups (back_to);
a966 1
  struct value *result;
a967 1
  struct cleanup *back_to;
d1017 3
a1019 9
  back_to = make_cleanup (xfree, (void *) baton.data);

  result = dwarf2_evaluate_loc_desc_full (TYPE_TARGET_TYPE (type), frame,
					  baton.data, baton.size, baton.per_cu,
					  piece->v.ptr.offset + byte_offset);

  do_cleanups (back_to);

  return result;
a2136 1
	    struct cleanup *back_to;
a2142 1
	    back_to = make_cleanup (xfree, (void *) block.data);
a2149 2

	    do_cleanups (back_to);
@


1.126
log
@gdb/
	Fix implicit pointer offsets.
	* dwarf2loc.c (indirect_pieced_value): Comment byte_offset.  Use also
	ptr.OFFSET.

gdb/testsuite/
	Fix implicit pointer offsets.
	* gdb.dwarf2/implptr.c (add): New marker baz breakpoint.
	* gdb.dwarf2/implptr.exp (set baz breakpoint for implptr)
	(continue to breakpoint: continue to baz breakpoint for implptr)
	(sanity check element 0, sanity check element 1)
	(enter the inlined function, check element 0 for the offset)
	(check element 1 for the offset)
	(continue to breakpoint: ignore the second baz breakpoint): New tests.
	(set foo breakpoint for implptr): Update the breakpoint number.
@
text
@d1235 7
a1241 1
	      n = TYPE_LENGTH (type);
d1263 7
a1269 1
	      n = TYPE_LENGTH (type);
@


1.125
log
@gdb/
	Fix crash if referenced CU is aged out.
	* dwarf2loc.c (per_cu_dwarf_call): New variable back_to, use to for
	xfree of block.data.
	(indirect_pieced_value): New variable back_to, use to for xfree of
	baton.data.
	(dwarf2_compile_expr_to_ax): New variable back_to, use to for xfree of
	block.data.
	* dwarf2read.c (dwarf2_find_base_address): New prototype.
	(load_cu): New function from ...
	(dw2_do_instantiate_symtab): ... the code here ...
	(process_full_comp_unit): ... and here.
	(dwarf2_fetch_die_location_block): Call load_cu first.  Call xmemdup on
	retval.data.

gdb/testsuite/
	Fix crash if referenced CU is aged out.
	* gdb.dwarf2/dw2-op-call.exp (maintenance set dwarf2 max-cache-age 0):
	New.
	* gdb.dwarf2/implptr.exp: Likewise.
@
text
@d1015 2
d1028 1
a1028 1
					  byte_offset);
@


1.124
log
@gdb/
	* dwarf2loc.c (indirect_pieced_value): Use check_typedef for VALUE's
	type.

gdb/testsuite/
	* gdb.dwarf2/implptr.S: Rebuilt.
	* gdb.dwarf2/implptr.c (intp, intpp, intppp): New typedefs.
	(bar): Use them for j, k, l.
	* gdb.dwarf2/implptr.exp: New variable opts.  Support runtest parameter
	COMPILE.
	(print j in implptr:bar): Update for the intp typedef.
	(print p[0].x in implptr:foo): Use more exact regex.
@
text
@d268 1
d273 2
d279 2
d974 1
d1022 2
d1028 2
d2136 1
d2143 1
d2151 2
@


1.123
log
@gdb/
	Code cleanup.
	* dwarf2-frame.c (dwarf2_frame_ctx_funcs): New.
	(execute_stack_op): Use dwarf2_frame_ctx_funcs
	* dwarf2expr.c (dwarf_get_base_type): Access get_base_type via funcs.
	(execute_stack_op): Access read_reg, get_frame_base, read_mem,
	get_frame_cfa, get_tls_address and dwarf_call via funcs.
	* dwarf2expr.h (struct dwarf_expr_context): New forward declaration.
	(struct dwarf_expr_context_funcs): New, move here methods from ...
	(struct dwarf_expr_context): ... here.  New fields funcs.
	* dwarf2loc.c (dwarf_expr_dwarf_call): Access get_frame_pc via funcs.
	(dwarf_expr_ctx_funcs): New.
	(dwarf2_evaluate_loc_desc_full): Use dwarf_expr_ctx_funcs.
	(needs_frame_dwarf_call): Access get_frame_pc via funcs.
	(needs_frame_ctx_funcs): New.
	(dwarf2_loc_desc_needs_frame): Use needs_frame_ctx_funcs.
@
text
@d970 1
a970 1
  type = value_type (value);
@


1.122
log
@gdb/
	Code cleanup - constify struct lval_funcs.
	* dwarf2loc.c (pieced_value_funcs): Make it const.
	* infrun.c (siginfo_value_funcs): Likewise.
	* opencl-lang.c (opencl_value_funcs): Likewise.
	* valops.c (value_assign, value_ind): Make the funcs variable const.
	* value.c (struct value): Make location.computed.funcs target const.
	Rearrange the comments.
	(allocate_computed_value): Make the funcs parameter target const.
	(value_computed_funcs): Return the funcs target const.
	(value_free, value_copy, set_value_component_location): Make the funcs
	variable const.
	* value.h (allocate_computed_value): Make the funcs parameter target
	const.
	(value_computed_funcs): Return the funcs target const.
	* windows-tdep.c (tlb_value_funcs): Make it const.
@
text
@d286 1
a286 1
		     ctx->get_frame_pc, ctx->baton);
d1075 14
d1124 1
a1124 8
  ctx->read_reg = dwarf_expr_read_reg;
  ctx->read_mem = dwarf_expr_read_mem;
  ctx->get_frame_base = dwarf_expr_frame_base;
  ctx->get_frame_cfa = dwarf_expr_frame_cfa;
  ctx->get_frame_pc = dwarf_expr_frame_pc;
  ctx->get_tls_address = dwarf_expr_tls_address;
  ctx->dwarf_call = dwarf_expr_dwarf_call;
  ctx->get_base_type = dwarf_expr_get_base_type;
d1351 1
a1351 1
		     ctx->get_frame_pc, ctx->baton);
d1354 14
d1392 1
a1392 7
  ctx->read_reg = needs_frame_read_reg;
  ctx->read_mem = needs_frame_read_mem;
  ctx->get_frame_base = needs_frame_frame_base;
  ctx->get_frame_cfa = needs_frame_frame_cfa;
  ctx->get_frame_pc = needs_frame_frame_cfa;
  ctx->get_tls_address = needs_frame_tls_address;
  ctx->dwarf_call = needs_frame_dwarf_call;
@


1.121
log
@gdb/
	Code cleanup.
	* dwarf2loc.c (dwarf_expr_frame_base_1, dwarf2_evaluate_loc_desc_full):
	Indent prototypes so they do not get into tags.
@
text
@d1054 1
a1054 1
static struct lval_funcs pieced_value_funcs = {
@


1.120
log
@gdb/
	Code cleanup making also optimized out values lazy.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use
	allocate_optimized_out_value.  Twice.
	(loclist_read_variable)  Use allocate_optimized_out_value.  Once.
	* findvar.c (read_var_value): Likewise.
	* value.c (allocate_optimized_out_value): New function.
	* value.h (allocate_optimized_out_value): New declaration.
@
text
@d47 2
a48 3
static void
dwarf_expr_frame_base_1 (struct symbol *framefunc, CORE_ADDR pc,
			 const gdb_byte **start, size_t *length);
d50 6
a55 5
static struct value *
dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,
			       const gdb_byte *data, unsigned short size,
			       struct dwarf2_per_cu_data *per_cu,
			       LONGEST byte_offset);
@


1.119
log
@	* dwarf2loc.c (locexpr_regname): New function.
	(locexpr_describe_location_piece): Use it.
	(disassemble_dwarf_expression): Add per_cu argument.  Use
	locexpr_regname.
	<DW_OP_GNU_deref_type, DW_OP_GNU_const_type,
	DW_OP_GNU_regval_type, DW_OP_GNU_convert, DW_OP_GNU_reinterpret>:
	New cases.
	(locexpr_describe_location_1): Add per_cu argument.
	(locexpr_describe_location): Update.
	(loclist_describe_location): Update.
@
text
@d1097 1
a1097 6
    {
      retval = allocate_value (type);
      VALUE_LVAL (retval) = not_lval;
      set_value_optimized_out (retval, 1);
      return retval;
    }
d1245 1
a1245 3
	  retval = allocate_value (type);
	  VALUE_LVAL (retval) = not_lval;
	  set_value_optimized_out (retval, 1);
d2825 1
a2825 5
    {
      val = allocate_value (SYMBOL_TYPE (symbol));
      VALUE_LVAL (val) = not_lval;
      set_value_optimized_out (val, 1);
    }
@


1.118
log
@	* dwarf2loc.c (disassemble_dwarf_expression): Fix instruction
	offset display.
@
text
@d2188 12
a2211 1
  int regno;
a2214 1
      regno = gdbarch_dwarf2_reg_to_regnum (gdbarch, data[0] - DW_OP_reg0);
d2216 1
a2216 1
			gdbarch_register_name (gdbarch, regno));
a2223 1
      regno = gdbarch_dwarf2_reg_to_regnum (gdbarch, reg);
d2225 1
a2225 1
			gdbarch_register_name (gdbarch, regno));
a2280 2
      regno = gdbarch_dwarf2_reg_to_regnum (gdbarch, frame_reg);

d2283 1
a2283 1
			gdbarch_register_name (gdbarch, regno),
a2290 2
      regno = gdbarch_dwarf2_reg_to_regnum (gdbarch, data[0] - DW_OP_breg0);

d2296 1
a2296 1
			gdbarch_register_name (gdbarch, regno));
d2353 2
a2354 1
			      int all)
d2467 1
a2467 1
			    gdbarch_register_name (arch, op - DW_OP_reg0));
d2473 1
a2473 1
			    gdbarch_register_name (arch, (int) ul));
d2516 1
a2516 1
			    gdbarch_register_name (arch, op - DW_OP_breg0));
d2524 1
a2524 1
			    gdbarch_register_name (arch, (int) ul),
d2607 65
d2688 1
a2688 1
			     int offset_size)
d2719 2
a2720 1
					     dwarf2_always_disassemble);
d2784 2
a2785 1
			       objfile, addr_size, offset_size);
d2931 2
a2932 1
				   objfile, addr_size, offset_size);
@


1.117
log
@	* utils.c (do_value_free): New function.
	(make_cleanup_value_free): Likewise.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Handle value
	freeing correctly.
	(dwarf2_loc_desc_needs_frame): Call
	make_cleanup_value_free_to_mark.
	* dwarf2expr.h (struct dwarf_expr_context) <mark>: Remove field.
	* dwarf2expr.c (free_dwarf_expr_context): Don't call
	value_free_to_mark.
	(new_dwarf_expr_context): Don't call value_mark.
	* dwarf2-frame.c (execute_stack_op): Call
	make_cleanup_value_free_to_mark.
	* defs.h (make_cleanup_value_free): Declare.
@
text
@d2367 2
a2368 2
	       op, (long) (data - start));
      fprintf_filtered (stream, "  % 4ld: %s", (long) (data - start), name);
@


1.116
log
@gdb
	PR gdb/12617:
	* value.h (value_from_contents): Declare.
	* value.c (value_from_contents): New function.
	* dwarf2read.c (dwarf_stack_op_name): Add new values.
	(dwarf2_get_die_type): New function.
	* dwarf2loc.c (dwarf_expr_get_base_type): New function.
	(allocate_piece_closure): Acquire reference to values.
	(read_pieced_value): Update for value-based expressions.
	(write_pieced_value): Likewise.
	(free_pieced_value_closure): Call value_free as needed.
	(dwarf2_evaluate_loc_desc_full): Set get_base_type field.
	Update for value-based expressions.
	* dwarf2loc.h (dwarf2_get_die_type): Declare.
	* dwarf2expr.h (struct dwarf_stack_value) <value>: Change type.
	<get_base_type>: New field.
	(struct dwarf_expr_piece) <v.value>: Change type.
	<v.regno>: New field.
	(struct dwarf_expr_context) <mark>: New field.
	(dwarf_expr_piece, dwarf_expr_fetch): Update.
	(dwarf_expr_pop, dwarf_expr_push): Remove.
	(dwarf_expr_push_address): Declare.
	* dwarf2expr.c (dwarf_arch_cookie): New global.
	(struct dwarf_gdbarch_types): New.
	(dwarf_gdbarch_types_init, dwarf_expr_address_type): New
	functions.
	(dwarf_expr_push): Change type of 'value' argument.  Update.  Now
	static.
	(dwarf_expr_push_address): New function.
	(dwarf_expr_pop): Now static.
	(dwarf_expr_fetch): Change return type.
	(dwarf_require_integral): New function.
	(dwarf_expr_fetch): Simplify.
	(add_piece): Update.
	(base_types_equal_p, dwarf_get_base_type, get_unsigned_type): New
	functions.
	(execute_stack_op) <sign_ext>: Remove.
	Use values for DWARF stack.
	<DW_OP_GNU_const_type, DW_OP_GNU_deref_type,
	DW_OP_GNU_regval_type, DW_OP_GNU_convert, DW_OP_GNU_reinterpret>:
	New cases.
	(_initialize_dwarf2expr): New function.
	(add_piece): Update.
	(new_dwarf_expr_context): Set new field.
	(free_dwarf_expr_context): Call value_free_to_mark.
	* dwarf2-frame.c (no_base_type): New function.
	(execute_stack_op): Set get_base_type field.  Update.
gdb/testsuite
	* gdb.dwarf2/typeddwarf.S: New file.
	* gdb.dwarf2/typeddwarf.c: New file.
	* gdb.dwarf2/typeddwarf.exp: New file.
@
text
@d1089 1
a1089 1
  struct cleanup *old_chain;
d1109 1
d1132 1
d1155 3
d1174 1
d1188 1
d1211 7
d1235 1
d1249 1
d1372 1
@


1.115
log
@gdb/
	* dwarf2expr.c (execute_stack_op): Handle DW_OP_GNU_entry_value.  New
	label abort_expression.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Handle
	DWARF_VALUE_OPTIMIZED_OUT.

gdb/testsuite/
	* gdb.dwarf2/dw2-entry-value-main.c: New file.
	* gdb.dwarf2/dw2-entry-value.S: New file.
	* gdb.dwarf2/dw2-entry-value.exp: New file.
@
text
@d289 10
d326 1
d335 3
d593 1
a593 1
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->v.value);
d626 1
a626 1
		       paddress (arch, p->v.value));
a639 1
	    struct gdbarch *gdbarch = get_type_arch (value_type (v));
a649 4
	    else if (source_offset == 0)
	      store_unsigned_integer (buffer, n,
				      gdbarch_byte_order (gdbarch),
				      p->v.value);
d652 1
a652 1
		gdb_byte bytes[sizeof (ULONGEST)];
d654 1
a654 4
		store_unsigned_integer (bytes, n + source_offset,
					gdbarch_byte_order (gdbarch),
					p->v.value);
		memcpy (buffer, bytes + source_offset, n);
d785 1
a785 1
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->v.value);
d825 1
a825 1
		       paddress (arch, p->v.value));
d1042 6
d1121 1
d1164 1
a1164 1
	    ULONGEST dwarf_regnum = dwarf_expr_fetch (ctx, 0);
d1192 4
a1195 3
	    ULONGEST value = dwarf_expr_fetch (ctx, 0);
	    bfd_byte *contents, *tem;
	    size_t n = ctx->addr_size;
d1200 2
a1201 6
	    tem = alloca (n);
	    store_unsigned_integer (tem, n,
				    gdbarch_byte_order (ctx->gdbarch),
				    value);

	    tem += byte_offset;
d1208 1
a1208 1
	    memcpy (contents, tem, n);
@


1.114
log
@	gdb/
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Catch
	NOT_AVAILABLE_ERROR when evaluating the location expression.
@
text
@d1223 6
a1233 1
	case DWARF_VALUE_OPTIMIZED_OUT:
@


1.113
log
@	gdb/
	* dwarf2loc.c (read_pieced_value): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	(write_pieced_value): Handle get_frame_register_bytes returning
	that the register piece is unavailable/optimized out when doing a
	read-modify write of a bitfield.
	* findvar.c (value_from_register): Handle get_frame_register_bytes
	returning that the register piece is unavailable/optimized out.
	* frame.c (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.  Throw error on bad debug info.  Use
	frame_register instead of frame_register_read, to fill in the new
	arguments.
	* frame.h (get_frame_register_bytes): New parameters `optimizedp'
	and `unavailablep'.
	* valops.c: (value_assign): Adjust, and handle
	get_frame_register_bytes failing.
	* spu-tdep.c: Include exceptions.h.
	(spu_software_single_step): Adjust, and handle
	get_frame_register_bytes failing.
	(spu_get_longjmp_target): Ditto.
	* gdbarch.sh (register_to_value): Change to return int.  New
	parameters `optimizedp' and `unavailablep'.
	* gdbarch.h, gdbarch.c: Regenerate.
	* i386-tdep.c (i386_register_to_value): Adjust to new
	gdbarch_register_to_value interface.
	* i387-tdep.c (i387_register_to_value): Ditto.
	* i387-tdep.h (i387_register_to_value): Ditto.
	* alpha-tdep.c (alpha_register_to_value): Ditto.
	* ia64-tdep.c (ia64_register_to_value): Ditto.
	* m68k-tdep.c (m68k_register_to_value): Ditto.
	* mips-tdep.c (mips_register_to_value): Ditto.
	* rs6000-tdep.c (rs6000_register_to_value): Ditto.
@
text
@d1079 1
d1110 16
a1125 1
  dwarf_expr_eval (ctx, data, size);
@


1.112
log
@	PR gdb/12576:
	* dwarf2loc.c (dwarf_expr_dwarf_call): Remove 'return'.
	(needs_frame_dwarf_call): Likewise.
@
text
@d594 14
a607 2
		get_frame_register_bytes (frame, gdb_regnum, reg_offset, 
					  this_size, buffer);
d791 16
a806 2
		    get_frame_register_bytes (frame, gdb_regnum, reg_offset,
					      this_size, buffer);
@


1.111
log
@2011-03-04  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2loc.c (indirect_pieced_value): Assert 'piece' not null.
@
text
@d285 2
a286 2
  return per_cu_dwarf_call (ctx, die_offset, debaton->per_cu,
			    ctx->get_frame_pc, ctx->baton);
d1277 2
a1278 2
  return per_cu_dwarf_call (ctx, die_offset, nf_baton->per_cu,
			    ctx->get_frame_pc, ctx->baton);
@


1.110
log
@2011-02-26  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2loc.c (insert_bits): Avoid shadowing a function param
	with a local variable of the same name.
@
text
@d979 1
@


1.109
log
@gdb/
	* dwarf2loc.c (disassemble_dwarf_expression) <DW_OP_breg[0-9]+>: Use
	L and plongest.
	(disassemble_dwarf_expression) <DW_OP_bregx>: Drop variable offset,
	use L and plongest.
	(disassemble_dwarf_expression) <DW_OP_fbreg>: Use L and plongest.
@
text
@d425 1
a425 1
  gdb_assert (dest_offset_bits >= 0 && dest_offset_bits + nbits <= 8);
d1162 1
a1162 1
	    const bfd_byte *data;
d1171 1
a1171 1
	    data = ctx->data + byte_offset;
d1176 1
a1176 1
	    memcpy (contents, data, n);
@


1.108
log
@gdb
	* ax-general.c (aop_map): Add pick and rot.
	* dwarf2loc.c (compile_dwarf_to_ax) <DW_OP_over>: Reimplement.
	<DW_OP_rot>: Implement.
	* ax.h (enum agent_op) <aop_pick, aop_rot>: New constants.
	(ax_pick): Declare.
	* ax-general.c (ax_pick): New function.
doc
	* agentexpr.texi (Bytecode Descriptions): Document pick and rot.
gdbserver
	* tracepoint.c (enum gdb_agent_op) <gdb_agent_op_pick,
	gdb_agent_op_rot>: New constants.
	(gdb_agent_op_names): Add pick and roll.
	(eval_agent_expr) <gdb_agent_op_pick, gdb_agent_op_rot>: New
	cases.
@
text
@d2433 2
a2434 2
	  data = read_sleb128 (data, end, &ul);
	  fprintf_filtered (stream, " %s [$%s]", pulongest (ul),
d2439 6
a2444 10
	  {
	    ULONGEST offset;

	    data = read_uleb128 (data, end, &ul);
	    data = read_sleb128 (data, end, &offset);
	    fprintf_filtered (stream, " register %s [$%s] offset %s",
			      pulongest (ul),
			      gdbarch_register_name (arch, (int) ul),
			      pulongest (offset));
	  }
d2448 2
a2449 2
	  data = read_sleb128 (data, end, &ul);
	  fprintf_filtered (stream, " %s", pulongest (ul));
@


1.107
log
@	* dwarf2loc.h (dwarf2_compile_expr_to_ax): Declare.
	* dwarf2loc.c (dwarf2_compile_expr_to_ax): Rename from
	compile_dwarf_to_ax.  No longer static.  Call
	dwarf2_compile_cfa_to_ax.
	(locexpr_tracepoint_var_ref): Update.
	(loclist_tracepoint_var_ref): Update.
	* dwarf2-frame.h (dwarf2_compile_cfa_to_ax): Declare.
	* dwarf2-frame.c (execute_cfa_program): Remove 'this_frame'
	argument; add 'gdbarch' and 'pc'.
	(dwarf2_compile_cfa_to_ax): New function.
	(dwarf2_frame_cache): Update.
@
text
@d1743 1
a1743 1
	  unimplemented (op);
d1751 1
a1751 21
	  /* We can't directly support DW_OP_over, but GCC emits it as
	     part of a sequence to implement signed modulus.  As a
	     hack, we recognize this sequence.  Note that if GCC ever
	     generates a branch to the middle of this sequence, then
	     we will die somehow.  */
	  if (op_end - op_ptr >= 4
	      && op_ptr[0] == DW_OP_over
	      && op_ptr[1] == DW_OP_div
	      && op_ptr[2] == DW_OP_mul
	      && op_ptr[3] == DW_OP_minus)
	    {
	      /* Sign extend the operands.  */
	      ax_ext (expr, addr_size_bits);
	      ax_simple (expr, aop_swap);
	      ax_ext (expr, addr_size_bits);
	      ax_simple (expr, aop_swap);
	      ax_simple (expr, aop_rem_signed);
	      op_ptr += 4;
	    }
	  else
	    unimplemented (op);
d1755 1
a1755 1
	  unimplemented (op);
@


1.106
log
@	* dwarf2loc.c (unimplemented): Fix typo.
@
text
@d1429 5
a1433 5
static void
compile_dwarf_to_ax (struct agent_expr *expr, struct axs_value *loc,
		     struct gdbarch *arch, unsigned int addr_size,
		     const gdb_byte *op_ptr, const gdb_byte *op_end,
		     struct dwarf2_per_cu_data *per_cu)
d1720 2
a1721 2
	    compile_dwarf_to_ax (expr, loc, arch, addr_size, datastart,
				 datastart + datalen, per_cu);
d1958 2
a1959 1
	  unimplemented (op);
d2073 3
a2075 3
	    compile_dwarf_to_ax (expr, loc, arch, addr_size,
				 block.data, block.data + block.size,
				 per_cu);
d2677 3
a2679 3
    compile_dwarf_to_ax (ax, value, gdbarch, addr_size,
			 dlbaton->data, dlbaton->data + dlbaton->size,
			 dlbaton->per_cu);
d2830 2
a2831 2
    compile_dwarf_to_ax (ax, value, gdbarch, addr_size, data, data + size,
			 dlbaton->per_cu);
@


1.105
log
@	* dwarf2loc.c (unimplemented): Handle unnamed opcodes.
	(compile_dwarf_to_ax) <default>: Use unimplemented.
	<DW_OP_deref>: Update.
	(disassemble_dwarf_expression): Update.
	* dwarf2read.c (dwarf_stack_op_name): Remove 'def' argument.
	(decode_locdesc): Update.
	* dwarf2expr.h (dwarf_stack_op_name): Update.
@
text
@d1343 2
a1344 1
    error (_("Unknown DWARF operator 0x%02x cannot be to an agent expression"),
@


1.104
log
@	Mark pieces of values as unavailable if the corresponding memory
	is unavailable.

	gdb/
	* valops.c: Include tracepoint.h.
	(value_fetch_lazy): Use read_value_memory.
	(read_value_memory): New.
	* value.h (read_value_memory): Declare.
	* dwarf2loc.c (read_pieced_value): Use read_value_memory.
	* exec.c (section_table_available_memory): New function.
	* exec.h (section_table_available_memory): Declare.
@
text
@d1337 8
a1344 2
  error (_("DWARF operator %s cannot be translated to an agent expression"),
	 dwarf_stack_op_name (op, 1));
d1802 2
d1805 1
a1805 1
		       size, dwarf_stack_op_name (op, 1));
d2081 1
a2081 1
	  error (_("Unhandled dwarf expression opcode 0x%x"), op);
d2306 1
a2306 1
      name = dwarf_stack_op_name (op, 0);
@


1.103
log
@gdb/
	Make value allocations more lazy.
	* ada-lang.c (coerce_unspec_val_to_type): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc_full): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy.
	* findvar.c (value_of_register_lazy): Likewise.
	(read_var_value): Remove V preallocation, call just check_typedef in
	advance.  Move allocate_value to LOC_CONST, LOC_LABEL,
	LOC_CONST_BYTES.  Use allocate_value_lazy in LOC_STATIC, LOC_ARG,
	LOC_REF_ARG, LOC_LOCAL, LOC_BLOCK.  Set ADDR instead of
	set_value_address and break in LOC_BLOCK.  Use allocate_value_lazy and
	remove lval_memory set in LOC_REGPARM_ADDR.  Use allocate_value_lazy
	in LOC_UNRESOLVED and LOC_OPTIMIZED_OUT.  Add setting lval_memory at
	the end, remove set_value_lazy there.
	* valarith.c (value_subscripted_rvalue): Use allocate_value_lazy
	instead of allocate_value and set_value_lazy when possible.
	* valops.c (value_fetch_lazy): Do nop for value_optimized_out VAL.
	* value.c (allocate_computed_value): Use allocate_value_lazy instead
	of allocate_value and set_value_lazy.
	(value_from_contents_and_address): Use allocate_value_lazy instead of
	allocate_value and set_value_lazy when possible.
@
text
@d606 4
a609 4
	  if (p->v.mem.in_stack_memory)
	    read_stack (p->v.mem.addr + source_offset, buffer, this_size);
	  else
	    read_memory (p->v.mem.addr + source_offset, buffer, this_size);
@


1.102
log
@2011-01-07  Michael Snyder  <msnyder@@vmware.com>

	* ada-lang.c: Comment cleanup, mostly periods and spaces.
	* ada-lang.h: Ditto.
	* ada-tasks.c: Ditto.
	* ada-valprint.c: Ditto.
	* aix-threads.c: Ditto.
	* alpha-linux-nat.c: Ditto.
	* alpha-linux-tdep.c: Ditto.
	* alpha-mdebug-tdep.c: Ditto.
	* alpha-nat.c: Ditto.
	* alpha-osf1-tdep.c: Ditto.
	* alpha-tdep.c: Ditto.
	* alphabsd-nat.c: Ditto.
	* alphabsd-tdep.c: Ditto.
	* amd64-darwin-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* amd64-sol2-tdep.c: Ditto.
	* amd64-tdep.c: Ditto.
	* amd64-fbsd-tdep.c: Ditto.
	* amd64-nbsd-tdep.c: Ditto.
	* amd64-obsd-tdep.c: Ditto.
	* amd64-linux-nat.c: Ditto.
	* amd64-linux-tdep.c: Ditto.
	* arm-tdep.c: Ditto.
	* arm-tdep.h: Ditto.
	* armnbsd-nat.c: Ditto.
	* avr-tdep.c: Ditto.
	* bfin-tdep.c: Ditto.
	* bsd-kvm.c: Ditto.
	* c-typeprintc: Ditto.
	* c-valprint.c: Ditto.
	* coff-pe-read.h: Ditto.
	* coffreead.c: Ditto.
	* cris-tdep.c: Ditto.
	* d-lang.c: Ditto.
	* darwin-nat-info.c: Ditto.
	* darwin-nat.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* dcache.c: Ditto.
	* dcache.h: Ditto.
	* dec-thread.c: Ditto.
	* defs.h: Ditto.
	* demangle.c: Ditto.
	* dicos-tdep.c: Ditto.
	* dictionary.c: Ditto.
	* dictionary.h: Ditto.
	* dink32-rom.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dsrec.c: Ditto.
	* dummy-frame.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* environ.c: Ditto.
	* eval.c: Ditto.
	* event-top.h: Ditto.
	* exceptions.c: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-exp.y: Ditto.
	* f-lang.c: Ditto.
	* f-lang.h: Ditto.
	* f-typeprint.c: Ditto.
	* f-valprint.c: Ditto.
	* fbsd-nat.c: Ditto.
	* findvar.c: Ditto.
	* fork-child.c: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* frv-linux-tdep.c: Ditto.
	* frv-tdep.c: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_string.h: Ditto.
	* gdb_thread_db.h: Ditto.
	* gdb_wait.h: Ditto.
	* gdbarch.sh: Ditto.
	* gdbcore.h: Ditto.
	* gdbthread.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* gnu-nat.c: Ditto.
	* gnu-nat.h: Ditto.
	* gnu-v2-abi.c: Ditto.
	* gnu-v3-abi.c: Ditto.
	* go32-nat.c: Ditto.
	* gdbarch.c: Regenerate.
	* gdbarch.h: Regenerate.
@
text
@d1126 1
a1126 1
	    retval = allocate_value (type);
a1127 1
	    set_value_lazy (retval, 1);
@


1.101
log
@2011-01-05  Michael Snyder  <msnyder@@vmware.com>

	* addrmap.c: Shorten lines of >= 80 columns.
	* arch-utils.c: Ditto.
	* arch-utils.h: Ditto.
	* ax-gdb.c: Ditto.
	* ax-general.c: Ditto.
	* bcache.c: Ditto.
	* blockframe.c: Ditto.
	* breakpoint.c: Ditto.
	* buildsym.c: Ditto.
	* c-lang.c: Ditto.
	* c-typeprint.c: Ditto.
	* charset.c: Ditto.
	* coffread.c: Ditto.
	* command.h: Ditto.
	* corelow.c: Ditto.
	* cp-abi.c: Ditto.
	* cp-namespace.c: Ditto.
	* cp-support.c: Ditto.
	* dbug-rom.c: Ditto.
	* dbxread.c: Ditto.
	* defs.h: Ditto.
	* dfp.c: Ditto.
	* dfp.h: Ditto.
	* dictionary.c: Ditto.
	* disasm.c: Ditto.
	* doublest.c: Ditto.
	* dwarf2-frame.c: Ditto.
	* dwarf2expr.c: Ditto.
	* dwarf2loc.c: Ditto.
	* dwarf2read.c: Ditto.
	* elfread.c: Ditto.
	* eval.c: Ditto.
	* event-loop.c: Ditto.
	* event-loop.h: Ditto.
	* exceptions.h: Ditto.
	* exec.c: Ditto.
	* expprint.c: Ditto.
	* expression.h: Ditto.
	* f-lang.c: Ditto.
	* f-valprint.c: Ditto.
	* findcmd.c: Ditto.
	* frame-base.c: Ditto.
	* frame-unwind.c: Ditto.
	* frame-unwind.h: Ditto.
	* frame.c: Ditto.
	* frame.h: Ditto.
	* gcore.c: Ditto.
	* gdb-stabs.h: Ditto.
	* gdb_assert.h: Ditto.
	* gdb_dirent.h: Ditto.
	* gdb_obstack.h: Ditto.
	* gdbcore.h: Ditto.
	* gdbtypes.c: Ditto.
	* gdbtypes.h: Ditto.
	* inf-ttrace.c: Ditto.
	* infcall.c: Ditto.
	* infcmd.c: Ditto.
	* inflow.c: Ditto.
	* infrun.c: Ditto.
	* inline-frame.h: Ditto.
	* language.c: Ditto.
	* language.h: Ditto.
	* libunwind-frame.c: Ditto.
	* libunwind-frame.h: Ditto.
	* linespec.c: Ditto.
	* linux-nat.c: Ditto.
	* linux-nat.h: Ditto.
	* linux-thread-db.c: Ditto.
	* machoread.c: Ditto.
	* macroexp.c: Ditto.
	* macrotab.c: Ditto.
	* main.c: Ditto.
	* maint.c: Ditto.
	* mdebugread.c: Ditto.
	* memattr.c: Ditto.
	* minsyms.c: Ditto.
	* monitor.c: Ditto.
	* monitor.h: Ditto.
	* objfiles.c: Ditto.
	* objfiles.h: Ditto.
	* osabi.c: Ditto.
	* p-typeprint.c: Ditto.
	* p-valprint.c: Ditto.
	* parse.c: Ditto.
	* printcmd.c: Ditto.
	* proc-events.c: Ditto.
	* procfs.c: Ditto.
	* progspace.c: Ditto.
	* progspace.h: Ditto.
	* psympriv.h: Ditto.
	* psymtab.c: Ditto.
	* record.c: Ditto.
	* regcache.c: Ditto.
	* regcache.h: Ditto.
	* remote-fileio.c: Ditto.
	* remote.c: Ditto.
	* ser-mingw.c: Ditto.
	* ser-tcp.c: Ditto.
	* ser-unix.c: Ditto.
	* serial.c: Ditto.
	* serial.h: Ditto.
	* solib-frv.c: Ditto.
	* solib-irix.c: Ditto.
	* solib-osf.c: Ditto.
	* solib-pa64.c: Ditto.
	* solib-som.c: Ditto.
	* solib-sunos.c: Ditto.
	* solib-svr4.c: Ditto.
	* solib-target.c: Ditto.
	* solib.c: Ditto.
	* somread.c: Ditto.
	* source.c: Ditto.
	* stabsread.c: Ditto.
	* stabsread.c: Ditto.
	* stack.c: Ditto.
	* stack.h: Ditto.
	* symfile-mem.c: Ditto.
	* symfile.c: Ditto.
	* symfile.h: Ditto.
	* symmisc.c: Ditto.
	* symtab.c: Ditto.
	* symtab.h: Ditto.
	* target-descriptions.c: Ditto.
	* target-memory.c: Ditto.
	* target.c: Ditto.
	* target.h: Ditto.
	* terminal.h: Ditto.
	* thread.c: Ditto.
	* top.c: Ditto.
	* tracepoint.c: Ditto.
	* tracepoint.h: Ditto.
	* ui-file.c: Ditto.
	* ui-file.h: Ditto.
	* ui-out.h: Ditto.
	* user-regs.c: Ditto.
	* user-regs.h: Ditto.
	* utils.c: Ditto.
	* valarith.c: Ditto.
	* valops.c: Ditto.
	* valprint.c: Ditto.
	* valprint.h: Ditto.
	* value.c: Ditto.
	* varobj.c: Ditto.
	* varobj.h: Ditto.
	* vec.h: Ditto.
	* xcoffread.c: Ditto.
	* xcoffsolib.c: Ditto.
	* xcoffsolib.h: Ditto.
	* xml-syscall.c: Ditto.
	* xml-tdesc.c: Ditto.
@
text
@d2240 3
a2242 3
     DW_OP_addr.  0xe0 is the encoding for
     DW_OP_GNU_push_tls_address. The operand represents the offset at
     which the variable is within the thread local storage.  */
@


1.100
log
@run copyright.sh for 2011.
@
text
@d88 2
a89 1
	error (_("dwarf2_find_location_expression: Corrupted DWARF expression."));
d257 3
a259 2
/* Call DWARF subroutine from DW_AT_location of DIE at DIE_OFFSET in current CU
   (as is PER_CU).  State of the CTX is not affected by the call and return.  */
d507 2
a508 1
  struct piece_closure *c = (struct piece_closure *) value_computed_closure (v);
d686 2
a687 1
  struct piece_closure *c = (struct piece_closure *) value_computed_closure (to);
d993 2
a994 1
  struct piece_closure *c = (struct piece_closure *) value_computed_closure (v);
d1003 2
a1004 1
  struct piece_closure *c = (struct piece_closure *) value_computed_closure (v);
d1032 2
a1033 1
  error (_("access outside bounds of object referenced via synthetic pointer"));
d2191 2
a2192 1
	    error (_("Unexpected opcode after DW_OP_breg%u for symbol \"%s\"."),
d2210 2
a2211 1
      fprintf_filtered (stream, _("a variable at frame base reg $%s offset %s+%s"),
d2574 2
a2575 1
	  data = locexpr_describe_location_piece (symbol, stream, addr, objfile,
d2585 2
a2586 1
	data = disassemble_dwarf_expression (stream, get_objfile_arch (objfile),
d2650 2
a2651 1
  locexpr_describe_location_1 (symbol, addr, stream, dlbaton->data, dlbaton->size,
@


1.99
log
@gdb
	* opencl-lang.c (lval_func_check_synthetic_pointer): New
	function.
	* value.h (struct lval_funcs) <indirect, check_synthetic_pointer>:
	New fields.
	(value_bits_synthetic_pointer): Declare.
	* value.c (value_bits_synthetic_pointer): New function.
	* valprint.c (valprint_check_validity): Handle synthetic
	pointers.
	* valops.c (value_ind): Use new 'indirect' lval_funcs method.
	* valarith.c (value_ptradd): Use set_value_component_location.
	* p-valprint.c (pascal_object_print_value_fields): Handle
	synthetic pointers.
	* jv-valprint.c (java_print_value_fields): Handle synthetic
	pointers.
	* dwarf2read.c (dwarf_stack_op_name): Add
	DW_OP_GNU_implicit_pointer.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.  Handle location lists.
	(fill_in_loclist_baton): New function.
	(dwarf2_symbol_mark_computed): Use it.
	* dwarf2loc.h (dwarf2_find_location_expression): Declare.
	(dwarf2_fetch_die_location_block): Add get_frame_pc, baton
	arguments.
	* dwarf2loc.c (dwarf2_find_location_expression): Rename from
	find_location_expression.  No longer static.  Update all callers.
	(dwarf_expr_frame_pc): New function.
	(per_cu_dwarf_call): Add get_frame_pc, baton arguments.  Update
	all callers.
	(struct piece_closure) <per_cu>: New field.
	(allocate_piece_closure): Add per_cu argument.
	(read_pieced_value): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_bits): Remove validity argument, add check_for
	argument.  Handle DWARF_VALUE_IMPLICIT_POINTER.
	(check_pieced_value_validity, check_pieced_value_invalid):
	Update.
	(check_pieced_synthetic_pointer): New function.
	(get_frame_address_in_block_wrapper): New function.
	(indirect_pieced_value): New function.
	(pieced_value_funcs): Update.
	(invalid_synthetic_pointer): New function.
	(dwarf2_evaluate_loc_desc_full): Rename from
	dwarf2_evaluate_loc_desc.  Add byte_offset argument.
	(dwarf2_evaluate_loc_desc): Rewrite.
	(dwarf2_loc_desc_needs_frame): Set new field on context.
	(get_ax_pc): New function.
	(disassemble_dwarf_expression): Handle
	DW_OP_GNU_implicit_pointer.
	* dwarf2expr.h (enum dwarf_value_location)
	<DWARF_VALUE_IMPLICIT_POINTER>: New constant.
	(struct dwarf_expr_context) <get_frame_pc>: New field.
	(struct dwarf_expr_piece) <v.ptr>: New field.
	* dwarf2expr.c (add_piece): Handle DWARF_VALUE_IMPLICIT_POINTER.
	(execute_stack_op): Handle DW_OP_GNU_implicit_pointer.
	* dwarf2-frame.c (no_get_frame_pc): New function.
	(execute_stack_op): Set new field on context.
	* cp-valprint.c (cp_print_value_fields): Handle synthetic
	pointers.
gdb/testsuite
	* gdb.dwarf2/implptr.exp: New file.
	* gdb.dwarf2/implptr.c: New file.
	* gdb.dwarf2/implptr.S: New file.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2007, 2008, 2009, 2010
@


1.98
log
@gdb
	PR symtab/8399:
	* dwarf2loc.c (locexpr_describe_location_piece): Don't call error
	for unrecognized frame base expression.
gdb/testsuite
	PR symtab/8399:
	* gdb.threads/tls.exp: Remove kfail.  Update expected output.
@
text
@d51 7
a57 1
/* A helper function for dealing with location lists.  Given a
d65 3
a67 3
static const gdb_byte *
find_location_expression (struct dwarf2_loclist_baton *baton,
			  size_t *locexpr_length, CORE_ADDR pc)
d88 1
a88 1
	error (_("find_location_expression: Corrupted DWARF expression."));
d202 1
a202 1
      *start = find_location_expression (symbaton, length, pc);
d234 11
d261 3
a263 1
		   struct dwarf2_per_cu_data *per_cu)
d267 2
a268 1
  block = dwarf2_fetch_die_location_block (die_offset, per_cu);
d283 2
a284 1
  return per_cu_dwarf_call (ctx, die_offset, debaton->per_cu);
d292 3
d309 2
a310 1
allocate_piece_closure (int n_pieces, struct dwarf_expr_piece *pieces,
d316 1
d651 5
d664 2
a665 1
      if (p->location != DWARF_VALUE_OPTIMIZED_OUT)
d820 8
d830 2
a831 1
			 int bit_length, int validity)
d836 2
d862 7
a868 1
      if (p->location == DWARF_VALUE_OPTIMIZED_OUT)
d887 2
a888 1
  return check_pieced_value_bits (value, bit_offset, bit_length, 1);
d895 89
a983 1
				  8 * TYPE_LENGTH (value_type (value)), 0);
d1014 2
d1020 9
d1030 3
a1032 2
   SIZE, to find the current location of variable of TYPE in the context
   of FRAME.  */
d1034 5
a1038 4
struct value *
dwarf2_evaluate_loc_desc (struct type *type, struct frame_info *frame,
			  const gdb_byte *data, unsigned short size,
			  struct dwarf2_per_cu_data *per_cu)
d1046 3
d1071 1
d1080 2
d1083 6
a1088 1
      c = allocate_piece_closure (ctx->num_pieces, ctx->pieces,
d1092 1
d1104 2
d1124 1
a1124 1
	    set_value_address (retval, address);
d1131 1
a1131 1
	    bfd_byte *contents;
d1134 11
d1149 1
a1149 3
	    store_unsigned_integer (contents, n,
				    gdbarch_byte_order (ctx->gdbarch),
				    value);
d1156 1
d1159 3
d1164 4
d1170 1
a1170 1
	    memcpy (contents, ctx->data, n);
d1174 3
d1191 12
d1270 2
a1271 1
  return per_cu_dwarf_call (ctx, die_offset, nf_baton->per_cu);
d1301 1
d1393 10
d2051 2
a2052 1
	    block = dwarf2_fetch_die_location_block (uoffset, per_cu);
d2518 14
d2683 1
d2685 1
a2685 3
  data = find_location_expression (dlbaton, &size,
				   frame ? get_frame_address_in_block (frame)
				   : 0);
d2805 1
a2805 1
  data = find_location_expression (dlbaton, &size, ax->scope);
@


1.97
log
@2010-08-12  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Pedro Alves  <pedro@@codesourcery.com>

	* dwarf2read.c: Include "c-lang.h" and "valprint.h".
	(struct dwarf2_per_objfile) <reading_partial_symbols>: New field.
	(struct partial_die_info) <has_template_arguments>: New field.
	<num_attrs>: Change type to unsigned char.
	<building_fullname>: New field.
	(dwarf2_build_psymtabs_hard): Set reading_partial_symbols.  Only
	allocate a CU if we don't have one already.  Add a cleanup for the
	CU.
	(partial_die_full_name): Handle template arguments not in
	DW_AT_name.
	(dwarf2_psymtab_to_symtab): Clear reading_partial_symbols.
	(load_full_comp_unit): Only allocate a CU if we don't have one
	already.
	(do_ui_file_peek_last): New.
	(dwarf2_compute_name): Handle template parameters not in
	DW_AT_name.
	(read_comp_unit): Read and free abbrevs if not read yet.
	(load_partial_dies): Handle template arguments not in DW_AT_name.
	(find_partial_die): If we have a CU, but no a partial dies yet,
	also read in the CU.
	(dwarf2_const_value_attr): New, abstracted out from
	dwarf2_const_value.
	(dwarf2_const_value, dwarf2_const_value_data): Adjust to use
	dwarf2_const_value_attr.
	(determine_prefix): Detect and break loops created by RCVT's debug
	info.
	(maybe_queue_comp_unit): Bail out early if reading partial
	symbols.
	(follow_die_offset): Load full CU if we have no dies.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Make public.
	* dwarf2loc.h (dwarf2_evaluate_loc_desc): Declare.
@
text
@d1943 1
a1943 1
      const gdb_byte *base_data, *new_data;
d1987 1
a1987 4
	  error (_("Cannot describe location of symbol \"%s\"; "
		   "DWARF 2 encoding not handled, "
		   "first opcode in base data is 0x%x."),
		 SYMBOL_PRINT_NAME (symbol), base_data[0]);
@


1.96
log
@	* dwarf2loc.c (locexpr_describe_location_piece): Also recognize
	TLS with DW_OP_const4u or DW_OP_const8u.
@
text
@d884 1
a884 1
static struct value *
@


1.95
log
@	* dwarf2loc.h (dwarf2_per_cu_text_offset): Declare.
	* dwarf2loc.c (find_location_expression): Use
	dwarf2_per_cu_text_offset.
	(dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax): Likewise.
	(loclist_describe_location): Likewise.
	* dwarf2read.c (dwarf2_per_cu_text_offset): New function.
	(dwarf2_per_cu_objfile): Update comment.
@
text
@d2019 1
a2019 1
     
d2022 5
a2026 3
     bytes).  0xe0 is the encoding for DW_OP_GNU_push_tls_address.
     The operand represents the offset at which the variable is within
     the thread local storage.  */
d2029 3
a2031 1
	   && data[0] == DW_OP_addr
@


1.94
log
@	* dwarf2read.c (dwarf2_const_value) <DW_form_addr>: Create a
	LOC_COMPUTED symbol.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Set new field.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax) <DW_OP_addr>: Use offset.
	* dwarf2expr.h (struct dwarf_expr_context) <offset>: New field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_addr>: Use offset.
	* dwarf2-frame.c (execute_stack_op): Set 'offset' field.  Add
	'offset' argument.
	(struct dwarf2_frame_cache) <text_offset>: New field.
	(dwarf2_frame_cache): Set new field.
	(dwarf2_frame_prev_register): Update.
	(dwarf2_frame_sniffer): Update.
	(dwarf2_frame_base_sniffer): Update.
	(dwarf2_frame_find_fde): Add 'out_offset' argument.
@
text
@d73 1
a73 2
  CORE_ADDR base_offset = ANOFFSET (objfile->section_offsets,
				    SECT_OFF_TEXT (objfile));
d911 1
a911 1
  ctx->offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1097 1
a1097 1
  ctx->offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1306 1
a1306 6
	    {
	      struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);

	      uoffset += ANOFFSET (objfile->section_offsets,
				   SECT_OFF_TEXT (objfile));
	    }
d2508 1
a2508 2
  CORE_ADDR base_offset = ANOFFSET (objfile->section_offsets,
				    SECT_OFF_TEXT (objfile));
@


1.93
log
@	* dwarf2loc.c (locexpr_tracepoint_var_ref)
	(loclist_tracepoint_var_ref): Handle optimized out values.
@
text
@d894 1
d910 1
a910 1
  ctx->gdbarch = get_objfile_arch (dwarf2_per_cu_objfile (per_cu));
d912 1
d1088 1
d1096 1
a1096 1
  ctx->gdbarch = get_objfile_arch (dwarf2_per_cu_objfile (per_cu));
d1098 1
d1300 1
a1300 2
	  ax_const_l (expr, extract_unsigned_integer (op_ptr,
						      addr_size, byte_order));
d1302 12
@


1.93.2.1
log
@	* dwarf2read.c (dwarf2_const_value) <DW_form_addr>: Create a
	LOC_COMPUTED symbol.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Set new field.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax) <DW_OP_addr>: Use offset.
	* dwarf2expr.h (struct dwarf_expr_context) <offset>: New field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_addr>: Use offset.
	* dwarf2-frame.c (execute_stack_op): Set 'offset' field.  Add
	'offset' argument.
	(struct dwarf2_frame_cache) <text_offset>: New field.
	(dwarf2_frame_cache): Set new field.
	(dwarf2_frame_prev_register): Update.
	(dwarf2_frame_sniffer): Update.
	(dwarf2_frame_base_sniffer): Update.
	(dwarf2_frame_find_fde): Add 'out_offset' argument.
@
text
@a893 1
  struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);
d909 1
a909 1
  ctx->gdbarch = get_objfile_arch (objfile);
a910 1
  ctx->offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
a1085 1
  struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);
d1093 1
a1093 1
  ctx->gdbarch = get_objfile_arch (objfile);
a1094 1
  ctx->offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));
d1296 2
a1297 1
	  uoffset = extract_unsigned_integer (op_ptr, addr_size, byte_order);
a1298 12
	  /* Some versions of GCC emit DW_OP_addr before
	     DW_OP_GNU_push_tls_address.  In this case the value is an
	     index, not an address.  We don't support things like
	     branching between the address and the TLS op.  */
	  if (op_ptr >= op_end || *op_ptr != DW_OP_GNU_push_tls_address)
	    {
	      struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);

	      uoffset += ANOFFSET (objfile->section_offsets,
				   SECT_OFF_TEXT (objfile));
	    }
	  ax_const_l (expr, uoffset);
@


1.93.2.2
log
@	* dwarf2loc.h (dwarf2_per_cu_text_offset): Declare.
	* dwarf2loc.c (find_location_expression): Use
	dwarf2_per_cu_text_offset.
	(dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(compile_dwarf_to_ax): Likewise.
	(loclist_describe_location): Likewise.
	* dwarf2read.c (dwarf2_per_cu_text_offset): New function.
	(dwarf2_per_cu_objfile): Update comment.
@
text
@d73 2
a74 1
  CORE_ADDR base_offset = dwarf2_per_cu_text_offset (baton->per_cu);
d912 1
a912 1
  ctx->offset = dwarf2_per_cu_text_offset (per_cu);
d1098 1
a1098 1
  ctx->offset = dwarf2_per_cu_text_offset (per_cu);
d1307 6
a1312 1
	    uoffset += dwarf2_per_cu_text_offset (per_cu);
d2514 2
a2515 1
  CORE_ADDR base_offset = dwarf2_per_cu_text_offset (dlbaton->per_cu);
@


1.93.2.3
log
@	* dwarf2loc.c (locexpr_describe_location_piece): Also recognize
	TLS with DW_OP_const4u or DW_OP_const8u.
@
text
@d2019 1
a2019 1

d2022 3
a2024 5
     bytes).  Note that more recent version of GCC emit DW_OP_const4u
     or DW_OP_const8u, depending on address size, rather than
     DW_OP_addr.  0xe0 is the encoding for
     DW_OP_GNU_push_tls_address. The operand represents the offset at
     which the variable is within the thread local storage.  */
d2027 1
a2027 3
	   && (data[0] == DW_OP_addr
	       || (addr_size == 4 && data[0] == DW_OP_const4u)
	       || (addr_size == 8 && data[0] == DW_OP_const8u))
@


1.93.2.4
log
@	PR gdb/12576:
	* dwarf2loc.c (dwarf_expr_dwarf_call): Remove 'return'.
	(needs_frame_dwarf_call): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2007, 2008, 2009, 2010, 2011
d263 1
a263 1
  per_cu_dwarf_call (ctx, die_offset, debaton->per_cu);
d1073 1
a1073 1
  per_cu_dwarf_call (ctx, die_offset, nf_baton->per_cu);
@


1.92
log
@ChangeLog:

	* dwarf2expr.h (struct dwarf_value_location): Use ULONGEST as type
	of stack values.
	(struct dwarf_expr_piece): Rename "expr" member to "mem".  Add new
	"value" member.
	(dwarf_expr_push): Change input type to ULONGEST.
	(dwarf_expr_fetch): Change return type to ULONGEST.
	(dwarf_expr_fetch_address): Add prototype.
	(dwarf2_read_address): Remove prototype.
	* dwarf2expr.c (dwarf_expr_push): Use ULONGEST as type of stack values.
	Truncate stack values to ctx->addr_size bytes.
	(dwarf_expr_fetch): Change return value to ULONGEST.
	(dwarf_expr_fetch_address): New function.
	(add_piece): Use dwarf_expr_fetch_address instead of dwarf_expr_fetch
	when appropriate.  Update for struct dwarf_expr_piece changes.
	(dwarf2_read_address): Remove.
	(unsigned_address_type): Remove.
	(signed_address_type): Remove.
	(execute_stack_op): Use dwarf_expr_fetch_address instead of
	dwarf_expr_fetch when appropriate.  Use ULONGEST as type of stack
	values.  Perform operations on ULONGEST instead of on GDB values,
	sign-extending from ctx->addr_size bytes as needed.  Read DW_OP_addr
	values and DW_OP_deref results as unsigned integers.
	* dwarf2loc.c (read_pieced_value): Update for struct dwarf_expr_piece
	changes.
	(write_pieced_value): Likewise.
	(dwarf2_evaluate_loc_desc): Use dwarf_expr_fetch_address instead of
	dwarf_expr_fetch when appropriate.
	(compile_dwarf_to_ax): Read DW_OP_addr values as unsigned integers.
	* dwarf2-frame.c (execute_stack_op): Use dwarf_expr_fetch_address
	instead of dwarf_expr_fetch when appropriate.

testsuite/ChangeLog:

	* gdb.cell/dwarfaddr.exp: New file.
	* gdb.cell/dwarfaddr.S: New file.
@
text
@d2419 6
a2424 3
  compile_dwarf_to_ax (ax, value, gdbarch, addr_size,
		       dlbaton->data, dlbaton->data + dlbaton->size,
		       dlbaton->per_cu);
d2574 5
a2578 3

  compile_dwarf_to_ax (ax, value, gdbarch, addr_size, data, data + size,
		       dlbaton->per_cu);
@


1.91
log
@	* dwarf2loc.c (find_location_expression): Add relocation offset
	to base-address-selection entry base addresses.  Read addresses
	(and offsets) as signed/unsigned integers, depending on the
	BFD's sign_extend_vma flag.  Do not call dwarf2_read_address.
	(loclist_describe_location): Likewise.
	(disassemble_dwarf_expression): Read DW_OP_addr operand as
	unsigned integer.  Do not call dwarf2_read_address.
	(locexpr_describe_location): Likewise for DW_OP_GNU_push_tls_address.
@
text
@d551 1
a551 2
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch,
							   p->v.expr.value);
d572 1
a572 1
		       paddress (arch, p->v.expr.value));
d578 2
a579 2
	  if (p->v.expr.in_stack_memory)
	    read_stack (p->v.expr.value + source_offset, buffer, this_size);
d581 1
a581 1
	    read_memory (p->v.expr.value + source_offset, buffer, this_size);
d600 1
a600 1
				      p->v.expr.value);
d607 1
a607 1
					p->v.expr.value);
d732 1
a732 1
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->v.expr.value);
d758 1
a758 1
		       paddress (arch, p->v.expr.value));
d767 2
a768 2
	      read_memory (p->v.expr.value + dest_offset, buffer, 1);
	      read_memory (p->v.expr.value + dest_offset + this_size - 1,
d776 1
a776 1
	  write_memory (p->v.expr.value + dest_offset,
d937 1
a937 1
	    CORE_ADDR dwarf_regnum = dwarf_expr_fetch (ctx, 0);
d950 1
a950 1
	    CORE_ADDR address = dwarf_expr_fetch (ctx, 0);
d964 1
a964 1
	    ULONGEST value = (ULONGEST) dwarf_expr_fetch (ctx, 0);
a1234 1
      CORE_ADDR result;
d1296 2
a1297 2
	  result = dwarf2_read_address (arch, op_ptr, op_end, addr_size);
	  ax_const_l (expr, result);
@


1.90
log
@gdb
	PR gdb/9977, PR exp/11636:
	* value.h (value_offset): Update.
	(struct lval_funcs) <check_validity>: New field.
	<copy_closure>: Make argument const.
	(value_computed_closure): Update.
	(value_contents_for_printing): Declare.
	(value_bits_valid): Likewise.
	(val_print): Likewise.
	(set_value_component_location): Update.
	(value_entirely_optimized_out): Declare.
	* value.c (value_offset): Argument now const.
	(require_not_optimized_out): New function.
	(value_contents_for_printing): New function.
	(value_contents_all): Call require_not_optimized_out.
	(value_contents): Likewise.
	(value_bits_valid): New function.
	(value_computed_closure): Argument now const.
	(set_value_component_location): Make 'whole' argument const.
	(value_entirely_optimized_out): New function.
	(value_bitsize): Argument now 'const'.
	(value_bitpos): Likewise.
	(value_type): Likewise.
	* valprint.h (val_print_array_elements): Update.
	* valprint.c (val_print): Add 'val' argument.  Use
	valprint_check_validity.
	(valprint_check_validity): New function.
	(value_check_printable): Use value_entirely_optimized_out.
	(common_val_print): Update.
	(value_print): Likewise.
	(val_print_array_elements): Add 'val' argument.
	* valops.c (value_fetch_lazy): Use value_contents_for_printing,
	value_bits_valid.  Reinit frame cache for lval_computed.
	* sh64-tdep.c (sh64_do_register): Update.
	* scm-valprint.c (scm_val_print): Add 'val' argument.
	* scm-lang.h (scm_val_print): Update.
	* python/python.h (apply_val_pretty_printer): Update.
	* python/py-prettyprint.c (apply_val_pretty_printer): Add 'val'
	argument.  Call set_value_component_location.
	* printcmd.c (print_scalar_formatted): Update.
	* p-valprint.c (pascal_val_print): Add 'val' argument.
	(pascal_object_print_value_fields): Likewise.
	(pascal_object_print_value): Likewise.
	(pascal_object_print_static_field): Update.
	* p-lang.h (pascal_val_print): Update.
	(pascal_object_print_value_fields): Update.
	* mt-tdep.c (mt_registers_info): Update.
	* mi/mi-main.c (get_register): Update.
	(mi_cmd_data_evaluate_expression): Use common_val_print.
	* m2-valprint.c (m2_print_array_contents): Add 'val' argument.
	(m2_print_unbounded_array): Likewise.
	(m2_val_print): Likewise.
	* m2-lang.h (m2_val_print): Update.
	* language.h (struct language_defn) <la_val_print>: Add 'val'
	argument.
	(LA_VAL_PRINT): Likewise.
	* language.c (unk_lang_val_print): Add 'val' argument.
	* jv-valprint.c (java_print_value_fields): Add 'val' argument.
	(java_val_print): Likewise.
	* jv-lang.h (java_val_print): Add 'val' argument.
	* infcmd.c (default_print_registers_info): Update.
	* f-valprint.c (f77_print_array_1): Add 'val' argument.
	(f77_print_array): Likewise.
	(f_val_print): Likewise.
	* f-lang.h (f_val_print): Add 'val' argument.
	* dwarf2loc.c (read_pieced_value): Use value_bitsize and
	value_bitpos.
	<DWARF_VALUE_OPTIMIZED_OUT>: Don't print warning.  Call
	set_value_optimized_out.
	(write_pieced_value): Use value_bitsize and value_bitpos.
	<default>: Don't exit loop.
	(check_pieced_value_validity): New function.
	(pieced_value_funcs): Reference check_pieced_value_validity,
	check_pieced_value_invalid.
	(copy_pieced_value_closure): Update.
	(check_pieced_value_bits): New function.
	(check_pieced_value_invalid): New function.
	* d-valprint.c (dynamic_array_type): Add 'val' argument.
	(d_val_print): Likewise.
	* d-lang.h (d_val_print): Update.
	* cp-valprint.c (cp_print_value_fields): Add 'val' argument.
	(cp_print_value_fields_rtti): Likewise.
	(cp_print_value): Likewise.
	(cp_print_static_field): Update.
	* c-valprint.c (c_val_print): Add 'val' argument.
	(c_value_print): Update.
	* c-lang.h (c_val_print): Update.
	(cp_print_value_fields): Likewise.
	(cp_print_value_fields_rtti): Likewise.
	* ada-valprint.c (struct ada_val_print_args): Remove.
	(val_print_packed_array_elements): Add 'val' argument.
	(ada_val_print): Likewise.  Rewrite.
	(ada_val_print_stub): Remove.
	(ada_val_print_array): Add 'val' argument.
	(ada_val_print_1): Likewise.
	(print_variant_part): Likewise.
	(ada_value_print): Update.
	(print_record): Add 'val' argument.
	(print_field_values): Likewise.
	* ada-lang.h (ada_val_print): Update.
gdb/testsuite
	PR gdb/9977, PR exp/11636::
	* gdb.dwarf2/pieces.exp (pieces_test_f3): Remove kfail.
	(pieces_test_f6): Update expected output.
@
text
@d70 1
d85 10
a94 1
      low = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
d98 1
a98 1
      if (low == base_mask)
d100 1
a100 3
	  base_address = dwarf2_read_address (gdbarch,
					      loc_ptr, buf_end, addr_size);
	  loc_ptr += addr_size;
a103 3
      high = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
      loc_ptr += addr_size;

d2024 3
a2026 4
      CORE_ADDR offset = dwarf2_read_address (gdbarch,
					      data + 1,
					      end,
					      addr_size);
d2029 1
a2029 1
			_("a thread-local variable at offset %s "
d2031 1
a2031 1
			paddress (gdbarch, offset), objfile->name);
a2067 1
      CORE_ADDR addr;
d2082 2
a2083 1
	  addr = dwarf2_read_address (arch, data, end, addr_size);
d2085 1
a2085 1
	  fprintf_filtered (stream, " %s", paddress (arch, addr));
d2495 1
d2514 10
a2523 1
      low = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
d2527 1
a2527 1
      if (low == base_mask)
d2529 1
a2529 2
	  base_address = dwarf2_read_address (gdbarch,
					      loc_ptr, buf_end, addr_size);
a2531 1
	  loc_ptr += addr_size;
a2534 3
      high = extract_unsigned_integer (loc_ptr, addr_size, byte_order);
      loc_ptr += addr_size;

@


1.89
log
@	* vec.h (VEC_cleanup): New macro.
	(DEF_VEC_ALLOC_FUNC_I): Update.
	(DEF_VEC_ALLOC_FUNC_P): Likewise.
	(DEF_VEC_ALLOC_FUNC_O): Likewise.
	* dwarf2loc.c (struct axs_var_loc): Remove.
	(unimplemented): New function.
	(translate_register): Likewise.
	(access_memory): Likewise.
	(compile_dwarf_to_ax): Likewise.
	(dwarf2_tracepoint_var_loc): Remove.
	(dwarf2_tracepoint_var_access): Likewise.
	(dwarf2_tracepoint_var_ref): Likewise.
	(locexpr_tracepoint_var_ref): Use compile_dwarf_to_ax.
	(loclist_tracepoint_var_ref): Likewise.
	* dwarf2expr.h (dwarf_expr_require_composition): Declare.
	* dwarf2expr.c (dwarf_expr_require_composition): Rename from
	require_composition.  No longer static.
	(execute_stack_op): Update.
	* ax-gdb.h (trace_kludge): Declare.
@
text
@d493 7
a499 1
  type_len = 8 * TYPE_LENGTH (value_type (v));
d623 1
a623 7
	  /* We just leave the bits empty for now.  This is not ideal
	     but gdb currently does not have a nice way to represent
	     optimized-out pieces.  */
	  warning (_("bits %ld-%ld in computed object were optimized out; "
		     "replacing with zeroes"),
		   offset,
		   offset + (long) this_size_bits);
d667 8
a674 1
  type_len = 8 * TYPE_LENGTH (value_type (to));
d777 1
a777 1
	  goto done;
a781 1
 done:
d785 60
d846 1
a846 1
copy_pieced_value_closure (struct value *v)
d871 2
@


1.88
log
@gdb/
	Fix PR 10640.
	* dwarf2-frame.c (no_dwarf_call): New function.
	(execute_stack_op): Set CTX->DWARF_CALL.
	* dwarf2expr.c (execute_stack_op) <DW_OP_call2, DW_OP_call4>: New.
	* dwarf2expr.h (struct dwarf_expr_context) <dwarf_call>: New.
	(struct dwarf_expr_context) <get_subr>: Remove the #if0-ed field.
	* dwarf2loc.c (per_cu_dwarf_call, dwarf_expr_dwarf_call): New functions.
	(dwarf2_evaluate_loc_desc): Initialize CTX->DWARF_CALL.
	(needs_frame_dwarf_call): New function.
	(dwarf2_loc_desc_needs_frame): Initialize CTX->DWARF_CALL.
	* dwarf2read.c (follow_die_offset): Based on former follow_die_ref.
	Update the comment.  Move variables die, offset and error call to ...
	(follow_die_ref): ... a new function.
	(dwarf2_fetch_die_location_block): New function.
	* dwarf2loc.h (dwarf2_fetch_die_location_block): New prototype.

gdb/testsuite/
	Test PR 10640.
	* gdb.dwarf2/dw2-op-call.exp, gdb.dwarf2/dw2-op-call.S: New.
@
text
@d1051 2
a1052 11
/* This struct keeps track of the pieces that make up a multi-location
   object, for use in agent expression generation.  It is
   superficially similar to struct dwarf_expr_piece, but
   dwarf_expr_piece is designed for use in immediate evaluation, and
   does not, for example, have a way to record both base register and
   offset.  */

struct axs_var_loc
{
  /* Memory vs register, etc */
  enum axs_lvalue_kind kind;
d1054 6
a1059 2
  /* If non-zero, number of bytes in this fragment */
  unsigned bytes;
d1061 14
a1074 2
  /* (GDB-numbered) reg, or base reg if >= 0 */
  int reg;
d1076 5
a1080 3
  /* offset from reg */
  LONGEST offset;
};
d1082 2
a1083 6
static const gdb_byte *
dwarf2_tracepoint_var_loc (struct symbol *symbol,
			   struct agent_expr *ax,
			   struct axs_var_loc *loc,
			   struct gdbarch *gdbarch,
			   const gdb_byte *data, const gdb_byte *end)
d1085 21
a1105 1
  if (data[0] >= DW_OP_reg0 && data[0] <= DW_OP_reg31)
d1107 4
a1110 3
      loc->kind = axs_lvalue_register;
      loc->reg = gdbarch_dwarf2_reg_to_regnum (gdbarch, data[0] - DW_OP_reg0);
      data += 1;
d1112 1
a1112 1
  else if (data[0] == DW_OP_regx)
d1114 45
a1158 1
      ULONGEST reg;
d1160 1
a1160 5
      data = read_uleb128 (data + 1, end, &reg);
      loc->kind = axs_lvalue_register;
      loc->reg = gdbarch_dwarf2_reg_to_regnum (gdbarch, reg);
    }
  else if (data[0] == DW_OP_fbreg)
d1162 396
a1557 7
      struct block *b;
      struct symbol *framefunc;
      int frame_reg = 0;
      LONGEST frame_offset;
      const gdb_byte *base_data;
      size_t base_size;
      LONGEST base_offset = 0;
d1559 3
a1561 1
      b = block_for_pc (ax->scope);
d1563 7
a1569 2
      if (!b)
	error (_("No block found for address"));
d1571 3
a1573 1
      framefunc = block_linkage_function (b);
d1575 3
a1577 2
      if (!framefunc)
	error (_("No function found for block"));
d1579 3
a1581 2
      dwarf_expr_frame_base_1 (framefunc, ax->scope,
			       &base_data, &base_size);
d1583 3
a1585 3
      if (base_data[0] >= DW_OP_breg0 && base_data[0] <= DW_OP_breg31)
	{
	  const gdb_byte *buf_end;
d1587 3
a1589 20
	  frame_reg = base_data[0] - DW_OP_breg0;
	  buf_end = read_sleb128 (base_data + 1,
				  base_data + base_size, &base_offset);
	  if (buf_end != base_data + base_size)
	    error (_("Unexpected opcode after DW_OP_breg%u for symbol \"%s\"."),
		   frame_reg, SYMBOL_PRINT_NAME (symbol));
	}
      else if (base_data[0] >= DW_OP_reg0 && base_data[0] <= DW_OP_reg31)
	{
	  /* The frame base is just the register, with no offset.  */
	  frame_reg = base_data[0] - DW_OP_reg0;
	  base_offset = 0;
	}
      else
	{
	  /* We don't know what to do with the frame base expression,
	     so we can't trace this variable; give up.  */
	  error (_("Cannot generate expression to collect symbol \"%s\"; DWARF 2 encoding not handled, first opcode in base data is 0x%x."),
		 SYMBOL_PRINT_NAME (symbol), base_data[0]);
	}
d1591 3
a1593 1
      data = read_sleb128 (data + 1, end, &frame_offset);
d1595 9
a1603 8
      loc->kind = axs_lvalue_memory;
      loc->reg = gdbarch_dwarf2_reg_to_regnum (gdbarch, frame_reg);
      loc->offset = base_offset + frame_offset;
    }
  else if (data[0] >= DW_OP_breg0 && data[0] <= DW_OP_breg31)
    {
      unsigned int reg;
      LONGEST offset;
d1605 10
a1614 2
      reg = data[0] - DW_OP_breg0;
      data = read_sleb128 (data + 1, end, &offset);
d1616 8
a1623 10
      loc->kind = axs_lvalue_memory;
      loc->reg = gdbarch_dwarf2_reg_to_regnum (gdbarch, reg);
      loc->offset = offset;
    }
  else
    error (_("Unsupported DWARF opcode 0x%x in the location of \"%s\"."),
	   data[0], SYMBOL_PRINT_NAME (symbol));
  
  return data;
}
d1625 8
a1632 1
/* Given the location of a piece, issue bytecodes that will access it.  */
d1634 8
a1641 26
static void
dwarf2_tracepoint_var_access (struct agent_expr *ax,
			      struct axs_value *value,
			      struct axs_var_loc *loc)
{
  value->kind = loc->kind;
  
  switch (loc->kind)
    {
    case axs_lvalue_register:
      value->u.reg = loc->reg;
      break;
      
    case axs_lvalue_memory:
      ax_reg (ax, loc->reg);
      if (loc->offset)
	{
	  ax_const_l (ax, loc->offset);
	  ax_simple (ax, aop_add);
	}
      break;
      
    default:
      internal_error (__FILE__, __LINE__, _("Unhandled value kind in dwarf2_tracepoint_var_access"));
    }
}
d1643 9
a1651 23
static void
dwarf2_tracepoint_var_ref (struct symbol *symbol, struct gdbarch *gdbarch,
			   struct agent_expr *ax, struct axs_value *value,
			   const gdb_byte *data, int size)
{
  const gdb_byte *end = data + size;
  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
  /* In practice, a variable is not going to be spread across
     dozens of registers or memory locations.  If someone comes up
     with a real-world example, revisit this.  */
#define MAX_FRAGS 16
  struct axs_var_loc fragments[MAX_FRAGS];
  int nfrags = 0, frag;
  int length = 0;
  int piece_ok = 0;
  int bad = 0;
  int first = 1;
      
  if (!data || size == 0)
    {
      value->optimized_out = 1;
      return;
    }
d1653 2
a1654 30
  while (data < end)
    {
      if (!piece_ok)
	{
	  if (nfrags == MAX_FRAGS)
	    error (_("Too many pieces in location for \"%s\"."),
		   SYMBOL_PRINT_NAME (symbol));

	  fragments[nfrags].bytes = 0;
	  data = dwarf2_tracepoint_var_loc (symbol, ax, &fragments[nfrags],
					    gdbarch, data, end);
	  nfrags++;
	  piece_ok = 1;
	}
      else if (data[0] == DW_OP_piece)
	{
	  ULONGEST bytes;
	      
	  data = read_uleb128 (data + 1, end, &bytes);
	  /* Only deal with 4 byte fragments for now.  */
	  if (bytes != 4)
	    error (_("DW_OP_piece %s not supported in location for \"%s\"."),
		   pulongest (bytes), SYMBOL_PRINT_NAME (symbol));
	  fragments[nfrags - 1].bytes = bytes;
	  length += bytes;
	  piece_ok = 0;
	}
      else
	{
	  bad = 1;
a1655 2
	}
    }
d1657 3
a1659 3
  if (bad || data > end)
    error (_("Corrupted DWARF expression for \"%s\"."),
	   SYMBOL_PRINT_NAME (symbol));
d1661 7
a1667 6
  /* If single expression, no pieces, convert to external format.  */
  if (length == 0)
    {
      dwarf2_tracepoint_var_access (ax, value, &fragments[0]);
      return;
    }
d1669 9
a1677 3
  if (length != TYPE_LENGTH (value->type))
    error (_("Inconsistent piece information for \"%s\"."),
	   SYMBOL_PRINT_NAME (symbol));
d1679 2
a1680 1
  /* Emit bytecodes to assemble the pieces into a single stack entry.  */
d1682 4
a1685 10
  for ((frag = (byte_order == BFD_ENDIAN_BIG ? 0 : nfrags - 1));
       nfrags--;
       (frag += (byte_order == BFD_ENDIAN_BIG ? 1 : -1)))
    {
      if (!first)
	{
	  /* shift the previous fragment up 32 bits */
	  ax_const_l (ax, 32);
	  ax_simple (ax, aop_lsh);
	}
d1687 57
a1743 1
      dwarf2_tracepoint_var_access (ax, value, &fragments[frag]);
d1745 3
a1747 4
      switch (value->kind)
	{
	case axs_lvalue_register:
	  ax_reg (ax, value->u.reg);
d1750 5
a1754 1
	case axs_lvalue_memory:
d1756 7
a1762 1
	    extern int trace_kludge;  /* Ugh. */
d1764 6
a1769 4
	    gdb_assert (fragments[frag].bytes == 4);
	    if (trace_kludge)
	      ax_trace_quick (ax, 4);
	    ax_simple (ax, aop_ref32);
d1772 6
d1779 1
d1781 7
a1787 7
      if (!first)
	{
	  /* or the new fragment into the previous */
	  ax_zero_ext (ax, 32);
	  ax_simple (ax, aop_bit_or);
	}
      first = 0;
d1789 2
a1790 1
  value->kind = axs_rvalue;
d2347 1
d2349 3
a2351 2
  dwarf2_tracepoint_var_ref (symbol, gdbarch, ax, value,
			     dlbaton->data, dlbaton->size);
d2493 1
d2497 2
a2498 1
  dwarf2_tracepoint_var_ref (symbol, gdbarch, ax, value, data, size);
@


1.87
log
@gdb/
	* dwarf2loc.c (struct dwarf_expr_baton) Replace objfile by per_cu.
	(dwarf_expr_tls_address): Use per_cu instead of objfile.
	(dwarf2_evaluate_loc_desc): Drop initialization of BATON.OBJFILE.
	Initialize new BATON.PER_CU.  Adjust CTX->GDBARCH initialization for
	this change.
	(struct needs_frame_baton): New field per_cu.
	(dwarf2_loc_desc_needs_frame): Initialize new BATON.PER_CU.
	* dwarf2read.c (struct dwarf2_per_cu_data) <cu>: Extend the comment.
@
text
@d235 27
d845 1
d993 10
d1029 1
@


1.86
log
@2010-06-04  Hui Zhu  <teawater@@gmail.com>

	* dwarf2loc.c (disassemble_dwarf_expression): Change ul to l.
@
text
@d125 1
a125 1
  struct objfile *objfile;
d230 1
d232 1
a232 1
  return target_translate_tls_address (debaton->objfile, offset);
d805 1
a805 1
  baton.objfile = dwarf2_per_cu_objfile (per_cu);
d810 1
a810 1
  ctx->gdbarch = get_objfile_arch (baton.objfile);
d911 1
d978 1
@


1.85
log
@gdb
	* dwarf2loc.h (dwarf2_per_cu_data): Declare.
	* dwarf2read.c (dwarf_stack_op_name): No longer static.  Return
	type is const.  Add 'def' argument.  Add missing operators, remove
	unhandled ones.
	(decode_locdesc): Update.
	(dwarf2_always_disassemble): New global.
	(show_dwarf2_always_disassemble): New function.
	(_initialize_dwarf2_read): Add always-disassemble.
	(dwarf2_per_cu_offset_size): New function.
	* dwarf2loc.c (dwarf2_always_disassemble): Declare.
	(piece_end_p): New function.
	(locexpr_describe_location_piece): Replace 'size' argument with
	'end'.  Use piece_end_p.  Rewrite recognition of TLS.  Recognize
	some constants.  Remove errors.
	(disassemble_dwarf_expression): New function.
	(locexpr_describe_location_1): Use disassemble_dwarf_expression.
	Add 'offset_size' argument.
	(loclist_describe_location): Change output formatting.
	* dwarf2expr.h (dwarf_stack_op_name): Declare.
gdb/doc
	* gdb.texinfo (Maintenance Commands): Document maint set dwarf2
	always-disassemble.
@
text
@d1539 1
a1539 1
	  data = read_sleb128 (data, end, &ul);
@


1.84
log
@	* dwarf2loc.c (struct piece_closure) <refc>: New field.
	(allocate_piece_closure): Initialize refc.
	(copy_pieced_value_closure): Use refc.
	(free_pieced_value_closure): Likewise.
@
text
@d45 2
d1296 13
a1308 2
/* Describe a single piece of a location, returning an updated
   position in the bytecode sequence.  */
d1313 1
a1313 1
				 const gdb_byte *data, int size,
d1330 1
a1330 1
      data = read_uleb128 (data + 1, data + size, &reg);
d1341 1
a1341 1
      const gdb_byte *base_data;
d1345 5
a1392 2
      data = read_sleb128 (data + 1, data + size, &frame_offset);

d1397 2
a1398 1
  else if (data[0] >= DW_OP_breg0 && data[0] <= DW_OP_breg31)
d1404 1
a1404 1
      data = read_sleb128 (data + 1, data + size, &offset);
d1424 4
a1427 3
  else if (size > 1
	   && data[size - 1] == DW_OP_GNU_push_tls_address
	   && data[0] == DW_OP_addr)
d1431 1
a1431 1
					      data + size - 1,
d1441 269
a1709 3
  else
    fprintf_filtered (stream,
		      _("a variable with complex or multiple locations (DWARF2)"));
d1721 2
a1722 1
			     struct objfile *objfile, unsigned int addr_size)
d1725 1
a1725 1
  int piece_done = 0, first_piece = 1, bad = 0;
a1726 2
  /* A multi-piece description consists of multiple sequences of bytes
     each followed by DW_OP_piece + length of piece.  */
d1729 9
a1737 1
      if (!piece_done)
d1739 13
a1751 4
	  if (first_piece)
	    first_piece = 0;
	  else
	    fprintf_filtered (stream, _(", and "));
d1753 1
a1753 5
	  data = locexpr_describe_location_piece (symbol, stream, addr, objfile,
						  data, size, addr_size);
	  piece_done = 1;
	}
      else if (data[0] == DW_OP_piece)
d1755 1
a1755 1
	  ULONGEST bytes;
d1757 18
a1774 1
	  data = read_uleb128 (data + 1, end, &bytes);
d1776 2
a1777 1
	  fprintf_filtered (stream, _(" [%s-byte piece]"), pulongest (bytes));
d1779 14
a1792 6
	  piece_done = 0;
	}
      else
	{
	  bad = 1;
	  break;
d1811 1
d1814 1
a1814 1
			       objfile, addr_size);
d1898 1
d1908 1
a1908 1
  fprintf_filtered (stream, _("multi-location ("));
d1925 1
a1925 1
	  fprintf_filtered (stream, _("[base address %s]"),
d1936 1
a1936 5
	{
	  /* Indicate the end of the list, for readability.  */
	  fprintf_filtered (stream, _(")"));
	  return;
	}
a1944 6
      /* Separate the different locations with a semicolon.  */
      if (first)
	first = 0;
      else
	fprintf_filtered (stream, _("; "));

d1947 1
a1947 1
      fprintf_filtered (stream, _("range %s-%s, "),
d1952 3
a1954 1
				   objfile, addr_size);
@


1.83
log
@	* dwarf2loc.h (struct dwarf2_locexpr_baton) <data>: Now const.
	(struct dwarf2_loclist_baton) <data>: Likewise.
	* dwarf2loc.c (find_location_expression): Constify return type.
	(dwarf2_evaluate_loc_desc): Make 'data' argument const.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(loclist_read_variable): Constify.
	(loclist_describe_location): Likewise.
	(loclist_tracepoint_var_ref): Likewise.
@
text
@d234 3
d256 1
d754 2
a755 1
  return allocate_piece_closure (c->n_pieces, c->pieces, c->addr_size);
d763 6
a768 2
  xfree (c->pieces);
  xfree (c);
@


1.82
log
@	* dwarf2loc.c (dwarf_expr_frame_base): Constify.
	(dwarf_expr_frame_base_1): Likewise.
	(read_pieced_value): Update.
	(needs_frame_frame_base): Constify.
	(dwarf2_tracepoint_var_loc): Likewise.
	(dwarf2_tracepoint_var_access): Likewise.
	(locexpr_describe_location_piece): Likewise.
	(locexpr_describe_location_1): Likewise.
	* dwarf2expr.h (struct dwarf_expr_context) <get_frame_base>:
	Constify.
	(data): Now const.
	(struct dwarf_expr_piece) <v.literal.data>: Likewise.
	(dwarf_expr_eval, read_uleb128, read_sleb128)
	(dwarf2_read_address): Update.
	* dwarf2expr.c (dwarf_expr_eval): Constify.
	(read_uleb128): Likewise.
	(read_sleb128): Likewise.
	(dwarf2_read_address): Likewise.
	(require_composition): Likewise.
	(execute_stack_op): Likewise.
	* dwarf2-frame.h (struct dwarf2_frame_state_reg) <loc.exp>: Now a
	"const gdb_byte *".
	* dwarf2-frame.c (struct dwarf2_frame_state_reg_info) <cfa_exp>:
	Now const.
	(no_get_frame_base): Constify.
	(execute_stack_op): Likewise.
	(execute_cfa_program): Likewise.
	(read_encoded_value): Likewise.
@
text
@d57 1
a57 1
static gdb_byte *
d62 1
a62 1
  gdb_byte *loc_ptr, *buf_end;
d776 1
a776 1
			  gdb_byte *data, unsigned short size,
d956 1
a956 1
dwarf2_loc_desc_needs_frame (gdb_byte *data, unsigned short size,
d1518 1
a1518 1
  gdb_byte *data;
d1560 1
a1560 1
  gdb_byte *loc_ptr, *buf_end;
d1642 1
a1642 1
  gdb_byte *data;
@


1.81
log
@gdb
	* dwarf2loc.c (extract_bits_primitive): New function.
	(extract_bits): Likewise.
	(insert_bits): Likewise.
	(copy_bitwise): Likewise.
	(read_pieced_value): Do all operations in bits.
	(write_pieced_value): Likewise.
	* dwarf2expr.h (struct dwarf_expr_piece) <offset>: New field.
	* dwarf2expr.c (add_piece): New arguments bit_piece, offset.
	Always use xrealloc to resize piece array.
	(execute_stack_op) <DW_OP_reg0>: Handle DW_OP_bit_piece.
	<DW_OP_piece>: Update.
	<DW_OP_bit_piece>: New case.
gdb/testsuite
	* gdb.dwarf2/pieces.exp (pieces_test_f3): New proc.
	Call it.
	* gdb.dwarf2/pieces.S: Update.
	* gdb.dwarf2/pieces.c (struct B): Remove initial field.
@
text
@d47 1
a47 1
			 gdb_byte **start, size_t *length);
d156 1
a156 1
dwarf_expr_frame_base (void *baton, gdb_byte **start, size_t * length)
d181 1
a181 1
			 gdb_byte **start, size_t *length)
d466 1
a466 1
      gdb_byte *intermediate_buffer;
d920 1
a920 1
needs_frame_frame_base (void *baton, gdb_byte **start, size_t * length)
d1020 1
a1020 1
static gdb_byte *
d1025 1
a1025 1
			   gdb_byte *data, gdb_byte *end)
d1047 1
a1047 1
      gdb_byte *base_data;
d1066 2
a1067 2
	  gdb_byte *buf_end;
	  
d1146 1
a1146 1
			   gdb_byte *data, int size)
d1148 1
a1148 1
  gdb_byte *end = data + size;
d1288 1
a1288 1
static gdb_byte *
d1291 2
a1292 1
				 gdb_byte *data, int size, unsigned int addr_size)
d1319 1
a1319 1
      gdb_byte *base_data;
d1339 1
a1339 1
	  gdb_byte *buf_end;
d1426 2
a1427 1
			     struct ui_file *stream, gdb_byte *data, int size,
d1430 1
a1430 1
  gdb_byte *end = data + size;
@


1.80
log
@gdb
	* dwarf2loc.c (read_pieced_value): Exit loop when result is full.
	<DWARF_VALUE_OPTIMIZED_OUT>: New case.
	* dwarf2expr.h (enum dwarf_value_location)
	<DWARF_VALUE_OPTIMIZED_OUT>: New constant.
	* dwarf2expr.c (dwarf_expr_stack_empty_p): New function.
	(add_piece): Handle empty piece.
	(execute_stack_op) <DW_OP_piece>: Handle
	DWARF_VALUE_OPTIMIZED_OUT.
gdb/testsuite
	* gdb.dwarf2/pieces.exp (pieces_test_f6): New proc.
	Call it.
	* gdb.dwarf2/pieces.c (struct C): New.
	(f6): New function.
	* gdb.dwarf2/pieces.S: Replace.
@
text
@d262 172
d439 1
a439 1
  ULONGEST bytes_to_skip;
d444 5
d455 2
d458 3
a460 2
  bytes_to_skip = value_offset (v);
  type_len = TYPE_LENGTH (value_type (v));
d464 8
a471 4
      size_t this_size;
      long dest_offset, source_offset;

      if (bytes_to_skip > 0 && bytes_to_skip >= p->size)
d473 1
a473 1
	  bytes_to_skip -= p->size;
d476 8
a483 9
      this_size = p->size;
      if (this_size > type_len - offset)
	this_size = type_len - offset;
      if (bytes_to_skip > 0)
	{
	  dest_offset = 0;
	  source_offset = bytes_to_skip;
	  this_size -= bytes_to_skip;
	  bytes_to_skip = 0;
d487 10
a496 2
	  dest_offset = offset;
	  source_offset = 0;
d498 1
d500 1
d512 7
a518 2
	      /* Big-endian, and we want less than full size.  */
	      reg_offset = register_size (arch, gdb_regnum) - this_size;
d523 1
a523 1
					  this_size, contents + dest_offset);
d535 1
a535 2
	    read_stack (p->v.expr.value + source_offset,
			contents + dest_offset, this_size);
d537 1
a537 2
	    read_memory (p->v.expr.value + source_offset,
			 contents + dest_offset, this_size);
d554 1
a554 1
	      store_unsigned_integer (contents + dest_offset, n,
d564 1
a564 1
		memcpy (contents + dest_offset, bytes + source_offset, n);
d578 1
a578 2
	      memcpy (contents + dest_offset,
		      p->v.literal.data + source_offset, n);
d586 1
a586 1
	  warning (_("bytes %ld-%ld in computed object were optimized out; "
d589 1
a589 1
		   offset + (long) this_size);
d595 7
a601 1
      offset += this_size;
d603 2
d612 1
a612 1
  ULONGEST bytes_to_skip;
d617 5
d629 2
d632 2
a633 2
  bytes_to_skip = value_offset (to);
  type_len = TYPE_LENGTH (value_type (to));
d637 4
a640 2
      size_t this_size;
      long dest_offset, source_offset;
d642 2
a643 1
      if (bytes_to_skip > 0 && bytes_to_skip >= p->size)
d645 1
a645 1
	  bytes_to_skip -= p->size;
d648 22
a669 9
      this_size = p->size;
      if (this_size > type_len - offset)
	this_size = type_len - offset;
      if (bytes_to_skip > 0)
	{
	  dest_offset = bytes_to_skip;
	  source_offset = 0;
	  this_size -= bytes_to_skip;
	  bytes_to_skip = 0;
d673 7
a679 2
	  dest_offset = 0;
	  source_offset = offset;
d697 10
d708 1
a708 1
					  this_size, contents + source_offset);
d718 13
d732 1
a732 1
			contents + source_offset, this_size);
d736 1
a736 1
	  return;
d738 1
a738 1
      offset += this_size;
d740 3
@


1.79
log
@gdb
	* dwarf2loc.c (read_pieced_value): Work properly when 'v' has an
	offset.
	(write_pieced_value): Likewise.
gdb/testsuite
	* gdb.dwarf2.pieces.exp: New file.
	* gdb.dwarf2.pieces.S: New file.
	* gdb.dwarf2.pieces.c: New file.
@
text
@d387 10
d622 3
@


1.78
log
@2010-05-14  Michael Snyder  <msnyder@@vmware.com>

	* dbxread.c: White space.
	* dcache.c: White space.
	* disasm.c: White space.
	* doublest.c: White space.
	* dsrec.c: White space.
	* dummy-frame.c: White space.
	* dwarf2expr.c: White space.
	* dwarf2-frame.c: White space.
	* dwarf2loc.c: White space.
	* dwarf2read.c: White space.
@
text
@d267 1
d271 6
d279 3
a281 1
  for (i = 0; i < c->n_pieces; i++)
d284 23
d315 1
a315 1
	    int reg_offset = 0;
d318 1
a318 1
		&& p->size < register_size (arch, gdb_regnum))
d320 1
a320 1
	      reg_offset = register_size (arch, gdb_regnum) - p->size;
d325 1
a325 1
					  p->size, contents + offset);
d337 2
a338 1
	    read_stack (p->v.expr.value, contents + offset, p->size);
d340 2
a341 1
	    read_memory (p->v.expr.value, contents + offset, p->size);
d347 17
a363 1
	    size_t n = p->size;
d365 5
a369 5
	    if (n > c->addr_size)
	      n = c->addr_size;
	    store_unsigned_integer (contents + offset, n,
				    gdbarch_byte_order (gdbarch),
				    p->v.expr.value);
d375 1
a375 1
	    size_t n = p->size;
d377 7
a383 3
	    if (n > p->v.literal.length)
	      n = p->v.literal.length;
	    memcpy (contents + offset, p->v.literal.data, n);
d390 1
a390 1
      offset += p->size;
d399 2
a400 1
  gdb_byte *contents;
d403 1
d411 4
a414 2
  contents = value_contents_raw (from);
  for (i = 0; i < c->n_pieces; i++)
d417 23
d447 1
a447 1
	    int reg_offset = 0;
d450 1
a450 1
		&& p->size < register_size (arch, gdb_regnum))
d452 1
a452 1
	      reg_offset = register_size (arch, gdb_regnum) - p->size;
d457 1
a457 1
					  p->size, contents + offset);
d467 2
a468 1
	  write_memory (p->v.expr.value, contents + offset, p->size);
d474 1
a474 1
      offset += p->size;
@


1.77
log
@gdb/
	Code cleanup.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Change the parameter to type.
	(locexpr_read_variable, loclist_read_variable): Update the callers.
@
text
@d195 1
d218 1
d275 1
d314 1
d326 1
d359 1
d478 1
d554 1
d585 1
d595 1
d684 1
d916 1
d928 1
d1053 1
@


1.76
log
@	* gdb/dwarf2loc.c (read_pieced_value, write_pieced_value,
	dwarf2_evaluate_loc_desc): Handle not being able to access DWARF
	registers gracefully.
@
text
@d416 1
a416 1
   SIZE, to find the current location of variable VAR in the context
d418 1
d420 1
a420 1
dwarf2_evaluate_loc_desc (struct symbol *var, struct frame_info *frame,
d431 1
a431 1
      retval = allocate_value (SYMBOL_TYPE (var));
d460 1
a460 3
      retval = allocate_computed_value (SYMBOL_TYPE (var),
					&pieced_value_funcs,
					c);
d473 1
a473 4
	      {
		retval = value_from_register (SYMBOL_TYPE (var),
					      gdb_regnum, frame);
	      }
d475 2
a476 4
	      {
		error (_("Unable to access DWARF register number %s"),
		       paddress (arch, dwarf_regnum));
	      }
d485 1
a485 1
	    retval = allocate_value (SYMBOL_TYPE (var));
d500 1
a500 1
	    retval = allocate_value (SYMBOL_TYPE (var));
d502 2
a503 2
	    if (n > TYPE_LENGTH (SYMBOL_TYPE (var)))
	      n = TYPE_LENGTH (SYMBOL_TYPE (var));
d515 1
a515 1
	    retval = allocate_value (SYMBOL_TYPE (var));
d517 2
a518 2
	    if (n > TYPE_LENGTH (SYMBOL_TYPE (var)))
	      n = TYPE_LENGTH (SYMBOL_TYPE (var));
d905 2
a906 2
  val = dwarf2_evaluate_loc_desc (symbol, frame, dlbaton->data, dlbaton->size,
				  dlbaton->per_cu);
d1163 1
a1163 1
    val = dwarf2_evaluate_loc_desc (symbol, frame, data, size,
@


1.75
log
@2010-04-20  Stan Shebs  <stan@@codesourcery.com>
	    Nathan Sidwell  <nathan@@codesourcery.com>

	* dwarf2loc.c (struct axs_var_loc): New struct.
	(dwarf2_tracepoint_var_loc): New function.
	(dwarf2_tracepoint_var_access): New function.
	(dwarf2_tracepoint_var_ref): Use dwarf2_tracepoint_var_loc, deal
	with DW_OP_piece.
	(locexpr_describe_location_piece): New function.
	(locexpr_describe_location_1): New function.
	(locexpr_describe_location): Call it, update signature.
	(loclist_describe_location): Rewrite to loop over locations,
	update signature.
	* symtab.h (struct symbol_computed_ops): Add address to
	describe_location arguments, return void.
	* printcmd.c (address_info): Get context PC, pass to computed
	location description.
	* tracepoint.c (scope_info): Ditto.
	* ax-gdb.c (trace_kludge): Export.
@
text
@d287 10
a296 2
	    get_frame_register_bytes (frame, gdb_regnum, reg_offset, p->size,
				      contents + offset);
d367 10
a376 2
	    put_frame_register_bytes (frame, gdb_regnum, reg_offset, p->size,
				      contents + offset);
d473 10
a482 1
	    retval = value_from_register (SYMBOL_TYPE (var), gdb_regnum, frame);
@


1.74
log
@2010-03-17 Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.h (struct axs_value): New field optimized_out.
	(gen_trace_for_var): Add gdbarch argument.
	* ax-gdb.c (gen_trace_static_fields): New function.
	(gen_traced_pop): Call it, add gdbarch argument.
	(gen_trace_for_expr): Update call to it.
	(gen_trace_for_var): Ditto, and report optimized-out variables.
	(gen_struct_ref_recursive): Check for optimized-out value.
	(gen_struct_elt_for_reference): Ditto.
	(gen_static_field): Pass gdbarch instead of expression, assume
	optimization if field not found.
	(gen_var_ref): Set the optimized_out flag.
	(gen_expr): Error on optimized-out variable.
	* tracepoint.c (collect_symbol): Handle struct-valued vars as
	expressions, skip optimized-out variables with computed locations.
	* dwarf2loc.c (dwarf2_tracepoint_var_ref): Flag instead of
	erroring out if location expression missing.
	(loclist_tracepoint_var_ref): Don't error out here.
@
text
@d617 28
a644 4
static void
dwarf2_tracepoint_var_ref (struct symbol *symbol, struct gdbarch *gdbarch,
			   struct agent_expr *ax, struct axs_value *value,
			   gdb_byte *data, int size)
d646 1
a646 1
  if (!data || size == 0)
d648 3
a650 8
      value->optimized_out = 1;
    }
  else if (size == 1
      && data[0] >= DW_OP_reg0
      && data[0] <= DW_OP_reg31)
    {
      value->kind = axs_lvalue_register;
      value->u.reg = data[0] - DW_OP_reg0;
d655 3
a657 3
      read_uleb128 (data + 1, data + size, &reg);
      value->kind = axs_lvalue_register;
      value->u.reg = reg;
a664 1
      gdb_byte *buf_end;
d682 1
a682 2
      if (base_data[0] >= DW_OP_breg0
	   && base_data[0] <= DW_OP_breg31)
d684 2
d687 2
a688 1
	  buf_end = read_sleb128 (base_data + 1, base_data + base_size, &base_offset);
d693 6
d703 2
a704 2
	  error (_("Cannot generate expression to collect symbol \"%s\"; DWARF 2 encoding not handled"),
		 SYMBOL_PRINT_NAME (symbol));
d707 1
a707 4
      buf_end = read_sleb128 (data + 1, data + size, &frame_offset);
      if (buf_end != data + size)
	error (_("Unexpected opcode after DW_OP_fbreg for symbol \"%s\"."),
	       SYMBOL_PRINT_NAME (symbol));
d709 3
a711 5
      ax_reg (ax, frame_reg);
      ax_const_l (ax, base_offset + frame_offset);
      ax_simple (ax, aop_add);

      value->kind = axs_lvalue_memory;
d713 1
a713 2
  else if (data[0] >= DW_OP_breg0
	   && data[0] <= DW_OP_breg31)
a716 1
      gdb_byte *buf_end;
d719 1
a719 8
      buf_end = read_sleb128 (data + 1, data + size, &offset);
      if (buf_end != data + size)
	error (_("Unexpected opcode after DW_OP_breg%u for symbol \"%s\"."),
	       reg, SYMBOL_PRINT_NAME (symbol));

      ax_reg (ax, reg);
      ax_const_l (ax, offset);
      ax_simple (ax, aop_add);
d721 3
a723 1
      value->kind = axs_lvalue_memory;
d728 2
d731 147
d901 7
a907 3
/* Print a natural-language description of SYMBOL to STREAM.  */
static int
locexpr_describe_location (struct symbol *symbol, struct ui_file *stream)
d909 85
a993 3
  /* FIXME: be more extensive.  */
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);
a994 8
  if (dlbaton->size == 1
      && dlbaton->data[0] >= DW_OP_reg0
      && dlbaton->data[0] <= DW_OP_reg31)
    {
      struct objfile *objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);
      struct gdbarch *gdbarch = get_objfile_arch (objfile);
      int regno = gdbarch_dwarf2_reg_to_regnum (gdbarch,
						dlbaton->data[0] - DW_OP_reg0);
d996 2
a997 1
			"a variable in register %s",
a998 1
      return 1;
d1013 64
a1076 17
  if (dlbaton->size > 1 
      && dlbaton->data[dlbaton->size - 1] == DW_OP_GNU_push_tls_address)
    if (dlbaton->data[0] == DW_OP_addr)
      {
	struct objfile *objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);
	struct gdbarch *gdbarch = get_objfile_arch (objfile);
	CORE_ADDR offset = dwarf2_read_address (gdbarch,
						&dlbaton->data[1],
						&dlbaton->data[dlbaton->size - 1],
						addr_size);
	fprintf_filtered (stream, 
			  "a thread-local variable at offset %s in the "
			  "thread-local storage for `%s'",
			  paddress (gdbarch, offset), objfile->name);
	return 1;
      }
  
d1078 3
a1080 3
  fprintf_filtered (stream,
		    "a variable with complex or multiple locations (DWARF2)");
  return 1;
d1083 14
d1099 1
a1099 6
   any necessary bytecode in AX.

   NOTE drow/2003-02-26: This function is extremely minimal, because
   doing it correctly is extremely complicated and there is no
   publicly available stub with tracepoint support for me to test
   against.  When there is one this function should be revisited.  */
d1163 7
a1169 3
/* Print a natural-language description of SYMBOL to STREAM.  */
static int
loclist_describe_location (struct symbol *symbol, struct ui_file *stream)
d1171 75
a1245 3
  /* FIXME: Could print the entire list of locations.  */
  fprintf_filtered (stream, "a variable with multiple locations");
  return 1;
@


1.73
log
@	* dwarf2loc.c (struct piece_closure): Remove ARCH member,
	add ADDR_SIZE member.
	(allocate_piece_closure): Update.
	(copy_pieced_value_closure): Likewise.
	(dwarf2_evaluate_loc_desc): Likewise.
	(read_pieced_value): Use DWARF address size instead of
	GDB's gdbarch_addr_bit as size of values on the DWARF stack.
@
text
@d622 5
a626 5
  if (size == 0)
    error (_("Symbol \"%s\" has been optimized out."),
	   SYMBOL_PRINT_NAME (symbol));

  if (size == 1
a885 2
  if (data == NULL)
    error (_("Variable \"%s\" is not available."), SYMBOL_NATURAL_NAME (symbol));
@


1.72
log
@	* dwarf2loc.c (read_pieced_value) <DWARF_VALUE_STACK>: Correctly
	handle big-endian values.
	(dwarf2_evaluate_loc_desc) <DWARF_VALUE_STACK>: Likewise.
@
text
@d235 2
a236 2
  /* The architecture, used only for DWARF_VALUE_STACK.  */
  struct gdbarch *arch;
d247 1
a247 1
			struct gdbarch *arch)
d252 1
a252 1
  c->arch = arch;
d301 4
a304 5
	    size_t n;
	    int addr_size = gdbarch_addr_bit (c->arch) / 8;
	    n = p->size;
	    if (n > addr_size)
	      n = addr_size;
d306 1
a306 1
				    gdbarch_byte_order (c->arch),
d379 1
a379 1
  return allocate_piece_closure (c->n_pieces, c->pieces, c->arch);
d441 2
a442 1
      c = allocate_piece_closure (ctx->num_pieces, ctx->pieces, ctx->gdbarch);
@


1.71
log
@	* dwarf2loc.c (read_pieced_value): If a piece occupies part of
	a register, assume the least-signficant part is used.
	(write_pieced_value): Likewise.
@
text
@a300 1
	    gdb_byte bytes[sizeof (ULONGEST)];
a302 3
	    store_unsigned_integer (bytes, addr_size,
				    gdbarch_byte_order (c->arch),
				    p->v.expr.value);
d306 3
a308 1
	    memcpy (contents + offset, bytes, n);
a476 1
	    gdb_byte bytes[sizeof (ULONGEST)];
a480 3
	    store_unsigned_integer (bytes, ctx->addr_size,
				    gdbarch_byte_order (ctx->gdbarch),
				    value);
d485 3
a487 1
	    memcpy (contents, bytes, n);
@


1.71.2.1
log
@	* dwarf2loc.c (read_pieced_value) <DWARF_VALUE_STACK>: Correctly
	handle big-endian values.
	(dwarf2_evaluate_loc_desc) <DWARF_VALUE_STACK>: Likewise.
@
text
@d301 1
d304 3
d310 1
a310 3
	    store_unsigned_integer (contents + offset, n,
				    gdbarch_byte_order (c->arch),
				    p->v.expr.value);
d479 1
d484 3
d491 1
a491 3
	    store_unsigned_integer (contents, n,
				    gdbarch_byte_order (ctx->gdbarch),
				    value);
@


1.70
log
@Update copyright year in most headers.

Automatic update by copyright.sh.
@
text
@a277 1
	    bfd_byte regval[MAX_REGISTER_SIZE];
d280 9
a288 2
	    get_frame_register (frame, gdb_regnum, regval);
	    memcpy (contents + offset, regval, p->size);
d355 9
a363 1
	    put_frame_register (frame, gdb_regnum, contents + offset);
@


1.69
log
@2009-12-23  Stan Shebs  <stan@@codesourcery.com>

	* ax-gdb.h (gen_trace_for_var): Declare.
	* ax-gdb.c (gen_trace_for_var): New function.
	* dwarf2loc.c (dwarf_expr_frame_base_1): New function, split from...
	(dwarf_expr_frame_base): ...here.
	(dwarf2_tracepoint_var_ref): Add computed location case.
	* tracepoint.c (collect_symbol): Add scope arg and LOC_COMPUTED
	case.
	(add_local_symbols): Update call to collect_symbol.
	(encode_actions): Ditto.
@
text
@d3 2
a4 1
   Copyright (C) 2003, 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.68
log
@	* dwarf2expr.h (dwarf_value_location): Add more comments describing
	enum values.
	(struct dwarf_stack_value): New struct.
	(struct dwarf_expr_context): Change type of `stack' from CORE_ADDR*
	to struct dwarf_stack_value*.
	(struct dwarf_expr_piece): Move `v.value' into its own struct, v.expr,
	all uses updated.  Add v.expr.in_stack_memory.
	(dwarf_expr_push): Update declaration.
	(dwarf_expr_fetch_in_stack_memory): Declare.
	* dwarf2expr.c (dwarf_expr_grow_stack): Update calculation of
	size of stack value.
	(dwarf_expr_push): New arg in_stack_memory, all callers updated.
	(dwarf_expr_fetch_in_stack_memory): New function.
	(add_piece): Set in_stack_memory for non-literal values.
	(execute_stack_op): Allow ops to specify whether the value is on the
	program's stack.
	(execute_stack_op, case DW_OP_fbreg): Mark value as in stack memory.
	(execute_stack_op, case DW_OP_call_frame_cfa): Ditto.
	(execute_stack_op, case DW_OP_dup): Copy in_stack_memory flag.
	(execute_stack_op, cases DW_OP_pick, DW_OP_over): Ditto.
	(execute_stack_op, cases DW_OP_swap, DW_OP_rot): Update type of
	dwarf stack value.
	* dwarf2loc.c (read_pieced_value): Call read_stack for values known
	to be on the program's stack.
	(dwarf2_evaluate_loc_desc, case DWARF_VALUE_MEMORY): Call
	set_value_stack only for objects known to be in stack memory.
	* dwarf2-frame.c (execute_stack_op): New arg initial_in_stack_memory,
	all callers updated.
@
text
@d44 4
d173 9
a186 1
      struct frame_info *frame = debaton->frame;
d189 1
a189 2
      *start = find_location_expression (symbaton, length,
					 get_frame_address_in_block (frame));
d631 3
a633 3
      /* And this is worse than just minimal; we should honor the frame base
	 as above.  */
      int frame_reg;
d636 33
a674 2
      gdbarch_virtual_frame_pointer (gdbarch,
				     ax->scope, &frame_reg, &frame_offset);
d676 1
a676 1
      ax_const_l (ax, frame_offset);
@


1.67
log
@gdb
	* dwarf2loc.c (struct piece_closure) <arch>: New field.
	(dwarf2_evaluate_loc_desc): Update.
	(dwarf2_loc_desc_needs_frame): Likewise.
	(allocate_piece_closure): Initialize new field.
	(read_pieced_value): Update.
	(write_pieced_value): Update.
	(copy_pieced_value_closure): Update.
	* dwarf2expr.h (enum dwarf_value_location): New.
	(struct dwarf_expr_context) <in_reg>: Remove.
	<location, len, data>: New fields.
	(struct dwarf_expr_piece) <in_reg, value>: Remove.
	<location, v>: New fields.
	* dwarf2expr.c (add_piece): Remove in_reg, value arguments.
	Update.
	(require_composition): New function.
	(execute_stack_op): Update.
	<DW_OP_implicit_value, DW_OP_stack_value>: New cases.
	<DW_OP_reg0>: Set location, not in_reg.
	<DW_OP_regx>: Likewise.  Use require_composition.
	<DW_OP_fbreg>: Update.
	<DW_OP_piece>: Likewise.
	* dwarf2-frame.c (execute_stack_op): Update.
gdb/testsuite
	* gdb.dwarf2/valop.S: New file.
	* gdb.dwarf2/valop.exp: New file.
@
text
@d268 1
a268 1
							   p->v.value);
d275 4
a278 1
	  read_memory (p->v.value, contents + offset, p->size);
d288 1
a288 1
				    p->v.value);
d336 1
a336 1
	    int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->v.value);
d341 1
a341 1
	  write_memory (p->v.value, contents + offset, p->size);
d440 1
d445 2
a446 1
	    set_value_stack (retval, 1);
a492 4




@


1.66
log
@	* dwarf2loc.c (struct piece_closure): New.
	(allocate_piece_closure): New function.
	(read_pieced_value): New function.
	(write_pieced_value): New function.
	(copy_pieced_value_closure): New function.
	(free_pieced_value_closure): New function.
	(pieced_value_funcs): Define.
	(dwarf2_evaluate_loc_desc): Return a computed value for a variable
	described with pieces.
@
text
@d223 3
d234 2
a235 1
allocate_piece_closure (int n_pieces, struct dwarf_expr_piece *pieces)
d240 1
d261 1
a261 7

      if (frame == NULL)
	{
	  memset (contents + offset, 0, p->size);
	  set_value_optimized_out (v, 1);
	}
      else if (p->in_reg)
d263 38
a300 3
	  struct gdbarch *arch = get_frame_arch (frame);
	  gdb_byte regval[MAX_REGISTER_SIZE];
	  int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->value);
d302 2
a303 6
	  get_frame_register (frame, gdb_regnum, regval);
	  memcpy (contents + offset, regval, p->size);
	}
      else
	{
	  read_memory (p->value, contents + offset, p->size);
d328 1
a328 1
      if (p->in_reg)
d330 13
a342 7
	  struct gdbarch *arch = get_frame_arch (frame);
	  int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->value);
	  put_frame_register (frame, gdb_regnum, contents + offset);
	}
      else
	{
	  write_memory (p->value, contents + offset, p->size);
d353 1
a353 1
  return allocate_piece_closure (c->n_pieces, c->pieces);
d415 1
a415 1
      c = allocate_piece_closure (ctx->num_pieces, ctx->pieces);
a420 7
  else if (ctx->in_reg)
    {
      struct gdbarch *arch = get_frame_arch (frame);
      CORE_ADDR dwarf_regnum = dwarf_expr_fetch (ctx, 0);
      int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, dwarf_regnum);
      retval = value_from_register (SYMBOL_TYPE (var), gdb_regnum, frame);
    }
d423 53
a475 1
      CORE_ADDR address = dwarf_expr_fetch (ctx, 0);
d477 3
a479 5
      retval = allocate_value (SYMBOL_TYPE (var));
      VALUE_LVAL (retval) = lval_memory;
      set_value_lazy (retval, 1);
      set_value_stack (retval, 1);
      set_value_address (retval, address);
d576 1
a576 1
  in_reg = ctx->in_reg;
d585 1
a585 1
        if (ctx->pieces[i].in_reg)
@


1.65
log
@gdb
	* frame.h (frame_unwinder_is): Declare.
	* frame.c (frame_unwinder_is): New function.
	* dwarf2loc.c: Include dwarf2-frame.h.
	(dwarf_expr_frame_cfa): New function.
	(dwarf2_evaluate_loc_desc): Use it.
	(needs_frame_frame_cfa): New function.
	(dwarf2_loc_desc_needs_frame): Use it.
	* dwarf2expr.h (struct dwarf_expr_context) <get_frame_cfa>: New
	field.
	* dwarf2expr.c (execute_stack_op) <DW_OP_call_frame_cfa>: New
	case.
	* dwarf2-frame.h (dwarf2_frame_cfa): Declare.
	* dwarf2-frame.c (no_get_frame_cfa): New function.
	(execute_stack_op): Use it.
	(dwarf2_frame_cfa): New function.
gdb/testsuite
	* gdb.dwarf2/callframecfa.exp: New file.
	* gdb.dwarf2/callframecfa.S: New file.
@
text
@d218 119
d376 2
a377 3
      int i;
      long offset = 0;
      bfd_byte *contents;
d379 5
a383 19
      retval = allocate_value (SYMBOL_TYPE (var));
      contents = value_contents_raw (retval);
      for (i = 0; i < ctx->num_pieces; i++)
	{
	  struct dwarf_expr_piece *p = &ctx->pieces[i];
	  if (p->in_reg)
	    {
	      struct gdbarch *arch = get_frame_arch (frame);
	      bfd_byte regval[MAX_REGISTER_SIZE];
	      int gdb_regnum = gdbarch_dwarf2_reg_to_regnum (arch, p->value);
	      get_frame_register (frame, gdb_regnum, regval);
	      memcpy (contents + offset, regval, p->size);
	    }
	  else /* In memory?  */
	    {
	      read_memory (p->value, contents + offset, p->size);
	    }
	  offset += p->size;
	}
@


1.64
log
@	Implement TARGET_OBJECT_STACK_MEMORY.
	* NEWS: Add note on new "set stack-cache" option.
	* corefile.c (read_stack): New function.
	* dcache.c (dcache_struct): New member ptid.
	(dcache_enable_p): Mark as obsolete.
	(show_dcache_enabled_p): Flag option as deprecated.
	(dcache_invalidate): Update ptid.
	(dcache_invalidate_line): New function.
	(dcache_read_line): No longer check cacheable attribute, stack
	accesses get cached despite attribute.
	(dcache_init): Set ptid.
	(dcache_xfer_memory): Flush cache if from different ptid than before.
	Update cache after write.
	(dcache_update): New function.
	(dcache_info): Report ptid.
	(_initialize_dcache): Update text for `remotecache' to indicate it
	is obsolete.
	* dcache.h (dcache_update): Declare.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Mark values on stack with
	set_value_stack.
	* frame-unwind.c (frame_unwind_got_memory): Ditto.
	* gdbcore.h (read_stack): Declare.
	* memattr.c (mem_enable_command): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(mem_disable_command, mem_delete_command): Ditto.
	* target.c (stack_cache_enabled_p_1): New static global.
	(stack_cache_enabled_p): New static global.
	(set_stack_cache_enabled_p): New function.
	(show_stack_cache_enabled_p): New function.
	(target_dcache): Make static.
	(target_dcache_invalidate): New function.
	(target_load, target_resume): Call target_dcache_invalidate
	instead of dcache_invalidate.
	(memory_xfer_partial): New arg object, all callers updated.
	Check for existing inferior before calling dcache routines.
	When writing non-TARGET_OBJECT_STACK_MEMORY, notify dcache.
	(target_xfer_partial): Call memory_xfer_partial for
	TARGET_OBJECT_STACK_MEMORY.
	(target_read_stack): New function.
	(initialize_targets): Install new option `stack-cache'.
	* target.h: Remove #include of dcache.h.
	(enum target_object): New value TARGET_OBJECT_STACK_MEMORY.
	(target_dcache): Delete.
	(target_dcache_invalidate): Declare.
	(target_read_stack): Declare.
	* top.c (prepare_execute_command): New function.
	(execute_command): Call prepare_execute_command
	instead of free_all_values.
	* top.h (prepare_execute_command): Declare.
	* valops.c (get_value_at): New function.
	(value_at): Guts moved to get_value_at.
	(value_at_lazy): Similarly.
	(value_fetch_lazy): Call read_stack for stack values.
	* value.c (struct value): New member `stack'.
	(value_stack, set_value_stack): New functions.
	* value.h (value_stack, set_value_stack): Declare.
	* mi/mi-main.c (mi_cmd_execute): Call prepare_execute_command
	instead of free_all_values.

	doc/
	* gdb.texinfo (Caching Data of Remote Targets): Update text.
	Mark `set/show remotecache' options as obsolete.
	Document new `set/show stack-cache' option.
	Update text for `info dcache'.
@
text
@d39 1
d198 10
d251 1
d346 10
d388 1
@


1.63
log
@	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Make a cleanup.
	(dwarf2_loc_desc_needs_frame): Likewise.
	* dwarf2expr.h (make_cleanup_free_dwarf_expr_context): Declare.
	* dwarf2expr.c (free_dwarf_expr_context_cleanup): New function.
	(make_cleanup_free_dwarf_expr_context): Likewise.
	* dwarf2-frame.c (execute_stack_op): Make a cleanup.
@
text
@d283 1
@


1.62
log
@	* dwarf2loc.c (find_location_expression): Retrieve beginning and
	ending address offsets in location list entries as integers,
	not as addresses.
@
text
@d218 1
d232 2
d288 1
a288 1
  free_dwarf_expr_context (ctx);
d352 1
d357 2
d382 1
a382 1
  free_dwarf_expr_context (ctx);
@


1.61
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d73 4
a76 1
      low = dwarf2_read_address (gdbarch, loc_ptr, buf_end, addr_size);
d78 11
a88 1
      high = dwarf2_read_address (gdbarch, loc_ptr, buf_end, addr_size);
a94 7
      /* A base-address-selection entry.  */
      if ((low & base_mask) == base_mask)
	{
	  base_address = high;
	  continue;
	}

@


1.60
log
@	* defs.h (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.
	* findvar.c (extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.

	* gdbcore.h (read_memory_integer, safe_read_memory_integer,
	read_memory_unsigned_integer, write_memory_signed_integer,
	write_memory_unsigned_integer): Add BYTE_ORDER parameter.
	* corefile.c (struct captured_read_memory_integer_arguments): Add
	BYTE_ORDER member.
	(safe_read_memory_integer): Add BYTE_ORDER parameter.  Store it into
	struct captured_read_memory_integer_arguments.
	(do_captured_read_memory_integer): Pass it to read_memory_integer.
	(read_memory_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_signed_integer.
	(read_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it to
	extract_unsigned_integer.
	(write_memory_signed_integer): Add BYTE_ORDER parameter.  Pass it
	to store_signed_integer.
	(write_memory_unsigned_integer): Add BYTE_ORDER parameter.  Pass it
	to store_unsigned_integer.

	* target.h (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	* target.c (get_target_memory_unsigned): Add BYTE_ORDER parameter.
	Pass it to extract_unsigned_integer.


	Update calls to extract_signed_integer, extract_unsigned_integer,
	extract_long_unsigned_integer, store_signed_integer,
	store_unsigned_integer, read_memory_integer,
	read_memory_unsigned_integer, safe_read_memory_integer,
	write_memory_signed_integer, write_memory_unsigned_integer, and
	get_target_memory_unsigned to pass byte order:
	* ada-lang.c (ada_value_binop): Update.
	* ada-valprint.c (char_at): Update.
	* alpha-osf1-tdep.c (alpha_osf1_sigcontext_addr): Update.
	* alpha-tdep.c (alpha_lds, alpha_sts, alpha_push_dummy_call,
	alpha_extract_return_value, alpha_read_insn,
	alpha_get_longjmp_target): Update.
	* amd64-linux-tdep.c (amd64_linux_sigcontext_addr): Update.
	* amd64obsd-tdep.c (amd64obsd_supply_uthread,
	amd64obsd_collect_uthread, amd64obsd_trapframe_cache): Update.
	* amd64-tdep.c (amd64_push_dummy_call, amd64_analyze_prologue,
	amd64_frame_cache, amd64_sigtramp_frame_cache, fixup_riprel,
	amd64_displaced_step_fixup): Update.
	* arm-linux-tdep.c (arm_linux_sigreturn_init,
	arm_linux_rt_sigreturn_init, arm_linux_supply_gregset): Update.
	* arm-tdep.c (thumb_analyze_prologue, arm_skip_prologue,
	arm_scan_prologue, arm_push_dummy_call, thumb_get_next_pc,
	arm_get_next_pc, arm_extract_return_value, arm_store_return_value,
	arm_return_value): Update.
	* arm-wince-tdep.c (arm_pe_skip_trampoline_code): Update.
	* auxv.c (default_auxv_parse): Update.
	* avr-tdep.c (avr_address_to_pointer, avr_pointer_to_address,
	avr_scan_prologue, avr_extract_return_value,
	avr_frame_prev_register, avr_push_dummy_call): Update.
	* bsd-uthread.c (bsd_uthread_check_magic, bsd_uthread_lookup_offset,
	bsd_uthread_wait, bsd_uthread_thread_alive,
	bsd_uthread_extra_thread_info): Update.
	* c-lang.c (c_printstr, print_wchar): Update.
	* cp-valprint.c (cp_print_class_member): Update.
	* cris-tdep.c (cris_sigcontext_addr, cris_sigtramp_frame_unwind_cache,
	cris_push_dummy_call, cris_scan_prologue, cris_store_return_value,
	cris_extract_return_value, find_step_target, dip_prefix,
	sixteen_bit_offset_branch_op, none_reg_mode_jump_op,
	move_mem_to_reg_movem_op, get_data_from_address): Update.
	* dwarf2expr.c (dwarf2_read_address, execute_stack_op): Update.
	* dwarf2-frame.c (execute_cfa_program): Update.
	* dwarf2loc.c (find_location_expression): Update.
	* dwarf2read.c (dwarf2_const_value): Update.
	* expprint.c (print_subexp_standard): Update.
	* findvar.c (unsigned_pointer_to_address, signed_pointer_to_address,
	unsigned_address_to_pointer, address_to_signed_pointer,
	read_var_value): Update.
	* frame.c (frame_unwind_register_signed,
	frame_unwind_register_unsigned, get_frame_memory_signed,
	get_frame_memory_unsigned): Update.
	* frame-unwind.c (frame_unwind_got_constant): Update.
	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp,
	frv_linux_sigcontext_reg_addr, frv_linux_sigtramp_frame_cache):
	Update.
	* frv-tdep.c (frv_analyze_prologue, frv_skip_main_prologue,
	frv_extract_return_value, find_func_descr,
	frv_convert_from_func_ptr_addr, frv_push_dummy_call): Update.
	* f-valprint.c (f_val_print): Update.
	* gnu-v3-abi.c (gnuv3_decode_method_ptr, gnuv3_make_method_ptr):
	Update.
	* h8300-tdep.c (h8300_is_argument_spill, h8300_analyze_prologue,
	h8300_push_dummy_call, h8300_extract_return_value,
	h8300h_extract_return_value, h8300_store_return_value,
	h8300h_store_return_value): Update.
	* hppabsd-tdep.c (hppabsd_find_global_pointer): Update.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register, hppa_hpux_store_register):
	Update.
	* hppa-hpux-tdep.c (hppa32_hpux_in_solib_call_trampoline,
	hppa64_hpux_in_solib_call_trampoline,
	hppa_hpux_in_solib_return_trampoline, hppa_hpux_skip_trampoline_code,
	hppa_hpux_sigtramp_frame_unwind_cache,
	hppa_hpux_sigtramp_unwind_sniffer, hppa32_hpux_find_global_pointer,
	hppa64_hpux_find_global_pointer, hppa_hpux_search_pattern,
	hppa32_hpux_search_dummy_call_sequence,
	hppa64_hpux_search_dummy_call_sequence, hppa_hpux_supply_save_state,
	hppa_hpux_unwind_adjust_stub): Update.
	* hppa-linux-tdep.c (insns_match_pattern,
	hppa_linux_find_global_pointer): Update.
	* hppa-tdep.c (hppa_in_function_epilogue_p, hppa32_push_dummy_call,
	hppa64_convert_code_addr_to_fptr, hppa64_push_dummy_call,
	skip_prologue_hard_way, hppa_frame_cache, hppa_fallback_frame_cache,
	hppa_pseudo_register_read, hppa_frame_prev_register_helper,
	hppa_match_insns): Update.
	* hpux-thread.c (hpux_thread_fetch_registers): Update.
	* i386-tdep.c (i386bsd_sigcontext_addr): Update.
	* i386-cygwin-tdep.c (core_process_module_section): Update.
	* i386-darwin-nat.c (i386_darwin_sstep_at_sigreturn,
	amd64_darwin_sstep_at_sigreturn): Update.
	* i386-darwin-tdep.c (i386_darwin_sigcontext_addr,
	amd64_darwin_sigcontext_addr): Likewise.
	* i386-linux-nat.c (i386_linux_sigcontext_addr): Update.
	* i386nbsd-tdep.c (i386nbsd_sigtramp_cache_init): Update.
	* i386-nto-tdep.c (i386nto_sigcontext_addr): Update.
	* i386obsd-nat.c (i386obsd_supply_pcb): Update.
	* i386obsd-tdep.c (i386obsd_supply_uthread, i386obsd_collect_uthread,
	i386obsd_trapframe_cache): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_follow_jump,
	i386_analyze_frame_setup, i386_analyze_prologue,
	i386_skip_main_prologue, i386_frame_cache, i386_sigtramp_frame_cache,
	i386_get_longjmp_target, i386_push_dummy_call,
	i386_pe_skip_trampoline_code, i386_svr4_sigcontext_addr,
	i386_fetch_pointer_argument): Update.
	* i387-tdep.c (i387_supply_fsave): Update.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Update.
	* ia64-tdep.c (ia64_pseudo_register_read, ia64_pseudo_register_write,
	examine_prologue, ia64_frame_cache, ia64_frame_prev_register,
	ia64_sigtramp_frame_cache, ia64_sigtramp_frame_prev_register,
	ia64_access_reg, ia64_access_rse_reg, ia64_libunwind_frame_this_id,
	ia64_libunwind_frame_prev_register,
	ia64_libunwind_sigtramp_frame_this_id,
	ia64_libunwind_sigtramp_frame_prev_register, ia64_find_global_pointer,
	find_extant_func_descr, find_func_descr,
	ia64_convert_from_func_ptr_addr, ia64_push_dummy_call, ia64_dummy_id,
	ia64_unwind_pc): Update.
	* iq2000-tdep.c (iq2000_pointer_to_address, iq2000_address_to_pointer,
	iq2000_scan_prologue, iq2000_extract_return_value,
	iq2000_push_dummy_call): Update.
	* irix5nat.c (fill_gregset): Update.
	* jv-lang.c (evaluate_subexp_java): Update.
	* jv-valprint.c (java_value_print): Update.
	* lm32-tdep.c (lm32_analyze_prologue, lm32_push_dummy_call,
	lm32_extract_return_value, lm32_store_return_value): Update.
	* m32c-tdep.c (m32c_push_dummy_call, m32c_return_value,
	m32c_skip_trampoline_code, m32c_m16c_address_to_pointer,
	m32c_m16c_pointer_to_address): Update.
	* m32r-tdep.c (m32r_store_return_value, decode_prologue,
	m32r_skip_prologue, m32r_push_dummy_call, m32r_extract_return_value):
	Update.
	* m68hc11-tdep.c (m68hc11_pseudo_register_read,
	m68hc11_pseudo_register_write, m68hc11_analyze_instruction,
	m68hc11_push_dummy_call): Update.
	* m68linux-tdep.c (m68k_linux_pc_in_sigtramp,
	m68k_linux_get_sigtramp_info, m68k_linux_sigtramp_frame_cache):
	Update.
	* m68k-tdep.c (m68k_push_dummy_call, m68k_analyze_frame_setup,
	m68k_analyze_register_saves, m68k_analyze_prologue, m68k_frame_cache,
	m68k_get_longjmp_target): Update.
	* m88k-tdep.c (m88k_fetch_instruction): Update.
	* mep-tdep.c (mep_pseudo_cr32_read, mep_pseudo_csr_write,
	mep_pseudo_cr32_write, mep_get_insn, mep_push_dummy_call): Update.
	* mi/mi-main.c (mi_cmd_data_write_memory): Update.
	* mips-linux-tdep.c (mips_linux_get_longjmp_target, supply_32bit_reg,
	mips64_linux_get_longjmp_target, mips64_fill_gregset,
	mips64_fill_fpregset, mips_linux_in_dynsym_stub): Update.
	* mipsnbdsd-tdep.c (mipsnbsd_get_longjmp_target): Update.
	* mips-tdep.c (mips_fetch_instruction, fetch_mips_16,
	mips_eabi_push_dummy_call, mips_n32n64_push_dummy_call,
	mips_o32_push_dummy_call, mips_o64_push_dummy_call,
	mips_single_step_through_delay, mips_skip_pic_trampoline_code,
	mips_integer_to_address): Update.
	* mn10300-tdep.c (mn10300_analyze_prologue, mn10300_push_dummy_call):
	Update.
	* monitor.c (monitor_supply_register, monitor_write_memory,
	monitor_read_memory_single): Update.
	* moxie-tdep.c (moxie_store_return_value, moxie_extract_return_value,
	moxie_analyze_prologue): Update.
	* mt-tdep.c (mt_return_value, mt_skip_prologue, mt_select_coprocessor,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_registers_info,
	mt_push_dummy_call): Update.
	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class, find_implementation_from_class): Update.
	* ppc64-linux-tdep.c (ppc64_desc_entry_point,
	ppc64_linux_convert_from_func_ptr_addr, ppc_linux_sigtramp_cache):
	Update.
	* ppcobsd-tdep.c (ppcobsd_sigtramp_frame_sniffer,
	ppcobsd_sigtramp_frame_cache): Update.
	* ppc-sysv-tdep.c (ppc_sysv_abi_push_dummy_call,
	do_ppc_sysv_return_value, ppc64_sysv_abi_push_dummy_call,
	ppc64_sysv_abi_return_value): Update.
	* ppc-linux-nat.c (ppc_linux_auxv_parse): Update.
	* procfs.c (procfs_auxv_parse): Update.
	* p-valprint.c (pascal_val_print): Update.
	* regcache.c (regcache_raw_read_signed, regcache_raw_read_unsigned,
	regcache_raw_write_signed, regcache_raw_write_unsigned,
	regcache_cooked_read_signed, regcache_cooked_read_unsigned,
	regcache_cooked_write_signed, regcache_cooked_write_unsigned): Update.
	* remote-m32r-sdi.c (m32r_fetch_register): Update.
	* remote-mips.c (mips_wait, mips_fetch_registers, mips_xfer_memory):
	Update.
	* rs6000-aix-tdep.c (rs6000_push_dummy_call, rs6000_return_value,
	rs6000_convert_from_func_ptr_addr, branch_dest,
	rs6000_software_single_step): Update.
	* rs6000-tdep.c (rs6000_in_function_epilogue_p,
	ppc_displaced_step_fixup, ppc_deal_with_atomic_sequence,
	bl_to_blrl_insn_p, rs6000_fetch_instruction, skip_prologue,
	rs6000_skip_main_prologue, rs6000_skip_trampoline_code,
	rs6000_frame_cache): Update.
	* s390-tdep.c (s390_pseudo_register_read, s390_pseudo_register_write,
	s390x_pseudo_register_read, s390x_pseudo_register_write, s390_load,
	s390_backchain_frame_unwind_cache, s390_sigtramp_frame_unwind_cache,
	extend_simple_arg, s390_push_dummy_call, s390_return_value): Update.
	* scm-exp.c (scm_lreadr): Update.
	* scm-lang.c (scm_get_field, scm_unpack): Update.
	* scm-valprint.c (scm_val_print): Update.
	* score-tdep.c (score_breakpoint_from_pc, score_push_dummy_call,
	score_fetch_inst): Update.
	* sh64-tdep.c (look_for_args_moves, sh64_skip_prologue_hard_way,
	sh64_analyze_prologue, sh64_push_dummy_call, sh64_extract_return_value,
	sh64_pseudo_register_read, sh64_pseudo_register_write,
	sh64_frame_prev_register): Update:
	* sh-tdep.c (sh_analyze_prologue, sh_push_dummy_call_fpu,
	sh_push_dummy_call_nofpu, sh_extract_return_value_nofpu,
	sh_store_return_value_nofpu, sh_in_function_epilogue_p): Update.
	* solib-darwin.c (darwin_load_image_infos): Update.
	* solib-frv.c (fetch_loadmap, lm_base, frv_current_sos, enable_break2,
	find_canonical_descriptor_in_load_object): Update.
	* solib-irix.c (extract_mips_address, fetch_lm_info, irix_current_sos,
	irix_open_symbol_file_object): Update.
	* solib-som.c (som_solib_create_inferior_hook, link_map_start,
	som_current_sos, som_open_symbol_file_object): Update.
	* solib-sunos.c (SOLIB_EXTRACT_ADDRESS, LM_ADDR, LM_NEXT, LM_NAME):
	Update.
	* solib-svr4.c (read_program_header, scan_dyntag_auxv,
	solib_svr4_r_ldsomap): Update.
	* sparc64-linux-tdep.c (sparc64_linux_step_trap): Update.
	* sparc64obsd-tdep.c (sparc64obsd_supply_uthread,
	sparc64obsd_collect_uthread): Update.
	* sparc64-tdep.c (sparc64_pseudo_register_read,
	sparc64_pseudo_register_write, sparc64_supply_gregset,
	sparc64_collect_gregset): Update.
	* sparc-linux-tdep.c (sparc32_linux_step_trap): Update.
	* sparcobsd-tdep.c (sparc32obsd_supply_uthread,
	sparc32obsd_collect_uthread): Update.
	* sparc-tdep.c (sparc_fetch_wcookie, sparc32_push_dummy_code,
	sparc32_store_arguments, sparc32_return_value, sparc_supply_rwindow,
	sparc_collect_rwindow): Update.
	* spu-linux-nat.c (parse_spufs_run): Update.
	* spu-tdep.c (spu_pseudo_register_read_spu,
	spu_pseudo_register_write_spu, spu_pointer_to_address,
	spu_analyze_prologue, spu_in_function_epilogue_p,
	spu_frame_unwind_cache, spu_push_dummy_call, spu_software_single_step,
	spu_get_longjmp_target, spu_get_overlay_table, spu_overlay_update_osect,
	info_spu_signal_command, info_spu_mailbox_list, info_spu_dma_cmdlist,
	info_spu_dma_command, info_spu_proxydma_command): Update.
	* stack.c (print_frame_nameless_args, frame_info): Update.
	* symfile.c (read_target_long_array, simple_read_overlay_table,
	simple_read_overlay_region_table): Update.
	* target.c (debug_print_register): Update.
	* tramp-frame.c (tramp_frame_start): Update.
	* v850-tdep.c (v850_analyze_prologue, v850_push_dummy_call,
	v850_extract_return_value, v850_store_return_value,
	* valarith.c (value_binop, value_bit_index): Update.
	* valops.c (value_cast): Update.
	* valprint.c (val_print_type_code_int, val_print_string,
	read_string): Update.
	* value.c (unpack_long, unpack_double, unpack_field_as_long,
	modify_field, pack_long): Update.
	* vax-tdep.c (vax_store_arguments, vax_push_dummy_call,
	vax_skip_prologue): Update.
	* xstormy16-tdep.c (xstormy16_push_dummy_call,
	xstormy16_analyze_prologue, xstormy16_in_function_epilogue_p,
	xstormy16_resolve_jmp_table_entry, xstormy16_find_jmp_table_entry,
	xstormy16_pointer_to_address, xstormy16_address_to_pointer): Update.
	* xtensa-tdep.c (extract_call_winsize, xtensa_pseudo_register_read,
	xtensa_pseudo_register_write, xtensa_frame_cache,
	xtensa_push_dummy_call, call0_track_op, call0_frame_cache): Update.


	* dfp.h (decimal_to_string, decimal_from_string, decimal_from_integral,
	decimal_from_floating, decimal_to_doublest, decimal_is_zero): Add
	BYTE_ORDER parameter.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	* dfp.c (match_endianness): Add BYTE_ORDER parameter.  Use it
	instead of current_gdbarch.
	(decimal_to_string, decimal_from_integral, decimal_from_floating,
	decimal_to_doublest, decimal_is_zero): Add BYTE_ORDER parameter.
	Pass it to match_endianness.
	(decimal_binop): Add BYTE_ORDER_X, BYTE_ORDER_Y, and BYTE_ORDER_RESULT
	parameters.  Pass them to match_endianness.
	(decimal_compare): Add BYTE_ORDER_X and BYTE_ORDER_Y parameters.
	Pass them to match_endianness.
	(decimal_convert): Add BYTE_ORDER_FROM and BYTE_ORDER_TO parameters.
	Pass them to match_endianness.
	* valarith.c (value_args_as_decimal): Add BYTE_ORDER_X and
	BYTE_ORDER_Y output parameters.
	(value_binop): Update call to value_args_as_decimal.

	Update calls to decimal_to_string, decimal_from_string,
	decimal_from_integral, decimal_from_floating, decimal_to_doublest,
	decimal_is_zero, decimal_binop, decimal_compare and decimal_convert
	to pass/receive byte order:
	* c-exp.y (parse_number): Update.
	* printcmd.c (printf_command): Update.
	* valarith.c (value_args_as_decimal, value_binop, value_logical_not,
	value_equal, value_less): Update.
	* valops.c (value_cast, value_one): Update.
	* valprint.c (print_decimal_floating): Update.
	* value.c (unpack_long, unpack_double): Update.
	* python/python-value.c (valpy_nonzero): Update.


	* ada-valprint.c (char_at): Add BYTE_ORDER parameter.
	(printstr): Update calls to char_at.
	(ada_val_print_array): Likewise.
	* valprint.c (read_string): Add BYTE_ORDER parameter.
	(val_print_string): Update call to read_string.
	* c-lang.c (c_get_string): Likewise.
	* charset.h (target_wide_charset): Add BYTE_ORDER parameter.
	* charset.c (target_wide_charset): Add BYTE_ORDER parameter.
	Use it instead of current_gdbarch.
	* printcmd.c (printf_command): Update calls to target_wide_charset.
	* c-lang.c (charset_for_string_type): Add BYTE_ORDER parameter.
	Pass to target_wide_charset.  Use it instead of current_gdbarch.
	(classify_type): Add BYTE_ORDER parameter.  Pass to
	charset_for_string_type.  Allow NULL encoding pointer.
	(print_wchar): Add BYTE_ORDER parameter.
	(c_emit_char): Update calls to classify_type and print_wchar.
	(c_printchar, c_printstr): Likewise.


	* gdbarch.sh (in_solib_return_trampoline): Convert to type "m".
	* gdbarch.c, gdbarch.h: Regenerate.
	* arch-utils.h (generic_in_solib_return_trampoline): Add GDBARCH
	parameter.
	* arch-utils.c (generic_in_solib_return_trampoline): Likewise.
	* hppa-hpux-tdep.c (hppa_hpux_in_solib_return_trampoline): Likewise.
	* rs6000-tdep.c (rs6000_in_solib_return_trampoline): Likewise.
	(rs6000_skip_trampoline_code): Update call.

	* alpha-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	dynamic_sigtramp_offset and pc_in_sigtramp callbacks.
	(alpha_read_insn): Add GDBARCH parameter.
	* alpha-tdep.c (alpha_lds, alpha_sts): Add GDBARCH parameter.
	(alpha_register_to_value): Pass architecture to alpha_sts.
	(alpha_extract_return_value): Likewise.
	(alpha_value_to_register): Pass architecture to alpha_lds.
	(alpha_store_return_value): Likewise.
	(alpha_read_insn): Add GDBARCH parameter.
	(alpha_skip_prologue): Pass architecture to alpha_read_insn.
	(alpha_heuristic_proc_start): Likewise.
	(alpha_heuristic_frame_unwind_cache): Likewise.
	(alpha_next_pc): Likewise.
	(alpha_sigtramp_frame_this_id): Pass architecture to
	tdep->dynamic_sigtramp_offset callback.
	(alpha_sigtramp_frame_sniffer): Pass architecture to
	tdep->pc_in_sigtramp callback.
	* alphafbsd-tdep.c (alphafbsd_pc_in_sigtramp): Add GDBARCH parameter.
	(alphafbsd_sigtramp_offset): Likewise.
	* alpha-linux-tdep.c (alpha_linux_sigtramp_offset_1): Add GDBARCH
	parameter.  Pass to alpha_read_insn.
	(alpha_linux_sigtramp_offset): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset_1.
	(alpha_linux_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_linux_sigtramp_offset.
	(alpha_linux_sigcontext_addr): Pass architecture to alpha_read_insn
	and alpha_linux_sigtramp_offset.
	* alphanbsd-tdep.c (alphanbsd_sigtramp_offset): Add GDBARCH parameter.
	(alphanbsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alphanbsd_sigtramp_offset.
	* alphaobsd-tdep.c (alphaobsd_sigtramp_offset): Add GDBARCH parameter.
	(alphaobsd_pc_in_sigtramp): Add GDBARCH parameter.  Pass to
	alpha_read_insn.
	(alphaobsd_sigcontext_addr): Pass architecture to
	alphaobsd_sigtramp_offset.
	* alpha-osf1-tdep.c (alpha_osf1_pc_in_sigtramp): Add GDBARCH
	parameter.

	* amd64-tdep.c (amd64_analyze_prologue): Add GDBARCH parameter.
	(amd64_skip_prologue): Pass architecture to amd64_analyze_prologue.
	(amd64_frame_cache): Likewise.

	* arm-tdep.c (SWAP_SHORT, SWAP_INT): Remove.
	(thumb_analyze_prologue, arm_skip_prologue, arm_scan_prologue,
	thumb_get_next_pc, arm_get_next_pc): Do not use SWAP_ macros.
	* arm-wince-tdep.c: Include "frame.h".

	* avr-tdep.c (EXTRACT_INSN): Remove.
	(avr_scan_prologue): Add GDBARCH argument, inline EXTRACT_INSN.
	(avr_skip_prologue): Pass architecture to avr_scan_prologue.
	(avr_frame_unwind_cache): Likewise.

	* cris-tdep.c (struct instruction_environment): Add BYTE_ORDER member.
	(find_step_target): Initialize it.
	(get_data_from_address): Add BYTE_ORDER parameter.
	(bdap_prefix): Pass byte order to get_data_from_address.
	(handle_prefix_assign_mode_for_aritm_op): Likewise.
	(three_operand_add_sub_cmp_and_or_op): Likewise.
	(handle_inc_and_index_mode_for_aritm_op): Likewise.

	* frv-linux-tdep.c (frv_linux_pc_in_sigtramp): Add GDBARCH parameter.
	(frv_linux_sigcontext_reg_addr): Pass architecture to
	frv_linux_pc_in_sigtramp.
	(frv_linux_sigtramp_frame_sniffer): Likewise.

	* h8300-tdep.c (h8300_is_argument_spill): Add GDBARCH parameter.
	(h8300_analyze_prologue): Add GDBARCH parameter.  Pass to
	h8300_is_argument_spill.
	(h8300_frame_cache, h8300_skip_prologue): Pass architecture
	to h8300_analyze_prologue.

	* hppa-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter to
	in_solib_call_trampoline callback.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.
	* hppa-tdep.c (hppa64_convert_code_addr_to_fptr): Add GDBARCH
	parameter.
	(hppa64_push_dummy_call): Pass architecture to
	hppa64_convert_code_addr_to_fptr.
	(hppa_match_insns): Add GDBARCH parameter.
	(hppa_match_insns_relaxed): Add GDBARCH parameter.  Pass to
	hppa_match_insns.
	(hppa_skip_trampoline_code): Pass architecture to hppa_match_insns.
	(hppa_in_solib_call_trampoline): Add GDBARCH parameter.  Pass to
	hppa_match_insns_relaxed.
	(hppa_stub_unwind_sniffer): Pass architecture to
	tdep->in_solib_call_trampoline callback.
	* hppa-hpux-tdep.c (hppa_hpux_search_pattern): Add GDBARCH parameter.
	(hppa32_hpux_search_dummy_call_sequence): Pass architecture to
	hppa_hpux_search_pattern.
	* hppa-linux-tdep.c (insns_match_pattern): Add GDBARCH parameter.
	(hppa_linux_sigtramp_find_sigcontext): Add GDBARCH parameter.
	Pass to insns_match_pattern.
	(hppa_linux_sigtramp_frame_unwind_cache): Pass architecture to
	hppa_linux_sigtramp_find_sigcontext.
	(hppa_linux_sigtramp_frame_sniffer): Likewise.
	(hppa32_hpux_in_solib_call_trampoline): Add GDBARCH parameter.
	(hppa64_hpux_in_solib_call_trampoline): Likewise.

	* i386-tdep.c (i386_follow_jump): Add GDBARCH parameter.
	(i386_analyze_frame_setup): Add GDBARCH parameter.
	(i386_analyze_prologue): Add GDBARCH parameter.  Pass to
	i386_follow_jump and i386_analyze_frame_setup.
	(i386_skip_prologue): Pass architecture to i386_analyze_prologue
	and i386_follow_jump.
	(i386_frame_cache): Pass architecture to i386_analyze_prologue.
	(i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-tdep.h (i386_pe_skip_trampoline_code): Add FRAME parameter.
	* i386-cygwin-tdep.c (i386_cygwin_skip_trampoline_code): Pass
	frame to i386_pe_skip_trampoline_code.

	* ia64-tdep.h (struct gdbarch_tdep): Add GDBARCH parameter
	to sigcontext_register_address callback.
	* ia64-tdep.c (ia64_find_global_pointer): Add GDBARCH parameter.
	(ia64_find_unwind_table): Pass architecture to
	ia64_find_global_pointer.
	(find_extant_func_descr): Add GDBARCH parameter.
	(find_func_descr): Pass architecture to find_extant_func_descr
	and ia64_find_global_pointer.
	(ia64_sigtramp_frame_init_saved_regs): Pass architecture to
	tdep->sigcontext_register_address callback.
	* ia64-linux-tdep.c (ia64_linux_sigcontext_register_address): Add
	GDBARCH parameter.

	* iq2000-tdep.c (iq2000_scan_prologue): Add GDBARCH parameter.
	(iq2000_frame_cache): Pass architecture to iq2000_scan_prologue.

	* lm32-tdep.c (lm32_analyze_prologue): Add GDBARCH parameter.
	(lm32_skip_prologue, lm32_frame_cache): Pass architecture to
	lm32_analyze_prologue.

	* m32r-tdep.c (decode_prologue): Add GDBARCH parameter.
	(m32r_skip_prologue): Pass architecture to decode_prologue.

	* m68hc11-tdep.c (m68hc11_analyze_instruction): Add GDBARCH parameter.
	(m68hc11_scan_prologue): Pass architecture to
	m68hc11_analyze_instruction.

	* m68k-tdep.c (m68k_analyze_frame_setup): Add GDBARCH parameter.
	(m68k_analyze_prologue): Pass architecture to
	m68k_analyze_frame_setup.

	* m88k-tdep.c (m88k_fetch_instruction): Add BYTE_ORDER parameter.
	(m88k_analyze_prologue): Add GDBARCH parameter.  Pass byte order
	to m88k_fetch_instruction.
	(m88k_skip_prologue): Pass architecture to m88k_analyze_prologue.
	(m88k_frame_cache): Likewise.

	* mep-tdep.c (mep_get_insn): Add GDBARCH parameter.
	(mep_analyze_prologue): Pass architecture to mep_get_insn.

	* mips-tdep.c (mips_fetch_instruction): Add GDBARCH parameter.
	(mips32_next_pc): Pass architecture to mips_fetch_instruction.
	(deal_with_atomic_sequence): Likewise.
	(unpack_mips16): Add GDBARCH parameter, pass to mips_fetch_instruction.
	(mips16_scan_prologue): Likewise.
	(mips32_scan_prologue): Likewise.
	(mips16_in_function_epilogue_p): Likewise.
	(mips32_in_function_epilogue_p): Likewise.
	(mips_about_to_return): Likewise.
	(mips_insn16_frame_cache): Pass architecture to mips16_scan_prologue.
	(mips_insn32_frame_cache): Pass architecture to mips32_scan_prologue.
	(mips_skip_prologue): Pass architecture to mips16_scan_prologue
	and mips32_scan_prologue.
	(mips_in_function_epilogue_p): Pass architecture to
	mips16_in_function_epilogue_p and
	mips32_in_function_epilogue_p.
	(heuristic_proc_start): Pass architecture to mips_fetch_instruction
	and mips_about_to_return.
	(mips_skip_mips16_trampoline_code): Pass architecture to
	mips_fetch_instruction.
	(fetch_mips_16): Add GDBARCH parameter.
	(mips16_next_pc): Pass architecture to fetch_mips_16.
	(extended_mips16_next_pc): Pass architecture to unpack_mips16 and
	fetch_mips_16.

	* objc-lang.c (read_objc_method, read_objc_methlist_nmethods,
	read_objc_methlist_method, read_objc_object, read_objc_super,
	read_objc_class): Add GDBARCH parameter.
	(find_implementation_from_class): Add GDBARCH parameter, pass
	to read_objc_class, read_objc_methlist_nmethods, and
	read_objc_methlist_method.
	(find_implementation): Add GDBARCH parameter, pass to
	read_objc_object and find_implementation_from_class.
	(resolve_msgsend, resolve_msgsend_stret): Pass architecture
	to find_implementation.
	(resolve_msgsend_super, resolve_msgsend_super_stret): Pass
	architecture to read_objc_super and find_implementation_from_class.

	* ppc64-linux-tdep.c (ppc64_desc_entry_point): Add GDBARCH parameter.
	(ppc64_standard_linkage1_target, ppc64_standard_linkage2_target,
	ppc64_standard_linkage3_target): Pass architecture to
	ppc64_desc_entry_point.
	* rs6000-tdep.c (bl_to_blrl_insn_p): Add BYTE_ORDER parameter.
	(skip_prologue): Pass byte order to bl_to_blrl_insn_p.
	(rs6000_fetch_instruction): Add GDBARCH parameter.
	(rs6000_skip_stack_check): Add GDBARCH parameter, pass to
	rs6000_fetch_instruction.
	(skip_prologue): Pass architecture to rs6000_fetch_instruction.

	* remote-mips.c (mips_store_word): Return old_contents as host
	integer value instead of target bytes.

	* s390-tdep.c (struct s390_prologue_data): Add BYTE_ORDER member.
	(s390_analyze_prologue): Initialize it.
	(extend_simple_arg): Add GDBARCH parameter.
	(s390_push_dummy_call): Pass architecture to extend_simple_arg.

	* scm-lang.c (scm_get_field): Add BYTE_ORDER parameter.
	* scm-lang.h (scm_get_field): Add BYTE_ORDER parameter.
	(SCM_CAR, SCM_CDR): Pass SCM_BYTE_ORDER to scm_get_field.
	* scm-valprint.c (scm_scmval_print): Likewise.
	(scm_scmlist_print, scm_ipruk, scm_scmval_print): Define
	SCM_BYTE_ORDER.

	* sh64-tdep.c (look_for_args_moves): Add GDBARCH parameter.
	(sh64_skip_prologue_hard_way): Add GDBARCH parameter, pass to
	look_for_args_moves.
	(sh64_skip_prologue): Pass architecture to
	sh64_skip_prologue_hard_way.
	* sh-tdep.c (sh_analyze_prologue): Add GDBARCH parameter.
	(sh_skip_prologue): Pass architecture to sh_analyze_prologue.
	(sh_frame_cache): Likewise.

	* solib-irix.c (extract_mips_address): Add GDBARCH parameter.
	(fetch_lm_info, irix_current_sos, irix_open_symbol_file_object):
	Pass architecture to extract_mips_address.

	* sparc-tdep.h (sparc_fetch_wcookie): Add GDBARCH parameter.
	* sparc-tdep.c (sparc_fetch_wcookie): Add GDBARCH parameter.
	(sparc_supply_rwindow, sparc_collect_rwindow): Pass architecture
	to sparc_fetch_wcookie.
	(sparc32_frame_prev_register): Likewise.
	* sparc64-tdep.c (sparc64_frame_prev_register): Likewise.
	* sparc32nbsd-tdep.c (sparc32nbsd_sigcontext_saved_regs): Likewise.
	* sparc64nbsd-tdep.c (sparc64nbsd_sigcontext_saved_regs): Likewise.

	* spu-tdep.c (spu_analyze_prologue): Add GDBARCH parameter.
	(spu_skip_prologue): Pass architecture to spu_analyze_prologue.
	(spu_virtual_frame_pointer): Likewise.
	(spu_frame_unwind_cache): Likewise.
	(info_spu_mailbox_list): Add BYTE_ORER parameter.
	(info_spu_mailbox_command): Pass byte order to info_spu_mailbox_list.
	(info_spu_dma_cmdlist): Add BYTE_ORER parameter.
	(info_spu_dma_command, info_spu_proxydma_command): Pass byte order
	to info_spu_dma_cmdlist.

	* symfile.c (read_target_long_array): Add GDBARCH parameter.
	(simple_read_overlay_table, simple_read_overlay_region_table,
	simple_overlay_update_1): Pass architecture to read_target_long_array.

	* v850-tdep.c (v850_analyze_prologue): Add GDBARCH parameter.
	(v850_frame_cache): Pass architecture to v850_analyze_prologue.

	* xstormy16-tdep.c (xstormy16_analyze_prologue): Add GDBARCH
	parameter.
	(xstormy16_skip_prologue, xstormy16_frame_cache): Pass architecture
	to xstormy16_analyze_prologue.
	(xstormy16_resolve_jmp_table_entry): Add GDBARCH parameter.
	(xstormy16_find_jmp_table_entry): Likewise.
	(xstormy16_skip_trampoline_code): Pass architecture to
	xstormy16_resolve_jmp_table_entry.
	(xstormy16_pointer_to_address): Likewise.
	(xstormy16_address_to_pointer): Pass architecture to
	xstormy16_find_jmp_table_entry.

	* xtensa-tdep.c (call0_track_op): Add GDBARCH parameter.
	(call0_analyze_prologue): Add GDBARCH parameter, pass to
	call0_track_op.
	(call0_frame_cache): Pass architecture to call0_analyze_prologue.
	(xtensa_skip_prologue): Likewise.
@
text
@d36 1
a36 1
#include "elf/dwarf2.h"
@


1.59
log
@	* defs.h (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter.
	* utils.c (strlen_paddr, paddr, paddr_nz): Remove.
	(paddress): Add GDBARCH parameter, use it instead of current_gdbarch.
	* ui-out.h (ui_out_field_core_addr): Add GDBARCH parameter.
	* ui-out.c (ui_out_field_core_addr): Add GDBARCH parameter,
	use it instead of current_gdbarch.

	Update calls to ui_out_field_core_addr to pass architecture:
	* ada-lang.c (print_one_exception): Update.
	* breakpoint.c (print_one_breakpoint_location,
	print_one_exception_catchpoint): Update.
	* disasm.c (dump_insns): Update.
	* darwin-nat-info.c (darwin_debug_regions_recurse): Update.
	* mi/mi-main.c (mi_cmd_data_read_memory): Update.
	* mi/mi-symbol-cmds.c: Include "objfiles.h".
	(mi_cmd_symbol_list_lines): Update.
	* stack.c (print_frame_info, print_frame): Update.

	Update callers of paddress to pass architecture:
	* ada-tasks.c (info_task): Update.
	* ada-valprint.c (ada_val_print_1): Update.
	* annotate.c (annotate_source, annotate_frame_begin): Update.
	* breakpoint.c (insert_bp_location, describe_other_breakpoints,
	mention): Update.
	* cli/cli-cmds.c (edit_command, list_command, print_disassembly):
	Update.
	* corefile.c (memory_error): Update.
	* c-valprint.c (print_function_pointer_address, c_val_print): Update.
	* disasm.c (dis_asm_print_address): Update.
	* exec.c (print_section_info): Update.
	* f-valprint.c (f_val_print): Update.
	* infcmd.c: Include "arch-utils.h".
	(jump_command, program_info): Update.
	* linux-fork.c: Include "arch-utils.h".
	(info_forks_command): Update.
	* m2-valprint.c (print_function_pointer_address,
	print_unpacked_pointer, print_variable_at_address,
	m2_val_print): Update.
	* m32r-rom.c (m32r_load_section, m32r_load, m32r_upload_command):
	Update.
	* printcmd.c (print_address, print_address_demangle, address_info):
	Update.
	* p-valprint.c (pascal_val_print): Update.
	* source.c: Include "arch-utils.h".
	(line_info): Update.
	* stack.c (frame_info, print_block_frame_labels): Update.
	* symfile.c (add_symbol_file_command, list_overlays_command): Update.
	* symmisc.c (dump_msymbols, dump_psymtab, dump_symtab_1,
	print_symbol, print_partial_symbols, maintenance_info_psymtabs,
	maintenance_check_symtabs): Update.
	* symtab.c (find_pc_sect_symtab): Update.
	* target.c (deprecated_debug_xfer_memory): Update.
	* tracepoint.c (scope_info): Update.
	* tui/tui-stack.c (tui_make_status_line): Update.
	* valprint.c (val_print_string): Update.

	Update callers of paddr_nz to use paddress instead (keeping
	user-visible output identical):
	* alpha-tdep.c (alpha_heuristic_proc_start): Update.
	* amd64-tdep.c (fixup_riprel, amd64_displaced_step_copy_insn,
	amd64_displaced_step_fixup): Update.
	* arch-utils.c (simple_displaced_step_copy_insn): Update.
	* auxv.c (fprint_target_auxv): Update.
	* breakpoint.c (insert_single_step_breakpoint): Update.
	* buildsym.c (finish_block): Update.
	* cli/cli-dump.c (restore_section_callback): Update.
	* fbsd-nat.c (fbsd_find_memory_regions): Update.
	* frame.c (frame_unwind_register_value): Update.
	* gcore.c (gcore_create_callback): Update.
	* hppa-tdep.c (hppa_frame_cache, hppa_skip_trampoline_code): Update.
	* i386-tdep.c (i386_displaced_step_fixup, i386_record_modrm,
	i386_record_lea_modrm_addr, i386_record_lea_modrm,
	i386_process_record): Update.
	* ia64-tdep.c (ia64_frame_this_id, ia64_sigtramp_frame_this_id,
	ia64_libunwind_frame_this_id, ia64_libunwind_sigtramp_frame_this_id,
	ia64_dummy_id, ia64_access_reg, ia64_access_rse_reg): Update.
	* infrun.c (displaced_step_prepare, displaced_step_fixup,
	handle_inferior_event, insert_step_resume_breakpoint_at_sal,
	insert_longjmp_resume_breakpoint): Update.
	* linux-nat.c (linux_nat_find_memory_regions): Update.
	* linux-record.c (record_linux_system_call): Update.
	* mips-tdep.c (heuristic_proc_start, mips_eabi_push_dummy_call,
	mips_n32n64_push_dummy_call, mips_o32_push_dummy_call,
	mips_o64_push_dummy_call): Update.
	* monitor.c (monitor_error, monitor_remove_breakpoint): Update.
	* record.c (record_arch_list_add_mem, record_wait,
	record_xfer_partial): Update.
	* remote-mips.c (mips_fetch_word, mips_check_lsi_error,
	mips_common_breakpoint): Update.
	* remote-sim.c (gdbsim_xfer_inferior_memory): Update.
	* rs6000-tdep.c (ppc_displaced_step_fixup): Update.
	* solib-som.c (som_current_sos): Update.
	* symfile.c (load_progress, generic_load): Update.
	* symfile-mem.c (add_vsyscall_page): Update.
	* valops.c (value_fetch_lazy): Update.
	* windows-tdep.c (windows_xfer_shared_library): Update.

	Update callers of paddr_nz to use paddress instead (changing
	user-visible output to make it more correct):
	* dwarf2loc.c (locexpr_describe_location): Update.
	* ia64-tdep.c (ia64_memory_insert_breakpoint,
	ia64_memory_remove_breakpoint): Update.
	* jv-valprint.c (java_value_print): Update.
	* m32c-tdep.c (m32c_m16c_address_to_pointer): Update.
	* monitor.c (monitor_read_memory): Update.

	Update callers of paddr to use paddress instead (changing
	user-visible output to make it more correct):
	* arm-tdep.c (arm_push_dummy_call): Update.
	* breakpoint.c (insert_bp_location, create_thread_event_breakpoint,
	create_breakpoint): Update.
	* darwin-nat-info.c (darwin_debug_regions): Update.
	* dcache.c (dcache_info): Update.
	* dsrec.c (load_srec, make_srec): Update.
	* dwarf2-frame.c (dwarf2_restore_rule, execute_cfa_program,
	dwarf2_frame_cache): Update.
	* gcore.c (gcore_copy_callback): Update.
	* gnu-nat.c (gnu_xfer_memory): Update.
	* mips-linux-nat.c (mips_show_dr): Update.
	* monitor.c (monitor_write_memory, monitor_insert_breakpoint,
	monitor_remove_breakpoint): Update.
	* remote.c (compare_sections_command): Update.
	* remote-m32r-sdi.c (m32r_xfer_memory, m32r_insert_breakpoint,
	m32r_remove_breakpoint, m32r_insert_watchpoint,
	m32r_remove_watchpoint): Update.
	* sol-thread.c (info_cb): Update.
	* symfile.c (load_progress): Update.

	Update callers of paddress or paddr_nz to use hex_string instead
	(changes output of internal/error/debug messages only):
	* dwarf2read.c (dump_die_shallow): Update.
	* frame.c (fprint_field, fprint_frame, frame_pc_unwind,
	get_frame_func, create_new_frame): Update.
	* hppa-tdep.c (find_unwind_entry, unwind_command): Update.
	* ia64-tdep.c (get_kernel_table, ia64_find_proc_info_x,
	ia64_get_dyn_info_list): Update.
	* maint.c (maintenance_translate_address): Update.
	* mi/mi-cmd-var.c (mi_cmd_var_create): Update.
	* target.c (target_flash_erase): Update.

	Update callers of paddr/paddr_nz to use phex/phex_nz instead,
	using an appropriate address size.  Remove use of strlen_paddr.
	* exec.c (exec_files_info): Update.
	* i386-nat.c (i386_show_dr): Update.
	* remote.c (remote_flash_erase): Update.
	* m32r-rom.c (m32r_load_section): Update.
	* monitor.c (monitor_vsprintf, monitor_store_register): Update.
	* remote.c (remote_check_symbols, remote_search_memory): Update.
	* remote-mips.c (mips_request, mips_common_breakpoint): Update.
	* scm-valprint.c (scm_ipruk, scm_scmval_print): Update.
	* sh64-tdep.c (sh64_show_media_regs, sh64_show_compact_regs): Update.
	* sh-tdep.c (sh_generic_show_regs, sh3_show_regs, sh2e_show_regs,
	sh2a_show_regs, sh2a_nofpu_show_regs, sh3e_show_regs,
	sh3_dsp_show_regs, sh4_show_regs, sh4_nofpu_show_regs,
	sh_dsp_show_regs): Update.
	* xcoffsolib.c (sharedlibrary_command): Update.


	* maint.c (maint_print_section_info): Add ADDR_SIZE parameter.
	Use hex_string_custom instead of paddr.
	(print_bfd_section_info): Pass address size.
	(print_objfile_section_info): Likewise.

	* annotate.h (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* annotate.c (annotate_source): Add GDBARCH parameter.
	(annotate_frame_begin): Likewise.
	* source.c (identify_source_line): Update call to annotate_source.
	* stack.c (print_frame_info, print_frame): Update call to
	annotate_frame_begin.

	* breakpoint.c (describe_other_breakpoints): Add GDBARCH parameter.
	(create_breakpoint, create_ada_exception_breakpoint): Update call.

	* stack.c (print_block_frame_labels): Add GDBARCH parameter.
	(print_frame_label_vars): Update call.

	* symmisc.c (print_partial_symbols): Add GDBARCH parameter.
	(dump_psymtab): Update call to print_partial_symbols.
	(struct print_symbol_args): Add GDBARCH member.
	(dump_symtab_1): Set print_symbol_args architecture member.
	(print_symbol): Use it.

	* windows-tdep.h (windows_xfer_shared_library): Add GDBARCH
	parameter.
	* windows-tdep.c (windows_xfer_shared_library): Likewise.
	* i386-cygwin-tdep.c (struct cpms_data): Add GDBARCH member.
	(core_process_module_section): Pass architecture from cpms_data to
	windows_xfer_shared_library.
	(windows_core_xfer_shared_libraries): Initialize cmps_data
	architecture member.
	* windows-nat.c (windows_xfer_shared_libraries): Pass architecture
	to windows_xfer_shared_library.

	* defs.h (print_address): Add GDBARCH parameter.
	* printcmd.c (print_address): Add GDBARCH parameter.
	(print_scalar_formatted, do_examine): Update call.
	* findcmd.c (find_command): Update call.
	* tracepoint.c: Include "arch-utils.h".
	(trace_find_line_command): Update call.
	* tui/tui-disasm.c (tui_disassemble): Update call.

	* value.h (print_address_demangle): Add GDBARCH parameter.
	* printcmd.c (print_address_demangle): Add GDBARCH parameter.
	* c-valprint.c (print_function_pointer_address, c_val_print):
	Update call.
	* f-valprint.c (f_val_print): Update call.
	* gnu-v3-abi.c (gnuv3_print_method_ptr): Update call.
	* jv-valprint.c (java_val_print): Update call.
	* m2-valprint.c (print_function_pointer_address, m2_val_print):
	Update call.
	* p-valprint.c (pascal_val_print): Update call.

	* disasm.c (gdb_disassemble_info): Install architecture into
	di.application_data field.

testsuite/ChangeLog:

	* gdb.threads/tls-shared.exp: Update to locexpr_describe_location
	change to prefix TLS offset in hex with 0x.

doc/ChangeLog:

	* gdbint.texinfo (Item Output Functions): Update signature
	for ui_out_field_core_addr.
@
text
@d60 1
d93 1
a93 1
      length = extract_unsigned_integer (loc_ptr, 2);
@


1.58
log
@	gdb/
	* NEWS: Document inlined function support.
	* Makefile.in (SFILES): Add inline-frame.c.
	(COMMON_OBS): Add inline-frame.o.
	* block.c (contained_in): Rewrite to use lexical nesting.
	(block_linkage_function): Skip inlined function blocks.
	(block_inlined_p): New.
	* block.h (struct block): Update comment.
	(block_inlined_p): New prototype.
	* blockframe.c (get_frame_block): Handle inlined functions.
	(get_frame_function): Do not use block_linkage_function.
	(block_innermost_frame): Use get_frame_block and contained_in.
	* breakpoint.c (watchpoint_check): Remove extra reinit_frame_cache.
	Skip over inlined functions.  Simplify epilogue check.
	(bpstat_check_breakpoint_conditions): Use get_stack_frame_id.
	Update comments.
	(set_momentary_breakpoint): Only accept non-inlined frames.
	(watch_command_1): Use frame_unwind_caller_pc and
	frame_unwind_caller_id instead of get_prev_frame.
	(until_break_command): Likewise.  Use get_stack_frame_id.
	* buildsym.c (end_symtab): Set SYMBOL_SYMTAB for block functions.
	* dwarf2loc.c (dwarf_expr_frame_base): Use block_linkage_function.
	* dwarf2read.c (process_die): Handle DW_TAG_inlined_subroutine.
	(read_func_scope, new_symbol): Likewise.  Handle arguments specially
	for inlined functions without call site information.
	(inherit_abstract_dies): Allow tag mismatch for inlined subroutines.
	(die_specification): Treat DW_AT_abstract_origin as a specification.
	(read_type_die): Handle DW_TAG_inlined_subroutine.
	* frame-unwind.c (frame_unwind_init): Add inline_frame_unwind.
	* frame.c (fprint_frame_id): Print inline depth.
	(fprint_frame_type): Handle INLINE_FRAME and SENTINEL_FRAME.
	(skip_inlined_frames, get_stack_frame_id): New.
	(frame_unwind_caller_id): Use skip_inlined_frames.
	(frame_id_inlined_p): New.
	(frame_id_eq): Make the logic match the comments.  Add inline_depth
	check.
	(frame_id_inner): Handle inlined functions.
	(frame_unwind_pc): New function, copied from frame_unwind_caller_pc.
	(frame_unwind_caller_pc): Use skip_inlined_frames and frame_unwind_pc.
	(get_prev_frame_1): Check for inline frames.  Split out frame
	allocation to get_prev_frame_raw.
	(get_prev_frame_raw): New function.
	(get_prev_frame): Handle inline frames.
	(get_frame_pc): Use frame_unwind_pc.
	(get_frame_address_in_block): Skip inlined frames on both sides.
	(pc_notcurrent): Delete.
	(find_frame_sal): Rewrite to handle inline call sites.  Use
	get_frame_address_in_block.
	(deprecated_update_frame_pc_hack): Make static.
	* frame.h: Update comments.
	(struct frame_id): Add inline_depth.
	(enum frame_type): Add INLINE_FRAME.
	(frame_id_inlined_p, get_stack_frame_id): New prototypes.
	* gdbthread.h (struct thread_info): Add step_stack_frame_id field.
	* infcmd.c (set_step_frame): New function.
	(step_once): Use set_step_frame.  Handle inlined functions.
	(until_next_command): Use set_step_frame.
	(finish_backward), finish_forward): Use get_stack_frame_id.
	(finish_command): Support inlined functions.
	* inferior.h (set_step_info): New prototype.
	* infrun.c (RESUME_ALL): Use minus_one_ptid.
	(clear_proceed_status): Clear step_stack_frame_id.
	(init_wait_for_inferior): Call clear_inline_frame_state.
	(init_execution_control_state): Make static.
	(set_step_info): New function.
	(init_thread_stepping_state): Do not set the symtab or line here.
	(stepped_in_from): New function.
	(handle_inferior_event): Handle inlined functions.  Use set_step_info.
	(insert_step_resume_breakpoint_at_frame): Use get_stack_frame_id.
	(struct inferior_status): Add step_stack_frame_id.
	(save_inferior_status, restore_inferior_status): Save and restore
	step_stack_frame_id.
	* inline-frame.c, inline-frame.h: New files.
	* minsyms.c (prim_record_minimal_symbol_and_info): Use XCALLOC.
	* regcache.c (regcache_write_pc): Call reinit_frame_cache.
	* s390-tdep.c (s390_prologue_frame_unwind_cache): Handle INLINE_FRAME.
	* stack.c (frame_show_address): New.
	(print_frame_info, print_frame): Use it.
	(find_frame_funname): Use get_frame_function.  Handle inlined blocks.
	(frame_info): Mark inlined functions.
	(backtrace_command_1): Use get_current_user_frame.
	(print_frame_local_vars, print_frame_label_vars): Update comments.
	(return_command): Refuse inlined functions.
	* symtab.c (lookup_symbol_aux_local): Stop at inlined function
	boundaries.
	(find_function_start_sal): Avoid inlined functions.
	(completion_list_add_fields): New function.
	(default_make_symbol_completion_list): Use it.  Use block_static_block
	and block_global_block.  Check for inlined functions.
	(skip_prologue_using_sal): Avoid line number comparison across
	inlining.
	* symtab.h (struct symbol): Add is_inlined.
	(SYMBOL_INLINED): New.
	* target.c (target_resume): Call clear_inline_frame_state.
	* valops.c (value_of_variable): Check block_inlined_p.

	gdb/doc/
	* gdb.texinfo (Debugging Optimized Code): New chapter.
	(Compiling for Debugging): Reference it.  Move some
	text to the new section.

	gdb/testsuite/
	* gdb.base/break.exp: Add an XFAIL for gcc/36748.
	* gdb.cp/annota2.exp: Accept frames-invalid in more places.
	* gdb.opt/Makefile.in (EXECUTABLES): Update.
	* gdb.opt/clobbered-registers-O2.exp: Update to GPL v3.
	* gdb.opt/inline-bt.c, gdb.opt/inline-bt.exp,
	gdb.opt/inline-cmds.c, gdb.opt/inline-cmds.exp,
	gdb.opt/inline-locals.c, gdb.opt/inline-locals.exp,
	gdb.opt/inline-markers.c: New files.
	* lib/gdb.exp (skip_inline_frame_tests): New function.
	(skip_inline_var_tests): New function.
@
text
@d511 1
a511 1
			  paddr_nz (offset), objfile->name);
@


1.57
log
@	* ax-gdb.c (gen_bitfield_ref): Add EXP argument, use expression
	architecture instead of current_gdbarch.
	(gen_struct_ref): Add EXP argument, pass to get_bitfield_ref.
	(gen_expr): Pass expression to get_struct_ref.

	* symtab.h (struct symbol_ops): Add GDBARCH parameter to
	tracepoint_var_ref callback.
	* ax-gdb.c (gen_var_ref): Pass architecture to tracepoint_var_ref
	symbol operation callback.
	* dwarf2loc.c (dwarf2_tracepoint_var_ref): Add GDBARCH parameter.
	Use it instead of current_gdbarch.
	(locexpr_tracepoint_var_ref): Add GDBARCH parameter.  Pass it to
	dwarf2_tracepoint_var_ref.
	(loclist_tracepoint_var_ref): Likewise.
@
text
@d34 1
d151 4
a154 1
  framefunc = get_frame_function (debaton->frame);
d161 3
a163 1
  if (SYMBOL_COMPUTED_OPS (framefunc) == &dwarf2_loclist_funcs)
@


1.56
log
@	* symtab.h: Rename SYMBOL_OPS to SYMBOL_COMPUTED_OPS.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value, symbol_read_needs_frame): Likewise.
	* printcmd.c (address_info): Likewise.
	* dwarf2loc.c (dwarf_expr_frame_base): Likewise.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Likewise.
	* symtab.h: Rename struct symbol_ops to struct symbol_computed_ops.
	* dwarf2loc.h: Likewise.
	* dwarf2loc.c (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Likewise.

	* symtab.h: (struct symbol_register_ops): New struct definition.
	(struct symbol): Make "ops" member a union of symbol_computed_ops and
	symbol_register_ops callback pointers.
	(SYMBOL_REGISTER_OPS): New macro.
	* tracepoint.c: Include "objfiles.h".
	(scope_info, collect_symbol): Use SYMBOL_REGISTER_OPS register_number
	callback to retrieve register numbers.
	* ax-gdb.c (gen_var_ref): Likewise.
	* findvar.c (read_var_value): Likewise.
	* printcmd.c (address_info): Likewise.

	* coffread.c (coff_reg_to_regnum): New function.
	(coff_register_funcs): New static variable.
	(process_coff_symbol): Do not call gdbarch_sdb_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* mdebugread.c (mdebug_reg_to_regnum): New function.
	(mdebug_register_funcs): New static variable.
	(parse_symbol): Do not call gdbarch_ecoff_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
	* stabsread.c (stab_reg_to_regnum): New function.
	(stab_register_funcs): New static variable.
	(define_symbol): Do not call gdbarch_stab_reg_to_regnum.
	Install SYMBOL_REGISTER_OPS callbacks.
@
text
@d369 3
a371 3
dwarf2_tracepoint_var_ref (struct symbol *symbol, struct agent_expr *ax,
			   struct axs_value *value, gdb_byte *data,
			   int size)
d404 1
a404 1
      gdbarch_virtual_frame_pointer (current_gdbarch, 
d525 2
a526 2
locexpr_tracepoint_var_ref (struct symbol * symbol, struct agent_expr * ax,
			    struct axs_value * value)
d530 2
a531 1
  dwarf2_tracepoint_var_ref (symbol, ax, value, dlbaton->data, dlbaton->size);
d598 2
a599 2
loclist_tracepoint_var_ref (struct symbol * symbol, struct agent_expr * ax,
			    struct axs_value * value)
d609 1
a609 1
  dwarf2_tracepoint_var_ref (symbol, ax, value, data, size);
@


1.55
log
@2009-05-27  Tom Tromey  <tromey@@redhat.com>
	    Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* mi/mi-main.c (mi_cmd_data_evaluate_expression): Use
	value_address.
	* cli/cli-dump.c (dump_value_to_file): Use value_address.
	* valprint.c (common_val_print): Likewise.
	* v850-tdep.c (v850_push_dummy_call): Use value_address.
	* tracepoint.c (encode_actions): Use value_address.
	* printcmd.c (print_formatted): Use value_address.
	(x_command): Likewise.
	* p-valprint.c (pascal_object_print_static_field): Use
	value_address.
	* mn10300-tdep.c (mn10300_push_dummy_call): Use value_address.
	* mips-tdep.c (mips_eabi_push_dummy_call): Use value_address.
	* m32r-tdep.c (m32r_push_dummy_call): Use value_address.
	* jv-valprint.c (java_value_print): Use value_address.
	* infcall.c (find_function_addr): Use value_address.
	* gnu-v3-abi.c (gnuv3_rtti_type): Use value_address.
	* gnu-v2-abi.c (gnuv2_value_rtti_type): Use value_address.
	* frv-tdep.c (frv_push_dummy_call): Use value_address.
	* frame.c (frame_register_unwind): Use value_address.
	(frame_unwind_register_value): Likewise.
	* darwin-nat-info.c (info_mach_region_command): Use
	value_address.
	* cp-valprint.c (cp_print_static_field): Use value_address.
	* c-valprint.c (c_value_print): Use value_address.
	* breakpoint.c (update_watchpoint): Use value_address.
	(can_use_hardware_watchpoint): Likewise.
	* ada-valprint.c (ada_val_print_1): Use value_address.
	(ada_value_print): Likewise.
	* ada-tasks.c (read_fat_string_value): Use value_address.
	* jv-lang.c (java_link_class_type): Use set_value_address.
	(java_link_class_type): Likewise.
	(get_java_utf8_name): Use value_address.
	(type_from_class): Likewise.
	(java_link_class_type): Likewise.
	* findvar.c (value_of_register): Use set_value_address.
	(read_var_value): Likewise.
	(read_var_value): Likewise.
	* eval.c (evaluate_subexp_standard): Use set_value_address.
	(evaluate_subexp_standard): Use value_address.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Use set_value_address.
	* ada-lang.c (coerce_unspec_val_to_type): Use set_value_address.
	(ada_value_primitive_packed_val): Likewise.
	(ensure_lval): Likewise.
	(thin_data_pntr): Use value_address.
	(desc_bounds): Likewise.
	(ada_value_primitive_packed_val): Likewise.
	(value_assign_to_component): Likewise.
	(ensure_lval): Likewise.
	(make_array_descriptor): Likewise.
	(ada_to_fixed_value): Likewise.
	(unwrap_value): Likewise.
	* value.c (deprecated_value_address_hack): Remove.
	(value_address): New function.
	(value_raw_address): Likewise.
	(set_value_address): Likewise.
	(value_fn_field): Use set_value_address.
	(value_from_contents_and_address): Likewise.
	(value_fn_field): Likewise.
	(allocate_value_lazy): Don't use VALUE_ADDRESS.
	(value_as_address): Use value_address.
	(value_static_field): Likewise.
	* valops.c (search_struct_field): Use set_value_address.
	(value_at): Likewise.
	(value_at_lazy): Likewise.
	(value_repeat): Likewise.
	(value_cast_structs): Use value_address.
	(value_cast): Likewise.
	(value_fetch_lazy): Likewise.
	(value_assign): Likewise.
	(value_repeat): Likewise.
	(address_of_variable): Likewise.
	(value_coerce_array): Likewise.
	(value_coerce_function): Likewise.
	(value_addr): Likewise.
	(search_struct_field): Likewise.
	(search_struct_method): Likewise.
	(find_method_list): Likewise.
	(value_struct_elt_for_reference): Likewise.
	(value_full_object): Likewise.
	* jv-valprint.c (java_value_print): Use set_value_address.
	* value.h (deprecated_value_address_hack): Remove.
	(VALUE_ADDRESS): Remove.
	(value_address): Declare.
	(value_raw_address): Declare.
	(set_value_address): Declare.
@
text
@d157 1
a157 1
  if (SYMBOL_OPS (framefunc) == &dwarf2_loclist_funcs)
d535 1
a535 1
const struct symbol_ops dwarf2_locexpr_funcs = {
d613 1
a613 1
const struct symbol_ops dwarf2_loclist_funcs = {
@


1.54
log
@	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Do not call get_frame_arch
	for NULL frame pointers.
@
text
@d267 1
a267 1
      VALUE_ADDRESS (retval) = address;
@


1.53
log
@        Updated copyright notices for most files.
@
text
@a201 1
  struct gdbarch *arch = get_frame_arch (frame);
d240 1
d242 1
a242 2
	      int gdb_regnum = gdbarch_dwarf2_reg_to_regnum
				 (arch, p->value);
d255 1
d257 1
a257 2
      int gdb_regnum = gdbarch_dwarf2_reg_to_regnum
			 (arch, dwarf_regnum);
@


1.52
log
@	* dwarf2expr.h (dwarf2_read_address): Add gdbarch argument.
	* dwarf2expr.c (dwarf2_read_address): Add gdbarch argument.
	Call gdbarch_integer_to_address directly instead of converting
	to value and back.  Update comment.
	(execute_stack_op): Update call site.
	* dwarf2loc.c (find_location_expression): Likewise.
	(locexpr_describe_location): Update

	* dwarf2expr.h (struct dwarf_expr_context): Add gdbarch member.
	* dwarf2-frame.c (execute_stack_op): Initialize ctx->gdbarch.
	* dwarf2loc. (dwarf2_evaluate_loc_desc): Likewise.
	(dwarf2_loc_desc_needs_frame): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.51
log
@	* dwarf2loc.c (dwarf_expr_frame_base): Error out on missing
	SYMBOL_LOCATION_BATON.
@
text
@d58 1
d71 1
a71 1
      low = dwarf2_read_address (loc_ptr, buf_end, addr_size);
d73 1
a73 1
      high = dwarf2_read_address (loc_ptr, buf_end, addr_size);
d219 1
d341 1
d498 3
a500 1
	CORE_ADDR offset = dwarf2_read_address (&dlbaton->data[1],
@


1.50
log
@	* objfiles.h (struct objfile): New GDBARCH member.
	(get_objfile_arch): Add prototype.
	* objfiles.c: Include "arch-utils.h".
	(allocate_objfile): Look up gdbarch associated with bfd.
	(get_objfile_arch): New function.
	* Makefile (objfiles.o): Update dependencies.

	* dwarf2-frame.c (decode_frame_entry_1): Replace current_gdbarch
	by objfile arch.
	* dwarf2loc.c (dwarf_expr_read_reg): Replace current_gdbarch
	by frame arch.
	(locexpr_describe_location): Replace current_gdbarch by
	objfile arch.
	* dwarf2read.c (die_type): Replace current_gdbarch by objfile arch.
	(dwarf2_add_field): Likewise.
	(read_tag_pointer_type): Likewise.
	(read_base_type): Likewise.
	(new_symbol): Likewise.

	* coffread.c (decode_type): Add OBJFILE argument.  Update callers.
	(decode_base_type, decode_function_type): Likewise.
	(coff_read_struct_type, coff_read_enum_type): Likewise.
	(coff_symtab_read): Replace current_gdbarch by objfile arch.
	(decode_base_type): Likewise.
	(coff_read_enum_type): Likewise.
	(coff_read_struct_type): Replace current_objfile by OBJFILE argument.
	(coff_read_enum_type): Likewise.

	* dbxread.c (read_dbx_symtab): Replace current_gdbarch by objfile arch.
	(end_psymtab): Likewise.
	(process_one_symbol): Likewise.

	* mdebugread.c (parse_symbol): Replace current_gdbarch by objfile arch.
	(parse_procedure): Likewise.
	(parse_partial_symbols): Likewise.

	* somread.c (som_symtab_read): Replace current_gdbarch by objfile arch.

	* stabsread.c (define_symbol): Replace current_gdbarch by objfile arch.
	Replace static pcc_promotion_type and pcc_unsigned_promotion_type by
	built-in types.
	(read_range_type): Replace current_gdbarch by objfile arch.  Replace
	static range_index_type by built-in type.
	(read_one_struct_field): Replace current_gdbarch by objfile arch.
	(read_enum_type): Likewise.

	* xcoffread.c (read_xcoff_symtab): Replace current_gdbarch by
	objfile arch.
@
text
@d169 7
a175 2
      *length = symbaton->size;
      *start = symbaton->data;
@


1.49
log
@2008-03-18  Ulrich Weigand  <uweigand@@de.ibm.com>
	    Jim Blandy  <jimb@@codesourcery.com>
	    Daniel Jacobowitz  <drow@@false.org>

	* dwarf2expr.h (struct dwarf_expr_context): Add ADDR_SIZE member.
	(dwarf2_read_address): Update prototype.

	* dwarf2expr.c (unsigned_address_type): Add ADDR_SIZE parameter.
	(signed_address_type): Likewise.
	(dwarf2_read_address): Replace BYTES_READ parameter with ADDR_SIZE.
	(execute_stack_op): Update calls to unsigned_address_type,
	signed_address_type and dwarf2_read_address.  Fix implementation
	of DW_OP_deref_size.

	* dwarf2loc.h (dwarf2_per_cu_objfile): Add prototype.
	(dwarf2_per_cu_addr_size): Likewise.
	(struct dwarf2_locexpr_baton): Replace OBJFILE with PER_CU.
	(struct dwarf2_loclist_baton): Likewise.

	* dwarf2loc.c (find_location_expression): Update calls to
	dwarf2_read_address.  Use dwarf2_per_cu_objfile and
	dwarf2_per_cu_addr_size to retrieve PER_CU parameters.
	(locexpr_describe_location): Likewise.
	(dwarf2_evaluate_loc_desc): Replace OBJFILE with PER_CU parameter.
	Set ctx->addr_size to dwarf2_per_cu_addr_size (per_cu).
	(dwarf2_loc_desc_needs_frame): Add PER_CU parameter.  Set ctx->addr_size
	to dwarf2_per_cu_addr_size (per_cu).
	(locexpr_read_variable): Update dwarf2_evaluate_loc_desc call.
	(loclist_read_variable): Likewise.
	(locexpr_read_needs_frame): Update dwarf2_loc_desc_needs_frame call.

	* dwarf2read.c (dwarf2_symbol_mark_computed): Set baton->per_cu
	instead of baton->objfile.
	(dwarf2_per_cu_obfile): New function.
	(dwarf2_per_cu_addr_size): Likewise.

	* dwarf2-frame.c (struct comp_unit): Move higher.
	(struct dwarf2_cie): Add UNIT and ADDR_SIZE members.
	(execute_stack_op): Add ADDR_SIZE parameter; set ctx->addr_size.
	(execute_cfa_program): Add FDE parameter.  Replace EH_FRAME_P
	parameter by using fde->eh_frame_p.  Use read_encoded_value
	to implement DW_CFA_set_loc.
	(struct dwarf2_frame_cache): Add ADDR_SIZE member.
	(dwarf2_frame_cache): Set cache->addr_size.  Update calls to
	execute_stack_op and execute_cfa_program.
	(dwarf2_frame_prev_register): Update calls to execute_stack_op.
	(size_of_encoded_value): Remove.
	(read_encoded_value): Add PTR_LEN and FUNC_BASE parameters.
	Remove call to size_of_encoded_value.  Implement DW_EH_PE_funcrel.
	(add_cie): Set cie->unit backlink.
	(decode_frame_entry_1): Set cie->addr_size.  Update calls to
	read_encoded_value.
	(dwarf2_build_frame_info): Allocate UNIT on objfile obstack.
@
text
@d119 1
d123 2
a124 2
  regnum = gdbarch_dwarf2_reg_to_regnum (current_gdbarch, dwarf_regnum);
  result = address_from_register (builtin_type_void_data_ptr,
d463 4
a466 2
      int regno = gdbarch_dwarf2_reg_to_regnum
		    (current_gdbarch, dlbaton->data[0] - DW_OP_reg0);
d469 1
a469 1
			gdbarch_register_name (current_gdbarch, regno));
@


1.48
log
@	Updated copyright notices for most files.
@
text
@d57 2
a58 1
  unsigned int addr_size = gdbarch_addr_bit (current_gdbarch) / TARGET_CHAR_BIT;
d61 2
a62 2
  CORE_ADDR base_offset = ANOFFSET (baton->objfile->section_offsets,
				    SECT_OFF_TEXT (baton->objfile));
d70 4
a73 4
      low = dwarf2_read_address (loc_ptr, buf_end, &length);
      loc_ptr += length;
      high = dwarf2_read_address (loc_ptr, buf_end, &length);
      loc_ptr += length;
d193 1
a193 1
			  struct objfile *objfile)
d209 1
a209 1
  baton.objfile = objfile;
d212 1
d323 2
a324 1
dwarf2_loc_desc_needs_frame (gdb_byte *data, unsigned short size)
d333 1
d436 1
a436 1
				  dlbaton->objfile);
d446 2
a447 1
  return dwarf2_loc_desc_needs_frame (dlbaton->data, dlbaton->size);
d456 1
d486 1
a486 1
	int bytes_read;
d489 1
a489 1
						&bytes_read);
d493 1
a493 1
			  paddr_nz (offset), dlbaton->objfile->name);
d555 1
a555 1
				    dlbaton->objfile);
@


1.48.6.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@a267 42
// begin ARC
static CORE_ADDR
dwarf2_find_address (struct symbol *var, struct frame_info *frame,
                     gdb_byte *data, unsigned short size,
                     struct objfile *objfile)
{
  struct gdbarch *arch = get_frame_arch (frame);
  struct value *retval;
  struct dwarf_expr_baton baton;
  struct dwarf_expr_context *ctx;
  CORE_ADDR address;

  /* optimised out */
  if (size == 0)
     return 0;

  baton.frame   = frame;
  baton.objfile = objfile;

  ctx = new_dwarf_expr_context ();
  ctx->baton           = &baton;
  ctx->read_reg        = dwarf_expr_read_reg;
  ctx->read_mem        = dwarf_expr_read_mem;
  ctx->get_frame_base  = dwarf_expr_frame_base;
  ctx->get_tls_address = dwarf_expr_tls_address;

  dwarf_expr_eval (ctx, data, size);
  if (ctx->num_pieces > 0)
    {
      /* what should we do here? */
      address = 0;
    }
  else if (ctx->in_reg)
    address = 0;
  else
    address = dwarf_expr_fetch (ctx, 0);

  free_dwarf_expr_context (ctx);

  return address;
}

a268 34
static unsigned int
dwarf2_find_size (struct symbol *var, struct frame_info *frame,
                  gdb_byte *data, unsigned short size,
                  struct objfile *objfile)
{
  struct gdbarch *arch = get_frame_arch (frame);
  struct dwarf_expr_baton baton;
  struct dwarf_expr_context *ctx;
  unsigned int sz;

  /* optimised out */
  if (size == 0)
     return 0;

  baton.frame   = frame;
  baton.objfile = objfile;

  ctx = new_dwarf_expr_context ();
  ctx->baton           = &baton;
  ctx->read_reg        = dwarf_expr_read_reg;
  ctx->read_mem        = dwarf_expr_read_mem;
  ctx->get_frame_base  = dwarf_expr_frame_base;
  ctx->get_tls_address = dwarf_expr_tls_address;

  dwarf_expr_eval (ctx, data, size);
  if (ctx->num_pieces > 0)
    {
      /* what should we do here? */
      sz = 0;
    }
  else if (ctx->in_reg)
    sz = 0;
  else
    sz = TYPE_LENGTH (SYMBOL_TYPE (var));
a269 5
  free_dwarf_expr_context (ctx);

  return sz;
}
// end ARC
a436 24
// begin ARC
/* Return the address of SYMBOL in FRAME using the DWARF-2 expression
   evaluator to calculate the location.  */
static CORE_ADDR
locexpr_get_variable_address (struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);

  return dwarf2_find_address (symbol, frame, dlbaton->data, dlbaton->size,
                              dlbaton->objfile);
}

/* Return the size of SYMBOL in FRAME using the DWARF-2 expression
   evaluator to calculate the location.  */
static unsigned int
locexpr_get_variable_size(struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_locexpr_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);

  return dwarf2_find_size (symbol, frame, dlbaton->data, dlbaton->size,
                           dlbaton->objfile);
}
// end ARC

a518 4
// begin ARC
  locexpr_get_variable_address,
  locexpr_get_variable_size,
// end ARC
a553 40
// begin ARC
/* Return the address of SYMBOL in FRAME using the DWARF-2 expression
   evaluator to calculate the location.  */
static CORE_ADDR
loclist_get_variable_address (struct symbol *symbol, struct frame_info *frame)
{ 
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  struct value *val;
  gdb_byte *data;
  size_t size;

  data = find_location_expression (dlbaton, &size,
                                   frame ? get_frame_address_in_block (frame)
                                   : 0);
  if (data == NULL)
      return 0;

  return dwarf2_find_address(symbol, frame, data, size, dlbaton->objfile);
}

/* Return the size of SYMBOL in FRAME using the DWARF-2 expression
   evaluator to calculate the location.  */
static unsigned int
loclist_get_variable_size(struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  struct value *val;
  gdb_byte *data;
  size_t size;

  data = find_location_expression (dlbaton, &size,
                                   frame ? get_frame_address_in_block (frame)
                                   : 0);
  if (data == NULL)
      return 0;

  return dwarf2_find_size(symbol, frame, data, size, dlbaton->objfile);
}
// end ARC

a596 4
// begin ARC
  loclist_get_variable_address,
  loclist_get_variable_size,
// end ARC
@


1.47
log
@2007-10-08  Markus Deuling  <deuling@@de.ibm.com>

	* dwarf2-frame.c (read_reg, execute_cfa_program, dwarf2_frame_cache)
	(dwarf2_frame_default_init_reg, dwarf2_frame_prev_register): Replace
	current_gdbarch by gdbarch.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Likewise.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005, 2007 Free Software Foundation, Inc.
@


1.46
log
@	* dwarf2loc.c (dwarf_expr_frame_base): Guard against NULL.
	* Makefile.in (dwarf2loc.o): Depend on gdb_assert.h.
@
text
@d233 1
a233 1
				 (current_gdbarch, p->value);
d248 1
a248 1
			 (current_gdbarch, dwarf_regnum);
@


1.45
log
@        Switch the license of all .c files to GPLv3.
        Switch the license of all .h files to GPLv3.
        Switch the license of all .cc files to GPLv3.
@
text
@d40 1
d149 5
@


1.44
log
@2007-06-13  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_ADDR_BIT): Replace by gdbarch_addr_bit.
	* valops.c (value_cast): Likewise.
	* utils.c (strlen_paddr, paddr, paddr_nz, paddress): Likewise.
	* ui-out.c (ui_out_field_core_addr): Likewise.
	* tracepoint.c (tracepoints_info): Likewise.
	* symtab.c (print_msymbol_info): Likewise.
	* solib-irix.c (irix_current_sos)
	(irix_open_symbol_file_object): Likewise.
	* remote.c (build_remote_gdbarch_data): Likewise.
	* prologue-value.c (make_pv_area): Likewise.
	* procfs.c (info_mappings_callback): Likewise.
	* printcmd.c (print_scalar_formatted)
	(deprecated_print_address_numeric): Likewise.
	* memattr.c (mem_info_command): Likewise.
	* linux-nat.c (linux_nat_info_proc_cmd): Likewise.
	* gdbtypes.c (build_flt, gdbtypes_post_init): Likewise.
	* exec.c (print_section_info): Likewise.
	* dwarf2read.c (read_subrange_type): Likewise.
	* dwarf2loc.c (find_location_expression): Likewise.
	* dwarf2expr.c (dwarf2_read_address, unsigned_address_type)
	(signed_address_type, execute_stack_op): Likewise.
	* breakpoint.c (print_one_breakpoint, breakpoint_1): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d11 2
a12 2
   the Free Software Foundation; either version 2 of the License, or (at
   your option) any later version.
d14 4
a17 4
   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
d20 1
a20 3
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.  */
@


1.43
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (STAB_REG_TO_REGNUM): Replace by
	gdbarch_stab_reg_to_regnum.
	* stabsread.c (define_symbol): Likewise.
	* gdbarch.sh (ECOFF_REG_TO_REGNUM): Replace by
	gdbarch_ecoff_reg_to_regnum.
	* mdebugread.c (parse_symbol): Likewise.
	* i386-tdep.c (i386_gdbarch_init): Likewise (comment).
	* gdbarch.sh (DWARF_REG_TO_REGNUM): Replace by
	gdbarch_dwarf_reg_to_regnum.
	* gdbarch.sh (SDB_REG_TO_REGNUM): Replace by gdbarch_sdb_reg_to_regnum.
	* coffread.c (process_coff_symbol): Likewise.
	* gdbarch.sh (DWARF2_REG_TO_REGNUM): Replace by
	gdbarch_dwarf2_reg_to_regnum.
	* dwarf2loc.c (dwarf_expr_read_reg,dwarf2_evaluate_loc_desc)
	(locexpr_describe_location): Likewise.
	* dwarf2-frame.c (read_reg,execute_cfa_program,dwarf2_frame_cache)
	(dwarf2_frame_prev_register,dwarf2_signal_frame_this_id): Likewise.
	* dwarf2loc.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* dwarf2read.c (DWARF2_REG_TO_REGNUM): Remove macro.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d58 1
a58 1
  unsigned int addr_size = TARGET_ADDR_BIT / TARGET_CHAR_BIT;
@


1.42
log
@2007-06-12  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (TARGET_VIRTUAL_FRAME_POINTER): Replace by
	gdbarch_virtual_frame_pointer.
	* tracepoint.c (encode_actions): Likewise.
	* dwarf2loc.c (dwarf2_loc_desc_needs_frame): Likewise.
	* ax-gdb.c (gen_frame_args_address, gen_frame_locals_address): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@a42 4
#ifndef DWARF2_REG_TO_REGNUM
#define DWARF2_REG_TO_REGNUM(REG) (REG)
#endif

d122 1
a122 1
  regnum = DWARF2_REG_TO_REGNUM (dwarf_regnum);
d228 2
a229 1
	      int gdb_regnum = DWARF2_REG_TO_REGNUM (p->value);
d243 2
a244 1
      int gdb_regnum = DWARF2_REG_TO_REGNUM (dwarf_regnum);
d452 2
a453 1
      int regno = DWARF2_REG_TO_REGNUM (dlbaton->data[0] - DW_OP_reg0);
@


1.41
log
@2007-06-09  Markus Deuling  <deuling@@de.ibm.com>

	* gdbarch.sh (REGISTER_NAME): Replace by gdbarch_register_name.
	* tracepoint.c (scope_info): Likewise.
	* target.c (debug_print_register): Likewise.
	* stack.c (frame_info): Likewise.
	* sh-tdep.c (sh_register_reggroup_p): Likewise.
	* sh64-tdep.c (sh64_do_fp_register, sh64_do_register)
	(sh64_media_print_registers_info)
	(sh64_compact_print_registers_info): Likewise.
	* rs6000-tdep.c (rs6000_register_reggroup_p): Likewise.
	* remote-sim.c (gdbsim_fetch_register): Likewise.
	* remote.c (packet_reg): Likewise (comment).
	* reggroups.c (default_register_reggroup_p): Likewise.
	* regcache.c (regcache_dump): Likewise.
	* printcmd.c (address_info): Likewise.
	* ppc-linux-nat.c (fetch_register, store_register): Likewise.
	* mt-dep.c (mt_registers_info): Likewise.
	* mn10300-tdep.c (mn10300_dwarf2_reg_to_regnum): Likewise (comment).
	* mips-tdep.c (mips_register_reggroup_p, mips_read_fp_register_single)
	(mips_read_fp_register_double, mips_print_fp_register)
	(mips_print_register, print_gp_register_row, mips_print_registers_info)
	(mips_register_sim_regno): Likewise.
	* m68klinux-nat.c (regmap, fetch_register, store_register): Likewise.
	* inf-ptrace.c (inf_ptrace_fetch_register)
	(inf_ptrace_store_register): Likewise.
	* infcmd.c (default_print_registers_info): Likewise.
	* ia64-linux-nat.c (ia64_linux_fetch_register)
	(ia64_linux_store_register): Likewise.
	* i386-linux-nat.c (fetch_register, store_register): Likewise.
	* i386gnu-nat.c (gnu_fetch_registers, gnu_store_registers): Likewise.
	* hppa-linux-nat.c (fetch_register, store_register): Likewise.
	* hppa-hpux-nat.c (hppa_hpux_fetch_register)
	(hppa_hpux_store_register): Likewise.
	* findvar.c (locate_var_value): Likewise.
	* dwarf2loc.c (locexpr_describe_location): Likewise.
	* dwarf2-frame.c (execute_cfa_program): Likewise.
	* arm-tdep.c (arm_push_dummy_call): Likewise.
	* arch-utils.c (legacy_register_sim_regno): Likewise.
	* alpha-tdep.c (alpha_register_reggroup_p): Likewise.
	* alpha-nat.c (fetch_osf_core_registers): Likewise.
	* mi/mi-main.c (mi_cmd_data_list_register_names)
	(mi_cmd_data_list_changed_registers, mi_cmd_data_list_register_values)
	(mi_cmd_data_write_register_values): Likewise.
	* gdbarch.c, gdbarch.h: Regenerate.
@
text
@d390 2
a391 1
      TARGET_VIRTUAL_FRAME_POINTER (ax->scope, &frame_reg, &frame_offset);
@


1.40
log
@Add ability to report when a variable's value is uninitialized,
based on information provided by the compiler.  Also add new
DWARF OP, DW_OP_GNU_uninit, for this purpose.
@
text
@d455 2
a456 1
			"a variable in register %s", REGISTER_NAME (regno));
@


1.39
log
@2007-01-24  Jim Blandy  <jimb@@codesourcery.com>

	* dwarf2loc.c (dwarf2_evaluate_loc_desc): When the location
	expression is empty, bother to return the 'optimized out' value we
	construct.  (Thanks to Carl Burch.)
@
text
@d259 2
@


1.38
log
@Copyright updates for 2007.
@
text
@d204 1
@


1.37
log
@	* findvar.c (address_from_register): New function.
	* value.h (address_from_register): Add prototype.
	* dwarf2loc.c (dwarf_expr_read_reg): Use address_from_register.
@
text
@d3 1
a3 1
   Copyright (C) 2003, 2005 Free Software Foundation, Inc.
@


1.36
log
@2006-11-06  Jim Blandy  <jimb@@codesourcery.com>

	* (dwarf_expr_read_reg): Use frame_register_read, not frame_register.
	* dwarf2loc.c (dwarf_expr_read_reg): Use frame_register_read
	instead of frame_register.  Doc fix.
@
text
@d118 1
a118 1
   REGNUM, treated as an unsigned integer.  */
d124 1
a124 2
  gdb_byte *buf;
  int regnum, regsize;
d127 2
a128 8
  regsize = register_size (current_gdbarch, regnum);
  buf = alloca (regsize);

  frame_register_read (debaton->frame, regnum, buf);
  /* NOTE: cagney/2003-05-22: This extract is assuming that a DWARF 2
     address is always unsigned.  That may or may not be true.  */
  result = extract_unsigned_integer (buf, regsize);

@


1.36.2.1
log
@	* findvar.c (address_from_register): New function.
	* value.h (address_from_register): Add prototype.
	* dwarf2loc.c (dwarf_expr_read_reg): Use address_from_register.
@
text
@d118 1
a118 1
   REGNUM, treated as a pointer.  */
d124 2
a125 1
  int regnum;
d128 8
a135 2
  result = address_from_register (builtin_type_void_data_ptr,
				  regnum, debaton->frame);
@


1.35
log
@2006-11-03  Jim Blandy  <jimb@@codesourcery.com>

        * dwarf2loc.c (dwarf_expr_read_reg): Use frame_unwind_register
        instead of frame_register.  Doc fix.
@
text
@d123 1
a123 2
  CORE_ADDR result, save_addr;
  enum lval_type lval_type;
d125 1
a125 1
  int optimized, regnum, realnum, regsize;
d131 1
a131 1
  frame_unwind_register (debaton->frame, regnum, buf);
@


1.34
log
@2006-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* Makefile.in (expprint.o, parse.o, target.o): Update.
	* dwarf2loc.c (dwarf_expr_tls_address): Move body to
	target_translate_tls_address.  Call it.
	* eval.c (evaluate_subexp_standard): Handle UNOP_MEMVAL_TLS.
	* expprint.c (print_subexp_standard): Likewise.
	(op_name_standard, dump_subexp_body_standard): Likewise.
	* expression.h (enum exp_opcode): Add UNOP_MEMVAL_TLS.
	(union exp_element): Add objfile.
	* parse.c (write_exp_elt_objfile): New function.
	(msym_tls_symbol_type): New.
	(write_exp_msymbol): Handle TLS.
	(operator_length_standard): Handle UNOP_MEMVAL_TLS.
	(build_parse): Initialize msym_tls_symbol_type.
	* parser-defs.h (write_exp_elt_objfile): New prototype.
	* target.c (target_translate_tls_address): New.
	* target.h (target_translate_tls_address): Add prototype.

2006-10-09  Jan Kratochvil  <jan.kratochvil@@redhat.com>

	* gdb.threads/tls-nodebug.c, gdb.threads/tls-nodebug.exp: New test.
@
text
@d117 2
a118 3
/* Using the frame specified in BATON, read register REGNUM.  The lval
   type will be returned in LVALP, and for lval_memory the register
   save address will be returned in ADDRP.  */
d132 1
a132 2
  frame_register (debaton->frame, regnum, &optimized, &lval_type, &save_addr,
		  &realnum, buf);
@


1.33
log
@
	* breakpoint.c:
	* arm-tdep.c:
	* ia64-tdep.c:
	* i386-tdep.c:
	* hpread.c:
	* hppa-tdep.c:
	* hppa-hpux-tdep.c:
	* gnu-nat.c:
	* gdbtypes.c:
	* gdbarch.h:
	* gdbarch.c:
	* eval.c:
	* dwarf2read.c:
	* dbxread.c:
	* copying:
	* symfile.c:
	* stabsread.c:
	* sh64-tdep.c:
	* sh-tdep.c:
	* s390-tdep.c:
	* rs6000-tdep.c:
	* remote.c:
	* remote-mips.c:
	* mips-tdep.c:
	* mdebugread.c:
	* linux-nat.c:
	* infrun.c:
	* xcoffread.c:
	* win32-nat.c:
	* valops.c:
	* utils.c:
	* tracepoint.c:
	* target.c:
	* symtab.c:
	* c-exp.y:
	* ada-valprint.c:
	* ada-typeprint.c:
	* ada-lex.l:
	* ada-lang.h:
	* ada-lang.c:
	* ada-exp.y:
	* alphafbsd-tdep.c:
	* alphabsd-tdep.h:
	* alphabsd-tdep.c:
	* alphabsd-nat.c:
	* alpha-tdep.h:
	* alpha-tdep.c:
	* alpha-osf1-tdep.c:
	* alpha-nat.c:
	* alpha-mdebug-tdep.c:
	* alpha-linux-tdep.c:
	* alpha-linux-nat.c:
	* aix-thread.c:
	* abug-rom.c:
	* arch-utils.c:
	* annotate.h:
	* annotate.c:
	* amd64obsd-tdep.c:
	* amd64obsd-nat.c:
	* amd64nbsd-tdep.c:
	* amd64nbsd-nat.c:
	* amd64fbsd-tdep.c:
	* amd64fbsd-nat.c:
	* amd64bsd-nat.c:
	* amd64-tdep.h:
	* amd64-tdep.c:
	* amd64-sol2-tdep.c:
	* amd64-nat.h:
	* amd64-nat.c:
	* amd64-linux-tdep.c:
	* amd64-linux-nat.c:
	* alphanbsd-tdep.c:
	* block.h:
	* block.c:
	* bfd-target.h:
	* bfd-target.c:
	* bcache.h:
	* bcache.c:
	* ax.h:
	* ax-general.c:
	* ax-gdb.h:
	* ax-gdb.c:
	* avr-tdep.c:
	* auxv.h:
	* auxv.c:
	* armnbsd-tdep.c:
	* armnbsd-nat.c:
	* arm-tdep.h:
	* arm-linux-nat.c:
	* arch-utils.h:
	* charset.c:
	* call-cmds.h:
	* c-valprint.c:
	* c-typeprint.c:
	* c-lang.h:
	* c-lang.c:
	* buildsym.h:
	* buildsym.c:
	* bsd-uthread.h:
	* bsd-uthread.c:
	* bsd-kvm.h:
	* bsd-kvm.c:
	* breakpoint.h:
	* core-regset.c:
	* core-aout.c:
	* completer.h:
	* completer.c:
	* complaints.h:
	* complaints.c:
	* command.h:
	* coffread.c:
	* coff-solib.h:
	* coff-solib.c:
	* coff-pe-read.h:
	* coff-pe-read.c:
	* cli-out.h:
	* cli-out.c:
	* charset.h:
	* dink32-rom.c:
	* dictionary.h:
	* dictionary.c:
	* demangle.c:
	* defs.h:
	* dcache.h:
	* dcache.c:
	* d10v-tdep.c:
	* cpu32bug-rom.c:
	* cp-valprint.c:
	* cp-support.h:
	* cp-support.c:
	* cp-namespace.c:
	* cp-abi.h:
	* cp-abi.c:
	* corelow.c:
	* corefile.c:
	* environ.c:
	* elfread.c:
	* dwarfread.c:
	* dwarf2loc.c:
	* dwarf2expr.h:
	* dwarf2expr.c:
	* dwarf2-frame.h:
	* dwarf2-frame.c:
	* dve3900-rom.c:
	* dummy-frame.h:
	* dummy-frame.c:
	* dsrec.c:
	* doublest.h:
	* doublest.c:
	* disasm.h:
	* disasm.c:
	* fork-child.c:
	* findvar.c:
	* fbsd-nat.h:
	* fbsd-nat.c:
	* f-valprint.c:
	* f-typeprint.c:
	* f-lang.h:
	* f-lang.c:
	* expression.h:
	* expprint.c:
	* exec.h:
	* exec.c:
	* exceptions.h:
	* exceptions.c:
	* event-top.h:
	* event-top.c:
	* event-loop.h:
	* event-loop.c:
	* gdb.c:
	* gdb-stabs.h:
	* gdb-events.h:
	* gdb-events.c:
	* gcore.c:
	* frv-tdep.h:
	* frv-tdep.c:
	* frv-linux-tdep.c:
	* frame.h:
	* frame.c:
	* frame-unwind.h:
	* frame-unwind.c:
	* frame-base.h:
	* frame-base.c:
	* gdb_vfork.h:
	* gdb_thread_db.h:
	* gdb_string.h:
	* gdb_stat.h:
	* gdb_regex.h:
	* gdb_ptrace.h:
	* gdb_proc_service.h:
	* gdb_obstack.h:
	* gdb_locale.h:
	* gdb_dirent.h:
	* gdb_curses.h:
	* gdb_assert.h:
	* gdbarch.sh:
	* gdb.h:
	* hpux-thread.c:
	* hppabsd-nat.c:
	* hppa-tdep.h:
	* hpacc-abi.c:
	* h8300-tdep.c:
	* gregset.h:
	* go32-nat.c:
	* gnu-v3-abi.c:
	* gnu-v2-abi.h:
	* gnu-v2-abi.c:
	* gnu-nat.h:
	* glibc-tdep.c:
	* gdbtypes.h:
	* gdbcore.h:
	* gdbcmd.h:
	* i386nbsd-tdep.c:
	* i386nbsd-nat.c:
	* i386gnu-tdep.c:
	* i386gnu-nat.c:
	* i386fbsd-tdep.c:
	* i386fbsd-nat.c:
	* i386bsd-tdep.c:
	* i386bsd-nat.h:
	* i386bsd-nat.c:
	* i386-tdep.h:
	* i386-sol2-nat.c:
	* i386-nto-tdep.c:
	* i386-nat.c:
	* i386-linux-tdep.h:
	* i386-linux-tdep.c:
	* i386-linux-nat.c:
	* i386-cygwin-tdep.c:
	* inf-ttrace.c:
	* inf-ptrace.h:
	* inf-ptrace.c:
	* inf-loop.h:
	* inf-loop.c:
	* inf-child.h:
	* inf-child.c:
	* ia64-tdep.h:
	* ia64-linux-nat.c:
	* i387-tdep.h:
	* i387-tdep.c:
	* i386v4-nat.c:
	* i386v-nat.c:
	* i386obsd-tdep.c:
	* i386obsd-nat.c:
	* kod.c:
	* jv-valprint.c:
	* jv-typeprint.c:
	* jv-lang.h:
	* jv-lang.c:
	* irix5-nat.c:
	* iq2000-tdep.c:
	* interps.h:
	* interps.c:
	* inftarg.c:
	* inflow.h:
	* inflow.c:
	* inferior.h:
	* infcmd.c:
	* infcall.h:
	* infcall.c:
	* inf-ttrace.h:
	* m32r-tdep.h:
	* m32r-tdep.c:
	* m32r-rom.c:
	* m32r-linux-tdep.c:
	* m32r-linux-nat.c:
	* m2-valprint.c:
	* m2-typeprint.c:
	* m2-lang.h:
	* m2-lang.c:
	* lynx-nat.c:
	* linux-thread-db.c:
	* linux-nat.h:
	* linespec.c:
	* libunwind-frame.h:
	* libunwind-frame.c:
	* language.h:
	* language.c:
	* macroexp.c:
	* macrocmd.c:
	* m88kbsd-nat.c:
	* m88k-tdep.h:
	* m88k-tdep.c:
	* m68klinux-tdep.c:
	* m68klinux-nat.c:
	* m68kbsd-tdep.c:
	* m68kbsd-nat.c:
	* m68k-tdep.h:
	* m68k-tdep.c:
	* mips-linux-nat.c:
	* mips-irix-tdep.c:
	* minsyms.c:
	* memattr.h:
	* memattr.c:
	* mem-break.c:
	* mdebugread.h:
	* main.h:
	* main.c:
	* macrotab.h:
	* macrotab.c:
	* macroscope.h:
	* macroscope.c:
	* macroexp.h:
	* nbsd-tdep.c:
	* mt-tdep.c:
	* monitor.h:
	* monitor.c:
	* mn10300-tdep.h:
	* mn10300-tdep.c:
	* mn10300-linux-tdep.c:
	* mipsv4-nat.c:
	* mipsread.c:
	* mipsnbsd-tdep.h:
	* mipsnbsd-tdep.c:
	* mipsnbsd-nat.c:
	* mips64obsd-tdep.c:
	* mips64obsd-nat.c:
	* mips-tdep.h:
	* mips-mdebug-tdep.c:
	* mips-linux-tdep.c:
	* osabi.h:
	* osabi.c:
	* ocd.h:
	* ocd.c:
	* observer.c:
	* objfiles.h:
	* objfiles.c:
	* objc-lang.h:
	* objc-lang.c:
	* objc-exp.y:
	* nto-tdep.h:
	* nto-tdep.c:
	* nto-procfs.c:
	* nlmread.c:
	* nbsd-tdep.h:
	* ppcobsd-tdep.c:
	* ppcobsd-nat.c:
	* ppcnbsd-tdep.h:
	* ppcnbsd-tdep.c:
	* ppcnbsd-nat.c:
	* ppcbug-rom.c:
	* ppc-tdep.h:
	* ppc-sysv-tdep.c:
	* ppc-linux-tdep.c:
	* ppc-linux-nat.c:
	* ppc-bdm.c:
	* parser-defs.h:
	* parse.c:
	* p-valprint.c:
	* p-typeprint.c:
	* p-lang.h:
	* p-lang.c:
	* remote-fileio.h:
	* remote-fileio.c:
	* remote-est.c:
	* remote-e7000.c:
	* regset.h:
	* regset.c:
	* reggroups.h:
	* reggroups.c:
	* regcache.h:
	* regcache.c:
	* proc-why.c:
	* proc-service.c:
	* proc-events.c:
	* printcmd.c:
	* ppcobsd-tdep.h:
	* sentinel-frame.h:
	* sentinel-frame.c:
	* scm-valprint.c:
	* scm-tags.h:
	* scm-lang.h:
	* scm-lang.c:
	* scm-exp.c:
	* s390-tdep.h:
	* rom68k-rom.c:
	* remote.h:
	* remote-utils.c:
	* remote-st.c:
	* remote-sim.c:
	* remote-sds.c:
	* remote-rdp.c:
	* remote-rdi.c:
	* remote-hms.c:
	* sim-regno.h:
	* shnbsd-tdep.h:
	* shnbsd-tdep.c:
	* shnbsd-nat.c:
	* sh-tdep.h:
	* serial.h:
	* serial.c:
	* ser-unix.h:
	* ser-unix.c:
	* ser-tcp.c:
	* ser-pipe.c:
	* ser-go32.c:
	* ser-e7kpc.c:
	* ser-base.h:
	* ser-base.c:
	* solib.c:
	* solib-svr4.h:
	* solib-svr4.c:
	* solib-sunos.c:
	* solib-som.h:
	* solib-som.c:
	* solib-pa64.h:
	* solib-pa64.c:
	* solib-osf.c:
	* solib-null.c:
	* solib-legacy.c:
	* solib-irix.c:
	* solib-frv.c:
	* solib-aix5.c:
	* sol-thread.c:
	* sparc64-linux-tdep.c:
	* sparc64-linux-nat.c:
	* sparc-tdep.h:
	* sparc-tdep.c:
	* sparc-sol2-tdep.c:
	* sparc-sol2-nat.c:
	* sparc-nat.h:
	* sparc-nat.c:
	* sparc-linux-tdep.c:
	* sparc-linux-nat.c:
	* source.h:
	* source.c:
	* somread.c:
	* solist.h:
	* solib.h:
	* std-regs.c:
	* stack.h:
	* stack.c:
	* stabsread.h:
	* sparcobsd-tdep.c:
	* sparcnbsd-tdep.c:
	* sparcnbsd-nat.c:
	* sparc64obsd-tdep.c:
	* sparc64nbsd-tdep.c:
	* sparc64nbsd-nat.c:
	* sparc64fbsd-tdep.c:
	* sparc64fbsd-nat.c:
	* sparc64-tdep.h:
	* sparc64-tdep.c:
	* sparc64-sol2-tdep.c:
	* sparc64-nat.c:
	* ui-file.c:
	* typeprint.h:
	* typeprint.c:
	* tramp-frame.h:
	* tramp-frame.c:
	* trad-frame.h:
	* trad-frame.c:
	* tracepoint.h:
	* top.c:
	* tobs.inc:
	* thread.c:
	* terminal.h:
	* target.h:
	* symfile.h:
	* stop-gdb.c:
	* vaxbsd-nat.c:
	* vax-tdep.h:
	* vax-tdep.c:
	* vax-nat.c:
	* varobj.h:
	* varobj.c:
	* value.h:
	* value.c:
	* valprint.h:
	* valprint.c:
	* v850-tdep.c:
	* uw-thread.c:
	* user-regs.c:
	* ui-out.h:
	* ui-out.c:
	* ui-file.h:
	* xcoffsolib.h:
	* xcoffsolib.c:
	* wrapper.c:
	* wince.c:
	* wince-stub.h:
	* wince-stub.c:
	* vaxobsd-tdep.c:
	* vaxnbsd-tdep.c:
	* gdb_gcore.sh:
	* copying.c:
	* configure.ac:
	* aclocal.m4:
	* acinclude.m4:
	* reply_mig_hack.awk:
	* observer.sh:
	* gdb_mbuild.sh:
	* arm-linux-tdep.c:
	* blockframe.c:
	* dbug-rom.c:
	* environ.h:
	* dwarf2loc.h:
	* gdb-events.sh:
	* glibc-tdep.h:
	* gdb_wait.h:
	* gdbthread.h:
	* i386-sol2-tdep.c:
	* hppabsd-tdep.c:
	* hppa-linux-nat.c:
	* hppa-hpux-nat.c:
	* ia64-linux-tdep.c:
	* infptrace.c:
	* linespec.h:
	* maint.c:
	* mips-mdebug-tdep.h:
	* remote-m32r-sdi.c:
	* s390-nat.c:
	* rs6000-nat.c:
	* remote-utils.h:
	* sh3-rom.c:
	* sh-linux-tdep.c:
	* top.h:
	* symtab.h:
	* symmisc.c:
	* symfile-mem.c:
	* srec.h:
	* user-regs.h:
	* version.h:
	* valarith.c:
	* xstormy16-tdep.c:
	* wrapper.h:
	* Makefile.in:
	* f-exp.y:
	* cris-tdep.c:
	* cp-name-parser.y:
	* procfs.c:
	* proc-utils.h:
	* proc-flags.c:
	* proc-api.c:
	* p-exp.y:
	* m68hc11-tdep.c:
	* m2-exp.y:
	* kod.h:
	* kod-cisco.c:
	* jv-exp.y:
	* hppa-linux-tdep.c: Add (c) after Copyright.  Update the FSF
	address.
@
text
@a191 1
  volatile CORE_ADDR addr = 0;
d193 1
a193 78
  if (target_get_thread_local_address_p ()
      && gdbarch_fetch_tls_load_module_address_p (current_gdbarch))
    {
      ptid_t ptid = inferior_ptid;
      struct objfile *objfile = debaton->objfile;
      volatile struct gdb_exception ex;

      TRY_CATCH (ex, RETURN_MASK_ALL)
	{
	  CORE_ADDR lm_addr;
	  
	  /* Fetch the load module address for this objfile.  */
	  lm_addr = gdbarch_fetch_tls_load_module_address (current_gdbarch,
	                                                   objfile);
	  /* If it's 0, throw the appropriate exception.  */
	  if (lm_addr == 0)
	    throw_error (TLS_LOAD_MODULE_NOT_FOUND_ERROR,
			 _("TLS load module not found"));

	  addr = target_get_thread_local_address (ptid, lm_addr, offset);
	}
      /* If an error occurred, print TLS related messages here.  Otherwise,
         throw the error to some higher catcher.  */
      if (ex.reason < 0)
	{
	  int objfile_is_library = (objfile->flags & OBJF_SHARED);

	  switch (ex.error)
	    {
	    case TLS_NO_LIBRARY_SUPPORT_ERROR:
	      error (_("Cannot find thread-local variables in this thread library."));
	      break;
	    case TLS_LOAD_MODULE_NOT_FOUND_ERROR:
	      if (objfile_is_library)
		error (_("Cannot find shared library `%s' in dynamic"
		         " linker's load module list"), objfile->name);
	      else
		error (_("Cannot find executable file `%s' in dynamic"
		         " linker's load module list"), objfile->name);
	      break;
	    case TLS_NOT_ALLOCATED_YET_ERROR:
	      if (objfile_is_library)
		error (_("The inferior has not yet allocated storage for"
		         " thread-local variables in\n"
		         "the shared library `%s'\n"
		         "for %s"),
		       objfile->name, target_pid_to_str (ptid));
	      else
		error (_("The inferior has not yet allocated storage for"
		         " thread-local variables in\n"
		         "the executable `%s'\n"
		         "for %s"),
		       objfile->name, target_pid_to_str (ptid));
	      break;
	    case TLS_GENERIC_ERROR:
	      if (objfile_is_library)
		error (_("Cannot find thread-local storage for %s, "
		         "shared library %s:\n%s"),
		       target_pid_to_str (ptid),
		       objfile->name, ex.message);
	      else
		error (_("Cannot find thread-local storage for %s, "
		         "executable file %s:\n%s"),
		       target_pid_to_str (ptid),
		       objfile->name, ex.message);
	      break;
	    default:
	      throw_exception (ex);
	      break;
	    }
	}
    }
  /* It wouldn't be wrong here to try a gdbarch method, too; finding
     TLS is an ABI-specific thing.  But we don't do that yet.  */
  else
    error (_("Cannot find thread-local variables on this target"));

  return addr;
@


1.32
log
@2005-11-19  Randolph Chung  <tausq@@debian.org>

	* dwarf2loc.c (dwarf2_tracepoint_var_ref): Remove extra add for
	DW_OP_fbreg.  Handle DW_OP_breg0 through DW_OP_breg31.  Print
	DWARF opcode for unsupported case.
@
text
@d3 1
a3 1
   Copyright 2003, 2005 Free Software Foundation, Inc.
d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.31
log
@Fix gcc bug 24490, location list query failed due to out-of-range address.
PR 2024
* dwarf2loc.c (dwarf_expr_frame_base): Use get_frame_address_in_block
instead of get_frame_pc.
(loclist_read_variable): Likewise.
@
text
@d480 17
a496 1
      ax_const_l (ax, frame_offset);
d498 1
d502 2
a503 2
    error (_("Unsupported DWARF opcode in the location of \"%s\"."),
	   SYMBOL_PRINT_NAME (symbol));
@


1.30
log
@2005-11-03 Andrew Cagney  <cagney@@gnu.org>

       Checked in by Elena Zannoni  <ezannoni@@redhat.com>

       * dwarf2loc.c (dwarf2_evaluate_loc_desc): Handle DW_OP_piece
       reads.
@
text
@d167 2
d171 1
a171 1
					 get_frame_pc (debaton->frame));
d602 2
a603 1
				   frame ? get_frame_pc (frame) : 0);
@


1.29
log
@* dwarf2expr.h: Tweak comment.
(struct dwarf_expr_context): Use `gdb_byte *' in read_mem and
get_frame_base function pointers.
(read_uleb128, read_sleb128): Change return type and types of
first two arguments to `gdb_byte *'.
(dwarf2_read_address): Change types of first two arguments to
`gdb_byte *'.
* dwarf2expr.c: Tweak comment.
(dwarf_expr_eval): Change type of second argument to `gdb_byte *'.
(read_uleb128, read_sleb128): Change return type and types of
first two arguments to `gdb_byte *'.
(dwarf2_read_address): Change types of first two arguments to
`gdb_byte *'.
(execute_stack_op): Change types of last two arguments to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.
* dwarf2loc.h: Tweak comment.
(struct dwarf2_locexpr_baton, struct dwarf2_loclist_baton): Use
`gdb_byte *' for byte buffers.
* dwarf2loc.c (find_location_expression): Change return type to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.  Change length
to `unsigned int'.
(dwarf_expr_read_reg): Use `gdb_byte *' for byte buffer.  Remove
bogus cast.
(dwarf_expr_read_mem): Change type of second argument to
`gdb_byte *'.
(dwarf_expr_frame_base): Change type of second argument to
`gdb_byte **'.
(dwarf2_evaluate_loc_desc): Change type of third argument to
`gdb_byte *'.
(needs_frame_read_mem): Change type of second argument to
`gdb_byte *'.
(needs_frame_frame_base): Change type of second argument
`gdb_byte **'.  Use gdb_byte for lit0.
(dwarf2_tracepoint_var_ref): Change type of fourth argument to
`gdb_byte *'.  Use `gdb_byte *' for byte buffer.
(loclist_read_variable, loclist_tracepoint_var_ref): Use `gdb_byte
*' for byte buffer.
* dwarf2-frame.c (struct dwarf2_cie, struct dwarf2_fde)
(struct dwarf2_frame_state): Use gdb_byte instead of `unsigned
char'.
(read_reg): Use `gdb_byte *' for byte buffers.  Remove redundant
cast.
(read_mem): Change second argument to `gdb_byte *'.
(no_get_frame_base): Change second argument to `gdb_byte **'.
(execute_stack_op): Change first argument to `gdb_byte *'.
(execute_cfa_program): Change first two arguments to `gdb_byte *'.
Use gdb_byte instead of `unsigned int'.  Use temprorary variable
to store result of read_uleb128.
(struct comp_unit): Use `gdb_byte *' for byte buffers.
(read_1_byte, read_4_bytes, read_8_bytes): Change last argument to
`gdb_byte *'.
(read_unsigned_leb128, read_signed_leb128): Change second argument
to `gdb_byte *'.  Use gdb_byte instead of `unsigned char'.
(read_initial_length): Change second argument to `gdb_byte *'.
Remove redundant casts.
(read_encoded_value): Use gdb_byte instead of `unsigned char'.
Remove bogus casts.
(decode_frame_entry_1): Change return type and second argument to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.  Use gdb_byte
instead of `unsigned char'.
(decode_frame_entry): Change return type and second argument to
`gdb_byte *'.  Use `gdb_byte *' for byte buffers.
(dwarf2_build_frame_info): Use `gdb_byte *' for byte buffers.
@
text
@d305 22
a326 5
      /* We haven't implemented splicing together pieces from
         arbitrary sources yet.  */
      error (_("The value of variable '%s' is distributed across several\n"
             "locations, and GDB cannot access its value.\n"),
             SYMBOL_NATURAL_NAME (var));
@


1.29.4.1
log
@2005-11-03 Andrew Cagney  <cagney@@gnu.org>

	Checked in by Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Handle DW_OP_piece
	reads.
@
text
@d305 5
a309 22
      int i;
      long offset = 0;
      bfd_byte *contents;

      retval = allocate_value (SYMBOL_TYPE (var));
      contents = value_contents_raw (retval);
      for (i = 0; i < ctx->num_pieces; i++)
	{
	  struct dwarf_expr_piece *p = &ctx->pieces[i];
	  if (p->in_reg)
	    {
	      bfd_byte regval[MAX_REGISTER_SIZE];
	      int gdb_regnum = DWARF2_REG_TO_REGNUM (p->value);
	      get_frame_register (frame, gdb_regnum, regval);
	      memcpy (contents + offset, regval, p->size);
	    }
	  else /* In memory?  */
	    {
	      read_memory (p->value, contents + offset, p->size);
	    }
	  offset += p->size;
	}
@


1.29.4.2
log
@Fix gcc bug 24490, location list query failed due to out-of-range address.
PR 2024
* dwarf2loc.c (dwarf_expr_frame_base): Use get_frame_address_in_block
instead of get_frame_pc.
(loclist_read_variable): Likewise.
@
text
@a166 2
      struct frame_info *frame = debaton->frame;

d169 1
a169 1
					 get_frame_address_in_block (frame));
d600 1
a600 2
				   frame ? get_frame_address_in_block (frame)
				   : 0);
@


1.28
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	* remote.c (remote_open_1): Move "ex"'s declaration to where it is
	used.
	(remote_get_thread_local_address): Use throw_error, include a
	printed string.
	* linux-thread-db.c (thread_db_get_thread_local_address): Ditto.
	* dwarf2loc.c (dwarf_expr_tls_address): Ditto.
	* cli/cli-script.c (script_from_file): Mark up throw_error message.
	* linespec.c (symtab_from_filename, decode_variable): Ditto.
@
text
@d55 1
a55 1
static char *
d60 3
a62 2
  char *loc_ptr, *buf_end;
  unsigned int addr_size = TARGET_ADDR_BIT / TARGET_CHAR_BIT, length;
d126 1
a126 1
  char *buf;
d131 1
a131 1
  buf = (char *) alloca (regsize);
d145 1
a145 1
dwarf_expr_read_mem (void *baton, char *buf, CORE_ADDR addr, size_t len)
d154 1
a154 1
dwarf_expr_frame_base (void *baton, unsigned char **start, size_t * length)
d277 1
a277 1
			  unsigned char *data, unsigned short size,
d354 1
a354 1
needs_frame_read_mem (void *baton, char *buf, CORE_ADDR addr, size_t len)
d361 1
a361 1
needs_frame_frame_base (void *baton, unsigned char **start, size_t * length)
d363 1
a363 1
  static char lit0 = DW_OP_lit0;
d385 1
a385 1
dwarf2_loc_desc_needs_frame (unsigned char *data, unsigned short size)
d421 2
a422 2
dwarf2_tracepoint_var_ref (struct symbol * symbol, struct agent_expr * ax,
			   struct axs_value * value, unsigned char *data,
d449 1
a449 1
      unsigned char *buf_end;
d579 1
a579 1
  unsigned char *data;
d626 1
a626 1
  unsigned char *data;
@


1.27
log
@2005-04-26  Andrew Cagney  <cagney@@gnu.org>

	Rename 'struct exception' to 'struct gdb_exception'.
	* wrapper.c: Update.
	* varobj.c: Update.
	* tui/tui-interp.c: Update.
	* remote.c: Update.
	* mi/mi-main.c: Update.
	* mi/mi-interp.c: Update.
	* linux-thread-db.c: Update.
	* interps.h: Update.
	* interps.c: Update.
	* exceptions.h: Update.
	* exceptions.c: Update.
	* dwarf2loc.c: Update.
	* cli/cli-interp.c: Update.
	* cli/cli-script.c: Update.
	* breakpoint.c: Update.
@
text
@d207 2
a208 6
	    {
	      struct gdb_exception e
		= { RETURN_ERROR, TLS_LOAD_MODULE_NOT_FOUND_ERROR, 0 };

	      throw_exception (e);
	    }
@


1.26
log
@	* gdbarch.sh (fetch_tls_load_module_address): New architecture method.
	* gdbarch.c, gdbarch.h: Regenerate.
	* dwarf2loc.c (dwarf_expr_tls_address): Fetch TLS load module
	address and pass this address, instead of the objfile address, to
	target_get_thread_local_address().
	* linux-thread-db.c (thread_db_get_thread_local_address): Change
	second parameter from type ``struct objfile *'' to CORE_ADDR.  Do
	not call svr4_fetch_objfile_link_map() to fetch the load module
	address.
	* target.h (struct target_ops): Change second parameter of
	``to_get_thread_local_address'' from ``struct objfile *'' to
	``CORE_ADDR''.
	* alpha-linux-tdep.c (solib-svr4.h): Include.
	(alpha_linux_init_abi): Register TLS load module fetcher.
	* amd64-linux-tdep.c (amd64_linux_init_abi): Likewise.
	* hppa-linux-tdep.c (hppa_linux_init_abi): Likewise.
	* i386-linux-tdep.c (i386_linux_init_abi): Likewise.
	* ia64-linux-tdep.c (solib-svr4.h): Include.
	(ia64_linux_init_abi): Register TLS load module fetcher.
	* m32r-linux-tdep.c (m32r_linux_init_abi): Likewise.
	* m68klinux-tdep.c (m68k_linux_init_abi): Likewise.
	* mips-linux-tdep.c (mips_linux_init_abi): Likewise.
	* s390-tdep.c (s390_gdbarch_init): Likewise.
	* sparc-linux-tdep.c (sparc32_linux_init_abi): Likewise.
	* sparc64-linux-tdep.c (solib-svr4.h): Include.
	(sparc64_linux_init_abi): Register TLS load module fetcher.
	* Makefile.in (alpha-linux-tdep.o, ia64-linux-tdep.o)
	(sparc-linux-tdep.o): Update dependencies.
@
text
@d196 1
a196 1
      volatile struct exception ex;
d208 1
a208 1
	      struct exception e
@


1.25
log
@* dwarf2loc.c (dwarf_expr_tls_address): Mark addr as volatile.
* varobj.c (my_value_equal): Mark val2 as volatile.
@
text
@d191 2
a192 1
  if (target_get_thread_local_address_p ())
d200 15
a214 1
	  addr = target_get_thread_local_address (ptid, objfile, offset);
@


1.24
log
@	* dwarf2loc.c (dwarf_expr_tls_address): Initialize ADDR.
	* gnu-v3-abi.c (gnuv3_baseclass_offset): Update type of
	VALADDR.
@
text
@d189 1
a189 1
  CORE_ADDR addr = 0;
@


1.23
log
@Move printing of TLS related error messages to dwarf2loc.c.
@
text
@d189 1
a189 1
  CORE_ADDR addr;
@


1.22
log
@	* dwarf2loc.c (loclist_read_variable): Set optimized_out
	instead of reporting an error.
	* valprint.c (value_check_printable): New function.
	(common_val_print): New function.  Use value_check_printable.
	(value_print): Use value_check_printable.
	* value.h (common_val_print): Add prototype.

	* c-valprint.c (c_val_print): Use common_val_print.
	* cp-valprint.c (cp_print_value_fields): Likewise.
	(cp_print_hpacc_virtual_table_entries): Likewise.
	* f-valprint.c (f_val_print): Likewise.
	* jv-valprint.c (java_value_print, java_print_value_fields):
	Likewise.
	* scm-valprint.c (scm_value_print): Likewise.
	* stack.c (print_frame_args): Likewise.
	* varobj.c (c_value_of_variable): Likewise.
	* p-valprint.c (pascal_val_print, pascal_value_print): Likewise.
	(pascal_object_print_value_fields): Likewise.  Update call to
	pascal_object_print_static_field.
	(pascal_object_print_static_field): Remove TYPE argument.  Use
	common_val_print.
@
text
@d35 1
d192 60
a251 3
    addr = target_get_thread_local_address (inferior_ptid,
					    debaton->objfile,
					    offset);
@


1.21
log
@2005-02-10  Andrew Cagney  <cagney@@gnu.org>

	Mark up all error and warning messages.
	* ada-lang.c, amd64-tdep.c, arch-utils.c, breakpoint.c: Update.
	* bsd-kvm.c, bsd-uthread.c, coff-solib.h, coffread.c: Update.
	* core-aout.c, core-regset.c, corefile.c, corelow.c: Update.
	* cp-abi.c, cp-support.c, cp-valprint.c, cris-tdep.c: Update.
	* dbxread.c, demangle.c, doublest.c, dsrec.c: Update.
	* dve3900-rom.c, dwarf2expr.c, dwarf2loc.c: Update.
	* dwarf2read.c, dwarfread.c, elfread.c, eval.c: Update.
	* event-top.c, exec.c, expprint.c, f-lang.c: Update.
	* f-typeprint.c, f-valprint.c, fbsd-nat.c, findvar.c: Update.
	* frame.c, frv-linux-tdep.c, gcore.c, gdbtypes.c: Update.
	* gnu-nat.c, gnu-v2-abi.c, gnu-v3-abi.c, go32-nat.c: Update.
	* hpacc-abi.c, hppa-hpux-nat.c, hppa-hpux-tdep.c: Update.
	* hppa-linux-nat.c, hppa-linux-tdep.c, hppa-tdep.c: Update.
	* hpread.c, hpux-thread.c, i386-linux-nat.c: Update.
	* i386-linux-tdep.c, i386-tdep.c, i386bsd-nat.c: Update.
	* i386gnu-nat.c, i387-tdep.c, ia64-linux-nat.c: Update.
	* ia64-tdep.c, inf-child.c, inf-ptrace.c, inf-ttrace.c: Update.
	* infcall.c, infcmd.c, inflow.c, infptrace.c, infrun.c: Update.
	* inftarg.c, interps.c, irix5-nat.c, jv-lang.c: Update.
	* kod-cisco.c, kod.c, language.c, libunwind-frame.c: Update.
	* linespec.c, linux-nat.c, linux-thread-db.c, m2-lang.c: Update.
	* m32r-rom.c, m68hc11-tdep.c, m68k-tdep.c: Update.
	* m68klinux-nat.c, macrocmd.c, macroexp.c, main.c: Update.
	* maint.c, mdebugread.c, mem-break.c, memattr.c: Update.
	* mips-linux-tdep.c, mips-tdep.c, mipsread.c, monitor.c: Update.
	* nlmread.c, nto-procfs.c, objc-lang.c, objfiles.c: Update.
	* observer.c, ocd.c, p-lang.c, p-typeprint.c: Update.
	* p-valprint.c, pa64solib.c, parse.c, ppc-linux-tdep.c: Update.
	* ppcnbsd-tdep.c, printcmd.c, procfs.c, remote-e7000.c: Update.
	* remote-fileio.c, remote-m32r-sdi.c, remote-rdi.c: Update.
	* remote-rdp.c, remote-sim.c, remote-st.c: Update.
	* remote-utils.c, remote-utils.h, remote.c: Update.
	* rom68k-rom.c, rs6000-nat.c, s390-tdep.c, scm-lang.c: Update.
	* ser-e7kpc.c, ser-tcp.c, ser-unix.c, sh-tdep.c: Update.
	* sh3-rom.c, shnbsd-tdep.c, sol-thread.c, solib-aix5.c: Update.
	* solib-frv.c, solib-irix.c, solib-osf.c, solib-pa64.c: Update.
	* solib-som.c, solib-sunos.c, solib-svr4.c, solib.c: Update.
	* somread.c, somsolib.c, source.c, stabsread.c: Update.
	* stack.c, std-regs.c, symfile-mem.c, symfile.c: Update.
	* symmisc.c, symtab.c, target.c, thread.c, top.c: Update.
	* tracepoint.c, trad-frame.c, typeprint.c, utils.c: Update.
	* uw-thread.c, valarith.c, valops.c, valprint.c: Update.
	* value.c, varobj.c, version.in, win32-nat.c, wince.c: Update.
	* xcoffread.c, xcoffsolib.c, cli/cli-cmds.c: Update.
	* cli/cli-decode.c, cli/cli-dump.c, cli/cli-logging.c: Update.
	* cli/cli-script.c, cli/cli-setshow.c, mi/mi-cmd-break.c: Update.
	* mi/mi-cmd-disas.c, mi/mi-cmd-env.c, mi/mi-cmd-file.c: Update.
	* mi/mi-cmd-stack.c, mi/mi-cmd-var.c, mi/mi-getopt.c: Update.
	* mi/mi-symbol-cmds.c, tui/tui-layout.c, tui/tui-stack.c: Update.
	* tui/tui-win.c: Update.
@
text
@d515 8
a522 3
    error (_("Variable \"%s\" is not available."), SYMBOL_NATURAL_NAME (symbol));

  val = dwarf2_evaluate_loc_desc (symbol, frame, data, size, dlbaton->objfile);
@


1.20
log
@2005-02-07  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_LAZY): Delete
	(set_value_lazy): Declare.
	* value.c (set_value_lazy): Define.
	* valops.c, valarith.c, jv-valprint.c, jv-lang.c: Update.
	* gnu-v2-abi.c, findvar.c, dwarf2loc.c, ada-lang.c: Update.
@
text
@d178 1
a178 1
    error ("Could not find the frame base for \"%s\".",
d197 1
a197 1
    error ("Cannot find thread-local variables on this target");
d237 2
a238 2
      error ("The value of variable '%s' is distributed across several\n"
             "locations, and GDB cannot access its value.\n",
d356 1
a356 1
    error ("Symbol \"%s\" has been optimized out.",
d383 1
a383 1
	error ("Unexpected opcode after DW_OP_fbreg for symbol \"%s\".",
d396 1
a396 1
    error ("Unsupported DWARF opcode in the location of \"%s\".",
d515 1
a515 1
    error ("Variable \"%s\" is not available.", SYMBOL_NATURAL_NAME (symbol));
d556 1
a556 1
    error ("Variable \"%s\" is not available.", SYMBOL_NATURAL_NAME (symbol));
@


1.19
log
@2005-02-06  Andrew Cagney  <cagney@@gnu.org>

	* value.h (VALUE_OPTIMIZED_OUT): Delete.
	(value_optimized_out, set_value_optimized_out): Declare.
	* value.c (set_value_optimized_out, value_optimized_out): Define.
	* valprint.c, findvar.c, dwarf2loc.c: Update.
@
text
@d253 1
a253 1
      VALUE_LAZY (retval) = 1;
@


1.18
log
@2004-11-09  Andrew Cagney  <cagney@@gnu.org>

	* value.h (struct value): Delete field bfd_section.
	(VALUE_BFD_SECTION): Delete macro.
	(COERCE_REF): Update.
	(value_at, value_at_lazy): Delete asection parameter.
	* printcmd.c (print_formatted, x_command): Update.
	(do_examine): Delete asection parameter.
	(next_section): Delete variable.
	* valops.c (value_cast, value_at, value_at_lazy)
	(value_coerce_function, value_addr, value_ind, value_string)
	(find_rt_vbase_offset, value_full_object): Update.
	* hpacc-abi.c (hpacc_virtual_fn_field)
	(hpacc_value_rtti_type): Update.
	* gnu-v3-abi.c (gnuv3_rtti_type, gnuv3_virtual_fn_field)
	(gnuv3_baseclass_offset): Update.
	* f-valprint.c (f_val_print): Update.
	* c-valprint.c (c_val_print): Update.
	* p-valprint.c (pascal_val_print): Update.
	* jv-valprint.c (java_value_print): Update.
	* jv-lang.c (java_class_from_object, evaluate_subexp_java): Update.
	* ada-lang.c (ada_value_primitive_packed_val)
	(ada_evaluate_subexp): Update.
	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Update.
	* expprint.c (print_subexp_standard): Update.
	* infcall.c (call_function_by_hand): Update.
	* valarith.c (value_add): Update.
	* eval.c (evaluate_subexp_standard): Update.
	* values.c (allocate_value, value_copy, value_static_field): Update.
	* findvar.c (read_var_value, locate_var_value): Update.
@
text
@d2 3
a4 1
   Copyright 2003 Free Software Foundation, Inc.
d219 1
a219 1
      VALUE_OPTIMIZED_OUT (retval) = 1;
@


1.17
log
@* dwarf2expr.h (struct dwarf_expr_context): New members
'num_pieces' and 'pieces', for returning the result of an
expression that uses DW_OP_piece.
(struct dwarf_expr_piece): New struct type.
* dwarf2expr.c (new_dwarf_expr_context): Initialize num_pieces and
pieces.
(free_dwarf_expr_context): Free pieces, if any.
(add_piece): New function.
(execute_stack_op): Implement DW_OP_piece.
* dwarf2loc.c (dwarf2_evaluate_loc_desc): If the result of the
expression is a list of pieces, print an error message.
(dwarf2_loc_desc_needs_frame): If the expression yields
pieces, and any piece is in a register, then we need a frame.
@
text
@a249 2
      VALUE_BFD_SECTION (retval) = SYMBOL_BFD_SECTION (var);

@


1.16
log
@* dwarf2loc.c (dwarf2_evaluate_loc_desc): Wait to fetch the top of
the stack until we've decided what sort of result the evaluation
has produced.  Use separate variables, with more specific names.
@
text
@d208 1
d231 9
a239 2

  if (ctx->in_reg)
d334 11
@


1.15
log
@2004-05-13  Bryce McKinlay  <mckinlay@@redhat.com>

	* dwarf2loc.c (find_location_expression): Use ANOFFSET to adjust
	base_address for shared libraries.
@
text
@a207 1
  CORE_ADDR result;
a229 1
  result = dwarf_expr_fetch (ctx, 0);
d233 3
a235 2
      int regnum = DWARF2_REG_TO_REGNUM (result);
      retval = value_from_register (SYMBOL_TYPE (var), regnum, frame);
d239 2
d246 1
a246 1
      VALUE_ADDRESS (retval) = result;
@


1.15.4.1
log
@Merge changes from trunk:

2004-08-24  Jim Blandy  <jimb@@redhat.com>

* dwarf2expr.h (struct dwarf_expr_context): New members
'num_pieces' and 'pieces', for returning the result of an
expression that uses DW_OP_piece.
(struct dwarf_expr_piece): New struct type.
* dwarf2expr.c (new_dwarf_expr_context): Initialize num_pieces and
pieces.
(free_dwarf_expr_context): Free pieces, if any.
(add_piece): New function.
(execute_stack_op): Implement DW_OP_piece.
* dwarf2loc.c (dwarf2_evaluate_loc_desc): If the result of the
expression is a list of pieces, print an error message.
(dwarf2_loc_desc_needs_frame): If the expression yields
pieces, and any piece is in a register, then we need a frame.

* dwarf2loc.c (dwarf2_evaluate_loc_desc): Wait to fetch the top of
the stack until we've decided what sort of result the evaluation
has produced.  Use separate variables, with more specific names.
@
text
@d208 1
a208 1
  struct gdbarch *arch = get_frame_arch (frame);
d231 1
d233 1
a233 1
  if (ctx->num_pieces > 0)
d235 2
a236 10
      /* We haven't implemented splicing together pieces from
         arbitrary sources yet.  */
      error ("The value of variable '%s' is distributed across several\n"
             "locations, and GDB cannot access its value.\n",
             SYMBOL_NATURAL_NAME (var));
    }
  else if (ctx->in_reg)
      CORE_ADDR dwarf_regnum = dwarf_expr_fetch (ctx, 0);
      int gdb_regnum = DWARF2_REG_TO_REGNUM (dwarf_regnum);
      retval = value_from_register (SYMBOL_TYPE (var), gdb_regnum, frame);
a239 2
      CORE_ADDR address = dwarf_expr_fetch (ctx, 0);

d245 1
a245 1
      VALUE_ADDRESS (retval) = address;
a324 11
  if (ctx->num_pieces > 0)
    {
      int i;

      /* If the location has several pieces, and any of them are in
         registers, then we will need a frame to fetch them from.  */
      for (i = 0; i < ctx->num_pieces; i++)
        if (ctx->pieces[i].in_reg)
          in_reg = 1;
    }

@


1.15.4.2
log
@* rs6000-tdep.c: #include "dwarf2expr.h".
(dwarf_piece_is_ev_upper_reg, dwarf_piece_is_gpr)
(e500_dwarf_simplify_register_pieces): New functions.
(rs6000_gdbarch_init): If the architecture is E500, register
e500_dwarf_simplify_register_pieces.
* Makefile.in (rs6000-tdep.o): Update dependencies.

* gdbarch.sh (dwarf_simplify_register_pieces): New method.
Add forward declaration for 'struct dwarf_expr_piece'.
* gdbarch.c, gdbarch.h: Regenerated.
* dwarf2loc.c (dwarf2_evaluate_loc_desc): Try to simplify
multi-piece expression results before giving up.
* arch-utils.c (dwarf_never_simplify_pieces): New function.
* arch-utils.h (struct dwarf_expr_piece): Forward decl for struct
type, used in ...
(dwarf_never_simplify_pieces): New declaration.
@
text
@d234 5
a238 12
      CORE_ADDR simplified
        = gdbarch_dwarf_simplify_register_pieces (arch, ctx->num_pieces,
                                                  ctx->pieces);
      if (simplified >= 0)
        retval = value_from_register (SYMBOL_TYPE (var), simplified, frame);

      /* We haven't implemented the more complex case of splicing
         together pieces from arbitrary sources yet.  */
      else
        error ("The value of variable '%s' is distributed across several\n"
               "locations, and GDB cannot access its value.\n",
               SYMBOL_NATURAL_NAME (var));
@


1.15.4.2.2.1
log
@* dwarf2loc.c (dwarf2_evaluate_loc_desc): Fix misapplied patch.
@
text
@a247 1
    {
@


1.14
log
@2004-01-26  Andrew Cagney  <cagney@@redhat.com>

	* dwarf2loc.c (dwarf_expr_frame_base): Use SYMBOL_OPS instead of
	SYMBOL_LOCATION_FUNCS
	(dwarf2_loclist_funcs, dwarf2_locexpr_funcs): Change type to
	"struct symbol_ops".
	* dwarf2loc.h (dwarf2_locexpr_funcs, dwarf2_loclist_funcs): Change
	type to "struct symbol_ops".
	* symtab.h (struct symbol_ops): Rename "struct location_funcs".
	(struct symbol): Replace ".aux_value.loc.funcs" and
	".aux_value.loc.baton" with ".ops" and ".aux_value.ptr".
	(SYMBOL_OBJFILE): Delete macro.
	(SYMBOL_LOCATION_FUNCS): Delete macro.
	(SYMBOL_LOCATION_BATON): Update.
	* dwarf2read.c (dwarf2_symbol_mark_computed): Set SYMBOL_OPS
	intead of SYMBOL_LOCATION_FUNCS.
	* ax-gdb.c (gen_var_ref): Ditto.
	* printcmd.c (address_info): Ditto.
	* findvar.c (read_var_value): Ditto.
	(symbol_read_needs_frame): Ditto.
@
text
@a55 1
  CORE_ADDR base_address = baton->base_address;
d60 4
@


1.14.4.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d56 1
a60 4
  /* Adjust base_address for relocatable objects.  */
  CORE_ADDR base_offset = ANOFFSET (baton->objfile->section_offsets,
				    SECT_OFF_TEXT (baton->objfile));
  CORE_ADDR base_address = baton->base_address + base_offset;
d205 1
a205 1
  struct gdbarch *arch = get_frame_arch (frame);
d228 3
a230 9
  if (ctx->num_pieces > 0)
    {
      /* We haven't implemented splicing together pieces from
         arbitrary sources yet.  */
      error ("The value of variable '%s' is distributed across several\n"
             "locations, and GDB cannot access its value.\n",
             SYMBOL_NATURAL_NAME (var));
    }
  else if (ctx->in_reg)
d232 2
a233 3
      CORE_ADDR dwarf_regnum = dwarf_expr_fetch (ctx, 0);
      int gdb_regnum = DWARF2_REG_TO_REGNUM (dwarf_regnum);
      retval = value_from_register (SYMBOL_TYPE (var), gdb_regnum, frame);
a236 2
      CORE_ADDR address = dwarf_expr_fetch (ctx, 0);

d242 1
a242 1
      VALUE_ADDRESS (retval) = address;
a321 11
  if (ctx->num_pieces > 0)
    {
      int i;

      /* If the location has several pieces, and any of them are in
         registers, then we will need a frame to fetch them from.  */
      for (i = 0; i < ctx->num_pieces; i++)
        if (ctx->pieces[i].in_reg)
          in_reg = 1;
    }

@


1.14.6.1
log
@2004-05-13  Bryce McKinlay  <mckinlay@@redhat.com>

	* dwarf2loc.c (find_location_expression): Use ANOFFSET to adjust
	base_address for shared libraries.
@
text
@d56 1
a60 4
  /* Adjust base_address for relocatable objects.  */
  CORE_ADDR base_offset = ANOFFSET (baton->objfile->section_offsets,
				    SECT_OFF_TEXT (baton->objfile));
  CORE_ADDR base_address = baton->base_address + base_offset;
@


1.13
log
@	* dwarf2loc.c (dwarf2_loc_desc_needs_frame): Variables in a
	register do need a frame.
@
text
@d157 1
a157 1
  if (SYMBOL_LOCATION_FUNCS (framefunc) == &dwarf2_loclist_funcs)
d468 1
a468 1
struct location_funcs dwarf2_locexpr_funcs = {
d540 1
a540 1
struct location_funcs dwarf2_loclist_funcs = {
@


1.13.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.13.6.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d157 1
a157 1
  if (SYMBOL_OPS (framefunc) == &dwarf2_loclist_funcs)
d468 1
a468 1
const struct symbol_ops dwarf2_locexpr_funcs = {
d540 1
a540 1
const struct symbol_ops dwarf2_loclist_funcs = {
@


1.12
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2loc.c (locexpr_describe_location): Fix typos.
@
text
@d307 1
d320 2
d324 1
a324 1
  return baton.needs_frame;
@


1.11
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	dwarf2loc.c (locexpr_describe_location): Fix typo.
@
text
@d433 1
a433 1
			  "a thread-local variable at offset %s in the"
@


1.10
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* findvar.c (read_var_value): Remove case for thread local storage
	variables.  It is now entirely handled by the dwarf2 location
	expression code.
	* printcmd.c (address_info): Ditto.
	* symtab.h (address_class): Remove LOC_THREAD_LOCAL_STATIC
	enumeration value.
	(struct symbol): Remove objfile field, which was used by
	LOC_THREAD_LOCAL_STATIC only.
	* dwarf2read.c (decode_locdesc): Remove is_thread_local variable.
	* dwarf2loc.h (struct dwarf2_loclist_baton): Add comment about
	usage of objfile pointer.
	* dwarf2loc.c (locexpr_describe_location): Add case to handle
	thread local variables.
	Add include of objfiles.h.
	* dwarf2expr.c (execute_stack_op): Add comments about thread local
	storage variables.
	* Makefile.in (dwarf2loc.o): Update dependencies.
@
text
@d430 1
a430 1
						&dlbaton->data[dlbaton->size - 2],
@


1.9
log
@2003-05-22  Andrew Cagney  <cagney@@redhat.com>

	* stack.c (frame_info): Inline extract_address, replacing it with
	extract_unsigned_integer.
	* findvar.c (unsigned_pointer_to_address): Ditto.
	* dwarf2loc.c (dwarf_expr_read_reg): Ditto.
	* dwarf2expr.c (dwarf2_read_address): Ditto.
	* frame.c (frame_pc_unwind): Update comment.
	* dummy-frame.c (deprecated_read_register_dummy): Update comment.
@
text
@d32 1
d189 2
d411 28
@


1.9.8.1
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* findvar.c (read_var_value): Remove case for thread local storage
	variables.  It is now entirely handled by the dwarf2 location
	expression code.
	* printcmd.c (address_info): Ditto.
	* symtab.h (address_class): Remove LOC_THREAD_LOCAL_STATIC
	enumeration value.
	(struct symbol): Remove objfile field, which was used by
	LOC_THREAD_LOCAL_STATIC only.
	* dwarf2read.c (decode_locdesc): Remove is_thread_local variable.
	* dwarf2loc.h (struct dwarf2_loclist_baton): Add comment about
	usage of objfile pointer.
	* dwarf2loc.c (locexpr_describe_location): Add case to handle
	thread local variables.
	Add include of objfiles.h.
	* dwarf2expr.c (execute_stack_op): Add comments about thread local
	storage variables.
	* Makefile.in (dwarf2loc.o): Update dependencies.
@
text
@a31 1
#include "objfiles.h"
a187 2
  /* It wouldn't be wrong here to try a gdbarch method, too; finding
     TLS is an ABI-specific thing.  But we don't do that yet.  */
a407 28

  /* The location expression for a TLS variable looks like this (on a
     64-bit LE machine):

     DW_AT_location    : 10 byte block: 3 4 0 0 0 0 0 0 0 e0
                        (DW_OP_addr: 4; DW_OP_GNU_push_tls_address)
     
     0x3 is the encoding for DW_OP_addr, which has an operand as long
     as the size of an address on the target machine (here is 8
     bytes).  0xe0 is the encoding for DW_OP_GNU_push_tls_address.
     The operand represents the offset at which the variable is within
     the thread local storage.  */

  if (dlbaton->size > 1 
      && dlbaton->data[dlbaton->size - 1] == DW_OP_GNU_push_tls_address)
    if (dlbaton->data[0] == DW_OP_addr)
      {
	int bytes_read;
	CORE_ADDR offset = dwarf2_read_address (&dlbaton->data[1],
						&dlbaton->data[dlbaton->size - 2],
						&bytes_read);
	fprintf_filtered (stream, 
			  "a thread-local variable at offset %s in the"
			  "thread-local storage for `%s'",
			  paddr_nz (offset), dlbaton->objfile->name);
	return 1;
      }
  
@


1.9.8.2
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	dwarf2loc.c (locexpr_describe_location): Fix typo.
@
text
@d430 1
a430 1
						&dlbaton->data[dlbaton->size - 1],
@


1.9.8.3
log
@2003-07-22  Elena Zannoni  <ezannoni@@redhat.com>

	* dwarf2loc.c (locexpr_describe_location): Fix typos.
@
text
@d433 1
a433 1
			  "a thread-local variable at offset %s in the "
@


1.9.8.4
log
@	* dwarf2loc.c (dwarf2_loc_desc_needs_frame): Variables in a
	register do need a frame.
@
text
@a306 1
  int in_reg;
a318 2
  in_reg = ctx->in_reg;

d321 1
a321 1
  return baton.needs_frame || in_reg;
@


1.8
log
@* dwarf2loc.c (find_location_expression): Change type of second
argument to `size_t *'.
(loclist_read_variable, loclist_tracepoint_var_ref): Use size_t
for size variable.
@
text
@d127 3
a129 1
  result = extract_address (buf, regsize);
@


1.7
log
@	* dwarf2loc.c (dwarf2_evaluate_loc_desc): Invoke DWARF2_REG_TO_REGNUM
	on the DWARF2 register number prior to fetching a register.
@
text
@d53 1
a53 1
			  int *locexpr_length, CORE_ADDR pc)
d451 1
a451 1
  int size;
d493 1
a493 1
  int size;
@


1.6
log
@	* dwarf2expr.h (struct dwarf_expr_context): Remove extra arguments
	to read_reg and update its comment.  Remove regnum member.
	* dwarf2expr.c (execute_stack_op): Remove memaddr and expr_lval.
	Don't call read_reg when setting in_reg.  Call read_reg to get
	the frame base if it's in a register.  Return the register number
	on the stack instead of in the context.  Remove extra arguments
	to read_reg.
	* dwarf2loc.c (dwarf_expr_read_reg): Remove extra arguments.
	(dwarf2_evaluate_loc_desc): Call value_from_register.  Expect
	the register number on the expression stack.
	(needs_frame_read_reg): Remove extra arguments.
@
text
@d226 4
a229 1
    retval = value_from_register (SYMBOL_TYPE (var), result, frame);
@


1.6.2.1
log
@Merge from mainline.
@
text
@d226 1
a226 4
    {
      int regnum = DWARF2_REG_TO_REGNUM (result);
      retval = value_from_register (SYMBOL_TYPE (var), regnum, frame);
    }
@


1.5
log
@2003-04-13  Daniel Jacobowitz  <drow@@mvista.com>

	* dwarf2expr.c (dwarf2_read_address): Renamed from read_address;
	made non-static.
	(execute_stack_op): All callers updated.
	* dwarf2expr.h: Add prototype for dwarf2_read_address.
	* dwarf2loc.c (find_location_expression): New function.
	(dwarf_expr_frame_base): Call it.
	(dwarf2_evaluate_loc_desc): Handle 0-length location expressions.
	(dwarf2_tracepoint_var_ref): New function, broken out from
	locexpr_tracepoint_var_ref.
	(locexpr_tracepoint_var_ref): Call dwarf2_tracepoint_var_ref.
	Make static.
	(loclist_read_variable, loclist_read_needs_frame): New functions.
	(loclist_describe_location, loclist_tracepoint_var_ref): New
	functions.
	(dwarf2_loclist_funcs): New struct location_funcs.
	* dwarf2loc.h (struct dwarf2_loclist_baton): New type.
	(struct dwarf2_locexpr_baton): Add comments.
	(dwarf2_loclist_funcs): New extern.
	* dwarf2read.c (struct comp_unit_head): Remove DIE member, add
	base_address and base_known.
	(dwarf_loc_buffer): New variable.
	(struct dwarf2_pinfo): Add dwarf_loc_buffer and dwarf_loc_size.
	(DWARF_LOC_BUFFER, DWARF_LOC_SIZE): New macros.
	(dwarf2_has_info): Initialize dwarf_loc_offset.
	(dwarf2_build_psymtabs): Read in .debug_loc.
	(dwarf2_build_psymtabs_hard): Use DWARF_LOC_BUFFER and
	DWARF_LOC_SIZE.
	(psymtab_to_symtab_1): Likewise.  Move base address calculation
	here, from...
	(dwarf2_get_pc_bounds): ... here.  Use the base address from
	cu_header.
	(dwarf2_symbol_mark_computed): Handle location lists.
@
text
@d113 1
a113 2
dwarf_expr_read_reg (void *baton, int dwarf_regnum, enum lval_type *lvalp,
		     CORE_ADDR *addrp)
d116 2
a117 1
  CORE_ADDR result;
d125 2
a126 2
  frame_register (debaton->frame, regnum, &optimized, lvalp, addrp, &realnum,
		  buf);
d223 1
a223 3

  retval = allocate_value (SYMBOL_TYPE (var));
  VALUE_BFD_SECTION (retval) = SYMBOL_BFD_SECTION (var);
d226 1
a226 7
    {
      store_unsigned_integer (VALUE_CONTENTS_RAW (retval),
			      TYPE_LENGTH (SYMBOL_TYPE (var)),
			      dwarf_expr_fetch (ctx, 0));
      VALUE_LVAL (retval) = lval_register;
      VALUE_REGNO (retval) = ctx->regnum;
    }
d229 3
a231 1
      result = dwarf_expr_fetch (ctx, 0);
d255 1
a255 2
needs_frame_read_reg (void *baton, int regnum, enum lval_type *lvalp,
			    CORE_ADDR *addrp)
@


1.4
log
@2003-04-01  Andrew Cagney  <cagney@@redhat.com>

	Add frame debug info addresses:
	* frame-base.c: New file.
	* frame-base.h: New file.
	* frame.h (struct frame_base): Add opaque declaration.
	(get_frame_base): Update comment.
	(get_frame_base_address): Declare.
	(get_frame_locals_address): Declare.
	(get_frame_args_address): Declare.
	(struct frame_info): Add "base" and "base_cache".  Update
	comments on the unwinder.
	* frame.c: Include "frame-base.h".
	(get_frame_locals_address): New function.
	(get_frame_base_address): New function.
	(get_frame_args_address): New function.
	* findvar.c (read_var_value): Use get_frame_locals_address and
	get_frame_args_address.
	* stack.c (frame_info): Use get_frame_locals_address and
	get_frame_args_address.
	(FRAME_ARGS_ADDRESS_CORRECT): Delete conditionally defined macro,
	moved to "frame-base.c".
	* printcmd.c (print_frame_nameless_args): Ditto.
	* symtab.h (address_class): Update comments.
	* dwarf2loc.c (dwarf_expr_frame_base): Add note about
	get_frame_base_address.
	* dwarf2expr.c (execute_stack_op): Ditto.
	* Makefile.in (frame_base_h): Define.
	(frame.o): Update dependencies.
	(frame-base.o): Add dependencies.
	(SFILES): Add frame-base.c.
	(COMMON_OBS): Add frame-base.o.
@
text
@d43 56
a149 1
  struct dwarf2_locexpr_baton *symbaton;
d151 1
d153 19
a171 3
  symbaton = SYMBOL_LOCATION_BATON (framefunc);
  *start = symbaton->data;
  *length = symbaton->size;
d205 7
d323 8
d332 31
d364 8
d425 1
a425 1
void
d431 1
a431 45
  if (dlbaton->size == 0)
    error ("Symbol \"%s\" has been optimized out.",
	   SYMBOL_PRINT_NAME (symbol));

  if (dlbaton->size == 1
      && dlbaton->data[0] >= DW_OP_reg0
      && dlbaton->data[0] <= DW_OP_reg31)
    {
      value->kind = axs_lvalue_register;
      value->u.reg = dlbaton->data[0] - DW_OP_reg0;
    }
  else if (dlbaton->data[0] == DW_OP_regx)
    {
      ULONGEST reg;
      read_uleb128 (dlbaton->data + 1, dlbaton->data + dlbaton->size,
		    &reg);
      value->kind = axs_lvalue_register;
      value->u.reg = reg;
    }
  else if (dlbaton->data[0] == DW_OP_fbreg)
    {
      /* And this is worse than just minimal; we should honor the frame base
	 as above.  */
      int frame_reg;
      LONGEST frame_offset;
      unsigned char *buf_end;

      buf_end = read_sleb128 (dlbaton->data + 1, dlbaton->data + dlbaton->size,
			      &frame_offset);
      if (buf_end != dlbaton->data + dlbaton->size)
	error ("Unexpected opcode after DW_OP_fbreg for symbol \"%s\".",
	       SYMBOL_PRINT_NAME (symbol));

      TARGET_VIRTUAL_FRAME_POINTER (ax->scope, &frame_reg, &frame_offset);
      ax_reg (ax, frame_reg);
      ax_const_l (ax, frame_offset);
      ax_simple (ax, aop_add);

      ax_const_l (ax, frame_offset);
      ax_simple (ax, aop_add);
      value->kind = axs_lvalue_memory;
    }
  else
    error ("Unsupported DWARF opcode in the location of \"%s\".",
	   SYMBOL_PRINT_NAME (symbol));
d441 72
@


1.3
log
@	* dwarf2expr.c (new_dwarf_expr_context): Add (void) to definition.
	* dwarf2loc.c: Include "regcache.h".
	(dwarf_expr_read_reg): Rename regnum argument to dwarf_regnum.  Use
	register_size.
	* Makefile.in (dwarf2loc.o): Update dependencies.
@
text
@d90 3
@


1.3.10.1
log
@2003-03-26  Andrew Cagney  <cagney@@redhat.com>

	Add frame debug info addresses:
	* frame-base.c: New file.
	* frame-base.h: New file.
	* frame.h (struct frame_base): Add opaque declaration.
	(get_frame_base): Update comment.
	(get_frame_base_address): Declare.
	(get_frame_locals_address): Declare.
	(get_frame_args_address): Declare.
	(struct frame_info): Add "base" and "base_cache".  Update
	comments on the unwinder.
	* frame.c: Include "frame-base.h".
	(get_frame_locals_address): New function.
	(get_frame_base_address): New function.
	(get_frame_args_address): New function.
	* findvar.c (read_var_value): Use get_frame_locals_address.
	* stack.c (frame_info): Use get_frame_locals_address and
	get_frame_args_address.
	(FRAME_ARGS_ADDRESS_CORRECT): Delete conditionally defined macro,
	moved to "frame-base.c".
	* Makefile.in (frame_base_h): Define.
	(frame.o): Update dependencies.
	(d10v-tdep.o): Update dependencies.
	(frame-base.o): Add dependencies.
	(SFILES): Add frame-base.c.
	(COMMON_OBS): Add frame-base.o.
	* printcmd.c (print_frame_nameless_args): Ditto.
	* symtab.h (address_class): Update comments.
	* dwarf2loc.c (dwarf_expr_frame_base): Add note about
	get_frame_base_address.
	* dwarf2expr.c (execute_stack_op): Ditto.
	* d10v-tdep.c: Include "frame-base.h".
	(d10v_frame_unwind): Make constant.
	(d10v_frame_base_address): New function.
	(d10v_frame_base): New variable.
	(d10v_gdbarch_init): Set frame_base default.
@
text
@a89 3
  /* FIXME: cagney/2003-03-26: This code should be using
     get_frame_base_address(), and then implement a dwarf2 specific
     this_base method.  */
@


1.3.2.1
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d121 1
a121 1
dwarf2_evaluate_loc_desc (const struct symbol *var, struct frame_info *frame,
d247 1
a247 1
locexpr_read_variable (const struct symbol *symbol, struct frame_info *frame)
d259 1
a259 1
locexpr_read_needs_frame (const struct symbol *symbol)
d267 1
a267 1
locexpr_describe_location (const struct symbol *symbol, struct ui_file *stream)
d297 1
a297 2
locexpr_tracepoint_var_ref (const struct symbol * symbol,
			    struct agent_expr * ax,
@


1.3.2.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@a42 56
/* A helper function for dealing with location lists.  Given a
   symbol baton (BATON) and a pc value (PC), find the appropriate
   location expression, set *LOCEXPR_LENGTH, and return a pointer
   to the beginning of the expression.  Returns NULL on failure.

   For now, only return the first matching location expression; there
   can be more than one in the list.  */

static char *
find_location_expression (struct dwarf2_loclist_baton *baton,
			  int *locexpr_length, CORE_ADDR pc)
{
  CORE_ADDR base_address = baton->base_address;
  CORE_ADDR low, high;
  char *loc_ptr, *buf_end;
  unsigned int addr_size = TARGET_ADDR_BIT / TARGET_CHAR_BIT, length;
  CORE_ADDR base_mask = ~(~(CORE_ADDR)1 << (addr_size * 8 - 1));

  loc_ptr = baton->data;
  buf_end = baton->data + baton->size;

  while (1)
    {
      low = dwarf2_read_address (loc_ptr, buf_end, &length);
      loc_ptr += length;
      high = dwarf2_read_address (loc_ptr, buf_end, &length);
      loc_ptr += length;

      /* An end-of-list entry.  */
      if (low == 0 && high == 0)
	return NULL;

      /* A base-address-selection entry.  */
      if ((low & base_mask) == base_mask)
	{
	  base_address = high;
	  continue;
	}

      /* Otherwise, a location expression entry.  */
      low += base_address;
      high += base_address;

      length = extract_unsigned_integer (loc_ptr, 2);
      loc_ptr += 2;

      if (pc >= low && pc < high)
	{
	  *locexpr_length = length;
	  return loc_ptr;
	}

      loc_ptr += length;
    }
}

d57 2
a58 1
dwarf_expr_read_reg (void *baton, int dwarf_regnum)
d61 1
a61 2
  CORE_ADDR result, save_addr;
  enum lval_type lval_type;
d69 2
a70 2
  frame_register (debaton->frame, regnum, &optimized, &lval_type, &save_addr,
		  &realnum, buf);
a89 3
  /* FIXME: cagney/2003-03-26: This code should be using
     get_frame_base_address(), and then implement a dwarf2 specific
     this_base method.  */
d91 1
a92 1

d94 3
a96 19

  if (SYMBOL_LOCATION_FUNCS (framefunc) == &dwarf2_loclist_funcs)
    {
      struct dwarf2_loclist_baton *symbaton;
      symbaton = SYMBOL_LOCATION_BATON (framefunc);
      *start = find_location_expression (symbaton, length,
					 get_frame_pc (debaton->frame));
    }
  else
    {
      struct dwarf2_locexpr_baton *symbaton;
      symbaton = SYMBOL_LOCATION_BATON (framefunc);
      *length = symbaton->size;
      *start = symbaton->data;
    }

  if (*start == NULL)
    error ("Could not find the frame base for \"%s\".",
	   SYMBOL_NATURAL_NAME (framefunc));
a129 7
  if (size == 0)
    {
      retval = allocate_value (SYMBOL_TYPE (var));
      VALUE_LVAL (retval) = not_lval;
      VALUE_OPTIMIZED_OUT (retval) = 1;
    }

d141 3
a143 1
  result = dwarf_expr_fetch (ctx, 0);
d146 7
a152 1
    retval = value_from_register (SYMBOL_TYPE (var), result, frame);
d155 1
a155 3
      retval = allocate_value (SYMBOL_TYPE (var));
      VALUE_BFD_SECTION (retval) = SYMBOL_BFD_SECTION (var);

d179 2
a180 1
needs_frame_read_reg (void *baton, int regnum)
a240 36
static void
dwarf2_tracepoint_var_ref (const struct symbol * symbol,
			   struct agent_expr * ax,
			   struct axs_value * value, unsigned char *data,
			   int size)
{
  if (size == 0)
    error ("Symbol \"%s\" has been optimized out.",
	   SYMBOL_PRINT_NAME (symbol));

  if (size == 1
      && data[0] >= DW_OP_reg0
      && data[0] <= DW_OP_reg31)
    {
      value->kind = axs_lvalue_register;
      value->u.reg = data[0] - DW_OP_reg0;
    }
  else if (data[0] == DW_OP_regx)
    {
      ULONGEST reg;
      read_uleb128 (data + 1, data + size, &reg);
      value->kind = axs_lvalue_register;
      value->u.reg = reg;
    }
  else if (data[0] == DW_OP_fbreg)
    {
      /* And this is worse than just minimal; we should honor the frame base
	 as above.  */
      int frame_reg;
      LONGEST frame_offset;
      unsigned char *buf_end;

      buf_end = read_sleb128 (data + 1, data + size, &frame_offset);
      if (buf_end != data + size)
	error ("Unexpected opcode after DW_OP_fbreg for symbol \"%s\".",
	       SYMBOL_PRINT_NAME (symbol));
a241 4
      TARGET_VIRTUAL_FRAME_POINTER (ax->scope, &frame_reg, &frame_offset);
      ax_reg (ax, frame_reg);
      ax_const_l (ax, frame_offset);
      ax_simple (ax, aop_add);
a242 8
      ax_const_l (ax, frame_offset);
      ax_simple (ax, aop_add);
      value->kind = axs_lvalue_memory;
    }
  else
    error ("Unsupported DWARF opcode in the location of \"%s\".",
	   SYMBOL_PRINT_NAME (symbol));
}
d296 1
a296 1
static void
d303 45
a347 1
  dwarf2_tracepoint_var_ref (symbol, ax, value, dlbaton->data, dlbaton->size);
a356 73
};


/* Wrapper functions for location lists.  These generally find
   the appropriate location expression and call something above.  */

/* Return the value of SYMBOL in FRAME using the DWARF-2 expression
   evaluator to calculate the location.  */
static struct value *
loclist_read_variable (const struct symbol *symbol, struct frame_info *frame)
{
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  struct value *val;
  unsigned char *data;
  int size;

  data = find_location_expression (dlbaton, &size,
				   frame ? get_frame_pc (frame) : 0);
  if (data == NULL)
    error ("Variable \"%s\" is not available.", SYMBOL_NATURAL_NAME (symbol));

  val = dwarf2_evaluate_loc_desc (symbol, frame, data, size, dlbaton->objfile);

  return val;
}

/* Return non-zero iff we need a frame to evaluate SYMBOL.  */
static int
loclist_read_needs_frame (const struct symbol *symbol)
{
  /* If there's a location list, then assume we need to have a frame
     to choose the appropriate location expression.  With tracking of
     global variables this is not necessarily true, but such tracking
     is disabled in GCC at the moment until we figure out how to
     represent it.  */

  return 1;
}

/* Print a natural-language description of SYMBOL to STREAM.  */
static int
loclist_describe_location (const struct symbol *symbol, struct ui_file *stream)
{
  /* FIXME: Could print the entire list of locations.  */
  fprintf_filtered (stream, "a variable with multiple locations");
  return 1;
}

/* Describe the location of SYMBOL as an agent value in VALUE, generating
   any necessary bytecode in AX.  */
static void
loclist_tracepoint_var_ref (const struct symbol * symbol,
			    struct agent_expr * ax,
			    struct axs_value * value)
{
  struct dwarf2_loclist_baton *dlbaton = SYMBOL_LOCATION_BATON (symbol);
  unsigned char *data;
  int size;

  data = find_location_expression (dlbaton, &size, ax->scope);
  if (data == NULL)
    error ("Variable \"%s\" is not available.", SYMBOL_NATURAL_NAME (symbol));

  dwarf2_tracepoint_var_ref (symbol, ax, value, data, size);
}

/* The set of location functions used with the DWARF-2 expression
   evaluator and location lists.  */
struct location_funcs dwarf2_loclist_funcs = {
  loclist_read_variable,
  loclist_read_needs_frame,
  loclist_describe_location,
  loclist_tracepoint_var_ref
@


1.3.2.3
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d226 1
a226 4
    {
      int regnum = DWARF2_REG_TO_REGNUM (result);
      retval = value_from_register (SYMBOL_TYPE (var), regnum, frame);
    }
@


1.3.2.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d53 1
a53 1
			  size_t *locexpr_length, CORE_ADDR pc)
d127 1
a127 3
  /* NOTE: cagney/2003-05-22: This extract is assuming that a DWARF 2
     address is always unsigned.  That may or may not be true.  */
  result = extract_unsigned_integer (buf, regsize);
d453 1
a453 1
  size_t size;
d496 1
a496 1
  size_t size;
@


1.3.2.5
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a31 1
#include "objfiles.h"
a187 2
  /* It wouldn't be wrong here to try a gdbarch method, too; finding
     TLS is an ABI-specific thing.  But we don't do that yet.  */
a408 28

  /* The location expression for a TLS variable looks like this (on a
     64-bit LE machine):

     DW_AT_location    : 10 byte block: 3 4 0 0 0 0 0 0 0 e0
                        (DW_OP_addr: 4; DW_OP_GNU_push_tls_address)
     
     0x3 is the encoding for DW_OP_addr, which has an operand as long
     as the size of an address on the target machine (here is 8
     bytes).  0xe0 is the encoding for DW_OP_GNU_push_tls_address.
     The operand represents the offset at which the variable is within
     the thread local storage.  */

  if (dlbaton->size > 1 
      && dlbaton->data[dlbaton->size - 1] == DW_OP_GNU_push_tls_address)
    if (dlbaton->data[0] == DW_OP_addr)
      {
	int bytes_read;
	CORE_ADDR offset = dwarf2_read_address (&dlbaton->data[1],
						&dlbaton->data[dlbaton->size - 1],
						&bytes_read);
	fprintf_filtered (stream, 
			  "a thread-local variable at offset %s in the "
			  "thread-local storage for `%s'",
			  paddr_nz (offset), dlbaton->objfile->name);
	return 1;
      }
  
@


1.3.2.6
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@a306 1
  int in_reg;
a318 2
  in_reg = ctx->in_reg;

d321 1
a321 1
  return baton.needs_frame || in_reg;
@


1.2
log
@	* Makefile.in (dwarf2loc.o): Update dependencies.
	* ax-gdb.c (gen_var_ref): Handle LOC_COMPUTED and LOC_COMPUTED_ARG.
	* dwarf2expr.c (read_uleb128, read_sleb128): Make non-static.
	* dwarf2expr.h (read_uleb128, read_sleb128): Add prototypes.
	* dwarf2loc.c: Include "ax.h" and "ax-gdb.h".
	(locexpr_tracepoint_var_ref): New function.
	(dwarf2_locexpr_funcs): Add locexpr_tracepoint_var_ref.
@
text
@d31 1
d57 1
a57 1
dwarf_expr_read_reg (void *baton, int regnum, enum lval_type *lvalp,
d60 1
d62 2
a63 3
  struct dwarf_expr_baton *debaton = (struct dwarf_expr_baton *) baton;
  char *buf = (char *) alloca (MAX_REGISTER_RAW_SIZE);
  int optimized, realnum;
d65 7
a71 3
  frame_register (debaton->frame, DWARF2_REG_TO_REGNUM (regnum),
		  &optimized, lvalp, addrp, &realnum, buf);
  result = extract_address (buf, REGISTER_RAW_SIZE (regnum));
@


1.1
log
@	Based on a patch from Daniel Berlin (dberlin@@dberlin.org).
	* symtab.h: Add opaque declarations of struct axs_value and
	struct agent_expr.
	(enum address_class): Add LOC_COMPUTED and LOC_COMPUTED_ARG.
	(struct location_funcs): New type.
	(struct symbol): Add "loc" to aux_value.
	(SYMBOL_LOCATION_BATON, SYMBOL_LOCATION_FUNCS): New macros.
	* dwarf2read.c: Include "dwarf2expr.h".
	(dwarf2_symbol_mark_computed): New function.
	(read_func_scope): Use it.
	(var_decode_location): New function.
	(new_symbol): Use it.
	* dwarf2expr.c, dwarf2expr.h, dwarf2loc.c, dwarf2loc.h: New files.

	* Makefile.in (SFILES): Add dwarf2loc.c and dwarf2expr.c.
	(dwarf2expr_h, dwarf2loc_h): New variables.
	(COMMON_OBS): Add dwarf2expr.o and dwarf2loc.o.
	(dwarf2expr.o, dwarf2loc.o): New rules.
	(dwarf2read.o): Add $(dwarf2expr_h) and $(dwarf2loc_h).
	* buildsym.c (finish_block): Handle LOC_COMPUTED and
	LOC_COMPUTED_ARG.
	* findvar.c (symbol_read_needs_frame, read_var_value): Likewise.
	* m2-exp.y (yylex): Likewise.
	* printcmd.c (address_info, print_frame_args): Likewise.
	* stack.c (print_block_frame_locals, print_frame_arg_vars): Likewise.
	* symmisc.c (print_symbol, print_partial_symbols): Likewise.
	* ada-lang.c (ada_resolve_subexp, symtab_for_sym)
	(ada_add_block_symbols, fill_in_ada_prototype): Likewise.
	* symtab.c (lookup_block_symbol): Likewise.
@
text
@d29 2
d282 62
d350 1
a350 1
  NULL
@

